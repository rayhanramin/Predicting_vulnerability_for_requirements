<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 1757:0e339aad00cf357d0a609e0a857bae05ca83c0f5</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 0e339aad00cf357d0a609e0a857bae05ca83c0f5" />
<meta property="og:url" content="/comm-central/rev/0e339aad00cf357d0a609e0a857bae05ca83c0f5" />
<meta property="og:description" content="Bug 444932 - &quot;nsMsgMessageFlags.h should be an idl file&quot; [r+sr=Standard8]" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 0e339aad00cf357d0a609e0a857bae05ca83c0f5 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/0e339aad00cf357d0a609e0a857bae05ca83c0f5">shortlog</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/0e339aad00cf357d0a609e0a857bae05ca83c0f5">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5">files</a> |
changeset |
<a href="/comm-central/raw-rev/0e339aad00cf357d0a609e0a857bae05ca83c0f5">raw</a>  | <a href="/comm-central/archive/0e339aad00cf357d0a609e0a857bae05ca83c0f5.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=444932">Bug 444932</a> - &quot;nsMsgMessageFlags.h should be an idl file&quot; [r+sr=Standard8]
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#83;&#105;&#100;&#100;&#104;&#97;&#114;&#116;&#104;&#32;&#65;&#103;&#97;&#114;&#119;&#97;&#108;&#32;&#60;&#115;&#105;&#100;&#46;&#98;&#117;&#103;&#122;&#105;&#108;&#108;&#97;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Mon, 26 Jan 2009 14:14:32 +0000</td></tr>

<tr>
 <td>changeset 1757</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/0e339aad00cf357d0a609e0a857bae05ca83c0f5">0e339aad00cf357d0a609e0a857bae05ca83c0f5</a></td>
</tr>



<tr>
<td>parent 1756</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/d4ff0342ca4eb1630a3c889fa0c45c7c8099a485">d4ff0342ca4eb1630a3c889fa0c45c7c8099a485</a>
</td>
</tr>

<tr>
<td>child 1758</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/0ce79e592a21b9e4da574968d64d49a7541a4d30">0ce79e592a21b9e4da574968d64d49a7541a4d30</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=0e339aad00cf357d0a609e0a857bae05ca83c0f5">1411</a></td></tr>
<tr><td>push user</td><td>bugzilla@standard8.plus.com</td></tr>
<tr><td>push date</td><td class="date age">Mon, 26 Jan 2009 14:15:23 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@0e339aad00cf [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=0e339aad00cf357d0a609e0a857bae05ca83c0f5">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=0e339aad00cf357d0a609e0a857bae05ca83c0f5&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=0e339aad00cf357d0a609e0a857bae05ca83c0f5&newProject=comm-central&newRevision=0e339aad00cf357d0a609e0a857bae05ca83c0f5&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=0e339aad00cf357d0a609e0a857bae05ca83c0f5&newProject=comm-central&newRevision=0e339aad00cf357d0a609e0a857bae05ca83c0f5&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=0e339aad00cf357d0a609e0a857bae05ca83c0f5&newProject=comm-central&newRevision=0e339aad00cf357d0a609e0a857bae05ca83c0f5&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>

<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=444932">444932</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=444932">Bug 444932</a> - &quot;nsMsgMessageFlags.h should be an idl file&quot; [r+sr=Standard8]</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/public/nsMsgMessageFlags.idl">mailnews/base/public/nsMsgMessageFlags.idl</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/public/nsMsgMessageFlags.idl">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/public/nsMsgMessageFlags.idl">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/public/nsMsgMessageFlags.idl">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/public/nsMsgMessageFlags.idl">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/public/nsMsgMessageFlags.idl">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgFilterService.cpp">mailnews/base/search/src/nsMsgFilterService.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgFilterService.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgFilterService.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgFilterService.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgFilterService.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgFilterService.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgLocalSearch.cpp">mailnews/base/search/src/nsMsgLocalSearch.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgLocalSearch.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgLocalSearch.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgLocalSearch.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgLocalSearch.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgLocalSearch.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgSearchAdapter.cpp">mailnews/base/search/src/nsMsgSearchAdapter.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgSearchAdapter.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgSearchAdapter.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgSearchAdapter.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgSearchAdapter.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgSearchAdapter.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgSearchTerm.cpp">mailnews/base/search/src/nsMsgSearchTerm.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgSearchTerm.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgSearchTerm.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgSearchTerm.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgSearchTerm.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/search/src/nsMsgSearchTerm.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMessenger.cpp">mailnews/base/src/nsMessenger.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMessenger.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMessenger.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMessenger.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMessenger.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMessenger.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgAccountManager.cpp">mailnews/base/src/nsMsgAccountManager.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgAccountManager.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgAccountManager.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgAccountManager.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgAccountManager.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgAccountManager.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgDBView.cpp">mailnews/base/src/nsMsgDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgDBView.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgDBView.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgDBView.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgDBView.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgFolderCompactor.cpp">mailnews/base/src/nsMsgFolderCompactor.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgFolderCompactor.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgFolderCompactor.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgFolderCompactor.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgFolderCompactor.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgFolderCompactor.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgGroupThread.cpp">mailnews/base/src/nsMsgGroupThread.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgGroupThread.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgGroupThread.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgGroupThread.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgGroupThread.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgGroupThread.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgGroupView.cpp">mailnews/base/src/nsMsgGroupView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgGroupView.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgGroupView.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgGroupView.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgGroupView.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgGroupView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgQuickSearchDBView.cpp">mailnews/base/src/nsMsgQuickSearchDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgQuickSearchDBView.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgQuickSearchDBView.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgQuickSearchDBView.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgQuickSearchDBView.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgQuickSearchDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgSearchDBView.cpp">mailnews/base/src/nsMsgSearchDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgSearchDBView.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgSearchDBView.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgSearchDBView.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgSearchDBView.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgSearchDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgSpecialViews.cpp">mailnews/base/src/nsMsgSpecialViews.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgSpecialViews.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgSpecialViews.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgSpecialViews.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgSpecialViews.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgSpecialViews.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgThreadedDBView.cpp">mailnews/base/src/nsMsgThreadedDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgThreadedDBView.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgThreadedDBView.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgThreadedDBView.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgThreadedDBView.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgThreadedDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgXFViewThread.cpp">mailnews/base/src/nsMsgXFViewThread.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgXFViewThread.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgXFViewThread.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgXFViewThread.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgXFViewThread.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgXFViewThread.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgDBFolder.cpp">mailnews/base/util/nsMsgDBFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgDBFolder.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgDBFolder.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgDBFolder.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgDBFolder.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgDBFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgDBFolder.h">mailnews/base/util/nsMsgDBFolder.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgDBFolder.h">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgDBFolder.h">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgDBFolder.h">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgDBFolder.h">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgDBFolder.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgTxn.cpp">mailnews/base/util/nsMsgTxn.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgTxn.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgTxn.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgTxn.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgTxn.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/base/util/nsMsgTxn.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgCompose.cpp">mailnews/compose/src/nsMsgCompose.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgCompose.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgCompose.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgCompose.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgCompose.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgCompose.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgCopy.cpp">mailnews/compose/src/nsMsgCopy.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgCopy.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgCopy.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgCopy.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgCopy.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgCopy.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgSend.cpp">mailnews/compose/src/nsMsgSend.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgSend.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgSend.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgSend.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgSend.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/compose/src/nsMsgSend.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsImapMailDatabase.h">mailnews/db/msgdb/public/nsImapMailDatabase.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsImapMailDatabase.h">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsImapMailDatabase.h">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsImapMailDatabase.h">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsImapMailDatabase.h">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsImapMailDatabase.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsMailDatabase.h">mailnews/db/msgdb/public/nsMailDatabase.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsMailDatabase.h">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsMailDatabase.h">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsMailDatabase.h">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsMailDatabase.h">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsMailDatabase.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsMsgDatabase.h">mailnews/db/msgdb/public/nsMsgDatabase.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsMsgDatabase.h">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsMsgDatabase.h">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsMsgDatabase.h">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsMsgDatabase.h">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/public/nsMsgDatabase.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsImapMailDatabase.cpp">mailnews/db/msgdb/src/nsImapMailDatabase.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsImapMailDatabase.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsImapMailDatabase.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsImapMailDatabase.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsImapMailDatabase.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsImapMailDatabase.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMailDatabase.cpp">mailnews/db/msgdb/src/nsMailDatabase.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMailDatabase.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMailDatabase.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMailDatabase.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMailDatabase.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMailDatabase.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgDatabase.cpp">mailnews/db/msgdb/src/nsMsgDatabase.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgDatabase.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgDatabase.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgDatabase.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgDatabase.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgDatabase.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgHdr.cpp">mailnews/db/msgdb/src/nsMsgHdr.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgHdr.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgHdr.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgHdr.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgHdr.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgHdr.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgThread.cpp">mailnews/db/msgdb/src/nsMsgThread.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgThread.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgThread.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgThread.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgThread.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsMsgThread.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsNewsDatabase.cpp">mailnews/db/msgdb/src/nsNewsDatabase.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsNewsDatabase.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsNewsDatabase.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsNewsDatabase.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsNewsDatabase.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/db/msgdb/src/nsNewsDatabase.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsAutoSyncManager.cpp">mailnews/imap/src/nsAutoSyncManager.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsAutoSyncManager.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsAutoSyncManager.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsAutoSyncManager.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsAutoSyncManager.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsAutoSyncManager.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsAutoSyncState.cpp">mailnews/imap/src/nsAutoSyncState.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsAutoSyncState.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsAutoSyncState.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsAutoSyncState.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsAutoSyncState.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsAutoSyncState.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapMailFolder.cpp">mailnews/imap/src/nsImapMailFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapMailFolder.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapMailFolder.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapMailFolder.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapMailFolder.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapMailFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapOfflineSync.cpp">mailnews/imap/src/nsImapOfflineSync.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapOfflineSync.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapOfflineSync.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapOfflineSync.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapOfflineSync.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapOfflineSync.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapProtocol.cpp">mailnews/imap/src/nsImapProtocol.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapProtocol.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapProtocol.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapProtocol.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapProtocol.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapProtocol.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapService.cpp">mailnews/imap/src/nsImapService.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapService.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapService.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapService.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapService.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/imap/src/nsImapService.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/import/applemail/src/nsEmlxHelperUtils.mm">mailnews/import/applemail/src/nsEmlxHelperUtils.mm</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/import/applemail/src/nsEmlxHelperUtils.mm">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/import/applemail/src/nsEmlxHelperUtils.mm">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/import/applemail/src/nsEmlxHelperUtils.mm">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/import/applemail/src/nsEmlxHelperUtils.mm">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/import/applemail/src/nsEmlxHelperUtils.mm">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/import/eudora/src/nsEudoraMailbox.cpp">mailnews/import/eudora/src/nsEudoraMailbox.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/import/eudora/src/nsEudoraMailbox.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/import/eudora/src/nsEudoraMailbox.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/import/eudora/src/nsEudoraMailbox.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/import/eudora/src/nsEudoraMailbox.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/import/eudora/src/nsEudoraMailbox.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsLocalMailFolder.cpp">mailnews/local/src/nsLocalMailFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsLocalMailFolder.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsLocalMailFolder.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsLocalMailFolder.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsLocalMailFolder.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsLocalMailFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsParseMailbox.cpp">mailnews/local/src/nsParseMailbox.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsParseMailbox.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsParseMailbox.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsParseMailbox.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsParseMailbox.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsParseMailbox.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsPop3Protocol.cpp">mailnews/local/src/nsPop3Protocol.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsPop3Protocol.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsPop3Protocol.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsPop3Protocol.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsPop3Protocol.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsPop3Protocol.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsPop3Sink.cpp">mailnews/local/src/nsPop3Sink.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsPop3Sink.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsPop3Sink.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsPop3Sink.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsPop3Sink.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/local/src/nsPop3Sink.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/mapi/mapihook/src/msgMapiImp.cpp">mailnews/mapi/mapihook/src/msgMapiImp.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/mapi/mapihook/src/msgMapiImp.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/mapi/mapihook/src/msgMapiImp.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/mapi/mapihook/src/msgMapiImp.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/mapi/mapihook/src/msgMapiImp.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/mapi/mapihook/src/msgMapiImp.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/mime/src/mimemsg.cpp">mailnews/mime/src/mimemsg.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/mime/src/mimemsg.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/mime/src/mimemsg.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/mime/src/mimemsg.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/mime/src/mimemsg.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/mime/src/mimemsg.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/news/src/nsNNTPNewsgroupList.cpp">mailnews/news/src/nsNNTPNewsgroupList.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/news/src/nsNNTPNewsgroupList.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/news/src/nsNNTPNewsgroupList.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/news/src/nsNNTPNewsgroupList.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/news/src/nsNNTPNewsgroupList.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/news/src/nsNNTPNewsgroupList.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/news/src/nsNewsDownloader.cpp">mailnews/news/src/nsNewsDownloader.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/news/src/nsNewsDownloader.cpp">file</a> |
<a href="/comm-central/annotate/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/news/src/nsNewsDownloader.cpp">annotate</a> |
<a href="/comm-central/diff/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/news/src/nsNewsDownloader.cpp">diff</a> |
<a href="/comm-central/comparison/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/news/src/nsNewsDownloader.cpp">comparison</a> |
<a href="/comm-central/log/0e339aad00cf357d0a609e0a857bae05ca83c0f5/mailnews/news/src/nsNewsDownloader.cpp">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/base/public/nsMsgMessageFlags.idl</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/base/public/nsMsgMessageFlags.idl</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -165,41 +165,8 @@ interface nsMsgProcessingFlags</span>
<a href="#l1.4"></a><span id="l1.4">   const nsMsgProcessingFlagType ClassifyJunk   = 0x00000001;</span>
<a href="#l1.5"></a><span id="l1.5"> </span>
<a href="#l1.6"></a><span id="l1.6">   /// This message needs traits classification</span>
<a href="#l1.7"></a><span id="l1.7">   const nsMsgProcessingFlagType ClassifyTraits = 0x00000002;</span>
<a href="#l1.8"></a><span id="l1.8"> </span>
<a href="#l1.9"></a><span id="l1.9">   /// Number of processing flags</span>
<a href="#l1.10"></a><span id="l1.10">   const nsMsgProcessingFlagType NumberOfFlags  = 2;</span>
<a href="#l1.11"></a><span id="l1.11"> };</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineminus">-%{C++</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineminus">-</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineminus">-typedef PRInt32 MsgFlags;</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineminus">-</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineminus">-#define MSG_FLAG_READ              nsMsgMessageFlags::Read</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineminus">-#define MSG_FLAG_REPLIED           nsMsgMessageFlags::Replied</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineminus">-#define MSG_FLAG_MARKED            nsMsgMessageFlags::Marked</span>
<a href="#l1.20"></a><span id="l1.20" class="difflineminus">-#define MSG_FLAG_EXPUNGED          nsMsgMessageFlags::Expunged</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineminus">-#define MSG_FLAG_HAS_RE            nsMsgMessageFlags::HasRe</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineminus">-#define MSG_FLAG_ELIDED            nsMsgMessageFlags::Elided</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineminus">-#define MSG_FLAG_OFFLINE           nsMsgMessageFlags::Offline</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineminus">-#define MSG_FLAG_WATCHED           nsMsgMessageFlags::Watched</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineminus">-#define MSG_FLAG_SENDER_AUTHED     nsMsgMessageFlags::SenderAuthed</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineminus">-#define MSG_FLAG_PARTIAL           nsMsgMessageFlags::Partial</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineminus">-#define MSG_FLAG_QUEUED            nsMsgMessageFlags::Queued</span>
<a href="#l1.28"></a><span id="l1.28" class="difflineminus">-#define MSG_FLAG_FORWARDED         nsMsgMessageFlags::Forwarded</span>
<a href="#l1.29"></a><span id="l1.29" class="difflineminus">-#define MSG_FLAG_PRIORITIES        nsMsgMessageFlags::Priorities</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineminus">-#define MSG_FLAG_NEW               nsMsgMessageFlags::New</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineminus">-#define MSG_FLAG_IGNORED           nsMsgMessageFlags::Ignored</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineminus">-#define MSG_FLAG_IMAP_DELETED      nsMsgMessageFlags::IMAPDeleted</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineminus">-#define MSG_FLAG_MDN_REPORT_NEEDED nsMsgMessageFlags::MDNReportNeeded</span>
<a href="#l1.34"></a><span id="l1.34" class="difflineminus">-#define MSG_FLAG_MDN_REPORT_SENT   nsMsgMessageFlags::MDNReportSent</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineminus">-#define MSG_FLAG_TEMPLATE          nsMsgMessageFlags::Template</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineminus">-#define MSG_FLAG_ATTACHMENT        nsMsgMessageFlags::Attachment</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineminus">-#define MSG_FLAG_LABELS            nsMsgMessageFlags::Labels</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineminus">-#define MSG_FLAG_RUNTIME_ONLY      nsMsgMessageFlags::RuntimeOnly</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineminus">-</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineminus">-#define MSG_PROCESSING_FLAG_CLASSIFY_JUNK   nsMsgProcessingFlags::ClassifyJunk</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineminus">-#define MSG_PROCESSING_FLAG_CLASSIFY_TRAITS nsMsgProcessingFlags::ClassifyTraits</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineminus">-#define MSG_NUMBER_OF_PROCESSING_FLAGS      nsMsgProcessingFlags::NumberOfFlags</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineminus">-</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineminus">-%}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/base/search/src/nsMsgFilterService.cpp</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/base/search/src/nsMsgFilterService.cpp</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -702,17 +702,17 @@ nsresult nsMsgFilterAfterTheFact::ApplyF</span>
<a href="#l2.4"></a><span id="l2.4">             for (PRUint32 msgIndex = 0; msgIndex &lt; m_searchHits.Length(); msgIndex++)</span>
<a href="#l2.5"></a><span id="l2.5">             {</span>
<a href="#l2.6"></a><span id="l2.6">               nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l2.7"></a><span id="l2.7">               m_searchHitHdrs-&gt;QueryElementAt(msgIndex, NS_GET_IID(nsIMsgDBHdr), getter_AddRefs(msgHdr));</span>
<a href="#l2.8"></a><span id="l2.8">               if (msgHdr)</span>
<a href="#l2.9"></a><span id="l2.9">               {</span>
<a href="#l2.10"></a><span id="l2.10">                 PRUint32 flags;</span>
<a href="#l2.11"></a><span id="l2.11">                 msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-                if (flags &amp; MSG_FLAG_PARTIAL)</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+                if (flags &amp; nsMsgMessageFlags::Partial)</span>
<a href="#l2.14"></a><span id="l2.14">                 {</span>
<a href="#l2.15"></a><span id="l2.15">                   if (!partialMsgs)</span>
<a href="#l2.16"></a><span id="l2.16">                     partialMsgs = do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv);</span>
<a href="#l2.17"></a><span id="l2.17">                   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l2.18"></a><span id="l2.18">                   partialMsgs-&gt;AppendElement(msgHdr, PR_FALSE);</span>
<a href="#l2.19"></a><span id="l2.19">                 }</span>
<a href="#l2.20"></a><span id="l2.20">               }</span>
<a href="#l2.21"></a><span id="l2.21">             }</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineat">@@ -731,17 +731,17 @@ nsresult nsMsgFilterAfterTheFact::ApplyF</span>
<a href="#l2.23"></a><span id="l2.23">             for (PRUint32 msgIndex = 0; msgIndex &lt; m_searchHits.Length(); msgIndex++)</span>
<a href="#l2.24"></a><span id="l2.24">             {</span>
<a href="#l2.25"></a><span id="l2.25">               nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l2.26"></a><span id="l2.26">               m_searchHitHdrs-&gt;QueryElementAt(msgIndex, NS_GET_IID(nsIMsgDBHdr), getter_AddRefs(msgHdr));</span>
<a href="#l2.27"></a><span id="l2.27">               if (msgHdr)</span>
<a href="#l2.28"></a><span id="l2.28">               {</span>
<a href="#l2.29"></a><span id="l2.29">                 PRUint32 flags = 0;</span>
<a href="#l2.30"></a><span id="l2.30">                 msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineminus">-                if (flags &amp; MSG_FLAG_PARTIAL)</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+                if (flags &amp; nsMsgMessageFlags::Partial)</span>
<a href="#l2.33"></a><span id="l2.33">                   messages-&gt;AppendElement(msgHdr, PR_FALSE);</span>
<a href="#l2.34"></a><span id="l2.34">               }</span>
<a href="#l2.35"></a><span id="l2.35">             }</span>
<a href="#l2.36"></a><span id="l2.36">             PRUint32 msgsToFetch;</span>
<a href="#l2.37"></a><span id="l2.37">             messages-&gt;GetLength(&amp;msgsToFetch);</span>
<a href="#l2.38"></a><span id="l2.38">             if (msgsToFetch &gt; 0)</span>
<a href="#l2.39"></a><span id="l2.39">               m_curFolder-&gt;DownloadMessagesForOffline(messages, m_msgWindow);</span>
<a href="#l2.40"></a><span id="l2.40">           }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/base/search/src/nsMsgLocalSearch.cpp</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/base/search/src/nsMsgLocalSearch.cpp</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -465,17 +465,17 @@ nsresult nsMsgSearchOfflineMail::Process</span>
<a href="#l3.4"></a><span id="l3.4">     {</span>
<a href="#l3.5"></a><span id="l3.5">       case nsMsgSearchAttrib::Sender:</span>
<a href="#l3.6"></a><span id="l3.6">         msgToMatch-&gt;GetAuthor(getter_Copies(matchString));</span>
<a href="#l3.7"></a><span id="l3.7">         err = aTerm-&gt;MatchRfc822String (matchString.get(), charset, charsetOverride, &amp;result);</span>
<a href="#l3.8"></a><span id="l3.8">         break;</span>
<a href="#l3.9"></a><span id="l3.9">       case nsMsgSearchAttrib::Subject:</span>
<a href="#l3.10"></a><span id="l3.10">       {</span>
<a href="#l3.11"></a><span id="l3.11">         msgToMatch-&gt;GetSubject(getter_Copies(matchString) /* , PR_TRUE */);</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-        if (msgFlags &amp; MSG_FLAG_HAS_RE)</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+        if (msgFlags &amp; nsMsgMessageFlags::HasRe)</span>
<a href="#l3.14"></a><span id="l3.14">         {</span>
<a href="#l3.15"></a><span id="l3.15">           // Make sure we pass along the &quot;Re: &quot; part of the subject if this is a reply.</span>
<a href="#l3.16"></a><span id="l3.16">           nsCString reString;</span>
<a href="#l3.17"></a><span id="l3.17">           reString.Assign(&quot;Re: &quot;);</span>
<a href="#l3.18"></a><span id="l3.18">           reString.Append(matchString);</span>
<a href="#l3.19"></a><span id="l3.19">           err = aTerm-&gt;MatchRfc2047String(reString.get(), charset, charsetOverride, &amp;result);</span>
<a href="#l3.20"></a><span id="l3.20">         }</span>
<a href="#l3.21"></a><span id="l3.21">         else</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/base/search/src/nsMsgSearchAdapter.cpp</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/base/search/src/nsMsgSearchAdapter.cpp</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -436,26 +436,26 @@ nsresult nsMsgSearchAdapter::EncodeImapT</span>
<a href="#l4.4"></a><span id="l4.4">     case nsMsgSearchAttrib::MsgStatus:</span>
<a href="#l4.5"></a><span id="l4.5">       useNot = PR_FALSE; // bizarrely, NOT SEEN is wrong, but UNSEEN is right.</span>
<a href="#l4.6"></a><span id="l4.6">       ignoreValue = PR_TRUE; // the mnemonic is all we need</span>
<a href="#l4.7"></a><span id="l4.7">       PRUint32 status;</span>
<a href="#l4.8"></a><span id="l4.8">       searchValue-&gt;GetStatus(&amp;status);</span>
<a href="#l4.9"></a><span id="l4.9"> </span>
<a href="#l4.10"></a><span id="l4.10">       switch (status)</span>
<a href="#l4.11"></a><span id="l4.11">       {</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-      case MSG_FLAG_READ:</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+      case nsMsgMessageFlags::Read:</span>
<a href="#l4.14"></a><span id="l4.14">         whichMnemonic = op == nsMsgSearchOp::Is ? m_kImapSeen : m_kImapNotSeen;</span>
<a href="#l4.15"></a><span id="l4.15">         break;</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineminus">-      case MSG_FLAG_REPLIED:</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineplus">+      case nsMsgMessageFlags::Replied:</span>
<a href="#l4.18"></a><span id="l4.18">         whichMnemonic = op == nsMsgSearchOp::Is ? m_kImapAnswered : m_kImapNotAnswered;</span>
<a href="#l4.19"></a><span id="l4.19">         break;</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineminus">-      case MSG_FLAG_NEW:</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineplus">+      case nsMsgMessageFlags::New:</span>
<a href="#l4.22"></a><span id="l4.22">         whichMnemonic = op == nsMsgSearchOp::Is ? m_kImapNew : m_kImapNotNew;</span>
<a href="#l4.23"></a><span id="l4.23">         break;</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineminus">-      case MSG_FLAG_MARKED:</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineplus">+      case nsMsgMessageFlags::Marked:</span>
<a href="#l4.26"></a><span id="l4.26">         whichMnemonic = op == nsMsgSearchOp::Is ? m_kImapFlagged : m_kImapNotFlagged;</span>
<a href="#l4.27"></a><span id="l4.27">         break;</span>
<a href="#l4.28"></a><span id="l4.28">       default:</span>
<a href="#l4.29"></a><span id="l4.29">         NS_ASSERTION(PR_FALSE, &quot;invalid search operator&quot;);</span>
<a href="#l4.30"></a><span id="l4.30">         return NS_ERROR_INVALID_ARG;</span>
<a href="#l4.31"></a><span id="l4.31">       }</span>
<a href="#l4.32"></a><span id="l4.32">       break;</span>
<a href="#l4.33"></a><span id="l4.33">     default:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/base/search/src/nsMsgSearchTerm.cpp</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/base/search/src/nsMsgSearchTerm.cpp</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -284,75 +284,76 @@ nsresult NS_MsgGetStringForOperator(PRIn</span>
<a href="#l5.4"></a><span id="l5.4">   }</span>
<a href="#l5.5"></a><span id="l5.5"> </span>
<a href="#l5.6"></a><span id="l5.6">   return (found) ? NS_OK : NS_ERROR_INVALID_ARG;</span>
<a href="#l5.7"></a><span id="l5.7"> }</span>
<a href="#l5.8"></a><span id="l5.8"> </span>
<a href="#l5.9"></a><span id="l5.9"> void NS_MsgGetUntranslatedStatusName (uint32 s, nsCString *outName)</span>
<a href="#l5.10"></a><span id="l5.10"> {</span>
<a href="#l5.11"></a><span id="l5.11">   const char *tmpOutName = NULL;</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-#define MSG_STATUS_MASK (MSG_FLAG_READ | MSG_FLAG_REPLIED | MSG_FLAG_FORWARDED | MSG_FLAG_NEW | MSG_FLAG_MARKED)</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+#define MSG_STATUS_MASK (nsMsgMessageFlags::Read | nsMsgMessageFlags::Replied |\</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+  nsMsgMessageFlags::Forwarded | nsMsgMessageFlags::New | nsMsgMessageFlags::Marked)</span>
<a href="#l5.15"></a><span id="l5.15">   PRUint32 maskOut = (s &amp; MSG_STATUS_MASK);</span>
<a href="#l5.16"></a><span id="l5.16"> </span>
<a href="#l5.17"></a><span id="l5.17">   // diddle the flags to pay attention to the most important ones first, if multiple</span>
<a href="#l5.18"></a><span id="l5.18">   // flags are set. Should remove this code from the winfe.</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineminus">-  if (maskOut &amp; MSG_FLAG_NEW)</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineminus">-    maskOut = MSG_FLAG_NEW;</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineminus">-  if ( maskOut &amp; MSG_FLAG_REPLIED &amp;&amp;</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineminus">-     maskOut &amp; MSG_FLAG_FORWARDED )</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineminus">-    maskOut = MSG_FLAG_REPLIED|MSG_FLAG_FORWARDED;</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineminus">-  else if ( maskOut &amp; MSG_FLAG_FORWARDED )</span>
<a href="#l5.25"></a><span id="l5.25" class="difflineminus">-    maskOut = MSG_FLAG_FORWARDED;</span>
<a href="#l5.26"></a><span id="l5.26" class="difflineminus">-  else if ( maskOut &amp; MSG_FLAG_REPLIED )</span>
<a href="#l5.27"></a><span id="l5.27" class="difflineminus">-    maskOut = MSG_FLAG_REPLIED;</span>
<a href="#l5.28"></a><span id="l5.28" class="difflineplus">+  if (maskOut &amp; nsMsgMessageFlags::New)</span>
<a href="#l5.29"></a><span id="l5.29" class="difflineplus">+    maskOut = nsMsgMessageFlags::New;</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineplus">+  if (maskOut &amp; nsMsgMessageFlags::Replied &amp;&amp;</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineplus">+      maskOut &amp; nsMsgMessageFlags::Forwarded)</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+    maskOut = nsMsgMessageFlags::Replied | nsMsgMessageFlags::Forwarded;</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineplus">+  else if (maskOut &amp; nsMsgMessageFlags::Forwarded)</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+    maskOut = nsMsgMessageFlags::Forwarded;</span>
<a href="#l5.35"></a><span id="l5.35" class="difflineplus">+  else if (maskOut &amp; nsMsgMessageFlags::Replied)</span>
<a href="#l5.36"></a><span id="l5.36" class="difflineplus">+    maskOut = nsMsgMessageFlags::Replied;</span>
<a href="#l5.37"></a><span id="l5.37"> </span>
<a href="#l5.38"></a><span id="l5.38">   switch (maskOut)</span>
<a href="#l5.39"></a><span id="l5.39">   {</span>
<a href="#l5.40"></a><span id="l5.40" class="difflineminus">-  case MSG_FLAG_READ:</span>
<a href="#l5.41"></a><span id="l5.41" class="difflineplus">+  case nsMsgMessageFlags::Read:</span>
<a href="#l5.42"></a><span id="l5.42">     tmpOutName = &quot;read&quot;;</span>
<a href="#l5.43"></a><span id="l5.43">     break;</span>
<a href="#l5.44"></a><span id="l5.44" class="difflineminus">-  case MSG_FLAG_REPLIED:</span>
<a href="#l5.45"></a><span id="l5.45" class="difflineplus">+  case nsMsgMessageFlags::Replied:</span>
<a href="#l5.46"></a><span id="l5.46">     tmpOutName = &quot;replied&quot;;</span>
<a href="#l5.47"></a><span id="l5.47">     break;</span>
<a href="#l5.48"></a><span id="l5.48" class="difflineminus">-  case MSG_FLAG_FORWARDED:</span>
<a href="#l5.49"></a><span id="l5.49" class="difflineplus">+  case nsMsgMessageFlags::Forwarded:</span>
<a href="#l5.50"></a><span id="l5.50">     tmpOutName = &quot;forwarded&quot;;</span>
<a href="#l5.51"></a><span id="l5.51">     break;</span>
<a href="#l5.52"></a><span id="l5.52" class="difflineminus">-  case MSG_FLAG_FORWARDED|MSG_FLAG_REPLIED:</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineplus">+  case nsMsgMessageFlags::Forwarded | nsMsgMessageFlags::Replied:</span>
<a href="#l5.54"></a><span id="l5.54">     tmpOutName = &quot;replied and forwarded&quot;;</span>
<a href="#l5.55"></a><span id="l5.55">     break;</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineminus">-  case MSG_FLAG_NEW:</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+  case nsMsgMessageFlags::New:</span>
<a href="#l5.58"></a><span id="l5.58">     tmpOutName = &quot;new&quot;;</span>
<a href="#l5.59"></a><span id="l5.59">     break;</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineminus">-        case MSG_FLAG_MARKED:</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineminus">-                tmpOutName = &quot;flagged&quot;;</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineminus">-                break;</span>
<a href="#l5.63"></a><span id="l5.63" class="difflineplus">+  case nsMsgMessageFlags::Marked:</span>
<a href="#l5.64"></a><span id="l5.64" class="difflineplus">+    tmpOutName = &quot;flagged&quot;;</span>
<a href="#l5.65"></a><span id="l5.65" class="difflineplus">+    break;</span>
<a href="#l5.66"></a><span id="l5.66">   default:</span>
<a href="#l5.67"></a><span id="l5.67">     // This is fine, status may be &quot;unread&quot; for example</span>
<a href="#l5.68"></a><span id="l5.68" class="difflineminus">-        break;</span>
<a href="#l5.69"></a><span id="l5.69" class="difflineplus">+    break;</span>
<a href="#l5.70"></a><span id="l5.70">   }</span>
<a href="#l5.71"></a><span id="l5.71"> </span>
<a href="#l5.72"></a><span id="l5.72">   if (tmpOutName)</span>
<a href="#l5.73"></a><span id="l5.73">     *outName = tmpOutName;</span>
<a href="#l5.74"></a><span id="l5.74"> }</span>
<a href="#l5.75"></a><span id="l5.75"> </span>
<a href="#l5.76"></a><span id="l5.76"> </span>
<a href="#l5.77"></a><span id="l5.77"> PRInt32 NS_MsgGetStatusValueFromName(char *name)</span>
<a href="#l5.78"></a><span id="l5.78"> {</span>
<a href="#l5.79"></a><span id="l5.79">   if (!strcmp(&quot;read&quot;, name))</span>
<a href="#l5.80"></a><span id="l5.80" class="difflineminus">-    return MSG_FLAG_READ;</span>
<a href="#l5.81"></a><span id="l5.81" class="difflineplus">+    return nsMsgMessageFlags::Read;</span>
<a href="#l5.82"></a><span id="l5.82">   if (!strcmp(&quot;replied&quot;, name))</span>
<a href="#l5.83"></a><span id="l5.83" class="difflineminus">-    return MSG_FLAG_REPLIED;</span>
<a href="#l5.84"></a><span id="l5.84" class="difflineplus">+    return nsMsgMessageFlags::Replied;</span>
<a href="#l5.85"></a><span id="l5.85">   if (!strcmp(&quot;forwarded&quot;, name))</span>
<a href="#l5.86"></a><span id="l5.86" class="difflineminus">-    return MSG_FLAG_FORWARDED;</span>
<a href="#l5.87"></a><span id="l5.87" class="difflineplus">+    return nsMsgMessageFlags::Forwarded;</span>
<a href="#l5.88"></a><span id="l5.88">   if (!strcmp(&quot;replied and forwarded&quot;, name))</span>
<a href="#l5.89"></a><span id="l5.89" class="difflineminus">-    return MSG_FLAG_FORWARDED|MSG_FLAG_REPLIED;</span>
<a href="#l5.90"></a><span id="l5.90" class="difflineplus">+    return nsMsgMessageFlags::Forwarded | nsMsgMessageFlags::Replied;</span>
<a href="#l5.91"></a><span id="l5.91">   if (!strcmp(&quot;new&quot;, name))</span>
<a href="#l5.92"></a><span id="l5.92" class="difflineminus">-    return MSG_FLAG_NEW;</span>
<a href="#l5.93"></a><span id="l5.93" class="difflineplus">+    return nsMsgMessageFlags::New;</span>
<a href="#l5.94"></a><span id="l5.94">   if (!strcmp(&quot;flagged&quot;, name))</span>
<a href="#l5.95"></a><span id="l5.95" class="difflineminus">-    return MSG_FLAG_MARKED;</span>
<a href="#l5.96"></a><span id="l5.96" class="difflineplus">+    return nsMsgMessageFlags::Marked;</span>
<a href="#l5.97"></a><span id="l5.97">   return 0;</span>
<a href="#l5.98"></a><span id="l5.98"> }</span>
<a href="#l5.99"></a><span id="l5.99"> </span>
<a href="#l5.100"></a><span id="l5.100"> </span>
<a href="#l5.101"></a><span id="l5.101"> // Needed for DeStream method.</span>
<a href="#l5.102"></a><span id="l5.102"> nsMsgSearchTerm::nsMsgSearchTerm()</span>
<a href="#l5.103"></a><span id="l5.103"> {</span>
<a href="#l5.104"></a><span id="l5.104">     // initialize this to zero</span>
<a href="#l5.105"></a><span id="l5.105" class="difflineat">@@ -601,17 +602,17 @@ nsresult nsMsgSearchTerm::ParseValue(cha</span>
<a href="#l5.106"></a><span id="l5.106">       break;</span>
<a href="#l5.107"></a><span id="l5.107">     case nsMsgSearchAttrib::JunkStatus:</span>
<a href="#l5.108"></a><span id="l5.108">       m_value.u.junkStatus = atoi(inStream); // only if we read from disk, right?</span>
<a href="#l5.109"></a><span id="l5.109">       break;</span>
<a href="#l5.110"></a><span id="l5.110">     case nsMsgSearchAttrib::JunkPercent:</span>
<a href="#l5.111"></a><span id="l5.111">       m_value.u.junkPercent = atoi(inStream);</span>
<a href="#l5.112"></a><span id="l5.112">       break;</span>
<a href="#l5.113"></a><span id="l5.113">     case nsMsgSearchAttrib::HasAttachmentStatus:</span>
<a href="#l5.114"></a><span id="l5.114" class="difflineminus">-      m_value.u.msgStatus = MSG_FLAG_ATTACHMENT;</span>
<a href="#l5.115"></a><span id="l5.115" class="difflineplus">+      m_value.u.msgStatus = nsMsgMessageFlags::Attachment;</span>
<a href="#l5.116"></a><span id="l5.116">       break; // this should always be true.</span>
<a href="#l5.117"></a><span id="l5.117">     case nsMsgSearchAttrib::Size:</span>
<a href="#l5.118"></a><span id="l5.118">       m_value.u.size = atoi(inStream);</span>
<a href="#l5.119"></a><span id="l5.119">       break;</span>
<a href="#l5.120"></a><span id="l5.120">     default:</span>
<a href="#l5.121"></a><span id="l5.121">       NS_ASSERTION(PR_FALSE, &quot;invalid attribute parsing search term value&quot;);</span>
<a href="#l5.122"></a><span id="l5.122">       break;</span>
<a href="#l5.123"></a><span id="l5.123">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/base/src/nsMessenger.cpp</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/base/src/nsMessenger.cpp</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -1516,17 +1516,18 @@ nsSaveMsgListener::OnStopRunningUrl(nsIU</span>
<a href="#l6.4"></a><span id="l6.4">       templateFolder = do_QueryInterface(res, &amp;rv);</span>
<a href="#l6.5"></a><span id="l6.5">       if (NS_FAILED(rv)) goto done;</span>
<a href="#l6.6"></a><span id="l6.6">       nsCOMPtr&lt;nsIMsgCopyService&gt; copyService = do_GetService(NS_MSGCOPYSERVICE_CONTRACTID);</span>
<a href="#l6.7"></a><span id="l6.7">       if (copyService)</span>
<a href="#l6.8"></a><span id="l6.8">       {</span>
<a href="#l6.9"></a><span id="l6.9">         nsCOMPtr &lt;nsIFile&gt; clone;</span>
<a href="#l6.10"></a><span id="l6.10">         m_file-&gt;Clone(getter_AddRefs(clone));</span>
<a href="#l6.11"></a><span id="l6.11">         rv = copyService-&gt;CopyFileMessage(clone, templateFolder, nsnull,</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-                                          PR_TRUE, MSG_FLAG_READ, EmptyCString(), this, nsnull);</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+                                          PR_TRUE, nsMsgMessageFlags::Read,</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+                                          EmptyCString(), this, nsnull);</span>
<a href="#l6.15"></a><span id="l6.15">       }</span>
<a href="#l6.16"></a><span id="l6.16">       killSelf = PR_FALSE;</span>
<a href="#l6.17"></a><span id="l6.17">     }</span>
<a href="#l6.18"></a><span id="l6.18">   }</span>
<a href="#l6.19"></a><span id="l6.19"> </span>
<a href="#l6.20"></a><span id="l6.20"> done:</span>
<a href="#l6.21"></a><span id="l6.21">   if (NS_FAILED(rv))</span>
<a href="#l6.22"></a><span id="l6.22">   {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/base/src/nsMsgAccountManager.cpp</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgAccountManager.cpp</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -2438,35 +2438,37 @@ VirtualFolderChangeListener::OnHdrProper</span>
<a href="#l7.4"></a><span id="l7.4">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l7.5"></a><span id="l7.5">   aHdrChanged-&gt;GetFlags(&amp;flags);</span>
<a href="#l7.6"></a><span id="l7.6">   </span>
<a href="#l7.7"></a><span id="l7.7">   if (aPreChange) // We're looking at the old header, save status</span>
<a href="#l7.8"></a><span id="l7.8">   {</span>
<a href="#l7.9"></a><span id="l7.9">     *aStatus = 0;</span>
<a href="#l7.10"></a><span id="l7.10">     if (match)</span>
<a href="#l7.11"></a><span id="l7.11">       *aStatus |= kMatch;</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-    if (flags &amp; MSG_FLAG_READ)</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+    if (flags &amp; nsMsgMessageFlags::Read)</span>
<a href="#l7.14"></a><span id="l7.14">       *aStatus |= kRead;</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineminus">-    if (flags &amp; MSG_FLAG_NEW)</span>
<a href="#l7.16"></a><span id="l7.16" class="difflineplus">+    if (flags &amp; nsMsgMessageFlags::New)</span>
<a href="#l7.17"></a><span id="l7.17">       *aStatus |= kNew;</span>
<a href="#l7.18"></a><span id="l7.18">     return NS_OK;</span>
<a href="#l7.19"></a><span id="l7.19">   }</span>
<a href="#l7.20"></a><span id="l7.20">   </span>
<a href="#l7.21"></a><span id="l7.21">   // This is the post change section where changes are detected</span>
<a href="#l7.22"></a><span id="l7.22"> </span>
<a href="#l7.23"></a><span id="l7.23">   PRBool wasMatch = *aStatus &amp; kMatch;</span>
<a href="#l7.24"></a><span id="l7.24">   if (!match &amp;&amp; !wasMatch) // header not in virtual folder</span>
<a href="#l7.25"></a><span id="l7.25">     return NS_OK;</span>
<a href="#l7.26"></a><span id="l7.26"> </span>
<a href="#l7.27"></a><span id="l7.27">   PRInt32 totalDelta = 0, unreadDelta = 0, newDelta = 0;</span>
<a href="#l7.28"></a><span id="l7.28"> </span>
<a href="#l7.29"></a><span id="l7.29">   if (match) {</span>
<a href="#l7.30"></a><span id="l7.30">     totalDelta++;</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineminus">-    if (!(flags &amp; MSG_FLAG_READ)) unreadDelta++;</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineminus">-    if (flags &amp; MSG_FLAG_NEW) newDelta++;</span>
<a href="#l7.33"></a><span id="l7.33" class="difflineplus">+    if (!(flags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l7.34"></a><span id="l7.34" class="difflineplus">+      unreadDelta++;</span>
<a href="#l7.35"></a><span id="l7.35" class="difflineplus">+    if (flags &amp; nsMsgMessageFlags::New)</span>
<a href="#l7.36"></a><span id="l7.36" class="difflineplus">+      newDelta++;</span>
<a href="#l7.37"></a><span id="l7.37">   }</span>
<a href="#l7.38"></a><span id="l7.38"> </span>
<a href="#l7.39"></a><span id="l7.39">   if (wasMatch) {</span>
<a href="#l7.40"></a><span id="l7.40">     totalDelta--;</span>
<a href="#l7.41"></a><span id="l7.41">     if (!(*aStatus &amp; kRead)) unreadDelta--;</span>
<a href="#l7.42"></a><span id="l7.42">     if (*aStatus &amp; kNew) newDelta--;</span>
<a href="#l7.43"></a><span id="l7.43">   }</span>
<a href="#l7.44"></a><span id="l7.44"> </span>
<a href="#l7.45"></a><span id="l7.45" class="difflineat">@@ -2528,17 +2530,17 @@ NS_IMETHODIMP VirtualFolderChangeListene</span>
<a href="#l7.46"></a><span id="l7.46">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l7.47"></a><span id="l7.47">   // we don't want to change the total counts if this virtual folder is open in a view,</span>
<a href="#l7.48"></a><span id="l7.48">   // because we won't remove the header from view while it's open. On the other hand,</span>
<a href="#l7.49"></a><span id="l7.49">   // it's hard to fix the count when the user clicks away to another folder, w/o re-running</span>
<a href="#l7.50"></a><span id="l7.50">   // the search, or setting some sort of pending count change.</span>
<a href="#l7.51"></a><span id="l7.51">   // Maybe this needs to be handled in the view code...the view could do the same calculation</span>
<a href="#l7.52"></a><span id="l7.52">   // and also keep track of the counts changed. Then, when the view was closed, if it's a virtual</span>
<a href="#l7.53"></a><span id="l7.53">   // folder, it could update the counts for the db.</span>
<a href="#l7.54"></a><span id="l7.54" class="difflineminus">-  if (oldMatch != newMatch || (oldMatch &amp;&amp; (aOldFlags &amp; MSG_FLAG_READ) != (aNewFlags &amp; MSG_FLAG_READ)))</span>
<a href="#l7.55"></a><span id="l7.55" class="difflineplus">+  if (oldMatch != newMatch || (oldMatch &amp;&amp; (aOldFlags &amp; nsMsgMessageFlags::Read) != (aNewFlags &amp; nsMsgMessageFlags::Read)))</span>
<a href="#l7.56"></a><span id="l7.56">   {</span>
<a href="#l7.57"></a><span id="l7.57">     nsCOMPtr &lt;nsIMsgDatabase&gt; virtDatabase;</span>
<a href="#l7.58"></a><span id="l7.58">     nsCOMPtr &lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l7.59"></a><span id="l7.59"> </span>
<a href="#l7.60"></a><span id="l7.60">     rv = m_virtualFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(dbFolderInfo), getter_AddRefs(virtDatabase));</span>
<a href="#l7.61"></a><span id="l7.61">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l7.62"></a><span id="l7.62">     PRInt32 totalDelta = 0,  unreadDelta = 0;</span>
<a href="#l7.63"></a><span id="l7.63">     if (oldMatch != newMatch)</span>
<a href="#l7.64"></a><span id="l7.64" class="difflineat">@@ -2551,24 +2553,24 @@ NS_IMETHODIMP VirtualFolderChangeListene</span>
<a href="#l7.65"></a><span id="l7.65"> //      if (!isOpen)</span>
<a href="#l7.66"></a><span id="l7.66">         totalDelta = (oldMatch) ? -1 : 1;</span>
<a href="#l7.67"></a><span id="l7.67">     }</span>
<a href="#l7.68"></a><span id="l7.68">     PRBool msgHdrIsRead;</span>
<a href="#l7.69"></a><span id="l7.69">     aHdrChanged-&gt;GetIsRead(&amp;msgHdrIsRead);</span>
<a href="#l7.70"></a><span id="l7.70">     if (oldMatch == newMatch) // read flag changed state</span>
<a href="#l7.71"></a><span id="l7.71">       unreadDelta = (msgHdrIsRead) ? -1 : 1;</span>
<a href="#l7.72"></a><span id="l7.72">     else if (oldMatch) // else header should removed</span>
<a href="#l7.73"></a><span id="l7.73" class="difflineminus">-      unreadDelta = (aOldFlags &amp; MSG_FLAG_READ) ? 0 : -1;</span>
<a href="#l7.74"></a><span id="l7.74" class="difflineplus">+      unreadDelta = (aOldFlags &amp; nsMsgMessageFlags::Read) ? 0 : -1;</span>
<a href="#l7.75"></a><span id="l7.75">     else               // header should be added</span>
<a href="#l7.76"></a><span id="l7.76" class="difflineminus">-      unreadDelta = (aNewFlags &amp; MSG_FLAG_READ) ? 0 : 1;</span>
<a href="#l7.77"></a><span id="l7.77" class="difflineplus">+      unreadDelta = (aNewFlags &amp; nsMsgMessageFlags::Read) ? 0 : 1;</span>
<a href="#l7.78"></a><span id="l7.78">     if (unreadDelta)</span>
<a href="#l7.79"></a><span id="l7.79">       dbFolderInfo-&gt;ChangeNumUnreadMessages(unreadDelta);</span>
<a href="#l7.80"></a><span id="l7.80">     if (totalDelta)</span>
<a href="#l7.81"></a><span id="l7.81">       dbFolderInfo-&gt;ChangeNumMessages(totalDelta);</span>
<a href="#l7.82"></a><span id="l7.82" class="difflineminus">-    if (unreadDelta == -1 &amp;&amp; aOldFlags &amp; MSG_FLAG_NEW)</span>
<a href="#l7.83"></a><span id="l7.83" class="difflineplus">+    if (unreadDelta == -1 &amp;&amp; aOldFlags &amp; nsMsgMessageFlags::New)</span>
<a href="#l7.84"></a><span id="l7.84">     {</span>
<a href="#l7.85"></a><span id="l7.85">       PRInt32 numNewMessages;</span>
<a href="#l7.86"></a><span id="l7.86">       m_virtualFolder-&gt;GetNumNewMessages(PR_FALSE, &amp;numNewMessages);</span>
<a href="#l7.87"></a><span id="l7.87">       m_virtualFolder-&gt;SetNumNewMessages(numNewMessages - 1);</span>
<a href="#l7.88"></a><span id="l7.88">       if (numNewMessages == 1)</span>
<a href="#l7.89"></a><span id="l7.89">         m_virtualFolder-&gt;SetHasNewMessages(PR_FALSE);</span>
<a href="#l7.90"></a><span id="l7.90">     }</span>
<a href="#l7.91"></a><span id="l7.91">     if (totalDelta)</span>
<a href="#l7.92"></a><span id="l7.92" class="difflineat">@@ -2601,17 +2603,17 @@ NS_IMETHODIMP VirtualFolderChangeListene</span>
<a href="#l7.93"></a><span id="l7.93"> </span>
<a href="#l7.94"></a><span id="l7.94">     rv = m_virtualFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(dbFolderInfo), getter_AddRefs(virtDatabase));</span>
<a href="#l7.95"></a><span id="l7.95">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l7.96"></a><span id="l7.96">     PRBool msgHdrIsRead;</span>
<a href="#l7.97"></a><span id="l7.97">     aHdrDeleted-&gt;GetIsRead(&amp;msgHdrIsRead);</span>
<a href="#l7.98"></a><span id="l7.98">     if (!msgHdrIsRead)</span>
<a href="#l7.99"></a><span id="l7.99">       dbFolderInfo-&gt;ChangeNumUnreadMessages(-1);</span>
<a href="#l7.100"></a><span id="l7.100">     dbFolderInfo-&gt;ChangeNumMessages(-1);</span>
<a href="#l7.101"></a><span id="l7.101" class="difflineminus">-    if (aFlags &amp; MSG_FLAG_NEW)</span>
<a href="#l7.102"></a><span id="l7.102" class="difflineplus">+    if (aFlags &amp; nsMsgMessageFlags::New)</span>
<a href="#l7.103"></a><span id="l7.103">     {</span>
<a href="#l7.104"></a><span id="l7.104">       PRInt32 numNewMessages;</span>
<a href="#l7.105"></a><span id="l7.105">       m_virtualFolder-&gt;GetNumNewMessages(PR_FALSE, &amp;numNewMessages);</span>
<a href="#l7.106"></a><span id="l7.106">       m_virtualFolder-&gt;SetNumNewMessages(numNewMessages - 1);</span>
<a href="#l7.107"></a><span id="l7.107">       if (numNewMessages == 1)</span>
<a href="#l7.108"></a><span id="l7.108">         m_virtualFolder-&gt;SetHasNewMessages(PR_FALSE);</span>
<a href="#l7.109"></a><span id="l7.109">     }</span>
<a href="#l7.110"></a><span id="l7.110">     </span>
<a href="#l7.111"></a><span id="l7.111" class="difflineat">@@ -2643,17 +2645,17 @@ NS_IMETHODIMP VirtualFolderChangeListene</span>
<a href="#l7.112"></a><span id="l7.112">     rv = m_virtualFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(dbFolderInfo), getter_AddRefs(virtDatabase));</span>
<a href="#l7.113"></a><span id="l7.113">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l7.114"></a><span id="l7.114">     PRBool msgHdrIsRead;</span>
<a href="#l7.115"></a><span id="l7.115">     PRUint32 msgFlags;</span>
<a href="#l7.116"></a><span id="l7.116">     aNewHdr-&gt;GetIsRead(&amp;msgHdrIsRead);</span>
<a href="#l7.117"></a><span id="l7.117">     aNewHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l7.118"></a><span id="l7.118">     if (!msgHdrIsRead)</span>
<a href="#l7.119"></a><span id="l7.119">       dbFolderInfo-&gt;ChangeNumUnreadMessages(1);</span>
<a href="#l7.120"></a><span id="l7.120" class="difflineminus">-    if (msgFlags &amp; MSG_FLAG_NEW)</span>
<a href="#l7.121"></a><span id="l7.121" class="difflineplus">+    if (msgFlags &amp; nsMsgMessageFlags::New)</span>
<a href="#l7.122"></a><span id="l7.122">     {</span>
<a href="#l7.123"></a><span id="l7.123">       PRInt32 numNewMessages;</span>
<a href="#l7.124"></a><span id="l7.124">       m_virtualFolder-&gt;GetNumNewMessages(PR_FALSE, &amp;numNewMessages);</span>
<a href="#l7.125"></a><span id="l7.125">       m_virtualFolder-&gt;SetHasNewMessages(PR_TRUE);</span>
<a href="#l7.126"></a><span id="l7.126">       m_virtualFolder-&gt;SetNumNewMessages(numNewMessages + 1);</span>
<a href="#l7.127"></a><span id="l7.127">     }</span>
<a href="#l7.128"></a><span id="l7.128">     nsCString searchUri;</span>
<a href="#l7.129"></a><span id="l7.129">     m_virtualFolder-&gt;GetURI(searchUri);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/base/src/nsMsgDBView.cpp</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgDBView.cpp</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -451,17 +451,17 @@ nsresult nsMsgDBView::FetchRecipients(ns</span>
<a href="#l8.4"></a><span id="l8.4">   }</span>
<a href="#l8.5"></a><span id="l8.5"> </span>
<a href="#l8.6"></a><span id="l8.6">   aRecipientsString = unparsedRecipients;</span>
<a href="#l8.7"></a><span id="l8.7">   return NS_OK;</span>
<a href="#l8.8"></a><span id="l8.8"> }</span>
<a href="#l8.9"></a><span id="l8.9"> </span>
<a href="#l8.10"></a><span id="l8.10"> nsresult nsMsgDBView::FetchSubject(nsIMsgDBHdr * aMsgHdr, PRUint32 aFlags, nsAString &amp;aValue)</span>
<a href="#l8.11"></a><span id="l8.11"> {</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-  if (aFlags &amp; MSG_FLAG_HAS_RE)</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+  if (aFlags &amp; nsMsgMessageFlags::HasRe)</span>
<a href="#l8.14"></a><span id="l8.14">   {</span>
<a href="#l8.15"></a><span id="l8.15">     nsString subject;</span>
<a href="#l8.16"></a><span id="l8.16">     aMsgHdr-&gt;GetMime2DecodedSubject(subject);</span>
<a href="#l8.17"></a><span id="l8.17">     aValue.AssignLiteral(&quot;Re: &quot;);</span>
<a href="#l8.18"></a><span id="l8.18">     aValue.Append(subject);</span>
<a href="#l8.19"></a><span id="l8.19">   }</span>
<a href="#l8.20"></a><span id="l8.20">   else</span>
<a href="#l8.21"></a><span id="l8.21">     aMsgHdr-&gt;GetMime2DecodedSubject(aValue);</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineat">@@ -565,23 +565,23 @@ nsresult nsMsgDBView::FetchDate(nsIMsgDB</span>
<a href="#l8.23"></a><span id="l8.23">                                       dateOfMsg,</span>
<a href="#l8.24"></a><span id="l8.24">                                       aDateString);</span>
<a href="#l8.25"></a><span id="l8.25"> </span>
<a href="#l8.26"></a><span id="l8.26">   return rv;</span>
<a href="#l8.27"></a><span id="l8.27"> }</span>
<a href="#l8.28"></a><span id="l8.28"> </span>
<a href="#l8.29"></a><span id="l8.29"> nsresult nsMsgDBView::FetchStatus(PRUint32 aFlags, nsAString &amp;aStatusString)</span>
<a href="#l8.30"></a><span id="l8.30"> {</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineminus">-  if(aFlags &amp; MSG_FLAG_REPLIED)</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+  if (aFlags &amp; nsMsgMessageFlags::Replied)</span>
<a href="#l8.33"></a><span id="l8.33">     aStatusString = kRepliedString;</span>
<a href="#l8.34"></a><span id="l8.34" class="difflineminus">-  else if(aFlags &amp; MSG_FLAG_FORWARDED)</span>
<a href="#l8.35"></a><span id="l8.35" class="difflineplus">+  else if (aFlags &amp; nsMsgMessageFlags::Forwarded)</span>
<a href="#l8.36"></a><span id="l8.36">     aStatusString = kForwardedString;</span>
<a href="#l8.37"></a><span id="l8.37" class="difflineminus">-  else if(aFlags &amp; MSG_FLAG_NEW)</span>
<a href="#l8.38"></a><span id="l8.38" class="difflineplus">+  else if (aFlags &amp; nsMsgMessageFlags::New)</span>
<a href="#l8.39"></a><span id="l8.39">     aStatusString = kNewString;</span>
<a href="#l8.40"></a><span id="l8.40" class="difflineminus">-  else if(aFlags &amp; MSG_FLAG_READ)</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineplus">+  else if (aFlags &amp; nsMsgMessageFlags::Read)</span>
<a href="#l8.42"></a><span id="l8.42">     aStatusString = kReadString;</span>
<a href="#l8.43"></a><span id="l8.43"> </span>
<a href="#l8.44"></a><span id="l8.44">   return NS_OK;</span>
<a href="#l8.45"></a><span id="l8.45"> }</span>
<a href="#l8.46"></a><span id="l8.46"> </span>
<a href="#l8.47"></a><span id="l8.47"> nsresult nsMsgDBView::FetchSize(nsIMsgDBHdr * aHdr, nsAString &amp;aSizeString)</span>
<a href="#l8.48"></a><span id="l8.48"> {</span>
<a href="#l8.49"></a><span id="l8.49">   nsAutoString formattedSizeString;</span>
<a href="#l8.50"></a><span id="l8.50" class="difflineat">@@ -593,17 +593,17 @@ nsresult nsMsgDBView::FetchSize(nsIMsgDB</span>
<a href="#l8.51"></a><span id="l8.51">     aHdr-&gt;GetLineCount(&amp;msgSize);</span>
<a href="#l8.52"></a><span id="l8.52">     formattedSizeString.AppendInt(msgSize);</span>
<a href="#l8.53"></a><span id="l8.53">   }</span>
<a href="#l8.54"></a><span id="l8.54">   else</span>
<a href="#l8.55"></a><span id="l8.55">   {</span>
<a href="#l8.56"></a><span id="l8.56">     PRUint32 flags = 0;</span>
<a href="#l8.57"></a><span id="l8.57"> </span>
<a href="#l8.58"></a><span id="l8.58">     aHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l8.59"></a><span id="l8.59" class="difflineminus">-    if (flags &amp; MSG_FLAG_PARTIAL)</span>
<a href="#l8.60"></a><span id="l8.60" class="difflineplus">+    if (flags &amp; nsMsgMessageFlags::Partial)</span>
<a href="#l8.61"></a><span id="l8.61">       aHdr-&gt;GetUint32Property(&quot;onlineSize&quot;, &amp;msgSize);</span>
<a href="#l8.62"></a><span id="l8.62"> </span>
<a href="#l8.63"></a><span id="l8.63">     if (msgSize == 0)</span>
<a href="#l8.64"></a><span id="l8.64">       aHdr-&gt;GetMessageSize(&amp;msgSize);</span>
<a href="#l8.65"></a><span id="l8.65"> </span>
<a href="#l8.66"></a><span id="l8.66">     if(msgSize &lt; 1024)</span>
<a href="#l8.67"></a><span id="l8.67">       msgSize = 1024;</span>
<a href="#l8.68"></a><span id="l8.68"> </span>
<a href="#l8.69"></a><span id="l8.69" class="difflineat">@@ -1207,42 +1207,42 @@ NS_IMETHODIMP nsMsgDBView::GetCellProper</span>
<a href="#l8.70"></a><span id="l8.70">   {</span>
<a href="#l8.71"></a><span id="l8.71">     ClearHdrCache();</span>
<a href="#l8.72"></a><span id="l8.72">     return NS_MSG_INVALID_DBVIEW_INDEX;</span>
<a href="#l8.73"></a><span id="l8.73">   }</span>
<a href="#l8.74"></a><span id="l8.74"> </span>
<a href="#l8.75"></a><span id="l8.75">   PRUint32 flags;</span>
<a href="#l8.76"></a><span id="l8.76">   msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l8.77"></a><span id="l8.77"> </span>
<a href="#l8.78"></a><span id="l8.78" class="difflineminus">-  if (!(flags &amp; MSG_FLAG_READ))</span>
<a href="#l8.79"></a><span id="l8.79" class="difflineplus">+  if (!(flags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l8.80"></a><span id="l8.80">     properties-&gt;AppendElement(kUnreadMsgAtom);</span>
<a href="#l8.81"></a><span id="l8.81">   else</span>
<a href="#l8.82"></a><span id="l8.82">     properties-&gt;AppendElement(kReadMsgAtom);</span>
<a href="#l8.83"></a><span id="l8.83"> </span>
<a href="#l8.84"></a><span id="l8.84" class="difflineminus">-  if (flags &amp; MSG_FLAG_REPLIED)</span>
<a href="#l8.85"></a><span id="l8.85" class="difflineplus">+  if (flags &amp; nsMsgMessageFlags::Replied)</span>
<a href="#l8.86"></a><span id="l8.86">     properties-&gt;AppendElement(kRepliedMsgAtom);</span>
<a href="#l8.87"></a><span id="l8.87"> </span>
<a href="#l8.88"></a><span id="l8.88" class="difflineminus">-  if (flags &amp; MSG_FLAG_FORWARDED)</span>
<a href="#l8.89"></a><span id="l8.89" class="difflineplus">+  if (flags &amp; nsMsgMessageFlags::Forwarded)</span>
<a href="#l8.90"></a><span id="l8.90">     properties-&gt;AppendElement(kForwardedMsgAtom);</span>
<a href="#l8.91"></a><span id="l8.91"> </span>
<a href="#l8.92"></a><span id="l8.92" class="difflineminus">-  if (flags &amp; MSG_FLAG_NEW)</span>
<a href="#l8.93"></a><span id="l8.93" class="difflineplus">+  if (flags &amp; nsMsgMessageFlags::New)</span>
<a href="#l8.94"></a><span id="l8.94">     properties-&gt;AppendElement(kNewMsgAtom);</span>
<a href="#l8.95"></a><span id="l8.95"> </span>
<a href="#l8.96"></a><span id="l8.96" class="difflineminus">-  if (flags &amp; MSG_FLAG_IGNORED)</span>
<a href="#l8.97"></a><span id="l8.97" class="difflineplus">+  if (flags &amp; nsMsgMessageFlags::Ignored)</span>
<a href="#l8.98"></a><span id="l8.98">     properties-&gt;AppendElement(kIgnoreSubthreadAtom);</span>
<a href="#l8.99"></a><span id="l8.99"> </span>
<a href="#l8.100"></a><span id="l8.100">   nsCOMPtr &lt;nsIMsgLocalMailFolder&gt; localFolder = do_QueryInterface(m_folder);</span>
<a href="#l8.101"></a><span id="l8.101"> </span>
<a href="#l8.102"></a><span id="l8.102" class="difflineminus">-  if ((flags &amp; MSG_FLAG_OFFLINE) || (localFolder &amp;&amp; !(flags &amp; MSG_FLAG_PARTIAL)))</span>
<a href="#l8.103"></a><span id="l8.103" class="difflineplus">+  if ((flags &amp; nsMsgMessageFlags::Offline) || (localFolder &amp;&amp; !(flags &amp; nsMsgMessageFlags::Partial)))</span>
<a href="#l8.104"></a><span id="l8.104">     properties-&gt;AppendElement(kOfflineMsgAtom);</span>
<a href="#l8.105"></a><span id="l8.105"> </span>
<a href="#l8.106"></a><span id="l8.106" class="difflineminus">-  if (flags &amp; MSG_FLAG_ATTACHMENT)</span>
<a href="#l8.107"></a><span id="l8.107" class="difflineplus">+  if (flags &amp; nsMsgMessageFlags::Attachment)</span>
<a href="#l8.108"></a><span id="l8.108">     properties-&gt;AppendElement(kAttachMsgAtom);</span>
<a href="#l8.109"></a><span id="l8.109"> </span>
<a href="#l8.110"></a><span id="l8.110" class="difflineminus">-  if ((mDeleteModel == nsMsgImapDeleteModels::IMAPDelete) &amp;&amp; (flags &amp; MSG_FLAG_IMAP_DELETED))</span>
<a href="#l8.111"></a><span id="l8.111" class="difflineplus">+  if ((mDeleteModel == nsMsgImapDeleteModels::IMAPDelete) &amp;&amp; (flags &amp; nsMsgMessageFlags::IMAPDeleted))</span>
<a href="#l8.112"></a><span id="l8.112">     properties-&gt;AppendElement(kImapDeletedMsgAtom);</span>
<a href="#l8.113"></a><span id="l8.113"> </span>
<a href="#l8.114"></a><span id="l8.114">   if (mMessageTypeAtom)</span>
<a href="#l8.115"></a><span id="l8.115">     properties-&gt;AppendElement(mMessageTypeAtom);</span>
<a href="#l8.116"></a><span id="l8.116"> </span>
<a href="#l8.117"></a><span id="l8.117">   nsCString imageSize;</span>
<a href="#l8.118"></a><span id="l8.118">   msgHdr-&gt;GetStringProperty(&quot;imageSize&quot;, getter_Copies(imageSize));</span>
<a href="#l8.119"></a><span id="l8.119">   if (!imageSize.IsEmpty())</span>
<a href="#l8.120"></a><span id="l8.120" class="difflineat">@@ -1310,17 +1310,17 @@ NS_IMETHODIMP nsMsgDBView::GetCellProper</span>
<a href="#l8.121"></a><span id="l8.121">     break;</span>
<a href="#l8.122"></a><span id="l8.122">   }</span>
<a href="#l8.123"></a><span id="l8.123"> #endif</span>
<a href="#l8.124"></a><span id="l8.124"> </span>
<a href="#l8.125"></a><span id="l8.125">   const PRUnichar* colID;</span>
<a href="#l8.126"></a><span id="l8.126">   col-&gt;GetIdConst(&amp;colID);</span>
<a href="#l8.127"></a><span id="l8.127">   if (colID[0] == 'f')</span>
<a href="#l8.128"></a><span id="l8.128">   {</span>
<a href="#l8.129"></a><span id="l8.129" class="difflineminus">-    if (m_flags[aRow] &amp; MSG_FLAG_MARKED)</span>
<a href="#l8.130"></a><span id="l8.130" class="difflineplus">+    if (m_flags[aRow] &amp; nsMsgMessageFlags::Marked)</span>
<a href="#l8.131"></a><span id="l8.131">     {</span>
<a href="#l8.132"></a><span id="l8.132">       properties-&gt;AppendElement(kFlaggedMsgAtom);</span>
<a href="#l8.133"></a><span id="l8.133">     }</span>
<a href="#l8.134"></a><span id="l8.134">   }</span>
<a href="#l8.135"></a><span id="l8.135"> </span>
<a href="#l8.136"></a><span id="l8.136">   if (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay)</span>
<a href="#l8.137"></a><span id="l8.137">   {</span>
<a href="#l8.138"></a><span id="l8.138">     if (m_flags[aRow] &amp; MSG_VIEW_FLAG_ISTHREAD)</span>
<a href="#l8.139"></a><span id="l8.139" class="difflineat">@@ -1329,19 +1329,19 @@ NS_IMETHODIMP nsMsgDBView::GetCellProper</span>
<a href="#l8.140"></a><span id="l8.140">       rv = GetThreadContainingIndex(aRow, getter_AddRefs(thread));</span>
<a href="#l8.141"></a><span id="l8.141">       if (NS_SUCCEEDED(rv) &amp;&amp; thread)</span>
<a href="#l8.142"></a><span id="l8.142">       {</span>
<a href="#l8.143"></a><span id="l8.143">         PRUint32 numUnreadChildren;</span>
<a href="#l8.144"></a><span id="l8.144">         thread-&gt;GetNumUnreadChildren(&amp;numUnreadChildren);</span>
<a href="#l8.145"></a><span id="l8.145">         if (numUnreadChildren &gt; 0)</span>
<a href="#l8.146"></a><span id="l8.146">           properties-&gt;AppendElement(kHasUnreadAtom);</span>
<a href="#l8.147"></a><span id="l8.147">         thread-&gt;GetFlags(&amp;flags);</span>
<a href="#l8.148"></a><span id="l8.148" class="difflineminus">-        if (flags &amp; MSG_FLAG_WATCHED)</span>
<a href="#l8.149"></a><span id="l8.149" class="difflineplus">+        if (flags &amp; nsMsgMessageFlags::Watched)</span>
<a href="#l8.150"></a><span id="l8.150">           properties-&gt;AppendElement(kWatchThreadAtom);</span>
<a href="#l8.151"></a><span id="l8.151" class="difflineminus">-        if (flags &amp; MSG_FLAG_IGNORED)</span>
<a href="#l8.152"></a><span id="l8.152" class="difflineplus">+        if (flags &amp; nsMsgMessageFlags::Ignored)</span>
<a href="#l8.153"></a><span id="l8.153">           properties-&gt;AppendElement(kIgnoreThreadAtom);</span>
<a href="#l8.154"></a><span id="l8.154">       }</span>
<a href="#l8.155"></a><span id="l8.155">     }</span>
<a href="#l8.156"></a><span id="l8.156">   }</span>
<a href="#l8.157"></a><span id="l8.157"> </span>
<a href="#l8.158"></a><span id="l8.158">   //custom column handlers are called at the end of getCellProperties</span>
<a href="#l8.159"></a><span id="l8.159">   //to make life easier for extension writers</span>
<a href="#l8.160"></a><span id="l8.160">   nsIMsgCustomColumnHandler* colHandler = GetColumnHandler(colID);</span>
<a href="#l8.161"></a><span id="l8.161" class="difflineat">@@ -1373,17 +1373,17 @@ NS_IMETHODIMP nsMsgDBView::IsContainer(P</span>
<a href="#l8.162"></a><span id="l8.162"> NS_IMETHODIMP nsMsgDBView::IsContainerOpen(PRInt32 index, PRBool *_retval)</span>
<a href="#l8.163"></a><span id="l8.163"> {</span>
<a href="#l8.164"></a><span id="l8.164">   if (!IsValidIndex(index))</span>
<a href="#l8.165"></a><span id="l8.165">       return NS_MSG_INVALID_DBVIEW_INDEX;</span>
<a href="#l8.166"></a><span id="l8.166"> </span>
<a href="#l8.167"></a><span id="l8.167">   if (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay)</span>
<a href="#l8.168"></a><span id="l8.168">   {</span>
<a href="#l8.169"></a><span id="l8.169">     PRUint32 flags = m_flags[index];</span>
<a href="#l8.170"></a><span id="l8.170" class="difflineminus">-    *_retval = (flags &amp; MSG_VIEW_FLAG_HASCHILDREN) &amp;&amp; !(flags &amp; MSG_FLAG_ELIDED);</span>
<a href="#l8.171"></a><span id="l8.171" class="difflineplus">+    *_retval = (flags &amp; MSG_VIEW_FLAG_HASCHILDREN) &amp;&amp; !(flags &amp; nsMsgMessageFlags::Elided);</span>
<a href="#l8.172"></a><span id="l8.172">   }</span>
<a href="#l8.173"></a><span id="l8.173">   else</span>
<a href="#l8.174"></a><span id="l8.174">     *_retval = PR_FALSE;</span>
<a href="#l8.175"></a><span id="l8.175">   return NS_OK;</span>
<a href="#l8.176"></a><span id="l8.176"> }</span>
<a href="#l8.177"></a><span id="l8.177"> </span>
<a href="#l8.178"></a><span id="l8.178"> NS_IMETHODIMP nsMsgDBView::IsContainerEmpty(PRInt32 index, PRBool *_retval)</span>
<a href="#l8.179"></a><span id="l8.179"> {</span>
<a href="#l8.180"></a><span id="l8.180" class="difflineat">@@ -1568,22 +1568,22 @@ NS_IMETHODIMP nsMsgDBView::GetCellValue(</span>
<a href="#l8.181"></a><span id="l8.181">   PRUint32 flags;</span>
<a href="#l8.182"></a><span id="l8.182">   msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l8.183"></a><span id="l8.183"> </span>
<a href="#l8.184"></a><span id="l8.184">   // provide a string &quot;value&quot; for cells that do not normally have text.</span>
<a href="#l8.185"></a><span id="l8.185">   // use empty string for the normal states &quot;Read&quot;, &quot;Not Starred&quot;, &quot;No Attachment&quot; and &quot;Not Junk&quot;</span>
<a href="#l8.186"></a><span id="l8.186">   switch (colID[0])</span>
<a href="#l8.187"></a><span id="l8.187">   {</span>
<a href="#l8.188"></a><span id="l8.188">     case 'a': // attachment column</span>
<a href="#l8.189"></a><span id="l8.189" class="difflineminus">-      aValue.Assign(GetString ((flags &amp; MSG_FLAG_ATTACHMENT) ?</span>
<a href="#l8.190"></a><span id="l8.190" class="difflineplus">+      aValue.Assign(GetString ((flags &amp; nsMsgMessageFlags::Attachment) ?</span>
<a href="#l8.191"></a><span id="l8.191">       NS_LITERAL_STRING(&quot;messageHasAttachment&quot;).get()</span>
<a href="#l8.192"></a><span id="l8.192">       : EmptyString().get()));</span>
<a href="#l8.193"></a><span id="l8.193">       break;</span>
<a href="#l8.194"></a><span id="l8.194">     case 'f': // flagged (starred) column</span>
<a href="#l8.195"></a><span id="l8.195" class="difflineminus">-      aValue.Assign(GetString ((flags &amp; MSG_FLAG_MARKED) ?</span>
<a href="#l8.196"></a><span id="l8.196" class="difflineplus">+      aValue.Assign(GetString ((flags &amp; nsMsgMessageFlags::Marked) ?</span>
<a href="#l8.197"></a><span id="l8.197">       NS_LITERAL_STRING(&quot;messageHasFlag&quot;).get()</span>
<a href="#l8.198"></a><span id="l8.198">       : EmptyString().get()));</span>
<a href="#l8.199"></a><span id="l8.199">       break;</span>
<a href="#l8.200"></a><span id="l8.200">     case 'j': // junk column</span>
<a href="#l8.201"></a><span id="l8.201">       if (!mIsNews)</span>
<a href="#l8.202"></a><span id="l8.202">       {</span>
<a href="#l8.203"></a><span id="l8.203">         nsCString junkScoreStr;</span>
<a href="#l8.204"></a><span id="l8.204">         msgHdr-&gt;GetStringProperty(&quot;junkscore&quot;, getter_Copies(junkScoreStr));</span>
<a href="#l8.205"></a><span id="l8.205" class="difflineat">@@ -1610,17 +1610,17 @@ NS_IMETHODIMP nsMsgDBView::GetCellValue(</span>
<a href="#l8.206"></a><span id="l8.206">             aValue.Assign(GetString (isContainerOpen ?</span>
<a href="#l8.207"></a><span id="l8.207">              NS_LITERAL_STRING(&quot;messageExpanded&quot;).get()</span>
<a href="#l8.208"></a><span id="l8.208">              : NS_LITERAL_STRING(&quot;messageCollapsed&quot;).get()));</span>
<a href="#l8.209"></a><span id="l8.209">           }</span>
<a href="#l8.210"></a><span id="l8.210">         }</span>
<a href="#l8.211"></a><span id="l8.211">       }</span>
<a href="#l8.212"></a><span id="l8.212">       break;</span>
<a href="#l8.213"></a><span id="l8.213">     case 'u': // read/unread column</span>
<a href="#l8.214"></a><span id="l8.214" class="difflineminus">-      aValue.Assign(GetString ((flags &amp; MSG_FLAG_READ) ?</span>
<a href="#l8.215"></a><span id="l8.215" class="difflineplus">+      aValue.Assign(GetString ((flags &amp; nsMsgMessageFlags::Read) ?</span>
<a href="#l8.216"></a><span id="l8.216">       EmptyString().get() : NS_LITERAL_STRING(&quot;messageUnread&quot;).get()));</span>
<a href="#l8.217"></a><span id="l8.217">       break;</span>
<a href="#l8.218"></a><span id="l8.218">     default:</span>
<a href="#l8.219"></a><span id="l8.219">       aValue.Assign(colID);</span>
<a href="#l8.220"></a><span id="l8.220">       break;</span>
<a href="#l8.221"></a><span id="l8.221">   }</span>
<a href="#l8.222"></a><span id="l8.222"> </span>
<a href="#l8.223"></a><span id="l8.223">   return rv;</span>
<a href="#l8.224"></a><span id="l8.224" class="difflineat">@@ -1932,17 +1932,17 @@ NS_IMETHODIMP nsMsgDBView::CycleCell(PRI</span>
<a href="#l8.225"></a><span id="l8.225">       // ### Do we want to keep this behaviour but switch it to tags?</span>
<a href="#l8.226"></a><span id="l8.226">       // We could enumerate over the tags and go to the next one - it looks</span>
<a href="#l8.227"></a><span id="l8.227">       // to me like this wasn't working before tags landed, so maybe not</span>
<a href="#l8.228"></a><span id="l8.228">       // worth bothering with.</span>
<a href="#l8.229"></a><span id="l8.229">     }</span>
<a href="#l8.230"></a><span id="l8.230">     break;</span>
<a href="#l8.231"></a><span id="l8.231">   case 'f': // flagged column</span>
<a href="#l8.232"></a><span id="l8.232">     // toggle the flagged status of the element at row.</span>
<a href="#l8.233"></a><span id="l8.233" class="difflineminus">-    if (m_flags[row] &amp; MSG_FLAG_MARKED)</span>
<a href="#l8.234"></a><span id="l8.234" class="difflineplus">+    if (m_flags[row] &amp; nsMsgMessageFlags::Marked)</span>
<a href="#l8.235"></a><span id="l8.235">       ApplyCommandToIndices(nsMsgViewCommandType::unflagMessages, (nsMsgViewIndex *) &amp;row, 1);</span>
<a href="#l8.236"></a><span id="l8.236">     else</span>
<a href="#l8.237"></a><span id="l8.237">       ApplyCommandToIndices(nsMsgViewCommandType::flagMessages, (nsMsgViewIndex *) &amp;row, 1);</span>
<a href="#l8.238"></a><span id="l8.238">     break;</span>
<a href="#l8.239"></a><span id="l8.239">   case 'j': // junkStatus column</span>
<a href="#l8.240"></a><span id="l8.240">     {</span>
<a href="#l8.241"></a><span id="l8.241">       if (mIsNews) // junk not supported for news yet.</span>
<a href="#l8.242"></a><span id="l8.242">         return NS_OK;</span>
<a href="#l8.243"></a><span id="l8.243" class="difflineat">@@ -2300,17 +2300,17 @@ NS_IMETHODIMP nsMsgDBView::DoCommand(nsM</span>
<a href="#l8.244"></a><span id="l8.244">     else</span>
<a href="#l8.245"></a><span id="l8.245">     {</span>
<a href="#l8.246"></a><span id="l8.246">       mTreeSelection-&gt;SetSelectEventsSuppressed(PR_TRUE);</span>
<a href="#l8.247"></a><span id="l8.247">       mTreeSelection-&gt;ClearSelection();</span>
<a href="#l8.248"></a><span id="l8.248">       // XXX ExpandAll?</span>
<a href="#l8.249"></a><span id="l8.249">       nsMsgViewIndex numIndices = GetSize();</span>
<a href="#l8.250"></a><span id="l8.250">       for (nsMsgViewIndex curIndex = 0; curIndex &lt; numIndices; curIndex++)</span>
<a href="#l8.251"></a><span id="l8.251">       {</span>
<a href="#l8.252"></a><span id="l8.252" class="difflineminus">-        if (m_flags[curIndex] &amp; MSG_FLAG_MARKED)</span>
<a href="#l8.253"></a><span id="l8.253" class="difflineplus">+        if (m_flags[curIndex] &amp; nsMsgMessageFlags::Marked)</span>
<a href="#l8.254"></a><span id="l8.254">           mTreeSelection-&gt;ToggleSelect(curIndex);</span>
<a href="#l8.255"></a><span id="l8.255">       }</span>
<a href="#l8.256"></a><span id="l8.256">       mTreeSelection-&gt;SetSelectEventsSuppressed(PR_FALSE);</span>
<a href="#l8.257"></a><span id="l8.257">     }</span>
<a href="#l8.258"></a><span id="l8.258">     break;</span>
<a href="#l8.259"></a><span id="l8.259">   case nsMsgViewCommandType::markAllRead:</span>
<a href="#l8.260"></a><span id="l8.260">     if (m_folder)</span>
<a href="#l8.261"></a><span id="l8.261">       rv = m_folder-&gt;MarkAllMessagesRead(msgWindow);</span>
<a href="#l8.262"></a><span id="l8.262" class="difflineat">@@ -2637,17 +2637,17 @@ nsMsgDBView::ApplyCommandToIndices(nsMsg</span>
<a href="#l8.263"></a><span id="l8.263">       addFlags = PR_TRUE;</span>
<a href="#l8.264"></a><span id="l8.264">       break;</span>
<a href="#l8.265"></a><span id="l8.265">     case nsMsgViewCommandType::markMessagesUnread:</span>
<a href="#l8.266"></a><span id="l8.266">       flags |= kImapMsgSeenFlag;</span>
<a href="#l8.267"></a><span id="l8.267">       addFlags = PR_FALSE;</span>
<a href="#l8.268"></a><span id="l8.268">       break;</span>
<a href="#l8.269"></a><span id="l8.269">     case nsMsgViewCommandType::toggleMessageRead:</span>
<a href="#l8.270"></a><span id="l8.270">       flags |= kImapMsgSeenFlag;</span>
<a href="#l8.271"></a><span id="l8.271" class="difflineminus">-      addFlags = m_flags[indices[0]] &amp; MSG_FLAG_READ;</span>
<a href="#l8.272"></a><span id="l8.272" class="difflineplus">+      addFlags = m_flags[indices[0]] &amp; nsMsgMessageFlags::Read;</span>
<a href="#l8.273"></a><span id="l8.273">       break;</span>
<a href="#l8.274"></a><span id="l8.274">     case nsMsgViewCommandType::flagMessages:</span>
<a href="#l8.275"></a><span id="l8.275">       flags |= kImapMsgFlaggedFlag;</span>
<a href="#l8.276"></a><span id="l8.276">       addFlags = PR_TRUE;</span>
<a href="#l8.277"></a><span id="l8.277">       break;</span>
<a href="#l8.278"></a><span id="l8.278">     case nsMsgViewCommandType::unflagMessages:</span>
<a href="#l8.279"></a><span id="l8.279">       flags |= kImapMsgFlaggedFlag;</span>
<a href="#l8.280"></a><span id="l8.280">       addFlags = PR_FALSE;</span>
<a href="#l8.281"></a><span id="l8.281" class="difflineat">@@ -2744,17 +2744,17 @@ nsresult nsMsgDBView::DownloadForOffline</span>
<a href="#l8.282"></a><span id="l8.282">     nsMsgKey key = m_keys[indices[index]];</span>
<a href="#l8.283"></a><span id="l8.283">     nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l8.284"></a><span id="l8.284">     rv = m_db-&gt;GetMsgHdrForKey(key, getter_AddRefs(msgHdr));</span>
<a href="#l8.285"></a><span id="l8.285">     NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l8.286"></a><span id="l8.286">     if (msgHdr)</span>
<a href="#l8.287"></a><span id="l8.287">     {</span>
<a href="#l8.288"></a><span id="l8.288">       PRUint32 flags;</span>
<a href="#l8.289"></a><span id="l8.289">       msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l8.290"></a><span id="l8.290" class="difflineminus">-      if (!(flags &amp; MSG_FLAG_OFFLINE))</span>
<a href="#l8.291"></a><span id="l8.291" class="difflineplus">+      if (!(flags &amp; nsMsgMessageFlags::Offline))</span>
<a href="#l8.292"></a><span id="l8.292">         messageArray-&gt;AppendElement(msgHdr, PR_FALSE);</span>
<a href="#l8.293"></a><span id="l8.293">     }</span>
<a href="#l8.294"></a><span id="l8.294">   }</span>
<a href="#l8.295"></a><span id="l8.295">   m_folder-&gt;DownloadMessagesForOffline(messageArray, window);</span>
<a href="#l8.296"></a><span id="l8.296">   return rv;</span>
<a href="#l8.297"></a><span id="l8.297"> }</span>
<a href="#l8.298"></a><span id="l8.298"> </span>
<a href="#l8.299"></a><span id="l8.299"> nsresult nsMsgDBView::DownloadFlaggedForOffline(nsIMsgWindow *window)</span>
<a href="#l8.300"></a><span id="l8.300" class="difflineat">@@ -2771,54 +2771,54 @@ nsresult nsMsgDBView::DownloadFlaggedFor</span>
<a href="#l8.301"></a><span id="l8.301">     {</span>
<a href="#l8.302"></a><span id="l8.302">       nsCOMPtr &lt;nsIMsgDBHdr&gt; pHeader;</span>
<a href="#l8.303"></a><span id="l8.303">       rv = enumerator-&gt;GetNext(getter_AddRefs(pHeader));</span>
<a href="#l8.304"></a><span id="l8.304">       NS_ASSERTION(NS_SUCCEEDED(rv), &quot;nsMsgDBEnumerator broken&quot;);</span>
<a href="#l8.305"></a><span id="l8.305">       if (pHeader &amp;&amp; NS_SUCCEEDED(rv))</span>
<a href="#l8.306"></a><span id="l8.306">       {</span>
<a href="#l8.307"></a><span id="l8.307">         PRUint32 flags;</span>
<a href="#l8.308"></a><span id="l8.308">         pHeader-&gt;GetFlags(&amp;flags);</span>
<a href="#l8.309"></a><span id="l8.309" class="difflineminus">-        if ((flags &amp; MSG_FLAG_MARKED) &amp;&amp; !(flags &amp; MSG_FLAG_OFFLINE))</span>
<a href="#l8.310"></a><span id="l8.310" class="difflineplus">+        if ((flags &amp; nsMsgMessageFlags::Marked) &amp;&amp; !(flags &amp; nsMsgMessageFlags::Offline))</span>
<a href="#l8.311"></a><span id="l8.311">           messageArray-&gt;AppendElement(pHeader, PR_FALSE);</span>
<a href="#l8.312"></a><span id="l8.312">       }</span>
<a href="#l8.313"></a><span id="l8.313">     }</span>
<a href="#l8.314"></a><span id="l8.314">   }</span>
<a href="#l8.315"></a><span id="l8.315">   m_folder-&gt;DownloadMessagesForOffline(messageArray, window);</span>
<a href="#l8.316"></a><span id="l8.316">   return rv;</span>
<a href="#l8.317"></a><span id="l8.317"> }</span>
<a href="#l8.318"></a><span id="l8.318"> </span>
<a href="#l8.319"></a><span id="l8.319"> // read/unread handling.</span>
<a href="#l8.320"></a><span id="l8.320"> nsresult nsMsgDBView::ToggleReadByIndex(nsMsgViewIndex index)</span>
<a href="#l8.321"></a><span id="l8.321"> {</span>
<a href="#l8.322"></a><span id="l8.322">   if (!IsValidIndex(index))</span>
<a href="#l8.323"></a><span id="l8.323">     return NS_MSG_INVALID_DBVIEW_INDEX;</span>
<a href="#l8.324"></a><span id="l8.324" class="difflineminus">-  return SetReadByIndex(index, !(m_flags[index] &amp; MSG_FLAG_READ));</span>
<a href="#l8.325"></a><span id="l8.325" class="difflineplus">+  return SetReadByIndex(index, !(m_flags[index] &amp; nsMsgMessageFlags::Read));</span>
<a href="#l8.326"></a><span id="l8.326"> }</span>
<a href="#l8.327"></a><span id="l8.327"> </span>
<a href="#l8.328"></a><span id="l8.328"> nsresult nsMsgDBView::SetReadByIndex(nsMsgViewIndex index, PRBool read)</span>
<a href="#l8.329"></a><span id="l8.329"> {</span>
<a href="#l8.330"></a><span id="l8.330">   nsresult rv;</span>
<a href="#l8.331"></a><span id="l8.331"> </span>
<a href="#l8.332"></a><span id="l8.332">   if (!IsValidIndex(index))</span>
<a href="#l8.333"></a><span id="l8.333">     return NS_MSG_INVALID_DBVIEW_INDEX;</span>
<a href="#l8.334"></a><span id="l8.334">   if (read)</span>
<a href="#l8.335"></a><span id="l8.335">   {</span>
<a href="#l8.336"></a><span id="l8.336" class="difflineminus">-    OrExtraFlag(index, MSG_FLAG_READ);</span>
<a href="#l8.337"></a><span id="l8.337" class="difflineplus">+    OrExtraFlag(index, nsMsgMessageFlags::Read);</span>
<a href="#l8.338"></a><span id="l8.338">     // MarkRead() will clear this flag in the db</span>
<a href="#l8.339"></a><span id="l8.339">     // and then call OnKeyChange(), but</span>
<a href="#l8.340"></a><span id="l8.340">     // because we are the instigator of the change</span>
<a href="#l8.341"></a><span id="l8.341">     // we'll ignore the change.</span>
<a href="#l8.342"></a><span id="l8.342">     //</span>
<a href="#l8.343"></a><span id="l8.343">     // so we need to clear it in m_flags</span>
<a href="#l8.344"></a><span id="l8.344">     // to keep the db and m_flags in sync</span>
<a href="#l8.345"></a><span id="l8.345" class="difflineminus">-    AndExtraFlag(index, ~MSG_FLAG_NEW);</span>
<a href="#l8.346"></a><span id="l8.346" class="difflineplus">+    AndExtraFlag(index, ~nsMsgMessageFlags::New);</span>
<a href="#l8.347"></a><span id="l8.347">   }</span>
<a href="#l8.348"></a><span id="l8.348">   else</span>
<a href="#l8.349"></a><span id="l8.349">   {</span>
<a href="#l8.350"></a><span id="l8.350" class="difflineminus">-    AndExtraFlag(index, ~MSG_FLAG_READ);</span>
<a href="#l8.351"></a><span id="l8.351" class="difflineplus">+    AndExtraFlag(index, ~nsMsgMessageFlags::Read);</span>
<a href="#l8.352"></a><span id="l8.352">   }</span>
<a href="#l8.353"></a><span id="l8.353"> </span>
<a href="#l8.354"></a><span id="l8.354">   nsCOMPtr &lt;nsIMsgDatabase&gt; dbToUse;</span>
<a href="#l8.355"></a><span id="l8.355">   rv = GetDBForViewIndex(index, getter_AddRefs(dbToUse));</span>
<a href="#l8.356"></a><span id="l8.356">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l8.357"></a><span id="l8.357"> </span>
<a href="#l8.358"></a><span id="l8.358">   rv = dbToUse-&gt;MarkRead(m_keys[index], read, this);</span>
<a href="#l8.359"></a><span id="l8.359">   NoteChange(index, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l8.360"></a><span id="l8.360" class="difflineat">@@ -2848,19 +2848,19 @@ nsresult nsMsgDBView::SetFlaggedByIndex(</span>
<a href="#l8.361"></a><span id="l8.361">   if (!IsValidIndex(index))</span>
<a href="#l8.362"></a><span id="l8.362">     return NS_MSG_INVALID_DBVIEW_INDEX;</span>
<a href="#l8.363"></a><span id="l8.363"> </span>
<a href="#l8.364"></a><span id="l8.364">   nsCOMPtr &lt;nsIMsgDatabase&gt; dbToUse;</span>
<a href="#l8.365"></a><span id="l8.365">   rv = GetDBForViewIndex(index, getter_AddRefs(dbToUse));</span>
<a href="#l8.366"></a><span id="l8.366">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l8.367"></a><span id="l8.367"> </span>
<a href="#l8.368"></a><span id="l8.368">   if (mark)</span>
<a href="#l8.369"></a><span id="l8.369" class="difflineminus">-    OrExtraFlag(index, MSG_FLAG_MARKED);</span>
<a href="#l8.370"></a><span id="l8.370" class="difflineplus">+    OrExtraFlag(index, nsMsgMessageFlags::Marked);</span>
<a href="#l8.371"></a><span id="l8.371">   else</span>
<a href="#l8.372"></a><span id="l8.372" class="difflineminus">-    AndExtraFlag(index, ~MSG_FLAG_MARKED);</span>
<a href="#l8.373"></a><span id="l8.373" class="difflineplus">+    AndExtraFlag(index, ~nsMsgMessageFlags::Marked);</span>
<a href="#l8.374"></a><span id="l8.374"> </span>
<a href="#l8.375"></a><span id="l8.375">   rv = dbToUse-&gt;MarkMarked(m_keys[index], mark, this);</span>
<a href="#l8.376"></a><span id="l8.376">   NoteChange(index, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l8.377"></a><span id="l8.377">   return rv;</span>
<a href="#l8.378"></a><span id="l8.378"> }</span>
<a href="#l8.379"></a><span id="l8.379"> </span>
<a href="#l8.380"></a><span id="l8.380"> nsresult nsMsgDBView::SetStringPropertyByIndex(nsMsgViewIndex index, const char *aProperty, const char *aValue)</span>
<a href="#l8.381"></a><span id="l8.381"> {</span>
<a href="#l8.382"></a><span id="l8.382" class="difflineat">@@ -3374,47 +3374,47 @@ nsresult nsMsgDBView::GetFieldTypeAndLen</span>
<a href="#l8.383"></a><span id="l8.383">         }</span>
<a href="#l8.384"></a><span id="l8.384">         default:</span>
<a href="#l8.385"></a><span id="l8.385">             return NS_ERROR_UNEXPECTED;</span>
<a href="#l8.386"></a><span id="l8.386">     }</span>
<a href="#l8.387"></a><span id="l8.387"> </span>
<a href="#l8.388"></a><span id="l8.388">     return NS_OK;</span>
<a href="#l8.389"></a><span id="l8.389"> }</span>
<a href="#l8.390"></a><span id="l8.390"> </span>
<a href="#l8.391"></a><span id="l8.391" class="difflineminus">-#define MSG_STATUS_MASK (MSG_FLAG_REPLIED | MSG_FLAG_FORWARDED)</span>
<a href="#l8.392"></a><span id="l8.392" class="difflineplus">+#define MSG_STATUS_MASK (nsMsgMessageFlags::Replied | nsMsgMessageFlags::Forwarded)</span>
<a href="#l8.393"></a><span id="l8.393"> </span>
<a href="#l8.394"></a><span id="l8.394"> nsresult nsMsgDBView::GetStatusSortValue(nsIMsgDBHdr *msgHdr, PRUint32 *result)</span>
<a href="#l8.395"></a><span id="l8.395"> {</span>
<a href="#l8.396"></a><span id="l8.396">   NS_ENSURE_ARG_POINTER(msgHdr);</span>
<a href="#l8.397"></a><span id="l8.397">   NS_ENSURE_ARG_POINTER(result);</span>
<a href="#l8.398"></a><span id="l8.398"> </span>
<a href="#l8.399"></a><span id="l8.399">   PRUint32 messageFlags;</span>
<a href="#l8.400"></a><span id="l8.400">   nsresult rv = msgHdr-&gt;GetFlags(&amp;messageFlags);</span>
<a href="#l8.401"></a><span id="l8.401">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l8.402"></a><span id="l8.402"> </span>
<a href="#l8.403"></a><span id="l8.403" class="difflineminus">-  if (messageFlags &amp; MSG_FLAG_NEW)</span>
<a href="#l8.404"></a><span id="l8.404" class="difflineplus">+  if (messageFlags &amp; nsMsgMessageFlags::New)</span>
<a href="#l8.405"></a><span id="l8.405">   {</span>
<a href="#l8.406"></a><span id="l8.406">     // happily, new by definition stands alone</span>
<a href="#l8.407"></a><span id="l8.407">     *result = 0;</span>
<a href="#l8.408"></a><span id="l8.408">     return NS_OK;</span>
<a href="#l8.409"></a><span id="l8.409">   }</span>
<a href="#l8.410"></a><span id="l8.410"> </span>
<a href="#l8.411"></a><span id="l8.411">   switch (messageFlags &amp; MSG_STATUS_MASK)</span>
<a href="#l8.412"></a><span id="l8.412">   {</span>
<a href="#l8.413"></a><span id="l8.413" class="difflineminus">-    case MSG_FLAG_REPLIED:</span>
<a href="#l8.414"></a><span id="l8.414" class="difflineplus">+    case nsMsgMessageFlags::Replied:</span>
<a href="#l8.415"></a><span id="l8.415">         *result = 2;</span>
<a href="#l8.416"></a><span id="l8.416">         break;</span>
<a href="#l8.417"></a><span id="l8.417" class="difflineminus">-    case MSG_FLAG_FORWARDED|MSG_FLAG_REPLIED:</span>
<a href="#l8.418"></a><span id="l8.418" class="difflineplus">+    case nsMsgMessageFlags::Forwarded | nsMsgMessageFlags::Replied:</span>
<a href="#l8.419"></a><span id="l8.419">         *result = 1;</span>
<a href="#l8.420"></a><span id="l8.420">         break;</span>
<a href="#l8.421"></a><span id="l8.421" class="difflineminus">-    case MSG_FLAG_FORWARDED:</span>
<a href="#l8.422"></a><span id="l8.422" class="difflineplus">+    case nsMsgMessageFlags::Forwarded:</span>
<a href="#l8.423"></a><span id="l8.423">         *result = 3;</span>
<a href="#l8.424"></a><span id="l8.424">         break;</span>
<a href="#l8.425"></a><span id="l8.425">     default:</span>
<a href="#l8.426"></a><span id="l8.426" class="difflineminus">-        *result = (messageFlags &amp; MSG_FLAG_READ) ? 4 : 5;</span>
<a href="#l8.427"></a><span id="l8.427" class="difflineplus">+        *result = (messageFlags &amp; nsMsgMessageFlags::Read) ? 4 : 5;</span>
<a href="#l8.428"></a><span id="l8.428">         break;</span>
<a href="#l8.429"></a><span id="l8.429">     }</span>
<a href="#l8.430"></a><span id="l8.430"> </span>
<a href="#l8.431"></a><span id="l8.431">     return NS_OK;</span>
<a href="#l8.432"></a><span id="l8.432"> }</span>
<a href="#l8.433"></a><span id="l8.433"> </span>
<a href="#l8.434"></a><span id="l8.434"> nsresult nsMsgDBView::GetLongField(nsIMsgDBHdr *msgHdr, nsMsgViewSortTypeValue sortType, PRUint32 *result, nsIMsgCustomColumnHandler* colHandler)</span>
<a href="#l8.435"></a><span id="l8.435"> {</span>
<a href="#l8.436"></a><span id="l8.436" class="difflineat">@@ -3443,17 +3443,17 @@ nsresult nsMsgDBView::GetLongField(nsIMs</span>
<a href="#l8.437"></a><span id="l8.437">         *result = nsMsgPriority::highest - priority;</span>
<a href="#l8.438"></a><span id="l8.438">         break;</span>
<a href="#l8.439"></a><span id="l8.439">     case nsMsgViewSortType::byStatus:</span>
<a href="#l8.440"></a><span id="l8.440">         rv = GetStatusSortValue(msgHdr,result);</span>
<a href="#l8.441"></a><span id="l8.441">         break;</span>
<a href="#l8.442"></a><span id="l8.442">     case nsMsgViewSortType::byFlagged:</span>
<a href="#l8.443"></a><span id="l8.443">         bits = 0;</span>
<a href="#l8.444"></a><span id="l8.444">         rv = msgHdr-&gt;GetFlags(&amp;bits);</span>
<a href="#l8.445"></a><span id="l8.445" class="difflineminus">-        *result = !(bits &amp; MSG_FLAG_MARKED);  //make flagged come out on top.</span>
<a href="#l8.446"></a><span id="l8.446" class="difflineplus">+        *result = !(bits &amp; nsMsgMessageFlags::Marked);  //make flagged come out on top.</span>
<a href="#l8.447"></a><span id="l8.447">         break;</span>
<a href="#l8.448"></a><span id="l8.448">     case nsMsgViewSortType::byUnread:</span>
<a href="#l8.449"></a><span id="l8.449">         rv = msgHdr-&gt;GetIsRead(&amp;isRead);</span>
<a href="#l8.450"></a><span id="l8.450">         if (NS_SUCCEEDED(rv))</span>
<a href="#l8.451"></a><span id="l8.451">             *result = !isRead;</span>
<a href="#l8.452"></a><span id="l8.452">         break;</span>
<a href="#l8.453"></a><span id="l8.453">     case nsMsgViewSortType::byJunkStatus:</span>
<a href="#l8.454"></a><span id="l8.454">       {</span>
<a href="#l8.455"></a><span id="l8.455" class="difflineat">@@ -3463,17 +3463,17 @@ nsresult nsMsgDBView::GetLongField(nsIMs</span>
<a href="#l8.456"></a><span id="l8.456">         // junkScoreStr is &quot;&quot;, and &quot;0&quot; - &quot;100&quot;</span>
<a href="#l8.457"></a><span id="l8.457">         // normalize to 0 - 101</span>
<a href="#l8.458"></a><span id="l8.458">         *result = junkScoreStr.IsEmpty() ? (0) : atoi(junkScoreStr.get()) + 1;</span>
<a href="#l8.459"></a><span id="l8.459">       }</span>
<a href="#l8.460"></a><span id="l8.460">       break;</span>
<a href="#l8.461"></a><span id="l8.461">      case nsMsgViewSortType::byAttachments:</span>
<a href="#l8.462"></a><span id="l8.462">         bits = 0;</span>
<a href="#l8.463"></a><span id="l8.463">         rv = msgHdr-&gt;GetFlags(&amp;bits);</span>
<a href="#l8.464"></a><span id="l8.464" class="difflineminus">-        *result = !(bits &amp; MSG_FLAG_ATTACHMENT);</span>
<a href="#l8.465"></a><span id="l8.465" class="difflineplus">+        *result = !(bits &amp; nsMsgMessageFlags::Attachment);</span>
<a href="#l8.466"></a><span id="l8.466">       break;</span>
<a href="#l8.467"></a><span id="l8.467">     case nsMsgViewSortType::byDate:</span>
<a href="#l8.468"></a><span id="l8.468">       // when sorting threads by date, we want the date of the newest msg</span>
<a href="#l8.469"></a><span id="l8.469">       // in the thread</span>
<a href="#l8.470"></a><span id="l8.470">       if (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay</span>
<a href="#l8.471"></a><span id="l8.471">         &amp;&amp; ! (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort))</span>
<a href="#l8.472"></a><span id="l8.472">       {</span>
<a href="#l8.473"></a><span id="l8.473">         nsCOMPtr &lt;nsIMsgThread&gt; thread;</span>
<a href="#l8.474"></a><span id="l8.474" class="difflineat">@@ -4165,29 +4165,29 @@ nsMsgViewIndex nsMsgDBView::FindHdr(nsIM</span>
<a href="#l8.475"></a><span id="l8.475"> }</span>
<a href="#l8.476"></a><span id="l8.476"> </span>
<a href="#l8.477"></a><span id="l8.477"> nsMsgViewIndex  nsMsgDBView::FindKey(nsMsgKey key, PRBool expand)</span>
<a href="#l8.478"></a><span id="l8.478"> {</span>
<a href="#l8.479"></a><span id="l8.479">   nsMsgViewIndex retIndex = nsMsgViewIndex_None;</span>
<a href="#l8.480"></a><span id="l8.480">   retIndex = (nsMsgViewIndex) (m_keys.IndexOf(key));</span>
<a href="#l8.481"></a><span id="l8.481">   // for dummy headers, try to expand if the caller says so. And if the thread is</span>
<a href="#l8.482"></a><span id="l8.482">   // expanded, ignore the dummy header and return the real header index.</span>
<a href="#l8.483"></a><span id="l8.483" class="difflineminus">-  if (retIndex != nsMsgViewIndex_None &amp;&amp; m_flags[retIndex] &amp; MSG_VIEW_FLAG_DUMMY &amp;&amp;  !(m_flags[retIndex] &amp; MSG_FLAG_ELIDED))</span>
<a href="#l8.484"></a><span id="l8.484" class="difflineplus">+  if (retIndex != nsMsgViewIndex_None &amp;&amp; m_flags[retIndex] &amp; MSG_VIEW_FLAG_DUMMY &amp;&amp;  !(m_flags[retIndex] &amp; nsMsgMessageFlags::Elided))</span>
<a href="#l8.485"></a><span id="l8.485">     return (nsMsgViewIndex) m_keys.IndexOf(key, retIndex + 1);</span>
<a href="#l8.486"></a><span id="l8.486">   if (key != nsMsgKey_None &amp;&amp; (retIndex == nsMsgViewIndex_None || m_flags[retIndex] &amp; MSG_VIEW_FLAG_DUMMY)</span>
<a href="#l8.487"></a><span id="l8.487">     &amp;&amp; expand &amp;&amp; m_db)</span>
<a href="#l8.488"></a><span id="l8.488">   {</span>
<a href="#l8.489"></a><span id="l8.489">     nsMsgKey threadKey = GetKeyOfFirstMsgInThread(key);</span>
<a href="#l8.490"></a><span id="l8.490">     if (threadKey != nsMsgKey_None)</span>
<a href="#l8.491"></a><span id="l8.491">     {</span>
<a href="#l8.492"></a><span id="l8.492">       nsMsgViewIndex threadIndex = FindKey(threadKey, PR_FALSE);</span>
<a href="#l8.493"></a><span id="l8.493">       if (threadIndex != nsMsgViewIndex_None)</span>
<a href="#l8.494"></a><span id="l8.494">       {</span>
<a href="#l8.495"></a><span id="l8.495">         PRUint32 flags = m_flags[threadIndex];</span>
<a href="#l8.496"></a><span id="l8.496" class="difflineminus">-        if ((flags &amp; MSG_FLAG_ELIDED) &amp;&amp; NS_SUCCEEDED(ExpandByIndex(threadIndex, nsnull))</span>
<a href="#l8.497"></a><span id="l8.497" class="difflineplus">+        if ((flags &amp; nsMsgMessageFlags::Elided) &amp;&amp; NS_SUCCEEDED(ExpandByIndex(threadIndex, nsnull))</span>
<a href="#l8.498"></a><span id="l8.498">           || (flags &amp; MSG_VIEW_FLAG_DUMMY))</span>
<a href="#l8.499"></a><span id="l8.499">           retIndex = (nsMsgViewIndex) m_keys.IndexOf(key, threadIndex + 1);</span>
<a href="#l8.500"></a><span id="l8.500">       }</span>
<a href="#l8.501"></a><span id="l8.501">     }</span>
<a href="#l8.502"></a><span id="l8.502">   }</span>
<a href="#l8.503"></a><span id="l8.503">   return retIndex;</span>
<a href="#l8.504"></a><span id="l8.504"> }</span>
<a href="#l8.505"></a><span id="l8.505"> </span>
<a href="#l8.506"></a><span id="l8.506" class="difflineat">@@ -4245,17 +4245,17 @@ nsresult nsMsgDBView::ExpansionDelta(nsM</span>
<a href="#l8.507"></a><span id="l8.507">     rv = GetThreadCount(index, &amp;numChildren);</span>
<a href="#l8.508"></a><span id="l8.508">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l8.509"></a><span id="l8.509">   }</span>
<a href="#l8.510"></a><span id="l8.510">   else</span>
<a href="#l8.511"></a><span id="l8.511">   {</span>
<a href="#l8.512"></a><span id="l8.512">     numChildren = CountExpandedThread(index);</span>
<a href="#l8.513"></a><span id="l8.513">   }</span>
<a href="#l8.514"></a><span id="l8.514"> </span>
<a href="#l8.515"></a><span id="l8.515" class="difflineminus">-  if (flags &amp; MSG_FLAG_ELIDED)</span>
<a href="#l8.516"></a><span id="l8.516" class="difflineplus">+  if (flags &amp; nsMsgMessageFlags::Elided)</span>
<a href="#l8.517"></a><span id="l8.517">     *expansionDelta = numChildren - 1;</span>
<a href="#l8.518"></a><span id="l8.518">   else</span>
<a href="#l8.519"></a><span id="l8.519">     *expansionDelta = - (PRInt32) (numChildren - 1);</span>
<a href="#l8.520"></a><span id="l8.520"> </span>
<a href="#l8.521"></a><span id="l8.521">   return NS_OK;</span>
<a href="#l8.522"></a><span id="l8.522"> }</span>
<a href="#l8.523"></a><span id="l8.523"> </span>
<a href="#l8.524"></a><span id="l8.524"> nsresult nsMsgDBView::ToggleExpansion(nsMsgViewIndex index, PRUint32 *numChanged)</span>
<a href="#l8.525"></a><span id="l8.525" class="difflineat">@@ -4269,17 +4269,17 @@ nsresult nsMsgDBView::ToggleExpansion(ns</span>
<a href="#l8.526"></a><span id="l8.526">     return NS_MSG_MESSAGE_NOT_FOUND;</span>
<a href="#l8.527"></a><span id="l8.527">   }</span>
<a href="#l8.528"></a><span id="l8.528">   PRInt32  flags = m_flags[threadIndex];</span>
<a href="#l8.529"></a><span id="l8.529"> </span>
<a href="#l8.530"></a><span id="l8.530">   // if not a thread, or doesn't have children, no expand/collapse</span>
<a href="#l8.531"></a><span id="l8.531">   // If we add sub-thread expand collapse, this will need to be relaxed</span>
<a href="#l8.532"></a><span id="l8.532">   if (!(flags &amp; MSG_VIEW_FLAG_ISTHREAD) || !(flags &amp; MSG_VIEW_FLAG_HASCHILDREN))</span>
<a href="#l8.533"></a><span id="l8.533">     return NS_MSG_MESSAGE_NOT_FOUND;</span>
<a href="#l8.534"></a><span id="l8.534" class="difflineminus">-  if (flags &amp; MSG_FLAG_ELIDED)</span>
<a href="#l8.535"></a><span id="l8.535" class="difflineplus">+  if (flags &amp; nsMsgMessageFlags::Elided)</span>
<a href="#l8.536"></a><span id="l8.536">     return ExpandByIndex(threadIndex, numChanged);</span>
<a href="#l8.537"></a><span id="l8.537">   else</span>
<a href="#l8.538"></a><span id="l8.538">     return CollapseByIndex(threadIndex, numChanged);</span>
<a href="#l8.539"></a><span id="l8.539"> </span>
<a href="#l8.540"></a><span id="l8.540"> }</span>
<a href="#l8.541"></a><span id="l8.541"> </span>
<a href="#l8.542"></a><span id="l8.542"> nsresult nsMsgDBView::ExpandAndSelectThread()</span>
<a href="#l8.543"></a><span id="l8.543"> {</span>
<a href="#l8.544"></a><span id="l8.544" class="difflineat">@@ -4321,17 +4321,17 @@ nsresult nsMsgDBView::ExpandAndSelectThr</span>
<a href="#l8.545"></a><span id="l8.545">   }</span>
<a href="#l8.546"></a><span id="l8.546"> </span>
<a href="#l8.547"></a><span id="l8.547">   PRInt32 flags = m_flags[threadIndex];</span>
<a href="#l8.548"></a><span id="l8.548">   PRInt32 count = 0;</span>
<a href="#l8.549"></a><span id="l8.549"> </span>
<a href="#l8.550"></a><span id="l8.550">   if (inThreadedMode &amp;&amp; (flags &amp; MSG_VIEW_FLAG_ISTHREAD) &amp;&amp; (flags &amp; MSG_VIEW_FLAG_HASCHILDREN))</span>
<a href="#l8.551"></a><span id="l8.551">   {</span>
<a href="#l8.552"></a><span id="l8.552">     // if closed, expand this thread.</span>
<a href="#l8.553"></a><span id="l8.553" class="difflineminus">-    if (flags &amp; MSG_FLAG_ELIDED)</span>
<a href="#l8.554"></a><span id="l8.554" class="difflineplus">+    if (flags &amp; nsMsgMessageFlags::Elided)</span>
<a href="#l8.555"></a><span id="l8.555">     {</span>
<a href="#l8.556"></a><span id="l8.556">       PRUint32 numExpanded;</span>
<a href="#l8.557"></a><span id="l8.557">       rv = ExpandByIndex(threadIndex, &amp;numExpanded);</span>
<a href="#l8.558"></a><span id="l8.558">       NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l8.559"></a><span id="l8.559">     }</span>
<a href="#l8.560"></a><span id="l8.560"> </span>
<a href="#l8.561"></a><span id="l8.561">     // get the number of messages in the expanded thread</span>
<a href="#l8.562"></a><span id="l8.562">     // so we know how many to select</span>
<a href="#l8.563"></a><span id="l8.563" class="difflineat">@@ -4357,17 +4357,17 @@ nsresult nsMsgDBView::ExpandAndSelectThr</span>
<a href="#l8.564"></a><span id="l8.564"> nsresult nsMsgDBView::ExpandAll()</span>
<a href="#l8.565"></a><span id="l8.565"> {</span>
<a href="#l8.566"></a><span id="l8.566">   if (mTree)</span>
<a href="#l8.567"></a><span id="l8.567">     mTree-&gt;BeginUpdateBatch();</span>
<a href="#l8.568"></a><span id="l8.568">   for (PRInt32 i = GetSize() - 1; i &gt;= 0; i--)</span>
<a href="#l8.569"></a><span id="l8.569">   {</span>
<a href="#l8.570"></a><span id="l8.570">     PRUint32 numExpanded;</span>
<a href="#l8.571"></a><span id="l8.571">     PRUint32 flags = m_flags[i];</span>
<a href="#l8.572"></a><span id="l8.572" class="difflineminus">-    if (flags &amp; MSG_FLAG_ELIDED)</span>
<a href="#l8.573"></a><span id="l8.573" class="difflineplus">+    if (flags &amp; nsMsgMessageFlags::Elided)</span>
<a href="#l8.574"></a><span id="l8.574">       ExpandByIndex(i, &amp;numExpanded);</span>
<a href="#l8.575"></a><span id="l8.575">   }</span>
<a href="#l8.576"></a><span id="l8.576">   if (mTree)</span>
<a href="#l8.577"></a><span id="l8.577">     mTree-&gt;EndUpdateBatch();</span>
<a href="#l8.578"></a><span id="l8.578">   return NS_OK;</span>
<a href="#l8.579"></a><span id="l8.579"> }</span>
<a href="#l8.580"></a><span id="l8.580"> </span>
<a href="#l8.581"></a><span id="l8.581"> nsresult nsMsgDBView::GetThreadContainingMsgHdr(nsIMsgDBHdr *msgHdr, nsIMsgThread **pThread)</span>
<a href="#l8.582"></a><span id="l8.582" class="difflineat">@@ -4375,31 +4375,31 @@ nsresult nsMsgDBView::GetThreadContainin</span>
<a href="#l8.583"></a><span id="l8.583">   return m_db-&gt;GetThreadContainingMsgHdr(msgHdr, pThread);</span>
<a href="#l8.584"></a><span id="l8.584"> }</span>
<a href="#l8.585"></a><span id="l8.585"> </span>
<a href="#l8.586"></a><span id="l8.586"> nsresult nsMsgDBView::ExpandByIndex(nsMsgViewIndex index, PRUint32 *pNumExpanded)</span>
<a href="#l8.587"></a><span id="l8.587"> {</span>
<a href="#l8.588"></a><span id="l8.588">   PRUint32      flags = m_flags[index];</span>
<a href="#l8.589"></a><span id="l8.589">   PRUint32      numExpanded = 0;</span>
<a href="#l8.590"></a><span id="l8.590"> </span>
<a href="#l8.591"></a><span id="l8.591" class="difflineminus">-  NS_ASSERTION(flags &amp; MSG_FLAG_ELIDED, &quot;can't expand an already expanded thread&quot;);</span>
<a href="#l8.592"></a><span id="l8.592" class="difflineminus">-  flags &amp;= ~MSG_FLAG_ELIDED;</span>
<a href="#l8.593"></a><span id="l8.593" class="difflineplus">+  NS_ASSERTION(flags &amp; nsMsgMessageFlags::Elided, &quot;can't expand an already expanded thread&quot;);</span>
<a href="#l8.594"></a><span id="l8.594" class="difflineplus">+  flags &amp;= ~nsMsgMessageFlags::Elided;</span>
<a href="#l8.595"></a><span id="l8.595"> </span>
<a href="#l8.596"></a><span id="l8.596">   if ((PRUint32) index &gt; m_keys.Length())</span>
<a href="#l8.597"></a><span id="l8.597">     return NS_MSG_MESSAGE_NOT_FOUND;</span>
<a href="#l8.598"></a><span id="l8.598"> </span>
<a href="#l8.599"></a><span id="l8.599">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l8.600"></a><span id="l8.600">   nsCOMPtr &lt;nsIMsgThread&gt; pThread;</span>
<a href="#l8.601"></a><span id="l8.601">   nsresult rv = GetThreadContainingIndex(index, getter_AddRefs(pThread));</span>
<a href="#l8.602"></a><span id="l8.602">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l8.603"></a><span id="l8.603">   m_flags[index] = flags;</span>
<a href="#l8.604"></a><span id="l8.604">   NoteChange(index, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l8.605"></a><span id="l8.605">   if (m_viewFlags &amp; nsMsgViewFlagsType::kUnreadOnly)</span>
<a href="#l8.606"></a><span id="l8.606">   {</span>
<a href="#l8.607"></a><span id="l8.607" class="difflineminus">-    if (flags &amp; MSG_FLAG_READ)</span>
<a href="#l8.608"></a><span id="l8.608" class="difflineplus">+    if (flags &amp; nsMsgMessageFlags::Read)</span>
<a href="#l8.609"></a><span id="l8.609">       m_levels.AppendElement(0);  // keep top level hdr in thread, even though read.</span>
<a href="#l8.610"></a><span id="l8.610">     rv = ListUnreadIdsInThread(pThread,  index, &amp;numExpanded);</span>
<a href="#l8.611"></a><span id="l8.611">   }</span>
<a href="#l8.612"></a><span id="l8.612">   else</span>
<a href="#l8.613"></a><span id="l8.613">     rv = ListIdsInThread(pThread,  index, &amp;numExpanded);</span>
<a href="#l8.614"></a><span id="l8.614"> </span>
<a href="#l8.615"></a><span id="l8.615">   NoteStartChange(index + 1, numExpanded, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l8.616"></a><span id="l8.616">   NoteEndChange(index + 1, numExpanded, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l8.617"></a><span id="l8.617" class="difflineat">@@ -4409,31 +4409,31 @@ nsresult nsMsgDBView::ExpandByIndex(nsMs</span>
<a href="#l8.618"></a><span id="l8.618"> }</span>
<a href="#l8.619"></a><span id="l8.619"> </span>
<a href="#l8.620"></a><span id="l8.620"> nsresult nsMsgDBView::CollapseAll()</span>
<a href="#l8.621"></a><span id="l8.621"> {</span>
<a href="#l8.622"></a><span id="l8.622">   for (PRInt32 i = 0; i &lt; GetSize(); i++)</span>
<a href="#l8.623"></a><span id="l8.623">   {</span>
<a href="#l8.624"></a><span id="l8.624">     PRUint32 numExpanded;</span>
<a href="#l8.625"></a><span id="l8.625">     PRUint32 flags = m_flags[i];</span>
<a href="#l8.626"></a><span id="l8.626" class="difflineminus">-    if (!(flags &amp; MSG_FLAG_ELIDED) &amp;&amp; (flags &amp; MSG_VIEW_FLAG_HASCHILDREN))</span>
<a href="#l8.627"></a><span id="l8.627" class="difflineplus">+    if (!(flags &amp; nsMsgMessageFlags::Elided) &amp;&amp; (flags &amp; MSG_VIEW_FLAG_HASCHILDREN))</span>
<a href="#l8.628"></a><span id="l8.628">       CollapseByIndex(i, &amp;numExpanded);</span>
<a href="#l8.629"></a><span id="l8.629">   }</span>
<a href="#l8.630"></a><span id="l8.630">   return NS_OK;</span>
<a href="#l8.631"></a><span id="l8.631"> }</span>
<a href="#l8.632"></a><span id="l8.632"> </span>
<a href="#l8.633"></a><span id="l8.633"> nsresult nsMsgDBView::CollapseByIndex(nsMsgViewIndex index, PRUint32 *pNumCollapsed)</span>
<a href="#l8.634"></a><span id="l8.634"> {</span>
<a href="#l8.635"></a><span id="l8.635">   nsresult  rv;</span>
<a href="#l8.636"></a><span id="l8.636">   PRInt32  flags = m_flags[index];</span>
<a href="#l8.637"></a><span id="l8.637">   PRInt32  threadCount = 0;</span>
<a href="#l8.638"></a><span id="l8.638"> </span>
<a href="#l8.639"></a><span id="l8.639" class="difflineminus">-  if (flags &amp; MSG_FLAG_ELIDED || !(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay) || !(flags &amp; MSG_VIEW_FLAG_HASCHILDREN))</span>
<a href="#l8.640"></a><span id="l8.640" class="difflineplus">+  if (flags &amp; nsMsgMessageFlags::Elided || !(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay) || !(flags &amp; MSG_VIEW_FLAG_HASCHILDREN))</span>
<a href="#l8.641"></a><span id="l8.641">     return NS_OK;</span>
<a href="#l8.642"></a><span id="l8.642" class="difflineminus">-  flags  |= MSG_FLAG_ELIDED;</span>
<a href="#l8.643"></a><span id="l8.643" class="difflineplus">+  flags |= nsMsgMessageFlags::Elided;</span>
<a href="#l8.644"></a><span id="l8.644"> </span>
<a href="#l8.645"></a><span id="l8.645">   if (index &gt; m_keys.Length())</span>
<a href="#l8.646"></a><span id="l8.646">     return NS_MSG_MESSAGE_NOT_FOUND;</span>
<a href="#l8.647"></a><span id="l8.647"> </span>
<a href="#l8.648"></a><span id="l8.648">   m_flags[index] = flags;</span>
<a href="#l8.649"></a><span id="l8.649">   NoteChange(index, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l8.650"></a><span id="l8.650"> </span>
<a href="#l8.651"></a><span id="l8.651">   rv = ExpansionDelta(index, &amp;threadCount);</span>
<a href="#l8.652"></a><span id="l8.652" class="difflineat">@@ -4706,17 +4706,17 @@ nsresult  nsMsgDBView::AddHdr(nsIMsgDBHd</span>
<a href="#l8.653"></a><span id="l8.653"> </span>
<a href="#l8.654"></a><span id="l8.654">   if (!GetShowingIgnored())</span>
<a href="#l8.655"></a><span id="l8.655">   {</span>
<a href="#l8.656"></a><span id="l8.656">     nsCOMPtr &lt;nsIMsgThread&gt; thread;</span>
<a href="#l8.657"></a><span id="l8.657">     GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(thread));</span>
<a href="#l8.658"></a><span id="l8.658">     if (thread)</span>
<a href="#l8.659"></a><span id="l8.659">     {</span>
<a href="#l8.660"></a><span id="l8.660">       thread-&gt;GetFlags(&amp;flags);</span>
<a href="#l8.661"></a><span id="l8.661" class="difflineminus">-      if (flags &amp; MSG_FLAG_IGNORED)</span>
<a href="#l8.662"></a><span id="l8.662" class="difflineplus">+      if (flags &amp; nsMsgMessageFlags::Ignored)</span>
<a href="#l8.663"></a><span id="l8.663">         return NS_OK;</span>
<a href="#l8.664"></a><span id="l8.664">     }</span>
<a href="#l8.665"></a><span id="l8.665"> </span>
<a href="#l8.666"></a><span id="l8.666">     PRBool ignored;</span>
<a href="#l8.667"></a><span id="l8.667">     msgHdr-&gt;GetIsKilled(&amp;ignored);</span>
<a href="#l8.668"></a><span id="l8.668">     if (ignored)</span>
<a href="#l8.669"></a><span id="l8.669">        return NS_OK;</span>
<a href="#l8.670"></a><span id="l8.670">   }</span>
<a href="#l8.671"></a><span id="l8.671" class="difflineat">@@ -4842,17 +4842,17 @@ nsresult nsMsgDBView::ListIdsInThreadOrd</span>
<a href="#l8.672"></a><span id="l8.672"> </span>
<a href="#l8.673"></a><span id="l8.673">       nsMsgKey msgKey;</span>
<a href="#l8.674"></a><span id="l8.674">       PRUint32 msgFlags, newFlags;</span>
<a href="#l8.675"></a><span id="l8.675">       msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l8.676"></a><span id="l8.676">       msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l8.677"></a><span id="l8.677">       AdjustReadFlag(msgHdr, &amp;msgFlags);</span>
<a href="#l8.678"></a><span id="l8.678">       SetMsgHdrAt(msgHdr, *viewIndex, msgKey, msgFlags &amp; ~MSG_VIEW_FLAGS, level);</span>
<a href="#l8.679"></a><span id="l8.679">       // turn off thread or elided bit if they got turned on (maybe from new only view?)</span>
<a href="#l8.680"></a><span id="l8.680" class="difflineminus">-      msgHdr-&gt;AndFlags(~(MSG_VIEW_FLAG_ISTHREAD | MSG_FLAG_ELIDED), &amp;newFlags);</span>
<a href="#l8.681"></a><span id="l8.681" class="difflineplus">+      msgHdr-&gt;AndFlags(~(MSG_VIEW_FLAG_ISTHREAD | nsMsgMessageFlags::Elided), &amp;newFlags);</span>
<a href="#l8.682"></a><span id="l8.682">       (*pNumListed)++;</span>
<a href="#l8.683"></a><span id="l8.683">       (*viewIndex)++;</span>
<a href="#l8.684"></a><span id="l8.684">       rv = ListIdsInThreadOrder(threadHdr, msgKey, level + 1, viewIndex, pNumListed);</span>
<a href="#l8.685"></a><span id="l8.685">     }</span>
<a href="#l8.686"></a><span id="l8.686">   }</span>
<a href="#l8.687"></a><span id="l8.687">   return rv; // we don't want to return the rv from the enumerator when it reaches the end, do we?</span>
<a href="#l8.688"></a><span id="l8.688"> }</span>
<a href="#l8.689"></a><span id="l8.689"> </span>
<a href="#l8.690"></a><span id="l8.690" class="difflineat">@@ -4921,17 +4921,17 @@ nsresult nsMsgDBView::ListIdsInThread(ns</span>
<a href="#l8.691"></a><span id="l8.691">         PRUint32 msgFlags, newFlags;</span>
<a href="#l8.692"></a><span id="l8.692">         msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l8.693"></a><span id="l8.693">         msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l8.694"></a><span id="l8.694">         AdjustReadFlag(msgHdr, &amp;msgFlags);</span>
<a href="#l8.695"></a><span id="l8.695">         SetMsgHdrAt(msgHdr, viewIndex, msgKey, msgFlags &amp; ~MSG_VIEW_FLAGS, 1);</span>
<a href="#l8.696"></a><span id="l8.696">         // here, we're either flat, or we're grouped - in either case, level is 1</span>
<a href="#l8.697"></a><span id="l8.697">         // turn off thread or elided bit if they got turned on (maybe from new only view?)</span>
<a href="#l8.698"></a><span id="l8.698">         if (i &gt; 0)</span>
<a href="#l8.699"></a><span id="l8.699" class="difflineminus">-          msgHdr-&gt;AndFlags(~(MSG_VIEW_FLAG_ISTHREAD | MSG_FLAG_ELIDED), &amp;newFlags);</span>
<a href="#l8.700"></a><span id="l8.700" class="difflineplus">+          msgHdr-&gt;AndFlags(~(MSG_VIEW_FLAG_ISTHREAD | nsMsgMessageFlags::Elided), &amp;newFlags);</span>
<a href="#l8.701"></a><span id="l8.701">         (*pNumListed)++;</span>
<a href="#l8.702"></a><span id="l8.702">         viewIndex++;</span>
<a href="#l8.703"></a><span id="l8.703">       }</span>
<a href="#l8.704"></a><span id="l8.704">     }</span>
<a href="#l8.705"></a><span id="l8.705">     if (ignoredHeaders + *pNumListed &lt; numChildren)</span>
<a href="#l8.706"></a><span id="l8.706">     {</span>
<a href="#l8.707"></a><span id="l8.707">       NS_NOTREACHED(&quot;thread corrupt in db&quot;);</span>
<a href="#l8.708"></a><span id="l8.708">       // if we've listed fewer messages than are in the thread, then the db</span>
<a href="#l8.709"></a><span id="l8.709" class="difflineat">@@ -5273,29 +5273,29 @@ NS_IMETHODIMP nsMsgDBView::OnHdrFlagsCha</span>
<a href="#l8.710"></a><span id="l8.710">   if (aInstigator != this)</span>
<a href="#l8.711"></a><span id="l8.711">   {</span>
<a href="#l8.712"></a><span id="l8.712">     NS_ENSURE_ARG_POINTER(aHdrChanged);</span>
<a href="#l8.713"></a><span id="l8.713">     nsMsgKey msgKey;</span>
<a href="#l8.714"></a><span id="l8.714">     aHdrChanged-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l8.715"></a><span id="l8.715">     nsMsgViewIndex index = FindHdr(aHdrChanged);</span>
<a href="#l8.716"></a><span id="l8.716">     if (index != nsMsgViewIndex_None)</span>
<a href="#l8.717"></a><span id="l8.717">     {</span>
<a href="#l8.718"></a><span id="l8.718" class="difflineminus">-      PRUint32 viewOnlyFlags = m_flags[index] &amp; (MSG_VIEW_FLAGS | MSG_FLAG_ELIDED);</span>
<a href="#l8.719"></a><span id="l8.719" class="difflineplus">+      PRUint32 viewOnlyFlags = m_flags[index] &amp; (MSG_VIEW_FLAGS | nsMsgMessageFlags::Elided);</span>
<a href="#l8.720"></a><span id="l8.720"> </span>
<a href="#l8.721"></a><span id="l8.721">       // ### what about saving the old view only flags, like IsThread and HasChildren?</span>
<a href="#l8.722"></a><span id="l8.722">       // I think we'll want to save those away.</span>
<a href="#l8.723"></a><span id="l8.723">       m_flags[index] = aNewFlags | viewOnlyFlags;</span>
<a href="#l8.724"></a><span id="l8.724">       // tell the view the extra flag changed, so it can</span>
<a href="#l8.725"></a><span id="l8.725">       // update the previous view, if any.</span>
<a href="#l8.726"></a><span id="l8.726">       OnExtraFlagChanged(index, aNewFlags);</span>
<a href="#l8.727"></a><span id="l8.727">       NoteChange(index, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l8.728"></a><span id="l8.728">     }</span>
<a href="#l8.729"></a><span id="l8.729"> </span>
<a href="#l8.730"></a><span id="l8.730">     PRUint32 deltaFlags = (aOldFlags ^ aNewFlags);</span>
<a href="#l8.731"></a><span id="l8.731" class="difflineminus">-    if (deltaFlags &amp; (MSG_FLAG_READ | MSG_FLAG_NEW))</span>
<a href="#l8.732"></a><span id="l8.732" class="difflineplus">+    if (deltaFlags &amp; (nsMsgMessageFlags::Read | nsMsgMessageFlags::New))</span>
<a href="#l8.733"></a><span id="l8.733">     {</span>
<a href="#l8.734"></a><span id="l8.734">       nsMsgViewIndex threadIndex = GetThreadIndex(index);</span>
<a href="#l8.735"></a><span id="l8.735">       // may need to fix thread counts</span>
<a href="#l8.736"></a><span id="l8.736">       if (threadIndex != nsMsgViewIndex_None &amp;&amp; threadIndex != index)</span>
<a href="#l8.737"></a><span id="l8.737">         NoteChange(threadIndex, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l8.738"></a><span id="l8.738">     }</span>
<a href="#l8.739"></a><span id="l8.739">  }</span>
<a href="#l8.740"></a><span id="l8.740">   // don't need to propagate notifications, right?</span>
<a href="#l8.741"></a><span id="l8.741" class="difflineat">@@ -5522,17 +5522,17 @@ nsresult nsMsgDBView::MarkThreadOfMsgRea</span>
<a href="#l8.742"></a><span id="l8.742">         threadIndex = msgIndex;</span>
<a href="#l8.743"></a><span id="l8.743">     return MarkThreadRead(threadHdr, threadIndex, idsMarkedRead, bRead);</span>
<a href="#l8.744"></a><span id="l8.744"> }</span>
<a href="#l8.745"></a><span id="l8.745"> </span>
<a href="#l8.746"></a><span id="l8.746"> nsresult nsMsgDBView::MarkThreadRead(nsIMsgThread *threadHdr, nsMsgViewIndex threadIndex, nsTArray&lt;nsMsgKey&gt; &amp;idsMarkedRead, PRBool bRead)</span>
<a href="#l8.747"></a><span id="l8.747"> {</span>
<a href="#l8.748"></a><span id="l8.748">     PRBool threadElided = PR_TRUE;</span>
<a href="#l8.749"></a><span id="l8.749">     if (threadIndex != nsMsgViewIndex_None)</span>
<a href="#l8.750"></a><span id="l8.750" class="difflineminus">-        threadElided = (m_flags[threadIndex] &amp; MSG_FLAG_ELIDED);</span>
<a href="#l8.751"></a><span id="l8.751" class="difflineplus">+        threadElided = (m_flags[threadIndex] &amp; nsMsgMessageFlags::Elided);</span>
<a href="#l8.752"></a><span id="l8.752"> </span>
<a href="#l8.753"></a><span id="l8.753">     PRUint32 numChildren;</span>
<a href="#l8.754"></a><span id="l8.754">     threadHdr-&gt;GetNumChildren(&amp;numChildren);</span>
<a href="#l8.755"></a><span id="l8.755">     idsMarkedRead.SetCapacity(numChildren);</span>
<a href="#l8.756"></a><span id="l8.756">     for (PRInt32 childIndex = 0; childIndex &lt; (PRInt32) numChildren ; childIndex++)</span>
<a href="#l8.757"></a><span id="l8.757">     {</span>
<a href="#l8.758"></a><span id="l8.758">         nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l8.759"></a><span id="l8.759">         threadHdr-&gt;GetChildHdrAt(childIndex, getter_AddRefs(msgHdr));</span>
<a href="#l8.760"></a><span id="l8.760" class="difflineat">@@ -5557,29 +5557,29 @@ nsresult nsMsgDBView::MarkThreadRead(nsI</span>
<a href="#l8.761"></a><span id="l8.761"> </span>
<a href="#l8.762"></a><span id="l8.762">     return NS_OK;</span>
<a href="#l8.763"></a><span id="l8.763"> }</span>
<a href="#l8.764"></a><span id="l8.764"> </span>
<a href="#l8.765"></a><span id="l8.765"> PRBool nsMsgDBView::AdjustReadFlag(nsIMsgDBHdr *msgHdr, PRUint32 *msgFlags)</span>
<a href="#l8.766"></a><span id="l8.766"> {</span>
<a href="#l8.767"></a><span id="l8.767">   // if we're a cross-folder view, just bail on this.</span>
<a href="#l8.768"></a><span id="l8.768">   if (GetFolders())</span>
<a href="#l8.769"></a><span id="l8.769" class="difflineminus">-    return *msgFlags &amp; MSG_FLAG_READ;</span>
<a href="#l8.770"></a><span id="l8.770" class="difflineplus">+    return *msgFlags &amp; nsMsgMessageFlags::Read;</span>
<a href="#l8.771"></a><span id="l8.771">   PRBool isRead = PR_FALSE;</span>
<a href="#l8.772"></a><span id="l8.772">   nsMsgKey msgKey;</span>
<a href="#l8.773"></a><span id="l8.773">   msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l8.774"></a><span id="l8.774">   m_db-&gt;IsRead(msgKey, &amp;isRead);</span>
<a href="#l8.775"></a><span id="l8.775">     // just make sure flag is right in db.</span>
<a href="#l8.776"></a><span id="l8.776"> #ifdef DEBUG_David_Bienvenu</span>
<a href="#l8.777"></a><span id="l8.777" class="difflineminus">-  NS_ASSERTION(isRead == ((*msgFlags &amp; MSG_FLAG_READ) != 0), &quot;msgFlags out of sync&quot;);</span>
<a href="#l8.778"></a><span id="l8.778" class="difflineplus">+  NS_ASSERTION(isRead == ((*msgFlags &amp; nsMsgMessageFlags::Read) != 0), &quot;msgFlags out of sync&quot;);</span>
<a href="#l8.779"></a><span id="l8.779"> #endif</span>
<a href="#l8.780"></a><span id="l8.780">   if (isRead)</span>
<a href="#l8.781"></a><span id="l8.781" class="difflineminus">-    *msgFlags |= MSG_FLAG_READ;</span>
<a href="#l8.782"></a><span id="l8.782" class="difflineplus">+    *msgFlags |= nsMsgMessageFlags::Read;</span>
<a href="#l8.783"></a><span id="l8.783">   else</span>
<a href="#l8.784"></a><span id="l8.784" class="difflineminus">-    *msgFlags &amp;= ~MSG_FLAG_READ;</span>
<a href="#l8.785"></a><span id="l8.785" class="difflineplus">+    *msgFlags &amp;= ~nsMsgMessageFlags::Read;</span>
<a href="#l8.786"></a><span id="l8.786">   m_db-&gt;MarkHdrRead(msgHdr, isRead, nsnull);</span>
<a href="#l8.787"></a><span id="l8.787">   return isRead;</span>
<a href="#l8.788"></a><span id="l8.788"> }</span>
<a href="#l8.789"></a><span id="l8.789"> </span>
<a href="#l8.790"></a><span id="l8.790"> // Starting from startIndex, performs the passed in navigation, including</span>
<a href="#l8.791"></a><span id="l8.791"> // any marking read needed, and returns the resultId and resultIndex of the</span>
<a href="#l8.792"></a><span id="l8.792"> // destination of the navigation.  If no message is found in the view,</span>
<a href="#l8.793"></a><span id="l8.793"> // it returns a resultId of nsMsgKey_None and an resultIndex of nsMsgViewIndex_None.</span>
<a href="#l8.794"></a><span id="l8.794" class="difflineat">@@ -5662,24 +5662,24 @@ nsresult nsMsgDBView::NavigateFromPos(ns</span>
<a href="#l8.795"></a><span id="l8.795">             break;</span>
<a href="#l8.796"></a><span id="l8.796">         case nsMsgNavigationType::firstUnreadMessage:</span>
<a href="#l8.797"></a><span id="l8.797">             startIndex = nsMsgViewIndex_None;        // note fall thru - is this motion ever used?</span>
<a href="#l8.798"></a><span id="l8.798">         case nsMsgNavigationType::nextUnreadMessage:</span>
<a href="#l8.799"></a><span id="l8.799">             for (curIndex = (startIndex == nsMsgViewIndex_None) ? 0 : startIndex; curIndex &lt;= lastIndex &amp;&amp; lastIndex != nsMsgViewIndex_None; curIndex++) {</span>
<a href="#l8.800"></a><span id="l8.800">                 PRUint32 flags = m_flags[curIndex];</span>
<a href="#l8.801"></a><span id="l8.801"> </span>
<a href="#l8.802"></a><span id="l8.802">                 // don't return start index since navigate should move</span>
<a href="#l8.803"></a><span id="l8.803" class="difflineminus">-                if (!(flags &amp; (MSG_FLAG_READ | MSG_VIEW_FLAG_DUMMY)) &amp;&amp; (curIndex != startIndex))</span>
<a href="#l8.804"></a><span id="l8.804" class="difflineplus">+                if (!(flags &amp; (nsMsgMessageFlags::Read | MSG_VIEW_FLAG_DUMMY)) &amp;&amp; (curIndex != startIndex))</span>
<a href="#l8.805"></a><span id="l8.805">                 {</span>
<a href="#l8.806"></a><span id="l8.806">                     *pResultIndex = curIndex;</span>
<a href="#l8.807"></a><span id="l8.807">                     *pResultKey = m_keys[*pResultIndex];</span>
<a href="#l8.808"></a><span id="l8.808">                     break;</span>
<a href="#l8.809"></a><span id="l8.809">                 }</span>
<a href="#l8.810"></a><span id="l8.810">                 // check for collapsed thread with new children</span>
<a href="#l8.811"></a><span id="l8.811" class="difflineminus">-                if ((m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay) &amp;&amp; flags &amp; MSG_VIEW_FLAG_ISTHREAD &amp;&amp; flags &amp; MSG_FLAG_ELIDED) {</span>
<a href="#l8.812"></a><span id="l8.812" class="difflineplus">+                if ((m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay) &amp;&amp; flags &amp; MSG_VIEW_FLAG_ISTHREAD &amp;&amp; flags &amp; nsMsgMessageFlags::Elided) {</span>
<a href="#l8.813"></a><span id="l8.813">                     nsCOMPtr &lt;nsIMsgThread&gt; threadHdr;</span>
<a href="#l8.814"></a><span id="l8.814">                     GetThreadContainingIndex(curIndex, getter_AddRefs(threadHdr));</span>
<a href="#l8.815"></a><span id="l8.815">                     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l8.816"></a><span id="l8.816"> </span>
<a href="#l8.817"></a><span id="l8.817">                     NS_ASSERTION(threadHdr, &quot;threadHdr is null&quot;);</span>
<a href="#l8.818"></a><span id="l8.818">                     if (!threadHdr)</span>
<a href="#l8.819"></a><span id="l8.819">                         continue;</span>
<a href="#l8.820"></a><span id="l8.820">                     PRUint32 numUnreadChildren;</span>
<a href="#l8.821"></a><span id="l8.821" class="difflineat">@@ -5947,17 +5947,17 @@ nsresult nsMsgDBView::FindNextFlagged(ns</span>
<a href="#l8.822"></a><span id="l8.822"> </span>
<a href="#l8.823"></a><span id="l8.823">     *pResultIndex = nsMsgViewIndex_None;</span>
<a href="#l8.824"></a><span id="l8.824"> </span>
<a href="#l8.825"></a><span id="l8.825">     if (GetSize() &gt; 0)</span>
<a href="#l8.826"></a><span id="l8.826">     {</span>
<a href="#l8.827"></a><span id="l8.827">         for (curIndex = startIndex; curIndex &lt;= lastIndex; curIndex++)</span>
<a href="#l8.828"></a><span id="l8.828">         {</span>
<a href="#l8.829"></a><span id="l8.829">             PRUint32 flags = m_flags[curIndex];</span>
<a href="#l8.830"></a><span id="l8.830" class="difflineminus">-            if (flags &amp; MSG_FLAG_MARKED)</span>
<a href="#l8.831"></a><span id="l8.831" class="difflineplus">+            if (flags &amp; nsMsgMessageFlags::Marked)</span>
<a href="#l8.832"></a><span id="l8.832">             {</span>
<a href="#l8.833"></a><span id="l8.833">                 *pResultIndex = curIndex;</span>
<a href="#l8.834"></a><span id="l8.834">                 break;</span>
<a href="#l8.835"></a><span id="l8.835">             }</span>
<a href="#l8.836"></a><span id="l8.836">         }</span>
<a href="#l8.837"></a><span id="l8.837">     }</span>
<a href="#l8.838"></a><span id="l8.838"> </span>
<a href="#l8.839"></a><span id="l8.839">     return NS_OK;</span>
<a href="#l8.840"></a><span id="l8.840" class="difflineat">@@ -5988,25 +5988,25 @@ nsresult nsMsgDBView::FindPrevUnread(nsM</span>
<a href="#l8.841"></a><span id="l8.841">     *pResultKey = nsMsgKey_None;</span>
<a href="#l8.842"></a><span id="l8.842">     if (resultThreadId)</span>
<a href="#l8.843"></a><span id="l8.843">         *resultThreadId = nsMsgKey_None;</span>
<a href="#l8.844"></a><span id="l8.844"> </span>
<a href="#l8.845"></a><span id="l8.845">     for (; (int) curIndex &gt;= 0 &amp;&amp; (*pResultKey == nsMsgKey_None); curIndex--)</span>
<a href="#l8.846"></a><span id="l8.846">     {</span>
<a href="#l8.847"></a><span id="l8.847">         PRUint32 flags = m_flags[curIndex];</span>
<a href="#l8.848"></a><span id="l8.848"> </span>
<a href="#l8.849"></a><span id="l8.849" class="difflineminus">-        if (curIndex != startIndex &amp;&amp; flags &amp; MSG_VIEW_FLAG_ISTHREAD &amp;&amp; flags &amp; MSG_FLAG_ELIDED)</span>
<a href="#l8.850"></a><span id="l8.850" class="difflineplus">+        if (curIndex != startIndex &amp;&amp; flags &amp; MSG_VIEW_FLAG_ISTHREAD &amp;&amp; flags &amp; nsMsgMessageFlags::Elided)</span>
<a href="#l8.851"></a><span id="l8.851">         {</span>
<a href="#l8.852"></a><span id="l8.852">             NS_ASSERTION(0,&quot;fix this&quot;);</span>
<a href="#l8.853"></a><span id="l8.853">             //nsMsgKey threadId = m_keys[curIndex];</span>
<a href="#l8.854"></a><span id="l8.854">             //rv = m_db-&gt;GetUnreadKeyInThread(threadId, pResultKey, resultThreadId);</span>
<a href="#l8.855"></a><span id="l8.855">             if (NS_SUCCEEDED(rv) &amp;&amp; (*pResultKey != nsMsgKey_None))</span>
<a href="#l8.856"></a><span id="l8.856">                 break;</span>
<a href="#l8.857"></a><span id="l8.857">         }</span>
<a href="#l8.858"></a><span id="l8.858" class="difflineminus">-        if (!(flags &amp; (MSG_FLAG_READ | MSG_VIEW_FLAG_DUMMY)) &amp;&amp; (curIndex != startIndex))</span>
<a href="#l8.859"></a><span id="l8.859" class="difflineplus">+        if (!(flags &amp; (nsMsgMessageFlags::Read | MSG_VIEW_FLAG_DUMMY)) &amp;&amp; (curIndex != startIndex))</span>
<a href="#l8.860"></a><span id="l8.860">         {</span>
<a href="#l8.861"></a><span id="l8.861">             *pResultKey = m_keys[curIndex];</span>
<a href="#l8.862"></a><span id="l8.862">             rv = NS_OK;</span>
<a href="#l8.863"></a><span id="l8.863">             break;</span>
<a href="#l8.864"></a><span id="l8.864">         }</span>
<a href="#l8.865"></a><span id="l8.865">     }</span>
<a href="#l8.866"></a><span id="l8.866">     // found unread message but we don't know the thread</span>
<a href="#l8.867"></a><span id="l8.867">     NS_ASSERTION(!(*pResultKey != nsMsgKey_None &amp;&amp; resultThreadId &amp;&amp; *resultThreadId == nsMsgKey_None),</span>
<a href="#l8.868"></a><span id="l8.868" class="difflineat">@@ -6029,17 +6029,17 @@ nsresult nsMsgDBView::FindPrevFlagged(ns</span>
<a href="#l8.869"></a><span id="l8.869">     {</span>
<a href="#l8.870"></a><span id="l8.870">         curIndex = startIndex;</span>
<a href="#l8.871"></a><span id="l8.871">         do</span>
<a href="#l8.872"></a><span id="l8.872">         {</span>
<a href="#l8.873"></a><span id="l8.873">             if (curIndex != 0)</span>
<a href="#l8.874"></a><span id="l8.874">                 curIndex--;</span>
<a href="#l8.875"></a><span id="l8.875"> </span>
<a href="#l8.876"></a><span id="l8.876">             PRUint32 flags = m_flags[curIndex];</span>
<a href="#l8.877"></a><span id="l8.877" class="difflineminus">-            if (flags &amp; MSG_FLAG_MARKED)</span>
<a href="#l8.878"></a><span id="l8.878" class="difflineplus">+            if (flags &amp; nsMsgMessageFlags::Marked)</span>
<a href="#l8.879"></a><span id="l8.879">             {</span>
<a href="#l8.880"></a><span id="l8.880">                 *pResultIndex = curIndex;</span>
<a href="#l8.881"></a><span id="l8.881">                 break;</span>
<a href="#l8.882"></a><span id="l8.882">             }</span>
<a href="#l8.883"></a><span id="l8.883">         }</span>
<a href="#l8.884"></a><span id="l8.884">         while (curIndex != 0);</span>
<a href="#l8.885"></a><span id="l8.885">     }</span>
<a href="#l8.886"></a><span id="l8.886">     return NS_OK;</span>
<a href="#l8.887"></a><span id="l8.887" class="difflineat">@@ -6087,29 +6087,29 @@ nsresult nsMsgDBView::SetExtraFlag(nsMsg</span>
<a href="#l8.888"></a><span id="l8.888"> nsresult nsMsgDBView::ToggleIgnored(nsMsgViewIndex * indices, PRInt32 numIndices, nsMsgViewIndex *resultIndex, PRBool *resultToggleState)</span>
<a href="#l8.889"></a><span id="l8.889"> {</span>
<a href="#l8.890"></a><span id="l8.890">   nsCOMPtr &lt;nsIMsgThread&gt; thread;</span>
<a href="#l8.891"></a><span id="l8.891"> </span>
<a href="#l8.892"></a><span id="l8.892">   // Ignored state is toggled based on the first selected thread</span>
<a href="#l8.893"></a><span id="l8.893">   nsMsgViewIndex threadIndex = GetThreadFromMsgIndex(indices[0], getter_AddRefs(thread));</span>
<a href="#l8.894"></a><span id="l8.894">   PRUint32 threadFlags;</span>
<a href="#l8.895"></a><span id="l8.895">   thread-&gt;GetFlags(&amp;threadFlags);</span>
<a href="#l8.896"></a><span id="l8.896" class="difflineminus">-  PRUint32 ignored = threadFlags &amp; MSG_FLAG_IGNORED;</span>
<a href="#l8.897"></a><span id="l8.897" class="difflineplus">+  PRUint32 ignored = threadFlags &amp; nsMsgMessageFlags::Ignored;</span>
<a href="#l8.898"></a><span id="l8.898"> </span>
<a href="#l8.899"></a><span id="l8.899">   // Process threads in reverse order</span>
<a href="#l8.900"></a><span id="l8.900">   // Otherwise collapsing the threads will invalidate the indices</span>
<a href="#l8.901"></a><span id="l8.901">   threadIndex = nsMsgViewIndex_None;</span>
<a href="#l8.902"></a><span id="l8.902">   while (numIndices)</span>
<a href="#l8.903"></a><span id="l8.903">   {</span>
<a href="#l8.904"></a><span id="l8.904">     numIndices--;</span>
<a href="#l8.905"></a><span id="l8.905">     if (indices[numIndices] &lt; threadIndex)</span>
<a href="#l8.906"></a><span id="l8.906">     {</span>
<a href="#l8.907"></a><span id="l8.907">       threadIndex = GetThreadFromMsgIndex(indices[numIndices], getter_AddRefs(thread));</span>
<a href="#l8.908"></a><span id="l8.908">       thread-&gt;GetFlags(&amp;threadFlags);</span>
<a href="#l8.909"></a><span id="l8.909" class="difflineminus">-      if ((threadFlags &amp; MSG_FLAG_IGNORED) == ignored)</span>
<a href="#l8.910"></a><span id="l8.910" class="difflineplus">+      if ((threadFlags &amp; nsMsgMessageFlags::Ignored) == ignored)</span>
<a href="#l8.911"></a><span id="l8.911">         SetThreadIgnored(thread, threadIndex, !ignored);</span>
<a href="#l8.912"></a><span id="l8.912">     }</span>
<a href="#l8.913"></a><span id="l8.913">   }</span>
<a href="#l8.914"></a><span id="l8.914"> </span>
<a href="#l8.915"></a><span id="l8.915">   if (resultIndex)</span>
<a href="#l8.916"></a><span id="l8.916">     *resultIndex = threadIndex;</span>
<a href="#l8.917"></a><span id="l8.917">   if (resultToggleState)</span>
<a href="#l8.918"></a><span id="l8.918">     *resultToggleState = !ignored;</span>
<a href="#l8.919"></a><span id="l8.919" class="difflineat">@@ -6121,30 +6121,30 @@ nsresult nsMsgDBView::ToggleMessageKille</span>
<a href="#l8.920"></a><span id="l8.920"> {</span>
<a href="#l8.921"></a><span id="l8.921">   nsCOMPtr &lt;nsIMsgDBHdr&gt; header;</span>
<a href="#l8.922"></a><span id="l8.922">   nsresult rv;</span>
<a href="#l8.923"></a><span id="l8.923"> </span>
<a href="#l8.924"></a><span id="l8.924">   // Ignored state is toggled based on the first selected message</span>
<a href="#l8.925"></a><span id="l8.925">   rv = GetMsgHdrForViewIndex(indices[0], getter_AddRefs(header));</span>
<a href="#l8.926"></a><span id="l8.926">   PRUint32 msgFlags;</span>
<a href="#l8.927"></a><span id="l8.927">   header-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l8.928"></a><span id="l8.928" class="difflineminus">-  PRUint32 ignored = msgFlags &amp; MSG_FLAG_IGNORED;</span>
<a href="#l8.929"></a><span id="l8.929" class="difflineplus">+  PRUint32 ignored = msgFlags &amp; nsMsgMessageFlags::Ignored;</span>
<a href="#l8.930"></a><span id="l8.930"> </span>
<a href="#l8.931"></a><span id="l8.931">   // Process messages in reverse order</span>
<a href="#l8.932"></a><span id="l8.932">   // Otherwise the indices may be invalidated...</span>
<a href="#l8.933"></a><span id="l8.933">   nsMsgViewIndex msgIndex = nsMsgViewIndex_None;</span>
<a href="#l8.934"></a><span id="l8.934">   while (numIndices)</span>
<a href="#l8.935"></a><span id="l8.935">   {</span>
<a href="#l8.936"></a><span id="l8.936">     numIndices--;</span>
<a href="#l8.937"></a><span id="l8.937">     if (indices[numIndices] &lt; msgIndex)</span>
<a href="#l8.938"></a><span id="l8.938">     {</span>
<a href="#l8.939"></a><span id="l8.939">       msgIndex = indices[numIndices];</span>
<a href="#l8.940"></a><span id="l8.940">       rv = GetMsgHdrForViewIndex(msgIndex, getter_AddRefs(header));</span>
<a href="#l8.941"></a><span id="l8.941">       header-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l8.942"></a><span id="l8.942" class="difflineminus">-      if ((msgFlags &amp; MSG_FLAG_IGNORED) == ignored)</span>
<a href="#l8.943"></a><span id="l8.943" class="difflineplus">+      if ((msgFlags &amp; nsMsgMessageFlags::Ignored) == ignored)</span>
<a href="#l8.944"></a><span id="l8.944">         SetSubthreadKilled(header, msgIndex, !ignored);</span>
<a href="#l8.945"></a><span id="l8.945">     }</span>
<a href="#l8.946"></a><span id="l8.946">   }</span>
<a href="#l8.947"></a><span id="l8.947"> </span>
<a href="#l8.948"></a><span id="l8.948">   if (resultIndex)</span>
<a href="#l8.949"></a><span id="l8.949">     *resultIndex = msgIndex;</span>
<a href="#l8.950"></a><span id="l8.950">   if (resultToggleState)</span>
<a href="#l8.951"></a><span id="l8.951">     *resultToggleState = !ignored;</span>
<a href="#l8.952"></a><span id="l8.952" class="difflineat">@@ -6177,29 +6177,29 @@ nsMsgViewIndex  nsMsgDBView::GetThreadFr</span>
<a href="#l8.953"></a><span id="l8.953"> nsresult nsMsgDBView::ToggleWatched( nsMsgViewIndex* indices,  PRInt32 numIndices)</span>
<a href="#l8.954"></a><span id="l8.954"> {</span>
<a href="#l8.955"></a><span id="l8.955">   nsCOMPtr &lt;nsIMsgThread&gt; thread;</span>
<a href="#l8.956"></a><span id="l8.956"> </span>
<a href="#l8.957"></a><span id="l8.957">   // Watched state is toggled based on the first selected thread</span>
<a href="#l8.958"></a><span id="l8.958">   nsMsgViewIndex threadIndex = GetThreadFromMsgIndex(indices[0], getter_AddRefs(thread));</span>
<a href="#l8.959"></a><span id="l8.959">   PRUint32 threadFlags;</span>
<a href="#l8.960"></a><span id="l8.960">   thread-&gt;GetFlags(&amp;threadFlags);</span>
<a href="#l8.961"></a><span id="l8.961" class="difflineminus">-  PRUint32 watched = threadFlags &amp; MSG_FLAG_WATCHED;</span>
<a href="#l8.962"></a><span id="l8.962" class="difflineplus">+  PRUint32 watched = threadFlags &amp; nsMsgMessageFlags::Watched;</span>
<a href="#l8.963"></a><span id="l8.963"> </span>
<a href="#l8.964"></a><span id="l8.964">   // Process threads in reverse order</span>
<a href="#l8.965"></a><span id="l8.965">   // for consistency with ToggleIgnored</span>
<a href="#l8.966"></a><span id="l8.966">   threadIndex = nsMsgViewIndex_None;</span>
<a href="#l8.967"></a><span id="l8.967">   while (numIndices)</span>
<a href="#l8.968"></a><span id="l8.968">   {</span>
<a href="#l8.969"></a><span id="l8.969">     numIndices--;</span>
<a href="#l8.970"></a><span id="l8.970">     if (indices[numIndices] &lt; threadIndex)</span>
<a href="#l8.971"></a><span id="l8.971">     {</span>
<a href="#l8.972"></a><span id="l8.972">       threadIndex = GetThreadFromMsgIndex(indices[numIndices], getter_AddRefs(thread));</span>
<a href="#l8.973"></a><span id="l8.973">       thread-&gt;GetFlags(&amp;threadFlags);</span>
<a href="#l8.974"></a><span id="l8.974" class="difflineminus">-      if ((threadFlags &amp; MSG_FLAG_WATCHED) == watched)</span>
<a href="#l8.975"></a><span id="l8.975" class="difflineplus">+      if ((threadFlags &amp; nsMsgMessageFlags::Watched) == watched)</span>
<a href="#l8.976"></a><span id="l8.976">         SetThreadWatched(thread, threadIndex, !watched);</span>
<a href="#l8.977"></a><span id="l8.977">     }</span>
<a href="#l8.978"></a><span id="l8.978">   }</span>
<a href="#l8.979"></a><span id="l8.979"> </span>
<a href="#l8.980"></a><span id="l8.980">   return NS_OK;</span>
<a href="#l8.981"></a><span id="l8.981"> }</span>
<a href="#l8.982"></a><span id="l8.982"> </span>
<a href="#l8.983"></a><span id="l8.983"> nsresult nsMsgDBView::SetThreadIgnored(nsIMsgThread *thread, nsMsgViewIndex threadIndex, PRBool ignored)</span>
<a href="#l8.984"></a><span id="l8.984" class="difflineat">@@ -6477,17 +6477,17 @@ PRBool nsMsgDBView::OfflineMsgSelected(n</span>
<a href="#l8.985"></a><span id="l8.985"> {</span>
<a href="#l8.986"></a><span id="l8.986">   nsCOMPtr &lt;nsIMsgLocalMailFolder&gt; localFolder = do_QueryInterface(m_folder);</span>
<a href="#l8.987"></a><span id="l8.987">   if (localFolder)</span>
<a href="#l8.988"></a><span id="l8.988">     return PR_TRUE;</span>
<a href="#l8.989"></a><span id="l8.989"> </span>
<a href="#l8.990"></a><span id="l8.990">   for (nsMsgViewIndex index = 0; index &lt; (nsMsgViewIndex) numIndices; index++)</span>
<a href="#l8.991"></a><span id="l8.991">   {</span>
<a href="#l8.992"></a><span id="l8.992">     PRUint32 flags = m_flags[indices[index]];</span>
<a href="#l8.993"></a><span id="l8.993" class="difflineminus">-    if ((flags &amp; MSG_FLAG_OFFLINE))</span>
<a href="#l8.994"></a><span id="l8.994" class="difflineplus">+    if ((flags &amp; nsMsgMessageFlags::Offline))</span>
<a href="#l8.995"></a><span id="l8.995">       return PR_TRUE;</span>
<a href="#l8.996"></a><span id="l8.996">   }</span>
<a href="#l8.997"></a><span id="l8.997">   return PR_FALSE;</span>
<a href="#l8.998"></a><span id="l8.998"> }</span>
<a href="#l8.999"></a><span id="l8.999"> </span>
<a href="#l8.1000"></a><span id="l8.1000"> PRBool nsMsgDBView::NonDummyMsgSelected(nsMsgViewIndex * indices, PRInt32 numIndices)</span>
<a href="#l8.1001"></a><span id="l8.1001"> {</span>
<a href="#l8.1002"></a><span id="l8.1002">   for (nsMsgViewIndex index = 0; index &lt; (nsMsgViewIndex) numIndices; index++)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/base/src/nsMsgFolderCompactor.cpp</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgFolderCompactor.cpp</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -902,17 +902,17 @@ nsOfflineStoreCompactState::OnStopReques</span>
<a href="#l9.4"></a><span id="l9.4">     rv = BuildMessageURI(m_baseMessageUri.get(), m_keyArray[m_curIndex],</span>
<a href="#l9.5"></a><span id="l9.5">                                 m_messageUri);</span>
<a href="#l9.6"></a><span id="l9.6">     if (NS_FAILED(rv)) goto done;</span>
<a href="#l9.7"></a><span id="l9.7">     rv = m_messageService-&gt;CopyMessage(m_messageUri.get(), this, PR_FALSE, nsnull,</span>
<a href="#l9.8"></a><span id="l9.8">                                        /* ### should get msg window! */ nsnull, nsnull);</span>
<a href="#l9.9"></a><span id="l9.9">    if (NS_FAILED(rv))</span>
<a href="#l9.10"></a><span id="l9.10">    {</span>
<a href="#l9.11"></a><span id="l9.11">      PRUint32 resultFlags;</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-     msgHdr-&gt;AndFlags(~MSG_FLAG_OFFLINE, &amp;resultFlags);</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+     msgHdr-&gt;AndFlags(~nsMsgMessageFlags::Offline, &amp;resultFlags);</span>
<a href="#l9.14"></a><span id="l9.14">    }</span>
<a href="#l9.15"></a><span id="l9.15">   // if this fails, we should clear the offline flag on the source message.</span>
<a href="#l9.16"></a><span id="l9.16">     </span>
<a href="#l9.17"></a><span id="l9.17">   }</span>
<a href="#l9.18"></a><span id="l9.18"> </span>
<a href="#l9.19"></a><span id="l9.19"> done:</span>
<a href="#l9.20"></a><span id="l9.20">   if (NS_FAILED(rv)) {</span>
<a href="#l9.21"></a><span id="l9.21">     m_status = rv; // set the status to rv so the destructor can remove the</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/base/src/nsMsgGroupThread.cpp</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgGroupThread.cpp</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -181,27 +181,27 @@ nsresult nsMsgGroupThread::AddChildFromG</span>
<a href="#l10.4"></a><span id="l10.4">   nsMsgKey newHdrKey = 0;</span>
<a href="#l10.5"></a><span id="l10.5">   </span>
<a href="#l10.6"></a><span id="l10.6">   child-&gt;GetFlags(&amp;newHdrFlags);</span>
<a href="#l10.7"></a><span id="l10.7">   child-&gt;GetMessageKey(&amp;newHdrKey);</span>
<a href="#l10.8"></a><span id="l10.8">   child-&gt;GetDateInSeconds(&amp;msgDate);</span>
<a href="#l10.9"></a><span id="l10.9">   if (msgDate &gt; m_newestMsgDate)</span>
<a href="#l10.10"></a><span id="l10.10">     SetNewestMsgDate(msgDate);</span>
<a href="#l10.11"></a><span id="l10.11"> </span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-  child-&gt;AndFlags(~(MSG_FLAG_WATCHED), &amp;newHdrFlags);</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+  child-&gt;AndFlags(~(nsMsgMessageFlags::Watched), &amp;newHdrFlags);</span>
<a href="#l10.14"></a><span id="l10.14">   PRUint32 numChildren;</span>
<a href="#l10.15"></a><span id="l10.15">   </span>
<a href="#l10.16"></a><span id="l10.16">   // get the num children before we add the new header.</span>
<a href="#l10.17"></a><span id="l10.17">   GetNumChildren(&amp;numChildren);</span>
<a href="#l10.18"></a><span id="l10.18">   </span>
<a href="#l10.19"></a><span id="l10.19">   // if this is an empty thread, set the root key to this header's key</span>
<a href="#l10.20"></a><span id="l10.20">   if (numChildren == 0)</span>
<a href="#l10.21"></a><span id="l10.21">     m_threadRootKey = newHdrKey;</span>
<a href="#l10.22"></a><span id="l10.22">   </span>
<a href="#l10.23"></a><span id="l10.23" class="difflineminus">-  if (! (newHdrFlags &amp; MSG_FLAG_READ))</span>
<a href="#l10.24"></a><span id="l10.24" class="difflineplus">+  if (! (newHdrFlags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l10.25"></a><span id="l10.25">     ChangeUnreadChildCount(1);</span>
<a href="#l10.26"></a><span id="l10.26"> </span>
<a href="#l10.27"></a><span id="l10.27">   return AddMsgHdrInDateOrder(child, view);</span>
<a href="#l10.28"></a><span id="l10.28"> }</span>
<a href="#l10.29"></a><span id="l10.29"> </span>
<a href="#l10.30"></a><span id="l10.30"> nsresult nsMsgGroupThread::ReparentNonReferenceChildrenOf(nsIMsgDBHdr *topLevelHdr, nsMsgKey newParentKey,</span>
<a href="#l10.31"></a><span id="l10.31">                                                             nsIDBChangeAnnouncer *announcer)</span>
<a href="#l10.32"></a><span id="l10.32"> {</span>
<a href="#l10.33"></a><span id="l10.33" class="difflineat">@@ -267,17 +267,17 @@ NS_IMETHODIMP nsMsgGroupThread::RemoveCh</span>
<a href="#l10.34"></a><span id="l10.34"> //  ReparentChildrenOf(key, threadParent, announcer);</span>
<a href="#l10.35"></a><span id="l10.35">   </span>
<a href="#l10.36"></a><span id="l10.36">   // if this was the newest msg, clear the newest msg date so we'll recalc.</span>
<a href="#l10.37"></a><span id="l10.37">   PRUint32 date;</span>
<a href="#l10.38"></a><span id="l10.38">   child-&gt;GetDateInSeconds(&amp;date);</span>
<a href="#l10.39"></a><span id="l10.39">   if (date == m_newestMsgDate)</span>
<a href="#l10.40"></a><span id="l10.40">     SetNewestMsgDate(0);</span>
<a href="#l10.41"></a><span id="l10.41"> </span>
<a href="#l10.42"></a><span id="l10.42" class="difflineminus">-  if (!(flags &amp; MSG_FLAG_READ))</span>
<a href="#l10.43"></a><span id="l10.43" class="difflineplus">+  if (!(flags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l10.44"></a><span id="l10.44">     ChangeUnreadChildCount(-1);</span>
<a href="#l10.45"></a><span id="l10.45">   PRBool keyWasFirstKey = (m_keys[0] == key);</span>
<a href="#l10.46"></a><span id="l10.46">   nsresult rv = RemoveChild(key);</span>
<a href="#l10.47"></a><span id="l10.47">  // if we're deleting the root of a dummy thread, need to update the threadKey</span>
<a href="#l10.48"></a><span id="l10.48">  // and the dummy header at position 0</span>
<a href="#l10.49"></a><span id="l10.49">  if (m_dummy &amp;&amp; keyWasFirstKey &amp;&amp; m_keys.Length() &gt; 1)</span>
<a href="#l10.50"></a><span id="l10.50">     m_keys[0] = m_keys[1];</span>
<a href="#l10.51"></a><span id="l10.51"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/base/src/nsMsgGroupView.cpp</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgGroupView.cpp</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -94,17 +94,17 @@ void nsMsgGroupView::InternalClose()</span>
<a href="#l11.4"></a><span id="l11.4">     m_db-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l11.5"></a><span id="l11.5">     if (dbFolderInfo)</span>
<a href="#l11.6"></a><span id="l11.6">     {</span>
<a href="#l11.7"></a><span id="l11.7">       PRUint32 expandFlags = 0;</span>
<a href="#l11.8"></a><span id="l11.8">       PRUint32 num = GetSize();</span>
<a href="#l11.9"></a><span id="l11.9"> </span>
<a href="#l11.10"></a><span id="l11.10">       for (PRUint32 i = 0; i &lt; num; i++)</span>
<a href="#l11.11"></a><span id="l11.11">       {</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-        if (m_flags[i] &amp; MSG_VIEW_FLAG_ISTHREAD &amp;&amp; ! (m_flags[i] &amp; MSG_FLAG_ELIDED))</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+        if (m_flags[i] &amp; MSG_VIEW_FLAG_ISTHREAD &amp;&amp; ! (m_flags[i] &amp; nsMsgMessageFlags::Elided))</span>
<a href="#l11.14"></a><span id="l11.14">         {</span>
<a href="#l11.15"></a><span id="l11.15">           nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l11.16"></a><span id="l11.16">           GetMsgHdrForViewIndex(i, getter_AddRefs(msgHdr));</span>
<a href="#l11.17"></a><span id="l11.17">           if (msgHdr)</span>
<a href="#l11.18"></a><span id="l11.18">           {</span>
<a href="#l11.19"></a><span id="l11.19">             PRUint32 ageBucket;</span>
<a href="#l11.20"></a><span id="l11.20">             nsresult rv = GetAgeBucketValue(msgHdr, &amp;ageBucket, rcvDate);</span>
<a href="#l11.21"></a><span id="l11.21">             if (NS_SUCCEEDED(rv))</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineat">@@ -247,24 +247,24 @@ nsresult nsMsgGroupView::HashHdr(nsIMsgD</span>
<a href="#l11.23"></a><span id="l11.23">           ? FetchAccount(msgHdr, aHashKey)</span>
<a href="#l11.24"></a><span id="l11.24">           : FetchTags(msgHdr, aHashKey);</span>
<a href="#l11.25"></a><span id="l11.25">       }</span>
<a href="#l11.26"></a><span id="l11.26">       break;</span>
<a href="#l11.27"></a><span id="l11.27">     case nsMsgViewSortType::byAttachments:</span>
<a href="#l11.28"></a><span id="l11.28">       {</span>
<a href="#l11.29"></a><span id="l11.29">         PRUint32 flags;</span>
<a href="#l11.30"></a><span id="l11.30">         msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l11.31"></a><span id="l11.31" class="difflineminus">-        aHashKey.Assign(flags &amp; MSG_FLAG_ATTACHMENT ? '1' : '0');</span>
<a href="#l11.32"></a><span id="l11.32" class="difflineplus">+        aHashKey.Assign(flags &amp; nsMsgMessageFlags::Attachment ? '1' : '0');</span>
<a href="#l11.33"></a><span id="l11.33">         break;</span>
<a href="#l11.34"></a><span id="l11.34">       }</span>
<a href="#l11.35"></a><span id="l11.35">     case nsMsgViewSortType::byFlagged:</span>
<a href="#l11.36"></a><span id="l11.36">       {</span>
<a href="#l11.37"></a><span id="l11.37">         PRUint32 flags;</span>
<a href="#l11.38"></a><span id="l11.38">         msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l11.39"></a><span id="l11.39" class="difflineminus">-        aHashKey.Assign(flags &amp; MSG_FLAG_MARKED ? '1' : '0');</span>
<a href="#l11.40"></a><span id="l11.40" class="difflineplus">+        aHashKey.Assign(flags &amp; nsMsgMessageFlags::Marked ? '1' : '0');</span>
<a href="#l11.41"></a><span id="l11.41">         break;</span>
<a href="#l11.42"></a><span id="l11.42">       }</span>
<a href="#l11.43"></a><span id="l11.43">     case nsMsgViewSortType::byPriority:</span>
<a href="#l11.44"></a><span id="l11.44">       {</span>
<a href="#l11.45"></a><span id="l11.45">         nsMsgPriorityValue priority;</span>
<a href="#l11.46"></a><span id="l11.46">         msgHdr-&gt;GetPriority(&amp;priority);</span>
<a href="#l11.47"></a><span id="l11.47">         aHashKey.AppendInt(priority);</span>
<a href="#l11.48"></a><span id="l11.48">       }</span>
<a href="#l11.49"></a><span id="l11.49" class="difflineat">@@ -328,17 +328,17 @@ nsMsgGroupThread *nsMsgGroupView::AddHdr</span>
<a href="#l11.50"></a><span id="l11.50">       foundThread-&gt;m_dummy = PR_TRUE;</span>
<a href="#l11.51"></a><span id="l11.51">       msgFlags |=  MSG_VIEW_FLAG_DUMMY | MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l11.52"></a><span id="l11.52">     }</span>
<a href="#l11.53"></a><span id="l11.53"> </span>
<a href="#l11.54"></a><span id="l11.54">     nsMsgViewIndex insertIndex = GetInsertIndex(msgHdr);</span>
<a href="#l11.55"></a><span id="l11.55">     if (insertIndex == nsMsgViewIndex_None)</span>
<a href="#l11.56"></a><span id="l11.56">       insertIndex = m_keys.Length();</span>
<a href="#l11.57"></a><span id="l11.57">     InsertMsgHdrAt(insertIndex, msgHdr, msgKey, </span>
<a href="#l11.58"></a><span id="l11.58" class="difflineminus">-                  msgFlags | MSG_VIEW_FLAG_ISTHREAD | MSG_FLAG_ELIDED, 0);</span>
<a href="#l11.59"></a><span id="l11.59" class="difflineplus">+                  msgFlags | MSG_VIEW_FLAG_ISTHREAD | nsMsgMessageFlags::Elided, 0);</span>
<a href="#l11.60"></a><span id="l11.60">     // if grouped by date, insert dummy header for &quot;age&quot;</span>
<a href="#l11.61"></a><span id="l11.61">     if (GroupViewUsesDummyRow())</span>
<a href="#l11.62"></a><span id="l11.62">     {</span>
<a href="#l11.63"></a><span id="l11.63">       // this needs to do something different for xf groups</span>
<a href="#l11.64"></a><span id="l11.64">       foundThread-&gt;InsertMsgHdrAt(0, msgHdr);</span>
<a href="#l11.65"></a><span id="l11.65">       // the previous code made it look like hashKey in this case was always an integer</span>
<a href="#l11.66"></a><span id="l11.66">       foundThread-&gt;m_threadKey = atoi(NS_LossyConvertUTF16toASCII(hashKey).get());</span>
<a href="#l11.67"></a><span id="l11.67">     }</span>
<a href="#l11.68"></a><span id="l11.68" class="difflineat">@@ -525,22 +525,22 @@ nsresult nsMsgGroupView::OnNewHeader(nsI</span>
<a href="#l11.69"></a><span id="l11.69">     nsMsgViewIndex threadIndex = ThreadIndexOfMsgHdr(newHdr);</span>
<a href="#l11.70"></a><span id="l11.70">     PRInt32 numRowsInserted = 1;</span>
<a href="#l11.71"></a><span id="l11.71">     if (newThread &amp;&amp; GroupViewUsesDummyRow())</span>
<a href="#l11.72"></a><span id="l11.72">       numRowsInserted++;</span>
<a href="#l11.73"></a><span id="l11.73">     // may need to fix thread counts</span>
<a href="#l11.74"></a><span id="l11.74">     if (threadIndex != nsMsgViewIndex_None)</span>
<a href="#l11.75"></a><span id="l11.75">     {</span>
<a href="#l11.76"></a><span id="l11.76">       if (newThread)</span>
<a href="#l11.77"></a><span id="l11.77" class="difflineminus">-        m_flags[threadIndex] &amp;= ~MSG_FLAG_ELIDED;</span>
<a href="#l11.78"></a><span id="l11.78" class="difflineplus">+        m_flags[threadIndex] &amp;= ~nsMsgMessageFlags::Elided;</span>
<a href="#l11.79"></a><span id="l11.79">       else</span>
<a href="#l11.80"></a><span id="l11.80">         m_flags[threadIndex] |= MSG_VIEW_FLAG_HASCHILDREN | MSG_VIEW_FLAG_ISTHREAD;</span>
<a href="#l11.81"></a><span id="l11.81"> </span>
<a href="#l11.82"></a><span id="l11.82">       PRInt32 numRowsToInvalidate = 1;</span>
<a href="#l11.83"></a><span id="l11.83" class="difflineminus">-      if (! (m_flags[threadIndex] &amp; MSG_FLAG_ELIDED))</span>
<a href="#l11.84"></a><span id="l11.84" class="difflineplus">+      if (! (m_flags[threadIndex] &amp; nsMsgMessageFlags::Elided))</span>
<a href="#l11.85"></a><span id="l11.85">       {</span>
<a href="#l11.86"></a><span id="l11.86">         PRUint32 msgIndexInThread = thread-&gt;m_keys.IndexOf(msgKey);</span>
<a href="#l11.87"></a><span id="l11.87">         PRBool insertedAtThreadRoot = !msgIndexInThread;</span>
<a href="#l11.88"></a><span id="l11.88">         if (!msgIndexInThread &amp;&amp; GroupViewUsesDummyRow())</span>
<a href="#l11.89"></a><span id="l11.89">           msgIndexInThread++;</span>
<a href="#l11.90"></a><span id="l11.90"> </span>
<a href="#l11.91"></a><span id="l11.91">         if (!newThread || GroupViewUsesDummyRow())</span>
<a href="#l11.92"></a><span id="l11.92">         {</span>
<a href="#l11.93"></a><span id="l11.93" class="difflineat">@@ -591,18 +591,18 @@ NS_IMETHODIMP nsMsgGroupView::OnHdrFlags</span>
<a href="#l11.94"></a><span id="l11.94">   // check if we're adding a header, and the current day has changed. If it has, we're just going to</span>
<a href="#l11.95"></a><span id="l11.95">   // close and re-open the view so things will be correctly categorized.</span>
<a href="#l11.96"></a><span id="l11.96">   if (m_dayChanged)</span>
<a href="#l11.97"></a><span id="l11.97">     return RebuildView(m_viewFlags);</span>
<a href="#l11.98"></a><span id="l11.98"> </span>
<a href="#l11.99"></a><span id="l11.99">   nsresult rv = GetThreadContainingMsgHdr(aHdrChanged, getter_AddRefs(thread));</span>
<a href="#l11.100"></a><span id="l11.100">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l11.101"></a><span id="l11.101">   PRUint32 deltaFlags = (aOldFlags ^ aNewFlags);</span>
<a href="#l11.102"></a><span id="l11.102" class="difflineminus">-  if (deltaFlags &amp; MSG_FLAG_READ)</span>
<a href="#l11.103"></a><span id="l11.103" class="difflineminus">-    thread-&gt;MarkChildRead(aNewFlags &amp; MSG_FLAG_READ);</span>
<a href="#l11.104"></a><span id="l11.104" class="difflineplus">+  if (deltaFlags &amp; nsMsgMessageFlags::Read)</span>
<a href="#l11.105"></a><span id="l11.105" class="difflineplus">+    thread-&gt;MarkChildRead(aNewFlags &amp; nsMsgMessageFlags::Read);</span>
<a href="#l11.106"></a><span id="l11.106"> </span>
<a href="#l11.107"></a><span id="l11.107">   return nsMsgDBView::OnHdrFlagsChanged(aHdrChanged, aOldFlags, aNewFlags, aInstigator);</span>
<a href="#l11.108"></a><span id="l11.108"> }</span>
<a href="#l11.109"></a><span id="l11.109"> </span>
<a href="#l11.110"></a><span id="l11.110"> NS_IMETHODIMP nsMsgGroupView::OnHdrDeleted(nsIMsgDBHdr *aHdrDeleted, nsMsgKey aParentKey, PRInt32 aFlags,</span>
<a href="#l11.111"></a><span id="l11.111">                             nsIDBChangeListener *aInstigator)</span>
<a href="#l11.112"></a><span id="l11.112"> {</span>
<a href="#l11.113"></a><span id="l11.113">   if (!(m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort))</span>
<a href="#l11.114"></a><span id="l11.114" class="difflineat">@@ -762,22 +762,22 @@ NS_IMETHODIMP nsMsgGroupView::GetCellTex</span>
<a href="#l11.115"></a><span id="l11.115">           break;</span>
<a href="#l11.116"></a><span id="l11.116">         case nsMsgViewSortType::byAccount:</span>
<a href="#l11.117"></a><span id="l11.117">           FetchAccount(msgHdr, aValue);</span>
<a href="#l11.118"></a><span id="l11.118">           break;</span>
<a href="#l11.119"></a><span id="l11.119">         case nsMsgViewSortType::byRecipient:</span>
<a href="#l11.120"></a><span id="l11.120">           FetchRecipients(msgHdr, aValue);</span>
<a href="#l11.121"></a><span id="l11.121">           break;</span>
<a href="#l11.122"></a><span id="l11.122">         case nsMsgViewSortType::byAttachments:</span>
<a href="#l11.123"></a><span id="l11.123" class="difflineminus">-          aValue.Adopt(GetString(flags &amp; MSG_FLAG_ATTACHMENT</span>
<a href="#l11.124"></a><span id="l11.124" class="difflineplus">+          aValue.Adopt(GetString(flags &amp; nsMsgMessageFlags::Attachment</span>
<a href="#l11.125"></a><span id="l11.125">             ? NS_LITERAL_STRING(&quot;attachments&quot;).get()</span>
<a href="#l11.126"></a><span id="l11.126">             : NS_LITERAL_STRING(&quot;noAttachments&quot;).get()));</span>
<a href="#l11.127"></a><span id="l11.127">           break;</span>
<a href="#l11.128"></a><span id="l11.128">         case nsMsgViewSortType::byFlagged:</span>
<a href="#l11.129"></a><span id="l11.129" class="difflineminus">-          aValue.Adopt(GetString(flags &amp; MSG_FLAG_MARKED </span>
<a href="#l11.130"></a><span id="l11.130" class="difflineplus">+          aValue.Adopt(GetString(flags &amp; nsMsgMessageFlags::Marked </span>
<a href="#l11.131"></a><span id="l11.131">             ? NS_LITERAL_STRING(&quot;groupFlagged&quot;).get()</span>
<a href="#l11.132"></a><span id="l11.132">             : NS_LITERAL_STRING(&quot;notFlagged&quot;).get()));</span>
<a href="#l11.133"></a><span id="l11.133">           break;</span>
<a href="#l11.134"></a><span id="l11.134"> </span>
<a href="#l11.135"></a><span id="l11.135">         default:</span>
<a href="#l11.136"></a><span id="l11.136">           NS_ASSERTION(PR_FALSE, &quot;we don't sort by group for this type&quot;);</span>
<a href="#l11.137"></a><span id="l11.137">           break;</span>
<a href="#l11.138"></a><span id="l11.138">       }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/mailnews/base/src/nsMsgQuickSearchDBView.cpp</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgQuickSearchDBView.cpp</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -163,17 +163,17 @@ nsresult nsMsgQuickSearchDBView::OnNewHe</span>
<a href="#l12.4"></a><span id="l12.4">   return NS_OK;</span>
<a href="#l12.5"></a><span id="l12.5"> }</span>
<a href="#l12.6"></a><span id="l12.6"> </span>
<a href="#l12.7"></a><span id="l12.7"> NS_IMETHODIMP nsMsgQuickSearchDBView::OnHdrFlagsChanged(nsIMsgDBHdr *aHdrChanged, PRUint32 aOldFlags, </span>
<a href="#l12.8"></a><span id="l12.8">                                        PRUint32 aNewFlags, nsIDBChangeListener *aInstigator)</span>
<a href="#l12.9"></a><span id="l12.9"> {</span>
<a href="#l12.10"></a><span id="l12.10">   nsresult rv = nsMsgGroupView::OnHdrFlagsChanged(aHdrChanged, aOldFlags, aNewFlags, aInstigator);</span>
<a href="#l12.11"></a><span id="l12.11"> </span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-  if (m_viewFolder &amp;&amp; (aOldFlags &amp; MSG_FLAG_READ) != (aNewFlags &amp; MSG_FLAG_READ))</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineplus">+  if (m_viewFolder &amp;&amp; (aOldFlags &amp; nsMsgMessageFlags::Read) != (aNewFlags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l12.14"></a><span id="l12.14">   {</span>
<a href="#l12.15"></a><span id="l12.15">     // if we're displaying a single folder virtual folder for an imap folder,</span>
<a href="#l12.16"></a><span id="l12.16">     // the search criteria might be on message body, and we might not have the</span>
<a href="#l12.17"></a><span id="l12.17">     // message body offline, in which case we can't tell if the message </span>
<a href="#l12.18"></a><span id="l12.18">     // matched or not. But if the unread flag changed, we need to update the</span>
<a href="#l12.19"></a><span id="l12.19">     // unread counts. Normally, VirtualFolderChangeListener::OnHdrFlagsChanged will</span>
<a href="#l12.20"></a><span id="l12.20">     // handle this, but it won't work for body criteria when we don't have the</span>
<a href="#l12.21"></a><span id="l12.21">     // body offline.</span>
<a href="#l12.22"></a><span id="l12.22" class="difflineat">@@ -195,17 +195,17 @@ NS_IMETHODIMP nsMsgQuickSearchDBView::On</span>
<a href="#l12.23"></a><span id="l12.23">           // won't tweak the read/unread counts. So do it here:</span>
<a href="#l12.24"></a><span id="l12.24">           if (!oldMatch &amp;&amp; !newMatch)</span>
<a href="#l12.25"></a><span id="l12.25">           {</span>
<a href="#l12.26"></a><span id="l12.26">             nsCOMPtr &lt;nsIMsgDatabase&gt; virtDatabase;</span>
<a href="#l12.27"></a><span id="l12.27">             nsCOMPtr &lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l12.28"></a><span id="l12.28"> </span>
<a href="#l12.29"></a><span id="l12.29">             rv = m_viewFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(dbFolderInfo), getter_AddRefs(virtDatabase));</span>
<a href="#l12.30"></a><span id="l12.30">             NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l12.31"></a><span id="l12.31" class="difflineminus">-            dbFolderInfo-&gt;ChangeNumUnreadMessages((aOldFlags &amp; MSG_FLAG_READ) ? 1 : -1);</span>
<a href="#l12.32"></a><span id="l12.32" class="difflineplus">+            dbFolderInfo-&gt;ChangeNumUnreadMessages((aOldFlags &amp; nsMsgMessageFlags::Read) ? 1 : -1);</span>
<a href="#l12.33"></a><span id="l12.33">             m_viewFolder-&gt;UpdateSummaryTotals(PR_TRUE); // force update from db.</span>
<a href="#l12.34"></a><span id="l12.34">             virtDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l12.35"></a><span id="l12.35">           }</span>
<a href="#l12.36"></a><span id="l12.36">         }</span>
<a href="#l12.37"></a><span id="l12.37">       }</span>
<a href="#l12.38"></a><span id="l12.38">     }</span>
<a href="#l12.39"></a><span id="l12.39">   }</span>
<a href="#l12.40"></a><span id="l12.40">   return rv;</span>
<a href="#l12.41"></a><span id="l12.41" class="difflineat">@@ -592,17 +592,17 @@ nsresult nsMsgQuickSearchDBView::Expansi</span>
<a href="#l12.42"></a><span id="l12.42">   if (!(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l12.43"></a><span id="l12.43">     return NS_OK;</span>
<a href="#l12.44"></a><span id="l12.44"> </span>
<a href="#l12.45"></a><span id="l12.45">   // The client can pass in the key of any message</span>
<a href="#l12.46"></a><span id="l12.46">   // in a thread and get the expansion delta for the thread.</span>
<a href="#l12.47"></a><span id="l12.47"> </span>
<a href="#l12.48"></a><span id="l12.48">   PRInt32 numChildren = CountExpandedThread(index);</span>
<a href="#l12.49"></a><span id="l12.49"> </span>
<a href="#l12.50"></a><span id="l12.50" class="difflineminus">-  *expansionDelta = (flags &amp; MSG_FLAG_ELIDED) ? </span>
<a href="#l12.51"></a><span id="l12.51" class="difflineplus">+  *expansionDelta = (flags &amp; nsMsgMessageFlags::Elided) ?</span>
<a href="#l12.52"></a><span id="l12.52">                     numChildren - 1 : - (PRInt32) (numChildren - 1);</span>
<a href="#l12.53"></a><span id="l12.53">   return NS_OK;</span>
<a href="#l12.54"></a><span id="l12.54"> }</span>
<a href="#l12.55"></a><span id="l12.55"> </span>
<a href="#l12.56"></a><span id="l12.56"> NS_IMETHODIMP </span>
<a href="#l12.57"></a><span id="l12.57"> nsMsgQuickSearchDBView::OpenWithHdrs(nsISimpleEnumerator *aHeaders, </span>
<a href="#l12.58"></a><span id="l12.58">                                      nsMsgViewSortTypeValue aSortType,</span>
<a href="#l12.59"></a><span id="l12.59">                                      nsMsgViewSortOrderValue aSortOrder, </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/mailnews/base/src/nsMsgSearchDBView.cpp</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgSearchDBView.cpp</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -221,34 +221,34 @@ nsMsgSearchDBView::OnHdrDeleted(nsIMsgDB</span>
<a href="#l13.4"></a><span id="l13.4">         // and remove the thread flags on it.</span>
<a href="#l13.5"></a><span id="l13.5">         nsCOMPtr&lt;nsIMsgDBHdr&gt; rootHdr;</span>
<a href="#l13.6"></a><span id="l13.6">         thread-&gt;GetRootHdr(nsnull, getter_AddRefs(rootHdr));</span>
<a href="#l13.7"></a><span id="l13.7">         if (rootHdr)</span>
<a href="#l13.8"></a><span id="l13.8">         {</span>
<a href="#l13.9"></a><span id="l13.9">           nsMsgViewIndex threadIndex = GetThreadRootIndex(rootHdr);</span>
<a href="#l13.10"></a><span id="l13.10">           if (threadIndex != nsMsgViewIndex_None)</span>
<a href="#l13.11"></a><span id="l13.11">             AndExtraFlag(threadIndex, ~(MSG_VIEW_FLAG_ISTHREAD | </span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">-                                        MSG_FLAG_ELIDED | </span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+                                        nsMsgMessageFlags::Elided | </span>
<a href="#l13.14"></a><span id="l13.14">                                         MSG_VIEW_FLAG_HASCHILDREN));</span>
<a href="#l13.15"></a><span id="l13.15">         }</span>
<a href="#l13.16"></a><span id="l13.16">       }</span>
<a href="#l13.17"></a><span id="l13.17">       else if (savedFlags &amp; MSG_VIEW_FLAG_HASCHILDREN)</span>
<a href="#l13.18"></a><span id="l13.18"> {</span>
<a href="#l13.19"></a><span id="l13.19" class="difflineminus">-        if (savedFlags &amp; MSG_FLAG_ELIDED)</span>
<a href="#l13.20"></a><span id="l13.20" class="difflineplus">+        if (savedFlags &amp; nsMsgMessageFlags::Elided)</span>
<a href="#l13.21"></a><span id="l13.21">         {</span>
<a href="#l13.22"></a><span id="l13.22">           nsCOMPtr&lt;nsIMsgDBHdr&gt; rootHdr;</span>
<a href="#l13.23"></a><span id="l13.23">           nsresult rv = thread-&gt;GetRootHdr(nsnull, getter_AddRefs(rootHdr));</span>
<a href="#l13.24"></a><span id="l13.24">           NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l13.25"></a><span id="l13.25">           nsMsgKey msgKey;</span>
<a href="#l13.26"></a><span id="l13.26">           PRUint32 msgFlags;</span>
<a href="#l13.27"></a><span id="l13.27">           rootHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l13.28"></a><span id="l13.28">           rootHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l13.29"></a><span id="l13.29">           // promote the new thread root</span>
<a href="#l13.30"></a><span id="l13.30">           if (viewThread-&gt;MsgCount() &gt; 1)</span>
<a href="#l13.31"></a><span id="l13.31" class="difflineminus">-            msgFlags |= MSG_VIEW_FLAG_ISTHREAD | MSG_FLAG_ELIDED | </span>
<a href="#l13.32"></a><span id="l13.32" class="difflineplus">+            msgFlags |= MSG_VIEW_FLAG_ISTHREAD | nsMsgMessageFlags::Elided | </span>
<a href="#l13.33"></a><span id="l13.33">                         MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l13.34"></a><span id="l13.34">           InsertMsgHdrAt(deletedIndex, rootHdr, msgKey, msgFlags, 0);</span>
<a href="#l13.35"></a><span id="l13.35">           NoteChange(deletedIndex, 1, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l13.36"></a><span id="l13.36">         }</span>
<a href="#l13.37"></a><span id="l13.37">         else if (viewThread-&gt;MsgCount() &gt; 1)</span>
<a href="#l13.38"></a><span id="l13.38">         {</span>
<a href="#l13.39"></a><span id="l13.39">           OrExtraFlag(deletedIndex, MSG_VIEW_FLAG_ISTHREAD |</span>
<a href="#l13.40"></a><span id="l13.40">                                     MSG_VIEW_FLAG_HASCHILDREN);</span>
<a href="#l13.41"></a><span id="l13.41" class="difflineat">@@ -281,18 +281,18 @@ NS_IMETHODIMP nsMsgSearchDBView::OnHdrFl</span>
<a href="#l13.42"></a><span id="l13.42">   // check that the header is actually in the thread.</span>
<a href="#l13.43"></a><span id="l13.43">   GetXFThreadFromMsgHdr(aHdrChanged, getter_AddRefs(thread), &amp;foundMessageId);</span>
<a href="#l13.44"></a><span id="l13.44">   if (foundMessageId)</span>
<a href="#l13.45"></a><span id="l13.45">   {</span>
<a href="#l13.46"></a><span id="l13.46">     nsMsgXFViewThread *viewThread = static_cast&lt;nsMsgXFViewThread*&gt;(thread.get());</span>
<a href="#l13.47"></a><span id="l13.47">     if (viewThread-&gt;HdrIndex(aHdrChanged) != -1)</span>
<a href="#l13.48"></a><span id="l13.48">     {</span>
<a href="#l13.49"></a><span id="l13.49">       PRUint32 deltaFlags = (aOldFlags ^ aNewFlags);</span>
<a href="#l13.50"></a><span id="l13.50" class="difflineminus">-      if (deltaFlags &amp; MSG_FLAG_READ)</span>
<a href="#l13.51"></a><span id="l13.51" class="difflineminus">-        thread-&gt;MarkChildRead(aNewFlags &amp; MSG_FLAG_READ);</span>
<a href="#l13.52"></a><span id="l13.52" class="difflineplus">+      if (deltaFlags &amp; nsMsgMessageFlags::Read)</span>
<a href="#l13.53"></a><span id="l13.53" class="difflineplus">+        thread-&gt;MarkChildRead(aNewFlags &amp; nsMsgMessageFlags::Read);</span>
<a href="#l13.54"></a><span id="l13.54">     }</span>
<a href="#l13.55"></a><span id="l13.55">   }</span>
<a href="#l13.56"></a><span id="l13.56">   return nsMsgDBView::OnHdrFlagsChanged(aHdrChanged, aOldFlags,</span>
<a href="#l13.57"></a><span id="l13.57">                                         aNewFlags, aInstigator);</span>
<a href="#l13.58"></a><span id="l13.58"> }</span>
<a href="#l13.59"></a><span id="l13.59"> </span>
<a href="#l13.60"></a><span id="l13.60"> void nsMsgSearchDBView::InsertMsgHdrAt(nsMsgViewIndex index, nsIMsgDBHdr *hdr,</span>
<a href="#l13.61"></a><span id="l13.61">                               nsMsgKey msgKey, PRUint32 flags, PRUint32 level)</span>
<a href="#l13.62"></a><span id="l13.62" class="difflineat">@@ -410,17 +410,17 @@ nsresult nsMsgSearchDBView::AddHdrFromFo</span>
<a href="#l13.63"></a><span id="l13.63">       viewThread-&gt;AddHdr(msgHdr, PR_FALSE, posInThread,</span>
<a href="#l13.64"></a><span id="l13.64">                          getter_AddRefs(parent));</span>
<a href="#l13.65"></a><span id="l13.65">       nsMsgViewIndex insertIndex = GetIndexForThread(msgHdr);</span>
<a href="#l13.66"></a><span id="l13.66">       NS_ASSERTION(insertIndex == m_levels.Length() || !m_levels[insertIndex],</span>
<a href="#l13.67"></a><span id="l13.67">                     &quot;inserting into middle of thread&quot;);</span>
<a href="#l13.68"></a><span id="l13.68">       if (insertIndex == nsMsgViewIndex_None)</span>
<a href="#l13.69"></a><span id="l13.69">         return NS_ERROR_FAILURE;</span>
<a href="#l13.70"></a><span id="l13.70">       if (!(m_viewFlags &amp; nsMsgViewFlagsType::kExpandAll))</span>
<a href="#l13.71"></a><span id="l13.71" class="difflineminus">-        msgFlags |= MSG_FLAG_ELIDED;</span>
<a href="#l13.72"></a><span id="l13.72" class="difflineplus">+        msgFlags |= nsMsgMessageFlags::Elided;</span>
<a href="#l13.73"></a><span id="l13.73">       InsertMsgHdrAt(insertIndex, msgHdr, msgKey, msgFlags, 0);</span>
<a href="#l13.74"></a><span id="l13.74">       NoteChange(insertIndex, 1, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l13.75"></a><span id="l13.75">     }</span>
<a href="#l13.76"></a><span id="l13.76">     else</span>
<a href="#l13.77"></a><span id="l13.77">     {</span>
<a href="#l13.78"></a><span id="l13.78">       // get the thread root index before we add the header, because adding</span>
<a href="#l13.79"></a><span id="l13.79">       // the header can change the sort position.</span>
<a href="#l13.80"></a><span id="l13.80">       nsMsgViewIndex threadIndex = GetThreadRootIndex(threadRoot);</span>
<a href="#l13.81"></a><span id="l13.81" class="difflineat">@@ -437,17 +437,17 @@ nsresult nsMsgSearchDBView::AddHdrFromFo</span>
<a href="#l13.82"></a><span id="l13.82">       if (m_sortType == nsMsgViewSortType::byDate)</span>
<a href="#l13.83"></a><span id="l13.83">       {</span>
<a href="#l13.84"></a><span id="l13.84">         PRUint32 newestMsgInThread = 0, msgDate = 0;</span>
<a href="#l13.85"></a><span id="l13.85">         viewThread-&gt;GetNewestMsgDate(&amp;newestMsgInThread);</span>
<a href="#l13.86"></a><span id="l13.86">         msgHdr-&gt;GetDateInSeconds(&amp;msgDate);</span>
<a href="#l13.87"></a><span id="l13.87">         moveThread = (msgDate == newestMsgInThread);</span>
<a href="#l13.88"></a><span id="l13.88">       }</span>
<a href="#l13.89"></a><span id="l13.89">       OrExtraFlag(threadIndex, MSG_VIEW_FLAG_HASCHILDREN | MSG_VIEW_FLAG_ISTHREAD);</span>
<a href="#l13.90"></a><span id="l13.90" class="difflineminus">-      if (!(m_flags[threadIndex] &amp; MSG_FLAG_ELIDED))</span>
<a href="#l13.91"></a><span id="l13.91" class="difflineplus">+      if (!(m_flags[threadIndex] &amp; nsMsgMessageFlags::Elided))</span>
<a href="#l13.92"></a><span id="l13.92">       {</span>
<a href="#l13.93"></a><span id="l13.93">         if (parent)</span>
<a href="#l13.94"></a><span id="l13.94">         {</span>
<a href="#l13.95"></a><span id="l13.95">           // since we know posInThread, we just want to insert the new hdr</span>
<a href="#l13.96"></a><span id="l13.96">           // at threadIndex + posInThread, and then rebuild the view until we</span>
<a href="#l13.97"></a><span id="l13.97">           // get to a sibling of the new hdr.</span>
<a href="#l13.98"></a><span id="l13.98">           PRUint8 newMsgLevel = viewThread-&gt;ChildLevelAt(posInThread);</span>
<a href="#l13.99"></a><span id="l13.99">           InsertMsgHdrAt(threadIndex + posInThread, msgHdr, msgKey, msgFlags,</span>
<a href="#l13.100"></a><span id="l13.100" class="difflineat">@@ -469,32 +469,32 @@ nsresult nsMsgSearchDBView::AddHdrFromFo</span>
<a href="#l13.101"></a><span id="l13.101"> </span>
<a href="#l13.102"></a><span id="l13.102">           NoteChange(threadIndex, 1, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l13.103"></a><span id="l13.103">           nsMsgViewIndex i;</span>
<a href="#l13.104"></a><span id="l13.104">           for (i = threadIndex + 1; </span>
<a href="#l13.105"></a><span id="l13.105">                i &lt; m_keys.Length() &amp;&amp; (i == threadIndex + 1 || m_levels[i]); i++)</span>
<a href="#l13.106"></a><span id="l13.106">             m_levels[i] = m_levels[i] + 1;</span>
<a href="#l13.107"></a><span id="l13.107">           // turn off thread flags on old root.</span>
<a href="#l13.108"></a><span id="l13.108">           AndExtraFlag(threadIndex + 1, ~(MSG_VIEW_FLAG_ISTHREAD | </span>
<a href="#l13.109"></a><span id="l13.109" class="difflineminus">-                                          MSG_FLAG_ELIDED | </span>
<a href="#l13.110"></a><span id="l13.110" class="difflineplus">+                                          nsMsgMessageFlags::Elided | </span>
<a href="#l13.111"></a><span id="l13.111">                                           MSG_VIEW_FLAG_HASCHILDREN));</span>
<a href="#l13.112"></a><span id="l13.112"> </span>
<a href="#l13.113"></a><span id="l13.113">           NoteChange(threadIndex + 1, i - threadIndex + 1, </span>
<a href="#l13.114"></a><span id="l13.114">                      nsMsgViewNotificationCode::changed);</span>
<a href="#l13.115"></a><span id="l13.115">         }</span>
<a href="#l13.116"></a><span id="l13.116">       }</span>
<a href="#l13.117"></a><span id="l13.117">       else if (!parent)</span>
<a href="#l13.118"></a><span id="l13.118">       {</span>
<a href="#l13.119"></a><span id="l13.119">         // new parent came into collapsed thread</span>
<a href="#l13.120"></a><span id="l13.120">         nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l13.121"></a><span id="l13.121">         msgHdr-&gt;GetFolder(getter_AddRefs(msgFolder));</span>
<a href="#l13.122"></a><span id="l13.122">         m_keys[threadIndex] = msgKey;</span>
<a href="#l13.123"></a><span id="l13.123">         m_folders.ReplaceObjectAt(msgFolder, threadIndex);</span>
<a href="#l13.124"></a><span id="l13.124">         m_flags[threadIndex] = msgFlags | MSG_VIEW_FLAG_ISTHREAD | </span>
<a href="#l13.125"></a><span id="l13.125" class="difflineminus">-                                          MSG_FLAG_ELIDED | </span>
<a href="#l13.126"></a><span id="l13.126" class="difflineplus">+                                          nsMsgMessageFlags::Elided | </span>
<a href="#l13.127"></a><span id="l13.127">                                           MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l13.128"></a><span id="l13.128">         NoteChange(threadIndex, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l13.129"></a><span id="l13.129"> </span>
<a href="#l13.130"></a><span id="l13.130">       }</span>
<a href="#l13.131"></a><span id="l13.131">       if (moveThread)</span>
<a href="#l13.132"></a><span id="l13.132">         MoveThreadAt(threadIndex);</span>
<a href="#l13.133"></a><span id="l13.133">     }</span>
<a href="#l13.134"></a><span id="l13.134">   }</span>
<a href="#l13.135"></a><span id="l13.135" class="difflineat">@@ -523,17 +523,17 @@ void nsMsgSearchDBView::MoveThreadAt(nsM</span>
<a href="#l13.136"></a><span id="l13.136">   // Turn off tree notifications so that we don't reload the current message.</span>
<a href="#l13.137"></a><span id="l13.137">   if (!updatesSuppressed)</span>
<a href="#l13.138"></a><span id="l13.138">     DisableChangeUpdates();</span>
<a href="#l13.139"></a><span id="l13.139"> </span>
<a href="#l13.140"></a><span id="l13.140">   nsCOMPtr&lt;nsIMsgDBHdr&gt; threadHdr;</span>
<a href="#l13.141"></a><span id="l13.141">   GetMsgHdrForViewIndex(threadIndex, getter_AddRefs(threadHdr));</span>
<a href="#l13.142"></a><span id="l13.142"> </span>
<a href="#l13.143"></a><span id="l13.143">   PRUint32 saveFlags = m_flags[threadIndex];</span>
<a href="#l13.144"></a><span id="l13.144" class="difflineminus">-  PRBool threadIsExpanded = !(saveFlags &amp; MSG_FLAG_ELIDED);</span>
<a href="#l13.145"></a><span id="l13.145" class="difflineplus">+  PRBool threadIsExpanded = !(saveFlags &amp; nsMsgMessageFlags::Elided);</span>
<a href="#l13.146"></a><span id="l13.146">   PRInt32 childCount = 0;</span>
<a href="#l13.147"></a><span id="l13.147">   nsMsgKey preservedKey;</span>
<a href="#l13.148"></a><span id="l13.148">   nsAutoTArray&lt;nsMsgKey, 1&gt; preservedSelection;</span>
<a href="#l13.149"></a><span id="l13.149"> </span>
<a href="#l13.150"></a><span id="l13.150">   SaveAndClearSelection(&amp;preservedKey, preservedSelection);</span>
<a href="#l13.151"></a><span id="l13.151">   if (threadIsExpanded)</span>
<a href="#l13.152"></a><span id="l13.152">   {</span>
<a href="#l13.153"></a><span id="l13.153">     ExpansionDelta(threadIndex, &amp;childCount);</span>
<a href="#l13.154"></a><span id="l13.154" class="difflineat">@@ -745,17 +745,17 @@ nsresult nsMsgSearchDBView::RemoveByInde</span>
<a href="#l13.155"></a><span id="l13.155">       nsMsgXFViewThread *viewThread = static_cast&lt;nsMsgXFViewThread*&gt;(thread.get());</span>
<a href="#l13.156"></a><span id="l13.156">       if (viewThread-&gt;MsgCount() == 2)</span>
<a href="#l13.157"></a><span id="l13.157">       {</span>
<a href="#l13.158"></a><span id="l13.158">         // if we removed the next to last message in the thread,</span>
<a href="#l13.159"></a><span id="l13.159">         // we need to adjust the flags on the first message in the thread.</span>
<a href="#l13.160"></a><span id="l13.160">         nsMsgViewIndex threadIndex = m_levels[index] ? index -1 : index;</span>
<a href="#l13.161"></a><span id="l13.161">         if (threadIndex != nsMsgViewIndex_None)</span>
<a href="#l13.162"></a><span id="l13.162">         {</span>
<a href="#l13.163"></a><span id="l13.163" class="difflineminus">-          AndExtraFlag(threadIndex, ~(MSG_VIEW_FLAG_ISTHREAD | MSG_FLAG_ELIDED |</span>
<a href="#l13.164"></a><span id="l13.164" class="difflineplus">+          AndExtraFlag(threadIndex, ~(MSG_VIEW_FLAG_ISTHREAD | nsMsgMessageFlags::Elided |</span>
<a href="#l13.165"></a><span id="l13.165">                                       MSG_VIEW_FLAG_HASCHILDREN));</span>
<a href="#l13.166"></a><span id="l13.166">           m_levels[threadIndex] = 0;</span>
<a href="#l13.167"></a><span id="l13.167">           NoteChange(threadIndex, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l13.168"></a><span id="l13.168">         }</span>
<a href="#l13.169"></a><span id="l13.169">       }</span>
<a href="#l13.170"></a><span id="l13.170">       // Bump up the level of all the descendents of the message</span>
<a href="#l13.171"></a><span id="l13.171">       // that was removed, if the thread was expanded.</span>
<a href="#l13.172"></a><span id="l13.172">       PRUint8 removedLevel = m_levels[index];</span>
<a href="#l13.173"></a><span id="l13.173" class="difflineat">@@ -1067,17 +1067,17 @@ nsMsgViewIndex nsMsgSearchDBView::FindHd</span>
<a href="#l13.174"></a><span id="l13.174"> {</span>
<a href="#l13.175"></a><span id="l13.175">   nsCOMPtr&lt;nsIMsgDBHdr&gt; curHdr;</span>
<a href="#l13.176"></a><span id="l13.176">   PRInt32 index;</span>
<a href="#l13.177"></a><span id="l13.177">   // it would be nice to take advantage of sorted views when possible.</span>
<a href="#l13.178"></a><span id="l13.178">   for (index = 0; index &lt; GetSize(); index++)</span>
<a href="#l13.179"></a><span id="l13.179">   {</span>
<a href="#l13.180"></a><span id="l13.180">     GetMsgHdrForViewIndex(index, getter_AddRefs(curHdr));</span>
<a href="#l13.181"></a><span id="l13.181">     if (curHdr == msgHdr &amp;&amp; (!(m_flags[index] &amp; MSG_VIEW_FLAG_DUMMY) ||</span>
<a href="#l13.182"></a><span id="l13.182" class="difflineminus">-        (m_flags[index] &amp; MSG_FLAG_ELIDED)))</span>
<a href="#l13.183"></a><span id="l13.183" class="difflineplus">+        (m_flags[index] &amp; nsMsgMessageFlags::Elided)))</span>
<a href="#l13.184"></a><span id="l13.184">       break;</span>
<a href="#l13.185"></a><span id="l13.185">   }</span>
<a href="#l13.186"></a><span id="l13.186">   return index &lt; GetSize() ? index : nsMsgViewIndex_None;</span>
<a href="#l13.187"></a><span id="l13.187"> }</span>
<a href="#l13.188"></a><span id="l13.188"> </span>
<a href="#l13.189"></a><span id="l13.189"> // This method looks for the XF thread that corresponds to this message hdr,</span>
<a href="#l13.190"></a><span id="l13.190"> // first by looking up the message id, then references, and finally, if subject</span>
<a href="#l13.191"></a><span id="l13.191"> // threading is turned on, the subject.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/mailnews/base/src/nsMsgSpecialViews.cpp</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgSpecialViews.cpp</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -71,28 +71,28 @@ PRBool nsMsgThreadsWithUnreadDBView::Wan</span>
<a href="#l14.4"></a><span id="l14.4"> nsresult nsMsgThreadsWithUnreadDBView::AddMsgToThreadNotInView(nsIMsgThread *threadHdr, nsIMsgDBHdr *msgHdr, PRBool ensureListed)</span>
<a href="#l14.5"></a><span id="l14.5"> {</span>
<a href="#l14.6"></a><span id="l14.6">   nsresult rv = NS_OK;</span>
<a href="#l14.7"></a><span id="l14.7"> </span>
<a href="#l14.8"></a><span id="l14.8">   nsCOMPtr &lt;nsIMsgDBHdr&gt; parentHdr;</span>
<a href="#l14.9"></a><span id="l14.9">   PRUint32 msgFlags;</span>
<a href="#l14.10"></a><span id="l14.10">   msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l14.11"></a><span id="l14.11">   GetFirstMessageHdrToDisplayInThread(threadHdr, getter_AddRefs(parentHdr));</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">-  if (parentHdr &amp;&amp; (ensureListed || !(msgFlags &amp; MSG_FLAG_READ)))</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+  if (parentHdr &amp;&amp; (ensureListed || !(msgFlags &amp; nsMsgMessageFlags::Read)))</span>
<a href="#l14.14"></a><span id="l14.14">   {</span>
<a href="#l14.15"></a><span id="l14.15">     nsMsgKey key;</span>
<a href="#l14.16"></a><span id="l14.16">     PRUint32 numMsgsInThread;</span>
<a href="#l14.17"></a><span id="l14.17">     rv = AddHdr(parentHdr);</span>
<a href="#l14.18"></a><span id="l14.18">     threadHdr-&gt;GetNumChildren(&amp;numMsgsInThread);</span>
<a href="#l14.19"></a><span id="l14.19">     if (numMsgsInThread &gt; 1)</span>
<a href="#l14.20"></a><span id="l14.20">     {</span>
<a href="#l14.21"></a><span id="l14.21">       parentHdr-&gt;GetMessageKey(&amp;key);</span>
<a href="#l14.22"></a><span id="l14.22">       nsMsgViewIndex viewIndex = FindViewIndex(key);</span>
<a href="#l14.23"></a><span id="l14.23">       if (viewIndex != nsMsgViewIndex_None)</span>
<a href="#l14.24"></a><span id="l14.24" class="difflineminus">-        OrExtraFlag(viewIndex, MSG_FLAG_ELIDED | MSG_VIEW_FLAG_HASCHILDREN);</span>
<a href="#l14.25"></a><span id="l14.25" class="difflineplus">+        OrExtraFlag(viewIndex, nsMsgMessageFlags::Elided | MSG_VIEW_FLAG_HASCHILDREN);</span>
<a href="#l14.26"></a><span id="l14.26">     }</span>
<a href="#l14.27"></a><span id="l14.27">   }</span>
<a href="#l14.28"></a><span id="l14.28">   return rv;</span>
<a href="#l14.29"></a><span id="l14.29"> }</span>
<a href="#l14.30"></a><span id="l14.30"> </span>
<a href="#l14.31"></a><span id="l14.31"> NS_IMETHODIMP</span>
<a href="#l14.32"></a><span id="l14.32"> nsMsgThreadsWithUnreadDBView::CloneDBView(nsIMessenger *aMessengerInstance, nsIMsgWindow *aMsgWindow, nsIMsgDBViewCommandUpdater *aCmdUpdater, nsIMsgDBView **_retval)</span>
<a href="#l14.33"></a><span id="l14.33"> {</span>
<a href="#l14.34"></a><span id="l14.34" class="difflineat">@@ -120,45 +120,45 @@ PRBool nsMsgWatchedThreadsWithUnreadDBVi</span>
<a href="#l14.35"></a><span id="l14.35"> {</span>
<a href="#l14.36"></a><span id="l14.36"> 	if (threadHdr)</span>
<a href="#l14.37"></a><span id="l14.37">   {</span>
<a href="#l14.38"></a><span id="l14.38">     PRUint32 numNewChildren;</span>
<a href="#l14.39"></a><span id="l14.39">     PRUint32 threadFlags;</span>
<a href="#l14.40"></a><span id="l14.40"> </span>
<a href="#l14.41"></a><span id="l14.41">     threadHdr-&gt;GetNumUnreadChildren(&amp;numNewChildren);</span>
<a href="#l14.42"></a><span id="l14.42">     threadHdr-&gt;GetFlags(&amp;threadFlags);</span>
<a href="#l14.43"></a><span id="l14.43" class="difflineminus">-    if (numNewChildren &gt; 0 &amp;&amp; (threadFlags &amp; MSG_FLAG_WATCHED) != 0) </span>
<a href="#l14.44"></a><span id="l14.44" class="difflineplus">+    if (numNewChildren &gt; 0 &amp;&amp; (threadFlags &amp; nsMsgMessageFlags::Watched) != 0) </span>
<a href="#l14.45"></a><span id="l14.45">       return PR_TRUE;</span>
<a href="#l14.46"></a><span id="l14.46">   }</span>
<a href="#l14.47"></a><span id="l14.47">   return PR_FALSE;</span>
<a href="#l14.48"></a><span id="l14.48"> }</span>
<a href="#l14.49"></a><span id="l14.49"> </span>
<a href="#l14.50"></a><span id="l14.50"> nsresult nsMsgWatchedThreadsWithUnreadDBView::AddMsgToThreadNotInView(nsIMsgThread *threadHdr, nsIMsgDBHdr *msgHdr, PRBool ensureListed)</span>
<a href="#l14.51"></a><span id="l14.51"> {</span>
<a href="#l14.52"></a><span id="l14.52">   nsresult rv = NS_OK;</span>
<a href="#l14.53"></a><span id="l14.53">   PRUint32 threadFlags;</span>
<a href="#l14.54"></a><span id="l14.54">   PRUint32 msgFlags;</span>
<a href="#l14.55"></a><span id="l14.55">   msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l14.56"></a><span id="l14.56">   threadHdr-&gt;GetFlags(&amp;threadFlags);</span>
<a href="#l14.57"></a><span id="l14.57" class="difflineminus">-  if (threadFlags &amp; MSG_FLAG_WATCHED)</span>
<a href="#l14.58"></a><span id="l14.58" class="difflineplus">+  if (threadFlags &amp; nsMsgMessageFlags::Watched)</span>
<a href="#l14.59"></a><span id="l14.59">   {</span>
<a href="#l14.60"></a><span id="l14.60">     nsCOMPtr &lt;nsIMsgDBHdr&gt; parentHdr;</span>
<a href="#l14.61"></a><span id="l14.61">     GetFirstMessageHdrToDisplayInThread(threadHdr, getter_AddRefs(parentHdr));</span>
<a href="#l14.62"></a><span id="l14.62" class="difflineminus">-    if (parentHdr &amp;&amp; (ensureListed || !(msgFlags &amp; MSG_FLAG_READ)))</span>
<a href="#l14.63"></a><span id="l14.63" class="difflineplus">+    if (parentHdr &amp;&amp; (ensureListed || !(msgFlags &amp; nsMsgMessageFlags::Read)))</span>
<a href="#l14.64"></a><span id="l14.64">     {</span>
<a href="#l14.65"></a><span id="l14.65">       PRUint32 numChildren;</span>
<a href="#l14.66"></a><span id="l14.66">       threadHdr-&gt;GetNumChildren(&amp;numChildren);</span>
<a href="#l14.67"></a><span id="l14.67">       rv = AddHdr(parentHdr);</span>
<a href="#l14.68"></a><span id="l14.68">       if (numChildren &gt; 1)</span>
<a href="#l14.69"></a><span id="l14.69">       {</span>
<a href="#l14.70"></a><span id="l14.70">         nsMsgKey key;</span>
<a href="#l14.71"></a><span id="l14.71">         parentHdr-&gt;GetMessageKey(&amp;key);</span>
<a href="#l14.72"></a><span id="l14.72">         nsMsgViewIndex viewIndex = FindViewIndex(key);</span>
<a href="#l14.73"></a><span id="l14.73">         if (viewIndex != nsMsgViewIndex_None)</span>
<a href="#l14.74"></a><span id="l14.74" class="difflineminus">-          OrExtraFlag(viewIndex, MSG_FLAG_ELIDED | MSG_VIEW_FLAG_ISTHREAD | MSG_VIEW_FLAG_HASCHILDREN | MSG_FLAG_WATCHED);</span>
<a href="#l14.75"></a><span id="l14.75" class="difflineplus">+          OrExtraFlag(viewIndex, nsMsgMessageFlags::Elided | MSG_VIEW_FLAG_ISTHREAD | MSG_VIEW_FLAG_HASCHILDREN | nsMsgMessageFlags::Watched);</span>
<a href="#l14.76"></a><span id="l14.76">       }</span>
<a href="#l14.77"></a><span id="l14.77">     }</span>
<a href="#l14.78"></a><span id="l14.78">   }</span>
<a href="#l14.79"></a><span id="l14.79">   return rv;</span>
<a href="#l14.80"></a><span id="l14.80"> }</span>
<a href="#l14.81"></a><span id="l14.81"> </span>
<a href="#l14.82"></a><span id="l14.82"> NS_IMETHODIMP</span>
<a href="#l14.83"></a><span id="l14.83"> nsMsgWatchedThreadsWithUnreadDBView::CloneDBView(nsIMessenger *aMessengerInstance, nsIMsgWindow *aMsgWindow, nsIMsgDBViewCommandUpdater *aCmdUpdater, nsIMsgDBView **_retval)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/mailnews/base/src/nsMsgThreadedDBView.cpp</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgThreadedDBView.cpp</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -101,17 +101,17 @@ NS_IMETHODIMP nsMsgThreadedDBView::Open(</span>
<a href="#l15.4"></a><span id="l15.4">   // matches what the db totals say. Except ignored threads are</span>
<a href="#l15.5"></a><span id="l15.5">   // going to throw us off...hmm. Unless we just look at the</span>
<a href="#l15.6"></a><span id="l15.6">   // unread counts which is what mostly tweaks people anyway...</span>
<a href="#l15.7"></a><span id="l15.7">   PRInt32 unreadMsgsInView = 0;</span>
<a href="#l15.8"></a><span id="l15.8">   if (!(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l15.9"></a><span id="l15.9">   {</span>
<a href="#l15.10"></a><span id="l15.10">     for (PRInt32 i = 0; i &lt; m_flags.Length(); i++)</span>
<a href="#l15.11"></a><span id="l15.11">     {</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineminus">-      if (! (m_flags[i] &amp; MSG_FLAG_READ))</span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+      if (! (m_flags[i] &amp; nsMsgMessageFlags::Read))</span>
<a href="#l15.14"></a><span id="l15.14">         unreadMsgsInView++;</span>
<a href="#l15.15"></a><span id="l15.15">     }</span>
<a href="#l15.16"></a><span id="l15.16">     if (unreadMessages != unreadMsgsInView)</span>
<a href="#l15.17"></a><span id="l15.17">       m_db-&gt;SyncCounts();</span>
<a href="#l15.18"></a><span id="l15.18">   }</span>
<a href="#l15.19"></a><span id="l15.19">   m_db-&gt;SetMsgHdrCacheSize(MSGHDR_CACHE_DEFAULT_SIZE);</span>
<a href="#l15.20"></a><span id="l15.20"> </span>
<a href="#l15.21"></a><span id="l15.21">   return rv;</span>
<a href="#l15.22"></a><span id="l15.22" class="difflineat">@@ -197,20 +197,20 @@ nsresult nsMsgThreadedDBView::SortThread</span>
<a href="#l15.23"></a><span id="l15.23">   DisableChangeUpdates();</span>
<a href="#l15.24"></a><span id="l15.24">   // Loop through the original array, for each thread that's expanded, find it in the new array</span>
<a href="#l15.25"></a><span id="l15.25">   // and expand the thread. We have to update MSG_VIEW_FLAG_HAS_CHILDREN because</span>
<a href="#l15.26"></a><span id="l15.26">   // we may be going from a flat sort, which doesn't maintain that flag,</span>
<a href="#l15.27"></a><span id="l15.27">   // to a threaded sort, which requires that flag.</span>
<a href="#l15.28"></a><span id="l15.28">   for (PRUint32 j = 0; j &lt; m_keys.Length(); j++)</span>
<a href="#l15.29"></a><span id="l15.29">   {</span>
<a href="#l15.30"></a><span id="l15.30">     PRUint32 flags = m_flags[j];</span>
<a href="#l15.31"></a><span id="l15.31" class="difflineminus">-    if ((flags &amp; (MSG_VIEW_FLAG_HASCHILDREN | MSG_FLAG_ELIDED)) == MSG_VIEW_FLAG_HASCHILDREN)</span>
<a href="#l15.32"></a><span id="l15.32" class="difflineplus">+    if ((flags &amp; (MSG_VIEW_FLAG_HASCHILDREN | nsMsgMessageFlags::Elided)) == MSG_VIEW_FLAG_HASCHILDREN)</span>
<a href="#l15.33"></a><span id="l15.33">     {</span>
<a href="#l15.34"></a><span id="l15.34">       PRUint32 numExpanded;</span>
<a href="#l15.35"></a><span id="l15.35" class="difflineminus">-      m_flags[j] = flags | MSG_FLAG_ELIDED;</span>
<a href="#l15.36"></a><span id="l15.36" class="difflineplus">+      m_flags[j] = flags | nsMsgMessageFlags::Elided;</span>
<a href="#l15.37"></a><span id="l15.37">       ExpandByIndex(j, &amp;numExpanded);</span>
<a href="#l15.38"></a><span id="l15.38">       j += numExpanded;</span>
<a href="#l15.39"></a><span id="l15.39">       if (numExpanded &gt; 0)</span>
<a href="#l15.40"></a><span id="l15.40">         m_flags[j - numExpanded] = flags | MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l15.41"></a><span id="l15.41">     }</span>
<a href="#l15.42"></a><span id="l15.42">     else if (flags &amp; MSG_VIEW_FLAG_ISTHREAD &amp;&amp; ! (flags &amp; MSG_VIEW_FLAG_HASCHILDREN))</span>
<a href="#l15.43"></a><span id="l15.43">     {</span>
<a href="#l15.44"></a><span id="l15.44">       nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l15.45"></a><span id="l15.45" class="difflineat">@@ -219,17 +219,17 @@ nsresult nsMsgThreadedDBView::SortThread</span>
<a href="#l15.46"></a><span id="l15.46">       if (msgHdr)</span>
<a href="#l15.47"></a><span id="l15.47">       {</span>
<a href="#l15.48"></a><span id="l15.48">         m_db-&gt;GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(pThread));</span>
<a href="#l15.49"></a><span id="l15.49">         if (pThread)</span>
<a href="#l15.50"></a><span id="l15.50">         {</span>
<a href="#l15.51"></a><span id="l15.51">           PRUint32 numChildren;</span>
<a href="#l15.52"></a><span id="l15.52">           pThread-&gt;GetNumChildren(&amp;numChildren);</span>
<a href="#l15.53"></a><span id="l15.53">           if (numChildren &gt; 1)</span>
<a href="#l15.54"></a><span id="l15.54" class="difflineminus">-            m_flags[j] = flags | MSG_VIEW_FLAG_HASCHILDREN | MSG_FLAG_ELIDED;</span>
<a href="#l15.55"></a><span id="l15.55" class="difflineplus">+            m_flags[j] = flags | MSG_VIEW_FLAG_HASCHILDREN | nsMsgMessageFlags::Elided;</span>
<a href="#l15.56"></a><span id="l15.56">         }</span>
<a href="#l15.57"></a><span id="l15.57">       }</span>
<a href="#l15.58"></a><span id="l15.58">     }</span>
<a href="#l15.59"></a><span id="l15.59">   }</span>
<a href="#l15.60"></a><span id="l15.60">   EnableChangeUpdates();</span>
<a href="#l15.61"></a><span id="l15.61"> </span>
<a href="#l15.62"></a><span id="l15.62">   return NS_OK;</span>
<a href="#l15.63"></a><span id="l15.63"> }</span>
<a href="#l15.64"></a><span id="l15.64" class="difflineat">@@ -243,43 +243,43 @@ nsresult nsMsgThreadedDBView::AddKeys(ns</span>
<a href="#l15.65"></a><span id="l15.65">   m_flags.SetCapacity(m_flags.Length() + numKeysToAdd);</span>
<a href="#l15.66"></a><span id="l15.66">   m_levels.SetCapacity(m_levels.Length() + numKeysToAdd);</span>
<a href="#l15.67"></a><span id="l15.67">   for (PRInt32 i = 0; i &lt; numKeysToAdd; i++)</span>
<a href="#l15.68"></a><span id="l15.68">   {</span>
<a href="#l15.69"></a><span id="l15.69">     PRInt32 threadFlag = pFlags[i];</span>
<a href="#l15.70"></a><span id="l15.70">     PRInt32 flag = threadFlag;</span>
<a href="#l15.71"></a><span id="l15.71">     </span>
<a href="#l15.72"></a><span id="l15.72">     // skip ignored threads.</span>
<a href="#l15.73"></a><span id="l15.73" class="difflineminus">-    if ((threadFlag &amp; MSG_FLAG_IGNORED) &amp;&amp; !(m_viewFlags &amp; nsMsgViewFlagsType::kShowIgnored))</span>
<a href="#l15.74"></a><span id="l15.74" class="difflineplus">+    if ((threadFlag &amp; nsMsgMessageFlags::Ignored) &amp;&amp; !(m_viewFlags &amp; nsMsgViewFlagsType::kShowIgnored))</span>
<a href="#l15.75"></a><span id="l15.75">       continue;</span>
<a href="#l15.76"></a><span id="l15.76">     </span>
<a href="#l15.77"></a><span id="l15.77">     // skip ignored subthreads</span>
<a href="#l15.78"></a><span id="l15.78">     nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l15.79"></a><span id="l15.79">     m_db-&gt;GetMsgHdrForKey(pKeys[i], getter_AddRefs(msgHdr));</span>
<a href="#l15.80"></a><span id="l15.80">     if (!(m_viewFlags &amp; nsMsgViewFlagsType::kShowIgnored))</span>
<a href="#l15.81"></a><span id="l15.81">     {</span>
<a href="#l15.82"></a><span id="l15.82">       PRBool killed;</span>
<a href="#l15.83"></a><span id="l15.83">       msgHdr-&gt;GetIsKilled(&amp;killed);</span>
<a href="#l15.84"></a><span id="l15.84">       if (killed)</span>
<a href="#l15.85"></a><span id="l15.85">         continue;</span>
<a href="#l15.86"></a><span id="l15.86">     }</span>
<a href="#l15.87"></a><span id="l15.87"> </span>
<a href="#l15.88"></a><span id="l15.88">     // by default, make threads collapsed, unless we're in only viewing new msgs</span>
<a href="#l15.89"></a><span id="l15.89">     </span>
<a href="#l15.90"></a><span id="l15.90">     if (flag &amp; MSG_VIEW_FLAG_HASCHILDREN)</span>
<a href="#l15.91"></a><span id="l15.91" class="difflineminus">-      flag |= MSG_FLAG_ELIDED;</span>
<a href="#l15.92"></a><span id="l15.92" class="difflineplus">+      flag |= nsMsgMessageFlags::Elided;</span>
<a href="#l15.93"></a><span id="l15.93">     // should this be persistent? Doesn't seem to need to be.</span>
<a href="#l15.94"></a><span id="l15.94">     flag |= MSG_VIEW_FLAG_ISTHREAD;</span>
<a href="#l15.95"></a><span id="l15.95">     m_keys.AppendElement(pKeys[i]);</span>
<a href="#l15.96"></a><span id="l15.96">     m_flags.AppendElement(flag);</span>
<a href="#l15.97"></a><span id="l15.97">     m_levels.AppendElement(pLevels[i]);</span>
<a href="#l15.98"></a><span id="l15.98">     numAdded++;</span>
<a href="#l15.99"></a><span id="l15.99">     // we expand as we build the view, which allows us to insert at the end of the key array,</span>
<a href="#l15.100"></a><span id="l15.100">     // instead of the middle, and is much faster.</span>
<a href="#l15.101"></a><span id="l15.101" class="difflineminus">-    if ((!(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay) || m_viewFlags &amp; nsMsgViewFlagsType::kExpandAll) &amp;&amp; flag &amp; MSG_FLAG_ELIDED)</span>
<a href="#l15.102"></a><span id="l15.102" class="difflineplus">+    if ((!(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay) || m_viewFlags &amp; nsMsgViewFlagsType::kExpandAll) &amp;&amp; flag &amp; nsMsgMessageFlags::Elided)</span>
<a href="#l15.103"></a><span id="l15.103">        ExpandByIndex(m_keys.Length() - 1, NULL);</span>
<a href="#l15.104"></a><span id="l15.104">   }</span>
<a href="#l15.105"></a><span id="l15.105">   return numAdded;</span>
<a href="#l15.106"></a><span id="l15.106"> }</span>
<a href="#l15.107"></a><span id="l15.107"> </span>
<a href="#l15.108"></a><span id="l15.108"> NS_IMETHODIMP nsMsgThreadedDBView::Sort(nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder)</span>
<a href="#l15.109"></a><span id="l15.109"> {</span>
<a href="#l15.110"></a><span id="l15.110">   nsresult rv;</span>
<a href="#l15.111"></a><span id="l15.111" class="difflineat">@@ -461,29 +461,29 @@ nsresult nsMsgThreadedDBView::ListThread</span>
<a href="#l15.112"></a><span id="l15.112">         nsMsgKey msgKey;</span>
<a href="#l15.113"></a><span id="l15.113">         msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l15.114"></a><span id="l15.114">         msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l15.115"></a><span id="l15.115">         // turn off high byte of msg flags - used for view flags.</span>
<a href="#l15.116"></a><span id="l15.116">         msgFlags &amp;= ~MSG_VIEW_FLAGS;</span>
<a href="#l15.117"></a><span id="l15.117">         pOutput[numListed] = msgKey;</span>
<a href="#l15.118"></a><span id="l15.118">         pLevels[numListed] = 0;</span>
<a href="#l15.119"></a><span id="l15.119">         // turn off these flags on msg hdr - they belong in thread</span>
<a href="#l15.120"></a><span id="l15.120" class="difflineminus">-        msgHdr-&gt;AndFlags(~(MSG_FLAG_WATCHED), &amp;newMsgFlags);</span>
<a href="#l15.121"></a><span id="l15.121" class="difflineplus">+        msgHdr-&gt;AndFlags(~(nsMsgMessageFlags::Watched), &amp;newMsgFlags);</span>
<a href="#l15.122"></a><span id="l15.122">         AdjustReadFlag(msgHdr, &amp;msgFlags);</span>
<a href="#l15.123"></a><span id="l15.123">         // try adding in MSG_VIEW_FLAG_ISTHREAD flag for unreadonly view.</span>
<a href="#l15.124"></a><span id="l15.124">         pFlags[numListed] = msgFlags | MSG_VIEW_FLAG_ISTHREAD | threadFlags;</span>
<a href="#l15.125"></a><span id="l15.125">         if (numChildren &gt; 1)</span>
<a href="#l15.126"></a><span id="l15.126">           pFlags[numListed] |= MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l15.127"></a><span id="l15.127">         </span>
<a href="#l15.128"></a><span id="l15.128">         numListed++;</span>
<a href="#l15.129"></a><span id="l15.129">       }</span>
<a href="#l15.130"></a><span id="l15.130">       else</span>
<a href="#l15.131"></a><span id="l15.131">         NS_ASSERTION(NS_SUCCEEDED(rv) &amp;&amp; msgHdr, &quot;couldn't get header for some reason&quot;);</span>
<a href="#l15.132"></a><span id="l15.132">     }</span>
<a href="#l15.133"></a><span id="l15.133" class="difflineminus">-    else if (threadsRemoved &lt; 10 &amp;&amp; !(threadFlags &amp; (MSG_FLAG_WATCHED | MSG_FLAG_IGNORED)))</span>
<a href="#l15.134"></a><span id="l15.134" class="difflineplus">+    else if (threadsRemoved &lt; 10 &amp;&amp; !(threadFlags &amp; (nsMsgMessageFlags::Watched | nsMsgMessageFlags::Ignored)))</span>
<a href="#l15.135"></a><span id="l15.135">     {</span>
<a href="#l15.136"></a><span id="l15.136">       // ### remove thread.</span>
<a href="#l15.137"></a><span id="l15.137">       threadsRemoved++;	// don't want to remove all empty threads first time</span>
<a href="#l15.138"></a><span id="l15.138">       // around as it will choke preformance for upgrade.</span>
<a href="#l15.139"></a><span id="l15.139"> #ifdef DEBUG_bienvenu</span>
<a href="#l15.140"></a><span id="l15.140">       printf(&quot;removing empty non-ignored non-watched thread\n&quot;);</span>
<a href="#l15.141"></a><span id="l15.141"> #endif</span>
<a href="#l15.142"></a><span id="l15.142">     }</span>
<a href="#l15.143"></a><span id="l15.143" class="difflineat">@@ -513,20 +513,20 @@ void	nsMsgThreadedDBView::OnExtraFlagCha</span>
<a href="#l15.144"></a><span id="l15.144">     if (m_havePrevView)</span>
<a href="#l15.145"></a><span id="l15.145">     {</span>
<a href="#l15.146"></a><span id="l15.146">       nsMsgKey keyChanged = m_keys[index];</span>
<a href="#l15.147"></a><span id="l15.147">       nsMsgViewIndex prevViewIndex = m_prevKeys.IndexOf(keyChanged);</span>
<a href="#l15.148"></a><span id="l15.148">       if (prevViewIndex != nsMsgViewIndex_None)</span>
<a href="#l15.149"></a><span id="l15.149">       {</span>
<a href="#l15.150"></a><span id="l15.150">         PRUint32 prevFlag = m_prevFlags[prevViewIndex];</span>
<a href="#l15.151"></a><span id="l15.151">         // don't want to change the elided bit, or has children or is thread</span>
<a href="#l15.152"></a><span id="l15.152" class="difflineminus">-        if (prevFlag &amp; MSG_FLAG_ELIDED)</span>
<a href="#l15.153"></a><span id="l15.153" class="difflineminus">-          extraFlag |= MSG_FLAG_ELIDED;</span>
<a href="#l15.154"></a><span id="l15.154" class="difflineplus">+        if (prevFlag &amp; nsMsgMessageFlags::Elided)</span>
<a href="#l15.155"></a><span id="l15.155" class="difflineplus">+          extraFlag |= nsMsgMessageFlags::Elided;</span>
<a href="#l15.156"></a><span id="l15.156">         else</span>
<a href="#l15.157"></a><span id="l15.157" class="difflineminus">-          extraFlag &amp;= ~MSG_FLAG_ELIDED;</span>
<a href="#l15.158"></a><span id="l15.158" class="difflineplus">+          extraFlag &amp;= ~nsMsgMessageFlags::Elided;</span>
<a href="#l15.159"></a><span id="l15.159">         if (prevFlag &amp; MSG_VIEW_FLAG_ISTHREAD)</span>
<a href="#l15.160"></a><span id="l15.160">           extraFlag |= MSG_VIEW_FLAG_ISTHREAD;</span>
<a href="#l15.161"></a><span id="l15.161">         else</span>
<a href="#l15.162"></a><span id="l15.162">           extraFlag &amp;= ~MSG_VIEW_FLAG_ISTHREAD;</span>
<a href="#l15.163"></a><span id="l15.163">         if (prevFlag &amp; MSG_VIEW_FLAG_HASCHILDREN)</span>
<a href="#l15.164"></a><span id="l15.164">           extraFlag |= MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l15.165"></a><span id="l15.165">         else</span>
<a href="#l15.166"></a><span id="l15.166">           extraFlag &amp;= ~MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l15.167"></a><span id="l15.167" class="difflineat">@@ -595,17 +595,17 @@ nsresult nsMsgThreadedDBView::OnNewHeade</span>
<a href="#l15.168"></a><span id="l15.168"> </span>
<a href="#l15.169"></a><span id="l15.169">   // views can override this behaviour, which is to append to view.</span>
<a href="#l15.170"></a><span id="l15.170">   // This is the mail behaviour, but threaded views want</span>
<a href="#l15.171"></a><span id="l15.171">   // to insert in order...</span>
<a href="#l15.172"></a><span id="l15.172">   if (newHdr)</span>
<a href="#l15.173"></a><span id="l15.173">   {</span>
<a href="#l15.174"></a><span id="l15.174">     PRUint32 msgFlags;</span>
<a href="#l15.175"></a><span id="l15.175">     newHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l15.176"></a><span id="l15.176" class="difflineminus">-    if ((m_viewFlags &amp; nsMsgViewFlagsType::kUnreadOnly) &amp;&amp; !ensureListed &amp;&amp; (msgFlags &amp; MSG_FLAG_READ))</span>
<a href="#l15.177"></a><span id="l15.177" class="difflineplus">+    if ((m_viewFlags &amp; nsMsgViewFlagsType::kUnreadOnly) &amp;&amp; !ensureListed &amp;&amp; (msgFlags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l15.178"></a><span id="l15.178">       return NS_OK;</span>
<a href="#l15.179"></a><span id="l15.179">     // Currently, we only add the header in a threaded view if it's a thread.</span>
<a href="#l15.180"></a><span id="l15.180">     // We used to check if this was the first header in the thread, but that's</span>
<a href="#l15.181"></a><span id="l15.181">     // a bit harder in the unreadOnly view. But we'll catch it below.</span>
<a href="#l15.182"></a><span id="l15.182"> </span>
<a href="#l15.183"></a><span id="l15.183">     // for search view we don't support threaded display so just add it to the view.   </span>
<a href="#l15.184"></a><span id="l15.184">     if (!(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay)) // || msgHdr-&gt;GetMessageKey() == m_messageDB-&gt;GetKeyOfFirstMsgInThread(msgHdr-&gt;GetMessageKey()))</span>
<a href="#l15.185"></a><span id="l15.185">       rv = AddHdr(newHdr);</span>
<a href="#l15.186"></a><span id="l15.186" class="difflineat">@@ -627,20 +627,20 @@ nsresult nsMsgThreadedDBView::OnNewHeade</span>
<a href="#l15.187"></a><span id="l15.187">       }</span>
<a href="#l15.188"></a><span id="l15.188">       if (threadIndex != nsMsgViewIndex_None)</span>
<a href="#l15.189"></a><span id="l15.189">       {</span>
<a href="#l15.190"></a><span id="l15.190">         PRUint32	flags = m_flags[threadIndex];</span>
<a href="#l15.191"></a><span id="l15.191">         if (!(flags &amp; MSG_VIEW_FLAG_HASCHILDREN))</span>
<a href="#l15.192"></a><span id="l15.192">         {</span>
<a href="#l15.193"></a><span id="l15.193">           flags |= MSG_VIEW_FLAG_HASCHILDREN | MSG_VIEW_FLAG_ISTHREAD;</span>
<a href="#l15.194"></a><span id="l15.194">           if (!(m_viewFlags &amp; nsMsgViewFlagsType::kUnreadOnly))</span>
<a href="#l15.195"></a><span id="l15.195" class="difflineminus">-            flags |= MSG_FLAG_ELIDED;</span>
<a href="#l15.196"></a><span id="l15.196" class="difflineplus">+            flags |= nsMsgMessageFlags::Elided;</span>
<a href="#l15.197"></a><span id="l15.197">           m_flags[threadIndex] = flags;</span>
<a href="#l15.198"></a><span id="l15.198">         }</span>
<a href="#l15.199"></a><span id="l15.199" class="difflineminus">-        if (!(flags &amp; MSG_FLAG_ELIDED))	// thread is expanded</span>
<a href="#l15.200"></a><span id="l15.200" class="difflineplus">+        if (!(flags &amp; nsMsgMessageFlags::Elided))	// thread is expanded</span>
<a href="#l15.201"></a><span id="l15.201">         {								// insert child into thread</span>
<a href="#l15.202"></a><span id="l15.202">           // levels of other hdrs may have changed!</span>
<a href="#l15.203"></a><span id="l15.203">           PRUint32	newFlags = msgFlags;</span>
<a href="#l15.204"></a><span id="l15.204">           PRInt32 level = 0;</span>
<a href="#l15.205"></a><span id="l15.205">           nsMsgViewIndex insertIndex = threadIndex;</span>
<a href="#l15.206"></a><span id="l15.206">           if (aParentKey == nsMsgKey_None)</span>
<a href="#l15.207"></a><span id="l15.207">           {</span>
<a href="#l15.208"></a><span id="l15.208">             newFlags |= MSG_VIEW_FLAG_ISTHREAD | MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l15.209"></a><span id="l15.209" class="difflineat">@@ -755,17 +755,17 @@ void nsMsgThreadedDBView::MoveThreadAt(n</span>
<a href="#l15.210"></a><span id="l15.210"> </span>
<a href="#l15.211"></a><span id="l15.211">   GetMsgHdrForViewIndex(threadIndex, getter_AddRefs(threadHdr));</span>
<a href="#l15.212"></a><span id="l15.212">   PRInt32 childCount = 0;</span>
<a href="#l15.213"></a><span id="l15.213"> </span>
<a href="#l15.214"></a><span id="l15.214">   nsMsgKey preservedKey;</span>
<a href="#l15.215"></a><span id="l15.215">   nsAutoTArray&lt;nsMsgKey, 1&gt; preservedSelection;</span>
<a href="#l15.216"></a><span id="l15.216">   SaveAndClearSelection(&amp;preservedKey, preservedSelection);</span>
<a href="#l15.217"></a><span id="l15.217">   PRUint32 saveFlags = m_flags[threadIndex];</span>
<a href="#l15.218"></a><span id="l15.218" class="difflineminus">-  PRBool threadIsExpanded = !(saveFlags &amp; MSG_FLAG_ELIDED);</span>
<a href="#l15.219"></a><span id="l15.219" class="difflineplus">+  PRBool threadIsExpanded = !(saveFlags &amp; nsMsgMessageFlags::Elided);</span>
<a href="#l15.220"></a><span id="l15.220"> </span>
<a href="#l15.221"></a><span id="l15.221">   if (threadIsExpanded)</span>
<a href="#l15.222"></a><span id="l15.222">   {</span>
<a href="#l15.223"></a><span id="l15.223">     ExpansionDelta(threadIndex, &amp;childCount);</span>
<a href="#l15.224"></a><span id="l15.224">     childCount = -childCount;</span>
<a href="#l15.225"></a><span id="l15.225">   }</span>
<a href="#l15.226"></a><span id="l15.226">   nsTArray&lt;nsMsgKey&gt; threadKeys;</span>
<a href="#l15.227"></a><span id="l15.227">   nsTArray&lt;PRUint32&gt; threadFlags;</span>
<a href="#l15.228"></a><span id="l15.228" class="difflineat">@@ -812,17 +812,17 @@ void nsMsgThreadedDBView::MoveThreadAt(n</span>
<a href="#l15.229"></a><span id="l15.229">   NoteChange(lowIndex, highIndex - lowIndex + childCount, </span>
<a href="#l15.230"></a><span id="l15.230">               nsMsgViewNotificationCode::changed);</span>
<a href="#l15.231"></a><span id="l15.231"> }</span>
<a href="#l15.232"></a><span id="l15.232"> nsresult nsMsgThreadedDBView::AddMsgToThreadNotInView(nsIMsgThread *threadHdr, nsIMsgDBHdr *msgHdr, PRBool ensureListed)</span>
<a href="#l15.233"></a><span id="l15.233"> {</span>
<a href="#l15.234"></a><span id="l15.234">   nsresult rv = NS_OK;</span>
<a href="#l15.235"></a><span id="l15.235">   PRUint32 threadFlags;</span>
<a href="#l15.236"></a><span id="l15.236">   threadHdr-&gt;GetFlags(&amp;threadFlags);</span>
<a href="#l15.237"></a><span id="l15.237" class="difflineminus">-  if (!(threadFlags &amp; MSG_FLAG_IGNORED))</span>
<a href="#l15.238"></a><span id="l15.238" class="difflineplus">+  if (!(threadFlags &amp; nsMsgMessageFlags::Ignored))</span>
<a href="#l15.239"></a><span id="l15.239">   {</span>
<a href="#l15.240"></a><span id="l15.240">     PRBool msgKilled;</span>
<a href="#l15.241"></a><span id="l15.241">     msgHdr-&gt;GetIsKilled(&amp;msgKilled);</span>
<a href="#l15.242"></a><span id="l15.242">     if (!msgKilled)</span>
<a href="#l15.243"></a><span id="l15.243">       rv = nsMsgDBView::AddHdr(msgHdr);</span>
<a href="#l15.244"></a><span id="l15.244">   }</span>
<a href="#l15.245"></a><span id="l15.245">   return rv;</span>
<a href="#l15.246"></a><span id="l15.246"> }</span>
<a href="#l15.247"></a><span id="l15.247" class="difflineat">@@ -846,17 +846,17 @@ nsresult nsMsgThreadedDBView::RemoveByIn</span>
<a href="#l15.248"></a><span id="l15.248">   </span>
<a href="#l15.249"></a><span id="l15.249">   nsCOMPtr &lt;nsIMsgThread&gt; threadHdr; </span>
<a href="#l15.250"></a><span id="l15.250">   GetThreadContainingIndex(index, getter_AddRefs(threadHdr));</span>
<a href="#l15.251"></a><span id="l15.251">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l15.252"></a><span id="l15.252">   PRUint32 numThreadChildren = 0; // if we can't get thread, it's already deleted and thus has 0 children</span>
<a href="#l15.253"></a><span id="l15.253">   if (threadHdr)</span>
<a href="#l15.254"></a><span id="l15.254">     threadHdr-&gt;GetNumChildren(&amp;numThreadChildren);</span>
<a href="#l15.255"></a><span id="l15.255">   // check if we're the top level msg in the thread, and we're not collapsed.</span>
<a href="#l15.256"></a><span id="l15.256" class="difflineminus">-  if ((flags &amp; MSG_VIEW_FLAG_ISTHREAD) &amp;&amp; !(flags &amp; MSG_FLAG_ELIDED) &amp;&amp; (flags &amp; MSG_VIEW_FLAG_HASCHILDREN))</span>
<a href="#l15.257"></a><span id="l15.257" class="difflineplus">+  if ((flags &amp; MSG_VIEW_FLAG_ISTHREAD) &amp;&amp; !(flags &amp; nsMsgMessageFlags::Elided) &amp;&amp; (flags &amp; MSG_VIEW_FLAG_HASCHILDREN))</span>
<a href="#l15.258"></a><span id="l15.258">   {</span>
<a href="#l15.259"></a><span id="l15.259">     // fix flags on thread header...Newly promoted message </span>
<a href="#l15.260"></a><span id="l15.260">     // should have flags set correctly</span>
<a href="#l15.261"></a><span id="l15.261">     if (threadHdr)</span>
<a href="#l15.262"></a><span id="l15.262">     {</span>
<a href="#l15.263"></a><span id="l15.263">       nsMsgDBView::RemoveByIndex(index);</span>
<a href="#l15.264"></a><span id="l15.264">       nsCOMPtr &lt;nsIMsgThread&gt; nextThreadHdr;</span>
<a href="#l15.265"></a><span id="l15.265">       if (numThreadChildren &gt; 0)</span>
<a href="#l15.266"></a><span id="l15.266" class="difflineat">@@ -885,17 +885,17 @@ nsresult nsMsgThreadedDBView::RemoveByIn</span>
<a href="#l15.267"></a><span id="l15.267">       nsMsgKey msgKey;</span>
<a href="#l15.268"></a><span id="l15.268">       rv = threadHdr-&gt;GetChildKeyAt(0, &amp;msgKey);</span>
<a href="#l15.269"></a><span id="l15.269">       if (NS_SUCCEEDED(rv))</span>
<a href="#l15.270"></a><span id="l15.270">       {</span>
<a href="#l15.271"></a><span id="l15.271">         nsMsgViewIndex threadIndex = FindViewIndex(msgKey);</span>
<a href="#l15.272"></a><span id="l15.272">         if (threadIndex != nsMsgViewIndex_None)</span>
<a href="#l15.273"></a><span id="l15.273">         {</span>
<a href="#l15.274"></a><span id="l15.274">           PRUint32 flags = m_flags[threadIndex];</span>
<a href="#l15.275"></a><span id="l15.275" class="difflineminus">-          flags &amp;= ~(MSG_VIEW_FLAG_ISTHREAD | MSG_FLAG_ELIDED | MSG_VIEW_FLAG_HASCHILDREN);</span>
<a href="#l15.276"></a><span id="l15.276" class="difflineplus">+          flags &amp;= ~(MSG_VIEW_FLAG_ISTHREAD | nsMsgMessageFlags::Elided | MSG_VIEW_FLAG_HASCHILDREN);</span>
<a href="#l15.277"></a><span id="l15.277">           m_flags[threadIndex] = flags;</span>
<a href="#l15.278"></a><span id="l15.278">           NoteChange(threadIndex, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l15.279"></a><span id="l15.279">         }</span>
<a href="#l15.280"></a><span id="l15.280">       }</span>
<a href="#l15.281"></a><span id="l15.281">       </span>
<a href="#l15.282"></a><span id="l15.282">     }</span>
<a href="#l15.283"></a><span id="l15.283">     </span>
<a href="#l15.284"></a><span id="l15.284">     return nsMsgDBView::RemoveByIndex(index);</span>
<a href="#l15.285"></a><span id="l15.285" class="difflineat">@@ -918,24 +918,24 @@ nsresult nsMsgThreadedDBView::RemoveByIn</span>
<a href="#l15.286"></a><span id="l15.286">       //			CopyDBFlagsToExtraFlags(msgHdr-&gt;GetFlags(), &amp;flag);</span>
<a href="#l15.287"></a><span id="l15.287">       //			if (msgHdr-&gt;GetArticleNum() == msgHdr-&gt;GetThreadId())</span>
<a href="#l15.288"></a><span id="l15.288">       flag |= MSG_VIEW_FLAG_ISTHREAD;</span>
<a href="#l15.289"></a><span id="l15.289">       </span>
<a href="#l15.290"></a><span id="l15.290">       if (numThreadChildren == 1)	// if only hdr in thread (with one about to be deleted)</span>
<a href="#l15.291"></a><span id="l15.291">         // adjust flags.</span>
<a href="#l15.292"></a><span id="l15.292">       {</span>
<a href="#l15.293"></a><span id="l15.293">         flag &amp;=  ~MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l15.294"></a><span id="l15.294" class="difflineminus">-        flag &amp;= ~MSG_FLAG_ELIDED;</span>
<a href="#l15.295"></a><span id="l15.295" class="difflineplus">+        flag &amp;= ~nsMsgMessageFlags::Elided;</span>
<a href="#l15.296"></a><span id="l15.296">         // tell FE that thread header needs to be repainted.</span>
<a href="#l15.297"></a><span id="l15.297">         NoteChange(index, 1, nsMsgViewNotificationCode::changed);	</span>
<a href="#l15.298"></a><span id="l15.298">       }</span>
<a href="#l15.299"></a><span id="l15.299">       else</span>
<a href="#l15.300"></a><span id="l15.300">       {</span>
<a href="#l15.301"></a><span id="l15.301">         flag |= MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l15.302"></a><span id="l15.302" class="difflineminus">-        flag |= MSG_FLAG_ELIDED;</span>
<a href="#l15.303"></a><span id="l15.303" class="difflineplus">+        flag |= nsMsgMessageFlags::Elided;</span>
<a href="#l15.304"></a><span id="l15.304">       }</span>
<a href="#l15.305"></a><span id="l15.305">       m_flags[index] = flag;</span>
<a href="#l15.306"></a><span id="l15.306">       mIndicesToNoteChange.RemoveElement(index);</span>
<a href="#l15.307"></a><span id="l15.307">     }</span>
<a href="#l15.308"></a><span id="l15.308">     else</span>
<a href="#l15.309"></a><span id="l15.309">       NS_ASSERTION(PR_FALSE, &quot;couldn't find thread child&quot;);	</span>
<a href="#l15.310"></a><span id="l15.310">     NoteChange(index, 1, nsMsgViewNotificationCode::changed);	</span>
<a href="#l15.311"></a><span id="l15.311">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/mailnews/base/src/nsMsgXFViewThread.cpp</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgXFViewThread.cpp</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -131,21 +131,21 @@ nsresult nsMsgXFViewThread::AddHdr(nsIMs</span>
<a href="#l16.4"></a><span id="l16.4">   nsMsgKey newHdrKey = 0;</span>
<a href="#l16.5"></a><span id="l16.5"> </span>
<a href="#l16.6"></a><span id="l16.6">   newHdr-&gt;GetMessageKey(&amp;newHdrKey);</span>
<a href="#l16.7"></a><span id="l16.7">   newHdr-&gt;GetDateInSeconds(&amp;msgDate);</span>
<a href="#l16.8"></a><span id="l16.8">   newHdr-&gt;GetFlags(&amp;newHdrFlags);</span>
<a href="#l16.9"></a><span id="l16.9">   if (msgDate &gt; m_newestMsgDate)</span>
<a href="#l16.10"></a><span id="l16.10">     SetNewestMsgDate(msgDate);</span>
<a href="#l16.11"></a><span id="l16.11"> </span>
<a href="#l16.12"></a><span id="l16.12" class="difflineminus">-  if (newHdrFlags &amp; MSG_FLAG_WATCHED)</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineminus">-    SetFlags(m_flags | MSG_FLAG_WATCHED);</span>
<a href="#l16.14"></a><span id="l16.14" class="difflineplus">+  if (newHdrFlags &amp; nsMsgMessageFlags::Watched)</span>
<a href="#l16.15"></a><span id="l16.15" class="difflineplus">+    SetFlags(m_flags | nsMsgMessageFlags::Watched);</span>
<a href="#l16.16"></a><span id="l16.16"> </span>
<a href="#l16.17"></a><span id="l16.17">   ChangeChildCount(1);</span>
<a href="#l16.18"></a><span id="l16.18" class="difflineminus">-  if (! (newHdrFlags &amp; MSG_FLAG_READ))</span>
<a href="#l16.19"></a><span id="l16.19" class="difflineplus">+  if (! (newHdrFlags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l16.20"></a><span id="l16.20">     ChangeUnreadChildCount(1);</span>
<a href="#l16.21"></a><span id="l16.21"> </span>
<a href="#l16.22"></a><span id="l16.22">   if (m_numChildren == 1)</span>
<a href="#l16.23"></a><span id="l16.23">   {</span>
<a href="#l16.24"></a><span id="l16.24">     m_keys.InsertElementAt(0, newHdrKey);</span>
<a href="#l16.25"></a><span id="l16.25">     m_levels.InsertElementAt(0, 0);</span>
<a href="#l16.26"></a><span id="l16.26">     m_folders.InsertObjectAt(newHdrFolder, 0);</span>
<a href="#l16.27"></a><span id="l16.27">     if (outParent)</span>
<a href="#l16.28"></a><span id="l16.28" class="difflineat">@@ -272,17 +272,17 @@ nsresult nsMsgXFViewThread::AddHdr(nsIMs</span>
<a href="#l16.29"></a><span id="l16.29"> </span>
<a href="#l16.30"></a><span id="l16.30">   // ### TODO handle the case where the root header starts </span>
<a href="#l16.31"></a><span id="l16.31">   // with Re, and the new one doesn't, and is earlier. In that</span>
<a href="#l16.32"></a><span id="l16.32">   // case, we want to promote the new header to root.</span>
<a href="#l16.33"></a><span id="l16.33"> </span>
<a href="#l16.34"></a><span id="l16.34"> //  PRTime newHdrDate;</span>
<a href="#l16.35"></a><span id="l16.35"> //  newHdr-&gt;GetDate(&amp;newHdrDate);</span>
<a href="#l16.36"></a><span id="l16.36"> </span>
<a href="#l16.37"></a><span id="l16.37" class="difflineminus">-//  if (numChildren &gt; 0 &amp;&amp; !(newHdrFlags &amp; MSG_FLAG_HAS_RE))</span>
<a href="#l16.38"></a><span id="l16.38" class="difflineplus">+//  if (numChildren &gt; 0 &amp;&amp; !(newHdrFlags &amp; nsMsgMessageFlags::HasRe))</span>
<a href="#l16.39"></a><span id="l16.39"> //  {</span>
<a href="#l16.40"></a><span id="l16.40"> //    PRTime topLevelHdrDate;</span>
<a href="#l16.41"></a><span id="l16.41"> </span>
<a href="#l16.42"></a><span id="l16.42"> //    nsCOMPtr&lt;nsIMsgDBHdr&gt; topLevelHdr;</span>
<a href="#l16.43"></a><span id="l16.43"> //    rv = GetRootHdr(nsnull, getter_AddRefs(topLevelHdr));</span>
<a href="#l16.44"></a><span id="l16.44"> //    if (NS_SUCCEEDED(rv) &amp;&amp; topLevelHdr)</span>
<a href="#l16.45"></a><span id="l16.45"> //    {</span>
<a href="#l16.46"></a><span id="l16.46"> //      topLevelHdr-&gt;GetDate(&amp;topLevelHdrDate);</span>
<a href="#l16.47"></a><span id="l16.47" class="difflineat">@@ -342,17 +342,17 @@ NS_IMETHODIMP nsMsgXFViewThread::RemoveC</span>
<a href="#l16.48"></a><span id="l16.48">                i &lt; m_keys.Length() &amp;&amp; m_levels[i] &gt; levelRemoved; i++)</span>
<a href="#l16.49"></a><span id="l16.49">             m_levels[i] = m_levels[i] - 1;</span>
<a href="#l16.50"></a><span id="l16.50"> </span>
<a href="#l16.51"></a><span id="l16.51">       m_view-&gt;NoteChange(childIndex + 1, i - childIndex + 1,</span>
<a href="#l16.52"></a><span id="l16.52">                          nsMsgViewNotificationCode::changed);</span>
<a href="#l16.53"></a><span id="l16.53">       m_keys.RemoveElementAt(childIndex);</span>
<a href="#l16.54"></a><span id="l16.54">       m_levels.RemoveElementAt(childIndex);</span>
<a href="#l16.55"></a><span id="l16.55">       m_folders.RemoveObjectAt(childIndex);</span>
<a href="#l16.56"></a><span id="l16.56" class="difflineminus">-      if (!(msgFlags &amp; MSG_FLAG_READ))</span>
<a href="#l16.57"></a><span id="l16.57" class="difflineplus">+      if (!(msgFlags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l16.58"></a><span id="l16.58">         ChangeUnreadChildCount(-1);</span>
<a href="#l16.59"></a><span id="l16.59">       ChangeChildCount(-1);</span>
<a href="#l16.60"></a><span id="l16.60">       return NS_OK;</span>
<a href="#l16.61"></a><span id="l16.61">     }</span>
<a href="#l16.62"></a><span id="l16.62">   }</span>
<a href="#l16.63"></a><span id="l16.63">   return NS_ERROR_FAILURE;</span>
<a href="#l16.64"></a><span id="l16.64"> }</span>
<a href="#l16.65"></a><span id="l16.65"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -340,33 +340,33 @@ nsMsgXFVirtualFolderDBView::OnSearchDone</span>
<a href="#l17.4"></a><span id="l17.4">   nsresult rv = m_viewFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(dbFolderInfo), getter_AddRefs(virtDatabase));</span>
<a href="#l17.5"></a><span id="l17.5">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l17.6"></a><span id="l17.6">   // count up the number of unread and total messages from the view, and set those in the</span>
<a href="#l17.7"></a><span id="l17.7">   // folder - easier than trying to keep the count up to date in the face of</span>
<a href="#l17.8"></a><span id="l17.8">   // search hits coming in while the user is reading/deleting messages.</span>
<a href="#l17.9"></a><span id="l17.9">   PRUint32 numUnread = 0;</span>
<a href="#l17.10"></a><span id="l17.10">   PRUint32 numTotal = 0;</span>
<a href="#l17.11"></a><span id="l17.11">   for (PRUint32 i = 0; i &lt; m_flags.Length(); i++)</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineminus">-    if (m_flags[i] &amp; MSG_FLAG_ELIDED)</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+    if (m_flags[i] &amp; nsMsgMessageFlags::Elided)</span>
<a href="#l17.14"></a><span id="l17.14">     {</span>
<a href="#l17.15"></a><span id="l17.15">       nsCOMPtr&lt;nsIMsgThread&gt; thread;</span>
<a href="#l17.16"></a><span id="l17.16">       GetThreadContainingIndex(i, getter_AddRefs(thread));</span>
<a href="#l17.17"></a><span id="l17.17">       if (thread)</span>
<a href="#l17.18"></a><span id="l17.18">       {</span>
<a href="#l17.19"></a><span id="l17.19">         PRUint32 totalInThread, unreadInThread;</span>
<a href="#l17.20"></a><span id="l17.20">         thread-&gt;GetNumUnreadChildren(&amp;unreadInThread);</span>
<a href="#l17.21"></a><span id="l17.21">         thread-&gt;GetNumChildren(&amp;totalInThread);</span>
<a href="#l17.22"></a><span id="l17.22">         numTotal += totalInThread;</span>
<a href="#l17.23"></a><span id="l17.23">         numUnread += unreadInThread;</span>
<a href="#l17.24"></a><span id="l17.24">       }</span>
<a href="#l17.25"></a><span id="l17.25">     }</span>
<a href="#l17.26"></a><span id="l17.26">     else</span>
<a href="#l17.27"></a><span id="l17.27">     {</span>
<a href="#l17.28"></a><span id="l17.28">       numTotal++;</span>
<a href="#l17.29"></a><span id="l17.29" class="difflineminus">-      if (!(m_flags[i] &amp; MSG_FLAG_READ))</span>
<a href="#l17.30"></a><span id="l17.30" class="difflineplus">+      if (!(m_flags[i] &amp; nsMsgMessageFlags::Read))</span>
<a href="#l17.31"></a><span id="l17.31">         numUnread++;</span>
<a href="#l17.32"></a><span id="l17.32">     }</span>
<a href="#l17.33"></a><span id="l17.33">   dbFolderInfo-&gt;SetNumUnreadMessages(numUnread);</span>
<a href="#l17.34"></a><span id="l17.34">   dbFolderInfo-&gt;SetNumMessages(numTotal);</span>
<a href="#l17.35"></a><span id="l17.35">   m_viewFolder-&gt;UpdateSummaryTotals(true); // force update from db.</span>
<a href="#l17.36"></a><span id="l17.36">   virtDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l17.37"></a><span id="l17.37">   if (!m_sortValid &amp;&amp; m_sortType != nsMsgViewSortType::byThread &amp;&amp; </span>
<a href="#l17.38"></a><span id="l17.38">       !(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/mailnews/base/util/nsMsgDBFolder.cpp</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgDBFolder.cpp</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -201,25 +201,25 @@ nsMsgDBFolder::nsMsgDBFolder(void)</span>
<a href="#l18.4"></a><span id="l18.4">     initializeStrings();</span>
<a href="#l18.5"></a><span id="l18.5">     createCollationKeyGenerator();</span>
<a href="#l18.6"></a><span id="l18.6"> #ifdef MSG_FASTER_URI_PARSING</span>
<a href="#l18.7"></a><span id="l18.7">     mParsingURL = do_CreateInstance(NS_STANDARDURL_CONTRACTID);</span>
<a href="#l18.8"></a><span id="l18.8"> #endif</span>
<a href="#l18.9"></a><span id="l18.9">     LL_I2L(gtimeOfLastPurgeCheck, 0);</span>
<a href="#l18.10"></a><span id="l18.10">   }</span>
<a href="#l18.11"></a><span id="l18.11"> </span>
<a href="#l18.12"></a><span id="l18.12" class="difflineminus">-  mProcessingFlag[0].bit = MSG_PROCESSING_FLAG_CLASSIFY_JUNK;</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineminus">-  mProcessingFlag[1].bit = MSG_PROCESSING_FLAG_CLASSIFY_TRAITS;</span>
<a href="#l18.14"></a><span id="l18.14" class="difflineminus">-  for (PRUint32 i = 0; i &lt; MSG_NUMBER_OF_PROCESSING_FLAGS; i++)</span>
<a href="#l18.15"></a><span id="l18.15" class="difflineplus">+  mProcessingFlag[0].bit = nsMsgProcessingFlags::ClassifyJunk;</span>
<a href="#l18.16"></a><span id="l18.16" class="difflineplus">+  mProcessingFlag[1].bit = nsMsgProcessingFlags::ClassifyTraits;</span>
<a href="#l18.17"></a><span id="l18.17" class="difflineplus">+  for (PRUint32 i = 0; i &lt; nsMsgProcessingFlags::NumberOfFlags; i++)</span>
<a href="#l18.18"></a><span id="l18.18">     mProcessingFlag[i].keys = nsMsgKeySetU::Create();</span>
<a href="#l18.19"></a><span id="l18.19"> }</span>
<a href="#l18.20"></a><span id="l18.20"> </span>
<a href="#l18.21"></a><span id="l18.21"> nsMsgDBFolder::~nsMsgDBFolder(void)</span>
<a href="#l18.22"></a><span id="l18.22"> {</span>
<a href="#l18.23"></a><span id="l18.23" class="difflineminus">-  for (PRUint32 i = 0; i &lt; MSG_NUMBER_OF_PROCESSING_FLAGS; i++)</span>
<a href="#l18.24"></a><span id="l18.24" class="difflineplus">+  for (PRUint32 i = 0; i &lt; nsMsgProcessingFlags::NumberOfFlags; i++)</span>
<a href="#l18.25"></a><span id="l18.25">     delete mProcessingFlag[i].keys;</span>
<a href="#l18.26"></a><span id="l18.26"> </span>
<a href="#l18.27"></a><span id="l18.27">   if (--mInstanceCount == 0) {</span>
<a href="#l18.28"></a><span id="l18.28">     NS_IF_RELEASE(gCollationKeyGenerator);</span>
<a href="#l18.29"></a><span id="l18.29">     NS_Free(kLocalizedInboxName);</span>
<a href="#l18.30"></a><span id="l18.30">     NS_Free(kLocalizedTrashName);</span>
<a href="#l18.31"></a><span id="l18.31">     NS_Free(kLocalizedSentName);</span>
<a href="#l18.32"></a><span id="l18.32">     NS_Free(kLocalizedDraftsName);</span>
<a href="#l18.33"></a><span id="l18.33" class="difflineat">@@ -712,26 +712,26 @@ nsresult nsMsgDBFolder::ReadDBFolderInfo</span>
<a href="#l18.34"></a><span id="l18.34">   }</span>
<a href="#l18.35"></a><span id="l18.35">   return result;</span>
<a href="#l18.36"></a><span id="l18.36"> }</span>
<a href="#l18.37"></a><span id="l18.37"> </span>
<a href="#l18.38"></a><span id="l18.38"> nsresult nsMsgDBFolder::SendFlagNotifications(nsIMsgDBHdr *item, PRUint32 oldFlags, PRUint32 newFlags)</span>
<a href="#l18.39"></a><span id="l18.39"> {</span>
<a href="#l18.40"></a><span id="l18.40">   nsresult rv = NS_OK;</span>
<a href="#l18.41"></a><span id="l18.41">   PRUint32 changedFlags = oldFlags ^ newFlags;</span>
<a href="#l18.42"></a><span id="l18.42" class="difflineminus">-  if((changedFlags &amp; MSG_FLAG_READ)  &amp;&amp; (changedFlags &amp; MSG_FLAG_NEW))</span>
<a href="#l18.43"></a><span id="l18.43" class="difflineplus">+  if((changedFlags &amp; nsMsgMessageFlags::Read)  &amp;&amp; (changedFlags &amp; nsMsgMessageFlags::New))</span>
<a href="#l18.44"></a><span id="l18.44">   {</span>
<a href="#l18.45"></a><span id="l18.45">     //..so..if the msg is read in the folder and the folder has new msgs clear the account level and status bar biffs.</span>
<a href="#l18.46"></a><span id="l18.46">     rv = NotifyPropertyFlagChanged(item, kStatusAtom, oldFlags, newFlags);</span>
<a href="#l18.47"></a><span id="l18.47">     rv = SetBiffState(nsMsgBiffState_NoMail);</span>
<a href="#l18.48"></a><span id="l18.48">   }</span>
<a href="#l18.49"></a><span id="l18.49" class="difflineminus">-  else if(changedFlags &amp; (MSG_FLAG_READ | MSG_FLAG_REPLIED | MSG_FLAG_FORWARDED</span>
<a href="#l18.50"></a><span id="l18.50" class="difflineminus">-    | MSG_FLAG_IMAP_DELETED | MSG_FLAG_NEW | MSG_FLAG_OFFLINE))</span>
<a href="#l18.51"></a><span id="l18.51" class="difflineplus">+  else if(changedFlags &amp; (nsMsgMessageFlags::Read | nsMsgMessageFlags::Replied | nsMsgMessageFlags::Forwarded</span>
<a href="#l18.52"></a><span id="l18.52" class="difflineplus">+    | nsMsgMessageFlags::IMAPDeleted | nsMsgMessageFlags::New | nsMsgMessageFlags::Offline))</span>
<a href="#l18.53"></a><span id="l18.53">     rv = NotifyPropertyFlagChanged(item, kStatusAtom, oldFlags, newFlags);</span>
<a href="#l18.54"></a><span id="l18.54" class="difflineminus">-  else if((changedFlags &amp; MSG_FLAG_MARKED))</span>
<a href="#l18.55"></a><span id="l18.55" class="difflineplus">+  else if((changedFlags &amp; nsMsgMessageFlags::Marked))</span>
<a href="#l18.56"></a><span id="l18.56">     rv = NotifyPropertyFlagChanged(item, kFlaggedAtom, oldFlags, newFlags);</span>
<a href="#l18.57"></a><span id="l18.57">   return rv;</span>
<a href="#l18.58"></a><span id="l18.58"> }</span>
<a href="#l18.59"></a><span id="l18.59"> </span>
<a href="#l18.60"></a><span id="l18.60"> NS_IMETHODIMP nsMsgDBFolder::DownloadMessagesForOffline(nsIArray *messages, nsIMsgWindow *)</span>
<a href="#l18.61"></a><span id="l18.61"> {</span>
<a href="#l18.62"></a><span id="l18.62">   NS_ASSERTION(PR_FALSE, &quot;imap and news need to override this&quot;);</span>
<a href="#l18.63"></a><span id="l18.63">   return NS_OK;</span>
<a href="#l18.64"></a><span id="l18.64" class="difflineat">@@ -968,20 +968,20 @@ NS_IMETHODIMP nsMsgDBFolder::OnHdrFlagsC</span>
<a href="#l18.65"></a><span id="l18.65">   if(aHdrChanged)</span>
<a href="#l18.66"></a><span id="l18.66">   {</span>
<a href="#l18.67"></a><span id="l18.67">     SendFlagNotifications(aHdrChanged, aOldFlags, aNewFlags);</span>
<a href="#l18.68"></a><span id="l18.68">     UpdateSummaryTotals(PR_TRUE);</span>
<a href="#l18.69"></a><span id="l18.69">   }</span>
<a href="#l18.70"></a><span id="l18.70"> </span>
<a href="#l18.71"></a><span id="l18.71">   // The old state was new message state</span>
<a href="#l18.72"></a><span id="l18.72">   // We check and see if this state has changed</span>
<a href="#l18.73"></a><span id="l18.73" class="difflineminus">-  if(aOldFlags &amp; MSG_FLAG_NEW)</span>
<a href="#l18.74"></a><span id="l18.74" class="difflineplus">+  if(aOldFlags &amp; nsMsgMessageFlags::New)</span>
<a href="#l18.75"></a><span id="l18.75">   {</span>
<a href="#l18.76"></a><span id="l18.76">     // state changing from new to something else</span>
<a href="#l18.77"></a><span id="l18.77" class="difflineminus">-    if (!(aNewFlags  &amp; MSG_FLAG_NEW))</span>
<a href="#l18.78"></a><span id="l18.78" class="difflineplus">+    if (!(aNewFlags  &amp; nsMsgMessageFlags::New))</span>
<a href="#l18.79"></a><span id="l18.79">       CheckWithNewMessagesStatus(PR_FALSE);</span>
<a href="#l18.80"></a><span id="l18.80">   }</span>
<a href="#l18.81"></a><span id="l18.81"> </span>
<a href="#l18.82"></a><span id="l18.82">   return NS_OK;</span>
<a href="#l18.83"></a><span id="l18.83"> }</span>
<a href="#l18.84"></a><span id="l18.84"> </span>
<a href="#l18.85"></a><span id="l18.85"> nsresult nsMsgDBFolder::CheckWithNewMessagesStatus(PRBool messageAdded)</span>
<a href="#l18.86"></a><span id="l18.86"> {</span>
<a href="#l18.87"></a><span id="l18.87" class="difflineat">@@ -1012,17 +1012,17 @@ NS_IMETHODIMP nsMsgDBFolder::OnHdrDelete</span>
<a href="#l18.88"></a><span id="l18.88">   CheckWithNewMessagesStatus(PR_FALSE);</span>
<a href="#l18.89"></a><span id="l18.89">   return OnHdrAddedOrDeleted(aHdrChanged, PR_FALSE);</span>
<a href="#l18.90"></a><span id="l18.90"> }</span>
<a href="#l18.91"></a><span id="l18.91"> </span>
<a href="#l18.92"></a><span id="l18.92"> // 2.  When a new messages gets added, we need to see if it's new.</span>
<a href="#l18.93"></a><span id="l18.93"> NS_IMETHODIMP nsMsgDBFolder::OnHdrAdded(nsIMsgDBHdr *aHdrChanged, nsMsgKey  aParentKey , PRInt32 aFlags,</span>
<a href="#l18.94"></a><span id="l18.94">                         nsIDBChangeListener * aInstigator)</span>
<a href="#l18.95"></a><span id="l18.95"> {</span>
<a href="#l18.96"></a><span id="l18.96" class="difflineminus">-  if(aFlags &amp; MSG_FLAG_NEW)</span>
<a href="#l18.97"></a><span id="l18.97" class="difflineplus">+  if(aFlags &amp; nsMsgMessageFlags::New)</span>
<a href="#l18.98"></a><span id="l18.98">     CheckWithNewMessagesStatus(PR_TRUE);</span>
<a href="#l18.99"></a><span id="l18.99">   return OnHdrAddedOrDeleted(aHdrChanged, PR_TRUE);</span>
<a href="#l18.100"></a><span id="l18.100"> }</span>
<a href="#l18.101"></a><span id="l18.101"> </span>
<a href="#l18.102"></a><span id="l18.102"> nsresult nsMsgDBFolder::OnHdrAddedOrDeleted(nsIMsgDBHdr *aHdrChanged, PRBool added)</span>
<a href="#l18.103"></a><span id="l18.103"> {</span>
<a href="#l18.104"></a><span id="l18.104">   if(added)</span>
<a href="#l18.105"></a><span id="l18.105">     NotifyItemAdded(aHdrChanged);</span>
<a href="#l18.106"></a><span id="l18.106" class="difflineat">@@ -1087,17 +1087,17 @@ nsresult nsMsgDBFolder::MsgFitsDownloadC</span>
<a href="#l18.107"></a><span id="l18.107">   if(NS_FAILED(rv))</span>
<a href="#l18.108"></a><span id="l18.108">     return rv;</span>
<a href="#l18.109"></a><span id="l18.109"> </span>
<a href="#l18.110"></a><span id="l18.110">   if (hdr)</span>
<a href="#l18.111"></a><span id="l18.111">   {</span>
<a href="#l18.112"></a><span id="l18.112">     PRUint32 msgFlags = 0;</span>
<a href="#l18.113"></a><span id="l18.113">     hdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l18.114"></a><span id="l18.114">     // check if we already have this message body offline</span>
<a href="#l18.115"></a><span id="l18.115" class="difflineminus">-    if (! (msgFlags &amp; MSG_FLAG_OFFLINE))</span>
<a href="#l18.116"></a><span id="l18.116" class="difflineplus">+    if (! (msgFlags &amp; nsMsgMessageFlags::Offline))</span>
<a href="#l18.117"></a><span id="l18.117">     {</span>
<a href="#l18.118"></a><span id="l18.118">       *result = PR_TRUE;</span>
<a href="#l18.119"></a><span id="l18.119">       // check against the server download size limit .</span>
<a href="#l18.120"></a><span id="l18.120">       nsCOMPtr &lt;nsIMsgIncomingServer&gt; incomingServer;</span>
<a href="#l18.121"></a><span id="l18.121">       rv = GetServer(getter_AddRefs(incomingServer));</span>
<a href="#l18.122"></a><span id="l18.122">       if (NS_SUCCEEDED(rv) &amp;&amp; incomingServer)</span>
<a href="#l18.123"></a><span id="l18.123">       {</span>
<a href="#l18.124"></a><span id="l18.124">         PRBool limitDownloadSize = PR_FALSE;</span>
<a href="#l18.125"></a><span id="l18.125" class="difflineat">@@ -1165,17 +1165,17 @@ NS_IMETHODIMP nsMsgDBFolder::HasMsgOffli</span>
<a href="#l18.126"></a><span id="l18.126">   if(NS_FAILED(rv))</span>
<a href="#l18.127"></a><span id="l18.127">     return rv;</span>
<a href="#l18.128"></a><span id="l18.128"> </span>
<a href="#l18.129"></a><span id="l18.129">   if (hdr)</span>
<a href="#l18.130"></a><span id="l18.130">   {</span>
<a href="#l18.131"></a><span id="l18.131">     PRUint32 msgFlags = 0;</span>
<a href="#l18.132"></a><span id="l18.132">     hdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l18.133"></a><span id="l18.133">     // check if we already have this message body offline</span>
<a href="#l18.134"></a><span id="l18.134" class="difflineminus">-    if ((msgFlags &amp; MSG_FLAG_OFFLINE))</span>
<a href="#l18.135"></a><span id="l18.135" class="difflineplus">+    if ((msgFlags &amp; nsMsgMessageFlags::Offline))</span>
<a href="#l18.136"></a><span id="l18.136">       *result = PR_TRUE;</span>
<a href="#l18.137"></a><span id="l18.137">   }</span>
<a href="#l18.138"></a><span id="l18.138">   return NS_OK;</span>
<a href="#l18.139"></a><span id="l18.139"> }</span>
<a href="#l18.140"></a><span id="l18.140"> </span>
<a href="#l18.141"></a><span id="l18.141"> </span>
<a href="#l18.142"></a><span id="l18.142"> NS_IMETHODIMP nsMsgDBFolder::GetFlags(PRUint32 *_retval)</span>
<a href="#l18.143"></a><span id="l18.143"> {</span>
<a href="#l18.144"></a><span id="l18.144" class="difflineat">@@ -2180,19 +2180,19 @@ nsMsgDBFolder::CallFilterPlugins(nsIMsgW</span>
<a href="#l18.145"></a><span id="l18.145">       }</span>
<a href="#l18.146"></a><span id="l18.146">       filterMessageForJunk = PR_TRUE;</span>
<a href="#l18.147"></a><span id="l18.147">       break;</span>
<a href="#l18.148"></a><span id="l18.148">     }</span>
<a href="#l18.149"></a><span id="l18.149">     if (filterMessageForJunk || filterForOther)</span>
<a href="#l18.150"></a><span id="l18.150">     {</span>
<a href="#l18.151"></a><span id="l18.151">       keysToClassify.AppendElement(newMessageKeys[i]);</span>
<a href="#l18.152"></a><span id="l18.152">       if (filterMessageForJunk)</span>
<a href="#l18.153"></a><span id="l18.153" class="difflineminus">-        OrProcessingFlags(msgKey, MSG_PROCESSING_FLAG_CLASSIFY_JUNK);</span>
<a href="#l18.154"></a><span id="l18.154" class="difflineplus">+        OrProcessingFlags(msgKey, nsMsgProcessingFlags::ClassifyJunk);</span>
<a href="#l18.155"></a><span id="l18.155">       if (filterForOther)</span>
<a href="#l18.156"></a><span id="l18.156" class="difflineminus">-        OrProcessingFlags(msgKey, MSG_PROCESSING_FLAG_CLASSIFY_TRAITS);</span>
<a href="#l18.157"></a><span id="l18.157" class="difflineplus">+        OrProcessingFlags(msgKey, nsMsgProcessingFlags::ClassifyTraits);</span>
<a href="#l18.158"></a><span id="l18.158">     }</span>
<a href="#l18.159"></a><span id="l18.159">   }</span>
<a href="#l18.160"></a><span id="l18.160"> </span>
<a href="#l18.161"></a><span id="l18.161">   if (!keysToClassify.IsEmpty())</span>
<a href="#l18.162"></a><span id="l18.162">   {</span>
<a href="#l18.163"></a><span id="l18.163">     PRUint32 numMessagesToClassify = keysToClassify.Length();</span>
<a href="#l18.164"></a><span id="l18.164">     char ** messageURIs = (char **) PR_MALLOC(sizeof(const char *) * numMessagesToClassify);</span>
<a href="#l18.165"></a><span id="l18.165">     if (!messageURIs)</span>
<a href="#l18.166"></a><span id="l18.166" class="difflineat">@@ -5364,33 +5364,33 @@ NS_IMETHODIMP nsMsgDBFolder::GetCustomId</span>
<a href="#l18.167"></a><span id="l18.167">   *aIdentity = nsnull;</span>
<a href="#l18.168"></a><span id="l18.168">   return NS_OK;</span>
<a href="#l18.169"></a><span id="l18.169"> }</span>
<a href="#l18.170"></a><span id="l18.170"> </span>
<a href="#l18.171"></a><span id="l18.171"> NS_IMETHODIMP nsMsgDBFolder::GetProcessingFlags(nsMsgKey aKey, PRUint32 *aFlags)</span>
<a href="#l18.172"></a><span id="l18.172"> {</span>
<a href="#l18.173"></a><span id="l18.173">   NS_ENSURE_ARG_POINTER(aFlags);</span>
<a href="#l18.174"></a><span id="l18.174">   *aFlags = 0;</span>
<a href="#l18.175"></a><span id="l18.175" class="difflineminus">-  for (PRUint32 i = 0; i &lt; MSG_NUMBER_OF_PROCESSING_FLAGS; i++)</span>
<a href="#l18.176"></a><span id="l18.176" class="difflineplus">+  for (PRUint32 i = 0; i &lt; nsMsgProcessingFlags::NumberOfFlags; i++)</span>
<a href="#l18.177"></a><span id="l18.177">     if (mProcessingFlag[i].keys &amp;&amp; mProcessingFlag[i].keys-&gt;IsMember(aKey))</span>
<a href="#l18.178"></a><span id="l18.178">       *aFlags |= mProcessingFlag[i].bit;</span>
<a href="#l18.179"></a><span id="l18.179">   return NS_OK;</span>
<a href="#l18.180"></a><span id="l18.180"> }  </span>
<a href="#l18.181"></a><span id="l18.181"> </span>
<a href="#l18.182"></a><span id="l18.182"> NS_IMETHODIMP nsMsgDBFolder::OrProcessingFlags(nsMsgKey aKey, PRUint32 mask)</span>
<a href="#l18.183"></a><span id="l18.183"> {</span>
<a href="#l18.184"></a><span id="l18.184" class="difflineminus">-  for (PRUint32 i = 0; i &lt; MSG_NUMBER_OF_PROCESSING_FLAGS; i++)</span>
<a href="#l18.185"></a><span id="l18.185" class="difflineplus">+  for (PRUint32 i = 0; i &lt; nsMsgProcessingFlags::NumberOfFlags; i++)</span>
<a href="#l18.186"></a><span id="l18.186">     if (mProcessingFlag[i].bit &amp; mask &amp;&amp; mProcessingFlag[i].keys)</span>
<a href="#l18.187"></a><span id="l18.187">       mProcessingFlag[i].keys-&gt;Add(aKey);</span>
<a href="#l18.188"></a><span id="l18.188">   return NS_OK;</span>
<a href="#l18.189"></a><span id="l18.189"> }  </span>
<a href="#l18.190"></a><span id="l18.190"> </span>
<a href="#l18.191"></a><span id="l18.191"> NS_IMETHODIMP nsMsgDBFolder::AndProcessingFlags(nsMsgKey aKey, PRUint32 mask)</span>
<a href="#l18.192"></a><span id="l18.192"> {</span>
<a href="#l18.193"></a><span id="l18.193" class="difflineminus">-  for (PRUint32 i = 0; i &lt; MSG_NUMBER_OF_PROCESSING_FLAGS; i++)</span>
<a href="#l18.194"></a><span id="l18.194" class="difflineplus">+  for (PRUint32 i = 0; i &lt; nsMsgProcessingFlags::NumberOfFlags; i++)</span>
<a href="#l18.195"></a><span id="l18.195">     if (!(mProcessingFlag[i].bit &amp; mask) &amp;&amp; mProcessingFlag[i].keys)</span>
<a href="#l18.196"></a><span id="l18.196">       mProcessingFlag[i].keys-&gt;Remove(aKey);</span>
<a href="#l18.197"></a><span id="l18.197">   return NS_OK;</span>
<a href="#l18.198"></a><span id="l18.198"> }</span>
<a href="#l18.199"></a><span id="l18.199"> </span>
<a href="#l18.200"></a><span id="l18.200"> /* static */ nsMsgKeySetU* nsMsgKeySetU::Create()</span>
<a href="#l18.201"></a><span id="l18.201"> {</span>
<a href="#l18.202"></a><span id="l18.202">   nsMsgKeySetU* set = new nsMsgKeySetU;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/mailnews/base/util/nsMsgDBFolder.h</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgDBFolder.h</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -153,17 +153,17 @@ protected:</span>
<a href="#l19.4"></a><span id="l19.4">   static PRBool PromptForMasterPasswordIfNecessary();</span>
<a href="#l19.5"></a><span id="l19.5"> </span>
<a href="#l19.6"></a><span id="l19.6">   // offline support methods.</span>
<a href="#l19.7"></a><span id="l19.7">   nsresult StartNewOfflineMessage();</span>
<a href="#l19.8"></a><span id="l19.8">   nsresult WriteStartOfNewLocalMessage();</span>
<a href="#l19.9"></a><span id="l19.9">   nsresult EndNewOfflineMessage();</span>
<a href="#l19.10"></a><span id="l19.10">   nsresult CompactOfflineStore(nsIMsgWindow *inWindow, nsIUrlListener *aUrlListener);</span>
<a href="#l19.11"></a><span id="l19.11">   nsresult AutoCompact(nsIMsgWindow *aWindow);</span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-  // this is a helper routine that ignores whether MSG_FLAG_OFFLINE is set for the folder</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+  // this is a helper routine that ignores whether nsMsgMessageFlags::Offline is set for the folder</span>
<a href="#l19.14"></a><span id="l19.14">   nsresult MsgFitsDownloadCriteria(nsMsgKey msgKey, PRBool *result);</span>
<a href="#l19.15"></a><span id="l19.15">   nsresult GetPromptPurgeThreshold(PRBool *aPrompt);</span>
<a href="#l19.16"></a><span id="l19.16">   nsresult GetPurgeThreshold(PRInt32 *aThreshold);</span>
<a href="#l19.17"></a><span id="l19.17">   nsresult ApplyRetentionSettings(PRBool deleteViaFolder);</span>
<a href="#l19.18"></a><span id="l19.18"> </span>
<a href="#l19.19"></a><span id="l19.19">   nsresult PerformBiffNotifications(void); // if there are new, non spam messages, do biff</span>
<a href="#l19.20"></a><span id="l19.20">   nsresult CloseDBIfFolderNotOpen();</span>
<a href="#l19.21"></a><span id="l19.21"> </span>
<a href="#l19.22"></a><span id="l19.22" class="difflineat">@@ -286,17 +286,17 @@ protected:</span>
<a href="#l19.23"></a><span id="l19.23"> </span>
<a href="#l19.24"></a><span id="l19.24">   static const NS_MSG_BASE_STATIC_MEMBER_(nsStaticAtom) folder_atoms[];</span>
<a href="#l19.25"></a><span id="l19.25"> </span>
<a href="#l19.26"></a><span id="l19.26">   // store of keys that have a processing flag set</span>
<a href="#l19.27"></a><span id="l19.27">   struct</span>
<a href="#l19.28"></a><span id="l19.28">   {</span>
<a href="#l19.29"></a><span id="l19.29">     PRUint32 bit;</span>
<a href="#l19.30"></a><span id="l19.30">     nsMsgKeySetU* keys;</span>
<a href="#l19.31"></a><span id="l19.31" class="difflineminus">-  } mProcessingFlag[MSG_NUMBER_OF_PROCESSING_FLAGS];</span>
<a href="#l19.32"></a><span id="l19.32" class="difflineplus">+  } mProcessingFlag[nsMsgProcessingFlags::NumberOfFlags];</span>
<a href="#l19.33"></a><span id="l19.33"> };</span>
<a href="#l19.34"></a><span id="l19.34"> </span>
<a href="#l19.35"></a><span id="l19.35"> // This class is a kludge to allow nsMsgKeySet to be used with PRUint32 keys</span>
<a href="#l19.36"></a><span id="l19.36"> class nsMsgKeySetU</span>
<a href="#l19.37"></a><span id="l19.37"> {</span>
<a href="#l19.38"></a><span id="l19.38"> public:</span>
<a href="#l19.39"></a><span id="l19.39">     // Creates an empty set.</span>
<a href="#l19.40"></a><span id="l19.40">   static nsMsgKeySetU* Create();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/mailnews/base/util/nsMsgTxn.cpp</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgTxn.cpp</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -328,13 +328,13 @@ nsMsgTxn::CheckForToggleDelete(nsIMsgFol</span>
<a href="#l20.4"></a><span id="l20.4">     rv = db-&gt;ContainsKey(aMsgKey, &amp;containsKey);</span>
<a href="#l20.5"></a><span id="l20.5">     if (NS_FAILED(rv) || !containsKey)   // the message has been deleted from db, so we cannot do toggle here</span>
<a href="#l20.6"></a><span id="l20.6">       return NS_OK;</span>
<a href="#l20.7"></a><span id="l20.7">     rv = db-&gt;GetMsgHdrForKey(aMsgKey, getter_AddRefs(message));</span>
<a href="#l20.8"></a><span id="l20.8">     PRUint32 flags;</span>
<a href="#l20.9"></a><span id="l20.9">     if (NS_SUCCEEDED(rv) &amp;&amp; message)</span>
<a href="#l20.10"></a><span id="l20.10">     {</span>
<a href="#l20.11"></a><span id="l20.11">       message-&gt;GetFlags(&amp;flags);</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineminus">-      *aResult = (flags &amp; MSG_FLAG_IMAP_DELETED) != 0;</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+      *aResult = (flags &amp; nsMsgMessageFlags::IMAPDeleted) != 0;</span>
<a href="#l20.14"></a><span id="l20.14">     }</span>
<a href="#l20.15"></a><span id="l20.15">   }</span>
<a href="#l20.16"></a><span id="l20.16">   return rv;</span>
<a href="#l20.17"></a><span id="l20.17"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/mailnews/compose/src/nsMsgCompose.cpp</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/mailnews/compose/src/nsMsgCompose.cpp</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -1986,17 +1986,17 @@ nsresult nsMsgCompose::CreateMessage(con</span>
<a href="#l21.4"></a><span id="l21.4">             mWhatHolder = 1;</span>
<a href="#l21.5"></a><span id="l21.5">             break;</span>
<a href="#l21.6"></a><span id="l21.6">           }</span>
<a href="#l21.7"></a><span id="l21.7">         case nsIMsgCompType::ForwardAsAttachment:</span>
<a href="#l21.8"></a><span id="l21.8">           {</span>
<a href="#l21.9"></a><span id="l21.9">             PRUint32 flags;</span>
<a href="#l21.10"></a><span id="l21.10"> </span>
<a href="#l21.11"></a><span id="l21.11">             msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-            if (flags &amp; MSG_FLAG_HAS_RE)</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+            if (flags &amp; nsMsgMessageFlags::HasRe)</span>
<a href="#l21.14"></a><span id="l21.14">               subject.Insert(NS_LITERAL_STRING(&quot;Re: &quot;), 0);</span>
<a href="#l21.15"></a><span id="l21.15"> </span>
<a href="#l21.16"></a><span id="l21.16">             // Setup quoting callbacks for later...</span>
<a href="#l21.17"></a><span id="l21.17">             mQuotingToFollow = PR_FALSE;  //We don't need to quote the original message.</span>
<a href="#l21.18"></a><span id="l21.18">             nsCOMPtr&lt;nsIMsgAttachment&gt; attachment = do_CreateInstance(NS_MSGATTACHMENT_CONTRACTID, &amp;rv);</span>
<a href="#l21.19"></a><span id="l21.19">             if (NS_SUCCEEDED(rv) &amp;&amp; attachment)</span>
<a href="#l21.20"></a><span id="l21.20">             {</span>
<a href="#l21.21"></a><span id="l21.21">               PRBool addExtension = PR_TRUE;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/mailnews/compose/src/nsMsgCopy.cpp</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/mailnews/compose/src/nsMsgCopy.cpp</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -301,17 +301,17 @@ nsMsgCopy::DoCopy(nsIFile *aDiskFile, ns</span>
<a href="#l22.4"></a><span id="l22.4">             copyListener-&gt;mCopyInProgress = PR_TRUE;</span>
<a href="#l22.5"></a><span id="l22.5">             NS_GetCurrentThread(getter_AddRefs(thread));</span>
<a href="#l22.6"></a><span id="l22.6">         }</span>
<a href="#l22.7"></a><span id="l22.7">     }</span>
<a href="#l22.8"></a><span id="l22.8">     nsCOMPtr&lt;nsIMsgCopyService&gt; copyService = do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l22.9"></a><span id="l22.9">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l22.10"></a><span id="l22.10"> </span>
<a href="#l22.11"></a><span id="l22.11">     rv = copyService-&gt;CopyFileMessage(aDiskFile, dstFolder, aMsgToReplace,</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineminus">-                                      aIsDraft, MSG_FLAG_READ, EmptyCString(),</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+                                      aIsDraft, nsMsgMessageFlags::Read, EmptyCString(),</span>
<a href="#l22.14"></a><span id="l22.14">                                       copyListener, msgWindow);</span>
<a href="#l22.15"></a><span id="l22.15">     // copyListener-&gt;mCopyInProgress can only be set when we are in the</span>
<a href="#l22.16"></a><span id="l22.16">     // middle of the shutdown process</span>
<a href="#l22.17"></a><span id="l22.17">     while (copyListener-&gt;mCopyInProgress)</span>
<a href="#l22.18"></a><span id="l22.18">     {</span>
<a href="#l22.19"></a><span id="l22.19">         PR_CEnterMonitor(copyListener);</span>
<a href="#l22.20"></a><span id="l22.20">         PR_CWait(copyListener, PR_MicrosecondsToInterval(1000UL));</span>
<a href="#l22.21"></a><span id="l22.21">         PR_CExitMonitor(copyListener);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/mailnews/compose/src/nsMsgSend.cpp</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/mailnews/compose/src/nsMsgSend.cpp</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -4681,17 +4681,17 @@ nsMsgComposeAndSend::MimeDoFCC(nsIFile  </span>
<a href="#l23.4"></a><span id="l23.4">       goto FAIL;</span>
<a href="#l23.5"></a><span id="l23.5">     }</span>
<a href="#l23.6"></a><span id="l23.6">   }</span>
<a href="#l23.7"></a><span id="l23.7"> </span>
<a href="#l23.8"></a><span id="l23.8">   //</span>
<a href="#l23.9"></a><span id="l23.9">   // Write out an X-Mozilla-Status header.</span>
<a href="#l23.10"></a><span id="l23.10">   //</span>
<a href="#l23.11"></a><span id="l23.11">   // This is required for the queue file, so that we can overwrite it once</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-  // the messages have been delivered, and so that the MSG_FLAG_QUEUED bit</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+  // the messages have been delivered, and so that the nsMsgMessageFlags::Queued bit</span>
<a href="#l23.14"></a><span id="l23.14">   // is set.</span>
<a href="#l23.15"></a><span id="l23.15">   //</span>
<a href="#l23.16"></a><span id="l23.16">   // For FCC files, we don't necessarily need one, but we might as well put</span>
<a href="#l23.17"></a><span id="l23.17">   // one in so that it's marked as read already.</span>
<a href="#l23.18"></a><span id="l23.18">   //</span>
<a href="#l23.19"></a><span id="l23.19">   //</span>
<a href="#l23.20"></a><span id="l23.20">   // Need to add these lines for POP3 ONLY! IMAP servers will handle</span>
<a href="#l23.21"></a><span id="l23.21">   // this status information for summary file regeneration for us.</span>
<a href="#l23.22"></a><span id="l23.22" class="difflineat">@@ -4700,39 +4700,39 @@ nsMsgComposeAndSend::MimeDoFCC(nsIFile  </span>
<a href="#l23.23"></a><span id="l23.23">         mode == nsMsgSendUnsent) &amp;&amp; folderIsLocal)</span>
<a href="#l23.24"></a><span id="l23.24">   {</span>
<a href="#l23.25"></a><span id="l23.25">     char       *buf = 0;</span>
<a href="#l23.26"></a><span id="l23.26">     PRUint16   flags = 0;</span>
<a href="#l23.27"></a><span id="l23.27"> </span>
<a href="#l23.28"></a><span id="l23.28">     // for save as draft and send later, we want to leave the message as unread.</span>
<a href="#l23.29"></a><span id="l23.29">     // See Bug #198087</span>
<a href="#l23.30"></a><span id="l23.30">     if (mode == nsMsgQueueForLater)</span>
<a href="#l23.31"></a><span id="l23.31" class="difflineminus">-      flags |= MSG_FLAG_QUEUED;</span>
<a href="#l23.32"></a><span id="l23.32" class="difflineplus">+      flags |= nsMsgMessageFlags::Queued;</span>
<a href="#l23.33"></a><span id="l23.33">     else if (mode != nsMsgSaveAsDraft)</span>
<a href="#l23.34"></a><span id="l23.34" class="difflineminus">-      flags |= MSG_FLAG_READ;</span>
<a href="#l23.35"></a><span id="l23.35" class="difflineplus">+      flags |= nsMsgMessageFlags::Read;</span>
<a href="#l23.36"></a><span id="l23.36">     buf = PR_smprintf(X_MOZILLA_STATUS_FORMAT CRLF, flags);</span>
<a href="#l23.37"></a><span id="l23.37">     if (buf)</span>
<a href="#l23.38"></a><span id="l23.38">     {</span>
<a href="#l23.39"></a><span id="l23.39">       PRUint32   len = PL_strlen(buf);</span>
<a href="#l23.40"></a><span id="l23.40">       rv = tempOutfile-&gt;Write(buf, len, &amp;n);</span>
<a href="#l23.41"></a><span id="l23.41">       PR_Free(buf);</span>
<a href="#l23.42"></a><span id="l23.42">       if (NS_FAILED(rv) || n != len)</span>
<a href="#l23.43"></a><span id="l23.43">       {</span>
<a href="#l23.44"></a><span id="l23.44">         status = NS_ERROR_FAILURE;</span>
<a href="#l23.45"></a><span id="l23.45">         goto FAIL;</span>
<a href="#l23.46"></a><span id="l23.46">       }</span>
<a href="#l23.47"></a><span id="l23.47">     }</span>
<a href="#l23.48"></a><span id="l23.48"> </span>
<a href="#l23.49"></a><span id="l23.49">     PRUint32 flags2 = 0;</span>
<a href="#l23.50"></a><span id="l23.50">     if (mode == nsMsgSaveAsTemplate)</span>
<a href="#l23.51"></a><span id="l23.51" class="difflineminus">-      flags2 |= MSG_FLAG_TEMPLATE;</span>
<a href="#l23.52"></a><span id="l23.52" class="difflineplus">+      flags2 |= nsMsgMessageFlags::Template;</span>
<a href="#l23.53"></a><span id="l23.53">     if (mode == nsMsgDeliverNow || mode == nsMsgSendUnsent)</span>
<a href="#l23.54"></a><span id="l23.54">     {</span>
<a href="#l23.55"></a><span id="l23.55" class="difflineminus">-      flags2 &amp;= ~MSG_FLAG_MDN_REPORT_NEEDED;</span>
<a href="#l23.56"></a><span id="l23.56" class="difflineminus">-      flags2 |= MSG_FLAG_MDN_REPORT_SENT;</span>
<a href="#l23.57"></a><span id="l23.57" class="difflineplus">+      flags2 &amp;= ~nsMsgMessageFlags::MDNReportNeeded;</span>
<a href="#l23.58"></a><span id="l23.58" class="difflineplus">+      flags2 |= nsMsgMessageFlags::MDNReportSent;</span>
<a href="#l23.59"></a><span id="l23.59">     }</span>
<a href="#l23.60"></a><span id="l23.60">     buf = PR_smprintf(X_MOZILLA_STATUS2_FORMAT CRLF, flags2);</span>
<a href="#l23.61"></a><span id="l23.61">     if (buf)</span>
<a href="#l23.62"></a><span id="l23.62">     {</span>
<a href="#l23.63"></a><span id="l23.63">       PRUint32   len = PL_strlen(buf);</span>
<a href="#l23.64"></a><span id="l23.64">       rv = tempOutfile-&gt;Write(buf, len, &amp;n);</span>
<a href="#l23.65"></a><span id="l23.65">       PR_Free(buf);</span>
<a href="#l23.66"></a><span id="l23.66">       if (NS_FAILED(rv) || n != len)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/mailnews/db/msgdb/public/nsImapMailDatabase.h</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/mailnews/db/msgdb/public/nsImapMailDatabase.h</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -60,19 +60,19 @@ public:</span>
<a href="#l24.4"></a><span id="l24.4">   NS_IMETHOD    AddNewHdrToDB(nsIMsgDBHdr *newHdr, PRBool notify);</span>
<a href="#l24.5"></a><span id="l24.5">   NS_IMETHOD    SetAttributesOnPendingHdr(nsIMsgDBHdr *pendingHdr, const char *property, </span>
<a href="#l24.6"></a><span id="l24.6">                                   const char *propertyVal, PRInt32 flags);</span>
<a href="#l24.7"></a><span id="l24.7">   NS_IMETHODIMP DeleteMessages(nsTArray&lt;nsMsgKey&gt;* nsMsgKeys, </span>
<a href="#l24.8"></a><span id="l24.8">                                nsIDBChangeListener *instigator);</span>
<a href="#l24.9"></a><span id="l24.9"> </span>
<a href="#l24.10"></a><span id="l24.10"> protected:</span>
<a href="#l24.11"></a><span id="l24.11">   // IMAP does not set local file flags, override does nothing</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineminus">-  virtual void	UpdateFolderFlag(nsIMsgDBHdr *msgHdr, PRBool bSet, </span>
<a href="#l24.13"></a><span id="l24.13" class="difflineminus">-                                  MsgFlags flag, nsIOutputStream **ppFileStream);</span>
<a href="#l24.14"></a><span id="l24.14" class="difflineminus">-  virtual PRBool SetHdrFlag(nsIMsgDBHdr *msgHdr, PRBool bSet, MsgFlags flag);</span>
<a href="#l24.15"></a><span id="l24.15" class="difflineplus">+  virtual void UpdateFolderFlag(nsIMsgDBHdr *msgHdr, PRBool bSet, </span>
<a href="#l24.16"></a><span id="l24.16" class="difflineplus">+                                nsMsgMessageFlagType flag, nsIOutputStream **ppFileStream);</span>
<a href="#l24.17"></a><span id="l24.17" class="difflineplus">+  virtual PRBool SetHdrFlag(nsIMsgDBHdr *msgHdr, PRBool bSet, nsMsgMessageFlagType flag);</span>
<a href="#l24.18"></a><span id="l24.18"> </span>
<a href="#l24.19"></a><span id="l24.19">    nsresult     GetAllPendingHdrsTable();</span>
<a href="#l24.20"></a><span id="l24.20">    mdb_token    m_pendingHdrsRowScopeToken;</span>
<a href="#l24.21"></a><span id="l24.21">    mdb_token    m_pendingHdrsTableKindToken; </span>
<a href="#l24.22"></a><span id="l24.22">    nsCOMPtr &lt;nsIMdbTable&gt; m_mdbAllPendingHdrsTable;</span>
<a href="#l24.23"></a><span id="l24.23"> };</span>
<a href="#l24.24"></a><span id="l24.24"> </span>
<a href="#l24.25"></a><span id="l24.25"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/mailnews/db/msgdb/public/nsMailDatabase.h</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/mailnews/db/msgdb/public/nsMailDatabase.h</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -84,19 +84,19 @@ protected:</span>
<a href="#l25.4"></a><span id="l25.4"> </span>
<a href="#l25.5"></a><span id="l25.5">   nsresult        GetAllOfflineOpsTable(); // get this on demand</span>
<a href="#l25.6"></a><span id="l25.6">   PRUint32        GetMailboxModDate(); </span>
<a href="#l25.7"></a><span id="l25.7"> </span>
<a href="#l25.8"></a><span id="l25.8">   nsCOMPtr &lt;nsIMdbTable&gt;  m_mdbAllOfflineOpsTable;</span>
<a href="#l25.9"></a><span id="l25.9">   mdb_token       m_offlineOpsRowScopeToken;</span>
<a href="#l25.10"></a><span id="l25.10">   mdb_token       m_offlineOpsTableKindToken;</span>
<a href="#l25.11"></a><span id="l25.11"> </span>
<a href="#l25.12"></a><span id="l25.12" class="difflineminus">-  virtual PRBool  SetHdrFlag(nsIMsgDBHdr *, PRBool bSet, MsgFlags flag);</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineplus">+  virtual PRBool  SetHdrFlag(nsIMsgDBHdr *, PRBool bSet, nsMsgMessageFlagType flag);</span>
<a href="#l25.14"></a><span id="l25.14">   virtual void    UpdateFolderFlag(nsIMsgDBHdr *msgHdr, PRBool bSet, </span>
<a href="#l25.15"></a><span id="l25.15" class="difflineminus">-                                    MsgFlags flag, nsIOutputStream **ppFileStream);</span>
<a href="#l25.16"></a><span id="l25.16" class="difflineplus">+                                   nsMsgMessageFlagType flag, nsIOutputStream **ppFileStream);</span>
<a href="#l25.17"></a><span id="l25.17">   virtual void    SetReparse(PRBool reparse);</span>
<a href="#l25.18"></a><span id="l25.18">   </span>
<a href="#l25.19"></a><span id="l25.19"> protected:</span>
<a href="#l25.20"></a><span id="l25.20">   virtual void    GetGlobalPrefs();</span>
<a href="#l25.21"></a><span id="l25.21">   </span>
<a href="#l25.22"></a><span id="l25.22">   PRBool          m_reparse;</span>
<a href="#l25.23"></a><span id="l25.23">   nsCOMPtr &lt;nsILocalFile&gt; m_folderFile;</span>
<a href="#l25.24"></a><span id="l25.24">   nsCOMPtr &lt;nsIOutputStream&gt; m_folderStream; 	/* this is a cache for loops which want file left open */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/mailnews/db/msgdb/public/nsMsgDatabase.h</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/mailnews/db/msgdb/public/nsMsgDatabase.h</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -201,17 +201,17 @@ protected:</span>
<a href="#l26.4"></a><span id="l26.4">   PRBool  MatchDbName(nsILocalFile *dbName);  // returns TRUE if they match</span>
<a href="#l26.5"></a><span id="l26.5">   </span>
<a href="#l26.6"></a><span id="l26.6">   // Flag handling routines</span>
<a href="#l26.7"></a><span id="l26.7">   virtual nsresult SetKeyFlag(nsMsgKey key, PRBool set, PRUint32 flag,</span>
<a href="#l26.8"></a><span id="l26.8">                               nsIDBChangeListener *instigator = NULL);</span>
<a href="#l26.9"></a><span id="l26.9">   virtual nsresult SetMsgHdrFlag(nsIMsgDBHdr *msgHdr, PRBool set, PRUint32 flag, </span>
<a href="#l26.10"></a><span id="l26.10">                                  nsIDBChangeListener *instigator);</span>
<a href="#l26.11"></a><span id="l26.11">   </span>
<a href="#l26.12"></a><span id="l26.12" class="difflineminus">-  virtual PRBool  SetHdrFlag(nsIMsgDBHdr *, PRBool bSet, MsgFlags flag);</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineplus">+  virtual PRBool  SetHdrFlag(nsIMsgDBHdr *, PRBool bSet, nsMsgMessageFlagType flag);</span>
<a href="#l26.14"></a><span id="l26.14">   virtual PRBool  SetHdrReadFlag(nsIMsgDBHdr *, PRBool pRead);</span>
<a href="#l26.15"></a><span id="l26.15">   virtual PRUint32 GetStatusFlags(nsIMsgDBHdr *msgHdr, PRUint32 origFlags);</span>
<a href="#l26.16"></a><span id="l26.16">   // helper function which doesn't involve thread object</span>
<a href="#l26.17"></a><span id="l26.17">   </span>
<a href="#l26.18"></a><span id="l26.18">   virtual nsresult RemoveHeaderFromDB(nsMsgHdr *msgHdr);</span>
<a href="#l26.19"></a><span id="l26.19">   virtual nsresult RemoveHeaderFromThread(nsMsgHdr *msgHdr);</span>
<a href="#l26.20"></a><span id="l26.20">   virtual nsresult AdjustExpungedBytesOnDelete(nsIMsgDBHdr *msgHdr);</span>
<a href="#l26.21"></a><span id="l26.21">   </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1" class="difflineminus">--- a/mailnews/db/msgdb/src/nsImapMailDatabase.cpp</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineplus">+++ b/mailnews/db/msgdb/src/nsImapMailDatabase.cpp</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineat">@@ -75,31 +75,31 @@ NS_IMETHODIMP	nsImapMailDatabase::SetSum</span>
<a href="#l27.4"></a><span id="l27.4">   {</span>
<a href="#l27.5"></a><span id="l27.5">     m_dbFolderInfo-&gt;SetVersion(valid ? GetCurVersion() : 0);</span>
<a href="#l27.6"></a><span id="l27.6">     Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l27.7"></a><span id="l27.7">   }</span>
<a href="#l27.8"></a><span id="l27.8">   return NS_OK;</span>
<a href="#l27.9"></a><span id="l27.9"> }</span>
<a href="#l27.10"></a><span id="l27.10"> </span>
<a href="#l27.11"></a><span id="l27.11"> // IMAP does not set local file flags, override does nothing</span>
<a href="#l27.12"></a><span id="l27.12" class="difflineminus">-void	nsImapMailDatabase::UpdateFolderFlag(nsIMsgDBHdr * /* msgHdr */, PRBool /* bSet */,</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineminus">-                                              MsgFlags /* flag */, nsIOutputStream ** /* ppFileStream */)</span>
<a href="#l27.14"></a><span id="l27.14" class="difflineplus">+void nsImapMailDatabase::UpdateFolderFlag(nsIMsgDBHdr * /* msgHdr */, PRBool /* bSet */,</span>
<a href="#l27.15"></a><span id="l27.15" class="difflineplus">+                                          nsMsgMessageFlagType /* flag */, nsIOutputStream ** /* ppFileStream */)</span>
<a href="#l27.16"></a><span id="l27.16"> {</span>
<a href="#l27.17"></a><span id="l27.17"> }</span>
<a href="#l27.18"></a><span id="l27.18"> </span>
<a href="#l27.19"></a><span id="l27.19"> // We override this to avoid our parent class (nsMailDatabase)'s </span>
<a href="#l27.20"></a><span id="l27.20"> // grabbing of the folder semaphore, and bailing on failure.</span>
<a href="#l27.21"></a><span id="l27.21"> NS_IMETHODIMP nsImapMailDatabase::DeleteMessages(nsTArray&lt;nsMsgKey&gt;* nsMsgKeys, nsIDBChangeListener *instigator)</span>
<a href="#l27.22"></a><span id="l27.22"> {</span>
<a href="#l27.23"></a><span id="l27.23">   return nsMsgDatabase::DeleteMessages(nsMsgKeys, instigator);</span>
<a href="#l27.24"></a><span id="l27.24"> }</span>
<a href="#l27.25"></a><span id="l27.25"> </span>
<a href="#l27.26"></a><span id="l27.26"> // We override this so we won't try to change the x-mozilla-status flags</span>
<a href="#l27.27"></a><span id="l27.27"> // in the offline store.</span>
<a href="#l27.28"></a><span id="l27.28" class="difflineminus">-PRBool nsImapMailDatabase::SetHdrFlag(nsIMsgDBHdr *msgHdr, PRBool bSet, MsgFlags flag)</span>
<a href="#l27.29"></a><span id="l27.29" class="difflineplus">+PRBool nsImapMailDatabase::SetHdrFlag(nsIMsgDBHdr *msgHdr, PRBool bSet, nsMsgMessageFlagType flag)</span>
<a href="#l27.30"></a><span id="l27.30"> {</span>
<a href="#l27.31"></a><span id="l27.31">   return nsMsgDatabase::SetHdrFlag(msgHdr, bSet, flag);</span>
<a href="#l27.32"></a><span id="l27.32"> }</span>
<a href="#l27.33"></a><span id="l27.33"> </span>
<a href="#l27.34"></a><span id="l27.34"> // override so nsMailDatabase methods that deal with m_folderStream are *not* called</span>
<a href="#l27.35"></a><span id="l27.35"> NS_IMETHODIMP nsImapMailDatabase::StartBatch()</span>
<a href="#l27.36"></a><span id="l27.36"> {</span>
<a href="#l27.37"></a><span id="l27.37">   return NS_OK;</span>
<a href="#l27.38"></a><span id="l27.38" class="difflineat">@@ -109,17 +109,17 @@ NS_IMETHODIMP nsImapMailDatabase::EndBat</span>
<a href="#l27.39"></a><span id="l27.39"> {</span>
<a href="#l27.40"></a><span id="l27.40">   return NS_OK;</span>
<a href="#l27.41"></a><span id="l27.41"> }</span>
<a href="#l27.42"></a><span id="l27.42"> </span>
<a href="#l27.43"></a><span id="l27.43"> nsresult nsImapMailDatabase::AdjustExpungedBytesOnDelete(nsIMsgDBHdr *msgHdr)</span>
<a href="#l27.44"></a><span id="l27.44"> {</span>
<a href="#l27.45"></a><span id="l27.45">   PRUint32 msgFlags;</span>
<a href="#l27.46"></a><span id="l27.46">   msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l27.47"></a><span id="l27.47" class="difflineminus">-  if (msgFlags &amp; MSG_FLAG_OFFLINE &amp;&amp; m_dbFolderInfo)</span>
<a href="#l27.48"></a><span id="l27.48" class="difflineplus">+  if (msgFlags &amp; nsMsgMessageFlags::Offline &amp;&amp; m_dbFolderInfo)</span>
<a href="#l27.49"></a><span id="l27.49">   {</span>
<a href="#l27.50"></a><span id="l27.50">     PRUint32 size = 0;</span>
<a href="#l27.51"></a><span id="l27.51">     (void)msgHdr-&gt;GetOfflineMessageSize(&amp;size);</span>
<a href="#l27.52"></a><span id="l27.52">     return m_dbFolderInfo-&gt;ChangeExpungedBytes (size);</span>
<a href="#l27.53"></a><span id="l27.53">   }</span>
<a href="#l27.54"></a><span id="l27.54">   return NS_OK;</span>
<a href="#l27.55"></a><span id="l27.55"> }</span>
<a href="#l27.56"></a><span id="l27.56"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1" class="difflineminus">--- a/mailnews/db/msgdb/src/nsMailDatabase.cpp</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineplus">+++ b/mailnews/db/msgdb/src/nsMailDatabase.cpp</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineat">@@ -194,17 +194,17 @@ NS_IMETHODIMP nsMailDatabase::DeleteMess</span>
<a href="#l28.4"></a><span id="l28.4">     m_ownFolderStream = PR_FALSE;</span>
<a href="#l28.5"></a><span id="l28.5">   }</span>
<a href="#l28.6"></a><span id="l28.6"> </span>
<a href="#l28.7"></a><span id="l28.7">   SetFolderInfoValid(m_folderFile, 0, 0);</span>
<a href="#l28.8"></a><span id="l28.8">   return rv;</span>
<a href="#l28.9"></a><span id="l28.9"> }</span>
<a href="#l28.10"></a><span id="l28.10"> </span>
<a href="#l28.11"></a><span id="l28.11"> // Helper routine - lowest level of flag setting</span>
<a href="#l28.12"></a><span id="l28.12" class="difflineminus">-PRBool nsMailDatabase::SetHdrFlag(nsIMsgDBHdr *msgHdr, PRBool bSet, MsgFlags flag)</span>
<a href="#l28.13"></a><span id="l28.13" class="difflineplus">+PRBool nsMailDatabase::SetHdrFlag(nsIMsgDBHdr *msgHdr, PRBool bSet, nsMsgMessageFlagType flag)</span>
<a href="#l28.14"></a><span id="l28.14"> {</span>
<a href="#l28.15"></a><span id="l28.15">   nsIOutputStream *fileStream = nsnull;</span>
<a href="#l28.16"></a><span id="l28.16">   PRBool ret = PR_FALSE;</span>
<a href="#l28.17"></a><span id="l28.17"> </span>
<a href="#l28.18"></a><span id="l28.18">   if (!m_folderStream &amp;&amp; m_folder)  //we are going to create a stream, bail out if someone else has lock</span>
<a href="#l28.19"></a><span id="l28.19">   {</span>
<a href="#l28.20"></a><span id="l28.20">     PRBool isLocked;</span>
<a href="#l28.21"></a><span id="l28.21">     m_folder-&gt;GetLocked(&amp;isLocked);</span>
<a href="#l28.22"></a><span id="l28.22" class="difflineat">@@ -239,17 +239,18 @@ int msg_UnHex(char C)</span>
<a href="#l28.23"></a><span id="l28.23"> }</span>
<a href="#l28.24"></a><span id="l28.24"> </span>
<a href="#l28.25"></a><span id="l28.25"> </span>
<a href="#l28.26"></a><span id="l28.26"> // We let the caller close the file in case he's updating a lot of flags</span>
<a href="#l28.27"></a><span id="l28.27"> // and we don't want to open and close the file every time through.</span>
<a href="#l28.28"></a><span id="l28.28"> // As an experiment, try caching the fid in the db as m_folderFile.</span>
<a href="#l28.29"></a><span id="l28.29"> // If this is set, use it but don't return *pFid.</span>
<a href="#l28.30"></a><span id="l28.30"> void nsMailDatabase::UpdateFolderFlag(nsIMsgDBHdr *mailHdr, PRBool bSet, </span>
<a href="#l28.31"></a><span id="l28.31" class="difflineminus">-							  MsgFlags flag, nsIOutputStream **ppFileStream)</span>
<a href="#l28.32"></a><span id="l28.32" class="difflineplus">+                                      nsMsgMessageFlagType flag,</span>
<a href="#l28.33"></a><span id="l28.33" class="difflineplus">+                                      nsIOutputStream **ppFileStream)</span>
<a href="#l28.34"></a><span id="l28.34"> {</span>
<a href="#l28.35"></a><span id="l28.35">   static char buf[50];</span>
<a href="#l28.36"></a><span id="l28.36">   PRInt64 folderStreamPos = 0; //saves the folderStream pos in case we are sharing the stream with other code</span>
<a href="#l28.37"></a><span id="l28.37">   nsIOutputStream *fileStream = (m_folderStream) ? m_folderStream.get() : *ppFileStream;</span>
<a href="#l28.38"></a><span id="l28.38">   PRUint32 offset;</span>
<a href="#l28.39"></a><span id="l28.39">   (void)mailHdr-&gt;GetStatusOffset(&amp;offset);</span>
<a href="#l28.40"></a><span id="l28.40">   nsCOMPtr &lt;nsISeekableStream&gt; seekableStream;</span>
<a href="#l28.41"></a><span id="l28.41">   </span>
<a href="#l28.42"></a><span id="l28.42" class="difflineat">@@ -289,34 +290,34 @@ void nsMailDatabase::UpdateFolderFlag(ns</span>
<a href="#l28.43"></a><span id="l28.43">         buf[bytesRead] = '\0';</span>
<a href="#l28.44"></a><span id="l28.44">         if (strncmp(buf, X_MOZILLA_STATUS, X_MOZILLA_STATUS_LEN) == 0 &amp;&amp;</span>
<a href="#l28.45"></a><span id="l28.45">           strncmp(buf + X_MOZILLA_STATUS_LEN, &quot;: &quot;, 2) == 0 &amp;&amp;</span>
<a href="#l28.46"></a><span id="l28.46">           strlen(buf) &gt;= X_MOZILLA_STATUS_LEN + 6) </span>
<a href="#l28.47"></a><span id="l28.47">         {</span>
<a href="#l28.48"></a><span id="l28.48">           PRUint32 flags;</span>
<a href="#l28.49"></a><span id="l28.49">           PRUint32 bytesWritten;</span>
<a href="#l28.50"></a><span id="l28.50">           (void)mailHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l28.51"></a><span id="l28.51" class="difflineminus">-          if (!(flags &amp; MSG_FLAG_EXPUNGED))</span>
<a href="#l28.52"></a><span id="l28.52" class="difflineplus">+          if (!(flags &amp; nsMsgMessageFlags::Expunged))</span>
<a href="#l28.53"></a><span id="l28.53">           {</span>
<a href="#l28.54"></a><span id="l28.54">             int i;</span>
<a href="#l28.55"></a><span id="l28.55">             char *p = buf + X_MOZILLA_STATUS_LEN + 2;</span>
<a href="#l28.56"></a><span id="l28.56">             </span>
<a href="#l28.57"></a><span id="l28.57">             for (i=0, flags = 0; i&lt;4; i++, p++)</span>
<a href="#l28.58"></a><span id="l28.58">             {</span>
<a href="#l28.59"></a><span id="l28.59">               flags = (flags &lt;&lt; 4) | msg_UnHex(*p);</span>
<a href="#l28.60"></a><span id="l28.60">             }</span>
<a href="#l28.61"></a><span id="l28.61">             </span>
<a href="#l28.62"></a><span id="l28.62">             PRUint32 curFlags;</span>
<a href="#l28.63"></a><span id="l28.63">             (void)mailHdr-&gt;GetFlags(&amp;curFlags);</span>
<a href="#l28.64"></a><span id="l28.64" class="difflineminus">-            flags = (flags &amp; MSG_FLAG_QUEUED) |</span>
<a href="#l28.65"></a><span id="l28.65" class="difflineminus">-              (curFlags &amp; ~MSG_FLAG_RUNTIME_ONLY);</span>
<a href="#l28.66"></a><span id="l28.66" class="difflineplus">+            flags = (flags &amp; nsMsgMessageFlags::Queued) |</span>
<a href="#l28.67"></a><span id="l28.67" class="difflineplus">+              (curFlags &amp; ~nsMsgMessageFlags::RuntimeOnly);</span>
<a href="#l28.68"></a><span id="l28.68">           }</span>
<a href="#l28.69"></a><span id="l28.69">           else</span>
<a href="#l28.70"></a><span id="l28.70">           {</span>
<a href="#l28.71"></a><span id="l28.71" class="difflineminus">-            flags &amp;= ~MSG_FLAG_RUNTIME_ONLY;</span>
<a href="#l28.72"></a><span id="l28.72" class="difflineplus">+            flags &amp;= ~nsMsgMessageFlags::RuntimeOnly;</span>
<a href="#l28.73"></a><span id="l28.73">           }</span>
<a href="#l28.74"></a><span id="l28.74">           seekableStream-&gt;Seek(nsISeekableStream::NS_SEEK_SET, statusPos);</span>
<a href="#l28.75"></a><span id="l28.75">           // We are filing out x-mozilla-status flags here</span>
<a href="#l28.76"></a><span id="l28.76">           PR_snprintf(buf, sizeof(buf), X_MOZILLA_STATUS_FORMAT,</span>
<a href="#l28.77"></a><span id="l28.77">             flags &amp; 0x0000FFFF);</span>
<a href="#l28.78"></a><span id="l28.78">           PRInt32 lineLen = PL_strlen(buf);</span>
<a href="#l28.79"></a><span id="l28.79">           PRUint32 status2Pos = statusPos + lineLen + MSG_LINEBREAK_LEN;</span>
<a href="#l28.80"></a><span id="l28.80">           fileStream-&gt;Write(buf, lineLen, &amp;bytesWritten);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1" class="difflineminus">--- a/mailnews/db/msgdb/src/nsMsgDatabase.cpp</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineplus">+++ b/mailnews/db/msgdb/src/nsMsgDatabase.cpp</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineat">@@ -1734,17 +1734,17 @@ nsresult nsMsgDatabase::AdjustExpungedBy</span>
<a href="#l29.4"></a><span id="l29.4"> }</span>
<a href="#l29.5"></a><span id="l29.5"> </span>
<a href="#l29.6"></a><span id="l29.6"> NS_IMETHODIMP nsMsgDatabase::DeleteHeader(nsIMsgDBHdr *msg, nsIDBChangeListener *instigator, PRBool commit, PRBool notify)</span>
<a href="#l29.7"></a><span id="l29.7"> {</span>
<a href="#l29.8"></a><span id="l29.8">   nsMsgHdr* msgHdr = static_cast&lt;nsMsgHdr*&gt;(msg);  // closed system, so this is ok</span>
<a href="#l29.9"></a><span id="l29.9">   nsMsgKey key;</span>
<a href="#l29.10"></a><span id="l29.10">   (void)msg-&gt;GetMessageKey(&amp;key);</span>
<a href="#l29.11"></a><span id="l29.11">   // only need to do this for mail - will this speed up news expiration?</span>
<a href="#l29.12"></a><span id="l29.12" class="difflineminus">-  SetHdrFlag(msg, PR_TRUE, MSG_FLAG_EXPUNGED);  // tell mailbox (mail)</span>
<a href="#l29.13"></a><span id="l29.13" class="difflineplus">+  SetHdrFlag(msg, PR_TRUE, nsMsgMessageFlags::Expunged);  // tell mailbox (mail)</span>
<a href="#l29.14"></a><span id="l29.14"> </span>
<a href="#l29.15"></a><span id="l29.15">   PRBool hdrWasNew = m_newSet.BinaryIndexOf(key) != -1;</span>
<a href="#l29.16"></a><span id="l29.16">   m_newSet.RemoveElement(key);</span>
<a href="#l29.17"></a><span id="l29.17"> </span>
<a href="#l29.18"></a><span id="l29.18">   if (m_dbFolderInfo != NULL)</span>
<a href="#l29.19"></a><span id="l29.19">   {</span>
<a href="#l29.20"></a><span id="l29.20">     PRBool isRead;</span>
<a href="#l29.21"></a><span id="l29.21">     m_dbFolderInfo-&gt;ChangeNumMessages(-1);</span>
<a href="#l29.22"></a><span id="l29.22" class="difflineat">@@ -1765,17 +1765,17 @@ NS_IMETHODIMP nsMsgDatabase::DeleteHeade</span>
<a href="#l29.23"></a><span id="l29.23">   }</span>
<a href="#l29.24"></a><span id="l29.24"> </span>
<a href="#l29.25"></a><span id="l29.25">   RemoveHeaderFromThread(msgHdr);</span>
<a href="#l29.26"></a><span id="l29.26">   if (notify)</span>
<a href="#l29.27"></a><span id="l29.27">   {</span>
<a href="#l29.28"></a><span id="l29.28">     // If deleted hdr was new, restore the new flag on flags </span>
<a href="#l29.29"></a><span id="l29.29">     // so saved searches will know to reduce their new msg count.</span>
<a href="#l29.30"></a><span id="l29.30">     if (hdrWasNew)</span>
<a href="#l29.31"></a><span id="l29.31" class="difflineminus">-      flags |= MSG_FLAG_NEW;</span>
<a href="#l29.32"></a><span id="l29.32" class="difflineplus">+      flags |= nsMsgMessageFlags::New;</span>
<a href="#l29.33"></a><span id="l29.33">     NotifyHdrDeletedAll(msg, threadParent, flags, instigator); // tell listeners</span>
<a href="#l29.34"></a><span id="l29.34">   }</span>
<a href="#l29.35"></a><span id="l29.35">   //  if (!onlyRemoveFromThread)  // to speed up expiration, try this. But really need to do this in RemoveHeaderFromDB</span>
<a href="#l29.36"></a><span id="l29.36">   nsresult ret = RemoveHeaderFromDB(msgHdr);</span>
<a href="#l29.37"></a><span id="l29.37"> </span>
<a href="#l29.38"></a><span id="l29.38"> </span>
<a href="#l29.39"></a><span id="l29.39">   if (commit)</span>
<a href="#l29.40"></a><span id="l29.40">     Commit(nsMsgDBCommitType::kLargeCommit);      // ### dmb is this a good time to commit?</span>
<a href="#l29.41"></a><span id="l29.41" class="difflineat">@@ -1784,18 +1784,18 @@ NS_IMETHODIMP nsMsgDatabase::DeleteHeade</span>
<a href="#l29.42"></a><span id="l29.42"> </span>
<a href="#l29.43"></a><span id="l29.43"> NS_IMETHODIMP</span>
<a href="#l29.44"></a><span id="l29.44"> nsMsgDatabase::UndoDelete(nsIMsgDBHdr *aMsgHdr)</span>
<a href="#l29.45"></a><span id="l29.45"> {</span>
<a href="#l29.46"></a><span id="l29.46">     if (aMsgHdr)</span>
<a href="#l29.47"></a><span id="l29.47">     {</span>
<a href="#l29.48"></a><span id="l29.48">         nsMsgHdr* msgHdr = static_cast&lt;nsMsgHdr*&gt;(aMsgHdr);  // closed system, so this is ok</span>
<a href="#l29.49"></a><span id="l29.49">         // force deleted flag, so SetHdrFlag won't bail out because  deleted flag isn't set</span>
<a href="#l29.50"></a><span id="l29.50" class="difflineminus">-        msgHdr-&gt;m_flags |= MSG_FLAG_EXPUNGED;</span>
<a href="#l29.51"></a><span id="l29.51" class="difflineminus">-        SetHdrFlag(msgHdr, PR_FALSE, MSG_FLAG_EXPUNGED); // clear deleted flag in db</span>
<a href="#l29.52"></a><span id="l29.52" class="difflineplus">+        msgHdr-&gt;m_flags |= nsMsgMessageFlags::Expunged;</span>
<a href="#l29.53"></a><span id="l29.53" class="difflineplus">+        SetHdrFlag(msgHdr, PR_FALSE, nsMsgMessageFlags::Expunged); // clear deleted flag in db</span>
<a href="#l29.54"></a><span id="l29.54">     }</span>
<a href="#l29.55"></a><span id="l29.55">     return NS_OK;</span>
<a href="#l29.56"></a><span id="l29.56"> }</span>
<a href="#l29.57"></a><span id="l29.57"> </span>
<a href="#l29.58"></a><span id="l29.58"> nsresult nsMsgDatabase::RemoveHeaderFromThread(nsMsgHdr *msgHdr)</span>
<a href="#l29.59"></a><span id="l29.59"> {</span>
<a href="#l29.60"></a><span id="l29.60">   if (!msgHdr)</span>
<a href="#l29.61"></a><span id="l29.61">     return NS_ERROR_NULL_POINTER;</span>
<a href="#l29.62"></a><span id="l29.62" class="difflineat">@@ -1851,48 +1851,48 @@ nsresult nsMsgDatabase::IsRead(nsMsgKey </span>
<a href="#l29.63"></a><span id="l29.63"> PRUint32  nsMsgDatabase::GetStatusFlags(nsIMsgDBHdr *msgHdr, PRUint32 origFlags)</span>
<a href="#l29.64"></a><span id="l29.64"> {</span>
<a href="#l29.65"></a><span id="l29.65">   PRUint32  statusFlags = origFlags;</span>
<a href="#l29.66"></a><span id="l29.66">   PRBool  isRead = PR_TRUE;</span>
<a href="#l29.67"></a><span id="l29.67"> </span>
<a href="#l29.68"></a><span id="l29.68">   nsMsgKey key;</span>
<a href="#l29.69"></a><span id="l29.69">   (void)msgHdr-&gt;GetMessageKey(&amp;key);</span>
<a href="#l29.70"></a><span id="l29.70">   if (!m_newSet.IsEmpty() &amp;&amp; m_newSet[m_newSet.Length() - 1] == key || m_newSet.BinaryIndexOf(key) != kNotFound)</span>
<a href="#l29.71"></a><span id="l29.71" class="difflineminus">-    statusFlags |= MSG_FLAG_NEW;</span>
<a href="#l29.72"></a><span id="l29.72" class="difflineplus">+    statusFlags |= nsMsgMessageFlags::New;</span>
<a href="#l29.73"></a><span id="l29.73">   else</span>
<a href="#l29.74"></a><span id="l29.74" class="difflineminus">-    statusFlags &amp;= ~MSG_FLAG_NEW;</span>
<a href="#l29.75"></a><span id="l29.75" class="difflineplus">+    statusFlags &amp;= ~nsMsgMessageFlags::New;</span>
<a href="#l29.76"></a><span id="l29.76">   if (IsHeaderRead(msgHdr, &amp;isRead) == NS_OK &amp;&amp; isRead)</span>
<a href="#l29.77"></a><span id="l29.77" class="difflineminus">-    statusFlags |= MSG_FLAG_READ;</span>
<a href="#l29.78"></a><span id="l29.78" class="difflineplus">+    statusFlags |= nsMsgMessageFlags::Read;</span>
<a href="#l29.79"></a><span id="l29.79">   return statusFlags;</span>
<a href="#l29.80"></a><span id="l29.80"> }</span>
<a href="#l29.81"></a><span id="l29.81"> </span>
<a href="#l29.82"></a><span id="l29.82"> nsresult nsMsgDatabase::IsHeaderRead(nsIMsgDBHdr *msgHdr, PRBool *pRead)</span>
<a href="#l29.83"></a><span id="l29.83"> {</span>
<a href="#l29.84"></a><span id="l29.84">   if (!msgHdr)</span>
<a href="#l29.85"></a><span id="l29.85">     return NS_MSG_MESSAGE_NOT_FOUND;</span>
<a href="#l29.86"></a><span id="l29.86"> </span>
<a href="#l29.87"></a><span id="l29.87">   nsMsgHdr* hdr = static_cast&lt;nsMsgHdr*&gt;(msgHdr);          // closed system, cast ok</span>
<a href="#l29.88"></a><span id="l29.88">   // can't call GetFlags, because it will be recursive.</span>
<a href="#l29.89"></a><span id="l29.89">   PRUint32 flags;</span>
<a href="#l29.90"></a><span id="l29.90">   hdr-&gt;GetRawFlags(&amp;flags);</span>
<a href="#l29.91"></a><span id="l29.91" class="difflineminus">-  *pRead = (flags &amp; MSG_FLAG_READ) != 0;</span>
<a href="#l29.92"></a><span id="l29.92" class="difflineplus">+  *pRead = (flags &amp; nsMsgMessageFlags::Read) != 0;</span>
<a href="#l29.93"></a><span id="l29.93">   return NS_OK;</span>
<a href="#l29.94"></a><span id="l29.94"> }</span>
<a href="#l29.95"></a><span id="l29.95"> </span>
<a href="#l29.96"></a><span id="l29.96"> NS_IMETHODIMP nsMsgDatabase::IsMarked(nsMsgKey key, PRBool *pMarked)</span>
<a href="#l29.97"></a><span id="l29.97"> {</span>
<a href="#l29.98"></a><span id="l29.98">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l29.99"></a><span id="l29.99"> </span>
<a href="#l29.100"></a><span id="l29.100">   nsresult rv = GetMsgHdrForKey(key, getter_AddRefs(msgHdr));</span>
<a href="#l29.101"></a><span id="l29.101">   if (NS_FAILED(rv))</span>
<a href="#l29.102"></a><span id="l29.102">     return NS_MSG_MESSAGE_NOT_FOUND; // XXX return rv?</span>
<a href="#l29.103"></a><span id="l29.103"> </span>
<a href="#l29.104"></a><span id="l29.104">   PRUint32 flags;</span>
<a href="#l29.105"></a><span id="l29.105">   (void)msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l29.106"></a><span id="l29.106" class="difflineminus">-  *pMarked = (flags &amp; MSG_FLAG_MARKED) == MSG_FLAG_MARKED;</span>
<a href="#l29.107"></a><span id="l29.107" class="difflineplus">+  *pMarked = (flags &amp; nsMsgMessageFlags::Marked) == nsMsgMessageFlags::Marked;</span>
<a href="#l29.108"></a><span id="l29.108">   return rv;</span>
<a href="#l29.109"></a><span id="l29.109"> }</span>
<a href="#l29.110"></a><span id="l29.110"> </span>
<a href="#l29.111"></a><span id="l29.111"> NS_IMETHODIMP nsMsgDatabase::IsIgnored(nsMsgKey key, PRBool *pIgnored)</span>
<a href="#l29.112"></a><span id="l29.112"> {</span>
<a href="#l29.113"></a><span id="l29.113">   PR_ASSERT(pIgnored != NULL);</span>
<a href="#l29.114"></a><span id="l29.114">   if (!pIgnored)</span>
<a href="#l29.115"></a><span id="l29.115">     return NS_ERROR_NULL_POINTER;</span>
<a href="#l29.116"></a><span id="l29.116" class="difflineat">@@ -1901,39 +1901,39 @@ NS_IMETHODIMP nsMsgDatabase::IsIgnored(n</span>
<a href="#l29.117"></a><span id="l29.117">   nsresult rv = GetThreadForMsgKey(key, getter_AddRefs(threadHdr));</span>
<a href="#l29.118"></a><span id="l29.118">   // This should be very surprising, but we leave that up to the caller</span>
<a href="#l29.119"></a><span id="l29.119">   // to determine for now.</span>
<a href="#l29.120"></a><span id="l29.120">   if (!threadHdr)</span>
<a href="#l29.121"></a><span id="l29.121">     return NS_MSG_MESSAGE_NOT_FOUND;</span>
<a href="#l29.122"></a><span id="l29.122"> </span>
<a href="#l29.123"></a><span id="l29.123">   PRUint32 threadFlags;</span>
<a href="#l29.124"></a><span id="l29.124">   threadHdr-&gt;GetFlags(&amp;threadFlags);</span>
<a href="#l29.125"></a><span id="l29.125" class="difflineminus">-  *pIgnored = (threadFlags &amp; MSG_FLAG_IGNORED) ? PR_TRUE : PR_FALSE;</span>
<a href="#l29.126"></a><span id="l29.126" class="difflineplus">+  *pIgnored = (threadFlags &amp; nsMsgMessageFlags::Ignored) ? PR_TRUE : PR_FALSE;</span>
<a href="#l29.127"></a><span id="l29.127">   return rv;</span>
<a href="#l29.128"></a><span id="l29.128"> }</span>
<a href="#l29.129"></a><span id="l29.129"> </span>
<a href="#l29.130"></a><span id="l29.130"> nsresult nsMsgDatabase::HasAttachments(nsMsgKey key, PRBool *pHasThem)</span>
<a href="#l29.131"></a><span id="l29.131"> {</span>
<a href="#l29.132"></a><span id="l29.132">   NS_ENSURE_ARG_POINTER(pHasThem);</span>
<a href="#l29.133"></a><span id="l29.133"> </span>
<a href="#l29.134"></a><span id="l29.134">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l29.135"></a><span id="l29.135"> </span>
<a href="#l29.136"></a><span id="l29.136">   nsresult rv = GetMsgHdrForKey(key, getter_AddRefs(msgHdr));</span>
<a href="#l29.137"></a><span id="l29.137">   if (NS_FAILED(rv))</span>
<a href="#l29.138"></a><span id="l29.138">     return rv;</span>
<a href="#l29.139"></a><span id="l29.139"> </span>
<a href="#l29.140"></a><span id="l29.140">   PRUint32 flags;</span>
<a href="#l29.141"></a><span id="l29.141">   (void)msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l29.142"></a><span id="l29.142" class="difflineminus">-  *pHasThem = (flags &amp; MSG_FLAG_ATTACHMENT) ? PR_TRUE : PR_FALSE;</span>
<a href="#l29.143"></a><span id="l29.143" class="difflineplus">+  *pHasThem = (flags &amp; nsMsgMessageFlags::Attachment) ? PR_TRUE : PR_FALSE;</span>
<a href="#l29.144"></a><span id="l29.144">   return rv;</span>
<a href="#l29.145"></a><span id="l29.145"> }</span>
<a href="#l29.146"></a><span id="l29.146"> </span>
<a href="#l29.147"></a><span id="l29.147"> PRBool nsMsgDatabase::SetHdrReadFlag(nsIMsgDBHdr *msgHdr, PRBool bRead)</span>
<a href="#l29.148"></a><span id="l29.148"> {</span>
<a href="#l29.149"></a><span id="l29.149" class="difflineminus">-  return SetHdrFlag(msgHdr, bRead, MSG_FLAG_READ);</span>
<a href="#l29.150"></a><span id="l29.150" class="difflineplus">+  return SetHdrFlag(msgHdr, bRead, nsMsgMessageFlags::Read);</span>
<a href="#l29.151"></a><span id="l29.151"> }</span>
<a href="#l29.152"></a><span id="l29.152"> </span>
<a href="#l29.153"></a><span id="l29.153"> nsresult nsMsgDatabase::MarkHdrReadInDB(nsIMsgDBHdr *msgHdr, PRBool bRead,</span>
<a href="#l29.154"></a><span id="l29.154">                                              nsIDBChangeListener *instigator)</span>
<a href="#l29.155"></a><span id="l29.155"> {</span>
<a href="#l29.156"></a><span id="l29.156">   nsresult rv;</span>
<a href="#l29.157"></a><span id="l29.157">   nsMsgKey key;</span>
<a href="#l29.158"></a><span id="l29.158">   PRUint32 oldFlags;</span>
<a href="#l29.159"></a><span id="l29.159" class="difflineat">@@ -1950,17 +1950,17 @@ nsresult nsMsgDatabase::MarkHdrReadInDB(</span>
<a href="#l29.160"></a><span id="l29.160">     else</span>
<a href="#l29.161"></a><span id="l29.161">       m_dbFolderInfo-&gt;ChangeNumUnreadMessages(1);</span>
<a href="#l29.162"></a><span id="l29.162">   }</span>
<a href="#l29.163"></a><span id="l29.163"> </span>
<a href="#l29.164"></a><span id="l29.164">   SetHdrReadFlag(msgHdr, bRead); // this will cause a commit, at least for local mail, so do it after we change</span>
<a href="#l29.165"></a><span id="l29.165">   // the folder counts above, so they will get committed too.</span>
<a href="#l29.166"></a><span id="l29.166">   PRUint32 flags;</span>
<a href="#l29.167"></a><span id="l29.167">   rv = msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l29.168"></a><span id="l29.168" class="difflineminus">-  flags &amp;= ~MSG_FLAG_NEW;</span>
<a href="#l29.169"></a><span id="l29.169" class="difflineplus">+  flags &amp;= ~nsMsgMessageFlags::New;</span>
<a href="#l29.170"></a><span id="l29.170">   msgHdr-&gt;SetFlags(flags);</span>
<a href="#l29.171"></a><span id="l29.171">   if (NS_FAILED(rv)) return rv;</span>
<a href="#l29.172"></a><span id="l29.172"> </span>
<a href="#l29.173"></a><span id="l29.173">   if (oldFlags == flags)</span>
<a href="#l29.174"></a><span id="l29.174">     return NS_OK;</span>
<a href="#l29.175"></a><span id="l29.175"> </span>
<a href="#l29.176"></a><span id="l29.176">   return NotifyHdrChangeAll(msgHdr, oldFlags, flags, instigator);</span>
<a href="#l29.177"></a><span id="l29.177"> }</span>
<a href="#l29.178"></a><span id="l29.178" class="difflineat">@@ -1977,29 +1977,29 @@ NS_IMETHODIMP nsMsgDatabase::MarkRead(ns</span>
<a href="#l29.179"></a><span id="l29.179"> </span>
<a href="#l29.180"></a><span id="l29.180">   rv = MarkHdrRead(msgHdr, bRead, instigator);</span>
<a href="#l29.181"></a><span id="l29.181">   return rv;</span>
<a href="#l29.182"></a><span id="l29.182"> }</span>
<a href="#l29.183"></a><span id="l29.183"> </span>
<a href="#l29.184"></a><span id="l29.184"> NS_IMETHODIMP nsMsgDatabase::MarkReplied(nsMsgKey key, PRBool bReplied,</span>
<a href="#l29.185"></a><span id="l29.185">                                          nsIDBChangeListener *instigator /* = NULL */)</span>
<a href="#l29.186"></a><span id="l29.186"> {</span>
<a href="#l29.187"></a><span id="l29.187" class="difflineminus">-  return SetKeyFlag(key, bReplied, MSG_FLAG_REPLIED, instigator);</span>
<a href="#l29.188"></a><span id="l29.188" class="difflineplus">+  return SetKeyFlag(key, bReplied, nsMsgMessageFlags::Replied, instigator);</span>
<a href="#l29.189"></a><span id="l29.189"> }</span>
<a href="#l29.190"></a><span id="l29.190"> </span>
<a href="#l29.191"></a><span id="l29.191"> NS_IMETHODIMP nsMsgDatabase::MarkForwarded(nsMsgKey key, PRBool bForwarded,</span>
<a href="#l29.192"></a><span id="l29.192">                                            nsIDBChangeListener *instigator /* = NULL */)</span>
<a href="#l29.193"></a><span id="l29.193"> {</span>
<a href="#l29.194"></a><span id="l29.194" class="difflineminus">-  return SetKeyFlag(key, bForwarded, MSG_FLAG_FORWARDED, instigator);</span>
<a href="#l29.195"></a><span id="l29.195" class="difflineplus">+  return SetKeyFlag(key, bForwarded, nsMsgMessageFlags::Forwarded, instigator);</span>
<a href="#l29.196"></a><span id="l29.196"> }</span>
<a href="#l29.197"></a><span id="l29.197"> </span>
<a href="#l29.198"></a><span id="l29.198"> NS_IMETHODIMP nsMsgDatabase::MarkHasAttachments(nsMsgKey key, PRBool bHasAttachments,</span>
<a href="#l29.199"></a><span id="l29.199">                                                 nsIDBChangeListener *instigator)</span>
<a href="#l29.200"></a><span id="l29.200"> {</span>
<a href="#l29.201"></a><span id="l29.201" class="difflineminus">-  return SetKeyFlag(key, bHasAttachments, MSG_FLAG_ATTACHMENT, instigator);</span>
<a href="#l29.202"></a><span id="l29.202" class="difflineplus">+  return SetKeyFlag(key, bHasAttachments, nsMsgMessageFlags::Attachment, instigator);</span>
<a href="#l29.203"></a><span id="l29.203"> }</span>
<a href="#l29.204"></a><span id="l29.204"> </span>
<a href="#l29.205"></a><span id="l29.205"> NS_IMETHODIMP</span>
<a href="#l29.206"></a><span id="l29.206"> nsMsgDatabase::MarkThreadRead(nsIMsgThread *thread, nsIDBChangeListener *instigator, nsTArray&lt;nsMsgKey&gt; *thoseMarked)</span>
<a href="#l29.207"></a><span id="l29.207"> {</span>
<a href="#l29.208"></a><span id="l29.208">   if (!thread)</span>
<a href="#l29.209"></a><span id="l29.209">     return NS_ERROR_NULL_POINTER;</span>
<a href="#l29.210"></a><span id="l29.210">   nsresult rv = NS_OK;</span>
<a href="#l29.211"></a><span id="l29.211" class="difflineat">@@ -2036,79 +2036,79 @@ nsMsgDatabase::MarkThreadIgnored(nsIMsgT</span>
<a href="#l29.212"></a><span id="l29.212">                                  nsIDBChangeListener *instigator)</span>
<a href="#l29.213"></a><span id="l29.213"> {</span>
<a href="#l29.214"></a><span id="l29.214">   NS_ENSURE_ARG(thread);</span>
<a href="#l29.215"></a><span id="l29.215">   PRUint32 threadFlags;</span>
<a href="#l29.216"></a><span id="l29.216">   thread-&gt;GetFlags(&amp;threadFlags);</span>
<a href="#l29.217"></a><span id="l29.217">   PRUint32 oldThreadFlags = threadFlags; // not quite right, since we probably want msg hdr flags.</span>
<a href="#l29.218"></a><span id="l29.218">   if (bIgnored)</span>
<a href="#l29.219"></a><span id="l29.219">   {</span>
<a href="#l29.220"></a><span id="l29.220" class="difflineminus">-    threadFlags |= MSG_FLAG_IGNORED;</span>
<a href="#l29.221"></a><span id="l29.221" class="difflineminus">-    threadFlags &amp;= ~MSG_FLAG_WATCHED;  // ignore is implicit un-watch</span>
<a href="#l29.222"></a><span id="l29.222" class="difflineplus">+    threadFlags |= nsMsgMessageFlags::Ignored;</span>
<a href="#l29.223"></a><span id="l29.223" class="difflineplus">+    threadFlags &amp;= ~nsMsgMessageFlags::Watched;  // ignore is implicit un-watch</span>
<a href="#l29.224"></a><span id="l29.224">   }</span>
<a href="#l29.225"></a><span id="l29.225">   else</span>
<a href="#l29.226"></a><span id="l29.226" class="difflineminus">-    threadFlags &amp;= ~MSG_FLAG_IGNORED;</span>
<a href="#l29.227"></a><span id="l29.227" class="difflineplus">+    threadFlags &amp;= ~nsMsgMessageFlags::Ignored;</span>
<a href="#l29.228"></a><span id="l29.228">   thread-&gt;SetFlags(threadFlags);</span>
<a href="#l29.229"></a><span id="l29.229"> </span>
<a href="#l29.230"></a><span id="l29.230">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msg;</span>
<a href="#l29.231"></a><span id="l29.231">   nsresult rv = GetMsgHdrForKey(threadKey, getter_AddRefs(msg));</span>
<a href="#l29.232"></a><span id="l29.232">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l29.233"></a><span id="l29.233">   return NotifyHdrChangeAll(msg, oldThreadFlags, threadFlags, instigator);</span>
<a href="#l29.234"></a><span id="l29.234"> }</span>
<a href="#l29.235"></a><span id="l29.235"> </span>
<a href="#l29.236"></a><span id="l29.236"> NS_IMETHODIMP</span>
<a href="#l29.237"></a><span id="l29.237"> nsMsgDatabase::MarkHeaderKilled(nsIMsgDBHdr *msg, PRBool bIgnored,</span>
<a href="#l29.238"></a><span id="l29.238">                            nsIDBChangeListener *instigator)</span>
<a href="#l29.239"></a><span id="l29.239"> {</span>
<a href="#l29.240"></a><span id="l29.240">   PRUint32 msgFlags;</span>
<a href="#l29.241"></a><span id="l29.241">   msg-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l29.242"></a><span id="l29.242">   PRUint32 oldFlags = msgFlags;</span>
<a href="#l29.243"></a><span id="l29.243">   if (bIgnored)</span>
<a href="#l29.244"></a><span id="l29.244" class="difflineminus">-    msgFlags |= MSG_FLAG_IGNORED;</span>
<a href="#l29.245"></a><span id="l29.245" class="difflineplus">+    msgFlags |= nsMsgMessageFlags::Ignored;</span>
<a href="#l29.246"></a><span id="l29.246">   else</span>
<a href="#l29.247"></a><span id="l29.247" class="difflineminus">-    msgFlags &amp;= ~MSG_FLAG_IGNORED;</span>
<a href="#l29.248"></a><span id="l29.248" class="difflineplus">+    msgFlags &amp;= ~nsMsgMessageFlags::Ignored;</span>
<a href="#l29.249"></a><span id="l29.249">   msg-&gt;SetFlags(msgFlags);</span>
<a href="#l29.250"></a><span id="l29.250"> </span>
<a href="#l29.251"></a><span id="l29.251">   return NotifyHdrChangeAll(msg, oldFlags, msgFlags, instigator);</span>
<a href="#l29.252"></a><span id="l29.252"> }</span>
<a href="#l29.253"></a><span id="l29.253"> </span>
<a href="#l29.254"></a><span id="l29.254"> NS_IMETHODIMP</span>
<a href="#l29.255"></a><span id="l29.255"> nsMsgDatabase::MarkThreadWatched(nsIMsgThread *thread, nsMsgKey threadKey, PRBool bWatched,</span>
<a href="#l29.256"></a><span id="l29.256">                                  nsIDBChangeListener *instigator)</span>
<a href="#l29.257"></a><span id="l29.257"> {</span>
<a href="#l29.258"></a><span id="l29.258">   NS_ENSURE_ARG(thread);</span>
<a href="#l29.259"></a><span id="l29.259">   PRUint32 threadFlags;</span>
<a href="#l29.260"></a><span id="l29.260">   thread-&gt;GetFlags(&amp;threadFlags);</span>
<a href="#l29.261"></a><span id="l29.261">   PRUint32 oldThreadFlags = threadFlags; // not quite right, since we probably want msg hdr flags.</span>
<a href="#l29.262"></a><span id="l29.262">   if (bWatched)</span>
<a href="#l29.263"></a><span id="l29.263">   {</span>
<a href="#l29.264"></a><span id="l29.264" class="difflineminus">-    threadFlags |= MSG_FLAG_WATCHED;</span>
<a href="#l29.265"></a><span id="l29.265" class="difflineminus">-    threadFlags &amp;= ~MSG_FLAG_IGNORED;  // watch is implicit un-ignore</span>
<a href="#l29.266"></a><span id="l29.266" class="difflineplus">+    threadFlags |= nsMsgMessageFlags::Watched;</span>
<a href="#l29.267"></a><span id="l29.267" class="difflineplus">+    threadFlags &amp;= ~nsMsgMessageFlags::Ignored;  // watch is implicit un-ignore</span>
<a href="#l29.268"></a><span id="l29.268">   }</span>
<a href="#l29.269"></a><span id="l29.269">   else</span>
<a href="#l29.270"></a><span id="l29.270" class="difflineminus">-    threadFlags &amp;= ~MSG_FLAG_WATCHED;</span>
<a href="#l29.271"></a><span id="l29.271" class="difflineplus">+    threadFlags &amp;= ~nsMsgMessageFlags::Watched;</span>
<a href="#l29.272"></a><span id="l29.272"> </span>
<a href="#l29.273"></a><span id="l29.273">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msg;</span>
<a href="#l29.274"></a><span id="l29.274">   GetMsgHdrForKey(threadKey, getter_AddRefs(msg));</span>
<a href="#l29.275"></a><span id="l29.275"> </span>
<a href="#l29.276"></a><span id="l29.276">   nsresult rv  = NotifyHdrChangeAll(msg, oldThreadFlags, threadFlags, instigator);</span>
<a href="#l29.277"></a><span id="l29.277">   thread-&gt;SetFlags(threadFlags);</span>
<a href="#l29.278"></a><span id="l29.278">   return rv;</span>
<a href="#l29.279"></a><span id="l29.279"> }</span>
<a href="#l29.280"></a><span id="l29.280"> </span>
<a href="#l29.281"></a><span id="l29.281"> NS_IMETHODIMP nsMsgDatabase::MarkMarked(nsMsgKey key, PRBool mark,</span>
<a href="#l29.282"></a><span id="l29.282">                                         nsIDBChangeListener *instigator)</span>
<a href="#l29.283"></a><span id="l29.283"> {</span>
<a href="#l29.284"></a><span id="l29.284" class="difflineminus">-  return SetKeyFlag(key, mark, MSG_FLAG_MARKED, instigator);</span>
<a href="#l29.285"></a><span id="l29.285" class="difflineplus">+  return SetKeyFlag(key, mark, nsMsgMessageFlags::Marked, instigator);</span>
<a href="#l29.286"></a><span id="l29.286"> }</span>
<a href="#l29.287"></a><span id="l29.287"> </span>
<a href="#l29.288"></a><span id="l29.288"> NS_IMETHODIMP nsMsgDatabase::MarkOffline(nsMsgKey key, PRBool offline,</span>
<a href="#l29.289"></a><span id="l29.289">                                          nsIDBChangeListener *instigator)</span>
<a href="#l29.290"></a><span id="l29.290"> {</span>
<a href="#l29.291"></a><span id="l29.291" class="difflineminus">-  return SetKeyFlag(key, offline, MSG_FLAG_OFFLINE, instigator);</span>
<a href="#l29.292"></a><span id="l29.292" class="difflineplus">+  return SetKeyFlag(key, offline, nsMsgMessageFlags::Offline, instigator);</span>
<a href="#l29.293"></a><span id="l29.293"> }</span>
<a href="#l29.294"></a><span id="l29.294"> </span>
<a href="#l29.295"></a><span id="l29.295"> NS_IMETHODIMP nsMsgDatabase::SetStringProperty(nsMsgKey aKey, const char *aProperty, const char *aValue)</span>
<a href="#l29.296"></a><span id="l29.296"> {</span>
<a href="#l29.297"></a><span id="l29.297">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l29.298"></a><span id="l29.298">   nsresult rv = GetMsgHdrForKey(aKey, getter_AddRefs(msgHdr));</span>
<a href="#l29.299"></a><span id="l29.299">   if (NS_FAILED(rv) || !msgHdr)</span>
<a href="#l29.300"></a><span id="l29.300">     return NS_MSG_MESSAGE_NOT_FOUND; // XXX return rv?</span>
<a href="#l29.301"></a><span id="l29.301" class="difflineat">@@ -2193,58 +2193,58 @@ NS_IMETHODIMP nsMsgDatabase::SetLabel(ns</span>
<a href="#l29.302"></a><span id="l29.302">     rv = SetKeyFlag(key, PR_TRUE, label &lt;&lt; 25, nsnull);</span>
<a href="#l29.303"></a><span id="l29.303">   }</span>
<a href="#l29.304"></a><span id="l29.304">   return rv;</span>
<a href="#l29.305"></a><span id="l29.305"> }</span>
<a href="#l29.306"></a><span id="l29.306"> </span>
<a href="#l29.307"></a><span id="l29.307"> NS_IMETHODIMP nsMsgDatabase::MarkImapDeleted(nsMsgKey key, PRBool deleted,</span>
<a href="#l29.308"></a><span id="l29.308">                                              nsIDBChangeListener *instigator)</span>
<a href="#l29.309"></a><span id="l29.309"> {</span>
<a href="#l29.310"></a><span id="l29.310" class="difflineminus">-  return SetKeyFlag(key, deleted, MSG_FLAG_IMAP_DELETED, instigator);</span>
<a href="#l29.311"></a><span id="l29.311" class="difflineplus">+  return SetKeyFlag(key, deleted, nsMsgMessageFlags::IMAPDeleted, instigator);</span>
<a href="#l29.312"></a><span id="l29.312"> }</span>
<a href="#l29.313"></a><span id="l29.313"> </span>
<a href="#l29.314"></a><span id="l29.314"> NS_IMETHODIMP nsMsgDatabase::MarkMDNNeeded(nsMsgKey key, PRBool bNeeded,</span>
<a href="#l29.315"></a><span id="l29.315">                                            nsIDBChangeListener *instigator /* = NULL */)</span>
<a href="#l29.316"></a><span id="l29.316"> {</span>
<a href="#l29.317"></a><span id="l29.317" class="difflineminus">-  return SetKeyFlag(key, bNeeded, MSG_FLAG_MDN_REPORT_NEEDED, instigator);</span>
<a href="#l29.318"></a><span id="l29.318" class="difflineplus">+  return SetKeyFlag(key, bNeeded, nsMsgMessageFlags::MDNReportNeeded, instigator);</span>
<a href="#l29.319"></a><span id="l29.319"> }</span>
<a href="#l29.320"></a><span id="l29.320"> </span>
<a href="#l29.321"></a><span id="l29.321"> NS_IMETHODIMP nsMsgDatabase::IsMDNNeeded(nsMsgKey key, PRBool *pNeeded)</span>
<a href="#l29.322"></a><span id="l29.322"> {</span>
<a href="#l29.323"></a><span id="l29.323">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l29.324"></a><span id="l29.324"> </span>
<a href="#l29.325"></a><span id="l29.325">   nsresult rv = GetMsgHdrForKey(key, getter_AddRefs(msgHdr));</span>
<a href="#l29.326"></a><span id="l29.326">   if (NS_FAILED(rv) || !msgHdr)</span>
<a href="#l29.327"></a><span id="l29.327">     return NS_MSG_MESSAGE_NOT_FOUND; // XXX return rv?</span>
<a href="#l29.328"></a><span id="l29.328"> </span>
<a href="#l29.329"></a><span id="l29.329">   PRUint32 flags;</span>
<a href="#l29.330"></a><span id="l29.330">   (void)msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l29.331"></a><span id="l29.331" class="difflineminus">-  *pNeeded = ((flags &amp; MSG_FLAG_MDN_REPORT_NEEDED) == MSG_FLAG_MDN_REPORT_NEEDED);</span>
<a href="#l29.332"></a><span id="l29.332" class="difflineplus">+  *pNeeded = ((flags &amp; nsMsgMessageFlags::MDNReportNeeded) == nsMsgMessageFlags::MDNReportNeeded);</span>
<a href="#l29.333"></a><span id="l29.333">   return rv;</span>
<a href="#l29.334"></a><span id="l29.334"> }</span>
<a href="#l29.335"></a><span id="l29.335"> </span>
<a href="#l29.336"></a><span id="l29.336"> </span>
<a href="#l29.337"></a><span id="l29.337"> nsresult nsMsgDatabase::MarkMDNSent(nsMsgKey key, PRBool bSent,</span>
<a href="#l29.338"></a><span id="l29.338">                                     nsIDBChangeListener *instigator /* = NULL */)</span>
<a href="#l29.339"></a><span id="l29.339"> {</span>
<a href="#l29.340"></a><span id="l29.340" class="difflineminus">-  return SetKeyFlag(key, bSent, MSG_FLAG_MDN_REPORT_SENT, instigator);</span>
<a href="#l29.341"></a><span id="l29.341" class="difflineplus">+  return SetKeyFlag(key, bSent, nsMsgMessageFlags::MDNReportSent, instigator);</span>
<a href="#l29.342"></a><span id="l29.342"> }</span>
<a href="#l29.343"></a><span id="l29.343"> </span>
<a href="#l29.344"></a><span id="l29.344"> </span>
<a href="#l29.345"></a><span id="l29.345"> nsresult nsMsgDatabase::IsMDNSent(nsMsgKey key, PRBool *pSent)</span>
<a href="#l29.346"></a><span id="l29.346"> {</span>
<a href="#l29.347"></a><span id="l29.347">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l29.348"></a><span id="l29.348"> </span>
<a href="#l29.349"></a><span id="l29.349">   nsresult rv = GetMsgHdrForKey(key, getter_AddRefs(msgHdr));</span>
<a href="#l29.350"></a><span id="l29.350">   if (NS_FAILED(rv) || !msgHdr)</span>
<a href="#l29.351"></a><span id="l29.351">     return NS_MSG_MESSAGE_NOT_FOUND; // XXX return rv?</span>
<a href="#l29.352"></a><span id="l29.352"> </span>
<a href="#l29.353"></a><span id="l29.353">   PRUint32 flags;</span>
<a href="#l29.354"></a><span id="l29.354">   (void)msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l29.355"></a><span id="l29.355" class="difflineminus">-  *pSent = flags &amp; MSG_FLAG_MDN_REPORT_SENT;</span>
<a href="#l29.356"></a><span id="l29.356" class="difflineplus">+  *pSent = flags &amp; nsMsgMessageFlags::MDNReportSent;</span>
<a href="#l29.357"></a><span id="l29.357">   return rv;</span>
<a href="#l29.358"></a><span id="l29.358"> }</span>
<a href="#l29.359"></a><span id="l29.359"> </span>
<a href="#l29.360"></a><span id="l29.360"> </span>
<a href="#l29.361"></a><span id="l29.361"> nsresult  nsMsgDatabase::SetKeyFlag(nsMsgKey key, PRBool set, PRUint32 flag,</span>
<a href="#l29.362"></a><span id="l29.362">                                      nsIDBChangeListener *instigator)</span>
<a href="#l29.363"></a><span id="l29.363"> {</span>
<a href="#l29.364"></a><span id="l29.364">   nsresult rv;</span>
<a href="#l29.365"></a><span id="l29.365" class="difflineat">@@ -2281,17 +2281,17 @@ nsresult nsMsgDatabase::SetMsgHdrFlag(ns</span>
<a href="#l29.366"></a><span id="l29.366">   if (oldFlags == flags)</span>
<a href="#l29.367"></a><span id="l29.367">     return NS_OK;</span>
<a href="#l29.368"></a><span id="l29.368"> </span>
<a href="#l29.369"></a><span id="l29.369">   return NotifyHdrChangeAll(msgHdr, oldFlags, flags, instigator);</span>
<a href="#l29.370"></a><span id="l29.370"> }</span>
<a href="#l29.371"></a><span id="l29.371"> </span>
<a href="#l29.372"></a><span id="l29.372"> // Helper routine - lowest level of flag setting - returns PR_TRUE if flags change,</span>
<a href="#l29.373"></a><span id="l29.373"> // PR_FALSE otherwise.</span>
<a href="#l29.374"></a><span id="l29.374" class="difflineminus">-PRBool nsMsgDatabase::SetHdrFlag(nsIMsgDBHdr *msgHdr, PRBool bSet, MsgFlags flag)</span>
<a href="#l29.375"></a><span id="l29.375" class="difflineplus">+PRBool nsMsgDatabase::SetHdrFlag(nsIMsgDBHdr *msgHdr, PRBool bSet, nsMsgMessageFlagType flag)</span>
<a href="#l29.376"></a><span id="l29.376"> {</span>
<a href="#l29.377"></a><span id="l29.377">   PRUint32 statusFlags;</span>
<a href="#l29.378"></a><span id="l29.378">   (void)msgHdr-&gt;GetFlags(&amp;statusFlags);</span>
<a href="#l29.379"></a><span id="l29.379">   PRUint32 currentStatusFlags = GetStatusFlags(msgHdr, statusFlags);</span>
<a href="#l29.380"></a><span id="l29.380">   PRBool flagAlreadySet = (currentStatusFlags &amp; flag) != 0;</span>
<a href="#l29.381"></a><span id="l29.381"> </span>
<a href="#l29.382"></a><span id="l29.382">   if ((flagAlreadySet &amp;&amp; !bSet) || (!flagAlreadySet &amp;&amp; bSet))</span>
<a href="#l29.383"></a><span id="l29.383">   {</span>
<a href="#l29.384"></a><span id="l29.384" class="difflineat">@@ -2343,24 +2343,24 @@ NS_IMETHODIMP nsMsgDatabase::MarkHdrRead</span>
<a href="#l29.385"></a><span id="l29.385">     return MarkHdrReadInDB(msgHdr, bRead, instigator);</span>
<a href="#l29.386"></a><span id="l29.386">   }</span>
<a href="#l29.387"></a><span id="l29.387">   return NS_OK;</span>
<a href="#l29.388"></a><span id="l29.388"> }</span>
<a href="#l29.389"></a><span id="l29.389"> </span>
<a href="#l29.390"></a><span id="l29.390"> NS_IMETHODIMP nsMsgDatabase::MarkHdrReplied(nsIMsgDBHdr *msgHdr, PRBool bReplied,</span>
<a href="#l29.391"></a><span id="l29.391">                          nsIDBChangeListener *instigator)</span>
<a href="#l29.392"></a><span id="l29.392"> {</span>
<a href="#l29.393"></a><span id="l29.393" class="difflineminus">-  return SetMsgHdrFlag(msgHdr, bReplied, MSG_FLAG_REPLIED, instigator);</span>
<a href="#l29.394"></a><span id="l29.394" class="difflineplus">+  return SetMsgHdrFlag(msgHdr, bReplied, nsMsgMessageFlags::Replied, instigator);</span>
<a href="#l29.395"></a><span id="l29.395"> }</span>
<a href="#l29.396"></a><span id="l29.396"> </span>
<a href="#l29.397"></a><span id="l29.397"> </span>
<a href="#l29.398"></a><span id="l29.398"> NS_IMETHODIMP nsMsgDatabase::MarkHdrMarked(nsIMsgDBHdr *msgHdr, PRBool mark,</span>
<a href="#l29.399"></a><span id="l29.399">                          nsIDBChangeListener *instigator)</span>
<a href="#l29.400"></a><span id="l29.400"> {</span>
<a href="#l29.401"></a><span id="l29.401" class="difflineminus">-  return SetMsgHdrFlag(msgHdr, mark, MSG_FLAG_MARKED, instigator);</span>
<a href="#l29.402"></a><span id="l29.402" class="difflineplus">+  return SetMsgHdrFlag(msgHdr, mark, nsMsgMessageFlags::Marked, instigator);</span>
<a href="#l29.403"></a><span id="l29.403"> }</span>
<a href="#l29.404"></a><span id="l29.404"> </span>
<a href="#l29.405"></a><span id="l29.405"> </span>
<a href="#l29.406"></a><span id="l29.406"> NS_IMETHODIMP nsMsgDatabase::MarkAllRead(nsTArray&lt;nsMsgKey&gt; *thoseMarked)</span>
<a href="#l29.407"></a><span id="l29.407"> {</span>
<a href="#l29.408"></a><span id="l29.408">   nsresult    rv;</span>
<a href="#l29.409"></a><span id="l29.409">   nsMsgHdr  *pHeader;</span>
<a href="#l29.410"></a><span id="l29.410"> </span>
<a href="#l29.411"></a><span id="l29.411" class="difflineat">@@ -2475,18 +2475,18 @@ NS_IMETHODIMP nsMsgDatabase::ClearNewLis</span>
<a href="#l29.412"></a><span id="l29.412">       nsMsgKey lastNewKey = saveNewSet.ElementAt(elementIndex);</span>
<a href="#l29.413"></a><span id="l29.413">       nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l29.414"></a><span id="l29.414">       err = GetMsgHdrForKey(lastNewKey, getter_AddRefs(msgHdr));</span>
<a href="#l29.415"></a><span id="l29.415">       if (NS_SUCCEEDED(err))</span>
<a href="#l29.416"></a><span id="l29.416">       {</span>
<a href="#l29.417"></a><span id="l29.417">         PRUint32 flags;</span>
<a href="#l29.418"></a><span id="l29.418">         (void)msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l29.419"></a><span id="l29.419"> </span>
<a href="#l29.420"></a><span id="l29.420" class="difflineminus">-        if ((flags | MSG_FLAG_NEW) != flags)</span>
<a href="#l29.421"></a><span id="l29.421" class="difflineminus">-          NotifyHdrChangeAll(msgHdr, flags | MSG_FLAG_NEW, flags, nsnull);</span>
<a href="#l29.422"></a><span id="l29.422" class="difflineplus">+        if ((flags | nsMsgMessageFlags::New) != flags)</span>
<a href="#l29.423"></a><span id="l29.423" class="difflineplus">+          NotifyHdrChangeAll(msgHdr, flags | nsMsgMessageFlags::New, flags, nsnull);</span>
<a href="#l29.424"></a><span id="l29.424">       }</span>
<a href="#l29.425"></a><span id="l29.425">       if (elementIndex == 0)</span>
<a href="#l29.426"></a><span id="l29.426">         break;</span>
<a href="#l29.427"></a><span id="l29.427">     }</span>
<a href="#l29.428"></a><span id="l29.428">   }</span>
<a href="#l29.429"></a><span id="l29.429">   return err;</span>
<a href="#l29.430"></a><span id="l29.430"> }</span>
<a href="#l29.431"></a><span id="l29.431"> </span>
<a href="#l29.432"></a><span id="l29.432" class="difflineat">@@ -2633,17 +2633,17 @@ nsresult nsMsgDBEnumerator::PrefetchNext</span>
<a href="#l29.433"></a><span id="l29.433">     if (NS_FAILED(rv))</span>
<a href="#l29.434"></a><span id="l29.434">       return rv;</span>
<a href="#l29.435"></a><span id="l29.435"> </span>
<a href="#l29.436"></a><span id="l29.436">     if (mResultHdr)</span>
<a href="#l29.437"></a><span id="l29.437">       mResultHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l29.438"></a><span id="l29.438">     else</span>
<a href="#l29.439"></a><span id="l29.439">       flags = 0;</span>
<a href="#l29.440"></a><span id="l29.440">   }</span>
<a href="#l29.441"></a><span id="l29.441" class="difflineminus">-  while (mFilter &amp;&amp; NS_FAILED(mFilter(mResultHdr, mClosure)) &amp;&amp; !(flags &amp; MSG_FLAG_EXPUNGED));</span>
<a href="#l29.442"></a><span id="l29.442" class="difflineplus">+  while (mFilter &amp;&amp; NS_FAILED(mFilter(mResultHdr, mClosure)) &amp;&amp; !(flags &amp; nsMsgMessageFlags::Expunged));</span>
<a href="#l29.443"></a><span id="l29.443"> </span>
<a href="#l29.444"></a><span id="l29.444">   if (mResultHdr)</span>
<a href="#l29.445"></a><span id="l29.445">   {</span>
<a href="#l29.446"></a><span id="l29.446">     mNextPrefetched = PR_TRUE;</span>
<a href="#l29.447"></a><span id="l29.447">     return NS_OK;</span>
<a href="#l29.448"></a><span id="l29.448">   }</span>
<a href="#l29.449"></a><span id="l29.449">   return NS_ERROR_FAILURE;</span>
<a href="#l29.450"></a><span id="l29.450"> }</span>
<a href="#l29.451"></a><span id="l29.451" class="difflineat">@@ -3013,20 +3013,20 @@ NS_IMETHODIMP nsMsgDatabase::AddNewHdrTo</span>
<a href="#l29.452"></a><span id="l29.452">     nsMsgKey key;</span>
<a href="#l29.453"></a><span id="l29.453">     PRUint32 flags;</span>
<a href="#l29.454"></a><span id="l29.454"> </span>
<a href="#l29.455"></a><span id="l29.455">     newHdr-&gt;GetMessageKey(&amp;key);</span>
<a href="#l29.456"></a><span id="l29.456">     hdr-&gt;GetRawFlags(&amp;flags);</span>
<a href="#l29.457"></a><span id="l29.457">     // use raw flags instead of GetFlags, because GetFlags will</span>
<a href="#l29.458"></a><span id="l29.458">     // pay attention to what's in m_newSet, and this new hdr isn't</span>
<a href="#l29.459"></a><span id="l29.459">     // in m_newSet yet.</span>
<a href="#l29.460"></a><span id="l29.460" class="difflineminus">-    if (flags &amp; MSG_FLAG_NEW)</span>
<a href="#l29.461"></a><span id="l29.461" class="difflineplus">+    if (flags &amp; nsMsgMessageFlags::New)</span>
<a href="#l29.462"></a><span id="l29.462">     {</span>
<a href="#l29.463"></a><span id="l29.463">       PRUint32 newFlags;</span>
<a href="#l29.464"></a><span id="l29.464" class="difflineminus">-      newHdr-&gt;AndFlags(~MSG_FLAG_NEW, &amp;newFlags);  // make sure not filed out</span>
<a href="#l29.465"></a><span id="l29.465" class="difflineplus">+      newHdr-&gt;AndFlags(~nsMsgMessageFlags::New, &amp;newFlags);  // make sure not filed out</span>
<a href="#l29.466"></a><span id="l29.466">       AddToNewList(key);</span>
<a href="#l29.467"></a><span id="l29.467">     }</span>
<a href="#l29.468"></a><span id="l29.468">     if (m_dbFolderInfo != NULL)</span>
<a href="#l29.469"></a><span id="l29.469">     {</span>
<a href="#l29.470"></a><span id="l29.470">       m_dbFolderInfo-&gt;ChangeNumMessages(1);</span>
<a href="#l29.471"></a><span id="l29.471">       PRBool isRead = PR_TRUE;</span>
<a href="#l29.472"></a><span id="l29.472">       IsHeaderRead(newHdr, &amp;isRead);</span>
<a href="#l29.473"></a><span id="l29.473">       if (!isRead)</span>
<a href="#l29.474"></a><span id="l29.474" class="difflineat">@@ -3972,17 +3972,17 @@ nsresult nsMsgDatabase::ThreadNewHdr(nsM</span>
<a href="#l29.475"></a><span id="l29.475">     }</span>
<a href="#l29.476"></a><span id="l29.476">   }</span>
<a href="#l29.477"></a><span id="l29.477">   // if user hasn't said &quot;only thread by ref headers&quot;, thread by subject</span>
<a href="#l29.478"></a><span id="l29.478">   if (!thread &amp;&amp; !UseStrictThreading())</span>
<a href="#l29.479"></a><span id="l29.479">   {</span>
<a href="#l29.480"></a><span id="l29.480">     // try subject threading if we couldn't find a reference and the subject starts with Re:</span>
<a href="#l29.481"></a><span id="l29.481">     nsCString subject;</span>
<a href="#l29.482"></a><span id="l29.482">     newHdr-&gt;GetSubject(getter_Copies(subject));</span>
<a href="#l29.483"></a><span id="l29.483" class="difflineminus">-    if (ThreadBySubjectWithoutRe() || (newHdrFlags &amp; MSG_FLAG_HAS_RE))</span>
<a href="#l29.484"></a><span id="l29.484" class="difflineplus">+    if (ThreadBySubjectWithoutRe() || (newHdrFlags &amp; nsMsgMessageFlags::HasRe))</span>
<a href="#l29.485"></a><span id="l29.485">     {</span>
<a href="#l29.486"></a><span id="l29.486">       nsCAutoString cSubject(subject);</span>
<a href="#l29.487"></a><span id="l29.487">       thread = getter_AddRefs(GetThreadForSubject(cSubject));</span>
<a href="#l29.488"></a><span id="l29.488">       if(thread)</span>
<a href="#l29.489"></a><span id="l29.489">       {</span>
<a href="#l29.490"></a><span id="l29.490">         thread-&gt;GetThreadKey(&amp;threadId);</span>
<a href="#l29.491"></a><span id="l29.491">         newHdr-&gt;SetThreadId(threadId);</span>
<a href="#l29.492"></a><span id="l29.492">         //TRACE(&quot;threading based on subject %s\n&quot;, (const char *) msgHdr-&gt;m_subject);</span>
<a href="#l29.493"></a><span id="l29.493" class="difflineat">@@ -4280,17 +4280,17 @@ NS_IMETHODIMP  nsMsgDatabase::RemoveOffl</span>
<a href="#l29.494"></a><span id="l29.494">   NS_ASSERTION(PR_FALSE, &quot;overridden by nsMailDatabase&quot;);</span>
<a href="#l29.495"></a><span id="l29.495">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l29.496"></a><span id="l29.496"> }</span>
<a href="#l29.497"></a><span id="l29.497"> </span>
<a href="#l29.498"></a><span id="l29.498"> </span>
<a href="#l29.499"></a><span id="l29.499"> NS_IMETHODIMP nsMsgDatabase::ListAllOfflineMsgs(nsTArray&lt;nsMsgKey&gt; *outputKeys)</span>
<a href="#l29.500"></a><span id="l29.500"> {</span>
<a href="#l29.501"></a><span id="l29.501">   nsCOMPtr &lt;nsISimpleEnumerator&gt; enumerator;</span>
<a href="#l29.502"></a><span id="l29.502" class="difflineminus">-  PRUint32 flag = MSG_FLAG_OFFLINE;</span>
<a href="#l29.503"></a><span id="l29.503" class="difflineplus">+  PRUint32 flag = nsMsgMessageFlags::Offline;</span>
<a href="#l29.504"></a><span id="l29.504">   // if we change this routine to return an enumerator that generates the keys</span>
<a href="#l29.505"></a><span id="l29.505">   // one by one, we'll need to somehow make a copy of flag for the enumerator</span>
<a href="#l29.506"></a><span id="l29.506">   // to own, since the enumerator will persist past the life of flag on the stack.</span>
<a href="#l29.507"></a><span id="l29.507">   nsresult rv = EnumerateMessagesWithFlag(getter_AddRefs(enumerator), &amp;flag);</span>
<a href="#l29.508"></a><span id="l29.508">   if (NS_SUCCEEDED(rv) &amp;&amp; enumerator)</span>
<a href="#l29.509"></a><span id="l29.509">   {</span>
<a href="#l29.510"></a><span id="l29.510">     PRBool hasMoreElements;</span>
<a href="#l29.511"></a><span id="l29.511">     while(NS_SUCCEEDED(enumerator-&gt;HasMoreElements(&amp;hasMoreElements)) &amp;&amp; hasMoreElements)</span>
<a href="#l29.512"></a><span id="l29.512" class="difflineat">@@ -4703,17 +4703,17 @@ nsresult nsMsgDatabase::PurgeMessagesOld</span>
<a href="#l29.513"></a><span id="l29.513">     NS_ASSERTION(NS_SUCCEEDED(rv), &quot;nsMsgDBEnumerator broken&quot;);</span>
<a href="#l29.514"></a><span id="l29.514">     if (NS_FAILED(rv))</span>
<a href="#l29.515"></a><span id="l29.515">       break;</span>
<a href="#l29.516"></a><span id="l29.516"> </span>
<a href="#l29.517"></a><span id="l29.517">     if (!applyToFlaggedMessages)</span>
<a href="#l29.518"></a><span id="l29.518">     {</span>
<a href="#l29.519"></a><span id="l29.519">       PRUint32 flags;</span>
<a href="#l29.520"></a><span id="l29.520">       (void)pHeader-&gt;GetFlags(&amp;flags);</span>
<a href="#l29.521"></a><span id="l29.521" class="difflineminus">-      if (flags &amp; MSG_FLAG_MARKED)</span>
<a href="#l29.522"></a><span id="l29.522" class="difflineplus">+      if (flags &amp; nsMsgMessageFlags::Marked)</span>
<a href="#l29.523"></a><span id="l29.523">         continue;</span>
<a href="#l29.524"></a><span id="l29.524">     }</span>
<a href="#l29.525"></a><span id="l29.525"> </span>
<a href="#l29.526"></a><span id="l29.526">     if (keepUnreadMessagesOnly)</span>
<a href="#l29.527"></a><span id="l29.527">     {</span>
<a href="#l29.528"></a><span id="l29.528">       PRBool isRead;</span>
<a href="#l29.529"></a><span id="l29.529">       IsHeaderRead(pHeader, &amp;isRead);</span>
<a href="#l29.530"></a><span id="l29.530">       if (isRead)</span>
<a href="#l29.531"></a><span id="l29.531" class="difflineat">@@ -4777,17 +4777,17 @@ nsresult nsMsgDatabase::PurgeExcessMessa</span>
<a href="#l29.532"></a><span id="l29.532">     NS_ASSERTION(NS_SUCCEEDED(rv), &quot;nsMsgDBEnumerator broken&quot;);</span>
<a href="#l29.533"></a><span id="l29.533">     if (NS_FAILED(rv))</span>
<a href="#l29.534"></a><span id="l29.534">       break;</span>
<a href="#l29.535"></a><span id="l29.535"> </span>
<a href="#l29.536"></a><span id="l29.536">     if (!applyToFlaggedMessages)</span>
<a href="#l29.537"></a><span id="l29.537">     {</span>
<a href="#l29.538"></a><span id="l29.538">       PRUint32 flags;</span>
<a href="#l29.539"></a><span id="l29.539">       (void)pHeader-&gt;GetFlags(&amp;flags);</span>
<a href="#l29.540"></a><span id="l29.540" class="difflineminus">-      if (flags &amp; MSG_FLAG_MARKED)</span>
<a href="#l29.541"></a><span id="l29.541" class="difflineplus">+      if (flags &amp; nsMsgMessageFlags::Marked)</span>
<a href="#l29.542"></a><span id="l29.542">         continue;</span>
<a href="#l29.543"></a><span id="l29.543">     }</span>
<a href="#l29.544"></a><span id="l29.544"> </span>
<a href="#l29.545"></a><span id="l29.545">     if (keepUnreadMessagesOnly)</span>
<a href="#l29.546"></a><span id="l29.546">     {</span>
<a href="#l29.547"></a><span id="l29.547">       PRBool isRead;</span>
<a href="#l29.548"></a><span id="l29.548">       IsHeaderRead(pHeader, &amp;isRead);</span>
<a href="#l29.549"></a><span id="l29.549">       if (isRead)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l30.1"></a><span id="l30.1" class="difflineminus">--- a/mailnews/db/msgdb/src/nsMsgHdr.cpp</span>
<a href="#l30.2"></a><span id="l30.2" class="difflineplus">+++ b/mailnews/db/msgdb/src/nsMsgHdr.cpp</span>
<a href="#l30.3"></a><span id="l30.3" class="difflineat">@@ -119,17 +119,17 @@ nsresult nsMsgHdr::InitFlags()</span>
<a href="#l30.4"></a><span id="l30.4">   nsresult err = NS_OK;</span>
<a href="#l30.5"></a><span id="l30.5"> </span>
<a href="#l30.6"></a><span id="l30.6">   if (!m_mdb)</span>
<a href="#l30.7"></a><span id="l30.7">     return NS_ERROR_NULL_POINTER;</span>
<a href="#l30.8"></a><span id="l30.8"> </span>
<a href="#l30.9"></a><span id="l30.9">   if(!(m_initedValues &amp; FLAGS_INITED))</span>
<a href="#l30.10"></a><span id="l30.10">   {</span>
<a href="#l30.11"></a><span id="l30.11">     err = GetUInt32Column(m_mdb-&gt;m_flagsColumnToken, &amp;m_flags);</span>
<a href="#l30.12"></a><span id="l30.12" class="difflineminus">-    m_flags &amp;= ~MSG_FLAG_NEW; // don't get new flag from MDB</span>
<a href="#l30.13"></a><span id="l30.13" class="difflineplus">+    m_flags &amp;= ~nsMsgMessageFlags::New; // don't get new flag from MDB</span>
<a href="#l30.14"></a><span id="l30.14"> </span>
<a href="#l30.15"></a><span id="l30.15">     if(NS_SUCCEEDED(err))</span>
<a href="#l30.16"></a><span id="l30.16">       m_initedValues |= FLAGS_INITED;</span>
<a href="#l30.17"></a><span id="l30.17">   }</span>
<a href="#l30.18"></a><span id="l30.18"> </span>
<a href="#l30.19"></a><span id="l30.19">   return err;</span>
<a href="#l30.20"></a><span id="l30.20"> </span>
<a href="#l30.21"></a><span id="l30.21"> }</span>
<a href="#l30.22"></a><span id="l30.22" class="difflineat">@@ -198,30 +198,30 @@ NS_IMETHODIMP nsMsgHdr::GetFlags(PRUint3</span>
<a href="#l30.23"></a><span id="l30.23"> {</span>
<a href="#l30.24"></a><span id="l30.24">   if (!(m_initedValues &amp; FLAGS_INITED))</span>
<a href="#l30.25"></a><span id="l30.25">     InitFlags();</span>
<a href="#l30.26"></a><span id="l30.26">   if (m_mdb)</span>
<a href="#l30.27"></a><span id="l30.27">     *result = m_mdb-&gt;GetStatusFlags(this, m_flags);</span>
<a href="#l30.28"></a><span id="l30.28">   else</span>
<a href="#l30.29"></a><span id="l30.29">     *result = m_flags;</span>
<a href="#l30.30"></a><span id="l30.30"> #ifdef DEBUG_bienvenu</span>
<a href="#l30.31"></a><span id="l30.31" class="difflineminus">-  NS_ASSERTION(! (*result &amp; (MSG_FLAG_ELIDED)), &quot;shouldn't be set in db&quot;);</span>
<a href="#l30.32"></a><span id="l30.32" class="difflineplus">+  NS_ASSERTION(! (*result &amp; (nsMsgMessageFlags::Elided)), &quot;shouldn't be set in db&quot;);</span>
<a href="#l30.33"></a><span id="l30.33"> #endif</span>
<a href="#l30.34"></a><span id="l30.34">   return NS_OK;</span>
<a href="#l30.35"></a><span id="l30.35"> }</span>
<a href="#l30.36"></a><span id="l30.36"> </span>
<a href="#l30.37"></a><span id="l30.37"> NS_IMETHODIMP nsMsgHdr::SetFlags(PRUint32 flags)</span>
<a href="#l30.38"></a><span id="l30.38"> {</span>
<a href="#l30.39"></a><span id="l30.39"> #ifdef DEBUG_bienvenu</span>
<a href="#l30.40"></a><span id="l30.40" class="difflineminus">-  NS_ASSERTION(! (flags &amp; (MSG_FLAG_ELIDED)), &quot;shouldn't set this flag on db&quot;);</span>
<a href="#l30.41"></a><span id="l30.41" class="difflineplus">+  NS_ASSERTION(! (flags &amp; (nsMsgMessageFlags::Elided)), &quot;shouldn't set this flag on db&quot;);</span>
<a href="#l30.42"></a><span id="l30.42"> #endif</span>
<a href="#l30.43"></a><span id="l30.43">   m_initedValues |= FLAGS_INITED;</span>
<a href="#l30.44"></a><span id="l30.44">   m_flags = flags;</span>
<a href="#l30.45"></a><span id="l30.45" class="difflineminus">-  // don't write out MSG_FLAG_NEW to MDB.</span>
<a href="#l30.46"></a><span id="l30.46" class="difflineminus">-  return SetUInt32Column(m_flags &amp; ~MSG_FLAG_NEW, m_mdb-&gt;m_flagsColumnToken);</span>
<a href="#l30.47"></a><span id="l30.47" class="difflineplus">+  // don't write out nsMsgMessageFlags::New to MDB.</span>
<a href="#l30.48"></a><span id="l30.48" class="difflineplus">+  return SetUInt32Column(m_flags &amp; ~nsMsgMessageFlags::New, m_mdb-&gt;m_flagsColumnToken);</span>
<a href="#l30.49"></a><span id="l30.49"> }</span>
<a href="#l30.50"></a><span id="l30.50"> </span>
<a href="#l30.51"></a><span id="l30.51"> NS_IMETHODIMP nsMsgHdr::OrFlags(PRUint32 flags, PRUint32 *result)</span>
<a href="#l30.52"></a><span id="l30.52"> {</span>
<a href="#l30.53"></a><span id="l30.53">   if (!(m_initedValues &amp; FLAGS_INITED))</span>
<a href="#l30.54"></a><span id="l30.54">     InitFlags();</span>
<a href="#l30.55"></a><span id="l30.55">   if ((m_flags &amp; flags) != flags)</span>
<a href="#l30.56"></a><span id="l30.56">     SetFlags (m_flags | flags);</span>
<a href="#l30.57"></a><span id="l30.57" class="difflineat">@@ -603,17 +603,17 @@ NS_IMETHODIMP nsMsgHdr::GetAccountKey(ch</span>
<a href="#l30.58"></a><span id="l30.58"> NS_IMETHODIMP nsMsgHdr::GetMessageOffset(PRUint32 *result)</span>
<a href="#l30.59"></a><span id="l30.59"> {</span>
<a href="#l30.60"></a><span id="l30.60">   NS_ENSURE_ARG(result);</span>
<a href="#l30.61"></a><span id="l30.61"> </span>
<a href="#l30.62"></a><span id="l30.62">   // if we have the message body offline, then return the message offset column</span>
<a href="#l30.63"></a><span id="l30.63">   // (this will only be true for news and imap messages).</span>
<a href="#l30.64"></a><span id="l30.64">   PRUint32 rawFlags;</span>
<a href="#l30.65"></a><span id="l30.65">   GetRawFlags(&amp;rawFlags);</span>
<a href="#l30.66"></a><span id="l30.66" class="difflineminus">-  if (rawFlags &amp; MSG_FLAG_OFFLINE)</span>
<a href="#l30.67"></a><span id="l30.67" class="difflineplus">+  if (rawFlags &amp; nsMsgMessageFlags::Offline)</span>
<a href="#l30.68"></a><span id="l30.68">   {</span>
<a href="#l30.69"></a><span id="l30.69">     return GetUInt32Column(m_mdb-&gt;m_offlineMsgOffsetColumnToken, result);</span>
<a href="#l30.70"></a><span id="l30.70">   }</span>
<a href="#l30.71"></a><span id="l30.71">   else</span>
<a href="#l30.72"></a><span id="l30.72">   {</span>
<a href="#l30.73"></a><span id="l30.73">     *result = m_messageKey;</span>
<a href="#l30.74"></a><span id="l30.74">     return NS_OK;</span>
<a href="#l30.75"></a><span id="l30.75">   }</span>
<a href="#l30.76"></a><span id="l30.76" class="difflineat">@@ -915,26 +915,26 @@ PRBool nsMsgHdr::IsAncestorOf(nsIMsgDBHd</span>
<a href="#l30.77"></a><span id="l30.77">   return (strstr(references, messageId.get()) != nsnull);</span>
<a href="#l30.78"></a><span id="l30.78"> }</span>
<a href="#l30.79"></a><span id="l30.79"> </span>
<a href="#l30.80"></a><span id="l30.80"> NS_IMETHODIMP nsMsgHdr::GetIsRead(PRBool *isRead)</span>
<a href="#l30.81"></a><span id="l30.81"> {</span>
<a href="#l30.82"></a><span id="l30.82">   NS_ENSURE_ARG_POINTER(isRead);</span>
<a href="#l30.83"></a><span id="l30.83">   if (!(m_initedValues &amp; FLAGS_INITED))</span>
<a href="#l30.84"></a><span id="l30.84">     InitFlags();</span>
<a href="#l30.85"></a><span id="l30.85" class="difflineminus">-  *isRead = m_flags &amp; MSG_FLAG_READ;</span>
<a href="#l30.86"></a><span id="l30.86" class="difflineplus">+  *isRead = m_flags &amp; nsMsgMessageFlags::Read;</span>
<a href="#l30.87"></a><span id="l30.87">   return NS_OK;</span>
<a href="#l30.88"></a><span id="l30.88"> }</span>
<a href="#l30.89"></a><span id="l30.89"> </span>
<a href="#l30.90"></a><span id="l30.90"> NS_IMETHODIMP nsMsgHdr::GetIsFlagged(PRBool *isFlagged)</span>
<a href="#l30.91"></a><span id="l30.91"> {</span>
<a href="#l30.92"></a><span id="l30.92">   NS_ENSURE_ARG_POINTER(isFlagged);</span>
<a href="#l30.93"></a><span id="l30.93">   if (!(m_initedValues &amp; FLAGS_INITED))</span>
<a href="#l30.94"></a><span id="l30.94">     InitFlags();</span>
<a href="#l30.95"></a><span id="l30.95" class="difflineminus">-  *isFlagged = m_flags &amp; MSG_FLAG_MARKED;</span>
<a href="#l30.96"></a><span id="l30.96" class="difflineplus">+  *isFlagged = m_flags &amp; nsMsgMessageFlags::Marked;</span>
<a href="#l30.97"></a><span id="l30.97">   return NS_OK;</span>
<a href="#l30.98"></a><span id="l30.98"> }</span>
<a href="#l30.99"></a><span id="l30.99"> </span>
<a href="#l30.100"></a><span id="l30.100"> void nsMsgHdr::ReparentInThread(nsIMsgThread *thread)</span>
<a href="#l30.101"></a><span id="l30.101"> {</span>
<a href="#l30.102"></a><span id="l30.102">   NS_WARNING(&quot;Borked message header, attempting to fix!&quot;);</span>
<a href="#l30.103"></a><span id="l30.103">   PRUint32 numChildren;</span>
<a href="#l30.104"></a><span id="l30.104">   thread-&gt;GetNumChildren(&amp;numChildren);</span>
<a href="#l30.105"></a><span id="l30.105" class="difflineat">@@ -976,17 +976,17 @@ void nsMsgHdr::ReparentInThread(nsIMsgTh</span>
<a href="#l30.106"></a><span id="l30.106">     }</span>
<a href="#l30.107"></a><span id="l30.107">   }</span>
<a href="#l30.108"></a><span id="l30.108"> }</span>
<a href="#l30.109"></a><span id="l30.109"> </span>
<a href="#l30.110"></a><span id="l30.110"> PRBool nsMsgHdr::IsAncestorKilled(PRUint32 ancestorsToCheck)</span>
<a href="#l30.111"></a><span id="l30.111"> {</span>
<a href="#l30.112"></a><span id="l30.112">   if (!(m_initedValues &amp; FLAGS_INITED))</span>
<a href="#l30.113"></a><span id="l30.113">     InitFlags();</span>
<a href="#l30.114"></a><span id="l30.114" class="difflineminus">-  PRBool isKilled = m_flags &amp; MSG_FLAG_IGNORED;</span>
<a href="#l30.115"></a><span id="l30.115" class="difflineplus">+  PRBool isKilled = m_flags &amp; nsMsgMessageFlags::Ignored;</span>
<a href="#l30.116"></a><span id="l30.116"> </span>
<a href="#l30.117"></a><span id="l30.117">   if (!isKilled)</span>
<a href="#l30.118"></a><span id="l30.118">   {</span>
<a href="#l30.119"></a><span id="l30.119">     nsMsgKey threadParent;</span>
<a href="#l30.120"></a><span id="l30.120">     GetThreadParent(&amp;threadParent);</span>
<a href="#l30.121"></a><span id="l30.121"> </span>
<a href="#l30.122"></a><span id="l30.122">     if (threadParent == m_messageKey)</span>
<a href="#l30.123"></a><span id="l30.123">     {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l31.1"></a><span id="l31.1" class="difflineminus">--- a/mailnews/db/msgdb/src/nsMsgThread.cpp</span>
<a href="#l31.2"></a><span id="l31.2" class="difflineplus">+++ b/mailnews/db/msgdb/src/nsMsgThread.cpp</span>
<a href="#l31.3"></a><span id="l31.3" class="difflineat">@@ -231,20 +231,20 @@ NS_IMETHODIMP nsMsgThread::AddChild(nsIM</span>
<a href="#l31.4"></a><span id="l31.4"> </span>
<a href="#l31.5"></a><span id="l31.5">   nsIMdbRow *hdrRow = hdr-&gt;GetMDBRow();</span>
<a href="#l31.6"></a><span id="l31.6">   hdr-&gt;GetRawFlags(&amp;newHdrFlags);</span>
<a href="#l31.7"></a><span id="l31.7">   hdr-&gt;GetMessageKey(&amp;newHdrKey);</span>
<a href="#l31.8"></a><span id="l31.8">   hdr-&gt;GetDateInSeconds(&amp;msgDate);</span>
<a href="#l31.9"></a><span id="l31.9">   if (msgDate &gt; m_newestMsgDate)</span>
<a href="#l31.10"></a><span id="l31.10">     SetNewestMsgDate(msgDate);</span>
<a href="#l31.11"></a><span id="l31.11"> </span>
<a href="#l31.12"></a><span id="l31.12" class="difflineminus">-  if (newHdrFlags &amp; MSG_FLAG_WATCHED)</span>
<a href="#l31.13"></a><span id="l31.13" class="difflineminus">-    SetFlags(m_flags | MSG_FLAG_WATCHED);</span>
<a href="#l31.14"></a><span id="l31.14" class="difflineplus">+  if (newHdrFlags &amp; nsMsgMessageFlags::Watched)</span>
<a href="#l31.15"></a><span id="l31.15" class="difflineplus">+    SetFlags(m_flags | nsMsgMessageFlags::Watched);</span>
<a href="#l31.16"></a><span id="l31.16"> </span>
<a href="#l31.17"></a><span id="l31.17" class="difflineminus">-  child-&gt;AndFlags(~(MSG_FLAG_WATCHED), &amp;newHdrFlags);</span>
<a href="#l31.18"></a><span id="l31.18" class="difflineplus">+  child-&gt;AndFlags(~(nsMsgMessageFlags::Watched), &amp;newHdrFlags);</span>
<a href="#l31.19"></a><span id="l31.19">   </span>
<a href="#l31.20"></a><span id="l31.20">   // These are threading flags that the child may have set before being added</span>
<a href="#l31.21"></a><span id="l31.21">   // to the database.</span>
<a href="#l31.22"></a><span id="l31.22">   PRUint32 protoThreadFlags;</span>
<a href="#l31.23"></a><span id="l31.23">   child-&gt;GetUint32Property(&quot;ProtoThreadFlags&quot;, &amp;protoThreadFlags);</span>
<a href="#l31.24"></a><span id="l31.24">   SetFlags(m_flags | protoThreadFlags);</span>
<a href="#l31.25"></a><span id="l31.25">   // Clear the flag so that it doesn't fudge anywhere else</span>
<a href="#l31.26"></a><span id="l31.26">   child-&gt;SetUint32Property(&quot;ProtoThreadFlags&quot;, 0);</span>
<a href="#l31.27"></a><span id="l31.27" class="difflineat">@@ -258,17 +258,17 @@ NS_IMETHODIMP nsMsgThread::AddChild(nsIM</span>
<a href="#l31.28"></a><span id="l31.28">   // if this is an empty thread, set the root key to this header's key</span>
<a href="#l31.29"></a><span id="l31.29">   if (numChildren == 0)</span>
<a href="#l31.30"></a><span id="l31.30">     SetThreadRootKey(newHdrKey);</span>
<a href="#l31.31"></a><span id="l31.31"> </span>
<a href="#l31.32"></a><span id="l31.32">   if (m_mdbTable)</span>
<a href="#l31.33"></a><span id="l31.33">   {</span>
<a href="#l31.34"></a><span id="l31.34">     m_mdbTable-&gt;AddRow(m_mdbDB-&gt;GetEnv(), hdrRow);</span>
<a href="#l31.35"></a><span id="l31.35">     ChangeChildCount(1);</span>
<a href="#l31.36"></a><span id="l31.36" class="difflineminus">-    if (! (newHdrFlags &amp; MSG_FLAG_READ))</span>
<a href="#l31.37"></a><span id="l31.37" class="difflineplus">+    if (! (newHdrFlags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l31.38"></a><span id="l31.38">       ChangeUnreadChildCount(1);</span>
<a href="#l31.39"></a><span id="l31.39">   }</span>
<a href="#l31.40"></a><span id="l31.40">   if (inReplyTo)</span>
<a href="#l31.41"></a><span id="l31.41">   {</span>
<a href="#l31.42"></a><span id="l31.42">     nsMsgKey parentKey;</span>
<a href="#l31.43"></a><span id="l31.43">     inReplyTo-&gt;GetMessageKey(&amp;parentKey);</span>
<a href="#l31.44"></a><span id="l31.44">     child-&gt;SetThreadParent(parentKey);</span>
<a href="#l31.45"></a><span id="l31.45">     parentKeyNeedsSetting = PR_FALSE;</span>
<a href="#l31.46"></a><span id="l31.46" class="difflineat">@@ -354,17 +354,17 @@ NS_IMETHODIMP nsMsgThread::AddChild(nsIM</span>
<a href="#l31.47"></a><span id="l31.47">         }</span>
<a href="#l31.48"></a><span id="l31.48">       }</span>
<a href="#l31.49"></a><span id="l31.49">     }</span>
<a href="#l31.50"></a><span id="l31.50">   }</span>
<a href="#l31.51"></a><span id="l31.51">   // If this header is not a reply to a header in the thread, and isn't a parent</span>
<a href="#l31.52"></a><span id="l31.52">   // check to see if it starts with Re: - if not, and the first header does start</span>
<a href="#l31.53"></a><span id="l31.53">   // with re, should we make this header the top level header?</span>
<a href="#l31.54"></a><span id="l31.54">   // If it's date is less (or it's ID?), then yes.</span>
<a href="#l31.55"></a><span id="l31.55" class="difflineminus">-  if (numChildren &gt; 0 &amp;&amp; !(newHdrFlags &amp; MSG_FLAG_HAS_RE) &amp;&amp; !inReplyTo)</span>
<a href="#l31.56"></a><span id="l31.56" class="difflineplus">+  if (numChildren &gt; 0 &amp;&amp; !(newHdrFlags &amp; nsMsgMessageFlags::HasRe) &amp;&amp; !inReplyTo)</span>
<a href="#l31.57"></a><span id="l31.57">   {</span>
<a href="#l31.58"></a><span id="l31.58">     PRTime topLevelHdrDate;</span>
<a href="#l31.59"></a><span id="l31.59"> </span>
<a href="#l31.60"></a><span id="l31.60">     nsCOMPtr &lt;nsIMsgDBHdr&gt; topLevelHdr;</span>
<a href="#l31.61"></a><span id="l31.61">     rv = GetRootHdr(nsnull, getter_AddRefs(topLevelHdr));</span>
<a href="#l31.62"></a><span id="l31.62">     if (NS_SUCCEEDED(rv) &amp;&amp; topLevelHdr)</span>
<a href="#l31.63"></a><span id="l31.63">     {</span>
<a href="#l31.64"></a><span id="l31.64">       topLevelHdr-&gt;GetDate(&amp;topLevelHdrDate);</span>
<a href="#l31.65"></a><span id="l31.65" class="difflineat">@@ -397,17 +397,17 @@ NS_IMETHODIMP nsMsgThread::AddChild(nsIM</span>
<a href="#l31.66"></a><span id="l31.66">   {</span>
<a href="#l31.67"></a><span id="l31.67">     mdb_pos outPos;</span>
<a href="#l31.68"></a><span id="l31.68">     m_mdbTable-&gt;MoveRow(m_mdbDB-&gt;GetEnv(), hdrRow, -1, moveIndex, &amp;outPos);</span>
<a href="#l31.69"></a><span id="l31.69">   }</span>
<a href="#l31.70"></a><span id="l31.70"> </span>
<a href="#l31.71"></a><span id="l31.71">   // do this after we've put the new hdr in the thread</span>
<a href="#l31.72"></a><span id="l31.72">   PRBool isKilled;</span>
<a href="#l31.73"></a><span id="l31.73">   child-&gt;GetIsKilled(&amp;isKilled);</span>
<a href="#l31.74"></a><span id="l31.74" class="difflineminus">-  if ((m_flags &amp; MSG_FLAG_IGNORED || isKilled) &amp;&amp; m_mdbDB)</span>
<a href="#l31.75"></a><span id="l31.75" class="difflineplus">+  if ((m_flags &amp; nsMsgMessageFlags::Ignored || isKilled) &amp;&amp; m_mdbDB)</span>
<a href="#l31.76"></a><span id="l31.76">     m_mdbDB-&gt;MarkHdrRead(child, PR_TRUE, nsnull);</span>
<a href="#l31.77"></a><span id="l31.77"> </span>
<a href="#l31.78"></a><span id="l31.78"> #ifdef DEBUG_bienvenu1</span>
<a href="#l31.79"></a><span id="l31.79">   nsMsgDatabase *msgDB = static_cast&lt;nsMsgDatabase*&gt;(m_mdbDB);</span>
<a href="#l31.80"></a><span id="l31.80">   msgDB-&gt;DumpThread(m_threadRootKey);</span>
<a href="#l31.81"></a><span id="l31.81"> #endif</span>
<a href="#l31.82"></a><span id="l31.82">   return rv;</span>
<a href="#l31.83"></a><span id="l31.83"> }</span>
<a href="#l31.84"></a><span id="l31.84" class="difflineat">@@ -585,17 +585,17 @@ NS_IMETHODIMP nsMsgThread::RemoveChildHd</span>
<a href="#l31.85"></a><span id="l31.85">   ReparentChildrenOf(key, threadParent, announcer);</span>
<a href="#l31.86"></a><span id="l31.86"> </span>
<a href="#l31.87"></a><span id="l31.87">   // if this was the newest msg, clear the newest msg date so we'll recalc.</span>
<a href="#l31.88"></a><span id="l31.88">   PRUint32 date;</span>
<a href="#l31.89"></a><span id="l31.89">   child-&gt;GetDateInSeconds(&amp;date);</span>
<a href="#l31.90"></a><span id="l31.90">   if (date == m_newestMsgDate)</span>
<a href="#l31.91"></a><span id="l31.91">     SetNewestMsgDate(0);</span>
<a href="#l31.92"></a><span id="l31.92"> </span>
<a href="#l31.93"></a><span id="l31.93" class="difflineminus">- if (!(flags &amp; MSG_FLAG_READ))</span>
<a href="#l31.94"></a><span id="l31.94" class="difflineplus">+ if (!(flags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l31.95"></a><span id="l31.95">     ChangeUnreadChildCount(-1);</span>
<a href="#l31.96"></a><span id="l31.96">   ChangeChildCount(-1);</span>
<a href="#l31.97"></a><span id="l31.97">   return RemoveChild(key);</span>
<a href="#l31.98"></a><span id="l31.98"> }</span>
<a href="#l31.99"></a><span id="l31.99"> </span>
<a href="#l31.100"></a><span id="l31.100"> nsresult nsMsgThread::ReparentChildrenOf(nsMsgKey oldParent, nsMsgKey newParent, nsIDBChangeAnnouncer *announcer)</span>
<a href="#l31.101"></a><span id="l31.101"> {</span>
<a href="#l31.102"></a><span id="l31.102">   nsresult rv = NS_OK;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l32.1"></a><span id="l32.1" class="difflineminus">--- a/mailnews/db/msgdb/src/nsNewsDatabase.cpp</span>
<a href="#l32.2"></a><span id="l32.2" class="difflineplus">+++ b/mailnews/db/msgdb/src/nsNewsDatabase.cpp</span>
<a href="#l32.3"></a><span id="l32.3" class="difflineat">@@ -339,17 +339,17 @@ nsresult nsNewsDatabase::SyncWithReadSet</span>
<a href="#l32.4"></a><span id="l32.4"> </span>
<a href="#l32.5"></a><span id="l32.5">   return rv;</span>
<a href="#l32.6"></a><span id="l32.6"> }</span>
<a href="#l32.7"></a><span id="l32.7"> </span>
<a href="#l32.8"></a><span id="l32.8"> nsresult nsNewsDatabase::AdjustExpungedBytesOnDelete(nsIMsgDBHdr *msgHdr)</span>
<a href="#l32.9"></a><span id="l32.9"> {</span>
<a href="#l32.10"></a><span id="l32.10">   PRUint32 msgFlags;</span>
<a href="#l32.11"></a><span id="l32.11">   msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l32.12"></a><span id="l32.12" class="difflineminus">-  if (msgFlags &amp; MSG_FLAG_OFFLINE &amp;&amp; m_dbFolderInfo)</span>
<a href="#l32.13"></a><span id="l32.13" class="difflineplus">+  if (msgFlags &amp; nsMsgMessageFlags::Offline &amp;&amp; m_dbFolderInfo)</span>
<a href="#l32.14"></a><span id="l32.14">   {</span>
<a href="#l32.15"></a><span id="l32.15">     PRUint32 size = 0;</span>
<a href="#l32.16"></a><span id="l32.16">     (void)msgHdr-&gt;GetOfflineMessageSize(&amp;size);</span>
<a href="#l32.17"></a><span id="l32.17">     return m_dbFolderInfo-&gt;ChangeExpungedBytes (size);</span>
<a href="#l32.18"></a><span id="l32.18">   }</span>
<a href="#l32.19"></a><span id="l32.19">   return NS_OK;</span>
<a href="#l32.20"></a><span id="l32.20"> }</span>
<a href="#l32.21"></a><span id="l32.21"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l33.1"></a><span id="l33.1" class="difflineminus">--- a/mailnews/imap/src/nsAutoSyncManager.cpp</span>
<a href="#l33.2"></a><span id="l33.2" class="difflineplus">+++ b/mailnews/imap/src/nsAutoSyncManager.cpp</span>
<a href="#l33.3"></a><span id="l33.3" class="difflineat">@@ -1046,17 +1046,17 @@ NS_IMETHODIMP</span>
<a href="#l33.4"></a><span id="l33.4"> nsAutoSyncManager::DoesMsgFitDownloadCriteria(nsIMsgDBHdr *aMsgHdr, PRBool *aResult)</span>
<a href="#l33.5"></a><span id="l33.5"> {</span>
<a href="#l33.6"></a><span id="l33.6">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l33.7"></a><span id="l33.7">   </span>
<a href="#l33.8"></a><span id="l33.8">   PRUint32 msgFlags = 0;</span>
<a href="#l33.9"></a><span id="l33.9">   aMsgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l33.10"></a><span id="l33.10">   </span>
<a href="#l33.11"></a><span id="l33.11">   // check whether this message is marked imap deleted or not </span>
<a href="#l33.12"></a><span id="l33.12" class="difflineminus">-  *aResult = !(msgFlags &amp; MSG_FLAG_IMAP_DELETED);</span>
<a href="#l33.13"></a><span id="l33.13" class="difflineplus">+  *aResult = !(msgFlags &amp; nsMsgMessageFlags::IMAPDeleted);</span>
<a href="#l33.14"></a><span id="l33.14">   if (!(*aResult))</span>
<a href="#l33.15"></a><span id="l33.15">     return NS_OK;</span>
<a href="#l33.16"></a><span id="l33.16">     </span>
<a href="#l33.17"></a><span id="l33.17">   PRBool shouldStoreMsgOffline = PR_TRUE;</span>
<a href="#l33.18"></a><span id="l33.18">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l33.19"></a><span id="l33.19">   aMsgHdr-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l33.20"></a><span id="l33.20">   if (folder)</span>
<a href="#l33.21"></a><span id="l33.21">   {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l34.1"></a><span id="l34.1" class="difflineminus">--- a/mailnews/imap/src/nsAutoSyncState.cpp</span>
<a href="#l34.2"></a><span id="l34.2" class="difflineplus">+++ b/mailnews/imap/src/nsAutoSyncState.cpp</span>
<a href="#l34.3"></a><span id="l34.3" class="difflineat">@@ -270,17 +270,17 @@ NS_IMETHODIMP nsAutoSyncState::GetNextGr</span>
<a href="#l34.4"></a><span id="l34.4">         if(!qhdr)</span>
<a href="#l34.5"></a><span id="l34.5">           continue; //maybe deleted, skip it!</span>
<a href="#l34.6"></a><span id="l34.6">         </span>
<a href="#l34.7"></a><span id="l34.7">         // ensure that we don't have this message body offline already,</span>
<a href="#l34.8"></a><span id="l34.8">         // possible if the user explicitly selects this message prior</span>
<a href="#l34.9"></a><span id="l34.9">         // to auto-sync kicks in</span>
<a href="#l34.10"></a><span id="l34.10">         PRUint32 msgFlags = 0;</span>
<a href="#l34.11"></a><span id="l34.11">         qhdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l34.12"></a><span id="l34.12" class="difflineminus">-        if ( msgFlags &amp; MSG_FLAG_OFFLINE )</span>
<a href="#l34.13"></a><span id="l34.13" class="difflineplus">+        if (msgFlags &amp; nsMsgMessageFlags::Offline)</span>
<a href="#l34.14"></a><span id="l34.14">           continue;</span>
<a href="#l34.15"></a><span id="l34.15">           </span>
<a href="#l34.16"></a><span id="l34.16">         // this check point allows msg strategy function</span>
<a href="#l34.17"></a><span id="l34.17">         // to do last minute decisions based on the current</span>
<a href="#l34.18"></a><span id="l34.18">         // state of TB such as the size of the message store etc..</span>
<a href="#l34.19"></a><span id="l34.19">         if (msgStrategy)</span>
<a href="#l34.20"></a><span id="l34.20">         {</span>
<a href="#l34.21"></a><span id="l34.21">           PRBool excluded = PR_FALSE;</span>
<a href="#l34.22"></a><span id="l34.22" class="difflineat">@@ -361,17 +361,17 @@ NS_IMETHODIMP nsAutoSyncState::ProcessEx</span>
<a href="#l34.23"></a><span id="l34.23">   {</span>
<a href="#l34.24"></a><span id="l34.24">     nsCOMPtr&lt;nsIMsgDBHdr&gt; hdr;</span>
<a href="#l34.25"></a><span id="l34.25">     rv = database-&gt;GetMsgHdrForKey(mExistingHeadersQ[mProcessPointer], getter_AddRefs(hdr));</span>
<a href="#l34.26"></a><span id="l34.26">     if (hdr)</span>
<a href="#l34.27"></a><span id="l34.27">     {</span>
<a href="#l34.28"></a><span id="l34.28">       PRUint32 msgFlags = 0;</span>
<a href="#l34.29"></a><span id="l34.29">       hdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l34.30"></a><span id="l34.30">       </span>
<a href="#l34.31"></a><span id="l34.31" class="difflineminus">-      if (!(msgFlags &amp; MSG_FLAG_OFFLINE))</span>
<a href="#l34.32"></a><span id="l34.32" class="difflineplus">+      if (!(msgFlags &amp; nsMsgMessageFlags::Offline))</span>
<a href="#l34.33"></a><span id="l34.33">         msgKeys.AppendElement(mExistingHeadersQ[mProcessPointer]);</span>
<a href="#l34.34"></a><span id="l34.34">     }</span>
<a href="#l34.35"></a><span id="l34.35">   }</span>
<a href="#l34.36"></a><span id="l34.36">   </span>
<a href="#l34.37"></a><span id="l34.37">   #if defined(DEBUG_me) &amp;&amp; defined(DEBUG_AutoSyncState_L1)</span>
<a href="#l34.38"></a><span id="l34.38">   nsCString folderName;</span>
<a href="#l34.39"></a><span id="l34.39">   folder-&gt;GetURI(folderName);</span>
<a href="#l34.40"></a><span id="l34.40">   printf(&quot;%d messages will be added into the download q of folder %s\n&quot;, msgKeys.Length(), folderName.get());</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l35.1"></a><span id="l35.1" class="difflineminus">--- a/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l35.2"></a><span id="l35.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l35.3"></a><span id="l35.3" class="difflineat">@@ -2128,17 +2128,17 @@ NS_IMETHODIMP nsImapMailFolder::DeleteMe</span>
<a href="#l35.4"></a><span id="l35.4">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l35.5"></a><span id="l35.5">       deleteMsgs = PR_FALSE;</span>
<a href="#l35.6"></a><span id="l35.6">       for (PRUint32 i=0; i &lt;cnt; i++)</span>
<a href="#l35.7"></a><span id="l35.7">       {</span>
<a href="#l35.8"></a><span id="l35.8">         nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr = do_QueryElementAt(messages, i);</span>
<a href="#l35.9"></a><span id="l35.9">         if (msgHdr)</span>
<a href="#l35.10"></a><span id="l35.10">         {</span>
<a href="#l35.11"></a><span id="l35.11">           msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l35.12"></a><span id="l35.12" class="difflineminus">-          if (!(flags &amp; MSG_FLAG_IMAP_DELETED))</span>
<a href="#l35.13"></a><span id="l35.13" class="difflineplus">+          if (!(flags &amp; nsMsgMessageFlags::IMAPDeleted))</span>
<a href="#l35.14"></a><span id="l35.14">           {</span>
<a href="#l35.15"></a><span id="l35.15">             deleteMsgs = PR_TRUE;</span>
<a href="#l35.16"></a><span id="l35.16">             break;</span>
<a href="#l35.17"></a><span id="l35.17">           }</span>
<a href="#l35.18"></a><span id="l35.18">         }</span>
<a href="#l35.19"></a><span id="l35.19">       }</span>
<a href="#l35.20"></a><span id="l35.20">     }</span>
<a href="#l35.21"></a><span id="l35.21">     // if copy service listener is also a url listener, pass that</span>
<a href="#l35.22"></a><span id="l35.22" class="difflineat">@@ -2849,17 +2849,17 @@ nsresult nsImapMailFolder::NormalEndHead</span>
<a href="#l35.23"></a><span id="l35.23">   if (NS_SUCCEEDED(newMsgHdr-&gt;GetMessageSize(&amp;messageSize)))</span>
<a href="#l35.24"></a><span id="l35.24">     mFolderSize += messageSize;</span>
<a href="#l35.25"></a><span id="l35.25">   m_msgMovedByFilter = PR_FALSE;</span>
<a href="#l35.26"></a><span id="l35.26">   // If this is the inbox, try to apply filters.</span>
<a href="#l35.27"></a><span id="l35.27">   if (mFlags &amp; nsMsgFolderFlags::Inbox)</span>
<a href="#l35.28"></a><span id="l35.28">   {</span>
<a href="#l35.29"></a><span id="l35.29">     PRUint32 msgFlags;</span>
<a href="#l35.30"></a><span id="l35.30">     newMsgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l35.31"></a><span id="l35.31" class="difflineminus">-    if (!(msgFlags &amp; (MSG_FLAG_READ | MSG_FLAG_IMAP_DELETED))) // only fire on unread msgs that haven't been deleted</span>
<a href="#l35.32"></a><span id="l35.32" class="difflineplus">+    if (!(msgFlags &amp; (nsMsgMessageFlags::Read | nsMsgMessageFlags::IMAPDeleted))) // only fire on unread msgs that haven't been deleted</span>
<a href="#l35.33"></a><span id="l35.33">     {</span>
<a href="#l35.34"></a><span id="l35.34">       PRInt32 duplicateAction = nsIMsgIncomingServer::keepDups;</span>
<a href="#l35.35"></a><span id="l35.35">       if (server)</span>
<a href="#l35.36"></a><span id="l35.36">         server-&gt;GetIncomingDuplicateAction(&amp;duplicateAction);</span>
<a href="#l35.37"></a><span id="l35.37">       if (duplicateAction != nsIMsgIncomingServer::keepDups)</span>
<a href="#l35.38"></a><span id="l35.38">       {</span>
<a href="#l35.39"></a><span id="l35.39">         PRBool isDup;</span>
<a href="#l35.40"></a><span id="l35.40">         server-&gt;IsNewHdrDuplicate(newMsgHdr, &amp;isDup);</span>
<a href="#l35.41"></a><span id="l35.41" class="difflineat">@@ -2868,17 +2868,17 @@ nsresult nsImapMailFolder::NormalEndHead</span>
<a href="#l35.42"></a><span id="l35.42">           // we want to do something similar to applying filter hits.</span>
<a href="#l35.43"></a><span id="l35.43">           // if a dup is marked read, it shouldn't trigger biff.</span>
<a href="#l35.44"></a><span id="l35.44">           // Same for deleting it or moving it to trash.</span>
<a href="#l35.45"></a><span id="l35.45">           switch (duplicateAction)</span>
<a href="#l35.46"></a><span id="l35.46">           {</span>
<a href="#l35.47"></a><span id="l35.47">             case nsIMsgIncomingServer::deleteDups:</span>
<a href="#l35.48"></a><span id="l35.48">               {</span>
<a href="#l35.49"></a><span id="l35.49">                 PRUint32 newFlags;</span>
<a href="#l35.50"></a><span id="l35.50" class="difflineminus">-                newMsgHdr-&gt;OrFlags(MSG_FLAG_READ | MSG_FLAG_IMAP_DELETED, &amp;newFlags);</span>
<a href="#l35.51"></a><span id="l35.51" class="difflineplus">+                newMsgHdr-&gt;OrFlags(nsMsgMessageFlags::Read | nsMsgMessageFlags::IMAPDeleted, &amp;newFlags);</span>
<a href="#l35.52"></a><span id="l35.52">                 StoreImapFlags(kImapMsgSeenFlag | kImapMsgDeletedFlag, PR_TRUE,</span>
<a href="#l35.53"></a><span id="l35.53">                                &amp;m_curMsgUid, 1, nsnull);</span>
<a href="#l35.54"></a><span id="l35.54">                 m_msgMovedByFilter = PR_TRUE;</span>
<a href="#l35.55"></a><span id="l35.55">               }</span>
<a href="#l35.56"></a><span id="l35.56">               break;</span>
<a href="#l35.57"></a><span id="l35.57">             case nsIMsgIncomingServer::moveDupsToTrash:</span>
<a href="#l35.58"></a><span id="l35.58">               {</span>
<a href="#l35.59"></a><span id="l35.59">                 nsCOMPtr &lt;nsIMsgFolder&gt; trash;</span>
<a href="#l35.60"></a><span id="l35.60" class="difflineat">@@ -2891,17 +2891,17 @@ nsresult nsImapMailFolder::NormalEndHead</span>
<a href="#l35.61"></a><span id="l35.61">                   if (NS_SUCCEEDED(err))</span>
<a href="#l35.62"></a><span id="l35.62">                     m_msgMovedByFilter = PR_TRUE;</span>
<a href="#l35.63"></a><span id="l35.63">                 }</span>
<a href="#l35.64"></a><span id="l35.64">               }</span>
<a href="#l35.65"></a><span id="l35.65">               break;</span>
<a href="#l35.66"></a><span id="l35.66">             case nsIMsgIncomingServer::markDupsRead:</span>
<a href="#l35.67"></a><span id="l35.67">               {</span>
<a href="#l35.68"></a><span id="l35.68">                 PRUint32 newFlags;</span>
<a href="#l35.69"></a><span id="l35.69" class="difflineminus">-                newMsgHdr-&gt;OrFlags(MSG_FLAG_READ, &amp;newFlags);</span>
<a href="#l35.70"></a><span id="l35.70" class="difflineplus">+                newMsgHdr-&gt;OrFlags(nsMsgMessageFlags::Read, &amp;newFlags);</span>
<a href="#l35.71"></a><span id="l35.71">                 StoreImapFlags(kImapMsgSeenFlag, PR_TRUE, &amp;m_curMsgUid, 1, nsnull);</span>
<a href="#l35.72"></a><span id="l35.72">               }</span>
<a href="#l35.73"></a><span id="l35.73">               break;</span>
<a href="#l35.74"></a><span id="l35.74">           }</span>
<a href="#l35.75"></a><span id="l35.75">           PRInt32 numNewMessages;</span>
<a href="#l35.76"></a><span id="l35.76">           GetNumNewMessages(PR_FALSE, &amp;numNewMessages);</span>
<a href="#l35.77"></a><span id="l35.77">           SetNumNewMessages(numNewMessages - 1);</span>
<a href="#l35.78"></a><span id="l35.78">         }</span>
<a href="#l35.79"></a><span id="l35.79" class="difflineat">@@ -3169,33 +3169,33 @@ NS_IMETHODIMP nsImapMailFolder::ApplyFil</span>
<a href="#l35.80"></a><span id="l35.80">       }</span>
<a href="#l35.81"></a><span id="l35.81"> </span>
<a href="#l35.82"></a><span id="l35.82">       PRUint32 msgFlags;</span>
<a href="#l35.83"></a><span id="l35.83">       nsMsgKey    msgKey;</span>
<a href="#l35.84"></a><span id="l35.84">       nsCAutoString trashNameVal;</span>
<a href="#l35.85"></a><span id="l35.85"> </span>
<a href="#l35.86"></a><span id="l35.86">       msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l35.87"></a><span id="l35.87">       msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l35.88"></a><span id="l35.88" class="difflineminus">-      PRBool isRead = (msgFlags &amp; MSG_FLAG_READ);</span>
<a href="#l35.89"></a><span id="l35.89" class="difflineplus">+      PRBool isRead = (msgFlags &amp; nsMsgMessageFlags::Read);</span>
<a href="#l35.90"></a><span id="l35.90">       switch (actionType)</span>
<a href="#l35.91"></a><span id="l35.91">       {</span>
<a href="#l35.92"></a><span id="l35.92">         case nsMsgFilterAction::Delete:</span>
<a href="#l35.93"></a><span id="l35.93">         {</span>
<a href="#l35.94"></a><span id="l35.94">           if (deleteToTrash)</span>
<a href="#l35.95"></a><span id="l35.95">           {</span>
<a href="#l35.96"></a><span id="l35.96">             // set value to trash folder</span>
<a href="#l35.97"></a><span id="l35.97">             nsCOMPtr &lt;nsIMsgFolder&gt; mailTrash;</span>
<a href="#l35.98"></a><span id="l35.98">             rv = GetTrashFolder(getter_AddRefs(mailTrash));</span>
<a href="#l35.99"></a><span id="l35.99">             if (NS_SUCCEEDED(rv) &amp;&amp; mailTrash)</span>
<a href="#l35.100"></a><span id="l35.100">               rv = mailTrash-&gt;GetURI(actionTargetFolderUri);</span>
<a href="#l35.101"></a><span id="l35.101" class="difflineminus">-            // msgHdr-&gt;OrFlags(MSG_FLAG_READ, &amp;newFlags);  // mark read in trash.</span>
<a href="#l35.102"></a><span id="l35.102" class="difflineplus">+            // msgHdr-&gt;OrFlags(nsMsgMessageFlags::Read, &amp;newFlags);  // mark read in trash.</span>
<a href="#l35.103"></a><span id="l35.103">           }</span>
<a href="#l35.104"></a><span id="l35.104">           else  // (!deleteToTrash)</span>
<a href="#l35.105"></a><span id="l35.105">           {</span>
<a href="#l35.106"></a><span id="l35.106" class="difflineminus">-            msgHdr-&gt;OrFlags(MSG_FLAG_READ | MSG_FLAG_IMAP_DELETED, &amp;newFlags);</span>
<a href="#l35.107"></a><span id="l35.107" class="difflineplus">+            msgHdr-&gt;OrFlags(nsMsgMessageFlags::Read | nsMsgMessageFlags::IMAPDeleted, &amp;newFlags);</span>
<a href="#l35.108"></a><span id="l35.108">             StoreImapFlags(kImapMsgSeenFlag | kImapMsgDeletedFlag, PR_TRUE,</span>
<a href="#l35.109"></a><span id="l35.109">                            &amp;msgKey, 1, nsnull);</span>
<a href="#l35.110"></a><span id="l35.110">             m_msgMovedByFilter = PR_TRUE; // this will prevent us from adding the header to the db.</span>
<a href="#l35.111"></a><span id="l35.111">           }</span>
<a href="#l35.112"></a><span id="l35.112">           msgIsNew = PR_FALSE;</span>
<a href="#l35.113"></a><span id="l35.113">         }</span>
<a href="#l35.114"></a><span id="l35.114">         // note that delete falls through to move.</span>
<a href="#l35.115"></a><span id="l35.115">         case nsMsgFilterAction::MoveToFolder:</span>
<a href="#l35.116"></a><span id="l35.116" class="difflineat">@@ -3203,20 +3203,20 @@ NS_IMETHODIMP nsImapMailFolder::ApplyFil</span>
<a href="#l35.117"></a><span id="l35.117">           // if moving to a different file, do it.</span>
<a href="#l35.118"></a><span id="l35.118">           nsCString uri;</span>
<a href="#l35.119"></a><span id="l35.119">           rv = GetURI(uri);</span>
<a href="#l35.120"></a><span id="l35.120"> </span>
<a href="#l35.121"></a><span id="l35.121">           if (!actionTargetFolderUri.Equals(uri))</span>
<a href="#l35.122"></a><span id="l35.122">           {</span>
<a href="#l35.123"></a><span id="l35.123">             msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l35.124"></a><span id="l35.124"> </span>
<a href="#l35.125"></a><span id="l35.125" class="difflineminus">-            if (msgFlags &amp; MSG_FLAG_MDN_REPORT_NEEDED &amp;&amp; !isRead)</span>
<a href="#l35.126"></a><span id="l35.126" class="difflineplus">+            if (msgFlags &amp; nsMsgMessageFlags::MDNReportNeeded &amp;&amp; !isRead)</span>
<a href="#l35.127"></a><span id="l35.127">             {</span>
<a href="#l35.128"></a><span id="l35.128" class="difflineminus">-               msgHdr-&gt;SetFlags(msgFlags &amp; ~MSG_FLAG_MDN_REPORT_NEEDED);</span>
<a href="#l35.129"></a><span id="l35.129" class="difflineminus">-               msgHdr-&gt;OrFlags(MSG_FLAG_MDN_REPORT_SENT, &amp;newFlags);</span>
<a href="#l35.130"></a><span id="l35.130" class="difflineplus">+               msgHdr-&gt;SetFlags(msgFlags &amp; ~nsMsgMessageFlags::MDNReportNeeded);</span>
<a href="#l35.131"></a><span id="l35.131" class="difflineplus">+               msgHdr-&gt;OrFlags(nsMsgMessageFlags::MDNReportSent, &amp;newFlags);</span>
<a href="#l35.132"></a><span id="l35.132">             }</span>
<a href="#l35.133"></a><span id="l35.133">             nsresult err = MoveIncorporatedMessage(msgHdr, mDatabase, actionTargetFolderUri, filter, msgWindow);</span>
<a href="#l35.134"></a><span id="l35.134">             if (NS_SUCCEEDED(err))</span>
<a href="#l35.135"></a><span id="l35.135">               m_msgMovedByFilter = PR_TRUE;</span>
<a href="#l35.136"></a><span id="l35.136">           }</span>
<a href="#l35.137"></a><span id="l35.137">           // don't apply any more filters, even if it was a move to the same folder</span>
<a href="#l35.138"></a><span id="l35.138">           *applyMore = PR_FALSE; </span>
<a href="#l35.139"></a><span id="l35.139">         }</span>
<a href="#l35.140"></a><span id="l35.140" class="difflineat">@@ -3227,20 +3227,20 @@ NS_IMETHODIMP nsImapMailFolder::ApplyFil</span>
<a href="#l35.141"></a><span id="l35.141">           rv = GetURI(uri);</span>
<a href="#l35.142"></a><span id="l35.142"> </span>
<a href="#l35.143"></a><span id="l35.143">           if (!actionTargetFolderUri.Equals(uri))</span>
<a href="#l35.144"></a><span id="l35.144">           {</span>
<a href="#l35.145"></a><span id="l35.145">             // XXXshaver I'm not actually 100% what the right semantics are for</span>
<a href="#l35.146"></a><span id="l35.146">             // MDNs and copied messages, but I suspect deep down inside that</span>
<a href="#l35.147"></a><span id="l35.147">             // we probably want to suppress them only on the copies.</span>
<a href="#l35.148"></a><span id="l35.148">             msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l35.149"></a><span id="l35.149" class="difflineminus">-            if (msgFlags &amp; MSG_FLAG_MDN_REPORT_NEEDED &amp;&amp; !isRead)</span>
<a href="#l35.150"></a><span id="l35.150" class="difflineplus">+            if (msgFlags &amp; nsMsgMessageFlags::MDNReportNeeded &amp;&amp; !isRead)</span>
<a href="#l35.151"></a><span id="l35.151">             {</span>
<a href="#l35.152"></a><span id="l35.152" class="difflineminus">-               msgHdr-&gt;SetFlags(msgFlags &amp; ~MSG_FLAG_MDN_REPORT_NEEDED);</span>
<a href="#l35.153"></a><span id="l35.153" class="difflineminus">-               msgHdr-&gt;OrFlags(MSG_FLAG_MDN_REPORT_SENT, &amp;newFlags);</span>
<a href="#l35.154"></a><span id="l35.154" class="difflineplus">+               msgHdr-&gt;SetFlags(msgFlags &amp; ~nsMsgMessageFlags::MDNReportNeeded);</span>
<a href="#l35.155"></a><span id="l35.155" class="difflineplus">+               msgHdr-&gt;OrFlags(nsMsgMessageFlags::MDNReportSent, &amp;newFlags);</span>
<a href="#l35.156"></a><span id="l35.156">             }</span>
<a href="#l35.157"></a><span id="l35.157"> </span>
<a href="#l35.158"></a><span id="l35.158">             nsCOMPtr&lt;nsIMutableArray&gt; messageArray(do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l35.159"></a><span id="l35.159">             NS_ENSURE_TRUE(messageArray, rv);</span>
<a href="#l35.160"></a><span id="l35.160">             messageArray-&gt;AppendElement(msgHdr, PR_FALSE);</span>
<a href="#l35.161"></a><span id="l35.161"> </span>
<a href="#l35.162"></a><span id="l35.162">             nsCOMPtr&lt;nsIMsgFolder&gt; dstFolder;</span>
<a href="#l35.163"></a><span id="l35.163">             rv = GetExistingFolder(actionTargetFolderUri, getter_AddRefs(dstFolder));</span>
<a href="#l35.164"></a><span id="l35.164" class="difflineat">@@ -3264,23 +3264,23 @@ NS_IMETHODIMP nsImapMailFolder::ApplyFil</span>
<a href="#l35.165"></a><span id="l35.165">         break;</span>
<a href="#l35.166"></a><span id="l35.166">         case nsMsgFilterAction::MarkFlagged:</span>
<a href="#l35.167"></a><span id="l35.167">         {</span>
<a href="#l35.168"></a><span id="l35.168">           mDatabase-&gt;MarkHdrMarked(msgHdr, PR_TRUE, nsnull);</span>
<a href="#l35.169"></a><span id="l35.169">           StoreImapFlags(kImapMsgFlaggedFlag, PR_TRUE, &amp;msgKey, 1, nsnull);</span>
<a href="#l35.170"></a><span id="l35.170">         }</span>
<a href="#l35.171"></a><span id="l35.171">         break;</span>
<a href="#l35.172"></a><span id="l35.172">         case nsMsgFilterAction::KillThread:</span>
<a href="#l35.173"></a><span id="l35.173" class="difflineminus">-          msgHdr-&gt;SetUint32Property(&quot;ProtoThreadFlags&quot;, MSG_FLAG_IGNORED);</span>
<a href="#l35.174"></a><span id="l35.174" class="difflineplus">+          msgHdr-&gt;SetUint32Property(&quot;ProtoThreadFlags&quot;, nsMsgMessageFlags::Ignored);</span>
<a href="#l35.175"></a><span id="l35.175">           break;</span>
<a href="#l35.176"></a><span id="l35.176">         case nsMsgFilterAction::KillSubthread:</span>
<a href="#l35.177"></a><span id="l35.177" class="difflineminus">-          msgHdr-&gt;OrFlags(MSG_FLAG_IGNORED, &amp;newFlags);</span>
<a href="#l35.178"></a><span id="l35.178" class="difflineplus">+          msgHdr-&gt;OrFlags(nsMsgMessageFlags::Ignored, &amp;newFlags);</span>
<a href="#l35.179"></a><span id="l35.179">           break;</span>
<a href="#l35.180"></a><span id="l35.180">         case nsMsgFilterAction::WatchThread:</span>
<a href="#l35.181"></a><span id="l35.181" class="difflineminus">-          msgHdr-&gt;OrFlags(MSG_FLAG_WATCHED, &amp;newFlags);</span>
<a href="#l35.182"></a><span id="l35.182" class="difflineplus">+          msgHdr-&gt;OrFlags(nsMsgMessageFlags::Watched, &amp;newFlags);</span>
<a href="#l35.183"></a><span id="l35.183">         break;</span>
<a href="#l35.184"></a><span id="l35.184">         case nsMsgFilterAction::ChangePriority:</span>
<a href="#l35.185"></a><span id="l35.185">         {</span>
<a href="#l35.186"></a><span id="l35.186">           nsMsgPriorityValue filterPriority;</span>
<a href="#l35.187"></a><span id="l35.187">           filterAction-&gt;GetPriority(&amp;filterPriority);</span>
<a href="#l35.188"></a><span id="l35.188">           msgHdr-&gt;SetPriority(filterPriority);</span>
<a href="#l35.189"></a><span id="l35.189">         }</span>
<a href="#l35.190"></a><span id="l35.190">         break;</span>
<a href="#l35.191"></a><span id="l35.191" class="difflineat">@@ -3870,58 +3870,60 @@ void nsImapMailFolder::TweakHeaderFlags(</span>
<a href="#l35.192"></a><span id="l35.192">     PRBool foundIt = PR_FALSE;</span>
<a href="#l35.193"></a><span id="l35.193">     imapMessageFlagsType imap_flags;</span>
<a href="#l35.194"></a><span id="l35.194"> </span>
<a href="#l35.195"></a><span id="l35.195">     nsCString customFlags;</span>
<a href="#l35.196"></a><span id="l35.196">     nsresult rv = aProtocol-&gt;GetFlagsForUID(m_curMsgUid, &amp;foundIt, &amp;imap_flags, getter_Copies(customFlags));</span>
<a href="#l35.197"></a><span id="l35.197">     if (NS_SUCCEEDED(rv) &amp;&amp; foundIt)</span>
<a href="#l35.198"></a><span id="l35.198">     {</span>
<a href="#l35.199"></a><span id="l35.199">       // make a mask and clear these message flags</span>
<a href="#l35.200"></a><span id="l35.200" class="difflineminus">-      PRUint32 mask = MSG_FLAG_READ | MSG_FLAG_REPLIED | MSG_FLAG_MARKED | MSG_FLAG_IMAP_DELETED | MSG_FLAG_LABELS;</span>
<a href="#l35.201"></a><span id="l35.201" class="difflineplus">+      PRUint32 mask = nsMsgMessageFlags::Read | nsMsgMessageFlags::Replied |</span>
<a href="#l35.202"></a><span id="l35.202" class="difflineplus">+                      nsMsgMessageFlags::Marked | nsMsgMessageFlags::IMAPDeleted |</span>
<a href="#l35.203"></a><span id="l35.203" class="difflineplus">+                      nsMsgMessageFlags::Labels;</span>
<a href="#l35.204"></a><span id="l35.204">       PRUint32 dbHdrFlags;</span>
<a href="#l35.205"></a><span id="l35.205"> </span>
<a href="#l35.206"></a><span id="l35.206">       tweakMe-&gt;GetFlags(&amp;dbHdrFlags);</span>
<a href="#l35.207"></a><span id="l35.207">       tweakMe-&gt;AndFlags(~mask, &amp;dbHdrFlags);</span>
<a href="#l35.208"></a><span id="l35.208"> </span>
<a href="#l35.209"></a><span id="l35.209">       // set the new value for these flags</span>
<a href="#l35.210"></a><span id="l35.210">       PRUint32 newFlags = 0;</span>
<a href="#l35.211"></a><span id="l35.211">       if (imap_flags &amp; kImapMsgSeenFlag)</span>
<a href="#l35.212"></a><span id="l35.212" class="difflineminus">-        newFlags |= MSG_FLAG_READ;</span>
<a href="#l35.213"></a><span id="l35.213" class="difflineplus">+        newFlags |= nsMsgMessageFlags::Read;</span>
<a href="#l35.214"></a><span id="l35.214">       else // if (imap_flags &amp; kImapMsgRecentFlag)</span>
<a href="#l35.215"></a><span id="l35.215" class="difflineminus">-        newFlags |= MSG_FLAG_NEW;</span>
<a href="#l35.216"></a><span id="l35.216" class="difflineplus">+        newFlags |= nsMsgMessageFlags::New;</span>
<a href="#l35.217"></a><span id="l35.217"> </span>
<a href="#l35.218"></a><span id="l35.218">       // Okay here is the MDN needed logic (if DNT header seen):</span>
<a href="#l35.219"></a><span id="l35.219">       /* if server support user defined flag:</span>
<a href="#l35.220"></a><span id="l35.220">                     MDNSent flag set =&gt; clear kMDNNeeded flag</span>
<a href="#l35.221"></a><span id="l35.221">                     MDNSent flag not set =&gt; do nothing, leave kMDNNeeded on</span>
<a href="#l35.222"></a><span id="l35.222">                     else if</span>
<a href="#l35.223"></a><span id="l35.223" class="difflineminus">-                    not MSG_FLAG_NEW =&gt; clear kMDNNeeded flag</span>
<a href="#l35.224"></a><span id="l35.224" class="difflineminus">-                   MSG_FLAG_NEW =&gt; do nothing, leave kMDNNeeded on</span>
<a href="#l35.225"></a><span id="l35.225" class="difflineplus">+                    not nsMsgMessageFlags::New =&gt; clear kMDNNeeded flag</span>
<a href="#l35.226"></a><span id="l35.226" class="difflineplus">+                   nsMsgMessageFlags::New =&gt; do nothing, leave kMDNNeeded on</span>
<a href="#l35.227"></a><span id="l35.227">                */</span>
<a href="#l35.228"></a><span id="l35.228">       PRUint16 userFlags;</span>
<a href="#l35.229"></a><span id="l35.229">       rv = aProtocol-&gt;GetSupportedUserFlags(&amp;userFlags);</span>
<a href="#l35.230"></a><span id="l35.230">       if (NS_SUCCEEDED(rv) &amp;&amp; (userFlags &amp; (kImapMsgSupportUserFlag |</span>
<a href="#l35.231"></a><span id="l35.231">                             kImapMsgSupportMDNSentFlag)))</span>
<a href="#l35.232"></a><span id="l35.232">       {</span>
<a href="#l35.233"></a><span id="l35.233">         if (imap_flags &amp; kImapMsgMDNSentFlag)</span>
<a href="#l35.234"></a><span id="l35.234">         {</span>
<a href="#l35.235"></a><span id="l35.235" class="difflineminus">-          newFlags |= MSG_FLAG_MDN_REPORT_SENT;</span>
<a href="#l35.236"></a><span id="l35.236" class="difflineminus">-          if (dbHdrFlags &amp; MSG_FLAG_MDN_REPORT_NEEDED)</span>
<a href="#l35.237"></a><span id="l35.237" class="difflineminus">-            tweakMe-&gt;AndFlags(~MSG_FLAG_MDN_REPORT_NEEDED, &amp;dbHdrFlags);</span>
<a href="#l35.238"></a><span id="l35.238" class="difflineplus">+          newFlags |= nsMsgMessageFlags::MDNReportSent;</span>
<a href="#l35.239"></a><span id="l35.239" class="difflineplus">+          if (dbHdrFlags &amp; nsMsgMessageFlags::MDNReportNeeded)</span>
<a href="#l35.240"></a><span id="l35.240" class="difflineplus">+            tweakMe-&gt;AndFlags(~nsMsgMessageFlags::MDNReportNeeded, &amp;dbHdrFlags);</span>
<a href="#l35.241"></a><span id="l35.241">         }</span>
<a href="#l35.242"></a><span id="l35.242">       }</span>
<a href="#l35.243"></a><span id="l35.243"> </span>
<a href="#l35.244"></a><span id="l35.244">       if (imap_flags &amp; kImapMsgAnsweredFlag)</span>
<a href="#l35.245"></a><span id="l35.245" class="difflineminus">-        newFlags |= MSG_FLAG_REPLIED;</span>
<a href="#l35.246"></a><span id="l35.246" class="difflineplus">+        newFlags |= nsMsgMessageFlags::Replied;</span>
<a href="#l35.247"></a><span id="l35.247">       if (imap_flags &amp; kImapMsgFlaggedFlag)</span>
<a href="#l35.248"></a><span id="l35.248" class="difflineminus">-        newFlags |= MSG_FLAG_MARKED;</span>
<a href="#l35.249"></a><span id="l35.249" class="difflineplus">+        newFlags |= nsMsgMessageFlags::Marked;</span>
<a href="#l35.250"></a><span id="l35.250">       if (imap_flags &amp; kImapMsgDeletedFlag)</span>
<a href="#l35.251"></a><span id="l35.251" class="difflineminus">-        newFlags |= MSG_FLAG_IMAP_DELETED;</span>
<a href="#l35.252"></a><span id="l35.252" class="difflineplus">+        newFlags |= nsMsgMessageFlags::IMAPDeleted;</span>
<a href="#l35.253"></a><span id="l35.253">       if (imap_flags &amp; kImapMsgForwardedFlag)</span>
<a href="#l35.254"></a><span id="l35.254" class="difflineminus">-        newFlags |= MSG_FLAG_FORWARDED;</span>
<a href="#l35.255"></a><span id="l35.255" class="difflineplus">+        newFlags |= nsMsgMessageFlags::Forwarded;</span>
<a href="#l35.256"></a><span id="l35.256"> </span>
<a href="#l35.257"></a><span id="l35.257">       // db label flags are 0x0E000000 and imap label flags are 0x0E00</span>
<a href="#l35.258"></a><span id="l35.258">       // so we need to shift 16 bits to the left to convert them.</span>
<a href="#l35.259"></a><span id="l35.259">       if (imap_flags &amp; kImapMsgLabelFlags)</span>
<a href="#l35.260"></a><span id="l35.260">       {</span>
<a href="#l35.261"></a><span id="l35.261">         // we need to set label attribute on header because the dbview code</span>
<a href="#l35.262"></a><span id="l35.262">         // does msgHdr-&gt;GetLabel when asked to paint a row</span>
<a href="#l35.263"></a><span id="l35.263">         tweakMe-&gt;SetLabel((imap_flags &amp; kImapMsgLabelFlags) &gt;&gt; 9);</span>
<a href="#l35.264"></a><span id="l35.264" class="difflineat">@@ -4185,17 +4187,17 @@ nsresult nsImapMailFolder::HandleCustomF</span>
<a href="#l35.265"></a><span id="l35.265">     nsCAutoString msgJunkScore;</span>
<a href="#l35.266"></a><span id="l35.266">     msgJunkScore.AppendInt(nsIJunkMailPlugin::IS_HAM_SCORE);</span>
<a href="#l35.267"></a><span id="l35.267">     mDatabase-&gt;SetStringProperty(uidOfMessage, &quot;junkscore&quot;, msgJunkScore.get());</span>
<a href="#l35.268"></a><span id="l35.268">   }</span>
<a href="#l35.269"></a><span id="l35.269">   // ### TODO: we really should parse the keywords into space delimited keywords before checking</span>
<a href="#l35.270"></a><span id="l35.270">   else if (keywords.Find(&quot;Junk&quot;, PR_TRUE /* ignore case */) != -1)</span>
<a href="#l35.271"></a><span id="l35.271">   {</span>
<a href="#l35.272"></a><span id="l35.272">     PRUint32 newFlags;</span>
<a href="#l35.273"></a><span id="l35.273" class="difflineminus">-    dbHdr-&gt;AndFlags(~MSG_FLAG_NEW, &amp;newFlags);</span>
<a href="#l35.274"></a><span id="l35.274" class="difflineplus">+    dbHdr-&gt;AndFlags(~nsMsgMessageFlags::New, &amp;newFlags);</span>
<a href="#l35.275"></a><span id="l35.275">     nsCAutoString msgJunkScore;</span>
<a href="#l35.276"></a><span id="l35.276">     msgJunkScore.AppendInt(nsIJunkMailPlugin::IS_SPAM_SCORE);</span>
<a href="#l35.277"></a><span id="l35.277">     mDatabase-&gt;SetStringProperty(uidOfMessage, &quot;junkscore&quot;, msgJunkScore.get());</span>
<a href="#l35.278"></a><span id="l35.278">   }</span>
<a href="#l35.279"></a><span id="l35.279">   else</span>
<a href="#l35.280"></a><span id="l35.280">     messageClassified = PR_FALSE;</span>
<a href="#l35.281"></a><span id="l35.281">   if (messageClassified)</span>
<a href="#l35.282"></a><span id="l35.282">   {</span>
<a href="#l35.283"></a><span id="l35.283" class="difflineat">@@ -4387,17 +4389,17 @@ nsresult nsImapMailFolder::GetTrashFolde</span>
<a href="#l35.284"></a><span id="l35.284">     rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Trash, pTrashFolder);</span>
<a href="#l35.285"></a><span id="l35.285">     if (!*pTrashFolder)</span>
<a href="#l35.286"></a><span id="l35.286">       rv = NS_ERROR_FAILURE;</span>
<a href="#l35.287"></a><span id="l35.287">   }</span>
<a href="#l35.288"></a><span id="l35.288">   return rv;</span>
<a href="#l35.289"></a><span id="l35.289"> }</span>
<a href="#l35.290"></a><span id="l35.290"> </span>
<a href="#l35.291"></a><span id="l35.291"> </span>
<a href="#l35.292"></a><span id="l35.292" class="difflineminus">-// store MSG_FLAG_IMAP_DELETED in the specified mailhdr records</span>
<a href="#l35.293"></a><span id="l35.293" class="difflineplus">+// store nsMsgMessageFlags::IMAPDeleted in the specified mailhdr records</span>
<a href="#l35.294"></a><span id="l35.294"> void nsImapMailFolder::SetIMAPDeletedFlag(nsIMsgDatabase *mailDB, const nsTArray&lt;nsMsgKey&gt; &amp;msgids, PRBool markDeleted)</span>
<a href="#l35.295"></a><span id="l35.295"> {</span>
<a href="#l35.296"></a><span id="l35.296">   nsresult markStatus = 0;</span>
<a href="#l35.297"></a><span id="l35.297">   PRUint32 total = msgids.Length();</span>
<a href="#l35.298"></a><span id="l35.298"> </span>
<a href="#l35.299"></a><span id="l35.299">   for (PRUint32 msgIndex=0; !markStatus &amp;&amp; (msgIndex &lt; total); msgIndex++)</span>
<a href="#l35.300"></a><span id="l35.300">     markStatus = mailDB-&gt;MarkImapDeleted(msgids[msgIndex], markDeleted, nsnull);</span>
<a href="#l35.301"></a><span id="l35.301"> }</span>
<a href="#l35.302"></a><span id="l35.302" class="difflineat">@@ -6220,17 +6222,17 @@ nsresult nsImapMailFolder::CopyOfflineMs</span>
<a href="#l35.303"></a><span id="l35.303">         PR_FREEIF(inputBuffer);</span>
<a href="#l35.304"></a><span id="l35.304">         outputStream-&gt;Flush();</span>
<a href="#l35.305"></a><span id="l35.305">       }</span>
<a href="#l35.306"></a><span id="l35.306">     }</span>
<a href="#l35.307"></a><span id="l35.307">   }</span>
<a href="#l35.308"></a><span id="l35.308">   if (NS_SUCCEEDED(rv))</span>
<a href="#l35.309"></a><span id="l35.309">   {</span>
<a href="#l35.310"></a><span id="l35.310">     PRUint32 resultFlags;</span>
<a href="#l35.311"></a><span id="l35.311" class="difflineminus">-    destHdr-&gt;OrFlags(MSG_FLAG_OFFLINE, &amp;resultFlags);</span>
<a href="#l35.312"></a><span id="l35.312" class="difflineplus">+    destHdr-&gt;OrFlags(nsMsgMessageFlags::Offline, &amp;resultFlags);</span>
<a href="#l35.313"></a><span id="l35.313">     destHdr-&gt;SetOfflineMessageSize(messageSize);</span>
<a href="#l35.314"></a><span id="l35.314">   }</span>
<a href="#l35.315"></a><span id="l35.315">   return rv;</span>
<a href="#l35.316"></a><span id="l35.316"> }</span>
<a href="#l35.317"></a><span id="l35.317"> </span>
<a href="#l35.318"></a><span id="l35.318"> // this imap folder is the destination of an offline move/copy.</span>
<a href="#l35.319"></a><span id="l35.319"> // We are either offline, or doing a pseudo-offline delete (where we do an offline</span>
<a href="#l35.320"></a><span id="l35.320"> // delete, load the next message, then playback the offline delete).</span>
<a href="#l35.321"></a><span id="l35.321" class="difflineat">@@ -6344,17 +6346,17 @@ nsresult nsImapMailFolder::CopyMessagesO</span>
<a href="#l35.322"></a><span id="l35.322">               PRUint32 msgFlags;</span>
<a href="#l35.323"></a><span id="l35.323">               imapMessageFlagsType newImapFlags = 0;</span>
<a href="#l35.324"></a><span id="l35.324">               message-&gt;GetMessageSize(&amp;msgSize);</span>
<a href="#l35.325"></a><span id="l35.325">               message-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l35.326"></a><span id="l35.326">               sourceOp-&gt;SetDestinationFolderURI(folderURI.get()); // offline move</span>
<a href="#l35.327"></a><span id="l35.327">               sourceOp-&gt;SetOperation(nsIMsgOfflineImapOperation::kMsgMoved);</span>
<a href="#l35.328"></a><span id="l35.328">               sourceOp-&gt;SetMsgSize(msgSize);</span>
<a href="#l35.329"></a><span id="l35.329">               newImapFlags = msgFlags &amp; 0x7;</span>
<a href="#l35.330"></a><span id="l35.330" class="difflineminus">-              if (msgFlags &amp; MSG_FLAG_FORWARDED)</span>
<a href="#l35.331"></a><span id="l35.331" class="difflineplus">+              if (msgFlags &amp; nsMsgMessageFlags::Forwarded)</span>
<a href="#l35.332"></a><span id="l35.332">                 newImapFlags |=  kImapMsgForwardedFlag;</span>
<a href="#l35.333"></a><span id="l35.333">               sourceOp-&gt;SetNewFlags(newImapFlags);</span>
<a href="#l35.334"></a><span id="l35.334">             }</span>
<a href="#l35.335"></a><span id="l35.335">             else</span>
<a href="#l35.336"></a><span id="l35.336">               sourceOp-&gt;AddMessageCopyOperation(folderURI.get()); // offline copy</span>
<a href="#l35.337"></a><span id="l35.337"> </span>
<a href="#l35.338"></a><span id="l35.338">             nsTArray&lt;nsMsgKey&gt; srcKeyArray;</span>
<a href="#l35.339"></a><span id="l35.339">             nsCOMPtr&lt;nsIUrlListener&gt; urlListener;</span>
<a href="#l35.340"></a><span id="l35.340" class="difflineat">@@ -7260,17 +7262,17 @@ nsImapMailFolder::InitCopyState(nsISuppo</span>
<a href="#l35.341"></a><span id="l35.341">         {</span>
<a href="#l35.342"></a><span id="l35.342">           nsCOMPtr&lt;nsIMsgDBHdr&gt; message = do_QueryElementAt(m_copyState-&gt;m_messages, keyIndex, &amp;rv);</span>
<a href="#l35.343"></a><span id="l35.343">           // if the key is not there, then assume what the caller tells us to.</span>
<a href="#l35.344"></a><span id="l35.344">           PRBool isRead = PR_FALSE;</span>
<a href="#l35.345"></a><span id="l35.345">           PRUint32 flags;</span>
<a href="#l35.346"></a><span id="l35.346">           if (message )</span>
<a href="#l35.347"></a><span id="l35.347">           {</span>
<a href="#l35.348"></a><span id="l35.348">             message-&gt;GetFlags(&amp;flags);</span>
<a href="#l35.349"></a><span id="l35.349" class="difflineminus">-            isRead = flags &amp; MSG_FLAG_READ;</span>
<a href="#l35.350"></a><span id="l35.350" class="difflineplus">+            isRead = flags &amp; nsMsgMessageFlags::Read;</span>
<a href="#l35.351"></a><span id="l35.351">           }</span>
<a href="#l35.352"></a><span id="l35.352">           if (!isRead)</span>
<a href="#l35.353"></a><span id="l35.353">             numUnread++;</span>
<a href="#l35.354"></a><span id="l35.354">         }</span>
<a href="#l35.355"></a><span id="l35.355">         m_copyState-&gt;m_unreadCount = numUnread;</span>
<a href="#l35.356"></a><span id="l35.356">     }</span>
<a href="#l35.357"></a><span id="l35.357">   }</span>
<a href="#l35.358"></a><span id="l35.358">   else</span>
<a href="#l35.359"></a><span id="l35.359" class="difflineat">@@ -7279,17 +7281,17 @@ nsImapMailFolder::InitCopyState(nsISuppo</span>
<a href="#l35.360"></a><span id="l35.360">         do_QueryElementAt(m_copyState-&gt;m_messages,</span>
<a href="#l35.361"></a><span id="l35.361">                           m_copyState-&gt;m_curIndex, &amp;rv);</span>
<a href="#l35.362"></a><span id="l35.362">       // if the key is not there, then assume what the caller tells us to.</span>
<a href="#l35.363"></a><span id="l35.363">     PRBool isRead = PR_FALSE;</span>
<a href="#l35.364"></a><span id="l35.364">     PRUint32 flags;</span>
<a href="#l35.365"></a><span id="l35.365">     if (message )</span>
<a href="#l35.366"></a><span id="l35.366">     {</span>
<a href="#l35.367"></a><span id="l35.367">       message-&gt;GetFlags(&amp;flags);</span>
<a href="#l35.368"></a><span id="l35.368" class="difflineminus">-      isRead = flags &amp; MSG_FLAG_READ;</span>
<a href="#l35.369"></a><span id="l35.369" class="difflineplus">+      isRead = flags &amp; nsMsgMessageFlags::Read;</span>
<a href="#l35.370"></a><span id="l35.370">     }</span>
<a href="#l35.371"></a><span id="l35.371">     m_copyState-&gt;m_unreadCount = (isRead) ? 0 : 1;</span>
<a href="#l35.372"></a><span id="l35.372">   }</span>
<a href="#l35.373"></a><span id="l35.373"> </span>
<a href="#l35.374"></a><span id="l35.374">   m_copyState-&gt;m_isMove = isMove;</span>
<a href="#l35.375"></a><span id="l35.375">   m_copyState-&gt;m_newMsgFlags = newMsgFlags;</span>
<a href="#l35.376"></a><span id="l35.376">   m_copyState-&gt;m_newMsgKeywords = newMsgKeywords;</span>
<a href="#l35.377"></a><span id="l35.377">   m_copyState-&gt;m_allowUndo = allowUndo;</span>
<a href="#l35.378"></a><span id="l35.378" class="difflineat">@@ -7989,19 +7991,19 @@ nsImapMailFolder::OnMessageClassified(co</span>
<a href="#l35.379"></a><span id="l35.379">   rv = msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l35.380"></a><span id="l35.380">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l35.381"></a><span id="l35.381"> </span>
<a href="#l35.382"></a><span id="l35.382">   // check if this message needs junk classification</span>
<a href="#l35.383"></a><span id="l35.383"> </span>
<a href="#l35.384"></a><span id="l35.384">   PRUint32 processingFlags;</span>
<a href="#l35.385"></a><span id="l35.385">   GetProcessingFlags(msgKey, &amp;processingFlags);</span>
<a href="#l35.386"></a><span id="l35.386"> </span>
<a href="#l35.387"></a><span id="l35.387" class="difflineminus">-  if (processingFlags &amp; MSG_PROCESSING_FLAG_CLASSIFY_JUNK)</span>
<a href="#l35.388"></a><span id="l35.388" class="difflineminus">-  {</span>
<a href="#l35.389"></a><span id="l35.389" class="difflineminus">-    AndProcessingFlags(msgKey, ~MSG_PROCESSING_FLAG_CLASSIFY_JUNK);</span>
<a href="#l35.390"></a><span id="l35.390" class="difflineplus">+  if (processingFlags &amp; nsMsgProcessingFlags::ClassifyJunk)</span>
<a href="#l35.391"></a><span id="l35.391" class="difflineplus">+  {</span>
<a href="#l35.392"></a><span id="l35.392" class="difflineplus">+    AndProcessingFlags(msgKey, ~nsMsgProcessingFlags::ClassifyJunk);</span>
<a href="#l35.393"></a><span id="l35.393">     nsCString spamFolderURI;</span>
<a href="#l35.394"></a><span id="l35.394"> </span>
<a href="#l35.395"></a><span id="l35.395">     nsCAutoString msgJunkScore;</span>
<a href="#l35.396"></a><span id="l35.396">     msgJunkScore.AppendInt(aClassification == nsIJunkMailPlugin::JUNK ?</span>
<a href="#l35.397"></a><span id="l35.397">           nsIJunkMailPlugin::IS_SPAM_SCORE:</span>
<a href="#l35.398"></a><span id="l35.398">           nsIJunkMailPlugin::IS_HAM_SCORE);</span>
<a href="#l35.399"></a><span id="l35.399">     mDatabase-&gt;SetStringProperty(msgKey, &quot;junkscore&quot;, msgJunkScore.get());</span>
<a href="#l35.400"></a><span id="l35.400">     mDatabase-&gt;SetStringProperty(msgKey, &quot;junkscoreorigin&quot;, &quot;plugin&quot;);</span>
<a href="#l35.401"></a><span id="l35.401" class="difflineat">@@ -8118,20 +8120,20 @@ nsImapMailFolder::OnMessageTraitsClassif</span>
<a href="#l35.402"></a><span id="l35.402">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l35.403"></a><span id="l35.403"> </span>
<a href="#l35.404"></a><span id="l35.404">   nsMsgKey msgKey;</span>
<a href="#l35.405"></a><span id="l35.405">   rv = msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l35.406"></a><span id="l35.406">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l35.407"></a><span id="l35.407"> </span>
<a href="#l35.408"></a><span id="l35.408">   PRUint32 processingFlags;</span>
<a href="#l35.409"></a><span id="l35.409">   GetProcessingFlags(msgKey, &amp;processingFlags);</span>
<a href="#l35.410"></a><span id="l35.410" class="difflineminus">-  if (!(processingFlags &amp; MSG_PROCESSING_FLAG_CLASSIFY_TRAITS))</span>
<a href="#l35.411"></a><span id="l35.411" class="difflineplus">+  if (!(processingFlags &amp; nsMsgProcessingFlags::ClassifyTraits))</span>
<a href="#l35.412"></a><span id="l35.412">     return NS_OK;</span>
<a href="#l35.413"></a><span id="l35.413"> </span>
<a href="#l35.414"></a><span id="l35.414" class="difflineminus">-  AndProcessingFlags(msgKey, ~MSG_PROCESSING_FLAG_CLASSIFY_TRAITS);</span>
<a href="#l35.415"></a><span id="l35.415" class="difflineplus">+  AndProcessingFlags(msgKey, ~nsMsgProcessingFlags::ClassifyTraits);</span>
<a href="#l35.416"></a><span id="l35.416"> </span>
<a href="#l35.417"></a><span id="l35.417">   nsCOMPtr&lt;nsIMsgTraitService&gt; traitService;</span>
<a href="#l35.418"></a><span id="l35.418">   traitService = do_GetService(&quot;@mozilla.org/msg-trait-service;1&quot;, &amp;rv);</span>
<a href="#l35.419"></a><span id="l35.419">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l35.420"></a><span id="l35.420"> </span>
<a href="#l35.421"></a><span id="l35.421">   for (PRUint32 i = 0; i &lt; aTraitCount; i++)</span>
<a href="#l35.422"></a><span id="l35.422">   {</span>
<a href="#l35.423"></a><span id="l35.423">     if (aTraits[i] == nsIJunkMailPlugin::JUNK_TRAIT)</span>
<a href="#l35.424"></a><span id="l35.424" class="difflineat">@@ -8241,17 +8243,17 @@ NS_IMETHODIMP nsImapMailFolder::FetchMsg</span>
<a href="#l35.425"></a><span id="l35.425">       }</span>
<a href="#l35.426"></a><span id="l35.426">     }</span>
<a href="#l35.427"></a><span id="l35.427">     else // lets look in the offline store</span>
<a href="#l35.428"></a><span id="l35.428">     {</span>
<a href="#l35.429"></a><span id="l35.429">       PRUint32 msgFlags;</span>
<a href="#l35.430"></a><span id="l35.430">       msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l35.431"></a><span id="l35.431">       nsMsgKey msgKey;</span>
<a href="#l35.432"></a><span id="l35.432">       msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l35.433"></a><span id="l35.433" class="difflineminus">-      if (msgFlags &amp; MSG_FLAG_OFFLINE)</span>
<a href="#l35.434"></a><span id="l35.434" class="difflineplus">+      if (msgFlags &amp; nsMsgMessageFlags::Offline)</span>
<a href="#l35.435"></a><span id="l35.435">       {</span>
<a href="#l35.436"></a><span id="l35.436">         nsMsgKey messageOffset;</span>
<a href="#l35.437"></a><span id="l35.437">         PRUint32 messageSize;</span>
<a href="#l35.438"></a><span id="l35.438">         GetOfflineFileStream(msgKey, &amp;messageOffset, &amp;messageSize, getter_AddRefs(inputStream));</span>
<a href="#l35.439"></a><span id="l35.439">         if (inputStream)</span>
<a href="#l35.440"></a><span id="l35.440">           rv = GetMsgPreviewTextFromStream(msgHdr, inputStream);</span>
<a href="#l35.441"></a><span id="l35.441">       }</span>
<a href="#l35.442"></a><span id="l35.442">       else if (!aLocalOnly)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l36.1"></a><span id="l36.1" class="difflineminus">--- a/mailnews/imap/src/nsImapOfflineSync.cpp</span>
<a href="#l36.2"></a><span id="l36.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapOfflineSync.cpp</span>
<a href="#l36.3"></a><span id="l36.3" class="difflineat">@@ -564,17 +564,17 @@ void nsImapOfflineSync::ProcessMoveOpera</span>
<a href="#l36.4"></a><span id="l36.4">           {</span>
<a href="#l36.5"></a><span id="l36.5">             imapMessageFlagsType newImapFlags;</span>
<a href="#l36.6"></a><span id="l36.6">             PRUint32 msgFlags = 0;</span>
<a href="#l36.7"></a><span id="l36.7">             op-&gt;GetMsgSize(&amp;msgSize);</span>
<a href="#l36.8"></a><span id="l36.8">             op-&gt;GetNewFlags(&amp;newImapFlags);</span>
<a href="#l36.9"></a><span id="l36.9">             // first three bits are the same</span>
<a href="#l36.10"></a><span id="l36.10">             msgFlags |= (newImapFlags &amp; 0x07);</span>
<a href="#l36.11"></a><span id="l36.11">             if (newImapFlags &amp; kImapMsgForwardedFlag)</span>
<a href="#l36.12"></a><span id="l36.12" class="difflineminus">-              msgFlags |= MSG_FLAG_FORWARDED;</span>
<a href="#l36.13"></a><span id="l36.13" class="difflineplus">+              msgFlags |= nsMsgMessageFlags::Forwarded;</span>
<a href="#l36.14"></a><span id="l36.14">             mailHdr-&gt;SetFlags(msgFlags);</span>
<a href="#l36.15"></a><span id="l36.15">             mailHdr-&gt;SetMessageSize(msgSize);</span>
<a href="#l36.16"></a><span id="l36.16">           }</span>
<a href="#l36.17"></a><span id="l36.17">           messages-&gt;AppendElement(mailHdr, PR_FALSE);</span>
<a href="#l36.18"></a><span id="l36.18">         }</span>
<a href="#l36.19"></a><span id="l36.19">       }</span>
<a href="#l36.20"></a><span id="l36.20">       nsCOMPtr&lt;nsIMsgCopyService&gt; copyService = do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l36.21"></a><span id="l36.21">       if (copyService)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l37.1"></a><span id="l37.1" class="difflineminus">--- a/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l37.2"></a><span id="l37.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l37.3"></a><span id="l37.3" class="difflineat">@@ -3628,17 +3628,17 @@ void nsImapProtocol::HandleMessageDownLo</span>
<a href="#l37.4"></a><span id="l37.4">     {</span>
<a href="#l37.5"></a><span id="l37.5">       m_fromHeaderSeen = PR_TRUE;</span>
<a href="#l37.6"></a><span id="l37.6">       if (PL_strstr(messageLine, xSenderInfo) != NULL)</span>
<a href="#l37.7"></a><span id="l37.7">           // Adding a X-Mozilla-Status line here is not very elegant but it</span>
<a href="#l37.8"></a><span id="l37.8">           // works.  Another X-Mozilla-Status line is added to the message when</span>
<a href="#l37.9"></a><span id="l37.9">           // downloading to a local folder; this new line will also contain the</span>
<a href="#l37.10"></a><span id="l37.10">           // 'authed' flag we are adding here.  (If the message is again</span>
<a href="#l37.11"></a><span id="l37.11">           // uploaded to the server, this flag is lost.)</span>
<a href="#l37.12"></a><span id="l37.12" class="difflineminus">-          // 0x0200 == MSG_FLAG_SENDER_AUTHED</span>
<a href="#l37.13"></a><span id="l37.13" class="difflineplus">+          // 0x0200 == nsMsgMessageFlags::SenderAuthed</span>
<a href="#l37.14"></a><span id="l37.14">           HandleMessageDownLoadLine(&quot;X-Mozilla-Status: 0200\r\n&quot;, PR_FALSE);</span>
<a href="#l37.15"></a><span id="l37.15">       GetServerStateParser().FreeXSenderInfo();</span>
<a href="#l37.16"></a><span id="l37.16">     }</span>
<a href="#l37.17"></a><span id="l37.17">   }</span>
<a href="#l37.18"></a><span id="l37.18"> </span>
<a href="#l37.19"></a><span id="l37.19">   if (GetServerStateParser().GetDownloadingHeaders())</span>
<a href="#l37.20"></a><span id="l37.20">   {</span>
<a href="#l37.21"></a><span id="l37.21">     if (!m_curHdrInfo)</span>
<a href="#l37.22"></a><span id="l37.22" class="difflineat">@@ -5499,28 +5499,28 @@ void nsImapProtocol::OnAppendMsgFromFile</span>
<a href="#l37.23"></a><span id="l37.23">       imapMessageFlagsType flagsToSet = 0;</span>
<a href="#l37.24"></a><span id="l37.24">       PRUint32 msgFlags = 0;</span>
<a href="#l37.25"></a><span id="l37.25">       PRTime date = 0;</span>
<a href="#l37.26"></a><span id="l37.26">       nsCString keywords;</span>
<a href="#l37.27"></a><span id="l37.27">       if (m_imapMessageSink)</span>
<a href="#l37.28"></a><span id="l37.28">         m_imapMessageSink-&gt;GetCurMoveCopyMessageInfo(m_runningUrl, &amp;date,</span>
<a href="#l37.29"></a><span id="l37.29">                                                     getter_Copies(keywords), &amp;msgFlags);</span>
<a href="#l37.30"></a><span id="l37.30"> </span>
<a href="#l37.31"></a><span id="l37.31" class="difflineminus">-      if (msgFlags &amp; MSG_FLAG_READ)</span>
<a href="#l37.32"></a><span id="l37.32" class="difflineplus">+      if (msgFlags &amp; nsMsgMessageFlags::Read)</span>
<a href="#l37.33"></a><span id="l37.33">         flagsToSet |= kImapMsgSeenFlag;</span>
<a href="#l37.34"></a><span id="l37.34" class="difflineminus">-      if (msgFlags &amp; MSG_FLAG_MDN_REPORT_SENT)</span>
<a href="#l37.35"></a><span id="l37.35" class="difflineplus">+      if (msgFlags &amp; nsMsgMessageFlags::MDNReportSent)</span>
<a href="#l37.36"></a><span id="l37.36">         flagsToSet |= kImapMsgMDNSentFlag;</span>
<a href="#l37.37"></a><span id="l37.37">       // convert msg flag label (0xE000000) to imap flag label (0x0E00)</span>
<a href="#l37.38"></a><span id="l37.38" class="difflineminus">-      if (msgFlags &amp; MSG_FLAG_LABELS)</span>
<a href="#l37.39"></a><span id="l37.39" class="difflineminus">-        flagsToSet |= (msgFlags &amp; MSG_FLAG_LABELS) &gt;&gt; 16;</span>
<a href="#l37.40"></a><span id="l37.40" class="difflineminus">-      if (msgFlags &amp; MSG_FLAG_MARKED)</span>
<a href="#l37.41"></a><span id="l37.41" class="difflineplus">+      if (msgFlags &amp; nsMsgMessageFlags::Labels)</span>
<a href="#l37.42"></a><span id="l37.42" class="difflineplus">+        flagsToSet |= (msgFlags &amp; nsMsgMessageFlags::Labels) &gt;&gt; 16;</span>
<a href="#l37.43"></a><span id="l37.43" class="difflineplus">+      if (msgFlags &amp; nsMsgMessageFlags::Marked)</span>
<a href="#l37.44"></a><span id="l37.44">         flagsToSet |= kImapMsgFlaggedFlag;</span>
<a href="#l37.45"></a><span id="l37.45" class="difflineminus">-      if (msgFlags &amp; MSG_FLAG_REPLIED)</span>
<a href="#l37.46"></a><span id="l37.46" class="difflineplus">+      if (msgFlags &amp; nsMsgMessageFlags::Replied)</span>
<a href="#l37.47"></a><span id="l37.47">         flagsToSet |= kImapMsgAnsweredFlag;</span>
<a href="#l37.48"></a><span id="l37.48" class="difflineminus">-      if (msgFlags &amp; MSG_FLAG_FORWARDED)</span>
<a href="#l37.49"></a><span id="l37.49" class="difflineplus">+      if (msgFlags &amp; nsMsgMessageFlags::Forwarded)</span>
<a href="#l37.50"></a><span id="l37.50">         flagsToSet |= kImapMsgForwardedFlag;</span>
<a href="#l37.51"></a><span id="l37.51"> </span>
<a href="#l37.52"></a><span id="l37.52">       // If the message copied was a draft, flag it as such</span>
<a href="#l37.53"></a><span id="l37.53">       nsImapAction imapAction;</span>
<a href="#l37.54"></a><span id="l37.54">       rv = m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l37.55"></a><span id="l37.55">       if (NS_SUCCEEDED(rv) &amp;&amp; (imapAction == nsIImapUrl::nsImapAppendDraftFromFile))</span>
<a href="#l37.56"></a><span id="l37.56">         flagsToSet |= kImapMsgDraftFlag;</span>
<a href="#l37.57"></a><span id="l37.57">       UploadMessageFromFile(file, mailboxName, date, flagsToSet, keywords);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l38.1"></a><span id="l38.1" class="difflineminus">--- a/mailnews/imap/src/nsImapService.cpp</span>
<a href="#l38.2"></a><span id="l38.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapService.cpp</span>
<a href="#l38.3"></a><span id="l38.3" class="difflineat">@@ -2071,17 +2071,17 @@ nsresult nsImapService::OfflineAppendFro</span>
<a href="#l38.4"></a><span id="l38.4">           msgParser-&gt;GetNewMsgHdr(getter_AddRefs(fakeHdr));</span>
<a href="#l38.5"></a><span id="l38.5">           if (fakeHdr)</span>
<a href="#l38.6"></a><span id="l38.6">           {</span>
<a href="#l38.7"></a><span id="l38.7">             if (NS_SUCCEEDED(rv) &amp;&amp; fakeHdr)</span>
<a href="#l38.8"></a><span id="l38.8">             {</span>
<a href="#l38.9"></a><span id="l38.9">               PRUint32 resultFlags;</span>
<a href="#l38.10"></a><span id="l38.10">               nsInt64 tellPos = curOfflineStorePos;</span>
<a href="#l38.11"></a><span id="l38.11">               fakeHdr-&gt;SetMessageOffset((PRUint32) tellPos);</span>
<a href="#l38.12"></a><span id="l38.12" class="difflineminus">-              fakeHdr-&gt;OrFlags(MSG_FLAG_OFFLINE | MSG_FLAG_READ, &amp;resultFlags);</span>
<a href="#l38.13"></a><span id="l38.13" class="difflineplus">+              fakeHdr-&gt;OrFlags(nsMsgMessageFlags::Offline | nsMsgMessageFlags::Read, &amp;resultFlags);</span>
<a href="#l38.14"></a><span id="l38.14">               fakeHdr-&gt;SetOfflineMessageSize(fileSize);</span>
<a href="#l38.15"></a><span id="l38.15">               destDB-&gt;AddNewHdrToDB(fakeHdr, PR_TRUE /* notify */);</span>
<a href="#l38.16"></a><span id="l38.16">               aDstFolder-&gt;SetFlag(nsMsgFolderFlags::OfflineEvents);</span>
<a href="#l38.17"></a><span id="l38.17">             }</span>
<a href="#l38.18"></a><span id="l38.18">           }</span>
<a href="#l38.19"></a><span id="l38.19">           // tell the listener we're done.</span>
<a href="#l38.20"></a><span id="l38.20">           inputStream-&gt;Close();</span>
<a href="#l38.21"></a><span id="l38.21">           inputStream = nsnull;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l39.1"></a><span id="l39.1" class="difflineminus">--- a/mailnews/import/applemail/src/nsEmlxHelperUtils.mm</span>
<a href="#l39.2"></a><span id="l39.2" class="difflineplus">+++ b/mailnews/import/applemail/src/nsEmlxHelperUtils.mm</span>
<a href="#l39.3"></a><span id="l39.3" class="difflineat">@@ -72,23 +72,23 @@ nsresult nsEmlxHelperUtils::ConvertToMoz</span>
<a href="#l39.4"></a><span id="l39.4"> </span>
<a href="#l39.5"></a><span id="l39.5">   // find the &lt;flags&gt;...&lt;/flags&gt; value and convert to int</span>
<a href="#l39.6"></a><span id="l39.6">   const PRUint32 emlxMessageFlags = [[(NSDictionary *)plist objectForKey:@&quot;flags&quot;] intValue];</span>
<a href="#l39.7"></a><span id="l39.7"> </span>
<a href="#l39.8"></a><span id="l39.8">   if (emlxMessageFlags == 0)</span>
<a href="#l39.9"></a><span id="l39.9">     return NS_ERROR_FAILURE;</span>
<a href="#l39.10"></a><span id="l39.10"> </span>
<a href="#l39.11"></a><span id="l39.11">   if (emlxMessageFlags &amp; nsEmlxHelperUtils::kRead) </span>
<a href="#l39.12"></a><span id="l39.12" class="difflineminus">-    *aMozillaStatusFlags |= MSG_FLAG_READ;</span>
<a href="#l39.13"></a><span id="l39.13" class="difflineplus">+    *aMozillaStatusFlags |= nsMsgMessageFlags::Read;</span>
<a href="#l39.14"></a><span id="l39.14">   if (emlxMessageFlags &amp; nsEmlxHelperUtils::kForwarded)</span>
<a href="#l39.15"></a><span id="l39.15" class="difflineminus">-    *aMozillaStatusFlags |= MSG_FLAG_FORWARDED;</span>
<a href="#l39.16"></a><span id="l39.16" class="difflineplus">+    *aMozillaStatusFlags |= nsMsgMessageFlags::Forwarded;</span>
<a href="#l39.17"></a><span id="l39.17">   if (emlxMessageFlags &amp; nsEmlxHelperUtils::kAnswered)</span>
<a href="#l39.18"></a><span id="l39.18" class="difflineminus">-    *aMozillaStatusFlags |= MSG_FLAG_REPLIED;</span>
<a href="#l39.19"></a><span id="l39.19" class="difflineplus">+    *aMozillaStatusFlags |= nsMsgMessageFlags::Replied;</span>
<a href="#l39.20"></a><span id="l39.20">   if (emlxMessageFlags &amp; nsEmlxHelperUtils::kFlagged)</span>
<a href="#l39.21"></a><span id="l39.21" class="difflineminus">-    *aMozillaStatusFlags |= MSG_FLAG_MARKED;</span>
<a href="#l39.22"></a><span id="l39.22" class="difflineplus">+    *aMozillaStatusFlags |= nsMsgMessageFlags::Marked;</span>
<a href="#l39.23"></a><span id="l39.23"> </span>
<a href="#l39.24"></a><span id="l39.24">   return NS_OK;</span>
<a href="#l39.25"></a><span id="l39.25"> }</span>
<a href="#l39.26"></a><span id="l39.26"> </span>
<a href="#l39.27"></a><span id="l39.27"> nsresult nsEmlxHelperUtils::ConvertToMboxRD(const char *aMessageBufferStart, const char *aMessageBufferEnd, nsCString &amp;aOutBuffer)</span>
<a href="#l39.28"></a><span id="l39.28"> {</span>
<a href="#l39.29"></a><span id="l39.29">   nsTArray&lt;const char *&gt; foundFromLines;</span>
<a href="#l39.30"></a><span id="l39.30"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l40.1"></a><span id="l40.1" class="difflineminus">--- a/mailnews/import/eudora/src/nsEudoraMailbox.cpp</span>
<a href="#l40.2"></a><span id="l40.2" class="difflineplus">+++ b/mailnews/import/eudora/src/nsEudoraMailbox.cpp</span>
<a href="#l40.3"></a><span id="l40.3" class="difflineat">@@ -120,46 +120,46 @@ PRUint16 EudoraTOCEntry::GetMozillaStatu</span>
<a href="#l40.4"></a><span id="l40.4"> #ifndef XP_MACOSX</span>
<a href="#l40.5"></a><span id="l40.5">   switch (m_State)</span>
<a href="#l40.6"></a><span id="l40.6">   {</span>
<a href="#l40.7"></a><span id="l40.7">     case MS_UNREAD:</span>
<a href="#l40.8"></a><span id="l40.8">       flags = 0;</span>
<a href="#l40.9"></a><span id="l40.9">       break;</span>
<a href="#l40.10"></a><span id="l40.10"> </span>
<a href="#l40.11"></a><span id="l40.11">     case MS_READ:</span>
<a href="#l40.12"></a><span id="l40.12" class="difflineminus">-      flags = MSG_FLAG_READ;</span>
<a href="#l40.13"></a><span id="l40.13" class="difflineplus">+      flags = nsMsgMessageFlags::Read;</span>
<a href="#l40.14"></a><span id="l40.14">       break;</span>
<a href="#l40.15"></a><span id="l40.15"> </span>
<a href="#l40.16"></a><span id="l40.16">     case MS_REPLIED:</span>
<a href="#l40.17"></a><span id="l40.17" class="difflineminus">-      flags = MSG_FLAG_READ | MSG_FLAG_REPLIED;</span>
<a href="#l40.18"></a><span id="l40.18" class="difflineplus">+      flags = nsMsgMessageFlags::Read | nsMsgMessageFlags::Replied;</span>
<a href="#l40.19"></a><span id="l40.19">       break;</span>
<a href="#l40.20"></a><span id="l40.20"> </span>
<a href="#l40.21"></a><span id="l40.21">     case MS_FORWARDED:</span>
<a href="#l40.22"></a><span id="l40.22" class="difflineminus">-      flags = MSG_FLAG_READ | MSG_FLAG_FORWARDED;</span>
<a href="#l40.23"></a><span id="l40.23" class="difflineplus">+      flags = nsMsgMessageFlags::Read | nsMsgMessageFlags::Forwarded;</span>
<a href="#l40.24"></a><span id="l40.24">       break;</span>
<a href="#l40.25"></a><span id="l40.25"> </span>
<a href="#l40.26"></a><span id="l40.26">     case MS_REDIRECT:</span>
<a href="#l40.27"></a><span id="l40.27">       // Redirect doesn't really mean forwarded, but forwarded</span>
<a href="#l40.28"></a><span id="l40.28">       // seems to be the closest equivalent for now.</span>
<a href="#l40.29"></a><span id="l40.29" class="difflineminus">-      flags = MSG_FLAG_READ | MSG_FLAG_FORWARDED;</span>
<a href="#l40.30"></a><span id="l40.30" class="difflineplus">+      flags = nsMsgMessageFlags::Read | nsMsgMessageFlags::Forwarded;</span>
<a href="#l40.31"></a><span id="l40.31">       break;</span>
<a href="#l40.32"></a><span id="l40.32"> </span>
<a href="#l40.33"></a><span id="l40.33">     case MS_UNSENDABLE:</span>
<a href="#l40.34"></a><span id="l40.34">     case MS_SENDABLE:</span>
<a href="#l40.35"></a><span id="l40.35">     case MS_QUEUED:</span>
<a href="#l40.36"></a><span id="l40.36">     case MS_SENT:</span>
<a href="#l40.37"></a><span id="l40.37">     case MS_UNSENT:</span>
<a href="#l40.38"></a><span id="l40.38">     case MS_TIME_QUEUED:</span>
<a href="#l40.39"></a><span id="l40.39">     case MS_SPOOLED:</span>
<a href="#l40.40"></a><span id="l40.40">       // To do: Add more sent message flag handling.</span>
<a href="#l40.41"></a><span id="l40.41">       flags = 0;</span>
<a href="#l40.42"></a><span id="l40.42">       break;</span>
<a href="#l40.43"></a><span id="l40.43"> </span>
<a href="#l40.44"></a><span id="l40.44">     case MS_RECOVERED:</span>
<a href="#l40.45"></a><span id="l40.45" class="difflineminus">-      flags = MSG_FLAG_READ;</span>
<a href="#l40.46"></a><span id="l40.46" class="difflineplus">+      flags = nsMsgMessageFlags::Read;</span>
<a href="#l40.47"></a><span id="l40.47">       break;</span>
<a href="#l40.48"></a><span id="l40.48">   }</span>
<a href="#l40.49"></a><span id="l40.49"> </span>
<a href="#l40.50"></a><span id="l40.50">   // Range check priority just to be sure</span>
<a href="#l40.51"></a><span id="l40.51">   if (m_Priority &lt; MSP_HIGHEST)</span>
<a href="#l40.52"></a><span id="l40.52">     m_Priority = MSP_HIGHEST;</span>
<a href="#l40.53"></a><span id="l40.53">   if (m_Priority &gt; MSP_LOWEST)</span>
<a href="#l40.54"></a><span id="l40.54">     m_Priority = MSP_LOWEST;</span>
<a href="#l40.55"></a><span id="l40.55" class="difflineat">@@ -178,20 +178,20 @@ PRUint32 EudoraTOCEntry::GetMozillaStatu</span>
<a href="#l40.56"></a><span id="l40.56"> #ifdef XP_MACOSX</span>
<a href="#l40.57"></a><span id="l40.57">   return 0;</span>
<a href="#l40.58"></a><span id="l40.58"> #else</span>
<a href="#l40.59"></a><span id="l40.59"> </span>
<a href="#l40.60"></a><span id="l40.60">   // Return the mozilla equivalent of flags that Eudora supports.</span>
<a href="#l40.61"></a><span id="l40.61">   PRUint32  flags = 0;</span>
<a href="#l40.62"></a><span id="l40.62"> </span>
<a href="#l40.63"></a><span id="l40.63">   if (m_Imflags &amp; IMFLAGS_DELETED)</span>
<a href="#l40.64"></a><span id="l40.64" class="difflineminus">-    flags |= MSG_FLAG_IMAP_DELETED;</span>
<a href="#l40.65"></a><span id="l40.65" class="difflineplus">+    flags |= nsMsgMessageFlags::IMAPDeleted;</span>
<a href="#l40.66"></a><span id="l40.66"> </span>
<a href="#l40.67"></a><span id="l40.67">   if (m_Flags &amp; MSF_READ_RECEIPT)</span>
<a href="#l40.68"></a><span id="l40.68" class="difflineminus">-    flags |= MSG_FLAG_MDN_REPORT_NEEDED;</span>
<a href="#l40.69"></a><span id="l40.69" class="difflineplus">+    flags |= nsMsgMessageFlags::MDNReportNeeded;</span>
<a href="#l40.70"></a><span id="l40.70"> </span>
<a href="#l40.71"></a><span id="l40.71">   return flags;</span>
<a href="#l40.72"></a><span id="l40.72"> #endif</span>
<a href="#l40.73"></a><span id="l40.73"> }</span>
<a href="#l40.74"></a><span id="l40.74"> </span>
<a href="#l40.75"></a><span id="l40.75"> </span>
<a href="#l40.76"></a><span id="l40.76"> nsEudoraMailbox::nsEudoraMailbox()</span>
<a href="#l40.77"></a><span id="l40.77"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l41.1"></a><span id="l41.1" class="difflineminus">--- a/mailnews/local/src/nsLocalMailFolder.cpp</span>
<a href="#l41.2"></a><span id="l41.2" class="difflineplus">+++ b/mailnews/local/src/nsLocalMailFolder.cpp</span>
<a href="#l41.3"></a><span id="l41.3" class="difflineat">@@ -2245,19 +2245,19 @@ nsresult nsMsgLocalMailFolder::WriteStar</span>
<a href="#l41.4"></a><span id="l41.4">                                                                 mCopyState-&gt;m_curCopyIndex, &amp;rv);</span>
<a href="#l41.5"></a><span id="l41.5"> </span>
<a href="#l41.6"></a><span id="l41.6">     char statusStrBuf[50];</span>
<a href="#l41.7"></a><span id="l41.7">     if (curSourceMessage)</span>
<a href="#l41.8"></a><span id="l41.8">     {</span>
<a href="#l41.9"></a><span id="l41.9">       PRUint32 dbFlags = 0;</span>
<a href="#l41.10"></a><span id="l41.10">       curSourceMessage-&gt;GetFlags(&amp;dbFlags);</span>
<a href="#l41.11"></a><span id="l41.11"> </span>
<a href="#l41.12"></a><span id="l41.12" class="difflineminus">-      // write out x-mozilla-status, but make sure we don't write out MSG_FLAG_OFFLINE</span>
<a href="#l41.13"></a><span id="l41.13" class="difflineplus">+      // write out x-mozilla-status, but make sure we don't write out nsMsgMessageFlags::Offline</span>
<a href="#l41.14"></a><span id="l41.14">       PR_snprintf(statusStrBuf, sizeof(statusStrBuf), X_MOZILLA_STATUS_FORMAT MSG_LINEBREAK,</span>
<a href="#l41.15"></a><span id="l41.15" class="difflineminus">-        dbFlags &amp; ~(MSG_FLAG_RUNTIME_ONLY | MSG_FLAG_OFFLINE) &amp; 0x0000FFFF);</span>
<a href="#l41.16"></a><span id="l41.16" class="difflineplus">+        dbFlags &amp; ~(nsMsgMessageFlags::RuntimeOnly | nsMsgMessageFlags::Offline) &amp; 0x0000FFFF);</span>
<a href="#l41.17"></a><span id="l41.17">     }</span>
<a href="#l41.18"></a><span id="l41.18">     else</span>
<a href="#l41.19"></a><span id="l41.19">       strcpy(statusStrBuf, &quot;X-Mozilla-Status: 0001&quot; MSG_LINEBREAK);</span>
<a href="#l41.20"></a><span id="l41.20">     PRUint32 bytesWritten;</span>
<a href="#l41.21"></a><span id="l41.21">     mCopyState-&gt;m_fileStream-&gt;Write(result.get(), result.Length(), &amp;bytesWritten);</span>
<a href="#l41.22"></a><span id="l41.22">     if (mCopyState-&gt;m_parseMsgState)</span>
<a href="#l41.23"></a><span id="l41.23">         mCopyState-&gt;m_parseMsgState-&gt;ParseAFolderLine(</span>
<a href="#l41.24"></a><span id="l41.24">           result.get(), result.Length());</span>
<a href="#l41.25"></a><span id="l41.25" class="difflineat">@@ -2468,17 +2468,17 @@ NS_IMETHODIMP nsMsgLocalMailFolder::EndC</span>
<a href="#l41.26"></a><span id="l41.26">       if(mCopyState-&gt;m_destDB)</span>
<a href="#l41.27"></a><span id="l41.27">       {</span>
<a href="#l41.28"></a><span id="l41.28">         rv = mCopyState-&gt;m_destDB-&gt;CopyHdrFromExistingHdr(mCopyState-&gt;m_curDstKey,</span>
<a href="#l41.29"></a><span id="l41.29">           mCopyState-&gt;m_message, PR_TRUE,</span>
<a href="#l41.30"></a><span id="l41.30">           getter_AddRefs(newHdr));</span>
<a href="#l41.31"></a><span id="l41.31">         PRUint32 newHdrFlags;</span>
<a href="#l41.32"></a><span id="l41.32">         // turn off offline flag - it's not valid for local mail folders.</span>
<a href="#l41.33"></a><span id="l41.33">         if (newHdr)</span>
<a href="#l41.34"></a><span id="l41.34" class="difflineminus">-          newHdr-&gt;AndFlags(~MSG_FLAG_OFFLINE, &amp;newHdrFlags);</span>
<a href="#l41.35"></a><span id="l41.35" class="difflineplus">+          newHdr-&gt;AndFlags(~nsMsgMessageFlags::Offline, &amp;newHdrFlags);</span>
<a href="#l41.36"></a><span id="l41.36">       }</span>
<a href="#l41.37"></a><span id="l41.37">       // we can do undo with the dest folder db, see bug #198909</span>
<a href="#l41.38"></a><span id="l41.38">       //else</span>
<a href="#l41.39"></a><span id="l41.39">       //  mCopyState-&gt;m_undoMsgTxn = nsnull; //null out the transaction because we can't undo w/o the msg db</span>
<a href="#l41.40"></a><span id="l41.40">     }</span>
<a href="#l41.41"></a><span id="l41.41"> </span>
<a href="#l41.42"></a><span id="l41.42">     // if we plan on allowing undo, (if we have a mCopyState-&gt;m_parseMsgState or not)</span>
<a href="#l41.43"></a><span id="l41.43">     // we need to save the source and dest keys on the undo txn.</span>
<a href="#l41.44"></a><span id="l41.44" class="difflineat">@@ -2525,17 +2525,17 @@ NS_IMETHODIMP nsMsgLocalMailFolder::EndC</span>
<a href="#l41.45"></a><span id="l41.45">       if (NS_SUCCEEDED(result) &amp;&amp; newHdr)</span>
<a href="#l41.46"></a><span id="l41.46">       {</span>
<a href="#l41.47"></a><span id="l41.47">         // need to copy junk score and label from mCopyState-&gt;m_message to newHdr.</span>
<a href="#l41.48"></a><span id="l41.48">         if (mCopyState-&gt;m_message)</span>
<a href="#l41.49"></a><span id="l41.49">         {</span>
<a href="#l41.50"></a><span id="l41.50">           // deal with propagating the new flag on an imap to local folder filter action</span>
<a href="#l41.51"></a><span id="l41.51">           PRUint32 msgFlags;</span>
<a href="#l41.52"></a><span id="l41.52">           mCopyState-&gt;m_message-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l41.53"></a><span id="l41.53" class="difflineminus">-          if (!(msgFlags &amp; MSG_FLAG_READ))</span>
<a href="#l41.54"></a><span id="l41.54" class="difflineplus">+          if (!(msgFlags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l41.55"></a><span id="l41.55">           {</span>
<a href="#l41.56"></a><span id="l41.56">             nsCOMPtr &lt;nsIMsgFolder&gt; srcFolder;</span>
<a href="#l41.57"></a><span id="l41.57">             mCopyState-&gt;m_message-&gt;GetFolder(getter_AddRefs(srcFolder));</span>
<a href="#l41.58"></a><span id="l41.58">             if (srcFolder)</span>
<a href="#l41.59"></a><span id="l41.59">             {</span>
<a href="#l41.60"></a><span id="l41.60">               PRUint32 folderFlags;</span>
<a href="#l41.61"></a><span id="l41.61">               srcFolder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l41.62"></a><span id="l41.62">               // check if the src folder is an imap inbox.</span>
<a href="#l41.63"></a><span id="l41.63" class="difflineat">@@ -2548,17 +2548,17 @@ NS_IMETHODIMP nsMsgLocalMailFolder::EndC</span>
<a href="#l41.64"></a><span id="l41.64">                 {</span>
<a href="#l41.65"></a><span id="l41.65">                   nsMsgKey srcKey;</span>
<a href="#l41.66"></a><span id="l41.66">                   PRBool containsKey;</span>
<a href="#l41.67"></a><span id="l41.67">                   mCopyState-&gt;m_message-&gt;GetMessageKey(&amp;srcKey);</span>
<a href="#l41.68"></a><span id="l41.68">                   db-&gt;ContainsKey(srcKey, &amp;containsKey);</span>
<a href="#l41.69"></a><span id="l41.69">                   // if the db doesn't have the key, it must be a filtered imap</span>
<a href="#l41.70"></a><span id="l41.70">                   // message, getting moved to a local folder.</span>
<a href="#l41.71"></a><span id="l41.71">                   if (!containsKey)</span>
<a href="#l41.72"></a><span id="l41.72" class="difflineminus">-                    newHdr-&gt;OrFlags(MSG_FLAG_NEW, &amp;msgFlags);</span>
<a href="#l41.73"></a><span id="l41.73" class="difflineplus">+                    newHdr-&gt;OrFlags(nsMsgMessageFlags::New, &amp;msgFlags);</span>
<a href="#l41.74"></a><span id="l41.74">                 }</span>
<a href="#l41.75"></a><span id="l41.75">               }</span>
<a href="#l41.76"></a><span id="l41.76">             }</span>
<a href="#l41.77"></a><span id="l41.77">           }</span>
<a href="#l41.78"></a><span id="l41.78">           CopyPropertiesToMsgHdr(newHdr, mCopyState-&gt;m_message);</span>
<a href="#l41.79"></a><span id="l41.79">         }</span>
<a href="#l41.80"></a><span id="l41.80">         msgDb-&gt;AddNewHdrToDB(newHdr, PR_TRUE);</span>
<a href="#l41.81"></a><span id="l41.81">         if (localUndoTxn)</span>
<a href="#l41.82"></a><span id="l41.82" class="difflineat">@@ -2970,17 +2970,17 @@ nsMsgLocalMailFolder::MarkMsgsOnPop3Serv</span>
<a href="#l41.83"></a><span id="l41.83">             msgPop3Server = curMsgPop3MailServer;</span>
<a href="#l41.84"></a><span id="l41.84">             msgPop3Server-&gt;GetDeleteMailLeftOnServer(&amp;deleteMailLeftOnServer);</span>
<a href="#l41.85"></a><span id="l41.85">             msgPop3Server-&gt;GetLeaveMessagesOnServer(&amp;leaveOnServer);</span>
<a href="#l41.86"></a><span id="l41.86">           }</span>
<a href="#l41.87"></a><span id="l41.87">         }</span>
<a href="#l41.88"></a><span id="l41.88">       }</span>
<a href="#l41.89"></a><span id="l41.89">       // ignore this header if not partial and leaveOnServer not set...</span>
<a href="#l41.90"></a><span id="l41.90">       // or if we can't find the pop3 server.</span>
<a href="#l41.91"></a><span id="l41.91" class="difflineminus">-      if (!msgPop3Server || (! (flags &amp; MSG_FLAG_PARTIAL) &amp;&amp; !leaveOnServer))</span>
<a href="#l41.92"></a><span id="l41.92" class="difflineplus">+      if (!msgPop3Server || (! (flags &amp; nsMsgMessageFlags::Partial) &amp;&amp; !leaveOnServer))</span>
<a href="#l41.93"></a><span id="l41.93">         continue;</span>
<a href="#l41.94"></a><span id="l41.94">       // if marking deleted, ignore header if we're not deleting from</span>
<a href="#l41.95"></a><span id="l41.95">       // server when deleting locally.</span>
<a href="#l41.96"></a><span id="l41.96">       if (aMark == POP3_DELETE &amp;&amp; leaveOnServer &amp;&amp; !deleteMailLeftOnServer)</span>
<a href="#l41.97"></a><span id="l41.97">         continue;</span>
<a href="#l41.98"></a><span id="l41.98">       if (folderScanState.m_uidl)</span>
<a href="#l41.99"></a><span id="l41.99">       {</span>
<a href="#l41.100"></a><span id="l41.100">         msgPop3Server-&gt;AddUidlToMark(folderScanState.m_uidl, mark);</span>
<a href="#l41.101"></a><span id="l41.101" class="difflineat">@@ -3092,17 +3092,17 @@ NS_IMETHODIMP nsMsgLocalMailFolder::Down</span>
<a href="#l41.102"></a><span id="l41.102">   NS_NewISupportsArray(getter_AddRefs(mDownloadMessages));</span>
<a href="#l41.103"></a><span id="l41.103">   for (PRUint32 i = 0; i &lt; srcCount; i++)</span>
<a href="#l41.104"></a><span id="l41.104">   {</span>
<a href="#l41.105"></a><span id="l41.105">     nsCOMPtr&lt;nsIMsgDBHdr&gt; msgDBHdr (do_QueryElementAt(aMessages, i, &amp;rv));</span>
<a href="#l41.106"></a><span id="l41.106">     if (NS_SUCCEEDED(rv))</span>
<a href="#l41.107"></a><span id="l41.107">     {</span>
<a href="#l41.108"></a><span id="l41.108">       PRUint32 flags = 0;</span>
<a href="#l41.109"></a><span id="l41.109">       msgDBHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l41.110"></a><span id="l41.110" class="difflineminus">-      if (flags &amp; MSG_FLAG_PARTIAL)</span>
<a href="#l41.111"></a><span id="l41.111" class="difflineplus">+      if (flags &amp; nsMsgMessageFlags::Partial)</span>
<a href="#l41.112"></a><span id="l41.112">         mDownloadMessages-&gt;AppendElement(msgDBHdr);</span>
<a href="#l41.113"></a><span id="l41.113">     }</span>
<a href="#l41.114"></a><span id="l41.114">   }</span>
<a href="#l41.115"></a><span id="l41.115">   mDownloadWindow = aWindow;</span>
<a href="#l41.116"></a><span id="l41.116"> </span>
<a href="#l41.117"></a><span id="l41.117">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l41.118"></a><span id="l41.118">   rv = GetServer(getter_AddRefs(server));</span>
<a href="#l41.119"></a><span id="l41.119">   NS_ENSURE_SUCCESS(rv, NS_MSG_INVALID_OR_MISSING_SERVER);</span>
<a href="#l41.120"></a><span id="l41.120" class="difflineat">@@ -3500,19 +3500,19 @@ nsMsgLocalMailFolder::OnMessageClassifie</span>
<a href="#l41.121"></a><span id="l41.121">   nsCOMPtr&lt;nsISpamSettings&gt; spamSettings;</span>
<a href="#l41.122"></a><span id="l41.122">   rv = server-&gt;GetSpamSettings(getter_AddRefs(spamSettings));</span>
<a href="#l41.123"></a><span id="l41.123">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l41.124"></a><span id="l41.124"> </span>
<a href="#l41.125"></a><span id="l41.125">   // check if this message needs junk classification</span>
<a href="#l41.126"></a><span id="l41.126">   PRUint32 processingFlags;</span>
<a href="#l41.127"></a><span id="l41.127">   GetProcessingFlags(msgKey, &amp;processingFlags);</span>
<a href="#l41.128"></a><span id="l41.128"> </span>
<a href="#l41.129"></a><span id="l41.129" class="difflineminus">-  if (processingFlags &amp; MSG_PROCESSING_FLAG_CLASSIFY_JUNK)</span>
<a href="#l41.130"></a><span id="l41.130" class="difflineplus">+  if (processingFlags &amp; nsMsgProcessingFlags::ClassifyJunk)</span>
<a href="#l41.131"></a><span id="l41.131">   {</span>
<a href="#l41.132"></a><span id="l41.132" class="difflineminus">-    AndProcessingFlags(msgKey, ~MSG_PROCESSING_FLAG_CLASSIFY_JUNK);</span>
<a href="#l41.133"></a><span id="l41.133" class="difflineplus">+    AndProcessingFlags(msgKey, ~nsMsgProcessingFlags::ClassifyJunk);</span>
<a href="#l41.134"></a><span id="l41.134"> </span>
<a href="#l41.135"></a><span id="l41.135">     nsCAutoString msgJunkScore;</span>
<a href="#l41.136"></a><span id="l41.136">     msgJunkScore.AppendInt(aClassification == nsIJunkMailPlugin::JUNK ?</span>
<a href="#l41.137"></a><span id="l41.137">           nsIJunkMailPlugin::IS_SPAM_SCORE:</span>
<a href="#l41.138"></a><span id="l41.138">           nsIJunkMailPlugin::IS_HAM_SCORE);</span>
<a href="#l41.139"></a><span id="l41.139">     mDatabase-&gt;SetStringProperty(msgKey, &quot;junkscore&quot;, msgJunkScore.get());</span>
<a href="#l41.140"></a><span id="l41.140">     mDatabase-&gt;SetStringProperty(msgKey, &quot;junkscoreorigin&quot;, &quot;plugin&quot;);</span>
<a href="#l41.141"></a><span id="l41.141"> </span>
<a href="#l41.142"></a><span id="l41.142" class="difflineat">@@ -3632,20 +3632,20 @@ nsMsgLocalMailFolder::OnMessageTraitsCla</span>
<a href="#l41.143"></a><span id="l41.143">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l41.144"></a><span id="l41.144"> </span>
<a href="#l41.145"></a><span id="l41.145">   nsMsgKey msgKey;</span>
<a href="#l41.146"></a><span id="l41.146">   rv = msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l41.147"></a><span id="l41.147">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l41.148"></a><span id="l41.148"> </span>
<a href="#l41.149"></a><span id="l41.149">   PRUint32 processingFlags;</span>
<a href="#l41.150"></a><span id="l41.150">   GetProcessingFlags(msgKey, &amp;processingFlags);</span>
<a href="#l41.151"></a><span id="l41.151" class="difflineminus">-  if (!(processingFlags &amp; MSG_PROCESSING_FLAG_CLASSIFY_TRAITS))</span>
<a href="#l41.152"></a><span id="l41.152" class="difflineplus">+  if (!(processingFlags &amp; nsMsgProcessingFlags::ClassifyTraits))</span>
<a href="#l41.153"></a><span id="l41.153">     return NS_OK;</span>
<a href="#l41.154"></a><span id="l41.154"> </span>
<a href="#l41.155"></a><span id="l41.155" class="difflineminus">-  AndProcessingFlags(msgKey, ~MSG_PROCESSING_FLAG_CLASSIFY_TRAITS);</span>
<a href="#l41.156"></a><span id="l41.156" class="difflineplus">+  AndProcessingFlags(msgKey, ~nsMsgProcessingFlags::ClassifyTraits);</span>
<a href="#l41.157"></a><span id="l41.157"> </span>
<a href="#l41.158"></a><span id="l41.158">   nsCOMPtr&lt;nsIMsgTraitService&gt; traitService;</span>
<a href="#l41.159"></a><span id="l41.159">   traitService = do_GetService(&quot;@mozilla.org/msg-trait-service;1&quot;, &amp;rv);</span>
<a href="#l41.160"></a><span id="l41.160">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l41.161"></a><span id="l41.161"> </span>
<a href="#l41.162"></a><span id="l41.162">   for (PRUint32 i = 0; i &lt; aTraitCount; i++)</span>
<a href="#l41.163"></a><span id="l41.163">   {</span>
<a href="#l41.164"></a><span id="l41.164">     if (aTraits[i] == nsIJunkMailPlugin::JUNK_TRAIT)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l42.1"></a><span id="l42.1" class="difflineminus">--- a/mailnews/local/src/nsParseMailbox.cpp</span>
<a href="#l42.2"></a><span id="l42.2" class="difflineplus">+++ b/mailnews/local/src/nsParseMailbox.cpp</span>
<a href="#l42.3"></a><span id="l42.3" class="difflineat">@@ -392,17 +392,17 @@ void nsMsgMailboxParser::UpdateDBFolderI</span>
<a href="#l42.4"></a><span id="l42.4"> // Tell the world about the message header (add to db, and view, if any)</span>
<a href="#l42.5"></a><span id="l42.5"> PRInt32 nsMsgMailboxParser::PublishMsgHeader(nsIMsgWindow *msgWindow)</span>
<a href="#l42.6"></a><span id="l42.6"> {</span>
<a href="#l42.7"></a><span id="l42.7">   FinishHeader();</span>
<a href="#l42.8"></a><span id="l42.8">   if (m_newMsgHdr)</span>
<a href="#l42.9"></a><span id="l42.9">   {</span>
<a href="#l42.10"></a><span id="l42.10">     PRUint32 flags;</span>
<a href="#l42.11"></a><span id="l42.11">     (void)m_newMsgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l42.12"></a><span id="l42.12" class="difflineminus">-    if (flags &amp; MSG_FLAG_EXPUNGED)</span>
<a href="#l42.13"></a><span id="l42.13" class="difflineplus">+    if (flags &amp; nsMsgMessageFlags::Expunged)</span>
<a href="#l42.14"></a><span id="l42.14">     {</span>
<a href="#l42.15"></a><span id="l42.15">       nsCOMPtr&lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l42.16"></a><span id="l42.16">       m_mailDB-&gt;GetDBFolderInfo(getter_AddRefs(folderInfo));</span>
<a href="#l42.17"></a><span id="l42.17">       PRUint32 size;</span>
<a href="#l42.18"></a><span id="l42.18">       (void)m_newMsgHdr-&gt;GetMessageSize(&amp;size);</span>
<a href="#l42.19"></a><span id="l42.19">       folderInfo-&gt;ChangeExpungedBytes(size);</span>
<a href="#l42.20"></a><span id="l42.20">       m_newMsgHdr = nsnull;</span>
<a href="#l42.21"></a><span id="l42.21">     }</span>
<a href="#l42.22"></a><span id="l42.22" class="difflineat">@@ -1173,19 +1173,19 @@ int nsParseMailMessageState::InternSubje</span>
<a href="#l42.23"></a><span id="l42.23">         We trust the X-Mozilla-Status line to be the smartest in almost</span>
<a href="#l42.24"></a><span id="l42.24">         all things.  One exception, however, is the HAS_RE flag.  Since</span>
<a href="#l42.25"></a><span id="l42.25">          we just parsed the subject header anyway, we expect that parsing</span>
<a href="#l42.26"></a><span id="l42.26">          to be smartest.  (After all, what if someone just went in and</span>
<a href="#l42.27"></a><span id="l42.27">         edited the subject line by hand?)</span>
<a href="#l42.28"></a><span id="l42.28">      */</span>
<a href="#l42.29"></a><span id="l42.29">   nsCString modifiedSubject;</span>
<a href="#l42.30"></a><span id="l42.30">   if (NS_MsgStripRE((const char **) &amp;key, &amp;L, getter_Copies(modifiedSubject)))</span>
<a href="#l42.31"></a><span id="l42.31" class="difflineminus">-    flags |= MSG_FLAG_HAS_RE;</span>
<a href="#l42.32"></a><span id="l42.32" class="difflineplus">+    flags |= nsMsgMessageFlags::HasRe;</span>
<a href="#l42.33"></a><span id="l42.33">   else</span>
<a href="#l42.34"></a><span id="l42.34" class="difflineminus">-    flags &amp;= ~MSG_FLAG_HAS_RE;</span>
<a href="#l42.35"></a><span id="l42.35" class="difflineplus">+    flags &amp;= ~nsMsgMessageFlags::HasRe;</span>
<a href="#l42.36"></a><span id="l42.36">   m_newMsgHdr-&gt;SetFlags(flags); // this *does not* update the mozilla-status header in the local folder</span>
<a href="#l42.37"></a><span id="l42.37"> </span>
<a href="#l42.38"></a><span id="l42.38">   //  if (!*key) return 0; /* To catch a subject of &quot;Re:&quot; */</span>
<a href="#l42.39"></a><span id="l42.39"> </span>
<a href="#l42.40"></a><span id="l42.40">   // Condense the subject text into as few MIME-2 encoded words as possible.</span>
<a href="#l42.41"></a><span id="l42.41"> #ifdef WE_CONDENSE_MIME_STRINGS</span>
<a href="#l42.42"></a><span id="l42.42">   char *condensedKey = msg_condense_mime2_string(modifiedSubject.IsEmpty() ? key : modifiedSubject.get());</span>
<a href="#l42.43"></a><span id="l42.43"> #else</span>
<a href="#l42.44"></a><span id="l42.44" class="difflineat">@@ -1270,34 +1270,34 @@ int nsParseMailMessageState::FinalizeHea</span>
<a href="#l42.45"></a><span id="l42.45">     if (strlen(mozstatus-&gt;value) == 4)</span>
<a href="#l42.46"></a><span id="l42.46">     {</span>
<a href="#l42.47"></a><span id="l42.47">       int i;</span>
<a href="#l42.48"></a><span id="l42.48">       for (i=0,s=mozstatus-&gt;value ; i&lt;4 ; i++,s++)</span>
<a href="#l42.49"></a><span id="l42.49">       {</span>
<a href="#l42.50"></a><span id="l42.50">         flags = (flags &lt;&lt; 4) | msg_UnHex(*s);</span>
<a href="#l42.51"></a><span id="l42.51">       }</span>
<a href="#l42.52"></a><span id="l42.52">       // strip off and remember priority bits.</span>
<a href="#l42.53"></a><span id="l42.53" class="difflineminus">-      flags &amp;= ~MSG_FLAG_RUNTIME_ONLY;</span>
<a href="#l42.54"></a><span id="l42.54" class="difflineminus">-      priorityFlags = (nsMsgPriorityValue) ((flags &amp; MSG_FLAG_PRIORITIES) &gt;&gt; 13);</span>
<a href="#l42.55"></a><span id="l42.55" class="difflineminus">-      flags &amp;= ~MSG_FLAG_PRIORITIES;</span>
<a href="#l42.56"></a><span id="l42.56" class="difflineplus">+      flags &amp;= ~nsMsgMessageFlags::RuntimeOnly;</span>
<a href="#l42.57"></a><span id="l42.57" class="difflineplus">+      priorityFlags = (nsMsgPriorityValue) ((flags &amp; nsMsgMessageFlags::Priorities) &gt;&gt; 13);</span>
<a href="#l42.58"></a><span id="l42.58" class="difflineplus">+      flags &amp;= ~nsMsgMessageFlags::Priorities;</span>
<a href="#l42.59"></a><span id="l42.59">     }</span>
<a href="#l42.60"></a><span id="l42.60">     delta = (m_headerstartpos +</span>
<a href="#l42.61"></a><span id="l42.61">       (mozstatus-&gt;value - m_headers.GetBuffer()) -</span>
<a href="#l42.62"></a><span id="l42.62">       (2 + X_MOZILLA_STATUS_LEN)    /* 2 extra bytes for &quot;: &quot;. */</span>
<a href="#l42.63"></a><span id="l42.63">       ) - m_envelope_pos;</span>
<a href="#l42.64"></a><span id="l42.64">   }</span>
<a href="#l42.65"></a><span id="l42.65"> </span>
<a href="#l42.66"></a><span id="l42.66">   if (mozstatus2)</span>
<a href="#l42.67"></a><span id="l42.67">   {</span>
<a href="#l42.68"></a><span id="l42.68">     PRUint32 flags2 = 0;</span>
<a href="#l42.69"></a><span id="l42.69">     sscanf(mozstatus2-&gt;value, &quot; %x &quot;, &amp;flags2);</span>
<a href="#l42.70"></a><span id="l42.70">     flags |= flags2;</span>
<a href="#l42.71"></a><span id="l42.71">   }</span>
<a href="#l42.72"></a><span id="l42.72"> </span>
<a href="#l42.73"></a><span id="l42.73" class="difflineminus">-  if (!(flags &amp; MSG_FLAG_EXPUNGED))  // message was deleted, don't bother creating a hdr.</span>
<a href="#l42.74"></a><span id="l42.74" class="difflineplus">+  if (!(flags &amp; nsMsgMessageFlags::Expunged))  // message was deleted, don't bother creating a hdr.</span>
<a href="#l42.75"></a><span id="l42.75">   {</span>
<a href="#l42.76"></a><span id="l42.76">     // We'll need the message id first to recover data from the backup database</span>
<a href="#l42.77"></a><span id="l42.77">     nsCAutoString rawMsgId;</span>
<a href="#l42.78"></a><span id="l42.78">     /* Take off &lt;&gt; around message ID. */</span>
<a href="#l42.79"></a><span id="l42.79">     if (id)</span>
<a href="#l42.80"></a><span id="l42.80">     {</span>
<a href="#l42.81"></a><span id="l42.81">       if (id-&gt;value[0] == '&lt;')</span>
<a href="#l42.82"></a><span id="l42.82">         id-&gt;value++, id-&gt;length--;</span>
<a href="#l42.83"></a><span id="l42.83" class="difflineat">@@ -1324,39 +1324,39 @@ int nsParseMailMessageState::FinalizeHea</span>
<a href="#l42.84"></a><span id="l42.84">                 oldHeader, PR_FALSE, getter_AddRefs(m_newMsgHdr));</span>
<a href="#l42.85"></a><span id="l42.85">     else</span>
<a href="#l42.86"></a><span id="l42.86">       ret = m_mailDB-&gt;CreateNewHdr(m_envelope_pos, getter_AddRefs(m_newMsgHdr));</span>
<a href="#l42.87"></a><span id="l42.87"> </span>
<a href="#l42.88"></a><span id="l42.88">     if (NS_SUCCEEDED(ret) &amp;&amp; m_newMsgHdr)</span>
<a href="#l42.89"></a><span id="l42.89">     {</span>
<a href="#l42.90"></a><span id="l42.90">       PRUint32 origFlags;</span>
<a href="#l42.91"></a><span id="l42.91">       (void)m_newMsgHdr-&gt;GetFlags(&amp;origFlags);</span>
<a href="#l42.92"></a><span id="l42.92" class="difflineminus">-      if (origFlags &amp; MSG_FLAG_HAS_RE)</span>
<a href="#l42.93"></a><span id="l42.93" class="difflineminus">-        flags |= MSG_FLAG_HAS_RE;</span>
<a href="#l42.94"></a><span id="l42.94" class="difflineplus">+      if (origFlags &amp; nsMsgMessageFlags::HasRe)</span>
<a href="#l42.95"></a><span id="l42.95" class="difflineplus">+        flags |= nsMsgMessageFlags::HasRe;</span>
<a href="#l42.96"></a><span id="l42.96">       else</span>
<a href="#l42.97"></a><span id="l42.97" class="difflineminus">-        flags &amp;= ~MSG_FLAG_HAS_RE;</span>
<a href="#l42.98"></a><span id="l42.98" class="difflineplus">+        flags &amp;= ~nsMsgMessageFlags::HasRe;</span>
<a href="#l42.99"></a><span id="l42.99"> </span>
<a href="#l42.100"></a><span id="l42.100" class="difflineminus">-      flags &amp;= ~MSG_FLAG_OFFLINE; // don't keep MSG_FLAG_OFFLINE for local msgs</span>
<a href="#l42.101"></a><span id="l42.101" class="difflineminus">-      if (mdn_dnt &amp;&amp; !(origFlags &amp; MSG_FLAG_READ) &amp;&amp;</span>
<a href="#l42.102"></a><span id="l42.102" class="difflineminus">-          !(origFlags &amp; MSG_FLAG_MDN_REPORT_SENT) &amp;&amp;</span>
<a href="#l42.103"></a><span id="l42.103" class="difflineminus">-          !(flags &amp; MSG_FLAG_MDN_REPORT_SENT))</span>
<a href="#l42.104"></a><span id="l42.104" class="difflineminus">-        flags |= MSG_FLAG_MDN_REPORT_NEEDED;</span>
<a href="#l42.105"></a><span id="l42.105" class="difflineplus">+      flags &amp;= ~nsMsgMessageFlags::Offline; // don't keep nsMsgMessageFlags::Offline for local msgs</span>
<a href="#l42.106"></a><span id="l42.106" class="difflineplus">+      if (mdn_dnt &amp;&amp; !(origFlags &amp; nsMsgMessageFlags::Read) &amp;&amp;</span>
<a href="#l42.107"></a><span id="l42.107" class="difflineplus">+          !(origFlags &amp; nsMsgMessageFlags::MDNReportSent) &amp;&amp;</span>
<a href="#l42.108"></a><span id="l42.108" class="difflineplus">+          !(flags &amp; nsMsgMessageFlags::MDNReportSent))</span>
<a href="#l42.109"></a><span id="l42.109" class="difflineplus">+        flags |= nsMsgMessageFlags::MDNReportNeeded;</span>
<a href="#l42.110"></a><span id="l42.110"> </span>
<a href="#l42.111"></a><span id="l42.111">       m_newMsgHdr-&gt;SetFlags(flags);</span>
<a href="#l42.112"></a><span id="l42.112">       if (priorityFlags != nsMsgPriority::notSet)</span>
<a href="#l42.113"></a><span id="l42.113">         m_newMsgHdr-&gt;SetPriority(priorityFlags);</span>
<a href="#l42.114"></a><span id="l42.114"> </span>
<a href="#l42.115"></a><span id="l42.115">       // if we have a reply to header, and it's different from the from: header,</span>
<a href="#l42.116"></a><span id="l42.116">       // set the &quot;replyTo&quot; attribute on the msg hdr.</span>
<a href="#l42.117"></a><span id="l42.117">       if (replyTo &amp;&amp; (!sender || replyTo-&gt;length != sender-&gt;length || strncmp(replyTo-&gt;value, sender-&gt;value, sender-&gt;length)))</span>
<a href="#l42.118"></a><span id="l42.118">         m_newMsgHdr-&gt;SetStringProperty(&quot;replyTo&quot;, replyTo-&gt;value);</span>
<a href="#l42.119"></a><span id="l42.119">       // convert the flag values (0xE000000) to label values (0-5)</span>
<a href="#l42.120"></a><span id="l42.120">       if (mozstatus2) // only do this if we have a mozstatus2 header</span>
<a href="#l42.121"></a><span id="l42.121">       {</span>
<a href="#l42.122"></a><span id="l42.122" class="difflineminus">-        labelFlags = ((flags &amp; MSG_FLAG_LABELS) &gt;&gt; 25);</span>
<a href="#l42.123"></a><span id="l42.123" class="difflineplus">+        labelFlags = ((flags &amp; nsMsgMessageFlags::Labels) &gt;&gt; 25);</span>
<a href="#l42.124"></a><span id="l42.124">         m_newMsgHdr-&gt;SetLabel(labelFlags);</span>
<a href="#l42.125"></a><span id="l42.125">       }</span>
<a href="#l42.126"></a><span id="l42.126">       if (delta &lt; 0xffff)</span>
<a href="#l42.127"></a><span id="l42.127">       {    /* Only use if fits in 16 bits. */</span>
<a href="#l42.128"></a><span id="l42.128">         m_newMsgHdr-&gt;SetStatusOffset((PRUint16) delta);</span>
<a href="#l42.129"></a><span id="l42.129">         if (!m_IgnoreXMozillaStatus) {  // imap doesn't care about X-MozillaStatus</span>
<a href="#l42.130"></a><span id="l42.130">           PRUint32 offset;</span>
<a href="#l42.131"></a><span id="l42.131">           (void)m_newMsgHdr-&gt;GetStatusOffset(&amp;offset);</span>
<a href="#l42.132"></a><span id="l42.132" class="difflineat">@@ -1457,24 +1457,24 @@ int nsParseMailMessageState::FinalizeHea</span>
<a href="#l42.133"></a><span id="l42.133">         {</span>
<a href="#l42.134"></a><span id="l42.134">           /* Parse a little bit of the Berkeley Mail status header. */</span>
<a href="#l42.135"></a><span id="l42.135">           for (s = statush-&gt;value; *s; s++) {</span>
<a href="#l42.136"></a><span id="l42.136">             PRUint32 msgFlags = 0;</span>
<a href="#l42.137"></a><span id="l42.137">             (void)m_newMsgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l42.138"></a><span id="l42.138">             switch (*s)</span>
<a href="#l42.139"></a><span id="l42.139">             {</span>
<a href="#l42.140"></a><span id="l42.140">             case 'R': case 'r':</span>
<a href="#l42.141"></a><span id="l42.141" class="difflineminus">-              m_newMsgHdr-&gt;SetFlags(msgFlags | MSG_FLAG_READ);</span>
<a href="#l42.142"></a><span id="l42.142" class="difflineplus">+              m_newMsgHdr-&gt;SetFlags(msgFlags | nsMsgMessageFlags::Read);</span>
<a href="#l42.143"></a><span id="l42.143">               break;</span>
<a href="#l42.144"></a><span id="l42.144">             case 'D': case 'd':</span>
<a href="#l42.145"></a><span id="l42.145" class="difflineminus">-              /* msg-&gt;flags |= MSG_FLAG_EXPUNGED;  ### Is this reasonable? */</span>
<a href="#l42.146"></a><span id="l42.146" class="difflineplus">+              /* msg-&gt;flags |= nsMsgMessageFlags::Expunged;  ### Is this reasonable? */</span>
<a href="#l42.147"></a><span id="l42.147">               break;</span>
<a href="#l42.148"></a><span id="l42.148">             case 'N': case 'n':</span>
<a href="#l42.149"></a><span id="l42.149">             case 'U': case 'u':</span>
<a href="#l42.150"></a><span id="l42.150" class="difflineminus">-              m_newMsgHdr-&gt;SetFlags(msgFlags &amp; ~MSG_FLAG_READ);</span>
<a href="#l42.151"></a><span id="l42.151" class="difflineplus">+              m_newMsgHdr-&gt;SetFlags(msgFlags &amp; ~nsMsgMessageFlags::Read);</span>
<a href="#l42.152"></a><span id="l42.152">               break;</span>
<a href="#l42.153"></a><span id="l42.153">             }</span>
<a href="#l42.154"></a><span id="l42.154">           }</span>
<a href="#l42.155"></a><span id="l42.155">         }</span>
<a href="#l42.156"></a><span id="l42.156"> </span>
<a href="#l42.157"></a><span id="l42.157">         if (account_key != nsnull)</span>
<a href="#l42.158"></a><span id="l42.158">           m_newMsgHdr-&gt;SetAccountKey(account_key-&gt;value);</span>
<a href="#l42.159"></a><span id="l42.159">         // use in-reply-to header as references, if there's no references header</span>
<a href="#l42.160"></a><span id="l42.160" class="difflineat">@@ -1588,17 +1588,17 @@ int nsParseMailMessageState::FinalizeHea</span>
<a href="#l42.161"></a><span id="l42.161">                 }</span>
<a href="#l42.162"></a><span id="l42.162">               }</span>
<a href="#l42.163"></a><span id="l42.163">             }</span>
<a href="#l42.164"></a><span id="l42.164">           }</span>
<a href="#l42.165"></a><span id="l42.165">           substring = PL_strcasestr(content_type-&gt;value, &quot;multipart/mixed&quot;);</span>
<a href="#l42.166"></a><span id="l42.166">           if (substring)</span>
<a href="#l42.167"></a><span id="l42.167">           {</span>
<a href="#l42.168"></a><span id="l42.168">             PRUint32 newFlags;</span>
<a href="#l42.169"></a><span id="l42.169" class="difflineminus">-            m_newMsgHdr-&gt;OrFlags(MSG_FLAG_ATTACHMENT, &amp;newFlags);</span>
<a href="#l42.170"></a><span id="l42.170" class="difflineplus">+            m_newMsgHdr-&gt;OrFlags(nsMsgMessageFlags::Attachment, &amp;newFlags);</span>
<a href="#l42.171"></a><span id="l42.171">           }</span>
<a href="#l42.172"></a><span id="l42.172">         }</span>
<a href="#l42.173"></a><span id="l42.173">       }</span>
<a href="#l42.174"></a><span id="l42.174">     }</span>
<a href="#l42.175"></a><span id="l42.175">     else</span>
<a href="#l42.176"></a><span id="l42.176">     {</span>
<a href="#l42.177"></a><span id="l42.177">       NS_ASSERTION(PR_FALSE, &quot;error creating message header&quot;);</span>
<a href="#l42.178"></a><span id="l42.178">       status = NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l42.179"></a><span id="l42.179" class="difflineat">@@ -1808,18 +1808,18 @@ PRInt32 nsParseNewMailState::PublishMsgH</span>
<a href="#l42.180"></a><span id="l42.180">       ApplyFilters(&amp;moved, msgWindow, msgOffset);</span>
<a href="#l42.181"></a><span id="l42.181">     }</span>
<a href="#l42.182"></a><span id="l42.182">     if (!moved)</span>
<a href="#l42.183"></a><span id="l42.183">     {</span>
<a href="#l42.184"></a><span id="l42.184">       if (m_mailDB)</span>
<a href="#l42.185"></a><span id="l42.185">       {</span>
<a href="#l42.186"></a><span id="l42.186">         PRUint32 newFlags, oldFlags;</span>
<a href="#l42.187"></a><span id="l42.187">         m_newMsgHdr-&gt;GetFlags(&amp;oldFlags);</span>
<a href="#l42.188"></a><span id="l42.188" class="difflineminus">-        if (!(oldFlags &amp; MSG_FLAG_READ)) // don't mark read messages as new.</span>
<a href="#l42.189"></a><span id="l42.189" class="difflineminus">-          m_newMsgHdr-&gt;OrFlags(MSG_FLAG_NEW, &amp;newFlags);</span>
<a href="#l42.190"></a><span id="l42.190" class="difflineplus">+        if (!(oldFlags &amp; nsMsgMessageFlags::Read)) // don't mark read messages as new.</span>
<a href="#l42.191"></a><span id="l42.191" class="difflineplus">+          m_newMsgHdr-&gt;OrFlags(nsMsgMessageFlags::New, &amp;newFlags);</span>
<a href="#l42.192"></a><span id="l42.192"> </span>
<a href="#l42.193"></a><span id="l42.193">         m_mailDB-&gt;AddNewHdrToDB(m_newMsgHdr, PR_TRUE);</span>
<a href="#l42.194"></a><span id="l42.194">         nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l42.195"></a><span id="l42.195">         if (notifier)</span>
<a href="#l42.196"></a><span id="l42.196">           notifier-&gt;NotifyMsgAdded(m_newMsgHdr);</span>
<a href="#l42.197"></a><span id="l42.197">       }</span>
<a href="#l42.198"></a><span id="l42.198">     } // if it was moved by imap filter, m_parseMsgState-&gt;m_newMsgHdr == nsnull</span>
<a href="#l42.199"></a><span id="l42.199">     m_newMsgHdr = nsnull;</span>
<a href="#l42.200"></a><span id="l42.200" class="difflineat">@@ -1935,17 +1935,17 @@ NS_IMETHODIMP nsParseNewMailState::Apply</span>
<a href="#l42.201"></a><span id="l42.201">       case nsMsgFilterAction::Delete:</span>
<a href="#l42.202"></a><span id="l42.202">         {</span>
<a href="#l42.203"></a><span id="l42.203">           nsCOMPtr &lt;nsIMsgFolder&gt; trash;</span>
<a href="#l42.204"></a><span id="l42.204">           // set value to trash folder</span>
<a href="#l42.205"></a><span id="l42.205">           rv = GetTrashFolder(getter_AddRefs(trash));</span>
<a href="#l42.206"></a><span id="l42.206">           if (NS_SUCCEEDED(rv) &amp;&amp; trash)</span>
<a href="#l42.207"></a><span id="l42.207">             rv = trash-&gt;GetURI(actionTargetFolderUri);</span>
<a href="#l42.208"></a><span id="l42.208"> </span>
<a href="#l42.209"></a><span id="l42.209" class="difflineminus">-          msgHdr-&gt;OrFlags(MSG_FLAG_READ, &amp;newFlags); // mark read in trash.</span>
<a href="#l42.210"></a><span id="l42.210" class="difflineplus">+          msgHdr-&gt;OrFlags(nsMsgMessageFlags::Read, &amp;newFlags); // mark read in trash.</span>
<a href="#l42.211"></a><span id="l42.211">           msgIsNew = PR_FALSE;</span>
<a href="#l42.212"></a><span id="l42.212">         }</span>
<a href="#l42.213"></a><span id="l42.213">       case nsMsgFilterAction::MoveToFolder:</span>
<a href="#l42.214"></a><span id="l42.214">         // if moving to a different file, do it.</span>
<a href="#l42.215"></a><span id="l42.215">         if (actionTargetFolderUri.get() &amp;&amp; !m_inboxUri.Equals(actionTargetFolderUri,</span>
<a href="#l42.216"></a><span id="l42.216">                                                              nsCaseInsensitiveCStringComparator()))</span>
<a href="#l42.217"></a><span id="l42.217">         {</span>
<a href="#l42.218"></a><span id="l42.218">           nsresult err;</span>
<a href="#l42.219"></a><span id="l42.219" class="difflineat">@@ -2021,23 +2021,23 @@ NS_IMETHODIMP nsParseNewMailState::Apply</span>
<a href="#l42.220"></a><span id="l42.220">           }</span>
<a href="#l42.221"></a><span id="l42.221">         }</span>
<a href="#l42.222"></a><span id="l42.222">         break;</span>
<a href="#l42.223"></a><span id="l42.223">       case nsMsgFilterAction::MarkRead:</span>
<a href="#l42.224"></a><span id="l42.224">         msgIsNew = PR_FALSE;</span>
<a href="#l42.225"></a><span id="l42.225">         MarkFilteredMessageRead(msgHdr);</span>
<a href="#l42.226"></a><span id="l42.226">         break;</span>
<a href="#l42.227"></a><span id="l42.227">       case nsMsgFilterAction::KillThread:</span>
<a href="#l42.228"></a><span id="l42.228" class="difflineminus">-        msgHdr-&gt;SetUint32Property(&quot;ProtoThreadFlags&quot;, MSG_FLAG_IGNORED);</span>
<a href="#l42.229"></a><span id="l42.229" class="difflineplus">+        msgHdr-&gt;SetUint32Property(&quot;ProtoThreadFlags&quot;, nsMsgMessageFlags::Ignored);</span>
<a href="#l42.230"></a><span id="l42.230">         break;</span>
<a href="#l42.231"></a><span id="l42.231">       case nsMsgFilterAction::KillSubthread:</span>
<a href="#l42.232"></a><span id="l42.232" class="difflineminus">-        msgHdr-&gt;OrFlags(MSG_FLAG_IGNORED, &amp;newFlags);</span>
<a href="#l42.233"></a><span id="l42.233" class="difflineplus">+        msgHdr-&gt;OrFlags(nsMsgMessageFlags::Ignored, &amp;newFlags);</span>
<a href="#l42.234"></a><span id="l42.234">         break;</span>
<a href="#l42.235"></a><span id="l42.235">       case nsMsgFilterAction::WatchThread:</span>
<a href="#l42.236"></a><span id="l42.236" class="difflineminus">-        msgHdr-&gt;OrFlags(MSG_FLAG_WATCHED, &amp;newFlags);</span>
<a href="#l42.237"></a><span id="l42.237" class="difflineplus">+        msgHdr-&gt;OrFlags(nsMsgMessageFlags::Watched, &amp;newFlags);</span>
<a href="#l42.238"></a><span id="l42.238">         break;</span>
<a href="#l42.239"></a><span id="l42.239">       case nsMsgFilterAction::MarkFlagged:</span>
<a href="#l42.240"></a><span id="l42.240">         msgHdr-&gt;MarkFlagged(PR_TRUE);</span>
<a href="#l42.241"></a><span id="l42.241">         break;</span>
<a href="#l42.242"></a><span id="l42.242">       case nsMsgFilterAction::ChangePriority:</span>
<a href="#l42.243"></a><span id="l42.243">         nsMsgPriorityValue filterPriority;</span>
<a href="#l42.244"></a><span id="l42.244">         filterAction-&gt;GetPriority(&amp;filterPriority);</span>
<a href="#l42.245"></a><span id="l42.245">         msgHdr-&gt;SetPriority(filterPriority);</span>
<a href="#l42.246"></a><span id="l42.246" class="difflineat">@@ -2100,32 +2100,32 @@ NS_IMETHODIMP nsParseNewMailState::Apply</span>
<a href="#l42.247"></a><span id="l42.247">             nsCOMPtr&lt;nsIMutableArray&gt; messages = do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv);</span>
<a href="#l42.248"></a><span id="l42.248">             NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l42.249"></a><span id="l42.249">             messages-&gt;AppendElement(msgHdr, PR_FALSE);</span>
<a href="#l42.250"></a><span id="l42.250">             // This action ignores the deleteMailLeftOnServer preference</span>
<a href="#l42.251"></a><span id="l42.251">             localFolder-&gt;MarkMsgsOnPop3Server(messages, POP3_FORCE_DEL);</span>
<a href="#l42.252"></a><span id="l42.252"> </span>
<a href="#l42.253"></a><span id="l42.253">             // If this is just a header, throw it away. It's useless now</span>
<a href="#l42.254"></a><span id="l42.254">             // that the server copy is being deleted.</span>
<a href="#l42.255"></a><span id="l42.255" class="difflineminus">-            if (flags &amp; MSG_FLAG_PARTIAL)</span>
<a href="#l42.256"></a><span id="l42.256" class="difflineplus">+            if (flags &amp; nsMsgMessageFlags::Partial)</span>
<a href="#l42.257"></a><span id="l42.257">             {</span>
<a href="#l42.258"></a><span id="l42.258">               m_msgMovedByFilter = PR_TRUE;</span>
<a href="#l42.259"></a><span id="l42.259">               msgIsNew = PR_FALSE;</span>
<a href="#l42.260"></a><span id="l42.260">             }</span>
<a href="#l42.261"></a><span id="l42.261">           }</span>
<a href="#l42.262"></a><span id="l42.262">         }</span>
<a href="#l42.263"></a><span id="l42.263">         break;</span>
<a href="#l42.264"></a><span id="l42.264">       case nsMsgFilterAction::FetchBodyFromPop3Server:</span>
<a href="#l42.265"></a><span id="l42.265">         {</span>
<a href="#l42.266"></a><span id="l42.266">           PRUint32 flags = 0;</span>
<a href="#l42.267"></a><span id="l42.267">           nsCOMPtr &lt;nsIMsgFolder&gt; downloadFolder;</span>
<a href="#l42.268"></a><span id="l42.268">           msgHdr-&gt;GetFolder(getter_AddRefs(downloadFolder));</span>
<a href="#l42.269"></a><span id="l42.269">           nsCOMPtr &lt;nsIMsgLocalMailFolder&gt; localFolder = do_QueryInterface(downloadFolder);</span>
<a href="#l42.270"></a><span id="l42.270">           msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l42.271"></a><span id="l42.271" class="difflineminus">-          if (localFolder &amp;&amp; (flags &amp; MSG_FLAG_PARTIAL))</span>
<a href="#l42.272"></a><span id="l42.272" class="difflineplus">+          if (localFolder &amp;&amp; (flags &amp; nsMsgMessageFlags::Partial))</span>
<a href="#l42.273"></a><span id="l42.273">           {</span>
<a href="#l42.274"></a><span id="l42.274">             nsCOMPtr&lt;nsIMutableArray&gt; messages = do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv);</span>
<a href="#l42.275"></a><span id="l42.275">             NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l42.276"></a><span id="l42.276">             messages-&gt;AppendElement(msgHdr, PR_FALSE);</span>
<a href="#l42.277"></a><span id="l42.277">             localFolder-&gt;MarkMsgsOnPop3Server(messages, POP3_FETCH_BODY);</span>
<a href="#l42.278"></a><span id="l42.278">             // Don't add this header to the DB, we're going to replace it</span>
<a href="#l42.279"></a><span id="l42.279">             // with the full message.</span>
<a href="#l42.280"></a><span id="l42.280">             m_msgMovedByFilter = PR_TRUE;</span>
<a href="#l42.281"></a><span id="l42.281" class="difflineat">@@ -2228,17 +2228,17 @@ nsresult nsParseNewMailState::ApplyForwa</span>
<a href="#l42.282"></a><span id="l42.282"> </span>
<a href="#l42.283"></a><span id="l42.283"> </span>
<a href="#l42.284"></a><span id="l42.284"> int nsParseNewMailState::MarkFilteredMessageRead(nsIMsgDBHdr *msgHdr)</span>
<a href="#l42.285"></a><span id="l42.285"> {</span>
<a href="#l42.286"></a><span id="l42.286">   PRUint32 newFlags;</span>
<a href="#l42.287"></a><span id="l42.287">   if (m_mailDB)</span>
<a href="#l42.288"></a><span id="l42.288">     m_mailDB-&gt;MarkHdrRead(msgHdr, PR_TRUE, nsnull);</span>
<a href="#l42.289"></a><span id="l42.289">   else</span>
<a href="#l42.290"></a><span id="l42.290" class="difflineminus">-    msgHdr-&gt;OrFlags(MSG_FLAG_READ, &amp;newFlags);</span>
<a href="#l42.291"></a><span id="l42.291" class="difflineplus">+    msgHdr-&gt;OrFlags(nsMsgMessageFlags::Read, &amp;newFlags);</span>
<a href="#l42.292"></a><span id="l42.292">   return 0;</span>
<a href="#l42.293"></a><span id="l42.293"> }</span>
<a href="#l42.294"></a><span id="l42.294"> </span>
<a href="#l42.295"></a><span id="l42.295"> nsresult nsParseNewMailState::EndMsgDownload()</span>
<a href="#l42.296"></a><span id="l42.296"> {</span>
<a href="#l42.297"></a><span id="l42.297">   if (m_moveCoalescer)</span>
<a href="#l42.298"></a><span id="l42.298">     m_moveCoalescer-&gt;PlaybackMoves();</span>
<a href="#l42.299"></a><span id="l42.299"> </span>
<a href="#l42.300"></a><span id="l42.300" class="difflineat">@@ -2440,23 +2440,23 @@ nsresult nsParseNewMailState::MoveIncorp</span>
<a href="#l42.301"></a><span id="l42.301"> </span>
<a href="#l42.302"></a><span id="l42.302">     nsresult msgErr = destMailDB-&gt;CopyHdrFromExistingHdr(newMsgPos, mailHdr, PR_FALSE, getter_AddRefs(newHdr));</span>
<a href="#l42.303"></a><span id="l42.303">     if (NS_SUCCEEDED(msgErr) &amp;&amp; newHdr)</span>
<a href="#l42.304"></a><span id="l42.304">     {</span>
<a href="#l42.305"></a><span id="l42.305">       PRUint32 newFlags;</span>
<a href="#l42.306"></a><span id="l42.306">       // set new byte offset, since the offset in the old file is certainly wrong</span>
<a href="#l42.307"></a><span id="l42.307">       newHdr-&gt;SetMessageKey (newMsgPos);</span>
<a href="#l42.308"></a><span id="l42.308">       newHdr-&gt;GetFlags(&amp;newFlags);</span>
<a href="#l42.309"></a><span id="l42.309" class="difflineminus">-      if (! (newFlags &amp; MSG_FLAG_READ))</span>
<a href="#l42.310"></a><span id="l42.310" class="difflineplus">+      if (! (newFlags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l42.311"></a><span id="l42.311">       {</span>
<a href="#l42.312"></a><span id="l42.312">         nsCString junkScoreStr;</span>
<a href="#l42.313"></a><span id="l42.313">         (void) newHdr-&gt;GetStringProperty(&quot;junkscore&quot;, getter_Copies(junkScoreStr));</span>
<a href="#l42.314"></a><span id="l42.314">         if (atoi(junkScoreStr.get()) == nsIJunkMailPlugin::IS_HAM_SCORE)</span>
<a href="#l42.315"></a><span id="l42.315">         {</span>
<a href="#l42.316"></a><span id="l42.316" class="difflineminus">-          newHdr-&gt;OrFlags(MSG_FLAG_NEW, &amp;newFlags);</span>
<a href="#l42.317"></a><span id="l42.317" class="difflineplus">+          newHdr-&gt;OrFlags(nsMsgMessageFlags::New, &amp;newFlags);</span>
<a href="#l42.318"></a><span id="l42.318">           destMailDB-&gt;AddToNewList(newMsgPos);</span>
<a href="#l42.319"></a><span id="l42.319">           movedMsgIsNew = PR_TRUE;</span>
<a href="#l42.320"></a><span id="l42.320">         }</span>
<a href="#l42.321"></a><span id="l42.321">       }</span>
<a href="#l42.322"></a><span id="l42.322">       destMailDB-&gt;AddNewHdrToDB(newHdr, PR_TRUE);</span>
<a href="#l42.323"></a><span id="l42.323">       nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l42.324"></a><span id="l42.324">       if (notifier)</span>
<a href="#l42.325"></a><span id="l42.325">         notifier-&gt;NotifyMsgAdded(newHdr);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l43.1"></a><span id="l43.1" class="difflineminus">--- a/mailnews/local/src/nsPop3Protocol.cpp</span>
<a href="#l43.2"></a><span id="l43.2" class="difflineplus">+++ b/mailnews/local/src/nsPop3Protocol.cpp</span>
<a href="#l43.3"></a><span id="l43.3" class="difflineat">@@ -2904,31 +2904,31 @@ nsPop3Protocol::RetrResponse(nsIInputStr</span>
<a href="#l43.4"></a><span id="l43.4">         if(!m_pop3ConData-&gt;command_succeeded)</span>
<a href="#l43.5"></a><span id="l43.5">             return Error(POP3_RETR_FAILURE);</span>
<a href="#l43.6"></a><span id="l43.6"> </span>
<a href="#l43.7"></a><span id="l43.7">         /* a successful RETR response looks like: #num_bytes Junk</span>
<a href="#l43.8"></a><span id="l43.8">            from TOP we only get the +OK and data</span>
<a href="#l43.9"></a><span id="l43.9">            */</span>
<a href="#l43.10"></a><span id="l43.10">         if (m_pop3ConData-&gt;truncating_cur_msg)</span>
<a href="#l43.11"></a><span id="l43.11">         { /* TOP, truncated message */</span>
<a href="#l43.12"></a><span id="l43.12" class="difflineminus">-            flags |= MSG_FLAG_PARTIAL;</span>
<a href="#l43.13"></a><span id="l43.13" class="difflineplus">+            flags |= nsMsgMessageFlags::Partial;</span>
<a href="#l43.14"></a><span id="l43.14">         }</span>
<a href="#l43.15"></a><span id="l43.15">         else</span>
<a href="#l43.16"></a><span id="l43.16">         {</span>
<a href="#l43.17"></a><span id="l43.17">           nsCString cmdResp(m_commandResponse);</span>
<a href="#l43.18"></a><span id="l43.18">           char *newStr = cmdResp.BeginWriting();</span>
<a href="#l43.19"></a><span id="l43.19">           char *num = NS_strtok( &quot; &quot;, &amp;newStr);</span>
<a href="#l43.20"></a><span id="l43.20">           if (num)</span>
<a href="#l43.21"></a><span id="l43.21">             m_pop3ConData-&gt;cur_msg_size = atol(num);</span>
<a href="#l43.22"></a><span id="l43.22">           m_commandResponse = newStr;</span>
<a href="#l43.23"></a><span id="l43.23">         }</span>
<a href="#l43.24"></a><span id="l43.24"> </span>
<a href="#l43.25"></a><span id="l43.25">         /* RETR complete message */</span>
<a href="#l43.26"></a><span id="l43.26">         if (!m_senderInfo.IsEmpty())</span>
<a href="#l43.27"></a><span id="l43.27" class="difflineminus">-            flags |= MSG_FLAG_SENDER_AUTHED;</span>
<a href="#l43.28"></a><span id="l43.28" class="difflineplus">+            flags |= nsMsgMessageFlags::SenderAuthed;</span>
<a href="#l43.29"></a><span id="l43.29"> </span>
<a href="#l43.30"></a><span id="l43.30">         if(m_pop3ConData-&gt;cur_msg_size &lt;= 0)</span>
<a href="#l43.31"></a><span id="l43.31">         {</span>
<a href="#l43.32"></a><span id="l43.32">           if (m_pop3ConData-&gt;msg_info)</span>
<a href="#l43.33"></a><span id="l43.33">             m_pop3ConData-&gt;cur_msg_size = m_pop3ConData-&gt;msg_info[m_pop3ConData-&gt;last_accessed_msg].size;</span>
<a href="#l43.34"></a><span id="l43.34">           else</span>
<a href="#l43.35"></a><span id="l43.35">             m_pop3ConData-&gt;cur_msg_size = 0;</span>
<a href="#l43.36"></a><span id="l43.36">         }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l44.1"></a><span id="l44.1" class="difflineminus">--- a/mailnews/local/src/nsPop3Sink.cpp</span>
<a href="#l44.2"></a><span id="l44.2" class="difflineplus">+++ b/mailnews/local/src/nsPop3Sink.cpp</span>
<a href="#l44.3"></a><span id="l44.3" class="difflineat">@@ -188,17 +188,17 @@ nsPop3Sink::FindPartialMessages(nsILocal</span>
<a href="#l44.4"></a><span id="l44.4">     messages-&gt;HasMoreElements(&amp;hasMore);</span>
<a href="#l44.5"></a><span id="l44.5">   while(hasMore &amp;&amp; NS_SUCCEEDED(rv))</span>
<a href="#l44.6"></a><span id="l44.6">   {</span>
<a href="#l44.7"></a><span id="l44.7">     nsCOMPtr&lt;nsISupports&gt; aSupport;</span>
<a href="#l44.8"></a><span id="l44.8">     PRUint32 flags = 0;</span>
<a href="#l44.9"></a><span id="l44.9">     rv = messages-&gt;GetNext(getter_AddRefs(aSupport));</span>
<a href="#l44.10"></a><span id="l44.10">     nsCOMPtr&lt;nsIMsgDBHdr&gt; msgDBHdr(do_QueryInterface(aSupport, &amp;rv));</span>
<a href="#l44.11"></a><span id="l44.11">     msgDBHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l44.12"></a><span id="l44.12" class="difflineminus">-    if (flags &amp; MSG_FLAG_PARTIAL)</span>
<a href="#l44.13"></a><span id="l44.13" class="difflineplus">+    if (flags &amp; nsMsgMessageFlags::Partial)</span>
<a href="#l44.14"></a><span id="l44.14">     {</span>
<a href="#l44.15"></a><span id="l44.15">       // Open the various streams we need to seek and read from the mailbox</span>
<a href="#l44.16"></a><span id="l44.16">       if (!isOpen)</span>
<a href="#l44.17"></a><span id="l44.17">       {</span>
<a href="#l44.18"></a><span id="l44.18">         folderScanState.m_localFile = folderFile;</span>
<a href="#l44.19"></a><span id="l44.19">         rv = localFolder-&gt;GetFolderScanState(&amp;folderScanState);</span>
<a href="#l44.20"></a><span id="l44.20">         if (NS_SUCCEEDED(rv))</span>
<a href="#l44.21"></a><span id="l44.21">           isOpen = PR_TRUE;</span>
<a href="#l44.22"></a><span id="l44.22" class="difflineat">@@ -859,23 +859,23 @@ nsPop3Sink::IncorporateComplete(nsIMsgWi</span>
<a href="#l44.23"></a><span id="l44.23">             return HandleTempDownloadFailed(aMsgWindow);</span>
<a href="#l44.24"></a><span id="l44.24"> </span>
<a href="#l44.25"></a><span id="l44.25">           // if we have made it this far then the message has successfully been written to the new folder</span>
<a href="#l44.26"></a><span id="l44.26">           // now add the header to the destMailDB.</span>
<a href="#l44.27"></a><span id="l44.27">           if (NS_SUCCEEDED(rv) &amp;&amp; m_newMailParser-&gt;m_mailDB)</span>
<a href="#l44.28"></a><span id="l44.28">           {</span>
<a href="#l44.29"></a><span id="l44.29">             PRUint32 newFlags;</span>
<a href="#l44.30"></a><span id="l44.30">             hdr-&gt;GetFlags(&amp;newFlags);</span>
<a href="#l44.31"></a><span id="l44.31" class="difflineminus">-            if (! (newFlags &amp; MSG_FLAG_READ))</span>
<a href="#l44.32"></a><span id="l44.32" class="difflineplus">+            if (! (newFlags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l44.33"></a><span id="l44.33">             {</span>
<a href="#l44.34"></a><span id="l44.34">               nsCString junkScoreStr;</span>
<a href="#l44.35"></a><span id="l44.35">               (void) hdr-&gt;GetStringProperty(&quot;junkscore&quot;, getter_Copies(junkScoreStr));</span>
<a href="#l44.36"></a><span id="l44.36">               if (atoi(junkScoreStr.get()) &lt; 50)</span>
<a href="#l44.37"></a><span id="l44.37">               {</span>
<a href="#l44.38"></a><span id="l44.38" class="difflineminus">-                hdr-&gt;OrFlags(MSG_FLAG_NEW, &amp;newFlags);</span>
<a href="#l44.39"></a><span id="l44.39" class="difflineplus">+                hdr-&gt;OrFlags(nsMsgMessageFlags::New, &amp;newFlags);</span>
<a href="#l44.40"></a><span id="l44.40">                 m_newMailParser-&gt;m_mailDB-&gt;AddToNewList(newMsgPos);</span>
<a href="#l44.41"></a><span id="l44.41">               }</span>
<a href="#l44.42"></a><span id="l44.42">             }</span>
<a href="#l44.43"></a><span id="l44.43">             m_newMailParser-&gt;m_mailDB-&gt;AddNewHdrToDB(hdr, PR_TRUE);</span>
<a href="#l44.44"></a><span id="l44.44">             nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l44.45"></a><span id="l44.45">             if (notifier)</span>
<a href="#l44.46"></a><span id="l44.46">               notifier-&gt;NotifyMsgAdded(hdr);</span>
<a href="#l44.47"></a><span id="l44.47">           }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l45.1"></a><span id="l45.1" class="difflineminus">--- a/mailnews/mapi/mapihook/src/msgMapiImp.cpp</span>
<a href="#l45.2"></a><span id="l45.2" class="difflineplus">+++ b/mailnews/mapi/mapihook/src/msgMapiImp.cpp</span>
<a href="#l45.3"></a><span id="l45.3" class="difflineat">@@ -571,17 +571,17 @@ nsMsgKey MsgMapiListContext::GetNext ()</span>
<a href="#l45.4"></a><span id="l45.4">         if (!IsIMAPHost())</span>
<a href="#l45.5"></a><span id="l45.5">           return key;</span>
<a href="#l45.6"></a><span id="l45.6">         </span>
<a href="#l45.7"></a><span id="l45.7">         // If this is an IMAP message, we have to make sure we have a valid</span>
<a href="#l45.8"></a><span id="l45.8">         // body to work with.</span>
<a href="#l45.9"></a><span id="l45.9">         PRUint32  flags = 0;</span>
<a href="#l45.10"></a><span id="l45.10">         </span>
<a href="#l45.11"></a><span id="l45.11">         (void) msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l45.12"></a><span id="l45.12" class="difflineminus">-        if (flags &amp; MSG_FLAG_OFFLINE) </span>
<a href="#l45.13"></a><span id="l45.13" class="difflineplus">+        if (flags &amp; nsMsgMessageFlags::Offline) </span>
<a href="#l45.14"></a><span id="l45.14">           return key;</span>
<a href="#l45.15"></a><span id="l45.15">         </span>
<a href="#l45.16"></a><span id="l45.16">         // Ok, if we get here, we have an IMAP message without a body!</span>
<a href="#l45.17"></a><span id="l45.17">         // We need to keep trying by calling the GetNext member recursively...</span>
<a href="#l45.18"></a><span id="l45.18">         keepTrying = TRUE;</span>
<a href="#l45.19"></a><span id="l45.19">       }</span>
<a href="#l45.20"></a><span id="l45.20">     } while (keepTrying);</span>
<a href="#l45.21"></a><span id="l45.21">   }</span>
<a href="#l45.22"></a><span id="l45.22" class="difflineat">@@ -619,19 +619,19 @@ lpnsMapiMessage MsgMapiListContext::GetM</span>
<a href="#l45.23"></a><span id="l45.23">       PRUint32 date;</span>
<a href="#l45.24"></a><span id="l45.24">       (void) msgHdr-&gt;GetDateInSeconds(&amp;date);</span>
<a href="#l45.25"></a><span id="l45.25">       message-&gt;lpszDateReceived = ConvertDateToMapiFormat (date);</span>
<a href="#l45.26"></a><span id="l45.26">       </span>
<a href="#l45.27"></a><span id="l45.27">       // Pull out the flags info</span>
<a href="#l45.28"></a><span id="l45.28">       // anything to do with MAPI_SENT? Since we're only reading the Inbox, I guess not</span>
<a href="#l45.29"></a><span id="l45.29">       PRUint32 ourFlags;</span>
<a href="#l45.30"></a><span id="l45.30">       (void) msgHdr-&gt;GetFlags(&amp;ourFlags);</span>
<a href="#l45.31"></a><span id="l45.31" class="difflineminus">-      if (!(ourFlags &amp; MSG_FLAG_READ))</span>
<a href="#l45.32"></a><span id="l45.32" class="difflineplus">+      if (!(ourFlags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l45.33"></a><span id="l45.33">         message-&gt;flFlags |= MAPI_UNREAD;</span>
<a href="#l45.34"></a><span id="l45.34" class="difflineminus">-      if (ourFlags &amp; (MSG_FLAG_MDN_REPORT_NEEDED | MSG_FLAG_MDN_REPORT_SENT))</span>
<a href="#l45.35"></a><span id="l45.35" class="difflineplus">+      if (ourFlags &amp; (nsMsgMessageFlags::MDNReportNeeded | nsMsgMessageFlags::MDNReportSent))</span>
<a href="#l45.36"></a><span id="l45.36">         message-&gt;flFlags |= MAPI_RECEIPT_REQUESTED;</span>
<a href="#l45.37"></a><span id="l45.37">       </span>
<a href="#l45.38"></a><span id="l45.38">       nsCOMPtr&lt;nsIMsgHeaderParser&gt; parser = do_GetService(NS_MAILNEWS_MIME_HEADER_PARSER_CONTRACTID);</span>
<a href="#l45.39"></a><span id="l45.39">       if (!parser)</span>
<a href="#l45.40"></a><span id="l45.40">         return nsnull;</span>
<a href="#l45.41"></a><span id="l45.41">       // Pull out the author/originator info</span>
<a href="#l45.42"></a><span id="l45.42">       message-&gt;lpOriginator = (lpnsMapiRecipDesc) CoTaskMemAlloc (sizeof(nsMapiRecipDesc));</span>
<a href="#l45.43"></a><span id="l45.43">       memset(message-&gt;lpOriginator, 0, sizeof(nsMapiRecipDesc));</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l46.1"></a><span id="l46.1" class="difflineminus">--- a/mailnews/mime/src/mimemsg.cpp</span>
<a href="#l46.2"></a><span id="l46.2" class="difflineplus">+++ b/mailnews/mime/src/mimemsg.cpp</span>
<a href="#l46.3"></a><span id="l46.3" class="difflineat">@@ -510,17 +510,17 @@ MimeMessage_close_headers (MimeObject *o</span>
<a href="#l46.4"></a><span id="l46.4">   // setting up truncated message html fotter function</span>
<a href="#l46.5"></a><span id="l46.5">   char *xmoz = MimeHeaders_get(msg-&gt;hdrs, HEADER_X_MOZILLA_STATUS, PR_FALSE,</span>
<a href="#l46.6"></a><span id="l46.6">                  PR_FALSE);</span>
<a href="#l46.7"></a><span id="l46.7">   if (xmoz)</span>
<a href="#l46.8"></a><span id="l46.8">   {</span>
<a href="#l46.9"></a><span id="l46.9">     PRUint32 flags = 0;</span>
<a href="#l46.10"></a><span id="l46.10">     char dummy = 0;</span>
<a href="#l46.11"></a><span id="l46.11">     if (sscanf(xmoz, &quot; %lx %c&quot;, &amp;flags, &amp;dummy) == 1 &amp;&amp;</span>
<a href="#l46.12"></a><span id="l46.12" class="difflineminus">-      flags &amp; MSG_FLAG_PARTIAL)</span>
<a href="#l46.13"></a><span id="l46.13" class="difflineplus">+      flags &amp; nsMsgMessageFlags::Partial)</span>
<a href="#l46.14"></a><span id="l46.14">     {</span>
<a href="#l46.15"></a><span id="l46.15">       obj-&gt;options-&gt;html_closure = obj;</span>
<a href="#l46.16"></a><span id="l46.16">       obj-&gt;options-&gt;generate_footer_html_fn =</span>
<a href="#l46.17"></a><span id="l46.17">         MimeMessage_partial_message_html;</span>
<a href="#l46.18"></a><span id="l46.18">     }</span>
<a href="#l46.19"></a><span id="l46.19">     PR_FREEIF(xmoz);</span>
<a href="#l46.20"></a><span id="l46.20">   }</span>
<a href="#l46.21"></a><span id="l46.21">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l47.1"></a><span id="l47.1" class="difflineminus">--- a/mailnews/news/src/nsNNTPNewsgroupList.cpp</span>
<a href="#l47.2"></a><span id="l47.2" class="difflineplus">+++ b/mailnews/news/src/nsNNTPNewsgroupList.cpp</span>
<a href="#l47.3"></a><span id="l47.3" class="difflineat">@@ -564,21 +564,21 @@ nsNNTPNewsgroupList::ParseLine(char *lin</span>
<a href="#l47.4"></a><span id="l47.4">     const char *subject = line;  /* #### const evilness */</span>
<a href="#l47.5"></a><span id="l47.5">     PRUint32 subjectLen = strlen(line);</span>
<a href="#l47.6"></a><span id="l47.6"> </span>
<a href="#l47.7"></a><span id="l47.7">     PRUint32 flags = 0;</span>
<a href="#l47.8"></a><span id="l47.8">     // ### should call IsHeaderRead here...</span>
<a href="#l47.9"></a><span id="l47.9">     /* strip &quot;Re: &quot; */</span>
<a href="#l47.10"></a><span id="l47.10">     nsCString modifiedSubject;</span>
<a href="#l47.11"></a><span id="l47.11">     if (NS_MsgStripRE(&amp;subject, &amp;subjectLen, getter_Copies(modifiedSubject)))</span>
<a href="#l47.12"></a><span id="l47.12" class="difflineminus">-      (void) newMsgHdr-&gt;OrFlags(MSG_FLAG_HAS_RE, &amp;flags);</span>
<a href="#l47.13"></a><span id="l47.13" class="difflineplus">+      (void) newMsgHdr-&gt;OrFlags(nsMsgMessageFlags::HasRe, &amp;flags);</span>
<a href="#l47.14"></a><span id="l47.14">     </span>
<a href="#l47.15"></a><span id="l47.15">     // this will make sure read flags agree with newsrc</span>
<a href="#l47.16"></a><span id="l47.16" class="difflineminus">-    if (! (flags &amp; MSG_FLAG_READ))</span>
<a href="#l47.17"></a><span id="l47.17" class="difflineminus">-      rv = newMsgHdr-&gt;OrFlags(MSG_FLAG_NEW, &amp;flags);</span>
<a href="#l47.18"></a><span id="l47.18" class="difflineplus">+    if (! (flags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l47.19"></a><span id="l47.19" class="difflineplus">+      rv = newMsgHdr-&gt;OrFlags(nsMsgMessageFlags::New, &amp;flags);</span>
<a href="#l47.20"></a><span id="l47.20"> </span>
<a href="#l47.21"></a><span id="l47.21">     rv = newMsgHdr-&gt;SetSubject(modifiedSubject.IsEmpty() ? subject : modifiedSubject.get());</span>
<a href="#l47.22"></a><span id="l47.22"> </span>
<a href="#l47.23"></a><span id="l47.23">     if (NS_FAILED(rv))</span>
<a href="#l47.24"></a><span id="l47.24">       return rv;</span>
<a href="#l47.25"></a><span id="l47.25">   }</span>
<a href="#l47.26"></a><span id="l47.26"> </span>
<a href="#l47.27"></a><span id="l47.27">   GET_TOKEN (); /* author */</span>
<a href="#l47.28"></a><span id="l47.28" class="difflineat">@@ -686,28 +686,28 @@ NS_IMETHODIMP nsNNTPNewsgroupList::Apply</span>
<a href="#l47.29"></a><span id="l47.29">       {</span>
<a href="#l47.30"></a><span id="l47.30">       case nsMsgFilterAction::Delete:</span>
<a href="#l47.31"></a><span id="l47.31">         m_addHdrToDB = PR_FALSE;</span>
<a href="#l47.32"></a><span id="l47.32">         break;</span>
<a href="#l47.33"></a><span id="l47.33">       case nsMsgFilterAction::MarkRead:</span>
<a href="#l47.34"></a><span id="l47.34">         m_newsDB-&gt;MarkHdrRead(m_newMsgHdr, PR_TRUE, nsnull);</span>
<a href="#l47.35"></a><span id="l47.35">         break;</span>
<a href="#l47.36"></a><span id="l47.36">       case nsMsgFilterAction::KillThread:</span>
<a href="#l47.37"></a><span id="l47.37" class="difflineminus">-        m_newMsgHdr-&gt;SetUint32Property(&quot;ProtoThreadFlags&quot;, MSG_FLAG_IGNORED);</span>
<a href="#l47.38"></a><span id="l47.38" class="difflineplus">+        m_newMsgHdr-&gt;SetUint32Property(&quot;ProtoThreadFlags&quot;, nsMsgMessageFlags::Ignored);</span>
<a href="#l47.39"></a><span id="l47.39">         break;</span>
<a href="#l47.40"></a><span id="l47.40">       case nsMsgFilterAction::KillSubthread:</span>
<a href="#l47.41"></a><span id="l47.41">         {</span>
<a href="#l47.42"></a><span id="l47.42">           PRUint32 newFlags;</span>
<a href="#l47.43"></a><span id="l47.43" class="difflineminus">-          m_newMsgHdr-&gt;OrFlags(MSG_FLAG_IGNORED, &amp;newFlags);</span>
<a href="#l47.44"></a><span id="l47.44" class="difflineplus">+          m_newMsgHdr-&gt;OrFlags(nsMsgMessageFlags::Ignored, &amp;newFlags);</span>
<a href="#l47.45"></a><span id="l47.45">         }</span>
<a href="#l47.46"></a><span id="l47.46">         break;</span>
<a href="#l47.47"></a><span id="l47.47">       case nsMsgFilterAction::WatchThread:</span>
<a href="#l47.48"></a><span id="l47.48">         {</span>
<a href="#l47.49"></a><span id="l47.49">           PRUint32 newFlags;</span>
<a href="#l47.50"></a><span id="l47.50" class="difflineminus">-          m_newMsgHdr-&gt;OrFlags(MSG_FLAG_WATCHED, &amp;newFlags);</span>
<a href="#l47.51"></a><span id="l47.51" class="difflineplus">+          m_newMsgHdr-&gt;OrFlags(nsMsgMessageFlags::Watched, &amp;newFlags);</span>
<a href="#l47.52"></a><span id="l47.52">         }</span>
<a href="#l47.53"></a><span id="l47.53">         break;</span>
<a href="#l47.54"></a><span id="l47.54">       case nsMsgFilterAction::MarkFlagged:</span>
<a href="#l47.55"></a><span id="l47.55">         m_newMsgHdr-&gt;MarkFlagged(PR_TRUE);</span>
<a href="#l47.56"></a><span id="l47.56">         break;</span>
<a href="#l47.57"></a><span id="l47.57">       case nsMsgFilterAction::ChangePriority:</span>
<a href="#l47.58"></a><span id="l47.58">         {</span>
<a href="#l47.59"></a><span id="l47.59">           nsMsgPriorityValue filterPriority;</span>
<a href="#l47.60"></a><span id="l47.60" class="difflineat">@@ -1086,20 +1086,20 @@ nsNNTPNewsgroupList::AddHeader(const cha</span>
<a href="#l47.61"></a><span id="l47.61">     PRUint32 subjectLen = strlen(value);</span>
<a href="#l47.62"></a><span id="l47.62"> </span>
<a href="#l47.63"></a><span id="l47.63">     PRUint32 flags = 0;</span>
<a href="#l47.64"></a><span id="l47.64">     // ### should call IsHeaderRead here...</span>
<a href="#l47.65"></a><span id="l47.65">     /* strip &quot;Re: &quot; */</span>
<a href="#l47.66"></a><span id="l47.66">     nsCString modifiedSubject;</span>
<a href="#l47.67"></a><span id="l47.67">     if (NS_MsgStripRE(&amp;subject, &amp;subjectLen, getter_Copies(modifiedSubject)))</span>
<a href="#l47.68"></a><span id="l47.68">       // this will make sure read flags agree with newsrc</span>
<a href="#l47.69"></a><span id="l47.69" class="difflineminus">-     (void) m_newMsgHdr-&gt;OrFlags(MSG_FLAG_HAS_RE, &amp;flags);</span>
<a href="#l47.70"></a><span id="l47.70" class="difflineplus">+     (void) m_newMsgHdr-&gt;OrFlags(nsMsgMessageFlags::HasRe, &amp;flags);</span>
<a href="#l47.71"></a><span id="l47.71"> </span>
<a href="#l47.72"></a><span id="l47.72" class="difflineminus">-    if (! (flags &amp; MSG_FLAG_READ))</span>
<a href="#l47.73"></a><span id="l47.73" class="difflineminus">-      rv = m_newMsgHdr-&gt;OrFlags(MSG_FLAG_NEW, &amp;flags);</span>
<a href="#l47.74"></a><span id="l47.74" class="difflineplus">+    if (! (flags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l47.75"></a><span id="l47.75" class="difflineplus">+      rv = m_newMsgHdr-&gt;OrFlags(nsMsgMessageFlags::New, &amp;flags);</span>
<a href="#l47.76"></a><span id="l47.76"> </span>
<a href="#l47.77"></a><span id="l47.77">     rv = m_newMsgHdr-&gt;SetSubject(modifiedSubject.IsEmpty() ? subject :</span>
<a href="#l47.78"></a><span id="l47.78">       modifiedSubject.get());</span>
<a href="#l47.79"></a><span id="l47.79">   }</span>
<a href="#l47.80"></a><span id="l47.80">   else if (PL_strcmp(header, &quot;message-id&quot;) == 0)</span>
<a href="#l47.81"></a><span id="l47.81">   {</span>
<a href="#l47.82"></a><span id="l47.82">     rv = m_newMsgHdr-&gt;SetMessageId(value);</span>
<a href="#l47.83"></a><span id="l47.83">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l48.1"></a><span id="l48.1" class="difflineminus">--- a/mailnews/news/src/nsNewsDownloader.cpp</span>
<a href="#l48.2"></a><span id="l48.2" class="difflineplus">+++ b/mailnews/news/src/nsNewsDownloader.cpp</span>
<a href="#l48.3"></a><span id="l48.3" class="difflineat">@@ -162,17 +162,17 @@ PRBool DownloadNewsArticlesToOfflineStor</span>
<a href="#l48.4"></a><span id="l48.4">   while (NS_SUCCEEDED(rv = m_headerEnumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l48.5"></a><span id="l48.5">   {</span>
<a href="#l48.6"></a><span id="l48.6">     nsCOMPtr &lt;nsISupports&gt; supports;</span>
<a href="#l48.7"></a><span id="l48.7">     rv = m_headerEnumerator-&gt;GetNext(getter_AddRefs(supports));</span>
<a href="#l48.8"></a><span id="l48.8">     m_newsHeader = do_QueryInterface(supports);</span>
<a href="#l48.9"></a><span id="l48.9">     NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l48.10"></a><span id="l48.10">     PRUint32 hdrFlags;</span>
<a href="#l48.11"></a><span id="l48.11">     m_newsHeader-&gt;GetFlags(&amp;hdrFlags);</span>
<a href="#l48.12"></a><span id="l48.12" class="difflineminus">-    if (hdrFlags &amp; MSG_FLAG_MARKED)</span>
<a href="#l48.13"></a><span id="l48.13" class="difflineplus">+    if (hdrFlags &amp; nsMsgMessageFlags::Marked)</span>
<a href="#l48.14"></a><span id="l48.14">     {</span>
<a href="#l48.15"></a><span id="l48.15">       m_newsHeader-&gt;GetMessageKey(&amp;m_keyToDownload);</span>
<a href="#l48.16"></a><span id="l48.16">       break;</span>
<a href="#l48.17"></a><span id="l48.17">     }</span>
<a href="#l48.18"></a><span id="l48.18">     else</span>
<a href="#l48.19"></a><span id="l48.19">     {</span>
<a href="#l48.20"></a><span id="l48.20">       m_newsHeader = nsnull;</span>
<a href="#l48.21"></a><span id="l48.21">     }</span>
<a href="#l48.22"></a><span id="l48.22" class="difflineat">@@ -290,17 +290,17 @@ int DownloadNewsArticlesToOfflineStore::</span>
<a href="#l48.23"></a><span id="l48.23"> NS_IMETHODIMP nsNewsDownloader::OnSearchHit(nsIMsgDBHdr *header, nsIMsgFolder *folder)</span>
<a href="#l48.24"></a><span id="l48.24"> {</span>
<a href="#l48.25"></a><span id="l48.25">   NS_ENSURE_ARG(header);</span>
<a href="#l48.26"></a><span id="l48.26"> </span>
<a href="#l48.27"></a><span id="l48.27"> </span>
<a href="#l48.28"></a><span id="l48.28">   PRUint32 msgFlags;</span>
<a href="#l48.29"></a><span id="l48.29">   header-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l48.30"></a><span id="l48.30">   // only need to download articles we don't already have...</span>
<a href="#l48.31"></a><span id="l48.31" class="difflineminus">-  if (! (msgFlags &amp; MSG_FLAG_OFFLINE))</span>
<a href="#l48.32"></a><span id="l48.32" class="difflineplus">+  if (! (msgFlags &amp; nsMsgMessageFlags::Offline))</span>
<a href="#l48.33"></a><span id="l48.33">   {</span>
<a href="#l48.34"></a><span id="l48.34">     nsMsgKey key;</span>
<a href="#l48.35"></a><span id="l48.35">     header-&gt;GetMessageKey(&amp;key);</span>
<a href="#l48.36"></a><span id="l48.36">     m_keysToDownload.AppendElement(key);</span>
<a href="#l48.37"></a><span id="l48.37">   }</span>
<a href="#l48.38"></a><span id="l48.38">   return NS_OK;</span>
<a href="#l48.39"></a><span id="l48.39"> }</span>
<a href="#l48.40"></a><span id="l48.40"> </span>
<a href="#l48.41"></a><span id="l48.41" class="difflineat">@@ -583,24 +583,24 @@ nsresult nsMsgDownloadAllNewsgroups::Dow</span>
<a href="#l48.42"></a><span id="l48.42"> </span>
<a href="#l48.43"></a><span id="l48.43">   rv = searchSession-&gt;CreateTerm(getter_AddRefs(term));</span>
<a href="#l48.44"></a><span id="l48.44">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l48.45"></a><span id="l48.45">   term-&gt;GetValue(getter_AddRefs(value));</span>
<a href="#l48.46"></a><span id="l48.46"> </span>
<a href="#l48.47"></a><span id="l48.47">   if (downloadUnreadOnly)</span>
<a href="#l48.48"></a><span id="l48.48">   {</span>
<a href="#l48.49"></a><span id="l48.49">     value-&gt;SetAttrib(nsMsgSearchAttrib::MsgStatus);</span>
<a href="#l48.50"></a><span id="l48.50" class="difflineminus">-    value-&gt;SetStatus(MSG_FLAG_READ);</span>
<a href="#l48.51"></a><span id="l48.51" class="difflineplus">+    value-&gt;SetStatus(nsMsgMessageFlags::Read);</span>
<a href="#l48.52"></a><span id="l48.52">     searchSession-&gt;AddSearchTerm(nsMsgSearchAttrib::MsgStatus, nsMsgSearchOp::Isnt, value, PR_TRUE, nsnull);</span>
<a href="#l48.53"></a><span id="l48.53">   }</span>
<a href="#l48.54"></a><span id="l48.54">   if (downloadByDate)</span>
<a href="#l48.55"></a><span id="l48.55">   {</span>
<a href="#l48.56"></a><span id="l48.56">     value-&gt;SetAttrib(nsMsgSearchAttrib::AgeInDays);</span>
<a href="#l48.57"></a><span id="l48.57">     value-&gt;SetAge(ageLimitOfMsgsToDownload);</span>
<a href="#l48.58"></a><span id="l48.58">     searchSession-&gt;AddSearchTerm(nsMsgSearchAttrib::AgeInDays, nsMsgSearchOp::IsLessThan, value, nsMsgSearchBooleanOp::BooleanAND, nsnull);</span>
<a href="#l48.59"></a><span id="l48.59">   }</span>
<a href="#l48.60"></a><span id="l48.60">   value-&gt;SetAttrib(nsMsgSearchAttrib::MsgStatus);</span>
<a href="#l48.61"></a><span id="l48.61" class="difflineminus">-  value-&gt;SetStatus(MSG_FLAG_OFFLINE);</span>
<a href="#l48.62"></a><span id="l48.62" class="difflineplus">+  value-&gt;SetStatus(nsMsgMessageFlags::Offline);</span>
<a href="#l48.63"></a><span id="l48.63">   searchSession-&gt;AddSearchTerm(nsMsgSearchAttrib::MsgStatus, nsMsgSearchOp::Isnt, value, nsMsgSearchBooleanOp::BooleanAND, nsnull);</span>
<a href="#l48.64"></a><span id="l48.64"> </span>
<a href="#l48.65"></a><span id="l48.65">   m_downloaderForGroup-&gt;RunSearch(m_currentFolder, db, searchSession);</span>
<a href="#l48.66"></a><span id="l48.66">   return rv;</span>
<a href="#l48.67"></a><span id="l48.67"> }</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

