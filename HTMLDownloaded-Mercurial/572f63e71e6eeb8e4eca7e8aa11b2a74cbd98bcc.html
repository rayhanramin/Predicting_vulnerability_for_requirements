<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/4b0de666d1a4/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/4b0de666d1a4/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/4b0de666d1a4/mercurial.js"></script>

<meta property="og:image" content="/static/4b0de666d1a4/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 26475:572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc" />
<meta property="og:url" content="/comm-central/rev/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc" />
<meta property="og:description" content="Bug 1546364 - Reformat to Google coding style in mailnews/imap (part 1). rs=reformat" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/4b0de666d1a4/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc">shortlog</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc">files</a> |
changeset |
<a href="/comm-central/raw-rev/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc">raw</a>  | <a href="/comm-central/archive/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1546364">Bug 1546364</a> - Reformat to Google coding style in mailnews/imap (part 1). rs=reformat
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#74;&#111;&#114;&#103;&#32;&#75;&#32;&#60;&#106;&#111;&#114;&#103;&#107;&#64;&#106;&#111;&#114;&#103;&#107;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Sun, 28 Apr 2019 22:24:09 +0200</td></tr>

<tr>
 <td>changeset 26475</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc">572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc</a></td>
</tr>



<tr>
<td>parent 26474</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/ee166a9bb9e027f5e857c802bcf94a512f10c44f">ee166a9bb9e027f5e857c802bcf94a512f10c44f</a>
</td>
</tr>

<tr>
<td>child 26476</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/635dddf89443cb9c5a0691865d6499ccf687f36c">635dddf89443cb9c5a0691865d6499ccf687f36c</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc">15847</a></td></tr>
<tr><td>push user</td><td>mozilla@jorgk.com</td></tr>
<tr><td>push date</td><td class="date age">Sun, 28 Apr 2019 20:37:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@635dddf89443 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=635dddf89443cb9c5a0691865d6499ccf687f36c">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=635dddf89443cb9c5a0691865d6499ccf687f36c&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=635dddf89443cb9c5a0691865d6499ccf687f36c&newProject=comm-central&newRevision=ee166a9bb9e027f5e857c802bcf94a512f10c44f&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=635dddf89443cb9c5a0691865d6499ccf687f36c&newProject=comm-central&newRevision=ee166a9bb9e027f5e857c802bcf94a512f10c44f&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=635dddf89443cb9c5a0691865d6499ccf687f36c&newProject=comm-central&newRevision=ee166a9bb9e027f5e857c802bcf94a512f10c44f&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28reformat%29&revcount=50">reformat</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1546364">1546364</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1546364">Bug 1546364</a> - Reformat to Google coding style in mailnews/imap (part 1). rs=reformat
# ignore-this-changeset</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/public/nsIIMAPHostSessionList.h">mailnews/imap/public/nsIIMAPHostSessionList.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/public/nsIIMAPHostSessionList.h">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/public/nsIIMAPHostSessionList.h">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/public/nsIIMAPHostSessionList.h">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/public/nsIIMAPHostSessionList.h">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/public/nsIIMAPHostSessionList.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/public/nsMsgImapCID.h">mailnews/imap/public/nsMsgImapCID.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/public/nsMsgImapCID.h">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/public/nsMsgImapCID.h">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/public/nsMsgImapCID.h">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/public/nsMsgImapCID.h">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/public/nsMsgImapCID.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncManager.cpp">mailnews/imap/src/nsAutoSyncManager.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncManager.cpp">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncManager.cpp">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncManager.cpp">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncManager.cpp">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncManager.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncManager.h">mailnews/imap/src/nsAutoSyncManager.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncManager.h">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncManager.h">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncManager.h">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncManager.h">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncManager.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncState.cpp">mailnews/imap/src/nsAutoSyncState.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncState.cpp">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncState.cpp">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncState.cpp">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncState.cpp">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncState.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncState.h">mailnews/imap/src/nsAutoSyncState.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncState.h">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncState.h">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncState.h">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncState.h">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsAutoSyncState.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPBodyShell.cpp">mailnews/imap/src/nsIMAPBodyShell.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPBodyShell.cpp">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPBodyShell.cpp">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPBodyShell.cpp">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPBodyShell.cpp">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPBodyShell.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPBodyShell.h">mailnews/imap/src/nsIMAPBodyShell.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPBodyShell.h">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPBodyShell.h">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPBodyShell.h">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPBodyShell.h">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPBodyShell.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPGenericParser.cpp">mailnews/imap/src/nsIMAPGenericParser.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPGenericParser.cpp">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPGenericParser.cpp">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPGenericParser.cpp">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPGenericParser.cpp">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPGenericParser.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPGenericParser.h">mailnews/imap/src/nsIMAPGenericParser.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPGenericParser.h">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPGenericParser.h">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPGenericParser.h">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPGenericParser.h">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPGenericParser.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPHostSessionList.cpp">mailnews/imap/src/nsIMAPHostSessionList.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPHostSessionList.cpp">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPHostSessionList.cpp">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPHostSessionList.cpp">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPHostSessionList.cpp">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPHostSessionList.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPHostSessionList.h">mailnews/imap/src/nsIMAPHostSessionList.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPHostSessionList.h">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPHostSessionList.h">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPHostSessionList.h">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPHostSessionList.h">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPHostSessionList.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPNamespace.cpp">mailnews/imap/src/nsIMAPNamespace.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPNamespace.cpp">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPNamespace.cpp">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPNamespace.cpp">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPNamespace.cpp">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPNamespace.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPNamespace.h">mailnews/imap/src/nsIMAPNamespace.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPNamespace.h">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPNamespace.h">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPNamespace.h">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPNamespace.h">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsIMAPNamespace.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapCore.h">mailnews/imap/src/nsImapCore.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapCore.h">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapCore.h">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapCore.h">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapCore.h">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapCore.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapFlagAndUidState.cpp">mailnews/imap/src/nsImapFlagAndUidState.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapFlagAndUidState.cpp">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapFlagAndUidState.cpp">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapFlagAndUidState.cpp">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapFlagAndUidState.cpp">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapFlagAndUidState.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapFlagAndUidState.h">mailnews/imap/src/nsImapFlagAndUidState.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapFlagAndUidState.h">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapFlagAndUidState.h">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapFlagAndUidState.h">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapFlagAndUidState.h">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapFlagAndUidState.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapIncomingServer.cpp">mailnews/imap/src/nsImapIncomingServer.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapIncomingServer.cpp">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapIncomingServer.cpp">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapIncomingServer.cpp">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapIncomingServer.cpp">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapIncomingServer.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapIncomingServer.h">mailnews/imap/src/nsImapIncomingServer.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapIncomingServer.h">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapIncomingServer.h">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapIncomingServer.h">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapIncomingServer.h">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapIncomingServer.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapMailFolder.cpp">mailnews/imap/src/nsImapMailFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapMailFolder.cpp">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapMailFolder.cpp">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapMailFolder.cpp">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapMailFolder.cpp">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapMailFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapMailFolder.h">mailnews/imap/src/nsImapMailFolder.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapMailFolder.h">file</a> |
<a href="/comm-central/annotate/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapMailFolder.h">annotate</a> |
<a href="/comm-central/diff/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapMailFolder.h">diff</a> |
<a href="/comm-central/comparison/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapMailFolder.h">comparison</a> |
<a href="/comm-central/log/572f63e71e6eeb8e4eca7e8aa11b2a74cbd98bcc/mailnews/imap/src/nsImapMailFolder.h">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/imap/public/nsIIMAPHostSessionList.h</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/imap/public/nsIIMAPHostSessionList.h</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -9,92 +9,127 @@</span>
<a href="#l1.4"></a><span id="l1.4"> #include &quot;nsISupports.h&quot;</span>
<a href="#l1.5"></a><span id="l1.5"> #include &quot;nsImapCore.h&quot;</span>
<a href="#l1.6"></a><span id="l1.6"> #include &quot;nsIMAPNamespace.h&quot;</span>
<a href="#l1.7"></a><span id="l1.7"> </span>
<a href="#l1.8"></a><span id="l1.8"> class nsIMAPBodyShell;</span>
<a href="#l1.9"></a><span id="l1.9"> class nsIImapIncomingServer;</span>
<a href="#l1.10"></a><span id="l1.10"> </span>
<a href="#l1.11"></a><span id="l1.11"> // f4d89e3e-77da-492c-962b-7835f0742c22</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-#define NS_IIMAPHOSTSESSIONLIST_IID \</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineminus">-{ 0xf4d89e3e, 0x77da, 0x492c, {0x96, 0x2b, 0x78, 0x35, 0xf0, 0x74, 0x2c, 0x22 } }</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+#define NS_IIMAPHOSTSESSIONLIST_IID                  \</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+  {                                                  \</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+    0xf4d89e3e, 0x77da, 0x492c, {                    \</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+      0x96, 0x2b, 0x78, 0x35, 0xf0, 0x74, 0x2c, 0x22 \</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineplus">+    }                                                \</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+  }</span>
<a href="#l1.20"></a><span id="l1.20"> </span>
<a href="#l1.21"></a><span id="l1.21"> // this is an interface to a linked list of host info's</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineminus">-class nsIImapHostSessionList : public nsISupports</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineminus">-{</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineminus">-public:</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineplus">+class nsIImapHostSessionList : public nsISupports {</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineplus">+ public:</span>
<a href="#l1.27"></a><span id="l1.27">   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IIMAPHOSTSESSIONLIST_IID)</span>
<a href="#l1.28"></a><span id="l1.28"> </span>
<a href="#l1.29"></a><span id="l1.29">   // Host List</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineminus">-  NS_IMETHOD  AddHostToList(const char *serverKey, nsIImapIncomingServer *server) = 0;</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineplus">+  NS_IMETHOD AddHostToList(const char *serverKey,</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+                           nsIImapIncomingServer *server) = 0;</span>
<a href="#l1.33"></a><span id="l1.33">   NS_IMETHOD ResetAll() = 0;</span>
<a href="#l1.34"></a><span id="l1.34"> </span>
<a href="#l1.35"></a><span id="l1.35">   // Capabilities</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineminus">-  NS_IMETHOD  GetHostHasAdminURL(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineminus">-  NS_IMETHOD  SetHostHasAdminURL(const char *serverKey, bool hasAdminUrl) = 0;</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineplus">+  NS_IMETHOD GetHostHasAdminURL(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineplus">+  NS_IMETHOD SetHostHasAdminURL(const char *serverKey, bool hasAdminUrl) = 0;</span>
<a href="#l1.40"></a><span id="l1.40">   // Subscription</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineminus">-  NS_IMETHOD  GetHostIsUsingSubscription(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineminus">-  NS_IMETHOD  SetHostIsUsingSubscription(const char *serverKey, bool usingSubscription) = 0;</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+  NS_IMETHOD GetHostIsUsingSubscription(const char *serverKey,</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+                                        bool &amp;result) = 0;</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+  NS_IMETHOD SetHostIsUsingSubscription(const char *serverKey,</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineplus">+                                        bool usingSubscription) = 0;</span>
<a href="#l1.47"></a><span id="l1.47"> </span>
<a href="#l1.48"></a><span id="l1.48">   // Passwords</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineminus">-  NS_IMETHOD  GetPasswordForHost(const char *serverKey, nsString &amp;result) = 0;</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineminus">-  NS_IMETHOD  SetPasswordForHost(const char *serverKey, const nsAString &amp;password) = 0;</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineminus">-  NS_IMETHOD  GetPasswordVerifiedOnline(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineminus">-  NS_IMETHOD  SetPasswordVerifiedOnline(const char *serverKey) = 0;</span>
<a href="#l1.53"></a><span id="l1.53" class="difflineplus">+  NS_IMETHOD GetPasswordForHost(const char *serverKey, nsString &amp;result) = 0;</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineplus">+  NS_IMETHOD SetPasswordForHost(const char *serverKey,</span>
<a href="#l1.55"></a><span id="l1.55" class="difflineplus">+                                const nsAString &amp;password) = 0;</span>
<a href="#l1.56"></a><span id="l1.56" class="difflineplus">+  NS_IMETHOD GetPasswordVerifiedOnline(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.57"></a><span id="l1.57" class="difflineplus">+  NS_IMETHOD SetPasswordVerifiedOnline(const char *serverKey) = 0;</span>
<a href="#l1.58"></a><span id="l1.58"> </span>
<a href="#l1.59"></a><span id="l1.59">   // OnlineDir</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineminus">-  NS_IMETHOD GetOnlineDirForHost(const char *serverKey,</span>
<a href="#l1.61"></a><span id="l1.61" class="difflineminus">-                                 nsString &amp;result) = 0;</span>
<a href="#l1.62"></a><span id="l1.62" class="difflineplus">+  NS_IMETHOD GetOnlineDirForHost(const char *serverKey, nsString &amp;result) = 0;</span>
<a href="#l1.63"></a><span id="l1.63">   NS_IMETHOD SetOnlineDirForHost(const char *serverKey,</span>
<a href="#l1.64"></a><span id="l1.64">                                  const char *onlineDir) = 0;</span>
<a href="#l1.65"></a><span id="l1.65"> </span>
<a href="#l1.66"></a><span id="l1.66">   // Delete is move to trash folder</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineminus">-  NS_IMETHOD GetDeleteIsMoveToTrashForHost(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineminus">-  NS_IMETHOD SetDeleteIsMoveToTrashForHost(const char *serverKey, bool isMoveToTrash) = 0;</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineminus">-  NS_IMETHOD GetShowDeletedMessagesForHost(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.70"></a><span id="l1.70" class="difflineplus">+  NS_IMETHOD GetDeleteIsMoveToTrashForHost(const char *serverKey,</span>
<a href="#l1.71"></a><span id="l1.71" class="difflineplus">+                                           bool &amp;result) = 0;</span>
<a href="#l1.72"></a><span id="l1.72" class="difflineplus">+  NS_IMETHOD SetDeleteIsMoveToTrashForHost(const char *serverKey,</span>
<a href="#l1.73"></a><span id="l1.73" class="difflineplus">+                                           bool isMoveToTrash) = 0;</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineplus">+  NS_IMETHOD GetShowDeletedMessagesForHost(const char *serverKey,</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineplus">+                                           bool &amp;result) = 0;</span>
<a href="#l1.76"></a><span id="l1.76"> </span>
<a href="#l1.77"></a><span id="l1.77" class="difflineminus">-  NS_IMETHOD SetShowDeletedMessagesForHost(const char *serverKey, bool showDeletedMessages) = 0;</span>
<a href="#l1.78"></a><span id="l1.78" class="difflineplus">+  NS_IMETHOD SetShowDeletedMessagesForHost(const char *serverKey,</span>
<a href="#l1.79"></a><span id="l1.79" class="difflineplus">+                                           bool showDeletedMessages) = 0;</span>
<a href="#l1.80"></a><span id="l1.80"> </span>
<a href="#l1.81"></a><span id="l1.81">   // Get namespaces</span>
<a href="#l1.82"></a><span id="l1.82">   NS_IMETHOD GetGotNamespacesForHost(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.83"></a><span id="l1.83" class="difflineminus">-  NS_IMETHOD SetGotNamespacesForHost(const char *serverKey, bool gotNamespaces) = 0;</span>
<a href="#l1.84"></a><span id="l1.84" class="difflineplus">+  NS_IMETHOD SetGotNamespacesForHost(const char *serverKey,</span>
<a href="#l1.85"></a><span id="l1.85" class="difflineplus">+                                     bool gotNamespaces) = 0;</span>
<a href="#l1.86"></a><span id="l1.86"> </span>
<a href="#l1.87"></a><span id="l1.87">   // Folders</span>
<a href="#l1.88"></a><span id="l1.88" class="difflineminus">-  NS_IMETHOD SetHaveWeEverDiscoveredFoldersForHost(const char *serverKey, bool discovered) = 0;</span>
<a href="#l1.89"></a><span id="l1.89" class="difflineminus">-  NS_IMETHOD GetHaveWeEverDiscoveredFoldersForHost(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.90"></a><span id="l1.90" class="difflineplus">+  NS_IMETHOD SetHaveWeEverDiscoveredFoldersForHost(const char *serverKey,</span>
<a href="#l1.91"></a><span id="l1.91" class="difflineplus">+                                                   bool discovered) = 0;</span>
<a href="#l1.92"></a><span id="l1.92" class="difflineplus">+  NS_IMETHOD GetHaveWeEverDiscoveredFoldersForHost(const char *serverKey,</span>
<a href="#l1.93"></a><span id="l1.93" class="difflineplus">+                                                   bool &amp;result) = 0;</span>
<a href="#l1.94"></a><span id="l1.94"> </span>
<a href="#l1.95"></a><span id="l1.95">   // Trash Folder</span>
<a href="#l1.96"></a><span id="l1.96" class="difflineminus">-  NS_IMETHOD SetOnlineTrashFolderExistsForHost(const char *serverKey, bool exists) = 0;</span>
<a href="#l1.97"></a><span id="l1.97" class="difflineminus">-  NS_IMETHOD GetOnlineTrashFolderExistsForHost(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.98"></a><span id="l1.98" class="difflineplus">+  NS_IMETHOD SetOnlineTrashFolderExistsForHost(const char *serverKey,</span>
<a href="#l1.99"></a><span id="l1.99" class="difflineplus">+                                               bool exists) = 0;</span>
<a href="#l1.100"></a><span id="l1.100" class="difflineplus">+  NS_IMETHOD GetOnlineTrashFolderExistsForHost(const char *serverKey,</span>
<a href="#l1.101"></a><span id="l1.101" class="difflineplus">+                                               bool &amp;result) = 0;</span>
<a href="#l1.102"></a><span id="l1.102"> </span>
<a href="#l1.103"></a><span id="l1.103">   // INBOX</span>
<a href="#l1.104"></a><span id="l1.104" class="difflineminus">-  NS_IMETHOD  GetOnlineInboxPathForHost(const char *serverKey, nsString &amp;result) = 0;</span>
<a href="#l1.105"></a><span id="l1.105" class="difflineminus">-  NS_IMETHOD  GetShouldAlwaysListInboxForHost(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.106"></a><span id="l1.106" class="difflineminus">-  NS_IMETHOD  SetShouldAlwaysListInboxForHost(const char *serverKey, bool shouldList) = 0;</span>
<a href="#l1.107"></a><span id="l1.107" class="difflineplus">+  NS_IMETHOD GetOnlineInboxPathForHost(const char *serverKey,</span>
<a href="#l1.108"></a><span id="l1.108" class="difflineplus">+                                       nsString &amp;result) = 0;</span>
<a href="#l1.109"></a><span id="l1.109" class="difflineplus">+  NS_IMETHOD GetShouldAlwaysListInboxForHost(const char *serverKey,</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineplus">+                                             bool &amp;result) = 0;</span>
<a href="#l1.111"></a><span id="l1.111" class="difflineplus">+  NS_IMETHOD SetShouldAlwaysListInboxForHost(const char *serverKey,</span>
<a href="#l1.112"></a><span id="l1.112" class="difflineplus">+                                             bool shouldList) = 0;</span>
<a href="#l1.113"></a><span id="l1.113"> </span>
<a href="#l1.114"></a><span id="l1.114">   // Namespaces</span>
<a href="#l1.115"></a><span id="l1.115" class="difflineminus">-  NS_IMETHOD  GetNamespaceForMailboxForHost(const char *serverKey, const char *mailbox_name, nsIMAPNamespace * &amp; result) = 0;</span>
<a href="#l1.116"></a><span id="l1.116" class="difflineminus">-  NS_IMETHOD  SetNamespaceFromPrefForHost(const char *serverKey, const char *namespacePref, EIMAPNamespaceType type) = 0;</span>
<a href="#l1.117"></a><span id="l1.117" class="difflineminus">-  NS_IMETHOD  AddNewNamespaceForHost(const char *serverKey, nsIMAPNamespace *ns) = 0;</span>
<a href="#l1.118"></a><span id="l1.118" class="difflineminus">-  NS_IMETHOD  ClearServerAdvertisedNamespacesForHost(const char *serverKey) = 0;</span>
<a href="#l1.119"></a><span id="l1.119" class="difflineminus">-  NS_IMETHOD  ClearPrefsNamespacesForHost(const char *serverKey) = 0;</span>
<a href="#l1.120"></a><span id="l1.120" class="difflineminus">-  NS_IMETHOD  GetDefaultNamespaceOfTypeForHost(const char *serverKey, EIMAPNamespaceType type, nsIMAPNamespace * &amp; result) = 0;</span>
<a href="#l1.121"></a><span id="l1.121" class="difflineminus">-  NS_IMETHOD  SetNamespacesOverridableForHost(const char *serverKey, bool overridable) = 0;</span>
<a href="#l1.122"></a><span id="l1.122" class="difflineminus">-  NS_IMETHOD  GetNamespacesOverridableForHost(const char *serverKey,bool &amp;result) = 0;</span>
<a href="#l1.123"></a><span id="l1.123" class="difflineminus">-  NS_IMETHOD  GetNumberOfNamespacesForHost(const char *serverKey, uint32_t &amp;result) = 0;</span>
<a href="#l1.124"></a><span id="l1.124" class="difflineminus">-  NS_IMETHOD  GetNamespaceNumberForHost(const char *serverKey, int32_t n, nsIMAPNamespace * &amp;result) = 0;</span>
<a href="#l1.125"></a><span id="l1.125" class="difflineplus">+  NS_IMETHOD GetNamespaceForMailboxForHost(const char *serverKey,</span>
<a href="#l1.126"></a><span id="l1.126" class="difflineplus">+                                           const char *mailbox_name,</span>
<a href="#l1.127"></a><span id="l1.127" class="difflineplus">+                                           nsIMAPNamespace *&amp;result) = 0;</span>
<a href="#l1.128"></a><span id="l1.128" class="difflineplus">+  NS_IMETHOD SetNamespaceFromPrefForHost(const char *serverKey,</span>
<a href="#l1.129"></a><span id="l1.129" class="difflineplus">+                                         const char *namespacePref,</span>
<a href="#l1.130"></a><span id="l1.130" class="difflineplus">+                                         EIMAPNamespaceType type) = 0;</span>
<a href="#l1.131"></a><span id="l1.131" class="difflineplus">+  NS_IMETHOD AddNewNamespaceForHost(const char *serverKey,</span>
<a href="#l1.132"></a><span id="l1.132" class="difflineplus">+                                    nsIMAPNamespace *ns) = 0;</span>
<a href="#l1.133"></a><span id="l1.133" class="difflineplus">+  NS_IMETHOD ClearServerAdvertisedNamespacesForHost(const char *serverKey) = 0;</span>
<a href="#l1.134"></a><span id="l1.134" class="difflineplus">+  NS_IMETHOD ClearPrefsNamespacesForHost(const char *serverKey) = 0;</span>
<a href="#l1.135"></a><span id="l1.135" class="difflineplus">+  NS_IMETHOD GetDefaultNamespaceOfTypeForHost(const char *serverKey,</span>
<a href="#l1.136"></a><span id="l1.136" class="difflineplus">+                                              EIMAPNamespaceType type,</span>
<a href="#l1.137"></a><span id="l1.137" class="difflineplus">+                                              nsIMAPNamespace *&amp;result) = 0;</span>
<a href="#l1.138"></a><span id="l1.138" class="difflineplus">+  NS_IMETHOD SetNamespacesOverridableForHost(const char *serverKey,</span>
<a href="#l1.139"></a><span id="l1.139" class="difflineplus">+                                             bool overridable) = 0;</span>
<a href="#l1.140"></a><span id="l1.140" class="difflineplus">+  NS_IMETHOD GetNamespacesOverridableForHost(const char *serverKey,</span>
<a href="#l1.141"></a><span id="l1.141" class="difflineplus">+                                             bool &amp;result) = 0;</span>
<a href="#l1.142"></a><span id="l1.142" class="difflineplus">+  NS_IMETHOD GetNumberOfNamespacesForHost(const char *serverKey,</span>
<a href="#l1.143"></a><span id="l1.143" class="difflineplus">+                                          uint32_t &amp;result) = 0;</span>
<a href="#l1.144"></a><span id="l1.144" class="difflineplus">+  NS_IMETHOD GetNamespaceNumberForHost(const char *serverKey, int32_t n,</span>
<a href="#l1.145"></a><span id="l1.145" class="difflineplus">+                                       nsIMAPNamespace *&amp;result) = 0;</span>
<a href="#l1.146"></a><span id="l1.146">   // ### dmb hoo boy, how are we going to do this?</span>
<a href="#l1.147"></a><span id="l1.147" class="difflineminus">-  NS_IMETHOD  CommitNamespacesForHost(nsIImapIncomingServer *server) = 0;</span>
<a href="#l1.148"></a><span id="l1.148" class="difflineminus">-  NS_IMETHOD  FlushUncommittedNamespacesForHost(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.149"></a><span id="l1.149" class="difflineplus">+  NS_IMETHOD CommitNamespacesForHost(nsIImapIncomingServer *server) = 0;</span>
<a href="#l1.150"></a><span id="l1.150" class="difflineplus">+  NS_IMETHOD FlushUncommittedNamespacesForHost(const char *serverKey,</span>
<a href="#l1.151"></a><span id="l1.151" class="difflineplus">+                                               bool &amp;result) = 0;</span>
<a href="#l1.152"></a><span id="l1.152"> </span>
<a href="#l1.153"></a><span id="l1.153">   // Hierarchy Delimiters</span>
<a href="#l1.154"></a><span id="l1.154" class="difflineminus">-  NS_IMETHOD  SetNamespaceHierarchyDelimiterFromMailboxForHost(const char *serverKey, const char *boxName, char delimiter) = 0;</span>
<a href="#l1.155"></a><span id="l1.155" class="difflineplus">+  NS_IMETHOD SetNamespaceHierarchyDelimiterFromMailboxForHost(</span>
<a href="#l1.156"></a><span id="l1.156" class="difflineplus">+      const char *serverKey, const char *boxName, char delimiter) = 0;</span>
<a href="#l1.157"></a><span id="l1.157"> </span>
<a href="#l1.158"></a><span id="l1.158">   // Message Body Shells</span>
<a href="#l1.159"></a><span id="l1.159" class="difflineminus">-  NS_IMETHOD  AddShellToCacheForHost(const char *serverKey, nsIMAPBodyShell *shell) = 0;</span>
<a href="#l1.160"></a><span id="l1.160" class="difflineminus">-  NS_IMETHOD  FindShellInCacheForHost(const char *serverKey, const char *mailboxName, const char *UID, IMAP_ContentModifiedType modType, nsIMAPBodyShell **result) = 0;</span>
<a href="#l1.161"></a><span id="l1.161" class="difflineminus">-  NS_IMETHOD  ClearShellCacheForHost(const char *serverKey) = 0;</span>
<a href="#l1.162"></a><span id="l1.162" class="difflineplus">+  NS_IMETHOD AddShellToCacheForHost(const char *serverKey,</span>
<a href="#l1.163"></a><span id="l1.163" class="difflineplus">+                                    nsIMAPBodyShell *shell) = 0;</span>
<a href="#l1.164"></a><span id="l1.164" class="difflineplus">+  NS_IMETHOD FindShellInCacheForHost(const char *serverKey,</span>
<a href="#l1.165"></a><span id="l1.165" class="difflineplus">+                                     const char *mailboxName, const char *UID,</span>
<a href="#l1.166"></a><span id="l1.166" class="difflineplus">+                                     IMAP_ContentModifiedType modType,</span>
<a href="#l1.167"></a><span id="l1.167" class="difflineplus">+                                     nsIMAPBodyShell **result) = 0;</span>
<a href="#l1.168"></a><span id="l1.168" class="difflineplus">+  NS_IMETHOD ClearShellCacheForHost(const char *serverKey) = 0;</span>
<a href="#l1.169"></a><span id="l1.169"> };</span>
<a href="#l1.170"></a><span id="l1.170"> </span>
<a href="#l1.171"></a><span id="l1.171"> NS_DEFINE_STATIC_IID_ACCESSOR(nsIImapHostSessionList,</span>
<a href="#l1.172"></a><span id="l1.172">                               NS_IIMAPHOSTSESSIONLIST_IID)</span>
<a href="#l1.173"></a><span id="l1.173"> </span>
<a href="#l1.174"></a><span id="l1.174"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/imap/public/nsMsgImapCID.h</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/imap/public/nsMsgImapCID.h</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -3,46 +3,66 @@</span>
<a href="#l2.4"></a><span id="l2.4">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l2.5"></a><span id="l2.5">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l2.6"></a><span id="l2.6"> </span>
<a href="#l2.7"></a><span id="l2.7"> #ifndef nsMsgImapCID_h__</span>
<a href="#l2.8"></a><span id="l2.8"> #define nsMsgImapCID_h__</span>
<a href="#l2.9"></a><span id="l2.9"> </span>
<a href="#l2.10"></a><span id="l2.10"> #include &quot;nsMsgBaseCID.h&quot;</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-#define NS_IMAPURL_CID        \</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineminus">-{ 0x21a89611, 0xdc0d, 0x11d2, \</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineminus">-{ 0x80, 0x6c, 0x0, 0x60, 0x8, 0x12, 0x8c, 0x4e }}</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+#define NS_IMAPURL_CID                             \</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+  {                                                \</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+    0x21a89611, 0xdc0d, 0x11d2, {                  \</span>
<a href="#l2.18"></a><span id="l2.18" class="difflineplus">+      0x80, 0x6c, 0x0, 0x60, 0x8, 0x12, 0x8c, 0x4e \</span>
<a href="#l2.19"></a><span id="l2.19" class="difflineplus">+    }                                              \</span>
<a href="#l2.20"></a><span id="l2.20" class="difflineplus">+  }</span>
<a href="#l2.21"></a><span id="l2.21"> </span>
<a href="#l2.22"></a><span id="l2.22"> #define NS_IMAPPROTOCOLINFO_CONTRACTID \</span>
<a href="#l2.23"></a><span id="l2.23">   NS_MSGPROTOCOLINFO_CONTRACTID_PREFIX &quot;imap&quot;</span>
<a href="#l2.24"></a><span id="l2.24"> </span>
<a href="#l2.25"></a><span id="l2.25" class="difflineminus">-#define NS_IMAPINCOMINGSERVER_CONTRACTID  \</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineplus">+#define NS_IMAPINCOMINGSERVER_CONTRACTID \</span>
<a href="#l2.27"></a><span id="l2.27">   NS_MSGINCOMINGSERVER_CONTRACTID_PREFIX &quot;imap&quot;</span>
<a href="#l2.28"></a><span id="l2.28"> </span>
<a href="#l2.29"></a><span id="l2.29" class="difflineminus">-#define NS_IMAPSERVICE_CONTRACTID \</span>
<a href="#l2.30"></a><span id="l2.30" class="difflineminus">-  &quot;@mozilla.org/messenger/imapservice;1&quot;</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+#define NS_IMAPSERVICE_CONTRACTID &quot;@mozilla.org/messenger/imapservice;1&quot;</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineplus">+#define NS_IMAPSERVICE_CID                         \</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+  {                                                \</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+    0xc5852b22, 0xebe2, 0x11d2, {                  \</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+      0x95, 0xad, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74 \</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+    }                                              \</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+  }</span>
<a href="#l2.39"></a><span id="l2.39"> </span>
<a href="#l2.40"></a><span id="l2.40" class="difflineminus">-#define NS_IMAPSERVICE_CID    \</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineminus">-{ 0xc5852b22, 0xebe2, 0x11d2, \</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineminus">-{ 0x95, 0xad, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74 }}</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineplus">+#define NS_IMAPPROTOCOL_CID                        \</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineplus">+  {                                                \</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineplus">+    0x8c0c40d1, 0xe173, 0x11d2, {                  \</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+      0x80, 0x6e, 0x0, 0x60, 0x8, 0x12, 0x8c, 0x4e \</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineplus">+    }                                              \</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineplus">+  }</span>
<a href="#l2.49"></a><span id="l2.49"> </span>
<a href="#l2.50"></a><span id="l2.50" class="difflineminus">-#define NS_IMAPPROTOCOL_CID   \</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineminus">-{ 0x8c0c40d1, 0xe173, 0x11d2, \</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineminus">-{ 0x80, 0x6e, 0x0, 0x60, 0x8, 0x12, 0x8c, 0x4e }}</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineplus">+#define NS_IIMAPHOSTSESSIONLIST_CID                  \</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineplus">+  {                                                  \</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+    0x479ce8fc, 0xe725, 0x11d2, {                    \</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+      0xa5, 0x05, 0x00, 0x60, 0xb0, 0xfc, 0x04, 0xb7 \</span>
<a href="#l2.57"></a><span id="l2.57" class="difflineplus">+    }                                                \</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineplus">+  }</span>
<a href="#l2.59"></a><span id="l2.59"> </span>
<a href="#l2.60"></a><span id="l2.60" class="difflineminus">-#define NS_IIMAPHOSTSESSIONLIST_CID \</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineminus">-{ 0x479ce8fc, 0xe725, 0x11d2,       \</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineminus">-{ 0xa5, 0x05, 0x00, 0x60, 0xb0, 0xfc, 0x04, 0xb7 }}</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineminus">-</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineminus">-#define NS_IMAPINCOMINGSERVER_CID \</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineminus">-{ 0x8d3675e0, 0xed46, 0x11d2,     \</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineminus">-{ 0x80, 0x77, 0x0, 0x60, 0x8, 0x12, 0x8c, 0x4e}}</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineplus">+#define NS_IMAPINCOMINGSERVER_CID                  \</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineplus">+  {                                                \</span>
<a href="#l2.69"></a><span id="l2.69" class="difflineplus">+    0x8d3675e0, 0xed46, 0x11d2, {                  \</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineplus">+      0x80, 0x77, 0x0, 0x60, 0x8, 0x12, 0x8c, 0x4e \</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+    }                                              \</span>
<a href="#l2.72"></a><span id="l2.72" class="difflineplus">+  }</span>
<a href="#l2.73"></a><span id="l2.73"> </span>
<a href="#l2.74"></a><span id="l2.74" class="difflineminus">-#define NS_IMAPRESOURCE_CID   \</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineminus">-{ 0xfa32d000, 0xf6a0, 0x11d2, \</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineminus">-{ 0xaf, 0x8d, 0x00, 0x10, 0x83, 0x00, 0x2d, 0xa8 }}</span>
<a href="#l2.77"></a><span id="l2.77" class="difflineplus">+#define NS_IMAPRESOURCE_CID                          \</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineplus">+  {                                                  \</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineplus">+    0xfa32d000, 0xf6a0, 0x11d2, {                    \</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineplus">+      0xaf, 0x8d, 0x00, 0x10, 0x83, 0x00, 0x2d, 0xa8 \</span>
<a href="#l2.81"></a><span id="l2.81" class="difflineplus">+    }                                                \</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineplus">+  }</span>
<a href="#l2.83"></a><span id="l2.83"> </span>
<a href="#l2.84"></a><span id="l2.84" class="difflineminus">-#define NS_IMAPMOCKCHANNEL_CID \</span>
<a href="#l2.85"></a><span id="l2.85" class="difflineminus">-{ 0x4eca51df, 0x6734, 0x11d3,  \</span>
<a href="#l2.86"></a><span id="l2.86" class="difflineminus">-{ 0x98, 0x9a, 0x0, 0x10, 0x83, 0x1, 0xe, 0x9b}}</span>
<a href="#l2.87"></a><span id="l2.87" class="difflineplus">+#define NS_IMAPMOCKCHANNEL_CID                    \</span>
<a href="#l2.88"></a><span id="l2.88" class="difflineplus">+  {                                               \</span>
<a href="#l2.89"></a><span id="l2.89" class="difflineplus">+    0x4eca51df, 0x6734, 0x11d3, {                 \</span>
<a href="#l2.90"></a><span id="l2.90" class="difflineplus">+      0x98, 0x9a, 0x0, 0x10, 0x83, 0x1, 0xe, 0x9b \</span>
<a href="#l2.91"></a><span id="l2.91" class="difflineplus">+    }                                             \</span>
<a href="#l2.92"></a><span id="l2.92" class="difflineplus">+  }</span>
<a href="#l2.93"></a><span id="l2.93"> </span>
<a href="#l2.94"></a><span id="l2.94" class="difflineminus">-#endif // nsMsgImapCID_h__</span>
<a href="#l2.95"></a><span id="l2.95" class="difflineplus">+#endif  // nsMsgImapCID_h__</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/imap/src/nsAutoSyncManager.cpp</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/imap/src/nsAutoSyncManager.cpp</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -22,455 +22,404 @@</span>
<a href="#l3.4"></a><span id="l3.4"> #include &quot;nsIMutableArray.h&quot;</span>
<a href="#l3.5"></a><span id="l3.5"> #include &quot;nsArrayUtils.h&quot;</span>
<a href="#l3.6"></a><span id="l3.6"> #include &quot;mozilla/Logging.h&quot;</span>
<a href="#l3.7"></a><span id="l3.7"> </span>
<a href="#l3.8"></a><span id="l3.8"> using namespace mozilla;</span>
<a href="#l3.9"></a><span id="l3.9"> </span>
<a href="#l3.10"></a><span id="l3.10"> NS_IMPL_ISUPPORTS(nsDefaultAutoSyncMsgStrategy, nsIAutoSyncMsgStrategy)</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-const char* kAppIdleNotification = &quot;mail:appIdle&quot;;</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">-const char* kStartupDoneNotification = &quot;mail-startup-done&quot;;</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+const char *kAppIdleNotification = &quot;mail:appIdle&quot;;</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+const char *kStartupDoneNotification = &quot;mail-startup-done&quot;;</span>
<a href="#l3.16"></a><span id="l3.16"> LazyLogModule gAutoSyncLog(&quot;IMAPAutoSync&quot;);</span>
<a href="#l3.17"></a><span id="l3.17"> </span>
<a href="#l3.18"></a><span id="l3.18"> // recommended size of each group of messages per download</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineminus">-static const uint32_t kDefaultGroupSize = 50U*1024U /* 50K */;</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+static const uint32_t kDefaultGroupSize = 50U * 1024U /* 50K */;</span>
<a href="#l3.21"></a><span id="l3.21"> </span>
<a href="#l3.22"></a><span id="l3.22" class="difflineminus">-nsDefaultAutoSyncMsgStrategy::nsDefaultAutoSyncMsgStrategy()</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineminus">-{</span>
<a href="#l3.24"></a><span id="l3.24" class="difflineminus">-}</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineplus">+nsDefaultAutoSyncMsgStrategy::nsDefaultAutoSyncMsgStrategy() {}</span>
<a href="#l3.26"></a><span id="l3.26"> </span>
<a href="#l3.27"></a><span id="l3.27" class="difflineminus">-nsDefaultAutoSyncMsgStrategy::~nsDefaultAutoSyncMsgStrategy()</span>
<a href="#l3.28"></a><span id="l3.28" class="difflineminus">-{</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineminus">-}</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineplus">+nsDefaultAutoSyncMsgStrategy::~nsDefaultAutoSyncMsgStrategy() {}</span>
<a href="#l3.31"></a><span id="l3.31"> </span>
<a href="#l3.32"></a><span id="l3.32" class="difflineminus">-NS_IMETHODIMP nsDefaultAutoSyncMsgStrategy::Sort(nsIMsgFolder *aFolder,</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineminus">-  nsIMsgDBHdr *aMsgHdr1, nsIMsgDBHdr *aMsgHdr2, nsAutoSyncStrategyDecisionType *aDecision)</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineminus">-{</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+NS_IMETHODIMP nsDefaultAutoSyncMsgStrategy::Sort(</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+    nsIMsgFolder *aFolder, nsIMsgDBHdr *aMsgHdr1, nsIMsgDBHdr *aMsgHdr2,</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineplus">+    nsAutoSyncStrategyDecisionType *aDecision) {</span>
<a href="#l3.38"></a><span id="l3.38">   NS_ENSURE_ARG_POINTER(aDecision);</span>
<a href="#l3.39"></a><span id="l3.39"> </span>
<a href="#l3.40"></a><span id="l3.40">   uint32_t msgSize1 = 0, msgSize2 = 0;</span>
<a href="#l3.41"></a><span id="l3.41">   PRTime msgDate1 = 0, msgDate2 = 0;</span>
<a href="#l3.42"></a><span id="l3.42"> </span>
<a href="#l3.43"></a><span id="l3.43" class="difflineminus">-  if (!aMsgHdr1 || !aMsgHdr2)</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineminus">-  {</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineplus">+  if (!aMsgHdr1 || !aMsgHdr2) {</span>
<a href="#l3.46"></a><span id="l3.46">     *aDecision = nsAutoSyncStrategyDecisions::Same;</span>
<a href="#l3.47"></a><span id="l3.47">     return NS_OK;</span>
<a href="#l3.48"></a><span id="l3.48">   }</span>
<a href="#l3.49"></a><span id="l3.49"> </span>
<a href="#l3.50"></a><span id="l3.50">   aMsgHdr1-&gt;GetMessageSize(&amp;msgSize1);</span>
<a href="#l3.51"></a><span id="l3.51">   aMsgHdr1-&gt;GetDate(&amp;msgDate1);</span>
<a href="#l3.52"></a><span id="l3.52"> </span>
<a href="#l3.53"></a><span id="l3.53">   aMsgHdr2-&gt;GetMessageSize(&amp;msgSize2);</span>
<a href="#l3.54"></a><span id="l3.54">   aMsgHdr2-&gt;GetDate(&amp;msgDate2);</span>
<a href="#l3.55"></a><span id="l3.55"> </span>
<a href="#l3.56"></a><span id="l3.56" class="difflineminus">-  //Special case: if message size is larger than a</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+  // Special case: if message size is larger than a</span>
<a href="#l3.58"></a><span id="l3.58">   // certain size, then place it to the bottom of the q</span>
<a href="#l3.59"></a><span id="l3.59">   if (msgSize2 &gt; kFirstPassMessageSize &amp;&amp; msgSize1 &gt; kFirstPassMessageSize)</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineminus">-    *aDecision = msgSize2 &gt; msgSize1 ?</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineminus">-        nsAutoSyncStrategyDecisions::Lower : nsAutoSyncStrategyDecisions::Higher;</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineplus">+    *aDecision = msgSize2 &gt; msgSize1 ? nsAutoSyncStrategyDecisions::Lower</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineplus">+                                     : nsAutoSyncStrategyDecisions::Higher;</span>
<a href="#l3.64"></a><span id="l3.64">   else if (msgSize2 &gt; kFirstPassMessageSize)</span>
<a href="#l3.65"></a><span id="l3.65">     *aDecision = nsAutoSyncStrategyDecisions::Lower;</span>
<a href="#l3.66"></a><span id="l3.66">   else if (msgSize1 &gt; kFirstPassMessageSize)</span>
<a href="#l3.67"></a><span id="l3.67">     *aDecision = nsAutoSyncStrategyDecisions::Higher;</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineminus">-  else</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineminus">-  {</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineplus">+  else {</span>
<a href="#l3.71"></a><span id="l3.71">     // Most recent and smallest first</span>
<a href="#l3.72"></a><span id="l3.72">     if (msgDate1 &lt; msgDate2)</span>
<a href="#l3.73"></a><span id="l3.73">       *aDecision = nsAutoSyncStrategyDecisions::Higher;</span>
<a href="#l3.74"></a><span id="l3.74">     else if (msgDate1 &gt; msgDate2)</span>
<a href="#l3.75"></a><span id="l3.75">       *aDecision = nsAutoSyncStrategyDecisions::Lower;</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineminus">-    else</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineminus">-    {</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+    else {</span>
<a href="#l3.79"></a><span id="l3.79">       if (msgSize1 &gt; msgSize2)</span>
<a href="#l3.80"></a><span id="l3.80">         *aDecision = nsAutoSyncStrategyDecisions::Higher;</span>
<a href="#l3.81"></a><span id="l3.81">       else if (msgSize1 &lt; msgSize2)</span>
<a href="#l3.82"></a><span id="l3.82">         *aDecision = nsAutoSyncStrategyDecisions::Lower;</span>
<a href="#l3.83"></a><span id="l3.83">       else</span>
<a href="#l3.84"></a><span id="l3.84">         *aDecision = nsAutoSyncStrategyDecisions::Same;</span>
<a href="#l3.85"></a><span id="l3.85">     }</span>
<a href="#l3.86"></a><span id="l3.86">   }</span>
<a href="#l3.87"></a><span id="l3.87">   return NS_OK;</span>
<a href="#l3.88"></a><span id="l3.88"> }</span>
<a href="#l3.89"></a><span id="l3.89"> </span>
<a href="#l3.90"></a><span id="l3.90"> NS_IMETHODIMP nsDefaultAutoSyncMsgStrategy::IsExcluded(nsIMsgFolder *aFolder,</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineminus">-  nsIMsgDBHdr *aMsgHdr, bool *aDecision)</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineminus">-{</span>
<a href="#l3.93"></a><span id="l3.93" class="difflineplus">+                                                       nsIMsgDBHdr *aMsgHdr,</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineplus">+                                                       bool *aDecision) {</span>
<a href="#l3.95"></a><span id="l3.95">   NS_ENSURE_ARG_POINTER(aDecision);</span>
<a href="#l3.96"></a><span id="l3.96">   NS_ENSURE_ARG_POINTER(aMsgHdr);</span>
<a href="#l3.97"></a><span id="l3.97">   NS_ENSURE_ARG_POINTER(aFolder);</span>
<a href="#l3.98"></a><span id="l3.98">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l3.99"></a><span id="l3.99"> </span>
<a href="#l3.100"></a><span id="l3.100">   nsresult rv = aFolder-&gt;GetServer(getter_AddRefs(server));</span>
<a href="#l3.101"></a><span id="l3.101">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.102"></a><span id="l3.102">   nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer(do_QueryInterface(server, &amp;rv));</span>
<a href="#l3.103"></a><span id="l3.103">   int32_t offlineMsgAgeLimit = -1;</span>
<a href="#l3.104"></a><span id="l3.104">   imapServer-&gt;GetAutoSyncMaxAgeDays(&amp;offlineMsgAgeLimit);</span>
<a href="#l3.105"></a><span id="l3.105">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.106"></a><span id="l3.106">   PRTime msgDate;</span>
<a href="#l3.107"></a><span id="l3.107">   aMsgHdr-&gt;GetDate(&amp;msgDate);</span>
<a href="#l3.108"></a><span id="l3.108">   *aDecision = offlineMsgAgeLimit &gt; 0 &amp;&amp;</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineminus">-    msgDate &lt; MsgConvertAgeInDaysToCutoffDate(offlineMsgAgeLimit);</span>
<a href="#l3.110"></a><span id="l3.110" class="difflineplus">+               msgDate &lt; MsgConvertAgeInDaysToCutoffDate(offlineMsgAgeLimit);</span>
<a href="#l3.111"></a><span id="l3.111">   return NS_OK;</span>
<a href="#l3.112"></a><span id="l3.112"> }</span>
<a href="#l3.113"></a><span id="l3.113"> </span>
<a href="#l3.114"></a><span id="l3.114"> NS_IMPL_ISUPPORTS(nsDefaultAutoSyncFolderStrategy, nsIAutoSyncFolderStrategy)</span>
<a href="#l3.115"></a><span id="l3.115"> </span>
<a href="#l3.116"></a><span id="l3.116" class="difflineminus">-nsDefaultAutoSyncFolderStrategy::nsDefaultAutoSyncFolderStrategy()</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineminus">-{</span>
<a href="#l3.118"></a><span id="l3.118" class="difflineminus">-}</span>
<a href="#l3.119"></a><span id="l3.119" class="difflineplus">+nsDefaultAutoSyncFolderStrategy::nsDefaultAutoSyncFolderStrategy() {}</span>
<a href="#l3.120"></a><span id="l3.120" class="difflineplus">+</span>
<a href="#l3.121"></a><span id="l3.121" class="difflineplus">+nsDefaultAutoSyncFolderStrategy::~nsDefaultAutoSyncFolderStrategy() {}</span>
<a href="#l3.122"></a><span id="l3.122"> </span>
<a href="#l3.123"></a><span id="l3.123" class="difflineminus">-nsDefaultAutoSyncFolderStrategy::~nsDefaultAutoSyncFolderStrategy()</span>
<a href="#l3.124"></a><span id="l3.124" class="difflineminus">-{</span>
<a href="#l3.125"></a><span id="l3.125" class="difflineminus">-}</span>
<a href="#l3.126"></a><span id="l3.126" class="difflineminus">-</span>
<a href="#l3.127"></a><span id="l3.127" class="difflineminus">-NS_IMETHODIMP nsDefaultAutoSyncFolderStrategy::Sort(nsIMsgFolder *aFolderA,</span>
<a href="#l3.128"></a><span id="l3.128" class="difflineminus">-  nsIMsgFolder *aFolderB, nsAutoSyncStrategyDecisionType *aDecision)</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineminus">-{</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineplus">+NS_IMETHODIMP nsDefaultAutoSyncFolderStrategy::Sort(</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineplus">+    nsIMsgFolder *aFolderA, nsIMsgFolder *aFolderB,</span>
<a href="#l3.132"></a><span id="l3.132" class="difflineplus">+    nsAutoSyncStrategyDecisionType *aDecision) {</span>
<a href="#l3.133"></a><span id="l3.133">   NS_ENSURE_ARG_POINTER(aDecision);</span>
<a href="#l3.134"></a><span id="l3.134"> </span>
<a href="#l3.135"></a><span id="l3.135" class="difflineminus">-  if (!aFolderA || !aFolderB)</span>
<a href="#l3.136"></a><span id="l3.136" class="difflineminus">-  {</span>
<a href="#l3.137"></a><span id="l3.137" class="difflineplus">+  if (!aFolderA || !aFolderB) {</span>
<a href="#l3.138"></a><span id="l3.138">     *aDecision = nsAutoSyncStrategyDecisions::Same;</span>
<a href="#l3.139"></a><span id="l3.139">     return NS_OK;</span>
<a href="#l3.140"></a><span id="l3.140">   }</span>
<a href="#l3.141"></a><span id="l3.141"> </span>
<a href="#l3.142"></a><span id="l3.142">   bool isInbox1, isInbox2, isDrafts1, isDrafts2, isTrash1, isTrash2;</span>
<a href="#l3.143"></a><span id="l3.143">   aFolderA-&gt;GetFlag(nsMsgFolderFlags::Inbox, &amp;isInbox1);</span>
<a href="#l3.144"></a><span id="l3.144">   aFolderB-&gt;GetFlag(nsMsgFolderFlags::Inbox, &amp;isInbox2);</span>
<a href="#l3.145"></a><span id="l3.145">   //</span>
<a href="#l3.146"></a><span id="l3.146">   aFolderA-&gt;GetFlag(nsMsgFolderFlags::Drafts, &amp;isDrafts1);</span>
<a href="#l3.147"></a><span id="l3.147">   aFolderB-&gt;GetFlag(nsMsgFolderFlags::Drafts, &amp;isDrafts2);</span>
<a href="#l3.148"></a><span id="l3.148">   //</span>
<a href="#l3.149"></a><span id="l3.149">   aFolderA-&gt;GetFlag(nsMsgFolderFlags::Trash, &amp;isTrash1);</span>
<a href="#l3.150"></a><span id="l3.150">   aFolderB-&gt;GetFlag(nsMsgFolderFlags::Trash, &amp;isTrash2);</span>
<a href="#l3.151"></a><span id="l3.151"> </span>
<a href="#l3.152"></a><span id="l3.152" class="difflineminus">-  //Follow this order;</span>
<a href="#l3.153"></a><span id="l3.153" class="difflineplus">+  // Follow this order;</span>
<a href="#l3.154"></a><span id="l3.154">   // INBOX &gt; DRAFTS &gt; SUBFOLDERS &gt; TRASH</span>
<a href="#l3.155"></a><span id="l3.155"> </span>
<a href="#l3.156"></a><span id="l3.156">   // test whether the folder is opened by the user.</span>
<a href="#l3.157"></a><span id="l3.157">   // we give high priority to the folders explicitly opened by</span>
<a href="#l3.158"></a><span id="l3.158">   // the user.</span>
<a href="#l3.159"></a><span id="l3.159">   nsresult rv;</span>
<a href="#l3.160"></a><span id="l3.160">   bool folderAOpen = false;</span>
<a href="#l3.161"></a><span id="l3.161">   bool folderBOpen = false;</span>
<a href="#l3.162"></a><span id="l3.162">   nsCOMPtr&lt;nsIMsgMailSession&gt; session =</span>
<a href="#l3.163"></a><span id="l3.163" class="difflineminus">-           do_GetService(NS_MSGMAILSESSION_CONTRACTID, &amp;rv);</span>
<a href="#l3.164"></a><span id="l3.164" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; session)</span>
<a href="#l3.165"></a><span id="l3.165" class="difflineminus">-  {</span>
<a href="#l3.166"></a><span id="l3.166" class="difflineplus">+      do_GetService(NS_MSGMAILSESSION_CONTRACTID, &amp;rv);</span>
<a href="#l3.167"></a><span id="l3.167" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; session) {</span>
<a href="#l3.168"></a><span id="l3.168">     session-&gt;IsFolderOpenInWindow(aFolderA, &amp;folderAOpen);</span>
<a href="#l3.169"></a><span id="l3.169">     session-&gt;IsFolderOpenInWindow(aFolderB, &amp;folderBOpen);</span>
<a href="#l3.170"></a><span id="l3.170">   }</span>
<a href="#l3.171"></a><span id="l3.171"> </span>
<a href="#l3.172"></a><span id="l3.172" class="difflineminus">-  if (folderAOpen == folderBOpen)</span>
<a href="#l3.173"></a><span id="l3.173" class="difflineminus">-  {</span>
<a href="#l3.174"></a><span id="l3.174" class="difflineplus">+  if (folderAOpen == folderBOpen) {</span>
<a href="#l3.175"></a><span id="l3.175">     // if both of them or none of them are opened by the user</span>
<a href="#l3.176"></a><span id="l3.176">     // make your decision based on the folder type</span>
<a href="#l3.177"></a><span id="l3.177">     if (isInbox2 || (isDrafts2 &amp;&amp; !isInbox1) || isTrash1)</span>
<a href="#l3.178"></a><span id="l3.178">       *aDecision = nsAutoSyncStrategyDecisions::Higher;</span>
<a href="#l3.179"></a><span id="l3.179">     else if (isInbox1 || (isDrafts1 &amp;&amp; !isDrafts2) || isTrash2)</span>
<a href="#l3.180"></a><span id="l3.180">       *aDecision = nsAutoSyncStrategyDecisions::Lower;</span>
<a href="#l3.181"></a><span id="l3.181">     else</span>
<a href="#l3.182"></a><span id="l3.182">       *aDecision = nsAutoSyncStrategyDecisions::Same;</span>
<a href="#l3.183"></a><span id="l3.183" class="difflineminus">-  }</span>
<a href="#l3.184"></a><span id="l3.184" class="difflineminus">-  else</span>
<a href="#l3.185"></a><span id="l3.185" class="difflineminus">-  {</span>
<a href="#l3.186"></a><span id="l3.186" class="difflineplus">+  } else {</span>
<a href="#l3.187"></a><span id="l3.187">     // otherwise give higher priority to opened one</span>
<a href="#l3.188"></a><span id="l3.188" class="difflineminus">-    *aDecision = folderBOpen ? nsAutoSyncStrategyDecisions::Higher :</span>
<a href="#l3.189"></a><span id="l3.189" class="difflineminus">-                               nsAutoSyncStrategyDecisions::Lower;</span>
<a href="#l3.190"></a><span id="l3.190" class="difflineplus">+    *aDecision = folderBOpen ? nsAutoSyncStrategyDecisions::Higher</span>
<a href="#l3.191"></a><span id="l3.191" class="difflineplus">+                             : nsAutoSyncStrategyDecisions::Lower;</span>
<a href="#l3.192"></a><span id="l3.192">   }</span>
<a href="#l3.193"></a><span id="l3.193"> </span>
<a href="#l3.194"></a><span id="l3.194">   return NS_OK;</span>
<a href="#l3.195"></a><span id="l3.195"> }</span>
<a href="#l3.196"></a><span id="l3.196"> </span>
<a href="#l3.197"></a><span id="l3.197"> NS_IMETHODIMP</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineminus">-nsDefaultAutoSyncFolderStrategy::IsExcluded(nsIMsgFolder *aFolder, bool *aDecision)</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineminus">-{</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineplus">+nsDefaultAutoSyncFolderStrategy::IsExcluded(nsIMsgFolder *aFolder,</span>
<a href="#l3.201"></a><span id="l3.201" class="difflineplus">+                                            bool *aDecision) {</span>
<a href="#l3.202"></a><span id="l3.202">   NS_ENSURE_ARG_POINTER(aDecision);</span>
<a href="#l3.203"></a><span id="l3.203">   NS_ENSURE_ARG_POINTER(aFolder);</span>
<a href="#l3.204"></a><span id="l3.204">   uint32_t folderFlags;</span>
<a href="#l3.205"></a><span id="l3.205">   aFolder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l3.206"></a><span id="l3.206">   // exclude saved search</span>
<a href="#l3.207"></a><span id="l3.207">   *aDecision = (folderFlags &amp; nsMsgFolderFlags::Virtual);</span>
<a href="#l3.208"></a><span id="l3.208" class="difflineminus">-  if (!*aDecision)</span>
<a href="#l3.209"></a><span id="l3.209" class="difflineminus">-  {</span>
<a href="#l3.210"></a><span id="l3.210" class="difflineplus">+  if (!*aDecision) {</span>
<a href="#l3.211"></a><span id="l3.211">     // Exclude orphans</span>
<a href="#l3.212"></a><span id="l3.212">     nsCOMPtr&lt;nsIMsgFolder&gt; parent;</span>
<a href="#l3.213"></a><span id="l3.213">     aFolder-&gt;GetParent(getter_AddRefs(parent));</span>
<a href="#l3.214"></a><span id="l3.214" class="difflineminus">-    if (!parent)</span>
<a href="#l3.215"></a><span id="l3.215" class="difflineminus">-      *aDecision = true;</span>
<a href="#l3.216"></a><span id="l3.216" class="difflineplus">+    if (!parent) *aDecision = true;</span>
<a href="#l3.217"></a><span id="l3.217">   }</span>
<a href="#l3.218"></a><span id="l3.218">   return NS_OK;</span>
<a href="#l3.219"></a><span id="l3.219"> }</span>
<a href="#l3.220"></a><span id="l3.220"> </span>
<a href="#l3.221"></a><span id="l3.221" class="difflineminus">-#define NOTIFY_LISTENERS_STATIC(obj_, propertyfunc_, params_) \</span>
<a href="#l3.222"></a><span id="l3.222" class="difflineminus">-  PR_BEGIN_MACRO \</span>
<a href="#l3.223"></a><span id="l3.223" class="difflineminus">-  nsTObserverArray&lt;nsCOMPtr&lt;nsIAutoSyncMgrListener&gt; &gt;::ForwardIterator iter(obj_-&gt;mListeners); \</span>
<a href="#l3.224"></a><span id="l3.224" class="difflineminus">-  nsCOMPtr&lt;nsIAutoSyncMgrListener&gt; listener; \</span>
<a href="#l3.225"></a><span id="l3.225" class="difflineminus">-  while (iter.HasMore()) { \</span>
<a href="#l3.226"></a><span id="l3.226" class="difflineminus">-    listener = iter.GetNext(); \</span>
<a href="#l3.227"></a><span id="l3.227" class="difflineminus">-    listener-&gt;propertyfunc_ params_; \</span>
<a href="#l3.228"></a><span id="l3.228" class="difflineminus">-  } \</span>
<a href="#l3.229"></a><span id="l3.229" class="difflineplus">+#define NOTIFY_LISTENERS_STATIC(obj_, propertyfunc_, params_)                \</span>
<a href="#l3.230"></a><span id="l3.230" class="difflineplus">+  PR_BEGIN_MACRO                                                             \</span>
<a href="#l3.231"></a><span id="l3.231" class="difflineplus">+  nsTObserverArray&lt;nsCOMPtr&lt;nsIAutoSyncMgrListener&gt; &gt;::ForwardIterator iter( \</span>
<a href="#l3.232"></a><span id="l3.232" class="difflineplus">+      obj_-&gt;mListeners);                                                     \</span>
<a href="#l3.233"></a><span id="l3.233" class="difflineplus">+  nsCOMPtr&lt;nsIAutoSyncMgrListener&gt; listener;                                 \</span>
<a href="#l3.234"></a><span id="l3.234" class="difflineplus">+  while (iter.HasMore()) {                                                   \</span>
<a href="#l3.235"></a><span id="l3.235" class="difflineplus">+    listener = iter.GetNext();                                               \</span>
<a href="#l3.236"></a><span id="l3.236" class="difflineplus">+    listener-&gt;propertyfunc_ params_;                                         \</span>
<a href="#l3.237"></a><span id="l3.237" class="difflineplus">+  }                                                                          \</span>
<a href="#l3.238"></a><span id="l3.238">   PR_END_MACRO</span>
<a href="#l3.239"></a><span id="l3.239"> </span>
<a href="#l3.240"></a><span id="l3.240"> #define NOTIFY_LISTENERS(propertyfunc_, params_) \</span>
<a href="#l3.241"></a><span id="l3.241">   NOTIFY_LISTENERS_STATIC(this, propertyfunc_, params_)</span>
<a href="#l3.242"></a><span id="l3.242"> </span>
<a href="#l3.243"></a><span id="l3.243" class="difflineminus">-nsAutoSyncManager::nsAutoSyncManager()</span>
<a href="#l3.244"></a><span id="l3.244" class="difflineminus">-{</span>
<a href="#l3.245"></a><span id="l3.245" class="difflineplus">+nsAutoSyncManager::nsAutoSyncManager() {</span>
<a href="#l3.246"></a><span id="l3.246">   mGroupSize = kDefaultGroupSize;</span>
<a href="#l3.247"></a><span id="l3.247"> </span>
<a href="#l3.248"></a><span id="l3.248">   mIdleState = notIdle;</span>
<a href="#l3.249"></a><span id="l3.249">   mStartupDone = false;</span>
<a href="#l3.250"></a><span id="l3.250">   mDownloadModel = dmChained;</span>
<a href="#l3.251"></a><span id="l3.251">   mUpdateState = completed;</span>
<a href="#l3.252"></a><span id="l3.252">   mPaused = false;</span>
<a href="#l3.253"></a><span id="l3.253"> </span>
<a href="#l3.254"></a><span id="l3.254">   nsresult rv;</span>
<a href="#l3.255"></a><span id="l3.255">   mIdleService = do_GetService(&quot;@mozilla.org/widget/idleservice;1&quot;, &amp;rv);</span>
<a href="#l3.256"></a><span id="l3.256" class="difflineminus">-  if (mIdleService)</span>
<a href="#l3.257"></a><span id="l3.257" class="difflineminus">-    mIdleService-&gt;AddIdleObserver(this, kIdleTimeInSec);</span>
<a href="#l3.258"></a><span id="l3.258" class="difflineplus">+  if (mIdleService) mIdleService-&gt;AddIdleObserver(this, kIdleTimeInSec);</span>
<a href="#l3.259"></a><span id="l3.259"> </span>
<a href="#l3.260"></a><span id="l3.260">   // Observe xpcom-shutdown event and app-idle changes</span>
<a href="#l3.261"></a><span id="l3.261">   nsCOMPtr&lt;nsIObserverService&gt; observerService =</span>
<a href="#l3.262"></a><span id="l3.262" class="difflineminus">-    mozilla::services::GetObserverService();</span>
<a href="#l3.263"></a><span id="l3.263" class="difflineplus">+      mozilla::services::GetObserverService();</span>
<a href="#l3.264"></a><span id="l3.264"> </span>
<a href="#l3.265"></a><span id="l3.265" class="difflineminus">-  rv = observerService-&gt;AddObserver(this,</span>
<a href="#l3.266"></a><span id="l3.266" class="difflineminus">-                                    NS_XPCOM_SHUTDOWN_OBSERVER_ID,</span>
<a href="#l3.267"></a><span id="l3.267" class="difflineminus">-                                    false);</span>
<a href="#l3.268"></a><span id="l3.268" class="difflineplus">+  rv = observerService-&gt;AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, false);</span>
<a href="#l3.269"></a><span id="l3.269">   observerService-&gt;AddObserver(this, kAppIdleNotification, false);</span>
<a href="#l3.270"></a><span id="l3.270">   observerService-&gt;AddObserver(this, NS_IOSERVICE_OFFLINE_STATUS_TOPIC, false);</span>
<a href="#l3.271"></a><span id="l3.271">   observerService-&gt;AddObserver(this, NS_IOSERVICE_GOING_OFFLINE_TOPIC, false);</span>
<a href="#l3.272"></a><span id="l3.272">   observerService-&gt;AddObserver(this, kStartupDoneNotification, false);</span>
<a href="#l3.273"></a><span id="l3.273"> }</span>
<a href="#l3.274"></a><span id="l3.274"> </span>
<a href="#l3.275"></a><span id="l3.275" class="difflineminus">-nsAutoSyncManager::~nsAutoSyncManager()</span>
<a href="#l3.276"></a><span id="l3.276" class="difflineminus">-{</span>
<a href="#l3.277"></a><span id="l3.277" class="difflineminus">-}</span>
<a href="#l3.278"></a><span id="l3.278" class="difflineplus">+nsAutoSyncManager::~nsAutoSyncManager() {}</span>
<a href="#l3.279"></a><span id="l3.279"> </span>
<a href="#l3.280"></a><span id="l3.280" class="difflineminus">-void nsAutoSyncManager::InitTimer()</span>
<a href="#l3.281"></a><span id="l3.281" class="difflineminus">-{</span>
<a href="#l3.282"></a><span id="l3.282" class="difflineminus">-  if (!mTimer)</span>
<a href="#l3.283"></a><span id="l3.283" class="difflineminus">-  {</span>
<a href="#l3.284"></a><span id="l3.284" class="difflineplus">+void nsAutoSyncManager::InitTimer() {</span>
<a href="#l3.285"></a><span id="l3.285" class="difflineplus">+  if (!mTimer) {</span>
<a href="#l3.286"></a><span id="l3.286">     nsresult rv;</span>
<a href="#l3.287"></a><span id="l3.287">     mTimer = do_CreateInstance(NS_TIMER_CONTRACTID, &amp;rv);</span>
<a href="#l3.288"></a><span id="l3.288" class="difflineminus">-    NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to create timer in nsAutoSyncManager&quot;);</span>
<a href="#l3.289"></a><span id="l3.289" class="difflineplus">+    NS_ASSERTION(NS_SUCCEEDED(rv),</span>
<a href="#l3.290"></a><span id="l3.290" class="difflineplus">+                 &quot;failed to create timer in nsAutoSyncManager&quot;);</span>
<a href="#l3.291"></a><span id="l3.291"> </span>
<a href="#l3.292"></a><span id="l3.292" class="difflineminus">-    mTimer-&gt;InitWithNamedFuncCallback(TimerCallback, (void *) this,</span>
<a href="#l3.293"></a><span id="l3.293" class="difflineminus">-                                      kTimerIntervalInMs,</span>
<a href="#l3.294"></a><span id="l3.294" class="difflineminus">-                                      nsITimer::TYPE_REPEATING_SLACK,</span>
<a href="#l3.295"></a><span id="l3.295" class="difflineminus">-                                      &quot;nsAutoSyncManager::TimerCallback&quot;);</span>
<a href="#l3.296"></a><span id="l3.296" class="difflineplus">+    mTimer-&gt;InitWithNamedFuncCallback(</span>
<a href="#l3.297"></a><span id="l3.297" class="difflineplus">+        TimerCallback, (void *)this, kTimerIntervalInMs,</span>
<a href="#l3.298"></a><span id="l3.298" class="difflineplus">+        nsITimer::TYPE_REPEATING_SLACK, &quot;nsAutoSyncManager::TimerCallback&quot;);</span>
<a href="#l3.299"></a><span id="l3.299">   }</span>
<a href="#l3.300"></a><span id="l3.300"> }</span>
<a href="#l3.301"></a><span id="l3.301"> </span>
<a href="#l3.302"></a><span id="l3.302" class="difflineminus">-void nsAutoSyncManager::StopTimer()</span>
<a href="#l3.303"></a><span id="l3.303" class="difflineminus">-{</span>
<a href="#l3.304"></a><span id="l3.304" class="difflineminus">-  if (mTimer)</span>
<a href="#l3.305"></a><span id="l3.305" class="difflineminus">-  {</span>
<a href="#l3.306"></a><span id="l3.306" class="difflineplus">+void nsAutoSyncManager::StopTimer() {</span>
<a href="#l3.307"></a><span id="l3.307" class="difflineplus">+  if (mTimer) {</span>
<a href="#l3.308"></a><span id="l3.308">     mTimer-&gt;Cancel();</span>
<a href="#l3.309"></a><span id="l3.309">     mTimer = nullptr;</span>
<a href="#l3.310"></a><span id="l3.310">   }</span>
<a href="#l3.311"></a><span id="l3.311"> }</span>
<a href="#l3.312"></a><span id="l3.312"> </span>
<a href="#l3.313"></a><span id="l3.313" class="difflineminus">-void nsAutoSyncManager::StartTimerIfNeeded()</span>
<a href="#l3.314"></a><span id="l3.314" class="difflineminus">-{</span>
<a href="#l3.315"></a><span id="l3.315" class="difflineminus">-  if ((mUpdateQ.Count() &gt; 0 || mDiscoveryQ.Count() &gt; 0) &amp;&amp; !mTimer)</span>
<a href="#l3.316"></a><span id="l3.316" class="difflineminus">-    InitTimer();</span>
<a href="#l3.317"></a><span id="l3.317" class="difflineplus">+void nsAutoSyncManager::StartTimerIfNeeded() {</span>
<a href="#l3.318"></a><span id="l3.318" class="difflineplus">+  if ((mUpdateQ.Count() &gt; 0 || mDiscoveryQ.Count() &gt; 0) &amp;&amp; !mTimer) InitTimer();</span>
<a href="#l3.319"></a><span id="l3.319"> }</span>
<a href="#l3.320"></a><span id="l3.320"> </span>
<a href="#l3.321"></a><span id="l3.321" class="difflineminus">-void nsAutoSyncManager::TimerCallback(nsITimer *aTimer, void *aClosure)</span>
<a href="#l3.322"></a><span id="l3.322" class="difflineminus">-{</span>
<a href="#l3.323"></a><span id="l3.323" class="difflineminus">-  if (!aClosure)</span>
<a href="#l3.324"></a><span id="l3.324" class="difflineminus">-    return;</span>
<a href="#l3.325"></a><span id="l3.325" class="difflineplus">+void nsAutoSyncManager::TimerCallback(nsITimer *aTimer, void *aClosure) {</span>
<a href="#l3.326"></a><span id="l3.326" class="difflineplus">+  if (!aClosure) return;</span>
<a href="#l3.327"></a><span id="l3.327"> </span>
<a href="#l3.328"></a><span id="l3.328" class="difflineminus">-  nsAutoSyncManager *autoSyncMgr = static_cast&lt;nsAutoSyncManager*&gt;(aClosure);</span>
<a href="#l3.329"></a><span id="l3.329" class="difflineplus">+  nsAutoSyncManager *autoSyncMgr = static_cast&lt;nsAutoSyncManager *&gt;(aClosure);</span>
<a href="#l3.330"></a><span id="l3.330">   if (autoSyncMgr-&gt;GetIdleState() == notIdle ||</span>
<a href="#l3.331"></a><span id="l3.331" class="difflineminus">-    (autoSyncMgr-&gt;mDiscoveryQ.Count() &lt;= 0 &amp;&amp; autoSyncMgr-&gt;mUpdateQ.Count() &lt;= 0))</span>
<a href="#l3.332"></a><span id="l3.332" class="difflineminus">-  {</span>
<a href="#l3.333"></a><span id="l3.333" class="difflineminus">-    // Idle will create a new timer automatically if discovery Q or update Q is not empty</span>
<a href="#l3.334"></a><span id="l3.334" class="difflineplus">+      (autoSyncMgr-&gt;mDiscoveryQ.Count() &lt;= 0 &amp;&amp;</span>
<a href="#l3.335"></a><span id="l3.335" class="difflineplus">+       autoSyncMgr-&gt;mUpdateQ.Count() &lt;= 0)) {</span>
<a href="#l3.336"></a><span id="l3.336" class="difflineplus">+    // Idle will create a new timer automatically if discovery Q or update Q is</span>
<a href="#l3.337"></a><span id="l3.337" class="difflineplus">+    // not empty</span>
<a href="#l3.338"></a><span id="l3.338">     autoSyncMgr-&gt;StopTimer();</span>
<a href="#l3.339"></a><span id="l3.339">   }</span>
<a href="#l3.340"></a><span id="l3.340"> </span>
<a href="#l3.341"></a><span id="l3.341">   // process folders within the discovery queue</span>
<a href="#l3.342"></a><span id="l3.342" class="difflineminus">-  if (autoSyncMgr-&gt;mDiscoveryQ.Count() &gt; 0)</span>
<a href="#l3.343"></a><span id="l3.343" class="difflineminus">-  {</span>
<a href="#l3.344"></a><span id="l3.344" class="difflineplus">+  if (autoSyncMgr-&gt;mDiscoveryQ.Count() &gt; 0) {</span>
<a href="#l3.345"></a><span id="l3.345">     nsCOMPtr&lt;nsIAutoSyncState&gt; autoSyncStateObj(autoSyncMgr-&gt;mDiscoveryQ[0]);</span>
<a href="#l3.346"></a><span id="l3.346" class="difflineminus">-    if (autoSyncStateObj)</span>
<a href="#l3.347"></a><span id="l3.347" class="difflineminus">-    {</span>
<a href="#l3.348"></a><span id="l3.348" class="difflineplus">+    if (autoSyncStateObj) {</span>
<a href="#l3.349"></a><span id="l3.349">       uint32_t leftToProcess;</span>
<a href="#l3.350"></a><span id="l3.350" class="difflineminus">-      nsresult rv = autoSyncStateObj-&gt;ProcessExistingHeaders(kNumberOfHeadersToProcess, &amp;leftToProcess);</span>
<a href="#l3.351"></a><span id="l3.351" class="difflineplus">+      nsresult rv = autoSyncStateObj-&gt;ProcessExistingHeaders(</span>
<a href="#l3.352"></a><span id="l3.352" class="difflineplus">+          kNumberOfHeadersToProcess, &amp;leftToProcess);</span>
<a href="#l3.353"></a><span id="l3.353"> </span>
<a href="#l3.354"></a><span id="l3.354">       nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.355"></a><span id="l3.355">       autoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l3.356"></a><span id="l3.356">       if (folder)</span>
<a href="#l3.357"></a><span id="l3.357" class="difflineminus">-        NOTIFY_LISTENERS_STATIC(autoSyncMgr, OnDiscoveryQProcessed, (folder, kNumberOfHeadersToProcess, leftToProcess));</span>
<a href="#l3.358"></a><span id="l3.358" class="difflineplus">+        NOTIFY_LISTENERS_STATIC(</span>
<a href="#l3.359"></a><span id="l3.359" class="difflineplus">+            autoSyncMgr, OnDiscoveryQProcessed,</span>
<a href="#l3.360"></a><span id="l3.360" class="difflineplus">+            (folder, kNumberOfHeadersToProcess, leftToProcess));</span>
<a href="#l3.361"></a><span id="l3.361"> </span>
<a href="#l3.362"></a><span id="l3.362" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; 0 == leftToProcess)</span>
<a href="#l3.363"></a><span id="l3.363" class="difflineminus">-      {</span>
<a href="#l3.364"></a><span id="l3.364" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; 0 == leftToProcess) {</span>
<a href="#l3.365"></a><span id="l3.365">         autoSyncMgr-&gt;mDiscoveryQ.RemoveObjectAt(0);</span>
<a href="#l3.366"></a><span id="l3.366">         if (folder)</span>
<a href="#l3.367"></a><span id="l3.367" class="difflineminus">-          NOTIFY_LISTENERS_STATIC(autoSyncMgr, OnFolderRemovedFromQ, (nsIAutoSyncMgrListener::DiscoveryQueue, folder));</span>
<a href="#l3.368"></a><span id="l3.368" class="difflineplus">+          NOTIFY_LISTENERS_STATIC(</span>
<a href="#l3.369"></a><span id="l3.369" class="difflineplus">+              autoSyncMgr, OnFolderRemovedFromQ,</span>
<a href="#l3.370"></a><span id="l3.370" class="difflineplus">+              (nsIAutoSyncMgrListener::DiscoveryQueue, folder));</span>
<a href="#l3.371"></a><span id="l3.371">       }</span>
<a href="#l3.372"></a><span id="l3.372">     }</span>
<a href="#l3.373"></a><span id="l3.373">   }</span>
<a href="#l3.374"></a><span id="l3.374"> </span>
<a href="#l3.375"></a><span id="l3.375" class="difflineminus">-  if (autoSyncMgr-&gt;mUpdateQ.Count() &gt; 0)</span>
<a href="#l3.376"></a><span id="l3.376" class="difflineminus">-  {</span>
<a href="#l3.377"></a><span id="l3.377" class="difflineminus">-    if (autoSyncMgr-&gt;mUpdateState == completed)</span>
<a href="#l3.378"></a><span id="l3.378" class="difflineminus">-    {</span>
<a href="#l3.379"></a><span id="l3.379" class="difflineplus">+  if (autoSyncMgr-&gt;mUpdateQ.Count() &gt; 0) {</span>
<a href="#l3.380"></a><span id="l3.380" class="difflineplus">+    if (autoSyncMgr-&gt;mUpdateState == completed) {</span>
<a href="#l3.381"></a><span id="l3.381">       nsCOMPtr&lt;nsIAutoSyncState&gt; autoSyncStateObj(autoSyncMgr-&gt;mUpdateQ[0]);</span>
<a href="#l3.382"></a><span id="l3.382" class="difflineminus">-      if (autoSyncStateObj)</span>
<a href="#l3.383"></a><span id="l3.383" class="difflineminus">-      {</span>
<a href="#l3.384"></a><span id="l3.384" class="difflineplus">+      if (autoSyncStateObj) {</span>
<a href="#l3.385"></a><span id="l3.385">         int32_t state;</span>
<a href="#l3.386"></a><span id="l3.386">         nsresult rv = autoSyncStateObj-&gt;GetState(&amp;state);</span>
<a href="#l3.387"></a><span id="l3.387">         if (NS_SUCCEEDED(rv) &amp;&amp; (state == nsAutoSyncState::stCompletedIdle ||</span>
<a href="#l3.388"></a><span id="l3.388" class="difflineminus">-                                 state == nsAutoSyncState::stUpdateNeeded))</span>
<a href="#l3.389"></a><span id="l3.389" class="difflineminus">-        {</span>
<a href="#l3.390"></a><span id="l3.390" class="difflineplus">+                                 state == nsAutoSyncState::stUpdateNeeded)) {</span>
<a href="#l3.391"></a><span id="l3.391">           nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.392"></a><span id="l3.392">           autoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l3.393"></a><span id="l3.393" class="difflineminus">-          if (folder)</span>
<a href="#l3.394"></a><span id="l3.394" class="difflineminus">-          {</span>
<a href="#l3.395"></a><span id="l3.395" class="difflineminus">-            nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(folder, &amp;rv);</span>
<a href="#l3.396"></a><span id="l3.396" class="difflineplus">+          if (folder) {</span>
<a href="#l3.397"></a><span id="l3.397" class="difflineplus">+            nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder =</span>
<a href="#l3.398"></a><span id="l3.398" class="difflineplus">+                do_QueryInterface(folder, &amp;rv);</span>
<a href="#l3.399"></a><span id="l3.399">             NS_ENSURE_SUCCESS_VOID(rv);</span>
<a href="#l3.400"></a><span id="l3.400">             rv = imapFolder-&gt;InitiateAutoSync(autoSyncMgr);</span>
<a href="#l3.401"></a><span id="l3.401" class="difflineminus">-            if (NS_SUCCEEDED(rv))</span>
<a href="#l3.402"></a><span id="l3.402" class="difflineminus">-            {</span>
<a href="#l3.403"></a><span id="l3.403" class="difflineplus">+            if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.404"></a><span id="l3.404">               autoSyncMgr-&gt;mUpdateState = initiated;</span>
<a href="#l3.405"></a><span id="l3.405" class="difflineminus">-              NOTIFY_LISTENERS_STATIC(autoSyncMgr, OnAutoSyncInitiated, (folder));</span>
<a href="#l3.406"></a><span id="l3.406" class="difflineplus">+              NOTIFY_LISTENERS_STATIC(autoSyncMgr, OnAutoSyncInitiated,</span>
<a href="#l3.407"></a><span id="l3.407" class="difflineplus">+                                      (folder));</span>
<a href="#l3.408"></a><span id="l3.408">             }</span>
<a href="#l3.409"></a><span id="l3.409">           }</span>
<a href="#l3.410"></a><span id="l3.410">         }</span>
<a href="#l3.411"></a><span id="l3.411">       }</span>
<a href="#l3.412"></a><span id="l3.412">     }</span>
<a href="#l3.413"></a><span id="l3.413">     // if initiation is not successful for some reason, or</span>
<a href="#l3.414"></a><span id="l3.414">     // if there is an on going download for this folder,</span>
<a href="#l3.415"></a><span id="l3.415">     // remove it from q and continue with the next one</span>
<a href="#l3.416"></a><span id="l3.416" class="difflineminus">-    if (autoSyncMgr-&gt;mUpdateState != initiated)</span>
<a href="#l3.417"></a><span id="l3.417" class="difflineminus">-    {</span>
<a href="#l3.418"></a><span id="l3.418" class="difflineplus">+    if (autoSyncMgr-&gt;mUpdateState != initiated) {</span>
<a href="#l3.419"></a><span id="l3.419">       nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.420"></a><span id="l3.420">       autoSyncMgr-&gt;mUpdateQ[0]-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l3.421"></a><span id="l3.421"> </span>
<a href="#l3.422"></a><span id="l3.422">       autoSyncMgr-&gt;mUpdateQ.RemoveObjectAt(0);</span>
<a href="#l3.423"></a><span id="l3.423"> </span>
<a href="#l3.424"></a><span id="l3.424">       if (folder)</span>
<a href="#l3.425"></a><span id="l3.425" class="difflineminus">-        NOTIFY_LISTENERS_STATIC(autoSyncMgr, OnFolderRemovedFromQ, (nsIAutoSyncMgrListener::UpdateQueue, folder));</span>
<a href="#l3.426"></a><span id="l3.426" class="difflineplus">+        NOTIFY_LISTENERS_STATIC(autoSyncMgr, OnFolderRemovedFromQ,</span>
<a href="#l3.427"></a><span id="l3.427" class="difflineplus">+                                (nsIAutoSyncMgrListener::UpdateQueue, folder));</span>
<a href="#l3.428"></a><span id="l3.428">     }</span>
<a href="#l3.429"></a><span id="l3.429"> </span>
<a href="#l3.430"></a><span id="l3.430" class="difflineminus">-  }//endif</span>
<a href="#l3.431"></a><span id="l3.431" class="difflineminus">-</span>
<a href="#l3.432"></a><span id="l3.432" class="difflineplus">+  }  // endif</span>
<a href="#l3.433"></a><span id="l3.433"> }</span>
<a href="#l3.434"></a><span id="l3.434"> </span>
<a href="#l3.435"></a><span id="l3.435"> /**</span>
<a href="#l3.436"></a><span id="l3.436">  * Populates aChainedQ with the auto-sync state objects that are not owned by</span>
<a href="#l3.437"></a><span id="l3.437">  * the same imap server.</span>
<a href="#l3.438"></a><span id="l3.438">  * Assumes that aChainedQ initially empty.</span>
<a href="#l3.439"></a><span id="l3.439">  */</span>
<a href="#l3.440"></a><span id="l3.440" class="difflineminus">-void nsAutoSyncManager::ChainFoldersInQ(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.441"></a><span id="l3.441" class="difflineminus">-      nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aChainedQ)</span>
<a href="#l3.442"></a><span id="l3.442" class="difflineminus">-{</span>
<a href="#l3.443"></a><span id="l3.443" class="difflineminus">-  if (aQueue.Count() &gt; 0)</span>
<a href="#l3.444"></a><span id="l3.444" class="difflineminus">-    aChainedQ.AppendObject(aQueue[0]);</span>
<a href="#l3.445"></a><span id="l3.445" class="difflineplus">+void nsAutoSyncManager::ChainFoldersInQ(</span>
<a href="#l3.446"></a><span id="l3.446" class="difflineplus">+    const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.447"></a><span id="l3.447" class="difflineplus">+    nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aChainedQ) {</span>
<a href="#l3.448"></a><span id="l3.448" class="difflineplus">+  if (aQueue.Count() &gt; 0) aChainedQ.AppendObject(aQueue[0]);</span>
<a href="#l3.449"></a><span id="l3.449"> </span>
<a href="#l3.450"></a><span id="l3.450">   int32_t pqElemCount = aQueue.Count();</span>
<a href="#l3.451"></a><span id="l3.451" class="difflineminus">-  for (int32_t pqidx = 1; pqidx &lt; pqElemCount; pqidx++)</span>
<a href="#l3.452"></a><span id="l3.452" class="difflineminus">-  {</span>
<a href="#l3.453"></a><span id="l3.453" class="difflineplus">+  for (int32_t pqidx = 1; pqidx &lt; pqElemCount; pqidx++) {</span>
<a href="#l3.454"></a><span id="l3.454">     bool chained = false;</span>
<a href="#l3.455"></a><span id="l3.455">     int32_t needToBeReplacedWith = -1;</span>
<a href="#l3.456"></a><span id="l3.456">     int32_t elemCount = aChainedQ.Count();</span>
<a href="#l3.457"></a><span id="l3.457" class="difflineminus">-    for (int32_t idx = 0; idx &lt; elemCount; idx++)</span>
<a href="#l3.458"></a><span id="l3.458" class="difflineminus">-    {</span>
<a href="#l3.459"></a><span id="l3.459" class="difflineplus">+    for (int32_t idx = 0; idx &lt; elemCount; idx++) {</span>
<a href="#l3.460"></a><span id="l3.460">       bool isSibling;</span>
<a href="#l3.461"></a><span id="l3.461">       nsresult rv = aChainedQ[idx]-&gt;IsSibling(aQueue[pqidx], &amp;isSibling);</span>
<a href="#l3.462"></a><span id="l3.462"> </span>
<a href="#l3.463"></a><span id="l3.463" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; isSibling)</span>
<a href="#l3.464"></a><span id="l3.464" class="difflineminus">-      {</span>
<a href="#l3.465"></a><span id="l3.465" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; isSibling) {</span>
<a href="#l3.466"></a><span id="l3.466">         // this prevent us to overwrite a lower priority sibling in</span>
<a href="#l3.467"></a><span id="l3.467">         // download-in-progress state with a higher priority one.</span>
<a href="#l3.468"></a><span id="l3.468">         // we have to wait until its download is completed before</span>
<a href="#l3.469"></a><span id="l3.469">         // switching to new one.</span>
<a href="#l3.470"></a><span id="l3.470">         int32_t state;</span>
<a href="#l3.471"></a><span id="l3.471">         aQueue[pqidx]-&gt;GetState(&amp;state);</span>
<a href="#l3.472"></a><span id="l3.472">         if (aQueue[pqidx] != aChainedQ[idx] &amp;&amp;</span>
<a href="#l3.473"></a><span id="l3.473">             state == nsAutoSyncState::stDownloadInProgress)</span>
<a href="#l3.474"></a><span id="l3.474">           needToBeReplacedWith = idx;</span>
<a href="#l3.475"></a><span id="l3.475">         else</span>
<a href="#l3.476"></a><span id="l3.476">           chained = true;</span>
<a href="#l3.477"></a><span id="l3.477"> </span>
<a href="#l3.478"></a><span id="l3.478">         break;</span>
<a href="#l3.479"></a><span id="l3.479">       }</span>
<a href="#l3.480"></a><span id="l3.480" class="difflineminus">-    }//endfor</span>
<a href="#l3.481"></a><span id="l3.481" class="difflineplus">+    }  // endfor</span>
<a href="#l3.482"></a><span id="l3.482"> </span>
<a href="#l3.483"></a><span id="l3.483">     if (needToBeReplacedWith &gt; -1)</span>
<a href="#l3.484"></a><span id="l3.484">       aChainedQ.ReplaceObjectAt(aQueue[pqidx], needToBeReplacedWith);</span>
<a href="#l3.485"></a><span id="l3.485">     else if (!chained)</span>
<a href="#l3.486"></a><span id="l3.486">       aChainedQ.AppendObject(aQueue[pqidx]);</span>
<a href="#l3.487"></a><span id="l3.487"> </span>
<a href="#l3.488"></a><span id="l3.488" class="difflineminus">-  }//endfor</span>
<a href="#l3.489"></a><span id="l3.489" class="difflineplus">+  }  // endfor</span>
<a href="#l3.490"></a><span id="l3.490"> }</span>
<a href="#l3.491"></a><span id="l3.491"> </span>
<a href="#l3.492"></a><span id="l3.492"> /**</span>
<a href="#l3.493"></a><span id="l3.493">  * Searches the given queue for another folder owned by the same imap server.</span>
<a href="#l3.494"></a><span id="l3.494">  */</span>
<a href="#l3.495"></a><span id="l3.495" class="difflineminus">-nsIAutoSyncState*</span>
<a href="#l3.496"></a><span id="l3.496" class="difflineminus">-nsAutoSyncManager::SearchQForSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.497"></a><span id="l3.497" class="difflineminus">-                          nsIAutoSyncState *aAutoSyncStateObj, int32_t aStartIdx, int32_t *aIndex)</span>
<a href="#l3.498"></a><span id="l3.498" class="difflineminus">-{</span>
<a href="#l3.499"></a><span id="l3.499" class="difflineminus">-  if (aIndex)</span>
<a href="#l3.500"></a><span id="l3.500" class="difflineminus">-    *aIndex = -1;</span>
<a href="#l3.501"></a><span id="l3.501" class="difflineplus">+nsIAutoSyncState *nsAutoSyncManager::SearchQForSibling(</span>
<a href="#l3.502"></a><span id="l3.502" class="difflineplus">+    const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.503"></a><span id="l3.503" class="difflineplus">+    nsIAutoSyncState *aAutoSyncStateObj, int32_t aStartIdx, int32_t *aIndex) {</span>
<a href="#l3.504"></a><span id="l3.504" class="difflineplus">+  if (aIndex) *aIndex = -1;</span>
<a href="#l3.505"></a><span id="l3.505"> </span>
<a href="#l3.506"></a><span id="l3.506" class="difflineminus">-  if (aAutoSyncStateObj)</span>
<a href="#l3.507"></a><span id="l3.507" class="difflineminus">-  {</span>
<a href="#l3.508"></a><span id="l3.508" class="difflineplus">+  if (aAutoSyncStateObj) {</span>
<a href="#l3.509"></a><span id="l3.509">     bool isSibling;</span>
<a href="#l3.510"></a><span id="l3.510">     int32_t elemCount = aQueue.Count();</span>
<a href="#l3.511"></a><span id="l3.511" class="difflineminus">-    for (int32_t idx = aStartIdx; idx &lt; elemCount; idx++)</span>
<a href="#l3.512"></a><span id="l3.512" class="difflineminus">-    {</span>
<a href="#l3.513"></a><span id="l3.513" class="difflineplus">+    for (int32_t idx = aStartIdx; idx &lt; elemCount; idx++) {</span>
<a href="#l3.514"></a><span id="l3.514">       nsresult rv = aAutoSyncStateObj-&gt;IsSibling(aQueue[idx], &amp;isSibling);</span>
<a href="#l3.515"></a><span id="l3.515"> </span>
<a href="#l3.516"></a><span id="l3.516" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; isSibling &amp;&amp; aAutoSyncStateObj != aQueue[idx])</span>
<a href="#l3.517"></a><span id="l3.517" class="difflineminus">-      {</span>
<a href="#l3.518"></a><span id="l3.518" class="difflineminus">-        if (aIndex)</span>
<a href="#l3.519"></a><span id="l3.519" class="difflineminus">-          *aIndex = idx;</span>
<a href="#l3.520"></a><span id="l3.520" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; isSibling &amp;&amp; aAutoSyncStateObj != aQueue[idx]) {</span>
<a href="#l3.521"></a><span id="l3.521" class="difflineplus">+        if (aIndex) *aIndex = idx;</span>
<a href="#l3.522"></a><span id="l3.522"> </span>
<a href="#l3.523"></a><span id="l3.523">         return aQueue[idx];</span>
<a href="#l3.524"></a><span id="l3.524">       }</span>
<a href="#l3.525"></a><span id="l3.525">     }</span>
<a href="#l3.526"></a><span id="l3.526">   }</span>
<a href="#l3.527"></a><span id="l3.527">   return nullptr;</span>
<a href="#l3.528"></a><span id="l3.528"> }</span>
<a href="#l3.529"></a><span id="l3.529"> </span>
<a href="#l3.530"></a><span id="l3.530"> /**</span>
<a href="#l3.531"></a><span id="l3.531" class="difflineminus">- * Searches for the next folder owned by the same imap server in the given queue,</span>
<a href="#l3.532"></a><span id="l3.532" class="difflineminus">- * starting from the index of the given folder.</span>
<a href="#l3.533"></a><span id="l3.533" class="difflineplus">+ * Searches for the next folder owned by the same imap server in the given</span>
<a href="#l3.534"></a><span id="l3.534" class="difflineplus">+ * queue, starting from the index of the given folder.</span>
<a href="#l3.535"></a><span id="l3.535">  */</span>
<a href="#l3.536"></a><span id="l3.536" class="difflineminus">-nsIAutoSyncState*</span>
<a href="#l3.537"></a><span id="l3.537" class="difflineminus">-nsAutoSyncManager::GetNextSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.538"></a><span id="l3.538" class="difflineminus">-                                          nsIAutoSyncState *aAutoSyncStateObj, int32_t *aIndex)</span>
<a href="#l3.539"></a><span id="l3.539" class="difflineminus">-{</span>
<a href="#l3.540"></a><span id="l3.540" class="difflineplus">+nsIAutoSyncState *nsAutoSyncManager::GetNextSibling(</span>
<a href="#l3.541"></a><span id="l3.541" class="difflineplus">+    const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.542"></a><span id="l3.542" class="difflineplus">+    nsIAutoSyncState *aAutoSyncStateObj, int32_t *aIndex) {</span>
<a href="#l3.543"></a><span id="l3.543" class="difflineplus">+  if (aIndex) *aIndex = -1;</span>
<a href="#l3.544"></a><span id="l3.544"> </span>
<a href="#l3.545"></a><span id="l3.545" class="difflineminus">-  if (aIndex)</span>
<a href="#l3.546"></a><span id="l3.546" class="difflineminus">-    *aIndex = -1;</span>
<a href="#l3.547"></a><span id="l3.547" class="difflineminus">-</span>
<a href="#l3.548"></a><span id="l3.548" class="difflineminus">-  if (aAutoSyncStateObj)</span>
<a href="#l3.549"></a><span id="l3.549" class="difflineminus">-  {</span>
<a href="#l3.550"></a><span id="l3.550" class="difflineplus">+  if (aAutoSyncStateObj) {</span>
<a href="#l3.551"></a><span id="l3.551">     bool located = false;</span>
<a href="#l3.552"></a><span id="l3.552">     bool isSibling;</span>
<a href="#l3.553"></a><span id="l3.553">     int32_t elemCount = aQueue.Count();</span>
<a href="#l3.554"></a><span id="l3.554" class="difflineminus">-    for (int32_t idx = 0; idx &lt; elemCount; idx++)</span>
<a href="#l3.555"></a><span id="l3.555" class="difflineminus">-    {</span>
<a href="#l3.556"></a><span id="l3.556" class="difflineminus">-      if (!located)</span>
<a href="#l3.557"></a><span id="l3.557" class="difflineminus">-      {</span>
<a href="#l3.558"></a><span id="l3.558" class="difflineplus">+    for (int32_t idx = 0; idx &lt; elemCount; idx++) {</span>
<a href="#l3.559"></a><span id="l3.559" class="difflineplus">+      if (!located) {</span>
<a href="#l3.560"></a><span id="l3.560">         located = (aAutoSyncStateObj == aQueue[idx]);</span>
<a href="#l3.561"></a><span id="l3.561">         continue;</span>
<a href="#l3.562"></a><span id="l3.562">       }</span>
<a href="#l3.563"></a><span id="l3.563"> </span>
<a href="#l3.564"></a><span id="l3.564">       nsresult rv = aAutoSyncStateObj-&gt;IsSibling(aQueue[idx], &amp;isSibling);</span>
<a href="#l3.565"></a><span id="l3.565" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; isSibling)</span>
<a href="#l3.566"></a><span id="l3.566" class="difflineminus">-      {</span>
<a href="#l3.567"></a><span id="l3.567" class="difflineminus">-        if (aIndex)</span>
<a href="#l3.568"></a><span id="l3.568" class="difflineminus">-          *aIndex = idx;</span>
<a href="#l3.569"></a><span id="l3.569" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; isSibling) {</span>
<a href="#l3.570"></a><span id="l3.570" class="difflineplus">+        if (aIndex) *aIndex = idx;</span>
<a href="#l3.571"></a><span id="l3.571"> </span>
<a href="#l3.572"></a><span id="l3.572">         return aQueue[idx];</span>
<a href="#l3.573"></a><span id="l3.573">       }</span>
<a href="#l3.574"></a><span id="l3.574">     }</span>
<a href="#l3.575"></a><span id="l3.575">   }</span>
<a href="#l3.576"></a><span id="l3.576">   return nullptr;</span>
<a href="#l3.577"></a><span id="l3.577"> }</span>
<a href="#l3.578"></a><span id="l3.578"> </span>
<a href="#l3.579"></a><span id="l3.579" class="difflineat">@@ -481,935 +430,836 @@ nsAutoSyncManager::GetNextSibling(const </span>
<a href="#l3.580"></a><span id="l3.580">  * @param aQueue the queue that will be searched for a sibling</span>
<a href="#l3.581"></a><span id="l3.581">  * @param aAutoSyncStateObj the auto-sync state object that we are looking</span>
<a href="#l3.582"></a><span id="l3.582">  *                          a sibling for</span>
<a href="#l3.583"></a><span id="l3.583">  * @param aState the state of the sibling. -1 means &quot;any state&quot;</span>
<a href="#l3.584"></a><span id="l3.584">  * @param aIndex [out] the index of the found sibling, if it is provided by the</span>
<a href="#l3.585"></a><span id="l3.585">  *               caller (not null)</span>
<a href="#l3.586"></a><span id="l3.586">  * @return true if found, false otherwise</span>
<a href="#l3.587"></a><span id="l3.587">  */</span>
<a href="#l3.588"></a><span id="l3.588" class="difflineminus">-bool nsAutoSyncManager::DoesQContainAnySiblingOf(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.589"></a><span id="l3.589" class="difflineminus">-                                                   nsIAutoSyncState *aAutoSyncStateObj,</span>
<a href="#l3.590"></a><span id="l3.590" class="difflineminus">-                                                   const int32_t aState, int32_t *aIndex)</span>
<a href="#l3.591"></a><span id="l3.591" class="difflineminus">-{</span>
<a href="#l3.592"></a><span id="l3.592" class="difflineplus">+bool nsAutoSyncManager::DoesQContainAnySiblingOf(</span>
<a href="#l3.593"></a><span id="l3.593" class="difflineplus">+    const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.594"></a><span id="l3.594" class="difflineplus">+    nsIAutoSyncState *aAutoSyncStateObj, const int32_t aState,</span>
<a href="#l3.595"></a><span id="l3.595" class="difflineplus">+    int32_t *aIndex) {</span>
<a href="#l3.596"></a><span id="l3.596">   if (aState == -1)</span>
<a href="#l3.597"></a><span id="l3.597">     return (nullptr != SearchQForSibling(aQueue, aAutoSyncStateObj, 0, aIndex));</span>
<a href="#l3.598"></a><span id="l3.598"> </span>
<a href="#l3.599"></a><span id="l3.599">   int32_t offset = 0;</span>
<a href="#l3.600"></a><span id="l3.600">   nsIAutoSyncState *autoSyncState;</span>
<a href="#l3.601"></a><span id="l3.601" class="difflineminus">-  while ((autoSyncState = SearchQForSibling(aQueue, aAutoSyncStateObj, offset, &amp;offset)))</span>
<a href="#l3.602"></a><span id="l3.602" class="difflineminus">-  {</span>
<a href="#l3.603"></a><span id="l3.603" class="difflineplus">+  while ((autoSyncState =</span>
<a href="#l3.604"></a><span id="l3.604" class="difflineplus">+              SearchQForSibling(aQueue, aAutoSyncStateObj, offset, &amp;offset))) {</span>
<a href="#l3.605"></a><span id="l3.605">     int32_t state;</span>
<a href="#l3.606"></a><span id="l3.606">     nsresult rv = autoSyncState-&gt;GetState(&amp;state);</span>
<a href="#l3.607"></a><span id="l3.607" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; aState == state)</span>
<a href="#l3.608"></a><span id="l3.608" class="difflineminus">-      break;</span>
<a href="#l3.609"></a><span id="l3.609" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; aState == state) break;</span>
<a href="#l3.610"></a><span id="l3.610"> </span>
<a href="#l3.611"></a><span id="l3.611">     offset++;</span>
<a href="#l3.612"></a><span id="l3.612">   }</span>
<a href="#l3.613"></a><span id="l3.613" class="difflineminus">-  if (aIndex)</span>
<a href="#l3.614"></a><span id="l3.614" class="difflineminus">-    *aIndex = offset;</span>
<a href="#l3.615"></a><span id="l3.615" class="difflineplus">+  if (aIndex) *aIndex = offset;</span>
<a href="#l3.616"></a><span id="l3.616"> </span>
<a href="#l3.617"></a><span id="l3.617">   return (nullptr != autoSyncState);</span>
<a href="#l3.618"></a><span id="l3.618"> }</span>
<a href="#l3.619"></a><span id="l3.619"> </span>
<a href="#l3.620"></a><span id="l3.620"> /**</span>
<a href="#l3.621"></a><span id="l3.621">  * Searches the given queue for the highest priority folder owned by the</span>
<a href="#l3.622"></a><span id="l3.622">  * same imap server.</span>
<a href="#l3.623"></a><span id="l3.623">  */</span>
<a href="#l3.624"></a><span id="l3.624" class="difflineminus">-nsIAutoSyncState*</span>
<a href="#l3.625"></a><span id="l3.625" class="difflineminus">-nsAutoSyncManager::GetHighestPrioSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.626"></a><span id="l3.626" class="difflineminus">-                                      nsIAutoSyncState *aAutoSyncStateObj, int32_t *aIndex)</span>
<a href="#l3.627"></a><span id="l3.627" class="difflineminus">-{</span>
<a href="#l3.628"></a><span id="l3.628" class="difflineplus">+nsIAutoSyncState *nsAutoSyncManager::GetHighestPrioSibling(</span>
<a href="#l3.629"></a><span id="l3.629" class="difflineplus">+    const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.630"></a><span id="l3.630" class="difflineplus">+    nsIAutoSyncState *aAutoSyncStateObj, int32_t *aIndex) {</span>
<a href="#l3.631"></a><span id="l3.631">   return SearchQForSibling(aQueue, aAutoSyncStateObj, 0, aIndex);</span>
<a href="#l3.632"></a><span id="l3.632"> }</span>
<a href="#l3.633"></a><span id="l3.633"> </span>
<a href="#l3.634"></a><span id="l3.634"> // to chain update folder actions</span>
<a href="#l3.635"></a><span id="l3.635" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::OnStartRunningUrl(nsIURI* aUrl)</span>
<a href="#l3.636"></a><span id="l3.636" class="difflineminus">-{</span>
<a href="#l3.637"></a><span id="l3.637" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::OnStartRunningUrl(nsIURI *aUrl) {</span>
<a href="#l3.638"></a><span id="l3.638">   return NS_OK;</span>
<a href="#l3.639"></a><span id="l3.639"> }</span>
<a href="#l3.640"></a><span id="l3.640"> </span>
<a href="#l3.641"></a><span id="l3.641" class="difflineminus">-</span>
<a href="#l3.642"></a><span id="l3.642" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::OnStopRunningUrl(nsIURI* aUrl, nsresult aExitCode)</span>
<a href="#l3.643"></a><span id="l3.643" class="difflineminus">-{</span>
<a href="#l3.644"></a><span id="l3.644" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::OnStopRunningUrl(nsIURI *aUrl,</span>
<a href="#l3.645"></a><span id="l3.645" class="difflineplus">+                                                  nsresult aExitCode) {</span>
<a href="#l3.646"></a><span id="l3.646">   mUpdateState = completed;</span>
<a href="#l3.647"></a><span id="l3.647" class="difflineminus">-  if (mUpdateQ.Count() &gt; 0)</span>
<a href="#l3.648"></a><span id="l3.648" class="difflineminus">-    mUpdateQ.RemoveObjectAt(0);</span>
<a href="#l3.649"></a><span id="l3.649" class="difflineplus">+  if (mUpdateQ.Count() &gt; 0) mUpdateQ.RemoveObjectAt(0);</span>
<a href="#l3.650"></a><span id="l3.650"> </span>
<a href="#l3.651"></a><span id="l3.651">   return aExitCode;</span>
<a href="#l3.652"></a><span id="l3.652"> }</span>
<a href="#l3.653"></a><span id="l3.653"> </span>
<a href="#l3.654"></a><span id="l3.654" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::Pause()</span>
<a href="#l3.655"></a><span id="l3.655" class="difflineminus">-{</span>
<a href="#l3.656"></a><span id="l3.656" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::Pause() {</span>
<a href="#l3.657"></a><span id="l3.657">   StopTimer();</span>
<a href="#l3.658"></a><span id="l3.658">   mPaused = true;</span>
<a href="#l3.659"></a><span id="l3.659">   MOZ_LOG(gAutoSyncLog, LogLevel::Debug, (&quot;autosync paused&quot;));</span>
<a href="#l3.660"></a><span id="l3.660">   return NS_OK;</span>
<a href="#l3.661"></a><span id="l3.661"> }</span>
<a href="#l3.662"></a><span id="l3.662"> </span>
<a href="#l3.663"></a><span id="l3.663" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::Resume()</span>
<a href="#l3.664"></a><span id="l3.664" class="difflineminus">-{</span>
<a href="#l3.665"></a><span id="l3.665" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::Resume() {</span>
<a href="#l3.666"></a><span id="l3.666">   mPaused = false;</span>
<a href="#l3.667"></a><span id="l3.667">   StartTimerIfNeeded();</span>
<a href="#l3.668"></a><span id="l3.668">   MOZ_LOG(gAutoSyncLog, LogLevel::Debug, (&quot;autosync resumed&quot;));</span>
<a href="#l3.669"></a><span id="l3.669">   return NS_OK;</span>
<a href="#l3.670"></a><span id="l3.670"> }</span>
<a href="#l3.671"></a><span id="l3.671"> </span>
<a href="#l3.672"></a><span id="l3.672" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::Observe(nsISupports*, const char *aTopic, const char16_t *aSomeData)</span>
<a href="#l3.673"></a><span id="l3.673" class="difflineminus">-{</span>
<a href="#l3.674"></a><span id="l3.674" class="difflineminus">-  if (!PL_strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID))</span>
<a href="#l3.675"></a><span id="l3.675" class="difflineminus">-  {</span>
<a href="#l3.676"></a><span id="l3.676" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::Observe(nsISupports *, const char *aTopic,</span>
<a href="#l3.677"></a><span id="l3.677" class="difflineplus">+                                         const char16_t *aSomeData) {</span>
<a href="#l3.678"></a><span id="l3.678" class="difflineplus">+  if (!PL_strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID)) {</span>
<a href="#l3.679"></a><span id="l3.679">     nsCOMPtr&lt;nsIObserverService&gt; observerService =</span>
<a href="#l3.680"></a><span id="l3.680" class="difflineminus">-      mozilla::services::GetObserverService();</span>
<a href="#l3.681"></a><span id="l3.681" class="difflineminus">-    if (observerService)</span>
<a href="#l3.682"></a><span id="l3.682" class="difflineminus">-    {</span>
<a href="#l3.683"></a><span id="l3.683" class="difflineplus">+        mozilla::services::GetObserverService();</span>
<a href="#l3.684"></a><span id="l3.684" class="difflineplus">+    if (observerService) {</span>
<a href="#l3.685"></a><span id="l3.685">       observerService-&gt;RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);</span>
<a href="#l3.686"></a><span id="l3.686">       observerService-&gt;RemoveObserver(this, kAppIdleNotification);</span>
<a href="#l3.687"></a><span id="l3.687">       observerService-&gt;RemoveObserver(this, NS_IOSERVICE_OFFLINE_STATUS_TOPIC);</span>
<a href="#l3.688"></a><span id="l3.688">       observerService-&gt;RemoveObserver(this, NS_IOSERVICE_GOING_OFFLINE_TOPIC);</span>
<a href="#l3.689"></a><span id="l3.689">       observerService-&gt;RemoveObserver(this, kStartupDoneNotification);</span>
<a href="#l3.690"></a><span id="l3.690">     }</span>
<a href="#l3.691"></a><span id="l3.691"> </span>
<a href="#l3.692"></a><span id="l3.692">     // cancel and release the timer</span>
<a href="#l3.693"></a><span id="l3.693" class="difflineminus">-    if (mTimer)</span>
<a href="#l3.694"></a><span id="l3.694" class="difflineminus">-    {</span>
<a href="#l3.695"></a><span id="l3.695" class="difflineminus">-       mTimer-&gt;Cancel();</span>
<a href="#l3.696"></a><span id="l3.696" class="difflineminus">-       mTimer = nullptr;</span>
<a href="#l3.697"></a><span id="l3.697" class="difflineplus">+    if (mTimer) {</span>
<a href="#l3.698"></a><span id="l3.698" class="difflineplus">+      mTimer-&gt;Cancel();</span>
<a href="#l3.699"></a><span id="l3.699" class="difflineplus">+      mTimer = nullptr;</span>
<a href="#l3.700"></a><span id="l3.700">     }</span>
<a href="#l3.701"></a><span id="l3.701">     // unsubscribe from idle service</span>
<a href="#l3.702"></a><span id="l3.702" class="difflineminus">-    if (mIdleService)</span>
<a href="#l3.703"></a><span id="l3.703" class="difflineminus">-       mIdleService-&gt;RemoveIdleObserver(this, kIdleTimeInSec);</span>
<a href="#l3.704"></a><span id="l3.704" class="difflineplus">+    if (mIdleService) mIdleService-&gt;RemoveIdleObserver(this, kIdleTimeInSec);</span>
<a href="#l3.705"></a><span id="l3.705"> </span>
<a href="#l3.706"></a><span id="l3.706">     return NS_OK;</span>
<a href="#l3.707"></a><span id="l3.707">   }</span>
<a href="#l3.708"></a><span id="l3.708"> </span>
<a href="#l3.709"></a><span id="l3.709" class="difflineminus">-  if (!PL_strcmp(aTopic, kStartupDoneNotification))</span>
<a href="#l3.710"></a><span id="l3.710" class="difflineminus">-  {</span>
<a href="#l3.711"></a><span id="l3.711" class="difflineplus">+  if (!PL_strcmp(aTopic, kStartupDoneNotification)) {</span>
<a href="#l3.712"></a><span id="l3.712">     mStartupDone = true;</span>
<a href="#l3.713"></a><span id="l3.713" class="difflineminus">-  }</span>
<a href="#l3.714"></a><span id="l3.714" class="difflineminus">-  else if (!PL_strcmp(aTopic, kAppIdleNotification))</span>
<a href="#l3.715"></a><span id="l3.715" class="difflineminus">-  {</span>
<a href="#l3.716"></a><span id="l3.716" class="difflineminus">-    if (nsDependentString(aSomeData).EqualsLiteral(&quot;idle&quot;))</span>
<a href="#l3.717"></a><span id="l3.717" class="difflineminus">-    {</span>
<a href="#l3.718"></a><span id="l3.718" class="difflineplus">+  } else if (!PL_strcmp(aTopic, kAppIdleNotification)) {</span>
<a href="#l3.719"></a><span id="l3.719" class="difflineplus">+    if (nsDependentString(aSomeData).EqualsLiteral(&quot;idle&quot;)) {</span>
<a href="#l3.720"></a><span id="l3.720">       IdleState prevIdleState = GetIdleState();</span>
<a href="#l3.721"></a><span id="l3.721"> </span>
<a href="#l3.722"></a><span id="l3.722">       // we were already idle (either system or app), so</span>
<a href="#l3.723"></a><span id="l3.723">       // just remember that we're app idle and return.</span>
<a href="#l3.724"></a><span id="l3.724">       SetIdleState(appIdle);</span>
<a href="#l3.725"></a><span id="l3.725" class="difflineminus">-      if (prevIdleState != notIdle)</span>
<a href="#l3.726"></a><span id="l3.726" class="difflineminus">-        return NS_OK;</span>
<a href="#l3.727"></a><span id="l3.727" class="difflineplus">+      if (prevIdleState != notIdle) return NS_OK;</span>
<a href="#l3.728"></a><span id="l3.728"> </span>
<a href="#l3.729"></a><span id="l3.729" class="difflineminus">-       return StartIdleProcessing();</span>
<a href="#l3.730"></a><span id="l3.730" class="difflineminus">-     }</span>
<a href="#l3.731"></a><span id="l3.731" class="difflineplus">+      return StartIdleProcessing();</span>
<a href="#l3.732"></a><span id="l3.732" class="difflineplus">+    }</span>
<a href="#l3.733"></a><span id="l3.733"> </span>
<a href="#l3.734"></a><span id="l3.734" class="difflineminus">-     // we're back from appIdle - if already notIdle, just return;</span>
<a href="#l3.735"></a><span id="l3.735" class="difflineminus">-     if (GetIdleState() == notIdle)</span>
<a href="#l3.736"></a><span id="l3.736" class="difflineminus">-       return NS_OK;</span>
<a href="#l3.737"></a><span id="l3.737" class="difflineplus">+    // we're back from appIdle - if already notIdle, just return;</span>
<a href="#l3.738"></a><span id="l3.738" class="difflineplus">+    if (GetIdleState() == notIdle) return NS_OK;</span>
<a href="#l3.739"></a><span id="l3.739"> </span>
<a href="#l3.740"></a><span id="l3.740">     SetIdleState(notIdle);</span>
<a href="#l3.741"></a><span id="l3.741">     NOTIFY_LISTENERS(OnStateChanged, (false));</span>
<a href="#l3.742"></a><span id="l3.742">     return NS_OK;</span>
<a href="#l3.743"></a><span id="l3.743" class="difflineminus">-  }</span>
<a href="#l3.744"></a><span id="l3.744" class="difflineminus">-  else if (!PL_strcmp(aTopic, NS_IOSERVICE_OFFLINE_STATUS_TOPIC))</span>
<a href="#l3.745"></a><span id="l3.745" class="difflineminus">-  {</span>
<a href="#l3.746"></a><span id="l3.746" class="difflineplus">+  } else if (!PL_strcmp(aTopic, NS_IOSERVICE_OFFLINE_STATUS_TOPIC)) {</span>
<a href="#l3.747"></a><span id="l3.747">     if (nsDependentString(aSomeData).EqualsLiteral(NS_IOSERVICE_ONLINE))</span>
<a href="#l3.748"></a><span id="l3.748">       Resume();</span>
<a href="#l3.749"></a><span id="l3.749" class="difflineminus">-  }</span>
<a href="#l3.750"></a><span id="l3.750" class="difflineminus">-  else if (!PL_strcmp(aTopic, NS_IOSERVICE_GOING_OFFLINE_TOPIC))</span>
<a href="#l3.751"></a><span id="l3.751" class="difflineminus">-  {</span>
<a href="#l3.752"></a><span id="l3.752" class="difflineplus">+  } else if (!PL_strcmp(aTopic, NS_IOSERVICE_GOING_OFFLINE_TOPIC)) {</span>
<a href="#l3.753"></a><span id="l3.753">     Pause();</span>
<a href="#l3.754"></a><span id="l3.754">   }</span>
<a href="#l3.755"></a><span id="l3.755">   // we're back from system idle</span>
<a href="#l3.756"></a><span id="l3.756" class="difflineminus">-  else if (!PL_strcmp(aTopic, &quot;back&quot;))</span>
<a href="#l3.757"></a><span id="l3.757" class="difflineminus">-  {</span>
<a href="#l3.758"></a><span id="l3.758" class="difflineplus">+  else if (!PL_strcmp(aTopic, &quot;back&quot;)) {</span>
<a href="#l3.759"></a><span id="l3.759">     // if we're app idle when we get back from system idle, we ignore</span>
<a href="#l3.760"></a><span id="l3.760">     // it, since we'll keep doing our idle stuff.</span>
<a href="#l3.761"></a><span id="l3.761" class="difflineminus">-    if (GetIdleState() != appIdle)</span>
<a href="#l3.762"></a><span id="l3.762" class="difflineminus">-    {</span>
<a href="#l3.763"></a><span id="l3.763" class="difflineplus">+    if (GetIdleState() != appIdle) {</span>
<a href="#l3.764"></a><span id="l3.764">       SetIdleState(notIdle);</span>
<a href="#l3.765"></a><span id="l3.765">       NOTIFY_LISTENERS(OnStateChanged, (false));</span>
<a href="#l3.766"></a><span id="l3.766">     }</span>
<a href="#l3.767"></a><span id="l3.767">     return NS_OK;</span>
<a href="#l3.768"></a><span id="l3.768" class="difflineminus">-  }</span>
<a href="#l3.769"></a><span id="l3.769" class="difflineminus">-  else // we've gone system idle</span>
<a href="#l3.770"></a><span id="l3.770" class="difflineplus">+  } else  // we've gone system idle</span>
<a href="#l3.771"></a><span id="l3.771">   {</span>
<a href="#l3.772"></a><span id="l3.772">     // Check if we were already idle. We may have gotten</span>
<a href="#l3.773"></a><span id="l3.773">     // multiple system idle notificatons. In that case,</span>
<a href="#l3.774"></a><span id="l3.774">     // just remember that we're systemIdle and return;</span>
<a href="#l3.775"></a><span id="l3.775" class="difflineminus">-    if (GetIdleState() != notIdle)</span>
<a href="#l3.776"></a><span id="l3.776" class="difflineminus">-      return NS_OK;</span>
<a href="#l3.777"></a><span id="l3.777" class="difflineplus">+    if (GetIdleState() != notIdle) return NS_OK;</span>
<a href="#l3.778"></a><span id="l3.778"> </span>
<a href="#l3.779"></a><span id="l3.779">     // we might want to remember if we were app idle, because</span>
<a href="#l3.780"></a><span id="l3.780">     // coming back from system idle while app idle shouldn't stop</span>
<a href="#l3.781"></a><span id="l3.781">     // app indexing. But I think it's OK for now just leave ourselves</span>
<a href="#l3.782"></a><span id="l3.782">     // in appIdle state.</span>
<a href="#l3.783"></a><span id="l3.783" class="difflineminus">-    if (GetIdleState() != appIdle)</span>
<a href="#l3.784"></a><span id="l3.784" class="difflineminus">-      SetIdleState(systemIdle);</span>
<a href="#l3.785"></a><span id="l3.785" class="difflineminus">-    if (WeAreOffline())</span>
<a href="#l3.786"></a><span id="l3.786" class="difflineminus">-      return NS_OK;</span>
<a href="#l3.787"></a><span id="l3.787" class="difflineplus">+    if (GetIdleState() != appIdle) SetIdleState(systemIdle);</span>
<a href="#l3.788"></a><span id="l3.788" class="difflineplus">+    if (WeAreOffline()) return NS_OK;</span>
<a href="#l3.789"></a><span id="l3.789">     return StartIdleProcessing();</span>
<a href="#l3.790"></a><span id="l3.790">   }</span>
<a href="#l3.791"></a><span id="l3.791">   return NS_OK;</span>
<a href="#l3.792"></a><span id="l3.792"> }</span>
<a href="#l3.793"></a><span id="l3.793"> </span>
<a href="#l3.794"></a><span id="l3.794" class="difflineminus">-nsresult nsAutoSyncManager::StartIdleProcessing()</span>
<a href="#l3.795"></a><span id="l3.795" class="difflineminus">-{</span>
<a href="#l3.796"></a><span id="l3.796" class="difflineminus">-  if (mPaused)</span>
<a href="#l3.797"></a><span id="l3.797" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.798"></a><span id="l3.798" class="difflineplus">+nsresult nsAutoSyncManager::StartIdleProcessing() {</span>
<a href="#l3.799"></a><span id="l3.799" class="difflineplus">+  if (mPaused) return NS_OK;</span>
<a href="#l3.800"></a><span id="l3.800"> </span>
<a href="#l3.801"></a><span id="l3.801">   StartTimerIfNeeded();</span>
<a href="#l3.802"></a><span id="l3.802"> </span>
<a href="#l3.803"></a><span id="l3.803">   // Ignore idle events sent during the startup</span>
<a href="#l3.804"></a><span id="l3.804" class="difflineminus">-  if (!mStartupDone)</span>
<a href="#l3.805"></a><span id="l3.805" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.806"></a><span id="l3.806" class="difflineplus">+  if (!mStartupDone) return NS_OK;</span>
<a href="#l3.807"></a><span id="l3.807"> </span>
<a href="#l3.808"></a><span id="l3.808">   // notify listeners that auto-sync is running</span>
<a href="#l3.809"></a><span id="l3.809">   NOTIFY_LISTENERS(OnStateChanged, (true));</span>
<a href="#l3.810"></a><span id="l3.810"> </span>
<a href="#l3.811"></a><span id="l3.811">   nsCOMArray&lt;nsIAutoSyncState&gt; chainedQ;</span>
<a href="#l3.812"></a><span id="l3.812">   nsCOMArray&lt;nsIAutoSyncState&gt; *queue = &amp;mPriorityQ;</span>
<a href="#l3.813"></a><span id="l3.813" class="difflineminus">-  if (mDownloadModel == dmChained)</span>
<a href="#l3.814"></a><span id="l3.814" class="difflineminus">-  {</span>
<a href="#l3.815"></a><span id="l3.815" class="difflineplus">+  if (mDownloadModel == dmChained) {</span>
<a href="#l3.816"></a><span id="l3.816">     ChainFoldersInQ(mPriorityQ, chainedQ);</span>
<a href="#l3.817"></a><span id="l3.817">     queue = &amp;chainedQ;</span>
<a href="#l3.818"></a><span id="l3.818">   }</span>
<a href="#l3.819"></a><span id="l3.819"> </span>
<a href="#l3.820"></a><span id="l3.820">   // to store the folders that should be removed from the priority</span>
<a href="#l3.821"></a><span id="l3.821">   // queue at the end of the iteration.</span>
<a href="#l3.822"></a><span id="l3.822">   nsCOMArray&lt;nsIAutoSyncState&gt; foldersToBeRemoved;</span>
<a href="#l3.823"></a><span id="l3.823"> </span>
<a href="#l3.824"></a><span id="l3.824">   // process folders in the priority queue</span>
<a href="#l3.825"></a><span id="l3.825">   int32_t elemCount = queue-&gt;Count();</span>
<a href="#l3.826"></a><span id="l3.826" class="difflineminus">-  for (int32_t idx = 0; idx &lt; elemCount; idx++)</span>
<a href="#l3.827"></a><span id="l3.827" class="difflineminus">-  {</span>
<a href="#l3.828"></a><span id="l3.828" class="difflineplus">+  for (int32_t idx = 0; idx &lt; elemCount; idx++) {</span>
<a href="#l3.829"></a><span id="l3.829">     nsCOMPtr&lt;nsIAutoSyncState&gt; autoSyncStateObj((*queue)[idx]);</span>
<a href="#l3.830"></a><span id="l3.830" class="difflineminus">-    if (!autoSyncStateObj)</span>
<a href="#l3.831"></a><span id="l3.831" class="difflineminus">-      continue;</span>
<a href="#l3.832"></a><span id="l3.832" class="difflineplus">+    if (!autoSyncStateObj) continue;</span>
<a href="#l3.833"></a><span id="l3.833"> </span>
<a href="#l3.834"></a><span id="l3.834">     int32_t state;</span>
<a href="#l3.835"></a><span id="l3.835">     autoSyncStateObj-&gt;GetState(&amp;state);</span>
<a href="#l3.836"></a><span id="l3.836"> </span>
<a href="#l3.837"></a><span id="l3.837" class="difflineminus">-    //TODO: Test cached-connection availability in parallel mode</span>
<a href="#l3.838"></a><span id="l3.838" class="difflineplus">+    // TODO: Test cached-connection availability in parallel mode</span>
<a href="#l3.839"></a><span id="l3.839">     // and do not exceed (cached-connection count - 1)</span>
<a href="#l3.840"></a><span id="l3.840"> </span>
<a href="#l3.841"></a><span id="l3.841" class="difflineminus">-    if (state != nsAutoSyncState::stReadyToDownload)</span>
<a href="#l3.842"></a><span id="l3.842" class="difflineminus">-      continue;</span>
<a href="#l3.843"></a><span id="l3.843" class="difflineplus">+    if (state != nsAutoSyncState::stReadyToDownload) continue;</span>
<a href="#l3.844"></a><span id="l3.844"> </span>
<a href="#l3.845"></a><span id="l3.845">     nsresult rv = DownloadMessagesForOffline(autoSyncStateObj);</span>
<a href="#l3.846"></a><span id="l3.846" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l3.847"></a><span id="l3.847" class="difflineminus">-    {</span>
<a href="#l3.848"></a><span id="l3.848" class="difflineplus">+    if (NS_FAILED(rv)) {</span>
<a href="#l3.849"></a><span id="l3.849">       // special case: this folder does not have any message to download</span>
<a href="#l3.850"></a><span id="l3.850">       // (see bug 457342), remove it explicitly from the queue when iteration</span>
<a href="#l3.851"></a><span id="l3.851">       // is over.</span>
<a href="#l3.852"></a><span id="l3.852">       // Note that in normal execution flow, folders are removed from priority</span>
<a href="#l3.853"></a><span id="l3.853">       // queue only in OnDownloadCompleted when all messages are downloaded</span>
<a href="#l3.854"></a><span id="l3.854">       // successfully. This is the only place we change this flow.</span>
<a href="#l3.855"></a><span id="l3.855">       if (NS_ERROR_NOT_AVAILABLE == rv)</span>
<a href="#l3.856"></a><span id="l3.856">         foldersToBeRemoved.AppendObject(autoSyncStateObj);</span>
<a href="#l3.857"></a><span id="l3.857"> </span>
<a href="#l3.858"></a><span id="l3.858">       HandleDownloadErrorFor(autoSyncStateObj, rv);</span>
<a href="#l3.859"></a><span id="l3.859" class="difflineminus">-    }// endif</span>
<a href="#l3.860"></a><span id="l3.860" class="difflineminus">-  }//endfor</span>
<a href="#l3.861"></a><span id="l3.861" class="difflineplus">+    }  // endif</span>
<a href="#l3.862"></a><span id="l3.862" class="difflineplus">+  }    // endfor</span>
<a href="#l3.863"></a><span id="l3.863"> </span>
<a href="#l3.864"></a><span id="l3.864">   // remove folders with no pending messages from the priority queue</span>
<a href="#l3.865"></a><span id="l3.865">   elemCount = foldersToBeRemoved.Count();</span>
<a href="#l3.866"></a><span id="l3.866" class="difflineminus">-  for (int32_t idx = 0; idx &lt; elemCount; idx++)</span>
<a href="#l3.867"></a><span id="l3.867" class="difflineminus">-  {</span>
<a href="#l3.868"></a><span id="l3.868" class="difflineplus">+  for (int32_t idx = 0; idx &lt; elemCount; idx++) {</span>
<a href="#l3.869"></a><span id="l3.869">     nsCOMPtr&lt;nsIAutoSyncState&gt; autoSyncStateObj(foldersToBeRemoved[idx]);</span>
<a href="#l3.870"></a><span id="l3.870" class="difflineminus">-    if (!autoSyncStateObj)</span>
<a href="#l3.871"></a><span id="l3.871" class="difflineminus">-      continue;</span>
<a href="#l3.872"></a><span id="l3.872" class="difflineplus">+    if (!autoSyncStateObj) continue;</span>
<a href="#l3.873"></a><span id="l3.873"> </span>
<a href="#l3.874"></a><span id="l3.874">     nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.875"></a><span id="l3.875">     autoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l3.876"></a><span id="l3.876" class="difflineminus">-    if (folder)</span>
<a href="#l3.877"></a><span id="l3.877" class="difflineminus">-      NOTIFY_LISTENERS(OnDownloadCompleted, (folder));</span>
<a href="#l3.878"></a><span id="l3.878" class="difflineplus">+    if (folder) NOTIFY_LISTENERS(OnDownloadCompleted, (folder));</span>
<a href="#l3.879"></a><span id="l3.879"> </span>
<a href="#l3.880"></a><span id="l3.880">     autoSyncStateObj-&gt;SetState(nsAutoSyncState::stCompletedIdle);</span>
<a href="#l3.881"></a><span id="l3.881"> </span>
<a href="#l3.882"></a><span id="l3.882">     if (mPriorityQ.RemoveObject(autoSyncStateObj))</span>
<a href="#l3.883"></a><span id="l3.883">       NOTIFY_LISTENERS(OnFolderRemovedFromQ,</span>
<a href="#l3.884"></a><span id="l3.884" class="difflineminus">-                      (nsIAutoSyncMgrListener::PriorityQueue, folder));</span>
<a href="#l3.885"></a><span id="l3.885" class="difflineplus">+                       (nsIAutoSyncMgrListener::PriorityQueue, folder));</span>
<a href="#l3.886"></a><span id="l3.886">   }</span>
<a href="#l3.887"></a><span id="l3.887"> </span>
<a href="#l3.888"></a><span id="l3.888">   return AutoUpdateFolders();</span>
<a href="#l3.889"></a><span id="l3.889"> }</span>
<a href="#l3.890"></a><span id="l3.890"> </span>
<a href="#l3.891"></a><span id="l3.891"> /**</span>
<a href="#l3.892"></a><span id="l3.892">  * Updates offline imap folders that are not synchronized recently. This is</span>
<a href="#l3.893"></a><span id="l3.893">  * called whenever we're idle.</span>
<a href="#l3.894"></a><span id="l3.894">  */</span>
<a href="#l3.895"></a><span id="l3.895" class="difflineminus">-nsresult nsAutoSyncManager::AutoUpdateFolders()</span>
<a href="#l3.896"></a><span id="l3.896" class="difflineminus">-{</span>
<a href="#l3.897"></a><span id="l3.897" class="difflineplus">+nsresult nsAutoSyncManager::AutoUpdateFolders() {</span>
<a href="#l3.898"></a><span id="l3.898">   nsresult rv;</span>
<a href="#l3.899"></a><span id="l3.899"> </span>
<a href="#l3.900"></a><span id="l3.900">   // iterate through each imap account and update offline folders automatically</span>
<a href="#l3.901"></a><span id="l3.901"> </span>
<a href="#l3.902"></a><span id="l3.902" class="difflineminus">-  nsCOMPtr&lt;nsIMsgAccountManager&gt; accountManager = do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l3.903"></a><span id="l3.903" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l3.904"></a><span id="l3.904" class="difflineplus">+  nsCOMPtr&lt;nsIMsgAccountManager&gt; accountManager =</span>
<a href="#l3.905"></a><span id="l3.905" class="difflineplus">+      do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l3.906"></a><span id="l3.906" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.907"></a><span id="l3.907"> </span>
<a href="#l3.908"></a><span id="l3.908">   nsCOMPtr&lt;nsIArray&gt; accounts;</span>
<a href="#l3.909"></a><span id="l3.909">   rv = accountManager-&gt;GetAccounts(getter_AddRefs(accounts));</span>
<a href="#l3.910"></a><span id="l3.910" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l3.911"></a><span id="l3.911" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.912"></a><span id="l3.912"> </span>
<a href="#l3.913"></a><span id="l3.913">   uint32_t accountCount;</span>
<a href="#l3.914"></a><span id="l3.914">   accounts-&gt;GetLength(&amp;accountCount);</span>
<a href="#l3.915"></a><span id="l3.915"> </span>
<a href="#l3.916"></a><span id="l3.916" class="difflineminus">-  for (uint32_t i = 0; i &lt; accountCount; ++i)</span>
<a href="#l3.917"></a><span id="l3.917" class="difflineminus">-  {</span>
<a href="#l3.918"></a><span id="l3.918" class="difflineplus">+  for (uint32_t i = 0; i &lt; accountCount; ++i) {</span>
<a href="#l3.919"></a><span id="l3.919">     nsCOMPtr&lt;nsIMsgAccount&gt; account(do_QueryElementAt(accounts, i, &amp;rv));</span>
<a href="#l3.920"></a><span id="l3.920" class="difflineminus">-    if (!account)</span>
<a href="#l3.921"></a><span id="l3.921" class="difflineminus">-      continue;</span>
<a href="#l3.922"></a><span id="l3.922" class="difflineplus">+    if (!account) continue;</span>
<a href="#l3.923"></a><span id="l3.923"> </span>
<a href="#l3.924"></a><span id="l3.924">     nsCOMPtr&lt;nsIMsgIncomingServer&gt; incomingServer;</span>
<a href="#l3.925"></a><span id="l3.925">     rv = account-&gt;GetIncomingServer(getter_AddRefs(incomingServer));</span>
<a href="#l3.926"></a><span id="l3.926" class="difflineminus">-    if (!incomingServer)</span>
<a href="#l3.927"></a><span id="l3.927" class="difflineminus">-      continue;</span>
<a href="#l3.928"></a><span id="l3.928" class="difflineplus">+    if (!incomingServer) continue;</span>
<a href="#l3.929"></a><span id="l3.929"> </span>
<a href="#l3.930"></a><span id="l3.930">     nsCString type;</span>
<a href="#l3.931"></a><span id="l3.931">     rv = incomingServer-&gt;GetType(type);</span>
<a href="#l3.932"></a><span id="l3.932"> </span>
<a href="#l3.933"></a><span id="l3.933" class="difflineminus">-    if (!type.EqualsLiteral(&quot;imap&quot;))</span>
<a href="#l3.934"></a><span id="l3.934" class="difflineminus">-      continue;</span>
<a href="#l3.935"></a><span id="l3.935" class="difflineplus">+    if (!type.EqualsLiteral(&quot;imap&quot;)) continue;</span>
<a href="#l3.936"></a><span id="l3.936"> </span>
<a href="#l3.937"></a><span id="l3.937">     // if we haven't logged onto this server yet, then skip this server.</span>
<a href="#l3.938"></a><span id="l3.938">     bool passwordRequired;</span>
<a href="#l3.939"></a><span id="l3.939">     incomingServer-&gt;GetServerRequiresPasswordForBiff(&amp;passwordRequired);</span>
<a href="#l3.940"></a><span id="l3.940" class="difflineminus">-    if (passwordRequired)</span>
<a href="#l3.941"></a><span id="l3.941" class="difflineminus">-      continue;</span>
<a href="#l3.942"></a><span id="l3.942" class="difflineplus">+    if (passwordRequired) continue;</span>
<a href="#l3.943"></a><span id="l3.943"> </span>
<a href="#l3.944"></a><span id="l3.944">     nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l3.945"></a><span id="l3.945">     nsCOMPtr&lt;nsIArray&gt; allDescendants;</span>
<a href="#l3.946"></a><span id="l3.946"> </span>
<a href="#l3.947"></a><span id="l3.947">     rv = incomingServer-&gt;GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l3.948"></a><span id="l3.948" class="difflineminus">-    if (rootFolder)</span>
<a href="#l3.949"></a><span id="l3.949" class="difflineminus">-    {</span>
<a href="#l3.950"></a><span id="l3.950" class="difflineminus">-      if (NS_FAILED(rv))</span>
<a href="#l3.951"></a><span id="l3.951" class="difflineminus">-        continue;</span>
<a href="#l3.952"></a><span id="l3.952" class="difflineplus">+    if (rootFolder) {</span>
<a href="#l3.953"></a><span id="l3.953" class="difflineplus">+      if (NS_FAILED(rv)) continue;</span>
<a href="#l3.954"></a><span id="l3.954"> </span>
<a href="#l3.955"></a><span id="l3.955">       rv = rootFolder-&gt;GetDescendants(getter_AddRefs(allDescendants));</span>
<a href="#l3.956"></a><span id="l3.956" class="difflineminus">-      if (!allDescendants)</span>
<a href="#l3.957"></a><span id="l3.957" class="difflineminus">-        continue;</span>
<a href="#l3.958"></a><span id="l3.958" class="difflineplus">+      if (!allDescendants) continue;</span>
<a href="#l3.959"></a><span id="l3.959"> </span>
<a href="#l3.960"></a><span id="l3.960">       uint32_t cnt = 0;</span>
<a href="#l3.961"></a><span id="l3.961">       rv = allDescendants-&gt;GetLength(&amp;cnt);</span>
<a href="#l3.962"></a><span id="l3.962" class="difflineminus">-      if (NS_FAILED(rv))</span>
<a href="#l3.963"></a><span id="l3.963" class="difflineminus">-        continue;</span>
<a href="#l3.964"></a><span id="l3.964" class="difflineplus">+      if (NS_FAILED(rv)) continue;</span>
<a href="#l3.965"></a><span id="l3.965"> </span>
<a href="#l3.966"></a><span id="l3.966" class="difflineminus">-      for (uint32_t i = 0; i &lt; cnt; i++)</span>
<a href="#l3.967"></a><span id="l3.967" class="difflineminus">-      {</span>
<a href="#l3.968"></a><span id="l3.968" class="difflineminus">-        nsCOMPtr&lt;nsIMsgFolder&gt; folder(do_QueryElementAt(allDescendants, i, &amp;rv));</span>
<a href="#l3.969"></a><span id="l3.969" class="difflineminus">-        if (NS_FAILED(rv))</span>
<a href="#l3.970"></a><span id="l3.970" class="difflineminus">-          continue;</span>
<a href="#l3.971"></a><span id="l3.971" class="difflineplus">+      for (uint32_t i = 0; i &lt; cnt; i++) {</span>
<a href="#l3.972"></a><span id="l3.972" class="difflineplus">+        nsCOMPtr&lt;nsIMsgFolder&gt; folder(</span>
<a href="#l3.973"></a><span id="l3.973" class="difflineplus">+            do_QueryElementAt(allDescendants, i, &amp;rv));</span>
<a href="#l3.974"></a><span id="l3.974" class="difflineplus">+        if (NS_FAILED(rv)) continue;</span>
<a href="#l3.975"></a><span id="l3.975"> </span>
<a href="#l3.976"></a><span id="l3.976">         uint32_t folderFlags;</span>
<a href="#l3.977"></a><span id="l3.977">         rv = folder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l3.978"></a><span id="l3.978">         // Skip this folder if not offline or is a saved search or is no select.</span>
<a href="#l3.979"></a><span id="l3.979">         if (NS_FAILED(rv) || !(folderFlags &amp; nsMsgFolderFlags::Offline) ||</span>
<a href="#l3.980"></a><span id="l3.980" class="difflineminus">-            folderFlags &amp; (nsMsgFolderFlags::Virtual |</span>
<a href="#l3.981"></a><span id="l3.981" class="difflineminus">-                           nsMsgFolderFlags::ImapNoselect))</span>
<a href="#l3.982"></a><span id="l3.982" class="difflineplus">+            folderFlags &amp;</span>
<a href="#l3.983"></a><span id="l3.983" class="difflineplus">+                (nsMsgFolderFlags::Virtual | nsMsgFolderFlags::ImapNoselect))</span>
<a href="#l3.984"></a><span id="l3.984">           continue;</span>
<a href="#l3.985"></a><span id="l3.985"> </span>
<a href="#l3.986"></a><span id="l3.986" class="difflineminus">-        nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(folder, &amp;rv);</span>
<a href="#l3.987"></a><span id="l3.987" class="difflineminus">-        if (NS_FAILED(rv))</span>
<a href="#l3.988"></a><span id="l3.988" class="difflineminus">-          continue;</span>
<a href="#l3.989"></a><span id="l3.989" class="difflineplus">+        nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder =</span>
<a href="#l3.990"></a><span id="l3.990" class="difflineplus">+            do_QueryInterface(folder, &amp;rv);</span>
<a href="#l3.991"></a><span id="l3.991" class="difflineplus">+        if (NS_FAILED(rv)) continue;</span>
<a href="#l3.992"></a><span id="l3.992"> </span>
<a href="#l3.993"></a><span id="l3.993">         nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l3.994"></a><span id="l3.994">         rv = imapFolder-&gt;GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l3.995"></a><span id="l3.995" class="difflineminus">-        if (imapServer)</span>
<a href="#l3.996"></a><span id="l3.996" class="difflineminus">-        {</span>
<a href="#l3.997"></a><span id="l3.997" class="difflineplus">+        if (imapServer) {</span>
<a href="#l3.998"></a><span id="l3.998">           bool autoSyncOfflineStores = false;</span>
<a href="#l3.999"></a><span id="l3.999">           rv = imapServer-&gt;GetAutoSyncOfflineStores(&amp;autoSyncOfflineStores);</span>
<a href="#l3.1000"></a><span id="l3.1000"> </span>
<a href="#l3.1001"></a><span id="l3.1001">           // skip if AutoSyncOfflineStores pref is not set for this folder</span>
<a href="#l3.1002"></a><span id="l3.1002" class="difflineminus">-          if (NS_FAILED(rv) || !autoSyncOfflineStores)</span>
<a href="#l3.1003"></a><span id="l3.1003" class="difflineminus">-            continue;</span>
<a href="#l3.1004"></a><span id="l3.1004" class="difflineplus">+          if (NS_FAILED(rv) || !autoSyncOfflineStores) continue;</span>
<a href="#l3.1005"></a><span id="l3.1005">         }</span>
<a href="#l3.1006"></a><span id="l3.1006"> </span>
<a href="#l3.1007"></a><span id="l3.1007">         nsCOMPtr&lt;nsIAutoSyncState&gt; autoSyncState;</span>
<a href="#l3.1008"></a><span id="l3.1008">         rv = imapFolder-&gt;GetAutoSyncStateObj(getter_AddRefs(autoSyncState));</span>
<a href="#l3.1009"></a><span id="l3.1009" class="difflineminus">-        NS_ASSERTION(autoSyncState, &quot;*** nsAutoSyncState shouldn't be NULL, check owner folder&quot;);</span>
<a href="#l3.1010"></a><span id="l3.1010" class="difflineplus">+        NS_ASSERTION(</span>
<a href="#l3.1011"></a><span id="l3.1011" class="difflineplus">+            autoSyncState,</span>
<a href="#l3.1012"></a><span id="l3.1012" class="difflineplus">+            &quot;*** nsAutoSyncState shouldn't be NULL, check owner folder&quot;);</span>
<a href="#l3.1013"></a><span id="l3.1013"> </span>
<a href="#l3.1014"></a><span id="l3.1014">         // shouldn't happen but let's be defensive here</span>
<a href="#l3.1015"></a><span id="l3.1015" class="difflineminus">-        if (!autoSyncState)</span>
<a href="#l3.1016"></a><span id="l3.1016" class="difflineminus">-          continue;</span>
<a href="#l3.1017"></a><span id="l3.1017" class="difflineplus">+        if (!autoSyncState) continue;</span>
<a href="#l3.1018"></a><span id="l3.1018"> </span>
<a href="#l3.1019"></a><span id="l3.1019">         int32_t state;</span>
<a href="#l3.1020"></a><span id="l3.1020">         rv = autoSyncState-&gt;GetState(&amp;state);</span>
<a href="#l3.1021"></a><span id="l3.1021"> </span>
<a href="#l3.1022"></a><span id="l3.1022" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; nsAutoSyncState::stCompletedIdle == state)</span>
<a href="#l3.1023"></a><span id="l3.1023" class="difflineminus">-        {</span>
<a href="#l3.1024"></a><span id="l3.1024" class="difflineminus">-          // ensure that we wait for at least nsMsgIncomingServer::BiffMinutes between</span>
<a href="#l3.1025"></a><span id="l3.1025" class="difflineminus">-          // each update of the same folder</span>
<a href="#l3.1026"></a><span id="l3.1026" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; nsAutoSyncState::stCompletedIdle == state) {</span>
<a href="#l3.1027"></a><span id="l3.1027" class="difflineplus">+          // ensure that we wait for at least nsMsgIncomingServer::BiffMinutes</span>
<a href="#l3.1028"></a><span id="l3.1028" class="difflineplus">+          // between each update of the same folder</span>
<a href="#l3.1029"></a><span id="l3.1029">           PRTime lastUpdateTime;</span>
<a href="#l3.1030"></a><span id="l3.1030">           rv = autoSyncState-&gt;GetLastUpdateTime(&amp;lastUpdateTime);</span>
<a href="#l3.1031"></a><span id="l3.1031" class="difflineminus">-          PRTime span = GetUpdateIntervalFor(autoSyncState) * (PR_USEC_PER_SEC * 60UL);</span>
<a href="#l3.1032"></a><span id="l3.1032" class="difflineminus">-          if ( NS_SUCCEEDED(rv) &amp;&amp; ((lastUpdateTime + span) &lt; PR_Now()) )</span>
<a href="#l3.1033"></a><span id="l3.1033" class="difflineminus">-          {</span>
<a href="#l3.1034"></a><span id="l3.1034" class="difflineminus">-            if (mUpdateQ.IndexOf(autoSyncState) == -1)</span>
<a href="#l3.1035"></a><span id="l3.1035" class="difflineminus">-            {</span>
<a href="#l3.1036"></a><span id="l3.1036" class="difflineplus">+          PRTime span =</span>
<a href="#l3.1037"></a><span id="l3.1037" class="difflineplus">+              GetUpdateIntervalFor(autoSyncState) * (PR_USEC_PER_SEC * 60UL);</span>
<a href="#l3.1038"></a><span id="l3.1038" class="difflineplus">+          if (NS_SUCCEEDED(rv) &amp;&amp; ((lastUpdateTime + span) &lt; PR_Now())) {</span>
<a href="#l3.1039"></a><span id="l3.1039" class="difflineplus">+            if (mUpdateQ.IndexOf(autoSyncState) == -1) {</span>
<a href="#l3.1040"></a><span id="l3.1040">               mUpdateQ.AppendObject(autoSyncState);</span>
<a href="#l3.1041"></a><span id="l3.1041">               if (folder)</span>
<a href="#l3.1042"></a><span id="l3.1042" class="difflineminus">-                NOTIFY_LISTENERS(OnFolderAddedIntoQ, (nsIAutoSyncMgrListener::UpdateQueue, folder));</span>
<a href="#l3.1043"></a><span id="l3.1043" class="difflineplus">+                NOTIFY_LISTENERS(OnFolderAddedIntoQ,</span>
<a href="#l3.1044"></a><span id="l3.1044" class="difflineplus">+                                 (nsIAutoSyncMgrListener::UpdateQueue, folder));</span>
<a href="#l3.1045"></a><span id="l3.1045">             }</span>
<a href="#l3.1046"></a><span id="l3.1046">           }</span>
<a href="#l3.1047"></a><span id="l3.1047">         }</span>
<a href="#l3.1048"></a><span id="l3.1048"> </span>
<a href="#l3.1049"></a><span id="l3.1049">         // check last sync time</span>
<a href="#l3.1050"></a><span id="l3.1050">         PRTime lastSyncTime;</span>
<a href="#l3.1051"></a><span id="l3.1051">         rv = autoSyncState-&gt;GetLastSyncTime(&amp;lastSyncTime);</span>
<a href="#l3.1052"></a><span id="l3.1052" class="difflineminus">-        if ( NS_SUCCEEDED(rv) &amp;&amp; ((lastSyncTime + kAutoSyncFreq) &lt; PR_Now()) )</span>
<a href="#l3.1053"></a><span id="l3.1053" class="difflineminus">-        {</span>
<a href="#l3.1054"></a><span id="l3.1054" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; ((lastSyncTime + kAutoSyncFreq) &lt; PR_Now())) {</span>
<a href="#l3.1055"></a><span id="l3.1055">           // add this folder into discovery queue to process existing headers</span>
<a href="#l3.1056"></a><span id="l3.1056">           // and discover messages not downloaded yet</span>
<a href="#l3.1057"></a><span id="l3.1057" class="difflineminus">-          if (mDiscoveryQ.IndexOf(autoSyncState) == -1)</span>
<a href="#l3.1058"></a><span id="l3.1058" class="difflineminus">-          {</span>
<a href="#l3.1059"></a><span id="l3.1059" class="difflineplus">+          if (mDiscoveryQ.IndexOf(autoSyncState) == -1) {</span>
<a href="#l3.1060"></a><span id="l3.1060">             mDiscoveryQ.AppendObject(autoSyncState);</span>
<a href="#l3.1061"></a><span id="l3.1061">             if (folder)</span>
<a href="#l3.1062"></a><span id="l3.1062" class="difflineminus">-              NOTIFY_LISTENERS(OnFolderAddedIntoQ, (nsIAutoSyncMgrListener::DiscoveryQueue, folder));</span>
<a href="#l3.1063"></a><span id="l3.1063" class="difflineplus">+              NOTIFY_LISTENERS(</span>
<a href="#l3.1064"></a><span id="l3.1064" class="difflineplus">+                  OnFolderAddedIntoQ,</span>
<a href="#l3.1065"></a><span id="l3.1065" class="difflineplus">+                  (nsIAutoSyncMgrListener::DiscoveryQueue, folder));</span>
<a href="#l3.1066"></a><span id="l3.1066">           }</span>
<a href="#l3.1067"></a><span id="l3.1067">         }</span>
<a href="#l3.1068"></a><span id="l3.1068" class="difflineminus">-      }//endfor</span>
<a href="#l3.1069"></a><span id="l3.1069" class="difflineminus">-    }//endif</span>
<a href="#l3.1070"></a><span id="l3.1070" class="difflineminus">-  }//endfor</span>
<a href="#l3.1071"></a><span id="l3.1071" class="difflineplus">+      }  // endfor</span>
<a href="#l3.1072"></a><span id="l3.1072" class="difflineplus">+    }    // endif</span>
<a href="#l3.1073"></a><span id="l3.1073" class="difflineplus">+  }      // endfor</span>
<a href="#l3.1074"></a><span id="l3.1074"> </span>
<a href="#l3.1075"></a><span id="l3.1075">   // lazily create the timer if there is something to process in the queue</span>
<a href="#l3.1076"></a><span id="l3.1076">   // when timer is done, it will self destruct</span>
<a href="#l3.1077"></a><span id="l3.1077">   StartTimerIfNeeded();</span>
<a href="#l3.1078"></a><span id="l3.1078"> </span>
<a href="#l3.1079"></a><span id="l3.1079">   return rv;</span>
<a href="#l3.1080"></a><span id="l3.1080"> }</span>
<a href="#l3.1081"></a><span id="l3.1081"> </span>
<a href="#l3.1082"></a><span id="l3.1082"> /**</span>
<a href="#l3.1083"></a><span id="l3.1083">  * Places the given folder into the priority queue based on active</span>
<a href="#l3.1084"></a><span id="l3.1084">  * strategy function.</span>
<a href="#l3.1085"></a><span id="l3.1085">  */</span>
<a href="#l3.1086"></a><span id="l3.1086" class="difflineminus">-void nsAutoSyncManager::ScheduleFolderForOfflineDownload(nsIAutoSyncState *aAutoSyncStateObj)</span>
<a href="#l3.1087"></a><span id="l3.1087" class="difflineminus">-{</span>
<a href="#l3.1088"></a><span id="l3.1088" class="difflineminus">-  if (aAutoSyncStateObj &amp;&amp; (mPriorityQ.IndexOf(aAutoSyncStateObj) == -1))</span>
<a href="#l3.1089"></a><span id="l3.1089" class="difflineminus">-  {</span>
<a href="#l3.1090"></a><span id="l3.1090" class="difflineplus">+void nsAutoSyncManager::ScheduleFolderForOfflineDownload(</span>
<a href="#l3.1091"></a><span id="l3.1091" class="difflineplus">+    nsIAutoSyncState *aAutoSyncStateObj) {</span>
<a href="#l3.1092"></a><span id="l3.1092" class="difflineplus">+  if (aAutoSyncStateObj &amp;&amp; (mPriorityQ.IndexOf(aAutoSyncStateObj) == -1)) {</span>
<a href="#l3.1093"></a><span id="l3.1093">     nsCOMPtr&lt;nsIAutoSyncFolderStrategy&gt; folStrategy;</span>
<a href="#l3.1094"></a><span id="l3.1094">     GetFolderStrategy(getter_AddRefs(folStrategy));</span>
<a href="#l3.1095"></a><span id="l3.1095"> </span>
<a href="#l3.1096"></a><span id="l3.1096" class="difflineminus">-    if (mPriorityQ.Count() &lt;= 0)</span>
<a href="#l3.1097"></a><span id="l3.1097" class="difflineminus">-    {</span>
<a href="#l3.1098"></a><span id="l3.1098" class="difflineplus">+    if (mPriorityQ.Count() &lt;= 0) {</span>
<a href="#l3.1099"></a><span id="l3.1099">       // make sure that we don't insert a folder excluded by the given strategy</span>
<a href="#l3.1100"></a><span id="l3.1100">       nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.1101"></a><span id="l3.1101">       aAutoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l3.1102"></a><span id="l3.1102" class="difflineminus">-      if (folder)</span>
<a href="#l3.1103"></a><span id="l3.1103" class="difflineminus">-      {</span>
<a href="#l3.1104"></a><span id="l3.1104" class="difflineplus">+      if (folder) {</span>
<a href="#l3.1105"></a><span id="l3.1105">         bool excluded = false;</span>
<a href="#l3.1106"></a><span id="l3.1106" class="difflineminus">-        if (folStrategy)</span>
<a href="#l3.1107"></a><span id="l3.1107" class="difflineminus">-          folStrategy-&gt;IsExcluded(folder, &amp;excluded);</span>
<a href="#l3.1108"></a><span id="l3.1108" class="difflineplus">+        if (folStrategy) folStrategy-&gt;IsExcluded(folder, &amp;excluded);</span>
<a href="#l3.1109"></a><span id="l3.1109"> </span>
<a href="#l3.1110"></a><span id="l3.1110" class="difflineminus">-        if (!excluded)</span>
<a href="#l3.1111"></a><span id="l3.1111" class="difflineminus">-        {</span>
<a href="#l3.1112"></a><span id="l3.1112" class="difflineminus">-          mPriorityQ.AppendObject(aAutoSyncStateObj); // insert into the first spot</span>
<a href="#l3.1113"></a><span id="l3.1113" class="difflineminus">-          NOTIFY_LISTENERS(OnFolderAddedIntoQ, (nsIAutoSyncMgrListener::PriorityQueue, folder));</span>
<a href="#l3.1114"></a><span id="l3.1114" class="difflineplus">+        if (!excluded) {</span>
<a href="#l3.1115"></a><span id="l3.1115" class="difflineplus">+          mPriorityQ.AppendObject(</span>
<a href="#l3.1116"></a><span id="l3.1116" class="difflineplus">+              aAutoSyncStateObj);  // insert into the first spot</span>
<a href="#l3.1117"></a><span id="l3.1117" class="difflineplus">+          NOTIFY_LISTENERS(OnFolderAddedIntoQ,</span>
<a href="#l3.1118"></a><span id="l3.1118" class="difflineplus">+                           (nsIAutoSyncMgrListener::PriorityQueue, folder));</span>
<a href="#l3.1119"></a><span id="l3.1119">         }</span>
<a href="#l3.1120"></a><span id="l3.1120">       }</span>
<a href="#l3.1121"></a><span id="l3.1121" class="difflineminus">-    }</span>
<a href="#l3.1122"></a><span id="l3.1122" class="difflineminus">-    else</span>
<a href="#l3.1123"></a><span id="l3.1123" class="difflineminus">-    {</span>
<a href="#l3.1124"></a><span id="l3.1124" class="difflineplus">+    } else {</span>
<a href="#l3.1125"></a><span id="l3.1125">       // find the right spot for the given folder</span>
<a href="#l3.1126"></a><span id="l3.1126">       uint32_t qidx = mPriorityQ.Count();</span>
<a href="#l3.1127"></a><span id="l3.1127" class="difflineminus">-      while (qidx &gt; 0)</span>
<a href="#l3.1128"></a><span id="l3.1128" class="difflineminus">-      {</span>
<a href="#l3.1129"></a><span id="l3.1129" class="difflineplus">+      while (qidx &gt; 0) {</span>
<a href="#l3.1130"></a><span id="l3.1130">         --qidx;</span>
<a href="#l3.1131"></a><span id="l3.1131"> </span>
<a href="#l3.1132"></a><span id="l3.1132">         nsCOMPtr&lt;nsIMsgFolder&gt; folderA, folderB;</span>
<a href="#l3.1133"></a><span id="l3.1133">         mPriorityQ[qidx]-&gt;GetOwnerFolder(getter_AddRefs(folderA));</span>
<a href="#l3.1134"></a><span id="l3.1134">         aAutoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folderB));</span>
<a href="#l3.1135"></a><span id="l3.1135"> </span>
<a href="#l3.1136"></a><span id="l3.1136">         bool excluded = false;</span>
<a href="#l3.1137"></a><span id="l3.1137" class="difflineminus">-        if (folderB &amp;&amp; folStrategy)</span>
<a href="#l3.1138"></a><span id="l3.1138" class="difflineminus">-          folStrategy-&gt;IsExcluded(folderB, &amp;excluded);</span>
<a href="#l3.1139"></a><span id="l3.1139" class="difflineplus">+        if (folderB &amp;&amp; folStrategy) folStrategy-&gt;IsExcluded(folderB, &amp;excluded);</span>
<a href="#l3.1140"></a><span id="l3.1140"> </span>
<a href="#l3.1141"></a><span id="l3.1141" class="difflineminus">-        if (excluded)</span>
<a href="#l3.1142"></a><span id="l3.1142" class="difflineminus">-          break;</span>
<a href="#l3.1143"></a><span id="l3.1143" class="difflineplus">+        if (excluded) break;</span>
<a href="#l3.1144"></a><span id="l3.1144"> </span>
<a href="#l3.1145"></a><span id="l3.1145" class="difflineminus">-        nsAutoSyncStrategyDecisionType decision = nsAutoSyncStrategyDecisions::Same;</span>
<a href="#l3.1146"></a><span id="l3.1146" class="difflineplus">+        nsAutoSyncStrategyDecisionType decision =</span>
<a href="#l3.1147"></a><span id="l3.1147" class="difflineplus">+            nsAutoSyncStrategyDecisions::Same;</span>
<a href="#l3.1148"></a><span id="l3.1148">         if (folderA &amp;&amp; folderB &amp;&amp; folStrategy)</span>
<a href="#l3.1149"></a><span id="l3.1149">           folStrategy-&gt;Sort(folderA, folderB, &amp;decision);</span>
<a href="#l3.1150"></a><span id="l3.1150"> </span>
<a href="#l3.1151"></a><span id="l3.1151">         if (decision == nsAutoSyncStrategyDecisions::Higher &amp;&amp; 0 == qidx)</span>
<a href="#l3.1152"></a><span id="l3.1152">           mPriorityQ.InsertObjectAt(aAutoSyncStateObj, 0);</span>
<a href="#l3.1153"></a><span id="l3.1153">         else if (decision == nsAutoSyncStrategyDecisions::Higher)</span>
<a href="#l3.1154"></a><span id="l3.1154">           continue;</span>
<a href="#l3.1155"></a><span id="l3.1155">         else if (decision == nsAutoSyncStrategyDecisions::Lower)</span>
<a href="#l3.1156"></a><span id="l3.1156" class="difflineminus">-          mPriorityQ.InsertObjectAt(aAutoSyncStateObj, qidx+1);</span>
<a href="#l3.1157"></a><span id="l3.1157" class="difflineminus">-        else //  decision == nsAutoSyncStrategyDecisions::Same</span>
<a href="#l3.1158"></a><span id="l3.1158" class="difflineplus">+          mPriorityQ.InsertObjectAt(aAutoSyncStateObj, qidx + 1);</span>
<a href="#l3.1159"></a><span id="l3.1159" class="difflineplus">+        else  //  decision == nsAutoSyncStrategyDecisions::Same</span>
<a href="#l3.1160"></a><span id="l3.1160">           mPriorityQ.InsertObjectAt(aAutoSyncStateObj, qidx);</span>
<a href="#l3.1161"></a><span id="l3.1161"> </span>
<a href="#l3.1162"></a><span id="l3.1162" class="difflineminus">-        NOTIFY_LISTENERS(OnFolderAddedIntoQ, (nsIAutoSyncMgrListener::PriorityQueue, folderB));</span>
<a href="#l3.1163"></a><span id="l3.1163" class="difflineplus">+        NOTIFY_LISTENERS(OnFolderAddedIntoQ,</span>
<a href="#l3.1164"></a><span id="l3.1164" class="difflineplus">+                         (nsIAutoSyncMgrListener::PriorityQueue, folderB));</span>
<a href="#l3.1165"></a><span id="l3.1165">         break;</span>
<a href="#l3.1166"></a><span id="l3.1166" class="difflineminus">-      }//endwhile</span>
<a href="#l3.1167"></a><span id="l3.1167" class="difflineplus">+      }  // endwhile</span>
<a href="#l3.1168"></a><span id="l3.1168">     }</span>
<a href="#l3.1169"></a><span id="l3.1169" class="difflineminus">-  }//endif</span>
<a href="#l3.1170"></a><span id="l3.1170" class="difflineplus">+  }  // endif</span>
<a href="#l3.1171"></a><span id="l3.1171"> }</span>
<a href="#l3.1172"></a><span id="l3.1172"> </span>
<a href="#l3.1173"></a><span id="l3.1173"> /**</span>
<a href="#l3.1174"></a><span id="l3.1174">  * Zero aSizeLimit means no limit</span>
<a href="#l3.1175"></a><span id="l3.1175">  */</span>
<a href="#l3.1176"></a><span id="l3.1176" class="difflineminus">-nsresult nsAutoSyncManager::DownloadMessagesForOffline(nsIAutoSyncState *aAutoSyncStateObj, uint32_t aSizeLimit)</span>
<a href="#l3.1177"></a><span id="l3.1177" class="difflineminus">-{</span>
<a href="#l3.1178"></a><span id="l3.1178" class="difflineminus">-  if (!aAutoSyncStateObj)</span>
<a href="#l3.1179"></a><span id="l3.1179" class="difflineminus">-    return NS_ERROR_INVALID_ARG;</span>
<a href="#l3.1180"></a><span id="l3.1180" class="difflineplus">+nsresult nsAutoSyncManager::DownloadMessagesForOffline(</span>
<a href="#l3.1181"></a><span id="l3.1181" class="difflineplus">+    nsIAutoSyncState *aAutoSyncStateObj, uint32_t aSizeLimit) {</span>
<a href="#l3.1182"></a><span id="l3.1182" class="difflineplus">+  if (!aAutoSyncStateObj) return NS_ERROR_INVALID_ARG;</span>
<a href="#l3.1183"></a><span id="l3.1183"> </span>
<a href="#l3.1184"></a><span id="l3.1184">   int32_t count;</span>
<a href="#l3.1185"></a><span id="l3.1185">   nsresult rv = aAutoSyncStateObj-&gt;GetPendingMessageCount(&amp;count);</span>
<a href="#l3.1186"></a><span id="l3.1186">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.1187"></a><span id="l3.1187"> </span>
<a href="#l3.1188"></a><span id="l3.1188">   // special case: no more message to download for this folder:</span>
<a href="#l3.1189"></a><span id="l3.1189">   // see HandleDownloadErrorFor for recovery policy</span>
<a href="#l3.1190"></a><span id="l3.1190" class="difflineminus">-  if (!count)</span>
<a href="#l3.1191"></a><span id="l3.1191" class="difflineminus">-    return NS_ERROR_NOT_AVAILABLE;</span>
<a href="#l3.1192"></a><span id="l3.1192" class="difflineplus">+  if (!count) return NS_ERROR_NOT_AVAILABLE;</span>
<a href="#l3.1193"></a><span id="l3.1193"> </span>
<a href="#l3.1194"></a><span id="l3.1194">   nsCOMPtr&lt;nsIMutableArray&gt; messagesToDownload;</span>
<a href="#l3.1195"></a><span id="l3.1195">   uint32_t totalSize = 0;</span>
<a href="#l3.1196"></a><span id="l3.1196" class="difflineminus">-  rv = aAutoSyncStateObj-&gt;GetNextGroupOfMessages(mGroupSize, &amp;totalSize, getter_AddRefs(messagesToDownload));</span>
<a href="#l3.1197"></a><span id="l3.1197" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l3.1198"></a><span id="l3.1198" class="difflineplus">+  rv = aAutoSyncStateObj-&gt;GetNextGroupOfMessages(</span>
<a href="#l3.1199"></a><span id="l3.1199" class="difflineplus">+      mGroupSize, &amp;totalSize, getter_AddRefs(messagesToDownload));</span>
<a href="#l3.1200"></a><span id="l3.1200" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.1201"></a><span id="l3.1201"> </span>
<a href="#l3.1202"></a><span id="l3.1202">   // there are pending messages but the cumulative size is zero:</span>
<a href="#l3.1203"></a><span id="l3.1203">   // treat as special case.</span>
<a href="#l3.1204"></a><span id="l3.1204">   // Note that although it shouldn't happen, we know that sometimes</span>
<a href="#l3.1205"></a><span id="l3.1205">   // imap servers manifest messages as zero length. By returning</span>
<a href="#l3.1206"></a><span id="l3.1206">   // NS_ERROR_NOT_AVAILABLE we cause this folder to be removed from</span>
<a href="#l3.1207"></a><span id="l3.1207">   // the priority queue temporarily (until the next idle or next update)</span>
<a href="#l3.1208"></a><span id="l3.1208">   // in an effort to prevent it blocking other folders of the same account</span>
<a href="#l3.1209"></a><span id="l3.1209">   // being synced.</span>
<a href="#l3.1210"></a><span id="l3.1210" class="difflineminus">-  if (!totalSize)</span>
<a href="#l3.1211"></a><span id="l3.1211" class="difflineminus">-    return NS_ERROR_NOT_AVAILABLE;</span>
<a href="#l3.1212"></a><span id="l3.1212" class="difflineplus">+  if (!totalSize) return NS_ERROR_NOT_AVAILABLE;</span>
<a href="#l3.1213"></a><span id="l3.1213"> </span>
<a href="#l3.1214"></a><span id="l3.1214">   // ensure that we don't exceed the given size limit for this particular group</span>
<a href="#l3.1215"></a><span id="l3.1215" class="difflineminus">-  if (aSizeLimit &amp;&amp; aSizeLimit &lt; totalSize)</span>
<a href="#l3.1216"></a><span id="l3.1216" class="difflineminus">-    return NS_ERROR_FAILURE;</span>
<a href="#l3.1217"></a><span id="l3.1217" class="difflineplus">+  if (aSizeLimit &amp;&amp; aSizeLimit &lt; totalSize) return NS_ERROR_FAILURE;</span>
<a href="#l3.1218"></a><span id="l3.1218"> </span>
<a href="#l3.1219"></a><span id="l3.1219">   uint32_t length;</span>
<a href="#l3.1220"></a><span id="l3.1220">   rv = messagesToDownload-&gt;GetLength(&amp;length);</span>
<a href="#l3.1221"></a><span id="l3.1221" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; length &gt; 0)</span>
<a href="#l3.1222"></a><span id="l3.1222" class="difflineminus">-  {</span>
<a href="#l3.1223"></a><span id="l3.1223" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; length &gt; 0) {</span>
<a href="#l3.1224"></a><span id="l3.1224">     rv = aAutoSyncStateObj-&gt;DownloadMessagesForOffline(messagesToDownload);</span>
<a href="#l3.1225"></a><span id="l3.1225"> </span>
<a href="#l3.1226"></a><span id="l3.1226">     int32_t totalCount;</span>
<a href="#l3.1227"></a><span id="l3.1227" class="difflineminus">-    (void) aAutoSyncStateObj-&gt;GetTotalMessageCount(&amp;totalCount);</span>
<a href="#l3.1228"></a><span id="l3.1228" class="difflineplus">+    (void)aAutoSyncStateObj-&gt;GetTotalMessageCount(&amp;totalCount);</span>
<a href="#l3.1229"></a><span id="l3.1229"> </span>
<a href="#l3.1230"></a><span id="l3.1230">     nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.1231"></a><span id="l3.1231">     aAutoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l3.1232"></a><span id="l3.1232">     if (NS_SUCCEEDED(rv) &amp;&amp; folder)</span>
<a href="#l3.1233"></a><span id="l3.1233">       NOTIFY_LISTENERS(OnDownloadStarted, (folder, length, totalCount));</span>
<a href="#l3.1234"></a><span id="l3.1234">   }</span>
<a href="#l3.1235"></a><span id="l3.1235"> </span>
<a href="#l3.1236"></a><span id="l3.1236">   return rv;</span>
<a href="#l3.1237"></a><span id="l3.1237"> }</span>
<a href="#l3.1238"></a><span id="l3.1238"> </span>
<a href="#l3.1239"></a><span id="l3.1239" class="difflineplus">+// clang-format off</span>
<a href="#l3.1240"></a><span id="l3.1240"> /**</span>
<a href="#l3.1241"></a><span id="l3.1241" class="difflineminus">- * Assuming that the download operation on the given folder has been failed at least once,</span>
<a href="#l3.1242"></a><span id="l3.1242" class="difflineminus">- * execute these steps:</span>
<a href="#l3.1243"></a><span id="l3.1243" class="difflineplus">+ * Assuming that the download operation on the given folder has been failed at</span>
<a href="#l3.1244"></a><span id="l3.1244" class="difflineplus">+ * least once, execute these steps:</span>
<a href="#l3.1245"></a><span id="l3.1245">  *  - put the auto-sync state into ready-to-download mode</span>
<a href="#l3.1246"></a><span id="l3.1246" class="difflineminus">- *  - rollback the message offset so we can try the same group again (unless the retry</span>
<a href="#l3.1247"></a><span id="l3.1247" class="difflineminus">- *     count is reached to the given limit)</span>
<a href="#l3.1248"></a><span id="l3.1248" class="difflineplus">+ *  - rollback the message offset so we can try the same group again (unless the</span>
<a href="#l3.1249"></a><span id="l3.1249" class="difflineplus">+ *    retry count is reached to the given limit)</span>
<a href="#l3.1250"></a><span id="l3.1250">  *  - if parallel model is active, wait to be resumed by the next idle</span>
<a href="#l3.1251"></a><span id="l3.1251" class="difflineminus">- *  - if chained model is active, search the priority queue to find a sibling to continue</span>
<a href="#l3.1252"></a><span id="l3.1252" class="difflineminus">- *    with.</span>
<a href="#l3.1253"></a><span id="l3.1253" class="difflineplus">+ *  - if chained model is active, search the priority queue to find a sibling to</span>
<a href="#l3.1254"></a><span id="l3.1254" class="difflineplus">+ *    continue with.</span>
<a href="#l3.1255"></a><span id="l3.1255">  */</span>
<a href="#l3.1256"></a><span id="l3.1256" class="difflineminus">-nsresult nsAutoSyncManager::HandleDownloadErrorFor(nsIAutoSyncState *aAutoSyncStateObj,</span>
<a href="#l3.1257"></a><span id="l3.1257" class="difflineminus">-                                                   const nsresult error)</span>
<a href="#l3.1258"></a><span id="l3.1258" class="difflineminus">-{</span>
<a href="#l3.1259"></a><span id="l3.1259" class="difflineminus">-  if (!aAutoSyncStateObj)</span>
<a href="#l3.1260"></a><span id="l3.1260" class="difflineminus">-    return NS_ERROR_INVALID_ARG;</span>
<a href="#l3.1261"></a><span id="l3.1261" class="difflineplus">+// clang-format on</span>
<a href="#l3.1262"></a><span id="l3.1262" class="difflineplus">+nsresult nsAutoSyncManager::HandleDownloadErrorFor(</span>
<a href="#l3.1263"></a><span id="l3.1263" class="difflineplus">+    nsIAutoSyncState *aAutoSyncStateObj, const nsresult error) {</span>
<a href="#l3.1264"></a><span id="l3.1264" class="difflineplus">+  if (!aAutoSyncStateObj) return NS_ERROR_INVALID_ARG;</span>
<a href="#l3.1265"></a><span id="l3.1265"> </span>
<a href="#l3.1266"></a><span id="l3.1266">   // ensure that an error occurred</span>
<a href="#l3.1267"></a><span id="l3.1267" class="difflineminus">-  if (NS_SUCCEEDED(error))</span>
<a href="#l3.1268"></a><span id="l3.1268" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.1269"></a><span id="l3.1269" class="difflineplus">+  if (NS_SUCCEEDED(error)) return NS_OK;</span>
<a href="#l3.1270"></a><span id="l3.1270"> </span>
<a href="#l3.1271"></a><span id="l3.1271" class="difflineminus">-  // NS_ERROR_NOT_AVAILABLE is a special case/error happens when the queued folder</span>
<a href="#l3.1272"></a><span id="l3.1272" class="difflineminus">-  // doesn't have any message to download (see bug 457342). In such case we shouldn't</span>
<a href="#l3.1273"></a><span id="l3.1273" class="difflineminus">-  // retry the current message group, nor notify listeners. Simply continuing with the</span>
<a href="#l3.1274"></a><span id="l3.1274" class="difflineminus">-  // next sibling in the priority queue would suffice.</span>
<a href="#l3.1275"></a><span id="l3.1275" class="difflineplus">+  // NS_ERROR_NOT_AVAILABLE is a special case/error happens when the queued</span>
<a href="#l3.1276"></a><span id="l3.1276" class="difflineplus">+  // folder doesn't have any message to download (see bug 457342). In such case</span>
<a href="#l3.1277"></a><span id="l3.1277" class="difflineplus">+  // we shouldn't retry the current message group, nor notify listeners. Simply</span>
<a href="#l3.1278"></a><span id="l3.1278" class="difflineplus">+  // continuing with the next sibling in the priority queue would suffice.</span>
<a href="#l3.1279"></a><span id="l3.1279"> </span>
<a href="#l3.1280"></a><span id="l3.1280" class="difflineminus">-  if (NS_ERROR_NOT_AVAILABLE != error)</span>
<a href="#l3.1281"></a><span id="l3.1281" class="difflineminus">-  {</span>
<a href="#l3.1282"></a><span id="l3.1282" class="difflineplus">+  if (NS_ERROR_NOT_AVAILABLE != error) {</span>
<a href="#l3.1283"></a><span id="l3.1283">     // force the auto-sync state to try downloading the same group at least</span>
<a href="#l3.1284"></a><span id="l3.1284">     // kGroupRetryCount times before it moves to the next one</span>
<a href="#l3.1285"></a><span id="l3.1285">     aAutoSyncStateObj-&gt;TryCurrentGroupAgain(kGroupRetryCount);</span>
<a href="#l3.1286"></a><span id="l3.1286"> </span>
<a href="#l3.1287"></a><span id="l3.1287">     nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.1288"></a><span id="l3.1288">     aAutoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l3.1289"></a><span id="l3.1289" class="difflineminus">-    if (folder)</span>
<a href="#l3.1290"></a><span id="l3.1290" class="difflineminus">-      NOTIFY_LISTENERS(OnDownloadError, (folder));</span>
<a href="#l3.1291"></a><span id="l3.1291" class="difflineplus">+    if (folder) NOTIFY_LISTENERS(OnDownloadError, (folder));</span>
<a href="#l3.1292"></a><span id="l3.1292">   }</span>
<a href="#l3.1293"></a><span id="l3.1293"> </span>
<a href="#l3.1294"></a><span id="l3.1294">   // if parallel model, don't do anything else</span>
<a href="#l3.1295"></a><span id="l3.1295"> </span>
<a href="#l3.1296"></a><span id="l3.1296" class="difflineminus">-  if (mDownloadModel == dmChained)</span>
<a href="#l3.1297"></a><span id="l3.1297" class="difflineminus">-  {</span>
<a href="#l3.1298"></a><span id="l3.1298" class="difflineplus">+  if (mDownloadModel == dmChained) {</span>
<a href="#l3.1299"></a><span id="l3.1299">     // switch to the next folder in the chain and continue downloading</span>
<a href="#l3.1300"></a><span id="l3.1300">     nsIAutoSyncState *autoSyncStateObj = aAutoSyncStateObj;</span>
<a href="#l3.1301"></a><span id="l3.1301">     nsIAutoSyncState *nextAutoSyncStateObj = nullptr;</span>
<a href="#l3.1302"></a><span id="l3.1302" class="difflineminus">-    while ( (nextAutoSyncStateObj = GetNextSibling(mPriorityQ, autoSyncStateObj)) )</span>
<a href="#l3.1303"></a><span id="l3.1303" class="difflineminus">-    {</span>
<a href="#l3.1304"></a><span id="l3.1304" class="difflineplus">+    while (</span>
<a href="#l3.1305"></a><span id="l3.1305" class="difflineplus">+        (nextAutoSyncStateObj = GetNextSibling(mPriorityQ, autoSyncStateObj))) {</span>
<a href="#l3.1306"></a><span id="l3.1306">       autoSyncStateObj = nextAutoSyncStateObj;</span>
<a href="#l3.1307"></a><span id="l3.1307">       nsresult rv = DownloadMessagesForOffline(autoSyncStateObj);</span>
<a href="#l3.1308"></a><span id="l3.1308" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l3.1309"></a><span id="l3.1309" class="difflineminus">-        break;</span>
<a href="#l3.1310"></a><span id="l3.1310" class="difflineplus">+      if (NS_SUCCEEDED(rv)) break;</span>
<a href="#l3.1311"></a><span id="l3.1311">       if (rv == NS_ERROR_NOT_AVAILABLE)</span>
<a href="#l3.1312"></a><span id="l3.1312">         // next folder in the chain also doesn't have any message to download</span>
<a href="#l3.1313"></a><span id="l3.1313">         // switch to next one if any</span>
<a href="#l3.1314"></a><span id="l3.1314">         continue;</span>
<a href="#l3.1315"></a><span id="l3.1315">       autoSyncStateObj-&gt;TryCurrentGroupAgain(kGroupRetryCount);</span>
<a href="#l3.1316"></a><span id="l3.1316">     }</span>
<a href="#l3.1317"></a><span id="l3.1317">   }</span>
<a href="#l3.1318"></a><span id="l3.1318"> </span>
<a href="#l3.1319"></a><span id="l3.1319">   return NS_OK;</span>
<a href="#l3.1320"></a><span id="l3.1320"> }</span>
<a href="#l3.1321"></a><span id="l3.1321"> </span>
<a href="#l3.1322"></a><span id="l3.1322" class="difflineminus">-uint32_t nsAutoSyncManager::GetUpdateIntervalFor(nsIAutoSyncState *aAutoSyncStateObj)</span>
<a href="#l3.1323"></a><span id="l3.1323" class="difflineminus">-{</span>
<a href="#l3.1324"></a><span id="l3.1324" class="difflineplus">+uint32_t nsAutoSyncManager::GetUpdateIntervalFor(</span>
<a href="#l3.1325"></a><span id="l3.1325" class="difflineplus">+    nsIAutoSyncState *aAutoSyncStateObj) {</span>
<a href="#l3.1326"></a><span id="l3.1326">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.1327"></a><span id="l3.1327">   nsresult rv = aAutoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l3.1328"></a><span id="l3.1328" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l3.1329"></a><span id="l3.1329" class="difflineminus">-    return kDefaultUpdateInterval;</span>
<a href="#l3.1330"></a><span id="l3.1330" class="difflineplus">+  if (NS_FAILED(rv)) return kDefaultUpdateInterval;</span>
<a href="#l3.1331"></a><span id="l3.1331"> </span>
<a href="#l3.1332"></a><span id="l3.1332">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l3.1333"></a><span id="l3.1333">   rv = folder-&gt;GetServer(getter_AddRefs(server));</span>
<a href="#l3.1334"></a><span id="l3.1334" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l3.1335"></a><span id="l3.1335" class="difflineminus">-    return kDefaultUpdateInterval;</span>
<a href="#l3.1336"></a><span id="l3.1336" class="difflineplus">+  if (NS_FAILED(rv)) return kDefaultUpdateInterval;</span>
<a href="#l3.1337"></a><span id="l3.1337"> </span>
<a href="#l3.1338"></a><span id="l3.1338" class="difflineminus">-  if (server)</span>
<a href="#l3.1339"></a><span id="l3.1339" class="difflineminus">-  {</span>
<a href="#l3.1340"></a><span id="l3.1340" class="difflineplus">+  if (server) {</span>
<a href="#l3.1341"></a><span id="l3.1341">     int32_t interval;</span>
<a href="#l3.1342"></a><span id="l3.1342">     rv = server-&gt;GetBiffMinutes(&amp;interval);</span>
<a href="#l3.1343"></a><span id="l3.1343"> </span>
<a href="#l3.1344"></a><span id="l3.1344" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.1345"></a><span id="l3.1345" class="difflineminus">-      return (uint32_t)interval;</span>
<a href="#l3.1346"></a><span id="l3.1346" class="difflineplus">+    if (NS_SUCCEEDED(rv)) return (uint32_t)interval;</span>
<a href="#l3.1347"></a><span id="l3.1347">   }</span>
<a href="#l3.1348"></a><span id="l3.1348"> </span>
<a href="#l3.1349"></a><span id="l3.1349">   return kDefaultUpdateInterval;</span>
<a href="#l3.1350"></a><span id="l3.1350"> }</span>
<a href="#l3.1351"></a><span id="l3.1351"> </span>
<a href="#l3.1352"></a><span id="l3.1352" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::GetGroupSize(uint32_t *aGroupSize)</span>
<a href="#l3.1353"></a><span id="l3.1353" class="difflineminus">-{</span>
<a href="#l3.1354"></a><span id="l3.1354" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::GetGroupSize(uint32_t *aGroupSize) {</span>
<a href="#l3.1355"></a><span id="l3.1355">   NS_ENSURE_ARG_POINTER(aGroupSize);</span>
<a href="#l3.1356"></a><span id="l3.1356">   *aGroupSize = mGroupSize;</span>
<a href="#l3.1357"></a><span id="l3.1357">   return NS_OK;</span>
<a href="#l3.1358"></a><span id="l3.1358"> }</span>
<a href="#l3.1359"></a><span id="l3.1359" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::SetGroupSize(uint32_t aGroupSize)</span>
<a href="#l3.1360"></a><span id="l3.1360" class="difflineminus">-{</span>
<a href="#l3.1361"></a><span id="l3.1361" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::SetGroupSize(uint32_t aGroupSize) {</span>
<a href="#l3.1362"></a><span id="l3.1362">   mGroupSize = aGroupSize ? aGroupSize : kDefaultGroupSize;</span>
<a href="#l3.1363"></a><span id="l3.1363">   return NS_OK;</span>
<a href="#l3.1364"></a><span id="l3.1364"> }</span>
<a href="#l3.1365"></a><span id="l3.1365"> </span>
<a href="#l3.1366"></a><span id="l3.1366" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::GetMsgStrategy(nsIAutoSyncMsgStrategy * *aMsgStrategy)</span>
<a href="#l3.1367"></a><span id="l3.1367" class="difflineminus">-{</span>
<a href="#l3.1368"></a><span id="l3.1368" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::GetMsgStrategy(</span>
<a href="#l3.1369"></a><span id="l3.1369" class="difflineplus">+    nsIAutoSyncMsgStrategy **aMsgStrategy) {</span>
<a href="#l3.1370"></a><span id="l3.1370">   NS_ENSURE_ARG_POINTER(aMsgStrategy);</span>
<a href="#l3.1371"></a><span id="l3.1371"> </span>
<a href="#l3.1372"></a><span id="l3.1372">   // lazily create if it is not done already</span>
<a href="#l3.1373"></a><span id="l3.1373" class="difflineminus">-  if (!mMsgStrategyImpl)</span>
<a href="#l3.1374"></a><span id="l3.1374" class="difflineminus">-  {</span>
<a href="#l3.1375"></a><span id="l3.1375" class="difflineplus">+  if (!mMsgStrategyImpl) {</span>
<a href="#l3.1376"></a><span id="l3.1376">     mMsgStrategyImpl = new nsDefaultAutoSyncMsgStrategy;</span>
<a href="#l3.1377"></a><span id="l3.1377" class="difflineminus">-    if (!mMsgStrategyImpl)</span>
<a href="#l3.1378"></a><span id="l3.1378" class="difflineminus">-      return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l3.1379"></a><span id="l3.1379" class="difflineplus">+    if (!mMsgStrategyImpl) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l3.1380"></a><span id="l3.1380">   }</span>
<a href="#l3.1381"></a><span id="l3.1381"> </span>
<a href="#l3.1382"></a><span id="l3.1382">   NS_IF_ADDREF(*aMsgStrategy = mMsgStrategyImpl);</span>
<a href="#l3.1383"></a><span id="l3.1383">   return NS_OK;</span>
<a href="#l3.1384"></a><span id="l3.1384"> }</span>
<a href="#l3.1385"></a><span id="l3.1385" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::SetMsgStrategy(nsIAutoSyncMsgStrategy * aMsgStrategy)</span>
<a href="#l3.1386"></a><span id="l3.1386" class="difflineminus">-{</span>
<a href="#l3.1387"></a><span id="l3.1387" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::SetMsgStrategy(</span>
<a href="#l3.1388"></a><span id="l3.1388" class="difflineplus">+    nsIAutoSyncMsgStrategy *aMsgStrategy) {</span>
<a href="#l3.1389"></a><span id="l3.1389">   mMsgStrategyImpl = aMsgStrategy;</span>
<a href="#l3.1390"></a><span id="l3.1390">   return NS_OK;</span>
<a href="#l3.1391"></a><span id="l3.1391"> }</span>
<a href="#l3.1392"></a><span id="l3.1392"> </span>
<a href="#l3.1393"></a><span id="l3.1393" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::GetFolderStrategy(nsIAutoSyncFolderStrategy * *aFolderStrategy)</span>
<a href="#l3.1394"></a><span id="l3.1394" class="difflineminus">-{</span>
<a href="#l3.1395"></a><span id="l3.1395" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::GetFolderStrategy(</span>
<a href="#l3.1396"></a><span id="l3.1396" class="difflineplus">+    nsIAutoSyncFolderStrategy **aFolderStrategy) {</span>
<a href="#l3.1397"></a><span id="l3.1397">   NS_ENSURE_ARG_POINTER(aFolderStrategy);</span>
<a href="#l3.1398"></a><span id="l3.1398"> </span>
<a href="#l3.1399"></a><span id="l3.1399">   // lazily create if it is not done already</span>
<a href="#l3.1400"></a><span id="l3.1400" class="difflineminus">-  if (!mFolderStrategyImpl)</span>
<a href="#l3.1401"></a><span id="l3.1401" class="difflineminus">-  {</span>
<a href="#l3.1402"></a><span id="l3.1402" class="difflineplus">+  if (!mFolderStrategyImpl) {</span>
<a href="#l3.1403"></a><span id="l3.1403">     mFolderStrategyImpl = new nsDefaultAutoSyncFolderStrategy;</span>
<a href="#l3.1404"></a><span id="l3.1404" class="difflineminus">-    if (!mFolderStrategyImpl)</span>
<a href="#l3.1405"></a><span id="l3.1405" class="difflineminus">-      return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l3.1406"></a><span id="l3.1406" class="difflineplus">+    if (!mFolderStrategyImpl) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l3.1407"></a><span id="l3.1407">   }</span>
<a href="#l3.1408"></a><span id="l3.1408"> </span>
<a href="#l3.1409"></a><span id="l3.1409">   NS_IF_ADDREF(*aFolderStrategy = mFolderStrategyImpl);</span>
<a href="#l3.1410"></a><span id="l3.1410">   return NS_OK;</span>
<a href="#l3.1411"></a><span id="l3.1411"> }</span>
<a href="#l3.1412"></a><span id="l3.1412" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::SetFolderStrategy(nsIAutoSyncFolderStrategy * aFolderStrategy)</span>
<a href="#l3.1413"></a><span id="l3.1413" class="difflineminus">-{</span>
<a href="#l3.1414"></a><span id="l3.1414" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::SetFolderStrategy(</span>
<a href="#l3.1415"></a><span id="l3.1415" class="difflineplus">+    nsIAutoSyncFolderStrategy *aFolderStrategy) {</span>
<a href="#l3.1416"></a><span id="l3.1416">   mFolderStrategyImpl = aFolderStrategy;</span>
<a href="#l3.1417"></a><span id="l3.1417">   return NS_OK;</span>
<a href="#l3.1418"></a><span id="l3.1418"> }</span>
<a href="#l3.1419"></a><span id="l3.1419"> </span>
<a href="#l3.1420"></a><span id="l3.1420"> NS_IMETHODIMP</span>
<a href="#l3.1421"></a><span id="l3.1421" class="difflineminus">-nsAutoSyncManager::DoesMsgFitDownloadCriteria(nsIMsgDBHdr *aMsgHdr, bool *aResult)</span>
<a href="#l3.1422"></a><span id="l3.1422" class="difflineminus">-{</span>
<a href="#l3.1423"></a><span id="l3.1423" class="difflineplus">+nsAutoSyncManager::DoesMsgFitDownloadCriteria(nsIMsgDBHdr *aMsgHdr,</span>
<a href="#l3.1424"></a><span id="l3.1424" class="difflineplus">+                                              bool *aResult) {</span>
<a href="#l3.1425"></a><span id="l3.1425">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l3.1426"></a><span id="l3.1426"> </span>
<a href="#l3.1427"></a><span id="l3.1427">   uint32_t msgFlags = 0;</span>
<a href="#l3.1428"></a><span id="l3.1428">   aMsgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l3.1429"></a><span id="l3.1429"> </span>
<a href="#l3.1430"></a><span id="l3.1430">   // check whether this message is marked imap deleted or not</span>
<a href="#l3.1431"></a><span id="l3.1431">   *aResult = !(msgFlags &amp; nsMsgMessageFlags::IMAPDeleted);</span>
<a href="#l3.1432"></a><span id="l3.1432" class="difflineminus">-  if (!(*aResult))</span>
<a href="#l3.1433"></a><span id="l3.1433" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.1434"></a><span id="l3.1434" class="difflineplus">+  if (!(*aResult)) return NS_OK;</span>
<a href="#l3.1435"></a><span id="l3.1435"> </span>
<a href="#l3.1436"></a><span id="l3.1436">   bool shouldStoreMsgOffline = true;</span>
<a href="#l3.1437"></a><span id="l3.1437">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.1438"></a><span id="l3.1438">   aMsgHdr-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l3.1439"></a><span id="l3.1439" class="difflineminus">-  if (folder)</span>
<a href="#l3.1440"></a><span id="l3.1440" class="difflineminus">-  {</span>
<a href="#l3.1441"></a><span id="l3.1441" class="difflineplus">+  if (folder) {</span>
<a href="#l3.1442"></a><span id="l3.1442">     nsMsgKey msgKey;</span>
<a href="#l3.1443"></a><span id="l3.1443">     nsresult rv = aMsgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l3.1444"></a><span id="l3.1444">     // a cheap way to get the size limit for this folder and make</span>
<a href="#l3.1445"></a><span id="l3.1445">     // sure that we don't have this message offline already</span>
<a href="#l3.1446"></a><span id="l3.1446">     if (NS_SUCCEEDED(rv))</span>
<a href="#l3.1447"></a><span id="l3.1447">       folder-&gt;ShouldStoreMsgOffline(msgKey, &amp;shouldStoreMsgOffline);</span>
<a href="#l3.1448"></a><span id="l3.1448">   }</span>
<a href="#l3.1449"></a><span id="l3.1449"> </span>
<a href="#l3.1450"></a><span id="l3.1450">   *aResult &amp;= shouldStoreMsgOffline;</span>
<a href="#l3.1451"></a><span id="l3.1451"> </span>
<a href="#l3.1452"></a><span id="l3.1452">   return NS_OK;</span>
<a href="#l3.1453"></a><span id="l3.1453"> }</span>
<a href="#l3.1454"></a><span id="l3.1454"> </span>
<a href="#l3.1455"></a><span id="l3.1455" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::OnDownloadQChanged(nsIAutoSyncState *aAutoSyncStateObj)</span>
<a href="#l3.1456"></a><span id="l3.1456" class="difflineminus">-{</span>
<a href="#l3.1457"></a><span id="l3.1457" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::OnDownloadQChanged(</span>
<a href="#l3.1458"></a><span id="l3.1458" class="difflineplus">+    nsIAutoSyncState *aAutoSyncStateObj) {</span>
<a href="#l3.1459"></a><span id="l3.1459">   nsCOMPtr&lt;nsIAutoSyncState&gt; autoSyncStateObj(aAutoSyncStateObj);</span>
<a href="#l3.1460"></a><span id="l3.1460" class="difflineminus">-  if (!autoSyncStateObj)</span>
<a href="#l3.1461"></a><span id="l3.1461" class="difflineminus">-    return NS_ERROR_INVALID_ARG;</span>
<a href="#l3.1462"></a><span id="l3.1462" class="difflineplus">+  if (!autoSyncStateObj) return NS_ERROR_INVALID_ARG;</span>
<a href="#l3.1463"></a><span id="l3.1463"> </span>
<a href="#l3.1464"></a><span id="l3.1464" class="difflineminus">-  if (mPaused)</span>
<a href="#l3.1465"></a><span id="l3.1465" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.1466"></a><span id="l3.1466" class="difflineplus">+  if (mPaused) return NS_OK;</span>
<a href="#l3.1467"></a><span id="l3.1467">   // We want to start downloading immediately unless the folder is excluded.</span>
<a href="#l3.1468"></a><span id="l3.1468">   bool excluded = false;</span>
<a href="#l3.1469"></a><span id="l3.1469">   nsCOMPtr&lt;nsIAutoSyncFolderStrategy&gt; folStrategy;</span>
<a href="#l3.1470"></a><span id="l3.1470">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.1471"></a><span id="l3.1471"> </span>
<a href="#l3.1472"></a><span id="l3.1472">   GetFolderStrategy(getter_AddRefs(folStrategy));</span>
<a href="#l3.1473"></a><span id="l3.1473">   autoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l3.1474"></a><span id="l3.1474"> </span>
<a href="#l3.1475"></a><span id="l3.1475" class="difflineminus">-  if (folder &amp;&amp; folStrategy)</span>
<a href="#l3.1476"></a><span id="l3.1476" class="difflineminus">-    folStrategy-&gt;IsExcluded(folder, &amp;excluded);</span>
<a href="#l3.1477"></a><span id="l3.1477" class="difflineplus">+  if (folder &amp;&amp; folStrategy) folStrategy-&gt;IsExcluded(folder, &amp;excluded);</span>
<a href="#l3.1478"></a><span id="l3.1478"> </span>
<a href="#l3.1479"></a><span id="l3.1479">   nsresult rv = NS_OK;</span>
<a href="#l3.1480"></a><span id="l3.1480"> </span>
<a href="#l3.1481"></a><span id="l3.1481" class="difflineminus">-  if (!excluded)</span>
<a href="#l3.1482"></a><span id="l3.1482" class="difflineminus">-  {</span>
<a href="#l3.1483"></a><span id="l3.1483" class="difflineplus">+  if (!excluded) {</span>
<a href="#l3.1484"></a><span id="l3.1484">     // Add this folder into the priority queue.</span>
<a href="#l3.1485"></a><span id="l3.1485">     autoSyncStateObj-&gt;SetState(nsAutoSyncState::stReadyToDownload);</span>
<a href="#l3.1486"></a><span id="l3.1486">     ScheduleFolderForOfflineDownload(autoSyncStateObj);</span>
<a href="#l3.1487"></a><span id="l3.1487"> </span>
<a href="#l3.1488"></a><span id="l3.1488" class="difflineminus">-    // If we operate in parallel mode or if there is no sibling downloading messages at the moment,</span>
<a href="#l3.1489"></a><span id="l3.1489" class="difflineminus">-    // we can download the first group of the messages for this folder</span>
<a href="#l3.1490"></a><span id="l3.1490" class="difflineplus">+    // If we operate in parallel mode or if there is no sibling downloading</span>
<a href="#l3.1491"></a><span id="l3.1491" class="difflineplus">+    // messages at the moment, we can download the first group of the messages</span>
<a href="#l3.1492"></a><span id="l3.1492" class="difflineplus">+    // for this folder</span>
<a href="#l3.1493"></a><span id="l3.1493">     if (mDownloadModel == dmParallel ||</span>
<a href="#l3.1494"></a><span id="l3.1494" class="difflineminus">-        !DoesQContainAnySiblingOf(mPriorityQ, autoSyncStateObj, nsAutoSyncState::stDownloadInProgress))</span>
<a href="#l3.1495"></a><span id="l3.1495" class="difflineminus">-    {</span>
<a href="#l3.1496"></a><span id="l3.1496" class="difflineplus">+        !DoesQContainAnySiblingOf(mPriorityQ, autoSyncStateObj,</span>
<a href="#l3.1497"></a><span id="l3.1497" class="difflineplus">+                                  nsAutoSyncState::stDownloadInProgress)) {</span>
<a href="#l3.1498"></a><span id="l3.1498">       // this will download the first group of messages immediately;</span>
<a href="#l3.1499"></a><span id="l3.1499" class="difflineminus">-      // to ensure that we don't end up downloading a large single message in not-idle time,</span>
<a href="#l3.1500"></a><span id="l3.1500" class="difflineminus">-      // we enforce a limit. If there is no message fits into this limit we postpone the</span>
<a href="#l3.1501"></a><span id="l3.1501" class="difflineminus">-      // download until the next idle.</span>
<a href="#l3.1502"></a><span id="l3.1502" class="difflineplus">+      // to ensure that we don't end up downloading a large single message in</span>
<a href="#l3.1503"></a><span id="l3.1503" class="difflineplus">+      // not-idle time, we enforce a limit. If there is no message fits into</span>
<a href="#l3.1504"></a><span id="l3.1504" class="difflineplus">+      // this limit we postpone the download until the next idle.</span>
<a href="#l3.1505"></a><span id="l3.1505">       if (GetIdleState() == notIdle)</span>
<a href="#l3.1506"></a><span id="l3.1506" class="difflineminus">-        rv =  DownloadMessagesForOffline(autoSyncStateObj, kFirstGroupSizeLimit);</span>
<a href="#l3.1507"></a><span id="l3.1507" class="difflineplus">+        rv = DownloadMessagesForOffline(autoSyncStateObj, kFirstGroupSizeLimit);</span>
<a href="#l3.1508"></a><span id="l3.1508">       else</span>
<a href="#l3.1509"></a><span id="l3.1509">         rv = DownloadMessagesForOffline(autoSyncStateObj);</span>
<a href="#l3.1510"></a><span id="l3.1510"> </span>
<a href="#l3.1511"></a><span id="l3.1511">       if (NS_FAILED(rv))</span>
<a href="#l3.1512"></a><span id="l3.1512">         autoSyncStateObj-&gt;TryCurrentGroupAgain(kGroupRetryCount);</span>
<a href="#l3.1513"></a><span id="l3.1513">     }</span>
<a href="#l3.1514"></a><span id="l3.1514">   }</span>
<a href="#l3.1515"></a><span id="l3.1515">   return rv;</span>
<a href="#l3.1516"></a><span id="l3.1516"> }</span>
<a href="#l3.1517"></a><span id="l3.1517"> </span>
<a href="#l3.1518"></a><span id="l3.1518"> NS_IMETHODIMP</span>
<a href="#l3.1519"></a><span id="l3.1519" class="difflineminus">-nsAutoSyncManager::OnDownloadStarted(nsIAutoSyncState *aAutoSyncStateObj, nsresult aStartCode)</span>
<a href="#l3.1520"></a><span id="l3.1520" class="difflineminus">-{</span>
<a href="#l3.1521"></a><span id="l3.1521" class="difflineplus">+nsAutoSyncManager::OnDownloadStarted(nsIAutoSyncState *aAutoSyncStateObj,</span>
<a href="#l3.1522"></a><span id="l3.1522" class="difflineplus">+                                     nsresult aStartCode) {</span>
<a href="#l3.1523"></a><span id="l3.1523">   nsCOMPtr&lt;nsIAutoSyncState&gt; autoSyncStateObj(aAutoSyncStateObj);</span>
<a href="#l3.1524"></a><span id="l3.1524" class="difflineminus">-  if (!autoSyncStateObj)</span>
<a href="#l3.1525"></a><span id="l3.1525" class="difflineminus">-    return NS_ERROR_INVALID_ARG;</span>
<a href="#l3.1526"></a><span id="l3.1526" class="difflineplus">+  if (!autoSyncStateObj) return NS_ERROR_INVALID_ARG;</span>
<a href="#l3.1527"></a><span id="l3.1527"> </span>
<a href="#l3.1528"></a><span id="l3.1528">   // resume downloads during next idle time</span>
<a href="#l3.1529"></a><span id="l3.1529">   if (NS_FAILED(aStartCode))</span>
<a href="#l3.1530"></a><span id="l3.1530">     autoSyncStateObj-&gt;SetState(nsAutoSyncState::stReadyToDownload);</span>
<a href="#l3.1531"></a><span id="l3.1531"> </span>
<a href="#l3.1532"></a><span id="l3.1532">   return aStartCode;</span>
<a href="#l3.1533"></a><span id="l3.1533"> }</span>
<a href="#l3.1534"></a><span id="l3.1534"> </span>
<a href="#l3.1535"></a><span id="l3.1535"> NS_IMETHODIMP</span>
<a href="#l3.1536"></a><span id="l3.1536" class="difflineminus">-nsAutoSyncManager::OnDownloadCompleted(nsIAutoSyncState *aAutoSyncStateObj, nsresult aExitCode)</span>
<a href="#l3.1537"></a><span id="l3.1537" class="difflineminus">-{</span>
<a href="#l3.1538"></a><span id="l3.1538" class="difflineplus">+nsAutoSyncManager::OnDownloadCompleted(nsIAutoSyncState *aAutoSyncStateObj,</span>
<a href="#l3.1539"></a><span id="l3.1539" class="difflineplus">+                                       nsresult aExitCode) {</span>
<a href="#l3.1540"></a><span id="l3.1540">   nsCOMPtr&lt;nsIAutoSyncState&gt; autoSyncStateObj(aAutoSyncStateObj);</span>
<a href="#l3.1541"></a><span id="l3.1541" class="difflineminus">-  if (!autoSyncStateObj)</span>
<a href="#l3.1542"></a><span id="l3.1542" class="difflineminus">-    return NS_ERROR_INVALID_ARG;</span>
<a href="#l3.1543"></a><span id="l3.1543" class="difflineplus">+  if (!autoSyncStateObj) return NS_ERROR_INVALID_ARG;</span>
<a href="#l3.1544"></a><span id="l3.1544"> </span>
<a href="#l3.1545"></a><span id="l3.1545">   nsresult rv = aExitCode;</span>
<a href="#l3.1546"></a><span id="l3.1546"> </span>
<a href="#l3.1547"></a><span id="l3.1547" class="difflineminus">-  if (NS_FAILED(aExitCode))</span>
<a href="#l3.1548"></a><span id="l3.1548" class="difflineminus">-  {</span>
<a href="#l3.1549"></a><span id="l3.1549" class="difflineplus">+  if (NS_FAILED(aExitCode)) {</span>
<a href="#l3.1550"></a><span id="l3.1550">     // retry the same group kGroupRetryCount times</span>
<a href="#l3.1551"></a><span id="l3.1551">     // try again if TB still idle, otherwise wait for the next idle time</span>
<a href="#l3.1552"></a><span id="l3.1552">     autoSyncStateObj-&gt;TryCurrentGroupAgain(kGroupRetryCount);</span>
<a href="#l3.1553"></a><span id="l3.1553" class="difflineminus">-    if (GetIdleState() != notIdle)</span>
<a href="#l3.1554"></a><span id="l3.1554" class="difflineminus">-    {</span>
<a href="#l3.1555"></a><span id="l3.1555" class="difflineplus">+    if (GetIdleState() != notIdle) {</span>
<a href="#l3.1556"></a><span id="l3.1556">       rv = DownloadMessagesForOffline(autoSyncStateObj);</span>
<a href="#l3.1557"></a><span id="l3.1557" class="difflineminus">-      if (NS_FAILED(rv))</span>
<a href="#l3.1558"></a><span id="l3.1558" class="difflineminus">-        rv = HandleDownloadErrorFor(autoSyncStateObj, rv);</span>
<a href="#l3.1559"></a><span id="l3.1559" class="difflineplus">+      if (NS_FAILED(rv)) rv = HandleDownloadErrorFor(autoSyncStateObj, rv);</span>
<a href="#l3.1560"></a><span id="l3.1560">     }</span>
<a href="#l3.1561"></a><span id="l3.1561">     return rv;</span>
<a href="#l3.1562"></a><span id="l3.1562">   }</span>
<a href="#l3.1563"></a><span id="l3.1563"> </span>
<a href="#l3.1564"></a><span id="l3.1564">   // download is successful, reset the retry counter of the folder</span>
<a href="#l3.1565"></a><span id="l3.1565">   autoSyncStateObj-&gt;ResetRetryCounter();</span>
<a href="#l3.1566"></a><span id="l3.1566"> </span>
<a href="#l3.1567"></a><span id="l3.1567">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.1568"></a><span id="l3.1568">   aAutoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l3.1569"></a><span id="l3.1569" class="difflineminus">-  if (folder)</span>
<a href="#l3.1570"></a><span id="l3.1570" class="difflineminus">-    NOTIFY_LISTENERS(OnDownloadCompleted, (folder));</span>
<a href="#l3.1571"></a><span id="l3.1571" class="difflineplus">+  if (folder) NOTIFY_LISTENERS(OnDownloadCompleted, (folder));</span>
<a href="#l3.1572"></a><span id="l3.1572"> </span>
<a href="#l3.1573"></a><span id="l3.1573">   int32_t count;</span>
<a href="#l3.1574"></a><span id="l3.1574">   rv = autoSyncStateObj-&gt;GetPendingMessageCount(&amp;count);</span>
<a href="#l3.1575"></a><span id="l3.1575">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.1576"></a><span id="l3.1576"> </span>
<a href="#l3.1577"></a><span id="l3.1577">   nsIAutoSyncState *nextFolderToDownload = nullptr;</span>
<a href="#l3.1578"></a><span id="l3.1578" class="difflineminus">-  if (count &gt; 0)</span>
<a href="#l3.1579"></a><span id="l3.1579" class="difflineminus">-  {</span>
<a href="#l3.1580"></a><span id="l3.1580" class="difflineplus">+  if (count &gt; 0) {</span>
<a href="#l3.1581"></a><span id="l3.1581">     autoSyncStateObj-&gt;SetState(nsAutoSyncState::stReadyToDownload);</span>
<a href="#l3.1582"></a><span id="l3.1582"> </span>
<a href="#l3.1583"></a><span id="l3.1583" class="difflineminus">-    // in parallel model, we continue downloading the same folder as long as it has</span>
<a href="#l3.1584"></a><span id="l3.1584" class="difflineminus">-    // more pending messages</span>
<a href="#l3.1585"></a><span id="l3.1585" class="difflineplus">+    // in parallel model, we continue downloading the same folder as long as it</span>
<a href="#l3.1586"></a><span id="l3.1586" class="difflineplus">+    // has more pending messages</span>
<a href="#l3.1587"></a><span id="l3.1587">     nextFolderToDownload = autoSyncStateObj;</span>
<a href="#l3.1588"></a><span id="l3.1588"> </span>
<a href="#l3.1589"></a><span id="l3.1589" class="difflineminus">-    // in chained model, ensure that we are always downloading the highest priority</span>
<a href="#l3.1590"></a><span id="l3.1590" class="difflineminus">-    // folder first</span>
<a href="#l3.1591"></a><span id="l3.1591" class="difflineminus">-    if (mDownloadModel == dmChained)</span>
<a href="#l3.1592"></a><span id="l3.1592" class="difflineminus">-    {</span>
<a href="#l3.1593"></a><span id="l3.1593" class="difflineplus">+    // in chained model, ensure that we are always downloading the highest</span>
<a href="#l3.1594"></a><span id="l3.1594" class="difflineplus">+    // priority folder first</span>
<a href="#l3.1595"></a><span id="l3.1595" class="difflineplus">+    if (mDownloadModel == dmChained) {</span>
<a href="#l3.1596"></a><span id="l3.1596">       // switch to higher priority folder and continue to download,</span>
<a href="#l3.1597"></a><span id="l3.1597">       // if any added recently</span>
<a href="#l3.1598"></a><span id="l3.1598">       int32_t myIndex = mPriorityQ.IndexOf(autoSyncStateObj);</span>
<a href="#l3.1599"></a><span id="l3.1599"> </span>
<a href="#l3.1600"></a><span id="l3.1600">       int32_t siblingIndex;</span>
<a href="#l3.1601"></a><span id="l3.1601" class="difflineminus">-      nsIAutoSyncState *sibling = GetHighestPrioSibling(mPriorityQ, autoSyncStateObj, &amp;siblingIndex);</span>
<a href="#l3.1602"></a><span id="l3.1602" class="difflineplus">+      nsIAutoSyncState *sibling =</span>
<a href="#l3.1603"></a><span id="l3.1603" class="difflineplus">+          GetHighestPrioSibling(mPriorityQ, autoSyncStateObj, &amp;siblingIndex);</span>
<a href="#l3.1604"></a><span id="l3.1604"> </span>
<a href="#l3.1605"></a><span id="l3.1605">       // lesser index = higher priority</span>
<a href="#l3.1606"></a><span id="l3.1606">       if (sibling &amp;&amp; myIndex &gt; -1 &amp;&amp; siblingIndex &lt; myIndex)</span>
<a href="#l3.1607"></a><span id="l3.1607">         nextFolderToDownload = sibling;</span>
<a href="#l3.1608"></a><span id="l3.1608">     }</span>
<a href="#l3.1609"></a><span id="l3.1609" class="difflineminus">-  }</span>
<a href="#l3.1610"></a><span id="l3.1610" class="difflineminus">-  else</span>
<a href="#l3.1611"></a><span id="l3.1611" class="difflineminus">-  {</span>
<a href="#l3.1612"></a><span id="l3.1612" class="difflineplus">+  } else {</span>
<a href="#l3.1613"></a><span id="l3.1613">     autoSyncStateObj-&gt;SetState(nsAutoSyncState::stCompletedIdle);</span>
<a href="#l3.1614"></a><span id="l3.1614"> </span>
<a href="#l3.1615"></a><span id="l3.1615">     nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.1616"></a><span id="l3.1616">     nsresult rv = autoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l3.1617"></a><span id="l3.1617"> </span>
<a href="#l3.1618"></a><span id="l3.1618">     if (NS_SUCCEEDED(rv) &amp;&amp; mPriorityQ.RemoveObject(autoSyncStateObj))</span>
<a href="#l3.1619"></a><span id="l3.1619" class="difflineminus">-      NOTIFY_LISTENERS(OnFolderRemovedFromQ, (nsIAutoSyncMgrListener::PriorityQueue, folder));</span>
<a href="#l3.1620"></a><span id="l3.1620" class="difflineplus">+      NOTIFY_LISTENERS(OnFolderRemovedFromQ,</span>
<a href="#l3.1621"></a><span id="l3.1621" class="difflineplus">+                       (nsIAutoSyncMgrListener::PriorityQueue, folder));</span>
<a href="#l3.1622"></a><span id="l3.1622"> </span>
<a href="#l3.1623"></a><span id="l3.1623" class="difflineminus">-    //find the next folder owned by the same server in the queue and continue downloading</span>
<a href="#l3.1624"></a><span id="l3.1624" class="difflineplus">+    // find the next folder owned by the same server in the queue and continue</span>
<a href="#l3.1625"></a><span id="l3.1625" class="difflineplus">+    // downloading</span>
<a href="#l3.1626"></a><span id="l3.1626">     if (mDownloadModel == dmChained)</span>
<a href="#l3.1627"></a><span id="l3.1627" class="difflineminus">-      nextFolderToDownload = GetHighestPrioSibling(mPriorityQ, autoSyncStateObj);</span>
<a href="#l3.1628"></a><span id="l3.1628" class="difflineplus">+      nextFolderToDownload =</span>
<a href="#l3.1629"></a><span id="l3.1629" class="difflineplus">+          GetHighestPrioSibling(mPriorityQ, autoSyncStateObj);</span>
<a href="#l3.1630"></a><span id="l3.1630"> </span>
<a href="#l3.1631"></a><span id="l3.1631" class="difflineminus">-  }//endif</span>
<a href="#l3.1632"></a><span id="l3.1632" class="difflineplus">+  }  // endif</span>
<a href="#l3.1633"></a><span id="l3.1633"> </span>
<a href="#l3.1634"></a><span id="l3.1634">   // continue downloading if TB is still in idle state</span>
<a href="#l3.1635"></a><span id="l3.1635" class="difflineminus">-  if (nextFolderToDownload &amp;&amp; GetIdleState() != notIdle)</span>
<a href="#l3.1636"></a><span id="l3.1636" class="difflineminus">-  {</span>
<a href="#l3.1637"></a><span id="l3.1637" class="difflineplus">+  if (nextFolderToDownload &amp;&amp; GetIdleState() != notIdle) {</span>
<a href="#l3.1638"></a><span id="l3.1638">     rv = DownloadMessagesForOffline(nextFolderToDownload);</span>
<a href="#l3.1639"></a><span id="l3.1639" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l3.1640"></a><span id="l3.1640" class="difflineminus">-      rv = HandleDownloadErrorFor(nextFolderToDownload, rv);</span>
<a href="#l3.1641"></a><span id="l3.1641" class="difflineplus">+    if (NS_FAILED(rv)) rv = HandleDownloadErrorFor(nextFolderToDownload, rv);</span>
<a href="#l3.1642"></a><span id="l3.1642">   }</span>
<a href="#l3.1643"></a><span id="l3.1643"> </span>
<a href="#l3.1644"></a><span id="l3.1644">   return rv;</span>
<a href="#l3.1645"></a><span id="l3.1645"> }</span>
<a href="#l3.1646"></a><span id="l3.1646"> </span>
<a href="#l3.1647"></a><span id="l3.1647" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::GetDownloadModel(int32_t *aDownloadModel)</span>
<a href="#l3.1648"></a><span id="l3.1648" class="difflineminus">-{</span>
<a href="#l3.1649"></a><span id="l3.1649" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::GetDownloadModel(int32_t *aDownloadModel) {</span>
<a href="#l3.1650"></a><span id="l3.1650">   NS_ENSURE_ARG_POINTER(aDownloadModel);</span>
<a href="#l3.1651"></a><span id="l3.1651">   *aDownloadModel = mDownloadModel;</span>
<a href="#l3.1652"></a><span id="l3.1652">   return NS_OK;</span>
<a href="#l3.1653"></a><span id="l3.1653"> }</span>
<a href="#l3.1654"></a><span id="l3.1654" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::SetDownloadModel(int32_t aDownloadModel)</span>
<a href="#l3.1655"></a><span id="l3.1655" class="difflineminus">-{</span>
<a href="#l3.1656"></a><span id="l3.1656" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::SetDownloadModel(int32_t aDownloadModel) {</span>
<a href="#l3.1657"></a><span id="l3.1657">   mDownloadModel = aDownloadModel;</span>
<a href="#l3.1658"></a><span id="l3.1658">   return NS_OK;</span>
<a href="#l3.1659"></a><span id="l3.1659"> }</span>
<a href="#l3.1660"></a><span id="l3.1660"> </span>
<a href="#l3.1661"></a><span id="l3.1661" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::AddListener(nsIAutoSyncMgrListener *aListener)</span>
<a href="#l3.1662"></a><span id="l3.1662" class="difflineminus">-{</span>
<a href="#l3.1663"></a><span id="l3.1663" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::AddListener(</span>
<a href="#l3.1664"></a><span id="l3.1664" class="difflineplus">+    nsIAutoSyncMgrListener *aListener) {</span>
<a href="#l3.1665"></a><span id="l3.1665">   NS_ENSURE_ARG_POINTER(aListener);</span>
<a href="#l3.1666"></a><span id="l3.1666">   mListeners.AppendElementUnlessExists(aListener);</span>
<a href="#l3.1667"></a><span id="l3.1667">   return NS_OK;</span>
<a href="#l3.1668"></a><span id="l3.1668"> }</span>
<a href="#l3.1669"></a><span id="l3.1669"> </span>
<a href="#l3.1670"></a><span id="l3.1670" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::RemoveListener(nsIAutoSyncMgrListener *aListener)</span>
<a href="#l3.1671"></a><span id="l3.1671" class="difflineminus">-{</span>
<a href="#l3.1672"></a><span id="l3.1672" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::RemoveListener(</span>
<a href="#l3.1673"></a><span id="l3.1673" class="difflineplus">+    nsIAutoSyncMgrListener *aListener) {</span>
<a href="#l3.1674"></a><span id="l3.1674">   NS_ENSURE_ARG_POINTER(aListener);</span>
<a href="#l3.1675"></a><span id="l3.1675">   mListeners.RemoveElement(aListener);</span>
<a href="#l3.1676"></a><span id="l3.1676">   return NS_OK;</span>
<a href="#l3.1677"></a><span id="l3.1677"> }</span>
<a href="#l3.1678"></a><span id="l3.1678"> </span>
<a href="#l3.1679"></a><span id="l3.1679"> /* readonly attribute unsigned long discoveryQLength; */</span>
<a href="#l3.1680"></a><span id="l3.1680" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::GetDiscoveryQLength(uint32_t *aDiscoveryQLength)</span>
<a href="#l3.1681"></a><span id="l3.1681" class="difflineminus">-{</span>
<a href="#l3.1682"></a><span id="l3.1682" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::GetDiscoveryQLength(</span>
<a href="#l3.1683"></a><span id="l3.1683" class="difflineplus">+    uint32_t *aDiscoveryQLength) {</span>
<a href="#l3.1684"></a><span id="l3.1684">   NS_ENSURE_ARG_POINTER(aDiscoveryQLength);</span>
<a href="#l3.1685"></a><span id="l3.1685">   *aDiscoveryQLength = mDiscoveryQ.Count();</span>
<a href="#l3.1686"></a><span id="l3.1686">   return NS_OK;</span>
<a href="#l3.1687"></a><span id="l3.1687"> }</span>
<a href="#l3.1688"></a><span id="l3.1688"> </span>
<a href="#l3.1689"></a><span id="l3.1689"> /* readonly attribute unsigned long uploadQLength; */</span>
<a href="#l3.1690"></a><span id="l3.1690" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::GetUpdateQLength(uint32_t *aUpdateQLength)</span>
<a href="#l3.1691"></a><span id="l3.1691" class="difflineminus">-{</span>
<a href="#l3.1692"></a><span id="l3.1692" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::GetUpdateQLength(uint32_t *aUpdateQLength) {</span>
<a href="#l3.1693"></a><span id="l3.1693">   NS_ENSURE_ARG_POINTER(aUpdateQLength);</span>
<a href="#l3.1694"></a><span id="l3.1694">   *aUpdateQLength = mUpdateQ.Count();</span>
<a href="#l3.1695"></a><span id="l3.1695">   return NS_OK;</span>
<a href="#l3.1696"></a><span id="l3.1696"> }</span>
<a href="#l3.1697"></a><span id="l3.1697"> </span>
<a href="#l3.1698"></a><span id="l3.1698"> /* readonly attribute unsigned long downloadQLength; */</span>
<a href="#l3.1699"></a><span id="l3.1699" class="difflineminus">-NS_IMETHODIMP nsAutoSyncManager::GetDownloadQLength(uint32_t *aDownloadQLength)</span>
<a href="#l3.1700"></a><span id="l3.1700" class="difflineminus">-{</span>
<a href="#l3.1701"></a><span id="l3.1701" class="difflineplus">+NS_IMETHODIMP nsAutoSyncManager::GetDownloadQLength(</span>
<a href="#l3.1702"></a><span id="l3.1702" class="difflineplus">+    uint32_t *aDownloadQLength) {</span>
<a href="#l3.1703"></a><span id="l3.1703">   NS_ENSURE_ARG_POINTER(aDownloadQLength);</span>
<a href="#l3.1704"></a><span id="l3.1704">   *aDownloadQLength = mPriorityQ.Count();</span>
<a href="#l3.1705"></a><span id="l3.1705">   return NS_OK;</span>
<a href="#l3.1706"></a><span id="l3.1706"> }</span>
<a href="#l3.1707"></a><span id="l3.1707"> </span>
<a href="#l3.1708"></a><span id="l3.1708"> NS_IMETHODIMP</span>
<a href="#l3.1709"></a><span id="l3.1709" class="difflineminus">-nsAutoSyncManager::OnFolderHasPendingMsgs(nsIAutoSyncState *aAutoSyncStateObj)</span>
<a href="#l3.1710"></a><span id="l3.1710" class="difflineminus">-{</span>
<a href="#l3.1711"></a><span id="l3.1711" class="difflineplus">+nsAutoSyncManager::OnFolderHasPendingMsgs(nsIAutoSyncState *aAutoSyncStateObj) {</span>
<a href="#l3.1712"></a><span id="l3.1712">   NS_ENSURE_ARG_POINTER(aAutoSyncStateObj);</span>
<a href="#l3.1713"></a><span id="l3.1713" class="difflineminus">-  if (mUpdateQ.IndexOf(aAutoSyncStateObj) == -1)</span>
<a href="#l3.1714"></a><span id="l3.1714" class="difflineminus">-  {</span>
<a href="#l3.1715"></a><span id="l3.1715" class="difflineplus">+  if (mUpdateQ.IndexOf(aAutoSyncStateObj) == -1) {</span>
<a href="#l3.1716"></a><span id="l3.1716">     nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.1717"></a><span id="l3.1717">     aAutoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l3.1718"></a><span id="l3.1718">     // If this folder isn't the trash, add it to the update q.</span>
<a href="#l3.1719"></a><span id="l3.1719" class="difflineminus">-    if (folder)</span>
<a href="#l3.1720"></a><span id="l3.1720" class="difflineminus">-    {</span>
<a href="#l3.1721"></a><span id="l3.1721" class="difflineplus">+    if (folder) {</span>
<a href="#l3.1722"></a><span id="l3.1722">       bool isTrash;</span>
<a href="#l3.1723"></a><span id="l3.1723">       folder-&gt;GetFlag(nsMsgFolderFlags::Trash, &amp;isTrash);</span>
<a href="#l3.1724"></a><span id="l3.1724" class="difflineminus">-      if (!isTrash)</span>
<a href="#l3.1725"></a><span id="l3.1725" class="difflineminus">-      {</span>
<a href="#l3.1726"></a><span id="l3.1726" class="difflineplus">+      if (!isTrash) {</span>
<a href="#l3.1727"></a><span id="l3.1727">         bool isSentOrArchive;</span>
<a href="#l3.1728"></a><span id="l3.1728" class="difflineminus">-        folder-&gt;IsSpecialFolder(nsMsgFolderFlags::SentMail|</span>
<a href="#l3.1729"></a><span id="l3.1729" class="difflineminus">-                                nsMsgFolderFlags::Archive,</span>
<a href="#l3.1730"></a><span id="l3.1730" class="difflineminus">-                                true, &amp;isSentOrArchive);</span>
<a href="#l3.1731"></a><span id="l3.1731" class="difflineplus">+        folder-&gt;IsSpecialFolder(</span>
<a href="#l3.1732"></a><span id="l3.1732" class="difflineplus">+            nsMsgFolderFlags::SentMail | nsMsgFolderFlags::Archive, true,</span>
<a href="#l3.1733"></a><span id="l3.1733" class="difflineplus">+            &amp;isSentOrArchive);</span>
<a href="#l3.1734"></a><span id="l3.1734">         // Sent or archive folders go to the q front, the rest to the end.</span>
<a href="#l3.1735"></a><span id="l3.1735">         if (isSentOrArchive)</span>
<a href="#l3.1736"></a><span id="l3.1736">           mUpdateQ.InsertObjectAt(aAutoSyncStateObj, 0);</span>
<a href="#l3.1737"></a><span id="l3.1737">         else</span>
<a href="#l3.1738"></a><span id="l3.1738">           mUpdateQ.AppendObject(aAutoSyncStateObj);</span>
<a href="#l3.1739"></a><span id="l3.1739">         aAutoSyncStateObj-&gt;SetState(nsAutoSyncState::stUpdateNeeded);</span>
<a href="#l3.1740"></a><span id="l3.1740">         NOTIFY_LISTENERS(OnFolderAddedIntoQ,</span>
<a href="#l3.1741"></a><span id="l3.1741" class="difflineminus">-                        (nsIAutoSyncMgrListener::UpdateQueue, folder));</span>
<a href="#l3.1742"></a><span id="l3.1742" class="difflineplus">+                         (nsIAutoSyncMgrListener::UpdateQueue, folder));</span>
<a href="#l3.1743"></a><span id="l3.1743">       }</span>
<a href="#l3.1744"></a><span id="l3.1744">     }</span>
<a href="#l3.1745"></a><span id="l3.1745">   }</span>
<a href="#l3.1746"></a><span id="l3.1746">   return NS_OK;</span>
<a href="#l3.1747"></a><span id="l3.1747"> }</span>
<a href="#l3.1748"></a><span id="l3.1748"> </span>
<a href="#l3.1749"></a><span id="l3.1749" class="difflineminus">-void nsAutoSyncManager::SetIdleState(IdleState st)</span>
<a href="#l3.1750"></a><span id="l3.1750" class="difflineminus">-{</span>
<a href="#l3.1751"></a><span id="l3.1751" class="difflineminus">-  mIdleState = st;</span>
<a href="#l3.1752"></a><span id="l3.1752" class="difflineminus">-}</span>
<a href="#l3.1753"></a><span id="l3.1753" class="difflineplus">+void nsAutoSyncManager::SetIdleState(IdleState st) { mIdleState = st; }</span>
<a href="#l3.1754"></a><span id="l3.1754"> </span>
<a href="#l3.1755"></a><span id="l3.1755" class="difflineminus">-nsAutoSyncManager::IdleState nsAutoSyncManager::GetIdleState() const</span>
<a href="#l3.1756"></a><span id="l3.1756" class="difflineminus">-{</span>
<a href="#l3.1757"></a><span id="l3.1757" class="difflineplus">+nsAutoSyncManager::IdleState nsAutoSyncManager::GetIdleState() const {</span>
<a href="#l3.1758"></a><span id="l3.1758">   return mIdleState;</span>
<a href="#l3.1759"></a><span id="l3.1759"> }</span>
<a href="#l3.1760"></a><span id="l3.1760"> </span>
<a href="#l3.1761"></a><span id="l3.1761" class="difflineminus">-NS_IMPL_ISUPPORTS(nsAutoSyncManager, nsIObserver, nsIUrlListener, nsIAutoSyncManager)</span>
<a href="#l3.1762"></a><span id="l3.1762" class="difflineplus">+NS_IMPL_ISUPPORTS(nsAutoSyncManager, nsIObserver, nsIUrlListener,</span>
<a href="#l3.1763"></a><span id="l3.1763" class="difflineplus">+                  nsIAutoSyncManager)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/imap/src/nsAutoSyncManager.h</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/imap/src/nsAutoSyncManager.h</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -1,28 +1,29 @@</span>
<a href="#l4.4"></a><span id="l4.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l4.5"></a><span id="l4.5">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l4.6"></a><span id="l4.6">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l4.7"></a><span id="l4.7"> </span>
<a href="#l4.8"></a><span id="l4.8"> #ifndef nsAutoSyncManager_h__</span>
<a href="#l4.9"></a><span id="l4.9" class="difflineminus">-#define nsAutoSyncManager_h__</span>
<a href="#l4.10"></a><span id="l4.10" class="difflineplus">+#  define nsAutoSyncManager_h__</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-#include &quot;nsAutoPtr.h&quot;</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineminus">-#include &quot;nsString.h&quot;</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineminus">-#include &quot;nsCOMArray.h&quot;</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineminus">-#include &quot;nsIObserver.h&quot;</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineminus">-#include &quot;nsIUrlListener.h&quot;</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineminus">-#include &quot;nsITimer.h&quot;</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineminus">-#include &quot;nsTObserverArray.h&quot;</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineminus">-#include &quot;nsIAutoSyncManager.h&quot;</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineminus">-#include &quot;nsIAutoSyncMsgStrategy.h&quot;</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineminus">-#include &quot;nsIAutoSyncFolderStrategy.h&quot;</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineminus">-#include &quot;nsIIdleService.h&quot;</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineminus">-#include &quot;prtime.h&quot;</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineplus">+#  include &quot;nsAutoPtr.h&quot;</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineplus">+#  include &quot;nsString.h&quot;</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineplus">+#  include &quot;nsCOMArray.h&quot;</span>
<a href="#l4.27"></a><span id="l4.27" class="difflineplus">+#  include &quot;nsIObserver.h&quot;</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineplus">+#  include &quot;nsIUrlListener.h&quot;</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineplus">+#  include &quot;nsITimer.h&quot;</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineplus">+#  include &quot;nsTObserverArray.h&quot;</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+#  include &quot;nsIAutoSyncManager.h&quot;</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+#  include &quot;nsIAutoSyncMsgStrategy.h&quot;</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+#  include &quot;nsIAutoSyncFolderStrategy.h&quot;</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+#  include &quot;nsIIdleService.h&quot;</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+#  include &quot;prtime.h&quot;</span>
<a href="#l4.36"></a><span id="l4.36"> </span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+// clang-format off</span>
<a href="#l4.38"></a><span id="l4.38"> /* Auto-Sync</span>
<a href="#l4.39"></a><span id="l4.39">  *</span>
<a href="#l4.40"></a><span id="l4.40">  * Background:</span>
<a href="#l4.41"></a><span id="l4.41">  *  it works only with offline imap folders. &quot;autosync_offline_stores&quot; pref</span>
<a href="#l4.42"></a><span id="l4.42">  *  enables/disables auto-sync mechanism. Note that setting &quot;autosync_offline_stores&quot;</span>
<a href="#l4.43"></a><span id="l4.43">  *  to false, or setting folder to not-offline doesn't stop synchronization</span>
<a href="#l4.44"></a><span id="l4.44">  *  process for already queued folders.</span>
<a href="#l4.45"></a><span id="l4.45">  *</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineat">@@ -73,144 +74,144 @@</span>
<a href="#l4.47"></a><span id="l4.47">  *</span>
<a href="#l4.48"></a><span id="l4.48">  * How it really works:</span>
<a href="#l4.49"></a><span id="l4.49">  * The AutoSyncManager gets an idle notification. First it processes any</span>
<a href="#l4.50"></a><span id="l4.50">  * folders in the discovery queue (which means it schedules message download</span>
<a href="#l4.51"></a><span id="l4.51">  * for any messages it previously determined it should download). Then it sets</span>
<a href="#l4.52"></a><span id="l4.52">  * a timer, and in the timer callback, it processes the update q, by calling</span>
<a href="#l4.53"></a><span id="l4.53">  * InitiateAutoSync on the first folder in the update q.</span>
<a href="#l4.54"></a><span id="l4.54">  */</span>
<a href="#l4.55"></a><span id="l4.55" class="difflineplus">+// clang-format on</span>
<a href="#l4.56"></a><span id="l4.56"> </span>
<a href="#l4.57"></a><span id="l4.57"> /**</span>
<a href="#l4.58"></a><span id="l4.58">  * Default strategy implementation to prioritize messages in the download queue.</span>
<a href="#l4.59"></a><span id="l4.59">  */</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineminus">-class nsDefaultAutoSyncMsgStrategy final : public nsIAutoSyncMsgStrategy</span>
<a href="#l4.61"></a><span id="l4.61" class="difflineminus">-{</span>
<a href="#l4.62"></a><span id="l4.62" class="difflineminus">-  static const uint32_t kFirstPassMessageSize = 60U*1024U; // 60K</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineplus">+class nsDefaultAutoSyncMsgStrategy final : public nsIAutoSyncMsgStrategy {</span>
<a href="#l4.64"></a><span id="l4.64" class="difflineplus">+  static const uint32_t kFirstPassMessageSize = 60U * 1024U;  // 60K</span>
<a href="#l4.65"></a><span id="l4.65"> </span>
<a href="#l4.66"></a><span id="l4.66" class="difflineminus">-  public:</span>
<a href="#l4.67"></a><span id="l4.67" class="difflineminus">-    NS_DECL_ISUPPORTS</span>
<a href="#l4.68"></a><span id="l4.68" class="difflineminus">-    NS_DECL_NSIAUTOSYNCMSGSTRATEGY</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineplus">+ public:</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineplus">+  NS_DECL_ISUPPORTS</span>
<a href="#l4.71"></a><span id="l4.71" class="difflineplus">+  NS_DECL_NSIAUTOSYNCMSGSTRATEGY</span>
<a href="#l4.72"></a><span id="l4.72"> </span>
<a href="#l4.73"></a><span id="l4.73" class="difflineminus">-    nsDefaultAutoSyncMsgStrategy();</span>
<a href="#l4.74"></a><span id="l4.74" class="difflineplus">+  nsDefaultAutoSyncMsgStrategy();</span>
<a href="#l4.75"></a><span id="l4.75"> </span>
<a href="#l4.76"></a><span id="l4.76" class="difflineminus">-  private:</span>
<a href="#l4.77"></a><span id="l4.77" class="difflineminus">-    ~nsDefaultAutoSyncMsgStrategy();</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineplus">+ private:</span>
<a href="#l4.79"></a><span id="l4.79" class="difflineplus">+  ~nsDefaultAutoSyncMsgStrategy();</span>
<a href="#l4.80"></a><span id="l4.80"> };</span>
<a href="#l4.81"></a><span id="l4.81"> </span>
<a href="#l4.82"></a><span id="l4.82"> /**</span>
<a href="#l4.83"></a><span id="l4.83">  * Default strategy implementation to prioritize folders in the download queue.</span>
<a href="#l4.84"></a><span id="l4.84">  */</span>
<a href="#l4.85"></a><span id="l4.85" class="difflineminus">-class nsDefaultAutoSyncFolderStrategy final : public nsIAutoSyncFolderStrategy</span>
<a href="#l4.86"></a><span id="l4.86" class="difflineminus">-{</span>
<a href="#l4.87"></a><span id="l4.87" class="difflineminus">-  public:</span>
<a href="#l4.88"></a><span id="l4.88" class="difflineminus">-    NS_DECL_ISUPPORTS</span>
<a href="#l4.89"></a><span id="l4.89" class="difflineminus">-    NS_DECL_NSIAUTOSYNCFOLDERSTRATEGY</span>
<a href="#l4.90"></a><span id="l4.90" class="difflineplus">+class nsDefaultAutoSyncFolderStrategy final : public nsIAutoSyncFolderStrategy {</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineplus">+ public:</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineplus">+  NS_DECL_ISUPPORTS</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineplus">+  NS_DECL_NSIAUTOSYNCFOLDERSTRATEGY</span>
<a href="#l4.94"></a><span id="l4.94"> </span>
<a href="#l4.95"></a><span id="l4.95" class="difflineminus">-    nsDefaultAutoSyncFolderStrategy();</span>
<a href="#l4.96"></a><span id="l4.96" class="difflineplus">+  nsDefaultAutoSyncFolderStrategy();</span>
<a href="#l4.97"></a><span id="l4.97"> </span>
<a href="#l4.98"></a><span id="l4.98" class="difflineminus">-  private:</span>
<a href="#l4.99"></a><span id="l4.99" class="difflineminus">-    ~nsDefaultAutoSyncFolderStrategy();</span>
<a href="#l4.100"></a><span id="l4.100" class="difflineplus">+ private:</span>
<a href="#l4.101"></a><span id="l4.101" class="difflineplus">+  ~nsDefaultAutoSyncFolderStrategy();</span>
<a href="#l4.102"></a><span id="l4.102"> };</span>
<a href="#l4.103"></a><span id="l4.103"> </span>
<a href="#l4.104"></a><span id="l4.104"> // see the end of the page for auto-sync internals</span>
<a href="#l4.105"></a><span id="l4.105"> </span>
<a href="#l4.106"></a><span id="l4.106"> /**</span>
<a href="#l4.107"></a><span id="l4.107">  * Manages background message download operations for offline imap folders.</span>
<a href="#l4.108"></a><span id="l4.108">  */</span>
<a href="#l4.109"></a><span id="l4.109"> class nsAutoSyncManager final : public nsIObserver,</span>
<a href="#l4.110"></a><span id="l4.110">                                 public nsIUrlListener,</span>
<a href="#l4.111"></a><span id="l4.111" class="difflineminus">-                                public nsIAutoSyncManager</span>
<a href="#l4.112"></a><span id="l4.112" class="difflineminus">-{</span>
<a href="#l4.113"></a><span id="l4.113" class="difflineplus">+                                public nsIAutoSyncManager {</span>
<a href="#l4.114"></a><span id="l4.114">   static const PRTime kAutoSyncFreq = 60UL * (PR_USEC_PER_SEC * 60UL);  // 1hr</span>
<a href="#l4.115"></a><span id="l4.115">   static const uint32_t kDefaultUpdateInterval = 10UL;                  // 10min</span>
<a href="#l4.116"></a><span id="l4.116">   static const int32_t kTimerIntervalInMs = 400;</span>
<a href="#l4.117"></a><span id="l4.117">   static const uint32_t kNumberOfHeadersToProcess = 250U;</span>
<a href="#l4.118"></a><span id="l4.118">   // enforced size of the first group that will be downloaded before idle time</span>
<a href="#l4.119"></a><span id="l4.119" class="difflineminus">-  static const uint32_t kFirstGroupSizeLimit = 60U*1024U /* 60K */;</span>
<a href="#l4.120"></a><span id="l4.120" class="difflineplus">+  static const uint32_t kFirstGroupSizeLimit = 60U * 1024U /* 60K */;</span>
<a href="#l4.121"></a><span id="l4.121">   static const int32_t kIdleTimeInSec = 10;</span>
<a href="#l4.122"></a><span id="l4.122">   static const uint32_t kGroupRetryCount = 3;</span>
<a href="#l4.123"></a><span id="l4.123"> </span>
<a href="#l4.124"></a><span id="l4.124">   enum IdleState { systemIdle, appIdle, notIdle };</span>
<a href="#l4.125"></a><span id="l4.125">   enum UpdateState { initiated, completed };</span>
<a href="#l4.126"></a><span id="l4.126"> </span>
<a href="#l4.127"></a><span id="l4.127" class="difflineminus">-  public:</span>
<a href="#l4.128"></a><span id="l4.128" class="difflineminus">-    NS_DECL_ISUPPORTS</span>
<a href="#l4.129"></a><span id="l4.129" class="difflineminus">-    NS_DECL_NSIOBSERVER</span>
<a href="#l4.130"></a><span id="l4.130" class="difflineminus">-    NS_DECL_NSIURLLISTENER</span>
<a href="#l4.131"></a><span id="l4.131" class="difflineminus">-    NS_DECL_NSIAUTOSYNCMANAGER</span>
<a href="#l4.132"></a><span id="l4.132" class="difflineplus">+ public:</span>
<a href="#l4.133"></a><span id="l4.133" class="difflineplus">+  NS_DECL_ISUPPORTS</span>
<a href="#l4.134"></a><span id="l4.134" class="difflineplus">+  NS_DECL_NSIOBSERVER</span>
<a href="#l4.135"></a><span id="l4.135" class="difflineplus">+  NS_DECL_NSIURLLISTENER</span>
<a href="#l4.136"></a><span id="l4.136" class="difflineplus">+  NS_DECL_NSIAUTOSYNCMANAGER</span>
<a href="#l4.137"></a><span id="l4.137"> </span>
<a href="#l4.138"></a><span id="l4.138" class="difflineminus">-    nsAutoSyncManager();</span>
<a href="#l4.139"></a><span id="l4.139" class="difflineminus">-</span>
<a href="#l4.140"></a><span id="l4.140" class="difflineminus">-  private:</span>
<a href="#l4.141"></a><span id="l4.141" class="difflineminus">-    ~nsAutoSyncManager();</span>
<a href="#l4.142"></a><span id="l4.142" class="difflineplus">+  nsAutoSyncManager();</span>
<a href="#l4.143"></a><span id="l4.143"> </span>
<a href="#l4.144"></a><span id="l4.144" class="difflineminus">-    void SetIdleState(IdleState st);</span>
<a href="#l4.145"></a><span id="l4.145" class="difflineminus">-    IdleState GetIdleState() const;</span>
<a href="#l4.146"></a><span id="l4.146" class="difflineminus">-    nsresult StartIdleProcessing();</span>
<a href="#l4.147"></a><span id="l4.147" class="difflineminus">-    nsresult AutoUpdateFolders();</span>
<a href="#l4.148"></a><span id="l4.148" class="difflineminus">-    void ScheduleFolderForOfflineDownload(nsIAutoSyncState *aAutoSyncStateObj);</span>
<a href="#l4.149"></a><span id="l4.149" class="difflineminus">-    nsresult DownloadMessagesForOffline(nsIAutoSyncState *aAutoSyncStateObj, uint32_t aSizeLimit = 0);</span>
<a href="#l4.150"></a><span id="l4.150" class="difflineminus">-    nsresult HandleDownloadErrorFor(nsIAutoSyncState *aAutoSyncStateObj, const nsresult error);</span>
<a href="#l4.151"></a><span id="l4.151" class="difflineplus">+ private:</span>
<a href="#l4.152"></a><span id="l4.152" class="difflineplus">+  ~nsAutoSyncManager();</span>
<a href="#l4.153"></a><span id="l4.153"> </span>
<a href="#l4.154"></a><span id="l4.154" class="difflineminus">-    // Helper methods for priority Q operations</span>
<a href="#l4.155"></a><span id="l4.155" class="difflineminus">-    static</span>
<a href="#l4.156"></a><span id="l4.156" class="difflineminus">-    void ChainFoldersInQ(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l4.157"></a><span id="l4.157" class="difflineminus">-                          nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aChainedQ);</span>
<a href="#l4.158"></a><span id="l4.158" class="difflineminus">-    static</span>
<a href="#l4.159"></a><span id="l4.159" class="difflineminus">-    nsIAutoSyncState* SearchQForSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l4.160"></a><span id="l4.160" class="difflineminus">-                          nsIAutoSyncState *aAutoSyncStateObj, int32_t aStartIdx, int32_t *aIndex = nullptr);</span>
<a href="#l4.161"></a><span id="l4.161" class="difflineminus">-    static</span>
<a href="#l4.162"></a><span id="l4.162" class="difflineminus">-    bool DoesQContainAnySiblingOf(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l4.163"></a><span id="l4.163" class="difflineminus">-                          nsIAutoSyncState *aAutoSyncStateObj, const int32_t aState,</span>
<a href="#l4.164"></a><span id="l4.164" class="difflineminus">-                          int32_t *aIndex = nullptr);</span>
<a href="#l4.165"></a><span id="l4.165" class="difflineminus">-    static</span>
<a href="#l4.166"></a><span id="l4.166" class="difflineminus">-    nsIAutoSyncState* GetNextSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l4.167"></a><span id="l4.167" class="difflineminus">-                          nsIAutoSyncState *aAutoSyncStateObj, int32_t *aIndex = nullptr);</span>
<a href="#l4.168"></a><span id="l4.168" class="difflineminus">-    static</span>
<a href="#l4.169"></a><span id="l4.169" class="difflineminus">-    nsIAutoSyncState* GetHighestPrioSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l4.170"></a><span id="l4.170" class="difflineminus">-                          nsIAutoSyncState *aAutoSyncStateObj, int32_t *aIndex = nullptr);</span>
<a href="#l4.171"></a><span id="l4.171" class="difflineplus">+  void SetIdleState(IdleState st);</span>
<a href="#l4.172"></a><span id="l4.172" class="difflineplus">+  IdleState GetIdleState() const;</span>
<a href="#l4.173"></a><span id="l4.173" class="difflineplus">+  nsresult StartIdleProcessing();</span>
<a href="#l4.174"></a><span id="l4.174" class="difflineplus">+  nsresult AutoUpdateFolders();</span>
<a href="#l4.175"></a><span id="l4.175" class="difflineplus">+  void ScheduleFolderForOfflineDownload(nsIAutoSyncState *aAutoSyncStateObj);</span>
<a href="#l4.176"></a><span id="l4.176" class="difflineplus">+  nsresult DownloadMessagesForOffline(nsIAutoSyncState *aAutoSyncStateObj,</span>
<a href="#l4.177"></a><span id="l4.177" class="difflineplus">+                                      uint32_t aSizeLimit = 0);</span>
<a href="#l4.178"></a><span id="l4.178" class="difflineplus">+  nsresult HandleDownloadErrorFor(nsIAutoSyncState *aAutoSyncStateObj,</span>
<a href="#l4.179"></a><span id="l4.179" class="difflineplus">+                                  const nsresult error);</span>
<a href="#l4.180"></a><span id="l4.180"> </span>
<a href="#l4.181"></a><span id="l4.181" class="difflineminus">-    /// timer to process existing keys and updates</span>
<a href="#l4.182"></a><span id="l4.182" class="difflineminus">-    void InitTimer();</span>
<a href="#l4.183"></a><span id="l4.183" class="difflineminus">-    static void TimerCallback(nsITimer *aTimer, void *aClosure);</span>
<a href="#l4.184"></a><span id="l4.184" class="difflineminus">-    void StopTimer();</span>
<a href="#l4.185"></a><span id="l4.185" class="difflineminus">-    void StartTimerIfNeeded();</span>
<a href="#l4.186"></a><span id="l4.186" class="difflineplus">+  // Helper methods for priority Q operations</span>
<a href="#l4.187"></a><span id="l4.187" class="difflineplus">+  static void ChainFoldersInQ(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l4.188"></a><span id="l4.188" class="difflineplus">+                              nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aChainedQ);</span>
<a href="#l4.189"></a><span id="l4.189" class="difflineplus">+  static nsIAutoSyncState *SearchQForSibling(</span>
<a href="#l4.190"></a><span id="l4.190" class="difflineplus">+      const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l4.191"></a><span id="l4.191" class="difflineplus">+      nsIAutoSyncState *aAutoSyncStateObj, int32_t aStartIdx,</span>
<a href="#l4.192"></a><span id="l4.192" class="difflineplus">+      int32_t *aIndex = nullptr);</span>
<a href="#l4.193"></a><span id="l4.193" class="difflineplus">+  static bool DoesQContainAnySiblingOf(</span>
<a href="#l4.194"></a><span id="l4.194" class="difflineplus">+      const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l4.195"></a><span id="l4.195" class="difflineplus">+      nsIAutoSyncState *aAutoSyncStateObj, const int32_t aState,</span>
<a href="#l4.196"></a><span id="l4.196" class="difflineplus">+      int32_t *aIndex = nullptr);</span>
<a href="#l4.197"></a><span id="l4.197" class="difflineplus">+  static nsIAutoSyncState *GetNextSibling(</span>
<a href="#l4.198"></a><span id="l4.198" class="difflineplus">+      const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l4.199"></a><span id="l4.199" class="difflineplus">+      nsIAutoSyncState *aAutoSyncStateObj, int32_t *aIndex = nullptr);</span>
<a href="#l4.200"></a><span id="l4.200" class="difflineplus">+  static nsIAutoSyncState *GetHighestPrioSibling(</span>
<a href="#l4.201"></a><span id="l4.201" class="difflineplus">+      const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l4.202"></a><span id="l4.202" class="difflineplus">+      nsIAutoSyncState *aAutoSyncStateObj, int32_t *aIndex = nullptr);</span>
<a href="#l4.203"></a><span id="l4.203"> </span>
<a href="#l4.204"></a><span id="l4.204" class="difflineminus">-    /// pref helpers</span>
<a href="#l4.205"></a><span id="l4.205" class="difflineminus">-    uint32_t GetUpdateIntervalFor(nsIAutoSyncState *aAutoSyncStateObj);</span>
<a href="#l4.206"></a><span id="l4.206" class="difflineplus">+  /// timer to process existing keys and updates</span>
<a href="#l4.207"></a><span id="l4.207" class="difflineplus">+  void InitTimer();</span>
<a href="#l4.208"></a><span id="l4.208" class="difflineplus">+  static void TimerCallback(nsITimer *aTimer, void *aClosure);</span>
<a href="#l4.209"></a><span id="l4.209" class="difflineplus">+  void StopTimer();</span>
<a href="#l4.210"></a><span id="l4.210" class="difflineplus">+  void StartTimerIfNeeded();</span>
<a href="#l4.211"></a><span id="l4.211" class="difflineplus">+</span>
<a href="#l4.212"></a><span id="l4.212" class="difflineplus">+  /// pref helpers</span>
<a href="#l4.213"></a><span id="l4.213" class="difflineplus">+  uint32_t GetUpdateIntervalFor(nsIAutoSyncState *aAutoSyncStateObj);</span>
<a href="#l4.214"></a><span id="l4.214"> </span>
<a href="#l4.215"></a><span id="l4.215" class="difflineminus">-  protected:</span>
<a href="#l4.216"></a><span id="l4.216" class="difflineminus">-    nsCOMPtr&lt;nsIAutoSyncMsgStrategy&gt; mMsgStrategyImpl;</span>
<a href="#l4.217"></a><span id="l4.217" class="difflineminus">-    nsCOMPtr&lt;nsIAutoSyncFolderStrategy&gt; mFolderStrategyImpl;</span>
<a href="#l4.218"></a><span id="l4.218" class="difflineminus">-    // contains the folders that will be downloaded on background</span>
<a href="#l4.219"></a><span id="l4.219" class="difflineminus">-    nsCOMArray&lt;nsIAutoSyncState&gt; mPriorityQ;</span>
<a href="#l4.220"></a><span id="l4.220" class="difflineminus">-    // contains the folders that will be examined for existing headers and</span>
<a href="#l4.221"></a><span id="l4.221" class="difflineminus">-    // adds the headers we don't have offline into the autosyncState</span>
<a href="#l4.222"></a><span id="l4.222" class="difflineminus">-    // object's download queue.</span>
<a href="#l4.223"></a><span id="l4.223" class="difflineminus">-    nsCOMArray&lt;nsIAutoSyncState&gt; mDiscoveryQ;</span>
<a href="#l4.224"></a><span id="l4.224" class="difflineminus">-    // contains the folders that will be checked for new messages with STATUS,</span>
<a href="#l4.225"></a><span id="l4.225" class="difflineminus">-    // and if there are any, we'll call UpdateFolder on them.</span>
<a href="#l4.226"></a><span id="l4.226" class="difflineminus">-    nsCOMArray&lt;nsIAutoSyncState&gt; mUpdateQ;</span>
<a href="#l4.227"></a><span id="l4.227" class="difflineminus">-    // this is the update state for the current folder.</span>
<a href="#l4.228"></a><span id="l4.228" class="difflineminus">-    UpdateState mUpdateState;</span>
<a href="#l4.229"></a><span id="l4.229" class="difflineplus">+ protected:</span>
<a href="#l4.230"></a><span id="l4.230" class="difflineplus">+  nsCOMPtr&lt;nsIAutoSyncMsgStrategy&gt; mMsgStrategyImpl;</span>
<a href="#l4.231"></a><span id="l4.231" class="difflineplus">+  nsCOMPtr&lt;nsIAutoSyncFolderStrategy&gt; mFolderStrategyImpl;</span>
<a href="#l4.232"></a><span id="l4.232" class="difflineplus">+  // contains the folders that will be downloaded on background</span>
<a href="#l4.233"></a><span id="l4.233" class="difflineplus">+  nsCOMArray&lt;nsIAutoSyncState&gt; mPriorityQ;</span>
<a href="#l4.234"></a><span id="l4.234" class="difflineplus">+  // contains the folders that will be examined for existing headers and</span>
<a href="#l4.235"></a><span id="l4.235" class="difflineplus">+  // adds the headers we don't have offline into the autosyncState</span>
<a href="#l4.236"></a><span id="l4.236" class="difflineplus">+  // object's download queue.</span>
<a href="#l4.237"></a><span id="l4.237" class="difflineplus">+  nsCOMArray&lt;nsIAutoSyncState&gt; mDiscoveryQ;</span>
<a href="#l4.238"></a><span id="l4.238" class="difflineplus">+  // contains the folders that will be checked for new messages with STATUS,</span>
<a href="#l4.239"></a><span id="l4.239" class="difflineplus">+  // and if there are any, we'll call UpdateFolder on them.</span>
<a href="#l4.240"></a><span id="l4.240" class="difflineplus">+  nsCOMArray&lt;nsIAutoSyncState&gt; mUpdateQ;</span>
<a href="#l4.241"></a><span id="l4.241" class="difflineplus">+  // this is the update state for the current folder.</span>
<a href="#l4.242"></a><span id="l4.242" class="difflineplus">+  UpdateState mUpdateState;</span>
<a href="#l4.243"></a><span id="l4.243"> </span>
<a href="#l4.244"></a><span id="l4.244" class="difflineminus">-    // This is set if auto sync has been completely paused.</span>
<a href="#l4.245"></a><span id="l4.245" class="difflineminus">-    bool mPaused;</span>
<a href="#l4.246"></a><span id="l4.246" class="difflineminus">-    // This is set if we've finished startup and should start</span>
<a href="#l4.247"></a><span id="l4.247" class="difflineminus">-    // paying attention to idle notifications.</span>
<a href="#l4.248"></a><span id="l4.248" class="difflineminus">-    bool mStartupDone;</span>
<a href="#l4.249"></a><span id="l4.249" class="difflineplus">+  // This is set if auto sync has been completely paused.</span>
<a href="#l4.250"></a><span id="l4.250" class="difflineplus">+  bool mPaused;</span>
<a href="#l4.251"></a><span id="l4.251" class="difflineplus">+  // This is set if we've finished startup and should start</span>
<a href="#l4.252"></a><span id="l4.252" class="difflineplus">+  // paying attention to idle notifications.</span>
<a href="#l4.253"></a><span id="l4.253" class="difflineplus">+  bool mStartupDone;</span>
<a href="#l4.254"></a><span id="l4.254"> </span>
<a href="#l4.255"></a><span id="l4.255" class="difflineminus">-  private:</span>
<a href="#l4.256"></a><span id="l4.256" class="difflineminus">-    uint32_t mGroupSize;</span>
<a href="#l4.257"></a><span id="l4.257" class="difflineminus">-    IdleState mIdleState;</span>
<a href="#l4.258"></a><span id="l4.258" class="difflineminus">-    int32_t mDownloadModel;</span>
<a href="#l4.259"></a><span id="l4.259" class="difflineminus">-    nsCOMPtr&lt;nsIIdleService&gt; mIdleService;</span>
<a href="#l4.260"></a><span id="l4.260" class="difflineminus">-    nsCOMPtr&lt;nsITimer&gt; mTimer;</span>
<a href="#l4.261"></a><span id="l4.261" class="difflineminus">-    nsTObserverArray&lt;nsCOMPtr&lt;nsIAutoSyncMgrListener&gt; &gt; mListeners;</span>
<a href="#l4.262"></a><span id="l4.262" class="difflineplus">+ private:</span>
<a href="#l4.263"></a><span id="l4.263" class="difflineplus">+  uint32_t mGroupSize;</span>
<a href="#l4.264"></a><span id="l4.264" class="difflineplus">+  IdleState mIdleState;</span>
<a href="#l4.265"></a><span id="l4.265" class="difflineplus">+  int32_t mDownloadModel;</span>
<a href="#l4.266"></a><span id="l4.266" class="difflineplus">+  nsCOMPtr&lt;nsIIdleService&gt; mIdleService;</span>
<a href="#l4.267"></a><span id="l4.267" class="difflineplus">+  nsCOMPtr&lt;nsITimer&gt; mTimer;</span>
<a href="#l4.268"></a><span id="l4.268" class="difflineplus">+  nsTObserverArray&lt;nsCOMPtr&lt;nsIAutoSyncMgrListener&gt; &gt; mListeners;</span>
<a href="#l4.269"></a><span id="l4.269"> };</span>
<a href="#l4.270"></a><span id="l4.270"> </span>
<a href="#l4.271"></a><span id="l4.271"> #endif</span>
<a href="#l4.272"></a><span id="l4.272"> </span>
<a href="#l4.273"></a><span id="l4.273"> /*</span>
<a href="#l4.274"></a><span id="l4.274"> How queues inter-relate:</span>
<a href="#l4.275"></a><span id="l4.275"> </span>
<a href="#l4.276"></a><span id="l4.276"> nsAutoSyncState has an internal priority queue to store messages waiting to be</span>
<a href="#l4.277"></a><span id="l4.277" class="difflineat">@@ -220,23 +221,24 @@ change in this queue:</span>
<a href="#l4.278"></a><span id="l4.278"> </span>
<a href="#l4.279"></a><span id="l4.279"> 1) nsImapMailFolder::HeaderFetchCompleted: is triggered when TB notices that</span>
<a href="#l4.280"></a><span id="l4.280"> there are pending messages on the server -- via IDLE command from the server,</span>
<a href="#l4.281"></a><span id="l4.281"> via explicit select from the user, or via automatic Update during idle time. If</span>
<a href="#l4.282"></a><span id="l4.282"> it turns out that there are pending messages on the server, it adds them into</span>
<a href="#l4.283"></a><span id="l4.283"> nsAutoSyncState's download queue.</span>
<a href="#l4.284"></a><span id="l4.284"> </span>
<a href="#l4.285"></a><span id="l4.285"> 2) nsAutoSyncState::ProcessExistingHeaders: is triggered for every imap folder</span>
<a href="#l4.286"></a><span id="l4.286" class="difflineminus">-every hour or so (see kAutoSyncFreq). nsAutoSyncManager uses an internal queue called Discovery</span>
<a href="#l4.287"></a><span id="l4.287" class="difflineminus">-queue to keep track of this task. The purpose of ProcessExistingHeaders()</span>
<a href="#l4.288"></a><span id="l4.288" class="difflineminus">-method is to check existing headers of a given folder in batches and discover</span>
<a href="#l4.289"></a><span id="l4.289" class="difflineminus">-the messages without bodies, in asynchronous fashion. This process is</span>
<a href="#l4.290"></a><span id="l4.290" class="difflineminus">-sequential, one and only one folder at any given time, very similar to</span>
<a href="#l4.291"></a><span id="l4.291" class="difflineminus">-indexing. Again, if it turns out that the folder in hand has messages w/o</span>
<a href="#l4.292"></a><span id="l4.292" class="difflineminus">-bodies, ProcessExistingHeaders adds them into nsAutoSyncState's download queue.</span>
<a href="#l4.293"></a><span id="l4.293" class="difflineplus">+every hour or so (see kAutoSyncFreq). nsAutoSyncManager uses an internal queue</span>
<a href="#l4.294"></a><span id="l4.294" class="difflineplus">+called Discovery queue to keep track of this task. The purpose of</span>
<a href="#l4.295"></a><span id="l4.295" class="difflineplus">+ProcessExistingHeaders() method is to check existing headers of a given folder</span>
<a href="#l4.296"></a><span id="l4.296" class="difflineplus">+in batches and discover the messages without bodies, in asynchronous fashion.</span>
<a href="#l4.297"></a><span id="l4.297" class="difflineplus">+This process is sequential, one and only one folder at any given time, very</span>
<a href="#l4.298"></a><span id="l4.298" class="difflineplus">+similar to indexing. Again, if it turns out that the folder in hand has messages</span>
<a href="#l4.299"></a><span id="l4.299" class="difflineplus">+w/o bodies, ProcessExistingHeaders adds them into nsAutoSyncState's download</span>
<a href="#l4.300"></a><span id="l4.300" class="difflineplus">+queue.</span>
<a href="#l4.301"></a><span id="l4.301"> </span>
<a href="#l4.302"></a><span id="l4.302"> Any change in nsAutoSyncState's download queue, notifies nsAutoSyncManager and</span>
<a href="#l4.303"></a><span id="l4.303"> nsAutoSyncManager puts the requesting  nsAutoSyncState into its internal</span>
<a href="#l4.304"></a><span id="l4.304"> priority queue (called mPriorityQ) -- if the folder is not already there.</span>
<a href="#l4.305"></a><span id="l4.305"> nsAutoSyncFolderStrategy object determines the order in this queue. This queue</span>
<a href="#l4.306"></a><span id="l4.306"> is processed in two modes: chained and parallel.</span>
<a href="#l4.307"></a><span id="l4.307"> </span>
<a href="#l4.308"></a><span id="l4.308"> i) Chained: One folder per imap server any given time. Folders owned by</span>
<a href="#l4.309"></a><span id="l4.309" class="difflineat">@@ -250,12 +252,13 @@ time a batch completed for an imap serve</span>
<a href="#l4.310"></a><span id="l4.310"> So, lets say that updating a sub-folder starts downloading message immediately,</span>
<a href="#l4.311"></a><span id="l4.311"> when an higher priority folder is added into the queue, nsAutoSyncManager</span>
<a href="#l4.312"></a><span id="l4.312"> switches to this higher priority folder instead of processing the next group of</span>
<a href="#l4.313"></a><span id="l4.313"> messages of the lower priority one. Setting group size too high might delay</span>
<a href="#l4.314"></a><span id="l4.314"> this switch at worst.</span>
<a href="#l4.315"></a><span id="l4.315"> </span>
<a href="#l4.316"></a><span id="l4.316"> And finally, Update queue helps nsAutoSyncManager to keep track of folders</span>
<a href="#l4.317"></a><span id="l4.317"> waiting to be updated. With the latest change, we update one and only one</span>
<a href="#l4.318"></a><span id="l4.318" class="difflineminus">-folder at any given time. Default frequency of updating is 10 min (kDefaultUpdateInterval).</span>
<a href="#l4.319"></a><span id="l4.319" class="difflineminus">-We add folders into the update queue during idle time, if they are not in mPriorityQ already.</span>
<a href="#l4.320"></a><span id="l4.320" class="difflineplus">+folder at any given time. Default frequency of updating is 10 min</span>
<a href="#l4.321"></a><span id="l4.321" class="difflineplus">+(kDefaultUpdateInterval). We add folders into the update queue during idle time,</span>
<a href="#l4.322"></a><span id="l4.322" class="difflineplus">+if they are not in mPriorityQ already.</span>
<a href="#l4.323"></a><span id="l4.323"> </span>
<a href="#l4.324"></a><span id="l4.324"> */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/imap/src/nsAutoSyncState.cpp</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/imap/src/nsAutoSyncState.cpp</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -15,188 +15,179 @@</span>
<a href="#l5.4"></a><span id="l5.4"> #include &quot;nsServiceManagerUtils.h&quot;</span>
<a href="#l5.5"></a><span id="l5.5"> #include &quot;nsComponentManagerUtils.h&quot;</span>
<a href="#l5.6"></a><span id="l5.6"> #include &quot;nsIMutableArray.h&quot;</span>
<a href="#l5.7"></a><span id="l5.7"> #include &quot;nsArrayUtils.h&quot;</span>
<a href="#l5.8"></a><span id="l5.8"> #include &quot;mozilla/Logging.h&quot;</span>
<a href="#l5.9"></a><span id="l5.9"> </span>
<a href="#l5.10"></a><span id="l5.10"> using namespace mozilla;</span>
<a href="#l5.11"></a><span id="l5.11"> </span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-extern LazyLogModule gAutoSyncLog; // defined in nsAutoSyncManager.cpp</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+extern LazyLogModule gAutoSyncLog;  // defined in nsAutoSyncManager.cpp</span>
<a href="#l5.14"></a><span id="l5.14"> </span>
<a href="#l5.15"></a><span id="l5.15" class="difflineminus">-MsgStrategyComparatorAdaptor::MsgStrategyComparatorAdaptor(nsIAutoSyncMsgStrategy* aStrategy,</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineminus">-  nsIMsgFolder *aFolder, nsIMsgDatabase *aDatabase) : mStrategy(aStrategy), mFolder(aFolder),</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineminus">-    mDatabase(aDatabase)</span>
<a href="#l5.18"></a><span id="l5.18" class="difflineminus">-{</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineminus">-}</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineplus">+MsgStrategyComparatorAdaptor::MsgStrategyComparatorAdaptor(</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+    nsIAutoSyncMsgStrategy *aStrategy, nsIMsgFolder *aFolder,</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+    nsIMsgDatabase *aDatabase)</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+    : mStrategy(aStrategy), mFolder(aFolder), mDatabase(aDatabase) {}</span>
<a href="#l5.24"></a><span id="l5.24"> </span>
<a href="#l5.25"></a><span id="l5.25"> /** @return True if the elements are equals; false otherwise. */</span>
<a href="#l5.26"></a><span id="l5.26" class="difflineminus">-bool MsgStrategyComparatorAdaptor::Equals(const nsMsgKey&amp; a, const nsMsgKey&amp; b) const</span>
<a href="#l5.27"></a><span id="l5.27" class="difflineminus">-{</span>
<a href="#l5.28"></a><span id="l5.28" class="difflineplus">+bool MsgStrategyComparatorAdaptor::Equals(const nsMsgKey &amp;a,</span>
<a href="#l5.29"></a><span id="l5.29" class="difflineplus">+                                          const nsMsgKey &amp;b) const {</span>
<a href="#l5.30"></a><span id="l5.30">   nsCOMPtr&lt;nsIMsgDBHdr&gt; hdrA;</span>
<a href="#l5.31"></a><span id="l5.31">   nsCOMPtr&lt;nsIMsgDBHdr&gt; hdrB;</span>
<a href="#l5.32"></a><span id="l5.32"> </span>
<a href="#l5.33"></a><span id="l5.33">   mDatabase-&gt;GetMsgHdrForKey(a, getter_AddRefs(hdrA));</span>
<a href="#l5.34"></a><span id="l5.34">   mDatabase-&gt;GetMsgHdrForKey(b, getter_AddRefs(hdrB));</span>
<a href="#l5.35"></a><span id="l5.35"> </span>
<a href="#l5.36"></a><span id="l5.36" class="difflineminus">-  if (hdrA &amp;&amp; hdrB)</span>
<a href="#l5.37"></a><span id="l5.37" class="difflineminus">-  {</span>
<a href="#l5.38"></a><span id="l5.38" class="difflineplus">+  if (hdrA &amp;&amp; hdrB) {</span>
<a href="#l5.39"></a><span id="l5.39">     nsresult rv = NS_OK;</span>
<a href="#l5.40"></a><span id="l5.40">     nsAutoSyncStrategyDecisionType decision = nsAutoSyncStrategyDecisions::Same;</span>
<a href="#l5.41"></a><span id="l5.41"> </span>
<a href="#l5.42"></a><span id="l5.42" class="difflineminus">-    if (mStrategy)</span>
<a href="#l5.43"></a><span id="l5.43" class="difflineminus">-      rv = mStrategy-&gt;Sort(mFolder, hdrA, hdrB, &amp;decision);</span>
<a href="#l5.44"></a><span id="l5.44" class="difflineplus">+    if (mStrategy) rv = mStrategy-&gt;Sort(mFolder, hdrA, hdrB, &amp;decision);</span>
<a href="#l5.45"></a><span id="l5.45"> </span>
<a href="#l5.46"></a><span id="l5.46">     if (NS_SUCCEEDED(rv))</span>
<a href="#l5.47"></a><span id="l5.47">       return (decision == nsAutoSyncStrategyDecisions::Same);</span>
<a href="#l5.48"></a><span id="l5.48">   }</span>
<a href="#l5.49"></a><span id="l5.49"> </span>
<a href="#l5.50"></a><span id="l5.50">   return false;</span>
<a href="#l5.51"></a><span id="l5.51"> }</span>
<a href="#l5.52"></a><span id="l5.52"> </span>
<a href="#l5.53"></a><span id="l5.53"> /** @return True if (a &lt; b); false otherwise. */</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineminus">-bool MsgStrategyComparatorAdaptor::LessThan(const nsMsgKey&amp; a, const nsMsgKey&amp; b) const</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineminus">-{</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+bool MsgStrategyComparatorAdaptor::LessThan(const nsMsgKey &amp;a,</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+                                            const nsMsgKey &amp;b) const {</span>
<a href="#l5.58"></a><span id="l5.58">   nsCOMPtr&lt;nsIMsgDBHdr&gt; hdrA;</span>
<a href="#l5.59"></a><span id="l5.59">   nsCOMPtr&lt;nsIMsgDBHdr&gt; hdrB;</span>
<a href="#l5.60"></a><span id="l5.60"> </span>
<a href="#l5.61"></a><span id="l5.61">   mDatabase-&gt;GetMsgHdrForKey(a, getter_AddRefs(hdrA));</span>
<a href="#l5.62"></a><span id="l5.62">   mDatabase-&gt;GetMsgHdrForKey(b, getter_AddRefs(hdrB));</span>
<a href="#l5.63"></a><span id="l5.63"> </span>
<a href="#l5.64"></a><span id="l5.64" class="difflineminus">-  if (hdrA &amp;&amp; hdrB)</span>
<a href="#l5.65"></a><span id="l5.65" class="difflineminus">-  {</span>
<a href="#l5.66"></a><span id="l5.66" class="difflineplus">+  if (hdrA &amp;&amp; hdrB) {</span>
<a href="#l5.67"></a><span id="l5.67">     nsresult rv = NS_OK;</span>
<a href="#l5.68"></a><span id="l5.68">     nsAutoSyncStrategyDecisionType decision = nsAutoSyncStrategyDecisions::Same;</span>
<a href="#l5.69"></a><span id="l5.69"> </span>
<a href="#l5.70"></a><span id="l5.70" class="difflineminus">-    if (mStrategy)</span>
<a href="#l5.71"></a><span id="l5.71" class="difflineminus">-      rv = mStrategy-&gt;Sort(mFolder, hdrA, hdrB, &amp;decision);</span>
<a href="#l5.72"></a><span id="l5.72" class="difflineplus">+    if (mStrategy) rv = mStrategy-&gt;Sort(mFolder, hdrA, hdrB, &amp;decision);</span>
<a href="#l5.73"></a><span id="l5.73"> </span>
<a href="#l5.74"></a><span id="l5.74">     if (NS_SUCCEEDED(rv))</span>
<a href="#l5.75"></a><span id="l5.75">       return (decision == nsAutoSyncStrategyDecisions::Lower);</span>
<a href="#l5.76"></a><span id="l5.76">   }</span>
<a href="#l5.77"></a><span id="l5.77"> </span>
<a href="#l5.78"></a><span id="l5.78">   return false;</span>
<a href="#l5.79"></a><span id="l5.79"> }</span>
<a href="#l5.80"></a><span id="l5.80"> </span>
<a href="#l5.81"></a><span id="l5.81" class="difflineminus">-nsAutoSyncState::nsAutoSyncState(nsImapMailFolder *aOwnerFolder, PRTime aLastSyncTime)</span>
<a href="#l5.82"></a><span id="l5.82" class="difflineminus">-  : mSyncState(stCompletedIdle), mOffset(0U), mLastOffset(0U), mLastServerTotal(0),</span>
<a href="#l5.83"></a><span id="l5.83" class="difflineminus">-    mLastServerRecent(0), mLastServerUnseen(0), mLastNextUID(0),</span>
<a href="#l5.84"></a><span id="l5.84" class="difflineminus">-    mLastSyncTime(aLastSyncTime), mLastUpdateTime(0UL), mProcessPointer(0U),</span>
<a href="#l5.85"></a><span id="l5.85" class="difflineminus">-    mIsDownloadQChanged(false), mRetryCounter(0U)</span>
<a href="#l5.86"></a><span id="l5.86" class="difflineminus">-{</span>
<a href="#l5.87"></a><span id="l5.87" class="difflineminus">-  mOwnerFolder = do_GetWeakReference(static_cast&lt;nsIMsgImapMailFolder*&gt;(aOwnerFolder));</span>
<a href="#l5.88"></a><span id="l5.88" class="difflineplus">+nsAutoSyncState::nsAutoSyncState(nsImapMailFolder *aOwnerFolder,</span>
<a href="#l5.89"></a><span id="l5.89" class="difflineplus">+                                 PRTime aLastSyncTime)</span>
<a href="#l5.90"></a><span id="l5.90" class="difflineplus">+    : mSyncState(stCompletedIdle),</span>
<a href="#l5.91"></a><span id="l5.91" class="difflineplus">+      mOffset(0U),</span>
<a href="#l5.92"></a><span id="l5.92" class="difflineplus">+      mLastOffset(0U),</span>
<a href="#l5.93"></a><span id="l5.93" class="difflineplus">+      mLastServerTotal(0),</span>
<a href="#l5.94"></a><span id="l5.94" class="difflineplus">+      mLastServerRecent(0),</span>
<a href="#l5.95"></a><span id="l5.95" class="difflineplus">+      mLastServerUnseen(0),</span>
<a href="#l5.96"></a><span id="l5.96" class="difflineplus">+      mLastNextUID(0),</span>
<a href="#l5.97"></a><span id="l5.97" class="difflineplus">+      mLastSyncTime(aLastSyncTime),</span>
<a href="#l5.98"></a><span id="l5.98" class="difflineplus">+      mLastUpdateTime(0UL),</span>
<a href="#l5.99"></a><span id="l5.99" class="difflineplus">+      mProcessPointer(0U),</span>
<a href="#l5.100"></a><span id="l5.100" class="difflineplus">+      mIsDownloadQChanged(false),</span>
<a href="#l5.101"></a><span id="l5.101" class="difflineplus">+      mRetryCounter(0U) {</span>
<a href="#l5.102"></a><span id="l5.102" class="difflineplus">+  mOwnerFolder =</span>
<a href="#l5.103"></a><span id="l5.103" class="difflineplus">+      do_GetWeakReference(static_cast&lt;nsIMsgImapMailFolder *&gt;(aOwnerFolder));</span>
<a href="#l5.104"></a><span id="l5.104"> }</span>
<a href="#l5.105"></a><span id="l5.105"> </span>
<a href="#l5.106"></a><span id="l5.106" class="difflineminus">-nsAutoSyncState::~nsAutoSyncState()</span>
<a href="#l5.107"></a><span id="l5.107" class="difflineminus">-{</span>
<a href="#l5.108"></a><span id="l5.108" class="difflineminus">-}</span>
<a href="#l5.109"></a><span id="l5.109" class="difflineplus">+nsAutoSyncState::~nsAutoSyncState() {}</span>
<a href="#l5.110"></a><span id="l5.110"> </span>
<a href="#l5.111"></a><span id="l5.111"> // TODO:XXXemre should be implemented when we start</span>
<a href="#l5.112"></a><span id="l5.112"> // doing space management</span>
<a href="#l5.113"></a><span id="l5.113" class="difflineminus">-nsresult nsAutoSyncState::ManageStorageSpace()</span>
<a href="#l5.114"></a><span id="l5.114" class="difflineminus">-{</span>
<a href="#l5.115"></a><span id="l5.115" class="difflineminus">-  return NS_OK;</span>
<a href="#l5.116"></a><span id="l5.116" class="difflineminus">-}</span>
<a href="#l5.117"></a><span id="l5.117" class="difflineplus">+nsresult nsAutoSyncState::ManageStorageSpace() { return NS_OK; }</span>
<a href="#l5.118"></a><span id="l5.118"> </span>
<a href="#l5.119"></a><span id="l5.119" class="difflineminus">-nsresult nsAutoSyncState::PlaceIntoDownloadQ(const nsTArray&lt;nsMsgKey&gt; &amp;aMsgKeyList)</span>
<a href="#l5.120"></a><span id="l5.120" class="difflineminus">-{</span>
<a href="#l5.121"></a><span id="l5.121" class="difflineplus">+nsresult nsAutoSyncState::PlaceIntoDownloadQ(</span>
<a href="#l5.122"></a><span id="l5.122" class="difflineplus">+    const nsTArray&lt;nsMsgKey&gt; &amp;aMsgKeyList) {</span>
<a href="#l5.123"></a><span id="l5.123">   nsresult rv = NS_OK;</span>
<a href="#l5.124"></a><span id="l5.124" class="difflineminus">-  if (!aMsgKeyList.IsEmpty())</span>
<a href="#l5.125"></a><span id="l5.125" class="difflineminus">-  {</span>
<a href="#l5.126"></a><span id="l5.126" class="difflineminus">-    nsCOMPtr &lt;nsIMsgFolder&gt; folder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.127"></a><span id="l5.127" class="difflineplus">+  if (!aMsgKeyList.IsEmpty()) {</span>
<a href="#l5.128"></a><span id="l5.128" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolder&gt; folder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.129"></a><span id="l5.129">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.130"></a><span id="l5.130"> </span>
<a href="#l5.131"></a><span id="l5.131">     nsCOMPtr&lt;nsIMsgDatabase&gt; database;</span>
<a href="#l5.132"></a><span id="l5.132">     rv = folder-&gt;GetMsgDatabase(getter_AddRefs(database));</span>
<a href="#l5.133"></a><span id="l5.133" class="difflineminus">-    if (!database)</span>
<a href="#l5.134"></a><span id="l5.134" class="difflineminus">-      return NS_ERROR_FAILURE;</span>
<a href="#l5.135"></a><span id="l5.135" class="difflineplus">+    if (!database) return NS_ERROR_FAILURE;</span>
<a href="#l5.136"></a><span id="l5.136"> </span>
<a href="#l5.137"></a><span id="l5.137" class="difflineminus">-    nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr = do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l5.138"></a><span id="l5.138" class="difflineminus">-    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l5.139"></a><span id="l5.139" class="difflineplus">+    nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr =</span>
<a href="#l5.140"></a><span id="l5.140" class="difflineplus">+        do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l5.141"></a><span id="l5.141" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.142"></a><span id="l5.142"> </span>
<a href="#l5.143"></a><span id="l5.143">     nsCOMPtr&lt;nsIAutoSyncMsgStrategy&gt; msgStrategy;</span>
<a href="#l5.144"></a><span id="l5.144">     autoSyncMgr-&gt;GetMsgStrategy(getter_AddRefs(msgStrategy));</span>
<a href="#l5.145"></a><span id="l5.145"> </span>
<a href="#l5.146"></a><span id="l5.146">     // increase the array size</span>
<a href="#l5.147"></a><span id="l5.147">     mDownloadQ.SetCapacity(mDownloadQ.Length() + aMsgKeyList.Length());</span>
<a href="#l5.148"></a><span id="l5.148"> </span>
<a href="#l5.149"></a><span id="l5.149">     // remove excluded messages</span>
<a href="#l5.150"></a><span id="l5.150">     int32_t elemCount = aMsgKeyList.Length();</span>
<a href="#l5.151"></a><span id="l5.151" class="difflineminus">-    for (int32_t idx = 0; idx &lt; elemCount; idx++)</span>
<a href="#l5.152"></a><span id="l5.152" class="difflineminus">-    {</span>
<a href="#l5.153"></a><span id="l5.153" class="difflineplus">+    for (int32_t idx = 0; idx &lt; elemCount; idx++) {</span>
<a href="#l5.154"></a><span id="l5.154">       nsCOMPtr&lt;nsIMsgDBHdr&gt; hdr;</span>
<a href="#l5.155"></a><span id="l5.155">       bool containsKey;</span>
<a href="#l5.156"></a><span id="l5.156">       database-&gt;ContainsKey(aMsgKeyList[idx], &amp;containsKey);</span>
<a href="#l5.157"></a><span id="l5.157" class="difflineminus">-      if (!containsKey)</span>
<a href="#l5.158"></a><span id="l5.158" class="difflineminus">-        continue;</span>
<a href="#l5.159"></a><span id="l5.159" class="difflineplus">+      if (!containsKey) continue;</span>
<a href="#l5.160"></a><span id="l5.160">       rv = database-&gt;GetMsgHdrForKey(aMsgKeyList[idx], getter_AddRefs(hdr));</span>
<a href="#l5.161"></a><span id="l5.161" class="difflineminus">-      if(!hdr)</span>
<a href="#l5.162"></a><span id="l5.162" class="difflineminus">-        continue; // can't get message header, continue with the next one</span>
<a href="#l5.163"></a><span id="l5.163" class="difflineplus">+      if (!hdr)</span>
<a href="#l5.164"></a><span id="l5.164" class="difflineplus">+        continue;  // can't get message header, continue with the next one</span>
<a href="#l5.165"></a><span id="l5.165"> </span>
<a href="#l5.166"></a><span id="l5.166">       bool doesFit = true;</span>
<a href="#l5.167"></a><span id="l5.167">       rv = autoSyncMgr-&gt;DoesMsgFitDownloadCriteria(hdr, &amp;doesFit);</span>
<a href="#l5.168"></a><span id="l5.168" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; !mDownloadSet.Contains(aMsgKeyList[idx]) &amp;&amp; doesFit)</span>
<a href="#l5.169"></a><span id="l5.169" class="difflineminus">-      {</span>
<a href="#l5.170"></a><span id="l5.170" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; !mDownloadSet.Contains(aMsgKeyList[idx]) &amp;&amp;</span>
<a href="#l5.171"></a><span id="l5.171" class="difflineplus">+          doesFit) {</span>
<a href="#l5.172"></a><span id="l5.172">         bool excluded = false;</span>
<a href="#l5.173"></a><span id="l5.173" class="difflineminus">-        if (msgStrategy)</span>
<a href="#l5.174"></a><span id="l5.174" class="difflineminus">-        {</span>
<a href="#l5.175"></a><span id="l5.175" class="difflineplus">+        if (msgStrategy) {</span>
<a href="#l5.176"></a><span id="l5.176">           rv = msgStrategy-&gt;IsExcluded(folder, hdr, &amp;excluded);</span>
<a href="#l5.177"></a><span id="l5.177"> </span>
<a href="#l5.178"></a><span id="l5.178" class="difflineminus">-          if (NS_SUCCEEDED(rv) &amp;&amp; !excluded)</span>
<a href="#l5.179"></a><span id="l5.179" class="difflineminus">-          {</span>
<a href="#l5.180"></a><span id="l5.180" class="difflineplus">+          if (NS_SUCCEEDED(rv) &amp;&amp; !excluded) {</span>
<a href="#l5.181"></a><span id="l5.181">             mIsDownloadQChanged = true;</span>
<a href="#l5.182"></a><span id="l5.182">             mDownloadSet.PutEntry(aMsgKeyList[idx]);</span>
<a href="#l5.183"></a><span id="l5.183">             mDownloadQ.AppendElement(aMsgKeyList[idx]);</span>
<a href="#l5.184"></a><span id="l5.184">           }</span>
<a href="#l5.185"></a><span id="l5.185">         }</span>
<a href="#l5.186"></a><span id="l5.186">       }</span>
<a href="#l5.187"></a><span id="l5.187" class="difflineminus">-    }//endfor</span>
<a href="#l5.188"></a><span id="l5.188" class="difflineplus">+    }  // endfor</span>
<a href="#l5.189"></a><span id="l5.189"> </span>
<a href="#l5.190"></a><span id="l5.190" class="difflineminus">-    if (mIsDownloadQChanged)</span>
<a href="#l5.191"></a><span id="l5.191" class="difflineminus">-    {</span>
<a href="#l5.192"></a><span id="l5.192" class="difflineplus">+    if (mIsDownloadQChanged) {</span>
<a href="#l5.193"></a><span id="l5.193">       LogOwnerFolderName(&quot;Download Q is created for &quot;);</span>
<a href="#l5.194"></a><span id="l5.194">       LogQWithSize(mDownloadQ, 0);</span>
<a href="#l5.195"></a><span id="l5.195">       rv = autoSyncMgr-&gt;OnDownloadQChanged(this);</span>
<a href="#l5.196"></a><span id="l5.196">     }</span>
<a href="#l5.197"></a><span id="l5.197" class="difflineminus">-</span>
<a href="#l5.198"></a><span id="l5.198">   }</span>
<a href="#l5.199"></a><span id="l5.199">   return rv;</span>
<a href="#l5.200"></a><span id="l5.200"> }</span>
<a href="#l5.201"></a><span id="l5.201"> </span>
<a href="#l5.202"></a><span id="l5.202" class="difflineminus">-nsresult nsAutoSyncState::SortQueueBasedOnStrategy(nsTArray&lt;nsMsgKey&gt; &amp;aQueue)</span>
<a href="#l5.203"></a><span id="l5.203" class="difflineminus">-{</span>
<a href="#l5.204"></a><span id="l5.204" class="difflineplus">+nsresult nsAutoSyncState::SortQueueBasedOnStrategy(nsTArray&lt;nsMsgKey&gt; &amp;aQueue) {</span>
<a href="#l5.205"></a><span id="l5.205">   nsresult rv;</span>
<a href="#l5.206"></a><span id="l5.206" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; folder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.207"></a><span id="l5.207" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; folder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.208"></a><span id="l5.208">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.209"></a><span id="l5.209"> </span>
<a href="#l5.210"></a><span id="l5.210">   nsCOMPtr&lt;nsIMsgDatabase&gt; database;</span>
<a href="#l5.211"></a><span id="l5.211">   rv = folder-&gt;GetMsgDatabase(getter_AddRefs(database));</span>
<a href="#l5.212"></a><span id="l5.212" class="difflineminus">-  if (!database)</span>
<a href="#l5.213"></a><span id="l5.213" class="difflineminus">-    return NS_ERROR_FAILURE;</span>
<a href="#l5.214"></a><span id="l5.214" class="difflineplus">+  if (!database) return NS_ERROR_FAILURE;</span>
<a href="#l5.215"></a><span id="l5.215"> </span>
<a href="#l5.216"></a><span id="l5.216" class="difflineminus">-  nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr = do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l5.217"></a><span id="l5.217" class="difflineplus">+  nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr =</span>
<a href="#l5.218"></a><span id="l5.218" class="difflineplus">+      do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l5.219"></a><span id="l5.219">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.220"></a><span id="l5.220"> </span>
<a href="#l5.221"></a><span id="l5.221">   nsCOMPtr&lt;nsIAutoSyncMsgStrategy&gt; msgStrategy;</span>
<a href="#l5.222"></a><span id="l5.222">   rv = autoSyncMgr-&gt;GetMsgStrategy(getter_AddRefs(msgStrategy));</span>
<a href="#l5.223"></a><span id="l5.223">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.224"></a><span id="l5.224"> </span>
<a href="#l5.225"></a><span id="l5.225">   MsgStrategyComparatorAdaptor strategyComp(msgStrategy, folder, database);</span>
<a href="#l5.226"></a><span id="l5.226">   aQueue.Sort(strategyComp);</span>
<a href="#l5.227"></a><span id="l5.227"> </span>
<a href="#l5.228"></a><span id="l5.228">   return rv;</span>
<a href="#l5.229"></a><span id="l5.229"> }</span>
<a href="#l5.230"></a><span id="l5.230"> </span>
<a href="#l5.231"></a><span id="l5.231"> // This method is a hack to prioritize newly inserted messages,</span>
<a href="#l5.232"></a><span id="l5.232"> // without changing the size of the queue. It is required since</span>
<a href="#l5.233"></a><span id="l5.233"> // we cannot sort ranges in nsTArray.</span>
<a href="#l5.234"></a><span id="l5.234" class="difflineminus">-nsresult nsAutoSyncState::SortSubQueueBasedOnStrategy(nsTArray&lt;nsMsgKey&gt; &amp;aQueue,</span>
<a href="#l5.235"></a><span id="l5.235" class="difflineminus">-                                                      uint32_t aStartingOffset)</span>
<a href="#l5.236"></a><span id="l5.236" class="difflineminus">-{</span>
<a href="#l5.237"></a><span id="l5.237" class="difflineminus">-  NS_ASSERTION(aStartingOffset &lt; aQueue.Length(), &quot;*** Starting offset is out of range&quot;);</span>
<a href="#l5.238"></a><span id="l5.238" class="difflineplus">+nsresult nsAutoSyncState::SortSubQueueBasedOnStrategy(</span>
<a href="#l5.239"></a><span id="l5.239" class="difflineplus">+    nsTArray&lt;nsMsgKey&gt; &amp;aQueue, uint32_t aStartingOffset) {</span>
<a href="#l5.240"></a><span id="l5.240" class="difflineplus">+  NS_ASSERTION(aStartingOffset &lt; aQueue.Length(),</span>
<a href="#l5.241"></a><span id="l5.241" class="difflineplus">+               &quot;*** Starting offset is out of range&quot;);</span>
<a href="#l5.242"></a><span id="l5.242"> </span>
<a href="#l5.243"></a><span id="l5.243">   // Copy already downloaded messages into a temporary queue,</span>
<a href="#l5.244"></a><span id="l5.244">   // we want to exclude them from the sort.</span>
<a href="#l5.245"></a><span id="l5.245">   nsTArray&lt;nsMsgKey&gt; tmpQ;</span>
<a href="#l5.246"></a><span id="l5.246">   tmpQ.AppendElements(aQueue.Elements(), aStartingOffset);</span>
<a href="#l5.247"></a><span id="l5.247"> </span>
<a href="#l5.248"></a><span id="l5.248">   // Remove already downloaded messages and sort the resulting queue</span>
<a href="#l5.249"></a><span id="l5.249">   aQueue.RemoveElementsAt(0, aStartingOffset);</span>
<a href="#l5.250"></a><span id="l5.250" class="difflineat">@@ -204,556 +195,510 @@ nsresult nsAutoSyncState::SortSubQueueBa</span>
<a href="#l5.251"></a><span id="l5.251">   nsresult rv = SortQueueBasedOnStrategy(aQueue);</span>
<a href="#l5.252"></a><span id="l5.252"> </span>
<a href="#l5.253"></a><span id="l5.253">   // copy excluded messages back</span>
<a href="#l5.254"></a><span id="l5.254">   aQueue.InsertElementsAt(0, tmpQ);</span>
<a href="#l5.255"></a><span id="l5.255"> </span>
<a href="#l5.256"></a><span id="l5.256">   return rv;</span>
<a href="#l5.257"></a><span id="l5.257"> }</span>
<a href="#l5.258"></a><span id="l5.258"> </span>
<a href="#l5.259"></a><span id="l5.259" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::GetNextGroupOfMessages(uint32_t aSuggestedGroupSizeLimit,</span>
<a href="#l5.260"></a><span id="l5.260" class="difflineminus">-                                                      uint32_t *aActualGroupSize,</span>
<a href="#l5.261"></a><span id="l5.261" class="difflineminus">-                                                      nsIMutableArray **aMessagesList)</span>
<a href="#l5.262"></a><span id="l5.262" class="difflineminus">-{</span>
<a href="#l5.263"></a><span id="l5.263" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::GetNextGroupOfMessages(</span>
<a href="#l5.264"></a><span id="l5.264" class="difflineplus">+    uint32_t aSuggestedGroupSizeLimit, uint32_t *aActualGroupSize,</span>
<a href="#l5.265"></a><span id="l5.265" class="difflineplus">+    nsIMutableArray **aMessagesList) {</span>
<a href="#l5.266"></a><span id="l5.266">   NS_ENSURE_ARG_POINTER(aMessagesList);</span>
<a href="#l5.267"></a><span id="l5.267">   NS_ENSURE_ARG_POINTER(aActualGroupSize);</span>
<a href="#l5.268"></a><span id="l5.268"> </span>
<a href="#l5.269"></a><span id="l5.269">   *aActualGroupSize = 0;</span>
<a href="#l5.270"></a><span id="l5.270"> </span>
<a href="#l5.271"></a><span id="l5.271">   nsresult rv;</span>
<a href="#l5.272"></a><span id="l5.272" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; folder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.273"></a><span id="l5.273" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; folder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.274"></a><span id="l5.274">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.275"></a><span id="l5.275"> </span>
<a href="#l5.276"></a><span id="l5.276">   nsCOMPtr&lt;nsIMsgDatabase&gt; database;</span>
<a href="#l5.277"></a><span id="l5.277">   folder-&gt;GetMsgDatabase(getter_AddRefs(database));</span>
<a href="#l5.278"></a><span id="l5.278"> </span>
<a href="#l5.279"></a><span id="l5.279">   nsCOMPtr&lt;nsIMutableArray&gt; group = do_CreateInstance(NS_ARRAY_CONTRACTID);</span>
<a href="#l5.280"></a><span id="l5.280" class="difflineminus">-  if (database)</span>
<a href="#l5.281"></a><span id="l5.281" class="difflineminus">-  {</span>
<a href="#l5.282"></a><span id="l5.282" class="difflineminus">-    if (!mDownloadQ.IsEmpty())</span>
<a href="#l5.283"></a><span id="l5.283" class="difflineminus">-    {</span>
<a href="#l5.284"></a><span id="l5.284" class="difflineplus">+  if (database) {</span>
<a href="#l5.285"></a><span id="l5.285" class="difflineplus">+    if (!mDownloadQ.IsEmpty()) {</span>
<a href="#l5.286"></a><span id="l5.286">       // sort the download queue if new items are added since the last time</span>
<a href="#l5.287"></a><span id="l5.287" class="difflineminus">-      if (mIsDownloadQChanged)</span>
<a href="#l5.288"></a><span id="l5.288" class="difflineminus">-      {</span>
<a href="#l5.289"></a><span id="l5.289" class="difflineplus">+      if (mIsDownloadQChanged) {</span>
<a href="#l5.290"></a><span id="l5.290">         // we want to sort only pending messages. mOffset is</span>
<a href="#l5.291"></a><span id="l5.291">         // the position of the first pending message in the download queue</span>
<a href="#l5.292"></a><span id="l5.292" class="difflineminus">-        rv = (mOffset &gt; 0)</span>
<a href="#l5.293"></a><span id="l5.293" class="difflineminus">-          ? SortSubQueueBasedOnStrategy(mDownloadQ, mOffset)</span>
<a href="#l5.294"></a><span id="l5.294" class="difflineminus">-          : SortQueueBasedOnStrategy(mDownloadQ);</span>
<a href="#l5.295"></a><span id="l5.295" class="difflineplus">+        rv = (mOffset &gt; 0) ? SortSubQueueBasedOnStrategy(mDownloadQ, mOffset)</span>
<a href="#l5.296"></a><span id="l5.296" class="difflineplus">+                           : SortQueueBasedOnStrategy(mDownloadQ);</span>
<a href="#l5.297"></a><span id="l5.297"> </span>
<a href="#l5.298"></a><span id="l5.298" class="difflineminus">-        if (NS_SUCCEEDED(rv))</span>
<a href="#l5.299"></a><span id="l5.299" class="difflineminus">-          mIsDownloadQChanged = false;</span>
<a href="#l5.300"></a><span id="l5.300" class="difflineplus">+        if (NS_SUCCEEDED(rv)) mIsDownloadQChanged = false;</span>
<a href="#l5.301"></a><span id="l5.301">       }</span>
<a href="#l5.302"></a><span id="l5.302"> </span>
<a href="#l5.303"></a><span id="l5.303" class="difflineminus">-      nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr = do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l5.304"></a><span id="l5.304" class="difflineplus">+      nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr =</span>
<a href="#l5.305"></a><span id="l5.305" class="difflineplus">+          do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l5.306"></a><span id="l5.306">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.307"></a><span id="l5.307"> </span>
<a href="#l5.308"></a><span id="l5.308">       uint32_t msgCount = mDownloadQ.Length();</span>
<a href="#l5.309"></a><span id="l5.309">       uint32_t idx = mOffset;</span>
<a href="#l5.310"></a><span id="l5.310"> </span>
<a href="#l5.311"></a><span id="l5.311">       nsCOMPtr&lt;nsIAutoSyncMsgStrategy&gt; msgStrategy;</span>
<a href="#l5.312"></a><span id="l5.312">       autoSyncMgr-&gt;GetMsgStrategy(getter_AddRefs(msgStrategy));</span>
<a href="#l5.313"></a><span id="l5.313"> </span>
<a href="#l5.314"></a><span id="l5.314" class="difflineminus">-      for (; idx &lt; msgCount; idx++)</span>
<a href="#l5.315"></a><span id="l5.315" class="difflineminus">-      {</span>
<a href="#l5.316"></a><span id="l5.316" class="difflineplus">+      for (; idx &lt; msgCount; idx++) {</span>
<a href="#l5.317"></a><span id="l5.317">         bool containsKey = false;</span>
<a href="#l5.318"></a><span id="l5.318">         database-&gt;ContainsKey(mDownloadQ[idx], &amp;containsKey);</span>
<a href="#l5.319"></a><span id="l5.319" class="difflineminus">-        if (!containsKey)</span>
<a href="#l5.320"></a><span id="l5.320" class="difflineminus">-        {</span>
<a href="#l5.321"></a><span id="l5.321" class="difflineplus">+        if (!containsKey) {</span>
<a href="#l5.322"></a><span id="l5.322">           mDownloadSet.RemoveEntry(mDownloadQ[idx]);</span>
<a href="#l5.323"></a><span id="l5.323">           mDownloadQ.RemoveElementAt(idx--);</span>
<a href="#l5.324"></a><span id="l5.324">           msgCount--;</span>
<a href="#l5.325"></a><span id="l5.325">           continue;</span>
<a href="#l5.326"></a><span id="l5.326">         }</span>
<a href="#l5.327"></a><span id="l5.327">         nsCOMPtr&lt;nsIMsgDBHdr&gt; qhdr;</span>
<a href="#l5.328"></a><span id="l5.328">         database-&gt;GetMsgHdrForKey(mDownloadQ[idx], getter_AddRefs(qhdr));</span>
<a href="#l5.329"></a><span id="l5.329" class="difflineminus">-        if(!qhdr)</span>
<a href="#l5.330"></a><span id="l5.330" class="difflineminus">-          continue; //maybe deleted, skip it!</span>
<a href="#l5.331"></a><span id="l5.331" class="difflineplus">+        if (!qhdr) continue;  // maybe deleted, skip it!</span>
<a href="#l5.332"></a><span id="l5.332"> </span>
<a href="#l5.333"></a><span id="l5.333">         // ensure that we don't have this message body offline already,</span>
<a href="#l5.334"></a><span id="l5.334">         // possible if the user explicitly selects this message prior</span>
<a href="#l5.335"></a><span id="l5.335">         // to auto-sync kicks in</span>
<a href="#l5.336"></a><span id="l5.336">         bool hasMessageOffline;</span>
<a href="#l5.337"></a><span id="l5.337">         folder-&gt;HasMsgOffline(mDownloadQ[idx], &amp;hasMessageOffline);</span>
<a href="#l5.338"></a><span id="l5.338" class="difflineminus">-        if (hasMessageOffline)</span>
<a href="#l5.339"></a><span id="l5.339" class="difflineminus">-          continue;</span>
<a href="#l5.340"></a><span id="l5.340" class="difflineplus">+        if (hasMessageOffline) continue;</span>
<a href="#l5.341"></a><span id="l5.341"> </span>
<a href="#l5.342"></a><span id="l5.342">         // this check point allows msg strategy function</span>
<a href="#l5.343"></a><span id="l5.343">         // to do last minute decisions based on the current</span>
<a href="#l5.344"></a><span id="l5.344">         // state of TB such as the size of the message store etc.</span>
<a href="#l5.345"></a><span id="l5.345" class="difflineminus">-        if (msgStrategy)</span>
<a href="#l5.346"></a><span id="l5.346" class="difflineminus">-        {</span>
<a href="#l5.347"></a><span id="l5.347" class="difflineplus">+        if (msgStrategy) {</span>
<a href="#l5.348"></a><span id="l5.348">           bool excluded = false;</span>
<a href="#l5.349"></a><span id="l5.349" class="difflineminus">-          if (NS_SUCCEEDED(msgStrategy-&gt;IsExcluded(folder, qhdr, &amp;excluded)) &amp;&amp; excluded)</span>
<a href="#l5.350"></a><span id="l5.350" class="difflineplus">+          if (NS_SUCCEEDED(msgStrategy-&gt;IsExcluded(folder, qhdr, &amp;excluded)) &amp;&amp;</span>
<a href="#l5.351"></a><span id="l5.351" class="difflineplus">+              excluded)</span>
<a href="#l5.352"></a><span id="l5.352">             continue;</span>
<a href="#l5.353"></a><span id="l5.353">         }</span>
<a href="#l5.354"></a><span id="l5.354"> </span>
<a href="#l5.355"></a><span id="l5.355">         uint32_t msgSize;</span>
<a href="#l5.356"></a><span id="l5.356">         qhdr-&gt;GetMessageSize(&amp;msgSize);</span>
<a href="#l5.357"></a><span id="l5.357">         // ignore 0 byte messages; the imap parser asserts when we try</span>
<a href="#l5.358"></a><span id="l5.358">         // to download them, and there's no point anyway.</span>
<a href="#l5.359"></a><span id="l5.359" class="difflineminus">-        if (!msgSize)</span>
<a href="#l5.360"></a><span id="l5.360" class="difflineminus">-          continue;</span>
<a href="#l5.361"></a><span id="l5.361" class="difflineplus">+        if (!msgSize) continue;</span>
<a href="#l5.362"></a><span id="l5.362"> </span>
<a href="#l5.363"></a><span id="l5.363" class="difflineminus">-        if (!*aActualGroupSize &amp;&amp; msgSize &gt;= aSuggestedGroupSizeLimit)</span>
<a href="#l5.364"></a><span id="l5.364" class="difflineminus">-        {</span>
<a href="#l5.365"></a><span id="l5.365" class="difflineplus">+        if (!*aActualGroupSize &amp;&amp; msgSize &gt;= aSuggestedGroupSizeLimit) {</span>
<a href="#l5.366"></a><span id="l5.366">           *aActualGroupSize = msgSize;</span>
<a href="#l5.367"></a><span id="l5.367">           group-&gt;AppendElement(qhdr);</span>
<a href="#l5.368"></a><span id="l5.368">           idx++;</span>
<a href="#l5.369"></a><span id="l5.369">           break;</span>
<a href="#l5.370"></a><span id="l5.370">         }</span>
<a href="#l5.371"></a><span id="l5.371" class="difflineminus">-        if ((*aActualGroupSize) + msgSize &gt; aSuggestedGroupSizeLimit)</span>
<a href="#l5.372"></a><span id="l5.372" class="difflineminus">-          break;</span>
<a href="#l5.373"></a><span id="l5.373" class="difflineplus">+        if ((*aActualGroupSize) + msgSize &gt; aSuggestedGroupSizeLimit) break;</span>
<a href="#l5.374"></a><span id="l5.374"> </span>
<a href="#l5.375"></a><span id="l5.375">         group-&gt;AppendElement(qhdr);</span>
<a href="#l5.376"></a><span id="l5.376">         *aActualGroupSize += msgSize;</span>
<a href="#l5.377"></a><span id="l5.377" class="difflineminus">-      }// endfor</span>
<a href="#l5.378"></a><span id="l5.378" class="difflineplus">+      }  // endfor</span>
<a href="#l5.379"></a><span id="l5.379"> </span>
<a href="#l5.380"></a><span id="l5.380">       mLastOffset = mOffset;</span>
<a href="#l5.381"></a><span id="l5.381">       mOffset = idx;</span>
<a href="#l5.382"></a><span id="l5.382">     }</span>
<a href="#l5.383"></a><span id="l5.383"> </span>
<a href="#l5.384"></a><span id="l5.384">     LogOwnerFolderName(&quot;Next group of messages to be downloaded.&quot;);</span>
<a href="#l5.385"></a><span id="l5.385">     LogQWithSize(group.get(), 0);</span>
<a href="#l5.386"></a><span id="l5.386" class="difflineminus">-  } //endif</span>
<a href="#l5.387"></a><span id="l5.387" class="difflineplus">+  }  // endif</span>
<a href="#l5.388"></a><span id="l5.388"> </span>
<a href="#l5.389"></a><span id="l5.389" class="difflineminus">-   // return it to the caller</span>
<a href="#l5.390"></a><span id="l5.390" class="difflineplus">+  // return it to the caller</span>
<a href="#l5.391"></a><span id="l5.391">   group.forget(aMessagesList);</span>
<a href="#l5.392"></a><span id="l5.392"> </span>
<a href="#l5.393"></a><span id="l5.393">   return NS_OK;</span>
<a href="#l5.394"></a><span id="l5.394"> }</span>
<a href="#l5.395"></a><span id="l5.395"> </span>
<a href="#l5.396"></a><span id="l5.396"> /**</span>
<a href="#l5.397"></a><span id="l5.397">  * Usually called by nsAutoSyncManager when the last sync time is expired.</span>
<a href="#l5.398"></a><span id="l5.398">  */</span>
<a href="#l5.399"></a><span id="l5.399" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::ProcessExistingHeaders(uint32_t aNumOfHdrsToProcess, uint32_t *aLeftToProcess)</span>
<a href="#l5.400"></a><span id="l5.400" class="difflineminus">-{</span>
<a href="#l5.401"></a><span id="l5.401" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::ProcessExistingHeaders(</span>
<a href="#l5.402"></a><span id="l5.402" class="difflineplus">+    uint32_t aNumOfHdrsToProcess, uint32_t *aLeftToProcess) {</span>
<a href="#l5.403"></a><span id="l5.403">   NS_ENSURE_ARG_POINTER(aLeftToProcess);</span>
<a href="#l5.404"></a><span id="l5.404"> </span>
<a href="#l5.405"></a><span id="l5.405">   nsresult rv;</span>
<a href="#l5.406"></a><span id="l5.406" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; folder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.407"></a><span id="l5.407" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; folder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.408"></a><span id="l5.408">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.409"></a><span id="l5.409"> </span>
<a href="#l5.410"></a><span id="l5.410">   nsCOMPtr&lt;nsIMsgDatabase&gt; database;</span>
<a href="#l5.411"></a><span id="l5.411">   rv = folder-&gt;GetMsgDatabase(getter_AddRefs(database));</span>
<a href="#l5.412"></a><span id="l5.412" class="difflineminus">-  if (!database)</span>
<a href="#l5.413"></a><span id="l5.413" class="difflineminus">-    return NS_ERROR_FAILURE;</span>
<a href="#l5.414"></a><span id="l5.414" class="difflineplus">+  if (!database) return NS_ERROR_FAILURE;</span>
<a href="#l5.415"></a><span id="l5.415"> </span>
<a href="#l5.416"></a><span id="l5.416">   // create a queue to process existing headers for the first time</span>
<a href="#l5.417"></a><span id="l5.417" class="difflineminus">-  if (mExistingHeadersQ.IsEmpty())</span>
<a href="#l5.418"></a><span id="l5.418" class="difflineminus">-  {</span>
<a href="#l5.419"></a><span id="l5.419" class="difflineplus">+  if (mExistingHeadersQ.IsEmpty()) {</span>
<a href="#l5.420"></a><span id="l5.420">     RefPtr&lt;nsMsgKeyArray&gt; keys = new nsMsgKeyArray;</span>
<a href="#l5.421"></a><span id="l5.421">     rv = database-&gt;ListAllKeys(keys);</span>
<a href="#l5.422"></a><span id="l5.422">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.423"></a><span id="l5.423">     keys-&gt;Sort();</span>
<a href="#l5.424"></a><span id="l5.424">     mExistingHeadersQ.AppendElements(keys-&gt;m_keys);</span>
<a href="#l5.425"></a><span id="l5.425">     mProcessPointer = 0;</span>
<a href="#l5.426"></a><span id="l5.426">   }</span>
<a href="#l5.427"></a><span id="l5.427"> </span>
<a href="#l5.428"></a><span id="l5.428">   // process the existing headers and find the messages not downloaded yet</span>
<a href="#l5.429"></a><span id="l5.429">   uint32_t lastIdx = mProcessPointer;</span>
<a href="#l5.430"></a><span id="l5.430">   nsTArray&lt;nsMsgKey&gt; msgKeys;</span>
<a href="#l5.431"></a><span id="l5.431">   uint32_t keyCount = mExistingHeadersQ.Length();</span>
<a href="#l5.432"></a><span id="l5.432" class="difflineminus">-  for (; mProcessPointer &lt; (lastIdx + aNumOfHdrsToProcess) &amp;&amp; mProcessPointer &lt; keyCount; mProcessPointer++)</span>
<a href="#l5.433"></a><span id="l5.433" class="difflineminus">-  {</span>
<a href="#l5.434"></a><span id="l5.434" class="difflineplus">+  for (; mProcessPointer &lt; (lastIdx + aNumOfHdrsToProcess) &amp;&amp;</span>
<a href="#l5.435"></a><span id="l5.435" class="difflineplus">+         mProcessPointer &lt; keyCount;</span>
<a href="#l5.436"></a><span id="l5.436" class="difflineplus">+       mProcessPointer++) {</span>
<a href="#l5.437"></a><span id="l5.437">     bool hasMessageOffline;</span>
<a href="#l5.438"></a><span id="l5.438" class="difflineminus">-    folder-&gt;HasMsgOffline(mExistingHeadersQ[mProcessPointer], &amp;hasMessageOffline);</span>
<a href="#l5.439"></a><span id="l5.439" class="difflineplus">+    folder-&gt;HasMsgOffline(mExistingHeadersQ[mProcessPointer],</span>
<a href="#l5.440"></a><span id="l5.440" class="difflineplus">+                          &amp;hasMessageOffline);</span>
<a href="#l5.441"></a><span id="l5.441">     if (!hasMessageOffline)</span>
<a href="#l5.442"></a><span id="l5.442">       msgKeys.AppendElement(mExistingHeadersQ[mProcessPointer]);</span>
<a href="#l5.443"></a><span id="l5.443">   }</span>
<a href="#l5.444"></a><span id="l5.444" class="difflineminus">-  if (!msgKeys.IsEmpty())</span>
<a href="#l5.445"></a><span id="l5.445" class="difflineminus">-  {</span>
<a href="#l5.446"></a><span id="l5.446" class="difflineplus">+  if (!msgKeys.IsEmpty()) {</span>
<a href="#l5.447"></a><span id="l5.447">     nsCString folderName;</span>
<a href="#l5.448"></a><span id="l5.448">     folder-&gt;GetURI(folderName);</span>
<a href="#l5.449"></a><span id="l5.449">     MOZ_LOG(gAutoSyncLog, LogLevel::Debug,</span>
<a href="#l5.450"></a><span id="l5.450" class="difflineminus">-          (&quot;%zu messages will be added into the download q of folder %s\n&quot;,</span>
<a href="#l5.451"></a><span id="l5.451" class="difflineminus">-            msgKeys.Length(), folderName.get()));</span>
<a href="#l5.452"></a><span id="l5.452" class="difflineplus">+            (&quot;%zu messages will be added into the download q of folder %s\n&quot;,</span>
<a href="#l5.453"></a><span id="l5.453" class="difflineplus">+             msgKeys.Length(), folderName.get()));</span>
<a href="#l5.454"></a><span id="l5.454"> </span>
<a href="#l5.455"></a><span id="l5.455">     rv = PlaceIntoDownloadQ(msgKeys);</span>
<a href="#l5.456"></a><span id="l5.456" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l5.457"></a><span id="l5.457" class="difflineminus">-      mProcessPointer = lastIdx;</span>
<a href="#l5.458"></a><span id="l5.458" class="difflineplus">+    if (NS_FAILED(rv)) mProcessPointer = lastIdx;</span>
<a href="#l5.459"></a><span id="l5.459">   }</span>
<a href="#l5.460"></a><span id="l5.460"> </span>
<a href="#l5.461"></a><span id="l5.461">   *aLeftToProcess = keyCount - mProcessPointer;</span>
<a href="#l5.462"></a><span id="l5.462"> </span>
<a href="#l5.463"></a><span id="l5.463">   // cleanup if we are done processing</span>
<a href="#l5.464"></a><span id="l5.464" class="difflineminus">-  if (0 == *aLeftToProcess)</span>
<a href="#l5.465"></a><span id="l5.465" class="difflineminus">-  {</span>
<a href="#l5.466"></a><span id="l5.466" class="difflineplus">+  if (0 == *aLeftToProcess) {</span>
<a href="#l5.467"></a><span id="l5.467">     mLastSyncTime = PR_Now();</span>
<a href="#l5.468"></a><span id="l5.468">     mExistingHeadersQ.Clear();</span>
<a href="#l5.469"></a><span id="l5.469">     mProcessPointer = 0;</span>
<a href="#l5.470"></a><span id="l5.470">     folder-&gt;SetMsgDatabase(nullptr);</span>
<a href="#l5.471"></a><span id="l5.471">   }</span>
<a href="#l5.472"></a><span id="l5.472"> </span>
<a href="#l5.473"></a><span id="l5.473">   return rv;</span>
<a href="#l5.474"></a><span id="l5.474"> }</span>
<a href="#l5.475"></a><span id="l5.475"> </span>
<a href="#l5.476"></a><span id="l5.476" class="difflineminus">-void nsAutoSyncState::OnNewHeaderFetchCompleted(const nsTArray&lt;nsMsgKey&gt; &amp;aMsgKeyList)</span>
<a href="#l5.477"></a><span id="l5.477" class="difflineminus">-{</span>
<a href="#l5.478"></a><span id="l5.478" class="difflineplus">+void nsAutoSyncState::OnNewHeaderFetchCompleted(</span>
<a href="#l5.479"></a><span id="l5.479" class="difflineplus">+    const nsTArray&lt;nsMsgKey&gt; &amp;aMsgKeyList) {</span>
<a href="#l5.480"></a><span id="l5.480">   SetLastUpdateTime(PR_Now());</span>
<a href="#l5.481"></a><span id="l5.481" class="difflineminus">-  if (!aMsgKeyList.IsEmpty())</span>
<a href="#l5.482"></a><span id="l5.482" class="difflineminus">-    PlaceIntoDownloadQ(aMsgKeyList);</span>
<a href="#l5.483"></a><span id="l5.483" class="difflineplus">+  if (!aMsgKeyList.IsEmpty()) PlaceIntoDownloadQ(aMsgKeyList);</span>
<a href="#l5.484"></a><span id="l5.484"> }</span>
<a href="#l5.485"></a><span id="l5.485"> </span>
<a href="#l5.486"></a><span id="l5.486" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::UpdateFolder()</span>
<a href="#l5.487"></a><span id="l5.487" class="difflineminus">-{</span>
<a href="#l5.488"></a><span id="l5.488" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::UpdateFolder() {</span>
<a href="#l5.489"></a><span id="l5.489">   nsresult rv;</span>
<a href="#l5.490"></a><span id="l5.490" class="difflineminus">-  nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr = do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l5.491"></a><span id="l5.491" class="difflineplus">+  nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr =</span>
<a href="#l5.492"></a><span id="l5.492" class="difflineplus">+      do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l5.493"></a><span id="l5.493">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.494"></a><span id="l5.494" class="difflineminus">-  nsCOMPtr&lt;nsIUrlListener&gt; autoSyncMgrListener = do_QueryInterface(autoSyncMgr, &amp;rv);</span>
<a href="#l5.495"></a><span id="l5.495" class="difflineplus">+  nsCOMPtr&lt;nsIUrlListener&gt; autoSyncMgrListener =</span>
<a href="#l5.496"></a><span id="l5.496" class="difflineplus">+      do_QueryInterface(autoSyncMgr, &amp;rv);</span>
<a href="#l5.497"></a><span id="l5.497">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.498"></a><span id="l5.498" class="difflineminus">-  nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.499"></a><span id="l5.499" class="difflineplus">+  nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder =</span>
<a href="#l5.500"></a><span id="l5.500" class="difflineplus">+      do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.501"></a><span id="l5.501">   SetState(nsAutoSyncState::stUpdateIssued);</span>
<a href="#l5.502"></a><span id="l5.502">   return imapFolder-&gt;UpdateFolderWithListener(nullptr, autoSyncMgrListener);</span>
<a href="#l5.503"></a><span id="l5.503"> }</span>
<a href="#l5.504"></a><span id="l5.504"> </span>
<a href="#l5.505"></a><span id="l5.505" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::OnStartRunningUrl(nsIURI* aUrl)</span>
<a href="#l5.506"></a><span id="l5.506" class="difflineminus">-{</span>
<a href="#l5.507"></a><span id="l5.507" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::OnStartRunningUrl(nsIURI *aUrl) {</span>
<a href="#l5.508"></a><span id="l5.508">   nsresult rv = NS_OK;</span>
<a href="#l5.509"></a><span id="l5.509"> </span>
<a href="#l5.510"></a><span id="l5.510">   // if there is a problem to start the download, set rv with the</span>
<a href="#l5.511"></a><span id="l5.511">   // corresponding error code. In that case, AutoSyncManager is going to</span>
<a href="#l5.512"></a><span id="l5.512">   // set the autosync state to nsAutoSyncState::stReadyToDownload</span>
<a href="#l5.513"></a><span id="l5.513">   // to resume downloading another time</span>
<a href="#l5.514"></a><span id="l5.514"> </span>
<a href="#l5.515"></a><span id="l5.515">   // TODO: is there a way to make sure that download started without</span>
<a href="#l5.516"></a><span id="l5.516">   // problem through nsIURI interface?</span>
<a href="#l5.517"></a><span id="l5.517"> </span>
<a href="#l5.518"></a><span id="l5.518" class="difflineminus">-  nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr = do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l5.519"></a><span id="l5.519" class="difflineplus">+  nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr =</span>
<a href="#l5.520"></a><span id="l5.520" class="difflineplus">+      do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l5.521"></a><span id="l5.521">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.522"></a><span id="l5.522"> </span>
<a href="#l5.523"></a><span id="l5.523">   return autoSyncMgr-&gt;OnDownloadStarted(this, rv);</span>
<a href="#l5.524"></a><span id="l5.524"> }</span>
<a href="#l5.525"></a><span id="l5.525"> </span>
<a href="#l5.526"></a><span id="l5.526" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::OnStopRunningUrl(nsIURI* aUrl, nsresult aExitCode)</span>
<a href="#l5.527"></a><span id="l5.527" class="difflineminus">-{</span>
<a href="#l5.528"></a><span id="l5.528" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::OnStopRunningUrl(nsIURI *aUrl,</span>
<a href="#l5.529"></a><span id="l5.529" class="difflineplus">+                                                nsresult aExitCode) {</span>
<a href="#l5.530"></a><span id="l5.530">   nsresult rv;</span>
<a href="#l5.531"></a><span id="l5.531" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.532"></a><span id="l5.532" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.533"></a><span id="l5.533">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.534"></a><span id="l5.534" class="difflineminus">-  nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr = do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l5.535"></a><span id="l5.535" class="difflineplus">+  nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr =</span>
<a href="#l5.536"></a><span id="l5.536" class="difflineplus">+      do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l5.537"></a><span id="l5.537">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.538"></a><span id="l5.538" class="difflineminus">-  nsCOMPtr&lt;nsIUrlListener&gt; autoSyncMgrListener = do_QueryInterface(autoSyncMgr, &amp;rv);</span>
<a href="#l5.539"></a><span id="l5.539" class="difflineplus">+  nsCOMPtr&lt;nsIUrlListener&gt; autoSyncMgrListener =</span>
<a href="#l5.540"></a><span id="l5.540" class="difflineplus">+      do_QueryInterface(autoSyncMgr, &amp;rv);</span>
<a href="#l5.541"></a><span id="l5.541">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.542"></a><span id="l5.542"> </span>
<a href="#l5.543"></a><span id="l5.543" class="difflineminus">-  if (mSyncState == stStatusIssued)</span>
<a href="#l5.544"></a><span id="l5.544" class="difflineminus">-  {</span>
<a href="#l5.545"></a><span id="l5.545" class="difflineminus">-    nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.546"></a><span id="l5.546" class="difflineplus">+  if (mSyncState == stStatusIssued) {</span>
<a href="#l5.547"></a><span id="l5.547" class="difflineplus">+    nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder =</span>
<a href="#l5.548"></a><span id="l5.548" class="difflineplus">+        do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.549"></a><span id="l5.549">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.550"></a><span id="l5.550">     int32_t serverTotal, serverUnseen, serverRecent, serverNextUID;</span>
<a href="#l5.551"></a><span id="l5.551">     imapFolder-&gt;GetServerTotal(&amp;serverTotal);</span>
<a href="#l5.552"></a><span id="l5.552">     imapFolder-&gt;GetServerUnseen(&amp;serverUnseen);</span>
<a href="#l5.553"></a><span id="l5.553">     imapFolder-&gt;GetServerRecent(&amp;serverRecent);</span>
<a href="#l5.554"></a><span id="l5.554">     imapFolder-&gt;GetServerNextUID(&amp;serverNextUID);</span>
<a href="#l5.555"></a><span id="l5.555">     if (serverNextUID != mLastNextUID || serverTotal != mLastServerTotal ||</span>
<a href="#l5.556"></a><span id="l5.556" class="difflineminus">-        serverUnseen != mLastServerUnseen || serverRecent != mLastServerRecent)</span>
<a href="#l5.557"></a><span id="l5.557" class="difflineminus">-    {</span>
<a href="#l5.558"></a><span id="l5.558" class="difflineplus">+        serverUnseen != mLastServerUnseen ||</span>
<a href="#l5.559"></a><span id="l5.559" class="difflineplus">+        serverRecent != mLastServerRecent) {</span>
<a href="#l5.560"></a><span id="l5.560">       nsCString folderName;</span>
<a href="#l5.561"></a><span id="l5.561">       ownerFolder-&gt;GetURI(folderName);</span>
<a href="#l5.562"></a><span id="l5.562">       MOZ_LOG(gAutoSyncLog, LogLevel::Debug,</span>
<a href="#l5.563"></a><span id="l5.563" class="difflineminus">-             (&quot;folder %s status changed serverNextUID = %x lastNextUID = %x\n&quot;, folderName.get(),</span>
<a href="#l5.564"></a><span id="l5.564" class="difflineminus">-              serverNextUID, mLastNextUID));</span>
<a href="#l5.565"></a><span id="l5.565" class="difflineplus">+              (&quot;folder %s status changed serverNextUID = %x lastNextUID = %x\n&quot;,</span>
<a href="#l5.566"></a><span id="l5.566" class="difflineplus">+               folderName.get(), serverNextUID, mLastNextUID));</span>
<a href="#l5.567"></a><span id="l5.567">       MOZ_LOG(gAutoSyncLog, LogLevel::Debug,</span>
<a href="#l5.568"></a><span id="l5.568" class="difflineminus">-             (&quot;serverTotal = %x lastServerTotal = %x serverRecent = %x lastServerRecent = %x\n&quot;,</span>
<a href="#l5.569"></a><span id="l5.569" class="difflineminus">-              serverTotal, mLastServerTotal, serverRecent, mLastServerRecent));</span>
<a href="#l5.570"></a><span id="l5.570" class="difflineplus">+              (&quot;serverTotal = %x lastServerTotal = %x serverRecent = %x &quot;</span>
<a href="#l5.571"></a><span id="l5.571" class="difflineplus">+               &quot;lastServerRecent = %x\n&quot;,</span>
<a href="#l5.572"></a><span id="l5.572" class="difflineplus">+               serverTotal, mLastServerTotal, serverRecent, mLastServerRecent));</span>
<a href="#l5.573"></a><span id="l5.573">       SetServerCounts(serverTotal, serverRecent, serverUnseen, serverNextUID);</span>
<a href="#l5.574"></a><span id="l5.574">       SetState(nsAutoSyncState::stUpdateIssued);</span>
<a href="#l5.575"></a><span id="l5.575">       return imapFolder-&gt;UpdateFolderWithListener(nullptr, autoSyncMgrListener);</span>
<a href="#l5.576"></a><span id="l5.576">     }</span>
<a href="#l5.577"></a><span id="l5.577"> </span>
<a href="#l5.578"></a><span id="l5.578">     ownerFolder-&gt;SetMsgDatabase(nullptr);</span>
<a href="#l5.579"></a><span id="l5.579">     // nothing more to do.</span>
<a href="#l5.580"></a><span id="l5.580">     SetState(nsAutoSyncState::stCompletedIdle);</span>
<a href="#l5.581"></a><span id="l5.581">     // autoSyncMgr needs this notification, so manufacture it.</span>
<a href="#l5.582"></a><span id="l5.582">     return autoSyncMgrListener-&gt;OnStopRunningUrl(nullptr, NS_OK);</span>
<a href="#l5.583"></a><span id="l5.583">   }</span>
<a href="#l5.584"></a><span id="l5.584" class="difflineminus">-  //XXXemre how we recover from this error?</span>
<a href="#l5.585"></a><span id="l5.585" class="difflineplus">+  // XXXemre how we recover from this error?</span>
<a href="#l5.586"></a><span id="l5.586">   rv = ownerFolder-&gt;ReleaseSemaphore(ownerFolder);</span>
<a href="#l5.587"></a><span id="l5.587">   NS_ASSERTION(NS_SUCCEEDED(rv), &quot;*** Cannot release folder semaphore&quot;);</span>
<a href="#l5.588"></a><span id="l5.588"> </span>
<a href="#l5.589"></a><span id="l5.589">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailUrl = do_QueryInterface(aUrl);</span>
<a href="#l5.590"></a><span id="l5.590" class="difflineminus">-  if (mailUrl)</span>
<a href="#l5.591"></a><span id="l5.591" class="difflineminus">-    rv = mailUrl-&gt;UnRegisterListener(this);</span>
<a href="#l5.592"></a><span id="l5.592" class="difflineplus">+  if (mailUrl) rv = mailUrl-&gt;UnRegisterListener(this);</span>
<a href="#l5.593"></a><span id="l5.593"> </span>
<a href="#l5.594"></a><span id="l5.594">   return autoSyncMgr-&gt;OnDownloadCompleted(this, aExitCode);</span>
<a href="#l5.595"></a><span id="l5.595"> }</span>
<a href="#l5.596"></a><span id="l5.596"> </span>
<a href="#l5.597"></a><span id="l5.597" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::GetState(int32_t *aState)</span>
<a href="#l5.598"></a><span id="l5.598" class="difflineminus">-{</span>
<a href="#l5.599"></a><span id="l5.599" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::GetState(int32_t *aState) {</span>
<a href="#l5.600"></a><span id="l5.600">   NS_ENSURE_ARG_POINTER(aState);</span>
<a href="#l5.601"></a><span id="l5.601">   *aState = mSyncState;</span>
<a href="#l5.602"></a><span id="l5.602">   return NS_OK;</span>
<a href="#l5.603"></a><span id="l5.603"> }</span>
<a href="#l5.604"></a><span id="l5.604"> </span>
<a href="#l5.605"></a><span id="l5.605" class="difflineminus">-const char *stateStrings[] = {&quot;idle&quot;, &quot;status issued&quot;, &quot;update needed&quot;,</span>
<a href="#l5.606"></a><span id="l5.606" class="difflineminus">-                              &quot;update issued&quot;, &quot;downloading&quot;,</span>
<a href="#l5.607"></a><span id="l5.607" class="difflineminus">-                              &quot;ready to download&quot;};</span>
<a href="#l5.608"></a><span id="l5.608" class="difflineplus">+const char *stateStrings[] = {&quot;idle&quot;,          &quot;status issued&quot;,</span>
<a href="#l5.609"></a><span id="l5.609" class="difflineplus">+                              &quot;update needed&quot;, &quot;update issued&quot;,</span>
<a href="#l5.610"></a><span id="l5.610" class="difflineplus">+                              &quot;downloading&quot;,   &quot;ready to download&quot;};</span>
<a href="#l5.611"></a><span id="l5.611"> </span>
<a href="#l5.612"></a><span id="l5.612" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::SetState(int32_t aState)</span>
<a href="#l5.613"></a><span id="l5.613" class="difflineminus">-{</span>
<a href="#l5.614"></a><span id="l5.614" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::SetState(int32_t aState) {</span>
<a href="#l5.615"></a><span id="l5.615">   mSyncState = aState;</span>
<a href="#l5.616"></a><span id="l5.616" class="difflineminus">-  if (aState == stCompletedIdle)</span>
<a href="#l5.617"></a><span id="l5.617" class="difflineminus">-  {</span>
<a href="#l5.618"></a><span id="l5.618" class="difflineplus">+  if (aState == stCompletedIdle) {</span>
<a href="#l5.619"></a><span id="l5.619">     ResetDownloadQ();</span>
<a href="#l5.620"></a><span id="l5.620" class="difflineminus">-    //tell folder to let go of its cached msg db pointer</span>
<a href="#l5.621"></a><span id="l5.621" class="difflineplus">+    // tell folder to let go of its cached msg db pointer</span>
<a href="#l5.622"></a><span id="l5.622">     nsresult rv;</span>
<a href="#l5.623"></a><span id="l5.623">     nsCOMPtr&lt;nsIMsgMailSession&gt; session =</span>
<a href="#l5.624"></a><span id="l5.624" class="difflineminus">-             do_GetService(NS_MSGMAILSESSION_CONTRACTID, &amp;rv);</span>
<a href="#l5.625"></a><span id="l5.625" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; session)</span>
<a href="#l5.626"></a><span id="l5.626" class="difflineminus">-    {</span>
<a href="#l5.627"></a><span id="l5.627" class="difflineminus">-      nsCOMPtr &lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.628"></a><span id="l5.628" class="difflineplus">+        do_GetService(NS_MSGMAILSESSION_CONTRACTID, &amp;rv);</span>
<a href="#l5.629"></a><span id="l5.629" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; session) {</span>
<a href="#l5.630"></a><span id="l5.630" class="difflineplus">+      nsCOMPtr&lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.631"></a><span id="l5.631">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.632"></a><span id="l5.632"> </span>
<a href="#l5.633"></a><span id="l5.633">       bool folderOpen;</span>
<a href="#l5.634"></a><span id="l5.634">       uint32_t folderFlags;</span>
<a href="#l5.635"></a><span id="l5.635">       ownerFolder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l5.636"></a><span id="l5.636">       session-&gt;IsFolderOpenInWindow(ownerFolder, &amp;folderOpen);</span>
<a href="#l5.637"></a><span id="l5.637" class="difflineminus">-      if (!folderOpen &amp;&amp; ! (folderFlags &amp; nsMsgFolderFlags::Inbox))</span>
<a href="#l5.638"></a><span id="l5.638" class="difflineplus">+      if (!folderOpen &amp;&amp; !(folderFlags &amp; nsMsgFolderFlags::Inbox))</span>
<a href="#l5.639"></a><span id="l5.639">         ownerFolder-&gt;SetMsgDatabase(nullptr);</span>
<a href="#l5.640"></a><span id="l5.640">     }</span>
<a href="#l5.641"></a><span id="l5.641">   }</span>
<a href="#l5.642"></a><span id="l5.642">   nsCString logStr(&quot;Sync State set to &quot;);</span>
<a href="#l5.643"></a><span id="l5.643">   logStr.Append(stateStrings[aState]);</span>
<a href="#l5.644"></a><span id="l5.644">   logStr.AppendLiteral(&quot; for &quot;);</span>
<a href="#l5.645"></a><span id="l5.645">   LogOwnerFolderName(logStr.get());</span>
<a href="#l5.646"></a><span id="l5.646">   return NS_OK;</span>
<a href="#l5.647"></a><span id="l5.647"> }</span>
<a href="#l5.648"></a><span id="l5.648"> </span>
<a href="#l5.649"></a><span id="l5.649" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::TryCurrentGroupAgain(uint32_t aRetryCount)</span>
<a href="#l5.650"></a><span id="l5.650" class="difflineminus">-{</span>
<a href="#l5.651"></a><span id="l5.651" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::TryCurrentGroupAgain(uint32_t aRetryCount) {</span>
<a href="#l5.652"></a><span id="l5.652">   SetState(stReadyToDownload);</span>
<a href="#l5.653"></a><span id="l5.653"> </span>
<a href="#l5.654"></a><span id="l5.654">   nsresult rv;</span>
<a href="#l5.655"></a><span id="l5.655" class="difflineminus">-  if (++mRetryCounter &gt; aRetryCount)</span>
<a href="#l5.656"></a><span id="l5.656" class="difflineminus">-  {</span>
<a href="#l5.657"></a><span id="l5.657" class="difflineplus">+  if (++mRetryCounter &gt; aRetryCount) {</span>
<a href="#l5.658"></a><span id="l5.658">     ResetRetryCounter();</span>
<a href="#l5.659"></a><span id="l5.659">     rv = NS_ERROR_FAILURE;</span>
<a href="#l5.660"></a><span id="l5.660" class="difflineminus">-  }</span>
<a href="#l5.661"></a><span id="l5.661" class="difflineminus">-  else</span>
<a href="#l5.662"></a><span id="l5.662" class="difflineplus">+  } else</span>
<a href="#l5.663"></a><span id="l5.663">     rv = Rollback();</span>
<a href="#l5.664"></a><span id="l5.664"> </span>
<a href="#l5.665"></a><span id="l5.665">   return rv;</span>
<a href="#l5.666"></a><span id="l5.666"> }</span>
<a href="#l5.667"></a><span id="l5.667"> </span>
<a href="#l5.668"></a><span id="l5.668" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::ResetRetryCounter()</span>
<a href="#l5.669"></a><span id="l5.669" class="difflineminus">-{</span>
<a href="#l5.670"></a><span id="l5.670" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::ResetRetryCounter() {</span>
<a href="#l5.671"></a><span id="l5.671">   mRetryCounter = 0;</span>
<a href="#l5.672"></a><span id="l5.672">   return NS_OK;</span>
<a href="#l5.673"></a><span id="l5.673"> }</span>
<a href="#l5.674"></a><span id="l5.674"> </span>
<a href="#l5.675"></a><span id="l5.675" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::GetPendingMessageCount(int32_t *aMsgCount)</span>
<a href="#l5.676"></a><span id="l5.676" class="difflineminus">-{</span>
<a href="#l5.677"></a><span id="l5.677" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::GetPendingMessageCount(int32_t *aMsgCount) {</span>
<a href="#l5.678"></a><span id="l5.678">   NS_ENSURE_ARG_POINTER(aMsgCount);</span>
<a href="#l5.679"></a><span id="l5.679">   *aMsgCount = mDownloadQ.Length() - mOffset;</span>
<a href="#l5.680"></a><span id="l5.680">   return NS_OK;</span>
<a href="#l5.681"></a><span id="l5.681"> }</span>
<a href="#l5.682"></a><span id="l5.682"> </span>
<a href="#l5.683"></a><span id="l5.683" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::GetTotalMessageCount(int32_t *aMsgCount)</span>
<a href="#l5.684"></a><span id="l5.684" class="difflineminus">-{</span>
<a href="#l5.685"></a><span id="l5.685" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::GetTotalMessageCount(int32_t *aMsgCount) {</span>
<a href="#l5.686"></a><span id="l5.686">   NS_ENSURE_ARG_POINTER(aMsgCount);</span>
<a href="#l5.687"></a><span id="l5.687">   *aMsgCount = mDownloadQ.Length();</span>
<a href="#l5.688"></a><span id="l5.688">   return NS_OK;</span>
<a href="#l5.689"></a><span id="l5.689"> }</span>
<a href="#l5.690"></a><span id="l5.690"> </span>
<a href="#l5.691"></a><span id="l5.691" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::GetOwnerFolder(nsIMsgFolder **aFolder)</span>
<a href="#l5.692"></a><span id="l5.692" class="difflineminus">-{</span>
<a href="#l5.693"></a><span id="l5.693" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::GetOwnerFolder(nsIMsgFolder **aFolder) {</span>
<a href="#l5.694"></a><span id="l5.694">   NS_ENSURE_ARG_POINTER(aFolder);</span>
<a href="#l5.695"></a><span id="l5.695"> </span>
<a href="#l5.696"></a><span id="l5.696">   nsresult rv;</span>
<a href="#l5.697"></a><span id="l5.697" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.698"></a><span id="l5.698" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.699"></a><span id="l5.699">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.700"></a><span id="l5.700"> </span>
<a href="#l5.701"></a><span id="l5.701">   ownerFolder.forget(aFolder);</span>
<a href="#l5.702"></a><span id="l5.702">   return NS_OK;</span>
<a href="#l5.703"></a><span id="l5.703"> }</span>
<a href="#l5.704"></a><span id="l5.704"> </span>
<a href="#l5.705"></a><span id="l5.705" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::Rollback()</span>
<a href="#l5.706"></a><span id="l5.706" class="difflineminus">-{</span>
<a href="#l5.707"></a><span id="l5.707" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::Rollback() {</span>
<a href="#l5.708"></a><span id="l5.708">   mOffset = mLastOffset;</span>
<a href="#l5.709"></a><span id="l5.709">   return NS_OK;</span>
<a href="#l5.710"></a><span id="l5.710"> }</span>
<a href="#l5.711"></a><span id="l5.711"> </span>
<a href="#l5.712"></a><span id="l5.712" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::ResetDownloadQ()</span>
<a href="#l5.713"></a><span id="l5.713" class="difflineminus">-{</span>
<a href="#l5.714"></a><span id="l5.714" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::ResetDownloadQ() {</span>
<a href="#l5.715"></a><span id="l5.715">   mOffset = mLastOffset = 0;</span>
<a href="#l5.716"></a><span id="l5.716">   mDownloadSet.Clear();</span>
<a href="#l5.717"></a><span id="l5.717">   mDownloadQ.Clear();</span>
<a href="#l5.718"></a><span id="l5.718">   mDownloadQ.Compact();</span>
<a href="#l5.719"></a><span id="l5.719"> </span>
<a href="#l5.720"></a><span id="l5.720">   return NS_OK;</span>
<a href="#l5.721"></a><span id="l5.721"> }</span>
<a href="#l5.722"></a><span id="l5.722"> </span>
<a href="#l5.723"></a><span id="l5.723"> /**</span>
<a href="#l5.724"></a><span id="l5.724">  * Tests whether the given folder is owned by the same imap server</span>
<a href="#l5.725"></a><span id="l5.725">  * or not.</span>
<a href="#l5.726"></a><span id="l5.726">  */</span>
<a href="#l5.727"></a><span id="l5.727" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::IsSibling(nsIAutoSyncState *aAnotherStateObj, bool *aResult)</span>
<a href="#l5.728"></a><span id="l5.728" class="difflineminus">-{</span>
<a href="#l5.729"></a><span id="l5.729" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::IsSibling(nsIAutoSyncState *aAnotherStateObj,</span>
<a href="#l5.730"></a><span id="l5.730" class="difflineplus">+                                         bool *aResult) {</span>
<a href="#l5.731"></a><span id="l5.731">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l5.732"></a><span id="l5.732">   *aResult = false;</span>
<a href="#l5.733"></a><span id="l5.733"> </span>
<a href="#l5.734"></a><span id="l5.734">   nsresult rv;</span>
<a href="#l5.735"></a><span id="l5.735">   nsCOMPtr&lt;nsIMsgFolder&gt; folderA, folderB;</span>
<a href="#l5.736"></a><span id="l5.736"> </span>
<a href="#l5.737"></a><span id="l5.737">   rv = GetOwnerFolder(getter_AddRefs(folderA));</span>
<a href="#l5.738"></a><span id="l5.738" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l5.739"></a><span id="l5.739" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.740"></a><span id="l5.740"> </span>
<a href="#l5.741"></a><span id="l5.741">   rv = aAnotherStateObj-&gt;GetOwnerFolder(getter_AddRefs(folderB));</span>
<a href="#l5.742"></a><span id="l5.742" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l5.743"></a><span id="l5.743" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.744"></a><span id="l5.744"> </span>
<a href="#l5.745"></a><span id="l5.745" class="difflineminus">-  nsCOMPtr &lt;nsIMsgIncomingServer&gt; serverA, serverB;</span>
<a href="#l5.746"></a><span id="l5.746" class="difflineplus">+  nsCOMPtr&lt;nsIMsgIncomingServer&gt; serverA, serverB;</span>
<a href="#l5.747"></a><span id="l5.747">   rv = folderA-&gt;GetServer(getter_AddRefs(serverA));</span>
<a href="#l5.748"></a><span id="l5.748" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l5.749"></a><span id="l5.749" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.750"></a><span id="l5.750">   rv = folderB-&gt;GetServer(getter_AddRefs(serverB));</span>
<a href="#l5.751"></a><span id="l5.751" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l5.752"></a><span id="l5.752" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.753"></a><span id="l5.753"> </span>
<a href="#l5.754"></a><span id="l5.754">   bool isSibling;</span>
<a href="#l5.755"></a><span id="l5.755">   rv = serverA-&gt;Equals(serverB, &amp;isSibling);</span>
<a href="#l5.756"></a><span id="l5.756"> </span>
<a href="#l5.757"></a><span id="l5.757" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l5.758"></a><span id="l5.758" class="difflineminus">-    *aResult = isSibling;</span>
<a href="#l5.759"></a><span id="l5.759" class="difflineplus">+  if (NS_SUCCEEDED(rv)) *aResult = isSibling;</span>
<a href="#l5.760"></a><span id="l5.760"> </span>
<a href="#l5.761"></a><span id="l5.761">   return rv;</span>
<a href="#l5.762"></a><span id="l5.762"> }</span>
<a href="#l5.763"></a><span id="l5.763"> </span>
<a href="#l5.764"></a><span id="l5.764" class="difflineminus">-</span>
<a href="#l5.765"></a><span id="l5.765" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::DownloadMessagesForOffline(nsIArray *aMessagesList)</span>
<a href="#l5.766"></a><span id="l5.766" class="difflineminus">-{</span>
<a href="#l5.767"></a><span id="l5.767" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::DownloadMessagesForOffline(</span>
<a href="#l5.768"></a><span id="l5.768" class="difflineplus">+    nsIArray *aMessagesList) {</span>
<a href="#l5.769"></a><span id="l5.769">   NS_ENSURE_ARG_POINTER(aMessagesList);</span>
<a href="#l5.770"></a><span id="l5.770"> </span>
<a href="#l5.771"></a><span id="l5.771">   uint32_t count;</span>
<a href="#l5.772"></a><span id="l5.772">   nsresult rv = aMessagesList-&gt;GetLength(&amp;count);</span>
<a href="#l5.773"></a><span id="l5.773" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l5.774"></a><span id="l5.774" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.775"></a><span id="l5.775"> </span>
<a href="#l5.776"></a><span id="l5.776" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l5.777"></a><span id="l5.777" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l5.778"></a><span id="l5.778" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l5.779"></a><span id="l5.779" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l5.780"></a><span id="l5.780" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.781"></a><span id="l5.781"> </span>
<a href="#l5.782"></a><span id="l5.782">   nsAutoCString messageIds;</span>
<a href="#l5.783"></a><span id="l5.783">   nsTArray&lt;nsMsgKey&gt; msgKeys;</span>
<a href="#l5.784"></a><span id="l5.784"> </span>
<a href="#l5.785"></a><span id="l5.785" class="difflineminus">-  rv = nsImapMailFolder::BuildIdsAndKeyArray(aMessagesList, messageIds, msgKeys);</span>
<a href="#l5.786"></a><span id="l5.786" class="difflineminus">-  if (NS_FAILED(rv) || messageIds.IsEmpty())</span>
<a href="#l5.787"></a><span id="l5.787" class="difflineminus">-    return rv;</span>
<a href="#l5.788"></a><span id="l5.788" class="difflineplus">+  rv =</span>
<a href="#l5.789"></a><span id="l5.789" class="difflineplus">+      nsImapMailFolder::BuildIdsAndKeyArray(aMessagesList, messageIds, msgKeys);</span>
<a href="#l5.790"></a><span id="l5.790" class="difflineplus">+  if (NS_FAILED(rv) || messageIds.IsEmpty()) return rv;</span>
<a href="#l5.791"></a><span id="l5.791"> </span>
<a href="#l5.792"></a><span id="l5.792">   // acquire semaphore for offline store. If it fails, we won't download</span>
<a href="#l5.793"></a><span id="l5.793" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; folder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.794"></a><span id="l5.794" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; folder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l5.795"></a><span id="l5.795">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.796"></a><span id="l5.796"> </span>
<a href="#l5.797"></a><span id="l5.797">   rv = folder-&gt;AcquireSemaphore(folder);</span>
<a href="#l5.798"></a><span id="l5.798">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.799"></a><span id="l5.799"> </span>
<a href="#l5.800"></a><span id="l5.800">   nsCString folderName;</span>
<a href="#l5.801"></a><span id="l5.801">   folder-&gt;GetURI(folderName);</span>
<a href="#l5.802"></a><span id="l5.802" class="difflineminus">-  MOZ_LOG(gAutoSyncLog, LogLevel::Debug, (&quot;downloading %s for %s&quot;, messageIds.get(),</span>
<a href="#l5.803"></a><span id="l5.803" class="difflineminus">-           folderName.get()));</span>
<a href="#l5.804"></a><span id="l5.804" class="difflineplus">+  MOZ_LOG(gAutoSyncLog, LogLevel::Debug,</span>
<a href="#l5.805"></a><span id="l5.805" class="difflineplus">+          (&quot;downloading %s for %s&quot;, messageIds.get(), folderName.get()));</span>
<a href="#l5.806"></a><span id="l5.806">   // start downloading</span>
<a href="#l5.807"></a><span id="l5.807" class="difflineminus">-  rv = imapService-&gt;DownloadMessagesForOffline(messageIds,</span>
<a href="#l5.808"></a><span id="l5.808" class="difflineminus">-                                               folder,</span>
<a href="#l5.809"></a><span id="l5.809" class="difflineminus">-                                               this,</span>
<a href="#l5.810"></a><span id="l5.810" class="difflineplus">+  rv = imapService-&gt;DownloadMessagesForOffline(messageIds, folder, this,</span>
<a href="#l5.811"></a><span id="l5.811">                                                nullptr);</span>
<a href="#l5.812"></a><span id="l5.812" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l5.813"></a><span id="l5.813" class="difflineminus">-    SetState(stDownloadInProgress);</span>
<a href="#l5.814"></a><span id="l5.814" class="difflineplus">+  if (NS_SUCCEEDED(rv)) SetState(stDownloadInProgress);</span>
<a href="#l5.815"></a><span id="l5.815"> </span>
<a href="#l5.816"></a><span id="l5.816">   return rv;</span>
<a href="#l5.817"></a><span id="l5.817"> }</span>
<a href="#l5.818"></a><span id="l5.818"> </span>
<a href="#l5.819"></a><span id="l5.819" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::GetLastSyncTime(PRTime *aLastSyncTime)</span>
<a href="#l5.820"></a><span id="l5.820" class="difflineminus">-{</span>
<a href="#l5.821"></a><span id="l5.821" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::GetLastSyncTime(PRTime *aLastSyncTime) {</span>
<a href="#l5.822"></a><span id="l5.822">   NS_ENSURE_ARG_POINTER(aLastSyncTime);</span>
<a href="#l5.823"></a><span id="l5.823">   *aLastSyncTime = mLastSyncTime;</span>
<a href="#l5.824"></a><span id="l5.824">   return NS_OK;</span>
<a href="#l5.825"></a><span id="l5.825"> }</span>
<a href="#l5.826"></a><span id="l5.826"> </span>
<a href="#l5.827"></a><span id="l5.827" class="difflineminus">-void nsAutoSyncState::SetLastSyncTimeInSec(int32_t aLastSyncTime)</span>
<a href="#l5.828"></a><span id="l5.828" class="difflineminus">-{</span>
<a href="#l5.829"></a><span id="l5.829" class="difflineplus">+void nsAutoSyncState::SetLastSyncTimeInSec(int32_t aLastSyncTime) {</span>
<a href="#l5.830"></a><span id="l5.830">   mLastSyncTime = ((PRTime)aLastSyncTime * PR_USEC_PER_SEC);</span>
<a href="#l5.831"></a><span id="l5.831"> }</span>
<a href="#l5.832"></a><span id="l5.832"> </span>
<a href="#l5.833"></a><span id="l5.833" class="difflineminus">-</span>
<a href="#l5.834"></a><span id="l5.834" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::GetLastUpdateTime(PRTime *aLastUpdateTime)</span>
<a href="#l5.835"></a><span id="l5.835" class="difflineminus">-{</span>
<a href="#l5.836"></a><span id="l5.836" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::GetLastUpdateTime(PRTime *aLastUpdateTime) {</span>
<a href="#l5.837"></a><span id="l5.837">   NS_ENSURE_ARG_POINTER(aLastUpdateTime);</span>
<a href="#l5.838"></a><span id="l5.838">   *aLastUpdateTime = mLastUpdateTime;</span>
<a href="#l5.839"></a><span id="l5.839">   return NS_OK;</span>
<a href="#l5.840"></a><span id="l5.840"> }</span>
<a href="#l5.841"></a><span id="l5.841"> </span>
<a href="#l5.842"></a><span id="l5.842" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::SetLastUpdateTime(PRTime aLastUpdateTime)</span>
<a href="#l5.843"></a><span id="l5.843" class="difflineminus">-{</span>
<a href="#l5.844"></a><span id="l5.844" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::SetLastUpdateTime(PRTime aLastUpdateTime) {</span>
<a href="#l5.845"></a><span id="l5.845">   mLastUpdateTime = aLastUpdateTime;</span>
<a href="#l5.846"></a><span id="l5.846">   return NS_OK;</span>
<a href="#l5.847"></a><span id="l5.847"> }</span>
<a href="#l5.848"></a><span id="l5.848"> </span>
<a href="#l5.849"></a><span id="l5.849"> void nsAutoSyncState::SetServerCounts(int32_t total, int32_t recent,</span>
<a href="#l5.850"></a><span id="l5.850" class="difflineminus">-                                      int32_t unseen, int32_t nextUID)</span>
<a href="#l5.851"></a><span id="l5.851" class="difflineminus">-{</span>
<a href="#l5.852"></a><span id="l5.852" class="difflineplus">+                                      int32_t unseen, int32_t nextUID) {</span>
<a href="#l5.853"></a><span id="l5.853">   mLastServerTotal = total;</span>
<a href="#l5.854"></a><span id="l5.854">   mLastServerRecent = recent;</span>
<a href="#l5.855"></a><span id="l5.855">   mLastServerUnseen = unseen;</span>
<a href="#l5.856"></a><span id="l5.856">   mLastNextUID = nextUID;</span>
<a href="#l5.857"></a><span id="l5.857"> }</span>
<a href="#l5.858"></a><span id="l5.858"> </span>
<a href="#l5.859"></a><span id="l5.859"> NS_IMPL_ISUPPORTS(nsAutoSyncState, nsIAutoSyncState, nsIUrlListener)</span>
<a href="#l5.860"></a><span id="l5.860"> </span>
<a href="#l5.861"></a><span id="l5.861" class="difflineminus">-</span>
<a href="#l5.862"></a><span id="l5.862" class="difflineminus">-void nsAutoSyncState::LogQWithSize(nsTArray&lt;nsMsgKey&gt;&amp; q, uint32_t toOffset)</span>
<a href="#l5.863"></a><span id="l5.863" class="difflineminus">-{</span>
<a href="#l5.864"></a><span id="l5.864" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder);</span>
<a href="#l5.865"></a><span id="l5.865" class="difflineminus">-  if (ownerFolder)</span>
<a href="#l5.866"></a><span id="l5.866" class="difflineminus">-  {</span>
<a href="#l5.867"></a><span id="l5.867" class="difflineplus">+void nsAutoSyncState::LogQWithSize(nsTArray&lt;nsMsgKey&gt; &amp;q, uint32_t toOffset) {</span>
<a href="#l5.868"></a><span id="l5.868" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder);</span>
<a href="#l5.869"></a><span id="l5.869" class="difflineplus">+  if (ownerFolder) {</span>
<a href="#l5.870"></a><span id="l5.870">     nsCOMPtr&lt;nsIMsgDatabase&gt; database;</span>
<a href="#l5.871"></a><span id="l5.871">     ownerFolder-&gt;GetMsgDatabase(getter_AddRefs(database));</span>
<a href="#l5.872"></a><span id="l5.872"> </span>
<a href="#l5.873"></a><span id="l5.873">     uint32_t x = q.Length();</span>
<a href="#l5.874"></a><span id="l5.874" class="difflineminus">-    while (x &gt; toOffset &amp;&amp; database)</span>
<a href="#l5.875"></a><span id="l5.875" class="difflineminus">-    {</span>
<a href="#l5.876"></a><span id="l5.876" class="difflineplus">+    while (x &gt; toOffset &amp;&amp; database) {</span>
<a href="#l5.877"></a><span id="l5.877">       x--;</span>
<a href="#l5.878"></a><span id="l5.878">       nsCOMPtr&lt;nsIMsgDBHdr&gt; h;</span>
<a href="#l5.879"></a><span id="l5.879">       database-&gt;GetMsgHdrForKey(q[x], getter_AddRefs(h));</span>
<a href="#l5.880"></a><span id="l5.880">       uint32_t s;</span>
<a href="#l5.881"></a><span id="l5.881" class="difflineminus">-      if (h)</span>
<a href="#l5.882"></a><span id="l5.882" class="difflineminus">-      {</span>
<a href="#l5.883"></a><span id="l5.883" class="difflineplus">+      if (h) {</span>
<a href="#l5.884"></a><span id="l5.884">         h-&gt;GetMessageSize(&amp;s);</span>
<a href="#l5.885"></a><span id="l5.885">         MOZ_LOG(gAutoSyncLog, LogLevel::Debug,</span>
<a href="#l5.886"></a><span id="l5.886" class="difflineminus">-              (&quot;Elem #%d, size: %u bytes\n&quot;, x+1, s));</span>
<a href="#l5.887"></a><span id="l5.887" class="difflineminus">-      }</span>
<a href="#l5.888"></a><span id="l5.888" class="difflineminus">-      else</span>
<a href="#l5.889"></a><span id="l5.889" class="difflineminus">-        MOZ_LOG(gAutoSyncLog, LogLevel::Debug, (&quot;unable to get header for key %ul&quot;, q[x]));</span>
<a href="#l5.890"></a><span id="l5.890" class="difflineplus">+                (&quot;Elem #%d, size: %u bytes\n&quot;, x + 1, s));</span>
<a href="#l5.891"></a><span id="l5.891" class="difflineplus">+      } else</span>
<a href="#l5.892"></a><span id="l5.892" class="difflineplus">+        MOZ_LOG(gAutoSyncLog, LogLevel::Debug,</span>
<a href="#l5.893"></a><span id="l5.893" class="difflineplus">+                (&quot;unable to get header for key %ul&quot;, q[x]));</span>
<a href="#l5.894"></a><span id="l5.894">     }</span>
<a href="#l5.895"></a><span id="l5.895">   }</span>
<a href="#l5.896"></a><span id="l5.896"> }</span>
<a href="#l5.897"></a><span id="l5.897"> </span>
<a href="#l5.898"></a><span id="l5.898" class="difflineminus">-void nsAutoSyncState::LogQWithSize(nsIMutableArray *q, uint32_t toOffset)</span>
<a href="#l5.899"></a><span id="l5.899" class="difflineminus">-{</span>
<a href="#l5.900"></a><span id="l5.900" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder);</span>
<a href="#l5.901"></a><span id="l5.901" class="difflineminus">-  if (ownerFolder)</span>
<a href="#l5.902"></a><span id="l5.902" class="difflineminus">-  {</span>
<a href="#l5.903"></a><span id="l5.903" class="difflineplus">+void nsAutoSyncState::LogQWithSize(nsIMutableArray *q, uint32_t toOffset) {</span>
<a href="#l5.904"></a><span id="l5.904" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder);</span>
<a href="#l5.905"></a><span id="l5.905" class="difflineplus">+  if (ownerFolder) {</span>
<a href="#l5.906"></a><span id="l5.906">     nsCOMPtr&lt;nsIMsgDatabase&gt; database;</span>
<a href="#l5.907"></a><span id="l5.907">     ownerFolder-&gt;GetMsgDatabase(getter_AddRefs(database));</span>
<a href="#l5.908"></a><span id="l5.908"> </span>
<a href="#l5.909"></a><span id="l5.909">     uint32_t x;</span>
<a href="#l5.910"></a><span id="l5.910">     q-&gt;GetLength(&amp;x);</span>
<a href="#l5.911"></a><span id="l5.911" class="difflineminus">-    while (x &gt; toOffset &amp;&amp; database)</span>
<a href="#l5.912"></a><span id="l5.912" class="difflineminus">-    {</span>
<a href="#l5.913"></a><span id="l5.913" class="difflineplus">+    while (x &gt; toOffset &amp;&amp; database) {</span>
<a href="#l5.914"></a><span id="l5.914">       x--;</span>
<a href="#l5.915"></a><span id="l5.915">       nsCOMPtr&lt;nsIMsgDBHdr&gt; h = do_QueryElementAt(q, x);</span>
<a href="#l5.916"></a><span id="l5.916" class="difflineminus">-      if (h)</span>
<a href="#l5.917"></a><span id="l5.917" class="difflineminus">-      {</span>
<a href="#l5.918"></a><span id="l5.918" class="difflineplus">+      if (h) {</span>
<a href="#l5.919"></a><span id="l5.919">         uint32_t s;</span>
<a href="#l5.920"></a><span id="l5.920">         h-&gt;GetMessageSize(&amp;s);</span>
<a href="#l5.921"></a><span id="l5.921">         MOZ_LOG(gAutoSyncLog, LogLevel::Debug,</span>
<a href="#l5.922"></a><span id="l5.922" class="difflineminus">-              (&quot;Elem #%d, size: %u bytes\n&quot;, x+1, s));</span>
<a href="#l5.923"></a><span id="l5.923" class="difflineminus">-      }</span>
<a href="#l5.924"></a><span id="l5.924" class="difflineminus">-      else</span>
<a href="#l5.925"></a><span id="l5.925" class="difflineminus">-        MOZ_LOG(gAutoSyncLog, LogLevel::Debug, (&quot;null header in q at index %ul&quot;, x));</span>
<a href="#l5.926"></a><span id="l5.926" class="difflineplus">+                (&quot;Elem #%d, size: %u bytes\n&quot;, x + 1, s));</span>
<a href="#l5.927"></a><span id="l5.927" class="difflineplus">+      } else</span>
<a href="#l5.928"></a><span id="l5.928" class="difflineplus">+        MOZ_LOG(gAutoSyncLog, LogLevel::Debug,</span>
<a href="#l5.929"></a><span id="l5.929" class="difflineplus">+                (&quot;null header in q at index %ul&quot;, x));</span>
<a href="#l5.930"></a><span id="l5.930">     }</span>
<a href="#l5.931"></a><span id="l5.931">   }</span>
<a href="#l5.932"></a><span id="l5.932"> }</span>
<a href="#l5.933"></a><span id="l5.933"> </span>
<a href="#l5.934"></a><span id="l5.934" class="difflineminus">-void nsAutoSyncState::LogOwnerFolderName(const char *s)</span>
<a href="#l5.935"></a><span id="l5.935" class="difflineminus">-{</span>
<a href="#l5.936"></a><span id="l5.936" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder);</span>
<a href="#l5.937"></a><span id="l5.937" class="difflineminus">-  if (ownerFolder)</span>
<a href="#l5.938"></a><span id="l5.938" class="difflineminus">-  {</span>
<a href="#l5.939"></a><span id="l5.939" class="difflineplus">+void nsAutoSyncState::LogOwnerFolderName(const char *s) {</span>
<a href="#l5.940"></a><span id="l5.940" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder);</span>
<a href="#l5.941"></a><span id="l5.941" class="difflineplus">+  if (ownerFolder) {</span>
<a href="#l5.942"></a><span id="l5.942">     nsCString folderName;</span>
<a href="#l5.943"></a><span id="l5.943">     ownerFolder-&gt;GetURI(folderName);</span>
<a href="#l5.944"></a><span id="l5.944">     MOZ_LOG(gAutoSyncLog, LogLevel::Debug,</span>
<a href="#l5.945"></a><span id="l5.945" class="difflineminus">-           (&quot;*** %s Folder: %s ***\n&quot;, s, folderName.get()));</span>
<a href="#l5.946"></a><span id="l5.946" class="difflineplus">+            (&quot;*** %s Folder: %s ***\n&quot;, s, folderName.get()));</span>
<a href="#l5.947"></a><span id="l5.947">   }</span>
<a href="#l5.948"></a><span id="l5.948"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/imap/src/nsAutoSyncState.h</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/imap/src/nsAutoSyncState.h</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -17,49 +17,48 @@</span>
<a href="#l6.4"></a><span id="l6.4"> class nsImapMailFolder;</span>
<a href="#l6.5"></a><span id="l6.5"> class nsIAutoSyncMsgStrategy;</span>
<a href="#l6.6"></a><span id="l6.6"> class nsIMsgDatabase;</span>
<a href="#l6.7"></a><span id="l6.7"> </span>
<a href="#l6.8"></a><span id="l6.8"> /**</span>
<a href="#l6.9"></a><span id="l6.9">  * An adaptor class to make msg strategy nsTArray.Sort()</span>
<a href="#l6.10"></a><span id="l6.10">  * compatible.</span>
<a href="#l6.11"></a><span id="l6.11">  */</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-class MsgStrategyComparatorAdaptor</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineminus">-{</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+class MsgStrategyComparatorAdaptor {</span>
<a href="#l6.15"></a><span id="l6.15">  public:</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineminus">-  MsgStrategyComparatorAdaptor(nsIAutoSyncMsgStrategy* aStrategy,</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineminus">-    nsIMsgFolder *aFolder, nsIMsgDatabase *aDatabase);</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+  MsgStrategyComparatorAdaptor(nsIAutoSyncMsgStrategy *aStrategy,</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+                               nsIMsgFolder *aFolder,</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineplus">+                               nsIMsgDatabase *aDatabase);</span>
<a href="#l6.21"></a><span id="l6.21"> </span>
<a href="#l6.22"></a><span id="l6.22">   /** @return True if the elements are equals; false otherwise. */</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineminus">-  bool Equals(const nsMsgKey&amp; a, const nsMsgKey&amp; b) const;</span>
<a href="#l6.24"></a><span id="l6.24" class="difflineplus">+  bool Equals(const nsMsgKey &amp;a, const nsMsgKey &amp;b) const;</span>
<a href="#l6.25"></a><span id="l6.25"> </span>
<a href="#l6.26"></a><span id="l6.26">   /** @return True if (a &lt; b); false otherwise. */</span>
<a href="#l6.27"></a><span id="l6.27" class="difflineminus">-  bool LessThan(const nsMsgKey&amp; a, const nsMsgKey&amp; b) const;</span>
<a href="#l6.28"></a><span id="l6.28" class="difflineplus">+  bool LessThan(const nsMsgKey &amp;a, const nsMsgKey &amp;b) const;</span>
<a href="#l6.29"></a><span id="l6.29"> </span>
<a href="#l6.30"></a><span id="l6.30">  private:</span>
<a href="#l6.31"></a><span id="l6.31">   MsgStrategyComparatorAdaptor();</span>
<a href="#l6.32"></a><span id="l6.32"> </span>
<a href="#l6.33"></a><span id="l6.33">  private:</span>
<a href="#l6.34"></a><span id="l6.34">   nsIAutoSyncMsgStrategy *mStrategy;</span>
<a href="#l6.35"></a><span id="l6.35">   nsIMsgFolder *mFolder;</span>
<a href="#l6.36"></a><span id="l6.36">   nsIMsgDatabase *mDatabase;</span>
<a href="#l6.37"></a><span id="l6.37"> };</span>
<a href="#l6.38"></a><span id="l6.38"> </span>
<a href="#l6.39"></a><span id="l6.39" class="difflineminus">-</span>
<a href="#l6.40"></a><span id="l6.40"> /**</span>
<a href="#l6.41"></a><span id="l6.41">  * Facilitates auto-sync capabilities for imap folders.</span>
<a href="#l6.42"></a><span id="l6.42">  */</span>
<a href="#l6.43"></a><span id="l6.43" class="difflineminus">-class nsAutoSyncState final : public nsIAutoSyncState, public nsIUrlListener</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineminus">-{</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineminus">-public:</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineplus">+class nsAutoSyncState final : public nsIAutoSyncState, public nsIUrlListener {</span>
<a href="#l6.47"></a><span id="l6.47" class="difflineplus">+ public:</span>
<a href="#l6.48"></a><span id="l6.48">   NS_DECL_ISUPPORTS</span>
<a href="#l6.49"></a><span id="l6.49">   NS_DECL_NSIAUTOSYNCSTATE</span>
<a href="#l6.50"></a><span id="l6.50">   NS_DECL_NSIURLLISTENER</span>
<a href="#l6.51"></a><span id="l6.51"> </span>
<a href="#l6.52"></a><span id="l6.52" class="difflineminus">-  explicit nsAutoSyncState(nsImapMailFolder *aOwnerFolder, PRTime aLastSyncTime = 0UL);</span>
<a href="#l6.53"></a><span id="l6.53" class="difflineplus">+  explicit nsAutoSyncState(nsImapMailFolder *aOwnerFolder,</span>
<a href="#l6.54"></a><span id="l6.54" class="difflineplus">+                           PRTime aLastSyncTime = 0UL);</span>
<a href="#l6.55"></a><span id="l6.55"> </span>
<a href="#l6.56"></a><span id="l6.56">   /// Called by owner folder when new headers are fetched from the server</span>
<a href="#l6.57"></a><span id="l6.57">   void OnNewHeaderFetchCompleted(const nsTArray&lt;nsMsgKey&gt; &amp;aMsgKeyList);</span>
<a href="#l6.58"></a><span id="l6.58"> </span>
<a href="#l6.59"></a><span id="l6.59">   /// Sets the last sync time in lower precision (seconds)</span>
<a href="#l6.60"></a><span id="l6.60">   void SetLastSyncTimeInSec(int32_t aLastSyncTime);</span>
<a href="#l6.61"></a><span id="l6.61"> </span>
<a href="#l6.62"></a><span id="l6.62">   /// Manages storage space for auto-sync operations</span>
<a href="#l6.63"></a><span id="l6.63" class="difflineat">@@ -69,20 +68,20 @@ public:</span>
<a href="#l6.64"></a><span id="l6.64">                        int32_t nextUID);</span>
<a href="#l6.65"></a><span id="l6.65"> </span>
<a href="#l6.66"></a><span id="l6.66">  private:</span>
<a href="#l6.67"></a><span id="l6.67">   ~nsAutoSyncState();</span>
<a href="#l6.68"></a><span id="l6.68"> </span>
<a href="#l6.69"></a><span id="l6.69">   nsresult PlaceIntoDownloadQ(const nsTArray&lt;nsMsgKey&gt; &amp;aMsgKeyList);</span>
<a href="#l6.70"></a><span id="l6.70">   nsresult SortQueueBasedOnStrategy(nsTArray&lt;nsMsgKey&gt; &amp;aQueue);</span>
<a href="#l6.71"></a><span id="l6.71">   nsresult SortSubQueueBasedOnStrategy(nsTArray&lt;nsMsgKey&gt; &amp;aQueue,</span>
<a href="#l6.72"></a><span id="l6.72" class="difflineminus">-                                    uint32_t aStartingOffset);</span>
<a href="#l6.73"></a><span id="l6.73" class="difflineplus">+                                       uint32_t aStartingOffset);</span>
<a href="#l6.74"></a><span id="l6.74"> </span>
<a href="#l6.75"></a><span id="l6.75">   void LogOwnerFolderName(const char *s);</span>
<a href="#l6.76"></a><span id="l6.76" class="difflineminus">-  void LogQWithSize(nsTArray&lt;nsMsgKey&gt;&amp; q, uint32_t toOffset = 0);</span>
<a href="#l6.77"></a><span id="l6.77" class="difflineplus">+  void LogQWithSize(nsTArray&lt;nsMsgKey&gt; &amp;q, uint32_t toOffset = 0);</span>
<a href="#l6.78"></a><span id="l6.78">   void LogQWithSize(nsIMutableArray *q, uint32_t toOffset = 0);</span>
<a href="#l6.79"></a><span id="l6.79"> </span>
<a href="#l6.80"></a><span id="l6.80">  private:</span>
<a href="#l6.81"></a><span id="l6.81">   int32_t mSyncState;</span>
<a href="#l6.82"></a><span id="l6.82">   nsWeakPtr mOwnerFolder;</span>
<a href="#l6.83"></a><span id="l6.83">   uint32_t mOffset;</span>
<a href="#l6.84"></a><span id="l6.84">   uint32_t mLastOffset;</span>
<a href="#l6.85"></a><span id="l6.85"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPBodyShell.cpp</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPBodyShell.cpp</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -17,287 +17,254 @@ using namespace mozilla;</span>
<a href="#l7.4"></a><span id="l7.4"> extern LazyLogModule IMAPCache;  // defined in nsImapProtocol.cpp</span>
<a href="#l7.5"></a><span id="l7.5"> </span>
<a href="#l7.6"></a><span id="l7.6"> // imapbody.cpp</span>
<a href="#l7.7"></a><span id="l7.7"> // Implementation of the nsIMAPBodyShell and associated classes</span>
<a href="#l7.8"></a><span id="l7.8"> // These are used to parse IMAP BODYSTRUCTURE responses, and intelligently (?)</span>
<a href="#l7.9"></a><span id="l7.9"> // figure out what parts we need to display inline.</span>
<a href="#l7.10"></a><span id="l7.10"> </span>
<a href="#l7.11"></a><span id="l7.11"> /*</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-        Create a nsIMAPBodyShell from a full BODYSTRUCUTRE response from the parser.</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+   Create a nsIMAPBodyShell from a full BODYSTRUCUTRE response from the</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+   parser.</span>
<a href="#l7.15"></a><span id="l7.15"> </span>
<a href="#l7.16"></a><span id="l7.16" class="difflineminus">-        The body shell represents a single, top-level object, the message.  The message body</span>
<a href="#l7.17"></a><span id="l7.17" class="difflineminus">-        might be treated as either a container or a leaf (just like any arbitrary part).</span>
<a href="#l7.18"></a><span id="l7.18" class="difflineplus">+   The body shell represents a single, top-level object, the message.  The</span>
<a href="#l7.19"></a><span id="l7.19" class="difflineplus">+   message body might be treated as either a container or a leaf (just like any</span>
<a href="#l7.20"></a><span id="l7.20" class="difflineplus">+   arbitrary part).</span>
<a href="#l7.21"></a><span id="l7.21"> </span>
<a href="#l7.22"></a><span id="l7.22" class="difflineminus">-        Steps for creating a part:</span>
<a href="#l7.23"></a><span id="l7.23" class="difflineminus">-        1. Pull out the paren grouping for the part</span>
<a href="#l7.24"></a><span id="l7.24" class="difflineminus">-        2. Create a generic part object with that buffer</span>
<a href="#l7.25"></a><span id="l7.25" class="difflineminus">-        3. The factory will return either a leaf or container, depending on what it really is.</span>
<a href="#l7.26"></a><span id="l7.26" class="difflineminus">-        4. It is responsible for parsing its children, if there are any</span>
<a href="#l7.27"></a><span id="l7.27" class="difflineplus">+   Steps for creating a part:</span>
<a href="#l7.28"></a><span id="l7.28" class="difflineplus">+   1. Pull out the paren grouping for the part</span>
<a href="#l7.29"></a><span id="l7.29" class="difflineplus">+   2. Create a generic part object with that buffer</span>
<a href="#l7.30"></a><span id="l7.30" class="difflineplus">+   3. The factory will return either a leaf or container, depending on what</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineplus">+      it really is.</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+   4. It is responsible for parsing its children, if there are any</span>
<a href="#l7.33"></a><span id="l7.33"> */</span>
<a href="#l7.34"></a><span id="l7.34"> </span>
<a href="#l7.35"></a><span id="l7.35" class="difflineminus">-</span>
<a href="#l7.36"></a><span id="l7.36"> ///////////// nsIMAPBodyShell ////////////////////////////////////</span>
<a href="#l7.37"></a><span id="l7.37"> </span>
<a href="#l7.38"></a><span id="l7.38"> NS_IMPL_ISUPPORTS0(nsIMAPBodyShell)</span>
<a href="#l7.39"></a><span id="l7.39"> </span>
<a href="#l7.40"></a><span id="l7.40"> nsIMAPBodyShell::nsIMAPBodyShell(nsImapProtocol *protocolConnection,</span>
<a href="#l7.41"></a><span id="l7.41">                                  nsIMAPBodypartMessage *message, uint32_t UID,</span>
<a href="#l7.42"></a><span id="l7.42" class="difflineminus">-                                 uint32_t UIDValidity, const char *folderName)</span>
<a href="#l7.43"></a><span id="l7.43" class="difflineminus">-{</span>
<a href="#l7.44"></a><span id="l7.44" class="difflineplus">+                                 uint32_t UIDValidity, const char *folderName) {</span>
<a href="#l7.45"></a><span id="l7.45">   m_isValid = false;</span>
<a href="#l7.46"></a><span id="l7.46">   m_isBeingGenerated = false;</span>
<a href="#l7.47"></a><span id="l7.47">   m_cached = false;</span>
<a href="#l7.48"></a><span id="l7.48">   m_gotAttachmentPref = false;</span>
<a href="#l7.49"></a><span id="l7.49">   m_generatingWholeMessage = false;</span>
<a href="#l7.50"></a><span id="l7.50">   m_generatingPart = NULL;</span>
<a href="#l7.51"></a><span id="l7.51">   m_protocolConnection = protocolConnection;</span>
<a href="#l7.52"></a><span id="l7.52">   m_message = message;</span>
<a href="#l7.53"></a><span id="l7.53">   NS_ASSERTION(m_protocolConnection, &quot;non null connection&quot;);</span>
<a href="#l7.54"></a><span id="l7.54" class="difflineminus">-  if (!m_protocolConnection)</span>
<a href="#l7.55"></a><span id="l7.55" class="difflineminus">-    return;</span>
<a href="#l7.56"></a><span id="l7.56" class="difflineplus">+  if (!m_protocolConnection) return;</span>
<a href="#l7.57"></a><span id="l7.57">   m_prefetchQueue = new nsIMAPMessagePartIDArray();</span>
<a href="#l7.58"></a><span id="l7.58" class="difflineminus">-  if (!m_prefetchQueue)</span>
<a href="#l7.59"></a><span id="l7.59" class="difflineminus">-    return;</span>
<a href="#l7.60"></a><span id="l7.60" class="difflineplus">+  if (!m_prefetchQueue) return;</span>
<a href="#l7.61"></a><span id="l7.61">   m_UID = &quot;&quot;;</span>
<a href="#l7.62"></a><span id="l7.62">   m_UID.AppendInt(UID);</span>
<a href="#l7.63"></a><span id="l7.63">   m_UID_validity = m_UID;</span>
<a href="#l7.64"></a><span id="l7.64">   m_UID_validity.AppendInt(UIDValidity);</span>
<a href="#l7.65"></a><span id="l7.65"> #ifdef DEBUG_chrisf</span>
<a href="#l7.66"></a><span id="l7.66">   NS_ASSERTION(folderName);</span>
<a href="#l7.67"></a><span id="l7.67"> #endif</span>
<a href="#l7.68"></a><span id="l7.68" class="difflineminus">-  if (!folderName)</span>
<a href="#l7.69"></a><span id="l7.69" class="difflineminus">-    return;</span>
<a href="#l7.70"></a><span id="l7.70" class="difflineplus">+  if (!folderName) return;</span>
<a href="#l7.71"></a><span id="l7.71">   m_folderName = NS_xstrdup(folderName);</span>
<a href="#l7.72"></a><span id="l7.72" class="difflineminus">-  if (!m_folderName)</span>
<a href="#l7.73"></a><span id="l7.73" class="difflineminus">-    return;</span>
<a href="#l7.74"></a><span id="l7.74" class="difflineplus">+  if (!m_folderName) return;</span>
<a href="#l7.75"></a><span id="l7.75"> </span>
<a href="#l7.76"></a><span id="l7.76" class="difflineminus">-  SetContentModified(GetShowAttachmentsInline() ? IMAP_CONTENT_MODIFIED_VIEW_INLINE : IMAP_CONTENT_MODIFIED_VIEW_AS_LINKS);</span>
<a href="#l7.77"></a><span id="l7.77" class="difflineplus">+  SetContentModified(GetShowAttachmentsInline()</span>
<a href="#l7.78"></a><span id="l7.78" class="difflineplus">+                         ? IMAP_CONTENT_MODIFIED_VIEW_INLINE</span>
<a href="#l7.79"></a><span id="l7.79" class="difflineplus">+                         : IMAP_CONTENT_MODIFIED_VIEW_AS_LINKS);</span>
<a href="#l7.80"></a><span id="l7.80"> </span>
<a href="#l7.81"></a><span id="l7.81">   SetIsValid(m_message != nullptr);</span>
<a href="#l7.82"></a><span id="l7.82"> }</span>
<a href="#l7.83"></a><span id="l7.83"> </span>
<a href="#l7.84"></a><span id="l7.84" class="difflineminus">-nsIMAPBodyShell::~nsIMAPBodyShell()</span>
<a href="#l7.85"></a><span id="l7.85" class="difflineminus">-{</span>
<a href="#l7.86"></a><span id="l7.86" class="difflineplus">+nsIMAPBodyShell::~nsIMAPBodyShell() {</span>
<a href="#l7.87"></a><span id="l7.87">   delete m_message;</span>
<a href="#l7.88"></a><span id="l7.88">   delete m_prefetchQueue;</span>
<a href="#l7.89"></a><span id="l7.89">   PR_Free(m_folderName);</span>
<a href="#l7.90"></a><span id="l7.90"> }</span>
<a href="#l7.91"></a><span id="l7.91"> </span>
<a href="#l7.92"></a><span id="l7.92" class="difflineminus">-void nsIMAPBodyShell::SetIsValid(bool valid)</span>
<a href="#l7.93"></a><span id="l7.93" class="difflineminus">-{</span>
<a href="#l7.94"></a><span id="l7.94" class="difflineminus">-  m_isValid = valid;</span>
<a href="#l7.95"></a><span id="l7.95" class="difflineminus">-}</span>
<a href="#l7.96"></a><span id="l7.96" class="difflineplus">+void nsIMAPBodyShell::SetIsValid(bool valid) { m_isValid = valid; }</span>
<a href="#l7.97"></a><span id="l7.97"> </span>
<a href="#l7.98"></a><span id="l7.98" class="difflineminus">-bool nsIMAPBodyShell::GetShowAttachmentsInline()</span>
<a href="#l7.99"></a><span id="l7.99" class="difflineminus">-{</span>
<a href="#l7.100"></a><span id="l7.100" class="difflineminus">-  if (!m_gotAttachmentPref)</span>
<a href="#l7.101"></a><span id="l7.101" class="difflineminus">-  {</span>
<a href="#l7.102"></a><span id="l7.102" class="difflineminus">-    m_showAttachmentsInline = !m_protocolConnection || m_protocolConnection-&gt;GetShowAttachmentsInline();</span>
<a href="#l7.103"></a><span id="l7.103" class="difflineplus">+bool nsIMAPBodyShell::GetShowAttachmentsInline() {</span>
<a href="#l7.104"></a><span id="l7.104" class="difflineplus">+  if (!m_gotAttachmentPref) {</span>
<a href="#l7.105"></a><span id="l7.105" class="difflineplus">+    m_showAttachmentsInline = !m_protocolConnection ||</span>
<a href="#l7.106"></a><span id="l7.106" class="difflineplus">+                              m_protocolConnection-&gt;GetShowAttachmentsInline();</span>
<a href="#l7.107"></a><span id="l7.107">     m_gotAttachmentPref = true;</span>
<a href="#l7.108"></a><span id="l7.108">   }</span>
<a href="#l7.109"></a><span id="l7.109"> </span>
<a href="#l7.110"></a><span id="l7.110">   return m_showAttachmentsInline;</span>
<a href="#l7.111"></a><span id="l7.111"> }</span>
<a href="#l7.112"></a><span id="l7.112"> </span>
<a href="#l7.113"></a><span id="l7.113"> // Fills in buffer (and adopts storage) for header object</span>
<a href="#l7.114"></a><span id="l7.114" class="difflineminus">-void nsIMAPBodyShell::AdoptMessageHeaders(char *headers, const char *partNum)</span>
<a href="#l7.115"></a><span id="l7.115" class="difflineminus">-{</span>
<a href="#l7.116"></a><span id="l7.116" class="difflineminus">-  if (!GetIsValid())</span>
<a href="#l7.117"></a><span id="l7.117" class="difflineminus">-    return;</span>
<a href="#l7.118"></a><span id="l7.118" class="difflineplus">+void nsIMAPBodyShell::AdoptMessageHeaders(char *headers, const char *partNum) {</span>
<a href="#l7.119"></a><span id="l7.119" class="difflineplus">+  if (!GetIsValid()) return;</span>
<a href="#l7.120"></a><span id="l7.120"> </span>
<a href="#l7.121"></a><span id="l7.121" class="difflineminus">-  if (!partNum)</span>
<a href="#l7.122"></a><span id="l7.122" class="difflineminus">-    partNum = &quot;0&quot;;</span>
<a href="#l7.123"></a><span id="l7.123" class="difflineplus">+  if (!partNum) partNum = &quot;0&quot;;</span>
<a href="#l7.124"></a><span id="l7.124"> </span>
<a href="#l7.125"></a><span id="l7.125">   // we are going to say that a message header object only has</span>
<a href="#l7.126"></a><span id="l7.126">   // part data, and no header data.</span>
<a href="#l7.127"></a><span id="l7.127">   nsIMAPBodypart *foundPart = m_message-&gt;FindPartWithNumber(partNum);</span>
<a href="#l7.128"></a><span id="l7.128" class="difflineminus">-  if (foundPart)</span>
<a href="#l7.129"></a><span id="l7.129" class="difflineminus">-  {</span>
<a href="#l7.130"></a><span id="l7.130" class="difflineplus">+  if (foundPart) {</span>
<a href="#l7.131"></a><span id="l7.131">     nsIMAPBodypartMessage *messageObj = foundPart-&gt;GetnsIMAPBodypartMessage();</span>
<a href="#l7.132"></a><span id="l7.132" class="difflineminus">-    if (messageObj)</span>
<a href="#l7.133"></a><span id="l7.133" class="difflineminus">-    {</span>
<a href="#l7.134"></a><span id="l7.134" class="difflineplus">+    if (messageObj) {</span>
<a href="#l7.135"></a><span id="l7.135">       messageObj-&gt;AdoptMessageHeaders(headers);</span>
<a href="#l7.136"></a><span id="l7.136" class="difflineminus">-      if (!messageObj-&gt;GetIsValid())</span>
<a href="#l7.137"></a><span id="l7.137" class="difflineminus">-        SetIsValid(false);</span>
<a href="#l7.138"></a><span id="l7.138" class="difflineminus">-    }</span>
<a href="#l7.139"></a><span id="l7.139" class="difflineminus">-    else</span>
<a href="#l7.140"></a><span id="l7.140" class="difflineminus">-    {</span>
<a href="#l7.141"></a><span id="l7.141" class="difflineplus">+      if (!messageObj-&gt;GetIsValid()) SetIsValid(false);</span>
<a href="#l7.142"></a><span id="l7.142" class="difflineplus">+    } else {</span>
<a href="#l7.143"></a><span id="l7.143">       // We were filling in message headers for a given part number.</span>
<a href="#l7.144"></a><span id="l7.144">       // We looked up that part number, found an object, but it</span>
<a href="#l7.145"></a><span id="l7.145">       // wasn't of type message/rfc822.</span>
<a href="#l7.146"></a><span id="l7.146">       // Something's wrong.</span>
<a href="#l7.147"></a><span id="l7.147">       NS_ASSERTION(false, &quot;object not of type message rfc822&quot;);</span>
<a href="#l7.148"></a><span id="l7.148">     }</span>
<a href="#l7.149"></a><span id="l7.149" class="difflineminus">-  }</span>
<a href="#l7.150"></a><span id="l7.150" class="difflineminus">-  else</span>
<a href="#l7.151"></a><span id="l7.151" class="difflineplus">+  } else</span>
<a href="#l7.152"></a><span id="l7.152">     SetIsValid(false);</span>
<a href="#l7.153"></a><span id="l7.153"> }</span>
<a href="#l7.154"></a><span id="l7.154"> </span>
<a href="#l7.155"></a><span id="l7.155"> // Fills in buffer (and adopts storage) for MIME headers in appropriate object.</span>
<a href="#l7.156"></a><span id="l7.156"> // If object can't be found, sets isValid to false.</span>
<a href="#l7.157"></a><span id="l7.157" class="difflineminus">-void nsIMAPBodyShell::AdoptMimeHeader(const char *partNum, char *mimeHeader)</span>
<a href="#l7.158"></a><span id="l7.158" class="difflineminus">-{</span>
<a href="#l7.159"></a><span id="l7.159" class="difflineminus">-  if (!GetIsValid())</span>
<a href="#l7.160"></a><span id="l7.160" class="difflineminus">-    return;</span>
<a href="#l7.161"></a><span id="l7.161" class="difflineplus">+void nsIMAPBodyShell::AdoptMimeHeader(const char *partNum, char *mimeHeader) {</span>
<a href="#l7.162"></a><span id="l7.162" class="difflineplus">+  if (!GetIsValid()) return;</span>
<a href="#l7.163"></a><span id="l7.163"> </span>
<a href="#l7.164"></a><span id="l7.164">   NS_ASSERTION(partNum, &quot;null partnum in body shell&quot;);</span>
<a href="#l7.165"></a><span id="l7.165"> </span>
<a href="#l7.166"></a><span id="l7.166">   nsIMAPBodypart *foundPart = m_message-&gt;FindPartWithNumber(partNum);</span>
<a href="#l7.167"></a><span id="l7.167"> </span>
<a href="#l7.168"></a><span id="l7.168" class="difflineminus">-  if (foundPart)</span>
<a href="#l7.169"></a><span id="l7.169" class="difflineminus">-  {</span>
<a href="#l7.170"></a><span id="l7.170" class="difflineplus">+  if (foundPart) {</span>
<a href="#l7.171"></a><span id="l7.171">     foundPart-&gt;AdoptHeaderDataBuffer(mimeHeader);</span>
<a href="#l7.172"></a><span id="l7.172" class="difflineminus">-    if (!foundPart-&gt;GetIsValid())</span>
<a href="#l7.173"></a><span id="l7.173" class="difflineminus">-      SetIsValid(false);</span>
<a href="#l7.174"></a><span id="l7.174" class="difflineminus">-  }</span>
<a href="#l7.175"></a><span id="l7.175" class="difflineminus">-  else</span>
<a href="#l7.176"></a><span id="l7.176" class="difflineminus">-  {</span>
<a href="#l7.177"></a><span id="l7.177" class="difflineplus">+    if (!foundPart-&gt;GetIsValid()) SetIsValid(false);</span>
<a href="#l7.178"></a><span id="l7.178" class="difflineplus">+  } else {</span>
<a href="#l7.179"></a><span id="l7.179">     SetIsValid(false);</span>
<a href="#l7.180"></a><span id="l7.180">   }</span>
<a href="#l7.181"></a><span id="l7.181"> }</span>
<a href="#l7.182"></a><span id="l7.182"> </span>
<a href="#l7.183"></a><span id="l7.183" class="difflineminus">-</span>
<a href="#l7.184"></a><span id="l7.184" class="difflineminus">-void nsIMAPBodyShell::AddPrefetchToQueue(nsIMAPeFetchFields fields, const char *partNumber)</span>
<a href="#l7.185"></a><span id="l7.185" class="difflineminus">-{</span>
<a href="#l7.186"></a><span id="l7.186" class="difflineplus">+void nsIMAPBodyShell::AddPrefetchToQueue(nsIMAPeFetchFields fields,</span>
<a href="#l7.187"></a><span id="l7.187" class="difflineplus">+                                         const char *partNumber) {</span>
<a href="#l7.188"></a><span id="l7.188">   nsIMAPMessagePartID *newPart = new nsIMAPMessagePartID(fields, partNumber);</span>
<a href="#l7.189"></a><span id="l7.189" class="difflineminus">-  if (newPart)</span>
<a href="#l7.190"></a><span id="l7.190" class="difflineminus">-  {</span>
<a href="#l7.191"></a><span id="l7.191" class="difflineplus">+  if (newPart) {</span>
<a href="#l7.192"></a><span id="l7.192">     m_prefetchQueue-&gt;AppendElement(newPart);</span>
<a href="#l7.193"></a><span id="l7.193" class="difflineminus">-  }</span>
<a href="#l7.194"></a><span id="l7.194" class="difflineminus">-  else</span>
<a href="#l7.195"></a><span id="l7.195" class="difflineminus">-  {</span>
<a href="#l7.196"></a><span id="l7.196" class="difflineplus">+  } else {</span>
<a href="#l7.197"></a><span id="l7.197">     // HandleMemoryFailure();</span>
<a href="#l7.198"></a><span id="l7.198">   }</span>
<a href="#l7.199"></a><span id="l7.199"> }</span>
<a href="#l7.200"></a><span id="l7.200"> </span>
<a href="#l7.201"></a><span id="l7.201"> // Flushes all of the prefetches that have been queued up in the prefetch queue,</span>
<a href="#l7.202"></a><span id="l7.202"> // freeing them as we go</span>
<a href="#l7.203"></a><span id="l7.203" class="difflineminus">-void nsIMAPBodyShell::FlushPrefetchQueue()</span>
<a href="#l7.204"></a><span id="l7.204" class="difflineminus">-{</span>
<a href="#l7.205"></a><span id="l7.205" class="difflineplus">+void nsIMAPBodyShell::FlushPrefetchQueue() {</span>
<a href="#l7.206"></a><span id="l7.206">   m_protocolConnection-&gt;PipelinedFetchMessageParts(GetUID(), m_prefetchQueue);</span>
<a href="#l7.207"></a><span id="l7.207">   m_prefetchQueue-&gt;RemoveAndFreeAll();</span>
<a href="#l7.208"></a><span id="l7.208"> }</span>
<a href="#l7.209"></a><span id="l7.209"> </span>
<a href="#l7.210"></a><span id="l7.210"> // Requires that the shell is valid when called</span>
<a href="#l7.211"></a><span id="l7.211"> // Performs a preflight check on all message parts to see if they are all</span>
<a href="#l7.212"></a><span id="l7.212"> // inline.  Returns true if all parts are inline, false otherwise.</span>
<a href="#l7.213"></a><span id="l7.213" class="difflineminus">-bool nsIMAPBodyShell::PreflightCheckAllInline()</span>
<a href="#l7.214"></a><span id="l7.214" class="difflineminus">-{</span>
<a href="#l7.215"></a><span id="l7.215" class="difflineplus">+bool nsIMAPBodyShell::PreflightCheckAllInline() {</span>
<a href="#l7.216"></a><span id="l7.216">   bool rv = m_message-&gt;PreflightCheckAllInline(this);</span>
<a href="#l7.217"></a><span id="l7.217">   //  if (rv)</span>
<a href="#l7.218"></a><span id="l7.218" class="difflineminus">-  //    MOZ_LOG(IMAP, out, (&quot;BODYSHELL: All parts inline.  Reverting to whole message download.&quot;));</span>
<a href="#l7.219"></a><span id="l7.219" class="difflineplus">+  //    MOZ_LOG(IMAP, out, (&quot;BODYSHELL: All parts inline.  Reverting to whole</span>
<a href="#l7.220"></a><span id="l7.220" class="difflineplus">+  //    message download.&quot;));</span>
<a href="#l7.221"></a><span id="l7.221">   return rv;</span>
<a href="#l7.222"></a><span id="l7.222"> }</span>
<a href="#l7.223"></a><span id="l7.223"> </span>
<a href="#l7.224"></a><span id="l7.224"> // When partNum is NULL, Generates a whole message and intelligently</span>
<a href="#l7.225"></a><span id="l7.225"> // leaves out parts that are not inline.</span>
<a href="#l7.226"></a><span id="l7.226"> </span>
<a href="#l7.227"></a><span id="l7.227" class="difflineminus">-// When partNum is not NULL, Generates a MIME part that hasn't been downloaded yet</span>
<a href="#l7.228"></a><span id="l7.228" class="difflineminus">-// Ok, here's how we're going to do this.  Essentially, this</span>
<a href="#l7.229"></a><span id="l7.229" class="difflineminus">-// will be the mirror image of the &quot;normal&quot; generation.</span>
<a href="#l7.230"></a><span id="l7.230" class="difflineminus">-// All parts will be left out except a single part which is</span>
<a href="#l7.231"></a><span id="l7.231" class="difflineminus">-// explicitly specified.  All relevant headers will be included.</span>
<a href="#l7.232"></a><span id="l7.232" class="difflineminus">-// Libmime will extract only the part of interest, so we don't</span>
<a href="#l7.233"></a><span id="l7.233" class="difflineminus">-// have to worry about the other parts.  This also has the</span>
<a href="#l7.234"></a><span id="l7.234" class="difflineminus">-// advantage that it looks like it will be more workable for</span>
<a href="#l7.235"></a><span id="l7.235" class="difflineminus">-// nested parts.  For instance, if a user clicks on a link to</span>
<a href="#l7.236"></a><span id="l7.236" class="difflineminus">-// a forwarded message, then that forwarded message may be</span>
<a href="#l7.237"></a><span id="l7.237" class="difflineminus">-// generated along with any images that the forwarded message</span>
<a href="#l7.238"></a><span id="l7.238" class="difflineminus">-// contains, for instance.</span>
<a href="#l7.239"></a><span id="l7.239" class="difflineplus">+// When partNum is not NULL, Generates a MIME part that hasn't been downloaded</span>
<a href="#l7.240"></a><span id="l7.240" class="difflineplus">+// yet Ok, here's how we're going to do this.  Essentially, this will be the</span>
<a href="#l7.241"></a><span id="l7.241" class="difflineplus">+// mirror image of the &quot;normal&quot; generation. All parts will be left out except a</span>
<a href="#l7.242"></a><span id="l7.242" class="difflineplus">+// single part which is explicitly specified.  All relevant headers will be</span>
<a href="#l7.243"></a><span id="l7.243" class="difflineplus">+// included. Libmime will extract only the part of interest, so we don't have to</span>
<a href="#l7.244"></a><span id="l7.244" class="difflineplus">+// worry about the other parts.  This also has the advantage that it looks like</span>
<a href="#l7.245"></a><span id="l7.245" class="difflineplus">+// it will be more workable for nested parts.  For instance, if a user clicks on</span>
<a href="#l7.246"></a><span id="l7.246" class="difflineplus">+// a link to a forwarded message, then that forwarded message may be generated</span>
<a href="#l7.247"></a><span id="l7.247" class="difflineplus">+// along with any images that the forwarded message contains, for instance.</span>
<a href="#l7.248"></a><span id="l7.248"> </span>
<a href="#l7.249"></a><span id="l7.249" class="difflineminus">-</span>
<a href="#l7.250"></a><span id="l7.250" class="difflineminus">-int32_t nsIMAPBodyShell::Generate(char *partNum)</span>
<a href="#l7.251"></a><span id="l7.251" class="difflineminus">-{</span>
<a href="#l7.252"></a><span id="l7.252" class="difflineplus">+int32_t nsIMAPBodyShell::Generate(char *partNum) {</span>
<a href="#l7.253"></a><span id="l7.253">   m_isBeingGenerated = true;</span>
<a href="#l7.254"></a><span id="l7.254">   m_generatingPart = partNum;</span>
<a href="#l7.255"></a><span id="l7.255">   int32_t contentLength = 0;</span>
<a href="#l7.256"></a><span id="l7.256"> </span>
<a href="#l7.257"></a><span id="l7.257" class="difflineminus">-  if (!GetIsValid() || PreflightCheckAllInline())</span>
<a href="#l7.258"></a><span id="l7.258" class="difflineminus">-  {</span>
<a href="#l7.259"></a><span id="l7.259" class="difflineminus">-    // We don't have a valid shell, or all parts are going to be inline anyway.  Fall back to fetching the whole message.</span>
<a href="#l7.260"></a><span id="l7.260" class="difflineplus">+  if (!GetIsValid() || PreflightCheckAllInline()) {</span>
<a href="#l7.261"></a><span id="l7.261" class="difflineplus">+    // We don't have a valid shell, or all parts are going to be inline anyway.</span>
<a href="#l7.262"></a><span id="l7.262" class="difflineplus">+    // Fall back to fetching the whole message.</span>
<a href="#l7.263"></a><span id="l7.263"> #ifdef DEBUG_chrisf</span>
<a href="#l7.264"></a><span id="l7.264">     NS_ASSERTION(GetIsValid());</span>
<a href="#l7.265"></a><span id="l7.265"> #endif</span>
<a href="#l7.266"></a><span id="l7.266">     m_generatingWholeMessage = true;</span>
<a href="#l7.267"></a><span id="l7.267" class="difflineminus">-    uint32_t messageSize = m_protocolConnection-&gt;GetMessageSize(GetUID().get(), true);</span>
<a href="#l7.268"></a><span id="l7.268" class="difflineminus">-    MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;Generate(): Set IMAP_CONTENT_NOT MODIFIED&quot;));</span>
<a href="#l7.269"></a><span id="l7.269" class="difflineminus">-    m_protocolConnection-&gt;SetContentModified(IMAP_CONTENT_NOT_MODIFIED);  // So that when we cache it, we know we have the whole message</span>
<a href="#l7.270"></a><span id="l7.270" class="difflineplus">+    uint32_t messageSize =</span>
<a href="#l7.271"></a><span id="l7.271" class="difflineplus">+        m_protocolConnection-&gt;GetMessageSize(GetUID().get(), true);</span>
<a href="#l7.272"></a><span id="l7.272" class="difflineplus">+    MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l7.273"></a><span id="l7.273" class="difflineplus">+            (&quot;Generate(): Set IMAP_CONTENT_NOT MODIFIED&quot;));</span>
<a href="#l7.274"></a><span id="l7.274" class="difflineplus">+    m_protocolConnection-&gt;SetContentModified(</span>
<a href="#l7.275"></a><span id="l7.275" class="difflineplus">+        IMAP_CONTENT_NOT_MODIFIED);  // So that when we cache it, we know we</span>
<a href="#l7.276"></a><span id="l7.276" class="difflineplus">+                                     // have the whole message</span>
<a href="#l7.277"></a><span id="l7.277">     if (!DeathSignalReceived())</span>
<a href="#l7.278"></a><span id="l7.278">       m_protocolConnection-&gt;FallbackToFetchWholeMsg(GetUID(), messageSize);</span>
<a href="#l7.279"></a><span id="l7.279" class="difflineminus">-    contentLength = (int32_t) messageSize;  // ugh</span>
<a href="#l7.280"></a><span id="l7.280" class="difflineminus">-  }</span>
<a href="#l7.281"></a><span id="l7.281" class="difflineminus">-  else</span>
<a href="#l7.282"></a><span id="l7.282" class="difflineminus">-  {</span>
<a href="#l7.283"></a><span id="l7.283" class="difflineplus">+    contentLength = (int32_t)messageSize;  // ugh</span>
<a href="#l7.284"></a><span id="l7.284" class="difflineplus">+  } else {</span>
<a href="#l7.285"></a><span id="l7.285">     // We have a valid shell.</span>
<a href="#l7.286"></a><span id="l7.286">     bool streamCreated = false;</span>
<a href="#l7.287"></a><span id="l7.287">     m_generatingWholeMessage = false;</span>
<a href="#l7.288"></a><span id="l7.288"> </span>
<a href="#l7.289"></a><span id="l7.289">     ////// PASS 1 : PREFETCH ///////</span>
<a href="#l7.290"></a><span id="l7.290">     // First, prefetch any additional headers/data that we need</span>
<a href="#l7.291"></a><span id="l7.291">     if (!GetPseudoInterrupted())</span>
<a href="#l7.292"></a><span id="l7.292" class="difflineminus">-      m_message-&gt;Generate(this, false, true); // This queues up everything we need to prefetch</span>
<a href="#l7.293"></a><span id="l7.293" class="difflineplus">+      m_message-&gt;Generate(</span>
<a href="#l7.294"></a><span id="l7.294" class="difflineplus">+          this, false, true);  // This queues up everything we need to prefetch</span>
<a href="#l7.295"></a><span id="l7.295">     // Now, run a single pipelined prefetch  (neato!)</span>
<a href="#l7.296"></a><span id="l7.296">     FlushPrefetchQueue();</span>
<a href="#l7.297"></a><span id="l7.297"> </span>
<a href="#l7.298"></a><span id="l7.298">     ////// PASS 2 : COMPUTE STREAM SIZE ///////</span>
<a href="#l7.299"></a><span id="l7.299">     // Next, figure out the size from the parts that we're going to fill in,</span>
<a href="#l7.300"></a><span id="l7.300">     // plus all of the MIME headers, plus the message header itself</span>
<a href="#l7.301"></a><span id="l7.301">     if (!GetPseudoInterrupted())</span>
<a href="#l7.302"></a><span id="l7.302">       contentLength = m_message-&gt;Generate(this, false, false);</span>
<a href="#l7.303"></a><span id="l7.303"> </span>
<a href="#l7.304"></a><span id="l7.304">     // Setup the stream</span>
<a href="#l7.305"></a><span id="l7.305" class="difflineminus">-    if (!GetPseudoInterrupted() &amp;&amp; !DeathSignalReceived())</span>
<a href="#l7.306"></a><span id="l7.306" class="difflineminus">-    {</span>
<a href="#l7.307"></a><span id="l7.307" class="difflineminus">-      nsresult rv =</span>
<a href="#l7.308"></a><span id="l7.308" class="difflineminus">-        m_protocolConnection-&gt;BeginMessageDownLoad(contentLength, MESSAGE_RFC822);</span>
<a href="#l7.309"></a><span id="l7.309" class="difflineminus">-      if (NS_FAILED(rv))</span>
<a href="#l7.310"></a><span id="l7.310" class="difflineminus">-      {</span>
<a href="#l7.311"></a><span id="l7.311" class="difflineplus">+    if (!GetPseudoInterrupted() &amp;&amp; !DeathSignalReceived()) {</span>
<a href="#l7.312"></a><span id="l7.312" class="difflineplus">+      nsresult rv = m_protocolConnection-&gt;BeginMessageDownLoad(contentLength,</span>
<a href="#l7.313"></a><span id="l7.313" class="difflineplus">+                                                               MESSAGE_RFC822);</span>
<a href="#l7.314"></a><span id="l7.314" class="difflineplus">+      if (NS_FAILED(rv)) {</span>
<a href="#l7.315"></a><span id="l7.315">         m_generatingPart = nullptr;</span>
<a href="#l7.316"></a><span id="l7.316">         m_protocolConnection-&gt;AbortMessageDownLoad();</span>
<a href="#l7.317"></a><span id="l7.317">         return 0;</span>
<a href="#l7.318"></a><span id="l7.318">       }</span>
<a href="#l7.319"></a><span id="l7.319">       streamCreated = true;</span>
<a href="#l7.320"></a><span id="l7.320">     }</span>
<a href="#l7.321"></a><span id="l7.321"> </span>
<a href="#l7.322"></a><span id="l7.322">     ////// PASS 3 : GENERATE ///////</span>
<a href="#l7.323"></a><span id="l7.323">     // Generate the message</span>
<a href="#l7.324"></a><span id="l7.324">     if (!GetPseudoInterrupted() &amp;&amp; !DeathSignalReceived())</span>
<a href="#l7.325"></a><span id="l7.325">       m_message-&gt;Generate(this, true, false);</span>
<a href="#l7.326"></a><span id="l7.326"> </span>
<a href="#l7.327"></a><span id="l7.327" class="difflineminus">-    // Close the stream here - normal.  If pseudointerrupted, the connection will abort the download stream</span>
<a href="#l7.328"></a><span id="l7.328" class="difflineplus">+    // Close the stream here - normal.  If pseudointerrupted, the connection</span>
<a href="#l7.329"></a><span id="l7.329" class="difflineplus">+    // will abort the download stream</span>
<a href="#l7.330"></a><span id="l7.330">     if (!GetPseudoInterrupted() &amp;&amp; !DeathSignalReceived())</span>
<a href="#l7.331"></a><span id="l7.331">       m_protocolConnection-&gt;NormalMessageEndDownload();</span>
<a href="#l7.332"></a><span id="l7.332">     else if (streamCreated)</span>
<a href="#l7.333"></a><span id="l7.333">       m_protocolConnection-&gt;AbortMessageDownLoad();</span>
<a href="#l7.334"></a><span id="l7.334"> </span>
<a href="#l7.335"></a><span id="l7.335">     m_generatingPart = NULL;</span>
<a href="#l7.336"></a><span id="l7.336">   }</span>
<a href="#l7.337"></a><span id="l7.337"> </span>
<a href="#l7.338"></a><span id="l7.338">   m_isBeingGenerated = false;</span>
<a href="#l7.339"></a><span id="l7.339">   return contentLength;</span>
<a href="#l7.340"></a><span id="l7.340"> }</span>
<a href="#l7.341"></a><span id="l7.341"> </span>
<a href="#l7.342"></a><span id="l7.342" class="difflineminus">-bool nsIMAPBodyShell::GetPseudoInterrupted()</span>
<a href="#l7.343"></a><span id="l7.343" class="difflineminus">-{</span>
<a href="#l7.344"></a><span id="l7.344" class="difflineplus">+bool nsIMAPBodyShell::GetPseudoInterrupted() {</span>
<a href="#l7.345"></a><span id="l7.345">   bool rv = m_protocolConnection-&gt;GetPseudoInterrupted();</span>
<a href="#l7.346"></a><span id="l7.346">   return rv;</span>
<a href="#l7.347"></a><span id="l7.347"> }</span>
<a href="#l7.348"></a><span id="l7.348"> </span>
<a href="#l7.349"></a><span id="l7.349" class="difflineminus">-bool nsIMAPBodyShell::DeathSignalReceived()</span>
<a href="#l7.350"></a><span id="l7.350" class="difflineminus">-{</span>
<a href="#l7.351"></a><span id="l7.351" class="difflineplus">+bool nsIMAPBodyShell::DeathSignalReceived() {</span>
<a href="#l7.352"></a><span id="l7.352">   bool rv = m_protocolConnection-&gt;DeathSignalReceived();</span>
<a href="#l7.353"></a><span id="l7.353">   return rv;</span>
<a href="#l7.354"></a><span id="l7.354"> }</span>
<a href="#l7.355"></a><span id="l7.355"> </span>
<a href="#l7.356"></a><span id="l7.356" class="difflineminus">-</span>
<a href="#l7.357"></a><span id="l7.357"> ///////////// nsIMAPBodypart ////////////////////////////////////</span>
<a href="#l7.358"></a><span id="l7.358"> </span>
<a href="#l7.359"></a><span id="l7.359" class="difflineminus">-nsIMAPBodypart::nsIMAPBodypart(char *partNumber, nsIMAPBodypart *parentPart)</span>
<a href="#l7.360"></a><span id="l7.360" class="difflineminus">-{</span>
<a href="#l7.361"></a><span id="l7.361" class="difflineplus">+nsIMAPBodypart::nsIMAPBodypart(char *partNumber, nsIMAPBodypart *parentPart) {</span>
<a href="#l7.362"></a><span id="l7.362">   SetIsValid(true);</span>
<a href="#l7.363"></a><span id="l7.363">   m_parentPart = parentPart;</span>
<a href="#l7.364"></a><span id="l7.364">   m_partNumberString = partNumber;  // storage adopted</span>
<a href="#l7.365"></a><span id="l7.365">   m_partData = NULL;</span>
<a href="#l7.366"></a><span id="l7.366">   m_headerData = NULL;</span>
<a href="#l7.367"></a><span id="l7.367">   m_boundaryData = NULL;  // initialize from parsed BODYSTRUCTURE</span>
<a href="#l7.368"></a><span id="l7.368">   m_contentLength = 0;</span>
<a href="#l7.369"></a><span id="l7.369">   m_partLength = 0;</span>
<a href="#l7.370"></a><span id="l7.370" class="difflineat">@@ -305,64 +272,57 @@ nsIMAPBodypart::nsIMAPBodypart(char *par</span>
<a href="#l7.371"></a><span id="l7.371">   m_contentType = NULL;</span>
<a href="#l7.372"></a><span id="l7.372">   m_bodyType = NULL;</span>
<a href="#l7.373"></a><span id="l7.373">   m_bodySubType = NULL;</span>
<a href="#l7.374"></a><span id="l7.374">   m_bodyID = NULL;</span>
<a href="#l7.375"></a><span id="l7.375">   m_bodyDescription = NULL;</span>
<a href="#l7.376"></a><span id="l7.376">   m_bodyEncoding = NULL;</span>
<a href="#l7.377"></a><span id="l7.377"> }</span>
<a href="#l7.378"></a><span id="l7.378"> </span>
<a href="#l7.379"></a><span id="l7.379" class="difflineminus">-nsIMAPBodypart::~nsIMAPBodypart()</span>
<a href="#l7.380"></a><span id="l7.380" class="difflineminus">-{</span>
<a href="#l7.381"></a><span id="l7.381" class="difflineplus">+nsIMAPBodypart::~nsIMAPBodypart() {</span>
<a href="#l7.382"></a><span id="l7.382">   PR_FREEIF(m_partNumberString);</span>
<a href="#l7.383"></a><span id="l7.383">   PR_FREEIF(m_contentType);</span>
<a href="#l7.384"></a><span id="l7.384">   PR_FREEIF(m_bodyType);</span>
<a href="#l7.385"></a><span id="l7.385">   PR_FREEIF(m_bodySubType);</span>
<a href="#l7.386"></a><span id="l7.386">   PR_FREEIF(m_bodyID);</span>
<a href="#l7.387"></a><span id="l7.387">   PR_FREEIF(m_bodyDescription);</span>
<a href="#l7.388"></a><span id="l7.388">   PR_FREEIF(m_bodyEncoding);</span>
<a href="#l7.389"></a><span id="l7.389">   PR_FREEIF(m_partData);</span>
<a href="#l7.390"></a><span id="l7.390">   PR_FREEIF(m_headerData);</span>
<a href="#l7.391"></a><span id="l7.391">   PR_FREEIF(m_boundaryData);</span>
<a href="#l7.392"></a><span id="l7.392"> }</span>
<a href="#l7.393"></a><span id="l7.393"> </span>
<a href="#l7.394"></a><span id="l7.394" class="difflineminus">-void nsIMAPBodypart::SetIsValid(bool valid)</span>
<a href="#l7.395"></a><span id="l7.395" class="difflineminus">-{</span>
<a href="#l7.396"></a><span id="l7.396" class="difflineplus">+void nsIMAPBodypart::SetIsValid(bool valid) {</span>
<a href="#l7.397"></a><span id="l7.397">   m_isValid = valid;</span>
<a href="#l7.398"></a><span id="l7.398" class="difflineminus">-  if (!m_isValid)</span>
<a href="#l7.399"></a><span id="l7.399" class="difflineminus">-  {</span>
<a href="#l7.400"></a><span id="l7.400" class="difflineminus">-    //MOZ_LOG(IMAP, out, (&quot;BODYSHELL: Part is invalid.  Part Number: %s Content-Type: %s&quot;, m_partNumberString, m_contentType));</span>
<a href="#l7.401"></a><span id="l7.401" class="difflineplus">+  if (!m_isValid) {</span>
<a href="#l7.402"></a><span id="l7.402" class="difflineplus">+    // MOZ_LOG(IMAP, out, (&quot;BODYSHELL: Part is invalid.  Part Number: %s</span>
<a href="#l7.403"></a><span id="l7.403" class="difflineplus">+    // Content-Type: %s&quot;, m_partNumberString, m_contentType));</span>
<a href="#l7.404"></a><span id="l7.404">   }</span>
<a href="#l7.405"></a><span id="l7.405"> }</span>
<a href="#l7.406"></a><span id="l7.406"> </span>
<a href="#l7.407"></a><span id="l7.407"> // Adopts storage for part data buffer.  If NULL, sets isValid to false.</span>
<a href="#l7.408"></a><span id="l7.408" class="difflineminus">-void nsIMAPBodypart::AdoptPartDataBuffer(char *buf)</span>
<a href="#l7.409"></a><span id="l7.409" class="difflineminus">-{</span>
<a href="#l7.410"></a><span id="l7.410" class="difflineplus">+void nsIMAPBodypart::AdoptPartDataBuffer(char *buf) {</span>
<a href="#l7.411"></a><span id="l7.411">   m_partData = buf;</span>
<a href="#l7.412"></a><span id="l7.412" class="difflineminus">-  if (!m_partData)</span>
<a href="#l7.413"></a><span id="l7.413" class="difflineminus">-  {</span>
<a href="#l7.414"></a><span id="l7.414" class="difflineplus">+  if (!m_partData) {</span>
<a href="#l7.415"></a><span id="l7.415">     SetIsValid(false);</span>
<a href="#l7.416"></a><span id="l7.416">   }</span>
<a href="#l7.417"></a><span id="l7.417"> }</span>
<a href="#l7.418"></a><span id="l7.418"> </span>
<a href="#l7.419"></a><span id="l7.419"> // Adopts storage for header data buffer.  If NULL, sets isValid to false.</span>
<a href="#l7.420"></a><span id="l7.420" class="difflineminus">-void nsIMAPBodypart::AdoptHeaderDataBuffer(char *buf)</span>
<a href="#l7.421"></a><span id="l7.421" class="difflineminus">-{</span>
<a href="#l7.422"></a><span id="l7.422" class="difflineplus">+void nsIMAPBodypart::AdoptHeaderDataBuffer(char *buf) {</span>
<a href="#l7.423"></a><span id="l7.423">   m_headerData = buf;</span>
<a href="#l7.424"></a><span id="l7.424" class="difflineminus">-  if (!m_headerData)</span>
<a href="#l7.425"></a><span id="l7.425" class="difflineminus">-  {</span>
<a href="#l7.426"></a><span id="l7.426" class="difflineplus">+  if (!m_headerData) {</span>
<a href="#l7.427"></a><span id="l7.427">     SetIsValid(false);</span>
<a href="#l7.428"></a><span id="l7.428">   }</span>
<a href="#l7.429"></a><span id="l7.429"> }</span>
<a href="#l7.430"></a><span id="l7.430"> </span>
<a href="#l7.431"></a><span id="l7.431"> // Finds the part with given part number</span>
<a href="#l7.432"></a><span id="l7.432"> // Returns a nsIMAPBodystructure of the matched part if it is this</span>
<a href="#l7.433"></a><span id="l7.433"> // or one of its children.  Returns NULL otherwise.</span>
<a href="#l7.434"></a><span id="l7.434" class="difflineminus">-nsIMAPBodypart *nsIMAPBodypart::FindPartWithNumber(const char *partNum)</span>
<a href="#l7.435"></a><span id="l7.435" class="difflineminus">-{</span>
<a href="#l7.436"></a><span id="l7.436" class="difflineplus">+nsIMAPBodypart *nsIMAPBodypart::FindPartWithNumber(const char *partNum) {</span>
<a href="#l7.437"></a><span id="l7.437">   // either brute force, or do it the smart way - look at the number.</span>
<a href="#l7.438"></a><span id="l7.438">   // (the parts should be ordered, and hopefully indexed by their number)</span>
<a href="#l7.439"></a><span id="l7.439"> </span>
<a href="#l7.440"></a><span id="l7.440">   if (m_partNumberString &amp;&amp; !PL_strcasecmp(partNum, m_partNumberString))</span>
<a href="#l7.441"></a><span id="l7.441">     return this;</span>
<a href="#l7.442"></a><span id="l7.442"> </span>
<a href="#l7.443"></a><span id="l7.443">   // if (!m_partNumberString &amp;&amp; !PL_strcasecmp(partNum, &quot;1&quot;))</span>
<a href="#l7.444"></a><span id="l7.444">   //   return this;</span>
<a href="#l7.445"></a><span id="l7.445" class="difflineat">@@ -370,924 +330,834 @@ nsIMAPBodypart *nsIMAPBodypart::FindPart</span>
<a href="#l7.446"></a><span id="l7.446">   return NULL;</span>
<a href="#l7.447"></a><span id="l7.447"> }</span>
<a href="#l7.448"></a><span id="l7.448"> </span>
<a href="#l7.449"></a><span id="l7.449"> /*</span>
<a href="#l7.450"></a><span id="l7.450"> void nsIMAPBodypart::PrefetchMIMEHeader()</span>
<a href="#l7.451"></a><span id="l7.451"> {</span>
<a href="#l7.452"></a><span id="l7.452"> if (!m_headerData &amp;&amp; !m_shell-&gt;DeathSignalReceived())</span>
<a href="#l7.453"></a><span id="l7.453"> {</span>
<a href="#l7.454"></a><span id="l7.454" class="difflineminus">-m_shell-&gt;GetConnection()-&gt;FetchMessage(m_shell-&gt;GetUID(), kMIMEHeader, true, 0, 0, m_partNumberString);</span>
<a href="#l7.455"></a><span id="l7.455" class="difflineplus">+m_shell-&gt;GetConnection()-&gt;FetchMessage(m_shell-&gt;GetUID(), kMIMEHeader, true, 0,</span>
<a href="#l7.456"></a><span id="l7.456" class="difflineplus">+0, m_partNumberString);</span>
<a href="#l7.457"></a><span id="l7.457"> // m_headerLength will be filled in when it is adopted from the parser</span>
<a href="#l7.458"></a><span id="l7.458"> }</span>
<a href="#l7.459"></a><span id="l7.459"> if (!m_headerData)</span>
<a href="#l7.460"></a><span id="l7.460"> {</span>
<a href="#l7.461"></a><span id="l7.461"> SetIsValid(false);</span>
<a href="#l7.462"></a><span id="l7.462"> }</span>
<a href="#l7.463"></a><span id="l7.463"> }</span>
<a href="#l7.464"></a><span id="l7.464"> */</span>
<a href="#l7.465"></a><span id="l7.465"> </span>
<a href="#l7.466"></a><span id="l7.466" class="difflineminus">-void nsIMAPBodypart::QueuePrefetchMIMEHeader(nsIMAPBodyShell *aShell)</span>
<a href="#l7.467"></a><span id="l7.467" class="difflineminus">-{</span>
<a href="#l7.468"></a><span id="l7.468" class="difflineplus">+void nsIMAPBodypart::QueuePrefetchMIMEHeader(nsIMAPBodyShell *aShell) {</span>
<a href="#l7.469"></a><span id="l7.469">   aShell-&gt;AddPrefetchToQueue(kMIMEHeader, m_partNumberString);</span>
<a href="#l7.470"></a><span id="l7.470"> }</span>
<a href="#l7.471"></a><span id="l7.471"> </span>
<a href="#l7.472"></a><span id="l7.472" class="difflineminus">-int32_t nsIMAPBodypart::GenerateMIMEHeader(nsIMAPBodyShell *aShell, bool stream, bool prefetch)</span>
<a href="#l7.473"></a><span id="l7.473" class="difflineminus">-{</span>
<a href="#l7.474"></a><span id="l7.474" class="difflineminus">-  if (prefetch &amp;&amp; !m_headerData)</span>
<a href="#l7.475"></a><span id="l7.475" class="difflineminus">-  {</span>
<a href="#l7.476"></a><span id="l7.476" class="difflineplus">+int32_t nsIMAPBodypart::GenerateMIMEHeader(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l7.477"></a><span id="l7.477" class="difflineplus">+                                           bool prefetch) {</span>
<a href="#l7.478"></a><span id="l7.478" class="difflineplus">+  if (prefetch &amp;&amp; !m_headerData) {</span>
<a href="#l7.479"></a><span id="l7.479">     QueuePrefetchMIMEHeader(aShell);</span>
<a href="#l7.480"></a><span id="l7.480">     return 0;</span>
<a href="#l7.481"></a><span id="l7.481">   }</span>
<a href="#l7.482"></a><span id="l7.482" class="difflineminus">-  if (m_headerData)</span>
<a href="#l7.483"></a><span id="l7.483" class="difflineminus">-  {</span>
<a href="#l7.484"></a><span id="l7.484" class="difflineplus">+  if (m_headerData) {</span>
<a href="#l7.485"></a><span id="l7.485">     int32_t mimeHeaderLength = 0;</span>
<a href="#l7.486"></a><span id="l7.486"> </span>
<a href="#l7.487"></a><span id="l7.487" class="difflineminus">-    if (!ShouldFetchInline(aShell))</span>
<a href="#l7.488"></a><span id="l7.488" class="difflineminus">-    {</span>
<a href="#l7.489"></a><span id="l7.489" class="difflineplus">+    if (!ShouldFetchInline(aShell)) {</span>
<a href="#l7.490"></a><span id="l7.490">       // if this part isn't inline, add the X-Mozilla-IMAP-Part header</span>
<a href="#l7.491"></a><span id="l7.491" class="difflineminus">-      char *xPartHeader = PR_smprintf(&quot;%s: %s&quot;, IMAP_EXTERNAL_CONTENT_HEADER, m_partNumberString);</span>
<a href="#l7.492"></a><span id="l7.492" class="difflineminus">-      if (xPartHeader)</span>
<a href="#l7.493"></a><span id="l7.493" class="difflineminus">-      {</span>
<a href="#l7.494"></a><span id="l7.494" class="difflineminus">-        if (stream)</span>
<a href="#l7.495"></a><span id="l7.495" class="difflineminus">-        {</span>
<a href="#l7.496"></a><span id="l7.496" class="difflineminus">-          aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-XHeader&quot;,m_partNumberString);</span>
<a href="#l7.497"></a><span id="l7.497" class="difflineminus">-          aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(xPartHeader, false);</span>
<a href="#l7.498"></a><span id="l7.498" class="difflineplus">+      char *xPartHeader = PR_smprintf(&quot;%s: %s&quot;, IMAP_EXTERNAL_CONTENT_HEADER,</span>
<a href="#l7.499"></a><span id="l7.499" class="difflineplus">+                                      m_partNumberString);</span>
<a href="#l7.500"></a><span id="l7.500" class="difflineplus">+      if (xPartHeader) {</span>
<a href="#l7.501"></a><span id="l7.501" class="difflineplus">+        if (stream) {</span>
<a href="#l7.502"></a><span id="l7.502" class="difflineplus">+          aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;, &quot;GENERATE-XHeader&quot;,</span>
<a href="#l7.503"></a><span id="l7.503" class="difflineplus">+                                       m_partNumberString);</span>
<a href="#l7.504"></a><span id="l7.504" class="difflineplus">+          aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(xPartHeader,</span>
<a href="#l7.505"></a><span id="l7.505" class="difflineplus">+                                                             false);</span>
<a href="#l7.506"></a><span id="l7.506">         }</span>
<a href="#l7.507"></a><span id="l7.507">         mimeHeaderLength += PL_strlen(xPartHeader);</span>
<a href="#l7.508"></a><span id="l7.508">         PR_Free(xPartHeader);</span>
<a href="#l7.509"></a><span id="l7.509">       }</span>
<a href="#l7.510"></a><span id="l7.510">     }</span>
<a href="#l7.511"></a><span id="l7.511"> </span>
<a href="#l7.512"></a><span id="l7.512">     mimeHeaderLength += PL_strlen(m_headerData);</span>
<a href="#l7.513"></a><span id="l7.513" class="difflineminus">-    if (stream)</span>
<a href="#l7.514"></a><span id="l7.514" class="difflineminus">-    {</span>
<a href="#l7.515"></a><span id="l7.515" class="difflineminus">-      aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-MIMEHeader&quot;,m_partNumberString);</span>
<a href="#l7.516"></a><span id="l7.516" class="difflineminus">-      aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(m_headerData, false);  // all one line?  Can we do that?</span>
<a href="#l7.517"></a><span id="l7.517" class="difflineplus">+    if (stream) {</span>
<a href="#l7.518"></a><span id="l7.518" class="difflineplus">+      aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;, &quot;GENERATE-MIMEHeader&quot;,</span>
<a href="#l7.519"></a><span id="l7.519" class="difflineplus">+                                   m_partNumberString);</span>
<a href="#l7.520"></a><span id="l7.520" class="difflineplus">+      aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(</span>
<a href="#l7.521"></a><span id="l7.521" class="difflineplus">+          m_headerData, false);  // all one line?  Can we do that?</span>
<a href="#l7.522"></a><span id="l7.522">     }</span>
<a href="#l7.523"></a><span id="l7.523"> </span>
<a href="#l7.524"></a><span id="l7.524">     return mimeHeaderLength;</span>
<a href="#l7.525"></a><span id="l7.525">   }</span>
<a href="#l7.526"></a><span id="l7.526"> </span>
<a href="#l7.527"></a><span id="l7.527">   SetIsValid(false);  // prefetch didn't adopt a MIME header</span>
<a href="#l7.528"></a><span id="l7.528">   return 0;</span>
<a href="#l7.529"></a><span id="l7.529"> }</span>
<a href="#l7.530"></a><span id="l7.530"> </span>
<a href="#l7.531"></a><span id="l7.531" class="difflineminus">-int32_t nsIMAPBodypart::GeneratePart(nsIMAPBodyShell *aShell, bool stream, bool prefetch)</span>
<a href="#l7.532"></a><span id="l7.532" class="difflineminus">-{</span>
<a href="#l7.533"></a><span id="l7.533" class="difflineminus">-  if (prefetch)</span>
<a href="#l7.534"></a><span id="l7.534" class="difflineminus">-    return 0;  // don't need to prefetch anything</span>
<a href="#l7.535"></a><span id="l7.535" class="difflineplus">+int32_t nsIMAPBodypart::GeneratePart(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l7.536"></a><span id="l7.536" class="difflineplus">+                                     bool prefetch) {</span>
<a href="#l7.537"></a><span id="l7.537" class="difflineplus">+  if (prefetch) return 0;  // don't need to prefetch anything</span>
<a href="#l7.538"></a><span id="l7.538"> </span>
<a href="#l7.539"></a><span id="l7.539">   if (m_partData)  // we have prefetched the part data</span>
<a href="#l7.540"></a><span id="l7.540">   {</span>
<a href="#l7.541"></a><span id="l7.541" class="difflineminus">-    if (stream)</span>
<a href="#l7.542"></a><span id="l7.542" class="difflineminus">-    {</span>
<a href="#l7.543"></a><span id="l7.543" class="difflineminus">-      aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-Part-Prefetched&quot;,m_partNumberString);</span>
<a href="#l7.544"></a><span id="l7.544" class="difflineplus">+    if (stream) {</span>
<a href="#l7.545"></a><span id="l7.545" class="difflineplus">+      aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;, &quot;GENERATE-Part-Prefetched&quot;,</span>
<a href="#l7.546"></a><span id="l7.546" class="difflineplus">+                                   m_partNumberString);</span>
<a href="#l7.547"></a><span id="l7.547">       aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(m_partData, false);</span>
<a href="#l7.548"></a><span id="l7.548">     }</span>
<a href="#l7.549"></a><span id="l7.549">     return PL_strlen(m_partData);</span>
<a href="#l7.550"></a><span id="l7.550">   }</span>
<a href="#l7.551"></a><span id="l7.551"> </span>
<a href="#l7.552"></a><span id="l7.552">   // we are fetching and streaming this part's body as we go</span>
<a href="#l7.553"></a><span id="l7.553" class="difflineminus">-  if (stream &amp;&amp; !aShell-&gt;DeathSignalReceived())</span>
<a href="#l7.554"></a><span id="l7.554" class="difflineminus">-  {</span>
<a href="#l7.555"></a><span id="l7.555" class="difflineplus">+  if (stream &amp;&amp; !aShell-&gt;DeathSignalReceived()) {</span>
<a href="#l7.556"></a><span id="l7.556">     char *generatingPart = aShell-&gt;GetGeneratingPart();</span>
<a href="#l7.557"></a><span id="l7.557" class="difflineminus">-    bool fetchingSpecificPart = (generatingPart &amp;&amp; !PL_strcmp(generatingPart, m_partNumberString));</span>
<a href="#l7.558"></a><span id="l7.558" class="difflineplus">+    bool fetchingSpecificPart =</span>
<a href="#l7.559"></a><span id="l7.559" class="difflineplus">+        (generatingPart &amp;&amp; !PL_strcmp(generatingPart, m_partNumberString));</span>
<a href="#l7.560"></a><span id="l7.560"> </span>
<a href="#l7.561"></a><span id="l7.561" class="difflineminus">-    aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-Part-Inline&quot;,m_partNumberString);</span>
<a href="#l7.562"></a><span id="l7.562" class="difflineplus">+    aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;, &quot;GENERATE-Part-Inline&quot;,</span>
<a href="#l7.563"></a><span id="l7.563" class="difflineplus">+                                 m_partNumberString);</span>
<a href="#l7.564"></a><span id="l7.564">     MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l7.565"></a><span id="l7.565" class="difflineminus">-      (&quot;GeneratePart(): Call FetchTryChunking() part length=%&quot; PRIi32 &quot;, part number=%s&quot;, m_partLength, m_partNumberString));</span>
<a href="#l7.566"></a><span id="l7.566" class="difflineminus">-    aShell-&gt;GetConnection()-&gt;FetchTryChunking(aShell-&gt;GetUID(), kMIMEPart, true, m_partNumberString, m_partLength, !fetchingSpecificPart);</span>
<a href="#l7.567"></a><span id="l7.567" class="difflineplus">+            (&quot;GeneratePart(): Call FetchTryChunking() part length=%&quot; PRIi32</span>
<a href="#l7.568"></a><span id="l7.568" class="difflineplus">+             &quot;, part number=%s&quot;,</span>
<a href="#l7.569"></a><span id="l7.569" class="difflineplus">+             m_partLength, m_partNumberString));</span>
<a href="#l7.570"></a><span id="l7.570" class="difflineplus">+    aShell-&gt;GetConnection()-&gt;FetchTryChunking(aShell-&gt;GetUID(), kMIMEPart, true,</span>
<a href="#l7.571"></a><span id="l7.571" class="difflineplus">+                                              m_partNumberString, m_partLength,</span>
<a href="#l7.572"></a><span id="l7.572" class="difflineplus">+                                              !fetchingSpecificPart);</span>
<a href="#l7.573"></a><span id="l7.573">   }</span>
<a href="#l7.574"></a><span id="l7.574" class="difflineminus">-  return m_partLength;  // the part length has been filled in from the BODYSTRUCTURE response</span>
<a href="#l7.575"></a><span id="l7.575" class="difflineplus">+  return m_partLength;  // the part length has been filled in from the</span>
<a href="#l7.576"></a><span id="l7.576" class="difflineplus">+                        // BODYSTRUCTURE response</span>
<a href="#l7.577"></a><span id="l7.577"> }</span>
<a href="#l7.578"></a><span id="l7.578"> </span>
<a href="#l7.579"></a><span id="l7.579" class="difflineminus">-int32_t nsIMAPBodypart::GenerateBoundary(nsIMAPBodyShell *aShell, bool stream, bool prefetch, bool lastBoundary)</span>
<a href="#l7.580"></a><span id="l7.580" class="difflineminus">-{</span>
<a href="#l7.581"></a><span id="l7.581" class="difflineminus">-  if (prefetch)</span>
<a href="#l7.582"></a><span id="l7.582" class="difflineminus">-    return 0;  // don't need to prefetch anything</span>
<a href="#l7.583"></a><span id="l7.583" class="difflineplus">+int32_t nsIMAPBodypart::GenerateBoundary(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l7.584"></a><span id="l7.584" class="difflineplus">+                                         bool prefetch, bool lastBoundary) {</span>
<a href="#l7.585"></a><span id="l7.585" class="difflineplus">+  if (prefetch) return 0;  // don't need to prefetch anything</span>
<a href="#l7.586"></a><span id="l7.586"> </span>
<a href="#l7.587"></a><span id="l7.587" class="difflineminus">-  if (m_boundaryData)</span>
<a href="#l7.588"></a><span id="l7.588" class="difflineminus">-  {</span>
<a href="#l7.589"></a><span id="l7.589" class="difflineminus">-    if (!lastBoundary)</span>
<a href="#l7.590"></a><span id="l7.590" class="difflineminus">-    {</span>
<a href="#l7.591"></a><span id="l7.591" class="difflineminus">-      if (stream)</span>
<a href="#l7.592"></a><span id="l7.592" class="difflineminus">-      {</span>
<a href="#l7.593"></a><span id="l7.593" class="difflineminus">-        aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-Boundary&quot;,m_partNumberString);</span>
<a href="#l7.594"></a><span id="l7.594" class="difflineminus">-        aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(m_boundaryData, false);</span>
<a href="#l7.595"></a><span id="l7.595" class="difflineplus">+  if (m_boundaryData) {</span>
<a href="#l7.596"></a><span id="l7.596" class="difflineplus">+    if (!lastBoundary) {</span>
<a href="#l7.597"></a><span id="l7.597" class="difflineplus">+      if (stream) {</span>
<a href="#l7.598"></a><span id="l7.598" class="difflineplus">+        aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;, &quot;GENERATE-Boundary&quot;,</span>
<a href="#l7.599"></a><span id="l7.599" class="difflineplus">+                                     m_partNumberString);</span>
<a href="#l7.600"></a><span id="l7.600" class="difflineplus">+        aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(m_boundaryData,</span>
<a href="#l7.601"></a><span id="l7.601" class="difflineplus">+                                                           false);</span>
<a href="#l7.602"></a><span id="l7.602">       }</span>
<a href="#l7.603"></a><span id="l7.603">       return PL_strlen(m_boundaryData);</span>
<a href="#l7.604"></a><span id="l7.604">     }</span>
<a href="#l7.605"></a><span id="l7.605"> </span>
<a href="#l7.606"></a><span id="l7.606">     // the last boundary</span>
<a href="#l7.607"></a><span id="l7.607">     char *lastBoundaryData = PR_smprintf(&quot;%s--&quot;, m_boundaryData);</span>
<a href="#l7.608"></a><span id="l7.608" class="difflineminus">-    if (lastBoundaryData)</span>
<a href="#l7.609"></a><span id="l7.609" class="difflineminus">-    {</span>
<a href="#l7.610"></a><span id="l7.610" class="difflineminus">-      if (stream)</span>
<a href="#l7.611"></a><span id="l7.611" class="difflineminus">-      {</span>
<a href="#l7.612"></a><span id="l7.612" class="difflineminus">-        aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-Boundary-Last&quot;,m_partNumberString);</span>
<a href="#l7.613"></a><span id="l7.613" class="difflineminus">-        aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(lastBoundaryData, false);</span>
<a href="#l7.614"></a><span id="l7.614" class="difflineplus">+    if (lastBoundaryData) {</span>
<a href="#l7.615"></a><span id="l7.615" class="difflineplus">+      if (stream) {</span>
<a href="#l7.616"></a><span id="l7.616" class="difflineplus">+        aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;, &quot;GENERATE-Boundary-Last&quot;,</span>
<a href="#l7.617"></a><span id="l7.617" class="difflineplus">+                                     m_partNumberString);</span>
<a href="#l7.618"></a><span id="l7.618" class="difflineplus">+        aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(lastBoundaryData,</span>
<a href="#l7.619"></a><span id="l7.619" class="difflineplus">+                                                           false);</span>
<a href="#l7.620"></a><span id="l7.620">       }</span>
<a href="#l7.621"></a><span id="l7.621">       int32_t rv = PL_strlen(lastBoundaryData);</span>
<a href="#l7.622"></a><span id="l7.622">       PR_Free(lastBoundaryData);</span>
<a href="#l7.623"></a><span id="l7.623">       return rv;</span>
<a href="#l7.624"></a><span id="l7.624">     }</span>
<a href="#l7.625"></a><span id="l7.625" class="difflineminus">-    //HandleMemoryFailure();</span>
<a href="#l7.626"></a><span id="l7.626" class="difflineplus">+    // HandleMemoryFailure();</span>
<a href="#l7.627"></a><span id="l7.627">     return 0;</span>
<a href="#l7.628"></a><span id="l7.628">   }</span>
<a href="#l7.629"></a><span id="l7.629">   return 0;</span>
<a href="#l7.630"></a><span id="l7.630"> }</span>
<a href="#l7.631"></a><span id="l7.631"> </span>
<a href="#l7.632"></a><span id="l7.632" class="difflineminus">-int32_t nsIMAPBodypart::GenerateEmptyFilling(nsIMAPBodyShell *aShell, bool stream, bool prefetch)</span>
<a href="#l7.633"></a><span id="l7.633" class="difflineminus">-{</span>
<a href="#l7.634"></a><span id="l7.634" class="difflineminus">-  if (prefetch)</span>
<a href="#l7.635"></a><span id="l7.635" class="difflineminus">-    return 0; // don't need to prefetch anything</span>
<a href="#l7.636"></a><span id="l7.636" class="difflineplus">+int32_t nsIMAPBodypart::GenerateEmptyFilling(nsIMAPBodyShell *aShell,</span>
<a href="#l7.637"></a><span id="l7.637" class="difflineplus">+                                             bool stream, bool prefetch) {</span>
<a href="#l7.638"></a><span id="l7.638" class="difflineplus">+  if (prefetch) return 0;  // don't need to prefetch anything</span>
<a href="#l7.639"></a><span id="l7.639"> </span>
<a href="#l7.640"></a><span id="l7.640" class="difflineminus">-  const nsString &amp;emptyString = aShell-&gt;GetConnection()-&gt;</span>
<a href="#l7.641"></a><span id="l7.641" class="difflineminus">-    GetEmptyMimePartString();</span>
<a href="#l7.642"></a><span id="l7.642" class="difflineminus">-  if (!emptyString.IsEmpty())</span>
<a href="#l7.643"></a><span id="l7.643" class="difflineminus">-  {</span>
<a href="#l7.644"></a><span id="l7.644" class="difflineminus">-    if (stream)</span>
<a href="#l7.645"></a><span id="l7.645" class="difflineminus">-    {</span>
<a href="#l7.646"></a><span id="l7.646" class="difflineplus">+  const nsString &amp;emptyString =</span>
<a href="#l7.647"></a><span id="l7.647" class="difflineplus">+      aShell-&gt;GetConnection()-&gt;GetEmptyMimePartString();</span>
<a href="#l7.648"></a><span id="l7.648" class="difflineplus">+  if (!emptyString.IsEmpty()) {</span>
<a href="#l7.649"></a><span id="l7.649" class="difflineplus">+    if (stream) {</span>
<a href="#l7.650"></a><span id="l7.650">       nsImapProtocol *conn = aShell-&gt;GetConnection();</span>
<a href="#l7.651"></a><span id="l7.651">       conn-&gt;Log(&quot;SHELL&quot;, &quot;GENERATE-Filling&quot;, m_partNumberString);</span>
<a href="#l7.652"></a><span id="l7.652">       conn-&gt;HandleMessageDownLoadLine(NS_ConvertUTF16toUTF8(emptyString).get(),</span>
<a href="#l7.653"></a><span id="l7.653">                                       false);</span>
<a href="#l7.654"></a><span id="l7.654">     }</span>
<a href="#l7.655"></a><span id="l7.655">     return emptyString.Length();</span>
<a href="#l7.656"></a><span id="l7.656">   }</span>
<a href="#l7.657"></a><span id="l7.657">   return 0;</span>
<a href="#l7.658"></a><span id="l7.658"> }</span>
<a href="#l7.659"></a><span id="l7.659"> </span>
<a href="#l7.660"></a><span id="l7.660"> // Returns true if the prefs say that this content type should</span>
<a href="#l7.661"></a><span id="l7.661"> // explicitly be kept in when filling in the shell</span>
<a href="#l7.662"></a><span id="l7.662" class="difflineminus">-bool nsIMAPBodypart::ShouldExplicitlyFetchInline()</span>
<a href="#l7.663"></a><span id="l7.663" class="difflineminus">-{</span>
<a href="#l7.664"></a><span id="l7.664" class="difflineminus">-  return false;</span>
<a href="#l7.665"></a><span id="l7.665" class="difflineminus">-}</span>
<a href="#l7.666"></a><span id="l7.666" class="difflineplus">+bool nsIMAPBodypart::ShouldExplicitlyFetchInline() { return false; }</span>
<a href="#l7.667"></a><span id="l7.667"> </span>
<a href="#l7.668"></a><span id="l7.668"> // Returns true if the prefs say that this content type should</span>
<a href="#l7.669"></a><span id="l7.669"> // explicitly be left out when filling in the shell</span>
<a href="#l7.670"></a><span id="l7.670" class="difflineminus">-bool nsIMAPBodypart::ShouldExplicitlyNotFetchInline()</span>
<a href="#l7.671"></a><span id="l7.671" class="difflineminus">-{</span>
<a href="#l7.672"></a><span id="l7.672" class="difflineminus">-  return false;</span>
<a href="#l7.673"></a><span id="l7.673" class="difflineminus">-}</span>
<a href="#l7.674"></a><span id="l7.674" class="difflineminus">-</span>
<a href="#l7.675"></a><span id="l7.675" class="difflineplus">+bool nsIMAPBodypart::ShouldExplicitlyNotFetchInline() { return false; }</span>
<a href="#l7.676"></a><span id="l7.676"> </span>
<a href="#l7.677"></a><span id="l7.677"> ///////////// nsIMAPBodypartLeaf /////////////////////////////</span>
<a href="#l7.678"></a><span id="l7.678"> </span>
<a href="#l7.679"></a><span id="l7.679"> nsIMAPBodypartLeaf::nsIMAPBodypartLeaf(char *partNum,</span>
<a href="#l7.680"></a><span id="l7.680">                                        nsIMAPBodypart *parentPart,</span>
<a href="#l7.681"></a><span id="l7.681">                                        char *bodyType, char *bodySubType,</span>
<a href="#l7.682"></a><span id="l7.682">                                        char *bodyID, char *bodyDescription,</span>
<a href="#l7.683"></a><span id="l7.683">                                        char *bodyEncoding, int32_t partLength,</span>
<a href="#l7.684"></a><span id="l7.684">                                        bool preferPlainText)</span>
<a href="#l7.685"></a><span id="l7.685" class="difflineminus">-  : nsIMAPBodypart(partNum, parentPart), mPreferPlainText(preferPlainText)</span>
<a href="#l7.686"></a><span id="l7.686" class="difflineminus">-{</span>
<a href="#l7.687"></a><span id="l7.687" class="difflineplus">+    : nsIMAPBodypart(partNum, parentPart), mPreferPlainText(preferPlainText) {</span>
<a href="#l7.688"></a><span id="l7.688">   m_bodyType = bodyType;</span>
<a href="#l7.689"></a><span id="l7.689">   m_bodySubType = bodySubType;</span>
<a href="#l7.690"></a><span id="l7.690">   m_bodyID = bodyID;</span>
<a href="#l7.691"></a><span id="l7.691">   m_bodyDescription = bodyDescription;</span>
<a href="#l7.692"></a><span id="l7.692">   m_bodyEncoding = bodyEncoding;</span>
<a href="#l7.693"></a><span id="l7.693">   m_partLength = partLength;</span>
<a href="#l7.694"></a><span id="l7.694" class="difflineminus">-  if (m_bodyType &amp;&amp; m_bodySubType)</span>
<a href="#l7.695"></a><span id="l7.695" class="difflineminus">-  {</span>
<a href="#l7.696"></a><span id="l7.696" class="difflineplus">+  if (m_bodyType &amp;&amp; m_bodySubType) {</span>
<a href="#l7.697"></a><span id="l7.697">     m_contentType = PR_smprintf(&quot;%s/%s&quot;, m_bodyType, m_bodySubType);</span>
<a href="#l7.698"></a><span id="l7.698">   }</span>
<a href="#l7.699"></a><span id="l7.699">   SetIsValid(true);</span>
<a href="#l7.700"></a><span id="l7.700"> }</span>
<a href="#l7.701"></a><span id="l7.701"> </span>
<a href="#l7.702"></a><span id="l7.702" class="difflineminus">-nsIMAPBodypartType nsIMAPBodypartLeaf::GetType()</span>
<a href="#l7.703"></a><span id="l7.703" class="difflineminus">-{</span>
<a href="#l7.704"></a><span id="l7.704" class="difflineminus">-  return IMAP_BODY_LEAF;</span>
<a href="#l7.705"></a><span id="l7.705" class="difflineminus">-}</span>
<a href="#l7.706"></a><span id="l7.706" class="difflineplus">+nsIMAPBodypartType nsIMAPBodypartLeaf::GetType() { return IMAP_BODY_LEAF; }</span>
<a href="#l7.707"></a><span id="l7.707"> </span>
<a href="#l7.708"></a><span id="l7.708" class="difflineminus">-int32_t nsIMAPBodypartLeaf::Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch)</span>
<a href="#l7.709"></a><span id="l7.709" class="difflineminus">-{</span>
<a href="#l7.710"></a><span id="l7.710" class="difflineplus">+int32_t nsIMAPBodypartLeaf::Generate(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l7.711"></a><span id="l7.711" class="difflineplus">+                                     bool prefetch) {</span>
<a href="#l7.712"></a><span id="l7.712">   int32_t len = 0;</span>
<a href="#l7.713"></a><span id="l7.713"> </span>
<a href="#l7.714"></a><span id="l7.714" class="difflineminus">-  if (GetIsValid())</span>
<a href="#l7.715"></a><span id="l7.715" class="difflineminus">-  {</span>
<a href="#l7.716"></a><span id="l7.716" class="difflineminus">-</span>
<a href="#l7.717"></a><span id="l7.717" class="difflineplus">+  if (GetIsValid()) {</span>
<a href="#l7.718"></a><span id="l7.718">     if (stream &amp;&amp; !prefetch)</span>
<a href="#l7.719"></a><span id="l7.719" class="difflineminus">-      aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-Leaf&quot;,m_partNumberString);</span>
<a href="#l7.720"></a><span id="l7.720" class="difflineplus">+      aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;, &quot;GENERATE-Leaf&quot;,</span>
<a href="#l7.721"></a><span id="l7.721" class="difflineplus">+                                   m_partNumberString);</span>
<a href="#l7.722"></a><span id="l7.722"> </span>
<a href="#l7.723"></a><span id="l7.723">     // Stream out the MIME part boundary</span>
<a href="#l7.724"></a><span id="l7.724" class="difflineminus">-    //GenerateBoundary();</span>
<a href="#l7.725"></a><span id="l7.725" class="difflineplus">+    // GenerateBoundary();</span>
<a href="#l7.726"></a><span id="l7.726">     NS_ASSERTION(m_parentPart, &quot;part has no parent&quot;);</span>
<a href="#l7.727"></a><span id="l7.727" class="difflineminus">-    //nsIMAPBodypartMessage *parentMessage = m_parentPart ? m_parentPart-&gt;GetnsIMAPBodypartMessage() : NULL;</span>
<a href="#l7.728"></a><span id="l7.728" class="difflineplus">+    // nsIMAPBodypartMessage *parentMessage = m_parentPart ?</span>
<a href="#l7.729"></a><span id="l7.729" class="difflineplus">+    // m_parentPart-&gt;GetnsIMAPBodypartMessage() : NULL;</span>
<a href="#l7.730"></a><span id="l7.730"> </span>
<a href="#l7.731"></a><span id="l7.731" class="difflineminus">-    // Stream out the MIME header of this part, if this isn't the only body part of a message</span>
<a href="#l7.732"></a><span id="l7.732" class="difflineminus">-    //if (parentMessage ? !parentMessage-&gt;GetIsTopLevelMessage() : true)</span>
<a href="#l7.733"></a><span id="l7.733" class="difflineminus">-    if ((m_parentPart-&gt;GetType() != IMAP_BODY_MESSAGE_RFC822)</span>
<a href="#l7.734"></a><span id="l7.734" class="difflineminus">-      &amp;&amp; !aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l7.735"></a><span id="l7.735" class="difflineplus">+    // Stream out the MIME header of this part, if this isn't the only body part</span>
<a href="#l7.736"></a><span id="l7.736" class="difflineplus">+    // of a message</span>
<a href="#l7.737"></a><span id="l7.737" class="difflineplus">+    // if (parentMessage ? !parentMessage-&gt;GetIsTopLevelMessage() : true)</span>
<a href="#l7.738"></a><span id="l7.738" class="difflineplus">+    if ((m_parentPart-&gt;GetType() != IMAP_BODY_MESSAGE_RFC822) &amp;&amp;</span>
<a href="#l7.739"></a><span id="l7.739" class="difflineplus">+        !aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l7.740"></a><span id="l7.740">       len += GenerateMIMEHeader(aShell, stream, prefetch);</span>
<a href="#l7.741"></a><span id="l7.741"> </span>
<a href="#l7.742"></a><span id="l7.742" class="difflineminus">-    if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l7.743"></a><span id="l7.743" class="difflineminus">-    {</span>
<a href="#l7.744"></a><span id="l7.744" class="difflineminus">-      if (ShouldFetchInline(aShell))</span>
<a href="#l7.745"></a><span id="l7.745" class="difflineminus">-      {</span>
<a href="#l7.746"></a><span id="l7.746" class="difflineplus">+    if (!aShell-&gt;GetPseudoInterrupted()) {</span>
<a href="#l7.747"></a><span id="l7.747" class="difflineplus">+      if (ShouldFetchInline(aShell)) {</span>
<a href="#l7.748"></a><span id="l7.748">         // Fetch and stream the content of this part</span>
<a href="#l7.749"></a><span id="l7.749">         len += GeneratePart(aShell, stream, prefetch);</span>
<a href="#l7.750"></a><span id="l7.750" class="difflineminus">-      }</span>
<a href="#l7.751"></a><span id="l7.751" class="difflineminus">-      else</span>
<a href="#l7.752"></a><span id="l7.752" class="difflineminus">-      {</span>
<a href="#l7.753"></a><span id="l7.753" class="difflineplus">+      } else {</span>
<a href="#l7.754"></a><span id="l7.754">         // fill in the filling within the empty part</span>
<a href="#l7.755"></a><span id="l7.755">         len += GenerateEmptyFilling(aShell, stream, prefetch);</span>
<a href="#l7.756"></a><span id="l7.756">       }</span>
<a href="#l7.757"></a><span id="l7.757">     }</span>
<a href="#l7.758"></a><span id="l7.758">   }</span>
<a href="#l7.759"></a><span id="l7.759">   m_contentLength = len;</span>
<a href="#l7.760"></a><span id="l7.760">   return m_contentLength;</span>
<a href="#l7.761"></a><span id="l7.761"> }</span>
<a href="#l7.762"></a><span id="l7.762"> </span>
<a href="#l7.763"></a><span id="l7.763"> // returns true if this part should be fetched inline for generation.</span>
<a href="#l7.764"></a><span id="l7.764" class="difflineminus">-bool nsIMAPBodypartLeaf::ShouldFetchInline(nsIMAPBodyShell *aShell)</span>
<a href="#l7.765"></a><span id="l7.765" class="difflineminus">-{</span>
<a href="#l7.766"></a><span id="l7.766" class="difflineplus">+bool nsIMAPBodypartLeaf::ShouldFetchInline(nsIMAPBodyShell *aShell) {</span>
<a href="#l7.767"></a><span id="l7.767">   char *generatingPart = aShell-&gt;GetGeneratingPart();</span>
<a href="#l7.768"></a><span id="l7.768" class="difflineminus">-  if (generatingPart)</span>
<a href="#l7.769"></a><span id="l7.769" class="difflineminus">-  {</span>
<a href="#l7.770"></a><span id="l7.770" class="difflineplus">+  if (generatingPart) {</span>
<a href="#l7.771"></a><span id="l7.771">     // If we are generating a specific part</span>
<a href="#l7.772"></a><span id="l7.772" class="difflineminus">-    if (!PL_strcmp(generatingPart, m_partNumberString))</span>
<a href="#l7.773"></a><span id="l7.773" class="difflineminus">-    {</span>
<a href="#l7.774"></a><span id="l7.774" class="difflineplus">+    if (!PL_strcmp(generatingPart, m_partNumberString)) {</span>
<a href="#l7.775"></a><span id="l7.775">       // This is the part we're generating</span>
<a href="#l7.776"></a><span id="l7.776">       return true;</span>
<a href="#l7.777"></a><span id="l7.777">     }</span>
<a href="#l7.778"></a><span id="l7.778"> </span>
<a href="#l7.779"></a><span id="l7.779">     // If this is the only body part of a message, and that</span>
<a href="#l7.780"></a><span id="l7.780">     // message is the part being generated, then this leaf should</span>
<a href="#l7.781"></a><span id="l7.781">     // be inline as well.</span>
<a href="#l7.782"></a><span id="l7.782">     if ((m_parentPart-&gt;GetType() == IMAP_BODY_MESSAGE_RFC822) &amp;&amp;</span>
<a href="#l7.783"></a><span id="l7.783">         (!PL_strcmp(m_parentPart-&gt;GetPartNumberString(), generatingPart)))</span>
<a href="#l7.784"></a><span id="l7.784">       return true;</span>
<a href="#l7.785"></a><span id="l7.785"> </span>
<a href="#l7.786"></a><span id="l7.786">     // The parent of this part is a multipart</span>
<a href="#l7.787"></a><span id="l7.787" class="difflineminus">-    if (m_parentPart-&gt;GetType() == IMAP_BODY_MULTIPART)</span>
<a href="#l7.788"></a><span id="l7.788" class="difflineminus">-    {</span>
<a href="#l7.789"></a><span id="l7.789" class="difflineplus">+    if (m_parentPart-&gt;GetType() == IMAP_BODY_MULTIPART) {</span>
<a href="#l7.790"></a><span id="l7.790">       // This is the first text part of a forwarded message</span>
<a href="#l7.791"></a><span id="l7.791">       // with a multipart body, and that message is being generated,</span>
<a href="#l7.792"></a><span id="l7.792">       // then generate this part.</span>
<a href="#l7.793"></a><span id="l7.793">       nsIMAPBodypart *grandParent = m_parentPart-&gt;GetParentPart();</span>
<a href="#l7.794"></a><span id="l7.794">       // grandParent must exist, since multiparts need parents</span>
<a href="#l7.795"></a><span id="l7.795">       NS_ASSERTION(grandParent, &quot;grandparent doesn't exist for multi-part alt&quot;);</span>
<a href="#l7.796"></a><span id="l7.796" class="difflineminus">-      if (grandParent &amp;&amp;</span>
<a href="#l7.797"></a><span id="l7.797" class="difflineminus">-          (grandParent-&gt;GetType() == IMAP_BODY_MESSAGE_RFC822) &amp;&amp;</span>
<a href="#l7.798"></a><span id="l7.798" class="difflineplus">+      if (grandParent &amp;&amp; (grandParent-&gt;GetType() == IMAP_BODY_MESSAGE_RFC822) &amp;&amp;</span>
<a href="#l7.799"></a><span id="l7.799">           (!PL_strcmp(grandParent-&gt;GetPartNumberString(), generatingPart)) &amp;&amp;</span>
<a href="#l7.800"></a><span id="l7.800" class="difflineminus">-          (m_partNumberString[PL_strlen(m_partNumberString)-1] == '1') &amp;&amp;</span>
<a href="#l7.801"></a><span id="l7.801" class="difflineplus">+          (m_partNumberString[PL_strlen(m_partNumberString) - 1] == '1') &amp;&amp;</span>
<a href="#l7.802"></a><span id="l7.802">           !PL_strcasecmp(m_bodyType, &quot;text&quot;))</span>
<a href="#l7.803"></a><span id="l7.803">         return true;  // we're downloading it inline</span>
<a href="#l7.804"></a><span id="l7.804"> </span>
<a href="#l7.805"></a><span id="l7.805">       // This is a child of a multipart/appledouble attachment,</span>
<a href="#l7.806"></a><span id="l7.806">       // and that multipart/appledouble attachment is being generated</span>
<a href="#l7.807"></a><span id="l7.807">       if (m_parentPart &amp;&amp;</span>
<a href="#l7.808"></a><span id="l7.808">           !PL_strcasecmp(m_parentPart-&gt;GetBodySubType(), &quot;appledouble&quot;) &amp;&amp;</span>
<a href="#l7.809"></a><span id="l7.809">           !PL_strcmp(m_parentPart-&gt;GetPartNumberString(), generatingPart))</span>
<a href="#l7.810"></a><span id="l7.810">         return true;  // we're downloading it inline</span>
<a href="#l7.811"></a><span id="l7.811" class="difflineminus">-      }</span>
<a href="#l7.812"></a><span id="l7.812" class="difflineplus">+    }</span>
<a href="#l7.813"></a><span id="l7.813"> </span>
<a href="#l7.814"></a><span id="l7.814">     // Leave out all other leaves if this isn't the one</span>
<a href="#l7.815"></a><span id="l7.815">     // we're generating.</span>
<a href="#l7.816"></a><span id="l7.816">     // Maybe change later to check parents, etc.</span>
<a href="#l7.817"></a><span id="l7.817">     return false;</span>
<a href="#l7.818"></a><span id="l7.818">   }</span>
<a href="#l7.819"></a><span id="l7.819"> </span>
<a href="#l7.820"></a><span id="l7.820">   // We are generating the whole message, possibly (hopefully)</span>
<a href="#l7.821"></a><span id="l7.821">   // leaving out non-inline parts</span>
<a href="#l7.822"></a><span id="l7.822" class="difflineminus">-  if (ShouldExplicitlyFetchInline())</span>
<a href="#l7.823"></a><span id="l7.823" class="difflineminus">-    return true;</span>
<a href="#l7.824"></a><span id="l7.824" class="difflineminus">-  if (ShouldExplicitlyNotFetchInline())</span>
<a href="#l7.825"></a><span id="l7.825" class="difflineminus">-    return false;</span>
<a href="#l7.826"></a><span id="l7.826" class="difflineplus">+  if (ShouldExplicitlyFetchInline()) return true;</span>
<a href="#l7.827"></a><span id="l7.827" class="difflineplus">+  if (ShouldExplicitlyNotFetchInline()) return false;</span>
<a href="#l7.828"></a><span id="l7.828"> </span>
<a href="#l7.829"></a><span id="l7.829">   // If the parent is a message (this is the only body part of that</span>
<a href="#l7.830"></a><span id="l7.830">   // message), and that message should be inline, then its body</span>
<a href="#l7.831"></a><span id="l7.831">   // should inherit the inline characteristics of that message</span>
<a href="#l7.832"></a><span id="l7.832">   if (m_parentPart-&gt;GetType() == IMAP_BODY_MESSAGE_RFC822)</span>
<a href="#l7.833"></a><span id="l7.833">     return m_parentPart-&gt;ShouldFetchInline(aShell);</span>
<a href="#l7.834"></a><span id="l7.834"> </span>
<a href="#l7.835"></a><span id="l7.835">   // View Attachments As Links is on.</span>
<a href="#l7.836"></a><span id="l7.836" class="difflineminus">-  if (!(aShell-&gt;GetContentModified() == IMAP_CONTENT_MODIFIED_VIEW_INLINE))</span>
<a href="#l7.837"></a><span id="l7.837" class="difflineminus">-  {</span>
<a href="#l7.838"></a><span id="l7.838" class="difflineplus">+  if (!(aShell-&gt;GetContentModified() == IMAP_CONTENT_MODIFIED_VIEW_INLINE)) {</span>
<a href="#l7.839"></a><span id="l7.839">     // The last text part is still displayed inline,</span>
<a href="#l7.840"></a><span id="l7.840">     // even if View Attachments As Links is on.</span>
<a href="#l7.841"></a><span id="l7.841">     nsIMAPBodypart *grandParentPart = m_parentPart-&gt;GetParentPart();</span>
<a href="#l7.842"></a><span id="l7.842">     if ((mPreferPlainText ||</span>
<a href="#l7.843"></a><span id="l7.843">          !PL_strcasecmp(m_parentPart-&gt;GetBodySubType(), &quot;mixed&quot;)) &amp;&amp;</span>
<a href="#l7.844"></a><span id="l7.844">         !PL_strcmp(m_partNumberString, &quot;1&quot;) &amp;&amp;</span>
<a href="#l7.845"></a><span id="l7.845">         !PL_strcasecmp(m_bodyType, &quot;text&quot;))</span>
<a href="#l7.846"></a><span id="l7.846" class="difflineminus">-      return true;         // we're downloading it inline</span>
<a href="#l7.847"></a><span id="l7.847" class="difflineplus">+      return true;  // we're downloading it inline</span>
<a href="#l7.848"></a><span id="l7.848"> </span>
<a href="#l7.849"></a><span id="l7.849">     if ((!PL_strcasecmp(m_parentPart-&gt;GetBodySubType(), &quot;alternative&quot;) ||</span>
<a href="#l7.850"></a><span id="l7.850">          (grandParentPart &amp;&amp;</span>
<a href="#l7.851"></a><span id="l7.851">           !PL_strcasecmp(grandParentPart-&gt;GetBodySubType(), &quot;alternative&quot;))) &amp;&amp;</span>
<a href="#l7.852"></a><span id="l7.852">         !PL_strcasecmp(m_bodyType, &quot;text&quot;) &amp;&amp;</span>
<a href="#l7.853"></a><span id="l7.853">         ((!PL_strcasecmp(m_bodySubType, &quot;plain&quot;) &amp;&amp; mPreferPlainText) ||</span>
<a href="#l7.854"></a><span id="l7.854">          (!PL_strcasecmp(m_bodySubType, &quot;html&quot;) &amp;&amp; !mPreferPlainText)))</span>
<a href="#l7.855"></a><span id="l7.855">       return true;</span>
<a href="#l7.856"></a><span id="l7.856"> </span>
<a href="#l7.857"></a><span id="l7.857">     // This is the first text part of a top-level multipart.</span>
<a href="#l7.858"></a><span id="l7.858">     // For instance, a message with multipart body, where the first</span>
<a href="#l7.859"></a><span id="l7.859">     // part is multipart, and this is the first leaf of that first part.</span>
<a href="#l7.860"></a><span id="l7.860">     if (m_parentPart-&gt;GetType() == IMAP_BODY_MULTIPART &amp;&amp;</span>
<a href="#l7.861"></a><span id="l7.861">         (PL_strlen(m_partNumberString) &gt;= 2) &amp;&amp;</span>
<a href="#l7.862"></a><span id="l7.862" class="difflineminus">-        !PL_strcmp(m_partNumberString + PL_strlen(m_partNumberString) - 2, &quot;.1&quot;) &amp;&amp; // this is the first text type on this level</span>
<a href="#l7.863"></a><span id="l7.863" class="difflineminus">-        (!PL_strcmp(m_parentPart-&gt;GetPartNumberString(), &quot;1&quot;) || !PL_strcmp(m_parentPart-&gt;GetPartNumberString(), &quot;2&quot;)) &amp;&amp;</span>
<a href="#l7.864"></a><span id="l7.864" class="difflineplus">+        !PL_strcmp(m_partNumberString + PL_strlen(m_partNumberString) - 2,</span>
<a href="#l7.865"></a><span id="l7.865" class="difflineplus">+                   &quot;.1&quot;) &amp;&amp;  // this is the first text type on this level</span>
<a href="#l7.866"></a><span id="l7.866" class="difflineplus">+        (!PL_strcmp(m_parentPart-&gt;GetPartNumberString(), &quot;1&quot;) ||</span>
<a href="#l7.867"></a><span id="l7.867" class="difflineplus">+         !PL_strcmp(m_parentPart-&gt;GetPartNumberString(), &quot;2&quot;)) &amp;&amp;</span>
<a href="#l7.868"></a><span id="l7.868">         !PL_strcasecmp(m_bodyType, &quot;text&quot;))</span>
<a href="#l7.869"></a><span id="l7.869">       return true;</span>
<a href="#l7.870"></a><span id="l7.870" class="difflineminus">-    // This is the first text part of a top-level multipart of the toplevelmessage</span>
<a href="#l7.871"></a><span id="l7.871" class="difflineminus">-    // This 'assumes' the text body is first leaf. This is not required for valid email.</span>
<a href="#l7.872"></a><span id="l7.872" class="difflineminus">-    // The only other way is to get content-disposition = attachment and exclude those text parts.</span>
<a href="#l7.873"></a><span id="l7.873" class="difflineplus">+    // This is the first text part of a top-level multipart of the</span>
<a href="#l7.874"></a><span id="l7.874" class="difflineplus">+    // toplevelmessage This 'assumes' the text body is first leaf. This is not</span>
<a href="#l7.875"></a><span id="l7.875" class="difflineplus">+    // required for valid email. The only other way is to get</span>
<a href="#l7.876"></a><span id="l7.876" class="difflineplus">+    // content-disposition = attachment and exclude those text parts.</span>
<a href="#l7.877"></a><span id="l7.877">     if (m_parentPart-&gt;GetType() == IMAP_BODY_MULTIPART &amp;&amp;</span>
<a href="#l7.878"></a><span id="l7.878">         !PL_strcasecmp(m_bodyType, &quot;text&quot;) &amp;&amp;</span>
<a href="#l7.879"></a><span id="l7.879">         !PL_strcmp(m_parentPart-&gt;GetPartNumberString(), &quot;0&quot;) &amp;&amp;</span>
<a href="#l7.880"></a><span id="l7.880">         !PL_strcmp(m_partNumberString, &quot;1&quot;))</span>
<a href="#l7.881"></a><span id="l7.881">       return true;</span>
<a href="#l7.882"></a><span id="l7.882"> </span>
<a href="#l7.883"></a><span id="l7.883">     // we may have future problems needing tests here</span>
<a href="#l7.884"></a><span id="l7.884"> </span>
<a href="#l7.885"></a><span id="l7.885">     return false;  // we can leave it on the server</span>
<a href="#l7.886"></a><span id="l7.886">   }</span>
<a href="#l7.887"></a><span id="l7.887"> #ifdef XP_MACOSX</span>
<a href="#l7.888"></a><span id="l7.888">   // If it is either applesingle, or a resource fork for appledouble</span>
<a href="#l7.889"></a><span id="l7.889" class="difflineminus">-  if (!PL_strcasecmp(m_contentType, &quot;application/applefile&quot;))</span>
<a href="#l7.890"></a><span id="l7.890" class="difflineminus">-  {</span>
<a href="#l7.891"></a><span id="l7.891" class="difflineplus">+  if (!PL_strcasecmp(m_contentType, &quot;application/applefile&quot;)) {</span>
<a href="#l7.892"></a><span id="l7.892">     // if it is appledouble</span>
<a href="#l7.893"></a><span id="l7.893">     if (m_parentPart-&gt;GetType() == IMAP_BODY_MULTIPART &amp;&amp;</span>
<a href="#l7.894"></a><span id="l7.894" class="difflineminus">-        !PL_strcasecmp(m_parentPart-&gt;GetBodySubType(), &quot;appledouble&quot;))</span>
<a href="#l7.895"></a><span id="l7.895" class="difflineminus">-    {</span>
<a href="#l7.896"></a><span id="l7.896" class="difflineplus">+        !PL_strcasecmp(m_parentPart-&gt;GetBodySubType(), &quot;appledouble&quot;)) {</span>
<a href="#l7.897"></a><span id="l7.897">       // This is the resource fork of a multipart/appledouble.</span>
<a href="#l7.898"></a><span id="l7.898">       // We inherit the inline attributes of the parent,</span>
<a href="#l7.899"></a><span id="l7.899">       // which was derived from its OTHER child.  (The data fork.)</span>
<a href="#l7.900"></a><span id="l7.900">       return m_parentPart-&gt;ShouldFetchInline(aShell);</span>
<a href="#l7.901"></a><span id="l7.901">     }</span>
<a href="#l7.902"></a><span id="l7.902">     // it is applesingle</span>
<a href="#l7.903"></a><span id="l7.903">     return false;  // we can leave it on the server</span>
<a href="#l7.904"></a><span id="l7.904">   }</span>
<a href="#l7.905"></a><span id="l7.905" class="difflineminus">-#endif // XP_MACOSX</span>
<a href="#l7.906"></a><span id="l7.906" class="difflineplus">+#endif  // XP_MACOSX</span>
<a href="#l7.907"></a><span id="l7.907"> </span>
<a href="#l7.908"></a><span id="l7.908">   // Fetch type APPLICATION now if the subtype is a signature or if it's an</span>
<a href="#l7.909"></a><span id="l7.909">   // octet-stream. Otherwise, fetch on demand.</span>
<a href="#l7.910"></a><span id="l7.910">   if (!PL_strcasecmp(m_bodyType, &quot;APPLICATION&quot;) &amp;&amp;</span>
<a href="#l7.911"></a><span id="l7.911">       PL_strncasecmp(m_bodySubType, &quot;x-pkcs7&quot;, 7) &amp;&amp;</span>
<a href="#l7.912"></a><span id="l7.912">       PL_strcasecmp(m_bodySubType, &quot;octet-stream&quot;))</span>
<a href="#l7.913"></a><span id="l7.913">     return false;  // we can leave it on the server</span>
<a href="#l7.914"></a><span id="l7.914" class="difflineminus">-  if (!PL_strcasecmp(m_bodyType, &quot;AUDIO&quot;))</span>
<a href="#l7.915"></a><span id="l7.915" class="difflineminus">-    return false;</span>
<a href="#l7.916"></a><span id="l7.916" class="difflineplus">+  if (!PL_strcasecmp(m_bodyType, &quot;AUDIO&quot;)) return false;</span>
<a href="#l7.917"></a><span id="l7.917">   // Here's where we can add some more intelligence -- let's leave out</span>
<a href="#l7.918"></a><span id="l7.918">   // any other parts that we know we can't display inline.</span>
<a href="#l7.919"></a><span id="l7.919">   return true;  // we're downloading it inline</span>
<a href="#l7.920"></a><span id="l7.920"> }</span>
<a href="#l7.921"></a><span id="l7.921"> </span>
<a href="#l7.922"></a><span id="l7.922" class="difflineminus">-bool nsIMAPBodypartMultipart::IsLastTextPart(const char *partNumberString)</span>
<a href="#l7.923"></a><span id="l7.923" class="difflineminus">-{</span>
<a href="#l7.924"></a><span id="l7.924" class="difflineminus">- // iterate backwards over the parent's part list and if the part is</span>
<a href="#l7.925"></a><span id="l7.925" class="difflineplus">+bool nsIMAPBodypartMultipart::IsLastTextPart(const char *partNumberString) {</span>
<a href="#l7.926"></a><span id="l7.926" class="difflineplus">+  // iterate backwards over the parent's part list and if the part is</span>
<a href="#l7.927"></a><span id="l7.927">   // text, compare it to the part number string</span>
<a href="#l7.928"></a><span id="l7.928" class="difflineminus">-  for (int i = m_partList-&gt;Length() - 1; i &gt;= 0; i--)</span>
<a href="#l7.929"></a><span id="l7.929" class="difflineminus">-  {</span>
<a href="#l7.930"></a><span id="l7.930" class="difflineminus">-      nsIMAPBodypart *part = m_partList-&gt;ElementAt(i);</span>
<a href="#l7.931"></a><span id="l7.931" class="difflineminus">-      if (!PL_strcasecmp(part-&gt;GetBodyType(), &quot;text&quot;))</span>
<a href="#l7.932"></a><span id="l7.932" class="difflineminus">-        return !PL_strcasecmp(part-&gt;GetPartNumberString(), partNumberString);</span>
<a href="#l7.933"></a><span id="l7.933" class="difflineplus">+  for (int i = m_partList-&gt;Length() - 1; i &gt;= 0; i--) {</span>
<a href="#l7.934"></a><span id="l7.934" class="difflineplus">+    nsIMAPBodypart *part = m_partList-&gt;ElementAt(i);</span>
<a href="#l7.935"></a><span id="l7.935" class="difflineplus">+    if (!PL_strcasecmp(part-&gt;GetBodyType(), &quot;text&quot;))</span>
<a href="#l7.936"></a><span id="l7.936" class="difflineplus">+      return !PL_strcasecmp(part-&gt;GetPartNumberString(), partNumberString);</span>
<a href="#l7.937"></a><span id="l7.937">   }</span>
<a href="#l7.938"></a><span id="l7.938">   return false;</span>
<a href="#l7.939"></a><span id="l7.939"> }</span>
<a href="#l7.940"></a><span id="l7.940"> </span>
<a href="#l7.941"></a><span id="l7.941" class="difflineminus">-bool nsIMAPBodypartLeaf::PreflightCheckAllInline(nsIMAPBodyShell *aShell)</span>
<a href="#l7.942"></a><span id="l7.942" class="difflineminus">-{</span>
<a href="#l7.943"></a><span id="l7.943" class="difflineplus">+bool nsIMAPBodypartLeaf::PreflightCheckAllInline(nsIMAPBodyShell *aShell) {</span>
<a href="#l7.944"></a><span id="l7.944">   // only need to check this part, since it has no children.</span>
<a href="#l7.945"></a><span id="l7.945">   return ShouldFetchInline(aShell);</span>
<a href="#l7.946"></a><span id="l7.946"> }</span>
<a href="#l7.947"></a><span id="l7.947"> </span>
<a href="#l7.948"></a><span id="l7.948" class="difflineminus">-</span>
<a href="#l7.949"></a><span id="l7.949"> ///////////// nsIMAPBodypartMessage ////////////////////////</span>
<a href="#l7.950"></a><span id="l7.950"> </span>
<a href="#l7.951"></a><span id="l7.951" class="difflineminus">-nsIMAPBodypartMessage::nsIMAPBodypartMessage(char *partNum,</span>
<a href="#l7.952"></a><span id="l7.952" class="difflineminus">-                                             nsIMAPBodypart *parentPart,</span>
<a href="#l7.953"></a><span id="l7.953" class="difflineminus">-                                             bool topLevelMessage,</span>
<a href="#l7.954"></a><span id="l7.954" class="difflineminus">-                                             char *bodyType, char *bodySubType,</span>
<a href="#l7.955"></a><span id="l7.955" class="difflineminus">-                                             char *bodyID,</span>
<a href="#l7.956"></a><span id="l7.956" class="difflineminus">-                                             char *bodyDescription,</span>
<a href="#l7.957"></a><span id="l7.957" class="difflineminus">-                                             char *bodyEncoding,</span>
<a href="#l7.958"></a><span id="l7.958" class="difflineminus">-                                             int32_t partLength,</span>
<a href="#l7.959"></a><span id="l7.959" class="difflineminus">-                                             bool preferPlainText)</span>
<a href="#l7.960"></a><span id="l7.960" class="difflineminus">- : nsIMAPBodypartLeaf(partNum, parentPart, bodyType, bodySubType, bodyID,</span>
<a href="#l7.961"></a><span id="l7.961" class="difflineminus">-                      bodyDescription, bodyEncoding, partLength,</span>
<a href="#l7.962"></a><span id="l7.962" class="difflineminus">-                      preferPlainText)</span>
<a href="#l7.963"></a><span id="l7.963" class="difflineminus">-{</span>
<a href="#l7.964"></a><span id="l7.964" class="difflineplus">+nsIMAPBodypartMessage::nsIMAPBodypartMessage(</span>
<a href="#l7.965"></a><span id="l7.965" class="difflineplus">+    char *partNum, nsIMAPBodypart *parentPart, bool topLevelMessage,</span>
<a href="#l7.966"></a><span id="l7.966" class="difflineplus">+    char *bodyType, char *bodySubType, char *bodyID, char *bodyDescription,</span>
<a href="#l7.967"></a><span id="l7.967" class="difflineplus">+    char *bodyEncoding, int32_t partLength, bool preferPlainText)</span>
<a href="#l7.968"></a><span id="l7.968" class="difflineplus">+    : nsIMAPBodypartLeaf(partNum, parentPart, bodyType, bodySubType, bodyID,</span>
<a href="#l7.969"></a><span id="l7.969" class="difflineplus">+                         bodyDescription, bodyEncoding, partLength,</span>
<a href="#l7.970"></a><span id="l7.970" class="difflineplus">+                         preferPlainText) {</span>
<a href="#l7.971"></a><span id="l7.971">   m_topLevelMessage = topLevelMessage;</span>
<a href="#l7.972"></a><span id="l7.972" class="difflineminus">-  if (m_topLevelMessage)</span>
<a href="#l7.973"></a><span id="l7.973" class="difflineminus">-  {</span>
<a href="#l7.974"></a><span id="l7.974" class="difflineplus">+  if (m_topLevelMessage) {</span>
<a href="#l7.975"></a><span id="l7.975">     m_partNumberString = PR_smprintf(&quot;0&quot;);</span>
<a href="#l7.976"></a><span id="l7.976" class="difflineminus">-    if (!m_partNumberString)</span>
<a href="#l7.977"></a><span id="l7.977" class="difflineminus">-    {</span>
<a href="#l7.978"></a><span id="l7.978" class="difflineplus">+    if (!m_partNumberString) {</span>
<a href="#l7.979"></a><span id="l7.979">       SetIsValid(false);</span>
<a href="#l7.980"></a><span id="l7.980">       return;</span>
<a href="#l7.981"></a><span id="l7.981">     }</span>
<a href="#l7.982"></a><span id="l7.982">   }</span>
<a href="#l7.983"></a><span id="l7.983">   m_body = NULL;</span>
<a href="#l7.984"></a><span id="l7.984" class="difflineminus">-  m_headers = new nsIMAPMessageHeaders(m_partNumberString, this);  // We always have a Headers object</span>
<a href="#l7.985"></a><span id="l7.985" class="difflineminus">-  if (!m_headers || !m_headers-&gt;GetIsValid())</span>
<a href="#l7.986"></a><span id="l7.986" class="difflineminus">-  {</span>
<a href="#l7.987"></a><span id="l7.987" class="difflineplus">+  m_headers = new nsIMAPMessageHeaders(</span>
<a href="#l7.988"></a><span id="l7.988" class="difflineplus">+      m_partNumberString, this);  // We always have a Headers object</span>
<a href="#l7.989"></a><span id="l7.989" class="difflineplus">+  if (!m_headers || !m_headers-&gt;GetIsValid()) {</span>
<a href="#l7.990"></a><span id="l7.990">     SetIsValid(false);</span>
<a href="#l7.991"></a><span id="l7.991">     return;</span>
<a href="#l7.992"></a><span id="l7.992">   }</span>
<a href="#l7.993"></a><span id="l7.993">   SetIsValid(true);</span>
<a href="#l7.994"></a><span id="l7.994"> }</span>
<a href="#l7.995"></a><span id="l7.995"> </span>
<a href="#l7.996"></a><span id="l7.996" class="difflineminus">-void nsIMAPBodypartMessage::SetBody(nsIMAPBodypart *body)</span>
<a href="#l7.997"></a><span id="l7.997" class="difflineminus">-{</span>
<a href="#l7.998"></a><span id="l7.998" class="difflineminus">-  if (m_body)</span>
<a href="#l7.999"></a><span id="l7.999" class="difflineminus">-    delete m_body;</span>
<a href="#l7.1000"></a><span id="l7.1000" class="difflineplus">+void nsIMAPBodypartMessage::SetBody(nsIMAPBodypart *body) {</span>
<a href="#l7.1001"></a><span id="l7.1001" class="difflineplus">+  if (m_body) delete m_body;</span>
<a href="#l7.1002"></a><span id="l7.1002">   m_body = body;</span>
<a href="#l7.1003"></a><span id="l7.1003"> }</span>
<a href="#l7.1004"></a><span id="l7.1004"> </span>
<a href="#l7.1005"></a><span id="l7.1005" class="difflineminus">-</span>
<a href="#l7.1006"></a><span id="l7.1006" class="difflineminus">-nsIMAPBodypartType nsIMAPBodypartMessage::GetType()</span>
<a href="#l7.1007"></a><span id="l7.1007" class="difflineminus">-{</span>
<a href="#l7.1008"></a><span id="l7.1008" class="difflineplus">+nsIMAPBodypartType nsIMAPBodypartMessage::GetType() {</span>
<a href="#l7.1009"></a><span id="l7.1009">   return IMAP_BODY_MESSAGE_RFC822;</span>
<a href="#l7.1010"></a><span id="l7.1010"> }</span>
<a href="#l7.1011"></a><span id="l7.1011"> </span>
<a href="#l7.1012"></a><span id="l7.1012" class="difflineminus">-nsIMAPBodypartMessage::~nsIMAPBodypartMessage()</span>
<a href="#l7.1013"></a><span id="l7.1013" class="difflineminus">-{</span>
<a href="#l7.1014"></a><span id="l7.1014" class="difflineplus">+nsIMAPBodypartMessage::~nsIMAPBodypartMessage() {</span>
<a href="#l7.1015"></a><span id="l7.1015">   delete m_headers;</span>
<a href="#l7.1016"></a><span id="l7.1016">   delete m_body;</span>
<a href="#l7.1017"></a><span id="l7.1017"> }</span>
<a href="#l7.1018"></a><span id="l7.1018"> </span>
<a href="#l7.1019"></a><span id="l7.1019" class="difflineminus">-int32_t nsIMAPBodypartMessage::Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch)</span>
<a href="#l7.1020"></a><span id="l7.1020" class="difflineminus">-{</span>
<a href="#l7.1021"></a><span id="l7.1021" class="difflineminus">-  if (!GetIsValid())</span>
<a href="#l7.1022"></a><span id="l7.1022" class="difflineminus">-    return 0;</span>
<a href="#l7.1023"></a><span id="l7.1023" class="difflineplus">+int32_t nsIMAPBodypartMessage::Generate(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l7.1024"></a><span id="l7.1024" class="difflineplus">+                                        bool prefetch) {</span>
<a href="#l7.1025"></a><span id="l7.1025" class="difflineplus">+  if (!GetIsValid()) return 0;</span>
<a href="#l7.1026"></a><span id="l7.1026"> </span>
<a href="#l7.1027"></a><span id="l7.1027">   m_contentLength = 0;</span>
<a href="#l7.1028"></a><span id="l7.1028"> </span>
<a href="#l7.1029"></a><span id="l7.1029">   if (stream &amp;&amp; !prefetch)</span>
<a href="#l7.1030"></a><span id="l7.1030" class="difflineminus">-    aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-MessageRFC822&quot;,m_partNumberString);</span>
<a href="#l7.1031"></a><span id="l7.1031" class="difflineplus">+    aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;, &quot;GENERATE-MessageRFC822&quot;,</span>
<a href="#l7.1032"></a><span id="l7.1032" class="difflineplus">+                                 m_partNumberString);</span>
<a href="#l7.1033"></a><span id="l7.1033"> </span>
<a href="#l7.1034"></a><span id="l7.1034" class="difflineminus">-  if (!m_topLevelMessage &amp;&amp; !aShell-&gt;GetPseudoInterrupted())  // not the top-level message - we need the MIME header as well as the message header</span>
<a href="#l7.1035"></a><span id="l7.1035" class="difflineplus">+  if (!m_topLevelMessage &amp;&amp;</span>
<a href="#l7.1036"></a><span id="l7.1036" class="difflineplus">+      !aShell-&gt;GetPseudoInterrupted())  // not the top-level message - we need</span>
<a href="#l7.1037"></a><span id="l7.1037" class="difflineplus">+                                        // the MIME header as well as the</span>
<a href="#l7.1038"></a><span id="l7.1038" class="difflineplus">+                                        // message header</span>
<a href="#l7.1039"></a><span id="l7.1039">   {</span>
<a href="#l7.1040"></a><span id="l7.1040" class="difflineminus">-    // but we don't need the MIME headers of a message/rfc822 part if this content</span>
<a href="#l7.1041"></a><span id="l7.1041" class="difflineminus">-    // type is in (part of) the main msg header. In other words, we still need</span>
<a href="#l7.1042"></a><span id="l7.1042" class="difflineminus">-    // these MIME headers if this message/rfc822 body part is enclosed in the msg</span>
<a href="#l7.1043"></a><span id="l7.1043" class="difflineminus">-    // body (most likely as a body part of a multipart/mixed msg).</span>
<a href="#l7.1044"></a><span id="l7.1044" class="difflineplus">+    // but we don't need the MIME headers of a message/rfc822 part if this</span>
<a href="#l7.1045"></a><span id="l7.1045" class="difflineplus">+    // content type is in (part of) the main msg header. In other words, we</span>
<a href="#l7.1046"></a><span id="l7.1046" class="difflineplus">+    // still need these MIME headers if this message/rfc822 body part is</span>
<a href="#l7.1047"></a><span id="l7.1047" class="difflineplus">+    // enclosed in the msg body (most likely as a body part of a multipart/mixed</span>
<a href="#l7.1048"></a><span id="l7.1048" class="difflineplus">+    // msg).</span>
<a href="#l7.1049"></a><span id="l7.1049">     //       Don't fetch (bug 128888)              Do fetch (bug 168097)</span>
<a href="#l7.1050"></a><span id="l7.1050">     //  ----------------------------------  -----------------------------------</span>
<a href="#l7.1051"></a><span id="l7.1051">     //  message/rfc822  (parent part)       message/rfc822</span>
<a href="#l7.1052"></a><span id="l7.1052">     //   message/rfc822 &lt;&lt;&lt;---               multipart/mixed  (parent part)</span>
<a href="#l7.1053"></a><span id="l7.1053">     //    multipart/mixed                     message/rfc822  &lt;&lt;&lt;---</span>
<a href="#l7.1054"></a><span id="l7.1054">     //     text/html   (body text)             multipart/mixed</span>
<a href="#l7.1055"></a><span id="l7.1055">     //     text/plain  (attachment)             text/html   (body text)</span>
<a href="#l7.1056"></a><span id="l7.1056">     //     application/msword (attachment)      text/plain  (attachment)</span>
<a href="#l7.1057"></a><span id="l7.1057">     //                                          application/msword (attachment)</span>
<a href="#l7.1058"></a><span id="l7.1058">     // &quot;&lt;&lt;&lt;---&quot; points to the part we're examining here.</span>
<a href="#l7.1059"></a><span id="l7.1059" class="difflineminus">-    if ( PL_strcasecmp(m_bodyType, &quot;message&quot;) || PL_strcasecmp(m_bodySubType, &quot;rfc822&quot;) ||</span>
<a href="#l7.1060"></a><span id="l7.1060" class="difflineminus">-      PL_strcasecmp(m_parentPart-&gt;GetBodyType(), &quot;message&quot;) || PL_strcasecmp(m_parentPart-&gt;GetBodySubType(), &quot;rfc822&quot;) )</span>
<a href="#l7.1061"></a><span id="l7.1061" class="difflineplus">+    if (PL_strcasecmp(m_bodyType, &quot;message&quot;) ||</span>
<a href="#l7.1062"></a><span id="l7.1062" class="difflineplus">+        PL_strcasecmp(m_bodySubType, &quot;rfc822&quot;) ||</span>
<a href="#l7.1063"></a><span id="l7.1063" class="difflineplus">+        PL_strcasecmp(m_parentPart-&gt;GetBodyType(), &quot;message&quot;) ||</span>
<a href="#l7.1064"></a><span id="l7.1064" class="difflineplus">+        PL_strcasecmp(m_parentPart-&gt;GetBodySubType(), &quot;rfc822&quot;))</span>
<a href="#l7.1065"></a><span id="l7.1065">       m_contentLength += GenerateMIMEHeader(aShell, stream, prefetch);</span>
<a href="#l7.1066"></a><span id="l7.1066">   }</span>
<a href="#l7.1067"></a><span id="l7.1067"> </span>
<a href="#l7.1068"></a><span id="l7.1068">   if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l7.1069"></a><span id="l7.1069">     m_contentLength += m_headers-&gt;Generate(aShell, stream, prefetch);</span>
<a href="#l7.1070"></a><span id="l7.1070">   if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l7.1071"></a><span id="l7.1071">     m_contentLength += m_body-&gt;Generate(aShell, stream, prefetch);</span>
<a href="#l7.1072"></a><span id="l7.1072"> </span>
<a href="#l7.1073"></a><span id="l7.1073">   return m_contentLength;</span>
<a href="#l7.1074"></a><span id="l7.1074"> }</span>
<a href="#l7.1075"></a><span id="l7.1075"> </span>
<a href="#l7.1076"></a><span id="l7.1076" class="difflineminus">-bool nsIMAPBodypartMessage::ShouldFetchInline(nsIMAPBodyShell *aShell)</span>
<a href="#l7.1077"></a><span id="l7.1077" class="difflineminus">-{</span>
<a href="#l7.1078"></a><span id="l7.1078" class="difflineminus">-  if (m_topLevelMessage)  // the main message should always be defined as &quot;inline&quot;</span>
<a href="#l7.1079"></a><span id="l7.1079" class="difflineplus">+bool nsIMAPBodypartMessage::ShouldFetchInline(nsIMAPBodyShell *aShell) {</span>
<a href="#l7.1080"></a><span id="l7.1080" class="difflineplus">+  if (m_topLevelMessage)  // the main message should always be defined as</span>
<a href="#l7.1081"></a><span id="l7.1081" class="difflineplus">+                          // &quot;inline&quot;</span>
<a href="#l7.1082"></a><span id="l7.1082">     return true;</span>
<a href="#l7.1083"></a><span id="l7.1083"> </span>
<a href="#l7.1084"></a><span id="l7.1084">   char *generatingPart = aShell-&gt;GetGeneratingPart();</span>
<a href="#l7.1085"></a><span id="l7.1085" class="difflineminus">-  if (generatingPart)</span>
<a href="#l7.1086"></a><span id="l7.1086" class="difflineminus">-  {</span>
<a href="#l7.1087"></a><span id="l7.1087" class="difflineplus">+  if (generatingPart) {</span>
<a href="#l7.1088"></a><span id="l7.1088">     // If we are generating a specific part</span>
<a href="#l7.1089"></a><span id="l7.1089">     // Always generate containers (just don't fill them in)</span>
<a href="#l7.1090"></a><span id="l7.1090">     // because it is low cost (everything is cached)</span>
<a href="#l7.1091"></a><span id="l7.1091">     // and it gives the message its full MIME structure,</span>
<a href="#l7.1092"></a><span id="l7.1092">     // to avoid any potential mishap.</span>
<a href="#l7.1093"></a><span id="l7.1093">     return true;</span>
<a href="#l7.1094"></a><span id="l7.1094">   }</span>
<a href="#l7.1095"></a><span id="l7.1095"> </span>
<a href="#l7.1096"></a><span id="l7.1096">   // Generating whole message</span>
<a href="#l7.1097"></a><span id="l7.1097" class="difflineminus">-  if (ShouldExplicitlyFetchInline())</span>
<a href="#l7.1098"></a><span id="l7.1098" class="difflineminus">-    return true;</span>
<a href="#l7.1099"></a><span id="l7.1099" class="difflineminus">-  if (ShouldExplicitlyNotFetchInline())</span>
<a href="#l7.1100"></a><span id="l7.1100" class="difflineminus">-    return false;</span>
<a href="#l7.1101"></a><span id="l7.1101" class="difflineplus">+  if (ShouldExplicitlyFetchInline()) return true;</span>
<a href="#l7.1102"></a><span id="l7.1102" class="difflineplus">+  if (ShouldExplicitlyNotFetchInline()) return false;</span>
<a href="#l7.1103"></a><span id="l7.1103"> </span>
<a href="#l7.1104"></a><span id="l7.1104">   // Message types are inline, by default.</span>
<a href="#l7.1105"></a><span id="l7.1105">   return true;</span>
<a href="#l7.1106"></a><span id="l7.1106" class="difflineminus">-</span>
<a href="#l7.1107"></a><span id="l7.1107"> }</span>
<a href="#l7.1108"></a><span id="l7.1108"> </span>
<a href="#l7.1109"></a><span id="l7.1109" class="difflineminus">-bool nsIMAPBodypartMessage::PreflightCheckAllInline(nsIMAPBodyShell *aShell)</span>
<a href="#l7.1110"></a><span id="l7.1110" class="difflineminus">-{</span>
<a href="#l7.1111"></a><span id="l7.1111" class="difflineminus">-  if (!ShouldFetchInline(aShell))</span>
<a href="#l7.1112"></a><span id="l7.1112" class="difflineminus">-    return false;</span>
<a href="#l7.1113"></a><span id="l7.1113" class="difflineplus">+bool nsIMAPBodypartMessage::PreflightCheckAllInline(nsIMAPBodyShell *aShell) {</span>
<a href="#l7.1114"></a><span id="l7.1114" class="difflineplus">+  if (!ShouldFetchInline(aShell)) return false;</span>
<a href="#l7.1115"></a><span id="l7.1115"> </span>
<a href="#l7.1116"></a><span id="l7.1116">   return m_body-&gt;PreflightCheckAllInline(aShell);</span>
<a href="#l7.1117"></a><span id="l7.1117"> }</span>
<a href="#l7.1118"></a><span id="l7.1118"> </span>
<a href="#l7.1119"></a><span id="l7.1119"> // Fills in buffer (and adopts storage) for header object</span>
<a href="#l7.1120"></a><span id="l7.1120" class="difflineminus">-void nsIMAPBodypartMessage::AdoptMessageHeaders(char *headers)</span>
<a href="#l7.1121"></a><span id="l7.1121" class="difflineminus">-{</span>
<a href="#l7.1122"></a><span id="l7.1122" class="difflineminus">-  if (!GetIsValid())</span>
<a href="#l7.1123"></a><span id="l7.1123" class="difflineminus">-    return;</span>
<a href="#l7.1124"></a><span id="l7.1124" class="difflineplus">+void nsIMAPBodypartMessage::AdoptMessageHeaders(char *headers) {</span>
<a href="#l7.1125"></a><span id="l7.1125" class="difflineplus">+  if (!GetIsValid()) return;</span>
<a href="#l7.1126"></a><span id="l7.1126"> </span>
<a href="#l7.1127"></a><span id="l7.1127">   // we are going to say that the message headers only have</span>
<a href="#l7.1128"></a><span id="l7.1128">   // part data, and no header data.</span>
<a href="#l7.1129"></a><span id="l7.1129">   m_headers-&gt;AdoptPartDataBuffer(headers);</span>
<a href="#l7.1130"></a><span id="l7.1130" class="difflineminus">-  if (!m_headers-&gt;GetIsValid())</span>
<a href="#l7.1131"></a><span id="l7.1131" class="difflineminus">-    SetIsValid(false);</span>
<a href="#l7.1132"></a><span id="l7.1132" class="difflineplus">+  if (!m_headers-&gt;GetIsValid()) SetIsValid(false);</span>
<a href="#l7.1133"></a><span id="l7.1133"> }</span>
<a href="#l7.1134"></a><span id="l7.1134"> </span>
<a href="#l7.1135"></a><span id="l7.1135"> // Finds the part with given part number</span>
<a href="#l7.1136"></a><span id="l7.1136"> // Returns a nsIMAPBodystructure of the matched part if it is this</span>
<a href="#l7.1137"></a><span id="l7.1137"> // or one of its children.  Returns NULL otherwise.</span>
<a href="#l7.1138"></a><span id="l7.1138" class="difflineminus">-nsIMAPBodypart *nsIMAPBodypartMessage::FindPartWithNumber(const char *partNum)</span>
<a href="#l7.1139"></a><span id="l7.1139" class="difflineminus">-{</span>
<a href="#l7.1140"></a><span id="l7.1140" class="difflineplus">+nsIMAPBodypart *nsIMAPBodypartMessage::FindPartWithNumber(const char *partNum) {</span>
<a href="#l7.1141"></a><span id="l7.1141">   // either brute force, or do it the smart way - look at the number.</span>
<a href="#l7.1142"></a><span id="l7.1142">   // (the parts should be ordered, and hopefully indexed by their number)</span>
<a href="#l7.1143"></a><span id="l7.1143"> </span>
<a href="#l7.1144"></a><span id="l7.1144" class="difflineminus">-  if (!PL_strcasecmp(partNum, m_partNumberString))</span>
<a href="#l7.1145"></a><span id="l7.1145" class="difflineminus">-    return this;</span>
<a href="#l7.1146"></a><span id="l7.1146" class="difflineplus">+  if (!PL_strcasecmp(partNum, m_partNumberString)) return this;</span>
<a href="#l7.1147"></a><span id="l7.1147"> </span>
<a href="#l7.1148"></a><span id="l7.1148">   return m_body-&gt;FindPartWithNumber(partNum);</span>
<a href="#l7.1149"></a><span id="l7.1149"> }</span>
<a href="#l7.1150"></a><span id="l7.1150"> </span>
<a href="#l7.1151"></a><span id="l7.1151"> ///////////// nsIMAPBodypartMultipart ////////////////////////</span>
<a href="#l7.1152"></a><span id="l7.1152"> </span>
<a href="#l7.1153"></a><span id="l7.1153" class="difflineminus">-nsIMAPBodypartMultipart::nsIMAPBodypartMultipart(char *partNum, nsIMAPBodypart *parentPart) :</span>
<a href="#l7.1154"></a><span id="l7.1154" class="difflineminus">-nsIMAPBodypart(partNum, parentPart)</span>
<a href="#l7.1155"></a><span id="l7.1155" class="difflineminus">-{</span>
<a href="#l7.1156"></a><span id="l7.1156" class="difflineminus">-  if (!m_parentPart  || (m_parentPart-&gt;GetType() == IMAP_BODY_MESSAGE_RFC822))</span>
<a href="#l7.1157"></a><span id="l7.1157" class="difflineminus">-  {</span>
<a href="#l7.1158"></a><span id="l7.1158" class="difflineplus">+nsIMAPBodypartMultipart::nsIMAPBodypartMultipart(char *partNum,</span>
<a href="#l7.1159"></a><span id="l7.1159" class="difflineplus">+                                                 nsIMAPBodypart *parentPart)</span>
<a href="#l7.1160"></a><span id="l7.1160" class="difflineplus">+    : nsIMAPBodypart(partNum, parentPart) {</span>
<a href="#l7.1161"></a><span id="l7.1161" class="difflineplus">+  if (!m_parentPart || (m_parentPart-&gt;GetType() == IMAP_BODY_MESSAGE_RFC822)) {</span>
<a href="#l7.1162"></a><span id="l7.1162">     // the multipart (this) will inherit the part number of its parent</span>
<a href="#l7.1163"></a><span id="l7.1163">     PR_FREEIF(m_partNumberString);</span>
<a href="#l7.1164"></a><span id="l7.1164" class="difflineminus">-    if (!m_parentPart)</span>
<a href="#l7.1165"></a><span id="l7.1165" class="difflineminus">-    {</span>
<a href="#l7.1166"></a><span id="l7.1166" class="difflineplus">+    if (!m_parentPart) {</span>
<a href="#l7.1167"></a><span id="l7.1167">       m_partNumberString = PR_smprintf(&quot;0&quot;);</span>
<a href="#l7.1168"></a><span id="l7.1168" class="difflineminus">-    }</span>
<a href="#l7.1169"></a><span id="l7.1169" class="difflineminus">-    else</span>
<a href="#l7.1170"></a><span id="l7.1170" class="difflineplus">+    } else</span>
<a href="#l7.1171"></a><span id="l7.1171">       m_partNumberString = NS_xstrdup(m_parentPart-&gt;GetPartNumberString());</span>
<a href="#l7.1172"></a><span id="l7.1172">   }</span>
<a href="#l7.1173"></a><span id="l7.1173" class="difflineminus">-  m_partList = new nsTArray&lt;nsIMAPBodypart*&gt;();</span>
<a href="#l7.1174"></a><span id="l7.1174" class="difflineplus">+  m_partList = new nsTArray&lt;nsIMAPBodypart *&gt;();</span>
<a href="#l7.1175"></a><span id="l7.1175">   m_bodyType = NS_xstrdup(&quot;multipart&quot;);</span>
<a href="#l7.1176"></a><span id="l7.1176">   if (m_partList &amp;&amp; m_parentPart &amp;&amp; m_bodyType)</span>
<a href="#l7.1177"></a><span id="l7.1177">     SetIsValid(true);</span>
<a href="#l7.1178"></a><span id="l7.1178">   else</span>
<a href="#l7.1179"></a><span id="l7.1179">     SetIsValid(false);</span>
<a href="#l7.1180"></a><span id="l7.1180"> }</span>
<a href="#l7.1181"></a><span id="l7.1181"> </span>
<a href="#l7.1182"></a><span id="l7.1182" class="difflineminus">-nsIMAPBodypartType nsIMAPBodypartMultipart::GetType()</span>
<a href="#l7.1183"></a><span id="l7.1183" class="difflineminus">-{</span>
<a href="#l7.1184"></a><span id="l7.1184" class="difflineplus">+nsIMAPBodypartType nsIMAPBodypartMultipart::GetType() {</span>
<a href="#l7.1185"></a><span id="l7.1185">   return IMAP_BODY_MULTIPART;</span>
<a href="#l7.1186"></a><span id="l7.1186"> }</span>
<a href="#l7.1187"></a><span id="l7.1187"> </span>
<a href="#l7.1188"></a><span id="l7.1188" class="difflineminus">-nsIMAPBodypartMultipart::~nsIMAPBodypartMultipart()</span>
<a href="#l7.1189"></a><span id="l7.1189" class="difflineminus">-{</span>
<a href="#l7.1190"></a><span id="l7.1190" class="difflineminus">-  for (int i = m_partList-&gt;Length() - 1; i &gt;= 0; i--)</span>
<a href="#l7.1191"></a><span id="l7.1191" class="difflineminus">-  {</span>
<a href="#l7.1192"></a><span id="l7.1192" class="difflineplus">+nsIMAPBodypartMultipart::~nsIMAPBodypartMultipart() {</span>
<a href="#l7.1193"></a><span id="l7.1193" class="difflineplus">+  for (int i = m_partList-&gt;Length() - 1; i &gt;= 0; i--) {</span>
<a href="#l7.1194"></a><span id="l7.1194">     delete m_partList-&gt;ElementAt(i);</span>
<a href="#l7.1195"></a><span id="l7.1195">   }</span>
<a href="#l7.1196"></a><span id="l7.1196">   delete m_partList;</span>
<a href="#l7.1197"></a><span id="l7.1197"> }</span>
<a href="#l7.1198"></a><span id="l7.1198"> </span>
<a href="#l7.1199"></a><span id="l7.1199" class="difflineminus">-void</span>
<a href="#l7.1200"></a><span id="l7.1200" class="difflineminus">-nsIMAPBodypartMultipart::SetBodySubType(char *bodySubType)</span>
<a href="#l7.1201"></a><span id="l7.1201" class="difflineminus">-{</span>
<a href="#l7.1202"></a><span id="l7.1202" class="difflineplus">+void nsIMAPBodypartMultipart::SetBodySubType(char *bodySubType) {</span>
<a href="#l7.1203"></a><span id="l7.1203">   PR_FREEIF(m_bodySubType);</span>
<a href="#l7.1204"></a><span id="l7.1204">   PR_FREEIF(m_contentType);</span>
<a href="#l7.1205"></a><span id="l7.1205">   m_bodySubType = bodySubType;</span>
<a href="#l7.1206"></a><span id="l7.1206">   if (m_bodyType &amp;&amp; m_bodySubType)</span>
<a href="#l7.1207"></a><span id="l7.1207">     m_contentType = PR_smprintf(&quot;%s/%s&quot;, m_bodyType, m_bodySubType);</span>
<a href="#l7.1208"></a><span id="l7.1208"> }</span>
<a href="#l7.1209"></a><span id="l7.1209"> </span>
<a href="#l7.1210"></a><span id="l7.1210" class="difflineminus">-int32_t nsIMAPBodypartMultipart::Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch)</span>
<a href="#l7.1211"></a><span id="l7.1211" class="difflineminus">-{</span>
<a href="#l7.1212"></a><span id="l7.1212" class="difflineplus">+int32_t nsIMAPBodypartMultipart::Generate(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l7.1213"></a><span id="l7.1213" class="difflineplus">+                                          bool prefetch) {</span>
<a href="#l7.1214"></a><span id="l7.1214">   int32_t len = 0;</span>
<a href="#l7.1215"></a><span id="l7.1215"> </span>
<a href="#l7.1216"></a><span id="l7.1216" class="difflineminus">-  if (GetIsValid())</span>
<a href="#l7.1217"></a><span id="l7.1217" class="difflineminus">-  {</span>
<a href="#l7.1218"></a><span id="l7.1218" class="difflineplus">+  if (GetIsValid()) {</span>
<a href="#l7.1219"></a><span id="l7.1219">     if (stream &amp;&amp; !prefetch)</span>
<a href="#l7.1220"></a><span id="l7.1220" class="difflineminus">-      aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-Multipart&quot;,m_partNumberString);</span>
<a href="#l7.1221"></a><span id="l7.1221" class="difflineplus">+      aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;, &quot;GENERATE-Multipart&quot;,</span>
<a href="#l7.1222"></a><span id="l7.1222" class="difflineplus">+                                   m_partNumberString);</span>
<a href="#l7.1223"></a><span id="l7.1223"> </span>
<a href="#l7.1224"></a><span id="l7.1224">     // Stream out the MIME header of this part</span>
<a href="#l7.1225"></a><span id="l7.1225"> </span>
<a href="#l7.1226"></a><span id="l7.1226" class="difflineminus">-    bool parentIsMessageType = GetParentPart() ? (GetParentPart()-&gt;GetType() == IMAP_BODY_MESSAGE_RFC822) : true;</span>
<a href="#l7.1227"></a><span id="l7.1227" class="difflineplus">+    bool parentIsMessageType =</span>
<a href="#l7.1228"></a><span id="l7.1228" class="difflineplus">+        GetParentPart()</span>
<a href="#l7.1229"></a><span id="l7.1229" class="difflineplus">+            ? (GetParentPart()-&gt;GetType() == IMAP_BODY_MESSAGE_RFC822)</span>
<a href="#l7.1230"></a><span id="l7.1230" class="difflineplus">+            : true;</span>
<a href="#l7.1231"></a><span id="l7.1231"> </span>
<a href="#l7.1232"></a><span id="l7.1232" class="difflineminus">-    // If this is multipart/signed, then we always want to generate the MIME headers of this multipart.</span>
<a href="#l7.1233"></a><span id="l7.1233" class="difflineminus">-    // Otherwise, we only want to do it if the parent is not of type &quot;message&quot;</span>
<a href="#l7.1234"></a><span id="l7.1234" class="difflineminus">-    bool needMIMEHeader = !parentIsMessageType;  // !PL_strcasecmp(m_bodySubType, &quot;signed&quot;) ? true : !parentIsMessageType;</span>
<a href="#l7.1235"></a><span id="l7.1235" class="difflineminus">-    if (needMIMEHeader &amp;&amp; !aShell-&gt;GetPseudoInterrupted())  // not a message body's type</span>
<a href="#l7.1236"></a><span id="l7.1236" class="difflineplus">+    // If this is multipart/signed, then we always want to generate the MIME</span>
<a href="#l7.1237"></a><span id="l7.1237" class="difflineplus">+    // headers of this multipart. Otherwise, we only want to do it if the parent</span>
<a href="#l7.1238"></a><span id="l7.1238" class="difflineplus">+    // is not of type &quot;message&quot;</span>
<a href="#l7.1239"></a><span id="l7.1239" class="difflineplus">+    bool needMIMEHeader =</span>
<a href="#l7.1240"></a><span id="l7.1240" class="difflineplus">+        !parentIsMessageType;  // !PL_strcasecmp(m_bodySubType, &quot;signed&quot;) ? true</span>
<a href="#l7.1241"></a><span id="l7.1241" class="difflineplus">+                               // : !parentIsMessageType;</span>
<a href="#l7.1242"></a><span id="l7.1242" class="difflineplus">+    if (needMIMEHeader &amp;&amp;</span>
<a href="#l7.1243"></a><span id="l7.1243" class="difflineplus">+        !aShell-&gt;GetPseudoInterrupted())  // not a message body's type</span>
<a href="#l7.1244"></a><span id="l7.1244">     {</span>
<a href="#l7.1245"></a><span id="l7.1245">       len += GenerateMIMEHeader(aShell, stream, prefetch);</span>
<a href="#l7.1246"></a><span id="l7.1246">     }</span>
<a href="#l7.1247"></a><span id="l7.1247"> </span>
<a href="#l7.1248"></a><span id="l7.1248" class="difflineminus">-    if (ShouldFetchInline(aShell))</span>
<a href="#l7.1249"></a><span id="l7.1249" class="difflineminus">-    {</span>
<a href="#l7.1250"></a><span id="l7.1250" class="difflineminus">-      for (size_t i = 0; i &lt; m_partList-&gt;Length(); i++)</span>
<a href="#l7.1251"></a><span id="l7.1251" class="difflineminus">-      {</span>
<a href="#l7.1252"></a><span id="l7.1252" class="difflineplus">+    if (ShouldFetchInline(aShell)) {</span>
<a href="#l7.1253"></a><span id="l7.1253" class="difflineplus">+      for (size_t i = 0; i &lt; m_partList-&gt;Length(); i++) {</span>
<a href="#l7.1254"></a><span id="l7.1254">         if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l7.1255"></a><span id="l7.1255">           len += GenerateBoundary(aShell, stream, prefetch, false);</span>
<a href="#l7.1256"></a><span id="l7.1256">         if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l7.1257"></a><span id="l7.1257">           len += m_partList-&gt;ElementAt(i)-&gt;Generate(aShell, stream, prefetch);</span>
<a href="#l7.1258"></a><span id="l7.1258">       }</span>
<a href="#l7.1259"></a><span id="l7.1259">       if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l7.1260"></a><span id="l7.1260">         len += GenerateBoundary(aShell, stream, prefetch, true);</span>
<a href="#l7.1261"></a><span id="l7.1261" class="difflineminus">-    }</span>
<a href="#l7.1262"></a><span id="l7.1262" class="difflineminus">-    else</span>
<a href="#l7.1263"></a><span id="l7.1263" class="difflineminus">-    {</span>
<a href="#l7.1264"></a><span id="l7.1264" class="difflineplus">+    } else {</span>
<a href="#l7.1265"></a><span id="l7.1265">       // fill in the filling within the empty part</span>
<a href="#l7.1266"></a><span id="l7.1266">       if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l7.1267"></a><span id="l7.1267">         len += GenerateEmptyFilling(aShell, stream, prefetch);</span>
<a href="#l7.1268"></a><span id="l7.1268">     }</span>
<a href="#l7.1269"></a><span id="l7.1269">   }</span>
<a href="#l7.1270"></a><span id="l7.1270">   m_contentLength = len;</span>
<a href="#l7.1271"></a><span id="l7.1271">   return m_contentLength;</span>
<a href="#l7.1272"></a><span id="l7.1272"> }</span>
<a href="#l7.1273"></a><span id="l7.1273"> </span>
<a href="#l7.1274"></a><span id="l7.1274" class="difflineminus">-bool nsIMAPBodypartMultipart::ShouldFetchInline(nsIMAPBodyShell *aShell)</span>
<a href="#l7.1275"></a><span id="l7.1275" class="difflineminus">-{</span>
<a href="#l7.1276"></a><span id="l7.1276" class="difflineplus">+bool nsIMAPBodypartMultipart::ShouldFetchInline(nsIMAPBodyShell *aShell) {</span>
<a href="#l7.1277"></a><span id="l7.1277">   char *generatingPart = aShell-&gt;GetGeneratingPart();</span>
<a href="#l7.1278"></a><span id="l7.1278" class="difflineminus">-  if (generatingPart)</span>
<a href="#l7.1279"></a><span id="l7.1279" class="difflineminus">-  {</span>
<a href="#l7.1280"></a><span id="l7.1280" class="difflineplus">+  if (generatingPart) {</span>
<a href="#l7.1281"></a><span id="l7.1281">     // If we are generating a specific part</span>
<a href="#l7.1282"></a><span id="l7.1282">     // Always generate containers (just don't fill them in)</span>
<a href="#l7.1283"></a><span id="l7.1283">     // because it is low cost (everything is cached)</span>
<a href="#l7.1284"></a><span id="l7.1284">     // and it gives the message its full MIME structure,</span>
<a href="#l7.1285"></a><span id="l7.1285">     // to avoid any potential mishap.</span>
<a href="#l7.1286"></a><span id="l7.1286">     return true;</span>
<a href="#l7.1287"></a><span id="l7.1287">   }</span>
<a href="#l7.1288"></a><span id="l7.1288"> </span>
<a href="#l7.1289"></a><span id="l7.1289">   // Generating whole message</span>
<a href="#l7.1290"></a><span id="l7.1290" class="difflineminus">-  if (ShouldExplicitlyFetchInline())</span>
<a href="#l7.1291"></a><span id="l7.1291" class="difflineminus">-    return true;</span>
<a href="#l7.1292"></a><span id="l7.1292" class="difflineminus">-  if (ShouldExplicitlyNotFetchInline())</span>
<a href="#l7.1293"></a><span id="l7.1293" class="difflineminus">-    return false;</span>
<a href="#l7.1294"></a><span id="l7.1294" class="difflineplus">+  if (ShouldExplicitlyFetchInline()) return true;</span>
<a href="#l7.1295"></a><span id="l7.1295" class="difflineplus">+  if (ShouldExplicitlyNotFetchInline()) return false;</span>
<a href="#l7.1296"></a><span id="l7.1296"> </span>
<a href="#l7.1297"></a><span id="l7.1297" class="difflineminus">-  if (!PL_strcasecmp(m_bodySubType, &quot;alternative&quot;))</span>
<a href="#l7.1298"></a><span id="l7.1298" class="difflineminus">-    return true;</span>
<a href="#l7.1299"></a><span id="l7.1299" class="difflineplus">+  if (!PL_strcasecmp(m_bodySubType, &quot;alternative&quot;)) return true;</span>
<a href="#l7.1300"></a><span id="l7.1300"> </span>
<a href="#l7.1301"></a><span id="l7.1301">   nsIMAPBodypart *grandparentPart = m_parentPart-&gt;GetParentPart();</span>
<a href="#l7.1302"></a><span id="l7.1302"> </span>
<a href="#l7.1303"></a><span id="l7.1303">   // if we're a multipart sub-part of multipart alternative, we need to</span>
<a href="#l7.1304"></a><span id="l7.1304">   // be fetched because mime will always display us.</span>
<a href="#l7.1305"></a><span id="l7.1305">   if (!PL_strcasecmp(m_parentPart-&gt;GetBodySubType(), &quot;alternative&quot;) &amp;&amp;</span>
<a href="#l7.1306"></a><span id="l7.1306">       GetType() == IMAP_BODY_MULTIPART)</span>
<a href="#l7.1307"></a><span id="l7.1307">     return true;</span>
<a href="#l7.1308"></a><span id="l7.1308">   // If &quot;Show Attachments as Links&quot; is on, and</span>
<a href="#l7.1309"></a><span id="l7.1309">   // the parent of this multipart is not a message,</span>
<a href="#l7.1310"></a><span id="l7.1310">   // then it's not inline.</span>
<a href="#l7.1311"></a><span id="l7.1311">   if (!(aShell-&gt;GetContentModified() == IMAP_CONTENT_MODIFIED_VIEW_INLINE) &amp;&amp;</span>
<a href="#l7.1312"></a><span id="l7.1312" class="difflineminus">-    (m_parentPart-&gt;GetType() != IMAP_BODY_MESSAGE_RFC822) &amp;&amp;</span>
<a href="#l7.1313"></a><span id="l7.1313" class="difflineminus">-    (m_parentPart-&gt;GetType() == IMAP_BODY_MULTIPART ?</span>
<a href="#l7.1314"></a><span id="l7.1314" class="difflineminus">-    (grandparentPart ? grandparentPart-&gt;GetType() != IMAP_BODY_MESSAGE_RFC822 : true)</span>
<a href="#l7.1315"></a><span id="l7.1315" class="difflineminus">-    : true))</span>
<a href="#l7.1316"></a><span id="l7.1316" class="difflineplus">+      (m_parentPart-&gt;GetType() != IMAP_BODY_MESSAGE_RFC822) &amp;&amp;</span>
<a href="#l7.1317"></a><span id="l7.1317" class="difflineplus">+      (m_parentPart-&gt;GetType() == IMAP_BODY_MULTIPART</span>
<a href="#l7.1318"></a><span id="l7.1318" class="difflineplus">+           ? (grandparentPart</span>
<a href="#l7.1319"></a><span id="l7.1319" class="difflineplus">+                  ? grandparentPart-&gt;GetType() != IMAP_BODY_MESSAGE_RFC822</span>
<a href="#l7.1320"></a><span id="l7.1320" class="difflineplus">+                  : true)</span>
<a href="#l7.1321"></a><span id="l7.1321" class="difflineplus">+           : true))</span>
<a href="#l7.1322"></a><span id="l7.1322">     return false;</span>
<a href="#l7.1323"></a><span id="l7.1323"> </span>
<a href="#l7.1324"></a><span id="l7.1324">   // multiparts are always inline (even multipart/appledouble)</span>
<a href="#l7.1325"></a><span id="l7.1325">   // (their children might not be, though)</span>
<a href="#l7.1326"></a><span id="l7.1326">   return true;</span>
<a href="#l7.1327"></a><span id="l7.1327"> }</span>
<a href="#l7.1328"></a><span id="l7.1328"> </span>
<a href="#l7.1329"></a><span id="l7.1329" class="difflineminus">-bool nsIMAPBodypartMultipart::PreflightCheckAllInline(nsIMAPBodyShell *aShell)</span>
<a href="#l7.1330"></a><span id="l7.1330" class="difflineminus">-{</span>
<a href="#l7.1331"></a><span id="l7.1331" class="difflineplus">+bool nsIMAPBodypartMultipart::PreflightCheckAllInline(nsIMAPBodyShell *aShell) {</span>
<a href="#l7.1332"></a><span id="l7.1332">   bool rv = ShouldFetchInline(aShell);</span>
<a href="#l7.1333"></a><span id="l7.1333"> </span>
<a href="#l7.1334"></a><span id="l7.1334">   size_t i = 0;</span>
<a href="#l7.1335"></a><span id="l7.1335" class="difflineminus">-  while (rv &amp;&amp; (i &lt; m_partList-&gt;Length()))</span>
<a href="#l7.1336"></a><span id="l7.1336" class="difflineminus">-  {</span>
<a href="#l7.1337"></a><span id="l7.1337" class="difflineplus">+  while (rv &amp;&amp; (i &lt; m_partList-&gt;Length())) {</span>
<a href="#l7.1338"></a><span id="l7.1338">     rv = m_partList-&gt;ElementAt(i)-&gt;PreflightCheckAllInline(aShell);</span>
<a href="#l7.1339"></a><span id="l7.1339">     i++;</span>
<a href="#l7.1340"></a><span id="l7.1340">   }</span>
<a href="#l7.1341"></a><span id="l7.1341"> </span>
<a href="#l7.1342"></a><span id="l7.1342">   return rv;</span>
<a href="#l7.1343"></a><span id="l7.1343"> }</span>
<a href="#l7.1344"></a><span id="l7.1344"> </span>
<a href="#l7.1345"></a><span id="l7.1345" class="difflineminus">-nsIMAPBodypart *nsIMAPBodypartMultipart::FindPartWithNumber(const char *partNum)</span>
<a href="#l7.1346"></a><span id="l7.1346" class="difflineminus">-{</span>
<a href="#l7.1347"></a><span id="l7.1347" class="difflineplus">+nsIMAPBodypart *nsIMAPBodypartMultipart::FindPartWithNumber(</span>
<a href="#l7.1348"></a><span id="l7.1348" class="difflineplus">+    const char *partNum) {</span>
<a href="#l7.1349"></a><span id="l7.1349">   NS_ASSERTION(partNum, &quot;null part passed into FindPartWithNumber&quot;);</span>
<a href="#l7.1350"></a><span id="l7.1350"> </span>
<a href="#l7.1351"></a><span id="l7.1351">   // check this</span>
<a href="#l7.1352"></a><span id="l7.1352" class="difflineminus">-  if (!PL_strcmp(partNum, m_partNumberString))</span>
<a href="#l7.1353"></a><span id="l7.1353" class="difflineminus">-    return this;</span>
<a href="#l7.1354"></a><span id="l7.1354" class="difflineplus">+  if (!PL_strcmp(partNum, m_partNumberString)) return this;</span>
<a href="#l7.1355"></a><span id="l7.1355"> </span>
<a href="#l7.1356"></a><span id="l7.1356">   // check children</span>
<a href="#l7.1357"></a><span id="l7.1357" class="difflineminus">-  for (int i = m_partList-&gt;Length() - 1; i &gt;= 0; i--)</span>
<a href="#l7.1358"></a><span id="l7.1358" class="difflineminus">-  {</span>
<a href="#l7.1359"></a><span id="l7.1359" class="difflineminus">-    nsIMAPBodypart *foundPart = m_partList-&gt;ElementAt(i)-&gt;FindPartWithNumber(partNum);</span>
<a href="#l7.1360"></a><span id="l7.1360" class="difflineminus">-    if (foundPart)</span>
<a href="#l7.1361"></a><span id="l7.1361" class="difflineminus">-      return foundPart;</span>
<a href="#l7.1362"></a><span id="l7.1362" class="difflineplus">+  for (int i = m_partList-&gt;Length() - 1; i &gt;= 0; i--) {</span>
<a href="#l7.1363"></a><span id="l7.1363" class="difflineplus">+    nsIMAPBodypart *foundPart =</span>
<a href="#l7.1364"></a><span id="l7.1364" class="difflineplus">+        m_partList-&gt;ElementAt(i)-&gt;FindPartWithNumber(partNum);</span>
<a href="#l7.1365"></a><span id="l7.1365" class="difflineplus">+    if (foundPart) return foundPart;</span>
<a href="#l7.1366"></a><span id="l7.1366">   }</span>
<a href="#l7.1367"></a><span id="l7.1367"> </span>
<a href="#l7.1368"></a><span id="l7.1368">   // not this, or any of this's children</span>
<a href="#l7.1369"></a><span id="l7.1369">   return NULL;</span>
<a href="#l7.1370"></a><span id="l7.1370"> }</span>
<a href="#l7.1371"></a><span id="l7.1371"> </span>
<a href="#l7.1372"></a><span id="l7.1372" class="difflineminus">-</span>
<a href="#l7.1373"></a><span id="l7.1373"> ///////////// nsIMAPMessageHeaders ////////////////////////////////////</span>
<a href="#l7.1374"></a><span id="l7.1374"> </span>
<a href="#l7.1375"></a><span id="l7.1375" class="difflineminus">-nsIMAPMessageHeaders::nsIMAPMessageHeaders(char *partNum, nsIMAPBodypart *parentPart) :</span>
<a href="#l7.1376"></a><span id="l7.1376" class="difflineminus">-nsIMAPBodypart(partNum, parentPart)</span>
<a href="#l7.1377"></a><span id="l7.1377" class="difflineminus">-{</span>
<a href="#l7.1378"></a><span id="l7.1378" class="difflineminus">-  if (!partNum)</span>
<a href="#l7.1379"></a><span id="l7.1379" class="difflineminus">-  {</span>
<a href="#l7.1380"></a><span id="l7.1380" class="difflineplus">+nsIMAPMessageHeaders::nsIMAPMessageHeaders(char *partNum,</span>
<a href="#l7.1381"></a><span id="l7.1381" class="difflineplus">+                                           nsIMAPBodypart *parentPart)</span>
<a href="#l7.1382"></a><span id="l7.1382" class="difflineplus">+    : nsIMAPBodypart(partNum, parentPart) {</span>
<a href="#l7.1383"></a><span id="l7.1383" class="difflineplus">+  if (!partNum) {</span>
<a href="#l7.1384"></a><span id="l7.1384">     SetIsValid(false);</span>
<a href="#l7.1385"></a><span id="l7.1385">     return;</span>
<a href="#l7.1386"></a><span id="l7.1386">   }</span>
<a href="#l7.1387"></a><span id="l7.1387">   m_partNumberString = NS_xstrdup(partNum);</span>
<a href="#l7.1388"></a><span id="l7.1388" class="difflineminus">-  if (!m_partNumberString)</span>
<a href="#l7.1389"></a><span id="l7.1389" class="difflineminus">-  {</span>
<a href="#l7.1390"></a><span id="l7.1390" class="difflineplus">+  if (!m_partNumberString) {</span>
<a href="#l7.1391"></a><span id="l7.1391">     SetIsValid(false);</span>
<a href="#l7.1392"></a><span id="l7.1392">     return;</span>
<a href="#l7.1393"></a><span id="l7.1393">   }</span>
<a href="#l7.1394"></a><span id="l7.1394" class="difflineminus">-  if (!m_parentPart || !m_parentPart-&gt;GetnsIMAPBodypartMessage())</span>
<a href="#l7.1395"></a><span id="l7.1395" class="difflineminus">-  {</span>
<a href="#l7.1396"></a><span id="l7.1396" class="difflineplus">+  if (!m_parentPart || !m_parentPart-&gt;GetnsIMAPBodypartMessage()) {</span>
<a href="#l7.1397"></a><span id="l7.1397">     // Message headers created without a valid Message parent</span>
<a href="#l7.1398"></a><span id="l7.1398">     NS_ASSERTION(false, &quot;creating message headers with invalid message parent&quot;);</span>
<a href="#l7.1399"></a><span id="l7.1399">     SetIsValid(false);</span>
<a href="#l7.1400"></a><span id="l7.1400">   }</span>
<a href="#l7.1401"></a><span id="l7.1401"> }</span>
<a href="#l7.1402"></a><span id="l7.1402"> </span>
<a href="#l7.1403"></a><span id="l7.1403" class="difflineminus">-nsIMAPBodypartType nsIMAPMessageHeaders::GetType()</span>
<a href="#l7.1404"></a><span id="l7.1404" class="difflineminus">-{</span>
<a href="#l7.1405"></a><span id="l7.1405" class="difflineplus">+nsIMAPBodypartType nsIMAPMessageHeaders::GetType() {</span>
<a href="#l7.1406"></a><span id="l7.1406">   return IMAP_BODY_MESSAGE_HEADER;</span>
<a href="#l7.1407"></a><span id="l7.1407"> }</span>
<a href="#l7.1408"></a><span id="l7.1408"> </span>
<a href="#l7.1409"></a><span id="l7.1409" class="difflineminus">-void nsIMAPMessageHeaders::QueuePrefetchMessageHeaders(nsIMAPBodyShell *aShell)</span>
<a href="#l7.1410"></a><span id="l7.1410" class="difflineminus">-{</span>
<a href="#l7.1411"></a><span id="l7.1411" class="difflineminus">-</span>
<a href="#l7.1412"></a><span id="l7.1412" class="difflineminus">-  if (!m_parentPart-&gt;GetnsIMAPBodypartMessage()-&gt;GetIsTopLevelMessage())  // not top-level headers</span>
<a href="#l7.1413"></a><span id="l7.1413" class="difflineplus">+void nsIMAPMessageHeaders::QueuePrefetchMessageHeaders(</span>
<a href="#l7.1414"></a><span id="l7.1414" class="difflineplus">+    nsIMAPBodyShell *aShell) {</span>
<a href="#l7.1415"></a><span id="l7.1415" class="difflineplus">+  if (!m_parentPart-&gt;GetnsIMAPBodypartMessage()</span>
<a href="#l7.1416"></a><span id="l7.1416" class="difflineplus">+           -&gt;GetIsTopLevelMessage())  // not top-level headers</span>
<a href="#l7.1417"></a><span id="l7.1417">     aShell-&gt;AddPrefetchToQueue(kRFC822HeadersOnly, m_partNumberString);</span>
<a href="#l7.1418"></a><span id="l7.1418">   else</span>
<a href="#l7.1419"></a><span id="l7.1419">     aShell-&gt;AddPrefetchToQueue(kRFC822HeadersOnly, NULL);</span>
<a href="#l7.1420"></a><span id="l7.1420"> }</span>
<a href="#l7.1421"></a><span id="l7.1421"> </span>
<a href="#l7.1422"></a><span id="l7.1422" class="difflineminus">-int32_t nsIMAPMessageHeaders::Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch)</span>
<a href="#l7.1423"></a><span id="l7.1423" class="difflineminus">-{</span>
<a href="#l7.1424"></a><span id="l7.1424" class="difflineplus">+int32_t nsIMAPMessageHeaders::Generate(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l7.1425"></a><span id="l7.1425" class="difflineplus">+                                       bool prefetch) {</span>
<a href="#l7.1426"></a><span id="l7.1426">   // prefetch the header</span>
<a href="#l7.1427"></a><span id="l7.1427" class="difflineminus">-  if (prefetch &amp;&amp; !m_partData &amp;&amp; !aShell-&gt;DeathSignalReceived())</span>
<a href="#l7.1428"></a><span id="l7.1428" class="difflineminus">-  {</span>
<a href="#l7.1429"></a><span id="l7.1429" class="difflineplus">+  if (prefetch &amp;&amp; !m_partData &amp;&amp; !aShell-&gt;DeathSignalReceived()) {</span>
<a href="#l7.1430"></a><span id="l7.1430">     QueuePrefetchMessageHeaders(aShell);</span>
<a href="#l7.1431"></a><span id="l7.1431">   }</span>
<a href="#l7.1432"></a><span id="l7.1432"> </span>
<a href="#l7.1433"></a><span id="l7.1433">   if (stream &amp;&amp; !prefetch)</span>
<a href="#l7.1434"></a><span id="l7.1434" class="difflineminus">-    aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-MessageHeaders&quot;,m_partNumberString);</span>
<a href="#l7.1435"></a><span id="l7.1435" class="difflineplus">+    aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;, &quot;GENERATE-MessageHeaders&quot;,</span>
<a href="#l7.1436"></a><span id="l7.1436" class="difflineplus">+                                 m_partNumberString);</span>
<a href="#l7.1437"></a><span id="l7.1437"> </span>
<a href="#l7.1438"></a><span id="l7.1438">   // stream out the part data</span>
<a href="#l7.1439"></a><span id="l7.1439" class="difflineminus">-  if (ShouldFetchInline(aShell))</span>
<a href="#l7.1440"></a><span id="l7.1440" class="difflineminus">-  {</span>
<a href="#l7.1441"></a><span id="l7.1441" class="difflineplus">+  if (ShouldFetchInline(aShell)) {</span>
<a href="#l7.1442"></a><span id="l7.1442">     if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l7.1443"></a><span id="l7.1443">       m_contentLength = GeneratePart(aShell, stream, prefetch);</span>
<a href="#l7.1444"></a><span id="l7.1444" class="difflineminus">-  }</span>
<a href="#l7.1445"></a><span id="l7.1445" class="difflineminus">-  else</span>
<a href="#l7.1446"></a><span id="l7.1446" class="difflineminus">-  {</span>
<a href="#l7.1447"></a><span id="l7.1447" class="difflineplus">+  } else {</span>
<a href="#l7.1448"></a><span id="l7.1448">     m_contentLength = 0;  // don't fill in any filling for the headers</span>
<a href="#l7.1449"></a><span id="l7.1449">   }</span>
<a href="#l7.1450"></a><span id="l7.1450">   return m_contentLength;</span>
<a href="#l7.1451"></a><span id="l7.1451"> }</span>
<a href="#l7.1452"></a><span id="l7.1452"> </span>
<a href="#l7.1453"></a><span id="l7.1453" class="difflineminus">-bool nsIMAPMessageHeaders::ShouldFetchInline(nsIMAPBodyShell *aShell)</span>
<a href="#l7.1454"></a><span id="l7.1454" class="difflineminus">-{</span>
<a href="#l7.1455"></a><span id="l7.1455" class="difflineplus">+bool nsIMAPMessageHeaders::ShouldFetchInline(nsIMAPBodyShell *aShell) {</span>
<a href="#l7.1456"></a><span id="l7.1456">   return m_parentPart-&gt;ShouldFetchInline(aShell);</span>
<a href="#l7.1457"></a><span id="l7.1457"> }</span>
<a href="#l7.1458"></a><span id="l7.1458"> </span>
<a href="#l7.1459"></a><span id="l7.1459" class="difflineminus">-</span>
<a href="#l7.1460"></a><span id="l7.1460"> ///////////// nsIMAPBodyShellCache ////////////////////////////////////</span>
<a href="#l7.1461"></a><span id="l7.1461"> </span>
<a href="#l7.1462"></a><span id="l7.1462"> #if 0  // mscott - commenting out because it does not appear to be used</span>
<a href="#l7.1463"></a><span id="l7.1463"> static int</span>
<a href="#l7.1464"></a><span id="l7.1464"> imap_shell_cache_strcmp (const void *a, const void *b)</span>
<a href="#l7.1465"></a><span id="l7.1465"> {</span>
<a href="#l7.1466"></a><span id="l7.1466">   return PL_strcmp ((const char *) a, (const char *) b);</span>
<a href="#l7.1467"></a><span id="l7.1467"> }</span>
<a href="#l7.1468"></a><span id="l7.1468"> #endif</span>
<a href="#l7.1469"></a><span id="l7.1469"> </span>
<a href="#l7.1470"></a><span id="l7.1470" class="difflineminus">-nsIMAPBodyShellCache::nsIMAPBodyShellCache()</span>
<a href="#l7.1471"></a><span id="l7.1471" class="difflineminus">-: m_shellHash(20)</span>
<a href="#l7.1472"></a><span id="l7.1472" class="difflineminus">-{</span>
<a href="#l7.1473"></a><span id="l7.1473" class="difflineminus">-  m_shellList = new nsTArray&lt;nsIMAPBodyShell*&gt;();</span>
<a href="#l7.1474"></a><span id="l7.1474" class="difflineplus">+nsIMAPBodyShellCache::nsIMAPBodyShellCache() : m_shellHash(20) {</span>
<a href="#l7.1475"></a><span id="l7.1475" class="difflineplus">+  m_shellList = new nsTArray&lt;nsIMAPBodyShell *&gt;();</span>
<a href="#l7.1476"></a><span id="l7.1476"> }</span>
<a href="#l7.1477"></a><span id="l7.1477"> </span>
<a href="#l7.1478"></a><span id="l7.1478" class="difflineminus">-/* static */ nsIMAPBodyShellCache *nsIMAPBodyShellCache::Create()</span>
<a href="#l7.1479"></a><span id="l7.1479" class="difflineminus">-{</span>
<a href="#l7.1480"></a><span id="l7.1480" class="difflineplus">+/* static */ nsIMAPBodyShellCache *nsIMAPBodyShellCache::Create() {</span>
<a href="#l7.1481"></a><span id="l7.1481">   nsIMAPBodyShellCache *cache = new nsIMAPBodyShellCache();</span>
<a href="#l7.1482"></a><span id="l7.1482" class="difflineminus">-  if (!cache || !cache-&gt;m_shellList)</span>
<a href="#l7.1483"></a><span id="l7.1483" class="difflineminus">-    return NULL;</span>
<a href="#l7.1484"></a><span id="l7.1484" class="difflineplus">+  if (!cache || !cache-&gt;m_shellList) return NULL;</span>
<a href="#l7.1485"></a><span id="l7.1485"> </span>
<a href="#l7.1486"></a><span id="l7.1486">   return cache;</span>
<a href="#l7.1487"></a><span id="l7.1487"> }</span>
<a href="#l7.1488"></a><span id="l7.1488"> </span>
<a href="#l7.1489"></a><span id="l7.1489" class="difflineminus">-nsIMAPBodyShellCache::~nsIMAPBodyShellCache()</span>
<a href="#l7.1490"></a><span id="l7.1490" class="difflineminus">-{</span>
<a href="#l7.1491"></a><span id="l7.1491" class="difflineminus">-  while (EjectEntry()) ;</span>
<a href="#l7.1492"></a><span id="l7.1492" class="difflineplus">+nsIMAPBodyShellCache::~nsIMAPBodyShellCache() {</span>
<a href="#l7.1493"></a><span id="l7.1493" class="difflineplus">+  while (EjectEntry())</span>
<a href="#l7.1494"></a><span id="l7.1494" class="difflineplus">+    ;</span>
<a href="#l7.1495"></a><span id="l7.1495">   delete m_shellList;</span>
<a href="#l7.1496"></a><span id="l7.1496"> }</span>
<a href="#l7.1497"></a><span id="l7.1497"> </span>
<a href="#l7.1498"></a><span id="l7.1498"> // We'll use an LRU scheme here.</span>
<a href="#l7.1499"></a><span id="l7.1499"> // We will add shells in numerical order, so the</span>
<a href="#l7.1500"></a><span id="l7.1500"> // least recently used one will be in slot 0.</span>
<a href="#l7.1501"></a><span id="l7.1501" class="difflineminus">-bool nsIMAPBodyShellCache::EjectEntry()</span>
<a href="#l7.1502"></a><span id="l7.1502" class="difflineminus">-{</span>
<a href="#l7.1503"></a><span id="l7.1503" class="difflineminus">-  if (m_shellList-&gt;Length() &lt; 1)</span>
<a href="#l7.1504"></a><span id="l7.1504" class="difflineminus">-    return false;</span>
<a href="#l7.1505"></a><span id="l7.1505" class="difflineplus">+bool nsIMAPBodyShellCache::EjectEntry() {</span>
<a href="#l7.1506"></a><span id="l7.1506" class="difflineplus">+  if (m_shellList-&gt;Length() &lt; 1) return false;</span>
<a href="#l7.1507"></a><span id="l7.1507"> </span>
<a href="#l7.1508"></a><span id="l7.1508">   nsIMAPBodyShell *removedShell = m_shellList-&gt;ElementAt(0);</span>
<a href="#l7.1509"></a><span id="l7.1509"> </span>
<a href="#l7.1510"></a><span id="l7.1510">   m_shellList-&gt;RemoveElementAt(0);</span>
<a href="#l7.1511"></a><span id="l7.1511">   m_shellHash.Remove(removedShell-&gt;GetUID());</span>
<a href="#l7.1512"></a><span id="l7.1512"> </span>
<a href="#l7.1513"></a><span id="l7.1513">   return true;</span>
<a href="#l7.1514"></a><span id="l7.1514"> }</span>
<a href="#l7.1515"></a><span id="l7.1515"> </span>
<a href="#l7.1516"></a><span id="l7.1516" class="difflineminus">-void nsIMAPBodyShellCache::Clear()</span>
<a href="#l7.1517"></a><span id="l7.1517" class="difflineminus">-{</span>
<a href="#l7.1518"></a><span id="l7.1518" class="difflineminus">-  while (EjectEntry()) ;</span>
<a href="#l7.1519"></a><span id="l7.1519" class="difflineplus">+void nsIMAPBodyShellCache::Clear() {</span>
<a href="#l7.1520"></a><span id="l7.1520" class="difflineplus">+  while (EjectEntry())</span>
<a href="#l7.1521"></a><span id="l7.1521" class="difflineplus">+    ;</span>
<a href="#l7.1522"></a><span id="l7.1522"> }</span>
<a href="#l7.1523"></a><span id="l7.1523"> </span>
<a href="#l7.1524"></a><span id="l7.1524" class="difflineminus">-bool nsIMAPBodyShellCache::AddShellToCache(nsIMAPBodyShell *shell)</span>
<a href="#l7.1525"></a><span id="l7.1525" class="difflineminus">-{</span>
<a href="#l7.1526"></a><span id="l7.1526" class="difflineplus">+bool nsIMAPBodyShellCache::AddShellToCache(nsIMAPBodyShell *shell) {</span>
<a href="#l7.1527"></a><span id="l7.1527">   // If it's already in the cache, then just return.</span>
<a href="#l7.1528"></a><span id="l7.1528">   // This has the side-effect of re-ordering the LRU list</span>
<a href="#l7.1529"></a><span id="l7.1529">   // to put this at the top, which is good, because it's what we want.</span>
<a href="#l7.1530"></a><span id="l7.1530" class="difflineminus">-  if (FindShellForUID(shell-&gt;GetUID_validity(), shell-&gt;GetFolderName(), shell-&gt;GetContentModified()))</span>
<a href="#l7.1531"></a><span id="l7.1531" class="difflineplus">+  if (FindShellForUID(shell-&gt;GetUID_validity(), shell-&gt;GetFolderName(),</span>
<a href="#l7.1532"></a><span id="l7.1532" class="difflineplus">+                      shell-&gt;GetContentModified()))</span>
<a href="#l7.1533"></a><span id="l7.1533">     return true;</span>
<a href="#l7.1534"></a><span id="l7.1534"> </span>
<a href="#l7.1535"></a><span id="l7.1535">   // OK, so it's not in the cache currently.</span>
<a href="#l7.1536"></a><span id="l7.1536"> </span>
<a href="#l7.1537"></a><span id="l7.1537">   // First, for safety sake, remove any entry with the given UID,</span>
<a href="#l7.1538"></a><span id="l7.1538">   // just in case we have a collision between two messages in different</span>
<a href="#l7.1539"></a><span id="l7.1539">   // folders with the same UID.</span>
<a href="#l7.1540"></a><span id="l7.1540">   RefPtr&lt;nsIMAPBodyShell&gt; foundShell;</span>
<a href="#l7.1541"></a><span id="l7.1541">   m_shellHash.Get(shell-&gt;GetUID_validity(), getter_AddRefs(foundShell));</span>
<a href="#l7.1542"></a><span id="l7.1542" class="difflineminus">-  if (foundShell)</span>
<a href="#l7.1543"></a><span id="l7.1543" class="difflineminus">-  {</span>
<a href="#l7.1544"></a><span id="l7.1544" class="difflineplus">+  if (foundShell) {</span>
<a href="#l7.1545"></a><span id="l7.1545">     m_shellHash.Remove(foundShell-&gt;GetUID_validity());</span>
<a href="#l7.1546"></a><span id="l7.1546">     m_shellList-&gt;RemoveElement(foundShell);</span>
<a href="#l7.1547"></a><span id="l7.1547">   }</span>
<a href="#l7.1548"></a><span id="l7.1548"> </span>
<a href="#l7.1549"></a><span id="l7.1549">   // Add the new one to the cache</span>
<a href="#l7.1550"></a><span id="l7.1550">   m_shellList-&gt;AppendElement(shell);</span>
<a href="#l7.1551"></a><span id="l7.1551"> </span>
<a href="#l7.1552"></a><span id="l7.1552">   m_shellHash.Put(shell-&gt;GetUID_validity(), shell);</span>
<a href="#l7.1553"></a><span id="l7.1553">   shell-&gt;SetIsCached(true);</span>
<a href="#l7.1554"></a><span id="l7.1554"> </span>
<a href="#l7.1555"></a><span id="l7.1555">   // while we're not over our size limit, eject entries</span>
<a href="#l7.1556"></a><span id="l7.1556">   bool rv = true;</span>
<a href="#l7.1557"></a><span id="l7.1557" class="difflineminus">-  while (GetSize() &gt; GetMaxSize())</span>
<a href="#l7.1558"></a><span id="l7.1558" class="difflineminus">-    rv = EjectEntry();</span>
<a href="#l7.1559"></a><span id="l7.1559" class="difflineplus">+  while (GetSize() &gt; GetMaxSize()) rv = EjectEntry();</span>
<a href="#l7.1560"></a><span id="l7.1560"> </span>
<a href="#l7.1561"></a><span id="l7.1561">   return rv;</span>
<a href="#l7.1562"></a><span id="l7.1562" class="difflineminus">-</span>
<a href="#l7.1563"></a><span id="l7.1563"> }</span>
<a href="#l7.1564"></a><span id="l7.1564"> </span>
<a href="#l7.1565"></a><span id="l7.1565" class="difflineminus">-nsIMAPBodyShell *nsIMAPBodyShellCache::FindShellForUID(nsCString &amp;UID, const char *mailboxName,</span>
<a href="#l7.1566"></a><span id="l7.1566" class="difflineminus">-                                                       IMAP_ContentModifiedType modType)</span>
<a href="#l7.1567"></a><span id="l7.1567" class="difflineminus">-{</span>
<a href="#l7.1568"></a><span id="l7.1568" class="difflineplus">+nsIMAPBodyShell *nsIMAPBodyShellCache::FindShellForUID(</span>
<a href="#l7.1569"></a><span id="l7.1569" class="difflineplus">+    nsCString &amp;UID, const char *mailboxName, IMAP_ContentModifiedType modType) {</span>
<a href="#l7.1570"></a><span id="l7.1570">   RefPtr&lt;nsIMAPBodyShell&gt; foundShell;</span>
<a href="#l7.1571"></a><span id="l7.1571">   m_shellHash.Get(UID, getter_AddRefs(foundShell));</span>
<a href="#l7.1572"></a><span id="l7.1572" class="difflineminus">-  if (!foundShell)</span>
<a href="#l7.1573"></a><span id="l7.1573" class="difflineminus">-    return nullptr;</span>
<a href="#l7.1574"></a><span id="l7.1574" class="difflineplus">+  if (!foundShell) return nullptr;</span>
<a href="#l7.1575"></a><span id="l7.1575">   // Make sure the content-modified types are compatible.</span>
<a href="#l7.1576"></a><span id="l7.1576">   // This allows us to work seamlessly while people switch between</span>
<a href="#l7.1577"></a><span id="l7.1577">   // View Attachments Inline and View Attachments As Links.</span>
<a href="#l7.1578"></a><span id="l7.1578">   // Enforce the invariant that any cached shell we use</span>
<a href="#l7.1579"></a><span id="l7.1579">   // match the current content-modified settings.</span>
<a href="#l7.1580"></a><span id="l7.1580" class="difflineminus">-  if (modType != foundShell-&gt;GetContentModified())</span>
<a href="#l7.1581"></a><span id="l7.1581" class="difflineminus">-    return nullptr;</span>
<a href="#l7.1582"></a><span id="l7.1582" class="difflineplus">+  if (modType != foundShell-&gt;GetContentModified()) return nullptr;</span>
<a href="#l7.1583"></a><span id="l7.1583"> </span>
<a href="#l7.1584"></a><span id="l7.1584">   // mailbox names must match also.</span>
<a href="#l7.1585"></a><span id="l7.1585" class="difflineminus">-  if (PL_strcmp(mailboxName, foundShell-&gt;GetFolderName()))</span>
<a href="#l7.1586"></a><span id="l7.1586" class="difflineminus">-    return nullptr;</span>
<a href="#l7.1587"></a><span id="l7.1587" class="difflineplus">+  if (PL_strcmp(mailboxName, foundShell-&gt;GetFolderName())) return nullptr;</span>
<a href="#l7.1588"></a><span id="l7.1588"> </span>
<a href="#l7.1589"></a><span id="l7.1589">   // adjust the LRU stuff. This defeats the performance gain of the hash if</span>
<a href="#l7.1590"></a><span id="l7.1590">   // it actually is found since this is linear.</span>
<a href="#l7.1591"></a><span id="l7.1591">   m_shellList-&gt;RemoveElement(foundShell);</span>
<a href="#l7.1592"></a><span id="l7.1592" class="difflineminus">-  m_shellList-&gt;AppendElement(foundShell);// Adds to end</span>
<a href="#l7.1593"></a><span id="l7.1593" class="difflineplus">+  m_shellList-&gt;AppendElement(foundShell);  // Adds to end</span>
<a href="#l7.1594"></a><span id="l7.1594"> </span>
<a href="#l7.1595"></a><span id="l7.1595">   return foundShell;</span>
<a href="#l7.1596"></a><span id="l7.1596"> }</span>
<a href="#l7.1597"></a><span id="l7.1597"> </span>
<a href="#l7.1598"></a><span id="l7.1598"> ///////////// nsIMAPMessagePartID ////////////////////////////////////</span>
<a href="#l7.1599"></a><span id="l7.1599"> </span>
<a href="#l7.1600"></a><span id="l7.1600" class="difflineminus">-nsIMAPMessagePartID::nsIMAPMessagePartID(nsIMAPeFetchFields fields, const char *partNumberString)</span>
<a href="#l7.1601"></a><span id="l7.1601" class="difflineminus">-: m_partNumberString(partNumberString),</span>
<a href="#l7.1602"></a><span id="l7.1602" class="difflineminus">-  m_fields(fields)</span>
<a href="#l7.1603"></a><span id="l7.1603" class="difflineminus">-{</span>
<a href="#l7.1604"></a><span id="l7.1604" class="difflineminus">-}</span>
<a href="#l7.1605"></a><span id="l7.1605" class="difflineplus">+nsIMAPMessagePartID::nsIMAPMessagePartID(nsIMAPeFetchFields fields,</span>
<a href="#l7.1606"></a><span id="l7.1606" class="difflineplus">+                                         const char *partNumberString)</span>
<a href="#l7.1607"></a><span id="l7.1607" class="difflineplus">+    : m_partNumberString(partNumberString), m_fields(fields) {}</span>
<a href="#l7.1608"></a><span id="l7.1608"> </span>
<a href="#l7.1609"></a><span id="l7.1609" class="difflineminus">-nsIMAPMessagePartIDArray::nsIMAPMessagePartIDArray()</span>
<a href="#l7.1610"></a><span id="l7.1610" class="difflineminus">-{</span>
<a href="#l7.1611"></a><span id="l7.1611" class="difflineminus">-}</span>
<a href="#l7.1612"></a><span id="l7.1612" class="difflineplus">+nsIMAPMessagePartIDArray::nsIMAPMessagePartIDArray() {}</span>
<a href="#l7.1613"></a><span id="l7.1613"> </span>
<a href="#l7.1614"></a><span id="l7.1614" class="difflineminus">-nsIMAPMessagePartIDArray::~nsIMAPMessagePartIDArray()</span>
<a href="#l7.1615"></a><span id="l7.1615" class="difflineminus">-{</span>
<a href="#l7.1616"></a><span id="l7.1616" class="difflineminus">-  RemoveAndFreeAll();</span>
<a href="#l7.1617"></a><span id="l7.1617" class="difflineminus">-}</span>
<a href="#l7.1618"></a><span id="l7.1618" class="difflineplus">+nsIMAPMessagePartIDArray::~nsIMAPMessagePartIDArray() { RemoveAndFreeAll(); }</span>
<a href="#l7.1619"></a><span id="l7.1619"> </span>
<a href="#l7.1620"></a><span id="l7.1620" class="difflineminus">-void nsIMAPMessagePartIDArray::RemoveAndFreeAll()</span>
<a href="#l7.1621"></a><span id="l7.1621" class="difflineminus">-{</span>
<a href="#l7.1622"></a><span id="l7.1622" class="difflineplus">+void nsIMAPMessagePartIDArray::RemoveAndFreeAll() {</span>
<a href="#l7.1623"></a><span id="l7.1623">   uint32_t n = Length();</span>
<a href="#l7.1624"></a><span id="l7.1624" class="difflineminus">-  for (uint32_t i = 0; i &lt; n; i++)</span>
<a href="#l7.1625"></a><span id="l7.1625" class="difflineminus">-  {</span>
<a href="#l7.1626"></a><span id="l7.1626" class="difflineminus">-     nsIMAPMessagePartID *part = GetPart(i);</span>
<a href="#l7.1627"></a><span id="l7.1627" class="difflineminus">-     delete part;</span>
<a href="#l7.1628"></a><span id="l7.1628" class="difflineplus">+  for (uint32_t i = 0; i &lt; n; i++) {</span>
<a href="#l7.1629"></a><span id="l7.1629" class="difflineplus">+    nsIMAPMessagePartID *part = GetPart(i);</span>
<a href="#l7.1630"></a><span id="l7.1630" class="difflineplus">+    delete part;</span>
<a href="#l7.1631"></a><span id="l7.1631">   }</span>
<a href="#l7.1632"></a><span id="l7.1632">   Clear();</span>
<a href="#l7.1633"></a><span id="l7.1633"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPBodyShell.h</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPBodyShell.h</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -23,195 +23,218 @@ typedef enum _nsIMAPBodypartType {</span>
<a href="#l8.4"></a><span id="l8.4">   IMAP_BODY_MESSAGE_HEADER,</span>
<a href="#l8.5"></a><span id="l8.5">   IMAP_BODY_LEAF,</span>
<a href="#l8.6"></a><span id="l8.6">   IMAP_BODY_MULTIPART</span>
<a href="#l8.7"></a><span id="l8.7"> } nsIMAPBodypartType;</span>
<a href="#l8.8"></a><span id="l8.8"> </span>
<a href="#l8.9"></a><span id="l8.9"> class nsIMAPBodyShell;</span>
<a href="#l8.10"></a><span id="l8.10"> class nsIMAPBodypartMessage;</span>
<a href="#l8.11"></a><span id="l8.11"> </span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-class nsIMAPBodypart</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineminus">-{</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineminus">-public:</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+class nsIMAPBodypart {</span>
<a href="#l8.16"></a><span id="l8.16" class="difflineplus">+ public:</span>
<a href="#l8.17"></a><span id="l8.17">   // Construction</span>
<a href="#l8.18"></a><span id="l8.18">   virtual bool GetIsValid() { return m_isValid; }</span>
<a href="#l8.19"></a><span id="l8.19">   virtual void SetIsValid(bool valid);</span>
<a href="#l8.20"></a><span id="l8.20">   virtual nsIMAPBodypartType GetType() = 0;</span>
<a href="#l8.21"></a><span id="l8.21"> </span>
<a href="#l8.22"></a><span id="l8.22">   // Generation</span>
<a href="#l8.23"></a><span id="l8.23" class="difflineminus">-  // Generates an HTML representation of this part.  Returns content length generated, -1 if failed.</span>
<a href="#l8.24"></a><span id="l8.24" class="difflineminus">-  virtual int32_t Generate(nsIMAPBodyShell *aShell, bool /*stream*/, bool /* prefetch */) { return -1; }</span>
<a href="#l8.25"></a><span id="l8.25" class="difflineminus">-  virtual void AdoptPartDataBuffer(char *buf);    // Adopts storage for part data buffer.  If NULL, sets isValid to false.</span>
<a href="#l8.26"></a><span id="l8.26" class="difflineminus">-  virtual void AdoptHeaderDataBuffer(char *buf);  // Adopts storage for header data buffer.  If NULL, sets isValid to false.</span>
<a href="#l8.27"></a><span id="l8.27" class="difflineminus">-  virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) { return true; }  // returns true if this part should be fetched inline for generation.</span>
<a href="#l8.28"></a><span id="l8.28" class="difflineplus">+  // Generates an HTML representation of this part.  Returns content length</span>
<a href="#l8.29"></a><span id="l8.29" class="difflineplus">+  // generated, -1 if failed.</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineplus">+  virtual int32_t Generate(nsIMAPBodyShell *aShell, bool /*stream*/,</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineplus">+                           bool /* prefetch */) {</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+    return -1;</span>
<a href="#l8.33"></a><span id="l8.33" class="difflineplus">+  }</span>
<a href="#l8.34"></a><span id="l8.34" class="difflineplus">+  virtual void AdoptPartDataBuffer(</span>
<a href="#l8.35"></a><span id="l8.35" class="difflineplus">+      char *buf);  // Adopts storage for part data buffer.  If NULL, sets</span>
<a href="#l8.36"></a><span id="l8.36" class="difflineplus">+                   // isValid to false.</span>
<a href="#l8.37"></a><span id="l8.37" class="difflineplus">+  virtual void AdoptHeaderDataBuffer(</span>
<a href="#l8.38"></a><span id="l8.38" class="difflineplus">+      char *buf);  // Adopts storage for header data buffer.  If NULL, sets</span>
<a href="#l8.39"></a><span id="l8.39" class="difflineplus">+                   // isValid to false.</span>
<a href="#l8.40"></a><span id="l8.40" class="difflineplus">+  virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) {</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineplus">+    return true;</span>
<a href="#l8.42"></a><span id="l8.42" class="difflineplus">+  }  // returns true if this part should be fetched inline for generation.</span>
<a href="#l8.43"></a><span id="l8.43">   virtual bool PreflightCheckAllInline(nsIMAPBodyShell *aShell) { return true; }</span>
<a href="#l8.44"></a><span id="l8.44"> </span>
<a href="#l8.45"></a><span id="l8.45">   virtual bool ShouldExplicitlyFetchInline();</span>
<a href="#l8.46"></a><span id="l8.46">   virtual bool ShouldExplicitlyNotFetchInline();</span>
<a href="#l8.47"></a><span id="l8.47" class="difflineminus">-  virtual bool IsLastTextPart(const char *partNumberString) {return true;}</span>
<a href="#l8.48"></a><span id="l8.48" class="difflineplus">+  virtual bool IsLastTextPart(const char *partNumberString) { return true; }</span>
<a href="#l8.49"></a><span id="l8.49"> </span>
<a href="#l8.50"></a><span id="l8.50" class="difflineminus">-protected:</span>
<a href="#l8.51"></a><span id="l8.51" class="difflineminus">-  // If stream is false, simply returns the content length that will be generated</span>
<a href="#l8.52"></a><span id="l8.52" class="difflineminus">-  // the body of the part itself</span>
<a href="#l8.53"></a><span id="l8.53" class="difflineminus">-  virtual int32_t GeneratePart(nsIMAPBodyShell *aShell, bool stream, bool prefetch);</span>
<a href="#l8.54"></a><span id="l8.54" class="difflineplus">+ protected:</span>
<a href="#l8.55"></a><span id="l8.55" class="difflineplus">+  // If stream is false, simply returns the content length that will be</span>
<a href="#l8.56"></a><span id="l8.56" class="difflineplus">+  // generated the body of the part itself</span>
<a href="#l8.57"></a><span id="l8.57" class="difflineplus">+  virtual int32_t GeneratePart(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l8.58"></a><span id="l8.58" class="difflineplus">+                               bool prefetch);</span>
<a href="#l8.59"></a><span id="l8.59">   // the MIME headers of the part</span>
<a href="#l8.60"></a><span id="l8.60" class="difflineminus">-  virtual int32_t GenerateMIMEHeader(nsIMAPBodyShell *aShell, bool stream, bool prefetch);</span>
<a href="#l8.61"></a><span id="l8.61" class="difflineplus">+  virtual int32_t GenerateMIMEHeader(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l8.62"></a><span id="l8.62" class="difflineplus">+                                     bool prefetch);</span>
<a href="#l8.63"></a><span id="l8.63">   // Generates the MIME boundary wrapper for this part.</span>
<a href="#l8.64"></a><span id="l8.64" class="difflineminus">-  virtual int32_t GenerateBoundary(nsIMAPBodyShell *aShell, bool stream, bool prefetch, bool lastBoundary);</span>
<a href="#l8.65"></a><span id="l8.65" class="difflineplus">+  virtual int32_t GenerateBoundary(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l8.66"></a><span id="l8.66" class="difflineplus">+                                   bool prefetch, bool lastBoundary);</span>
<a href="#l8.67"></a><span id="l8.67">   // lastBoundary indicates whether or not this should be the boundary for the</span>
<a href="#l8.68"></a><span id="l8.68">   // final MIME part of the multipart message.</span>
<a href="#l8.69"></a><span id="l8.69" class="difflineminus">-  // Generates (possibly empty) filling for a part that won't be filled in inline.</span>
<a href="#l8.70"></a><span id="l8.70" class="difflineminus">-  virtual int32_t GenerateEmptyFilling(nsIMAPBodyShell *aShell, bool stream, bool prefetch);</span>
<a href="#l8.71"></a><span id="l8.71" class="difflineplus">+  // Generates (possibly empty) filling for a part that won't be filled in</span>
<a href="#l8.72"></a><span id="l8.72" class="difflineplus">+  // inline.</span>
<a href="#l8.73"></a><span id="l8.73" class="difflineplus">+  virtual int32_t GenerateEmptyFilling(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l8.74"></a><span id="l8.74" class="difflineplus">+                                       bool prefetch);</span>
<a href="#l8.75"></a><span id="l8.75"> </span>
<a href="#l8.76"></a><span id="l8.76">   // Part Numbers / Hierarchy</span>
<a href="#l8.77"></a><span id="l8.77" class="difflineminus">-public:</span>
<a href="#l8.78"></a><span id="l8.78" class="difflineplus">+ public:</span>
<a href="#l8.79"></a><span id="l8.79">   virtual char *GetPartNumberString() { return m_partNumberString; }</span>
<a href="#l8.80"></a><span id="l8.80" class="difflineminus">-  virtual nsIMAPBodypart *FindPartWithNumber(const char *partNum);  // Returns the part object with the given number</span>
<a href="#l8.81"></a><span id="l8.81" class="difflineminus">-  virtual nsIMAPBodypart *GetParentPart() { return m_parentPart; }  // Returns the parent of this part.</span>
<a href="#l8.82"></a><span id="l8.82" class="difflineminus">-                                                                    // We will define a part of type message/rfc822 to be the</span>
<a href="#l8.83"></a><span id="l8.83" class="difflineminus">-                                                                    // parent of its body and header.</span>
<a href="#l8.84"></a><span id="l8.84" class="difflineminus">-                                                                    // A multipart is a parent of its child parts.</span>
<a href="#l8.85"></a><span id="l8.85" class="difflineminus">-                                                                    // All other leafs do not have children.</span>
<a href="#l8.86"></a><span id="l8.86" class="difflineplus">+  virtual nsIMAPBodypart *FindPartWithNumber(</span>
<a href="#l8.87"></a><span id="l8.87" class="difflineplus">+      const char *partNum);  // Returns the part object with the given number</span>
<a href="#l8.88"></a><span id="l8.88" class="difflineplus">+  virtual nsIMAPBodypart *GetParentPart() {</span>
<a href="#l8.89"></a><span id="l8.89" class="difflineplus">+    return m_parentPart;</span>
<a href="#l8.90"></a><span id="l8.90" class="difflineplus">+  }  // Returns the parent of this part.</span>
<a href="#l8.91"></a><span id="l8.91" class="difflineplus">+     // We will define a part of type message/rfc822 to be the</span>
<a href="#l8.92"></a><span id="l8.92" class="difflineplus">+     // parent of its body and header.</span>
<a href="#l8.93"></a><span id="l8.93" class="difflineplus">+     // A multipart is a parent of its child parts.</span>
<a href="#l8.94"></a><span id="l8.94" class="difflineplus">+     // All other leafs do not have children.</span>
<a href="#l8.95"></a><span id="l8.95"> </span>
<a href="#l8.96"></a><span id="l8.96">   // Other / Helpers</span>
<a href="#l8.97"></a><span id="l8.97" class="difflineminus">-public:</span>
<a href="#l8.98"></a><span id="l8.98" class="difflineplus">+ public:</span>
<a href="#l8.99"></a><span id="l8.99">   virtual ~nsIMAPBodypart();</span>
<a href="#l8.100"></a><span id="l8.100" class="difflineminus">-  virtual nsIMAPBodypartMessage  *GetnsIMAPBodypartMessage() { return NULL; }</span>
<a href="#l8.101"></a><span id="l8.101" class="difflineplus">+  virtual nsIMAPBodypartMessage *GetnsIMAPBodypartMessage() { return NULL; }</span>
<a href="#l8.102"></a><span id="l8.102"> </span>
<a href="#l8.103"></a><span id="l8.103">   const char *GetBodyType() { return m_bodyType; }</span>
<a href="#l8.104"></a><span id="l8.104">   const char *GetBodySubType() { return m_bodySubType; }</span>
<a href="#l8.105"></a><span id="l8.105">   void SetBoundaryData(char *boundaryData) { m_boundaryData = boundaryData; }</span>
<a href="#l8.106"></a><span id="l8.106"> </span>
<a href="#l8.107"></a><span id="l8.107" class="difflineminus">-protected:</span>
<a href="#l8.108"></a><span id="l8.108" class="difflineplus">+ protected:</span>
<a href="#l8.109"></a><span id="l8.109">   virtual void QueuePrefetchMIMEHeader(nsIMAPBodyShell *aShell);</span>
<a href="#l8.110"></a><span id="l8.110" class="difflineminus">-  //virtual void  PrefetchMIMEHeader();  // Initiates a prefetch for the MIME header of this part.</span>
<a href="#l8.111"></a><span id="l8.111" class="difflineplus">+  // virtual void  PrefetchMIMEHeader();  // Initiates a prefetch for the MIME</span>
<a href="#l8.112"></a><span id="l8.112" class="difflineplus">+  // header of this part.</span>
<a href="#l8.113"></a><span id="l8.113">   nsIMAPBodypart(char *partNumber, nsIMAPBodypart *parentPart);</span>
<a href="#l8.114"></a><span id="l8.114"> </span>
<a href="#l8.115"></a><span id="l8.115" class="difflineminus">-protected:</span>
<a href="#l8.116"></a><span id="l8.116" class="difflineplus">+ protected:</span>
<a href="#l8.117"></a><span id="l8.117">   bool m_isValid;            // If this part is valid.</span>
<a href="#l8.118"></a><span id="l8.118" class="difflineminus">-  char *m_partNumberString;  // string representation of this part's full-hierarchy number.  Define 0 to be the top-level message</span>
<a href="#l8.119"></a><span id="l8.119" class="difflineplus">+  char *m_partNumberString;  // string representation of this part's</span>
<a href="#l8.120"></a><span id="l8.120" class="difflineplus">+                             // full-hierarchy number.  Define 0 to be the</span>
<a href="#l8.121"></a><span id="l8.121" class="difflineplus">+                             // top-level message</span>
<a href="#l8.122"></a><span id="l8.122">   char *m_partData;          // data for this part.  NULL if not filled in yet.</span>
<a href="#l8.123"></a><span id="l8.123" class="difflineminus">-  char *m_headerData;        // data for this part's MIME header.  NULL if not filled in yet.</span>
<a href="#l8.124"></a><span id="l8.124" class="difflineminus">-  char *m_boundaryData;      // MIME boundary for this part</span>
<a href="#l8.125"></a><span id="l8.125" class="difflineplus">+  char *m_headerData;  // data for this part's MIME header.  NULL if not filled</span>
<a href="#l8.126"></a><span id="l8.126" class="difflineplus">+                       // in yet.</span>
<a href="#l8.127"></a><span id="l8.127" class="difflineplus">+  char *m_boundaryData;  // MIME boundary for this part</span>
<a href="#l8.128"></a><span id="l8.128">   int32_t m_partLength;</span>
<a href="#l8.129"></a><span id="l8.129" class="difflineminus">-  int32_t m_contentLength;   // Total content length which will be Generate()'d.  -1 if not filled in yet.</span>
<a href="#l8.130"></a><span id="l8.130" class="difflineplus">+  int32_t m_contentLength;  // Total content length which will be Generate()'d.</span>
<a href="#l8.131"></a><span id="l8.131" class="difflineplus">+                            // -1 if not filled in yet.</span>
<a href="#l8.132"></a><span id="l8.132">   nsIMAPBodypart *m_parentPart;  // Parent of this part</span>
<a href="#l8.133"></a><span id="l8.133"> </span>
<a href="#l8.134"></a><span id="l8.134">   // Fields - Filled in from parsed BODYSTRUCTURE response (as well as others)</span>
<a href="#l8.135"></a><span id="l8.135">   char *m_contentType;  // constructed from m_bodyType and m_bodySubType</span>
<a href="#l8.136"></a><span id="l8.136">   char *m_bodyType;</span>
<a href="#l8.137"></a><span id="l8.137">   char *m_bodySubType;</span>
<a href="#l8.138"></a><span id="l8.138">   char *m_bodyID;</span>
<a href="#l8.139"></a><span id="l8.139">   char *m_bodyDescription;</span>
<a href="#l8.140"></a><span id="l8.140">   char *m_bodyEncoding;</span>
<a href="#l8.141"></a><span id="l8.141">   // we ignore extension data for now</span>
<a href="#l8.142"></a><span id="l8.142"> };</span>
<a href="#l8.143"></a><span id="l8.143"> </span>
<a href="#l8.144"></a><span id="l8.144" class="difflineminus">-</span>
<a href="#l8.145"></a><span id="l8.145"> // Message headers</span>
<a href="#l8.146"></a><span id="l8.146"> // A special type of nsIMAPBodypart</span>
<a href="#l8.147"></a><span id="l8.147"> // These may be headers for the top-level message,</span>
<a href="#l8.148"></a><span id="l8.148"> // or any body part of type message/rfc822.</span>
<a href="#l8.149"></a><span id="l8.149" class="difflineminus">-class nsIMAPMessageHeaders : public nsIMAPBodypart</span>
<a href="#l8.150"></a><span id="l8.150" class="difflineminus">-{</span>
<a href="#l8.151"></a><span id="l8.151" class="difflineminus">-public:</span>
<a href="#l8.152"></a><span id="l8.152" class="difflineplus">+class nsIMAPMessageHeaders : public nsIMAPBodypart {</span>
<a href="#l8.153"></a><span id="l8.153" class="difflineplus">+ public:</span>
<a href="#l8.154"></a><span id="l8.154">   nsIMAPMessageHeaders(char *partNum, nsIMAPBodypart *parentPart);</span>
<a href="#l8.155"></a><span id="l8.155" class="difflineminus">-  virtual nsIMAPBodypartType  GetType() override;</span>
<a href="#l8.156"></a><span id="l8.156" class="difflineminus">-  // Generates an HTML representation of this part.  Returns content length generated, -1 if failed.</span>
<a href="#l8.157"></a><span id="l8.157" class="difflineminus">-  virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch) override;</span>
<a href="#l8.158"></a><span id="l8.158" class="difflineplus">+  virtual nsIMAPBodypartType GetType() override;</span>
<a href="#l8.159"></a><span id="l8.159" class="difflineplus">+  // Generates an HTML representation of this part.  Returns content length</span>
<a href="#l8.160"></a><span id="l8.160" class="difflineplus">+  // generated, -1 if failed.</span>
<a href="#l8.161"></a><span id="l8.161" class="difflineplus">+  virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l8.162"></a><span id="l8.162" class="difflineplus">+                           bool prefetch) override;</span>
<a href="#l8.163"></a><span id="l8.163">   virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l8.164"></a><span id="l8.164">   virtual void QueuePrefetchMessageHeaders(nsIMAPBodyShell *aShell);</span>
<a href="#l8.165"></a><span id="l8.165"> };</span>
<a href="#l8.166"></a><span id="l8.166"> </span>
<a href="#l8.167"></a><span id="l8.167" class="difflineminus">-</span>
<a href="#l8.168"></a><span id="l8.168" class="difflineminus">-class nsIMAPBodypartMultipart : public nsIMAPBodypart</span>
<a href="#l8.169"></a><span id="l8.169" class="difflineminus">-{</span>
<a href="#l8.170"></a><span id="l8.170" class="difflineminus">-public:</span>
<a href="#l8.171"></a><span id="l8.171" class="difflineplus">+class nsIMAPBodypartMultipart : public nsIMAPBodypart {</span>
<a href="#l8.172"></a><span id="l8.172" class="difflineplus">+ public:</span>
<a href="#l8.173"></a><span id="l8.173">   nsIMAPBodypartMultipart(char *partNum, nsIMAPBodypart *parentPart);</span>
<a href="#l8.174"></a><span id="l8.174">   virtual nsIMAPBodypartType GetType() override;</span>
<a href="#l8.175"></a><span id="l8.175">   virtual ~nsIMAPBodypartMultipart();</span>
<a href="#l8.176"></a><span id="l8.176">   virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l8.177"></a><span id="l8.177">   virtual bool PreflightCheckAllInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l8.178"></a><span id="l8.178" class="difflineminus">-  // Generates an HTML representation of this part.  Returns content length generated, -1 if failed.</span>
<a href="#l8.179"></a><span id="l8.179" class="difflineminus">-  virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch) override;</span>
<a href="#l8.180"></a><span id="l8.180" class="difflineminus">-    // Returns the part object with the given number</span>
<a href="#l8.181"></a><span id="l8.181" class="difflineplus">+  // Generates an HTML representation of this part.  Returns content length</span>
<a href="#l8.182"></a><span id="l8.182" class="difflineplus">+  // generated, -1 if failed.</span>
<a href="#l8.183"></a><span id="l8.183" class="difflineplus">+  virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l8.184"></a><span id="l8.184" class="difflineplus">+                           bool prefetch) override;</span>
<a href="#l8.185"></a><span id="l8.185" class="difflineplus">+  // Returns the part object with the given number</span>
<a href="#l8.186"></a><span id="l8.186">   virtual nsIMAPBodypart *FindPartWithNumber(const char *partNum) override;</span>
<a href="#l8.187"></a><span id="l8.187">   virtual bool IsLastTextPart(const char *partNumberString) override;</span>
<a href="#l8.188"></a><span id="l8.188">   void AppendPart(nsIMAPBodypart *part) { m_partList-&gt;AppendElement(part); }</span>
<a href="#l8.189"></a><span id="l8.189">   void SetBodySubType(char *bodySubType);</span>
<a href="#l8.190"></a><span id="l8.190"> </span>
<a href="#l8.191"></a><span id="l8.191" class="difflineminus">-protected:</span>
<a href="#l8.192"></a><span id="l8.192" class="difflineminus">-    nsTArray&lt;nsIMAPBodypart*&gt;  *m_partList;  // An ordered list of top-level body parts for this shell</span>
<a href="#l8.193"></a><span id="l8.193" class="difflineplus">+ protected:</span>
<a href="#l8.194"></a><span id="l8.194" class="difflineplus">+  nsTArray&lt;nsIMAPBodypart *&gt;</span>
<a href="#l8.195"></a><span id="l8.195" class="difflineplus">+      *m_partList;  // An ordered list of top-level body parts for this shell</span>
<a href="#l8.196"></a><span id="l8.196"> };</span>
<a href="#l8.197"></a><span id="l8.197"> </span>
<a href="#l8.198"></a><span id="l8.198" class="difflineminus">-</span>
<a href="#l8.199"></a><span id="l8.199" class="difflineminus">-// The name &quot;leaf&quot; is somewhat misleading, since a part of type message/rfc822 is technically</span>
<a href="#l8.200"></a><span id="l8.200" class="difflineminus">-// a leaf, even though it can contain other parts within it.</span>
<a href="#l8.201"></a><span id="l8.201" class="difflineminus">-class nsIMAPBodypartLeaf : public nsIMAPBodypart</span>
<a href="#l8.202"></a><span id="l8.202" class="difflineminus">-{</span>
<a href="#l8.203"></a><span id="l8.203" class="difflineminus">-public:</span>
<a href="#l8.204"></a><span id="l8.204" class="difflineplus">+// The name &quot;leaf&quot; is somewhat misleading, since a part of type message/rfc822</span>
<a href="#l8.205"></a><span id="l8.205" class="difflineplus">+// is technically a leaf, even though it can contain other parts within it.</span>
<a href="#l8.206"></a><span id="l8.206" class="difflineplus">+class nsIMAPBodypartLeaf : public nsIMAPBodypart {</span>
<a href="#l8.207"></a><span id="l8.207" class="difflineplus">+ public:</span>
<a href="#l8.208"></a><span id="l8.208">   nsIMAPBodypartLeaf(char *partNum, nsIMAPBodypart *parentPart, char *bodyType,</span>
<a href="#l8.209"></a><span id="l8.209">                      char *bodySubType, char *bodyID, char *bodyDescription,</span>
<a href="#l8.210"></a><span id="l8.210">                      char *bodyEncoding, int32_t partLength,</span>
<a href="#l8.211"></a><span id="l8.211">                      bool preferPlainText);</span>
<a href="#l8.212"></a><span id="l8.212" class="difflineminus">-  virtual nsIMAPBodypartType  GetType() override;</span>
<a href="#l8.213"></a><span id="l8.213" class="difflineminus">-  // Generates an HTML representation of this part.  Returns content length generated, -1 if failed.</span>
<a href="#l8.214"></a><span id="l8.214" class="difflineminus">-  virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch) override;</span>
<a href="#l8.215"></a><span id="l8.215" class="difflineplus">+  virtual nsIMAPBodypartType GetType() override;</span>
<a href="#l8.216"></a><span id="l8.216" class="difflineplus">+  // Generates an HTML representation of this part.  Returns content length</span>
<a href="#l8.217"></a><span id="l8.217" class="difflineplus">+  // generated, -1 if failed.</span>
<a href="#l8.218"></a><span id="l8.218" class="difflineplus">+  virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l8.219"></a><span id="l8.219" class="difflineplus">+                           bool prefetch) override;</span>
<a href="#l8.220"></a><span id="l8.220">   // returns true if this part should be fetched inline for generation.</span>
<a href="#l8.221"></a><span id="l8.221">   virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l8.222"></a><span id="l8.222">   virtual bool PreflightCheckAllInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l8.223"></a><span id="l8.223" class="difflineminus">-private:</span>
<a href="#l8.224"></a><span id="l8.224" class="difflineplus">+</span>
<a href="#l8.225"></a><span id="l8.225" class="difflineplus">+ private:</span>
<a href="#l8.226"></a><span id="l8.226">   bool mPreferPlainText;</span>
<a href="#l8.227"></a><span id="l8.227"> };</span>
<a href="#l8.228"></a><span id="l8.228"> </span>
<a href="#l8.229"></a><span id="l8.229" class="difflineminus">-</span>
<a href="#l8.230"></a><span id="l8.230" class="difflineminus">-class nsIMAPBodypartMessage : public nsIMAPBodypartLeaf</span>
<a href="#l8.231"></a><span id="l8.231" class="difflineminus">-{</span>
<a href="#l8.232"></a><span id="l8.232" class="difflineminus">-public:</span>
<a href="#l8.233"></a><span id="l8.233" class="difflineplus">+class nsIMAPBodypartMessage : public nsIMAPBodypartLeaf {</span>
<a href="#l8.234"></a><span id="l8.234" class="difflineplus">+ public:</span>
<a href="#l8.235"></a><span id="l8.235">   nsIMAPBodypartMessage(char *partNum, nsIMAPBodypart *parentPart,</span>
<a href="#l8.236"></a><span id="l8.236" class="difflineminus">-                        bool topLevelMessage, char *bodyType,</span>
<a href="#l8.237"></a><span id="l8.237" class="difflineminus">-                        char *bodySubType, char *bodyID,</span>
<a href="#l8.238"></a><span id="l8.238" class="difflineminus">-                        char *bodyDescription, char *bodyEncoding,</span>
<a href="#l8.239"></a><span id="l8.239" class="difflineplus">+                        bool topLevelMessage, char *bodyType, char *bodySubType,</span>
<a href="#l8.240"></a><span id="l8.240" class="difflineplus">+                        char *bodyID, char *bodyDescription, char *bodyEncoding,</span>
<a href="#l8.241"></a><span id="l8.241">                         int32_t partLength, bool preferPlainText);</span>
<a href="#l8.242"></a><span id="l8.242">   void SetBody(nsIMAPBodypart *body);</span>
<a href="#l8.243"></a><span id="l8.243" class="difflineminus">-  virtual nsIMAPBodypartType  GetType() override;</span>
<a href="#l8.244"></a><span id="l8.244" class="difflineplus">+  virtual nsIMAPBodypartType GetType() override;</span>
<a href="#l8.245"></a><span id="l8.245">   virtual ~nsIMAPBodypartMessage();</span>
<a href="#l8.246"></a><span id="l8.246">   virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l8.247"></a><span id="l8.247" class="difflineminus">-                             bool prefetch) override;</span>
<a href="#l8.248"></a><span id="l8.248" class="difflineplus">+                           bool prefetch) override;</span>
<a href="#l8.249"></a><span id="l8.249">   virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l8.250"></a><span id="l8.250">   virtual bool PreflightCheckAllInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l8.251"></a><span id="l8.251">   // Returns the part object with the given number</span>
<a href="#l8.252"></a><span id="l8.252" class="difflineminus">-  virtual nsIMAPBodypart  *FindPartWithNumber(const char *partNum) override;</span>
<a href="#l8.253"></a><span id="l8.253" class="difflineminus">-  void  AdoptMessageHeaders(char *headers);  // Fills in buffer (and adopts storage) for header object</span>
<a href="#l8.254"></a><span id="l8.254" class="difflineminus">-                                             // partNum specifies the message part number to which the</span>
<a href="#l8.255"></a><span id="l8.255" class="difflineminus">-                                             // headers correspond.  NULL indicates the top-level message</span>
<a href="#l8.256"></a><span id="l8.256" class="difflineminus">-  virtual nsIMAPBodypartMessage  *GetnsIMAPBodypartMessage() override { return this; }</span>
<a href="#l8.257"></a><span id="l8.257" class="difflineplus">+  virtual nsIMAPBodypart *FindPartWithNumber(const char *partNum) override;</span>
<a href="#l8.258"></a><span id="l8.258" class="difflineplus">+  void AdoptMessageHeaders(</span>
<a href="#l8.259"></a><span id="l8.259" class="difflineplus">+      char *headers);  // Fills in buffer (and adopts storage) for header object</span>
<a href="#l8.260"></a><span id="l8.260" class="difflineplus">+                       // partNum specifies the message part number to which the</span>
<a href="#l8.261"></a><span id="l8.261" class="difflineplus">+                       // headers correspond.  NULL indicates the top-level</span>
<a href="#l8.262"></a><span id="l8.262" class="difflineplus">+                       // message</span>
<a href="#l8.263"></a><span id="l8.263" class="difflineplus">+  virtual nsIMAPBodypartMessage *GetnsIMAPBodypartMessage() override {</span>
<a href="#l8.264"></a><span id="l8.264" class="difflineplus">+    return this;</span>
<a href="#l8.265"></a><span id="l8.265" class="difflineplus">+  }</span>
<a href="#l8.266"></a><span id="l8.266">   virtual bool GetIsTopLevelMessage() { return m_topLevelMessage; }</span>
<a href="#l8.267"></a><span id="l8.267"> </span>
<a href="#l8.268"></a><span id="l8.268" class="difflineminus">-protected:</span>
<a href="#l8.269"></a><span id="l8.269" class="difflineminus">-  nsIMAPMessageHeaders *m_headers;         // Every body shell should have headers</span>
<a href="#l8.270"></a><span id="l8.270" class="difflineminus">-  nsIMAPBodypart       *m_body;</span>
<a href="#l8.271"></a><span id="l8.271" class="difflineminus">-  bool                 m_topLevelMessage;  // Whether or not this is the top-level message</span>
<a href="#l8.272"></a><span id="l8.272" class="difflineminus">-</span>
<a href="#l8.273"></a><span id="l8.273" class="difflineplus">+ protected:</span>
<a href="#l8.274"></a><span id="l8.274" class="difflineplus">+  nsIMAPMessageHeaders *m_headers;  // Every body shell should have headers</span>
<a href="#l8.275"></a><span id="l8.275" class="difflineplus">+  nsIMAPBodypart *m_body;</span>
<a href="#l8.276"></a><span id="l8.276" class="difflineplus">+  bool m_topLevelMessage;  // Whether or not this is the top-level message</span>
<a href="#l8.277"></a><span id="l8.277"> };</span>
<a href="#l8.278"></a><span id="l8.278"> </span>
<a href="#l8.279"></a><span id="l8.279" class="difflineminus">-</span>
<a href="#l8.280"></a><span id="l8.280"> class nsIMAPMessagePartIDArray;</span>
<a href="#l8.281"></a><span id="l8.281"> </span>
<a href="#l8.282"></a><span id="l8.282" class="difflineminus">-// We will refer to a Body &quot;Shell&quot; as a hierarchical object representation of a parsed BODYSTRUCTURE</span>
<a href="#l8.283"></a><span id="l8.283" class="difflineminus">-// response.  A shell contains representations of Shell &quot;Parts.&quot;  A Body Shell can undergo essentially</span>
<a href="#l8.284"></a><span id="l8.284" class="difflineminus">-// two operations: Construction and Generation.</span>
<a href="#l8.285"></a><span id="l8.285" class="difflineminus">-// Shell Construction occurs from a parsed a BODYSTRUCTURE response, split into empty parts.</span>
<a href="#l8.286"></a><span id="l8.286" class="difflineminus">-// Shell Generation generates a &quot;MIME Shell&quot; of the message and streams it to libmime for</span>
<a href="#l8.287"></a><span id="l8.287" class="difflineminus">-// display.  The MIME Shell has selected (inline) parts filled in, and leaves all others</span>
<a href="#l8.288"></a><span id="l8.288" class="difflineminus">-// for on-demand retrieval through explicit part fetches.</span>
<a href="#l8.289"></a><span id="l8.289" class="difflineplus">+// We will refer to a Body &quot;Shell&quot; as a hierarchical object representation of a</span>
<a href="#l8.290"></a><span id="l8.290" class="difflineplus">+// parsed BODYSTRUCTURE response.  A shell contains representations of Shell</span>
<a href="#l8.291"></a><span id="l8.291" class="difflineplus">+// &quot;Parts.&quot;  A Body Shell can undergo essentially two operations: Construction</span>
<a href="#l8.292"></a><span id="l8.292" class="difflineplus">+// and Generation. Shell Construction occurs from a parsed a BODYSTRUCTURE</span>
<a href="#l8.293"></a><span id="l8.293" class="difflineplus">+// response, split into empty parts. Shell Generation generates a &quot;MIME Shell&quot;</span>
<a href="#l8.294"></a><span id="l8.294" class="difflineplus">+// of the message and streams it to libmime for display.  The MIME Shell has</span>
<a href="#l8.295"></a><span id="l8.295" class="difflineplus">+// selected (inline) parts filled in, and leaves all others for on-demand</span>
<a href="#l8.296"></a><span id="l8.296" class="difflineplus">+// retrieval through explicit part fetches.</span>
<a href="#l8.297"></a><span id="l8.297"> </span>
<a href="#l8.298"></a><span id="l8.298" class="difflineminus">-class nsIMAPBodyShell : public nsISupports</span>
<a href="#l8.299"></a><span id="l8.299" class="difflineminus">-{</span>
<a href="#l8.300"></a><span id="l8.300" class="difflineminus">-public:</span>
<a href="#l8.301"></a><span id="l8.301" class="difflineplus">+class nsIMAPBodyShell : public nsISupports {</span>
<a href="#l8.302"></a><span id="l8.302" class="difflineplus">+ public:</span>
<a href="#l8.303"></a><span id="l8.303">   NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l8.304"></a><span id="l8.304">   nsIMAPBodyShell(nsImapProtocol *protocolConnection,</span>
<a href="#l8.305"></a><span id="l8.305">                   nsIMAPBodypartMessage *message, uint32_t UID,</span>
<a href="#l8.306"></a><span id="l8.306">                   uint32_t UIDValidity, const char *folderName);</span>
<a href="#l8.307"></a><span id="l8.307">   // To be used after a shell is uncached</span>
<a href="#l8.308"></a><span id="l8.308">   void SetConnection(nsImapProtocol *con) { m_protocolConnection = con; }</span>
<a href="#l8.309"></a><span id="l8.309">   virtual bool GetIsValid() { return m_isValid; }</span>
<a href="#l8.310"></a><span id="l8.310">   virtual void SetIsValid(bool valid);</span>
<a href="#l8.311"></a><span id="l8.311" class="difflineat">@@ -222,133 +245,142 @@ public:</span>
<a href="#l8.312"></a><span id="l8.312">   void AddPrefetchToQueue(nsIMAPeFetchFields, const char *partNum);</span>
<a href="#l8.313"></a><span id="l8.313">   // Runs a single pipelined command which fetches all of the</span>
<a href="#l8.314"></a><span id="l8.314">   // elements in the prefetch queue</span>
<a href="#l8.315"></a><span id="l8.315">   void FlushPrefetchQueue();</span>
<a href="#l8.316"></a><span id="l8.316">   // Fills in buffer (and adopts storage) for header object</span>
<a href="#l8.317"></a><span id="l8.317">   // partNum specifies the message part number to which the</span>
<a href="#l8.318"></a><span id="l8.318">   // headers correspond.  NULL indicates the top-level message</span>
<a href="#l8.319"></a><span id="l8.319">   void AdoptMessageHeaders(char *headers, const char *partNum);</span>
<a href="#l8.320"></a><span id="l8.320" class="difflineminus">-  // Fills in buffer (and adopts storage) for MIME headers in appropriate object.</span>
<a href="#l8.321"></a><span id="l8.321" class="difflineminus">-  // If object can't be found, sets isValid to false.</span>
<a href="#l8.322"></a><span id="l8.322" class="difflineplus">+  // Fills in buffer (and adopts storage) for MIME headers in appropriate</span>
<a href="#l8.323"></a><span id="l8.323" class="difflineplus">+  // object. If object can't be found, sets isValid to false.</span>
<a href="#l8.324"></a><span id="l8.324">   void AdoptMimeHeader(const char *partNum, char *mimeHeader);</span>
<a href="#l8.325"></a><span id="l8.325"> </span>
<a href="#l8.326"></a><span id="l8.326">   // Generation</span>
<a href="#l8.327"></a><span id="l8.327">   // Streams out an HTML representation of this IMAP message, going along and</span>
<a href="#l8.328"></a><span id="l8.328">   // fetching parts it thinks it needs, and leaving empty shells for the parts</span>
<a href="#l8.329"></a><span id="l8.329">   // it doesn't.</span>
<a href="#l8.330"></a><span id="l8.330">   // Returns number of bytes generated, or -1 if invalid.</span>
<a href="#l8.331"></a><span id="l8.331" class="difflineminus">-  // If partNum is not NULL, then this works to generates a MIME part that hasn't been downloaded yet</span>
<a href="#l8.332"></a><span id="l8.332" class="difflineminus">-  // and leaves out all other parts.  By default, to generate a normal message, partNum should be NULL.</span>
<a href="#l8.333"></a><span id="l8.333" class="difflineplus">+  // If partNum is not NULL, then this works to generates a MIME part that</span>
<a href="#l8.334"></a><span id="l8.334" class="difflineplus">+  // hasn't been downloaded yet and leaves out all other parts.  By default, to</span>
<a href="#l8.335"></a><span id="l8.335" class="difflineplus">+  // generate a normal message, partNum should be NULL.</span>
<a href="#l8.336"></a><span id="l8.336">   virtual int32_t Generate(char *partNum);</span>
<a href="#l8.337"></a><span id="l8.337"> </span>
<a href="#l8.338"></a><span id="l8.338">   // Returns TRUE if the user has the pref &quot;Show Attachments Inline&quot; set.</span>
<a href="#l8.339"></a><span id="l8.339">   // Returns FALSE if the setting is &quot;Show Attachments as Links&quot;</span>
<a href="#l8.340"></a><span id="l8.340">   virtual bool GetShowAttachmentsInline();</span>
<a href="#l8.341"></a><span id="l8.341" class="difflineminus">-  // Returns true if all parts are inline, false otherwise. Does not generate anything.</span>
<a href="#l8.342"></a><span id="l8.342" class="difflineplus">+  // Returns true if all parts are inline, false otherwise. Does not generate</span>
<a href="#l8.343"></a><span id="l8.343" class="difflineplus">+  // anything.</span>
<a href="#l8.344"></a><span id="l8.344">   bool PreflightCheckAllInline();</span>
<a href="#l8.345"></a><span id="l8.345"> </span>
<a href="#l8.346"></a><span id="l8.346">   // Helpers</span>
<a href="#l8.347"></a><span id="l8.347">   nsImapProtocol *GetConnection() { return m_protocolConnection; }</span>
<a href="#l8.348"></a><span id="l8.348">   bool GetPseudoInterrupted();</span>
<a href="#l8.349"></a><span id="l8.349">   bool DeathSignalReceived();</span>
<a href="#l8.350"></a><span id="l8.350">   nsCString &amp;GetUID() { return m_UID; }</span>
<a href="#l8.351"></a><span id="l8.351">   nsCString &amp;GetUID_validity() { return m_UID_validity; }</span>
<a href="#l8.352"></a><span id="l8.352">   const char *GetFolderName() { return m_folderName; }</span>
<a href="#l8.353"></a><span id="l8.353">   char *GetGeneratingPart() { return m_generatingPart; }</span>
<a href="#l8.354"></a><span id="l8.354">   // Returns true if this is in the process of being generated,</span>
<a href="#l8.355"></a><span id="l8.355">   // so we don't re-enter</span>
<a href="#l8.356"></a><span id="l8.356">   bool IsBeingGenerated() { return m_isBeingGenerated; }</span>
<a href="#l8.357"></a><span id="l8.357">   bool IsShellCached() { return m_cached; }</span>
<a href="#l8.358"></a><span id="l8.358">   void SetIsCached(bool isCached) { m_cached = isCached; }</span>
<a href="#l8.359"></a><span id="l8.359">   bool GetGeneratingWholeMessage() { return m_generatingWholeMessage; }</span>
<a href="#l8.360"></a><span id="l8.360" class="difflineminus">-  IMAP_ContentModifiedType  GetContentModified() { return m_contentModified; }</span>
<a href="#l8.361"></a><span id="l8.361" class="difflineminus">-  void SetContentModified(IMAP_ContentModifiedType modType) { m_contentModified = modType; }</span>
<a href="#l8.362"></a><span id="l8.362" class="difflineminus">-protected:</span>
<a href="#l8.363"></a><span id="l8.363" class="difflineplus">+  IMAP_ContentModifiedType GetContentModified() { return m_contentModified; }</span>
<a href="#l8.364"></a><span id="l8.364" class="difflineplus">+  void SetContentModified(IMAP_ContentModifiedType modType) {</span>
<a href="#l8.365"></a><span id="l8.365" class="difflineplus">+    m_contentModified = modType;</span>
<a href="#l8.366"></a><span id="l8.366" class="difflineplus">+  }</span>
<a href="#l8.367"></a><span id="l8.367" class="difflineplus">+</span>
<a href="#l8.368"></a><span id="l8.368" class="difflineplus">+ protected:</span>
<a href="#l8.369"></a><span id="l8.369">   virtual ~nsIMAPBodyShell();</span>
<a href="#l8.370"></a><span id="l8.370"> </span>
<a href="#l8.371"></a><span id="l8.371">   nsIMAPBodypartMessage *m_message;</span>
<a href="#l8.372"></a><span id="l8.372"> </span>
<a href="#l8.373"></a><span id="l8.373" class="difflineminus">-  nsIMAPMessagePartIDArray  *m_prefetchQueue; // array of pipelined part prefetches.  Ok, so it's not really a queue.</span>
<a href="#l8.374"></a><span id="l8.374" class="difflineplus">+  nsIMAPMessagePartIDArray</span>
<a href="#l8.375"></a><span id="l8.375" class="difflineplus">+      *m_prefetchQueue;  // array of pipelined part prefetches.  Ok, so it's not</span>
<a href="#l8.376"></a><span id="l8.376" class="difflineplus">+                         // really a queue.</span>
<a href="#l8.377"></a><span id="l8.377"> </span>
<a href="#l8.378"></a><span id="l8.378" class="difflineminus">-  bool                      m_isValid;</span>
<a href="#l8.379"></a><span id="l8.379" class="difflineminus">-  nsImapProtocol            *m_protocolConnection;    // Connection, for filling in parts</span>
<a href="#l8.380"></a><span id="l8.380" class="difflineminus">-  nsCString                 m_UID;                    // UID of this message</span>
<a href="#l8.381"></a><span id="l8.381" class="difflineminus">-  nsCString                 m_UID_validity;           // appended UID and UID-validity of this message</span>
<a href="#l8.382"></a><span id="l8.382" class="difflineminus">-  char                      *m_folderName;            // folder that contains this message</span>
<a href="#l8.383"></a><span id="l8.383" class="difflineminus">-  char                      *m_generatingPart;        // If a specific part is being generated, this is it.  Otherwise, NULL.</span>
<a href="#l8.384"></a><span id="l8.384" class="difflineminus">-  bool                      m_isBeingGenerated;       // true if this body shell is in the process of being generated</span>
<a href="#l8.385"></a><span id="l8.385" class="difflineminus">-  bool                      m_gotAttachmentPref;      // Whether or not m_showAttachmentsInline has been initialized</span>
<a href="#l8.386"></a><span id="l8.386" class="difflineminus">-  bool                      m_showAttachmentsInline;  // Whether or not we should display attachment inline</span>
<a href="#l8.387"></a><span id="l8.387" class="difflineminus">-  bool                      m_cached;                 // Whether or not this shell is cached</span>
<a href="#l8.388"></a><span id="l8.388" class="difflineminus">-  bool                      m_generatingWholeMessage; // whether or not we are generating the whole (non-MPOD) message</span>
<a href="#l8.389"></a><span id="l8.389" class="difflineminus">-                                                          // Set to false if we are generating by parts</span>
<a href="#l8.390"></a><span id="l8.390" class="difflineplus">+  bool m_isValid;</span>
<a href="#l8.391"></a><span id="l8.391" class="difflineplus">+  nsImapProtocol *m_protocolConnection;  // Connection, for filling in parts</span>
<a href="#l8.392"></a><span id="l8.392" class="difflineplus">+  nsCString m_UID;                       // UID of this message</span>
<a href="#l8.393"></a><span id="l8.393" class="difflineplus">+  nsCString m_UID_validity;  // appended UID and UID-validity of this message</span>
<a href="#l8.394"></a><span id="l8.394" class="difflineplus">+  char *m_folderName;        // folder that contains this message</span>
<a href="#l8.395"></a><span id="l8.395" class="difflineplus">+  char *m_generatingPart;  // If a specific part is being generated, this is it.</span>
<a href="#l8.396"></a><span id="l8.396" class="difflineplus">+                           // Otherwise, NULL.</span>
<a href="#l8.397"></a><span id="l8.397" class="difflineplus">+  bool m_isBeingGenerated;   // true if this body shell is in the process of</span>
<a href="#l8.398"></a><span id="l8.398" class="difflineplus">+                             // being generated</span>
<a href="#l8.399"></a><span id="l8.399" class="difflineplus">+  bool m_gotAttachmentPref;  // Whether or not m_showAttachmentsInline has been</span>
<a href="#l8.400"></a><span id="l8.400" class="difflineplus">+                             // initialized</span>
<a href="#l8.401"></a><span id="l8.401" class="difflineplus">+  bool m_showAttachmentsInline;   // Whether or not we should display attachment</span>
<a href="#l8.402"></a><span id="l8.402" class="difflineplus">+                                  // inline</span>
<a href="#l8.403"></a><span id="l8.403" class="difflineplus">+  bool m_cached;                  // Whether or not this shell is cached</span>
<a href="#l8.404"></a><span id="l8.404" class="difflineplus">+  bool m_generatingWholeMessage;  // whether or not we are generating the whole</span>
<a href="#l8.405"></a><span id="l8.405" class="difflineplus">+                                  // (non-MPOD) message Set to false if we are</span>
<a href="#l8.406"></a><span id="l8.406" class="difflineplus">+                                  // generating by parts</span>
<a href="#l8.407"></a><span id="l8.407">   // under what conditions the content has been modified.</span>
<a href="#l8.408"></a><span id="l8.408" class="difflineminus">-  // Either IMAP_CONTENT_MODIFIED_VIEW_INLINE or IMAP_CONTENT_MODIFIED_VIEW_AS_LINKS</span>
<a href="#l8.409"></a><span id="l8.409" class="difflineminus">-  IMAP_ContentModifiedType        m_contentModified;</span>
<a href="#l8.410"></a><span id="l8.410" class="difflineplus">+  // Either IMAP_CONTENT_MODIFIED_VIEW_INLINE or</span>
<a href="#l8.411"></a><span id="l8.411" class="difflineplus">+  // IMAP_CONTENT_MODIFIED_VIEW_AS_LINKS</span>
<a href="#l8.412"></a><span id="l8.412" class="difflineplus">+  IMAP_ContentModifiedType m_contentModified;</span>
<a href="#l8.413"></a><span id="l8.413"> };</span>
<a href="#l8.414"></a><span id="l8.414"> </span>
<a href="#l8.415"></a><span id="l8.415"> // This class caches shells, so we don't have to always go and re-fetch them.</span>
<a href="#l8.416"></a><span id="l8.416" class="difflineminus">-// This does not cache any of the filled-in inline parts;  those are cached individually</span>
<a href="#l8.417"></a><span id="l8.417" class="difflineminus">-// in the libnet memory cache.  (ugh, how will we do that?)</span>
<a href="#l8.418"></a><span id="l8.418" class="difflineminus">-// Since we'll only be retrieving shells for messages over a given size, and since the</span>
<a href="#l8.419"></a><span id="l8.419" class="difflineminus">-// shells themselves won't be very large, this cache will not grow very big (relatively)</span>
<a href="#l8.420"></a><span id="l8.420" class="difflineminus">-// and should handle most common usage scenarios.</span>
<a href="#l8.421"></a><span id="l8.421" class="difflineplus">+// This does not cache any of the filled-in inline parts;  those are cached</span>
<a href="#l8.422"></a><span id="l8.422" class="difflineplus">+// individually in the libnet memory cache.  (ugh, how will we do that?) Since</span>
<a href="#l8.423"></a><span id="l8.423" class="difflineplus">+// we'll only be retrieving shells for messages over a given size, and since the</span>
<a href="#l8.424"></a><span id="l8.424" class="difflineplus">+// shells themselves won't be very large, this cache will not grow very big</span>
<a href="#l8.425"></a><span id="l8.425" class="difflineplus">+// (relatively) and should handle most common usage scenarios.</span>
<a href="#l8.426"></a><span id="l8.426"> </span>
<a href="#l8.427"></a><span id="l8.427"> // A body cache is associated with a given host, spanning folders, so</span>
<a href="#l8.428"></a><span id="l8.428"> // it uses both UID and UIDVALIDITY .</span>
<a href="#l8.429"></a><span id="l8.429"> </span>
<a href="#l8.430"></a><span id="l8.430" class="difflineminus">-class nsIMAPBodyShellCache</span>
<a href="#l8.431"></a><span id="l8.431" class="difflineminus">-{</span>
<a href="#l8.432"></a><span id="l8.432" class="difflineminus">-public:</span>
<a href="#l8.433"></a><span id="l8.433" class="difflineplus">+class nsIMAPBodyShellCache {</span>
<a href="#l8.434"></a><span id="l8.434" class="difflineplus">+ public:</span>
<a href="#l8.435"></a><span id="l8.435">   static nsIMAPBodyShellCache *Create();</span>
<a href="#l8.436"></a><span id="l8.436">   virtual ~nsIMAPBodyShellCache();</span>
<a href="#l8.437"></a><span id="l8.437"> </span>
<a href="#l8.438"></a><span id="l8.438">   // Adds shell to cache, possibly ejecting</span>
<a href="#l8.439"></a><span id="l8.439">   // another entry based on scheme in EjectEntry().</span>
<a href="#l8.440"></a><span id="l8.440">   bool AddShellToCache(nsIMAPBodyShell *shell);</span>
<a href="#l8.441"></a><span id="l8.441">   // Looks up a shell in the cache given the message's UID.</span>
<a href="#l8.442"></a><span id="l8.442">   nsIMAPBodyShell *FindShellForUID(nsCString &amp;UID, const char *mailboxName,</span>
<a href="#l8.443"></a><span id="l8.443">                                    IMAP_ContentModifiedType modType);</span>
<a href="#l8.444"></a><span id="l8.444">   void Clear();</span>
<a href="#l8.445"></a><span id="l8.445"> </span>
<a href="#l8.446"></a><span id="l8.446" class="difflineminus">-protected:</span>
<a href="#l8.447"></a><span id="l8.447" class="difflineplus">+ protected:</span>
<a href="#l8.448"></a><span id="l8.448">   nsIMAPBodyShellCache();</span>
<a href="#l8.449"></a><span id="l8.449">   // Chooses an entry to eject;  deletes that entry;  and ejects it from the</span>
<a href="#l8.450"></a><span id="l8.450">   // cache, clearing up a new space.  Returns true if it found an entry</span>
<a href="#l8.451"></a><span id="l8.451">   // to eject, false otherwise.</span>
<a href="#l8.452"></a><span id="l8.452">   bool EjectEntry();</span>
<a href="#l8.453"></a><span id="l8.453">   uint32_t GetSize() { return m_shellList-&gt;Length(); }</span>
<a href="#l8.454"></a><span id="l8.454">   uint32_t GetMaxSize() { return 20; }</span>
<a href="#l8.455"></a><span id="l8.455" class="difflineminus">-  nsTArray&lt;nsIMAPBodyShell*&gt; *m_shellList; // For maintenance</span>
<a href="#l8.456"></a><span id="l8.456" class="difflineplus">+  nsTArray&lt;nsIMAPBodyShell *&gt; *m_shellList;  // For maintenance</span>
<a href="#l8.457"></a><span id="l8.457">   // For quick lookup based on UID</span>
<a href="#l8.458"></a><span id="l8.458" class="difflineminus">-  nsRefPtrHashtable &lt;nsCStringHashKey, nsIMAPBodyShell&gt; m_shellHash;</span>
<a href="#l8.459"></a><span id="l8.459" class="difflineplus">+  nsRefPtrHashtable&lt;nsCStringHashKey, nsIMAPBodyShell&gt; m_shellHash;</span>
<a href="#l8.460"></a><span id="l8.460"> };</span>
<a href="#l8.461"></a><span id="l8.461"> </span>
<a href="#l8.462"></a><span id="l8.462"> // MessagePartID and MessagePartIDArray are used for pipelining prefetches.</span>
<a href="#l8.463"></a><span id="l8.463"> </span>
<a href="#l8.464"></a><span id="l8.464" class="difflineminus">-class nsIMAPMessagePartID</span>
<a href="#l8.465"></a><span id="l8.465" class="difflineminus">-{</span>
<a href="#l8.466"></a><span id="l8.466" class="difflineminus">-public:</span>
<a href="#l8.467"></a><span id="l8.467" class="difflineplus">+class nsIMAPMessagePartID {</span>
<a href="#l8.468"></a><span id="l8.468" class="difflineplus">+ public:</span>
<a href="#l8.469"></a><span id="l8.469">   nsIMAPMessagePartID(nsIMAPeFetchFields fields, const char *partNumberString);</span>
<a href="#l8.470"></a><span id="l8.470">   nsIMAPeFetchFields GetFields() { return m_fields; }</span>
<a href="#l8.471"></a><span id="l8.471">   const char *GetPartNumberString() { return m_partNumberString; }</span>
<a href="#l8.472"></a><span id="l8.472"> </span>
<a href="#l8.473"></a><span id="l8.473" class="difflineminus">-protected:</span>
<a href="#l8.474"></a><span id="l8.474" class="difflineplus">+ protected:</span>
<a href="#l8.475"></a><span id="l8.475">   const char *m_partNumberString;</span>
<a href="#l8.476"></a><span id="l8.476">   nsIMAPeFetchFields m_fields;</span>
<a href="#l8.477"></a><span id="l8.477"> };</span>
<a href="#l8.478"></a><span id="l8.478"> </span>
<a href="#l8.479"></a><span id="l8.479" class="difflineminus">-</span>
<a href="#l8.480"></a><span id="l8.480" class="difflineminus">-class nsIMAPMessagePartIDArray : public nsTArray&lt;nsIMAPMessagePartID*&gt; {</span>
<a href="#l8.481"></a><span id="l8.481" class="difflineminus">-public:</span>
<a href="#l8.482"></a><span id="l8.482" class="difflineplus">+class nsIMAPMessagePartIDArray : public nsTArray&lt;nsIMAPMessagePartID *&gt; {</span>
<a href="#l8.483"></a><span id="l8.483" class="difflineplus">+ public:</span>
<a href="#l8.484"></a><span id="l8.484">   nsIMAPMessagePartIDArray();</span>
<a href="#l8.485"></a><span id="l8.485">   ~nsIMAPMessagePartIDArray();</span>
<a href="#l8.486"></a><span id="l8.486"> </span>
<a href="#l8.487"></a><span id="l8.487">   void RemoveAndFreeAll();</span>
<a href="#l8.488"></a><span id="l8.488">   uint32_t GetNumParts() { return Length(); }</span>
<a href="#l8.489"></a><span id="l8.489" class="difflineminus">-  nsIMAPMessagePartID *GetPart(uint32_t i)</span>
<a href="#l8.490"></a><span id="l8.490" class="difflineminus">-  {</span>
<a href="#l8.491"></a><span id="l8.491" class="difflineplus">+  nsIMAPMessagePartID *GetPart(uint32_t i) {</span>
<a href="#l8.492"></a><span id="l8.492">     NS_ASSERTION(i &lt; Length(), &quot;invalid message part #&quot;);</span>
<a href="#l8.493"></a><span id="l8.493">     return ElementAt(i);</span>
<a href="#l8.494"></a><span id="l8.494">   }</span>
<a href="#l8.495"></a><span id="l8.495"> };</span>
<a href="#l8.496"></a><span id="l8.496" class="difflineminus">-#endif // IMAPBODY_H</span>
<a href="#l8.497"></a><span id="l8.497" class="difflineplus">+#endif  // IMAPBODY_H</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPGenericParser.cpp</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPGenericParser.cpp</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -5,473 +5,403 @@</span>
<a href="#l9.4"></a><span id="l9.4"> </span>
<a href="#l9.5"></a><span id="l9.5"> #include &quot;msgCore.h&quot;  // for pre-compiled headers</span>
<a href="#l9.6"></a><span id="l9.6"> </span>
<a href="#l9.7"></a><span id="l9.7"> #include &quot;nsIMAPGenericParser.h&quot;</span>
<a href="#l9.8"></a><span id="l9.8"> #include &quot;nsString.h&quot;</span>
<a href="#l9.9"></a><span id="l9.9"> </span>
<a href="#l9.10"></a><span id="l9.10"> ////////////////// nsIMAPGenericParser /////////////////////////</span>
<a href="#l9.11"></a><span id="l9.11"> </span>
<a href="#l9.12"></a><span id="l9.12" class="difflineplus">+nsIMAPGenericParser::nsIMAPGenericParser()</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+    : fNextToken(nullptr),</span>
<a href="#l9.14"></a><span id="l9.14" class="difflineplus">+      fCurrentLine(nullptr),</span>
<a href="#l9.15"></a><span id="l9.15" class="difflineplus">+      fLineOfTokens(nullptr),</span>
<a href="#l9.16"></a><span id="l9.16" class="difflineplus">+      fStartOfLineOfTokens(nullptr),</span>
<a href="#l9.17"></a><span id="l9.17" class="difflineplus">+      fCurrentTokenPlaceHolder(nullptr),</span>
<a href="#l9.18"></a><span id="l9.18" class="difflineplus">+      fAtEndOfLine(false),</span>
<a href="#l9.19"></a><span id="l9.19" class="difflineplus">+      fParserState(stateOK) {}</span>
<a href="#l9.20"></a><span id="l9.20"> </span>
<a href="#l9.21"></a><span id="l9.21" class="difflineminus">-nsIMAPGenericParser::nsIMAPGenericParser() :</span>
<a href="#l9.22"></a><span id="l9.22" class="difflineminus">-fNextToken(nullptr),</span>
<a href="#l9.23"></a><span id="l9.23" class="difflineminus">-fCurrentLine(nullptr),</span>
<a href="#l9.24"></a><span id="l9.24" class="difflineminus">-fLineOfTokens(nullptr),</span>
<a href="#l9.25"></a><span id="l9.25" class="difflineminus">-fStartOfLineOfTokens(nullptr),</span>
<a href="#l9.26"></a><span id="l9.26" class="difflineminus">-fCurrentTokenPlaceHolder(nullptr),</span>
<a href="#l9.27"></a><span id="l9.27" class="difflineminus">-fAtEndOfLine(false),</span>
<a href="#l9.28"></a><span id="l9.28" class="difflineminus">-fParserState(stateOK)</span>
<a href="#l9.29"></a><span id="l9.29" class="difflineminus">-{</span>
<a href="#l9.30"></a><span id="l9.30" class="difflineplus">+nsIMAPGenericParser::~nsIMAPGenericParser() {</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineplus">+  PR_FREEIF(fCurrentLine);</span>
<a href="#l9.32"></a><span id="l9.32" class="difflineplus">+  PR_FREEIF(fStartOfLineOfTokens);</span>
<a href="#l9.33"></a><span id="l9.33"> }</span>
<a href="#l9.34"></a><span id="l9.34"> </span>
<a href="#l9.35"></a><span id="l9.35" class="difflineminus">-nsIMAPGenericParser::~nsIMAPGenericParser()</span>
<a href="#l9.36"></a><span id="l9.36" class="difflineminus">-{</span>
<a href="#l9.37"></a><span id="l9.37" class="difflineminus">-  PR_FREEIF( fCurrentLine );</span>
<a href="#l9.38"></a><span id="l9.38" class="difflineminus">-  PR_FREEIF( fStartOfLineOfTokens);</span>
<a href="#l9.39"></a><span id="l9.39" class="difflineminus">-}</span>
<a href="#l9.40"></a><span id="l9.40" class="difflineplus">+void nsIMAPGenericParser::HandleMemoryFailure() { SetConnected(false); }</span>
<a href="#l9.41"></a><span id="l9.41"> </span>
<a href="#l9.42"></a><span id="l9.42" class="difflineminus">-void nsIMAPGenericParser::HandleMemoryFailure()</span>
<a href="#l9.43"></a><span id="l9.43" class="difflineminus">-{</span>
<a href="#l9.44"></a><span id="l9.44" class="difflineminus">-  SetConnected(false);</span>
<a href="#l9.45"></a><span id="l9.45" class="difflineminus">-}</span>
<a href="#l9.46"></a><span id="l9.46" class="difflineplus">+void nsIMAPGenericParser::ResetLexAnalyzer() {</span>
<a href="#l9.47"></a><span id="l9.47" class="difflineplus">+  PR_FREEIF(fCurrentLine);</span>
<a href="#l9.48"></a><span id="l9.48" class="difflineplus">+  PR_FREEIF(fStartOfLineOfTokens);</span>
<a href="#l9.49"></a><span id="l9.49"> </span>
<a href="#l9.50"></a><span id="l9.50" class="difflineminus">-void nsIMAPGenericParser::ResetLexAnalyzer()</span>
<a href="#l9.51"></a><span id="l9.51" class="difflineminus">-{</span>
<a href="#l9.52"></a><span id="l9.52" class="difflineminus">-  PR_FREEIF( fCurrentLine );</span>
<a href="#l9.53"></a><span id="l9.53" class="difflineminus">-  PR_FREEIF( fStartOfLineOfTokens );</span>
<a href="#l9.54"></a><span id="l9.54" class="difflineminus">-</span>
<a href="#l9.55"></a><span id="l9.55" class="difflineminus">-  fNextToken = fCurrentLine = fLineOfTokens = fStartOfLineOfTokens = fCurrentTokenPlaceHolder = nullptr;</span>
<a href="#l9.56"></a><span id="l9.56" class="difflineplus">+  fNextToken = fCurrentLine = fLineOfTokens = fStartOfLineOfTokens =</span>
<a href="#l9.57"></a><span id="l9.57" class="difflineplus">+      fCurrentTokenPlaceHolder = nullptr;</span>
<a href="#l9.58"></a><span id="l9.58">   fAtEndOfLine = false;</span>
<a href="#l9.59"></a><span id="l9.59"> }</span>
<a href="#l9.60"></a><span id="l9.60"> </span>
<a href="#l9.61"></a><span id="l9.61" class="difflineminus">-bool nsIMAPGenericParser::LastCommandSuccessful()</span>
<a href="#l9.62"></a><span id="l9.62" class="difflineminus">-{</span>
<a href="#l9.63"></a><span id="l9.63" class="difflineplus">+bool nsIMAPGenericParser::LastCommandSuccessful() {</span>
<a href="#l9.64"></a><span id="l9.64">   return fParserState == stateOK;</span>
<a href="#l9.65"></a><span id="l9.65"> }</span>
<a href="#l9.66"></a><span id="l9.66"> </span>
<a href="#l9.67"></a><span id="l9.67" class="difflineminus">-void nsIMAPGenericParser::SetSyntaxError(bool error, const char *msg)</span>
<a href="#l9.68"></a><span id="l9.68" class="difflineminus">-{</span>
<a href="#l9.69"></a><span id="l9.69" class="difflineplus">+void nsIMAPGenericParser::SetSyntaxError(bool error, const char *msg) {</span>
<a href="#l9.70"></a><span id="l9.70">   if (error)</span>
<a href="#l9.71"></a><span id="l9.71" class="difflineminus">-      fParserState |= stateSyntaxErrorFlag;</span>
<a href="#l9.72"></a><span id="l9.72" class="difflineplus">+    fParserState |= stateSyntaxErrorFlag;</span>
<a href="#l9.73"></a><span id="l9.73">   else</span>
<a href="#l9.74"></a><span id="l9.74" class="difflineminus">-      fParserState &amp;= ~stateSyntaxErrorFlag;</span>
<a href="#l9.75"></a><span id="l9.75" class="difflineplus">+    fParserState &amp;= ~stateSyntaxErrorFlag;</span>
<a href="#l9.76"></a><span id="l9.76">   NS_ASSERTION(!error, &quot;syntax error in generic parser&quot;);</span>
<a href="#l9.77"></a><span id="l9.77"> }</span>
<a href="#l9.78"></a><span id="l9.78"> </span>
<a href="#l9.79"></a><span id="l9.79" class="difflineminus">-void nsIMAPGenericParser::SetConnected(bool connected)</span>
<a href="#l9.80"></a><span id="l9.80" class="difflineminus">-{</span>
<a href="#l9.81"></a><span id="l9.81" class="difflineplus">+void nsIMAPGenericParser::SetConnected(bool connected) {</span>
<a href="#l9.82"></a><span id="l9.82">   if (connected)</span>
<a href="#l9.83"></a><span id="l9.83" class="difflineminus">-      fParserState &amp;= ~stateDisconnectedFlag;</span>
<a href="#l9.84"></a><span id="l9.84" class="difflineplus">+    fParserState &amp;= ~stateDisconnectedFlag;</span>
<a href="#l9.85"></a><span id="l9.85">   else</span>
<a href="#l9.86"></a><span id="l9.86" class="difflineminus">-      fParserState |= stateDisconnectedFlag;</span>
<a href="#l9.87"></a><span id="l9.87" class="difflineplus">+    fParserState |= stateDisconnectedFlag;</span>
<a href="#l9.88"></a><span id="l9.88"> }</span>
<a href="#l9.89"></a><span id="l9.89"> </span>
<a href="#l9.90"></a><span id="l9.90" class="difflineminus">-void nsIMAPGenericParser::skip_to_CRLF()</span>
<a href="#l9.91"></a><span id="l9.91" class="difflineminus">-{</span>
<a href="#l9.92"></a><span id="l9.92" class="difflineminus">-  while (Connected() &amp;&amp; !fAtEndOfLine)</span>
<a href="#l9.93"></a><span id="l9.93" class="difflineminus">-    AdvanceToNextToken();</span>
<a href="#l9.94"></a><span id="l9.94" class="difflineplus">+void nsIMAPGenericParser::skip_to_CRLF() {</span>
<a href="#l9.95"></a><span id="l9.95" class="difflineplus">+  while (Connected() &amp;&amp; !fAtEndOfLine) AdvanceToNextToken();</span>
<a href="#l9.96"></a><span id="l9.96"> }</span>
<a href="#l9.97"></a><span id="l9.97"> </span>
<a href="#l9.98"></a><span id="l9.98"> // fNextToken initially should point to</span>
<a href="#l9.99"></a><span id="l9.99"> // a string after the initial open paren (&quot;(&quot;)</span>
<a href="#l9.100"></a><span id="l9.100"> // After this call, fNextToken points to the</span>
<a href="#l9.101"></a><span id="l9.101"> // first character after the matching close</span>
<a href="#l9.102"></a><span id="l9.102"> // paren.  Only call AdvanceToNextToken() to get the NEXT</span>
<a href="#l9.103"></a><span id="l9.103"> // token after the one returned in fNextToken.</span>
<a href="#l9.104"></a><span id="l9.104" class="difflineminus">-void nsIMAPGenericParser::skip_to_close_paren()</span>
<a href="#l9.105"></a><span id="l9.105" class="difflineminus">-{</span>
<a href="#l9.106"></a><span id="l9.106" class="difflineplus">+void nsIMAPGenericParser::skip_to_close_paren() {</span>
<a href="#l9.107"></a><span id="l9.107">   int numberOfCloseParensNeeded = 1;</span>
<a href="#l9.108"></a><span id="l9.108" class="difflineminus">-  while (ContinueParse())</span>
<a href="#l9.109"></a><span id="l9.109" class="difflineminus">-  {</span>
<a href="#l9.110"></a><span id="l9.110" class="difflineplus">+  while (ContinueParse()) {</span>
<a href="#l9.111"></a><span id="l9.111">     // go through fNextToken, account for nested parens</span>
<a href="#l9.112"></a><span id="l9.112">     const char *loc;</span>
<a href="#l9.113"></a><span id="l9.113" class="difflineminus">-    for (loc = fNextToken; loc &amp;&amp; *loc; loc++)</span>
<a href="#l9.114"></a><span id="l9.114" class="difflineminus">-    {</span>
<a href="#l9.115"></a><span id="l9.115" class="difflineplus">+    for (loc = fNextToken; loc &amp;&amp; *loc; loc++) {</span>
<a href="#l9.116"></a><span id="l9.116">       if (*loc == '(')</span>
<a href="#l9.117"></a><span id="l9.117">         numberOfCloseParensNeeded++;</span>
<a href="#l9.118"></a><span id="l9.118" class="difflineminus">-      else if (*loc == ')')</span>
<a href="#l9.119"></a><span id="l9.119" class="difflineminus">-      {</span>
<a href="#l9.120"></a><span id="l9.120" class="difflineplus">+      else if (*loc == ')') {</span>
<a href="#l9.121"></a><span id="l9.121">         numberOfCloseParensNeeded--;</span>
<a href="#l9.122"></a><span id="l9.122" class="difflineminus">-        if (numberOfCloseParensNeeded == 0)</span>
<a href="#l9.123"></a><span id="l9.123" class="difflineminus">-        {</span>
<a href="#l9.124"></a><span id="l9.124" class="difflineplus">+        if (numberOfCloseParensNeeded == 0) {</span>
<a href="#l9.125"></a><span id="l9.125">           fNextToken = loc + 1;</span>
<a href="#l9.126"></a><span id="l9.126" class="difflineminus">-          if (!fNextToken || !*fNextToken)</span>
<a href="#l9.127"></a><span id="l9.127" class="difflineminus">-            AdvanceToNextToken();</span>
<a href="#l9.128"></a><span id="l9.128" class="difflineplus">+          if (!fNextToken || !*fNextToken) AdvanceToNextToken();</span>
<a href="#l9.129"></a><span id="l9.129">           return;</span>
<a href="#l9.130"></a><span id="l9.130">         }</span>
<a href="#l9.131"></a><span id="l9.131" class="difflineminus">-      }</span>
<a href="#l9.132"></a><span id="l9.132" class="difflineminus">-      else if (*loc == '{' || *loc == '&quot;') {</span>
<a href="#l9.133"></a><span id="l9.133" class="difflineplus">+      } else if (*loc == '{' || *loc == '&quot;') {</span>
<a href="#l9.134"></a><span id="l9.134">         // quoted or literal</span>
<a href="#l9.135"></a><span id="l9.135">         fNextToken = loc;</span>
<a href="#l9.136"></a><span id="l9.136">         char *a = CreateString();</span>
<a href="#l9.137"></a><span id="l9.137">         PR_FREEIF(a);</span>
<a href="#l9.138"></a><span id="l9.138" class="difflineminus">-        break; // move to next token</span>
<a href="#l9.139"></a><span id="l9.139" class="difflineplus">+        break;  // move to next token</span>
<a href="#l9.140"></a><span id="l9.140">       }</span>
<a href="#l9.141"></a><span id="l9.141">     }</span>
<a href="#l9.142"></a><span id="l9.142" class="difflineminus">-    if (ContinueParse())</span>
<a href="#l9.143"></a><span id="l9.143" class="difflineminus">-      AdvanceToNextToken();</span>
<a href="#l9.144"></a><span id="l9.144" class="difflineplus">+    if (ContinueParse()) AdvanceToNextToken();</span>
<a href="#l9.145"></a><span id="l9.145">   }</span>
<a href="#l9.146"></a><span id="l9.146"> }</span>
<a href="#l9.147"></a><span id="l9.147"> </span>
<a href="#l9.148"></a><span id="l9.148" class="difflineminus">-void nsIMAPGenericParser::AdvanceToNextToken()</span>
<a href="#l9.149"></a><span id="l9.149" class="difflineminus">-{</span>
<a href="#l9.150"></a><span id="l9.150" class="difflineminus">-  if (!fCurrentLine || fAtEndOfLine)</span>
<a href="#l9.151"></a><span id="l9.151" class="difflineminus">-    AdvanceToNextLine();</span>
<a href="#l9.152"></a><span id="l9.152" class="difflineminus">-  if (Connected())</span>
<a href="#l9.153"></a><span id="l9.153" class="difflineminus">-  {</span>
<a href="#l9.154"></a><span id="l9.154" class="difflineminus">-    if (!fStartOfLineOfTokens)</span>
<a href="#l9.155"></a><span id="l9.155" class="difflineminus">-    {</span>
<a href="#l9.156"></a><span id="l9.156" class="difflineplus">+void nsIMAPGenericParser::AdvanceToNextToken() {</span>
<a href="#l9.157"></a><span id="l9.157" class="difflineplus">+  if (!fCurrentLine || fAtEndOfLine) AdvanceToNextLine();</span>
<a href="#l9.158"></a><span id="l9.158" class="difflineplus">+  if (Connected()) {</span>
<a href="#l9.159"></a><span id="l9.159" class="difflineplus">+    if (!fStartOfLineOfTokens) {</span>
<a href="#l9.160"></a><span id="l9.160">       // this is the first token of the line; setup tokenizer now</span>
<a href="#l9.161"></a><span id="l9.161">       fStartOfLineOfTokens = PL_strdup(fCurrentLine);</span>
<a href="#l9.162"></a><span id="l9.162" class="difflineminus">-      if (!fStartOfLineOfTokens)</span>
<a href="#l9.163"></a><span id="l9.163" class="difflineminus">-      {</span>
<a href="#l9.164"></a><span id="l9.164" class="difflineplus">+      if (!fStartOfLineOfTokens) {</span>
<a href="#l9.165"></a><span id="l9.165">         HandleMemoryFailure();</span>
<a href="#l9.166"></a><span id="l9.166">         return;</span>
<a href="#l9.167"></a><span id="l9.167">       }</span>
<a href="#l9.168"></a><span id="l9.168">       fLineOfTokens = fStartOfLineOfTokens;</span>
<a href="#l9.169"></a><span id="l9.169">       fCurrentTokenPlaceHolder = fStartOfLineOfTokens;</span>
<a href="#l9.170"></a><span id="l9.170">     }</span>
<a href="#l9.171"></a><span id="l9.171">     fNextToken = NS_strtok(WHITESPACE, &amp;fCurrentTokenPlaceHolder);</span>
<a href="#l9.172"></a><span id="l9.172" class="difflineminus">-    if (!fNextToken)</span>
<a href="#l9.173"></a><span id="l9.173" class="difflineminus">-    {</span>
<a href="#l9.174"></a><span id="l9.174" class="difflineplus">+    if (!fNextToken) {</span>
<a href="#l9.175"></a><span id="l9.175">       fAtEndOfLine = true;</span>
<a href="#l9.176"></a><span id="l9.176">       fNextToken = CRLF;</span>
<a href="#l9.177"></a><span id="l9.177">     }</span>
<a href="#l9.178"></a><span id="l9.178">   }</span>
<a href="#l9.179"></a><span id="l9.179"> }</span>
<a href="#l9.180"></a><span id="l9.180"> </span>
<a href="#l9.181"></a><span id="l9.181" class="difflineminus">-void nsIMAPGenericParser::AdvanceToNextLine()</span>
<a href="#l9.182"></a><span id="l9.182" class="difflineminus">-{</span>
<a href="#l9.183"></a><span id="l9.183" class="difflineminus">-  PR_FREEIF( fCurrentLine );</span>
<a href="#l9.184"></a><span id="l9.184" class="difflineminus">-  PR_FREEIF( fStartOfLineOfTokens);</span>
<a href="#l9.185"></a><span id="l9.185" class="difflineplus">+void nsIMAPGenericParser::AdvanceToNextLine() {</span>
<a href="#l9.186"></a><span id="l9.186" class="difflineplus">+  PR_FREEIF(fCurrentLine);</span>
<a href="#l9.187"></a><span id="l9.187" class="difflineplus">+  PR_FREEIF(fStartOfLineOfTokens);</span>
<a href="#l9.188"></a><span id="l9.188"> </span>
<a href="#l9.189"></a><span id="l9.189">   bool ok = GetNextLineForParser(&amp;fCurrentLine);</span>
<a href="#l9.190"></a><span id="l9.190" class="difflineminus">-  if (!ok)</span>
<a href="#l9.191"></a><span id="l9.191" class="difflineminus">-  {</span>
<a href="#l9.192"></a><span id="l9.192" class="difflineplus">+  if (!ok) {</span>
<a href="#l9.193"></a><span id="l9.193">     SetConnected(false);</span>
<a href="#l9.194"></a><span id="l9.194">     fStartOfLineOfTokens = nullptr;</span>
<a href="#l9.195"></a><span id="l9.195">     fLineOfTokens = nullptr;</span>
<a href="#l9.196"></a><span id="l9.196">     fCurrentTokenPlaceHolder = nullptr;</span>
<a href="#l9.197"></a><span id="l9.197">     fAtEndOfLine = true;</span>
<a href="#l9.198"></a><span id="l9.198">     fNextToken = CRLF;</span>
<a href="#l9.199"></a><span id="l9.199" class="difflineminus">-  }</span>
<a href="#l9.200"></a><span id="l9.200" class="difflineminus">-  else if (!fCurrentLine)</span>
<a href="#l9.201"></a><span id="l9.201" class="difflineminus">-  {</span>
<a href="#l9.202"></a><span id="l9.202" class="difflineplus">+  } else if (!fCurrentLine) {</span>
<a href="#l9.203"></a><span id="l9.203">     HandleMemoryFailure();</span>
<a href="#l9.204"></a><span id="l9.204" class="difflineminus">-  }</span>
<a href="#l9.205"></a><span id="l9.205" class="difflineminus">-  else</span>
<a href="#l9.206"></a><span id="l9.206" class="difflineminus">-  {</span>
<a href="#l9.207"></a><span id="l9.207" class="difflineminus">-     fNextToken = nullptr;</span>
<a href="#l9.208"></a><span id="l9.208" class="difflineminus">-     // determine if there are any tokens (without calling AdvanceToNextToken);</span>
<a href="#l9.209"></a><span id="l9.209" class="difflineminus">-     // otherwise we are already at end of line</span>
<a href="#l9.210"></a><span id="l9.210" class="difflineminus">-     NS_ASSERTION(strlen(WHITESPACE) == 3, &quot;assume 3 chars of whitespace&quot;);</span>
<a href="#l9.211"></a><span id="l9.211" class="difflineminus">-     char *firstToken = fCurrentLine;</span>
<a href="#l9.212"></a><span id="l9.212" class="difflineminus">-     while (*firstToken &amp;&amp; (*firstToken == WHITESPACE[0] ||</span>
<a href="#l9.213"></a><span id="l9.213" class="difflineminus">-            *firstToken == WHITESPACE[1] || *firstToken == WHITESPACE[2]))</span>
<a href="#l9.214"></a><span id="l9.214" class="difflineminus">-       firstToken++;</span>
<a href="#l9.215"></a><span id="l9.215" class="difflineminus">-     fAtEndOfLine = (*firstToken == '\0');</span>
<a href="#l9.216"></a><span id="l9.216" class="difflineplus">+  } else {</span>
<a href="#l9.217"></a><span id="l9.217" class="difflineplus">+    fNextToken = nullptr;</span>
<a href="#l9.218"></a><span id="l9.218" class="difflineplus">+    // determine if there are any tokens (without calling AdvanceToNextToken);</span>
<a href="#l9.219"></a><span id="l9.219" class="difflineplus">+    // otherwise we are already at end of line</span>
<a href="#l9.220"></a><span id="l9.220" class="difflineplus">+    NS_ASSERTION(strlen(WHITESPACE) == 3, &quot;assume 3 chars of whitespace&quot;);</span>
<a href="#l9.221"></a><span id="l9.221" class="difflineplus">+    char *firstToken = fCurrentLine;</span>
<a href="#l9.222"></a><span id="l9.222" class="difflineplus">+    while (*firstToken &amp;&amp;</span>
<a href="#l9.223"></a><span id="l9.223" class="difflineplus">+           (*firstToken == WHITESPACE[0] || *firstToken == WHITESPACE[1] ||</span>
<a href="#l9.224"></a><span id="l9.224" class="difflineplus">+            *firstToken == WHITESPACE[2]))</span>
<a href="#l9.225"></a><span id="l9.225" class="difflineplus">+      firstToken++;</span>
<a href="#l9.226"></a><span id="l9.226" class="difflineplus">+    fAtEndOfLine = (*firstToken == '\0');</span>
<a href="#l9.227"></a><span id="l9.227">   }</span>
<a href="#l9.228"></a><span id="l9.228"> }</span>
<a href="#l9.229"></a><span id="l9.229"> </span>
<a href="#l9.230"></a><span id="l9.230"> // advances |fLineOfTokens| by |bytesToAdvance| bytes</span>
<a href="#l9.231"></a><span id="l9.231" class="difflineminus">-void nsIMAPGenericParser::AdvanceTokenizerStartingPoint(int32_t bytesToAdvance)</span>
<a href="#l9.232"></a><span id="l9.232" class="difflineminus">-{</span>
<a href="#l9.233"></a><span id="l9.233" class="difflineminus">-  NS_ASSERTION(bytesToAdvance&gt;=0, &quot;bytesToAdvance must not be negative&quot;);</span>
<a href="#l9.234"></a><span id="l9.234" class="difflineminus">-  if (!fStartOfLineOfTokens)</span>
<a href="#l9.235"></a><span id="l9.235" class="difflineminus">-  {</span>
<a href="#l9.236"></a><span id="l9.236" class="difflineplus">+void nsIMAPGenericParser::AdvanceTokenizerStartingPoint(</span>
<a href="#l9.237"></a><span id="l9.237" class="difflineplus">+    int32_t bytesToAdvance) {</span>
<a href="#l9.238"></a><span id="l9.238" class="difflineplus">+  NS_ASSERTION(bytesToAdvance &gt;= 0, &quot;bytesToAdvance must not be negative&quot;);</span>
<a href="#l9.239"></a><span id="l9.239" class="difflineplus">+  if (!fStartOfLineOfTokens) {</span>
<a href="#l9.240"></a><span id="l9.240">     AdvanceToNextToken();  // the tokenizer was not yet initialized, do it now</span>
<a href="#l9.241"></a><span id="l9.241" class="difflineminus">-    if (!fStartOfLineOfTokens)</span>
<a href="#l9.242"></a><span id="l9.242" class="difflineminus">-      return;</span>
<a href="#l9.243"></a><span id="l9.243" class="difflineplus">+    if (!fStartOfLineOfTokens) return;</span>
<a href="#l9.244"></a><span id="l9.244">   }</span>
<a href="#l9.245"></a><span id="l9.245"> </span>
<a href="#l9.246"></a><span id="l9.246" class="difflineminus">-  if(!fStartOfLineOfTokens)</span>
<a href="#l9.247"></a><span id="l9.247" class="difflineminus">-      return;</span>
<a href="#l9.248"></a><span id="l9.248" class="difflineplus">+  if (!fStartOfLineOfTokens) return;</span>
<a href="#l9.249"></a><span id="l9.249">   // The last call to AdvanceToNextToken() cleared the token separator to '\0'</span>
<a href="#l9.250"></a><span id="l9.250">   // iff |fCurrentTokenPlaceHolder|.  We must recover this token separator now.</span>
<a href="#l9.251"></a><span id="l9.251" class="difflineminus">-  if (fCurrentTokenPlaceHolder)</span>
<a href="#l9.252"></a><span id="l9.252" class="difflineminus">-  {</span>
<a href="#l9.253"></a><span id="l9.253" class="difflineplus">+  if (fCurrentTokenPlaceHolder) {</span>
<a href="#l9.254"></a><span id="l9.254">     int endTokenOffset = fCurrentTokenPlaceHolder - fStartOfLineOfTokens - 1;</span>
<a href="#l9.255"></a><span id="l9.255">     if (endTokenOffset &gt;= 0)</span>
<a href="#l9.256"></a><span id="l9.256">       fStartOfLineOfTokens[endTokenOffset] = fCurrentLine[endTokenOffset];</span>
<a href="#l9.257"></a><span id="l9.257">   }</span>
<a href="#l9.258"></a><span id="l9.258"> </span>
<a href="#l9.259"></a><span id="l9.259" class="difflineminus">-  NS_ASSERTION(bytesToAdvance + (fLineOfTokens-fStartOfLineOfTokens) &lt;=</span>
<a href="#l9.260"></a><span id="l9.260" class="difflineminus">-    (int32_t)strlen(fCurrentLine), &quot;cannot advance beyond end of fLineOfTokens&quot;);</span>
<a href="#l9.261"></a><span id="l9.261" class="difflineplus">+  NS_ASSERTION(bytesToAdvance + (fLineOfTokens - fStartOfLineOfTokens) &lt;=</span>
<a href="#l9.262"></a><span id="l9.262" class="difflineplus">+                   (int32_t)strlen(fCurrentLine),</span>
<a href="#l9.263"></a><span id="l9.263" class="difflineplus">+               &quot;cannot advance beyond end of fLineOfTokens&quot;);</span>
<a href="#l9.264"></a><span id="l9.264">   fLineOfTokens += bytesToAdvance;</span>
<a href="#l9.265"></a><span id="l9.265">   fCurrentTokenPlaceHolder = fLineOfTokens;</span>
<a href="#l9.266"></a><span id="l9.266"> }</span>
<a href="#l9.267"></a><span id="l9.267"> </span>
<a href="#l9.268"></a><span id="l9.268"> // RFC3501:  astring = 1*ASTRING-CHAR / string</span>
<a href="#l9.269"></a><span id="l9.269"> //           string  = quoted / literal</span>
<a href="#l9.270"></a><span id="l9.270"> // This function leaves us off with fCurrentTokenPlaceHolder immediately after</span>
<a href="#l9.271"></a><span id="l9.271"> // the end of the Astring.  Call AdvanceToNextToken() to get the token after it.</span>
<a href="#l9.272"></a><span id="l9.272" class="difflineminus">-char *nsIMAPGenericParser::CreateAstring()</span>
<a href="#l9.273"></a><span id="l9.273" class="difflineminus">-{</span>
<a href="#l9.274"></a><span id="l9.274" class="difflineminus">-  if (*fNextToken == '{')</span>
<a href="#l9.275"></a><span id="l9.275" class="difflineminus">-    return CreateLiteral();  // literal</span>
<a href="#l9.276"></a><span id="l9.276" class="difflineminus">-  if (*fNextToken == '&quot;')</span>
<a href="#l9.277"></a><span id="l9.277" class="difflineminus">-    return CreateQuoted();  // quoted</span>
<a href="#l9.278"></a><span id="l9.278" class="difflineminus">-  return CreateAtom(true); // atom</span>
<a href="#l9.279"></a><span id="l9.279" class="difflineplus">+char *nsIMAPGenericParser::CreateAstring() {</span>
<a href="#l9.280"></a><span id="l9.280" class="difflineplus">+  if (*fNextToken == '{') return CreateLiteral();  // literal</span>
<a href="#l9.281"></a><span id="l9.281" class="difflineplus">+  if (*fNextToken == '&quot;') return CreateQuoted();   // quoted</span>
<a href="#l9.282"></a><span id="l9.282" class="difflineplus">+  return CreateAtom(true);                         // atom</span>
<a href="#l9.283"></a><span id="l9.283"> }</span>
<a href="#l9.284"></a><span id="l9.284"> </span>
<a href="#l9.285"></a><span id="l9.285"> // Create an atom</span>
<a href="#l9.286"></a><span id="l9.286"> // This function does not advance the parser.</span>
<a href="#l9.287"></a><span id="l9.287"> // Call AdvanceToNextToken() to get the next token after the atom.</span>
<a href="#l9.288"></a><span id="l9.288"> // RFC3501:  atom            = 1*ATOM-CHAR</span>
<a href="#l9.289"></a><span id="l9.289"> //           ASTRING-CHAR    = ATOM-CHAR / resp-specials</span>
<a href="#l9.290"></a><span id="l9.290"> //           ATOM-CHAR       = &lt;any CHAR except atom-specials&gt;</span>
<a href="#l9.291"></a><span id="l9.291"> //           atom-specials   = &quot;(&quot; / &quot;)&quot; / &quot;{&quot; / SP / CTL / list-wildcards /</span>
<a href="#l9.292"></a><span id="l9.292"> //                             quoted-specials / resp-specials</span>
<a href="#l9.293"></a><span id="l9.293"> //           list-wildcards  = &quot;%&quot; / &quot;*&quot;</span>
<a href="#l9.294"></a><span id="l9.294"> //           quoted-specials = DQUOTE / &quot;\&quot;</span>
<a href="#l9.295"></a><span id="l9.295"> //           resp-specials   = &quot;]&quot;</span>
<a href="#l9.296"></a><span id="l9.296"> // &quot;Characters are 7-bit US-ASCII unless otherwise specified.&quot; [RFC3501, 1.2.]</span>
<a href="#l9.297"></a><span id="l9.297" class="difflineminus">-char *nsIMAPGenericParser::CreateAtom(bool isAstring)</span>
<a href="#l9.298"></a><span id="l9.298" class="difflineminus">-{</span>
<a href="#l9.299"></a><span id="l9.299" class="difflineplus">+char *nsIMAPGenericParser::CreateAtom(bool isAstring) {</span>
<a href="#l9.300"></a><span id="l9.300">   char *rv = PL_strdup(fNextToken);</span>
<a href="#l9.301"></a><span id="l9.301" class="difflineminus">-  if (!rv)</span>
<a href="#l9.302"></a><span id="l9.302" class="difflineminus">-  {</span>
<a href="#l9.303"></a><span id="l9.303" class="difflineplus">+  if (!rv) {</span>
<a href="#l9.304"></a><span id="l9.304">     HandleMemoryFailure();</span>
<a href="#l9.305"></a><span id="l9.305">     return nullptr;</span>
<a href="#l9.306"></a><span id="l9.306">   }</span>
<a href="#l9.307"></a><span id="l9.307">   // We wish to stop at the following characters (in decimal ascii)</span>
<a href="#l9.308"></a><span id="l9.308">   // 1-31 (CTL), 32 (SP), 34 '&quot;', 37 '%', 40-42 &quot;()*&quot;, 92 '\\', 123 '{'</span>
<a href="#l9.309"></a><span id="l9.309">   // also, ']' is only allowed in astrings</span>
<a href="#l9.310"></a><span id="l9.310">   char *last = rv;</span>
<a href="#l9.311"></a><span id="l9.311">   char c = *last;</span>
<a href="#l9.312"></a><span id="l9.312" class="difflineminus">-  while ((c &gt; 42 || c == 33 || c == 35 || c == 36 || c == 38 || c == 39)</span>
<a href="#l9.313"></a><span id="l9.313" class="difflineminus">-         &amp;&amp; c != '\\' &amp;&amp; c != '{' &amp;&amp; (isAstring || c != ']'))</span>
<a href="#l9.314"></a><span id="l9.314" class="difflineminus">-     c = *++last;</span>
<a href="#l9.315"></a><span id="l9.315" class="difflineplus">+  while ((c &gt; 42 || c == 33 || c == 35 || c == 36 || c == 38 || c == 39) &amp;&amp;</span>
<a href="#l9.316"></a><span id="l9.316" class="difflineplus">+         c != '\\' &amp;&amp; c != '{' &amp;&amp; (isAstring || c != ']'))</span>
<a href="#l9.317"></a><span id="l9.317" class="difflineplus">+    c = *++last;</span>
<a href="#l9.318"></a><span id="l9.318">   if (rv == last) {</span>
<a href="#l9.319"></a><span id="l9.319" class="difflineminus">-     SetSyntaxError(true, &quot;no atom characters found&quot;);</span>
<a href="#l9.320"></a><span id="l9.320" class="difflineminus">-     PL_strfree(rv);</span>
<a href="#l9.321"></a><span id="l9.321" class="difflineminus">-     return nullptr;</span>
<a href="#l9.322"></a><span id="l9.322" class="difflineplus">+    SetSyntaxError(true, &quot;no atom characters found&quot;);</span>
<a href="#l9.323"></a><span id="l9.323" class="difflineplus">+    PL_strfree(rv);</span>
<a href="#l9.324"></a><span id="l9.324" class="difflineplus">+    return nullptr;</span>
<a href="#l9.325"></a><span id="l9.325">   }</span>
<a href="#l9.326"></a><span id="l9.326" class="difflineminus">-  if (*last)</span>
<a href="#l9.327"></a><span id="l9.327" class="difflineminus">-  {</span>
<a href="#l9.328"></a><span id="l9.328" class="difflineplus">+  if (*last) {</span>
<a href="#l9.329"></a><span id="l9.329">     // not the whole token was consumed</span>
<a href="#l9.330"></a><span id="l9.330">     *last = '\0';</span>
<a href="#l9.331"></a><span id="l9.331" class="difflineminus">-    AdvanceTokenizerStartingPoint((fNextToken - fLineOfTokens) + (last-rv));</span>
<a href="#l9.332"></a><span id="l9.332" class="difflineplus">+    AdvanceTokenizerStartingPoint((fNextToken - fLineOfTokens) + (last - rv));</span>
<a href="#l9.333"></a><span id="l9.333">   }</span>
<a href="#l9.334"></a><span id="l9.334">   return rv;</span>
<a href="#l9.335"></a><span id="l9.335"> }</span>
<a href="#l9.336"></a><span id="l9.336"> </span>
<a href="#l9.337"></a><span id="l9.337"> // CreateNilString return either NULL (for &quot;NIL&quot;) or a string</span>
<a href="#l9.338"></a><span id="l9.338"> // Call with fNextToken pointing to the thing which we think is the nilstring.</span>
<a href="#l9.339"></a><span id="l9.339"> // This function leaves us off with fCurrentTokenPlaceHolder immediately after</span>
<a href="#l9.340"></a><span id="l9.340"> // the end of the string.</span>
<a href="#l9.341"></a><span id="l9.341"> // Regardless of type, call AdvanceToNextToken() to get the token after it.</span>
<a href="#l9.342"></a><span id="l9.342"> // RFC3501:   nstring  = string / nil</span>
<a href="#l9.343"></a><span id="l9.343"> //            nil      = &quot;NIL&quot;</span>
<a href="#l9.344"></a><span id="l9.344" class="difflineminus">-char *nsIMAPGenericParser::CreateNilString()</span>
<a href="#l9.345"></a><span id="l9.345" class="difflineminus">-{</span>
<a href="#l9.346"></a><span id="l9.346" class="difflineminus">-  if (!PL_strncasecmp(fNextToken, &quot;NIL&quot;, 3))</span>
<a href="#l9.347"></a><span id="l9.347" class="difflineminus">-  {</span>
<a href="#l9.348"></a><span id="l9.348" class="difflineplus">+char *nsIMAPGenericParser::CreateNilString() {</span>
<a href="#l9.349"></a><span id="l9.349" class="difflineplus">+  if (!PL_strncasecmp(fNextToken, &quot;NIL&quot;, 3)) {</span>
<a href="#l9.350"></a><span id="l9.350">     // check if there is text after &quot;NIL&quot; in fNextToken,</span>
<a href="#l9.351"></a><span id="l9.351">     // equivalent handling as in CreateQuoted</span>
<a href="#l9.352"></a><span id="l9.352">     if (fNextToken[3])</span>
<a href="#l9.353"></a><span id="l9.353">       AdvanceTokenizerStartingPoint((fNextToken - fLineOfTokens) + 3);</span>
<a href="#l9.354"></a><span id="l9.354">     return NULL;</span>
<a href="#l9.355"></a><span id="l9.355">   }</span>
<a href="#l9.356"></a><span id="l9.356">   return CreateString();</span>
<a href="#l9.357"></a><span id="l9.357"> }</span>
<a href="#l9.358"></a><span id="l9.358"> </span>
<a href="#l9.359"></a><span id="l9.359" class="difflineminus">-</span>
<a href="#l9.360"></a><span id="l9.360"> // Create a string, which can either be quoted or literal,</span>
<a href="#l9.361"></a><span id="l9.361"> // but not an atom.</span>
<a href="#l9.362"></a><span id="l9.362"> // This function leaves us off with fCurrentTokenPlaceHolder immediately after</span>
<a href="#l9.363"></a><span id="l9.363"> // the end of the String.  Call AdvanceToNextToken() to get the token after it.</span>
<a href="#l9.364"></a><span id="l9.364" class="difflineminus">-char *nsIMAPGenericParser::CreateString()</span>
<a href="#l9.365"></a><span id="l9.365" class="difflineminus">-{</span>
<a href="#l9.366"></a><span id="l9.366" class="difflineminus">-  if (*fNextToken == '{')</span>
<a href="#l9.367"></a><span id="l9.367" class="difflineminus">-  {</span>
<a href="#l9.368"></a><span id="l9.368" class="difflineplus">+char *nsIMAPGenericParser::CreateString() {</span>
<a href="#l9.369"></a><span id="l9.369" class="difflineplus">+  if (*fNextToken == '{') {</span>
<a href="#l9.370"></a><span id="l9.370">     char *rv = CreateLiteral();  // literal</span>
<a href="#l9.371"></a><span id="l9.371">     return (rv);</span>
<a href="#l9.372"></a><span id="l9.372">   }</span>
<a href="#l9.373"></a><span id="l9.373" class="difflineminus">-  if (*fNextToken == '&quot;')</span>
<a href="#l9.374"></a><span id="l9.374" class="difflineminus">-  {</span>
<a href="#l9.375"></a><span id="l9.375" class="difflineplus">+  if (*fNextToken == '&quot;') {</span>
<a href="#l9.376"></a><span id="l9.376">     char *rv = CreateQuoted();  // quoted</span>
<a href="#l9.377"></a><span id="l9.377">     return (rv);</span>
<a href="#l9.378"></a><span id="l9.378">   }</span>
<a href="#l9.379"></a><span id="l9.379">   SetSyntaxError(true, &quot;string does not start with '{' or '\&quot;'&quot;);</span>
<a href="#l9.380"></a><span id="l9.380">   return NULL;</span>
<a href="#l9.381"></a><span id="l9.381"> }</span>
<a href="#l9.382"></a><span id="l9.382"> </span>
<a href="#l9.383"></a><span id="l9.383"> // This function sets fCurrentTokenPlaceHolder immediately after the end of the</span>
<a href="#l9.384"></a><span id="l9.384"> // closing quote.  Call AdvanceToNextToken() to get the token after it.</span>
<a href="#l9.385"></a><span id="l9.385"> // QUOTED_CHAR     ::= &lt;any TEXT_CHAR except quoted_specials&gt; /</span>
<a href="#l9.386"></a><span id="l9.386"> //                     &quot;\&quot; quoted_specials</span>
<a href="#l9.387"></a><span id="l9.387"> // TEXT_CHAR       ::= &lt;any CHAR except CR and LF&gt;</span>
<a href="#l9.388"></a><span id="l9.388"> // quoted_specials ::= &lt;&quot;&gt; / &quot;\&quot;</span>
<a href="#l9.389"></a><span id="l9.389"> // Note that according to RFC 1064 and RFC 2060, CRs and LFs are not allowed</span>
<a href="#l9.390"></a><span id="l9.390"> // inside a quoted string.  It is sufficient to read from the current line only.</span>
<a href="#l9.391"></a><span id="l9.391" class="difflineminus">-char *nsIMAPGenericParser::CreateQuoted(bool /*skipToEnd*/)</span>
<a href="#l9.392"></a><span id="l9.392" class="difflineminus">-{</span>
<a href="#l9.393"></a><span id="l9.393" class="difflineplus">+char *nsIMAPGenericParser::CreateQuoted(bool /*skipToEnd*/) {</span>
<a href="#l9.394"></a><span id="l9.394">   // one char past opening '&quot;'</span>
<a href="#l9.395"></a><span id="l9.395">   char *currentChar = fCurrentLine + (fNextToken - fStartOfLineOfTokens) + 1;</span>
<a href="#l9.396"></a><span id="l9.396"> </span>
<a href="#l9.397"></a><span id="l9.397">   int escapeCharsCut = 0;</span>
<a href="#l9.398"></a><span id="l9.398">   nsCString returnString(currentChar);</span>
<a href="#l9.399"></a><span id="l9.399">   int charIndex;</span>
<a href="#l9.400"></a><span id="l9.400" class="difflineminus">-  for (charIndex = 0; returnString.CharAt(charIndex) != '&quot;'; charIndex++)</span>
<a href="#l9.401"></a><span id="l9.401" class="difflineminus">-  {</span>
<a href="#l9.402"></a><span id="l9.402" class="difflineminus">-    if (!returnString.CharAt(charIndex))</span>
<a href="#l9.403"></a><span id="l9.403" class="difflineminus">-    {</span>
<a href="#l9.404"></a><span id="l9.404" class="difflineplus">+  for (charIndex = 0; returnString.CharAt(charIndex) != '&quot;'; charIndex++) {</span>
<a href="#l9.405"></a><span id="l9.405" class="difflineplus">+    if (!returnString.CharAt(charIndex)) {</span>
<a href="#l9.406"></a><span id="l9.406">       SetSyntaxError(true, &quot;no closing '\&quot;' found in quoted&quot;);</span>
<a href="#l9.407"></a><span id="l9.407">       return nullptr;</span>
<a href="#l9.408"></a><span id="l9.408">     }</span>
<a href="#l9.409"></a><span id="l9.409" class="difflineminus">-    if (returnString.CharAt(charIndex) == '\\')</span>
<a href="#l9.410"></a><span id="l9.410" class="difflineminus">-    {</span>
<a href="#l9.411"></a><span id="l9.411" class="difflineplus">+    if (returnString.CharAt(charIndex) == '\\') {</span>
<a href="#l9.412"></a><span id="l9.412">       // eat the escape character, but keep the escaped character</span>
<a href="#l9.413"></a><span id="l9.413">       returnString.Cut(charIndex, 1);</span>
<a href="#l9.414"></a><span id="l9.414">       escapeCharsCut++;</span>
<a href="#l9.415"></a><span id="l9.415">     }</span>
<a href="#l9.416"></a><span id="l9.416">   }</span>
<a href="#l9.417"></a><span id="l9.417">   // +2 because of the start and end quotes</span>
<a href="#l9.418"></a><span id="l9.418" class="difflineminus">-  AdvanceTokenizerStartingPoint((fNextToken - fLineOfTokens) +</span>
<a href="#l9.419"></a><span id="l9.419" class="difflineminus">-                                charIndex + escapeCharsCut + 2);</span>
<a href="#l9.420"></a><span id="l9.420" class="difflineplus">+  AdvanceTokenizerStartingPoint((fNextToken - fLineOfTokens) + charIndex +</span>
<a href="#l9.421"></a><span id="l9.421" class="difflineplus">+                                escapeCharsCut + 2);</span>
<a href="#l9.422"></a><span id="l9.422"> </span>
<a href="#l9.423"></a><span id="l9.423">   returnString.SetLength(charIndex);</span>
<a href="#l9.424"></a><span id="l9.424">   return ToNewCString(returnString);</span>
<a href="#l9.425"></a><span id="l9.425"> }</span>
<a href="#l9.426"></a><span id="l9.426"> </span>
<a href="#l9.427"></a><span id="l9.427" class="difflineminus">-</span>
<a href="#l9.428"></a><span id="l9.428"> // This function leaves us off with fCurrentTokenPlaceHolder immediately after</span>
<a href="#l9.429"></a><span id="l9.429"> // the end of the literal string.  Call AdvanceToNextToken() to get the token</span>
<a href="#l9.430"></a><span id="l9.430"> // after the literal string.</span>
<a href="#l9.431"></a><span id="l9.431"> // RFC3501:  literal = &quot;{&quot; number &quot;}&quot; CRLF *CHAR8</span>
<a href="#l9.432"></a><span id="l9.432"> //                       ; Number represents the number of CHAR8s</span>
<a href="#l9.433"></a><span id="l9.433"> //           CHAR8   = %x01-ff</span>
<a href="#l9.434"></a><span id="l9.434"> //                       ; any OCTET except NUL, %x00</span>
<a href="#l9.435"></a><span id="l9.435" class="difflineminus">-char *nsIMAPGenericParser::CreateLiteral()</span>
<a href="#l9.436"></a><span id="l9.436" class="difflineminus">-{</span>
<a href="#l9.437"></a><span id="l9.437" class="difflineplus">+char *nsIMAPGenericParser::CreateLiteral() {</span>
<a href="#l9.438"></a><span id="l9.438">   int32_t numberOfCharsInMessage = atoi(fNextToken + 1);</span>
<a href="#l9.439"></a><span id="l9.439">   uint32_t numBytes = numberOfCharsInMessage + 1;</span>
<a href="#l9.440"></a><span id="l9.440">   NS_ASSERTION(numBytes, &quot;overflow!&quot;);</span>
<a href="#l9.441"></a><span id="l9.441" class="difflineminus">-  if (!numBytes)</span>
<a href="#l9.442"></a><span id="l9.442" class="difflineminus">-    return nullptr;</span>
<a href="#l9.443"></a><span id="l9.443" class="difflineplus">+  if (!numBytes) return nullptr;</span>
<a href="#l9.444"></a><span id="l9.444">   char *returnString = (char *)PR_Malloc(numBytes);</span>
<a href="#l9.445"></a><span id="l9.445" class="difflineminus">-  if (!returnString)</span>
<a href="#l9.446"></a><span id="l9.446" class="difflineminus">-  {</span>
<a href="#l9.447"></a><span id="l9.447" class="difflineplus">+  if (!returnString) {</span>
<a href="#l9.448"></a><span id="l9.448">     HandleMemoryFailure();</span>
<a href="#l9.449"></a><span id="l9.449">     return nullptr;</span>
<a href="#l9.450"></a><span id="l9.450">   }</span>
<a href="#l9.451"></a><span id="l9.451"> </span>
<a href="#l9.452"></a><span id="l9.452">   int32_t currentLineLength = 0;</span>
<a href="#l9.453"></a><span id="l9.453">   int32_t charsReadSoFar = 0;</span>
<a href="#l9.454"></a><span id="l9.454">   int32_t bytesToCopy = 0;</span>
<a href="#l9.455"></a><span id="l9.455" class="difflineminus">-  while (charsReadSoFar &lt; numberOfCharsInMessage)</span>
<a href="#l9.456"></a><span id="l9.456" class="difflineminus">-  {</span>
<a href="#l9.457"></a><span id="l9.457" class="difflineplus">+  while (charsReadSoFar &lt; numberOfCharsInMessage) {</span>
<a href="#l9.458"></a><span id="l9.458">     AdvanceToNextLine();</span>
<a href="#l9.459"></a><span id="l9.459" class="difflineminus">-    if (!ContinueParse())</span>
<a href="#l9.460"></a><span id="l9.460" class="difflineminus">-      break;</span>
<a href="#l9.461"></a><span id="l9.461" class="difflineplus">+    if (!ContinueParse()) break;</span>
<a href="#l9.462"></a><span id="l9.462"> </span>
<a href="#l9.463"></a><span id="l9.463">     currentLineLength = strlen(fCurrentLine);</span>
<a href="#l9.464"></a><span id="l9.464" class="difflineminus">-    bytesToCopy = (currentLineLength &gt; numberOfCharsInMessage - charsReadSoFar ?</span>
<a href="#l9.465"></a><span id="l9.465" class="difflineminus">-                   numberOfCharsInMessage - charsReadSoFar : currentLineLength);</span>
<a href="#l9.466"></a><span id="l9.466" class="difflineplus">+    bytesToCopy = (currentLineLength &gt; numberOfCharsInMessage - charsReadSoFar</span>
<a href="#l9.467"></a><span id="l9.467" class="difflineplus">+                       ? numberOfCharsInMessage - charsReadSoFar</span>
<a href="#l9.468"></a><span id="l9.468" class="difflineplus">+                       : currentLineLength);</span>
<a href="#l9.469"></a><span id="l9.469">     NS_ASSERTION(bytesToCopy, &quot;zero-length line?&quot;);</span>
<a href="#l9.470"></a><span id="l9.470">     memcpy(returnString + charsReadSoFar, fCurrentLine, bytesToCopy);</span>
<a href="#l9.471"></a><span id="l9.471">     charsReadSoFar += bytesToCopy;</span>
<a href="#l9.472"></a><span id="l9.472">   }</span>
<a href="#l9.473"></a><span id="l9.473"> </span>
<a href="#l9.474"></a><span id="l9.474" class="difflineminus">-  if (ContinueParse())</span>
<a href="#l9.475"></a><span id="l9.475" class="difflineminus">-  {</span>
<a href="#l9.476"></a><span id="l9.476" class="difflineminus">-    if (currentLineLength == bytesToCopy)</span>
<a href="#l9.477"></a><span id="l9.477" class="difflineminus">-    {</span>
<a href="#l9.478"></a><span id="l9.478" class="difflineplus">+  if (ContinueParse()) {</span>
<a href="#l9.479"></a><span id="l9.479" class="difflineplus">+    if (currentLineLength == bytesToCopy) {</span>
<a href="#l9.480"></a><span id="l9.480">       // We have consumed the entire line.</span>
<a href="#l9.481"></a><span id="l9.481">       // Consider the input  &quot;{4}\r\n&quot;  &quot;L1\r\n&quot;  &quot; A2\r\n&quot;  which is read</span>
<a href="#l9.482"></a><span id="l9.482">       // line-by-line.  Reading an Astring, this should result in &quot;L1\r\n&quot;.</span>
<a href="#l9.483"></a><span id="l9.483">       // Note that the second line is &quot;L1\r\n&quot;, where the &quot;\r\n&quot; is part of</span>
<a href="#l9.484"></a><span id="l9.484">       // the literal.  Hence, we now read the next line to ensure that the</span>
<a href="#l9.485"></a><span id="l9.485">       // next call to AdvanceToNextToken() leads to fNextToken==&quot;A2&quot; in our</span>
<a href="#l9.486"></a><span id="l9.486">       // example.</span>
<a href="#l9.487"></a><span id="l9.487">       AdvanceToNextLine();</span>
<a href="#l9.488"></a><span id="l9.488" class="difflineminus">-    }</span>
<a href="#l9.489"></a><span id="l9.489" class="difflineminus">-    else</span>
<a href="#l9.490"></a><span id="l9.490" class="difflineplus">+    } else</span>
<a href="#l9.491"></a><span id="l9.491">       AdvanceTokenizerStartingPoint(bytesToCopy);</span>
<a href="#l9.492"></a><span id="l9.492">   }</span>
<a href="#l9.493"></a><span id="l9.493"> </span>
<a href="#l9.494"></a><span id="l9.494">   returnString[charsReadSoFar] = 0;</span>
<a href="#l9.495"></a><span id="l9.495">   return returnString;</span>
<a href="#l9.496"></a><span id="l9.496"> }</span>
<a href="#l9.497"></a><span id="l9.497"> </span>
<a href="#l9.498"></a><span id="l9.498" class="difflineminus">-</span>
<a href="#l9.499"></a><span id="l9.499"> // Call this to create a buffer containing all characters within</span>
<a href="#l9.500"></a><span id="l9.500"> // a given set of parentheses.</span>
<a href="#l9.501"></a><span id="l9.501"> // Call this with fNextToken[0]=='(', that is, the open paren</span>
<a href="#l9.502"></a><span id="l9.502"> // of the group.</span>
<a href="#l9.503"></a><span id="l9.503" class="difflineminus">-// It will allocate and return all characters up to and including the corresponding</span>
<a href="#l9.504"></a><span id="l9.504" class="difflineminus">-// closing paren, and leave the parser in the right place afterwards.</span>
<a href="#l9.505"></a><span id="l9.505" class="difflineminus">-char *nsIMAPGenericParser::CreateParenGroup()</span>
<a href="#l9.506"></a><span id="l9.506" class="difflineminus">-{</span>
<a href="#l9.507"></a><span id="l9.507" class="difflineplus">+// It will allocate and return all characters up to and including the</span>
<a href="#l9.508"></a><span id="l9.508" class="difflineplus">+// corresponding closing paren, and leave the parser in the right place</span>
<a href="#l9.509"></a><span id="l9.509" class="difflineplus">+// afterwards.</span>
<a href="#l9.510"></a><span id="l9.510" class="difflineplus">+char *nsIMAPGenericParser::CreateParenGroup() {</span>
<a href="#l9.511"></a><span id="l9.511">   NS_ASSERTION(fNextToken[0] == '(', &quot;we don't have a paren group!&quot;);</span>
<a href="#l9.512"></a><span id="l9.512"> </span>
<a href="#l9.513"></a><span id="l9.513">   int numOpenParens = 0;</span>
<a href="#l9.514"></a><span id="l9.514">   AdvanceTokenizerStartingPoint(fNextToken - fLineOfTokens);</span>
<a href="#l9.515"></a><span id="l9.515"> </span>
<a href="#l9.516"></a><span id="l9.516">   // Build up a buffer containing the paren group.</span>
<a href="#l9.517"></a><span id="l9.517">   nsCString returnString;</span>
<a href="#l9.518"></a><span id="l9.518">   char *parenGroupStart = fCurrentTokenPlaceHolder;</span>
<a href="#l9.519"></a><span id="l9.519">   NS_ASSERTION(parenGroupStart[0] == '(', &quot;we don't have a paren group (2)!&quot;);</span>
<a href="#l9.520"></a><span id="l9.520" class="difflineminus">-  while (*fCurrentTokenPlaceHolder)</span>
<a href="#l9.521"></a><span id="l9.521" class="difflineminus">-  {</span>
<a href="#l9.522"></a><span id="l9.522" class="difflineplus">+  while (*fCurrentTokenPlaceHolder) {</span>
<a href="#l9.523"></a><span id="l9.523">     if (*fCurrentTokenPlaceHolder == '{')  // literal</span>
<a href="#l9.524"></a><span id="l9.524">     {</span>
<a href="#l9.525"></a><span id="l9.525">       // Ensure it is a properly formatted literal.</span>
<a href="#l9.526"></a><span id="l9.526" class="difflineminus">-      NS_ASSERTION(!strcmp(&quot;}\r\n&quot;, fCurrentTokenPlaceHolder + strlen(fCurrentTokenPlaceHolder) - 3), &quot;not a literal&quot;);</span>
<a href="#l9.527"></a><span id="l9.527" class="difflineplus">+      NS_ASSERTION(!strcmp(&quot;}\r\n&quot;, fCurrentTokenPlaceHolder +</span>
<a href="#l9.528"></a><span id="l9.528" class="difflineplus">+                                        strlen(fCurrentTokenPlaceHolder) - 3),</span>
<a href="#l9.529"></a><span id="l9.529" class="difflineplus">+                   &quot;not a literal&quot;);</span>
<a href="#l9.530"></a><span id="l9.530"> </span>
<a href="#l9.531"></a><span id="l9.531">       // Append previous characters and the &quot;{xx}\r\n&quot; to buffer.</span>
<a href="#l9.532"></a><span id="l9.532">       returnString.Append(parenGroupStart);</span>
<a href="#l9.533"></a><span id="l9.533"> </span>
<a href="#l9.534"></a><span id="l9.534">       // Append literal itself.</span>
<a href="#l9.535"></a><span id="l9.535">       AdvanceToNextToken();</span>
<a href="#l9.536"></a><span id="l9.536" class="difflineminus">-      if (!ContinueParse())</span>
<a href="#l9.537"></a><span id="l9.537" class="difflineminus">-        break;</span>
<a href="#l9.538"></a><span id="l9.538" class="difflineplus">+      if (!ContinueParse()) break;</span>
<a href="#l9.539"></a><span id="l9.539">       char *lit = CreateLiteral();</span>
<a href="#l9.540"></a><span id="l9.540">       NS_ASSERTION(lit, &quot;syntax error or out of memory&quot;);</span>
<a href="#l9.541"></a><span id="l9.541" class="difflineminus">-      if (!lit)</span>
<a href="#l9.542"></a><span id="l9.542" class="difflineminus">-        break;</span>
<a href="#l9.543"></a><span id="l9.543" class="difflineplus">+      if (!lit) break;</span>
<a href="#l9.544"></a><span id="l9.544">       returnString.Append(lit);</span>
<a href="#l9.545"></a><span id="l9.545">       PR_Free(lit);</span>
<a href="#l9.546"></a><span id="l9.546" class="difflineminus">-      if (!ContinueParse())</span>
<a href="#l9.547"></a><span id="l9.547" class="difflineminus">-        break;</span>
<a href="#l9.548"></a><span id="l9.548" class="difflineplus">+      if (!ContinueParse()) break;</span>
<a href="#l9.549"></a><span id="l9.549">       parenGroupStart = fCurrentTokenPlaceHolder;</span>
<a href="#l9.550"></a><span id="l9.550" class="difflineminus">-    }</span>
<a href="#l9.551"></a><span id="l9.551" class="difflineminus">-    else if (*fCurrentTokenPlaceHolder == '&quot;')  // quoted</span>
<a href="#l9.552"></a><span id="l9.552" class="difflineplus">+    } else if (*fCurrentTokenPlaceHolder == '&quot;')  // quoted</span>
<a href="#l9.553"></a><span id="l9.553">     {</span>
<a href="#l9.554"></a><span id="l9.554">       // Append the _escaped_ version of the quoted string:</span>
<a href="#l9.555"></a><span id="l9.555">       // just skip it (because the quoted string must be on the same line).</span>
<a href="#l9.556"></a><span id="l9.556">       AdvanceToNextToken();</span>
<a href="#l9.557"></a><span id="l9.557" class="difflineminus">-      if (!ContinueParse())</span>
<a href="#l9.558"></a><span id="l9.558" class="difflineminus">-        break;</span>
<a href="#l9.559"></a><span id="l9.559" class="difflineplus">+      if (!ContinueParse()) break;</span>
<a href="#l9.560"></a><span id="l9.560">       char *q = CreateQuoted();</span>
<a href="#l9.561"></a><span id="l9.561" class="difflineminus">-      if (!q)</span>
<a href="#l9.562"></a><span id="l9.562" class="difflineminus">-        break;</span>
<a href="#l9.563"></a><span id="l9.563" class="difflineplus">+      if (!q) break;</span>
<a href="#l9.564"></a><span id="l9.564">       PR_Free(q);</span>
<a href="#l9.565"></a><span id="l9.565" class="difflineminus">-      if (!ContinueParse())</span>
<a href="#l9.566"></a><span id="l9.566" class="difflineminus">-        break;</span>
<a href="#l9.567"></a><span id="l9.567" class="difflineminus">-    }</span>
<a href="#l9.568"></a><span id="l9.568" class="difflineminus">-    else</span>
<a href="#l9.569"></a><span id="l9.569" class="difflineminus">-    {</span>
<a href="#l9.570"></a><span id="l9.570" class="difflineplus">+      if (!ContinueParse()) break;</span>
<a href="#l9.571"></a><span id="l9.571" class="difflineplus">+    } else {</span>
<a href="#l9.572"></a><span id="l9.572">       // Append this character to the buffer.</span>
<a href="#l9.573"></a><span id="l9.573">       char c = *fCurrentTokenPlaceHolder++;</span>
<a href="#l9.574"></a><span id="l9.574">       if (c == '(')</span>
<a href="#l9.575"></a><span id="l9.575">         numOpenParens++;</span>
<a href="#l9.576"></a><span id="l9.576" class="difflineminus">-      else if (c == ')')</span>
<a href="#l9.577"></a><span id="l9.577" class="difflineminus">-      {</span>
<a href="#l9.578"></a><span id="l9.578" class="difflineplus">+      else if (c == ')') {</span>
<a href="#l9.579"></a><span id="l9.579">         numOpenParens--;</span>
<a href="#l9.580"></a><span id="l9.580" class="difflineminus">-        if (numOpenParens == 0)</span>
<a href="#l9.581"></a><span id="l9.581" class="difflineminus">-          break;</span>
<a href="#l9.582"></a><span id="l9.582" class="difflineplus">+        if (numOpenParens == 0) break;</span>
<a href="#l9.583"></a><span id="l9.583">       }</span>
<a href="#l9.584"></a><span id="l9.584">     }</span>
<a href="#l9.585"></a><span id="l9.585">   }</span>
<a href="#l9.586"></a><span id="l9.586"> </span>
<a href="#l9.587"></a><span id="l9.587" class="difflineminus">-  if (numOpenParens != 0 || !ContinueParse())</span>
<a href="#l9.588"></a><span id="l9.588" class="difflineminus">-  {</span>
<a href="#l9.589"></a><span id="l9.589" class="difflineplus">+  if (numOpenParens != 0 || !ContinueParse()) {</span>
<a href="#l9.590"></a><span id="l9.590">     SetSyntaxError(true, &quot;closing ')' not found in paren group&quot;);</span>
<a href="#l9.591"></a><span id="l9.591">     return nullptr;</span>
<a href="#l9.592"></a><span id="l9.592">   }</span>
<a href="#l9.593"></a><span id="l9.593"> </span>
<a href="#l9.594"></a><span id="l9.594" class="difflineminus">-  returnString.Append(parenGroupStart, fCurrentTokenPlaceHolder - parenGroupStart);</span>
<a href="#l9.595"></a><span id="l9.595" class="difflineplus">+  returnString.Append(parenGroupStart,</span>
<a href="#l9.596"></a><span id="l9.596" class="difflineplus">+                      fCurrentTokenPlaceHolder - parenGroupStart);</span>
<a href="#l9.597"></a><span id="l9.597">   AdvanceToNextToken();</span>
<a href="#l9.598"></a><span id="l9.598">   return ToNewCString(returnString);</span>
<a href="#l9.599"></a><span id="l9.599"> }</span>
<a href="#l9.600"></a><span id="l9.600" class="difflineminus">-</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPGenericParser.h</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPGenericParser.h</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -1,46 +1,44 @@</span>
<a href="#l10.4"></a><span id="l10.4"> /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l10.5"></a><span id="l10.5"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l10.6"></a><span id="l10.6">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l10.7"></a><span id="l10.7">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l10.8"></a><span id="l10.8"> </span>
<a href="#l10.9"></a><span id="l10.9"> /*</span>
<a href="#l10.10"></a><span id="l10.10" class="difflineminus">-nsIMAPGenericParser is the base parser class used by the server parser and body shell parser</span>
<a href="#l10.11"></a><span id="l10.11" class="difflineplus">+nsIMAPGenericParser is the base parser class used by the server parser and body</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+shell parser</span>
<a href="#l10.13"></a><span id="l10.13"> */</span>
<a href="#l10.14"></a><span id="l10.14"> </span>
<a href="#l10.15"></a><span id="l10.15"> #ifndef nsIMAPGenericParser_H</span>
<a href="#l10.16"></a><span id="l10.16"> #define nsIMAPGenericParser_H</span>
<a href="#l10.17"></a><span id="l10.17"> </span>
<a href="#l10.18"></a><span id="l10.18" class="difflineminus">-#define WHITESPACE &quot; \015\012&quot;     // token delimiter</span>
<a href="#l10.19"></a><span id="l10.19" class="difflineminus">-</span>
<a href="#l10.20"></a><span id="l10.20" class="difflineplus">+#define WHITESPACE &quot; \015\012&quot;  // token delimiter</span>
<a href="#l10.21"></a><span id="l10.21"> </span>
<a href="#l10.22"></a><span id="l10.22" class="difflineminus">-class nsIMAPGenericParser</span>
<a href="#l10.23"></a><span id="l10.23" class="difflineminus">-{</span>
<a href="#l10.24"></a><span id="l10.24" class="difflineminus">-</span>
<a href="#l10.25"></a><span id="l10.25" class="difflineminus">-public:</span>
<a href="#l10.26"></a><span id="l10.26" class="difflineplus">+class nsIMAPGenericParser {</span>
<a href="#l10.27"></a><span id="l10.27" class="difflineplus">+ public:</span>
<a href="#l10.28"></a><span id="l10.28">   nsIMAPGenericParser();</span>
<a href="#l10.29"></a><span id="l10.29">   virtual ~nsIMAPGenericParser();</span>
<a href="#l10.30"></a><span id="l10.30"> </span>
<a href="#l10.31"></a><span id="l10.31">   // Add any specific stuff in the derived class</span>
<a href="#l10.32"></a><span id="l10.32" class="difflineminus">-  virtual bool       LastCommandSuccessful();</span>
<a href="#l10.33"></a><span id="l10.33" class="difflineplus">+  virtual bool LastCommandSuccessful();</span>
<a href="#l10.34"></a><span id="l10.34"> </span>
<a href="#l10.35"></a><span id="l10.35">   bool SyntaxError() { return (fParserState &amp; stateSyntaxErrorFlag) != 0; }</span>
<a href="#l10.36"></a><span id="l10.36">   bool ContinueParse() { return fParserState == stateOK; }</span>
<a href="#l10.37"></a><span id="l10.37">   bool Connected() { return !(fParserState &amp; stateDisconnectedFlag); }</span>
<a href="#l10.38"></a><span id="l10.38">   void SetConnected(bool error);</span>
<a href="#l10.39"></a><span id="l10.39"> </span>
<a href="#l10.40"></a><span id="l10.40" class="difflineminus">-protected:</span>
<a href="#l10.41"></a><span id="l10.41" class="difflineminus">-</span>
<a href="#l10.42"></a><span id="l10.42" class="difflineplus">+ protected:</span>
<a href="#l10.43"></a><span id="l10.43">   // This is a pure virtual member which must be overridden in the derived class</span>
<a href="#l10.44"></a><span id="l10.44">   // for each different implementation of a nsIMAPGenericParser.</span>
<a href="#l10.45"></a><span id="l10.45" class="difflineminus">-  // For instance, one implementation (the nsIMAPServerState) might get the next line</span>
<a href="#l10.46"></a><span id="l10.46" class="difflineminus">-  // from an open socket, whereas another implementation might just get it from a buffer somewhere.</span>
<a href="#l10.47"></a><span id="l10.47" class="difflineminus">-  // This fills in nextLine with the buffer, and returns true if everything is OK.</span>
<a href="#l10.48"></a><span id="l10.48" class="difflineminus">-  // Returns false if there was some error encountered.  In that case, we reset the parser.</span>
<a href="#l10.49"></a><span id="l10.49" class="difflineplus">+  // For instance, one implementation (the nsIMAPServerState) might get the next</span>
<a href="#l10.50"></a><span id="l10.50" class="difflineplus">+  // line from an open socket, whereas another implementation might just get it</span>
<a href="#l10.51"></a><span id="l10.51" class="difflineplus">+  // from a buffer somewhere. This fills in nextLine with the buffer, and</span>
<a href="#l10.52"></a><span id="l10.52" class="difflineplus">+  // returns true if everything is OK. Returns false if there was some error</span>
<a href="#l10.53"></a><span id="l10.53" class="difflineplus">+  // encountered.  In that case, we reset the parser.</span>
<a href="#l10.54"></a><span id="l10.54">   virtual bool GetNextLineForParser(char **nextLine) = 0;</span>
<a href="#l10.55"></a><span id="l10.55"> </span>
<a href="#l10.56"></a><span id="l10.56">   virtual void HandleMemoryFailure();</span>
<a href="#l10.57"></a><span id="l10.57">   void skip_to_CRLF();</span>
<a href="#l10.58"></a><span id="l10.58">   void skip_to_close_paren();</span>
<a href="#l10.59"></a><span id="l10.59">   char *CreateString();</span>
<a href="#l10.60"></a><span id="l10.60">   char *CreateAstring();</span>
<a href="#l10.61"></a><span id="l10.61">   char *CreateNilString();</span>
<a href="#l10.62"></a><span id="l10.62" class="difflineat">@@ -50,25 +48,27 @@ protected:</span>
<a href="#l10.63"></a><span id="l10.63">   char *CreateParenGroup();</span>
<a href="#l10.64"></a><span id="l10.64">   virtual void SetSyntaxError(bool error, const char *msg);</span>
<a href="#l10.65"></a><span id="l10.65"> </span>
<a href="#l10.66"></a><span id="l10.66">   void AdvanceToNextToken();</span>
<a href="#l10.67"></a><span id="l10.67">   void AdvanceToNextLine();</span>
<a href="#l10.68"></a><span id="l10.68">   void AdvanceTokenizerStartingPoint(int32_t bytesToAdvance);</span>
<a href="#l10.69"></a><span id="l10.69">   void ResetLexAnalyzer();</span>
<a href="#l10.70"></a><span id="l10.70"> </span>
<a href="#l10.71"></a><span id="l10.71" class="difflineminus">-protected:</span>
<a href="#l10.72"></a><span id="l10.72" class="difflineplus">+ protected:</span>
<a href="#l10.73"></a><span id="l10.73">   // use with care</span>
<a href="#l10.74"></a><span id="l10.74" class="difflineminus">-  const char     *fNextToken;</span>
<a href="#l10.75"></a><span id="l10.75" class="difflineminus">-  char           *fCurrentLine;</span>
<a href="#l10.76"></a><span id="l10.76" class="difflineminus">-  char           *fLineOfTokens;</span>
<a href="#l10.77"></a><span id="l10.77" class="difflineminus">-  char           *fStartOfLineOfTokens;</span>
<a href="#l10.78"></a><span id="l10.78" class="difflineminus">-  char           *fCurrentTokenPlaceHolder;</span>
<a href="#l10.79"></a><span id="l10.79" class="difflineminus">-  bool            fAtEndOfLine;</span>
<a href="#l10.80"></a><span id="l10.80" class="difflineplus">+  const char *fNextToken;</span>
<a href="#l10.81"></a><span id="l10.81" class="difflineplus">+  char *fCurrentLine;</span>
<a href="#l10.82"></a><span id="l10.82" class="difflineplus">+  char *fLineOfTokens;</span>
<a href="#l10.83"></a><span id="l10.83" class="difflineplus">+  char *fStartOfLineOfTokens;</span>
<a href="#l10.84"></a><span id="l10.84" class="difflineplus">+  char *fCurrentTokenPlaceHolder;</span>
<a href="#l10.85"></a><span id="l10.85" class="difflineplus">+  bool fAtEndOfLine;</span>
<a href="#l10.86"></a><span id="l10.86"> </span>
<a href="#l10.87"></a><span id="l10.87" class="difflineminus">-private:</span>
<a href="#l10.88"></a><span id="l10.88" class="difflineminus">-  enum nsIMAPGenericParserState { stateOK = 0,</span>
<a href="#l10.89"></a><span id="l10.89" class="difflineminus">-                                  stateSyntaxErrorFlag = 0x1,</span>
<a href="#l10.90"></a><span id="l10.90" class="difflineminus">-                                  stateDisconnectedFlag = 0x2 };</span>
<a href="#l10.91"></a><span id="l10.91" class="difflineplus">+ private:</span>
<a href="#l10.92"></a><span id="l10.92" class="difflineplus">+  enum nsIMAPGenericParserState {</span>
<a href="#l10.93"></a><span id="l10.93" class="difflineplus">+    stateOK = 0,</span>
<a href="#l10.94"></a><span id="l10.94" class="difflineplus">+    stateSyntaxErrorFlag = 0x1,</span>
<a href="#l10.95"></a><span id="l10.95" class="difflineplus">+    stateDisconnectedFlag = 0x2</span>
<a href="#l10.96"></a><span id="l10.96" class="difflineplus">+  };</span>
<a href="#l10.97"></a><span id="l10.97">   uint32_t fParserState;</span>
<a href="#l10.98"></a><span id="l10.98"> };</span>
<a href="#l10.99"></a><span id="l10.99"> </span>
<a href="#l10.100"></a><span id="l10.100"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPHostSessionList.cpp</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPHostSessionList.cpp</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -11,29 +11,29 @@</span>
<a href="#l11.4"></a><span id="l11.4"> #include &quot;nsCOMPtr.h&quot;</span>
<a href="#l11.5"></a><span id="l11.5"> #include &quot;nsIMsgIncomingServer.h&quot;</span>
<a href="#l11.6"></a><span id="l11.6"> #include &quot;nsIObserverService.h&quot;</span>
<a href="#l11.7"></a><span id="l11.7"> #include &quot;nsServiceManagerUtils.h&quot;</span>
<a href="#l11.8"></a><span id="l11.8"> #include &quot;nsMsgUtils.h&quot;</span>
<a href="#l11.9"></a><span id="l11.9"> #include &quot;mozilla/Services.h&quot;</span>
<a href="#l11.10"></a><span id="l11.10"> </span>
<a href="#l11.11"></a><span id="l11.11"> nsIMAPHostInfo::nsIMAPHostInfo(const char *serverKey,</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-                               nsIImapIncomingServer *server)</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineminus">-{</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineplus">+                               nsIImapIncomingServer *server) {</span>
<a href="#l11.15"></a><span id="l11.15">   fServerKey = serverKey;</span>
<a href="#l11.16"></a><span id="l11.16">   NS_ASSERTION(server, &quot;*** Fatal null imap incoming server...&quot;);</span>
<a href="#l11.17"></a><span id="l11.17">   server-&gt;GetServerDirectory(fOnlineDir);</span>
<a href="#l11.18"></a><span id="l11.18">   fNextHost = NULL;</span>
<a href="#l11.19"></a><span id="l11.19">   fCapabilityFlags = kCapabilityUndefined;</span>
<a href="#l11.20"></a><span id="l11.20">   fHierarchyDelimiters = NULL;</span>
<a href="#l11.21"></a><span id="l11.21"> #ifdef DEBUG_bienvenu1</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineminus">-  fHaveWeEverDiscoveredFolders = true; // try this, see what bad happens - we'll need to</span>
<a href="#l11.23"></a><span id="l11.23" class="difflineminus">-  // figure out a way to make new accounts have it be false</span>
<a href="#l11.24"></a><span id="l11.24" class="difflineplus">+  fHaveWeEverDiscoveredFolders =</span>
<a href="#l11.25"></a><span id="l11.25" class="difflineplus">+      true;  // try this, see what bad happens - we'll need to</span>
<a href="#l11.26"></a><span id="l11.26" class="difflineplus">+             // figure out a way to make new accounts have it be false</span>
<a href="#l11.27"></a><span id="l11.27"> #else</span>
<a href="#l11.28"></a><span id="l11.28" class="difflineminus">-  fHaveWeEverDiscoveredFolders = false; // try this, see what bad happens</span>
<a href="#l11.29"></a><span id="l11.29" class="difflineplus">+  fHaveWeEverDiscoveredFolders = false;  // try this, see what bad happens</span>
<a href="#l11.30"></a><span id="l11.30"> #endif</span>
<a href="#l11.31"></a><span id="l11.31">   fCanonicalOnlineSubDir = NULL;</span>
<a href="#l11.32"></a><span id="l11.32">   fNamespaceList = nsIMAPNamespaceList::CreatensIMAPNamespaceList();</span>
<a href="#l11.33"></a><span id="l11.33">   fUsingSubscription = true;</span>
<a href="#l11.34"></a><span id="l11.34">   server-&gt;GetUsingSubscription(&amp;fUsingSubscription);</span>
<a href="#l11.35"></a><span id="l11.35">   fOnlineTrashFolderExists = false;</span>
<a href="#l11.36"></a><span id="l11.36">   fShouldAlwaysListInbox = true;</span>
<a href="#l11.37"></a><span id="l11.37">   fShellCache = nsIMAPBodyShellCache::Create();</span>
<a href="#l11.38"></a><span id="l11.38" class="difflineat">@@ -42,653 +42,575 @@ nsIMAPHostInfo::nsIMAPHostInfo(const cha</span>
<a href="#l11.39"></a><span id="l11.39">   fShowDeletedMessages = false;</span>
<a href="#l11.40"></a><span id="l11.40">   fGotNamespaces = false;</span>
<a href="#l11.41"></a><span id="l11.41">   fHaveAdminURL = false;</span>
<a href="#l11.42"></a><span id="l11.42">   fNamespacesOverridable = true;</span>
<a href="#l11.43"></a><span id="l11.43">   server-&gt;GetOverrideNamespaces(&amp;fNamespacesOverridable);</span>
<a href="#l11.44"></a><span id="l11.44">   fTempNamespaceList = nsIMAPNamespaceList::CreatensIMAPNamespaceList();</span>
<a href="#l11.45"></a><span id="l11.45"> }</span>
<a href="#l11.46"></a><span id="l11.46"> </span>
<a href="#l11.47"></a><span id="l11.47" class="difflineminus">-nsIMAPHostInfo::~nsIMAPHostInfo()</span>
<a href="#l11.48"></a><span id="l11.48" class="difflineminus">-{</span>
<a href="#l11.49"></a><span id="l11.49" class="difflineplus">+nsIMAPHostInfo::~nsIMAPHostInfo() {</span>
<a href="#l11.50"></a><span id="l11.50">   PR_Free(fHierarchyDelimiters);</span>
<a href="#l11.51"></a><span id="l11.51">   delete fNamespaceList;</span>
<a href="#l11.52"></a><span id="l11.52">   delete fTempNamespaceList;</span>
<a href="#l11.53"></a><span id="l11.53">   delete fShellCache;</span>
<a href="#l11.54"></a><span id="l11.54"> }</span>
<a href="#l11.55"></a><span id="l11.55"> </span>
<a href="#l11.56"></a><span id="l11.56" class="difflineminus">-NS_IMPL_ISUPPORTS(nsIMAPHostSessionList,</span>
<a href="#l11.57"></a><span id="l11.57" class="difflineminus">-                              nsIImapHostSessionList,</span>
<a href="#l11.58"></a><span id="l11.58" class="difflineminus">-                              nsIObserver,</span>
<a href="#l11.59"></a><span id="l11.59" class="difflineminus">-                              nsISupportsWeakReference)</span>
<a href="#l11.60"></a><span id="l11.60" class="difflineplus">+NS_IMPL_ISUPPORTS(nsIMAPHostSessionList, nsIImapHostSessionList, nsIObserver,</span>
<a href="#l11.61"></a><span id="l11.61" class="difflineplus">+                  nsISupportsWeakReference)</span>
<a href="#l11.62"></a><span id="l11.62"> </span>
<a href="#l11.63"></a><span id="l11.63" class="difflineminus">-</span>
<a href="#l11.64"></a><span id="l11.64" class="difflineminus">-nsIMAPHostSessionList::nsIMAPHostSessionList()</span>
<a href="#l11.65"></a><span id="l11.65" class="difflineminus">-{</span>
<a href="#l11.66"></a><span id="l11.66" class="difflineplus">+nsIMAPHostSessionList::nsIMAPHostSessionList() {</span>
<a href="#l11.67"></a><span id="l11.67">   gCachedHostInfoMonitor = PR_NewMonitor(/* &quot;accessing-hostlist-monitor&quot;*/);</span>
<a href="#l11.68"></a><span id="l11.68">   fHostInfoList = nullptr;</span>
<a href="#l11.69"></a><span id="l11.69"> }</span>
<a href="#l11.70"></a><span id="l11.70"> </span>
<a href="#l11.71"></a><span id="l11.71" class="difflineminus">-nsIMAPHostSessionList::~nsIMAPHostSessionList()</span>
<a href="#l11.72"></a><span id="l11.72" class="difflineminus">-{</span>
<a href="#l11.73"></a><span id="l11.73" class="difflineplus">+nsIMAPHostSessionList::~nsIMAPHostSessionList() {</span>
<a href="#l11.74"></a><span id="l11.74">   ResetAll();</span>
<a href="#l11.75"></a><span id="l11.75">   PR_DestroyMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.76"></a><span id="l11.76"> }</span>
<a href="#l11.77"></a><span id="l11.77"> </span>
<a href="#l11.78"></a><span id="l11.78" class="difflineminus">-nsresult nsIMAPHostSessionList::Init()</span>
<a href="#l11.79"></a><span id="l11.79" class="difflineminus">-{</span>
<a href="#l11.80"></a><span id="l11.80" class="difflineplus">+nsresult nsIMAPHostSessionList::Init() {</span>
<a href="#l11.81"></a><span id="l11.81">   nsCOMPtr&lt;nsIObserverService&gt; observerService =</span>
<a href="#l11.82"></a><span id="l11.82" class="difflineminus">-    mozilla::services::GetObserverService();</span>
<a href="#l11.83"></a><span id="l11.83" class="difflineplus">+      mozilla::services::GetObserverService();</span>
<a href="#l11.84"></a><span id="l11.84">   NS_ENSURE_TRUE(observerService, NS_ERROR_UNEXPECTED);</span>
<a href="#l11.85"></a><span id="l11.85">   observerService-&gt;AddObserver(this, &quot;profile-before-change&quot;, true);</span>
<a href="#l11.86"></a><span id="l11.86">   observerService-&gt;AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, true);</span>
<a href="#l11.87"></a><span id="l11.87">   return NS_OK;</span>
<a href="#l11.88"></a><span id="l11.88"> }</span>
<a href="#l11.89"></a><span id="l11.89"> </span>
<a href="#l11.90"></a><span id="l11.90" class="difflineminus">-</span>
<a href="#l11.91"></a><span id="l11.91" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::Observe(nsISupports *aSubject, const char *aTopic, const char16_t *someData)</span>
<a href="#l11.92"></a><span id="l11.92" class="difflineminus">-{</span>
<a href="#l11.93"></a><span id="l11.93" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::Observe(nsISupports *aSubject,</span>
<a href="#l11.94"></a><span id="l11.94" class="difflineplus">+                                             const char *aTopic,</span>
<a href="#l11.95"></a><span id="l11.95" class="difflineplus">+                                             const char16_t *someData) {</span>
<a href="#l11.96"></a><span id="l11.96">   if (!strcmp(aTopic, &quot;profile-before-change&quot;))</span>
<a href="#l11.97"></a><span id="l11.97">     ResetAll();</span>
<a href="#l11.98"></a><span id="l11.98" class="difflineminus">-  else if (!strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID))</span>
<a href="#l11.99"></a><span id="l11.99" class="difflineminus">-  {</span>
<a href="#l11.100"></a><span id="l11.100" class="difflineplus">+  else if (!strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID)) {</span>
<a href="#l11.101"></a><span id="l11.101">     nsCOMPtr&lt;nsIObserverService&gt; observerService =</span>
<a href="#l11.102"></a><span id="l11.102" class="difflineminus">-      mozilla::services::GetObserverService();</span>
<a href="#l11.103"></a><span id="l11.103" class="difflineplus">+        mozilla::services::GetObserverService();</span>
<a href="#l11.104"></a><span id="l11.104">     NS_ENSURE_TRUE(observerService, NS_ERROR_UNEXPECTED);</span>
<a href="#l11.105"></a><span id="l11.105">     observerService-&gt;RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);</span>
<a href="#l11.106"></a><span id="l11.106">     observerService-&gt;RemoveObserver(this, &quot;profile-before-change&quot;);</span>
<a href="#l11.107"></a><span id="l11.107">   }</span>
<a href="#l11.108"></a><span id="l11.108">   return NS_OK;</span>
<a href="#l11.109"></a><span id="l11.109"> }</span>
<a href="#l11.110"></a><span id="l11.110"> </span>
<a href="#l11.111"></a><span id="l11.111" class="difflineminus">-nsIMAPHostInfo *nsIMAPHostSessionList::FindHost(const char *serverKey)</span>
<a href="#l11.112"></a><span id="l11.112" class="difflineminus">-{</span>
<a href="#l11.113"></a><span id="l11.113" class="difflineplus">+nsIMAPHostInfo *nsIMAPHostSessionList::FindHost(const char *serverKey) {</span>
<a href="#l11.114"></a><span id="l11.114">   nsIMAPHostInfo *host;</span>
<a href="#l11.115"></a><span id="l11.115"> </span>
<a href="#l11.116"></a><span id="l11.116">   // ### should also check userName here, if NON NULL</span>
<a href="#l11.117"></a><span id="l11.117" class="difflineminus">-  for (host = fHostInfoList; host; host = host-&gt;fNextHost)</span>
<a href="#l11.118"></a><span id="l11.118" class="difflineminus">-  {</span>
<a href="#l11.119"></a><span id="l11.119" class="difflineminus">-    if (host-&gt;fServerKey.Equals(serverKey, nsCaseInsensitiveCStringComparator()))</span>
<a href="#l11.120"></a><span id="l11.120" class="difflineplus">+  for (host = fHostInfoList; host; host = host-&gt;fNextHost) {</span>
<a href="#l11.121"></a><span id="l11.121" class="difflineplus">+    if (host-&gt;fServerKey.Equals(serverKey,</span>
<a href="#l11.122"></a><span id="l11.122" class="difflineplus">+                                nsCaseInsensitiveCStringComparator()))</span>
<a href="#l11.123"></a><span id="l11.123">       return host;</span>
<a href="#l11.124"></a><span id="l11.124">   }</span>
<a href="#l11.125"></a><span id="l11.125">   return host;</span>
<a href="#l11.126"></a><span id="l11.126"> }</span>
<a href="#l11.127"></a><span id="l11.127"> </span>
<a href="#l11.128"></a><span id="l11.128"> // reset any cached connection info - delete the lot of 'em</span>
<a href="#l11.129"></a><span id="l11.129" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::ResetAll()</span>
<a href="#l11.130"></a><span id="l11.130" class="difflineminus">-{</span>
<a href="#l11.131"></a><span id="l11.131" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::ResetAll() {</span>
<a href="#l11.132"></a><span id="l11.132">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.133"></a><span id="l11.133">   nsIMAPHostInfo *nextHost = NULL;</span>
<a href="#l11.134"></a><span id="l11.134" class="difflineminus">-  for (nsIMAPHostInfo *host = fHostInfoList; host; host = nextHost)</span>
<a href="#l11.135"></a><span id="l11.135" class="difflineminus">-  {</span>
<a href="#l11.136"></a><span id="l11.136" class="difflineplus">+  for (nsIMAPHostInfo *host = fHostInfoList; host; host = nextHost) {</span>
<a href="#l11.137"></a><span id="l11.137">     nextHost = host-&gt;fNextHost;</span>
<a href="#l11.138"></a><span id="l11.138">     delete host;</span>
<a href="#l11.139"></a><span id="l11.139">   }</span>
<a href="#l11.140"></a><span id="l11.140">   fHostInfoList = NULL;</span>
<a href="#l11.141"></a><span id="l11.141">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.142"></a><span id="l11.142">   return NS_OK;</span>
<a href="#l11.143"></a><span id="l11.143"> }</span>
<a href="#l11.144"></a><span id="l11.144"> </span>
<a href="#l11.145"></a><span id="l11.145"> NS_IMETHODIMP</span>
<a href="#l11.146"></a><span id="l11.146"> nsIMAPHostSessionList::AddHostToList(const char *serverKey,</span>
<a href="#l11.147"></a><span id="l11.147" class="difflineminus">-                                     nsIImapIncomingServer *server)</span>
<a href="#l11.148"></a><span id="l11.148" class="difflineminus">-{</span>
<a href="#l11.149"></a><span id="l11.149" class="difflineminus">-  nsIMAPHostInfo *newHost=NULL;</span>
<a href="#l11.150"></a><span id="l11.150" class="difflineplus">+                                     nsIImapIncomingServer *server) {</span>
<a href="#l11.151"></a><span id="l11.151" class="difflineplus">+  nsIMAPHostInfo *newHost = NULL;</span>
<a href="#l11.152"></a><span id="l11.152">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.153"></a><span id="l11.153" class="difflineminus">-  if (!FindHost(serverKey))</span>
<a href="#l11.154"></a><span id="l11.154" class="difflineminus">-  {</span>
<a href="#l11.155"></a><span id="l11.155" class="difflineplus">+  if (!FindHost(serverKey)) {</span>
<a href="#l11.156"></a><span id="l11.156">     // stick it on the front</span>
<a href="#l11.157"></a><span id="l11.157">     newHost = new nsIMAPHostInfo(serverKey, server);</span>
<a href="#l11.158"></a><span id="l11.158" class="difflineminus">-    if (newHost)</span>
<a href="#l11.159"></a><span id="l11.159" class="difflineminus">-    {</span>
<a href="#l11.160"></a><span id="l11.160" class="difflineplus">+    if (newHost) {</span>
<a href="#l11.161"></a><span id="l11.161">       newHost-&gt;fNextHost = fHostInfoList;</span>
<a href="#l11.162"></a><span id="l11.162">       fHostInfoList = newHost;</span>
<a href="#l11.163"></a><span id="l11.163">     }</span>
<a href="#l11.164"></a><span id="l11.164">   }</span>
<a href="#l11.165"></a><span id="l11.165">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.166"></a><span id="l11.166">   return (newHost == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.167"></a><span id="l11.167"> }</span>
<a href="#l11.168"></a><span id="l11.168"> </span>
<a href="#l11.169"></a><span id="l11.169" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetPasswordForHost(const char *serverKey, nsString &amp;result)</span>
<a href="#l11.170"></a><span id="l11.170" class="difflineminus">-{</span>
<a href="#l11.171"></a><span id="l11.171" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetPasswordForHost(const char *serverKey,</span>
<a href="#l11.172"></a><span id="l11.172" class="difflineplus">+                                                        nsString &amp;result) {</span>
<a href="#l11.173"></a><span id="l11.173">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.174"></a><span id="l11.174">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.175"></a><span id="l11.175" class="difflineminus">-  if (host)</span>
<a href="#l11.176"></a><span id="l11.176" class="difflineminus">-    result = host-&gt;fCachedPassword;</span>
<a href="#l11.177"></a><span id="l11.177" class="difflineplus">+  if (host) result = host-&gt;fCachedPassword;</span>
<a href="#l11.178"></a><span id="l11.178">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.179"></a><span id="l11.179">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.180"></a><span id="l11.180"> }</span>
<a href="#l11.181"></a><span id="l11.181"> </span>
<a href="#l11.182"></a><span id="l11.182" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::SetPasswordForHost(const char *serverKey, const nsAString &amp;password)</span>
<a href="#l11.183"></a><span id="l11.183" class="difflineminus">-{</span>
<a href="#l11.184"></a><span id="l11.184" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::SetPasswordForHost(</span>
<a href="#l11.185"></a><span id="l11.185" class="difflineplus">+    const char *serverKey, const nsAString &amp;password) {</span>
<a href="#l11.186"></a><span id="l11.186">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.187"></a><span id="l11.187">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.188"></a><span id="l11.188" class="difflineminus">-  if (host)</span>
<a href="#l11.189"></a><span id="l11.189" class="difflineminus">-    host-&gt;fCachedPassword = password;</span>
<a href="#l11.190"></a><span id="l11.190" class="difflineplus">+  if (host) host-&gt;fCachedPassword = password;</span>
<a href="#l11.191"></a><span id="l11.191">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.192"></a><span id="l11.192">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.193"></a><span id="l11.193"> }</span>
<a href="#l11.194"></a><span id="l11.194"> </span>
<a href="#l11.195"></a><span id="l11.195" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::SetPasswordVerifiedOnline(const char *serverKey)</span>
<a href="#l11.196"></a><span id="l11.196" class="difflineminus">-{</span>
<a href="#l11.197"></a><span id="l11.197" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::SetPasswordVerifiedOnline(</span>
<a href="#l11.198"></a><span id="l11.198" class="difflineplus">+    const char *serverKey) {</span>
<a href="#l11.199"></a><span id="l11.199">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.200"></a><span id="l11.200">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.201"></a><span id="l11.201" class="difflineminus">-  if (host)</span>
<a href="#l11.202"></a><span id="l11.202" class="difflineminus">-    host-&gt;fPasswordVerifiedOnline = true;</span>
<a href="#l11.203"></a><span id="l11.203" class="difflineplus">+  if (host) host-&gt;fPasswordVerifiedOnline = true;</span>
<a href="#l11.204"></a><span id="l11.204">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.205"></a><span id="l11.205">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.206"></a><span id="l11.206"> }</span>
<a href="#l11.207"></a><span id="l11.207"> </span>
<a href="#l11.208"></a><span id="l11.208" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetPasswordVerifiedOnline(const char *serverKey, bool &amp;result)</span>
<a href="#l11.209"></a><span id="l11.209" class="difflineminus">-{</span>
<a href="#l11.210"></a><span id="l11.210" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetPasswordVerifiedOnline(</span>
<a href="#l11.211"></a><span id="l11.211" class="difflineplus">+    const char *serverKey, bool &amp;result) {</span>
<a href="#l11.212"></a><span id="l11.212">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.213"></a><span id="l11.213">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.214"></a><span id="l11.214" class="difflineminus">-  if (host)</span>
<a href="#l11.215"></a><span id="l11.215" class="difflineminus">-    result = host-&gt;fPasswordVerifiedOnline;</span>
<a href="#l11.216"></a><span id="l11.216" class="difflineplus">+  if (host) result = host-&gt;fPasswordVerifiedOnline;</span>
<a href="#l11.217"></a><span id="l11.217">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.218"></a><span id="l11.218">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.219"></a><span id="l11.219"> }</span>
<a href="#l11.220"></a><span id="l11.220"> </span>
<a href="#l11.221"></a><span id="l11.221"> NS_IMETHODIMP nsIMAPHostSessionList::GetOnlineDirForHost(const char *serverKey,</span>
<a href="#l11.222"></a><span id="l11.222" class="difflineminus">-                                                         nsString &amp;result)</span>
<a href="#l11.223"></a><span id="l11.223" class="difflineminus">-{</span>
<a href="#l11.224"></a><span id="l11.224" class="difflineplus">+                                                         nsString &amp;result) {</span>
<a href="#l11.225"></a><span id="l11.225">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.226"></a><span id="l11.226">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.227"></a><span id="l11.227" class="difflineminus">-  if (host)</span>
<a href="#l11.228"></a><span id="l11.228" class="difflineminus">-    CopyASCIItoUTF16(host-&gt;fOnlineDir, result);</span>
<a href="#l11.229"></a><span id="l11.229" class="difflineplus">+  if (host) CopyASCIItoUTF16(host-&gt;fOnlineDir, result);</span>
<a href="#l11.230"></a><span id="l11.230">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.231"></a><span id="l11.231">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.232"></a><span id="l11.232"> }</span>
<a href="#l11.233"></a><span id="l11.233"> </span>
<a href="#l11.234"></a><span id="l11.234" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::SetOnlineDirForHost(const char *serverKey,</span>
<a href="#l11.235"></a><span id="l11.235" class="difflineminus">-                                                         const char *onlineDir)</span>
<a href="#l11.236"></a><span id="l11.236" class="difflineminus">-{</span>
<a href="#l11.237"></a><span id="l11.237" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::SetOnlineDirForHost(</span>
<a href="#l11.238"></a><span id="l11.238" class="difflineplus">+    const char *serverKey, const char *onlineDir) {</span>
<a href="#l11.239"></a><span id="l11.239">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.240"></a><span id="l11.240">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.241"></a><span id="l11.241" class="difflineminus">-  if (host)</span>
<a href="#l11.242"></a><span id="l11.242" class="difflineminus">-  {</span>
<a href="#l11.243"></a><span id="l11.243" class="difflineminus">-    if (onlineDir)</span>
<a href="#l11.244"></a><span id="l11.244" class="difflineminus">-      host-&gt;fOnlineDir = onlineDir;</span>
<a href="#l11.245"></a><span id="l11.245" class="difflineplus">+  if (host) {</span>
<a href="#l11.246"></a><span id="l11.246" class="difflineplus">+    if (onlineDir) host-&gt;fOnlineDir = onlineDir;</span>
<a href="#l11.247"></a><span id="l11.247">   }</span>
<a href="#l11.248"></a><span id="l11.248">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.249"></a><span id="l11.249">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.250"></a><span id="l11.250"> }</span>
<a href="#l11.251"></a><span id="l11.251"> </span>
<a href="#l11.252"></a><span id="l11.252" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetDeleteIsMoveToTrashForHost(const char *serverKey, bool &amp;result)</span>
<a href="#l11.253"></a><span id="l11.253" class="difflineminus">-{</span>
<a href="#l11.254"></a><span id="l11.254" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetDeleteIsMoveToTrashForHost(</span>
<a href="#l11.255"></a><span id="l11.255" class="difflineplus">+    const char *serverKey, bool &amp;result) {</span>
<a href="#l11.256"></a><span id="l11.256">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.257"></a><span id="l11.257">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.258"></a><span id="l11.258" class="difflineminus">-  if (host)</span>
<a href="#l11.259"></a><span id="l11.259" class="difflineminus">-    result = host-&gt;fDeleteIsMoveToTrash;</span>
<a href="#l11.260"></a><span id="l11.260" class="difflineplus">+  if (host) result = host-&gt;fDeleteIsMoveToTrash;</span>
<a href="#l11.261"></a><span id="l11.261">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.262"></a><span id="l11.262">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.263"></a><span id="l11.263"> }</span>
<a href="#l11.264"></a><span id="l11.264"> </span>
<a href="#l11.265"></a><span id="l11.265" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetShowDeletedMessagesForHost(const char *serverKey, bool &amp;result)</span>
<a href="#l11.266"></a><span id="l11.266" class="difflineminus">-{</span>
<a href="#l11.267"></a><span id="l11.267" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetShowDeletedMessagesForHost(</span>
<a href="#l11.268"></a><span id="l11.268" class="difflineplus">+    const char *serverKey, bool &amp;result) {</span>
<a href="#l11.269"></a><span id="l11.269">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.270"></a><span id="l11.270">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.271"></a><span id="l11.271" class="difflineminus">-  if (host)</span>
<a href="#l11.272"></a><span id="l11.272" class="difflineminus">-    result = host-&gt;fShowDeletedMessages;</span>
<a href="#l11.273"></a><span id="l11.273" class="difflineplus">+  if (host) result = host-&gt;fShowDeletedMessages;</span>
<a href="#l11.274"></a><span id="l11.274">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.275"></a><span id="l11.275">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.276"></a><span id="l11.276"> }</span>
<a href="#l11.277"></a><span id="l11.277"> </span>
<a href="#l11.278"></a><span id="l11.278" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::SetDeleteIsMoveToTrashForHost(const char *serverKey, bool isMoveToTrash)</span>
<a href="#l11.279"></a><span id="l11.279" class="difflineminus">-{</span>
<a href="#l11.280"></a><span id="l11.280" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::SetDeleteIsMoveToTrashForHost(</span>
<a href="#l11.281"></a><span id="l11.281" class="difflineplus">+    const char *serverKey, bool isMoveToTrash) {</span>
<a href="#l11.282"></a><span id="l11.282">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.283"></a><span id="l11.283">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.284"></a><span id="l11.284" class="difflineminus">-  if (host)</span>
<a href="#l11.285"></a><span id="l11.285" class="difflineminus">-    host-&gt;fDeleteIsMoveToTrash = isMoveToTrash;</span>
<a href="#l11.286"></a><span id="l11.286" class="difflineplus">+  if (host) host-&gt;fDeleteIsMoveToTrash = isMoveToTrash;</span>
<a href="#l11.287"></a><span id="l11.287">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.288"></a><span id="l11.288">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.289"></a><span id="l11.289"> }</span>
<a href="#l11.290"></a><span id="l11.290"> </span>
<a href="#l11.291"></a><span id="l11.291" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::SetShowDeletedMessagesForHost(const char *serverKey, bool showDeletedMessages)</span>
<a href="#l11.292"></a><span id="l11.292" class="difflineminus">-{</span>
<a href="#l11.293"></a><span id="l11.293" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::SetShowDeletedMessagesForHost(</span>
<a href="#l11.294"></a><span id="l11.294" class="difflineplus">+    const char *serverKey, bool showDeletedMessages) {</span>
<a href="#l11.295"></a><span id="l11.295">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.296"></a><span id="l11.296">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.297"></a><span id="l11.297" class="difflineminus">-  if (host)</span>
<a href="#l11.298"></a><span id="l11.298" class="difflineminus">-    host-&gt;fShowDeletedMessages = showDeletedMessages;</span>
<a href="#l11.299"></a><span id="l11.299" class="difflineplus">+  if (host) host-&gt;fShowDeletedMessages = showDeletedMessages;</span>
<a href="#l11.300"></a><span id="l11.300">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.301"></a><span id="l11.301">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.302"></a><span id="l11.302"> }</span>
<a href="#l11.303"></a><span id="l11.303"> </span>
<a href="#l11.304"></a><span id="l11.304" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetGotNamespacesForHost(const char *serverKey, bool &amp;result)</span>
<a href="#l11.305"></a><span id="l11.305" class="difflineminus">-{</span>
<a href="#l11.306"></a><span id="l11.306" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetGotNamespacesForHost(</span>
<a href="#l11.307"></a><span id="l11.307" class="difflineplus">+    const char *serverKey, bool &amp;result) {</span>
<a href="#l11.308"></a><span id="l11.308">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.309"></a><span id="l11.309">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.310"></a><span id="l11.310" class="difflineminus">-  if (host)</span>
<a href="#l11.311"></a><span id="l11.311" class="difflineminus">-    result = host-&gt;fGotNamespaces;</span>
<a href="#l11.312"></a><span id="l11.312" class="difflineplus">+  if (host) result = host-&gt;fGotNamespaces;</span>
<a href="#l11.313"></a><span id="l11.313">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.314"></a><span id="l11.314">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.315"></a><span id="l11.315"> }</span>
<a href="#l11.316"></a><span id="l11.316"> </span>
<a href="#l11.317"></a><span id="l11.317" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::SetGotNamespacesForHost(const char *serverKey, bool gotNamespaces)</span>
<a href="#l11.318"></a><span id="l11.318" class="difflineminus">-{</span>
<a href="#l11.319"></a><span id="l11.319" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::SetGotNamespacesForHost(</span>
<a href="#l11.320"></a><span id="l11.320" class="difflineplus">+    const char *serverKey, bool gotNamespaces) {</span>
<a href="#l11.321"></a><span id="l11.321">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.322"></a><span id="l11.322">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.323"></a><span id="l11.323" class="difflineminus">-  if (host)</span>
<a href="#l11.324"></a><span id="l11.324" class="difflineminus">-    host-&gt;fGotNamespaces = gotNamespaces;</span>
<a href="#l11.325"></a><span id="l11.325" class="difflineplus">+  if (host) host-&gt;fGotNamespaces = gotNamespaces;</span>
<a href="#l11.326"></a><span id="l11.326">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.327"></a><span id="l11.327">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.328"></a><span id="l11.328"> }</span>
<a href="#l11.329"></a><span id="l11.329"> </span>
<a href="#l11.330"></a><span id="l11.330" class="difflineminus">-</span>
<a href="#l11.331"></a><span id="l11.331" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetHostIsUsingSubscription(const char *serverKey, bool &amp;result)</span>
<a href="#l11.332"></a><span id="l11.332" class="difflineminus">-{</span>
<a href="#l11.333"></a><span id="l11.333" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetHostIsUsingSubscription(</span>
<a href="#l11.334"></a><span id="l11.334" class="difflineplus">+    const char *serverKey, bool &amp;result) {</span>
<a href="#l11.335"></a><span id="l11.335">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.336"></a><span id="l11.336">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.337"></a><span id="l11.337" class="difflineminus">-  if (host)</span>
<a href="#l11.338"></a><span id="l11.338" class="difflineminus">-    result = host-&gt;fUsingSubscription;</span>
<a href="#l11.339"></a><span id="l11.339" class="difflineplus">+  if (host) result = host-&gt;fUsingSubscription;</span>
<a href="#l11.340"></a><span id="l11.340">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.341"></a><span id="l11.341">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.342"></a><span id="l11.342"> }</span>
<a href="#l11.343"></a><span id="l11.343"> </span>
<a href="#l11.344"></a><span id="l11.344" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::SetHostIsUsingSubscription(const char *serverKey, bool usingSubscription)</span>
<a href="#l11.345"></a><span id="l11.345" class="difflineminus">-{</span>
<a href="#l11.346"></a><span id="l11.346" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::SetHostIsUsingSubscription(</span>
<a href="#l11.347"></a><span id="l11.347" class="difflineplus">+    const char *serverKey, bool usingSubscription) {</span>
<a href="#l11.348"></a><span id="l11.348">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.349"></a><span id="l11.349">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.350"></a><span id="l11.350" class="difflineminus">-  if (host)</span>
<a href="#l11.351"></a><span id="l11.351" class="difflineminus">-    host-&gt;fUsingSubscription = usingSubscription;</span>
<a href="#l11.352"></a><span id="l11.352" class="difflineplus">+  if (host) host-&gt;fUsingSubscription = usingSubscription;</span>
<a href="#l11.353"></a><span id="l11.353">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.354"></a><span id="l11.354">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.355"></a><span id="l11.355"> }</span>
<a href="#l11.356"></a><span id="l11.356"> </span>
<a href="#l11.357"></a><span id="l11.357" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetHostHasAdminURL(const char *serverKey, bool &amp;result)</span>
<a href="#l11.358"></a><span id="l11.358" class="difflineminus">-{</span>
<a href="#l11.359"></a><span id="l11.359" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetHostHasAdminURL(const char *serverKey,</span>
<a href="#l11.360"></a><span id="l11.360" class="difflineplus">+                                                        bool &amp;result) {</span>
<a href="#l11.361"></a><span id="l11.361">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.362"></a><span id="l11.362">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.363"></a><span id="l11.363" class="difflineminus">-  if (host)</span>
<a href="#l11.364"></a><span id="l11.364" class="difflineminus">-    result = host-&gt;fHaveAdminURL;</span>
<a href="#l11.365"></a><span id="l11.365" class="difflineplus">+  if (host) result = host-&gt;fHaveAdminURL;</span>
<a href="#l11.366"></a><span id="l11.366">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.367"></a><span id="l11.367">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.368"></a><span id="l11.368"> }</span>
<a href="#l11.369"></a><span id="l11.369"> </span>
<a href="#l11.370"></a><span id="l11.370" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::SetHostHasAdminURL(const char *serverKey, bool haveAdminURL)</span>
<a href="#l11.371"></a><span id="l11.371" class="difflineminus">-{</span>
<a href="#l11.372"></a><span id="l11.372" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::SetHostHasAdminURL(const char *serverKey,</span>
<a href="#l11.373"></a><span id="l11.373" class="difflineplus">+                                                        bool haveAdminURL) {</span>
<a href="#l11.374"></a><span id="l11.374">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.375"></a><span id="l11.375">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.376"></a><span id="l11.376" class="difflineminus">-  if (host)</span>
<a href="#l11.377"></a><span id="l11.377" class="difflineminus">-    host-&gt;fHaveAdminURL = haveAdminURL;</span>
<a href="#l11.378"></a><span id="l11.378" class="difflineplus">+  if (host) host-&gt;fHaveAdminURL = haveAdminURL;</span>
<a href="#l11.379"></a><span id="l11.379">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.380"></a><span id="l11.380">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.381"></a><span id="l11.381"> }</span>
<a href="#l11.382"></a><span id="l11.382"> </span>
<a href="#l11.383"></a><span id="l11.383" class="difflineminus">-</span>
<a href="#l11.384"></a><span id="l11.384" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetHaveWeEverDiscoveredFoldersForHost(const char *serverKey, bool &amp;result)</span>
<a href="#l11.385"></a><span id="l11.385" class="difflineminus">-{</span>
<a href="#l11.386"></a><span id="l11.386" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetHaveWeEverDiscoveredFoldersForHost(</span>
<a href="#l11.387"></a><span id="l11.387" class="difflineplus">+    const char *serverKey, bool &amp;result) {</span>
<a href="#l11.388"></a><span id="l11.388">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.389"></a><span id="l11.389">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.390"></a><span id="l11.390" class="difflineminus">-  if (host)</span>
<a href="#l11.391"></a><span id="l11.391" class="difflineminus">-    result = host-&gt;fHaveWeEverDiscoveredFolders;</span>
<a href="#l11.392"></a><span id="l11.392" class="difflineplus">+  if (host) result = host-&gt;fHaveWeEverDiscoveredFolders;</span>
<a href="#l11.393"></a><span id="l11.393">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.394"></a><span id="l11.394">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.395"></a><span id="l11.395"> }</span>
<a href="#l11.396"></a><span id="l11.396"> </span>
<a href="#l11.397"></a><span id="l11.397" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::SetHaveWeEverDiscoveredFoldersForHost(const char *serverKey, bool discovered)</span>
<a href="#l11.398"></a><span id="l11.398" class="difflineminus">-{</span>
<a href="#l11.399"></a><span id="l11.399" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::SetHaveWeEverDiscoveredFoldersForHost(</span>
<a href="#l11.400"></a><span id="l11.400" class="difflineplus">+    const char *serverKey, bool discovered) {</span>
<a href="#l11.401"></a><span id="l11.401">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.402"></a><span id="l11.402">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.403"></a><span id="l11.403" class="difflineminus">-  if (host)</span>
<a href="#l11.404"></a><span id="l11.404" class="difflineminus">-    host-&gt;fHaveWeEverDiscoveredFolders = discovered;</span>
<a href="#l11.405"></a><span id="l11.405" class="difflineplus">+  if (host) host-&gt;fHaveWeEverDiscoveredFolders = discovered;</span>
<a href="#l11.406"></a><span id="l11.406">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.407"></a><span id="l11.407">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.408"></a><span id="l11.408"> }</span>
<a href="#l11.409"></a><span id="l11.409"> </span>
<a href="#l11.410"></a><span id="l11.410" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::SetOnlineTrashFolderExistsForHost(const char *serverKey, bool exists)</span>
<a href="#l11.411"></a><span id="l11.411" class="difflineminus">-{</span>
<a href="#l11.412"></a><span id="l11.412" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::SetOnlineTrashFolderExistsForHost(</span>
<a href="#l11.413"></a><span id="l11.413" class="difflineplus">+    const char *serverKey, bool exists) {</span>
<a href="#l11.414"></a><span id="l11.414">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.415"></a><span id="l11.415">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.416"></a><span id="l11.416" class="difflineminus">-  if (host)</span>
<a href="#l11.417"></a><span id="l11.417" class="difflineminus">-    host-&gt;fOnlineTrashFolderExists = exists;</span>
<a href="#l11.418"></a><span id="l11.418" class="difflineplus">+  if (host) host-&gt;fOnlineTrashFolderExists = exists;</span>
<a href="#l11.419"></a><span id="l11.419">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.420"></a><span id="l11.420">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.421"></a><span id="l11.421"> }</span>
<a href="#l11.422"></a><span id="l11.422"> </span>
<a href="#l11.423"></a><span id="l11.423" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetOnlineTrashFolderExistsForHost(const char *serverKey, bool &amp;result)</span>
<a href="#l11.424"></a><span id="l11.424" class="difflineminus">-{</span>
<a href="#l11.425"></a><span id="l11.425" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetOnlineTrashFolderExistsForHost(</span>
<a href="#l11.426"></a><span id="l11.426" class="difflineplus">+    const char *serverKey, bool &amp;result) {</span>
<a href="#l11.427"></a><span id="l11.427">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.428"></a><span id="l11.428">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.429"></a><span id="l11.429" class="difflineminus">-  if (host)</span>
<a href="#l11.430"></a><span id="l11.430" class="difflineminus">-    result = host-&gt;fOnlineTrashFolderExists;</span>
<a href="#l11.431"></a><span id="l11.431" class="difflineplus">+  if (host) result = host-&gt;fOnlineTrashFolderExists;</span>
<a href="#l11.432"></a><span id="l11.432">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.433"></a><span id="l11.433">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.434"></a><span id="l11.434"> }</span>
<a href="#l11.435"></a><span id="l11.435"> </span>
<a href="#l11.436"></a><span id="l11.436" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::AddNewNamespaceForHost(const char *serverKey, nsIMAPNamespace *ns)</span>
<a href="#l11.437"></a><span id="l11.437" class="difflineminus">-{</span>
<a href="#l11.438"></a><span id="l11.438" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::AddNewNamespaceForHost(</span>
<a href="#l11.439"></a><span id="l11.439" class="difflineplus">+    const char *serverKey, nsIMAPNamespace *ns) {</span>
<a href="#l11.440"></a><span id="l11.440">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.441"></a><span id="l11.441">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.442"></a><span id="l11.442" class="difflineminus">-  if (host)</span>
<a href="#l11.443"></a><span id="l11.443" class="difflineminus">-    host-&gt;fNamespaceList-&gt;AddNewNamespace(ns);</span>
<a href="#l11.444"></a><span id="l11.444" class="difflineplus">+  if (host) host-&gt;fNamespaceList-&gt;AddNewNamespace(ns);</span>
<a href="#l11.445"></a><span id="l11.445">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.446"></a><span id="l11.446">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.447"></a><span id="l11.447"> }</span>
<a href="#l11.448"></a><span id="l11.448"> </span>
<a href="#l11.449"></a><span id="l11.449" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::SetNamespaceFromPrefForHost(const char *serverKey,</span>
<a href="#l11.450"></a><span id="l11.450" class="difflineminus">-                                                                 const char *namespacePref, EIMAPNamespaceType nstype)</span>
<a href="#l11.451"></a><span id="l11.451" class="difflineminus">-{</span>
<a href="#l11.452"></a><span id="l11.452" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::SetNamespaceFromPrefForHost(</span>
<a href="#l11.453"></a><span id="l11.453" class="difflineplus">+    const char *serverKey, const char *namespacePref,</span>
<a href="#l11.454"></a><span id="l11.454" class="difflineplus">+    EIMAPNamespaceType nstype) {</span>
<a href="#l11.455"></a><span id="l11.455">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.456"></a><span id="l11.456">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.457"></a><span id="l11.457" class="difflineminus">-  if (host)</span>
<a href="#l11.458"></a><span id="l11.458" class="difflineminus">-  {</span>
<a href="#l11.459"></a><span id="l11.459" class="difflineminus">-    if (namespacePref)</span>
<a href="#l11.460"></a><span id="l11.460" class="difflineminus">-    {</span>
<a href="#l11.461"></a><span id="l11.461" class="difflineminus">-      int numNamespaces = host-&gt;fNamespaceList-&gt;UnserializeNamespaces(namespacePref, nullptr, 0);</span>
<a href="#l11.462"></a><span id="l11.462" class="difflineminus">-      char **prefixes = (char**) PR_CALLOC(numNamespaces * sizeof(char*));</span>
<a href="#l11.463"></a><span id="l11.463" class="difflineminus">-      if (prefixes)</span>
<a href="#l11.464"></a><span id="l11.464" class="difflineminus">-      {</span>
<a href="#l11.465"></a><span id="l11.465" class="difflineminus">-        int len = host-&gt;fNamespaceList-&gt;UnserializeNamespaces(namespacePref, prefixes, numNamespaces);</span>
<a href="#l11.466"></a><span id="l11.466" class="difflineminus">-        for (int i = 0; i &lt; len; i++)</span>
<a href="#l11.467"></a><span id="l11.467" class="difflineminus">-        {</span>
<a href="#l11.468"></a><span id="l11.468" class="difflineplus">+  if (host) {</span>
<a href="#l11.469"></a><span id="l11.469" class="difflineplus">+    if (namespacePref) {</span>
<a href="#l11.470"></a><span id="l11.470" class="difflineplus">+      int numNamespaces = host-&gt;fNamespaceList-&gt;UnserializeNamespaces(</span>
<a href="#l11.471"></a><span id="l11.471" class="difflineplus">+          namespacePref, nullptr, 0);</span>
<a href="#l11.472"></a><span id="l11.472" class="difflineplus">+      char **prefixes = (char **)PR_CALLOC(numNamespaces * sizeof(char *));</span>
<a href="#l11.473"></a><span id="l11.473" class="difflineplus">+      if (prefixes) {</span>
<a href="#l11.474"></a><span id="l11.474" class="difflineplus">+        int len = host-&gt;fNamespaceList-&gt;UnserializeNamespaces(</span>
<a href="#l11.475"></a><span id="l11.475" class="difflineplus">+            namespacePref, prefixes, numNamespaces);</span>
<a href="#l11.476"></a><span id="l11.476" class="difflineplus">+        for (int i = 0; i &lt; len; i++) {</span>
<a href="#l11.477"></a><span id="l11.477">           char *thisns = prefixes[i];</span>
<a href="#l11.478"></a><span id="l11.478">           char delimiter = '/';  // a guess</span>
<a href="#l11.479"></a><span id="l11.479" class="difflineminus">-          if (PL_strlen(thisns) &gt;= 1)</span>
<a href="#l11.480"></a><span id="l11.480" class="difflineminus">-            delimiter = thisns[PL_strlen(thisns)-1];</span>
<a href="#l11.481"></a><span id="l11.481" class="difflineminus">-          nsIMAPNamespace *ns = new nsIMAPNamespace(nstype, thisns, delimiter, true);</span>
<a href="#l11.482"></a><span id="l11.482" class="difflineminus">-          if (ns)</span>
<a href="#l11.483"></a><span id="l11.483" class="difflineminus">-            host-&gt;fNamespaceList-&gt;AddNewNamespace(ns);</span>
<a href="#l11.484"></a><span id="l11.484" class="difflineplus">+          if (PL_strlen(thisns) &gt;= 1) delimiter = thisns[PL_strlen(thisns) - 1];</span>
<a href="#l11.485"></a><span id="l11.485" class="difflineplus">+          nsIMAPNamespace *ns =</span>
<a href="#l11.486"></a><span id="l11.486" class="difflineplus">+              new nsIMAPNamespace(nstype, thisns, delimiter, true);</span>
<a href="#l11.487"></a><span id="l11.487" class="difflineplus">+          if (ns) host-&gt;fNamespaceList-&gt;AddNewNamespace(ns);</span>
<a href="#l11.488"></a><span id="l11.488">           PR_FREEIF(thisns);</span>
<a href="#l11.489"></a><span id="l11.489">         }</span>
<a href="#l11.490"></a><span id="l11.490">         PR_Free(prefixes);</span>
<a href="#l11.491"></a><span id="l11.491">       }</span>
<a href="#l11.492"></a><span id="l11.492">     }</span>
<a href="#l11.493"></a><span id="l11.493">   }</span>
<a href="#l11.494"></a><span id="l11.494">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.495"></a><span id="l11.495">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.496"></a><span id="l11.496"> }</span>
<a href="#l11.497"></a><span id="l11.497"> </span>
<a href="#l11.498"></a><span id="l11.498" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetNamespaceForMailboxForHost(const char *serverKey, const char *mailbox_name, nsIMAPNamespace * &amp;result)</span>
<a href="#l11.499"></a><span id="l11.499" class="difflineminus">-{</span>
<a href="#l11.500"></a><span id="l11.500" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetNamespaceForMailboxForHost(</span>
<a href="#l11.501"></a><span id="l11.501" class="difflineplus">+    const char *serverKey, const char *mailbox_name, nsIMAPNamespace *&amp;result) {</span>
<a href="#l11.502"></a><span id="l11.502">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.503"></a><span id="l11.503">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.504"></a><span id="l11.504" class="difflineminus">-  if (host)</span>
<a href="#l11.505"></a><span id="l11.505" class="difflineminus">-    result = host-&gt;fNamespaceList-&gt;GetNamespaceForMailbox(mailbox_name);</span>
<a href="#l11.506"></a><span id="l11.506" class="difflineplus">+  if (host) result = host-&gt;fNamespaceList-&gt;GetNamespaceForMailbox(mailbox_name);</span>
<a href="#l11.507"></a><span id="l11.507">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.508"></a><span id="l11.508">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.509"></a><span id="l11.509"> }</span>
<a href="#l11.510"></a><span id="l11.510"> </span>
<a href="#l11.511"></a><span id="l11.511" class="difflineminus">-</span>
<a href="#l11.512"></a><span id="l11.512" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::ClearPrefsNamespacesForHost(const char *serverKey)</span>
<a href="#l11.513"></a><span id="l11.513" class="difflineminus">-{</span>
<a href="#l11.514"></a><span id="l11.514" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::ClearPrefsNamespacesForHost(</span>
<a href="#l11.515"></a><span id="l11.515" class="difflineplus">+    const char *serverKey) {</span>
<a href="#l11.516"></a><span id="l11.516">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.517"></a><span id="l11.517">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.518"></a><span id="l11.518" class="difflineminus">-  if (host)</span>
<a href="#l11.519"></a><span id="l11.519" class="difflineminus">-    host-&gt;fNamespaceList-&gt;ClearNamespaces(true, false, true);</span>
<a href="#l11.520"></a><span id="l11.520" class="difflineplus">+  if (host) host-&gt;fNamespaceList-&gt;ClearNamespaces(true, false, true);</span>
<a href="#l11.521"></a><span id="l11.521">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.522"></a><span id="l11.522">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.523"></a><span id="l11.523"> }</span>
<a href="#l11.524"></a><span id="l11.524"> </span>
<a href="#l11.525"></a><span id="l11.525" class="difflineminus">-</span>
<a href="#l11.526"></a><span id="l11.526" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::ClearServerAdvertisedNamespacesForHost(const char *serverKey)</span>
<a href="#l11.527"></a><span id="l11.527" class="difflineminus">-{</span>
<a href="#l11.528"></a><span id="l11.528" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::ClearServerAdvertisedNamespacesForHost(</span>
<a href="#l11.529"></a><span id="l11.529" class="difflineplus">+    const char *serverKey) {</span>
<a href="#l11.530"></a><span id="l11.530">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.531"></a><span id="l11.531">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.532"></a><span id="l11.532" class="difflineminus">-  if (host)</span>
<a href="#l11.533"></a><span id="l11.533" class="difflineminus">-    host-&gt;fNamespaceList-&gt;ClearNamespaces(false, true, true);</span>
<a href="#l11.534"></a><span id="l11.534" class="difflineplus">+  if (host) host-&gt;fNamespaceList-&gt;ClearNamespaces(false, true, true);</span>
<a href="#l11.535"></a><span id="l11.535">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.536"></a><span id="l11.536">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.537"></a><span id="l11.537"> }</span>
<a href="#l11.538"></a><span id="l11.538"> </span>
<a href="#l11.539"></a><span id="l11.539" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetDefaultNamespaceOfTypeForHost(const char *serverKey, EIMAPNamespaceType type, nsIMAPNamespace * &amp;result)</span>
<a href="#l11.540"></a><span id="l11.540" class="difflineminus">-{</span>
<a href="#l11.541"></a><span id="l11.541" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetDefaultNamespaceOfTypeForHost(</span>
<a href="#l11.542"></a><span id="l11.542" class="difflineplus">+    const char *serverKey, EIMAPNamespaceType type, nsIMAPNamespace *&amp;result) {</span>
<a href="#l11.543"></a><span id="l11.543">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.544"></a><span id="l11.544">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.545"></a><span id="l11.545" class="difflineminus">-  if (host)</span>
<a href="#l11.546"></a><span id="l11.546" class="difflineminus">-    result = host-&gt;fNamespaceList-&gt;GetDefaultNamespaceOfType(type);</span>
<a href="#l11.547"></a><span id="l11.547" class="difflineplus">+  if (host) result = host-&gt;fNamespaceList-&gt;GetDefaultNamespaceOfType(type);</span>
<a href="#l11.548"></a><span id="l11.548">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.549"></a><span id="l11.549">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.550"></a><span id="l11.550"> }</span>
<a href="#l11.551"></a><span id="l11.551"> </span>
<a href="#l11.552"></a><span id="l11.552" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetNamespacesOverridableForHost(const char *serverKey, bool &amp;result)</span>
<a href="#l11.553"></a><span id="l11.553" class="difflineminus">-{</span>
<a href="#l11.554"></a><span id="l11.554" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetNamespacesOverridableForHost(</span>
<a href="#l11.555"></a><span id="l11.555" class="difflineplus">+    const char *serverKey, bool &amp;result) {</span>
<a href="#l11.556"></a><span id="l11.556">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.557"></a><span id="l11.557">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.558"></a><span id="l11.558" class="difflineminus">-  if (host)</span>
<a href="#l11.559"></a><span id="l11.559" class="difflineminus">-    result = host-&gt;fNamespacesOverridable;</span>
<a href="#l11.560"></a><span id="l11.560" class="difflineplus">+  if (host) result = host-&gt;fNamespacesOverridable;</span>
<a href="#l11.561"></a><span id="l11.561">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.562"></a><span id="l11.562">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.563"></a><span id="l11.563"> }</span>
<a href="#l11.564"></a><span id="l11.564"> </span>
<a href="#l11.565"></a><span id="l11.565" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::SetNamespacesOverridableForHost(const char *serverKey, bool overridable)</span>
<a href="#l11.566"></a><span id="l11.566" class="difflineminus">-{</span>
<a href="#l11.567"></a><span id="l11.567" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::SetNamespacesOverridableForHost(</span>
<a href="#l11.568"></a><span id="l11.568" class="difflineplus">+    const char *serverKey, bool overridable) {</span>
<a href="#l11.569"></a><span id="l11.569">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.570"></a><span id="l11.570">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.571"></a><span id="l11.571" class="difflineminus">-  if (host)</span>
<a href="#l11.572"></a><span id="l11.572" class="difflineminus">-    host-&gt;fNamespacesOverridable = overridable;</span>
<a href="#l11.573"></a><span id="l11.573" class="difflineplus">+  if (host) host-&gt;fNamespacesOverridable = overridable;</span>
<a href="#l11.574"></a><span id="l11.574">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.575"></a><span id="l11.575">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.576"></a><span id="l11.576"> }</span>
<a href="#l11.577"></a><span id="l11.577"> </span>
<a href="#l11.578"></a><span id="l11.578" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetNumberOfNamespacesForHost(const char *serverKey, uint32_t &amp;result)</span>
<a href="#l11.579"></a><span id="l11.579" class="difflineminus">-{</span>
<a href="#l11.580"></a><span id="l11.580" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetNumberOfNamespacesForHost(</span>
<a href="#l11.581"></a><span id="l11.581" class="difflineplus">+    const char *serverKey, uint32_t &amp;result) {</span>
<a href="#l11.582"></a><span id="l11.582">   int32_t intResult = 0;</span>
<a href="#l11.583"></a><span id="l11.583"> </span>
<a href="#l11.584"></a><span id="l11.584">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.585"></a><span id="l11.585">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.586"></a><span id="l11.586" class="difflineminus">-  if (host)</span>
<a href="#l11.587"></a><span id="l11.587" class="difflineminus">-    intResult = host-&gt;fNamespaceList-&gt;GetNumberOfNamespaces();</span>
<a href="#l11.588"></a><span id="l11.588" class="difflineplus">+  if (host) intResult = host-&gt;fNamespaceList-&gt;GetNumberOfNamespaces();</span>
<a href="#l11.589"></a><span id="l11.589">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.590"></a><span id="l11.590">   NS_ASSERTION(intResult &gt;= 0, &quot;negative number of namespaces&quot;);</span>
<a href="#l11.591"></a><span id="l11.591" class="difflineminus">-  result = (uint32_t) intResult;</span>
<a href="#l11.592"></a><span id="l11.592" class="difflineplus">+  result = (uint32_t)intResult;</span>
<a href="#l11.593"></a><span id="l11.593">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.594"></a><span id="l11.594"> }</span>
<a href="#l11.595"></a><span id="l11.595"> </span>
<a href="#l11.596"></a><span id="l11.596" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetNamespaceNumberForHost(const char *serverKey, int32_t n, nsIMAPNamespace * &amp;result)</span>
<a href="#l11.597"></a><span id="l11.597" class="difflineminus">-{</span>
<a href="#l11.598"></a><span id="l11.598" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetNamespaceNumberForHost(</span>
<a href="#l11.599"></a><span id="l11.599" class="difflineplus">+    const char *serverKey, int32_t n, nsIMAPNamespace *&amp;result) {</span>
<a href="#l11.600"></a><span id="l11.600">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.601"></a><span id="l11.601">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.602"></a><span id="l11.602" class="difflineminus">-  if (host)</span>
<a href="#l11.603"></a><span id="l11.603" class="difflineminus">-    result = host-&gt;fNamespaceList-&gt;GetNamespaceNumber(n);</span>
<a href="#l11.604"></a><span id="l11.604" class="difflineplus">+  if (host) result = host-&gt;fNamespaceList-&gt;GetNamespaceNumber(n);</span>
<a href="#l11.605"></a><span id="l11.605">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.606"></a><span id="l11.606">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.607"></a><span id="l11.607"> }</span>
<a href="#l11.608"></a><span id="l11.608"> </span>
<a href="#l11.609"></a><span id="l11.609" class="difflineminus">-nsresult nsIMAPHostSessionList::SetNamespacesPrefForHost(nsIImapIncomingServer *aHost,</span>
<a href="#l11.610"></a><span id="l11.610" class="difflineminus">-                                                         EIMAPNamespaceType type,</span>
<a href="#l11.611"></a><span id="l11.611" class="difflineminus">-                                                         const char *pref)</span>
<a href="#l11.612"></a><span id="l11.612" class="difflineminus">-{</span>
<a href="#l11.613"></a><span id="l11.613" class="difflineplus">+nsresult nsIMAPHostSessionList::SetNamespacesPrefForHost(</span>
<a href="#l11.614"></a><span id="l11.614" class="difflineplus">+    nsIImapIncomingServer *aHost, EIMAPNamespaceType type, const char *pref) {</span>
<a href="#l11.615"></a><span id="l11.615">   if (type == kPersonalNamespace)</span>
<a href="#l11.616"></a><span id="l11.616">     aHost-&gt;SetPersonalNamespace(nsDependentCString(pref));</span>
<a href="#l11.617"></a><span id="l11.617">   else if (type == kPublicNamespace)</span>
<a href="#l11.618"></a><span id="l11.618">     aHost-&gt;SetPublicNamespace(nsDependentCString(pref));</span>
<a href="#l11.619"></a><span id="l11.619">   else if (type == kOtherUsersNamespace)</span>
<a href="#l11.620"></a><span id="l11.620">     aHost-&gt;SetOtherUsersNamespace(nsDependentCString(pref));</span>
<a href="#l11.621"></a><span id="l11.621">   else</span>
<a href="#l11.622"></a><span id="l11.622">     NS_ASSERTION(false, &quot;bogus namespace type&quot;);</span>
<a href="#l11.623"></a><span id="l11.623">   return NS_OK;</span>
<a href="#l11.624"></a><span id="l11.624" class="difflineminus">-</span>
<a href="#l11.625"></a><span id="l11.625"> }</span>
<a href="#l11.626"></a><span id="l11.626"> // do we need this? What should we do about the master thing?</span>
<a href="#l11.627"></a><span id="l11.627"> // Make sure this is running in the Mozilla thread when called</span>
<a href="#l11.628"></a><span id="l11.628" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::CommitNamespacesForHost(nsIImapIncomingServer *aHost)</span>
<a href="#l11.629"></a><span id="l11.629" class="difflineminus">-{</span>
<a href="#l11.630"></a><span id="l11.630" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::CommitNamespacesForHost(</span>
<a href="#l11.631"></a><span id="l11.631" class="difflineplus">+    nsIImapIncomingServer *aHost) {</span>
<a href="#l11.632"></a><span id="l11.632">   NS_ENSURE_ARG_POINTER(aHost);</span>
<a href="#l11.633"></a><span id="l11.633">   nsCString serverKey;</span>
<a href="#l11.634"></a><span id="l11.634" class="difflineminus">-  nsCOMPtr &lt;nsIMsgIncomingServer&gt; incomingServer = do_QueryInterface(aHost);</span>
<a href="#l11.635"></a><span id="l11.635" class="difflineminus">-  if (!incomingServer)</span>
<a href="#l11.636"></a><span id="l11.636" class="difflineminus">-    return NS_ERROR_NULL_POINTER;</span>
<a href="#l11.637"></a><span id="l11.637" class="difflineplus">+  nsCOMPtr&lt;nsIMsgIncomingServer&gt; incomingServer = do_QueryInterface(aHost);</span>
<a href="#l11.638"></a><span id="l11.638" class="difflineplus">+  if (!incomingServer) return NS_ERROR_NULL_POINTER;</span>
<a href="#l11.639"></a><span id="l11.639"> </span>
<a href="#l11.640"></a><span id="l11.640">   nsresult rv = incomingServer-&gt;GetKey(serverKey);</span>
<a href="#l11.641"></a><span id="l11.641">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l11.642"></a><span id="l11.642"> </span>
<a href="#l11.643"></a><span id="l11.643">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.644"></a><span id="l11.644">   nsIMAPHostInfo *host = FindHost(serverKey.get());</span>
<a href="#l11.645"></a><span id="l11.645" class="difflineminus">-  if (host)</span>
<a href="#l11.646"></a><span id="l11.646" class="difflineminus">-  {</span>
<a href="#l11.647"></a><span id="l11.647" class="difflineminus">-    host-&gt;fGotNamespaces = true;  // so we only issue NAMESPACE once per host per session.</span>
<a href="#l11.648"></a><span id="l11.648" class="difflineplus">+  if (host) {</span>
<a href="#l11.649"></a><span id="l11.649" class="difflineplus">+    host-&gt;fGotNamespaces =</span>
<a href="#l11.650"></a><span id="l11.650" class="difflineplus">+        true;  // so we only issue NAMESPACE once per host per session.</span>
<a href="#l11.651"></a><span id="l11.651">     EIMAPNamespaceType type = kPersonalNamespace;</span>
<a href="#l11.652"></a><span id="l11.652" class="difflineminus">-    for (int i = 1; i &lt;= 3; i++)</span>
<a href="#l11.653"></a><span id="l11.653" class="difflineminus">-    {</span>
<a href="#l11.654"></a><span id="l11.654" class="difflineminus">-      switch(i)</span>
<a href="#l11.655"></a><span id="l11.655" class="difflineminus">-      {</span>
<a href="#l11.656"></a><span id="l11.656" class="difflineminus">-      case 1:</span>
<a href="#l11.657"></a><span id="l11.657" class="difflineminus">-        type = kPersonalNamespace;</span>
<a href="#l11.658"></a><span id="l11.658" class="difflineminus">-        break;</span>
<a href="#l11.659"></a><span id="l11.659" class="difflineminus">-      case 2:</span>
<a href="#l11.660"></a><span id="l11.660" class="difflineminus">-        type = kPublicNamespace;</span>
<a href="#l11.661"></a><span id="l11.661" class="difflineminus">-        break;</span>
<a href="#l11.662"></a><span id="l11.662" class="difflineminus">-      case 3:</span>
<a href="#l11.663"></a><span id="l11.663" class="difflineminus">-        type = kOtherUsersNamespace;</span>
<a href="#l11.664"></a><span id="l11.664" class="difflineminus">-        break;</span>
<a href="#l11.665"></a><span id="l11.665" class="difflineminus">-      default:</span>
<a href="#l11.666"></a><span id="l11.666" class="difflineminus">-        type = kPersonalNamespace;</span>
<a href="#l11.667"></a><span id="l11.667" class="difflineminus">-        break;</span>
<a href="#l11.668"></a><span id="l11.668" class="difflineplus">+    for (int i = 1; i &lt;= 3; i++) {</span>
<a href="#l11.669"></a><span id="l11.669" class="difflineplus">+      switch (i) {</span>
<a href="#l11.670"></a><span id="l11.670" class="difflineplus">+        case 1:</span>
<a href="#l11.671"></a><span id="l11.671" class="difflineplus">+          type = kPersonalNamespace;</span>
<a href="#l11.672"></a><span id="l11.672" class="difflineplus">+          break;</span>
<a href="#l11.673"></a><span id="l11.673" class="difflineplus">+        case 2:</span>
<a href="#l11.674"></a><span id="l11.674" class="difflineplus">+          type = kPublicNamespace;</span>
<a href="#l11.675"></a><span id="l11.675" class="difflineplus">+          break;</span>
<a href="#l11.676"></a><span id="l11.676" class="difflineplus">+        case 3:</span>
<a href="#l11.677"></a><span id="l11.677" class="difflineplus">+          type = kOtherUsersNamespace;</span>
<a href="#l11.678"></a><span id="l11.678" class="difflineplus">+          break;</span>
<a href="#l11.679"></a><span id="l11.679" class="difflineplus">+        default:</span>
<a href="#l11.680"></a><span id="l11.680" class="difflineplus">+          type = kPersonalNamespace;</span>
<a href="#l11.681"></a><span id="l11.681" class="difflineplus">+          break;</span>
<a href="#l11.682"></a><span id="l11.682">       }</span>
<a href="#l11.683"></a><span id="l11.683"> </span>
<a href="#l11.684"></a><span id="l11.684">       int32_t numInNS = host-&gt;fNamespaceList-&gt;GetNumberOfNamespaces(type);</span>
<a href="#l11.685"></a><span id="l11.685">       if (numInNS == 0)</span>
<a href="#l11.686"></a><span id="l11.686">         SetNamespacesPrefForHost(aHost, type, &quot;&quot;);</span>
<a href="#l11.687"></a><span id="l11.687" class="difflineminus">-      else if (numInNS &gt;= 1)</span>
<a href="#l11.688"></a><span id="l11.688" class="difflineminus">-      {</span>
<a href="#l11.689"></a><span id="l11.689" class="difflineplus">+      else if (numInNS &gt;= 1) {</span>
<a href="#l11.690"></a><span id="l11.690">         char *pref = PR_smprintf(&quot;&quot;);</span>
<a href="#l11.691"></a><span id="l11.691" class="difflineminus">-        for (int count = 1; count &lt;= numInNS; count++)</span>
<a href="#l11.692"></a><span id="l11.692" class="difflineminus">-        {</span>
<a href="#l11.693"></a><span id="l11.693" class="difflineminus">-          nsIMAPNamespace *ns = host-&gt;fNamespaceList-&gt;GetNamespaceNumber(count, type);</span>
<a href="#l11.694"></a><span id="l11.694" class="difflineminus">-          if (ns)</span>
<a href="#l11.695"></a><span id="l11.695" class="difflineminus">-          {</span>
<a href="#l11.696"></a><span id="l11.696" class="difflineminus">-            if (count &gt; 1)</span>
<a href="#l11.697"></a><span id="l11.697" class="difflineminus">-            {</span>
<a href="#l11.698"></a><span id="l11.698" class="difflineplus">+        for (int count = 1; count &lt;= numInNS; count++) {</span>
<a href="#l11.699"></a><span id="l11.699" class="difflineplus">+          nsIMAPNamespace *ns =</span>
<a href="#l11.700"></a><span id="l11.700" class="difflineplus">+              host-&gt;fNamespaceList-&gt;GetNamespaceNumber(count, type);</span>
<a href="#l11.701"></a><span id="l11.701" class="difflineplus">+          if (ns) {</span>
<a href="#l11.702"></a><span id="l11.702" class="difflineplus">+            if (count &gt; 1) {</span>
<a href="#l11.703"></a><span id="l11.703">               // append the comma</span>
<a href="#l11.704"></a><span id="l11.704" class="difflineminus">-              char *tempPref = PR_smprintf(&quot;%s,&quot;,pref);</span>
<a href="#l11.705"></a><span id="l11.705" class="difflineplus">+              char *tempPref = PR_smprintf(&quot;%s,&quot;, pref);</span>
<a href="#l11.706"></a><span id="l11.706">               PR_FREEIF(pref);</span>
<a href="#l11.707"></a><span id="l11.707">               pref = tempPref;</span>
<a href="#l11.708"></a><span id="l11.708">             }</span>
<a href="#l11.709"></a><span id="l11.709" class="difflineminus">-            char *tempPref = PR_smprintf(&quot;%s\&quot;%s\&quot;&quot;,pref,ns-&gt;GetPrefix());</span>
<a href="#l11.710"></a><span id="l11.710" class="difflineplus">+            char *tempPref = PR_smprintf(&quot;%s\&quot;%s\&quot;&quot;, pref, ns-&gt;GetPrefix());</span>
<a href="#l11.711"></a><span id="l11.711">             PR_FREEIF(pref);</span>
<a href="#l11.712"></a><span id="l11.712">             pref = tempPref;</span>
<a href="#l11.713"></a><span id="l11.713">           }</span>
<a href="#l11.714"></a><span id="l11.714">         }</span>
<a href="#l11.715"></a><span id="l11.715" class="difflineminus">-        if (pref)</span>
<a href="#l11.716"></a><span id="l11.716" class="difflineminus">-        {</span>
<a href="#l11.717"></a><span id="l11.717" class="difflineplus">+        if (pref) {</span>
<a href="#l11.718"></a><span id="l11.718">           SetNamespacesPrefForHost(aHost, type, pref);</span>
<a href="#l11.719"></a><span id="l11.719">           PR_Free(pref);</span>
<a href="#l11.720"></a><span id="l11.720">         }</span>
<a href="#l11.721"></a><span id="l11.721">       }</span>
<a href="#l11.722"></a><span id="l11.722">     }</span>
<a href="#l11.723"></a><span id="l11.723">     // clear, but don't delete the entries in, the temp namespace list</span>
<a href="#l11.724"></a><span id="l11.724">     host-&gt;fTempNamespaceList-&gt;ClearNamespaces(true, true, false);</span>
<a href="#l11.725"></a><span id="l11.725"> </span>
<a href="#l11.726"></a><span id="l11.726">     // Now reset all of libmsg's namespace references.</span>
<a href="#l11.727"></a><span id="l11.727">     // Did I mention this needs to be running in the mozilla thread?</span>
<a href="#l11.728"></a><span id="l11.728">     aHost-&gt;ResetNamespaceReferences();</span>
<a href="#l11.729"></a><span id="l11.729">   }</span>
<a href="#l11.730"></a><span id="l11.730">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.731"></a><span id="l11.731">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.732"></a><span id="l11.732"> }</span>
<a href="#l11.733"></a><span id="l11.733"> </span>
<a href="#l11.734"></a><span id="l11.734" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::FlushUncommittedNamespacesForHost(const char *serverKey, bool &amp;result)</span>
<a href="#l11.735"></a><span id="l11.735" class="difflineminus">-{</span>
<a href="#l11.736"></a><span id="l11.736" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::FlushUncommittedNamespacesForHost(</span>
<a href="#l11.737"></a><span id="l11.737" class="difflineplus">+    const char *serverKey, bool &amp;result) {</span>
<a href="#l11.738"></a><span id="l11.738">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.739"></a><span id="l11.739">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.740"></a><span id="l11.740" class="difflineminus">-  if (host)</span>
<a href="#l11.741"></a><span id="l11.741" class="difflineminus">-    host-&gt;fTempNamespaceList-&gt;ClearNamespaces(true, true, true);</span>
<a href="#l11.742"></a><span id="l11.742" class="difflineplus">+  if (host) host-&gt;fTempNamespaceList-&gt;ClearNamespaces(true, true, true);</span>
<a href="#l11.743"></a><span id="l11.743">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.744"></a><span id="l11.744">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.745"></a><span id="l11.745"> }</span>
<a href="#l11.746"></a><span id="l11.746"> </span>
<a href="#l11.747"></a><span id="l11.747" class="difflineminus">-</span>
<a href="#l11.748"></a><span id="l11.748"> // Returns NULL if there is no personal namespace on the given host</span>
<a href="#l11.749"></a><span id="l11.749" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetOnlineInboxPathForHost(const char *serverKey, nsString &amp;result)</span>
<a href="#l11.750"></a><span id="l11.750" class="difflineminus">-{</span>
<a href="#l11.751"></a><span id="l11.751" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetOnlineInboxPathForHost(</span>
<a href="#l11.752"></a><span id="l11.752" class="difflineplus">+    const char *serverKey, nsString &amp;result) {</span>
<a href="#l11.753"></a><span id="l11.753">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.754"></a><span id="l11.754">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.755"></a><span id="l11.755" class="difflineminus">-  if (host)</span>
<a href="#l11.756"></a><span id="l11.756" class="difflineminus">-  {</span>
<a href="#l11.757"></a><span id="l11.757" class="difflineplus">+  if (host) {</span>
<a href="#l11.758"></a><span id="l11.758">     nsIMAPNamespace *ns = NULL;</span>
<a href="#l11.759"></a><span id="l11.759">     ns = host-&gt;fNamespaceList-&gt;GetDefaultNamespaceOfType(kPersonalNamespace);</span>
<a href="#l11.760"></a><span id="l11.760" class="difflineminus">-    if (ns)</span>
<a href="#l11.761"></a><span id="l11.761" class="difflineminus">-    {</span>
<a href="#l11.762"></a><span id="l11.762" class="difflineplus">+    if (ns) {</span>
<a href="#l11.763"></a><span id="l11.763">       CopyASCIItoUTF16(nsDependentCString(ns-&gt;GetPrefix()), result);</span>
<a href="#l11.764"></a><span id="l11.764">       result.AppendLiteral(&quot;INBOX&quot;);</span>
<a href="#l11.765"></a><span id="l11.765">     }</span>
<a href="#l11.766"></a><span id="l11.766" class="difflineminus">-  }</span>
<a href="#l11.767"></a><span id="l11.767" class="difflineminus">-  else</span>
<a href="#l11.768"></a><span id="l11.768" class="difflineplus">+  } else</span>
<a href="#l11.769"></a><span id="l11.769">     result.Truncate();</span>
<a href="#l11.770"></a><span id="l11.770">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.771"></a><span id="l11.771">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.772"></a><span id="l11.772"> }</span>
<a href="#l11.773"></a><span id="l11.773"> </span>
<a href="#l11.774"></a><span id="l11.774" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::GetShouldAlwaysListInboxForHost(const char* /*serverKey*/, bool &amp;result)</span>
<a href="#l11.775"></a><span id="l11.775" class="difflineminus">-{</span>
<a href="#l11.776"></a><span id="l11.776" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetShouldAlwaysListInboxForHost(</span>
<a href="#l11.777"></a><span id="l11.777" class="difflineplus">+    const char * /*serverKey*/, bool &amp;result) {</span>
<a href="#l11.778"></a><span id="l11.778">   result = true;</span>
<a href="#l11.779"></a><span id="l11.779"> </span>
<a href="#l11.780"></a><span id="l11.780">   /*</span>
<a href="#l11.781"></a><span id="l11.781">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.782"></a><span id="l11.782">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.783"></a><span id="l11.783">   if (host)</span>
<a href="#l11.784"></a><span id="l11.784">     ret = host-&gt;fShouldAlwaysListInbox;</span>
<a href="#l11.785"></a><span id="l11.785">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.786"></a><span id="l11.786">   */</span>
<a href="#l11.787"></a><span id="l11.787">   return NS_OK;</span>
<a href="#l11.788"></a><span id="l11.788"> }</span>
<a href="#l11.789"></a><span id="l11.789"> </span>
<a href="#l11.790"></a><span id="l11.790" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::SetShouldAlwaysListInboxForHost(const char *serverKey, bool shouldList)</span>
<a href="#l11.791"></a><span id="l11.791" class="difflineminus">-{</span>
<a href="#l11.792"></a><span id="l11.792" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::SetShouldAlwaysListInboxForHost(</span>
<a href="#l11.793"></a><span id="l11.793" class="difflineplus">+    const char *serverKey, bool shouldList) {</span>
<a href="#l11.794"></a><span id="l11.794">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.795"></a><span id="l11.795">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.796"></a><span id="l11.796" class="difflineminus">-  if (host)</span>
<a href="#l11.797"></a><span id="l11.797" class="difflineminus">-    host-&gt;fShouldAlwaysListInbox = shouldList;</span>
<a href="#l11.798"></a><span id="l11.798" class="difflineplus">+  if (host) host-&gt;fShouldAlwaysListInbox = shouldList;</span>
<a href="#l11.799"></a><span id="l11.799">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.800"></a><span id="l11.800">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.801"></a><span id="l11.801"> }</span>
<a href="#l11.802"></a><span id="l11.802"> </span>
<a href="#l11.803"></a><span id="l11.803" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::SetNamespaceHierarchyDelimiterFromMailboxForHost(const char *serverKey, const char *boxName, char delimiter)</span>
<a href="#l11.804"></a><span id="l11.804" class="difflineminus">-{</span>
<a href="#l11.805"></a><span id="l11.805" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l11.806"></a><span id="l11.806" class="difflineplus">+nsIMAPHostSessionList::SetNamespaceHierarchyDelimiterFromMailboxForHost(</span>
<a href="#l11.807"></a><span id="l11.807" class="difflineplus">+    const char *serverKey, const char *boxName, char delimiter) {</span>
<a href="#l11.808"></a><span id="l11.808">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.809"></a><span id="l11.809">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.810"></a><span id="l11.810" class="difflineminus">-  if (host)</span>
<a href="#l11.811"></a><span id="l11.811" class="difflineminus">-  {</span>
<a href="#l11.812"></a><span id="l11.812" class="difflineplus">+  if (host) {</span>
<a href="#l11.813"></a><span id="l11.813">     nsIMAPNamespace *ns = host-&gt;fNamespaceList-&gt;GetNamespaceForMailbox(boxName);</span>
<a href="#l11.814"></a><span id="l11.814" class="difflineminus">-    if (ns &amp;&amp; !ns-&gt;GetIsDelimiterFilledIn())</span>
<a href="#l11.815"></a><span id="l11.815" class="difflineminus">-      ns-&gt;SetDelimiter(delimiter, true);</span>
<a href="#l11.816"></a><span id="l11.816" class="difflineplus">+    if (ns &amp;&amp; !ns-&gt;GetIsDelimiterFilledIn()) ns-&gt;SetDelimiter(delimiter, true);</span>
<a href="#l11.817"></a><span id="l11.817">   }</span>
<a href="#l11.818"></a><span id="l11.818">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.819"></a><span id="l11.819" class="difflineminus">-  return (host) ? NS_OK : NS_ERROR_ILLEGAL_VALUE ;</span>
<a href="#l11.820"></a><span id="l11.820" class="difflineplus">+  return (host) ? NS_OK : NS_ERROR_ILLEGAL_VALUE;</span>
<a href="#l11.821"></a><span id="l11.821"> }</span>
<a href="#l11.822"></a><span id="l11.822"> </span>
<a href="#l11.823"></a><span id="l11.823" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::AddShellToCacheForHost(const char *serverKey, nsIMAPBodyShell *shell)</span>
<a href="#l11.824"></a><span id="l11.824" class="difflineminus">-{</span>
<a href="#l11.825"></a><span id="l11.825" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::AddShellToCacheForHost(</span>
<a href="#l11.826"></a><span id="l11.826" class="difflineplus">+    const char *serverKey, nsIMAPBodyShell *shell) {</span>
<a href="#l11.827"></a><span id="l11.827">   nsresult rv = NS_OK;</span>
<a href="#l11.828"></a><span id="l11.828">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.829"></a><span id="l11.829">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.830"></a><span id="l11.830" class="difflineminus">-  if (host)</span>
<a href="#l11.831"></a><span id="l11.831" class="difflineminus">-  {</span>
<a href="#l11.832"></a><span id="l11.832" class="difflineminus">-    if (host-&gt;fShellCache)</span>
<a href="#l11.833"></a><span id="l11.833" class="difflineminus">-    {</span>
<a href="#l11.834"></a><span id="l11.834" class="difflineminus">-      if (!host-&gt;fShellCache-&gt;AddShellToCache(shell))</span>
<a href="#l11.835"></a><span id="l11.835" class="difflineminus">-        rv = NS_ERROR_UNEXPECTED;</span>
<a href="#l11.836"></a><span id="l11.836" class="difflineplus">+  if (host) {</span>
<a href="#l11.837"></a><span id="l11.837" class="difflineplus">+    if (host-&gt;fShellCache) {</span>
<a href="#l11.838"></a><span id="l11.838" class="difflineplus">+      if (!host-&gt;fShellCache-&gt;AddShellToCache(shell)) rv = NS_ERROR_UNEXPECTED;</span>
<a href="#l11.839"></a><span id="l11.839">     }</span>
<a href="#l11.840"></a><span id="l11.840" class="difflineminus">-  }</span>
<a href="#l11.841"></a><span id="l11.841" class="difflineminus">-  else</span>
<a href="#l11.842"></a><span id="l11.842" class="difflineplus">+  } else</span>
<a href="#l11.843"></a><span id="l11.843">     rv = NS_ERROR_ILLEGAL_VALUE;</span>
<a href="#l11.844"></a><span id="l11.844"> </span>
<a href="#l11.845"></a><span id="l11.845">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.846"></a><span id="l11.846">   return rv;</span>
<a href="#l11.847"></a><span id="l11.847"> }</span>
<a href="#l11.848"></a><span id="l11.848"> </span>
<a href="#l11.849"></a><span id="l11.849" class="difflineminus">-NS_IMETHODIMP nsIMAPHostSessionList::FindShellInCacheForHost(const char *serverKey, const char *mailboxName, const char *UID,</span>
<a href="#l11.850"></a><span id="l11.850" class="difflineminus">-                                                             IMAP_ContentModifiedType modType, nsIMAPBodyShell **shell)</span>
<a href="#l11.851"></a><span id="l11.851" class="difflineminus">-{</span>
<a href="#l11.852"></a><span id="l11.852" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::FindShellInCacheForHost(</span>
<a href="#l11.853"></a><span id="l11.853" class="difflineplus">+    const char *serverKey, const char *mailboxName, const char *UID,</span>
<a href="#l11.854"></a><span id="l11.854" class="difflineplus">+    IMAP_ContentModifiedType modType, nsIMAPBodyShell **shell) {</span>
<a href="#l11.855"></a><span id="l11.855">   nsCString uidString(UID);</span>
<a href="#l11.856"></a><span id="l11.856"> </span>
<a href="#l11.857"></a><span id="l11.857">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.858"></a><span id="l11.858">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.859"></a><span id="l11.859">   if (host &amp;&amp; host-&gt;fShellCache)</span>
<a href="#l11.860"></a><span id="l11.860" class="difflineminus">-    NS_IF_ADDREF(*shell = host-&gt;fShellCache-&gt;FindShellForUID(uidString,</span>
<a href="#l11.861"></a><span id="l11.861" class="difflineminus">-                                                             mailboxName,</span>
<a href="#l11.862"></a><span id="l11.862" class="difflineminus">-                                                             modType));</span>
<a href="#l11.863"></a><span id="l11.863" class="difflineplus">+    NS_IF_ADDREF(*shell = host-&gt;fShellCache-&gt;FindShellForUID(</span>
<a href="#l11.864"></a><span id="l11.864" class="difflineplus">+                     uidString, mailboxName, modType));</span>
<a href="#l11.865"></a><span id="l11.865">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.866"></a><span id="l11.866">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.867"></a><span id="l11.867"> }</span>
<a href="#l11.868"></a><span id="l11.868"> </span>
<a href="#l11.869"></a><span id="l11.869"> NS_IMETHODIMP</span>
<a href="#l11.870"></a><span id="l11.870" class="difflineminus">-nsIMAPHostSessionList::ClearShellCacheForHost(const char *serverKey)</span>
<a href="#l11.871"></a><span id="l11.871" class="difflineminus">-{</span>
<a href="#l11.872"></a><span id="l11.872" class="difflineplus">+nsIMAPHostSessionList::ClearShellCacheForHost(const char *serverKey) {</span>
<a href="#l11.873"></a><span id="l11.873">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.874"></a><span id="l11.874">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l11.875"></a><span id="l11.875" class="difflineminus">-  if (host &amp;&amp; host-&gt;fShellCache)</span>
<a href="#l11.876"></a><span id="l11.876" class="difflineminus">-    host-&gt;fShellCache-&gt;Clear();</span>
<a href="#l11.877"></a><span id="l11.877" class="difflineplus">+  if (host &amp;&amp; host-&gt;fShellCache) host-&gt;fShellCache-&gt;Clear();</span>
<a href="#l11.878"></a><span id="l11.878">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l11.879"></a><span id="l11.879">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l11.880"></a><span id="l11.880"> }</span>
<a href="#l11.881"></a><span id="l11.881" class="difflineminus">-</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPHostSessionList.h</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPHostSessionList.h</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -12,125 +12,163 @@</span>
<a href="#l12.4"></a><span id="l12.4"> #include &quot;nsIMAPBodyShell.h&quot;</span>
<a href="#l12.5"></a><span id="l12.5"> #include &quot;nsIObserver.h&quot;</span>
<a href="#l12.6"></a><span id="l12.6"> #include &quot;nsWeakReference.h&quot;</span>
<a href="#l12.7"></a><span id="l12.7"> #include &quot;nspr.h&quot;</span>
<a href="#l12.8"></a><span id="l12.8"> </span>
<a href="#l12.9"></a><span id="l12.9"> class nsIMAPNamespaceList;</span>
<a href="#l12.10"></a><span id="l12.10"> class nsIImapIncomingServer;</span>
<a href="#l12.11"></a><span id="l12.11"> </span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-class nsIMAPHostInfo</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineminus">-{</span>
<a href="#l12.14"></a><span id="l12.14" class="difflineminus">-public:</span>
<a href="#l12.15"></a><span id="l12.15" class="difflineplus">+class nsIMAPHostInfo {</span>
<a href="#l12.16"></a><span id="l12.16" class="difflineplus">+ public:</span>
<a href="#l12.17"></a><span id="l12.17">   friend class nsIMAPHostSessionList;</span>
<a href="#l12.18"></a><span id="l12.18"> </span>
<a href="#l12.19"></a><span id="l12.19">   nsIMAPHostInfo(const char *serverKey, nsIImapIncomingServer *server);</span>
<a href="#l12.20"></a><span id="l12.20">   ~nsIMAPHostInfo();</span>
<a href="#l12.21"></a><span id="l12.21" class="difflineminus">-protected:</span>
<a href="#l12.22"></a><span id="l12.22" class="difflineplus">+</span>
<a href="#l12.23"></a><span id="l12.23" class="difflineplus">+ protected:</span>
<a href="#l12.24"></a><span id="l12.24">   nsCString fServerKey;</span>
<a href="#l12.25"></a><span id="l12.25">   nsString fCachedPassword;</span>
<a href="#l12.26"></a><span id="l12.26">   nsCString fOnlineDir;</span>
<a href="#l12.27"></a><span id="l12.27">   nsIMAPHostInfo *fNextHost;</span>
<a href="#l12.28"></a><span id="l12.28">   eIMAPCapabilityFlags fCapabilityFlags;</span>
<a href="#l12.29"></a><span id="l12.29" class="difflineminus">-  char *fHierarchyDelimiters;// string of top-level hierarchy delimiters</span>
<a href="#l12.30"></a><span id="l12.30" class="difflineplus">+  char *fHierarchyDelimiters;  // string of top-level hierarchy delimiters</span>
<a href="#l12.31"></a><span id="l12.31">   bool fHaveWeEverDiscoveredFolders;</span>
<a href="#l12.32"></a><span id="l12.32">   char *fCanonicalOnlineSubDir;</span>
<a href="#l12.33"></a><span id="l12.33">   nsIMAPNamespaceList *fNamespaceList, *fTempNamespaceList;</span>
<a href="#l12.34"></a><span id="l12.34">   bool fNamespacesOverridable;</span>
<a href="#l12.35"></a><span id="l12.35">   bool fUsingSubscription;</span>
<a href="#l12.36"></a><span id="l12.36">   bool fOnlineTrashFolderExists;</span>
<a href="#l12.37"></a><span id="l12.37">   bool fShouldAlwaysListInbox;</span>
<a href="#l12.38"></a><span id="l12.38">   bool fHaveAdminURL;</span>
<a href="#l12.39"></a><span id="l12.39">   bool fPasswordVerifiedOnline;</span>
<a href="#l12.40"></a><span id="l12.40">   bool fDeleteIsMoveToTrash;</span>
<a href="#l12.41"></a><span id="l12.41">   bool fShowDeletedMessages;</span>
<a href="#l12.42"></a><span id="l12.42">   bool fGotNamespaces;</span>
<a href="#l12.43"></a><span id="l12.43">   nsIMAPBodyShellCache *fShellCache;</span>
<a href="#l12.44"></a><span id="l12.44"> };</span>
<a href="#l12.45"></a><span id="l12.45"> </span>
<a href="#l12.46"></a><span id="l12.46"> // this is an interface to a linked list of host info's</span>
<a href="#l12.47"></a><span id="l12.47" class="difflineminus">-class nsIMAPHostSessionList : public nsIImapHostSessionList, public nsIObserver, public nsSupportsWeakReference</span>
<a href="#l12.48"></a><span id="l12.48" class="difflineminus">-{</span>
<a href="#l12.49"></a><span id="l12.49" class="difflineminus">-public:</span>
<a href="#l12.50"></a><span id="l12.50" class="difflineplus">+class nsIMAPHostSessionList : public nsIImapHostSessionList,</span>
<a href="#l12.51"></a><span id="l12.51" class="difflineplus">+                              public nsIObserver,</span>
<a href="#l12.52"></a><span id="l12.52" class="difflineplus">+                              public nsSupportsWeakReference {</span>
<a href="#l12.53"></a><span id="l12.53" class="difflineplus">+ public:</span>
<a href="#l12.54"></a><span id="l12.54">   NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l12.55"></a><span id="l12.55">   NS_DECL_NSIOBSERVER</span>
<a href="#l12.56"></a><span id="l12.56"> </span>
<a href="#l12.57"></a><span id="l12.57">   nsIMAPHostSessionList();</span>
<a href="#l12.58"></a><span id="l12.58">   nsresult Init();</span>
<a href="#l12.59"></a><span id="l12.59">   // Host List</span>
<a href="#l12.60"></a><span id="l12.60">   NS_IMETHOD AddHostToList(const char *serverKey,</span>
<a href="#l12.61"></a><span id="l12.61" class="difflineminus">-                            nsIImapIncomingServer *server) override;</span>
<a href="#l12.62"></a><span id="l12.62" class="difflineplus">+                           nsIImapIncomingServer *server) override;</span>
<a href="#l12.63"></a><span id="l12.63">   NS_IMETHOD ResetAll() override;</span>
<a href="#l12.64"></a><span id="l12.64"> </span>
<a href="#l12.65"></a><span id="l12.65">   // Capabilities</span>
<a href="#l12.66"></a><span id="l12.66">   NS_IMETHOD GetHostHasAdminURL(const char *serverKey, bool &amp;result) override;</span>
<a href="#l12.67"></a><span id="l12.67" class="difflineminus">-  NS_IMETHOD SetHostHasAdminURL(const char *serverKey, bool hasAdminUrl) override;</span>
<a href="#l12.68"></a><span id="l12.68" class="difflineplus">+  NS_IMETHOD SetHostHasAdminURL(const char *serverKey,</span>
<a href="#l12.69"></a><span id="l12.69" class="difflineplus">+                                bool hasAdminUrl) override;</span>
<a href="#l12.70"></a><span id="l12.70">   // Subscription</span>
<a href="#l12.71"></a><span id="l12.71" class="difflineminus">-  NS_IMETHOD GetHostIsUsingSubscription(const char *serverKey, bool &amp;result) override;</span>
<a href="#l12.72"></a><span id="l12.72" class="difflineminus">-  NS_IMETHOD SetHostIsUsingSubscription(const char *serverKey, bool usingSubscription) override;</span>
<a href="#l12.73"></a><span id="l12.73" class="difflineplus">+  NS_IMETHOD GetHostIsUsingSubscription(const char *serverKey,</span>
<a href="#l12.74"></a><span id="l12.74" class="difflineplus">+                                        bool &amp;result) override;</span>
<a href="#l12.75"></a><span id="l12.75" class="difflineplus">+  NS_IMETHOD SetHostIsUsingSubscription(const char *serverKey,</span>
<a href="#l12.76"></a><span id="l12.76" class="difflineplus">+                                        bool usingSubscription) override;</span>
<a href="#l12.77"></a><span id="l12.77"> </span>
<a href="#l12.78"></a><span id="l12.78">   // Passwords</span>
<a href="#l12.79"></a><span id="l12.79" class="difflineminus">-  NS_IMETHOD GetPasswordForHost(const char *serverKey, nsString &amp;result) override;</span>
<a href="#l12.80"></a><span id="l12.80" class="difflineminus">-  NS_IMETHOD SetPasswordForHost(const char *serverKey, const nsAString &amp;password) override;</span>
<a href="#l12.81"></a><span id="l12.81" class="difflineminus">-  NS_IMETHOD GetPasswordVerifiedOnline(const char *serverKey, bool &amp;result) override;</span>
<a href="#l12.82"></a><span id="l12.82" class="difflineplus">+  NS_IMETHOD GetPasswordForHost(const char *serverKey,</span>
<a href="#l12.83"></a><span id="l12.83" class="difflineplus">+                                nsString &amp;result) override;</span>
<a href="#l12.84"></a><span id="l12.84" class="difflineplus">+  NS_IMETHOD SetPasswordForHost(const char *serverKey,</span>
<a href="#l12.85"></a><span id="l12.85" class="difflineplus">+                                const nsAString &amp;password) override;</span>
<a href="#l12.86"></a><span id="l12.86" class="difflineplus">+  NS_IMETHOD GetPasswordVerifiedOnline(const char *serverKey,</span>
<a href="#l12.87"></a><span id="l12.87" class="difflineplus">+                                       bool &amp;result) override;</span>
<a href="#l12.88"></a><span id="l12.88">   NS_IMETHOD SetPasswordVerifiedOnline(const char *serverKey) override;</span>
<a href="#l12.89"></a><span id="l12.89"> </span>
<a href="#l12.90"></a><span id="l12.90">   // OnlineDir</span>
<a href="#l12.91"></a><span id="l12.91">   NS_IMETHOD GetOnlineDirForHost(const char *serverKey,</span>
<a href="#l12.92"></a><span id="l12.92">                                  nsString &amp;result) override;</span>
<a href="#l12.93"></a><span id="l12.93">   NS_IMETHOD SetOnlineDirForHost(const char *serverKey,</span>
<a href="#l12.94"></a><span id="l12.94">                                  const char *onlineDir) override;</span>
<a href="#l12.95"></a><span id="l12.95"> </span>
<a href="#l12.96"></a><span id="l12.96">   // Delete is move to trash folder</span>
<a href="#l12.97"></a><span id="l12.97" class="difflineminus">-  NS_IMETHOD GetDeleteIsMoveToTrashForHost(const char *serverKey, bool &amp;result) override;</span>
<a href="#l12.98"></a><span id="l12.98" class="difflineminus">-  NS_IMETHOD SetDeleteIsMoveToTrashForHost(const char *serverKey, bool isMoveToTrash) override;</span>
<a href="#l12.99"></a><span id="l12.99" class="difflineplus">+  NS_IMETHOD GetDeleteIsMoveToTrashForHost(const char *serverKey,</span>
<a href="#l12.100"></a><span id="l12.100" class="difflineplus">+                                           bool &amp;result) override;</span>
<a href="#l12.101"></a><span id="l12.101" class="difflineplus">+  NS_IMETHOD SetDeleteIsMoveToTrashForHost(const char *serverKey,</span>
<a href="#l12.102"></a><span id="l12.102" class="difflineplus">+                                           bool isMoveToTrash) override;</span>
<a href="#l12.103"></a><span id="l12.103">   // imap delete model (or not)</span>
<a href="#l12.104"></a><span id="l12.104" class="difflineminus">-  NS_IMETHOD GetShowDeletedMessagesForHost(const char *serverKey, bool &amp;result) override;</span>
<a href="#l12.105"></a><span id="l12.105" class="difflineminus">-  NS_IMETHOD SetShowDeletedMessagesForHost(const char *serverKey, bool showDeletedMessages) override;</span>
<a href="#l12.106"></a><span id="l12.106" class="difflineplus">+  NS_IMETHOD GetShowDeletedMessagesForHost(const char *serverKey,</span>
<a href="#l12.107"></a><span id="l12.107" class="difflineplus">+                                           bool &amp;result) override;</span>
<a href="#l12.108"></a><span id="l12.108" class="difflineplus">+  NS_IMETHOD SetShowDeletedMessagesForHost(const char *serverKey,</span>
<a href="#l12.109"></a><span id="l12.109" class="difflineplus">+                                           bool showDeletedMessages) override;</span>
<a href="#l12.110"></a><span id="l12.110"> </span>
<a href="#l12.111"></a><span id="l12.111">   // Get namespaces</span>
<a href="#l12.112"></a><span id="l12.112" class="difflineminus">-  NS_IMETHOD GetGotNamespacesForHost(const char *serverKey, bool &amp;result) override;</span>
<a href="#l12.113"></a><span id="l12.113" class="difflineminus">-  NS_IMETHOD SetGotNamespacesForHost(const char *serverKey, bool gotNamespaces) override;</span>
<a href="#l12.114"></a><span id="l12.114" class="difflineplus">+  NS_IMETHOD GetGotNamespacesForHost(const char *serverKey,</span>
<a href="#l12.115"></a><span id="l12.115" class="difflineplus">+                                     bool &amp;result) override;</span>
<a href="#l12.116"></a><span id="l12.116" class="difflineplus">+  NS_IMETHOD SetGotNamespacesForHost(const char *serverKey,</span>
<a href="#l12.117"></a><span id="l12.117" class="difflineplus">+                                     bool gotNamespaces) override;</span>
<a href="#l12.118"></a><span id="l12.118">   // Folders</span>
<a href="#l12.119"></a><span id="l12.119" class="difflineminus">-  NS_IMETHOD SetHaveWeEverDiscoveredFoldersForHost(const char *serverKey, bool discovered) override;</span>
<a href="#l12.120"></a><span id="l12.120" class="difflineminus">-  NS_IMETHOD GetHaveWeEverDiscoveredFoldersForHost(const char *serverKey, bool &amp;result) override;</span>
<a href="#l12.121"></a><span id="l12.121" class="difflineplus">+  NS_IMETHOD SetHaveWeEverDiscoveredFoldersForHost(const char *serverKey,</span>
<a href="#l12.122"></a><span id="l12.122" class="difflineplus">+                                                   bool discovered) override;</span>
<a href="#l12.123"></a><span id="l12.123" class="difflineplus">+  NS_IMETHOD GetHaveWeEverDiscoveredFoldersForHost(const char *serverKey,</span>
<a href="#l12.124"></a><span id="l12.124" class="difflineplus">+                                                   bool &amp;result) override;</span>
<a href="#l12.125"></a><span id="l12.125"> </span>
<a href="#l12.126"></a><span id="l12.126">   // Trash Folder</span>
<a href="#l12.127"></a><span id="l12.127" class="difflineminus">-  NS_IMETHOD SetOnlineTrashFolderExistsForHost(const char *serverKey, bool exists) override;</span>
<a href="#l12.128"></a><span id="l12.128" class="difflineminus">-  NS_IMETHOD GetOnlineTrashFolderExistsForHost(const char *serverKey, bool &amp;result) override;</span>
<a href="#l12.129"></a><span id="l12.129" class="difflineplus">+  NS_IMETHOD SetOnlineTrashFolderExistsForHost(const char *serverKey,</span>
<a href="#l12.130"></a><span id="l12.130" class="difflineplus">+                                               bool exists) override;</span>
<a href="#l12.131"></a><span id="l12.131" class="difflineplus">+  NS_IMETHOD GetOnlineTrashFolderExistsForHost(const char *serverKey,</span>
<a href="#l12.132"></a><span id="l12.132" class="difflineplus">+                                               bool &amp;result) override;</span>
<a href="#l12.133"></a><span id="l12.133"> </span>
<a href="#l12.134"></a><span id="l12.134">   // INBOX</span>
<a href="#l12.135"></a><span id="l12.135" class="difflineminus">-  NS_IMETHOD GetOnlineInboxPathForHost(const char *serverKey, nsString &amp;result) override;</span>
<a href="#l12.136"></a><span id="l12.136" class="difflineminus">-  NS_IMETHOD GetShouldAlwaysListInboxForHost(const char *serverKey, bool &amp;result) override;</span>
<a href="#l12.137"></a><span id="l12.137" class="difflineminus">-  NS_IMETHOD SetShouldAlwaysListInboxForHost(const char *serverKey, bool shouldList) override;</span>
<a href="#l12.138"></a><span id="l12.138" class="difflineplus">+  NS_IMETHOD GetOnlineInboxPathForHost(const char *serverKey,</span>
<a href="#l12.139"></a><span id="l12.139" class="difflineplus">+                                       nsString &amp;result) override;</span>
<a href="#l12.140"></a><span id="l12.140" class="difflineplus">+  NS_IMETHOD GetShouldAlwaysListInboxForHost(const char *serverKey,</span>
<a href="#l12.141"></a><span id="l12.141" class="difflineplus">+                                             bool &amp;result) override;</span>
<a href="#l12.142"></a><span id="l12.142" class="difflineplus">+  NS_IMETHOD SetShouldAlwaysListInboxForHost(const char *serverKey,</span>
<a href="#l12.143"></a><span id="l12.143" class="difflineplus">+                                             bool shouldList) override;</span>
<a href="#l12.144"></a><span id="l12.144"> </span>
<a href="#l12.145"></a><span id="l12.145">   // Namespaces</span>
<a href="#l12.146"></a><span id="l12.146" class="difflineminus">-  NS_IMETHOD GetNamespaceForMailboxForHost(const char *serverKey, const char *mailbox_name, nsIMAPNamespace *&amp;result) override;</span>
<a href="#l12.147"></a><span id="l12.147" class="difflineminus">-  NS_IMETHOD SetNamespaceFromPrefForHost(const char *serverKey, const char *namespacePref, EIMAPNamespaceType type) override;</span>
<a href="#l12.148"></a><span id="l12.148" class="difflineminus">-  NS_IMETHOD AddNewNamespaceForHost(const char *serverKey, nsIMAPNamespace *ns) override;</span>
<a href="#l12.149"></a><span id="l12.149" class="difflineminus">-  NS_IMETHOD ClearServerAdvertisedNamespacesForHost(const char *serverKey) override;</span>
<a href="#l12.150"></a><span id="l12.150" class="difflineplus">+  NS_IMETHOD GetNamespaceForMailboxForHost(const char *serverKey,</span>
<a href="#l12.151"></a><span id="l12.151" class="difflineplus">+                                           const char *mailbox_name,</span>
<a href="#l12.152"></a><span id="l12.152" class="difflineplus">+                                           nsIMAPNamespace *&amp;result) override;</span>
<a href="#l12.153"></a><span id="l12.153" class="difflineplus">+  NS_IMETHOD SetNamespaceFromPrefForHost(const char *serverKey,</span>
<a href="#l12.154"></a><span id="l12.154" class="difflineplus">+                                         const char *namespacePref,</span>
<a href="#l12.155"></a><span id="l12.155" class="difflineplus">+                                         EIMAPNamespaceType type) override;</span>
<a href="#l12.156"></a><span id="l12.156" class="difflineplus">+  NS_IMETHOD AddNewNamespaceForHost(const char *serverKey,</span>
<a href="#l12.157"></a><span id="l12.157" class="difflineplus">+                                    nsIMAPNamespace *ns) override;</span>
<a href="#l12.158"></a><span id="l12.158" class="difflineplus">+  NS_IMETHOD ClearServerAdvertisedNamespacesForHost(</span>
<a href="#l12.159"></a><span id="l12.159" class="difflineplus">+      const char *serverKey) override;</span>
<a href="#l12.160"></a><span id="l12.160">   NS_IMETHOD ClearPrefsNamespacesForHost(const char *serverKey) override;</span>
<a href="#l12.161"></a><span id="l12.161" class="difflineminus">-  NS_IMETHOD GetDefaultNamespaceOfTypeForHost(const char *serverKey, EIMAPNamespaceType type, nsIMAPNamespace *&amp;result) override;</span>
<a href="#l12.162"></a><span id="l12.162" class="difflineminus">-  NS_IMETHOD SetNamespacesOverridableForHost(const char *serverKey, bool overridable) override;</span>
<a href="#l12.163"></a><span id="l12.163" class="difflineminus">-  NS_IMETHOD GetNamespacesOverridableForHost(const char *serverKey,bool &amp;result) override;</span>
<a href="#l12.164"></a><span id="l12.164" class="difflineminus">-  NS_IMETHOD GetNumberOfNamespacesForHost(const char *serverKey, uint32_t &amp;result) override;</span>
<a href="#l12.165"></a><span id="l12.165" class="difflineminus">-  NS_IMETHOD GetNamespaceNumberForHost(const char *serverKey, int32_t n, nsIMAPNamespace * &amp;result) override;</span>
<a href="#l12.166"></a><span id="l12.166" class="difflineplus">+  NS_IMETHOD GetDefaultNamespaceOfTypeForHost(</span>
<a href="#l12.167"></a><span id="l12.167" class="difflineplus">+      const char *serverKey, EIMAPNamespaceType type,</span>
<a href="#l12.168"></a><span id="l12.168" class="difflineplus">+      nsIMAPNamespace *&amp;result) override;</span>
<a href="#l12.169"></a><span id="l12.169" class="difflineplus">+  NS_IMETHOD SetNamespacesOverridableForHost(const char *serverKey,</span>
<a href="#l12.170"></a><span id="l12.170" class="difflineplus">+                                             bool overridable) override;</span>
<a href="#l12.171"></a><span id="l12.171" class="difflineplus">+  NS_IMETHOD GetNamespacesOverridableForHost(const char *serverKey,</span>
<a href="#l12.172"></a><span id="l12.172" class="difflineplus">+                                             bool &amp;result) override;</span>
<a href="#l12.173"></a><span id="l12.173" class="difflineplus">+  NS_IMETHOD GetNumberOfNamespacesForHost(const char *serverKey,</span>
<a href="#l12.174"></a><span id="l12.174" class="difflineplus">+                                          uint32_t &amp;result) override;</span>
<a href="#l12.175"></a><span id="l12.175" class="difflineplus">+  NS_IMETHOD GetNamespaceNumberForHost(const char *serverKey, int32_t n,</span>
<a href="#l12.176"></a><span id="l12.176" class="difflineplus">+                                       nsIMAPNamespace *&amp;result) override;</span>
<a href="#l12.177"></a><span id="l12.177">   // ### dmb hoo boy, how are we going to do this?</span>
<a href="#l12.178"></a><span id="l12.178">   NS_IMETHOD CommitNamespacesForHost(nsIImapIncomingServer *host) override;</span>
<a href="#l12.179"></a><span id="l12.179" class="difflineminus">-  NS_IMETHOD FlushUncommittedNamespacesForHost(const char *serverKey, bool &amp;result) override;</span>
<a href="#l12.180"></a><span id="l12.180" class="difflineplus">+  NS_IMETHOD FlushUncommittedNamespacesForHost(const char *serverKey,</span>
<a href="#l12.181"></a><span id="l12.181" class="difflineplus">+                                               bool &amp;result) override;</span>
<a href="#l12.182"></a><span id="l12.182"> </span>
<a href="#l12.183"></a><span id="l12.183">   // Hierarchy Delimiters</span>
<a href="#l12.184"></a><span id="l12.184" class="difflineminus">-  NS_IMETHOD SetNamespaceHierarchyDelimiterFromMailboxForHost(const char *serverKey, const char *boxName, char delimiter) override;</span>
<a href="#l12.185"></a><span id="l12.185" class="difflineplus">+  NS_IMETHOD SetNamespaceHierarchyDelimiterFromMailboxForHost(</span>
<a href="#l12.186"></a><span id="l12.186" class="difflineplus">+      const char *serverKey, const char *boxName, char delimiter) override;</span>
<a href="#l12.187"></a><span id="l12.187"> </span>
<a href="#l12.188"></a><span id="l12.188">   // Message Body Shells</span>
<a href="#l12.189"></a><span id="l12.189" class="difflineminus">-  NS_IMETHOD AddShellToCacheForHost(const char *serverKey, nsIMAPBodyShell *shell) override;</span>
<a href="#l12.190"></a><span id="l12.190" class="difflineminus">-  NS_IMETHOD FindShellInCacheForHost(const char *serverKey, const char *mailboxName, const char *UID, IMAP_ContentModifiedType modType, nsIMAPBodyShell **result) override;</span>
<a href="#l12.191"></a><span id="l12.191" class="difflineplus">+  NS_IMETHOD AddShellToCacheForHost(const char *serverKey,</span>
<a href="#l12.192"></a><span id="l12.192" class="difflineplus">+                                    nsIMAPBodyShell *shell) override;</span>
<a href="#l12.193"></a><span id="l12.193" class="difflineplus">+  NS_IMETHOD FindShellInCacheForHost(const char *serverKey,</span>
<a href="#l12.194"></a><span id="l12.194" class="difflineplus">+                                     const char *mailboxName, const char *UID,</span>
<a href="#l12.195"></a><span id="l12.195" class="difflineplus">+                                     IMAP_ContentModifiedType modType,</span>
<a href="#l12.196"></a><span id="l12.196" class="difflineplus">+                                     nsIMAPBodyShell **result) override;</span>
<a href="#l12.197"></a><span id="l12.197">   NS_IMETHOD ClearShellCacheForHost(const char *serverKey) override;</span>
<a href="#l12.198"></a><span id="l12.198">   PRMonitor *gCachedHostInfoMonitor;</span>
<a href="#l12.199"></a><span id="l12.199">   nsIMAPHostInfo *fHostInfoList;</span>
<a href="#l12.200"></a><span id="l12.200" class="difflineminus">-protected:</span>
<a href="#l12.201"></a><span id="l12.201" class="difflineplus">+</span>
<a href="#l12.202"></a><span id="l12.202" class="difflineplus">+ protected:</span>
<a href="#l12.203"></a><span id="l12.203">   virtual ~nsIMAPHostSessionList();</span>
<a href="#l12.204"></a><span id="l12.204">   nsresult SetNamespacesPrefForHost(nsIImapIncomingServer *aHost,</span>
<a href="#l12.205"></a><span id="l12.205" class="difflineminus">-                                    EIMAPNamespaceType type,</span>
<a href="#l12.206"></a><span id="l12.206" class="difflineminus">-                                    const char *pref);</span>
<a href="#l12.207"></a><span id="l12.207" class="difflineplus">+                                    EIMAPNamespaceType type, const char *pref);</span>
<a href="#l12.208"></a><span id="l12.208">   nsIMAPHostInfo *FindHost(const char *serverKey);</span>
<a href="#l12.209"></a><span id="l12.209"> };</span>
<a href="#l12.210"></a><span id="l12.210"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPNamespace.cpp</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPNamespace.cpp</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -8,624 +8,558 @@</span>
<a href="#l13.4"></a><span id="l13.4"> #include &quot;nsImapCore.h&quot;</span>
<a href="#l13.5"></a><span id="l13.5"> #include &quot;nsIMAPNamespace.h&quot;</span>
<a href="#l13.6"></a><span id="l13.6"> #include &quot;nsIIMAPHostSessionList.h&quot;</span>
<a href="#l13.7"></a><span id="l13.7"> #include &quot;nsMsgImapCID.h&quot;</span>
<a href="#l13.8"></a><span id="l13.8"> #include &quot;nsImapUrl.h&quot;</span>
<a href="#l13.9"></a><span id="l13.9"> #include &quot;nsString.h&quot;</span>
<a href="#l13.10"></a><span id="l13.10"> #include &quot;nsServiceManagerUtils.h&quot;</span>
<a href="#l13.11"></a><span id="l13.11"> </span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">-//////////////////// nsIMAPNamespace  /////////////////////////////////////////////////////////////</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+//////////////////// nsIMAPNamespace</span>
<a href="#l13.14"></a><span id="l13.14" class="difflineplus">+////////////////////////////////////////////////////////////////</span>
<a href="#l13.15"></a><span id="l13.15"> </span>
<a href="#l13.16"></a><span id="l13.16"> static NS_DEFINE_CID(kCImapHostSessionListCID, NS_IIMAPHOSTSESSIONLIST_CID);</span>
<a href="#l13.17"></a><span id="l13.17"> </span>
<a href="#l13.18"></a><span id="l13.18" class="difflineminus">-nsIMAPNamespace::nsIMAPNamespace(EIMAPNamespaceType type, const char *prefix, char delimiter, bool from_prefs)</span>
<a href="#l13.19"></a><span id="l13.19" class="difflineminus">-{</span>
<a href="#l13.20"></a><span id="l13.20" class="difflineplus">+nsIMAPNamespace::nsIMAPNamespace(EIMAPNamespaceType type, const char *prefix,</span>
<a href="#l13.21"></a><span id="l13.21" class="difflineplus">+                                 char delimiter, bool from_prefs) {</span>
<a href="#l13.22"></a><span id="l13.22">   m_namespaceType = type;</span>
<a href="#l13.23"></a><span id="l13.23">   m_prefix = PL_strdup(prefix);</span>
<a href="#l13.24"></a><span id="l13.24">   m_fromPrefs = from_prefs;</span>
<a href="#l13.25"></a><span id="l13.25"> </span>
<a href="#l13.26"></a><span id="l13.26">   m_delimiter = delimiter;</span>
<a href="#l13.27"></a><span id="l13.27" class="difflineminus">-  m_delimiterFilledIn = !m_fromPrefs;  // if it's from the prefs, we can't be sure about the delimiter until we list it.</span>
<a href="#l13.28"></a><span id="l13.28" class="difflineplus">+  m_delimiterFilledIn =</span>
<a href="#l13.29"></a><span id="l13.29" class="difflineplus">+      !m_fromPrefs;  // if it's from the prefs, we can't be sure about the</span>
<a href="#l13.30"></a><span id="l13.30" class="difflineplus">+                     // delimiter until we list it.</span>
<a href="#l13.31"></a><span id="l13.31"> }</span>
<a href="#l13.32"></a><span id="l13.32"> </span>
<a href="#l13.33"></a><span id="l13.33" class="difflineminus">-nsIMAPNamespace::~nsIMAPNamespace()</span>
<a href="#l13.34"></a><span id="l13.34" class="difflineminus">-{</span>
<a href="#l13.35"></a><span id="l13.35" class="difflineminus">-  PR_FREEIF(m_prefix);</span>
<a href="#l13.36"></a><span id="l13.36" class="difflineminus">-}</span>
<a href="#l13.37"></a><span id="l13.37" class="difflineplus">+nsIMAPNamespace::~nsIMAPNamespace() { PR_FREEIF(m_prefix); }</span>
<a href="#l13.38"></a><span id="l13.38"> </span>
<a href="#l13.39"></a><span id="l13.39" class="difflineminus">-void nsIMAPNamespace::SetDelimiter(char delimiter, bool delimiterFilledIn)</span>
<a href="#l13.40"></a><span id="l13.40" class="difflineminus">-{</span>
<a href="#l13.41"></a><span id="l13.41" class="difflineplus">+void nsIMAPNamespace::SetDelimiter(char delimiter, bool delimiterFilledIn) {</span>
<a href="#l13.42"></a><span id="l13.42">   m_delimiter = delimiter;</span>
<a href="#l13.43"></a><span id="l13.43">   m_delimiterFilledIn = delimiterFilledIn;</span>
<a href="#l13.44"></a><span id="l13.44"> }</span>
<a href="#l13.45"></a><span id="l13.45"> </span>
<a href="#l13.46"></a><span id="l13.46"> // returns -1 if this box is not part of this namespace,</span>
<a href="#l13.47"></a><span id="l13.47"> // or the length of the prefix if it is part of this namespace</span>
<a href="#l13.48"></a><span id="l13.48" class="difflineminus">-int nsIMAPNamespace::MailboxMatchesNamespace(const char *boxname)</span>
<a href="#l13.49"></a><span id="l13.49" class="difflineminus">-{</span>
<a href="#l13.50"></a><span id="l13.50" class="difflineplus">+int nsIMAPNamespace::MailboxMatchesNamespace(const char *boxname) {</span>
<a href="#l13.51"></a><span id="l13.51">   if (!boxname) return -1;</span>
<a href="#l13.52"></a><span id="l13.52"> </span>
<a href="#l13.53"></a><span id="l13.53">   // If the namespace is part of the boxname</span>
<a href="#l13.54"></a><span id="l13.54" class="difflineminus">-  if (!m_prefix || !*m_prefix)</span>
<a href="#l13.55"></a><span id="l13.55" class="difflineminus">-    return 0;</span>
<a href="#l13.56"></a><span id="l13.56" class="difflineplus">+  if (!m_prefix || !*m_prefix) return 0;</span>
<a href="#l13.57"></a><span id="l13.57"> </span>
<a href="#l13.58"></a><span id="l13.58" class="difflineminus">-  if (PL_strstr(boxname, m_prefix) == boxname)</span>
<a href="#l13.59"></a><span id="l13.59" class="difflineminus">-    return PL_strlen(m_prefix);</span>
<a href="#l13.60"></a><span id="l13.60" class="difflineplus">+  if (PL_strstr(boxname, m_prefix) == boxname) return PL_strlen(m_prefix);</span>
<a href="#l13.61"></a><span id="l13.61"> </span>
<a href="#l13.62"></a><span id="l13.62">   // If the boxname is part of the prefix</span>
<a href="#l13.63"></a><span id="l13.63">   // (Used for matching Personal mailbox with Personal/ namespace, etc.)</span>
<a href="#l13.64"></a><span id="l13.64" class="difflineminus">-  if (PL_strstr(m_prefix, boxname) == m_prefix)</span>
<a href="#l13.65"></a><span id="l13.65" class="difflineminus">-    return PL_strlen(boxname);</span>
<a href="#l13.66"></a><span id="l13.66" class="difflineplus">+  if (PL_strstr(m_prefix, boxname) == m_prefix) return PL_strlen(boxname);</span>
<a href="#l13.67"></a><span id="l13.67">   return -1;</span>
<a href="#l13.68"></a><span id="l13.68"> }</span>
<a href="#l13.69"></a><span id="l13.69"> </span>
<a href="#l13.70"></a><span id="l13.70" class="difflineminus">-nsIMAPNamespaceList *nsIMAPNamespaceList::CreatensIMAPNamespaceList()</span>
<a href="#l13.71"></a><span id="l13.71" class="difflineminus">-{</span>
<a href="#l13.72"></a><span id="l13.72" class="difflineplus">+nsIMAPNamespaceList *nsIMAPNamespaceList::CreatensIMAPNamespaceList() {</span>
<a href="#l13.73"></a><span id="l13.73">   nsIMAPNamespaceList *rv = new nsIMAPNamespaceList();</span>
<a href="#l13.74"></a><span id="l13.74">   return rv;</span>
<a href="#l13.75"></a><span id="l13.75"> }</span>
<a href="#l13.76"></a><span id="l13.76"> </span>
<a href="#l13.77"></a><span id="l13.77" class="difflineminus">-nsIMAPNamespaceList::nsIMAPNamespaceList()</span>
<a href="#l13.78"></a><span id="l13.78" class="difflineminus">-{</span>
<a href="#l13.79"></a><span id="l13.79" class="difflineminus">-}</span>
<a href="#l13.80"></a><span id="l13.80" class="difflineplus">+nsIMAPNamespaceList::nsIMAPNamespaceList() {}</span>
<a href="#l13.81"></a><span id="l13.81"> </span>
<a href="#l13.82"></a><span id="l13.82" class="difflineminus">-int nsIMAPNamespaceList::GetNumberOfNamespaces()</span>
<a href="#l13.83"></a><span id="l13.83" class="difflineminus">-{</span>
<a href="#l13.84"></a><span id="l13.84" class="difflineplus">+int nsIMAPNamespaceList::GetNumberOfNamespaces() {</span>
<a href="#l13.85"></a><span id="l13.85">   return m_NamespaceList.Length();</span>
<a href="#l13.86"></a><span id="l13.86"> }</span>
<a href="#l13.87"></a><span id="l13.87"> </span>
<a href="#l13.88"></a><span id="l13.88" class="difflineminus">-nsresult nsIMAPNamespaceList::InitFromString(const char *nameSpaceString, EIMAPNamespaceType nstype)</span>
<a href="#l13.89"></a><span id="l13.89" class="difflineminus">-{</span>
<a href="#l13.90"></a><span id="l13.90" class="difflineplus">+nsresult nsIMAPNamespaceList::InitFromString(const char *nameSpaceString,</span>
<a href="#l13.91"></a><span id="l13.91" class="difflineplus">+                                             EIMAPNamespaceType nstype) {</span>
<a href="#l13.92"></a><span id="l13.92">   nsresult rv = NS_OK;</span>
<a href="#l13.93"></a><span id="l13.93" class="difflineminus">-  if (nameSpaceString)</span>
<a href="#l13.94"></a><span id="l13.94" class="difflineminus">-  {</span>
<a href="#l13.95"></a><span id="l13.95" class="difflineplus">+  if (nameSpaceString) {</span>
<a href="#l13.96"></a><span id="l13.96">     int numNamespaces = UnserializeNamespaces(nameSpaceString, nullptr, 0);</span>
<a href="#l13.97"></a><span id="l13.97" class="difflineminus">-    char **prefixes = (char**) PR_CALLOC(numNamespaces * sizeof(char*));</span>
<a href="#l13.98"></a><span id="l13.98" class="difflineminus">-    if (prefixes)</span>
<a href="#l13.99"></a><span id="l13.99" class="difflineminus">-    {</span>
<a href="#l13.100"></a><span id="l13.100" class="difflineplus">+    char **prefixes = (char **)PR_CALLOC(numNamespaces * sizeof(char *));</span>
<a href="#l13.101"></a><span id="l13.101" class="difflineplus">+    if (prefixes) {</span>
<a href="#l13.102"></a><span id="l13.102">       int len = UnserializeNamespaces(nameSpaceString, prefixes, numNamespaces);</span>
<a href="#l13.103"></a><span id="l13.103" class="difflineminus">-      for (int i = 0; i &lt; len; i++)</span>
<a href="#l13.104"></a><span id="l13.104" class="difflineminus">-      {</span>
<a href="#l13.105"></a><span id="l13.105" class="difflineplus">+      for (int i = 0; i &lt; len; i++) {</span>
<a href="#l13.106"></a><span id="l13.106">         char *thisns = prefixes[i];</span>
<a href="#l13.107"></a><span id="l13.107">         char delimiter = '/';  // a guess</span>
<a href="#l13.108"></a><span id="l13.108" class="difflineminus">-        if (PL_strlen(thisns) &gt;= 1)</span>
<a href="#l13.109"></a><span id="l13.109" class="difflineminus">-          delimiter = thisns[PL_strlen(thisns)-1];</span>
<a href="#l13.110"></a><span id="l13.110" class="difflineminus">-        nsIMAPNamespace *ns = new nsIMAPNamespace(nstype, thisns, delimiter, true);</span>
<a href="#l13.111"></a><span id="l13.111" class="difflineminus">-        if (ns)</span>
<a href="#l13.112"></a><span id="l13.112" class="difflineminus">-          AddNewNamespace(ns);</span>
<a href="#l13.113"></a><span id="l13.113" class="difflineplus">+        if (PL_strlen(thisns) &gt;= 1) delimiter = thisns[PL_strlen(thisns) - 1];</span>
<a href="#l13.114"></a><span id="l13.114" class="difflineplus">+        nsIMAPNamespace *ns =</span>
<a href="#l13.115"></a><span id="l13.115" class="difflineplus">+            new nsIMAPNamespace(nstype, thisns, delimiter, true);</span>
<a href="#l13.116"></a><span id="l13.116" class="difflineplus">+        if (ns) AddNewNamespace(ns);</span>
<a href="#l13.117"></a><span id="l13.117">         PR_FREEIF(thisns);</span>
<a href="#l13.118"></a><span id="l13.118">       }</span>
<a href="#l13.119"></a><span id="l13.119">       PR_Free(prefixes);</span>
<a href="#l13.120"></a><span id="l13.120">     }</span>
<a href="#l13.121"></a><span id="l13.121">   }</span>
<a href="#l13.122"></a><span id="l13.122"> </span>
<a href="#l13.123"></a><span id="l13.123">   return rv;</span>
<a href="#l13.124"></a><span id="l13.124"> }</span>
<a href="#l13.125"></a><span id="l13.125"> </span>
<a href="#l13.126"></a><span id="l13.126" class="difflineminus">-nsresult nsIMAPNamespaceList::OutputToString(nsCString &amp;string)</span>
<a href="#l13.127"></a><span id="l13.127" class="difflineminus">-{</span>
<a href="#l13.128"></a><span id="l13.128" class="difflineplus">+nsresult nsIMAPNamespaceList::OutputToString(nsCString &amp;string) {</span>
<a href="#l13.129"></a><span id="l13.129">   nsresult rv = NS_OK;</span>
<a href="#l13.130"></a><span id="l13.130">   return rv;</span>
<a href="#l13.131"></a><span id="l13.131"> }</span>
<a href="#l13.132"></a><span id="l13.132"> </span>
<a href="#l13.133"></a><span id="l13.133" class="difflineminus">-</span>
<a href="#l13.134"></a><span id="l13.134" class="difflineminus">-int nsIMAPNamespaceList::GetNumberOfNamespaces(EIMAPNamespaceType type)</span>
<a href="#l13.135"></a><span id="l13.135" class="difflineminus">-{</span>
<a href="#l13.136"></a><span id="l13.136" class="difflineplus">+int nsIMAPNamespaceList::GetNumberOfNamespaces(EIMAPNamespaceType type) {</span>
<a href="#l13.137"></a><span id="l13.137">   int nodeIndex = 0, count = 0;</span>
<a href="#l13.138"></a><span id="l13.138" class="difflineminus">-  for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l13.139"></a><span id="l13.139" class="difflineminus">-  {</span>
<a href="#l13.140"></a><span id="l13.140" class="difflineplus">+  for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--) {</span>
<a href="#l13.141"></a><span id="l13.141">     nsIMAPNamespace *nspace = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l13.142"></a><span id="l13.142" class="difflineminus">-    if (nspace-&gt;GetType() == type)</span>
<a href="#l13.143"></a><span id="l13.143" class="difflineminus">-    {</span>
<a href="#l13.144"></a><span id="l13.144" class="difflineplus">+    if (nspace-&gt;GetType() == type) {</span>
<a href="#l13.145"></a><span id="l13.145">       count++;</span>
<a href="#l13.146"></a><span id="l13.146">     }</span>
<a href="#l13.147"></a><span id="l13.147">   }</span>
<a href="#l13.148"></a><span id="l13.148">   return count;</span>
<a href="#l13.149"></a><span id="l13.149"> }</span>
<a href="#l13.150"></a><span id="l13.150"> </span>
<a href="#l13.151"></a><span id="l13.151" class="difflineminus">-int nsIMAPNamespaceList::AddNewNamespace(nsIMAPNamespace *ns)</span>
<a href="#l13.152"></a><span id="l13.152" class="difflineminus">-{</span>
<a href="#l13.153"></a><span id="l13.153" class="difflineminus">-  // If the namespace is from the NAMESPACE response, then we should see if there</span>
<a href="#l13.154"></a><span id="l13.154" class="difflineminus">-  // are any namespaces previously set by the preferences, or the default namespace.  If so, remove these.</span>
<a href="#l13.155"></a><span id="l13.155" class="difflineplus">+int nsIMAPNamespaceList::AddNewNamespace(nsIMAPNamespace *ns) {</span>
<a href="#l13.156"></a><span id="l13.156" class="difflineplus">+  // If the namespace is from the NAMESPACE response, then we should see if</span>
<a href="#l13.157"></a><span id="l13.157" class="difflineplus">+  // there are any namespaces previously set by the preferences, or the default</span>
<a href="#l13.158"></a><span id="l13.158" class="difflineplus">+  // namespace.  If so, remove these.</span>
<a href="#l13.159"></a><span id="l13.159"> </span>
<a href="#l13.160"></a><span id="l13.160" class="difflineminus">-  if (!ns-&gt;GetIsNamespaceFromPrefs())</span>
<a href="#l13.161"></a><span id="l13.161" class="difflineminus">-  {</span>
<a href="#l13.162"></a><span id="l13.162" class="difflineplus">+  if (!ns-&gt;GetIsNamespaceFromPrefs()) {</span>
<a href="#l13.163"></a><span id="l13.163">     int nodeIndex;</span>
<a href="#l13.164"></a><span id="l13.164" class="difflineminus">-        // iterate backwards because we delete elements</span>
<a href="#l13.165"></a><span id="l13.165" class="difflineminus">-    for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l13.166"></a><span id="l13.166" class="difflineminus">-    {</span>
<a href="#l13.167"></a><span id="l13.167" class="difflineplus">+    // iterate backwards because we delete elements</span>
<a href="#l13.168"></a><span id="l13.168" class="difflineplus">+    for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0;</span>
<a href="#l13.169"></a><span id="l13.169" class="difflineplus">+         nodeIndex--) {</span>
<a href="#l13.170"></a><span id="l13.170">       nsIMAPNamespace *nspace = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l13.171"></a><span id="l13.171">       // if we find existing namespace(s) that matches the</span>
<a href="#l13.172"></a><span id="l13.172">       // new one, we'll just remove the old ones and let the</span>
<a href="#l13.173"></a><span id="l13.173">       // new one get added when we've finished checking for</span>
<a href="#l13.174"></a><span id="l13.174">       // matching namespaces or namespaces that came from prefs.</span>
<a href="#l13.175"></a><span id="l13.175">       if (nspace &amp;&amp; (nspace-&gt;GetIsNamespaceFromPrefs() ||</span>
<a href="#l13.176"></a><span id="l13.176">                      (!PL_strcmp(ns-&gt;GetPrefix(), nspace-&gt;GetPrefix()) &amp;&amp;</span>
<a href="#l13.177"></a><span id="l13.177">                       ns-&gt;GetType() == nspace-&gt;GetType() &amp;&amp;</span>
<a href="#l13.178"></a><span id="l13.178" class="difflineminus">-                      ns-&gt;GetDelimiter() == nspace-&gt;GetDelimiter())))</span>
<a href="#l13.179"></a><span id="l13.179" class="difflineminus">-      {</span>
<a href="#l13.180"></a><span id="l13.180" class="difflineplus">+                      ns-&gt;GetDelimiter() == nspace-&gt;GetDelimiter()))) {</span>
<a href="#l13.181"></a><span id="l13.181">         m_NamespaceList.RemoveElementAt(nodeIndex);</span>
<a href="#l13.182"></a><span id="l13.182">         delete nspace;</span>
<a href="#l13.183"></a><span id="l13.183">       }</span>
<a href="#l13.184"></a><span id="l13.184">     }</span>
<a href="#l13.185"></a><span id="l13.185">   }</span>
<a href="#l13.186"></a><span id="l13.186"> </span>
<a href="#l13.187"></a><span id="l13.187">   // Add the new namespace to the list.  This must come after the removing code,</span>
<a href="#l13.188"></a><span id="l13.188">   // or else we could never add the initial kDefaultNamespace type to the list.</span>
<a href="#l13.189"></a><span id="l13.189">   m_NamespaceList.AppendElement(ns);</span>
<a href="#l13.190"></a><span id="l13.190"> </span>
<a href="#l13.191"></a><span id="l13.191">   return 0;</span>
<a href="#l13.192"></a><span id="l13.192"> }</span>
<a href="#l13.193"></a><span id="l13.193"> </span>
<a href="#l13.194"></a><span id="l13.194" class="difflineminus">-</span>
<a href="#l13.195"></a><span id="l13.195" class="difflineminus">-// chrisf - later, fix this to know the real concept of &quot;default&quot; namespace of a given type</span>
<a href="#l13.196"></a><span id="l13.196" class="difflineminus">-nsIMAPNamespace *nsIMAPNamespaceList::GetDefaultNamespaceOfType(EIMAPNamespaceType type)</span>
<a href="#l13.197"></a><span id="l13.197" class="difflineminus">-{</span>
<a href="#l13.198"></a><span id="l13.198" class="difflineplus">+// chrisf - later, fix this to know the real concept of &quot;default&quot; namespace of a</span>
<a href="#l13.199"></a><span id="l13.199" class="difflineplus">+// given type</span>
<a href="#l13.200"></a><span id="l13.200" class="difflineplus">+nsIMAPNamespace *nsIMAPNamespaceList::GetDefaultNamespaceOfType(</span>
<a href="#l13.201"></a><span id="l13.201" class="difflineplus">+    EIMAPNamespaceType type) {</span>
<a href="#l13.202"></a><span id="l13.202">   nsIMAPNamespace *rv = 0, *firstOfType = 0;</span>
<a href="#l13.203"></a><span id="l13.203"> </span>
<a href="#l13.204"></a><span id="l13.204">   int nodeIndex, count = m_NamespaceList.Length();</span>
<a href="#l13.205"></a><span id="l13.205" class="difflineminus">-  for (nodeIndex= 0; nodeIndex &lt; count &amp;&amp; !rv; nodeIndex++)</span>
<a href="#l13.206"></a><span id="l13.206" class="difflineminus">-  {</span>
<a href="#l13.207"></a><span id="l13.207" class="difflineplus">+  for (nodeIndex = 0; nodeIndex &lt; count &amp;&amp; !rv; nodeIndex++) {</span>
<a href="#l13.208"></a><span id="l13.208">     nsIMAPNamespace *ns = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l13.209"></a><span id="l13.209" class="difflineminus">-    if (ns-&gt;GetType() == type)</span>
<a href="#l13.210"></a><span id="l13.210" class="difflineminus">-    {</span>
<a href="#l13.211"></a><span id="l13.211" class="difflineminus">-      if (!firstOfType)</span>
<a href="#l13.212"></a><span id="l13.212" class="difflineminus">-        firstOfType = ns;</span>
<a href="#l13.213"></a><span id="l13.213" class="difflineminus">-      if (!(*(ns-&gt;GetPrefix())))</span>
<a href="#l13.214"></a><span id="l13.214" class="difflineminus">-      {</span>
<a href="#l13.215"></a><span id="l13.215" class="difflineplus">+    if (ns-&gt;GetType() == type) {</span>
<a href="#l13.216"></a><span id="l13.216" class="difflineplus">+      if (!firstOfType) firstOfType = ns;</span>
<a href="#l13.217"></a><span id="l13.217" class="difflineplus">+      if (!(*(ns-&gt;GetPrefix()))) {</span>
<a href="#l13.218"></a><span id="l13.218">         // This namespace's prefix is &quot;&quot;</span>
<a href="#l13.219"></a><span id="l13.219">         // Therefore it is the default</span>
<a href="#l13.220"></a><span id="l13.220">         rv = ns;</span>
<a href="#l13.221"></a><span id="l13.221">       }</span>
<a href="#l13.222"></a><span id="l13.222">     }</span>
<a href="#l13.223"></a><span id="l13.223">   }</span>
<a href="#l13.224"></a><span id="l13.224" class="difflineminus">-  if (!rv)</span>
<a href="#l13.225"></a><span id="l13.225" class="difflineminus">-    rv = firstOfType;</span>
<a href="#l13.226"></a><span id="l13.226" class="difflineplus">+  if (!rv) rv = firstOfType;</span>
<a href="#l13.227"></a><span id="l13.227">   return rv;</span>
<a href="#l13.228"></a><span id="l13.228"> }</span>
<a href="#l13.229"></a><span id="l13.229"> </span>
<a href="#l13.230"></a><span id="l13.230" class="difflineminus">-nsIMAPNamespaceList::~nsIMAPNamespaceList()</span>
<a href="#l13.231"></a><span id="l13.231" class="difflineminus">-{</span>
<a href="#l13.232"></a><span id="l13.232" class="difflineplus">+nsIMAPNamespaceList::~nsIMAPNamespaceList() {</span>
<a href="#l13.233"></a><span id="l13.233">   ClearNamespaces(true, true, true);</span>
<a href="#l13.234"></a><span id="l13.234"> }</span>
<a href="#l13.235"></a><span id="l13.235"> </span>
<a href="#l13.236"></a><span id="l13.236" class="difflineminus">-// ClearNamespaces removes and deletes the namespaces specified, and if there are no namespaces left,</span>
<a href="#l13.237"></a><span id="l13.237" class="difflineminus">-void nsIMAPNamespaceList::ClearNamespaces(bool deleteFromPrefsNamespaces, bool deleteServerAdvertisedNamespaces, bool reallyDelete)</span>
<a href="#l13.238"></a><span id="l13.238" class="difflineminus">-{</span>
<a href="#l13.239"></a><span id="l13.239" class="difflineplus">+// ClearNamespaces removes and deletes the namespaces specified, and if there</span>
<a href="#l13.240"></a><span id="l13.240" class="difflineplus">+// are no namespaces left,</span>
<a href="#l13.241"></a><span id="l13.241" class="difflineplus">+void nsIMAPNamespaceList::ClearNamespaces(bool deleteFromPrefsNamespaces,</span>
<a href="#l13.242"></a><span id="l13.242" class="difflineplus">+                                          bool deleteServerAdvertisedNamespaces,</span>
<a href="#l13.243"></a><span id="l13.243" class="difflineplus">+                                          bool reallyDelete) {</span>
<a href="#l13.244"></a><span id="l13.244">   int nodeIndex;</span>
<a href="#l13.245"></a><span id="l13.245"> </span>
<a href="#l13.246"></a><span id="l13.246" class="difflineminus">-    // iterate backwards because we delete elements</span>
<a href="#l13.247"></a><span id="l13.247" class="difflineminus">-  for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l13.248"></a><span id="l13.248" class="difflineminus">-  {</span>
<a href="#l13.249"></a><span id="l13.249" class="difflineplus">+  // iterate backwards because we delete elements</span>
<a href="#l13.250"></a><span id="l13.250" class="difflineplus">+  for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--) {</span>
<a href="#l13.251"></a><span id="l13.251">     nsIMAPNamespace *ns = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l13.252"></a><span id="l13.252" class="difflineminus">-    if (ns-&gt;GetIsNamespaceFromPrefs())</span>
<a href="#l13.253"></a><span id="l13.253" class="difflineminus">-    {</span>
<a href="#l13.254"></a><span id="l13.254" class="difflineminus">-      if (deleteFromPrefsNamespaces)</span>
<a href="#l13.255"></a><span id="l13.255" class="difflineminus">-      {</span>
<a href="#l13.256"></a><span id="l13.256" class="difflineplus">+    if (ns-&gt;GetIsNamespaceFromPrefs()) {</span>
<a href="#l13.257"></a><span id="l13.257" class="difflineplus">+      if (deleteFromPrefsNamespaces) {</span>
<a href="#l13.258"></a><span id="l13.258">         m_NamespaceList.RemoveElementAt(nodeIndex);</span>
<a href="#l13.259"></a><span id="l13.259" class="difflineminus">-        if (reallyDelete)</span>
<a href="#l13.260"></a><span id="l13.260" class="difflineminus">-          delete ns;</span>
<a href="#l13.261"></a><span id="l13.261" class="difflineplus">+        if (reallyDelete) delete ns;</span>
<a href="#l13.262"></a><span id="l13.262">       }</span>
<a href="#l13.263"></a><span id="l13.263" class="difflineminus">-    }</span>
<a href="#l13.264"></a><span id="l13.264" class="difflineminus">-    else if (deleteServerAdvertisedNamespaces)</span>
<a href="#l13.265"></a><span id="l13.265" class="difflineminus">-    {</span>
<a href="#l13.266"></a><span id="l13.266" class="difflineplus">+    } else if (deleteServerAdvertisedNamespaces) {</span>
<a href="#l13.267"></a><span id="l13.267">       m_NamespaceList.RemoveElementAt(nodeIndex);</span>
<a href="#l13.268"></a><span id="l13.268" class="difflineminus">-      if (reallyDelete)</span>
<a href="#l13.269"></a><span id="l13.269" class="difflineminus">-        delete ns;</span>
<a href="#l13.270"></a><span id="l13.270" class="difflineplus">+      if (reallyDelete) delete ns;</span>
<a href="#l13.271"></a><span id="l13.271">     }</span>
<a href="#l13.272"></a><span id="l13.272">   }</span>
<a href="#l13.273"></a><span id="l13.273"> }</span>
<a href="#l13.274"></a><span id="l13.274"> </span>
<a href="#l13.275"></a><span id="l13.275" class="difflineminus">-nsIMAPNamespace *nsIMAPNamespaceList::GetNamespaceNumber(int nodeIndex)</span>
<a href="#l13.276"></a><span id="l13.276" class="difflineminus">-{</span>
<a href="#l13.277"></a><span id="l13.277" class="difflineminus">-  NS_ASSERTION(nodeIndex &gt;= 0 &amp;&amp; nodeIndex &lt; GetNumberOfNamespaces(), &quot;invalid IMAP namespace node index&quot;);</span>
<a href="#l13.278"></a><span id="l13.278" class="difflineplus">+nsIMAPNamespace *nsIMAPNamespaceList::GetNamespaceNumber(int nodeIndex) {</span>
<a href="#l13.279"></a><span id="l13.279" class="difflineplus">+  NS_ASSERTION(nodeIndex &gt;= 0 &amp;&amp; nodeIndex &lt; GetNumberOfNamespaces(),</span>
<a href="#l13.280"></a><span id="l13.280" class="difflineplus">+               &quot;invalid IMAP namespace node index&quot;);</span>
<a href="#l13.281"></a><span id="l13.281">   if (nodeIndex &lt; 0) nodeIndex = 0;</span>
<a href="#l13.282"></a><span id="l13.282"> </span>
<a href="#l13.283"></a><span id="l13.283">   // XXX really could be just ElementAt; that's why we have the assertion</span>
<a href="#l13.284"></a><span id="l13.284">   return m_NamespaceList.SafeElementAt(nodeIndex);</span>
<a href="#l13.285"></a><span id="l13.285"> }</span>
<a href="#l13.286"></a><span id="l13.286"> </span>
<a href="#l13.287"></a><span id="l13.287" class="difflineminus">-nsIMAPNamespace *nsIMAPNamespaceList::GetNamespaceNumber(int nodeIndex, EIMAPNamespaceType type)</span>
<a href="#l13.288"></a><span id="l13.288" class="difflineminus">-{</span>
<a href="#l13.289"></a><span id="l13.289" class="difflineplus">+nsIMAPNamespace *nsIMAPNamespaceList::GetNamespaceNumber(</span>
<a href="#l13.290"></a><span id="l13.290" class="difflineplus">+    int nodeIndex, EIMAPNamespaceType type) {</span>
<a href="#l13.291"></a><span id="l13.291">   int nodeCount, count = 0;</span>
<a href="#l13.292"></a><span id="l13.292" class="difflineminus">-  for (nodeCount = m_NamespaceList.Length() - 1; nodeCount &gt;= 0; nodeCount--)</span>
<a href="#l13.293"></a><span id="l13.293" class="difflineminus">-  {</span>
<a href="#l13.294"></a><span id="l13.294" class="difflineplus">+  for (nodeCount = m_NamespaceList.Length() - 1; nodeCount &gt;= 0; nodeCount--) {</span>
<a href="#l13.295"></a><span id="l13.295">     nsIMAPNamespace *nspace = m_NamespaceList.ElementAt(nodeCount);</span>
<a href="#l13.296"></a><span id="l13.296" class="difflineminus">-    if (nspace-&gt;GetType() == type)</span>
<a href="#l13.297"></a><span id="l13.297" class="difflineminus">-    {</span>
<a href="#l13.298"></a><span id="l13.298" class="difflineplus">+    if (nspace-&gt;GetType() == type) {</span>
<a href="#l13.299"></a><span id="l13.299">       count++;</span>
<a href="#l13.300"></a><span id="l13.300" class="difflineminus">-      if (count == nodeIndex)</span>
<a href="#l13.301"></a><span id="l13.301" class="difflineminus">-        return nspace;</span>
<a href="#l13.302"></a><span id="l13.302" class="difflineplus">+      if (count == nodeIndex) return nspace;</span>
<a href="#l13.303"></a><span id="l13.303">     }</span>
<a href="#l13.304"></a><span id="l13.304">   }</span>
<a href="#l13.305"></a><span id="l13.305">   return nullptr;</span>
<a href="#l13.306"></a><span id="l13.306"> }</span>
<a href="#l13.307"></a><span id="l13.307"> </span>
<a href="#l13.308"></a><span id="l13.308" class="difflineminus">-nsIMAPNamespace *nsIMAPNamespaceList::GetNamespaceForMailbox(const char *boxname)</span>
<a href="#l13.309"></a><span id="l13.309" class="difflineminus">-{</span>
<a href="#l13.310"></a><span id="l13.310" class="difflineminus">-  // We want to find the LONGEST substring that matches the beginning of this mailbox's path.</span>
<a href="#l13.311"></a><span id="l13.311" class="difflineminus">-  // This accounts for nested namespaces  (i.e. &quot;Public/&quot; and &quot;Public/Users/&quot;)</span>
<a href="#l13.312"></a><span id="l13.312" class="difflineplus">+nsIMAPNamespace *nsIMAPNamespaceList::GetNamespaceForMailbox(</span>
<a href="#l13.313"></a><span id="l13.313" class="difflineplus">+    const char *boxname) {</span>
<a href="#l13.314"></a><span id="l13.314" class="difflineplus">+  // We want to find the LONGEST substring that matches the beginning of this</span>
<a href="#l13.315"></a><span id="l13.315" class="difflineplus">+  // mailbox's path. This accounts for nested namespaces  (i.e. &quot;Public/&quot; and</span>
<a href="#l13.316"></a><span id="l13.316" class="difflineplus">+  // &quot;Public/Users/&quot;)</span>
<a href="#l13.317"></a><span id="l13.317"> </span>
<a href="#l13.318"></a><span id="l13.318">   // Also, we want to match the namespace's mailbox to that namespace also:</span>
<a href="#l13.319"></a><span id="l13.319">   // The Personal box will match the Personal/ namespace, etc.</span>
<a href="#l13.320"></a><span id="l13.320"> </span>
<a href="#l13.321"></a><span id="l13.321" class="difflineminus">-  // these lists shouldn't be too long (99% chance there won't be more than 3 or 4)</span>
<a href="#l13.322"></a><span id="l13.322" class="difflineminus">-  // so just do a linear search</span>
<a href="#l13.323"></a><span id="l13.323" class="difflineplus">+  // these lists shouldn't be too long (99% chance there won't be more than 3 or</span>
<a href="#l13.324"></a><span id="l13.324" class="difflineplus">+  // 4) so just do a linear search</span>
<a href="#l13.325"></a><span id="l13.325"> </span>
<a href="#l13.326"></a><span id="l13.326">   int lengthMatched = -1;</span>
<a href="#l13.327"></a><span id="l13.327">   int currentMatchedLength = -1;</span>
<a href="#l13.328"></a><span id="l13.328">   nsIMAPNamespace *rv = nullptr;</span>
<a href="#l13.329"></a><span id="l13.329">   int nodeIndex = 0;</span>
<a href="#l13.330"></a><span id="l13.330"> </span>
<a href="#l13.331"></a><span id="l13.331">   if (!PL_strcasecmp(boxname, &quot;INBOX&quot;))</span>
<a href="#l13.332"></a><span id="l13.332">     return GetDefaultNamespaceOfType(kPersonalNamespace);</span>
<a href="#l13.333"></a><span id="l13.333"> </span>
<a href="#l13.334"></a><span id="l13.334" class="difflineminus">-  for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l13.335"></a><span id="l13.335" class="difflineminus">-  {</span>
<a href="#l13.336"></a><span id="l13.336" class="difflineplus">+  for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--) {</span>
<a href="#l13.337"></a><span id="l13.337">     nsIMAPNamespace *nspace = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l13.338"></a><span id="l13.338">     currentMatchedLength = nspace-&gt;MailboxMatchesNamespace(boxname);</span>
<a href="#l13.339"></a><span id="l13.339" class="difflineminus">-    if (currentMatchedLength &gt; lengthMatched)</span>
<a href="#l13.340"></a><span id="l13.340" class="difflineminus">-    {</span>
<a href="#l13.341"></a><span id="l13.341" class="difflineplus">+    if (currentMatchedLength &gt; lengthMatched) {</span>
<a href="#l13.342"></a><span id="l13.342">       rv = nspace;</span>
<a href="#l13.343"></a><span id="l13.343">       lengthMatched = currentMatchedLength;</span>
<a href="#l13.344"></a><span id="l13.344">     }</span>
<a href="#l13.345"></a><span id="l13.345">   }</span>
<a href="#l13.346"></a><span id="l13.346"> </span>
<a href="#l13.347"></a><span id="l13.347">   return rv;</span>
<a href="#l13.348"></a><span id="l13.348"> }</span>
<a href="#l13.349"></a><span id="l13.349"> </span>
<a href="#l13.350"></a><span id="l13.350"> #define SERIALIZER_SEPARATORS &quot;,&quot;</span>
<a href="#l13.351"></a><span id="l13.351"> </span>
<a href="#l13.352"></a><span id="l13.352"> /**</span>
<a href="#l13.353"></a><span id="l13.353" class="difflineminus">- * If len is one, copies the first element of prefixes into serializedNamespaces.</span>
<a href="#l13.354"></a><span id="l13.354" class="difflineminus">- * If len &gt; 1, copies len strings from prefixes into serializedNamespaces</span>
<a href="#l13.355"></a><span id="l13.355" class="difflineminus">- * as a comma-separated list of quoted strings.</span>
<a href="#l13.356"></a><span id="l13.356" class="difflineplus">+ * If len is one, copies the first element of prefixes into</span>
<a href="#l13.357"></a><span id="l13.357" class="difflineplus">+ * serializedNamespaces. If len &gt; 1, copies len strings from prefixes into</span>
<a href="#l13.358"></a><span id="l13.358" class="difflineplus">+ * serializedNamespaces as a comma-separated list of quoted strings.</span>
<a href="#l13.359"></a><span id="l13.359">  */</span>
<a href="#l13.360"></a><span id="l13.360" class="difflineminus">-nsresult nsIMAPNamespaceList::SerializeNamespaces(char **prefixes, int len,</span>
<a href="#l13.361"></a><span id="l13.361" class="difflineminus">-                                                  nsCString &amp;serializedNamespaces)</span>
<a href="#l13.362"></a><span id="l13.362" class="difflineminus">-{</span>
<a href="#l13.363"></a><span id="l13.363" class="difflineminus">-  if (len &lt;= 0)</span>
<a href="#l13.364"></a><span id="l13.364" class="difflineminus">-    return NS_OK;</span>
<a href="#l13.365"></a><span id="l13.365" class="difflineplus">+nsresult nsIMAPNamespaceList::SerializeNamespaces(</span>
<a href="#l13.366"></a><span id="l13.366" class="difflineplus">+    char **prefixes, int len, nsCString &amp;serializedNamespaces) {</span>
<a href="#l13.367"></a><span id="l13.367" class="difflineplus">+  if (len &lt;= 0) return NS_OK;</span>
<a href="#l13.368"></a><span id="l13.368"> </span>
<a href="#l13.369"></a><span id="l13.369" class="difflineminus">-  if (len == 1)</span>
<a href="#l13.370"></a><span id="l13.370" class="difflineminus">-  {</span>
<a href="#l13.371"></a><span id="l13.371" class="difflineplus">+  if (len == 1) {</span>
<a href="#l13.372"></a><span id="l13.372">     serializedNamespaces.Assign(prefixes[0]);</span>
<a href="#l13.373"></a><span id="l13.373">     return NS_OK;</span>
<a href="#l13.374"></a><span id="l13.374">   }</span>
<a href="#l13.375"></a><span id="l13.375"> </span>
<a href="#l13.376"></a><span id="l13.376" class="difflineminus">-  for (int i = 0; i &lt; len; i++)</span>
<a href="#l13.377"></a><span id="l13.377" class="difflineminus">-  {</span>
<a href="#l13.378"></a><span id="l13.378" class="difflineminus">-    if (i &gt; 0)</span>
<a href="#l13.379"></a><span id="l13.379" class="difflineminus">-      serializedNamespaces.Append(',');</span>
<a href="#l13.380"></a><span id="l13.380" class="difflineplus">+  for (int i = 0; i &lt; len; i++) {</span>
<a href="#l13.381"></a><span id="l13.381" class="difflineplus">+    if (i &gt; 0) serializedNamespaces.Append(',');</span>
<a href="#l13.382"></a><span id="l13.382"> </span>
<a href="#l13.383"></a><span id="l13.383">     serializedNamespaces.Append('&quot;');</span>
<a href="#l13.384"></a><span id="l13.384">     serializedNamespaces.Append(prefixes[i]);</span>
<a href="#l13.385"></a><span id="l13.385">     serializedNamespaces.Append('&quot;');</span>
<a href="#l13.386"></a><span id="l13.386">   }</span>
<a href="#l13.387"></a><span id="l13.387">   return NS_OK;</span>
<a href="#l13.388"></a><span id="l13.388"> }</span>
<a href="#l13.389"></a><span id="l13.389"> </span>
<a href="#l13.390"></a><span id="l13.390"> /* str is the string which needs to be unserialized.</span>
<a href="#l13.391"></a><span id="l13.391" class="difflineminus">-   If prefixes is NULL, simply returns the number of namespaces in str.  (len is ignored)</span>
<a href="#l13.392"></a><span id="l13.392" class="difflineminus">-   If prefixes is not NULL, it should be an array of length len which is to be filled in</span>
<a href="#l13.393"></a><span id="l13.393" class="difflineminus">-   with newly-allocated string.  Returns the number of strings filled in.</span>
<a href="#l13.394"></a><span id="l13.394" class="difflineplus">+   If prefixes is NULL, simply returns the number of namespaces in str.  (len is</span>
<a href="#l13.395"></a><span id="l13.395" class="difflineplus">+   ignored) If prefixes is not NULL, it should be an array of length len which</span>
<a href="#l13.396"></a><span id="l13.396" class="difflineplus">+   is to be filled in with newly-allocated string.  Returns the number of</span>
<a href="#l13.397"></a><span id="l13.397" class="difflineplus">+   strings filled in.</span>
<a href="#l13.398"></a><span id="l13.398"> */</span>
<a href="#l13.399"></a><span id="l13.399" class="difflineminus">-int nsIMAPNamespaceList::UnserializeNamespaces(const char *str, char **prefixes, int len)</span>
<a href="#l13.400"></a><span id="l13.400" class="difflineminus">-{</span>
<a href="#l13.401"></a><span id="l13.401" class="difflineminus">-  if (!str)</span>
<a href="#l13.402"></a><span id="l13.402" class="difflineminus">-    return 0;</span>
<a href="#l13.403"></a><span id="l13.403" class="difflineminus">-  if (!prefixes)</span>
<a href="#l13.404"></a><span id="l13.404" class="difflineminus">-  {</span>
<a href="#l13.405"></a><span id="l13.405" class="difflineminus">-    if (str[0] != '&quot;')</span>
<a href="#l13.406"></a><span id="l13.406" class="difflineminus">-      return 1;</span>
<a href="#l13.407"></a><span id="l13.407" class="difflineplus">+int nsIMAPNamespaceList::UnserializeNamespaces(const char *str, char **prefixes,</span>
<a href="#l13.408"></a><span id="l13.408" class="difflineplus">+                                               int len) {</span>
<a href="#l13.409"></a><span id="l13.409" class="difflineplus">+  if (!str) return 0;</span>
<a href="#l13.410"></a><span id="l13.410" class="difflineplus">+  if (!prefixes) {</span>
<a href="#l13.411"></a><span id="l13.411" class="difflineplus">+    if (str[0] != '&quot;') return 1;</span>
<a href="#l13.412"></a><span id="l13.412"> </span>
<a href="#l13.413"></a><span id="l13.413">     int count = 0;</span>
<a href="#l13.414"></a><span id="l13.414">     char *ourstr = PL_strdup(str);</span>
<a href="#l13.415"></a><span id="l13.415">     char *origOurStr = ourstr;</span>
<a href="#l13.416"></a><span id="l13.416" class="difflineminus">-    if (ourstr)</span>
<a href="#l13.417"></a><span id="l13.417" class="difflineminus">-    {</span>
<a href="#l13.418"></a><span id="l13.418" class="difflineminus">-      char *token = NS_strtok(SERIALIZER_SEPARATORS, &amp;ourstr );</span>
<a href="#l13.419"></a><span id="l13.419" class="difflineminus">-      while (token != nullptr)</span>
<a href="#l13.420"></a><span id="l13.420" class="difflineminus">-      {</span>
<a href="#l13.421"></a><span id="l13.421" class="difflineminus">-        token = NS_strtok(SERIALIZER_SEPARATORS, &amp;ourstr );</span>
<a href="#l13.422"></a><span id="l13.422" class="difflineplus">+    if (ourstr) {</span>
<a href="#l13.423"></a><span id="l13.423" class="difflineplus">+      char *token = NS_strtok(SERIALIZER_SEPARATORS, &amp;ourstr);</span>
<a href="#l13.424"></a><span id="l13.424" class="difflineplus">+      while (token != nullptr) {</span>
<a href="#l13.425"></a><span id="l13.425" class="difflineplus">+        token = NS_strtok(SERIALIZER_SEPARATORS, &amp;ourstr);</span>
<a href="#l13.426"></a><span id="l13.426">         count++;</span>
<a href="#l13.427"></a><span id="l13.427">       }</span>
<a href="#l13.428"></a><span id="l13.428">       PR_Free(origOurStr);</span>
<a href="#l13.429"></a><span id="l13.429">     }</span>
<a href="#l13.430"></a><span id="l13.430">     return count;</span>
<a href="#l13.431"></a><span id="l13.431">   }</span>
<a href="#l13.432"></a><span id="l13.432"> </span>
<a href="#l13.433"></a><span id="l13.433" class="difflineminus">-  if ((str[0] != '&quot;') &amp;&amp; (len &gt;= 1))</span>
<a href="#l13.434"></a><span id="l13.434" class="difflineminus">-  {</span>
<a href="#l13.435"></a><span id="l13.435" class="difflineplus">+  if ((str[0] != '&quot;') &amp;&amp; (len &gt;= 1)) {</span>
<a href="#l13.436"></a><span id="l13.436">     prefixes[0] = PL_strdup(str);</span>
<a href="#l13.437"></a><span id="l13.437">     return 1;</span>
<a href="#l13.438"></a><span id="l13.438">   }</span>
<a href="#l13.439"></a><span id="l13.439"> </span>
<a href="#l13.440"></a><span id="l13.440">   int count = 0;</span>
<a href="#l13.441"></a><span id="l13.441">   char *ourstr = PL_strdup(str);</span>
<a href="#l13.442"></a><span id="l13.442">   char *origOurStr = ourstr;</span>
<a href="#l13.443"></a><span id="l13.443" class="difflineminus">-  if (ourstr)</span>
<a href="#l13.444"></a><span id="l13.444" class="difflineminus">-  {</span>
<a href="#l13.445"></a><span id="l13.445" class="difflineminus">-    char *token = NS_strtok(SERIALIZER_SEPARATORS, &amp;ourstr );</span>
<a href="#l13.446"></a><span id="l13.446" class="difflineminus">-    while ((count &lt; len) &amp;&amp; (token != nullptr))</span>
<a href="#l13.447"></a><span id="l13.447" class="difflineminus">-    {</span>
<a href="#l13.448"></a><span id="l13.448" class="difflineplus">+  if (ourstr) {</span>
<a href="#l13.449"></a><span id="l13.449" class="difflineplus">+    char *token = NS_strtok(SERIALIZER_SEPARATORS, &amp;ourstr);</span>
<a href="#l13.450"></a><span id="l13.450" class="difflineplus">+    while ((count &lt; len) &amp;&amp; (token != nullptr)) {</span>
<a href="#l13.451"></a><span id="l13.451">       char *current = PL_strdup(token), *where = current;</span>
<a href="#l13.452"></a><span id="l13.452" class="difflineminus">-      if (where[0] == '&quot;')</span>
<a href="#l13.453"></a><span id="l13.453" class="difflineminus">-        where++;</span>
<a href="#l13.454"></a><span id="l13.454" class="difflineminus">-      if (where[PL_strlen(where)-1] == '&quot;')</span>
<a href="#l13.455"></a><span id="l13.455" class="difflineminus">-        where[PL_strlen(where)-1] = 0;</span>
<a href="#l13.456"></a><span id="l13.456" class="difflineplus">+      if (where[0] == '&quot;') where++;</span>
<a href="#l13.457"></a><span id="l13.457" class="difflineplus">+      if (where[PL_strlen(where) - 1] == '&quot;') where[PL_strlen(where) - 1] = 0;</span>
<a href="#l13.458"></a><span id="l13.458">       prefixes[count] = PL_strdup(where);</span>
<a href="#l13.459"></a><span id="l13.459">       PR_FREEIF(current);</span>
<a href="#l13.460"></a><span id="l13.460" class="difflineminus">-      token = NS_strtok(SERIALIZER_SEPARATORS, &amp;ourstr );</span>
<a href="#l13.461"></a><span id="l13.461" class="difflineplus">+      token = NS_strtok(SERIALIZER_SEPARATORS, &amp;ourstr);</span>
<a href="#l13.462"></a><span id="l13.462">       count++;</span>
<a href="#l13.463"></a><span id="l13.463">     }</span>
<a href="#l13.464"></a><span id="l13.464">     PR_Free(origOurStr);</span>
<a href="#l13.465"></a><span id="l13.465">   }</span>
<a href="#l13.466"></a><span id="l13.466">   return count;</span>
<a href="#l13.467"></a><span id="l13.467"> }</span>
<a href="#l13.468"></a><span id="l13.468"> </span>
<a href="#l13.469"></a><span id="l13.469" class="difflineminus">-char *nsIMAPNamespaceList::AllocateCanonicalFolderName(const char *onlineFolderName, char delimiter)</span>
<a href="#l13.470"></a><span id="l13.470" class="difflineminus">-{</span>
<a href="#l13.471"></a><span id="l13.471" class="difflineplus">+char *nsIMAPNamespaceList::AllocateCanonicalFolderName(</span>
<a href="#l13.472"></a><span id="l13.472" class="difflineplus">+    const char *onlineFolderName, char delimiter) {</span>
<a href="#l13.473"></a><span id="l13.473">   char *canonicalPath = nullptr;</span>
<a href="#l13.474"></a><span id="l13.474">   if (delimiter)</span>
<a href="#l13.475"></a><span id="l13.475" class="difflineminus">-    canonicalPath = nsImapUrl::ReplaceCharsInCopiedString(onlineFolderName, delimiter , '/');</span>
<a href="#l13.476"></a><span id="l13.476" class="difflineplus">+    canonicalPath =</span>
<a href="#l13.477"></a><span id="l13.477" class="difflineplus">+        nsImapUrl::ReplaceCharsInCopiedString(onlineFolderName, delimiter, '/');</span>
<a href="#l13.478"></a><span id="l13.478">   else</span>
<a href="#l13.479"></a><span id="l13.479">     canonicalPath = PL_strdup(onlineFolderName);</span>
<a href="#l13.480"></a><span id="l13.480"> </span>
<a href="#l13.481"></a><span id="l13.481">   // eat any escape characters for escaped dir separators</span>
<a href="#l13.482"></a><span id="l13.482" class="difflineminus">-  if (canonicalPath)</span>
<a href="#l13.483"></a><span id="l13.483" class="difflineminus">-  {</span>
<a href="#l13.484"></a><span id="l13.484" class="difflineplus">+  if (canonicalPath) {</span>
<a href="#l13.485"></a><span id="l13.485">     char *currentEscapeSequence = strstr(canonicalPath, &quot;\\/&quot;);</span>
<a href="#l13.486"></a><span id="l13.486" class="difflineminus">-    while (currentEscapeSequence)</span>
<a href="#l13.487"></a><span id="l13.487" class="difflineminus">-    {</span>
<a href="#l13.488"></a><span id="l13.488" class="difflineminus">-      strcpy(currentEscapeSequence, currentEscapeSequence+1);</span>
<a href="#l13.489"></a><span id="l13.489" class="difflineminus">-      currentEscapeSequence = strstr(currentEscapeSequence+1, &quot;\\/&quot;);</span>
<a href="#l13.490"></a><span id="l13.490" class="difflineplus">+    while (currentEscapeSequence) {</span>
<a href="#l13.491"></a><span id="l13.491" class="difflineplus">+      strcpy(currentEscapeSequence, currentEscapeSequence + 1);</span>
<a href="#l13.492"></a><span id="l13.492" class="difflineplus">+      currentEscapeSequence = strstr(currentEscapeSequence + 1, &quot;\\/&quot;);</span>
<a href="#l13.493"></a><span id="l13.493">     }</span>
<a href="#l13.494"></a><span id="l13.494">   }</span>
<a href="#l13.495"></a><span id="l13.495"> </span>
<a href="#l13.496"></a><span id="l13.496">   return canonicalPath;</span>
<a href="#l13.497"></a><span id="l13.497"> }</span>
<a href="#l13.498"></a><span id="l13.498"> </span>
<a href="#l13.499"></a><span id="l13.499"> /*</span>
<a href="#l13.500"></a><span id="l13.500">   GetFolderNameWithoutNamespace takes as input a folder name</span>
<a href="#l13.501"></a><span id="l13.501" class="difflineminus">-  in canonical form, and the namespace for the given folder.  It returns an allocated</span>
<a href="#l13.502"></a><span id="l13.502" class="difflineminus">-  string of the folder's path with the namespace string stripped out.  For instance,</span>
<a href="#l13.503"></a><span id="l13.503" class="difflineminus">-  when passed the folder Folders/a/b where the namespace is &quot;Folders/&quot;, it will return</span>
<a href="#l13.504"></a><span id="l13.504" class="difflineminus">-  &quot;a/b&quot;.  Similarly, if the folder name is &quot;#news/comp/mail/imap&quot; in canonical form,</span>
<a href="#l13.505"></a><span id="l13.505" class="difflineminus">-  with a real delimiter of &quot;.&quot; and a namespace of &quot;#news.&quot;, it will return &quot;comp/mail/imap&quot;.</span>
<a href="#l13.506"></a><span id="l13.506" class="difflineminus">-  The return value is always in canonical form.</span>
<a href="#l13.507"></a><span id="l13.507" class="difflineplus">+  in canonical form, and the namespace for the given folder.  It returns an</span>
<a href="#l13.508"></a><span id="l13.508" class="difflineplus">+  allocated string of the folder's path with the namespace string stripped out.</span>
<a href="#l13.509"></a><span id="l13.509" class="difflineplus">+  For instance, when passed the folder Folders/a/b where the namespace is</span>
<a href="#l13.510"></a><span id="l13.510" class="difflineplus">+  &quot;Folders/&quot;, it will return &quot;a/b&quot;.  Similarly, if the folder name is</span>
<a href="#l13.511"></a><span id="l13.511" class="difflineplus">+  &quot;#news/comp/mail/imap&quot; in canonical form, with a real delimiter of &quot;.&quot; and a</span>
<a href="#l13.512"></a><span id="l13.512" class="difflineplus">+  namespace of &quot;#news.&quot;, it will return &quot;comp/mail/imap&quot;. The return value is</span>
<a href="#l13.513"></a><span id="l13.513" class="difflineplus">+  always in canonical form.</span>
<a href="#l13.514"></a><span id="l13.514"> */</span>
<a href="#l13.515"></a><span id="l13.515" class="difflineminus">-char* nsIMAPNamespaceList::GetFolderNameWithoutNamespace(nsIMAPNamespace *namespaceForFolder, const char *canonicalFolderName)</span>
<a href="#l13.516"></a><span id="l13.516" class="difflineminus">-{</span>
<a href="#l13.517"></a><span id="l13.517" class="difflineplus">+char *nsIMAPNamespaceList::GetFolderNameWithoutNamespace(</span>
<a href="#l13.518"></a><span id="l13.518" class="difflineplus">+    nsIMAPNamespace *namespaceForFolder, const char *canonicalFolderName) {</span>
<a href="#l13.519"></a><span id="l13.519">   NS_ASSERTION(canonicalFolderName, &quot;null folder name&quot;);</span>
<a href="#l13.520"></a><span id="l13.520"> #ifdef DEBUG</span>
<a href="#l13.521"></a><span id="l13.521" class="difflineminus">-  NS_ASSERTION(namespaceForFolder || !PL_strcasecmp(canonicalFolderName, &quot;INBOX&quot;), &quot;need namespace or INBOX&quot;);</span>
<a href="#l13.522"></a><span id="l13.522" class="difflineplus">+  NS_ASSERTION(</span>
<a href="#l13.523"></a><span id="l13.523" class="difflineplus">+      namespaceForFolder || !PL_strcasecmp(canonicalFolderName, &quot;INBOX&quot;),</span>
<a href="#l13.524"></a><span id="l13.524" class="difflineplus">+      &quot;need namespace or INBOX&quot;);</span>
<a href="#l13.525"></a><span id="l13.525"> #endif</span>
<a href="#l13.526"></a><span id="l13.526"> </span>
<a href="#l13.527"></a><span id="l13.527">   char *retFolderName = nullptr;</span>
<a href="#l13.528"></a><span id="l13.528"> </span>
<a href="#l13.529"></a><span id="l13.529">   if (!PL_strcasecmp(canonicalFolderName, &quot;INBOX&quot;))</span>
<a href="#l13.530"></a><span id="l13.530">     return PL_strdup(canonicalFolderName);</span>
<a href="#l13.531"></a><span id="l13.531"> </span>
<a href="#l13.532"></a><span id="l13.532">   // convert the canonical path to the online path</span>
<a href="#l13.533"></a><span id="l13.533" class="difflineminus">-  char *convertedFolderName = nsIMAPNamespaceList::AllocateServerFolderName(canonicalFolderName, namespaceForFolder-&gt;GetDelimiter());</span>
<a href="#l13.534"></a><span id="l13.534" class="difflineminus">-  if (convertedFolderName)</span>
<a href="#l13.535"></a><span id="l13.535" class="difflineminus">-  {</span>
<a href="#l13.536"></a><span id="l13.536" class="difflineplus">+  char *convertedFolderName = nsIMAPNamespaceList::AllocateServerFolderName(</span>
<a href="#l13.537"></a><span id="l13.537" class="difflineplus">+      canonicalFolderName, namespaceForFolder-&gt;GetDelimiter());</span>
<a href="#l13.538"></a><span id="l13.538" class="difflineplus">+  if (convertedFolderName) {</span>
<a href="#l13.539"></a><span id="l13.539">     char *beginFolderPath = nullptr;</span>
<a href="#l13.540"></a><span id="l13.540">     if (strlen(convertedFolderName) &lt;= strlen(namespaceForFolder-&gt;GetPrefix()))</span>
<a href="#l13.541"></a><span id="l13.541">       beginFolderPath = convertedFolderName;</span>
<a href="#l13.542"></a><span id="l13.542">     else</span>
<a href="#l13.543"></a><span id="l13.543" class="difflineminus">-      beginFolderPath = convertedFolderName + strlen(namespaceForFolder-&gt;GetPrefix());</span>
<a href="#l13.544"></a><span id="l13.544" class="difflineplus">+      beginFolderPath =</span>
<a href="#l13.545"></a><span id="l13.545" class="difflineplus">+          convertedFolderName + strlen(namespaceForFolder-&gt;GetPrefix());</span>
<a href="#l13.546"></a><span id="l13.546">     NS_ASSERTION(beginFolderPath, &quot;empty folder path&quot;);</span>
<a href="#l13.547"></a><span id="l13.547" class="difflineminus">-    retFolderName = nsIMAPNamespaceList::AllocateCanonicalFolderName(beginFolderPath, namespaceForFolder-&gt;GetDelimiter());</span>
<a href="#l13.548"></a><span id="l13.548" class="difflineplus">+    retFolderName = nsIMAPNamespaceList::AllocateCanonicalFolderName(</span>
<a href="#l13.549"></a><span id="l13.549" class="difflineplus">+        beginFolderPath, namespaceForFolder-&gt;GetDelimiter());</span>
<a href="#l13.550"></a><span id="l13.550">     PR_Free(convertedFolderName);</span>
<a href="#l13.551"></a><span id="l13.551">   }</span>
<a href="#l13.552"></a><span id="l13.552"> </span>
<a href="#l13.553"></a><span id="l13.553">   NS_ASSERTION(retFolderName, &quot;returning null folder name&quot;);</span>
<a href="#l13.554"></a><span id="l13.554">   return retFolderName;</span>
<a href="#l13.555"></a><span id="l13.555"> }</span>
<a href="#l13.556"></a><span id="l13.556"> </span>
<a href="#l13.557"></a><span id="l13.557" class="difflineminus">-</span>
<a href="#l13.558"></a><span id="l13.558" class="difflineminus">-nsIMAPNamespace* nsIMAPNamespaceList::GetNamespaceForFolder(const char *hostName,</span>
<a href="#l13.559"></a><span id="l13.559" class="difflineminus">-                                                    const char *canonicalFolderName,</span>
<a href="#l13.560"></a><span id="l13.560" class="difflineminus">-                                                    char delimiter)</span>
<a href="#l13.561"></a><span id="l13.561" class="difflineminus">-{</span>
<a href="#l13.562"></a><span id="l13.562" class="difflineminus">-  if (!hostName || !canonicalFolderName)</span>
<a href="#l13.563"></a><span id="l13.563" class="difflineminus">-    return nullptr;</span>
<a href="#l13.564"></a><span id="l13.564" class="difflineplus">+nsIMAPNamespace *nsIMAPNamespaceList::GetNamespaceForFolder(</span>
<a href="#l13.565"></a><span id="l13.565" class="difflineplus">+    const char *hostName, const char *canonicalFolderName, char delimiter) {</span>
<a href="#l13.566"></a><span id="l13.566" class="difflineplus">+  if (!hostName || !canonicalFolderName) return nullptr;</span>
<a href="#l13.567"></a><span id="l13.567"> </span>
<a href="#l13.568"></a><span id="l13.568">   nsIMAPNamespace *resultNamespace = nullptr;</span>
<a href="#l13.569"></a><span id="l13.569">   nsresult rv;</span>
<a href="#l13.570"></a><span id="l13.570" class="difflineminus">-  char *convertedFolderName = nsIMAPNamespaceList::AllocateServerFolderName(canonicalFolderName, delimiter);</span>
<a href="#l13.571"></a><span id="l13.571" class="difflineplus">+  char *convertedFolderName = nsIMAPNamespaceList::AllocateServerFolderName(</span>
<a href="#l13.572"></a><span id="l13.572" class="difflineplus">+      canonicalFolderName, delimiter);</span>
<a href="#l13.573"></a><span id="l13.573"> </span>
<a href="#l13.574"></a><span id="l13.574" class="difflineminus">-  if (convertedFolderName)</span>
<a href="#l13.575"></a><span id="l13.575" class="difflineminus">-  {</span>
<a href="#l13.576"></a><span id="l13.576" class="difflineplus">+  if (convertedFolderName) {</span>
<a href="#l13.577"></a><span id="l13.577">     nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSessionList =</span>
<a href="#l13.578"></a><span id="l13.578" class="difflineminus">-             do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l13.579"></a><span id="l13.579" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l13.580"></a><span id="l13.580" class="difflineminus">-      return nullptr;</span>
<a href="#l13.581"></a><span id="l13.581" class="difflineminus">-    hostSessionList-&gt;GetNamespaceForMailboxForHost(hostName, convertedFolderName, resultNamespace);</span>
<a href="#l13.582"></a><span id="l13.582" class="difflineplus">+        do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l13.583"></a><span id="l13.583" class="difflineplus">+    if (NS_FAILED(rv)) return nullptr;</span>
<a href="#l13.584"></a><span id="l13.584" class="difflineplus">+    hostSessionList-&gt;GetNamespaceForMailboxForHost(</span>
<a href="#l13.585"></a><span id="l13.585" class="difflineplus">+        hostName, convertedFolderName, resultNamespace);</span>
<a href="#l13.586"></a><span id="l13.586">     PR_Free(convertedFolderName);</span>
<a href="#l13.587"></a><span id="l13.587" class="difflineminus">-  }</span>
<a href="#l13.588"></a><span id="l13.588" class="difflineminus">-  else</span>
<a href="#l13.589"></a><span id="l13.589" class="difflineminus">-  {</span>
<a href="#l13.590"></a><span id="l13.590" class="difflineplus">+  } else {</span>
<a href="#l13.591"></a><span id="l13.591">     NS_ASSERTION(false, &quot;couldn't get converted folder name&quot;);</span>
<a href="#l13.592"></a><span id="l13.592">   }</span>
<a href="#l13.593"></a><span id="l13.593"> </span>
<a href="#l13.594"></a><span id="l13.594">   return resultNamespace;</span>
<a href="#l13.595"></a><span id="l13.595"> }</span>
<a href="#l13.596"></a><span id="l13.596"> </span>
<a href="#l13.597"></a><span id="l13.597"> /* static */</span>
<a href="#l13.598"></a><span id="l13.598" class="difflineminus">-char *nsIMAPNamespaceList::AllocateServerFolderName(const char *canonicalFolderName, char delimiter)</span>
<a href="#l13.599"></a><span id="l13.599" class="difflineminus">-{</span>
<a href="#l13.600"></a><span id="l13.600" class="difflineplus">+char *nsIMAPNamespaceList::AllocateServerFolderName(</span>
<a href="#l13.601"></a><span id="l13.601" class="difflineplus">+    const char *canonicalFolderName, char delimiter) {</span>
<a href="#l13.602"></a><span id="l13.602">   if (delimiter)</span>
<a href="#l13.603"></a><span id="l13.603" class="difflineminus">-    return nsImapUrl::ReplaceCharsInCopiedString(canonicalFolderName, '/', delimiter);</span>
<a href="#l13.604"></a><span id="l13.604" class="difflineplus">+    return nsImapUrl::ReplaceCharsInCopiedString(canonicalFolderName, '/',</span>
<a href="#l13.605"></a><span id="l13.605" class="difflineplus">+                                                 delimiter);</span>
<a href="#l13.606"></a><span id="l13.606">   return NS_xstrdup(canonicalFolderName);</span>
<a href="#l13.607"></a><span id="l13.607"> }</span>
<a href="#l13.608"></a><span id="l13.608"> </span>
<a href="#l13.609"></a><span id="l13.609"> /*</span>
<a href="#l13.610"></a><span id="l13.610">   GetFolderOwnerNameFromPath takes as inputs a folder name</span>
<a href="#l13.611"></a><span id="l13.611">   in canonical form, and a namespace for that folder.</span>
<a href="#l13.612"></a><span id="l13.612">   The namespace MUST be of type kOtherUsersNamespace, hence the folder MUST be</span>
<a href="#l13.613"></a><span id="l13.613" class="difflineminus">-  owned by another user.  This function extracts the folder owner's name from the</span>
<a href="#l13.614"></a><span id="l13.614" class="difflineminus">-  canonical name of the folder, and returns an allocated copy of that owner's name</span>
<a href="#l13.615"></a><span id="l13.615" class="difflineplus">+  owned by another user.  This function extracts the folder owner's name from</span>
<a href="#l13.616"></a><span id="l13.616" class="difflineplus">+  the canonical name of the folder, and returns an allocated copy of that</span>
<a href="#l13.617"></a><span id="l13.617" class="difflineplus">+  owner's name</span>
<a href="#l13.618"></a><span id="l13.618"> */</span>
<a href="#l13.619"></a><span id="l13.619"> /* static */</span>
<a href="#l13.620"></a><span id="l13.620" class="difflineminus">-char *nsIMAPNamespaceList::GetFolderOwnerNameFromPath(nsIMAPNamespace *namespaceForFolder, const char *canonicalFolderName)</span>
<a href="#l13.621"></a><span id="l13.621" class="difflineminus">-{</span>
<a href="#l13.622"></a><span id="l13.622" class="difflineminus">-  if (!namespaceForFolder || !canonicalFolderName)</span>
<a href="#l13.623"></a><span id="l13.623" class="difflineminus">-  {</span>
<a href="#l13.624"></a><span id="l13.624" class="difflineminus">-    NS_ASSERTION(false,&quot;null namespace or canonical folder name&quot;);</span>
<a href="#l13.625"></a><span id="l13.625" class="difflineplus">+char *nsIMAPNamespaceList::GetFolderOwnerNameFromPath(</span>
<a href="#l13.626"></a><span id="l13.626" class="difflineplus">+    nsIMAPNamespace *namespaceForFolder, const char *canonicalFolderName) {</span>
<a href="#l13.627"></a><span id="l13.627" class="difflineplus">+  if (!namespaceForFolder || !canonicalFolderName) {</span>
<a href="#l13.628"></a><span id="l13.628" class="difflineplus">+    NS_ASSERTION(false, &quot;null namespace or canonical folder name&quot;);</span>
<a href="#l13.629"></a><span id="l13.629">     return nullptr;</span>
<a href="#l13.630"></a><span id="l13.630">   }</span>
<a href="#l13.631"></a><span id="l13.631"> </span>
<a href="#l13.632"></a><span id="l13.632">   char *rv = nullptr;</span>
<a href="#l13.633"></a><span id="l13.633"> </span>
<a href="#l13.634"></a><span id="l13.634">   // convert the canonical path to the online path</span>
<a href="#l13.635"></a><span id="l13.635" class="difflineminus">-  char *convertedFolderName = AllocateServerFolderName(canonicalFolderName, namespaceForFolder-&gt;GetDelimiter());</span>
<a href="#l13.636"></a><span id="l13.636" class="difflineminus">-  if (convertedFolderName)</span>
<a href="#l13.637"></a><span id="l13.637" class="difflineminus">-  {</span>
<a href="#l13.638"></a><span id="l13.638" class="difflineplus">+  char *convertedFolderName = AllocateServerFolderName(</span>
<a href="#l13.639"></a><span id="l13.639" class="difflineplus">+      canonicalFolderName, namespaceForFolder-&gt;GetDelimiter());</span>
<a href="#l13.640"></a><span id="l13.640" class="difflineplus">+  if (convertedFolderName) {</span>
<a href="#l13.641"></a><span id="l13.641"> #ifdef DEBUG</span>
<a href="#l13.642"></a><span id="l13.642" class="difflineminus">-    NS_ASSERTION(strlen(convertedFolderName) &gt; strlen(namespaceForFolder-&gt;GetPrefix()), &quot;server folder name invalid&quot;);</span>
<a href="#l13.643"></a><span id="l13.643" class="difflineplus">+    NS_ASSERTION(</span>
<a href="#l13.644"></a><span id="l13.644" class="difflineplus">+        strlen(convertedFolderName) &gt; strlen(namespaceForFolder-&gt;GetPrefix()),</span>
<a href="#l13.645"></a><span id="l13.645" class="difflineplus">+        &quot;server folder name invalid&quot;);</span>
<a href="#l13.646"></a><span id="l13.646"> #endif</span>
<a href="#l13.647"></a><span id="l13.647" class="difflineminus">-    if (strlen(convertedFolderName) &gt; strlen(namespaceForFolder-&gt;GetPrefix()))</span>
<a href="#l13.648"></a><span id="l13.648" class="difflineminus">-    {</span>
<a href="#l13.649"></a><span id="l13.649" class="difflineminus">-      char *owner = convertedFolderName + strlen(namespaceForFolder-&gt;GetPrefix());</span>
<a href="#l13.650"></a><span id="l13.650" class="difflineplus">+    if (strlen(convertedFolderName) &gt; strlen(namespaceForFolder-&gt;GetPrefix())) {</span>
<a href="#l13.651"></a><span id="l13.651" class="difflineplus">+      char *owner =</span>
<a href="#l13.652"></a><span id="l13.652" class="difflineplus">+          convertedFolderName + strlen(namespaceForFolder-&gt;GetPrefix());</span>
<a href="#l13.653"></a><span id="l13.653">       NS_ASSERTION(owner, &quot;couldn't find folder owner&quot;);</span>
<a href="#l13.654"></a><span id="l13.654">       char *nextDelimiter = strchr(owner, namespaceForFolder-&gt;GetDelimiter());</span>
<a href="#l13.655"></a><span id="l13.655" class="difflineminus">-      // if !nextDelimiter, then the path is of the form Shared/Users/chrisf   (no subfolder)</span>
<a href="#l13.656"></a><span id="l13.656" class="difflineminus">-      if (nextDelimiter)</span>
<a href="#l13.657"></a><span id="l13.657" class="difflineminus">-      {</span>
<a href="#l13.658"></a><span id="l13.658" class="difflineplus">+      // if !nextDelimiter, then the path is of the form Shared/Users/chrisf (no</span>
<a href="#l13.659"></a><span id="l13.659" class="difflineplus">+      // subfolder)</span>
<a href="#l13.660"></a><span id="l13.660" class="difflineplus">+      if (nextDelimiter) {</span>
<a href="#l13.661"></a><span id="l13.661">         *nextDelimiter = 0;</span>
<a href="#l13.662"></a><span id="l13.662">       }</span>
<a href="#l13.663"></a><span id="l13.663">       rv = PL_strdup(owner);</span>
<a href="#l13.664"></a><span id="l13.664">     }</span>
<a href="#l13.665"></a><span id="l13.665">     PR_Free(convertedFolderName);</span>
<a href="#l13.666"></a><span id="l13.666" class="difflineminus">-  }</span>
<a href="#l13.667"></a><span id="l13.667" class="difflineminus">-  else</span>
<a href="#l13.668"></a><span id="l13.668" class="difflineminus">-  {</span>
<a href="#l13.669"></a><span id="l13.669" class="difflineplus">+  } else {</span>
<a href="#l13.670"></a><span id="l13.670">     NS_ASSERTION(false, &quot;couldn't allocate server folder name&quot;);</span>
<a href="#l13.671"></a><span id="l13.671">   }</span>
<a href="#l13.672"></a><span id="l13.672"> </span>
<a href="#l13.673"></a><span id="l13.673">   return rv;</span>
<a href="#l13.674"></a><span id="l13.674"> }</span>
<a href="#l13.675"></a><span id="l13.675"> </span>
<a href="#l13.676"></a><span id="l13.676"> /*</span>
<a href="#l13.677"></a><span id="l13.677"> GetFolderIsNamespace returns TRUE if the given folder is the folder representing</span>
<a href="#l13.678"></a><span id="l13.678"> a namespace.</span>
<a href="#l13.679"></a><span id="l13.679"> */</span>
<a href="#l13.680"></a><span id="l13.680"> </span>
<a href="#l13.681"></a><span id="l13.681" class="difflineminus">-bool nsIMAPNamespaceList::GetFolderIsNamespace(const char *hostName,</span>
<a href="#l13.682"></a><span id="l13.682" class="difflineminus">-                                                 const char *canonicalFolderName,</span>
<a href="#l13.683"></a><span id="l13.683" class="difflineminus">-                                                 char delimiter,nsIMAPNamespace *namespaceForFolder)</span>
<a href="#l13.684"></a><span id="l13.684" class="difflineminus">-{</span>
<a href="#l13.685"></a><span id="l13.685" class="difflineplus">+bool nsIMAPNamespaceList::GetFolderIsNamespace(</span>
<a href="#l13.686"></a><span id="l13.686" class="difflineplus">+    const char *hostName, const char *canonicalFolderName, char delimiter,</span>
<a href="#l13.687"></a><span id="l13.687" class="difflineplus">+    nsIMAPNamespace *namespaceForFolder) {</span>
<a href="#l13.688"></a><span id="l13.688">   NS_ASSERTION(namespaceForFolder, &quot;null namespace&quot;);</span>
<a href="#l13.689"></a><span id="l13.689"> </span>
<a href="#l13.690"></a><span id="l13.690">   bool rv = false;</span>
<a href="#l13.691"></a><span id="l13.691"> </span>
<a href="#l13.692"></a><span id="l13.692">   const char *prefix = namespaceForFolder-&gt;GetPrefix();</span>
<a href="#l13.693"></a><span id="l13.693">   NS_ASSERTION(prefix, &quot;namespace has no prefix&quot;);</span>
<a href="#l13.694"></a><span id="l13.694">   if (!prefix || !*prefix)  // empty namespace prefix</span>
<a href="#l13.695"></a><span id="l13.695">     return false;</span>
<a href="#l13.696"></a><span id="l13.696"> </span>
<a href="#l13.697"></a><span id="l13.697" class="difflineminus">-  char *convertedFolderName = AllocateServerFolderName(canonicalFolderName, delimiter);</span>
<a href="#l13.698"></a><span id="l13.698" class="difflineminus">-  if (convertedFolderName)</span>
<a href="#l13.699"></a><span id="l13.699" class="difflineminus">-  {</span>
<a href="#l13.700"></a><span id="l13.700" class="difflineplus">+  char *convertedFolderName =</span>
<a href="#l13.701"></a><span id="l13.701" class="difflineplus">+      AllocateServerFolderName(canonicalFolderName, delimiter);</span>
<a href="#l13.702"></a><span id="l13.702" class="difflineplus">+  if (convertedFolderName) {</span>
<a href="#l13.703"></a><span id="l13.703">     bool lastCharIsDelimiter = (prefix[strlen(prefix) - 1] == delimiter);</span>
<a href="#l13.704"></a><span id="l13.704"> </span>
<a href="#l13.705"></a><span id="l13.705" class="difflineminus">-    if (lastCharIsDelimiter)</span>
<a href="#l13.706"></a><span id="l13.706" class="difflineminus">-    {</span>
<a href="#l13.707"></a><span id="l13.707" class="difflineminus">-      rv = ((strncmp(convertedFolderName, prefix, strlen(convertedFolderName)) == 0) &amp;&amp;</span>
<a href="#l13.708"></a><span id="l13.708" class="difflineminus">-        (strlen(convertedFolderName) == strlen(prefix) - 1));</span>
<a href="#l13.709"></a><span id="l13.709" class="difflineminus">-    }</span>
<a href="#l13.710"></a><span id="l13.710" class="difflineminus">-    else</span>
<a href="#l13.711"></a><span id="l13.711" class="difflineminus">-    {</span>
<a href="#l13.712"></a><span id="l13.712" class="difflineplus">+    if (lastCharIsDelimiter) {</span>
<a href="#l13.713"></a><span id="l13.713" class="difflineplus">+      rv = ((strncmp(convertedFolderName, prefix,</span>
<a href="#l13.714"></a><span id="l13.714" class="difflineplus">+                     strlen(convertedFolderName)) == 0) &amp;&amp;</span>
<a href="#l13.715"></a><span id="l13.715" class="difflineplus">+            (strlen(convertedFolderName) == strlen(prefix) - 1));</span>
<a href="#l13.716"></a><span id="l13.716" class="difflineplus">+    } else {</span>
<a href="#l13.717"></a><span id="l13.717">       rv = (strcmp(convertedFolderName, prefix) == 0);</span>
<a href="#l13.718"></a><span id="l13.718">     }</span>
<a href="#l13.719"></a><span id="l13.719"> </span>
<a href="#l13.720"></a><span id="l13.720">     PR_Free(convertedFolderName);</span>
<a href="#l13.721"></a><span id="l13.721" class="difflineminus">-  }</span>
<a href="#l13.722"></a><span id="l13.722" class="difflineminus">-  else</span>
<a href="#l13.723"></a><span id="l13.723" class="difflineminus">-  {</span>
<a href="#l13.724"></a><span id="l13.724" class="difflineplus">+  } else {</span>
<a href="#l13.725"></a><span id="l13.725">     NS_ASSERTION(false, &quot;couldn't allocate server folder name&quot;);</span>
<a href="#l13.726"></a><span id="l13.726">   }</span>
<a href="#l13.727"></a><span id="l13.727"> </span>
<a href="#l13.728"></a><span id="l13.728">   return rv;</span>
<a href="#l13.729"></a><span id="l13.729"> }</span>
<a href="#l13.730"></a><span id="l13.730"> </span>
<a href="#l13.731"></a><span id="l13.731"> /*</span>
<a href="#l13.732"></a><span id="l13.732">   SuggestHierarchySeparatorForNamespace takes a namespace from libmsg</span>
<a href="#l13.733"></a><span id="l13.733">   and a hierarchy delimiter.  If the namespace has not been filled in from</span>
<a href="#l13.734"></a><span id="l13.734">   online NAMESPACE command yet, it fills in the suggested delimiter to be</span>
<a href="#l13.735"></a><span id="l13.735">   used from then on (until it is overridden by an online response).</span>
<a href="#l13.736"></a><span id="l13.736"> */</span>
<a href="#l13.737"></a><span id="l13.737"> </span>
<a href="#l13.738"></a><span id="l13.738" class="difflineminus">-void nsIMAPNamespaceList::SuggestHierarchySeparatorForNamespace(nsIMAPNamespace *namespaceForFolder, char delimiterFromFolder)</span>
<a href="#l13.739"></a><span id="l13.739" class="difflineminus">-{</span>
<a href="#l13.740"></a><span id="l13.740" class="difflineplus">+void nsIMAPNamespaceList::SuggestHierarchySeparatorForNamespace(</span>
<a href="#l13.741"></a><span id="l13.741" class="difflineplus">+    nsIMAPNamespace *namespaceForFolder, char delimiterFromFolder) {</span>
<a href="#l13.742"></a><span id="l13.742">   NS_ASSERTION(namespaceForFolder, &quot;need namespace&quot;);</span>
<a href="#l13.743"></a><span id="l13.743">   if (namespaceForFolder &amp;&amp; !namespaceForFolder-&gt;GetIsDelimiterFilledIn())</span>
<a href="#l13.744"></a><span id="l13.744">     namespaceForFolder-&gt;SetDelimiter(delimiterFromFolder, false);</span>
<a href="#l13.745"></a><span id="l13.745"> }</span>
<a href="#l13.746"></a><span id="l13.746"> </span>
<a href="#l13.747"></a><span id="l13.747" class="difflineminus">-</span>
<a href="#l13.748"></a><span id="l13.748"> /*</span>
<a href="#l13.749"></a><span id="l13.749" class="difflineminus">- GenerateFullFolderNameWithDefaultNamespace takes a folder name in canonical form,</span>
<a href="#l13.750"></a><span id="l13.750" class="difflineminus">-  converts it to online form, allocates a string to contain the full online server name</span>
<a href="#l13.751"></a><span id="l13.751" class="difflineminus">-  including the namespace prefix of the default namespace of the given type, in the form:</span>
<a href="#l13.752"></a><span id="l13.752" class="difflineminus">-  PR_smprintf(&quot;%s%s&quot;, prefix, onlineServerName) if there is a NULL owner</span>
<a href="#l13.753"></a><span id="l13.753" class="difflineminus">-  PR_smprintf(&quot;%s%s%c%s&quot;, prefix, owner, delimiter, onlineServerName) if there is an owner</span>
<a href="#l13.754"></a><span id="l13.754" class="difflineminus">-  It then converts this back to canonical form and returns it (allocated) to libmsg.</span>
<a href="#l13.755"></a><span id="l13.755" class="difflineminus">-  It returns NULL if there is no namespace of the given type.</span>
<a href="#l13.756"></a><span id="l13.756" class="difflineminus">-  If nsUsed is not passed in as NULL, then *nsUsed is filled in and returned;  it is the</span>
<a href="#l13.757"></a><span id="l13.757" class="difflineminus">-  namespace used for generating the folder name.</span>
<a href="#l13.758"></a><span id="l13.758" class="difflineplus">+ GenerateFullFolderNameWithDefaultNamespace takes a folder name in canonical</span>
<a href="#l13.759"></a><span id="l13.759" class="difflineplus">+ form, converts it to online form, allocates a string to contain the full online</span>
<a href="#l13.760"></a><span id="l13.760" class="difflineplus">+ server name including the namespace prefix of the default namespace of the</span>
<a href="#l13.761"></a><span id="l13.761" class="difflineplus">+ given type, in the form: PR_smprintf(&quot;%s%s&quot;, prefix, onlineServerName) if there</span>
<a href="#l13.762"></a><span id="l13.762" class="difflineplus">+ is a NULL owner PR_smprintf(&quot;%s%s%c%s&quot;, prefix, owner, delimiter,</span>
<a href="#l13.763"></a><span id="l13.763" class="difflineplus">+ onlineServerName) if there is an owner It then converts this back to canonical</span>
<a href="#l13.764"></a><span id="l13.764" class="difflineplus">+ form and returns it (allocated) to libmsg. It returns NULL if there is no</span>
<a href="#l13.765"></a><span id="l13.765" class="difflineplus">+ namespace of the given type. If nsUsed is not passed in as NULL, then *nsUsed</span>
<a href="#l13.766"></a><span id="l13.766" class="difflineplus">+ is filled in and returned;  it is the namespace used for generating the folder</span>
<a href="#l13.767"></a><span id="l13.767" class="difflineplus">+ name.</span>
<a href="#l13.768"></a><span id="l13.768"> */</span>
<a href="#l13.769"></a><span id="l13.769" class="difflineminus">-char *nsIMAPNamespaceList::GenerateFullFolderNameWithDefaultNamespace(const char *hostName,</span>
<a href="#l13.770"></a><span id="l13.770" class="difflineminus">-                                                                      const char *canonicalFolderName,</span>
<a href="#l13.771"></a><span id="l13.771" class="difflineminus">-                                                                      const char *owner,</span>
<a href="#l13.772"></a><span id="l13.772" class="difflineminus">-                                                                      EIMAPNamespaceType nsType,</span>
<a href="#l13.773"></a><span id="l13.773" class="difflineminus">-                                                                      nsIMAPNamespace **nsUsed)</span>
<a href="#l13.774"></a><span id="l13.774" class="difflineminus">-{</span>
<a href="#l13.775"></a><span id="l13.775" class="difflineplus">+char *nsIMAPNamespaceList::GenerateFullFolderNameWithDefaultNamespace(</span>
<a href="#l13.776"></a><span id="l13.776" class="difflineplus">+    const char *hostName, const char *canonicalFolderName, const char *owner,</span>
<a href="#l13.777"></a><span id="l13.777" class="difflineplus">+    EIMAPNamespaceType nsType, nsIMAPNamespace **nsUsed) {</span>
<a href="#l13.778"></a><span id="l13.778">   nsresult rv = NS_OK;</span>
<a href="#l13.779"></a><span id="l13.779"> </span>
<a href="#l13.780"></a><span id="l13.780">   nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession =</span>
<a href="#l13.781"></a><span id="l13.781" class="difflineminus">-           do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l13.782"></a><span id="l13.782" class="difflineplus">+      do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l13.783"></a><span id="l13.783">   NS_ENSURE_SUCCESS(rv, nullptr);</span>
<a href="#l13.784"></a><span id="l13.784">   nsIMAPNamespace *ns;</span>
<a href="#l13.785"></a><span id="l13.785">   char *fullFolderName = nullptr;</span>
<a href="#l13.786"></a><span id="l13.786">   rv = hostSession-&gt;GetDefaultNamespaceOfTypeForHost(hostName, nsType, ns);</span>
<a href="#l13.787"></a><span id="l13.787">   NS_ENSURE_SUCCESS(rv, nullptr);</span>
<a href="#l13.788"></a><span id="l13.788" class="difflineminus">-  if (ns)</span>
<a href="#l13.789"></a><span id="l13.789" class="difflineminus">-  {</span>
<a href="#l13.790"></a><span id="l13.790" class="difflineminus">-    if (nsUsed)</span>
<a href="#l13.791"></a><span id="l13.791" class="difflineminus">-      *nsUsed = ns;</span>
<a href="#l13.792"></a><span id="l13.792" class="difflineplus">+  if (ns) {</span>
<a href="#l13.793"></a><span id="l13.793" class="difflineplus">+    if (nsUsed) *nsUsed = ns;</span>
<a href="#l13.794"></a><span id="l13.794">     const char *prefix = ns-&gt;GetPrefix();</span>
<a href="#l13.795"></a><span id="l13.795" class="difflineminus">-    char *convertedFolderName = AllocateServerFolderName(canonicalFolderName, ns-&gt;GetDelimiter());</span>
<a href="#l13.796"></a><span id="l13.796" class="difflineminus">-    if (convertedFolderName)</span>
<a href="#l13.797"></a><span id="l13.797" class="difflineminus">-    {</span>
<a href="#l13.798"></a><span id="l13.798" class="difflineplus">+    char *convertedFolderName =</span>
<a href="#l13.799"></a><span id="l13.799" class="difflineplus">+        AllocateServerFolderName(canonicalFolderName, ns-&gt;GetDelimiter());</span>
<a href="#l13.800"></a><span id="l13.800" class="difflineplus">+    if (convertedFolderName) {</span>
<a href="#l13.801"></a><span id="l13.801">       char *convertedReturnName = nullptr;</span>
<a href="#l13.802"></a><span id="l13.802" class="difflineminus">-      if (owner)</span>
<a href="#l13.803"></a><span id="l13.803" class="difflineminus">-      {</span>
<a href="#l13.804"></a><span id="l13.804" class="difflineminus">-        convertedReturnName = PR_smprintf(&quot;%s%s%c%s&quot;, prefix, owner, ns-&gt;GetDelimiter(), convertedFolderName);</span>
<a href="#l13.805"></a><span id="l13.805" class="difflineminus">-      }</span>
<a href="#l13.806"></a><span id="l13.806" class="difflineminus">-      else</span>
<a href="#l13.807"></a><span id="l13.807" class="difflineminus">-      {</span>
<a href="#l13.808"></a><span id="l13.808" class="difflineplus">+      if (owner) {</span>
<a href="#l13.809"></a><span id="l13.809" class="difflineplus">+        convertedReturnName = PR_smprintf(</span>
<a href="#l13.810"></a><span id="l13.810" class="difflineplus">+            &quot;%s%s%c%s&quot;, prefix, owner, ns-&gt;GetDelimiter(), convertedFolderName);</span>
<a href="#l13.811"></a><span id="l13.811" class="difflineplus">+      } else {</span>
<a href="#l13.812"></a><span id="l13.812">         convertedReturnName = PR_smprintf(&quot;%s%s&quot;, prefix, convertedFolderName);</span>
<a href="#l13.813"></a><span id="l13.813">       }</span>
<a href="#l13.814"></a><span id="l13.814"> </span>
<a href="#l13.815"></a><span id="l13.815" class="difflineminus">-      if (convertedReturnName)</span>
<a href="#l13.816"></a><span id="l13.816" class="difflineminus">-      {</span>
<a href="#l13.817"></a><span id="l13.817" class="difflineminus">-        fullFolderName = AllocateCanonicalFolderName(convertedReturnName, ns-&gt;GetDelimiter());</span>
<a href="#l13.818"></a><span id="l13.818" class="difflineplus">+      if (convertedReturnName) {</span>
<a href="#l13.819"></a><span id="l13.819" class="difflineplus">+        fullFolderName = AllocateCanonicalFolderName(convertedReturnName,</span>
<a href="#l13.820"></a><span id="l13.820" class="difflineplus">+                                                     ns-&gt;GetDelimiter());</span>
<a href="#l13.821"></a><span id="l13.821">         PR_Free(convertedReturnName);</span>
<a href="#l13.822"></a><span id="l13.822">       }</span>
<a href="#l13.823"></a><span id="l13.823">       PR_Free(convertedFolderName);</span>
<a href="#l13.824"></a><span id="l13.824" class="difflineminus">-    }</span>
<a href="#l13.825"></a><span id="l13.825" class="difflineminus">-    else</span>
<a href="#l13.826"></a><span id="l13.826" class="difflineminus">-    {</span>
<a href="#l13.827"></a><span id="l13.827" class="difflineplus">+    } else {</span>
<a href="#l13.828"></a><span id="l13.828">       NS_ASSERTION(false, &quot;couldn't allocate server folder name&quot;);</span>
<a href="#l13.829"></a><span id="l13.829">     }</span>
<a href="#l13.830"></a><span id="l13.830" class="difflineminus">-  }</span>
<a href="#l13.831"></a><span id="l13.831" class="difflineminus">-  else</span>
<a href="#l13.832"></a><span id="l13.832" class="difflineminus">-  {</span>
<a href="#l13.833"></a><span id="l13.833" class="difflineplus">+  } else {</span>
<a href="#l13.834"></a><span id="l13.834">     // Could not find other users namespace on the given host</span>
<a href="#l13.835"></a><span id="l13.835">     NS_WARNING(&quot;couldn't find namespace for given host&quot;);</span>
<a href="#l13.836"></a><span id="l13.836">   }</span>
<a href="#l13.837"></a><span id="l13.837">   return (fullFolderName);</span>
<a href="#l13.838"></a><span id="l13.838"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPNamespace.h</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPNamespace.h</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -4,83 +4,86 @@</span>
<a href="#l14.4"></a><span id="l14.4">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l14.5"></a><span id="l14.5"> </span>
<a href="#l14.6"></a><span id="l14.6"> #ifndef _nsIMAPNamespace_H_</span>
<a href="#l14.7"></a><span id="l14.7"> #define _nsIMAPNamespace_H_</span>
<a href="#l14.8"></a><span id="l14.8"> </span>
<a href="#l14.9"></a><span id="l14.9"> #include &quot;nsImapCore.h&quot;</span>
<a href="#l14.10"></a><span id="l14.10"> #include &quot;nsTArray.h&quot;</span>
<a href="#l14.11"></a><span id="l14.11"> </span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">-class nsIMAPNamespace</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineminus">-{</span>
<a href="#l14.14"></a><span id="l14.14" class="difflineminus">-</span>
<a href="#l14.15"></a><span id="l14.15" class="difflineminus">-public:</span>
<a href="#l14.16"></a><span id="l14.16" class="difflineminus">-  nsIMAPNamespace(EIMAPNamespaceType type, const char *prefix, char delimiter, bool from_prefs);</span>
<a href="#l14.17"></a><span id="l14.17" class="difflineplus">+class nsIMAPNamespace {</span>
<a href="#l14.18"></a><span id="l14.18" class="difflineplus">+ public:</span>
<a href="#l14.19"></a><span id="l14.19" class="difflineplus">+  nsIMAPNamespace(EIMAPNamespaceType type, const char *prefix, char delimiter,</span>
<a href="#l14.20"></a><span id="l14.20" class="difflineplus">+                  bool from_prefs);</span>
<a href="#l14.21"></a><span id="l14.21"> </span>
<a href="#l14.22"></a><span id="l14.22">   ~nsIMAPNamespace();</span>
<a href="#l14.23"></a><span id="l14.23"> </span>
<a href="#l14.24"></a><span id="l14.24">   EIMAPNamespaceType GetType() { return m_namespaceType; }</span>
<a href="#l14.25"></a><span id="l14.25" class="difflineminus">-  const char *       GetPrefix() { return m_prefix; }</span>
<a href="#l14.26"></a><span id="l14.26" class="difflineminus">-  char               GetDelimiter() { return m_delimiter; }</span>
<a href="#l14.27"></a><span id="l14.27" class="difflineminus">-  void               SetDelimiter(char delimiter, bool delimiterFilledIn);</span>
<a href="#l14.28"></a><span id="l14.28" class="difflineminus">-  bool               GetIsDelimiterFilledIn() { return m_delimiterFilledIn; }</span>
<a href="#l14.29"></a><span id="l14.29" class="difflineminus">-  bool               GetIsNamespaceFromPrefs() { return m_fromPrefs; }</span>
<a href="#l14.30"></a><span id="l14.30" class="difflineplus">+  const char *GetPrefix() { return m_prefix; }</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineplus">+  char GetDelimiter() { return m_delimiter; }</span>
<a href="#l14.32"></a><span id="l14.32" class="difflineplus">+  void SetDelimiter(char delimiter, bool delimiterFilledIn);</span>
<a href="#l14.33"></a><span id="l14.33" class="difflineplus">+  bool GetIsDelimiterFilledIn() { return m_delimiterFilledIn; }</span>
<a href="#l14.34"></a><span id="l14.34" class="difflineplus">+  bool GetIsNamespaceFromPrefs() { return m_fromPrefs; }</span>
<a href="#l14.35"></a><span id="l14.35"> </span>
<a href="#l14.36"></a><span id="l14.36">   // returns -1 if this box is not part of this namespace,</span>
<a href="#l14.37"></a><span id="l14.37">   // or the length of the prefix if it is part of this namespace</span>
<a href="#l14.38"></a><span id="l14.38" class="difflineminus">-  int                MailboxMatchesNamespace(const char *boxname);</span>
<a href="#l14.39"></a><span id="l14.39" class="difflineplus">+  int MailboxMatchesNamespace(const char *boxname);</span>
<a href="#l14.40"></a><span id="l14.40"> </span>
<a href="#l14.41"></a><span id="l14.41" class="difflineminus">-protected:</span>
<a href="#l14.42"></a><span id="l14.42" class="difflineplus">+ protected:</span>
<a href="#l14.43"></a><span id="l14.43">   EIMAPNamespaceType m_namespaceType;</span>
<a href="#l14.44"></a><span id="l14.44">   char *m_prefix;</span>
<a href="#l14.45"></a><span id="l14.45">   char m_delimiter;</span>
<a href="#l14.46"></a><span id="l14.46">   bool m_fromPrefs;</span>
<a href="#l14.47"></a><span id="l14.47">   bool m_delimiterFilledIn;</span>
<a href="#l14.48"></a><span id="l14.48" class="difflineminus">-</span>
<a href="#l14.49"></a><span id="l14.49"> };</span>
<a href="#l14.50"></a><span id="l14.50"> </span>
<a href="#l14.51"></a><span id="l14.51" class="difflineminus">-</span>
<a href="#l14.52"></a><span id="l14.52"> // represents an array of namespaces for a given host</span>
<a href="#l14.53"></a><span id="l14.53" class="difflineminus">-class nsIMAPNamespaceList</span>
<a href="#l14.54"></a><span id="l14.54" class="difflineminus">-{</span>
<a href="#l14.55"></a><span id="l14.55" class="difflineminus">-public:</span>
<a href="#l14.56"></a><span id="l14.56" class="difflineplus">+class nsIMAPNamespaceList {</span>
<a href="#l14.57"></a><span id="l14.57" class="difflineplus">+ public:</span>
<a href="#l14.58"></a><span id="l14.58">   ~nsIMAPNamespaceList();</span>
<a href="#l14.59"></a><span id="l14.59"> </span>
<a href="#l14.60"></a><span id="l14.60">   static nsIMAPNamespaceList *CreatensIMAPNamespaceList();</span>
<a href="#l14.61"></a><span id="l14.61"> </span>
<a href="#l14.62"></a><span id="l14.62" class="difflineminus">-  nsresult InitFromString(const char *nameSpaceString, EIMAPNamespaceType nstype);</span>
<a href="#l14.63"></a><span id="l14.63" class="difflineplus">+  nsresult InitFromString(const char *nameSpaceString,</span>
<a href="#l14.64"></a><span id="l14.64" class="difflineplus">+                          EIMAPNamespaceType nstype);</span>
<a href="#l14.65"></a><span id="l14.65">   nsresult OutputToString(nsCString &amp;OutputString);</span>
<a href="#l14.66"></a><span id="l14.66">   int UnserializeNamespaces(const char *str, char **prefixes, int len);</span>
<a href="#l14.67"></a><span id="l14.67" class="difflineminus">-  nsresult SerializeNamespaces(char **prefixes, int len, nsCString &amp;serializedNamespace);</span>
<a href="#l14.68"></a><span id="l14.68" class="difflineplus">+  nsresult SerializeNamespaces(char **prefixes, int len,</span>
<a href="#l14.69"></a><span id="l14.69" class="difflineplus">+                               nsCString &amp;serializedNamespace);</span>
<a href="#l14.70"></a><span id="l14.70"> </span>
<a href="#l14.71"></a><span id="l14.71" class="difflineminus">-  void ClearNamespaces(bool deleteFromPrefsNamespaces, bool deleteServerAdvertisedNamespaces, bool reallyDelete);</span>
<a href="#l14.72"></a><span id="l14.72" class="difflineplus">+  void ClearNamespaces(bool deleteFromPrefsNamespaces,</span>
<a href="#l14.73"></a><span id="l14.73" class="difflineplus">+                       bool deleteServerAdvertisedNamespaces,</span>
<a href="#l14.74"></a><span id="l14.74" class="difflineplus">+                       bool reallyDelete);</span>
<a href="#l14.75"></a><span id="l14.75">   int GetNumberOfNamespaces();</span>
<a href="#l14.76"></a><span id="l14.76">   int GetNumberOfNamespaces(EIMAPNamespaceType);</span>
<a href="#l14.77"></a><span id="l14.77">   nsIMAPNamespace *GetNamespaceNumber(int nodeIndex);</span>
<a href="#l14.78"></a><span id="l14.78">   nsIMAPNamespace *GetNamespaceNumber(int nodeIndex, EIMAPNamespaceType);</span>
<a href="#l14.79"></a><span id="l14.79"> </span>
<a href="#l14.80"></a><span id="l14.80">   nsIMAPNamespace *GetDefaultNamespaceOfType(EIMAPNamespaceType type);</span>
<a href="#l14.81"></a><span id="l14.81">   int AddNewNamespace(nsIMAPNamespace *ns);</span>
<a href="#l14.82"></a><span id="l14.82">   nsIMAPNamespace *GetNamespaceForMailbox(const char *boxname);</span>
<a href="#l14.83"></a><span id="l14.83" class="difflineminus">-  static nsIMAPNamespace* GetNamespaceForFolder(const char *hostName,</span>
<a href="#l14.84"></a><span id="l14.84" class="difflineplus">+  static nsIMAPNamespace *GetNamespaceForFolder(const char *hostName,</span>
<a href="#l14.85"></a><span id="l14.85">                                                 const char *canonicalFolderName,</span>
<a href="#l14.86"></a><span id="l14.86">                                                 char delimiter);</span>
<a href="#l14.87"></a><span id="l14.87">   static bool GetFolderIsNamespace(const char *hostName,</span>
<a href="#l14.88"></a><span id="l14.88">                                    const char *canonicalFolderName,</span>
<a href="#l14.89"></a><span id="l14.89" class="difflineminus">-                                   char delimiter,nsIMAPNamespace *namespaceForFolder);</span>
<a href="#l14.90"></a><span id="l14.90" class="difflineminus">-  static char* GetFolderNameWithoutNamespace(nsIMAPNamespace *namespaceForFolder, const char *canonicalFolderName);</span>
<a href="#l14.91"></a><span id="l14.91" class="difflineminus">-  static char *AllocateServerFolderName(const char *canonicalFolderName, char delimiter);</span>
<a href="#l14.92"></a><span id="l14.92" class="difflineminus">-  static char *GetFolderOwnerNameFromPath(nsIMAPNamespace *namespaceForFolder, const char *canonicalFolderName);</span>
<a href="#l14.93"></a><span id="l14.93" class="difflineminus">-  static char *AllocateCanonicalFolderName(const char *onlineFolderName, char delimiter);</span>
<a href="#l14.94"></a><span id="l14.94" class="difflineminus">-  static void  SuggestHierarchySeparatorForNamespace(nsIMAPNamespace *namespaceForFolder, char delimiterFromFolder);</span>
<a href="#l14.95"></a><span id="l14.95" class="difflineminus">-  static char *GenerateFullFolderNameWithDefaultNamespace(const char *hostName,</span>
<a href="#l14.96"></a><span id="l14.96" class="difflineminus">-                                                          const char *canonicalFolderName,</span>
<a href="#l14.97"></a><span id="l14.97" class="difflineminus">-                                                          const char *owner,</span>
<a href="#l14.98"></a><span id="l14.98" class="difflineminus">-                                                          EIMAPNamespaceType nsType,</span>
<a href="#l14.99"></a><span id="l14.99" class="difflineminus">-                                                          nsIMAPNamespace **nsUsed);</span>
<a href="#l14.100"></a><span id="l14.100" class="difflineplus">+                                   char delimiter,</span>
<a href="#l14.101"></a><span id="l14.101" class="difflineplus">+                                   nsIMAPNamespace *namespaceForFolder);</span>
<a href="#l14.102"></a><span id="l14.102" class="difflineplus">+  static char *GetFolderNameWithoutNamespace(</span>
<a href="#l14.103"></a><span id="l14.103" class="difflineplus">+      nsIMAPNamespace *namespaceForFolder, const char *canonicalFolderName);</span>
<a href="#l14.104"></a><span id="l14.104" class="difflineplus">+  static char *AllocateServerFolderName(const char *canonicalFolderName,</span>
<a href="#l14.105"></a><span id="l14.105" class="difflineplus">+                                        char delimiter);</span>
<a href="#l14.106"></a><span id="l14.106" class="difflineplus">+  static char *GetFolderOwnerNameFromPath(nsIMAPNamespace *namespaceForFolder,</span>
<a href="#l14.107"></a><span id="l14.107" class="difflineplus">+                                          const char *canonicalFolderName);</span>
<a href="#l14.108"></a><span id="l14.108" class="difflineplus">+  static char *AllocateCanonicalFolderName(const char *onlineFolderName,</span>
<a href="#l14.109"></a><span id="l14.109" class="difflineplus">+                                           char delimiter);</span>
<a href="#l14.110"></a><span id="l14.110" class="difflineplus">+  static void SuggestHierarchySeparatorForNamespace(</span>
<a href="#l14.111"></a><span id="l14.111" class="difflineplus">+      nsIMAPNamespace *namespaceForFolder, char delimiterFromFolder);</span>
<a href="#l14.112"></a><span id="l14.112" class="difflineplus">+  static char *GenerateFullFolderNameWithDefaultNamespace(</span>
<a href="#l14.113"></a><span id="l14.113" class="difflineplus">+      const char *hostName, const char *canonicalFolderName, const char *owner,</span>
<a href="#l14.114"></a><span id="l14.114" class="difflineplus">+      EIMAPNamespaceType nsType, nsIMAPNamespace **nsUsed);</span>
<a href="#l14.115"></a><span id="l14.115"> </span>
<a href="#l14.116"></a><span id="l14.116" class="difflineminus">-protected:</span>
<a href="#l14.117"></a><span id="l14.117" class="difflineplus">+ protected:</span>
<a href="#l14.118"></a><span id="l14.118">   nsIMAPNamespaceList();  // use CreatensIMAPNamespaceList to create one</span>
<a href="#l14.119"></a><span id="l14.119"> </span>
<a href="#l14.120"></a><span id="l14.120" class="difflineminus">-  nsTArray&lt;nsIMAPNamespace*&gt; m_NamespaceList;</span>
<a href="#l14.121"></a><span id="l14.121" class="difflineminus">-</span>
<a href="#l14.122"></a><span id="l14.122" class="difflineplus">+  nsTArray&lt;nsIMAPNamespace *&gt; m_NamespaceList;</span>
<a href="#l14.123"></a><span id="l14.123"> };</span>
<a href="#l14.124"></a><span id="l14.124"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/mailnews/imap/src/nsImapCore.h</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapCore.h</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -1,13 +1,14 @@</span>
<a href="#l15.4"></a><span id="l15.4"> /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l15.5"></a><span id="l15.5"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l15.6"></a><span id="l15.6">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l15.7"></a><span id="l15.7">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l15.8"></a><span id="l15.8"> </span>
<a href="#l15.9"></a><span id="l15.9" class="difflineplus">+// clang-format off</span>
<a href="#l15.10"></a><span id="l15.10"> #ifndef _nsImapCore_H_</span>
<a href="#l15.11"></a><span id="l15.11"> #define _nsImapCore_H_</span>
<a href="#l15.12"></a><span id="l15.12"> </span>
<a href="#l15.13"></a><span id="l15.13"> #include &quot;MailNewsTypes.h&quot;</span>
<a href="#l15.14"></a><span id="l15.14"> #include &quot;nsString.h&quot;</span>
<a href="#l15.15"></a><span id="l15.15"> </span>
<a href="#l15.16"></a><span id="l15.16"> /* imap message flags */</span>
<a href="#l15.17"></a><span id="l15.17"> typedef uint16_t imapMessageFlagsType;</span>
<a href="#l15.18"></a><span id="l15.18" class="difflineat">@@ -175,8 +176,9 @@ typedef enum {</span>
<a href="#l15.19"></a><span id="l15.19">   eContinue,</span>
<a href="#l15.20"></a><span id="l15.20">   eContinueNew,</span>
<a href="#l15.21"></a><span id="l15.21">   eListMyChildren,</span>
<a href="#l15.22"></a><span id="l15.22">   eNewServerDirectory,</span>
<a href="#l15.23"></a><span id="l15.23">   eCancelled</span>
<a href="#l15.24"></a><span id="l15.24"> } EMailboxDiscoverStatus;</span>
<a href="#l15.25"></a><span id="l15.25"> </span>
<a href="#l15.26"></a><span id="l15.26"> #endif</span>
<a href="#l15.27"></a><span id="l15.27" class="difflineplus">+// clang-format on</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/mailnews/imap/src/nsImapFlagAndUidState.cpp</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapFlagAndUidState.cpp</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -10,345 +10,308 @@</span>
<a href="#l16.4"></a><span id="l16.4"> #include &quot;nsMsgUtils.h&quot;</span>
<a href="#l16.5"></a><span id="l16.5"> #include &quot;prcmon.h&quot;</span>
<a href="#l16.6"></a><span id="l16.6"> #include &quot;nspr.h&quot;</span>
<a href="#l16.7"></a><span id="l16.7"> </span>
<a href="#l16.8"></a><span id="l16.8"> NS_IMPL_ISUPPORTS(nsImapFlagAndUidState, nsIImapFlagAndUidState)</span>
<a href="#l16.9"></a><span id="l16.9"> </span>
<a href="#l16.10"></a><span id="l16.10"> using namespace mozilla;</span>
<a href="#l16.11"></a><span id="l16.11"> </span>
<a href="#l16.12"></a><span id="l16.12" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::GetNumberOfMessages(int32_t *result)</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineminus">-{</span>
<a href="#l16.14"></a><span id="l16.14" class="difflineminus">-  if (!result)</span>
<a href="#l16.15"></a><span id="l16.15" class="difflineminus">-    return NS_ERROR_NULL_POINTER;</span>
<a href="#l16.16"></a><span id="l16.16" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::GetNumberOfMessages(int32_t *result) {</span>
<a href="#l16.17"></a><span id="l16.17" class="difflineplus">+  if (!result) return NS_ERROR_NULL_POINTER;</span>
<a href="#l16.18"></a><span id="l16.18">   *result = fUids.Length();</span>
<a href="#l16.19"></a><span id="l16.19">   return NS_OK;</span>
<a href="#l16.20"></a><span id="l16.20"> }</span>
<a href="#l16.21"></a><span id="l16.21"> </span>
<a href="#l16.22"></a><span id="l16.22" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::GetUidOfMessage(int32_t zeroBasedIndex, uint32_t *aResult)</span>
<a href="#l16.23"></a><span id="l16.23" class="difflineminus">-{</span>
<a href="#l16.24"></a><span id="l16.24" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::GetUidOfMessage(int32_t zeroBasedIndex,</span>
<a href="#l16.25"></a><span id="l16.25" class="difflineplus">+                                                     uint32_t *aResult) {</span>
<a href="#l16.26"></a><span id="l16.26">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l16.27"></a><span id="l16.27"> </span>
<a href="#l16.28"></a><span id="l16.28">   PR_CEnterMonitor(this);</span>
<a href="#l16.29"></a><span id="l16.29">   *aResult = fUids.SafeElementAt(zeroBasedIndex, nsMsgKey_None);</span>
<a href="#l16.30"></a><span id="l16.30">   PR_CExitMonitor(this);</span>
<a href="#l16.31"></a><span id="l16.31">   return NS_OK;</span>
<a href="#l16.32"></a><span id="l16.32"> }</span>
<a href="#l16.33"></a><span id="l16.33"> </span>
<a href="#l16.34"></a><span id="l16.34" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::GetMessageFlags(int32_t zeroBasedIndex, uint16_t *aResult)</span>
<a href="#l16.35"></a><span id="l16.35" class="difflineminus">-{</span>
<a href="#l16.36"></a><span id="l16.36" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::GetMessageFlags(int32_t zeroBasedIndex,</span>
<a href="#l16.37"></a><span id="l16.37" class="difflineplus">+                                                     uint16_t *aResult) {</span>
<a href="#l16.38"></a><span id="l16.38">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l16.39"></a><span id="l16.39">   *aResult = fFlags.SafeElementAt(zeroBasedIndex, kNoImapMsgFlag);</span>
<a href="#l16.40"></a><span id="l16.40">   return NS_OK;</span>
<a href="#l16.41"></a><span id="l16.41"> }</span>
<a href="#l16.42"></a><span id="l16.42"> </span>
<a href="#l16.43"></a><span id="l16.43" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::SetMessageFlags(int32_t zeroBasedIndex, unsigned short flags)</span>
<a href="#l16.44"></a><span id="l16.44" class="difflineminus">-{</span>
<a href="#l16.45"></a><span id="l16.45" class="difflineminus">-  if (zeroBasedIndex &lt; (int32_t)fUids.Length())</span>
<a href="#l16.46"></a><span id="l16.46" class="difflineminus">-    fFlags[zeroBasedIndex] = flags;</span>
<a href="#l16.47"></a><span id="l16.47" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::SetMessageFlags(int32_t zeroBasedIndex,</span>
<a href="#l16.48"></a><span id="l16.48" class="difflineplus">+                                                     unsigned short flags) {</span>
<a href="#l16.49"></a><span id="l16.49" class="difflineplus">+  if (zeroBasedIndex &lt; (int32_t)fUids.Length()) fFlags[zeroBasedIndex] = flags;</span>
<a href="#l16.50"></a><span id="l16.50">   return NS_OK;</span>
<a href="#l16.51"></a><span id="l16.51"> }</span>
<a href="#l16.52"></a><span id="l16.52"> </span>
<a href="#l16.53"></a><span id="l16.53" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::GetNumberOfRecentMessages(int32_t *result)</span>
<a href="#l16.54"></a><span id="l16.54" class="difflineminus">-{</span>
<a href="#l16.55"></a><span id="l16.55" class="difflineminus">-  if (!result)</span>
<a href="#l16.56"></a><span id="l16.56" class="difflineminus">-    return NS_ERROR_NULL_POINTER;</span>
<a href="#l16.57"></a><span id="l16.57" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::GetNumberOfRecentMessages(</span>
<a href="#l16.58"></a><span id="l16.58" class="difflineplus">+    int32_t *result) {</span>
<a href="#l16.59"></a><span id="l16.59" class="difflineplus">+  if (!result) return NS_ERROR_NULL_POINTER;</span>
<a href="#l16.60"></a><span id="l16.60"> </span>
<a href="#l16.61"></a><span id="l16.61">   PR_CEnterMonitor(this);</span>
<a href="#l16.62"></a><span id="l16.62">   uint32_t counter = 0;</span>
<a href="#l16.63"></a><span id="l16.63">   int32_t numUnseenMessages = 0;</span>
<a href="#l16.64"></a><span id="l16.64"> </span>
<a href="#l16.65"></a><span id="l16.65" class="difflineminus">-  for (counter = 0; counter &lt; fUids.Length(); counter++)</span>
<a href="#l16.66"></a><span id="l16.66" class="difflineminus">-  {</span>
<a href="#l16.67"></a><span id="l16.67" class="difflineminus">-    if (fFlags[counter] &amp; kImapMsgRecentFlag)</span>
<a href="#l16.68"></a><span id="l16.68" class="difflineminus">-      numUnseenMessages++;</span>
<a href="#l16.69"></a><span id="l16.69" class="difflineplus">+  for (counter = 0; counter &lt; fUids.Length(); counter++) {</span>
<a href="#l16.70"></a><span id="l16.70" class="difflineplus">+    if (fFlags[counter] &amp; kImapMsgRecentFlag) numUnseenMessages++;</span>
<a href="#l16.71"></a><span id="l16.71">   }</span>
<a href="#l16.72"></a><span id="l16.72">   PR_CExitMonitor(this);</span>
<a href="#l16.73"></a><span id="l16.73"> </span>
<a href="#l16.74"></a><span id="l16.74">   *result = numUnseenMessages;</span>
<a href="#l16.75"></a><span id="l16.75"> </span>
<a href="#l16.76"></a><span id="l16.76">   return NS_OK;</span>
<a href="#l16.77"></a><span id="l16.77"> }</span>
<a href="#l16.78"></a><span id="l16.78"> </span>
<a href="#l16.79"></a><span id="l16.79" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::GetPartialUIDFetch(bool *aPartialUIDFetch)</span>
<a href="#l16.80"></a><span id="l16.80" class="difflineminus">-{</span>
<a href="#l16.81"></a><span id="l16.81" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::GetPartialUIDFetch(</span>
<a href="#l16.82"></a><span id="l16.82" class="difflineplus">+    bool *aPartialUIDFetch) {</span>
<a href="#l16.83"></a><span id="l16.83">   NS_ENSURE_ARG_POINTER(aPartialUIDFetch);</span>
<a href="#l16.84"></a><span id="l16.84">   *aPartialUIDFetch = fPartialUIDFetch;</span>
<a href="#l16.85"></a><span id="l16.85">   return NS_OK;</span>
<a href="#l16.86"></a><span id="l16.86"> }</span>
<a href="#l16.87"></a><span id="l16.87"> </span>
<a href="#l16.88"></a><span id="l16.88"> /* amount to expand for imap entry flags when we need more */</span>
<a href="#l16.89"></a><span id="l16.89"> </span>
<a href="#l16.90"></a><span id="l16.90"> nsImapFlagAndUidState::nsImapFlagAndUidState(int32_t numberOfMessages)</span>
<a href="#l16.91"></a><span id="l16.91" class="difflineminus">-  : fUids(numberOfMessages),</span>
<a href="#l16.92"></a><span id="l16.92" class="difflineminus">-    fFlags(numberOfMessages),</span>
<a href="#l16.93"></a><span id="l16.93" class="difflineminus">-    m_customFlagsHash(10),</span>
<a href="#l16.94"></a><span id="l16.94" class="difflineminus">-    m_customAttributesHash(10),</span>
<a href="#l16.95"></a><span id="l16.95" class="difflineminus">-    mLock(&quot;nsImapFlagAndUidState.mLock&quot;)</span>
<a href="#l16.96"></a><span id="l16.96" class="difflineminus">-{</span>
<a href="#l16.97"></a><span id="l16.97" class="difflineplus">+    : fUids(numberOfMessages),</span>
<a href="#l16.98"></a><span id="l16.98" class="difflineplus">+      fFlags(numberOfMessages),</span>
<a href="#l16.99"></a><span id="l16.99" class="difflineplus">+      m_customFlagsHash(10),</span>
<a href="#l16.100"></a><span id="l16.100" class="difflineplus">+      m_customAttributesHash(10),</span>
<a href="#l16.101"></a><span id="l16.101" class="difflineplus">+      mLock(&quot;nsImapFlagAndUidState.mLock&quot;) {</span>
<a href="#l16.102"></a><span id="l16.102">   fSupportedUserFlags = 0;</span>
<a href="#l16.103"></a><span id="l16.103">   fNumberDeleted = 0;</span>
<a href="#l16.104"></a><span id="l16.104">   fPartialUIDFetch = true;</span>
<a href="#l16.105"></a><span id="l16.105">   fStartCapture = false;</span>
<a href="#l16.106"></a><span id="l16.106">   fNumAdded = 0;</span>
<a href="#l16.107"></a><span id="l16.107"> }</span>
<a href="#l16.108"></a><span id="l16.108"> </span>
<a href="#l16.109"></a><span id="l16.109" class="difflineminus">-nsImapFlagAndUidState::~nsImapFlagAndUidState()</span>
<a href="#l16.110"></a><span id="l16.110" class="difflineminus">-{</span>
<a href="#l16.111"></a><span id="l16.111" class="difflineminus">-}</span>
<a href="#l16.112"></a><span id="l16.112" class="difflineplus">+nsImapFlagAndUidState::~nsImapFlagAndUidState() {}</span>
<a href="#l16.113"></a><span id="l16.113"> </span>
<a href="#l16.114"></a><span id="l16.114"> NS_IMETHODIMP</span>
<a href="#l16.115"></a><span id="l16.115" class="difflineminus">-nsImapFlagAndUidState::OrSupportedUserFlags(uint16_t flags)</span>
<a href="#l16.116"></a><span id="l16.116" class="difflineminus">-{</span>
<a href="#l16.117"></a><span id="l16.117" class="difflineplus">+nsImapFlagAndUidState::OrSupportedUserFlags(uint16_t flags) {</span>
<a href="#l16.118"></a><span id="l16.118">   fSupportedUserFlags |= flags;</span>
<a href="#l16.119"></a><span id="l16.119">   return NS_OK;</span>
<a href="#l16.120"></a><span id="l16.120"> }</span>
<a href="#l16.121"></a><span id="l16.121"> </span>
<a href="#l16.122"></a><span id="l16.122"> NS_IMETHODIMP</span>
<a href="#l16.123"></a><span id="l16.123" class="difflineminus">-nsImapFlagAndUidState::GetSupportedUserFlags(uint16_t *aFlags)</span>
<a href="#l16.124"></a><span id="l16.124" class="difflineminus">-{</span>
<a href="#l16.125"></a><span id="l16.125" class="difflineplus">+nsImapFlagAndUidState::GetSupportedUserFlags(uint16_t *aFlags) {</span>
<a href="#l16.126"></a><span id="l16.126">   NS_ENSURE_ARG_POINTER(aFlags);</span>
<a href="#l16.127"></a><span id="l16.127">   *aFlags = fSupportedUserFlags;</span>
<a href="#l16.128"></a><span id="l16.128">   return NS_OK;</span>
<a href="#l16.129"></a><span id="l16.129"> }</span>
<a href="#l16.130"></a><span id="l16.130"> </span>
<a href="#l16.131"></a><span id="l16.131"> NS_IMETHODIMP</span>
<a href="#l16.132"></a><span id="l16.132" class="difflineminus">-nsImapFlagAndUidState::SetOtherKeywords(uint16_t index, const nsACString &amp;otherKeyword)</span>
<a href="#l16.133"></a><span id="l16.133" class="difflineminus">-{</span>
<a href="#l16.134"></a><span id="l16.134" class="difflineminus">-  if (index == 0)</span>
<a href="#l16.135"></a><span id="l16.135" class="difflineminus">-    fOtherKeywords.Clear();</span>
<a href="#l16.136"></a><span id="l16.136" class="difflineplus">+nsImapFlagAndUidState::SetOtherKeywords(uint16_t index,</span>
<a href="#l16.137"></a><span id="l16.137" class="difflineplus">+                                        const nsACString &amp;otherKeyword) {</span>
<a href="#l16.138"></a><span id="l16.138" class="difflineplus">+  if (index == 0) fOtherKeywords.Clear();</span>
<a href="#l16.139"></a><span id="l16.139">   nsAutoCString flag(otherKeyword);</span>
<a href="#l16.140"></a><span id="l16.140">   ToLowerCase(flag);</span>
<a href="#l16.141"></a><span id="l16.141">   fOtherKeywords.AppendElement(flag);</span>
<a href="#l16.142"></a><span id="l16.142">   return NS_OK;</span>
<a href="#l16.143"></a><span id="l16.143"> }</span>
<a href="#l16.144"></a><span id="l16.144"> </span>
<a href="#l16.145"></a><span id="l16.145"> NS_IMETHODIMP</span>
<a href="#l16.146"></a><span id="l16.146" class="difflineminus">-nsImapFlagAndUidState::GetOtherKeywords(uint16_t index, nsACString &amp;aKeyword)</span>
<a href="#l16.147"></a><span id="l16.147" class="difflineminus">-{</span>
<a href="#l16.148"></a><span id="l16.148" class="difflineplus">+nsImapFlagAndUidState::GetOtherKeywords(uint16_t index, nsACString &amp;aKeyword) {</span>
<a href="#l16.149"></a><span id="l16.149">   if (index &lt; fOtherKeywords.Length())</span>
<a href="#l16.150"></a><span id="l16.150">     aKeyword = fOtherKeywords[index];</span>
<a href="#l16.151"></a><span id="l16.151">   else</span>
<a href="#l16.152"></a><span id="l16.152">     aKeyword = EmptyCString();</span>
<a href="#l16.153"></a><span id="l16.153">   return NS_OK;</span>
<a href="#l16.154"></a><span id="l16.154"> }</span>
<a href="#l16.155"></a><span id="l16.155"> </span>
<a href="#l16.156"></a><span id="l16.156" class="difflineminus">-// we need to reset our flags, (re-read all) but chances are the memory allocation needed will be</span>
<a href="#l16.157"></a><span id="l16.157" class="difflineminus">-// very close to what we were already using</span>
<a href="#l16.158"></a><span id="l16.158" class="difflineplus">+// we need to reset our flags, (re-read all) but chances are the memory</span>
<a href="#l16.159"></a><span id="l16.159" class="difflineplus">+// allocation needed will be very close to what we were already using</span>
<a href="#l16.160"></a><span id="l16.160"> </span>
<a href="#l16.161"></a><span id="l16.161" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::Reset()</span>
<a href="#l16.162"></a><span id="l16.162" class="difflineminus">-{</span>
<a href="#l16.163"></a><span id="l16.163" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::Reset() {</span>
<a href="#l16.164"></a><span id="l16.164">   PR_CEnterMonitor(this);</span>
<a href="#l16.165"></a><span id="l16.165">   fNumberDeleted = 0;</span>
<a href="#l16.166"></a><span id="l16.166">   m_customFlagsHash.Clear();</span>
<a href="#l16.167"></a><span id="l16.167">   fUids.Clear();</span>
<a href="#l16.168"></a><span id="l16.168">   fFlags.Clear();</span>
<a href="#l16.169"></a><span id="l16.169">   fPartialUIDFetch = true;</span>
<a href="#l16.170"></a><span id="l16.170">   fStartCapture = false;</span>
<a href="#l16.171"></a><span id="l16.171">   fNumAdded = 0;</span>
<a href="#l16.172"></a><span id="l16.172">   PR_CExitMonitor(this);</span>
<a href="#l16.173"></a><span id="l16.173">   return NS_OK;</span>
<a href="#l16.174"></a><span id="l16.174"> }</span>
<a href="#l16.175"></a><span id="l16.175"> </span>
<a href="#l16.176"></a><span id="l16.176" class="difflineminus">-</span>
<a href="#l16.177"></a><span id="l16.177"> // Remove (expunge) a message from our array, since now it is gone for good</span>
<a href="#l16.178"></a><span id="l16.178"> </span>
<a href="#l16.179"></a><span id="l16.179" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::ExpungeByIndex(uint32_t msgIndex)</span>
<a href="#l16.180"></a><span id="l16.180" class="difflineminus">-{</span>
<a href="#l16.181"></a><span id="l16.181" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::ExpungeByIndex(uint32_t msgIndex) {</span>
<a href="#l16.182"></a><span id="l16.182">   // protect ourselves in case the server gave us an index key of -1 or 0</span>
<a href="#l16.183"></a><span id="l16.183" class="difflineminus">-  if ((int32_t) msgIndex &lt;= 0)</span>
<a href="#l16.184"></a><span id="l16.184" class="difflineminus">-    return NS_ERROR_INVALID_ARG;</span>
<a href="#l16.185"></a><span id="l16.185" class="difflineplus">+  if ((int32_t)msgIndex &lt;= 0) return NS_ERROR_INVALID_ARG;</span>
<a href="#l16.186"></a><span id="l16.186"> </span>
<a href="#l16.187"></a><span id="l16.187" class="difflineminus">-  if ((uint32_t) fUids.Length() &lt; msgIndex)</span>
<a href="#l16.188"></a><span id="l16.188" class="difflineminus">-    return NS_ERROR_INVALID_ARG;</span>
<a href="#l16.189"></a><span id="l16.189" class="difflineplus">+  if ((uint32_t)fUids.Length() &lt; msgIndex) return NS_ERROR_INVALID_ARG;</span>
<a href="#l16.190"></a><span id="l16.190"> </span>
<a href="#l16.191"></a><span id="l16.191">   PR_CEnterMonitor(this);</span>
<a href="#l16.192"></a><span id="l16.192">   msgIndex--;  // msgIndex is 1-relative</span>
<a href="#l16.193"></a><span id="l16.193" class="difflineminus">-  if (fFlags[msgIndex] &amp; kImapMsgDeletedFlag) // see if we already had counted this one as deleted</span>
<a href="#l16.194"></a><span id="l16.194" class="difflineplus">+  if (fFlags[msgIndex] &amp;</span>
<a href="#l16.195"></a><span id="l16.195" class="difflineplus">+      kImapMsgDeletedFlag)  // see if we already had counted this one as deleted</span>
<a href="#l16.196"></a><span id="l16.196">     fNumberDeleted--;</span>
<a href="#l16.197"></a><span id="l16.197">   fUids.RemoveElementAt(msgIndex);</span>
<a href="#l16.198"></a><span id="l16.198">   fFlags.RemoveElementAt(msgIndex);</span>
<a href="#l16.199"></a><span id="l16.199">   PR_CExitMonitor(this);</span>
<a href="#l16.200"></a><span id="l16.200">   return NS_OK;</span>
<a href="#l16.201"></a><span id="l16.201"> }</span>
<a href="#l16.202"></a><span id="l16.202"> </span>
<a href="#l16.203"></a><span id="l16.203" class="difflineminus">-</span>
<a href="#l16.204"></a><span id="l16.204"> // adds to sorted list, protects against duplicates and going past array bounds.</span>
<a href="#l16.205"></a><span id="l16.205" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::AddUidFlagPair(uint32_t uid, imapMessageFlagsType flags, uint32_t zeroBasedIndex)</span>
<a href="#l16.206"></a><span id="l16.206" class="difflineminus">-{</span>
<a href="#l16.207"></a><span id="l16.207" class="difflineminus">-  if (uid == nsMsgKey_None) // ignore uid of -1</span>
<a href="#l16.208"></a><span id="l16.208" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::AddUidFlagPair(uint32_t uid,</span>
<a href="#l16.209"></a><span id="l16.209" class="difflineplus">+                                                    imapMessageFlagsType flags,</span>
<a href="#l16.210"></a><span id="l16.210" class="difflineplus">+                                                    uint32_t zeroBasedIndex) {</span>
<a href="#l16.211"></a><span id="l16.211" class="difflineplus">+  if (uid == nsMsgKey_None)  // ignore uid of -1</span>
<a href="#l16.212"></a><span id="l16.212">     return NS_OK;</span>
<a href="#l16.213"></a><span id="l16.213">   // check for potential overflow in buffer size for uid array</span>
<a href="#l16.214"></a><span id="l16.214" class="difflineminus">-  if (zeroBasedIndex &gt; 0x3FFFFFFF)</span>
<a href="#l16.215"></a><span id="l16.215" class="difflineminus">-    return NS_ERROR_INVALID_ARG;</span>
<a href="#l16.216"></a><span id="l16.216" class="difflineplus">+  if (zeroBasedIndex &gt; 0x3FFFFFFF) return NS_ERROR_INVALID_ARG;</span>
<a href="#l16.217"></a><span id="l16.217">   PR_CEnterMonitor(this);</span>
<a href="#l16.218"></a><span id="l16.218">   // make sure there is room for this pair</span>
<a href="#l16.219"></a><span id="l16.219" class="difflineminus">-  if (zeroBasedIndex &gt;= fUids.Length())</span>
<a href="#l16.220"></a><span id="l16.220" class="difflineminus">-  {</span>
<a href="#l16.221"></a><span id="l16.221" class="difflineplus">+  if (zeroBasedIndex &gt;= fUids.Length()) {</span>
<a href="#l16.222"></a><span id="l16.222">     int32_t sizeToGrowBy = zeroBasedIndex - fUids.Length() + 1;</span>
<a href="#l16.223"></a><span id="l16.223">     fUids.InsertElementsAt(fUids.Length(), sizeToGrowBy, 0);</span>
<a href="#l16.224"></a><span id="l16.224">     fFlags.InsertElementsAt(fFlags.Length(), sizeToGrowBy, 0);</span>
<a href="#l16.225"></a><span id="l16.225" class="difflineminus">-    if (fStartCapture)</span>
<a href="#l16.226"></a><span id="l16.226" class="difflineminus">-    {</span>
<a href="#l16.227"></a><span id="l16.227" class="difflineplus">+    if (fStartCapture) {</span>
<a href="#l16.228"></a><span id="l16.228">       // A new partial (CONDSTORE/CHANGEDSINCE) fetch response is occurring</span>
<a href="#l16.229"></a><span id="l16.229">       // so need to start the count of number of uid/flag combos added.</span>
<a href="#l16.230"></a><span id="l16.230">       fNumAdded = 0;</span>
<a href="#l16.231"></a><span id="l16.231">       fStartCapture = false;</span>
<a href="#l16.232"></a><span id="l16.232">     }</span>
<a href="#l16.233"></a><span id="l16.233">     fNumAdded++;</span>
<a href="#l16.234"></a><span id="l16.234">   }</span>
<a href="#l16.235"></a><span id="l16.235"> </span>
<a href="#l16.236"></a><span id="l16.236">   fUids[zeroBasedIndex] = uid;</span>
<a href="#l16.237"></a><span id="l16.237">   fFlags[zeroBasedIndex] = flags;</span>
<a href="#l16.238"></a><span id="l16.238" class="difflineminus">-  if (flags &amp; kImapMsgDeletedFlag)</span>
<a href="#l16.239"></a><span id="l16.239" class="difflineminus">-    fNumberDeleted++;</span>
<a href="#l16.240"></a><span id="l16.240" class="difflineplus">+  if (flags &amp; kImapMsgDeletedFlag) fNumberDeleted++;</span>
<a href="#l16.241"></a><span id="l16.241">   PR_CExitMonitor(this);</span>
<a href="#l16.242"></a><span id="l16.242">   return NS_OK;</span>
<a href="#l16.243"></a><span id="l16.243"> }</span>
<a href="#l16.244"></a><span id="l16.244"> </span>
<a href="#l16.245"></a><span id="l16.245" class="difflineminus">-</span>
<a href="#l16.246"></a><span id="l16.246" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::GetNumberOfDeletedMessages(int32_t *numDeletedMessages)</span>
<a href="#l16.247"></a><span id="l16.247" class="difflineminus">-{</span>
<a href="#l16.248"></a><span id="l16.248" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::GetNumberOfDeletedMessages(</span>
<a href="#l16.249"></a><span id="l16.249" class="difflineplus">+    int32_t *numDeletedMessages) {</span>
<a href="#l16.250"></a><span id="l16.250">   NS_ENSURE_ARG_POINTER(numDeletedMessages);</span>
<a href="#l16.251"></a><span id="l16.251">   *numDeletedMessages = NumberOfDeletedMessages();</span>
<a href="#l16.252"></a><span id="l16.252">   return NS_OK;</span>
<a href="#l16.253"></a><span id="l16.253"> }</span>
<a href="#l16.254"></a><span id="l16.254"> </span>
<a href="#l16.255"></a><span id="l16.255" class="difflineminus">-int32_t nsImapFlagAndUidState::NumberOfDeletedMessages()</span>
<a href="#l16.256"></a><span id="l16.256" class="difflineminus">-{</span>
<a href="#l16.257"></a><span id="l16.257" class="difflineplus">+int32_t nsImapFlagAndUidState::NumberOfDeletedMessages() {</span>
<a href="#l16.258"></a><span id="l16.258">   return fNumberDeleted;</span>
<a href="#l16.259"></a><span id="l16.259"> }</span>
<a href="#l16.260"></a><span id="l16.260"> </span>
<a href="#l16.261"></a><span id="l16.261"> // since the uids are sorted, start from the back (rb)</span>
<a href="#l16.262"></a><span id="l16.262"> </span>
<a href="#l16.263"></a><span id="l16.263" class="difflineminus">-uint32_t  nsImapFlagAndUidState::GetHighestNonDeletedUID()</span>
<a href="#l16.264"></a><span id="l16.264" class="difflineminus">-{</span>
<a href="#l16.265"></a><span id="l16.265" class="difflineplus">+uint32_t nsImapFlagAndUidState::GetHighestNonDeletedUID() {</span>
<a href="#l16.266"></a><span id="l16.266">   uint32_t msgIndex = fUids.Length();</span>
<a href="#l16.267"></a><span id="l16.267" class="difflineminus">-  do</span>
<a href="#l16.268"></a><span id="l16.268" class="difflineminus">-  {</span>
<a href="#l16.269"></a><span id="l16.269" class="difflineminus">-    if (msgIndex &lt;= 0)</span>
<a href="#l16.270"></a><span id="l16.270" class="difflineminus">-      return(0);</span>
<a href="#l16.271"></a><span id="l16.271" class="difflineplus">+  do {</span>
<a href="#l16.272"></a><span id="l16.272" class="difflineplus">+    if (msgIndex &lt;= 0) return (0);</span>
<a href="#l16.273"></a><span id="l16.273">     msgIndex--;</span>
<a href="#l16.274"></a><span id="l16.274">     if (fUids[msgIndex] &amp;&amp; !(fFlags[msgIndex] &amp; kImapMsgDeletedFlag))</span>
<a href="#l16.275"></a><span id="l16.275">       return fUids[msgIndex];</span>
<a href="#l16.276"></a><span id="l16.276" class="difflineminus">-  }</span>
<a href="#l16.277"></a><span id="l16.277" class="difflineminus">-  while (msgIndex &gt; 0);</span>
<a href="#l16.278"></a><span id="l16.278" class="difflineplus">+  } while (msgIndex &gt; 0);</span>
<a href="#l16.279"></a><span id="l16.279">   return 0;</span>
<a href="#l16.280"></a><span id="l16.280"> }</span>
<a href="#l16.281"></a><span id="l16.281"> </span>
<a href="#l16.282"></a><span id="l16.282" class="difflineplus">+// Has the user read the last message here ? Used when we first open the inbox</span>
<a href="#l16.283"></a><span id="l16.283" class="difflineplus">+// to see if there really is new mail there.</span>
<a href="#l16.284"></a><span id="l16.284"> </span>
<a href="#l16.285"></a><span id="l16.285" class="difflineminus">-// Has the user read the last message here ? Used when we first open the inbox to see if there</span>
<a href="#l16.286"></a><span id="l16.286" class="difflineminus">-// really is new mail there.</span>
<a href="#l16.287"></a><span id="l16.287" class="difflineminus">-</span>
<a href="#l16.288"></a><span id="l16.288" class="difflineminus">-bool nsImapFlagAndUidState::IsLastMessageUnseen()</span>
<a href="#l16.289"></a><span id="l16.289" class="difflineminus">-{</span>
<a href="#l16.290"></a><span id="l16.290" class="difflineplus">+bool nsImapFlagAndUidState::IsLastMessageUnseen() {</span>
<a href="#l16.291"></a><span id="l16.291">   uint32_t msgIndex = fUids.Length();</span>
<a href="#l16.292"></a><span id="l16.292"> </span>
<a href="#l16.293"></a><span id="l16.293" class="difflineminus">-  if (msgIndex &lt;= 0)</span>
<a href="#l16.294"></a><span id="l16.294" class="difflineminus">-    return false;</span>
<a href="#l16.295"></a><span id="l16.295" class="difflineplus">+  if (msgIndex &lt;= 0) return false;</span>
<a href="#l16.296"></a><span id="l16.296">   msgIndex--;</span>
<a href="#l16.297"></a><span id="l16.297">   // if last message is deleted, it was probably filtered the last time around</span>
<a href="#l16.298"></a><span id="l16.298" class="difflineminus">-  if (fUids[msgIndex] &amp;&amp; (fFlags[msgIndex] &amp; (kImapMsgSeenFlag | kImapMsgDeletedFlag)))</span>
<a href="#l16.299"></a><span id="l16.299" class="difflineplus">+  if (fUids[msgIndex] &amp;&amp;</span>
<a href="#l16.300"></a><span id="l16.300" class="difflineplus">+      (fFlags[msgIndex] &amp; (kImapMsgSeenFlag | kImapMsgDeletedFlag)))</span>
<a href="#l16.301"></a><span id="l16.301">     return false;</span>
<a href="#l16.302"></a><span id="l16.302">   return true;</span>
<a href="#l16.303"></a><span id="l16.303"> }</span>
<a href="#l16.304"></a><span id="l16.304"> </span>
<a href="#l16.305"></a><span id="l16.305" class="difflineminus">-// find a message flag given a key with non-recursive binary search, since some folders</span>
<a href="#l16.306"></a><span id="l16.306" class="difflineminus">-// may have thousand of messages, once we find the key set its index, or the index of</span>
<a href="#l16.307"></a><span id="l16.307" class="difflineminus">-// where the key should be inserted</span>
<a href="#l16.308"></a><span id="l16.308" class="difflineplus">+// find a message flag given a key with non-recursive binary search, since some</span>
<a href="#l16.309"></a><span id="l16.309" class="difflineplus">+// folders may have thousand of messages, once we find the key set its index, or</span>
<a href="#l16.310"></a><span id="l16.310" class="difflineplus">+// the index of where the key should be inserted</span>
<a href="#l16.311"></a><span id="l16.311"> </span>
<a href="#l16.312"></a><span id="l16.312" class="difflineminus">-imapMessageFlagsType nsImapFlagAndUidState::GetMessageFlagsFromUID(uint32_t uid, bool *foundIt, int32_t *ndx)</span>
<a href="#l16.313"></a><span id="l16.313" class="difflineminus">-{</span>
<a href="#l16.314"></a><span id="l16.314" class="difflineplus">+imapMessageFlagsType nsImapFlagAndUidState::GetMessageFlagsFromUID(</span>
<a href="#l16.315"></a><span id="l16.315" class="difflineplus">+    uint32_t uid, bool *foundIt, int32_t *ndx) {</span>
<a href="#l16.316"></a><span id="l16.316">   PR_CEnterMonitor(this);</span>
<a href="#l16.317"></a><span id="l16.317" class="difflineminus">-  *ndx = (int32_t) fUids.IndexOfFirstElementGt(uid) - 1;</span>
<a href="#l16.318"></a><span id="l16.318" class="difflineplus">+  *ndx = (int32_t)fUids.IndexOfFirstElementGt(uid) - 1;</span>
<a href="#l16.319"></a><span id="l16.319">   *foundIt = *ndx &gt;= 0 &amp;&amp; fUids[*ndx] == uid;</span>
<a href="#l16.320"></a><span id="l16.320">   imapMessageFlagsType retFlags = (*foundIt) ? fFlags[*ndx] : kNoImapMsgFlag;</span>
<a href="#l16.321"></a><span id="l16.321">   PR_CExitMonitor(this);</span>
<a href="#l16.322"></a><span id="l16.322">   return retFlags;</span>
<a href="#l16.323"></a><span id="l16.323"> }</span>
<a href="#l16.324"></a><span id="l16.324"> </span>
<a href="#l16.325"></a><span id="l16.325" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::AddUidCustomFlagPair(uint32_t uid, const char *customFlag)</span>
<a href="#l16.326"></a><span id="l16.326" class="difflineminus">-{</span>
<a href="#l16.327"></a><span id="l16.327" class="difflineminus">-  if (!customFlag)</span>
<a href="#l16.328"></a><span id="l16.328" class="difflineminus">-    return NS_OK;</span>
<a href="#l16.329"></a><span id="l16.329" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::AddUidCustomFlagPair(</span>
<a href="#l16.330"></a><span id="l16.330" class="difflineplus">+    uint32_t uid, const char *customFlag) {</span>
<a href="#l16.331"></a><span id="l16.331" class="difflineplus">+  if (!customFlag) return NS_OK;</span>
<a href="#l16.332"></a><span id="l16.332"> </span>
<a href="#l16.333"></a><span id="l16.333">   MutexAutoLock mon(mLock);</span>
<a href="#l16.334"></a><span id="l16.334">   nsCString ourCustomFlags;</span>
<a href="#l16.335"></a><span id="l16.335">   nsCString oldValue;</span>
<a href="#l16.336"></a><span id="l16.336" class="difflineminus">-  if (m_customFlagsHash.Get(uid, &amp;oldValue))</span>
<a href="#l16.337"></a><span id="l16.337" class="difflineminus">-  {</span>
<a href="#l16.338"></a><span id="l16.338" class="difflineplus">+  if (m_customFlagsHash.Get(uid, &amp;oldValue)) {</span>
<a href="#l16.339"></a><span id="l16.339">     // We'll store multiple keys as space-delimited since space is not</span>
<a href="#l16.340"></a><span id="l16.340">     // a valid character in a keyword. First, we need to look for the</span>
<a href="#l16.341"></a><span id="l16.341">     // customFlag in the existing flags;</span>
<a href="#l16.342"></a><span id="l16.342">     nsDependentCString customFlagString(customFlag);</span>
<a href="#l16.343"></a><span id="l16.343">     int32_t existingCustomFlagPos = oldValue.Find(customFlagString);</span>
<a href="#l16.344"></a><span id="l16.344">     uint32_t customFlagLen = customFlagString.Length();</span>
<a href="#l16.345"></a><span id="l16.345" class="difflineminus">-    while (existingCustomFlagPos != kNotFound)</span>
<a href="#l16.346"></a><span id="l16.346" class="difflineminus">-    {</span>
<a href="#l16.347"></a><span id="l16.347" class="difflineplus">+    while (existingCustomFlagPos != kNotFound) {</span>
<a href="#l16.348"></a><span id="l16.348">       // if existing flags ends with this exact flag, or flag + ' '</span>
<a href="#l16.349"></a><span id="l16.349">       // and the flag is at the beginning of the string or there is ' ' + flag</span>
<a href="#l16.350"></a><span id="l16.350">       // then we have this flag already;</span>
<a href="#l16.351"></a><span id="l16.351">       if (((oldValue.Length() == existingCustomFlagPos + customFlagLen) ||</span>
<a href="#l16.352"></a><span id="l16.352">            (oldValue.CharAt(existingCustomFlagPos + customFlagLen) == ' ')) &amp;&amp;</span>
<a href="#l16.353"></a><span id="l16.353" class="difflineminus">-           ((existingCustomFlagPos == 0) ||</span>
<a href="#l16.354"></a><span id="l16.354" class="difflineminus">-            (oldValue.CharAt(existingCustomFlagPos - 1) == ' ')))</span>
<a href="#l16.355"></a><span id="l16.355" class="difflineplus">+          ((existingCustomFlagPos == 0) ||</span>
<a href="#l16.356"></a><span id="l16.356" class="difflineplus">+           (oldValue.CharAt(existingCustomFlagPos - 1) == ' ')))</span>
<a href="#l16.357"></a><span id="l16.357">         return NS_OK;</span>
<a href="#l16.358"></a><span id="l16.358">       // else, advance to next flag</span>
<a href="#l16.359"></a><span id="l16.359" class="difflineminus">-      existingCustomFlagPos = MsgFind(oldValue, customFlagString, false, existingCustomFlagPos + customFlagLen);</span>
<a href="#l16.360"></a><span id="l16.360" class="difflineplus">+      existingCustomFlagPos = MsgFind(oldValue, customFlagString, false,</span>
<a href="#l16.361"></a><span id="l16.361" class="difflineplus">+                                      existingCustomFlagPos + customFlagLen);</span>
<a href="#l16.362"></a><span id="l16.362">     }</span>
<a href="#l16.363"></a><span id="l16.363">     ourCustomFlags.Assign(oldValue);</span>
<a href="#l16.364"></a><span id="l16.364">     ourCustomFlags.Append(' ');</span>
<a href="#l16.365"></a><span id="l16.365">     ourCustomFlags.Append(customFlag);</span>
<a href="#l16.366"></a><span id="l16.366">     m_customFlagsHash.Remove(uid);</span>
<a href="#l16.367"></a><span id="l16.367" class="difflineminus">-  }</span>
<a href="#l16.368"></a><span id="l16.368" class="difflineminus">-  else</span>
<a href="#l16.369"></a><span id="l16.369" class="difflineminus">-  {</span>
<a href="#l16.370"></a><span id="l16.370" class="difflineplus">+  } else {</span>
<a href="#l16.371"></a><span id="l16.371">     ourCustomFlags.Assign(customFlag);</span>
<a href="#l16.372"></a><span id="l16.372">   }</span>
<a href="#l16.373"></a><span id="l16.373">   m_customFlagsHash.Put(uid, ourCustomFlags);</span>
<a href="#l16.374"></a><span id="l16.374">   return NS_OK;</span>
<a href="#l16.375"></a><span id="l16.375"> }</span>
<a href="#l16.376"></a><span id="l16.376"> </span>
<a href="#l16.377"></a><span id="l16.377" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::GetCustomFlags(uint32_t uid, char **customFlags)</span>
<a href="#l16.378"></a><span id="l16.378" class="difflineminus">-{</span>
<a href="#l16.379"></a><span id="l16.379" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::GetCustomFlags(uint32_t uid,</span>
<a href="#l16.380"></a><span id="l16.380" class="difflineplus">+                                                    char **customFlags) {</span>
<a href="#l16.381"></a><span id="l16.381">   MutexAutoLock mon(mLock);</span>
<a href="#l16.382"></a><span id="l16.382">   nsCString value;</span>
<a href="#l16.383"></a><span id="l16.383" class="difflineminus">-  if (m_customFlagsHash.Get(uid, &amp;value))</span>
<a href="#l16.384"></a><span id="l16.384" class="difflineminus">-  {</span>
<a href="#l16.385"></a><span id="l16.385" class="difflineplus">+  if (m_customFlagsHash.Get(uid, &amp;value)) {</span>
<a href="#l16.386"></a><span id="l16.386">     *customFlags = NS_xstrdup(value.get());</span>
<a href="#l16.387"></a><span id="l16.387">     return (*customFlags) ? NS_OK : NS_ERROR_FAILURE;</span>
<a href="#l16.388"></a><span id="l16.388">   }</span>
<a href="#l16.389"></a><span id="l16.389">   *customFlags = nullptr;</span>
<a href="#l16.390"></a><span id="l16.390">   return NS_OK;</span>
<a href="#l16.391"></a><span id="l16.391"> }</span>
<a href="#l16.392"></a><span id="l16.392"> </span>
<a href="#l16.393"></a><span id="l16.393" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::ClearCustomFlags(uint32_t uid)</span>
<a href="#l16.394"></a><span id="l16.394" class="difflineminus">-{</span>
<a href="#l16.395"></a><span id="l16.395" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::ClearCustomFlags(uint32_t uid) {</span>
<a href="#l16.396"></a><span id="l16.396">   MutexAutoLock mon(mLock);</span>
<a href="#l16.397"></a><span id="l16.397">   m_customFlagsHash.Remove(uid);</span>
<a href="#l16.398"></a><span id="l16.398">   return NS_OK;</span>
<a href="#l16.399"></a><span id="l16.399"> }</span>
<a href="#l16.400"></a><span id="l16.400"> </span>
<a href="#l16.401"></a><span id="l16.401" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::SetCustomAttribute(uint32_t aUid,</span>
<a href="#l16.402"></a><span id="l16.402" class="difflineminus">-                                                        const nsACString &amp;aCustomAttributeName,</span>
<a href="#l16.403"></a><span id="l16.403" class="difflineminus">-                                                        const nsACString &amp;aCustomAttributeValue)</span>
<a href="#l16.404"></a><span id="l16.404" class="difflineminus">-{</span>
<a href="#l16.405"></a><span id="l16.405" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::SetCustomAttribute(</span>
<a href="#l16.406"></a><span id="l16.406" class="difflineplus">+    uint32_t aUid, const nsACString &amp;aCustomAttributeName,</span>
<a href="#l16.407"></a><span id="l16.407" class="difflineplus">+    const nsACString &amp;aCustomAttributeValue) {</span>
<a href="#l16.408"></a><span id="l16.408">   nsCString key;</span>
<a href="#l16.409"></a><span id="l16.409">   key.AppendInt((int64_t)aUid);</span>
<a href="#l16.410"></a><span id="l16.410">   key.Append(aCustomAttributeName);</span>
<a href="#l16.411"></a><span id="l16.411">   nsCString value;</span>
<a href="#l16.412"></a><span id="l16.412">   value.Assign(aCustomAttributeValue);</span>
<a href="#l16.413"></a><span id="l16.413">   m_customAttributesHash.Put(key, value);</span>
<a href="#l16.414"></a><span id="l16.414">   return NS_OK;</span>
<a href="#l16.415"></a><span id="l16.415"> }</span>
<a href="#l16.416"></a><span id="l16.416"> </span>
<a href="#l16.417"></a><span id="l16.417" class="difflineminus">-NS_IMETHODIMP nsImapFlagAndUidState::GetCustomAttribute(uint32_t aUid,</span>
<a href="#l16.418"></a><span id="l16.418" class="difflineminus">-                                                        const nsACString &amp;aCustomAttributeName,</span>
<a href="#l16.419"></a><span id="l16.419" class="difflineminus">-                                                        nsACString &amp;aCustomAttributeValue)</span>
<a href="#l16.420"></a><span id="l16.420" class="difflineminus">-{</span>
<a href="#l16.421"></a><span id="l16.421" class="difflineplus">+NS_IMETHODIMP nsImapFlagAndUidState::GetCustomAttribute(</span>
<a href="#l16.422"></a><span id="l16.422" class="difflineplus">+    uint32_t aUid, const nsACString &amp;aCustomAttributeName,</span>
<a href="#l16.423"></a><span id="l16.423" class="difflineplus">+    nsACString &amp;aCustomAttributeValue) {</span>
<a href="#l16.424"></a><span id="l16.424">   nsCString key;</span>
<a href="#l16.425"></a><span id="l16.425">   key.AppendInt((int64_t)aUid);</span>
<a href="#l16.426"></a><span id="l16.426">   key.Append(aCustomAttributeName);</span>
<a href="#l16.427"></a><span id="l16.427">   nsCString val;</span>
<a href="#l16.428"></a><span id="l16.428">   m_customAttributesHash.Get(key, &amp;val);</span>
<a href="#l16.429"></a><span id="l16.429">   aCustomAttributeValue.Assign(val);</span>
<a href="#l16.430"></a><span id="l16.430">   return NS_OK;</span>
<a href="#l16.431"></a><span id="l16.431"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/mailnews/imap/src/nsImapFlagAndUidState.h</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapFlagAndUidState.h</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -12,48 +12,48 @@</span>
<a href="#l17.4"></a><span id="l17.4"> #include &quot;nsTArray.h&quot;</span>
<a href="#l17.5"></a><span id="l17.5"> #include &quot;mozilla/Mutex.h&quot;</span>
<a href="#l17.6"></a><span id="l17.6"> </span>
<a href="#l17.7"></a><span id="l17.7"> const int32_t kImapFlagAndUidStateSize = 100;</span>
<a href="#l17.8"></a><span id="l17.8"> </span>
<a href="#l17.9"></a><span id="l17.9"> #include &quot;nsBaseHashtable.h&quot;</span>
<a href="#l17.10"></a><span id="l17.10"> #include &quot;nsDataHashtable.h&quot;</span>
<a href="#l17.11"></a><span id="l17.11"> </span>
<a href="#l17.12"></a><span id="l17.12" class="difflineminus">-class nsImapFlagAndUidState : public nsIImapFlagAndUidState</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineminus">-{</span>
<a href="#l17.14"></a><span id="l17.14" class="difflineminus">-public:</span>
<a href="#l17.15"></a><span id="l17.15" class="difflineminus">-    NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l17.16"></a><span id="l17.16" class="difflineminus">-    explicit nsImapFlagAndUidState(int numberOfMessages);</span>
<a href="#l17.17"></a><span id="l17.17" class="difflineplus">+class nsImapFlagAndUidState : public nsIImapFlagAndUidState {</span>
<a href="#l17.18"></a><span id="l17.18" class="difflineplus">+ public:</span>
<a href="#l17.19"></a><span id="l17.19" class="difflineplus">+  NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l17.20"></a><span id="l17.20" class="difflineplus">+  explicit nsImapFlagAndUidState(int numberOfMessages);</span>
<a href="#l17.21"></a><span id="l17.21"> </span>
<a href="#l17.22"></a><span id="l17.22" class="difflineminus">-    NS_DECL_NSIIMAPFLAGANDUIDSTATE</span>
<a href="#l17.23"></a><span id="l17.23" class="difflineplus">+  NS_DECL_NSIIMAPFLAGANDUIDSTATE</span>
<a href="#l17.24"></a><span id="l17.24"> </span>
<a href="#l17.25"></a><span id="l17.25" class="difflineminus">-    int32_t               NumberOfDeletedMessages();</span>
<a href="#l17.26"></a><span id="l17.26" class="difflineplus">+  int32_t NumberOfDeletedMessages();</span>
<a href="#l17.27"></a><span id="l17.27"> </span>
<a href="#l17.28"></a><span id="l17.28" class="difflineminus">-    imapMessageFlagsType  GetMessageFlagsFromUID(uint32_t uid, bool *foundIt, int32_t *ndx);</span>
<a href="#l17.29"></a><span id="l17.29" class="difflineplus">+  imapMessageFlagsType GetMessageFlagsFromUID(uint32_t uid, bool *foundIt,</span>
<a href="#l17.30"></a><span id="l17.30" class="difflineplus">+                                              int32_t *ndx);</span>
<a href="#l17.31"></a><span id="l17.31"> </span>
<a href="#l17.32"></a><span id="l17.32" class="difflineminus">-    bool         IsLastMessageUnseen(void);</span>
<a href="#l17.33"></a><span id="l17.33" class="difflineminus">-    bool         GetPartialUIDFetch() {return fPartialUIDFetch;}</span>
<a href="#l17.34"></a><span id="l17.34" class="difflineminus">-    void         SetPartialUIDFetch(bool isPartial) {fPartialUIDFetch = isPartial;}</span>
<a href="#l17.35"></a><span id="l17.35" class="difflineminus">-    uint32_t     GetHighestNonDeletedUID();</span>
<a href="#l17.36"></a><span id="l17.36" class="difflineminus">-    uint16_t     GetSupportedUserFlags() { return fSupportedUserFlags; }</span>
<a href="#l17.37"></a><span id="l17.37" class="difflineminus">-    void         StartCapture() { fStartCapture = true; }</span>
<a href="#l17.38"></a><span id="l17.38" class="difflineminus">-    uint32_t     GetNumAdded() { return fNumAdded; }</span>
<a href="#l17.39"></a><span id="l17.39" class="difflineplus">+  bool IsLastMessageUnseen(void);</span>
<a href="#l17.40"></a><span id="l17.40" class="difflineplus">+  bool GetPartialUIDFetch() { return fPartialUIDFetch; }</span>
<a href="#l17.41"></a><span id="l17.41" class="difflineplus">+  void SetPartialUIDFetch(bool isPartial) { fPartialUIDFetch = isPartial; }</span>
<a href="#l17.42"></a><span id="l17.42" class="difflineplus">+  uint32_t GetHighestNonDeletedUID();</span>
<a href="#l17.43"></a><span id="l17.43" class="difflineplus">+  uint16_t GetSupportedUserFlags() { return fSupportedUserFlags; }</span>
<a href="#l17.44"></a><span id="l17.44" class="difflineplus">+  void StartCapture() { fStartCapture = true; }</span>
<a href="#l17.45"></a><span id="l17.45" class="difflineplus">+  uint32_t GetNumAdded() { return fNumAdded; }</span>
<a href="#l17.46"></a><span id="l17.46"> </span>
<a href="#l17.47"></a><span id="l17.47" class="difflineminus">-private:</span>
<a href="#l17.48"></a><span id="l17.48" class="difflineplus">+ private:</span>
<a href="#l17.49"></a><span id="l17.49">   virtual ~nsImapFlagAndUidState();</span>
<a href="#l17.50"></a><span id="l17.50"> </span>
<a href="#l17.51"></a><span id="l17.51" class="difflineminus">-    nsTArray&lt;nsMsgKey&gt;      fUids;</span>
<a href="#l17.52"></a><span id="l17.52" class="difflineminus">-    nsTArray&lt;imapMessageFlagsType&gt; fFlags;</span>
<a href="#l17.53"></a><span id="l17.53" class="difflineminus">-    // Hash table, mapping uids to extra flags</span>
<a href="#l17.54"></a><span id="l17.54" class="difflineminus">-    nsDataHashtable&lt;nsUint32HashKey, nsCString&gt; m_customFlagsHash;</span>
<a href="#l17.55"></a><span id="l17.55" class="difflineminus">-    // Hash table, mapping UID+customAttributeName to customAttributeValue.</span>
<a href="#l17.56"></a><span id="l17.56" class="difflineminus">-    nsDataHashtable&lt;nsCStringHashKey, nsCString&gt; m_customAttributesHash;</span>
<a href="#l17.57"></a><span id="l17.57" class="difflineminus">-    uint16_t                fSupportedUserFlags;</span>
<a href="#l17.58"></a><span id="l17.58" class="difflineminus">-    int32_t                 fNumberDeleted;</span>
<a href="#l17.59"></a><span id="l17.59" class="difflineminus">-    bool                    fPartialUIDFetch;</span>
<a href="#l17.60"></a><span id="l17.60" class="difflineminus">-    uint32_t                fNumAdded;</span>
<a href="#l17.61"></a><span id="l17.61" class="difflineminus">-    bool                    fStartCapture;</span>
<a href="#l17.62"></a><span id="l17.62" class="difflineminus">-    // Keywords (aka, tags) in FLAGS response to SELECT defined by other clients</span>
<a href="#l17.63"></a><span id="l17.63" class="difflineminus">-    nsTArray&lt;nsCString&gt;     fOtherKeywords;</span>
<a href="#l17.64"></a><span id="l17.64" class="difflineminus">-    mozilla::Mutex mLock;</span>
<a href="#l17.65"></a><span id="l17.65" class="difflineplus">+  nsTArray&lt;nsMsgKey&gt; fUids;</span>
<a href="#l17.66"></a><span id="l17.66" class="difflineplus">+  nsTArray&lt;imapMessageFlagsType&gt; fFlags;</span>
<a href="#l17.67"></a><span id="l17.67" class="difflineplus">+  // Hash table, mapping uids to extra flags</span>
<a href="#l17.68"></a><span id="l17.68" class="difflineplus">+  nsDataHashtable&lt;nsUint32HashKey, nsCString&gt; m_customFlagsHash;</span>
<a href="#l17.69"></a><span id="l17.69" class="difflineplus">+  // Hash table, mapping UID+customAttributeName to customAttributeValue.</span>
<a href="#l17.70"></a><span id="l17.70" class="difflineplus">+  nsDataHashtable&lt;nsCStringHashKey, nsCString&gt; m_customAttributesHash;</span>
<a href="#l17.71"></a><span id="l17.71" class="difflineplus">+  uint16_t fSupportedUserFlags;</span>
<a href="#l17.72"></a><span id="l17.72" class="difflineplus">+  int32_t fNumberDeleted;</span>
<a href="#l17.73"></a><span id="l17.73" class="difflineplus">+  bool fPartialUIDFetch;</span>
<a href="#l17.74"></a><span id="l17.74" class="difflineplus">+  uint32_t fNumAdded;</span>
<a href="#l17.75"></a><span id="l17.75" class="difflineplus">+  bool fStartCapture;</span>
<a href="#l17.76"></a><span id="l17.76" class="difflineplus">+  // Keywords (aka, tags) in FLAGS response to SELECT defined by other clients</span>
<a href="#l17.77"></a><span id="l17.77" class="difflineplus">+  nsTArray&lt;nsCString&gt; fOtherKeywords;</span>
<a href="#l17.78"></a><span id="l17.78" class="difflineplus">+  mozilla::Mutex mLock;</span>
<a href="#l17.79"></a><span id="l17.79"> };</span>
<a href="#l17.80"></a><span id="l17.80"> </span>
<a href="#l17.81"></a><span id="l17.81"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/mailnews/imap/src/nsImapIncomingServer.cpp</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapIncomingServer.cpp</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -58,53 +58,56 @@ NS_IMPL_RELEASE_INHERITED(nsImapIncoming</span>
<a href="#l18.4"></a><span id="l18.4"> NS_INTERFACE_MAP_BEGIN(nsImapIncomingServer)</span>
<a href="#l18.5"></a><span id="l18.5">   NS_INTERFACE_MAP_ENTRY(nsIImapServerSink)</span>
<a href="#l18.6"></a><span id="l18.6">   NS_INTERFACE_MAP_ENTRY(nsIImapIncomingServer)</span>
<a href="#l18.7"></a><span id="l18.7">   NS_INTERFACE_MAP_ENTRY(nsISubscribableServer)</span>
<a href="#l18.8"></a><span id="l18.8">   NS_INTERFACE_MAP_ENTRY(nsIUrlListener)</span>
<a href="#l18.9"></a><span id="l18.9"> NS_INTERFACE_MAP_END_INHERITING(nsMsgIncomingServer)</span>
<a href="#l18.10"></a><span id="l18.10"> </span>
<a href="#l18.11"></a><span id="l18.11"> nsImapIncomingServer::nsImapIncomingServer()</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineminus">-  : mLock(&quot;nsImapIncomingServer.mLock&quot;)</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineminus">-{</span>
<a href="#l18.14"></a><span id="l18.14" class="difflineplus">+    : mLock(&quot;nsImapIncomingServer.mLock&quot;) {</span>
<a href="#l18.15"></a><span id="l18.15">   m_capability = kCapabilityUndefined;</span>
<a href="#l18.16"></a><span id="l18.16">   mDoingSubscribeDialog = false;</span>
<a href="#l18.17"></a><span id="l18.17">   mDoingLsub = false;</span>
<a href="#l18.18"></a><span id="l18.18">   m_canHaveFilters = true;</span>
<a href="#l18.19"></a><span id="l18.19">   m_userAuthenticated = false;</span>
<a href="#l18.20"></a><span id="l18.20">   m_shuttingDown = false;</span>
<a href="#l18.21"></a><span id="l18.21"> }</span>
<a href="#l18.22"></a><span id="l18.22"> </span>
<a href="#l18.23"></a><span id="l18.23" class="difflineminus">-nsImapIncomingServer::~nsImapIncomingServer()</span>
<a href="#l18.24"></a><span id="l18.24" class="difflineminus">-{</span>
<a href="#l18.25"></a><span id="l18.25" class="difflineplus">+nsImapIncomingServer::~nsImapIncomingServer() {</span>
<a href="#l18.26"></a><span id="l18.26">   mozilla::DebugOnly&lt;nsresult&gt; rv = ClearInner();</span>
<a href="#l18.27"></a><span id="l18.27">   NS_ASSERTION(NS_SUCCEEDED(rv), &quot;ClearInner failed&quot;);</span>
<a href="#l18.28"></a><span id="l18.28">   CloseCachedConnections();</span>
<a href="#l18.29"></a><span id="l18.29"> }</span>
<a href="#l18.30"></a><span id="l18.30"> </span>
<a href="#l18.31"></a><span id="l18.31" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::SetKey(const nsACString&amp; aKey)  // override nsMsgIncomingServer's implementation...</span>
<a href="#l18.32"></a><span id="l18.32" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::SetKey(</span>
<a href="#l18.33"></a><span id="l18.33" class="difflineplus">+    const nsACString &amp;aKey)  // override nsMsgIncomingServer's implementation...</span>
<a href="#l18.34"></a><span id="l18.34"> {</span>
<a href="#l18.35"></a><span id="l18.35">   nsMsgIncomingServer::SetKey(aKey);</span>
<a href="#l18.36"></a><span id="l18.36"> </span>
<a href="#l18.37"></a><span id="l18.37">   // okay now that the key has been set, we need to add ourselves to the</span>
<a href="#l18.38"></a><span id="l18.38">   // host session list...</span>
<a href="#l18.39"></a><span id="l18.39"> </span>
<a href="#l18.40"></a><span id="l18.40">   // every time we create an imap incoming server, we need to add it to the</span>
<a href="#l18.41"></a><span id="l18.41">   // host session list!!</span>
<a href="#l18.42"></a><span id="l18.42"> </span>
<a href="#l18.43"></a><span id="l18.43">   nsresult rv;</span>
<a href="#l18.44"></a><span id="l18.44" class="difflineminus">-  nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession = do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.45"></a><span id="l18.45" class="difflineplus">+  nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession =</span>
<a href="#l18.46"></a><span id="l18.46" class="difflineplus">+      do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.47"></a><span id="l18.47">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.48"></a><span id="l18.48"> </span>
<a href="#l18.49"></a><span id="l18.49">   nsCString key(aKey);</span>
<a href="#l18.50"></a><span id="l18.50">   hostSession-&gt;AddHostToList(key.get(), this);</span>
<a href="#l18.51"></a><span id="l18.51" class="difflineminus">-  nsMsgImapDeleteModel deleteModel = nsMsgImapDeleteModels::MoveToTrash; // default to trash</span>
<a href="#l18.52"></a><span id="l18.52" class="difflineplus">+  nsMsgImapDeleteModel deleteModel =</span>
<a href="#l18.53"></a><span id="l18.53" class="difflineplus">+      nsMsgImapDeleteModels::MoveToTrash;  // default to trash</span>
<a href="#l18.54"></a><span id="l18.54">   GetDeleteModel(&amp;deleteModel);</span>
<a href="#l18.55"></a><span id="l18.55" class="difflineminus">-  hostSession-&gt;SetDeleteIsMoveToTrashForHost(key.get(), deleteModel == nsMsgImapDeleteModels::MoveToTrash);</span>
<a href="#l18.56"></a><span id="l18.56" class="difflineminus">-  hostSession-&gt;SetShowDeletedMessagesForHost(key.get(), deleteModel == nsMsgImapDeleteModels::IMAPDelete);</span>
<a href="#l18.57"></a><span id="l18.57" class="difflineplus">+  hostSession-&gt;SetDeleteIsMoveToTrashForHost(</span>
<a href="#l18.58"></a><span id="l18.58" class="difflineplus">+      key.get(), deleteModel == nsMsgImapDeleteModels::MoveToTrash);</span>
<a href="#l18.59"></a><span id="l18.59" class="difflineplus">+  hostSession-&gt;SetShowDeletedMessagesForHost(</span>
<a href="#l18.60"></a><span id="l18.60" class="difflineplus">+      key.get(), deleteModel == nsMsgImapDeleteModels::IMAPDelete);</span>
<a href="#l18.61"></a><span id="l18.61"> </span>
<a href="#l18.62"></a><span id="l18.62">   nsAutoCString onlineDir;</span>
<a href="#l18.63"></a><span id="l18.63">   rv = GetServerDirectory(onlineDir);</span>
<a href="#l18.64"></a><span id="l18.64">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.65"></a><span id="l18.65">   if (!onlineDir.IsEmpty())</span>
<a href="#l18.66"></a><span id="l18.66">     hostSession-&gt;SetOnlineDirForHost(key.get(), onlineDir.get());</span>
<a href="#l18.67"></a><span id="l18.67"> </span>
<a href="#l18.68"></a><span id="l18.68">   nsCString personalNamespace;</span>
<a href="#l18.69"></a><span id="l18.69" class="difflineat">@@ -113,596 +116,536 @@ NS_IMETHODIMP nsImapIncomingServer::SetK</span>
<a href="#l18.70"></a><span id="l18.70"> </span>
<a href="#l18.71"></a><span id="l18.71">   rv = GetPersonalNamespace(personalNamespace);</span>
<a href="#l18.72"></a><span id="l18.72">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.73"></a><span id="l18.73">   rv = GetPublicNamespace(publicNamespace);</span>
<a href="#l18.74"></a><span id="l18.74">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.75"></a><span id="l18.75">   rv = GetOtherUsersNamespace(otherUsersNamespace);</span>
<a href="#l18.76"></a><span id="l18.76">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.77"></a><span id="l18.77"> </span>
<a href="#l18.78"></a><span id="l18.78" class="difflineminus">-  if (personalNamespace.IsEmpty() &amp;&amp; publicNamespace.IsEmpty() &amp;&amp; otherUsersNamespace.IsEmpty())</span>
<a href="#l18.79"></a><span id="l18.79" class="difflineminus">-      personalNamespace.AssignLiteral(&quot;\&quot;\&quot;&quot;);</span>
<a href="#l18.80"></a><span id="l18.80" class="difflineplus">+  if (personalNamespace.IsEmpty() &amp;&amp; publicNamespace.IsEmpty() &amp;&amp;</span>
<a href="#l18.81"></a><span id="l18.81" class="difflineplus">+      otherUsersNamespace.IsEmpty())</span>
<a href="#l18.82"></a><span id="l18.82" class="difflineplus">+    personalNamespace.AssignLiteral(&quot;\&quot;\&quot;&quot;);</span>
<a href="#l18.83"></a><span id="l18.83"> </span>
<a href="#l18.84"></a><span id="l18.84">   hostSession-&gt;SetNamespaceFromPrefForHost(key.get(), personalNamespace.get(),</span>
<a href="#l18.85"></a><span id="l18.85">                                            kPersonalNamespace);</span>
<a href="#l18.86"></a><span id="l18.86"> </span>
<a href="#l18.87"></a><span id="l18.87">   if (!publicNamespace.IsEmpty())</span>
<a href="#l18.88"></a><span id="l18.88" class="difflineminus">-      hostSession-&gt;SetNamespaceFromPrefForHost(key.get(), publicNamespace.get(),</span>
<a href="#l18.89"></a><span id="l18.89" class="difflineminus">-                                               kPublicNamespace);</span>
<a href="#l18.90"></a><span id="l18.90" class="difflineplus">+    hostSession-&gt;SetNamespaceFromPrefForHost(key.get(), publicNamespace.get(),</span>
<a href="#l18.91"></a><span id="l18.91" class="difflineplus">+                                             kPublicNamespace);</span>
<a href="#l18.92"></a><span id="l18.92"> </span>
<a href="#l18.93"></a><span id="l18.93">   if (!otherUsersNamespace.IsEmpty())</span>
<a href="#l18.94"></a><span id="l18.94" class="difflineminus">-      hostSession-&gt;SetNamespaceFromPrefForHost(key.get(), otherUsersNamespace.get(),</span>
<a href="#l18.95"></a><span id="l18.95" class="difflineminus">-                                               kOtherUsersNamespace);</span>
<a href="#l18.96"></a><span id="l18.96" class="difflineplus">+    hostSession-&gt;SetNamespaceFromPrefForHost(</span>
<a href="#l18.97"></a><span id="l18.97" class="difflineplus">+        key.get(), otherUsersNamespace.get(), kOtherUsersNamespace);</span>
<a href="#l18.98"></a><span id="l18.98">   return rv;</span>
<a href="#l18.99"></a><span id="l18.99"> }</span>
<a href="#l18.100"></a><span id="l18.100"> </span>
<a href="#l18.101"></a><span id="l18.101"> // construct the pretty name to show to the user if they haven't</span>
<a href="#l18.102"></a><span id="l18.102"> // specified one. This should be overridden for news and mail.</span>
<a href="#l18.103"></a><span id="l18.103"> NS_IMETHODIMP</span>
<a href="#l18.104"></a><span id="l18.104" class="difflineminus">-nsImapIncomingServer::GetConstructedPrettyName(nsAString&amp; retval)</span>
<a href="#l18.105"></a><span id="l18.105" class="difflineminus">-{</span>
<a href="#l18.106"></a><span id="l18.106" class="difflineplus">+nsImapIncomingServer::GetConstructedPrettyName(nsAString &amp;retval) {</span>
<a href="#l18.107"></a><span id="l18.107">   nsAutoCString username;</span>
<a href="#l18.108"></a><span id="l18.108">   nsAutoCString hostName;</span>
<a href="#l18.109"></a><span id="l18.109">   nsresult rv;</span>
<a href="#l18.110"></a><span id="l18.110"> </span>
<a href="#l18.111"></a><span id="l18.111">   nsCOMPtr&lt;nsIMsgAccountManager&gt; accountManager =</span>
<a href="#l18.112"></a><span id="l18.112" class="difflineminus">-           do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l18.113"></a><span id="l18.113" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.114"></a><span id="l18.114" class="difflineplus">+      do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l18.115"></a><span id="l18.115" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.116"></a><span id="l18.116"> </span>
<a href="#l18.117"></a><span id="l18.117">   nsCOMPtr&lt;nsIMsgIdentity&gt; identity;</span>
<a href="#l18.118"></a><span id="l18.118" class="difflineminus">-  rv = accountManager-&gt;GetFirstIdentityForServer(this, getter_AddRefs(identity));</span>
<a href="#l18.119"></a><span id="l18.119" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.120"></a><span id="l18.120" class="difflineplus">+  rv =</span>
<a href="#l18.121"></a><span id="l18.121" class="difflineplus">+      accountManager-&gt;GetFirstIdentityForServer(this, getter_AddRefs(identity));</span>
<a href="#l18.122"></a><span id="l18.122" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.123"></a><span id="l18.123"> </span>
<a href="#l18.124"></a><span id="l18.124">   nsAutoString emailAddress;</span>
<a href="#l18.125"></a><span id="l18.125"> </span>
<a href="#l18.126"></a><span id="l18.126" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; identity)</span>
<a href="#l18.127"></a><span id="l18.127" class="difflineminus">-  {</span>
<a href="#l18.128"></a><span id="l18.128" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; identity) {</span>
<a href="#l18.129"></a><span id="l18.129">     nsCString identityEmailAddress;</span>
<a href="#l18.130"></a><span id="l18.130">     identity-&gt;GetEmail(identityEmailAddress);</span>
<a href="#l18.131"></a><span id="l18.131">     CopyASCIItoUTF16(identityEmailAddress, emailAddress);</span>
<a href="#l18.132"></a><span id="l18.132" class="difflineminus">-  }</span>
<a href="#l18.133"></a><span id="l18.133" class="difflineminus">-  else</span>
<a href="#l18.134"></a><span id="l18.134" class="difflineminus">-  {</span>
<a href="#l18.135"></a><span id="l18.135" class="difflineplus">+  } else {</span>
<a href="#l18.136"></a><span id="l18.136">     rv = GetRealUsername(username);</span>
<a href="#l18.137"></a><span id="l18.137" class="difflineminus">-    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.138"></a><span id="l18.138" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.139"></a><span id="l18.139">     rv = GetRealHostName(hostName);</span>
<a href="#l18.140"></a><span id="l18.140" class="difflineminus">-    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.141"></a><span id="l18.141" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.142"></a><span id="l18.142">     if (!username.IsEmpty() &amp;&amp; !hostName.IsEmpty()) {</span>
<a href="#l18.143"></a><span id="l18.143">       CopyASCIItoUTF16(username, emailAddress);</span>
<a href="#l18.144"></a><span id="l18.144">       emailAddress.Append('@');</span>
<a href="#l18.145"></a><span id="l18.145">       emailAddress.Append(NS_ConvertASCIItoUTF16(hostName));</span>
<a href="#l18.146"></a><span id="l18.146">     }</span>
<a href="#l18.147"></a><span id="l18.147">   }</span>
<a href="#l18.148"></a><span id="l18.148"> </span>
<a href="#l18.149"></a><span id="l18.149" class="difflineminus">-  return GetFormattedStringFromName(emailAddress, &quot;imapDefaultAccountName&quot;, retval);</span>
<a href="#l18.150"></a><span id="l18.150" class="difflineplus">+  return GetFormattedStringFromName(emailAddress, &quot;imapDefaultAccountName&quot;,</span>
<a href="#l18.151"></a><span id="l18.151" class="difflineplus">+                                    retval);</span>
<a href="#l18.152"></a><span id="l18.152"> }</span>
<a href="#l18.153"></a><span id="l18.153"> </span>
<a href="#l18.154"></a><span id="l18.154" class="difflineminus">-</span>
<a href="#l18.155"></a><span id="l18.155" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::GetLocalStoreType(nsACString&amp; type)</span>
<a href="#l18.156"></a><span id="l18.156" class="difflineminus">-{</span>
<a href="#l18.157"></a><span id="l18.157" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::GetLocalStoreType(nsACString &amp;type) {</span>
<a href="#l18.158"></a><span id="l18.158">   type.AssignLiteral(&quot;imap&quot;);</span>
<a href="#l18.159"></a><span id="l18.159">   return NS_OK;</span>
<a href="#l18.160"></a><span id="l18.160"> }</span>
<a href="#l18.161"></a><span id="l18.161"> </span>
<a href="#l18.162"></a><span id="l18.162" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::GetLocalDatabaseType(nsACString&amp; type)</span>
<a href="#l18.163"></a><span id="l18.163" class="difflineminus">-{</span>
<a href="#l18.164"></a><span id="l18.164" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::GetLocalDatabaseType(nsACString &amp;type) {</span>
<a href="#l18.165"></a><span id="l18.165">   type.AssignLiteral(&quot;imap&quot;);</span>
<a href="#l18.166"></a><span id="l18.166">   return NS_OK;</span>
<a href="#l18.167"></a><span id="l18.167"> }</span>
<a href="#l18.168"></a><span id="l18.168"> </span>
<a href="#l18.169"></a><span id="l18.169"> NS_IMETHODIMP</span>
<a href="#l18.170"></a><span id="l18.170" class="difflineminus">-nsImapIncomingServer::GetServerDirectory(nsACString&amp; serverDirectory)</span>
<a href="#l18.171"></a><span id="l18.171" class="difflineminus">-{</span>
<a href="#l18.172"></a><span id="l18.172" class="difflineplus">+nsImapIncomingServer::GetServerDirectory(nsACString &amp;serverDirectory) {</span>
<a href="#l18.173"></a><span id="l18.173">   return GetCharValue(&quot;server_sub_directory&quot;, serverDirectory);</span>
<a href="#l18.174"></a><span id="l18.174"> }</span>
<a href="#l18.175"></a><span id="l18.175"> </span>
<a href="#l18.176"></a><span id="l18.176"> NS_IMETHODIMP</span>
<a href="#l18.177"></a><span id="l18.177" class="difflineminus">-nsImapIncomingServer::SetServerDirectory(const nsACString&amp; serverDirectory)</span>
<a href="#l18.178"></a><span id="l18.178" class="difflineminus">-{</span>
<a href="#l18.179"></a><span id="l18.179" class="difflineplus">+nsImapIncomingServer::SetServerDirectory(const nsACString &amp;serverDirectory) {</span>
<a href="#l18.180"></a><span id="l18.180">   nsCString serverKey;</span>
<a href="#l18.181"></a><span id="l18.181">   nsresult rv = GetKey(serverKey);</span>
<a href="#l18.182"></a><span id="l18.182" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l18.183"></a><span id="l18.183" class="difflineminus">-  {</span>
<a href="#l18.184"></a><span id="l18.184" class="difflineminus">-    nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession = do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.185"></a><span id="l18.185" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.186"></a><span id="l18.186" class="difflineplus">+    nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession =</span>
<a href="#l18.187"></a><span id="l18.187" class="difflineplus">+        do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.188"></a><span id="l18.188">     if (NS_SUCCEEDED(rv))</span>
<a href="#l18.189"></a><span id="l18.189" class="difflineminus">-      hostSession-&gt;SetOnlineDirForHost(serverKey.get(), PromiseFlatCString(serverDirectory).get());</span>
<a href="#l18.190"></a><span id="l18.190" class="difflineplus">+      hostSession-&gt;SetOnlineDirForHost(</span>
<a href="#l18.191"></a><span id="l18.191" class="difflineplus">+          serverKey.get(), PromiseFlatCString(serverDirectory).get());</span>
<a href="#l18.192"></a><span id="l18.192">   }</span>
<a href="#l18.193"></a><span id="l18.193">   return SetCharValue(&quot;server_sub_directory&quot;, serverDirectory);</span>
<a href="#l18.194"></a><span id="l18.194"> }</span>
<a href="#l18.195"></a><span id="l18.195"> </span>
<a href="#l18.196"></a><span id="l18.196"> NS_IMETHODIMP</span>
<a href="#l18.197"></a><span id="l18.197" class="difflineminus">-nsImapIncomingServer::GetOverrideNamespaces(bool *bVal)</span>
<a href="#l18.198"></a><span id="l18.198" class="difflineminus">-{</span>
<a href="#l18.199"></a><span id="l18.199" class="difflineplus">+nsImapIncomingServer::GetOverrideNamespaces(bool *bVal) {</span>
<a href="#l18.200"></a><span id="l18.200">   return GetBoolValue(&quot;override_namespaces&quot;, bVal);</span>
<a href="#l18.201"></a><span id="l18.201"> }</span>
<a href="#l18.202"></a><span id="l18.202"> </span>
<a href="#l18.203"></a><span id="l18.203"> NS_IMETHODIMP</span>
<a href="#l18.204"></a><span id="l18.204" class="difflineminus">-nsImapIncomingServer::SetOverrideNamespaces(bool bVal)</span>
<a href="#l18.205"></a><span id="l18.205" class="difflineminus">-{</span>
<a href="#l18.206"></a><span id="l18.206" class="difflineplus">+nsImapIncomingServer::SetOverrideNamespaces(bool bVal) {</span>
<a href="#l18.207"></a><span id="l18.207">   nsCString serverKey;</span>
<a href="#l18.208"></a><span id="l18.208">   GetKey(serverKey);</span>
<a href="#l18.209"></a><span id="l18.209" class="difflineminus">-  if (!serverKey.IsEmpty())</span>
<a href="#l18.210"></a><span id="l18.210" class="difflineminus">-  {</span>
<a href="#l18.211"></a><span id="l18.211" class="difflineplus">+  if (!serverKey.IsEmpty()) {</span>
<a href="#l18.212"></a><span id="l18.212">     nsresult rv;</span>
<a href="#l18.213"></a><span id="l18.213" class="difflineminus">-    nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession = do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.214"></a><span id="l18.214" class="difflineplus">+    nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession =</span>
<a href="#l18.215"></a><span id="l18.215" class="difflineplus">+        do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.216"></a><span id="l18.216">     if (NS_SUCCEEDED(rv))</span>
<a href="#l18.217"></a><span id="l18.217">       hostSession-&gt;SetNamespacesOverridableForHost(serverKey.get(), bVal);</span>
<a href="#l18.218"></a><span id="l18.218">   }</span>
<a href="#l18.219"></a><span id="l18.219">   return SetBoolValue(&quot;override_namespaces&quot;, bVal);</span>
<a href="#l18.220"></a><span id="l18.220"> }</span>
<a href="#l18.221"></a><span id="l18.221"> </span>
<a href="#l18.222"></a><span id="l18.222"> NS_IMETHODIMP</span>
<a href="#l18.223"></a><span id="l18.223" class="difflineminus">-nsImapIncomingServer::GetUsingSubscription(bool *bVal)</span>
<a href="#l18.224"></a><span id="l18.224" class="difflineminus">-{</span>
<a href="#l18.225"></a><span id="l18.225" class="difflineplus">+nsImapIncomingServer::GetUsingSubscription(bool *bVal) {</span>
<a href="#l18.226"></a><span id="l18.226">   return GetBoolValue(&quot;using_subscription&quot;, bVal);</span>
<a href="#l18.227"></a><span id="l18.227"> }</span>
<a href="#l18.228"></a><span id="l18.228"> </span>
<a href="#l18.229"></a><span id="l18.229"> NS_IMETHODIMP</span>
<a href="#l18.230"></a><span id="l18.230" class="difflineminus">-nsImapIncomingServer::SetUsingSubscription(bool bVal)</span>
<a href="#l18.231"></a><span id="l18.231" class="difflineminus">-{</span>
<a href="#l18.232"></a><span id="l18.232" class="difflineplus">+nsImapIncomingServer::SetUsingSubscription(bool bVal) {</span>
<a href="#l18.233"></a><span id="l18.233">   nsCString serverKey;</span>
<a href="#l18.234"></a><span id="l18.234">   GetKey(serverKey);</span>
<a href="#l18.235"></a><span id="l18.235" class="difflineminus">-  if (!serverKey.IsEmpty())</span>
<a href="#l18.236"></a><span id="l18.236" class="difflineminus">-  {</span>
<a href="#l18.237"></a><span id="l18.237" class="difflineplus">+  if (!serverKey.IsEmpty()) {</span>
<a href="#l18.238"></a><span id="l18.238">     nsresult rv;</span>
<a href="#l18.239"></a><span id="l18.239" class="difflineminus">-    nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession = do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.240"></a><span id="l18.240" class="difflineplus">+    nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession =</span>
<a href="#l18.241"></a><span id="l18.241" class="difflineplus">+        do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.242"></a><span id="l18.242">     if (NS_SUCCEEDED(rv))</span>
<a href="#l18.243"></a><span id="l18.243">       hostSession-&gt;SetHostIsUsingSubscription(serverKey.get(), bVal);</span>
<a href="#l18.244"></a><span id="l18.244">   }</span>
<a href="#l18.245"></a><span id="l18.245">   return SetBoolValue(&quot;using_subscription&quot;, bVal);</span>
<a href="#l18.246"></a><span id="l18.246"> }</span>
<a href="#l18.247"></a><span id="l18.247"> </span>
<a href="#l18.248"></a><span id="l18.248"> NS_IMETHODIMP</span>
<a href="#l18.249"></a><span id="l18.249" class="difflineminus">-nsImapIncomingServer::GetMaximumConnectionsNumber(int32_t *aMaxConnections)</span>
<a href="#l18.250"></a><span id="l18.250" class="difflineminus">-{</span>
<a href="#l18.251"></a><span id="l18.251" class="difflineplus">+nsImapIncomingServer::GetMaximumConnectionsNumber(int32_t *aMaxConnections) {</span>
<a href="#l18.252"></a><span id="l18.252">   NS_ENSURE_ARG_POINTER(aMaxConnections);</span>
<a href="#l18.253"></a><span id="l18.253"> </span>
<a href="#l18.254"></a><span id="l18.254">   nsresult rv = GetIntValue(&quot;max_cached_connections&quot;, aMaxConnections);</span>
<a href="#l18.255"></a><span id="l18.255">   // Get our maximum connection count. We need at least 1. If the value is 0,</span>
<a href="#l18.256"></a><span id="l18.256">   // we use the default of 5. If it's negative, we treat that as 1.</span>
<a href="#l18.257"></a><span id="l18.257" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; *aMaxConnections &gt; 0)</span>
<a href="#l18.258"></a><span id="l18.258" class="difflineminus">-    return NS_OK;</span>
<a href="#l18.259"></a><span id="l18.259" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; *aMaxConnections &gt; 0) return NS_OK;</span>
<a href="#l18.260"></a><span id="l18.260"> </span>
<a href="#l18.261"></a><span id="l18.261">   *aMaxConnections = (NS_FAILED(rv) || (*aMaxConnections == 0)) ? 5 : 1;</span>
<a href="#l18.262"></a><span id="l18.262">   (void)SetMaximumConnectionsNumber(*aMaxConnections);</span>
<a href="#l18.263"></a><span id="l18.263"> </span>
<a href="#l18.264"></a><span id="l18.264">   return NS_OK;</span>
<a href="#l18.265"></a><span id="l18.265"> }</span>
<a href="#l18.266"></a><span id="l18.266"> </span>
<a href="#l18.267"></a><span id="l18.267"> NS_IMETHODIMP</span>
<a href="#l18.268"></a><span id="l18.268" class="difflineminus">-nsImapIncomingServer::SetMaximumConnectionsNumber(int32_t aMaxConnections)</span>
<a href="#l18.269"></a><span id="l18.269" class="difflineminus">-{</span>
<a href="#l18.270"></a><span id="l18.270" class="difflineplus">+nsImapIncomingServer::SetMaximumConnectionsNumber(int32_t aMaxConnections) {</span>
<a href="#l18.271"></a><span id="l18.271">   return SetIntValue(&quot;max_cached_connections&quot;, aMaxConnections);</span>
<a href="#l18.272"></a><span id="l18.272"> }</span>
<a href="#l18.273"></a><span id="l18.273"> </span>
<a href="#l18.274"></a><span id="l18.274" class="difflineminus">-NS_IMPL_SERVERPREF_STR(nsImapIncomingServer, ForceSelect,</span>
<a href="#l18.275"></a><span id="l18.275" class="difflineminus">-                       &quot;force_select&quot;)</span>
<a href="#l18.276"></a><span id="l18.276" class="difflineplus">+NS_IMPL_SERVERPREF_STR(nsImapIncomingServer, ForceSelect, &quot;force_select&quot;)</span>
<a href="#l18.277"></a><span id="l18.277"> </span>
<a href="#l18.278"></a><span id="l18.278"> NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, DualUseFolders,</span>
<a href="#l18.279"></a><span id="l18.279">                         &quot;dual_use_folders&quot;)</span>
<a href="#l18.280"></a><span id="l18.280"> </span>
<a href="#l18.281"></a><span id="l18.281" class="difflineminus">-NS_IMPL_SERVERPREF_STR(nsImapIncomingServer, AdminUrl,</span>
<a href="#l18.282"></a><span id="l18.282" class="difflineminus">-                       &quot;admin_url&quot;)</span>
<a href="#l18.283"></a><span id="l18.283" class="difflineplus">+NS_IMPL_SERVERPREF_STR(nsImapIncomingServer, AdminUrl, &quot;admin_url&quot;)</span>
<a href="#l18.284"></a><span id="l18.284"> </span>
<a href="#l18.285"></a><span id="l18.285"> NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, CleanupInboxOnExit,</span>
<a href="#l18.286"></a><span id="l18.286">                         &quot;cleanup_inbox_on_exit&quot;)</span>
<a href="#l18.287"></a><span id="l18.287"> </span>
<a href="#l18.288"></a><span id="l18.288"> NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, OfflineDownload,</span>
<a href="#l18.289"></a><span id="l18.289">                         &quot;offline_download&quot;)</span>
<a href="#l18.290"></a><span id="l18.290"> </span>
<a href="#l18.291"></a><span id="l18.291"> NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, DownloadBodiesOnGetNewMail,</span>
<a href="#l18.292"></a><span id="l18.292">                         &quot;download_bodies_on_get_new_mail&quot;)</span>
<a href="#l18.293"></a><span id="l18.293"> </span>
<a href="#l18.294"></a><span id="l18.294"> NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, AutoSyncOfflineStores,</span>
<a href="#l18.295"></a><span id="l18.295">                         &quot;autosync_offline_stores&quot;)</span>
<a href="#l18.296"></a><span id="l18.296"> </span>
<a href="#l18.297"></a><span id="l18.297" class="difflineminus">-NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, UseIdle,</span>
<a href="#l18.298"></a><span id="l18.298" class="difflineminus">-                        &quot;use_idle&quot;)</span>
<a href="#l18.299"></a><span id="l18.299" class="difflineplus">+NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, UseIdle, &quot;use_idle&quot;)</span>
<a href="#l18.300"></a><span id="l18.300"> </span>
<a href="#l18.301"></a><span id="l18.301"> NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, CheckAllFoldersForNew,</span>
<a href="#l18.302"></a><span id="l18.302">                         &quot;check_all_folders_for_new&quot;)</span>
<a href="#l18.303"></a><span id="l18.303"> </span>
<a href="#l18.304"></a><span id="l18.304" class="difflineminus">-NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, UseCondStore,</span>
<a href="#l18.305"></a><span id="l18.305" class="difflineminus">-                        &quot;use_condstore&quot;)</span>
<a href="#l18.306"></a><span id="l18.306" class="difflineminus">-</span>
<a href="#l18.307"></a><span id="l18.307" class="difflineminus">-NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, IsGMailServer,</span>
<a href="#l18.308"></a><span id="l18.308" class="difflineminus">-                        &quot;is_gmail&quot;)</span>
<a href="#l18.309"></a><span id="l18.309" class="difflineplus">+NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, UseCondStore, &quot;use_condstore&quot;)</span>
<a href="#l18.310"></a><span id="l18.310" class="difflineplus">+</span>
<a href="#l18.311"></a><span id="l18.311" class="difflineplus">+NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, IsGMailServer, &quot;is_gmail&quot;)</span>
<a href="#l18.312"></a><span id="l18.312"> </span>
<a href="#l18.313"></a><span id="l18.313"> NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, UseCompressDeflate,</span>
<a href="#l18.314"></a><span id="l18.314">                         &quot;use_compress_deflate&quot;)</span>
<a href="#l18.315"></a><span id="l18.315"> </span>
<a href="#l18.316"></a><span id="l18.316"> NS_IMPL_SERVERPREF_INT(nsImapIncomingServer, AutoSyncMaxAgeDays,</span>
<a href="#l18.317"></a><span id="l18.317" class="difflineminus">-                        &quot;autosync_max_age_days&quot;)</span>
<a href="#l18.318"></a><span id="l18.318" class="difflineplus">+                       &quot;autosync_max_age_days&quot;)</span>
<a href="#l18.319"></a><span id="l18.319"> </span>
<a href="#l18.320"></a><span id="l18.320"> NS_IMETHODIMP</span>
<a href="#l18.321"></a><span id="l18.321" class="difflineminus">-nsImapIncomingServer::GetShuttingDown(bool *retval)</span>
<a href="#l18.322"></a><span id="l18.322" class="difflineminus">-{</span>
<a href="#l18.323"></a><span id="l18.323" class="difflineplus">+nsImapIncomingServer::GetShuttingDown(bool *retval) {</span>
<a href="#l18.324"></a><span id="l18.324">   NS_ENSURE_ARG_POINTER(retval);</span>
<a href="#l18.325"></a><span id="l18.325">   *retval = m_shuttingDown;</span>
<a href="#l18.326"></a><span id="l18.326">   return NS_OK;</span>
<a href="#l18.327"></a><span id="l18.327"> }</span>
<a href="#l18.328"></a><span id="l18.328"> </span>
<a href="#l18.329"></a><span id="l18.329"> NS_IMETHODIMP</span>
<a href="#l18.330"></a><span id="l18.330" class="difflineminus">-nsImapIncomingServer::SetShuttingDown(bool val)</span>
<a href="#l18.331"></a><span id="l18.331" class="difflineminus">-{</span>
<a href="#l18.332"></a><span id="l18.332" class="difflineplus">+nsImapIncomingServer::SetShuttingDown(bool val) {</span>
<a href="#l18.333"></a><span id="l18.333">   m_shuttingDown = val;</span>
<a href="#l18.334"></a><span id="l18.334">   return NS_OK;</span>
<a href="#l18.335"></a><span id="l18.335"> }</span>
<a href="#l18.336"></a><span id="l18.336"> </span>
<a href="#l18.337"></a><span id="l18.337"> NS_IMETHODIMP</span>
<a href="#l18.338"></a><span id="l18.338" class="difflineminus">-nsImapIncomingServer::GetDeleteModel(int32_t *retval)</span>
<a href="#l18.339"></a><span id="l18.339" class="difflineminus">-{</span>
<a href="#l18.340"></a><span id="l18.340" class="difflineplus">+nsImapIncomingServer::GetDeleteModel(int32_t *retval) {</span>
<a href="#l18.341"></a><span id="l18.341">   NS_ENSURE_ARG(retval);</span>
<a href="#l18.342"></a><span id="l18.342">   return GetIntValue(&quot;delete_model&quot;, retval);</span>
<a href="#l18.343"></a><span id="l18.343"> }</span>
<a href="#l18.344"></a><span id="l18.344"> </span>
<a href="#l18.345"></a><span id="l18.345"> NS_IMETHODIMP</span>
<a href="#l18.346"></a><span id="l18.346" class="difflineminus">-nsImapIncomingServer::SetDeleteModel(int32_t ivalue)</span>
<a href="#l18.347"></a><span id="l18.347" class="difflineminus">-{</span>
<a href="#l18.348"></a><span id="l18.348" class="difflineplus">+nsImapIncomingServer::SetDeleteModel(int32_t ivalue) {</span>
<a href="#l18.349"></a><span id="l18.349">   nsresult rv = SetIntValue(&quot;delete_model&quot;, ivalue);</span>
<a href="#l18.350"></a><span id="l18.350" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l18.351"></a><span id="l18.351" class="difflineminus">-  {</span>
<a href="#l18.352"></a><span id="l18.352" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.353"></a><span id="l18.353">     nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession =</span>
<a href="#l18.354"></a><span id="l18.354">         do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.355"></a><span id="l18.355" class="difflineminus">-    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.356"></a><span id="l18.356" class="difflineminus">-    hostSession-&gt;SetDeleteIsMoveToTrashForHost(m_serverKey.get(), ivalue == nsMsgImapDeleteModels::MoveToTrash);</span>
<a href="#l18.357"></a><span id="l18.357" class="difflineminus">-    hostSession-&gt;SetShowDeletedMessagesForHost(m_serverKey.get(), ivalue == nsMsgImapDeleteModels::IMAPDelete);</span>
<a href="#l18.358"></a><span id="l18.358" class="difflineminus">-</span>
<a href="#l18.359"></a><span id="l18.359" class="difflineminus">-    // Despite its name, this returns the trash folder path, for example INBOX/Trash.</span>
<a href="#l18.360"></a><span id="l18.360" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.361"></a><span id="l18.361" class="difflineplus">+    hostSession-&gt;SetDeleteIsMoveToTrashForHost(</span>
<a href="#l18.362"></a><span id="l18.362" class="difflineplus">+        m_serverKey.get(), ivalue == nsMsgImapDeleteModels::MoveToTrash);</span>
<a href="#l18.363"></a><span id="l18.363" class="difflineplus">+    hostSession-&gt;SetShowDeletedMessagesForHost(</span>
<a href="#l18.364"></a><span id="l18.364" class="difflineplus">+        m_serverKey.get(), ivalue == nsMsgImapDeleteModels::IMAPDelete);</span>
<a href="#l18.365"></a><span id="l18.365" class="difflineplus">+</span>
<a href="#l18.366"></a><span id="l18.366" class="difflineplus">+    // Despite its name, this returns the trash folder path, for example</span>
<a href="#l18.367"></a><span id="l18.367" class="difflineplus">+    // INBOX/Trash.</span>
<a href="#l18.368"></a><span id="l18.368">     nsAutoString trashFolderName;</span>
<a href="#l18.369"></a><span id="l18.369">     nsresult rv = GetTrashFolderName(trashFolderName);</span>
<a href="#l18.370"></a><span id="l18.370" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l18.371"></a><span id="l18.371" class="difflineminus">-    {</span>
<a href="#l18.372"></a><span id="l18.372" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.373"></a><span id="l18.373">       nsAutoCString trashFolderNameUtf7;</span>
<a href="#l18.374"></a><span id="l18.374">       rv = CopyUTF16toMUTF7(trashFolderName, trashFolderNameUtf7);</span>
<a href="#l18.375"></a><span id="l18.375" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l18.376"></a><span id="l18.376" class="difflineminus">-      {</span>
<a href="#l18.377"></a><span id="l18.377" class="difflineplus">+      if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.378"></a><span id="l18.378">         nsCOMPtr&lt;nsIMsgFolder&gt; trashFolder;</span>
<a href="#l18.379"></a><span id="l18.379">         // 'trashFolderName' being a path here works well since this is appended</span>
<a href="#l18.380"></a><span id="l18.380">         // to the server's root folder in GetFolder().</span>
<a href="#l18.381"></a><span id="l18.381">         rv = GetFolder(trashFolderNameUtf7, getter_AddRefs(trashFolder));</span>
<a href="#l18.382"></a><span id="l18.382">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.383"></a><span id="l18.383">         nsCString trashURI;</span>
<a href="#l18.384"></a><span id="l18.384">         trashFolder-&gt;GetURI(trashURI);</span>
<a href="#l18.385"></a><span id="l18.385">         GetMsgFolderFromURI(trashFolder, trashURI, getter_AddRefs(trashFolder));</span>
<a href="#l18.386"></a><span id="l18.386" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; trashFolder)</span>
<a href="#l18.387"></a><span id="l18.387" class="difflineminus">-        {</span>
<a href="#l18.388"></a><span id="l18.388" class="difflineminus">-           // If the trash folder is used, set the flag, otherwise clear it.</span>
<a href="#l18.389"></a><span id="l18.389" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; trashFolder) {</span>
<a href="#l18.390"></a><span id="l18.390" class="difflineplus">+          // If the trash folder is used, set the flag, otherwise clear it.</span>
<a href="#l18.391"></a><span id="l18.391">           if (ivalue == nsMsgImapDeleteModels::MoveToTrash)</span>
<a href="#l18.392"></a><span id="l18.392">             trashFolder-&gt;SetFlag(nsMsgFolderFlags::Trash);</span>
<a href="#l18.393"></a><span id="l18.393">           else</span>
<a href="#l18.394"></a><span id="l18.394">             trashFolder-&gt;ClearFlag(nsMsgFolderFlags::Trash);</span>
<a href="#l18.395"></a><span id="l18.395">         }</span>
<a href="#l18.396"></a><span id="l18.396">       }</span>
<a href="#l18.397"></a><span id="l18.397">     }</span>
<a href="#l18.398"></a><span id="l18.398">   }</span>
<a href="#l18.399"></a><span id="l18.399">   return rv;</span>
<a href="#l18.400"></a><span id="l18.400"> }</span>
<a href="#l18.401"></a><span id="l18.401"> </span>
<a href="#l18.402"></a><span id="l18.402" class="difflineminus">-NS_IMPL_SERVERPREF_INT(nsImapIncomingServer, TimeOutLimits,</span>
<a href="#l18.403"></a><span id="l18.403" class="difflineminus">-                       &quot;timeout&quot;)</span>
<a href="#l18.404"></a><span id="l18.404" class="difflineminus">-</span>
<a href="#l18.405"></a><span id="l18.405" class="difflineminus">-NS_IMPL_SERVERPREF_STR(nsImapIncomingServer, ServerIDPref,</span>
<a href="#l18.406"></a><span id="l18.406" class="difflineminus">-                       &quot;serverIDResponse&quot;)</span>
<a href="#l18.407"></a><span id="l18.407" class="difflineplus">+NS_IMPL_SERVERPREF_INT(nsImapIncomingServer, TimeOutLimits, &quot;timeout&quot;)</span>
<a href="#l18.408"></a><span id="l18.408" class="difflineplus">+</span>
<a href="#l18.409"></a><span id="l18.409" class="difflineplus">+NS_IMPL_SERVERPREF_STR(nsImapIncomingServer, ServerIDPref, &quot;serverIDResponse&quot;)</span>
<a href="#l18.410"></a><span id="l18.410"> </span>
<a href="#l18.411"></a><span id="l18.411"> NS_IMPL_SERVERPREF_STR(nsImapIncomingServer, PersonalNamespace,</span>
<a href="#l18.412"></a><span id="l18.412">                        &quot;namespace.personal&quot;)</span>
<a href="#l18.413"></a><span id="l18.413"> </span>
<a href="#l18.414"></a><span id="l18.414"> NS_IMPL_SERVERPREF_STR(nsImapIncomingServer, PublicNamespace,</span>
<a href="#l18.415"></a><span id="l18.415">                        &quot;namespace.public&quot;)</span>
<a href="#l18.416"></a><span id="l18.416"> </span>
<a href="#l18.417"></a><span id="l18.417"> NS_IMPL_SERVERPREF_STR(nsImapIncomingServer, OtherUsersNamespace,</span>
<a href="#l18.418"></a><span id="l18.418">                        &quot;namespace.other_users&quot;)</span>
<a href="#l18.419"></a><span id="l18.419"> </span>
<a href="#l18.420"></a><span id="l18.420" class="difflineminus">-NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, FetchByChunks,</span>
<a href="#l18.421"></a><span id="l18.421" class="difflineminus">-                       &quot;fetch_by_chunks&quot;)</span>
<a href="#l18.422"></a><span id="l18.422" class="difflineplus">+NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, FetchByChunks, &quot;fetch_by_chunks&quot;)</span>
<a href="#l18.423"></a><span id="l18.423"> </span>
<a href="#l18.424"></a><span id="l18.424"> NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, MimePartsOnDemand,</span>
<a href="#l18.425"></a><span id="l18.425" class="difflineminus">-                       &quot;mime_parts_on_demand&quot;)</span>
<a href="#l18.426"></a><span id="l18.426" class="difflineminus">-</span>
<a href="#l18.427"></a><span id="l18.427" class="difflineminus">-NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, SendID,</span>
<a href="#l18.428"></a><span id="l18.428" class="difflineminus">-                       &quot;send_client_info&quot;)</span>
<a href="#l18.429"></a><span id="l18.429" class="difflineminus">-</span>
<a href="#l18.430"></a><span id="l18.430" class="difflineminus">-NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, CapabilityACL,</span>
<a href="#l18.431"></a><span id="l18.431" class="difflineminus">-                       &quot;cacheCapa.acl&quot;)</span>
<a href="#l18.432"></a><span id="l18.432" class="difflineplus">+                        &quot;mime_parts_on_demand&quot;)</span>
<a href="#l18.433"></a><span id="l18.433" class="difflineplus">+</span>
<a href="#l18.434"></a><span id="l18.434" class="difflineplus">+NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, SendID, &quot;send_client_info&quot;)</span>
<a href="#l18.435"></a><span id="l18.435" class="difflineplus">+</span>
<a href="#l18.436"></a><span id="l18.436" class="difflineplus">+NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, CapabilityACL, &quot;cacheCapa.acl&quot;)</span>
<a href="#l18.437"></a><span id="l18.437"> NS_IMPL_SERVERPREF_BOOL(nsImapIncomingServer, CapabilityQuota,</span>
<a href="#l18.438"></a><span id="l18.438" class="difflineminus">-                       &quot;cacheCapa.quota&quot;)</span>
<a href="#l18.439"></a><span id="l18.439" class="difflineplus">+                        &quot;cacheCapa.quota&quot;)</span>
<a href="#l18.440"></a><span id="l18.440"> </span>
<a href="#l18.441"></a><span id="l18.441"> NS_IMETHODIMP</span>
<a href="#l18.442"></a><span id="l18.442" class="difflineminus">-nsImapIncomingServer::GetIsAOLServer(bool *aBool)</span>
<a href="#l18.443"></a><span id="l18.443" class="difflineminus">-{</span>
<a href="#l18.444"></a><span id="l18.444" class="difflineplus">+nsImapIncomingServer::GetIsAOLServer(bool *aBool) {</span>
<a href="#l18.445"></a><span id="l18.445">   NS_ENSURE_ARG_POINTER(aBool);</span>
<a href="#l18.446"></a><span id="l18.446">   *aBool = ((m_capability &amp; kAOLImapCapability) != 0);</span>
<a href="#l18.447"></a><span id="l18.447">   return NS_OK;</span>
<a href="#l18.448"></a><span id="l18.448"> }</span>
<a href="#l18.449"></a><span id="l18.449"> </span>
<a href="#l18.450"></a><span id="l18.450"> NS_IMETHODIMP</span>
<a href="#l18.451"></a><span id="l18.451" class="difflineminus">-nsImapIncomingServer::SetIsAOLServer(bool aBool)</span>
<a href="#l18.452"></a><span id="l18.452" class="difflineminus">-{</span>
<a href="#l18.453"></a><span id="l18.453" class="difflineplus">+nsImapIncomingServer::SetIsAOLServer(bool aBool) {</span>
<a href="#l18.454"></a><span id="l18.454">   if (aBool)</span>
<a href="#l18.455"></a><span id="l18.455">     m_capability |= kAOLImapCapability;</span>
<a href="#l18.456"></a><span id="l18.456">   else</span>
<a href="#l18.457"></a><span id="l18.457">     m_capability &amp;= ~kAOLImapCapability;</span>
<a href="#l18.458"></a><span id="l18.458">   return NS_OK;</span>
<a href="#l18.459"></a><span id="l18.459"> }</span>
<a href="#l18.460"></a><span id="l18.460"> </span>
<a href="#l18.461"></a><span id="l18.461"> NS_IMETHODIMP</span>
<a href="#l18.462"></a><span id="l18.462" class="difflineminus">-nsImapIncomingServer::UpdateTrySTARTTLSPref(bool aStartTLSSucceeded)</span>
<a href="#l18.463"></a><span id="l18.463" class="difflineminus">-{</span>
<a href="#l18.464"></a><span id="l18.464" class="difflineminus">-  SetSocketType(aStartTLSSucceeded ? nsMsgSocketType::alwaysSTARTTLS :</span>
<a href="#l18.465"></a><span id="l18.465" class="difflineminus">-                                     nsMsgSocketType::plain);</span>
<a href="#l18.466"></a><span id="l18.466" class="difflineplus">+nsImapIncomingServer::UpdateTrySTARTTLSPref(bool aStartTLSSucceeded) {</span>
<a href="#l18.467"></a><span id="l18.467" class="difflineplus">+  SetSocketType(aStartTLSSucceeded ? nsMsgSocketType::alwaysSTARTTLS</span>
<a href="#l18.468"></a><span id="l18.468" class="difflineplus">+                                   : nsMsgSocketType::plain);</span>
<a href="#l18.469"></a><span id="l18.469">   return NS_OK;</span>
<a href="#l18.470"></a><span id="l18.470"> }</span>
<a href="#l18.471"></a><span id="l18.471"> </span>
<a href="#l18.472"></a><span id="l18.472"> NS_IMETHODIMP</span>
<a href="#l18.473"></a><span id="l18.473" class="difflineminus">-nsImapIncomingServer::GetImapConnectionAndLoadUrl(nsIImapUrl* aImapUrl,</span>
<a href="#l18.474"></a><span id="l18.474" class="difflineminus">-                                                  nsISupports* aConsumer)</span>
<a href="#l18.475"></a><span id="l18.475" class="difflineminus">-{</span>
<a href="#l18.476"></a><span id="l18.476" class="difflineplus">+nsImapIncomingServer::GetImapConnectionAndLoadUrl(nsIImapUrl *aImapUrl,</span>
<a href="#l18.477"></a><span id="l18.477" class="difflineplus">+                                                  nsISupports *aConsumer) {</span>
<a href="#l18.478"></a><span id="l18.478">   nsCOMPtr&lt;nsIImapProtocol&gt; aProtocol;</span>
<a href="#l18.479"></a><span id="l18.479"> </span>
<a href="#l18.480"></a><span id="l18.480">   nsresult rv = GetImapConnection(aImapUrl, getter_AddRefs(aProtocol));</span>
<a href="#l18.481"></a><span id="l18.481">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.482"></a><span id="l18.482"> </span>
<a href="#l18.483"></a><span id="l18.483">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsurl = do_QueryInterface(aImapUrl, &amp;rv);</span>
<a href="#l18.484"></a><span id="l18.484" class="difflineminus">-  if (aProtocol)</span>
<a href="#l18.485"></a><span id="l18.485" class="difflineminus">-  {</span>
<a href="#l18.486"></a><span id="l18.486" class="difflineplus">+  if (aProtocol) {</span>
<a href="#l18.487"></a><span id="l18.487">     rv = aProtocol-&gt;LoadImapUrl(mailnewsurl, aConsumer);</span>
<a href="#l18.488"></a><span id="l18.488">     // *** jt - in case of the time out situation or the connection gets</span>
<a href="#l18.489"></a><span id="l18.489">     // terminated by some unforeseen problems let's give it a second chance</span>
<a href="#l18.490"></a><span id="l18.490">     // to run the url</span>
<a href="#l18.491"></a><span id="l18.491" class="difflineminus">-    if (NS_FAILED(rv) &amp;&amp; rv != NS_ERROR_ILLEGAL_VALUE)</span>
<a href="#l18.492"></a><span id="l18.492" class="difflineminus">-    {</span>
<a href="#l18.493"></a><span id="l18.493" class="difflineplus">+    if (NS_FAILED(rv) &amp;&amp; rv != NS_ERROR_ILLEGAL_VALUE) {</span>
<a href="#l18.494"></a><span id="l18.494">       NS_ASSERTION(false, &quot;shouldn't get an error loading url&quot;);</span>
<a href="#l18.495"></a><span id="l18.495">       rv = aProtocol-&gt;LoadImapUrl(mailnewsurl, aConsumer);</span>
<a href="#l18.496"></a><span id="l18.496">     }</span>
<a href="#l18.497"></a><span id="l18.497" class="difflineminus">-  }</span>
<a href="#l18.498"></a><span id="l18.498" class="difflineminus">-  else</span>
<a href="#l18.499"></a><span id="l18.499" class="difflineminus">-  {   // unable to get an imap connection to run the url; add to the url</span>
<a href="#l18.500"></a><span id="l18.500" class="difflineminus">-     // queue</span>
<a href="#l18.501"></a><span id="l18.501" class="difflineplus">+  } else {  // unable to get an imap connection to run the url; add to the url</span>
<a href="#l18.502"></a><span id="l18.502" class="difflineplus">+            // queue</span>
<a href="#l18.503"></a><span id="l18.503">     nsImapProtocol::LogImapUrl(&quot;queuing url&quot;, aImapUrl);</span>
<a href="#l18.504"></a><span id="l18.504">     PR_CEnterMonitor(this);</span>
<a href="#l18.505"></a><span id="l18.505">     m_urlQueue.AppendObject(aImapUrl);</span>
<a href="#l18.506"></a><span id="l18.506">     m_urlConsumers.AppendElement(aConsumer);</span>
<a href="#l18.507"></a><span id="l18.507">     NS_IF_ADDREF(aConsumer);</span>
<a href="#l18.508"></a><span id="l18.508">     PR_CExitMonitor(this);</span>
<a href="#l18.509"></a><span id="l18.509">     // let's try running it now - maybe the connection is free now.</span>
<a href="#l18.510"></a><span id="l18.510">     bool urlRun;</span>
<a href="#l18.511"></a><span id="l18.511">     rv = LoadNextQueuedUrl(nullptr, &amp;urlRun);</span>
<a href="#l18.512"></a><span id="l18.512">   }</span>
<a href="#l18.513"></a><span id="l18.513"> </span>
<a href="#l18.514"></a><span id="l18.514">   return rv;</span>
<a href="#l18.515"></a><span id="l18.515"> }</span>
<a href="#l18.516"></a><span id="l18.516"> </span>
<a href="#l18.517"></a><span id="l18.517" class="difflineminus">-</span>
<a href="#l18.518"></a><span id="l18.518"> NS_IMETHODIMP</span>
<a href="#l18.519"></a><span id="l18.519" class="difflineminus">-nsImapIncomingServer::PrepareToRetryUrl(nsIImapUrl *aImapUrl, nsIImapMockChannel **aChannel)</span>
<a href="#l18.520"></a><span id="l18.520" class="difflineminus">-{</span>
<a href="#l18.521"></a><span id="l18.521" class="difflineplus">+nsImapIncomingServer::PrepareToRetryUrl(nsIImapUrl *aImapUrl,</span>
<a href="#l18.522"></a><span id="l18.522" class="difflineplus">+                                        nsIImapMockChannel **aChannel) {</span>
<a href="#l18.523"></a><span id="l18.523">   NS_ENSURE_ARG_POINTER(aChannel);</span>
<a href="#l18.524"></a><span id="l18.524">   NS_ENSURE_ARG_POINTER(aImapUrl);</span>
<a href="#l18.525"></a><span id="l18.525">   // maybe there's more we could do here, but this is all we need now.</span>
<a href="#l18.526"></a><span id="l18.526">   return aImapUrl-&gt;GetMockChannel(aChannel);</span>
<a href="#l18.527"></a><span id="l18.527"> }</span>
<a href="#l18.528"></a><span id="l18.528"> </span>
<a href="#l18.529"></a><span id="l18.529"> NS_IMETHODIMP</span>
<a href="#l18.530"></a><span id="l18.530" class="difflineminus">-nsImapIncomingServer::SuspendUrl(nsIImapUrl *aImapUrl)</span>
<a href="#l18.531"></a><span id="l18.531" class="difflineminus">-{</span>
<a href="#l18.532"></a><span id="l18.532" class="difflineplus">+nsImapIncomingServer::SuspendUrl(nsIImapUrl *aImapUrl) {</span>
<a href="#l18.533"></a><span id="l18.533">   NS_ENSURE_ARG_POINTER(aImapUrl);</span>
<a href="#l18.534"></a><span id="l18.534">   nsImapProtocol::LogImapUrl(&quot;suspending url&quot;, aImapUrl);</span>
<a href="#l18.535"></a><span id="l18.535">   PR_CEnterMonitor(this);</span>
<a href="#l18.536"></a><span id="l18.536">   m_urlQueue.AppendObject(aImapUrl);</span>
<a href="#l18.537"></a><span id="l18.537">   m_urlConsumers.AppendElement(nullptr);</span>
<a href="#l18.538"></a><span id="l18.538">   PR_CExitMonitor(this);</span>
<a href="#l18.539"></a><span id="l18.539">   return NS_OK;</span>
<a href="#l18.540"></a><span id="l18.540"> }</span>
<a href="#l18.541"></a><span id="l18.541"> </span>
<a href="#l18.542"></a><span id="l18.542"> NS_IMETHODIMP</span>
<a href="#l18.543"></a><span id="l18.543" class="difflineminus">-nsImapIncomingServer::RetryUrl(nsIImapUrl *aImapUrl, nsIImapMockChannel *aChannel)</span>
<a href="#l18.544"></a><span id="l18.544" class="difflineminus">-{</span>
<a href="#l18.545"></a><span id="l18.545" class="difflineplus">+nsImapIncomingServer::RetryUrl(nsIImapUrl *aImapUrl,</span>
<a href="#l18.546"></a><span id="l18.546" class="difflineplus">+                               nsIImapMockChannel *aChannel) {</span>
<a href="#l18.547"></a><span id="l18.547">   nsresult rv;</span>
<a href="#l18.548"></a><span id="l18.548">   // Get current thread envent queue</span>
<a href="#l18.549"></a><span id="l18.549">   aImapUrl-&gt;SetMockChannel(aChannel);</span>
<a href="#l18.550"></a><span id="l18.550" class="difflineminus">-  nsCOMPtr &lt;nsIImapProtocol&gt; protocolInstance;</span>
<a href="#l18.551"></a><span id="l18.551" class="difflineminus">-  nsImapProtocol::LogImapUrl(&quot;creating protocol instance to retry queued url&quot;, aImapUrl);</span>
<a href="#l18.552"></a><span id="l18.552" class="difflineplus">+  nsCOMPtr&lt;nsIImapProtocol&gt; protocolInstance;</span>
<a href="#l18.553"></a><span id="l18.553" class="difflineplus">+  nsImapProtocol::LogImapUrl(&quot;creating protocol instance to retry queued url&quot;,</span>
<a href="#l18.554"></a><span id="l18.554" class="difflineplus">+                             aImapUrl);</span>
<a href="#l18.555"></a><span id="l18.555">   nsCOMPtr&lt;nsIThread&gt; thread(do_GetCurrentThread());</span>
<a href="#l18.556"></a><span id="l18.556">   rv = GetImapConnection(aImapUrl, getter_AddRefs(protocolInstance));</span>
<a href="#l18.557"></a><span id="l18.557" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; protocolInstance)</span>
<a href="#l18.558"></a><span id="l18.558" class="difflineminus">-  {</span>
<a href="#l18.559"></a><span id="l18.559" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; protocolInstance) {</span>
<a href="#l18.560"></a><span id="l18.560">     nsCOMPtr&lt;nsIURI&gt; url = do_QueryInterface(aImapUrl, &amp;rv);</span>
<a href="#l18.561"></a><span id="l18.561" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; url)</span>
<a href="#l18.562"></a><span id="l18.562" class="difflineminus">-    {</span>
<a href="#l18.563"></a><span id="l18.563" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; url) {</span>
<a href="#l18.564"></a><span id="l18.564">       nsImapProtocol::LogImapUrl(&quot;retrying  url&quot;, aImapUrl);</span>
<a href="#l18.565"></a><span id="l18.565" class="difflineminus">-      rv = protocolInstance-&gt;LoadImapUrl(url, nullptr); // ### need to save the display consumer.</span>
<a href="#l18.566"></a><span id="l18.566" class="difflineplus">+      rv = protocolInstance-&gt;LoadImapUrl(</span>
<a href="#l18.567"></a><span id="l18.567" class="difflineplus">+          url, nullptr);  // ### need to save the display consumer.</span>
<a href="#l18.568"></a><span id="l18.568">       NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed running queued url&quot;);</span>
<a href="#l18.569"></a><span id="l18.569">     }</span>
<a href="#l18.570"></a><span id="l18.570">   }</span>
<a href="#l18.571"></a><span id="l18.571">   return rv;</span>
<a href="#l18.572"></a><span id="l18.572"> }</span>
<a href="#l18.573"></a><span id="l18.573"> </span>
<a href="#l18.574"></a><span id="l18.574"> // checks to see if there are any queued urls on this incoming server,</span>
<a href="#l18.575"></a><span id="l18.575"> // and if so, tries to run the oldest one. Returns true if the url is run</span>
<a href="#l18.576"></a><span id="l18.576"> // on the passed in protocol connection.</span>
<a href="#l18.577"></a><span id="l18.577"> NS_IMETHODIMP</span>
<a href="#l18.578"></a><span id="l18.578" class="difflineminus">-nsImapIncomingServer::LoadNextQueuedUrl(nsIImapProtocol *aProtocol, bool *aResult)</span>
<a href="#l18.579"></a><span id="l18.579" class="difflineminus">-{</span>
<a href="#l18.580"></a><span id="l18.580" class="difflineminus">-  if (WeAreOffline())</span>
<a href="#l18.581"></a><span id="l18.581" class="difflineminus">-    return NS_MSG_ERROR_OFFLINE;</span>
<a href="#l18.582"></a><span id="l18.582" class="difflineplus">+nsImapIncomingServer::LoadNextQueuedUrl(nsIImapProtocol *aProtocol,</span>
<a href="#l18.583"></a><span id="l18.583" class="difflineplus">+                                        bool *aResult) {</span>
<a href="#l18.584"></a><span id="l18.584" class="difflineplus">+  if (WeAreOffline()) return NS_MSG_ERROR_OFFLINE;</span>
<a href="#l18.585"></a><span id="l18.585"> </span>
<a href="#l18.586"></a><span id="l18.586">   nsresult rv = NS_OK;</span>
<a href="#l18.587"></a><span id="l18.587">   bool urlRun = false;</span>
<a href="#l18.588"></a><span id="l18.588">   bool keepGoing = true;</span>
<a href="#l18.589"></a><span id="l18.589" class="difflineminus">-  nsCOMPtr &lt;nsIImapProtocol&gt;  protocolInstance ;</span>
<a href="#l18.590"></a><span id="l18.590" class="difflineplus">+  nsCOMPtr&lt;nsIImapProtocol&gt; protocolInstance;</span>
<a href="#l18.591"></a><span id="l18.591"> </span>
<a href="#l18.592"></a><span id="l18.592">   MutexAutoLock mon(mLock);</span>
<a href="#l18.593"></a><span id="l18.593">   int32_t cnt = m_urlQueue.Count();</span>
<a href="#l18.594"></a><span id="l18.594"> </span>
<a href="#l18.595"></a><span id="l18.595" class="difflineminus">-  while (cnt &gt; 0 &amp;&amp; !urlRun &amp;&amp; keepGoing)</span>
<a href="#l18.596"></a><span id="l18.596" class="difflineminus">-  {</span>
<a href="#l18.597"></a><span id="l18.597" class="difflineplus">+  while (cnt &gt; 0 &amp;&amp; !urlRun &amp;&amp; keepGoing) {</span>
<a href="#l18.598"></a><span id="l18.598">     nsCOMPtr&lt;nsIImapUrl&gt; aImapUrl(m_urlQueue[0]);</span>
<a href="#l18.599"></a><span id="l18.599"> </span>
<a href="#l18.600"></a><span id="l18.600">     bool removeUrlFromQueue = false;</span>
<a href="#l18.601"></a><span id="l18.601" class="difflineminus">-    if (aImapUrl)</span>
<a href="#l18.602"></a><span id="l18.602" class="difflineminus">-    {</span>
<a href="#l18.603"></a><span id="l18.603" class="difflineplus">+    if (aImapUrl) {</span>
<a href="#l18.604"></a><span id="l18.604">       nsImapProtocol::LogImapUrl(&quot;considering playing queued url&quot;, aImapUrl);</span>
<a href="#l18.605"></a><span id="l18.605">       rv = DoomUrlIfChannelHasError(aImapUrl, &amp;removeUrlFromQueue);</span>
<a href="#l18.606"></a><span id="l18.606">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.607"></a><span id="l18.607">       // if we didn't doom the url, lets run it.</span>
<a href="#l18.608"></a><span id="l18.608" class="difflineminus">-      if (!removeUrlFromQueue)</span>
<a href="#l18.609"></a><span id="l18.609" class="difflineminus">-      {</span>
<a href="#l18.610"></a><span id="l18.610" class="difflineplus">+      if (!removeUrlFromQueue) {</span>
<a href="#l18.611"></a><span id="l18.611">         nsISupports *aConsumer = m_urlConsumers.ElementAt(0);</span>
<a href="#l18.612"></a><span id="l18.612">         NS_IF_ADDREF(aConsumer);</span>
<a href="#l18.613"></a><span id="l18.613"> </span>
<a href="#l18.614"></a><span id="l18.614" class="difflineminus">-        nsImapProtocol::LogImapUrl(&quot;creating protocol instance to play queued url&quot;, aImapUrl);</span>
<a href="#l18.615"></a><span id="l18.615" class="difflineplus">+        nsImapProtocol::LogImapUrl(</span>
<a href="#l18.616"></a><span id="l18.616" class="difflineplus">+            &quot;creating protocol instance to play queued url&quot;, aImapUrl);</span>
<a href="#l18.617"></a><span id="l18.617">         rv = GetImapConnection(aImapUrl, getter_AddRefs(protocolInstance));</span>
<a href="#l18.618"></a><span id="l18.618" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; protocolInstance)</span>
<a href="#l18.619"></a><span id="l18.619" class="difflineminus">-        {</span>
<a href="#l18.620"></a><span id="l18.620" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; protocolInstance) {</span>
<a href="#l18.621"></a><span id="l18.621">           nsCOMPtr&lt;nsIURI&gt; url = do_QueryInterface(aImapUrl, &amp;rv);</span>
<a href="#l18.622"></a><span id="l18.622" class="difflineminus">-          if (NS_SUCCEEDED(rv) &amp;&amp; url)</span>
<a href="#l18.623"></a><span id="l18.623" class="difflineminus">-          {</span>
<a href="#l18.624"></a><span id="l18.624" class="difflineplus">+          if (NS_SUCCEEDED(rv) &amp;&amp; url) {</span>
<a href="#l18.625"></a><span id="l18.625">             nsImapProtocol::LogImapUrl(&quot;playing queued url&quot;, aImapUrl);</span>
<a href="#l18.626"></a><span id="l18.626">             rv = protocolInstance-&gt;LoadImapUrl(url, aConsumer);</span>
<a href="#l18.627"></a><span id="l18.627">             NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed running queued url&quot;);</span>
<a href="#l18.628"></a><span id="l18.628">             bool isInbox;</span>
<a href="#l18.629"></a><span id="l18.629">             protocolInstance-&gt;IsBusy(&amp;urlRun, &amp;isInbox);</span>
<a href="#l18.630"></a><span id="l18.630">             if (!urlRun)</span>
<a href="#l18.631"></a><span id="l18.631">               nsImapProtocol::LogImapUrl(&quot;didn't need to run&quot;, aImapUrl);</span>
<a href="#l18.632"></a><span id="l18.632">             removeUrlFromQueue = true;</span>
<a href="#l18.633"></a><span id="l18.633">           }</span>
<a href="#l18.634"></a><span id="l18.634" class="difflineminus">-        }</span>
<a href="#l18.635"></a><span id="l18.635" class="difflineminus">-        else</span>
<a href="#l18.636"></a><span id="l18.636" class="difflineminus">-        {</span>
<a href="#l18.637"></a><span id="l18.637" class="difflineminus">-          nsImapProtocol::LogImapUrl(&quot;failed creating protocol instance to play queued url&quot;, aImapUrl);</span>
<a href="#l18.638"></a><span id="l18.638" class="difflineplus">+        } else {</span>
<a href="#l18.639"></a><span id="l18.639" class="difflineplus">+          nsImapProtocol::LogImapUrl(</span>
<a href="#l18.640"></a><span id="l18.640" class="difflineplus">+              &quot;failed creating protocol instance to play queued url&quot;, aImapUrl);</span>
<a href="#l18.641"></a><span id="l18.641">           keepGoing = false;</span>
<a href="#l18.642"></a><span id="l18.642">         }</span>
<a href="#l18.643"></a><span id="l18.643">         NS_IF_RELEASE(aConsumer);</span>
<a href="#l18.644"></a><span id="l18.644">       }</span>
<a href="#l18.645"></a><span id="l18.645" class="difflineminus">-      if (removeUrlFromQueue)</span>
<a href="#l18.646"></a><span id="l18.646" class="difflineminus">-      {</span>
<a href="#l18.647"></a><span id="l18.647" class="difflineplus">+      if (removeUrlFromQueue) {</span>
<a href="#l18.648"></a><span id="l18.648">         m_urlQueue.RemoveObjectAt(0);</span>
<a href="#l18.649"></a><span id="l18.649">         m_urlConsumers.RemoveElementAt(0);</span>
<a href="#l18.650"></a><span id="l18.650">       }</span>
<a href="#l18.651"></a><span id="l18.651">     }</span>
<a href="#l18.652"></a><span id="l18.652">     cnt = m_urlQueue.Count();</span>
<a href="#l18.653"></a><span id="l18.653">   }</span>
<a href="#l18.654"></a><span id="l18.654" class="difflineminus">-  if (aResult)</span>
<a href="#l18.655"></a><span id="l18.655" class="difflineminus">-    *aResult = urlRun &amp;&amp; aProtocol &amp;&amp; aProtocol == protocolInstance;</span>
<a href="#l18.656"></a><span id="l18.656" class="difflineplus">+  if (aResult) *aResult = urlRun &amp;&amp; aProtocol &amp;&amp; aProtocol == protocolInstance;</span>
<a href="#l18.657"></a><span id="l18.657"> </span>
<a href="#l18.658"></a><span id="l18.658">   return rv;</span>
<a href="#l18.659"></a><span id="l18.659"> }</span>
<a href="#l18.660"></a><span id="l18.660"> </span>
<a href="#l18.661"></a><span id="l18.661"> NS_IMETHODIMP</span>
<a href="#l18.662"></a><span id="l18.662" class="difflineminus">-nsImapIncomingServer::AbortQueuedUrls()</span>
<a href="#l18.663"></a><span id="l18.663" class="difflineminus">-{</span>
<a href="#l18.664"></a><span id="l18.664" class="difflineplus">+nsImapIncomingServer::AbortQueuedUrls() {</span>
<a href="#l18.665"></a><span id="l18.665">   nsresult rv = NS_OK;</span>
<a href="#l18.666"></a><span id="l18.666"> </span>
<a href="#l18.667"></a><span id="l18.667">   MutexAutoLock mon(mLock);</span>
<a href="#l18.668"></a><span id="l18.668">   int32_t cnt = m_urlQueue.Count();</span>
<a href="#l18.669"></a><span id="l18.669"> </span>
<a href="#l18.670"></a><span id="l18.670" class="difflineminus">-  while (cnt &gt; 0)</span>
<a href="#l18.671"></a><span id="l18.671" class="difflineminus">-  {</span>
<a href="#l18.672"></a><span id="l18.672" class="difflineplus">+  while (cnt &gt; 0) {</span>
<a href="#l18.673"></a><span id="l18.673">     nsCOMPtr&lt;nsIImapUrl&gt; aImapUrl(m_urlQueue[cnt - 1]);</span>
<a href="#l18.674"></a><span id="l18.674">     bool removeUrlFromQueue = false;</span>
<a href="#l18.675"></a><span id="l18.675"> </span>
<a href="#l18.676"></a><span id="l18.676" class="difflineminus">-    if (aImapUrl)</span>
<a href="#l18.677"></a><span id="l18.677" class="difflineminus">-    {</span>
<a href="#l18.678"></a><span id="l18.678" class="difflineplus">+    if (aImapUrl) {</span>
<a href="#l18.679"></a><span id="l18.679">       rv = DoomUrlIfChannelHasError(aImapUrl, &amp;removeUrlFromQueue);</span>
<a href="#l18.680"></a><span id="l18.680">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.681"></a><span id="l18.681" class="difflineminus">-      if (removeUrlFromQueue)</span>
<a href="#l18.682"></a><span id="l18.682" class="difflineminus">-      {</span>
<a href="#l18.683"></a><span id="l18.683" class="difflineplus">+      if (removeUrlFromQueue) {</span>
<a href="#l18.684"></a><span id="l18.684">         m_urlQueue.RemoveObjectAt(cnt - 1);</span>
<a href="#l18.685"></a><span id="l18.685">         m_urlConsumers.RemoveElementAt(cnt - 1);</span>
<a href="#l18.686"></a><span id="l18.686">       }</span>
<a href="#l18.687"></a><span id="l18.687">     }</span>
<a href="#l18.688"></a><span id="l18.688">     cnt--;</span>
<a href="#l18.689"></a><span id="l18.689">   }</span>
<a href="#l18.690"></a><span id="l18.690"> </span>
<a href="#l18.691"></a><span id="l18.691">   return rv;</span>
<a href="#l18.692"></a><span id="l18.692"> }</span>
<a href="#l18.693"></a><span id="l18.693"> </span>
<a href="#l18.694"></a><span id="l18.694"> // if this url has a channel with an error, doom it and its mem cache entries,</span>
<a href="#l18.695"></a><span id="l18.695"> // and notify url listeners.</span>
<a href="#l18.696"></a><span id="l18.696" class="difflineminus">-nsresult nsImapIncomingServer::DoomUrlIfChannelHasError(nsIImapUrl *aImapUrl, bool *urlDoomed)</span>
<a href="#l18.697"></a><span id="l18.697" class="difflineminus">-{</span>
<a href="#l18.698"></a><span id="l18.698" class="difflineplus">+nsresult nsImapIncomingServer::DoomUrlIfChannelHasError(nsIImapUrl *aImapUrl,</span>
<a href="#l18.699"></a><span id="l18.699" class="difflineplus">+                                                        bool *urlDoomed) {</span>
<a href="#l18.700"></a><span id="l18.700">   nsresult rv = NS_OK;</span>
<a href="#l18.701"></a><span id="l18.701"> </span>
<a href="#l18.702"></a><span id="l18.702">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; aMailNewsUrl(do_QueryInterface(aImapUrl, &amp;rv));</span>
<a href="#l18.703"></a><span id="l18.703"> </span>
<a href="#l18.704"></a><span id="l18.704" class="difflineminus">-  if (aMailNewsUrl &amp;&amp; aImapUrl)</span>
<a href="#l18.705"></a><span id="l18.705" class="difflineminus">-  {</span>
<a href="#l18.706"></a><span id="l18.706" class="difflineminus">-    nsCOMPtr &lt;nsIImapMockChannel&gt; mockChannel;</span>
<a href="#l18.707"></a><span id="l18.707" class="difflineminus">-</span>
<a href="#l18.708"></a><span id="l18.708" class="difflineminus">-    if (NS_SUCCEEDED(aImapUrl-&gt;GetMockChannel(getter_AddRefs(mockChannel))) &amp;&amp; mockChannel)</span>
<a href="#l18.709"></a><span id="l18.709" class="difflineminus">-    {</span>
<a href="#l18.710"></a><span id="l18.710" class="difflineplus">+  if (aMailNewsUrl &amp;&amp; aImapUrl) {</span>
<a href="#l18.711"></a><span id="l18.711" class="difflineplus">+    nsCOMPtr&lt;nsIImapMockChannel&gt; mockChannel;</span>
<a href="#l18.712"></a><span id="l18.712" class="difflineplus">+</span>
<a href="#l18.713"></a><span id="l18.713" class="difflineplus">+    if (NS_SUCCEEDED(aImapUrl-&gt;GetMockChannel(getter_AddRefs(mockChannel))) &amp;&amp;</span>
<a href="#l18.714"></a><span id="l18.714" class="difflineplus">+        mockChannel) {</span>
<a href="#l18.715"></a><span id="l18.715">       nsresult requestStatus;</span>
<a href="#l18.716"></a><span id="l18.716">       mockChannel-&gt;GetStatus(&amp;requestStatus);</span>
<a href="#l18.717"></a><span id="l18.717" class="difflineminus">-      if (NS_FAILED(requestStatus))</span>
<a href="#l18.718"></a><span id="l18.718" class="difflineminus">-      {</span>
<a href="#l18.719"></a><span id="l18.719" class="difflineplus">+      if (NS_FAILED(requestStatus)) {</span>
<a href="#l18.720"></a><span id="l18.720">         nsresult res;</span>
<a href="#l18.721"></a><span id="l18.721">         *urlDoomed = true;</span>
<a href="#l18.722"></a><span id="l18.722">         nsImapProtocol::LogImapUrl(&quot;dooming url&quot;, aImapUrl);</span>
<a href="#l18.723"></a><span id="l18.723"> </span>
<a href="#l18.724"></a><span id="l18.724" class="difflineminus">-        mockChannel-&gt;Close(); // try closing it to get channel listener nulled out.</span>
<a href="#l18.725"></a><span id="l18.725" class="difflineminus">-</span>
<a href="#l18.726"></a><span id="l18.726" class="difflineminus">-        if (aMailNewsUrl)</span>
<a href="#l18.727"></a><span id="l18.727" class="difflineminus">-        {</span>
<a href="#l18.728"></a><span id="l18.728" class="difflineplus">+        mockChannel</span>
<a href="#l18.729"></a><span id="l18.729" class="difflineplus">+            -&gt;Close();  // try closing it to get channel listener nulled out.</span>
<a href="#l18.730"></a><span id="l18.730" class="difflineplus">+</span>
<a href="#l18.731"></a><span id="l18.731" class="difflineplus">+        if (aMailNewsUrl) {</span>
<a href="#l18.732"></a><span id="l18.732">           nsCOMPtr&lt;nsICacheEntry&gt; cacheEntry;</span>
<a href="#l18.733"></a><span id="l18.733">           res = aMailNewsUrl-&gt;GetMemCacheEntry(getter_AddRefs(cacheEntry));</span>
<a href="#l18.734"></a><span id="l18.734" class="difflineminus">-          if (NS_SUCCEEDED(res) &amp;&amp; cacheEntry)</span>
<a href="#l18.735"></a><span id="l18.735" class="difflineminus">-            cacheEntry-&gt;AsyncDoom(nullptr);</span>
<a href="#l18.736"></a><span id="l18.736" class="difflineplus">+          if (NS_SUCCEEDED(res) &amp;&amp; cacheEntry) cacheEntry-&gt;AsyncDoom(nullptr);</span>
<a href="#l18.737"></a><span id="l18.737">           // we're aborting this url - tell listeners</span>
<a href="#l18.738"></a><span id="l18.738">           aMailNewsUrl-&gt;SetUrlState(false, NS_MSG_ERROR_URL_ABORTED);</span>
<a href="#l18.739"></a><span id="l18.739">         }</span>
<a href="#l18.740"></a><span id="l18.740">       }</span>
<a href="#l18.741"></a><span id="l18.741">     }</span>
<a href="#l18.742"></a><span id="l18.742">   }</span>
<a href="#l18.743"></a><span id="l18.743">   return rv;</span>
<a href="#l18.744"></a><span id="l18.744"> }</span>
<a href="#l18.745"></a><span id="l18.745"> </span>
<a href="#l18.746"></a><span id="l18.746"> NS_IMETHODIMP</span>
<a href="#l18.747"></a><span id="l18.747" class="difflineminus">-nsImapIncomingServer::RemoveConnection(nsIImapProtocol* aImapConnection)</span>
<a href="#l18.748"></a><span id="l18.748" class="difflineminus">-{</span>
<a href="#l18.749"></a><span id="l18.749" class="difflineplus">+nsImapIncomingServer::RemoveConnection(nsIImapProtocol *aImapConnection) {</span>
<a href="#l18.750"></a><span id="l18.750">   PR_CEnterMonitor(this);</span>
<a href="#l18.751"></a><span id="l18.751" class="difflineminus">-  if (aImapConnection)</span>
<a href="#l18.752"></a><span id="l18.752" class="difflineminus">-    m_connectionCache.RemoveObject(aImapConnection);</span>
<a href="#l18.753"></a><span id="l18.753" class="difflineplus">+  if (aImapConnection) m_connectionCache.RemoveObject(aImapConnection);</span>
<a href="#l18.754"></a><span id="l18.754"> </span>
<a href="#l18.755"></a><span id="l18.755">   PR_CExitMonitor(this);</span>
<a href="#l18.756"></a><span id="l18.756">   return NS_OK;</span>
<a href="#l18.757"></a><span id="l18.757"> }</span>
<a href="#l18.758"></a><span id="l18.758"> </span>
<a href="#l18.759"></a><span id="l18.759" class="difflineminus">-bool</span>
<a href="#l18.760"></a><span id="l18.760" class="difflineminus">-nsImapIncomingServer::ConnectionTimeOut(nsIImapProtocol* aConnection)</span>
<a href="#l18.761"></a><span id="l18.761" class="difflineminus">-{</span>
<a href="#l18.762"></a><span id="l18.762" class="difflineplus">+bool nsImapIncomingServer::ConnectionTimeOut(nsIImapProtocol *aConnection) {</span>
<a href="#l18.763"></a><span id="l18.763">   bool retVal = false;</span>
<a href="#l18.764"></a><span id="l18.764">   if (!aConnection) return retVal;</span>
<a href="#l18.765"></a><span id="l18.765">   nsresult rv;</span>
<a href="#l18.766"></a><span id="l18.766"> </span>
<a href="#l18.767"></a><span id="l18.767">   int32_t timeoutInMinutes = 0;</span>
<a href="#l18.768"></a><span id="l18.768">   rv = GetTimeOutLimits(&amp;timeoutInMinutes);</span>
<a href="#l18.769"></a><span id="l18.769" class="difflineminus">-  if (NS_FAILED(rv) || timeoutInMinutes &lt;= 0 || timeoutInMinutes &gt; 29)</span>
<a href="#l18.770"></a><span id="l18.770" class="difflineminus">-  {</span>
<a href="#l18.771"></a><span id="l18.771" class="difflineplus">+  if (NS_FAILED(rv) || timeoutInMinutes &lt;= 0 || timeoutInMinutes &gt; 29) {</span>
<a href="#l18.772"></a><span id="l18.772">     timeoutInMinutes = 29;</span>
<a href="#l18.773"></a><span id="l18.773">     SetTimeOutLimits(timeoutInMinutes);</span>
<a href="#l18.774"></a><span id="l18.774">   }</span>
<a href="#l18.775"></a><span id="l18.775"> </span>
<a href="#l18.776"></a><span id="l18.776">   PRTime cacheTimeoutLimits = timeoutInMinutes * 60 * PR_USEC_PER_SEC;</span>
<a href="#l18.777"></a><span id="l18.777">   PRTime lastActiveTimeStamp;</span>
<a href="#l18.778"></a><span id="l18.778">   rv = aConnection-&gt;GetLastActiveTimeStamp(&amp;lastActiveTimeStamp);</span>
<a href="#l18.779"></a><span id="l18.779"> </span>
<a href="#l18.780"></a><span id="l18.780" class="difflineminus">-  if (PR_Now() - lastActiveTimeStamp &gt;= cacheTimeoutLimits)</span>
<a href="#l18.781"></a><span id="l18.781" class="difflineminus">-  {</span>
<a href="#l18.782"></a><span id="l18.782" class="difflineplus">+  if (PR_Now() - lastActiveTimeStamp &gt;= cacheTimeoutLimits) {</span>
<a href="#l18.783"></a><span id="l18.783">     RemoveConnection(aConnection);</span>
<a href="#l18.784"></a><span id="l18.784">     aConnection-&gt;TellThreadToDie(false);</span>
<a href="#l18.785"></a><span id="l18.785">     retVal = true;</span>
<a href="#l18.786"></a><span id="l18.786">   }</span>
<a href="#l18.787"></a><span id="l18.787">   return retVal;</span>
<a href="#l18.788"></a><span id="l18.788"> }</span>
<a href="#l18.789"></a><span id="l18.789"> </span>
<a href="#l18.790"></a><span id="l18.790" class="difflineminus">-nsresult</span>
<a href="#l18.791"></a><span id="l18.791" class="difflineminus">-nsImapIncomingServer::GetImapConnection(nsIImapUrl * aImapUrl,</span>
<a href="#l18.792"></a><span id="l18.792" class="difflineminus">-                                        nsIImapProtocol ** aImapConnection)</span>
<a href="#l18.793"></a><span id="l18.793" class="difflineminus">-{</span>
<a href="#l18.794"></a><span id="l18.794" class="difflineplus">+nsresult nsImapIncomingServer::GetImapConnection(</span>
<a href="#l18.795"></a><span id="l18.795" class="difflineplus">+    nsIImapUrl *aImapUrl, nsIImapProtocol **aImapConnection) {</span>
<a href="#l18.796"></a><span id="l18.796">   NS_ENSURE_ARG_POINTER(aImapUrl);</span>
<a href="#l18.797"></a><span id="l18.797"> </span>
<a href="#l18.798"></a><span id="l18.798">   nsresult rv = NS_OK;</span>
<a href="#l18.799"></a><span id="l18.799">   bool canRunUrlImmediately = false;</span>
<a href="#l18.800"></a><span id="l18.800">   bool canRunButBusy = false;</span>
<a href="#l18.801"></a><span id="l18.801">   nsCOMPtr&lt;nsIImapProtocol&gt; connection;</span>
<a href="#l18.802"></a><span id="l18.802">   nsCOMPtr&lt;nsIImapProtocol&gt; freeConnection;</span>
<a href="#l18.803"></a><span id="l18.803">   bool isBusy = false;</span>
<a href="#l18.804"></a><span id="l18.804" class="difflineat">@@ -711,480 +654,438 @@ nsImapIncomingServer::GetImapConnection(</span>
<a href="#l18.805"></a><span id="l18.805">   PR_CEnterMonitor(this);</span>
<a href="#l18.806"></a><span id="l18.806"> </span>
<a href="#l18.807"></a><span id="l18.807">   int32_t maxConnections;</span>
<a href="#l18.808"></a><span id="l18.808">   (void)GetMaximumConnectionsNumber(&amp;maxConnections);</span>
<a href="#l18.809"></a><span id="l18.809"> </span>
<a href="#l18.810"></a><span id="l18.810">   int32_t cnt = m_connectionCache.Count();</span>
<a href="#l18.811"></a><span id="l18.811"> </span>
<a href="#l18.812"></a><span id="l18.812">   *aImapConnection = nullptr;</span>
<a href="#l18.813"></a><span id="l18.813" class="difflineminus">-  // iterate through the connection cache for a connection that can handle this url.</span>
<a href="#l18.814"></a><span id="l18.814" class="difflineplus">+  // iterate through the connection cache for a connection that can handle this</span>
<a href="#l18.815"></a><span id="l18.815" class="difflineplus">+  // url.</span>
<a href="#l18.816"></a><span id="l18.816">   bool userCancelled = false;</span>
<a href="#l18.817"></a><span id="l18.817"> </span>
<a href="#l18.818"></a><span id="l18.818" class="difflineminus">-  // loop until we find a connection that can run the url, or doesn't have to wait?</span>
<a href="#l18.819"></a><span id="l18.819" class="difflineminus">-  for (int32_t i = cnt - 1; i &gt;= 0 &amp;&amp; !canRunUrlImmediately &amp;&amp; !canRunButBusy; i--)</span>
<a href="#l18.820"></a><span id="l18.820" class="difflineminus">-  {</span>
<a href="#l18.821"></a><span id="l18.821" class="difflineplus">+  // loop until we find a connection that can run the url, or doesn't have to</span>
<a href="#l18.822"></a><span id="l18.822" class="difflineplus">+  // wait?</span>
<a href="#l18.823"></a><span id="l18.823" class="difflineplus">+  for (int32_t i = cnt - 1; i &gt;= 0 &amp;&amp; !canRunUrlImmediately &amp;&amp; !canRunButBusy;</span>
<a href="#l18.824"></a><span id="l18.824" class="difflineplus">+       i--) {</span>
<a href="#l18.825"></a><span id="l18.825">     connection = m_connectionCache[i];</span>
<a href="#l18.826"></a><span id="l18.826" class="difflineminus">-    if (connection)</span>
<a href="#l18.827"></a><span id="l18.827" class="difflineminus">-    {</span>
<a href="#l18.828"></a><span id="l18.828" class="difflineplus">+    if (connection) {</span>
<a href="#l18.829"></a><span id="l18.829">       bool badConnection = ConnectionTimeOut(connection);</span>
<a href="#l18.830"></a><span id="l18.830" class="difflineminus">-      if (!badConnection)</span>
<a href="#l18.831"></a><span id="l18.831" class="difflineminus">-      {</span>
<a href="#l18.832"></a><span id="l18.832" class="difflineminus">-        badConnection = NS_FAILED(connection-&gt;CanHandleUrl(aImapUrl,</span>
<a href="#l18.833"></a><span id="l18.833" class="difflineminus">-                                                           &amp;canRunUrlImmediately,</span>
<a href="#l18.834"></a><span id="l18.834" class="difflineminus">-                                                           &amp;canRunButBusy));</span>
<a href="#l18.835"></a><span id="l18.835" class="difflineplus">+      if (!badConnection) {</span>
<a href="#l18.836"></a><span id="l18.836" class="difflineplus">+        badConnection = NS_FAILED(connection-&gt;CanHandleUrl(</span>
<a href="#l18.837"></a><span id="l18.837" class="difflineplus">+            aImapUrl, &amp;canRunUrlImmediately, &amp;canRunButBusy));</span>
<a href="#l18.838"></a><span id="l18.838"> #ifdef DEBUG_bienvenu</span>
<a href="#l18.839"></a><span id="l18.839">         nsAutoCString curSelectedFolderName;</span>
<a href="#l18.840"></a><span id="l18.840">         if (connection)</span>
<a href="#l18.841"></a><span id="l18.841" class="difflineminus">-          connection-&gt;GetSelectedMailboxName(getter_Copies(curSelectedFolderName));</span>
<a href="#l18.842"></a><span id="l18.842" class="difflineplus">+          connection-&gt;GetSelectedMailboxName(</span>
<a href="#l18.843"></a><span id="l18.843" class="difflineplus">+              getter_Copies(curSelectedFolderName));</span>
<a href="#l18.844"></a><span id="l18.844">         // check that no other connection is in the same selected state.</span>
<a href="#l18.845"></a><span id="l18.845" class="difflineminus">-        if (!curSelectedFolderName.IsEmpty())</span>
<a href="#l18.846"></a><span id="l18.846" class="difflineminus">-        {</span>
<a href="#l18.847"></a><span id="l18.847" class="difflineminus">-          for (uint32_t j = 0; j &lt; cnt; j++)</span>
<a href="#l18.848"></a><span id="l18.848" class="difflineminus">-          {</span>
<a href="#l18.849"></a><span id="l18.849" class="difflineminus">-            if (j != i)</span>
<a href="#l18.850"></a><span id="l18.850" class="difflineminus">-            {</span>
<a href="#l18.851"></a><span id="l18.851" class="difflineminus">-              nsCOMPtr&lt;nsIImapProtocol&gt; otherConnection = do_QueryElementAt(m_connectionCache, j);</span>
<a href="#l18.852"></a><span id="l18.852" class="difflineminus">-              if (otherConnection)</span>
<a href="#l18.853"></a><span id="l18.853" class="difflineminus">-              {</span>
<a href="#l18.854"></a><span id="l18.854" class="difflineplus">+        if (!curSelectedFolderName.IsEmpty()) {</span>
<a href="#l18.855"></a><span id="l18.855" class="difflineplus">+          for (uint32_t j = 0; j &lt; cnt; j++) {</span>
<a href="#l18.856"></a><span id="l18.856" class="difflineplus">+            if (j != i) {</span>
<a href="#l18.857"></a><span id="l18.857" class="difflineplus">+              nsCOMPtr&lt;nsIImapProtocol&gt; otherConnection =</span>
<a href="#l18.858"></a><span id="l18.858" class="difflineplus">+                  do_QueryElementAt(m_connectionCache, j);</span>
<a href="#l18.859"></a><span id="l18.859" class="difflineplus">+              if (otherConnection) {</span>
<a href="#l18.860"></a><span id="l18.860">                 nsAutoCString otherSelectedFolderName;</span>
<a href="#l18.861"></a><span id="l18.861" class="difflineminus">-                otherConnection-&gt;GetSelectedMailboxName(getter_Copies(otherSelectedFolderName));</span>
<a href="#l18.862"></a><span id="l18.862" class="difflineminus">-                NS_ASSERTION(!curSelectedFolderName.Equals(otherSelectedFolderName), &quot;two connections selected on same folder&quot;);</span>
<a href="#l18.863"></a><span id="l18.863" class="difflineplus">+                otherConnection-&gt;GetSelectedMailboxName(</span>
<a href="#l18.864"></a><span id="l18.864" class="difflineplus">+                    getter_Copies(otherSelectedFolderName));</span>
<a href="#l18.865"></a><span id="l18.865" class="difflineplus">+                NS_ASSERTION(</span>
<a href="#l18.866"></a><span id="l18.866" class="difflineplus">+                    !curSelectedFolderName.Equals(otherSelectedFolderName),</span>
<a href="#l18.867"></a><span id="l18.867" class="difflineplus">+                    &quot;two connections selected on same folder&quot;);</span>
<a href="#l18.868"></a><span id="l18.868">               }</span>
<a href="#l18.869"></a><span id="l18.869" class="difflineminus">-</span>
<a href="#l18.870"></a><span id="l18.870">             }</span>
<a href="#l18.871"></a><span id="l18.871">           }</span>
<a href="#l18.872"></a><span id="l18.872">         }</span>
<a href="#l18.873"></a><span id="l18.873" class="difflineminus">-#endif // DEBUG_bienvenu</span>
<a href="#l18.874"></a><span id="l18.874" class="difflineplus">+#endif  // DEBUG_bienvenu</span>
<a href="#l18.875"></a><span id="l18.875">       }</span>
<a href="#l18.876"></a><span id="l18.876" class="difflineminus">-      if (badConnection)</span>
<a href="#l18.877"></a><span id="l18.877" class="difflineminus">-      {</span>
<a href="#l18.878"></a><span id="l18.878" class="difflineplus">+      if (badConnection) {</span>
<a href="#l18.879"></a><span id="l18.879">         connection = nullptr;</span>
<a href="#l18.880"></a><span id="l18.880">         continue;</span>
<a href="#l18.881"></a><span id="l18.881">       }</span>
<a href="#l18.882"></a><span id="l18.882">     }</span>
<a href="#l18.883"></a><span id="l18.883"> </span>
<a href="#l18.884"></a><span id="l18.884" class="difflineminus">-    // if this connection is wrong, but it's not busy, check if we should designate</span>
<a href="#l18.885"></a><span id="l18.885" class="difflineminus">-    // it as the free connection.</span>
<a href="#l18.886"></a><span id="l18.886" class="difflineminus">-    if (!canRunUrlImmediately &amp;&amp; !canRunButBusy &amp;&amp; connection)</span>
<a href="#l18.887"></a><span id="l18.887" class="difflineminus">-    {</span>
<a href="#l18.888"></a><span id="l18.888" class="difflineminus">-        rv = connection-&gt;IsBusy(&amp;isBusy, &amp;isInboxConnection);</span>
<a href="#l18.889"></a><span id="l18.889" class="difflineminus">-        if (NS_FAILED(rv))</span>
<a href="#l18.890"></a><span id="l18.890" class="difflineminus">-          continue;</span>
<a href="#l18.891"></a><span id="l18.891" class="difflineminus">-        // if max connections is &lt;= 1, we have to re-use the inbox connection.</span>
<a href="#l18.892"></a><span id="l18.892" class="difflineminus">-        if (!isBusy &amp;&amp; (!isInboxConnection || maxConnections &lt;= 1))</span>
<a href="#l18.893"></a><span id="l18.893" class="difflineminus">-        {</span>
<a href="#l18.894"></a><span id="l18.894" class="difflineminus">-          if (!freeConnection)</span>
<a href="#l18.895"></a><span id="l18.895" class="difflineminus">-            freeConnection = connection;</span>
<a href="#l18.896"></a><span id="l18.896" class="difflineminus">-          else  // check which is the better free connection to use.</span>
<a href="#l18.897"></a><span id="l18.897" class="difflineminus">-          {     // We prefer one not in the selected state.</span>
<a href="#l18.898"></a><span id="l18.898" class="difflineminus">-            nsAutoCString selectedFolderName;</span>
<a href="#l18.899"></a><span id="l18.899" class="difflineminus">-            connection-&gt;GetSelectedMailboxName(getter_Copies(selectedFolderName));</span>
<a href="#l18.900"></a><span id="l18.900" class="difflineminus">-            if (selectedFolderName.IsEmpty())</span>
<a href="#l18.901"></a><span id="l18.901" class="difflineminus">-              freeConnection = connection;</span>
<a href="#l18.902"></a><span id="l18.902" class="difflineminus">-          }</span>
<a href="#l18.903"></a><span id="l18.903" class="difflineplus">+    // if this connection is wrong, but it's not busy, check if we should</span>
<a href="#l18.904"></a><span id="l18.904" class="difflineplus">+    // designate it as the free connection.</span>
<a href="#l18.905"></a><span id="l18.905" class="difflineplus">+    if (!canRunUrlImmediately &amp;&amp; !canRunButBusy &amp;&amp; connection) {</span>
<a href="#l18.906"></a><span id="l18.906" class="difflineplus">+      rv = connection-&gt;IsBusy(&amp;isBusy, &amp;isInboxConnection);</span>
<a href="#l18.907"></a><span id="l18.907" class="difflineplus">+      if (NS_FAILED(rv)) continue;</span>
<a href="#l18.908"></a><span id="l18.908" class="difflineplus">+      // if max connections is &lt;= 1, we have to re-use the inbox connection.</span>
<a href="#l18.909"></a><span id="l18.909" class="difflineplus">+      if (!isBusy &amp;&amp; (!isInboxConnection || maxConnections &lt;= 1)) {</span>
<a href="#l18.910"></a><span id="l18.910" class="difflineplus">+        if (!freeConnection)</span>
<a href="#l18.911"></a><span id="l18.911" class="difflineplus">+          freeConnection = connection;</span>
<a href="#l18.912"></a><span id="l18.912" class="difflineplus">+        else  // check which is the better free connection to use.</span>
<a href="#l18.913"></a><span id="l18.913" class="difflineplus">+        {     // We prefer one not in the selected state.</span>
<a href="#l18.914"></a><span id="l18.914" class="difflineplus">+          nsAutoCString selectedFolderName;</span>
<a href="#l18.915"></a><span id="l18.915" class="difflineplus">+          connection-&gt;GetSelectedMailboxName(getter_Copies(selectedFolderName));</span>
<a href="#l18.916"></a><span id="l18.916" class="difflineplus">+          if (selectedFolderName.IsEmpty()) freeConnection = connection;</span>
<a href="#l18.917"></a><span id="l18.917">         }</span>
<a href="#l18.918"></a><span id="l18.918" class="difflineplus">+      }</span>
<a href="#l18.919"></a><span id="l18.919">     }</span>
<a href="#l18.920"></a><span id="l18.920">     // don't leave this loop with connection set if we can't use it!</span>
<a href="#l18.921"></a><span id="l18.921" class="difflineminus">-    if (!canRunButBusy &amp;&amp; !canRunUrlImmediately)</span>
<a href="#l18.922"></a><span id="l18.922" class="difflineminus">-      connection = nullptr;</span>
<a href="#l18.923"></a><span id="l18.923" class="difflineplus">+    if (!canRunButBusy &amp;&amp; !canRunUrlImmediately) connection = nullptr;</span>
<a href="#l18.924"></a><span id="l18.924">   }</span>
<a href="#l18.925"></a><span id="l18.925"> </span>
<a href="#l18.926"></a><span id="l18.926">   nsImapState requiredState;</span>
<a href="#l18.927"></a><span id="l18.927">   aImapUrl-&gt;GetRequiredImapState(&amp;requiredState);</span>
<a href="#l18.928"></a><span id="l18.928">   // refresh cnt in case we killed one or more dead connections. This</span>
<a href="#l18.929"></a><span id="l18.929">   // will prevent us from not spinning up a new connection when all</span>
<a href="#l18.930"></a><span id="l18.930">   // connections were dead.</span>
<a href="#l18.931"></a><span id="l18.931">   cnt = m_connectionCache.Count();</span>
<a href="#l18.932"></a><span id="l18.932">   // if we got here and we have a connection, then we should return it!</span>
<a href="#l18.933"></a><span id="l18.933" class="difflineminus">-  if (canRunUrlImmediately &amp;&amp; connection)</span>
<a href="#l18.934"></a><span id="l18.934" class="difflineminus">-  {</span>
<a href="#l18.935"></a><span id="l18.935" class="difflineplus">+  if (canRunUrlImmediately &amp;&amp; connection) {</span>
<a href="#l18.936"></a><span id="l18.936">     connection.forget(aImapConnection);</span>
<a href="#l18.937"></a><span id="l18.937" class="difflineminus">-  }</span>
<a href="#l18.938"></a><span id="l18.938" class="difflineminus">-  else if (canRunButBusy)</span>
<a href="#l18.939"></a><span id="l18.939" class="difflineminus">-  {</span>
<a href="#l18.940"></a><span id="l18.940" class="difflineplus">+  } else if (canRunButBusy) {</span>
<a href="#l18.941"></a><span id="l18.941">     // do nothing; return NS_OK; for queuing</span>
<a href="#l18.942"></a><span id="l18.942" class="difflineminus">-  }</span>
<a href="#l18.943"></a><span id="l18.943" class="difflineminus">-  else if (userCancelled)</span>
<a href="#l18.944"></a><span id="l18.944" class="difflineminus">-  {</span>
<a href="#l18.945"></a><span id="l18.945" class="difflineplus">+  } else if (userCancelled) {</span>
<a href="#l18.946"></a><span id="l18.946">     rv = NS_BINDING_ABORTED;  // user cancelled</span>
<a href="#l18.947"></a><span id="l18.947">   }</span>
<a href="#l18.948"></a><span id="l18.948" class="difflineminus">-  // CanHandleUrl will pretend that some types of urls require a selected state url</span>
<a href="#l18.949"></a><span id="l18.949" class="difflineminus">-  // (e.g., a folder delete or msg append) but we shouldn't create new connections</span>
<a href="#l18.950"></a><span id="l18.950" class="difflineminus">-  // for these types of urls if we have a free connection. So we check the actual</span>
<a href="#l18.951"></a><span id="l18.951" class="difflineminus">-  // required state here.</span>
<a href="#l18.952"></a><span id="l18.952" class="difflineminus">-  else if (cnt &lt; maxConnections</span>
<a href="#l18.953"></a><span id="l18.953" class="difflineminus">-      &amp;&amp; (!freeConnection || requiredState == nsIImapUrl::nsImapSelectedState))</span>
<a href="#l18.954"></a><span id="l18.954" class="difflineplus">+  // CanHandleUrl will pretend that some types of urls require a selected state</span>
<a href="#l18.955"></a><span id="l18.955" class="difflineplus">+  // url (e.g., a folder delete or msg append) but we shouldn't create new</span>
<a href="#l18.956"></a><span id="l18.956" class="difflineplus">+  // connections for these types of urls if we have a free connection. So we</span>
<a href="#l18.957"></a><span id="l18.957" class="difflineplus">+  // check the actual required state here.</span>
<a href="#l18.958"></a><span id="l18.958" class="difflineplus">+  else if (cnt &lt; maxConnections &amp;&amp;</span>
<a href="#l18.959"></a><span id="l18.959" class="difflineplus">+           (!freeConnection ||</span>
<a href="#l18.960"></a><span id="l18.960" class="difflineplus">+            requiredState == nsIImapUrl::nsImapSelectedState))</span>
<a href="#l18.961"></a><span id="l18.961">     rv = CreateProtocolInstance(aImapConnection);</span>
<a href="#l18.962"></a><span id="l18.962" class="difflineminus">-  else if (freeConnection)</span>
<a href="#l18.963"></a><span id="l18.963" class="difflineminus">-  {</span>
<a href="#l18.964"></a><span id="l18.964" class="difflineplus">+  else if (freeConnection) {</span>
<a href="#l18.965"></a><span id="l18.965">     freeConnection.forget(aImapConnection);</span>
<a href="#l18.966"></a><span id="l18.966" class="difflineminus">-  }</span>
<a href="#l18.967"></a><span id="l18.967" class="difflineminus">-  else // cannot get anyone to handle the url queue it</span>
<a href="#l18.968"></a><span id="l18.968" class="difflineplus">+  } else  // cannot get anyone to handle the url queue it</span>
<a href="#l18.969"></a><span id="l18.969">   {</span>
<a href="#l18.970"></a><span id="l18.970">     if (cnt &gt;= maxConnections)</span>
<a href="#l18.971"></a><span id="l18.971">       nsImapProtocol::LogImapUrl(&quot;exceeded connection cache limit&quot;, aImapUrl);</span>
<a href="#l18.972"></a><span id="l18.972" class="difflineminus">-      // caller will queue the url</span>
<a href="#l18.973"></a><span id="l18.973" class="difflineplus">+    // caller will queue the url</span>
<a href="#l18.974"></a><span id="l18.974">   }</span>
<a href="#l18.975"></a><span id="l18.975"> </span>
<a href="#l18.976"></a><span id="l18.976">   PR_CExitMonitor(this);</span>
<a href="#l18.977"></a><span id="l18.977">   return rv;</span>
<a href="#l18.978"></a><span id="l18.978"> }</span>
<a href="#l18.979"></a><span id="l18.979"> </span>
<a href="#l18.980"></a><span id="l18.980" class="difflineminus">-nsresult</span>
<a href="#l18.981"></a><span id="l18.981" class="difflineminus">-nsImapIncomingServer::CreateProtocolInstance(nsIImapProtocol ** aImapConnection)</span>
<a href="#l18.982"></a><span id="l18.982" class="difflineminus">-{</span>
<a href="#l18.983"></a><span id="l18.983" class="difflineplus">+nsresult nsImapIncomingServer::CreateProtocolInstance(</span>
<a href="#l18.984"></a><span id="l18.984" class="difflineplus">+    nsIImapProtocol **aImapConnection) {</span>
<a href="#l18.985"></a><span id="l18.985">   // create a new connection and add it to the connection cache</span>
<a href="#l18.986"></a><span id="l18.986">   // we may need to flag the protocol connection as busy so we don't get</span>
<a href="#l18.987"></a><span id="l18.987">   // a race condition where someone else goes through this code</span>
<a href="#l18.988"></a><span id="l18.988"> </span>
<a href="#l18.989"></a><span id="l18.989">   int32_t authMethod;</span>
<a href="#l18.990"></a><span id="l18.990">   GetAuthMethod(&amp;authMethod);</span>
<a href="#l18.991"></a><span id="l18.991">   nsresult rv;</span>
<a href="#l18.992"></a><span id="l18.992">   // pre-flight that we have nss - on the ui thread - for MD5 etc.</span>
<a href="#l18.993"></a><span id="l18.993" class="difflineminus">-  switch (authMethod)</span>
<a href="#l18.994"></a><span id="l18.994" class="difflineminus">-  {</span>
<a href="#l18.995"></a><span id="l18.995" class="difflineplus">+  switch (authMethod) {</span>
<a href="#l18.996"></a><span id="l18.996">     case nsMsgAuthMethod::passwordEncrypted:</span>
<a href="#l18.997"></a><span id="l18.997">     case nsMsgAuthMethod::secure:</span>
<a href="#l18.998"></a><span id="l18.998" class="difflineminus">-    case nsMsgAuthMethod::anything:</span>
<a href="#l18.999"></a><span id="l18.999" class="difflineminus">-      {</span>
<a href="#l18.1000"></a><span id="l18.1000" class="difflineminus">-        nsCOMPtr&lt;nsISupports&gt; dummyUsedToEnsureNSSIsInitialized =</span>
<a href="#l18.1001"></a><span id="l18.1001" class="difflineplus">+    case nsMsgAuthMethod::anything: {</span>
<a href="#l18.1002"></a><span id="l18.1002" class="difflineplus">+      nsCOMPtr&lt;nsISupports&gt; dummyUsedToEnsureNSSIsInitialized =</span>
<a href="#l18.1003"></a><span id="l18.1003">           do_GetService(&quot;@mozilla.org/psm;1&quot;, &amp;rv);</span>
<a href="#l18.1004"></a><span id="l18.1004" class="difflineminus">-        NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.1005"></a><span id="l18.1005" class="difflineminus">-      }</span>
<a href="#l18.1006"></a><span id="l18.1006" class="difflineminus">-      break;</span>
<a href="#l18.1007"></a><span id="l18.1007" class="difflineplus">+      NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.1008"></a><span id="l18.1008" class="difflineplus">+    } break;</span>
<a href="#l18.1009"></a><span id="l18.1009">     default:</span>
<a href="#l18.1010"></a><span id="l18.1010">       break;</span>
<a href="#l18.1011"></a><span id="l18.1011">   }</span>
<a href="#l18.1012"></a><span id="l18.1012" class="difflineminus">-  nsIImapProtocol * protocolInstance;</span>
<a href="#l18.1013"></a><span id="l18.1013" class="difflineplus">+  nsIImapProtocol *protocolInstance;</span>
<a href="#l18.1014"></a><span id="l18.1014">   rv = CallCreateInstance(kImapProtocolCID, &amp;protocolInstance);</span>
<a href="#l18.1015"></a><span id="l18.1015" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; protocolInstance)</span>
<a href="#l18.1016"></a><span id="l18.1016" class="difflineminus">-  {</span>
<a href="#l18.1017"></a><span id="l18.1017" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; protocolInstance) {</span>
<a href="#l18.1018"></a><span id="l18.1018">     nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession =</span>
<a href="#l18.1019"></a><span id="l18.1019" class="difflineminus">-      do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.1020"></a><span id="l18.1020" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l18.1021"></a><span id="l18.1021" class="difflineminus">-      rv = protocolInstance-&gt;Initialize(hostSession, this);</span>
<a href="#l18.1022"></a><span id="l18.1022" class="difflineplus">+        do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.1023"></a><span id="l18.1023" class="difflineplus">+    if (NS_SUCCEEDED(rv)) rv = protocolInstance-&gt;Initialize(hostSession, this);</span>
<a href="#l18.1024"></a><span id="l18.1024">   }</span>
<a href="#l18.1025"></a><span id="l18.1025"> </span>
<a href="#l18.1026"></a><span id="l18.1026">   // take the protocol instance and add it to the connectionCache</span>
<a href="#l18.1027"></a><span id="l18.1027" class="difflineminus">-  if (protocolInstance)</span>
<a href="#l18.1028"></a><span id="l18.1028" class="difflineminus">-    m_connectionCache.AppendObject(protocolInstance);</span>
<a href="#l18.1029"></a><span id="l18.1029" class="difflineminus">-  *aImapConnection = protocolInstance; // this is already ref counted.</span>
<a href="#l18.1030"></a><span id="l18.1030" class="difflineplus">+  if (protocolInstance) m_connectionCache.AppendObject(protocolInstance);</span>
<a href="#l18.1031"></a><span id="l18.1031" class="difflineplus">+  *aImapConnection = protocolInstance;  // this is already ref counted.</span>
<a href="#l18.1032"></a><span id="l18.1032">   return rv;</span>
<a href="#l18.1033"></a><span id="l18.1033"> }</span>
<a href="#l18.1034"></a><span id="l18.1034"> </span>
<a href="#l18.1035"></a><span id="l18.1035" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::CloseConnectionForFolder(nsIMsgFolder *aMsgFolder)</span>
<a href="#l18.1036"></a><span id="l18.1036" class="difflineminus">-{</span>
<a href="#l18.1037"></a><span id="l18.1037" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::CloseConnectionForFolder(</span>
<a href="#l18.1038"></a><span id="l18.1038" class="difflineplus">+    nsIMsgFolder *aMsgFolder) {</span>
<a href="#l18.1039"></a><span id="l18.1039">   nsresult rv = NS_OK;</span>
<a href="#l18.1040"></a><span id="l18.1040">   nsCOMPtr&lt;nsIImapProtocol&gt; connection;</span>
<a href="#l18.1041"></a><span id="l18.1041">   bool isBusy = false, isInbox = false;</span>
<a href="#l18.1042"></a><span id="l18.1042">   nsCString inFolderName;</span>
<a href="#l18.1043"></a><span id="l18.1043">   nsCString connectionFolderName;</span>
<a href="#l18.1044"></a><span id="l18.1044" class="difflineminus">-  nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(aMsgFolder);</span>
<a href="#l18.1045"></a><span id="l18.1045" class="difflineminus">-</span>
<a href="#l18.1046"></a><span id="l18.1046" class="difflineminus">-  if (!imapFolder)</span>
<a href="#l18.1047"></a><span id="l18.1047" class="difflineminus">-    return NS_ERROR_NULL_POINTER;</span>
<a href="#l18.1048"></a><span id="l18.1048" class="difflineplus">+  nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(aMsgFolder);</span>
<a href="#l18.1049"></a><span id="l18.1049" class="difflineplus">+</span>
<a href="#l18.1050"></a><span id="l18.1050" class="difflineplus">+  if (!imapFolder) return NS_ERROR_NULL_POINTER;</span>
<a href="#l18.1051"></a><span id="l18.1051"> </span>
<a href="#l18.1052"></a><span id="l18.1052">   int32_t cnt = m_connectionCache.Count();</span>
<a href="#l18.1053"></a><span id="l18.1053">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.1054"></a><span id="l18.1054"> </span>
<a href="#l18.1055"></a><span id="l18.1055">   imapFolder-&gt;GetOnlineName(inFolderName);</span>
<a href="#l18.1056"></a><span id="l18.1056">   PR_CEnterMonitor(this);</span>
<a href="#l18.1057"></a><span id="l18.1057"> </span>
<a href="#l18.1058"></a><span id="l18.1058" class="difflineminus">-  for (int32_t i = 0; i &lt; cnt; ++i)</span>
<a href="#l18.1059"></a><span id="l18.1059" class="difflineminus">-  {</span>
<a href="#l18.1060"></a><span id="l18.1060" class="difflineplus">+  for (int32_t i = 0; i &lt; cnt; ++i) {</span>
<a href="#l18.1061"></a><span id="l18.1061">     connection = m_connectionCache[i];</span>
<a href="#l18.1062"></a><span id="l18.1062" class="difflineminus">-    if (connection)</span>
<a href="#l18.1063"></a><span id="l18.1063" class="difflineminus">-    {</span>
<a href="#l18.1064"></a><span id="l18.1064" class="difflineminus">-      rv = connection-&gt;GetSelectedMailboxName(getter_Copies(connectionFolderName));</span>
<a href="#l18.1065"></a><span id="l18.1065" class="difflineminus">-      if (connectionFolderName.Equals(inFolderName))</span>
<a href="#l18.1066"></a><span id="l18.1066" class="difflineminus">-      {</span>
<a href="#l18.1067"></a><span id="l18.1067" class="difflineplus">+    if (connection) {</span>
<a href="#l18.1068"></a><span id="l18.1068" class="difflineplus">+      rv = connection-&gt;GetSelectedMailboxName(</span>
<a href="#l18.1069"></a><span id="l18.1069" class="difflineplus">+          getter_Copies(connectionFolderName));</span>
<a href="#l18.1070"></a><span id="l18.1070" class="difflineplus">+      if (connectionFolderName.Equals(inFolderName)) {</span>
<a href="#l18.1071"></a><span id="l18.1071">         rv = connection-&gt;IsBusy(&amp;isBusy, &amp;isInbox);</span>
<a href="#l18.1072"></a><span id="l18.1072" class="difflineminus">-        if (!isBusy)</span>
<a href="#l18.1073"></a><span id="l18.1073" class="difflineminus">-          rv = connection-&gt;TellThreadToDie(true);</span>
<a href="#l18.1074"></a><span id="l18.1074" class="difflineminus">-        break; // found it, end of the loop</span>
<a href="#l18.1075"></a><span id="l18.1075" class="difflineplus">+        if (!isBusy) rv = connection-&gt;TellThreadToDie(true);</span>
<a href="#l18.1076"></a><span id="l18.1076" class="difflineplus">+        break;  // found it, end of the loop</span>
<a href="#l18.1077"></a><span id="l18.1077">       }</span>
<a href="#l18.1078"></a><span id="l18.1078">     }</span>
<a href="#l18.1079"></a><span id="l18.1079">   }</span>
<a href="#l18.1080"></a><span id="l18.1080"> </span>
<a href="#l18.1081"></a><span id="l18.1081">   PR_CExitMonitor(this);</span>
<a href="#l18.1082"></a><span id="l18.1082">   return rv;</span>
<a href="#l18.1083"></a><span id="l18.1083"> }</span>
<a href="#l18.1084"></a><span id="l18.1084"> </span>
<a href="#l18.1085"></a><span id="l18.1085" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::ResetConnection(const nsACString&amp; folderName)</span>
<a href="#l18.1086"></a><span id="l18.1086" class="difflineminus">-{</span>
<a href="#l18.1087"></a><span id="l18.1087" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::ResetConnection(</span>
<a href="#l18.1088"></a><span id="l18.1088" class="difflineplus">+    const nsACString &amp;folderName) {</span>
<a href="#l18.1089"></a><span id="l18.1089">   nsresult rv = NS_OK;</span>
<a href="#l18.1090"></a><span id="l18.1090">   nsCOMPtr&lt;nsIImapProtocol&gt; connection;</span>
<a href="#l18.1091"></a><span id="l18.1091">   bool isBusy = false, isInbox = false;</span>
<a href="#l18.1092"></a><span id="l18.1092">   nsCString curFolderName;</span>
<a href="#l18.1093"></a><span id="l18.1093"> </span>
<a href="#l18.1094"></a><span id="l18.1094">   int32_t cnt = m_connectionCache.Count();</span>
<a href="#l18.1095"></a><span id="l18.1095"> </span>
<a href="#l18.1096"></a><span id="l18.1096">   PR_CEnterMonitor(this);</span>
<a href="#l18.1097"></a><span id="l18.1097"> </span>
<a href="#l18.1098"></a><span id="l18.1098" class="difflineminus">-  for (int32_t i = 0; i &lt; cnt; ++i)</span>
<a href="#l18.1099"></a><span id="l18.1099" class="difflineminus">-  {</span>
<a href="#l18.1100"></a><span id="l18.1100" class="difflineplus">+  for (int32_t i = 0; i &lt; cnt; ++i) {</span>
<a href="#l18.1101"></a><span id="l18.1101">     connection = m_connectionCache[i];</span>
<a href="#l18.1102"></a><span id="l18.1102" class="difflineminus">-    if (connection)</span>
<a href="#l18.1103"></a><span id="l18.1103" class="difflineminus">-    {</span>
<a href="#l18.1104"></a><span id="l18.1104" class="difflineplus">+    if (connection) {</span>
<a href="#l18.1105"></a><span id="l18.1105">       rv = connection-&gt;GetSelectedMailboxName(getter_Copies(curFolderName));</span>
<a href="#l18.1106"></a><span id="l18.1106" class="difflineminus">-      if (curFolderName.Equals(folderName))</span>
<a href="#l18.1107"></a><span id="l18.1107" class="difflineminus">-      {</span>
<a href="#l18.1108"></a><span id="l18.1108" class="difflineplus">+      if (curFolderName.Equals(folderName)) {</span>
<a href="#l18.1109"></a><span id="l18.1109">         rv = connection-&gt;IsBusy(&amp;isBusy, &amp;isInbox);</span>
<a href="#l18.1110"></a><span id="l18.1110" class="difflineminus">-        if (!isBusy)</span>
<a href="#l18.1111"></a><span id="l18.1111" class="difflineminus">-            rv = connection-&gt;ResetToAuthenticatedState();</span>
<a href="#l18.1112"></a><span id="l18.1112" class="difflineminus">-        break; // found it, end of the loop</span>
<a href="#l18.1113"></a><span id="l18.1113" class="difflineplus">+        if (!isBusy) rv = connection-&gt;ResetToAuthenticatedState();</span>
<a href="#l18.1114"></a><span id="l18.1114" class="difflineplus">+        break;  // found it, end of the loop</span>
<a href="#l18.1115"></a><span id="l18.1115">       }</span>
<a href="#l18.1116"></a><span id="l18.1116">     }</span>
<a href="#l18.1117"></a><span id="l18.1117">   }</span>
<a href="#l18.1118"></a><span id="l18.1118"> </span>
<a href="#l18.1119"></a><span id="l18.1119">   PR_CExitMonitor(this);</span>
<a href="#l18.1120"></a><span id="l18.1120">   return rv;</span>
<a href="#l18.1121"></a><span id="l18.1121"> }</span>
<a href="#l18.1122"></a><span id="l18.1122"> </span>
<a href="#l18.1123"></a><span id="l18.1123"> NS_IMETHODIMP</span>
<a href="#l18.1124"></a><span id="l18.1124" class="difflineminus">-nsImapIncomingServer::PerformExpand(nsIMsgWindow *aMsgWindow)</span>
<a href="#l18.1125"></a><span id="l18.1125" class="difflineminus">-{</span>
<a href="#l18.1126"></a><span id="l18.1126" class="difflineplus">+nsImapIncomingServer::PerformExpand(nsIMsgWindow *aMsgWindow) {</span>
<a href="#l18.1127"></a><span id="l18.1127">   nsString password;</span>
<a href="#l18.1128"></a><span id="l18.1128">   nsresult rv;</span>
<a href="#l18.1129"></a><span id="l18.1129">   rv = GetPassword(password);</span>
<a href="#l18.1130"></a><span id="l18.1130">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.1131"></a><span id="l18.1131"> </span>
<a href="#l18.1132"></a><span id="l18.1132" class="difflineminus">-  if (password.IsEmpty())</span>
<a href="#l18.1133"></a><span id="l18.1133" class="difflineminus">-    return NS_OK;</span>
<a href="#l18.1134"></a><span id="l18.1134" class="difflineplus">+  if (password.IsEmpty()) return NS_OK;</span>
<a href="#l18.1135"></a><span id="l18.1135"> </span>
<a href="#l18.1136"></a><span id="l18.1136">   rv = ResetFoldersToUnverified(nullptr);</span>
<a href="#l18.1137"></a><span id="l18.1137"> </span>
<a href="#l18.1138"></a><span id="l18.1138">   nsCOMPtr&lt;nsIMsgFolder&gt; rootMsgFolder;</span>
<a href="#l18.1139"></a><span id="l18.1139">   rv = GetRootFolder(getter_AddRefs(rootMsgFolder));</span>
<a href="#l18.1140"></a><span id="l18.1140">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.1141"></a><span id="l18.1141"> </span>
<a href="#l18.1142"></a><span id="l18.1142">   if (!rootMsgFolder) return NS_ERROR_FAILURE;</span>
<a href="#l18.1143"></a><span id="l18.1143"> </span>
<a href="#l18.1144"></a><span id="l18.1144" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.1145"></a><span id="l18.1145" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l18.1146"></a><span id="l18.1146" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.1147"></a><span id="l18.1147">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.1148"></a><span id="l18.1148">   nsCOMPtr&lt;nsIThread&gt; thread(do_GetCurrentThread());</span>
<a href="#l18.1149"></a><span id="l18.1149" class="difflineminus">-  rv = imapService-&gt;DiscoverAllFolders(rootMsgFolder,</span>
<a href="#l18.1150"></a><span id="l18.1150" class="difflineminus">-                                       this, aMsgWindow, nullptr);</span>
<a href="#l18.1151"></a><span id="l18.1151" class="difflineplus">+  rv =</span>
<a href="#l18.1152"></a><span id="l18.1152" class="difflineplus">+      imapService-&gt;DiscoverAllFolders(rootMsgFolder, this, aMsgWindow, nullptr);</span>
<a href="#l18.1153"></a><span id="l18.1153">   return rv;</span>
<a href="#l18.1154"></a><span id="l18.1154"> }</span>
<a href="#l18.1155"></a><span id="l18.1155"> </span>
<a href="#l18.1156"></a><span id="l18.1156"> NS_IMETHODIMP</span>
<a href="#l18.1157"></a><span id="l18.1157"> nsImapIncomingServer::VerifyLogon(nsIUrlListener *aUrlListener,</span>
<a href="#l18.1158"></a><span id="l18.1158" class="difflineminus">-                                  nsIMsgWindow *aMsgWindow, nsIURI **aURL)</span>
<a href="#l18.1159"></a><span id="l18.1159" class="difflineminus">-{</span>
<a href="#l18.1160"></a><span id="l18.1160" class="difflineplus">+                                  nsIMsgWindow *aMsgWindow, nsIURI **aURL) {</span>
<a href="#l18.1161"></a><span id="l18.1161">   nsresult rv;</span>
<a href="#l18.1162"></a><span id="l18.1162"> </span>
<a href="#l18.1163"></a><span id="l18.1163" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.1164"></a><span id="l18.1164" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l18.1165"></a><span id="l18.1165" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.1166"></a><span id="l18.1166">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.1167"></a><span id="l18.1167">   nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.1168"></a><span id="l18.1168">   // this will create the resource if it doesn't exist, but it shouldn't</span>
<a href="#l18.1169"></a><span id="l18.1169">   // do anything on disk.</span>
<a href="#l18.1170"></a><span id="l18.1170">   rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l18.1171"></a><span id="l18.1171">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.1172"></a><span id="l18.1172">   return imapService-&gt;VerifyLogon(rootFolder, aUrlListener, aMsgWindow, aURL);</span>
<a href="#l18.1173"></a><span id="l18.1173"> }</span>
<a href="#l18.1174"></a><span id="l18.1174"> </span>
<a href="#l18.1175"></a><span id="l18.1175" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::PerformBiff(nsIMsgWindow* aMsgWindow)</span>
<a href="#l18.1176"></a><span id="l18.1176" class="difflineminus">-{</span>
<a href="#l18.1177"></a><span id="l18.1177" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::PerformBiff(nsIMsgWindow *aMsgWindow) {</span>
<a href="#l18.1178"></a><span id="l18.1178">   nsCOMPtr&lt;nsIMsgFolder&gt; rootMsgFolder;</span>
<a href="#l18.1179"></a><span id="l18.1179">   nsresult rv = GetRootMsgFolder(getter_AddRefs(rootMsgFolder));</span>
<a href="#l18.1180"></a><span id="l18.1180" class="difflineminus">-  if(NS_SUCCEEDED(rv))</span>
<a href="#l18.1181"></a><span id="l18.1181" class="difflineminus">-  {</span>
<a href="#l18.1182"></a><span id="l18.1182" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.1183"></a><span id="l18.1183">     SetPerformingBiff(true);</span>
<a href="#l18.1184"></a><span id="l18.1184">     rv = rootMsgFolder-&gt;GetNewMessages(aMsgWindow, nullptr);</span>
<a href="#l18.1185"></a><span id="l18.1185">   }</span>
<a href="#l18.1186"></a><span id="l18.1186">   return rv;</span>
<a href="#l18.1187"></a><span id="l18.1187"> }</span>
<a href="#l18.1188"></a><span id="l18.1188"> </span>
<a href="#l18.1189"></a><span id="l18.1189" class="difflineminus">-</span>
<a href="#l18.1190"></a><span id="l18.1190"> NS_IMETHODIMP</span>
<a href="#l18.1191"></a><span id="l18.1191" class="difflineminus">-nsImapIncomingServer::CloseCachedConnections()</span>
<a href="#l18.1192"></a><span id="l18.1192" class="difflineminus">-{</span>
<a href="#l18.1193"></a><span id="l18.1193" class="difflineplus">+nsImapIncomingServer::CloseCachedConnections() {</span>
<a href="#l18.1194"></a><span id="l18.1194">   nsCOMPtr&lt;nsIImapProtocol&gt; connection;</span>
<a href="#l18.1195"></a><span id="l18.1195">   PR_CEnterMonitor(this);</span>
<a href="#l18.1196"></a><span id="l18.1196"> </span>
<a href="#l18.1197"></a><span id="l18.1197">   // iterate through the connection cache closing open connections.</span>
<a href="#l18.1198"></a><span id="l18.1198">   int32_t cnt = m_connectionCache.Count();</span>
<a href="#l18.1199"></a><span id="l18.1199"> </span>
<a href="#l18.1200"></a><span id="l18.1200" class="difflineminus">-  for (int32_t i = cnt; i &gt; 0; --i)</span>
<a href="#l18.1201"></a><span id="l18.1201" class="difflineminus">-  {</span>
<a href="#l18.1202"></a><span id="l18.1202" class="difflineplus">+  for (int32_t i = cnt; i &gt; 0; --i) {</span>
<a href="#l18.1203"></a><span id="l18.1203">     connection = m_connectionCache[i - 1];</span>
<a href="#l18.1204"></a><span id="l18.1204" class="difflineminus">-    if (connection)</span>
<a href="#l18.1205"></a><span id="l18.1205" class="difflineminus">-      connection-&gt;TellThreadToDie(true);</span>
<a href="#l18.1206"></a><span id="l18.1206" class="difflineplus">+    if (connection) connection-&gt;TellThreadToDie(true);</span>
<a href="#l18.1207"></a><span id="l18.1207">   }</span>
<a href="#l18.1208"></a><span id="l18.1208"> </span>
<a href="#l18.1209"></a><span id="l18.1209">   PR_CExitMonitor(this);</span>
<a href="#l18.1210"></a><span id="l18.1210">   return NS_OK;</span>
<a href="#l18.1211"></a><span id="l18.1211"> }</span>
<a href="#l18.1212"></a><span id="l18.1212"> </span>
<a href="#l18.1213"></a><span id="l18.1213" class="difflineminus">-nsresult</span>
<a href="#l18.1214"></a><span id="l18.1214" class="difflineminus">-nsImapIncomingServer::CreateRootFolderFromUri(const nsCString &amp;serverUri,</span>
<a href="#l18.1215"></a><span id="l18.1215" class="difflineminus">-                                              nsIMsgFolder **rootFolder)</span>
<a href="#l18.1216"></a><span id="l18.1216" class="difflineminus">-{</span>
<a href="#l18.1217"></a><span id="l18.1217" class="difflineplus">+nsresult nsImapIncomingServer::CreateRootFolderFromUri(</span>
<a href="#l18.1218"></a><span id="l18.1218" class="difflineplus">+    const nsCString &amp;serverUri, nsIMsgFolder **rootFolder) {</span>
<a href="#l18.1219"></a><span id="l18.1219">   nsImapMailFolder *newRootFolder = new nsImapMailFolder;</span>
<a href="#l18.1220"></a><span id="l18.1220">   newRootFolder-&gt;Init(serverUri.get());</span>
<a href="#l18.1221"></a><span id="l18.1221">   NS_ADDREF(*rootFolder = newRootFolder);</span>
<a href="#l18.1222"></a><span id="l18.1222">   return NS_OK;</span>
<a href="#l18.1223"></a><span id="l18.1223"> }</span>
<a href="#l18.1224"></a><span id="l18.1224"> </span>
<a href="#l18.1225"></a><span id="l18.1225"> // nsIImapServerSink impl</span>
<a href="#l18.1226"></a><span id="l18.1226" class="difflineminus">-// aNewFolder will not be set if we're listing for the subscribe UI, since that's the way 4.x worked.</span>
<a href="#l18.1227"></a><span id="l18.1227" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::PossibleImapMailbox(const nsACString&amp; folderPath,</span>
<a href="#l18.1228"></a><span id="l18.1228" class="difflineminus">-                                                        char hierarchyDelimiter,</span>
<a href="#l18.1229"></a><span id="l18.1229" class="difflineminus">-                                                        int32_t boxFlags, bool *aNewFolder)</span>
<a href="#l18.1230"></a><span id="l18.1230" class="difflineminus">-{</span>
<a href="#l18.1231"></a><span id="l18.1231" class="difflineplus">+// aNewFolder will not be set if we're listing for the subscribe UI, since</span>
<a href="#l18.1232"></a><span id="l18.1232" class="difflineplus">+// that's the way 4.x worked.</span>
<a href="#l18.1233"></a><span id="l18.1233" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::PossibleImapMailbox(</span>
<a href="#l18.1234"></a><span id="l18.1234" class="difflineplus">+    const nsACString &amp;folderPath, char hierarchyDelimiter, int32_t boxFlags,</span>
<a href="#l18.1235"></a><span id="l18.1235" class="difflineplus">+    bool *aNewFolder) {</span>
<a href="#l18.1236"></a><span id="l18.1236">   NS_ENSURE_ARG_POINTER(aNewFolder);</span>
<a href="#l18.1237"></a><span id="l18.1237">   NS_ENSURE_TRUE(!folderPath.IsEmpty(), NS_ERROR_FAILURE);</span>
<a href="#l18.1238"></a><span id="l18.1238"> </span>
<a href="#l18.1239"></a><span id="l18.1239" class="difflineminus">-  // folderPath is in canonical format, i.e., hierarchy separator has been replaced with '/'</span>
<a href="#l18.1240"></a><span id="l18.1240" class="difflineplus">+  // folderPath is in canonical format, i.e., hierarchy separator has been</span>
<a href="#l18.1241"></a><span id="l18.1241" class="difflineplus">+  // replaced with '/'</span>
<a href="#l18.1242"></a><span id="l18.1242">   nsresult rv;</span>
<a href="#l18.1243"></a><span id="l18.1243">   bool found = false;</span>
<a href="#l18.1244"></a><span id="l18.1244">   bool haveParent = false;</span>
<a href="#l18.1245"></a><span id="l18.1245">   nsCOMPtr&lt;nsIMsgImapMailFolder&gt; hostFolder;</span>
<a href="#l18.1246"></a><span id="l18.1246">   nsCOMPtr&lt;nsIMsgFolder&gt; aFolder;</span>
<a href="#l18.1247"></a><span id="l18.1247">   bool explicitlyVerify = false;</span>
<a href="#l18.1248"></a><span id="l18.1248"> </span>
<a href="#l18.1249"></a><span id="l18.1249">   *aNewFolder = false;</span>
<a href="#l18.1250"></a><span id="l18.1250">   nsCOMPtr&lt;nsIMsgFolder&gt; a_nsIFolder;</span>
<a href="#l18.1251"></a><span id="l18.1251">   rv = GetRootFolder(getter_AddRefs(a_nsIFolder));</span>
<a href="#l18.1252"></a><span id="l18.1252"> </span>
<a href="#l18.1253"></a><span id="l18.1253" class="difflineminus">-  if(NS_FAILED(rv))</span>
<a href="#l18.1254"></a><span id="l18.1254" class="difflineminus">-    return rv;</span>
<a href="#l18.1255"></a><span id="l18.1255" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l18.1256"></a><span id="l18.1256"> </span>
<a href="#l18.1257"></a><span id="l18.1257">   nsAutoCString dupFolderPath(folderPath);</span>
<a href="#l18.1258"></a><span id="l18.1258" class="difflineminus">-  if (dupFolderPath.Last() == '/')</span>
<a href="#l18.1259"></a><span id="l18.1259" class="difflineminus">-  {</span>
<a href="#l18.1260"></a><span id="l18.1260" class="difflineminus">-    dupFolderPath.SetLength(dupFolderPath.Length()-1);</span>
<a href="#l18.1261"></a><span id="l18.1261" class="difflineminus">-    if (dupFolderPath.IsEmpty())</span>
<a href="#l18.1262"></a><span id="l18.1262" class="difflineminus">-      return NS_ERROR_FAILURE;</span>
<a href="#l18.1263"></a><span id="l18.1263" class="difflineplus">+  if (dupFolderPath.Last() == '/') {</span>
<a href="#l18.1264"></a><span id="l18.1264" class="difflineplus">+    dupFolderPath.SetLength(dupFolderPath.Length() - 1);</span>
<a href="#l18.1265"></a><span id="l18.1265" class="difflineplus">+    if (dupFolderPath.IsEmpty()) return NS_ERROR_FAILURE;</span>
<a href="#l18.1266"></a><span id="l18.1266">     // *** this is what we did in 4.x in order to list uw folder only</span>
<a href="#l18.1267"></a><span id="l18.1267">     // mailbox in order to get the \NoSelect flag</span>
<a href="#l18.1268"></a><span id="l18.1268">     explicitlyVerify = !(boxFlags &amp; kNameSpace);</span>
<a href="#l18.1269"></a><span id="l18.1269">   }</span>
<a href="#l18.1270"></a><span id="l18.1270" class="difflineminus">-  if (mDoingSubscribeDialog)</span>
<a href="#l18.1271"></a><span id="l18.1271" class="difflineminus">-  {</span>
<a href="#l18.1272"></a><span id="l18.1272" class="difflineminus">-    // Make sure the imapmailfolder object has the right delimiter because the unsubscribed</span>
<a href="#l18.1273"></a><span id="l18.1273" class="difflineminus">-    // folders (those not in the 'lsub' list) have the delimiter set to the default ('^').</span>
<a href="#l18.1274"></a><span id="l18.1274" class="difflineminus">-    if (a_nsIFolder &amp;&amp; !dupFolderPath.IsEmpty())</span>
<a href="#l18.1275"></a><span id="l18.1275" class="difflineminus">-    {</span>
<a href="#l18.1276"></a><span id="l18.1276" class="difflineplus">+  if (mDoingSubscribeDialog) {</span>
<a href="#l18.1277"></a><span id="l18.1277" class="difflineplus">+    // Make sure the imapmailfolder object has the right delimiter because the</span>
<a href="#l18.1278"></a><span id="l18.1278" class="difflineplus">+    // unsubscribed folders (those not in the 'lsub' list) have the delimiter</span>
<a href="#l18.1279"></a><span id="l18.1279" class="difflineplus">+    // set to the default ('^').</span>
<a href="#l18.1280"></a><span id="l18.1280" class="difflineplus">+    if (a_nsIFolder &amp;&amp; !dupFolderPath.IsEmpty()) {</span>
<a href="#l18.1281"></a><span id="l18.1281">       nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l18.1282"></a><span id="l18.1282">       bool isNamespace = false;</span>
<a href="#l18.1283"></a><span id="l18.1283">       bool noSelect = false;</span>
<a href="#l18.1284"></a><span id="l18.1284"> </span>
<a href="#l18.1285"></a><span id="l18.1285">       rv = a_nsIFolder-&gt;FindSubFolder(dupFolderPath, getter_AddRefs(msgFolder));</span>
<a href="#l18.1286"></a><span id="l18.1286" class="difflineminus">-      NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.1287"></a><span id="l18.1287" class="difflineplus">+      NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.1288"></a><span id="l18.1288">       m_subscribeFolders.AppendObject(msgFolder);</span>
<a href="#l18.1289"></a><span id="l18.1289">       noSelect = (boxFlags &amp; kNoselect) != 0;</span>
<a href="#l18.1290"></a><span id="l18.1290" class="difflineminus">-      nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(msgFolder, &amp;rv);</span>
<a href="#l18.1291"></a><span id="l18.1291" class="difflineminus">-      NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.1292"></a><span id="l18.1292" class="difflineplus">+      nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder =</span>
<a href="#l18.1293"></a><span id="l18.1293" class="difflineplus">+          do_QueryInterface(msgFolder, &amp;rv);</span>
<a href="#l18.1294"></a><span id="l18.1294" class="difflineplus">+      NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.1295"></a><span id="l18.1295">       imapFolder-&gt;SetHierarchyDelimiter(hierarchyDelimiter);</span>
<a href="#l18.1296"></a><span id="l18.1296">       isNamespace = (boxFlags &amp; kNameSpace) != 0;</span>
<a href="#l18.1297"></a><span id="l18.1297">       if (!isNamespace)</span>
<a href="#l18.1298"></a><span id="l18.1298" class="difflineminus">-        rv = AddTo(dupFolderPath, mDoingLsub &amp;&amp; !noSelect/* add as subscribed */,</span>
<a href="#l18.1299"></a><span id="l18.1299" class="difflineminus">-                   !noSelect, mDoingLsub /* change if exists */);</span>
<a href="#l18.1300"></a><span id="l18.1300" class="difflineminus">-      NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.1301"></a><span id="l18.1301" class="difflineplus">+        rv = AddTo(dupFolderPath,</span>
<a href="#l18.1302"></a><span id="l18.1302" class="difflineplus">+                   mDoingLsub &amp;&amp; !noSelect /* add as subscribed */, !noSelect,</span>
<a href="#l18.1303"></a><span id="l18.1303" class="difflineplus">+                   mDoingLsub /* change if exists */);</span>
<a href="#l18.1304"></a><span id="l18.1304" class="difflineplus">+      NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.1305"></a><span id="l18.1305">       return rv;</span>
<a href="#l18.1306"></a><span id="l18.1306">     }</span>
<a href="#l18.1307"></a><span id="l18.1307">   }</span>
<a href="#l18.1308"></a><span id="l18.1308"> </span>
<a href="#l18.1309"></a><span id="l18.1309">   hostFolder = do_QueryInterface(a_nsIFolder, &amp;rv);</span>
<a href="#l18.1310"></a><span id="l18.1310" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l18.1311"></a><span id="l18.1311" class="difflineminus">-    return rv;</span>
<a href="#l18.1312"></a><span id="l18.1312" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l18.1313"></a><span id="l18.1313"> </span>
<a href="#l18.1314"></a><span id="l18.1314">   nsAutoCString tempFolderName(dupFolderPath);</span>
<a href="#l18.1315"></a><span id="l18.1315">   nsAutoCString tokenStr, remStr, changedStr;</span>
<a href="#l18.1316"></a><span id="l18.1316">   int32_t slashPos = tempFolderName.FindChar('/');</span>
<a href="#l18.1317"></a><span id="l18.1317" class="difflineminus">-  if (slashPos &gt; 0)</span>
<a href="#l18.1318"></a><span id="l18.1318" class="difflineminus">-  {</span>
<a href="#l18.1319"></a><span id="l18.1319" class="difflineplus">+  if (slashPos &gt; 0) {</span>
<a href="#l18.1320"></a><span id="l18.1320">     tokenStr = StringHead(tempFolderName, slashPos);</span>
<a href="#l18.1321"></a><span id="l18.1321">     remStr = Substring(tempFolderName, slashPos);</span>
<a href="#l18.1322"></a><span id="l18.1322" class="difflineminus">-  }</span>
<a href="#l18.1323"></a><span id="l18.1323" class="difflineminus">-  else</span>
<a href="#l18.1324"></a><span id="l18.1324" class="difflineplus">+  } else</span>
<a href="#l18.1325"></a><span id="l18.1325">     tokenStr.Assign(tempFolderName);</span>
<a href="#l18.1326"></a><span id="l18.1326"> </span>
<a href="#l18.1327"></a><span id="l18.1327" class="difflineminus">-  if ((int32_t(PL_strcasecmp(tokenStr.get(), &quot;INBOX&quot;))==0) &amp;&amp; (strcmp(tokenStr.get(), &quot;INBOX&quot;) != 0))</span>
<a href="#l18.1328"></a><span id="l18.1328" class="difflineplus">+  if ((int32_t(PL_strcasecmp(tokenStr.get(), &quot;INBOX&quot;)) == 0) &amp;&amp;</span>
<a href="#l18.1329"></a><span id="l18.1329" class="difflineplus">+      (strcmp(tokenStr.get(), &quot;INBOX&quot;) != 0))</span>
<a href="#l18.1330"></a><span id="l18.1330">     changedStr.AppendLiteral(&quot;INBOX&quot;);</span>
<a href="#l18.1331"></a><span id="l18.1331">   else</span>
<a href="#l18.1332"></a><span id="l18.1332">     changedStr.Append(tokenStr);</span>
<a href="#l18.1333"></a><span id="l18.1333"> </span>
<a href="#l18.1334"></a><span id="l18.1334" class="difflineminus">-  if (slashPos &gt; 0 )</span>
<a href="#l18.1335"></a><span id="l18.1335" class="difflineminus">-    changedStr.Append(remStr);</span>
<a href="#l18.1336"></a><span id="l18.1336" class="difflineplus">+  if (slashPos &gt; 0) changedStr.Append(remStr);</span>
<a href="#l18.1337"></a><span id="l18.1337"> </span>
<a href="#l18.1338"></a><span id="l18.1338">   dupFolderPath.Assign(changedStr);</span>
<a href="#l18.1339"></a><span id="l18.1339">   nsAutoCString folderName(dupFolderPath);</span>
<a href="#l18.1340"></a><span id="l18.1340"> </span>
<a href="#l18.1341"></a><span id="l18.1341">   nsAutoCString uri;</span>
<a href="#l18.1342"></a><span id="l18.1342">   nsCString serverUri;</span>
<a href="#l18.1343"></a><span id="l18.1343">   GetServerURI(serverUri);</span>
<a href="#l18.1344"></a><span id="l18.1344">   uri.Assign(serverUri);</span>
<a href="#l18.1345"></a><span id="l18.1345">   int32_t leafPos = folderName.RFindChar('/');</span>
<a href="#l18.1346"></a><span id="l18.1346">   nsAutoCString parentName(folderName);</span>
<a href="#l18.1347"></a><span id="l18.1347">   nsAutoCString parentUri(uri);</span>
<a href="#l18.1348"></a><span id="l18.1348"> </span>
<a href="#l18.1349"></a><span id="l18.1349" class="difflineminus">-  if (leafPos &gt; 0)</span>
<a href="#l18.1350"></a><span id="l18.1350" class="difflineminus">-  {</span>
<a href="#l18.1351"></a><span id="l18.1351" class="difflineplus">+  if (leafPos &gt; 0) {</span>
<a href="#l18.1352"></a><span id="l18.1352">     // If there is a hierarchy, there is a parent.</span>
<a href="#l18.1353"></a><span id="l18.1353">     // Don't strip off slash if it's the first character</span>
<a href="#l18.1354"></a><span id="l18.1354">     parentName.SetLength(leafPos);</span>
<a href="#l18.1355"></a><span id="l18.1355">     folderName.Cut(0, leafPos + 1);  // get rid of the parent name</span>
<a href="#l18.1356"></a><span id="l18.1356">     haveParent = true;</span>
<a href="#l18.1357"></a><span id="l18.1357">     parentUri.Append('/');</span>
<a href="#l18.1358"></a><span id="l18.1358">     parentUri.Append(parentName);</span>
<a href="#l18.1359"></a><span id="l18.1359">   }</span>
<a href="#l18.1360"></a><span id="l18.1360">   if (MsgLowerCaseEqualsLiteral(folderPath, &quot;inbox&quot;) &amp;&amp;</span>
<a href="#l18.1361"></a><span id="l18.1361" class="difflineminus">-    hierarchyDelimiter == kOnlineHierarchySeparatorNil)</span>
<a href="#l18.1362"></a><span id="l18.1362" class="difflineminus">-  {</span>
<a href="#l18.1363"></a><span id="l18.1363" class="difflineminus">-    hierarchyDelimiter = '/'; // set to default in this case (as in 4.x)</span>
<a href="#l18.1364"></a><span id="l18.1364" class="difflineplus">+      hierarchyDelimiter == kOnlineHierarchySeparatorNil) {</span>
<a href="#l18.1365"></a><span id="l18.1365" class="difflineplus">+    hierarchyDelimiter = '/';  // set to default in this case (as in 4.x)</span>
<a href="#l18.1366"></a><span id="l18.1366">     hostFolder-&gt;SetHierarchyDelimiter(hierarchyDelimiter);</span>
<a href="#l18.1367"></a><span id="l18.1367">   }</span>
<a href="#l18.1368"></a><span id="l18.1368"> </span>
<a href="#l18.1369"></a><span id="l18.1369" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; child;</span>
<a href="#l18.1370"></a><span id="l18.1370" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; child;</span>
<a href="#l18.1371"></a><span id="l18.1371"> </span>
<a href="#l18.1372"></a><span id="l18.1372">   // nsCString possibleName(aSpec-&gt;allocatedPathName);</span>
<a href="#l18.1373"></a><span id="l18.1373">   uri.Append('/');</span>
<a href="#l18.1374"></a><span id="l18.1374">   uri.Append(dupFolderPath);</span>
<a href="#l18.1375"></a><span id="l18.1375">   bool caseInsensitive = MsgLowerCaseEqualsLiteral(dupFolderPath, &quot;inbox&quot;);</span>
<a href="#l18.1376"></a><span id="l18.1376" class="difflineminus">-  a_nsIFolder-&gt;GetChildWithURI(uri, true, caseInsensitive, getter_AddRefs(child));</span>
<a href="#l18.1377"></a><span id="l18.1377" class="difflineminus">-  // if we couldn't find this folder by URI, tell the imap code it's a new folder to us</span>
<a href="#l18.1378"></a><span id="l18.1378" class="difflineplus">+  a_nsIFolder-&gt;GetChildWithURI(uri, true, caseInsensitive,</span>
<a href="#l18.1379"></a><span id="l18.1379" class="difflineplus">+                               getter_AddRefs(child));</span>
<a href="#l18.1380"></a><span id="l18.1380" class="difflineplus">+  // if we couldn't find this folder by URI, tell the imap code it's a new</span>
<a href="#l18.1381"></a><span id="l18.1381" class="difflineplus">+  // folder to us</span>
<a href="#l18.1382"></a><span id="l18.1382">   *aNewFolder = !child;</span>
<a href="#l18.1383"></a><span id="l18.1383" class="difflineminus">-  if (child)</span>
<a href="#l18.1384"></a><span id="l18.1384" class="difflineminus">-    found = true;</span>
<a href="#l18.1385"></a><span id="l18.1385" class="difflineminus">-  if (!found)</span>
<a href="#l18.1386"></a><span id="l18.1386" class="difflineminus">-  {</span>
<a href="#l18.1387"></a><span id="l18.1387" class="difflineplus">+  if (child) found = true;</span>
<a href="#l18.1388"></a><span id="l18.1388" class="difflineplus">+  if (!found) {</span>
<a href="#l18.1389"></a><span id="l18.1389">     // trying to find/discover the parent</span>
<a href="#l18.1390"></a><span id="l18.1390" class="difflineminus">-    if (haveParent)</span>
<a href="#l18.1391"></a><span id="l18.1391" class="difflineminus">-    {</span>
<a href="#l18.1392"></a><span id="l18.1392" class="difflineminus">-      nsCOMPtr &lt;nsIMsgFolder&gt; parent;</span>
<a href="#l18.1393"></a><span id="l18.1393" class="difflineplus">+    if (haveParent) {</span>
<a href="#l18.1394"></a><span id="l18.1394" class="difflineplus">+      nsCOMPtr&lt;nsIMsgFolder&gt; parent;</span>
<a href="#l18.1395"></a><span id="l18.1395">       bool parentIsNew;</span>
<a href="#l18.1396"></a><span id="l18.1396">       caseInsensitive = MsgLowerCaseEqualsLiteral(parentName, &quot;inbox&quot;);</span>
<a href="#l18.1397"></a><span id="l18.1397" class="difflineminus">-      a_nsIFolder-&gt;GetChildWithURI(parentUri, true, caseInsensitive, getter_AddRefs(parent));</span>
<a href="#l18.1398"></a><span id="l18.1398" class="difflineminus">-      if (!parent /* || parentFolder-&gt;GetFolderNeedsAdded()*/)</span>
<a href="#l18.1399"></a><span id="l18.1399" class="difflineminus">-      {</span>
<a href="#l18.1400"></a><span id="l18.1400" class="difflineminus">-        PossibleImapMailbox(parentName, hierarchyDelimiter, kNoselect | // be defensive</span>
<a href="#l18.1401"></a><span id="l18.1401" class="difflineminus">-          ((boxFlags  &amp; //only inherit certain flags from the child</span>
<a href="#l18.1402"></a><span id="l18.1402" class="difflineminus">-          (kPublicMailbox | kOtherUsersMailbox | kPersonalMailbox))), &amp;parentIsNew);</span>
<a href="#l18.1403"></a><span id="l18.1403" class="difflineplus">+      a_nsIFolder-&gt;GetChildWithURI(parentUri, true, caseInsensitive,</span>
<a href="#l18.1404"></a><span id="l18.1404" class="difflineplus">+                                   getter_AddRefs(parent));</span>
<a href="#l18.1405"></a><span id="l18.1405" class="difflineplus">+      if (!parent /* || parentFolder-&gt;GetFolderNeedsAdded()*/) {</span>
<a href="#l18.1406"></a><span id="l18.1406" class="difflineplus">+        PossibleImapMailbox(</span>
<a href="#l18.1407"></a><span id="l18.1407" class="difflineplus">+            parentName, hierarchyDelimiter,</span>
<a href="#l18.1408"></a><span id="l18.1408" class="difflineplus">+            kNoselect |       // be defensive</span>
<a href="#l18.1409"></a><span id="l18.1409" class="difflineplus">+                ((boxFlags &amp;  // only inherit certain flags from the child</span>
<a href="#l18.1410"></a><span id="l18.1410" class="difflineplus">+                  (kPublicMailbox | kOtherUsersMailbox | kPersonalMailbox))),</span>
<a href="#l18.1411"></a><span id="l18.1411" class="difflineplus">+            &amp;parentIsNew);</span>
<a href="#l18.1412"></a><span id="l18.1412">       }</span>
<a href="#l18.1413"></a><span id="l18.1413">     }</span>
<a href="#l18.1414"></a><span id="l18.1414" class="difflineminus">-    rv = hostFolder-&gt;CreateClientSubfolderInfo(dupFolderPath, hierarchyDelimiter,boxFlags, false);</span>
<a href="#l18.1415"></a><span id="l18.1415" class="difflineplus">+    rv = hostFolder-&gt;CreateClientSubfolderInfo(</span>
<a href="#l18.1416"></a><span id="l18.1416" class="difflineplus">+        dupFolderPath, hierarchyDelimiter, boxFlags, false);</span>
<a href="#l18.1417"></a><span id="l18.1417">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.1418"></a><span id="l18.1418">     caseInsensitive = MsgLowerCaseEqualsLiteral(dupFolderPath, &quot;inbox&quot;);</span>
<a href="#l18.1419"></a><span id="l18.1419" class="difflineminus">-    a_nsIFolder-&gt;GetChildWithURI(uri, true, caseInsensitive, getter_AddRefs(child));</span>
<a href="#l18.1420"></a><span id="l18.1420" class="difflineplus">+    a_nsIFolder-&gt;GetChildWithURI(uri, true, caseInsensitive,</span>
<a href="#l18.1421"></a><span id="l18.1421" class="difflineplus">+                                 getter_AddRefs(child));</span>
<a href="#l18.1422"></a><span id="l18.1422">   }</span>
<a href="#l18.1423"></a><span id="l18.1423" class="difflineminus">-  if (child)</span>
<a href="#l18.1424"></a><span id="l18.1424" class="difflineminus">-  {</span>
<a href="#l18.1425"></a><span id="l18.1425" class="difflineminus">-    nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(child);</span>
<a href="#l18.1426"></a><span id="l18.1426" class="difflineminus">-    if (imapFolder)</span>
<a href="#l18.1427"></a><span id="l18.1427" class="difflineminus">-    {</span>
<a href="#l18.1428"></a><span id="l18.1428" class="difflineplus">+  if (child) {</span>
<a href="#l18.1429"></a><span id="l18.1429" class="difflineplus">+    nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(child);</span>
<a href="#l18.1430"></a><span id="l18.1430" class="difflineplus">+    if (imapFolder) {</span>
<a href="#l18.1431"></a><span id="l18.1431">       nsAutoCString onlineName;</span>
<a href="#l18.1432"></a><span id="l18.1432">       nsAutoString unicodeName;</span>
<a href="#l18.1433"></a><span id="l18.1433">       imapFolder-&gt;SetVerifiedAsOnlineFolder(true);</span>
<a href="#l18.1434"></a><span id="l18.1434">       imapFolder-&gt;SetHierarchyDelimiter(hierarchyDelimiter);</span>
<a href="#l18.1435"></a><span id="l18.1435" class="difflineminus">-      if (boxFlags &amp; kImapTrash)</span>
<a href="#l18.1436"></a><span id="l18.1436" class="difflineminus">-      {</span>
<a href="#l18.1437"></a><span id="l18.1437" class="difflineplus">+      if (boxFlags &amp; kImapTrash) {</span>
<a href="#l18.1438"></a><span id="l18.1438">         int32_t deleteModel;</span>
<a href="#l18.1439"></a><span id="l18.1439">         GetDeleteModel(&amp;deleteModel);</span>
<a href="#l18.1440"></a><span id="l18.1440">         if (deleteModel == nsMsgImapDeleteModels::MoveToTrash)</span>
<a href="#l18.1441"></a><span id="l18.1441">           child-&gt;SetFlag(nsMsgFolderFlags::Trash);</span>
<a href="#l18.1442"></a><span id="l18.1442">       }</span>
<a href="#l18.1443"></a><span id="l18.1443"> </span>
<a href="#l18.1444"></a><span id="l18.1444">       imapFolder-&gt;SetBoxFlags(boxFlags);</span>
<a href="#l18.1445"></a><span id="l18.1445">       imapFolder-&gt;SetExplicitlyVerify(explicitlyVerify);</span>
<a href="#l18.1446"></a><span id="l18.1446" class="difflineat">@@ -1205,356 +1106,323 @@ NS_IMETHODIMP nsImapIncomingServer::Poss</span>
<a href="#l18.1447"></a><span id="l18.1447"> </span>
<a href="#l18.1448"></a><span id="l18.1448">       if (hierarchyDelimiter != '/')</span>
<a href="#l18.1449"></a><span id="l18.1449">         nsImapUrl::UnescapeSlashes(folderName.BeginWriting());</span>
<a href="#l18.1450"></a><span id="l18.1450">       if (NS_SUCCEEDED(CopyMUTF7toUTF16(folderName, unicodeName)))</span>
<a href="#l18.1451"></a><span id="l18.1451">         child-&gt;SetPrettyName(unicodeName);</span>
<a href="#l18.1452"></a><span id="l18.1452">     }</span>
<a href="#l18.1453"></a><span id="l18.1453">   }</span>
<a href="#l18.1454"></a><span id="l18.1454">   if (!found &amp;&amp; child)</span>
<a href="#l18.1455"></a><span id="l18.1455" class="difflineminus">-    child-&gt;SetMsgDatabase(nullptr); // close the db, so we don't hold open all the .msf files for new folders</span>
<a href="#l18.1456"></a><span id="l18.1456" class="difflineplus">+    child-&gt;SetMsgDatabase(nullptr);  // close the db, so we don't hold open all</span>
<a href="#l18.1457"></a><span id="l18.1457" class="difflineplus">+                                     // the .msf files for new folders</span>
<a href="#l18.1458"></a><span id="l18.1458">   return NS_OK;</span>
<a href="#l18.1459"></a><span id="l18.1459"> }</span>
<a href="#l18.1460"></a><span id="l18.1460"> </span>
<a href="#l18.1461"></a><span id="l18.1461" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::AddFolderRights(const nsACString&amp; mailboxName, const nsACString&amp; userName,</span>
<a href="#l18.1462"></a><span id="l18.1462" class="difflineminus">-                                                    const nsACString&amp; rights)</span>
<a href="#l18.1463"></a><span id="l18.1463" class="difflineminus">-{</span>
<a href="#l18.1464"></a><span id="l18.1464" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.1465"></a><span id="l18.1465" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::AddFolderRights(</span>
<a href="#l18.1466"></a><span id="l18.1466" class="difflineplus">+    const nsACString &amp;mailboxName, const nsACString &amp;userName,</span>
<a href="#l18.1467"></a><span id="l18.1467" class="difflineplus">+    const nsACString &amp;rights) {</span>
<a href="#l18.1468"></a><span id="l18.1468" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.1469"></a><span id="l18.1469">   nsresult rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l18.1470"></a><span id="l18.1470" class="difflineminus">-  if(NS_SUCCEEDED(rv) &amp;&amp; rootFolder)</span>
<a href="#l18.1471"></a><span id="l18.1471" class="difflineminus">-  {</span>
<a href="#l18.1472"></a><span id="l18.1472" class="difflineminus">-    nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapRoot = do_QueryInterface(rootFolder);</span>
<a href="#l18.1473"></a><span id="l18.1473" class="difflineminus">-    if (imapRoot)</span>
<a href="#l18.1474"></a><span id="l18.1474" class="difflineminus">-    {</span>
<a href="#l18.1475"></a><span id="l18.1475" class="difflineminus">-      nsCOMPtr &lt;nsIMsgImapMailFolder&gt; foundFolder;</span>
<a href="#l18.1476"></a><span id="l18.1476" class="difflineminus">-      rv = imapRoot-&gt;FindOnlineSubFolder(mailboxName, getter_AddRefs(foundFolder));</span>
<a href="#l18.1477"></a><span id="l18.1477" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder) {</span>
<a href="#l18.1478"></a><span id="l18.1478" class="difflineplus">+    nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapRoot = do_QueryInterface(rootFolder);</span>
<a href="#l18.1479"></a><span id="l18.1479" class="difflineplus">+    if (imapRoot) {</span>
<a href="#l18.1480"></a><span id="l18.1480" class="difflineplus">+      nsCOMPtr&lt;nsIMsgImapMailFolder&gt; foundFolder;</span>
<a href="#l18.1481"></a><span id="l18.1481" class="difflineplus">+      rv = imapRoot-&gt;FindOnlineSubFolder(mailboxName,</span>
<a href="#l18.1482"></a><span id="l18.1482" class="difflineplus">+                                         getter_AddRefs(foundFolder));</span>
<a href="#l18.1483"></a><span id="l18.1483">       if (NS_SUCCEEDED(rv) &amp;&amp; foundFolder)</span>
<a href="#l18.1484"></a><span id="l18.1484">         return foundFolder-&gt;AddFolderRights(userName, rights);</span>
<a href="#l18.1485"></a><span id="l18.1485">     }</span>
<a href="#l18.1486"></a><span id="l18.1486">   }</span>
<a href="#l18.1487"></a><span id="l18.1487">   return rv;</span>
<a href="#l18.1488"></a><span id="l18.1488"> }</span>
<a href="#l18.1489"></a><span id="l18.1489"> </span>
<a href="#l18.1490"></a><span id="l18.1490" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::FolderNeedsACLInitialized(const nsACString&amp; folderPath,</span>
<a href="#l18.1491"></a><span id="l18.1491" class="difflineminus">-                                                              bool *aNeedsACLInitialized)</span>
<a href="#l18.1492"></a><span id="l18.1492" class="difflineminus">-{</span>
<a href="#l18.1493"></a><span id="l18.1493" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::FolderNeedsACLInitialized(</span>
<a href="#l18.1494"></a><span id="l18.1494" class="difflineplus">+    const nsACString &amp;folderPath, bool *aNeedsACLInitialized) {</span>
<a href="#l18.1495"></a><span id="l18.1495">   NS_ENSURE_ARG_POINTER(aNeedsACLInitialized);</span>
<a href="#l18.1496"></a><span id="l18.1496" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.1497"></a><span id="l18.1497" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.1498"></a><span id="l18.1498">   nsresult rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l18.1499"></a><span id="l18.1499" class="difflineminus">-  if(NS_SUCCEEDED(rv) &amp;&amp; rootFolder)</span>
<a href="#l18.1500"></a><span id="l18.1500" class="difflineminus">-  {</span>
<a href="#l18.1501"></a><span id="l18.1501" class="difflineminus">-    nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapRoot = do_QueryInterface(rootFolder);</span>
<a href="#l18.1502"></a><span id="l18.1502" class="difflineminus">-    if (imapRoot)</span>
<a href="#l18.1503"></a><span id="l18.1503" class="difflineminus">-    {</span>
<a href="#l18.1504"></a><span id="l18.1504" class="difflineminus">-      nsCOMPtr &lt;nsIMsgImapMailFolder&gt; foundFolder;</span>
<a href="#l18.1505"></a><span id="l18.1505" class="difflineminus">-      rv = imapRoot-&gt;FindOnlineSubFolder(folderPath, getter_AddRefs(foundFolder));</span>
<a href="#l18.1506"></a><span id="l18.1506" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; foundFolder)</span>
<a href="#l18.1507"></a><span id="l18.1507" class="difflineminus">-      {</span>
<a href="#l18.1508"></a><span id="l18.1508" class="difflineminus">-        nsCOMPtr &lt;nsIImapMailFolderSink&gt; folderSink = do_QueryInterface(foundFolder);</span>
<a href="#l18.1509"></a><span id="l18.1509" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder) {</span>
<a href="#l18.1510"></a><span id="l18.1510" class="difflineplus">+    nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapRoot = do_QueryInterface(rootFolder);</span>
<a href="#l18.1511"></a><span id="l18.1511" class="difflineplus">+    if (imapRoot) {</span>
<a href="#l18.1512"></a><span id="l18.1512" class="difflineplus">+      nsCOMPtr&lt;nsIMsgImapMailFolder&gt; foundFolder;</span>
<a href="#l18.1513"></a><span id="l18.1513" class="difflineplus">+      rv = imapRoot-&gt;FindOnlineSubFolder(folderPath,</span>
<a href="#l18.1514"></a><span id="l18.1514" class="difflineplus">+                                         getter_AddRefs(foundFolder));</span>
<a href="#l18.1515"></a><span id="l18.1515" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; foundFolder) {</span>
<a href="#l18.1516"></a><span id="l18.1516" class="difflineplus">+        nsCOMPtr&lt;nsIImapMailFolderSink&gt; folderSink =</span>
<a href="#l18.1517"></a><span id="l18.1517" class="difflineplus">+            do_QueryInterface(foundFolder);</span>
<a href="#l18.1518"></a><span id="l18.1518">         if (folderSink)</span>
<a href="#l18.1519"></a><span id="l18.1519">           return folderSink-&gt;GetFolderNeedsACLListed(aNeedsACLInitialized);</span>
<a href="#l18.1520"></a><span id="l18.1520">       }</span>
<a href="#l18.1521"></a><span id="l18.1521">     }</span>
<a href="#l18.1522"></a><span id="l18.1522">   }</span>
<a href="#l18.1523"></a><span id="l18.1523" class="difflineminus">-  *aNeedsACLInitialized = false; // maybe we want to say TRUE here...</span>
<a href="#l18.1524"></a><span id="l18.1524" class="difflineplus">+  *aNeedsACLInitialized = false;  // maybe we want to say TRUE here...</span>
<a href="#l18.1525"></a><span id="l18.1525">   return NS_OK;</span>
<a href="#l18.1526"></a><span id="l18.1526"> }</span>
<a href="#l18.1527"></a><span id="l18.1527"> </span>
<a href="#l18.1528"></a><span id="l18.1528" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::RefreshFolderRights(const nsACString&amp; folderPath)</span>
<a href="#l18.1529"></a><span id="l18.1529" class="difflineminus">-{</span>
<a href="#l18.1530"></a><span id="l18.1530" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.1531"></a><span id="l18.1531" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::RefreshFolderRights(</span>
<a href="#l18.1532"></a><span id="l18.1532" class="difflineplus">+    const nsACString &amp;folderPath) {</span>
<a href="#l18.1533"></a><span id="l18.1533" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.1534"></a><span id="l18.1534">   nsresult rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l18.1535"></a><span id="l18.1535" class="difflineminus">-  if(NS_SUCCEEDED(rv) &amp;&amp; rootFolder)</span>
<a href="#l18.1536"></a><span id="l18.1536" class="difflineminus">-  {</span>
<a href="#l18.1537"></a><span id="l18.1537" class="difflineminus">-    nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapRoot = do_QueryInterface(rootFolder);</span>
<a href="#l18.1538"></a><span id="l18.1538" class="difflineminus">-    if (imapRoot)</span>
<a href="#l18.1539"></a><span id="l18.1539" class="difflineminus">-    {</span>
<a href="#l18.1540"></a><span id="l18.1540" class="difflineminus">-      nsCOMPtr &lt;nsIMsgImapMailFolder&gt; foundFolder;</span>
<a href="#l18.1541"></a><span id="l18.1541" class="difflineminus">-      rv = imapRoot-&gt;FindOnlineSubFolder(folderPath, getter_AddRefs(foundFolder));</span>
<a href="#l18.1542"></a><span id="l18.1542" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder) {</span>
<a href="#l18.1543"></a><span id="l18.1543" class="difflineplus">+    nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapRoot = do_QueryInterface(rootFolder);</span>
<a href="#l18.1544"></a><span id="l18.1544" class="difflineplus">+    if (imapRoot) {</span>
<a href="#l18.1545"></a><span id="l18.1545" class="difflineplus">+      nsCOMPtr&lt;nsIMsgImapMailFolder&gt; foundFolder;</span>
<a href="#l18.1546"></a><span id="l18.1546" class="difflineplus">+      rv = imapRoot-&gt;FindOnlineSubFolder(folderPath,</span>
<a href="#l18.1547"></a><span id="l18.1547" class="difflineplus">+                                         getter_AddRefs(foundFolder));</span>
<a href="#l18.1548"></a><span id="l18.1548">       if (NS_SUCCEEDED(rv) &amp;&amp; foundFolder)</span>
<a href="#l18.1549"></a><span id="l18.1549">         return foundFolder-&gt;RefreshFolderRights();</span>
<a href="#l18.1550"></a><span id="l18.1550">     }</span>
<a href="#l18.1551"></a><span id="l18.1551">   }</span>
<a href="#l18.1552"></a><span id="l18.1552">   return rv;</span>
<a href="#l18.1553"></a><span id="l18.1553"> }</span>
<a href="#l18.1554"></a><span id="l18.1554"> </span>
<a href="#l18.1555"></a><span id="l18.1555" class="difflineminus">-nsresult nsImapIncomingServer::GetFolder(const nsACString&amp; name, nsIMsgFolder** pFolder)</span>
<a href="#l18.1556"></a><span id="l18.1556" class="difflineminus">-{</span>
<a href="#l18.1557"></a><span id="l18.1557" class="difflineplus">+nsresult nsImapIncomingServer::GetFolder(const nsACString &amp;name,</span>
<a href="#l18.1558"></a><span id="l18.1558" class="difflineplus">+                                         nsIMsgFolder **pFolder) {</span>
<a href="#l18.1559"></a><span id="l18.1559">   NS_ENSURE_ARG_POINTER(pFolder);</span>
<a href="#l18.1560"></a><span id="l18.1560">   NS_ENSURE_TRUE(!name.IsEmpty(), NS_ERROR_FAILURE);</span>
<a href="#l18.1561"></a><span id="l18.1561">   nsresult rv;</span>
<a href="#l18.1562"></a><span id="l18.1562">   *pFolder = nullptr;</span>
<a href="#l18.1563"></a><span id="l18.1563"> </span>
<a href="#l18.1564"></a><span id="l18.1564">   nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.1565"></a><span id="l18.1565">   rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l18.1566"></a><span id="l18.1566" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder)</span>
<a href="#l18.1567"></a><span id="l18.1567" class="difflineminus">-  {</span>
<a href="#l18.1568"></a><span id="l18.1568" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder) {</span>
<a href="#l18.1569"></a><span id="l18.1569">     nsCString uri;</span>
<a href="#l18.1570"></a><span id="l18.1570">     rv = rootFolder-&gt;GetURI(uri);</span>
<a href="#l18.1571"></a><span id="l18.1571" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; !uri.IsEmpty())</span>
<a href="#l18.1572"></a><span id="l18.1572" class="difflineminus">-    {</span>
<a href="#l18.1573"></a><span id="l18.1573" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; !uri.IsEmpty()) {</span>
<a href="#l18.1574"></a><span id="l18.1574">       nsAutoCString uriString(uri);</span>
<a href="#l18.1575"></a><span id="l18.1575">       uriString.Append('/');</span>
<a href="#l18.1576"></a><span id="l18.1576">       uriString.Append(name);</span>
<a href="#l18.1577"></a><span id="l18.1577">       rv = GetOrCreateFolder(uriString, pFolder);</span>
<a href="#l18.1578"></a><span id="l18.1578">     }</span>
<a href="#l18.1579"></a><span id="l18.1579">   }</span>
<a href="#l18.1580"></a><span id="l18.1580">   return rv;</span>
<a href="#l18.1581"></a><span id="l18.1581"> }</span>
<a href="#l18.1582"></a><span id="l18.1582"> </span>
<a href="#l18.1583"></a><span id="l18.1583" class="difflineminus">-NS_IMETHODIMP  nsImapIncomingServer::OnlineFolderDelete(const nsACString&amp; aFolderName)</span>
<a href="#l18.1584"></a><span id="l18.1584" class="difflineminus">-{</span>
<a href="#l18.1585"></a><span id="l18.1585" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::OnlineFolderDelete(</span>
<a href="#l18.1586"></a><span id="l18.1586" class="difflineplus">+    const nsACString &amp;aFolderName) {</span>
<a href="#l18.1587"></a><span id="l18.1587">   return NS_OK;</span>
<a href="#l18.1588"></a><span id="l18.1588"> }</span>
<a href="#l18.1589"></a><span id="l18.1589"> </span>
<a href="#l18.1590"></a><span id="l18.1590" class="difflineminus">-NS_IMETHODIMP  nsImapIncomingServer::OnlineFolderCreateFailed(const nsACString&amp; aFolderName)</span>
<a href="#l18.1591"></a><span id="l18.1591" class="difflineminus">-{</span>
<a href="#l18.1592"></a><span id="l18.1592" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::OnlineFolderCreateFailed(</span>
<a href="#l18.1593"></a><span id="l18.1593" class="difflineplus">+    const nsACString &amp;aFolderName) {</span>
<a href="#l18.1594"></a><span id="l18.1594">   return NS_OK;</span>
<a href="#l18.1595"></a><span id="l18.1595"> }</span>
<a href="#l18.1596"></a><span id="l18.1596"> </span>
<a href="#l18.1597"></a><span id="l18.1597" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::OnlineFolderRename(nsIMsgWindow *msgWindow, const nsACString&amp; oldName,</span>
<a href="#l18.1598"></a><span id="l18.1598" class="difflineminus">-                                                       const nsACString&amp; newName)</span>
<a href="#l18.1599"></a><span id="l18.1599" class="difflineminus">-{</span>
<a href="#l18.1600"></a><span id="l18.1600" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::OnlineFolderRename(</span>
<a href="#l18.1601"></a><span id="l18.1601" class="difflineplus">+    nsIMsgWindow *msgWindow, const nsACString &amp;oldName,</span>
<a href="#l18.1602"></a><span id="l18.1602" class="difflineplus">+    const nsACString &amp;newName) {</span>
<a href="#l18.1603"></a><span id="l18.1603">   nsresult rv = NS_ERROR_FAILURE;</span>
<a href="#l18.1604"></a><span id="l18.1604" class="difflineminus">-  if (!newName.IsEmpty())</span>
<a href="#l18.1605"></a><span id="l18.1605" class="difflineminus">-  {</span>
<a href="#l18.1606"></a><span id="l18.1606" class="difflineplus">+  if (!newName.IsEmpty()) {</span>
<a href="#l18.1607"></a><span id="l18.1607">     nsCOMPtr&lt;nsIMsgFolder&gt; me;</span>
<a href="#l18.1608"></a><span id="l18.1608">     rv = GetFolder(oldName, getter_AddRefs(me));</span>
<a href="#l18.1609"></a><span id="l18.1609" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l18.1610"></a><span id="l18.1610" class="difflineminus">-      return rv;</span>
<a href="#l18.1611"></a><span id="l18.1611" class="difflineplus">+    if (NS_FAILED(rv)) return rv;</span>
<a href="#l18.1612"></a><span id="l18.1612"> </span>
<a href="#l18.1613"></a><span id="l18.1613">     nsCOMPtr&lt;nsIMsgFolder&gt; parent;</span>
<a href="#l18.1614"></a><span id="l18.1614" class="difflineminus">-    nsCString tmpNewName (newName);</span>
<a href="#l18.1615"></a><span id="l18.1615" class="difflineplus">+    nsCString tmpNewName(newName);</span>
<a href="#l18.1616"></a><span id="l18.1616">     int32_t folderStart = tmpNewName.RFindChar('/');</span>
<a href="#l18.1617"></a><span id="l18.1617" class="difflineminus">-    if (folderStart &gt; 0)</span>
<a href="#l18.1618"></a><span id="l18.1618" class="difflineminus">-    {</span>
<a href="#l18.1619"></a><span id="l18.1619" class="difflineminus">-      rv = GetFolder(StringHead(tmpNewName, folderStart), getter_AddRefs(parent));</span>
<a href="#l18.1620"></a><span id="l18.1620" class="difflineminus">-    }</span>
<a href="#l18.1621"></a><span id="l18.1621" class="difflineminus">-    else  // root is the parent</span>
<a href="#l18.1622"></a><span id="l18.1622" class="difflineplus">+    if (folderStart &gt; 0) {</span>
<a href="#l18.1623"></a><span id="l18.1623" class="difflineplus">+      rv = GetFolder(StringHead(tmpNewName, folderStart),</span>
<a href="#l18.1624"></a><span id="l18.1624" class="difflineplus">+                     getter_AddRefs(parent));</span>
<a href="#l18.1625"></a><span id="l18.1625" class="difflineplus">+    } else  // root is the parent</span>
<a href="#l18.1626"></a><span id="l18.1626">       rv = GetRootFolder(getter_AddRefs(parent));</span>
<a href="#l18.1627"></a><span id="l18.1627" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; parent)</span>
<a href="#l18.1628"></a><span id="l18.1628" class="difflineminus">-    {</span>
<a href="#l18.1629"></a><span id="l18.1629" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; parent) {</span>
<a href="#l18.1630"></a><span id="l18.1630">       nsCOMPtr&lt;nsIMsgImapMailFolder&gt; folder;</span>
<a href="#l18.1631"></a><span id="l18.1631">       folder = do_QueryInterface(me, &amp;rv);</span>
<a href="#l18.1632"></a><span id="l18.1632" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l18.1633"></a><span id="l18.1633" class="difflineminus">-      {</span>
<a href="#l18.1634"></a><span id="l18.1634" class="difflineplus">+      if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.1635"></a><span id="l18.1635">         folder-&gt;RenameLocal(tmpNewName, parent);</span>
<a href="#l18.1636"></a><span id="l18.1636" class="difflineminus">-        nsCOMPtr&lt;nsIMsgImapMailFolder&gt; parentImapFolder = do_QueryInterface(parent);</span>
<a href="#l18.1637"></a><span id="l18.1637" class="difflineplus">+        nsCOMPtr&lt;nsIMsgImapMailFolder&gt; parentImapFolder =</span>
<a href="#l18.1638"></a><span id="l18.1638" class="difflineplus">+            do_QueryInterface(parent);</span>
<a href="#l18.1639"></a><span id="l18.1639"> </span>
<a href="#l18.1640"></a><span id="l18.1640">         if (parentImapFolder)</span>
<a href="#l18.1641"></a><span id="l18.1641">           parentImapFolder-&gt;RenameClient(msgWindow, me, oldName, tmpNewName);</span>
<a href="#l18.1642"></a><span id="l18.1642"> </span>
<a href="#l18.1643"></a><span id="l18.1643" class="difflineminus">-        nsCOMPtr &lt;nsIMsgFolder&gt; newFolder;</span>
<a href="#l18.1644"></a><span id="l18.1644" class="difflineplus">+        nsCOMPtr&lt;nsIMsgFolder&gt; newFolder;</span>
<a href="#l18.1645"></a><span id="l18.1645">         nsString unicodeNewName;</span>
<a href="#l18.1646"></a><span id="l18.1646">         // tmpNewName is imap mod utf7. It needs to be convert to utf8.</span>
<a href="#l18.1647"></a><span id="l18.1647">         CopyMUTF7toUTF16(tmpNewName, unicodeNewName);</span>
<a href="#l18.1648"></a><span id="l18.1648">         CopyUTF16toUTF8(unicodeNewName, tmpNewName);</span>
<a href="#l18.1649"></a><span id="l18.1649">         rv = GetFolder(tmpNewName, getter_AddRefs(newFolder));</span>
<a href="#l18.1650"></a><span id="l18.1650" class="difflineminus">-        if (NS_SUCCEEDED(rv))</span>
<a href="#l18.1651"></a><span id="l18.1651" class="difflineminus">-        {</span>
<a href="#l18.1652"></a><span id="l18.1652" class="difflineplus">+        if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.1653"></a><span id="l18.1653">           newFolder-&gt;NotifyFolderEvent(kRenameCompleted);</span>
<a href="#l18.1654"></a><span id="l18.1654">         }</span>
<a href="#l18.1655"></a><span id="l18.1655">       }</span>
<a href="#l18.1656"></a><span id="l18.1656">     }</span>
<a href="#l18.1657"></a><span id="l18.1657">   }</span>
<a href="#l18.1658"></a><span id="l18.1658">   return rv;</span>
<a href="#l18.1659"></a><span id="l18.1659"> }</span>
<a href="#l18.1660"></a><span id="l18.1660"> </span>
<a href="#l18.1661"></a><span id="l18.1661" class="difflineminus">-NS_IMETHODIMP  nsImapIncomingServer::FolderIsNoSelect(const nsACString&amp; aFolderName, bool *result)</span>
<a href="#l18.1662"></a><span id="l18.1662" class="difflineminus">-{</span>
<a href="#l18.1663"></a><span id="l18.1663" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::FolderIsNoSelect(</span>
<a href="#l18.1664"></a><span id="l18.1664" class="difflineplus">+    const nsACString &amp;aFolderName, bool *result) {</span>
<a href="#l18.1665"></a><span id="l18.1665">   NS_ENSURE_ARG_POINTER(result);</span>
<a href="#l18.1666"></a><span id="l18.1666">   nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l18.1667"></a><span id="l18.1667">   nsresult rv = GetFolder(aFolderName, getter_AddRefs(msgFolder));</span>
<a href="#l18.1668"></a><span id="l18.1668" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; msgFolder)</span>
<a href="#l18.1669"></a><span id="l18.1669" class="difflineminus">-  {</span>
<a href="#l18.1670"></a><span id="l18.1670" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; msgFolder) {</span>
<a href="#l18.1671"></a><span id="l18.1671">     uint32_t flags;</span>
<a href="#l18.1672"></a><span id="l18.1672">     msgFolder-&gt;GetFlags(&amp;flags);</span>
<a href="#l18.1673"></a><span id="l18.1673">     *result = ((flags &amp; nsMsgFolderFlags::ImapNoselect) != 0);</span>
<a href="#l18.1674"></a><span id="l18.1674" class="difflineminus">-  }</span>
<a href="#l18.1675"></a><span id="l18.1675" class="difflineminus">-  else</span>
<a href="#l18.1676"></a><span id="l18.1676" class="difflineminus">-   *result = false;</span>
<a href="#l18.1677"></a><span id="l18.1677" class="difflineplus">+  } else</span>
<a href="#l18.1678"></a><span id="l18.1678" class="difflineplus">+    *result = false;</span>
<a href="#l18.1679"></a><span id="l18.1679">   return NS_OK;</span>
<a href="#l18.1680"></a><span id="l18.1680"> }</span>
<a href="#l18.1681"></a><span id="l18.1681"> </span>
<a href="#l18.1682"></a><span id="l18.1682" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::SetFolderAdminURL(const nsACString&amp; aFolderName, const nsACString&amp; aFolderAdminUrl)</span>
<a href="#l18.1683"></a><span id="l18.1683" class="difflineminus">-{</span>
<a href="#l18.1684"></a><span id="l18.1684" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.1685"></a><span id="l18.1685" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::SetFolderAdminURL(</span>
<a href="#l18.1686"></a><span id="l18.1686" class="difflineplus">+    const nsACString &amp;aFolderName, const nsACString &amp;aFolderAdminUrl) {</span>
<a href="#l18.1687"></a><span id="l18.1687" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.1688"></a><span id="l18.1688">   nsresult rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l18.1689"></a><span id="l18.1689" class="difflineminus">-  if(NS_SUCCEEDED(rv) &amp;&amp; rootFolder)</span>
<a href="#l18.1690"></a><span id="l18.1690" class="difflineminus">-  {</span>
<a href="#l18.1691"></a><span id="l18.1691" class="difflineminus">-    nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapRoot = do_QueryInterface(rootFolder);</span>
<a href="#l18.1692"></a><span id="l18.1692" class="difflineminus">-    if (imapRoot)</span>
<a href="#l18.1693"></a><span id="l18.1693" class="difflineminus">-    {</span>
<a href="#l18.1694"></a><span id="l18.1694" class="difflineminus">-      nsCOMPtr &lt;nsIMsgImapMailFolder&gt; foundFolder;</span>
<a href="#l18.1695"></a><span id="l18.1695" class="difflineminus">-      rv = imapRoot-&gt;FindOnlineSubFolder(aFolderName, getter_AddRefs(foundFolder));</span>
<a href="#l18.1696"></a><span id="l18.1696" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder) {</span>
<a href="#l18.1697"></a><span id="l18.1697" class="difflineplus">+    nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapRoot = do_QueryInterface(rootFolder);</span>
<a href="#l18.1698"></a><span id="l18.1698" class="difflineplus">+    if (imapRoot) {</span>
<a href="#l18.1699"></a><span id="l18.1699" class="difflineplus">+      nsCOMPtr&lt;nsIMsgImapMailFolder&gt; foundFolder;</span>
<a href="#l18.1700"></a><span id="l18.1700" class="difflineplus">+      rv = imapRoot-&gt;FindOnlineSubFolder(aFolderName,</span>
<a href="#l18.1701"></a><span id="l18.1701" class="difflineplus">+                                         getter_AddRefs(foundFolder));</span>
<a href="#l18.1702"></a><span id="l18.1702">       if (NS_SUCCEEDED(rv) &amp;&amp; foundFolder)</span>
<a href="#l18.1703"></a><span id="l18.1703">         return foundFolder-&gt;SetAdminUrl(aFolderAdminUrl);</span>
<a href="#l18.1704"></a><span id="l18.1704">     }</span>
<a href="#l18.1705"></a><span id="l18.1705">   }</span>
<a href="#l18.1706"></a><span id="l18.1706">   return rv;</span>
<a href="#l18.1707"></a><span id="l18.1707"> }</span>
<a href="#l18.1708"></a><span id="l18.1708"> </span>
<a href="#l18.1709"></a><span id="l18.1709" class="difflineminus">-NS_IMETHODIMP  nsImapIncomingServer::FolderVerifiedOnline(const nsACString&amp; folderName, bool *aResult)</span>
<a href="#l18.1710"></a><span id="l18.1710" class="difflineminus">-{</span>
<a href="#l18.1711"></a><span id="l18.1711" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::FolderVerifiedOnline(</span>
<a href="#l18.1712"></a><span id="l18.1712" class="difflineplus">+    const nsACString &amp;folderName, bool *aResult) {</span>
<a href="#l18.1713"></a><span id="l18.1713">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l18.1714"></a><span id="l18.1714">   *aResult = false;</span>
<a href="#l18.1715"></a><span id="l18.1715">   nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.1716"></a><span id="l18.1716">   nsresult rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l18.1717"></a><span id="l18.1717" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder)</span>
<a href="#l18.1718"></a><span id="l18.1718" class="difflineminus">-  {</span>
<a href="#l18.1719"></a><span id="l18.1719" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder) {</span>
<a href="#l18.1720"></a><span id="l18.1720">     nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l18.1721"></a><span id="l18.1721">     rv = rootFolder-&gt;FindSubFolder(folderName, getter_AddRefs(folder));</span>
<a href="#l18.1722"></a><span id="l18.1722" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; folder)</span>
<a href="#l18.1723"></a><span id="l18.1723" class="difflineminus">-    {</span>
<a href="#l18.1724"></a><span id="l18.1724" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; folder) {</span>
<a href="#l18.1725"></a><span id="l18.1725">       nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(folder);</span>
<a href="#l18.1726"></a><span id="l18.1726" class="difflineminus">-      if (imapFolder)</span>
<a href="#l18.1727"></a><span id="l18.1727" class="difflineminus">-        imapFolder-&gt;GetVerifiedAsOnlineFolder(aResult);</span>
<a href="#l18.1728"></a><span id="l18.1728" class="difflineplus">+      if (imapFolder) imapFolder-&gt;GetVerifiedAsOnlineFolder(aResult);</span>
<a href="#l18.1729"></a><span id="l18.1729">     }</span>
<a href="#l18.1730"></a><span id="l18.1730">   }</span>
<a href="#l18.1731"></a><span id="l18.1731">   return rv;</span>
<a href="#l18.1732"></a><span id="l18.1732"> }</span>
<a href="#l18.1733"></a><span id="l18.1733"> </span>
<a href="#l18.1734"></a><span id="l18.1734" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::DiscoveryDone()</span>
<a href="#l18.1735"></a><span id="l18.1735" class="difflineminus">-{</span>
<a href="#l18.1736"></a><span id="l18.1736" class="difflineminus">-  if (mDoingSubscribeDialog)</span>
<a href="#l18.1737"></a><span id="l18.1737" class="difflineminus">-    return NS_OK;</span>
<a href="#l18.1738"></a><span id="l18.1738" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::DiscoveryDone() {</span>
<a href="#l18.1739"></a><span id="l18.1739" class="difflineplus">+  if (mDoingSubscribeDialog) return NS_OK;</span>
<a href="#l18.1740"></a><span id="l18.1740"> </span>
<a href="#l18.1741"></a><span id="l18.1741">   nsCOMPtr&lt;nsIMsgFolder&gt; rootMsgFolder;</span>
<a href="#l18.1742"></a><span id="l18.1742">   nsresult rv = GetRootFolder(getter_AddRefs(rootMsgFolder));</span>
<a href="#l18.1743"></a><span id="l18.1743" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; rootMsgFolder)</span>
<a href="#l18.1744"></a><span id="l18.1744" class="difflineminus">-  {</span>
<a href="#l18.1745"></a><span id="l18.1745" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; rootMsgFolder) {</span>
<a href="#l18.1746"></a><span id="l18.1746">     // GetResource() may return a node which is not in the folder</span>
<a href="#l18.1747"></a><span id="l18.1747">     // tree hierarchy but in the rdf cache in case of the non-existing default</span>
<a href="#l18.1748"></a><span id="l18.1748">     // Sent, Drafts, and Templates folders. The resource will be eventually</span>
<a href="#l18.1749"></a><span id="l18.1749">     // released when the rdf service shuts down. When we create the default</span>
<a href="#l18.1750"></a><span id="l18.1750">     // folders later on in the imap server, the subsequent GetResource() of the</span>
<a href="#l18.1751"></a><span id="l18.1751">     // same uri will get us the cached rdf resource which should have the folder</span>
<a href="#l18.1752"></a><span id="l18.1752">     // flag set appropriately.</span>
<a href="#l18.1753"></a><span id="l18.1753"> </span>
<a href="#l18.1754"></a><span id="l18.1754" class="difflineminus">-    nsCOMPtr&lt;nsIMsgAccountManager&gt; accountMgr = do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l18.1755"></a><span id="l18.1755" class="difflineplus">+    nsCOMPtr&lt;nsIMsgAccountManager&gt; accountMgr =</span>
<a href="#l18.1756"></a><span id="l18.1756" class="difflineplus">+        do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l18.1757"></a><span id="l18.1757">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.1758"></a><span id="l18.1758"> </span>
<a href="#l18.1759"></a><span id="l18.1759">     nsCOMPtr&lt;nsIMsgIdentity&gt; identity;</span>
<a href="#l18.1760"></a><span id="l18.1760">     rv = accountMgr-&gt;GetFirstIdentityForServer(this, getter_AddRefs(identity));</span>
<a href="#l18.1761"></a><span id="l18.1761" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; identity)</span>
<a href="#l18.1762"></a><span id="l18.1762" class="difflineminus">-    {</span>
<a href="#l18.1763"></a><span id="l18.1763" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; identity) {</span>
<a href="#l18.1764"></a><span id="l18.1764">       nsCString folderUri;</span>
<a href="#l18.1765"></a><span id="l18.1765">       identity-&gt;GetFccFolder(folderUri);</span>
<a href="#l18.1766"></a><span id="l18.1766">       nsCString existingUri;</span>
<a href="#l18.1767"></a><span id="l18.1767"> </span>
<a href="#l18.1768"></a><span id="l18.1768">       if (CheckSpecialFolder(folderUri, nsMsgFolderFlags::SentMail,</span>
<a href="#l18.1769"></a><span id="l18.1769" class="difflineminus">-                             existingUri))</span>
<a href="#l18.1770"></a><span id="l18.1770" class="difflineminus">-      {</span>
<a href="#l18.1771"></a><span id="l18.1771" class="difflineplus">+                             existingUri)) {</span>
<a href="#l18.1772"></a><span id="l18.1772">         identity-&gt;SetFccFolder(existingUri);</span>
<a href="#l18.1773"></a><span id="l18.1773">         identity-&gt;SetFccFolderPickerMode(NS_LITERAL_CSTRING(&quot;1&quot;));</span>
<a href="#l18.1774"></a><span id="l18.1774">       }</span>
<a href="#l18.1775"></a><span id="l18.1775">       identity-&gt;GetDraftFolder(folderUri);</span>
<a href="#l18.1776"></a><span id="l18.1776">       if (CheckSpecialFolder(folderUri, nsMsgFolderFlags::Drafts,</span>
<a href="#l18.1777"></a><span id="l18.1777" class="difflineminus">-                             existingUri))</span>
<a href="#l18.1778"></a><span id="l18.1778" class="difflineminus">-      {</span>
<a href="#l18.1779"></a><span id="l18.1779" class="difflineplus">+                             existingUri)) {</span>
<a href="#l18.1780"></a><span id="l18.1780">         identity-&gt;SetDraftFolder(existingUri);</span>
<a href="#l18.1781"></a><span id="l18.1781">         identity-&gt;SetDraftsFolderPickerMode(NS_LITERAL_CSTRING(&quot;1&quot;));</span>
<a href="#l18.1782"></a><span id="l18.1782">       }</span>
<a href="#l18.1783"></a><span id="l18.1783">       bool archiveEnabled;</span>
<a href="#l18.1784"></a><span id="l18.1784">       identity-&gt;GetArchiveEnabled(&amp;archiveEnabled);</span>
<a href="#l18.1785"></a><span id="l18.1785" class="difflineminus">-      if (archiveEnabled)</span>
<a href="#l18.1786"></a><span id="l18.1786" class="difflineminus">-      {</span>
<a href="#l18.1787"></a><span id="l18.1787" class="difflineplus">+      if (archiveEnabled) {</span>
<a href="#l18.1788"></a><span id="l18.1788">         identity-&gt;GetArchiveFolder(folderUri);</span>
<a href="#l18.1789"></a><span id="l18.1789">         if (CheckSpecialFolder(folderUri, nsMsgFolderFlags::Archive,</span>
<a href="#l18.1790"></a><span id="l18.1790" class="difflineminus">-                               existingUri))</span>
<a href="#l18.1791"></a><span id="l18.1791" class="difflineminus">-        {</span>
<a href="#l18.1792"></a><span id="l18.1792" class="difflineplus">+                               existingUri)) {</span>
<a href="#l18.1793"></a><span id="l18.1793">           identity-&gt;SetArchiveFolder(existingUri);</span>
<a href="#l18.1794"></a><span id="l18.1794">           identity-&gt;SetArchivesFolderPickerMode(NS_LITERAL_CSTRING(&quot;1&quot;));</span>
<a href="#l18.1795"></a><span id="l18.1795">         }</span>
<a href="#l18.1796"></a><span id="l18.1796">       }</span>
<a href="#l18.1797"></a><span id="l18.1797">       identity-&gt;GetStationeryFolder(folderUri);</span>
<a href="#l18.1798"></a><span id="l18.1798">       if (!folderUri.IsEmpty()) {</span>
<a href="#l18.1799"></a><span id="l18.1799">         nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l18.1800"></a><span id="l18.1800">         rv = GetOrCreateFolder(folderUri, getter_AddRefs(folder));</span>
<a href="#l18.1801"></a><span id="l18.1801" class="difflineminus">-        if (NS_SUCCEEDED(rv))</span>
<a href="#l18.1802"></a><span id="l18.1802" class="difflineminus">-          rv = folder-&gt;SetFlag(nsMsgFolderFlags::Templates);</span>
<a href="#l18.1803"></a><span id="l18.1803" class="difflineplus">+        if (NS_SUCCEEDED(rv)) rv = folder-&gt;SetFlag(nsMsgFolderFlags::Templates);</span>
<a href="#l18.1804"></a><span id="l18.1804">       }</span>
<a href="#l18.1805"></a><span id="l18.1805">     }</span>
<a href="#l18.1806"></a><span id="l18.1806"> </span>
<a href="#l18.1807"></a><span id="l18.1807">     nsCOMPtr&lt;nsISpamSettings&gt; spamSettings;</span>
<a href="#l18.1808"></a><span id="l18.1808">     rv = GetSpamSettings(getter_AddRefs(spamSettings));</span>
<a href="#l18.1809"></a><span id="l18.1809" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; spamSettings)</span>
<a href="#l18.1810"></a><span id="l18.1810" class="difflineminus">-    {</span>
<a href="#l18.1811"></a><span id="l18.1811" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; spamSettings) {</span>
<a href="#l18.1812"></a><span id="l18.1812">       nsCString spamFolderUri, existingUri;</span>
<a href="#l18.1813"></a><span id="l18.1813">       spamSettings-&gt;GetSpamFolderURI(getter_Copies(spamFolderUri));</span>
<a href="#l18.1814"></a><span id="l18.1814">       if (CheckSpecialFolder(spamFolderUri, nsMsgFolderFlags::Junk,</span>
<a href="#l18.1815"></a><span id="l18.1815" class="difflineminus">-                             existingUri))</span>
<a href="#l18.1816"></a><span id="l18.1816" class="difflineminus">-      {</span>
<a href="#l18.1817"></a><span id="l18.1817" class="difflineplus">+                             existingUri)) {</span>
<a href="#l18.1818"></a><span id="l18.1818">         // This only sets the cached values in the spam settings object.</span>
<a href="#l18.1819"></a><span id="l18.1819">         spamSettings-&gt;SetActionTargetFolder(existingUri.get());</span>
<a href="#l18.1820"></a><span id="l18.1820" class="difflineminus">-        spamSettings-&gt;SetMoveTargetMode(nsISpamSettings::MOVE_TARGET_MODE_FOLDER);</span>
<a href="#l18.1821"></a><span id="l18.1821" class="difflineplus">+        spamSettings-&gt;SetMoveTargetMode(</span>
<a href="#l18.1822"></a><span id="l18.1822" class="difflineplus">+            nsISpamSettings::MOVE_TARGET_MODE_FOLDER);</span>
<a href="#l18.1823"></a><span id="l18.1823">         // Set the preferences too so that the values persist.</span>
<a href="#l18.1824"></a><span id="l18.1824">         SetCharValue(&quot;spamActionTargetFolder&quot;, existingUri);</span>
<a href="#l18.1825"></a><span id="l18.1825">         SetIntValue(&quot;moveTargetMode&quot;, nsISpamSettings::MOVE_TARGET_MODE_FOLDER);</span>
<a href="#l18.1826"></a><span id="l18.1826">       }</span>
<a href="#l18.1827"></a><span id="l18.1827">     }</span>
<a href="#l18.1828"></a><span id="l18.1828"> </span>
<a href="#l18.1829"></a><span id="l18.1829">     bool isGMailServer;</span>
<a href="#l18.1830"></a><span id="l18.1830">     GetIsGMailServer(&amp;isGMailServer);</span>
<a href="#l18.1831"></a><span id="l18.1831"> </span>
<a href="#l18.1832"></a><span id="l18.1832">     // Verify there is only one trash folder. Another might be present if</span>
<a href="#l18.1833"></a><span id="l18.1833">     // the trash name has been changed. Or we might be a gmail server and</span>
<a href="#l18.1834"></a><span id="l18.1834">     // want to switch to gmail's trash folder.</span>
<a href="#l18.1835"></a><span id="l18.1835">     nsCOMPtr&lt;nsIArray&gt; trashFolders;</span>
<a href="#l18.1836"></a><span id="l18.1836">     rv = rootMsgFolder-&gt;GetFoldersWithFlags(nsMsgFolderFlags::Trash,</span>
<a href="#l18.1837"></a><span id="l18.1837">                                             getter_AddRefs(trashFolders));</span>
<a href="#l18.1838"></a><span id="l18.1838"> </span>
<a href="#l18.1839"></a><span id="l18.1839" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; trashFolders)</span>
<a href="#l18.1840"></a><span id="l18.1840" class="difflineminus">-    {</span>
<a href="#l18.1841"></a><span id="l18.1841" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; trashFolders) {</span>
<a href="#l18.1842"></a><span id="l18.1842">       uint32_t numFolders;</span>
<a href="#l18.1843"></a><span id="l18.1843">       trashFolders-&gt;GetLength(&amp;numFolders);</span>
<a href="#l18.1844"></a><span id="l18.1844">       nsAutoString trashName;</span>
<a href="#l18.1845"></a><span id="l18.1845" class="difflineminus">-      if (NS_SUCCEEDED(GetTrashFolderName(trashName)))</span>
<a href="#l18.1846"></a><span id="l18.1846" class="difflineminus">-      {</span>
<a href="#l18.1847"></a><span id="l18.1847" class="difflineminus">-        for (uint32_t i = 0; i &lt; numFolders; i++)</span>
<a href="#l18.1848"></a><span id="l18.1848" class="difflineminus">-        {</span>
<a href="#l18.1849"></a><span id="l18.1849" class="difflineminus">-          nsCOMPtr&lt;nsIMsgFolder&gt; trashFolder(do_QueryElementAt(trashFolders, i));</span>
<a href="#l18.1850"></a><span id="l18.1850" class="difflineminus">-          if (trashFolder)</span>
<a href="#l18.1851"></a><span id="l18.1851" class="difflineminus">-          {</span>
<a href="#l18.1852"></a><span id="l18.1852" class="difflineplus">+      if (NS_SUCCEEDED(GetTrashFolderName(trashName))) {</span>
<a href="#l18.1853"></a><span id="l18.1853" class="difflineplus">+        for (uint32_t i = 0; i &lt; numFolders; i++) {</span>
<a href="#l18.1854"></a><span id="l18.1854" class="difflineplus">+          nsCOMPtr&lt;nsIMsgFolder&gt; trashFolder(</span>
<a href="#l18.1855"></a><span id="l18.1855" class="difflineplus">+              do_QueryElementAt(trashFolders, i));</span>
<a href="#l18.1856"></a><span id="l18.1856" class="difflineplus">+          if (trashFolder) {</span>
<a href="#l18.1857"></a><span id="l18.1857">             // If we're a gmail server, we clear the trash flags from folder(s)</span>
<a href="#l18.1858"></a><span id="l18.1858">             // without the kImapXListTrash flag. For normal servers, we clear</span>
<a href="#l18.1859"></a><span id="l18.1859">             // the trash folder flag if the folder name doesn't match the</span>
<a href="#l18.1860"></a><span id="l18.1860">             // pref trash folder name.</span>
<a href="#l18.1861"></a><span id="l18.1861" class="difflineminus">-            if (isGMailServer)</span>
<a href="#l18.1862"></a><span id="l18.1862" class="difflineminus">-            {</span>
<a href="#l18.1863"></a><span id="l18.1863" class="difflineminus">-              nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder(do_QueryInterface(trashFolder));</span>
<a href="#l18.1864"></a><span id="l18.1864" class="difflineplus">+            if (isGMailServer) {</span>
<a href="#l18.1865"></a><span id="l18.1865" class="difflineplus">+              nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder(</span>
<a href="#l18.1866"></a><span id="l18.1866" class="difflineplus">+                  do_QueryInterface(trashFolder));</span>
<a href="#l18.1867"></a><span id="l18.1867">               int32_t boxFlags;</span>
<a href="#l18.1868"></a><span id="l18.1868">               imapFolder-&gt;GetBoxFlags(&amp;boxFlags);</span>
<a href="#l18.1869"></a><span id="l18.1869" class="difflineminus">-              if (boxFlags &amp; kImapXListTrash)</span>
<a href="#l18.1870"></a><span id="l18.1870" class="difflineminus">-              {</span>
<a href="#l18.1871"></a><span id="l18.1871" class="difflineplus">+              if (boxFlags &amp; kImapXListTrash) {</span>
<a href="#l18.1872"></a><span id="l18.1872">                 continue;</span>
<a href="#l18.1873"></a><span id="l18.1873">               }</span>
<a href="#l18.1874"></a><span id="l18.1874" class="difflineminus">-            }</span>
<a href="#l18.1875"></a><span id="l18.1875" class="difflineminus">-            else</span>
<a href="#l18.1876"></a><span id="l18.1876" class="difflineminus">-            {</span>
<a href="#l18.1877"></a><span id="l18.1877" class="difflineplus">+            } else {</span>
<a href="#l18.1878"></a><span id="l18.1878">               // Store the trash folder path. We maintain the full path in the</span>
<a href="#l18.1879"></a><span id="l18.1879" class="difflineminus">-              // trash_folder_name preference since the full path is stored there</span>
<a href="#l18.1880"></a><span id="l18.1880" class="difflineminus">-              // when selecting a trash folder in the Account Manager.</span>
<a href="#l18.1881"></a><span id="l18.1881" class="difflineplus">+              // trash_folder_name preference since the full path is stored</span>
<a href="#l18.1882"></a><span id="l18.1882" class="difflineplus">+              // there when selecting a trash folder in the Account Manager.</span>
<a href="#l18.1883"></a><span id="l18.1883">               nsAutoCString trashURL;</span>
<a href="#l18.1884"></a><span id="l18.1884">               trashFolder-&gt;GetFolderURL(trashURL);</span>
<a href="#l18.1885"></a><span id="l18.1885">               nsCOMPtr&lt;nsIURI&gt; uri;</span>
<a href="#l18.1886"></a><span id="l18.1886">               NS_NewURI(getter_AddRefs(uri), trashURL);</span>
<a href="#l18.1887"></a><span id="l18.1887">               nsAutoCString trashPath;</span>
<a href="#l18.1888"></a><span id="l18.1888">               uri-&gt;GetPathQueryRef(trashPath);</span>
<a href="#l18.1889"></a><span id="l18.1889">               nsAutoCString unescapedName;</span>
<a href="#l18.1890"></a><span id="l18.1890" class="difflineminus">-              MsgUnescapeString(Substring(trashPath, 1), // Skip leading slash.</span>
<a href="#l18.1891"></a><span id="l18.1891" class="difflineplus">+              MsgUnescapeString(Substring(trashPath, 1),  // Skip leading slash.</span>
<a href="#l18.1892"></a><span id="l18.1892">                                 nsINetUtil::ESCAPE_URL_PATH, unescapedName);</span>
<a href="#l18.1893"></a><span id="l18.1893">               nsAutoString nameUnicode;</span>
<a href="#l18.1894"></a><span id="l18.1894">               if (NS_FAILED(CopyMUTF7toUTF16(unescapedName, nameUnicode)) ||</span>
<a href="#l18.1895"></a><span id="l18.1895" class="difflineminus">-                  trashName.Equals(nameUnicode))</span>
<a href="#l18.1896"></a><span id="l18.1896" class="difflineminus">-              {</span>
<a href="#l18.1897"></a><span id="l18.1897" class="difflineplus">+                  trashName.Equals(nameUnicode)) {</span>
<a href="#l18.1898"></a><span id="l18.1898">                 continue;</span>
<a href="#l18.1899"></a><span id="l18.1899">               }</span>
<a href="#l18.1900"></a><span id="l18.1900" class="difflineminus">-              if (numFolders == 1)</span>
<a href="#l18.1901"></a><span id="l18.1901" class="difflineminus">-              {</span>
<a href="#l18.1902"></a><span id="l18.1902" class="difflineplus">+              if (numFolders == 1) {</span>
<a href="#l18.1903"></a><span id="l18.1903">                 // We got here because the preferred trash folder does not</span>
<a href="#l18.1904"></a><span id="l18.1904">                 // exist, but a folder got discovered to be the trash folder.</span>
<a href="#l18.1905"></a><span id="l18.1905">                 SetUnicharValue(PREF_TRASH_FOLDER_PATH, nameUnicode);</span>
<a href="#l18.1906"></a><span id="l18.1906">                 continue;</span>
<a href="#l18.1907"></a><span id="l18.1907">               }</span>
<a href="#l18.1908"></a><span id="l18.1908">             }</span>
<a href="#l18.1909"></a><span id="l18.1909">             trashFolder-&gt;ClearFlag(nsMsgFolderFlags::Trash);</span>
<a href="#l18.1910"></a><span id="l18.1910">           }</span>
<a href="#l18.1911"></a><span id="l18.1911" class="difflineat">@@ -1565,534 +1433,485 @@ NS_IMETHODIMP nsImapIncomingServer::Disc</span>
<a href="#l18.1912"></a><span id="l18.1912"> </span>
<a href="#l18.1913"></a><span id="l18.1913">   bool usingSubscription = true;</span>
<a href="#l18.1914"></a><span id="l18.1914">   GetUsingSubscription(&amp;usingSubscription);</span>
<a href="#l18.1915"></a><span id="l18.1915"> </span>
<a href="#l18.1916"></a><span id="l18.1916">   nsCOMArray&lt;nsIMsgImapMailFolder&gt; unverifiedFolders;</span>
<a href="#l18.1917"></a><span id="l18.1917">   GetUnverifiedFolders(unverifiedFolders);</span>
<a href="#l18.1918"></a><span id="l18.1918"> </span>
<a href="#l18.1919"></a><span id="l18.1919">   int32_t count = unverifiedFolders.Count();</span>
<a href="#l18.1920"></a><span id="l18.1920" class="difflineminus">-  for (int32_t k = 0; k &lt; count; ++k)</span>
<a href="#l18.1921"></a><span id="l18.1921" class="difflineminus">-  {</span>
<a href="#l18.1922"></a><span id="l18.1922" class="difflineplus">+  for (int32_t k = 0; k &lt; count; ++k) {</span>
<a href="#l18.1923"></a><span id="l18.1923">     bool explicitlyVerify = false;</span>
<a href="#l18.1924"></a><span id="l18.1924">     bool hasSubFolders = false;</span>
<a href="#l18.1925"></a><span id="l18.1925">     uint32_t folderFlags;</span>
<a href="#l18.1926"></a><span id="l18.1926">     nsCOMPtr&lt;nsIMsgImapMailFolder&gt; currentImapFolder(unverifiedFolders[k]);</span>
<a href="#l18.1927"></a><span id="l18.1927" class="difflineminus">-    nsCOMPtr&lt;nsIMsgFolder&gt; currentFolder(do_QueryInterface(currentImapFolder, &amp;rv));</span>
<a href="#l18.1928"></a><span id="l18.1928" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l18.1929"></a><span id="l18.1929" class="difflineminus">-      continue;</span>
<a href="#l18.1930"></a><span id="l18.1930" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolder&gt; currentFolder(</span>
<a href="#l18.1931"></a><span id="l18.1931" class="difflineplus">+        do_QueryInterface(currentImapFolder, &amp;rv));</span>
<a href="#l18.1932"></a><span id="l18.1932" class="difflineplus">+    if (NS_FAILED(rv)) continue;</span>
<a href="#l18.1933"></a><span id="l18.1933"> </span>
<a href="#l18.1934"></a><span id="l18.1934">     currentFolder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l18.1935"></a><span id="l18.1935" class="difflineminus">-    if (folderFlags &amp; nsMsgFolderFlags::Virtual) // don't remove virtual folders</span>
<a href="#l18.1936"></a><span id="l18.1936" class="difflineplus">+    if (folderFlags &amp;</span>
<a href="#l18.1937"></a><span id="l18.1937" class="difflineplus">+        nsMsgFolderFlags::Virtual)  // don't remove virtual folders</span>
<a href="#l18.1938"></a><span id="l18.1938">       continue;</span>
<a href="#l18.1939"></a><span id="l18.1939"> </span>
<a href="#l18.1940"></a><span id="l18.1940">     if ((!usingSubscription ||</span>
<a href="#l18.1941"></a><span id="l18.1941" class="difflineminus">-         (NS_SUCCEEDED(currentImapFolder-&gt;GetExplicitlyVerify(&amp;explicitlyVerify)) &amp;&amp;</span>
<a href="#l18.1942"></a><span id="l18.1942" class="difflineplus">+         (NS_SUCCEEDED(</span>
<a href="#l18.1943"></a><span id="l18.1943" class="difflineplus">+              currentImapFolder-&gt;GetExplicitlyVerify(&amp;explicitlyVerify)) &amp;&amp;</span>
<a href="#l18.1944"></a><span id="l18.1944">           explicitlyVerify)) ||</span>
<a href="#l18.1945"></a><span id="l18.1945">         ((NS_SUCCEEDED(currentFolder-&gt;GetHasSubFolders(&amp;hasSubFolders)) &amp;&amp;</span>
<a href="#l18.1946"></a><span id="l18.1946">           hasSubFolders) &amp;&amp;</span>
<a href="#l18.1947"></a><span id="l18.1947" class="difflineminus">-         !NoDescendentsAreVerified(currentFolder)))</span>
<a href="#l18.1948"></a><span id="l18.1948" class="difflineminus">-    {</span>
<a href="#l18.1949"></a><span id="l18.1949" class="difflineplus">+         !NoDescendentsAreVerified(currentFolder))) {</span>
<a href="#l18.1950"></a><span id="l18.1950">       bool isNamespace;</span>
<a href="#l18.1951"></a><span id="l18.1951">       currentImapFolder-&gt;GetIsNamespace(&amp;isNamespace);</span>
<a href="#l18.1952"></a><span id="l18.1952" class="difflineminus">-      if (!isNamespace) // don't list namespaces explicitly</span>
<a href="#l18.1953"></a><span id="l18.1953" class="difflineplus">+      if (!isNamespace)  // don't list namespaces explicitly</span>
<a href="#l18.1954"></a><span id="l18.1954">       {</span>
<a href="#l18.1955"></a><span id="l18.1955">         // If there are no subfolders and this is unverified, we don't want to</span>
<a href="#l18.1956"></a><span id="l18.1956">         // run this url. That is, we want to undiscover the folder.</span>
<a href="#l18.1957"></a><span id="l18.1957">         // If there are subfolders and no descendants are verified, we want to</span>
<a href="#l18.1958"></a><span id="l18.1958">         // undiscover all of the folders.</span>
<a href="#l18.1959"></a><span id="l18.1959">         // Only if there are subfolders and at least one of them is verified</span>
<a href="#l18.1960"></a><span id="l18.1960">         // do we want to refresh that folder's flags, because it won't be going</span>
<a href="#l18.1961"></a><span id="l18.1961">         // away.</span>
<a href="#l18.1962"></a><span id="l18.1962">         currentImapFolder-&gt;SetExplicitlyVerify(false);</span>
<a href="#l18.1963"></a><span id="l18.1963">         currentImapFolder-&gt;List();</span>
<a href="#l18.1964"></a><span id="l18.1964">       }</span>
<a href="#l18.1965"></a><span id="l18.1965" class="difflineminus">-    }</span>
<a href="#l18.1966"></a><span id="l18.1966" class="difflineminus">-    else</span>
<a href="#l18.1967"></a><span id="l18.1967" class="difflineplus">+    } else</span>
<a href="#l18.1968"></a><span id="l18.1968">       DeleteNonVerifiedFolders(currentFolder);</span>
<a href="#l18.1969"></a><span id="l18.1969">   }</span>
<a href="#l18.1970"></a><span id="l18.1970"> </span>
<a href="#l18.1971"></a><span id="l18.1971">   return rv;</span>
<a href="#l18.1972"></a><span id="l18.1972"> }</span>
<a href="#l18.1973"></a><span id="l18.1973"> </span>
<a href="#l18.1974"></a><span id="l18.1974"> // Check if the special folder corresponding to the uri exists. If not, check</span>
<a href="#l18.1975"></a><span id="l18.1975"> // if there already exists a folder with the special folder flag (the server may</span>
<a href="#l18.1976"></a><span id="l18.1976"> // have told us about a folder to use through XLIST). If so, return the uri of</span>
<a href="#l18.1977"></a><span id="l18.1977"> // the existing special folder. If not, set the special flag on the folder so</span>
<a href="#l18.1978"></a><span id="l18.1978"> // it will be there if and when the folder is created.</span>
<a href="#l18.1979"></a><span id="l18.1979"> // Return true if we found an existing special folder different than</span>
<a href="#l18.1980"></a><span id="l18.1980"> // the one specified in prefs, and the one specified by prefs doesn't exist.</span>
<a href="#l18.1981"></a><span id="l18.1981"> bool nsImapIncomingServer::CheckSpecialFolder(nsCString &amp;folderUri,</span>
<a href="#l18.1982"></a><span id="l18.1982">                                               uint32_t folderFlag,</span>
<a href="#l18.1983"></a><span id="l18.1983" class="difflineminus">-                                              nsCString &amp;existingUri)</span>
<a href="#l18.1984"></a><span id="l18.1984" class="difflineminus">-{</span>
<a href="#l18.1985"></a><span id="l18.1985" class="difflineplus">+                                              nsCString &amp;existingUri) {</span>
<a href="#l18.1986"></a><span id="l18.1986">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l18.1987"></a><span id="l18.1987">   nsCOMPtr&lt;nsIMsgFolder&gt; rootMsgFolder;</span>
<a href="#l18.1988"></a><span id="l18.1988">   nsresult rv = GetRootFolder(getter_AddRefs(rootMsgFolder));</span>
<a href="#l18.1989"></a><span id="l18.1989">   NS_ENSURE_SUCCESS(rv, false);</span>
<a href="#l18.1990"></a><span id="l18.1990">   nsCOMPtr&lt;nsIMsgFolder&gt; existingFolder;</span>
<a href="#l18.1991"></a><span id="l18.1991">   rootMsgFolder-&gt;GetFolderWithFlags(folderFlag, getter_AddRefs(existingFolder));</span>
<a href="#l18.1992"></a><span id="l18.1992"> </span>
<a href="#l18.1993"></a><span id="l18.1993">   if (!folderUri.IsEmpty() &amp;&amp;</span>
<a href="#l18.1994"></a><span id="l18.1994" class="difflineminus">-    NS_SUCCEEDED(GetOrCreateFolder(folderUri, getter_AddRefs(folder))))</span>
<a href="#l18.1995"></a><span id="l18.1995" class="difflineminus">-  {</span>
<a href="#l18.1996"></a><span id="l18.1996" class="difflineplus">+      NS_SUCCEEDED(GetOrCreateFolder(folderUri, getter_AddRefs(folder)))) {</span>
<a href="#l18.1997"></a><span id="l18.1997">     nsCOMPtr&lt;nsIMsgFolder&gt; parent;</span>
<a href="#l18.1998"></a><span id="l18.1998">     folder-&gt;GetParent(getter_AddRefs(parent));</span>
<a href="#l18.1999"></a><span id="l18.1999" class="difflineminus">-    if (parent)</span>
<a href="#l18.2000"></a><span id="l18.2000" class="difflineminus">-    {</span>
<a href="#l18.2001"></a><span id="l18.2001" class="difflineplus">+    if (parent) {</span>
<a href="#l18.2002"></a><span id="l18.2002">       existingFolder = nullptr;</span>
<a href="#l18.2003"></a><span id="l18.2003">     }</span>
<a href="#l18.2004"></a><span id="l18.2004" class="difflineminus">-    if (!existingFolder)</span>
<a href="#l18.2005"></a><span id="l18.2005" class="difflineminus">-    {</span>
<a href="#l18.2006"></a><span id="l18.2006" class="difflineplus">+    if (!existingFolder) {</span>
<a href="#l18.2007"></a><span id="l18.2007">       folder-&gt;SetFlag(folderFlag);</span>
<a href="#l18.2008"></a><span id="l18.2008">     }</span>
<a href="#l18.2009"></a><span id="l18.2009"> </span>
<a href="#l18.2010"></a><span id="l18.2010">     nsString folderName;</span>
<a href="#l18.2011"></a><span id="l18.2011">     folder-&gt;GetPrettyName(folderName);</span>
<a href="#l18.2012"></a><span id="l18.2012">     // this will set the localized name based on the folder flag.</span>
<a href="#l18.2013"></a><span id="l18.2013">     folder-&gt;SetPrettyName(folderName);</span>
<a href="#l18.2014"></a><span id="l18.2014">   }</span>
<a href="#l18.2015"></a><span id="l18.2015"> </span>
<a href="#l18.2016"></a><span id="l18.2016" class="difflineminus">-  if (existingFolder)</span>
<a href="#l18.2017"></a><span id="l18.2017" class="difflineminus">-  {</span>
<a href="#l18.2018"></a><span id="l18.2018" class="difflineplus">+  if (existingFolder) {</span>
<a href="#l18.2019"></a><span id="l18.2019">     existingFolder-&gt;GetURI(existingUri);</span>
<a href="#l18.2020"></a><span id="l18.2020">     return true;</span>
<a href="#l18.2021"></a><span id="l18.2021">   }</span>
<a href="#l18.2022"></a><span id="l18.2022"> </span>
<a href="#l18.2023"></a><span id="l18.2023">   return false;</span>
<a href="#l18.2024"></a><span id="l18.2024"> }</span>
<a href="#l18.2025"></a><span id="l18.2025"> </span>
<a href="#l18.2026"></a><span id="l18.2026" class="difflineminus">-nsresult nsImapIncomingServer::DeleteNonVerifiedFolders(nsIMsgFolder *curFolder)</span>
<a href="#l18.2027"></a><span id="l18.2027" class="difflineminus">-{</span>
<a href="#l18.2028"></a><span id="l18.2028" class="difflineplus">+nsresult nsImapIncomingServer::DeleteNonVerifiedFolders(</span>
<a href="#l18.2029"></a><span id="l18.2029" class="difflineplus">+    nsIMsgFolder *curFolder) {</span>
<a href="#l18.2030"></a><span id="l18.2030">   bool autoUnsubscribeFromNoSelectFolders = true;</span>
<a href="#l18.2031"></a><span id="l18.2031">   nsresult rv;</span>
<a href="#l18.2032"></a><span id="l18.2032" class="difflineminus">-  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.2033"></a><span id="l18.2033" class="difflineplus">+  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch =</span>
<a href="#l18.2034"></a><span id="l18.2034" class="difflineplus">+      do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.2035"></a><span id="l18.2035">   if (NS_SUCCEEDED(rv))</span>
<a href="#l18.2036"></a><span id="l18.2036" class="difflineminus">-    prefBranch-&gt;GetBoolPref(&quot;mail.imap.auto_unsubscribe_from_noselect_folders&quot;, &amp;autoUnsubscribeFromNoSelectFolders);</span>
<a href="#l18.2037"></a><span id="l18.2037" class="difflineplus">+    prefBranch-&gt;GetBoolPref(&quot;mail.imap.auto_unsubscribe_from_noselect_folders&quot;,</span>
<a href="#l18.2038"></a><span id="l18.2038" class="difflineplus">+                            &amp;autoUnsubscribeFromNoSelectFolders);</span>
<a href="#l18.2039"></a><span id="l18.2039"> </span>
<a href="#l18.2040"></a><span id="l18.2040">   nsCOMPtr&lt;nsISimpleEnumerator&gt; subFolders;</span>
<a href="#l18.2041"></a><span id="l18.2041"> </span>
<a href="#l18.2042"></a><span id="l18.2042">   rv = curFolder-&gt;GetSubFolders(getter_AddRefs(subFolders));</span>
<a href="#l18.2043"></a><span id="l18.2043" class="difflineminus">-  if(NS_SUCCEEDED(rv))</span>
<a href="#l18.2044"></a><span id="l18.2044" class="difflineminus">-  {</span>
<a href="#l18.2045"></a><span id="l18.2045" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.2046"></a><span id="l18.2046">     bool moreFolders;</span>
<a href="#l18.2047"></a><span id="l18.2047"> </span>
<a href="#l18.2048"></a><span id="l18.2048" class="difflineminus">-    while (NS_SUCCEEDED(subFolders-&gt;HasMoreElements(&amp;moreFolders)) &amp;&amp; moreFolders)</span>
<a href="#l18.2049"></a><span id="l18.2049" class="difflineminus">-    {</span>
<a href="#l18.2050"></a><span id="l18.2050" class="difflineplus">+    while (NS_SUCCEEDED(subFolders-&gt;HasMoreElements(&amp;moreFolders)) &amp;&amp;</span>
<a href="#l18.2051"></a><span id="l18.2051" class="difflineplus">+           moreFolders) {</span>
<a href="#l18.2052"></a><span id="l18.2052">       nsCOMPtr&lt;nsISupports&gt; child;</span>
<a href="#l18.2053"></a><span id="l18.2053">       rv = subFolders-&gt;GetNext(getter_AddRefs(child));</span>
<a href="#l18.2054"></a><span id="l18.2054" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; child)</span>
<a href="#l18.2055"></a><span id="l18.2055" class="difflineminus">-      {</span>
<a href="#l18.2056"></a><span id="l18.2056" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; child) {</span>
<a href="#l18.2057"></a><span id="l18.2057">         bool childVerified = false;</span>
<a href="#l18.2058"></a><span id="l18.2058" class="difflineminus">-        nsCOMPtr &lt;nsIMsgImapMailFolder&gt; childImapFolder = do_QueryInterface(child, &amp;rv);</span>
<a href="#l18.2059"></a><span id="l18.2059" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; childImapFolder)</span>
<a href="#l18.2060"></a><span id="l18.2060" class="difflineminus">-        {</span>
<a href="#l18.2061"></a><span id="l18.2061" class="difflineplus">+        nsCOMPtr&lt;nsIMsgImapMailFolder&gt; childImapFolder =</span>
<a href="#l18.2062"></a><span id="l18.2062" class="difflineplus">+            do_QueryInterface(child, &amp;rv);</span>
<a href="#l18.2063"></a><span id="l18.2063" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; childImapFolder) {</span>
<a href="#l18.2064"></a><span id="l18.2064">           uint32_t flags;</span>
<a href="#l18.2065"></a><span id="l18.2065"> </span>
<a href="#l18.2066"></a><span id="l18.2066" class="difflineminus">-          nsCOMPtr &lt;nsIMsgFolder&gt; childFolder = do_QueryInterface(child, &amp;rv);</span>
<a href="#l18.2067"></a><span id="l18.2067" class="difflineplus">+          nsCOMPtr&lt;nsIMsgFolder&gt; childFolder = do_QueryInterface(child, &amp;rv);</span>
<a href="#l18.2068"></a><span id="l18.2068">           rv = childImapFolder-&gt;GetVerifiedAsOnlineFolder(&amp;childVerified);</span>
<a href="#l18.2069"></a><span id="l18.2069"> </span>
<a href="#l18.2070"></a><span id="l18.2070">           rv = childFolder-&gt;GetFlags(&amp;flags);</span>
<a href="#l18.2071"></a><span id="l18.2071" class="difflineminus">-          bool folderIsNoSelectFolder = NS_SUCCEEDED(rv) &amp;&amp; ((flags &amp; nsMsgFolderFlags::ImapNoselect) != 0);</span>
<a href="#l18.2072"></a><span id="l18.2072" class="difflineplus">+          bool folderIsNoSelectFolder =</span>
<a href="#l18.2073"></a><span id="l18.2073" class="difflineplus">+              NS_SUCCEEDED(rv) &amp;&amp;</span>
<a href="#l18.2074"></a><span id="l18.2074" class="difflineplus">+              ((flags &amp; nsMsgFolderFlags::ImapNoselect) != 0);</span>
<a href="#l18.2075"></a><span id="l18.2075"> </span>
<a href="#l18.2076"></a><span id="l18.2076">           bool usingSubscription = true;</span>
<a href="#l18.2077"></a><span id="l18.2077">           GetUsingSubscription(&amp;usingSubscription);</span>
<a href="#l18.2078"></a><span id="l18.2078" class="difflineminus">-          if (usingSubscription)</span>
<a href="#l18.2079"></a><span id="l18.2079" class="difflineminus">-          {</span>
<a href="#l18.2080"></a><span id="l18.2080" class="difflineplus">+          if (usingSubscription) {</span>
<a href="#l18.2081"></a><span id="l18.2081">             bool folderIsNameSpace = false;</span>
<a href="#l18.2082"></a><span id="l18.2082" class="difflineminus">-            bool noDescendentsAreVerified = NoDescendentsAreVerified(childFolder);</span>
<a href="#l18.2083"></a><span id="l18.2083" class="difflineminus">-            bool shouldDieBecauseNoSelect = (folderIsNoSelectFolder ?</span>
<a href="#l18.2084"></a><span id="l18.2084" class="difflineminus">-              ((noDescendentsAreVerified || AllDescendentsAreNoSelect(childFolder)) &amp;&amp; !folderIsNameSpace)</span>
<a href="#l18.2085"></a><span id="l18.2085" class="difflineminus">-              : false);</span>
<a href="#l18.2086"></a><span id="l18.2086" class="difflineminus">-            if (!childVerified &amp;&amp; (noDescendentsAreVerified || shouldDieBecauseNoSelect))</span>
<a href="#l18.2087"></a><span id="l18.2087" class="difflineminus">-            {</span>
<a href="#l18.2088"></a><span id="l18.2088" class="difflineplus">+            bool noDescendentsAreVerified =</span>
<a href="#l18.2089"></a><span id="l18.2089" class="difflineplus">+                NoDescendentsAreVerified(childFolder);</span>
<a href="#l18.2090"></a><span id="l18.2090" class="difflineplus">+            bool shouldDieBecauseNoSelect =</span>
<a href="#l18.2091"></a><span id="l18.2091" class="difflineplus">+                (folderIsNoSelectFolder</span>
<a href="#l18.2092"></a><span id="l18.2092" class="difflineplus">+                     ? ((noDescendentsAreVerified ||</span>
<a href="#l18.2093"></a><span id="l18.2093" class="difflineplus">+                         AllDescendentsAreNoSelect(childFolder)) &amp;&amp;</span>
<a href="#l18.2094"></a><span id="l18.2094" class="difflineplus">+                        !folderIsNameSpace)</span>
<a href="#l18.2095"></a><span id="l18.2095" class="difflineplus">+                     : false);</span>
<a href="#l18.2096"></a><span id="l18.2096" class="difflineplus">+            if (!childVerified &amp;&amp;</span>
<a href="#l18.2097"></a><span id="l18.2097" class="difflineplus">+                (noDescendentsAreVerified || shouldDieBecauseNoSelect)) {</span>
<a href="#l18.2098"></a><span id="l18.2098">             }</span>
<a href="#l18.2099"></a><span id="l18.2099" class="difflineminus">-          }</span>
<a href="#l18.2100"></a><span id="l18.2100" class="difflineminus">-          else</span>
<a href="#l18.2101"></a><span id="l18.2101" class="difflineminus">-          {</span>
<a href="#l18.2102"></a><span id="l18.2102" class="difflineplus">+          } else {</span>
<a href="#l18.2103"></a><span id="l18.2103">           }</span>
<a href="#l18.2104"></a><span id="l18.2104">         }</span>
<a href="#l18.2105"></a><span id="l18.2105">       }</span>
<a href="#l18.2106"></a><span id="l18.2106">     }</span>
<a href="#l18.2107"></a><span id="l18.2107">   }</span>
<a href="#l18.2108"></a><span id="l18.2108"> </span>
<a href="#l18.2109"></a><span id="l18.2109">   nsCOMPtr&lt;nsIMsgFolder&gt; parent;</span>
<a href="#l18.2110"></a><span id="l18.2110">   rv = curFolder-&gt;GetParent(getter_AddRefs(parent));</span>
<a href="#l18.2111"></a><span id="l18.2111"> </span>
<a href="#l18.2112"></a><span id="l18.2112" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; parent)</span>
<a href="#l18.2113"></a><span id="l18.2113" class="difflineminus">-  {</span>
<a href="#l18.2114"></a><span id="l18.2114" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; parent) {</span>
<a href="#l18.2115"></a><span id="l18.2115">     nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapParent = do_QueryInterface(parent);</span>
<a href="#l18.2116"></a><span id="l18.2116" class="difflineminus">-    if (imapParent)</span>
<a href="#l18.2117"></a><span id="l18.2117" class="difflineminus">-      imapParent-&gt;RemoveSubFolder(curFolder);</span>
<a href="#l18.2118"></a><span id="l18.2118" class="difflineplus">+    if (imapParent) imapParent-&gt;RemoveSubFolder(curFolder);</span>
<a href="#l18.2119"></a><span id="l18.2119">   }</span>
<a href="#l18.2120"></a><span id="l18.2120"> </span>
<a href="#l18.2121"></a><span id="l18.2121">   return rv;</span>
<a href="#l18.2122"></a><span id="l18.2122"> }</span>
<a href="#l18.2123"></a><span id="l18.2123"> </span>
<a href="#l18.2124"></a><span id="l18.2124" class="difflineminus">-bool nsImapIncomingServer::NoDescendentsAreVerified(nsIMsgFolder *parentFolder)</span>
<a href="#l18.2125"></a><span id="l18.2125" class="difflineminus">-{</span>
<a href="#l18.2126"></a><span id="l18.2126" class="difflineplus">+bool nsImapIncomingServer::NoDescendentsAreVerified(</span>
<a href="#l18.2127"></a><span id="l18.2127" class="difflineplus">+    nsIMsgFolder *parentFolder) {</span>
<a href="#l18.2128"></a><span id="l18.2128">   bool nobodyIsVerified = true;</span>
<a href="#l18.2129"></a><span id="l18.2129">   nsCOMPtr&lt;nsISimpleEnumerator&gt; subFolders;</span>
<a href="#l18.2130"></a><span id="l18.2130">   nsresult rv = parentFolder-&gt;GetSubFolders(getter_AddRefs(subFolders));</span>
<a href="#l18.2131"></a><span id="l18.2131" class="difflineminus">-  if(NS_SUCCEEDED(rv))</span>
<a href="#l18.2132"></a><span id="l18.2132" class="difflineminus">-  {</span>
<a href="#l18.2133"></a><span id="l18.2133" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.2134"></a><span id="l18.2134">     bool moreFolders;</span>
<a href="#l18.2135"></a><span id="l18.2135">     while (NS_SUCCEEDED(subFolders-&gt;HasMoreElements(&amp;moreFolders)) &amp;&amp;</span>
<a href="#l18.2136"></a><span id="l18.2136" class="difflineminus">-           moreFolders &amp;&amp; nobodyIsVerified)</span>
<a href="#l18.2137"></a><span id="l18.2137" class="difflineminus">-    {</span>
<a href="#l18.2138"></a><span id="l18.2138" class="difflineplus">+           moreFolders &amp;&amp; nobodyIsVerified) {</span>
<a href="#l18.2139"></a><span id="l18.2139">       nsCOMPtr&lt;nsISupports&gt; child;</span>
<a href="#l18.2140"></a><span id="l18.2140">       rv = subFolders-&gt;GetNext(getter_AddRefs(child));</span>
<a href="#l18.2141"></a><span id="l18.2141" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; child)</span>
<a href="#l18.2142"></a><span id="l18.2142" class="difflineminus">-      {</span>
<a href="#l18.2143"></a><span id="l18.2143" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; child) {</span>
<a href="#l18.2144"></a><span id="l18.2144">         bool childVerified = false;</span>
<a href="#l18.2145"></a><span id="l18.2145" class="difflineminus">-        nsCOMPtr &lt;nsIMsgImapMailFolder&gt; childImapFolder = do_QueryInterface(child, &amp;rv);</span>
<a href="#l18.2146"></a><span id="l18.2146" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; childImapFolder)</span>
<a href="#l18.2147"></a><span id="l18.2147" class="difflineminus">-        {</span>
<a href="#l18.2148"></a><span id="l18.2148" class="difflineminus">-          nsCOMPtr &lt;nsIMsgFolder&gt; childFolder = do_QueryInterface(child, &amp;rv);</span>
<a href="#l18.2149"></a><span id="l18.2149" class="difflineplus">+        nsCOMPtr&lt;nsIMsgImapMailFolder&gt; childImapFolder =</span>
<a href="#l18.2150"></a><span id="l18.2150" class="difflineplus">+            do_QueryInterface(child, &amp;rv);</span>
<a href="#l18.2151"></a><span id="l18.2151" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; childImapFolder) {</span>
<a href="#l18.2152"></a><span id="l18.2152" class="difflineplus">+          nsCOMPtr&lt;nsIMsgFolder&gt; childFolder = do_QueryInterface(child, &amp;rv);</span>
<a href="#l18.2153"></a><span id="l18.2153">           rv = childImapFolder-&gt;GetVerifiedAsOnlineFolder(&amp;childVerified);</span>
<a href="#l18.2154"></a><span id="l18.2154" class="difflineminus">-          nobodyIsVerified = !childVerified &amp;&amp; NoDescendentsAreVerified(childFolder);</span>
<a href="#l18.2155"></a><span id="l18.2155" class="difflineplus">+          nobodyIsVerified =</span>
<a href="#l18.2156"></a><span id="l18.2156" class="difflineplus">+              !childVerified &amp;&amp; NoDescendentsAreVerified(childFolder);</span>
<a href="#l18.2157"></a><span id="l18.2157">         }</span>
<a href="#l18.2158"></a><span id="l18.2158">       }</span>
<a href="#l18.2159"></a><span id="l18.2159">     }</span>
<a href="#l18.2160"></a><span id="l18.2160">   }</span>
<a href="#l18.2161"></a><span id="l18.2161">   return nobodyIsVerified;</span>
<a href="#l18.2162"></a><span id="l18.2162"> }</span>
<a href="#l18.2163"></a><span id="l18.2163"> </span>
<a href="#l18.2164"></a><span id="l18.2164" class="difflineminus">-</span>
<a href="#l18.2165"></a><span id="l18.2165" class="difflineminus">-bool nsImapIncomingServer::AllDescendentsAreNoSelect(nsIMsgFolder *parentFolder)</span>
<a href="#l18.2166"></a><span id="l18.2166" class="difflineminus">-{</span>
<a href="#l18.2167"></a><span id="l18.2167" class="difflineplus">+bool nsImapIncomingServer::AllDescendentsAreNoSelect(</span>
<a href="#l18.2168"></a><span id="l18.2168" class="difflineplus">+    nsIMsgFolder *parentFolder) {</span>
<a href="#l18.2169"></a><span id="l18.2169">   bool allDescendentsAreNoSelect = true;</span>
<a href="#l18.2170"></a><span id="l18.2170">   nsCOMPtr&lt;nsISimpleEnumerator&gt; subFolders;</span>
<a href="#l18.2171"></a><span id="l18.2171">   nsresult rv = parentFolder-&gt;GetSubFolders(getter_AddRefs(subFolders));</span>
<a href="#l18.2172"></a><span id="l18.2172" class="difflineminus">-  if(NS_SUCCEEDED(rv))</span>
<a href="#l18.2173"></a><span id="l18.2173" class="difflineminus">-  {</span>
<a href="#l18.2174"></a><span id="l18.2174" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.2175"></a><span id="l18.2175">     bool moreFolders;</span>
<a href="#l18.2176"></a><span id="l18.2176">     while (NS_SUCCEEDED(subFolders-&gt;HasMoreElements(&amp;moreFolders)) &amp;&amp;</span>
<a href="#l18.2177"></a><span id="l18.2177" class="difflineminus">-           moreFolders &amp;&amp; allDescendentsAreNoSelect)</span>
<a href="#l18.2178"></a><span id="l18.2178" class="difflineminus">-    {</span>
<a href="#l18.2179"></a><span id="l18.2179" class="difflineplus">+           moreFolders &amp;&amp; allDescendentsAreNoSelect) {</span>
<a href="#l18.2180"></a><span id="l18.2180">       nsCOMPtr&lt;nsISupports&gt; child;</span>
<a href="#l18.2181"></a><span id="l18.2181">       rv = subFolders-&gt;GetNext(getter_AddRefs(child));</span>
<a href="#l18.2182"></a><span id="l18.2182" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; child)</span>
<a href="#l18.2183"></a><span id="l18.2183" class="difflineminus">-      {</span>
<a href="#l18.2184"></a><span id="l18.2184" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; child) {</span>
<a href="#l18.2185"></a><span id="l18.2185">         bool childIsNoSelect = false;</span>
<a href="#l18.2186"></a><span id="l18.2186" class="difflineminus">-        nsCOMPtr &lt;nsIMsgImapMailFolder&gt; childImapFolder = do_QueryInterface(child, &amp;rv);</span>
<a href="#l18.2187"></a><span id="l18.2187" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; childImapFolder)</span>
<a href="#l18.2188"></a><span id="l18.2188" class="difflineminus">-        {</span>
<a href="#l18.2189"></a><span id="l18.2189" class="difflineplus">+        nsCOMPtr&lt;nsIMsgImapMailFolder&gt; childImapFolder =</span>
<a href="#l18.2190"></a><span id="l18.2190" class="difflineplus">+            do_QueryInterface(child, &amp;rv);</span>
<a href="#l18.2191"></a><span id="l18.2191" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; childImapFolder) {</span>
<a href="#l18.2192"></a><span id="l18.2192">           uint32_t flags;</span>
<a href="#l18.2193"></a><span id="l18.2193" class="difflineminus">-          nsCOMPtr &lt;nsIMsgFolder&gt; childFolder = do_QueryInterface(child, &amp;rv);</span>
<a href="#l18.2194"></a><span id="l18.2194" class="difflineplus">+          nsCOMPtr&lt;nsIMsgFolder&gt; childFolder = do_QueryInterface(child, &amp;rv);</span>
<a href="#l18.2195"></a><span id="l18.2195">           rv = childFolder-&gt;GetFlags(&amp;flags);</span>
<a href="#l18.2196"></a><span id="l18.2196" class="difflineminus">-          childIsNoSelect = NS_SUCCEEDED(rv) &amp;&amp; (flags &amp; nsMsgFolderFlags::ImapNoselect);</span>
<a href="#l18.2197"></a><span id="l18.2197" class="difflineminus">-          allDescendentsAreNoSelect = !childIsNoSelect &amp;&amp; AllDescendentsAreNoSelect(childFolder);</span>
<a href="#l18.2198"></a><span id="l18.2198" class="difflineplus">+          childIsNoSelect =</span>
<a href="#l18.2199"></a><span id="l18.2199" class="difflineplus">+              NS_SUCCEEDED(rv) &amp;&amp; (flags &amp; nsMsgFolderFlags::ImapNoselect);</span>
<a href="#l18.2200"></a><span id="l18.2200" class="difflineplus">+          allDescendentsAreNoSelect =</span>
<a href="#l18.2201"></a><span id="l18.2201" class="difflineplus">+              !childIsNoSelect &amp;&amp; AllDescendentsAreNoSelect(childFolder);</span>
<a href="#l18.2202"></a><span id="l18.2202">         }</span>
<a href="#l18.2203"></a><span id="l18.2203">       }</span>
<a href="#l18.2204"></a><span id="l18.2204">     }</span>
<a href="#l18.2205"></a><span id="l18.2205">   }</span>
<a href="#l18.2206"></a><span id="l18.2206"> #if 0</span>
<a href="#l18.2207"></a><span id="l18.2207">   int numberOfSubfolders = parentFolder-&gt;GetNumSubFolders();</span>
<a href="#l18.2208"></a><span id="l18.2208"> </span>
<a href="#l18.2209"></a><span id="l18.2209">   for (int childIndex=0; allDescendantsAreNoSelect &amp;&amp; (childIndex &lt; numberOfSubfolders); childIndex++)</span>
<a href="#l18.2210"></a><span id="l18.2210">   {</span>
<a href="#l18.2211"></a><span id="l18.2211">     MSG_IMAPFolderInfoMail *currentChild = (MSG_IMAPFolderInfoMail *) parentFolder-&gt;GetSubFolder(childIndex);</span>
<a href="#l18.2212"></a><span id="l18.2212">     allDescendentsAreNoSelect = (currentChild-&gt;GetFolderPrefFlags() &amp; MSG_FOLDER_PREF_IMAPNOSELECT) &amp;&amp;</span>
<a href="#l18.2213"></a><span id="l18.2213">       AllDescendentsAreNoSelect(currentChild);</span>
<a href="#l18.2214"></a><span id="l18.2214">   }</span>
<a href="#l18.2215"></a><span id="l18.2215" class="difflineminus">-#endif // 0</span>
<a href="#l18.2216"></a><span id="l18.2216" class="difflineplus">+#endif  // 0</span>
<a href="#l18.2217"></a><span id="l18.2217">   return allDescendentsAreNoSelect;</span>
<a href="#l18.2218"></a><span id="l18.2218"> }</span>
<a href="#l18.2219"></a><span id="l18.2219"> </span>
<a href="#l18.2220"></a><span id="l18.2220"> NS_IMETHODIMP</span>
<a href="#l18.2221"></a><span id="l18.2221"> nsImapIncomingServer::PromptLoginFailed(nsIMsgWindow *aMsgWindow,</span>
<a href="#l18.2222"></a><span id="l18.2222" class="difflineminus">-                                        int32_t *aResult)</span>
<a href="#l18.2223"></a><span id="l18.2223" class="difflineminus">-{</span>
<a href="#l18.2224"></a><span id="l18.2224" class="difflineplus">+                                        int32_t *aResult) {</span>
<a href="#l18.2225"></a><span id="l18.2225">   nsAutoCString hostName;</span>
<a href="#l18.2226"></a><span id="l18.2226">   GetRealHostName(hostName);</span>
<a href="#l18.2227"></a><span id="l18.2227"> </span>
<a href="#l18.2228"></a><span id="l18.2228">   nsAutoCString userName;</span>
<a href="#l18.2229"></a><span id="l18.2229">   GetRealUsername(userName);</span>
<a href="#l18.2230"></a><span id="l18.2230"> </span>
<a href="#l18.2231"></a><span id="l18.2231">   nsAutoString accountName;</span>
<a href="#l18.2232"></a><span id="l18.2232">   GetPrettyName(accountName);</span>
<a href="#l18.2233"></a><span id="l18.2233"> </span>
<a href="#l18.2234"></a><span id="l18.2234" class="difflineminus">-  return MsgPromptLoginFailed(aMsgWindow, hostName, userName, accountName, aResult);</span>
<a href="#l18.2235"></a><span id="l18.2235" class="difflineplus">+  return MsgPromptLoginFailed(aMsgWindow, hostName, userName, accountName,</span>
<a href="#l18.2236"></a><span id="l18.2236" class="difflineplus">+                              aResult);</span>
<a href="#l18.2237"></a><span id="l18.2237"> }</span>
<a href="#l18.2238"></a><span id="l18.2238"> </span>
<a href="#l18.2239"></a><span id="l18.2239"> NS_IMETHODIMP</span>
<a href="#l18.2240"></a><span id="l18.2240" class="difflineminus">-nsImapIncomingServer::FEAlert(const nsAString&amp; aAlertString,</span>
<a href="#l18.2241"></a><span id="l18.2241" class="difflineminus">-                              nsIMsgMailNewsUrl *aUrl)</span>
<a href="#l18.2242"></a><span id="l18.2242" class="difflineminus">-{</span>
<a href="#l18.2243"></a><span id="l18.2243" class="difflineplus">+nsImapIncomingServer::FEAlert(const nsAString &amp;aAlertString,</span>
<a href="#l18.2244"></a><span id="l18.2244" class="difflineplus">+                              nsIMsgMailNewsUrl *aUrl) {</span>
<a href="#l18.2245"></a><span id="l18.2245">   GetStringBundle();</span>
<a href="#l18.2246"></a><span id="l18.2246"> </span>
<a href="#l18.2247"></a><span id="l18.2247" class="difflineminus">-  if (m_stringBundle)</span>
<a href="#l18.2248"></a><span id="l18.2248" class="difflineminus">-  {</span>
<a href="#l18.2249"></a><span id="l18.2249" class="difflineplus">+  if (m_stringBundle) {</span>
<a href="#l18.2250"></a><span id="l18.2250">     nsAutoString hostName;</span>
<a href="#l18.2251"></a><span id="l18.2251">     nsresult rv = GetPrettyName(hostName);</span>
<a href="#l18.2252"></a><span id="l18.2252" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l18.2253"></a><span id="l18.2253" class="difflineminus">-    {</span>
<a href="#l18.2254"></a><span id="l18.2254" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.2255"></a><span id="l18.2255">       nsString message;</span>
<a href="#l18.2256"></a><span id="l18.2256">       nsString tempString(aAlertString);</span>
<a href="#l18.2257"></a><span id="l18.2257" class="difflineminus">-      const char16_t *params[] = { hostName.get(), tempString.get() };</span>
<a href="#l18.2258"></a><span id="l18.2258" class="difflineminus">-</span>
<a href="#l18.2259"></a><span id="l18.2259" class="difflineminus">-      rv = m_stringBundle-&gt;FormatStringFromName(</span>
<a href="#l18.2260"></a><span id="l18.2260" class="difflineminus">-        &quot;imapServerAlert&quot;,</span>
<a href="#l18.2261"></a><span id="l18.2261" class="difflineminus">-        params, 2, message);</span>
<a href="#l18.2262"></a><span id="l18.2262" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l18.2263"></a><span id="l18.2263" class="difflineminus">-        return AlertUser(message, aUrl);</span>
<a href="#l18.2264"></a><span id="l18.2264" class="difflineplus">+      const char16_t *params[] = {hostName.get(), tempString.get()};</span>
<a href="#l18.2265"></a><span id="l18.2265" class="difflineplus">+</span>
<a href="#l18.2266"></a><span id="l18.2266" class="difflineplus">+      rv = m_stringBundle-&gt;FormatStringFromName(&quot;imapServerAlert&quot;, params, 2,</span>
<a href="#l18.2267"></a><span id="l18.2267" class="difflineplus">+                                                message);</span>
<a href="#l18.2268"></a><span id="l18.2268" class="difflineplus">+      if (NS_SUCCEEDED(rv)) return AlertUser(message, aUrl);</span>
<a href="#l18.2269"></a><span id="l18.2269">     }</span>
<a href="#l18.2270"></a><span id="l18.2270">   }</span>
<a href="#l18.2271"></a><span id="l18.2271">   return AlertUser(aAlertString, aUrl);</span>
<a href="#l18.2272"></a><span id="l18.2272"> }</span>
<a href="#l18.2273"></a><span id="l18.2273"> </span>
<a href="#l18.2274"></a><span id="l18.2274" class="difflineminus">-nsresult nsImapIncomingServer::AlertUser(const nsAString&amp; aString,</span>
<a href="#l18.2275"></a><span id="l18.2275" class="difflineminus">-                                         nsIMsgMailNewsUrl *aUrl)</span>
<a href="#l18.2276"></a><span id="l18.2276" class="difflineminus">-{</span>
<a href="#l18.2277"></a><span id="l18.2277" class="difflineplus">+nsresult nsImapIncomingServer::AlertUser(const nsAString &amp;aString,</span>
<a href="#l18.2278"></a><span id="l18.2278" class="difflineplus">+                                         nsIMsgMailNewsUrl *aUrl) {</span>
<a href="#l18.2279"></a><span id="l18.2279">   nsresult rv;</span>
<a href="#l18.2280"></a><span id="l18.2280" class="difflineminus">-  nsCOMPtr &lt;nsIMsgMailSession&gt; mailSession =</span>
<a href="#l18.2281"></a><span id="l18.2281" class="difflineminus">-    do_GetService(NS_MSGMAILSESSION_CONTRACTID, &amp;rv);</span>
<a href="#l18.2282"></a><span id="l18.2282" class="difflineplus">+  nsCOMPtr&lt;nsIMsgMailSession&gt; mailSession =</span>
<a href="#l18.2283"></a><span id="l18.2283" class="difflineplus">+      do_GetService(NS_MSGMAILSESSION_CONTRACTID, &amp;rv);</span>
<a href="#l18.2284"></a><span id="l18.2284">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2285"></a><span id="l18.2285"> </span>
<a href="#l18.2286"></a><span id="l18.2286">   return mailSession-&gt;AlertUser(aString, aUrl);</span>
<a href="#l18.2287"></a><span id="l18.2287"> }</span>
<a href="#l18.2288"></a><span id="l18.2288"> </span>
<a href="#l18.2289"></a><span id="l18.2289"> NS_IMETHODIMP</span>
<a href="#l18.2290"></a><span id="l18.2290" class="difflineminus">-nsImapIncomingServer::FEAlertWithName(const char* aMsgName, nsIMsgMailNewsUrl *aUrl)</span>
<a href="#l18.2291"></a><span id="l18.2291" class="difflineminus">-{</span>
<a href="#l18.2292"></a><span id="l18.2292" class="difflineplus">+nsImapIncomingServer::FEAlertWithName(const char *aMsgName,</span>
<a href="#l18.2293"></a><span id="l18.2293" class="difflineplus">+                                      nsIMsgMailNewsUrl *aUrl) {</span>
<a href="#l18.2294"></a><span id="l18.2294">   // don't bother the user if we're shutting down.</span>
<a href="#l18.2295"></a><span id="l18.2295" class="difflineminus">-  if (m_shuttingDown)</span>
<a href="#l18.2296"></a><span id="l18.2296" class="difflineminus">-    return NS_OK;</span>
<a href="#l18.2297"></a><span id="l18.2297" class="difflineplus">+  if (m_shuttingDown) return NS_OK;</span>
<a href="#l18.2298"></a><span id="l18.2298"> </span>
<a href="#l18.2299"></a><span id="l18.2299">   GetStringBundle();</span>
<a href="#l18.2300"></a><span id="l18.2300"> </span>
<a href="#l18.2301"></a><span id="l18.2301">   nsString message;</span>
<a href="#l18.2302"></a><span id="l18.2302"> </span>
<a href="#l18.2303"></a><span id="l18.2303" class="difflineminus">-  if (m_stringBundle)</span>
<a href="#l18.2304"></a><span id="l18.2304" class="difflineminus">-  {</span>
<a href="#l18.2305"></a><span id="l18.2305" class="difflineplus">+  if (m_stringBundle) {</span>
<a href="#l18.2306"></a><span id="l18.2306">     nsAutoCString hostName;</span>
<a href="#l18.2307"></a><span id="l18.2307">     nsresult rv = GetHostName(hostName);</span>
<a href="#l18.2308"></a><span id="l18.2308" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l18.2309"></a><span id="l18.2309" class="difflineminus">-    {</span>
<a href="#l18.2310"></a><span id="l18.2310" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.2311"></a><span id="l18.2311">       const NS_ConvertUTF8toUTF16 hostName16(hostName);</span>
<a href="#l18.2312"></a><span id="l18.2312" class="difflineminus">-      const char16_t *params[] = { hostName16.get() };</span>
<a href="#l18.2313"></a><span id="l18.2313" class="difflineminus">-      rv = m_stringBundle-&gt;FormatStringFromName(</span>
<a href="#l18.2314"></a><span id="l18.2314" class="difflineminus">-        aMsgName,</span>
<a href="#l18.2315"></a><span id="l18.2315" class="difflineminus">-        params, 1,message);</span>
<a href="#l18.2316"></a><span id="l18.2316" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l18.2317"></a><span id="l18.2317" class="difflineminus">-        return AlertUser(message, aUrl);</span>
<a href="#l18.2318"></a><span id="l18.2318" class="difflineplus">+      const char16_t *params[] = {hostName16.get()};</span>
<a href="#l18.2319"></a><span id="l18.2319" class="difflineplus">+      rv = m_stringBundle-&gt;FormatStringFromName(aMsgName, params, 1, message);</span>
<a href="#l18.2320"></a><span id="l18.2320" class="difflineplus">+      if (NS_SUCCEEDED(rv)) return AlertUser(message, aUrl);</span>
<a href="#l18.2321"></a><span id="l18.2321">     }</span>
<a href="#l18.2322"></a><span id="l18.2322">   }</span>
<a href="#l18.2323"></a><span id="l18.2323"> </span>
<a href="#l18.2324"></a><span id="l18.2324">   // Error condition</span>
<a href="#l18.2325"></a><span id="l18.2325">   message.AssignLiteral(&quot;String Name &quot;);</span>
<a href="#l18.2326"></a><span id="l18.2326">   message.AppendASCII(aMsgName);</span>
<a href="#l18.2327"></a><span id="l18.2327">   FEAlert(message, aUrl);</span>
<a href="#l18.2328"></a><span id="l18.2328">   return NS_OK;</span>
<a href="#l18.2329"></a><span id="l18.2329"> }</span>
<a href="#l18.2330"></a><span id="l18.2330"> </span>
<a href="#l18.2331"></a><span id="l18.2331" class="difflineminus">-NS_IMETHODIMP  nsImapIncomingServer::FEAlertFromServer(const nsACString&amp; aServerString,</span>
<a href="#l18.2332"></a><span id="l18.2332" class="difflineminus">-                                                       nsIMsgMailNewsUrl *aUrl)</span>
<a href="#l18.2333"></a><span id="l18.2333" class="difflineminus">-{</span>
<a href="#l18.2334"></a><span id="l18.2334" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::FEAlertFromServer(</span>
<a href="#l18.2335"></a><span id="l18.2335" class="difflineplus">+    const nsACString &amp;aServerString, nsIMsgMailNewsUrl *aUrl) {</span>
<a href="#l18.2336"></a><span id="l18.2336">   NS_ENSURE_TRUE(!aServerString.IsEmpty(), NS_OK);</span>
<a href="#l18.2337"></a><span id="l18.2337"> </span>
<a href="#l18.2338"></a><span id="l18.2338">   nsCString message(aServerString);</span>
<a href="#l18.2339"></a><span id="l18.2339">   message.Trim(&quot; \t\b\r\n&quot;);</span>
<a href="#l18.2340"></a><span id="l18.2340" class="difflineminus">-  if (message.Last() != '.')</span>
<a href="#l18.2341"></a><span id="l18.2341" class="difflineminus">-    message.Append('.');</span>
<a href="#l18.2342"></a><span id="l18.2342" class="difflineplus">+  if (message.Last() != '.') message.Append('.');</span>
<a href="#l18.2343"></a><span id="l18.2343"> </span>
<a href="#l18.2344"></a><span id="l18.2344">   // Skip over the first two words (the command tag and &quot;NO&quot;).</span>
<a href="#l18.2345"></a><span id="l18.2345">   // Find the first word break.</span>
<a href="#l18.2346"></a><span id="l18.2346">   int32_t pos = message.FindChar(' ');</span>
<a href="#l18.2347"></a><span id="l18.2347"> </span>
<a href="#l18.2348"></a><span id="l18.2348">   // Find the second word break.</span>
<a href="#l18.2349"></a><span id="l18.2349" class="difflineminus">-  if (pos != -1)</span>
<a href="#l18.2350"></a><span id="l18.2350" class="difflineminus">-    pos = message.FindChar(' ', pos + 1);</span>
<a href="#l18.2351"></a><span id="l18.2351" class="difflineplus">+  if (pos != -1) pos = message.FindChar(' ', pos + 1);</span>
<a href="#l18.2352"></a><span id="l18.2352"> </span>
<a href="#l18.2353"></a><span id="l18.2353">   // Adjust the message.</span>
<a href="#l18.2354"></a><span id="l18.2354" class="difflineminus">-  if (pos != -1)</span>
<a href="#l18.2355"></a><span id="l18.2355" class="difflineminus">-    message = Substring(message, pos + 1);</span>
<a href="#l18.2356"></a><span id="l18.2356" class="difflineplus">+  if (pos != -1) message = Substring(message, pos + 1);</span>
<a href="#l18.2357"></a><span id="l18.2357"> </span>
<a href="#l18.2358"></a><span id="l18.2358">   nsString hostName;</span>
<a href="#l18.2359"></a><span id="l18.2359">   GetPrettyName(hostName);</span>
<a href="#l18.2360"></a><span id="l18.2360"> </span>
<a href="#l18.2361"></a><span id="l18.2361" class="difflineminus">-  const char16_t *formatStrings[] =</span>
<a href="#l18.2362"></a><span id="l18.2362" class="difflineminus">-  {</span>
<a href="#l18.2363"></a><span id="l18.2363" class="difflineminus">-    hostName.get(),</span>
<a href="#l18.2364"></a><span id="l18.2364" class="difflineminus">-    nullptr,</span>
<a href="#l18.2365"></a><span id="l18.2365" class="difflineminus">-    nullptr</span>
<a href="#l18.2366"></a><span id="l18.2366" class="difflineminus">-  };</span>
<a href="#l18.2367"></a><span id="l18.2367" class="difflineminus">-</span>
<a href="#l18.2368"></a><span id="l18.2368" class="difflineminus">-  const char* msgName;</span>
<a href="#l18.2369"></a><span id="l18.2369" class="difflineplus">+  const char16_t *formatStrings[] = {hostName.get(), nullptr, nullptr};</span>
<a href="#l18.2370"></a><span id="l18.2370" class="difflineplus">+</span>
<a href="#l18.2371"></a><span id="l18.2371" class="difflineplus">+  const char *msgName;</span>
<a href="#l18.2372"></a><span id="l18.2372">   int32_t numStrings;</span>
<a href="#l18.2373"></a><span id="l18.2373">   nsString fullMessage;</span>
<a href="#l18.2374"></a><span id="l18.2374">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(aUrl);</span>
<a href="#l18.2375"></a><span id="l18.2375">   NS_ENSURE_TRUE(imapUrl, NS_ERROR_INVALID_ARG);</span>
<a href="#l18.2376"></a><span id="l18.2376"> </span>
<a href="#l18.2377"></a><span id="l18.2377">   nsImapState imapState;</span>
<a href="#l18.2378"></a><span id="l18.2378">   nsImapAction imapAction;</span>
<a href="#l18.2379"></a><span id="l18.2379"> </span>
<a href="#l18.2380"></a><span id="l18.2380">   imapUrl-&gt;GetRequiredImapState(&amp;imapState);</span>
<a href="#l18.2381"></a><span id="l18.2381">   imapUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l18.2382"></a><span id="l18.2382">   nsString folderName;</span>
<a href="#l18.2383"></a><span id="l18.2383"> </span>
<a href="#l18.2384"></a><span id="l18.2384">   NS_ConvertUTF8toUTF16 unicodeMsg(message);</span>
<a href="#l18.2385"></a><span id="l18.2385"> </span>
<a href="#l18.2386"></a><span id="l18.2386">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l18.2387"></a><span id="l18.2387">   if (imapState == nsIImapUrl::nsImapSelectedState ||</span>
<a href="#l18.2388"></a><span id="l18.2388" class="difflineminus">-      imapAction == nsIImapUrl::nsImapFolderStatus)</span>
<a href="#l18.2389"></a><span id="l18.2389" class="difflineminus">-  {</span>
<a href="#l18.2390"></a><span id="l18.2390" class="difflineplus">+      imapAction == nsIImapUrl::nsImapFolderStatus) {</span>
<a href="#l18.2391"></a><span id="l18.2391">     aUrl-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l18.2392"></a><span id="l18.2392" class="difflineminus">-    if (folder)</span>
<a href="#l18.2393"></a><span id="l18.2393" class="difflineminus">-      folder-&gt;GetPrettyName(folderName);</span>
<a href="#l18.2394"></a><span id="l18.2394" class="difflineplus">+    if (folder) folder-&gt;GetPrettyName(folderName);</span>
<a href="#l18.2395"></a><span id="l18.2395">     numStrings = 3;</span>
<a href="#l18.2396"></a><span id="l18.2396">     msgName = &quot;imapFolderCommandFailed&quot;;</span>
<a href="#l18.2397"></a><span id="l18.2397">     formatStrings[1] = folderName.get();</span>
<a href="#l18.2398"></a><span id="l18.2398" class="difflineminus">-  }</span>
<a href="#l18.2399"></a><span id="l18.2399" class="difflineminus">-  else</span>
<a href="#l18.2400"></a><span id="l18.2400" class="difflineminus">-  {</span>
<a href="#l18.2401"></a><span id="l18.2401" class="difflineplus">+  } else {</span>
<a href="#l18.2402"></a><span id="l18.2402">     msgName = &quot;imapServerCommandFailed&quot;;</span>
<a href="#l18.2403"></a><span id="l18.2403">     numStrings = 2;</span>
<a href="#l18.2404"></a><span id="l18.2404">   }</span>
<a href="#l18.2405"></a><span id="l18.2405"> </span>
<a href="#l18.2406"></a><span id="l18.2406" class="difflineminus">-  formatStrings[numStrings -1] = unicodeMsg.get();</span>
<a href="#l18.2407"></a><span id="l18.2407" class="difflineplus">+  formatStrings[numStrings - 1] = unicodeMsg.get();</span>
<a href="#l18.2408"></a><span id="l18.2408"> </span>
<a href="#l18.2409"></a><span id="l18.2409">   nsresult rv = GetStringBundle();</span>
<a href="#l18.2410"></a><span id="l18.2410">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2411"></a><span id="l18.2411" class="difflineminus">-  if (m_stringBundle)</span>
<a href="#l18.2412"></a><span id="l18.2412" class="difflineminus">-  {</span>
<a href="#l18.2413"></a><span id="l18.2413" class="difflineminus">-    rv = m_stringBundle-&gt;FormatStringFromName(msgName,</span>
<a href="#l18.2414"></a><span id="l18.2414" class="difflineminus">-      formatStrings, numStrings, fullMessage);</span>
<a href="#l18.2415"></a><span id="l18.2415" class="difflineplus">+  if (m_stringBundle) {</span>
<a href="#l18.2416"></a><span id="l18.2416" class="difflineplus">+    rv = m_stringBundle-&gt;FormatStringFromName(msgName, formatStrings,</span>
<a href="#l18.2417"></a><span id="l18.2417" class="difflineplus">+                                              numStrings, fullMessage);</span>
<a href="#l18.2418"></a><span id="l18.2418">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2419"></a><span id="l18.2419">   }</span>
<a href="#l18.2420"></a><span id="l18.2420"> </span>
<a href="#l18.2421"></a><span id="l18.2421">   return AlertUser(fullMessage, aUrl);</span>
<a href="#l18.2422"></a><span id="l18.2422"> }</span>
<a href="#l18.2423"></a><span id="l18.2423"> </span>
<a href="#l18.2424"></a><span id="l18.2424" class="difflineminus">-#define IMAP_MSGS_URL       &quot;chrome://messenger/locale/imapMsgs.properties&quot;</span>
<a href="#l18.2425"></a><span id="l18.2425" class="difflineminus">-</span>
<a href="#l18.2426"></a><span id="l18.2426" class="difflineminus">-nsresult nsImapIncomingServer::GetStringBundle()</span>
<a href="#l18.2427"></a><span id="l18.2427" class="difflineminus">-{</span>
<a href="#l18.2428"></a><span id="l18.2428" class="difflineminus">-  if (m_stringBundle)</span>
<a href="#l18.2429"></a><span id="l18.2429" class="difflineminus">-    return NS_OK;</span>
<a href="#l18.2430"></a><span id="l18.2430" class="difflineplus">+#define IMAP_MSGS_URL &quot;chrome://messenger/locale/imapMsgs.properties&quot;</span>
<a href="#l18.2431"></a><span id="l18.2431" class="difflineplus">+</span>
<a href="#l18.2432"></a><span id="l18.2432" class="difflineplus">+nsresult nsImapIncomingServer::GetStringBundle() {</span>
<a href="#l18.2433"></a><span id="l18.2433" class="difflineplus">+  if (m_stringBundle) return NS_OK;</span>
<a href="#l18.2434"></a><span id="l18.2434"> </span>
<a href="#l18.2435"></a><span id="l18.2435">   nsCOMPtr&lt;nsIStringBundleService&gt; sBundleService =</span>
<a href="#l18.2436"></a><span id="l18.2436" class="difflineminus">-    mozilla::services::GetStringBundleService();</span>
<a href="#l18.2437"></a><span id="l18.2437" class="difflineplus">+      mozilla::services::GetStringBundleService();</span>
<a href="#l18.2438"></a><span id="l18.2438">   NS_ENSURE_TRUE(sBundleService, NS_ERROR_UNEXPECTED);</span>
<a href="#l18.2439"></a><span id="l18.2439" class="difflineminus">-  return sBundleService-&gt;CreateBundle(IMAP_MSGS_URL, getter_AddRefs(m_stringBundle));</span>
<a href="#l18.2440"></a><span id="l18.2440" class="difflineplus">+  return sBundleService-&gt;CreateBundle(IMAP_MSGS_URL,</span>
<a href="#l18.2441"></a><span id="l18.2441" class="difflineplus">+                                      getter_AddRefs(m_stringBundle));</span>
<a href="#l18.2442"></a><span id="l18.2442"> }</span>
<a href="#l18.2443"></a><span id="l18.2443"> </span>
<a href="#l18.2444"></a><span id="l18.2444"> NS_IMETHODIMP</span>
<a href="#l18.2445"></a><span id="l18.2445" class="difflineminus">-nsImapIncomingServer::GetImapStringByName(const char* msgName, nsAString&amp; aString)</span>
<a href="#l18.2446"></a><span id="l18.2446" class="difflineminus">-{</span>
<a href="#l18.2447"></a><span id="l18.2447" class="difflineplus">+nsImapIncomingServer::GetImapStringByName(const char *msgName,</span>
<a href="#l18.2448"></a><span id="l18.2448" class="difflineplus">+                                          nsAString &amp;aString) {</span>
<a href="#l18.2449"></a><span id="l18.2449">   nsresult rv = NS_OK;</span>
<a href="#l18.2450"></a><span id="l18.2450">   GetStringBundle();</span>
<a href="#l18.2451"></a><span id="l18.2451" class="difflineminus">-  if (m_stringBundle)</span>
<a href="#l18.2452"></a><span id="l18.2452" class="difflineminus">-  {</span>
<a href="#l18.2453"></a><span id="l18.2453" class="difflineplus">+  if (m_stringBundle) {</span>
<a href="#l18.2454"></a><span id="l18.2454">     nsString res_str;</span>
<a href="#l18.2455"></a><span id="l18.2455">     rv = m_stringBundle-&gt;GetStringFromName(msgName, res_str);</span>
<a href="#l18.2456"></a><span id="l18.2456">     aString.Assign(res_str);</span>
<a href="#l18.2457"></a><span id="l18.2457" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l18.2458"></a><span id="l18.2458" class="difflineminus">-      return rv;</span>
<a href="#l18.2459"></a><span id="l18.2459" class="difflineplus">+    if (NS_SUCCEEDED(rv)) return rv;</span>
<a href="#l18.2460"></a><span id="l18.2460">   }</span>
<a href="#l18.2461"></a><span id="l18.2461">   aString.AssignLiteral(&quot;String Name &quot;);</span>
<a href="#l18.2462"></a><span id="l18.2462">   // mscott: FIX ME</span>
<a href="#l18.2463"></a><span id="l18.2463">   aString.AppendASCII(msgName);</span>
<a href="#l18.2464"></a><span id="l18.2464">   return NS_OK;</span>
<a href="#l18.2465"></a><span id="l18.2465"> }</span>
<a href="#l18.2466"></a><span id="l18.2466"> </span>
<a href="#l18.2467"></a><span id="l18.2467" class="difflineminus">-nsresult nsImapIncomingServer::ResetFoldersToUnverified(nsIMsgFolder *parentFolder)</span>
<a href="#l18.2468"></a><span id="l18.2468" class="difflineminus">-{</span>
<a href="#l18.2469"></a><span id="l18.2469" class="difflineplus">+nsresult nsImapIncomingServer::ResetFoldersToUnverified(</span>
<a href="#l18.2470"></a><span id="l18.2470" class="difflineplus">+    nsIMsgFolder *parentFolder) {</span>
<a href="#l18.2471"></a><span id="l18.2471">   nsresult rv = NS_OK;</span>
<a href="#l18.2472"></a><span id="l18.2472" class="difflineminus">-  if (!parentFolder)</span>
<a href="#l18.2473"></a><span id="l18.2473" class="difflineminus">-  {</span>
<a href="#l18.2474"></a><span id="l18.2474" class="difflineplus">+  if (!parentFolder) {</span>
<a href="#l18.2475"></a><span id="l18.2475">     nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.2476"></a><span id="l18.2476">     rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l18.2477"></a><span id="l18.2477">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2478"></a><span id="l18.2478">     return ResetFoldersToUnverified(rootFolder);</span>
<a href="#l18.2479"></a><span id="l18.2479">   }</span>
<a href="#l18.2480"></a><span id="l18.2480"> </span>
<a href="#l18.2481"></a><span id="l18.2481">   nsCOMPtr&lt;nsISimpleEnumerator&gt; subFolders;</span>
<a href="#l18.2482"></a><span id="l18.2482" class="difflineminus">-  nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(parentFolder, &amp;rv);</span>
<a href="#l18.2483"></a><span id="l18.2483" class="difflineplus">+  nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder =</span>
<a href="#l18.2484"></a><span id="l18.2484" class="difflineplus">+      do_QueryInterface(parentFolder, &amp;rv);</span>
<a href="#l18.2485"></a><span id="l18.2485">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2486"></a><span id="l18.2486">   rv = imapFolder-&gt;SetVerifiedAsOnlineFolder(false);</span>
<a href="#l18.2487"></a><span id="l18.2487">   rv = parentFolder-&gt;GetSubFolders(getter_AddRefs(subFolders));</span>
<a href="#l18.2488"></a><span id="l18.2488">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2489"></a><span id="l18.2489"> </span>
<a href="#l18.2490"></a><span id="l18.2490">   bool moreFolders = false;</span>
<a href="#l18.2491"></a><span id="l18.2491" class="difflineminus">-  while (NS_SUCCEEDED(subFolders-&gt;HasMoreElements(&amp;moreFolders)) &amp;&amp; moreFolders)</span>
<a href="#l18.2492"></a><span id="l18.2492" class="difflineminus">-  {</span>
<a href="#l18.2493"></a><span id="l18.2493" class="difflineplus">+  while (NS_SUCCEEDED(subFolders-&gt;HasMoreElements(&amp;moreFolders)) &amp;&amp;</span>
<a href="#l18.2494"></a><span id="l18.2494" class="difflineplus">+         moreFolders) {</span>
<a href="#l18.2495"></a><span id="l18.2495">     nsCOMPtr&lt;nsISupports&gt; child;</span>
<a href="#l18.2496"></a><span id="l18.2496">     rv = subFolders-&gt;GetNext(getter_AddRefs(child));</span>
<a href="#l18.2497"></a><span id="l18.2497" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; child)</span>
<a href="#l18.2498"></a><span id="l18.2498" class="difflineminus">-    {</span>
<a href="#l18.2499"></a><span id="l18.2499" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; child) {</span>
<a href="#l18.2500"></a><span id="l18.2500">       nsCOMPtr&lt;nsIMsgFolder&gt; childFolder = do_QueryInterface(child, &amp;rv);</span>
<a href="#l18.2501"></a><span id="l18.2501" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; childFolder)</span>
<a href="#l18.2502"></a><span id="l18.2502" class="difflineminus">-      {</span>
<a href="#l18.2503"></a><span id="l18.2503" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; childFolder) {</span>
<a href="#l18.2504"></a><span id="l18.2504">         rv = ResetFoldersToUnverified(childFolder);</span>
<a href="#l18.2505"></a><span id="l18.2505" class="difflineminus">-        if (NS_FAILED(rv))</span>
<a href="#l18.2506"></a><span id="l18.2506" class="difflineminus">-          break;</span>
<a href="#l18.2507"></a><span id="l18.2507" class="difflineplus">+        if (NS_FAILED(rv)) break;</span>
<a href="#l18.2508"></a><span id="l18.2508">       }</span>
<a href="#l18.2509"></a><span id="l18.2509">     }</span>
<a href="#l18.2510"></a><span id="l18.2510">   }</span>
<a href="#l18.2511"></a><span id="l18.2511"> </span>
<a href="#l18.2512"></a><span id="l18.2512">   return rv;</span>
<a href="#l18.2513"></a><span id="l18.2513"> }</span>
<a href="#l18.2514"></a><span id="l18.2514"> </span>
<a href="#l18.2515"></a><span id="l18.2515" class="difflineminus">-void</span>
<a href="#l18.2516"></a><span id="l18.2516" class="difflineminus">-nsImapIncomingServer::GetUnverifiedFolders(nsCOMArray&lt;nsIMsgImapMailFolder&gt; &amp;aFoldersArray)</span>
<a href="#l18.2517"></a><span id="l18.2517" class="difflineminus">-{</span>
<a href="#l18.2518"></a><span id="l18.2518" class="difflineplus">+void nsImapIncomingServer::GetUnverifiedFolders(</span>
<a href="#l18.2519"></a><span id="l18.2519" class="difflineplus">+    nsCOMArray&lt;nsIMsgImapMailFolder&gt; &amp;aFoldersArray) {</span>
<a href="#l18.2520"></a><span id="l18.2520">   nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.2521"></a><span id="l18.2521">   if (NS_FAILED(GetRootFolder(getter_AddRefs(rootFolder))) || !rootFolder)</span>
<a href="#l18.2522"></a><span id="l18.2522">     return;</span>
<a href="#l18.2523"></a><span id="l18.2523"> </span>
<a href="#l18.2524"></a><span id="l18.2524">   nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapRoot(do_QueryInterface(rootFolder));</span>
<a href="#l18.2525"></a><span id="l18.2525">   // don't need to verify the root.</span>
<a href="#l18.2526"></a><span id="l18.2526" class="difflineminus">-  if (imapRoot)</span>
<a href="#l18.2527"></a><span id="l18.2527" class="difflineminus">-    imapRoot-&gt;SetVerifiedAsOnlineFolder(true);</span>
<a href="#l18.2528"></a><span id="l18.2528" class="difflineplus">+  if (imapRoot) imapRoot-&gt;SetVerifiedAsOnlineFolder(true);</span>
<a href="#l18.2529"></a><span id="l18.2529"> </span>
<a href="#l18.2530"></a><span id="l18.2530">   GetUnverifiedSubFolders(rootFolder, aFoldersArray);</span>
<a href="#l18.2531"></a><span id="l18.2531"> }</span>
<a href="#l18.2532"></a><span id="l18.2532"> </span>
<a href="#l18.2533"></a><span id="l18.2533" class="difflineminus">-void</span>
<a href="#l18.2534"></a><span id="l18.2534" class="difflineminus">-nsImapIncomingServer::GetUnverifiedSubFolders(nsIMsgFolder *parentFolder,</span>
<a href="#l18.2535"></a><span id="l18.2535" class="difflineminus">-                                              nsCOMArray&lt;nsIMsgImapMailFolder&gt; &amp;aFoldersArray)</span>
<a href="#l18.2536"></a><span id="l18.2536" class="difflineminus">-{</span>
<a href="#l18.2537"></a><span id="l18.2537" class="difflineplus">+void nsImapIncomingServer::GetUnverifiedSubFolders(</span>
<a href="#l18.2538"></a><span id="l18.2538" class="difflineplus">+    nsIMsgFolder *parentFolder,</span>
<a href="#l18.2539"></a><span id="l18.2539" class="difflineplus">+    nsCOMArray&lt;nsIMsgImapMailFolder&gt; &amp;aFoldersArray) {</span>
<a href="#l18.2540"></a><span id="l18.2540">   nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder(do_QueryInterface(parentFolder));</span>
<a href="#l18.2541"></a><span id="l18.2541"> </span>
<a href="#l18.2542"></a><span id="l18.2542">   bool verified = false, explicitlyVerify = false;</span>
<a href="#l18.2543"></a><span id="l18.2543" class="difflineminus">-  if (imapFolder)</span>
<a href="#l18.2544"></a><span id="l18.2544" class="difflineminus">-  {</span>
<a href="#l18.2545"></a><span id="l18.2545" class="difflineplus">+  if (imapFolder) {</span>
<a href="#l18.2546"></a><span id="l18.2546">     nsresult rv = imapFolder-&gt;GetVerifiedAsOnlineFolder(&amp;verified);</span>
<a href="#l18.2547"></a><span id="l18.2547">     if (NS_SUCCEEDED(rv))</span>
<a href="#l18.2548"></a><span id="l18.2548">       rv = imapFolder-&gt;GetExplicitlyVerify(&amp;explicitlyVerify);</span>
<a href="#l18.2549"></a><span id="l18.2549"> </span>
<a href="#l18.2550"></a><span id="l18.2550">     if (NS_SUCCEEDED(rv) &amp;&amp; (!verified || explicitlyVerify))</span>
<a href="#l18.2551"></a><span id="l18.2551">       aFoldersArray.AppendObject(imapFolder);</span>
<a href="#l18.2552"></a><span id="l18.2552">   }</span>
<a href="#l18.2553"></a><span id="l18.2553"> </span>
<a href="#l18.2554"></a><span id="l18.2554">   nsCOMPtr&lt;nsISimpleEnumerator&gt; subFolders;</span>
<a href="#l18.2555"></a><span id="l18.2555" class="difflineminus">-  if (NS_SUCCEEDED(parentFolder-&gt;GetSubFolders(getter_AddRefs(subFolders))))</span>
<a href="#l18.2556"></a><span id="l18.2556" class="difflineminus">-  {</span>
<a href="#l18.2557"></a><span id="l18.2557" class="difflineplus">+  if (NS_SUCCEEDED(parentFolder-&gt;GetSubFolders(getter_AddRefs(subFolders)))) {</span>
<a href="#l18.2558"></a><span id="l18.2558">     bool moreFolders;</span>
<a href="#l18.2559"></a><span id="l18.2559"> </span>
<a href="#l18.2560"></a><span id="l18.2560" class="difflineminus">-    while (NS_SUCCEEDED(subFolders-&gt;HasMoreElements(&amp;moreFolders)) &amp;&amp; moreFolders)</span>
<a href="#l18.2561"></a><span id="l18.2561" class="difflineminus">-    {</span>
<a href="#l18.2562"></a><span id="l18.2562" class="difflineplus">+    while (NS_SUCCEEDED(subFolders-&gt;HasMoreElements(&amp;moreFolders)) &amp;&amp;</span>
<a href="#l18.2563"></a><span id="l18.2563" class="difflineplus">+           moreFolders) {</span>
<a href="#l18.2564"></a><span id="l18.2564">       nsCOMPtr&lt;nsISupports&gt; child;</span>
<a href="#l18.2565"></a><span id="l18.2565">       subFolders-&gt;GetNext(getter_AddRefs(child));</span>
<a href="#l18.2566"></a><span id="l18.2566" class="difflineminus">-      if (child)</span>
<a href="#l18.2567"></a><span id="l18.2567" class="difflineminus">-      {</span>
<a href="#l18.2568"></a><span id="l18.2568" class="difflineplus">+      if (child) {</span>
<a href="#l18.2569"></a><span id="l18.2569">         nsCOMPtr&lt;nsIMsgFolder&gt; childFolder(do_QueryInterface(child));</span>
<a href="#l18.2570"></a><span id="l18.2570" class="difflineminus">-        if (childFolder)</span>
<a href="#l18.2571"></a><span id="l18.2571" class="difflineminus">-          GetUnverifiedSubFolders(childFolder, aFoldersArray);</span>
<a href="#l18.2572"></a><span id="l18.2572" class="difflineplus">+        if (childFolder) GetUnverifiedSubFolders(childFolder, aFoldersArray);</span>
<a href="#l18.2573"></a><span id="l18.2573">       }</span>
<a href="#l18.2574"></a><span id="l18.2574">     }</span>
<a href="#l18.2575"></a><span id="l18.2575">   }</span>
<a href="#l18.2576"></a><span id="l18.2576"> }</span>
<a href="#l18.2577"></a><span id="l18.2577"> </span>
<a href="#l18.2578"></a><span id="l18.2578" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::ForgetSessionPassword()</span>
<a href="#l18.2579"></a><span id="l18.2579" class="difflineminus">-{</span>
<a href="#l18.2580"></a><span id="l18.2580" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::ForgetSessionPassword() {</span>
<a href="#l18.2581"></a><span id="l18.2581">   nsresult rv = nsMsgIncomingServer::ForgetSessionPassword();</span>
<a href="#l18.2582"></a><span id="l18.2582" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.2583"></a><span id="l18.2583" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2584"></a><span id="l18.2584"> </span>
<a href="#l18.2585"></a><span id="l18.2585">   // fix for bugscape bug #15485</span>
<a href="#l18.2586"></a><span id="l18.2586">   // if we use turbo, and we logout, we need to make sure</span>
<a href="#l18.2587"></a><span id="l18.2587">   // the server doesn't think it's authenticated.</span>
<a href="#l18.2588"></a><span id="l18.2588">   // the biff timer continues to fire when you use turbo</span>
<a href="#l18.2589"></a><span id="l18.2589">   // (see #143848).  if we exited, we've set the password to null</span>
<a href="#l18.2590"></a><span id="l18.2590">   // but if we're authenticated, and the biff timer goes off</span>
<a href="#l18.2591"></a><span id="l18.2591">   // we'll still perform biff, because we use m_userAuthenticated</span>
<a href="#l18.2592"></a><span id="l18.2592" class="difflineat">@@ -2100,430 +1919,401 @@ NS_IMETHODIMP nsImapIncomingServer::Forg</span>
<a href="#l18.2593"></a><span id="l18.2593">   // (if authenticated, we don't require a password</span>
<a href="#l18.2594"></a><span id="l18.2594">   // see nsMsgBiffManager::PerformBiff())</span>
<a href="#l18.2595"></a><span id="l18.2595">   // performing biff without a password will pop up the prompt dialog</span>
<a href="#l18.2596"></a><span id="l18.2596">   // which is pretty wacky, when it happens after you quit the application</span>
<a href="#l18.2597"></a><span id="l18.2597">   m_userAuthenticated = false;</span>
<a href="#l18.2598"></a><span id="l18.2598">   return NS_OK;</span>
<a href="#l18.2599"></a><span id="l18.2599"> }</span>
<a href="#l18.2600"></a><span id="l18.2600"> </span>
<a href="#l18.2601"></a><span id="l18.2601" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::GetServerRequiresPasswordForBiff(bool *aServerRequiresPasswordForBiff)</span>
<a href="#l18.2602"></a><span id="l18.2602" class="difflineminus">-{</span>
<a href="#l18.2603"></a><span id="l18.2603" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::GetServerRequiresPasswordForBiff(</span>
<a href="#l18.2604"></a><span id="l18.2604" class="difflineplus">+    bool *aServerRequiresPasswordForBiff) {</span>
<a href="#l18.2605"></a><span id="l18.2605">   NS_ENSURE_ARG_POINTER(aServerRequiresPasswordForBiff);</span>
<a href="#l18.2606"></a><span id="l18.2606">   // if the user has already been authenticated, we've got the password</span>
<a href="#l18.2607"></a><span id="l18.2607">   *aServerRequiresPasswordForBiff = !m_userAuthenticated;</span>
<a href="#l18.2608"></a><span id="l18.2608">   return NS_OK;</span>
<a href="#l18.2609"></a><span id="l18.2609"> }</span>
<a href="#l18.2610"></a><span id="l18.2610"> </span>
<a href="#l18.2611"></a><span id="l18.2611" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::ForgetPassword()</span>
<a href="#l18.2612"></a><span id="l18.2612" class="difflineminus">-{</span>
<a href="#l18.2613"></a><span id="l18.2613" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::ForgetPassword() {</span>
<a href="#l18.2614"></a><span id="l18.2614">   return nsMsgIncomingServer::ForgetPassword();</span>
<a href="#l18.2615"></a><span id="l18.2615"> }</span>
<a href="#l18.2616"></a><span id="l18.2616"> </span>
<a href="#l18.2617"></a><span id="l18.2617" class="difflineminus">-</span>
<a href="#l18.2618"></a><span id="l18.2618"> NS_IMETHODIMP</span>
<a href="#l18.2619"></a><span id="l18.2619"> nsImapIncomingServer::AsyncGetPassword(nsIImapProtocol *aProtocol,</span>
<a href="#l18.2620"></a><span id="l18.2620">                                        bool aNewPasswordRequested,</span>
<a href="#l18.2621"></a><span id="l18.2621" class="difflineminus">-                                       nsAString &amp;aPassword)</span>
<a href="#l18.2622"></a><span id="l18.2622" class="difflineminus">-{</span>
<a href="#l18.2623"></a><span id="l18.2623" class="difflineminus">-  if (m_password.IsEmpty())</span>
<a href="#l18.2624"></a><span id="l18.2624" class="difflineminus">-  {</span>
<a href="#l18.2625"></a><span id="l18.2625" class="difflineplus">+                                       nsAString &amp;aPassword) {</span>
<a href="#l18.2626"></a><span id="l18.2626" class="difflineplus">+  if (m_password.IsEmpty()) {</span>
<a href="#l18.2627"></a><span id="l18.2627">     // We're now going to need to do something that will end up with us either</span>
<a href="#l18.2628"></a><span id="l18.2628">     // poking login manager or prompting the user. We need to ensure we only</span>
<a href="#l18.2629"></a><span id="l18.2629">     // do one prompt at a time (and login manager could cause a master password</span>
<a href="#l18.2630"></a><span id="l18.2630">     // prompt), so we need to use the async prompter.</span>
<a href="#l18.2631"></a><span id="l18.2631">     nsresult rv;</span>
<a href="#l18.2632"></a><span id="l18.2632">     nsCOMPtr&lt;nsIMsgAsyncPrompter&gt; asyncPrompter =</span>
<a href="#l18.2633"></a><span id="l18.2633" class="difflineminus">-      do_GetService(NS_MSGASYNCPROMPTER_CONTRACTID, &amp;rv);</span>
<a href="#l18.2634"></a><span id="l18.2634" class="difflineplus">+        do_GetService(NS_MSGASYNCPROMPTER_CONTRACTID, &amp;rv);</span>
<a href="#l18.2635"></a><span id="l18.2635">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2636"></a><span id="l18.2636" class="difflineminus">-    nsCOMPtr&lt;nsIMsgAsyncPromptListener&gt; promptListener(do_QueryInterface(aProtocol));</span>
<a href="#l18.2637"></a><span id="l18.2637" class="difflineplus">+    nsCOMPtr&lt;nsIMsgAsyncPromptListener&gt; promptListener(</span>
<a href="#l18.2638"></a><span id="l18.2638" class="difflineplus">+        do_QueryInterface(aProtocol));</span>
<a href="#l18.2639"></a><span id="l18.2639">     rv = asyncPrompter-&gt;QueueAsyncAuthPrompt(m_serverKey, aNewPasswordRequested,</span>
<a href="#l18.2640"></a><span id="l18.2640">                                              promptListener);</span>
<a href="#l18.2641"></a><span id="l18.2641">     // Explicit NS_ENSURE_SUCCESS for debug purposes as errors tend to get</span>
<a href="#l18.2642"></a><span id="l18.2642">     // hidden.</span>
<a href="#l18.2643"></a><span id="l18.2643">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2644"></a><span id="l18.2644">   }</span>
<a href="#l18.2645"></a><span id="l18.2645" class="difflineminus">-  if (!m_password.IsEmpty())</span>
<a href="#l18.2646"></a><span id="l18.2646" class="difflineminus">-    aPassword = m_password;</span>
<a href="#l18.2647"></a><span id="l18.2647" class="difflineplus">+  if (!m_password.IsEmpty()) aPassword = m_password;</span>
<a href="#l18.2648"></a><span id="l18.2648">   return NS_OK;</span>
<a href="#l18.2649"></a><span id="l18.2649"> }</span>
<a href="#l18.2650"></a><span id="l18.2650"> </span>
<a href="#l18.2651"></a><span id="l18.2651"> NS_IMETHODIMP</span>
<a href="#l18.2652"></a><span id="l18.2652"> nsImapIncomingServer::PromptPassword(nsIMsgWindow *aMsgWindow,</span>
<a href="#l18.2653"></a><span id="l18.2653" class="difflineminus">-                                     nsAString &amp;aPassword)</span>
<a href="#l18.2654"></a><span id="l18.2654" class="difflineminus">-{</span>
<a href="#l18.2655"></a><span id="l18.2655" class="difflineplus">+                                     nsAString &amp;aPassword) {</span>
<a href="#l18.2656"></a><span id="l18.2656">   nsString passwordTitle;</span>
<a href="#l18.2657"></a><span id="l18.2657">   GetImapStringByName(&quot;imapEnterPasswordPromptTitle&quot;, passwordTitle);</span>
<a href="#l18.2658"></a><span id="l18.2658">   NS_ENSURE_STATE(m_stringBundle);</span>
<a href="#l18.2659"></a><span id="l18.2659"> </span>
<a href="#l18.2660"></a><span id="l18.2660">   nsAutoCString userName;</span>
<a href="#l18.2661"></a><span id="l18.2661">   GetRealUsername(userName);</span>
<a href="#l18.2662"></a><span id="l18.2662"> </span>
<a href="#l18.2663"></a><span id="l18.2663">   nsAutoCString hostName;</span>
<a href="#l18.2664"></a><span id="l18.2664">   GetRealHostName(hostName);</span>
<a href="#l18.2665"></a><span id="l18.2665"> </span>
<a href="#l18.2666"></a><span id="l18.2666">   nsresult rv = GetStringBundle();</span>
<a href="#l18.2667"></a><span id="l18.2667">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2668"></a><span id="l18.2668"> </span>
<a href="#l18.2669"></a><span id="l18.2669">   NS_ConvertASCIItoUTF16 finalUserName(userName);</span>
<a href="#l18.2670"></a><span id="l18.2670">   NS_ConvertASCIItoUTF16 finalHostName(hostName);</span>
<a href="#l18.2671"></a><span id="l18.2671"> </span>
<a href="#l18.2672"></a><span id="l18.2672" class="difflineminus">-  const char16_t *formatStrings[] = { finalUserName.get(), finalHostName.get() };</span>
<a href="#l18.2673"></a><span id="l18.2673" class="difflineplus">+  const char16_t *formatStrings[] = {finalUserName.get(), finalHostName.get()};</span>
<a href="#l18.2674"></a><span id="l18.2674"> </span>
<a href="#l18.2675"></a><span id="l18.2675">   nsString passwordText;</span>
<a href="#l18.2676"></a><span id="l18.2676" class="difflineminus">-  rv = m_stringBundle-&gt;FormatStringFromName(</span>
<a href="#l18.2677"></a><span id="l18.2677" class="difflineminus">-    &quot;imapEnterServerPasswordPrompt&quot;,</span>
<a href="#l18.2678"></a><span id="l18.2678" class="difflineminus">-    formatStrings, 2, passwordText);</span>
<a href="#l18.2679"></a><span id="l18.2679" class="difflineplus">+  rv = m_stringBundle-&gt;FormatStringFromName(&quot;imapEnterServerPasswordPrompt&quot;,</span>
<a href="#l18.2680"></a><span id="l18.2680" class="difflineplus">+                                            formatStrings, 2, passwordText);</span>
<a href="#l18.2681"></a><span id="l18.2681">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2682"></a><span id="l18.2682"> </span>
<a href="#l18.2683"></a><span id="l18.2683">   rv = GetPasswordWithUI(passwordText, passwordTitle, aMsgWindow, aPassword);</span>
<a href="#l18.2684"></a><span id="l18.2684" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l18.2685"></a><span id="l18.2685" class="difflineminus">-    m_password = aPassword;</span>
<a href="#l18.2686"></a><span id="l18.2686" class="difflineplus">+  if (NS_SUCCEEDED(rv)) m_password = aPassword;</span>
<a href="#l18.2687"></a><span id="l18.2687">   return rv;</span>
<a href="#l18.2688"></a><span id="l18.2688"> }</span>
<a href="#l18.2689"></a><span id="l18.2689"> </span>
<a href="#l18.2690"></a><span id="l18.2690"> // for the nsIImapServerSink interface</span>
<a href="#l18.2691"></a><span id="l18.2691" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::SetCapability(eIMAPCapabilityFlags capability)</span>
<a href="#l18.2692"></a><span id="l18.2692" class="difflineminus">-{</span>
<a href="#l18.2693"></a><span id="l18.2693" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::SetCapability(</span>
<a href="#l18.2694"></a><span id="l18.2694" class="difflineplus">+    eIMAPCapabilityFlags capability) {</span>
<a href="#l18.2695"></a><span id="l18.2695">   m_capability = capability;</span>
<a href="#l18.2696"></a><span id="l18.2696">   SetIsGMailServer((capability &amp; kGmailImapCapability) != 0);</span>
<a href="#l18.2697"></a><span id="l18.2697">   SetCapabilityACL(capability &amp; kACLCapability);</span>
<a href="#l18.2698"></a><span id="l18.2698">   SetCapabilityQuota(capability &amp; kQuotaCapability);</span>
<a href="#l18.2699"></a><span id="l18.2699">   return NS_OK;</span>
<a href="#l18.2700"></a><span id="l18.2700"> }</span>
<a href="#l18.2701"></a><span id="l18.2701"> </span>
<a href="#l18.2702"></a><span id="l18.2702" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::SetServerID(const nsACString &amp;aServerID)</span>
<a href="#l18.2703"></a><span id="l18.2703" class="difflineminus">-{</span>
<a href="#l18.2704"></a><span id="l18.2704" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::SetServerID(const nsACString &amp;aServerID) {</span>
<a href="#l18.2705"></a><span id="l18.2705">   return SetServerIDPref(aServerID);</span>
<a href="#l18.2706"></a><span id="l18.2706"> }</span>
<a href="#l18.2707"></a><span id="l18.2707"> </span>
<a href="#l18.2708"></a><span id="l18.2708" class="difflineminus">-NS_IMETHODIMP  nsImapIncomingServer::CommitNamespaces()</span>
<a href="#l18.2709"></a><span id="l18.2709" class="difflineminus">-{</span>
<a href="#l18.2710"></a><span id="l18.2710" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::CommitNamespaces() {</span>
<a href="#l18.2711"></a><span id="l18.2711">   nsresult rv;</span>
<a href="#l18.2712"></a><span id="l18.2712" class="difflineminus">-  nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession = do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.2713"></a><span id="l18.2713" class="difflineplus">+  nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession =</span>
<a href="#l18.2714"></a><span id="l18.2714" class="difflineplus">+      do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.2715"></a><span id="l18.2715">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2716"></a><span id="l18.2716">   return hostSession-&gt;CommitNamespacesForHost(this);</span>
<a href="#l18.2717"></a><span id="l18.2717"> }</span>
<a href="#l18.2718"></a><span id="l18.2718"> </span>
<a href="#l18.2719"></a><span id="l18.2719" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::PseudoInterruptMsgLoad(nsIMsgFolder *aImapFolder, nsIMsgWindow *aMsgWindow,</span>
<a href="#l18.2720"></a><span id="l18.2720" class="difflineminus">-                                                          bool *interrupted)</span>
<a href="#l18.2721"></a><span id="l18.2721" class="difflineminus">-{</span>
<a href="#l18.2722"></a><span id="l18.2722" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::PseudoInterruptMsgLoad(</span>
<a href="#l18.2723"></a><span id="l18.2723" class="difflineplus">+    nsIMsgFolder *aImapFolder, nsIMsgWindow *aMsgWindow, bool *interrupted) {</span>
<a href="#l18.2724"></a><span id="l18.2724">   nsresult rv = NS_OK;</span>
<a href="#l18.2725"></a><span id="l18.2725">   nsCOMPtr&lt;nsIImapProtocol&gt; connection;</span>
<a href="#l18.2726"></a><span id="l18.2726">   PR_CEnterMonitor(this);</span>
<a href="#l18.2727"></a><span id="l18.2727">   // iterate through the connection cache for a connection that is loading</span>
<a href="#l18.2728"></a><span id="l18.2728">   // a message in this folder and should be pseudo-interrupted.</span>
<a href="#l18.2729"></a><span id="l18.2729">   int32_t cnt = m_connectionCache.Count();</span>
<a href="#l18.2730"></a><span id="l18.2730"> </span>
<a href="#l18.2731"></a><span id="l18.2731" class="difflineminus">-  for (int32_t i = 0; i &lt; cnt; ++i)</span>
<a href="#l18.2732"></a><span id="l18.2732" class="difflineminus">-  {</span>
<a href="#l18.2733"></a><span id="l18.2733" class="difflineplus">+  for (int32_t i = 0; i &lt; cnt; ++i) {</span>
<a href="#l18.2734"></a><span id="l18.2734">     connection = m_connectionCache[i];</span>
<a href="#l18.2735"></a><span id="l18.2735">     if (connection)</span>
<a href="#l18.2736"></a><span id="l18.2736" class="difflineminus">-      rv = connection-&gt;PseudoInterruptMsgLoad(aImapFolder, aMsgWindow, interrupted);</span>
<a href="#l18.2737"></a><span id="l18.2737" class="difflineplus">+      rv = connection-&gt;PseudoInterruptMsgLoad(aImapFolder, aMsgWindow,</span>
<a href="#l18.2738"></a><span id="l18.2738" class="difflineplus">+                                              interrupted);</span>
<a href="#l18.2739"></a><span id="l18.2739">   }</span>
<a href="#l18.2740"></a><span id="l18.2740"> </span>
<a href="#l18.2741"></a><span id="l18.2741">   PR_CExitMonitor(this);</span>
<a href="#l18.2742"></a><span id="l18.2742">   return rv;</span>
<a href="#l18.2743"></a><span id="l18.2743"> }</span>
<a href="#l18.2744"></a><span id="l18.2744"> </span>
<a href="#l18.2745"></a><span id="l18.2745" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::ResetNamespaceReferences()</span>
<a href="#l18.2746"></a><span id="l18.2746" class="difflineminus">-{</span>
<a href="#l18.2747"></a><span id="l18.2747" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.2748"></a><span id="l18.2748" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::ResetNamespaceReferences() {</span>
<a href="#l18.2749"></a><span id="l18.2749" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l18.2750"></a><span id="l18.2750">   nsresult rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l18.2751"></a><span id="l18.2751" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder)</span>
<a href="#l18.2752"></a><span id="l18.2752" class="difflineminus">-  {</span>
<a href="#l18.2753"></a><span id="l18.2753" class="difflineminus">-    nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(rootFolder);</span>
<a href="#l18.2754"></a><span id="l18.2754" class="difflineminus">-    if (imapFolder)</span>
<a href="#l18.2755"></a><span id="l18.2755" class="difflineminus">-      rv = imapFolder-&gt;ResetNamespaceReferences();</span>
<a href="#l18.2756"></a><span id="l18.2756" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder) {</span>
<a href="#l18.2757"></a><span id="l18.2757" class="difflineplus">+    nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(rootFolder);</span>
<a href="#l18.2758"></a><span id="l18.2758" class="difflineplus">+    if (imapFolder) rv = imapFolder-&gt;ResetNamespaceReferences();</span>
<a href="#l18.2759"></a><span id="l18.2759">   }</span>
<a href="#l18.2760"></a><span id="l18.2760">   return rv;</span>
<a href="#l18.2761"></a><span id="l18.2761"> }</span>
<a href="#l18.2762"></a><span id="l18.2762"> </span>
<a href="#l18.2763"></a><span id="l18.2763" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::SetUserAuthenticated(bool aUserAuthenticated)</span>
<a href="#l18.2764"></a><span id="l18.2764" class="difflineminus">-{</span>
<a href="#l18.2765"></a><span id="l18.2765" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::SetUserAuthenticated(</span>
<a href="#l18.2766"></a><span id="l18.2766" class="difflineplus">+    bool aUserAuthenticated) {</span>
<a href="#l18.2767"></a><span id="l18.2767">   m_userAuthenticated = aUserAuthenticated;</span>
<a href="#l18.2768"></a><span id="l18.2768" class="difflineminus">-  if (aUserAuthenticated)</span>
<a href="#l18.2769"></a><span id="l18.2769" class="difflineminus">-  {</span>
<a href="#l18.2770"></a><span id="l18.2770" class="difflineplus">+  if (aUserAuthenticated) {</span>
<a href="#l18.2771"></a><span id="l18.2771">     nsresult rv;</span>
<a href="#l18.2772"></a><span id="l18.2772">     nsCOMPtr&lt;nsIMsgAccountManager&gt; accountManager =</span>
<a href="#l18.2773"></a><span id="l18.2773" class="difflineminus">-      do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l18.2774"></a><span id="l18.2774" class="difflineplus">+        do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l18.2775"></a><span id="l18.2775">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2776"></a><span id="l18.2776"> </span>
<a href="#l18.2777"></a><span id="l18.2777">     accountManager-&gt;SetUserNeedsToAuthenticate(false);</span>
<a href="#l18.2778"></a><span id="l18.2778">   }</span>
<a href="#l18.2779"></a><span id="l18.2779">   return NS_OK;</span>
<a href="#l18.2780"></a><span id="l18.2780"> }</span>
<a href="#l18.2781"></a><span id="l18.2781"> </span>
<a href="#l18.2782"></a><span id="l18.2782" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::GetUserAuthenticated(bool *aUserAuthenticated)</span>
<a href="#l18.2783"></a><span id="l18.2783" class="difflineminus">-{</span>
<a href="#l18.2784"></a><span id="l18.2784" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::GetUserAuthenticated(</span>
<a href="#l18.2785"></a><span id="l18.2785" class="difflineplus">+    bool *aUserAuthenticated) {</span>
<a href="#l18.2786"></a><span id="l18.2786">   NS_ENSURE_ARG_POINTER(aUserAuthenticated);</span>
<a href="#l18.2787"></a><span id="l18.2787">   *aUserAuthenticated = m_userAuthenticated;</span>
<a href="#l18.2788"></a><span id="l18.2788">   return NS_OK;</span>
<a href="#l18.2789"></a><span id="l18.2789"> }</span>
<a href="#l18.2790"></a><span id="l18.2790"> </span>
<a href="#l18.2791"></a><span id="l18.2791" class="difflineminus">-/* void SetMailServerUrls (in string manageMailAccount, in string manageLists, in string manageFilters); */</span>
<a href="#l18.2792"></a><span id="l18.2792" class="difflineminus">-NS_IMETHODIMP  nsImapIncomingServer::SetMailServerUrls(const nsACString&amp; manageMailAccount, const nsACString&amp; manageLists,</span>
<a href="#l18.2793"></a><span id="l18.2793" class="difflineminus">-                                                       const nsACString&amp; manageFilters)</span>
<a href="#l18.2794"></a><span id="l18.2794" class="difflineminus">-{</span>
<a href="#l18.2795"></a><span id="l18.2795" class="difflineplus">+/* void SetMailServerUrls (in string manageMailAccount, in string manageLists,</span>
<a href="#l18.2796"></a><span id="l18.2796" class="difflineplus">+ * in string manageFilters); */</span>
<a href="#l18.2797"></a><span id="l18.2797" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::SetMailServerUrls(</span>
<a href="#l18.2798"></a><span id="l18.2798" class="difflineplus">+    const nsACString &amp;manageMailAccount, const nsACString &amp;manageLists,</span>
<a href="#l18.2799"></a><span id="l18.2799" class="difflineplus">+    const nsACString &amp;manageFilters) {</span>
<a href="#l18.2800"></a><span id="l18.2800">   return SetManageMailAccountUrl(manageMailAccount);</span>
<a href="#l18.2801"></a><span id="l18.2801"> }</span>
<a href="#l18.2802"></a><span id="l18.2802"> </span>
<a href="#l18.2803"></a><span id="l18.2803" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::SetManageMailAccountUrl(const nsACString&amp; manageMailAccountUrl)</span>
<a href="#l18.2804"></a><span id="l18.2804" class="difflineminus">-{</span>
<a href="#l18.2805"></a><span id="l18.2805" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::SetManageMailAccountUrl(</span>
<a href="#l18.2806"></a><span id="l18.2806" class="difflineplus">+    const nsACString &amp;manageMailAccountUrl) {</span>
<a href="#l18.2807"></a><span id="l18.2807">   m_manageMailAccountUrl = manageMailAccountUrl;</span>
<a href="#l18.2808"></a><span id="l18.2808">   return NS_OK;</span>
<a href="#l18.2809"></a><span id="l18.2809"> }</span>
<a href="#l18.2810"></a><span id="l18.2810"> </span>
<a href="#l18.2811"></a><span id="l18.2811" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::GetManageMailAccountUrl(nsACString&amp; manageMailAccountUrl)</span>
<a href="#l18.2812"></a><span id="l18.2812" class="difflineminus">-{</span>
<a href="#l18.2813"></a><span id="l18.2813" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::GetManageMailAccountUrl(</span>
<a href="#l18.2814"></a><span id="l18.2814" class="difflineplus">+    nsACString &amp;manageMailAccountUrl) {</span>
<a href="#l18.2815"></a><span id="l18.2815">   manageMailAccountUrl = m_manageMailAccountUrl;</span>
<a href="#l18.2816"></a><span id="l18.2816">   return NS_OK;</span>
<a href="#l18.2817"></a><span id="l18.2817"> }</span>
<a href="#l18.2818"></a><span id="l18.2818"> </span>
<a href="#l18.2819"></a><span id="l18.2819"> NS_IMETHODIMP</span>
<a href="#l18.2820"></a><span id="l18.2820" class="difflineminus">-nsImapIncomingServer::StartPopulatingWithUri(nsIMsgWindow *aMsgWindow, bool aForceToServer /*ignored*/, const char *uri)</span>
<a href="#l18.2821"></a><span id="l18.2821" class="difflineminus">-{</span>
<a href="#l18.2822"></a><span id="l18.2822" class="difflineminus">-  NS_ENSURE_ARG_POINTER (uri);</span>
<a href="#l18.2823"></a><span id="l18.2823" class="difflineplus">+nsImapIncomingServer::StartPopulatingWithUri(nsIMsgWindow *aMsgWindow,</span>
<a href="#l18.2824"></a><span id="l18.2824" class="difflineplus">+                                             bool aForceToServer /*ignored*/,</span>
<a href="#l18.2825"></a><span id="l18.2825" class="difflineplus">+                                             const char *uri) {</span>
<a href="#l18.2826"></a><span id="l18.2826" class="difflineplus">+  NS_ENSURE_ARG_POINTER(uri);</span>
<a href="#l18.2827"></a><span id="l18.2827"> </span>
<a href="#l18.2828"></a><span id="l18.2828">   nsresult rv;</span>
<a href="#l18.2829"></a><span id="l18.2829">   mDoingSubscribeDialog = true;</span>
<a href="#l18.2830"></a><span id="l18.2830"> </span>
<a href="#l18.2831"></a><span id="l18.2831">   rv = EnsureInner();</span>
<a href="#l18.2832"></a><span id="l18.2832" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.2833"></a><span id="l18.2833" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2834"></a><span id="l18.2834">   rv = mInner-&gt;StartPopulatingWithUri(aMsgWindow, aForceToServer, uri);</span>
<a href="#l18.2835"></a><span id="l18.2835" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.2836"></a><span id="l18.2836" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2837"></a><span id="l18.2837"> </span>
<a href="#l18.2838"></a><span id="l18.2838">   // imap always uses the canonical delimiter form of paths for subscribe ui.</span>
<a href="#l18.2839"></a><span id="l18.2839">   rv = SetDelimiter('/');</span>
<a href="#l18.2840"></a><span id="l18.2840" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.2841"></a><span id="l18.2841" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2842"></a><span id="l18.2842"> </span>
<a href="#l18.2843"></a><span id="l18.2843">   rv = SetShowFullName(false);</span>
<a href="#l18.2844"></a><span id="l18.2844" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.2845"></a><span id="l18.2845" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2846"></a><span id="l18.2846"> </span>
<a href="#l18.2847"></a><span id="l18.2847">   nsCString serverUri;</span>
<a href="#l18.2848"></a><span id="l18.2848">   rv = GetServerURI(serverUri);</span>
<a href="#l18.2849"></a><span id="l18.2849" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.2850"></a><span id="l18.2850" class="difflineminus">-</span>
<a href="#l18.2851"></a><span id="l18.2851" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.2852"></a><span id="l18.2852" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.2853"></a><span id="l18.2853" class="difflineminus">-</span>
<a href="#l18.2854"></a><span id="l18.2854" class="difflineminus">-/*</span>
<a href="#l18.2855"></a><span id="l18.2855" class="difflineminus">-    if uri = imap://user@host/foo/bar, the serverUri is imap://user@host</span>
<a href="#l18.2856"></a><span id="l18.2856" class="difflineminus">-    to get path from uri, skip over imap://user@host + 1 (for the /)</span>
<a href="#l18.2857"></a><span id="l18.2857" class="difflineminus">-*/</span>
<a href="#l18.2858"></a><span id="l18.2858" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2859"></a><span id="l18.2859" class="difflineplus">+</span>
<a href="#l18.2860"></a><span id="l18.2860" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l18.2861"></a><span id="l18.2861" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.2862"></a><span id="l18.2862" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2863"></a><span id="l18.2863" class="difflineplus">+</span>
<a href="#l18.2864"></a><span id="l18.2864" class="difflineplus">+  /*</span>
<a href="#l18.2865"></a><span id="l18.2865" class="difflineplus">+      if uri = imap://user@host/foo/bar, the serverUri is imap://user@host</span>
<a href="#l18.2866"></a><span id="l18.2866" class="difflineplus">+      to get path from uri, skip over imap://user@host + 1 (for the /)</span>
<a href="#l18.2867"></a><span id="l18.2867" class="difflineplus">+  */</span>
<a href="#l18.2868"></a><span id="l18.2868">   const char *path = uri + serverUri.Length() + 1;</span>
<a href="#l18.2869"></a><span id="l18.2869" class="difflineminus">-  return imapService-&gt;GetListOfFoldersWithPath(this, aMsgWindow, nsDependentCString(path));</span>
<a href="#l18.2870"></a><span id="l18.2870" class="difflineplus">+  return imapService-&gt;GetListOfFoldersWithPath(this, aMsgWindow,</span>
<a href="#l18.2871"></a><span id="l18.2871" class="difflineplus">+                                               nsDependentCString(path));</span>
<a href="#l18.2872"></a><span id="l18.2872"> }</span>
<a href="#l18.2873"></a><span id="l18.2873"> </span>
<a href="#l18.2874"></a><span id="l18.2874"> NS_IMETHODIMP</span>
<a href="#l18.2875"></a><span id="l18.2875" class="difflineminus">-nsImapIncomingServer::StartPopulating(nsIMsgWindow *aMsgWindow, bool aForceToServer /*ignored*/, bool aGetOnlyNew)</span>
<a href="#l18.2876"></a><span id="l18.2876" class="difflineminus">-{</span>
<a href="#l18.2877"></a><span id="l18.2877" class="difflineplus">+nsImapIncomingServer::StartPopulating(nsIMsgWindow *aMsgWindow,</span>
<a href="#l18.2878"></a><span id="l18.2878" class="difflineplus">+                                      bool aForceToServer /*ignored*/,</span>
<a href="#l18.2879"></a><span id="l18.2879" class="difflineplus">+                                      bool aGetOnlyNew) {</span>
<a href="#l18.2880"></a><span id="l18.2880">   nsresult rv;</span>
<a href="#l18.2881"></a><span id="l18.2881">   mDoingSubscribeDialog = true;</span>
<a href="#l18.2882"></a><span id="l18.2882"> </span>
<a href="#l18.2883"></a><span id="l18.2883">   rv = EnsureInner();</span>
<a href="#l18.2884"></a><span id="l18.2884" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.2885"></a><span id="l18.2885" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2886"></a><span id="l18.2886">   rv = mInner-&gt;StartPopulating(aMsgWindow, aForceToServer, aGetOnlyNew);</span>
<a href="#l18.2887"></a><span id="l18.2887" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.2888"></a><span id="l18.2888" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2889"></a><span id="l18.2889"> </span>
<a href="#l18.2890"></a><span id="l18.2890">   // imap always uses the canonical delimiter form of paths for subscribe ui.</span>
<a href="#l18.2891"></a><span id="l18.2891">   rv = SetDelimiter('/');</span>
<a href="#l18.2892"></a><span id="l18.2892" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.2893"></a><span id="l18.2893" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2894"></a><span id="l18.2894"> </span>
<a href="#l18.2895"></a><span id="l18.2895">   rv = SetShowFullName(false);</span>
<a href="#l18.2896"></a><span id="l18.2896" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.2897"></a><span id="l18.2897" class="difflineminus">-</span>
<a href="#l18.2898"></a><span id="l18.2898" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.2899"></a><span id="l18.2899" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.2900"></a><span id="l18.2900" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2901"></a><span id="l18.2901" class="difflineplus">+</span>
<a href="#l18.2902"></a><span id="l18.2902" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l18.2903"></a><span id="l18.2903" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.2904"></a><span id="l18.2904" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2905"></a><span id="l18.2905">   return imapService-&gt;GetListOfFoldersOnServer(this, aMsgWindow);</span>
<a href="#l18.2906"></a><span id="l18.2906"> }</span>
<a href="#l18.2907"></a><span id="l18.2907"> </span>
<a href="#l18.2908"></a><span id="l18.2908"> NS_IMETHODIMP</span>
<a href="#l18.2909"></a><span id="l18.2909" class="difflineminus">-nsImapIncomingServer::OnStartRunningUrl(nsIURI *url)</span>
<a href="#l18.2910"></a><span id="l18.2910" class="difflineminus">-{</span>
<a href="#l18.2911"></a><span id="l18.2911" class="difflineminus">-  return NS_OK;</span>
<a href="#l18.2912"></a><span id="l18.2912" class="difflineminus">-}</span>
<a href="#l18.2913"></a><span id="l18.2913" class="difflineplus">+nsImapIncomingServer::OnStartRunningUrl(nsIURI *url) { return NS_OK; }</span>
<a href="#l18.2914"></a><span id="l18.2914"> </span>
<a href="#l18.2915"></a><span id="l18.2915"> NS_IMETHODIMP</span>
<a href="#l18.2916"></a><span id="l18.2916" class="difflineminus">-nsImapIncomingServer::OnStopRunningUrl(nsIURI *url, nsresult exitCode)</span>
<a href="#l18.2917"></a><span id="l18.2917" class="difflineminus">-{</span>
<a href="#l18.2918"></a><span id="l18.2918" class="difflineplus">+nsImapIncomingServer::OnStopRunningUrl(nsIURI *url, nsresult exitCode) {</span>
<a href="#l18.2919"></a><span id="l18.2919">   nsresult rv = exitCode;</span>
<a href="#l18.2920"></a><span id="l18.2920"> </span>
<a href="#l18.2921"></a><span id="l18.2921">   // xxx todo get msgWindow from url</span>
<a href="#l18.2922"></a><span id="l18.2922">   nsCOMPtr&lt;nsIMsgWindow&gt; msgWindow;</span>
<a href="#l18.2923"></a><span id="l18.2923">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(url);</span>
<a href="#l18.2924"></a><span id="l18.2924">   if (imapUrl) {</span>
<a href="#l18.2925"></a><span id="l18.2925">     nsImapAction imapAction = nsIImapUrl::nsImapTest;</span>
<a href="#l18.2926"></a><span id="l18.2926">     imapUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l18.2927"></a><span id="l18.2927">     switch (imapAction) {</span>
<a href="#l18.2928"></a><span id="l18.2928" class="difflineminus">-    case nsIImapUrl::nsImapDiscoverAllAndSubscribedBoxesUrl:</span>
<a href="#l18.2929"></a><span id="l18.2929" class="difflineminus">-    case nsIImapUrl::nsImapDiscoverChildrenUrl:</span>
<a href="#l18.2930"></a><span id="l18.2930" class="difflineminus">-      rv = UpdateSubscribed();</span>
<a href="#l18.2931"></a><span id="l18.2931" class="difflineminus">-      NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2932"></a><span id="l18.2932" class="difflineminus">-      mDoingSubscribeDialog = false;</span>
<a href="#l18.2933"></a><span id="l18.2933" class="difflineminus">-      rv = StopPopulating(msgWindow);</span>
<a href="#l18.2934"></a><span id="l18.2934" class="difflineminus">-      NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2935"></a><span id="l18.2935" class="difflineminus">-      break;</span>
<a href="#l18.2936"></a><span id="l18.2936" class="difflineminus">-    case nsIImapUrl::nsImapDiscoverAllBoxesUrl:</span>
<a href="#l18.2937"></a><span id="l18.2937" class="difflineminus">-      if (NS_SUCCEEDED(exitCode))</span>
<a href="#l18.2938"></a><span id="l18.2938" class="difflineminus">-        DiscoveryDone();</span>
<a href="#l18.2939"></a><span id="l18.2939" class="difflineminus">-      break;</span>
<a href="#l18.2940"></a><span id="l18.2940" class="difflineminus">-    case nsIImapUrl::nsImapFolderStatus:</span>
<a href="#l18.2941"></a><span id="l18.2941" class="difflineminus">-    {</span>
<a href="#l18.2942"></a><span id="l18.2942" class="difflineminus">-      nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l18.2943"></a><span id="l18.2943" class="difflineminus">-      nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailUrl = do_QueryInterface(imapUrl);</span>
<a href="#l18.2944"></a><span id="l18.2944" class="difflineminus">-      mailUrl-&gt;GetFolder(getter_AddRefs(msgFolder));</span>
<a href="#l18.2945"></a><span id="l18.2945" class="difflineminus">-      if (msgFolder)</span>
<a href="#l18.2946"></a><span id="l18.2946" class="difflineminus">-      {</span>
<a href="#l18.2947"></a><span id="l18.2947" class="difflineminus">-        nsresult rv;</span>
<a href="#l18.2948"></a><span id="l18.2948" class="difflineminus">-        nsCOMPtr&lt;nsIMsgMailSession&gt; session =</span>
<a href="#l18.2949"></a><span id="l18.2949" class="difflineminus">-                 do_GetService(NS_MSGMAILSESSION_CONTRACTID, &amp;rv);</span>
<a href="#l18.2950"></a><span id="l18.2950" class="difflineplus">+      case nsIImapUrl::nsImapDiscoverAllAndSubscribedBoxesUrl:</span>
<a href="#l18.2951"></a><span id="l18.2951" class="difflineplus">+      case nsIImapUrl::nsImapDiscoverChildrenUrl:</span>
<a href="#l18.2952"></a><span id="l18.2952" class="difflineplus">+        rv = UpdateSubscribed();</span>
<a href="#l18.2953"></a><span id="l18.2953" class="difflineplus">+        NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2954"></a><span id="l18.2954" class="difflineplus">+        mDoingSubscribeDialog = false;</span>
<a href="#l18.2955"></a><span id="l18.2955" class="difflineplus">+        rv = StopPopulating(msgWindow);</span>
<a href="#l18.2956"></a><span id="l18.2956">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2957"></a><span id="l18.2957" class="difflineminus">-        bool folderOpen;</span>
<a href="#l18.2958"></a><span id="l18.2958" class="difflineminus">-        rv = session-&gt;IsFolderOpenInWindow(msgFolder, &amp;folderOpen);</span>
<a href="#l18.2959"></a><span id="l18.2959" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; !folderOpen &amp;&amp; msgFolder)</span>
<a href="#l18.2960"></a><span id="l18.2960" class="difflineminus">-          msgFolder-&gt;SetMsgDatabase(nullptr);</span>
<a href="#l18.2961"></a><span id="l18.2961" class="difflineminus">-        nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(msgFolder);</span>
<a href="#l18.2962"></a><span id="l18.2962" class="difflineminus">-        m_foldersToStat.RemoveObject(imapFolder);</span>
<a href="#l18.2963"></a><span id="l18.2963" class="difflineplus">+        break;</span>
<a href="#l18.2964"></a><span id="l18.2964" class="difflineplus">+      case nsIImapUrl::nsImapDiscoverAllBoxesUrl:</span>
<a href="#l18.2965"></a><span id="l18.2965" class="difflineplus">+        if (NS_SUCCEEDED(exitCode)) DiscoveryDone();</span>
<a href="#l18.2966"></a><span id="l18.2966" class="difflineplus">+        break;</span>
<a href="#l18.2967"></a><span id="l18.2967" class="difflineplus">+      case nsIImapUrl::nsImapFolderStatus: {</span>
<a href="#l18.2968"></a><span id="l18.2968" class="difflineplus">+        nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l18.2969"></a><span id="l18.2969" class="difflineplus">+        nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailUrl = do_QueryInterface(imapUrl);</span>
<a href="#l18.2970"></a><span id="l18.2970" class="difflineplus">+        mailUrl-&gt;GetFolder(getter_AddRefs(msgFolder));</span>
<a href="#l18.2971"></a><span id="l18.2971" class="difflineplus">+        if (msgFolder) {</span>
<a href="#l18.2972"></a><span id="l18.2972" class="difflineplus">+          nsresult rv;</span>
<a href="#l18.2973"></a><span id="l18.2973" class="difflineplus">+          nsCOMPtr&lt;nsIMsgMailSession&gt; session =</span>
<a href="#l18.2974"></a><span id="l18.2974" class="difflineplus">+              do_GetService(NS_MSGMAILSESSION_CONTRACTID, &amp;rv);</span>
<a href="#l18.2975"></a><span id="l18.2975" class="difflineplus">+          NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.2976"></a><span id="l18.2976" class="difflineplus">+          bool folderOpen;</span>
<a href="#l18.2977"></a><span id="l18.2977" class="difflineplus">+          rv = session-&gt;IsFolderOpenInWindow(msgFolder, &amp;folderOpen);</span>
<a href="#l18.2978"></a><span id="l18.2978" class="difflineplus">+          if (NS_SUCCEEDED(rv) &amp;&amp; !folderOpen &amp;&amp; msgFolder)</span>
<a href="#l18.2979"></a><span id="l18.2979" class="difflineplus">+            msgFolder-&gt;SetMsgDatabase(nullptr);</span>
<a href="#l18.2980"></a><span id="l18.2980" class="difflineplus">+          nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder =</span>
<a href="#l18.2981"></a><span id="l18.2981" class="difflineplus">+              do_QueryInterface(msgFolder);</span>
<a href="#l18.2982"></a><span id="l18.2982" class="difflineplus">+          m_foldersToStat.RemoveObject(imapFolder);</span>
<a href="#l18.2983"></a><span id="l18.2983" class="difflineplus">+        }</span>
<a href="#l18.2984"></a><span id="l18.2984" class="difflineplus">+        // if we get an error running the url, it's better</span>
<a href="#l18.2985"></a><span id="l18.2985" class="difflineplus">+        // not to chain the next url.</span>
<a href="#l18.2986"></a><span id="l18.2986" class="difflineplus">+        if (NS_FAILED(exitCode) &amp;&amp; exitCode != NS_MSG_ERROR_IMAP_COMMAND_FAILED)</span>
<a href="#l18.2987"></a><span id="l18.2987" class="difflineplus">+          m_foldersToStat.Clear();</span>
<a href="#l18.2988"></a><span id="l18.2988" class="difflineplus">+        if (m_foldersToStat.Count() &gt; 0)</span>
<a href="#l18.2989"></a><span id="l18.2989" class="difflineplus">+          m_foldersToStat[0]-&gt;UpdateStatus(this, nullptr);</span>
<a href="#l18.2990"></a><span id="l18.2990" class="difflineplus">+        break;</span>
<a href="#l18.2991"></a><span id="l18.2991">       }</span>
<a href="#l18.2992"></a><span id="l18.2992" class="difflineminus">-      // if we get an error running the url, it's better</span>
<a href="#l18.2993"></a><span id="l18.2993" class="difflineminus">-      // not to chain the next url.</span>
<a href="#l18.2994"></a><span id="l18.2994" class="difflineminus">-      if (NS_FAILED(exitCode) &amp;&amp; exitCode != NS_MSG_ERROR_IMAP_COMMAND_FAILED)</span>
<a href="#l18.2995"></a><span id="l18.2995" class="difflineminus">-        m_foldersToStat.Clear();</span>
<a href="#l18.2996"></a><span id="l18.2996" class="difflineminus">-      if (m_foldersToStat.Count() &gt; 0)</span>
<a href="#l18.2997"></a><span id="l18.2997" class="difflineminus">-        m_foldersToStat[0]-&gt;UpdateStatus(this, nullptr);</span>
<a href="#l18.2998"></a><span id="l18.2998" class="difflineminus">-      break;</span>
<a href="#l18.2999"></a><span id="l18.2999" class="difflineminus">-    }</span>
<a href="#l18.3000"></a><span id="l18.3000" class="difflineminus">-    default:</span>
<a href="#l18.3001"></a><span id="l18.3001" class="difflineplus">+      default:</span>
<a href="#l18.3002"></a><span id="l18.3002">         break;</span>
<a href="#l18.3003"></a><span id="l18.3003">     }</span>
<a href="#l18.3004"></a><span id="l18.3004">   }</span>
<a href="#l18.3005"></a><span id="l18.3005">   return NS_OK;</span>
<a href="#l18.3006"></a><span id="l18.3006"> }</span>
<a href="#l18.3007"></a><span id="l18.3007"> </span>
<a href="#l18.3008"></a><span id="l18.3008"> NS_IMETHODIMP</span>
<a href="#l18.3009"></a><span id="l18.3009" class="difflineminus">-nsImapIncomingServer::SetIncomingServer(nsIMsgIncomingServer *aServer)</span>
<a href="#l18.3010"></a><span id="l18.3010" class="difflineminus">-{</span>
<a href="#l18.3011"></a><span id="l18.3011" class="difflineplus">+nsImapIncomingServer::SetIncomingServer(nsIMsgIncomingServer *aServer) {</span>
<a href="#l18.3012"></a><span id="l18.3012">   nsresult rv = EnsureInner();</span>
<a href="#l18.3013"></a><span id="l18.3013" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3014"></a><span id="l18.3014" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3015"></a><span id="l18.3015">   return mInner-&gt;SetIncomingServer(aServer);</span>
<a href="#l18.3016"></a><span id="l18.3016"> }</span>
<a href="#l18.3017"></a><span id="l18.3017"> </span>
<a href="#l18.3018"></a><span id="l18.3018"> NS_IMETHODIMP</span>
<a href="#l18.3019"></a><span id="l18.3019" class="difflineminus">-nsImapIncomingServer::SetShowFullName(bool showFullName)</span>
<a href="#l18.3020"></a><span id="l18.3020" class="difflineminus">-{</span>
<a href="#l18.3021"></a><span id="l18.3021" class="difflineplus">+nsImapIncomingServer::SetShowFullName(bool showFullName) {</span>
<a href="#l18.3022"></a><span id="l18.3022">   nsresult rv = EnsureInner();</span>
<a href="#l18.3023"></a><span id="l18.3023" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3024"></a><span id="l18.3024" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3025"></a><span id="l18.3025">   return mInner-&gt;SetShowFullName(showFullName);</span>
<a href="#l18.3026"></a><span id="l18.3026"> }</span>
<a href="#l18.3027"></a><span id="l18.3027"> </span>
<a href="#l18.3028"></a><span id="l18.3028"> NS_IMETHODIMP</span>
<a href="#l18.3029"></a><span id="l18.3029" class="difflineminus">-nsImapIncomingServer::GetDelimiter(char *aDelimiter)</span>
<a href="#l18.3030"></a><span id="l18.3030" class="difflineminus">-{</span>
<a href="#l18.3031"></a><span id="l18.3031" class="difflineplus">+nsImapIncomingServer::GetDelimiter(char *aDelimiter) {</span>
<a href="#l18.3032"></a><span id="l18.3032">   nsresult rv = EnsureInner();</span>
<a href="#l18.3033"></a><span id="l18.3033" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3034"></a><span id="l18.3034" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3035"></a><span id="l18.3035">   return mInner-&gt;GetDelimiter(aDelimiter);</span>
<a href="#l18.3036"></a><span id="l18.3036"> }</span>
<a href="#l18.3037"></a><span id="l18.3037"> </span>
<a href="#l18.3038"></a><span id="l18.3038"> NS_IMETHODIMP</span>
<a href="#l18.3039"></a><span id="l18.3039" class="difflineminus">-nsImapIncomingServer::SetDelimiter(char aDelimiter)</span>
<a href="#l18.3040"></a><span id="l18.3040" class="difflineminus">-{</span>
<a href="#l18.3041"></a><span id="l18.3041" class="difflineplus">+nsImapIncomingServer::SetDelimiter(char aDelimiter) {</span>
<a href="#l18.3042"></a><span id="l18.3042">   nsresult rv = EnsureInner();</span>
<a href="#l18.3043"></a><span id="l18.3043" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3044"></a><span id="l18.3044" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3045"></a><span id="l18.3045">   return mInner-&gt;SetDelimiter(aDelimiter);</span>
<a href="#l18.3046"></a><span id="l18.3046"> }</span>
<a href="#l18.3047"></a><span id="l18.3047"> </span>
<a href="#l18.3048"></a><span id="l18.3048"> NS_IMETHODIMP</span>
<a href="#l18.3049"></a><span id="l18.3049" class="difflineminus">-nsImapIncomingServer::SetAsSubscribed(const nsACString &amp;path)</span>
<a href="#l18.3050"></a><span id="l18.3050" class="difflineminus">-{</span>
<a href="#l18.3051"></a><span id="l18.3051" class="difflineplus">+nsImapIncomingServer::SetAsSubscribed(const nsACString &amp;path) {</span>
<a href="#l18.3052"></a><span id="l18.3052">   nsresult rv = EnsureInner();</span>
<a href="#l18.3053"></a><span id="l18.3053" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3054"></a><span id="l18.3054" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3055"></a><span id="l18.3055">   return mInner-&gt;SetAsSubscribed(path);</span>
<a href="#l18.3056"></a><span id="l18.3056"> }</span>
<a href="#l18.3057"></a><span id="l18.3057"> </span>
<a href="#l18.3058"></a><span id="l18.3058"> NS_IMETHODIMP</span>
<a href="#l18.3059"></a><span id="l18.3059" class="difflineminus">-nsImapIncomingServer::UpdateSubscribed()</span>
<a href="#l18.3060"></a><span id="l18.3060" class="difflineminus">-{</span>
<a href="#l18.3061"></a><span id="l18.3061" class="difflineminus">-  return NS_OK;</span>
<a href="#l18.3062"></a><span id="l18.3062" class="difflineminus">-}</span>
<a href="#l18.3063"></a><span id="l18.3063" class="difflineplus">+nsImapIncomingServer::UpdateSubscribed() { return NS_OK; }</span>
<a href="#l18.3064"></a><span id="l18.3064"> </span>
<a href="#l18.3065"></a><span id="l18.3065"> NS_IMETHODIMP</span>
<a href="#l18.3066"></a><span id="l18.3066"> nsImapIncomingServer::AddTo(const nsACString &amp;aName, bool addAsSubscribed,</span>
<a href="#l18.3067"></a><span id="l18.3067" class="difflineminus">-                            bool aSubscribable, bool changeIfExists)</span>
<a href="#l18.3068"></a><span id="l18.3068" class="difflineminus">-{</span>
<a href="#l18.3069"></a><span id="l18.3069" class="difflineplus">+                            bool aSubscribable, bool changeIfExists) {</span>
<a href="#l18.3070"></a><span id="l18.3070">   nsresult rv = EnsureInner();</span>
<a href="#l18.3071"></a><span id="l18.3071" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3072"></a><span id="l18.3072" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3073"></a><span id="l18.3073"> </span>
<a href="#l18.3074"></a><span id="l18.3074">   // RFC 3501 allows UTF-8 in addition to modified UTF-7</span>
<a href="#l18.3075"></a><span id="l18.3075">   // If it's not UTF-8, it cannot be MUTF7, either. We just ignore it.</span>
<a href="#l18.3076"></a><span id="l18.3076">   // (otherwise we'll crash. see #63186)</span>
<a href="#l18.3077"></a><span id="l18.3077" class="difflineminus">-  if (!MsgIsUTF8(aName))</span>
<a href="#l18.3078"></a><span id="l18.3078" class="difflineminus">-    return NS_OK;</span>
<a href="#l18.3079"></a><span id="l18.3079" class="difflineplus">+  if (!MsgIsUTF8(aName)) return NS_OK;</span>
<a href="#l18.3080"></a><span id="l18.3080"> </span>
<a href="#l18.3081"></a><span id="l18.3081">   if (!NS_IsAscii(aName.BeginReading(), aName.Length())) {</span>
<a href="#l18.3082"></a><span id="l18.3082">     nsAutoCString name;</span>
<a href="#l18.3083"></a><span id="l18.3083">     CopyUTF16toMUTF7(NS_ConvertUTF8toUTF16(aName), name);</span>
<a href="#l18.3084"></a><span id="l18.3084">     return mInner-&gt;AddTo(name, addAsSubscribed, aSubscribable, changeIfExists);</span>
<a href="#l18.3085"></a><span id="l18.3085">   }</span>
<a href="#l18.3086"></a><span id="l18.3086">   return mInner-&gt;AddTo(aName, addAsSubscribed, aSubscribable, changeIfExists);</span>
<a href="#l18.3087"></a><span id="l18.3087"> }</span>
<a href="#l18.3088"></a><span id="l18.3088"> </span>
<a href="#l18.3089"></a><span id="l18.3089"> NS_IMETHODIMP</span>
<a href="#l18.3090"></a><span id="l18.3090" class="difflineminus">-nsImapIncomingServer::StopPopulating(nsIMsgWindow *aMsgWindow)</span>
<a href="#l18.3091"></a><span id="l18.3091" class="difflineminus">-{</span>
<a href="#l18.3092"></a><span id="l18.3092" class="difflineplus">+nsImapIncomingServer::StopPopulating(nsIMsgWindow *aMsgWindow) {</span>
<a href="#l18.3093"></a><span id="l18.3093">   nsresult rv = EnsureInner();</span>
<a href="#l18.3094"></a><span id="l18.3094" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3095"></a><span id="l18.3095" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3096"></a><span id="l18.3096">   return mInner-&gt;StopPopulating(aMsgWindow);</span>
<a href="#l18.3097"></a><span id="l18.3097"> }</span>
<a href="#l18.3098"></a><span id="l18.3098"> </span>
<a href="#l18.3099"></a><span id="l18.3099" class="difflineminus">-</span>
<a href="#l18.3100"></a><span id="l18.3100"> NS_IMETHODIMP</span>
<a href="#l18.3101"></a><span id="l18.3101" class="difflineminus">-nsImapIncomingServer::SubscribeCleanup()</span>
<a href="#l18.3102"></a><span id="l18.3102" class="difflineminus">-{</span>
<a href="#l18.3103"></a><span id="l18.3103" class="difflineplus">+nsImapIncomingServer::SubscribeCleanup() {</span>
<a href="#l18.3104"></a><span id="l18.3104">   m_subscribeFolders.Clear();</span>
<a href="#l18.3105"></a><span id="l18.3105">   return ClearInner();</span>
<a href="#l18.3106"></a><span id="l18.3106"> }</span>
<a href="#l18.3107"></a><span id="l18.3107"> </span>
<a href="#l18.3108"></a><span id="l18.3108"> NS_IMETHODIMP</span>
<a href="#l18.3109"></a><span id="l18.3109" class="difflineminus">-nsImapIncomingServer::SetSubscribeListener(nsISubscribeListener *aListener)</span>
<a href="#l18.3110"></a><span id="l18.3110" class="difflineminus">-{</span>
<a href="#l18.3111"></a><span id="l18.3111" class="difflineplus">+nsImapIncomingServer::SetSubscribeListener(nsISubscribeListener *aListener) {</span>
<a href="#l18.3112"></a><span id="l18.3112">   nsresult rv = EnsureInner();</span>
<a href="#l18.3113"></a><span id="l18.3113" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3114"></a><span id="l18.3114" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3115"></a><span id="l18.3115">   return mInner-&gt;SetSubscribeListener(aListener);</span>
<a href="#l18.3116"></a><span id="l18.3116"> }</span>
<a href="#l18.3117"></a><span id="l18.3117"> </span>
<a href="#l18.3118"></a><span id="l18.3118"> NS_IMETHODIMP</span>
<a href="#l18.3119"></a><span id="l18.3119" class="difflineminus">-nsImapIncomingServer::GetSubscribeListener(nsISubscribeListener **aListener)</span>
<a href="#l18.3120"></a><span id="l18.3120" class="difflineminus">-{</span>
<a href="#l18.3121"></a><span id="l18.3121" class="difflineplus">+nsImapIncomingServer::GetSubscribeListener(nsISubscribeListener **aListener) {</span>
<a href="#l18.3122"></a><span id="l18.3122">   nsresult rv = EnsureInner();</span>
<a href="#l18.3123"></a><span id="l18.3123" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3124"></a><span id="l18.3124" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3125"></a><span id="l18.3125">   return mInner-&gt;GetSubscribeListener(aListener);</span>
<a href="#l18.3126"></a><span id="l18.3126"> }</span>
<a href="#l18.3127"></a><span id="l18.3127"> </span>
<a href="#l18.3128"></a><span id="l18.3128"> NS_IMETHODIMP</span>
<a href="#l18.3129"></a><span id="l18.3129" class="difflineminus">-nsImapIncomingServer::Subscribe(const char16_t *aName)</span>
<a href="#l18.3130"></a><span id="l18.3130" class="difflineminus">-{</span>
<a href="#l18.3131"></a><span id="l18.3131" class="difflineplus">+nsImapIncomingServer::Subscribe(const char16_t *aName) {</span>
<a href="#l18.3132"></a><span id="l18.3132">   NS_ENSURE_ARG_POINTER(aName);</span>
<a href="#l18.3133"></a><span id="l18.3133"> </span>
<a href="#l18.3134"></a><span id="l18.3134">   return SubscribeToFolder(nsDependentString(aName), true, nullptr);</span>
<a href="#l18.3135"></a><span id="l18.3135"> }</span>
<a href="#l18.3136"></a><span id="l18.3136"> </span>
<a href="#l18.3137"></a><span id="l18.3137"> NS_IMETHODIMP</span>
<a href="#l18.3138"></a><span id="l18.3138" class="difflineminus">-nsImapIncomingServer::Unsubscribe(const char16_t *aName)</span>
<a href="#l18.3139"></a><span id="l18.3139" class="difflineminus">-{</span>
<a href="#l18.3140"></a><span id="l18.3140" class="difflineplus">+nsImapIncomingServer::Unsubscribe(const char16_t *aName) {</span>
<a href="#l18.3141"></a><span id="l18.3141">   NS_ENSURE_ARG_POINTER(aName);</span>
<a href="#l18.3142"></a><span id="l18.3142"> </span>
<a href="#l18.3143"></a><span id="l18.3143">   return SubscribeToFolder(nsDependentString(aName), false, nullptr);</span>
<a href="#l18.3144"></a><span id="l18.3144"> }</span>
<a href="#l18.3145"></a><span id="l18.3145"> </span>
<a href="#l18.3146"></a><span id="l18.3146"> NS_IMETHODIMP</span>
<a href="#l18.3147"></a><span id="l18.3147" class="difflineminus">-nsImapIncomingServer::SubscribeToFolder(const nsAString&amp; aName, bool subscribe, nsIURI **aUri)</span>
<a href="#l18.3148"></a><span id="l18.3148" class="difflineminus">-{</span>
<a href="#l18.3149"></a><span id="l18.3149" class="difflineplus">+nsImapIncomingServer::SubscribeToFolder(const nsAString &amp;aName, bool subscribe,</span>
<a href="#l18.3150"></a><span id="l18.3150" class="difflineplus">+                                        nsIURI **aUri) {</span>
<a href="#l18.3151"></a><span id="l18.3151">   nsresult rv;</span>
<a href="#l18.3152"></a><span id="l18.3152" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.3153"></a><span id="l18.3153" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l18.3154"></a><span id="l18.3154" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.3155"></a><span id="l18.3155">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3156"></a><span id="l18.3156"> </span>
<a href="#l18.3157"></a><span id="l18.3157">   nsCOMPtr&lt;nsIMsgFolder&gt; rootMsgFolder;</span>
<a href="#l18.3158"></a><span id="l18.3158">   rv = GetRootFolder(getter_AddRefs(rootMsgFolder));</span>
<a href="#l18.3159"></a><span id="l18.3159">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3160"></a><span id="l18.3160"> </span>
<a href="#l18.3161"></a><span id="l18.3161">   // Locate the folder so that the correct hierarchical delimiter is used in the</span>
<a href="#l18.3162"></a><span id="l18.3162">   // folder pathnames, otherwise root's (ie, '^') is used and this is wrong.</span>
<a href="#l18.3163"></a><span id="l18.3163" class="difflineat">@@ -2538,831 +2328,765 @@ nsImapIncomingServer::SubscribeToFolder(</span>
<a href="#l18.3164"></a><span id="l18.3164"> </span>
<a href="#l18.3165"></a><span id="l18.3165">   nsAutoString unicodeName;</span>
<a href="#l18.3166"></a><span id="l18.3166">   rv = CopyMUTF7toUTF16(folderCName, unicodeName);</span>
<a href="#l18.3167"></a><span id="l18.3167">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3168"></a><span id="l18.3168"> </span>
<a href="#l18.3169"></a><span id="l18.3169">   if (subscribe)</span>
<a href="#l18.3170"></a><span id="l18.3170">     rv = imapService-&gt;SubscribeFolder(msgFolder, unicodeName, nullptr, aUri);</span>
<a href="#l18.3171"></a><span id="l18.3171">   else</span>
<a href="#l18.3172"></a><span id="l18.3172" class="difflineminus">-    rv = imapService-&gt;UnsubscribeFolder(msgFolder, unicodeName, nullptr, nullptr);</span>
<a href="#l18.3173"></a><span id="l18.3173" class="difflineplus">+    rv = imapService-&gt;UnsubscribeFolder(msgFolder, unicodeName, nullptr,</span>
<a href="#l18.3174"></a><span id="l18.3174" class="difflineplus">+                                        nullptr);</span>
<a href="#l18.3175"></a><span id="l18.3175">   return rv;</span>
<a href="#l18.3176"></a><span id="l18.3176"> }</span>
<a href="#l18.3177"></a><span id="l18.3177"> </span>
<a href="#l18.3178"></a><span id="l18.3178"> NS_IMETHODIMP</span>
<a href="#l18.3179"></a><span id="l18.3179" class="difflineminus">-nsImapIncomingServer::SetDoingLsub(bool doingLsub)</span>
<a href="#l18.3180"></a><span id="l18.3180" class="difflineminus">-{</span>
<a href="#l18.3181"></a><span id="l18.3181" class="difflineplus">+nsImapIncomingServer::SetDoingLsub(bool doingLsub) {</span>
<a href="#l18.3182"></a><span id="l18.3182">   mDoingLsub = doingLsub;</span>
<a href="#l18.3183"></a><span id="l18.3183">   return NS_OK;</span>
<a href="#l18.3184"></a><span id="l18.3184"> }</span>
<a href="#l18.3185"></a><span id="l18.3185"> </span>
<a href="#l18.3186"></a><span id="l18.3186"> NS_IMETHODIMP</span>
<a href="#l18.3187"></a><span id="l18.3187" class="difflineminus">-nsImapIncomingServer::GetDoingLsub(bool *doingLsub)</span>
<a href="#l18.3188"></a><span id="l18.3188" class="difflineminus">-{</span>
<a href="#l18.3189"></a><span id="l18.3189" class="difflineplus">+nsImapIncomingServer::GetDoingLsub(bool *doingLsub) {</span>
<a href="#l18.3190"></a><span id="l18.3190">   NS_ENSURE_ARG_POINTER(doingLsub);</span>
<a href="#l18.3191"></a><span id="l18.3191">   *doingLsub = mDoingLsub;</span>
<a href="#l18.3192"></a><span id="l18.3192">   return NS_OK;</span>
<a href="#l18.3193"></a><span id="l18.3193"> }</span>
<a href="#l18.3194"></a><span id="l18.3194"> </span>
<a href="#l18.3195"></a><span id="l18.3195"> NS_IMETHODIMP</span>
<a href="#l18.3196"></a><span id="l18.3196" class="difflineminus">-nsImapIncomingServer::ReDiscoverAllFolders()</span>
<a href="#l18.3197"></a><span id="l18.3197" class="difflineminus">-{</span>
<a href="#l18.3198"></a><span id="l18.3198" class="difflineminus">-  return PerformExpand(nullptr);</span>
<a href="#l18.3199"></a><span id="l18.3199" class="difflineminus">-}</span>
<a href="#l18.3200"></a><span id="l18.3200" class="difflineplus">+nsImapIncomingServer::ReDiscoverAllFolders() { return PerformExpand(nullptr); }</span>
<a href="#l18.3201"></a><span id="l18.3201"> </span>
<a href="#l18.3202"></a><span id="l18.3202"> NS_IMETHODIMP</span>
<a href="#l18.3203"></a><span id="l18.3203"> nsImapIncomingServer::SetState(const nsACString &amp;path, bool state,</span>
<a href="#l18.3204"></a><span id="l18.3204" class="difflineminus">-                               bool *stateChanged)</span>
<a href="#l18.3205"></a><span id="l18.3205" class="difflineminus">-{</span>
<a href="#l18.3206"></a><span id="l18.3206" class="difflineplus">+                               bool *stateChanged) {</span>
<a href="#l18.3207"></a><span id="l18.3207">   nsresult rv = EnsureInner();</span>
<a href="#l18.3208"></a><span id="l18.3208" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3209"></a><span id="l18.3209" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3210"></a><span id="l18.3210">   return mInner-&gt;SetState(path, state, stateChanged);</span>
<a href="#l18.3211"></a><span id="l18.3211"> }</span>
<a href="#l18.3212"></a><span id="l18.3212"> </span>
<a href="#l18.3213"></a><span id="l18.3213"> NS_IMETHODIMP</span>
<a href="#l18.3214"></a><span id="l18.3214" class="difflineminus">-nsImapIncomingServer::HasChildren(const nsACString &amp;path, bool *aHasChildren)</span>
<a href="#l18.3215"></a><span id="l18.3215" class="difflineminus">-{</span>
<a href="#l18.3216"></a><span id="l18.3216" class="difflineplus">+nsImapIncomingServer::HasChildren(const nsACString &amp;path, bool *aHasChildren) {</span>
<a href="#l18.3217"></a><span id="l18.3217">   nsresult rv = EnsureInner();</span>
<a href="#l18.3218"></a><span id="l18.3218" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3219"></a><span id="l18.3219" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3220"></a><span id="l18.3220">   return mInner-&gt;HasChildren(path, aHasChildren);</span>
<a href="#l18.3221"></a><span id="l18.3221"> }</span>
<a href="#l18.3222"></a><span id="l18.3222"> </span>
<a href="#l18.3223"></a><span id="l18.3223"> NS_IMETHODIMP</span>
<a href="#l18.3224"></a><span id="l18.3224"> nsImapIncomingServer::IsSubscribed(const nsACString &amp;path,</span>
<a href="#l18.3225"></a><span id="l18.3225" class="difflineminus">-                                   bool *aIsSubscribed)</span>
<a href="#l18.3226"></a><span id="l18.3226" class="difflineminus">-{</span>
<a href="#l18.3227"></a><span id="l18.3227" class="difflineplus">+                                   bool *aIsSubscribed) {</span>
<a href="#l18.3228"></a><span id="l18.3228">   nsresult rv = EnsureInner();</span>
<a href="#l18.3229"></a><span id="l18.3229" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3230"></a><span id="l18.3230" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3231"></a><span id="l18.3231">   return mInner-&gt;IsSubscribed(path, aIsSubscribed);</span>
<a href="#l18.3232"></a><span id="l18.3232"> }</span>
<a href="#l18.3233"></a><span id="l18.3233"> </span>
<a href="#l18.3234"></a><span id="l18.3234"> NS_IMETHODIMP</span>
<a href="#l18.3235"></a><span id="l18.3235" class="difflineminus">-nsImapIncomingServer::IsSubscribable(const nsACString &amp;path, bool *aIsSubscribable)</span>
<a href="#l18.3236"></a><span id="l18.3236" class="difflineminus">-{</span>
<a href="#l18.3237"></a><span id="l18.3237" class="difflineplus">+nsImapIncomingServer::IsSubscribable(const nsACString &amp;path,</span>
<a href="#l18.3238"></a><span id="l18.3238" class="difflineplus">+                                     bool *aIsSubscribable) {</span>
<a href="#l18.3239"></a><span id="l18.3239">   nsresult rv = EnsureInner();</span>
<a href="#l18.3240"></a><span id="l18.3240" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3241"></a><span id="l18.3241" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3242"></a><span id="l18.3242">   return mInner-&gt;IsSubscribable(path, aIsSubscribable);</span>
<a href="#l18.3243"></a><span id="l18.3243"> }</span>
<a href="#l18.3244"></a><span id="l18.3244"> </span>
<a href="#l18.3245"></a><span id="l18.3245"> NS_IMETHODIMP</span>
<a href="#l18.3246"></a><span id="l18.3246" class="difflineminus">-nsImapIncomingServer::GetLeafName(const nsACString &amp;path, nsAString &amp;aLeafName)</span>
<a href="#l18.3247"></a><span id="l18.3247" class="difflineminus">-{</span>
<a href="#l18.3248"></a><span id="l18.3248" class="difflineplus">+nsImapIncomingServer::GetLeafName(const nsACString &amp;path,</span>
<a href="#l18.3249"></a><span id="l18.3249" class="difflineplus">+                                  nsAString &amp;aLeafName) {</span>
<a href="#l18.3250"></a><span id="l18.3250">   nsresult rv = EnsureInner();</span>
<a href="#l18.3251"></a><span id="l18.3251" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3252"></a><span id="l18.3252" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3253"></a><span id="l18.3253">   return mInner-&gt;GetLeafName(path, aLeafName);</span>
<a href="#l18.3254"></a><span id="l18.3254"> }</span>
<a href="#l18.3255"></a><span id="l18.3255"> </span>
<a href="#l18.3256"></a><span id="l18.3256"> NS_IMETHODIMP</span>
<a href="#l18.3257"></a><span id="l18.3257" class="difflineminus">-nsImapIncomingServer::GetFirstChildURI(const nsACString &amp;path, nsACString &amp;aResult)</span>
<a href="#l18.3258"></a><span id="l18.3258" class="difflineminus">-{</span>
<a href="#l18.3259"></a><span id="l18.3259" class="difflineplus">+nsImapIncomingServer::GetFirstChildURI(const nsACString &amp;path,</span>
<a href="#l18.3260"></a><span id="l18.3260" class="difflineplus">+                                       nsACString &amp;aResult) {</span>
<a href="#l18.3261"></a><span id="l18.3261">   nsresult rv = EnsureInner();</span>
<a href="#l18.3262"></a><span id="l18.3262" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3263"></a><span id="l18.3263" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3264"></a><span id="l18.3264">   return mInner-&gt;GetFirstChildURI(path, aResult);</span>
<a href="#l18.3265"></a><span id="l18.3265"> }</span>
<a href="#l18.3266"></a><span id="l18.3266"> </span>
<a href="#l18.3267"></a><span id="l18.3267" class="difflineminus">-</span>
<a href="#l18.3268"></a><span id="l18.3268"> NS_IMETHODIMP</span>
<a href="#l18.3269"></a><span id="l18.3269"> nsImapIncomingServer::GetChildURIs(const nsACString &amp;aPath,</span>
<a href="#l18.3270"></a><span id="l18.3270" class="difflineminus">-                                   nsIUTF8StringEnumerator **aResult)</span>
<a href="#l18.3271"></a><span id="l18.3271" class="difflineminus">-{</span>
<a href="#l18.3272"></a><span id="l18.3272" class="difflineplus">+                                   nsIUTF8StringEnumerator **aResult) {</span>
<a href="#l18.3273"></a><span id="l18.3273">   nsresult rv = EnsureInner();</span>
<a href="#l18.3274"></a><span id="l18.3274" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3275"></a><span id="l18.3275" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3276"></a><span id="l18.3276">   return mInner-&gt;GetChildURIs(aPath, aResult);</span>
<a href="#l18.3277"></a><span id="l18.3277"> }</span>
<a href="#l18.3278"></a><span id="l18.3278"> </span>
<a href="#l18.3279"></a><span id="l18.3279" class="difflineminus">-nsresult</span>
<a href="#l18.3280"></a><span id="l18.3280" class="difflineminus">-nsImapIncomingServer::EnsureInner()</span>
<a href="#l18.3281"></a><span id="l18.3281" class="difflineminus">-{</span>
<a href="#l18.3282"></a><span id="l18.3282" class="difflineplus">+nsresult nsImapIncomingServer::EnsureInner() {</span>
<a href="#l18.3283"></a><span id="l18.3283">   nsresult rv = NS_OK;</span>
<a href="#l18.3284"></a><span id="l18.3284"> </span>
<a href="#l18.3285"></a><span id="l18.3285" class="difflineminus">-  if (mInner)</span>
<a href="#l18.3286"></a><span id="l18.3286" class="difflineminus">-    return NS_OK;</span>
<a href="#l18.3287"></a><span id="l18.3287" class="difflineminus">-</span>
<a href="#l18.3288"></a><span id="l18.3288" class="difflineminus">-  mInner = do_CreateInstance(kSubscribableServerCID,&amp;rv);</span>
<a href="#l18.3289"></a><span id="l18.3289" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3290"></a><span id="l18.3290" class="difflineplus">+  if (mInner) return NS_OK;</span>
<a href="#l18.3291"></a><span id="l18.3291" class="difflineplus">+</span>
<a href="#l18.3292"></a><span id="l18.3292" class="difflineplus">+  mInner = do_CreateInstance(kSubscribableServerCID, &amp;rv);</span>
<a href="#l18.3293"></a><span id="l18.3293" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3294"></a><span id="l18.3294">   return SetIncomingServer(this);</span>
<a href="#l18.3295"></a><span id="l18.3295"> }</span>
<a href="#l18.3296"></a><span id="l18.3296"> </span>
<a href="#l18.3297"></a><span id="l18.3297" class="difflineminus">-nsresult</span>
<a href="#l18.3298"></a><span id="l18.3298" class="difflineminus">-nsImapIncomingServer::ClearInner()</span>
<a href="#l18.3299"></a><span id="l18.3299" class="difflineminus">-{</span>
<a href="#l18.3300"></a><span id="l18.3300" class="difflineplus">+nsresult nsImapIncomingServer::ClearInner() {</span>
<a href="#l18.3301"></a><span id="l18.3301">   nsresult rv = NS_OK;</span>
<a href="#l18.3302"></a><span id="l18.3302" class="difflineminus">-  if (mInner)</span>
<a href="#l18.3303"></a><span id="l18.3303" class="difflineminus">-  {</span>
<a href="#l18.3304"></a><span id="l18.3304" class="difflineplus">+  if (mInner) {</span>
<a href="#l18.3305"></a><span id="l18.3305">     rv = mInner-&gt;SetSubscribeListener(nullptr);</span>
<a href="#l18.3306"></a><span id="l18.3306" class="difflineminus">-    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3307"></a><span id="l18.3307" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3308"></a><span id="l18.3308">     rv = mInner-&gt;SetIncomingServer(nullptr);</span>
<a href="#l18.3309"></a><span id="l18.3309" class="difflineminus">-    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3310"></a><span id="l18.3310" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3311"></a><span id="l18.3311">     mInner = nullptr;</span>
<a href="#l18.3312"></a><span id="l18.3312">   }</span>
<a href="#l18.3313"></a><span id="l18.3313">   return NS_OK;</span>
<a href="#l18.3314"></a><span id="l18.3314"> }</span>
<a href="#l18.3315"></a><span id="l18.3315"> </span>
<a href="#l18.3316"></a><span id="l18.3316"> NS_IMETHODIMP</span>
<a href="#l18.3317"></a><span id="l18.3317" class="difflineminus">-nsImapIncomingServer::CommitSubscribeChanges()</span>
<a href="#l18.3318"></a><span id="l18.3318" class="difflineminus">-{</span>
<a href="#l18.3319"></a><span id="l18.3319" class="difflineplus">+nsImapIncomingServer::CommitSubscribeChanges() {</span>
<a href="#l18.3320"></a><span id="l18.3320">   return ReDiscoverAllFolders();</span>
<a href="#l18.3321"></a><span id="l18.3321"> }</span>
<a href="#l18.3322"></a><span id="l18.3322"> </span>
<a href="#l18.3323"></a><span id="l18.3323"> NS_IMETHODIMP</span>
<a href="#l18.3324"></a><span id="l18.3324" class="difflineminus">-nsImapIncomingServer::GetCanBeDefaultServer(bool *canBeDefaultServer)</span>
<a href="#l18.3325"></a><span id="l18.3325" class="difflineminus">-{</span>
<a href="#l18.3326"></a><span id="l18.3326" class="difflineplus">+nsImapIncomingServer::GetCanBeDefaultServer(bool *canBeDefaultServer) {</span>
<a href="#l18.3327"></a><span id="l18.3327">   NS_ENSURE_ARG_POINTER(canBeDefaultServer);</span>
<a href="#l18.3328"></a><span id="l18.3328">   *canBeDefaultServer = true;</span>
<a href="#l18.3329"></a><span id="l18.3329">   return NS_OK;</span>
<a href="#l18.3330"></a><span id="l18.3330"> }</span>
<a href="#l18.3331"></a><span id="l18.3331"> </span>
<a href="#l18.3332"></a><span id="l18.3332"> NS_IMETHODIMP</span>
<a href="#l18.3333"></a><span id="l18.3333" class="difflineminus">-nsImapIncomingServer::GetCanCompactFoldersOnServer(bool *canCompactFoldersOnServer)</span>
<a href="#l18.3334"></a><span id="l18.3334" class="difflineminus">-{</span>
<a href="#l18.3335"></a><span id="l18.3335" class="difflineplus">+nsImapIncomingServer::GetCanCompactFoldersOnServer(</span>
<a href="#l18.3336"></a><span id="l18.3336" class="difflineplus">+    bool *canCompactFoldersOnServer) {</span>
<a href="#l18.3337"></a><span id="l18.3337">   NS_ENSURE_ARG_POINTER(canCompactFoldersOnServer);</span>
<a href="#l18.3338"></a><span id="l18.3338">   // Initialize canCompactFoldersOnServer true, a default value for IMAP</span>
<a href="#l18.3339"></a><span id="l18.3339">   *canCompactFoldersOnServer = true;</span>
<a href="#l18.3340"></a><span id="l18.3340" class="difflineminus">-  GetPrefForServerAttribute(&quot;canCompactFoldersOnServer&quot;, canCompactFoldersOnServer);</span>
<a href="#l18.3341"></a><span id="l18.3341" class="difflineplus">+  GetPrefForServerAttribute(&quot;canCompactFoldersOnServer&quot;,</span>
<a href="#l18.3342"></a><span id="l18.3342" class="difflineplus">+                            canCompactFoldersOnServer);</span>
<a href="#l18.3343"></a><span id="l18.3343">   return NS_OK;</span>
<a href="#l18.3344"></a><span id="l18.3344"> }</span>
<a href="#l18.3345"></a><span id="l18.3345"> </span>
<a href="#l18.3346"></a><span id="l18.3346"> NS_IMETHODIMP</span>
<a href="#l18.3347"></a><span id="l18.3347" class="difflineminus">-nsImapIncomingServer::GetCanUndoDeleteOnServer(bool *canUndoDeleteOnServer)</span>
<a href="#l18.3348"></a><span id="l18.3348" class="difflineminus">-{</span>
<a href="#l18.3349"></a><span id="l18.3349" class="difflineplus">+nsImapIncomingServer::GetCanUndoDeleteOnServer(bool *canUndoDeleteOnServer) {</span>
<a href="#l18.3350"></a><span id="l18.3350">   NS_ENSURE_ARG_POINTER(canUndoDeleteOnServer);</span>
<a href="#l18.3351"></a><span id="l18.3351">   // Initialize canUndoDeleteOnServer true, a default value for IMAP</span>
<a href="#l18.3352"></a><span id="l18.3352">   *canUndoDeleteOnServer = true;</span>
<a href="#l18.3353"></a><span id="l18.3353">   GetPrefForServerAttribute(&quot;canUndoDeleteOnServer&quot;, canUndoDeleteOnServer);</span>
<a href="#l18.3354"></a><span id="l18.3354">   return NS_OK;</span>
<a href="#l18.3355"></a><span id="l18.3355"> }</span>
<a href="#l18.3356"></a><span id="l18.3356"> </span>
<a href="#l18.3357"></a><span id="l18.3357"> NS_IMETHODIMP</span>
<a href="#l18.3358"></a><span id="l18.3358" class="difflineminus">-nsImapIncomingServer::GetCanSearchMessages(bool *canSearchMessages)</span>
<a href="#l18.3359"></a><span id="l18.3359" class="difflineminus">-{</span>
<a href="#l18.3360"></a><span id="l18.3360" class="difflineplus">+nsImapIncomingServer::GetCanSearchMessages(bool *canSearchMessages) {</span>
<a href="#l18.3361"></a><span id="l18.3361">   NS_ENSURE_ARG_POINTER(canSearchMessages);</span>
<a href="#l18.3362"></a><span id="l18.3362">   // Initialize canSearchMessages true, a default value for IMAP</span>
<a href="#l18.3363"></a><span id="l18.3363">   *canSearchMessages = true;</span>
<a href="#l18.3364"></a><span id="l18.3364">   GetPrefForServerAttribute(&quot;canSearchMessages&quot;, canSearchMessages);</span>
<a href="#l18.3365"></a><span id="l18.3365">   return NS_OK;</span>
<a href="#l18.3366"></a><span id="l18.3366"> }</span>
<a href="#l18.3367"></a><span id="l18.3367"> </span>
<a href="#l18.3368"></a><span id="l18.3368"> NS_IMETHODIMP</span>
<a href="#l18.3369"></a><span id="l18.3369" class="difflineminus">-nsImapIncomingServer::GetCanEmptyTrashOnExit(bool *canEmptyTrashOnExit)</span>
<a href="#l18.3370"></a><span id="l18.3370" class="difflineminus">-{</span>
<a href="#l18.3371"></a><span id="l18.3371" class="difflineplus">+nsImapIncomingServer::GetCanEmptyTrashOnExit(bool *canEmptyTrashOnExit) {</span>
<a href="#l18.3372"></a><span id="l18.3372">   NS_ENSURE_ARG_POINTER(canEmptyTrashOnExit);</span>
<a href="#l18.3373"></a><span id="l18.3373">   // Initialize canEmptyTrashOnExit true, a default value for IMAP</span>
<a href="#l18.3374"></a><span id="l18.3374">   *canEmptyTrashOnExit = true;</span>
<a href="#l18.3375"></a><span id="l18.3375">   GetPrefForServerAttribute(&quot;canEmptyTrashOnExit&quot;, canEmptyTrashOnExit);</span>
<a href="#l18.3376"></a><span id="l18.3376">   return NS_OK;</span>
<a href="#l18.3377"></a><span id="l18.3377"> }</span>
<a href="#l18.3378"></a><span id="l18.3378"> </span>
<a href="#l18.3379"></a><span id="l18.3379" class="difflineminus">-nsresult</span>
<a href="#l18.3380"></a><span id="l18.3380" class="difflineminus">-nsImapIncomingServer::CreateHostSpecificPrefName(const char *prefPrefix, nsAutoCString &amp;prefName)</span>
<a href="#l18.3381"></a><span id="l18.3381" class="difflineminus">-{</span>
<a href="#l18.3382"></a><span id="l18.3382" class="difflineplus">+nsresult nsImapIncomingServer::CreateHostSpecificPrefName(</span>
<a href="#l18.3383"></a><span id="l18.3383" class="difflineplus">+    const char *prefPrefix, nsAutoCString &amp;prefName) {</span>
<a href="#l18.3384"></a><span id="l18.3384">   NS_ENSURE_ARG_POINTER(prefPrefix);</span>
<a href="#l18.3385"></a><span id="l18.3385"> </span>
<a href="#l18.3386"></a><span id="l18.3386">   nsCString hostName;</span>
<a href="#l18.3387"></a><span id="l18.3387">   nsresult rv = GetHostName(hostName);</span>
<a href="#l18.3388"></a><span id="l18.3388" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3389"></a><span id="l18.3389" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3390"></a><span id="l18.3390"> </span>
<a href="#l18.3391"></a><span id="l18.3391">   prefName = prefPrefix;</span>
<a href="#l18.3392"></a><span id="l18.3392">   prefName.Append('.');</span>
<a href="#l18.3393"></a><span id="l18.3393">   prefName.Append(hostName);</span>
<a href="#l18.3394"></a><span id="l18.3394">   return NS_OK;</span>
<a href="#l18.3395"></a><span id="l18.3395"> }</span>
<a href="#l18.3396"></a><span id="l18.3396"> </span>
<a href="#l18.3397"></a><span id="l18.3397"> NS_IMETHODIMP</span>
<a href="#l18.3398"></a><span id="l18.3398" class="difflineminus">-nsImapIncomingServer::GetSupportsDiskSpace(bool *aSupportsDiskSpace)</span>
<a href="#l18.3399"></a><span id="l18.3399" class="difflineminus">-{</span>
<a href="#l18.3400"></a><span id="l18.3400" class="difflineplus">+nsImapIncomingServer::GetSupportsDiskSpace(bool *aSupportsDiskSpace) {</span>
<a href="#l18.3401"></a><span id="l18.3401">   NS_ENSURE_ARG_POINTER(aSupportsDiskSpace);</span>
<a href="#l18.3402"></a><span id="l18.3402">   nsAutoCString prefName;</span>
<a href="#l18.3403"></a><span id="l18.3403" class="difflineminus">-  nsresult rv = CreateHostSpecificPrefName(&quot;default_supports_diskspace&quot;, prefName);</span>
<a href="#l18.3404"></a><span id="l18.3404" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3405"></a><span id="l18.3405" class="difflineminus">-</span>
<a href="#l18.3406"></a><span id="l18.3406" class="difflineminus">-  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.3407"></a><span id="l18.3407" class="difflineplus">+  nsresult rv =</span>
<a href="#l18.3408"></a><span id="l18.3408" class="difflineplus">+      CreateHostSpecificPrefName(&quot;default_supports_diskspace&quot;, prefName);</span>
<a href="#l18.3409"></a><span id="l18.3409" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3410"></a><span id="l18.3410" class="difflineplus">+</span>
<a href="#l18.3411"></a><span id="l18.3411" class="difflineplus">+  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch =</span>
<a href="#l18.3412"></a><span id="l18.3412" class="difflineplus">+      do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.3413"></a><span id="l18.3413">   if (NS_SUCCEEDED(rv))</span>
<a href="#l18.3414"></a><span id="l18.3414" class="difflineminus">-     rv = prefBranch-&gt;GetBoolPref(prefName.get(), aSupportsDiskSpace);</span>
<a href="#l18.3415"></a><span id="l18.3415" class="difflineplus">+    rv = prefBranch-&gt;GetBoolPref(prefName.get(), aSupportsDiskSpace);</span>
<a href="#l18.3416"></a><span id="l18.3416"> </span>
<a href="#l18.3417"></a><span id="l18.3417">   // Couldn't get the default value with the hostname.</span>
<a href="#l18.3418"></a><span id="l18.3418">   // Fall back on IMAP default value</span>
<a href="#l18.3419"></a><span id="l18.3419" class="difflineminus">-  if (NS_FAILED(rv)) // set default value</span>
<a href="#l18.3420"></a><span id="l18.3420" class="difflineminus">-     *aSupportsDiskSpace = true;</span>
<a href="#l18.3421"></a><span id="l18.3421" class="difflineplus">+  if (NS_FAILED(rv))  // set default value</span>
<a href="#l18.3422"></a><span id="l18.3422" class="difflineplus">+    *aSupportsDiskSpace = true;</span>
<a href="#l18.3423"></a><span id="l18.3423">   return NS_OK;</span>
<a href="#l18.3424"></a><span id="l18.3424"> }</span>
<a href="#l18.3425"></a><span id="l18.3425"> </span>
<a href="#l18.3426"></a><span id="l18.3426"> // count number of non-busy connections in cache</span>
<a href="#l18.3427"></a><span id="l18.3427"> NS_IMETHODIMP</span>
<a href="#l18.3428"></a><span id="l18.3428" class="difflineminus">-nsImapIncomingServer::GetNumIdleConnections(int32_t *aNumIdleConnections)</span>
<a href="#l18.3429"></a><span id="l18.3429" class="difflineminus">-{</span>
<a href="#l18.3430"></a><span id="l18.3430" class="difflineplus">+nsImapIncomingServer::GetNumIdleConnections(int32_t *aNumIdleConnections) {</span>
<a href="#l18.3431"></a><span id="l18.3431">   NS_ENSURE_ARG_POINTER(aNumIdleConnections);</span>
<a href="#l18.3432"></a><span id="l18.3432">   *aNumIdleConnections = 0;</span>
<a href="#l18.3433"></a><span id="l18.3433"> </span>
<a href="#l18.3434"></a><span id="l18.3434">   nsresult rv = NS_OK;</span>
<a href="#l18.3435"></a><span id="l18.3435">   nsCOMPtr&lt;nsIImapProtocol&gt; connection;</span>
<a href="#l18.3436"></a><span id="l18.3436">   bool isBusy = false;</span>
<a href="#l18.3437"></a><span id="l18.3437">   bool isInboxConnection;</span>
<a href="#l18.3438"></a><span id="l18.3438">   PR_CEnterMonitor(this);</span>
<a href="#l18.3439"></a><span id="l18.3439"> </span>
<a href="#l18.3440"></a><span id="l18.3440">   int32_t cnt = m_connectionCache.Count();</span>
<a href="#l18.3441"></a><span id="l18.3441"> </span>
<a href="#l18.3442"></a><span id="l18.3442">   // loop counting idle connections</span>
<a href="#l18.3443"></a><span id="l18.3443" class="difflineminus">-  for (int32_t i = 0; i &lt; cnt; ++i)</span>
<a href="#l18.3444"></a><span id="l18.3444" class="difflineminus">-  {</span>
<a href="#l18.3445"></a><span id="l18.3445" class="difflineplus">+  for (int32_t i = 0; i &lt; cnt; ++i) {</span>
<a href="#l18.3446"></a><span id="l18.3446">     connection = m_connectionCache[i];</span>
<a href="#l18.3447"></a><span id="l18.3447" class="difflineminus">-    if (connection)</span>
<a href="#l18.3448"></a><span id="l18.3448" class="difflineminus">-    {</span>
<a href="#l18.3449"></a><span id="l18.3449" class="difflineplus">+    if (connection) {</span>
<a href="#l18.3450"></a><span id="l18.3450">       rv = connection-&gt;IsBusy(&amp;isBusy, &amp;isInboxConnection);</span>
<a href="#l18.3451"></a><span id="l18.3451" class="difflineminus">-      if (NS_FAILED(rv))</span>
<a href="#l18.3452"></a><span id="l18.3452" class="difflineminus">-        continue;</span>
<a href="#l18.3453"></a><span id="l18.3453" class="difflineminus">-      if (!isBusy)</span>
<a href="#l18.3454"></a><span id="l18.3454" class="difflineminus">-        (*aNumIdleConnections)++;</span>
<a href="#l18.3455"></a><span id="l18.3455" class="difflineplus">+      if (NS_FAILED(rv)) continue;</span>
<a href="#l18.3456"></a><span id="l18.3456" class="difflineplus">+      if (!isBusy) (*aNumIdleConnections)++;</span>
<a href="#l18.3457"></a><span id="l18.3457">     }</span>
<a href="#l18.3458"></a><span id="l18.3458">   }</span>
<a href="#l18.3459"></a><span id="l18.3459">   PR_CExitMonitor(this);</span>
<a href="#l18.3460"></a><span id="l18.3460">   return rv;</span>
<a href="#l18.3461"></a><span id="l18.3461"> }</span>
<a href="#l18.3462"></a><span id="l18.3462"> </span>
<a href="#l18.3463"></a><span id="l18.3463" class="difflineminus">-</span>
<a href="#l18.3464"></a><span id="l18.3464"> /**</span>
<a href="#l18.3465"></a><span id="l18.3465">  * Get the preference that tells us whether the imap server in question allows</span>
<a href="#l18.3466"></a><span id="l18.3466">  * us to create subfolders. Some ISPs might not want users to create any folders</span>
<a href="#l18.3467"></a><span id="l18.3467">  * besides the existing ones.</span>
<a href="#l18.3468"></a><span id="l18.3468" class="difflineminus">- * We do want to identify all those servers that don't allow creation of subfolders</span>
<a href="#l18.3469"></a><span id="l18.3469" class="difflineminus">- * and take them out of the account picker in the Copies and Folder panel.</span>
<a href="#l18.3470"></a><span id="l18.3470" class="difflineplus">+ * We do want to identify all those servers that don't allow creation of</span>
<a href="#l18.3471"></a><span id="l18.3471" class="difflineplus">+ * subfolders and take them out of the account picker in the Copies and Folder</span>
<a href="#l18.3472"></a><span id="l18.3472" class="difflineplus">+ * panel.</span>
<a href="#l18.3473"></a><span id="l18.3473">  */</span>
<a href="#l18.3474"></a><span id="l18.3474"> NS_IMETHODIMP</span>
<a href="#l18.3475"></a><span id="l18.3475" class="difflineminus">-nsImapIncomingServer::GetCanCreateFoldersOnServer(bool *aCanCreateFoldersOnServer)</span>
<a href="#l18.3476"></a><span id="l18.3476" class="difflineminus">-{</span>
<a href="#l18.3477"></a><span id="l18.3477" class="difflineplus">+nsImapIncomingServer::GetCanCreateFoldersOnServer(</span>
<a href="#l18.3478"></a><span id="l18.3478" class="difflineplus">+    bool *aCanCreateFoldersOnServer) {</span>
<a href="#l18.3479"></a><span id="l18.3479">   NS_ENSURE_ARG_POINTER(aCanCreateFoldersOnServer);</span>
<a href="#l18.3480"></a><span id="l18.3480">   // Initialize aCanCreateFoldersOnServer true, a default value for IMAP</span>
<a href="#l18.3481"></a><span id="l18.3481">   *aCanCreateFoldersOnServer = true;</span>
<a href="#l18.3482"></a><span id="l18.3482">   GetPrefForServerAttribute(&quot;canCreateFolders&quot;, aCanCreateFoldersOnServer);</span>
<a href="#l18.3483"></a><span id="l18.3483">   return NS_OK;</span>
<a href="#l18.3484"></a><span id="l18.3484"> }</span>
<a href="#l18.3485"></a><span id="l18.3485"> </span>
<a href="#l18.3486"></a><span id="l18.3486"> NS_IMETHODIMP</span>
<a href="#l18.3487"></a><span id="l18.3487" class="difflineminus">-nsImapIncomingServer::GetOfflineSupportLevel(int32_t *aSupportLevel)</span>
<a href="#l18.3488"></a><span id="l18.3488" class="difflineminus">-{</span>
<a href="#l18.3489"></a><span id="l18.3489" class="difflineplus">+nsImapIncomingServer::GetOfflineSupportLevel(int32_t *aSupportLevel) {</span>
<a href="#l18.3490"></a><span id="l18.3490">   NS_ENSURE_ARG_POINTER(aSupportLevel);</span>
<a href="#l18.3491"></a><span id="l18.3491">   nsresult rv = NS_OK;</span>
<a href="#l18.3492"></a><span id="l18.3492"> </span>
<a href="#l18.3493"></a><span id="l18.3493">   rv = GetIntValue(&quot;offline_support_level&quot;, aSupportLevel);</span>
<a href="#l18.3494"></a><span id="l18.3494" class="difflineminus">-  if (*aSupportLevel != OFFLINE_SUPPORT_LEVEL_UNDEFINED)</span>
<a href="#l18.3495"></a><span id="l18.3495" class="difflineminus">-    return rv;</span>
<a href="#l18.3496"></a><span id="l18.3496" class="difflineplus">+  if (*aSupportLevel != OFFLINE_SUPPORT_LEVEL_UNDEFINED) return rv;</span>
<a href="#l18.3497"></a><span id="l18.3497"> </span>
<a href="#l18.3498"></a><span id="l18.3498">   nsAutoCString prefName;</span>
<a href="#l18.3499"></a><span id="l18.3499">   rv = CreateHostSpecificPrefName(&quot;default_offline_support_level&quot;, prefName);</span>
<a href="#l18.3500"></a><span id="l18.3500" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3501"></a><span id="l18.3501" class="difflineminus">-</span>
<a href="#l18.3502"></a><span id="l18.3502" class="difflineminus">-  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.3503"></a><span id="l18.3503" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3504"></a><span id="l18.3504" class="difflineplus">+</span>
<a href="#l18.3505"></a><span id="l18.3505" class="difflineplus">+  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch =</span>
<a href="#l18.3506"></a><span id="l18.3506" class="difflineplus">+      do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.3507"></a><span id="l18.3507">   if (NS_SUCCEEDED(rv))</span>
<a href="#l18.3508"></a><span id="l18.3508">     rv = prefBranch-&gt;GetIntPref(prefName.get(), aSupportLevel);</span>
<a href="#l18.3509"></a><span id="l18.3509"> </span>
<a href="#l18.3510"></a><span id="l18.3510">   // Couldn't get the pref value with the hostname.</span>
<a href="#l18.3511"></a><span id="l18.3511">   // Fall back on IMAP default value</span>
<a href="#l18.3512"></a><span id="l18.3512" class="difflineminus">-  if (NS_FAILED(rv)) // set default value</span>
<a href="#l18.3513"></a><span id="l18.3513" class="difflineplus">+  if (NS_FAILED(rv))  // set default value</span>
<a href="#l18.3514"></a><span id="l18.3514">     *aSupportLevel = OFFLINE_SUPPORT_LEVEL_REGULAR;</span>
<a href="#l18.3515"></a><span id="l18.3515">   return NS_OK;</span>
<a href="#l18.3516"></a><span id="l18.3516"> }</span>
<a href="#l18.3517"></a><span id="l18.3517"> </span>
<a href="#l18.3518"></a><span id="l18.3518" class="difflineminus">-// Called only during the migration process. This routine enables the generation of</span>
<a href="#l18.3519"></a><span id="l18.3519" class="difflineminus">-// unique account name based on the username, hostname and the port. If the port</span>
<a href="#l18.3520"></a><span id="l18.3520" class="difflineminus">-// is valid and not a default one, it will be appended to the account name.</span>
<a href="#l18.3521"></a><span id="l18.3521" class="difflineplus">+// Called only during the migration process. This routine enables the generation</span>
<a href="#l18.3522"></a><span id="l18.3522" class="difflineplus">+// of unique account name based on the username, hostname and the port. If the</span>
<a href="#l18.3523"></a><span id="l18.3523" class="difflineplus">+// port is valid and not a default one, it will be appended to the account name.</span>
<a href="#l18.3524"></a><span id="l18.3524"> NS_IMETHODIMP</span>
<a href="#l18.3525"></a><span id="l18.3525" class="difflineminus">-nsImapIncomingServer::GeneratePrettyNameForMigration(nsAString&amp; aPrettyName)</span>
<a href="#l18.3526"></a><span id="l18.3526" class="difflineminus">-{</span>
<a href="#l18.3527"></a><span id="l18.3527" class="difflineplus">+nsImapIncomingServer::GeneratePrettyNameForMigration(nsAString &amp;aPrettyName) {</span>
<a href="#l18.3528"></a><span id="l18.3528">   nsCString userName;</span>
<a href="#l18.3529"></a><span id="l18.3529">   nsCString hostName;</span>
<a href="#l18.3530"></a><span id="l18.3530"> </span>
<a href="#l18.3531"></a><span id="l18.3531" class="difflineminus">-/**</span>
<a href="#l18.3532"></a><span id="l18.3532" class="difflineminus">-  * Pretty name for migrated account is of format username@hostname:&lt;port&gt;,</span>
<a href="#l18.3533"></a><span id="l18.3533" class="difflineminus">-  * provided the port is valid and not the default</span>
<a href="#l18.3534"></a><span id="l18.3534" class="difflineminus">-*/</span>
<a href="#l18.3535"></a><span id="l18.3535" class="difflineplus">+  /**</span>
<a href="#l18.3536"></a><span id="l18.3536" class="difflineplus">+   * Pretty name for migrated account is of format username@hostname:&lt;port&gt;,</span>
<a href="#l18.3537"></a><span id="l18.3537" class="difflineplus">+   * provided the port is valid and not the default</span>
<a href="#l18.3538"></a><span id="l18.3538" class="difflineplus">+   */</span>
<a href="#l18.3539"></a><span id="l18.3539">   // Get user name to construct pretty name</span>
<a href="#l18.3540"></a><span id="l18.3540">   nsresult rv = GetUsername(userName);</span>
<a href="#l18.3541"></a><span id="l18.3541">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3542"></a><span id="l18.3542"> </span>
<a href="#l18.3543"></a><span id="l18.3543">   // Get host name to construct pretty name</span>
<a href="#l18.3544"></a><span id="l18.3544">   rv = GetHostName(hostName);</span>
<a href="#l18.3545"></a><span id="l18.3545">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3546"></a><span id="l18.3546"> </span>
<a href="#l18.3547"></a><span id="l18.3547">   int32_t defaultServerPort;</span>
<a href="#l18.3548"></a><span id="l18.3548">   int32_t defaultSecureServerPort;</span>
<a href="#l18.3549"></a><span id="l18.3549"> </span>
<a href="#l18.3550"></a><span id="l18.3550" class="difflineminus">-  // Here, the final contract ID is already known, so use it directly for efficiency.</span>
<a href="#l18.3551"></a><span id="l18.3551" class="difflineminus">-  nsCOMPtr &lt;nsIMsgProtocolInfo&gt; protocolInfo = do_GetService(NS_IMAPPROTOCOLINFO_CONTRACTID, &amp;rv);</span>
<a href="#l18.3552"></a><span id="l18.3552" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3553"></a><span id="l18.3553" class="difflineplus">+  // Here, the final contract ID is already known, so use it directly for</span>
<a href="#l18.3554"></a><span id="l18.3554" class="difflineplus">+  // efficiency.</span>
<a href="#l18.3555"></a><span id="l18.3555" class="difflineplus">+  nsCOMPtr&lt;nsIMsgProtocolInfo&gt; protocolInfo =</span>
<a href="#l18.3556"></a><span id="l18.3556" class="difflineplus">+      do_GetService(NS_IMAPPROTOCOLINFO_CONTRACTID, &amp;rv);</span>
<a href="#l18.3557"></a><span id="l18.3557" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3558"></a><span id="l18.3558"> </span>
<a href="#l18.3559"></a><span id="l18.3559">   // Get the default port</span>
<a href="#l18.3560"></a><span id="l18.3560">   rv = protocolInfo-&gt;GetDefaultServerPort(false, &amp;defaultServerPort);</span>
<a href="#l18.3561"></a><span id="l18.3561" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3562"></a><span id="l18.3562" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3563"></a><span id="l18.3563"> </span>
<a href="#l18.3564"></a><span id="l18.3564">   // Get the default secure port</span>
<a href="#l18.3565"></a><span id="l18.3565">   rv = protocolInfo-&gt;GetDefaultServerPort(true, &amp;defaultSecureServerPort);</span>
<a href="#l18.3566"></a><span id="l18.3566" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3567"></a><span id="l18.3567" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3568"></a><span id="l18.3568"> </span>
<a href="#l18.3569"></a><span id="l18.3569">   // Get the current server port</span>
<a href="#l18.3570"></a><span id="l18.3570">   int32_t serverPort = PORT_NOT_SET;</span>
<a href="#l18.3571"></a><span id="l18.3571">   rv = GetPort(&amp;serverPort);</span>
<a href="#l18.3572"></a><span id="l18.3572" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3573"></a><span id="l18.3573" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3574"></a><span id="l18.3574"> </span>
<a href="#l18.3575"></a><span id="l18.3575">   // Is the server secure ?</span>
<a href="#l18.3576"></a><span id="l18.3576">   int32_t socketType;</span>
<a href="#l18.3577"></a><span id="l18.3577">   rv = GetSocketType(&amp;socketType);</span>
<a href="#l18.3578"></a><span id="l18.3578" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3579"></a><span id="l18.3579" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3580"></a><span id="l18.3580">   bool isSecure = (socketType == nsMsgSocketType::SSL);</span>
<a href="#l18.3581"></a><span id="l18.3581"> </span>
<a href="#l18.3582"></a><span id="l18.3582">   // Is server port a default port ?</span>
<a href="#l18.3583"></a><span id="l18.3583">   bool isItDefaultPort = false;</span>
<a href="#l18.3584"></a><span id="l18.3584" class="difflineminus">-  if (((serverPort == defaultServerPort) &amp;&amp; !isSecure)||</span>
<a href="#l18.3585"></a><span id="l18.3585" class="difflineplus">+  if (((serverPort == defaultServerPort) &amp;&amp; !isSecure) ||</span>
<a href="#l18.3586"></a><span id="l18.3586">       ((serverPort == defaultSecureServerPort) &amp;&amp; isSecure))</span>
<a href="#l18.3587"></a><span id="l18.3587" class="difflineminus">-      isItDefaultPort = true;</span>
<a href="#l18.3588"></a><span id="l18.3588" class="difflineplus">+    isItDefaultPort = true;</span>
<a href="#l18.3589"></a><span id="l18.3589"> </span>
<a href="#l18.3590"></a><span id="l18.3590">   // Construct pretty name from username and hostname</span>
<a href="#l18.3591"></a><span id="l18.3591">   nsAutoString constructedPrettyName;</span>
<a href="#l18.3592"></a><span id="l18.3592" class="difflineminus">-  CopyASCIItoUTF16(userName,constructedPrettyName);</span>
<a href="#l18.3593"></a><span id="l18.3593" class="difflineplus">+  CopyASCIItoUTF16(userName, constructedPrettyName);</span>
<a href="#l18.3594"></a><span id="l18.3594">   constructedPrettyName.Append('@');</span>
<a href="#l18.3595"></a><span id="l18.3595">   constructedPrettyName.Append(NS_ConvertASCIItoUTF16(hostName));</span>
<a href="#l18.3596"></a><span id="l18.3596"> </span>
<a href="#l18.3597"></a><span id="l18.3597">   // If the port is valid and not default, add port value to the pretty name</span>
<a href="#l18.3598"></a><span id="l18.3598">   if ((serverPort &gt; 0) &amp;&amp; (!isItDefaultPort)) {</span>
<a href="#l18.3599"></a><span id="l18.3599">     constructedPrettyName.Append(':');</span>
<a href="#l18.3600"></a><span id="l18.3600">     constructedPrettyName.AppendInt(serverPort);</span>
<a href="#l18.3601"></a><span id="l18.3601">   }</span>
<a href="#l18.3602"></a><span id="l18.3602"> </span>
<a href="#l18.3603"></a><span id="l18.3603">   // Format the pretty name</span>
<a href="#l18.3604"></a><span id="l18.3604">   return GetFormattedStringFromName(constructedPrettyName,</span>
<a href="#l18.3605"></a><span id="l18.3605" class="difflineminus">-                                    &quot;imapDefaultAccountName&quot;,</span>
<a href="#l18.3606"></a><span id="l18.3606" class="difflineminus">-                                    aPrettyName);</span>
<a href="#l18.3607"></a><span id="l18.3607" class="difflineplus">+                                    &quot;imapDefaultAccountName&quot;, aPrettyName);</span>
<a href="#l18.3608"></a><span id="l18.3608"> }</span>
<a href="#l18.3609"></a><span id="l18.3609"> </span>
<a href="#l18.3610"></a><span id="l18.3610" class="difflineminus">-nsresult</span>
<a href="#l18.3611"></a><span id="l18.3611" class="difflineminus">-nsImapIncomingServer::GetFormattedStringFromName(const nsAString&amp; aValue,</span>
<a href="#l18.3612"></a><span id="l18.3612" class="difflineminus">-                                                 const char* aName,</span>
<a href="#l18.3613"></a><span id="l18.3613" class="difflineminus">-                                                 nsAString&amp; aResult)</span>
<a href="#l18.3614"></a><span id="l18.3614" class="difflineminus">-{</span>
<a href="#l18.3615"></a><span id="l18.3615" class="difflineplus">+nsresult nsImapIncomingServer::GetFormattedStringFromName(</span>
<a href="#l18.3616"></a><span id="l18.3616" class="difflineplus">+    const nsAString &amp;aValue, const char *aName, nsAString &amp;aResult) {</span>
<a href="#l18.3617"></a><span id="l18.3617">   nsresult rv = GetStringBundle();</span>
<a href="#l18.3618"></a><span id="l18.3618" class="difflineminus">-  if (m_stringBundle)</span>
<a href="#l18.3619"></a><span id="l18.3619" class="difflineminus">-  {</span>
<a href="#l18.3620"></a><span id="l18.3620" class="difflineminus">-    nsString tmpVal (aValue);</span>
<a href="#l18.3621"></a><span id="l18.3621" class="difflineminus">-    const char16_t *formatStrings[] = { tmpVal.get() };</span>
<a href="#l18.3622"></a><span id="l18.3622" class="difflineplus">+  if (m_stringBundle) {</span>
<a href="#l18.3623"></a><span id="l18.3623" class="difflineplus">+    nsString tmpVal(aValue);</span>
<a href="#l18.3624"></a><span id="l18.3624" class="difflineplus">+    const char16_t *formatStrings[] = {tmpVal.get()};</span>
<a href="#l18.3625"></a><span id="l18.3625"> </span>
<a href="#l18.3626"></a><span id="l18.3626">     nsString result;</span>
<a href="#l18.3627"></a><span id="l18.3627" class="difflineminus">-    rv = m_stringBundle-&gt;FormatStringFromName(</span>
<a href="#l18.3628"></a><span id="l18.3628" class="difflineminus">-      aName,</span>
<a href="#l18.3629"></a><span id="l18.3629" class="difflineminus">-      formatStrings, 1, result);</span>
<a href="#l18.3630"></a><span id="l18.3630" class="difflineplus">+    rv = m_stringBundle-&gt;FormatStringFromName(aName, formatStrings, 1, result);</span>
<a href="#l18.3631"></a><span id="l18.3631">     aResult.Assign(result);</span>
<a href="#l18.3632"></a><span id="l18.3632">   }</span>
<a href="#l18.3633"></a><span id="l18.3633">   return rv;</span>
<a href="#l18.3634"></a><span id="l18.3634"> }</span>
<a href="#l18.3635"></a><span id="l18.3635"> </span>
<a href="#l18.3636"></a><span id="l18.3636" class="difflineminus">-nsresult</span>
<a href="#l18.3637"></a><span id="l18.3637" class="difflineminus">-nsImapIncomingServer::GetPrefForServerAttribute(const char *prefSuffix, bool *prefValue)</span>
<a href="#l18.3638"></a><span id="l18.3638" class="difflineminus">-{</span>
<a href="#l18.3639"></a><span id="l18.3639" class="difflineplus">+nsresult nsImapIncomingServer::GetPrefForServerAttribute(const char *prefSuffix,</span>
<a href="#l18.3640"></a><span id="l18.3640" class="difflineplus">+                                                         bool *prefValue) {</span>
<a href="#l18.3641"></a><span id="l18.3641">   // Any caller of this function must initialize prefValue with a default value</span>
<a href="#l18.3642"></a><span id="l18.3642">   // as this code will not set prefValue when the pref does not exist and return</span>
<a href="#l18.3643"></a><span id="l18.3643">   // NS_OK anyway</span>
<a href="#l18.3644"></a><span id="l18.3644"> </span>
<a href="#l18.3645"></a><span id="l18.3645" class="difflineminus">-  if (!mPrefBranch)</span>
<a href="#l18.3646"></a><span id="l18.3646" class="difflineminus">-    return NS_ERROR_NOT_INITIALIZED;</span>
<a href="#l18.3647"></a><span id="l18.3647" class="difflineplus">+  if (!mPrefBranch) return NS_ERROR_NOT_INITIALIZED;</span>
<a href="#l18.3648"></a><span id="l18.3648"> </span>
<a href="#l18.3649"></a><span id="l18.3649">   NS_ENSURE_ARG_POINTER(prefValue);</span>
<a href="#l18.3650"></a><span id="l18.3650"> </span>
<a href="#l18.3651"></a><span id="l18.3651">   if (NS_FAILED(mPrefBranch-&gt;GetBoolPref(prefSuffix, prefValue)))</span>
<a href="#l18.3652"></a><span id="l18.3652">     mDefPrefBranch-&gt;GetBoolPref(prefSuffix, prefValue);</span>
<a href="#l18.3653"></a><span id="l18.3653"> </span>
<a href="#l18.3654"></a><span id="l18.3654">   return NS_OK;</span>
<a href="#l18.3655"></a><span id="l18.3655"> }</span>
<a href="#l18.3656"></a><span id="l18.3656"> </span>
<a href="#l18.3657"></a><span id="l18.3657"> NS_IMETHODIMP</span>
<a href="#l18.3658"></a><span id="l18.3658" class="difflineminus">-nsImapIncomingServer::GetCanFileMessagesOnServer(bool *aCanFileMessagesOnServer)</span>
<a href="#l18.3659"></a><span id="l18.3659" class="difflineminus">-{</span>
<a href="#l18.3660"></a><span id="l18.3660" class="difflineplus">+nsImapIncomingServer::GetCanFileMessagesOnServer(</span>
<a href="#l18.3661"></a><span id="l18.3661" class="difflineplus">+    bool *aCanFileMessagesOnServer) {</span>
<a href="#l18.3662"></a><span id="l18.3662">   NS_ENSURE_ARG_POINTER(aCanFileMessagesOnServer);</span>
<a href="#l18.3663"></a><span id="l18.3663">   // Initialize aCanFileMessagesOnServer true, a default value for IMAP</span>
<a href="#l18.3664"></a><span id="l18.3664">   *aCanFileMessagesOnServer = true;</span>
<a href="#l18.3665"></a><span id="l18.3665">   GetPrefForServerAttribute(&quot;canFileMessages&quot;, aCanFileMessagesOnServer);</span>
<a href="#l18.3666"></a><span id="l18.3666">   return NS_OK;</span>
<a href="#l18.3667"></a><span id="l18.3667"> }</span>
<a href="#l18.3668"></a><span id="l18.3668"> </span>
<a href="#l18.3669"></a><span id="l18.3669"> NS_IMETHODIMP</span>
<a href="#l18.3670"></a><span id="l18.3670" class="difflineminus">-nsImapIncomingServer::SetSearchValue(const nsAString &amp;searchValue)</span>
<a href="#l18.3671"></a><span id="l18.3671" class="difflineminus">-{</span>
<a href="#l18.3672"></a><span id="l18.3672" class="difflineplus">+nsImapIncomingServer::SetSearchValue(const nsAString &amp;searchValue) {</span>
<a href="#l18.3673"></a><span id="l18.3673">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l18.3674"></a><span id="l18.3674"> }</span>
<a href="#l18.3675"></a><span id="l18.3675"> </span>
<a href="#l18.3676"></a><span id="l18.3676"> NS_IMETHODIMP</span>
<a href="#l18.3677"></a><span id="l18.3677" class="difflineminus">-nsImapIncomingServer::GetSupportsSubscribeSearch(bool *retVal)</span>
<a href="#l18.3678"></a><span id="l18.3678" class="difflineminus">-{</span>
<a href="#l18.3679"></a><span id="l18.3679" class="difflineplus">+nsImapIncomingServer::GetSupportsSubscribeSearch(bool *retVal) {</span>
<a href="#l18.3680"></a><span id="l18.3680">   NS_ENSURE_ARG_POINTER(retVal);</span>
<a href="#l18.3681"></a><span id="l18.3681">   *retVal = false;</span>
<a href="#l18.3682"></a><span id="l18.3682">   return NS_OK;</span>
<a href="#l18.3683"></a><span id="l18.3683"> }</span>
<a href="#l18.3684"></a><span id="l18.3684"> </span>
<a href="#l18.3685"></a><span id="l18.3685"> NS_IMETHODIMP</span>
<a href="#l18.3686"></a><span id="l18.3686" class="difflineminus">-nsImapIncomingServer::GetFolderView(nsITreeView **aView)</span>
<a href="#l18.3687"></a><span id="l18.3687" class="difflineminus">-{</span>
<a href="#l18.3688"></a><span id="l18.3688" class="difflineplus">+nsImapIncomingServer::GetFolderView(nsITreeView **aView) {</span>
<a href="#l18.3689"></a><span id="l18.3689">   nsresult rv = EnsureInner();</span>
<a href="#l18.3690"></a><span id="l18.3690" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3691"></a><span id="l18.3691" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3692"></a><span id="l18.3692">   return mInner-&gt;GetFolderView(aView);</span>
<a href="#l18.3693"></a><span id="l18.3693"> }</span>
<a href="#l18.3694"></a><span id="l18.3694"> </span>
<a href="#l18.3695"></a><span id="l18.3695"> NS_IMETHODIMP</span>
<a href="#l18.3696"></a><span id="l18.3696" class="difflineminus">-nsImapIncomingServer::GetFilterScope(nsMsgSearchScopeValue *filterScope)</span>
<a href="#l18.3697"></a><span id="l18.3697" class="difflineminus">-{</span>
<a href="#l18.3698"></a><span id="l18.3698" class="difflineplus">+nsImapIncomingServer::GetFilterScope(nsMsgSearchScopeValue *filterScope) {</span>
<a href="#l18.3699"></a><span id="l18.3699">   NS_ENSURE_ARG_POINTER(filterScope);</span>
<a href="#l18.3700"></a><span id="l18.3700">   // If the inbox is enabled for offline use, then use the offline filter</span>
<a href="#l18.3701"></a><span id="l18.3701">   // scope, else use the online filter scope.</span>
<a href="#l18.3702"></a><span id="l18.3702">   //</span>
<a href="#l18.3703"></a><span id="l18.3703">   // XXX We use the same scope for all folders with the same incoming server,</span>
<a href="#l18.3704"></a><span id="l18.3704">   // yet it is possible to set the offline flag separately for each folder.</span>
<a href="#l18.3705"></a><span id="l18.3705">   // Manual filters could perhaps check the offline status of each folder,</span>
<a href="#l18.3706"></a><span id="l18.3706">   // though it's hard to see how to make that work since we only store filters</span>
<a href="#l18.3707"></a><span id="l18.3707">   // per server.</span>
<a href="#l18.3708"></a><span id="l18.3708">   //</span>
<a href="#l18.3709"></a><span id="l18.3709">   nsCOMPtr&lt;nsIMsgFolder&gt; rootMsgFolder;</span>
<a href="#l18.3710"></a><span id="l18.3710">   nsresult rv = GetRootMsgFolder(getter_AddRefs(rootMsgFolder));</span>
<a href="#l18.3711"></a><span id="l18.3711">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3712"></a><span id="l18.3712">   nsCOMPtr&lt;nsIMsgFolder&gt; offlineInboxMsgFolder;</span>
<a href="#l18.3713"></a><span id="l18.3713" class="difflineminus">-  rv = rootMsgFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Inbox |</span>
<a href="#l18.3714"></a><span id="l18.3714" class="difflineminus">-                                           nsMsgFolderFlags::Offline,</span>
<a href="#l18.3715"></a><span id="l18.3715" class="difflineminus">-                                         getter_AddRefs(offlineInboxMsgFolder));</span>
<a href="#l18.3716"></a><span id="l18.3716" class="difflineplus">+  rv = rootMsgFolder-&gt;GetFolderWithFlags(</span>
<a href="#l18.3717"></a><span id="l18.3717" class="difflineplus">+      nsMsgFolderFlags::Inbox | nsMsgFolderFlags::Offline,</span>
<a href="#l18.3718"></a><span id="l18.3718" class="difflineplus">+      getter_AddRefs(offlineInboxMsgFolder));</span>
<a href="#l18.3719"></a><span id="l18.3719"> </span>
<a href="#l18.3720"></a><span id="l18.3720">   *filterScope = offlineInboxMsgFolder ? nsMsgSearchScope::offlineMailFilter</span>
<a href="#l18.3721"></a><span id="l18.3721">                                        : nsMsgSearchScope::onlineMailFilter;</span>
<a href="#l18.3722"></a><span id="l18.3722">   return NS_OK;</span>
<a href="#l18.3723"></a><span id="l18.3723"> }</span>
<a href="#l18.3724"></a><span id="l18.3724"> </span>
<a href="#l18.3725"></a><span id="l18.3725"> NS_IMETHODIMP</span>
<a href="#l18.3726"></a><span id="l18.3726" class="difflineminus">-nsImapIncomingServer::GetSearchScope(nsMsgSearchScopeValue *searchScope)</span>
<a href="#l18.3727"></a><span id="l18.3727" class="difflineminus">-{</span>
<a href="#l18.3728"></a><span id="l18.3728" class="difflineplus">+nsImapIncomingServer::GetSearchScope(nsMsgSearchScopeValue *searchScope) {</span>
<a href="#l18.3729"></a><span id="l18.3729">   NS_ENSURE_ARG_POINTER(searchScope);</span>
<a href="#l18.3730"></a><span id="l18.3730" class="difflineminus">- *searchScope = WeAreOffline() ? nsMsgSearchScope::offlineMail : nsMsgSearchScope::onlineMail;</span>
<a href="#l18.3731"></a><span id="l18.3731" class="difflineplus">+  *searchScope = WeAreOffline() ? nsMsgSearchScope::offlineMail</span>
<a href="#l18.3732"></a><span id="l18.3732" class="difflineplus">+                                : nsMsgSearchScope::onlineMail;</span>
<a href="#l18.3733"></a><span id="l18.3733">   return NS_OK;</span>
<a href="#l18.3734"></a><span id="l18.3734"> }</span>
<a href="#l18.3735"></a><span id="l18.3735"> </span>
<a href="#l18.3736"></a><span id="l18.3736"> // This is a recursive function. It gets new messages for current folder</span>
<a href="#l18.3737"></a><span id="l18.3737"> // first if it is marked, then calls itself recursively for each subfolder.</span>
<a href="#l18.3738"></a><span id="l18.3738"> NS_IMETHODIMP</span>
<a href="#l18.3739"></a><span id="l18.3739"> nsImapIncomingServer::GetNewMessagesForNonInboxFolders(nsIMsgFolder *aFolder,</span>
<a href="#l18.3740"></a><span id="l18.3740">                                                        nsIMsgWindow *aWindow,</span>
<a href="#l18.3741"></a><span id="l18.3741">                                                        bool forceAllFolders,</span>
<a href="#l18.3742"></a><span id="l18.3742" class="difflineminus">-                                                       bool performingBiff)</span>
<a href="#l18.3743"></a><span id="l18.3743" class="difflineminus">-{</span>
<a href="#l18.3744"></a><span id="l18.3744" class="difflineplus">+                                                       bool performingBiff) {</span>
<a href="#l18.3745"></a><span id="l18.3745">   NS_ENSURE_ARG_POINTER(aFolder);</span>
<a href="#l18.3746"></a><span id="l18.3746">   static bool gGotStatusPref = false;</span>
<a href="#l18.3747"></a><span id="l18.3747">   static bool gUseStatus = false;</span>
<a href="#l18.3748"></a><span id="l18.3748"> </span>
<a href="#l18.3749"></a><span id="l18.3749">   bool isServer;</span>
<a href="#l18.3750"></a><span id="l18.3750" class="difflineminus">-  (void) aFolder-&gt;GetIsServer(&amp;isServer);</span>
<a href="#l18.3751"></a><span id="l18.3751" class="difflineplus">+  (void)aFolder-&gt;GetIsServer(&amp;isServer);</span>
<a href="#l18.3752"></a><span id="l18.3752">   // Check this folder for new messages if it is marked to be checked</span>
<a href="#l18.3753"></a><span id="l18.3753">   // or if we are forced to check all folders</span>
<a href="#l18.3754"></a><span id="l18.3754">   uint32_t flags = 0;</span>
<a href="#l18.3755"></a><span id="l18.3755">   aFolder-&gt;GetFlags(&amp;flags);</span>
<a href="#l18.3756"></a><span id="l18.3756">   nsresult rv;</span>
<a href="#l18.3757"></a><span id="l18.3757">   nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(aFolder, &amp;rv);</span>
<a href="#l18.3758"></a><span id="l18.3758">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3759"></a><span id="l18.3759">   bool canOpen;</span>
<a href="#l18.3760"></a><span id="l18.3760">   imapFolder-&gt;GetCanOpenFolder(&amp;canOpen);</span>
<a href="#l18.3761"></a><span id="l18.3761" class="difflineminus">-  if (canOpen &amp;&amp; ((forceAllFolders &amp;&amp;</span>
<a href="#l18.3762"></a><span id="l18.3762" class="difflineminus">-                 !(flags &amp; (nsMsgFolderFlags::Inbox | nsMsgFolderFlags::Trash |</span>
<a href="#l18.3763"></a><span id="l18.3763" class="difflineplus">+  if (canOpen &amp;&amp;</span>
<a href="#l18.3764"></a><span id="l18.3764" class="difflineplus">+      ((forceAllFolders &amp;&amp;</span>
<a href="#l18.3765"></a><span id="l18.3765" class="difflineplus">+        !(flags &amp; (nsMsgFolderFlags::Inbox | nsMsgFolderFlags::Trash |</span>
<a href="#l18.3766"></a><span id="l18.3766">                    nsMsgFolderFlags::Junk | nsMsgFolderFlags::Virtual))) ||</span>
<a href="#l18.3767"></a><span id="l18.3767" class="difflineminus">-                flags &amp; nsMsgFolderFlags::CheckNew))</span>
<a href="#l18.3768"></a><span id="l18.3768" class="difflineminus">-  {</span>
<a href="#l18.3769"></a><span id="l18.3769" class="difflineplus">+       flags &amp; nsMsgFolderFlags::CheckNew)) {</span>
<a href="#l18.3770"></a><span id="l18.3770">     // Get new messages for this folder.</span>
<a href="#l18.3771"></a><span id="l18.3771">     aFolder-&gt;SetGettingNewMessages(true);</span>
<a href="#l18.3772"></a><span id="l18.3772" class="difflineminus">-    if (performingBiff)</span>
<a href="#l18.3773"></a><span id="l18.3773" class="difflineminus">-      imapFolder-&gt;SetPerformingBiff(true);</span>
<a href="#l18.3774"></a><span id="l18.3774" class="difflineplus">+    if (performingBiff) imapFolder-&gt;SetPerformingBiff(true);</span>
<a href="#l18.3775"></a><span id="l18.3775">     bool isOpen = false;</span>
<a href="#l18.3776"></a><span id="l18.3776" class="difflineminus">-    nsCOMPtr &lt;nsIMsgMailSession&gt; mailSession = do_GetService(NS_MSGMAILSESSION_CONTRACTID);</span>
<a href="#l18.3777"></a><span id="l18.3777" class="difflineplus">+    nsCOMPtr&lt;nsIMsgMailSession&gt; mailSession =</span>
<a href="#l18.3778"></a><span id="l18.3778" class="difflineplus">+        do_GetService(NS_MSGMAILSESSION_CONTRACTID);</span>
<a href="#l18.3779"></a><span id="l18.3779">     if (mailSession &amp;&amp; aFolder)</span>
<a href="#l18.3780"></a><span id="l18.3780">       mailSession-&gt;IsFolderOpenInWindow(aFolder, &amp;isOpen);</span>
<a href="#l18.3781"></a><span id="l18.3781">     // eventually, the gGotStatusPref should go away, once we work out the kinks</span>
<a href="#l18.3782"></a><span id="l18.3782">     // from using STATUS.</span>
<a href="#l18.3783"></a><span id="l18.3783" class="difflineminus">-    if (!gGotStatusPref)</span>
<a href="#l18.3784"></a><span id="l18.3784" class="difflineminus">-    {</span>
<a href="#l18.3785"></a><span id="l18.3785" class="difflineminus">-      nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID);</span>
<a href="#l18.3786"></a><span id="l18.3786" class="difflineminus">-      if(prefBranch)</span>
<a href="#l18.3787"></a><span id="l18.3787" class="difflineplus">+    if (!gGotStatusPref) {</span>
<a href="#l18.3788"></a><span id="l18.3788" class="difflineplus">+      nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch =</span>
<a href="#l18.3789"></a><span id="l18.3789" class="difflineplus">+          do_GetService(NS_PREFSERVICE_CONTRACTID);</span>
<a href="#l18.3790"></a><span id="l18.3790" class="difflineplus">+      if (prefBranch)</span>
<a href="#l18.3791"></a><span id="l18.3791">         prefBranch-&gt;GetBoolPref(&quot;mail.imap.use_status_for_biff&quot;, &amp;gUseStatus);</span>
<a href="#l18.3792"></a><span id="l18.3792">       gGotStatusPref = true;</span>
<a href="#l18.3793"></a><span id="l18.3793">     }</span>
<a href="#l18.3794"></a><span id="l18.3794" class="difflineminus">-    if (gUseStatus &amp;&amp; !isOpen)</span>
<a href="#l18.3795"></a><span id="l18.3795" class="difflineminus">-    {</span>
<a href="#l18.3796"></a><span id="l18.3796" class="difflineplus">+    if (gUseStatus &amp;&amp; !isOpen) {</span>
<a href="#l18.3797"></a><span id="l18.3797">       if (!isServer &amp;&amp; m_foldersToStat.IndexOf(imapFolder) == -1)</span>
<a href="#l18.3798"></a><span id="l18.3798">         m_foldersToStat.AppendObject(imapFolder);</span>
<a href="#l18.3799"></a><span id="l18.3799" class="difflineminus">-    }</span>
<a href="#l18.3800"></a><span id="l18.3800" class="difflineminus">-    else</span>
<a href="#l18.3801"></a><span id="l18.3801" class="difflineplus">+    } else</span>
<a href="#l18.3802"></a><span id="l18.3802">       aFolder-&gt;UpdateFolder(aWindow);</span>
<a href="#l18.3803"></a><span id="l18.3803">   }</span>
<a href="#l18.3804"></a><span id="l18.3804"> </span>
<a href="#l18.3805"></a><span id="l18.3805">   // Loop through all subfolders to get new messages for them.</span>
<a href="#l18.3806"></a><span id="l18.3806">   nsCOMPtr&lt;nsISimpleEnumerator&gt; enumerator;</span>
<a href="#l18.3807"></a><span id="l18.3807">   rv = aFolder-&gt;GetSubFolders(getter_AddRefs(enumerator));</span>
<a href="#l18.3808"></a><span id="l18.3808" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l18.3809"></a><span id="l18.3809" class="difflineminus">-    return rv;</span>
<a href="#l18.3810"></a><span id="l18.3810" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l18.3811"></a><span id="l18.3811"> </span>
<a href="#l18.3812"></a><span id="l18.3812">   bool hasMore;</span>
<a href="#l18.3813"></a><span id="l18.3813" class="difflineminus">-  while (NS_SUCCEEDED(enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l18.3814"></a><span id="l18.3814" class="difflineminus">-  {</span>
<a href="#l18.3815"></a><span id="l18.3815" class="difflineplus">+  while (NS_SUCCEEDED(enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore) {</span>
<a href="#l18.3816"></a><span id="l18.3816">     nsCOMPtr&lt;nsISupports&gt; item;</span>
<a href="#l18.3817"></a><span id="l18.3817">     enumerator-&gt;GetNext(getter_AddRefs(item));</span>
<a href="#l18.3818"></a><span id="l18.3818"> </span>
<a href="#l18.3819"></a><span id="l18.3819">     nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder(do_QueryInterface(item));</span>
<a href="#l18.3820"></a><span id="l18.3820" class="difflineminus">-    if (!msgFolder)</span>
<a href="#l18.3821"></a><span id="l18.3821" class="difflineminus">-    {</span>
<a href="#l18.3822"></a><span id="l18.3822" class="difflineplus">+    if (!msgFolder) {</span>
<a href="#l18.3823"></a><span id="l18.3823">       NS_WARNING(&quot;Not an nsIMsgFolder&quot;);</span>
<a href="#l18.3824"></a><span id="l18.3824">       continue;</span>
<a href="#l18.3825"></a><span id="l18.3825">     }</span>
<a href="#l18.3826"></a><span id="l18.3826">     GetNewMessagesForNonInboxFolders(msgFolder, aWindow, forceAllFolders,</span>
<a href="#l18.3827"></a><span id="l18.3827">                                      performingBiff);</span>
<a href="#l18.3828"></a><span id="l18.3828">   }</span>
<a href="#l18.3829"></a><span id="l18.3829">   if (isServer &amp;&amp; m_foldersToStat.Count() &gt; 0)</span>
<a href="#l18.3830"></a><span id="l18.3830">     m_foldersToStat[0]-&gt;UpdateStatus(this, nullptr);</span>
<a href="#l18.3831"></a><span id="l18.3831">   return NS_OK;</span>
<a href="#l18.3832"></a><span id="l18.3832"> }</span>
<a href="#l18.3833"></a><span id="l18.3833"> </span>
<a href="#l18.3834"></a><span id="l18.3834"> NS_IMETHODIMP</span>
<a href="#l18.3835"></a><span id="l18.3835" class="difflineminus">-nsImapIncomingServer::GetArbitraryHeaders(nsACString &amp;aResult)</span>
<a href="#l18.3836"></a><span id="l18.3836" class="difflineminus">-{</span>
<a href="#l18.3837"></a><span id="l18.3837" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFilterList&gt; filterList;</span>
<a href="#l18.3838"></a><span id="l18.3838" class="difflineplus">+nsImapIncomingServer::GetArbitraryHeaders(nsACString &amp;aResult) {</span>
<a href="#l18.3839"></a><span id="l18.3839" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFilterList&gt; filterList;</span>
<a href="#l18.3840"></a><span id="l18.3840">   nsresult rv = GetFilterList(nullptr, getter_AddRefs(filterList));</span>
<a href="#l18.3841"></a><span id="l18.3841" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3842"></a><span id="l18.3842" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3843"></a><span id="l18.3843">   return filterList-&gt;GetArbitraryHeaders(aResult);</span>
<a href="#l18.3844"></a><span id="l18.3844"> }</span>
<a href="#l18.3845"></a><span id="l18.3845"> </span>
<a href="#l18.3846"></a><span id="l18.3846"> NS_IMETHODIMP</span>
<a href="#l18.3847"></a><span id="l18.3847" class="difflineminus">-nsImapIncomingServer::GetShowAttachmentsInline(bool *aResult)</span>
<a href="#l18.3848"></a><span id="l18.3848" class="difflineminus">-{</span>
<a href="#l18.3849"></a><span id="l18.3849" class="difflineplus">+nsImapIncomingServer::GetShowAttachmentsInline(bool *aResult) {</span>
<a href="#l18.3850"></a><span id="l18.3850">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l18.3851"></a><span id="l18.3851" class="difflineminus">-  *aResult = true; // true per default</span>
<a href="#l18.3852"></a><span id="l18.3852" class="difflineplus">+  *aResult = true;  // true per default</span>
<a href="#l18.3853"></a><span id="l18.3853">   nsresult rv;</span>
<a href="#l18.3854"></a><span id="l18.3854" class="difflineminus">-  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.3855"></a><span id="l18.3855" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3856"></a><span id="l18.3856" class="difflineplus">+  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch =</span>
<a href="#l18.3857"></a><span id="l18.3857" class="difflineplus">+      do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.3858"></a><span id="l18.3858" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3859"></a><span id="l18.3859"> </span>
<a href="#l18.3860"></a><span id="l18.3860">   prefBranch-&gt;GetBoolPref(&quot;mail.inline_attachments&quot;, aResult);</span>
<a href="#l18.3861"></a><span id="l18.3861" class="difflineminus">-  return NS_OK; // In case this pref is not set we need to return NS_OK.</span>
<a href="#l18.3862"></a><span id="l18.3862" class="difflineplus">+  return NS_OK;  // In case this pref is not set we need to return NS_OK.</span>
<a href="#l18.3863"></a><span id="l18.3863"> }</span>
<a href="#l18.3864"></a><span id="l18.3864"> </span>
<a href="#l18.3865"></a><span id="l18.3865" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::SetSocketType(int32_t aSocketType)</span>
<a href="#l18.3866"></a><span id="l18.3866" class="difflineminus">-{</span>
<a href="#l18.3867"></a><span id="l18.3867" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::SetSocketType(int32_t aSocketType) {</span>
<a href="#l18.3868"></a><span id="l18.3868">   int32_t oldSocketType;</span>
<a href="#l18.3869"></a><span id="l18.3869">   nsresult rv = GetSocketType(&amp;oldSocketType);</span>
<a href="#l18.3870"></a><span id="l18.3870">   if (NS_SUCCEEDED(rv) &amp;&amp; oldSocketType != aSocketType)</span>
<a href="#l18.3871"></a><span id="l18.3871">     CloseCachedConnections();</span>
<a href="#l18.3872"></a><span id="l18.3872">   return nsMsgIncomingServer::SetSocketType(aSocketType);</span>
<a href="#l18.3873"></a><span id="l18.3873"> }</span>
<a href="#l18.3874"></a><span id="l18.3874"> </span>
<a href="#l18.3875"></a><span id="l18.3875"> NS_IMETHODIMP</span>
<a href="#l18.3876"></a><span id="l18.3876" class="difflineminus">-nsImapIncomingServer::OnUserOrHostNameChanged(const nsACString&amp; oldName,</span>
<a href="#l18.3877"></a><span id="l18.3877" class="difflineminus">-                                              const nsACString&amp; newName,</span>
<a href="#l18.3878"></a><span id="l18.3878" class="difflineminus">-                                              bool hostnameChanged)</span>
<a href="#l18.3879"></a><span id="l18.3879" class="difflineminus">-{</span>
<a href="#l18.3880"></a><span id="l18.3880" class="difflineplus">+nsImapIncomingServer::OnUserOrHostNameChanged(const nsACString &amp;oldName,</span>
<a href="#l18.3881"></a><span id="l18.3881" class="difflineplus">+                                              const nsACString &amp;newName,</span>
<a href="#l18.3882"></a><span id="l18.3882" class="difflineplus">+                                              bool hostnameChanged) {</span>
<a href="#l18.3883"></a><span id="l18.3883">   nsresult rv;</span>
<a href="#l18.3884"></a><span id="l18.3884">   // 1. Do common things in the base class.</span>
<a href="#l18.3885"></a><span id="l18.3885" class="difflineminus">-  rv = nsMsgIncomingServer::OnUserOrHostNameChanged(oldName, newName, hostnameChanged);</span>
<a href="#l18.3886"></a><span id="l18.3886" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.3887"></a><span id="l18.3887" class="difflineplus">+  rv = nsMsgIncomingServer::OnUserOrHostNameChanged(oldName, newName,</span>
<a href="#l18.3888"></a><span id="l18.3888" class="difflineplus">+                                                    hostnameChanged);</span>
<a href="#l18.3889"></a><span id="l18.3889" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3890"></a><span id="l18.3890"> </span>
<a href="#l18.3891"></a><span id="l18.3891">   // 2. Reset 'HaveWeEverDiscoveredFolders' flag so the new folder list can be</span>
<a href="#l18.3892"></a><span id="l18.3892">   //    reloaded (ie, DiscoverMailboxList() will be invoked in nsImapProtocol).</span>
<a href="#l18.3893"></a><span id="l18.3893" class="difflineminus">-  nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSessionList = do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.3894"></a><span id="l18.3894" class="difflineplus">+  nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSessionList =</span>
<a href="#l18.3895"></a><span id="l18.3895" class="difflineplus">+      do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.3896"></a><span id="l18.3896">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3897"></a><span id="l18.3897">   nsAutoCString serverKey;</span>
<a href="#l18.3898"></a><span id="l18.3898">   rv = GetKey(serverKey);</span>
<a href="#l18.3899"></a><span id="l18.3899">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3900"></a><span id="l18.3900" class="difflineminus">-  hostSessionList-&gt;SetHaveWeEverDiscoveredFoldersForHost(serverKey.get(), false);</span>
<a href="#l18.3901"></a><span id="l18.3901" class="difflineplus">+  hostSessionList-&gt;SetHaveWeEverDiscoveredFoldersForHost(serverKey.get(),</span>
<a href="#l18.3902"></a><span id="l18.3902" class="difflineplus">+                                                         false);</span>
<a href="#l18.3903"></a><span id="l18.3903">   // 3. Make all the existing folders 'unverified' so that they can be</span>
<a href="#l18.3904"></a><span id="l18.3904">   //    removed from the folder pane after users log into the new server.</span>
<a href="#l18.3905"></a><span id="l18.3905">   ResetFoldersToUnverified(nullptr);</span>
<a href="#l18.3906"></a><span id="l18.3906">   return NS_OK;</span>
<a href="#l18.3907"></a><span id="l18.3907"> }</span>
<a href="#l18.3908"></a><span id="l18.3908"> </span>
<a href="#l18.3909"></a><span id="l18.3909"> // use canonical format in originalUri &amp; convertedUri</span>
<a href="#l18.3910"></a><span id="l18.3910"> NS_IMETHODIMP</span>
<a href="#l18.3911"></a><span id="l18.3911" class="difflineminus">-nsImapIncomingServer::GetUriWithNamespacePrefixIfNecessary(int32_t namespaceType,</span>
<a href="#l18.3912"></a><span id="l18.3912" class="difflineminus">-                                                           const nsACString&amp; originalUri,</span>
<a href="#l18.3913"></a><span id="l18.3913" class="difflineminus">-                                                           nsACString&amp; convertedUri)</span>
<a href="#l18.3914"></a><span id="l18.3914" class="difflineminus">-{</span>
<a href="#l18.3915"></a><span id="l18.3915" class="difflineplus">+nsImapIncomingServer::GetUriWithNamespacePrefixIfNecessary(</span>
<a href="#l18.3916"></a><span id="l18.3916" class="difflineplus">+    int32_t namespaceType, const nsACString &amp;originalUri,</span>
<a href="#l18.3917"></a><span id="l18.3917" class="difflineplus">+    nsACString &amp;convertedUri) {</span>
<a href="#l18.3918"></a><span id="l18.3918">   nsresult rv = NS_OK;</span>
<a href="#l18.3919"></a><span id="l18.3919">   nsAutoCString serverKey;</span>
<a href="#l18.3920"></a><span id="l18.3920">   rv = GetKey(serverKey);</span>
<a href="#l18.3921"></a><span id="l18.3921">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3922"></a><span id="l18.3922" class="difflineminus">-  nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSessionList = do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.3923"></a><span id="l18.3923" class="difflineplus">+  nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSessionList =</span>
<a href="#l18.3924"></a><span id="l18.3924" class="difflineplus">+      do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l18.3925"></a><span id="l18.3925">   nsIMAPNamespace *ns = nullptr;</span>
<a href="#l18.3926"></a><span id="l18.3926" class="difflineminus">-  rv = hostSessionList-&gt;GetDefaultNamespaceOfTypeForHost(serverKey.get(), (EIMAPNamespaceType)namespaceType, ns);</span>
<a href="#l18.3927"></a><span id="l18.3927" class="difflineminus">-  if (ns)</span>
<a href="#l18.3928"></a><span id="l18.3928" class="difflineminus">-  {</span>
<a href="#l18.3929"></a><span id="l18.3929" class="difflineplus">+  rv = hostSessionList-&gt;GetDefaultNamespaceOfTypeForHost(</span>
<a href="#l18.3930"></a><span id="l18.3930" class="difflineplus">+      serverKey.get(), (EIMAPNamespaceType)namespaceType, ns);</span>
<a href="#l18.3931"></a><span id="l18.3931" class="difflineplus">+  if (ns) {</span>
<a href="#l18.3932"></a><span id="l18.3932">     nsAutoCString namespacePrefix(ns-&gt;GetPrefix());</span>
<a href="#l18.3933"></a><span id="l18.3933" class="difflineminus">-    if (!namespacePrefix.IsEmpty())</span>
<a href="#l18.3934"></a><span id="l18.3934" class="difflineminus">-    {</span>
<a href="#l18.3935"></a><span id="l18.3935" class="difflineminus">-      // check if namespacePrefix is the same as the online directory; if so, ignore it.</span>
<a href="#l18.3936"></a><span id="l18.3936" class="difflineplus">+    if (!namespacePrefix.IsEmpty()) {</span>
<a href="#l18.3937"></a><span id="l18.3937" class="difflineplus">+      // check if namespacePrefix is the same as the online directory; if so,</span>
<a href="#l18.3938"></a><span id="l18.3938" class="difflineplus">+      // ignore it.</span>
<a href="#l18.3939"></a><span id="l18.3939">       nsAutoCString onlineDir;</span>
<a href="#l18.3940"></a><span id="l18.3940">       rv = GetServerDirectory(onlineDir);</span>
<a href="#l18.3941"></a><span id="l18.3941">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.3942"></a><span id="l18.3942" class="difflineminus">-      if (!onlineDir.IsEmpty())</span>
<a href="#l18.3943"></a><span id="l18.3943" class="difflineminus">-      {</span>
<a href="#l18.3944"></a><span id="l18.3944" class="difflineplus">+      if (!onlineDir.IsEmpty()) {</span>
<a href="#l18.3945"></a><span id="l18.3945">         char delimiter = ns-&gt;GetDelimiter();</span>
<a href="#l18.3946"></a><span id="l18.3946" class="difflineminus">-          if ( onlineDir.Last() != delimiter )</span>
<a href="#l18.3947"></a><span id="l18.3947" class="difflineminus">-            onlineDir += delimiter;</span>
<a href="#l18.3948"></a><span id="l18.3948" class="difflineminus">-          if (onlineDir.Equals(namespacePrefix))</span>
<a href="#l18.3949"></a><span id="l18.3949" class="difflineminus">-            return NS_OK;</span>
<a href="#l18.3950"></a><span id="l18.3950" class="difflineplus">+        if (onlineDir.Last() != delimiter) onlineDir += delimiter;</span>
<a href="#l18.3951"></a><span id="l18.3951" class="difflineplus">+        if (onlineDir.Equals(namespacePrefix)) return NS_OK;</span>
<a href="#l18.3952"></a><span id="l18.3952">       }</span>
<a href="#l18.3953"></a><span id="l18.3953"> </span>
<a href="#l18.3954"></a><span id="l18.3954" class="difflineminus">-      MsgReplaceChar(namespacePrefix, ns-&gt;GetDelimiter(), '/'); // use canonical format</span>
<a href="#l18.3955"></a><span id="l18.3955" class="difflineplus">+      MsgReplaceChar(namespacePrefix, ns-&gt;GetDelimiter(),</span>
<a href="#l18.3956"></a><span id="l18.3956" class="difflineplus">+                     '/');  // use canonical format</span>
<a href="#l18.3957"></a><span id="l18.3957">       nsCString uri(originalUri);</span>
<a href="#l18.3958"></a><span id="l18.3958" class="difflineminus">-      int32_t index = uri.Find(&quot;//&quot;);           // find scheme</span>
<a href="#l18.3959"></a><span id="l18.3959" class="difflineminus">-      index = uri.FindChar('/', index + 2);       // find '/' after scheme</span>
<a href="#l18.3960"></a><span id="l18.3960" class="difflineplus">+      int32_t index = uri.Find(&quot;//&quot;);        // find scheme</span>
<a href="#l18.3961"></a><span id="l18.3961" class="difflineplus">+      index = uri.FindChar('/', index + 2);  // find '/' after scheme</span>
<a href="#l18.3962"></a><span id="l18.3962">       // it may be the case that this is the INBOX uri, in which case</span>
<a href="#l18.3963"></a><span id="l18.3963" class="difflineminus">-      // we don't want to prepend the namespace. In that case, the uri ends with &quot;INBOX&quot;,</span>
<a href="#l18.3964"></a><span id="l18.3964" class="difflineminus">-      // but the namespace is &quot;INBOX/&quot;, so they don't match.</span>
<a href="#l18.3965"></a><span id="l18.3965" class="difflineplus">+      // we don't want to prepend the namespace. In that case, the uri ends with</span>
<a href="#l18.3966"></a><span id="l18.3966" class="difflineplus">+      // &quot;INBOX&quot;, but the namespace is &quot;INBOX/&quot;, so they don't match.</span>
<a href="#l18.3967"></a><span id="l18.3967">       if (MsgFind(uri, namespacePrefix, false, index + 1) != index + 1 &amp;&amp;</span>
<a href="#l18.3968"></a><span id="l18.3968">           !MsgLowerCaseEqualsLiteral(Substring(uri, index + 1), &quot;inbox&quot;))</span>
<a href="#l18.3969"></a><span id="l18.3969" class="difflineminus">-        uri.Insert(namespacePrefix, index + 1);   // insert namespace prefix</span>
<a href="#l18.3970"></a><span id="l18.3970" class="difflineplus">+        uri.Insert(namespacePrefix, index + 1);  // insert namespace prefix</span>
<a href="#l18.3971"></a><span id="l18.3971">       convertedUri = uri;</span>
<a href="#l18.3972"></a><span id="l18.3972">     }</span>
<a href="#l18.3973"></a><span id="l18.3973">   }</span>
<a href="#l18.3974"></a><span id="l18.3974">   return rv;</span>
<a href="#l18.3975"></a><span id="l18.3975"> }</span>
<a href="#l18.3976"></a><span id="l18.3976"> </span>
<a href="#l18.3977"></a><span id="l18.3977" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::GetTrashFolderName(nsAString&amp; retval)</span>
<a href="#l18.3978"></a><span id="l18.3978" class="difflineminus">-{</span>
<a href="#l18.3979"></a><span id="l18.3979" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::GetTrashFolderName(nsAString &amp;retval) {</span>
<a href="#l18.3980"></a><span id="l18.3980">   // Despite its name, this returns a path, for example INBOX/Trash.</span>
<a href="#l18.3981"></a><span id="l18.3981">   nsresult rv = GetUnicharValue(PREF_TRASH_FOLDER_PATH, retval);</span>
<a href="#l18.3982"></a><span id="l18.3982" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l18.3983"></a><span id="l18.3983" class="difflineminus">-    return rv;</span>
<a href="#l18.3984"></a><span id="l18.3984" class="difflineminus">-  if (retval.IsEmpty())</span>
<a href="#l18.3985"></a><span id="l18.3985" class="difflineminus">-    retval = NS_LITERAL_STRING(DEFAULT_TRASH_FOLDER_PATH);</span>
<a href="#l18.3986"></a><span id="l18.3986" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l18.3987"></a><span id="l18.3987" class="difflineplus">+  if (retval.IsEmpty()) retval = NS_LITERAL_STRING(DEFAULT_TRASH_FOLDER_PATH);</span>
<a href="#l18.3988"></a><span id="l18.3988">   return NS_OK;</span>
<a href="#l18.3989"></a><span id="l18.3989"> }</span>
<a href="#l18.3990"></a><span id="l18.3990"> </span>
<a href="#l18.3991"></a><span id="l18.3991" class="difflineminus">-NS_IMETHODIMP nsImapIncomingServer::SetTrashFolderName(const nsAString&amp; chvalue)</span>
<a href="#l18.3992"></a><span id="l18.3992" class="difflineminus">-{</span>
<a href="#l18.3993"></a><span id="l18.3993" class="difflineplus">+NS_IMETHODIMP nsImapIncomingServer::SetTrashFolderName(</span>
<a href="#l18.3994"></a><span id="l18.3994" class="difflineplus">+    const nsAString &amp;chvalue) {</span>
<a href="#l18.3995"></a><span id="l18.3995">   // Clear trash flag from the old pref.</span>
<a href="#l18.3996"></a><span id="l18.3996" class="difflineminus">-  // Despite its name, this returns the trash folder path, for example INBOX/Trash.</span>
<a href="#l18.3997"></a><span id="l18.3997" class="difflineplus">+  // Despite its name, this returns the trash folder path, for example</span>
<a href="#l18.3998"></a><span id="l18.3998" class="difflineplus">+  // INBOX/Trash.</span>
<a href="#l18.3999"></a><span id="l18.3999">   nsAutoString oldTrashName;</span>
<a href="#l18.4000"></a><span id="l18.4000">   nsresult rv = GetTrashFolderName(oldTrashName);</span>
<a href="#l18.4001"></a><span id="l18.4001" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l18.4002"></a><span id="l18.4002" class="difflineminus">-  {</span>
<a href="#l18.4003"></a><span id="l18.4003" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.4004"></a><span id="l18.4004">     nsAutoCString oldTrashNameUtf7;</span>
<a href="#l18.4005"></a><span id="l18.4005">     rv = CopyUTF16toMUTF7(oldTrashName, oldTrashNameUtf7);</span>
<a href="#l18.4006"></a><span id="l18.4006" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l18.4007"></a><span id="l18.4007" class="difflineminus">-    {</span>
<a href="#l18.4008"></a><span id="l18.4008" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.4009"></a><span id="l18.4009">       nsCOMPtr&lt;nsIMsgFolder&gt; oldFolder;</span>
<a href="#l18.4010"></a><span id="l18.4010">       // 'trashFolderName' being a path here works well since this is appended</span>
<a href="#l18.4011"></a><span id="l18.4011">       // to the server's root folder in GetFolder().</span>
<a href="#l18.4012"></a><span id="l18.4012">       rv = GetFolder(oldTrashNameUtf7, getter_AddRefs(oldFolder));</span>
<a href="#l18.4013"></a><span id="l18.4013">       if (NS_SUCCEEDED(rv) &amp;&amp; oldFolder)</span>
<a href="#l18.4014"></a><span id="l18.4014">         oldFolder-&gt;ClearFlag(nsMsgFolderFlags::Trash);</span>
<a href="#l18.4015"></a><span id="l18.4015">     }</span>
<a href="#l18.4016"></a><span id="l18.4016">   }</span>
<a href="#l18.4017"></a><span id="l18.4017"> </span>
<a href="#l18.4018"></a><span id="l18.4018">   // If the user configured delete mode (model) is currently &quot;move to trash&quot;,</span>
<a href="#l18.4019"></a><span id="l18.4019">   // mark the newly designated trash folder name as the active trash</span>
<a href="#l18.4020"></a><span id="l18.4020">   // destination folder.</span>
<a href="#l18.4021"></a><span id="l18.4021">   int32_t deleteModel;</span>
<a href="#l18.4022"></a><span id="l18.4022">   rv = GetDeleteModel(&amp;deleteModel);</span>
<a href="#l18.4023"></a><span id="l18.4023" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; (deleteModel == nsMsgImapDeleteModels::MoveToTrash))</span>
<a href="#l18.4024"></a><span id="l18.4024" class="difflineminus">-  {</span>
<a href="#l18.4025"></a><span id="l18.4025" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; (deleteModel == nsMsgImapDeleteModels::MoveToTrash)) {</span>
<a href="#l18.4026"></a><span id="l18.4026">     nsAutoCString newTrashNameUtf7;</span>
<a href="#l18.4027"></a><span id="l18.4027">     rv = CopyUTF16toMUTF7(PromiseFlatString(chvalue), newTrashNameUtf7);</span>
<a href="#l18.4028"></a><span id="l18.4028" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l18.4029"></a><span id="l18.4029" class="difflineminus">-    {</span>
<a href="#l18.4030"></a><span id="l18.4030" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l18.4031"></a><span id="l18.4031">       nsCOMPtr&lt;nsIMsgFolder&gt; newTrashFolder;</span>
<a href="#l18.4032"></a><span id="l18.4032">       rv = GetFolder(newTrashNameUtf7, getter_AddRefs(newTrashFolder));</span>
<a href="#l18.4033"></a><span id="l18.4033">       if (NS_SUCCEEDED(rv) &amp;&amp; newTrashFolder)</span>
<a href="#l18.4034"></a><span id="l18.4034">         newTrashFolder-&gt;SetFlag(nsMsgFolderFlags::Trash);</span>
<a href="#l18.4035"></a><span id="l18.4035">     }</span>
<a href="#l18.4036"></a><span id="l18.4036">   }</span>
<a href="#l18.4037"></a><span id="l18.4037"> </span>
<a href="#l18.4038"></a><span id="l18.4038">   return SetUnicharValue(PREF_TRASH_FOLDER_PATH, chvalue);</span>
<a href="#l18.4039"></a><span id="l18.4039"> }</span>
<a href="#l18.4040"></a><span id="l18.4040"> </span>
<a href="#l18.4041"></a><span id="l18.4041"> NS_IMETHODIMP</span>
<a href="#l18.4042"></a><span id="l18.4042"> nsImapIncomingServer::GetMsgFolderFromURI(nsIMsgFolder *aFolderResource,</span>
<a href="#l18.4043"></a><span id="l18.4043" class="difflineminus">-                                          const nsACString&amp; aURI,</span>
<a href="#l18.4044"></a><span id="l18.4044" class="difflineminus">-                                          nsIMsgFolder **aFolder)</span>
<a href="#l18.4045"></a><span id="l18.4045" class="difflineminus">-{</span>
<a href="#l18.4046"></a><span id="l18.4046" class="difflineplus">+                                          const nsACString &amp;aURI,</span>
<a href="#l18.4047"></a><span id="l18.4047" class="difflineplus">+                                          nsIMsgFolder **aFolder) {</span>
<a href="#l18.4048"></a><span id="l18.4048">   nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l18.4049"></a><span id="l18.4049">   bool namespacePrefixAdded = false;</span>
<a href="#l18.4050"></a><span id="l18.4050">   nsCString folderUriWithNamespace;</span>
<a href="#l18.4051"></a><span id="l18.4051"> </span>
<a href="#l18.4052"></a><span id="l18.4052" class="difflineplus">+  // clang-format off</span>
<a href="#l18.4053"></a><span id="l18.4053">   // Check if the folder exists as is...</span>
<a href="#l18.4054"></a><span id="l18.4054">   nsresult rv = GetExistingMsgFolder(aURI, folderUriWithNamespace,</span>
<a href="#l18.4055"></a><span id="l18.4055">                                      namespacePrefixAdded, false,</span>
<a href="#l18.4056"></a><span id="l18.4056">                                      getter_AddRefs(msgFolder));</span>
<a href="#l18.4057"></a><span id="l18.4057"> </span>
<a href="#l18.4058"></a><span id="l18.4058">   // Or try again with a case-insensitive lookup</span>
<a href="#l18.4059"></a><span id="l18.4059">   if (NS_FAILED(rv) || !msgFolder)</span>
<a href="#l18.4060"></a><span id="l18.4060">     rv = GetExistingMsgFolder(aURI, folderUriWithNamespace,</span>
<a href="#l18.4061"></a><span id="l18.4061">                               namespacePrefixAdded, true,</span>
<a href="#l18.4062"></a><span id="l18.4062">                               getter_AddRefs(msgFolder));</span>
<a href="#l18.4063"></a><span id="l18.4063" class="difflineplus">+  // clang-format on</span>
<a href="#l18.4064"></a><span id="l18.4064"> </span>
<a href="#l18.4065"></a><span id="l18.4065">   if (NS_FAILED(rv) || !msgFolder) {</span>
<a href="#l18.4066"></a><span id="l18.4066">     // we didn't find the folder so we will have to create a new one.</span>
<a href="#l18.4067"></a><span id="l18.4067" class="difflineminus">-    if (namespacePrefixAdded)</span>
<a href="#l18.4068"></a><span id="l18.4068" class="difflineminus">-    {</span>
<a href="#l18.4069"></a><span id="l18.4069" class="difflineplus">+    if (namespacePrefixAdded) {</span>
<a href="#l18.4070"></a><span id="l18.4070">       nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l18.4071"></a><span id="l18.4071">       rv = GetOrCreateFolder(folderUriWithNamespace, getter_AddRefs(folder));</span>
<a href="#l18.4072"></a><span id="l18.4072">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.4073"></a><span id="l18.4073">       msgFolder = folder;</span>
<a href="#l18.4074"></a><span id="l18.4074" class="difflineminus">-    }</span>
<a href="#l18.4075"></a><span id="l18.4075" class="difflineminus">-    else</span>
<a href="#l18.4076"></a><span id="l18.4076" class="difflineplus">+    } else</span>
<a href="#l18.4077"></a><span id="l18.4077">       msgFolder = aFolderResource;</span>
<a href="#l18.4078"></a><span id="l18.4078">   }</span>
<a href="#l18.4079"></a><span id="l18.4079"> </span>
<a href="#l18.4080"></a><span id="l18.4080">   msgFolder.forget(aFolder);</span>
<a href="#l18.4081"></a><span id="l18.4081">   return (aFolder ? NS_OK : NS_ERROR_FAILURE);</span>
<a href="#l18.4082"></a><span id="l18.4082"> }</span>
<a href="#l18.4083"></a><span id="l18.4083"> </span>
<a href="#l18.4084"></a><span id="l18.4084" class="difflineminus">-nsresult</span>
<a href="#l18.4085"></a><span id="l18.4085" class="difflineminus">-nsImapIncomingServer::GetExistingMsgFolder(const nsACString&amp; aURI,</span>
<a href="#l18.4086"></a><span id="l18.4086" class="difflineminus">-                                           nsACString&amp; aFolderUriWithNamespace,</span>
<a href="#l18.4087"></a><span id="l18.4087" class="difflineminus">-                                           bool&amp; aNamespacePrefixAdded,</span>
<a href="#l18.4088"></a><span id="l18.4088" class="difflineminus">-                                           bool aCaseInsensitive,</span>
<a href="#l18.4089"></a><span id="l18.4089" class="difflineminus">-                                           nsIMsgFolder **aFolder)</span>
<a href="#l18.4090"></a><span id="l18.4090" class="difflineminus">-{</span>
<a href="#l18.4091"></a><span id="l18.4091" class="difflineplus">+nsresult nsImapIncomingServer::GetExistingMsgFolder(</span>
<a href="#l18.4092"></a><span id="l18.4092" class="difflineplus">+    const nsACString &amp;aURI, nsACString &amp;aFolderUriWithNamespace,</span>
<a href="#l18.4093"></a><span id="l18.4093" class="difflineplus">+    bool &amp;aNamespacePrefixAdded, bool aCaseInsensitive,</span>
<a href="#l18.4094"></a><span id="l18.4094" class="difflineplus">+    nsIMsgFolder **aFolder) {</span>
<a href="#l18.4095"></a><span id="l18.4095">   nsCOMPtr&lt;nsIMsgFolder&gt; rootMsgFolder;</span>
<a href="#l18.4096"></a><span id="l18.4096">   nsresult rv = GetRootMsgFolder(getter_AddRefs(rootMsgFolder));</span>
<a href="#l18.4097"></a><span id="l18.4097">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.4098"></a><span id="l18.4098"> </span>
<a href="#l18.4099"></a><span id="l18.4099">   aNamespacePrefixAdded = false;</span>
<a href="#l18.4100"></a><span id="l18.4100">   // Check if the folder exists as is...Even if we have a personal namespace,</span>
<a href="#l18.4101"></a><span id="l18.4101">   // it might be in another namespace (e.g., shared) and this will catch that.</span>
<a href="#l18.4102"></a><span id="l18.4102">   rv = rootMsgFolder-&gt;GetChildWithURI(aURI, true, aCaseInsensitive, aFolder);</span>
<a href="#l18.4103"></a><span id="l18.4103"> </span>
<a href="#l18.4104"></a><span id="l18.4104">   // If we couldn't find the folder as is, check if we need to prepend the</span>
<a href="#l18.4105"></a><span id="l18.4105">   // personal namespace</span>
<a href="#l18.4106"></a><span id="l18.4106" class="difflineminus">-  if (!*aFolder)</span>
<a href="#l18.4107"></a><span id="l18.4107" class="difflineminus">-  {</span>
<a href="#l18.4108"></a><span id="l18.4108" class="difflineplus">+  if (!*aFolder) {</span>
<a href="#l18.4109"></a><span id="l18.4109">     GetUriWithNamespacePrefixIfNecessary(kPersonalNamespace, aURI,</span>
<a href="#l18.4110"></a><span id="l18.4110">                                          aFolderUriWithNamespace);</span>
<a href="#l18.4111"></a><span id="l18.4111" class="difflineminus">-    if (!aFolderUriWithNamespace.IsEmpty())</span>
<a href="#l18.4112"></a><span id="l18.4112" class="difflineminus">-    {</span>
<a href="#l18.4113"></a><span id="l18.4113" class="difflineplus">+    if (!aFolderUriWithNamespace.IsEmpty()) {</span>
<a href="#l18.4114"></a><span id="l18.4114">       aNamespacePrefixAdded = true;</span>
<a href="#l18.4115"></a><span id="l18.4115">       rv = rootMsgFolder-&gt;GetChildWithURI(aFolderUriWithNamespace, true,</span>
<a href="#l18.4116"></a><span id="l18.4116">                                           aCaseInsensitive, aFolder);</span>
<a href="#l18.4117"></a><span id="l18.4117">     }</span>
<a href="#l18.4118"></a><span id="l18.4118">   }</span>
<a href="#l18.4119"></a><span id="l18.4119">   return rv;</span>
<a href="#l18.4120"></a><span id="l18.4120"> }</span>
<a href="#l18.4121"></a><span id="l18.4121"> </span>
<a href="#l18.4122"></a><span id="l18.4122"> NS_IMETHODIMP</span>
<a href="#l18.4123"></a><span id="l18.4123" class="difflineminus">-nsImapIncomingServer::CramMD5Hash(const char *decodedChallenge, const char *key, char **result)</span>
<a href="#l18.4124"></a><span id="l18.4124" class="difflineminus">-{</span>
<a href="#l18.4125"></a><span id="l18.4125" class="difflineplus">+nsImapIncomingServer::CramMD5Hash(const char *decodedChallenge, const char *key,</span>
<a href="#l18.4126"></a><span id="l18.4126" class="difflineplus">+                                  char **result) {</span>
<a href="#l18.4127"></a><span id="l18.4127">   NS_ENSURE_ARG_POINTER(decodedChallenge);</span>
<a href="#l18.4128"></a><span id="l18.4128">   NS_ENSURE_ARG_POINTER(key);</span>
<a href="#l18.4129"></a><span id="l18.4129"> </span>
<a href="#l18.4130"></a><span id="l18.4130">   unsigned char resultDigest[DIGEST_LENGTH];</span>
<a href="#l18.4131"></a><span id="l18.4131" class="difflineminus">-  nsresult rv = MSGCramMD5(decodedChallenge, strlen(decodedChallenge), key, strlen(key), resultDigest);</span>
<a href="#l18.4132"></a><span id="l18.4132" class="difflineplus">+  nsresult rv = MSGCramMD5(decodedChallenge, strlen(decodedChallenge), key,</span>
<a href="#l18.4133"></a><span id="l18.4133" class="difflineplus">+                           strlen(key), resultDigest);</span>
<a href="#l18.4134"></a><span id="l18.4134">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.4135"></a><span id="l18.4135" class="difflineminus">-  *result = (char *) malloc(DIGEST_LENGTH);</span>
<a href="#l18.4136"></a><span id="l18.4136" class="difflineminus">-  if (*result)</span>
<a href="#l18.4137"></a><span id="l18.4137" class="difflineminus">-    memcpy(*result, resultDigest, DIGEST_LENGTH);</span>
<a href="#l18.4138"></a><span id="l18.4138" class="difflineplus">+  *result = (char *)malloc(DIGEST_LENGTH);</span>
<a href="#l18.4139"></a><span id="l18.4139" class="difflineplus">+  if (*result) memcpy(*result, resultDigest, DIGEST_LENGTH);</span>
<a href="#l18.4140"></a><span id="l18.4140">   return (*result) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.4141"></a><span id="l18.4141"> }</span>
<a href="#l18.4142"></a><span id="l18.4142"> </span>
<a href="#l18.4143"></a><span id="l18.4143"> NS_IMETHODIMP</span>
<a href="#l18.4144"></a><span id="l18.4144" class="difflineminus">-nsImapIncomingServer::GetLoginUsername(nsACString &amp;aLoginUsername)</span>
<a href="#l18.4145"></a><span id="l18.4145" class="difflineminus">-{</span>
<a href="#l18.4146"></a><span id="l18.4146" class="difflineplus">+nsImapIncomingServer::GetLoginUsername(nsACString &amp;aLoginUsername) {</span>
<a href="#l18.4147"></a><span id="l18.4147">   return GetRealUsername(aLoginUsername);</span>
<a href="#l18.4148"></a><span id="l18.4148"> }</span>
<a href="#l18.4149"></a><span id="l18.4149"> </span>
<a href="#l18.4150"></a><span id="l18.4150"> NS_IMETHODIMP</span>
<a href="#l18.4151"></a><span id="l18.4151" class="difflineminus">-nsImapIncomingServer::GetOriginalUsername(nsACString &amp;aUsername)</span>
<a href="#l18.4152"></a><span id="l18.4152" class="difflineminus">-{</span>
<a href="#l18.4153"></a><span id="l18.4153" class="difflineplus">+nsImapIncomingServer::GetOriginalUsername(nsACString &amp;aUsername) {</span>
<a href="#l18.4154"></a><span id="l18.4154">   return GetUsername(aUsername);</span>
<a href="#l18.4155"></a><span id="l18.4155"> }</span>
<a href="#l18.4156"></a><span id="l18.4156"> </span>
<a href="#l18.4157"></a><span id="l18.4157"> NS_IMETHODIMP</span>
<a href="#l18.4158"></a><span id="l18.4158" class="difflineminus">-nsImapIncomingServer::GetServerKey(nsACString &amp;aServerKey)</span>
<a href="#l18.4159"></a><span id="l18.4159" class="difflineminus">-{</span>
<a href="#l18.4160"></a><span id="l18.4160" class="difflineplus">+nsImapIncomingServer::GetServerKey(nsACString &amp;aServerKey) {</span>
<a href="#l18.4161"></a><span id="l18.4161">   return GetKey(aServerKey);</span>
<a href="#l18.4162"></a><span id="l18.4162"> }</span>
<a href="#l18.4163"></a><span id="l18.4163"> </span>
<a href="#l18.4164"></a><span id="l18.4164"> NS_IMETHODIMP</span>
<a href="#l18.4165"></a><span id="l18.4165" class="difflineminus">-nsImapIncomingServer::GetServerPassword(nsAString &amp;aPassword)</span>
<a href="#l18.4166"></a><span id="l18.4166" class="difflineminus">-{</span>
<a href="#l18.4167"></a><span id="l18.4167" class="difflineplus">+nsImapIncomingServer::GetServerPassword(nsAString &amp;aPassword) {</span>
<a href="#l18.4168"></a><span id="l18.4168">   return GetPassword(aPassword);</span>
<a href="#l18.4169"></a><span id="l18.4169"> }</span>
<a href="#l18.4170"></a><span id="l18.4170"> </span>
<a href="#l18.4171"></a><span id="l18.4171"> NS_IMETHODIMP</span>
<a href="#l18.4172"></a><span id="l18.4172" class="difflineminus">-nsImapIncomingServer::RemoveServerConnection(nsIImapProtocol* aProtocol)</span>
<a href="#l18.4173"></a><span id="l18.4173" class="difflineminus">-{</span>
<a href="#l18.4174"></a><span id="l18.4174" class="difflineplus">+nsImapIncomingServer::RemoveServerConnection(nsIImapProtocol *aProtocol) {</span>
<a href="#l18.4175"></a><span id="l18.4175">   return RemoveConnection(aProtocol);</span>
<a href="#l18.4176"></a><span id="l18.4176"> }</span>
<a href="#l18.4177"></a><span id="l18.4177"> </span>
<a href="#l18.4178"></a><span id="l18.4178"> NS_IMETHODIMP</span>
<a href="#l18.4179"></a><span id="l18.4179" class="difflineminus">-nsImapIncomingServer::GetServerShuttingDown(bool* aShuttingDown)</span>
<a href="#l18.4180"></a><span id="l18.4180" class="difflineminus">-{</span>
<a href="#l18.4181"></a><span id="l18.4181" class="difflineplus">+nsImapIncomingServer::GetServerShuttingDown(bool *aShuttingDown) {</span>
<a href="#l18.4182"></a><span id="l18.4182">   return GetShuttingDown(aShuttingDown);</span>
<a href="#l18.4183"></a><span id="l18.4183"> }</span>
<a href="#l18.4184"></a><span id="l18.4184"> </span>
<a href="#l18.4185"></a><span id="l18.4185"> NS_IMETHODIMP</span>
<a href="#l18.4186"></a><span id="l18.4186" class="difflineminus">-nsImapIncomingServer::ResetServerConnection(const nsACString&amp; aFolderName)</span>
<a href="#l18.4187"></a><span id="l18.4187" class="difflineminus">-{</span>
<a href="#l18.4188"></a><span id="l18.4188" class="difflineplus">+nsImapIncomingServer::ResetServerConnection(const nsACString &amp;aFolderName) {</span>
<a href="#l18.4189"></a><span id="l18.4189">   return ResetConnection(aFolderName);</span>
<a href="#l18.4190"></a><span id="l18.4190"> }</span>
<a href="#l18.4191"></a><span id="l18.4191"> </span>
<a href="#l18.4192"></a><span id="l18.4192"> NS_IMETHODIMP</span>
<a href="#l18.4193"></a><span id="l18.4193" class="difflineminus">-nsImapIncomingServer::SetServerDoingLsub(bool aDoingLsub)</span>
<a href="#l18.4194"></a><span id="l18.4194" class="difflineminus">-{</span>
<a href="#l18.4195"></a><span id="l18.4195" class="difflineplus">+nsImapIncomingServer::SetServerDoingLsub(bool aDoingLsub) {</span>
<a href="#l18.4196"></a><span id="l18.4196">   return SetDoingLsub(aDoingLsub);</span>
<a href="#l18.4197"></a><span id="l18.4197"> }</span>
<a href="#l18.4198"></a><span id="l18.4198"> </span>
<a href="#l18.4199"></a><span id="l18.4199"> NS_IMETHODIMP</span>
<a href="#l18.4200"></a><span id="l18.4200" class="difflineminus">-nsImapIncomingServer::SetServerForceSelect(const nsACString &amp;aForceSelect)</span>
<a href="#l18.4201"></a><span id="l18.4201" class="difflineminus">-{</span>
<a href="#l18.4202"></a><span id="l18.4202" class="difflineplus">+nsImapIncomingServer::SetServerForceSelect(const nsACString &amp;aForceSelect) {</span>
<a href="#l18.4203"></a><span id="l18.4203">   return SetForceSelect(aForceSelect);</span>
<a href="#l18.4204"></a><span id="l18.4204"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/mailnews/imap/src/nsImapIncomingServer.h</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapIncomingServer.h</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -14,119 +14,127 @@</span>
<a href="#l19.4"></a><span id="l19.4"> #include &quot;nsIStringBundle.h&quot;</span>
<a href="#l19.5"></a><span id="l19.5"> #include &quot;nsISubscribableServer.h&quot;</span>
<a href="#l19.6"></a><span id="l19.6"> #include &quot;nsIUrlListener.h&quot;</span>
<a href="#l19.7"></a><span id="l19.7"> #include &quot;nsIMsgImapMailFolder.h&quot;</span>
<a href="#l19.8"></a><span id="l19.8"> #include &quot;nsCOMArray.h&quot;</span>
<a href="#l19.9"></a><span id="l19.9"> #include &quot;nsTArray.h&quot;</span>
<a href="#l19.10"></a><span id="l19.10"> #include &quot;mozilla/Mutex.h&quot;</span>
<a href="#l19.11"></a><span id="l19.11"> </span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-</span>
<a href="#l19.13"></a><span id="l19.13"> /* get some implementation from nsMsgIncomingServer */</span>
<a href="#l19.14"></a><span id="l19.14"> class nsImapIncomingServer : public nsMsgIncomingServer,</span>
<a href="#l19.15"></a><span id="l19.15">                              public nsIImapIncomingServer,</span>
<a href="#l19.16"></a><span id="l19.16">                              public nsIImapServerSink,</span>
<a href="#l19.17"></a><span id="l19.17">                              public nsISubscribableServer,</span>
<a href="#l19.18"></a><span id="l19.18" class="difflineminus">-                             public nsIUrlListener</span>
<a href="#l19.19"></a><span id="l19.19" class="difflineminus">-{</span>
<a href="#l19.20"></a><span id="l19.20" class="difflineminus">-public:</span>
<a href="#l19.21"></a><span id="l19.21" class="difflineplus">+                             public nsIUrlListener {</span>
<a href="#l19.22"></a><span id="l19.22" class="difflineplus">+ public:</span>
<a href="#l19.23"></a><span id="l19.23">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l19.24"></a><span id="l19.24"> </span>
<a href="#l19.25"></a><span id="l19.25">   nsImapIncomingServer();</span>
<a href="#l19.26"></a><span id="l19.26"> </span>
<a href="#l19.27"></a><span id="l19.27">   // overriding nsMsgIncomingServer methods</span>
<a href="#l19.28"></a><span id="l19.28" class="difflineminus">-  NS_IMETHOD SetKey(const nsACString&amp; aKey) override;  // override nsMsgIncomingServer's implementation...</span>
<a href="#l19.29"></a><span id="l19.29" class="difflineminus">-  NS_IMETHOD GetLocalStoreType(nsACString&amp; type) override;</span>
<a href="#l19.30"></a><span id="l19.30" class="difflineminus">-  NS_IMETHOD GetLocalDatabaseType(nsACString&amp; type) override;</span>
<a href="#l19.31"></a><span id="l19.31" class="difflineplus">+  NS_IMETHOD SetKey(const nsACString &amp;aKey)</span>
<a href="#l19.32"></a><span id="l19.32" class="difflineplus">+      override;  // override nsMsgIncomingServer's implementation...</span>
<a href="#l19.33"></a><span id="l19.33" class="difflineplus">+  NS_IMETHOD GetLocalStoreType(nsACString &amp;type) override;</span>
<a href="#l19.34"></a><span id="l19.34" class="difflineplus">+  NS_IMETHOD GetLocalDatabaseType(nsACString &amp;type) override;</span>
<a href="#l19.35"></a><span id="l19.35"> </span>
<a href="#l19.36"></a><span id="l19.36">   NS_DECL_NSIIMAPINCOMINGSERVER</span>
<a href="#l19.37"></a><span id="l19.37">   NS_DECL_NSIIMAPSERVERSINK</span>
<a href="#l19.38"></a><span id="l19.38">   NS_DECL_NSISUBSCRIBABLESERVER</span>
<a href="#l19.39"></a><span id="l19.39">   NS_DECL_NSIURLLISTENER</span>
<a href="#l19.40"></a><span id="l19.40"> </span>
<a href="#l19.41"></a><span id="l19.41">   NS_IMETHOD PerformBiff(nsIMsgWindow *aMsgWindow) override;</span>
<a href="#l19.42"></a><span id="l19.42">   NS_IMETHOD PerformExpand(nsIMsgWindow *aMsgWindow) override;</span>
<a href="#l19.43"></a><span id="l19.43">   NS_IMETHOD CloseCachedConnections() override;</span>
<a href="#l19.44"></a><span id="l19.44" class="difflineminus">-  NS_IMETHOD GetConstructedPrettyName(nsAString&amp; retval) override;</span>
<a href="#l19.45"></a><span id="l19.45" class="difflineplus">+  NS_IMETHOD GetConstructedPrettyName(nsAString &amp;retval) override;</span>
<a href="#l19.46"></a><span id="l19.46">   NS_IMETHOD GetCanBeDefaultServer(bool *canBeDefaultServer) override;</span>
<a href="#l19.47"></a><span id="l19.47" class="difflineminus">-  NS_IMETHOD GetCanCompactFoldersOnServer(bool *canCompactFoldersOnServer) override;</span>
<a href="#l19.48"></a><span id="l19.48" class="difflineplus">+  NS_IMETHOD GetCanCompactFoldersOnServer(</span>
<a href="#l19.49"></a><span id="l19.49" class="difflineplus">+      bool *canCompactFoldersOnServer) override;</span>
<a href="#l19.50"></a><span id="l19.50">   NS_IMETHOD GetCanUndoDeleteOnServer(bool *canUndoDeleteOnServer) override;</span>
<a href="#l19.51"></a><span id="l19.51">   NS_IMETHOD GetCanSearchMessages(bool *canSearchMessages) override;</span>
<a href="#l19.52"></a><span id="l19.52">   NS_IMETHOD GetCanEmptyTrashOnExit(bool *canEmptyTrashOnExit) override;</span>
<a href="#l19.53"></a><span id="l19.53">   NS_IMETHOD GetOfflineSupportLevel(int32_t *aSupportLevel) override;</span>
<a href="#l19.54"></a><span id="l19.54" class="difflineminus">-  NS_IMETHOD GeneratePrettyNameForMigration(nsAString&amp; aPrettyName) override;</span>
<a href="#l19.55"></a><span id="l19.55" class="difflineplus">+  NS_IMETHOD GeneratePrettyNameForMigration(nsAString &amp;aPrettyName) override;</span>
<a href="#l19.56"></a><span id="l19.56">   NS_IMETHOD GetSupportsDiskSpace(bool *aSupportsDiskSpace) override;</span>
<a href="#l19.57"></a><span id="l19.57" class="difflineminus">-  NS_IMETHOD GetCanCreateFoldersOnServer(bool *aCanCreateFoldersOnServer) override;</span>
<a href="#l19.58"></a><span id="l19.58" class="difflineminus">-  NS_IMETHOD GetCanFileMessagesOnServer(bool *aCanFileMessagesOnServer) override;</span>
<a href="#l19.59"></a><span id="l19.59" class="difflineplus">+  NS_IMETHOD GetCanCreateFoldersOnServer(</span>
<a href="#l19.60"></a><span id="l19.60" class="difflineplus">+      bool *aCanCreateFoldersOnServer) override;</span>
<a href="#l19.61"></a><span id="l19.61" class="difflineplus">+  NS_IMETHOD GetCanFileMessagesOnServer(</span>
<a href="#l19.62"></a><span id="l19.62" class="difflineplus">+      bool *aCanFileMessagesOnServer) override;</span>
<a href="#l19.63"></a><span id="l19.63">   NS_IMETHOD GetFilterScope(nsMsgSearchScopeValue *filterScope) override;</span>
<a href="#l19.64"></a><span id="l19.64">   NS_IMETHOD GetSearchScope(nsMsgSearchScopeValue *searchScope) override;</span>
<a href="#l19.65"></a><span id="l19.65" class="difflineminus">-  NS_IMETHOD GetServerRequiresPasswordForBiff(bool *aServerRequiresPasswordForBiff) override;</span>
<a href="#l19.66"></a><span id="l19.66" class="difflineminus">-  NS_IMETHOD OnUserOrHostNameChanged(const nsACString&amp; oldName,</span>
<a href="#l19.67"></a><span id="l19.67" class="difflineminus">-                                     const nsACString&amp; newName,</span>
<a href="#l19.68"></a><span id="l19.68" class="difflineplus">+  NS_IMETHOD GetServerRequiresPasswordForBiff(</span>
<a href="#l19.69"></a><span id="l19.69" class="difflineplus">+      bool *aServerRequiresPasswordForBiff) override;</span>
<a href="#l19.70"></a><span id="l19.70" class="difflineplus">+  NS_IMETHOD OnUserOrHostNameChanged(const nsACString &amp;oldName,</span>
<a href="#l19.71"></a><span id="l19.71" class="difflineplus">+                                     const nsACString &amp;newName,</span>
<a href="#l19.72"></a><span id="l19.72">                                      bool hostnameChanged) override;</span>
<a href="#l19.73"></a><span id="l19.73">   NS_IMETHOD GetNumIdleConnections(int32_t *aNumIdleConnections);</span>
<a href="#l19.74"></a><span id="l19.74">   NS_IMETHOD ForgetSessionPassword() override;</span>
<a href="#l19.75"></a><span id="l19.75">   NS_IMETHOD GetMsgFolderFromURI(nsIMsgFolder *aFolderResource,</span>
<a href="#l19.76"></a><span id="l19.76" class="difflineminus">-                                 const nsACString&amp; aURI,</span>
<a href="#l19.77"></a><span id="l19.77" class="difflineplus">+                                 const nsACString &amp;aURI,</span>
<a href="#l19.78"></a><span id="l19.78">                                  nsIMsgFolder **aFolder) override;</span>
<a href="#l19.79"></a><span id="l19.79">   NS_IMETHOD SetSocketType(int32_t aSocketType) override;</span>
<a href="#l19.80"></a><span id="l19.80">   NS_IMETHOD VerifyLogon(nsIUrlListener *aUrlListener, nsIMsgWindow *aMsgWindow,</span>
<a href="#l19.81"></a><span id="l19.81">                          nsIURI **aURL) override;</span>
<a href="#l19.82"></a><span id="l19.82"> </span>
<a href="#l19.83"></a><span id="l19.83" class="difflineminus">-protected:</span>
<a href="#l19.84"></a><span id="l19.84" class="difflineplus">+ protected:</span>
<a href="#l19.85"></a><span id="l19.85">   virtual ~nsImapIncomingServer();</span>
<a href="#l19.86"></a><span id="l19.86" class="difflineminus">-  nsresult GetFolder(const nsACString&amp; name, nsIMsgFolder** pFolder);</span>
<a href="#l19.87"></a><span id="l19.87" class="difflineplus">+  nsresult GetFolder(const nsACString &amp;name, nsIMsgFolder **pFolder);</span>
<a href="#l19.88"></a><span id="l19.88">   virtual nsresult CreateRootFolderFromUri(const nsCString &amp;serverUri,</span>
<a href="#l19.89"></a><span id="l19.89">                                            nsIMsgFolder **rootFolder) override;</span>
<a href="#l19.90"></a><span id="l19.90">   nsresult ResetFoldersToUnverified(nsIMsgFolder *parentFolder);</span>
<a href="#l19.91"></a><span id="l19.91">   void GetUnverifiedSubFolders(nsIMsgFolder *parentFolder,</span>
<a href="#l19.92"></a><span id="l19.92">                                nsCOMArray&lt;nsIMsgImapMailFolder&gt; &amp;aFoldersArray);</span>
<a href="#l19.93"></a><span id="l19.93">   void GetUnverifiedFolders(nsCOMArray&lt;nsIMsgImapMailFolder&gt; &amp;aFolderArray);</span>
<a href="#l19.94"></a><span id="l19.94">   nsresult DeleteNonVerifiedFolders(nsIMsgFolder *parentFolder);</span>
<a href="#l19.95"></a><span id="l19.95">   bool NoDescendentsAreVerified(nsIMsgFolder *parentFolder);</span>
<a href="#l19.96"></a><span id="l19.96">   bool AllDescendentsAreNoSelect(nsIMsgFolder *parentFolder);</span>
<a href="#l19.97"></a><span id="l19.97"> </span>
<a href="#l19.98"></a><span id="l19.98">   nsresult GetStringBundle();</span>
<a href="#l19.99"></a><span id="l19.99" class="difflineminus">-  static nsresult AlertUser(const nsAString&amp; aString, nsIMsgMailNewsUrl *aUrl);</span>
<a href="#l19.100"></a><span id="l19.100" class="difflineplus">+  static nsresult AlertUser(const nsAString &amp;aString, nsIMsgMailNewsUrl *aUrl);</span>
<a href="#l19.101"></a><span id="l19.101"> </span>
<a href="#l19.102"></a><span id="l19.102" class="difflineminus">-private:</span>
<a href="#l19.103"></a><span id="l19.103" class="difflineplus">+ private:</span>
<a href="#l19.104"></a><span id="l19.104">   nsresult SubscribeToFolder(const char16_t *aName, bool subscribe);</span>
<a href="#l19.105"></a><span id="l19.105" class="difflineminus">-  nsresult GetImapConnection(nsIImapUrl* aImapUrl,</span>
<a href="#l19.106"></a><span id="l19.106" class="difflineminus">-                             nsIImapProtocol** aImapConnection);</span>
<a href="#l19.107"></a><span id="l19.107" class="difflineminus">-  nsresult CreateProtocolInstance(nsIImapProtocol ** aImapConnection);</span>
<a href="#l19.108"></a><span id="l19.108" class="difflineminus">-  nsresult CreateHostSpecificPrefName(const char *prefPrefix, nsAutoCString &amp;prefName);</span>
<a href="#l19.109"></a><span id="l19.109" class="difflineplus">+  nsresult GetImapConnection(nsIImapUrl *aImapUrl,</span>
<a href="#l19.110"></a><span id="l19.110" class="difflineplus">+                             nsIImapProtocol **aImapConnection);</span>
<a href="#l19.111"></a><span id="l19.111" class="difflineplus">+  nsresult CreateProtocolInstance(nsIImapProtocol **aImapConnection);</span>
<a href="#l19.112"></a><span id="l19.112" class="difflineplus">+  nsresult CreateHostSpecificPrefName(const char *prefPrefix,</span>
<a href="#l19.113"></a><span id="l19.113" class="difflineplus">+                                      nsAutoCString &amp;prefName);</span>
<a href="#l19.114"></a><span id="l19.114"> </span>
<a href="#l19.115"></a><span id="l19.115">   nsresult DoomUrlIfChannelHasError(nsIImapUrl *aImapUrl, bool *urlDoomed);</span>
<a href="#l19.116"></a><span id="l19.116" class="difflineminus">-  bool ConnectionTimeOut(nsIImapProtocol* aImapConnection);</span>
<a href="#l19.117"></a><span id="l19.117" class="difflineminus">-  nsresult GetFormattedStringFromName(const nsAString&amp; aValue, const char* aName, nsAString&amp; aResult);</span>
<a href="#l19.118"></a><span id="l19.118" class="difflineplus">+  bool ConnectionTimeOut(nsIImapProtocol *aImapConnection);</span>
<a href="#l19.119"></a><span id="l19.119" class="difflineplus">+  nsresult GetFormattedStringFromName(const nsAString &amp;aValue,</span>
<a href="#l19.120"></a><span id="l19.120" class="difflineplus">+                                      const char *aName, nsAString &amp;aResult);</span>
<a href="#l19.121"></a><span id="l19.121">   nsresult GetPrefForServerAttribute(const char *prefSuffix, bool *prefValue);</span>
<a href="#l19.122"></a><span id="l19.122" class="difflineminus">-  bool CheckSpecialFolder(nsCString &amp;folderUri,</span>
<a href="#l19.123"></a><span id="l19.123" class="difflineminus">-                          uint32_t folderFlag, nsCString &amp;existingUri);</span>
<a href="#l19.124"></a><span id="l19.124" class="difflineplus">+  bool CheckSpecialFolder(nsCString &amp;folderUri, uint32_t folderFlag,</span>
<a href="#l19.125"></a><span id="l19.125" class="difflineplus">+                          nsCString &amp;existingUri);</span>
<a href="#l19.126"></a><span id="l19.126"> </span>
<a href="#l19.127"></a><span id="l19.127">   nsCOMArray&lt;nsIImapProtocol&gt; m_connectionCache;</span>
<a href="#l19.128"></a><span id="l19.128">   nsCOMArray&lt;nsIImapUrl&gt; m_urlQueue;</span>
<a href="#l19.129"></a><span id="l19.129" class="difflineminus">-  nsCOMPtr&lt;nsIStringBundle&gt;m_stringBundle;</span>
<a href="#l19.130"></a><span id="l19.130" class="difflineminus">-  nsCOMArray&lt;nsIMsgFolder&gt; m_subscribeFolders; // used to keep folder resources around while subscribe UI is up.</span>
<a href="#l19.131"></a><span id="l19.131" class="difflineminus">-  nsCOMArray&lt;nsIMsgImapMailFolder&gt; m_foldersToStat; // folders to check for new mail with Status</span>
<a href="#l19.132"></a><span id="l19.132" class="difflineminus">-  nsTArray&lt;nsISupports*&gt; m_urlConsumers;</span>
<a href="#l19.133"></a><span id="l19.133" class="difflineplus">+  nsCOMPtr&lt;nsIStringBundle&gt; m_stringBundle;</span>
<a href="#l19.134"></a><span id="l19.134" class="difflineplus">+  nsCOMArray&lt;nsIMsgFolder&gt;</span>
<a href="#l19.135"></a><span id="l19.135" class="difflineplus">+      m_subscribeFolders;  // used to keep folder resources around while</span>
<a href="#l19.136"></a><span id="l19.136" class="difflineplus">+                           // subscribe UI is up.</span>
<a href="#l19.137"></a><span id="l19.137" class="difflineplus">+  nsCOMArray&lt;nsIMsgImapMailFolder&gt;</span>
<a href="#l19.138"></a><span id="l19.138" class="difflineplus">+      m_foldersToStat;  // folders to check for new mail with Status</span>
<a href="#l19.139"></a><span id="l19.139" class="difflineplus">+  nsTArray&lt;nsISupports *&gt; m_urlConsumers;</span>
<a href="#l19.140"></a><span id="l19.140">   eIMAPCapabilityFlags m_capability;</span>
<a href="#l19.141"></a><span id="l19.141">   nsCString m_manageMailAccountUrl;</span>
<a href="#l19.142"></a><span id="l19.142">   bool m_userAuthenticated;</span>
<a href="#l19.143"></a><span id="l19.143">   bool mDoingSubscribeDialog;</span>
<a href="#l19.144"></a><span id="l19.144">   bool mDoingLsub;</span>
<a href="#l19.145"></a><span id="l19.145">   bool m_shuttingDown;</span>
<a href="#l19.146"></a><span id="l19.146"> </span>
<a href="#l19.147"></a><span id="l19.147">   mozilla::Mutex mLock;</span>
<a href="#l19.148"></a><span id="l19.148">   // subscribe dialog stuff</span>
<a href="#l19.149"></a><span id="l19.149" class="difflineminus">-  nsresult AddFolderToSubscribeDialog(const char *parentUri, const char *uri,const char *folderName);</span>
<a href="#l19.150"></a><span id="l19.150" class="difflineminus">-  nsCOMPtr &lt;nsISubscribableServer&gt; mInner;</span>
<a href="#l19.151"></a><span id="l19.151" class="difflineplus">+  nsresult AddFolderToSubscribeDialog(const char *parentUri, const char *uri,</span>
<a href="#l19.152"></a><span id="l19.152" class="difflineplus">+                                      const char *folderName);</span>
<a href="#l19.153"></a><span id="l19.153" class="difflineplus">+  nsCOMPtr&lt;nsISubscribableServer&gt; mInner;</span>
<a href="#l19.154"></a><span id="l19.154">   nsresult EnsureInner();</span>
<a href="#l19.155"></a><span id="l19.155">   nsresult ClearInner();</span>
<a href="#l19.156"></a><span id="l19.156"> </span>
<a href="#l19.157"></a><span id="l19.157">   // Utility function for checking folder existence</span>
<a href="#l19.158"></a><span id="l19.158" class="difflineminus">-  nsresult GetExistingMsgFolder(const nsACString&amp; aURI,</span>
<a href="#l19.159"></a><span id="l19.159" class="difflineminus">-                                nsACString&amp; folderUriWithNamespace,</span>
<a href="#l19.160"></a><span id="l19.160" class="difflineminus">-                                bool&amp; namespacePrefixAdded,</span>
<a href="#l19.161"></a><span id="l19.161" class="difflineminus">-                                bool caseInsensitive,</span>
<a href="#l19.162"></a><span id="l19.162" class="difflineminus">-                                nsIMsgFolder **aFolder);</span>
<a href="#l19.163"></a><span id="l19.163" class="difflineplus">+  nsresult GetExistingMsgFolder(const nsACString &amp;aURI,</span>
<a href="#l19.164"></a><span id="l19.164" class="difflineplus">+                                nsACString &amp;folderUriWithNamespace,</span>
<a href="#l19.165"></a><span id="l19.165" class="difflineplus">+                                bool &amp;namespacePrefixAdded,</span>
<a href="#l19.166"></a><span id="l19.166" class="difflineplus">+                                bool caseInsensitive, nsIMsgFolder **aFolder);</span>
<a href="#l19.167"></a><span id="l19.167"> };</span>
<a href="#l19.168"></a><span id="l19.168"> </span>
<a href="#l19.169"></a><span id="l19.169"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -45,17 +45,17 @@</span>
<a href="#l20.4"></a><span id="l20.4"> #include &quot;nsUnicharUtils.h&quot;</span>
<a href="#l20.5"></a><span id="l20.5"> #include &quot;nsIImapFlagAndUidState.h&quot;</span>
<a href="#l20.6"></a><span id="l20.6"> #include &quot;nsIImapHeaderXferInfo.h&quot;</span>
<a href="#l20.7"></a><span id="l20.7"> #include &quot;nsIMessenger.h&quot;</span>
<a href="#l20.8"></a><span id="l20.8"> #include &quot;nsIMsgSearchAdapter.h&quot;</span>
<a href="#l20.9"></a><span id="l20.9"> #include &quot;nsIImapMockChannel.h&quot;</span>
<a href="#l20.10"></a><span id="l20.10"> #include &quot;nsIProgressEventSink.h&quot;</span>
<a href="#l20.11"></a><span id="l20.11"> #include &quot;nsIMsgWindow.h&quot;</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineminus">-#include &quot;nsIMsgFolder.h&quot; // TO include biffState enum. Change to bool later...</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+#include &quot;nsIMsgFolder.h&quot;  // TO include biffState enum. Change to bool later...</span>
<a href="#l20.14"></a><span id="l20.14"> #include &quot;nsIMsgLocalMailFolder.h&quot;</span>
<a href="#l20.15"></a><span id="l20.15"> #include &quot;nsIMsgOfflineImapOperation.h&quot;</span>
<a href="#l20.16"></a><span id="l20.16"> #include &quot;nsImapOfflineSync.h&quot;</span>
<a href="#l20.17"></a><span id="l20.17"> #include &quot;nsIImapMailFolderSink.h&quot;</span>
<a href="#l20.18"></a><span id="l20.18"> #include &quot;nsIImapServerSink.h&quot;</span>
<a href="#l20.19"></a><span id="l20.19"> #include &quot;nsIMsgAccountManager.h&quot;</span>
<a href="#l20.20"></a><span id="l20.20"> #include &quot;nsQuickSort.h&quot;</span>
<a href="#l20.21"></a><span id="l20.21"> #include &quot;nsIImapMockChannel.h&quot;</span>
<a href="#l20.22"></a><span id="l20.22" class="difflineat">@@ -93,259 +93,245 @@</span>
<a href="#l20.23"></a><span id="l20.23"> </span>
<a href="#l20.24"></a><span id="l20.24"> static NS_DEFINE_CID(kParseMailMsgStateCID, NS_PARSEMAILMSGSTATE_CID);</span>
<a href="#l20.25"></a><span id="l20.25"> static NS_DEFINE_CID(kCImapHostSessionList, NS_IIMAPHOSTSESSIONLIST_CID);</span>
<a href="#l20.26"></a><span id="l20.26"> </span>
<a href="#l20.27"></a><span id="l20.27"> #define MAILNEWS_CUSTOM_HEADERS &quot;mailnews.customHeaders&quot;</span>
<a href="#l20.28"></a><span id="l20.28"> </span>
<a href="#l20.29"></a><span id="l20.29"> using namespace mozilla;</span>
<a href="#l20.30"></a><span id="l20.30"> </span>
<a href="#l20.31"></a><span id="l20.31" class="difflineminus">-extern LazyLogModule gAutoSyncLog;    // defined in nsAutoSyncManager.cpp</span>
<a href="#l20.32"></a><span id="l20.32" class="difflineminus">-extern LazyLogModule IMAP;            // defined in nsImapProtocol.cpp</span>
<a href="#l20.33"></a><span id="l20.33" class="difflineminus">-extern LazyLogModule IMAP_CS;         // For CONDSTORE, defined in nsImapProtocol.cpp</span>
<a href="#l20.34"></a><span id="l20.34" class="difflineminus">-extern LazyLogModule FILTERLOGMODULE; // defined in nsMsgFilterService.cpp</span>
<a href="#l20.35"></a><span id="l20.35" class="difflineminus">-LazyLogModule IMAP_KW(&quot;IMAP_KW&quot;);     // for logging keyword (tag) processing</span>
<a href="#l20.36"></a><span id="l20.36" class="difflineplus">+extern LazyLogModule gAutoSyncLog;  // defined in nsAutoSyncManager.cpp</span>
<a href="#l20.37"></a><span id="l20.37" class="difflineplus">+extern LazyLogModule IMAP;          // defined in nsImapProtocol.cpp</span>
<a href="#l20.38"></a><span id="l20.38" class="difflineplus">+extern LazyLogModule IMAP_CS;  // For CONDSTORE, defined in nsImapProtocol.cpp</span>
<a href="#l20.39"></a><span id="l20.39" class="difflineplus">+extern LazyLogModule FILTERLOGMODULE;  // defined in nsMsgFilterService.cpp</span>
<a href="#l20.40"></a><span id="l20.40" class="difflineplus">+LazyLogModule IMAP_KW(&quot;IMAP_KW&quot;);      // for logging keyword (tag) processing</span>
<a href="#l20.41"></a><span id="l20.41"> </span>
<a href="#l20.42"></a><span id="l20.42"> /*</span>
<a href="#l20.43"></a><span id="l20.43">     Copies the contents of srcDir into destDir.</span>
<a href="#l20.44"></a><span id="l20.44">     destDir will be created if it doesn't exist.</span>
<a href="#l20.45"></a><span id="l20.45"> */</span>
<a href="#l20.46"></a><span id="l20.46"> </span>
<a href="#l20.47"></a><span id="l20.47" class="difflineminus">-static</span>
<a href="#l20.48"></a><span id="l20.48" class="difflineminus">-nsresult RecursiveCopy(nsIFile* srcDir, nsIFile* destDir)</span>
<a href="#l20.49"></a><span id="l20.49" class="difflineminus">-{</span>
<a href="#l20.50"></a><span id="l20.50" class="difflineplus">+static nsresult RecursiveCopy(nsIFile *srcDir, nsIFile *destDir) {</span>
<a href="#l20.51"></a><span id="l20.51">   nsresult rv;</span>
<a href="#l20.52"></a><span id="l20.52">   bool isDir;</span>
<a href="#l20.53"></a><span id="l20.53"> </span>
<a href="#l20.54"></a><span id="l20.54">   rv = srcDir-&gt;IsDirectory(&amp;isDir);</span>
<a href="#l20.55"></a><span id="l20.55">   if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.56"></a><span id="l20.56">   if (!isDir) return NS_ERROR_INVALID_ARG;</span>
<a href="#l20.57"></a><span id="l20.57"> </span>
<a href="#l20.58"></a><span id="l20.58">   bool exists;</span>
<a href="#l20.59"></a><span id="l20.59">   rv = destDir-&gt;Exists(&amp;exists);</span>
<a href="#l20.60"></a><span id="l20.60">   if (NS_SUCCEEDED(rv) &amp;&amp; !exists)</span>
<a href="#l20.61"></a><span id="l20.61">     rv = destDir-&gt;Create(nsIFile::DIRECTORY_TYPE, 0775);</span>
<a href="#l20.62"></a><span id="l20.62">   if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.63"></a><span id="l20.63"> </span>
<a href="#l20.64"></a><span id="l20.64" class="difflineminus">-</span>
<a href="#l20.65"></a><span id="l20.65">   nsCOMPtr&lt;nsIDirectoryEnumerator&gt; dirIterator;</span>
<a href="#l20.66"></a><span id="l20.66">   rv = srcDir-&gt;GetDirectoryEntries(getter_AddRefs(dirIterator));</span>
<a href="#l20.67"></a><span id="l20.67">   if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.68"></a><span id="l20.68"> </span>
<a href="#l20.69"></a><span id="l20.69">   bool hasMore = false;</span>
<a href="#l20.70"></a><span id="l20.70" class="difflineminus">-  while (NS_SUCCEEDED(dirIterator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l20.71"></a><span id="l20.71" class="difflineminus">-  {</span>
<a href="#l20.72"></a><span id="l20.72" class="difflineplus">+  while (NS_SUCCEEDED(dirIterator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore) {</span>
<a href="#l20.73"></a><span id="l20.73">     nsCOMPtr&lt;nsIFile&gt; dirEntry;</span>
<a href="#l20.74"></a><span id="l20.74">     rv = dirIterator-&gt;GetNextFile(getter_AddRefs(dirEntry));</span>
<a href="#l20.75"></a><span id="l20.75" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; dirEntry)</span>
<a href="#l20.76"></a><span id="l20.76" class="difflineminus">-    {</span>
<a href="#l20.77"></a><span id="l20.77" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; dirEntry) {</span>
<a href="#l20.78"></a><span id="l20.78">       rv = dirEntry-&gt;IsDirectory(&amp;isDir);</span>
<a href="#l20.79"></a><span id="l20.79" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l20.80"></a><span id="l20.80" class="difflineminus">-      {</span>
<a href="#l20.81"></a><span id="l20.81" class="difflineminus">-        if (isDir)</span>
<a href="#l20.82"></a><span id="l20.82" class="difflineminus">-        {</span>
<a href="#l20.83"></a><span id="l20.83" class="difflineplus">+      if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.84"></a><span id="l20.84" class="difflineplus">+        if (isDir) {</span>
<a href="#l20.85"></a><span id="l20.85">           nsCOMPtr&lt;nsIFile&gt; newChild;</span>
<a href="#l20.86"></a><span id="l20.86">           rv = destDir-&gt;Clone(getter_AddRefs(newChild));</span>
<a href="#l20.87"></a><span id="l20.87" class="difflineminus">-          if (NS_SUCCEEDED(rv))</span>
<a href="#l20.88"></a><span id="l20.88" class="difflineminus">-          {</span>
<a href="#l20.89"></a><span id="l20.89" class="difflineplus">+          if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.90"></a><span id="l20.90">             nsAutoString leafName;</span>
<a href="#l20.91"></a><span id="l20.91">             dirEntry-&gt;GetLeafName(leafName);</span>
<a href="#l20.92"></a><span id="l20.92">             newChild-&gt;AppendRelativePath(leafName);</span>
<a href="#l20.93"></a><span id="l20.93">             rv = newChild-&gt;Exists(&amp;exists);</span>
<a href="#l20.94"></a><span id="l20.94">             if (NS_SUCCEEDED(rv) &amp;&amp; !exists)</span>
<a href="#l20.95"></a><span id="l20.95">               rv = newChild-&gt;Create(nsIFile::DIRECTORY_TYPE, 0775);</span>
<a href="#l20.96"></a><span id="l20.96">             rv = RecursiveCopy(dirEntry, newChild);</span>
<a href="#l20.97"></a><span id="l20.97">           }</span>
<a href="#l20.98"></a><span id="l20.98" class="difflineminus">-        }</span>
<a href="#l20.99"></a><span id="l20.99" class="difflineminus">-        else</span>
<a href="#l20.100"></a><span id="l20.100" class="difflineplus">+        } else</span>
<a href="#l20.101"></a><span id="l20.101">           rv = dirEntry-&gt;CopyTo(destDir, EmptyString());</span>
<a href="#l20.102"></a><span id="l20.102">       }</span>
<a href="#l20.103"></a><span id="l20.103" class="difflineminus">-</span>
<a href="#l20.104"></a><span id="l20.104">     }</span>
<a href="#l20.105"></a><span id="l20.105">   }</span>
<a href="#l20.106"></a><span id="l20.106"> </span>
<a href="#l20.107"></a><span id="l20.107">   return rv;</span>
<a href="#l20.108"></a><span id="l20.108"> }</span>
<a href="#l20.109"></a><span id="l20.109"> </span>
<a href="#l20.110"></a><span id="l20.110" class="difflineminus">-nsImapMailFolder::nsImapMailFolder() :</span>
<a href="#l20.111"></a><span id="l20.111" class="difflineminus">-    m_initialized(false),m_haveDiscoveredAllFolders(false),</span>
<a href="#l20.112"></a><span id="l20.112" class="difflineminus">-    m_curMsgUid(0), m_nextMessageByteLength(0),</span>
<a href="#l20.113"></a><span id="l20.113" class="difflineminus">-    m_urlRunning(false),</span>
<a href="#l20.114"></a><span id="l20.114" class="difflineminus">-    m_verifiedAsOnlineFolder(false),</span>
<a href="#l20.115"></a><span id="l20.115" class="difflineminus">-    m_explicitlyVerify(false),</span>
<a href="#l20.116"></a><span id="l20.116" class="difflineminus">-    m_folderIsNamespace(false),</span>
<a href="#l20.117"></a><span id="l20.117" class="difflineminus">-    m_folderNeedsSubscribing(false),</span>
<a href="#l20.118"></a><span id="l20.118" class="difflineminus">-    m_folderNeedsAdded(false),</span>
<a href="#l20.119"></a><span id="l20.119" class="difflineminus">-    m_folderNeedsACLListed(true),</span>
<a href="#l20.120"></a><span id="l20.120" class="difflineminus">-    m_performingBiff(false),</span>
<a href="#l20.121"></a><span id="l20.121" class="difflineminus">-    m_folderQuotaCommandIssued(false),</span>
<a href="#l20.122"></a><span id="l20.122" class="difflineminus">-    m_folderQuotaDataIsValid(false),</span>
<a href="#l20.123"></a><span id="l20.123" class="difflineminus">-    m_updatingFolder(false),</span>
<a href="#l20.124"></a><span id="l20.124" class="difflineminus">-    m_compactingOfflineStore(false),</span>
<a href="#l20.125"></a><span id="l20.125" class="difflineminus">-    m_expunging(false),</span>
<a href="#l20.126"></a><span id="l20.126" class="difflineminus">-    m_applyIncomingFilters(false),</span>
<a href="#l20.127"></a><span id="l20.127" class="difflineminus">-    m_downloadingFolderForOfflineUse(false),</span>
<a href="#l20.128"></a><span id="l20.128" class="difflineminus">-    m_filterListRequiresBody(false),</span>
<a href="#l20.129"></a><span id="l20.129" class="difflineminus">-    m_folderQuotaUsedKB(0),</span>
<a href="#l20.130"></a><span id="l20.130" class="difflineminus">-    m_folderQuotaMaxKB(0)</span>
<a href="#l20.131"></a><span id="l20.131" class="difflineminus">-{</span>
<a href="#l20.132"></a><span id="l20.132" class="difflineplus">+nsImapMailFolder::nsImapMailFolder()</span>
<a href="#l20.133"></a><span id="l20.133" class="difflineplus">+    : m_initialized(false),</span>
<a href="#l20.134"></a><span id="l20.134" class="difflineplus">+      m_haveDiscoveredAllFolders(false),</span>
<a href="#l20.135"></a><span id="l20.135" class="difflineplus">+      m_curMsgUid(0),</span>
<a href="#l20.136"></a><span id="l20.136" class="difflineplus">+      m_nextMessageByteLength(0),</span>
<a href="#l20.137"></a><span id="l20.137" class="difflineplus">+      m_urlRunning(false),</span>
<a href="#l20.138"></a><span id="l20.138" class="difflineplus">+      m_verifiedAsOnlineFolder(false),</span>
<a href="#l20.139"></a><span id="l20.139" class="difflineplus">+      m_explicitlyVerify(false),</span>
<a href="#l20.140"></a><span id="l20.140" class="difflineplus">+      m_folderIsNamespace(false),</span>
<a href="#l20.141"></a><span id="l20.141" class="difflineplus">+      m_folderNeedsSubscribing(false),</span>
<a href="#l20.142"></a><span id="l20.142" class="difflineplus">+      m_folderNeedsAdded(false),</span>
<a href="#l20.143"></a><span id="l20.143" class="difflineplus">+      m_folderNeedsACLListed(true),</span>
<a href="#l20.144"></a><span id="l20.144" class="difflineplus">+      m_performingBiff(false),</span>
<a href="#l20.145"></a><span id="l20.145" class="difflineplus">+      m_folderQuotaCommandIssued(false),</span>
<a href="#l20.146"></a><span id="l20.146" class="difflineplus">+      m_folderQuotaDataIsValid(false),</span>
<a href="#l20.147"></a><span id="l20.147" class="difflineplus">+      m_updatingFolder(false),</span>
<a href="#l20.148"></a><span id="l20.148" class="difflineplus">+      m_compactingOfflineStore(false),</span>
<a href="#l20.149"></a><span id="l20.149" class="difflineplus">+      m_expunging(false),</span>
<a href="#l20.150"></a><span id="l20.150" class="difflineplus">+      m_applyIncomingFilters(false),</span>
<a href="#l20.151"></a><span id="l20.151" class="difflineplus">+      m_downloadingFolderForOfflineUse(false),</span>
<a href="#l20.152"></a><span id="l20.152" class="difflineplus">+      m_filterListRequiresBody(false),</span>
<a href="#l20.153"></a><span id="l20.153" class="difflineplus">+      m_folderQuotaUsedKB(0),</span>
<a href="#l20.154"></a><span id="l20.154" class="difflineplus">+      m_folderQuotaMaxKB(0) {</span>
<a href="#l20.155"></a><span id="l20.155">   m_boxFlags = 0;</span>
<a href="#l20.156"></a><span id="l20.156">   m_uidValidity = kUidUnknown;</span>
<a href="#l20.157"></a><span id="l20.157">   m_numServerRecentMessages = 0;</span>
<a href="#l20.158"></a><span id="l20.158">   m_numServerUnseenMessages = 0;</span>
<a href="#l20.159"></a><span id="l20.159">   m_numServerTotalMessages = 0;</span>
<a href="#l20.160"></a><span id="l20.160">   m_nextUID = nsMsgKey_None;</span>
<a href="#l20.161"></a><span id="l20.161">   m_hierarchyDelimiter = kOnlineHierarchySeparatorUnknown;</span>
<a href="#l20.162"></a><span id="l20.162">   m_folderACL = nullptr;</span>
<a href="#l20.163"></a><span id="l20.163">   m_aclFlags = 0;</span>
<a href="#l20.164"></a><span id="l20.164">   m_supportedUserFlags = 0;</span>
<a href="#l20.165"></a><span id="l20.165">   m_namespace = nullptr;</span>
<a href="#l20.166"></a><span id="l20.166">   m_pendingPlaybackReq = nullptr;</span>
<a href="#l20.167"></a><span id="l20.167"> }</span>
<a href="#l20.168"></a><span id="l20.168"> </span>
<a href="#l20.169"></a><span id="l20.169" class="difflineminus">-nsImapMailFolder::~nsImapMailFolder()</span>
<a href="#l20.170"></a><span id="l20.170" class="difflineminus">-{</span>
<a href="#l20.171"></a><span id="l20.171" class="difflineplus">+nsImapMailFolder::~nsImapMailFolder() {</span>
<a href="#l20.172"></a><span id="l20.172">   delete m_folderACL;</span>
<a href="#l20.173"></a><span id="l20.173"> </span>
<a href="#l20.174"></a><span id="l20.174">   // cleanup any pending request</span>
<a href="#l20.175"></a><span id="l20.175">   delete m_pendingPlaybackReq;</span>
<a href="#l20.176"></a><span id="l20.176"> }</span>
<a href="#l20.177"></a><span id="l20.177"> </span>
<a href="#l20.178"></a><span id="l20.178"> NS_IMPL_ADDREF_INHERITED(nsImapMailFolder, nsMsgDBFolder)</span>
<a href="#l20.179"></a><span id="l20.179"> NS_IMPL_RELEASE_INHERITED(nsImapMailFolder, nsMsgDBFolder)</span>
<a href="#l20.180"></a><span id="l20.180"> NS_IMPL_QUERY_HEAD(nsImapMailFolder)</span>
<a href="#l20.181"></a><span id="l20.181" class="difflineminus">-    NS_IMPL_QUERY_BODY(nsIMsgImapMailFolder)</span>
<a href="#l20.182"></a><span id="l20.182" class="difflineminus">-    NS_IMPL_QUERY_BODY(nsICopyMessageListener)</span>
<a href="#l20.183"></a><span id="l20.183" class="difflineminus">-    NS_IMPL_QUERY_BODY(nsIImapMailFolderSink)</span>
<a href="#l20.184"></a><span id="l20.184" class="difflineminus">-    NS_IMPL_QUERY_BODY(nsIImapMessageSink)</span>
<a href="#l20.185"></a><span id="l20.185" class="difflineminus">-    NS_IMPL_QUERY_BODY(nsIUrlListener)</span>
<a href="#l20.186"></a><span id="l20.186" class="difflineminus">-    NS_IMPL_QUERY_BODY(nsIMsgFilterHitNotify)</span>
<a href="#l20.187"></a><span id="l20.187" class="difflineplus">+NS_IMPL_QUERY_BODY(nsIMsgImapMailFolder)</span>
<a href="#l20.188"></a><span id="l20.188" class="difflineplus">+NS_IMPL_QUERY_BODY(nsICopyMessageListener)</span>
<a href="#l20.189"></a><span id="l20.189" class="difflineplus">+NS_IMPL_QUERY_BODY(nsIImapMailFolderSink)</span>
<a href="#l20.190"></a><span id="l20.190" class="difflineplus">+NS_IMPL_QUERY_BODY(nsIImapMessageSink)</span>
<a href="#l20.191"></a><span id="l20.191" class="difflineplus">+NS_IMPL_QUERY_BODY(nsIUrlListener)</span>
<a href="#l20.192"></a><span id="l20.192" class="difflineplus">+NS_IMPL_QUERY_BODY(nsIMsgFilterHitNotify)</span>
<a href="#l20.193"></a><span id="l20.193"> NS_IMPL_QUERY_TAIL_INHERITING(nsMsgDBFolder)</span>
<a href="#l20.194"></a><span id="l20.194"> </span>
<a href="#l20.195"></a><span id="l20.195" class="difflineminus">-nsresult nsImapMailFolder::AddDirectorySeparator(nsIFile *path)</span>
<a href="#l20.196"></a><span id="l20.196" class="difflineminus">-{</span>
<a href="#l20.197"></a><span id="l20.197" class="difflineminus">-  if (mURI.Equals(kImapRootURI))</span>
<a href="#l20.198"></a><span id="l20.198" class="difflineminus">-  {</span>
<a href="#l20.199"></a><span id="l20.199" class="difflineplus">+nsresult nsImapMailFolder::AddDirectorySeparator(nsIFile *path) {</span>
<a href="#l20.200"></a><span id="l20.200" class="difflineplus">+  if (mURI.Equals(kImapRootURI)) {</span>
<a href="#l20.201"></a><span id="l20.201">     // don't concat the full separator with .sbd</span>
<a href="#l20.202"></a><span id="l20.202" class="difflineminus">-  }</span>
<a href="#l20.203"></a><span id="l20.203" class="difflineminus">-  else</span>
<a href="#l20.204"></a><span id="l20.204" class="difflineminus">-  {</span>
<a href="#l20.205"></a><span id="l20.205" class="difflineplus">+  } else {</span>
<a href="#l20.206"></a><span id="l20.206">     // see if there's a dir with the same name ending with .sbd</span>
<a href="#l20.207"></a><span id="l20.207">     nsAutoString leafName;</span>
<a href="#l20.208"></a><span id="l20.208">     path-&gt;GetLeafName(leafName);</span>
<a href="#l20.209"></a><span id="l20.209">     leafName.AppendLiteral(FOLDER_SUFFIX);</span>
<a href="#l20.210"></a><span id="l20.210">     path-&gt;SetLeafName(leafName);</span>
<a href="#l20.211"></a><span id="l20.211">   }</span>
<a href="#l20.212"></a><span id="l20.212"> </span>
<a href="#l20.213"></a><span id="l20.213">   return NS_OK;</span>
<a href="#l20.214"></a><span id="l20.214"> }</span>
<a href="#l20.215"></a><span id="l20.215"> </span>
<a href="#l20.216"></a><span id="l20.216" class="difflineminus">-static bool</span>
<a href="#l20.217"></a><span id="l20.217" class="difflineminus">-nsShouldIgnoreFile(nsString&amp; name)</span>
<a href="#l20.218"></a><span id="l20.218" class="difflineminus">-{</span>
<a href="#l20.219"></a><span id="l20.219" class="difflineminus">-  if (StringEndsWith(name, NS_LITERAL_STRING(SUMMARY_SUFFIX), nsCaseInsensitiveStringComparator()))</span>
<a href="#l20.220"></a><span id="l20.220" class="difflineminus">-  {</span>
<a href="#l20.221"></a><span id="l20.221" class="difflineminus">-    name.SetLength(name.Length() - SUMMARY_SUFFIX_LENGTH); // truncate the string</span>
<a href="#l20.222"></a><span id="l20.222" class="difflineplus">+static bool nsShouldIgnoreFile(nsString &amp;name) {</span>
<a href="#l20.223"></a><span id="l20.223" class="difflineplus">+  if (StringEndsWith(name, NS_LITERAL_STRING(SUMMARY_SUFFIX),</span>
<a href="#l20.224"></a><span id="l20.224" class="difflineplus">+                     nsCaseInsensitiveStringComparator())) {</span>
<a href="#l20.225"></a><span id="l20.225" class="difflineplus">+    name.SetLength(name.Length() -</span>
<a href="#l20.226"></a><span id="l20.226" class="difflineplus">+                   SUMMARY_SUFFIX_LENGTH);  // truncate the string</span>
<a href="#l20.227"></a><span id="l20.227">     return false;</span>
<a href="#l20.228"></a><span id="l20.228">   }</span>
<a href="#l20.229"></a><span id="l20.229">   return true;</span>
<a href="#l20.230"></a><span id="l20.230"> }</span>
<a href="#l20.231"></a><span id="l20.231"> </span>
<a href="#l20.232"></a><span id="l20.232" class="difflineminus">-nsresult nsImapMailFolder::CreateChildFromURI(const nsCString &amp;uri, nsIMsgFolder **folder)</span>
<a href="#l20.233"></a><span id="l20.233" class="difflineminus">-{</span>
<a href="#l20.234"></a><span id="l20.234" class="difflineplus">+nsresult nsImapMailFolder::CreateChildFromURI(const nsCString &amp;uri,</span>
<a href="#l20.235"></a><span id="l20.235" class="difflineplus">+                                              nsIMsgFolder **folder) {</span>
<a href="#l20.236"></a><span id="l20.236">   nsImapMailFolder *newFolder = new nsImapMailFolder;</span>
<a href="#l20.237"></a><span id="l20.237">   newFolder-&gt;Init(uri.get());</span>
<a href="#l20.238"></a><span id="l20.238">   NS_ADDREF(*folder = newFolder);</span>
<a href="#l20.239"></a><span id="l20.239">   return NS_OK;</span>
<a href="#l20.240"></a><span id="l20.240"> }</span>
<a href="#l20.241"></a><span id="l20.241"> </span>
<a href="#l20.242"></a><span id="l20.242" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::AddSubfolder(const nsAString&amp; aName, nsIMsgFolder** aChild)</span>
<a href="#l20.243"></a><span id="l20.243" class="difflineminus">-{</span>
<a href="#l20.244"></a><span id="l20.244" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::AddSubfolder(const nsAString &amp;aName,</span>
<a href="#l20.245"></a><span id="l20.245" class="difflineplus">+                                             nsIMsgFolder **aChild) {</span>
<a href="#l20.246"></a><span id="l20.246">   NS_ENSURE_ARG_POINTER(aChild);</span>
<a href="#l20.247"></a><span id="l20.247"> </span>
<a href="#l20.248"></a><span id="l20.248">   int32_t flags = 0;</span>
<a href="#l20.249"></a><span id="l20.249">   nsresult rv;</span>
<a href="#l20.250"></a><span id="l20.250"> </span>
<a href="#l20.251"></a><span id="l20.251">   nsAutoCString uri(mURI);</span>
<a href="#l20.252"></a><span id="l20.252">   uri.Append('/');</span>
<a href="#l20.253"></a><span id="l20.253"> </span>
<a href="#l20.254"></a><span id="l20.254" class="difflineminus">-  // If AddSubFolder starts getting called for folders other than virtual folders,</span>
<a href="#l20.255"></a><span id="l20.255" class="difflineminus">-  // we'll have to do convert those names to modified utf-7. For now, the account manager code</span>
<a href="#l20.256"></a><span id="l20.256" class="difflineminus">-  // that loads the virtual folders for each account, expects utf8 not modified utf-7.</span>
<a href="#l20.257"></a><span id="l20.257" class="difflineplus">+  // If AddSubFolder starts getting called for folders other than virtual</span>
<a href="#l20.258"></a><span id="l20.258" class="difflineplus">+  // folders, we'll have to do convert those names to modified utf-7. For now,</span>
<a href="#l20.259"></a><span id="l20.259" class="difflineplus">+  // the account manager code that loads the virtual folders for each account,</span>
<a href="#l20.260"></a><span id="l20.260" class="difflineplus">+  // expects utf8 not modified utf-7.</span>
<a href="#l20.261"></a><span id="l20.261">   nsAutoCString escapedName;</span>
<a href="#l20.262"></a><span id="l20.262">   rv = NS_MsgEscapeEncodeURLPath(aName, escapedName);</span>
<a href="#l20.263"></a><span id="l20.263">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.264"></a><span id="l20.264"> </span>
<a href="#l20.265"></a><span id="l20.265">   uri += escapedName.get();</span>
<a href="#l20.266"></a><span id="l20.266"> </span>
<a href="#l20.267"></a><span id="l20.267" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l20.268"></a><span id="l20.268" class="difflineminus">-  rv = GetChildWithURI(uri, false/*deep*/, true /*case Insensitive*/, getter_AddRefs(msgFolder));</span>
<a href="#l20.269"></a><span id="l20.269" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; msgFolder)</span>
<a href="#l20.270"></a><span id="l20.270" class="difflineminus">-    return NS_MSG_FOLDER_EXISTS;</span>
<a href="#l20.271"></a><span id="l20.271" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l20.272"></a><span id="l20.272" class="difflineplus">+  rv = GetChildWithURI(uri, false /*deep*/, true /*case Insensitive*/,</span>
<a href="#l20.273"></a><span id="l20.273" class="difflineplus">+                       getter_AddRefs(msgFolder));</span>
<a href="#l20.274"></a><span id="l20.274" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; msgFolder) return NS_MSG_FOLDER_EXISTS;</span>
<a href="#l20.275"></a><span id="l20.275"> </span>
<a href="#l20.276"></a><span id="l20.276">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l20.277"></a><span id="l20.277">   rv = GetOrCreateFolder(uri, getter_AddRefs(folder));</span>
<a href="#l20.278"></a><span id="l20.278">   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);</span>
<a href="#l20.279"></a><span id="l20.279"> </span>
<a href="#l20.280"></a><span id="l20.280" class="difflineminus">-  nsCOMPtr &lt;nsIFile&gt; path;</span>
<a href="#l20.281"></a><span id="l20.281" class="difflineplus">+  nsCOMPtr&lt;nsIFile&gt; path;</span>
<a href="#l20.282"></a><span id="l20.282">   rv = CreateDirectoryForFolder(getter_AddRefs(path));</span>
<a href="#l20.283"></a><span id="l20.283">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.284"></a><span id="l20.284"> </span>
<a href="#l20.285"></a><span id="l20.285">   folder-&gt;GetFlags((uint32_t *)&amp;flags);</span>
<a href="#l20.286"></a><span id="l20.286"> </span>
<a href="#l20.287"></a><span id="l20.287">   flags |= nsMsgFolderFlags::Mail;</span>
<a href="#l20.288"></a><span id="l20.288"> </span>
<a href="#l20.289"></a><span id="l20.289">   nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.290"></a><span id="l20.290">   GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.291"></a><span id="l20.291" class="difflineminus">-  if (imapServer)</span>
<a href="#l20.292"></a><span id="l20.292" class="difflineminus">-  {</span>
<a href="#l20.293"></a><span id="l20.293" class="difflineplus">+  if (imapServer) {</span>
<a href="#l20.294"></a><span id="l20.294">     bool setNewFoldersForOffline = false;</span>
<a href="#l20.295"></a><span id="l20.295">     rv = imapServer-&gt;GetOfflineDownload(&amp;setNewFoldersForOffline);</span>
<a href="#l20.296"></a><span id="l20.296">     if (NS_SUCCEEDED(rv) &amp;&amp; setNewFoldersForOffline)</span>
<a href="#l20.297"></a><span id="l20.297">       flags |= nsMsgFolderFlags::Offline;</span>
<a href="#l20.298"></a><span id="l20.298">   }</span>
<a href="#l20.299"></a><span id="l20.299"> </span>
<a href="#l20.300"></a><span id="l20.300">   folder-&gt;SetParent(this);</span>
<a href="#l20.301"></a><span id="l20.301"> </span>
<a href="#l20.302"></a><span id="l20.302">   folder-&gt;SetFlags(flags);</span>
<a href="#l20.303"></a><span id="l20.303"> </span>
<a href="#l20.304"></a><span id="l20.304">   mSubFolders.AppendObject(folder);</span>
<a href="#l20.305"></a><span id="l20.305">   folder.forget(aChild);</span>
<a href="#l20.306"></a><span id="l20.306"> </span>
<a href="#l20.307"></a><span id="l20.307" class="difflineminus">-  nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapChild = do_QueryInterface(*aChild);</span>
<a href="#l20.308"></a><span id="l20.308" class="difflineminus">-  if (imapChild)</span>
<a href="#l20.309"></a><span id="l20.309" class="difflineminus">-  {</span>
<a href="#l20.310"></a><span id="l20.310" class="difflineplus">+  nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapChild = do_QueryInterface(*aChild);</span>
<a href="#l20.311"></a><span id="l20.311" class="difflineplus">+  if (imapChild) {</span>
<a href="#l20.312"></a><span id="l20.312">     imapChild-&gt;SetOnlineName(NS_LossyConvertUTF16toASCII(aName));</span>
<a href="#l20.313"></a><span id="l20.313">     imapChild-&gt;SetHierarchyDelimiter(m_hierarchyDelimiter);</span>
<a href="#l20.314"></a><span id="l20.314">   }</span>
<a href="#l20.315"></a><span id="l20.315">   NotifyItemAdded(*aChild);</span>
<a href="#l20.316"></a><span id="l20.316">   return rv;</span>
<a href="#l20.317"></a><span id="l20.317"> }</span>
<a href="#l20.318"></a><span id="l20.318"> </span>
<a href="#l20.319"></a><span id="l20.319" class="difflineminus">-nsresult nsImapMailFolder::AddSubfolderWithPath(nsAString&amp; name, nsIFile *dbPath,</span>
<a href="#l20.320"></a><span id="l20.320" class="difflineminus">-                                             nsIMsgFolder **child, bool brandNew)</span>
<a href="#l20.321"></a><span id="l20.321" class="difflineminus">-{</span>
<a href="#l20.322"></a><span id="l20.322" class="difflineplus">+nsresult nsImapMailFolder::AddSubfolderWithPath(nsAString &amp;name,</span>
<a href="#l20.323"></a><span id="l20.323" class="difflineplus">+                                                nsIFile *dbPath,</span>
<a href="#l20.324"></a><span id="l20.324" class="difflineplus">+                                                nsIMsgFolder **child,</span>
<a href="#l20.325"></a><span id="l20.325" class="difflineplus">+                                                bool brandNew) {</span>
<a href="#l20.326"></a><span id="l20.326">   NS_ENSURE_ARG_POINTER(child);</span>
<a href="#l20.327"></a><span id="l20.327">   nsresult rv;</span>
<a href="#l20.328"></a><span id="l20.328"> </span>
<a href="#l20.329"></a><span id="l20.329">   nsAutoCString uri(mURI);</span>
<a href="#l20.330"></a><span id="l20.330">   uri.Append('/');</span>
<a href="#l20.331"></a><span id="l20.331">   AppendUTF16toUTF8(name, uri);</span>
<a href="#l20.332"></a><span id="l20.332"> </span>
<a href="#l20.333"></a><span id="l20.333">   bool isServer;</span>
<a href="#l20.334"></a><span id="l20.334">   rv = GetIsServer(&amp;isServer);</span>
<a href="#l20.335"></a><span id="l20.335">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.336"></a><span id="l20.336"> </span>
<a href="#l20.337"></a><span id="l20.337">   bool isInbox = isServer &amp;&amp; name.LowerCaseEqualsLiteral(&quot;inbox&quot;);</span>
<a href="#l20.338"></a><span id="l20.338"> </span>
<a href="#l20.339"></a><span id="l20.339" class="difflineminus">-  //will make sure mSubFolders does not have duplicates because of bogus msf files.</span>
<a href="#l20.340"></a><span id="l20.340" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l20.341"></a><span id="l20.341" class="difflineminus">-  rv = GetChildWithURI(uri, false/*deep*/, isInbox /*case Insensitive*/, getter_AddRefs(msgFolder));</span>
<a href="#l20.342"></a><span id="l20.342" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; msgFolder)</span>
<a href="#l20.343"></a><span id="l20.343" class="difflineminus">-    return NS_MSG_FOLDER_EXISTS;</span>
<a href="#l20.344"></a><span id="l20.344" class="difflineplus">+  // will make sure mSubFolders does not have duplicates because of bogus msf</span>
<a href="#l20.345"></a><span id="l20.345" class="difflineplus">+  // files.</span>
<a href="#l20.346"></a><span id="l20.346" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l20.347"></a><span id="l20.347" class="difflineplus">+  rv = GetChildWithURI(uri, false /*deep*/, isInbox /*case Insensitive*/,</span>
<a href="#l20.348"></a><span id="l20.348" class="difflineplus">+                       getter_AddRefs(msgFolder));</span>
<a href="#l20.349"></a><span id="l20.349" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; msgFolder) return NS_MSG_FOLDER_EXISTS;</span>
<a href="#l20.350"></a><span id="l20.350"> </span>
<a href="#l20.351"></a><span id="l20.351">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l20.352"></a><span id="l20.352">   rv = GetOrCreateFolder(uri, getter_AddRefs(folder));</span>
<a href="#l20.353"></a><span id="l20.353">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.354"></a><span id="l20.354"> </span>
<a href="#l20.355"></a><span id="l20.355">   folder-&gt;SetFilePath(dbPath);</span>
<a href="#l20.356"></a><span id="l20.356">   nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(folder, &amp;rv);</span>
<a href="#l20.357"></a><span id="l20.357">   mozilla::Unused &lt;&lt; imapFolder;</span>
<a href="#l20.358"></a><span id="l20.358" class="difflineat">@@ -360,788 +346,726 @@ nsresult nsImapMailFolder::AddSubfolderW</span>
<a href="#l20.359"></a><span id="l20.359">   uint32_t pFlags;</span>
<a href="#l20.360"></a><span id="l20.360">   GetFlags(&amp;pFlags);</span>
<a href="#l20.361"></a><span id="l20.361">   bool isParentInbox = pFlags &amp; nsMsgFolderFlags::Inbox;</span>
<a href="#l20.362"></a><span id="l20.362"> </span>
<a href="#l20.363"></a><span id="l20.363">   nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.364"></a><span id="l20.364">   rv = GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.365"></a><span id="l20.365">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.366"></a><span id="l20.366"> </span>
<a href="#l20.367"></a><span id="l20.367" class="difflineminus">-  //Only set these if these are top level children or parent is inbox</span>
<a href="#l20.368"></a><span id="l20.368" class="difflineplus">+  // Only set these if these are top level children or parent is inbox</span>
<a href="#l20.369"></a><span id="l20.369">   if (isInbox)</span>
<a href="#l20.370"></a><span id="l20.370">     flags |= nsMsgFolderFlags::Inbox;</span>
<a href="#l20.371"></a><span id="l20.371" class="difflineminus">-  else if (isServer || isParentInbox)</span>
<a href="#l20.372"></a><span id="l20.372" class="difflineminus">-  {</span>
<a href="#l20.373"></a><span id="l20.373" class="difflineplus">+  else if (isServer || isParentInbox) {</span>
<a href="#l20.374"></a><span id="l20.374">     nsMsgImapDeleteModel deleteModel;</span>
<a href="#l20.375"></a><span id="l20.375">     imapServer-&gt;GetDeleteModel(&amp;deleteModel);</span>
<a href="#l20.376"></a><span id="l20.376" class="difflineminus">-    if (deleteModel == nsMsgImapDeleteModels::MoveToTrash)</span>
<a href="#l20.377"></a><span id="l20.377" class="difflineminus">-    {</span>
<a href="#l20.378"></a><span id="l20.378" class="difflineplus">+    if (deleteModel == nsMsgImapDeleteModels::MoveToTrash) {</span>
<a href="#l20.379"></a><span id="l20.379">       nsAutoString trashName;</span>
<a href="#l20.380"></a><span id="l20.380">       GetTrashFolderName(trashName);</span>
<a href="#l20.381"></a><span id="l20.381" class="difflineminus">-      if (name.Equals(trashName))</span>
<a href="#l20.382"></a><span id="l20.382" class="difflineminus">-        flags |= nsMsgFolderFlags::Trash;</span>
<a href="#l20.383"></a><span id="l20.383" class="difflineplus">+      if (name.Equals(trashName)) flags |= nsMsgFolderFlags::Trash;</span>
<a href="#l20.384"></a><span id="l20.384">     }</span>
<a href="#l20.385"></a><span id="l20.385">   }</span>
<a href="#l20.386"></a><span id="l20.386"> </span>
<a href="#l20.387"></a><span id="l20.387">   // Make the folder offline if it is newly created and the offline_download</span>
<a href="#l20.388"></a><span id="l20.388">   // pref is true, unless it's the Trash or Junk folder.</span>
<a href="#l20.389"></a><span id="l20.389" class="difflineminus">-  if (brandNew &amp;&amp; !(flags &amp; (nsMsgFolderFlags::Trash | nsMsgFolderFlags::Junk)))</span>
<a href="#l20.390"></a><span id="l20.390" class="difflineminus">-  {</span>
<a href="#l20.391"></a><span id="l20.391" class="difflineplus">+  if (brandNew &amp;&amp;</span>
<a href="#l20.392"></a><span id="l20.392" class="difflineplus">+      !(flags &amp; (nsMsgFolderFlags::Trash | nsMsgFolderFlags::Junk))) {</span>
<a href="#l20.393"></a><span id="l20.393">     bool setNewFoldersForOffline = false;</span>
<a href="#l20.394"></a><span id="l20.394">     rv = imapServer-&gt;GetOfflineDownload(&amp;setNewFoldersForOffline);</span>
<a href="#l20.395"></a><span id="l20.395">     if (NS_SUCCEEDED(rv) &amp;&amp; setNewFoldersForOffline)</span>
<a href="#l20.396"></a><span id="l20.396">       flags |= nsMsgFolderFlags::Offline;</span>
<a href="#l20.397"></a><span id="l20.397">   }</span>
<a href="#l20.398"></a><span id="l20.398"> </span>
<a href="#l20.399"></a><span id="l20.399">   folder-&gt;SetFlags(flags);</span>
<a href="#l20.400"></a><span id="l20.400"> </span>
<a href="#l20.401"></a><span id="l20.401" class="difflineminus">-  if (folder)</span>
<a href="#l20.402"></a><span id="l20.402" class="difflineminus">-    mSubFolders.AppendObject(folder);</span>
<a href="#l20.403"></a><span id="l20.403" class="difflineplus">+  if (folder) mSubFolders.AppendObject(folder);</span>
<a href="#l20.404"></a><span id="l20.404">   folder.forget(child);</span>
<a href="#l20.405"></a><span id="l20.405">   return NS_OK;</span>
<a href="#l20.406"></a><span id="l20.406"> }</span>
<a href="#l20.407"></a><span id="l20.407"> </span>
<a href="#l20.408"></a><span id="l20.408" class="difflineminus">-nsresult nsImapMailFolder::CreateSubFolders(nsIFile *path)</span>
<a href="#l20.409"></a><span id="l20.409" class="difflineminus">-{</span>
<a href="#l20.410"></a><span id="l20.410" class="difflineplus">+nsresult nsImapMailFolder::CreateSubFolders(nsIFile *path) {</span>
<a href="#l20.411"></a><span id="l20.411">   nsresult rv = NS_OK;</span>
<a href="#l20.412"></a><span id="l20.412">   nsAutoString currentFolderNameStr;    // online name</span>
<a href="#l20.413"></a><span id="l20.413">   nsAutoString currentFolderDBNameStr;  // possibly munged name</span>
<a href="#l20.414"></a><span id="l20.414">   nsCOMPtr&lt;nsIMsgFolder&gt; child;</span>
<a href="#l20.415"></a><span id="l20.415">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.416"></a><span id="l20.416">   rv = GetServer(getter_AddRefs(server));</span>
<a href="#l20.417"></a><span id="l20.417">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.418"></a><span id="l20.418"> </span>
<a href="#l20.419"></a><span id="l20.419">   nsCOMPtr&lt;nsIDirectoryEnumerator&gt; children;</span>
<a href="#l20.420"></a><span id="l20.420">   rv = path-&gt;GetDirectoryEntries(getter_AddRefs(children));</span>
<a href="#l20.421"></a><span id="l20.421">   bool more = false;</span>
<a href="#l20.422"></a><span id="l20.422" class="difflineminus">-  if (children)</span>
<a href="#l20.423"></a><span id="l20.423" class="difflineminus">-    children-&gt;HasMoreElements(&amp;more);</span>
<a href="#l20.424"></a><span id="l20.424" class="difflineminus">-</span>
<a href="#l20.425"></a><span id="l20.425" class="difflineminus">-  while (more)</span>
<a href="#l20.426"></a><span id="l20.426" class="difflineminus">-  {</span>
<a href="#l20.427"></a><span id="l20.427" class="difflineplus">+  if (children) children-&gt;HasMoreElements(&amp;more);</span>
<a href="#l20.428"></a><span id="l20.428" class="difflineplus">+</span>
<a href="#l20.429"></a><span id="l20.429" class="difflineplus">+  while (more) {</span>
<a href="#l20.430"></a><span id="l20.430">     nsCOMPtr&lt;nsIFile&gt; currentFolderPath;</span>
<a href="#l20.431"></a><span id="l20.431">     rv = children-&gt;GetNextFile(getter_AddRefs(currentFolderPath));</span>
<a href="#l20.432"></a><span id="l20.432" class="difflineminus">-    if (NS_FAILED(rv) || !currentFolderPath)</span>
<a href="#l20.433"></a><span id="l20.433" class="difflineminus">-      break;</span>
<a href="#l20.434"></a><span id="l20.434" class="difflineplus">+    if (NS_FAILED(rv) || !currentFolderPath) break;</span>
<a href="#l20.435"></a><span id="l20.435">     rv = children-&gt;HasMoreElements(&amp;more);</span>
<a href="#l20.436"></a><span id="l20.436">     if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.437"></a><span id="l20.437"> </span>
<a href="#l20.438"></a><span id="l20.438">     currentFolderPath-&gt;GetLeafName(currentFolderNameStr);</span>
<a href="#l20.439"></a><span id="l20.439" class="difflineminus">-    if (nsShouldIgnoreFile(currentFolderNameStr))</span>
<a href="#l20.440"></a><span id="l20.440" class="difflineminus">-      continue;</span>
<a href="#l20.441"></a><span id="l20.441" class="difflineplus">+    if (nsShouldIgnoreFile(currentFolderNameStr)) continue;</span>
<a href="#l20.442"></a><span id="l20.442"> </span>
<a href="#l20.443"></a><span id="l20.443">     // OK, here we need to get the online name from the folder cache if we can.</span>
<a href="#l20.444"></a><span id="l20.444">     // If we can, use that to create the sub-folder</span>
<a href="#l20.445"></a><span id="l20.445" class="difflineminus">-    nsCOMPtr &lt;nsIMsgFolderCacheElement&gt; cacheElement;</span>
<a href="#l20.446"></a><span id="l20.446" class="difflineminus">-    nsCOMPtr &lt;nsIFile&gt; curFolder = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID, &amp;rv);</span>
<a href="#l20.447"></a><span id="l20.447" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolderCacheElement&gt; cacheElement;</span>
<a href="#l20.448"></a><span id="l20.448" class="difflineplus">+    nsCOMPtr&lt;nsIFile&gt; curFolder =</span>
<a href="#l20.449"></a><span id="l20.449" class="difflineplus">+        do_CreateInstance(NS_LOCAL_FILE_CONTRACTID, &amp;rv);</span>
<a href="#l20.450"></a><span id="l20.450">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.451"></a><span id="l20.451" class="difflineminus">-    nsCOMPtr &lt;nsIFile&gt; dbFile = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID, &amp;rv);</span>
<a href="#l20.452"></a><span id="l20.452" class="difflineplus">+    nsCOMPtr&lt;nsIFile&gt; dbFile = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID, &amp;rv);</span>
<a href="#l20.453"></a><span id="l20.453">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.454"></a><span id="l20.454">     dbFile-&gt;InitWithFile(currentFolderPath);</span>
<a href="#l20.455"></a><span id="l20.455">     curFolder-&gt;InitWithFile(currentFolderPath);</span>
<a href="#l20.456"></a><span id="l20.456">     // don't strip off the .msf in currentFolderPath.</span>
<a href="#l20.457"></a><span id="l20.457">     currentFolderPath-&gt;SetLeafName(currentFolderNameStr);</span>
<a href="#l20.458"></a><span id="l20.458">     currentFolderDBNameStr = currentFolderNameStr;</span>
<a href="#l20.459"></a><span id="l20.459">     nsAutoString utf7LeafName = currentFolderNameStr;</span>
<a href="#l20.460"></a><span id="l20.460"> </span>
<a href="#l20.461"></a><span id="l20.461" class="difflineminus">-    if (curFolder)</span>
<a href="#l20.462"></a><span id="l20.462" class="difflineminus">-    {</span>
<a href="#l20.463"></a><span id="l20.463" class="difflineplus">+    if (curFolder) {</span>
<a href="#l20.464"></a><span id="l20.464">       rv = GetFolderCacheElemFromFile(dbFile, getter_AddRefs(cacheElement));</span>
<a href="#l20.465"></a><span id="l20.465" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; cacheElement)</span>
<a href="#l20.466"></a><span id="l20.466" class="difflineminus">-      {</span>
<a href="#l20.467"></a><span id="l20.467" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; cacheElement) {</span>
<a href="#l20.468"></a><span id="l20.468">         nsCString onlineFullUtf7Name;</span>
<a href="#l20.469"></a><span id="l20.469"> </span>
<a href="#l20.470"></a><span id="l20.470">         uint32_t folderFlags;</span>
<a href="#l20.471"></a><span id="l20.471" class="difflineminus">-        rv = cacheElement-&gt;GetInt32Property(&quot;flags&quot;, (int32_t *) &amp;folderFlags);</span>
<a href="#l20.472"></a><span id="l20.472" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; folderFlags &amp; nsMsgFolderFlags::Virtual) //ignore virtual folders</span>
<a href="#l20.473"></a><span id="l20.473" class="difflineplus">+        rv = cacheElement-&gt;GetInt32Property(&quot;flags&quot;, (int32_t *)&amp;folderFlags);</span>
<a href="#l20.474"></a><span id="l20.474" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp;</span>
<a href="#l20.475"></a><span id="l20.475" class="difflineplus">+            folderFlags &amp; nsMsgFolderFlags::Virtual)  // ignore virtual folders</span>
<a href="#l20.476"></a><span id="l20.476">           continue;</span>
<a href="#l20.477"></a><span id="l20.477">         int32_t hierarchyDelimiter;</span>
<a href="#l20.478"></a><span id="l20.478">         rv = cacheElement-&gt;GetInt32Property(&quot;hierDelim&quot;, &amp;hierarchyDelimiter);</span>
<a href="#l20.479"></a><span id="l20.479" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; hierarchyDelimiter == kOnlineHierarchySeparatorUnknown)</span>
<a href="#l20.480"></a><span id="l20.480" class="difflineminus">-        {</span>
<a href="#l20.481"></a><span id="l20.481" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp;</span>
<a href="#l20.482"></a><span id="l20.482" class="difflineplus">+            hierarchyDelimiter == kOnlineHierarchySeparatorUnknown) {</span>
<a href="#l20.483"></a><span id="l20.483">           currentFolderPath-&gt;Remove(false);</span>
<a href="#l20.484"></a><span id="l20.484" class="difflineminus">-          continue; // blow away .msf files for folders with unknown delimiter.</span>
<a href="#l20.485"></a><span id="l20.485" class="difflineplus">+          continue;  // blow away .msf files for folders with unknown delimiter.</span>
<a href="#l20.486"></a><span id="l20.486">         }</span>
<a href="#l20.487"></a><span id="l20.487">         rv = cacheElement-&gt;GetStringProperty(&quot;onlineName&quot;, onlineFullUtf7Name);</span>
<a href="#l20.488"></a><span id="l20.488" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; !onlineFullUtf7Name.IsEmpty())</span>
<a href="#l20.489"></a><span id="l20.489" class="difflineminus">-        {</span>
<a href="#l20.490"></a><span id="l20.490" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; !onlineFullUtf7Name.IsEmpty()) {</span>
<a href="#l20.491"></a><span id="l20.491">           CopyMUTF7toUTF16(onlineFullUtf7Name, currentFolderNameStr);</span>
<a href="#l20.492"></a><span id="l20.492">           char delimiter = 0;</span>
<a href="#l20.493"></a><span id="l20.493">           GetHierarchyDelimiter(&amp;delimiter);</span>
<a href="#l20.494"></a><span id="l20.494">           int32_t leafPos = currentFolderNameStr.RFindChar(delimiter);</span>
<a href="#l20.495"></a><span id="l20.495" class="difflineminus">-          if (leafPos &gt; 0)</span>
<a href="#l20.496"></a><span id="l20.496" class="difflineminus">-            currentFolderNameStr.Cut(0, leafPos + 1);</span>
<a href="#l20.497"></a><span id="l20.497" class="difflineplus">+          if (leafPos &gt; 0) currentFolderNameStr.Cut(0, leafPos + 1);</span>
<a href="#l20.498"></a><span id="l20.498"> </span>
<a href="#l20.499"></a><span id="l20.499">           // take the utf7 full online name, and determine the utf7 leaf name</span>
<a href="#l20.500"></a><span id="l20.500">           CopyASCIItoUTF16(onlineFullUtf7Name, utf7LeafName);</span>
<a href="#l20.501"></a><span id="l20.501">           leafPos = utf7LeafName.RFindChar(delimiter);</span>
<a href="#l20.502"></a><span id="l20.502" class="difflineminus">-          if (leafPos &gt; 0)</span>
<a href="#l20.503"></a><span id="l20.503" class="difflineminus">-            utf7LeafName.Cut(0, leafPos + 1);</span>
<a href="#l20.504"></a><span id="l20.504" class="difflineplus">+          if (leafPos &gt; 0) utf7LeafName.Cut(0, leafPos + 1);</span>
<a href="#l20.505"></a><span id="l20.505">         }</span>
<a href="#l20.506"></a><span id="l20.506">       }</span>
<a href="#l20.507"></a><span id="l20.507">     }</span>
<a href="#l20.508"></a><span id="l20.508" class="difflineminus">-      // make the imap folder remember the file spec it was created with.</span>
<a href="#l20.509"></a><span id="l20.509" class="difflineminus">-    nsCOMPtr &lt;nsIFile&gt; msfFilePath = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID, &amp;rv);</span>
<a href="#l20.510"></a><span id="l20.510" class="difflineplus">+    // make the imap folder remember the file spec it was created with.</span>
<a href="#l20.511"></a><span id="l20.511" class="difflineplus">+    nsCOMPtr&lt;nsIFile&gt; msfFilePath =</span>
<a href="#l20.512"></a><span id="l20.512" class="difflineplus">+        do_CreateInstance(NS_LOCAL_FILE_CONTRACTID, &amp;rv);</span>
<a href="#l20.513"></a><span id="l20.513">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.514"></a><span id="l20.514">     msfFilePath-&gt;InitWithFile(currentFolderPath);</span>
<a href="#l20.515"></a><span id="l20.515" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; msfFilePath)</span>
<a href="#l20.516"></a><span id="l20.516" class="difflineminus">-    {</span>
<a href="#l20.517"></a><span id="l20.517" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; msfFilePath) {</span>
<a href="#l20.518"></a><span id="l20.518">       // leaf name is the db name w/o .msf (nsShouldIgnoreFile strips it off)</span>
<a href="#l20.519"></a><span id="l20.519">       // so this trims the .msf off the file spec.</span>
<a href="#l20.520"></a><span id="l20.520">       msfFilePath-&gt;SetLeafName(currentFolderDBNameStr);</span>
<a href="#l20.521"></a><span id="l20.521">     }</span>
<a href="#l20.522"></a><span id="l20.522">     // use the utf7 name as the uri for the folder.</span>
<a href="#l20.523"></a><span id="l20.523">     AddSubfolderWithPath(utf7LeafName, msfFilePath, getter_AddRefs(child));</span>
<a href="#l20.524"></a><span id="l20.524" class="difflineminus">-    if (child)</span>
<a href="#l20.525"></a><span id="l20.525" class="difflineminus">-    {</span>
<a href="#l20.526"></a><span id="l20.526" class="difflineplus">+    if (child) {</span>
<a href="#l20.527"></a><span id="l20.527">       // use the unicode name as the &quot;pretty&quot; name. Set it so it won't be</span>
<a href="#l20.528"></a><span id="l20.528">       // automatically computed from the URI, which is in utf7 form.</span>
<a href="#l20.529"></a><span id="l20.529">       if (!currentFolderNameStr.IsEmpty())</span>
<a href="#l20.530"></a><span id="l20.530">         child-&gt;SetPrettyName(currentFolderNameStr);</span>
<a href="#l20.531"></a><span id="l20.531">       child-&gt;SetMsgDatabase(nullptr);</span>
<a href="#l20.532"></a><span id="l20.532">     }</span>
<a href="#l20.533"></a><span id="l20.533">   }</span>
<a href="#l20.534"></a><span id="l20.534">   return rv;</span>
<a href="#l20.535"></a><span id="l20.535"> }</span>
<a href="#l20.536"></a><span id="l20.536"> </span>
<a href="#l20.537"></a><span id="l20.537" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetSubFolders(nsISimpleEnumerator **aResult)</span>
<a href="#l20.538"></a><span id="l20.538" class="difflineminus">-{</span>
<a href="#l20.539"></a><span id="l20.539" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetSubFolders(nsISimpleEnumerator **aResult) {</span>
<a href="#l20.540"></a><span id="l20.540">   bool isServer;</span>
<a href="#l20.541"></a><span id="l20.541">   nsresult rv = GetIsServer(&amp;isServer);</span>
<a href="#l20.542"></a><span id="l20.542">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.543"></a><span id="l20.543"> </span>
<a href="#l20.544"></a><span id="l20.544" class="difflineminus">-  if (!m_initialized)</span>
<a href="#l20.545"></a><span id="l20.545" class="difflineminus">-  {</span>
<a href="#l20.546"></a><span id="l20.546" class="difflineplus">+  if (!m_initialized) {</span>
<a href="#l20.547"></a><span id="l20.547">     nsCOMPtr&lt;nsIFile&gt; pathFile;</span>
<a href="#l20.548"></a><span id="l20.548">     rv = GetFilePath(getter_AddRefs(pathFile));</span>
<a href="#l20.549"></a><span id="l20.549">     if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.550"></a><span id="l20.550"> </span>
<a href="#l20.551"></a><span id="l20.551">     // host directory does not need .sbd tacked on</span>
<a href="#l20.552"></a><span id="l20.552" class="difflineminus">-    if (!isServer)</span>
<a href="#l20.553"></a><span id="l20.553" class="difflineminus">-    {</span>
<a href="#l20.554"></a><span id="l20.554" class="difflineplus">+    if (!isServer) {</span>
<a href="#l20.555"></a><span id="l20.555">       rv = AddDirectorySeparator(pathFile);</span>
<a href="#l20.556"></a><span id="l20.556" class="difflineminus">-      if(NS_FAILED(rv)) return rv;</span>
<a href="#l20.557"></a><span id="l20.557" class="difflineminus">-    }</span>
<a href="#l20.558"></a><span id="l20.558" class="difflineminus">-</span>
<a href="#l20.559"></a><span id="l20.559" class="difflineminus">-    m_initialized = true;      // need to set this here to avoid infinite recursion from CreateSubfolders.</span>
<a href="#l20.560"></a><span id="l20.560" class="difflineplus">+      if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.561"></a><span id="l20.561" class="difflineplus">+    }</span>
<a href="#l20.562"></a><span id="l20.562" class="difflineplus">+</span>
<a href="#l20.563"></a><span id="l20.563" class="difflineplus">+    m_initialized = true;  // need to set this here to avoid infinite recursion</span>
<a href="#l20.564"></a><span id="l20.564" class="difflineplus">+                           // from CreateSubfolders.</span>
<a href="#l20.565"></a><span id="l20.565">     // we have to treat the root folder specially, because it's name</span>
<a href="#l20.566"></a><span id="l20.566">     // doesn't end with .sbd</span>
<a href="#l20.567"></a><span id="l20.567"> </span>
<a href="#l20.568"></a><span id="l20.568">     int32_t newFlags = nsMsgFolderFlags::Mail;</span>
<a href="#l20.569"></a><span id="l20.569">     bool isDirectory = false;</span>
<a href="#l20.570"></a><span id="l20.570">     pathFile-&gt;IsDirectory(&amp;isDirectory);</span>
<a href="#l20.571"></a><span id="l20.571" class="difflineminus">-    if (isDirectory)</span>
<a href="#l20.572"></a><span id="l20.572" class="difflineminus">-    {</span>
<a href="#l20.573"></a><span id="l20.573" class="difflineminus">-        newFlags |= (nsMsgFolderFlags::Directory | nsMsgFolderFlags::Elided);</span>
<a href="#l20.574"></a><span id="l20.574" class="difflineminus">-        if (!mIsServer)</span>
<a href="#l20.575"></a><span id="l20.575" class="difflineminus">-          SetFlag(newFlags);</span>
<a href="#l20.576"></a><span id="l20.576" class="difflineminus">-        rv = CreateSubFolders(pathFile);</span>
<a href="#l20.577"></a><span id="l20.577" class="difflineminus">-    }</span>
<a href="#l20.578"></a><span id="l20.578" class="difflineminus">-    if (isServer)</span>
<a href="#l20.579"></a><span id="l20.579" class="difflineminus">-    {</span>
<a href="#l20.580"></a><span id="l20.580" class="difflineminus">-      nsCOMPtr &lt;nsIMsgFolder&gt; inboxFolder;</span>
<a href="#l20.581"></a><span id="l20.581" class="difflineplus">+    if (isDirectory) {</span>
<a href="#l20.582"></a><span id="l20.582" class="difflineplus">+      newFlags |= (nsMsgFolderFlags::Directory | nsMsgFolderFlags::Elided);</span>
<a href="#l20.583"></a><span id="l20.583" class="difflineplus">+      if (!mIsServer) SetFlag(newFlags);</span>
<a href="#l20.584"></a><span id="l20.584" class="difflineplus">+      rv = CreateSubFolders(pathFile);</span>
<a href="#l20.585"></a><span id="l20.585" class="difflineplus">+    }</span>
<a href="#l20.586"></a><span id="l20.586" class="difflineplus">+    if (isServer) {</span>
<a href="#l20.587"></a><span id="l20.587" class="difflineplus">+      nsCOMPtr&lt;nsIMsgFolder&gt; inboxFolder;</span>
<a href="#l20.588"></a><span id="l20.588"> </span>
<a href="#l20.589"></a><span id="l20.589">       GetFolderWithFlags(nsMsgFolderFlags::Inbox, getter_AddRefs(inboxFolder));</span>
<a href="#l20.590"></a><span id="l20.590" class="difflineminus">-      if (!inboxFolder)</span>
<a href="#l20.591"></a><span id="l20.591" class="difflineminus">-      {</span>
<a href="#l20.592"></a><span id="l20.592" class="difflineplus">+      if (!inboxFolder) {</span>
<a href="#l20.593"></a><span id="l20.593">         // create an inbox if we don't have one.</span>
<a href="#l20.594"></a><span id="l20.594" class="difflineminus">-        CreateClientSubfolderInfo(NS_LITERAL_CSTRING(&quot;INBOX&quot;), kOnlineHierarchySeparatorUnknown, 0, true);</span>
<a href="#l20.595"></a><span id="l20.595" class="difflineplus">+        CreateClientSubfolderInfo(NS_LITERAL_CSTRING(&quot;INBOX&quot;),</span>
<a href="#l20.596"></a><span id="l20.596" class="difflineplus">+                                  kOnlineHierarchySeparatorUnknown, 0, true);</span>
<a href="#l20.597"></a><span id="l20.597">       }</span>
<a href="#l20.598"></a><span id="l20.598">     }</span>
<a href="#l20.599"></a><span id="l20.599"> </span>
<a href="#l20.600"></a><span id="l20.600">     int32_t count = mSubFolders.Count();</span>
<a href="#l20.601"></a><span id="l20.601">     nsCOMPtr&lt;nsISimpleEnumerator&gt; dummy;</span>
<a href="#l20.602"></a><span id="l20.602">     for (int32_t i = 0; i &lt; count; i++)</span>
<a href="#l20.603"></a><span id="l20.603">       mSubFolders[i]-&gt;GetSubFolders(getter_AddRefs(dummy));</span>
<a href="#l20.604"></a><span id="l20.604"> </span>
<a href="#l20.605"></a><span id="l20.605">     UpdateSummaryTotals(false);</span>
<a href="#l20.606"></a><span id="l20.606">     if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.607"></a><span id="l20.607">   }</span>
<a href="#l20.608"></a><span id="l20.608"> </span>
<a href="#l20.609"></a><span id="l20.609" class="difflineminus">-  return aResult ? NS_NewArrayEnumerator(aResult, mSubFolders, NS_GET_IID(nsIMsgFolder)) : NS_ERROR_NULL_POINTER;</span>
<a href="#l20.610"></a><span id="l20.610" class="difflineminus">-}</span>
<a href="#l20.611"></a><span id="l20.611" class="difflineminus">-</span>
<a href="#l20.612"></a><span id="l20.612" class="difflineminus">-//Makes sure the database is open and exists.  If the database is valid then</span>
<a href="#l20.613"></a><span id="l20.613" class="difflineminus">-//returns NS_OK.  Otherwise returns a failure error value.</span>
<a href="#l20.614"></a><span id="l20.614" class="difflineminus">-nsresult nsImapMailFolder::GetDatabase()</span>
<a href="#l20.615"></a><span id="l20.615" class="difflineminus">-{</span>
<a href="#l20.616"></a><span id="l20.616" class="difflineplus">+  return aResult ? NS_NewArrayEnumerator(aResult, mSubFolders,</span>
<a href="#l20.617"></a><span id="l20.617" class="difflineplus">+                                         NS_GET_IID(nsIMsgFolder))</span>
<a href="#l20.618"></a><span id="l20.618" class="difflineplus">+                 : NS_ERROR_NULL_POINTER;</span>
<a href="#l20.619"></a><span id="l20.619" class="difflineplus">+}</span>
<a href="#l20.620"></a><span id="l20.620" class="difflineplus">+</span>
<a href="#l20.621"></a><span id="l20.621" class="difflineplus">+// Makes sure the database is open and exists.  If the database is valid then</span>
<a href="#l20.622"></a><span id="l20.622" class="difflineplus">+// returns NS_OK.  Otherwise returns a failure error value.</span>
<a href="#l20.623"></a><span id="l20.623" class="difflineplus">+nsresult nsImapMailFolder::GetDatabase() {</span>
<a href="#l20.624"></a><span id="l20.624">   nsresult rv = NS_OK;</span>
<a href="#l20.625"></a><span id="l20.625" class="difflineminus">-  if (!mDatabase)</span>
<a href="#l20.626"></a><span id="l20.626" class="difflineminus">-  {</span>
<a href="#l20.627"></a><span id="l20.627" class="difflineminus">-    nsCOMPtr&lt;nsIMsgDBService&gt; msgDBService = do_GetService(NS_MSGDB_SERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.628"></a><span id="l20.628" class="difflineplus">+  if (!mDatabase) {</span>
<a href="#l20.629"></a><span id="l20.629" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBService&gt; msgDBService =</span>
<a href="#l20.630"></a><span id="l20.630" class="difflineplus">+        do_GetService(NS_MSGDB_SERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.631"></a><span id="l20.631">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.632"></a><span id="l20.632"> </span>
<a href="#l20.633"></a><span id="l20.633">     // Create the database, blowing it away if it needs to be rebuilt</span>
<a href="#l20.634"></a><span id="l20.634">     rv = msgDBService-&gt;OpenFolderDB(this, false, getter_AddRefs(mDatabase));</span>
<a href="#l20.635"></a><span id="l20.635">     if (NS_FAILED(rv))</span>
<a href="#l20.636"></a><span id="l20.636">       rv = msgDBService-&gt;CreateNewDB(this, getter_AddRefs(mDatabase));</span>
<a href="#l20.637"></a><span id="l20.637"> </span>
<a href="#l20.638"></a><span id="l20.638">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.639"></a><span id="l20.639"> </span>
<a href="#l20.640"></a><span id="l20.640" class="difflineminus">-    // UpdateNewMessages/UpdateSummaryTotals can null mDatabase, so we save a local copy</span>
<a href="#l20.641"></a><span id="l20.641" class="difflineplus">+    // UpdateNewMessages/UpdateSummaryTotals can null mDatabase, so we save a</span>
<a href="#l20.642"></a><span id="l20.642" class="difflineplus">+    // local copy</span>
<a href="#l20.643"></a><span id="l20.643">     nsCOMPtr&lt;nsIMsgDatabase&gt; database(mDatabase);</span>
<a href="#l20.644"></a><span id="l20.644">     UpdateNewMessages();</span>
<a href="#l20.645"></a><span id="l20.645" class="difflineminus">-    if(mAddListener)</span>
<a href="#l20.646"></a><span id="l20.646" class="difflineminus">-      database-&gt;AddListener(this);</span>
<a href="#l20.647"></a><span id="l20.647" class="difflineplus">+    if (mAddListener) database-&gt;AddListener(this);</span>
<a href="#l20.648"></a><span id="l20.648">     UpdateSummaryTotals(true);</span>
<a href="#l20.649"></a><span id="l20.649">     mDatabase = database;</span>
<a href="#l20.650"></a><span id="l20.650">   }</span>
<a href="#l20.651"></a><span id="l20.651">   return rv;</span>
<a href="#l20.652"></a><span id="l20.652"> }</span>
<a href="#l20.653"></a><span id="l20.653"> </span>
<a href="#l20.654"></a><span id="l20.654" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::UpdateFolder(nsIMsgWindow * inMsgWindow)</span>
<a href="#l20.655"></a><span id="l20.655" class="difflineminus">-{</span>
<a href="#l20.656"></a><span id="l20.656" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::UpdateFolder(nsIMsgWindow *inMsgWindow) {</span>
<a href="#l20.657"></a><span id="l20.657">   return UpdateFolderWithListener(inMsgWindow, nullptr);</span>
<a href="#l20.658"></a><span id="l20.658"> }</span>
<a href="#l20.659"></a><span id="l20.659"> </span>
<a href="#l20.660"></a><span id="l20.660" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::UpdateFolderWithListener(nsIMsgWindow *aMsgWindow, nsIUrlListener *aUrlListener)</span>
<a href="#l20.661"></a><span id="l20.661" class="difflineminus">-{</span>
<a href="#l20.662"></a><span id="l20.662" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::UpdateFolderWithListener(</span>
<a href="#l20.663"></a><span id="l20.663" class="difflineplus">+    nsIMsgWindow *aMsgWindow, nsIUrlListener *aUrlListener) {</span>
<a href="#l20.664"></a><span id="l20.664">   nsresult rv;</span>
<a href="#l20.665"></a><span id="l20.665">   bool selectFolder = false;</span>
<a href="#l20.666"></a><span id="l20.666"> </span>
<a href="#l20.667"></a><span id="l20.667">   // If this is the inbox, filters will be applied. Otherwise, we test the</span>
<a href="#l20.668"></a><span id="l20.668">   // inherited folder property &quot;applyIncomingFilters&quot; (which defaults to empty).</span>
<a href="#l20.669"></a><span id="l20.669">   // If this inherited property has the string value &quot;true&quot;, we will apply</span>
<a href="#l20.670"></a><span id="l20.670">   // filters even if this is not the inbox folder.</span>
<a href="#l20.671"></a><span id="l20.671">   nsCString applyIncomingFilters;</span>
<a href="#l20.672"></a><span id="l20.672">   GetInheritedStringProperty(&quot;applyIncomingFilters&quot;, applyIncomingFilters);</span>
<a href="#l20.673"></a><span id="l20.673">   m_applyIncomingFilters = applyIncomingFilters.EqualsLiteral(&quot;true&quot;);</span>
<a href="#l20.674"></a><span id="l20.674"> </span>
<a href="#l20.675"></a><span id="l20.675">   nsString folderName;</span>
<a href="#l20.676"></a><span id="l20.676">   GetPrettyName(folderName);</span>
<a href="#l20.677"></a><span id="l20.677" class="difflineminus">-  MOZ_LOG(FILTERLOGMODULE, LogLevel::Debug, (&quot;(Imap) nsImapMailFolder::UpdateFolderWithListener() on folder '%s'&quot;, NS_ConvertUTF16toUTF8(folderName).get()));</span>
<a href="#l20.678"></a><span id="l20.678" class="difflineminus">-  if (mFlags &amp; nsMsgFolderFlags::Inbox || m_applyIncomingFilters)</span>
<a href="#l20.679"></a><span id="l20.679" class="difflineminus">-  {</span>
<a href="#l20.680"></a><span id="l20.680" class="difflineminus">-    MOZ_LOG(FILTERLOGMODULE, LogLevel::Info, (&quot;(Imap) Preparing filter run on folder '%s'&quot;, NS_ConvertUTF16toUTF8(folderName).get()));</span>
<a href="#l20.681"></a><span id="l20.681" class="difflineplus">+  MOZ_LOG(FILTERLOGMODULE, LogLevel::Debug,</span>
<a href="#l20.682"></a><span id="l20.682" class="difflineplus">+          (&quot;(Imap) nsImapMailFolder::UpdateFolderWithListener() on folder '%s'&quot;,</span>
<a href="#l20.683"></a><span id="l20.683" class="difflineplus">+           NS_ConvertUTF16toUTF8(folderName).get()));</span>
<a href="#l20.684"></a><span id="l20.684" class="difflineplus">+  if (mFlags &amp; nsMsgFolderFlags::Inbox || m_applyIncomingFilters) {</span>
<a href="#l20.685"></a><span id="l20.685" class="difflineplus">+    MOZ_LOG(FILTERLOGMODULE, LogLevel::Info,</span>
<a href="#l20.686"></a><span id="l20.686" class="difflineplus">+            (&quot;(Imap) Preparing filter run on folder '%s'&quot;,</span>
<a href="#l20.687"></a><span id="l20.687" class="difflineplus">+             NS_ConvertUTF16toUTF8(folderName).get()));</span>
<a href="#l20.688"></a><span id="l20.688"> </span>
<a href="#l20.689"></a><span id="l20.689">     if (!m_filterList) {</span>
<a href="#l20.690"></a><span id="l20.690">       rv = GetFilterList(aMsgWindow, getter_AddRefs(m_filterList));</span>
<a href="#l20.691"></a><span id="l20.691">       if (NS_FAILED(rv)) {</span>
<a href="#l20.692"></a><span id="l20.692" class="difflineminus">-        MOZ_LOG(FILTERLOGMODULE, LogLevel::Error, (&quot;(Imap) Loading of filter list failed&quot;));</span>
<a href="#l20.693"></a><span id="l20.693" class="difflineplus">+        MOZ_LOG(FILTERLOGMODULE, LogLevel::Error,</span>
<a href="#l20.694"></a><span id="l20.694" class="difflineplus">+                (&quot;(Imap) Loading of filter list failed&quot;));</span>
<a href="#l20.695"></a><span id="l20.695">       }</span>
<a href="#l20.696"></a><span id="l20.696">     }</span>
<a href="#l20.697"></a><span id="l20.697"> </span>
<a href="#l20.698"></a><span id="l20.698">     // if there's no msg window, but someone is updating the inbox, we're</span>
<a href="#l20.699"></a><span id="l20.699">     // doing something biff-like, and may download headers, so make biff notify.</span>
<a href="#l20.700"></a><span id="l20.700">     if (!aMsgWindow &amp;&amp; mFlags &amp; nsMsgFolderFlags::Inbox)</span>
<a href="#l20.701"></a><span id="l20.701">       SetPerformingBiff(true);</span>
<a href="#l20.702"></a><span id="l20.702">   }</span>
<a href="#l20.703"></a><span id="l20.703"> </span>
<a href="#l20.704"></a><span id="l20.704" class="difflineminus">-  if (m_filterList)</span>
<a href="#l20.705"></a><span id="l20.705" class="difflineminus">-  {</span>
<a href="#l20.706"></a><span id="l20.706" class="difflineplus">+  if (m_filterList) {</span>
<a href="#l20.707"></a><span id="l20.707">     nsCString listId;</span>
<a href="#l20.708"></a><span id="l20.708">     m_filterList-&gt;GetListId(listId);</span>
<a href="#l20.709"></a><span id="l20.709" class="difflineminus">-    MOZ_LOG(FILTERLOGMODULE, LogLevel::Info, (&quot;(Imap) Preparing filter list %s&quot;, listId.get()));</span>
<a href="#l20.710"></a><span id="l20.710" class="difflineplus">+    MOZ_LOG(FILTERLOGMODULE, LogLevel::Info,</span>
<a href="#l20.711"></a><span id="l20.711" class="difflineplus">+            (&quot;(Imap) Preparing filter list %s&quot;, listId.get()));</span>
<a href="#l20.712"></a><span id="l20.712">     nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.713"></a><span id="l20.713">     rv = GetServer(getter_AddRefs(server));</span>
<a href="#l20.714"></a><span id="l20.714">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.715"></a><span id="l20.715"> </span>
<a href="#l20.716"></a><span id="l20.716">     bool canFileMessagesOnServer = true;</span>
<a href="#l20.717"></a><span id="l20.717">     rv = server-&gt;GetCanFileMessagesOnServer(&amp;canFileMessagesOnServer);</span>
<a href="#l20.718"></a><span id="l20.718">     // the mdn filter is for filing return receipts into the sent folder</span>
<a href="#l20.719"></a><span id="l20.719">     // some servers (like AOL mail servers)</span>
<a href="#l20.720"></a><span id="l20.720" class="difflineminus">-    // can't file to the sent folder, so we don't add the filter for those servers</span>
<a href="#l20.721"></a><span id="l20.721" class="difflineminus">-    if (canFileMessagesOnServer)</span>
<a href="#l20.722"></a><span id="l20.722" class="difflineminus">-    {</span>
<a href="#l20.723"></a><span id="l20.723" class="difflineplus">+    // can't file to the sent folder, so we don't add the filter for those</span>
<a href="#l20.724"></a><span id="l20.724" class="difflineplus">+    // servers</span>
<a href="#l20.725"></a><span id="l20.725" class="difflineplus">+    if (canFileMessagesOnServer) {</span>
<a href="#l20.726"></a><span id="l20.726">       rv = server-&gt;ConfigureTemporaryFilters(m_filterList);</span>
<a href="#l20.727"></a><span id="l20.727">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.728"></a><span id="l20.728">     }</span>
<a href="#l20.729"></a><span id="l20.729"> </span>
<a href="#l20.730"></a><span id="l20.730">     // If a body filter is enabled for an offline folder, delay the filter</span>
<a href="#l20.731"></a><span id="l20.731">     // application until after message has been downloaded.</span>
<a href="#l20.732"></a><span id="l20.732">     m_filterListRequiresBody = false;</span>
<a href="#l20.733"></a><span id="l20.733"> </span>
<a href="#l20.734"></a><span id="l20.734" class="difflineminus">-    if (mFlags &amp; nsMsgFolderFlags::Offline)</span>
<a href="#l20.735"></a><span id="l20.735" class="difflineminus">-    {</span>
<a href="#l20.736"></a><span id="l20.736" class="difflineplus">+    if (mFlags &amp; nsMsgFolderFlags::Offline) {</span>
<a href="#l20.737"></a><span id="l20.737">       nsCOMPtr&lt;nsIMsgFilterService&gt; filterService =</span>
<a href="#l20.738"></a><span id="l20.738" class="difflineminus">-        do_GetService(NS_MSGFILTERSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.739"></a><span id="l20.739" class="difflineplus">+          do_GetService(NS_MSGFILTERSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.740"></a><span id="l20.740">       uint32_t filterCount = 0;</span>
<a href="#l20.741"></a><span id="l20.741">       m_filterList-&gt;GetFilterCount(&amp;filterCount);</span>
<a href="#l20.742"></a><span id="l20.742" class="difflineminus">-      for (uint32_t index = 0;</span>
<a href="#l20.743"></a><span id="l20.743" class="difflineminus">-           index &lt; filterCount &amp;&amp; !m_filterListRequiresBody;</span>
<a href="#l20.744"></a><span id="l20.744" class="difflineminus">-           ++index)</span>
<a href="#l20.745"></a><span id="l20.745" class="difflineminus">-      {</span>
<a href="#l20.746"></a><span id="l20.746" class="difflineplus">+      for (uint32_t index = 0; index &lt; filterCount &amp;&amp; !m_filterListRequiresBody;</span>
<a href="#l20.747"></a><span id="l20.747" class="difflineplus">+           ++index) {</span>
<a href="#l20.748"></a><span id="l20.748">         nsCOMPtr&lt;nsIMsgFilter&gt; filter;</span>
<a href="#l20.749"></a><span id="l20.749">         m_filterList-&gt;GetFilterAt(index, getter_AddRefs(filter));</span>
<a href="#l20.750"></a><span id="l20.750" class="difflineminus">-        if (!filter)</span>
<a href="#l20.751"></a><span id="l20.751" class="difflineminus">-          continue;</span>
<a href="#l20.752"></a><span id="l20.752" class="difflineplus">+        if (!filter) continue;</span>
<a href="#l20.753"></a><span id="l20.753">         nsMsgFilterTypeType filterType;</span>
<a href="#l20.754"></a><span id="l20.754">         filter-&gt;GetFilterType(&amp;filterType);</span>
<a href="#l20.755"></a><span id="l20.755" class="difflineminus">-        if (!(filterType &amp; nsMsgFilterType::Incoming))</span>
<a href="#l20.756"></a><span id="l20.756" class="difflineminus">-          continue;</span>
<a href="#l20.757"></a><span id="l20.757" class="difflineplus">+        if (!(filterType &amp; nsMsgFilterType::Incoming)) continue;</span>
<a href="#l20.758"></a><span id="l20.758">         bool enabled = false;</span>
<a href="#l20.759"></a><span id="l20.759">         filter-&gt;GetEnabled(&amp;enabled);</span>
<a href="#l20.760"></a><span id="l20.760" class="difflineminus">-        if (!enabled)</span>
<a href="#l20.761"></a><span id="l20.761" class="difflineminus">-          continue;</span>
<a href="#l20.762"></a><span id="l20.762" class="difflineplus">+        if (!enabled) continue;</span>
<a href="#l20.763"></a><span id="l20.763">         nsCOMPtr&lt;nsIMutableArray&gt; searchTerms;</span>
<a href="#l20.764"></a><span id="l20.764">         uint32_t numSearchTerms = 0;</span>
<a href="#l20.765"></a><span id="l20.765">         filter-&gt;GetSearchTerms(getter_AddRefs(searchTerms));</span>
<a href="#l20.766"></a><span id="l20.766" class="difflineminus">-        if (searchTerms)</span>
<a href="#l20.767"></a><span id="l20.767" class="difflineminus">-          searchTerms-&gt;Count(&amp;numSearchTerms);</span>
<a href="#l20.768"></a><span id="l20.768" class="difflineplus">+        if (searchTerms) searchTerms-&gt;Count(&amp;numSearchTerms);</span>
<a href="#l20.769"></a><span id="l20.769">         for (uint32_t termIndex = 0;</span>
<a href="#l20.770"></a><span id="l20.770">              termIndex &lt; numSearchTerms &amp;&amp; !m_filterListRequiresBody;</span>
<a href="#l20.771"></a><span id="l20.771" class="difflineminus">-             termIndex++)</span>
<a href="#l20.772"></a><span id="l20.772" class="difflineminus">-        {</span>
<a href="#l20.773"></a><span id="l20.773" class="difflineminus">-          nsCOMPtr&lt;nsIMsgSearchTerm&gt; term = do_QueryElementAt(searchTerms, termIndex, &amp;rv);</span>
<a href="#l20.774"></a><span id="l20.774" class="difflineplus">+             termIndex++) {</span>
<a href="#l20.775"></a><span id="l20.775" class="difflineplus">+          nsCOMPtr&lt;nsIMsgSearchTerm&gt; term =</span>
<a href="#l20.776"></a><span id="l20.776" class="difflineplus">+              do_QueryElementAt(searchTerms, termIndex, &amp;rv);</span>
<a href="#l20.777"></a><span id="l20.777">           NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.778"></a><span id="l20.778">           nsMsgSearchAttribValue attrib;</span>
<a href="#l20.779"></a><span id="l20.779">           rv = term-&gt;GetAttrib(&amp;attrib);</span>
<a href="#l20.780"></a><span id="l20.780">           NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.781"></a><span id="l20.781">           if (attrib == nsMsgSearchAttrib::Body)</span>
<a href="#l20.782"></a><span id="l20.782">             m_filterListRequiresBody = true;</span>
<a href="#l20.783"></a><span id="l20.783" class="difflineminus">-          else if (attrib == nsMsgSearchAttrib::Custom)</span>
<a href="#l20.784"></a><span id="l20.784" class="difflineminus">-          {</span>
<a href="#l20.785"></a><span id="l20.785" class="difflineplus">+          else if (attrib == nsMsgSearchAttrib::Custom) {</span>
<a href="#l20.786"></a><span id="l20.786">             nsAutoCString customId;</span>
<a href="#l20.787"></a><span id="l20.787">             rv = term-&gt;GetCustomId(customId);</span>
<a href="#l20.788"></a><span id="l20.788">             nsCOMPtr&lt;nsIMsgSearchCustomTerm&gt; customTerm;</span>
<a href="#l20.789"></a><span id="l20.789">             if (NS_SUCCEEDED(rv) &amp;&amp; filterService)</span>
<a href="#l20.790"></a><span id="l20.790">               rv = filterService-&gt;GetCustomTerm(customId,</span>
<a href="#l20.791"></a><span id="l20.791">                                                 getter_AddRefs(customTerm));</span>
<a href="#l20.792"></a><span id="l20.792">             bool needsBody = false;</span>
<a href="#l20.793"></a><span id="l20.793">             if (NS_SUCCEEDED(rv) &amp;&amp; customTerm)</span>
<a href="#l20.794"></a><span id="l20.794">               rv = customTerm-&gt;GetNeedsBody(&amp;needsBody);</span>
<a href="#l20.795"></a><span id="l20.795" class="difflineminus">-            if (NS_SUCCEEDED(rv) &amp;&amp; needsBody)</span>
<a href="#l20.796"></a><span id="l20.796" class="difflineminus">-              m_filterListRequiresBody = true;</span>
<a href="#l20.797"></a><span id="l20.797" class="difflineplus">+            if (NS_SUCCEEDED(rv) &amp;&amp; needsBody) m_filterListRequiresBody = true;</span>
<a href="#l20.798"></a><span id="l20.798">           }</span>
<a href="#l20.799"></a><span id="l20.799">         }</span>
<a href="#l20.800"></a><span id="l20.800"> </span>
<a href="#l20.801"></a><span id="l20.801">         // Also check if filter actions need the body, as this</span>
<a href="#l20.802"></a><span id="l20.802">         // is supported in custom actions.</span>
<a href="#l20.803"></a><span id="l20.803">         uint32_t numActions = 0;</span>
<a href="#l20.804"></a><span id="l20.804">         filter-&gt;GetActionCount(&amp;numActions);</span>
<a href="#l20.805"></a><span id="l20.805">         for (uint32_t actionIndex = 0;</span>
<a href="#l20.806"></a><span id="l20.806">              actionIndex &lt; numActions &amp;&amp; !m_filterListRequiresBody;</span>
<a href="#l20.807"></a><span id="l20.807" class="difflineminus">-             actionIndex++)</span>
<a href="#l20.808"></a><span id="l20.808" class="difflineminus">-        {</span>
<a href="#l20.809"></a><span id="l20.809" class="difflineplus">+             actionIndex++) {</span>
<a href="#l20.810"></a><span id="l20.810">           nsCOMPtr&lt;nsIMsgRuleAction&gt; action;</span>
<a href="#l20.811"></a><span id="l20.811">           rv = filter-&gt;GetActionAt(actionIndex, getter_AddRefs(action));</span>
<a href="#l20.812"></a><span id="l20.812" class="difflineminus">-          if (NS_FAILED(rv) || !action)</span>
<a href="#l20.813"></a><span id="l20.813" class="difflineminus">-            continue;</span>
<a href="#l20.814"></a><span id="l20.814" class="difflineplus">+          if (NS_FAILED(rv) || !action) continue;</span>
<a href="#l20.815"></a><span id="l20.815"> </span>
<a href="#l20.816"></a><span id="l20.816">           nsCOMPtr&lt;nsIMsgFilterCustomAction&gt; customAction;</span>
<a href="#l20.817"></a><span id="l20.817">           rv = action-&gt;GetCustomAction(getter_AddRefs(customAction));</span>
<a href="#l20.818"></a><span id="l20.818" class="difflineminus">-          if (NS_FAILED(rv) || !customAction)</span>
<a href="#l20.819"></a><span id="l20.819" class="difflineminus">-            continue;</span>
<a href="#l20.820"></a><span id="l20.820" class="difflineplus">+          if (NS_FAILED(rv) || !customAction) continue;</span>
<a href="#l20.821"></a><span id="l20.821"> </span>
<a href="#l20.822"></a><span id="l20.822">           bool needsBody = false;</span>
<a href="#l20.823"></a><span id="l20.823">           customAction-&gt;GetNeedsBody(&amp;needsBody);</span>
<a href="#l20.824"></a><span id="l20.824" class="difflineminus">-          if (needsBody)</span>
<a href="#l20.825"></a><span id="l20.825" class="difflineminus">-            m_filterListRequiresBody = true;</span>
<a href="#l20.826"></a><span id="l20.826" class="difflineplus">+          if (needsBody) m_filterListRequiresBody = true;</span>
<a href="#l20.827"></a><span id="l20.827">         }</span>
<a href="#l20.828"></a><span id="l20.828">       }</span>
<a href="#l20.829"></a><span id="l20.829">     }</span>
<a href="#l20.830"></a><span id="l20.830" class="difflineminus">-    MOZ_LOG(FILTERLOGMODULE, LogLevel::Info, (&quot;(Imap) Filters require the message body: %s&quot;,</span>
<a href="#l20.831"></a><span id="l20.831" class="difflineminus">-                                              (m_filterListRequiresBody ? &quot;true&quot; : &quot;false&quot;)));</span>
<a href="#l20.832"></a><span id="l20.832" class="difflineplus">+    MOZ_LOG(FILTERLOGMODULE, LogLevel::Info,</span>
<a href="#l20.833"></a><span id="l20.833" class="difflineplus">+            (&quot;(Imap) Filters require the message body: %s&quot;,</span>
<a href="#l20.834"></a><span id="l20.834" class="difflineplus">+             (m_filterListRequiresBody ? &quot;true&quot; : &quot;false&quot;)));</span>
<a href="#l20.835"></a><span id="l20.835">   }</span>
<a href="#l20.836"></a><span id="l20.836"> </span>
<a href="#l20.837"></a><span id="l20.837">   selectFolder = true;</span>
<a href="#l20.838"></a><span id="l20.838"> </span>
<a href="#l20.839"></a><span id="l20.839">   bool isServer;</span>
<a href="#l20.840"></a><span id="l20.840">   rv = GetIsServer(&amp;isServer);</span>
<a href="#l20.841"></a><span id="l20.841" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; isServer)</span>
<a href="#l20.842"></a><span id="l20.842" class="difflineminus">-  {</span>
<a href="#l20.843"></a><span id="l20.843" class="difflineminus">-    if (!m_haveDiscoveredAllFolders)</span>
<a href="#l20.844"></a><span id="l20.844" class="difflineminus">-    {</span>
<a href="#l20.845"></a><span id="l20.845" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; isServer) {</span>
<a href="#l20.846"></a><span id="l20.846" class="difflineplus">+    if (!m_haveDiscoveredAllFolders) {</span>
<a href="#l20.847"></a><span id="l20.847">       bool hasSubFolders = false;</span>
<a href="#l20.848"></a><span id="l20.848">       GetHasSubFolders(&amp;hasSubFolders);</span>
<a href="#l20.849"></a><span id="l20.849" class="difflineminus">-      if (!hasSubFolders)</span>
<a href="#l20.850"></a><span id="l20.850" class="difflineminus">-      {</span>
<a href="#l20.851"></a><span id="l20.851" class="difflineminus">-        rv = CreateClientSubfolderInfo(NS_LITERAL_CSTRING(&quot;Inbox&quot;), kOnlineHierarchySeparatorUnknown,0, false);</span>
<a href="#l20.852"></a><span id="l20.852" class="difflineplus">+      if (!hasSubFolders) {</span>
<a href="#l20.853"></a><span id="l20.853" class="difflineplus">+        rv = CreateClientSubfolderInfo(NS_LITERAL_CSTRING(&quot;Inbox&quot;),</span>
<a href="#l20.854"></a><span id="l20.854" class="difflineplus">+                                       kOnlineHierarchySeparatorUnknown, 0,</span>
<a href="#l20.855"></a><span id="l20.855" class="difflineplus">+                                       false);</span>
<a href="#l20.856"></a><span id="l20.856">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.857"></a><span id="l20.857">       }</span>
<a href="#l20.858"></a><span id="l20.858">       m_haveDiscoveredAllFolders = true;</span>
<a href="#l20.859"></a><span id="l20.859">     }</span>
<a href="#l20.860"></a><span id="l20.860">     selectFolder = false;</span>
<a href="#l20.861"></a><span id="l20.861">   }</span>
<a href="#l20.862"></a><span id="l20.862">   rv = GetDatabase();</span>
<a href="#l20.863"></a><span id="l20.863" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l20.864"></a><span id="l20.864" class="difflineminus">-  {</span>
<a href="#l20.865"></a><span id="l20.865" class="difflineplus">+  if (NS_FAILED(rv)) {</span>
<a href="#l20.866"></a><span id="l20.866">     ThrowAlertMsg(&quot;errorGettingDB&quot;, aMsgWindow);</span>
<a href="#l20.867"></a><span id="l20.867">     return rv;</span>
<a href="#l20.868"></a><span id="l20.868">   }</span>
<a href="#l20.869"></a><span id="l20.869">   bool canOpenThisFolder = true;</span>
<a href="#l20.870"></a><span id="l20.870">   GetCanOpenFolder(&amp;canOpenThisFolder);</span>
<a href="#l20.871"></a><span id="l20.871"> </span>
<a href="#l20.872"></a><span id="l20.872">   bool hasOfflineEvents = false;</span>
<a href="#l20.873"></a><span id="l20.873">   GetFlag(nsMsgFolderFlags::OfflineEvents, &amp;hasOfflineEvents);</span>
<a href="#l20.874"></a><span id="l20.874"> </span>
<a href="#l20.875"></a><span id="l20.875" class="difflineminus">-  if (!WeAreOffline())</span>
<a href="#l20.876"></a><span id="l20.876" class="difflineminus">-  {</span>
<a href="#l20.877"></a><span id="l20.877" class="difflineminus">-    if (hasOfflineEvents)</span>
<a href="#l20.878"></a><span id="l20.878" class="difflineminus">-    {</span>
<a href="#l20.879"></a><span id="l20.879" class="difflineplus">+  if (!WeAreOffline()) {</span>
<a href="#l20.880"></a><span id="l20.880" class="difflineplus">+    if (hasOfflineEvents) {</span>
<a href="#l20.881"></a><span id="l20.881">       // hold a reference to the offline sync object. If ProcessNextOperation</span>
<a href="#l20.882"></a><span id="l20.882">       // runs a url, a reference will be added to it. Otherwise, it will get</span>
<a href="#l20.883"></a><span id="l20.883">       // destroyed when the refptr goes out of scope.</span>
<a href="#l20.884"></a><span id="l20.884" class="difflineminus">-      RefPtr&lt;nsImapOfflineSync&gt; goOnline = new nsImapOfflineSync(aMsgWindow, this, this);</span>
<a href="#l20.885"></a><span id="l20.885" class="difflineminus">-      if (goOnline)</span>
<a href="#l20.886"></a><span id="l20.886" class="difflineminus">-      {</span>
<a href="#l20.887"></a><span id="l20.887" class="difflineplus">+      RefPtr&lt;nsImapOfflineSync&gt; goOnline =</span>
<a href="#l20.888"></a><span id="l20.888" class="difflineplus">+          new nsImapOfflineSync(aMsgWindow, this, this);</span>
<a href="#l20.889"></a><span id="l20.889" class="difflineplus">+      if (goOnline) {</span>
<a href="#l20.890"></a><span id="l20.890">         m_urlListener = aUrlListener;</span>
<a href="#l20.891"></a><span id="l20.891">         return goOnline-&gt;ProcessNextOperation();</span>
<a href="#l20.892"></a><span id="l20.892">       }</span>
<a href="#l20.893"></a><span id="l20.893">     }</span>
<a href="#l20.894"></a><span id="l20.894">   }</span>
<a href="#l20.895"></a><span id="l20.895"> </span>
<a href="#l20.896"></a><span id="l20.896">   // Check it we're password protecting the local store.</span>
<a href="#l20.897"></a><span id="l20.897" class="difflineminus">-  if (!PromptForMasterPasswordIfNecessary())</span>
<a href="#l20.898"></a><span id="l20.898" class="difflineminus">-    return NS_ERROR_FAILURE;</span>
<a href="#l20.899"></a><span id="l20.899" class="difflineminus">-</span>
<a href="#l20.900"></a><span id="l20.900" class="difflineminus">-  if (!canOpenThisFolder)</span>
<a href="#l20.901"></a><span id="l20.901" class="difflineminus">-    selectFolder = false;</span>
<a href="#l20.902"></a><span id="l20.902" class="difflineplus">+  if (!PromptForMasterPasswordIfNecessary()) return NS_ERROR_FAILURE;</span>
<a href="#l20.903"></a><span id="l20.903" class="difflineplus">+</span>
<a href="#l20.904"></a><span id="l20.904" class="difflineplus">+  if (!canOpenThisFolder) selectFolder = false;</span>
<a href="#l20.905"></a><span id="l20.905">   // don't run select if we can't select the folder...</span>
<a href="#l20.906"></a><span id="l20.906" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; !m_urlRunning &amp;&amp; selectFolder)</span>
<a href="#l20.907"></a><span id="l20.907" class="difflineminus">-  {</span>
<a href="#l20.908"></a><span id="l20.908" class="difflineminus">-    nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.909"></a><span id="l20.909" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; !m_urlRunning &amp;&amp; selectFolder) {</span>
<a href="#l20.910"></a><span id="l20.910" class="difflineplus">+    nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.911"></a><span id="l20.911" class="difflineplus">+        do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.912"></a><span id="l20.912">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.913"></a><span id="l20.913"> </span>
<a href="#l20.914"></a><span id="l20.914" class="difflineminus">-    nsCOMPtr &lt;nsIURI&gt; url;</span>
<a href="#l20.915"></a><span id="l20.915" class="difflineminus">-    rv = imapService-&gt;SelectFolder(this, m_urlListener, aMsgWindow, getter_AddRefs(url));</span>
<a href="#l20.916"></a><span id="l20.916" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l20.917"></a><span id="l20.917" class="difflineminus">-    {</span>
<a href="#l20.918"></a><span id="l20.918" class="difflineplus">+    nsCOMPtr&lt;nsIURI&gt; url;</span>
<a href="#l20.919"></a><span id="l20.919" class="difflineplus">+    rv = imapService-&gt;SelectFolder(this, m_urlListener, aMsgWindow,</span>
<a href="#l20.920"></a><span id="l20.920" class="difflineplus">+                                   getter_AddRefs(url));</span>
<a href="#l20.921"></a><span id="l20.921" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.922"></a><span id="l20.922">       m_urlRunning = true;</span>
<a href="#l20.923"></a><span id="l20.923">       m_updatingFolder = true;</span>
<a href="#l20.924"></a><span id="l20.924">     }</span>
<a href="#l20.925"></a><span id="l20.925" class="difflineminus">-    if (url)</span>
<a href="#l20.926"></a><span id="l20.926" class="difflineminus">-    {</span>
<a href="#l20.927"></a><span id="l20.927" class="difflineminus">-      nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(url, &amp;rv);</span>
<a href="#l20.928"></a><span id="l20.928" class="difflineplus">+    if (url) {</span>
<a href="#l20.929"></a><span id="l20.929" class="difflineplus">+      nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(url, &amp;rv);</span>
<a href="#l20.930"></a><span id="l20.930">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.931"></a><span id="l20.931">       mailnewsUrl-&gt;RegisterListener(this);</span>
<a href="#l20.932"></a><span id="l20.932">       m_urlListener = aUrlListener;</span>
<a href="#l20.933"></a><span id="l20.933">     }</span>
<a href="#l20.934"></a><span id="l20.934"> </span>
<a href="#l20.935"></a><span id="l20.935">     // Allow IMAP folder auto-compact to occur when online or offline.</span>
<a href="#l20.936"></a><span id="l20.936" class="difflineminus">-    if (aMsgWindow)</span>
<a href="#l20.937"></a><span id="l20.937" class="difflineminus">-      AutoCompact(aMsgWindow);</span>
<a href="#l20.938"></a><span id="l20.938" class="difflineminus">-</span>
<a href="#l20.939"></a><span id="l20.939" class="difflineminus">-    if (rv == NS_MSG_ERROR_OFFLINE || rv == NS_BINDING_ABORTED)</span>
<a href="#l20.940"></a><span id="l20.940" class="difflineminus">-    {</span>
<a href="#l20.941"></a><span id="l20.941" class="difflineplus">+    if (aMsgWindow) AutoCompact(aMsgWindow);</span>
<a href="#l20.942"></a><span id="l20.942" class="difflineplus">+</span>
<a href="#l20.943"></a><span id="l20.943" class="difflineplus">+    if (rv == NS_MSG_ERROR_OFFLINE || rv == NS_BINDING_ABORTED) {</span>
<a href="#l20.944"></a><span id="l20.944">       rv = NS_OK;</span>
<a href="#l20.945"></a><span id="l20.945">       NotifyFolderEvent(kFolderLoaded);</span>
<a href="#l20.946"></a><span id="l20.946">     }</span>
<a href="#l20.947"></a><span id="l20.947" class="difflineminus">-  }</span>
<a href="#l20.948"></a><span id="l20.948" class="difflineminus">-  else if (NS_SUCCEEDED(rv))  // tell the front end that the folder is loaded if we're not going to</span>
<a href="#l20.949"></a><span id="l20.949" class="difflineminus">-  {                           // actually run a url.</span>
<a href="#l20.950"></a><span id="l20.950" class="difflineminus">-    if (!m_updatingFolder)    // if we're already running an update url, we'll let that one send the folder loaded</span>
<a href="#l20.951"></a><span id="l20.951" class="difflineplus">+  } else if (NS_SUCCEEDED(rv))  // tell the front end that the folder is loaded</span>
<a href="#l20.952"></a><span id="l20.952" class="difflineplus">+                                // if we're not going to</span>
<a href="#l20.953"></a><span id="l20.953" class="difflineplus">+  {                             // actually run a url.</span>
<a href="#l20.954"></a><span id="l20.954" class="difflineplus">+    if (!m_updatingFolder)  // if we're already running an update url, we'll let</span>
<a href="#l20.955"></a><span id="l20.955" class="difflineplus">+                            // that one send the folder loaded</span>
<a href="#l20.956"></a><span id="l20.956">       NotifyFolderEvent(kFolderLoaded);</span>
<a href="#l20.957"></a><span id="l20.957">   }</span>
<a href="#l20.958"></a><span id="l20.958">   return rv;</span>
<a href="#l20.959"></a><span id="l20.959"> }</span>
<a href="#l20.960"></a><span id="l20.960"> </span>
<a href="#l20.961"></a><span id="l20.961" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetMessages(nsISimpleEnumerator* *result)</span>
<a href="#l20.962"></a><span id="l20.962" class="difflineminus">-{</span>
<a href="#l20.963"></a><span id="l20.963" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetMessages(nsISimpleEnumerator **result) {</span>
<a href="#l20.964"></a><span id="l20.964">   NS_ENSURE_ARG_POINTER(result);</span>
<a href="#l20.965"></a><span id="l20.965" class="difflineminus">-  if (!mDatabase)</span>
<a href="#l20.966"></a><span id="l20.966" class="difflineminus">-    GetDatabase();</span>
<a href="#l20.967"></a><span id="l20.967" class="difflineminus">-  if (mDatabase)</span>
<a href="#l20.968"></a><span id="l20.968" class="difflineminus">-    return mDatabase-&gt;EnumerateMessages(result);</span>
<a href="#l20.969"></a><span id="l20.969" class="difflineplus">+  if (!mDatabase) GetDatabase();</span>
<a href="#l20.970"></a><span id="l20.970" class="difflineplus">+  if (mDatabase) return mDatabase-&gt;EnumerateMessages(result);</span>
<a href="#l20.971"></a><span id="l20.971">   return NS_ERROR_UNEXPECTED;</span>
<a href="#l20.972"></a><span id="l20.972"> }</span>
<a href="#l20.973"></a><span id="l20.973"> </span>
<a href="#l20.974"></a><span id="l20.974" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::CreateSubfolder(const nsAString&amp; folderName, nsIMsgWindow *msgWindow)</span>
<a href="#l20.975"></a><span id="l20.975" class="difflineminus">-{</span>
<a href="#l20.976"></a><span id="l20.976" class="difflineminus">-  if (folderName.IsEmpty())</span>
<a href="#l20.977"></a><span id="l20.977" class="difflineminus">-    return NS_MSG_ERROR_INVALID_FOLDER_NAME;</span>
<a href="#l20.978"></a><span id="l20.978" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::CreateSubfolder(const nsAString &amp;folderName,</span>
<a href="#l20.979"></a><span id="l20.979" class="difflineplus">+                                                nsIMsgWindow *msgWindow) {</span>
<a href="#l20.980"></a><span id="l20.980" class="difflineplus">+  if (folderName.IsEmpty()) return NS_MSG_ERROR_INVALID_FOLDER_NAME;</span>
<a href="#l20.981"></a><span id="l20.981"> </span>
<a href="#l20.982"></a><span id="l20.982">   nsresult rv;</span>
<a href="#l20.983"></a><span id="l20.983">   nsAutoString trashName;</span>
<a href="#l20.984"></a><span id="l20.984">   GetTrashFolderName(trashName);</span>
<a href="#l20.985"></a><span id="l20.985" class="difflineminus">-  if ( folderName.Equals(trashName))   // Trash , a special folder</span>
<a href="#l20.986"></a><span id="l20.986" class="difflineplus">+  if (folderName.Equals(trashName))  // Trash , a special folder</span>
<a href="#l20.987"></a><span id="l20.987">   {</span>
<a href="#l20.988"></a><span id="l20.988">     ThrowAlertMsg(&quot;folderExists&quot;, msgWindow);</span>
<a href="#l20.989"></a><span id="l20.989">     return NS_MSG_FOLDER_EXISTS;</span>
<a href="#l20.990"></a><span id="l20.990">   }</span>
<a href="#l20.991"></a><span id="l20.991" class="difflineminus">-  if (mIsServer &amp;&amp; folderName.LowerCaseEqualsLiteral(&quot;inbox&quot;))  // Inbox, a special folder</span>
<a href="#l20.992"></a><span id="l20.992" class="difflineplus">+  if (mIsServer &amp;&amp;</span>
<a href="#l20.993"></a><span id="l20.993" class="difflineplus">+      folderName.LowerCaseEqualsLiteral(&quot;inbox&quot;))  // Inbox, a special folder</span>
<a href="#l20.994"></a><span id="l20.994">   {</span>
<a href="#l20.995"></a><span id="l20.995">     ThrowAlertMsg(&quot;folderExists&quot;, msgWindow);</span>
<a href="#l20.996"></a><span id="l20.996">     return NS_MSG_FOLDER_EXISTS;</span>
<a href="#l20.997"></a><span id="l20.997">   }</span>
<a href="#l20.998"></a><span id="l20.998"> </span>
<a href="#l20.999"></a><span id="l20.999" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1000"></a><span id="l20.1000" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.1001"></a><span id="l20.1001" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.1002"></a><span id="l20.1002" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1003"></a><span id="l20.1003" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1004"></a><span id="l20.1004"> </span>
<a href="#l20.1005"></a><span id="l20.1005">   return imapService-&gt;CreateFolder(this, folderName, this, nullptr);</span>
<a href="#l20.1006"></a><span id="l20.1006"> }</span>
<a href="#l20.1007"></a><span id="l20.1007"> </span>
<a href="#l20.1008"></a><span id="l20.1008" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::CreateClientSubfolderInfo(const nsACString&amp; folderName,</span>
<a href="#l20.1009"></a><span id="l20.1009" class="difflineminus">-                                                          char hierarchyDelimiter,</span>
<a href="#l20.1010"></a><span id="l20.1010" class="difflineminus">-                                                          int32_t flags,</span>
<a href="#l20.1011"></a><span id="l20.1011" class="difflineminus">-                                                          bool suppressNotification)</span>
<a href="#l20.1012"></a><span id="l20.1012" class="difflineminus">-{</span>
<a href="#l20.1013"></a><span id="l20.1013" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::CreateClientSubfolderInfo(</span>
<a href="#l20.1014"></a><span id="l20.1014" class="difflineplus">+    const nsACString &amp;folderName, char hierarchyDelimiter, int32_t flags,</span>
<a href="#l20.1015"></a><span id="l20.1015" class="difflineplus">+    bool suppressNotification) {</span>
<a href="#l20.1016"></a><span id="l20.1016">   nsresult rv = NS_OK;</span>
<a href="#l20.1017"></a><span id="l20.1017"> </span>
<a href="#l20.1018"></a><span id="l20.1018" class="difflineminus">-  //Get a directory based on our current path.</span>
<a href="#l20.1019"></a><span id="l20.1019" class="difflineminus">-  nsCOMPtr &lt;nsIFile&gt; path;</span>
<a href="#l20.1020"></a><span id="l20.1020" class="difflineplus">+  // Get a directory based on our current path.</span>
<a href="#l20.1021"></a><span id="l20.1021" class="difflineplus">+  nsCOMPtr&lt;nsIFile&gt; path;</span>
<a href="#l20.1022"></a><span id="l20.1022">   rv = CreateDirectoryForFolder(getter_AddRefs(path));</span>
<a href="#l20.1023"></a><span id="l20.1023" class="difflineminus">-  if(NS_FAILED(rv))</span>
<a href="#l20.1024"></a><span id="l20.1024" class="difflineminus">-    return rv;</span>
<a href="#l20.1025"></a><span id="l20.1025" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.1026"></a><span id="l20.1026"> </span>
<a href="#l20.1027"></a><span id="l20.1027">   NS_ConvertASCIItoUTF16 leafName(folderName);</span>
<a href="#l20.1028"></a><span id="l20.1028">   nsAutoString folderNameStr;</span>
<a href="#l20.1029"></a><span id="l20.1029">   nsAutoString parentName = leafName;</span>
<a href="#l20.1030"></a><span id="l20.1030">   // use RFind, because folder can start with a delimiter and</span>
<a href="#l20.1031"></a><span id="l20.1031">   // not be a leaf folder.</span>
<a href="#l20.1032"></a><span id="l20.1032">   int32_t folderStart = leafName.RFindChar('/');</span>
<a href="#l20.1033"></a><span id="l20.1033" class="difflineminus">-  if (folderStart &gt; 0)</span>
<a href="#l20.1034"></a><span id="l20.1034" class="difflineminus">-  {</span>
<a href="#l20.1035"></a><span id="l20.1035" class="difflineplus">+  if (folderStart &gt; 0) {</span>
<a href="#l20.1036"></a><span id="l20.1036">     nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder;</span>
<a href="#l20.1037"></a><span id="l20.1037" class="difflineminus">-    nsAutoCString uri (mURI);</span>
<a href="#l20.1038"></a><span id="l20.1038" class="difflineplus">+    nsAutoCString uri(mURI);</span>
<a href="#l20.1039"></a><span id="l20.1039">     leafName.Assign(Substring(parentName, folderStart + 1));</span>
<a href="#l20.1040"></a><span id="l20.1040">     parentName.SetLength(folderStart);</span>
<a href="#l20.1041"></a><span id="l20.1041"> </span>
<a href="#l20.1042"></a><span id="l20.1042">     rv = CreateDirectoryForFolder(getter_AddRefs(path));</span>
<a href="#l20.1043"></a><span id="l20.1043">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1044"></a><span id="l20.1044">     uri.Append('/');</span>
<a href="#l20.1045"></a><span id="l20.1045">     uri.Append(NS_LossyConvertUTF16toASCII(parentName));</span>
<a href="#l20.1046"></a><span id="l20.1046">     nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l20.1047"></a><span id="l20.1047">     rv = GetOrCreateFolder(uri, getter_AddRefs(folder));</span>
<a href="#l20.1048"></a><span id="l20.1048">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1049"></a><span id="l20.1049">     imapFolder = do_QueryInterface(folder, &amp;rv);</span>
<a href="#l20.1050"></a><span id="l20.1050">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1051"></a><span id="l20.1051">     nsAutoCString leafnameC;</span>
<a href="#l20.1052"></a><span id="l20.1052">     LossyCopyUTF16toASCII(leafName, leafnameC);</span>
<a href="#l20.1053"></a><span id="l20.1053" class="difflineminus">-    return imapFolder-&gt;CreateClientSubfolderInfo(leafnameC, hierarchyDelimiter,flags, suppressNotification);</span>
<a href="#l20.1054"></a><span id="l20.1054" class="difflineplus">+    return imapFolder-&gt;CreateClientSubfolderInfo(leafnameC, hierarchyDelimiter,</span>
<a href="#l20.1055"></a><span id="l20.1055" class="difflineplus">+                                                 flags, suppressNotification);</span>
<a href="#l20.1056"></a><span id="l20.1056">   }</span>
<a href="#l20.1057"></a><span id="l20.1057"> </span>
<a href="#l20.1058"></a><span id="l20.1058">   // if we get here, it's really a leaf, and &quot;this&quot; is the parent.</span>
<a href="#l20.1059"></a><span id="l20.1059">   folderNameStr = leafName;</span>
<a href="#l20.1060"></a><span id="l20.1060"> </span>
<a href="#l20.1061"></a><span id="l20.1061">   // Create an empty database for this mail folder, set its name from the user</span>
<a href="#l20.1062"></a><span id="l20.1062">   nsCOMPtr&lt;nsIMsgDatabase&gt; mailDBFactory;</span>
<a href="#l20.1063"></a><span id="l20.1063">   nsCOMPtr&lt;nsIMsgFolder&gt; child;</span>
<a href="#l20.1064"></a><span id="l20.1064"> </span>
<a href="#l20.1065"></a><span id="l20.1065" class="difflineminus">-  nsCOMPtr&lt;nsIMsgDBService&gt; msgDBService = do_GetService(NS_MSGDB_SERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1066"></a><span id="l20.1066" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBService&gt; msgDBService =</span>
<a href="#l20.1067"></a><span id="l20.1067" class="difflineplus">+      do_GetService(NS_MSGDB_SERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1068"></a><span id="l20.1068">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1069"></a><span id="l20.1069">   nsCOMPtr&lt;nsIMsgDatabase&gt; unusedDB;</span>
<a href="#l20.1070"></a><span id="l20.1070" class="difflineminus">-  nsCOMPtr &lt;nsIFile&gt; dbFile;</span>
<a href="#l20.1071"></a><span id="l20.1071" class="difflineplus">+  nsCOMPtr&lt;nsIFile&gt; dbFile;</span>
<a href="#l20.1072"></a><span id="l20.1072"> </span>
<a href="#l20.1073"></a><span id="l20.1073">   // warning, path will be changed</span>
<a href="#l20.1074"></a><span id="l20.1074">   rv = CreateFileForDB(folderNameStr, path, getter_AddRefs(dbFile));</span>
<a href="#l20.1075"></a><span id="l20.1075" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.1076"></a><span id="l20.1076" class="difflineminus">-</span>
<a href="#l20.1077"></a><span id="l20.1077" class="difflineminus">-  //Now let's create the actual new folder</span>
<a href="#l20.1078"></a><span id="l20.1078" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1079"></a><span id="l20.1079" class="difflineplus">+</span>
<a href="#l20.1080"></a><span id="l20.1080" class="difflineplus">+  // Now let's create the actual new folder</span>
<a href="#l20.1081"></a><span id="l20.1081">   rv = AddSubfolderWithPath(folderNameStr, dbFile, getter_AddRefs(child), true);</span>
<a href="#l20.1082"></a><span id="l20.1082">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1083"></a><span id="l20.1083">   rv = msgDBService-&gt;OpenMailDBFromFile(dbFile, child, true, true,</span>
<a href="#l20.1084"></a><span id="l20.1084">                                         getter_AddRefs(unusedDB));</span>
<a href="#l20.1085"></a><span id="l20.1085" class="difflineminus">-  if (rv == NS_MSG_ERROR_FOLDER_SUMMARY_MISSING)</span>
<a href="#l20.1086"></a><span id="l20.1086" class="difflineminus">-    rv = NS_OK;</span>
<a href="#l20.1087"></a><span id="l20.1087" class="difflineminus">-</span>
<a href="#l20.1088"></a><span id="l20.1088" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; unusedDB)</span>
<a href="#l20.1089"></a><span id="l20.1089" class="difflineminus">-  {</span>
<a href="#l20.1090"></a><span id="l20.1090" class="difflineminus">-  //need to set the folder name</span>
<a href="#l20.1091"></a><span id="l20.1091" class="difflineminus">-    nsCOMPtr &lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l20.1092"></a><span id="l20.1092" class="difflineplus">+  if (rv == NS_MSG_ERROR_FOLDER_SUMMARY_MISSING) rv = NS_OK;</span>
<a href="#l20.1093"></a><span id="l20.1093" class="difflineplus">+</span>
<a href="#l20.1094"></a><span id="l20.1094" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; unusedDB) {</span>
<a href="#l20.1095"></a><span id="l20.1095" class="difflineplus">+    // need to set the folder name</span>
<a href="#l20.1096"></a><span id="l20.1096" class="difflineplus">+    nsCOMPtr&lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l20.1097"></a><span id="l20.1097">     rv = unusedDB-&gt;GetDBFolderInfo(getter_AddRefs(folderInfo));</span>
<a href="#l20.1098"></a><span id="l20.1098" class="difflineminus">-    nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(child, &amp;rv);</span>
<a href="#l20.1099"></a><span id="l20.1099" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l20.1100"></a><span id="l20.1100" class="difflineminus">-    {</span>
<a href="#l20.1101"></a><span id="l20.1101" class="difflineplus">+    nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(child, &amp;rv);</span>
<a href="#l20.1102"></a><span id="l20.1102" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.1103"></a><span id="l20.1103">       nsAutoCString onlineName(m_onlineFolderName);</span>
<a href="#l20.1104"></a><span id="l20.1104" class="difflineminus">-      if (!onlineName.IsEmpty())</span>
<a href="#l20.1105"></a><span id="l20.1105" class="difflineminus">-        onlineName.Append(hierarchyDelimiter);</span>
<a href="#l20.1106"></a><span id="l20.1106" class="difflineplus">+      if (!onlineName.IsEmpty()) onlineName.Append(hierarchyDelimiter);</span>
<a href="#l20.1107"></a><span id="l20.1107">       onlineName.Append(NS_LossyConvertUTF16toASCII(folderNameStr));</span>
<a href="#l20.1108"></a><span id="l20.1108">       imapFolder-&gt;SetVerifiedAsOnlineFolder(true);</span>
<a href="#l20.1109"></a><span id="l20.1109">       imapFolder-&gt;SetOnlineName(onlineName);</span>
<a href="#l20.1110"></a><span id="l20.1110">       imapFolder-&gt;SetHierarchyDelimiter(hierarchyDelimiter);</span>
<a href="#l20.1111"></a><span id="l20.1111">       imapFolder-&gt;SetBoxFlags(flags);</span>
<a href="#l20.1112"></a><span id="l20.1112"> </span>
<a href="#l20.1113"></a><span id="l20.1113">       // Now that the child is created and the boxflags are set we can be sure</span>
<a href="#l20.1114"></a><span id="l20.1114">       // all special folder flags are known. The child may get its flags already</span>
<a href="#l20.1115"></a><span id="l20.1115">       // in AddSubfolderWithPath if they were in FolderCache, but that's</span>
<a href="#l20.1116"></a><span id="l20.1116">       // not always the case.</span>
<a href="#l20.1117"></a><span id="l20.1117">       uint32_t flags = 0;</span>
<a href="#l20.1118"></a><span id="l20.1118">       child-&gt;GetFlags(&amp;flags);</span>
<a href="#l20.1119"></a><span id="l20.1119"> </span>
<a href="#l20.1120"></a><span id="l20.1120">       // Set the offline use flag for the newly created folder if the</span>
<a href="#l20.1121"></a><span id="l20.1121">       // offline_download preference is true, unless it's the Trash or Junk</span>
<a href="#l20.1122"></a><span id="l20.1122">       // folder.</span>
<a href="#l20.1123"></a><span id="l20.1123" class="difflineminus">-      if (!(flags &amp; (nsMsgFolderFlags::Trash | nsMsgFolderFlags::Junk)))</span>
<a href="#l20.1124"></a><span id="l20.1124" class="difflineminus">-      {</span>
<a href="#l20.1125"></a><span id="l20.1125" class="difflineplus">+      if (!(flags &amp; (nsMsgFolderFlags::Trash | nsMsgFolderFlags::Junk))) {</span>
<a href="#l20.1126"></a><span id="l20.1126">         nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.1127"></a><span id="l20.1127">         rv = GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.1128"></a><span id="l20.1128">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1129"></a><span id="l20.1129">         bool setNewFoldersForOffline = false;</span>
<a href="#l20.1130"></a><span id="l20.1130">         rv = imapServer-&gt;GetOfflineDownload(&amp;setNewFoldersForOffline);</span>
<a href="#l20.1131"></a><span id="l20.1131">         if (NS_SUCCEEDED(rv) &amp;&amp; setNewFoldersForOffline)</span>
<a href="#l20.1132"></a><span id="l20.1132">           flags |= nsMsgFolderFlags::Offline;</span>
<a href="#l20.1133"></a><span id="l20.1133" class="difflineminus">-      }</span>
<a href="#l20.1134"></a><span id="l20.1134" class="difflineminus">-      else</span>
<a href="#l20.1135"></a><span id="l20.1135" class="difflineminus">-      {</span>
<a href="#l20.1136"></a><span id="l20.1136" class="difflineminus">-        flags &amp;= ~nsMsgFolderFlags::Offline; // clear offline flag if set</span>
<a href="#l20.1137"></a><span id="l20.1137" class="difflineplus">+      } else {</span>
<a href="#l20.1138"></a><span id="l20.1138" class="difflineplus">+        flags &amp;= ~nsMsgFolderFlags::Offline;  // clear offline flag if set</span>
<a href="#l20.1139"></a><span id="l20.1139">       }</span>
<a href="#l20.1140"></a><span id="l20.1140"> </span>
<a href="#l20.1141"></a><span id="l20.1141">       flags |= nsMsgFolderFlags::Elided;</span>
<a href="#l20.1142"></a><span id="l20.1142">       child-&gt;SetFlags(flags);</span>
<a href="#l20.1143"></a><span id="l20.1143"> </span>
<a href="#l20.1144"></a><span id="l20.1144">       nsString unicodeName;</span>
<a href="#l20.1145"></a><span id="l20.1145">       rv = CopyMUTF7toUTF16(nsCString(folderName), unicodeName);</span>
<a href="#l20.1146"></a><span id="l20.1146" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l20.1147"></a><span id="l20.1147" class="difflineminus">-        child-&gt;SetPrettyName(unicodeName);</span>
<a href="#l20.1148"></a><span id="l20.1148" class="difflineplus">+      if (NS_SUCCEEDED(rv)) child-&gt;SetPrettyName(unicodeName);</span>
<a href="#l20.1149"></a><span id="l20.1149"> </span>
<a href="#l20.1150"></a><span id="l20.1150">       // store the online name as the mailbox name in the db folder info</span>
<a href="#l20.1151"></a><span id="l20.1151">       // I don't think anyone uses the mailbox name, so we'll use it</span>
<a href="#l20.1152"></a><span id="l20.1152">       // to restore the online name when blowing away an imap db.</span>
<a href="#l20.1153"></a><span id="l20.1153">       if (folderInfo)</span>
<a href="#l20.1154"></a><span id="l20.1154">         folderInfo-&gt;SetMailboxName(NS_ConvertASCIItoUTF16(onlineName));</span>
<a href="#l20.1155"></a><span id="l20.1155">     }</span>
<a href="#l20.1156"></a><span id="l20.1156"> </span>
<a href="#l20.1157"></a><span id="l20.1157">     unusedDB-&gt;SetSummaryValid(true);</span>
<a href="#l20.1158"></a><span id="l20.1158">     unusedDB-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.1159"></a><span id="l20.1159">     unusedDB-&gt;Close(true);</span>
<a href="#l20.1160"></a><span id="l20.1160">     // don't want to hold onto this newly created db.</span>
<a href="#l20.1161"></a><span id="l20.1161">     child-&gt;SetMsgDatabase(nullptr);</span>
<a href="#l20.1162"></a><span id="l20.1162">   }</span>
<a href="#l20.1163"></a><span id="l20.1163"> </span>
<a href="#l20.1164"></a><span id="l20.1164" class="difflineminus">-  if (!suppressNotification)</span>
<a href="#l20.1165"></a><span id="l20.1165" class="difflineminus">-  {</span>
<a href="#l20.1166"></a><span id="l20.1166" class="difflineminus">-    if(NS_SUCCEEDED(rv) &amp;&amp; child)</span>
<a href="#l20.1167"></a><span id="l20.1167" class="difflineminus">-    {</span>
<a href="#l20.1168"></a><span id="l20.1168" class="difflineplus">+  if (!suppressNotification) {</span>
<a href="#l20.1169"></a><span id="l20.1169" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; child) {</span>
<a href="#l20.1170"></a><span id="l20.1170">       NotifyItemAdded(child);</span>
<a href="#l20.1171"></a><span id="l20.1171">       child-&gt;NotifyFolderEvent(kFolderCreateCompleted);</span>
<a href="#l20.1172"></a><span id="l20.1172" class="difflineminus">-      nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.1173"></a><span id="l20.1173" class="difflineminus">-      if (notifier)</span>
<a href="#l20.1174"></a><span id="l20.1174" class="difflineminus">-        notifier-&gt;NotifyFolderAdded(child);</span>
<a href="#l20.1175"></a><span id="l20.1175" class="difflineminus">-    }</span>
<a href="#l20.1176"></a><span id="l20.1176" class="difflineminus">-    else</span>
<a href="#l20.1177"></a><span id="l20.1177" class="difflineminus">-    {</span>
<a href="#l20.1178"></a><span id="l20.1178" class="difflineplus">+      nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(</span>
<a href="#l20.1179"></a><span id="l20.1179" class="difflineplus">+          do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.1180"></a><span id="l20.1180" class="difflineplus">+      if (notifier) notifier-&gt;NotifyFolderAdded(child);</span>
<a href="#l20.1181"></a><span id="l20.1181" class="difflineplus">+    } else {</span>
<a href="#l20.1182"></a><span id="l20.1182">       NotifyFolderEvent(kFolderCreateFailed);</span>
<a href="#l20.1183"></a><span id="l20.1183">     }</span>
<a href="#l20.1184"></a><span id="l20.1184">   }</span>
<a href="#l20.1185"></a><span id="l20.1185">   return rv;</span>
<a href="#l20.1186"></a><span id="l20.1186"> }</span>
<a href="#l20.1187"></a><span id="l20.1187"> </span>
<a href="#l20.1188"></a><span id="l20.1188" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::List()</span>
<a href="#l20.1189"></a><span id="l20.1189" class="difflineminus">-{</span>
<a href="#l20.1190"></a><span id="l20.1190" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::List() {</span>
<a href="#l20.1191"></a><span id="l20.1191">   nsresult rv;</span>
<a href="#l20.1192"></a><span id="l20.1192" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1193"></a><span id="l20.1193" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.1194"></a><span id="l20.1194" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.1195"></a><span id="l20.1195" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1196"></a><span id="l20.1196" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1197"></a><span id="l20.1197">   return imapService-&gt;ListFolder(this, this, nullptr);</span>
<a href="#l20.1198"></a><span id="l20.1198"> }</span>
<a href="#l20.1199"></a><span id="l20.1199"> </span>
<a href="#l20.1200"></a><span id="l20.1200" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::RemoveSubFolder (nsIMsgFolder *which)</span>
<a href="#l20.1201"></a><span id="l20.1201" class="difflineminus">-{</span>
<a href="#l20.1202"></a><span id="l20.1202" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::RemoveSubFolder(nsIMsgFolder *which) {</span>
<a href="#l20.1203"></a><span id="l20.1203">   nsresult rv;</span>
<a href="#l20.1204"></a><span id="l20.1204" class="difflineminus">-  nsCOMPtr&lt;nsIMutableArray&gt; folders(do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l20.1205"></a><span id="l20.1205" class="difflineplus">+  nsCOMPtr&lt;nsIMutableArray&gt; folders(</span>
<a href="#l20.1206"></a><span id="l20.1206" class="difflineplus">+      do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l20.1207"></a><span id="l20.1207">   NS_ENSURE_TRUE(folders, rv);</span>
<a href="#l20.1208"></a><span id="l20.1208">   nsCOMPtr&lt;nsISupports&gt; folderSupport = do_QueryInterface(which, &amp;rv);</span>
<a href="#l20.1209"></a><span id="l20.1209">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1210"></a><span id="l20.1210">   folders-&gt;AppendElement(folderSupport);</span>
<a href="#l20.1211"></a><span id="l20.1211">   rv = nsMsgDBFolder::DeleteSubFolders(folders, nullptr);</span>
<a href="#l20.1212"></a><span id="l20.1212">   which-&gt;Delete();</span>
<a href="#l20.1213"></a><span id="l20.1213">   return rv;</span>
<a href="#l20.1214"></a><span id="l20.1214"> }</span>
<a href="#l20.1215"></a><span id="l20.1215"> </span>
<a href="#l20.1216"></a><span id="l20.1216" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::CreateStorageIfMissing(nsIUrlListener* urlListener)</span>
<a href="#l20.1217"></a><span id="l20.1217" class="difflineminus">-{</span>
<a href="#l20.1218"></a><span id="l20.1218" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::CreateStorageIfMissing(</span>
<a href="#l20.1219"></a><span id="l20.1219" class="difflineplus">+    nsIUrlListener *urlListener) {</span>
<a href="#l20.1220"></a><span id="l20.1220">   nsresult rv = NS_OK;</span>
<a href="#l20.1221"></a><span id="l20.1221" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; msgParent;</span>
<a href="#l20.1222"></a><span id="l20.1222" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; msgParent;</span>
<a href="#l20.1223"></a><span id="l20.1223">   GetParent(getter_AddRefs(msgParent));</span>
<a href="#l20.1224"></a><span id="l20.1224"> </span>
<a href="#l20.1225"></a><span id="l20.1225">   // parent is probably not set because *this* was probably created by rdf</span>
<a href="#l20.1226"></a><span id="l20.1226">   // and not by folder discovery. So, we have to compute the parent.</span>
<a href="#l20.1227"></a><span id="l20.1227" class="difflineminus">-  if (!msgParent)</span>
<a href="#l20.1228"></a><span id="l20.1228" class="difflineminus">-  {</span>
<a href="#l20.1229"></a><span id="l20.1229" class="difflineplus">+  if (!msgParent) {</span>
<a href="#l20.1230"></a><span id="l20.1230">     nsAutoCString folderName(mURI);</span>
<a href="#l20.1231"></a><span id="l20.1231"> </span>
<a href="#l20.1232"></a><span id="l20.1232">     int32_t leafPos = folderName.RFindChar('/');</span>
<a href="#l20.1233"></a><span id="l20.1233">     nsAutoCString parentName(folderName);</span>
<a href="#l20.1234"></a><span id="l20.1234"> </span>
<a href="#l20.1235"></a><span id="l20.1235" class="difflineminus">-    if (leafPos &gt; 0)</span>
<a href="#l20.1236"></a><span id="l20.1236" class="difflineminus">-    {</span>
<a href="#l20.1237"></a><span id="l20.1237" class="difflineplus">+    if (leafPos &gt; 0) {</span>
<a href="#l20.1238"></a><span id="l20.1238">       // If there is a hierarchy, there is a parent.</span>
<a href="#l20.1239"></a><span id="l20.1239">       // Don't strip off slash if it's the first character</span>
<a href="#l20.1240"></a><span id="l20.1240">       parentName.SetLength(leafPos);</span>
<a href="#l20.1241"></a><span id="l20.1241">       rv = GetOrCreateFolder(parentName, getter_AddRefs(msgParent));</span>
<a href="#l20.1242"></a><span id="l20.1242">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1243"></a><span id="l20.1243">     }</span>
<a href="#l20.1244"></a><span id="l20.1244">   }</span>
<a href="#l20.1245"></a><span id="l20.1245" class="difflineminus">-  if (msgParent)</span>
<a href="#l20.1246"></a><span id="l20.1246" class="difflineminus">-  {</span>
<a href="#l20.1247"></a><span id="l20.1247" class="difflineplus">+  if (msgParent) {</span>
<a href="#l20.1248"></a><span id="l20.1248">     nsString folderName;</span>
<a href="#l20.1249"></a><span id="l20.1249">     GetName(folderName);</span>
<a href="#l20.1250"></a><span id="l20.1250">     nsresult rv;</span>
<a href="#l20.1251"></a><span id="l20.1251" class="difflineminus">-    nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1252"></a><span id="l20.1252" class="difflineplus">+    nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.1253"></a><span id="l20.1253" class="difflineplus">+        do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1254"></a><span id="l20.1254">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1255"></a><span id="l20.1255" class="difflineminus">-    nsCOMPtr &lt;nsIURI&gt; uri;</span>
<a href="#l20.1256"></a><span id="l20.1256" class="difflineminus">-    imapService-&gt;EnsureFolderExists(msgParent, folderName, urlListener, getter_AddRefs(uri));</span>
<a href="#l20.1257"></a><span id="l20.1257" class="difflineplus">+    nsCOMPtr&lt;nsIURI&gt; uri;</span>
<a href="#l20.1258"></a><span id="l20.1258" class="difflineplus">+    imapService-&gt;EnsureFolderExists(msgParent, folderName, urlListener,</span>
<a href="#l20.1259"></a><span id="l20.1259" class="difflineplus">+                                    getter_AddRefs(uri));</span>
<a href="#l20.1260"></a><span id="l20.1260">   }</span>
<a href="#l20.1261"></a><span id="l20.1261">   return rv;</span>
<a href="#l20.1262"></a><span id="l20.1262"> }</span>
<a href="#l20.1263"></a><span id="l20.1263"> </span>
<a href="#l20.1264"></a><span id="l20.1264" class="difflineminus">-</span>
<a href="#l20.1265"></a><span id="l20.1265" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetVerifiedAsOnlineFolder(bool *aVerifiedAsOnlineFolder)</span>
<a href="#l20.1266"></a><span id="l20.1266" class="difflineminus">-{</span>
<a href="#l20.1267"></a><span id="l20.1267" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetVerifiedAsOnlineFolder(</span>
<a href="#l20.1268"></a><span id="l20.1268" class="difflineplus">+    bool *aVerifiedAsOnlineFolder) {</span>
<a href="#l20.1269"></a><span id="l20.1269">   NS_ENSURE_ARG_POINTER(aVerifiedAsOnlineFolder);</span>
<a href="#l20.1270"></a><span id="l20.1270">   *aVerifiedAsOnlineFolder = m_verifiedAsOnlineFolder;</span>
<a href="#l20.1271"></a><span id="l20.1271">   return NS_OK;</span>
<a href="#l20.1272"></a><span id="l20.1272"> }</span>
<a href="#l20.1273"></a><span id="l20.1273"> </span>
<a href="#l20.1274"></a><span id="l20.1274" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetVerifiedAsOnlineFolder(bool aVerifiedAsOnlineFolder)</span>
<a href="#l20.1275"></a><span id="l20.1275" class="difflineminus">-{</span>
<a href="#l20.1276"></a><span id="l20.1276" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetVerifiedAsOnlineFolder(</span>
<a href="#l20.1277"></a><span id="l20.1277" class="difflineplus">+    bool aVerifiedAsOnlineFolder) {</span>
<a href="#l20.1278"></a><span id="l20.1278">   m_verifiedAsOnlineFolder = aVerifiedAsOnlineFolder;</span>
<a href="#l20.1279"></a><span id="l20.1279">   // mark ancestors as verified as well</span>
<a href="#l20.1280"></a><span id="l20.1280" class="difflineminus">-  if (aVerifiedAsOnlineFolder)</span>
<a href="#l20.1281"></a><span id="l20.1281" class="difflineminus">-  {</span>
<a href="#l20.1282"></a><span id="l20.1282" class="difflineplus">+  if (aVerifiedAsOnlineFolder) {</span>
<a href="#l20.1283"></a><span id="l20.1283">     nsCOMPtr&lt;nsIMsgFolder&gt; parent;</span>
<a href="#l20.1284"></a><span id="l20.1284" class="difflineminus">-    do</span>
<a href="#l20.1285"></a><span id="l20.1285" class="difflineminus">-    {</span>
<a href="#l20.1286"></a><span id="l20.1286" class="difflineplus">+    do {</span>
<a href="#l20.1287"></a><span id="l20.1287">       GetParent(getter_AddRefs(parent));</span>
<a href="#l20.1288"></a><span id="l20.1288" class="difflineminus">-      if (parent)</span>
<a href="#l20.1289"></a><span id="l20.1289" class="difflineminus">-      {</span>
<a href="#l20.1290"></a><span id="l20.1290" class="difflineplus">+      if (parent) {</span>
<a href="#l20.1291"></a><span id="l20.1291">         nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapParent = do_QueryInterface(parent);</span>
<a href="#l20.1292"></a><span id="l20.1292" class="difflineminus">-        if (imapParent)</span>
<a href="#l20.1293"></a><span id="l20.1293" class="difflineminus">-        {</span>
<a href="#l20.1294"></a><span id="l20.1294" class="difflineplus">+        if (imapParent) {</span>
<a href="#l20.1295"></a><span id="l20.1295">           bool verifiedOnline;</span>
<a href="#l20.1296"></a><span id="l20.1296">           imapParent-&gt;GetVerifiedAsOnlineFolder(&amp;verifiedOnline);</span>
<a href="#l20.1297"></a><span id="l20.1297" class="difflineminus">-          if (verifiedOnline)</span>
<a href="#l20.1298"></a><span id="l20.1298" class="difflineminus">-            break;</span>
<a href="#l20.1299"></a><span id="l20.1299" class="difflineplus">+          if (verifiedOnline) break;</span>
<a href="#l20.1300"></a><span id="l20.1300">           imapParent-&gt;SetVerifiedAsOnlineFolder(true);</span>
<a href="#l20.1301"></a><span id="l20.1301">         }</span>
<a href="#l20.1302"></a><span id="l20.1302">       }</span>
<a href="#l20.1303"></a><span id="l20.1303" class="difflineminus">-    }</span>
<a href="#l20.1304"></a><span id="l20.1304" class="difflineminus">-    while (parent);</span>
<a href="#l20.1305"></a><span id="l20.1305" class="difflineplus">+    } while (parent);</span>
<a href="#l20.1306"></a><span id="l20.1306">   }</span>
<a href="#l20.1307"></a><span id="l20.1307">   return NS_OK;</span>
<a href="#l20.1308"></a><span id="l20.1308"> }</span>
<a href="#l20.1309"></a><span id="l20.1309"> </span>
<a href="#l20.1310"></a><span id="l20.1310" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetOnlineDelimiter(char* onlineDelimiter)</span>
<a href="#l20.1311"></a><span id="l20.1311" class="difflineminus">-{</span>
<a href="#l20.1312"></a><span id="l20.1312" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetOnlineDelimiter(char *onlineDelimiter) {</span>
<a href="#l20.1313"></a><span id="l20.1313">   return GetHierarchyDelimiter(onlineDelimiter);</span>
<a href="#l20.1314"></a><span id="l20.1314"> }</span>
<a href="#l20.1315"></a><span id="l20.1315"> </span>
<a href="#l20.1316"></a><span id="l20.1316" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetHierarchyDelimiter(char aHierarchyDelimiter)</span>
<a href="#l20.1317"></a><span id="l20.1317" class="difflineminus">-{</span>
<a href="#l20.1318"></a><span id="l20.1318" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetHierarchyDelimiter(</span>
<a href="#l20.1319"></a><span id="l20.1319" class="difflineplus">+    char aHierarchyDelimiter) {</span>
<a href="#l20.1320"></a><span id="l20.1320">   m_hierarchyDelimiter = aHierarchyDelimiter;</span>
<a href="#l20.1321"></a><span id="l20.1321">   return NS_OK;</span>
<a href="#l20.1322"></a><span id="l20.1322"> }</span>
<a href="#l20.1323"></a><span id="l20.1323"> </span>
<a href="#l20.1324"></a><span id="l20.1324" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetHierarchyDelimiter(char *aHierarchyDelimiter)</span>
<a href="#l20.1325"></a><span id="l20.1325" class="difflineminus">-{</span>
<a href="#l20.1326"></a><span id="l20.1326" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetHierarchyDelimiter(</span>
<a href="#l20.1327"></a><span id="l20.1327" class="difflineplus">+    char *aHierarchyDelimiter) {</span>
<a href="#l20.1328"></a><span id="l20.1328">   NS_ENSURE_ARG_POINTER(aHierarchyDelimiter);</span>
<a href="#l20.1329"></a><span id="l20.1329" class="difflineminus">-  if (mIsServer)</span>
<a href="#l20.1330"></a><span id="l20.1330" class="difflineminus">-  {</span>
<a href="#l20.1331"></a><span id="l20.1331" class="difflineplus">+  if (mIsServer) {</span>
<a href="#l20.1332"></a><span id="l20.1332">     // if it's the root folder, we don't know the delimiter. So look at the</span>
<a href="#l20.1333"></a><span id="l20.1333">     // first child.</span>
<a href="#l20.1334"></a><span id="l20.1334">     int32_t count = mSubFolders.Count();</span>
<a href="#l20.1335"></a><span id="l20.1335" class="difflineminus">-    if (count &gt; 0)</span>
<a href="#l20.1336"></a><span id="l20.1336" class="difflineminus">-    {</span>
<a href="#l20.1337"></a><span id="l20.1337" class="difflineminus">-      nsCOMPtr&lt;nsIMsgImapMailFolder&gt; childFolder(do_QueryInterface(mSubFolders[0]));</span>
<a href="#l20.1338"></a><span id="l20.1338" class="difflineminus">-      if (childFolder)</span>
<a href="#l20.1339"></a><span id="l20.1339" class="difflineminus">-      {</span>
<a href="#l20.1340"></a><span id="l20.1340" class="difflineplus">+    if (count &gt; 0) {</span>
<a href="#l20.1341"></a><span id="l20.1341" class="difflineplus">+      nsCOMPtr&lt;nsIMsgImapMailFolder&gt; childFolder(</span>
<a href="#l20.1342"></a><span id="l20.1342" class="difflineplus">+          do_QueryInterface(mSubFolders[0]));</span>
<a href="#l20.1343"></a><span id="l20.1343" class="difflineplus">+      if (childFolder) {</span>
<a href="#l20.1344"></a><span id="l20.1344">         nsresult rv = childFolder-&gt;GetHierarchyDelimiter(aHierarchyDelimiter);</span>
<a href="#l20.1345"></a><span id="l20.1345">         // some code uses m_hierarchyDelimiter directly, so we should set it.</span>
<a href="#l20.1346"></a><span id="l20.1346">         m_hierarchyDelimiter = *aHierarchyDelimiter;</span>
<a href="#l20.1347"></a><span id="l20.1347">         return rv;</span>
<a href="#l20.1348"></a><span id="l20.1348">       }</span>
<a href="#l20.1349"></a><span id="l20.1349">     }</span>
<a href="#l20.1350"></a><span id="l20.1350">   }</span>
<a href="#l20.1351"></a><span id="l20.1351" class="difflineminus">-  ReadDBFolderInfo(false); // update cache first.</span>
<a href="#l20.1352"></a><span id="l20.1352" class="difflineplus">+  ReadDBFolderInfo(false);  // update cache first.</span>
<a href="#l20.1353"></a><span id="l20.1353">   *aHierarchyDelimiter = m_hierarchyDelimiter;</span>
<a href="#l20.1354"></a><span id="l20.1354">   return NS_OK;</span>
<a href="#l20.1355"></a><span id="l20.1355"> }</span>
<a href="#l20.1356"></a><span id="l20.1356"> </span>
<a href="#l20.1357"></a><span id="l20.1357" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetBoxFlags(int32_t aBoxFlags)</span>
<a href="#l20.1358"></a><span id="l20.1358" class="difflineminus">-{</span>
<a href="#l20.1359"></a><span id="l20.1359" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetBoxFlags(int32_t aBoxFlags) {</span>
<a href="#l20.1360"></a><span id="l20.1360">   ReadDBFolderInfo(false);</span>
<a href="#l20.1361"></a><span id="l20.1361"> </span>
<a href="#l20.1362"></a><span id="l20.1362">   m_boxFlags = aBoxFlags;</span>
<a href="#l20.1363"></a><span id="l20.1363">   uint32_t newFlags = mFlags;</span>
<a href="#l20.1364"></a><span id="l20.1364"> </span>
<a href="#l20.1365"></a><span id="l20.1365">   newFlags |= nsMsgFolderFlags::ImapBox;</span>
<a href="#l20.1366"></a><span id="l20.1366"> </span>
<a href="#l20.1367"></a><span id="l20.1367">   if (m_boxFlags &amp; kNoinferiors)</span>
<a href="#l20.1368"></a><span id="l20.1368" class="difflineat">@@ -1162,1844 +1086,1694 @@ NS_IMETHODIMP nsImapMailFolder::SetBoxFl</span>
<a href="#l20.1369"></a><span id="l20.1369">     newFlags &amp;= ~nsMsgFolderFlags::ImapOtherUser;</span>
<a href="#l20.1370"></a><span id="l20.1370">   if (m_boxFlags &amp; kPersonalMailbox)</span>
<a href="#l20.1371"></a><span id="l20.1371">     newFlags |= nsMsgFolderFlags::ImapPersonal;</span>
<a href="#l20.1372"></a><span id="l20.1372">   else</span>
<a href="#l20.1373"></a><span id="l20.1373">     newFlags &amp;= ~nsMsgFolderFlags::ImapPersonal;</span>
<a href="#l20.1374"></a><span id="l20.1374"> </span>
<a href="#l20.1375"></a><span id="l20.1375">   // The following are all flags returned by XLIST.</span>
<a href="#l20.1376"></a><span id="l20.1376">   // nsImapIncomingServer::DiscoveryDone checks for these folders.</span>
<a href="#l20.1377"></a><span id="l20.1377" class="difflineminus">-  if (m_boxFlags &amp; kImapDrafts)</span>
<a href="#l20.1378"></a><span id="l20.1378" class="difflineminus">-    newFlags |= nsMsgFolderFlags::Drafts;</span>
<a href="#l20.1379"></a><span id="l20.1379" class="difflineminus">-</span>
<a href="#l20.1380"></a><span id="l20.1380" class="difflineminus">-  if (m_boxFlags &amp; kImapSpam)</span>
<a href="#l20.1381"></a><span id="l20.1381" class="difflineminus">-    newFlags |= nsMsgFolderFlags::Junk;</span>
<a href="#l20.1382"></a><span id="l20.1382" class="difflineminus">-</span>
<a href="#l20.1383"></a><span id="l20.1383" class="difflineminus">-  if (m_boxFlags &amp; kImapSent)</span>
<a href="#l20.1384"></a><span id="l20.1384" class="difflineminus">-    newFlags |= nsMsgFolderFlags::SentMail;</span>
<a href="#l20.1385"></a><span id="l20.1385" class="difflineminus">-</span>
<a href="#l20.1386"></a><span id="l20.1386" class="difflineminus">-  if (m_boxFlags &amp; kImapInbox)</span>
<a href="#l20.1387"></a><span id="l20.1387" class="difflineminus">-    newFlags |= nsMsgFolderFlags::Inbox;</span>
<a href="#l20.1388"></a><span id="l20.1388" class="difflineminus">-</span>
<a href="#l20.1389"></a><span id="l20.1389" class="difflineminus">-  if (m_boxFlags &amp; kImapXListTrash)</span>
<a href="#l20.1390"></a><span id="l20.1390" class="difflineminus">-  {</span>
<a href="#l20.1391"></a><span id="l20.1391" class="difflineplus">+  if (m_boxFlags &amp; kImapDrafts) newFlags |= nsMsgFolderFlags::Drafts;</span>
<a href="#l20.1392"></a><span id="l20.1392" class="difflineplus">+</span>
<a href="#l20.1393"></a><span id="l20.1393" class="difflineplus">+  if (m_boxFlags &amp; kImapSpam) newFlags |= nsMsgFolderFlags::Junk;</span>
<a href="#l20.1394"></a><span id="l20.1394" class="difflineplus">+</span>
<a href="#l20.1395"></a><span id="l20.1395" class="difflineplus">+  if (m_boxFlags &amp; kImapSent) newFlags |= nsMsgFolderFlags::SentMail;</span>
<a href="#l20.1396"></a><span id="l20.1396" class="difflineplus">+</span>
<a href="#l20.1397"></a><span id="l20.1397" class="difflineplus">+  if (m_boxFlags &amp; kImapInbox) newFlags |= nsMsgFolderFlags::Inbox;</span>
<a href="#l20.1398"></a><span id="l20.1398" class="difflineplus">+</span>
<a href="#l20.1399"></a><span id="l20.1399" class="difflineplus">+  if (m_boxFlags &amp; kImapXListTrash) {</span>
<a href="#l20.1400"></a><span id="l20.1400">     nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.1401"></a><span id="l20.1401">     nsMsgImapDeleteModel deleteModel = nsMsgImapDeleteModels::MoveToTrash;</span>
<a href="#l20.1402"></a><span id="l20.1402" class="difflineminus">-    (void) GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.1403"></a><span id="l20.1403" class="difflineminus">-    if (imapServer)</span>
<a href="#l20.1404"></a><span id="l20.1404" class="difflineminus">-      imapServer-&gt;GetDeleteModel(&amp;deleteModel);</span>
<a href="#l20.1405"></a><span id="l20.1405" class="difflineplus">+    (void)GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.1406"></a><span id="l20.1406" class="difflineplus">+    if (imapServer) imapServer-&gt;GetDeleteModel(&amp;deleteModel);</span>
<a href="#l20.1407"></a><span id="l20.1407">     if (deleteModel == nsMsgImapDeleteModels::MoveToTrash)</span>
<a href="#l20.1408"></a><span id="l20.1408">       newFlags |= nsMsgFolderFlags::Trash;</span>
<a href="#l20.1409"></a><span id="l20.1409">   }</span>
<a href="#l20.1410"></a><span id="l20.1410">   // Treat the GMail all mail folder as the archive folder.</span>
<a href="#l20.1411"></a><span id="l20.1411">   if (m_boxFlags &amp; (kImapAllMail | kImapArchive))</span>
<a href="#l20.1412"></a><span id="l20.1412">     newFlags |= nsMsgFolderFlags::Archive;</span>
<a href="#l20.1413"></a><span id="l20.1413"> </span>
<a href="#l20.1414"></a><span id="l20.1414">   SetFlags(newFlags);</span>
<a href="#l20.1415"></a><span id="l20.1415">   return NS_OK;</span>
<a href="#l20.1416"></a><span id="l20.1416"> }</span>
<a href="#l20.1417"></a><span id="l20.1417"> </span>
<a href="#l20.1418"></a><span id="l20.1418" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetBoxFlags(int32_t *aBoxFlags)</span>
<a href="#l20.1419"></a><span id="l20.1419" class="difflineminus">-{</span>
<a href="#l20.1420"></a><span id="l20.1420" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetBoxFlags(int32_t *aBoxFlags) {</span>
<a href="#l20.1421"></a><span id="l20.1421">   NS_ENSURE_ARG_POINTER(aBoxFlags);</span>
<a href="#l20.1422"></a><span id="l20.1422">   *aBoxFlags = m_boxFlags;</span>
<a href="#l20.1423"></a><span id="l20.1423">   return NS_OK;</span>
<a href="#l20.1424"></a><span id="l20.1424"> }</span>
<a href="#l20.1425"></a><span id="l20.1425"> </span>
<a href="#l20.1426"></a><span id="l20.1426" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetExplicitlyVerify(bool *aExplicitlyVerify)</span>
<a href="#l20.1427"></a><span id="l20.1427" class="difflineminus">-{</span>
<a href="#l20.1428"></a><span id="l20.1428" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetExplicitlyVerify(bool *aExplicitlyVerify) {</span>
<a href="#l20.1429"></a><span id="l20.1429">   NS_ENSURE_ARG_POINTER(aExplicitlyVerify);</span>
<a href="#l20.1430"></a><span id="l20.1430">   *aExplicitlyVerify = m_explicitlyVerify;</span>
<a href="#l20.1431"></a><span id="l20.1431">   return NS_OK;</span>
<a href="#l20.1432"></a><span id="l20.1432"> }</span>
<a href="#l20.1433"></a><span id="l20.1433"> </span>
<a href="#l20.1434"></a><span id="l20.1434" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetExplicitlyVerify(bool aExplicitlyVerify)</span>
<a href="#l20.1435"></a><span id="l20.1435" class="difflineminus">-{</span>
<a href="#l20.1436"></a><span id="l20.1436" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetExplicitlyVerify(bool aExplicitlyVerify) {</span>
<a href="#l20.1437"></a><span id="l20.1437">   m_explicitlyVerify = aExplicitlyVerify;</span>
<a href="#l20.1438"></a><span id="l20.1438">   return NS_OK;</span>
<a href="#l20.1439"></a><span id="l20.1439"> }</span>
<a href="#l20.1440"></a><span id="l20.1440"> </span>
<a href="#l20.1441"></a><span id="l20.1441" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetNoSelect(bool *aResult)</span>
<a href="#l20.1442"></a><span id="l20.1442" class="difflineminus">-{</span>
<a href="#l20.1443"></a><span id="l20.1443" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetNoSelect(bool *aResult) {</span>
<a href="#l20.1444"></a><span id="l20.1444">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l20.1445"></a><span id="l20.1445">   return GetFlag(nsMsgFolderFlags::ImapNoselect, aResult);</span>
<a href="#l20.1446"></a><span id="l20.1446"> }</span>
<a href="#l20.1447"></a><span id="l20.1447"> </span>
<a href="#l20.1448"></a><span id="l20.1448" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::ApplyRetentionSettings()</span>
<a href="#l20.1449"></a><span id="l20.1449" class="difflineminus">-{</span>
<a href="#l20.1450"></a><span id="l20.1450" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::ApplyRetentionSettings() {</span>
<a href="#l20.1451"></a><span id="l20.1451">   int32_t numDaysToKeepOfflineMsgs = -1;</span>
<a href="#l20.1452"></a><span id="l20.1452"> </span>
<a href="#l20.1453"></a><span id="l20.1453">   // Check if we've limited the offline storage by age.</span>
<a href="#l20.1454"></a><span id="l20.1454">   nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.1455"></a><span id="l20.1455">   nsresult rv = GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.1456"></a><span id="l20.1456">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1457"></a><span id="l20.1457">   imapServer-&gt;GetAutoSyncMaxAgeDays(&amp;numDaysToKeepOfflineMsgs);</span>
<a href="#l20.1458"></a><span id="l20.1458"> </span>
<a href="#l20.1459"></a><span id="l20.1459">   nsCOMPtr&lt;nsIMsgDatabase&gt; holdDBOpen;</span>
<a href="#l20.1460"></a><span id="l20.1460" class="difflineminus">-  if (numDaysToKeepOfflineMsgs &gt; 0)</span>
<a href="#l20.1461"></a><span id="l20.1461" class="difflineminus">-  {</span>
<a href="#l20.1462"></a><span id="l20.1462" class="difflineplus">+  if (numDaysToKeepOfflineMsgs &gt; 0) {</span>
<a href="#l20.1463"></a><span id="l20.1463">     bool dbWasCached = mDatabase != nullptr;</span>
<a href="#l20.1464"></a><span id="l20.1464">     rv = GetDatabase();</span>
<a href="#l20.1465"></a><span id="l20.1465">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1466"></a><span id="l20.1466" class="difflineminus">-    nsCOMPtr &lt;nsISimpleEnumerator&gt; hdrs;</span>
<a href="#l20.1467"></a><span id="l20.1467" class="difflineplus">+    nsCOMPtr&lt;nsISimpleEnumerator&gt; hdrs;</span>
<a href="#l20.1468"></a><span id="l20.1468">     rv = mDatabase-&gt;EnumerateMessages(getter_AddRefs(hdrs));</span>
<a href="#l20.1469"></a><span id="l20.1469">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1470"></a><span id="l20.1470">     bool hasMore = false;</span>
<a href="#l20.1471"></a><span id="l20.1471"> </span>
<a href="#l20.1472"></a><span id="l20.1472">     PRTime cutOffDay =</span>
<a href="#l20.1473"></a><span id="l20.1473" class="difflineminus">-      MsgConvertAgeInDaysToCutoffDate(numDaysToKeepOfflineMsgs);</span>
<a href="#l20.1474"></a><span id="l20.1474" class="difflineminus">-</span>
<a href="#l20.1475"></a><span id="l20.1475" class="difflineminus">-    nsCOMPtr &lt;nsIMsgDBHdr&gt; pHeader;</span>
<a href="#l20.1476"></a><span id="l20.1476" class="difflineplus">+        MsgConvertAgeInDaysToCutoffDate(numDaysToKeepOfflineMsgs);</span>
<a href="#l20.1477"></a><span id="l20.1477" class="difflineplus">+</span>
<a href="#l20.1478"></a><span id="l20.1478" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; pHeader;</span>
<a href="#l20.1479"></a><span id="l20.1479">     // so now cutOffDay is the PRTime cut-off point. Any offline msg with</span>
<a href="#l20.1480"></a><span id="l20.1480">     // a date less than that will get marked for pending removal.</span>
<a href="#l20.1481"></a><span id="l20.1481" class="difflineminus">-    while (NS_SUCCEEDED(rv = hdrs-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l20.1482"></a><span id="l20.1482" class="difflineminus">-    {</span>
<a href="#l20.1483"></a><span id="l20.1483" class="difflineplus">+    while (NS_SUCCEEDED(rv = hdrs-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore) {</span>
<a href="#l20.1484"></a><span id="l20.1484">       nsCOMPtr&lt;nsISupports&gt; supports;</span>
<a href="#l20.1485"></a><span id="l20.1485">       rv = hdrs-&gt;GetNext(getter_AddRefs(supports));</span>
<a href="#l20.1486"></a><span id="l20.1486">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1487"></a><span id="l20.1487">       pHeader = do_QueryInterface(supports, &amp;rv);</span>
<a href="#l20.1488"></a><span id="l20.1488">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1489"></a><span id="l20.1489"> </span>
<a href="#l20.1490"></a><span id="l20.1490">       uint32_t msgFlags;</span>
<a href="#l20.1491"></a><span id="l20.1491">       PRTime msgDate;</span>
<a href="#l20.1492"></a><span id="l20.1492">       pHeader-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l20.1493"></a><span id="l20.1493" class="difflineminus">-      if (msgFlags &amp; nsMsgMessageFlags::Offline)</span>
<a href="#l20.1494"></a><span id="l20.1494" class="difflineminus">-      {</span>
<a href="#l20.1495"></a><span id="l20.1495" class="difflineplus">+      if (msgFlags &amp; nsMsgMessageFlags::Offline) {</span>
<a href="#l20.1496"></a><span id="l20.1496">         pHeader-&gt;GetDate(&amp;msgDate);</span>
<a href="#l20.1497"></a><span id="l20.1497">         MarkPendingRemoval(pHeader, msgDate &lt; cutOffDay);</span>
<a href="#l20.1498"></a><span id="l20.1498">         // I'm horribly tempted to break out of the loop if we've found</span>
<a href="#l20.1499"></a><span id="l20.1499">         // a message after the cut-off date, because messages will most likely</span>
<a href="#l20.1500"></a><span id="l20.1500">         // be in date order in the db, but there are always edge cases.</span>
<a href="#l20.1501"></a><span id="l20.1501">       }</span>
<a href="#l20.1502"></a><span id="l20.1502">     }</span>
<a href="#l20.1503"></a><span id="l20.1503" class="difflineminus">-    if (!dbWasCached)</span>
<a href="#l20.1504"></a><span id="l20.1504" class="difflineminus">-    {</span>
<a href="#l20.1505"></a><span id="l20.1505" class="difflineplus">+    if (!dbWasCached) {</span>
<a href="#l20.1506"></a><span id="l20.1506">       holdDBOpen = mDatabase;</span>
<a href="#l20.1507"></a><span id="l20.1507">       mDatabase = nullptr;</span>
<a href="#l20.1508"></a><span id="l20.1508">     }</span>
<a href="#l20.1509"></a><span id="l20.1509">   }</span>
<a href="#l20.1510"></a><span id="l20.1510">   return nsMsgDBFolder::ApplyRetentionSettings();</span>
<a href="#l20.1511"></a><span id="l20.1511"> }</span>
<a href="#l20.1512"></a><span id="l20.1512"> </span>
<a href="#l20.1513"></a><span id="l20.1513"> /**</span>
<a href="#l20.1514"></a><span id="l20.1514">  * The listener will get called when both the online expunge and the offline</span>
<a href="#l20.1515"></a><span id="l20.1515">  * store compaction are finished (if the latter is needed).</span>
<a href="#l20.1516"></a><span id="l20.1516">  */</span>
<a href="#l20.1517"></a><span id="l20.1517" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::Compact(nsIUrlListener *aListener, nsIMsgWindow *aMsgWindow)</span>
<a href="#l20.1518"></a><span id="l20.1518" class="difflineminus">-{</span>
<a href="#l20.1519"></a><span id="l20.1519" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::Compact(nsIUrlListener *aListener,</span>
<a href="#l20.1520"></a><span id="l20.1520" class="difflineplus">+                                        nsIMsgWindow *aMsgWindow) {</span>
<a href="#l20.1521"></a><span id="l20.1521">   GetDatabase();</span>
<a href="#l20.1522"></a><span id="l20.1522">   // now's a good time to apply the retention settings. If we do delete any</span>
<a href="#l20.1523"></a><span id="l20.1523">   // messages, the expunge is going to have to wait until the delete to</span>
<a href="#l20.1524"></a><span id="l20.1524">   // finish before it can run, but the multiple-connection protection code</span>
<a href="#l20.1525"></a><span id="l20.1525">   // should handle that.</span>
<a href="#l20.1526"></a><span id="l20.1526" class="difflineminus">-  if (mDatabase)</span>
<a href="#l20.1527"></a><span id="l20.1527" class="difflineminus">-    ApplyRetentionSettings();</span>
<a href="#l20.1528"></a><span id="l20.1528" class="difflineplus">+  if (mDatabase) ApplyRetentionSettings();</span>
<a href="#l20.1529"></a><span id="l20.1529"> </span>
<a href="#l20.1530"></a><span id="l20.1530">   m_urlListener = aListener;</span>
<a href="#l20.1531"></a><span id="l20.1531">   // We should be able to compact the offline store now that this should</span>
<a href="#l20.1532"></a><span id="l20.1532">   // just be called by the UI.</span>
<a href="#l20.1533"></a><span id="l20.1533" class="difflineminus">-  if (aMsgWindow &amp;&amp; (mFlags &amp; nsMsgFolderFlags::Offline))</span>
<a href="#l20.1534"></a><span id="l20.1534" class="difflineminus">-  {</span>
<a href="#l20.1535"></a><span id="l20.1535" class="difflineplus">+  if (aMsgWindow &amp;&amp; (mFlags &amp; nsMsgFolderFlags::Offline)) {</span>
<a href="#l20.1536"></a><span id="l20.1536">     m_compactingOfflineStore = true;</span>
<a href="#l20.1537"></a><span id="l20.1537">     CompactOfflineStore(aMsgWindow, this);</span>
<a href="#l20.1538"></a><span id="l20.1538">   }</span>
<a href="#l20.1539"></a><span id="l20.1539" class="difflineminus">-  if (WeAreOffline())</span>
<a href="#l20.1540"></a><span id="l20.1540" class="difflineminus">-    return NS_OK;</span>
<a href="#l20.1541"></a><span id="l20.1541" class="difflineplus">+  if (WeAreOffline()) return NS_OK;</span>
<a href="#l20.1542"></a><span id="l20.1542">   m_expunging = true;</span>
<a href="#l20.1543"></a><span id="l20.1543">   return Expunge(this, aMsgWindow);</span>
<a href="#l20.1544"></a><span id="l20.1544"> }</span>
<a href="#l20.1545"></a><span id="l20.1545"> </span>
<a href="#l20.1546"></a><span id="l20.1546"> NS_IMETHODIMP</span>
<a href="#l20.1547"></a><span id="l20.1547" class="difflineminus">-nsImapMailFolder::NotifyCompactCompleted()</span>
<a href="#l20.1548"></a><span id="l20.1548" class="difflineminus">-{</span>
<a href="#l20.1549"></a><span id="l20.1549" class="difflineminus">-  if (!m_expunging &amp;&amp; m_urlListener)</span>
<a href="#l20.1550"></a><span id="l20.1550" class="difflineminus">-  {</span>
<a href="#l20.1551"></a><span id="l20.1551" class="difflineplus">+nsImapMailFolder::NotifyCompactCompleted() {</span>
<a href="#l20.1552"></a><span id="l20.1552" class="difflineplus">+  if (!m_expunging &amp;&amp; m_urlListener) {</span>
<a href="#l20.1553"></a><span id="l20.1553">     m_urlListener-&gt;OnStopRunningUrl(nullptr, NS_OK);</span>
<a href="#l20.1554"></a><span id="l20.1554">     m_urlListener = nullptr;</span>
<a href="#l20.1555"></a><span id="l20.1555">   }</span>
<a href="#l20.1556"></a><span id="l20.1556">   m_compactingOfflineStore = false;</span>
<a href="#l20.1557"></a><span id="l20.1557">   return NS_OK;</span>
<a href="#l20.1558"></a><span id="l20.1558"> }</span>
<a href="#l20.1559"></a><span id="l20.1559"> </span>
<a href="#l20.1560"></a><span id="l20.1560" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::MarkPendingRemoval(nsIMsgDBHdr *aHdr, bool aMark)</span>
<a href="#l20.1561"></a><span id="l20.1561" class="difflineminus">-{</span>
<a href="#l20.1562"></a><span id="l20.1562" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::MarkPendingRemoval(nsIMsgDBHdr *aHdr,</span>
<a href="#l20.1563"></a><span id="l20.1563" class="difflineplus">+                                                   bool aMark) {</span>
<a href="#l20.1564"></a><span id="l20.1564">   NS_ENSURE_ARG_POINTER(aHdr);</span>
<a href="#l20.1565"></a><span id="l20.1565">   uint32_t offlineMessageSize;</span>
<a href="#l20.1566"></a><span id="l20.1566">   aHdr-&gt;GetOfflineMessageSize(&amp;offlineMessageSize);</span>
<a href="#l20.1567"></a><span id="l20.1567">   aHdr-&gt;SetStringProperty(&quot;pendingRemoval&quot;, aMark ? &quot;1&quot; : &quot;&quot;);</span>
<a href="#l20.1568"></a><span id="l20.1568" class="difflineminus">-  if (!aMark)</span>
<a href="#l20.1569"></a><span id="l20.1569" class="difflineminus">-    return NS_OK;</span>
<a href="#l20.1570"></a><span id="l20.1570" class="difflineplus">+  if (!aMark) return NS_OK;</span>
<a href="#l20.1571"></a><span id="l20.1571">   nsresult rv = GetDatabase();</span>
<a href="#l20.1572"></a><span id="l20.1572">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1573"></a><span id="l20.1573">   nsCOMPtr&lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l20.1574"></a><span id="l20.1574">   rv = mDatabase-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l20.1575"></a><span id="l20.1575">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1576"></a><span id="l20.1576">   return dbFolderInfo-&gt;ChangeExpungedBytes(offlineMessageSize);</span>
<a href="#l20.1577"></a><span id="l20.1577"> }</span>
<a href="#l20.1578"></a><span id="l20.1578"> </span>
<a href="#l20.1579"></a><span id="l20.1579"> NS_IMETHODIMP nsImapMailFolder::Expunge(nsIUrlListener *aListener,</span>
<a href="#l20.1580"></a><span id="l20.1580" class="difflineminus">-                                        nsIMsgWindow *aMsgWindow)</span>
<a href="#l20.1581"></a><span id="l20.1581" class="difflineminus">-{</span>
<a href="#l20.1582"></a><span id="l20.1582" class="difflineplus">+                                        nsIMsgWindow *aMsgWindow) {</span>
<a href="#l20.1583"></a><span id="l20.1583">   nsresult rv;</span>
<a href="#l20.1584"></a><span id="l20.1584" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1585"></a><span id="l20.1585" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.1586"></a><span id="l20.1586" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1587"></a><span id="l20.1587">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1588"></a><span id="l20.1588"> </span>
<a href="#l20.1589"></a><span id="l20.1589">   return imapService-&gt;Expunge(this, aListener, aMsgWindow, nullptr);</span>
<a href="#l20.1590"></a><span id="l20.1590"> }</span>
<a href="#l20.1591"></a><span id="l20.1591"> </span>
<a href="#l20.1592"></a><span id="l20.1592"> NS_IMETHODIMP nsImapMailFolder::CompactAll(nsIUrlListener *aListener,</span>
<a href="#l20.1593"></a><span id="l20.1593" class="difflineminus">-                                               nsIMsgWindow *aMsgWindow,</span>
<a href="#l20.1594"></a><span id="l20.1594" class="difflineminus">-                                               bool aCompactOfflineAlso)</span>
<a href="#l20.1595"></a><span id="l20.1595" class="difflineminus">-{</span>
<a href="#l20.1596"></a><span id="l20.1596" class="difflineplus">+                                           nsIMsgWindow *aMsgWindow,</span>
<a href="#l20.1597"></a><span id="l20.1597" class="difflineplus">+                                           bool aCompactOfflineAlso) {</span>
<a href="#l20.1598"></a><span id="l20.1598">   nsresult rv;</span>
<a href="#l20.1599"></a><span id="l20.1599">   nsCOMPtr&lt;nsIMutableArray&gt; folderArray, offlineFolderArray;</span>
<a href="#l20.1600"></a><span id="l20.1600"> </span>
<a href="#l20.1601"></a><span id="l20.1601">   nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l20.1602"></a><span id="l20.1602">   nsCOMPtr&lt;nsIArray&gt; allDescendents;</span>
<a href="#l20.1603"></a><span id="l20.1603">   rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l20.1604"></a><span id="l20.1604" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder)</span>
<a href="#l20.1605"></a><span id="l20.1605" class="difflineminus">-  {</span>
<a href="#l20.1606"></a><span id="l20.1606" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder) {</span>
<a href="#l20.1607"></a><span id="l20.1607">     rootFolder-&gt;GetDescendants(getter_AddRefs(allDescendents));</span>
<a href="#l20.1608"></a><span id="l20.1608">     uint32_t cnt = 0;</span>
<a href="#l20.1609"></a><span id="l20.1609">     rv = allDescendents-&gt;GetLength(&amp;cnt);</span>
<a href="#l20.1610"></a><span id="l20.1610">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1611"></a><span id="l20.1611">     folderArray = do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv);</span>
<a href="#l20.1612"></a><span id="l20.1612">     NS_ENSURE_TRUE(folderArray, rv);</span>
<a href="#l20.1613"></a><span id="l20.1613" class="difflineminus">-    if (aCompactOfflineAlso)</span>
<a href="#l20.1614"></a><span id="l20.1614" class="difflineminus">-    {</span>
<a href="#l20.1615"></a><span id="l20.1615" class="difflineplus">+    if (aCompactOfflineAlso) {</span>
<a href="#l20.1616"></a><span id="l20.1616">       offlineFolderArray = do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv);</span>
<a href="#l20.1617"></a><span id="l20.1617">       NS_ENSURE_TRUE(offlineFolderArray, rv);</span>
<a href="#l20.1618"></a><span id="l20.1618">     }</span>
<a href="#l20.1619"></a><span id="l20.1619" class="difflineminus">-    for (uint32_t i = 0; i &lt; cnt; i++)</span>
<a href="#l20.1620"></a><span id="l20.1620" class="difflineminus">-    {</span>
<a href="#l20.1621"></a><span id="l20.1621" class="difflineplus">+    for (uint32_t i = 0; i &lt; cnt; i++) {</span>
<a href="#l20.1622"></a><span id="l20.1622">       nsCOMPtr&lt;nsIMsgFolder&gt; folder = do_QueryElementAt(allDescendents, i, &amp;rv);</span>
<a href="#l20.1623"></a><span id="l20.1623">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1624"></a><span id="l20.1624">       uint32_t folderFlags;</span>
<a href="#l20.1625"></a><span id="l20.1625">       folder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l20.1626"></a><span id="l20.1626" class="difflineminus">-      if (! (folderFlags &amp; (nsMsgFolderFlags::Virtual | nsMsgFolderFlags::ImapNoselect)))</span>
<a href="#l20.1627"></a><span id="l20.1627" class="difflineminus">-      {</span>
<a href="#l20.1628"></a><span id="l20.1628" class="difflineplus">+      if (!(folderFlags &amp;</span>
<a href="#l20.1629"></a><span id="l20.1629" class="difflineplus">+            (nsMsgFolderFlags::Virtual | nsMsgFolderFlags::ImapNoselect))) {</span>
<a href="#l20.1630"></a><span id="l20.1630">         rv = folderArray-&gt;AppendElement(folder);</span>
<a href="#l20.1631"></a><span id="l20.1631" class="difflineminus">-        if (aCompactOfflineAlso)</span>
<a href="#l20.1632"></a><span id="l20.1632" class="difflineminus">-          offlineFolderArray-&gt;AppendElement(folder);</span>
<a href="#l20.1633"></a><span id="l20.1633" class="difflineplus">+        if (aCompactOfflineAlso) offlineFolderArray-&gt;AppendElement(folder);</span>
<a href="#l20.1634"></a><span id="l20.1634">       }</span>
<a href="#l20.1635"></a><span id="l20.1635">     }</span>
<a href="#l20.1636"></a><span id="l20.1636">     rv = folderArray-&gt;GetLength(&amp;cnt);</span>
<a href="#l20.1637"></a><span id="l20.1637">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1638"></a><span id="l20.1638" class="difflineminus">-    if (cnt == 0)</span>
<a href="#l20.1639"></a><span id="l20.1639" class="difflineminus">-      return NotifyCompactCompleted();</span>
<a href="#l20.1640"></a><span id="l20.1640" class="difflineminus">-  }</span>
<a href="#l20.1641"></a><span id="l20.1641" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolderCompactor&gt; folderCompactor =</span>
<a href="#l20.1642"></a><span id="l20.1642" class="difflineminus">-    do_CreateInstance(NS_MSGLOCALFOLDERCOMPACTOR_CONTRACTID, &amp;rv);</span>
<a href="#l20.1643"></a><span id="l20.1643" class="difflineplus">+    if (cnt == 0) return NotifyCompactCompleted();</span>
<a href="#l20.1644"></a><span id="l20.1644" class="difflineplus">+  }</span>
<a href="#l20.1645"></a><span id="l20.1645" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolderCompactor&gt; folderCompactor =</span>
<a href="#l20.1646"></a><span id="l20.1646" class="difflineplus">+      do_CreateInstance(NS_MSGLOCALFOLDERCOMPACTOR_CONTRACTID, &amp;rv);</span>
<a href="#l20.1647"></a><span id="l20.1647">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1648"></a><span id="l20.1648">   return folderCompactor-&gt;CompactFolders(folderArray, offlineFolderArray,</span>
<a href="#l20.1649"></a><span id="l20.1649">                                          aListener, aMsgWindow);</span>
<a href="#l20.1650"></a><span id="l20.1650"> }</span>
<a href="#l20.1651"></a><span id="l20.1651"> </span>
<a href="#l20.1652"></a><span id="l20.1652" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::UpdateStatus(nsIUrlListener *aListener, nsIMsgWindow *aMsgWindow)</span>
<a href="#l20.1653"></a><span id="l20.1653" class="difflineminus">-{</span>
<a href="#l20.1654"></a><span id="l20.1654" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::UpdateStatus(nsIUrlListener *aListener,</span>
<a href="#l20.1655"></a><span id="l20.1655" class="difflineplus">+                                             nsIMsgWindow *aMsgWindow) {</span>
<a href="#l20.1656"></a><span id="l20.1656">   nsresult rv;</span>
<a href="#l20.1657"></a><span id="l20.1657" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1658"></a><span id="l20.1658" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.1659"></a><span id="l20.1659" class="difflineminus">-</span>
<a href="#l20.1660"></a><span id="l20.1660" class="difflineminus">-  nsCOMPtr &lt;nsIURI&gt; uri;</span>
<a href="#l20.1661"></a><span id="l20.1661" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.1662"></a><span id="l20.1662" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1663"></a><span id="l20.1663" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1664"></a><span id="l20.1664" class="difflineplus">+</span>
<a href="#l20.1665"></a><span id="l20.1665" class="difflineplus">+  nsCOMPtr&lt;nsIURI&gt; uri;</span>
<a href="#l20.1666"></a><span id="l20.1666">   rv = imapService-&gt;UpdateFolderStatus(this, aListener, getter_AddRefs(uri));</span>
<a href="#l20.1667"></a><span id="l20.1667" class="difflineminus">-  if (uri &amp;&amp; !aMsgWindow)</span>
<a href="#l20.1668"></a><span id="l20.1668" class="difflineminus">-  {</span>
<a href="#l20.1669"></a><span id="l20.1669" class="difflineminus">-    nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailNewsUrl = do_QueryInterface(uri, &amp;rv);</span>
<a href="#l20.1670"></a><span id="l20.1670" class="difflineplus">+  if (uri &amp;&amp; !aMsgWindow) {</span>
<a href="#l20.1671"></a><span id="l20.1671" class="difflineplus">+    nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailNewsUrl = do_QueryInterface(uri, &amp;rv);</span>
<a href="#l20.1672"></a><span id="l20.1672">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1673"></a><span id="l20.1673" class="difflineminus">-    // if no msg window, we won't put up error messages (this is almost certainly a biff-inspired status)</span>
<a href="#l20.1674"></a><span id="l20.1674" class="difflineplus">+    // if no msg window, we won't put up error messages (this is almost</span>
<a href="#l20.1675"></a><span id="l20.1675" class="difflineplus">+    // certainly a biff-inspired status)</span>
<a href="#l20.1676"></a><span id="l20.1676">     mailNewsUrl-&gt;SetSuppressErrorMsgs(true);</span>
<a href="#l20.1677"></a><span id="l20.1677">   }</span>
<a href="#l20.1678"></a><span id="l20.1678">   return rv;</span>
<a href="#l20.1679"></a><span id="l20.1679"> }</span>
<a href="#l20.1680"></a><span id="l20.1680"> </span>
<a href="#l20.1681"></a><span id="l20.1681" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::EmptyTrash(nsIMsgWindow *aMsgWindow, nsIUrlListener *aListener)</span>
<a href="#l20.1682"></a><span id="l20.1682" class="difflineminus">-{</span>
<a href="#l20.1683"></a><span id="l20.1683" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::EmptyTrash(nsIMsgWindow *aMsgWindow,</span>
<a href="#l20.1684"></a><span id="l20.1684" class="difflineplus">+                                           nsIUrlListener *aListener) {</span>
<a href="#l20.1685"></a><span id="l20.1685">   nsCOMPtr&lt;nsIMsgFolder&gt; trashFolder;</span>
<a href="#l20.1686"></a><span id="l20.1686">   nsresult rv = GetTrashFolder(getter_AddRefs(trashFolder));</span>
<a href="#l20.1687"></a><span id="l20.1687" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l20.1688"></a><span id="l20.1688" class="difflineminus">-  {</span>
<a href="#l20.1689"></a><span id="l20.1689" class="difflineminus">-    nsCOMPtr&lt;nsIMsgAccountManager&gt; accountManager = do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l20.1690"></a><span id="l20.1690" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.1691"></a><span id="l20.1691" class="difflineplus">+    nsCOMPtr&lt;nsIMsgAccountManager&gt; accountManager =</span>
<a href="#l20.1692"></a><span id="l20.1692" class="difflineplus">+        do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l20.1693"></a><span id="l20.1693">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1694"></a><span id="l20.1694" class="difflineminus">-    // if we are emptying trash on exit and we are an aol server then don't perform</span>
<a href="#l20.1695"></a><span id="l20.1695" class="difflineminus">-    // this operation because it's causing a hang that we haven't been able to figure out yet</span>
<a href="#l20.1696"></a><span id="l20.1696" class="difflineminus">-    // this is an rtm fix and we'll look for the right solution post rtm.</span>
<a href="#l20.1697"></a><span id="l20.1697" class="difflineplus">+    // if we are emptying trash on exit and we are an aol server then don't</span>
<a href="#l20.1698"></a><span id="l20.1698" class="difflineplus">+    // perform this operation because it's causing a hang that we haven't been</span>
<a href="#l20.1699"></a><span id="l20.1699" class="difflineplus">+    // able to figure out yet this is an rtm fix and we'll look for the right</span>
<a href="#l20.1700"></a><span id="l20.1700" class="difflineplus">+    // solution post rtm.</span>
<a href="#l20.1701"></a><span id="l20.1701">     bool empytingOnExit = false;</span>
<a href="#l20.1702"></a><span id="l20.1702">     accountManager-&gt;GetEmptyTrashInProgress(&amp;empytingOnExit);</span>
<a href="#l20.1703"></a><span id="l20.1703" class="difflineminus">-    if (empytingOnExit)</span>
<a href="#l20.1704"></a><span id="l20.1704" class="difflineminus">-    {</span>
<a href="#l20.1705"></a><span id="l20.1705" class="difflineplus">+    if (empytingOnExit) {</span>
<a href="#l20.1706"></a><span id="l20.1706">       nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.1707"></a><span id="l20.1707">       rv = GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.1708"></a><span id="l20.1708" class="difflineminus">-      if (imapServer)</span>
<a href="#l20.1709"></a><span id="l20.1709" class="difflineminus">-      {</span>
<a href="#l20.1710"></a><span id="l20.1710" class="difflineplus">+      if (imapServer) {</span>
<a href="#l20.1711"></a><span id="l20.1711">         bool isAOLServer = false;</span>
<a href="#l20.1712"></a><span id="l20.1712">         imapServer-&gt;GetIsAOLServer(&amp;isAOLServer);</span>
<a href="#l20.1713"></a><span id="l20.1713">         if (isAOLServer)</span>
<a href="#l20.1714"></a><span id="l20.1714" class="difflineminus">-          return NS_ERROR_FAILURE;  // we will not be performing an empty trash....</span>
<a href="#l20.1715"></a><span id="l20.1715" class="difflineminus">-      } // if we fetched an imap server</span>
<a href="#l20.1716"></a><span id="l20.1716" class="difflineminus">-    } // if emptying trash on exit which is done through the account manager.</span>
<a href="#l20.1717"></a><span id="l20.1717" class="difflineminus">-</span>
<a href="#l20.1718"></a><span id="l20.1718" class="difflineminus">-    if (WeAreOffline())</span>
<a href="#l20.1719"></a><span id="l20.1719" class="difflineminus">-    {</span>
<a href="#l20.1720"></a><span id="l20.1720" class="difflineminus">-      nsCOMPtr &lt;nsIMsgDatabase&gt; trashDB;</span>
<a href="#l20.1721"></a><span id="l20.1721" class="difflineplus">+          return NS_ERROR_FAILURE;  // we will not be performing an empty</span>
<a href="#l20.1722"></a><span id="l20.1722" class="difflineplus">+                                    // trash....</span>
<a href="#l20.1723"></a><span id="l20.1723" class="difflineplus">+      }                             // if we fetched an imap server</span>
<a href="#l20.1724"></a><span id="l20.1724" class="difflineplus">+    }  // if emptying trash on exit which is done through the account manager.</span>
<a href="#l20.1725"></a><span id="l20.1725" class="difflineplus">+</span>
<a href="#l20.1726"></a><span id="l20.1726" class="difflineplus">+    if (WeAreOffline()) {</span>
<a href="#l20.1727"></a><span id="l20.1727" class="difflineplus">+      nsCOMPtr&lt;nsIMsgDatabase&gt; trashDB;</span>
<a href="#l20.1728"></a><span id="l20.1728">       rv = trashFolder-&gt;GetMsgDatabase(getter_AddRefs(trashDB));</span>
<a href="#l20.1729"></a><span id="l20.1729" class="difflineminus">-      if (trashDB)</span>
<a href="#l20.1730"></a><span id="l20.1730" class="difflineminus">-      {</span>
<a href="#l20.1731"></a><span id="l20.1731" class="difflineplus">+      if (trashDB) {</span>
<a href="#l20.1732"></a><span id="l20.1732">         nsMsgKey fakeKey;</span>
<a href="#l20.1733"></a><span id="l20.1733">         trashDB-&gt;GetNextFakeOfflineMsgKey(&amp;fakeKey);</span>
<a href="#l20.1734"></a><span id="l20.1734"> </span>
<a href="#l20.1735"></a><span id="l20.1735" class="difflineminus">-        nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; op;</span>
<a href="#l20.1736"></a><span id="l20.1736" class="difflineplus">+        nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; op;</span>
<a href="#l20.1737"></a><span id="l20.1737">         rv = trashDB-&gt;GetOfflineOpForKey(fakeKey, true, getter_AddRefs(op));</span>
<a href="#l20.1738"></a><span id="l20.1738">         trashFolder-&gt;SetFlag(nsMsgFolderFlags::OfflineEvents);</span>
<a href="#l20.1739"></a><span id="l20.1739">         op-&gt;SetOperation(nsIMsgOfflineImapOperation::kDeleteAllMsgs);</span>
<a href="#l20.1740"></a><span id="l20.1740">       }</span>
<a href="#l20.1741"></a><span id="l20.1741">       return rv;</span>
<a href="#l20.1742"></a><span id="l20.1742">     }</span>
<a href="#l20.1743"></a><span id="l20.1743"> </span>
<a href="#l20.1744"></a><span id="l20.1744" class="difflineminus">-    nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1745"></a><span id="l20.1745" class="difflineplus">+    nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.1746"></a><span id="l20.1746" class="difflineplus">+        do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1747"></a><span id="l20.1747">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1748"></a><span id="l20.1748"> </span>
<a href="#l20.1749"></a><span id="l20.1749">     if (aListener)</span>
<a href="#l20.1750"></a><span id="l20.1750">       rv = imapService-&gt;DeleteAllMessages(trashFolder, aListener, nullptr);</span>
<a href="#l20.1751"></a><span id="l20.1751" class="difflineminus">-    else</span>
<a href="#l20.1752"></a><span id="l20.1752" class="difflineminus">-    {</span>
<a href="#l20.1753"></a><span id="l20.1753" class="difflineplus">+    else {</span>
<a href="#l20.1754"></a><span id="l20.1754">       nsCOMPtr&lt;nsIUrlListener&gt; urlListener = do_QueryInterface(trashFolder);</span>
<a href="#l20.1755"></a><span id="l20.1755">       rv = imapService-&gt;DeleteAllMessages(trashFolder, urlListener, nullptr);</span>
<a href="#l20.1756"></a><span id="l20.1756">     }</span>
<a href="#l20.1757"></a><span id="l20.1757">     // Return an error if this failed. We want the empty trash on exit code</span>
<a href="#l20.1758"></a><span id="l20.1758" class="difflineminus">-    // to know if this fails so that it doesn't block waiting for empty trash to finish.</span>
<a href="#l20.1759"></a><span id="l20.1759" class="difflineplus">+    // to know if this fails so that it doesn't block waiting for empty trash to</span>
<a href="#l20.1760"></a><span id="l20.1760" class="difflineplus">+    // finish.</span>
<a href="#l20.1761"></a><span id="l20.1761">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1762"></a><span id="l20.1762"> </span>
<a href="#l20.1763"></a><span id="l20.1763">     bool hasSubfolders = false;</span>
<a href="#l20.1764"></a><span id="l20.1764">     rv = trashFolder-&gt;GetHasSubFolders(&amp;hasSubfolders);</span>
<a href="#l20.1765"></a><span id="l20.1765">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1766"></a><span id="l20.1766" class="difflineminus">-    if (hasSubfolders)</span>
<a href="#l20.1767"></a><span id="l20.1767" class="difflineminus">-    {</span>
<a href="#l20.1768"></a><span id="l20.1768" class="difflineplus">+    if (hasSubfolders) {</span>
<a href="#l20.1769"></a><span id="l20.1769">       nsCOMPtr&lt;nsISimpleEnumerator&gt; enumerator;</span>
<a href="#l20.1770"></a><span id="l20.1770">       nsCOMPtr&lt;nsISupports&gt; item;</span>
<a href="#l20.1771"></a><span id="l20.1771">       nsCOMArray&lt;nsIMsgFolder&gt; array;</span>
<a href="#l20.1772"></a><span id="l20.1772"> </span>
<a href="#l20.1773"></a><span id="l20.1773">       rv = trashFolder-&gt;GetSubFolders(getter_AddRefs(enumerator));</span>
<a href="#l20.1774"></a><span id="l20.1774">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1775"></a><span id="l20.1775"> </span>
<a href="#l20.1776"></a><span id="l20.1776">       bool hasMore;</span>
<a href="#l20.1777"></a><span id="l20.1777" class="difflineminus">-      while (NS_SUCCEEDED(enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l20.1778"></a><span id="l20.1778" class="difflineminus">-      {</span>
<a href="#l20.1779"></a><span id="l20.1779" class="difflineplus">+      while (NS_SUCCEEDED(enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore) {</span>
<a href="#l20.1780"></a><span id="l20.1780">         rv = enumerator-&gt;GetNext(getter_AddRefs(item));</span>
<a href="#l20.1781"></a><span id="l20.1781" class="difflineminus">-        if (NS_SUCCEEDED(rv))</span>
<a href="#l20.1782"></a><span id="l20.1782" class="difflineminus">-        {</span>
<a href="#l20.1783"></a><span id="l20.1783" class="difflineplus">+        if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.1784"></a><span id="l20.1784">           nsCOMPtr&lt;nsIMsgFolder&gt; folder(do_QueryInterface(item, &amp;rv));</span>
<a href="#l20.1785"></a><span id="l20.1785" class="difflineminus">-          if (NS_SUCCEEDED(rv))</span>
<a href="#l20.1786"></a><span id="l20.1786" class="difflineminus">-            array.AppendObject(folder);</span>
<a href="#l20.1787"></a><span id="l20.1787" class="difflineplus">+          if (NS_SUCCEEDED(rv)) array.AppendObject(folder);</span>
<a href="#l20.1788"></a><span id="l20.1788">         }</span>
<a href="#l20.1789"></a><span id="l20.1789">       }</span>
<a href="#l20.1790"></a><span id="l20.1790" class="difflineminus">-      for (int32_t i = array.Count() - 1; i &gt;= 0; i--)</span>
<a href="#l20.1791"></a><span id="l20.1791" class="difflineminus">-      {</span>
<a href="#l20.1792"></a><span id="l20.1792" class="difflineplus">+      for (int32_t i = array.Count() - 1; i &gt;= 0; i--) {</span>
<a href="#l20.1793"></a><span id="l20.1793">         trashFolder-&gt;PropagateDelete(array[i], true, aMsgWindow);</span>
<a href="#l20.1794"></a><span id="l20.1794" class="difflineminus">-        // Remove the object, presumably to free it up before we delete the next.</span>
<a href="#l20.1795"></a><span id="l20.1795" class="difflineplus">+        // Remove the object, presumably to free it up before we delete the</span>
<a href="#l20.1796"></a><span id="l20.1796" class="difflineplus">+        // next.</span>
<a href="#l20.1797"></a><span id="l20.1797">         array.RemoveObjectAt(i);</span>
<a href="#l20.1798"></a><span id="l20.1798">       }</span>
<a href="#l20.1799"></a><span id="l20.1799">     }</span>
<a href="#l20.1800"></a><span id="l20.1800"> </span>
<a href="#l20.1801"></a><span id="l20.1801" class="difflineminus">-    nsCOMPtr &lt;nsIDBFolderInfo&gt; transferInfo;</span>
<a href="#l20.1802"></a><span id="l20.1802" class="difflineplus">+    nsCOMPtr&lt;nsIDBFolderInfo&gt; transferInfo;</span>
<a href="#l20.1803"></a><span id="l20.1803">     rv = trashFolder-&gt;GetDBTransferInfo(getter_AddRefs(transferInfo));</span>
<a href="#l20.1804"></a><span id="l20.1804">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1805"></a><span id="l20.1805">     // Bulk-delete all the messages by deleting the msf file and storage.</span>
<a href="#l20.1806"></a><span id="l20.1806">     // This is a little kludgy.</span>
<a href="#l20.1807"></a><span id="l20.1807">     rv = trashFolder-&gt;Delete();</span>
<a href="#l20.1808"></a><span id="l20.1808">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1809"></a><span id="l20.1809">     trashFolder-&gt;SetDBTransferInfo(transferInfo);</span>
<a href="#l20.1810"></a><span id="l20.1810">     trashFolder-&gt;SetSizeOnDisk(0);</span>
<a href="#l20.1811"></a><span id="l20.1811"> </span>
<a href="#l20.1812"></a><span id="l20.1812">     // The trash folder has effectively been deleted.</span>
<a href="#l20.1813"></a><span id="l20.1813" class="difflineminus">-    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.1814"></a><span id="l20.1814" class="difflineminus">-    if (notifier)</span>
<a href="#l20.1815"></a><span id="l20.1815" class="difflineminus">-      notifier-&gt;NotifyFolderDeleted(trashFolder);</span>
<a href="#l20.1816"></a><span id="l20.1816" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(</span>
<a href="#l20.1817"></a><span id="l20.1817" class="difflineplus">+        do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.1818"></a><span id="l20.1818" class="difflineplus">+    if (notifier) notifier-&gt;NotifyFolderDeleted(trashFolder);</span>
<a href="#l20.1819"></a><span id="l20.1819"> </span>
<a href="#l20.1820"></a><span id="l20.1820">     return NS_OK;</span>
<a href="#l20.1821"></a><span id="l20.1821">   }</span>
<a href="#l20.1822"></a><span id="l20.1822">   return rv;</span>
<a href="#l20.1823"></a><span id="l20.1823"> }</span>
<a href="#l20.1824"></a><span id="l20.1824"> </span>
<a href="#l20.1825"></a><span id="l20.1825" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::Delete()</span>
<a href="#l20.1826"></a><span id="l20.1826" class="difflineminus">-{</span>
<a href="#l20.1827"></a><span id="l20.1827" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::Delete() {</span>
<a href="#l20.1828"></a><span id="l20.1828">   nsresult rv = nsMsgDBFolder::Delete();</span>
<a href="#l20.1829"></a><span id="l20.1829"> </span>
<a href="#l20.1830"></a><span id="l20.1830">   // Should notify nsIMsgFolderListeners about the folder getting deleted?</span>
<a href="#l20.1831"></a><span id="l20.1831">   return rv;</span>
<a href="#l20.1832"></a><span id="l20.1832"> }</span>
<a href="#l20.1833"></a><span id="l20.1833"> </span>
<a href="#l20.1834"></a><span id="l20.1834" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::Rename (const nsAString&amp; newName, nsIMsgWindow *msgWindow)</span>
<a href="#l20.1835"></a><span id="l20.1835" class="difflineminus">-{</span>
<a href="#l20.1836"></a><span id="l20.1836" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::Rename(const nsAString &amp;newName,</span>
<a href="#l20.1837"></a><span id="l20.1837" class="difflineplus">+                                       nsIMsgWindow *msgWindow) {</span>
<a href="#l20.1838"></a><span id="l20.1838">   if (mFlags &amp; nsMsgFolderFlags::Virtual)</span>
<a href="#l20.1839"></a><span id="l20.1839">     return nsMsgDBFolder::Rename(newName, msgWindow);</span>
<a href="#l20.1840"></a><span id="l20.1840">   nsresult rv;</span>
<a href="#l20.1841"></a><span id="l20.1841">   nsAutoString newNameStr(newName);</span>
<a href="#l20.1842"></a><span id="l20.1842" class="difflineminus">-  if (newNameStr.FindChar(m_hierarchyDelimiter, 0) != kNotFound)</span>
<a href="#l20.1843"></a><span id="l20.1843" class="difflineminus">-  {</span>
<a href="#l20.1844"></a><span id="l20.1844" class="difflineplus">+  if (newNameStr.FindChar(m_hierarchyDelimiter, 0) != kNotFound) {</span>
<a href="#l20.1845"></a><span id="l20.1845">     nsCOMPtr&lt;nsIDocShell&gt; docShell;</span>
<a href="#l20.1846"></a><span id="l20.1846" class="difflineminus">-    if (msgWindow)</span>
<a href="#l20.1847"></a><span id="l20.1847" class="difflineminus">-      msgWindow-&gt;GetRootDocShell(getter_AddRefs(docShell));</span>
<a href="#l20.1848"></a><span id="l20.1848" class="difflineminus">-    if (docShell)</span>
<a href="#l20.1849"></a><span id="l20.1849" class="difflineminus">-    {</span>
<a href="#l20.1850"></a><span id="l20.1850" class="difflineplus">+    if (msgWindow) msgWindow-&gt;GetRootDocShell(getter_AddRefs(docShell));</span>
<a href="#l20.1851"></a><span id="l20.1851" class="difflineplus">+    if (docShell) {</span>
<a href="#l20.1852"></a><span id="l20.1852">       nsCOMPtr&lt;nsIStringBundle&gt; bundle;</span>
<a href="#l20.1853"></a><span id="l20.1853">       rv = IMAPGetStringBundle(getter_AddRefs(bundle));</span>
<a href="#l20.1854"></a><span id="l20.1854" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; bundle)</span>
<a href="#l20.1855"></a><span id="l20.1855" class="difflineminus">-      {</span>
<a href="#l20.1856"></a><span id="l20.1856" class="difflineminus">-        const char16_t delimiter[2] = { (char16_t)m_hierarchyDelimiter, '\0' };</span>
<a href="#l20.1857"></a><span id="l20.1857" class="difflineminus">-        const char16_t *formatStrings[] = { delimiter };</span>
<a href="#l20.1858"></a><span id="l20.1858" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; bundle) {</span>
<a href="#l20.1859"></a><span id="l20.1859" class="difflineplus">+        const char16_t delimiter[2] = {(char16_t)m_hierarchyDelimiter, '\0'};</span>
<a href="#l20.1860"></a><span id="l20.1860" class="difflineplus">+        const char16_t *formatStrings[] = {delimiter};</span>
<a href="#l20.1861"></a><span id="l20.1861">         nsString alertString;</span>
<a href="#l20.1862"></a><span id="l20.1862" class="difflineminus">-        rv = bundle-&gt;FormatStringFromName(</span>
<a href="#l20.1863"></a><span id="l20.1863" class="difflineminus">-          &quot;imapSpecialChar2&quot;,</span>
<a href="#l20.1864"></a><span id="l20.1864" class="difflineminus">-          formatStrings, 1, alertString);</span>
<a href="#l20.1865"></a><span id="l20.1865" class="difflineplus">+        rv = bundle-&gt;FormatStringFromName(&quot;imapSpecialChar2&quot;, formatStrings, 1,</span>
<a href="#l20.1866"></a><span id="l20.1866" class="difflineplus">+                                          alertString);</span>
<a href="#l20.1867"></a><span id="l20.1867">         nsCOMPtr&lt;nsIPrompt&gt; dialog(do_GetInterface(docShell));</span>
<a href="#l20.1868"></a><span id="l20.1868">         // setting up the dialog title</span>
<a href="#l20.1869"></a><span id="l20.1869">         nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.1870"></a><span id="l20.1870">         rv = GetServer(getter_AddRefs(server));</span>
<a href="#l20.1871"></a><span id="l20.1871">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1872"></a><span id="l20.1872">         nsString dialogTitle;</span>
<a href="#l20.1873"></a><span id="l20.1873">         nsString accountName;</span>
<a href="#l20.1874"></a><span id="l20.1874">         rv = server-&gt;GetPrettyName(accountName);</span>
<a href="#l20.1875"></a><span id="l20.1875">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1876"></a><span id="l20.1876" class="difflineminus">-        const char16_t *titleParams[] = { accountName.get() };</span>
<a href="#l20.1877"></a><span id="l20.1877" class="difflineminus">-        rv = bundle-&gt;FormatStringFromName(</span>
<a href="#l20.1878"></a><span id="l20.1878" class="difflineminus">-          &quot;imapAlertDialogTitle&quot;,</span>
<a href="#l20.1879"></a><span id="l20.1879" class="difflineminus">-          titleParams, 1, dialogTitle);</span>
<a href="#l20.1880"></a><span id="l20.1880" class="difflineplus">+        const char16_t *titleParams[] = {accountName.get()};</span>
<a href="#l20.1881"></a><span id="l20.1881" class="difflineplus">+        rv = bundle-&gt;FormatStringFromName(&quot;imapAlertDialogTitle&quot;, titleParams,</span>
<a href="#l20.1882"></a><span id="l20.1882" class="difflineplus">+                                          1, dialogTitle);</span>
<a href="#l20.1883"></a><span id="l20.1883"> </span>
<a href="#l20.1884"></a><span id="l20.1884">         if (dialog &amp;&amp; !alertString.IsEmpty())</span>
<a href="#l20.1885"></a><span id="l20.1885">           dialog-&gt;Alert(dialogTitle.get(), alertString.get());</span>
<a href="#l20.1886"></a><span id="l20.1886">       }</span>
<a href="#l20.1887"></a><span id="l20.1887">     }</span>
<a href="#l20.1888"></a><span id="l20.1888">     return NS_ERROR_FAILURE;</span>
<a href="#l20.1889"></a><span id="l20.1889">   }</span>
<a href="#l20.1890"></a><span id="l20.1890" class="difflineminus">-  nsCOMPtr &lt;nsIImapIncomingServer&gt; incomingImapServer;</span>
<a href="#l20.1891"></a><span id="l20.1891" class="difflineplus">+  nsCOMPtr&lt;nsIImapIncomingServer&gt; incomingImapServer;</span>
<a href="#l20.1892"></a><span id="l20.1892">   GetImapIncomingServer(getter_AddRefs(incomingImapServer));</span>
<a href="#l20.1893"></a><span id="l20.1893" class="difflineminus">-  if (incomingImapServer)</span>
<a href="#l20.1894"></a><span id="l20.1894" class="difflineminus">-    RecursiveCloseActiveConnections(incomingImapServer);</span>
<a href="#l20.1895"></a><span id="l20.1895" class="difflineminus">-</span>
<a href="#l20.1896"></a><span id="l20.1896" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1897"></a><span id="l20.1897" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.1898"></a><span id="l20.1898" class="difflineplus">+  if (incomingImapServer) RecursiveCloseActiveConnections(incomingImapServer);</span>
<a href="#l20.1899"></a><span id="l20.1899" class="difflineplus">+</span>
<a href="#l20.1900"></a><span id="l20.1900" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.1901"></a><span id="l20.1901" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.1902"></a><span id="l20.1902" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1903"></a><span id="l20.1903">   return imapService-&gt;RenameLeaf(this, newName, this, msgWindow, nullptr);</span>
<a href="#l20.1904"></a><span id="l20.1904"> }</span>
<a href="#l20.1905"></a><span id="l20.1905"> </span>
<a href="#l20.1906"></a><span id="l20.1906" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::RecursiveCloseActiveConnections(nsIImapIncomingServer *incomingImapServer)</span>
<a href="#l20.1907"></a><span id="l20.1907" class="difflineminus">-{</span>
<a href="#l20.1908"></a><span id="l20.1908" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::RecursiveCloseActiveConnections(</span>
<a href="#l20.1909"></a><span id="l20.1909" class="difflineplus">+    nsIImapIncomingServer *incomingImapServer) {</span>
<a href="#l20.1910"></a><span id="l20.1910">   NS_ENSURE_ARG(incomingImapServer);</span>
<a href="#l20.1911"></a><span id="l20.1911"> </span>
<a href="#l20.1912"></a><span id="l20.1912">   nsCOMPtr&lt;nsIMsgImapMailFolder&gt; folder;</span>
<a href="#l20.1913"></a><span id="l20.1913">   int32_t count = mSubFolders.Count();</span>
<a href="#l20.1914"></a><span id="l20.1914" class="difflineminus">-  for (int32_t i = 0; i &lt; count; i++)</span>
<a href="#l20.1915"></a><span id="l20.1915" class="difflineminus">-  {</span>
<a href="#l20.1916"></a><span id="l20.1916" class="difflineplus">+  for (int32_t i = 0; i &lt; count; i++) {</span>
<a href="#l20.1917"></a><span id="l20.1917">     folder = do_QueryInterface(mSubFolders[i]);</span>
<a href="#l20.1918"></a><span id="l20.1918" class="difflineminus">-    if (folder)</span>
<a href="#l20.1919"></a><span id="l20.1919" class="difflineminus">-      folder-&gt;RecursiveCloseActiveConnections(incomingImapServer);</span>
<a href="#l20.1920"></a><span id="l20.1920" class="difflineplus">+    if (folder) folder-&gt;RecursiveCloseActiveConnections(incomingImapServer);</span>
<a href="#l20.1921"></a><span id="l20.1921"> </span>
<a href="#l20.1922"></a><span id="l20.1922">     incomingImapServer-&gt;CloseConnectionForFolder(mSubFolders[i]);</span>
<a href="#l20.1923"></a><span id="l20.1923">   }</span>
<a href="#l20.1924"></a><span id="l20.1924">   return NS_OK;</span>
<a href="#l20.1925"></a><span id="l20.1925"> }</span>
<a href="#l20.1926"></a><span id="l20.1926"> </span>
<a href="#l20.1927"></a><span id="l20.1927"> // this is called *after* we've done the rename on the server.</span>
<a href="#l20.1928"></a><span id="l20.1928" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::PrepareToRename()</span>
<a href="#l20.1929"></a><span id="l20.1929" class="difflineminus">-{</span>
<a href="#l20.1930"></a><span id="l20.1930" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::PrepareToRename() {</span>
<a href="#l20.1931"></a><span id="l20.1931">   nsCOMPtr&lt;nsIMsgImapMailFolder&gt; folder;</span>
<a href="#l20.1932"></a><span id="l20.1932">   int32_t count = mSubFolders.Count();</span>
<a href="#l20.1933"></a><span id="l20.1933" class="difflineminus">-  for (int32_t i = 0; i &lt; count; i++)</span>
<a href="#l20.1934"></a><span id="l20.1934" class="difflineminus">-  {</span>
<a href="#l20.1935"></a><span id="l20.1935" class="difflineplus">+  for (int32_t i = 0; i &lt; count; i++) {</span>
<a href="#l20.1936"></a><span id="l20.1936">     folder = do_QueryInterface(mSubFolders[i]);</span>
<a href="#l20.1937"></a><span id="l20.1937" class="difflineminus">-    if (folder)</span>
<a href="#l20.1938"></a><span id="l20.1938" class="difflineminus">-      folder-&gt;PrepareToRename();</span>
<a href="#l20.1939"></a><span id="l20.1939" class="difflineplus">+    if (folder) folder-&gt;PrepareToRename();</span>
<a href="#l20.1940"></a><span id="l20.1940">   }</span>
<a href="#l20.1941"></a><span id="l20.1941"> </span>
<a href="#l20.1942"></a><span id="l20.1942">   SetOnlineName(EmptyCString());</span>
<a href="#l20.1943"></a><span id="l20.1943">   return NS_OK;</span>
<a href="#l20.1944"></a><span id="l20.1944"> }</span>
<a href="#l20.1945"></a><span id="l20.1945"> </span>
<a href="#l20.1946"></a><span id="l20.1946" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::RenameLocal(const nsACString&amp; newName, nsIMsgFolder *parent)</span>
<a href="#l20.1947"></a><span id="l20.1947" class="difflineminus">-{</span>
<a href="#l20.1948"></a><span id="l20.1948" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::RenameLocal(const nsACString &amp;newName,</span>
<a href="#l20.1949"></a><span id="l20.1949" class="difflineplus">+                                            nsIMsgFolder *parent) {</span>
<a href="#l20.1950"></a><span id="l20.1950">   // XXX Here it's assumed that IMAP folder names are stored locally</span>
<a href="#l20.1951"></a><span id="l20.1951">   // in modified UTF-7 (ASCII-only) as is stored remotely.  If we ever change</span>
<a href="#l20.1952"></a><span id="l20.1952">   // this, we have to work with nsString instead of nsCString</span>
<a href="#l20.1953"></a><span id="l20.1953">   // (ref. bug 264071)</span>
<a href="#l20.1954"></a><span id="l20.1954">   nsAutoCString leafname(newName);</span>
<a href="#l20.1955"></a><span id="l20.1955">   nsAutoCString parentName;</span>
<a href="#l20.1956"></a><span id="l20.1956">   // newName always in the canonical form &quot;greatparent/parentname/leafname&quot;</span>
<a href="#l20.1957"></a><span id="l20.1957">   int32_t leafpos = leafname.RFindChar('/');</span>
<a href="#l20.1958"></a><span id="l20.1958" class="difflineminus">-  if (leafpos &gt;0)</span>
<a href="#l20.1959"></a><span id="l20.1959" class="difflineminus">-      leafname.Cut(0, leafpos+1);</span>
<a href="#l20.1960"></a><span id="l20.1960" class="difflineplus">+  if (leafpos &gt; 0) leafname.Cut(0, leafpos + 1);</span>
<a href="#l20.1961"></a><span id="l20.1961">   m_msgParser = nullptr;</span>
<a href="#l20.1962"></a><span id="l20.1962">   PrepareToRename();</span>
<a href="#l20.1963"></a><span id="l20.1963">   CloseAndBackupFolderDB(leafname);</span>
<a href="#l20.1964"></a><span id="l20.1964"> </span>
<a href="#l20.1965"></a><span id="l20.1965">   nsresult rv = NS_OK;</span>
<a href="#l20.1966"></a><span id="l20.1966">   nsCOMPtr&lt;nsIFile&gt; oldPathFile;</span>
<a href="#l20.1967"></a><span id="l20.1967">   rv = GetFilePath(getter_AddRefs(oldPathFile));</span>
<a href="#l20.1968"></a><span id="l20.1968">   if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.1969"></a><span id="l20.1969"> </span>
<a href="#l20.1970"></a><span id="l20.1970">   nsCOMPtr&lt;nsIFile&gt; parentPathFile;</span>
<a href="#l20.1971"></a><span id="l20.1971">   rv = parent-&gt;GetFilePath(getter_AddRefs(parentPathFile));</span>
<a href="#l20.1972"></a><span id="l20.1972" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.1973"></a><span id="l20.1973" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1974"></a><span id="l20.1974"> </span>
<a href="#l20.1975"></a><span id="l20.1975">   bool isDirectory = false;</span>
<a href="#l20.1976"></a><span id="l20.1976">   parentPathFile-&gt;IsDirectory(&amp;isDirectory);</span>
<a href="#l20.1977"></a><span id="l20.1977" class="difflineminus">-  if (!isDirectory)</span>
<a href="#l20.1978"></a><span id="l20.1978" class="difflineminus">-  AddDirectorySeparator(parentPathFile);</span>
<a href="#l20.1979"></a><span id="l20.1979" class="difflineminus">-</span>
<a href="#l20.1980"></a><span id="l20.1980" class="difflineminus">-  nsCOMPtr &lt;nsIFile&gt; dirFile;</span>
<a href="#l20.1981"></a><span id="l20.1981" class="difflineplus">+  if (!isDirectory) AddDirectorySeparator(parentPathFile);</span>
<a href="#l20.1982"></a><span id="l20.1982" class="difflineplus">+</span>
<a href="#l20.1983"></a><span id="l20.1983" class="difflineplus">+  nsCOMPtr&lt;nsIFile&gt; dirFile;</span>
<a href="#l20.1984"></a><span id="l20.1984"> </span>
<a href="#l20.1985"></a><span id="l20.1985">   int32_t count = mSubFolders.Count();</span>
<a href="#l20.1986"></a><span id="l20.1986" class="difflineminus">-  if (count &gt; 0)</span>
<a href="#l20.1987"></a><span id="l20.1987" class="difflineminus">-    rv = CreateDirectoryForFolder(getter_AddRefs(dirFile));</span>
<a href="#l20.1988"></a><span id="l20.1988" class="difflineminus">-</span>
<a href="#l20.1989"></a><span id="l20.1989" class="difflineminus">-  nsCOMPtr &lt;nsIFile&gt; oldSummaryFile;</span>
<a href="#l20.1990"></a><span id="l20.1990" class="difflineplus">+  if (count &gt; 0) rv = CreateDirectoryForFolder(getter_AddRefs(dirFile));</span>
<a href="#l20.1991"></a><span id="l20.1991" class="difflineplus">+</span>
<a href="#l20.1992"></a><span id="l20.1992" class="difflineplus">+  nsCOMPtr&lt;nsIFile&gt; oldSummaryFile;</span>
<a href="#l20.1993"></a><span id="l20.1993">   rv = GetSummaryFileLocation(oldPathFile, getter_AddRefs(oldSummaryFile));</span>
<a href="#l20.1994"></a><span id="l20.1994">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.1995"></a><span id="l20.1995"> </span>
<a href="#l20.1996"></a><span id="l20.1996">   nsAutoCString newNameStr;</span>
<a href="#l20.1997"></a><span id="l20.1997">   oldSummaryFile-&gt;Remove(false);</span>
<a href="#l20.1998"></a><span id="l20.1998" class="difflineminus">-  if (count &gt; 0)</span>
<a href="#l20.1999"></a><span id="l20.1999" class="difflineminus">-  {</span>
<a href="#l20.2000"></a><span id="l20.2000" class="difflineplus">+  if (count &gt; 0) {</span>
<a href="#l20.2001"></a><span id="l20.2001">     newNameStr = leafname;</span>
<a href="#l20.2002"></a><span id="l20.2002">     NS_MsgHashIfNecessary(newNameStr);</span>
<a href="#l20.2003"></a><span id="l20.2003">     newNameStr.AppendLiteral(FOLDER_SUFFIX8);</span>
<a href="#l20.2004"></a><span id="l20.2004">     nsAutoCString leafName;</span>
<a href="#l20.2005"></a><span id="l20.2005">     dirFile-&gt;GetNativeLeafName(leafName);</span>
<a href="#l20.2006"></a><span id="l20.2006">     if (!leafName.Equals(newNameStr))</span>
<a href="#l20.2007"></a><span id="l20.2007" class="difflineminus">-      return dirFile-&gt;MoveToNative(nullptr, newNameStr);      // in case of rename operation leaf names will differ</span>
<a href="#l20.2008"></a><span id="l20.2008" class="difflineminus">-</span>
<a href="#l20.2009"></a><span id="l20.2009" class="difflineminus">-    parentPathFile-&gt;AppendNative(newNameStr);    //only for move we need to progress further in case the parent differs</span>
<a href="#l20.2010"></a><span id="l20.2010" class="difflineplus">+      return dirFile-&gt;MoveToNative(</span>
<a href="#l20.2011"></a><span id="l20.2011" class="difflineplus">+          nullptr,</span>
<a href="#l20.2012"></a><span id="l20.2012" class="difflineplus">+          newNameStr);  // in case of rename operation leaf names will differ</span>
<a href="#l20.2013"></a><span id="l20.2013" class="difflineplus">+</span>
<a href="#l20.2014"></a><span id="l20.2014" class="difflineplus">+    parentPathFile-&gt;AppendNative(</span>
<a href="#l20.2015"></a><span id="l20.2015" class="difflineplus">+        newNameStr);  // only for move we need to progress further in case the</span>
<a href="#l20.2016"></a><span id="l20.2016" class="difflineplus">+                      // parent differs</span>
<a href="#l20.2017"></a><span id="l20.2017">     bool isDirectory = false;</span>
<a href="#l20.2018"></a><span id="l20.2018">     parentPathFile-&gt;IsDirectory(&amp;isDirectory);</span>
<a href="#l20.2019"></a><span id="l20.2019">     if (!isDirectory) {</span>
<a href="#l20.2020"></a><span id="l20.2020">       rv = parentPathFile-&gt;Create(nsIFile::DIRECTORY_TYPE, 0700);</span>
<a href="#l20.2021"></a><span id="l20.2021">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2022"></a><span id="l20.2022">     } else {</span>
<a href="#l20.2023"></a><span id="l20.2023">       NS_ERROR(&quot;Directory already exists.&quot;);</span>
<a href="#l20.2024"></a><span id="l20.2024">     }</span>
<a href="#l20.2025"></a><span id="l20.2025">     rv = RecursiveCopy(dirFile, parentPathFile);</span>
<a href="#l20.2026"></a><span id="l20.2026" class="difflineminus">-    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.2027"></a><span id="l20.2027" class="difflineminus">-    dirFile-&gt;Remove(true);                         // moving folders</span>
<a href="#l20.2028"></a><span id="l20.2028" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2029"></a><span id="l20.2029" class="difflineplus">+    dirFile-&gt;Remove(true);  // moving folders</span>
<a href="#l20.2030"></a><span id="l20.2030">   }</span>
<a href="#l20.2031"></a><span id="l20.2031">   return rv;</span>
<a href="#l20.2032"></a><span id="l20.2032"> }</span>
<a href="#l20.2033"></a><span id="l20.2033"> </span>
<a href="#l20.2034"></a><span id="l20.2034" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetPrettyName(nsAString&amp; prettyName)</span>
<a href="#l20.2035"></a><span id="l20.2035" class="difflineminus">-{</span>
<a href="#l20.2036"></a><span id="l20.2036" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetPrettyName(nsAString &amp;prettyName) {</span>
<a href="#l20.2037"></a><span id="l20.2037">   return GetName(prettyName);</span>
<a href="#l20.2038"></a><span id="l20.2038"> }</span>
<a href="#l20.2039"></a><span id="l20.2039"> </span>
<a href="#l20.2040"></a><span id="l20.2040" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::UpdateSummaryTotals(bool force)</span>
<a href="#l20.2041"></a><span id="l20.2041" class="difflineminus">-{</span>
<a href="#l20.2042"></a><span id="l20.2042" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::UpdateSummaryTotals(bool force) {</span>
<a href="#l20.2043"></a><span id="l20.2043">   // bug 72871 inserted the mIsServer check for IMAP</span>
<a href="#l20.2044"></a><span id="l20.2044" class="difflineminus">-  return mIsServer? NS_OK : nsMsgDBFolder::UpdateSummaryTotals(force);</span>
<a href="#l20.2045"></a><span id="l20.2045" class="difflineminus">-}</span>
<a href="#l20.2046"></a><span id="l20.2046" class="difflineminus">-</span>
<a href="#l20.2047"></a><span id="l20.2047" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetDeletable (bool *deletable)</span>
<a href="#l20.2048"></a><span id="l20.2048" class="difflineminus">-{</span>
<a href="#l20.2049"></a><span id="l20.2049" class="difflineplus">+  return mIsServer ? NS_OK : nsMsgDBFolder::UpdateSummaryTotals(force);</span>
<a href="#l20.2050"></a><span id="l20.2050" class="difflineplus">+}</span>
<a href="#l20.2051"></a><span id="l20.2051" class="difflineplus">+</span>
<a href="#l20.2052"></a><span id="l20.2052" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetDeletable(bool *deletable) {</span>
<a href="#l20.2053"></a><span id="l20.2053">   NS_ENSURE_ARG_POINTER(deletable);</span>
<a href="#l20.2054"></a><span id="l20.2054"> </span>
<a href="#l20.2055"></a><span id="l20.2055">   bool isServer;</span>
<a href="#l20.2056"></a><span id="l20.2056">   GetIsServer(&amp;isServer);</span>
<a href="#l20.2057"></a><span id="l20.2057"> </span>
<a href="#l20.2058"></a><span id="l20.2058">   *deletable = !(isServer || (mFlags &amp; nsMsgFolderFlags::SpecialUse));</span>
<a href="#l20.2059"></a><span id="l20.2059">   return NS_OK;</span>
<a href="#l20.2060"></a><span id="l20.2060"> }</span>
<a href="#l20.2061"></a><span id="l20.2061"> </span>
<a href="#l20.2062"></a><span id="l20.2062" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetSizeOnDisk(int64_t *size)</span>
<a href="#l20.2063"></a><span id="l20.2063" class="difflineminus">-{</span>
<a href="#l20.2064"></a><span id="l20.2064" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetSizeOnDisk(int64_t *size) {</span>
<a href="#l20.2065"></a><span id="l20.2065">   NS_ENSURE_ARG_POINTER(size);</span>
<a href="#l20.2066"></a><span id="l20.2066"> </span>
<a href="#l20.2067"></a><span id="l20.2067">   bool isServer = false;</span>
<a href="#l20.2068"></a><span id="l20.2068">   nsresult rv = GetIsServer(&amp;isServer);</span>
<a href="#l20.2069"></a><span id="l20.2069">   // If this is the rootFolder, return 0 as a safe value.</span>
<a href="#l20.2070"></a><span id="l20.2070" class="difflineminus">-  if (NS_FAILED(rv) || isServer)</span>
<a href="#l20.2071"></a><span id="l20.2071" class="difflineminus">-    mFolderSize = 0;</span>
<a href="#l20.2072"></a><span id="l20.2072" class="difflineplus">+  if (NS_FAILED(rv) || isServer) mFolderSize = 0;</span>
<a href="#l20.2073"></a><span id="l20.2073"> </span>
<a href="#l20.2074"></a><span id="l20.2074">   *size = mFolderSize;</span>
<a href="#l20.2075"></a><span id="l20.2075">   return NS_OK;</span>
<a href="#l20.2076"></a><span id="l20.2076"> }</span>
<a href="#l20.2077"></a><span id="l20.2077"> </span>
<a href="#l20.2078"></a><span id="l20.2078"> NS_IMETHODIMP</span>
<a href="#l20.2079"></a><span id="l20.2079" class="difflineminus">-nsImapMailFolder::GetCanCreateSubfolders(bool *aResult)</span>
<a href="#l20.2080"></a><span id="l20.2080" class="difflineminus">-{</span>
<a href="#l20.2081"></a><span id="l20.2081" class="difflineplus">+nsImapMailFolder::GetCanCreateSubfolders(bool *aResult) {</span>
<a href="#l20.2082"></a><span id="l20.2082">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l20.2083"></a><span id="l20.2083" class="difflineminus">-  *aResult = !(mFlags &amp; (nsMsgFolderFlags::ImapNoinferiors | nsMsgFolderFlags::Virtual));</span>
<a href="#l20.2084"></a><span id="l20.2084" class="difflineplus">+  *aResult = !(mFlags &amp;</span>
<a href="#l20.2085"></a><span id="l20.2085" class="difflineplus">+               (nsMsgFolderFlags::ImapNoinferiors | nsMsgFolderFlags::Virtual));</span>
<a href="#l20.2086"></a><span id="l20.2086"> </span>
<a href="#l20.2087"></a><span id="l20.2087">   bool isServer = false;</span>
<a href="#l20.2088"></a><span id="l20.2088">   GetIsServer(&amp;isServer);</span>
<a href="#l20.2089"></a><span id="l20.2089" class="difflineminus">-  if (!isServer)</span>
<a href="#l20.2090"></a><span id="l20.2090" class="difflineminus">-  {</span>
<a href="#l20.2091"></a><span id="l20.2091" class="difflineplus">+  if (!isServer) {</span>
<a href="#l20.2092"></a><span id="l20.2092">     nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.2093"></a><span id="l20.2093">     nsresult rv = GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.2094"></a><span id="l20.2094">     bool dualUseFolders = true;</span>
<a href="#l20.2095"></a><span id="l20.2095">     if (NS_SUCCEEDED(rv) &amp;&amp; imapServer)</span>
<a href="#l20.2096"></a><span id="l20.2096">       imapServer-&gt;GetDualUseFolders(&amp;dualUseFolders);</span>
<a href="#l20.2097"></a><span id="l20.2097">     if (!dualUseFolders &amp;&amp; *aResult)</span>
<a href="#l20.2098"></a><span id="l20.2098">       *aResult = (mFlags &amp; nsMsgFolderFlags::ImapNoselect);</span>
<a href="#l20.2099"></a><span id="l20.2099">   }</span>
<a href="#l20.2100"></a><span id="l20.2100">   return NS_OK;</span>
<a href="#l20.2101"></a><span id="l20.2101"> }</span>
<a href="#l20.2102"></a><span id="l20.2102"> </span>
<a href="#l20.2103"></a><span id="l20.2103"> NS_IMETHODIMP</span>
<a href="#l20.2104"></a><span id="l20.2104" class="difflineminus">-nsImapMailFolder::GetCanSubscribe(bool *aResult)</span>
<a href="#l20.2105"></a><span id="l20.2105" class="difflineminus">-{</span>
<a href="#l20.2106"></a><span id="l20.2106" class="difflineplus">+nsImapMailFolder::GetCanSubscribe(bool *aResult) {</span>
<a href="#l20.2107"></a><span id="l20.2107">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l20.2108"></a><span id="l20.2108">   *aResult = false;</span>
<a href="#l20.2109"></a><span id="l20.2109"> </span>
<a href="#l20.2110"></a><span id="l20.2110">   bool isImapServer = false;</span>
<a href="#l20.2111"></a><span id="l20.2111">   nsresult rv = GetIsServer(&amp;isImapServer);</span>
<a href="#l20.2112"></a><span id="l20.2112">   if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.2113"></a><span id="l20.2113">   // you can only subscribe to imap servers, not imap folders</span>
<a href="#l20.2114"></a><span id="l20.2114">   *aResult = isImapServer;</span>
<a href="#l20.2115"></a><span id="l20.2115">   return NS_OK;</span>
<a href="#l20.2116"></a><span id="l20.2116"> }</span>
<a href="#l20.2117"></a><span id="l20.2117"> </span>
<a href="#l20.2118"></a><span id="l20.2118" class="difflineminus">-nsresult nsImapMailFolder::GetServerKey(nsACString&amp; serverKey)</span>
<a href="#l20.2119"></a><span id="l20.2119" class="difflineminus">-{</span>
<a href="#l20.2120"></a><span id="l20.2120" class="difflineplus">+nsresult nsImapMailFolder::GetServerKey(nsACString &amp;serverKey) {</span>
<a href="#l20.2121"></a><span id="l20.2121">   // look for matching imap folders, then pop folders</span>
<a href="#l20.2122"></a><span id="l20.2122">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.2123"></a><span id="l20.2123">   nsresult rv = GetServer(getter_AddRefs(server));</span>
<a href="#l20.2124"></a><span id="l20.2124" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l20.2125"></a><span id="l20.2125" class="difflineminus">-    rv = server-&gt;GetKey(serverKey);</span>
<a href="#l20.2126"></a><span id="l20.2126" class="difflineplus">+  if (NS_SUCCEEDED(rv)) rv = server-&gt;GetKey(serverKey);</span>
<a href="#l20.2127"></a><span id="l20.2127">   return rv;</span>
<a href="#l20.2128"></a><span id="l20.2128"> }</span>
<a href="#l20.2129"></a><span id="l20.2129"> </span>
<a href="#l20.2130"></a><span id="l20.2130"> NS_IMETHODIMP</span>
<a href="#l20.2131"></a><span id="l20.2131" class="difflineminus">-nsImapMailFolder::GetImapIncomingServer(nsIImapIncomingServer **aImapIncomingServer)</span>
<a href="#l20.2132"></a><span id="l20.2132" class="difflineminus">-{</span>
<a href="#l20.2133"></a><span id="l20.2133" class="difflineplus">+nsImapMailFolder::GetImapIncomingServer(</span>
<a href="#l20.2134"></a><span id="l20.2134" class="difflineplus">+    nsIImapIncomingServer **aImapIncomingServer) {</span>
<a href="#l20.2135"></a><span id="l20.2135">   NS_ENSURE_ARG(aImapIncomingServer);</span>
<a href="#l20.2136"></a><span id="l20.2136">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.2137"></a><span id="l20.2137" class="difflineminus">-  if (NS_SUCCEEDED(GetServer(getter_AddRefs(server))) &amp;&amp; server)</span>
<a href="#l20.2138"></a><span id="l20.2138" class="difflineminus">-  {</span>
<a href="#l20.2139"></a><span id="l20.2139" class="difflineminus">-    nsCOMPtr &lt;nsIImapIncomingServer&gt; incomingServer = do_QueryInterface(server);</span>
<a href="#l20.2140"></a><span id="l20.2140" class="difflineplus">+  if (NS_SUCCEEDED(GetServer(getter_AddRefs(server))) &amp;&amp; server) {</span>
<a href="#l20.2141"></a><span id="l20.2141" class="difflineplus">+    nsCOMPtr&lt;nsIImapIncomingServer&gt; incomingServer = do_QueryInterface(server);</span>
<a href="#l20.2142"></a><span id="l20.2142">     incomingServer.forget(aImapIncomingServer);</span>
<a href="#l20.2143"></a><span id="l20.2143">     return NS_OK;</span>
<a href="#l20.2144"></a><span id="l20.2144">   }</span>
<a href="#l20.2145"></a><span id="l20.2145">   return NS_ERROR_NULL_POINTER;</span>
<a href="#l20.2146"></a><span id="l20.2146"> }</span>
<a href="#l20.2147"></a><span id="l20.2147"> </span>
<a href="#l20.2148"></a><span id="l20.2148"> NS_IMETHODIMP</span>
<a href="#l20.2149"></a><span id="l20.2149" class="difflineminus">-nsImapMailFolder::AddMessageDispositionState(nsIMsgDBHdr *aMessage, nsMsgDispositionState aDispositionFlag)</span>
<a href="#l20.2150"></a><span id="l20.2150" class="difflineminus">-{</span>
<a href="#l20.2151"></a><span id="l20.2151" class="difflineplus">+nsImapMailFolder::AddMessageDispositionState(</span>
<a href="#l20.2152"></a><span id="l20.2152" class="difflineplus">+    nsIMsgDBHdr *aMessage, nsMsgDispositionState aDispositionFlag) {</span>
<a href="#l20.2153"></a><span id="l20.2153">   nsMsgDBFolder::AddMessageDispositionState(aMessage, aDispositionFlag);</span>
<a href="#l20.2154"></a><span id="l20.2154"> </span>
<a href="#l20.2155"></a><span id="l20.2155">   // set the mark message answered flag on the server for this message...</span>
<a href="#l20.2156"></a><span id="l20.2156" class="difflineminus">-  if (aMessage)</span>
<a href="#l20.2157"></a><span id="l20.2157" class="difflineminus">-  {</span>
<a href="#l20.2158"></a><span id="l20.2158" class="difflineplus">+  if (aMessage) {</span>
<a href="#l20.2159"></a><span id="l20.2159">     nsMsgKey msgKey;</span>
<a href="#l20.2160"></a><span id="l20.2160">     aMessage-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l20.2161"></a><span id="l20.2161"> </span>
<a href="#l20.2162"></a><span id="l20.2162">     if (aDispositionFlag == nsIMsgFolder::nsMsgDispositionState_Replied)</span>
<a href="#l20.2163"></a><span id="l20.2163">       StoreImapFlags(kImapMsgAnsweredFlag, true, &amp;msgKey, 1, nullptr);</span>
<a href="#l20.2164"></a><span id="l20.2164">     else if (aDispositionFlag == nsIMsgFolder::nsMsgDispositionState_Forwarded)</span>
<a href="#l20.2165"></a><span id="l20.2165">       StoreImapFlags(kImapMsgForwardedFlag, true, &amp;msgKey, 1, nullptr);</span>
<a href="#l20.2166"></a><span id="l20.2166">   }</span>
<a href="#l20.2167"></a><span id="l20.2167">   return NS_OK;</span>
<a href="#l20.2168"></a><span id="l20.2168"> }</span>
<a href="#l20.2169"></a><span id="l20.2169"> </span>
<a href="#l20.2170"></a><span id="l20.2170"> NS_IMETHODIMP</span>
<a href="#l20.2171"></a><span id="l20.2171" class="difflineminus">-nsImapMailFolder::MarkMessagesRead(nsIArray *messages, bool markRead)</span>
<a href="#l20.2172"></a><span id="l20.2172" class="difflineminus">-{</span>
<a href="#l20.2173"></a><span id="l20.2173" class="difflineplus">+nsImapMailFolder::MarkMessagesRead(nsIArray *messages, bool markRead) {</span>
<a href="#l20.2174"></a><span id="l20.2174">   // tell the folder to do it, which will mark them read in the db.</span>
<a href="#l20.2175"></a><span id="l20.2175">   nsresult rv = nsMsgDBFolder::MarkMessagesRead(messages, markRead);</span>
<a href="#l20.2176"></a><span id="l20.2176" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l20.2177"></a><span id="l20.2177" class="difflineminus">-  {</span>
<a href="#l20.2178"></a><span id="l20.2178" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.2179"></a><span id="l20.2179">     nsAutoCString messageIds;</span>
<a href="#l20.2180"></a><span id="l20.2180">     nsTArray&lt;nsMsgKey&gt; keysToMarkRead;</span>
<a href="#l20.2181"></a><span id="l20.2181">     rv = BuildIdsAndKeyArray(messages, messageIds, keysToMarkRead);</span>
<a href="#l20.2182"></a><span id="l20.2182">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2183"></a><span id="l20.2183"> </span>
<a href="#l20.2184"></a><span id="l20.2184" class="difflineminus">-    StoreImapFlags(kImapMsgSeenFlag, markRead, keysToMarkRead.Elements(), keysToMarkRead.Length(), nullptr);</span>
<a href="#l20.2185"></a><span id="l20.2185" class="difflineplus">+    StoreImapFlags(kImapMsgSeenFlag, markRead, keysToMarkRead.Elements(),</span>
<a href="#l20.2186"></a><span id="l20.2186" class="difflineplus">+                   keysToMarkRead.Length(), nullptr);</span>
<a href="#l20.2187"></a><span id="l20.2187">     rv = GetDatabase();</span>
<a href="#l20.2188"></a><span id="l20.2188" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l20.2189"></a><span id="l20.2189" class="difflineminus">-      mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.2190"></a><span id="l20.2190" class="difflineplus">+    if (NS_SUCCEEDED(rv)) mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.2191"></a><span id="l20.2191">   }</span>
<a href="#l20.2192"></a><span id="l20.2192">   return rv;</span>
<a href="#l20.2193"></a><span id="l20.2193"> }</span>
<a href="#l20.2194"></a><span id="l20.2194"> </span>
<a href="#l20.2195"></a><span id="l20.2195"> NS_IMETHODIMP</span>
<a href="#l20.2196"></a><span id="l20.2196" class="difflineminus">-nsImapMailFolder::SetLabelForMessages(nsIArray *aMessages, nsMsgLabelValue aLabel)</span>
<a href="#l20.2197"></a><span id="l20.2197" class="difflineminus">-{</span>
<a href="#l20.2198"></a><span id="l20.2198" class="difflineplus">+nsImapMailFolder::SetLabelForMessages(nsIArray *aMessages,</span>
<a href="#l20.2199"></a><span id="l20.2199" class="difflineplus">+                                      nsMsgLabelValue aLabel) {</span>
<a href="#l20.2200"></a><span id="l20.2200">   NS_ENSURE_ARG(aMessages);</span>
<a href="#l20.2201"></a><span id="l20.2201"> </span>
<a href="#l20.2202"></a><span id="l20.2202">   nsresult rv = nsMsgDBFolder::SetLabelForMessages(aMessages, aLabel);</span>
<a href="#l20.2203"></a><span id="l20.2203" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l20.2204"></a><span id="l20.2204" class="difflineminus">-  {</span>
<a href="#l20.2205"></a><span id="l20.2205" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.2206"></a><span id="l20.2206">     nsAutoCString messageIds;</span>
<a href="#l20.2207"></a><span id="l20.2207">     nsTArray&lt;nsMsgKey&gt; keysToLabel;</span>
<a href="#l20.2208"></a><span id="l20.2208">     nsresult rv = BuildIdsAndKeyArray(aMessages, messageIds, keysToLabel);</span>
<a href="#l20.2209"></a><span id="l20.2209">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2210"></a><span id="l20.2210" class="difflineminus">-    StoreImapFlags((aLabel &lt;&lt; 9), true, keysToLabel.Elements(), keysToLabel.Length(), nullptr);</span>
<a href="#l20.2211"></a><span id="l20.2211" class="difflineplus">+    StoreImapFlags((aLabel &lt;&lt; 9), true, keysToLabel.Elements(),</span>
<a href="#l20.2212"></a><span id="l20.2212" class="difflineplus">+                   keysToLabel.Length(), nullptr);</span>
<a href="#l20.2213"></a><span id="l20.2213">     rv = GetDatabase();</span>
<a href="#l20.2214"></a><span id="l20.2214" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l20.2215"></a><span id="l20.2215" class="difflineminus">-      mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.2216"></a><span id="l20.2216" class="difflineplus">+    if (NS_SUCCEEDED(rv)) mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.2217"></a><span id="l20.2217">   }</span>
<a href="#l20.2218"></a><span id="l20.2218">   return rv;</span>
<a href="#l20.2219"></a><span id="l20.2219"> }</span>
<a href="#l20.2220"></a><span id="l20.2220"> </span>
<a href="#l20.2221"></a><span id="l20.2221"> NS_IMETHODIMP</span>
<a href="#l20.2222"></a><span id="l20.2222" class="difflineminus">-nsImapMailFolder::MarkAllMessagesRead(nsIMsgWindow *aMsgWindow)</span>
<a href="#l20.2223"></a><span id="l20.2223" class="difflineminus">-{</span>
<a href="#l20.2224"></a><span id="l20.2224" class="difflineplus">+nsImapMailFolder::MarkAllMessagesRead(nsIMsgWindow *aMsgWindow) {</span>
<a href="#l20.2225"></a><span id="l20.2225">   nsresult rv = GetDatabase();</span>
<a href="#l20.2226"></a><span id="l20.2226" class="difflineminus">-  if(NS_SUCCEEDED(rv))</span>
<a href="#l20.2227"></a><span id="l20.2227" class="difflineminus">-  {</span>
<a href="#l20.2228"></a><span id="l20.2228" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.2229"></a><span id="l20.2229">     nsMsgKey *thoseMarked;</span>
<a href="#l20.2230"></a><span id="l20.2230">     uint32_t numMarked;</span>
<a href="#l20.2231"></a><span id="l20.2231">     EnableNotifications(allMessageCountNotifications, false);</span>
<a href="#l20.2232"></a><span id="l20.2232">     rv = mDatabase-&gt;MarkAllRead(&amp;numMarked, &amp;thoseMarked);</span>
<a href="#l20.2233"></a><span id="l20.2233">     EnableNotifications(allMessageCountNotifications, true);</span>
<a href="#l20.2234"></a><span id="l20.2234" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; numMarked)</span>
<a href="#l20.2235"></a><span id="l20.2235" class="difflineminus">-    {</span>
<a href="#l20.2236"></a><span id="l20.2236" class="difflineminus">-      rv = StoreImapFlags(kImapMsgSeenFlag, true, thoseMarked,</span>
<a href="#l20.2237"></a><span id="l20.2237" class="difflineminus">-                          numMarked, nullptr);</span>
<a href="#l20.2238"></a><span id="l20.2238" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; numMarked) {</span>
<a href="#l20.2239"></a><span id="l20.2239" class="difflineplus">+      rv = StoreImapFlags(kImapMsgSeenFlag, true, thoseMarked, numMarked,</span>
<a href="#l20.2240"></a><span id="l20.2240" class="difflineplus">+                          nullptr);</span>
<a href="#l20.2241"></a><span id="l20.2241">       mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.2242"></a><span id="l20.2242"> </span>
<a href="#l20.2243"></a><span id="l20.2243">       // Setup a undo-state</span>
<a href="#l20.2244"></a><span id="l20.2244">       if (aMsgWindow)</span>
<a href="#l20.2245"></a><span id="l20.2245">         rv = AddMarkAllReadUndoAction(aMsgWindow, thoseMarked, numMarked);</span>
<a href="#l20.2246"></a><span id="l20.2246">       free(thoseMarked);</span>
<a href="#l20.2247"></a><span id="l20.2247">     }</span>
<a href="#l20.2248"></a><span id="l20.2248">   }</span>
<a href="#l20.2249"></a><span id="l20.2249">   return rv;</span>
<a href="#l20.2250"></a><span id="l20.2250"> }</span>
<a href="#l20.2251"></a><span id="l20.2251"> </span>
<a href="#l20.2252"></a><span id="l20.2252" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::MarkThreadRead(nsIMsgThread *thread)</span>
<a href="#l20.2253"></a><span id="l20.2253" class="difflineminus">-{</span>
<a href="#l20.2254"></a><span id="l20.2254" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::MarkThreadRead(nsIMsgThread *thread) {</span>
<a href="#l20.2255"></a><span id="l20.2255">   nsresult rv = GetDatabase();</span>
<a href="#l20.2256"></a><span id="l20.2256" class="difflineminus">-  if(NS_SUCCEEDED(rv))</span>
<a href="#l20.2257"></a><span id="l20.2257" class="difflineminus">-  {</span>
<a href="#l20.2258"></a><span id="l20.2258" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.2259"></a><span id="l20.2259">     nsMsgKey *keys;</span>
<a href="#l20.2260"></a><span id="l20.2260">     uint32_t numKeys;</span>
<a href="#l20.2261"></a><span id="l20.2261">     rv = mDatabase-&gt;MarkThreadRead(thread, nullptr, &amp;numKeys, &amp;keys);</span>
<a href="#l20.2262"></a><span id="l20.2262" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; numKeys)</span>
<a href="#l20.2263"></a><span id="l20.2263" class="difflineminus">-    {</span>
<a href="#l20.2264"></a><span id="l20.2264" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; numKeys) {</span>
<a href="#l20.2265"></a><span id="l20.2265">       rv = StoreImapFlags(kImapMsgSeenFlag, true, keys, numKeys, nullptr);</span>
<a href="#l20.2266"></a><span id="l20.2266">       mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.2267"></a><span id="l20.2267">       free(keys);</span>
<a href="#l20.2268"></a><span id="l20.2268">     }</span>
<a href="#l20.2269"></a><span id="l20.2269">   }</span>
<a href="#l20.2270"></a><span id="l20.2270">   return rv;</span>
<a href="#l20.2271"></a><span id="l20.2271"> }</span>
<a href="#l20.2272"></a><span id="l20.2272"> </span>
<a href="#l20.2273"></a><span id="l20.2273" class="difflineminus">-</span>
<a href="#l20.2274"></a><span id="l20.2274" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::ReadFromFolderCacheElem(nsIMsgFolderCacheElement *element)</span>
<a href="#l20.2275"></a><span id="l20.2275" class="difflineminus">-{</span>
<a href="#l20.2276"></a><span id="l20.2276" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::ReadFromFolderCacheElem(</span>
<a href="#l20.2277"></a><span id="l20.2277" class="difflineplus">+    nsIMsgFolderCacheElement *element) {</span>
<a href="#l20.2278"></a><span id="l20.2278">   nsresult rv = nsMsgDBFolder::ReadFromFolderCacheElem(element);</span>
<a href="#l20.2279"></a><span id="l20.2279">   int32_t hierarchyDelimiter = kOnlineHierarchySeparatorUnknown;</span>
<a href="#l20.2280"></a><span id="l20.2280">   nsCString onlineName;</span>
<a href="#l20.2281"></a><span id="l20.2281"> </span>
<a href="#l20.2282"></a><span id="l20.2282">   element-&gt;GetInt32Property(&quot;boxFlags&quot;, &amp;m_boxFlags);</span>
<a href="#l20.2283"></a><span id="l20.2283" class="difflineminus">-  if (NS_SUCCEEDED(element-&gt;GetInt32Property(&quot;hierDelim&quot;, &amp;hierarchyDelimiter))</span>
<a href="#l20.2284"></a><span id="l20.2284" class="difflineminus">-      &amp;&amp; hierarchyDelimiter != kOnlineHierarchySeparatorUnknown)</span>
<a href="#l20.2285"></a><span id="l20.2285" class="difflineminus">-    m_hierarchyDelimiter = (char) hierarchyDelimiter;</span>
<a href="#l20.2286"></a><span id="l20.2286" class="difflineplus">+  if (NS_SUCCEEDED(</span>
<a href="#l20.2287"></a><span id="l20.2287" class="difflineplus">+          element-&gt;GetInt32Property(&quot;hierDelim&quot;, &amp;hierarchyDelimiter)) &amp;&amp;</span>
<a href="#l20.2288"></a><span id="l20.2288" class="difflineplus">+      hierarchyDelimiter != kOnlineHierarchySeparatorUnknown)</span>
<a href="#l20.2289"></a><span id="l20.2289" class="difflineplus">+    m_hierarchyDelimiter = (char)hierarchyDelimiter;</span>
<a href="#l20.2290"></a><span id="l20.2290">   rv = element-&gt;GetStringProperty(&quot;onlineName&quot;, onlineName);</span>
<a href="#l20.2291"></a><span id="l20.2291">   if (NS_SUCCEEDED(rv) &amp;&amp; !onlineName.IsEmpty())</span>
<a href="#l20.2292"></a><span id="l20.2292">     m_onlineFolderName.Assign(onlineName);</span>
<a href="#l20.2293"></a><span id="l20.2293"> </span>
<a href="#l20.2294"></a><span id="l20.2294" class="difflineminus">-  m_aclFlags = kAclInvalid; // init to invalid value.</span>
<a href="#l20.2295"></a><span id="l20.2295" class="difflineminus">-  element-&gt;GetInt32Property(&quot;aclFlags&quot;, (int32_t *) &amp;m_aclFlags);</span>
<a href="#l20.2296"></a><span id="l20.2296" class="difflineplus">+  m_aclFlags = kAclInvalid;  // init to invalid value.</span>
<a href="#l20.2297"></a><span id="l20.2297" class="difflineplus">+  element-&gt;GetInt32Property(&quot;aclFlags&quot;, (int32_t *)&amp;m_aclFlags);</span>
<a href="#l20.2298"></a><span id="l20.2298">   element-&gt;GetInt32Property(&quot;serverTotal&quot;, &amp;m_numServerTotalMessages);</span>
<a href="#l20.2299"></a><span id="l20.2299">   element-&gt;GetInt32Property(&quot;serverUnseen&quot;, &amp;m_numServerUnseenMessages);</span>
<a href="#l20.2300"></a><span id="l20.2300">   element-&gt;GetInt32Property(&quot;serverRecent&quot;, &amp;m_numServerRecentMessages);</span>
<a href="#l20.2301"></a><span id="l20.2301">   element-&gt;GetInt32Property(&quot;nextUID&quot;, &amp;m_nextUID);</span>
<a href="#l20.2302"></a><span id="l20.2302">   int32_t lastSyncTimeInSec;</span>
<a href="#l20.2303"></a><span id="l20.2303" class="difflineminus">-  if ( NS_FAILED(element-&gt;GetInt32Property(&quot;lastSyncTimeInSec&quot;, (int32_t *) &amp;lastSyncTimeInSec)) )</span>
<a href="#l20.2304"></a><span id="l20.2304" class="difflineplus">+  if (NS_FAILED(element-&gt;GetInt32Property(&quot;lastSyncTimeInSec&quot;,</span>
<a href="#l20.2305"></a><span id="l20.2305" class="difflineplus">+                                          (int32_t *)&amp;lastSyncTimeInSec)))</span>
<a href="#l20.2306"></a><span id="l20.2306">     lastSyncTimeInSec = 0U;</span>
<a href="#l20.2307"></a><span id="l20.2307"> </span>
<a href="#l20.2308"></a><span id="l20.2308">   // make sure that auto-sync state object is created</span>
<a href="#l20.2309"></a><span id="l20.2309">   InitAutoSyncState();</span>
<a href="#l20.2310"></a><span id="l20.2310">   m_autoSyncStateObj-&gt;SetLastSyncTimeInSec(lastSyncTimeInSec);</span>
<a href="#l20.2311"></a><span id="l20.2311"> </span>
<a href="#l20.2312"></a><span id="l20.2312">   return rv;</span>
<a href="#l20.2313"></a><span id="l20.2313"> }</span>
<a href="#l20.2314"></a><span id="l20.2314"> </span>
<a href="#l20.2315"></a><span id="l20.2315" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::WriteToFolderCacheElem(nsIMsgFolderCacheElement *element)</span>
<a href="#l20.2316"></a><span id="l20.2316" class="difflineminus">-{</span>
<a href="#l20.2317"></a><span id="l20.2317" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::WriteToFolderCacheElem(</span>
<a href="#l20.2318"></a><span id="l20.2318" class="difflineplus">+    nsIMsgFolderCacheElement *element) {</span>
<a href="#l20.2319"></a><span id="l20.2319">   nsresult rv = nsMsgDBFolder::WriteToFolderCacheElem(element);</span>
<a href="#l20.2320"></a><span id="l20.2320">   element-&gt;SetInt32Property(&quot;boxFlags&quot;, m_boxFlags);</span>
<a href="#l20.2321"></a><span id="l20.2321" class="difflineminus">-  element-&gt;SetInt32Property(&quot;hierDelim&quot;, (int32_t) m_hierarchyDelimiter);</span>
<a href="#l20.2322"></a><span id="l20.2322" class="difflineplus">+  element-&gt;SetInt32Property(&quot;hierDelim&quot;, (int32_t)m_hierarchyDelimiter);</span>
<a href="#l20.2323"></a><span id="l20.2323">   element-&gt;SetStringProperty(&quot;onlineName&quot;, m_onlineFolderName);</span>
<a href="#l20.2324"></a><span id="l20.2324" class="difflineminus">-  element-&gt;SetInt32Property(&quot;aclFlags&quot;, (int32_t) m_aclFlags);</span>
<a href="#l20.2325"></a><span id="l20.2325" class="difflineplus">+  element-&gt;SetInt32Property(&quot;aclFlags&quot;, (int32_t)m_aclFlags);</span>
<a href="#l20.2326"></a><span id="l20.2326">   element-&gt;SetInt32Property(&quot;serverTotal&quot;, m_numServerTotalMessages);</span>
<a href="#l20.2327"></a><span id="l20.2327">   element-&gt;SetInt32Property(&quot;serverUnseen&quot;, m_numServerUnseenMessages);</span>
<a href="#l20.2328"></a><span id="l20.2328">   element-&gt;SetInt32Property(&quot;serverRecent&quot;, m_numServerRecentMessages);</span>
<a href="#l20.2329"></a><span id="l20.2329" class="difflineminus">-  if (m_nextUID != (int32_t) nsMsgKey_None)</span>
<a href="#l20.2330"></a><span id="l20.2330" class="difflineplus">+  if (m_nextUID != (int32_t)nsMsgKey_None)</span>
<a href="#l20.2331"></a><span id="l20.2331">     element-&gt;SetInt32Property(&quot;nextUID&quot;, m_nextUID);</span>
<a href="#l20.2332"></a><span id="l20.2332"> </span>
<a href="#l20.2333"></a><span id="l20.2333">   // store folder's last sync time</span>
<a href="#l20.2334"></a><span id="l20.2334" class="difflineminus">-  if (m_autoSyncStateObj)</span>
<a href="#l20.2335"></a><span id="l20.2335" class="difflineminus">-  {</span>
<a href="#l20.2336"></a><span id="l20.2336" class="difflineplus">+  if (m_autoSyncStateObj) {</span>
<a href="#l20.2337"></a><span id="l20.2337">     PRTime lastSyncTime;</span>
<a href="#l20.2338"></a><span id="l20.2338">     m_autoSyncStateObj-&gt;GetLastSyncTime(&amp;lastSyncTime);</span>
<a href="#l20.2339"></a><span id="l20.2339">     // store in sec</span>
<a href="#l20.2340"></a><span id="l20.2340" class="difflineminus">-    element-&gt;SetInt32Property(&quot;lastSyncTimeInSec&quot;, (int32_t) (lastSyncTime / PR_USEC_PER_SEC));</span>
<a href="#l20.2341"></a><span id="l20.2341" class="difflineplus">+    element-&gt;SetInt32Property(&quot;lastSyncTimeInSec&quot;,</span>
<a href="#l20.2342"></a><span id="l20.2342" class="difflineplus">+                              (int32_t)(lastSyncTime / PR_USEC_PER_SEC));</span>
<a href="#l20.2343"></a><span id="l20.2343">   }</span>
<a href="#l20.2344"></a><span id="l20.2344"> </span>
<a href="#l20.2345"></a><span id="l20.2345">   return rv;</span>
<a href="#l20.2346"></a><span id="l20.2346"> }</span>
<a href="#l20.2347"></a><span id="l20.2347"> </span>
<a href="#l20.2348"></a><span id="l20.2348"> NS_IMETHODIMP</span>
<a href="#l20.2349"></a><span id="l20.2349" class="difflineminus">-nsImapMailFolder::MarkMessagesFlagged(nsIArray *messages, bool markFlagged)</span>
<a href="#l20.2350"></a><span id="l20.2350" class="difflineminus">-{</span>
<a href="#l20.2351"></a><span id="l20.2351" class="difflineplus">+nsImapMailFolder::MarkMessagesFlagged(nsIArray *messages, bool markFlagged) {</span>
<a href="#l20.2352"></a><span id="l20.2352">   nsresult rv;</span>
<a href="#l20.2353"></a><span id="l20.2353">   // tell the folder to do it, which will mark them read in the db.</span>
<a href="#l20.2354"></a><span id="l20.2354">   rv = nsMsgDBFolder::MarkMessagesFlagged(messages, markFlagged);</span>
<a href="#l20.2355"></a><span id="l20.2355" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l20.2356"></a><span id="l20.2356" class="difflineminus">-  {</span>
<a href="#l20.2357"></a><span id="l20.2357" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.2358"></a><span id="l20.2358">     nsAutoCString messageIds;</span>
<a href="#l20.2359"></a><span id="l20.2359">     nsTArray&lt;nsMsgKey&gt; keysToMarkFlagged;</span>
<a href="#l20.2360"></a><span id="l20.2360">     rv = BuildIdsAndKeyArray(messages, messageIds, keysToMarkFlagged);</span>
<a href="#l20.2361"></a><span id="l20.2361">     if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.2362"></a><span id="l20.2362" class="difflineminus">-    rv = StoreImapFlags(kImapMsgFlaggedFlag, markFlagged,  keysToMarkFlagged.Elements(),</span>
<a href="#l20.2363"></a><span id="l20.2363" class="difflineplus">+    rv = StoreImapFlags(kImapMsgFlaggedFlag, markFlagged,</span>
<a href="#l20.2364"></a><span id="l20.2364" class="difflineplus">+                        keysToMarkFlagged.Elements(),</span>
<a href="#l20.2365"></a><span id="l20.2365">                         keysToMarkFlagged.Length(), nullptr);</span>
<a href="#l20.2366"></a><span id="l20.2366">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2367"></a><span id="l20.2367">     rv = GetDatabase();</span>
<a href="#l20.2368"></a><span id="l20.2368">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2369"></a><span id="l20.2369">     mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.2370"></a><span id="l20.2370">   }</span>
<a href="#l20.2371"></a><span id="l20.2371">   return rv;</span>
<a href="#l20.2372"></a><span id="l20.2372"> }</span>
<a href="#l20.2373"></a><span id="l20.2373"> </span>
<a href="#l20.2374"></a><span id="l20.2374" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetOnlineName(const nsACString&amp; aOnlineFolderName)</span>
<a href="#l20.2375"></a><span id="l20.2375" class="difflineminus">-{</span>
<a href="#l20.2376"></a><span id="l20.2376" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetOnlineName(</span>
<a href="#l20.2377"></a><span id="l20.2377" class="difflineplus">+    const nsACString &amp;aOnlineFolderName) {</span>
<a href="#l20.2378"></a><span id="l20.2378">   nsresult rv;</span>
<a href="#l20.2379"></a><span id="l20.2379">   nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l20.2380"></a><span id="l20.2380">   nsCOMPtr&lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l20.2381"></a><span id="l20.2381">   rv = GetDBFolderInfoAndDB(getter_AddRefs(folderInfo), getter_AddRefs(db));</span>
<a href="#l20.2382"></a><span id="l20.2382" class="difflineminus">-  // do this after GetDBFolderInfoAndDB, because it crunches m_onlineFolderName (not sure why)</span>
<a href="#l20.2383"></a><span id="l20.2383" class="difflineplus">+  // do this after GetDBFolderInfoAndDB, because it crunches m_onlineFolderName</span>
<a href="#l20.2384"></a><span id="l20.2384" class="difflineplus">+  // (not sure why)</span>
<a href="#l20.2385"></a><span id="l20.2385">   m_onlineFolderName = aOnlineFolderName;</span>
<a href="#l20.2386"></a><span id="l20.2386" class="difflineminus">-  if(NS_SUCCEEDED(rv) &amp;&amp; folderInfo)</span>
<a href="#l20.2387"></a><span id="l20.2387" class="difflineminus">-  {</span>
<a href="#l20.2388"></a><span id="l20.2388" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; folderInfo) {</span>
<a href="#l20.2389"></a><span id="l20.2389">     nsAutoString onlineName;</span>
<a href="#l20.2390"></a><span id="l20.2390">     CopyASCIItoUTF16(aOnlineFolderName, onlineName);</span>
<a href="#l20.2391"></a><span id="l20.2391">     rv = folderInfo-&gt;SetProperty(&quot;onlineName&quot;, onlineName);</span>
<a href="#l20.2392"></a><span id="l20.2392">     rv = folderInfo-&gt;SetMailboxName(onlineName);</span>
<a href="#l20.2393"></a><span id="l20.2393">     // so, when are we going to commit this? Definitely not every time!</span>
<a href="#l20.2394"></a><span id="l20.2394">     // We could check if the online name has changed.</span>
<a href="#l20.2395"></a><span id="l20.2395">     db-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.2396"></a><span id="l20.2396">   }</span>
<a href="#l20.2397"></a><span id="l20.2397">   folderInfo = nullptr;</span>
<a href="#l20.2398"></a><span id="l20.2398">   return rv;</span>
<a href="#l20.2399"></a><span id="l20.2399"> }</span>
<a href="#l20.2400"></a><span id="l20.2400"> </span>
<a href="#l20.2401"></a><span id="l20.2401" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetOnlineName(nsACString&amp; aOnlineFolderName)</span>
<a href="#l20.2402"></a><span id="l20.2402" class="difflineminus">-{</span>
<a href="#l20.2403"></a><span id="l20.2403" class="difflineminus">-  ReadDBFolderInfo(false); // update cache first.</span>
<a href="#l20.2404"></a><span id="l20.2404" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetOnlineName(nsACString &amp;aOnlineFolderName) {</span>
<a href="#l20.2405"></a><span id="l20.2405" class="difflineplus">+  ReadDBFolderInfo(false);  // update cache first.</span>
<a href="#l20.2406"></a><span id="l20.2406">   aOnlineFolderName = m_onlineFolderName;</span>
<a href="#l20.2407"></a><span id="l20.2407">   return NS_OK;</span>
<a href="#l20.2408"></a><span id="l20.2408"> }</span>
<a href="#l20.2409"></a><span id="l20.2409"> </span>
<a href="#l20.2410"></a><span id="l20.2410"> NS_IMETHODIMP</span>
<a href="#l20.2411"></a><span id="l20.2411" class="difflineminus">-nsImapMailFolder::GetDBFolderInfoAndDB(nsIDBFolderInfo **folderInfo, nsIMsgDatabase **db)</span>
<a href="#l20.2412"></a><span id="l20.2412" class="difflineminus">-{</span>
<a href="#l20.2413"></a><span id="l20.2413" class="difflineminus">-  NS_ENSURE_ARG_POINTER (folderInfo);</span>
<a href="#l20.2414"></a><span id="l20.2414" class="difflineminus">-  NS_ENSURE_ARG_POINTER (db);</span>
<a href="#l20.2415"></a><span id="l20.2415" class="difflineplus">+nsImapMailFolder::GetDBFolderInfoAndDB(nsIDBFolderInfo **folderInfo,</span>
<a href="#l20.2416"></a><span id="l20.2416" class="difflineplus">+                                       nsIMsgDatabase **db) {</span>
<a href="#l20.2417"></a><span id="l20.2417" class="difflineplus">+  NS_ENSURE_ARG_POINTER(folderInfo);</span>
<a href="#l20.2418"></a><span id="l20.2418" class="difflineplus">+  NS_ENSURE_ARG_POINTER(db);</span>
<a href="#l20.2419"></a><span id="l20.2419"> </span>
<a href="#l20.2420"></a><span id="l20.2420">   nsresult rv = GetDatabase();</span>
<a href="#l20.2421"></a><span id="l20.2421" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l20.2422"></a><span id="l20.2422" class="difflineminus">-    return rv;</span>
<a href="#l20.2423"></a><span id="l20.2423" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.2424"></a><span id="l20.2424"> </span>
<a href="#l20.2425"></a><span id="l20.2425">   NS_ADDREF(*db = mDatabase);</span>
<a href="#l20.2426"></a><span id="l20.2426"> </span>
<a href="#l20.2427"></a><span id="l20.2427">   rv = (*db)-&gt;GetDBFolderInfo(folderInfo);</span>
<a href="#l20.2428"></a><span id="l20.2428">   if (NS_FAILED(rv))</span>
<a href="#l20.2429"></a><span id="l20.2429" class="difflineminus">-    return rv; //GetDBFolderInfo can't return NS_OK if !folderInfo</span>
<a href="#l20.2430"></a><span id="l20.2430" class="difflineplus">+    return rv;  // GetDBFolderInfo can't return NS_OK if !folderInfo</span>
<a href="#l20.2431"></a><span id="l20.2431"> </span>
<a href="#l20.2432"></a><span id="l20.2432">   nsCString onlineName;</span>
<a href="#l20.2433"></a><span id="l20.2433">   rv = (*folderInfo)-&gt;GetCharProperty(&quot;onlineName&quot;, onlineName);</span>
<a href="#l20.2434"></a><span id="l20.2434" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l20.2435"></a><span id="l20.2435" class="difflineminus">-    return rv;</span>
<a href="#l20.2436"></a><span id="l20.2436" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.2437"></a><span id="l20.2437"> </span>
<a href="#l20.2438"></a><span id="l20.2438">   if (!onlineName.IsEmpty())</span>
<a href="#l20.2439"></a><span id="l20.2439">     m_onlineFolderName.Assign(onlineName);</span>
<a href="#l20.2440"></a><span id="l20.2440" class="difflineminus">-  else</span>
<a href="#l20.2441"></a><span id="l20.2441" class="difflineminus">-  {</span>
<a href="#l20.2442"></a><span id="l20.2442" class="difflineplus">+  else {</span>
<a href="#l20.2443"></a><span id="l20.2443">     nsAutoString autoOnlineName;</span>
<a href="#l20.2444"></a><span id="l20.2444">     (*folderInfo)-&gt;GetMailboxName(autoOnlineName);</span>
<a href="#l20.2445"></a><span id="l20.2445" class="difflineminus">-    if (autoOnlineName.IsEmpty())</span>
<a href="#l20.2446"></a><span id="l20.2446" class="difflineminus">-    {</span>
<a href="#l20.2447"></a><span id="l20.2447" class="difflineplus">+    if (autoOnlineName.IsEmpty()) {</span>
<a href="#l20.2448"></a><span id="l20.2448">       nsCString uri;</span>
<a href="#l20.2449"></a><span id="l20.2449">       rv = GetURI(uri);</span>
<a href="#l20.2450"></a><span id="l20.2450">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2451"></a><span id="l20.2451"> </span>
<a href="#l20.2452"></a><span id="l20.2452">       nsCString hostname;</span>
<a href="#l20.2453"></a><span id="l20.2453">       rv = GetHostname(hostname);</span>
<a href="#l20.2454"></a><span id="l20.2454">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2455"></a><span id="l20.2455"> </span>
<a href="#l20.2456"></a><span id="l20.2456">       nsCString onlineCName;</span>
<a href="#l20.2457"></a><span id="l20.2457" class="difflineminus">-      rv = nsImapURI2FullName(kImapRootURI, hostname.get(), uri.get(), getter_Copies(onlineCName));</span>
<a href="#l20.2458"></a><span id="l20.2458" class="difflineplus">+      rv = nsImapURI2FullName(kImapRootURI, hostname.get(), uri.get(),</span>
<a href="#l20.2459"></a><span id="l20.2459" class="difflineplus">+                              getter_Copies(onlineCName));</span>
<a href="#l20.2460"></a><span id="l20.2460">       if (m_hierarchyDelimiter != '/')</span>
<a href="#l20.2461"></a><span id="l20.2461">         MsgReplaceChar(onlineCName, '/', m_hierarchyDelimiter);</span>
<a href="#l20.2462"></a><span id="l20.2462">       m_onlineFolderName.Assign(onlineCName);</span>
<a href="#l20.2463"></a><span id="l20.2463">       CopyASCIItoUTF16(onlineCName, autoOnlineName);</span>
<a href="#l20.2464"></a><span id="l20.2464">     }</span>
<a href="#l20.2465"></a><span id="l20.2465">     (*folderInfo)-&gt;SetProperty(&quot;onlineName&quot;, autoOnlineName);</span>
<a href="#l20.2466"></a><span id="l20.2466">   }</span>
<a href="#l20.2467"></a><span id="l20.2467">   return rv;</span>
<a href="#l20.2468"></a><span id="l20.2468"> }</span>
<a href="#l20.2469"></a><span id="l20.2469"> </span>
<a href="#l20.2470"></a><span id="l20.2470" class="difflineminus">-/* static */ nsresult</span>
<a href="#l20.2471"></a><span id="l20.2471" class="difflineminus">-nsImapMailFolder::BuildIdsAndKeyArray(nsIArray* messages,</span>
<a href="#l20.2472"></a><span id="l20.2472" class="difflineminus">-                                      nsCString&amp; msgIds,</span>
<a href="#l20.2473"></a><span id="l20.2473" class="difflineminus">-                                      nsTArray&lt;nsMsgKey&gt;&amp; keyArray)</span>
<a href="#l20.2474"></a><span id="l20.2474" class="difflineminus">-{</span>
<a href="#l20.2475"></a><span id="l20.2475" class="difflineplus">+/* static */ nsresult nsImapMailFolder::BuildIdsAndKeyArray(</span>
<a href="#l20.2476"></a><span id="l20.2476" class="difflineplus">+    nsIArray *messages, nsCString &amp;msgIds, nsTArray&lt;nsMsgKey&gt; &amp;keyArray) {</span>
<a href="#l20.2477"></a><span id="l20.2477">   NS_ENSURE_ARG_POINTER(messages);</span>
<a href="#l20.2478"></a><span id="l20.2478">   nsresult rv;</span>
<a href="#l20.2479"></a><span id="l20.2479">   uint32_t count = 0;</span>
<a href="#l20.2480"></a><span id="l20.2480">   uint32_t i;</span>
<a href="#l20.2481"></a><span id="l20.2481">   rv = messages-&gt;GetLength(&amp;count);</span>
<a href="#l20.2482"></a><span id="l20.2482">   if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.2483"></a><span id="l20.2483"> </span>
<a href="#l20.2484"></a><span id="l20.2484">   // build up message keys.</span>
<a href="#l20.2485"></a><span id="l20.2485" class="difflineminus">-  for (i = 0; i &lt; count; i++)</span>
<a href="#l20.2486"></a><span id="l20.2486" class="difflineminus">-  {</span>
<a href="#l20.2487"></a><span id="l20.2487" class="difflineplus">+  for (i = 0; i &lt; count; i++) {</span>
<a href="#l20.2488"></a><span id="l20.2488">     nsMsgKey key;</span>
<a href="#l20.2489"></a><span id="l20.2489" class="difflineminus">-    nsCOMPtr &lt;nsIMsgDBHdr&gt; msgDBHdr = do_QueryElementAt(messages, i, &amp;rv);</span>
<a href="#l20.2490"></a><span id="l20.2490" class="difflineminus">-    if (msgDBHdr)</span>
<a href="#l20.2491"></a><span id="l20.2491" class="difflineminus">-      rv = msgDBHdr-&gt;GetMessageKey(&amp;key);</span>
<a href="#l20.2492"></a><span id="l20.2492" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l20.2493"></a><span id="l20.2493" class="difflineminus">-      keyArray.AppendElement(key);</span>
<a href="#l20.2494"></a><span id="l20.2494" class="difflineminus">-  }</span>
<a href="#l20.2495"></a><span id="l20.2495" class="difflineminus">-  return AllocateUidStringFromKeys(keyArray.Elements(), keyArray.Length(), msgIds);</span>
<a href="#l20.2496"></a><span id="l20.2496" class="difflineminus">-}</span>
<a href="#l20.2497"></a><span id="l20.2497" class="difflineminus">-</span>
<a href="#l20.2498"></a><span id="l20.2498" class="difflineminus">-static int CompareKey (const void *v1, const void *v2, void *)</span>
<a href="#l20.2499"></a><span id="l20.2499" class="difflineminus">-{</span>
<a href="#l20.2500"></a><span id="l20.2500" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; msgDBHdr = do_QueryElementAt(messages, i, &amp;rv);</span>
<a href="#l20.2501"></a><span id="l20.2501" class="difflineplus">+    if (msgDBHdr) rv = msgDBHdr-&gt;GetMessageKey(&amp;key);</span>
<a href="#l20.2502"></a><span id="l20.2502" class="difflineplus">+    if (NS_SUCCEEDED(rv)) keyArray.AppendElement(key);</span>
<a href="#l20.2503"></a><span id="l20.2503" class="difflineplus">+  }</span>
<a href="#l20.2504"></a><span id="l20.2504" class="difflineplus">+  return AllocateUidStringFromKeys(keyArray.Elements(), keyArray.Length(),</span>
<a href="#l20.2505"></a><span id="l20.2505" class="difflineplus">+                                   msgIds);</span>
<a href="#l20.2506"></a><span id="l20.2506" class="difflineplus">+}</span>
<a href="#l20.2507"></a><span id="l20.2507" class="difflineplus">+</span>
<a href="#l20.2508"></a><span id="l20.2508" class="difflineplus">+static int CompareKey(const void *v1, const void *v2, void *) {</span>
<a href="#l20.2509"></a><span id="l20.2509">   // QuickSort callback to compare array values</span>
<a href="#l20.2510"></a><span id="l20.2510">   nsMsgKey i1 = *(nsMsgKey *)v1;</span>
<a href="#l20.2511"></a><span id="l20.2511">   nsMsgKey i2 = *(nsMsgKey *)v2;</span>
<a href="#l20.2512"></a><span id="l20.2512">   return i1 - i2;</span>
<a href="#l20.2513"></a><span id="l20.2513"> }</span>
<a href="#l20.2514"></a><span id="l20.2514"> </span>
<a href="#l20.2515"></a><span id="l20.2515" class="difflineminus">-/* static */nsresult</span>
<a href="#l20.2516"></a><span id="l20.2516" class="difflineminus">-nsImapMailFolder::AllocateUidStringFromKeys(nsMsgKey *keys, uint32_t numKeys, nsCString &amp;msgIds)</span>
<a href="#l20.2517"></a><span id="l20.2517" class="difflineminus">-{</span>
<a href="#l20.2518"></a><span id="l20.2518" class="difflineminus">-  if (!numKeys)</span>
<a href="#l20.2519"></a><span id="l20.2519" class="difflineminus">-    return NS_ERROR_INVALID_ARG;</span>
<a href="#l20.2520"></a><span id="l20.2520" class="difflineplus">+/* static */ nsresult nsImapMailFolder::AllocateUidStringFromKeys(</span>
<a href="#l20.2521"></a><span id="l20.2521" class="difflineplus">+    nsMsgKey *keys, uint32_t numKeys, nsCString &amp;msgIds) {</span>
<a href="#l20.2522"></a><span id="l20.2522" class="difflineplus">+  if (!numKeys) return NS_ERROR_INVALID_ARG;</span>
<a href="#l20.2523"></a><span id="l20.2523">   nsresult rv = NS_OK;</span>
<a href="#l20.2524"></a><span id="l20.2524">   uint32_t startSequence;</span>
<a href="#l20.2525"></a><span id="l20.2525">   startSequence = keys[0];</span>
<a href="#l20.2526"></a><span id="l20.2526">   uint32_t curSequenceEnd = startSequence;</span>
<a href="#l20.2527"></a><span id="l20.2527">   uint32_t total = numKeys;</span>
<a href="#l20.2528"></a><span id="l20.2528">   // sort keys and then generate ranges instead of singletons!</span>
<a href="#l20.2529"></a><span id="l20.2529">   NS_QuickSort(keys, numKeys, sizeof(nsMsgKey), CompareKey, nullptr);</span>
<a href="#l20.2530"></a><span id="l20.2530" class="difflineminus">-  for (uint32_t keyIndex = 0; keyIndex &lt; total; keyIndex++)</span>
<a href="#l20.2531"></a><span id="l20.2531" class="difflineminus">-  {</span>
<a href="#l20.2532"></a><span id="l20.2532" class="difflineplus">+  for (uint32_t keyIndex = 0; keyIndex &lt; total; keyIndex++) {</span>
<a href="#l20.2533"></a><span id="l20.2533">     uint32_t curKey = keys[keyIndex];</span>
<a href="#l20.2534"></a><span id="l20.2534">     uint32_t nextKey = (keyIndex + 1 &lt; total) ? keys[keyIndex + 1] : 0xFFFFFFFF;</span>
<a href="#l20.2535"></a><span id="l20.2535">     bool lastKey = (nextKey == 0xFFFFFFFF);</span>
<a href="#l20.2536"></a><span id="l20.2536"> </span>
<a href="#l20.2537"></a><span id="l20.2537" class="difflineminus">-    if (lastKey)</span>
<a href="#l20.2538"></a><span id="l20.2538" class="difflineminus">-      curSequenceEnd = curKey;</span>
<a href="#l20.2539"></a><span id="l20.2539" class="difflineminus">-    if (nextKey == (uint32_t) curSequenceEnd + 1 &amp;&amp; !lastKey)</span>
<a href="#l20.2540"></a><span id="l20.2540" class="difflineminus">-    {</span>
<a href="#l20.2541"></a><span id="l20.2541" class="difflineplus">+    if (lastKey) curSequenceEnd = curKey;</span>
<a href="#l20.2542"></a><span id="l20.2542" class="difflineplus">+    if (nextKey == (uint32_t)curSequenceEnd + 1 &amp;&amp; !lastKey) {</span>
<a href="#l20.2543"></a><span id="l20.2543">       curSequenceEnd = nextKey;</span>
<a href="#l20.2544"></a><span id="l20.2544">       continue;</span>
<a href="#l20.2545"></a><span id="l20.2545">     }</span>
<a href="#l20.2546"></a><span id="l20.2546" class="difflineminus">-    if (curSequenceEnd &gt; startSequence)</span>
<a href="#l20.2547"></a><span id="l20.2547" class="difflineminus">-    {</span>
<a href="#l20.2548"></a><span id="l20.2548" class="difflineplus">+    if (curSequenceEnd &gt; startSequence) {</span>
<a href="#l20.2549"></a><span id="l20.2549">       AppendUid(msgIds, startSequence);</span>
<a href="#l20.2550"></a><span id="l20.2550">       msgIds += ':';</span>
<a href="#l20.2551"></a><span id="l20.2551" class="difflineminus">-      AppendUid(msgIds,curSequenceEnd);</span>
<a href="#l20.2552"></a><span id="l20.2552" class="difflineminus">-      if (!lastKey)</span>
<a href="#l20.2553"></a><span id="l20.2553" class="difflineminus">-        msgIds += ',';</span>
<a href="#l20.2554"></a><span id="l20.2554" class="difflineplus">+      AppendUid(msgIds, curSequenceEnd);</span>
<a href="#l20.2555"></a><span id="l20.2555" class="difflineplus">+      if (!lastKey) msgIds += ',';</span>
<a href="#l20.2556"></a><span id="l20.2556">       startSequence = nextKey;</span>
<a href="#l20.2557"></a><span id="l20.2557">       curSequenceEnd = startSequence;</span>
<a href="#l20.2558"></a><span id="l20.2558" class="difflineminus">-    }</span>
<a href="#l20.2559"></a><span id="l20.2559" class="difflineminus">-    else</span>
<a href="#l20.2560"></a><span id="l20.2560" class="difflineminus">-    {</span>
<a href="#l20.2561"></a><span id="l20.2561" class="difflineplus">+    } else {</span>
<a href="#l20.2562"></a><span id="l20.2562">       startSequence = nextKey;</span>
<a href="#l20.2563"></a><span id="l20.2563">       curSequenceEnd = startSequence;</span>
<a href="#l20.2564"></a><span id="l20.2564">       AppendUid(msgIds, keys[keyIndex]);</span>
<a href="#l20.2565"></a><span id="l20.2565" class="difflineminus">-      if (!lastKey)</span>
<a href="#l20.2566"></a><span id="l20.2566" class="difflineminus">-        msgIds += ',';</span>
<a href="#l20.2567"></a><span id="l20.2567" class="difflineplus">+      if (!lastKey) msgIds += ',';</span>
<a href="#l20.2568"></a><span id="l20.2568">     }</span>
<a href="#l20.2569"></a><span id="l20.2569">   }</span>
<a href="#l20.2570"></a><span id="l20.2570">   return rv;</span>
<a href="#l20.2571"></a><span id="l20.2571"> }</span>
<a href="#l20.2572"></a><span id="l20.2572"> </span>
<a href="#l20.2573"></a><span id="l20.2573" class="difflineminus">-nsresult nsImapMailFolder::MarkMessagesImapDeleted(nsTArray&lt;nsMsgKey&gt; *keyArray, bool deleted, nsIMsgDatabase *db)</span>
<a href="#l20.2574"></a><span id="l20.2574" class="difflineminus">-{</span>
<a href="#l20.2575"></a><span id="l20.2575" class="difflineminus">-  for (uint32_t kindex = 0; kindex &lt; keyArray-&gt;Length(); kindex++)</span>
<a href="#l20.2576"></a><span id="l20.2576" class="difflineminus">-  {</span>
<a href="#l20.2577"></a><span id="l20.2577" class="difflineplus">+nsresult nsImapMailFolder::MarkMessagesImapDeleted(nsTArray&lt;nsMsgKey&gt; *keyArray,</span>
<a href="#l20.2578"></a><span id="l20.2578" class="difflineplus">+                                                   bool deleted,</span>
<a href="#l20.2579"></a><span id="l20.2579" class="difflineplus">+                                                   nsIMsgDatabase *db) {</span>
<a href="#l20.2580"></a><span id="l20.2580" class="difflineplus">+  for (uint32_t kindex = 0; kindex &lt; keyArray-&gt;Length(); kindex++) {</span>
<a href="#l20.2581"></a><span id="l20.2581">     nsMsgKey key = keyArray-&gt;ElementAt(kindex);</span>
<a href="#l20.2582"></a><span id="l20.2582">     db-&gt;MarkImapDeleted(key, deleted, nullptr);</span>
<a href="#l20.2583"></a><span id="l20.2583">   }</span>
<a href="#l20.2584"></a><span id="l20.2584">   return NS_OK;</span>
<a href="#l20.2585"></a><span id="l20.2585"> }</span>
<a href="#l20.2586"></a><span id="l20.2586"> </span>
<a href="#l20.2587"></a><span id="l20.2587" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::DeleteMessages(nsIArray *messages,</span>
<a href="#l20.2588"></a><span id="l20.2588" class="difflineminus">-                                               nsIMsgWindow *msgWindow,</span>
<a href="#l20.2589"></a><span id="l20.2589" class="difflineminus">-                                               bool deleteStorage, bool isMove,</span>
<a href="#l20.2590"></a><span id="l20.2590" class="difflineminus">-                                               nsIMsgCopyServiceListener* listener,</span>
<a href="#l20.2591"></a><span id="l20.2591" class="difflineminus">-                                               bool allowUndo)</span>
<a href="#l20.2592"></a><span id="l20.2592" class="difflineminus">-{</span>
<a href="#l20.2593"></a><span id="l20.2593" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::DeleteMessages(</span>
<a href="#l20.2594"></a><span id="l20.2594" class="difflineplus">+    nsIArray *messages, nsIMsgWindow *msgWindow, bool deleteStorage,</span>
<a href="#l20.2595"></a><span id="l20.2595" class="difflineplus">+    bool isMove, nsIMsgCopyServiceListener *listener, bool allowUndo) {</span>
<a href="#l20.2596"></a><span id="l20.2596">   // *** jt - assuming delete is move to the trash folder for now</span>
<a href="#l20.2597"></a><span id="l20.2597">   nsAutoCString uri;</span>
<a href="#l20.2598"></a><span id="l20.2598">   bool deleteImmediatelyNoTrash = false;</span>
<a href="#l20.2599"></a><span id="l20.2599">   nsAutoCString messageIds;</span>
<a href="#l20.2600"></a><span id="l20.2600">   nsTArray&lt;nsMsgKey&gt; srcKeyArray;</span>
<a href="#l20.2601"></a><span id="l20.2601" class="difflineminus">-  bool deleteMsgs = true;  //used for toggling delete status - default is true</span>
<a href="#l20.2602"></a><span id="l20.2602" class="difflineplus">+  bool deleteMsgs = true;  // used for toggling delete status - default is true</span>
<a href="#l20.2603"></a><span id="l20.2603">   nsMsgImapDeleteModel deleteModel = nsMsgImapDeleteModels::MoveToTrash;</span>
<a href="#l20.2604"></a><span id="l20.2604">   imapMessageFlagsType messageFlags = kImapMsgDeletedFlag;</span>
<a href="#l20.2605"></a><span id="l20.2605"> </span>
<a href="#l20.2606"></a><span id="l20.2606">   nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.2607"></a><span id="l20.2607">   nsresult rv = GetFlag(nsMsgFolderFlags::Trash, &amp;deleteImmediatelyNoTrash);</span>
<a href="#l20.2608"></a><span id="l20.2608">   rv = GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.2609"></a><span id="l20.2609"> </span>
<a href="#l20.2610"></a><span id="l20.2610" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; imapServer)</span>
<a href="#l20.2611"></a><span id="l20.2611" class="difflineminus">-  {</span>
<a href="#l20.2612"></a><span id="l20.2612" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; imapServer) {</span>
<a href="#l20.2613"></a><span id="l20.2613">     imapServer-&gt;GetDeleteModel(&amp;deleteModel);</span>
<a href="#l20.2614"></a><span id="l20.2614">     if (deleteModel != nsMsgImapDeleteModels::MoveToTrash || deleteStorage)</span>
<a href="#l20.2615"></a><span id="l20.2615">       deleteImmediatelyNoTrash = true;</span>
<a href="#l20.2616"></a><span id="l20.2616">     // if we're deleting a message, we should pseudo-interrupt the msg</span>
<a href="#l20.2617"></a><span id="l20.2617" class="difflineminus">-    //load of the current message.</span>
<a href="#l20.2618"></a><span id="l20.2618" class="difflineplus">+    // load of the current message.</span>
<a href="#l20.2619"></a><span id="l20.2619">     bool interrupted = false;</span>
<a href="#l20.2620"></a><span id="l20.2620">     imapServer-&gt;PseudoInterruptMsgLoad(this, msgWindow, &amp;interrupted);</span>
<a href="#l20.2621"></a><span id="l20.2621">   }</span>
<a href="#l20.2622"></a><span id="l20.2622"> </span>
<a href="#l20.2623"></a><span id="l20.2623">   rv = BuildIdsAndKeyArray(messages, messageIds, srcKeyArray);</span>
<a href="#l20.2624"></a><span id="l20.2624">   if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.2625"></a><span id="l20.2625"> </span>
<a href="#l20.2626"></a><span id="l20.2626">   nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l20.2627"></a><span id="l20.2627">   nsCOMPtr&lt;nsIMsgFolder&gt; trashFolder;</span>
<a href="#l20.2628"></a><span id="l20.2628"> </span>
<a href="#l20.2629"></a><span id="l20.2629" class="difflineminus">-  if (!deleteImmediatelyNoTrash)</span>
<a href="#l20.2630"></a><span id="l20.2630" class="difflineminus">-  {</span>
<a href="#l20.2631"></a><span id="l20.2631" class="difflineplus">+  if (!deleteImmediatelyNoTrash) {</span>
<a href="#l20.2632"></a><span id="l20.2632">     rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l20.2633"></a><span id="l20.2633" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder)</span>
<a href="#l20.2634"></a><span id="l20.2634" class="difflineminus">-    {</span>
<a href="#l20.2635"></a><span id="l20.2635" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder) {</span>
<a href="#l20.2636"></a><span id="l20.2636">       rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Trash,</span>
<a href="#l20.2637"></a><span id="l20.2637">                                      getter_AddRefs(trashFolder));</span>
<a href="#l20.2638"></a><span id="l20.2638">       NS_ASSERTION(trashFolder, &quot;couldn't find trash&quot;);</span>
<a href="#l20.2639"></a><span id="l20.2639" class="difflineminus">-      // if we can't find the trash, we'll just have to do an imap delete and pretend this is the trash</span>
<a href="#l20.2640"></a><span id="l20.2640" class="difflineminus">-      if (!trashFolder)</span>
<a href="#l20.2641"></a><span id="l20.2641" class="difflineminus">-        deleteImmediatelyNoTrash = true;</span>
<a href="#l20.2642"></a><span id="l20.2642" class="difflineminus">-    }</span>
<a href="#l20.2643"></a><span id="l20.2643" class="difflineminus">-  }</span>
<a href="#l20.2644"></a><span id="l20.2644" class="difflineminus">-</span>
<a href="#l20.2645"></a><span id="l20.2645" class="difflineminus">-  if ((NS_SUCCEEDED(rv) &amp;&amp; deleteImmediatelyNoTrash) || deleteModel == nsMsgImapDeleteModels::IMAPDelete )</span>
<a href="#l20.2646"></a><span id="l20.2646" class="difflineminus">-  {</span>
<a href="#l20.2647"></a><span id="l20.2647" class="difflineminus">-    if (allowUndo)</span>
<a href="#l20.2648"></a><span id="l20.2648" class="difflineminus">-    {</span>
<a href="#l20.2649"></a><span id="l20.2649" class="difflineminus">-      //need to take care of these two delete models</span>
<a href="#l20.2650"></a><span id="l20.2650" class="difflineplus">+      // if we can't find the trash, we'll just have to do an imap delete and</span>
<a href="#l20.2651"></a><span id="l20.2651" class="difflineplus">+      // pretend this is the trash</span>
<a href="#l20.2652"></a><span id="l20.2652" class="difflineplus">+      if (!trashFolder) deleteImmediatelyNoTrash = true;</span>
<a href="#l20.2653"></a><span id="l20.2653" class="difflineplus">+    }</span>
<a href="#l20.2654"></a><span id="l20.2654" class="difflineplus">+  }</span>
<a href="#l20.2655"></a><span id="l20.2655" class="difflineplus">+</span>
<a href="#l20.2656"></a><span id="l20.2656" class="difflineplus">+  if ((NS_SUCCEEDED(rv) &amp;&amp; deleteImmediatelyNoTrash) ||</span>
<a href="#l20.2657"></a><span id="l20.2657" class="difflineplus">+      deleteModel == nsMsgImapDeleteModels::IMAPDelete) {</span>
<a href="#l20.2658"></a><span id="l20.2658" class="difflineplus">+    if (allowUndo) {</span>
<a href="#l20.2659"></a><span id="l20.2659" class="difflineplus">+      // need to take care of these two delete models</span>
<a href="#l20.2660"></a><span id="l20.2660">       RefPtr&lt;nsImapMoveCopyMsgTxn&gt; undoMsgTxn = new nsImapMoveCopyMsgTxn;</span>
<a href="#l20.2661"></a><span id="l20.2661" class="difflineminus">-      if (!undoMsgTxn || NS_FAILED(undoMsgTxn-&gt;Init(this, &amp;srcKeyArray, messageIds.get(), nullptr,</span>
<a href="#l20.2662"></a><span id="l20.2662" class="difflineminus">-                                                    true, isMove)))</span>
<a href="#l20.2663"></a><span id="l20.2663" class="difflineplus">+      if (!undoMsgTxn ||</span>
<a href="#l20.2664"></a><span id="l20.2664" class="difflineplus">+          NS_FAILED(undoMsgTxn-&gt;Init(this, &amp;srcKeyArray, messageIds.get(),</span>
<a href="#l20.2665"></a><span id="l20.2665" class="difflineplus">+                                     nullptr, true, isMove)))</span>
<a href="#l20.2666"></a><span id="l20.2666">         return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.2667"></a><span id="l20.2667"> </span>
<a href="#l20.2668"></a><span id="l20.2668">       undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eDeleteMsg);</span>
<a href="#l20.2669"></a><span id="l20.2669" class="difflineminus">-      // we're adding this undo action before the delete is successful. This is evil,</span>
<a href="#l20.2670"></a><span id="l20.2670" class="difflineminus">-      // but 4.5 did it as well.</span>
<a href="#l20.2671"></a><span id="l20.2671" class="difflineminus">-      nsCOMPtr &lt;nsITransactionManager&gt; txnMgr;</span>
<a href="#l20.2672"></a><span id="l20.2672" class="difflineminus">-      if (msgWindow)</span>
<a href="#l20.2673"></a><span id="l20.2673" class="difflineminus">-        msgWindow-&gt;GetTransactionManager(getter_AddRefs(txnMgr));</span>
<a href="#l20.2674"></a><span id="l20.2674" class="difflineminus">-      if (txnMgr)</span>
<a href="#l20.2675"></a><span id="l20.2675" class="difflineminus">-        txnMgr-&gt;DoTransaction(undoMsgTxn);</span>
<a href="#l20.2676"></a><span id="l20.2676" class="difflineminus">-    }</span>
<a href="#l20.2677"></a><span id="l20.2677" class="difflineminus">-</span>
<a href="#l20.2678"></a><span id="l20.2678" class="difflineminus">-    if (deleteModel == nsMsgImapDeleteModels::IMAPDelete &amp;&amp; !deleteStorage)</span>
<a href="#l20.2679"></a><span id="l20.2679" class="difflineminus">-    {</span>
<a href="#l20.2680"></a><span id="l20.2680" class="difflineplus">+      // we're adding this undo action before the delete is successful. This is</span>
<a href="#l20.2681"></a><span id="l20.2681" class="difflineplus">+      // evil, but 4.5 did it as well.</span>
<a href="#l20.2682"></a><span id="l20.2682" class="difflineplus">+      nsCOMPtr&lt;nsITransactionManager&gt; txnMgr;</span>
<a href="#l20.2683"></a><span id="l20.2683" class="difflineplus">+      if (msgWindow) msgWindow-&gt;GetTransactionManager(getter_AddRefs(txnMgr));</span>
<a href="#l20.2684"></a><span id="l20.2684" class="difflineplus">+      if (txnMgr) txnMgr-&gt;DoTransaction(undoMsgTxn);</span>
<a href="#l20.2685"></a><span id="l20.2685" class="difflineplus">+    }</span>
<a href="#l20.2686"></a><span id="l20.2686" class="difflineplus">+</span>
<a href="#l20.2687"></a><span id="l20.2687" class="difflineplus">+    if (deleteModel == nsMsgImapDeleteModels::IMAPDelete &amp;&amp; !deleteStorage) {</span>
<a href="#l20.2688"></a><span id="l20.2688">       uint32_t cnt, flags;</span>
<a href="#l20.2689"></a><span id="l20.2689">       rv = messages-&gt;GetLength(&amp;cnt);</span>
<a href="#l20.2690"></a><span id="l20.2690">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2691"></a><span id="l20.2691">       deleteMsgs = false;</span>
<a href="#l20.2692"></a><span id="l20.2692" class="difflineminus">-      for (uint32_t i=0; i &lt;cnt; i++)</span>
<a href="#l20.2693"></a><span id="l20.2693" class="difflineminus">-      {</span>
<a href="#l20.2694"></a><span id="l20.2694" class="difflineminus">-        nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr = do_QueryElementAt(messages, i);</span>
<a href="#l20.2695"></a><span id="l20.2695" class="difflineminus">-        if (msgHdr)</span>
<a href="#l20.2696"></a><span id="l20.2696" class="difflineminus">-        {</span>
<a href="#l20.2697"></a><span id="l20.2697" class="difflineplus">+      for (uint32_t i = 0; i &lt; cnt; i++) {</span>
<a href="#l20.2698"></a><span id="l20.2698" class="difflineplus">+        nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr = do_QueryElementAt(messages, i);</span>
<a href="#l20.2699"></a><span id="l20.2699" class="difflineplus">+        if (msgHdr) {</span>
<a href="#l20.2700"></a><span id="l20.2700">           msgHdr-&gt;GetFlags(&amp;flags);</span>
<a href="#l20.2701"></a><span id="l20.2701" class="difflineminus">-          if (!(flags &amp; nsMsgMessageFlags::IMAPDeleted))</span>
<a href="#l20.2702"></a><span id="l20.2702" class="difflineminus">-          {</span>
<a href="#l20.2703"></a><span id="l20.2703" class="difflineplus">+          if (!(flags &amp; nsMsgMessageFlags::IMAPDeleted)) {</span>
<a href="#l20.2704"></a><span id="l20.2704">             deleteMsgs = true;</span>
<a href="#l20.2705"></a><span id="l20.2705">             break;</span>
<a href="#l20.2706"></a><span id="l20.2706">           }</span>
<a href="#l20.2707"></a><span id="l20.2707">         }</span>
<a href="#l20.2708"></a><span id="l20.2708">       }</span>
<a href="#l20.2709"></a><span id="l20.2709">     }</span>
<a href="#l20.2710"></a><span id="l20.2710">     // if copy service listener is also a url listener, pass that</span>
<a href="#l20.2711"></a><span id="l20.2711">     // url listener into StoreImapFlags.</span>
<a href="#l20.2712"></a><span id="l20.2712" class="difflineminus">-    nsCOMPtr &lt;nsIUrlListener&gt; urlListener = do_QueryInterface(listener);</span>
<a href="#l20.2713"></a><span id="l20.2713" class="difflineminus">-    if (deleteMsgs)</span>
<a href="#l20.2714"></a><span id="l20.2714" class="difflineminus">-      messageFlags |= kImapMsgSeenFlag;</span>
<a href="#l20.2715"></a><span id="l20.2715" class="difflineplus">+    nsCOMPtr&lt;nsIUrlListener&gt; urlListener = do_QueryInterface(listener);</span>
<a href="#l20.2716"></a><span id="l20.2716" class="difflineplus">+    if (deleteMsgs) messageFlags |= kImapMsgSeenFlag;</span>
<a href="#l20.2717"></a><span id="l20.2717">     rv = StoreImapFlags(messageFlags, deleteMsgs, srcKeyArray.Elements(),</span>
<a href="#l20.2718"></a><span id="l20.2718">                         srcKeyArray.Length(), urlListener);</span>
<a href="#l20.2719"></a><span id="l20.2719"> </span>
<a href="#l20.2720"></a><span id="l20.2720" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l20.2721"></a><span id="l20.2721" class="difflineminus">-    {</span>
<a href="#l20.2722"></a><span id="l20.2722" class="difflineminus">-      if (mDatabase)</span>
<a href="#l20.2723"></a><span id="l20.2723" class="difflineminus">-      {</span>
<a href="#l20.2724"></a><span id="l20.2724" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.2725"></a><span id="l20.2725" class="difflineplus">+      if (mDatabase) {</span>
<a href="#l20.2726"></a><span id="l20.2726">         nsCOMPtr&lt;nsIMsgDatabase&gt; database(mDatabase);</span>
<a href="#l20.2727"></a><span id="l20.2727">         if (deleteModel == nsMsgImapDeleteModels::IMAPDelete)</span>
<a href="#l20.2728"></a><span id="l20.2728">           MarkMessagesImapDeleted(&amp;srcKeyArray, deleteMsgs, database);</span>
<a href="#l20.2729"></a><span id="l20.2729" class="difflineminus">-        else</span>
<a href="#l20.2730"></a><span id="l20.2730" class="difflineminus">-        {</span>
<a href="#l20.2731"></a><span id="l20.2731" class="difflineminus">-          EnableNotifications(allMessageCountNotifications, false);  //&quot;remove it immediately&quot; model</span>
<a href="#l20.2732"></a><span id="l20.2732" class="difflineplus">+        else {</span>
<a href="#l20.2733"></a><span id="l20.2733" class="difflineplus">+          EnableNotifications(allMessageCountNotifications,</span>
<a href="#l20.2734"></a><span id="l20.2734" class="difflineplus">+                              false);  //&quot;remove it immediately&quot; model</span>
<a href="#l20.2735"></a><span id="l20.2735">           // Notify if this is an actual delete.</span>
<a href="#l20.2736"></a><span id="l20.2736" class="difflineminus">-          if (!isMove)</span>
<a href="#l20.2737"></a><span id="l20.2737" class="difflineminus">-          {</span>
<a href="#l20.2738"></a><span id="l20.2738" class="difflineminus">-            nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.2739"></a><span id="l20.2739" class="difflineminus">-            if (notifier)</span>
<a href="#l20.2740"></a><span id="l20.2740" class="difflineminus">-              notifier-&gt;NotifyMsgsDeleted(messages);</span>
<a href="#l20.2741"></a><span id="l20.2741" class="difflineplus">+          if (!isMove) {</span>
<a href="#l20.2742"></a><span id="l20.2742" class="difflineplus">+            nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(</span>
<a href="#l20.2743"></a><span id="l20.2743" class="difflineplus">+                do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.2744"></a><span id="l20.2744" class="difflineplus">+            if (notifier) notifier-&gt;NotifyMsgsDeleted(messages);</span>
<a href="#l20.2745"></a><span id="l20.2745">           }</span>
<a href="#l20.2746"></a><span id="l20.2746">           DeleteStoreMessages(messages);</span>
<a href="#l20.2747"></a><span id="l20.2747" class="difflineminus">-          database-&gt;DeleteMessages(srcKeyArray.Length(), srcKeyArray.Elements(), nullptr);</span>
<a href="#l20.2748"></a><span id="l20.2748" class="difflineplus">+          database-&gt;DeleteMessages(srcKeyArray.Length(), srcKeyArray.Elements(),</span>
<a href="#l20.2749"></a><span id="l20.2749" class="difflineplus">+                                   nullptr);</span>
<a href="#l20.2750"></a><span id="l20.2750">           EnableNotifications(allMessageCountNotifications, true);</span>
<a href="#l20.2751"></a><span id="l20.2751">         }</span>
<a href="#l20.2752"></a><span id="l20.2752" class="difflineminus">-        if (listener)</span>
<a href="#l20.2753"></a><span id="l20.2753" class="difflineminus">-        {</span>
<a href="#l20.2754"></a><span id="l20.2754" class="difflineplus">+        if (listener) {</span>
<a href="#l20.2755"></a><span id="l20.2755">           listener-&gt;OnStartCopy();</span>
<a href="#l20.2756"></a><span id="l20.2756">           listener-&gt;OnStopCopy(NS_OK);</span>
<a href="#l20.2757"></a><span id="l20.2757">         }</span>
<a href="#l20.2758"></a><span id="l20.2758">         NotifyFolderEvent(kDeleteOrMoveMsgCompleted);</span>
<a href="#l20.2759"></a><span id="l20.2759">       }</span>
<a href="#l20.2760"></a><span id="l20.2760">     }</span>
<a href="#l20.2761"></a><span id="l20.2761">     return rv;</span>
<a href="#l20.2762"></a><span id="l20.2762">   }</span>
<a href="#l20.2763"></a><span id="l20.2763"> </span>
<a href="#l20.2764"></a><span id="l20.2764">   // have to move the messages to the trash</span>
<a href="#l20.2765"></a><span id="l20.2765" class="difflineminus">-  if(trashFolder)</span>
<a href="#l20.2766"></a><span id="l20.2766" class="difflineminus">-  {</span>
<a href="#l20.2767"></a><span id="l20.2767" class="difflineplus">+  if (trashFolder) {</span>
<a href="#l20.2768"></a><span id="l20.2768">     nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder;</span>
<a href="#l20.2769"></a><span id="l20.2769" class="difflineminus">-    nsCOMPtr&lt;nsISupports&gt;srcSupport;</span>
<a href="#l20.2770"></a><span id="l20.2770" class="difflineplus">+    nsCOMPtr&lt;nsISupports&gt; srcSupport;</span>
<a href="#l20.2771"></a><span id="l20.2771">     uint32_t count = 0;</span>
<a href="#l20.2772"></a><span id="l20.2772">     rv = messages-&gt;GetLength(&amp;count);</span>
<a href="#l20.2773"></a><span id="l20.2773"> </span>
<a href="#l20.2774"></a><span id="l20.2774">     rv = QueryInterface(NS_GET_IID(nsIMsgFolder), getter_AddRefs(srcFolder));</span>
<a href="#l20.2775"></a><span id="l20.2775" class="difflineminus">-    nsCOMPtr&lt;nsIMsgCopyService&gt; copyService = do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.2776"></a><span id="l20.2776" class="difflineplus">+    nsCOMPtr&lt;nsIMsgCopyService&gt; copyService =</span>
<a href="#l20.2777"></a><span id="l20.2777" class="difflineplus">+        do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.2778"></a><span id="l20.2778">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2779"></a><span id="l20.2779" class="difflineminus">-    rv = copyService-&gt;CopyMessages(srcFolder, messages, trashFolder, true, listener, msgWindow, allowUndo);</span>
<a href="#l20.2780"></a><span id="l20.2780" class="difflineplus">+    rv = copyService-&gt;CopyMessages(srcFolder, messages, trashFolder, true,</span>
<a href="#l20.2781"></a><span id="l20.2781" class="difflineplus">+                                   listener, msgWindow, allowUndo);</span>
<a href="#l20.2782"></a><span id="l20.2782">   }</span>
<a href="#l20.2783"></a><span id="l20.2783"> </span>
<a href="#l20.2784"></a><span id="l20.2784">   return rv;</span>
<a href="#l20.2785"></a><span id="l20.2785"> }</span>
<a href="#l20.2786"></a><span id="l20.2786"> </span>
<a href="#l20.2787"></a><span id="l20.2787"> // check if folder is the trash, or a descendent of the trash</span>
<a href="#l20.2788"></a><span id="l20.2788"> // so we can tell if the folders we're deleting from it should</span>
<a href="#l20.2789"></a><span id="l20.2789"> // be *really* deleted.</span>
<a href="#l20.2790"></a><span id="l20.2790" class="difflineminus">-bool</span>
<a href="#l20.2791"></a><span id="l20.2791" class="difflineminus">-nsImapMailFolder::TrashOrDescendentOfTrash(nsIMsgFolder* folder)</span>
<a href="#l20.2792"></a><span id="l20.2792" class="difflineminus">-{</span>
<a href="#l20.2793"></a><span id="l20.2793" class="difflineplus">+bool nsImapMailFolder::TrashOrDescendentOfTrash(nsIMsgFolder *folder) {</span>
<a href="#l20.2794"></a><span id="l20.2794">   NS_ENSURE_TRUE(folder, false);</span>
<a href="#l20.2795"></a><span id="l20.2795">   nsCOMPtr&lt;nsIMsgFolder&gt; parent;</span>
<a href="#l20.2796"></a><span id="l20.2796">   nsCOMPtr&lt;nsIMsgFolder&gt; curFolder = folder;</span>
<a href="#l20.2797"></a><span id="l20.2797">   nsresult rv;</span>
<a href="#l20.2798"></a><span id="l20.2798">   uint32_t flags = 0;</span>
<a href="#l20.2799"></a><span id="l20.2799" class="difflineminus">-  do</span>
<a href="#l20.2800"></a><span id="l20.2800" class="difflineminus">-  {</span>
<a href="#l20.2801"></a><span id="l20.2801" class="difflineplus">+  do {</span>
<a href="#l20.2802"></a><span id="l20.2802">     rv = curFolder-&gt;GetFlags(&amp;flags);</span>
<a href="#l20.2803"></a><span id="l20.2803">     if (NS_FAILED(rv)) return false;</span>
<a href="#l20.2804"></a><span id="l20.2804" class="difflineminus">-    if (flags &amp; nsMsgFolderFlags::Trash)</span>
<a href="#l20.2805"></a><span id="l20.2805" class="difflineminus">-      return true;</span>
<a href="#l20.2806"></a><span id="l20.2806" class="difflineplus">+    if (flags &amp; nsMsgFolderFlags::Trash) return true;</span>
<a href="#l20.2807"></a><span id="l20.2807">     curFolder-&gt;GetParent(getter_AddRefs(parent));</span>
<a href="#l20.2808"></a><span id="l20.2808">     if (!parent) return false;</span>
<a href="#l20.2809"></a><span id="l20.2809">     curFolder = parent;</span>
<a href="#l20.2810"></a><span id="l20.2810">   } while (NS_SUCCEEDED(rv) &amp;&amp; curFolder);</span>
<a href="#l20.2811"></a><span id="l20.2811">   return false;</span>
<a href="#l20.2812"></a><span id="l20.2812"> }</span>
<a href="#l20.2813"></a><span id="l20.2813"> NS_IMETHODIMP</span>
<a href="#l20.2814"></a><span id="l20.2814" class="difflineminus">-nsImapMailFolder::DeleteSubFolders(nsIArray* folders, nsIMsgWindow *msgWindow)</span>
<a href="#l20.2815"></a><span id="l20.2815" class="difflineminus">-{</span>
<a href="#l20.2816"></a><span id="l20.2816" class="difflineplus">+nsImapMailFolder::DeleteSubFolders(nsIArray *folders, nsIMsgWindow *msgWindow) {</span>
<a href="#l20.2817"></a><span id="l20.2817">   nsCOMPtr&lt;nsIMsgFolder&gt; curFolder;</span>
<a href="#l20.2818"></a><span id="l20.2818">   nsCOMPtr&lt;nsIUrlListener&gt; urlListener;</span>
<a href="#l20.2819"></a><span id="l20.2819">   nsCOMPtr&lt;nsIMsgFolder&gt; trashFolder;</span>
<a href="#l20.2820"></a><span id="l20.2820">   int32_t i;</span>
<a href="#l20.2821"></a><span id="l20.2821">   uint32_t folderCount = 0;</span>
<a href="#l20.2822"></a><span id="l20.2822">   nsresult rv;</span>
<a href="#l20.2823"></a><span id="l20.2823">   // &quot;this&quot; is the folder we're deleting from</span>
<a href="#l20.2824"></a><span id="l20.2824">   bool deleteNoTrash = TrashOrDescendentOfTrash(this) || !DeleteIsMoveToTrash();</span>
<a href="#l20.2825"></a><span id="l20.2825">   bool confirmed = false;</span>
<a href="#l20.2826"></a><span id="l20.2826">   bool confirmDeletion = true;</span>
<a href="#l20.2827"></a><span id="l20.2827"> </span>
<a href="#l20.2828"></a><span id="l20.2828" class="difflineminus">-  nsCOMPtr&lt;nsIMutableArray&gt; foldersRemaining(do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l20.2829"></a><span id="l20.2829" class="difflineplus">+  nsCOMPtr&lt;nsIMutableArray&gt; foldersRemaining(</span>
<a href="#l20.2830"></a><span id="l20.2830" class="difflineplus">+      do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l20.2831"></a><span id="l20.2831">   folders-&gt;GetLength(&amp;folderCount);</span>
<a href="#l20.2832"></a><span id="l20.2832"> </span>
<a href="#l20.2833"></a><span id="l20.2833" class="difflineminus">-  for (i = folderCount - 1; i &gt;= 0; i--)</span>
<a href="#l20.2834"></a><span id="l20.2834" class="difflineminus">-  {</span>
<a href="#l20.2835"></a><span id="l20.2835" class="difflineplus">+  for (i = folderCount - 1; i &gt;= 0; i--) {</span>
<a href="#l20.2836"></a><span id="l20.2836">     curFolder = do_QueryElementAt(folders, i, &amp;rv);</span>
<a href="#l20.2837"></a><span id="l20.2837" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l20.2838"></a><span id="l20.2838" class="difflineminus">-    {</span>
<a href="#l20.2839"></a><span id="l20.2839" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.2840"></a><span id="l20.2840">       uint32_t folderFlags;</span>
<a href="#l20.2841"></a><span id="l20.2841">       curFolder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l20.2842"></a><span id="l20.2842" class="difflineminus">-      if (folderFlags &amp; nsMsgFolderFlags::Virtual)</span>
<a href="#l20.2843"></a><span id="l20.2843" class="difflineminus">-      {</span>
<a href="#l20.2844"></a><span id="l20.2844" class="difflineplus">+      if (folderFlags &amp; nsMsgFolderFlags::Virtual) {</span>
<a href="#l20.2845"></a><span id="l20.2845">         RemoveSubFolder(curFolder);</span>
<a href="#l20.2846"></a><span id="l20.2846">         // since the folder pane only allows single selection, we can do this</span>
<a href="#l20.2847"></a><span id="l20.2847">         deleteNoTrash = confirmed = true;</span>
<a href="#l20.2848"></a><span id="l20.2848">         confirmDeletion = false;</span>
<a href="#l20.2849"></a><span id="l20.2849" class="difflineminus">-      }</span>
<a href="#l20.2850"></a><span id="l20.2850" class="difflineminus">-      else</span>
<a href="#l20.2851"></a><span id="l20.2851" class="difflineplus">+      } else</span>
<a href="#l20.2852"></a><span id="l20.2852">         foldersRemaining-&gt;InsertElementAt(curFolder, 0);</span>
<a href="#l20.2853"></a><span id="l20.2853">     }</span>
<a href="#l20.2854"></a><span id="l20.2854">   }</span>
<a href="#l20.2855"></a><span id="l20.2855"> </span>
<a href="#l20.2856"></a><span id="l20.2856">   foldersRemaining-&gt;GetLength(&amp;folderCount);</span>
<a href="#l20.2857"></a><span id="l20.2857"> </span>
<a href="#l20.2858"></a><span id="l20.2858" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.2859"></a><span id="l20.2859" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.2860"></a><span id="l20.2860" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.2861"></a><span id="l20.2861">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2862"></a><span id="l20.2862" class="difflineminus">-  if (!deleteNoTrash)</span>
<a href="#l20.2863"></a><span id="l20.2863" class="difflineminus">-  {</span>
<a href="#l20.2864"></a><span id="l20.2864" class="difflineplus">+  if (!deleteNoTrash) {</span>
<a href="#l20.2865"></a><span id="l20.2865">     rv = GetTrashFolder(getter_AddRefs(trashFolder));</span>
<a href="#l20.2866"></a><span id="l20.2866" class="difflineminus">-    //If we can't find the trash folder and we are supposed to move it to the trash</span>
<a href="#l20.2867"></a><span id="l20.2867" class="difflineminus">-    //return failure.</span>
<a href="#l20.2868"></a><span id="l20.2868" class="difflineminus">-    if(NS_FAILED(rv) || !trashFolder)</span>
<a href="#l20.2869"></a><span id="l20.2869" class="difflineminus">-      return NS_ERROR_FAILURE;</span>
<a href="#l20.2870"></a><span id="l20.2870" class="difflineplus">+    // If we can't find the trash folder and we are supposed to move it to the</span>
<a href="#l20.2871"></a><span id="l20.2871" class="difflineplus">+    // trash return failure.</span>
<a href="#l20.2872"></a><span id="l20.2872" class="difflineplus">+    if (NS_FAILED(rv) || !trashFolder) return NS_ERROR_FAILURE;</span>
<a href="#l20.2873"></a><span id="l20.2873">     bool canHaveSubFoldersOfTrash = true;</span>
<a href="#l20.2874"></a><span id="l20.2874">     trashFolder-&gt;GetCanCreateSubfolders(&amp;canHaveSubFoldersOfTrash);</span>
<a href="#l20.2875"></a><span id="l20.2875" class="difflineminus">-    if (canHaveSubFoldersOfTrash) // UW server doesn't set NOINFERIORS - check dual use pref</span>
<a href="#l20.2876"></a><span id="l20.2876" class="difflineplus">+    if (canHaveSubFoldersOfTrash)  // UW server doesn't set NOINFERIORS - check</span>
<a href="#l20.2877"></a><span id="l20.2877" class="difflineplus">+                                   // dual use pref</span>
<a href="#l20.2878"></a><span id="l20.2878">     {</span>
<a href="#l20.2879"></a><span id="l20.2879">       nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.2880"></a><span id="l20.2880">       rv = GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.2881"></a><span id="l20.2881">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2882"></a><span id="l20.2882">       bool serverSupportsDualUseFolders;</span>
<a href="#l20.2883"></a><span id="l20.2883">       imapServer-&gt;GetDualUseFolders(&amp;serverSupportsDualUseFolders);</span>
<a href="#l20.2884"></a><span id="l20.2884" class="difflineminus">-      if (!serverSupportsDualUseFolders)</span>
<a href="#l20.2885"></a><span id="l20.2885" class="difflineminus">-        canHaveSubFoldersOfTrash = false;</span>
<a href="#l20.2886"></a><span id="l20.2886" class="difflineminus">-    }</span>
<a href="#l20.2887"></a><span id="l20.2887" class="difflineminus">-    if (!canHaveSubFoldersOfTrash)</span>
<a href="#l20.2888"></a><span id="l20.2888" class="difflineminus">-      deleteNoTrash = true;</span>
<a href="#l20.2889"></a><span id="l20.2889" class="difflineminus">-    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l20.2890"></a><span id="l20.2890" class="difflineplus">+      if (!serverSupportsDualUseFolders) canHaveSubFoldersOfTrash = false;</span>
<a href="#l20.2891"></a><span id="l20.2891" class="difflineplus">+    }</span>
<a href="#l20.2892"></a><span id="l20.2892" class="difflineplus">+    if (!canHaveSubFoldersOfTrash) deleteNoTrash = true;</span>
<a href="#l20.2893"></a><span id="l20.2893" class="difflineplus">+    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(</span>
<a href="#l20.2894"></a><span id="l20.2894" class="difflineplus">+        do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l20.2895"></a><span id="l20.2895">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2896"></a><span id="l20.2896" class="difflineminus">-    prefBranch-&gt;GetBoolPref(&quot;mailnews.confirm.moveFoldersToTrash&quot;, &amp;confirmDeletion);</span>
<a href="#l20.2897"></a><span id="l20.2897" class="difflineminus">-  }</span>
<a href="#l20.2898"></a><span id="l20.2898" class="difflineminus">-  if (!confirmed &amp;&amp; (confirmDeletion || deleteNoTrash)) //let us alert the user if we are deleting folder immediately</span>
<a href="#l20.2899"></a><span id="l20.2899" class="difflineplus">+    prefBranch-&gt;GetBoolPref(&quot;mailnews.confirm.moveFoldersToTrash&quot;,</span>
<a href="#l20.2900"></a><span id="l20.2900" class="difflineplus">+                            &amp;confirmDeletion);</span>
<a href="#l20.2901"></a><span id="l20.2901" class="difflineplus">+  }</span>
<a href="#l20.2902"></a><span id="l20.2902" class="difflineplus">+  if (!confirmed &amp;&amp;</span>
<a href="#l20.2903"></a><span id="l20.2903" class="difflineplus">+      (confirmDeletion || deleteNoTrash))  // let us alert the user if we are</span>
<a href="#l20.2904"></a><span id="l20.2904" class="difflineplus">+                                           // deleting folder immediately</span>
<a href="#l20.2905"></a><span id="l20.2905">   {</span>
<a href="#l20.2906"></a><span id="l20.2906">     nsCOMPtr&lt;nsIStringBundle&gt; bundle;</span>
<a href="#l20.2907"></a><span id="l20.2907">     rv = IMAPGetStringBundle(getter_AddRefs(bundle));</span>
<a href="#l20.2908"></a><span id="l20.2908">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2909"></a><span id="l20.2909"> </span>
<a href="#l20.2910"></a><span id="l20.2910">     nsAutoString folderName;</span>
<a href="#l20.2911"></a><span id="l20.2911">     rv = curFolder-&gt;GetName(folderName);</span>
<a href="#l20.2912"></a><span id="l20.2912">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2913"></a><span id="l20.2913" class="difflineminus">-    const char16_t *formatStrings[1] = { folderName.get() };</span>
<a href="#l20.2914"></a><span id="l20.2914" class="difflineplus">+    const char16_t *formatStrings[1] = {folderName.get()};</span>
<a href="#l20.2915"></a><span id="l20.2915"> </span>
<a href="#l20.2916"></a><span id="l20.2916">     nsAutoString deleteFolderDialogTitle;</span>
<a href="#l20.2917"></a><span id="l20.2917" class="difflineminus">-    rv = bundle-&gt;GetStringFromName(</span>
<a href="#l20.2918"></a><span id="l20.2918" class="difflineminus">-      &quot;imapDeleteFolderDialogTitle&quot;,</span>
<a href="#l20.2919"></a><span id="l20.2919" class="difflineminus">-      deleteFolderDialogTitle);</span>
<a href="#l20.2920"></a><span id="l20.2920" class="difflineplus">+    rv = bundle-&gt;GetStringFromName(&quot;imapDeleteFolderDialogTitle&quot;,</span>
<a href="#l20.2921"></a><span id="l20.2921" class="difflineplus">+                                   deleteFolderDialogTitle);</span>
<a href="#l20.2922"></a><span id="l20.2922">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2923"></a><span id="l20.2923"> </span>
<a href="#l20.2924"></a><span id="l20.2924">     nsAutoString deleteFolderButtonLabel;</span>
<a href="#l20.2925"></a><span id="l20.2925" class="difflineminus">-    rv = bundle-&gt;GetStringFromName(</span>
<a href="#l20.2926"></a><span id="l20.2926" class="difflineminus">-      &quot;imapDeleteFolderButtonLabel&quot;,</span>
<a href="#l20.2927"></a><span id="l20.2927" class="difflineminus">-      deleteFolderButtonLabel);</span>
<a href="#l20.2928"></a><span id="l20.2928" class="difflineplus">+    rv = bundle-&gt;GetStringFromName(&quot;imapDeleteFolderButtonLabel&quot;,</span>
<a href="#l20.2929"></a><span id="l20.2929" class="difflineplus">+                                   deleteFolderButtonLabel);</span>
<a href="#l20.2930"></a><span id="l20.2930">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2931"></a><span id="l20.2931"> </span>
<a href="#l20.2932"></a><span id="l20.2932">     nsAutoString confirmationStr;</span>
<a href="#l20.2933"></a><span id="l20.2933" class="difflineminus">-    rv = bundle-&gt;FormatStringFromName((deleteNoTrash) ?</span>
<a href="#l20.2934"></a><span id="l20.2934" class="difflineminus">-        &quot;imapDeleteNoTrash&quot; :</span>
<a href="#l20.2935"></a><span id="l20.2935" class="difflineminus">-        &quot;imapMoveFolderToTrash&quot;,</span>
<a href="#l20.2936"></a><span id="l20.2936" class="difflineminus">-      formatStrings, 1, confirmationStr);</span>
<a href="#l20.2937"></a><span id="l20.2937" class="difflineplus">+    rv = bundle-&gt;FormatStringFromName(</span>
<a href="#l20.2938"></a><span id="l20.2938" class="difflineplus">+        (deleteNoTrash) ? &quot;imapDeleteNoTrash&quot; : &quot;imapMoveFolderToTrash&quot;,</span>
<a href="#l20.2939"></a><span id="l20.2939" class="difflineplus">+        formatStrings, 1, confirmationStr);</span>
<a href="#l20.2940"></a><span id="l20.2940">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2941"></a><span id="l20.2941" class="difflineminus">-    if (!msgWindow)</span>
<a href="#l20.2942"></a><span id="l20.2942" class="difflineminus">-      return NS_ERROR_NULL_POINTER;</span>
<a href="#l20.2943"></a><span id="l20.2943" class="difflineplus">+    if (!msgWindow) return NS_ERROR_NULL_POINTER;</span>
<a href="#l20.2944"></a><span id="l20.2944">     nsCOMPtr&lt;nsIDocShell&gt; docShell;</span>
<a href="#l20.2945"></a><span id="l20.2945">     msgWindow-&gt;GetRootDocShell(getter_AddRefs(docShell));</span>
<a href="#l20.2946"></a><span id="l20.2946">     nsCOMPtr&lt;nsIPrompt&gt; dialog;</span>
<a href="#l20.2947"></a><span id="l20.2947" class="difflineminus">-    if (docShell)</span>
<a href="#l20.2948"></a><span id="l20.2948" class="difflineminus">-      dialog = do_GetInterface(docShell);</span>
<a href="#l20.2949"></a><span id="l20.2949" class="difflineminus">-    if (dialog)</span>
<a href="#l20.2950"></a><span id="l20.2950" class="difflineminus">-    {</span>
<a href="#l20.2951"></a><span id="l20.2951" class="difflineplus">+    if (docShell) dialog = do_GetInterface(docShell);</span>
<a href="#l20.2952"></a><span id="l20.2952" class="difflineplus">+    if (dialog) {</span>
<a href="#l20.2953"></a><span id="l20.2953">       int32_t buttonPressed = 0;</span>
<a href="#l20.2954"></a><span id="l20.2954">       // Default the dialog to &quot;cancel&quot;.</span>
<a href="#l20.2955"></a><span id="l20.2955">       const uint32_t buttonFlags =</span>
<a href="#l20.2956"></a><span id="l20.2956" class="difflineminus">-        (nsIPrompt::BUTTON_TITLE_IS_STRING * nsIPrompt::BUTTON_POS_0) +</span>
<a href="#l20.2957"></a><span id="l20.2957" class="difflineminus">-        (nsIPrompt::BUTTON_TITLE_CANCEL * nsIPrompt::BUTTON_POS_1);</span>
<a href="#l20.2958"></a><span id="l20.2958" class="difflineplus">+          (nsIPrompt::BUTTON_TITLE_IS_STRING * nsIPrompt::BUTTON_POS_0) +</span>
<a href="#l20.2959"></a><span id="l20.2959" class="difflineplus">+          (nsIPrompt::BUTTON_TITLE_CANCEL * nsIPrompt::BUTTON_POS_1);</span>
<a href="#l20.2960"></a><span id="l20.2960"> </span>
<a href="#l20.2961"></a><span id="l20.2961">       bool dummyValue = false;</span>
<a href="#l20.2962"></a><span id="l20.2962" class="difflineminus">-      rv = dialog-&gt;ConfirmEx(deleteFolderDialogTitle.get(), confirmationStr.get(),</span>
<a href="#l20.2963"></a><span id="l20.2963" class="difflineminus">-                             buttonFlags,  deleteFolderButtonLabel.get(),</span>
<a href="#l20.2964"></a><span id="l20.2964" class="difflineminus">-                             nullptr, nullptr, nullptr, &amp;dummyValue,</span>
<a href="#l20.2965"></a><span id="l20.2965" class="difflineminus">-                             &amp;buttonPressed);</span>
<a href="#l20.2966"></a><span id="l20.2966" class="difflineplus">+      rv = dialog-&gt;ConfirmEx(deleteFolderDialogTitle.get(),</span>
<a href="#l20.2967"></a><span id="l20.2967" class="difflineplus">+                             confirmationStr.get(), buttonFlags,</span>
<a href="#l20.2968"></a><span id="l20.2968" class="difflineplus">+                             deleteFolderButtonLabel.get(), nullptr, nullptr,</span>
<a href="#l20.2969"></a><span id="l20.2969" class="difflineplus">+                             nullptr, &amp;dummyValue, &amp;buttonPressed);</span>
<a href="#l20.2970"></a><span id="l20.2970">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.2971"></a><span id="l20.2971" class="difflineminus">-      confirmed = !buttonPressed; // &quot;ok&quot; is in position 0</span>
<a href="#l20.2972"></a><span id="l20.2972" class="difflineminus">-    }</span>
<a href="#l20.2973"></a><span id="l20.2973" class="difflineminus">-  }</span>
<a href="#l20.2974"></a><span id="l20.2974" class="difflineminus">-  else</span>
<a href="#l20.2975"></a><span id="l20.2975" class="difflineplus">+      confirmed = !buttonPressed;  // &quot;ok&quot; is in position 0</span>
<a href="#l20.2976"></a><span id="l20.2976" class="difflineplus">+    }</span>
<a href="#l20.2977"></a><span id="l20.2977" class="difflineplus">+  } else</span>
<a href="#l20.2978"></a><span id="l20.2978">     confirmed = true;</span>
<a href="#l20.2979"></a><span id="l20.2979"> </span>
<a href="#l20.2980"></a><span id="l20.2980" class="difflineminus">-  if (confirmed)</span>
<a href="#l20.2981"></a><span id="l20.2981" class="difflineminus">-  {</span>
<a href="#l20.2982"></a><span id="l20.2982" class="difflineminus">-    for (i = 0; i &lt; (int32_t) folderCount; i++)</span>
<a href="#l20.2983"></a><span id="l20.2983" class="difflineminus">-    {</span>
<a href="#l20.2984"></a><span id="l20.2984" class="difflineplus">+  if (confirmed) {</span>
<a href="#l20.2985"></a><span id="l20.2985" class="difflineplus">+    for (i = 0; i &lt; (int32_t)folderCount; i++) {</span>
<a href="#l20.2986"></a><span id="l20.2986">       curFolder = do_QueryElementAt(foldersRemaining, i, &amp;rv);</span>
<a href="#l20.2987"></a><span id="l20.2987" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l20.2988"></a><span id="l20.2988" class="difflineminus">-      {</span>
<a href="#l20.2989"></a><span id="l20.2989" class="difflineplus">+      if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.2990"></a><span id="l20.2990">         urlListener = do_QueryInterface(curFolder);</span>
<a href="#l20.2991"></a><span id="l20.2991">         if (deleteNoTrash)</span>
<a href="#l20.2992"></a><span id="l20.2992" class="difflineminus">-          rv = imapService-&gt;DeleteFolder(curFolder,</span>
<a href="#l20.2993"></a><span id="l20.2993" class="difflineminus">-                                         urlListener,</span>
<a href="#l20.2994"></a><span id="l20.2994" class="difflineminus">-                                         msgWindow,</span>
<a href="#l20.2995"></a><span id="l20.2995" class="difflineplus">+          rv = imapService-&gt;DeleteFolder(curFolder, urlListener, msgWindow,</span>
<a href="#l20.2996"></a><span id="l20.2996">                                          nullptr);</span>
<a href="#l20.2997"></a><span id="l20.2997" class="difflineminus">-        else</span>
<a href="#l20.2998"></a><span id="l20.2998" class="difflineminus">-        {</span>
<a href="#l20.2999"></a><span id="l20.2999" class="difflineplus">+        else {</span>
<a href="#l20.3000"></a><span id="l20.3000">           bool confirm = false;</span>
<a href="#l20.3001"></a><span id="l20.3001">           bool match = false;</span>
<a href="#l20.3002"></a><span id="l20.3002" class="difflineminus">-          rv = curFolder-&gt;MatchOrChangeFilterDestination(nullptr, false, &amp;match);</span>
<a href="#l20.3003"></a><span id="l20.3003" class="difflineminus">-          if (match)</span>
<a href="#l20.3004"></a><span id="l20.3004" class="difflineminus">-          {</span>
<a href="#l20.3005"></a><span id="l20.3005" class="difflineplus">+          rv =</span>
<a href="#l20.3006"></a><span id="l20.3006" class="difflineplus">+              curFolder-&gt;MatchOrChangeFilterDestination(nullptr, false, &amp;match);</span>
<a href="#l20.3007"></a><span id="l20.3007" class="difflineplus">+          if (match) {</span>
<a href="#l20.3008"></a><span id="l20.3008">             curFolder-&gt;ConfirmFolderDeletionForFilter(msgWindow, &amp;confirm);</span>
<a href="#l20.3009"></a><span id="l20.3009" class="difflineminus">-            if (!confirm)</span>
<a href="#l20.3010"></a><span id="l20.3010" class="difflineminus">-              return NS_OK;</span>
<a href="#l20.3011"></a><span id="l20.3011" class="difflineplus">+            if (!confirm) return NS_OK;</span>
<a href="#l20.3012"></a><span id="l20.3012">           }</span>
<a href="#l20.3013"></a><span id="l20.3013" class="difflineminus">-          rv = imapService-&gt;MoveFolder(curFolder,</span>
<a href="#l20.3014"></a><span id="l20.3014" class="difflineminus">-                                       trashFolder,</span>
<a href="#l20.3015"></a><span id="l20.3015" class="difflineminus">-                                       urlListener,</span>
<a href="#l20.3016"></a><span id="l20.3016" class="difflineminus">-                                       msgWindow,</span>
<a href="#l20.3017"></a><span id="l20.3017" class="difflineminus">-                                       nullptr);</span>
<a href="#l20.3018"></a><span id="l20.3018" class="difflineplus">+          rv = imapService-&gt;MoveFolder(curFolder, trashFolder, urlListener,</span>
<a href="#l20.3019"></a><span id="l20.3019" class="difflineplus">+                                       msgWindow, nullptr);</span>
<a href="#l20.3020"></a><span id="l20.3020">         }</span>
<a href="#l20.3021"></a><span id="l20.3021">       }</span>
<a href="#l20.3022"></a><span id="l20.3022">     }</span>
<a href="#l20.3023"></a><span id="l20.3023">   }</span>
<a href="#l20.3024"></a><span id="l20.3024" class="difflineminus">-  //delete subfolders only if you are  deleting things from trash</span>
<a href="#l20.3025"></a><span id="l20.3025" class="difflineminus">-  return confirmed &amp;&amp; deleteNoTrash ? nsMsgDBFolder::DeleteSubFolders(foldersRemaining, msgWindow) : rv;</span>
<a href="#l20.3026"></a><span id="l20.3026" class="difflineplus">+  // delete subfolders only if you are  deleting things from trash</span>
<a href="#l20.3027"></a><span id="l20.3027" class="difflineplus">+  return confirmed &amp;&amp; deleteNoTrash</span>
<a href="#l20.3028"></a><span id="l20.3028" class="difflineplus">+             ? nsMsgDBFolder::DeleteSubFolders(foldersRemaining, msgWindow)</span>
<a href="#l20.3029"></a><span id="l20.3029" class="difflineplus">+             : rv;</span>
<a href="#l20.3030"></a><span id="l20.3030"> }</span>
<a href="#l20.3031"></a><span id="l20.3031"> </span>
<a href="#l20.3032"></a><span id="l20.3032"> // FIXME: helper function to know whether we should check all IMAP folders</span>
<a href="#l20.3033"></a><span id="l20.3033"> // for new mail; this is necessary because of a legacy hidden preference</span>
<a href="#l20.3034"></a><span id="l20.3034"> // mail.check_all_imap_folders_for_new (now replaced by per-server preference</span>
<a href="#l20.3035"></a><span id="l20.3035"> // mail.server.%serverkey%.check_all_folders_for_new), still present in some</span>
<a href="#l20.3036"></a><span id="l20.3036"> // profiles.</span>
<a href="#l20.3037"></a><span id="l20.3037"> /*static*/</span>
<a href="#l20.3038"></a><span id="l20.3038" class="difflineminus">-bool nsImapMailFolder::ShouldCheckAllFolders(nsIImapIncomingServer *imapServer)</span>
<a href="#l20.3039"></a><span id="l20.3039" class="difflineminus">-{</span>
<a href="#l20.3040"></a><span id="l20.3040" class="difflineplus">+bool nsImapMailFolder::ShouldCheckAllFolders(</span>
<a href="#l20.3041"></a><span id="l20.3041" class="difflineplus">+    nsIImapIncomingServer *imapServer) {</span>
<a href="#l20.3042"></a><span id="l20.3042">   // Check legacy global preference to see if we should check all folders for</span>
<a href="#l20.3043"></a><span id="l20.3043">   // new messages, or just the inbox and marked ones.</span>
<a href="#l20.3044"></a><span id="l20.3044">   bool checkAllFolders = false;</span>
<a href="#l20.3045"></a><span id="l20.3045">   nsresult rv;</span>
<a href="#l20.3046"></a><span id="l20.3046" class="difflineminus">-  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.3047"></a><span id="l20.3047" class="difflineplus">+  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch =</span>
<a href="#l20.3048"></a><span id="l20.3048" class="difflineplus">+      do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.3049"></a><span id="l20.3049">   NS_ENSURE_SUCCESS(rv, false);</span>
<a href="#l20.3050"></a><span id="l20.3050">   // This pref might not exist, which is OK.</span>
<a href="#l20.3051"></a><span id="l20.3051" class="difflineminus">-  (void) prefBranch-&gt;GetBoolPref(&quot;mail.check_all_imap_folders_for_new&quot;, &amp;checkAllFolders);</span>
<a href="#l20.3052"></a><span id="l20.3052" class="difflineminus">-</span>
<a href="#l20.3053"></a><span id="l20.3053" class="difflineminus">-  if (checkAllFolders)</span>
<a href="#l20.3054"></a><span id="l20.3054" class="difflineminus">-    return true;</span>
<a href="#l20.3055"></a><span id="l20.3055" class="difflineplus">+  (void)prefBranch-&gt;GetBoolPref(&quot;mail.check_all_imap_folders_for_new&quot;,</span>
<a href="#l20.3056"></a><span id="l20.3056" class="difflineplus">+                                &amp;checkAllFolders);</span>
<a href="#l20.3057"></a><span id="l20.3057" class="difflineplus">+</span>
<a href="#l20.3058"></a><span id="l20.3058" class="difflineplus">+  if (checkAllFolders) return true;</span>
<a href="#l20.3059"></a><span id="l20.3059"> </span>
<a href="#l20.3060"></a><span id="l20.3060">   // If the legacy preference doesn't exist or has its default value (False),</span>
<a href="#l20.3061"></a><span id="l20.3061">   // the true preference is read.</span>
<a href="#l20.3062"></a><span id="l20.3062">   imapServer-&gt;GetCheckAllFoldersForNew(&amp;checkAllFolders);</span>
<a href="#l20.3063"></a><span id="l20.3063">   return checkAllFolders;</span>
<a href="#l20.3064"></a><span id="l20.3064"> }</span>
<a href="#l20.3065"></a><span id="l20.3065"> </span>
<a href="#l20.3066"></a><span id="l20.3066"> // Called by Biff, or when user presses GetMsg button.</span>
<a href="#l20.3067"></a><span id="l20.3067" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetNewMessages(nsIMsgWindow *aWindow, nsIUrlListener *aListener)</span>
<a href="#l20.3068"></a><span id="l20.3068" class="difflineminus">-{</span>
<a href="#l20.3069"></a><span id="l20.3069" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetNewMessages(nsIMsgWindow *aWindow,</span>
<a href="#l20.3070"></a><span id="l20.3070" class="difflineplus">+                                               nsIUrlListener *aListener) {</span>
<a href="#l20.3071"></a><span id="l20.3071">   nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l20.3072"></a><span id="l20.3072">   nsresult rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l20.3073"></a><span id="l20.3073" class="difflineminus">-  if(NS_SUCCEEDED(rv) &amp;&amp; rootFolder)</span>
<a href="#l20.3074"></a><span id="l20.3074" class="difflineminus">-  {</span>
<a href="#l20.3075"></a><span id="l20.3075" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder) {</span>
<a href="#l20.3076"></a><span id="l20.3076">     nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.3077"></a><span id="l20.3077">     rv = GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.3078"></a><span id="l20.3078">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3079"></a><span id="l20.3079">     bool performingBiff = false;</span>
<a href="#l20.3080"></a><span id="l20.3080" class="difflineminus">-    nsCOMPtr&lt;nsIMsgIncomingServer&gt; incomingServer = do_QueryInterface(imapServer, &amp;rv);</span>
<a href="#l20.3081"></a><span id="l20.3081" class="difflineplus">+    nsCOMPtr&lt;nsIMsgIncomingServer&gt; incomingServer =</span>
<a href="#l20.3082"></a><span id="l20.3082" class="difflineplus">+        do_QueryInterface(imapServer, &amp;rv);</span>
<a href="#l20.3083"></a><span id="l20.3083">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3084"></a><span id="l20.3084">     incomingServer-&gt;GetPerformingBiff(&amp;performingBiff);</span>
<a href="#l20.3085"></a><span id="l20.3085">     m_urlListener = aListener;</span>
<a href="#l20.3086"></a><span id="l20.3086"> </span>
<a href="#l20.3087"></a><span id="l20.3087">     // See if we should check all folders for new messages, or just the inbox</span>
<a href="#l20.3088"></a><span id="l20.3088">     // and marked ones</span>
<a href="#l20.3089"></a><span id="l20.3089">     bool checkAllFolders = ShouldCheckAllFolders(imapServer);</span>
<a href="#l20.3090"></a><span id="l20.3090"> </span>
<a href="#l20.3091"></a><span id="l20.3091">     // Get new messages for inbox</span>
<a href="#l20.3092"></a><span id="l20.3092">     nsCOMPtr&lt;nsIMsgFolder&gt; inbox;</span>
<a href="#l20.3093"></a><span id="l20.3093">     rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Inbox,</span>
<a href="#l20.3094"></a><span id="l20.3094">                                         getter_AddRefs(inbox));</span>
<a href="#l20.3095"></a><span id="l20.3095" class="difflineminus">-    if (inbox)</span>
<a href="#l20.3096"></a><span id="l20.3096" class="difflineminus">-    {</span>
<a href="#l20.3097"></a><span id="l20.3097" class="difflineplus">+    if (inbox) {</span>
<a href="#l20.3098"></a><span id="l20.3098">       nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(inbox, &amp;rv);</span>
<a href="#l20.3099"></a><span id="l20.3099">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3100"></a><span id="l20.3100">       imapFolder-&gt;SetPerformingBiff(performingBiff);</span>
<a href="#l20.3101"></a><span id="l20.3101">       inbox-&gt;SetGettingNewMessages(true);</span>
<a href="#l20.3102"></a><span id="l20.3102">       rv = inbox-&gt;UpdateFolder(aWindow);</span>
<a href="#l20.3103"></a><span id="l20.3103">     }</span>
<a href="#l20.3104"></a><span id="l20.3104" class="difflineminus">-    // Get new messages for other folders if marked, or all of them if the pref is set</span>
<a href="#l20.3105"></a><span id="l20.3105" class="difflineminus">-    rv = imapServer-&gt;GetNewMessagesForNonInboxFolders(rootFolder, aWindow, checkAllFolders, performingBiff);</span>
<a href="#l20.3106"></a><span id="l20.3106" class="difflineplus">+    // Get new messages for other folders if marked, or all of them if the pref</span>
<a href="#l20.3107"></a><span id="l20.3107" class="difflineplus">+    // is set</span>
<a href="#l20.3108"></a><span id="l20.3108" class="difflineplus">+    rv = imapServer-&gt;GetNewMessagesForNonInboxFolders(</span>
<a href="#l20.3109"></a><span id="l20.3109" class="difflineplus">+        rootFolder, aWindow, checkAllFolders, performingBiff);</span>
<a href="#l20.3110"></a><span id="l20.3110">   }</span>
<a href="#l20.3111"></a><span id="l20.3111">   return rv;</span>
<a href="#l20.3112"></a><span id="l20.3112"> }</span>
<a href="#l20.3113"></a><span id="l20.3113"> </span>
<a href="#l20.3114"></a><span id="l20.3114" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::Shutdown(bool shutdownChildren)</span>
<a href="#l20.3115"></a><span id="l20.3115" class="difflineminus">-{</span>
<a href="#l20.3116"></a><span id="l20.3116" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::Shutdown(bool shutdownChildren) {</span>
<a href="#l20.3117"></a><span id="l20.3117">   m_filterList = nullptr;</span>
<a href="#l20.3118"></a><span id="l20.3118">   m_initialized = false;</span>
<a href="#l20.3119"></a><span id="l20.3119" class="difflineminus">-  // mPath is used to decide if folder pathname needs to be reconstructed in GetPath().</span>
<a href="#l20.3120"></a><span id="l20.3120" class="difflineplus">+  // mPath is used to decide if folder pathname needs to be reconstructed in</span>
<a href="#l20.3121"></a><span id="l20.3121" class="difflineplus">+  // GetPath().</span>
<a href="#l20.3122"></a><span id="l20.3122">   mPath = nullptr;</span>
<a href="#l20.3123"></a><span id="l20.3123">   m_moveCoalescer = nullptr;</span>
<a href="#l20.3124"></a><span id="l20.3124">   m_msgParser = nullptr;</span>
<a href="#l20.3125"></a><span id="l20.3125" class="difflineminus">-  if (m_playbackTimer)</span>
<a href="#l20.3126"></a><span id="l20.3126" class="difflineminus">-  {</span>
<a href="#l20.3127"></a><span id="l20.3127" class="difflineplus">+  if (m_playbackTimer) {</span>
<a href="#l20.3128"></a><span id="l20.3128">     m_playbackTimer-&gt;Cancel();</span>
<a href="#l20.3129"></a><span id="l20.3129">     m_playbackTimer = nullptr;</span>
<a href="#l20.3130"></a><span id="l20.3130">   }</span>
<a href="#l20.3131"></a><span id="l20.3131">   m_pendingOfflineMoves.Clear();</span>
<a href="#l20.3132"></a><span id="l20.3132">   return nsMsgDBFolder::Shutdown(shutdownChildren);</span>
<a href="#l20.3133"></a><span id="l20.3133"> }</span>
<a href="#l20.3134"></a><span id="l20.3134"> </span>
<a href="#l20.3135"></a><span id="l20.3135" class="difflineminus">-nsresult nsImapMailFolder::GetBodysToDownload(nsTArray&lt;nsMsgKey&gt; *keysOfMessagesToDownload)</span>
<a href="#l20.3136"></a><span id="l20.3136" class="difflineminus">-{</span>
<a href="#l20.3137"></a><span id="l20.3137" class="difflineplus">+nsresult nsImapMailFolder::GetBodysToDownload(</span>
<a href="#l20.3138"></a><span id="l20.3138" class="difflineplus">+    nsTArray&lt;nsMsgKey&gt; *keysOfMessagesToDownload) {</span>
<a href="#l20.3139"></a><span id="l20.3139">   NS_ENSURE_ARG(keysOfMessagesToDownload);</span>
<a href="#l20.3140"></a><span id="l20.3140">   NS_ENSURE_TRUE(mDatabase, NS_ERROR_FAILURE);</span>
<a href="#l20.3141"></a><span id="l20.3141"> </span>
<a href="#l20.3142"></a><span id="l20.3142" class="difflineminus">-  nsCOMPtr &lt;nsISimpleEnumerator&gt; enumerator;</span>
<a href="#l20.3143"></a><span id="l20.3143" class="difflineplus">+  nsCOMPtr&lt;nsISimpleEnumerator&gt; enumerator;</span>
<a href="#l20.3144"></a><span id="l20.3144">   nsresult rv = mDatabase-&gt;EnumerateMessages(getter_AddRefs(enumerator));</span>
<a href="#l20.3145"></a><span id="l20.3145" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; enumerator)</span>
<a href="#l20.3146"></a><span id="l20.3146" class="difflineminus">-  {</span>
<a href="#l20.3147"></a><span id="l20.3147" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; enumerator) {</span>
<a href="#l20.3148"></a><span id="l20.3148">     bool hasMore;</span>
<a href="#l20.3149"></a><span id="l20.3149" class="difflineminus">-    while (NS_SUCCEEDED(rv = enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l20.3150"></a><span id="l20.3150" class="difflineminus">-    {</span>
<a href="#l20.3151"></a><span id="l20.3151" class="difflineminus">-      nsCOMPtr &lt;nsISupports&gt; supports;</span>
<a href="#l20.3152"></a><span id="l20.3152" class="difflineplus">+    while (NS_SUCCEEDED(rv = enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp;</span>
<a href="#l20.3153"></a><span id="l20.3153" class="difflineplus">+           hasMore) {</span>
<a href="#l20.3154"></a><span id="l20.3154" class="difflineplus">+      nsCOMPtr&lt;nsISupports&gt; supports;</span>
<a href="#l20.3155"></a><span id="l20.3155">       rv = enumerator-&gt;GetNext(getter_AddRefs(supports));</span>
<a href="#l20.3156"></a><span id="l20.3156">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3157"></a><span id="l20.3157" class="difflineminus">-      nsCOMPtr &lt;nsIMsgDBHdr&gt; pHeader = do_QueryInterface(supports, &amp;rv);</span>
<a href="#l20.3158"></a><span id="l20.3158" class="difflineplus">+      nsCOMPtr&lt;nsIMsgDBHdr&gt; pHeader = do_QueryInterface(supports, &amp;rv);</span>
<a href="#l20.3159"></a><span id="l20.3159">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3160"></a><span id="l20.3160">       bool shouldStoreMsgOffline = false;</span>
<a href="#l20.3161"></a><span id="l20.3161">       nsMsgKey msgKey;</span>
<a href="#l20.3162"></a><span id="l20.3162">       pHeader-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l20.3163"></a><span id="l20.3163" class="difflineminus">-      // MsgFitsDownloadCriteria ignores nsMsgFolderFlags::Offline, which we want</span>
<a href="#l20.3164"></a><span id="l20.3164" class="difflineplus">+      // MsgFitsDownloadCriteria ignores nsMsgFolderFlags::Offline, which we</span>
<a href="#l20.3165"></a><span id="l20.3165" class="difflineplus">+      // want</span>
<a href="#l20.3166"></a><span id="l20.3166">       if (m_downloadingFolderForOfflineUse)</span>
<a href="#l20.3167"></a><span id="l20.3167">         MsgFitsDownloadCriteria(msgKey, &amp;shouldStoreMsgOffline);</span>
<a href="#l20.3168"></a><span id="l20.3168">       else</span>
<a href="#l20.3169"></a><span id="l20.3169">         ShouldStoreMsgOffline(msgKey, &amp;shouldStoreMsgOffline);</span>
<a href="#l20.3170"></a><span id="l20.3170">       if (shouldStoreMsgOffline)</span>
<a href="#l20.3171"></a><span id="l20.3171">         keysOfMessagesToDownload-&gt;AppendElement(msgKey);</span>
<a href="#l20.3172"></a><span id="l20.3172">     }</span>
<a href="#l20.3173"></a><span id="l20.3173">   }</span>
<a href="#l20.3174"></a><span id="l20.3174">   return rv;</span>
<a href="#l20.3175"></a><span id="l20.3175"> }</span>
<a href="#l20.3176"></a><span id="l20.3176"> </span>
<a href="#l20.3177"></a><span id="l20.3177" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::OnNewIdleMessages()</span>
<a href="#l20.3178"></a><span id="l20.3178" class="difflineminus">-{</span>
<a href="#l20.3179"></a><span id="l20.3179" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::OnNewIdleMessages() {</span>
<a href="#l20.3180"></a><span id="l20.3180">   nsresult rv;</span>
<a href="#l20.3181"></a><span id="l20.3181">   nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.3182"></a><span id="l20.3182">   rv = GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.3183"></a><span id="l20.3183">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3184"></a><span id="l20.3184"> </span>
<a href="#l20.3185"></a><span id="l20.3185">   bool checkAllFolders = ShouldCheckAllFolders(imapServer);</span>
<a href="#l20.3186"></a><span id="l20.3186"> </span>
<a href="#l20.3187"></a><span id="l20.3187" class="difflineminus">-  // only trigger biff if we're checking all new folders for new messages, or this particular folder,</span>
<a href="#l20.3188"></a><span id="l20.3188" class="difflineminus">-  // but excluding trash,junk, sent, and no select folders, by default.</span>
<a href="#l20.3189"></a><span id="l20.3189" class="difflineplus">+  // only trigger biff if we're checking all new folders for new messages, or</span>
<a href="#l20.3190"></a><span id="l20.3190" class="difflineplus">+  // this particular folder, but excluding trash,junk, sent, and no select</span>
<a href="#l20.3191"></a><span id="l20.3191" class="difflineplus">+  // folders, by default.</span>
<a href="#l20.3192"></a><span id="l20.3192">   if ((checkAllFolders &amp;&amp;</span>
<a href="#l20.3193"></a><span id="l20.3193" class="difflineminus">-    !(mFlags &amp; (nsMsgFolderFlags::Trash | nsMsgFolderFlags::Junk | nsMsgFolderFlags::SentMail | nsMsgFolderFlags::ImapNoselect)))</span>
<a href="#l20.3194"></a><span id="l20.3194" class="difflineminus">-    || (mFlags &amp; (nsMsgFolderFlags::CheckNew|nsMsgFolderFlags::Inbox)))</span>
<a href="#l20.3195"></a><span id="l20.3195" class="difflineplus">+       !(mFlags &amp;</span>
<a href="#l20.3196"></a><span id="l20.3196" class="difflineplus">+         (nsMsgFolderFlags::Trash | nsMsgFolderFlags::Junk |</span>
<a href="#l20.3197"></a><span id="l20.3197" class="difflineplus">+          nsMsgFolderFlags::SentMail | nsMsgFolderFlags::ImapNoselect))) ||</span>
<a href="#l20.3198"></a><span id="l20.3198" class="difflineplus">+      (mFlags &amp; (nsMsgFolderFlags::CheckNew | nsMsgFolderFlags::Inbox)))</span>
<a href="#l20.3199"></a><span id="l20.3199">     SetPerformingBiff(true);</span>
<a href="#l20.3200"></a><span id="l20.3200">   return UpdateFolder(nullptr);</span>
<a href="#l20.3201"></a><span id="l20.3201"> }</span>
<a href="#l20.3202"></a><span id="l20.3202"> </span>
<a href="#l20.3203"></a><span id="l20.3203" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::UpdateImapMailboxInfo(nsIImapProtocol* aProtocol, nsIMailboxSpec* aSpec)</span>
<a href="#l20.3204"></a><span id="l20.3204" class="difflineminus">-{</span>
<a href="#l20.3205"></a><span id="l20.3205" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::UpdateImapMailboxInfo(</span>
<a href="#l20.3206"></a><span id="l20.3206" class="difflineplus">+    nsIImapProtocol *aProtocol, nsIMailboxSpec *aSpec) {</span>
<a href="#l20.3207"></a><span id="l20.3207">   nsresult rv;</span>
<a href="#l20.3208"></a><span id="l20.3208">   ChangeNumPendingTotalMessages(-mNumPendingTotalMessages);</span>
<a href="#l20.3209"></a><span id="l20.3209">   ChangeNumPendingUnread(-mNumPendingUnreadMessages);</span>
<a href="#l20.3210"></a><span id="l20.3210" class="difflineminus">-  m_numServerRecentMessages = 0; // clear this since we selected the folder.</span>
<a href="#l20.3211"></a><span id="l20.3211" class="difflineminus">-  m_numServerUnseenMessages = 0; // clear this since we selected the folder.</span>
<a href="#l20.3212"></a><span id="l20.3212" class="difflineminus">-</span>
<a href="#l20.3213"></a><span id="l20.3213" class="difflineminus">-  if (!mDatabase)</span>
<a href="#l20.3214"></a><span id="l20.3214" class="difflineminus">-    GetDatabase();</span>
<a href="#l20.3215"></a><span id="l20.3215" class="difflineplus">+  m_numServerRecentMessages = 0;  // clear this since we selected the folder.</span>
<a href="#l20.3216"></a><span id="l20.3216" class="difflineplus">+  m_numServerUnseenMessages = 0;  // clear this since we selected the folder.</span>
<a href="#l20.3217"></a><span id="l20.3217" class="difflineplus">+</span>
<a href="#l20.3218"></a><span id="l20.3218" class="difflineplus">+  if (!mDatabase) GetDatabase();</span>
<a href="#l20.3219"></a><span id="l20.3219"> </span>
<a href="#l20.3220"></a><span id="l20.3220">   bool folderSelected;</span>
<a href="#l20.3221"></a><span id="l20.3221">   rv = aSpec-&gt;GetFolderSelected(&amp;folderSelected);</span>
<a href="#l20.3222"></a><span id="l20.3222">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3223"></a><span id="l20.3223">   nsTArray&lt;nsMsgKey&gt; existingKeys;</span>
<a href="#l20.3224"></a><span id="l20.3224">   nsTArray&lt;nsMsgKey&gt; keysToDelete;</span>
<a href="#l20.3225"></a><span id="l20.3225">   uint32_t numNewUnread;</span>
<a href="#l20.3226"></a><span id="l20.3226">   nsCOMPtr&lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l20.3227"></a><span id="l20.3227">   int32_t imapUIDValidity = 0;</span>
<a href="#l20.3228"></a><span id="l20.3228" class="difflineminus">-  if (mDatabase)</span>
<a href="#l20.3229"></a><span id="l20.3229" class="difflineminus">-  {</span>
<a href="#l20.3230"></a><span id="l20.3230" class="difflineplus">+  if (mDatabase) {</span>
<a href="#l20.3231"></a><span id="l20.3231">     rv = mDatabase-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l20.3232"></a><span id="l20.3232" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; dbFolderInfo)</span>
<a href="#l20.3233"></a><span id="l20.3233" class="difflineminus">-    {</span>
<a href="#l20.3234"></a><span id="l20.3234" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; dbFolderInfo) {</span>
<a href="#l20.3235"></a><span id="l20.3235">       dbFolderInfo-&gt;GetImapUidValidity(&amp;imapUIDValidity);</span>
<a href="#l20.3236"></a><span id="l20.3236">       uint64_t mailboxHighestModSeq;</span>
<a href="#l20.3237"></a><span id="l20.3237">       aSpec-&gt;GetHighestModSeq(&amp;mailboxHighestModSeq);</span>
<a href="#l20.3238"></a><span id="l20.3238">       MOZ_LOG(IMAP_CS, mozilla::LogLevel::Debug,</span>
<a href="#l20.3239"></a><span id="l20.3239" class="difflineminus">-              (&quot;UpdateImapMailboxInfo(): Store highest MODSEQ=%&quot; PRIu64 &quot; for folder=%s&quot;,</span>
<a href="#l20.3240"></a><span id="l20.3240" class="difflineplus">+              (&quot;UpdateImapMailboxInfo(): Store highest MODSEQ=%&quot; PRIu64</span>
<a href="#l20.3241"></a><span id="l20.3241" class="difflineplus">+               &quot; for folder=%s&quot;,</span>
<a href="#l20.3242"></a><span id="l20.3242">                mailboxHighestModSeq, m_onlineFolderName.get()));</span>
<a href="#l20.3243"></a><span id="l20.3243">       char intStrBuf[40];</span>
<a href="#l20.3244"></a><span id="l20.3244" class="difflineminus">-      PR_snprintf(intStrBuf, sizeof(intStrBuf), &quot;%llu&quot;,  mailboxHighestModSeq);</span>
<a href="#l20.3245"></a><span id="l20.3245" class="difflineminus">-      dbFolderInfo-&gt;SetCharProperty(kModSeqPropertyName, nsDependentCString(intStrBuf));</span>
<a href="#l20.3246"></a><span id="l20.3246" class="difflineplus">+      PR_snprintf(intStrBuf, sizeof(intStrBuf), &quot;%llu&quot;, mailboxHighestModSeq);</span>
<a href="#l20.3247"></a><span id="l20.3247" class="difflineplus">+      dbFolderInfo-&gt;SetCharProperty(kModSeqPropertyName,</span>
<a href="#l20.3248"></a><span id="l20.3248" class="difflineplus">+                                    nsDependentCString(intStrBuf));</span>
<a href="#l20.3249"></a><span id="l20.3249">     }</span>
<a href="#l20.3250"></a><span id="l20.3250">     RefPtr&lt;nsMsgKeyArray&gt; keys = new nsMsgKeyArray;</span>
<a href="#l20.3251"></a><span id="l20.3251" class="difflineminus">-    if (!keys)</span>
<a href="#l20.3252"></a><span id="l20.3252" class="difflineminus">-      return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.3253"></a><span id="l20.3253" class="difflineplus">+    if (!keys) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.3254"></a><span id="l20.3254">     rv = mDatabase-&gt;ListAllKeys(keys);</span>
<a href="#l20.3255"></a><span id="l20.3255">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3256"></a><span id="l20.3256">     existingKeys.AppendElements(keys-&gt;m_keys);</span>
<a href="#l20.3257"></a><span id="l20.3257">     mDatabase-&gt;ListAllOfflineDeletes(&amp;existingKeys);</span>
<a href="#l20.3258"></a><span id="l20.3258">   }</span>
<a href="#l20.3259"></a><span id="l20.3259">   int32_t folderValidity;</span>
<a href="#l20.3260"></a><span id="l20.3260">   aSpec-&gt;GetFolder_UIDVALIDITY(&amp;folderValidity);</span>
<a href="#l20.3261"></a><span id="l20.3261" class="difflineminus">-  nsCOMPtr &lt;nsIImapFlagAndUidState&gt; flagState;</span>
<a href="#l20.3262"></a><span id="l20.3262" class="difflineplus">+  nsCOMPtr&lt;nsIImapFlagAndUidState&gt; flagState;</span>
<a href="#l20.3263"></a><span id="l20.3263">   aSpec-&gt;GetFlagState(getter_AddRefs(flagState));</span>
<a href="#l20.3264"></a><span id="l20.3264"> </span>
<a href="#l20.3265"></a><span id="l20.3265">   // remember what the supported user flags are.</span>
<a href="#l20.3266"></a><span id="l20.3266">   uint32_t supportedUserFlags;</span>
<a href="#l20.3267"></a><span id="l20.3267">   aSpec-&gt;GetSupportedUserFlags(&amp;supportedUserFlags);</span>
<a href="#l20.3268"></a><span id="l20.3268">   SetSupportedUserFlags(supportedUserFlags);</span>
<a href="#l20.3269"></a><span id="l20.3269"> </span>
<a href="#l20.3270"></a><span id="l20.3270">   m_uidValidity = folderValidity;</span>
<a href="#l20.3271"></a><span id="l20.3271"> </span>
<a href="#l20.3272"></a><span id="l20.3272" class="difflineminus">-  if (imapUIDValidity != folderValidity)</span>
<a href="#l20.3273"></a><span id="l20.3273" class="difflineminus">-  {</span>
<a href="#l20.3274"></a><span id="l20.3274" class="difflineplus">+  if (imapUIDValidity != folderValidity) {</span>
<a href="#l20.3275"></a><span id="l20.3275">     NS_ASSERTION(imapUIDValidity == kUidUnknown,</span>
<a href="#l20.3276"></a><span id="l20.3276">                  &quot;uid validity seems to have changed, blowing away db&quot;);</span>
<a href="#l20.3277"></a><span id="l20.3277">     nsCOMPtr&lt;nsIFile&gt; pathFile;</span>
<a href="#l20.3278"></a><span id="l20.3278">     rv = GetFilePath(getter_AddRefs(pathFile));</span>
<a href="#l20.3279"></a><span id="l20.3279">     if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.3280"></a><span id="l20.3280"> </span>
<a href="#l20.3281"></a><span id="l20.3281" class="difflineminus">-    nsCOMPtr&lt;nsIMsgDBService&gt; msgDBService = do_GetService(NS_MSGDB_SERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.3282"></a><span id="l20.3282" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBService&gt; msgDBService =</span>
<a href="#l20.3283"></a><span id="l20.3283" class="difflineplus">+        do_GetService(NS_MSGDB_SERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.3284"></a><span id="l20.3284">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3285"></a><span id="l20.3285"> </span>
<a href="#l20.3286"></a><span id="l20.3286" class="difflineminus">-    nsCOMPtr &lt;nsIDBFolderInfo&gt; transferInfo;</span>
<a href="#l20.3287"></a><span id="l20.3287" class="difflineplus">+    nsCOMPtr&lt;nsIDBFolderInfo&gt; transferInfo;</span>
<a href="#l20.3288"></a><span id="l20.3288">     if (dbFolderInfo)</span>
<a href="#l20.3289"></a><span id="l20.3289">       dbFolderInfo-&gt;GetTransferInfo(getter_AddRefs(transferInfo));</span>
<a href="#l20.3290"></a><span id="l20.3290"> </span>
<a href="#l20.3291"></a><span id="l20.3291">     // A backup message database might have been created earlier, for example</span>
<a href="#l20.3292"></a><span id="l20.3292">     // if the user requested a reindex. We'll use the earlier one if we can,</span>
<a href="#l20.3293"></a><span id="l20.3293">     // otherwise we'll try to backup at this point.</span>
<a href="#l20.3294"></a><span id="l20.3294">     nsresult rvbackup = OpenBackupMsgDatabase();</span>
<a href="#l20.3295"></a><span id="l20.3295" class="difflineminus">-    if (mDatabase)</span>
<a href="#l20.3296"></a><span id="l20.3296" class="difflineminus">-    {</span>
<a href="#l20.3297"></a><span id="l20.3297" class="difflineplus">+    if (mDatabase) {</span>
<a href="#l20.3298"></a><span id="l20.3298">       dbFolderInfo = nullptr;</span>
<a href="#l20.3299"></a><span id="l20.3299" class="difflineminus">-      if (NS_FAILED(rvbackup))</span>
<a href="#l20.3300"></a><span id="l20.3300" class="difflineminus">-      {</span>
<a href="#l20.3301"></a><span id="l20.3301" class="difflineplus">+      if (NS_FAILED(rvbackup)) {</span>
<a href="#l20.3302"></a><span id="l20.3302">         CloseAndBackupFolderDB(EmptyCString());</span>
<a href="#l20.3303"></a><span id="l20.3303" class="difflineminus">-        if (NS_FAILED(OpenBackupMsgDatabase()) &amp;&amp; mBackupDatabase)</span>
<a href="#l20.3304"></a><span id="l20.3304" class="difflineminus">-        {</span>
<a href="#l20.3305"></a><span id="l20.3305" class="difflineplus">+        if (NS_FAILED(OpenBackupMsgDatabase()) &amp;&amp; mBackupDatabase) {</span>
<a href="#l20.3306"></a><span id="l20.3306">           mBackupDatabase-&gt;RemoveListener(this);</span>
<a href="#l20.3307"></a><span id="l20.3307">           mBackupDatabase = nullptr;</span>
<a href="#l20.3308"></a><span id="l20.3308">         }</span>
<a href="#l20.3309"></a><span id="l20.3309" class="difflineminus">-      }</span>
<a href="#l20.3310"></a><span id="l20.3310" class="difflineminus">-      else</span>
<a href="#l20.3311"></a><span id="l20.3311" class="difflineplus">+      } else</span>
<a href="#l20.3312"></a><span id="l20.3312">         mDatabase-&gt;ForceClosed();</span>
<a href="#l20.3313"></a><span id="l20.3313">     }</span>
<a href="#l20.3314"></a><span id="l20.3314">     mDatabase = nullptr;</span>
<a href="#l20.3315"></a><span id="l20.3315"> </span>
<a href="#l20.3316"></a><span id="l20.3316" class="difflineminus">-    nsCOMPtr &lt;nsIFile&gt; summaryFile;</span>
<a href="#l20.3317"></a><span id="l20.3317" class="difflineplus">+    nsCOMPtr&lt;nsIFile&gt; summaryFile;</span>
<a href="#l20.3318"></a><span id="l20.3318">     rv = GetSummaryFileLocation(pathFile, getter_AddRefs(summaryFile));</span>
<a href="#l20.3319"></a><span id="l20.3319">     // Remove summary file.</span>
<a href="#l20.3320"></a><span id="l20.3320" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; summaryFile)</span>
<a href="#l20.3321"></a><span id="l20.3321" class="difflineminus">-      summaryFile-&gt;Remove(false);</span>
<a href="#l20.3322"></a><span id="l20.3322" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; summaryFile) summaryFile-&gt;Remove(false);</span>
<a href="#l20.3323"></a><span id="l20.3323"> </span>
<a href="#l20.3324"></a><span id="l20.3324">     // Create a new summary file, update the folder message counts, and</span>
<a href="#l20.3325"></a><span id="l20.3325">     // Close the summary file db.</span>
<a href="#l20.3326"></a><span id="l20.3326">     rv = msgDBService-&gt;CreateNewDB(this, getter_AddRefs(mDatabase));</span>
<a href="#l20.3327"></a><span id="l20.3327"> </span>
<a href="#l20.3328"></a><span id="l20.3328" class="difflineminus">-    if (NS_FAILED(rv) &amp;&amp; mDatabase)</span>
<a href="#l20.3329"></a><span id="l20.3329" class="difflineminus">-    {</span>
<a href="#l20.3330"></a><span id="l20.3330" class="difflineplus">+    if (NS_FAILED(rv) &amp;&amp; mDatabase) {</span>
<a href="#l20.3331"></a><span id="l20.3331">       mDatabase-&gt;ForceClosed();</span>
<a href="#l20.3332"></a><span id="l20.3332">       mDatabase = nullptr;</span>
<a href="#l20.3333"></a><span id="l20.3333" class="difflineminus">-    }</span>
<a href="#l20.3334"></a><span id="l20.3334" class="difflineminus">-    else if (NS_SUCCEEDED(rv) &amp;&amp; mDatabase)</span>
<a href="#l20.3335"></a><span id="l20.3335" class="difflineminus">-    {</span>
<a href="#l20.3336"></a><span id="l20.3336" class="difflineminus">-      if (transferInfo)</span>
<a href="#l20.3337"></a><span id="l20.3337" class="difflineminus">-        SetDBTransferInfo(transferInfo);</span>
<a href="#l20.3338"></a><span id="l20.3338" class="difflineplus">+    } else if (NS_SUCCEEDED(rv) &amp;&amp; mDatabase) {</span>
<a href="#l20.3339"></a><span id="l20.3339" class="difflineplus">+      if (transferInfo) SetDBTransferInfo(transferInfo);</span>
<a href="#l20.3340"></a><span id="l20.3340"> </span>
<a href="#l20.3341"></a><span id="l20.3341">       SummaryChanged();</span>
<a href="#l20.3342"></a><span id="l20.3342" class="difflineminus">-      if (mDatabase)</span>
<a href="#l20.3343"></a><span id="l20.3343" class="difflineminus">-      {</span>
<a href="#l20.3344"></a><span id="l20.3344" class="difflineminus">-        if(mAddListener)</span>
<a href="#l20.3345"></a><span id="l20.3345" class="difflineminus">-          mDatabase-&gt;AddListener(this);</span>
<a href="#l20.3346"></a><span id="l20.3346" class="difflineplus">+      if (mDatabase) {</span>
<a href="#l20.3347"></a><span id="l20.3347" class="difflineplus">+        if (mAddListener) mDatabase-&gt;AddListener(this);</span>
<a href="#l20.3348"></a><span id="l20.3348">         rv = mDatabase-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l20.3349"></a><span id="l20.3349">       }</span>
<a href="#l20.3350"></a><span id="l20.3350">     }</span>
<a href="#l20.3351"></a><span id="l20.3351">     // store the new UIDVALIDITY value</span>
<a href="#l20.3352"></a><span id="l20.3352"> </span>
<a href="#l20.3353"></a><span id="l20.3353" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; dbFolderInfo)</span>
<a href="#l20.3354"></a><span id="l20.3354" class="difflineminus">-    {</span>
<a href="#l20.3355"></a><span id="l20.3355" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; dbFolderInfo) {</span>
<a href="#l20.3356"></a><span id="l20.3356">       dbFolderInfo-&gt;SetImapUidValidity(folderValidity);</span>
<a href="#l20.3357"></a><span id="l20.3357">       // need to forget highest mod seq when uid validity rolls.</span>
<a href="#l20.3358"></a><span id="l20.3358">       MOZ_LOG(IMAP_CS, mozilla::LogLevel::Debug,</span>
<a href="#l20.3359"></a><span id="l20.3359" class="difflineminus">-              (&quot;UpdateImapMailboxInfo(): UIDVALIDITY changed, reset highest MODSEQ and UID for folder=%s&quot;,</span>
<a href="#l20.3360"></a><span id="l20.3360" class="difflineplus">+              (&quot;UpdateImapMailboxInfo(): UIDVALIDITY changed, reset highest &quot;</span>
<a href="#l20.3361"></a><span id="l20.3361" class="difflineplus">+               &quot;MODSEQ and UID for folder=%s&quot;,</span>
<a href="#l20.3362"></a><span id="l20.3362">                m_onlineFolderName.get()));</span>
<a href="#l20.3363"></a><span id="l20.3363">       dbFolderInfo-&gt;SetCharProperty(kModSeqPropertyName, EmptyCString());</span>
<a href="#l20.3364"></a><span id="l20.3364">       dbFolderInfo-&gt;SetUint32Property(kHighestRecordedUIDPropertyName, 0);</span>
<a href="#l20.3365"></a><span id="l20.3365">     }</span>
<a href="#l20.3366"></a><span id="l20.3366">     // delete all my msgs, the keys are bogus now</span>
<a href="#l20.3367"></a><span id="l20.3367">     // add every message in this folder</span>
<a href="#l20.3368"></a><span id="l20.3368">     existingKeys.Clear();</span>
<a href="#l20.3369"></a><span id="l20.3369">     //      keysToDelete.CopyArray(&amp;existingKeys);</span>
<a href="#l20.3370"></a><span id="l20.3370"> </span>
<a href="#l20.3371"></a><span id="l20.3371" class="difflineminus">-    if (flagState)</span>
<a href="#l20.3372"></a><span id="l20.3372" class="difflineminus">-    {</span>
<a href="#l20.3373"></a><span id="l20.3373" class="difflineplus">+    if (flagState) {</span>
<a href="#l20.3374"></a><span id="l20.3374">       nsTArray&lt;nsMsgKey&gt; no_existingKeys;</span>
<a href="#l20.3375"></a><span id="l20.3375">       FindKeysToAdd(no_existingKeys, m_keysToFetch, numNewUnread, flagState);</span>
<a href="#l20.3376"></a><span id="l20.3376">     }</span>
<a href="#l20.3377"></a><span id="l20.3377" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l20.3378"></a><span id="l20.3378" class="difflineminus">-      pathFile-&gt;Remove(false);</span>
<a href="#l20.3379"></a><span id="l20.3379" class="difflineminus">-</span>
<a href="#l20.3380"></a><span id="l20.3380" class="difflineminus">-  }</span>
<a href="#l20.3381"></a><span id="l20.3381" class="difflineminus">-  else if (!flagState /*&amp;&amp; !NET_IsOffline() */) // if there are no messages on the server</span>
<a href="#l20.3382"></a><span id="l20.3382" class="difflineplus">+    if (NS_FAILED(rv)) pathFile-&gt;Remove(false);</span>
<a href="#l20.3383"></a><span id="l20.3383" class="difflineplus">+</span>
<a href="#l20.3384"></a><span id="l20.3384" class="difflineplus">+  } else if (!flagState /*&amp;&amp; !NET_IsOffline() */)  // if there are no messages</span>
<a href="#l20.3385"></a><span id="l20.3385" class="difflineplus">+                                                   // on the server</span>
<a href="#l20.3386"></a><span id="l20.3386">     keysToDelete = existingKeys;</span>
<a href="#l20.3387"></a><span id="l20.3387">   else /* if ( !NET_IsOffline()) */</span>
<a href="#l20.3388"></a><span id="l20.3388">   {</span>
<a href="#l20.3389"></a><span id="l20.3389">     uint32_t boxFlags;</span>
<a href="#l20.3390"></a><span id="l20.3390">     aSpec-&gt;GetBox_flags(&amp;boxFlags);</span>
<a href="#l20.3391"></a><span id="l20.3391">     // FindKeysToDelete and FindKeysToAdd require sorted lists</span>
<a href="#l20.3392"></a><span id="l20.3392">     existingKeys.Sort();</span>
<a href="#l20.3393"></a><span id="l20.3393">     FindKeysToDelete(existingKeys, keysToDelete, flagState, boxFlags);</span>
<a href="#l20.3394"></a><span id="l20.3394">     // if this is the result of an expunge then don't grab headers</span>
<a href="#l20.3395"></a><span id="l20.3395">     if (!(boxFlags &amp; kJustExpunged))</span>
<a href="#l20.3396"></a><span id="l20.3396">       FindKeysToAdd(existingKeys, m_keysToFetch, numNewUnread, flagState);</span>
<a href="#l20.3397"></a><span id="l20.3397">   }</span>
<a href="#l20.3398"></a><span id="l20.3398">   m_totalKeysToFetch = m_keysToFetch.Length();</span>
<a href="#l20.3399"></a><span id="l20.3399" class="difflineminus">-  if (!keysToDelete.IsEmpty() &amp;&amp; mDatabase)</span>
<a href="#l20.3400"></a><span id="l20.3400" class="difflineminus">-  {</span>
<a href="#l20.3401"></a><span id="l20.3401" class="difflineminus">-    nsCOMPtr&lt;nsIMutableArray&gt; hdrsToDelete(do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l20.3402"></a><span id="l20.3402" class="difflineplus">+  if (!keysToDelete.IsEmpty() &amp;&amp; mDatabase) {</span>
<a href="#l20.3403"></a><span id="l20.3403" class="difflineplus">+    nsCOMPtr&lt;nsIMutableArray&gt; hdrsToDelete(</span>
<a href="#l20.3404"></a><span id="l20.3404" class="difflineplus">+        do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l20.3405"></a><span id="l20.3405">     MsgGetHeadersFromKeys(mDatabase, keysToDelete, hdrsToDelete);</span>
<a href="#l20.3406"></a><span id="l20.3406" class="difflineminus">-    // Notify nsIMsgFolderListeners of a mass delete, but only if we actually have headers</span>
<a href="#l20.3407"></a><span id="l20.3407" class="difflineplus">+    // Notify nsIMsgFolderListeners of a mass delete, but only if we actually</span>
<a href="#l20.3408"></a><span id="l20.3408" class="difflineplus">+    // have headers</span>
<a href="#l20.3409"></a><span id="l20.3409">     uint32_t numHdrs;</span>
<a href="#l20.3410"></a><span id="l20.3410">     hdrsToDelete-&gt;GetLength(&amp;numHdrs);</span>
<a href="#l20.3411"></a><span id="l20.3411" class="difflineminus">-    if (numHdrs)</span>
<a href="#l20.3412"></a><span id="l20.3412" class="difflineminus">-    {</span>
<a href="#l20.3413"></a><span id="l20.3413" class="difflineminus">-      nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.3414"></a><span id="l20.3414" class="difflineminus">-      if (notifier)</span>
<a href="#l20.3415"></a><span id="l20.3415" class="difflineminus">-        notifier-&gt;NotifyMsgsDeleted(hdrsToDelete);</span>
<a href="#l20.3416"></a><span id="l20.3416" class="difflineplus">+    if (numHdrs) {</span>
<a href="#l20.3417"></a><span id="l20.3417" class="difflineplus">+      nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(</span>
<a href="#l20.3418"></a><span id="l20.3418" class="difflineplus">+          do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.3419"></a><span id="l20.3419" class="difflineplus">+      if (notifier) notifier-&gt;NotifyMsgsDeleted(hdrsToDelete);</span>
<a href="#l20.3420"></a><span id="l20.3420">     }</span>
<a href="#l20.3421"></a><span id="l20.3421">     DeleteStoreMessages(hdrsToDelete);</span>
<a href="#l20.3422"></a><span id="l20.3422">     EnableNotifications(nsIMsgFolder::allMessageCountNotifications, false);</span>
<a href="#l20.3423"></a><span id="l20.3423" class="difflineminus">-    mDatabase-&gt;DeleteMessages(keysToDelete.Length(), keysToDelete.Elements(), nullptr);</span>
<a href="#l20.3424"></a><span id="l20.3424" class="difflineplus">+    mDatabase-&gt;DeleteMessages(keysToDelete.Length(), keysToDelete.Elements(),</span>
<a href="#l20.3425"></a><span id="l20.3425" class="difflineplus">+                              nullptr);</span>
<a href="#l20.3426"></a><span id="l20.3426">     EnableNotifications(nsIMsgFolder::allMessageCountNotifications, true);</span>
<a href="#l20.3427"></a><span id="l20.3427">   }</span>
<a href="#l20.3428"></a><span id="l20.3428">   int32_t numUnreadFromServer;</span>
<a href="#l20.3429"></a><span id="l20.3429">   aSpec-&gt;GetNumUnseenMessages(&amp;numUnreadFromServer);</span>
<a href="#l20.3430"></a><span id="l20.3430"> </span>
<a href="#l20.3431"></a><span id="l20.3431">   bool partialUIDFetch;</span>
<a href="#l20.3432"></a><span id="l20.3432">   flagState-&gt;GetPartialUIDFetch(&amp;partialUIDFetch);</span>
<a href="#l20.3433"></a><span id="l20.3433"> </span>
<a href="#l20.3434"></a><span id="l20.3434">   // For partial UID fetches, we can only trust the numUnread from the server.</span>
<a href="#l20.3435"></a><span id="l20.3435" class="difflineminus">-  if (partialUIDFetch)</span>
<a href="#l20.3436"></a><span id="l20.3436" class="difflineminus">-    numNewUnread = numUnreadFromServer;</span>
<a href="#l20.3437"></a><span id="l20.3437" class="difflineplus">+  if (partialUIDFetch) numNewUnread = numUnreadFromServer;</span>
<a href="#l20.3438"></a><span id="l20.3438"> </span>
<a href="#l20.3439"></a><span id="l20.3439">   // If we are performing biff for this folder, tell the</span>
<a href="#l20.3440"></a><span id="l20.3440">   // stand-alone biff about the new high water mark</span>
<a href="#l20.3441"></a><span id="l20.3441" class="difflineminus">-  if (m_performingBiff &amp;&amp; numNewUnread)</span>
<a href="#l20.3442"></a><span id="l20.3442" class="difflineminus">-  {</span>
<a href="#l20.3443"></a><span id="l20.3443" class="difflineplus">+  if (m_performingBiff &amp;&amp; numNewUnread) {</span>
<a href="#l20.3444"></a><span id="l20.3444">     // We must ensure that the server knows that we are performing biff.</span>
<a href="#l20.3445"></a><span id="l20.3445">     // Otherwise the stand-alone biff won't fire.</span>
<a href="#l20.3446"></a><span id="l20.3446">     nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.3447"></a><span id="l20.3447">     if (NS_SUCCEEDED(GetServer(getter_AddRefs(server))) &amp;&amp; server)</span>
<a href="#l20.3448"></a><span id="l20.3448">       server-&gt;SetPerformingBiff(true);</span>
<a href="#l20.3449"></a><span id="l20.3449" class="difflineminus">-     SetNumNewMessages(numNewUnread);</span>
<a href="#l20.3450"></a><span id="l20.3450" class="difflineplus">+    SetNumNewMessages(numNewUnread);</span>
<a href="#l20.3451"></a><span id="l20.3451">   }</span>
<a href="#l20.3452"></a><span id="l20.3452">   SyncFlags(flagState);</span>
<a href="#l20.3453"></a><span id="l20.3453" class="difflineminus">-  if (mDatabase &amp;&amp; (int32_t) (mNumUnreadMessages + m_keysToFetch.Length()) &gt; numUnreadFromServer)</span>
<a href="#l20.3454"></a><span id="l20.3454" class="difflineplus">+  if (mDatabase &amp;&amp; (int32_t)(mNumUnreadMessages + m_keysToFetch.Length()) &gt;</span>
<a href="#l20.3455"></a><span id="l20.3455" class="difflineplus">+                       numUnreadFromServer)</span>
<a href="#l20.3456"></a><span id="l20.3456">     mDatabase-&gt;SyncCounts();</span>
<a href="#l20.3457"></a><span id="l20.3457"> </span>
<a href="#l20.3458"></a><span id="l20.3458">   if (!m_keysToFetch.IsEmpty() &amp;&amp; aProtocol)</span>
<a href="#l20.3459"></a><span id="l20.3459">     PrepareToAddHeadersToMailDB(aProtocol);</span>
<a href="#l20.3460"></a><span id="l20.3460" class="difflineminus">-  else</span>
<a href="#l20.3461"></a><span id="l20.3461" class="difflineminus">-  {</span>
<a href="#l20.3462"></a><span id="l20.3462" class="difflineplus">+  else {</span>
<a href="#l20.3463"></a><span id="l20.3463">     bool gettingNewMessages;</span>
<a href="#l20.3464"></a><span id="l20.3464">     GetGettingNewMessages(&amp;gettingNewMessages);</span>
<a href="#l20.3465"></a><span id="l20.3465">     if (gettingNewMessages)</span>
<a href="#l20.3466"></a><span id="l20.3466">       ProgressStatusString(aProtocol, &quot;imapNoNewMessages&quot;, nullptr);</span>
<a href="#l20.3467"></a><span id="l20.3467">     SetPerformingBiff(false);</span>
<a href="#l20.3468"></a><span id="l20.3468">   }</span>
<a href="#l20.3469"></a><span id="l20.3469">   aSpec-&gt;GetNumMessages(&amp;m_numServerTotalMessages);</span>
<a href="#l20.3470"></a><span id="l20.3470">   aSpec-&gt;GetNumUnseenMessages(&amp;m_numServerUnseenMessages);</span>
<a href="#l20.3471"></a><span id="l20.3471">   aSpec-&gt;GetNumRecentMessages(&amp;m_numServerRecentMessages);</span>
<a href="#l20.3472"></a><span id="l20.3472"> </span>
<a href="#l20.3473"></a><span id="l20.3473">   // some servers don't return UIDNEXT on SELECT - don't crunch</span>
<a href="#l20.3474"></a><span id="l20.3474">   // existing values in that case.</span>
<a href="#l20.3475"></a><span id="l20.3475">   int32_t nextUID;</span>
<a href="#l20.3476"></a><span id="l20.3476">   aSpec-&gt;GetNextUID(&amp;nextUID);</span>
<a href="#l20.3477"></a><span id="l20.3477" class="difflineminus">-  if (nextUID != (int32_t) nsMsgKey_None)</span>
<a href="#l20.3478"></a><span id="l20.3478" class="difflineminus">-    m_nextUID = nextUID;</span>
<a href="#l20.3479"></a><span id="l20.3479" class="difflineplus">+  if (nextUID != (int32_t)nsMsgKey_None) m_nextUID = nextUID;</span>
<a href="#l20.3480"></a><span id="l20.3480"> </span>
<a href="#l20.3481"></a><span id="l20.3481">   return rv;</span>
<a href="#l20.3482"></a><span id="l20.3482"> }</span>
<a href="#l20.3483"></a><span id="l20.3483"> </span>
<a href="#l20.3484"></a><span id="l20.3484"> NS_IMETHODIMP nsImapMailFolder::UpdateImapMailboxStatus(</span>
<a href="#l20.3485"></a><span id="l20.3485" class="difflineminus">-  nsIImapProtocol* aProtocol, nsIMailboxSpec* aSpec)</span>
<a href="#l20.3486"></a><span id="l20.3486" class="difflineminus">-{</span>
<a href="#l20.3487"></a><span id="l20.3487" class="difflineplus">+    nsIImapProtocol *aProtocol, nsIMailboxSpec *aSpec) {</span>
<a href="#l20.3488"></a><span id="l20.3488">   NS_ENSURE_ARG_POINTER(aSpec);</span>
<a href="#l20.3489"></a><span id="l20.3489">   int32_t numUnread, numTotal;</span>
<a href="#l20.3490"></a><span id="l20.3490">   aSpec-&gt;GetNumUnseenMessages(&amp;numUnread);</span>
<a href="#l20.3491"></a><span id="l20.3491">   aSpec-&gt;GetNumMessages(&amp;numTotal);</span>
<a href="#l20.3492"></a><span id="l20.3492">   aSpec-&gt;GetNumRecentMessages(&amp;m_numServerRecentMessages);</span>
<a href="#l20.3493"></a><span id="l20.3493">   int32_t prevNextUID = m_nextUID;</span>
<a href="#l20.3494"></a><span id="l20.3494">   aSpec-&gt;GetNextUID(&amp;m_nextUID);</span>
<a href="#l20.3495"></a><span id="l20.3495">   bool summaryChanged = false;</span>
<a href="#l20.3496"></a><span id="l20.3496"> </span>
<a href="#l20.3497"></a><span id="l20.3497">   // If m_numServerUnseenMessages is 0, it means</span>
<a href="#l20.3498"></a><span id="l20.3498">   // this is the first time we've done a Status.</span>
<a href="#l20.3499"></a><span id="l20.3499" class="difflineminus">-  // In that case, we count all the previous pending unread messages we know about</span>
<a href="#l20.3500"></a><span id="l20.3500" class="difflineminus">-  // as unread messages.</span>
<a href="#l20.3501"></a><span id="l20.3501" class="difflineminus">-  // We may want to do similar things with total messages, but the total messages</span>
<a href="#l20.3502"></a><span id="l20.3502" class="difflineminus">-  // include deleted messages if the folder hasn't been expunged.</span>
<a href="#l20.3503"></a><span id="l20.3503" class="difflineminus">-  int32_t previousUnreadMessages = (m_numServerUnseenMessages)</span>
<a href="#l20.3504"></a><span id="l20.3504" class="difflineminus">-    ? m_numServerUnseenMessages : mNumPendingUnreadMessages + mNumUnreadMessages;</span>
<a href="#l20.3505"></a><span id="l20.3505" class="difflineminus">-  if (numUnread != previousUnreadMessages || m_nextUID != prevNextUID)</span>
<a href="#l20.3506"></a><span id="l20.3506" class="difflineminus">-  {</span>
<a href="#l20.3507"></a><span id="l20.3507" class="difflineminus">-    int32_t unreadDelta = numUnread - (mNumPendingUnreadMessages + mNumUnreadMessages);</span>
<a href="#l20.3508"></a><span id="l20.3508" class="difflineplus">+  // In that case, we count all the previous pending unread messages we know</span>
<a href="#l20.3509"></a><span id="l20.3509" class="difflineplus">+  // about as unread messages. We may want to do similar things with total</span>
<a href="#l20.3510"></a><span id="l20.3510" class="difflineplus">+  // messages, but the total messages include deleted messages if the folder</span>
<a href="#l20.3511"></a><span id="l20.3511" class="difflineplus">+  // hasn't been expunged.</span>
<a href="#l20.3512"></a><span id="l20.3512" class="difflineplus">+  int32_t previousUnreadMessages =</span>
<a href="#l20.3513"></a><span id="l20.3513" class="difflineplus">+      (m_numServerUnseenMessages)</span>
<a href="#l20.3514"></a><span id="l20.3514" class="difflineplus">+          ? m_numServerUnseenMessages</span>
<a href="#l20.3515"></a><span id="l20.3515" class="difflineplus">+          : mNumPendingUnreadMessages + mNumUnreadMessages;</span>
<a href="#l20.3516"></a><span id="l20.3516" class="difflineplus">+  if (numUnread != previousUnreadMessages || m_nextUID != prevNextUID) {</span>
<a href="#l20.3517"></a><span id="l20.3517" class="difflineplus">+    int32_t unreadDelta =</span>
<a href="#l20.3518"></a><span id="l20.3518" class="difflineplus">+        numUnread - (mNumPendingUnreadMessages + mNumUnreadMessages);</span>
<a href="#l20.3519"></a><span id="l20.3519">     if (numUnread - previousUnreadMessages != unreadDelta)</span>
<a href="#l20.3520"></a><span id="l20.3520" class="difflineminus">-       NS_WARNING(&quot;unread count should match server count&quot;);</span>
<a href="#l20.3521"></a><span id="l20.3521" class="difflineplus">+      NS_WARNING(&quot;unread count should match server count&quot;);</span>
<a href="#l20.3522"></a><span id="l20.3522">     ChangeNumPendingUnread(unreadDelta);</span>
<a href="#l20.3523"></a><span id="l20.3523">     if (unreadDelta &gt; 0 &amp;&amp;</span>
<a href="#l20.3524"></a><span id="l20.3524" class="difflineminus">-        !(mFlags &amp; (nsMsgFolderFlags::Trash | nsMsgFolderFlags::Junk)))</span>
<a href="#l20.3525"></a><span id="l20.3525" class="difflineminus">-    {</span>
<a href="#l20.3526"></a><span id="l20.3526" class="difflineplus">+        !(mFlags &amp; (nsMsgFolderFlags::Trash | nsMsgFolderFlags::Junk))) {</span>
<a href="#l20.3527"></a><span id="l20.3527">       SetHasNewMessages(true);</span>
<a href="#l20.3528"></a><span id="l20.3528">       SetNumNewMessages(unreadDelta);</span>
<a href="#l20.3529"></a><span id="l20.3529">       SetBiffState(nsMsgBiffState_NewMail);</span>
<a href="#l20.3530"></a><span id="l20.3530">     }</span>
<a href="#l20.3531"></a><span id="l20.3531">     summaryChanged = true;</span>
<a href="#l20.3532"></a><span id="l20.3532">   }</span>
<a href="#l20.3533"></a><span id="l20.3533">   SetPerformingBiff(false);</span>
<a href="#l20.3534"></a><span id="l20.3534" class="difflineminus">-  if (m_numServerUnseenMessages != numUnread || m_numServerTotalMessages != numTotal)</span>
<a href="#l20.3535"></a><span id="l20.3535" class="difflineminus">-  {</span>
<a href="#l20.3536"></a><span id="l20.3536" class="difflineplus">+  if (m_numServerUnseenMessages != numUnread ||</span>
<a href="#l20.3537"></a><span id="l20.3537" class="difflineplus">+      m_numServerTotalMessages != numTotal) {</span>
<a href="#l20.3538"></a><span id="l20.3538">     if (numUnread &gt; m_numServerUnseenMessages ||</span>
<a href="#l20.3539"></a><span id="l20.3539">         m_numServerTotalMessages &gt; numTotal)</span>
<a href="#l20.3540"></a><span id="l20.3540">       NotifyHasPendingMsgs();</span>
<a href="#l20.3541"></a><span id="l20.3541">     summaryChanged = true;</span>
<a href="#l20.3542"></a><span id="l20.3542">     m_numServerUnseenMessages = numUnread;</span>
<a href="#l20.3543"></a><span id="l20.3543">     m_numServerTotalMessages = numTotal;</span>
<a href="#l20.3544"></a><span id="l20.3544">   }</span>
<a href="#l20.3545"></a><span id="l20.3545" class="difflineminus">-  if (summaryChanged)</span>
<a href="#l20.3546"></a><span id="l20.3546" class="difflineminus">-    SummaryChanged();</span>
<a href="#l20.3547"></a><span id="l20.3547" class="difflineplus">+  if (summaryChanged) SummaryChanged();</span>
<a href="#l20.3548"></a><span id="l20.3548"> </span>
<a href="#l20.3549"></a><span id="l20.3549">   return NS_OK;</span>
<a href="#l20.3550"></a><span id="l20.3550"> }</span>
<a href="#l20.3551"></a><span id="l20.3551"> </span>
<a href="#l20.3552"></a><span id="l20.3552" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::ParseMsgHdrs(nsIImapProtocol *aProtocol, nsIImapHeaderXferInfo *aHdrXferInfo)</span>
<a href="#l20.3553"></a><span id="l20.3553" class="difflineminus">-{</span>
<a href="#l20.3554"></a><span id="l20.3554" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::ParseMsgHdrs(</span>
<a href="#l20.3555"></a><span id="l20.3555" class="difflineplus">+    nsIImapProtocol *aProtocol, nsIImapHeaderXferInfo *aHdrXferInfo) {</span>
<a href="#l20.3556"></a><span id="l20.3556">   NS_ENSURE_ARG_POINTER(aHdrXferInfo);</span>
<a href="#l20.3557"></a><span id="l20.3557">   int32_t numHdrs;</span>
<a href="#l20.3558"></a><span id="l20.3558" class="difflineminus">-  nsCOMPtr &lt;nsIImapHeaderInfo&gt; headerInfo;</span>
<a href="#l20.3559"></a><span id="l20.3559" class="difflineminus">-  nsCOMPtr &lt;nsIImapUrl&gt; aImapUrl;</span>
<a href="#l20.3560"></a><span id="l20.3560" class="difflineminus">-  nsImapAction imapAction = nsIImapUrl::nsImapTest; // unused value.</span>
<a href="#l20.3561"></a><span id="l20.3561" class="difflineminus">-  if (!mDatabase)</span>
<a href="#l20.3562"></a><span id="l20.3562" class="difflineminus">-    GetDatabase();</span>
<a href="#l20.3563"></a><span id="l20.3563" class="difflineplus">+  nsCOMPtr&lt;nsIImapHeaderInfo&gt; headerInfo;</span>
<a href="#l20.3564"></a><span id="l20.3564" class="difflineplus">+  nsCOMPtr&lt;nsIImapUrl&gt; aImapUrl;</span>
<a href="#l20.3565"></a><span id="l20.3565" class="difflineplus">+  nsImapAction imapAction = nsIImapUrl::nsImapTest;  // unused value.</span>
<a href="#l20.3566"></a><span id="l20.3566" class="difflineplus">+  if (!mDatabase) GetDatabase();</span>
<a href="#l20.3567"></a><span id="l20.3567"> </span>
<a href="#l20.3568"></a><span id="l20.3568">   nsresult rv = aHdrXferInfo-&gt;GetNumHeaders(&amp;numHdrs);</span>
<a href="#l20.3569"></a><span id="l20.3569" class="difflineminus">-  if (aProtocol)</span>
<a href="#l20.3570"></a><span id="l20.3570" class="difflineminus">-  {</span>
<a href="#l20.3571"></a><span id="l20.3571" class="difflineminus">-    (void) aProtocol-&gt;GetRunningImapURL(getter_AddRefs(aImapUrl));</span>
<a href="#l20.3572"></a><span id="l20.3572" class="difflineminus">-    if (aImapUrl)</span>
<a href="#l20.3573"></a><span id="l20.3573" class="difflineminus">-      aImapUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l20.3574"></a><span id="l20.3574" class="difflineminus">-  }</span>
<a href="#l20.3575"></a><span id="l20.3575" class="difflineminus">-  for (uint32_t i = 0; NS_SUCCEEDED(rv) &amp;&amp; (int32_t)i &lt; numHdrs; i++)</span>
<a href="#l20.3576"></a><span id="l20.3576" class="difflineminus">-  {</span>
<a href="#l20.3577"></a><span id="l20.3577" class="difflineplus">+  if (aProtocol) {</span>
<a href="#l20.3578"></a><span id="l20.3578" class="difflineplus">+    (void)aProtocol-&gt;GetRunningImapURL(getter_AddRefs(aImapUrl));</span>
<a href="#l20.3579"></a><span id="l20.3579" class="difflineplus">+    if (aImapUrl) aImapUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l20.3580"></a><span id="l20.3580" class="difflineplus">+  }</span>
<a href="#l20.3581"></a><span id="l20.3581" class="difflineplus">+  for (uint32_t i = 0; NS_SUCCEEDED(rv) &amp;&amp; (int32_t)i &lt; numHdrs; i++) {</span>
<a href="#l20.3582"></a><span id="l20.3582">     rv = aHdrXferInfo-&gt;GetHeader(i, getter_AddRefs(headerInfo));</span>
<a href="#l20.3583"></a><span id="l20.3583">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3584"></a><span id="l20.3584" class="difflineminus">-    if (!headerInfo)</span>
<a href="#l20.3585"></a><span id="l20.3585" class="difflineminus">-      break;</span>
<a href="#l20.3586"></a><span id="l20.3586" class="difflineplus">+    if (!headerInfo) break;</span>
<a href="#l20.3587"></a><span id="l20.3587">     int32_t msgSize;</span>
<a href="#l20.3588"></a><span id="l20.3588">     nsMsgKey msgKey;</span>
<a href="#l20.3589"></a><span id="l20.3589">     bool containsKey;</span>
<a href="#l20.3590"></a><span id="l20.3590">     const char *msgHdrs;</span>
<a href="#l20.3591"></a><span id="l20.3591">     headerInfo-&gt;GetMsgSize(&amp;msgSize);</span>
<a href="#l20.3592"></a><span id="l20.3592">     headerInfo-&gt;GetMsgUid(&amp;msgKey);</span>
<a href="#l20.3593"></a><span id="l20.3593" class="difflineminus">-    if (msgKey == nsMsgKey_None) // not a valid uid.</span>
<a href="#l20.3594"></a><span id="l20.3594" class="difflineplus">+    if (msgKey == nsMsgKey_None)  // not a valid uid.</span>
<a href="#l20.3595"></a><span id="l20.3595">       continue;</span>
<a href="#l20.3596"></a><span id="l20.3596" class="difflineminus">-    if (imapAction == nsIImapUrl::nsImapMsgPreview)</span>
<a href="#l20.3597"></a><span id="l20.3597" class="difflineminus">-    {</span>
<a href="#l20.3598"></a><span id="l20.3598" class="difflineminus">-      nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l20.3599"></a><span id="l20.3599" class="difflineplus">+    if (imapAction == nsIImapUrl::nsImapMsgPreview) {</span>
<a href="#l20.3600"></a><span id="l20.3600" class="difflineplus">+      nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l20.3601"></a><span id="l20.3601">       headerInfo-&gt;GetMsgHdrs(&amp;msgHdrs);</span>
<a href="#l20.3602"></a><span id="l20.3602">       // create an input stream based on the hdr string.</span>
<a href="#l20.3603"></a><span id="l20.3603">       nsCOMPtr&lt;nsIStringInputStream&gt; inputStream =</span>
<a href="#l20.3604"></a><span id="l20.3604" class="difflineminus">-            do_CreateInstance(&quot;@mozilla.org/io/string-input-stream;1&quot;, &amp;rv);</span>
<a href="#l20.3605"></a><span id="l20.3605" class="difflineplus">+          do_CreateInstance(&quot;@mozilla.org/io/string-input-stream;1&quot;, &amp;rv);</span>
<a href="#l20.3606"></a><span id="l20.3606">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3607"></a><span id="l20.3607">       inputStream-&gt;ShareData(msgHdrs, strlen(msgHdrs));</span>
<a href="#l20.3608"></a><span id="l20.3608">       GetMessageHeader(msgKey, getter_AddRefs(msgHdr));</span>
<a href="#l20.3609"></a><span id="l20.3609">       if (msgHdr) {</span>
<a href="#l20.3610"></a><span id="l20.3610">         GetMsgPreviewTextFromStream(msgHdr, inputStream);</span>
<a href="#l20.3611"></a><span id="l20.3611">       }</span>
<a href="#l20.3612"></a><span id="l20.3612">       continue;</span>
<a href="#l20.3613"></a><span id="l20.3613">     }</span>
<a href="#l20.3614"></a><span id="l20.3614" class="difflineminus">-    if (mDatabase &amp;&amp; NS_SUCCEEDED(mDatabase-&gt;ContainsKey(msgKey, &amp;containsKey)) &amp;&amp; containsKey)</span>
<a href="#l20.3615"></a><span id="l20.3615" class="difflineminus">-    {</span>
<a href="#l20.3616"></a><span id="l20.3616" class="difflineplus">+    if (mDatabase &amp;&amp;</span>
<a href="#l20.3617"></a><span id="l20.3617" class="difflineplus">+        NS_SUCCEEDED(mDatabase-&gt;ContainsKey(msgKey, &amp;containsKey)) &amp;&amp;</span>
<a href="#l20.3618"></a><span id="l20.3618" class="difflineplus">+        containsKey) {</span>
<a href="#l20.3619"></a><span id="l20.3619">       NS_ERROR(&quot;downloading hdrs for hdr we already have&quot;);</span>
<a href="#l20.3620"></a><span id="l20.3620">       continue;</span>
<a href="#l20.3621"></a><span id="l20.3621">     }</span>
<a href="#l20.3622"></a><span id="l20.3622">     nsresult rv = SetupHeaderParseStream(msgSize, EmptyCString(), nullptr);</span>
<a href="#l20.3623"></a><span id="l20.3623">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3624"></a><span id="l20.3624">     headerInfo-&gt;GetMsgHdrs(&amp;msgHdrs);</span>
<a href="#l20.3625"></a><span id="l20.3625">     rv = ParseAdoptedHeaderLine(msgHdrs, msgKey);</span>
<a href="#l20.3626"></a><span id="l20.3626">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3627"></a><span id="l20.3627">     rv = NormalEndHeaderParseStream(aProtocol, aImapUrl);</span>
<a href="#l20.3628"></a><span id="l20.3628">   }</span>
<a href="#l20.3629"></a><span id="l20.3629">   return rv;</span>
<a href="#l20.3630"></a><span id="l20.3630"> }</span>
<a href="#l20.3631"></a><span id="l20.3631"> </span>
<a href="#l20.3632"></a><span id="l20.3632" class="difflineminus">-nsresult nsImapMailFolder::SetupHeaderParseStream(uint32_t aSize,</span>
<a href="#l20.3633"></a><span id="l20.3633" class="difflineminus">-                                                  const nsACString&amp; content_type, nsIMailboxSpec *boxSpec)</span>
<a href="#l20.3634"></a><span id="l20.3634" class="difflineminus">-{</span>
<a href="#l20.3635"></a><span id="l20.3635" class="difflineminus">-  if (!mDatabase)</span>
<a href="#l20.3636"></a><span id="l20.3636" class="difflineminus">-    GetDatabase();</span>
<a href="#l20.3637"></a><span id="l20.3637" class="difflineplus">+nsresult nsImapMailFolder::SetupHeaderParseStream(</span>
<a href="#l20.3638"></a><span id="l20.3638" class="difflineplus">+    uint32_t aSize, const nsACString &amp;content_type, nsIMailboxSpec *boxSpec) {</span>
<a href="#l20.3639"></a><span id="l20.3639" class="difflineplus">+  if (!mDatabase) GetDatabase();</span>
<a href="#l20.3640"></a><span id="l20.3640">   m_nextMessageByteLength = aSize;</span>
<a href="#l20.3641"></a><span id="l20.3641" class="difflineminus">-  if (!m_msgParser)</span>
<a href="#l20.3642"></a><span id="l20.3642" class="difflineminus">-  {</span>
<a href="#l20.3643"></a><span id="l20.3643" class="difflineplus">+  if (!m_msgParser) {</span>
<a href="#l20.3644"></a><span id="l20.3644">     nsresult rv;</span>
<a href="#l20.3645"></a><span id="l20.3645">     m_msgParser = do_CreateInstance(kParseMailMsgStateCID, &amp;rv);</span>
<a href="#l20.3646"></a><span id="l20.3646">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3647"></a><span id="l20.3647" class="difflineminus">-  }</span>
<a href="#l20.3648"></a><span id="l20.3648" class="difflineminus">-  else</span>
<a href="#l20.3649"></a><span id="l20.3649" class="difflineplus">+  } else</span>
<a href="#l20.3650"></a><span id="l20.3650">     m_msgParser-&gt;Clear();</span>
<a href="#l20.3651"></a><span id="l20.3651"> </span>
<a href="#l20.3652"></a><span id="l20.3652">   m_msgParser-&gt;SetMailDB(mDatabase);</span>
<a href="#l20.3653"></a><span id="l20.3653" class="difflineminus">-  if (mBackupDatabase)</span>
<a href="#l20.3654"></a><span id="l20.3654" class="difflineminus">-    m_msgParser-&gt;SetBackupMailDB(mBackupDatabase);</span>
<a href="#l20.3655"></a><span id="l20.3655" class="difflineplus">+  if (mBackupDatabase) m_msgParser-&gt;SetBackupMailDB(mBackupDatabase);</span>
<a href="#l20.3656"></a><span id="l20.3656">   return m_msgParser-&gt;SetState(nsIMsgParseMailMsgState::ParseHeadersState);</span>
<a href="#l20.3657"></a><span id="l20.3657"> }</span>
<a href="#l20.3658"></a><span id="l20.3658"> </span>
<a href="#l20.3659"></a><span id="l20.3659" class="difflineminus">-nsresult nsImapMailFolder::ParseAdoptedHeaderLine(const char *aMessageLine, nsMsgKey aMsgKey)</span>
<a href="#l20.3660"></a><span id="l20.3660" class="difflineminus">-{</span>
<a href="#l20.3661"></a><span id="l20.3661" class="difflineplus">+nsresult nsImapMailFolder::ParseAdoptedHeaderLine(const char *aMessageLine,</span>
<a href="#l20.3662"></a><span id="l20.3662" class="difflineplus">+                                                  nsMsgKey aMsgKey) {</span>
<a href="#l20.3663"></a><span id="l20.3663">   // we can get blocks that contain more than one line,</span>
<a href="#l20.3664"></a><span id="l20.3664">   // but they never contain partial lines</span>
<a href="#l20.3665"></a><span id="l20.3665">   const char *str = aMessageLine;</span>
<a href="#l20.3666"></a><span id="l20.3666">   m_curMsgUid = aMsgKey;</span>
<a href="#l20.3667"></a><span id="l20.3667">   m_msgParser-&gt;SetNewKey(m_curMsgUid);</span>
<a href="#l20.3668"></a><span id="l20.3668">   // m_envelope_pos, for local folders,</span>
<a href="#l20.3669"></a><span id="l20.3669">   // is the msg key. Setting this will set the msg key for the new header.</span>
<a href="#l20.3670"></a><span id="l20.3670"> </span>
<a href="#l20.3671"></a><span id="l20.3671">   int32_t len = strlen(str);</span>
<a href="#l20.3672"></a><span id="l20.3672" class="difflineminus">-  char *currentEOL  = PL_strstr(str, MSG_LINEBREAK);</span>
<a href="#l20.3673"></a><span id="l20.3673" class="difflineplus">+  char *currentEOL = PL_strstr(str, MSG_LINEBREAK);</span>
<a href="#l20.3674"></a><span id="l20.3674">   const char *currentLine = str;</span>
<a href="#l20.3675"></a><span id="l20.3675" class="difflineminus">-  while (currentLine &lt; (str + len))</span>
<a href="#l20.3676"></a><span id="l20.3676" class="difflineminus">-  {</span>
<a href="#l20.3677"></a><span id="l20.3677" class="difflineminus">-    if (currentEOL)</span>
<a href="#l20.3678"></a><span id="l20.3678" class="difflineminus">-    {</span>
<a href="#l20.3679"></a><span id="l20.3679" class="difflineminus">-      m_msgParser-&gt;ParseAFolderLine(currentLine,</span>
<a href="#l20.3680"></a><span id="l20.3680" class="difflineminus">-        (currentEOL + MSG_LINEBREAK_LEN) -</span>
<a href="#l20.3681"></a><span id="l20.3681" class="difflineminus">-        currentLine);</span>
<a href="#l20.3682"></a><span id="l20.3682" class="difflineplus">+  while (currentLine &lt; (str + len)) {</span>
<a href="#l20.3683"></a><span id="l20.3683" class="difflineplus">+    if (currentEOL) {</span>
<a href="#l20.3684"></a><span id="l20.3684" class="difflineplus">+      m_msgParser-&gt;ParseAFolderLine(</span>
<a href="#l20.3685"></a><span id="l20.3685" class="difflineplus">+          currentLine, (currentEOL + MSG_LINEBREAK_LEN) - currentLine);</span>
<a href="#l20.3686"></a><span id="l20.3686">       currentLine = currentEOL + MSG_LINEBREAK_LEN;</span>
<a href="#l20.3687"></a><span id="l20.3687" class="difflineminus">-      currentEOL  = PL_strstr(currentLine, MSG_LINEBREAK);</span>
<a href="#l20.3688"></a><span id="l20.3688" class="difflineminus">-    }</span>
<a href="#l20.3689"></a><span id="l20.3689" class="difflineminus">-    else</span>
<a href="#l20.3690"></a><span id="l20.3690" class="difflineminus">-    {</span>
<a href="#l20.3691"></a><span id="l20.3691" class="difflineplus">+      currentEOL = PL_strstr(currentLine, MSG_LINEBREAK);</span>
<a href="#l20.3692"></a><span id="l20.3692" class="difflineplus">+    } else {</span>
<a href="#l20.3693"></a><span id="l20.3693">       m_msgParser-&gt;ParseAFolderLine(currentLine, PL_strlen(currentLine));</span>
<a href="#l20.3694"></a><span id="l20.3694">       currentLine = str + len + 1;</span>
<a href="#l20.3695"></a><span id="l20.3695">     }</span>
<a href="#l20.3696"></a><span id="l20.3696">   }</span>
<a href="#l20.3697"></a><span id="l20.3697">   return NS_OK;</span>
<a href="#l20.3698"></a><span id="l20.3698"> }</span>
<a href="#l20.3699"></a><span id="l20.3699"> </span>
<a href="#l20.3700"></a><span id="l20.3700" class="difflineminus">-nsresult nsImapMailFolder::NormalEndHeaderParseStream(nsIImapProtocol *aProtocol, nsIImapUrl* imapUrl)</span>
<a href="#l20.3701"></a><span id="l20.3701" class="difflineminus">-{</span>
<a href="#l20.3702"></a><span id="l20.3702" class="difflineplus">+nsresult nsImapMailFolder::NormalEndHeaderParseStream(</span>
<a href="#l20.3703"></a><span id="l20.3703" class="difflineplus">+    nsIImapProtocol *aProtocol, nsIImapUrl *imapUrl) {</span>
<a href="#l20.3704"></a><span id="l20.3704">   nsCOMPtr&lt;nsIMsgDBHdr&gt; newMsgHdr;</span>
<a href="#l20.3705"></a><span id="l20.3705">   nsresult rv;</span>
<a href="#l20.3706"></a><span id="l20.3706">   NS_ENSURE_TRUE(m_msgParser, NS_ERROR_NULL_POINTER);</span>
<a href="#l20.3707"></a><span id="l20.3707"> </span>
<a href="#l20.3708"></a><span id="l20.3708">   nsMailboxParseState parseState;</span>
<a href="#l20.3709"></a><span id="l20.3709">   m_msgParser-&gt;GetState(&amp;parseState);</span>
<a href="#l20.3710"></a><span id="l20.3710">   if (parseState == nsIMsgParseMailMsgState::ParseHeadersState)</span>
<a href="#l20.3711"></a><span id="l20.3711">     m_msgParser-&gt;ParseAFolderLine(CRLF, 2);</span>
<a href="#l20.3712"></a><span id="l20.3712">   rv = m_msgParser-&gt;GetNewMsgHdr(getter_AddRefs(newMsgHdr));</span>
<a href="#l20.3713"></a><span id="l20.3713">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3714"></a><span id="l20.3714"> </span>
<a href="#l20.3715"></a><span id="l20.3715">   char *headers;</span>
<a href="#l20.3716"></a><span id="l20.3716">   int32_t headersSize;</span>
<a href="#l20.3717"></a><span id="l20.3717"> </span>
<a href="#l20.3718"></a><span id="l20.3718" class="difflineminus">-  nsCOMPtr &lt;nsIMsgWindow&gt; msgWindow;</span>
<a href="#l20.3719"></a><span id="l20.3719" class="difflineminus">-  nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; msgUrl;</span>
<a href="#l20.3720"></a><span id="l20.3720" class="difflineminus">-  if (imapUrl)</span>
<a href="#l20.3721"></a><span id="l20.3721" class="difflineminus">-  {</span>
<a href="#l20.3722"></a><span id="l20.3722" class="difflineplus">+  nsCOMPtr&lt;nsIMsgWindow&gt; msgWindow;</span>
<a href="#l20.3723"></a><span id="l20.3723" class="difflineplus">+  nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; msgUrl;</span>
<a href="#l20.3724"></a><span id="l20.3724" class="difflineplus">+  if (imapUrl) {</span>
<a href="#l20.3725"></a><span id="l20.3725">     msgUrl = do_QueryInterface(imapUrl, &amp;rv);</span>
<a href="#l20.3726"></a><span id="l20.3726">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3727"></a><span id="l20.3727">     msgUrl-&gt;GetMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l20.3728"></a><span id="l20.3728">   }</span>
<a href="#l20.3729"></a><span id="l20.3729"> </span>
<a href="#l20.3730"></a><span id="l20.3730">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.3731"></a><span id="l20.3731">   rv = GetServer(getter_AddRefs(server));</span>
<a href="#l20.3732"></a><span id="l20.3732">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.3733"></a><span id="l20.3733" class="difflineat">@@ -3012,389 +2786,366 @@ nsresult nsImapMailFolder::NormalEndHead</span>
<a href="#l20.3734"></a><span id="l20.3734">   TweakHeaderFlags(aProtocol, newMsgHdr);</span>
<a href="#l20.3735"></a><span id="l20.3735">   uint32_t messageSize;</span>
<a href="#l20.3736"></a><span id="l20.3736">   if (NS_SUCCEEDED(newMsgHdr-&gt;GetMessageSize(&amp;messageSize)))</span>
<a href="#l20.3737"></a><span id="l20.3737">     mFolderSize += messageSize;</span>
<a href="#l20.3738"></a><span id="l20.3738">   m_msgMovedByFilter = false;</span>
<a href="#l20.3739"></a><span id="l20.3739"> </span>
<a href="#l20.3740"></a><span id="l20.3740">   nsMsgKey highestUID = 0;</span>
<a href="#l20.3741"></a><span id="l20.3741">   nsCOMPtr&lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l20.3742"></a><span id="l20.3742" class="difflineminus">-  if (mDatabase)</span>
<a href="#l20.3743"></a><span id="l20.3743" class="difflineminus">-    mDatabase-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l20.3744"></a><span id="l20.3744" class="difflineplus">+  if (mDatabase) mDatabase-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l20.3745"></a><span id="l20.3745">   if (dbFolderInfo)</span>
<a href="#l20.3746"></a><span id="l20.3746" class="difflineminus">-    dbFolderInfo-&gt;GetUint32Property(kHighestRecordedUIDPropertyName, 0, &amp;highestUID);</span>
<a href="#l20.3747"></a><span id="l20.3747" class="difflineplus">+    dbFolderInfo-&gt;GetUint32Property(kHighestRecordedUIDPropertyName, 0,</span>
<a href="#l20.3748"></a><span id="l20.3748" class="difflineplus">+                                    &amp;highestUID);</span>
<a href="#l20.3749"></a><span id="l20.3749"> </span>
<a href="#l20.3750"></a><span id="l20.3750">   // If this is the inbox, try to apply filters. Otherwise, test the inherited</span>
<a href="#l20.3751"></a><span id="l20.3751">   // folder property &quot;applyIncomingFilters&quot; (which defaults to empty). If this</span>
<a href="#l20.3752"></a><span id="l20.3752">   // inherited property has the string value &quot;true&quot;, then apply filters even</span>
<a href="#l20.3753"></a><span id="l20.3753">   // if this is not the Inbox folder.</span>
<a href="#l20.3754"></a><span id="l20.3754" class="difflineminus">-  if (mFlags &amp; nsMsgFolderFlags::Inbox || m_applyIncomingFilters)</span>
<a href="#l20.3755"></a><span id="l20.3755" class="difflineminus">-  {</span>
<a href="#l20.3756"></a><span id="l20.3756" class="difflineplus">+  if (mFlags &amp; nsMsgFolderFlags::Inbox || m_applyIncomingFilters) {</span>
<a href="#l20.3757"></a><span id="l20.3757">     // Use highwater to determine whether to filter?</span>
<a href="#l20.3758"></a><span id="l20.3758">     bool filterOnHighwater = false;</span>
<a href="#l20.3759"></a><span id="l20.3759" class="difflineminus">-    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID));</span>
<a href="#l20.3760"></a><span id="l20.3760" class="difflineplus">+    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(</span>
<a href="#l20.3761"></a><span id="l20.3761" class="difflineplus">+        do_GetService(NS_PREFSERVICE_CONTRACTID));</span>
<a href="#l20.3762"></a><span id="l20.3762">     if (prefBranch)</span>
<a href="#l20.3763"></a><span id="l20.3763">       prefBranch-&gt;GetBoolPref(&quot;mail.imap.filter_on_new&quot;, &amp;filterOnHighwater);</span>
<a href="#l20.3764"></a><span id="l20.3764"> </span>
<a href="#l20.3765"></a><span id="l20.3765">     uint32_t msgFlags;</span>
<a href="#l20.3766"></a><span id="l20.3766">     newMsgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l20.3767"></a><span id="l20.3767"> </span>
<a href="#l20.3768"></a><span id="l20.3768" class="difflineminus">-    bool doFilter = filterOnHighwater ?</span>
<a href="#l20.3769"></a><span id="l20.3769" class="difflineplus">+    // clang-format off</span>
<a href="#l20.3770"></a><span id="l20.3770" class="difflineplus">+    bool doFilter = filterOnHighwater</span>
<a href="#l20.3771"></a><span id="l20.3771">       // Filter on largest UUID and not deleted.</span>
<a href="#l20.3772"></a><span id="l20.3772" class="difflineminus">-      m_curMsgUid &gt; highestUID &amp;&amp; !(msgFlags &amp; nsMsgMessageFlags::IMAPDeleted) :</span>
<a href="#l20.3773"></a><span id="l20.3773" class="difflineplus">+      ? m_curMsgUid &gt; highestUID &amp;&amp; !(msgFlags &amp; nsMsgMessageFlags::IMAPDeleted)</span>
<a href="#l20.3774"></a><span id="l20.3774">       // Filter on unread and not deleted.</span>
<a href="#l20.3775"></a><span id="l20.3775" class="difflineminus">-      !(msgFlags &amp; (nsMsgMessageFlags::Read | nsMsgMessageFlags::IMAPDeleted));</span>
<a href="#l20.3776"></a><span id="l20.3776" class="difflineminus">-</span>
<a href="#l20.3777"></a><span id="l20.3777" class="difflineminus">-    if (doFilter)</span>
<a href="#l20.3778"></a><span id="l20.3778" class="difflineminus">-      MOZ_LOG(FILTERLOGMODULE, LogLevel::Info, (&quot;(Imap) New message parsed, and filters will be run on it&quot;));</span>
<a href="#l20.3779"></a><span id="l20.3779" class="difflineminus">-    else</span>
<a href="#l20.3780"></a><span id="l20.3780" class="difflineminus">-      MOZ_LOG(FILTERLOGMODULE, LogLevel::Info, (&quot;(Imap) New message parsed, but filters will not be run on it&quot;));</span>
<a href="#l20.3781"></a><span id="l20.3781" class="difflineplus">+      : !(msgFlags &amp; (nsMsgMessageFlags::Read | nsMsgMessageFlags::IMAPDeleted));</span>
<a href="#l20.3782"></a><span id="l20.3782" class="difflineplus">+    // clang-format on</span>
<a href="#l20.3783"></a><span id="l20.3783"> </span>
<a href="#l20.3784"></a><span id="l20.3784">     if (doFilter)</span>
<a href="#l20.3785"></a><span id="l20.3785" class="difflineminus">-    {</span>
<a href="#l20.3786"></a><span id="l20.3786" class="difflineplus">+      MOZ_LOG(FILTERLOGMODULE, LogLevel::Info,</span>
<a href="#l20.3787"></a><span id="l20.3787" class="difflineplus">+              (&quot;(Imap) New message parsed, and filters will be run on it&quot;));</span>
<a href="#l20.3788"></a><span id="l20.3788" class="difflineplus">+    else</span>
<a href="#l20.3789"></a><span id="l20.3789" class="difflineplus">+      MOZ_LOG(FILTERLOGMODULE, LogLevel::Info,</span>
<a href="#l20.3790"></a><span id="l20.3790" class="difflineplus">+              (&quot;(Imap) New message parsed, but filters will not be run on it&quot;));</span>
<a href="#l20.3791"></a><span id="l20.3791" class="difflineplus">+</span>
<a href="#l20.3792"></a><span id="l20.3792" class="difflineplus">+    if (doFilter) {</span>
<a href="#l20.3793"></a><span id="l20.3793">       int32_t duplicateAction = nsIMsgIncomingServer::keepDups;</span>
<a href="#l20.3794"></a><span id="l20.3794" class="difflineminus">-      if (server)</span>
<a href="#l20.3795"></a><span id="l20.3795" class="difflineminus">-        server-&gt;GetIncomingDuplicateAction(&amp;duplicateAction);</span>
<a href="#l20.3796"></a><span id="l20.3796" class="difflineplus">+      if (server) server-&gt;GetIncomingDuplicateAction(&amp;duplicateAction);</span>
<a href="#l20.3797"></a><span id="l20.3797">       if ((duplicateAction != nsIMsgIncomingServer::keepDups) &amp;&amp;</span>
<a href="#l20.3798"></a><span id="l20.3798" class="difflineminus">-          mFlags &amp; nsMsgFolderFlags::Inbox)</span>
<a href="#l20.3799"></a><span id="l20.3799" class="difflineminus">-      {</span>
<a href="#l20.3800"></a><span id="l20.3800" class="difflineplus">+          mFlags &amp; nsMsgFolderFlags::Inbox) {</span>
<a href="#l20.3801"></a><span id="l20.3801">         bool isDup;</span>
<a href="#l20.3802"></a><span id="l20.3802">         server-&gt;IsNewHdrDuplicate(newMsgHdr, &amp;isDup);</span>
<a href="#l20.3803"></a><span id="l20.3803" class="difflineminus">-        if (isDup)</span>
<a href="#l20.3804"></a><span id="l20.3804" class="difflineminus">-        {</span>
<a href="#l20.3805"></a><span id="l20.3805" class="difflineplus">+        if (isDup) {</span>
<a href="#l20.3806"></a><span id="l20.3806">           // we want to do something similar to applying filter hits.</span>
<a href="#l20.3807"></a><span id="l20.3807">           // if a dup is marked read, it shouldn't trigger biff.</span>
<a href="#l20.3808"></a><span id="l20.3808">           // Same for deleting it or moving it to trash.</span>
<a href="#l20.3809"></a><span id="l20.3809" class="difflineminus">-          switch (duplicateAction)</span>
<a href="#l20.3810"></a><span id="l20.3810" class="difflineminus">-          {</span>
<a href="#l20.3811"></a><span id="l20.3811" class="difflineminus">-            case nsIMsgIncomingServer::deleteDups:</span>
<a href="#l20.3812"></a><span id="l20.3812" class="difflineminus">-              {</span>
<a href="#l20.3813"></a><span id="l20.3813" class="difflineminus">-                uint32_t newFlags;</span>
<a href="#l20.3814"></a><span id="l20.3814" class="difflineminus">-                newMsgHdr-&gt;OrFlags(nsMsgMessageFlags::Read | nsMsgMessageFlags::IMAPDeleted, &amp;newFlags);</span>
<a href="#l20.3815"></a><span id="l20.3815" class="difflineminus">-                StoreImapFlags(kImapMsgSeenFlag | kImapMsgDeletedFlag, true,</span>
<a href="#l20.3816"></a><span id="l20.3816" class="difflineminus">-                               &amp;m_curMsgUid, 1, nullptr);</span>
<a href="#l20.3817"></a><span id="l20.3817" class="difflineminus">-                m_msgMovedByFilter = true;</span>
<a href="#l20.3818"></a><span id="l20.3818" class="difflineplus">+          switch (duplicateAction) {</span>
<a href="#l20.3819"></a><span id="l20.3819" class="difflineplus">+            case nsIMsgIncomingServer::deleteDups: {</span>
<a href="#l20.3820"></a><span id="l20.3820" class="difflineplus">+              uint32_t newFlags;</span>
<a href="#l20.3821"></a><span id="l20.3821" class="difflineplus">+              newMsgHdr-&gt;OrFlags(</span>
<a href="#l20.3822"></a><span id="l20.3822" class="difflineplus">+                  nsMsgMessageFlags::Read | nsMsgMessageFlags::IMAPDeleted,</span>
<a href="#l20.3823"></a><span id="l20.3823" class="difflineplus">+                  &amp;newFlags);</span>
<a href="#l20.3824"></a><span id="l20.3824" class="difflineplus">+              StoreImapFlags(kImapMsgSeenFlag | kImapMsgDeletedFlag, true,</span>
<a href="#l20.3825"></a><span id="l20.3825" class="difflineplus">+                             &amp;m_curMsgUid, 1, nullptr);</span>
<a href="#l20.3826"></a><span id="l20.3826" class="difflineplus">+              m_msgMovedByFilter = true;</span>
<a href="#l20.3827"></a><span id="l20.3827" class="difflineplus">+            } break;</span>
<a href="#l20.3828"></a><span id="l20.3828" class="difflineplus">+            case nsIMsgIncomingServer::moveDupsToTrash: {</span>
<a href="#l20.3829"></a><span id="l20.3829" class="difflineplus">+              nsCOMPtr&lt;nsIMsgFolder&gt; trash;</span>
<a href="#l20.3830"></a><span id="l20.3830" class="difflineplus">+              GetTrashFolder(getter_AddRefs(trash));</span>
<a href="#l20.3831"></a><span id="l20.3831" class="difflineplus">+              if (trash) {</span>
<a href="#l20.3832"></a><span id="l20.3832" class="difflineplus">+                nsCString trashUri;</span>
<a href="#l20.3833"></a><span id="l20.3833" class="difflineplus">+                trash-&gt;GetURI(trashUri);</span>
<a href="#l20.3834"></a><span id="l20.3834" class="difflineplus">+                nsresult err = MoveIncorporatedMessage(</span>
<a href="#l20.3835"></a><span id="l20.3835" class="difflineplus">+                    newMsgHdr, mDatabase, trashUri, nullptr, msgWindow);</span>
<a href="#l20.3836"></a><span id="l20.3836" class="difflineplus">+                if (NS_SUCCEEDED(err)) m_msgMovedByFilter = true;</span>
<a href="#l20.3837"></a><span id="l20.3837">               }</span>
<a href="#l20.3838"></a><span id="l20.3838" class="difflineminus">-              break;</span>
<a href="#l20.3839"></a><span id="l20.3839" class="difflineminus">-            case nsIMsgIncomingServer::moveDupsToTrash:</span>
<a href="#l20.3840"></a><span id="l20.3840" class="difflineminus">-              {</span>
<a href="#l20.3841"></a><span id="l20.3841" class="difflineminus">-                nsCOMPtr &lt;nsIMsgFolder&gt; trash;</span>
<a href="#l20.3842"></a><span id="l20.3842" class="difflineminus">-                GetTrashFolder(getter_AddRefs(trash));</span>
<a href="#l20.3843"></a><span id="l20.3843" class="difflineminus">-                if (trash)</span>
<a href="#l20.3844"></a><span id="l20.3844" class="difflineminus">-                {</span>
<a href="#l20.3845"></a><span id="l20.3845" class="difflineminus">-                  nsCString trashUri;</span>
<a href="#l20.3846"></a><span id="l20.3846" class="difflineminus">-                  trash-&gt;GetURI(trashUri);</span>
<a href="#l20.3847"></a><span id="l20.3847" class="difflineminus">-                  nsresult err = MoveIncorporatedMessage(newMsgHdr, mDatabase, trashUri, nullptr, msgWindow);</span>
<a href="#l20.3848"></a><span id="l20.3848" class="difflineminus">-                  if (NS_SUCCEEDED(err))</span>
<a href="#l20.3849"></a><span id="l20.3849" class="difflineminus">-                    m_msgMovedByFilter = true;</span>
<a href="#l20.3850"></a><span id="l20.3850" class="difflineminus">-                }</span>
<a href="#l20.3851"></a><span id="l20.3851" class="difflineminus">-              }</span>
<a href="#l20.3852"></a><span id="l20.3852" class="difflineminus">-              break;</span>
<a href="#l20.3853"></a><span id="l20.3853" class="difflineminus">-            case nsIMsgIncomingServer::markDupsRead:</span>
<a href="#l20.3854"></a><span id="l20.3854" class="difflineminus">-              {</span>
<a href="#l20.3855"></a><span id="l20.3855" class="difflineminus">-                uint32_t newFlags;</span>
<a href="#l20.3856"></a><span id="l20.3856" class="difflineminus">-                newMsgHdr-&gt;OrFlags(nsMsgMessageFlags::Read, &amp;newFlags);</span>
<a href="#l20.3857"></a><span id="l20.3857" class="difflineminus">-                StoreImapFlags(kImapMsgSeenFlag, true, &amp;m_curMsgUid, 1, nullptr);</span>
<a href="#l20.3858"></a><span id="l20.3858" class="difflineminus">-              }</span>
<a href="#l20.3859"></a><span id="l20.3859" class="difflineminus">-              break;</span>
<a href="#l20.3860"></a><span id="l20.3860" class="difflineplus">+            } break;</span>
<a href="#l20.3861"></a><span id="l20.3861" class="difflineplus">+            case nsIMsgIncomingServer::markDupsRead: {</span>
<a href="#l20.3862"></a><span id="l20.3862" class="difflineplus">+              uint32_t newFlags;</span>
<a href="#l20.3863"></a><span id="l20.3863" class="difflineplus">+              newMsgHdr-&gt;OrFlags(nsMsgMessageFlags::Read, &amp;newFlags);</span>
<a href="#l20.3864"></a><span id="l20.3864" class="difflineplus">+              StoreImapFlags(kImapMsgSeenFlag, true, &amp;m_curMsgUid, 1, nullptr);</span>
<a href="#l20.3865"></a><span id="l20.3865" class="difflineplus">+            } break;</span>
<a href="#l20.3866"></a><span id="l20.3866">           }</span>
<a href="#l20.3867"></a><span id="l20.3867">           int32_t numNewMessages;</span>
<a href="#l20.3868"></a><span id="l20.3868">           GetNumNewMessages(false, &amp;numNewMessages);</span>
<a href="#l20.3869"></a><span id="l20.3869">           SetNumNewMessages(numNewMessages - 1);</span>
<a href="#l20.3870"></a><span id="l20.3870">         }</span>
<a href="#l20.3871"></a><span id="l20.3871">       }</span>
<a href="#l20.3872"></a><span id="l20.3872">       rv = m_msgParser-&gt;GetAllHeaders(&amp;headers, &amp;headersSize);</span>
<a href="#l20.3873"></a><span id="l20.3873"> </span>
<a href="#l20.3874"></a><span id="l20.3874">       if (NS_SUCCEEDED(rv) &amp;&amp; headers &amp;&amp; !m_msgMovedByFilter &amp;&amp;</span>
<a href="#l20.3875"></a><span id="l20.3875" class="difflineminus">-          !m_filterListRequiresBody)</span>
<a href="#l20.3876"></a><span id="l20.3876" class="difflineminus">-      {</span>
<a href="#l20.3877"></a><span id="l20.3877" class="difflineminus">-        if (m_filterList)</span>
<a href="#l20.3878"></a><span id="l20.3878" class="difflineminus">-        {</span>
<a href="#l20.3879"></a><span id="l20.3879" class="difflineplus">+          !m_filterListRequiresBody) {</span>
<a href="#l20.3880"></a><span id="l20.3880" class="difflineplus">+        if (m_filterList) {</span>
<a href="#l20.3881"></a><span id="l20.3881">           GetMoveCoalescer();  // not sure why we're doing this here.</span>
<a href="#l20.3882"></a><span id="l20.3882">           MOZ_LOG(FILTERLOGMODULE, LogLevel::Debug,</span>
<a href="#l20.3883"></a><span id="l20.3883" class="difflineminus">-                  (&quot;(Imap) ApplyFilterToHdr from nsImapMailFolder::NormalEndHeaderParseStream()&quot;));</span>
<a href="#l20.3884"></a><span id="l20.3884" class="difflineminus">-          m_filterList-&gt;ApplyFiltersToHdr(nsMsgFilterType::InboxRule, newMsgHdr,</span>
<a href="#l20.3885"></a><span id="l20.3885" class="difflineminus">-                                          this, mDatabase, nsDependentCSubstring(headers, headersSize),</span>
<a href="#l20.3886"></a><span id="l20.3886" class="difflineminus">-                                          this, msgWindow);</span>
<a href="#l20.3887"></a><span id="l20.3887" class="difflineplus">+                  (&quot;(Imap) ApplyFilterToHdr from &quot;</span>
<a href="#l20.3888"></a><span id="l20.3888" class="difflineplus">+                   &quot;nsImapMailFolder::NormalEndHeaderParseStream()&quot;));</span>
<a href="#l20.3889"></a><span id="l20.3889" class="difflineplus">+          m_filterList-&gt;ApplyFiltersToHdr(</span>
<a href="#l20.3890"></a><span id="l20.3890" class="difflineplus">+              nsMsgFilterType::InboxRule, newMsgHdr, this, mDatabase,</span>
<a href="#l20.3891"></a><span id="l20.3891" class="difflineplus">+              nsDependentCSubstring(headers, headersSize), this, msgWindow);</span>
<a href="#l20.3892"></a><span id="l20.3892">           NotifyFolderEvent(kFiltersApplied);</span>
<a href="#l20.3893"></a><span id="l20.3893">         }</span>
<a href="#l20.3894"></a><span id="l20.3894">       }</span>
<a href="#l20.3895"></a><span id="l20.3895">     }</span>
<a href="#l20.3896"></a><span id="l20.3896">   }</span>
<a href="#l20.3897"></a><span id="l20.3897">   // here we need to tweak flags from uid state..</span>
<a href="#l20.3898"></a><span id="l20.3898" class="difflineminus">-  if (mDatabase &amp;&amp; (!m_msgMovedByFilter || ShowDeletedMessages()))</span>
<a href="#l20.3899"></a><span id="l20.3899" class="difflineminus">-  {</span>
<a href="#l20.3900"></a><span id="l20.3900" class="difflineminus">-    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.3901"></a><span id="l20.3901" class="difflineplus">+  if (mDatabase &amp;&amp; (!m_msgMovedByFilter || ShowDeletedMessages())) {</span>
<a href="#l20.3902"></a><span id="l20.3902" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(</span>
<a href="#l20.3903"></a><span id="l20.3903" class="difflineplus">+        do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.3904"></a><span id="l20.3904">     // Check if this header corresponds to a pseudo header</span>
<a href="#l20.3905"></a><span id="l20.3905">     // we have from doing a pseudo-offline move and then downloading</span>
<a href="#l20.3906"></a><span id="l20.3906">     // the real header from the server. In that case, we notify</span>
<a href="#l20.3907"></a><span id="l20.3907">     // db/folder listeners that the pseudo-header has become the new</span>
<a href="#l20.3908"></a><span id="l20.3908">     // header, i.e., the key has changed.</span>
<a href="#l20.3909"></a><span id="l20.3909">     nsCString newMessageId;</span>
<a href="#l20.3910"></a><span id="l20.3910">     nsMsgKey pseudoKey = nsMsgKey_None;</span>
<a href="#l20.3911"></a><span id="l20.3911">     newMsgHdr-&gt;GetMessageId(getter_Copies(newMessageId));</span>
<a href="#l20.3912"></a><span id="l20.3912">     m_pseudoHdrs.Get(newMessageId, &amp;pseudoKey);</span>
<a href="#l20.3913"></a><span id="l20.3913" class="difflineminus">-    if (notifier &amp;&amp; pseudoKey != nsMsgKey_None)</span>
<a href="#l20.3914"></a><span id="l20.3914" class="difflineminus">-    {</span>
<a href="#l20.3915"></a><span id="l20.3915" class="difflineplus">+    if (notifier &amp;&amp; pseudoKey != nsMsgKey_None) {</span>
<a href="#l20.3916"></a><span id="l20.3916">       notifier-&gt;NotifyMsgKeyChanged(pseudoKey, newMsgHdr);</span>
<a href="#l20.3917"></a><span id="l20.3917">       m_pseudoHdrs.Remove(newMessageId);</span>
<a href="#l20.3918"></a><span id="l20.3918">     }</span>
<a href="#l20.3919"></a><span id="l20.3919">     mDatabase-&gt;AddNewHdrToDB(newMsgHdr, true);</span>
<a href="#l20.3920"></a><span id="l20.3920" class="difflineminus">-    if (notifier)</span>
<a href="#l20.3921"></a><span id="l20.3921" class="difflineminus">-      notifier-&gt;NotifyMsgAdded(newMsgHdr);</span>
<a href="#l20.3922"></a><span id="l20.3922" class="difflineplus">+    if (notifier) notifier-&gt;NotifyMsgAdded(newMsgHdr);</span>
<a href="#l20.3923"></a><span id="l20.3923">     // mark the header as not yet reported classified</span>
<a href="#l20.3924"></a><span id="l20.3924">     OrProcessingFlags(m_curMsgUid, nsMsgProcessingFlags::NotReportedClassified);</span>
<a href="#l20.3925"></a><span id="l20.3925">   }</span>
<a href="#l20.3926"></a><span id="l20.3926">   // adjust highestRecordedUID</span>
<a href="#l20.3927"></a><span id="l20.3927" class="difflineminus">-  if (dbFolderInfo)</span>
<a href="#l20.3928"></a><span id="l20.3928" class="difflineminus">-  {</span>
<a href="#l20.3929"></a><span id="l20.3929" class="difflineminus">-    if (m_curMsgUid &gt; highestUID)</span>
<a href="#l20.3930"></a><span id="l20.3930" class="difflineminus">-    {</span>
<a href="#l20.3931"></a><span id="l20.3931" class="difflineplus">+  if (dbFolderInfo) {</span>
<a href="#l20.3932"></a><span id="l20.3932" class="difflineplus">+    if (m_curMsgUid &gt; highestUID) {</span>
<a href="#l20.3933"></a><span id="l20.3933">       MOZ_LOG(IMAP_CS, mozilla::LogLevel::Debug,</span>
<a href="#l20.3934"></a><span id="l20.3934" class="difflineminus">-              (&quot;NormalEndHeaderParseStream(): Store new highest UID=%&quot; PRIu32 &quot; for folder=%s&quot;,</span>
<a href="#l20.3935"></a><span id="l20.3935" class="difflineplus">+              (&quot;NormalEndHeaderParseStream(): Store new highest UID=%&quot; PRIu32</span>
<a href="#l20.3936"></a><span id="l20.3936" class="difflineplus">+               &quot; for folder=%s&quot;,</span>
<a href="#l20.3937"></a><span id="l20.3937">                m_curMsgUid, m_onlineFolderName.get()));</span>
<a href="#l20.3938"></a><span id="l20.3938" class="difflineminus">-      dbFolderInfo-&gt;SetUint32Property(kHighestRecordedUIDPropertyName, m_curMsgUid);</span>
<a href="#l20.3939"></a><span id="l20.3939" class="difflineminus">-    }</span>
<a href="#l20.3940"></a><span id="l20.3940" class="difflineminus">-  }</span>
<a href="#l20.3941"></a><span id="l20.3941" class="difflineminus">-</span>
<a href="#l20.3942"></a><span id="l20.3942" class="difflineminus">-  if (m_isGmailServer)</span>
<a href="#l20.3943"></a><span id="l20.3943" class="difflineminus">-  {</span>
<a href="#l20.3944"></a><span id="l20.3944" class="difflineplus">+      dbFolderInfo-&gt;SetUint32Property(kHighestRecordedUIDPropertyName,</span>
<a href="#l20.3945"></a><span id="l20.3945" class="difflineplus">+                                      m_curMsgUid);</span>
<a href="#l20.3946"></a><span id="l20.3946" class="difflineplus">+    }</span>
<a href="#l20.3947"></a><span id="l20.3947" class="difflineplus">+  }</span>
<a href="#l20.3948"></a><span id="l20.3948" class="difflineplus">+</span>
<a href="#l20.3949"></a><span id="l20.3949" class="difflineplus">+  if (m_isGmailServer) {</span>
<a href="#l20.3950"></a><span id="l20.3950">     nsCOMPtr&lt;nsIImapFlagAndUidState&gt; flagState;</span>
<a href="#l20.3951"></a><span id="l20.3951">     aProtocol-&gt;GetFlagAndUidState(getter_AddRefs(flagState));</span>
<a href="#l20.3952"></a><span id="l20.3952">     nsCString msgIDValue;</span>
<a href="#l20.3953"></a><span id="l20.3953">     nsCString threadIDValue;</span>
<a href="#l20.3954"></a><span id="l20.3954">     nsCString labelsValue;</span>
<a href="#l20.3955"></a><span id="l20.3955" class="difflineminus">-    flagState-&gt;GetCustomAttribute(m_curMsgUid, NS_LITERAL_CSTRING(&quot;X-GM-MSGID&quot;), msgIDValue);</span>
<a href="#l20.3956"></a><span id="l20.3956" class="difflineminus">-    flagState-&gt;GetCustomAttribute(m_curMsgUid, NS_LITERAL_CSTRING(&quot;X-GM-THRID&quot;), threadIDValue);</span>
<a href="#l20.3957"></a><span id="l20.3957" class="difflineminus">-    flagState-&gt;GetCustomAttribute(m_curMsgUid, NS_LITERAL_CSTRING(&quot;X-GM-LABELS&quot;), labelsValue);</span>
<a href="#l20.3958"></a><span id="l20.3958" class="difflineplus">+    flagState-&gt;GetCustomAttribute(m_curMsgUid, NS_LITERAL_CSTRING(&quot;X-GM-MSGID&quot;),</span>
<a href="#l20.3959"></a><span id="l20.3959" class="difflineplus">+                                  msgIDValue);</span>
<a href="#l20.3960"></a><span id="l20.3960" class="difflineplus">+    flagState-&gt;GetCustomAttribute(m_curMsgUid, NS_LITERAL_CSTRING(&quot;X-GM-THRID&quot;),</span>
<a href="#l20.3961"></a><span id="l20.3961" class="difflineplus">+                                  threadIDValue);</span>
<a href="#l20.3962"></a><span id="l20.3962" class="difflineplus">+    flagState-&gt;GetCustomAttribute(</span>
<a href="#l20.3963"></a><span id="l20.3963" class="difflineplus">+        m_curMsgUid, NS_LITERAL_CSTRING(&quot;X-GM-LABELS&quot;), labelsValue);</span>
<a href="#l20.3964"></a><span id="l20.3964">     newMsgHdr-&gt;SetStringProperty(&quot;X-GM-MSGID&quot;, msgIDValue.get());</span>
<a href="#l20.3965"></a><span id="l20.3965">     newMsgHdr-&gt;SetStringProperty(&quot;X-GM-THRID&quot;, threadIDValue.get());</span>
<a href="#l20.3966"></a><span id="l20.3966">     newMsgHdr-&gt;SetStringProperty(&quot;X-GM-LABELS&quot;, labelsValue.get());</span>
<a href="#l20.3967"></a><span id="l20.3967">   }</span>
<a href="#l20.3968"></a><span id="l20.3968"> </span>
<a href="#l20.3969"></a><span id="l20.3969" class="difflineminus">-  m_msgParser-&gt;Clear(); // clear out parser, because it holds onto a msg hdr.</span>
<a href="#l20.3970"></a><span id="l20.3970" class="difflineminus">-  m_msgParser-&gt;SetMailDB(nullptr); // tell it to let go of the db too.</span>
<a href="#l20.3971"></a><span id="l20.3971" class="difflineminus">-  // I don't think we want to do this - it does bad things like set the size incorrectly.</span>
<a href="#l20.3972"></a><span id="l20.3972" class="difflineplus">+  m_msgParser-&gt;Clear();  // clear out parser, because it holds onto a msg hdr.</span>
<a href="#l20.3973"></a><span id="l20.3973" class="difflineplus">+  m_msgParser-&gt;SetMailDB(nullptr);  // tell it to let go of the db too.</span>
<a href="#l20.3974"></a><span id="l20.3974" class="difflineplus">+  // I don't think we want to do this - it does bad things like set the size</span>
<a href="#l20.3975"></a><span id="l20.3975" class="difflineplus">+  // incorrectly.</span>
<a href="#l20.3976"></a><span id="l20.3976">   //    m_msgParser-&gt;FinishHeader();</span>
<a href="#l20.3977"></a><span id="l20.3977" class="difflineminus">-    return NS_OK;</span>
<a href="#l20.3978"></a><span id="l20.3978" class="difflineminus">-}</span>
<a href="#l20.3979"></a><span id="l20.3979" class="difflineminus">-</span>
<a href="#l20.3980"></a><span id="l20.3980" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::AbortHeaderParseStream(nsIImapProtocol* aProtocol)</span>
<a href="#l20.3981"></a><span id="l20.3981" class="difflineminus">-{</span>
<a href="#l20.3982"></a><span id="l20.3982" class="difflineplus">+  return NS_OK;</span>
<a href="#l20.3983"></a><span id="l20.3983" class="difflineplus">+}</span>
<a href="#l20.3984"></a><span id="l20.3984" class="difflineplus">+</span>
<a href="#l20.3985"></a><span id="l20.3985" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::AbortHeaderParseStream(</span>
<a href="#l20.3986"></a><span id="l20.3986" class="difflineplus">+    nsIImapProtocol *aProtocol) {</span>
<a href="#l20.3987"></a><span id="l20.3987">   nsresult rv = NS_ERROR_FAILURE;</span>
<a href="#l20.3988"></a><span id="l20.3988">   return rv;</span>
<a href="#l20.3989"></a><span id="l20.3989"> }</span>
<a href="#l20.3990"></a><span id="l20.3990"> </span>
<a href="#l20.3991"></a><span id="l20.3991" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::BeginCopy(nsIMsgDBHdr *message)</span>
<a href="#l20.3992"></a><span id="l20.3992" class="difflineminus">-{</span>
<a href="#l20.3993"></a><span id="l20.3993" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::BeginCopy(nsIMsgDBHdr *message) {</span>
<a href="#l20.3994"></a><span id="l20.3994">   NS_ENSURE_TRUE(m_copyState, NS_ERROR_NULL_POINTER);</span>
<a href="#l20.3995"></a><span id="l20.3995">   nsresult rv;</span>
<a href="#l20.3996"></a><span id="l20.3996" class="difflineminus">-  if (m_copyState-&gt;m_tmpFile) // leftover file spec nuke it</span>
<a href="#l20.3997"></a><span id="l20.3997" class="difflineplus">+  if (m_copyState-&gt;m_tmpFile)  // leftover file spec nuke it</span>
<a href="#l20.3998"></a><span id="l20.3998">   {</span>
<a href="#l20.3999"></a><span id="l20.3999">     rv = m_copyState-&gt;m_tmpFile-&gt;Remove(false);</span>
<a href="#l20.4000"></a><span id="l20.4000" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l20.4001"></a><span id="l20.4001" class="difflineminus">-    {</span>
<a href="#l20.4002"></a><span id="l20.4002" class="difflineplus">+    if (NS_FAILED(rv)) {</span>
<a href="#l20.4003"></a><span id="l20.4003">       nsCString nativePath = m_copyState-&gt;m_tmpFile-&gt;HumanReadablePath();</span>
<a href="#l20.4004"></a><span id="l20.4004">       MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l20.4005"></a><span id="l20.4005" class="difflineminus">-        (&quot;couldn't remove prev temp file %s: %&quot; PRIx32, nativePath.get(), static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.4006"></a><span id="l20.4006" class="difflineplus">+              (&quot;couldn't remove prev temp file %s: %&quot; PRIx32, nativePath.get(),</span>
<a href="#l20.4007"></a><span id="l20.4007" class="difflineplus">+               static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.4008"></a><span id="l20.4008">     }</span>
<a href="#l20.4009"></a><span id="l20.4009">     m_copyState-&gt;m_tmpFile = nullptr;</span>
<a href="#l20.4010"></a><span id="l20.4010">   }</span>
<a href="#l20.4011"></a><span id="l20.4011" class="difflineminus">-  if (message)</span>
<a href="#l20.4012"></a><span id="l20.4012" class="difflineminus">-    m_copyState-&gt;m_message = message;</span>
<a href="#l20.4013"></a><span id="l20.4013" class="difflineminus">-</span>
<a href="#l20.4014"></a><span id="l20.4014" class="difflineminus">-  rv = GetSpecialDirectoryWithFileName(NS_OS_TEMP_DIR,</span>
<a href="#l20.4015"></a><span id="l20.4015" class="difflineminus">-                                       &quot;nscpmsg.txt&quot;,</span>
<a href="#l20.4016"></a><span id="l20.4016" class="difflineminus">-                                        getter_AddRefs(m_copyState-&gt;m_tmpFile));</span>
<a href="#l20.4017"></a><span id="l20.4017" class="difflineplus">+  if (message) m_copyState-&gt;m_message = message;</span>
<a href="#l20.4018"></a><span id="l20.4018" class="difflineplus">+</span>
<a href="#l20.4019"></a><span id="l20.4019" class="difflineplus">+  rv = GetSpecialDirectoryWithFileName(NS_OS_TEMP_DIR, &quot;nscpmsg.txt&quot;,</span>
<a href="#l20.4020"></a><span id="l20.4020" class="difflineplus">+                                       getter_AddRefs(m_copyState-&gt;m_tmpFile));</span>
<a href="#l20.4021"></a><span id="l20.4021">   if (NS_FAILED(rv))</span>
<a href="#l20.4022"></a><span id="l20.4022" class="difflineminus">-    MOZ_LOG(IMAP, mozilla::LogLevel::Info, (&quot;couldn't find nscpmsg.txt:%&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.4023"></a><span id="l20.4023" class="difflineplus">+    MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l20.4024"></a><span id="l20.4024" class="difflineplus">+            (&quot;couldn't find nscpmsg.txt:%&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.4025"></a><span id="l20.4025">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4026"></a><span id="l20.4026"> </span>
<a href="#l20.4027"></a><span id="l20.4027">   // create a unique file, since multiple copies may be open on multiple folders</span>
<a href="#l20.4028"></a><span id="l20.4028">   rv = m_copyState-&gt;m_tmpFile-&gt;CreateUnique(nsIFile::NORMAL_FILE_TYPE, 00600);</span>
<a href="#l20.4029"></a><span id="l20.4029" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l20.4030"></a><span id="l20.4030" class="difflineminus">-  {</span>
<a href="#l20.4031"></a><span id="l20.4031" class="difflineminus">-    MOZ_LOG(IMAP, mozilla::LogLevel::Info, (&quot;couldn't create temp nscpmsg.txt:%&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.4032"></a><span id="l20.4032" class="difflineplus">+  if (NS_FAILED(rv)) {</span>
<a href="#l20.4033"></a><span id="l20.4033" class="difflineplus">+    MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l20.4034"></a><span id="l20.4034" class="difflineplus">+            (&quot;couldn't create temp nscpmsg.txt:%&quot; PRIx32,</span>
<a href="#l20.4035"></a><span id="l20.4035" class="difflineplus">+             static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.4036"></a><span id="l20.4036">     // Last ditch attempt to create a temp file, because virus checker might</span>
<a href="#l20.4037"></a><span id="l20.4037">     // be locking the previous temp file, and CreateUnique fails if the file</span>
<a href="#l20.4038"></a><span id="l20.4038">     // is locked. Use the message key to make a unique name.</span>
<a href="#l20.4039"></a><span id="l20.4039" class="difflineminus">-    if (message)</span>
<a href="#l20.4040"></a><span id="l20.4040" class="difflineminus">-    {</span>
<a href="#l20.4041"></a><span id="l20.4041" class="difflineplus">+    if (message) {</span>
<a href="#l20.4042"></a><span id="l20.4042">       nsCString tmpFileName(&quot;nscpmsg-&quot;);</span>
<a href="#l20.4043"></a><span id="l20.4043">       nsMsgKey msgKey;</span>
<a href="#l20.4044"></a><span id="l20.4044">       message-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l20.4045"></a><span id="l20.4045">       tmpFileName.AppendInt(msgKey);</span>
<a href="#l20.4046"></a><span id="l20.4046">       tmpFileName.AppendLiteral(&quot;.txt&quot;);</span>
<a href="#l20.4047"></a><span id="l20.4047">       m_copyState-&gt;m_tmpFile-&gt;SetNativeLeafName(tmpFileName);</span>
<a href="#l20.4048"></a><span id="l20.4048" class="difflineminus">-      rv = m_copyState-&gt;m_tmpFile-&gt;CreateUnique(nsIFile::NORMAL_FILE_TYPE, 00600);</span>
<a href="#l20.4049"></a><span id="l20.4049" class="difflineminus">-      if (NS_FAILED(rv))</span>
<a href="#l20.4050"></a><span id="l20.4050" class="difflineminus">-      {</span>
<a href="#l20.4051"></a><span id="l20.4051" class="difflineminus">-        MOZ_LOG(IMAP, mozilla::LogLevel::Info, (&quot;couldn't create temp nscpmsg.txt: %&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.4052"></a><span id="l20.4052" class="difflineplus">+      rv = m_copyState-&gt;m_tmpFile-&gt;CreateUnique(nsIFile::NORMAL_FILE_TYPE,</span>
<a href="#l20.4053"></a><span id="l20.4053" class="difflineplus">+                                                00600);</span>
<a href="#l20.4054"></a><span id="l20.4054" class="difflineplus">+      if (NS_FAILED(rv)) {</span>
<a href="#l20.4055"></a><span id="l20.4055" class="difflineplus">+        MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l20.4056"></a><span id="l20.4056" class="difflineplus">+                (&quot;couldn't create temp nscpmsg.txt: %&quot; PRIx32,</span>
<a href="#l20.4057"></a><span id="l20.4057" class="difflineplus">+                 static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.4058"></a><span id="l20.4058">         OnCopyCompleted(m_copyState-&gt;m_srcSupport, rv);</span>
<a href="#l20.4059"></a><span id="l20.4059">         return rv;</span>
<a href="#l20.4060"></a><span id="l20.4060">       }</span>
<a href="#l20.4061"></a><span id="l20.4061">     }</span>
<a href="#l20.4062"></a><span id="l20.4062">   }</span>
<a href="#l20.4063"></a><span id="l20.4063"> </span>
<a href="#l20.4064"></a><span id="l20.4064">   nsCOMPtr&lt;nsIOutputStream&gt; fileOutputStream;</span>
<a href="#l20.4065"></a><span id="l20.4065" class="difflineminus">-  rv = MsgNewBufferedFileOutputStream(getter_AddRefs(m_copyState-&gt;m_msgFileStream),</span>
<a href="#l20.4066"></a><span id="l20.4066" class="difflineminus">-                                      m_copyState-&gt;m_tmpFile, -1, 00600);</span>
<a href="#l20.4067"></a><span id="l20.4067" class="difflineplus">+  rv = MsgNewBufferedFileOutputStream(</span>
<a href="#l20.4068"></a><span id="l20.4068" class="difflineplus">+      getter_AddRefs(m_copyState-&gt;m_msgFileStream), m_copyState-&gt;m_tmpFile, -1,</span>
<a href="#l20.4069"></a><span id="l20.4069" class="difflineplus">+      00600);</span>
<a href="#l20.4070"></a><span id="l20.4070">   if (NS_FAILED(rv))</span>
<a href="#l20.4071"></a><span id="l20.4071" class="difflineminus">-    MOZ_LOG(IMAP, mozilla::LogLevel::Info, (&quot;couldn't create output file stream: %&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.4072"></a><span id="l20.4072" class="difflineplus">+    MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l20.4073"></a><span id="l20.4073" class="difflineplus">+            (&quot;couldn't create output file stream: %&quot; PRIx32,</span>
<a href="#l20.4074"></a><span id="l20.4074" class="difflineplus">+             static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.4075"></a><span id="l20.4075"> </span>
<a href="#l20.4076"></a><span id="l20.4076">   if (!m_copyState-&gt;m_dataBuffer)</span>
<a href="#l20.4077"></a><span id="l20.4077" class="difflineminus">-    m_copyState-&gt;m_dataBuffer = (char*) PR_CALLOC(COPY_BUFFER_SIZE+1);</span>
<a href="#l20.4078"></a><span id="l20.4078" class="difflineplus">+    m_copyState-&gt;m_dataBuffer = (char *)PR_CALLOC(COPY_BUFFER_SIZE + 1);</span>
<a href="#l20.4079"></a><span id="l20.4079">   NS_ENSURE_TRUE(m_copyState-&gt;m_dataBuffer, NS_ERROR_OUT_OF_MEMORY);</span>
<a href="#l20.4080"></a><span id="l20.4080">   m_copyState-&gt;m_dataBufferSize = COPY_BUFFER_SIZE;</span>
<a href="#l20.4081"></a><span id="l20.4081">   return NS_OK;</span>
<a href="#l20.4082"></a><span id="l20.4082"> }</span>
<a href="#l20.4083"></a><span id="l20.4083"> </span>
<a href="#l20.4084"></a><span id="l20.4084" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::CopyDataToOutputStreamForAppend(nsIInputStream *aIStream,</span>
<a href="#l20.4085"></a><span id="l20.4085" class="difflineminus">-                     int32_t aLength, nsIOutputStream *outputStream)</span>
<a href="#l20.4086"></a><span id="l20.4086" class="difflineminus">-{</span>
<a href="#l20.4087"></a><span id="l20.4087" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::CopyDataToOutputStreamForAppend(</span>
<a href="#l20.4088"></a><span id="l20.4088" class="difflineplus">+    nsIInputStream *aIStream, int32_t aLength, nsIOutputStream *outputStream) {</span>
<a href="#l20.4089"></a><span id="l20.4089">   uint32_t readCount;</span>
<a href="#l20.4090"></a><span id="l20.4090">   uint32_t writeCount;</span>
<a href="#l20.4091"></a><span id="l20.4091" class="difflineminus">-  if (!m_copyState)</span>
<a href="#l20.4092"></a><span id="l20.4092" class="difflineminus">-    m_copyState = new nsImapMailCopyState();</span>
<a href="#l20.4093"></a><span id="l20.4093" class="difflineminus">-</span>
<a href="#l20.4094"></a><span id="l20.4094" class="difflineminus">-  if ( aLength + m_copyState-&gt;m_leftOver &gt; m_copyState-&gt;m_dataBufferSize )</span>
<a href="#l20.4095"></a><span id="l20.4095" class="difflineminus">-  {</span>
<a href="#l20.4096"></a><span id="l20.4096" class="difflineminus">-    char *newBuffer = (char*) PR_REALLOC(m_copyState-&gt;m_dataBuffer, aLength + m_copyState-&gt;m_leftOver+ 1);</span>
<a href="#l20.4097"></a><span id="l20.4097" class="difflineplus">+  if (!m_copyState) m_copyState = new nsImapMailCopyState();</span>
<a href="#l20.4098"></a><span id="l20.4098" class="difflineplus">+</span>
<a href="#l20.4099"></a><span id="l20.4099" class="difflineplus">+  if (aLength + m_copyState-&gt;m_leftOver &gt; m_copyState-&gt;m_dataBufferSize) {</span>
<a href="#l20.4100"></a><span id="l20.4100" class="difflineplus">+    char *newBuffer = (char *)PR_REALLOC(m_copyState-&gt;m_dataBuffer,</span>
<a href="#l20.4101"></a><span id="l20.4101" class="difflineplus">+                                         aLength + m_copyState-&gt;m_leftOver + 1);</span>
<a href="#l20.4102"></a><span id="l20.4102">     NS_ENSURE_TRUE(newBuffer, NS_ERROR_OUT_OF_MEMORY);</span>
<a href="#l20.4103"></a><span id="l20.4103">     m_copyState-&gt;m_dataBuffer = newBuffer;</span>
<a href="#l20.4104"></a><span id="l20.4104">     m_copyState-&gt;m_dataBufferSize = aLength + m_copyState-&gt;m_leftOver;</span>
<a href="#l20.4105"></a><span id="l20.4105">   }</span>
<a href="#l20.4106"></a><span id="l20.4106"> </span>
<a href="#l20.4107"></a><span id="l20.4107">   char *start, *end;</span>
<a href="#l20.4108"></a><span id="l20.4108">   uint32_t linebreak_len = 1;</span>
<a href="#l20.4109"></a><span id="l20.4109"> </span>
<a href="#l20.4110"></a><span id="l20.4110" class="difflineminus">-  nsresult rv = aIStream-&gt;Read(m_copyState-&gt;m_dataBuffer+m_copyState-&gt;m_leftOver, aLength, &amp;readCount);</span>
<a href="#l20.4111"></a><span id="l20.4111" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l20.4112"></a><span id="l20.4112" class="difflineminus">-    return rv;</span>
<a href="#l20.4113"></a><span id="l20.4113" class="difflineplus">+  nsresult rv = aIStream-&gt;Read(</span>
<a href="#l20.4114"></a><span id="l20.4114" class="difflineplus">+      m_copyState-&gt;m_dataBuffer + m_copyState-&gt;m_leftOver, aLength, &amp;readCount);</span>
<a href="#l20.4115"></a><span id="l20.4115" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.4116"></a><span id="l20.4116"> </span>
<a href="#l20.4117"></a><span id="l20.4117">   m_copyState-&gt;m_leftOver += readCount;</span>
<a href="#l20.4118"></a><span id="l20.4118">   m_copyState-&gt;m_dataBuffer[m_copyState-&gt;m_leftOver] = '\0';</span>
<a href="#l20.4119"></a><span id="l20.4119"> </span>
<a href="#l20.4120"></a><span id="l20.4120">   start = m_copyState-&gt;m_dataBuffer;</span>
<a href="#l20.4121"></a><span id="l20.4121" class="difflineminus">-  if (m_copyState-&gt;m_eatLF)</span>
<a href="#l20.4122"></a><span id="l20.4122" class="difflineminus">-  {</span>
<a href="#l20.4123"></a><span id="l20.4123" class="difflineminus">-    if (*start == '\n')</span>
<a href="#l20.4124"></a><span id="l20.4124" class="difflineminus">-      start++;</span>
<a href="#l20.4125"></a><span id="l20.4125" class="difflineplus">+  if (m_copyState-&gt;m_eatLF) {</span>
<a href="#l20.4126"></a><span id="l20.4126" class="difflineplus">+    if (*start == '\n') start++;</span>
<a href="#l20.4127"></a><span id="l20.4127">     m_copyState-&gt;m_eatLF = false;</span>
<a href="#l20.4128"></a><span id="l20.4128">   }</span>
<a href="#l20.4129"></a><span id="l20.4129">   end = PL_strpbrk(start, &quot;\r\n&quot;);</span>
<a href="#l20.4130"></a><span id="l20.4130" class="difflineminus">-  if (end &amp;&amp; *end == '\r' &amp;&amp; *(end+1) == '\n')</span>
<a href="#l20.4131"></a><span id="l20.4131" class="difflineminus">-    linebreak_len = 2;</span>
<a href="#l20.4132"></a><span id="l20.4132" class="difflineminus">-</span>
<a href="#l20.4133"></a><span id="l20.4133" class="difflineminus">-  while (start &amp;&amp; end)</span>
<a href="#l20.4134"></a><span id="l20.4134" class="difflineminus">-  {</span>
<a href="#l20.4135"></a><span id="l20.4135" class="difflineplus">+  if (end &amp;&amp; *end == '\r' &amp;&amp; *(end + 1) == '\n') linebreak_len = 2;</span>
<a href="#l20.4136"></a><span id="l20.4136" class="difflineplus">+</span>
<a href="#l20.4137"></a><span id="l20.4137" class="difflineplus">+  while (start &amp;&amp; end) {</span>
<a href="#l20.4138"></a><span id="l20.4138">     if (PL_strncasecmp(start, &quot;X-Mozilla-Status:&quot;, 17) &amp;&amp;</span>
<a href="#l20.4139"></a><span id="l20.4139">         PL_strncasecmp(start, &quot;X-Mozilla-Status2:&quot;, 18) &amp;&amp;</span>
<a href="#l20.4140"></a><span id="l20.4140" class="difflineminus">-        PL_strncmp(start, &quot;From - &quot;, 7))</span>
<a href="#l20.4141"></a><span id="l20.4141" class="difflineminus">-    {</span>
<a href="#l20.4142"></a><span id="l20.4142" class="difflineminus">-      rv = outputStream-&gt;Write(start,</span>
<a href="#l20.4143"></a><span id="l20.4143" class="difflineminus">-                                             end-start,</span>
<a href="#l20.4144"></a><span id="l20.4144" class="difflineminus">-                                             &amp;writeCount);</span>
<a href="#l20.4145"></a><span id="l20.4145" class="difflineplus">+        PL_strncmp(start, &quot;From - &quot;, 7)) {</span>
<a href="#l20.4146"></a><span id="l20.4146" class="difflineplus">+      rv = outputStream-&gt;Write(start, end - start, &amp;writeCount);</span>
<a href="#l20.4147"></a><span id="l20.4147">       rv = outputStream-&gt;Write(CRLF, 2, &amp;writeCount);</span>
<a href="#l20.4148"></a><span id="l20.4148">     }</span>
<a href="#l20.4149"></a><span id="l20.4149" class="difflineminus">-    start = end+linebreak_len;</span>
<a href="#l20.4150"></a><span id="l20.4150" class="difflineminus">-    if (start &gt;=</span>
<a href="#l20.4151"></a><span id="l20.4151" class="difflineminus">-        m_copyState-&gt;m_dataBuffer+m_copyState-&gt;m_leftOver)</span>
<a href="#l20.4152"></a><span id="l20.4152" class="difflineminus">-    {</span>
<a href="#l20.4153"></a><span id="l20.4153" class="difflineminus">-       m_copyState-&gt;m_leftOver = 0;</span>
<a href="#l20.4154"></a><span id="l20.4154" class="difflineminus">-       break;</span>
<a href="#l20.4155"></a><span id="l20.4155" class="difflineplus">+    start = end + linebreak_len;</span>
<a href="#l20.4156"></a><span id="l20.4156" class="difflineplus">+    if (start &gt;= m_copyState-&gt;m_dataBuffer + m_copyState-&gt;m_leftOver) {</span>
<a href="#l20.4157"></a><span id="l20.4157" class="difflineplus">+      m_copyState-&gt;m_leftOver = 0;</span>
<a href="#l20.4158"></a><span id="l20.4158" class="difflineplus">+      break;</span>
<a href="#l20.4159"></a><span id="l20.4159">     }</span>
<a href="#l20.4160"></a><span id="l20.4160">     linebreak_len = 1;</span>
<a href="#l20.4161"></a><span id="l20.4161"> </span>
<a href="#l20.4162"></a><span id="l20.4162">     end = PL_strpbrk(start, &quot;\r\n&quot;);</span>
<a href="#l20.4163"></a><span id="l20.4163" class="difflineminus">-    if (end &amp;&amp; *end == '\r')</span>
<a href="#l20.4164"></a><span id="l20.4164" class="difflineminus">-    {</span>
<a href="#l20.4165"></a><span id="l20.4165" class="difflineminus">-      if (*(end+1) == '\n')</span>
<a href="#l20.4166"></a><span id="l20.4166" class="difflineplus">+    if (end &amp;&amp; *end == '\r') {</span>
<a href="#l20.4167"></a><span id="l20.4167" class="difflineplus">+      if (*(end + 1) == '\n')</span>
<a href="#l20.4168"></a><span id="l20.4168">         linebreak_len = 2;</span>
<a href="#l20.4169"></a><span id="l20.4169" class="difflineminus">-      else if (! *(end+1)) // block might have split CRLF so remember if</span>
<a href="#l20.4170"></a><span id="l20.4170" class="difflineminus">-        m_copyState-&gt;m_eatLF = true; // we should eat LF</span>
<a href="#l20.4171"></a><span id="l20.4171" class="difflineminus">-    }</span>
<a href="#l20.4172"></a><span id="l20.4172" class="difflineminus">-</span>
<a href="#l20.4173"></a><span id="l20.4173" class="difflineminus">-    if (start &amp;&amp; !end)</span>
<a href="#l20.4174"></a><span id="l20.4174" class="difflineminus">-    {</span>
<a href="#l20.4175"></a><span id="l20.4175" class="difflineplus">+      else if (!*(end + 1))  // block might have split CRLF so remember if</span>
<a href="#l20.4176"></a><span id="l20.4176" class="difflineplus">+        m_copyState-&gt;m_eatLF = true;  // we should eat LF</span>
<a href="#l20.4177"></a><span id="l20.4177" class="difflineplus">+    }</span>
<a href="#l20.4178"></a><span id="l20.4178" class="difflineplus">+</span>
<a href="#l20.4179"></a><span id="l20.4179" class="difflineplus">+    if (start &amp;&amp; !end) {</span>
<a href="#l20.4180"></a><span id="l20.4180">       m_copyState-&gt;m_leftOver -= (start - m_copyState-&gt;m_dataBuffer);</span>
<a href="#l20.4181"></a><span id="l20.4181" class="difflineminus">-      memcpy(m_copyState-&gt;m_dataBuffer, start, m_copyState-&gt;m_leftOver+1); // including null</span>
<a href="#l20.4182"></a><span id="l20.4182" class="difflineplus">+      memcpy(m_copyState-&gt;m_dataBuffer, start,</span>
<a href="#l20.4183"></a><span id="l20.4183" class="difflineplus">+             m_copyState-&gt;m_leftOver + 1);  // including null</span>
<a href="#l20.4184"></a><span id="l20.4184">     }</span>
<a href="#l20.4185"></a><span id="l20.4185">   }</span>
<a href="#l20.4186"></a><span id="l20.4186">   return rv;</span>
<a href="#l20.4187"></a><span id="l20.4187"> }</span>
<a href="#l20.4188"></a><span id="l20.4188"> </span>
<a href="#l20.4189"></a><span id="l20.4189" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::CopyDataDone()</span>
<a href="#l20.4190"></a><span id="l20.4190" class="difflineminus">-{</span>
<a href="#l20.4191"></a><span id="l20.4191" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::CopyDataDone() {</span>
<a href="#l20.4192"></a><span id="l20.4192">   m_copyState = nullptr;</span>
<a href="#l20.4193"></a><span id="l20.4193">   return NS_OK;</span>
<a href="#l20.4194"></a><span id="l20.4194"> }</span>
<a href="#l20.4195"></a><span id="l20.4195"> </span>
<a href="#l20.4196"></a><span id="l20.4196" class="difflineminus">-// sICopyMessageListener methods, BeginCopy, CopyData, EndCopy, EndMove, StartMessage, EndMessage</span>
<a href="#l20.4197"></a><span id="l20.4197" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::CopyData(nsIInputStream *aIStream, int32_t aLength)</span>
<a href="#l20.4198"></a><span id="l20.4198" class="difflineminus">-{</span>
<a href="#l20.4199"></a><span id="l20.4199" class="difflineminus">-  NS_ENSURE_TRUE(m_copyState &amp;&amp; m_copyState-&gt;m_msgFileStream &amp;&amp; m_copyState-&gt;m_dataBuffer, NS_ERROR_NULL_POINTER);</span>
<a href="#l20.4200"></a><span id="l20.4200" class="difflineplus">+// sICopyMessageListener methods, BeginCopy, CopyData, EndCopy, EndMove,</span>
<a href="#l20.4201"></a><span id="l20.4201" class="difflineplus">+// StartMessage, EndMessage</span>
<a href="#l20.4202"></a><span id="l20.4202" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::CopyData(nsIInputStream *aIStream,</span>
<a href="#l20.4203"></a><span id="l20.4203" class="difflineplus">+                                         int32_t aLength) {</span>
<a href="#l20.4204"></a><span id="l20.4204" class="difflineplus">+  NS_ENSURE_TRUE(</span>
<a href="#l20.4205"></a><span id="l20.4205" class="difflineplus">+      m_copyState &amp;&amp; m_copyState-&gt;m_msgFileStream &amp;&amp; m_copyState-&gt;m_dataBuffer,</span>
<a href="#l20.4206"></a><span id="l20.4206" class="difflineplus">+      NS_ERROR_NULL_POINTER);</span>
<a href="#l20.4207"></a><span id="l20.4207">   nsresult rv = CopyDataToOutputStreamForAppend(aIStream, aLength,</span>
<a href="#l20.4208"></a><span id="l20.4208">                                                 m_copyState-&gt;m_msgFileStream);</span>
<a href="#l20.4209"></a><span id="l20.4209" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l20.4210"></a><span id="l20.4210" class="difflineminus">-  {</span>
<a href="#l20.4211"></a><span id="l20.4211" class="difflineminus">-    MOZ_LOG(IMAP, mozilla::LogLevel::Info, (&quot;CopyData failed: %&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.4212"></a><span id="l20.4212" class="difflineplus">+  if (NS_FAILED(rv)) {</span>
<a href="#l20.4213"></a><span id="l20.4213" class="difflineplus">+    MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l20.4214"></a><span id="l20.4214" class="difflineplus">+            (&quot;CopyData failed: %&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.4215"></a><span id="l20.4215">     OnCopyCompleted(m_copyState-&gt;m_srcSupport, rv);</span>
<a href="#l20.4216"></a><span id="l20.4216">   }</span>
<a href="#l20.4217"></a><span id="l20.4217">   return rv;</span>
<a href="#l20.4218"></a><span id="l20.4218"> }</span>
<a href="#l20.4219"></a><span id="l20.4219"> </span>
<a href="#l20.4220"></a><span id="l20.4220" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::EndCopy(bool copySucceeded)</span>
<a href="#l20.4221"></a><span id="l20.4221" class="difflineminus">-{</span>
<a href="#l20.4222"></a><span id="l20.4222" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::EndCopy(bool copySucceeded) {</span>
<a href="#l20.4223"></a><span id="l20.4223">   nsresult rv = copySucceeded ? NS_OK : NS_ERROR_FAILURE;</span>
<a href="#l20.4224"></a><span id="l20.4224" class="difflineminus">-  if (copySucceeded &amp;&amp; m_copyState &amp;&amp; m_copyState-&gt;m_msgFileStream)</span>
<a href="#l20.4225"></a><span id="l20.4225" class="difflineminus">-  {</span>
<a href="#l20.4226"></a><span id="l20.4226" class="difflineplus">+  if (copySucceeded &amp;&amp; m_copyState &amp;&amp; m_copyState-&gt;m_msgFileStream) {</span>
<a href="#l20.4227"></a><span id="l20.4227">     nsCOMPtr&lt;nsIUrlListener&gt; urlListener;</span>
<a href="#l20.4228"></a><span id="l20.4228">     m_copyState-&gt;m_msgFileStream-&gt;Close();</span>
<a href="#l20.4229"></a><span id="l20.4229">     // m_tmpFile can be stale because we wrote to it</span>
<a href="#l20.4230"></a><span id="l20.4230">     nsCOMPtr&lt;nsIFile&gt; tmpFile;</span>
<a href="#l20.4231"></a><span id="l20.4231">     m_copyState-&gt;m_tmpFile-&gt;Clone(getter_AddRefs(tmpFile));</span>
<a href="#l20.4232"></a><span id="l20.4232">     m_copyState-&gt;m_tmpFile = tmpFile;</span>
<a href="#l20.4233"></a><span id="l20.4233" class="difflineminus">-    nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.4234"></a><span id="l20.4234" class="difflineminus">-    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.4235"></a><span id="l20.4235" class="difflineminus">-</span>
<a href="#l20.4236"></a><span id="l20.4236" class="difflineminus">-    rv = QueryInterface(NS_GET_IID(nsIUrlListener), getter_AddRefs(urlListener));</span>
<a href="#l20.4237"></a><span id="l20.4237" class="difflineplus">+    nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.4238"></a><span id="l20.4238" class="difflineplus">+        do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.4239"></a><span id="l20.4239" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4240"></a><span id="l20.4240" class="difflineplus">+</span>
<a href="#l20.4241"></a><span id="l20.4241" class="difflineplus">+    rv =</span>
<a href="#l20.4242"></a><span id="l20.4242" class="difflineplus">+        QueryInterface(NS_GET_IID(nsIUrlListener), getter_AddRefs(urlListener));</span>
<a href="#l20.4243"></a><span id="l20.4243">     nsCOMPtr&lt;nsISupports&gt; copySupport;</span>
<a href="#l20.4244"></a><span id="l20.4244" class="difflineminus">-    if (m_copyState)</span>
<a href="#l20.4245"></a><span id="l20.4245" class="difflineminus">-      copySupport = do_QueryInterface(m_copyState);</span>
<a href="#l20.4246"></a><span id="l20.4246" class="difflineminus">-    rv = imapService-&gt;AppendMessageFromFile(m_copyState-&gt;m_tmpFile,</span>
<a href="#l20.4247"></a><span id="l20.4247" class="difflineminus">-                                            this, EmptyCString(), true,</span>
<a href="#l20.4248"></a><span id="l20.4248" class="difflineminus">-                                            m_copyState-&gt;m_selectedState,</span>
<a href="#l20.4249"></a><span id="l20.4249" class="difflineminus">-                                            urlListener, nullptr,</span>
<a href="#l20.4250"></a><span id="l20.4250" class="difflineminus">-                                            copySupport,</span>
<a href="#l20.4251"></a><span id="l20.4251" class="difflineminus">-                                            m_copyState-&gt;m_msgWindow);</span>
<a href="#l20.4252"></a><span id="l20.4252" class="difflineplus">+    if (m_copyState) copySupport = do_QueryInterface(m_copyState);</span>
<a href="#l20.4253"></a><span id="l20.4253" class="difflineplus">+    rv = imapService-&gt;AppendMessageFromFile(</span>
<a href="#l20.4254"></a><span id="l20.4254" class="difflineplus">+        m_copyState-&gt;m_tmpFile, this, EmptyCString(), true,</span>
<a href="#l20.4255"></a><span id="l20.4255" class="difflineplus">+        m_copyState-&gt;m_selectedState, urlListener, nullptr, copySupport,</span>
<a href="#l20.4256"></a><span id="l20.4256" class="difflineplus">+        m_copyState-&gt;m_msgWindow);</span>
<a href="#l20.4257"></a><span id="l20.4257">   }</span>
<a href="#l20.4258"></a><span id="l20.4258">   if (NS_FAILED(rv) || !copySucceeded)</span>
<a href="#l20.4259"></a><span id="l20.4259" class="difflineminus">-    MOZ_LOG(IMAP, mozilla::LogLevel::Info, (&quot;EndCopy failed: %&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.4260"></a><span id="l20.4260" class="difflineplus">+    MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l20.4261"></a><span id="l20.4261" class="difflineplus">+            (&quot;EndCopy failed: %&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.4262"></a><span id="l20.4262">   return rv;</span>
<a href="#l20.4263"></a><span id="l20.4263"> }</span>
<a href="#l20.4264"></a><span id="l20.4264"> </span>
<a href="#l20.4265"></a><span id="l20.4265" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::EndMove(bool moveSucceeded)</span>
<a href="#l20.4266"></a><span id="l20.4266" class="difflineminus">-{</span>
<a href="#l20.4267"></a><span id="l20.4267" class="difflineminus">-  return NS_OK;</span>
<a href="#l20.4268"></a><span id="l20.4268" class="difflineminus">-}</span>
<a href="#l20.4269"></a><span id="l20.4269" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::EndMove(bool moveSucceeded) { return NS_OK; }</span>
<a href="#l20.4270"></a><span id="l20.4270"> // this is the beginning of the next message copied</span>
<a href="#l20.4271"></a><span id="l20.4271" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::StartMessage()</span>
<a href="#l20.4272"></a><span id="l20.4272" class="difflineminus">-{</span>
<a href="#l20.4273"></a><span id="l20.4273" class="difflineminus">-  return NS_OK;</span>
<a href="#l20.4274"></a><span id="l20.4274" class="difflineminus">-}</span>
<a href="#l20.4275"></a><span id="l20.4275" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::StartMessage() { return NS_OK; }</span>
<a href="#l20.4276"></a><span id="l20.4276"> </span>
<a href="#l20.4277"></a><span id="l20.4277"> // just finished the current message.</span>
<a href="#l20.4278"></a><span id="l20.4278" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::EndMessage(nsMsgKey key)</span>
<a href="#l20.4279"></a><span id="l20.4279" class="difflineminus">-{</span>
<a href="#l20.4280"></a><span id="l20.4280" class="difflineminus">-  return NS_OK;</span>
<a href="#l20.4281"></a><span id="l20.4281" class="difflineminus">-}</span>
<a href="#l20.4282"></a><span id="l20.4282" class="difflineminus">-</span>
<a href="#l20.4283"></a><span id="l20.4283" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::ApplyFilterHit(nsIMsgFilter *filter, nsIMsgWindow *msgWindow, bool *applyMore)</span>
<a href="#l20.4284"></a><span id="l20.4284" class="difflineminus">-{</span>
<a href="#l20.4285"></a><span id="l20.4285" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::EndMessage(nsMsgKey key) { return NS_OK; }</span>
<a href="#l20.4286"></a><span id="l20.4286" class="difflineplus">+</span>
<a href="#l20.4287"></a><span id="l20.4287" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::ApplyFilterHit(nsIMsgFilter *filter,</span>
<a href="#l20.4288"></a><span id="l20.4288" class="difflineplus">+                                               nsIMsgWindow *msgWindow,</span>
<a href="#l20.4289"></a><span id="l20.4289" class="difflineplus">+                                               bool *applyMore) {</span>
<a href="#l20.4290"></a><span id="l20.4290">   //</span>
<a href="#l20.4291"></a><span id="l20.4291">   //  This routine is called indirectly from ApplyFiltersToHdr in two</span>
<a href="#l20.4292"></a><span id="l20.4292">   //  circumstances, controlled by m_filterListRequiresBody:</span>
<a href="#l20.4293"></a><span id="l20.4293">   //</span>
<a href="#l20.4294"></a><span id="l20.4294">   //  If false, after headers are parsed in NormalEndHeaderParseStream.</span>
<a href="#l20.4295"></a><span id="l20.4295">   //  If true, after the message body is downloaded in NormalEndMsgWriteStream.</span>
<a href="#l20.4296"></a><span id="l20.4296">   //</span>
<a href="#l20.4297"></a><span id="l20.4297">   //  In NormalEndHeaderParseStream, the message has not been added to the</span>
<a href="#l20.4298"></a><span id="l20.4298" class="difflineat">@@ -3409,1017 +3160,931 @@ NS_IMETHODIMP nsImapMailFolder::ApplyFil</span>
<a href="#l20.4299"></a><span id="l20.4299"> </span>
<a href="#l20.4300"></a><span id="l20.4300">   nsresult rv = NS_OK;</span>
<a href="#l20.4301"></a><span id="l20.4301"> </span>
<a href="#l20.4302"></a><span id="l20.4302">   nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l20.4303"></a><span id="l20.4303">   if (m_filterListRequiresBody)</span>
<a href="#l20.4304"></a><span id="l20.4304">     GetMessageHeader(m_curMsgUid, getter_AddRefs(msgHdr));</span>
<a href="#l20.4305"></a><span id="l20.4305">   else if (m_msgParser)</span>
<a href="#l20.4306"></a><span id="l20.4306">     m_msgParser-&gt;GetNewMsgHdr(getter_AddRefs(msgHdr));</span>
<a href="#l20.4307"></a><span id="l20.4307" class="difflineminus">-  NS_ENSURE_TRUE(msgHdr, NS_ERROR_NULL_POINTER); //fatal error, cannot apply filters</span>
<a href="#l20.4308"></a><span id="l20.4308" class="difflineplus">+  NS_ENSURE_TRUE(msgHdr,</span>
<a href="#l20.4309"></a><span id="l20.4309" class="difflineplus">+                 NS_ERROR_NULL_POINTER);  // fatal error, cannot apply filters</span>
<a href="#l20.4310"></a><span id="l20.4310"> </span>
<a href="#l20.4311"></a><span id="l20.4311">   bool deleteToTrash = DeleteIsMoveToTrash();</span>
<a href="#l20.4312"></a><span id="l20.4312"> </span>
<a href="#l20.4313"></a><span id="l20.4313">   nsCOMPtr&lt;nsIArray&gt; filterActionList;</span>
<a href="#l20.4314"></a><span id="l20.4314">   rv = filter-&gt;GetSortedActionList(getter_AddRefs(filterActionList));</span>
<a href="#l20.4315"></a><span id="l20.4315">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4316"></a><span id="l20.4316"> </span>
<a href="#l20.4317"></a><span id="l20.4317">   uint32_t numActions;</span>
<a href="#l20.4318"></a><span id="l20.4318">   rv = filterActionList-&gt;GetLength(&amp;numActions);</span>
<a href="#l20.4319"></a><span id="l20.4319">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4320"></a><span id="l20.4320"> </span>
<a href="#l20.4321"></a><span id="l20.4321">   nsCString msgId;</span>
<a href="#l20.4322"></a><span id="l20.4322">   msgHdr-&gt;GetMessageId(getter_Copies(msgId));</span>
<a href="#l20.4323"></a><span id="l20.4323">   nsMsgKey msgKey;</span>
<a href="#l20.4324"></a><span id="l20.4324">   msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l20.4325"></a><span id="l20.4325" class="difflineminus">-  MOZ_LOG(FILTERLOGMODULE, LogLevel::Info, (&quot;(Imap) Applying filter actions on message with key %&quot; PRIu32, msgKeyToInt(msgKey)));</span>
<a href="#l20.4326"></a><span id="l20.4326" class="difflineminus">-  MOZ_LOG(FILTERLOGMODULE, LogLevel::Debug, (&quot;(Imap) Message ID: %s&quot;, msgId.get()));</span>
<a href="#l20.4327"></a><span id="l20.4327" class="difflineplus">+  MOZ_LOG(FILTERLOGMODULE, LogLevel::Info,</span>
<a href="#l20.4328"></a><span id="l20.4328" class="difflineplus">+          (&quot;(Imap) Applying filter actions on message with key %&quot; PRIu32,</span>
<a href="#l20.4329"></a><span id="l20.4329" class="difflineplus">+           msgKeyToInt(msgKey)));</span>
<a href="#l20.4330"></a><span id="l20.4330" class="difflineplus">+  MOZ_LOG(FILTERLOGMODULE, LogLevel::Debug,</span>
<a href="#l20.4331"></a><span id="l20.4331" class="difflineplus">+          (&quot;(Imap) Message ID: %s&quot;, msgId.get()));</span>
<a href="#l20.4332"></a><span id="l20.4332"> </span>
<a href="#l20.4333"></a><span id="l20.4333">   bool loggingEnabled = false;</span>
<a href="#l20.4334"></a><span id="l20.4334">   if (m_filterList &amp;&amp; numActions)</span>
<a href="#l20.4335"></a><span id="l20.4335">     (void)m_filterList-&gt;GetLoggingEnabled(&amp;loggingEnabled);</span>
<a href="#l20.4336"></a><span id="l20.4336"> </span>
<a href="#l20.4337"></a><span id="l20.4337">   bool msgIsNew = true;</span>
<a href="#l20.4338"></a><span id="l20.4338"> </span>
<a href="#l20.4339"></a><span id="l20.4339" class="difflineminus">-  for (uint32_t actionIndex = 0; actionIndex &lt; numActions; actionIndex++)</span>
<a href="#l20.4340"></a><span id="l20.4340" class="difflineminus">-  {</span>
<a href="#l20.4341"></a><span id="l20.4341" class="difflineminus">-    nsCOMPtr&lt;nsIMsgRuleAction&gt; filterAction = do_QueryElementAt(filterActionList, actionIndex);</span>
<a href="#l20.4342"></a><span id="l20.4342" class="difflineminus">-    if (NS_FAILED(rv) || !filterAction)</span>
<a href="#l20.4343"></a><span id="l20.4343" class="difflineminus">-      continue;</span>
<a href="#l20.4344"></a><span id="l20.4344" class="difflineplus">+  for (uint32_t actionIndex = 0; actionIndex &lt; numActions; actionIndex++) {</span>
<a href="#l20.4345"></a><span id="l20.4345" class="difflineplus">+    nsCOMPtr&lt;nsIMsgRuleAction&gt; filterAction =</span>
<a href="#l20.4346"></a><span id="l20.4346" class="difflineplus">+        do_QueryElementAt(filterActionList, actionIndex);</span>
<a href="#l20.4347"></a><span id="l20.4347" class="difflineplus">+    if (NS_FAILED(rv) || !filterAction) continue;</span>
<a href="#l20.4348"></a><span id="l20.4348"> </span>
<a href="#l20.4349"></a><span id="l20.4349">     nsMsgRuleActionType actionType;</span>
<a href="#l20.4350"></a><span id="l20.4350" class="difflineminus">-    if (NS_SUCCEEDED(filterAction-&gt;GetType(&amp;actionType)))</span>
<a href="#l20.4351"></a><span id="l20.4351" class="difflineminus">-    {</span>
<a href="#l20.4352"></a><span id="l20.4352" class="difflineminus">-      if (loggingEnabled)</span>
<a href="#l20.4353"></a><span id="l20.4353" class="difflineminus">-        (void) filter-&gt;LogRuleHit(filterAction, msgHdr);</span>
<a href="#l20.4354"></a><span id="l20.4354" class="difflineplus">+    if (NS_SUCCEEDED(filterAction-&gt;GetType(&amp;actionType))) {</span>
<a href="#l20.4355"></a><span id="l20.4355" class="difflineplus">+      if (loggingEnabled) (void)filter-&gt;LogRuleHit(filterAction, msgHdr);</span>
<a href="#l20.4356"></a><span id="l20.4356"> </span>
<a href="#l20.4357"></a><span id="l20.4357">       nsCString actionTargetFolderUri;</span>
<a href="#l20.4358"></a><span id="l20.4358">       if (actionType == nsMsgFilterAction::MoveToFolder ||</span>
<a href="#l20.4359"></a><span id="l20.4359" class="difflineminus">-          actionType == nsMsgFilterAction::CopyToFolder)</span>
<a href="#l20.4360"></a><span id="l20.4360" class="difflineminus">-      {</span>
<a href="#l20.4361"></a><span id="l20.4361" class="difflineplus">+          actionType == nsMsgFilterAction::CopyToFolder) {</span>
<a href="#l20.4362"></a><span id="l20.4362">         rv = filterAction-&gt;GetTargetFolderUri(actionTargetFolderUri);</span>
<a href="#l20.4363"></a><span id="l20.4363" class="difflineminus">-        if (NS_FAILED(rv) || actionTargetFolderUri.IsEmpty())</span>
<a href="#l20.4364"></a><span id="l20.4364" class="difflineminus">-        {</span>
<a href="#l20.4365"></a><span id="l20.4365" class="difflineplus">+        if (NS_FAILED(rv) || actionTargetFolderUri.IsEmpty()) {</span>
<a href="#l20.4366"></a><span id="l20.4366">           NS_ASSERTION(false, &quot;actionTargetFolderUri is empty&quot;);</span>
<a href="#l20.4367"></a><span id="l20.4367">           continue;</span>
<a href="#l20.4368"></a><span id="l20.4368">         }</span>
<a href="#l20.4369"></a><span id="l20.4369">       }</span>
<a href="#l20.4370"></a><span id="l20.4370"> </span>
<a href="#l20.4371"></a><span id="l20.4371">       uint32_t msgFlags;</span>
<a href="#l20.4372"></a><span id="l20.4372" class="difflineminus">-      nsMsgKey    msgKey;</span>
<a href="#l20.4373"></a><span id="l20.4373" class="difflineplus">+      nsMsgKey msgKey;</span>
<a href="#l20.4374"></a><span id="l20.4374">       nsAutoCString trashNameVal;</span>
<a href="#l20.4375"></a><span id="l20.4375"> </span>
<a href="#l20.4376"></a><span id="l20.4376">       msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l20.4377"></a><span id="l20.4377">       msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l20.4378"></a><span id="l20.4378">       bool isRead = (msgFlags &amp; nsMsgMessageFlags::Read);</span>
<a href="#l20.4379"></a><span id="l20.4379">       nsresult rv = GetDatabase();</span>
<a href="#l20.4380"></a><span id="l20.4380">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4381"></a><span id="l20.4381" class="difflineminus">-      switch (actionType)</span>
<a href="#l20.4382"></a><span id="l20.4382" class="difflineminus">-      {</span>
<a href="#l20.4383"></a><span id="l20.4383" class="difflineminus">-        case nsMsgFilterAction::Delete:</span>
<a href="#l20.4384"></a><span id="l20.4384" class="difflineminus">-        {</span>
<a href="#l20.4385"></a><span id="l20.4385" class="difflineminus">-          if (deleteToTrash)</span>
<a href="#l20.4386"></a><span id="l20.4386" class="difflineminus">-          {</span>
<a href="#l20.4387"></a><span id="l20.4387" class="difflineplus">+      switch (actionType) {</span>
<a href="#l20.4388"></a><span id="l20.4388" class="difflineplus">+        case nsMsgFilterAction::Delete: {</span>
<a href="#l20.4389"></a><span id="l20.4389" class="difflineplus">+          if (deleteToTrash) {</span>
<a href="#l20.4390"></a><span id="l20.4390">             // set value to trash folder</span>
<a href="#l20.4391"></a><span id="l20.4391" class="difflineminus">-            nsCOMPtr &lt;nsIMsgFolder&gt; mailTrash;</span>
<a href="#l20.4392"></a><span id="l20.4392" class="difflineplus">+            nsCOMPtr&lt;nsIMsgFolder&gt; mailTrash;</span>
<a href="#l20.4393"></a><span id="l20.4393">             rv = GetTrashFolder(getter_AddRefs(mailTrash));</span>
<a href="#l20.4394"></a><span id="l20.4394">             if (NS_SUCCEEDED(rv) &amp;&amp; mailTrash)</span>
<a href="#l20.4395"></a><span id="l20.4395">               rv = mailTrash-&gt;GetURI(actionTargetFolderUri);</span>
<a href="#l20.4396"></a><span id="l20.4396" class="difflineminus">-            // msgHdr-&gt;OrFlags(nsMsgMessageFlags::Read, &amp;newFlags);  // mark read in trash.</span>
<a href="#l20.4397"></a><span id="l20.4397" class="difflineminus">-          }</span>
<a href="#l20.4398"></a><span id="l20.4398" class="difflineminus">-          else  // (!deleteToTrash)</span>
<a href="#l20.4399"></a><span id="l20.4399" class="difflineminus">-          {</span>
<a href="#l20.4400"></a><span id="l20.4400" class="difflineplus">+            // msgHdr-&gt;OrFlags(nsMsgMessageFlags::Read, &amp;newFlags);  // mark</span>
<a href="#l20.4401"></a><span id="l20.4401" class="difflineplus">+            // read in trash.</span>
<a href="#l20.4402"></a><span id="l20.4402" class="difflineplus">+          } else {</span>
<a href="#l20.4403"></a><span id="l20.4403">             mDatabase-&gt;MarkHdrRead(msgHdr, true, nullptr);</span>
<a href="#l20.4404"></a><span id="l20.4404">             mDatabase-&gt;MarkImapDeleted(msgKey, true, nullptr);</span>
<a href="#l20.4405"></a><span id="l20.4405">             StoreImapFlags(kImapMsgSeenFlag | kImapMsgDeletedFlag, true,</span>
<a href="#l20.4406"></a><span id="l20.4406">                            &amp;msgKey, 1, nullptr);</span>
<a href="#l20.4407"></a><span id="l20.4407" class="difflineminus">-            m_msgMovedByFilter = true; // this will prevent us from adding the header to the db.</span>
<a href="#l20.4408"></a><span id="l20.4408" class="difflineplus">+            m_msgMovedByFilter =</span>
<a href="#l20.4409"></a><span id="l20.4409" class="difflineplus">+                true;  // this will prevent us from adding the header to the db.</span>
<a href="#l20.4410"></a><span id="l20.4410">           }</span>
<a href="#l20.4411"></a><span id="l20.4411">           msgIsNew = false;</span>
<a href="#l20.4412"></a><span id="l20.4412">         }</span>
<a href="#l20.4413"></a><span id="l20.4413" class="difflineminus">-        // note that delete falls through to move.</span>
<a href="#l20.4414"></a><span id="l20.4414" class="difflineminus">-        MOZ_FALLTHROUGH;</span>
<a href="#l20.4415"></a><span id="l20.4415" class="difflineminus">-        case nsMsgFilterAction::MoveToFolder:</span>
<a href="#l20.4416"></a><span id="l20.4416" class="difflineminus">-        {</span>
<a href="#l20.4417"></a><span id="l20.4417" class="difflineplus">+          // note that delete falls through to move.</span>
<a href="#l20.4418"></a><span id="l20.4418" class="difflineplus">+          MOZ_FALLTHROUGH;</span>
<a href="#l20.4419"></a><span id="l20.4419" class="difflineplus">+        case nsMsgFilterAction::MoveToFolder: {</span>
<a href="#l20.4420"></a><span id="l20.4420">           // if moving to a different file, do it.</span>
<a href="#l20.4421"></a><span id="l20.4421">           nsCString uri;</span>
<a href="#l20.4422"></a><span id="l20.4422">           rv = GetURI(uri);</span>
<a href="#l20.4423"></a><span id="l20.4423"> </span>
<a href="#l20.4424"></a><span id="l20.4424" class="difflineminus">-          if (!actionTargetFolderUri.Equals(uri))</span>
<a href="#l20.4425"></a><span id="l20.4425" class="difflineminus">-          {</span>
<a href="#l20.4426"></a><span id="l20.4426" class="difflineplus">+          if (!actionTargetFolderUri.Equals(uri)) {</span>
<a href="#l20.4427"></a><span id="l20.4427">             msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l20.4428"></a><span id="l20.4428"> </span>
<a href="#l20.4429"></a><span id="l20.4429" class="difflineminus">-            if (msgFlags &amp; nsMsgMessageFlags::MDNReportNeeded &amp;&amp; !isRead)</span>
<a href="#l20.4430"></a><span id="l20.4430" class="difflineminus">-            {</span>
<a href="#l20.4431"></a><span id="l20.4431" class="difflineminus">-               mDatabase-&gt;MarkMDNNeeded(msgKey, false, nullptr);</span>
<a href="#l20.4432"></a><span id="l20.4432" class="difflineminus">-               mDatabase-&gt;MarkMDNSent(msgKey, true, nullptr);</span>
<a href="#l20.4433"></a><span id="l20.4433" class="difflineplus">+            if (msgFlags &amp; nsMsgMessageFlags::MDNReportNeeded &amp;&amp; !isRead) {</span>
<a href="#l20.4434"></a><span id="l20.4434" class="difflineplus">+              mDatabase-&gt;MarkMDNNeeded(msgKey, false, nullptr);</span>
<a href="#l20.4435"></a><span id="l20.4435" class="difflineplus">+              mDatabase-&gt;MarkMDNSent(msgKey, true, nullptr);</span>
<a href="#l20.4436"></a><span id="l20.4436">             }</span>
<a href="#l20.4437"></a><span id="l20.4437" class="difflineminus">-            nsresult err = MoveIncorporatedMessage(msgHdr, mDatabase, actionTargetFolderUri, filter, msgWindow);</span>
<a href="#l20.4438"></a><span id="l20.4438" class="difflineminus">-            if (NS_SUCCEEDED(err))</span>
<a href="#l20.4439"></a><span id="l20.4439" class="difflineminus">-              m_msgMovedByFilter = true;</span>
<a href="#l20.4440"></a><span id="l20.4440" class="difflineplus">+            nsresult err = MoveIncorporatedMessage(</span>
<a href="#l20.4441"></a><span id="l20.4441" class="difflineplus">+                msgHdr, mDatabase, actionTargetFolderUri, filter, msgWindow);</span>
<a href="#l20.4442"></a><span id="l20.4442" class="difflineplus">+            if (NS_SUCCEEDED(err)) m_msgMovedByFilter = true;</span>
<a href="#l20.4443"></a><span id="l20.4443">           }</span>
<a href="#l20.4444"></a><span id="l20.4444" class="difflineminus">-          // don't apply any more filters, even if it was a move to the same folder</span>
<a href="#l20.4445"></a><span id="l20.4445" class="difflineplus">+          // don't apply any more filters, even if it was a move to the same</span>
<a href="#l20.4446"></a><span id="l20.4446" class="difflineplus">+          // folder</span>
<a href="#l20.4447"></a><span id="l20.4447">           *applyMore = false;</span>
<a href="#l20.4448"></a><span id="l20.4448" class="difflineminus">-        }</span>
<a href="#l20.4449"></a><span id="l20.4449" class="difflineminus">-        break;</span>
<a href="#l20.4450"></a><span id="l20.4450" class="difflineminus">-        case nsMsgFilterAction::CopyToFolder:</span>
<a href="#l20.4451"></a><span id="l20.4451" class="difflineminus">-        {</span>
<a href="#l20.4452"></a><span id="l20.4452" class="difflineplus">+        } break;</span>
<a href="#l20.4453"></a><span id="l20.4453" class="difflineplus">+        case nsMsgFilterAction::CopyToFolder: {</span>
<a href="#l20.4454"></a><span id="l20.4454">           nsCString uri;</span>
<a href="#l20.4455"></a><span id="l20.4455">           rv = GetURI(uri);</span>
<a href="#l20.4456"></a><span id="l20.4456"> </span>
<a href="#l20.4457"></a><span id="l20.4457" class="difflineminus">-          if (!actionTargetFolderUri.Equals(uri))</span>
<a href="#l20.4458"></a><span id="l20.4458" class="difflineminus">-          {</span>
<a href="#l20.4459"></a><span id="l20.4459" class="difflineplus">+          if (!actionTargetFolderUri.Equals(uri)) {</span>
<a href="#l20.4460"></a><span id="l20.4460">             // XXXshaver I'm not actually 100% what the right semantics are for</span>
<a href="#l20.4461"></a><span id="l20.4461">             // MDNs and copied messages, but I suspect deep down inside that</span>
<a href="#l20.4462"></a><span id="l20.4462">             // we probably want to suppress them only on the copies.</span>
<a href="#l20.4463"></a><span id="l20.4463">             msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l20.4464"></a><span id="l20.4464" class="difflineminus">-            if (msgFlags &amp; nsMsgMessageFlags::MDNReportNeeded &amp;&amp; !isRead)</span>
<a href="#l20.4465"></a><span id="l20.4465" class="difflineminus">-            {</span>
<a href="#l20.4466"></a><span id="l20.4466" class="difflineminus">-               mDatabase-&gt;MarkMDNNeeded(msgKey, false, nullptr);</span>
<a href="#l20.4467"></a><span id="l20.4467" class="difflineminus">-               mDatabase-&gt;MarkMDNSent(msgKey, true, nullptr);</span>
<a href="#l20.4468"></a><span id="l20.4468" class="difflineplus">+            if (msgFlags &amp; nsMsgMessageFlags::MDNReportNeeded &amp;&amp; !isRead) {</span>
<a href="#l20.4469"></a><span id="l20.4469" class="difflineplus">+              mDatabase-&gt;MarkMDNNeeded(msgKey, false, nullptr);</span>
<a href="#l20.4470"></a><span id="l20.4470" class="difflineplus">+              mDatabase-&gt;MarkMDNSent(msgKey, true, nullptr);</span>
<a href="#l20.4471"></a><span id="l20.4471">             }</span>
<a href="#l20.4472"></a><span id="l20.4472"> </span>
<a href="#l20.4473"></a><span id="l20.4473" class="difflineminus">-            nsCOMPtr&lt;nsIMutableArray&gt; messageArray(do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l20.4474"></a><span id="l20.4474" class="difflineplus">+            nsCOMPtr&lt;nsIMutableArray&gt; messageArray(</span>
<a href="#l20.4475"></a><span id="l20.4475" class="difflineplus">+                do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l20.4476"></a><span id="l20.4476">             NS_ENSURE_TRUE(messageArray, rv);</span>
<a href="#l20.4477"></a><span id="l20.4477">             messageArray-&gt;AppendElement(msgHdr);</span>
<a href="#l20.4478"></a><span id="l20.4478"> </span>
<a href="#l20.4479"></a><span id="l20.4479">             nsCOMPtr&lt;nsIMsgFolder&gt; dstFolder;</span>
<a href="#l20.4480"></a><span id="l20.4480" class="difflineminus">-            rv = GetExistingFolder(actionTargetFolderUri, getter_AddRefs(dstFolder));</span>
<a href="#l20.4481"></a><span id="l20.4481" class="difflineplus">+            rv = GetExistingFolder(actionTargetFolderUri,</span>
<a href="#l20.4482"></a><span id="l20.4482" class="difflineplus">+                                   getter_AddRefs(dstFolder));</span>
<a href="#l20.4483"></a><span id="l20.4483">             NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4484"></a><span id="l20.4484"> </span>
<a href="#l20.4485"></a><span id="l20.4485">             nsCOMPtr&lt;nsIMsgCopyService&gt; copyService =</span>
<a href="#l20.4486"></a><span id="l20.4486" class="difflineminus">-              do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.4487"></a><span id="l20.4487" class="difflineplus">+                do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.4488"></a><span id="l20.4488">             NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4489"></a><span id="l20.4489" class="difflineminus">-            rv = copyService-&gt;CopyMessages(this, messageArray, dstFolder,</span>
<a href="#l20.4490"></a><span id="l20.4490" class="difflineminus">-                                           false, nullptr, msgWindow, false);</span>
<a href="#l20.4491"></a><span id="l20.4491" class="difflineplus">+            rv = copyService-&gt;CopyMessages(this, messageArray, dstFolder, false,</span>
<a href="#l20.4492"></a><span id="l20.4492" class="difflineplus">+                                           nullptr, msgWindow, false);</span>
<a href="#l20.4493"></a><span id="l20.4493">             NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4494"></a><span id="l20.4494">           }</span>
<a href="#l20.4495"></a><span id="l20.4495" class="difflineminus">-        }</span>
<a href="#l20.4496"></a><span id="l20.4496" class="difflineminus">-        break;</span>
<a href="#l20.4497"></a><span id="l20.4497" class="difflineminus">-        case nsMsgFilterAction::MarkRead:</span>
<a href="#l20.4498"></a><span id="l20.4498" class="difflineminus">-        {</span>
<a href="#l20.4499"></a><span id="l20.4499" class="difflineplus">+        } break;</span>
<a href="#l20.4500"></a><span id="l20.4500" class="difflineplus">+        case nsMsgFilterAction::MarkRead: {</span>
<a href="#l20.4501"></a><span id="l20.4501">           mDatabase-&gt;MarkHdrRead(msgHdr, true, nullptr);</span>
<a href="#l20.4502"></a><span id="l20.4502">           StoreImapFlags(kImapMsgSeenFlag, true, &amp;msgKey, 1, nullptr);</span>
<a href="#l20.4503"></a><span id="l20.4503">           msgIsNew = false;</span>
<a href="#l20.4504"></a><span id="l20.4504" class="difflineminus">-        }</span>
<a href="#l20.4505"></a><span id="l20.4505" class="difflineminus">-        break;</span>
<a href="#l20.4506"></a><span id="l20.4506" class="difflineminus">-        case nsMsgFilterAction::MarkUnread:</span>
<a href="#l20.4507"></a><span id="l20.4507" class="difflineminus">-        {</span>
<a href="#l20.4508"></a><span id="l20.4508" class="difflineplus">+        } break;</span>
<a href="#l20.4509"></a><span id="l20.4509" class="difflineplus">+        case nsMsgFilterAction::MarkUnread: {</span>
<a href="#l20.4510"></a><span id="l20.4510">           mDatabase-&gt;MarkHdrRead(msgHdr, false, nullptr);</span>
<a href="#l20.4511"></a><span id="l20.4511">           StoreImapFlags(kImapMsgSeenFlag, false, &amp;msgKey, 1, nullptr);</span>
<a href="#l20.4512"></a><span id="l20.4512">           msgIsNew = true;</span>
<a href="#l20.4513"></a><span id="l20.4513" class="difflineminus">-        }</span>
<a href="#l20.4514"></a><span id="l20.4514" class="difflineminus">-        break;</span>
<a href="#l20.4515"></a><span id="l20.4515" class="difflineminus">-        case nsMsgFilterAction::MarkFlagged:</span>
<a href="#l20.4516"></a><span id="l20.4516" class="difflineminus">-        {</span>
<a href="#l20.4517"></a><span id="l20.4517" class="difflineplus">+        } break;</span>
<a href="#l20.4518"></a><span id="l20.4518" class="difflineplus">+        case nsMsgFilterAction::MarkFlagged: {</span>
<a href="#l20.4519"></a><span id="l20.4519">           mDatabase-&gt;MarkHdrMarked(msgHdr, true, nullptr);</span>
<a href="#l20.4520"></a><span id="l20.4520">           StoreImapFlags(kImapMsgFlaggedFlag, true, &amp;msgKey, 1, nullptr);</span>
<a href="#l20.4521"></a><span id="l20.4521" class="difflineminus">-        }</span>
<a href="#l20.4522"></a><span id="l20.4522" class="difflineminus">-        break;</span>
<a href="#l20.4523"></a><span id="l20.4523" class="difflineplus">+        } break;</span>
<a href="#l20.4524"></a><span id="l20.4524">         case nsMsgFilterAction::KillThread:</span>
<a href="#l20.4525"></a><span id="l20.4525" class="difflineminus">-        case nsMsgFilterAction::WatchThread:</span>
<a href="#l20.4526"></a><span id="l20.4526" class="difflineminus">-        {</span>
<a href="#l20.4527"></a><span id="l20.4527" class="difflineminus">-          nsCOMPtr &lt;nsIMsgThread&gt; msgThread;</span>
<a href="#l20.4528"></a><span id="l20.4528" class="difflineplus">+        case nsMsgFilterAction::WatchThread: {</span>
<a href="#l20.4529"></a><span id="l20.4529" class="difflineplus">+          nsCOMPtr&lt;nsIMsgThread&gt; msgThread;</span>
<a href="#l20.4530"></a><span id="l20.4530">           nsMsgKey threadKey;</span>
<a href="#l20.4531"></a><span id="l20.4531" class="difflineminus">-          mDatabase-&gt;GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(msgThread));</span>
<a href="#l20.4532"></a><span id="l20.4532" class="difflineminus">-          if (msgThread)</span>
<a href="#l20.4533"></a><span id="l20.4533" class="difflineminus">-          {</span>
<a href="#l20.4534"></a><span id="l20.4534" class="difflineplus">+          mDatabase-&gt;GetThreadContainingMsgHdr(msgHdr,</span>
<a href="#l20.4535"></a><span id="l20.4535" class="difflineplus">+                                               getter_AddRefs(msgThread));</span>
<a href="#l20.4536"></a><span id="l20.4536" class="difflineplus">+          if (msgThread) {</span>
<a href="#l20.4537"></a><span id="l20.4537">             msgThread-&gt;GetThreadKey(&amp;threadKey);</span>
<a href="#l20.4538"></a><span id="l20.4538">             if (actionType == nsMsgFilterAction::KillThread)</span>
<a href="#l20.4539"></a><span id="l20.4539">               mDatabase-&gt;MarkThreadIgnored(msgThread, threadKey, true, nullptr);</span>
<a href="#l20.4540"></a><span id="l20.4540">             else</span>
<a href="#l20.4541"></a><span id="l20.4541">               mDatabase-&gt;MarkThreadWatched(msgThread, threadKey, true, nullptr);</span>
<a href="#l20.4542"></a><span id="l20.4542" class="difflineminus">-          }</span>
<a href="#l20.4543"></a><span id="l20.4543" class="difflineminus">-          else</span>
<a href="#l20.4544"></a><span id="l20.4544" class="difflineminus">-          {</span>
<a href="#l20.4545"></a><span id="l20.4545" class="difflineplus">+          } else {</span>
<a href="#l20.4546"></a><span id="l20.4546">             if (actionType == nsMsgFilterAction::KillThread)</span>
<a href="#l20.4547"></a><span id="l20.4547" class="difflineminus">-              msgHdr-&gt;SetUint32Property(&quot;ProtoThreadFlags&quot;, nsMsgMessageFlags::Ignored);</span>
<a href="#l20.4548"></a><span id="l20.4548" class="difflineplus">+              msgHdr-&gt;SetUint32Property(&quot;ProtoThreadFlags&quot;,</span>
<a href="#l20.4549"></a><span id="l20.4549" class="difflineplus">+                                        nsMsgMessageFlags::Ignored);</span>
<a href="#l20.4550"></a><span id="l20.4550">             else</span>
<a href="#l20.4551"></a><span id="l20.4551" class="difflineminus">-              msgHdr-&gt;SetUint32Property(&quot;ProtoThreadFlags&quot;, nsMsgMessageFlags::Watched);</span>
<a href="#l20.4552"></a><span id="l20.4552" class="difflineplus">+              msgHdr-&gt;SetUint32Property(&quot;ProtoThreadFlags&quot;,</span>
<a href="#l20.4553"></a><span id="l20.4553" class="difflineplus">+                                        nsMsgMessageFlags::Watched);</span>
<a href="#l20.4554"></a><span id="l20.4554">           }</span>
<a href="#l20.4555"></a><span id="l20.4555" class="difflineminus">-          if (actionType == nsMsgFilterAction::KillThread)</span>
<a href="#l20.4556"></a><span id="l20.4556" class="difflineminus">-          {</span>
<a href="#l20.4557"></a><span id="l20.4557" class="difflineplus">+          if (actionType == nsMsgFilterAction::KillThread) {</span>
<a href="#l20.4558"></a><span id="l20.4558">             mDatabase-&gt;MarkHdrRead(msgHdr, true, nullptr);</span>
<a href="#l20.4559"></a><span id="l20.4559">             StoreImapFlags(kImapMsgSeenFlag, true, &amp;msgKey, 1, nullptr);</span>
<a href="#l20.4560"></a><span id="l20.4560">             msgIsNew = false;</span>
<a href="#l20.4561"></a><span id="l20.4561">           }</span>
<a href="#l20.4562"></a><span id="l20.4562" class="difflineminus">-        }</span>
<a href="#l20.4563"></a><span id="l20.4563" class="difflineminus">-        break;</span>
<a href="#l20.4564"></a><span id="l20.4564" class="difflineminus">-        case nsMsgFilterAction::KillSubthread:</span>
<a href="#l20.4565"></a><span id="l20.4565" class="difflineminus">-        {</span>
<a href="#l20.4566"></a><span id="l20.4566" class="difflineplus">+        } break;</span>
<a href="#l20.4567"></a><span id="l20.4567" class="difflineplus">+        case nsMsgFilterAction::KillSubthread: {</span>
<a href="#l20.4568"></a><span id="l20.4568">           mDatabase-&gt;MarkHeaderKilled(msgHdr, true, nullptr);</span>
<a href="#l20.4569"></a><span id="l20.4569">           mDatabase-&gt;MarkHdrRead(msgHdr, true, nullptr);</span>
<a href="#l20.4570"></a><span id="l20.4570">           StoreImapFlags(kImapMsgSeenFlag, true, &amp;msgKey, 1, nullptr);</span>
<a href="#l20.4571"></a><span id="l20.4571">           msgIsNew = false;</span>
<a href="#l20.4572"></a><span id="l20.4572" class="difflineminus">-        }</span>
<a href="#l20.4573"></a><span id="l20.4573" class="difflineminus">-        break;</span>
<a href="#l20.4574"></a><span id="l20.4574" class="difflineminus">-        case nsMsgFilterAction::ChangePriority:</span>
<a href="#l20.4575"></a><span id="l20.4575" class="difflineminus">-        {</span>
<a href="#l20.4576"></a><span id="l20.4576" class="difflineminus">-          nsMsgPriorityValue filterPriority; // a int32_t</span>
<a href="#l20.4577"></a><span id="l20.4577" class="difflineplus">+        } break;</span>
<a href="#l20.4578"></a><span id="l20.4578" class="difflineplus">+        case nsMsgFilterAction::ChangePriority: {</span>
<a href="#l20.4579"></a><span id="l20.4579" class="difflineplus">+          nsMsgPriorityValue filterPriority;  // a int32_t</span>
<a href="#l20.4580"></a><span id="l20.4580">           filterAction-&gt;GetPriority(&amp;filterPriority);</span>
<a href="#l20.4581"></a><span id="l20.4581" class="difflineminus">-          mDatabase-&gt;SetUint32PropertyByHdr(msgHdr, &quot;priority&quot;,</span>
<a href="#l20.4582"></a><span id="l20.4582" class="difflineminus">-                                            static_cast&lt;uint32_t&gt;(filterPriority));</span>
<a href="#l20.4583"></a><span id="l20.4583" class="difflineminus">-        }</span>
<a href="#l20.4584"></a><span id="l20.4584" class="difflineminus">-        break;</span>
<a href="#l20.4585"></a><span id="l20.4585" class="difflineminus">-        case nsMsgFilterAction::Label:</span>
<a href="#l20.4586"></a><span id="l20.4586" class="difflineminus">-        {</span>
<a href="#l20.4587"></a><span id="l20.4587" class="difflineplus">+          mDatabase-&gt;SetUint32PropertyByHdr(</span>
<a href="#l20.4588"></a><span id="l20.4588" class="difflineplus">+              msgHdr, &quot;priority&quot;, static_cast&lt;uint32_t&gt;(filterPriority));</span>
<a href="#l20.4589"></a><span id="l20.4589" class="difflineplus">+        } break;</span>
<a href="#l20.4590"></a><span id="l20.4590" class="difflineplus">+        case nsMsgFilterAction::Label: {</span>
<a href="#l20.4591"></a><span id="l20.4591">           nsMsgLabelValue filterLabel;</span>
<a href="#l20.4592"></a><span id="l20.4592">           filterAction-&gt;GetLabel(&amp;filterLabel);</span>
<a href="#l20.4593"></a><span id="l20.4593">           mDatabase-&gt;SetUint32PropertyByHdr(msgHdr, &quot;label&quot;,</span>
<a href="#l20.4594"></a><span id="l20.4594">                                             static_cast&lt;uint32_t&gt;(filterLabel));</span>
<a href="#l20.4595"></a><span id="l20.4595">           StoreImapFlags((filterLabel &lt;&lt; 9), true, &amp;msgKey, 1, nullptr);</span>
<a href="#l20.4596"></a><span id="l20.4596" class="difflineminus">-        }</span>
<a href="#l20.4597"></a><span id="l20.4597" class="difflineminus">-        break;</span>
<a href="#l20.4598"></a><span id="l20.4598" class="difflineminus">-        case nsMsgFilterAction::AddTag:</span>
<a href="#l20.4599"></a><span id="l20.4599" class="difflineminus">-        {</span>
<a href="#l20.4600"></a><span id="l20.4600" class="difflineplus">+        } break;</span>
<a href="#l20.4601"></a><span id="l20.4601" class="difflineplus">+        case nsMsgFilterAction::AddTag: {</span>
<a href="#l20.4602"></a><span id="l20.4602">           nsCString keyword;</span>
<a href="#l20.4603"></a><span id="l20.4603">           filterAction-&gt;GetStrValue(keyword);</span>
<a href="#l20.4604"></a><span id="l20.4604" class="difflineminus">-          nsCOMPtr&lt;nsIMutableArray&gt; messageArray(do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l20.4605"></a><span id="l20.4605" class="difflineplus">+          nsCOMPtr&lt;nsIMutableArray&gt; messageArray(</span>
<a href="#l20.4606"></a><span id="l20.4606" class="difflineplus">+              do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l20.4607"></a><span id="l20.4607">           NS_ENSURE_TRUE(messageArray, rv);</span>
<a href="#l20.4608"></a><span id="l20.4608">           messageArray-&gt;AppendElement(msgHdr);</span>
<a href="#l20.4609"></a><span id="l20.4609">           AddKeywordsToMessages(messageArray, keyword);</span>
<a href="#l20.4610"></a><span id="l20.4610">           break;</span>
<a href="#l20.4611"></a><span id="l20.4611">         }</span>
<a href="#l20.4612"></a><span id="l20.4612" class="difflineminus">-        case nsMsgFilterAction::JunkScore:</span>
<a href="#l20.4613"></a><span id="l20.4613" class="difflineminus">-        {</span>
<a href="#l20.4614"></a><span id="l20.4614" class="difflineplus">+        case nsMsgFilterAction::JunkScore: {</span>
<a href="#l20.4615"></a><span id="l20.4615">           nsAutoCString junkScoreStr;</span>
<a href="#l20.4616"></a><span id="l20.4616">           int32_t junkScore;</span>
<a href="#l20.4617"></a><span id="l20.4617">           filterAction-&gt;GetJunkScore(&amp;junkScore);</span>
<a href="#l20.4618"></a><span id="l20.4618">           junkScoreStr.AppendInt(junkScore);</span>
<a href="#l20.4619"></a><span id="l20.4619">           mDatabase-&gt;SetStringProperty(msgKey, &quot;junkscore&quot;, junkScoreStr.get());</span>
<a href="#l20.4620"></a><span id="l20.4620">           mDatabase-&gt;SetStringProperty(msgKey, &quot;junkscoreorigin&quot;, &quot;filter&quot;);</span>
<a href="#l20.4621"></a><span id="l20.4621"> </span>
<a href="#l20.4622"></a><span id="l20.4622">           // If score is available, set up to store junk status on server.</span>
<a href="#l20.4623"></a><span id="l20.4623">           if (junkScore == nsIJunkMailPlugin::IS_SPAM_SCORE ||</span>
<a href="#l20.4624"></a><span id="l20.4624" class="difflineminus">-              junkScore == nsIJunkMailPlugin::IS_HAM_SCORE)</span>
<a href="#l20.4625"></a><span id="l20.4625" class="difflineminus">-          {</span>
<a href="#l20.4626"></a><span id="l20.4626" class="difflineplus">+              junkScore == nsIJunkMailPlugin::IS_HAM_SCORE) {</span>
<a href="#l20.4627"></a><span id="l20.4627">             nsTArray&lt;nsMsgKey&gt; *keysToClassify = m_moveCoalescer-&gt;GetKeyBucket(</span>
<a href="#l20.4628"></a><span id="l20.4628" class="difflineminus">-                       (junkScore == nsIJunkMailPlugin::IS_SPAM_SCORE) ? 0 : 1);</span>
<a href="#l20.4629"></a><span id="l20.4629" class="difflineplus">+                (junkScore == nsIJunkMailPlugin::IS_SPAM_SCORE) ? 0 : 1);</span>
<a href="#l20.4630"></a><span id="l20.4630">             NS_ASSERTION(keysToClassify, &quot;error getting key bucket&quot;);</span>
<a href="#l20.4631"></a><span id="l20.4631" class="difflineminus">-            if (keysToClassify)</span>
<a href="#l20.4632"></a><span id="l20.4632" class="difflineminus">-              keysToClassify-&gt;AppendElement(msgKey);</span>
<a href="#l20.4633"></a><span id="l20.4633" class="difflineminus">-            if (msgIsNew &amp;&amp; junkScore == nsIJunkMailPlugin::IS_SPAM_SCORE)</span>
<a href="#l20.4634"></a><span id="l20.4634" class="difflineminus">-            {</span>
<a href="#l20.4635"></a><span id="l20.4635" class="difflineplus">+            if (keysToClassify) keysToClassify-&gt;AppendElement(msgKey);</span>
<a href="#l20.4636"></a><span id="l20.4636" class="difflineplus">+            if (msgIsNew &amp;&amp; junkScore == nsIJunkMailPlugin::IS_SPAM_SCORE) {</span>
<a href="#l20.4637"></a><span id="l20.4637">               msgIsNew = false;</span>
<a href="#l20.4638"></a><span id="l20.4638">               mDatabase-&gt;MarkHdrNotNew(msgHdr, nullptr);</span>
<a href="#l20.4639"></a><span id="l20.4639">               // nsMsgDBFolder::SendFlagNotifications by the call to</span>
<a href="#l20.4640"></a><span id="l20.4640">               // SetBiffState(nsMsgBiffState_NoMail) will reset numNewMessages</span>
<a href="#l20.4641"></a><span id="l20.4641">               // only if the message is also read and database notifications</span>
<a href="#l20.4642"></a><span id="l20.4642">               // are active, but we are not going to mark it read in this</span>
<a href="#l20.4643"></a><span id="l20.4643">               // action, preferring to leave the choice to the user.</span>
<a href="#l20.4644"></a><span id="l20.4644">               // So correct numNewMessages.</span>
<a href="#l20.4645"></a><span id="l20.4645" class="difflineminus">-              if (m_filterListRequiresBody)</span>
<a href="#l20.4646"></a><span id="l20.4646" class="difflineminus">-              {</span>
<a href="#l20.4647"></a><span id="l20.4647" class="difflineplus">+              if (m_filterListRequiresBody) {</span>
<a href="#l20.4648"></a><span id="l20.4648">                 msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l20.4649"></a><span id="l20.4649" class="difflineminus">-                if (!(msgFlags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l20.4650"></a><span id="l20.4650" class="difflineminus">-                {</span>
<a href="#l20.4651"></a><span id="l20.4651" class="difflineplus">+                if (!(msgFlags &amp; nsMsgMessageFlags::Read)) {</span>
<a href="#l20.4652"></a><span id="l20.4652">                   int32_t numNewMessages;</span>
<a href="#l20.4653"></a><span id="l20.4653">                   GetNumNewMessages(false, &amp;numNewMessages);</span>
<a href="#l20.4654"></a><span id="l20.4654">                   SetNumNewMessages(--numNewMessages);</span>
<a href="#l20.4655"></a><span id="l20.4655">                   SetHasNewMessages(numNewMessages != 0);</span>
<a href="#l20.4656"></a><span id="l20.4656">                 }</span>
<a href="#l20.4657"></a><span id="l20.4657">               }</span>
<a href="#l20.4658"></a><span id="l20.4658">             }</span>
<a href="#l20.4659"></a><span id="l20.4659">           }</span>
<a href="#l20.4660"></a><span id="l20.4660" class="difflineminus">-        }</span>
<a href="#l20.4661"></a><span id="l20.4661" class="difflineminus">-        break;</span>
<a href="#l20.4662"></a><span id="l20.4662" class="difflineminus">-      case nsMsgFilterAction::Forward:</span>
<a href="#l20.4663"></a><span id="l20.4663" class="difflineminus">-        {</span>
<a href="#l20.4664"></a><span id="l20.4664" class="difflineplus">+        } break;</span>
<a href="#l20.4665"></a><span id="l20.4665" class="difflineplus">+        case nsMsgFilterAction::Forward: {</span>
<a href="#l20.4666"></a><span id="l20.4666">           nsCString forwardTo;</span>
<a href="#l20.4667"></a><span id="l20.4667">           filterAction-&gt;GetStrValue(forwardTo);</span>
<a href="#l20.4668"></a><span id="l20.4668">           nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.4669"></a><span id="l20.4669">           rv = GetServer(getter_AddRefs(server));</span>
<a href="#l20.4670"></a><span id="l20.4670">           NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4671"></a><span id="l20.4671" class="difflineminus">-          if (!forwardTo.IsEmpty())</span>
<a href="#l20.4672"></a><span id="l20.4672" class="difflineminus">-          {</span>
<a href="#l20.4673"></a><span id="l20.4673" class="difflineplus">+          if (!forwardTo.IsEmpty()) {</span>
<a href="#l20.4674"></a><span id="l20.4674">             nsCOMPtr&lt;nsIMsgComposeService&gt; compService =</span>
<a href="#l20.4675"></a><span id="l20.4675" class="difflineminus">-              do_GetService (NS_MSGCOMPOSESERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.4676"></a><span id="l20.4676" class="difflineplus">+                do_GetService(NS_MSGCOMPOSESERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.4677"></a><span id="l20.4677">             NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4678"></a><span id="l20.4678" class="difflineminus">-            rv = compService-&gt;ForwardMessage(NS_ConvertASCIItoUTF16(forwardTo),</span>
<a href="#l20.4679"></a><span id="l20.4679" class="difflineminus">-                                             msgHdr, msgWindow, server,</span>
<a href="#l20.4680"></a><span id="l20.4680" class="difflineminus">-                                             nsIMsgComposeService::kForwardAsDefault);</span>
<a href="#l20.4681"></a><span id="l20.4681" class="difflineplus">+            rv = compService-&gt;ForwardMessage(</span>
<a href="#l20.4682"></a><span id="l20.4682" class="difflineplus">+                NS_ConvertASCIItoUTF16(forwardTo), msgHdr, msgWindow, server,</span>
<a href="#l20.4683"></a><span id="l20.4683" class="difflineplus">+                nsIMsgComposeService::kForwardAsDefault);</span>
<a href="#l20.4684"></a><span id="l20.4684">           }</span>
<a href="#l20.4685"></a><span id="l20.4685" class="difflineminus">-        }</span>
<a href="#l20.4686"></a><span id="l20.4686" class="difflineminus">-        break;</span>
<a href="#l20.4687"></a><span id="l20.4687" class="difflineminus">-</span>
<a href="#l20.4688"></a><span id="l20.4688" class="difflineminus">-      case nsMsgFilterAction::Reply:</span>
<a href="#l20.4689"></a><span id="l20.4689" class="difflineminus">-        {</span>
<a href="#l20.4690"></a><span id="l20.4690" class="difflineplus">+        } break;</span>
<a href="#l20.4691"></a><span id="l20.4691" class="difflineplus">+</span>
<a href="#l20.4692"></a><span id="l20.4692" class="difflineplus">+        case nsMsgFilterAction::Reply: {</span>
<a href="#l20.4693"></a><span id="l20.4693">           nsCString replyTemplateUri;</span>
<a href="#l20.4694"></a><span id="l20.4694">           filterAction-&gt;GetStrValue(replyTemplateUri);</span>
<a href="#l20.4695"></a><span id="l20.4695" class="difflineminus">-          nsCOMPtr &lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.4696"></a><span id="l20.4696" class="difflineplus">+          nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.4697"></a><span id="l20.4697">           GetServer(getter_AddRefs(server));</span>
<a href="#l20.4698"></a><span id="l20.4698">           NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4699"></a><span id="l20.4699" class="difflineminus">-          if (!replyTemplateUri.IsEmpty())</span>
<a href="#l20.4700"></a><span id="l20.4700" class="difflineminus">-          {</span>
<a href="#l20.4701"></a><span id="l20.4701" class="difflineminus">-            nsCOMPtr &lt;nsIMsgComposeService&gt; compService = do_GetService (NS_MSGCOMPOSESERVICE_CONTRACTID) ;</span>
<a href="#l20.4702"></a><span id="l20.4702" class="difflineplus">+          if (!replyTemplateUri.IsEmpty()) {</span>
<a href="#l20.4703"></a><span id="l20.4703" class="difflineplus">+            nsCOMPtr&lt;nsIMsgComposeService&gt; compService =</span>
<a href="#l20.4704"></a><span id="l20.4704" class="difflineplus">+                do_GetService(NS_MSGCOMPOSESERVICE_CONTRACTID);</span>
<a href="#l20.4705"></a><span id="l20.4705">             if (compService) {</span>
<a href="#l20.4706"></a><span id="l20.4706" class="difflineminus">-              rv = compService-&gt;ReplyWithTemplate(msgHdr, replyTemplateUri.get(), msgWindow, server);</span>
<a href="#l20.4707"></a><span id="l20.4707" class="difflineplus">+              rv = compService-&gt;ReplyWithTemplate(</span>
<a href="#l20.4708"></a><span id="l20.4708" class="difflineplus">+                  msgHdr, replyTemplateUri.get(), msgWindow, server);</span>
<a href="#l20.4709"></a><span id="l20.4709">               if (NS_FAILED(rv)) {</span>
<a href="#l20.4710"></a><span id="l20.4710">                 NS_WARNING(&quot;ReplyWithTemplate failed&quot;);</span>
<a href="#l20.4711"></a><span id="l20.4711">                 if (rv == NS_ERROR_ABORT) {</span>
<a href="#l20.4712"></a><span id="l20.4712" class="difflineminus">-                  (void) filter-&gt;LogRuleHitFail(filterAction, msgHdr, rv,</span>
<a href="#l20.4713"></a><span id="l20.4713" class="difflineminus">-                                                NS_LITERAL_CSTRING(&quot;filterFailureSendingReplyAborted&quot;));</span>
<a href="#l20.4714"></a><span id="l20.4714" class="difflineplus">+                  (void)filter-&gt;LogRuleHitFail(</span>
<a href="#l20.4715"></a><span id="l20.4715" class="difflineplus">+                      filterAction, msgHdr, rv,</span>
<a href="#l20.4716"></a><span id="l20.4716" class="difflineplus">+                      NS_LITERAL_CSTRING(&quot;filterFailureSendingReplyAborted&quot;));</span>
<a href="#l20.4717"></a><span id="l20.4717">                 } else {</span>
<a href="#l20.4718"></a><span id="l20.4718" class="difflineminus">-                  (void) filter-&gt;LogRuleHitFail(filterAction, msgHdr, rv,</span>
<a href="#l20.4719"></a><span id="l20.4719" class="difflineminus">-                                                NS_LITERAL_CSTRING(&quot;filterFailureSendingReplyError&quot;));</span>
<a href="#l20.4720"></a><span id="l20.4720" class="difflineplus">+                  (void)filter-&gt;LogRuleHitFail(</span>
<a href="#l20.4721"></a><span id="l20.4721" class="difflineplus">+                      filterAction, msgHdr, rv,</span>
<a href="#l20.4722"></a><span id="l20.4722" class="difflineplus">+                      NS_LITERAL_CSTRING(&quot;filterFailureSendingReplyError&quot;));</span>
<a href="#l20.4723"></a><span id="l20.4723">                 }</span>
<a href="#l20.4724"></a><span id="l20.4724">               }</span>
<a href="#l20.4725"></a><span id="l20.4725">             }</span>
<a href="#l20.4726"></a><span id="l20.4726">           }</span>
<a href="#l20.4727"></a><span id="l20.4727" class="difflineminus">-        }</span>
<a href="#l20.4728"></a><span id="l20.4728" class="difflineminus">-        break;</span>
<a href="#l20.4729"></a><span id="l20.4729" class="difflineminus">-</span>
<a href="#l20.4730"></a><span id="l20.4730" class="difflineminus">-        case nsMsgFilterAction::StopExecution:</span>
<a href="#l20.4731"></a><span id="l20.4731" class="difflineminus">-        {</span>
<a href="#l20.4732"></a><span id="l20.4732" class="difflineplus">+        } break;</span>
<a href="#l20.4733"></a><span id="l20.4733" class="difflineplus">+</span>
<a href="#l20.4734"></a><span id="l20.4734" class="difflineplus">+        case nsMsgFilterAction::StopExecution: {</span>
<a href="#l20.4735"></a><span id="l20.4735">           // don't apply any more filters</span>
<a href="#l20.4736"></a><span id="l20.4736">           *applyMore = false;</span>
<a href="#l20.4737"></a><span id="l20.4737" class="difflineminus">-        }</span>
<a href="#l20.4738"></a><span id="l20.4738" class="difflineminus">-        break;</span>
<a href="#l20.4739"></a><span id="l20.4739" class="difflineminus">-</span>
<a href="#l20.4740"></a><span id="l20.4740" class="difflineminus">-        case nsMsgFilterAction::Custom:</span>
<a href="#l20.4741"></a><span id="l20.4741" class="difflineminus">-        {</span>
<a href="#l20.4742"></a><span id="l20.4742" class="difflineplus">+        } break;</span>
<a href="#l20.4743"></a><span id="l20.4743" class="difflineplus">+</span>
<a href="#l20.4744"></a><span id="l20.4744" class="difflineplus">+        case nsMsgFilterAction::Custom: {</span>
<a href="#l20.4745"></a><span id="l20.4745">           nsCOMPtr&lt;nsIMsgFilterCustomAction&gt; customAction;</span>
<a href="#l20.4746"></a><span id="l20.4746">           rv = filterAction-&gt;GetCustomAction(getter_AddRefs(customAction));</span>
<a href="#l20.4747"></a><span id="l20.4747">           NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4748"></a><span id="l20.4748"> </span>
<a href="#l20.4749"></a><span id="l20.4749">           nsAutoCString value;</span>
<a href="#l20.4750"></a><span id="l20.4750">           filterAction-&gt;GetStrValue(value);</span>
<a href="#l20.4751"></a><span id="l20.4751"> </span>
<a href="#l20.4752"></a><span id="l20.4752">           nsCOMPtr&lt;nsIMutableArray&gt; messageArray(</span>
<a href="#l20.4753"></a><span id="l20.4753">               do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l20.4754"></a><span id="l20.4754">           NS_ENSURE_TRUE(messageArray, rv);</span>
<a href="#l20.4755"></a><span id="l20.4755">           messageArray-&gt;AppendElement(msgHdr);</span>
<a href="#l20.4756"></a><span id="l20.4756"> </span>
<a href="#l20.4757"></a><span id="l20.4757">           customAction-&gt;Apply(messageArray, value, nullptr,</span>
<a href="#l20.4758"></a><span id="l20.4758">                               nsMsgFilterType::InboxRule, msgWindow);</span>
<a href="#l20.4759"></a><span id="l20.4759">           // allow custom action to affect new</span>
<a href="#l20.4760"></a><span id="l20.4760">           msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l20.4761"></a><span id="l20.4761" class="difflineminus">-          if (!(msgFlags &amp; nsMsgMessageFlags::New))</span>
<a href="#l20.4762"></a><span id="l20.4762" class="difflineminus">-            msgIsNew = false;</span>
<a href="#l20.4763"></a><span id="l20.4763" class="difflineminus">-        }</span>
<a href="#l20.4764"></a><span id="l20.4764" class="difflineminus">-        break;</span>
<a href="#l20.4765"></a><span id="l20.4765" class="difflineplus">+          if (!(msgFlags &amp; nsMsgMessageFlags::New)) msgIsNew = false;</span>
<a href="#l20.4766"></a><span id="l20.4766" class="difflineplus">+        } break;</span>
<a href="#l20.4767"></a><span id="l20.4767"> </span>
<a href="#l20.4768"></a><span id="l20.4768">         default:</span>
<a href="#l20.4769"></a><span id="l20.4769">           break;</span>
<a href="#l20.4770"></a><span id="l20.4770">       }</span>
<a href="#l20.4771"></a><span id="l20.4771">     }</span>
<a href="#l20.4772"></a><span id="l20.4772">   }</span>
<a href="#l20.4773"></a><span id="l20.4773" class="difflineminus">-  if (!msgIsNew)</span>
<a href="#l20.4774"></a><span id="l20.4774" class="difflineminus">-  {</span>
<a href="#l20.4775"></a><span id="l20.4775" class="difflineplus">+  if (!msgIsNew) {</span>
<a href="#l20.4776"></a><span id="l20.4776">     int32_t numNewMessages;</span>
<a href="#l20.4777"></a><span id="l20.4777">     GetNumNewMessages(false, &amp;numNewMessages);</span>
<a href="#l20.4778"></a><span id="l20.4778">     // When database notifications are active, new counts will be reset</span>
<a href="#l20.4779"></a><span id="l20.4779">     // to zero in nsMsgDBFolder::SendFlagNotifications by the call to</span>
<a href="#l20.4780"></a><span id="l20.4780">     // SetBiffState(nsMsgBiffState_NoMail), so don't repeat them here.</span>
<a href="#l20.4781"></a><span id="l20.4781" class="difflineminus">-    if (!m_filterListRequiresBody)</span>
<a href="#l20.4782"></a><span id="l20.4782" class="difflineminus">-      SetNumNewMessages(--numNewMessages);</span>
<a href="#l20.4783"></a><span id="l20.4783" class="difflineminus">-    if (mDatabase)</span>
<a href="#l20.4784"></a><span id="l20.4784" class="difflineminus">-      mDatabase-&gt;MarkHdrNotNew(msgHdr, nullptr);</span>
<a href="#l20.4785"></a><span id="l20.4785" class="difflineplus">+    if (!m_filterListRequiresBody) SetNumNewMessages(--numNewMessages);</span>
<a href="#l20.4786"></a><span id="l20.4786" class="difflineplus">+    if (mDatabase) mDatabase-&gt;MarkHdrNotNew(msgHdr, nullptr);</span>
<a href="#l20.4787"></a><span id="l20.4787">   }</span>
<a href="#l20.4788"></a><span id="l20.4788">   return NS_OK;</span>
<a href="#l20.4789"></a><span id="l20.4789"> }</span>
<a href="#l20.4790"></a><span id="l20.4790"> </span>
<a href="#l20.4791"></a><span id="l20.4791" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetImapFlags(const char *uids, int32_t flags, nsIURI **url)</span>
<a href="#l20.4792"></a><span id="l20.4792" class="difflineminus">-{</span>
<a href="#l20.4793"></a><span id="l20.4793" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetImapFlags(const char *uids, int32_t flags,</span>
<a href="#l20.4794"></a><span id="l20.4794" class="difflineplus">+                                             nsIURI **url) {</span>
<a href="#l20.4795"></a><span id="l20.4795">   nsresult rv;</span>
<a href="#l20.4796"></a><span id="l20.4796" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.4797"></a><span id="l20.4797" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.4798"></a><span id="l20.4798" class="difflineminus">-</span>
<a href="#l20.4799"></a><span id="l20.4799" class="difflineminus">-  return imapService-&gt;SetMessageFlags(this, this, url, nsAutoCString(uids), flags, true);</span>
<a href="#l20.4800"></a><span id="l20.4800" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.4801"></a><span id="l20.4801" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.4802"></a><span id="l20.4802" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4803"></a><span id="l20.4803" class="difflineplus">+</span>
<a href="#l20.4804"></a><span id="l20.4804" class="difflineplus">+  return imapService-&gt;SetMessageFlags(this, this, url, nsAutoCString(uids),</span>
<a href="#l20.4805"></a><span id="l20.4805" class="difflineplus">+                                      flags, true);</span>
<a href="#l20.4806"></a><span id="l20.4806"> }</span>
<a href="#l20.4807"></a><span id="l20.4807"> </span>
<a href="#l20.4808"></a><span id="l20.4808"> // &quot;this&quot; is the parent folder</span>
<a href="#l20.4809"></a><span id="l20.4809" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::PlaybackOfflineFolderCreate(const nsAString&amp; aFolderName, nsIMsgWindow *aWindow, nsIURI **url)</span>
<a href="#l20.4810"></a><span id="l20.4810" class="difflineminus">-{</span>
<a href="#l20.4811"></a><span id="l20.4811" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::PlaybackOfflineFolderCreate(</span>
<a href="#l20.4812"></a><span id="l20.4812" class="difflineplus">+    const nsAString &amp;aFolderName, nsIMsgWindow *aWindow, nsIURI **url) {</span>
<a href="#l20.4813"></a><span id="l20.4813">   nsresult rv;</span>
<a href="#l20.4814"></a><span id="l20.4814" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.4815"></a><span id="l20.4815" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.4816"></a><span id="l20.4816" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.4817"></a><span id="l20.4817" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.4818"></a><span id="l20.4818" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4819"></a><span id="l20.4819">   return imapService-&gt;CreateFolder(this, aFolderName, this, url);</span>
<a href="#l20.4820"></a><span id="l20.4820"> }</span>
<a href="#l20.4821"></a><span id="l20.4821"> </span>
<a href="#l20.4822"></a><span id="l20.4822"> NS_IMETHODIMP</span>
<a href="#l20.4823"></a><span id="l20.4823"> nsImapMailFolder::ReplayOfflineMoveCopy(nsMsgKey *aMsgKeys, uint32_t aNumKeys,</span>
<a href="#l20.4824"></a><span id="l20.4824">                                         bool isMove, nsIMsgFolder *aDstFolder,</span>
<a href="#l20.4825"></a><span id="l20.4825" class="difflineminus">-                                        nsIUrlListener *aUrlListener, nsIMsgWindow *aWindow)</span>
<a href="#l20.4826"></a><span id="l20.4826" class="difflineminus">-{</span>
<a href="#l20.4827"></a><span id="l20.4827" class="difflineplus">+                                        nsIUrlListener *aUrlListener,</span>
<a href="#l20.4828"></a><span id="l20.4828" class="difflineplus">+                                        nsIMsgWindow *aWindow) {</span>
<a href="#l20.4829"></a><span id="l20.4829">   nsresult rv;</span>
<a href="#l20.4830"></a><span id="l20.4830"> </span>
<a href="#l20.4831"></a><span id="l20.4831" class="difflineminus">-  nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(aDstFolder);</span>
<a href="#l20.4832"></a><span id="l20.4832" class="difflineminus">-  if (imapFolder)</span>
<a href="#l20.4833"></a><span id="l20.4833" class="difflineminus">-  {</span>
<a href="#l20.4834"></a><span id="l20.4834" class="difflineminus">-    nsImapMailFolder *destImapFolder = static_cast&lt;nsImapMailFolder*&gt;(aDstFolder);</span>
<a href="#l20.4835"></a><span id="l20.4835" class="difflineplus">+  nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(aDstFolder);</span>
<a href="#l20.4836"></a><span id="l20.4836" class="difflineplus">+  if (imapFolder) {</span>
<a href="#l20.4837"></a><span id="l20.4837" class="difflineplus">+    nsImapMailFolder *destImapFolder =</span>
<a href="#l20.4838"></a><span id="l20.4838" class="difflineplus">+        static_cast&lt;nsImapMailFolder *&gt;(aDstFolder);</span>
<a href="#l20.4839"></a><span id="l20.4839">     nsCOMPtr&lt;nsIMutableArray&gt; messages(do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l20.4840"></a><span id="l20.4840">     nsCOMPtr&lt;nsIMsgDatabase&gt; dstFolderDB;</span>
<a href="#l20.4841"></a><span id="l20.4841">     aDstFolder-&gt;GetMsgDatabase(getter_AddRefs(dstFolderDB));</span>
<a href="#l20.4842"></a><span id="l20.4842" class="difflineminus">-    if (dstFolderDB)</span>
<a href="#l20.4843"></a><span id="l20.4843" class="difflineminus">-    {</span>
<a href="#l20.4844"></a><span id="l20.4844" class="difflineplus">+    if (dstFolderDB) {</span>
<a href="#l20.4845"></a><span id="l20.4845">       // find the fake header in the destination db, and use that to</span>
<a href="#l20.4846"></a><span id="l20.4846">       // set the pending attributes on the real headers. To do this,</span>
<a href="#l20.4847"></a><span id="l20.4847">       // we need to iterate over the offline ops in the destination db,</span>
<a href="#l20.4848"></a><span id="l20.4848">       // looking for ones with matching keys and source folder uri.</span>
<a href="#l20.4849"></a><span id="l20.4849">       // If we find that offline op, its &quot;key&quot; will be the key of the fake</span>
<a href="#l20.4850"></a><span id="l20.4850">       // header, so we just need to get the header for that key</span>
<a href="#l20.4851"></a><span id="l20.4851">       // from the dest db.</span>
<a href="#l20.4852"></a><span id="l20.4852">       nsTArray&lt;nsMsgKey&gt; offlineOps;</span>
<a href="#l20.4853"></a><span id="l20.4853" class="difflineminus">-      if (NS_SUCCEEDED(dstFolderDB-&gt;ListAllOfflineOpIds(&amp;offlineOps)))</span>
<a href="#l20.4854"></a><span id="l20.4854" class="difflineminus">-      {</span>
<a href="#l20.4855"></a><span id="l20.4855" class="difflineplus">+      if (NS_SUCCEEDED(dstFolderDB-&gt;ListAllOfflineOpIds(&amp;offlineOps))) {</span>
<a href="#l20.4856"></a><span id="l20.4856">         nsCString srcFolderUri;</span>
<a href="#l20.4857"></a><span id="l20.4857">         GetURI(srcFolderUri);</span>
<a href="#l20.4858"></a><span id="l20.4858">         nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; currentOp;</span>
<a href="#l20.4859"></a><span id="l20.4859" class="difflineminus">-        for (uint32_t opIndex = 0; opIndex &lt; offlineOps.Length(); opIndex++)</span>
<a href="#l20.4860"></a><span id="l20.4860" class="difflineminus">-        {</span>
<a href="#l20.4861"></a><span id="l20.4861" class="difflineplus">+        for (uint32_t opIndex = 0; opIndex &lt; offlineOps.Length(); opIndex++) {</span>
<a href="#l20.4862"></a><span id="l20.4862">           dstFolderDB-&gt;GetOfflineOpForKey(offlineOps[opIndex], false,</span>
<a href="#l20.4863"></a><span id="l20.4863">                                           getter_AddRefs(currentOp));</span>
<a href="#l20.4864"></a><span id="l20.4864" class="difflineminus">-          if (currentOp)</span>
<a href="#l20.4865"></a><span id="l20.4865" class="difflineminus">-          {</span>
<a href="#l20.4866"></a><span id="l20.4866" class="difflineplus">+          if (currentOp) {</span>
<a href="#l20.4867"></a><span id="l20.4867">             nsCString opSrcUri;</span>
<a href="#l20.4868"></a><span id="l20.4868">             currentOp-&gt;GetSourceFolderURI(getter_Copies(opSrcUri));</span>
<a href="#l20.4869"></a><span id="l20.4869" class="difflineminus">-            if (opSrcUri.Equals(srcFolderUri))</span>
<a href="#l20.4870"></a><span id="l20.4870" class="difflineminus">-            {</span>
<a href="#l20.4871"></a><span id="l20.4871" class="difflineplus">+            if (opSrcUri.Equals(srcFolderUri)) {</span>
<a href="#l20.4872"></a><span id="l20.4872">               nsMsgKey srcMessageKey;</span>
<a href="#l20.4873"></a><span id="l20.4873">               currentOp-&gt;GetSrcMessageKey(&amp;srcMessageKey);</span>
<a href="#l20.4874"></a><span id="l20.4874" class="difflineminus">-              for (uint32_t msgIndex = 0; msgIndex &lt; aNumKeys; msgIndex++)</span>
<a href="#l20.4875"></a><span id="l20.4875" class="difflineminus">-              {</span>
<a href="#l20.4876"></a><span id="l20.4876" class="difflineminus">-                if (srcMessageKey == aMsgKeys[msgIndex])</span>
<a href="#l20.4877"></a><span id="l20.4877" class="difflineminus">-                {</span>
<a href="#l20.4878"></a><span id="l20.4878" class="difflineplus">+              for (uint32_t msgIndex = 0; msgIndex &lt; aNumKeys; msgIndex++) {</span>
<a href="#l20.4879"></a><span id="l20.4879" class="difflineplus">+                if (srcMessageKey == aMsgKeys[msgIndex]) {</span>
<a href="#l20.4880"></a><span id="l20.4880">                   nsCOMPtr&lt;nsIMsgDBHdr&gt; fakeDestHdr;</span>
<a href="#l20.4881"></a><span id="l20.4881">                   dstFolderDB-&gt;GetMsgHdrForKey(offlineOps[opIndex],</span>
<a href="#l20.4882"></a><span id="l20.4882" class="difflineminus">-                    getter_AddRefs(fakeDestHdr));</span>
<a href="#l20.4883"></a><span id="l20.4883" class="difflineminus">-                  if (fakeDestHdr)</span>
<a href="#l20.4884"></a><span id="l20.4884" class="difflineminus">-                    messages-&gt;AppendElement(fakeDestHdr);</span>
<a href="#l20.4885"></a><span id="l20.4885" class="difflineplus">+                                               getter_AddRefs(fakeDestHdr));</span>
<a href="#l20.4886"></a><span id="l20.4886" class="difflineplus">+                  if (fakeDestHdr) messages-&gt;AppendElement(fakeDestHdr);</span>
<a href="#l20.4887"></a><span id="l20.4887">                   break;</span>
<a href="#l20.4888"></a><span id="l20.4888">                 }</span>
<a href="#l20.4889"></a><span id="l20.4889">               }</span>
<a href="#l20.4890"></a><span id="l20.4890">             }</span>
<a href="#l20.4891"></a><span id="l20.4891">           }</span>
<a href="#l20.4892"></a><span id="l20.4892">         }</span>
<a href="#l20.4893"></a><span id="l20.4893">         // 3rd parameter: Set offline flag.</span>
<a href="#l20.4894"></a><span id="l20.4894">         destImapFolder-&gt;SetPendingAttributes(messages, isMove, true);</span>
<a href="#l20.4895"></a><span id="l20.4895">       }</span>
<a href="#l20.4896"></a><span id="l20.4896">     }</span>
<a href="#l20.4897"></a><span id="l20.4897">     // if we can't get the dst folder db, we should still try to playback</span>
<a href="#l20.4898"></a><span id="l20.4898">     // the offline move/copy.</span>
<a href="#l20.4899"></a><span id="l20.4899">   }</span>
<a href="#l20.4900"></a><span id="l20.4900"> </span>
<a href="#l20.4901"></a><span id="l20.4901" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.4902"></a><span id="l20.4902" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.4903"></a><span id="l20.4903" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.4904"></a><span id="l20.4904">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4905"></a><span id="l20.4905" class="difflineminus">-  nsCOMPtr &lt;nsIURI&gt; resultUrl;</span>
<a href="#l20.4906"></a><span id="l20.4906" class="difflineplus">+  nsCOMPtr&lt;nsIURI&gt; resultUrl;</span>
<a href="#l20.4907"></a><span id="l20.4907">   nsAutoCString uids;</span>
<a href="#l20.4908"></a><span id="l20.4908">   AllocateUidStringFromKeys(aMsgKeys, aNumKeys, uids);</span>
<a href="#l20.4909"></a><span id="l20.4909" class="difflineminus">-  rv = imapService-&gt;OnlineMessageCopy(this, uids, aDstFolder,</span>
<a href="#l20.4910"></a><span id="l20.4910" class="difflineminus">-                                      true, isMove, aUrlListener,</span>
<a href="#l20.4911"></a><span id="l20.4911" class="difflineminus">-                                      getter_AddRefs(resultUrl), nullptr, aWindow);</span>
<a href="#l20.4912"></a><span id="l20.4912" class="difflineminus">-  if (resultUrl)</span>
<a href="#l20.4913"></a><span id="l20.4913" class="difflineminus">-  {</span>
<a href="#l20.4914"></a><span id="l20.4914" class="difflineminus">-    nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(resultUrl, &amp;rv);</span>
<a href="#l20.4915"></a><span id="l20.4915" class="difflineplus">+  rv = imapService-&gt;OnlineMessageCopy(this, uids, aDstFolder, true, isMove,</span>
<a href="#l20.4916"></a><span id="l20.4916" class="difflineplus">+                                      aUrlListener, getter_AddRefs(resultUrl),</span>
<a href="#l20.4917"></a><span id="l20.4917" class="difflineplus">+                                      nullptr, aWindow);</span>
<a href="#l20.4918"></a><span id="l20.4918" class="difflineplus">+  if (resultUrl) {</span>
<a href="#l20.4919"></a><span id="l20.4919" class="difflineplus">+    nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(resultUrl, &amp;rv);</span>
<a href="#l20.4920"></a><span id="l20.4920">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4921"></a><span id="l20.4921" class="difflineminus">-    nsCOMPtr &lt;nsIUrlListener&gt; folderListener = do_QueryInterface(aDstFolder);</span>
<a href="#l20.4922"></a><span id="l20.4922" class="difflineminus">-    if (folderListener)</span>
<a href="#l20.4923"></a><span id="l20.4923" class="difflineminus">-      mailnewsUrl-&gt;RegisterListener(folderListener);</span>
<a href="#l20.4924"></a><span id="l20.4924" class="difflineplus">+    nsCOMPtr&lt;nsIUrlListener&gt; folderListener = do_QueryInterface(aDstFolder);</span>
<a href="#l20.4925"></a><span id="l20.4925" class="difflineplus">+    if (folderListener) mailnewsUrl-&gt;RegisterListener(folderListener);</span>
<a href="#l20.4926"></a><span id="l20.4926">   }</span>
<a href="#l20.4927"></a><span id="l20.4927">   return rv;</span>
<a href="#l20.4928"></a><span id="l20.4928"> }</span>
<a href="#l20.4929"></a><span id="l20.4929"> </span>
<a href="#l20.4930"></a><span id="l20.4930" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::AddMoveResultPseudoKey(nsMsgKey aMsgKey)</span>
<a href="#l20.4931"></a><span id="l20.4931" class="difflineminus">-{</span>
<a href="#l20.4932"></a><span id="l20.4932" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::AddMoveResultPseudoKey(nsMsgKey aMsgKey) {</span>
<a href="#l20.4933"></a><span id="l20.4933">   nsresult rv = GetDatabase();</span>
<a href="#l20.4934"></a><span id="l20.4934">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4935"></a><span id="l20.4935"> </span>
<a href="#l20.4936"></a><span id="l20.4936">   nsCOMPtr&lt;nsIMsgDBHdr&gt; pseudoHdr;</span>
<a href="#l20.4937"></a><span id="l20.4937">   rv = mDatabase-&gt;GetMsgHdrForKey(aMsgKey, getter_AddRefs(pseudoHdr));</span>
<a href="#l20.4938"></a><span id="l20.4938">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4939"></a><span id="l20.4939">   nsCString messageId;</span>
<a href="#l20.4940"></a><span id="l20.4940">   pseudoHdr-&gt;GetMessageId(getter_Copies(messageId));</span>
<a href="#l20.4941"></a><span id="l20.4941">   // err on the side of caution and ignore messages w/o messageid.</span>
<a href="#l20.4942"></a><span id="l20.4942" class="difflineminus">-  if (messageId.IsEmpty())</span>
<a href="#l20.4943"></a><span id="l20.4943" class="difflineminus">-    return NS_OK;</span>
<a href="#l20.4944"></a><span id="l20.4944" class="difflineplus">+  if (messageId.IsEmpty()) return NS_OK;</span>
<a href="#l20.4945"></a><span id="l20.4945">   m_pseudoHdrs.Put(messageId, aMsgKey);</span>
<a href="#l20.4946"></a><span id="l20.4946">   return NS_OK;</span>
<a href="#l20.4947"></a><span id="l20.4947"> }</span>
<a href="#l20.4948"></a><span id="l20.4948"> </span>
<a href="#l20.4949"></a><span id="l20.4949"> NS_IMETHODIMP nsImapMailFolder::StoreImapFlags(int32_t flags, bool addFlags,</span>
<a href="#l20.4950"></a><span id="l20.4950">                                                nsMsgKey *keys, uint32_t numKeys,</span>
<a href="#l20.4951"></a><span id="l20.4951" class="difflineminus">-                                               nsIUrlListener *aUrlListener)</span>
<a href="#l20.4952"></a><span id="l20.4952" class="difflineminus">-{</span>
<a href="#l20.4953"></a><span id="l20.4953" class="difflineplus">+                                               nsIUrlListener *aUrlListener) {</span>
<a href="#l20.4954"></a><span id="l20.4954">   nsresult rv;</span>
<a href="#l20.4955"></a><span id="l20.4955" class="difflineminus">-  if (!WeAreOffline())</span>
<a href="#l20.4956"></a><span id="l20.4956" class="difflineminus">-  {</span>
<a href="#l20.4957"></a><span id="l20.4957" class="difflineminus">-    nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.4958"></a><span id="l20.4958" class="difflineplus">+  if (!WeAreOffline()) {</span>
<a href="#l20.4959"></a><span id="l20.4959" class="difflineplus">+    nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.4960"></a><span id="l20.4960" class="difflineplus">+        do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.4961"></a><span id="l20.4961">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.4962"></a><span id="l20.4962">     nsAutoCString msgIds;</span>
<a href="#l20.4963"></a><span id="l20.4963">     AllocateUidStringFromKeys(keys, numKeys, msgIds);</span>
<a href="#l20.4964"></a><span id="l20.4964">     if (addFlags)</span>
<a href="#l20.4965"></a><span id="l20.4965">       imapService-&gt;AddMessageFlags(this, aUrlListener ? aUrlListener : this,</span>
<a href="#l20.4966"></a><span id="l20.4966">                                    nullptr, msgIds, flags, true);</span>
<a href="#l20.4967"></a><span id="l20.4967">     else</span>
<a href="#l20.4968"></a><span id="l20.4968" class="difflineminus">-      imapService-&gt;SubtractMessageFlags(this, aUrlListener ? aUrlListener : this,</span>
<a href="#l20.4969"></a><span id="l20.4969" class="difflineplus">+      imapService-&gt;SubtractMessageFlags(this,</span>
<a href="#l20.4970"></a><span id="l20.4970" class="difflineplus">+                                        aUrlListener ? aUrlListener : this,</span>
<a href="#l20.4971"></a><span id="l20.4971">                                         nullptr, msgIds, flags, true);</span>
<a href="#l20.4972"></a><span id="l20.4972" class="difflineminus">-  }</span>
<a href="#l20.4973"></a><span id="l20.4973" class="difflineminus">-  else</span>
<a href="#l20.4974"></a><span id="l20.4974" class="difflineminus">-  {</span>
<a href="#l20.4975"></a><span id="l20.4975" class="difflineplus">+  } else {</span>
<a href="#l20.4976"></a><span id="l20.4976">     rv = GetDatabase();</span>
<a href="#l20.4977"></a><span id="l20.4977" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; mDatabase)</span>
<a href="#l20.4978"></a><span id="l20.4978" class="difflineminus">-    {</span>
<a href="#l20.4979"></a><span id="l20.4979" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; mDatabase) {</span>
<a href="#l20.4980"></a><span id="l20.4980">       uint32_t total = numKeys;</span>
<a href="#l20.4981"></a><span id="l20.4981" class="difflineminus">-      for (uint32_t keyIndex = 0; keyIndex &lt; total; keyIndex++)</span>
<a href="#l20.4982"></a><span id="l20.4982" class="difflineminus">-      {</span>
<a href="#l20.4983"></a><span id="l20.4983" class="difflineminus">-        nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; op;</span>
<a href="#l20.4984"></a><span id="l20.4984" class="difflineminus">-        rv = mDatabase-&gt;GetOfflineOpForKey(keys[keyIndex], true, getter_AddRefs(op));</span>
<a href="#l20.4985"></a><span id="l20.4985" class="difflineplus">+      for (uint32_t keyIndex = 0; keyIndex &lt; total; keyIndex++) {</span>
<a href="#l20.4986"></a><span id="l20.4986" class="difflineplus">+        nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; op;</span>
<a href="#l20.4987"></a><span id="l20.4987" class="difflineplus">+        rv = mDatabase-&gt;GetOfflineOpForKey(keys[keyIndex], true,</span>
<a href="#l20.4988"></a><span id="l20.4988" class="difflineplus">+                                           getter_AddRefs(op));</span>
<a href="#l20.4989"></a><span id="l20.4989">         SetFlag(nsMsgFolderFlags::OfflineEvents);</span>
<a href="#l20.4990"></a><span id="l20.4990" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; op)</span>
<a href="#l20.4991"></a><span id="l20.4991" class="difflineminus">-        {</span>
<a href="#l20.4992"></a><span id="l20.4992" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; op) {</span>
<a href="#l20.4993"></a><span id="l20.4993">           imapMessageFlagsType newFlags;</span>
<a href="#l20.4994"></a><span id="l20.4994">           op-&gt;GetNewFlags(&amp;newFlags);</span>
<a href="#l20.4995"></a><span id="l20.4995">           op-&gt;SetFlagOperation(addFlags ? newFlags | flags : newFlags &amp; ~flags);</span>
<a href="#l20.4996"></a><span id="l20.4996">         }</span>
<a href="#l20.4997"></a><span id="l20.4997">       }</span>
<a href="#l20.4998"></a><span id="l20.4998" class="difflineminus">-      mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit); // flush offline flags</span>
<a href="#l20.4999"></a><span id="l20.4999" class="difflineplus">+      mDatabase-&gt;Commit(</span>
<a href="#l20.5000"></a><span id="l20.5000" class="difflineplus">+          nsMsgDBCommitType::kLargeCommit);  // flush offline flags</span>
<a href="#l20.5001"></a><span id="l20.5001">     }</span>
<a href="#l20.5002"></a><span id="l20.5002">   }</span>
<a href="#l20.5003"></a><span id="l20.5003">   return rv;</span>
<a href="#l20.5004"></a><span id="l20.5004"> }</span>
<a href="#l20.5005"></a><span id="l20.5005"> </span>
<a href="#l20.5006"></a><span id="l20.5006"> NS_IMETHODIMP nsImapMailFolder::LiteSelect(nsIUrlListener *aUrlListener,</span>
<a href="#l20.5007"></a><span id="l20.5007" class="difflineminus">-                                           nsIMsgWindow *aMsgWindow)</span>
<a href="#l20.5008"></a><span id="l20.5008" class="difflineminus">-{</span>
<a href="#l20.5009"></a><span id="l20.5009" class="difflineplus">+                                           nsIMsgWindow *aMsgWindow) {</span>
<a href="#l20.5010"></a><span id="l20.5010">   nsresult rv;</span>
<a href="#l20.5011"></a><span id="l20.5011" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.5012"></a><span id="l20.5012" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.5013"></a><span id="l20.5013" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.5014"></a><span id="l20.5014">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.5015"></a><span id="l20.5015" class="difflineminus">-  return imapService-&gt;LiteSelectFolder(this, aUrlListener,</span>
<a href="#l20.5016"></a><span id="l20.5016" class="difflineminus">-                                       aMsgWindow, nullptr);</span>
<a href="#l20.5017"></a><span id="l20.5017" class="difflineminus">-}</span>
<a href="#l20.5018"></a><span id="l20.5018" class="difflineminus">-</span>
<a href="#l20.5019"></a><span id="l20.5019" class="difflineminus">-nsresult nsImapMailFolder::GetFolderOwnerUserName(nsACString&amp; userName)</span>
<a href="#l20.5020"></a><span id="l20.5020" class="difflineminus">-{</span>
<a href="#l20.5021"></a><span id="l20.5021" class="difflineplus">+  return imapService-&gt;LiteSelectFolder(this, aUrlListener, aMsgWindow, nullptr);</span>
<a href="#l20.5022"></a><span id="l20.5022" class="difflineplus">+}</span>
<a href="#l20.5023"></a><span id="l20.5023" class="difflineplus">+</span>
<a href="#l20.5024"></a><span id="l20.5024" class="difflineplus">+nsresult nsImapMailFolder::GetFolderOwnerUserName(nsACString &amp;userName) {</span>
<a href="#l20.5025"></a><span id="l20.5025">   if ((mFlags &amp; nsMsgFolderFlags::ImapPersonal) ||</span>
<a href="#l20.5026"></a><span id="l20.5026" class="difflineminus">-    !(mFlags &amp; (nsMsgFolderFlags::ImapPublic | nsMsgFolderFlags::ImapOtherUser)))</span>
<a href="#l20.5027"></a><span id="l20.5027" class="difflineminus">-  {</span>
<a href="#l20.5028"></a><span id="l20.5028" class="difflineplus">+      !(mFlags &amp;</span>
<a href="#l20.5029"></a><span id="l20.5029" class="difflineplus">+        (nsMsgFolderFlags::ImapPublic | nsMsgFolderFlags::ImapOtherUser))) {</span>
<a href="#l20.5030"></a><span id="l20.5030">     // this is one of our personal mail folders</span>
<a href="#l20.5031"></a><span id="l20.5031">     // return our username on this host</span>
<a href="#l20.5032"></a><span id="l20.5032">     nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.5033"></a><span id="l20.5033">     nsresult rv = GetServer(getter_AddRefs(server));</span>
<a href="#l20.5034"></a><span id="l20.5034">     return NS_FAILED(rv) ? rv : server-&gt;GetUsername(userName);</span>
<a href="#l20.5035"></a><span id="l20.5035">   }</span>
<a href="#l20.5036"></a><span id="l20.5036"> </span>
<a href="#l20.5037"></a><span id="l20.5037">   // the only other type of owner is if it's in the other users' namespace</span>
<a href="#l20.5038"></a><span id="l20.5038" class="difflineminus">-  if (!(mFlags &amp; nsMsgFolderFlags::ImapOtherUser))</span>
<a href="#l20.5039"></a><span id="l20.5039" class="difflineminus">-    return NS_OK;</span>
<a href="#l20.5040"></a><span id="l20.5040" class="difflineminus">-</span>
<a href="#l20.5041"></a><span id="l20.5041" class="difflineminus">-  if (m_ownerUserName.IsEmpty())</span>
<a href="#l20.5042"></a><span id="l20.5042" class="difflineminus">-  {</span>
<a href="#l20.5043"></a><span id="l20.5043" class="difflineplus">+  if (!(mFlags &amp; nsMsgFolderFlags::ImapOtherUser)) return NS_OK;</span>
<a href="#l20.5044"></a><span id="l20.5044" class="difflineplus">+</span>
<a href="#l20.5045"></a><span id="l20.5045" class="difflineplus">+  if (m_ownerUserName.IsEmpty()) {</span>
<a href="#l20.5046"></a><span id="l20.5046">     nsCString onlineName;</span>
<a href="#l20.5047"></a><span id="l20.5047">     GetOnlineName(onlineName);</span>
<a href="#l20.5048"></a><span id="l20.5048" class="difflineminus">-    m_ownerUserName = nsIMAPNamespaceList::GetFolderOwnerNameFromPath(GetNamespaceForFolder(), onlineName.get());</span>
<a href="#l20.5049"></a><span id="l20.5049" class="difflineplus">+    m_ownerUserName = nsIMAPNamespaceList::GetFolderOwnerNameFromPath(</span>
<a href="#l20.5050"></a><span id="l20.5050" class="difflineplus">+        GetNamespaceForFolder(), onlineName.get());</span>
<a href="#l20.5051"></a><span id="l20.5051">   }</span>
<a href="#l20.5052"></a><span id="l20.5052">   userName = m_ownerUserName;</span>
<a href="#l20.5053"></a><span id="l20.5053">   return NS_OK;</span>
<a href="#l20.5054"></a><span id="l20.5054"> }</span>
<a href="#l20.5055"></a><span id="l20.5055"> </span>
<a href="#l20.5056"></a><span id="l20.5056" class="difflineminus">-nsIMAPNamespace *nsImapMailFolder::GetNamespaceForFolder()</span>
<a href="#l20.5057"></a><span id="l20.5057" class="difflineminus">-{</span>
<a href="#l20.5058"></a><span id="l20.5058" class="difflineminus">-  if (!m_namespace)</span>
<a href="#l20.5059"></a><span id="l20.5059" class="difflineminus">-  {</span>
<a href="#l20.5060"></a><span id="l20.5060" class="difflineplus">+nsIMAPNamespace *nsImapMailFolder::GetNamespaceForFolder() {</span>
<a href="#l20.5061"></a><span id="l20.5061" class="difflineplus">+  if (!m_namespace) {</span>
<a href="#l20.5062"></a><span id="l20.5062"> #ifdef DEBUG_bienvenu</span>
<a href="#l20.5063"></a><span id="l20.5063">     // Make sure this isn't causing us to open the database</span>
<a href="#l20.5064"></a><span id="l20.5064" class="difflineminus">-    NS_ASSERTION(m_hierarchyDelimiter != kOnlineHierarchySeparatorUnknown, &quot;haven't set hierarchy delimiter&quot;);</span>
<a href="#l20.5065"></a><span id="l20.5065" class="difflineplus">+    NS_ASSERTION(m_hierarchyDelimiter != kOnlineHierarchySeparatorUnknown,</span>
<a href="#l20.5066"></a><span id="l20.5066" class="difflineplus">+                 &quot;haven't set hierarchy delimiter&quot;);</span>
<a href="#l20.5067"></a><span id="l20.5067"> #endif</span>
<a href="#l20.5068"></a><span id="l20.5068">     nsCString serverKey;</span>
<a href="#l20.5069"></a><span id="l20.5069">     nsCString onlineName;</span>
<a href="#l20.5070"></a><span id="l20.5070">     GetServerKey(serverKey);</span>
<a href="#l20.5071"></a><span id="l20.5071">     GetOnlineName(onlineName);</span>
<a href="#l20.5072"></a><span id="l20.5072">     char hierarchyDelimiter;</span>
<a href="#l20.5073"></a><span id="l20.5073">     GetHierarchyDelimiter(&amp;hierarchyDelimiter);</span>
<a href="#l20.5074"></a><span id="l20.5074"> </span>
<a href="#l20.5075"></a><span id="l20.5075">     m_namespace = nsIMAPNamespaceList::GetNamespaceForFolder(</span>
<a href="#l20.5076"></a><span id="l20.5076" class="difflineminus">-                    serverKey.get(), onlineName.get(), hierarchyDelimiter);</span>
<a href="#l20.5077"></a><span id="l20.5077" class="difflineplus">+        serverKey.get(), onlineName.get(), hierarchyDelimiter);</span>
<a href="#l20.5078"></a><span id="l20.5078">     NS_ASSERTION(m_namespace, &quot;didn't get namespace for folder&quot;);</span>
<a href="#l20.5079"></a><span id="l20.5079" class="difflineminus">-    if (m_namespace)</span>
<a href="#l20.5080"></a><span id="l20.5080" class="difflineminus">-    {</span>
<a href="#l20.5081"></a><span id="l20.5081" class="difflineminus">-      nsIMAPNamespaceList::SuggestHierarchySeparatorForNamespace(m_namespace, hierarchyDelimiter);</span>
<a href="#l20.5082"></a><span id="l20.5082" class="difflineplus">+    if (m_namespace) {</span>
<a href="#l20.5083"></a><span id="l20.5083" class="difflineplus">+      nsIMAPNamespaceList::SuggestHierarchySeparatorForNamespace(</span>
<a href="#l20.5084"></a><span id="l20.5084" class="difflineplus">+          m_namespace, hierarchyDelimiter);</span>
<a href="#l20.5085"></a><span id="l20.5085">       m_folderIsNamespace = nsIMAPNamespaceList::GetFolderIsNamespace(</span>
<a href="#l20.5086"></a><span id="l20.5086" class="difflineminus">-                              serverKey.get(), onlineName.get(),</span>
<a href="#l20.5087"></a><span id="l20.5087" class="difflineminus">-                              hierarchyDelimiter, m_namespace);</span>
<a href="#l20.5088"></a><span id="l20.5088" class="difflineplus">+          serverKey.get(), onlineName.get(), hierarchyDelimiter, m_namespace);</span>
<a href="#l20.5089"></a><span id="l20.5089">     }</span>
<a href="#l20.5090"></a><span id="l20.5090">   }</span>
<a href="#l20.5091"></a><span id="l20.5091">   return m_namespace;</span>
<a href="#l20.5092"></a><span id="l20.5092"> }</span>
<a href="#l20.5093"></a><span id="l20.5093"> </span>
<a href="#l20.5094"></a><span id="l20.5094" class="difflineminus">-void nsImapMailFolder::SetNamespaceForFolder(nsIMAPNamespace *ns)</span>
<a href="#l20.5095"></a><span id="l20.5095" class="difflineminus">-{</span>
<a href="#l20.5096"></a><span id="l20.5096" class="difflineplus">+void nsImapMailFolder::SetNamespaceForFolder(nsIMAPNamespace *ns) {</span>
<a href="#l20.5097"></a><span id="l20.5097"> #ifdef DEBUG_bienvenu</span>
<a href="#l20.5098"></a><span id="l20.5098">   NS_ASSERTION(ns, &quot;null namespace&quot;);</span>
<a href="#l20.5099"></a><span id="l20.5099"> #endif</span>
<a href="#l20.5100"></a><span id="l20.5100">   m_namespace = ns;</span>
<a href="#l20.5101"></a><span id="l20.5101"> }</span>
<a href="#l20.5102"></a><span id="l20.5102"> </span>
<a href="#l20.5103"></a><span id="l20.5103" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::FolderPrivileges(nsIMsgWindow *window)</span>
<a href="#l20.5104"></a><span id="l20.5104" class="difflineminus">-{</span>
<a href="#l20.5105"></a><span id="l20.5105" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::FolderPrivileges(nsIMsgWindow *window) {</span>
<a href="#l20.5106"></a><span id="l20.5106">   NS_ENSURE_ARG_POINTER(window);</span>
<a href="#l20.5107"></a><span id="l20.5107">   nsresult rv = NS_OK;  // if no window...</span>
<a href="#l20.5108"></a><span id="l20.5108" class="difflineminus">-  if (!m_adminUrl.IsEmpty())</span>
<a href="#l20.5109"></a><span id="l20.5109" class="difflineminus">-  {</span>
<a href="#l20.5110"></a><span id="l20.5110" class="difflineminus">-    nsCOMPtr&lt;nsIExternalProtocolService&gt; extProtService = do_GetService(NS_EXTERNALPROTOCOLSERVICE_CONTRACTID);</span>
<a href="#l20.5111"></a><span id="l20.5111" class="difflineminus">-    if (extProtService)</span>
<a href="#l20.5112"></a><span id="l20.5112" class="difflineminus">-    {</span>
<a href="#l20.5113"></a><span id="l20.5113" class="difflineplus">+  if (!m_adminUrl.IsEmpty()) {</span>
<a href="#l20.5114"></a><span id="l20.5114" class="difflineplus">+    nsCOMPtr&lt;nsIExternalProtocolService&gt; extProtService =</span>
<a href="#l20.5115"></a><span id="l20.5115" class="difflineplus">+        do_GetService(NS_EXTERNALPROTOCOLSERVICE_CONTRACTID);</span>
<a href="#l20.5116"></a><span id="l20.5116" class="difflineplus">+    if (extProtService) {</span>
<a href="#l20.5117"></a><span id="l20.5117">       nsAutoCString scheme;</span>
<a href="#l20.5118"></a><span id="l20.5118">       nsCOMPtr&lt;nsIURI&gt; uri;</span>
<a href="#l20.5119"></a><span id="l20.5119">       if (NS_FAILED(rv = NS_NewURI(getter_AddRefs(uri), m_adminUrl.get())))</span>
<a href="#l20.5120"></a><span id="l20.5120">         return rv;</span>
<a href="#l20.5121"></a><span id="l20.5121">       uri-&gt;GetScheme(scheme);</span>
<a href="#l20.5122"></a><span id="l20.5122" class="difflineminus">-      if (!scheme.IsEmpty())</span>
<a href="#l20.5123"></a><span id="l20.5123" class="difflineminus">-      {</span>
<a href="#l20.5124"></a><span id="l20.5124" class="difflineplus">+      if (!scheme.IsEmpty()) {</span>
<a href="#l20.5125"></a><span id="l20.5125">         // if the URL scheme does not correspond to an exposed protocol, then we</span>
<a href="#l20.5126"></a><span id="l20.5126">         // need to hand this link click over to the external protocol handler.</span>
<a href="#l20.5127"></a><span id="l20.5127">         bool isExposed;</span>
<a href="#l20.5128"></a><span id="l20.5128">         rv = extProtService-&gt;IsExposedProtocol(scheme.get(), &amp;isExposed);</span>
<a href="#l20.5129"></a><span id="l20.5129">         if (NS_SUCCEEDED(rv) &amp;&amp; !isExposed)</span>
<a href="#l20.5130"></a><span id="l20.5130">           return extProtService-&gt;LoadURI(uri, nullptr);</span>
<a href="#l20.5131"></a><span id="l20.5131">       }</span>
<a href="#l20.5132"></a><span id="l20.5132">     }</span>
<a href="#l20.5133"></a><span id="l20.5133" class="difflineminus">-  }</span>
<a href="#l20.5134"></a><span id="l20.5134" class="difflineminus">-  else</span>
<a href="#l20.5135"></a><span id="l20.5135" class="difflineminus">-  {</span>
<a href="#l20.5136"></a><span id="l20.5136" class="difflineminus">-    nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.5137"></a><span id="l20.5137" class="difflineminus">-    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.5138"></a><span id="l20.5138" class="difflineplus">+  } else {</span>
<a href="#l20.5139"></a><span id="l20.5139" class="difflineplus">+    nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.5140"></a><span id="l20.5140" class="difflineplus">+        do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.5141"></a><span id="l20.5141" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.5142"></a><span id="l20.5142">     rv = imapService-&gt;GetFolderAdminUrl(this, window, this, nullptr);</span>
<a href="#l20.5143"></a><span id="l20.5143" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l20.5144"></a><span id="l20.5144" class="difflineminus">-      m_urlRunning = true;</span>
<a href="#l20.5145"></a><span id="l20.5145" class="difflineplus">+    if (NS_SUCCEEDED(rv)) m_urlRunning = true;</span>
<a href="#l20.5146"></a><span id="l20.5146">   }</span>
<a href="#l20.5147"></a><span id="l20.5147">   return rv;</span>
<a href="#l20.5148"></a><span id="l20.5148"> }</span>
<a href="#l20.5149"></a><span id="l20.5149"> </span>
<a href="#l20.5150"></a><span id="l20.5150" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetHasAdminUrl(bool *aBool)</span>
<a href="#l20.5151"></a><span id="l20.5151" class="difflineminus">-{</span>
<a href="#l20.5152"></a><span id="l20.5152" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetHasAdminUrl(bool *aBool) {</span>
<a href="#l20.5153"></a><span id="l20.5153">   NS_ENSURE_ARG_POINTER(aBool);</span>
<a href="#l20.5154"></a><span id="l20.5154">   nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.5155"></a><span id="l20.5155">   nsresult rv = GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.5156"></a><span id="l20.5156">   nsCString manageMailAccountUrl;</span>
<a href="#l20.5157"></a><span id="l20.5157">   if (NS_SUCCEEDED(rv) &amp;&amp; imapServer)</span>
<a href="#l20.5158"></a><span id="l20.5158">     rv = imapServer-&gt;GetManageMailAccountUrl(manageMailAccountUrl);</span>
<a href="#l20.5159"></a><span id="l20.5159">   *aBool = (NS_SUCCEEDED(rv) &amp;&amp; !manageMailAccountUrl.IsEmpty());</span>
<a href="#l20.5160"></a><span id="l20.5160">   return rv;</span>
<a href="#l20.5161"></a><span id="l20.5161"> }</span>
<a href="#l20.5162"></a><span id="l20.5162"> </span>
<a href="#l20.5163"></a><span id="l20.5163" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetAdminUrl(nsACString&amp; aResult)</span>
<a href="#l20.5164"></a><span id="l20.5164" class="difflineminus">-{</span>
<a href="#l20.5165"></a><span id="l20.5165" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetAdminUrl(nsACString &amp;aResult) {</span>
<a href="#l20.5166"></a><span id="l20.5166">   aResult = m_adminUrl;</span>
<a href="#l20.5167"></a><span id="l20.5167">   return NS_OK;</span>
<a href="#l20.5168"></a><span id="l20.5168"> }</span>
<a href="#l20.5169"></a><span id="l20.5169"> </span>
<a href="#l20.5170"></a><span id="l20.5170" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetAdminUrl(const nsACString&amp; adminUrl)</span>
<a href="#l20.5171"></a><span id="l20.5171" class="difflineminus">-{</span>
<a href="#l20.5172"></a><span id="l20.5172" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetAdminUrl(const nsACString &amp;adminUrl) {</span>
<a href="#l20.5173"></a><span id="l20.5173">   m_adminUrl = adminUrl;</span>
<a href="#l20.5174"></a><span id="l20.5174">   return NS_OK;</span>
<a href="#l20.5175"></a><span id="l20.5175"> }</span>
<a href="#l20.5176"></a><span id="l20.5176"> </span>
<a href="#l20.5177"></a><span id="l20.5177" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetHdrParser(nsIMsgParseMailMsgState **aHdrParser)</span>
<a href="#l20.5178"></a><span id="l20.5178" class="difflineminus">-{</span>
<a href="#l20.5179"></a><span id="l20.5179" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetHdrParser(</span>
<a href="#l20.5180"></a><span id="l20.5180" class="difflineplus">+    nsIMsgParseMailMsgState **aHdrParser) {</span>
<a href="#l20.5181"></a><span id="l20.5181">   NS_ENSURE_ARG_POINTER(aHdrParser);</span>
<a href="#l20.5182"></a><span id="l20.5182">   NS_IF_ADDREF(*aHdrParser = m_msgParser);</span>
<a href="#l20.5183"></a><span id="l20.5183">   return NS_OK;</span>
<a href="#l20.5184"></a><span id="l20.5184"> }</span>
<a href="#l20.5185"></a><span id="l20.5185"> </span>
<a href="#l20.5186"></a><span id="l20.5186" class="difflineminus">-  // this is used to issue an arbitrary imap command on the passed in msgs.</span>
<a href="#l20.5187"></a><span id="l20.5187" class="difflineminus">-  // It assumes the command needs to be run in the selected state.</span>
<a href="#l20.5188"></a><span id="l20.5188" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::IssueCommandOnMsgs(const nsACString&amp; command, const char *uids, nsIMsgWindow *aWindow, nsIURI **url)</span>
<a href="#l20.5189"></a><span id="l20.5189" class="difflineminus">-{</span>
<a href="#l20.5190"></a><span id="l20.5190" class="difflineminus">-  nsresult rv;</span>
<a href="#l20.5191"></a><span id="l20.5191" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.5192"></a><span id="l20.5192" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.5193"></a><span id="l20.5193" class="difflineminus">-  return imapService-&gt;IssueCommandOnMsgs(this, aWindow, command, nsDependentCString(uids), url);</span>
<a href="#l20.5194"></a><span id="l20.5194" class="difflineminus">-}</span>
<a href="#l20.5195"></a><span id="l20.5195" class="difflineminus">-</span>
<a href="#l20.5196"></a><span id="l20.5196" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::FetchCustomMsgAttribute(const nsACString&amp; attribute, const char *uids, nsIMsgWindow *aWindow, nsIURI **url)</span>
<a href="#l20.5197"></a><span id="l20.5197" class="difflineminus">-{</span>
<a href="#l20.5198"></a><span id="l20.5198" class="difflineplus">+// this is used to issue an arbitrary imap command on the passed in msgs.</span>
<a href="#l20.5199"></a><span id="l20.5199" class="difflineplus">+// It assumes the command needs to be run in the selected state.</span>
<a href="#l20.5200"></a><span id="l20.5200" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::IssueCommandOnMsgs(const nsACString &amp;command,</span>
<a href="#l20.5201"></a><span id="l20.5201" class="difflineplus">+                                                   const char *uids,</span>
<a href="#l20.5202"></a><span id="l20.5202" class="difflineplus">+                                                   nsIMsgWindow *aWindow,</span>
<a href="#l20.5203"></a><span id="l20.5203" class="difflineplus">+                                                   nsIURI **url) {</span>
<a href="#l20.5204"></a><span id="l20.5204">   nsresult rv;</span>
<a href="#l20.5205"></a><span id="l20.5205" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.5206"></a><span id="l20.5206" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.5207"></a><span id="l20.5207" class="difflineminus">-</span>
<a href="#l20.5208"></a><span id="l20.5208" class="difflineminus">-  return imapService-&gt;FetchCustomMsgAttribute(this, aWindow, attribute, nsDependentCString(uids), url);</span>
<a href="#l20.5209"></a><span id="l20.5209" class="difflineminus">-}</span>
<a href="#l20.5210"></a><span id="l20.5210" class="difflineminus">-</span>
<a href="#l20.5211"></a><span id="l20.5211" class="difflineminus">-nsresult nsImapMailFolder::MoveIncorporatedMessage(nsIMsgDBHdr *mailHdr,</span>
<a href="#l20.5212"></a><span id="l20.5212" class="difflineminus">-                                                   nsIMsgDatabase *sourceDB,</span>
<a href="#l20.5213"></a><span id="l20.5213" class="difflineminus">-                                                   const nsACString&amp; destFolderUri,</span>
<a href="#l20.5214"></a><span id="l20.5214" class="difflineminus">-                                                   nsIMsgFilter *filter,</span>
<a href="#l20.5215"></a><span id="l20.5215" class="difflineminus">-                                                   nsIMsgWindow *msgWindow)</span>
<a href="#l20.5216"></a><span id="l20.5216" class="difflineminus">-{</span>
<a href="#l20.5217"></a><span id="l20.5217" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.5218"></a><span id="l20.5218" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.5219"></a><span id="l20.5219" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.5220"></a><span id="l20.5220" class="difflineplus">+  return imapService-&gt;IssueCommandOnMsgs(this, aWindow, command,</span>
<a href="#l20.5221"></a><span id="l20.5221" class="difflineplus">+                                         nsDependentCString(uids), url);</span>
<a href="#l20.5222"></a><span id="l20.5222" class="difflineplus">+}</span>
<a href="#l20.5223"></a><span id="l20.5223" class="difflineplus">+</span>
<a href="#l20.5224"></a><span id="l20.5224" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::FetchCustomMsgAttribute(</span>
<a href="#l20.5225"></a><span id="l20.5225" class="difflineplus">+    const nsACString &amp;attribute, const char *uids, nsIMsgWindow *aWindow,</span>
<a href="#l20.5226"></a><span id="l20.5226" class="difflineplus">+    nsIURI **url) {</span>
<a href="#l20.5227"></a><span id="l20.5227">   nsresult rv;</span>
<a href="#l20.5228"></a><span id="l20.5228" class="difflineminus">-  if (m_moveCoalescer)</span>
<a href="#l20.5229"></a><span id="l20.5229" class="difflineminus">-  {</span>
<a href="#l20.5230"></a><span id="l20.5230" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.5231"></a><span id="l20.5231" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.5232"></a><span id="l20.5232" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.5233"></a><span id="l20.5233" class="difflineplus">+</span>
<a href="#l20.5234"></a><span id="l20.5234" class="difflineplus">+  return imapService-&gt;FetchCustomMsgAttribute(this, aWindow, attribute,</span>
<a href="#l20.5235"></a><span id="l20.5235" class="difflineplus">+                                              nsDependentCString(uids), url);</span>
<a href="#l20.5236"></a><span id="l20.5236" class="difflineplus">+}</span>
<a href="#l20.5237"></a><span id="l20.5237" class="difflineplus">+</span>
<a href="#l20.5238"></a><span id="l20.5238" class="difflineplus">+nsresult nsImapMailFolder::MoveIncorporatedMessage(</span>
<a href="#l20.5239"></a><span id="l20.5239" class="difflineplus">+    nsIMsgDBHdr *mailHdr, nsIMsgDatabase *sourceDB,</span>
<a href="#l20.5240"></a><span id="l20.5240" class="difflineplus">+    const nsACString &amp;destFolderUri, nsIMsgFilter *filter,</span>
<a href="#l20.5241"></a><span id="l20.5241" class="difflineplus">+    nsIMsgWindow *msgWindow) {</span>
<a href="#l20.5242"></a><span id="l20.5242" class="difflineplus">+  nsresult rv;</span>
<a href="#l20.5243"></a><span id="l20.5243" class="difflineplus">+  if (m_moveCoalescer) {</span>
<a href="#l20.5244"></a><span id="l20.5244">     nsCOMPtr&lt;nsIMsgFolder&gt; destIFolder;</span>
<a href="#l20.5245"></a><span id="l20.5245">     rv = GetOrCreateFolder(destFolderUri, getter_AddRefs(destIFolder));</span>
<a href="#l20.5246"></a><span id="l20.5246">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.5247"></a><span id="l20.5247"> </span>
<a href="#l20.5248"></a><span id="l20.5248" class="difflineminus">-    if (destIFolder)</span>
<a href="#l20.5249"></a><span id="l20.5249" class="difflineminus">-    {</span>
<a href="#l20.5250"></a><span id="l20.5250" class="difflineplus">+    if (destIFolder) {</span>
<a href="#l20.5251"></a><span id="l20.5251">       // check if the destination is a real folder (by checking for null parent)</span>
<a href="#l20.5252"></a><span id="l20.5252" class="difflineminus">-      // and if it can file messages (e.g., servers or news folders can't file messages).</span>
<a href="#l20.5253"></a><span id="l20.5253" class="difflineminus">-      // Or read only imap folders...</span>
<a href="#l20.5254"></a><span id="l20.5254" class="difflineplus">+      // and if it can file messages (e.g., servers or news folders can't file</span>
<a href="#l20.5255"></a><span id="l20.5255" class="difflineplus">+      // messages). Or read only imap folders...</span>
<a href="#l20.5256"></a><span id="l20.5256">       bool canFileMessages = true;</span>
<a href="#l20.5257"></a><span id="l20.5257">       nsCOMPtr&lt;nsIMsgFolder&gt; parentFolder;</span>
<a href="#l20.5258"></a><span id="l20.5258">       destIFolder-&gt;GetParent(getter_AddRefs(parentFolder));</span>
<a href="#l20.5259"></a><span id="l20.5259" class="difflineminus">-      if (parentFolder)</span>
<a href="#l20.5260"></a><span id="l20.5260" class="difflineminus">-        destIFolder-&gt;GetCanFileMessages(&amp;canFileMessages);</span>
<a href="#l20.5261"></a><span id="l20.5261" class="difflineminus">-      if (filter &amp;&amp; (!parentFolder || !canFileMessages))</span>
<a href="#l20.5262"></a><span id="l20.5262" class="difflineminus">-      {</span>
<a href="#l20.5263"></a><span id="l20.5263" class="difflineplus">+      if (parentFolder) destIFolder-&gt;GetCanFileMessages(&amp;canFileMessages);</span>
<a href="#l20.5264"></a><span id="l20.5264" class="difflineplus">+      if (filter &amp;&amp; (!parentFolder || !canFileMessages)) {</span>
<a href="#l20.5265"></a><span id="l20.5265">         filter-&gt;SetEnabled(false);</span>
<a href="#l20.5266"></a><span id="l20.5266">         m_filterList-&gt;SaveToDefaultFile();</span>
<a href="#l20.5267"></a><span id="l20.5267" class="difflineminus">-        destIFolder-&gt;ThrowAlertMsg(&quot;filterDisabled&quot;,msgWindow);</span>
<a href="#l20.5268"></a><span id="l20.5268" class="difflineplus">+        destIFolder-&gt;ThrowAlertMsg(&quot;filterDisabled&quot;, msgWindow);</span>
<a href="#l20.5269"></a><span id="l20.5269">         return NS_MSG_NOT_A_MAIL_FOLDER;</span>
<a href="#l20.5270"></a><span id="l20.5270">       }</span>
<a href="#l20.5271"></a><span id="l20.5271" class="difflineminus">-      // put the header into the source db, since it needs to be there when we copy it</span>
<a href="#l20.5272"></a><span id="l20.5272" class="difflineminus">-      // and we need a valid header to pass to StartAsyncCopyMessagesInto</span>
<a href="#l20.5273"></a><span id="l20.5273" class="difflineplus">+      // put the header into the source db, since it needs to be there when we</span>
<a href="#l20.5274"></a><span id="l20.5274" class="difflineplus">+      // copy it and we need a valid header to pass to</span>
<a href="#l20.5275"></a><span id="l20.5275" class="difflineplus">+      // StartAsyncCopyMessagesInto</span>
<a href="#l20.5276"></a><span id="l20.5276">       nsMsgKey keyToFilter;</span>
<a href="#l20.5277"></a><span id="l20.5277">       mailHdr-&gt;GetMessageKey(&amp;keyToFilter);</span>
<a href="#l20.5278"></a><span id="l20.5278"> </span>
<a href="#l20.5279"></a><span id="l20.5279" class="difflineminus">-      if (sourceDB &amp;&amp; destIFolder)</span>
<a href="#l20.5280"></a><span id="l20.5280" class="difflineminus">-      {</span>
<a href="#l20.5281"></a><span id="l20.5281" class="difflineplus">+      if (sourceDB &amp;&amp; destIFolder) {</span>
<a href="#l20.5282"></a><span id="l20.5282">         bool imapDeleteIsMoveToTrash = DeleteIsMoveToTrash();</span>
<a href="#l20.5283"></a><span id="l20.5283" class="difflineminus">-        m_moveCoalescer-&gt;AddMove (destIFolder, keyToFilter);</span>
<a href="#l20.5284"></a><span id="l20.5284" class="difflineminus">-        // For each folder, we need to keep track of the ids we want to move to that</span>
<a href="#l20.5285"></a><span id="l20.5285" class="difflineminus">-        // folder - we used to store them in the MSG_FolderInfo and then when we'd finished</span>
<a href="#l20.5286"></a><span id="l20.5286" class="difflineminus">-        // downloading headers, we'd iterate through all the folders looking for the ones</span>
<a href="#l20.5287"></a><span id="l20.5287" class="difflineminus">-        // that needed messages moved into them - perhaps instead we could</span>
<a href="#l20.5288"></a><span id="l20.5288" class="difflineminus">-        // keep track of nsIMsgFolder, nsTArray&lt;nsMsgKey&gt; pairs here in the imap code.</span>
<a href="#l20.5289"></a><span id="l20.5289" class="difflineminus">-        // nsTArray&lt;nsMsgKey&gt; *idsToMoveFromInbox = msgFolder-&gt;GetImapIdsToMoveFromInbox();</span>
<a href="#l20.5290"></a><span id="l20.5290" class="difflineplus">+        m_moveCoalescer-&gt;AddMove(destIFolder, keyToFilter);</span>
<a href="#l20.5291"></a><span id="l20.5291" class="difflineplus">+        // For each folder, we need to keep track of the ids we want to move to</span>
<a href="#l20.5292"></a><span id="l20.5292" class="difflineplus">+        // that folder - we used to store them in the MSG_FolderInfo and then</span>
<a href="#l20.5293"></a><span id="l20.5293" class="difflineplus">+        // when we'd finished downloading headers, we'd iterate through all the</span>
<a href="#l20.5294"></a><span id="l20.5294" class="difflineplus">+        // folders looking for the ones that needed messages moved into them -</span>
<a href="#l20.5295"></a><span id="l20.5295" class="difflineplus">+        // perhaps instead we could keep track of nsIMsgFolder,</span>
<a href="#l20.5296"></a><span id="l20.5296" class="difflineplus">+        // nsTArray&lt;nsMsgKey&gt; pairs here in the imap code. nsTArray&lt;nsMsgKey&gt;</span>
<a href="#l20.5297"></a><span id="l20.5297" class="difflineplus">+        // *idsToMoveFromInbox = msgFolder-&gt;GetImapIdsToMoveFromInbox();</span>
<a href="#l20.5298"></a><span id="l20.5298">         // idsToMoveFromInbox-&gt;AppendElement(keyToFilter);</span>
<a href="#l20.5299"></a><span id="l20.5299" class="difflineminus">-        if (imapDeleteIsMoveToTrash)</span>
<a href="#l20.5300"></a><span id="l20.5300" class="difflineminus">-        {</span>
<a href="#l20.5301"></a><span id="l20.5301" class="difflineplus">+        if (imapDeleteIsMoveToTrash) {</span>
<a href="#l20.5302"></a><span id="l20.5302">         }</span>
<a href="#l20.5303"></a><span id="l20.5303">         bool isRead = false;</span>
<a href="#l20.5304"></a><span id="l20.5304">         mailHdr-&gt;GetIsRead(&amp;isRead);</span>
<a href="#l20.5305"></a><span id="l20.5305" class="difflineminus">-        if (imapDeleteIsMoveToTrash)</span>
<a href="#l20.5306"></a><span id="l20.5306" class="difflineminus">-          rv = NS_OK;</span>
<a href="#l20.5307"></a><span id="l20.5307" class="difflineplus">+        if (imapDeleteIsMoveToTrash) rv = NS_OK;</span>
<a href="#l20.5308"></a><span id="l20.5308">       }</span>
<a href="#l20.5309"></a><span id="l20.5309">     }</span>
<a href="#l20.5310"></a><span id="l20.5310">   } else</span>
<a href="#l20.5311"></a><span id="l20.5311">     rv = NS_ERROR_UNEXPECTED;</span>
<a href="#l20.5312"></a><span id="l20.5312"> </span>
<a href="#l20.5313"></a><span id="l20.5313">   // we have to return an error because we do not actually move the message</span>
<a href="#l20.5314"></a><span id="l20.5314">   // it is done async and that can fail</span>
<a href="#l20.5315"></a><span id="l20.5315">   return rv;</span>
<a href="#l20.5316"></a><span id="l20.5316"> }</span>
<a href="#l20.5317"></a><span id="l20.5317"> </span>
<a href="#l20.5318"></a><span id="l20.5318"> /**</span>
<a href="#l20.5319"></a><span id="l20.5319" class="difflineminus">- * This method assumes that key arrays and flag states are sorted by increasing key.</span>
<a href="#l20.5320"></a><span id="l20.5320" class="difflineplus">+ * This method assumes that key arrays and flag states are sorted by increasing</span>
<a href="#l20.5321"></a><span id="l20.5321" class="difflineplus">+ * key.</span>
<a href="#l20.5322"></a><span id="l20.5322">  */</span>
<a href="#l20.5323"></a><span id="l20.5323"> void nsImapMailFolder::FindKeysToDelete(const nsTArray&lt;nsMsgKey&gt; &amp;existingKeys,</span>
<a href="#l20.5324"></a><span id="l20.5324">                                         nsTArray&lt;nsMsgKey&gt; &amp;keysToDelete,</span>
<a href="#l20.5325"></a><span id="l20.5325">                                         nsIImapFlagAndUidState *flagState,</span>
<a href="#l20.5326"></a><span id="l20.5326" class="difflineminus">-                                        uint32_t boxFlags)</span>
<a href="#l20.5327"></a><span id="l20.5327" class="difflineminus">-{</span>
<a href="#l20.5328"></a><span id="l20.5328" class="difflineplus">+                                        uint32_t boxFlags) {</span>
<a href="#l20.5329"></a><span id="l20.5329">   bool showDeletedMessages = ShowDeletedMessages();</span>
<a href="#l20.5330"></a><span id="l20.5330">   int32_t numMessageInFlagState;</span>
<a href="#l20.5331"></a><span id="l20.5331">   bool partialUIDFetch;</span>
<a href="#l20.5332"></a><span id="l20.5332">   uint32_t uidOfMessage;</span>
<a href="#l20.5333"></a><span id="l20.5333">   imapMessageFlagsType flags;</span>
<a href="#l20.5334"></a><span id="l20.5334"> </span>
<a href="#l20.5335"></a><span id="l20.5335">   flagState-&gt;GetNumberOfMessages(&amp;numMessageInFlagState);</span>
<a href="#l20.5336"></a><span id="l20.5336">   flagState-&gt;GetPartialUIDFetch(&amp;partialUIDFetch);</span>
<a href="#l20.5337"></a><span id="l20.5337"> </span>
<a href="#l20.5338"></a><span id="l20.5338">   // if we're doing a partialUIDFetch, just delete the keys from the db</span>
<a href="#l20.5339"></a><span id="l20.5339">   // that have the deleted flag set (if not using imap delete model)</span>
<a href="#l20.5340"></a><span id="l20.5340">   // and return.</span>
<a href="#l20.5341"></a><span id="l20.5341" class="difflineminus">-  if (partialUIDFetch)</span>
<a href="#l20.5342"></a><span id="l20.5342" class="difflineminus">-  {</span>
<a href="#l20.5343"></a><span id="l20.5343" class="difflineminus">-    if (!showDeletedMessages)</span>
<a href="#l20.5344"></a><span id="l20.5344" class="difflineminus">-    {</span>
<a href="#l20.5345"></a><span id="l20.5345" class="difflineminus">-      for (uint32_t i = 0; (int32_t) i &lt; numMessageInFlagState; i++)</span>
<a href="#l20.5346"></a><span id="l20.5346" class="difflineminus">-      {</span>
<a href="#l20.5347"></a><span id="l20.5347" class="difflineplus">+  if (partialUIDFetch) {</span>
<a href="#l20.5348"></a><span id="l20.5348" class="difflineplus">+    if (!showDeletedMessages) {</span>
<a href="#l20.5349"></a><span id="l20.5349" class="difflineplus">+      for (uint32_t i = 0; (int32_t)i &lt; numMessageInFlagState; i++) {</span>
<a href="#l20.5350"></a><span id="l20.5350">         flagState-&gt;GetUidOfMessage(i, &amp;uidOfMessage);</span>
<a href="#l20.5351"></a><span id="l20.5351">         // flag state will be zero filled up to first real uid, so ignore those.</span>
<a href="#l20.5352"></a><span id="l20.5352" class="difflineminus">-        if (uidOfMessage)</span>
<a href="#l20.5353"></a><span id="l20.5353" class="difflineminus">-        {</span>
<a href="#l20.5354"></a><span id="l20.5354" class="difflineplus">+        if (uidOfMessage) {</span>
<a href="#l20.5355"></a><span id="l20.5355">           flagState-&gt;GetMessageFlags(i, &amp;flags);</span>
<a href="#l20.5356"></a><span id="l20.5356">           if (flags &amp; kImapMsgDeletedFlag)</span>
<a href="#l20.5357"></a><span id="l20.5357">             keysToDelete.AppendElement(uidOfMessage);</span>
<a href="#l20.5358"></a><span id="l20.5358">         }</span>
<a href="#l20.5359"></a><span id="l20.5359">       }</span>
<a href="#l20.5360"></a><span id="l20.5360" class="difflineminus">-    }</span>
<a href="#l20.5361"></a><span id="l20.5361" class="difflineminus">-    else if (boxFlags &amp; kJustExpunged)</span>
<a href="#l20.5362"></a><span id="l20.5362" class="difflineminus">-    {</span>
<a href="#l20.5363"></a><span id="l20.5363" class="difflineplus">+    } else if (boxFlags &amp; kJustExpunged) {</span>
<a href="#l20.5364"></a><span id="l20.5364">       // we've just issued an expunge with a partial flag state. We should</span>
<a href="#l20.5365"></a><span id="l20.5365">       // delete headers with the imap deleted flag set, because we can't</span>
<a href="#l20.5366"></a><span id="l20.5366">       // tell from the expunge response which messages were deleted.</span>
<a href="#l20.5367"></a><span id="l20.5367" class="difflineminus">-      nsCOMPtr &lt;nsISimpleEnumerator&gt; hdrs;</span>
<a href="#l20.5368"></a><span id="l20.5368" class="difflineplus">+      nsCOMPtr&lt;nsISimpleEnumerator&gt; hdrs;</span>
<a href="#l20.5369"></a><span id="l20.5369">       nsresult rv = GetMessages(getter_AddRefs(hdrs));</span>
<a href="#l20.5370"></a><span id="l20.5370">       NS_ENSURE_SUCCESS_VOID(rv);</span>
<a href="#l20.5371"></a><span id="l20.5371">       bool hasMore = false;</span>
<a href="#l20.5372"></a><span id="l20.5372" class="difflineminus">-      nsCOMPtr &lt;nsIMsgDBHdr&gt; pHeader;</span>
<a href="#l20.5373"></a><span id="l20.5373" class="difflineminus">-      while (NS_SUCCEEDED(rv = hdrs-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l20.5374"></a><span id="l20.5374" class="difflineminus">-      {</span>
<a href="#l20.5375"></a><span id="l20.5375" class="difflineminus">-        nsCOMPtr &lt;nsISupports&gt; supports;</span>
<a href="#l20.5376"></a><span id="l20.5376" class="difflineplus">+      nsCOMPtr&lt;nsIMsgDBHdr&gt; pHeader;</span>
<a href="#l20.5377"></a><span id="l20.5377" class="difflineplus">+      while (NS_SUCCEEDED(rv = hdrs-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore) {</span>
<a href="#l20.5378"></a><span id="l20.5378" class="difflineplus">+        nsCOMPtr&lt;nsISupports&gt; supports;</span>
<a href="#l20.5379"></a><span id="l20.5379">         rv = hdrs-&gt;GetNext(getter_AddRefs(supports));</span>
<a href="#l20.5380"></a><span id="l20.5380">         NS_ENSURE_SUCCESS_VOID(rv);</span>
<a href="#l20.5381"></a><span id="l20.5381">         pHeader = do_QueryInterface(supports, &amp;rv);</span>
<a href="#l20.5382"></a><span id="l20.5382">         NS_ENSURE_SUCCESS_VOID(rv);</span>
<a href="#l20.5383"></a><span id="l20.5383">         uint32_t msgFlags;</span>
<a href="#l20.5384"></a><span id="l20.5384">         pHeader-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l20.5385"></a><span id="l20.5385" class="difflineminus">-        if (msgFlags &amp; nsMsgMessageFlags::IMAPDeleted)</span>
<a href="#l20.5386"></a><span id="l20.5386" class="difflineminus">-        {</span>
<a href="#l20.5387"></a><span id="l20.5387" class="difflineplus">+        if (msgFlags &amp; nsMsgMessageFlags::IMAPDeleted) {</span>
<a href="#l20.5388"></a><span id="l20.5388">           nsMsgKey msgKey;</span>
<a href="#l20.5389"></a><span id="l20.5389">           pHeader-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l20.5390"></a><span id="l20.5390">           keysToDelete.AppendElement(msgKey);</span>
<a href="#l20.5391"></a><span id="l20.5391">         }</span>
<a href="#l20.5392"></a><span id="l20.5392">       }</span>
<a href="#l20.5393"></a><span id="l20.5393">     }</span>
<a href="#l20.5394"></a><span id="l20.5394">     return;</span>
<a href="#l20.5395"></a><span id="l20.5395">   }</span>
<a href="#l20.5396"></a><span id="l20.5396">   // otherwise, we have a complete set of uid's and flags, so we delete</span>
<a href="#l20.5397"></a><span id="l20.5397">   // anything that's in existingKeys but not in the flag state, as well</span>
<a href="#l20.5398"></a><span id="l20.5398">   // as messages with the deleted flag set.</span>
<a href="#l20.5399"></a><span id="l20.5399">   uint32_t total = existingKeys.Length();</span>
<a href="#l20.5400"></a><span id="l20.5400" class="difflineminus">-  int onlineIndex = 0; // current index into flagState</span>
<a href="#l20.5401"></a><span id="l20.5401" class="difflineminus">-  for (uint32_t keyIndex = 0; keyIndex &lt; total; keyIndex++)</span>
<a href="#l20.5402"></a><span id="l20.5402" class="difflineminus">-  {</span>
<a href="#l20.5403"></a><span id="l20.5403" class="difflineminus">-</span>
<a href="#l20.5404"></a><span id="l20.5404" class="difflineminus">-    while ((onlineIndex &lt; numMessageInFlagState) &amp;&amp;</span>
<a href="#l20.5405"></a><span id="l20.5405" class="difflineminus">-           NS_SUCCEEDED(flagState-&gt;GetUidOfMessage(onlineIndex, &amp;uidOfMessage)) &amp;&amp;</span>
<a href="#l20.5406"></a><span id="l20.5406" class="difflineminus">-           (existingKeys[keyIndex] &gt; uidOfMessage))</span>
<a href="#l20.5407"></a><span id="l20.5407" class="difflineplus">+  int onlineIndex = 0;  // current index into flagState</span>
<a href="#l20.5408"></a><span id="l20.5408" class="difflineplus">+  for (uint32_t keyIndex = 0; keyIndex &lt; total; keyIndex++) {</span>
<a href="#l20.5409"></a><span id="l20.5409" class="difflineplus">+    while (</span>
<a href="#l20.5410"></a><span id="l20.5410" class="difflineplus">+        (onlineIndex &lt; numMessageInFlagState) &amp;&amp;</span>
<a href="#l20.5411"></a><span id="l20.5411" class="difflineplus">+        NS_SUCCEEDED(flagState-&gt;GetUidOfMessage(onlineIndex, &amp;uidOfMessage)) &amp;&amp;</span>
<a href="#l20.5412"></a><span id="l20.5412" class="difflineplus">+        (existingKeys[keyIndex] &gt; uidOfMessage))</span>
<a href="#l20.5413"></a><span id="l20.5413">       onlineIndex++;</span>
<a href="#l20.5414"></a><span id="l20.5414"> </span>
<a href="#l20.5415"></a><span id="l20.5415">     flagState-&gt;GetUidOfMessage(onlineIndex, &amp;uidOfMessage);</span>
<a href="#l20.5416"></a><span id="l20.5416">     flagState-&gt;GetMessageFlags(onlineIndex, &amp;flags);</span>
<a href="#l20.5417"></a><span id="l20.5417">     // delete this key if it is not there or marked deleted</span>
<a href="#l20.5418"></a><span id="l20.5418" class="difflineminus">-    if ( (onlineIndex &gt;= numMessageInFlagState ) ||</span>
<a href="#l20.5419"></a><span id="l20.5419" class="difflineminus">-       (existingKeys[keyIndex] != uidOfMessage) ||</span>
<a href="#l20.5420"></a><span id="l20.5420" class="difflineminus">-       ((flags &amp; kImapMsgDeletedFlag) &amp;&amp; !showDeletedMessages) )</span>
<a href="#l20.5421"></a><span id="l20.5421" class="difflineminus">-    {</span>
<a href="#l20.5422"></a><span id="l20.5422" class="difflineplus">+    if ((onlineIndex &gt;= numMessageInFlagState) ||</span>
<a href="#l20.5423"></a><span id="l20.5423" class="difflineplus">+        (existingKeys[keyIndex] != uidOfMessage) ||</span>
<a href="#l20.5424"></a><span id="l20.5424" class="difflineplus">+        ((flags &amp; kImapMsgDeletedFlag) &amp;&amp; !showDeletedMessages)) {</span>
<a href="#l20.5425"></a><span id="l20.5425">       nsMsgKey doomedKey = existingKeys[keyIndex];</span>
<a href="#l20.5426"></a><span id="l20.5426" class="difflineminus">-      if ((int32_t) doomedKey &lt;= 0 &amp;&amp; doomedKey != nsMsgKey_None)</span>
<a href="#l20.5427"></a><span id="l20.5427" class="difflineminus">-        continue;</span>
<a href="#l20.5428"></a><span id="l20.5428" class="difflineplus">+      if ((int32_t)doomedKey &lt;= 0 &amp;&amp; doomedKey != nsMsgKey_None) continue;</span>
<a href="#l20.5429"></a><span id="l20.5429"> </span>
<a href="#l20.5430"></a><span id="l20.5430">       keysToDelete.AppendElement(existingKeys[keyIndex]);</span>
<a href="#l20.5431"></a><span id="l20.5431">     }</span>
<a href="#l20.5432"></a><span id="l20.5432"> </span>
<a href="#l20.5433"></a><span id="l20.5433">     flagState-&gt;GetUidOfMessage(onlineIndex, &amp;uidOfMessage);</span>
<a href="#l20.5434"></a><span id="l20.5434" class="difflineminus">-    if (existingKeys[keyIndex] == uidOfMessage)</span>
<a href="#l20.5435"></a><span id="l20.5435" class="difflineminus">-      onlineIndex++;</span>
<a href="#l20.5436"></a><span id="l20.5436" class="difflineminus">-  }</span>
<a href="#l20.5437"></a><span id="l20.5437" class="difflineminus">-}</span>
<a href="#l20.5438"></a><span id="l20.5438" class="difflineminus">-</span>
<a href="#l20.5439"></a><span id="l20.5439" class="difflineminus">-void nsImapMailFolder::FindKeysToAdd(const nsTArray&lt;nsMsgKey&gt; &amp;existingKeys, nsTArray&lt;nsMsgKey&gt; &amp;keysToFetch, uint32_t &amp;numNewUnread, nsIImapFlagAndUidState *flagState)</span>
<a href="#l20.5440"></a><span id="l20.5440" class="difflineminus">-{</span>
<a href="#l20.5441"></a><span id="l20.5441" class="difflineplus">+    if (existingKeys[keyIndex] == uidOfMessage) onlineIndex++;</span>
<a href="#l20.5442"></a><span id="l20.5442" class="difflineplus">+  }</span>
<a href="#l20.5443"></a><span id="l20.5443" class="difflineplus">+}</span>
<a href="#l20.5444"></a><span id="l20.5444" class="difflineplus">+</span>
<a href="#l20.5445"></a><span id="l20.5445" class="difflineplus">+void nsImapMailFolder::FindKeysToAdd(const nsTArray&lt;nsMsgKey&gt; &amp;existingKeys,</span>
<a href="#l20.5446"></a><span id="l20.5446" class="difflineplus">+                                     nsTArray&lt;nsMsgKey&gt; &amp;keysToFetch,</span>
<a href="#l20.5447"></a><span id="l20.5447" class="difflineplus">+                                     uint32_t &amp;numNewUnread,</span>
<a href="#l20.5448"></a><span id="l20.5448" class="difflineplus">+                                     nsIImapFlagAndUidState *flagState) {</span>
<a href="#l20.5449"></a><span id="l20.5449">   bool showDeletedMessages = ShowDeletedMessages();</span>
<a href="#l20.5450"></a><span id="l20.5450" class="difflineminus">-  int dbIndex=0; // current index into existingKeys</span>
<a href="#l20.5451"></a><span id="l20.5451" class="difflineplus">+  int dbIndex = 0;  // current index into existingKeys</span>
<a href="#l20.5452"></a><span id="l20.5452">   int32_t existTotal, numberOfKnownKeys;</span>
<a href="#l20.5453"></a><span id="l20.5453">   int32_t messageIndex;</span>
<a href="#l20.5454"></a><span id="l20.5454"> </span>
<a href="#l20.5455"></a><span id="l20.5455">   numNewUnread = 0;</span>
<a href="#l20.5456"></a><span id="l20.5456">   existTotal = numberOfKnownKeys = existingKeys.Length();</span>
<a href="#l20.5457"></a><span id="l20.5457">   flagState-&gt;GetNumberOfMessages(&amp;messageIndex);</span>
<a href="#l20.5458"></a><span id="l20.5458">   bool partialUIDFetch;</span>
<a href="#l20.5459"></a><span id="l20.5459">   flagState-&gt;GetPartialUIDFetch(&amp;partialUIDFetch);</span>
<a href="#l20.5460"></a><span id="l20.5460"> </span>
<a href="#l20.5461"></a><span id="l20.5461" class="difflineminus">-  for (int32_t flagIndex=0; flagIndex &lt; messageIndex; flagIndex++)</span>
<a href="#l20.5462"></a><span id="l20.5462" class="difflineminus">-  {</span>
<a href="#l20.5463"></a><span id="l20.5463" class="difflineplus">+  for (int32_t flagIndex = 0; flagIndex &lt; messageIndex; flagIndex++) {</span>
<a href="#l20.5464"></a><span id="l20.5464">     uint32_t uidOfMessage;</span>
<a href="#l20.5465"></a><span id="l20.5465">     flagState-&gt;GetUidOfMessage(flagIndex, &amp;uidOfMessage);</span>
<a href="#l20.5466"></a><span id="l20.5466" class="difflineminus">-    while ( (flagIndex &lt; numberOfKnownKeys) &amp;&amp; (dbIndex &lt; existTotal) &amp;&amp;</span>
<a href="#l20.5467"></a><span id="l20.5467" class="difflineminus">-        existingKeys[dbIndex] &lt; uidOfMessage)</span>
<a href="#l20.5468"></a><span id="l20.5468" class="difflineplus">+    while ((flagIndex &lt; numberOfKnownKeys) &amp;&amp; (dbIndex &lt; existTotal) &amp;&amp;</span>
<a href="#l20.5469"></a><span id="l20.5469" class="difflineplus">+           existingKeys[dbIndex] &lt; uidOfMessage)</span>
<a href="#l20.5470"></a><span id="l20.5470">       dbIndex++;</span>
<a href="#l20.5471"></a><span id="l20.5471"> </span>
<a href="#l20.5472"></a><span id="l20.5472" class="difflineminus">-    if ( (flagIndex &gt;= numberOfKnownKeys)  ||</span>
<a href="#l20.5473"></a><span id="l20.5473" class="difflineminus">-       (dbIndex &gt;= existTotal) ||</span>
<a href="#l20.5474"></a><span id="l20.5474" class="difflineminus">-       (existingKeys[dbIndex] != uidOfMessage ) )</span>
<a href="#l20.5475"></a><span id="l20.5475" class="difflineminus">-    {</span>
<a href="#l20.5476"></a><span id="l20.5476" class="difflineplus">+    if ((flagIndex &gt;= numberOfKnownKeys) || (dbIndex &gt;= existTotal) ||</span>
<a href="#l20.5477"></a><span id="l20.5477" class="difflineplus">+        (existingKeys[dbIndex] != uidOfMessage)) {</span>
<a href="#l20.5478"></a><span id="l20.5478">       numberOfKnownKeys++;</span>
<a href="#l20.5479"></a><span id="l20.5479"> </span>
<a href="#l20.5480"></a><span id="l20.5480">       imapMessageFlagsType flags;</span>
<a href="#l20.5481"></a><span id="l20.5481">       flagState-&gt;GetMessageFlags(flagIndex, &amp;flags);</span>
<a href="#l20.5482"></a><span id="l20.5482">       NS_ASSERTION(uidOfMessage != nsMsgKey_None, &quot;got invalid msg key&quot;);</span>
<a href="#l20.5483"></a><span id="l20.5483" class="difflineminus">-      if (uidOfMessage &amp;&amp; uidOfMessage != nsMsgKey_None &amp;&amp; (showDeletedMessages || ! (flags &amp; kImapMsgDeletedFlag)))</span>
<a href="#l20.5484"></a><span id="l20.5484" class="difflineminus">-      {</span>
<a href="#l20.5485"></a><span id="l20.5485" class="difflineminus">-        if (mDatabase)</span>
<a href="#l20.5486"></a><span id="l20.5486" class="difflineminus">-        {</span>
<a href="#l20.5487"></a><span id="l20.5487" class="difflineplus">+      if (uidOfMessage &amp;&amp; uidOfMessage != nsMsgKey_None &amp;&amp;</span>
<a href="#l20.5488"></a><span id="l20.5488" class="difflineplus">+          (showDeletedMessages || !(flags &amp; kImapMsgDeletedFlag))) {</span>
<a href="#l20.5489"></a><span id="l20.5489" class="difflineplus">+        if (mDatabase) {</span>
<a href="#l20.5490"></a><span id="l20.5490">           bool dbContainsKey;</span>
<a href="#l20.5491"></a><span id="l20.5491" class="difflineminus">-          if (NS_SUCCEEDED(mDatabase-&gt;ContainsKey(uidOfMessage, &amp;dbContainsKey)) &amp;&amp;</span>
<a href="#l20.5492"></a><span id="l20.5492" class="difflineminus">-              dbContainsKey)</span>
<a href="#l20.5493"></a><span id="l20.5493" class="difflineminus">-          {</span>
<a href="#l20.5494"></a><span id="l20.5494" class="difflineplus">+          if (NS_SUCCEEDED(</span>
<a href="#l20.5495"></a><span id="l20.5495" class="difflineplus">+                  mDatabase-&gt;ContainsKey(uidOfMessage, &amp;dbContainsKey)) &amp;&amp;</span>
<a href="#l20.5496"></a><span id="l20.5496" class="difflineplus">+              dbContainsKey) {</span>
<a href="#l20.5497"></a><span id="l20.5497">             // this is expected in the partial uid fetch case because the</span>
<a href="#l20.5498"></a><span id="l20.5498">             // flag state does not contain all messages, so the db has</span>
<a href="#l20.5499"></a><span id="l20.5499">             // messages the flag state doesn't know about.</span>
<a href="#l20.5500"></a><span id="l20.5500" class="difflineminus">-            if (!partialUIDFetch)</span>
<a href="#l20.5501"></a><span id="l20.5501" class="difflineminus">-              NS_ERROR(&quot;db has key - flagState messed up?&quot;);</span>
<a href="#l20.5502"></a><span id="l20.5502" class="difflineplus">+            if (!partialUIDFetch) NS_ERROR(&quot;db has key - flagState messed up?&quot;);</span>
<a href="#l20.5503"></a><span id="l20.5503">             continue;</span>
<a href="#l20.5504"></a><span id="l20.5504">           }</span>
<a href="#l20.5505"></a><span id="l20.5505">         }</span>
<a href="#l20.5506"></a><span id="l20.5506">         keysToFetch.AppendElement(uidOfMessage);</span>
<a href="#l20.5507"></a><span id="l20.5507" class="difflineminus">-        if (! (flags &amp; kImapMsgSeenFlag))</span>
<a href="#l20.5508"></a><span id="l20.5508" class="difflineminus">-          numNewUnread++;</span>
<a href="#l20.5509"></a><span id="l20.5509" class="difflineplus">+        if (!(flags &amp; kImapMsgSeenFlag)) numNewUnread++;</span>
<a href="#l20.5510"></a><span id="l20.5510">       }</span>
<a href="#l20.5511"></a><span id="l20.5511">     }</span>
<a href="#l20.5512"></a><span id="l20.5512">   }</span>
<a href="#l20.5513"></a><span id="l20.5513"> }</span>
<a href="#l20.5514"></a><span id="l20.5514"> </span>
<a href="#l20.5515"></a><span id="l20.5515"> NS_IMETHODIMP nsImapMailFolder::GetMsgHdrsToDownload(bool *aMoreToDownload,</span>
<a href="#l20.5516"></a><span id="l20.5516">                                                      int32_t *aTotalCount,</span>
<a href="#l20.5517"></a><span id="l20.5517">                                                      uint32_t *aLength,</span>
<a href="#l20.5518"></a><span id="l20.5518" class="difflineminus">-                                                     nsMsgKey **aKeys)</span>
<a href="#l20.5519"></a><span id="l20.5519" class="difflineminus">-{</span>
<a href="#l20.5520"></a><span id="l20.5520" class="difflineplus">+                                                     nsMsgKey **aKeys) {</span>
<a href="#l20.5521"></a><span id="l20.5521">   NS_ENSURE_ARG_POINTER(aMoreToDownload);</span>
<a href="#l20.5522"></a><span id="l20.5522">   NS_ENSURE_ARG_POINTER(aTotalCount);</span>
<a href="#l20.5523"></a><span id="l20.5523">   NS_ENSURE_ARG_POINTER(aLength);</span>
<a href="#l20.5524"></a><span id="l20.5524">   NS_ENSURE_ARG_POINTER(aKeys);</span>
<a href="#l20.5525"></a><span id="l20.5525"> </span>
<a href="#l20.5526"></a><span id="l20.5526">   *aMoreToDownload = false;</span>
<a href="#l20.5527"></a><span id="l20.5527">   *aTotalCount = m_totalKeysToFetch;</span>
<a href="#l20.5528"></a><span id="l20.5528" class="difflineminus">-  if (m_keysToFetch.IsEmpty())</span>
<a href="#l20.5529"></a><span id="l20.5529" class="difflineminus">-  {</span>
<a href="#l20.5530"></a><span id="l20.5530" class="difflineplus">+  if (m_keysToFetch.IsEmpty()) {</span>
<a href="#l20.5531"></a><span id="l20.5531">     *aLength = 0;</span>
<a href="#l20.5532"></a><span id="l20.5532">     return NS_OK;</span>
<a href="#l20.5533"></a><span id="l20.5533">   }</span>
<a href="#l20.5534"></a><span id="l20.5534"> </span>
<a href="#l20.5535"></a><span id="l20.5535">   // if folder isn't open in a window, no reason to limit the number of headers</span>
<a href="#l20.5536"></a><span id="l20.5536">   // we download.</span>
<a href="#l20.5537"></a><span id="l20.5537" class="difflineminus">-  nsCOMPtr&lt;nsIMsgMailSession&gt; session = do_GetService(NS_MSGMAILSESSION_CONTRACTID);</span>
<a href="#l20.5538"></a><span id="l20.5538" class="difflineplus">+  nsCOMPtr&lt;nsIMsgMailSession&gt; session =</span>
<a href="#l20.5539"></a><span id="l20.5539" class="difflineplus">+      do_GetService(NS_MSGMAILSESSION_CONTRACTID);</span>
<a href="#l20.5540"></a><span id="l20.5540">   bool folderOpen = false;</span>
<a href="#l20.5541"></a><span id="l20.5541" class="difflineminus">-  if (session)</span>
<a href="#l20.5542"></a><span id="l20.5542" class="difflineminus">-    session-&gt;IsFolderOpenInWindow(this, &amp;folderOpen);</span>
<a href="#l20.5543"></a><span id="l20.5543" class="difflineplus">+  if (session) session-&gt;IsFolderOpenInWindow(this, &amp;folderOpen);</span>
<a href="#l20.5544"></a><span id="l20.5544"> </span>
<a href="#l20.5545"></a><span id="l20.5545">   int32_t hdrChunkSize = 200;</span>
<a href="#l20.5546"></a><span id="l20.5546" class="difflineminus">-  if (folderOpen)</span>
<a href="#l20.5547"></a><span id="l20.5547" class="difflineminus">-  {</span>
<a href="#l20.5548"></a><span id="l20.5548" class="difflineplus">+  if (folderOpen) {</span>
<a href="#l20.5549"></a><span id="l20.5549">     nsresult rv;</span>
<a href="#l20.5550"></a><span id="l20.5550" class="difflineminus">-    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l20.5551"></a><span id="l20.5551" class="difflineplus">+    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(</span>
<a href="#l20.5552"></a><span id="l20.5552" class="difflineplus">+        do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l20.5553"></a><span id="l20.5553">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.5554"></a><span id="l20.5554">     if (prefBranch)</span>
<a href="#l20.5555"></a><span id="l20.5555">       prefBranch-&gt;GetIntPref(&quot;mail.imap.hdr_chunk_size&quot;, &amp;hdrChunkSize);</span>
<a href="#l20.5556"></a><span id="l20.5556">   }</span>
<a href="#l20.5557"></a><span id="l20.5557">   int32_t numKeysToFetch = m_keysToFetch.Length();</span>
<a href="#l20.5558"></a><span id="l20.5558">   int32_t startIndex = 0;</span>
<a href="#l20.5559"></a><span id="l20.5559" class="difflineminus">-  if (folderOpen &amp;&amp; hdrChunkSize &gt; 0 &amp;&amp; (int32_t) m_keysToFetch.Length() &gt; hdrChunkSize)</span>
<a href="#l20.5560"></a><span id="l20.5560" class="difflineminus">-  {</span>
<a href="#l20.5561"></a><span id="l20.5561" class="difflineplus">+  if (folderOpen &amp;&amp; hdrChunkSize &gt; 0 &amp;&amp;</span>
<a href="#l20.5562"></a><span id="l20.5562" class="difflineplus">+      (int32_t)m_keysToFetch.Length() &gt; hdrChunkSize) {</span>
<a href="#l20.5563"></a><span id="l20.5563">     numKeysToFetch = hdrChunkSize;</span>
<a href="#l20.5564"></a><span id="l20.5564">     *aMoreToDownload = true;</span>
<a href="#l20.5565"></a><span id="l20.5565">     startIndex = m_keysToFetch.Length() - hdrChunkSize;</span>
<a href="#l20.5566"></a><span id="l20.5566">   }</span>
<a href="#l20.5567"></a><span id="l20.5567" class="difflineminus">-  *aKeys = (nsMsgKey *) moz_xmemdup(&amp;m_keysToFetch[startIndex],</span>
<a href="#l20.5568"></a><span id="l20.5568" class="difflineminus">-                                    numKeysToFetch * sizeof(nsMsgKey));</span>
<a href="#l20.5569"></a><span id="l20.5569" class="difflineplus">+  *aKeys = (nsMsgKey *)moz_xmemdup(&amp;m_keysToFetch[startIndex],</span>
<a href="#l20.5570"></a><span id="l20.5570" class="difflineplus">+                                   numKeysToFetch * sizeof(nsMsgKey));</span>
<a href="#l20.5571"></a><span id="l20.5571">   NS_ENSURE_TRUE(*aKeys, NS_ERROR_OUT_OF_MEMORY);</span>
<a href="#l20.5572"></a><span id="l20.5572">   // Remove these for the incremental header download case, so that</span>
<a href="#l20.5573"></a><span id="l20.5573">   // we know we don't have to download them again.</span>
<a href="#l20.5574"></a><span id="l20.5574">   m_keysToFetch.RemoveElementsAt(startIndex, numKeysToFetch);</span>
<a href="#l20.5575"></a><span id="l20.5575">   *aLength = numKeysToFetch;</span>
<a href="#l20.5576"></a><span id="l20.5576"> </span>
<a href="#l20.5577"></a><span id="l20.5577">   return NS_OK;</span>
<a href="#l20.5578"></a><span id="l20.5578"> }</span>
<a href="#l20.5579"></a><span id="l20.5579"> </span>
<a href="#l20.5580"></a><span id="l20.5580" class="difflineminus">-void nsImapMailFolder::PrepareToAddHeadersToMailDB(nsIImapProtocol* aProtocol)</span>
<a href="#l20.5581"></a><span id="l20.5581" class="difflineminus">-{</span>
<a href="#l20.5582"></a><span id="l20.5582" class="difflineplus">+void nsImapMailFolder::PrepareToAddHeadersToMailDB(nsIImapProtocol *aProtocol) {</span>
<a href="#l20.5583"></a><span id="l20.5583">   // now, tell it we don't need any bodies.</span>
<a href="#l20.5584"></a><span id="l20.5584">   aProtocol-&gt;NotifyBodysToDownload(nullptr, 0);</span>
<a href="#l20.5585"></a><span id="l20.5585"> }</span>
<a href="#l20.5586"></a><span id="l20.5586"> </span>
<a href="#l20.5587"></a><span id="l20.5587" class="difflineminus">-void nsImapMailFolder::TweakHeaderFlags(nsIImapProtocol* aProtocol, nsIMsgDBHdr *tweakMe)</span>
<a href="#l20.5588"></a><span id="l20.5588" class="difflineminus">-{</span>
<a href="#l20.5589"></a><span id="l20.5589" class="difflineminus">-  if (mDatabase &amp;&amp; aProtocol &amp;&amp; tweakMe)</span>
<a href="#l20.5590"></a><span id="l20.5590" class="difflineminus">-  {</span>
<a href="#l20.5591"></a><span id="l20.5591" class="difflineplus">+void nsImapMailFolder::TweakHeaderFlags(nsIImapProtocol *aProtocol,</span>
<a href="#l20.5592"></a><span id="l20.5592" class="difflineplus">+                                        nsIMsgDBHdr *tweakMe) {</span>
<a href="#l20.5593"></a><span id="l20.5593" class="difflineplus">+  if (mDatabase &amp;&amp; aProtocol &amp;&amp; tweakMe) {</span>
<a href="#l20.5594"></a><span id="l20.5594">     tweakMe-&gt;SetMessageKey(m_curMsgUid);</span>
<a href="#l20.5595"></a><span id="l20.5595">     tweakMe-&gt;SetMessageSize(m_nextMessageByteLength);</span>
<a href="#l20.5596"></a><span id="l20.5596"> </span>
<a href="#l20.5597"></a><span id="l20.5597">     bool foundIt = false;</span>
<a href="#l20.5598"></a><span id="l20.5598">     imapMessageFlagsType imap_flags;</span>
<a href="#l20.5599"></a><span id="l20.5599"> </span>
<a href="#l20.5600"></a><span id="l20.5600">     nsCString customFlags;</span>
<a href="#l20.5601"></a><span id="l20.5601" class="difflineminus">-    nsresult rv = aProtocol-&gt;GetFlagsForUID(m_curMsgUid, &amp;foundIt, &amp;imap_flags, getter_Copies(customFlags));</span>
<a href="#l20.5602"></a><span id="l20.5602" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; foundIt)</span>
<a href="#l20.5603"></a><span id="l20.5603" class="difflineminus">-    {</span>
<a href="#l20.5604"></a><span id="l20.5604" class="difflineplus">+    nsresult rv = aProtocol-&gt;GetFlagsForUID(m_curMsgUid, &amp;foundIt, &amp;imap_flags,</span>
<a href="#l20.5605"></a><span id="l20.5605" class="difflineplus">+                                            getter_Copies(customFlags));</span>
<a href="#l20.5606"></a><span id="l20.5606" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; foundIt) {</span>
<a href="#l20.5607"></a><span id="l20.5607">       // make a mask and clear these message flags</span>
<a href="#l20.5608"></a><span id="l20.5608">       uint32_t mask = nsMsgMessageFlags::Read | nsMsgMessageFlags::Replied |</span>
<a href="#l20.5609"></a><span id="l20.5609" class="difflineminus">-                      nsMsgMessageFlags::Marked | nsMsgMessageFlags::IMAPDeleted |</span>
<a href="#l20.5610"></a><span id="l20.5610" class="difflineplus">+                      nsMsgMessageFlags::Marked |</span>
<a href="#l20.5611"></a><span id="l20.5611" class="difflineplus">+                      nsMsgMessageFlags::IMAPDeleted |</span>
<a href="#l20.5612"></a><span id="l20.5612">                       nsMsgMessageFlags::Labels;</span>
<a href="#l20.5613"></a><span id="l20.5613">       uint32_t dbHdrFlags;</span>
<a href="#l20.5614"></a><span id="l20.5614"> </span>
<a href="#l20.5615"></a><span id="l20.5615">       tweakMe-&gt;GetFlags(&amp;dbHdrFlags);</span>
<a href="#l20.5616"></a><span id="l20.5616">       tweakMe-&gt;AndFlags(~mask, &amp;dbHdrFlags);</span>
<a href="#l20.5617"></a><span id="l20.5617"> </span>
<a href="#l20.5618"></a><span id="l20.5618">       // set the new value for these flags</span>
<a href="#l20.5619"></a><span id="l20.5619">       uint32_t newFlags = 0;</span>
<a href="#l20.5620"></a><span id="l20.5620">       if (imap_flags &amp; kImapMsgSeenFlag)</span>
<a href="#l20.5621"></a><span id="l20.5621">         newFlags |= nsMsgMessageFlags::Read;</span>
<a href="#l20.5622"></a><span id="l20.5622" class="difflineminus">-      else // if (imap_flags &amp; kImapMsgRecentFlag)</span>
<a href="#l20.5623"></a><span id="l20.5623" class="difflineplus">+      else  // if (imap_flags &amp; kImapMsgRecentFlag)</span>
<a href="#l20.5624"></a><span id="l20.5624">         newFlags |= nsMsgMessageFlags::New;</span>
<a href="#l20.5625"></a><span id="l20.5625"> </span>
<a href="#l20.5626"></a><span id="l20.5626">       // Okay here is the MDN needed logic (if DNT header seen):</span>
<a href="#l20.5627"></a><span id="l20.5627">       /* if server support user defined flag:</span>
<a href="#l20.5628"></a><span id="l20.5628" class="difflineplus">+         XXX TODO: Fix badly formatted comment which doesn't reflect the code.</span>
<a href="#l20.5629"></a><span id="l20.5629">                     MDNSent flag set =&gt; clear kMDNNeeded flag</span>
<a href="#l20.5630"></a><span id="l20.5630">                     MDNSent flag not set =&gt; do nothing, leave kMDNNeeded on</span>
<a href="#l20.5631"></a><span id="l20.5631">                     else if</span>
<a href="#l20.5632"></a><span id="l20.5632">                     not nsMsgMessageFlags::New =&gt; clear kMDNNeeded flag</span>
<a href="#l20.5633"></a><span id="l20.5633">                    nsMsgMessageFlags::New =&gt; do nothing, leave kMDNNeeded on</span>
<a href="#l20.5634"></a><span id="l20.5634">                */</span>
<a href="#l20.5635"></a><span id="l20.5635">       uint16_t userFlags;</span>
<a href="#l20.5636"></a><span id="l20.5636">       rv = aProtocol-&gt;GetSupportedUserFlags(&amp;userFlags);</span>
<a href="#l20.5637"></a><span id="l20.5637">       if (NS_SUCCEEDED(rv) &amp;&amp; (userFlags &amp; (kImapMsgSupportUserFlag |</span>
<a href="#l20.5638"></a><span id="l20.5638" class="difflineminus">-                            kImapMsgSupportMDNSentFlag)))</span>
<a href="#l20.5639"></a><span id="l20.5639" class="difflineminus">-      {</span>
<a href="#l20.5640"></a><span id="l20.5640" class="difflineminus">-        if (imap_flags &amp; kImapMsgMDNSentFlag)</span>
<a href="#l20.5641"></a><span id="l20.5641" class="difflineminus">-        {</span>
<a href="#l20.5642"></a><span id="l20.5642" class="difflineplus">+                                            kImapMsgSupportMDNSentFlag))) {</span>
<a href="#l20.5643"></a><span id="l20.5643" class="difflineplus">+        if (imap_flags &amp; kImapMsgMDNSentFlag) {</span>
<a href="#l20.5644"></a><span id="l20.5644">           newFlags |= nsMsgMessageFlags::MDNReportSent;</span>
<a href="#l20.5645"></a><span id="l20.5645">           if (dbHdrFlags &amp; nsMsgMessageFlags::MDNReportNeeded)</span>
<a href="#l20.5646"></a><span id="l20.5646">             tweakMe-&gt;AndFlags(~nsMsgMessageFlags::MDNReportNeeded, &amp;dbHdrFlags);</span>
<a href="#l20.5647"></a><span id="l20.5647">         }</span>
<a href="#l20.5648"></a><span id="l20.5648">       }</span>
<a href="#l20.5649"></a><span id="l20.5649"> </span>
<a href="#l20.5650"></a><span id="l20.5650">       if (imap_flags &amp; kImapMsgAnsweredFlag)</span>
<a href="#l20.5651"></a><span id="l20.5651">         newFlags |= nsMsgMessageFlags::Replied;</span>
<a href="#l20.5652"></a><span id="l20.5652" class="difflineat">@@ -4427,220 +4092,201 @@ void nsImapMailFolder::TweakHeaderFlags(</span>
<a href="#l20.5653"></a><span id="l20.5653">         newFlags |= nsMsgMessageFlags::Marked;</span>
<a href="#l20.5654"></a><span id="l20.5654">       if (imap_flags &amp; kImapMsgDeletedFlag)</span>
<a href="#l20.5655"></a><span id="l20.5655">         newFlags |= nsMsgMessageFlags::IMAPDeleted;</span>
<a href="#l20.5656"></a><span id="l20.5656">       if (imap_flags &amp; kImapMsgForwardedFlag)</span>
<a href="#l20.5657"></a><span id="l20.5657">         newFlags |= nsMsgMessageFlags::Forwarded;</span>
<a href="#l20.5658"></a><span id="l20.5658"> </span>
<a href="#l20.5659"></a><span id="l20.5659">       // db label flags are 0x0E000000 and imap label flags are 0x0E00</span>
<a href="#l20.5660"></a><span id="l20.5660">       // so we need to shift 16 bits to the left to convert them.</span>
<a href="#l20.5661"></a><span id="l20.5661" class="difflineminus">-      if (imap_flags &amp; kImapMsgLabelFlags)</span>
<a href="#l20.5662"></a><span id="l20.5662" class="difflineminus">-      {</span>
<a href="#l20.5663"></a><span id="l20.5663" class="difflineplus">+      if (imap_flags &amp; kImapMsgLabelFlags) {</span>
<a href="#l20.5664"></a><span id="l20.5664">         // we need to set label attribute on header because the dbview code</span>
<a href="#l20.5665"></a><span id="l20.5665">         // does msgHdr-&gt;GetLabel when asked to paint a row</span>
<a href="#l20.5666"></a><span id="l20.5666">         tweakMe-&gt;SetLabel((imap_flags &amp; kImapMsgLabelFlags) &gt;&gt; 9);</span>
<a href="#l20.5667"></a><span id="l20.5667">         newFlags |= (imap_flags &amp; kImapMsgLabelFlags) &lt;&lt; 16;</span>
<a href="#l20.5668"></a><span id="l20.5668">       }</span>
<a href="#l20.5669"></a><span id="l20.5669" class="difflineminus">-      if (newFlags)</span>
<a href="#l20.5670"></a><span id="l20.5670" class="difflineminus">-        tweakMe-&gt;OrFlags(newFlags, &amp;dbHdrFlags);</span>
<a href="#l20.5671"></a><span id="l20.5671" class="difflineplus">+      if (newFlags) tweakMe-&gt;OrFlags(newFlags, &amp;dbHdrFlags);</span>
<a href="#l20.5672"></a><span id="l20.5672">       if (!customFlags.IsEmpty())</span>
<a href="#l20.5673"></a><span id="l20.5673" class="difflineminus">-        (void) HandleCustomFlags(m_curMsgUid, tweakMe, userFlags, customFlags, nullptr);</span>
<a href="#l20.5674"></a><span id="l20.5674" class="difflineplus">+        (void)HandleCustomFlags(m_curMsgUid, tweakMe, userFlags, customFlags,</span>
<a href="#l20.5675"></a><span id="l20.5675" class="difflineplus">+                                nullptr);</span>
<a href="#l20.5676"></a><span id="l20.5676">     }</span>
<a href="#l20.5677"></a><span id="l20.5677">   }</span>
<a href="#l20.5678"></a><span id="l20.5678"> }</span>
<a href="#l20.5679"></a><span id="l20.5679"> </span>
<a href="#l20.5680"></a><span id="l20.5680"> NS_IMETHODIMP</span>
<a href="#l20.5681"></a><span id="l20.5681" class="difflineminus">-nsImapMailFolder::SetupMsgWriteStream(nsIFile * aFile, bool addDummyEnvelope)</span>
<a href="#l20.5682"></a><span id="l20.5682" class="difflineminus">-{</span>
<a href="#l20.5683"></a><span id="l20.5683" class="difflineplus">+nsImapMailFolder::SetupMsgWriteStream(nsIFile *aFile, bool addDummyEnvelope) {</span>
<a href="#l20.5684"></a><span id="l20.5684">   nsresult rv;</span>
<a href="#l20.5685"></a><span id="l20.5685">   aFile-&gt;Remove(false);</span>
<a href="#l20.5686"></a><span id="l20.5686" class="difflineminus">-  rv = MsgNewBufferedFileOutputStream(getter_AddRefs(m_tempMessageStream), aFile, PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE, 00700);</span>
<a href="#l20.5687"></a><span id="l20.5687" class="difflineminus">-  if (m_tempMessageStream &amp;&amp; addDummyEnvelope)</span>
<a href="#l20.5688"></a><span id="l20.5688" class="difflineminus">-  {</span>
<a href="#l20.5689"></a><span id="l20.5689" class="difflineplus">+  rv = MsgNewBufferedFileOutputStream(</span>
<a href="#l20.5690"></a><span id="l20.5690" class="difflineplus">+      getter_AddRefs(m_tempMessageStream), aFile,</span>
<a href="#l20.5691"></a><span id="l20.5691" class="difflineplus">+      PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE, 00700);</span>
<a href="#l20.5692"></a><span id="l20.5692" class="difflineplus">+  if (m_tempMessageStream &amp;&amp; addDummyEnvelope) {</span>
<a href="#l20.5693"></a><span id="l20.5693">     nsAutoCString result;</span>
<a href="#l20.5694"></a><span id="l20.5694">     char *ct;</span>
<a href="#l20.5695"></a><span id="l20.5695">     uint32_t writeCount;</span>
<a href="#l20.5696"></a><span id="l20.5696" class="difflineminus">-    time_t now = time ((time_t*) 0);</span>
<a href="#l20.5697"></a><span id="l20.5697" class="difflineplus">+    time_t now = time((time_t *)0);</span>
<a href="#l20.5698"></a><span id="l20.5698">     ct = ctime(&amp;now);</span>
<a href="#l20.5699"></a><span id="l20.5699">     ct[24] = 0;</span>
<a href="#l20.5700"></a><span id="l20.5700">     result = &quot;From - &quot;;</span>
<a href="#l20.5701"></a><span id="l20.5701">     result += ct;</span>
<a href="#l20.5702"></a><span id="l20.5702">     result += MSG_LINEBREAK;</span>
<a href="#l20.5703"></a><span id="l20.5703"> </span>
<a href="#l20.5704"></a><span id="l20.5704">     m_tempMessageStream-&gt;Write(result.get(), result.Length(), &amp;writeCount);</span>
<a href="#l20.5705"></a><span id="l20.5705">     result = &quot;X-Mozilla-Status: 0001&quot;;</span>
<a href="#l20.5706"></a><span id="l20.5706">     result += MSG_LINEBREAK;</span>
<a href="#l20.5707"></a><span id="l20.5707">     m_tempMessageStream-&gt;Write(result.get(), result.Length(), &amp;writeCount);</span>
<a href="#l20.5708"></a><span id="l20.5708" class="difflineminus">-    result =  &quot;X-Mozilla-Status2: 00000000&quot;;</span>
<a href="#l20.5709"></a><span id="l20.5709" class="difflineplus">+    result = &quot;X-Mozilla-Status2: 00000000&quot;;</span>
<a href="#l20.5710"></a><span id="l20.5710">     result += MSG_LINEBREAK;</span>
<a href="#l20.5711"></a><span id="l20.5711">     m_tempMessageStream-&gt;Write(result.get(), result.Length(), &amp;writeCount);</span>
<a href="#l20.5712"></a><span id="l20.5712">   }</span>
<a href="#l20.5713"></a><span id="l20.5713">   return rv;</span>
<a href="#l20.5714"></a><span id="l20.5714"> }</span>
<a href="#l20.5715"></a><span id="l20.5715"> </span>
<a href="#l20.5716"></a><span id="l20.5716" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::DownloadMessagesForOffline(nsIArray *messages, nsIMsgWindow *window)</span>
<a href="#l20.5717"></a><span id="l20.5717" class="difflineminus">-{</span>
<a href="#l20.5718"></a><span id="l20.5718" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::DownloadMessagesForOffline(</span>
<a href="#l20.5719"></a><span id="l20.5719" class="difflineplus">+    nsIArray *messages, nsIMsgWindow *window) {</span>
<a href="#l20.5720"></a><span id="l20.5720">   nsAutoCString messageIds;</span>
<a href="#l20.5721"></a><span id="l20.5721">   nsTArray&lt;nsMsgKey&gt; srcKeyArray;</span>
<a href="#l20.5722"></a><span id="l20.5722">   nsresult rv = BuildIdsAndKeyArray(messages, messageIds, srcKeyArray);</span>
<a href="#l20.5723"></a><span id="l20.5723">   if (NS_FAILED(rv) || messageIds.IsEmpty()) return rv;</span>
<a href="#l20.5724"></a><span id="l20.5724"> </span>
<a href="#l20.5725"></a><span id="l20.5725" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.5726"></a><span id="l20.5726" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.5727"></a><span id="l20.5727" class="difflineminus">-</span>
<a href="#l20.5728"></a><span id="l20.5728" class="difflineminus">-  rv = AcquireSemaphore(static_cast&lt;nsIMsgFolder*&gt;(this));</span>
<a href="#l20.5729"></a><span id="l20.5729" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l20.5730"></a><span id="l20.5730" class="difflineminus">-  {</span>
<a href="#l20.5731"></a><span id="l20.5731" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.5732"></a><span id="l20.5732" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.5733"></a><span id="l20.5733" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.5734"></a><span id="l20.5734" class="difflineplus">+</span>
<a href="#l20.5735"></a><span id="l20.5735" class="difflineplus">+  rv = AcquireSemaphore(static_cast&lt;nsIMsgFolder *&gt;(this));</span>
<a href="#l20.5736"></a><span id="l20.5736" class="difflineplus">+  if (NS_FAILED(rv)) {</span>
<a href="#l20.5737"></a><span id="l20.5737">     ThrowAlertMsg(&quot;operationFailedFolderBusy&quot;, window);</span>
<a href="#l20.5738"></a><span id="l20.5738">     return rv;</span>
<a href="#l20.5739"></a><span id="l20.5739">   }</span>
<a href="#l20.5740"></a><span id="l20.5740" class="difflineminus">-  return imapService-&gt;DownloadMessagesForOffline(messageIds, this, this, window);</span>
<a href="#l20.5741"></a><span id="l20.5741" class="difflineminus">-}</span>
<a href="#l20.5742"></a><span id="l20.5742" class="difflineminus">-</span>
<a href="#l20.5743"></a><span id="l20.5743" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::DownloadAllForOffline(nsIUrlListener *listener, nsIMsgWindow *msgWindow)</span>
<a href="#l20.5744"></a><span id="l20.5744" class="difflineminus">-{</span>
<a href="#l20.5745"></a><span id="l20.5745" class="difflineplus">+  return imapService-&gt;DownloadMessagesForOffline(messageIds, this, this,</span>
<a href="#l20.5746"></a><span id="l20.5746" class="difflineplus">+                                                 window);</span>
<a href="#l20.5747"></a><span id="l20.5747" class="difflineplus">+}</span>
<a href="#l20.5748"></a><span id="l20.5748" class="difflineplus">+</span>
<a href="#l20.5749"></a><span id="l20.5749" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::DownloadAllForOffline(nsIUrlListener *listener,</span>
<a href="#l20.5750"></a><span id="l20.5750" class="difflineplus">+                                                      nsIMsgWindow *msgWindow) {</span>
<a href="#l20.5751"></a><span id="l20.5751">   nsresult rv;</span>
<a href="#l20.5752"></a><span id="l20.5752" class="difflineminus">-  nsCOMPtr &lt;nsIURI&gt; runningURI;</span>
<a href="#l20.5753"></a><span id="l20.5753" class="difflineplus">+  nsCOMPtr&lt;nsIURI&gt; runningURI;</span>
<a href="#l20.5754"></a><span id="l20.5754">   bool noSelect;</span>
<a href="#l20.5755"></a><span id="l20.5755">   GetFlag(nsMsgFolderFlags::ImapNoselect, &amp;noSelect);</span>
<a href="#l20.5756"></a><span id="l20.5756"> </span>
<a href="#l20.5757"></a><span id="l20.5757" class="difflineminus">-  if (!noSelect)</span>
<a href="#l20.5758"></a><span id="l20.5758" class="difflineminus">-  {</span>
<a href="#l20.5759"></a><span id="l20.5759" class="difflineplus">+  if (!noSelect) {</span>
<a href="#l20.5760"></a><span id="l20.5760">     nsAutoCString messageIdsToDownload;</span>
<a href="#l20.5761"></a><span id="l20.5761">     nsTArray&lt;nsMsgKey&gt; msgsToDownload;</span>
<a href="#l20.5762"></a><span id="l20.5762"> </span>
<a href="#l20.5763"></a><span id="l20.5763">     GetDatabase();</span>
<a href="#l20.5764"></a><span id="l20.5764">     m_downloadingFolderForOfflineUse = true;</span>
<a href="#l20.5765"></a><span id="l20.5765"> </span>
<a href="#l20.5766"></a><span id="l20.5766" class="difflineminus">-    rv = AcquireSemaphore(static_cast&lt;nsIMsgFolder*&gt;(this));</span>
<a href="#l20.5767"></a><span id="l20.5767" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l20.5768"></a><span id="l20.5768" class="difflineminus">-    {</span>
<a href="#l20.5769"></a><span id="l20.5769" class="difflineplus">+    rv = AcquireSemaphore(static_cast&lt;nsIMsgFolder *&gt;(this));</span>
<a href="#l20.5770"></a><span id="l20.5770" class="difflineplus">+    if (NS_FAILED(rv)) {</span>
<a href="#l20.5771"></a><span id="l20.5771">       m_downloadingFolderForOfflineUse = false;</span>
<a href="#l20.5772"></a><span id="l20.5772">       ThrowAlertMsg(&quot;operationFailedFolderBusy&quot;, msgWindow);</span>
<a href="#l20.5773"></a><span id="l20.5773">       return rv;</span>
<a href="#l20.5774"></a><span id="l20.5774">     }</span>
<a href="#l20.5775"></a><span id="l20.5775" class="difflineminus">-    nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.5776"></a><span id="l20.5776" class="difflineplus">+    nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.5777"></a><span id="l20.5777" class="difflineplus">+        do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.5778"></a><span id="l20.5778">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.5779"></a><span id="l20.5779"> </span>
<a href="#l20.5780"></a><span id="l20.5780">     // Selecting the folder with nsIImapUrl::shouldStoreMsgOffline true will</span>
<a href="#l20.5781"></a><span id="l20.5781">     // cause us to fetch any message bodies we don't have.</span>
<a href="#l20.5782"></a><span id="l20.5782">     m_urlListener = listener;</span>
<a href="#l20.5783"></a><span id="l20.5783">     rv = imapService-&gt;SelectFolder(this, this, msgWindow,</span>
<a href="#l20.5784"></a><span id="l20.5784">                                    getter_AddRefs(runningURI));</span>
<a href="#l20.5785"></a><span id="l20.5785" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l20.5786"></a><span id="l20.5786" class="difflineminus">-    {</span>
<a href="#l20.5787"></a><span id="l20.5787" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.5788"></a><span id="l20.5788">       nsCOMPtr&lt;nsIImapUrl&gt; imapUrl(do_QueryInterface(runningURI));</span>
<a href="#l20.5789"></a><span id="l20.5789" class="difflineminus">-      if (imapUrl)</span>
<a href="#l20.5790"></a><span id="l20.5790" class="difflineminus">-        imapUrl-&gt;SetStoreResultsOffline(true);</span>
<a href="#l20.5791"></a><span id="l20.5791" class="difflineplus">+      if (imapUrl) imapUrl-&gt;SetStoreResultsOffline(true);</span>
<a href="#l20.5792"></a><span id="l20.5792">       m_urlRunning = true;</span>
<a href="#l20.5793"></a><span id="l20.5793">     }</span>
<a href="#l20.5794"></a><span id="l20.5794" class="difflineminus">-  }</span>
<a href="#l20.5795"></a><span id="l20.5795" class="difflineminus">-  else</span>
<a href="#l20.5796"></a><span id="l20.5796" class="difflineplus">+  } else</span>
<a href="#l20.5797"></a><span id="l20.5797">     rv = NS_MSG_FOLDER_UNREADABLE;</span>
<a href="#l20.5798"></a><span id="l20.5798">   return rv;</span>
<a href="#l20.5799"></a><span id="l20.5799"> }</span>
<a href="#l20.5800"></a><span id="l20.5800"> </span>
<a href="#l20.5801"></a><span id="l20.5801"> NS_IMETHODIMP</span>
<a href="#l20.5802"></a><span id="l20.5802"> nsImapMailFolder::ParseAdoptedMsgLine(const char *adoptedMessageLine,</span>
<a href="#l20.5803"></a><span id="l20.5803">                                       nsMsgKey uidOfMessage,</span>
<a href="#l20.5804"></a><span id="l20.5804" class="difflineminus">-                                      nsIImapUrl *aImapUrl)</span>
<a href="#l20.5805"></a><span id="l20.5805" class="difflineminus">-{</span>
<a href="#l20.5806"></a><span id="l20.5806" class="difflineplus">+                                      nsIImapUrl *aImapUrl) {</span>
<a href="#l20.5807"></a><span id="l20.5807">   NS_ENSURE_ARG_POINTER(aImapUrl);</span>
<a href="#l20.5808"></a><span id="l20.5808">   uint32_t count = 0;</span>
<a href="#l20.5809"></a><span id="l20.5809">   nsresult rv;</span>
<a href="#l20.5810"></a><span id="l20.5810">   // remember the uid of the message we're downloading.</span>
<a href="#l20.5811"></a><span id="l20.5811">   m_curMsgUid = uidOfMessage;</span>
<a href="#l20.5812"></a><span id="l20.5812" class="difflineminus">-  if (!m_offlineHeader)</span>
<a href="#l20.5813"></a><span id="l20.5813" class="difflineminus">-  {</span>
<a href="#l20.5814"></a><span id="l20.5814" class="difflineplus">+  if (!m_offlineHeader) {</span>
<a href="#l20.5815"></a><span id="l20.5815">     rv = GetMessageHeader(uidOfMessage, getter_AddRefs(m_offlineHeader));</span>
<a href="#l20.5816"></a><span id="l20.5816" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; !m_offlineHeader)</span>
<a href="#l20.5817"></a><span id="l20.5817" class="difflineminus">-      rv = NS_ERROR_UNEXPECTED;</span>
<a href="#l20.5818"></a><span id="l20.5818" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; !m_offlineHeader) rv = NS_ERROR_UNEXPECTED;</span>
<a href="#l20.5819"></a><span id="l20.5819">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.5820"></a><span id="l20.5820">     rv = StartNewOfflineMessage();</span>
<a href="#l20.5821"></a><span id="l20.5821">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.5822"></a><span id="l20.5822">   }</span>
<a href="#l20.5823"></a><span id="l20.5823" class="difflineminus">-  // adoptedMessageLine is actually a string with a lot of message lines, separated by native line terminators</span>
<a href="#l20.5824"></a><span id="l20.5824" class="difflineminus">-  // we need to count the number of MSG_LINEBREAK's to determine how much to increment m_numOfflineMsgLines by.</span>
<a href="#l20.5825"></a><span id="l20.5825" class="difflineplus">+  // adoptedMessageLine is actually a string with a lot of message lines,</span>
<a href="#l20.5826"></a><span id="l20.5826" class="difflineplus">+  // separated by native line terminators we need to count the number of</span>
<a href="#l20.5827"></a><span id="l20.5827" class="difflineplus">+  // MSG_LINEBREAK's to determine how much to increment m_numOfflineMsgLines by.</span>
<a href="#l20.5828"></a><span id="l20.5828">   const char *nextLine = adoptedMessageLine;</span>
<a href="#l20.5829"></a><span id="l20.5829" class="difflineminus">-  do</span>
<a href="#l20.5830"></a><span id="l20.5830" class="difflineminus">-  {</span>
<a href="#l20.5831"></a><span id="l20.5831" class="difflineplus">+  do {</span>
<a href="#l20.5832"></a><span id="l20.5832">     m_numOfflineMsgLines++;</span>
<a href="#l20.5833"></a><span id="l20.5833">     nextLine = PL_strstr(nextLine, MSG_LINEBREAK);</span>
<a href="#l20.5834"></a><span id="l20.5834" class="difflineminus">-    if (nextLine)</span>
<a href="#l20.5835"></a><span id="l20.5835" class="difflineminus">-      nextLine += MSG_LINEBREAK_LEN;</span>
<a href="#l20.5836"></a><span id="l20.5836" class="difflineminus">-  }</span>
<a href="#l20.5837"></a><span id="l20.5837" class="difflineminus">-  while (nextLine &amp;&amp; *nextLine);</span>
<a href="#l20.5838"></a><span id="l20.5838" class="difflineminus">-</span>
<a href="#l20.5839"></a><span id="l20.5839" class="difflineminus">-  if (m_tempMessageStream)</span>
<a href="#l20.5840"></a><span id="l20.5840" class="difflineminus">-  {</span>
<a href="#l20.5841"></a><span id="l20.5841" class="difflineminus">-    nsCOMPtr &lt;nsISeekableStream&gt; seekable (do_QueryInterface(m_tempMessageStream));</span>
<a href="#l20.5842"></a><span id="l20.5842" class="difflineminus">-    if (seekable)</span>
<a href="#l20.5843"></a><span id="l20.5843" class="difflineminus">-      seekable-&gt;Seek(PR_SEEK_END, 0);</span>
<a href="#l20.5844"></a><span id="l20.5844" class="difflineplus">+    if (nextLine) nextLine += MSG_LINEBREAK_LEN;</span>
<a href="#l20.5845"></a><span id="l20.5845" class="difflineplus">+  } while (nextLine &amp;&amp; *nextLine);</span>
<a href="#l20.5846"></a><span id="l20.5846" class="difflineplus">+</span>
<a href="#l20.5847"></a><span id="l20.5847" class="difflineplus">+  if (m_tempMessageStream) {</span>
<a href="#l20.5848"></a><span id="l20.5848" class="difflineplus">+    nsCOMPtr&lt;nsISeekableStream&gt; seekable(</span>
<a href="#l20.5849"></a><span id="l20.5849" class="difflineplus">+        do_QueryInterface(m_tempMessageStream));</span>
<a href="#l20.5850"></a><span id="l20.5850" class="difflineplus">+    if (seekable) seekable-&gt;Seek(PR_SEEK_END, 0);</span>
<a href="#l20.5851"></a><span id="l20.5851">     rv = m_tempMessageStream-&gt;Write(adoptedMessageLine,</span>
<a href="#l20.5852"></a><span id="l20.5852" class="difflineminus">-                PL_strlen(adoptedMessageLine), &amp;count);</span>
<a href="#l20.5853"></a><span id="l20.5853" class="difflineplus">+                                    PL_strlen(adoptedMessageLine), &amp;count);</span>
<a href="#l20.5854"></a><span id="l20.5854">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.5855"></a><span id="l20.5855">   }</span>
<a href="#l20.5856"></a><span id="l20.5856">   return NS_OK;</span>
<a href="#l20.5857"></a><span id="l20.5857"> }</span>
<a href="#l20.5858"></a><span id="l20.5858"> </span>
<a href="#l20.5859"></a><span id="l20.5859" class="difflineminus">-void nsImapMailFolder::EndOfflineDownload()</span>
<a href="#l20.5860"></a><span id="l20.5860" class="difflineminus">-{</span>
<a href="#l20.5861"></a><span id="l20.5861" class="difflineminus">-  if (m_tempMessageStream)</span>
<a href="#l20.5862"></a><span id="l20.5862" class="difflineminus">-  {</span>
<a href="#l20.5863"></a><span id="l20.5863" class="difflineplus">+void nsImapMailFolder::EndOfflineDownload() {</span>
<a href="#l20.5864"></a><span id="l20.5864" class="difflineplus">+  if (m_tempMessageStream) {</span>
<a href="#l20.5865"></a><span id="l20.5865">     m_tempMessageStream-&gt;Close();</span>
<a href="#l20.5866"></a><span id="l20.5866">     m_tempMessageStream = nullptr;</span>
<a href="#l20.5867"></a><span id="l20.5867" class="difflineminus">-    ReleaseSemaphore(static_cast&lt;nsIMsgFolder*&gt;(this));</span>
<a href="#l20.5868"></a><span id="l20.5868" class="difflineminus">-    if (mDatabase)</span>
<a href="#l20.5869"></a><span id="l20.5869" class="difflineminus">-      mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.5870"></a><span id="l20.5870" class="difflineplus">+    ReleaseSemaphore(static_cast&lt;nsIMsgFolder *&gt;(this));</span>
<a href="#l20.5871"></a><span id="l20.5871" class="difflineplus">+    if (mDatabase) mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.5872"></a><span id="l20.5872">   }</span>
<a href="#l20.5873"></a><span id="l20.5873">   m_offlineHeader = nullptr;</span>
<a href="#l20.5874"></a><span id="l20.5874"> }</span>
<a href="#l20.5875"></a><span id="l20.5875"> </span>
<a href="#l20.5876"></a><span id="l20.5876"> NS_IMETHODIMP</span>
<a href="#l20.5877"></a><span id="l20.5877" class="difflineminus">-nsImapMailFolder::NormalEndMsgWriteStream(nsMsgKey uidOfMessage,</span>
<a href="#l20.5878"></a><span id="l20.5878" class="difflineminus">-                                          bool markRead,</span>
<a href="#l20.5879"></a><span id="l20.5879" class="difflineplus">+nsImapMailFolder::NormalEndMsgWriteStream(nsMsgKey uidOfMessage, bool markRead,</span>
<a href="#l20.5880"></a><span id="l20.5880">                                           nsIImapUrl *imapUrl,</span>
<a href="#l20.5881"></a><span id="l20.5881" class="difflineminus">-                                          int32_t updatedMessageSize)</span>
<a href="#l20.5882"></a><span id="l20.5882" class="difflineminus">-{</span>
<a href="#l20.5883"></a><span id="l20.5883" class="difflineplus">+                                          int32_t updatedMessageSize) {</span>
<a href="#l20.5884"></a><span id="l20.5884">   if (updatedMessageSize != -1) {</span>
<a href="#l20.5885"></a><span id="l20.5885">     // retrieve the message header to update size, if we don't already have it</span>
<a href="#l20.5886"></a><span id="l20.5886">     nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHeader = m_offlineHeader;</span>
<a href="#l20.5887"></a><span id="l20.5887" class="difflineminus">-    if (!msgHeader)</span>
<a href="#l20.5888"></a><span id="l20.5888" class="difflineminus">-      GetMessageHeader(uidOfMessage, getter_AddRefs(msgHeader));</span>
<a href="#l20.5889"></a><span id="l20.5889" class="difflineplus">+    if (!msgHeader) GetMessageHeader(uidOfMessage, getter_AddRefs(msgHeader));</span>
<a href="#l20.5890"></a><span id="l20.5890">     if (msgHeader) {</span>
<a href="#l20.5891"></a><span id="l20.5891">       uint32_t msgSize;</span>
<a href="#l20.5892"></a><span id="l20.5892">       msgHeader-&gt;GetMessageSize(&amp;msgSize);</span>
<a href="#l20.5893"></a><span id="l20.5893" class="difflineminus">-      MOZ_LOG(IMAP, mozilla::LogLevel::Debug, (&quot;Updating stored message size from %u, new size %d&quot;,</span>
<a href="#l20.5894"></a><span id="l20.5894" class="difflineminus">-                                  msgSize, updatedMessageSize));</span>
<a href="#l20.5895"></a><span id="l20.5895" class="difflineplus">+      MOZ_LOG(IMAP, mozilla::LogLevel::Debug,</span>
<a href="#l20.5896"></a><span id="l20.5896" class="difflineplus">+              (&quot;Updating stored message size from %u, new size %d&quot;, msgSize,</span>
<a href="#l20.5897"></a><span id="l20.5897" class="difflineplus">+               updatedMessageSize));</span>
<a href="#l20.5898"></a><span id="l20.5898">       msgHeader-&gt;SetMessageSize(updatedMessageSize);</span>
<a href="#l20.5899"></a><span id="l20.5899">       // only commit here if this isn't an offline message</span>
<a href="#l20.5900"></a><span id="l20.5900">       // offline header gets committed in EndNewOfflineMessage() called below</span>
<a href="#l20.5901"></a><span id="l20.5901">       if (mDatabase &amp;&amp; !m_offlineHeader)</span>
<a href="#l20.5902"></a><span id="l20.5902">         mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.5903"></a><span id="l20.5903" class="difflineminus">-    }</span>
<a href="#l20.5904"></a><span id="l20.5904" class="difflineminus">-    else</span>
<a href="#l20.5905"></a><span id="l20.5905" class="difflineminus">-      NS_WARNING(&quot;Failed to get message header when trying to update message size&quot;);</span>
<a href="#l20.5906"></a><span id="l20.5906" class="difflineminus">-  }</span>
<a href="#l20.5907"></a><span id="l20.5907" class="difflineminus">-</span>
<a href="#l20.5908"></a><span id="l20.5908" class="difflineminus">-  if (m_offlineHeader)</span>
<a href="#l20.5909"></a><span id="l20.5909" class="difflineminus">-    EndNewOfflineMessage();</span>
<a href="#l20.5910"></a><span id="l20.5910" class="difflineplus">+    } else</span>
<a href="#l20.5911"></a><span id="l20.5911" class="difflineplus">+      NS_WARNING(</span>
<a href="#l20.5912"></a><span id="l20.5912" class="difflineplus">+          &quot;Failed to get message header when trying to update message size&quot;);</span>
<a href="#l20.5913"></a><span id="l20.5913" class="difflineplus">+  }</span>
<a href="#l20.5914"></a><span id="l20.5914" class="difflineplus">+</span>
<a href="#l20.5915"></a><span id="l20.5915" class="difflineplus">+  if (m_offlineHeader) EndNewOfflineMessage();</span>
<a href="#l20.5916"></a><span id="l20.5916"> </span>
<a href="#l20.5917"></a><span id="l20.5917">   m_curMsgUid = uidOfMessage;</span>
<a href="#l20.5918"></a><span id="l20.5918"> </span>
<a href="#l20.5919"></a><span id="l20.5919">   // Apply filter now if it needed a body</span>
<a href="#l20.5920"></a><span id="l20.5920" class="difflineminus">-  if (m_filterListRequiresBody)</span>
<a href="#l20.5921"></a><span id="l20.5921" class="difflineminus">-  {</span>
<a href="#l20.5922"></a><span id="l20.5922" class="difflineminus">-    if (m_filterList)</span>
<a href="#l20.5923"></a><span id="l20.5923" class="difflineminus">-    {</span>
<a href="#l20.5924"></a><span id="l20.5924" class="difflineplus">+  if (m_filterListRequiresBody) {</span>
<a href="#l20.5925"></a><span id="l20.5925" class="difflineplus">+    if (m_filterList) {</span>
<a href="#l20.5926"></a><span id="l20.5926">       nsCOMPtr&lt;nsIMsgDBHdr&gt; newMsgHdr;</span>
<a href="#l20.5927"></a><span id="l20.5927">       GetMessageHeader(uidOfMessage, getter_AddRefs(newMsgHdr));</span>
<a href="#l20.5928"></a><span id="l20.5928">       GetMoveCoalescer();</span>
<a href="#l20.5929"></a><span id="l20.5929">       nsCOMPtr&lt;nsIMsgWindow&gt; msgWindow;</span>
<a href="#l20.5930"></a><span id="l20.5930" class="difflineminus">-      if (imapUrl)</span>
<a href="#l20.5931"></a><span id="l20.5931" class="difflineminus">-      {</span>
<a href="#l20.5932"></a><span id="l20.5932" class="difflineplus">+      if (imapUrl) {</span>
<a href="#l20.5933"></a><span id="l20.5933">         nsresult rv;</span>
<a href="#l20.5934"></a><span id="l20.5934">         nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; msgUrl;</span>
<a href="#l20.5935"></a><span id="l20.5935">         msgUrl = do_QueryInterface(imapUrl, &amp;rv);</span>
<a href="#l20.5936"></a><span id="l20.5936">         if (msgUrl &amp;&amp; NS_SUCCEEDED(rv))</span>
<a href="#l20.5937"></a><span id="l20.5937">           msgUrl-&gt;GetMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l20.5938"></a><span id="l20.5938">       }</span>
<a href="#l20.5939"></a><span id="l20.5939">       m_filterList-&gt;ApplyFiltersToHdr(nsMsgFilterType::InboxRule, newMsgHdr,</span>
<a href="#l20.5940"></a><span id="l20.5940">                                       this, mDatabase, EmptyCString(), this,</span>
<a href="#l20.5941"></a><span id="l20.5941" class="difflineat">@@ -4650,222 +4296,195 @@ nsImapMailFolder::NormalEndMsgWriteStrea</span>
<a href="#l20.5942"></a><span id="l20.5942">     // Process filter plugins and other items normally done at the end of</span>
<a href="#l20.5943"></a><span id="l20.5943">     // HeaderFetchCompleted.</span>
<a href="#l20.5944"></a><span id="l20.5944">     bool pendingMoves = m_moveCoalescer &amp;&amp; m_moveCoalescer-&gt;HasPendingMoves();</span>
<a href="#l20.5945"></a><span id="l20.5945">     PlaybackCoalescedOperations();</span>
<a href="#l20.5946"></a><span id="l20.5946"> </span>
<a href="#l20.5947"></a><span id="l20.5947">     bool filtersRun;</span>
<a href="#l20.5948"></a><span id="l20.5948">     CallFilterPlugins(nullptr, &amp;filtersRun);</span>
<a href="#l20.5949"></a><span id="l20.5949">     int32_t numNewBiffMsgs = 0;</span>
<a href="#l20.5950"></a><span id="l20.5950" class="difflineminus">-    if (m_performingBiff)</span>
<a href="#l20.5951"></a><span id="l20.5951" class="difflineminus">-      GetNumNewMessages(false, &amp;numNewBiffMsgs);</span>
<a href="#l20.5952"></a><span id="l20.5952" class="difflineplus">+    if (m_performingBiff) GetNumNewMessages(false, &amp;numNewBiffMsgs);</span>
<a href="#l20.5953"></a><span id="l20.5953"> </span>
<a href="#l20.5954"></a><span id="l20.5954">     if (!filtersRun &amp;&amp; m_performingBiff &amp;&amp; mDatabase &amp;&amp; numNewBiffMsgs &gt; 0 &amp;&amp;</span>
<a href="#l20.5955"></a><span id="l20.5955" class="difflineminus">-        (!pendingMoves || !ShowPreviewText()))</span>
<a href="#l20.5956"></a><span id="l20.5956" class="difflineminus">-    {</span>
<a href="#l20.5957"></a><span id="l20.5957" class="difflineplus">+        (!pendingMoves || !ShowPreviewText())) {</span>
<a href="#l20.5958"></a><span id="l20.5958">       // If we are performing biff for this folder, tell the</span>
<a href="#l20.5959"></a><span id="l20.5959">       // stand-alone biff about the new high water mark</span>
<a href="#l20.5960"></a><span id="l20.5960">       // We must ensure that the server knows that we are performing biff.</span>
<a href="#l20.5961"></a><span id="l20.5961">       // Otherwise the stand-alone biff won't fire.</span>
<a href="#l20.5962"></a><span id="l20.5962">       nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.5963"></a><span id="l20.5963">       if (NS_SUCCEEDED(GetServer(getter_AddRefs(server))) &amp;&amp; server)</span>
<a href="#l20.5964"></a><span id="l20.5964">         server-&gt;SetPerformingBiff(true);</span>
<a href="#l20.5965"></a><span id="l20.5965"> </span>
<a href="#l20.5966"></a><span id="l20.5966">       SetBiffState(nsIMsgFolder::nsMsgBiffState_NewMail);</span>
<a href="#l20.5967"></a><span id="l20.5967" class="difflineminus">-      if (server)</span>
<a href="#l20.5968"></a><span id="l20.5968" class="difflineminus">-        server-&gt;SetPerformingBiff(false);</span>
<a href="#l20.5969"></a><span id="l20.5969" class="difflineplus">+      if (server) server-&gt;SetPerformingBiff(false);</span>
<a href="#l20.5970"></a><span id="l20.5970">       m_performingBiff = false;</span>
<a href="#l20.5971"></a><span id="l20.5971">     }</span>
<a href="#l20.5972"></a><span id="l20.5972"> </span>
<a href="#l20.5973"></a><span id="l20.5973" class="difflineminus">-    if (m_filterList)</span>
<a href="#l20.5974"></a><span id="l20.5974" class="difflineminus">-      (void)m_filterList-&gt;FlushLogIfNecessary();</span>
<a href="#l20.5975"></a><span id="l20.5975" class="difflineplus">+    if (m_filterList) (void)m_filterList-&gt;FlushLogIfNecessary();</span>
<a href="#l20.5976"></a><span id="l20.5976">   }</span>
<a href="#l20.5977"></a><span id="l20.5977"> </span>
<a href="#l20.5978"></a><span id="l20.5978">   return NS_OK;</span>
<a href="#l20.5979"></a><span id="l20.5979"> }</span>
<a href="#l20.5980"></a><span id="l20.5980"> </span>
<a href="#l20.5981"></a><span id="l20.5981"> NS_IMETHODIMP</span>
<a href="#l20.5982"></a><span id="l20.5982" class="difflineminus">-nsImapMailFolder::AbortMsgWriteStream()</span>
<a href="#l20.5983"></a><span id="l20.5983" class="difflineminus">-{</span>
<a href="#l20.5984"></a><span id="l20.5984" class="difflineplus">+nsImapMailFolder::AbortMsgWriteStream() {</span>
<a href="#l20.5985"></a><span id="l20.5985">   m_offlineHeader = nullptr;</span>
<a href="#l20.5986"></a><span id="l20.5986">   return NS_ERROR_FAILURE;</span>
<a href="#l20.5987"></a><span id="l20.5987"> }</span>
<a href="#l20.5988"></a><span id="l20.5988"> </span>
<a href="#l20.5989"></a><span id="l20.5989" class="difflineminus">-    // message move/copy related methods</span>
<a href="#l20.5990"></a><span id="l20.5990" class="difflineplus">+// message move/copy related methods</span>
<a href="#l20.5991"></a><span id="l20.5991"> NS_IMETHODIMP</span>
<a href="#l20.5992"></a><span id="l20.5992" class="difflineminus">-nsImapMailFolder::OnlineCopyCompleted(nsIImapProtocol *aProtocol, ImapOnlineCopyState aCopyState)</span>
<a href="#l20.5993"></a><span id="l20.5993" class="difflineminus">-{</span>
<a href="#l20.5994"></a><span id="l20.5994" class="difflineplus">+nsImapMailFolder::OnlineCopyCompleted(nsIImapProtocol *aProtocol,</span>
<a href="#l20.5995"></a><span id="l20.5995" class="difflineplus">+                                      ImapOnlineCopyState aCopyState) {</span>
<a href="#l20.5996"></a><span id="l20.5996">   NS_ENSURE_ARG_POINTER(aProtocol);</span>
<a href="#l20.5997"></a><span id="l20.5997"> </span>
<a href="#l20.5998"></a><span id="l20.5998">   nsresult rv;</span>
<a href="#l20.5999"></a><span id="l20.5999" class="difflineminus">-  if (aCopyState == ImapOnlineCopyStateType::kSuccessfulCopy)</span>
<a href="#l20.6000"></a><span id="l20.6000" class="difflineminus">-  {</span>
<a href="#l20.6001"></a><span id="l20.6001" class="difflineminus">-    nsCOMPtr &lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l20.6002"></a><span id="l20.6002" class="difflineplus">+  if (aCopyState == ImapOnlineCopyStateType::kSuccessfulCopy) {</span>
<a href="#l20.6003"></a><span id="l20.6003" class="difflineplus">+    nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l20.6004"></a><span id="l20.6004">     rv = aProtocol-&gt;GetRunningImapURL(getter_AddRefs(imapUrl));</span>
<a href="#l20.6005"></a><span id="l20.6005">     if (NS_FAILED(rv) || !imapUrl) return NS_ERROR_FAILURE;</span>
<a href="#l20.6006"></a><span id="l20.6006">     nsImapAction action;</span>
<a href="#l20.6007"></a><span id="l20.6007">     rv = imapUrl-&gt;GetImapAction(&amp;action);</span>
<a href="#l20.6008"></a><span id="l20.6008">     if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.6009"></a><span id="l20.6009">     if (action != nsIImapUrl::nsImapOnlineToOfflineMove)</span>
<a href="#l20.6010"></a><span id="l20.6010" class="difflineminus">-      return NS_ERROR_FAILURE; // don't assert here...</span>
<a href="#l20.6011"></a><span id="l20.6011" class="difflineplus">+      return NS_ERROR_FAILURE;  // don't assert here...</span>
<a href="#l20.6012"></a><span id="l20.6012">     nsCString messageIds;</span>
<a href="#l20.6013"></a><span id="l20.6013">     rv = imapUrl-&gt;GetListOfMessageIds(messageIds);</span>
<a href="#l20.6014"></a><span id="l20.6014">     if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.6015"></a><span id="l20.6015" class="difflineminus">-    nsCOMPtr&lt;nsIImapService&gt; imapService =  do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.6016"></a><span id="l20.6016" class="difflineminus">-    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.6017"></a><span id="l20.6017" class="difflineminus">-    return imapService-&gt;AddMessageFlags(this, nullptr, nullptr,</span>
<a href="#l20.6018"></a><span id="l20.6018" class="difflineminus">-                                      messageIds,</span>
<a href="#l20.6019"></a><span id="l20.6019" class="difflineminus">-                                      kImapMsgDeletedFlag,</span>
<a href="#l20.6020"></a><span id="l20.6020" class="difflineminus">-                                      true);</span>
<a href="#l20.6021"></a><span id="l20.6021" class="difflineplus">+    nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.6022"></a><span id="l20.6022" class="difflineplus">+        do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.6023"></a><span id="l20.6023" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.6024"></a><span id="l20.6024" class="difflineplus">+    return imapService-&gt;AddMessageFlags(this, nullptr, nullptr, messageIds,</span>
<a href="#l20.6025"></a><span id="l20.6025" class="difflineplus">+                                        kImapMsgDeletedFlag, true);</span>
<a href="#l20.6026"></a><span id="l20.6026">   }</span>
<a href="#l20.6027"></a><span id="l20.6027">   /* unhandled copystate */</span>
<a href="#l20.6028"></a><span id="l20.6028" class="difflineminus">-  if (m_copyState) // whoops, this is the wrong folder - should use the source folder</span>
<a href="#l20.6029"></a><span id="l20.6029" class="difflineplus">+  if (m_copyState)  // whoops, this is the wrong folder - should use the source</span>
<a href="#l20.6030"></a><span id="l20.6030" class="difflineplus">+                    // folder</span>
<a href="#l20.6031"></a><span id="l20.6031">   {</span>
<a href="#l20.6032"></a><span id="l20.6032">     nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder;</span>
<a href="#l20.6033"></a><span id="l20.6033">     srcFolder = do_QueryInterface(m_copyState-&gt;m_srcSupport, &amp;rv);</span>
<a href="#l20.6034"></a><span id="l20.6034" class="difflineminus">-    if (srcFolder)</span>
<a href="#l20.6035"></a><span id="l20.6035" class="difflineminus">-      srcFolder-&gt;NotifyFolderEvent(kDeleteOrMoveMsgCompleted);</span>
<a href="#l20.6036"></a><span id="l20.6036" class="difflineminus">-  }</span>
<a href="#l20.6037"></a><span id="l20.6037" class="difflineminus">-  else</span>
<a href="#l20.6038"></a><span id="l20.6038" class="difflineplus">+    if (srcFolder) srcFolder-&gt;NotifyFolderEvent(kDeleteOrMoveMsgCompleted);</span>
<a href="#l20.6039"></a><span id="l20.6039" class="difflineplus">+  } else</span>
<a href="#l20.6040"></a><span id="l20.6040">     rv = NS_ERROR_FAILURE;</span>
<a href="#l20.6041"></a><span id="l20.6041"> </span>
<a href="#l20.6042"></a><span id="l20.6042">   return rv;</span>
<a href="#l20.6043"></a><span id="l20.6043"> }</span>
<a href="#l20.6044"></a><span id="l20.6044"> </span>
<a href="#l20.6045"></a><span id="l20.6045"> NS_IMETHODIMP</span>
<a href="#l20.6046"></a><span id="l20.6046" class="difflineminus">-nsImapMailFolder::CloseMockChannel(nsIImapMockChannel * aChannel)</span>
<a href="#l20.6047"></a><span id="l20.6047" class="difflineminus">-{</span>
<a href="#l20.6048"></a><span id="l20.6048" class="difflineplus">+nsImapMailFolder::CloseMockChannel(nsIImapMockChannel *aChannel) {</span>
<a href="#l20.6049"></a><span id="l20.6049">   aChannel-&gt;Close();</span>
<a href="#l20.6050"></a><span id="l20.6050">   return NS_OK;</span>
<a href="#l20.6051"></a><span id="l20.6051"> }</span>
<a href="#l20.6052"></a><span id="l20.6052"> </span>
<a href="#l20.6053"></a><span id="l20.6053"> NS_IMETHODIMP</span>
<a href="#l20.6054"></a><span id="l20.6054" class="difflineminus">-nsImapMailFolder::ReleaseUrlCacheEntry(nsIMsgMailNewsUrl *aUrl)</span>
<a href="#l20.6055"></a><span id="l20.6055" class="difflineminus">-{</span>
<a href="#l20.6056"></a><span id="l20.6056" class="difflineplus">+nsImapMailFolder::ReleaseUrlCacheEntry(nsIMsgMailNewsUrl *aUrl) {</span>
<a href="#l20.6057"></a><span id="l20.6057">   NS_ENSURE_ARG_POINTER(aUrl);</span>
<a href="#l20.6058"></a><span id="l20.6058">   return aUrl-&gt;SetMemCacheEntry(nullptr);</span>
<a href="#l20.6059"></a><span id="l20.6059"> }</span>
<a href="#l20.6060"></a><span id="l20.6060"> </span>
<a href="#l20.6061"></a><span id="l20.6061"> NS_IMETHODIMP</span>
<a href="#l20.6062"></a><span id="l20.6062" class="difflineminus">-nsImapMailFolder::BeginMessageUpload()</span>
<a href="#l20.6063"></a><span id="l20.6063" class="difflineminus">-{</span>
<a href="#l20.6064"></a><span id="l20.6064" class="difflineminus">-  return NS_ERROR_FAILURE;</span>
<a href="#l20.6065"></a><span id="l20.6065" class="difflineminus">-}</span>
<a href="#l20.6066"></a><span id="l20.6066" class="difflineminus">-</span>
<a href="#l20.6067"></a><span id="l20.6067" class="difflineminus">-nsresult nsImapMailFolder::HandleCustomFlags(nsMsgKey uidOfMessage,</span>
<a href="#l20.6068"></a><span id="l20.6068" class="difflineminus">-                                             nsIMsgDBHdr *dbHdr,</span>
<a href="#l20.6069"></a><span id="l20.6069" class="difflineminus">-                                             uint16_t userFlags,</span>
<a href="#l20.6070"></a><span id="l20.6070" class="difflineminus">-                                             nsCString &amp;keywords,</span>
<a href="#l20.6071"></a><span id="l20.6071" class="difflineminus">-                                             nsIImapFlagAndUidState *flagState)</span>
<a href="#l20.6072"></a><span id="l20.6072" class="difflineminus">-{</span>
<a href="#l20.6073"></a><span id="l20.6073" class="difflineplus">+nsImapMailFolder::BeginMessageUpload() { return NS_ERROR_FAILURE; }</span>
<a href="#l20.6074"></a><span id="l20.6074" class="difflineplus">+</span>
<a href="#l20.6075"></a><span id="l20.6075" class="difflineplus">+nsresult nsImapMailFolder::HandleCustomFlags(</span>
<a href="#l20.6076"></a><span id="l20.6076" class="difflineplus">+    nsMsgKey uidOfMessage, nsIMsgDBHdr *dbHdr, uint16_t userFlags,</span>
<a href="#l20.6077"></a><span id="l20.6077" class="difflineplus">+    nsCString &amp;keywords, nsIImapFlagAndUidState *flagState) {</span>
<a href="#l20.6078"></a><span id="l20.6078">   nsresult rv = GetDatabase();</span>
<a href="#l20.6079"></a><span id="l20.6079">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.6080"></a><span id="l20.6080"> </span>
<a href="#l20.6081"></a><span id="l20.6081">   ToLowerCase(keywords);</span>
<a href="#l20.6082"></a><span id="l20.6082">   bool messageClassified = true;</span>
<a href="#l20.6083"></a><span id="l20.6083">   // Mac Mail uses &quot;NotJunk&quot;</span>
<a href="#l20.6084"></a><span id="l20.6084">   if (keywords.Find(&quot;NonJunk&quot;, /* ignoreCase = */ true) != kNotFound ||</span>
<a href="#l20.6085"></a><span id="l20.6085" class="difflineminus">-      keywords.Find(&quot;NotJunk&quot;, /* ignoreCase = */ true) != kNotFound)</span>
<a href="#l20.6086"></a><span id="l20.6086" class="difflineminus">-  {</span>
<a href="#l20.6087"></a><span id="l20.6087" class="difflineplus">+      keywords.Find(&quot;NotJunk&quot;, /* ignoreCase = */ true) != kNotFound) {</span>
<a href="#l20.6088"></a><span id="l20.6088">     nsAutoCString msgJunkScore;</span>
<a href="#l20.6089"></a><span id="l20.6089">     msgJunkScore.AppendInt(nsIJunkMailPlugin::IS_HAM_SCORE);</span>
<a href="#l20.6090"></a><span id="l20.6090">     mDatabase-&gt;SetStringProperty(uidOfMessage, &quot;junkscore&quot;, msgJunkScore.get());</span>
<a href="#l20.6091"></a><span id="l20.6091">   }</span>
<a href="#l20.6092"></a><span id="l20.6092" class="difflineminus">-  // ### TODO: we really should parse the keywords into space delimited keywords before checking</span>
<a href="#l20.6093"></a><span id="l20.6093" class="difflineminus">-  else if (keywords.Find(&quot;Junk&quot;, /* ignoreCase = */ true) != kNotFound)</span>
<a href="#l20.6094"></a><span id="l20.6094" class="difflineminus">-  {</span>
<a href="#l20.6095"></a><span id="l20.6095" class="difflineplus">+  // ### TODO: we really should parse the keywords into space delimited keywords</span>
<a href="#l20.6096"></a><span id="l20.6096" class="difflineplus">+  // before checking</span>
<a href="#l20.6097"></a><span id="l20.6097" class="difflineplus">+  else if (keywords.Find(&quot;Junk&quot;, /* ignoreCase = */ true) != kNotFound) {</span>
<a href="#l20.6098"></a><span id="l20.6098">     uint32_t newFlags;</span>
<a href="#l20.6099"></a><span id="l20.6099">     dbHdr-&gt;AndFlags(~nsMsgMessageFlags::New, &amp;newFlags);</span>
<a href="#l20.6100"></a><span id="l20.6100">     nsAutoCString msgJunkScore;</span>
<a href="#l20.6101"></a><span id="l20.6101">     msgJunkScore.AppendInt(nsIJunkMailPlugin::IS_SPAM_SCORE);</span>
<a href="#l20.6102"></a><span id="l20.6102">     mDatabase-&gt;SetStringProperty(uidOfMessage, &quot;junkscore&quot;, msgJunkScore.get());</span>
<a href="#l20.6103"></a><span id="l20.6103" class="difflineminus">-  }</span>
<a href="#l20.6104"></a><span id="l20.6104" class="difflineminus">-  else</span>
<a href="#l20.6105"></a><span id="l20.6105" class="difflineplus">+  } else</span>
<a href="#l20.6106"></a><span id="l20.6106">     messageClassified = false;</span>
<a href="#l20.6107"></a><span id="l20.6107" class="difflineminus">-  if (messageClassified)</span>
<a href="#l20.6108"></a><span id="l20.6108" class="difflineminus">-  {</span>
<a href="#l20.6109"></a><span id="l20.6109" class="difflineplus">+  if (messageClassified) {</span>
<a href="#l20.6110"></a><span id="l20.6110">     // only set the junkscore origin if it wasn't set before.</span>
<a href="#l20.6111"></a><span id="l20.6111">     nsCString existingProperty;</span>
<a href="#l20.6112"></a><span id="l20.6112" class="difflineminus">-    dbHdr-&gt;GetStringProperty(&quot;junkscoreorigin&quot;, getter_Copies(existingProperty));</span>
<a href="#l20.6113"></a><span id="l20.6113" class="difflineplus">+    dbHdr-&gt;GetStringProperty(&quot;junkscoreorigin&quot;,</span>
<a href="#l20.6114"></a><span id="l20.6114" class="difflineplus">+                             getter_Copies(existingProperty));</span>
<a href="#l20.6115"></a><span id="l20.6115">     if (existingProperty.IsEmpty())</span>
<a href="#l20.6116"></a><span id="l20.6116">       dbHdr-&gt;SetStringProperty(&quot;junkscoreorigin&quot;, &quot;imapflag&quot;);</span>
<a href="#l20.6117"></a><span id="l20.6117">   }</span>
<a href="#l20.6118"></a><span id="l20.6118"> </span>
<a href="#l20.6119"></a><span id="l20.6119" class="difflineminus">-  if (flagState &amp;&amp; !(userFlags &amp; kImapMsgSupportUserFlag))</span>
<a href="#l20.6120"></a><span id="l20.6120" class="difflineminus">-  {</span>
<a href="#l20.6121"></a><span id="l20.6121" class="difflineplus">+  if (flagState &amp;&amp; !(userFlags &amp; kImapMsgSupportUserFlag)) {</span>
<a href="#l20.6122"></a><span id="l20.6122">     nsCString localKeywords;</span>
<a href="#l20.6123"></a><span id="l20.6123" class="difflineminus">-    if (!(userFlags &amp; kImapMsgSupportUserFlag))</span>
<a href="#l20.6124"></a><span id="l20.6124" class="difflineminus">-    {</span>
<a href="#l20.6125"></a><span id="l20.6125" class="difflineplus">+    if (!(userFlags &amp; kImapMsgSupportUserFlag)) {</span>
<a href="#l20.6126"></a><span id="l20.6126">       dbHdr-&gt;GetStringProperty(&quot;keywords&quot;, getter_Copies(localKeywords));</span>
<a href="#l20.6127"></a><span id="l20.6127" class="difflineminus">-      MOZ_LOG(IMAP_KW, mozilla::LogLevel::Debug, (&quot;UID=%&quot; PRIu32 &quot;, localKeywords=|%s| rcvdKeyword=|%s|&quot;,</span>
<a href="#l20.6128"></a><span id="l20.6128" class="difflineminus">-              uidOfMessage, localKeywords.get(), keywords.get()));</span>
<a href="#l20.6129"></a><span id="l20.6129" class="difflineplus">+      MOZ_LOG(IMAP_KW, mozilla::LogLevel::Debug,</span>
<a href="#l20.6130"></a><span id="l20.6130" class="difflineplus">+              (&quot;UID=%&quot; PRIu32 &quot;, localKeywords=|%s| rcvdKeyword=|%s|&quot;,</span>
<a href="#l20.6131"></a><span id="l20.6131" class="difflineplus">+               uidOfMessage, localKeywords.get(), keywords.get()));</span>
<a href="#l20.6132"></a><span id="l20.6132">     }</span>
<a href="#l20.6133"></a><span id="l20.6133">     nsTArray&lt;nsCString&gt; localKeywordArray;</span>
<a href="#l20.6134"></a><span id="l20.6134">     nsTArray&lt;nsCString&gt; rcvdKeywordArray;</span>
<a href="#l20.6135"></a><span id="l20.6135">     ParseString(localKeywords, ' ', localKeywordArray);</span>
<a href="#l20.6136"></a><span id="l20.6136">     ParseString(keywords, ' ', rcvdKeywordArray);</span>
<a href="#l20.6137"></a><span id="l20.6137"> </span>
<a href="#l20.6138"></a><span id="l20.6138">     nsAutoCString mozLogDefinedKWs;</span>
<a href="#l20.6139"></a><span id="l20.6139">     if (MOZ_LOG_TEST(IMAP_KW, mozilla::LogLevel::Debug))</span>
<a href="#l20.6140"></a><span id="l20.6140">       mozLogDefinedKWs.AppendLiteral(&quot;Defined keywords = |&quot;);</span>
<a href="#l20.6141"></a><span id="l20.6141">     uint32_t i = 0;</span>
<a href="#l20.6142"></a><span id="l20.6142" class="difflineminus">-    while (true)</span>
<a href="#l20.6143"></a><span id="l20.6143" class="difflineminus">-    {</span>
<a href="#l20.6144"></a><span id="l20.6144" class="difflineplus">+    while (true) {</span>
<a href="#l20.6145"></a><span id="l20.6145">       nsAutoCString definedKeyword;</span>
<a href="#l20.6146"></a><span id="l20.6146">       flagState-&gt;GetOtherKeywords(i++, definedKeyword);</span>
<a href="#l20.6147"></a><span id="l20.6147" class="difflineminus">-      if (definedKeyword.IsEmpty())</span>
<a href="#l20.6148"></a><span id="l20.6148" class="difflineminus">-      {</span>
<a href="#l20.6149"></a><span id="l20.6149" class="difflineminus">-        if (MOZ_LOG_TEST(IMAP_KW, mozilla::LogLevel::Debug))</span>
<a href="#l20.6150"></a><span id="l20.6150" class="difflineminus">-        {</span>
<a href="#l20.6151"></a><span id="l20.6151" class="difflineplus">+      if (definedKeyword.IsEmpty()) {</span>
<a href="#l20.6152"></a><span id="l20.6152" class="difflineplus">+        if (MOZ_LOG_TEST(IMAP_KW, mozilla::LogLevel::Debug)) {</span>
<a href="#l20.6153"></a><span id="l20.6153">           mozLogDefinedKWs.Append('|');</span>
<a href="#l20.6154"></a><span id="l20.6154" class="difflineminus">-          MOZ_LOG(IMAP_KW, mozilla::LogLevel::Debug, (&quot;%s&quot;, mozLogDefinedKWs.get()));</span>
<a href="#l20.6155"></a><span id="l20.6155" class="difflineplus">+          MOZ_LOG(IMAP_KW, mozilla::LogLevel::Debug,</span>
<a href="#l20.6156"></a><span id="l20.6156" class="difflineplus">+                  (&quot;%s&quot;, mozLogDefinedKWs.get()));</span>
<a href="#l20.6157"></a><span id="l20.6157">         }</span>
<a href="#l20.6158"></a><span id="l20.6158">         break;</span>
<a href="#l20.6159"></a><span id="l20.6159">       }</span>
<a href="#l20.6160"></a><span id="l20.6160"> </span>
<a href="#l20.6161"></a><span id="l20.6161" class="difflineminus">-      if (MOZ_LOG_TEST(IMAP_KW, mozilla::LogLevel::Debug))</span>
<a href="#l20.6162"></a><span id="l20.6162" class="difflineminus">-      {</span>
<a href="#l20.6163"></a><span id="l20.6163" class="difflineplus">+      if (MOZ_LOG_TEST(IMAP_KW, mozilla::LogLevel::Debug)) {</span>
<a href="#l20.6164"></a><span id="l20.6164">         mozLogDefinedKWs.Append(definedKeyword.get());</span>
<a href="#l20.6165"></a><span id="l20.6165">         mozLogDefinedKWs.Append(' ');</span>
<a href="#l20.6166"></a><span id="l20.6166">       }</span>
<a href="#l20.6167"></a><span id="l20.6167"> </span>
<a href="#l20.6168"></a><span id="l20.6168">       bool inLocal = localKeywordArray.Contains(definedKeyword);</span>
<a href="#l20.6169"></a><span id="l20.6169">       bool inRcvd = rcvdKeywordArray.Contains(definedKeyword);</span>
<a href="#l20.6170"></a><span id="l20.6170" class="difflineminus">-      if (inLocal &amp;&amp; inRcvd)</span>
<a href="#l20.6171"></a><span id="l20.6171" class="difflineminus">-        rcvdKeywordArray.RemoveElement(definedKeyword);</span>
<a href="#l20.6172"></a><span id="l20.6172" class="difflineminus">-      if (inLocal &amp;&amp; !inRcvd)</span>
<a href="#l20.6173"></a><span id="l20.6173" class="difflineminus">-        localKeywordArray.RemoveElement(definedKeyword);</span>
<a href="#l20.6174"></a><span id="l20.6174" class="difflineplus">+      if (inLocal &amp;&amp; inRcvd) rcvdKeywordArray.RemoveElement(definedKeyword);</span>
<a href="#l20.6175"></a><span id="l20.6175" class="difflineplus">+      if (inLocal &amp;&amp; !inRcvd) localKeywordArray.RemoveElement(definedKeyword);</span>
<a href="#l20.6176"></a><span id="l20.6176">     }</span>
<a href="#l20.6177"></a><span id="l20.6177">     // Combine local and rcvd keyword arrays into a single string</span>
<a href="#l20.6178"></a><span id="l20.6178">     // so it can be passed to SetStringProperty(). If element of</span>
<a href="#l20.6179"></a><span id="l20.6179">     // local already in rcvd, avoid duplicates in combined string.</span>
<a href="#l20.6180"></a><span id="l20.6180">     nsAutoCString combinedKeywords;</span>
<a href="#l20.6181"></a><span id="l20.6181" class="difflineminus">-    for (i = 0; i &lt; localKeywordArray.Length(); i++)</span>
<a href="#l20.6182"></a><span id="l20.6182" class="difflineminus">-    {</span>
<a href="#l20.6183"></a><span id="l20.6183" class="difflineminus">-      if (!rcvdKeywordArray.Contains(localKeywordArray[i]))</span>
<a href="#l20.6184"></a><span id="l20.6184" class="difflineminus">-      {</span>
<a href="#l20.6185"></a><span id="l20.6185" class="difflineplus">+    for (i = 0; i &lt; localKeywordArray.Length(); i++) {</span>
<a href="#l20.6186"></a><span id="l20.6186" class="difflineplus">+      if (!rcvdKeywordArray.Contains(localKeywordArray[i])) {</span>
<a href="#l20.6187"></a><span id="l20.6187">         combinedKeywords.Append(localKeywordArray[i]);</span>
<a href="#l20.6188"></a><span id="l20.6188">         combinedKeywords.Append(' ');</span>
<a href="#l20.6189"></a><span id="l20.6189">       }</span>
<a href="#l20.6190"></a><span id="l20.6190">     }</span>
<a href="#l20.6191"></a><span id="l20.6191" class="difflineminus">-    for (i = 0; i &lt; rcvdKeywordArray.Length(); i++)</span>
<a href="#l20.6192"></a><span id="l20.6192" class="difflineminus">-    {</span>
<a href="#l20.6193"></a><span id="l20.6193" class="difflineplus">+    for (i = 0; i &lt; rcvdKeywordArray.Length(); i++) {</span>
<a href="#l20.6194"></a><span id="l20.6194">       combinedKeywords.Append(rcvdKeywordArray[i]);</span>
<a href="#l20.6195"></a><span id="l20.6195">       combinedKeywords.Append(' ');</span>
<a href="#l20.6196"></a><span id="l20.6196">     }</span>
<a href="#l20.6197"></a><span id="l20.6197">     return dbHdr-&gt;SetStringProperty(&quot;keywords&quot;, combinedKeywords.get());</span>
<a href="#l20.6198"></a><span id="l20.6198">   }</span>
<a href="#l20.6199"></a><span id="l20.6199" class="difflineminus">-  return (userFlags &amp; kImapMsgSupportUserFlag) ?</span>
<a href="#l20.6200"></a><span id="l20.6200" class="difflineminus">-          dbHdr-&gt;SetStringProperty(&quot;keywords&quot;, keywords.get()) : NS_OK;</span>
<a href="#l20.6201"></a><span id="l20.6201" class="difflineplus">+  return (userFlags &amp; kImapMsgSupportUserFlag)</span>
<a href="#l20.6202"></a><span id="l20.6202" class="difflineplus">+             ? dbHdr-&gt;SetStringProperty(&quot;keywords&quot;, keywords.get())</span>
<a href="#l20.6203"></a><span id="l20.6203" class="difflineplus">+             : NS_OK;</span>
<a href="#l20.6204"></a><span id="l20.6204"> }</span>
<a href="#l20.6205"></a><span id="l20.6205"> </span>
<a href="#l20.6206"></a><span id="l20.6206"> // synchronize the message flags in the database with the server flags</span>
<a href="#l20.6207"></a><span id="l20.6207" class="difflineminus">-nsresult nsImapMailFolder::SyncFlags(nsIImapFlagAndUidState *flagState)</span>
<a href="#l20.6208"></a><span id="l20.6208" class="difflineminus">-{</span>
<a href="#l20.6209"></a><span id="l20.6209" class="difflineminus">-  nsresult rv = GetDatabase(); // we need a database for this</span>
<a href="#l20.6210"></a><span id="l20.6210" class="difflineplus">+nsresult nsImapMailFolder::SyncFlags(nsIImapFlagAndUidState *flagState) {</span>
<a href="#l20.6211"></a><span id="l20.6211" class="difflineplus">+  nsresult rv = GetDatabase();  // we need a database for this</span>
<a href="#l20.6212"></a><span id="l20.6212">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.6213"></a><span id="l20.6213">   bool partialUIDFetch;</span>
<a href="#l20.6214"></a><span id="l20.6214">   flagState-&gt;GetPartialUIDFetch(&amp;partialUIDFetch);</span>
<a href="#l20.6215"></a><span id="l20.6215"> </span>
<a href="#l20.6216"></a><span id="l20.6216">   // update all of the database flags</span>
<a href="#l20.6217"></a><span id="l20.6217">   int32_t messageIndex;</span>
<a href="#l20.6218"></a><span id="l20.6218">   uint32_t messageSize;</span>
<a href="#l20.6219"></a><span id="l20.6219"> </span>
<a href="#l20.6220"></a><span id="l20.6220" class="difflineat">@@ -4873,311 +4492,292 @@ nsresult nsImapMailFolder::SyncFlags(nsI</span>
<a href="#l20.6221"></a><span id="l20.6221">   // partial (condstore) fetch.</span>
<a href="#l20.6222"></a><span id="l20.6222">   int64_t newFolderSize = 0;</span>
<a href="#l20.6223"></a><span id="l20.6223"> </span>
<a href="#l20.6224"></a><span id="l20.6224">   flagState-&gt;GetNumberOfMessages(&amp;messageIndex);</span>
<a href="#l20.6225"></a><span id="l20.6225"> </span>
<a href="#l20.6226"></a><span id="l20.6226">   uint16_t supportedUserFlags;</span>
<a href="#l20.6227"></a><span id="l20.6227">   flagState-&gt;GetSupportedUserFlags(&amp;supportedUserFlags);</span>
<a href="#l20.6228"></a><span id="l20.6228"> </span>
<a href="#l20.6229"></a><span id="l20.6229" class="difflineminus">-  for (int32_t flagIndex = 0; flagIndex &lt; messageIndex; flagIndex++)</span>
<a href="#l20.6230"></a><span id="l20.6230" class="difflineminus">-  {</span>
<a href="#l20.6231"></a><span id="l20.6231" class="difflineplus">+  for (int32_t flagIndex = 0; flagIndex &lt; messageIndex; flagIndex++) {</span>
<a href="#l20.6232"></a><span id="l20.6232">     uint32_t uidOfMessage;</span>
<a href="#l20.6233"></a><span id="l20.6233">     flagState-&gt;GetUidOfMessage(flagIndex, &amp;uidOfMessage);</span>
<a href="#l20.6234"></a><span id="l20.6234">     imapMessageFlagsType flags;</span>
<a href="#l20.6235"></a><span id="l20.6235">     flagState-&gt;GetMessageFlags(flagIndex, &amp;flags);</span>
<a href="#l20.6236"></a><span id="l20.6236">     nsCOMPtr&lt;nsIMsgDBHdr&gt; dbHdr;</span>
<a href="#l20.6237"></a><span id="l20.6237">     bool containsKey;</span>
<a href="#l20.6238"></a><span id="l20.6238" class="difflineminus">-    rv = mDatabase-&gt;ContainsKey(uidOfMessage , &amp;containsKey);</span>
<a href="#l20.6239"></a><span id="l20.6239" class="difflineplus">+    rv = mDatabase-&gt;ContainsKey(uidOfMessage, &amp;containsKey);</span>
<a href="#l20.6240"></a><span id="l20.6240">     // if we don't have the header, don't diddle the flags.</span>
<a href="#l20.6241"></a><span id="l20.6241">     // GetMsgHdrForKey will create the header if it doesn't exist.</span>
<a href="#l20.6242"></a><span id="l20.6242" class="difflineminus">-    if (NS_FAILED(rv) || !containsKey)</span>
<a href="#l20.6243"></a><span id="l20.6243" class="difflineminus">-      continue;</span>
<a href="#l20.6244"></a><span id="l20.6244" class="difflineplus">+    if (NS_FAILED(rv) || !containsKey) continue;</span>
<a href="#l20.6245"></a><span id="l20.6245"> </span>
<a href="#l20.6246"></a><span id="l20.6246">     rv = mDatabase-&gt;GetMsgHdrForKey(uidOfMessage, getter_AddRefs(dbHdr));</span>
<a href="#l20.6247"></a><span id="l20.6247">     if (NS_SUCCEEDED(dbHdr-&gt;GetMessageSize(&amp;messageSize)))</span>
<a href="#l20.6248"></a><span id="l20.6248">       newFolderSize += messageSize;</span>
<a href="#l20.6249"></a><span id="l20.6249"> </span>
<a href="#l20.6250"></a><span id="l20.6250">     nsCString keywords;</span>
<a href="#l20.6251"></a><span id="l20.6251" class="difflineminus">-    if (NS_SUCCEEDED(flagState-&gt;GetCustomFlags(uidOfMessage, getter_Copies(keywords))))</span>
<a href="#l20.6252"></a><span id="l20.6252" class="difflineminus">-        HandleCustomFlags(uidOfMessage, dbHdr, supportedUserFlags, keywords, flagState);</span>
<a href="#l20.6253"></a><span id="l20.6253" class="difflineplus">+    if (NS_SUCCEEDED(</span>
<a href="#l20.6254"></a><span id="l20.6254" class="difflineplus">+            flagState-&gt;GetCustomFlags(uidOfMessage, getter_Copies(keywords))))</span>
<a href="#l20.6255"></a><span id="l20.6255" class="difflineplus">+      HandleCustomFlags(uidOfMessage, dbHdr, supportedUserFlags, keywords,</span>
<a href="#l20.6256"></a><span id="l20.6256" class="difflineplus">+                        flagState);</span>
<a href="#l20.6257"></a><span id="l20.6257"> </span>
<a href="#l20.6258"></a><span id="l20.6258">     NotifyMessageFlagsFromHdr(dbHdr, uidOfMessage, flags);</span>
<a href="#l20.6259"></a><span id="l20.6259">   }</span>
<a href="#l20.6260"></a><span id="l20.6260" class="difflineminus">-  if (!partialUIDFetch &amp;&amp; newFolderSize != mFolderSize)</span>
<a href="#l20.6261"></a><span id="l20.6261" class="difflineminus">-  {</span>
<a href="#l20.6262"></a><span id="l20.6262" class="difflineplus">+  if (!partialUIDFetch &amp;&amp; newFolderSize != mFolderSize) {</span>
<a href="#l20.6263"></a><span id="l20.6263">     int64_t oldFolderSize = mFolderSize;</span>
<a href="#l20.6264"></a><span id="l20.6264">     mFolderSize = newFolderSize;</span>
<a href="#l20.6265"></a><span id="l20.6265">     NotifyIntPropertyChanged(kFolderSize, oldFolderSize, mFolderSize);</span>
<a href="#l20.6266"></a><span id="l20.6266">   }</span>
<a href="#l20.6267"></a><span id="l20.6267"> </span>
<a href="#l20.6268"></a><span id="l20.6268">   return NS_OK;</span>
<a href="#l20.6269"></a><span id="l20.6269"> }</span>
<a href="#l20.6270"></a><span id="l20.6270"> </span>
<a href="#l20.6271"></a><span id="l20.6271"> // helper routine to sync the flags on a given header</span>
<a href="#l20.6272"></a><span id="l20.6272" class="difflineminus">-nsresult</span>
<a href="#l20.6273"></a><span id="l20.6273" class="difflineminus">-nsImapMailFolder::NotifyMessageFlagsFromHdr(nsIMsgDBHdr *dbHdr,</span>
<a href="#l20.6274"></a><span id="l20.6274" class="difflineminus">-                                            nsMsgKey msgKey, uint32_t flags)</span>
<a href="#l20.6275"></a><span id="l20.6275" class="difflineminus">-{</span>
<a href="#l20.6276"></a><span id="l20.6276" class="difflineplus">+nsresult nsImapMailFolder::NotifyMessageFlagsFromHdr(nsIMsgDBHdr *dbHdr,</span>
<a href="#l20.6277"></a><span id="l20.6277" class="difflineplus">+                                                     nsMsgKey msgKey,</span>
<a href="#l20.6278"></a><span id="l20.6278" class="difflineplus">+                                                     uint32_t flags) {</span>
<a href="#l20.6279"></a><span id="l20.6279">   nsresult rv = GetDatabase();</span>
<a href="#l20.6280"></a><span id="l20.6280">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.6281"></a><span id="l20.6281"> </span>
<a href="#l20.6282"></a><span id="l20.6282">   // Although it may seem strange to keep a local reference of mDatabase here,</span>
<a href="#l20.6283"></a><span id="l20.6283" class="difflineminus">-  // the current lifetime management of databases requires that methods sometimes</span>
<a href="#l20.6284"></a><span id="l20.6284" class="difflineminus">-  // null the database when they think they opened it. Unfortunately experience</span>
<a href="#l20.6285"></a><span id="l20.6285" class="difflineminus">-  // shows this happens when we don't expect, so for crash protection best</span>
<a href="#l20.6286"></a><span id="l20.6286" class="difflineminus">-  // practice with the current flawed database management is to keep a local</span>
<a href="#l20.6287"></a><span id="l20.6287" class="difflineminus">-  // reference when there will be complex calls in a method. See bug 1312254.</span>
<a href="#l20.6288"></a><span id="l20.6288" class="difflineplus">+  // the current lifetime management of databases requires that methods</span>
<a href="#l20.6289"></a><span id="l20.6289" class="difflineplus">+  // sometimes null the database when they think they opened it. Unfortunately</span>
<a href="#l20.6290"></a><span id="l20.6290" class="difflineplus">+  // experience shows this happens when we don't expect, so for crash protection</span>
<a href="#l20.6291"></a><span id="l20.6291" class="difflineplus">+  // best practice with the current flawed database management is to keep a</span>
<a href="#l20.6292"></a><span id="l20.6292" class="difflineplus">+  // local reference when there will be complex calls in a method. See bug</span>
<a href="#l20.6293"></a><span id="l20.6293" class="difflineplus">+  // 1312254.</span>
<a href="#l20.6294"></a><span id="l20.6294">   nsCOMPtr&lt;nsIMsgDatabase&gt; database(mDatabase);</span>
<a href="#l20.6295"></a><span id="l20.6295">   NS_ENSURE_STATE(database);</span>
<a href="#l20.6296"></a><span id="l20.6296"> </span>
<a href="#l20.6297"></a><span id="l20.6297">   database-&gt;MarkHdrRead(dbHdr, (flags &amp; kImapMsgSeenFlag) != 0, nullptr);</span>
<a href="#l20.6298"></a><span id="l20.6298">   database-&gt;MarkHdrReplied(dbHdr, (flags &amp; kImapMsgAnsweredFlag) != 0, nullptr);</span>
<a href="#l20.6299"></a><span id="l20.6299">   database-&gt;MarkHdrMarked(dbHdr, (flags &amp; kImapMsgFlaggedFlag) != 0, nullptr);</span>
<a href="#l20.6300"></a><span id="l20.6300" class="difflineminus">-  database-&gt;MarkImapDeleted(msgKey, (flags &amp; kImapMsgDeletedFlag) != 0, nullptr);</span>
<a href="#l20.6301"></a><span id="l20.6301" class="difflineplus">+  database-&gt;MarkImapDeleted(msgKey, (flags &amp; kImapMsgDeletedFlag) != 0,</span>
<a href="#l20.6302"></a><span id="l20.6302" class="difflineplus">+                            nullptr);</span>
<a href="#l20.6303"></a><span id="l20.6303"> </span>
<a href="#l20.6304"></a><span id="l20.6304">   uint32_t supportedFlags;</span>
<a href="#l20.6305"></a><span id="l20.6305">   GetSupportedUserFlags(&amp;supportedFlags);</span>
<a href="#l20.6306"></a><span id="l20.6306">   if (supportedFlags &amp; kImapMsgSupportForwardedFlag)</span>
<a href="#l20.6307"></a><span id="l20.6307" class="difflineminus">-    database-&gt;MarkForwarded(msgKey, (flags &amp; kImapMsgForwardedFlag) != 0, nullptr);</span>
<a href="#l20.6308"></a><span id="l20.6308" class="difflineplus">+    database-&gt;MarkForwarded(msgKey, (flags &amp; kImapMsgForwardedFlag) != 0,</span>
<a href="#l20.6309"></a><span id="l20.6309" class="difflineplus">+                            nullptr);</span>
<a href="#l20.6310"></a><span id="l20.6310">   // this turns on labels, but it doesn't handle the case where the user</span>
<a href="#l20.6311"></a><span id="l20.6311">   // unlabels a message on one machine, and expects it to be unlabeled</span>
<a href="#l20.6312"></a><span id="l20.6312">   // on their other machines. If I turn that on, I'll be removing all the labels</span>
<a href="#l20.6313"></a><span id="l20.6313">   // that were assigned before we started storing them on the server, which will</span>
<a href="#l20.6314"></a><span id="l20.6314">   // make some people very unhappy.</span>
<a href="#l20.6315"></a><span id="l20.6315">   if (flags &amp; kImapMsgLabelFlags)</span>
<a href="#l20.6316"></a><span id="l20.6316">     database-&gt;SetLabel(msgKey, (flags &amp; kImapMsgLabelFlags) &gt;&gt; 9);</span>
<a href="#l20.6317"></a><span id="l20.6317" class="difflineminus">-  else</span>
<a href="#l20.6318"></a><span id="l20.6318" class="difflineminus">-  {</span>
<a href="#l20.6319"></a><span id="l20.6319" class="difflineminus">-    if (supportedFlags &amp; kImapMsgLabelFlags)</span>
<a href="#l20.6320"></a><span id="l20.6320" class="difflineminus">-      database-&gt;SetLabel(msgKey, 0);</span>
<a href="#l20.6321"></a><span id="l20.6321" class="difflineplus">+  else {</span>
<a href="#l20.6322"></a><span id="l20.6322" class="difflineplus">+    if (supportedFlags &amp; kImapMsgLabelFlags) database-&gt;SetLabel(msgKey, 0);</span>
<a href="#l20.6323"></a><span id="l20.6323">   }</span>
<a href="#l20.6324"></a><span id="l20.6324">   if (supportedFlags &amp; kImapMsgSupportMDNSentFlag)</span>
<a href="#l20.6325"></a><span id="l20.6325">     database-&gt;MarkMDNSent(msgKey, (flags &amp; kImapMsgMDNSentFlag) != 0, nullptr);</span>
<a href="#l20.6326"></a><span id="l20.6326"> </span>
<a href="#l20.6327"></a><span id="l20.6327">   return NS_OK;</span>
<a href="#l20.6328"></a><span id="l20.6328"> }</span>
<a href="#l20.6329"></a><span id="l20.6329"> </span>
<a href="#l20.6330"></a><span id="l20.6330"> // message flags operation - this is called from the imap protocol,</span>
<a href="#l20.6331"></a><span id="l20.6331"> // proxied over from the imap thread to the ui thread, when a flag changes</span>
<a href="#l20.6332"></a><span id="l20.6332"> NS_IMETHODIMP</span>
<a href="#l20.6333"></a><span id="l20.6333"> nsImapMailFolder::NotifyMessageFlags(uint32_t aFlags,</span>
<a href="#l20.6334"></a><span id="l20.6334">                                      const nsACString &amp;aKeywords,</span>
<a href="#l20.6335"></a><span id="l20.6335" class="difflineminus">-                                     nsMsgKey aMsgKey, uint64_t aHighestModSeq)</span>
<a href="#l20.6336"></a><span id="l20.6336" class="difflineminus">-{</span>
<a href="#l20.6337"></a><span id="l20.6337" class="difflineminus">-  if (NS_SUCCEEDED(GetDatabase()) &amp;&amp; mDatabase)</span>
<a href="#l20.6338"></a><span id="l20.6338" class="difflineminus">-  {</span>
<a href="#l20.6339"></a><span id="l20.6339" class="difflineplus">+                                     nsMsgKey aMsgKey,</span>
<a href="#l20.6340"></a><span id="l20.6340" class="difflineplus">+                                     uint64_t aHighestModSeq) {</span>
<a href="#l20.6341"></a><span id="l20.6341" class="difflineplus">+  if (NS_SUCCEEDED(GetDatabase()) &amp;&amp; mDatabase) {</span>
<a href="#l20.6342"></a><span id="l20.6342">     bool msgDeleted = aFlags &amp; kImapMsgDeletedFlag;</span>
<a href="#l20.6343"></a><span id="l20.6343" class="difflineminus">-    if (aHighestModSeq || msgDeleted)</span>
<a href="#l20.6344"></a><span id="l20.6344" class="difflineminus">-    {</span>
<a href="#l20.6345"></a><span id="l20.6345" class="difflineminus">-      nsCOMPtr &lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l20.6346"></a><span id="l20.6346" class="difflineplus">+    if (aHighestModSeq || msgDeleted) {</span>
<a href="#l20.6347"></a><span id="l20.6347" class="difflineplus">+      nsCOMPtr&lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l20.6348"></a><span id="l20.6348">       mDatabase-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l20.6349"></a><span id="l20.6349" class="difflineminus">-      if (dbFolderInfo)</span>
<a href="#l20.6350"></a><span id="l20.6350" class="difflineminus">-      {</span>
<a href="#l20.6351"></a><span id="l20.6351" class="difflineminus">-        if (aHighestModSeq)</span>
<a href="#l20.6352"></a><span id="l20.6352" class="difflineminus">-        {</span>
<a href="#l20.6353"></a><span id="l20.6353" class="difflineplus">+      if (dbFolderInfo) {</span>
<a href="#l20.6354"></a><span id="l20.6354" class="difflineplus">+        if (aHighestModSeq) {</span>
<a href="#l20.6355"></a><span id="l20.6355">           char intStrBuf[40];</span>
<a href="#l20.6356"></a><span id="l20.6356" class="difflineminus">-          PR_snprintf(intStrBuf, sizeof(intStrBuf), &quot;%llu&quot;,  aHighestModSeq);</span>
<a href="#l20.6357"></a><span id="l20.6357" class="difflineplus">+          PR_snprintf(intStrBuf, sizeof(intStrBuf), &quot;%llu&quot;, aHighestModSeq);</span>
<a href="#l20.6358"></a><span id="l20.6358">           MOZ_LOG(IMAP_CS, mozilla::LogLevel::Debug,</span>
<a href="#l20.6359"></a><span id="l20.6359" class="difflineminus">-                  (&quot;NotifyMessageFlags(): Store highest MODSEQ=%&quot; PRIu64 &quot; for folder=%s&quot;,</span>
<a href="#l20.6360"></a><span id="l20.6360" class="difflineplus">+                  (&quot;NotifyMessageFlags(): Store highest MODSEQ=%&quot; PRIu64</span>
<a href="#l20.6361"></a><span id="l20.6361" class="difflineplus">+                   &quot; for folder=%s&quot;,</span>
<a href="#l20.6362"></a><span id="l20.6362">                    aHighestModSeq, m_onlineFolderName.get()));</span>
<a href="#l20.6363"></a><span id="l20.6363" class="difflineminus">-          dbFolderInfo-&gt;SetCharProperty(kModSeqPropertyName, nsDependentCString(intStrBuf));</span>
<a href="#l20.6364"></a><span id="l20.6364" class="difflineplus">+          dbFolderInfo-&gt;SetCharProperty(kModSeqPropertyName,</span>
<a href="#l20.6365"></a><span id="l20.6365" class="difflineplus">+                                        nsDependentCString(intStrBuf));</span>
<a href="#l20.6366"></a><span id="l20.6366">         }</span>
<a href="#l20.6367"></a><span id="l20.6367" class="difflineminus">-        if (msgDeleted)</span>
<a href="#l20.6368"></a><span id="l20.6368" class="difflineminus">-        {</span>
<a href="#l20.6369"></a><span id="l20.6369" class="difflineplus">+        if (msgDeleted) {</span>
<a href="#l20.6370"></a><span id="l20.6370">           uint32_t oldDeletedCount;</span>
<a href="#l20.6371"></a><span id="l20.6371" class="difflineminus">-          dbFolderInfo-&gt;GetUint32Property(kDeletedHdrCountPropertyName, 0, &amp;oldDeletedCount);</span>
<a href="#l20.6372"></a><span id="l20.6372" class="difflineminus">-          dbFolderInfo-&gt;SetUint32Property(kDeletedHdrCountPropertyName, oldDeletedCount + 1);</span>
<a href="#l20.6373"></a><span id="l20.6373" class="difflineplus">+          dbFolderInfo-&gt;GetUint32Property(kDeletedHdrCountPropertyName, 0,</span>
<a href="#l20.6374"></a><span id="l20.6374" class="difflineplus">+                                          &amp;oldDeletedCount);</span>
<a href="#l20.6375"></a><span id="l20.6375" class="difflineplus">+          dbFolderInfo-&gt;SetUint32Property(kDeletedHdrCountPropertyName,</span>
<a href="#l20.6376"></a><span id="l20.6376" class="difflineplus">+                                          oldDeletedCount + 1);</span>
<a href="#l20.6377"></a><span id="l20.6377">         }</span>
<a href="#l20.6378"></a><span id="l20.6378">       }</span>
<a href="#l20.6379"></a><span id="l20.6379">     }</span>
<a href="#l20.6380"></a><span id="l20.6380">     nsCOMPtr&lt;nsIMsgDBHdr&gt; dbHdr;</span>
<a href="#l20.6381"></a><span id="l20.6381">     bool containsKey;</span>
<a href="#l20.6382"></a><span id="l20.6382" class="difflineminus">-    nsresult rv = mDatabase-&gt;ContainsKey(aMsgKey , &amp;containsKey);</span>
<a href="#l20.6383"></a><span id="l20.6383" class="difflineplus">+    nsresult rv = mDatabase-&gt;ContainsKey(aMsgKey, &amp;containsKey);</span>
<a href="#l20.6384"></a><span id="l20.6384">     // if we don't have the header, don't diddle the flags.</span>
<a href="#l20.6385"></a><span id="l20.6385">     // GetMsgHdrForKey will create the header if it doesn't exist.</span>
<a href="#l20.6386"></a><span id="l20.6386" class="difflineminus">-    if (NS_FAILED(rv) || !containsKey)</span>
<a href="#l20.6387"></a><span id="l20.6387" class="difflineminus">-      return rv;</span>
<a href="#l20.6388"></a><span id="l20.6388" class="difflineplus">+    if (NS_FAILED(rv) || !containsKey) return rv;</span>
<a href="#l20.6389"></a><span id="l20.6389">     rv = mDatabase-&gt;GetMsgHdrForKey(aMsgKey, getter_AddRefs(dbHdr));</span>
<a href="#l20.6390"></a><span id="l20.6390" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; dbHdr)</span>
<a href="#l20.6391"></a><span id="l20.6391" class="difflineminus">-    {</span>
<a href="#l20.6392"></a><span id="l20.6392" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; dbHdr) {</span>
<a href="#l20.6393"></a><span id="l20.6393">       uint32_t supportedUserFlags;</span>
<a href="#l20.6394"></a><span id="l20.6394">       GetSupportedUserFlags(&amp;supportedUserFlags);</span>
<a href="#l20.6395"></a><span id="l20.6395">       NotifyMessageFlagsFromHdr(dbHdr, aMsgKey, aFlags);</span>
<a href="#l20.6396"></a><span id="l20.6396">       nsCString keywords(aKeywords);</span>
<a href="#l20.6397"></a><span id="l20.6397">       HandleCustomFlags(aMsgKey, dbHdr, supportedUserFlags, keywords, nullptr);</span>
<a href="#l20.6398"></a><span id="l20.6398">     }</span>
<a href="#l20.6399"></a><span id="l20.6399">   }</span>
<a href="#l20.6400"></a><span id="l20.6400">   return NS_OK;</span>
<a href="#l20.6401"></a><span id="l20.6401"> }</span>
<a href="#l20.6402"></a><span id="l20.6402"> </span>
<a href="#l20.6403"></a><span id="l20.6403"> NS_IMETHODIMP</span>
<a href="#l20.6404"></a><span id="l20.6404" class="difflineminus">-nsImapMailFolder::NotifyMessageDeleted(const char * onlineFolderName, bool deleteAllMsgs, const char * msgIdString)</span>
<a href="#l20.6405"></a><span id="l20.6405" class="difflineminus">-{</span>
<a href="#l20.6406"></a><span id="l20.6406" class="difflineminus">-  if (deleteAllMsgs)</span>
<a href="#l20.6407"></a><span id="l20.6407" class="difflineminus">-    return NS_OK;</span>
<a href="#l20.6408"></a><span id="l20.6408" class="difflineminus">-</span>
<a href="#l20.6409"></a><span id="l20.6409" class="difflineminus">-  if (!msgIdString)</span>
<a href="#l20.6410"></a><span id="l20.6410" class="difflineminus">-    return NS_OK;</span>
<a href="#l20.6411"></a><span id="l20.6411" class="difflineplus">+nsImapMailFolder::NotifyMessageDeleted(const char *onlineFolderName,</span>
<a href="#l20.6412"></a><span id="l20.6412" class="difflineplus">+                                       bool deleteAllMsgs,</span>
<a href="#l20.6413"></a><span id="l20.6413" class="difflineplus">+                                       const char *msgIdString) {</span>
<a href="#l20.6414"></a><span id="l20.6414" class="difflineplus">+  if (deleteAllMsgs) return NS_OK;</span>
<a href="#l20.6415"></a><span id="l20.6415" class="difflineplus">+</span>
<a href="#l20.6416"></a><span id="l20.6416" class="difflineplus">+  if (!msgIdString) return NS_OK;</span>
<a href="#l20.6417"></a><span id="l20.6417"> </span>
<a href="#l20.6418"></a><span id="l20.6418">   nsTArray&lt;nsMsgKey&gt; affectedMessages;</span>
<a href="#l20.6419"></a><span id="l20.6419">   ParseUidString(msgIdString, affectedMessages);</span>
<a href="#l20.6420"></a><span id="l20.6420"> </span>
<a href="#l20.6421"></a><span id="l20.6421" class="difflineminus">-  if (!ShowDeletedMessages())</span>
<a href="#l20.6422"></a><span id="l20.6422" class="difflineminus">-  {</span>
<a href="#l20.6423"></a><span id="l20.6423" class="difflineplus">+  if (!ShowDeletedMessages()) {</span>
<a href="#l20.6424"></a><span id="l20.6424">     GetDatabase();</span>
<a href="#l20.6425"></a><span id="l20.6425">     NS_ENSURE_TRUE(mDatabase, NS_OK);</span>
<a href="#l20.6426"></a><span id="l20.6426" class="difflineminus">-    if (!ShowDeletedMessages())</span>
<a href="#l20.6427"></a><span id="l20.6427" class="difflineminus">-    {</span>
<a href="#l20.6428"></a><span id="l20.6428" class="difflineminus">-      if (!affectedMessages.IsEmpty()) // perhaps Search deleted these messages</span>
<a href="#l20.6429"></a><span id="l20.6429" class="difflineplus">+    if (!ShowDeletedMessages()) {</span>
<a href="#l20.6430"></a><span id="l20.6430" class="difflineplus">+      if (!affectedMessages.IsEmpty())  // perhaps Search deleted these messages</span>
<a href="#l20.6431"></a><span id="l20.6431">       {</span>
<a href="#l20.6432"></a><span id="l20.6432">         DeleteStoreMessages(affectedMessages);</span>
<a href="#l20.6433"></a><span id="l20.6433" class="difflineminus">-        mDatabase-&gt;DeleteMessages(affectedMessages.Length(), affectedMessages.Elements(), nullptr);</span>
<a href="#l20.6434"></a><span id="l20.6434" class="difflineplus">+        mDatabase-&gt;DeleteMessages(affectedMessages.Length(),</span>
<a href="#l20.6435"></a><span id="l20.6435" class="difflineplus">+                                  affectedMessages.Elements(), nullptr);</span>
<a href="#l20.6436"></a><span id="l20.6436">       }</span>
<a href="#l20.6437"></a><span id="l20.6437" class="difflineminus">-    }</span>
<a href="#l20.6438"></a><span id="l20.6438" class="difflineminus">-    else // &amp;&amp; !imapDeleteIsMoveToTrash // TODO: can this ever be executed?</span>
<a href="#l20.6439"></a><span id="l20.6439" class="difflineplus">+    } else  // &amp;&amp; !imapDeleteIsMoveToTrash // TODO: can this ever be executed?</span>
<a href="#l20.6440"></a><span id="l20.6440">       SetIMAPDeletedFlag(mDatabase, affectedMessages, false);</span>
<a href="#l20.6441"></a><span id="l20.6441">   }</span>
<a href="#l20.6442"></a><span id="l20.6442">   return NS_OK;</span>
<a href="#l20.6443"></a><span id="l20.6443"> }</span>
<a href="#l20.6444"></a><span id="l20.6444"> </span>
<a href="#l20.6445"></a><span id="l20.6445" class="difflineminus">-bool nsImapMailFolder::ShowDeletedMessages()</span>
<a href="#l20.6446"></a><span id="l20.6446" class="difflineminus">-{</span>
<a href="#l20.6447"></a><span id="l20.6447" class="difflineplus">+bool nsImapMailFolder::ShowDeletedMessages() {</span>
<a href="#l20.6448"></a><span id="l20.6448">   nsresult rv;</span>
<a href="#l20.6449"></a><span id="l20.6449" class="difflineminus">-  nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession = do_GetService(kCImapHostSessionList, &amp;rv);</span>
<a href="#l20.6450"></a><span id="l20.6450" class="difflineplus">+  nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession =</span>
<a href="#l20.6451"></a><span id="l20.6451" class="difflineplus">+      do_GetService(kCImapHostSessionList, &amp;rv);</span>
<a href="#l20.6452"></a><span id="l20.6452">   NS_ENSURE_SUCCESS(rv, false);</span>
<a href="#l20.6453"></a><span id="l20.6453"> </span>
<a href="#l20.6454"></a><span id="l20.6454">   bool showDeleted = false;</span>
<a href="#l20.6455"></a><span id="l20.6455">   nsCString serverKey;</span>
<a href="#l20.6456"></a><span id="l20.6456">   GetServerKey(serverKey);</span>
<a href="#l20.6457"></a><span id="l20.6457">   hostSession-&gt;GetShowDeletedMessagesForHost(serverKey.get(), showDeleted);</span>
<a href="#l20.6458"></a><span id="l20.6458"> </span>
<a href="#l20.6459"></a><span id="l20.6459">   return showDeleted;</span>
<a href="#l20.6460"></a><span id="l20.6460"> }</span>
<a href="#l20.6461"></a><span id="l20.6461"> </span>
<a href="#l20.6462"></a><span id="l20.6462" class="difflineminus">-bool nsImapMailFolder::DeleteIsMoveToTrash()</span>
<a href="#l20.6463"></a><span id="l20.6463" class="difflineminus">-{</span>
<a href="#l20.6464"></a><span id="l20.6464" class="difflineplus">+bool nsImapMailFolder::DeleteIsMoveToTrash() {</span>
<a href="#l20.6465"></a><span id="l20.6465">   nsresult err;</span>
<a href="#l20.6466"></a><span id="l20.6466" class="difflineminus">-  nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession = do_GetService(kCImapHostSessionList, &amp;err);</span>
<a href="#l20.6467"></a><span id="l20.6467" class="difflineplus">+  nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession =</span>
<a href="#l20.6468"></a><span id="l20.6468" class="difflineplus">+      do_GetService(kCImapHostSessionList, &amp;err);</span>
<a href="#l20.6469"></a><span id="l20.6469">   NS_ENSURE_SUCCESS(err, true);</span>
<a href="#l20.6470"></a><span id="l20.6470">   bool rv = true;</span>
<a href="#l20.6471"></a><span id="l20.6471"> </span>
<a href="#l20.6472"></a><span id="l20.6472">   nsCString serverKey;</span>
<a href="#l20.6473"></a><span id="l20.6473">   GetServerKey(serverKey);</span>
<a href="#l20.6474"></a><span id="l20.6474">   hostSession-&gt;GetDeleteIsMoveToTrashForHost(serverKey.get(), rv);</span>
<a href="#l20.6475"></a><span id="l20.6475">   return rv;</span>
<a href="#l20.6476"></a><span id="l20.6476"> }</span>
<a href="#l20.6477"></a><span id="l20.6477"> </span>
<a href="#l20.6478"></a><span id="l20.6478" class="difflineminus">-nsresult nsImapMailFolder::GetTrashFolder(nsIMsgFolder **pTrashFolder)</span>
<a href="#l20.6479"></a><span id="l20.6479" class="difflineminus">-{</span>
<a href="#l20.6480"></a><span id="l20.6480" class="difflineplus">+nsresult nsImapMailFolder::GetTrashFolder(nsIMsgFolder **pTrashFolder) {</span>
<a href="#l20.6481"></a><span id="l20.6481">   NS_ENSURE_ARG_POINTER(pTrashFolder);</span>
<a href="#l20.6482"></a><span id="l20.6482">   nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l20.6483"></a><span id="l20.6483">   nsresult rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l20.6484"></a><span id="l20.6484" class="difflineminus">-  if(NS_SUCCEEDED(rv) &amp;&amp; rootFolder)</span>
<a href="#l20.6485"></a><span id="l20.6485" class="difflineminus">-  {</span>
<a href="#l20.6486"></a><span id="l20.6486" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder) {</span>
<a href="#l20.6487"></a><span id="l20.6487">     rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Trash, pTrashFolder);</span>
<a href="#l20.6488"></a><span id="l20.6488" class="difflineminus">-    if (!*pTrashFolder)</span>
<a href="#l20.6489"></a><span id="l20.6489" class="difflineminus">-      rv = NS_ERROR_FAILURE;</span>
<a href="#l20.6490"></a><span id="l20.6490" class="difflineplus">+    if (!*pTrashFolder) rv = NS_ERROR_FAILURE;</span>
<a href="#l20.6491"></a><span id="l20.6491">   }</span>
<a href="#l20.6492"></a><span id="l20.6492">   return rv;</span>
<a href="#l20.6493"></a><span id="l20.6493"> }</span>
<a href="#l20.6494"></a><span id="l20.6494"> </span>
<a href="#l20.6495"></a><span id="l20.6495" class="difflineminus">-</span>
<a href="#l20.6496"></a><span id="l20.6496"> // store nsMsgMessageFlags::IMAPDeleted in the specified mailhdr records</span>
<a href="#l20.6497"></a><span id="l20.6497" class="difflineminus">-void nsImapMailFolder::SetIMAPDeletedFlag(nsIMsgDatabase *mailDB, const nsTArray&lt;nsMsgKey&gt; &amp;msgids, bool markDeleted)</span>
<a href="#l20.6498"></a><span id="l20.6498" class="difflineminus">-{</span>
<a href="#l20.6499"></a><span id="l20.6499" class="difflineplus">+void nsImapMailFolder::SetIMAPDeletedFlag(nsIMsgDatabase *mailDB,</span>
<a href="#l20.6500"></a><span id="l20.6500" class="difflineplus">+                                          const nsTArray&lt;nsMsgKey&gt; &amp;msgids,</span>
<a href="#l20.6501"></a><span id="l20.6501" class="difflineplus">+                                          bool markDeleted) {</span>
<a href="#l20.6502"></a><span id="l20.6502">   nsresult markStatus = NS_OK;</span>
<a href="#l20.6503"></a><span id="l20.6503">   uint32_t total = msgids.Length();</span>
<a href="#l20.6504"></a><span id="l20.6504"> </span>
<a href="#l20.6505"></a><span id="l20.6505" class="difflineminus">-  for (uint32_t msgIndex=0; NS_SUCCEEDED(markStatus) &amp;&amp; (msgIndex &lt; total); msgIndex++)</span>
<a href="#l20.6506"></a><span id="l20.6506" class="difflineminus">-    markStatus = mailDB-&gt;MarkImapDeleted(msgids[msgIndex], markDeleted, nullptr);</span>
<a href="#l20.6507"></a><span id="l20.6507" class="difflineplus">+  for (uint32_t msgIndex = 0; NS_SUCCEEDED(markStatus) &amp;&amp; (msgIndex &lt; total);</span>
<a href="#l20.6508"></a><span id="l20.6508" class="difflineplus">+       msgIndex++)</span>
<a href="#l20.6509"></a><span id="l20.6509" class="difflineplus">+    markStatus =</span>
<a href="#l20.6510"></a><span id="l20.6510" class="difflineplus">+        mailDB-&gt;MarkImapDeleted(msgids[msgIndex], markDeleted, nullptr);</span>
<a href="#l20.6511"></a><span id="l20.6511"> }</span>
<a href="#l20.6512"></a><span id="l20.6512"> </span>
<a href="#l20.6513"></a><span id="l20.6513"> NS_IMETHODIMP</span>
<a href="#l20.6514"></a><span id="l20.6514" class="difflineminus">-nsImapMailFolder::GetMessageSizeFromDB(const char * id, uint32_t *size)</span>
<a href="#l20.6515"></a><span id="l20.6515" class="difflineminus">-{</span>
<a href="#l20.6516"></a><span id="l20.6516" class="difflineplus">+nsImapMailFolder::GetMessageSizeFromDB(const char *id, uint32_t *size) {</span>
<a href="#l20.6517"></a><span id="l20.6517">   NS_ENSURE_ARG_POINTER(size);</span>
<a href="#l20.6518"></a><span id="l20.6518"> </span>
<a href="#l20.6519"></a><span id="l20.6519">   *size = 0;</span>
<a href="#l20.6520"></a><span id="l20.6520">   nsresult rv = GetDatabase();</span>
<a href="#l20.6521"></a><span id="l20.6521">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.6522"></a><span id="l20.6522" class="difflineminus">-  if (id)</span>
<a href="#l20.6523"></a><span id="l20.6523" class="difflineminus">-  {</span>
<a href="#l20.6524"></a><span id="l20.6524" class="difflineplus">+  if (id) {</span>
<a href="#l20.6525"></a><span id="l20.6525">     nsMsgKey key = msgKeyFromInt(ParseUint64Str(id));</span>
<a href="#l20.6526"></a><span id="l20.6526">     nsCOMPtr&lt;nsIMsgDBHdr&gt; mailHdr;</span>
<a href="#l20.6527"></a><span id="l20.6527">     rv = mDatabase-&gt;GetMsgHdrForKey(key, getter_AddRefs(mailHdr));</span>
<a href="#l20.6528"></a><span id="l20.6528" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; mailHdr)</span>
<a href="#l20.6529"></a><span id="l20.6529" class="difflineminus">-      rv = mailHdr-&gt;GetMessageSize(size);</span>
<a href="#l20.6530"></a><span id="l20.6530" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; mailHdr) rv = mailHdr-&gt;GetMessageSize(size);</span>
<a href="#l20.6531"></a><span id="l20.6531">   }</span>
<a href="#l20.6532"></a><span id="l20.6532">   return rv;</span>
<a href="#l20.6533"></a><span id="l20.6533"> }</span>
<a href="#l20.6534"></a><span id="l20.6534"> </span>
<a href="#l20.6535"></a><span id="l20.6535"> NS_IMETHODIMP</span>
<a href="#l20.6536"></a><span id="l20.6536" class="difflineminus">-nsImapMailFolder::SetContentModified(nsIImapUrl *aImapUrl, nsImapContentModifiedType modified)</span>
<a href="#l20.6537"></a><span id="l20.6537" class="difflineminus">-{</span>
<a href="#l20.6538"></a><span id="l20.6538" class="difflineplus">+nsImapMailFolder::SetContentModified(nsIImapUrl *aImapUrl,</span>
<a href="#l20.6539"></a><span id="l20.6539" class="difflineplus">+                                     nsImapContentModifiedType modified) {</span>
<a href="#l20.6540"></a><span id="l20.6540">   return aImapUrl-&gt;SetContentModified(modified);</span>
<a href="#l20.6541"></a><span id="l20.6541"> }</span>
<a href="#l20.6542"></a><span id="l20.6542"> </span>
<a href="#l20.6543"></a><span id="l20.6543"> NS_IMETHODIMP</span>
<a href="#l20.6544"></a><span id="l20.6544"> nsImapMailFolder::GetCurMoveCopyMessageInfo(nsIImapUrl *runningUrl,</span>
<a href="#l20.6545"></a><span id="l20.6545">                                             PRTime *aDate,</span>
<a href="#l20.6546"></a><span id="l20.6546" class="difflineminus">-                                            nsACString&amp; aKeywords,</span>
<a href="#l20.6547"></a><span id="l20.6547" class="difflineminus">-                                            uint32_t* aResult)</span>
<a href="#l20.6548"></a><span id="l20.6548" class="difflineminus">-{</span>
<a href="#l20.6549"></a><span id="l20.6549" class="difflineminus">-  nsCOMPtr &lt;nsISupports&gt; copyState;</span>
<a href="#l20.6550"></a><span id="l20.6550" class="difflineplus">+                                            nsACString &amp;aKeywords,</span>
<a href="#l20.6551"></a><span id="l20.6551" class="difflineplus">+                                            uint32_t *aResult) {</span>
<a href="#l20.6552"></a><span id="l20.6552" class="difflineplus">+  nsCOMPtr&lt;nsISupports&gt; copyState;</span>
<a href="#l20.6553"></a><span id="l20.6553">   runningUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l20.6554"></a><span id="l20.6554" class="difflineminus">-  if (copyState)</span>
<a href="#l20.6555"></a><span id="l20.6555" class="difflineminus">-  {</span>
<a href="#l20.6556"></a><span id="l20.6556" class="difflineplus">+  if (copyState) {</span>
<a href="#l20.6557"></a><span id="l20.6557">     nsCOMPtr&lt;nsImapMailCopyState&gt; mailCopyState = do_QueryInterface(copyState);</span>
<a href="#l20.6558"></a><span id="l20.6558">     uint32_t supportedFlags = 0;</span>
<a href="#l20.6559"></a><span id="l20.6559">     GetSupportedUserFlags(&amp;supportedFlags);</span>
<a href="#l20.6560"></a><span id="l20.6560" class="difflineminus">-    if (mailCopyState &amp;&amp; mailCopyState-&gt;m_message)</span>
<a href="#l20.6561"></a><span id="l20.6561" class="difflineminus">-    {</span>
<a href="#l20.6562"></a><span id="l20.6562" class="difflineplus">+    if (mailCopyState &amp;&amp; mailCopyState-&gt;m_message) {</span>
<a href="#l20.6563"></a><span id="l20.6563">       nsMsgLabelValue label;</span>
<a href="#l20.6564"></a><span id="l20.6564">       mailCopyState-&gt;m_message-&gt;GetFlags(aResult);</span>
<a href="#l20.6565"></a><span id="l20.6565" class="difflineminus">-      if (supportedFlags &amp; (kImapMsgSupportUserFlag | kImapMsgLabelFlags))</span>
<a href="#l20.6566"></a><span id="l20.6566" class="difflineminus">-      {</span>
<a href="#l20.6567"></a><span id="l20.6567" class="difflineplus">+      if (supportedFlags &amp; (kImapMsgSupportUserFlag | kImapMsgLabelFlags)) {</span>
<a href="#l20.6568"></a><span id="l20.6568">         mailCopyState-&gt;m_message-&gt;GetLabel(&amp;label);</span>
<a href="#l20.6569"></a><span id="l20.6569" class="difflineminus">-        if (label != 0)</span>
<a href="#l20.6570"></a><span id="l20.6570" class="difflineminus">-          *aResult |= label &lt;&lt; 25;</span>
<a href="#l20.6571"></a><span id="l20.6571" class="difflineplus">+        if (label != 0) *aResult |= label &lt;&lt; 25;</span>
<a href="#l20.6572"></a><span id="l20.6572">       }</span>
<a href="#l20.6573"></a><span id="l20.6573" class="difflineminus">-      if (aDate)</span>
<a href="#l20.6574"></a><span id="l20.6574" class="difflineminus">-        mailCopyState-&gt;m_message-&gt;GetDate(aDate);</span>
<a href="#l20.6575"></a><span id="l20.6575" class="difflineminus">-      if (supportedFlags &amp; kImapMsgSupportUserFlag)</span>
<a href="#l20.6576"></a><span id="l20.6576" class="difflineminus">-      {</span>
<a href="#l20.6577"></a><span id="l20.6577" class="difflineplus">+      if (aDate) mailCopyState-&gt;m_message-&gt;GetDate(aDate);</span>
<a href="#l20.6578"></a><span id="l20.6578" class="difflineplus">+      if (supportedFlags &amp; kImapMsgSupportUserFlag) {</span>
<a href="#l20.6579"></a><span id="l20.6579">         // setup the custom imap keywords, which includes the message keywords</span>
<a href="#l20.6580"></a><span id="l20.6580">         // plus any junk status</span>
<a href="#l20.6581"></a><span id="l20.6581">         nsCString junkscore;</span>
<a href="#l20.6582"></a><span id="l20.6582">         mailCopyState-&gt;m_message-&gt;GetStringProperty(&quot;junkscore&quot;,</span>
<a href="#l20.6583"></a><span id="l20.6583">                                                     getter_Copies(junkscore));</span>
<a href="#l20.6584"></a><span id="l20.6584">         bool isJunk = false, isNotJunk = false;</span>
<a href="#l20.6585"></a><span id="l20.6585" class="difflineminus">-        if (!junkscore.IsEmpty())</span>
<a href="#l20.6586"></a><span id="l20.6586" class="difflineminus">-        {</span>
<a href="#l20.6587"></a><span id="l20.6587" class="difflineplus">+        if (!junkscore.IsEmpty()) {</span>
<a href="#l20.6588"></a><span id="l20.6588">           if (junkscore.EqualsLiteral(&quot;0&quot;))</span>
<a href="#l20.6589"></a><span id="l20.6589">             isNotJunk = true;</span>
<a href="#l20.6590"></a><span id="l20.6590">           else</span>
<a href="#l20.6591"></a><span id="l20.6591">             isJunk = true;</span>
<a href="#l20.6592"></a><span id="l20.6592">         }</span>
<a href="#l20.6593"></a><span id="l20.6593"> </span>
<a href="#l20.6594"></a><span id="l20.6594" class="difflineminus">-        nsCString keywords; // MsgFindKeyword can't use nsACString</span>
<a href="#l20.6595"></a><span id="l20.6595" class="difflineplus">+        nsCString keywords;  // MsgFindKeyword can't use nsACString</span>
<a href="#l20.6596"></a><span id="l20.6596">         mailCopyState-&gt;m_message-&gt;GetStringProperty(&quot;keywords&quot;,</span>
<a href="#l20.6597"></a><span id="l20.6597">                                                     getter_Copies(keywords));</span>
<a href="#l20.6598"></a><span id="l20.6598">         int32_t start;</span>
<a href="#l20.6599"></a><span id="l20.6599">         int32_t length;</span>
<a href="#l20.6600"></a><span id="l20.6600" class="difflineminus">-        bool hasJunk = MsgFindKeyword(NS_LITERAL_CSTRING(&quot;junk&quot;),</span>
<a href="#l20.6601"></a><span id="l20.6601" class="difflineminus">-                                        keywords, &amp;start, &amp;length);</span>
<a href="#l20.6602"></a><span id="l20.6602" class="difflineplus">+        bool hasJunk = MsgFindKeyword(NS_LITERAL_CSTRING(&quot;junk&quot;), keywords,</span>
<a href="#l20.6603"></a><span id="l20.6603" class="difflineplus">+                                      &amp;start, &amp;length);</span>
<a href="#l20.6604"></a><span id="l20.6604">         if (hasJunk &amp;&amp; !isJunk)</span>
<a href="#l20.6605"></a><span id="l20.6605">           keywords.Cut(start, length);</span>
<a href="#l20.6606"></a><span id="l20.6606">         else if (!hasJunk &amp;&amp; isJunk)</span>
<a href="#l20.6607"></a><span id="l20.6607">           keywords.AppendLiteral(&quot; Junk&quot;);</span>
<a href="#l20.6608"></a><span id="l20.6608">         bool hasNonJunk = MsgFindKeyword(NS_LITERAL_CSTRING(&quot;nonjunk&quot;),</span>
<a href="#l20.6609"></a><span id="l20.6609" class="difflineminus">-                                           keywords, &amp;start, &amp;length);</span>
<a href="#l20.6610"></a><span id="l20.6610" class="difflineplus">+                                         keywords, &amp;start, &amp;length);</span>
<a href="#l20.6611"></a><span id="l20.6611">         if (!hasNonJunk)</span>
<a href="#l20.6612"></a><span id="l20.6612" class="difflineminus">-          hasNonJunk = MsgFindKeyword(NS_LITERAL_CSTRING(&quot;notjunk&quot;),</span>
<a href="#l20.6613"></a><span id="l20.6613" class="difflineminus">-                                      keywords, &amp;start, &amp;length);</span>
<a href="#l20.6614"></a><span id="l20.6614" class="difflineplus">+          hasNonJunk = MsgFindKeyword(NS_LITERAL_CSTRING(&quot;notjunk&quot;), keywords,</span>
<a href="#l20.6615"></a><span id="l20.6615" class="difflineplus">+                                      &amp;start, &amp;length);</span>
<a href="#l20.6616"></a><span id="l20.6616">         if (hasNonJunk &amp;&amp; !isNotJunk)</span>
<a href="#l20.6617"></a><span id="l20.6617">           keywords.Cut(start, length);</span>
<a href="#l20.6618"></a><span id="l20.6618">         else if (!hasNonJunk &amp;&amp; isNotJunk)</span>
<a href="#l20.6619"></a><span id="l20.6619">           keywords.AppendLiteral(&quot; NonJunk&quot;);</span>
<a href="#l20.6620"></a><span id="l20.6620"> </span>
<a href="#l20.6621"></a><span id="l20.6621">         // Cleanup extra spaces</span>
<a href="#l20.6622"></a><span id="l20.6622">         while (!keywords.IsEmpty() &amp;&amp; keywords.First() == ' ')</span>
<a href="#l20.6623"></a><span id="l20.6623">           keywords.Cut(0, 1);</span>
<a href="#l20.6624"></a><span id="l20.6624" class="difflineat">@@ -5187,1104 +4787,961 @@ nsImapMailFolder::GetCurMoveCopyMessageI</span>
<a href="#l20.6625"></a><span id="l20.6625">                (start = keywords.Find(NS_LITERAL_CSTRING(&quot;  &quot;))) &gt;= 0)</span>
<a href="#l20.6626"></a><span id="l20.6626">           keywords.Cut(start, 1);</span>
<a href="#l20.6627"></a><span id="l20.6627">         aKeywords.Assign(keywords);</span>
<a href="#l20.6628"></a><span id="l20.6628">       }</span>
<a href="#l20.6629"></a><span id="l20.6629">     }</span>
<a href="#l20.6630"></a><span id="l20.6630">     // if we don't have a source header, and it's not the drafts folder,</span>
<a href="#l20.6631"></a><span id="l20.6631">     // then mark the message read, since it must be an append to the</span>
<a href="#l20.6632"></a><span id="l20.6632">     // fcc or templates folder.</span>
<a href="#l20.6633"></a><span id="l20.6633" class="difflineminus">-    else if (mailCopyState)</span>
<a href="#l20.6634"></a><span id="l20.6634" class="difflineminus">-    {</span>
<a href="#l20.6635"></a><span id="l20.6635" class="difflineplus">+    else if (mailCopyState) {</span>
<a href="#l20.6636"></a><span id="l20.6636">       *aResult = mailCopyState-&gt;m_newMsgFlags;</span>
<a href="#l20.6637"></a><span id="l20.6637">       if (supportedFlags &amp; kImapMsgSupportUserFlag)</span>
<a href="#l20.6638"></a><span id="l20.6638">         aKeywords.Assign(mailCopyState-&gt;m_newMsgKeywords);</span>
<a href="#l20.6639"></a><span id="l20.6639">     }</span>
<a href="#l20.6640"></a><span id="l20.6640">   }</span>
<a href="#l20.6641"></a><span id="l20.6641">   return NS_OK;</span>
<a href="#l20.6642"></a><span id="l20.6642"> }</span>
<a href="#l20.6643"></a><span id="l20.6643"> </span>
<a href="#l20.6644"></a><span id="l20.6644"> NS_IMETHODIMP</span>
<a href="#l20.6645"></a><span id="l20.6645" class="difflineminus">-nsImapMailFolder::OnStartRunningUrl(nsIURI *aUrl)</span>
<a href="#l20.6646"></a><span id="l20.6646" class="difflineminus">-{</span>
<a href="#l20.6647"></a><span id="l20.6647" class="difflineplus">+nsImapMailFolder::OnStartRunningUrl(nsIURI *aUrl) {</span>
<a href="#l20.6648"></a><span id="l20.6648">   NS_ASSERTION(aUrl, &quot;sanity check - need to be be running non-null url&quot;);</span>
<a href="#l20.6649"></a><span id="l20.6649">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailUrl = do_QueryInterface(aUrl);</span>
<a href="#l20.6650"></a><span id="l20.6650" class="difflineminus">-  if (mailUrl)</span>
<a href="#l20.6651"></a><span id="l20.6651" class="difflineminus">-  {</span>
<a href="#l20.6652"></a><span id="l20.6652" class="difflineplus">+  if (mailUrl) {</span>
<a href="#l20.6653"></a><span id="l20.6653">     bool updatingFolder;</span>
<a href="#l20.6654"></a><span id="l20.6654">     mailUrl-&gt;GetUpdatingFolder(&amp;updatingFolder);</span>
<a href="#l20.6655"></a><span id="l20.6655">     m_updatingFolder = updatingFolder;</span>
<a href="#l20.6656"></a><span id="l20.6656">   }</span>
<a href="#l20.6657"></a><span id="l20.6657">   m_urlRunning = true;</span>
<a href="#l20.6658"></a><span id="l20.6658">   return NS_OK;</span>
<a href="#l20.6659"></a><span id="l20.6659"> }</span>
<a href="#l20.6660"></a><span id="l20.6660"> </span>
<a href="#l20.6661"></a><span id="l20.6661"> NS_IMETHODIMP</span>
<a href="#l20.6662"></a><span id="l20.6662" class="difflineminus">-nsImapMailFolder::OnStopRunningUrl(nsIURI *aUrl, nsresult aExitCode)</span>
<a href="#l20.6663"></a><span id="l20.6663" class="difflineminus">-{</span>
<a href="#l20.6664"></a><span id="l20.6664" class="difflineplus">+nsImapMailFolder::OnStopRunningUrl(nsIURI *aUrl, nsresult aExitCode) {</span>
<a href="#l20.6665"></a><span id="l20.6665">   nsresult rv;</span>
<a href="#l20.6666"></a><span id="l20.6666">   bool endedOfflineDownload = false;</span>
<a href="#l20.6667"></a><span id="l20.6667">   nsImapAction imapAction = nsIImapUrl::nsImapTest;</span>
<a href="#l20.6668"></a><span id="l20.6668">   m_urlRunning = false;</span>
<a href="#l20.6669"></a><span id="l20.6669">   m_updatingFolder = false;</span>
<a href="#l20.6670"></a><span id="l20.6670">   nsCOMPtr&lt;nsIMsgMailSession&gt; session =</span>
<a href="#l20.6671"></a><span id="l20.6671" class="difflineminus">-    do_GetService(NS_MSGMAILSESSION_CONTRACTID, &amp;rv);</span>
<a href="#l20.6672"></a><span id="l20.6672" class="difflineplus">+      do_GetService(NS_MSGMAILSESSION_CONTRACTID, &amp;rv);</span>
<a href="#l20.6673"></a><span id="l20.6673">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.6674"></a><span id="l20.6674" class="difflineminus">-  if (aUrl)</span>
<a href="#l20.6675"></a><span id="l20.6675" class="difflineminus">-  {</span>
<a href="#l20.6676"></a><span id="l20.6676" class="difflineminus">-  nsCOMPtr &lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(aUrl, &amp;rv);</span>
<a href="#l20.6677"></a><span id="l20.6677" class="difflineminus">-  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.6678"></a><span id="l20.6678" class="difflineminus">-  bool downloadingForOfflineUse;</span>
<a href="#l20.6679"></a><span id="l20.6679" class="difflineminus">-  imapUrl-&gt;GetStoreResultsOffline(&amp;downloadingForOfflineUse);</span>
<a href="#l20.6680"></a><span id="l20.6680" class="difflineplus">+  if (aUrl) {</span>
<a href="#l20.6681"></a><span id="l20.6681" class="difflineplus">+    nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(aUrl, &amp;rv);</span>
<a href="#l20.6682"></a><span id="l20.6682" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.6683"></a><span id="l20.6683" class="difflineplus">+    bool downloadingForOfflineUse;</span>
<a href="#l20.6684"></a><span id="l20.6684" class="difflineplus">+    imapUrl-&gt;GetStoreResultsOffline(&amp;downloadingForOfflineUse);</span>
<a href="#l20.6685"></a><span id="l20.6685">     bool hasSemaphore = false;</span>
<a href="#l20.6686"></a><span id="l20.6686">     // if we have the folder locked, clear it.</span>
<a href="#l20.6687"></a><span id="l20.6687" class="difflineminus">-    TestSemaphore(static_cast&lt;nsIMsgFolder*&gt;(this), &amp;hasSemaphore);</span>
<a href="#l20.6688"></a><span id="l20.6688" class="difflineminus">-    if (hasSemaphore)</span>
<a href="#l20.6689"></a><span id="l20.6689" class="difflineminus">-      ReleaseSemaphore(static_cast&lt;nsIMsgFolder*&gt;(this));</span>
<a href="#l20.6690"></a><span id="l20.6690" class="difflineminus">-  if (downloadingForOfflineUse)</span>
<a href="#l20.6691"></a><span id="l20.6691" class="difflineminus">-  {</span>
<a href="#l20.6692"></a><span id="l20.6692" class="difflineminus">-    endedOfflineDownload = true;</span>
<a href="#l20.6693"></a><span id="l20.6693" class="difflineminus">-    EndOfflineDownload();</span>
<a href="#l20.6694"></a><span id="l20.6694" class="difflineminus">-  }</span>
<a href="#l20.6695"></a><span id="l20.6695" class="difflineplus">+    TestSemaphore(static_cast&lt;nsIMsgFolder *&gt;(this), &amp;hasSemaphore);</span>
<a href="#l20.6696"></a><span id="l20.6696" class="difflineplus">+    if (hasSemaphore) ReleaseSemaphore(static_cast&lt;nsIMsgFolder *&gt;(this));</span>
<a href="#l20.6697"></a><span id="l20.6697" class="difflineplus">+    if (downloadingForOfflineUse) {</span>
<a href="#l20.6698"></a><span id="l20.6698" class="difflineplus">+      endedOfflineDownload = true;</span>
<a href="#l20.6699"></a><span id="l20.6699" class="difflineplus">+      EndOfflineDownload();</span>
<a href="#l20.6700"></a><span id="l20.6700" class="difflineplus">+    }</span>
<a href="#l20.6701"></a><span id="l20.6701">     nsCOMPtr&lt;nsIMsgWindow&gt; msgWindow;</span>
<a href="#l20.6702"></a><span id="l20.6702">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailUrl = do_QueryInterface(aUrl);</span>
<a href="#l20.6703"></a><span id="l20.6703">     bool folderOpen = false;</span>
<a href="#l20.6704"></a><span id="l20.6704" class="difflineminus">-    if (mailUrl)</span>
<a href="#l20.6705"></a><span id="l20.6705" class="difflineminus">-      mailUrl-&gt;GetMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l20.6706"></a><span id="l20.6706" class="difflineminus">-    if (session)</span>
<a href="#l20.6707"></a><span id="l20.6707" class="difflineminus">-      session-&gt;IsFolderOpenInWindow(this, &amp;folderOpen);</span>
<a href="#l20.6708"></a><span id="l20.6708" class="difflineplus">+    if (mailUrl) mailUrl-&gt;GetMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l20.6709"></a><span id="l20.6709" class="difflineplus">+    if (session) session-&gt;IsFolderOpenInWindow(this, &amp;folderOpen);</span>
<a href="#l20.6710"></a><span id="l20.6710"> #ifdef DEBUG_bienvenu</span>
<a href="#l20.6711"></a><span id="l20.6711">     printf(&quot;stop running url %s\n&quot;, aUrl-&gt;GetSpecOrDefault().get());</span>
<a href="#l20.6712"></a><span id="l20.6712"> #endif</span>
<a href="#l20.6713"></a><span id="l20.6713"> </span>
<a href="#l20.6714"></a><span id="l20.6714" class="difflineminus">-   if (imapUrl)</span>
<a href="#l20.6715"></a><span id="l20.6715" class="difflineminus">-   {</span>
<a href="#l20.6716"></a><span id="l20.6716" class="difflineplus">+    if (imapUrl) {</span>
<a href="#l20.6717"></a><span id="l20.6717">       DisplayStatusMsg(imapUrl, EmptyString());</span>
<a href="#l20.6718"></a><span id="l20.6718">       imapUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l20.6719"></a><span id="l20.6719" class="difflineminus">-      if (imapAction == nsIImapUrl::nsImapMsgFetch || imapAction == nsIImapUrl::nsImapMsgDownloadForOffline)</span>
<a href="#l20.6720"></a><span id="l20.6720" class="difflineminus">-      {</span>
<a href="#l20.6721"></a><span id="l20.6721" class="difflineminus">-        ReleaseSemaphore(static_cast&lt;nsIMsgFolder*&gt;(this));</span>
<a href="#l20.6722"></a><span id="l20.6722" class="difflineminus">-        if (!endedOfflineDownload)</span>
<a href="#l20.6723"></a><span id="l20.6723" class="difflineminus">-          EndOfflineDownload();</span>
<a href="#l20.6724"></a><span id="l20.6724" class="difflineplus">+      if (imapAction == nsIImapUrl::nsImapMsgFetch ||</span>
<a href="#l20.6725"></a><span id="l20.6725" class="difflineplus">+          imapAction == nsIImapUrl::nsImapMsgDownloadForOffline) {</span>
<a href="#l20.6726"></a><span id="l20.6726" class="difflineplus">+        ReleaseSemaphore(static_cast&lt;nsIMsgFolder *&gt;(this));</span>
<a href="#l20.6727"></a><span id="l20.6727" class="difflineplus">+        if (!endedOfflineDownload) EndOfflineDownload();</span>
<a href="#l20.6728"></a><span id="l20.6728">       }</span>
<a href="#l20.6729"></a><span id="l20.6729"> </span>
<a href="#l20.6730"></a><span id="l20.6730">       // Notify move, copy or delete (online operations)</span>
<a href="#l20.6731"></a><span id="l20.6731" class="difflineminus">-      // Not sure whether nsImapDeleteMsg is even used, deletes in all three models use nsImapAddMsgFlags.</span>
<a href="#l20.6732"></a><span id="l20.6732" class="difflineminus">-      nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.6733"></a><span id="l20.6733" class="difflineminus">-      if (notifier &amp;&amp; m_copyState)</span>
<a href="#l20.6734"></a><span id="l20.6734" class="difflineminus">-      {</span>
<a href="#l20.6735"></a><span id="l20.6735" class="difflineplus">+      // Not sure whether nsImapDeleteMsg is even used, deletes in all three</span>
<a href="#l20.6736"></a><span id="l20.6736" class="difflineplus">+      // models use nsImapAddMsgFlags.</span>
<a href="#l20.6737"></a><span id="l20.6737" class="difflineplus">+      nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(</span>
<a href="#l20.6738"></a><span id="l20.6738" class="difflineplus">+          do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.6739"></a><span id="l20.6739" class="difflineplus">+      if (notifier &amp;&amp; m_copyState) {</span>
<a href="#l20.6740"></a><span id="l20.6740">         if (imapAction == nsIImapUrl::nsImapOnlineMove)</span>
<a href="#l20.6741"></a><span id="l20.6741" class="difflineminus">-          notifier-&gt;NotifyMsgsMoveCopyCompleted(true, m_copyState-&gt;m_messages, this, nullptr);</span>
<a href="#l20.6742"></a><span id="l20.6742" class="difflineplus">+          notifier-&gt;NotifyMsgsMoveCopyCompleted(true, m_copyState-&gt;m_messages,</span>
<a href="#l20.6743"></a><span id="l20.6743" class="difflineplus">+                                                this, nullptr);</span>
<a href="#l20.6744"></a><span id="l20.6744">         else if (imapAction == nsIImapUrl::nsImapOnlineCopy)</span>
<a href="#l20.6745"></a><span id="l20.6745" class="difflineminus">-          notifier-&gt;NotifyMsgsMoveCopyCompleted(false, m_copyState-&gt;m_messages, this, nullptr);</span>
<a href="#l20.6746"></a><span id="l20.6746" class="difflineplus">+          notifier-&gt;NotifyMsgsMoveCopyCompleted(false, m_copyState-&gt;m_messages,</span>
<a href="#l20.6747"></a><span id="l20.6747" class="difflineplus">+                                                this, nullptr);</span>
<a href="#l20.6748"></a><span id="l20.6748">         else if (imapAction == nsIImapUrl::nsImapDeleteMsg)</span>
<a href="#l20.6749"></a><span id="l20.6749">           notifier-&gt;NotifyMsgsDeleted(m_copyState-&gt;m_messages);</span>
<a href="#l20.6750"></a><span id="l20.6750">       }</span>
<a href="#l20.6751"></a><span id="l20.6751"> </span>
<a href="#l20.6752"></a><span id="l20.6752" class="difflineminus">-      switch(imapAction)</span>
<a href="#l20.6753"></a><span id="l20.6753" class="difflineminus">-      {</span>
<a href="#l20.6754"></a><span id="l20.6754" class="difflineminus">-      case nsIImapUrl::nsImapDeleteMsg:</span>
<a href="#l20.6755"></a><span id="l20.6755" class="difflineminus">-      case nsIImapUrl::nsImapOnlineMove:</span>
<a href="#l20.6756"></a><span id="l20.6756" class="difflineminus">-      case nsIImapUrl::nsImapOnlineCopy:</span>
<a href="#l20.6757"></a><span id="l20.6757" class="difflineminus">-        if (NS_SUCCEEDED(aExitCode))</span>
<a href="#l20.6758"></a><span id="l20.6758" class="difflineminus">-        {</span>
<a href="#l20.6759"></a><span id="l20.6759" class="difflineminus">-          if (folderOpen)</span>
<a href="#l20.6760"></a><span id="l20.6760" class="difflineminus">-            UpdateFolder(msgWindow);</span>
<a href="#l20.6761"></a><span id="l20.6761" class="difflineminus">-          else</span>
<a href="#l20.6762"></a><span id="l20.6762" class="difflineminus">-            UpdatePendingCounts();</span>
<a href="#l20.6763"></a><span id="l20.6763" class="difflineminus">-        }</span>
<a href="#l20.6764"></a><span id="l20.6764" class="difflineminus">-</span>
<a href="#l20.6765"></a><span id="l20.6765" class="difflineminus">-        if (m_copyState)</span>
<a href="#l20.6766"></a><span id="l20.6766" class="difflineminus">-        {</span>
<a href="#l20.6767"></a><span id="l20.6767" class="difflineminus">-          nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder = do_QueryInterface(m_copyState-&gt;m_srcSupport, &amp;rv);</span>
<a href="#l20.6768"></a><span id="l20.6768" class="difflineminus">-          if (m_copyState-&gt;m_isMove &amp;&amp; !m_copyState-&gt;m_isCrossServerOp)</span>
<a href="#l20.6769"></a><span id="l20.6769" class="difflineminus">-          {</span>
<a href="#l20.6770"></a><span id="l20.6770" class="difflineminus">-            if (NS_SUCCEEDED(aExitCode))</span>
<a href="#l20.6771"></a><span id="l20.6771" class="difflineminus">-            {</span>
<a href="#l20.6772"></a><span id="l20.6772" class="difflineminus">-              nsCOMPtr&lt;nsIMsgDatabase&gt; srcDB;</span>
<a href="#l20.6773"></a><span id="l20.6773" class="difflineminus">-              if (srcFolder)</span>
<a href="#l20.6774"></a><span id="l20.6774" class="difflineplus">+      switch (imapAction) {</span>
<a href="#l20.6775"></a><span id="l20.6775" class="difflineplus">+        case nsIImapUrl::nsImapDeleteMsg:</span>
<a href="#l20.6776"></a><span id="l20.6776" class="difflineplus">+        case nsIImapUrl::nsImapOnlineMove:</span>
<a href="#l20.6777"></a><span id="l20.6777" class="difflineplus">+        case nsIImapUrl::nsImapOnlineCopy:</span>
<a href="#l20.6778"></a><span id="l20.6778" class="difflineplus">+          if (NS_SUCCEEDED(aExitCode)) {</span>
<a href="#l20.6779"></a><span id="l20.6779" class="difflineplus">+            if (folderOpen)</span>
<a href="#l20.6780"></a><span id="l20.6780" class="difflineplus">+              UpdateFolder(msgWindow);</span>
<a href="#l20.6781"></a><span id="l20.6781" class="difflineplus">+            else</span>
<a href="#l20.6782"></a><span id="l20.6782" class="difflineplus">+              UpdatePendingCounts();</span>
<a href="#l20.6783"></a><span id="l20.6783" class="difflineplus">+          }</span>
<a href="#l20.6784"></a><span id="l20.6784" class="difflineplus">+</span>
<a href="#l20.6785"></a><span id="l20.6785" class="difflineplus">+          if (m_copyState) {</span>
<a href="#l20.6786"></a><span id="l20.6786" class="difflineplus">+            nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder =</span>
<a href="#l20.6787"></a><span id="l20.6787" class="difflineplus">+                do_QueryInterface(m_copyState-&gt;m_srcSupport, &amp;rv);</span>
<a href="#l20.6788"></a><span id="l20.6788" class="difflineplus">+            if (m_copyState-&gt;m_isMove &amp;&amp; !m_copyState-&gt;m_isCrossServerOp) {</span>
<a href="#l20.6789"></a><span id="l20.6789" class="difflineplus">+              if (NS_SUCCEEDED(aExitCode)) {</span>
<a href="#l20.6790"></a><span id="l20.6790" class="difflineplus">+                nsCOMPtr&lt;nsIMsgDatabase&gt; srcDB;</span>
<a href="#l20.6791"></a><span id="l20.6791" class="difflineplus">+                if (srcFolder)</span>
<a href="#l20.6792"></a><span id="l20.6792">                   rv = srcFolder-&gt;GetMsgDatabase(getter_AddRefs(srcDB));</span>
<a href="#l20.6793"></a><span id="l20.6793" class="difflineminus">-              if (NS_SUCCEEDED(rv) &amp;&amp; srcDB)</span>
<a href="#l20.6794"></a><span id="l20.6794" class="difflineminus">-              {</span>
<a href="#l20.6795"></a><span id="l20.6795" class="difflineminus">-                RefPtr&lt;nsImapMoveCopyMsgTxn&gt; msgTxn;</span>
<a href="#l20.6796"></a><span id="l20.6796" class="difflineminus">-                nsTArray&lt;nsMsgKey&gt; srcKeyArray;</span>
<a href="#l20.6797"></a><span id="l20.6797" class="difflineminus">-                if (m_copyState-&gt;m_allowUndo)</span>
<a href="#l20.6798"></a><span id="l20.6798" class="difflineminus">-                {</span>
<a href="#l20.6799"></a><span id="l20.6799" class="difflineminus">-                  msgTxn = m_copyState-&gt;m_undoMsgTxn;</span>
<a href="#l20.6800"></a><span id="l20.6800" class="difflineminus">-                  if (msgTxn)</span>
<a href="#l20.6801"></a><span id="l20.6801" class="difflineminus">-                    msgTxn-&gt;GetSrcKeyArray(srcKeyArray);</span>
<a href="#l20.6802"></a><span id="l20.6802" class="difflineplus">+                if (NS_SUCCEEDED(rv) &amp;&amp; srcDB) {</span>
<a href="#l20.6803"></a><span id="l20.6803" class="difflineplus">+                  RefPtr&lt;nsImapMoveCopyMsgTxn&gt; msgTxn;</span>
<a href="#l20.6804"></a><span id="l20.6804" class="difflineplus">+                  nsTArray&lt;nsMsgKey&gt; srcKeyArray;</span>
<a href="#l20.6805"></a><span id="l20.6805" class="difflineplus">+                  if (m_copyState-&gt;m_allowUndo) {</span>
<a href="#l20.6806"></a><span id="l20.6806" class="difflineplus">+                    msgTxn = m_copyState-&gt;m_undoMsgTxn;</span>
<a href="#l20.6807"></a><span id="l20.6807" class="difflineplus">+                    if (msgTxn) msgTxn-&gt;GetSrcKeyArray(srcKeyArray);</span>
<a href="#l20.6808"></a><span id="l20.6808" class="difflineplus">+                  } else {</span>
<a href="#l20.6809"></a><span id="l20.6809" class="difflineplus">+                    nsAutoCString messageIds;</span>
<a href="#l20.6810"></a><span id="l20.6810" class="difflineplus">+                    rv = BuildIdsAndKeyArray(m_copyState-&gt;m_messages,</span>
<a href="#l20.6811"></a><span id="l20.6811" class="difflineplus">+                                             messageIds, srcKeyArray);</span>
<a href="#l20.6812"></a><span id="l20.6812" class="difflineplus">+                    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.6813"></a><span id="l20.6813" class="difflineplus">+                  }</span>
<a href="#l20.6814"></a><span id="l20.6814" class="difflineplus">+</span>
<a href="#l20.6815"></a><span id="l20.6815" class="difflineplus">+                  if (!ShowDeletedMessages()) {</span>
<a href="#l20.6816"></a><span id="l20.6816" class="difflineplus">+                    // We only reach here for same-server operations</span>
<a href="#l20.6817"></a><span id="l20.6817" class="difflineplus">+                    // (!m_copyState-&gt;m_isCrossServerOp in if above), so we can</span>
<a href="#l20.6818"></a><span id="l20.6818" class="difflineplus">+                    // assume that the src is also imap that uses offline</span>
<a href="#l20.6819"></a><span id="l20.6819" class="difflineplus">+                    // storage.</span>
<a href="#l20.6820"></a><span id="l20.6820" class="difflineplus">+                    DeleteStoreMessages(srcKeyArray, srcFolder);</span>
<a href="#l20.6821"></a><span id="l20.6821" class="difflineplus">+                    srcDB-&gt;DeleteMessages(srcKeyArray.Length(),</span>
<a href="#l20.6822"></a><span id="l20.6822" class="difflineplus">+                                          srcKeyArray.Elements(), nullptr);</span>
<a href="#l20.6823"></a><span id="l20.6823" class="difflineplus">+                  } else</span>
<a href="#l20.6824"></a><span id="l20.6824" class="difflineplus">+                    MarkMessagesImapDeleted(&amp;srcKeyArray, true, srcDB);</span>
<a href="#l20.6825"></a><span id="l20.6825">                 }</span>
<a href="#l20.6826"></a><span id="l20.6826" class="difflineminus">-                else</span>
<a href="#l20.6827"></a><span id="l20.6827" class="difflineminus">-                {</span>
<a href="#l20.6828"></a><span id="l20.6828" class="difflineminus">-                  nsAutoCString messageIds;</span>
<a href="#l20.6829"></a><span id="l20.6829" class="difflineminus">-                  rv = BuildIdsAndKeyArray(m_copyState-&gt;m_messages, messageIds, srcKeyArray);</span>
<a href="#l20.6830"></a><span id="l20.6830" class="difflineminus">-                  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.6831"></a><span id="l20.6831" class="difflineminus">-                }</span>
<a href="#l20.6832"></a><span id="l20.6832" class="difflineminus">-</span>
<a href="#l20.6833"></a><span id="l20.6833" class="difflineminus">-                if (!ShowDeletedMessages())</span>
<a href="#l20.6834"></a><span id="l20.6834" class="difflineminus">-                {</span>
<a href="#l20.6835"></a><span id="l20.6835" class="difflineminus">-                  // We only reach here for same-server operations</span>
<a href="#l20.6836"></a><span id="l20.6836" class="difflineminus">-                  // (!m_copyState-&gt;m_isCrossServerOp in if above), so we can</span>
<a href="#l20.6837"></a><span id="l20.6837" class="difflineminus">-                  // assume that the src is also imap that uses offline storage.</span>
<a href="#l20.6838"></a><span id="l20.6838" class="difflineminus">-                  DeleteStoreMessages(srcKeyArray, srcFolder);</span>
<a href="#l20.6839"></a><span id="l20.6839" class="difflineminus">-                  srcDB-&gt;DeleteMessages(srcKeyArray.Length(), srcKeyArray.Elements(), nullptr);</span>
<a href="#l20.6840"></a><span id="l20.6840" class="difflineplus">+                srcFolder-&gt;EnableNotifications(allMessageCountNotifications,</span>
<a href="#l20.6841"></a><span id="l20.6841" class="difflineplus">+                                               true);</span>
<a href="#l20.6842"></a><span id="l20.6842" class="difflineplus">+                // even if we're showing deleted messages,</span>
<a href="#l20.6843"></a><span id="l20.6843" class="difflineplus">+                // we still need to notify FE so it will show the imap deleted</span>
<a href="#l20.6844"></a><span id="l20.6844" class="difflineplus">+                // flag</span>
<a href="#l20.6845"></a><span id="l20.6845" class="difflineplus">+                srcFolder-&gt;NotifyFolderEvent(kDeleteOrMoveMsgCompleted);</span>
<a href="#l20.6846"></a><span id="l20.6846" class="difflineplus">+                // is there a way to see that we think we have new msgs?</span>
<a href="#l20.6847"></a><span id="l20.6847" class="difflineplus">+                nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(</span>
<a href="#l20.6848"></a><span id="l20.6848" class="difflineplus">+                    do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l20.6849"></a><span id="l20.6849" class="difflineplus">+                if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.6850"></a><span id="l20.6850" class="difflineplus">+                  bool showPreviewText;</span>
<a href="#l20.6851"></a><span id="l20.6851" class="difflineplus">+                  prefBranch-&gt;GetBoolPref(&quot;mail.biff.alert.show_preview&quot;,</span>
<a href="#l20.6852"></a><span id="l20.6852" class="difflineplus">+                                          &amp;showPreviewText);</span>
<a href="#l20.6853"></a><span id="l20.6853" class="difflineplus">+                  // if we're showing preview text, update ourselves if we got a</span>
<a href="#l20.6854"></a><span id="l20.6854" class="difflineplus">+                  // new unread message copied so that we can download the new</span>
<a href="#l20.6855"></a><span id="l20.6855" class="difflineplus">+                  // headers and have a chance to preview the msg bodies.</span>
<a href="#l20.6856"></a><span id="l20.6856" class="difflineplus">+                  if (!folderOpen &amp;&amp; showPreviewText &amp;&amp;</span>
<a href="#l20.6857"></a><span id="l20.6857" class="difflineplus">+                      m_copyState-&gt;m_unreadCount &gt; 0 &amp;&amp;</span>
<a href="#l20.6858"></a><span id="l20.6858" class="difflineplus">+                      !(mFlags &amp;</span>
<a href="#l20.6859"></a><span id="l20.6859" class="difflineplus">+                        (nsMsgFolderFlags::Trash | nsMsgFolderFlags::Junk)))</span>
<a href="#l20.6860"></a><span id="l20.6860" class="difflineplus">+                    UpdateFolder(msgWindow);</span>
<a href="#l20.6861"></a><span id="l20.6861">                 }</span>
<a href="#l20.6862"></a><span id="l20.6862" class="difflineminus">-                else</span>
<a href="#l20.6863"></a><span id="l20.6863" class="difflineminus">-                  MarkMessagesImapDeleted(&amp;srcKeyArray, true, srcDB);</span>
<a href="#l20.6864"></a><span id="l20.6864" class="difflineminus">-              }</span>
<a href="#l20.6865"></a><span id="l20.6865" class="difflineminus">-              srcFolder-&gt;EnableNotifications(allMessageCountNotifications, true);</span>
<a href="#l20.6866"></a><span id="l20.6866" class="difflineminus">-              // even if we're showing deleted messages,</span>
<a href="#l20.6867"></a><span id="l20.6867" class="difflineminus">-              // we still need to notify FE so it will show the imap deleted flag</span>
<a href="#l20.6868"></a><span id="l20.6868" class="difflineminus">-              srcFolder-&gt;NotifyFolderEvent(kDeleteOrMoveMsgCompleted);</span>
<a href="#l20.6869"></a><span id="l20.6869" class="difflineminus">-              // is there a way to see that we think we have new msgs?</span>
<a href="#l20.6870"></a><span id="l20.6870" class="difflineminus">-              nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l20.6871"></a><span id="l20.6871" class="difflineminus">-              if (NS_SUCCEEDED(rv))</span>
<a href="#l20.6872"></a><span id="l20.6872" class="difflineminus">-              {</span>
<a href="#l20.6873"></a><span id="l20.6873" class="difflineminus">-                bool showPreviewText;</span>
<a href="#l20.6874"></a><span id="l20.6874" class="difflineminus">-                prefBranch-&gt;GetBoolPref(&quot;mail.biff.alert.show_preview&quot;, &amp;showPreviewText);</span>
<a href="#l20.6875"></a><span id="l20.6875" class="difflineminus">-                // if we're showing preview text, update ourselves if we got a new unread</span>
<a href="#l20.6876"></a><span id="l20.6876" class="difflineminus">-                // message copied so that we can download the new headers and have a chance</span>
<a href="#l20.6877"></a><span id="l20.6877" class="difflineminus">-                // to preview the msg bodies.</span>
<a href="#l20.6878"></a><span id="l20.6878" class="difflineminus">-                if (!folderOpen &amp;&amp; showPreviewText &amp;&amp; m_copyState-&gt;m_unreadCount &gt; 0</span>
<a href="#l20.6879"></a><span id="l20.6879" class="difflineminus">-                    &amp;&amp; ! (mFlags &amp; (nsMsgFolderFlags::Trash | nsMsgFolderFlags::Junk)))</span>
<a href="#l20.6880"></a><span id="l20.6880" class="difflineminus">-                  UpdateFolder(msgWindow);</span>
<a href="#l20.6881"></a><span id="l20.6881" class="difflineplus">+              } else {</span>
<a href="#l20.6882"></a><span id="l20.6882" class="difflineplus">+                srcFolder-&gt;EnableNotifications(allMessageCountNotifications,</span>
<a href="#l20.6883"></a><span id="l20.6883" class="difflineplus">+                                               true);</span>
<a href="#l20.6884"></a><span id="l20.6884" class="difflineplus">+                srcFolder-&gt;NotifyFolderEvent(kDeleteOrMoveMsgFailed);</span>
<a href="#l20.6885"></a><span id="l20.6885">               }</span>
<a href="#l20.6886"></a><span id="l20.6886">             }</span>
<a href="#l20.6887"></a><span id="l20.6887" class="difflineminus">-            else</span>
<a href="#l20.6888"></a><span id="l20.6888" class="difflineminus">-            {</span>
<a href="#l20.6889"></a><span id="l20.6889" class="difflineminus">-              srcFolder-&gt;EnableNotifications(allMessageCountNotifications, true);</span>
<a href="#l20.6890"></a><span id="l20.6890" class="difflineminus">-              srcFolder-&gt;NotifyFolderEvent(kDeleteOrMoveMsgFailed);</span>
<a href="#l20.6891"></a><span id="l20.6891" class="difflineminus">-            }</span>
<a href="#l20.6892"></a><span id="l20.6892" class="difflineminus">-</span>
<a href="#l20.6893"></a><span id="l20.6893" class="difflineminus">-          }</span>
<a href="#l20.6894"></a><span id="l20.6894" class="difflineminus">-          if (m_copyState-&gt;m_msgWindow &amp;&amp;</span>
<a href="#l20.6895"></a><span id="l20.6895" class="difflineminus">-              m_copyState-&gt;m_undoMsgTxn &amp;&amp;  // may be null from filters</span>
<a href="#l20.6896"></a><span id="l20.6896" class="difflineminus">-              NS_SUCCEEDED(aExitCode))      //we should do this only if move/copy succeeds</span>
<a href="#l20.6897"></a><span id="l20.6897" class="difflineminus">-          {</span>
<a href="#l20.6898"></a><span id="l20.6898" class="difflineminus">-            nsCOMPtr&lt;nsITransactionManager&gt; txnMgr;</span>
<a href="#l20.6899"></a><span id="l20.6899" class="difflineminus">-            m_copyState-&gt;m_msgWindow-&gt;GetTransactionManager(getter_AddRefs(txnMgr));</span>
<a href="#l20.6900"></a><span id="l20.6900" class="difflineminus">-            if (txnMgr)</span>
<a href="#l20.6901"></a><span id="l20.6901" class="difflineplus">+            if (m_copyState-&gt;m_msgWindow &amp;&amp;</span>
<a href="#l20.6902"></a><span id="l20.6902" class="difflineplus">+                m_copyState-&gt;m_undoMsgTxn &amp;&amp;  // may be null from filters</span>
<a href="#l20.6903"></a><span id="l20.6903" class="difflineplus">+                NS_SUCCEEDED(</span>
<a href="#l20.6904"></a><span id="l20.6904" class="difflineplus">+                    aExitCode))  // we should do this only if move/copy succeeds</span>
<a href="#l20.6905"></a><span id="l20.6905">             {</span>
<a href="#l20.6906"></a><span id="l20.6906" class="difflineminus">-              mozilla::DebugOnly&lt;nsresult&gt; rv2 = txnMgr-&gt;DoTransaction(m_copyState-&gt;m_undoMsgTxn);</span>
<a href="#l20.6907"></a><span id="l20.6907" class="difflineminus">-              NS_ASSERTION(NS_SUCCEEDED(rv2), &quot;doing transaction failed&quot;);</span>
<a href="#l20.6908"></a><span id="l20.6908" class="difflineplus">+              nsCOMPtr&lt;nsITransactionManager&gt; txnMgr;</span>
<a href="#l20.6909"></a><span id="l20.6909" class="difflineplus">+              m_copyState-&gt;m_msgWindow-&gt;GetTransactionManager(</span>
<a href="#l20.6910"></a><span id="l20.6910" class="difflineplus">+                  getter_AddRefs(txnMgr));</span>
<a href="#l20.6911"></a><span id="l20.6911" class="difflineplus">+              if (txnMgr) {</span>
<a href="#l20.6912"></a><span id="l20.6912" class="difflineplus">+                mozilla::DebugOnly&lt;nsresult&gt; rv2 =</span>
<a href="#l20.6913"></a><span id="l20.6913" class="difflineplus">+                    txnMgr-&gt;DoTransaction(m_copyState-&gt;m_undoMsgTxn);</span>
<a href="#l20.6914"></a><span id="l20.6914" class="difflineplus">+                NS_ASSERTION(NS_SUCCEEDED(rv2), &quot;doing transaction failed&quot;);</span>
<a href="#l20.6915"></a><span id="l20.6915" class="difflineplus">+              }</span>
<a href="#l20.6916"></a><span id="l20.6916">             }</span>
<a href="#l20.6917"></a><span id="l20.6917" class="difflineplus">+            (void)OnCopyCompleted(m_copyState-&gt;m_srcSupport, aExitCode);</span>
<a href="#l20.6918"></a><span id="l20.6918">           }</span>
<a href="#l20.6919"></a><span id="l20.6919" class="difflineminus">-          (void) OnCopyCompleted(m_copyState-&gt;m_srcSupport, aExitCode);</span>
<a href="#l20.6920"></a><span id="l20.6920" class="difflineminus">-        }</span>
<a href="#l20.6921"></a><span id="l20.6921" class="difflineminus">-</span>
<a href="#l20.6922"></a><span id="l20.6922" class="difflineminus">-        // we're the dest folder of a move/copy - if we're not open in the ui,</span>
<a href="#l20.6923"></a><span id="l20.6923" class="difflineminus">-        // then we should clear our nsMsgDatabase pointer. Otherwise, the db would</span>
<a href="#l20.6924"></a><span id="l20.6924" class="difflineminus">-        // be open until the user selected it and then selected another folder.</span>
<a href="#l20.6925"></a><span id="l20.6925" class="difflineminus">-        // but don't do this for the trash or inbox - we'll leave them open</span>
<a href="#l20.6926"></a><span id="l20.6926" class="difflineminus">-        if (!folderOpen &amp;&amp; ! (mFlags &amp; (nsMsgFolderFlags::Trash | nsMsgFolderFlags::Inbox)))</span>
<a href="#l20.6927"></a><span id="l20.6927" class="difflineminus">-          SetMsgDatabase(nullptr);</span>
<a href="#l20.6928"></a><span id="l20.6928" class="difflineminus">-        break;</span>
<a href="#l20.6929"></a><span id="l20.6929" class="difflineminus">-      case nsIImapUrl::nsImapSubtractMsgFlags:</span>
<a href="#l20.6930"></a><span id="l20.6930" class="difflineminus">-        {</span>
<a href="#l20.6931"></a><span id="l20.6931" class="difflineminus">-        // this isn't really right - we'd like to know we were</span>
<a href="#l20.6932"></a><span id="l20.6932" class="difflineminus">-        // deleting a message to start with, but it probably</span>
<a href="#l20.6933"></a><span id="l20.6933" class="difflineminus">-        // won't do any harm.</span>
<a href="#l20.6934"></a><span id="l20.6934" class="difflineplus">+</span>
<a href="#l20.6935"></a><span id="l20.6935" class="difflineplus">+          // we're the dest folder of a move/copy - if we're not open in the ui,</span>
<a href="#l20.6936"></a><span id="l20.6936" class="difflineplus">+          // then we should clear our nsMsgDatabase pointer. Otherwise, the db</span>
<a href="#l20.6937"></a><span id="l20.6937" class="difflineplus">+          // would be open until the user selected it and then selected another</span>
<a href="#l20.6938"></a><span id="l20.6938" class="difflineplus">+          // folder. but don't do this for the trash or inbox - we'll leave them</span>
<a href="#l20.6939"></a><span id="l20.6939" class="difflineplus">+          // open</span>
<a href="#l20.6940"></a><span id="l20.6940" class="difflineplus">+          if (!folderOpen &amp;&amp;</span>
<a href="#l20.6941"></a><span id="l20.6941" class="difflineplus">+              !(mFlags &amp; (nsMsgFolderFlags::Trash | nsMsgFolderFlags::Inbox)))</span>
<a href="#l20.6942"></a><span id="l20.6942" class="difflineplus">+            SetMsgDatabase(nullptr);</span>
<a href="#l20.6943"></a><span id="l20.6943" class="difflineplus">+          break;</span>
<a href="#l20.6944"></a><span id="l20.6944" class="difflineplus">+        case nsIImapUrl::nsImapSubtractMsgFlags: {</span>
<a href="#l20.6945"></a><span id="l20.6945" class="difflineplus">+          // this isn't really right - we'd like to know we were</span>
<a href="#l20.6946"></a><span id="l20.6946" class="difflineplus">+          // deleting a message to start with, but it probably</span>
<a href="#l20.6947"></a><span id="l20.6947" class="difflineplus">+          // won't do any harm.</span>
<a href="#l20.6948"></a><span id="l20.6948">           imapMessageFlagsType flags = 0;</span>
<a href="#l20.6949"></a><span id="l20.6949">           imapUrl-&gt;GetMsgFlags(&amp;flags);</span>
<a href="#l20.6950"></a><span id="l20.6950" class="difflineminus">-          //we need to subtract the delete flag in db only in case when we show deleted msgs</span>
<a href="#l20.6951"></a><span id="l20.6951" class="difflineminus">-          if (flags &amp; kImapMsgDeletedFlag &amp;&amp; ShowDeletedMessages())</span>
<a href="#l20.6952"></a><span id="l20.6952" class="difflineminus">-          {</span>
<a href="#l20.6953"></a><span id="l20.6953" class="difflineplus">+          // we need to subtract the delete flag in db only in case when we show</span>
<a href="#l20.6954"></a><span id="l20.6954" class="difflineplus">+          // deleted msgs</span>
<a href="#l20.6955"></a><span id="l20.6955" class="difflineplus">+          if (flags &amp; kImapMsgDeletedFlag &amp;&amp; ShowDeletedMessages()) {</span>
<a href="#l20.6956"></a><span id="l20.6956">             nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l20.6957"></a><span id="l20.6957">             rv = GetMsgDatabase(getter_AddRefs(db));</span>
<a href="#l20.6958"></a><span id="l20.6958" class="difflineminus">-            if (NS_SUCCEEDED(rv) &amp;&amp; db)</span>
<a href="#l20.6959"></a><span id="l20.6959" class="difflineminus">-            {</span>
<a href="#l20.6960"></a><span id="l20.6960" class="difflineplus">+            if (NS_SUCCEEDED(rv) &amp;&amp; db) {</span>
<a href="#l20.6961"></a><span id="l20.6961">               nsTArray&lt;nsMsgKey&gt; keyArray;</span>
<a href="#l20.6962"></a><span id="l20.6962">               nsCString keyString;</span>
<a href="#l20.6963"></a><span id="l20.6963">               imapUrl-&gt;GetListOfMessageIds(keyString);</span>
<a href="#l20.6964"></a><span id="l20.6964">               ParseUidString(keyString.get(), keyArray);</span>
<a href="#l20.6965"></a><span id="l20.6965">               MarkMessagesImapDeleted(&amp;keyArray, false, db);</span>
<a href="#l20.6966"></a><span id="l20.6966">               db-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.6967"></a><span id="l20.6967">             }</span>
<a href="#l20.6968"></a><span id="l20.6968">           }</span>
<a href="#l20.6969"></a><span id="l20.6969" class="difflineminus">-        }</span>
<a href="#l20.6970"></a><span id="l20.6970" class="difflineminus">-        break;</span>
<a href="#l20.6971"></a><span id="l20.6971" class="difflineminus">-      case nsIImapUrl::nsImapAddMsgFlags:</span>
<a href="#l20.6972"></a><span id="l20.6972" class="difflineminus">-        {</span>
<a href="#l20.6973"></a><span id="l20.6973" class="difflineplus">+        } break;</span>
<a href="#l20.6974"></a><span id="l20.6974" class="difflineplus">+        case nsIImapUrl::nsImapAddMsgFlags: {</span>
<a href="#l20.6975"></a><span id="l20.6975">           imapMessageFlagsType flags = 0;</span>
<a href="#l20.6976"></a><span id="l20.6976">           imapUrl-&gt;GetMsgFlags(&amp;flags);</span>
<a href="#l20.6977"></a><span id="l20.6977" class="difflineminus">-          if (flags &amp; kImapMsgDeletedFlag)</span>
<a href="#l20.6978"></a><span id="l20.6978" class="difflineminus">-          {</span>
<a href="#l20.6979"></a><span id="l20.6979" class="difflineminus">-            // we need to delete headers from db only when we don't show deleted msgs</span>
<a href="#l20.6980"></a><span id="l20.6980" class="difflineminus">-            if (!ShowDeletedMessages())</span>
<a href="#l20.6981"></a><span id="l20.6981" class="difflineminus">-            {</span>
<a href="#l20.6982"></a><span id="l20.6982" class="difflineplus">+          if (flags &amp; kImapMsgDeletedFlag) {</span>
<a href="#l20.6983"></a><span id="l20.6983" class="difflineplus">+            // we need to delete headers from db only when we don't show deleted</span>
<a href="#l20.6984"></a><span id="l20.6984" class="difflineplus">+            // msgs</span>
<a href="#l20.6985"></a><span id="l20.6985" class="difflineplus">+            if (!ShowDeletedMessages()) {</span>
<a href="#l20.6986"></a><span id="l20.6986">               nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l20.6987"></a><span id="l20.6987">               rv = GetMsgDatabase(getter_AddRefs(db));</span>
<a href="#l20.6988"></a><span id="l20.6988" class="difflineminus">-              if (NS_SUCCEEDED(rv) &amp;&amp; db)</span>
<a href="#l20.6989"></a><span id="l20.6989" class="difflineminus">-              {</span>
<a href="#l20.6990"></a><span id="l20.6990" class="difflineplus">+              if (NS_SUCCEEDED(rv) &amp;&amp; db) {</span>
<a href="#l20.6991"></a><span id="l20.6991">                 nsTArray&lt;nsMsgKey&gt; keyArray;</span>
<a href="#l20.6992"></a><span id="l20.6992">                 nsCString keyString;</span>
<a href="#l20.6993"></a><span id="l20.6993">                 imapUrl-&gt;GetListOfMessageIds(keyString);</span>
<a href="#l20.6994"></a><span id="l20.6994">                 ParseUidString(keyString.get(), keyArray);</span>
<a href="#l20.6995"></a><span id="l20.6995"> </span>
<a href="#l20.6996"></a><span id="l20.6996">                 // For pluggable stores that do not support compaction, we need</span>
<a href="#l20.6997"></a><span id="l20.6997">                 // to delete the messages now.</span>
<a href="#l20.6998"></a><span id="l20.6998">                 bool supportsCompaction = false;</span>
<a href="#l20.6999"></a><span id="l20.6999">                 uint32_t numHdrs = 0;</span>
<a href="#l20.7000"></a><span id="l20.7000">                 nsCOMPtr&lt;nsIMsgPluggableStore&gt; offlineStore;</span>
<a href="#l20.7001"></a><span id="l20.7001" class="difflineminus">-                (void) GetMsgStore(getter_AddRefs(offlineStore));</span>
<a href="#l20.7002"></a><span id="l20.7002" class="difflineplus">+                (void)GetMsgStore(getter_AddRefs(offlineStore));</span>
<a href="#l20.7003"></a><span id="l20.7003">                 if (offlineStore)</span>
<a href="#l20.7004"></a><span id="l20.7004">                   offlineStore-&gt;GetSupportsCompaction(&amp;supportsCompaction);</span>
<a href="#l20.7005"></a><span id="l20.7005"> </span>
<a href="#l20.7006"></a><span id="l20.7006">                 nsCOMPtr&lt;nsIMutableArray&gt; msgHdrs;</span>
<a href="#l20.7007"></a><span id="l20.7007" class="difflineminus">-                if (notifier || !supportsCompaction)</span>
<a href="#l20.7008"></a><span id="l20.7008" class="difflineminus">-                {</span>
<a href="#l20.7009"></a><span id="l20.7009" class="difflineplus">+                if (notifier || !supportsCompaction) {</span>
<a href="#l20.7010"></a><span id="l20.7010">                   msgHdrs = do_CreateInstance(NS_ARRAY_CONTRACTID);</span>
<a href="#l20.7011"></a><span id="l20.7011">                   NS_ENSURE_STATE(msgHdrs);</span>
<a href="#l20.7012"></a><span id="l20.7012">                   MsgGetHeadersFromKeys(db, keyArray, msgHdrs);</span>
<a href="#l20.7013"></a><span id="l20.7013">                   msgHdrs-&gt;GetLength(&amp;numHdrs);</span>
<a href="#l20.7014"></a><span id="l20.7014">                 }</span>
<a href="#l20.7015"></a><span id="l20.7015"> </span>
<a href="#l20.7016"></a><span id="l20.7016">                 // Notify listeners of delete.</span>
<a href="#l20.7017"></a><span id="l20.7017" class="difflineminus">-                if (notifier &amp;&amp; numHdrs)</span>
<a href="#l20.7018"></a><span id="l20.7018" class="difflineminus">-                {</span>
<a href="#l20.7019"></a><span id="l20.7019" class="difflineminus">-                  // XXX Currently, the DeleteMessages below gets executed twice on deletes.</span>
<a href="#l20.7020"></a><span id="l20.7020" class="difflineminus">-                  // Once in DeleteMessages, once here. The second time, it silently fails</span>
<a href="#l20.7021"></a><span id="l20.7021" class="difflineminus">-                  // to delete. This is why we're also checking whether the array is empty.</span>
<a href="#l20.7022"></a><span id="l20.7022" class="difflineplus">+                if (notifier &amp;&amp; numHdrs) {</span>
<a href="#l20.7023"></a><span id="l20.7023" class="difflineplus">+                  // XXX Currently, the DeleteMessages below gets executed twice</span>
<a href="#l20.7024"></a><span id="l20.7024" class="difflineplus">+                  // on deletes. Once in DeleteMessages, once here. The second</span>
<a href="#l20.7025"></a><span id="l20.7025" class="difflineplus">+                  // time, it silently fails to delete. This is why we're also</span>
<a href="#l20.7026"></a><span id="l20.7026" class="difflineplus">+                  // checking whether the array is empty.</span>
<a href="#l20.7027"></a><span id="l20.7027">                   notifier-&gt;NotifyMsgsDeleted(msgHdrs);</span>
<a href="#l20.7028"></a><span id="l20.7028">                 }</span>
<a href="#l20.7029"></a><span id="l20.7029"> </span>
<a href="#l20.7030"></a><span id="l20.7030">                 if (!supportsCompaction &amp;&amp; numHdrs)</span>
<a href="#l20.7031"></a><span id="l20.7031">                   DeleteStoreMessages(msgHdrs);</span>
<a href="#l20.7032"></a><span id="l20.7032"> </span>
<a href="#l20.7033"></a><span id="l20.7033" class="difflineminus">-                db-&gt;DeleteMessages(keyArray.Length(), keyArray.Elements(), nullptr);</span>
<a href="#l20.7034"></a><span id="l20.7034" class="difflineplus">+                db-&gt;DeleteMessages(keyArray.Length(), keyArray.Elements(),</span>
<a href="#l20.7035"></a><span id="l20.7035" class="difflineplus">+                                   nullptr);</span>
<a href="#l20.7036"></a><span id="l20.7036">                 db-&gt;SetSummaryValid(true);</span>
<a href="#l20.7037"></a><span id="l20.7037">                 db-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.7038"></a><span id="l20.7038">               }</span>
<a href="#l20.7039"></a><span id="l20.7039">             }</span>
<a href="#l20.7040"></a><span id="l20.7040">           }</span>
<a href="#l20.7041"></a><span id="l20.7041" class="difflineminus">-        }</span>
<a href="#l20.7042"></a><span id="l20.7042" class="difflineminus">-        break;</span>
<a href="#l20.7043"></a><span id="l20.7043" class="difflineminus">-      case nsIImapUrl::nsImapAppendMsgFromFile:</span>
<a href="#l20.7044"></a><span id="l20.7044" class="difflineminus">-      case nsIImapUrl::nsImapAppendDraftFromFile:</span>
<a href="#l20.7045"></a><span id="l20.7045" class="difflineminus">-          if (m_copyState)</span>
<a href="#l20.7046"></a><span id="l20.7046" class="difflineminus">-          {</span>
<a href="#l20.7047"></a><span id="l20.7047" class="difflineminus">-            if (NS_SUCCEEDED(aExitCode))</span>
<a href="#l20.7048"></a><span id="l20.7048" class="difflineminus">-            {</span>
<a href="#l20.7049"></a><span id="l20.7049" class="difflineplus">+        } break;</span>
<a href="#l20.7050"></a><span id="l20.7050" class="difflineplus">+        case nsIImapUrl::nsImapAppendMsgFromFile:</span>
<a href="#l20.7051"></a><span id="l20.7051" class="difflineplus">+        case nsIImapUrl::nsImapAppendDraftFromFile:</span>
<a href="#l20.7052"></a><span id="l20.7052" class="difflineplus">+          if (m_copyState) {</span>
<a href="#l20.7053"></a><span id="l20.7053" class="difflineplus">+            if (NS_SUCCEEDED(aExitCode)) {</span>
<a href="#l20.7054"></a><span id="l20.7054">               UpdatePendingCounts();</span>
<a href="#l20.7055"></a><span id="l20.7055"> </span>
<a href="#l20.7056"></a><span id="l20.7056">               m_copyState-&gt;m_curIndex++;</span>
<a href="#l20.7057"></a><span id="l20.7057" class="difflineminus">-              if (m_copyState-&gt;m_curIndex &gt;= m_copyState-&gt;m_totalCount)</span>
<a href="#l20.7058"></a><span id="l20.7058" class="difflineminus">-              {</span>
<a href="#l20.7059"></a><span id="l20.7059" class="difflineplus">+              if (m_copyState-&gt;m_curIndex &gt;= m_copyState-&gt;m_totalCount) {</span>
<a href="#l20.7060"></a><span id="l20.7060">                 nsCOMPtr&lt;nsIUrlListener&gt; saveUrlListener = m_urlListener;</span>
<a href="#l20.7061"></a><span id="l20.7061" class="difflineminus">-                if (folderOpen)</span>
<a href="#l20.7062"></a><span id="l20.7062" class="difflineminus">-                {</span>
<a href="#l20.7063"></a><span id="l20.7063" class="difflineplus">+                if (folderOpen) {</span>
<a href="#l20.7064"></a><span id="l20.7064">                   // This gives a way for the caller to get notified</span>
<a href="#l20.7065"></a><span id="l20.7065">                   // when the UpdateFolder url is done.</span>
<a href="#l20.7066"></a><span id="l20.7066">                   if (m_copyState-&gt;m_listener)</span>
<a href="#l20.7067"></a><span id="l20.7067">                     m_urlListener = do_QueryInterface(m_copyState-&gt;m_listener);</span>
<a href="#l20.7068"></a><span id="l20.7068">                 }</span>
<a href="#l20.7069"></a><span id="l20.7069" class="difflineminus">-                if (m_copyState-&gt;m_msgWindow &amp;&amp; m_copyState-&gt;m_undoMsgTxn)</span>
<a href="#l20.7070"></a><span id="l20.7070" class="difflineminus">-                {</span>
<a href="#l20.7071"></a><span id="l20.7071" class="difflineplus">+                if (m_copyState-&gt;m_msgWindow &amp;&amp; m_copyState-&gt;m_undoMsgTxn) {</span>
<a href="#l20.7072"></a><span id="l20.7072">                   nsCOMPtr&lt;nsITransactionManager&gt; txnMgr;</span>
<a href="#l20.7073"></a><span id="l20.7073" class="difflineminus">-                  m_copyState-&gt;m_msgWindow-&gt;GetTransactionManager(getter_AddRefs(txnMgr));</span>
<a href="#l20.7074"></a><span id="l20.7074" class="difflineminus">-                  if (txnMgr)</span>
<a href="#l20.7075"></a><span id="l20.7075" class="difflineminus">-                    txnMgr-&gt;DoTransaction(m_copyState-&gt;m_undoMsgTxn);</span>
<a href="#l20.7076"></a><span id="l20.7076" class="difflineplus">+                  m_copyState-&gt;m_msgWindow-&gt;GetTransactionManager(</span>
<a href="#l20.7077"></a><span id="l20.7077" class="difflineplus">+                      getter_AddRefs(txnMgr));</span>
<a href="#l20.7078"></a><span id="l20.7078" class="difflineplus">+                  if (txnMgr) txnMgr-&gt;DoTransaction(m_copyState-&gt;m_undoMsgTxn);</span>
<a href="#l20.7079"></a><span id="l20.7079">                 }</span>
<a href="#l20.7080"></a><span id="l20.7080" class="difflineminus">-                (void) OnCopyCompleted(m_copyState-&gt;m_srcSupport, aExitCode);</span>
<a href="#l20.7081"></a><span id="l20.7081" class="difflineplus">+                (void)OnCopyCompleted(m_copyState-&gt;m_srcSupport, aExitCode);</span>
<a href="#l20.7082"></a><span id="l20.7082">                 if (folderOpen ||</span>
<a href="#l20.7083"></a><span id="l20.7083" class="difflineminus">-                    imapAction == nsIImapUrl::nsImapAppendDraftFromFile)</span>
<a href="#l20.7084"></a><span id="l20.7084" class="difflineminus">-                {</span>
<a href="#l20.7085"></a><span id="l20.7085" class="difflineplus">+                    imapAction == nsIImapUrl::nsImapAppendDraftFromFile) {</span>
<a href="#l20.7086"></a><span id="l20.7086">                   UpdateFolderWithListener(msgWindow, m_urlListener);</span>
<a href="#l20.7087"></a><span id="l20.7087">                   m_urlListener = saveUrlListener;</span>
<a href="#l20.7088"></a><span id="l20.7088">                 }</span>
<a href="#l20.7089"></a><span id="l20.7089">               }</span>
<a href="#l20.7090"></a><span id="l20.7090" class="difflineminus">-            }</span>
<a href="#l20.7091"></a><span id="l20.7091" class="difflineminus">-            else</span>
<a href="#l20.7092"></a><span id="l20.7092" class="difflineminus">-              //clear the copyState if copy has failed</span>
<a href="#l20.7093"></a><span id="l20.7093" class="difflineminus">-              (void) OnCopyCompleted(m_copyState-&gt;m_srcSupport, aExitCode);</span>
<a href="#l20.7094"></a><span id="l20.7094" class="difflineplus">+            } else</span>
<a href="#l20.7095"></a><span id="l20.7095" class="difflineplus">+              // clear the copyState if copy has failed</span>
<a href="#l20.7096"></a><span id="l20.7096" class="difflineplus">+              (void)OnCopyCompleted(m_copyState-&gt;m_srcSupport, aExitCode);</span>
<a href="#l20.7097"></a><span id="l20.7097">           }</span>
<a href="#l20.7098"></a><span id="l20.7098">           break;</span>
<a href="#l20.7099"></a><span id="l20.7099" class="difflineminus">-      case nsIImapUrl::nsImapMoveFolderHierarchy:</span>
<a href="#l20.7100"></a><span id="l20.7100" class="difflineminus">-        if (m_copyState) // delete folder gets here, but w/o an m_copyState</span>
<a href="#l20.7101"></a><span id="l20.7101" class="difflineminus">-        {</span>
<a href="#l20.7102"></a><span id="l20.7102" class="difflineminus">-          nsCOMPtr&lt;nsIMsgCopyService&gt; copyService = do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.7103"></a><span id="l20.7103" class="difflineminus">-          NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.7104"></a><span id="l20.7104" class="difflineminus">-          nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder = do_QueryInterface(m_copyState-&gt;m_srcSupport);</span>
<a href="#l20.7105"></a><span id="l20.7105" class="difflineminus">-          if (srcFolder)</span>
<a href="#l20.7106"></a><span id="l20.7106" class="difflineplus">+        case nsIImapUrl::nsImapMoveFolderHierarchy:</span>
<a href="#l20.7107"></a><span id="l20.7107" class="difflineplus">+          if (m_copyState)  // delete folder gets here, but w/o an m_copyState</span>
<a href="#l20.7108"></a><span id="l20.7108">           {</span>
<a href="#l20.7109"></a><span id="l20.7109" class="difflineminus">-            copyService-&gt;NotifyCompletion(m_copyState-&gt;m_srcSupport, this, aExitCode);</span>
<a href="#l20.7110"></a><span id="l20.7110" class="difflineplus">+            nsCOMPtr&lt;nsIMsgCopyService&gt; copyService =</span>
<a href="#l20.7111"></a><span id="l20.7111" class="difflineplus">+                do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.7112"></a><span id="l20.7112" class="difflineplus">+            NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.7113"></a><span id="l20.7113" class="difflineplus">+            nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder =</span>
<a href="#l20.7114"></a><span id="l20.7114" class="difflineplus">+                do_QueryInterface(m_copyState-&gt;m_srcSupport);</span>
<a href="#l20.7115"></a><span id="l20.7115" class="difflineplus">+            if (srcFolder) {</span>
<a href="#l20.7116"></a><span id="l20.7116" class="difflineplus">+              copyService-&gt;NotifyCompletion(m_copyState-&gt;m_srcSupport, this,</span>
<a href="#l20.7117"></a><span id="l20.7117" class="difflineplus">+                                            aExitCode);</span>
<a href="#l20.7118"></a><span id="l20.7118" class="difflineplus">+            }</span>
<a href="#l20.7119"></a><span id="l20.7119" class="difflineplus">+            m_copyState = nullptr;</span>
<a href="#l20.7120"></a><span id="l20.7120">           }</span>
<a href="#l20.7121"></a><span id="l20.7121" class="difflineminus">-          m_copyState = nullptr;</span>
<a href="#l20.7122"></a><span id="l20.7122" class="difflineminus">-        }</span>
<a href="#l20.7123"></a><span id="l20.7123" class="difflineminus">-        break;</span>
<a href="#l20.7124"></a><span id="l20.7124" class="difflineminus">-      case nsIImapUrl::nsImapRenameFolder:</span>
<a href="#l20.7125"></a><span id="l20.7125" class="difflineminus">-        if (NS_FAILED(aExitCode))</span>
<a href="#l20.7126"></a><span id="l20.7126" class="difflineminus">-        {</span>
<a href="#l20.7127"></a><span id="l20.7127" class="difflineminus">-          NotifyFolderEvent(kRenameCompleted);</span>
<a href="#l20.7128"></a><span id="l20.7128" class="difflineminus">-        }</span>
<a href="#l20.7129"></a><span id="l20.7129" class="difflineminus">-        break;</span>
<a href="#l20.7130"></a><span id="l20.7130" class="difflineminus">-      case nsIImapUrl::nsImapDeleteAllMsgs:</span>
<a href="#l20.7131"></a><span id="l20.7131" class="difflineminus">-          if (NS_SUCCEEDED(aExitCode))</span>
<a href="#l20.7132"></a><span id="l20.7132" class="difflineminus">-          {</span>
<a href="#l20.7133"></a><span id="l20.7133" class="difflineplus">+          break;</span>
<a href="#l20.7134"></a><span id="l20.7134" class="difflineplus">+        case nsIImapUrl::nsImapRenameFolder:</span>
<a href="#l20.7135"></a><span id="l20.7135" class="difflineplus">+          if (NS_FAILED(aExitCode)) {</span>
<a href="#l20.7136"></a><span id="l20.7136" class="difflineplus">+            NotifyFolderEvent(kRenameCompleted);</span>
<a href="#l20.7137"></a><span id="l20.7137" class="difflineplus">+          }</span>
<a href="#l20.7138"></a><span id="l20.7138" class="difflineplus">+          break;</span>
<a href="#l20.7139"></a><span id="l20.7139" class="difflineplus">+        case nsIImapUrl::nsImapDeleteAllMsgs:</span>
<a href="#l20.7140"></a><span id="l20.7140" class="difflineplus">+          if (NS_SUCCEEDED(aExitCode)) {</span>
<a href="#l20.7141"></a><span id="l20.7141">             if (folderOpen)</span>
<a href="#l20.7142"></a><span id="l20.7142">               UpdateFolder(msgWindow);</span>
<a href="#l20.7143"></a><span id="l20.7143" class="difflineminus">-            else</span>
<a href="#l20.7144"></a><span id="l20.7144" class="difflineminus">-            {</span>
<a href="#l20.7145"></a><span id="l20.7145" class="difflineplus">+            else {</span>
<a href="#l20.7146"></a><span id="l20.7146">               ChangeNumPendingTotalMessages(-mNumPendingTotalMessages);</span>
<a href="#l20.7147"></a><span id="l20.7147">               ChangeNumPendingUnread(-mNumPendingUnreadMessages);</span>
<a href="#l20.7148"></a><span id="l20.7148">               m_numServerUnseenMessages = 0;</span>
<a href="#l20.7149"></a><span id="l20.7149">             }</span>
<a href="#l20.7150"></a><span id="l20.7150" class="difflineminus">-</span>
<a href="#l20.7151"></a><span id="l20.7151">           }</span>
<a href="#l20.7152"></a><span id="l20.7152">           break;</span>
<a href="#l20.7153"></a><span id="l20.7153" class="difflineminus">-      case nsIImapUrl::nsImapListFolder:</span>
<a href="#l20.7154"></a><span id="l20.7154" class="difflineminus">-          if (NS_SUCCEEDED(aExitCode))</span>
<a href="#l20.7155"></a><span id="l20.7155" class="difflineminus">-          {</span>
<a href="#l20.7156"></a><span id="l20.7156" class="difflineplus">+        case nsIImapUrl::nsImapListFolder:</span>
<a href="#l20.7157"></a><span id="l20.7157" class="difflineplus">+          if (NS_SUCCEEDED(aExitCode)) {</span>
<a href="#l20.7158"></a><span id="l20.7158">             // listing folder will open db; don't leave the db open.</span>
<a href="#l20.7159"></a><span id="l20.7159">             SetMsgDatabase(nullptr);</span>
<a href="#l20.7160"></a><span id="l20.7160" class="difflineminus">-            if (!m_verifiedAsOnlineFolder)</span>
<a href="#l20.7161"></a><span id="l20.7161" class="difflineminus">-            {</span>
<a href="#l20.7162"></a><span id="l20.7162" class="difflineplus">+            if (!m_verifiedAsOnlineFolder) {</span>
<a href="#l20.7163"></a><span id="l20.7163">               // If folder is not verified, we remove it.</span>
<a href="#l20.7164"></a><span id="l20.7164">               nsCOMPtr&lt;nsIMsgFolder&gt; parent;</span>
<a href="#l20.7165"></a><span id="l20.7165">               rv = GetParent(getter_AddRefs(parent));</span>
<a href="#l20.7166"></a><span id="l20.7166" class="difflineminus">-              if (NS_SUCCEEDED(rv) &amp;&amp; parent)</span>
<a href="#l20.7167"></a><span id="l20.7167" class="difflineminus">-              {</span>
<a href="#l20.7168"></a><span id="l20.7168" class="difflineminus">-                nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapParent = do_QueryInterface(parent);</span>
<a href="#l20.7169"></a><span id="l20.7169" class="difflineminus">-                if (imapParent)</span>
<a href="#l20.7170"></a><span id="l20.7170" class="difflineminus">-                  imapParent-&gt;RemoveSubFolder(this);</span>
<a href="#l20.7171"></a><span id="l20.7171" class="difflineplus">+              if (NS_SUCCEEDED(rv) &amp;&amp; parent) {</span>
<a href="#l20.7172"></a><span id="l20.7172" class="difflineplus">+                nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapParent =</span>
<a href="#l20.7173"></a><span id="l20.7173" class="difflineplus">+                    do_QueryInterface(parent);</span>
<a href="#l20.7174"></a><span id="l20.7174" class="difflineplus">+                if (imapParent) imapParent-&gt;RemoveSubFolder(this);</span>
<a href="#l20.7175"></a><span id="l20.7175">               }</span>
<a href="#l20.7176"></a><span id="l20.7176">             }</span>
<a href="#l20.7177"></a><span id="l20.7177">           }</span>
<a href="#l20.7178"></a><span id="l20.7178" class="difflineminus">-        break;</span>
<a href="#l20.7179"></a><span id="l20.7179" class="difflineminus">-      case nsIImapUrl::nsImapRefreshFolderUrls:</span>
<a href="#l20.7180"></a><span id="l20.7180" class="difflineminus">-        // we finished getting an admin url for the folder.</span>
<a href="#l20.7181"></a><span id="l20.7181" class="difflineminus">-          if (!m_adminUrl.IsEmpty())</span>
<a href="#l20.7182"></a><span id="l20.7182" class="difflineminus">-            FolderPrivileges(msgWindow);</span>
<a href="#l20.7183"></a><span id="l20.7183" class="difflineplus">+          break;</span>
<a href="#l20.7184"></a><span id="l20.7184" class="difflineplus">+        case nsIImapUrl::nsImapRefreshFolderUrls:</span>
<a href="#l20.7185"></a><span id="l20.7185" class="difflineplus">+          // we finished getting an admin url for the folder.</span>
<a href="#l20.7186"></a><span id="l20.7186" class="difflineplus">+          if (!m_adminUrl.IsEmpty()) FolderPrivileges(msgWindow);</span>
<a href="#l20.7187"></a><span id="l20.7187" class="difflineplus">+          break;</span>
<a href="#l20.7188"></a><span id="l20.7188" class="difflineplus">+        case nsIImapUrl::nsImapCreateFolder:</span>
<a href="#l20.7189"></a><span id="l20.7189" class="difflineplus">+          if (NS_FAILED(aExitCode))  // if success notification already done</span>
<a href="#l20.7190"></a><span id="l20.7190" class="difflineplus">+          {</span>
<a href="#l20.7191"></a><span id="l20.7191" class="difflineplus">+            NotifyFolderEvent(kFolderCreateFailed);</span>
<a href="#l20.7192"></a><span id="l20.7192" class="difflineplus">+          }</span>
<a href="#l20.7193"></a><span id="l20.7193">           break;</span>
<a href="#l20.7194"></a><span id="l20.7194" class="difflineminus">-      case nsIImapUrl::nsImapCreateFolder:</span>
<a href="#l20.7195"></a><span id="l20.7195" class="difflineminus">-        if (NS_FAILED(aExitCode))  //if success notification already done</span>
<a href="#l20.7196"></a><span id="l20.7196" class="difflineminus">-        {</span>
<a href="#l20.7197"></a><span id="l20.7197" class="difflineminus">-          NotifyFolderEvent(kFolderCreateFailed);</span>
<a href="#l20.7198"></a><span id="l20.7198" class="difflineminus">-        }</span>
<a href="#l20.7199"></a><span id="l20.7199" class="difflineminus">-        break;</span>
<a href="#l20.7200"></a><span id="l20.7200" class="difflineminus">-      case nsIImapUrl::nsImapSubscribe:</span>
<a href="#l20.7201"></a><span id="l20.7201" class="difflineminus">-        if (NS_SUCCEEDED(aExitCode) &amp;&amp; msgWindow)</span>
<a href="#l20.7202"></a><span id="l20.7202" class="difflineminus">-        {</span>
<a href="#l20.7203"></a><span id="l20.7203" class="difflineminus">-          nsCString canonicalFolderName;</span>
<a href="#l20.7204"></a><span id="l20.7204" class="difflineminus">-          imapUrl-&gt;CreateCanonicalSourceFolderPathString(getter_Copies(canonicalFolderName));</span>
<a href="#l20.7205"></a><span id="l20.7205" class="difflineminus">-          nsCOMPtr &lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l20.7206"></a><span id="l20.7206" class="difflineminus">-          nsresult rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l20.7207"></a><span id="l20.7207" class="difflineminus">-          if(NS_SUCCEEDED(rv) &amp;&amp; rootFolder)</span>
<a href="#l20.7208"></a><span id="l20.7208" class="difflineminus">-          {</span>
<a href="#l20.7209"></a><span id="l20.7209" class="difflineminus">-            nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapRoot = do_QueryInterface(rootFolder);</span>
<a href="#l20.7210"></a><span id="l20.7210" class="difflineminus">-            if (imapRoot)</span>
<a href="#l20.7211"></a><span id="l20.7211" class="difflineminus">-            {</span>
<a href="#l20.7212"></a><span id="l20.7212" class="difflineminus">-              nsCOMPtr &lt;nsIMsgImapMailFolder&gt; foundFolder;</span>
<a href="#l20.7213"></a><span id="l20.7213" class="difflineminus">-              rv = imapRoot-&gt;FindOnlineSubFolder(canonicalFolderName, getter_AddRefs(foundFolder));</span>
<a href="#l20.7214"></a><span id="l20.7214" class="difflineminus">-              if (NS_SUCCEEDED(rv) &amp;&amp; foundFolder)</span>
<a href="#l20.7215"></a><span id="l20.7215" class="difflineminus">-              {</span>
<a href="#l20.7216"></a><span id="l20.7216" class="difflineminus">-                nsCString uri;</span>
<a href="#l20.7217"></a><span id="l20.7217" class="difflineminus">-                nsCOMPtr &lt;nsIMsgFolder&gt; msgFolder = do_QueryInterface(foundFolder);</span>
<a href="#l20.7218"></a><span id="l20.7218" class="difflineminus">-                if (msgFolder)</span>
<a href="#l20.7219"></a><span id="l20.7219" class="difflineminus">-                {</span>
<a href="#l20.7220"></a><span id="l20.7220" class="difflineminus">-                  msgFolder-&gt;GetURI(uri);</span>
<a href="#l20.7221"></a><span id="l20.7221" class="difflineminus">-                  nsCOMPtr&lt;nsIMsgWindowCommands&gt; windowCommands;</span>
<a href="#l20.7222"></a><span id="l20.7222" class="difflineminus">-                  msgWindow-&gt;GetWindowCommands(getter_AddRefs(windowCommands));</span>
<a href="#l20.7223"></a><span id="l20.7223" class="difflineminus">-                  if (windowCommands)</span>
<a href="#l20.7224"></a><span id="l20.7224" class="difflineminus">-                    windowCommands-&gt;SelectFolder(uri);</span>
<a href="#l20.7225"></a><span id="l20.7225" class="difflineplus">+        case nsIImapUrl::nsImapSubscribe:</span>
<a href="#l20.7226"></a><span id="l20.7226" class="difflineplus">+          if (NS_SUCCEEDED(aExitCode) &amp;&amp; msgWindow) {</span>
<a href="#l20.7227"></a><span id="l20.7227" class="difflineplus">+            nsCString canonicalFolderName;</span>
<a href="#l20.7228"></a><span id="l20.7228" class="difflineplus">+            imapUrl-&gt;CreateCanonicalSourceFolderPathString(</span>
<a href="#l20.7229"></a><span id="l20.7229" class="difflineplus">+                getter_Copies(canonicalFolderName));</span>
<a href="#l20.7230"></a><span id="l20.7230" class="difflineplus">+            nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l20.7231"></a><span id="l20.7231" class="difflineplus">+            nsresult rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l20.7232"></a><span id="l20.7232" class="difflineplus">+            if (NS_SUCCEEDED(rv) &amp;&amp; rootFolder) {</span>
<a href="#l20.7233"></a><span id="l20.7233" class="difflineplus">+              nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapRoot =</span>
<a href="#l20.7234"></a><span id="l20.7234" class="difflineplus">+                  do_QueryInterface(rootFolder);</span>
<a href="#l20.7235"></a><span id="l20.7235" class="difflineplus">+              if (imapRoot) {</span>
<a href="#l20.7236"></a><span id="l20.7236" class="difflineplus">+                nsCOMPtr&lt;nsIMsgImapMailFolder&gt; foundFolder;</span>
<a href="#l20.7237"></a><span id="l20.7237" class="difflineplus">+                rv = imapRoot-&gt;FindOnlineSubFolder(canonicalFolderName,</span>
<a href="#l20.7238"></a><span id="l20.7238" class="difflineplus">+                                                   getter_AddRefs(foundFolder));</span>
<a href="#l20.7239"></a><span id="l20.7239" class="difflineplus">+                if (NS_SUCCEEDED(rv) &amp;&amp; foundFolder) {</span>
<a href="#l20.7240"></a><span id="l20.7240" class="difflineplus">+                  nsCString uri;</span>
<a href="#l20.7241"></a><span id="l20.7241" class="difflineplus">+                  nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder =</span>
<a href="#l20.7242"></a><span id="l20.7242" class="difflineplus">+                      do_QueryInterface(foundFolder);</span>
<a href="#l20.7243"></a><span id="l20.7243" class="difflineplus">+                  if (msgFolder) {</span>
<a href="#l20.7244"></a><span id="l20.7244" class="difflineplus">+                    msgFolder-&gt;GetURI(uri);</span>
<a href="#l20.7245"></a><span id="l20.7245" class="difflineplus">+                    nsCOMPtr&lt;nsIMsgWindowCommands&gt; windowCommands;</span>
<a href="#l20.7246"></a><span id="l20.7246" class="difflineplus">+                    msgWindow-&gt;GetWindowCommands(</span>
<a href="#l20.7247"></a><span id="l20.7247" class="difflineplus">+                        getter_AddRefs(windowCommands));</span>
<a href="#l20.7248"></a><span id="l20.7248" class="difflineplus">+                    if (windowCommands) windowCommands-&gt;SelectFolder(uri);</span>
<a href="#l20.7249"></a><span id="l20.7249" class="difflineplus">+                  }</span>
<a href="#l20.7250"></a><span id="l20.7250">                 }</span>
<a href="#l20.7251"></a><span id="l20.7251">               }</span>
<a href="#l20.7252"></a><span id="l20.7252">             }</span>
<a href="#l20.7253"></a><span id="l20.7253">           }</span>
<a href="#l20.7254"></a><span id="l20.7254" class="difflineminus">-        }</span>
<a href="#l20.7255"></a><span id="l20.7255" class="difflineminus">-        break;</span>
<a href="#l20.7256"></a><span id="l20.7256" class="difflineminus">-      case nsIImapUrl::nsImapExpungeFolder:</span>
<a href="#l20.7257"></a><span id="l20.7257" class="difflineminus">-        m_expunging = false;</span>
<a href="#l20.7258"></a><span id="l20.7258" class="difflineminus">-        break;</span>
<a href="#l20.7259"></a><span id="l20.7259" class="difflineminus">-      default:</span>
<a href="#l20.7260"></a><span id="l20.7260" class="difflineplus">+          break;</span>
<a href="#l20.7261"></a><span id="l20.7261" class="difflineplus">+        case nsIImapUrl::nsImapExpungeFolder:</span>
<a href="#l20.7262"></a><span id="l20.7262" class="difflineplus">+          m_expunging = false;</span>
<a href="#l20.7263"></a><span id="l20.7263" class="difflineplus">+          break;</span>
<a href="#l20.7264"></a><span id="l20.7264" class="difflineplus">+        default:</span>
<a href="#l20.7265"></a><span id="l20.7265">           break;</span>
<a href="#l20.7266"></a><span id="l20.7266">       }</span>
<a href="#l20.7267"></a><span id="l20.7267">     }</span>
<a href="#l20.7268"></a><span id="l20.7268">     // give base class a chance to send folder loaded notification...</span>
<a href="#l20.7269"></a><span id="l20.7269">     rv = nsMsgDBFolder::OnStopRunningUrl(aUrl, aExitCode);</span>
<a href="#l20.7270"></a><span id="l20.7270">   }</span>
<a href="#l20.7271"></a><span id="l20.7271">   // if we're not running a url, we must not be getting new mail.</span>
<a href="#l20.7272"></a><span id="l20.7272">   SetGettingNewMessages(false);</span>
<a href="#l20.7273"></a><span id="l20.7273">   // don't send OnStopRunning notification if still compacting offline store.</span>
<a href="#l20.7274"></a><span id="l20.7274">   if (m_urlListener &amp;&amp; (imapAction != nsIImapUrl::nsImapExpungeFolder ||</span>
<a href="#l20.7275"></a><span id="l20.7275" class="difflineminus">-                        !m_compactingOfflineStore))</span>
<a href="#l20.7276"></a><span id="l20.7276" class="difflineminus">-  {</span>
<a href="#l20.7277"></a><span id="l20.7277" class="difflineplus">+                        !m_compactingOfflineStore)) {</span>
<a href="#l20.7278"></a><span id="l20.7278">     nsCOMPtr&lt;nsIUrlListener&gt; saveListener = m_urlListener;</span>
<a href="#l20.7279"></a><span id="l20.7279">     m_urlListener = nullptr;</span>
<a href="#l20.7280"></a><span id="l20.7280">     saveListener-&gt;OnStopRunningUrl(aUrl, aExitCode);</span>
<a href="#l20.7281"></a><span id="l20.7281">   }</span>
<a href="#l20.7282"></a><span id="l20.7282">   return rv;</span>
<a href="#l20.7283"></a><span id="l20.7283"> }</span>
<a href="#l20.7284"></a><span id="l20.7284"> </span>
<a href="#l20.7285"></a><span id="l20.7285" class="difflineminus">-void nsImapMailFolder::UpdatePendingCounts()</span>
<a href="#l20.7286"></a><span id="l20.7286" class="difflineminus">-{</span>
<a href="#l20.7287"></a><span id="l20.7287" class="difflineminus">-  if (m_copyState)</span>
<a href="#l20.7288"></a><span id="l20.7288" class="difflineminus">-  {</span>
<a href="#l20.7289"></a><span id="l20.7289" class="difflineminus">-    ChangePendingTotal(m_copyState-&gt;m_isCrossServerOp ? 1 : m_copyState-&gt;m_totalCount);</span>
<a href="#l20.7290"></a><span id="l20.7290" class="difflineplus">+void nsImapMailFolder::UpdatePendingCounts() {</span>
<a href="#l20.7291"></a><span id="l20.7291" class="difflineplus">+  if (m_copyState) {</span>
<a href="#l20.7292"></a><span id="l20.7292" class="difflineplus">+    ChangePendingTotal(</span>
<a href="#l20.7293"></a><span id="l20.7293" class="difflineplus">+        m_copyState-&gt;m_isCrossServerOp ? 1 : m_copyState-&gt;m_totalCount);</span>
<a href="#l20.7294"></a><span id="l20.7294"> </span>
<a href="#l20.7295"></a><span id="l20.7295">     // count the moves that were unread</span>
<a href="#l20.7296"></a><span id="l20.7296">     int numUnread = m_copyState-&gt;m_unreadCount;</span>
<a href="#l20.7297"></a><span id="l20.7297" class="difflineminus">-    if (numUnread)</span>
<a href="#l20.7298"></a><span id="l20.7298" class="difflineminus">-    {</span>
<a href="#l20.7299"></a><span id="l20.7299" class="difflineminus">-      m_numServerUnseenMessages += numUnread; // adjust last status count by this delta.</span>
<a href="#l20.7300"></a><span id="l20.7300" class="difflineplus">+    if (numUnread) {</span>
<a href="#l20.7301"></a><span id="l20.7301" class="difflineplus">+      m_numServerUnseenMessages +=</span>
<a href="#l20.7302"></a><span id="l20.7302" class="difflineplus">+          numUnread;  // adjust last status count by this delta.</span>
<a href="#l20.7303"></a><span id="l20.7303">       ChangeNumPendingUnread(numUnread);</span>
<a href="#l20.7304"></a><span id="l20.7304">     }</span>
<a href="#l20.7305"></a><span id="l20.7305">     SummaryChanged();</span>
<a href="#l20.7306"></a><span id="l20.7306">   }</span>
<a href="#l20.7307"></a><span id="l20.7307"> }</span>
<a href="#l20.7308"></a><span id="l20.7308"> </span>
<a href="#l20.7309"></a><span id="l20.7309"> NS_IMETHODIMP</span>
<a href="#l20.7310"></a><span id="l20.7310" class="difflineminus">-nsImapMailFolder::ClearFolderRights()</span>
<a href="#l20.7311"></a><span id="l20.7311" class="difflineminus">-{</span>
<a href="#l20.7312"></a><span id="l20.7312" class="difflineplus">+nsImapMailFolder::ClearFolderRights() {</span>
<a href="#l20.7313"></a><span id="l20.7313">   SetFolderNeedsACLListed(false);</span>
<a href="#l20.7314"></a><span id="l20.7314">   delete m_folderACL;</span>
<a href="#l20.7315"></a><span id="l20.7315">   m_folderACL = new nsMsgIMAPFolderACL(this);</span>
<a href="#l20.7316"></a><span id="l20.7316">   return NS_OK;</span>
<a href="#l20.7317"></a><span id="l20.7317"> }</span>
<a href="#l20.7318"></a><span id="l20.7318"> </span>
<a href="#l20.7319"></a><span id="l20.7319"> NS_IMETHODIMP</span>
<a href="#l20.7320"></a><span id="l20.7320" class="difflineminus">-nsImapMailFolder::AddFolderRights(const nsACString&amp; userName, const nsACString&amp; rights)</span>
<a href="#l20.7321"></a><span id="l20.7321" class="difflineminus">-{</span>
<a href="#l20.7322"></a><span id="l20.7322" class="difflineplus">+nsImapMailFolder::AddFolderRights(const nsACString &amp;userName,</span>
<a href="#l20.7323"></a><span id="l20.7323" class="difflineplus">+                                  const nsACString &amp;rights) {</span>
<a href="#l20.7324"></a><span id="l20.7324">   SetFolderNeedsACLListed(false);</span>
<a href="#l20.7325"></a><span id="l20.7325">   GetFolderACL()-&gt;SetFolderRightsForUser(userName, rights);</span>
<a href="#l20.7326"></a><span id="l20.7326">   return NS_OK;</span>
<a href="#l20.7327"></a><span id="l20.7327"> }</span>
<a href="#l20.7328"></a><span id="l20.7328"> </span>
<a href="#l20.7329"></a><span id="l20.7329"> NS_IMETHODIMP</span>
<a href="#l20.7330"></a><span id="l20.7330" class="difflineminus">-nsImapMailFolder::RefreshFolderRights()</span>
<a href="#l20.7331"></a><span id="l20.7331" class="difflineminus">-{</span>
<a href="#l20.7332"></a><span id="l20.7332" class="difflineplus">+nsImapMailFolder::RefreshFolderRights() {</span>
<a href="#l20.7333"></a><span id="l20.7333">   if (GetFolderACL()-&gt;GetIsFolderShared())</span>
<a href="#l20.7334"></a><span id="l20.7334">     SetFlag(nsMsgFolderFlags::PersonalShared);</span>
<a href="#l20.7335"></a><span id="l20.7335">   else</span>
<a href="#l20.7336"></a><span id="l20.7336">     ClearFlag(nsMsgFolderFlags::PersonalShared);</span>
<a href="#l20.7337"></a><span id="l20.7337">   return NS_OK;</span>
<a href="#l20.7338"></a><span id="l20.7338"> }</span>
<a href="#l20.7339"></a><span id="l20.7339"> </span>
<a href="#l20.7340"></a><span id="l20.7340"> NS_IMETHODIMP</span>
<a href="#l20.7341"></a><span id="l20.7341" class="difflineminus">-nsImapMailFolder::SetCopyResponseUid(const char* msgIdString,</span>
<a href="#l20.7342"></a><span id="l20.7342" class="difflineminus">-                                     nsIImapUrl * aUrl)</span>
<a href="#l20.7343"></a><span id="l20.7343" class="difflineminus">-{   // CopyMessages() only</span>
<a href="#l20.7344"></a><span id="l20.7344" class="difflineplus">+nsImapMailFolder::SetCopyResponseUid(const char *msgIdString,</span>
<a href="#l20.7345"></a><span id="l20.7345" class="difflineplus">+                                     nsIImapUrl *aUrl) {  // CopyMessages() only</span>
<a href="#l20.7346"></a><span id="l20.7346">   nsresult rv = NS_OK;</span>
<a href="#l20.7347"></a><span id="l20.7347">   RefPtr&lt;nsImapMoveCopyMsgTxn&gt; msgTxn;</span>
<a href="#l20.7348"></a><span id="l20.7348">   nsCOMPtr&lt;nsISupports&gt; copyState;</span>
<a href="#l20.7349"></a><span id="l20.7349"> </span>
<a href="#l20.7350"></a><span id="l20.7350" class="difflineminus">-  if (aUrl)</span>
<a href="#l20.7351"></a><span id="l20.7351" class="difflineminus">-    aUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l20.7352"></a><span id="l20.7352" class="difflineminus">-</span>
<a href="#l20.7353"></a><span id="l20.7353" class="difflineminus">-  if (copyState)</span>
<a href="#l20.7354"></a><span id="l20.7354" class="difflineminus">-  {</span>
<a href="#l20.7355"></a><span id="l20.7355" class="difflineplus">+  if (aUrl) aUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l20.7356"></a><span id="l20.7356" class="difflineplus">+</span>
<a href="#l20.7357"></a><span id="l20.7357" class="difflineplus">+  if (copyState) {</span>
<a href="#l20.7358"></a><span id="l20.7358">     nsCOMPtr&lt;nsImapMailCopyState&gt; mailCopyState =</span>
<a href="#l20.7359"></a><span id="l20.7359">         do_QueryInterface(copyState, &amp;rv);</span>
<a href="#l20.7360"></a><span id="l20.7360">     if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.7361"></a><span id="l20.7361" class="difflineminus">-    if (mailCopyState-&gt;m_undoMsgTxn)</span>
<a href="#l20.7362"></a><span id="l20.7362" class="difflineminus">-      msgTxn = mailCopyState-&gt;m_undoMsgTxn;</span>
<a href="#l20.7363"></a><span id="l20.7363" class="difflineminus">-  }</span>
<a href="#l20.7364"></a><span id="l20.7364" class="difflineminus">-  else if (aUrl &amp;&amp; m_pendingOfflineMoves.Length())</span>
<a href="#l20.7365"></a><span id="l20.7365" class="difflineminus">-  {</span>
<a href="#l20.7366"></a><span id="l20.7366" class="difflineplus">+    if (mailCopyState-&gt;m_undoMsgTxn) msgTxn = mailCopyState-&gt;m_undoMsgTxn;</span>
<a href="#l20.7367"></a><span id="l20.7367" class="difflineplus">+  } else if (aUrl &amp;&amp; m_pendingOfflineMoves.Length()) {</span>
<a href="#l20.7368"></a><span id="l20.7368">     nsCString urlSourceMsgIds, undoTxnSourceMsgIds;</span>
<a href="#l20.7369"></a><span id="l20.7369">     aUrl-&gt;GetListOfMessageIds(urlSourceMsgIds);</span>
<a href="#l20.7370"></a><span id="l20.7370">     RefPtr&lt;nsImapMoveCopyMsgTxn&gt; imapUndo = m_pendingOfflineMoves[0];</span>
<a href="#l20.7371"></a><span id="l20.7371" class="difflineminus">-    if (imapUndo)</span>
<a href="#l20.7372"></a><span id="l20.7372" class="difflineminus">-    {</span>
<a href="#l20.7373"></a><span id="l20.7373" class="difflineplus">+    if (imapUndo) {</span>
<a href="#l20.7374"></a><span id="l20.7374">       imapUndo-&gt;GetSrcMsgIds(undoTxnSourceMsgIds);</span>
<a href="#l20.7375"></a><span id="l20.7375" class="difflineminus">-      if (undoTxnSourceMsgIds.Equals(urlSourceMsgIds))</span>
<a href="#l20.7376"></a><span id="l20.7376" class="difflineminus">-        msgTxn = imapUndo;</span>
<a href="#l20.7377"></a><span id="l20.7377" class="difflineplus">+      if (undoTxnSourceMsgIds.Equals(urlSourceMsgIds)) msgTxn = imapUndo;</span>
<a href="#l20.7378"></a><span id="l20.7378">       // ### we should handle batched moves, but lets keep it simple for a2.</span>
<a href="#l20.7379"></a><span id="l20.7379">       m_pendingOfflineMoves.Clear();</span>
<a href="#l20.7380"></a><span id="l20.7380">     }</span>
<a href="#l20.7381"></a><span id="l20.7381">   }</span>
<a href="#l20.7382"></a><span id="l20.7382" class="difflineminus">-  if (msgTxn)</span>
<a href="#l20.7383"></a><span id="l20.7383" class="difflineminus">-    msgTxn-&gt;SetCopyResponseUid(msgIdString);</span>
<a href="#l20.7384"></a><span id="l20.7384" class="difflineplus">+  if (msgTxn) msgTxn-&gt;SetCopyResponseUid(msgIdString);</span>
<a href="#l20.7385"></a><span id="l20.7385">   return NS_OK;</span>
<a href="#l20.7386"></a><span id="l20.7386"> }</span>
<a href="#l20.7387"></a><span id="l20.7387"> </span>
<a href="#l20.7388"></a><span id="l20.7388"> NS_IMETHODIMP</span>
<a href="#l20.7389"></a><span id="l20.7389" class="difflineminus">-nsImapMailFolder::StartMessage(nsIMsgMailNewsUrl * aUrl)</span>
<a href="#l20.7390"></a><span id="l20.7390" class="difflineminus">-{</span>
<a href="#l20.7391"></a><span id="l20.7391" class="difflineminus">-  nsCOMPtr&lt;nsIImapUrl&gt; imapUrl (do_QueryInterface(aUrl));</span>
<a href="#l20.7392"></a><span id="l20.7392" class="difflineplus">+nsImapMailFolder::StartMessage(nsIMsgMailNewsUrl *aUrl) {</span>
<a href="#l20.7393"></a><span id="l20.7393" class="difflineplus">+  nsCOMPtr&lt;nsIImapUrl&gt; imapUrl(do_QueryInterface(aUrl));</span>
<a href="#l20.7394"></a><span id="l20.7394">   nsCOMPtr&lt;nsISupports&gt; copyState;</span>
<a href="#l20.7395"></a><span id="l20.7395">   NS_ENSURE_TRUE(imapUrl, NS_ERROR_FAILURE);</span>
<a href="#l20.7396"></a><span id="l20.7396"> </span>
<a href="#l20.7397"></a><span id="l20.7397">   imapUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l20.7398"></a><span id="l20.7398" class="difflineminus">-  if (copyState)</span>
<a href="#l20.7399"></a><span id="l20.7399" class="difflineminus">-  {</span>
<a href="#l20.7400"></a><span id="l20.7400" class="difflineminus">-    nsCOMPtr &lt;nsICopyMessageStreamListener&gt; listener = do_QueryInterface(copyState);</span>
<a href="#l20.7401"></a><span id="l20.7401" class="difflineminus">-    if (listener)</span>
<a href="#l20.7402"></a><span id="l20.7402" class="difflineminus">-      listener-&gt;StartMessage();</span>
<a href="#l20.7403"></a><span id="l20.7403" class="difflineplus">+  if (copyState) {</span>
<a href="#l20.7404"></a><span id="l20.7404" class="difflineplus">+    nsCOMPtr&lt;nsICopyMessageStreamListener&gt; listener =</span>
<a href="#l20.7405"></a><span id="l20.7405" class="difflineplus">+        do_QueryInterface(copyState);</span>
<a href="#l20.7406"></a><span id="l20.7406" class="difflineplus">+    if (listener) listener-&gt;StartMessage();</span>
<a href="#l20.7407"></a><span id="l20.7407">   }</span>
<a href="#l20.7408"></a><span id="l20.7408">   return NS_OK;</span>
<a href="#l20.7409"></a><span id="l20.7409"> }</span>
<a href="#l20.7410"></a><span id="l20.7410"> </span>
<a href="#l20.7411"></a><span id="l20.7411"> NS_IMETHODIMP</span>
<a href="#l20.7412"></a><span id="l20.7412" class="difflineminus">-nsImapMailFolder::EndMessage(nsIMsgMailNewsUrl * aUrl, nsMsgKey uidOfMessage)</span>
<a href="#l20.7413"></a><span id="l20.7413" class="difflineminus">-{</span>
<a href="#l20.7414"></a><span id="l20.7414" class="difflineminus">-  nsCOMPtr&lt;nsIImapUrl&gt; imapUrl (do_QueryInterface(aUrl));</span>
<a href="#l20.7415"></a><span id="l20.7415" class="difflineplus">+nsImapMailFolder::EndMessage(nsIMsgMailNewsUrl *aUrl, nsMsgKey uidOfMessage) {</span>
<a href="#l20.7416"></a><span id="l20.7416" class="difflineplus">+  nsCOMPtr&lt;nsIImapUrl&gt; imapUrl(do_QueryInterface(aUrl));</span>
<a href="#l20.7417"></a><span id="l20.7417">   nsCOMPtr&lt;nsISupports&gt; copyState;</span>
<a href="#l20.7418"></a><span id="l20.7418">   NS_ENSURE_TRUE(imapUrl, NS_ERROR_FAILURE);</span>
<a href="#l20.7419"></a><span id="l20.7419">   imapUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l20.7420"></a><span id="l20.7420" class="difflineminus">-  if (copyState)</span>
<a href="#l20.7421"></a><span id="l20.7421" class="difflineminus">-  {</span>
<a href="#l20.7422"></a><span id="l20.7422" class="difflineminus">-    nsCOMPtr &lt;nsICopyMessageStreamListener&gt; listener = do_QueryInterface(copyState);</span>
<a href="#l20.7423"></a><span id="l20.7423" class="difflineminus">-    if (listener)</span>
<a href="#l20.7424"></a><span id="l20.7424" class="difflineminus">-      listener-&gt;EndMessage(uidOfMessage);</span>
<a href="#l20.7425"></a><span id="l20.7425" class="difflineplus">+  if (copyState) {</span>
<a href="#l20.7426"></a><span id="l20.7426" class="difflineplus">+    nsCOMPtr&lt;nsICopyMessageStreamListener&gt; listener =</span>
<a href="#l20.7427"></a><span id="l20.7427" class="difflineplus">+        do_QueryInterface(copyState);</span>
<a href="#l20.7428"></a><span id="l20.7428" class="difflineplus">+    if (listener) listener-&gt;EndMessage(uidOfMessage);</span>
<a href="#l20.7429"></a><span id="l20.7429">   }</span>
<a href="#l20.7430"></a><span id="l20.7430">   return NS_OK;</span>
<a href="#l20.7431"></a><span id="l20.7431"> }</span>
<a href="#l20.7432"></a><span id="l20.7432"> </span>
<a href="#l20.7433"></a><span id="l20.7433" class="difflineminus">-#define WHITESPACE &quot; \015\012&quot;     // token delimiter</span>
<a href="#l20.7434"></a><span id="l20.7434" class="difflineplus">+#define WHITESPACE &quot; \015\012&quot;  // token delimiter</span>
<a href="#l20.7435"></a><span id="l20.7435"> </span>
<a href="#l20.7436"></a><span id="l20.7436"> NS_IMETHODIMP</span>
<a href="#l20.7437"></a><span id="l20.7437" class="difflineminus">-nsImapMailFolder::NotifySearchHit(nsIMsgMailNewsUrl * aUrl,</span>
<a href="#l20.7438"></a><span id="l20.7438" class="difflineminus">-                                  const char* searchHitLine)</span>
<a href="#l20.7439"></a><span id="l20.7439" class="difflineminus">-{</span>
<a href="#l20.7440"></a><span id="l20.7440" class="difflineplus">+nsImapMailFolder::NotifySearchHit(nsIMsgMailNewsUrl *aUrl,</span>
<a href="#l20.7441"></a><span id="l20.7441" class="difflineplus">+                                  const char *searchHitLine) {</span>
<a href="#l20.7442"></a><span id="l20.7442">   NS_ENSURE_ARG_POINTER(aUrl);</span>
<a href="#l20.7443"></a><span id="l20.7443">   nsresult rv = GetDatabase();</span>
<a href="#l20.7444"></a><span id="l20.7444">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.7445"></a><span id="l20.7445"> </span>
<a href="#l20.7446"></a><span id="l20.7446">   // expect search results in the form of &quot;* SEARCH &lt;hit&gt; &lt;hit&gt; ...&quot;</span>
<a href="#l20.7447"></a><span id="l20.7447">   // expect search results in the form of &quot;* SEARCH &lt;hit&gt; &lt;hit&gt; ...&quot;</span>
<a href="#l20.7448"></a><span id="l20.7448">   nsCString tokenString(searchHitLine);</span>
<a href="#l20.7449"></a><span id="l20.7449">   char *currentPosition = PL_strcasestr(tokenString.get(), &quot;SEARCH&quot;);</span>
<a href="#l20.7450"></a><span id="l20.7450" class="difflineminus">-  if (currentPosition)</span>
<a href="#l20.7451"></a><span id="l20.7451" class="difflineminus">-  {</span>
<a href="#l20.7452"></a><span id="l20.7452" class="difflineplus">+  if (currentPosition) {</span>
<a href="#l20.7453"></a><span id="l20.7453">     currentPosition += strlen(&quot;SEARCH&quot;);</span>
<a href="#l20.7454"></a><span id="l20.7454">     bool shownUpdateAlert = false;</span>
<a href="#l20.7455"></a><span id="l20.7455">     char *hitUidToken = NS_strtok(WHITESPACE, &amp;currentPosition);</span>
<a href="#l20.7456"></a><span id="l20.7456" class="difflineminus">-    while (hitUidToken)</span>
<a href="#l20.7457"></a><span id="l20.7457" class="difflineminus">-    {</span>
<a href="#l20.7458"></a><span id="l20.7458" class="difflineminus">-      long naturalLong; // %l is 64 bits on OSF1</span>
<a href="#l20.7459"></a><span id="l20.7459" class="difflineplus">+    while (hitUidToken) {</span>
<a href="#l20.7460"></a><span id="l20.7460" class="difflineplus">+      long naturalLong;  // %l is 64 bits on OSF1</span>
<a href="#l20.7461"></a><span id="l20.7461">       sscanf(hitUidToken, &quot;%ld&quot;, &amp;naturalLong);</span>
<a href="#l20.7462"></a><span id="l20.7462" class="difflineminus">-      nsMsgKey hitUid = (nsMsgKey) naturalLong;</span>
<a href="#l20.7463"></a><span id="l20.7463" class="difflineminus">-</span>
<a href="#l20.7464"></a><span id="l20.7464" class="difflineminus">-      nsCOMPtr &lt;nsIMsgDBHdr&gt; hitHeader;</span>
<a href="#l20.7465"></a><span id="l20.7465" class="difflineplus">+      nsMsgKey hitUid = (nsMsgKey)naturalLong;</span>
<a href="#l20.7466"></a><span id="l20.7466" class="difflineplus">+</span>
<a href="#l20.7467"></a><span id="l20.7467" class="difflineplus">+      nsCOMPtr&lt;nsIMsgDBHdr&gt; hitHeader;</span>
<a href="#l20.7468"></a><span id="l20.7468">       rv = mDatabase-&gt;GetMsgHdrForKey(hitUid, getter_AddRefs(hitHeader));</span>
<a href="#l20.7469"></a><span id="l20.7469" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; hitHeader)</span>
<a href="#l20.7470"></a><span id="l20.7470" class="difflineminus">-      {</span>
<a href="#l20.7471"></a><span id="l20.7471" class="difflineminus">-        nsCOMPtr &lt;nsIMsgSearchSession&gt; searchSession;</span>
<a href="#l20.7472"></a><span id="l20.7472" class="difflineminus">-        nsCOMPtr &lt;nsIMsgSearchAdapter&gt; searchAdapter;</span>
<a href="#l20.7473"></a><span id="l20.7473" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; hitHeader) {</span>
<a href="#l20.7474"></a><span id="l20.7474" class="difflineplus">+        nsCOMPtr&lt;nsIMsgSearchSession&gt; searchSession;</span>
<a href="#l20.7475"></a><span id="l20.7475" class="difflineplus">+        nsCOMPtr&lt;nsIMsgSearchAdapter&gt; searchAdapter;</span>
<a href="#l20.7476"></a><span id="l20.7476">         aUrl-&gt;GetSearchSession(getter_AddRefs(searchSession));</span>
<a href="#l20.7477"></a><span id="l20.7477" class="difflineminus">-        if (searchSession)</span>
<a href="#l20.7478"></a><span id="l20.7478" class="difflineminus">-        {</span>
<a href="#l20.7479"></a><span id="l20.7479" class="difflineplus">+        if (searchSession) {</span>
<a href="#l20.7480"></a><span id="l20.7480">           searchSession-&gt;GetRunningAdapter(getter_AddRefs(searchAdapter));</span>
<a href="#l20.7481"></a><span id="l20.7481" class="difflineminus">-          if (searchAdapter)</span>
<a href="#l20.7482"></a><span id="l20.7482" class="difflineminus">-            searchAdapter-&gt;AddResultElement(hitHeader);</span>
<a href="#l20.7483"></a><span id="l20.7483" class="difflineplus">+          if (searchAdapter) searchAdapter-&gt;AddResultElement(hitHeader);</span>
<a href="#l20.7484"></a><span id="l20.7484">         }</span>
<a href="#l20.7485"></a><span id="l20.7485" class="difflineminus">-      }</span>
<a href="#l20.7486"></a><span id="l20.7486" class="difflineminus">-      else if (!shownUpdateAlert)</span>
<a href="#l20.7487"></a><span id="l20.7487" class="difflineminus">-      {</span>
<a href="#l20.7488"></a><span id="l20.7488" class="difflineplus">+      } else if (!shownUpdateAlert) {</span>
<a href="#l20.7489"></a><span id="l20.7489">       }</span>
<a href="#l20.7490"></a><span id="l20.7490"> </span>
<a href="#l20.7491"></a><span id="l20.7491">       hitUidToken = NS_strtok(WHITESPACE, &amp;currentPosition);</span>
<a href="#l20.7492"></a><span id="l20.7492">     }</span>
<a href="#l20.7493"></a><span id="l20.7493" class="difflineminus">-}</span>
<a href="#l20.7494"></a><span id="l20.7494" class="difflineplus">+  }</span>
<a href="#l20.7495"></a><span id="l20.7495">   return NS_OK;</span>
<a href="#l20.7496"></a><span id="l20.7496"> }</span>
<a href="#l20.7497"></a><span id="l20.7497"> </span>
<a href="#l20.7498"></a><span id="l20.7498"> NS_IMETHODIMP</span>
<a href="#l20.7499"></a><span id="l20.7499" class="difflineminus">-nsImapMailFolder::SetAppendMsgUid(nsMsgKey aKey,</span>
<a href="#l20.7500"></a><span id="l20.7500" class="difflineminus">-                                  nsIImapUrl * aUrl)</span>
<a href="#l20.7501"></a><span id="l20.7501" class="difflineminus">-{</span>
<a href="#l20.7502"></a><span id="l20.7502" class="difflineplus">+nsImapMailFolder::SetAppendMsgUid(nsMsgKey aKey, nsIImapUrl *aUrl) {</span>
<a href="#l20.7503"></a><span id="l20.7503">   nsresult rv;</span>
<a href="#l20.7504"></a><span id="l20.7504">   nsCOMPtr&lt;nsISupports&gt; copyState;</span>
<a href="#l20.7505"></a><span id="l20.7505" class="difflineminus">-  if (aUrl)</span>
<a href="#l20.7506"></a><span id="l20.7506" class="difflineminus">-    aUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l20.7507"></a><span id="l20.7507" class="difflineminus">-  if (copyState)</span>
<a href="#l20.7508"></a><span id="l20.7508" class="difflineminus">-  {</span>
<a href="#l20.7509"></a><span id="l20.7509" class="difflineminus">-    nsCOMPtr&lt;nsImapMailCopyState&gt; mailCopyState = do_QueryInterface(copyState, &amp;rv);</span>
<a href="#l20.7510"></a><span id="l20.7510" class="difflineplus">+  if (aUrl) aUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l20.7511"></a><span id="l20.7511" class="difflineplus">+  if (copyState) {</span>
<a href="#l20.7512"></a><span id="l20.7512" class="difflineplus">+    nsCOMPtr&lt;nsImapMailCopyState&gt; mailCopyState =</span>
<a href="#l20.7513"></a><span id="l20.7513" class="difflineplus">+        do_QueryInterface(copyState, &amp;rv);</span>
<a href="#l20.7514"></a><span id="l20.7514">     if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.7515"></a><span id="l20.7515"> </span>
<a href="#l20.7516"></a><span id="l20.7516" class="difflineminus">-    if (mailCopyState-&gt;m_undoMsgTxn) // CopyMessages()</span>
<a href="#l20.7517"></a><span id="l20.7517" class="difflineplus">+    if (mailCopyState-&gt;m_undoMsgTxn)  // CopyMessages()</span>
<a href="#l20.7518"></a><span id="l20.7518">     {</span>
<a href="#l20.7519"></a><span id="l20.7519" class="difflineminus">-        RefPtr&lt;nsImapMoveCopyMsgTxn&gt; msgTxn;</span>
<a href="#l20.7520"></a><span id="l20.7520" class="difflineminus">-        msgTxn = mailCopyState-&gt;m_undoMsgTxn;</span>
<a href="#l20.7521"></a><span id="l20.7521" class="difflineminus">-        msgTxn-&gt;AddDstKey(aKey);</span>
<a href="#l20.7522"></a><span id="l20.7522" class="difflineminus">-    }</span>
<a href="#l20.7523"></a><span id="l20.7523" class="difflineminus">-    else if (mailCopyState-&gt;m_listener) // CopyFileMessage();</span>
<a href="#l20.7524"></a><span id="l20.7524" class="difflineminus">-                                        // Draft/Template goes here</span>
<a href="#l20.7525"></a><span id="l20.7525" class="difflineplus">+      RefPtr&lt;nsImapMoveCopyMsgTxn&gt; msgTxn;</span>
<a href="#l20.7526"></a><span id="l20.7526" class="difflineplus">+      msgTxn = mailCopyState-&gt;m_undoMsgTxn;</span>
<a href="#l20.7527"></a><span id="l20.7527" class="difflineplus">+      msgTxn-&gt;AddDstKey(aKey);</span>
<a href="#l20.7528"></a><span id="l20.7528" class="difflineplus">+    } else if (mailCopyState-&gt;m_listener)  // CopyFileMessage();</span>
<a href="#l20.7529"></a><span id="l20.7529" class="difflineplus">+                                           // Draft/Template goes here</span>
<a href="#l20.7530"></a><span id="l20.7530">     {</span>
<a href="#l20.7531"></a><span id="l20.7531">       mailCopyState-&gt;m_appendUID = aKey;</span>
<a href="#l20.7532"></a><span id="l20.7532">       mailCopyState-&gt;m_listener-&gt;SetMessageKey(aKey);</span>
<a href="#l20.7533"></a><span id="l20.7533">     }</span>
<a href="#l20.7534"></a><span id="l20.7534">   }</span>
<a href="#l20.7535"></a><span id="l20.7535">   return NS_OK;</span>
<a href="#l20.7536"></a><span id="l20.7536"> }</span>
<a href="#l20.7537"></a><span id="l20.7537"> </span>
<a href="#l20.7538"></a><span id="l20.7538"> NS_IMETHODIMP</span>
<a href="#l20.7539"></a><span id="l20.7539" class="difflineminus">-nsImapMailFolder::GetMessageId(nsIImapUrl * aUrl,</span>
<a href="#l20.7540"></a><span id="l20.7540" class="difflineminus">-                               nsACString &amp;messageId)</span>
<a href="#l20.7541"></a><span id="l20.7541" class="difflineminus">-{</span>
<a href="#l20.7542"></a><span id="l20.7542" class="difflineplus">+nsImapMailFolder::GetMessageId(nsIImapUrl *aUrl, nsACString &amp;messageId) {</span>
<a href="#l20.7543"></a><span id="l20.7543">   nsresult rv = NS_OK;</span>
<a href="#l20.7544"></a><span id="l20.7544">   nsCOMPtr&lt;nsISupports&gt; copyState;</span>
<a href="#l20.7545"></a><span id="l20.7545"> </span>
<a href="#l20.7546"></a><span id="l20.7546" class="difflineminus">-  if (aUrl)</span>
<a href="#l20.7547"></a><span id="l20.7547" class="difflineminus">-    aUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l20.7548"></a><span id="l20.7548" class="difflineminus">-  if (copyState)</span>
<a href="#l20.7549"></a><span id="l20.7549" class="difflineminus">-  {</span>
<a href="#l20.7550"></a><span id="l20.7550" class="difflineminus">-    nsCOMPtr&lt;nsImapMailCopyState&gt; mailCopyState = do_QueryInterface(copyState, &amp;rv);</span>
<a href="#l20.7551"></a><span id="l20.7551" class="difflineplus">+  if (aUrl) aUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l20.7552"></a><span id="l20.7552" class="difflineplus">+  if (copyState) {</span>
<a href="#l20.7553"></a><span id="l20.7553" class="difflineplus">+    nsCOMPtr&lt;nsImapMailCopyState&gt; mailCopyState =</span>
<a href="#l20.7554"></a><span id="l20.7554" class="difflineplus">+        do_QueryInterface(copyState, &amp;rv);</span>
<a href="#l20.7555"></a><span id="l20.7555">     if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.7556"></a><span id="l20.7556">     if (mailCopyState-&gt;m_listener)</span>
<a href="#l20.7557"></a><span id="l20.7557">       rv = mailCopyState-&gt;m_listener-&gt;GetMessageId(messageId);</span>
<a href="#l20.7558"></a><span id="l20.7558">   }</span>
<a href="#l20.7559"></a><span id="l20.7559" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; messageId.Length() &gt; 0)</span>
<a href="#l20.7560"></a><span id="l20.7560" class="difflineminus">-  {</span>
<a href="#l20.7561"></a><span id="l20.7561" class="difflineminus">-    if (messageId.First() == '&lt;')</span>
<a href="#l20.7562"></a><span id="l20.7562" class="difflineminus">-        messageId.Cut(0, 1);</span>
<a href="#l20.7563"></a><span id="l20.7563" class="difflineminus">-    if (messageId.Last() == '&gt;')</span>
<a href="#l20.7564"></a><span id="l20.7564" class="difflineminus">-        messageId.SetLength(messageId.Length() -1);</span>
<a href="#l20.7565"></a><span id="l20.7565" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; messageId.Length() &gt; 0) {</span>
<a href="#l20.7566"></a><span id="l20.7566" class="difflineplus">+    if (messageId.First() == '&lt;') messageId.Cut(0, 1);</span>
<a href="#l20.7567"></a><span id="l20.7567" class="difflineplus">+    if (messageId.Last() == '&gt;') messageId.SetLength(messageId.Length() - 1);</span>
<a href="#l20.7568"></a><span id="l20.7568">   }</span>
<a href="#l20.7569"></a><span id="l20.7569">   return rv;</span>
<a href="#l20.7570"></a><span id="l20.7570"> }</span>
<a href="#l20.7571"></a><span id="l20.7571"> </span>
<a href="#l20.7572"></a><span id="l20.7572"> NS_IMETHODIMP</span>
<a href="#l20.7573"></a><span id="l20.7573" class="difflineminus">-nsImapMailFolder::HeaderFetchCompleted(nsIImapProtocol* aProtocol)</span>
<a href="#l20.7574"></a><span id="l20.7574" class="difflineminus">-{</span>
<a href="#l20.7575"></a><span id="l20.7575" class="difflineminus">-  nsCOMPtr &lt;nsIMsgWindow&gt; msgWindow; // we might need this for the filter plugins.</span>
<a href="#l20.7576"></a><span id="l20.7576" class="difflineminus">-  if (mBackupDatabase)</span>
<a href="#l20.7577"></a><span id="l20.7577" class="difflineminus">-    RemoveBackupMsgDatabase();</span>
<a href="#l20.7578"></a><span id="l20.7578" class="difflineplus">+nsImapMailFolder::HeaderFetchCompleted(nsIImapProtocol *aProtocol) {</span>
<a href="#l20.7579"></a><span id="l20.7579" class="difflineplus">+  nsCOMPtr&lt;nsIMsgWindow&gt;</span>
<a href="#l20.7580"></a><span id="l20.7580" class="difflineplus">+      msgWindow;  // we might need this for the filter plugins.</span>
<a href="#l20.7581"></a><span id="l20.7581" class="difflineplus">+  if (mBackupDatabase) RemoveBackupMsgDatabase();</span>
<a href="#l20.7582"></a><span id="l20.7582"> </span>
<a href="#l20.7583"></a><span id="l20.7583">   SetSizeOnDisk(mFolderSize);</span>
<a href="#l20.7584"></a><span id="l20.7584">   int32_t numNewBiffMsgs = 0;</span>
<a href="#l20.7585"></a><span id="l20.7585" class="difflineminus">-  if (m_performingBiff)</span>
<a href="#l20.7586"></a><span id="l20.7586" class="difflineminus">-    GetNumNewMessages(false, &amp;numNewBiffMsgs);</span>
<a href="#l20.7587"></a><span id="l20.7587" class="difflineplus">+  if (m_performingBiff) GetNumNewMessages(false, &amp;numNewBiffMsgs);</span>
<a href="#l20.7588"></a><span id="l20.7588"> </span>
<a href="#l20.7589"></a><span id="l20.7589">   bool pendingMoves = m_moveCoalescer &amp;&amp; m_moveCoalescer-&gt;HasPendingMoves();</span>
<a href="#l20.7590"></a><span id="l20.7590">   PlaybackCoalescedOperations();</span>
<a href="#l20.7591"></a><span id="l20.7591" class="difflineminus">-  if (aProtocol)</span>
<a href="#l20.7592"></a><span id="l20.7592" class="difflineminus">-  {</span>
<a href="#l20.7593"></a><span id="l20.7593" class="difflineplus">+  if (aProtocol) {</span>
<a href="#l20.7594"></a><span id="l20.7594">     // check if we should download message bodies because it's the inbox and</span>
<a href="#l20.7595"></a><span id="l20.7595" class="difflineminus">-    // the server is specified as one where where we download msg bodies automatically.</span>
<a href="#l20.7596"></a><span id="l20.7596" class="difflineminus">-    // Or if we autosyncing all offline folders.</span>
<a href="#l20.7597"></a><span id="l20.7597" class="difflineplus">+    // the server is specified as one where where we download msg bodies</span>
<a href="#l20.7598"></a><span id="l20.7598" class="difflineplus">+    // automatically. Or if we autosyncing all offline folders.</span>
<a href="#l20.7599"></a><span id="l20.7599">     nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.7600"></a><span id="l20.7600">     GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.7601"></a><span id="l20.7601"> </span>
<a href="#l20.7602"></a><span id="l20.7602">     bool autoDownloadNewHeaders = false;</span>
<a href="#l20.7603"></a><span id="l20.7603">     bool autoSyncOfflineStores = false;</span>
<a href="#l20.7604"></a><span id="l20.7604"> </span>
<a href="#l20.7605"></a><span id="l20.7605" class="difflineminus">-    if (imapServer)</span>
<a href="#l20.7606"></a><span id="l20.7606" class="difflineminus">-    {</span>
<a href="#l20.7607"></a><span id="l20.7607" class="difflineplus">+    if (imapServer) {</span>
<a href="#l20.7608"></a><span id="l20.7608">       imapServer-&gt;GetAutoSyncOfflineStores(&amp;autoSyncOfflineStores);</span>
<a href="#l20.7609"></a><span id="l20.7609">       imapServer-&gt;GetDownloadBodiesOnGetNewMail(&amp;autoDownloadNewHeaders);</span>
<a href="#l20.7610"></a><span id="l20.7610" class="difflineminus">-      if (m_filterListRequiresBody)</span>
<a href="#l20.7611"></a><span id="l20.7611" class="difflineminus">-        autoDownloadNewHeaders = true;</span>
<a href="#l20.7612"></a><span id="l20.7612" class="difflineplus">+      if (m_filterListRequiresBody) autoDownloadNewHeaders = true;</span>
<a href="#l20.7613"></a><span id="l20.7613">     }</span>
<a href="#l20.7614"></a><span id="l20.7614">     bool notifiedBodies = false;</span>
<a href="#l20.7615"></a><span id="l20.7615">     if (m_downloadingFolderForOfflineUse || autoSyncOfflineStores ||</span>
<a href="#l20.7616"></a><span id="l20.7616" class="difflineminus">-        autoDownloadNewHeaders)</span>
<a href="#l20.7617"></a><span id="l20.7617" class="difflineminus">-    {</span>
<a href="#l20.7618"></a><span id="l20.7618" class="difflineplus">+        autoDownloadNewHeaders) {</span>
<a href="#l20.7619"></a><span id="l20.7619">       nsTArray&lt;nsMsgKey&gt; keysToDownload;</span>
<a href="#l20.7620"></a><span id="l20.7620">       GetBodysToDownload(&amp;keysToDownload);</span>
<a href="#l20.7621"></a><span id="l20.7621">       // this is the case when DownloadAllForOffline is called.</span>
<a href="#l20.7622"></a><span id="l20.7622" class="difflineminus">-      if (!keysToDownload.IsEmpty() &amp;&amp; (m_downloadingFolderForOfflineUse ||</span>
<a href="#l20.7623"></a><span id="l20.7623" class="difflineminus">-                                        autoDownloadNewHeaders))</span>
<a href="#l20.7624"></a><span id="l20.7624" class="difflineminus">-      {</span>
<a href="#l20.7625"></a><span id="l20.7625" class="difflineplus">+      if (!keysToDownload.IsEmpty() &amp;&amp;</span>
<a href="#l20.7626"></a><span id="l20.7626" class="difflineplus">+          (m_downloadingFolderForOfflineUse || autoDownloadNewHeaders)) {</span>
<a href="#l20.7627"></a><span id="l20.7627">         notifiedBodies = true;</span>
<a href="#l20.7628"></a><span id="l20.7628" class="difflineminus">-        aProtocol-&gt;NotifyBodysToDownload(keysToDownload.Elements(), keysToDownload.Length());</span>
<a href="#l20.7629"></a><span id="l20.7629" class="difflineminus">-      }</span>
<a href="#l20.7630"></a><span id="l20.7630" class="difflineminus">-      else</span>
<a href="#l20.7631"></a><span id="l20.7631" class="difflineminus">-      {</span>
<a href="#l20.7632"></a><span id="l20.7632" class="difflineplus">+        aProtocol-&gt;NotifyBodysToDownload(keysToDownload.Elements(),</span>
<a href="#l20.7633"></a><span id="l20.7633" class="difflineplus">+                                         keysToDownload.Length());</span>
<a href="#l20.7634"></a><span id="l20.7634" class="difflineplus">+      } else {</span>
<a href="#l20.7635"></a><span id="l20.7635">         // create auto-sync state object lazily</span>
<a href="#l20.7636"></a><span id="l20.7636">         InitAutoSyncState();</span>
<a href="#l20.7637"></a><span id="l20.7637"> </span>
<a href="#l20.7638"></a><span id="l20.7638">         // make enough room for new downloads</span>
<a href="#l20.7639"></a><span id="l20.7639">         m_autoSyncStateObj-&gt;ManageStorageSpace();</span>
<a href="#l20.7640"></a><span id="l20.7640" class="difflineminus">-        m_autoSyncStateObj-&gt;SetServerCounts(m_numServerTotalMessages,</span>
<a href="#l20.7641"></a><span id="l20.7641" class="difflineminus">-                                            m_numServerRecentMessages,</span>
<a href="#l20.7642"></a><span id="l20.7642" class="difflineminus">-                                            m_numServerUnseenMessages,</span>
<a href="#l20.7643"></a><span id="l20.7643" class="difflineminus">-                                            m_nextUID);</span>
<a href="#l20.7644"></a><span id="l20.7644" class="difflineplus">+        m_autoSyncStateObj-&gt;SetServerCounts(</span>
<a href="#l20.7645"></a><span id="l20.7645" class="difflineplus">+            m_numServerTotalMessages, m_numServerRecentMessages,</span>
<a href="#l20.7646"></a><span id="l20.7646" class="difflineplus">+            m_numServerUnseenMessages, m_nextUID);</span>
<a href="#l20.7647"></a><span id="l20.7647">         m_autoSyncStateObj-&gt;OnNewHeaderFetchCompleted(keysToDownload);</span>
<a href="#l20.7648"></a><span id="l20.7648">       }</span>
<a href="#l20.7649"></a><span id="l20.7649">     }</span>
<a href="#l20.7650"></a><span id="l20.7650">     if (!notifiedBodies)</span>
<a href="#l20.7651"></a><span id="l20.7651" class="difflineminus">-      aProtocol-&gt;NotifyBodysToDownload(nullptr, 0/*keysToFetch.Length() */);</span>
<a href="#l20.7652"></a><span id="l20.7652" class="difflineminus">-</span>
<a href="#l20.7653"></a><span id="l20.7653" class="difflineminus">-    nsCOMPtr &lt;nsIURI&gt; runningUri;</span>
<a href="#l20.7654"></a><span id="l20.7654" class="difflineplus">+      aProtocol-&gt;NotifyBodysToDownload(nullptr, 0 /*keysToFetch.Length() */);</span>
<a href="#l20.7655"></a><span id="l20.7655" class="difflineplus">+</span>
<a href="#l20.7656"></a><span id="l20.7656" class="difflineplus">+    nsCOMPtr&lt;nsIURI&gt; runningUri;</span>
<a href="#l20.7657"></a><span id="l20.7657">     aProtocol-&gt;GetRunningUrl(getter_AddRefs(runningUri));</span>
<a href="#l20.7658"></a><span id="l20.7658" class="difflineminus">-    if (runningUri)</span>
<a href="#l20.7659"></a><span id="l20.7659" class="difflineminus">-    {</span>
<a href="#l20.7660"></a><span id="l20.7660" class="difflineminus">-      nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(runningUri);</span>
<a href="#l20.7661"></a><span id="l20.7661" class="difflineminus">-      if (mailnewsUrl)</span>
<a href="#l20.7662"></a><span id="l20.7662" class="difflineminus">-        mailnewsUrl-&gt;GetMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l20.7663"></a><span id="l20.7663" class="difflineplus">+    if (runningUri) {</span>
<a href="#l20.7664"></a><span id="l20.7664" class="difflineplus">+      nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(runningUri);</span>
<a href="#l20.7665"></a><span id="l20.7665" class="difflineplus">+      if (mailnewsUrl) mailnewsUrl-&gt;GetMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l20.7666"></a><span id="l20.7666">     }</span>
<a href="#l20.7667"></a><span id="l20.7667">   }</span>
<a href="#l20.7668"></a><span id="l20.7668"> </span>
<a href="#l20.7669"></a><span id="l20.7669">   // delay calling plugins if filter application is also delayed</span>
<a href="#l20.7670"></a><span id="l20.7670" class="difflineminus">-  if (!m_filterListRequiresBody)</span>
<a href="#l20.7671"></a><span id="l20.7671" class="difflineminus">-  {</span>
<a href="#l20.7672"></a><span id="l20.7672" class="difflineplus">+  if (!m_filterListRequiresBody) {</span>
<a href="#l20.7673"></a><span id="l20.7673">     bool filtersRun;</span>
<a href="#l20.7674"></a><span id="l20.7674">     CallFilterPlugins(msgWindow, &amp;filtersRun);</span>
<a href="#l20.7675"></a><span id="l20.7675">     if (!filtersRun &amp;&amp; m_performingBiff &amp;&amp; mDatabase &amp;&amp; numNewBiffMsgs &gt; 0 &amp;&amp;</span>
<a href="#l20.7676"></a><span id="l20.7676" class="difflineminus">-        (!pendingMoves || !ShowPreviewText()))</span>
<a href="#l20.7677"></a><span id="l20.7677" class="difflineminus">-    {</span>
<a href="#l20.7678"></a><span id="l20.7678" class="difflineplus">+        (!pendingMoves || !ShowPreviewText())) {</span>
<a href="#l20.7679"></a><span id="l20.7679">       // If we are performing biff for this folder, tell the</span>
<a href="#l20.7680"></a><span id="l20.7680">       // stand-alone biff about the new high water mark</span>
<a href="#l20.7681"></a><span id="l20.7681">       // We must ensure that the server knows that we are performing biff.</span>
<a href="#l20.7682"></a><span id="l20.7682">       // Otherwise the stand-alone biff won't fire.</span>
<a href="#l20.7683"></a><span id="l20.7683">       nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.7684"></a><span id="l20.7684">       if (NS_SUCCEEDED(GetServer(getter_AddRefs(server))) &amp;&amp; server)</span>
<a href="#l20.7685"></a><span id="l20.7685">         server-&gt;SetPerformingBiff(true);</span>
<a href="#l20.7686"></a><span id="l20.7686"> </span>
<a href="#l20.7687"></a><span id="l20.7687">       SetBiffState(nsIMsgFolder::nsMsgBiffState_NewMail);</span>
<a href="#l20.7688"></a><span id="l20.7688" class="difflineminus">-      if (server)</span>
<a href="#l20.7689"></a><span id="l20.7689" class="difflineminus">-        server-&gt;SetPerformingBiff(false);</span>
<a href="#l20.7690"></a><span id="l20.7690" class="difflineplus">+      if (server) server-&gt;SetPerformingBiff(false);</span>
<a href="#l20.7691"></a><span id="l20.7691">       m_performingBiff = false;</span>
<a href="#l20.7692"></a><span id="l20.7692">     }</span>
<a href="#l20.7693"></a><span id="l20.7693"> </span>
<a href="#l20.7694"></a><span id="l20.7694" class="difflineminus">-    if (m_filterList)</span>
<a href="#l20.7695"></a><span id="l20.7695" class="difflineminus">-      (void)m_filterList-&gt;FlushLogIfNecessary();</span>
<a href="#l20.7696"></a><span id="l20.7696" class="difflineplus">+    if (m_filterList) (void)m_filterList-&gt;FlushLogIfNecessary();</span>
<a href="#l20.7697"></a><span id="l20.7697">   }</span>
<a href="#l20.7698"></a><span id="l20.7698"> </span>
<a href="#l20.7699"></a><span id="l20.7699">   return NS_OK;</span>
<a href="#l20.7700"></a><span id="l20.7700"> }</span>
<a href="#l20.7701"></a><span id="l20.7701"> </span>
<a href="#l20.7702"></a><span id="l20.7702"> NS_IMETHODIMP</span>
<a href="#l20.7703"></a><span id="l20.7703" class="difflineminus">-nsImapMailFolder::SetBiffStateAndUpdate(nsMsgBiffState biffState)</span>
<a href="#l20.7704"></a><span id="l20.7704" class="difflineminus">-{</span>
<a href="#l20.7705"></a><span id="l20.7705" class="difflineplus">+nsImapMailFolder::SetBiffStateAndUpdate(nsMsgBiffState biffState) {</span>
<a href="#l20.7706"></a><span id="l20.7706">   SetBiffState(biffState);</span>
<a href="#l20.7707"></a><span id="l20.7707">   return NS_OK;</span>
<a href="#l20.7708"></a><span id="l20.7708"> }</span>
<a href="#l20.7709"></a><span id="l20.7709"> </span>
<a href="#l20.7710"></a><span id="l20.7710"> NS_IMETHODIMP</span>
<a href="#l20.7711"></a><span id="l20.7711" class="difflineminus">-nsImapMailFolder::GetUidValidity(int32_t *uidValidity)</span>
<a href="#l20.7712"></a><span id="l20.7712" class="difflineminus">-{</span>
<a href="#l20.7713"></a><span id="l20.7713" class="difflineplus">+nsImapMailFolder::GetUidValidity(int32_t *uidValidity) {</span>
<a href="#l20.7714"></a><span id="l20.7714">   NS_ENSURE_ARG(uidValidity);</span>
<a href="#l20.7715"></a><span id="l20.7715" class="difflineminus">-  if ((int32_t)m_uidValidity == kUidUnknown)</span>
<a href="#l20.7716"></a><span id="l20.7716" class="difflineminus">-  {</span>
<a href="#l20.7717"></a><span id="l20.7717" class="difflineplus">+  if ((int32_t)m_uidValidity == kUidUnknown) {</span>
<a href="#l20.7718"></a><span id="l20.7718">     nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l20.7719"></a><span id="l20.7719">     nsCOMPtr&lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l20.7720"></a><span id="l20.7720" class="difflineminus">-    (void) GetDBFolderInfoAndDB(getter_AddRefs(dbFolderInfo), getter_AddRefs(db));</span>
<a href="#l20.7721"></a><span id="l20.7721" class="difflineminus">-    if (db)</span>
<a href="#l20.7722"></a><span id="l20.7722" class="difflineminus">-      db-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l20.7723"></a><span id="l20.7723" class="difflineplus">+    (void)GetDBFolderInfoAndDB(getter_AddRefs(dbFolderInfo),</span>
<a href="#l20.7724"></a><span id="l20.7724" class="difflineplus">+                               getter_AddRefs(db));</span>
<a href="#l20.7725"></a><span id="l20.7725" class="difflineplus">+    if (db) db-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l20.7726"></a><span id="l20.7726"> </span>
<a href="#l20.7727"></a><span id="l20.7727">     if (dbFolderInfo)</span>
<a href="#l20.7728"></a><span id="l20.7728" class="difflineminus">-      dbFolderInfo-&gt;GetImapUidValidity((int32_t *) &amp;m_uidValidity);</span>
<a href="#l20.7729"></a><span id="l20.7729" class="difflineplus">+      dbFolderInfo-&gt;GetImapUidValidity((int32_t *)&amp;m_uidValidity);</span>
<a href="#l20.7730"></a><span id="l20.7730">   }</span>
<a href="#l20.7731"></a><span id="l20.7731">   *uidValidity = m_uidValidity;</span>
<a href="#l20.7732"></a><span id="l20.7732">   return NS_OK;</span>
<a href="#l20.7733"></a><span id="l20.7733"> }</span>
<a href="#l20.7734"></a><span id="l20.7734"> </span>
<a href="#l20.7735"></a><span id="l20.7735"> NS_IMETHODIMP</span>
<a href="#l20.7736"></a><span id="l20.7736" class="difflineminus">-nsImapMailFolder::SetUidValidity(int32_t uidValidity)</span>
<a href="#l20.7737"></a><span id="l20.7737" class="difflineminus">-{</span>
<a href="#l20.7738"></a><span id="l20.7738" class="difflineplus">+nsImapMailFolder::SetUidValidity(int32_t uidValidity) {</span>
<a href="#l20.7739"></a><span id="l20.7739">   m_uidValidity = uidValidity;</span>
<a href="#l20.7740"></a><span id="l20.7740">   return NS_OK;</span>
<a href="#l20.7741"></a><span id="l20.7741"> }</span>
<a href="#l20.7742"></a><span id="l20.7742"> </span>
<a href="#l20.7743"></a><span id="l20.7743"> NS_IMETHODIMP</span>
<a href="#l20.7744"></a><span id="l20.7744" class="difflineminus">-nsImapMailFolder::FillInFolderProps(nsIMsgImapFolderProps *aFolderProps)</span>
<a href="#l20.7745"></a><span id="l20.7745" class="difflineminus">-{</span>
<a href="#l20.7746"></a><span id="l20.7746" class="difflineplus">+nsImapMailFolder::FillInFolderProps(nsIMsgImapFolderProps *aFolderProps) {</span>
<a href="#l20.7747"></a><span id="l20.7747">   NS_ENSURE_ARG(aFolderProps);</span>
<a href="#l20.7748"></a><span id="l20.7748" class="difflineminus">-  const char* folderTypeStringID;</span>
<a href="#l20.7749"></a><span id="l20.7749" class="difflineminus">-  const char* folderTypeDescStringID = nullptr;</span>
<a href="#l20.7750"></a><span id="l20.7750" class="difflineminus">-  const char* folderQuotaStatusStringID;</span>
<a href="#l20.7751"></a><span id="l20.7751" class="difflineplus">+  const char *folderTypeStringID;</span>
<a href="#l20.7752"></a><span id="l20.7752" class="difflineplus">+  const char *folderTypeDescStringID = nullptr;</span>
<a href="#l20.7753"></a><span id="l20.7753" class="difflineplus">+  const char *folderQuotaStatusStringID;</span>
<a href="#l20.7754"></a><span id="l20.7754">   nsString folderType;</span>
<a href="#l20.7755"></a><span id="l20.7755">   nsString folderTypeDesc;</span>
<a href="#l20.7756"></a><span id="l20.7756">   nsString folderQuotaStatusDesc;</span>
<a href="#l20.7757"></a><span id="l20.7757">   nsCOMPtr&lt;nsIStringBundle&gt; bundle;</span>
<a href="#l20.7758"></a><span id="l20.7758">   nsresult rv = IMAPGetStringBundle(getter_AddRefs(bundle));</span>
<a href="#l20.7759"></a><span id="l20.7759">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.7760"></a><span id="l20.7760"> </span>
<a href="#l20.7761"></a><span id="l20.7761">   // get the host session list and get server capabilities.</span>
<a href="#l20.7762"></a><span id="l20.7762">   eIMAPCapabilityFlags capability = kCapabilityUndefined;</span>
<a href="#l20.7763"></a><span id="l20.7763"> </span>
<a href="#l20.7764"></a><span id="l20.7764">   nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.7765"></a><span id="l20.7765">   rv = GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.7766"></a><span id="l20.7766" class="difflineminus">-  // if for some bizarre reason this fails, we'll still fall through to the normal sharing code</span>
<a href="#l20.7767"></a><span id="l20.7767" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l20.7768"></a><span id="l20.7768" class="difflineminus">-  {</span>
<a href="#l20.7769"></a><span id="l20.7769" class="difflineplus">+  // if for some bizarre reason this fails, we'll still fall through to the</span>
<a href="#l20.7770"></a><span id="l20.7770" class="difflineplus">+  // normal sharing code</span>
<a href="#l20.7771"></a><span id="l20.7771" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.7772"></a><span id="l20.7772">     bool haveACL = false;</span>
<a href="#l20.7773"></a><span id="l20.7773">     bool haveQuota = false;</span>
<a href="#l20.7774"></a><span id="l20.7774">     imapServer-&gt;GetCapabilityACL(&amp;haveACL);</span>
<a href="#l20.7775"></a><span id="l20.7775">     imapServer-&gt;GetCapabilityQuota(&amp;haveQuota);</span>
<a href="#l20.7776"></a><span id="l20.7776"> </span>
<a href="#l20.7777"></a><span id="l20.7777">     // Figure out what to display in the Quota tab of the folder properties.</span>
<a href="#l20.7778"></a><span id="l20.7778">     // Does the server support quotas?</span>
<a href="#l20.7779"></a><span id="l20.7779" class="difflineminus">-    if (haveQuota)</span>
<a href="#l20.7780"></a><span id="l20.7780" class="difflineminus">-    {</span>
<a href="#l20.7781"></a><span id="l20.7781" class="difflineplus">+    if (haveQuota) {</span>
<a href="#l20.7782"></a><span id="l20.7782">       // Have we asked the server for quota information?</span>
<a href="#l20.7783"></a><span id="l20.7783" class="difflineminus">-      if(m_folderQuotaCommandIssued)</span>
<a href="#l20.7784"></a><span id="l20.7784" class="difflineminus">-      {</span>
<a href="#l20.7785"></a><span id="l20.7785" class="difflineplus">+      if (m_folderQuotaCommandIssued) {</span>
<a href="#l20.7786"></a><span id="l20.7786">         // Has the server replied with storage quota info?</span>
<a href="#l20.7787"></a><span id="l20.7787" class="difflineminus">-        if(m_folderQuotaDataIsValid)</span>
<a href="#l20.7788"></a><span id="l20.7788" class="difflineminus">-        {</span>
<a href="#l20.7789"></a><span id="l20.7789" class="difflineplus">+        if (m_folderQuotaDataIsValid) {</span>
<a href="#l20.7790"></a><span id="l20.7790">           // If so, set quota data</span>
<a href="#l20.7791"></a><span id="l20.7791">           folderQuotaStatusStringID = nullptr;</span>
<a href="#l20.7792"></a><span id="l20.7792" class="difflineminus">-          aFolderProps-&gt;SetQuotaData(m_folderQuotaRoot, m_folderQuotaUsedKB, m_folderQuotaMaxKB);</span>
<a href="#l20.7793"></a><span id="l20.7793" class="difflineminus">-        }</span>
<a href="#l20.7794"></a><span id="l20.7794" class="difflineminus">-        else</span>
<a href="#l20.7795"></a><span id="l20.7795" class="difflineminus">-        {</span>
<a href="#l20.7796"></a><span id="l20.7796" class="difflineplus">+          aFolderProps-&gt;SetQuotaData(m_folderQuotaRoot, m_folderQuotaUsedKB,</span>
<a href="#l20.7797"></a><span id="l20.7797" class="difflineplus">+                                     m_folderQuotaMaxKB);</span>
<a href="#l20.7798"></a><span id="l20.7798" class="difflineplus">+        } else {</span>
<a href="#l20.7799"></a><span id="l20.7799">           // If not, there is no storage quota set on this folder</span>
<a href="#l20.7800"></a><span id="l20.7800">           folderQuotaStatusStringID = &quot;imapQuotaStatusNoQuota&quot;;</span>
<a href="#l20.7801"></a><span id="l20.7801">         }</span>
<a href="#l20.7802"></a><span id="l20.7802" class="difflineminus">-      }</span>
<a href="#l20.7803"></a><span id="l20.7803" class="difflineminus">-      else</span>
<a href="#l20.7804"></a><span id="l20.7804" class="difflineminus">-      {</span>
<a href="#l20.7805"></a><span id="l20.7805" class="difflineplus">+      } else {</span>
<a href="#l20.7806"></a><span id="l20.7806">         // The folder is not open, so no quota information is available</span>
<a href="#l20.7807"></a><span id="l20.7807">         folderQuotaStatusStringID = &quot;imapQuotaStatusFolderNotOpen&quot;;</span>
<a href="#l20.7808"></a><span id="l20.7808">       }</span>
<a href="#l20.7809"></a><span id="l20.7809" class="difflineminus">-    }</span>
<a href="#l20.7810"></a><span id="l20.7810" class="difflineminus">-    else</span>
<a href="#l20.7811"></a><span id="l20.7811" class="difflineminus">-    {</span>
<a href="#l20.7812"></a><span id="l20.7812" class="difflineplus">+    } else {</span>
<a href="#l20.7813"></a><span id="l20.7813">       // Either the server doesn't support quotas, or we don't know if it does</span>
<a href="#l20.7814"></a><span id="l20.7814" class="difflineminus">-      // (e.g., because we don't have a connection yet). If the latter, we fall back</span>
<a href="#l20.7815"></a><span id="l20.7815" class="difflineminus">-      // to saying that no information is available because the folder is not open.</span>
<a href="#l20.7816"></a><span id="l20.7816" class="difflineminus">-      folderQuotaStatusStringID = (capability == kCapabilityUndefined) ?</span>
<a href="#l20.7817"></a><span id="l20.7817" class="difflineminus">-        &quot;imapQuotaStatusFolderNotOpen&quot; :</span>
<a href="#l20.7818"></a><span id="l20.7818" class="difflineminus">-        &quot;imapQuotaStatusNotSupported&quot;;</span>
<a href="#l20.7819"></a><span id="l20.7819" class="difflineminus">-    }</span>
<a href="#l20.7820"></a><span id="l20.7820" class="difflineminus">-</span>
<a href="#l20.7821"></a><span id="l20.7821" class="difflineminus">-    if(!folderQuotaStatusStringID)</span>
<a href="#l20.7822"></a><span id="l20.7822" class="difflineminus">-    {</span>
<a href="#l20.7823"></a><span id="l20.7823" class="difflineplus">+      // (e.g., because we don't have a connection yet). If the latter, we fall</span>
<a href="#l20.7824"></a><span id="l20.7824" class="difflineplus">+      // back to saying that no information is available because the folder is</span>
<a href="#l20.7825"></a><span id="l20.7825" class="difflineplus">+      // not open.</span>
<a href="#l20.7826"></a><span id="l20.7826" class="difflineplus">+      folderQuotaStatusStringID = (capability == kCapabilityUndefined)</span>
<a href="#l20.7827"></a><span id="l20.7827" class="difflineplus">+                                      ? &quot;imapQuotaStatusFolderNotOpen&quot;</span>
<a href="#l20.7828"></a><span id="l20.7828" class="difflineplus">+                                      : &quot;imapQuotaStatusNotSupported&quot;;</span>
<a href="#l20.7829"></a><span id="l20.7829" class="difflineplus">+    }</span>
<a href="#l20.7830"></a><span id="l20.7830" class="difflineplus">+</span>
<a href="#l20.7831"></a><span id="l20.7831" class="difflineplus">+    if (!folderQuotaStatusStringID) {</span>
<a href="#l20.7832"></a><span id="l20.7832">       // Display quota data</span>
<a href="#l20.7833"></a><span id="l20.7833">       aFolderProps-&gt;ShowQuotaData(true);</span>
<a href="#l20.7834"></a><span id="l20.7834" class="difflineminus">-    }</span>
<a href="#l20.7835"></a><span id="l20.7835" class="difflineminus">-    else</span>
<a href="#l20.7836"></a><span id="l20.7836" class="difflineminus">-    {</span>
<a href="#l20.7837"></a><span id="l20.7837" class="difflineplus">+    } else {</span>
<a href="#l20.7838"></a><span id="l20.7838">       // Hide quota data and show reason why it is not available</span>
<a href="#l20.7839"></a><span id="l20.7839">       aFolderProps-&gt;ShowQuotaData(false);</span>
<a href="#l20.7840"></a><span id="l20.7840"> </span>
<a href="#l20.7841"></a><span id="l20.7841">       rv = IMAPGetStringByName(folderQuotaStatusStringID,</span>
<a href="#l20.7842"></a><span id="l20.7842">                                getter_Copies(folderQuotaStatusDesc));</span>
<a href="#l20.7843"></a><span id="l20.7843" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l20.7844"></a><span id="l20.7844" class="difflineminus">-        aFolderProps-&gt;SetQuotaStatus(folderQuotaStatusDesc);</span>
<a href="#l20.7845"></a><span id="l20.7845" class="difflineplus">+      if (NS_SUCCEEDED(rv)) aFolderProps-&gt;SetQuotaStatus(folderQuotaStatusDesc);</span>
<a href="#l20.7846"></a><span id="l20.7846">     }</span>
<a href="#l20.7847"></a><span id="l20.7847"> </span>
<a href="#l20.7848"></a><span id="l20.7848">     // See if the server supports ACL.</span>
<a href="#l20.7849"></a><span id="l20.7849">     // If not, just set the folder description to a string that says</span>
<a href="#l20.7850"></a><span id="l20.7850">     // the server doesn't support sharing, and return.</span>
<a href="#l20.7851"></a><span id="l20.7851" class="difflineminus">-    if (!haveACL)</span>
<a href="#l20.7852"></a><span id="l20.7852" class="difflineminus">-    {</span>
<a href="#l20.7853"></a><span id="l20.7853" class="difflineplus">+    if (!haveACL) {</span>
<a href="#l20.7854"></a><span id="l20.7854">       rv = IMAPGetStringByName(&quot;imapServerDoesntSupportAcl&quot;,</span>
<a href="#l20.7855"></a><span id="l20.7855">                                getter_Copies(folderTypeDesc));</span>
<a href="#l20.7856"></a><span id="l20.7856">       if (NS_SUCCEEDED(rv))</span>
<a href="#l20.7857"></a><span id="l20.7857">         aFolderProps-&gt;SetFolderTypeDescription(folderTypeDesc);</span>
<a href="#l20.7858"></a><span id="l20.7858">       aFolderProps-&gt;ServerDoesntSupportACL();</span>
<a href="#l20.7859"></a><span id="l20.7859">       return NS_OK;</span>
<a href="#l20.7860"></a><span id="l20.7860">     }</span>
<a href="#l20.7861"></a><span id="l20.7861">   }</span>
<a href="#l20.7862"></a><span id="l20.7862" class="difflineminus">-  if (mFlags &amp; nsMsgFolderFlags::ImapPublic)</span>
<a href="#l20.7863"></a><span id="l20.7863" class="difflineminus">-  {</span>
<a href="#l20.7864"></a><span id="l20.7864" class="difflineplus">+  if (mFlags &amp; nsMsgFolderFlags::ImapPublic) {</span>
<a href="#l20.7865"></a><span id="l20.7865">     folderTypeStringID = &quot;imapPublicFolderTypeName&quot;;</span>
<a href="#l20.7866"></a><span id="l20.7866">     folderTypeDescStringID = &quot;imapPublicFolderTypeDescription&quot;;</span>
<a href="#l20.7867"></a><span id="l20.7867" class="difflineminus">-  }</span>
<a href="#l20.7868"></a><span id="l20.7868" class="difflineminus">-  else if (mFlags &amp; nsMsgFolderFlags::ImapOtherUser)</span>
<a href="#l20.7869"></a><span id="l20.7869" class="difflineminus">-  {</span>
<a href="#l20.7870"></a><span id="l20.7870" class="difflineplus">+  } else if (mFlags &amp; nsMsgFolderFlags::ImapOtherUser) {</span>
<a href="#l20.7871"></a><span id="l20.7871">     folderTypeStringID = &quot;imapOtherUsersFolderTypeName&quot;;</span>
<a href="#l20.7872"></a><span id="l20.7872">     nsCString owner;</span>
<a href="#l20.7873"></a><span id="l20.7873">     nsString uniOwner;</span>
<a href="#l20.7874"></a><span id="l20.7874">     GetFolderOwnerUserName(owner);</span>
<a href="#l20.7875"></a><span id="l20.7875" class="difflineminus">-    if (owner.IsEmpty())</span>
<a href="#l20.7876"></a><span id="l20.7876" class="difflineminus">-    {</span>
<a href="#l20.7877"></a><span id="l20.7877" class="difflineminus">-      rv = IMAPGetStringByName(folderTypeStringID,</span>
<a href="#l20.7878"></a><span id="l20.7878" class="difflineminus">-                               getter_Copies(uniOwner));</span>
<a href="#l20.7879"></a><span id="l20.7879" class="difflineplus">+    if (owner.IsEmpty()) {</span>
<a href="#l20.7880"></a><span id="l20.7880" class="difflineplus">+      rv = IMAPGetStringByName(folderTypeStringID, getter_Copies(uniOwner));</span>
<a href="#l20.7881"></a><span id="l20.7881">       // Another user's folder, for which we couldn't find an owner name</span>
<a href="#l20.7882"></a><span id="l20.7882">       NS_ASSERTION(false, &quot;couldn't get owner name for other user's folder&quot;);</span>
<a href="#l20.7883"></a><span id="l20.7883" class="difflineminus">-    }</span>
<a href="#l20.7884"></a><span id="l20.7884" class="difflineminus">-    else</span>
<a href="#l20.7885"></a><span id="l20.7885" class="difflineminus">-    {</span>
<a href="#l20.7886"></a><span id="l20.7886" class="difflineplus">+    } else {</span>
<a href="#l20.7887"></a><span id="l20.7887">       // is this right? It doesn't leak, does it?</span>
<a href="#l20.7888"></a><span id="l20.7888">       CopyASCIItoUTF16(owner, uniOwner);</span>
<a href="#l20.7889"></a><span id="l20.7889">     }</span>
<a href="#l20.7890"></a><span id="l20.7890" class="difflineminus">-    const char16_t *params[] = { uniOwner.get() };</span>
<a href="#l20.7891"></a><span id="l20.7891" class="difflineminus">-    rv = bundle-&gt;FormatStringFromName(</span>
<a href="#l20.7892"></a><span id="l20.7892" class="difflineminus">-      &quot;imapOtherUsersFolderTypeDescription&quot;,</span>
<a href="#l20.7893"></a><span id="l20.7893" class="difflineminus">-      params, 1, folderTypeDesc);</span>
<a href="#l20.7894"></a><span id="l20.7894" class="difflineminus">-  }</span>
<a href="#l20.7895"></a><span id="l20.7895" class="difflineminus">-  else if (GetFolderACL()-&gt;GetIsFolderShared())</span>
<a href="#l20.7896"></a><span id="l20.7896" class="difflineminus">-  {</span>
<a href="#l20.7897"></a><span id="l20.7897" class="difflineplus">+    const char16_t *params[] = {uniOwner.get()};</span>
<a href="#l20.7898"></a><span id="l20.7898" class="difflineplus">+    rv = bundle-&gt;FormatStringFromName(&quot;imapOtherUsersFolderTypeDescription&quot;,</span>
<a href="#l20.7899"></a><span id="l20.7899" class="difflineplus">+                                      params, 1, folderTypeDesc);</span>
<a href="#l20.7900"></a><span id="l20.7900" class="difflineplus">+  } else if (GetFolderACL()-&gt;GetIsFolderShared()) {</span>
<a href="#l20.7901"></a><span id="l20.7901">     folderTypeStringID = &quot;imapPersonalSharedFolderTypeName&quot;;</span>
<a href="#l20.7902"></a><span id="l20.7902">     folderTypeDescStringID = &quot;imapPersonalSharedFolderTypeDescription&quot;;</span>
<a href="#l20.7903"></a><span id="l20.7903" class="difflineminus">-  }</span>
<a href="#l20.7904"></a><span id="l20.7904" class="difflineminus">-  else</span>
<a href="#l20.7905"></a><span id="l20.7905" class="difflineminus">-  {</span>
<a href="#l20.7906"></a><span id="l20.7906" class="difflineplus">+  } else {</span>
<a href="#l20.7907"></a><span id="l20.7907">     folderTypeStringID = &quot;imapPersonalSharedFolderTypeName&quot;;</span>
<a href="#l20.7908"></a><span id="l20.7908">     folderTypeDescStringID = &quot;imapPersonalFolderTypeDescription&quot;;</span>
<a href="#l20.7909"></a><span id="l20.7909">   }</span>
<a href="#l20.7910"></a><span id="l20.7910"> </span>
<a href="#l20.7911"></a><span id="l20.7911" class="difflineminus">-  rv = IMAPGetStringByName(folderTypeStringID,</span>
<a href="#l20.7912"></a><span id="l20.7912" class="difflineminus">-                           getter_Copies(folderType));</span>
<a href="#l20.7913"></a><span id="l20.7913" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l20.7914"></a><span id="l20.7914" class="difflineminus">-    aFolderProps-&gt;SetFolderType(folderType);</span>
<a href="#l20.7915"></a><span id="l20.7915" class="difflineplus">+  rv = IMAPGetStringByName(folderTypeStringID, getter_Copies(folderType));</span>
<a href="#l20.7916"></a><span id="l20.7916" class="difflineplus">+  if (NS_SUCCEEDED(rv)) aFolderProps-&gt;SetFolderType(folderType);</span>
<a href="#l20.7917"></a><span id="l20.7917"> </span>
<a href="#l20.7918"></a><span id="l20.7918">   if (folderTypeDesc.IsEmpty() &amp;&amp; folderTypeDescStringID)</span>
<a href="#l20.7919"></a><span id="l20.7919">     rv = IMAPGetStringByName(folderTypeDescStringID,</span>
<a href="#l20.7920"></a><span id="l20.7920">                              getter_Copies(folderTypeDesc));</span>
<a href="#l20.7921"></a><span id="l20.7921">   if (!folderTypeDesc.IsEmpty())</span>
<a href="#l20.7922"></a><span id="l20.7922">     aFolderProps-&gt;SetFolderTypeDescription(folderTypeDesc);</span>
<a href="#l20.7923"></a><span id="l20.7923"> </span>
<a href="#l20.7924"></a><span id="l20.7924">   nsString rightsString;</span>
<a href="#l20.7925"></a><span id="l20.7925">   rv = CreateACLRightsStringForFolder(rightsString);</span>
<a href="#l20.7926"></a><span id="l20.7926" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l20.7927"></a><span id="l20.7927" class="difflineminus">-    aFolderProps-&gt;SetFolderPermissions(rightsString);</span>
<a href="#l20.7928"></a><span id="l20.7928" class="difflineplus">+  if (NS_SUCCEEDED(rv)) aFolderProps-&gt;SetFolderPermissions(rightsString);</span>
<a href="#l20.7929"></a><span id="l20.7929">   return NS_OK;</span>
<a href="#l20.7930"></a><span id="l20.7930"> }</span>
<a href="#l20.7931"></a><span id="l20.7931"> </span>
<a href="#l20.7932"></a><span id="l20.7932" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetAclFlags(uint32_t aclFlags)</span>
<a href="#l20.7933"></a><span id="l20.7933" class="difflineminus">-{</span>
<a href="#l20.7934"></a><span id="l20.7934" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetAclFlags(uint32_t aclFlags) {</span>
<a href="#l20.7935"></a><span id="l20.7935">   nsresult rv = NS_OK;</span>
<a href="#l20.7936"></a><span id="l20.7936" class="difflineminus">-  if (m_aclFlags != aclFlags)</span>
<a href="#l20.7937"></a><span id="l20.7937" class="difflineminus">-  {</span>
<a href="#l20.7938"></a><span id="l20.7938" class="difflineplus">+  if (m_aclFlags != aclFlags) {</span>
<a href="#l20.7939"></a><span id="l20.7939">     nsCOMPtr&lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l20.7940"></a><span id="l20.7940">     bool dbWasOpen = (mDatabase != nullptr);</span>
<a href="#l20.7941"></a><span id="l20.7941">     rv = GetDatabase();</span>
<a href="#l20.7942"></a><span id="l20.7942"> </span>
<a href="#l20.7943"></a><span id="l20.7943">     m_aclFlags = aclFlags;</span>
<a href="#l20.7944"></a><span id="l20.7944" class="difflineminus">-    if (mDatabase)</span>
<a href="#l20.7945"></a><span id="l20.7945" class="difflineminus">-    {</span>
<a href="#l20.7946"></a><span id="l20.7946" class="difflineplus">+    if (mDatabase) {</span>
<a href="#l20.7947"></a><span id="l20.7947">       rv = mDatabase-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l20.7948"></a><span id="l20.7948">       if (NS_SUCCEEDED(rv) &amp;&amp; dbFolderInfo)</span>
<a href="#l20.7949"></a><span id="l20.7949">         dbFolderInfo-&gt;SetUint32Property(&quot;aclFlags&quot;, aclFlags);</span>
<a href="#l20.7950"></a><span id="l20.7950">       // if setting the acl flags caused us to open the db, release the ref</span>
<a href="#l20.7951"></a><span id="l20.7951">       // because on startup, we might get acl on all folders,which will</span>
<a href="#l20.7952"></a><span id="l20.7952">       // leave a lot of db's open.</span>
<a href="#l20.7953"></a><span id="l20.7953" class="difflineminus">-      if (!dbWasOpen)</span>
<a href="#l20.7954"></a><span id="l20.7954" class="difflineminus">-      {</span>
<a href="#l20.7955"></a><span id="l20.7955" class="difflineplus">+      if (!dbWasOpen) {</span>
<a href="#l20.7956"></a><span id="l20.7956">         mDatabase-&gt;Close(true /* commit changes */);</span>
<a href="#l20.7957"></a><span id="l20.7957">         mDatabase = nullptr;</span>
<a href="#l20.7958"></a><span id="l20.7958">       }</span>
<a href="#l20.7959"></a><span id="l20.7959">     }</span>
<a href="#l20.7960"></a><span id="l20.7960">   }</span>
<a href="#l20.7961"></a><span id="l20.7961">   return rv;</span>
<a href="#l20.7962"></a><span id="l20.7962"> }</span>
<a href="#l20.7963"></a><span id="l20.7963"> </span>
<a href="#l20.7964"></a><span id="l20.7964" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetAclFlags(uint32_t *aclFlags)</span>
<a href="#l20.7965"></a><span id="l20.7965" class="difflineminus">-{</span>
<a href="#l20.7966"></a><span id="l20.7966" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetAclFlags(uint32_t *aclFlags) {</span>
<a href="#l20.7967"></a><span id="l20.7967">   NS_ENSURE_ARG_POINTER(aclFlags);</span>
<a href="#l20.7968"></a><span id="l20.7968">   nsresult rv;</span>
<a href="#l20.7969"></a><span id="l20.7969" class="difflineminus">-  ReadDBFolderInfo(false); // update cache first.</span>
<a href="#l20.7970"></a><span id="l20.7970" class="difflineminus">-  if (m_aclFlags == kAclInvalid) // -1 means invalid value, so get it from db.</span>
<a href="#l20.7971"></a><span id="l20.7971" class="difflineplus">+  ReadDBFolderInfo(false);        // update cache first.</span>
<a href="#l20.7972"></a><span id="l20.7972" class="difflineplus">+  if (m_aclFlags == kAclInvalid)  // -1 means invalid value, so get it from db.</span>
<a href="#l20.7973"></a><span id="l20.7973">   {</span>
<a href="#l20.7974"></a><span id="l20.7974">     nsCOMPtr&lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l20.7975"></a><span id="l20.7975">     bool dbWasOpen = (mDatabase != nullptr);</span>
<a href="#l20.7976"></a><span id="l20.7976">     rv = GetDatabase();</span>
<a href="#l20.7977"></a><span id="l20.7977"> </span>
<a href="#l20.7978"></a><span id="l20.7978" class="difflineminus">-    if (mDatabase)</span>
<a href="#l20.7979"></a><span id="l20.7979" class="difflineminus">-    {</span>
<a href="#l20.7980"></a><span id="l20.7980" class="difflineplus">+    if (mDatabase) {</span>
<a href="#l20.7981"></a><span id="l20.7981">       rv = mDatabase-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l20.7982"></a><span id="l20.7982" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; dbFolderInfo)</span>
<a href="#l20.7983"></a><span id="l20.7983" class="difflineminus">-      {</span>
<a href="#l20.7984"></a><span id="l20.7984" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; dbFolderInfo) {</span>
<a href="#l20.7985"></a><span id="l20.7985">         rv = dbFolderInfo-&gt;GetUint32Property(&quot;aclFlags&quot;, 0, aclFlags);</span>
<a href="#l20.7986"></a><span id="l20.7986">         m_aclFlags = *aclFlags;</span>
<a href="#l20.7987"></a><span id="l20.7987">       }</span>
<a href="#l20.7988"></a><span id="l20.7988">       // if getting the acl flags caused us to open the db, release the ref</span>
<a href="#l20.7989"></a><span id="l20.7989">       // because on startup, we might get acl on all folders,which will</span>
<a href="#l20.7990"></a><span id="l20.7990">       // leave a lot of db's open.</span>
<a href="#l20.7991"></a><span id="l20.7991" class="difflineminus">-      if (!dbWasOpen)</span>
<a href="#l20.7992"></a><span id="l20.7992" class="difflineminus">-      {</span>
<a href="#l20.7993"></a><span id="l20.7993" class="difflineplus">+      if (!dbWasOpen) {</span>
<a href="#l20.7994"></a><span id="l20.7994">         mDatabase-&gt;Close(true /* commit changes */);</span>
<a href="#l20.7995"></a><span id="l20.7995">         mDatabase = nullptr;</span>
<a href="#l20.7996"></a><span id="l20.7996">       }</span>
<a href="#l20.7997"></a><span id="l20.7997">     }</span>
<a href="#l20.7998"></a><span id="l20.7998" class="difflineminus">-  }</span>
<a href="#l20.7999"></a><span id="l20.7999" class="difflineminus">-  else</span>
<a href="#l20.8000"></a><span id="l20.8000" class="difflineplus">+  } else</span>
<a href="#l20.8001"></a><span id="l20.8001">     *aclFlags = m_aclFlags;</span>
<a href="#l20.8002"></a><span id="l20.8002">   return NS_OK;</span>
<a href="#l20.8003"></a><span id="l20.8003"> }</span>
<a href="#l20.8004"></a><span id="l20.8004"> </span>
<a href="#l20.8005"></a><span id="l20.8005" class="difflineminus">-nsresult nsImapMailFolder::SetSupportedUserFlags(uint32_t userFlags)</span>
<a href="#l20.8006"></a><span id="l20.8006" class="difflineminus">-{</span>
<a href="#l20.8007"></a><span id="l20.8007" class="difflineplus">+nsresult nsImapMailFolder::SetSupportedUserFlags(uint32_t userFlags) {</span>
<a href="#l20.8008"></a><span id="l20.8008">   nsCOMPtr&lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l20.8009"></a><span id="l20.8009">   nsresult rv = GetDatabase();</span>
<a href="#l20.8010"></a><span id="l20.8010"> </span>
<a href="#l20.8011"></a><span id="l20.8011">   m_supportedUserFlags = userFlags;</span>
<a href="#l20.8012"></a><span id="l20.8012" class="difflineminus">-  if (mDatabase)</span>
<a href="#l20.8013"></a><span id="l20.8013" class="difflineminus">-  {</span>
<a href="#l20.8014"></a><span id="l20.8014" class="difflineplus">+  if (mDatabase) {</span>
<a href="#l20.8015"></a><span id="l20.8015">     rv = mDatabase-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l20.8016"></a><span id="l20.8016">     if (NS_SUCCEEDED(rv) &amp;&amp; dbFolderInfo)</span>
<a href="#l20.8017"></a><span id="l20.8017">       dbFolderInfo-&gt;SetUint32Property(&quot;imapFlags&quot;, userFlags);</span>
<a href="#l20.8018"></a><span id="l20.8018">   }</span>
<a href="#l20.8019"></a><span id="l20.8019">   return rv;</span>
<a href="#l20.8020"></a><span id="l20.8020"> }</span>
<a href="#l20.8021"></a><span id="l20.8021"> </span>
<a href="#l20.8022"></a><span id="l20.8022" class="difflineminus">-nsresult nsImapMailFolder::GetSupportedUserFlags(uint32_t *userFlags)</span>
<a href="#l20.8023"></a><span id="l20.8023" class="difflineminus">-{</span>
<a href="#l20.8024"></a><span id="l20.8024" class="difflineplus">+nsresult nsImapMailFolder::GetSupportedUserFlags(uint32_t *userFlags) {</span>
<a href="#l20.8025"></a><span id="l20.8025">   NS_ENSURE_ARG_POINTER(userFlags);</span>
<a href="#l20.8026"></a><span id="l20.8026"> </span>
<a href="#l20.8027"></a><span id="l20.8027">   nsresult rv = NS_OK;</span>
<a href="#l20.8028"></a><span id="l20.8028"> </span>
<a href="#l20.8029"></a><span id="l20.8029" class="difflineminus">-  ReadDBFolderInfo(false); // update cache first.</span>
<a href="#l20.8030"></a><span id="l20.8030" class="difflineminus">-  if (m_supportedUserFlags == 0) // 0 means invalid value, so get it from db.</span>
<a href="#l20.8031"></a><span id="l20.8031" class="difflineplus">+  ReadDBFolderInfo(false);        // update cache first.</span>
<a href="#l20.8032"></a><span id="l20.8032" class="difflineplus">+  if (m_supportedUserFlags == 0)  // 0 means invalid value, so get it from db.</span>
<a href="#l20.8033"></a><span id="l20.8033">   {</span>
<a href="#l20.8034"></a><span id="l20.8034">     nsCOMPtr&lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l20.8035"></a><span id="l20.8035">     rv = GetDatabase();</span>
<a href="#l20.8036"></a><span id="l20.8036"> </span>
<a href="#l20.8037"></a><span id="l20.8037" class="difflineminus">-    if (mDatabase)</span>
<a href="#l20.8038"></a><span id="l20.8038" class="difflineminus">-    {</span>
<a href="#l20.8039"></a><span id="l20.8039" class="difflineplus">+    if (mDatabase) {</span>
<a href="#l20.8040"></a><span id="l20.8040">       rv = mDatabase-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l20.8041"></a><span id="l20.8041" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; dbFolderInfo)</span>
<a href="#l20.8042"></a><span id="l20.8042" class="difflineminus">-      {</span>
<a href="#l20.8043"></a><span id="l20.8043" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; dbFolderInfo) {</span>
<a href="#l20.8044"></a><span id="l20.8044">         rv = dbFolderInfo-&gt;GetUint32Property(&quot;imapFlags&quot;, 0, userFlags);</span>
<a href="#l20.8045"></a><span id="l20.8045">         m_supportedUserFlags = *userFlags;</span>
<a href="#l20.8046"></a><span id="l20.8046">       }</span>
<a href="#l20.8047"></a><span id="l20.8047">     }</span>
<a href="#l20.8048"></a><span id="l20.8048" class="difflineminus">-  }</span>
<a href="#l20.8049"></a><span id="l20.8049" class="difflineminus">-  else</span>
<a href="#l20.8050"></a><span id="l20.8050" class="difflineplus">+  } else</span>
<a href="#l20.8051"></a><span id="l20.8051">     *userFlags = m_supportedUserFlags;</span>
<a href="#l20.8052"></a><span id="l20.8052">   return rv;</span>
<a href="#l20.8053"></a><span id="l20.8053"> }</span>
<a href="#l20.8054"></a><span id="l20.8054"> </span>
<a href="#l20.8055"></a><span id="l20.8055" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetCanOpenFolder(bool *aBool)</span>
<a href="#l20.8056"></a><span id="l20.8056" class="difflineminus">-{</span>
<a href="#l20.8057"></a><span id="l20.8057" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetCanOpenFolder(bool *aBool) {</span>
<a href="#l20.8058"></a><span id="l20.8058">   NS_ENSURE_ARG_POINTER(aBool);</span>
<a href="#l20.8059"></a><span id="l20.8059">   bool noSelect;</span>
<a href="#l20.8060"></a><span id="l20.8060">   GetFlag(nsMsgFolderFlags::ImapNoselect, &amp;noSelect);</span>
<a href="#l20.8061"></a><span id="l20.8061">   *aBool = (noSelect) ? false : GetFolderACL()-&gt;GetCanIReadFolder();</span>
<a href="#l20.8062"></a><span id="l20.8062">   return NS_OK;</span>
<a href="#l20.8063"></a><span id="l20.8063"> }</span>
<a href="#l20.8064"></a><span id="l20.8064"> </span>
<a href="#l20.8065"></a><span id="l20.8065"> ///////// nsMsgIMAPFolderACL class ///////////////////////////////</span>
<a href="#l20.8066"></a><span id="l20.8066"> </span>
<a href="#l20.8067"></a><span id="l20.8067"> // This string is defined in the ACL RFC to be &quot;anyone&quot;</span>
<a href="#l20.8068"></a><span id="l20.8068"> #define IMAP_ACL_ANYONE_STRING &quot;anyone&quot;</span>
<a href="#l20.8069"></a><span id="l20.8069"> </span>
<a href="#l20.8070"></a><span id="l20.8070"> nsMsgIMAPFolderACL::nsMsgIMAPFolderACL(nsImapMailFolder *folder)</span>
<a href="#l20.8071"></a><span id="l20.8071" class="difflineminus">-: m_rightsHash(24)</span>
<a href="#l20.8072"></a><span id="l20.8072" class="difflineminus">-{</span>
<a href="#l20.8073"></a><span id="l20.8073" class="difflineplus">+    : m_rightsHash(24) {</span>
<a href="#l20.8074"></a><span id="l20.8074">   NS_ASSERTION(folder, &quot;need folder&quot;);</span>
<a href="#l20.8075"></a><span id="l20.8075">   m_folder = folder;</span>
<a href="#l20.8076"></a><span id="l20.8076">   m_aclCount = 0;</span>
<a href="#l20.8077"></a><span id="l20.8077">   BuildInitialACLFromCache();</span>
<a href="#l20.8078"></a><span id="l20.8078"> }</span>
<a href="#l20.8079"></a><span id="l20.8079"> </span>
<a href="#l20.8080"></a><span id="l20.8080" class="difflineminus">-nsMsgIMAPFolderACL::~nsMsgIMAPFolderACL()</span>
<a href="#l20.8081"></a><span id="l20.8081" class="difflineminus">-{</span>
<a href="#l20.8082"></a><span id="l20.8082" class="difflineminus">-}</span>
<a href="#l20.8083"></a><span id="l20.8083" class="difflineplus">+nsMsgIMAPFolderACL::~nsMsgIMAPFolderACL() {}</span>
<a href="#l20.8084"></a><span id="l20.8084"> </span>
<a href="#l20.8085"></a><span id="l20.8085"> // We cache most of our own rights in the MSG_FOLDER_PREF_* flags</span>
<a href="#l20.8086"></a><span id="l20.8086" class="difflineminus">-void nsMsgIMAPFolderACL::BuildInitialACLFromCache()</span>
<a href="#l20.8087"></a><span id="l20.8087" class="difflineminus">-{</span>
<a href="#l20.8088"></a><span id="l20.8088" class="difflineplus">+void nsMsgIMAPFolderACL::BuildInitialACLFromCache() {</span>
<a href="#l20.8089"></a><span id="l20.8089">   nsAutoCString myrights;</span>
<a href="#l20.8090"></a><span id="l20.8090"> </span>
<a href="#l20.8091"></a><span id="l20.8091">   uint32_t startingFlags;</span>
<a href="#l20.8092"></a><span id="l20.8092">   m_folder-&gt;GetAclFlags(&amp;startingFlags);</span>
<a href="#l20.8093"></a><span id="l20.8093"> </span>
<a href="#l20.8094"></a><span id="l20.8094" class="difflineminus">-  if (startingFlags &amp; IMAP_ACL_READ_FLAG)</span>
<a href="#l20.8095"></a><span id="l20.8095" class="difflineminus">-    myrights += &quot;r&quot;;</span>
<a href="#l20.8096"></a><span id="l20.8096" class="difflineminus">-  if (startingFlags &amp; IMAP_ACL_STORE_SEEN_FLAG)</span>
<a href="#l20.8097"></a><span id="l20.8097" class="difflineminus">-    myrights += &quot;s&quot;;</span>
<a href="#l20.8098"></a><span id="l20.8098" class="difflineminus">-  if (startingFlags &amp; IMAP_ACL_WRITE_FLAG)</span>
<a href="#l20.8099"></a><span id="l20.8099" class="difflineminus">-    myrights += &quot;w&quot;;</span>
<a href="#l20.8100"></a><span id="l20.8100" class="difflineminus">-  if (startingFlags &amp; IMAP_ACL_INSERT_FLAG)</span>
<a href="#l20.8101"></a><span id="l20.8101" class="difflineminus">-    myrights += &quot;i&quot;;</span>
<a href="#l20.8102"></a><span id="l20.8102" class="difflineminus">-  if (startingFlags &amp; IMAP_ACL_POST_FLAG)</span>
<a href="#l20.8103"></a><span id="l20.8103" class="difflineminus">-    myrights += &quot;p&quot;;</span>
<a href="#l20.8104"></a><span id="l20.8104" class="difflineminus">-  if (startingFlags &amp; IMAP_ACL_CREATE_SUBFOLDER_FLAG)</span>
<a href="#l20.8105"></a><span id="l20.8105" class="difflineminus">-    myrights +=&quot;c&quot;;</span>
<a href="#l20.8106"></a><span id="l20.8106" class="difflineminus">-  if (startingFlags &amp; IMAP_ACL_DELETE_FLAG)</span>
<a href="#l20.8107"></a><span id="l20.8107" class="difflineminus">-    myrights += &quot;dt&quot;;</span>
<a href="#l20.8108"></a><span id="l20.8108" class="difflineminus">-  if (startingFlags &amp; IMAP_ACL_ADMINISTER_FLAG)</span>
<a href="#l20.8109"></a><span id="l20.8109" class="difflineminus">-    myrights += &quot;a&quot;;</span>
<a href="#l20.8110"></a><span id="l20.8110" class="difflineminus">-  if (startingFlags &amp; IMAP_ACL_EXPUNGE_FLAG)</span>
<a href="#l20.8111"></a><span id="l20.8111" class="difflineminus">-    myrights += &quot;e&quot;;</span>
<a href="#l20.8112"></a><span id="l20.8112" class="difflineminus">-</span>
<a href="#l20.8113"></a><span id="l20.8113" class="difflineminus">-  if (!myrights.IsEmpty())</span>
<a href="#l20.8114"></a><span id="l20.8114" class="difflineminus">-    SetFolderRightsForUser(EmptyCString(), myrights);</span>
<a href="#l20.8115"></a><span id="l20.8115" class="difflineminus">-}</span>
<a href="#l20.8116"></a><span id="l20.8116" class="difflineminus">-</span>
<a href="#l20.8117"></a><span id="l20.8117" class="difflineminus">-void nsMsgIMAPFolderACL::UpdateACLCache()</span>
<a href="#l20.8118"></a><span id="l20.8118" class="difflineminus">-{</span>
<a href="#l20.8119"></a><span id="l20.8119" class="difflineplus">+  if (startingFlags &amp; IMAP_ACL_READ_FLAG) myrights += &quot;r&quot;;</span>
<a href="#l20.8120"></a><span id="l20.8120" class="difflineplus">+  if (startingFlags &amp; IMAP_ACL_STORE_SEEN_FLAG) myrights += &quot;s&quot;;</span>
<a href="#l20.8121"></a><span id="l20.8121" class="difflineplus">+  if (startingFlags &amp; IMAP_ACL_WRITE_FLAG) myrights += &quot;w&quot;;</span>
<a href="#l20.8122"></a><span id="l20.8122" class="difflineplus">+  if (startingFlags &amp; IMAP_ACL_INSERT_FLAG) myrights += &quot;i&quot;;</span>
<a href="#l20.8123"></a><span id="l20.8123" class="difflineplus">+  if (startingFlags &amp; IMAP_ACL_POST_FLAG) myrights += &quot;p&quot;;</span>
<a href="#l20.8124"></a><span id="l20.8124" class="difflineplus">+  if (startingFlags &amp; IMAP_ACL_CREATE_SUBFOLDER_FLAG) myrights += &quot;c&quot;;</span>
<a href="#l20.8125"></a><span id="l20.8125" class="difflineplus">+  if (startingFlags &amp; IMAP_ACL_DELETE_FLAG) myrights += &quot;dt&quot;;</span>
<a href="#l20.8126"></a><span id="l20.8126" class="difflineplus">+  if (startingFlags &amp; IMAP_ACL_ADMINISTER_FLAG) myrights += &quot;a&quot;;</span>
<a href="#l20.8127"></a><span id="l20.8127" class="difflineplus">+  if (startingFlags &amp; IMAP_ACL_EXPUNGE_FLAG) myrights += &quot;e&quot;;</span>
<a href="#l20.8128"></a><span id="l20.8128" class="difflineplus">+</span>
<a href="#l20.8129"></a><span id="l20.8129" class="difflineplus">+  if (!myrights.IsEmpty()) SetFolderRightsForUser(EmptyCString(), myrights);</span>
<a href="#l20.8130"></a><span id="l20.8130" class="difflineplus">+}</span>
<a href="#l20.8131"></a><span id="l20.8131" class="difflineplus">+</span>
<a href="#l20.8132"></a><span id="l20.8132" class="difflineplus">+void nsMsgIMAPFolderACL::UpdateACLCache() {</span>
<a href="#l20.8133"></a><span id="l20.8133">   uint32_t startingFlags = 0;</span>
<a href="#l20.8134"></a><span id="l20.8134">   m_folder-&gt;GetAclFlags(&amp;startingFlags);</span>
<a href="#l20.8135"></a><span id="l20.8135"> </span>
<a href="#l20.8136"></a><span id="l20.8136">   if (GetCanIReadFolder())</span>
<a href="#l20.8137"></a><span id="l20.8137">     startingFlags |= IMAP_ACL_READ_FLAG;</span>
<a href="#l20.8138"></a><span id="l20.8138">   else</span>
<a href="#l20.8139"></a><span id="l20.8139">     startingFlags &amp;= ~IMAP_ACL_READ_FLAG;</span>
<a href="#l20.8140"></a><span id="l20.8140"> </span>
<a href="#l20.8141"></a><span id="l20.8141" class="difflineat">@@ -6326,810 +5783,720 @@ void nsMsgIMAPFolderACL::UpdateACLCache(</span>
<a href="#l20.8142"></a><span id="l20.8142">   if (GetCanIExpungeFolder())</span>
<a href="#l20.8143"></a><span id="l20.8143">     startingFlags |= IMAP_ACL_EXPUNGE_FLAG;</span>
<a href="#l20.8144"></a><span id="l20.8144">   else</span>
<a href="#l20.8145"></a><span id="l20.8145">     startingFlags &amp;= ~IMAP_ACL_EXPUNGE_FLAG;</span>
<a href="#l20.8146"></a><span id="l20.8146"> </span>
<a href="#l20.8147"></a><span id="l20.8147">   m_folder-&gt;SetAclFlags(startingFlags);</span>
<a href="#l20.8148"></a><span id="l20.8148"> }</span>
<a href="#l20.8149"></a><span id="l20.8149"> </span>
<a href="#l20.8150"></a><span id="l20.8150" class="difflineminus">-bool nsMsgIMAPFolderACL::SetFolderRightsForUser(const nsACString&amp; userName, const nsACString&amp; rights)</span>
<a href="#l20.8151"></a><span id="l20.8151" class="difflineminus">-{</span>
<a href="#l20.8152"></a><span id="l20.8152" class="difflineplus">+bool nsMsgIMAPFolderACL::SetFolderRightsForUser(const nsACString &amp;userName,</span>
<a href="#l20.8153"></a><span id="l20.8153" class="difflineplus">+                                                const nsACString &amp;rights) {</span>
<a href="#l20.8154"></a><span id="l20.8154">   nsCString myUserName;</span>
<a href="#l20.8155"></a><span id="l20.8155">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.8156"></a><span id="l20.8156">   nsresult rv = m_folder-&gt;GetServer(getter_AddRefs(server));</span>
<a href="#l20.8157"></a><span id="l20.8157">   NS_ENSURE_SUCCESS(rv, false);</span>
<a href="#l20.8158"></a><span id="l20.8158"> </span>
<a href="#l20.8159"></a><span id="l20.8159">   // we need the real user name to match with what the imap server returns</span>
<a href="#l20.8160"></a><span id="l20.8160">   // in the acl response.</span>
<a href="#l20.8161"></a><span id="l20.8161">   server-&gt;GetRealUsername(myUserName);</span>
<a href="#l20.8162"></a><span id="l20.8162"> </span>
<a href="#l20.8163"></a><span id="l20.8163">   nsAutoCString ourUserName;</span>
<a href="#l20.8164"></a><span id="l20.8164">   if (userName.IsEmpty())</span>
<a href="#l20.8165"></a><span id="l20.8165">     ourUserName.Assign(myUserName);</span>
<a href="#l20.8166"></a><span id="l20.8166">   else</span>
<a href="#l20.8167"></a><span id="l20.8167">     ourUserName.Assign(userName);</span>
<a href="#l20.8168"></a><span id="l20.8168"> </span>
<a href="#l20.8169"></a><span id="l20.8169" class="difflineminus">-  if (ourUserName.IsEmpty())</span>
<a href="#l20.8170"></a><span id="l20.8170" class="difflineminus">-    return false;</span>
<a href="#l20.8171"></a><span id="l20.8171" class="difflineplus">+  if (ourUserName.IsEmpty()) return false;</span>
<a href="#l20.8172"></a><span id="l20.8172"> </span>
<a href="#l20.8173"></a><span id="l20.8173">   ToLowerCase(ourUserName);</span>
<a href="#l20.8174"></a><span id="l20.8174">   nsCString oldValue;</span>
<a href="#l20.8175"></a><span id="l20.8175">   m_rightsHash.Get(ourUserName, &amp;oldValue);</span>
<a href="#l20.8176"></a><span id="l20.8176" class="difflineminus">-  if (!oldValue.IsEmpty())</span>
<a href="#l20.8177"></a><span id="l20.8177" class="difflineminus">-  {</span>
<a href="#l20.8178"></a><span id="l20.8178" class="difflineplus">+  if (!oldValue.IsEmpty()) {</span>
<a href="#l20.8179"></a><span id="l20.8179">     m_rightsHash.Remove(ourUserName);</span>
<a href="#l20.8180"></a><span id="l20.8180">     m_aclCount--;</span>
<a href="#l20.8181"></a><span id="l20.8181">     NS_ASSERTION(m_aclCount &gt;= 0, &quot;acl count can't go negative&quot;);</span>
<a href="#l20.8182"></a><span id="l20.8182">   }</span>
<a href="#l20.8183"></a><span id="l20.8183">   m_aclCount++;</span>
<a href="#l20.8184"></a><span id="l20.8184">   m_rightsHash.Put(ourUserName, PromiseFlatCString(rights));</span>
<a href="#l20.8185"></a><span id="l20.8185"> </span>
<a href="#l20.8186"></a><span id="l20.8186" class="difflineminus">-  if (myUserName.Equals(ourUserName) || ourUserName.EqualsLiteral(IMAP_ACL_ANYONE_STRING))</span>
<a href="#l20.8187"></a><span id="l20.8187" class="difflineplus">+  if (myUserName.Equals(ourUserName) ||</span>
<a href="#l20.8188"></a><span id="l20.8188" class="difflineplus">+      ourUserName.EqualsLiteral(IMAP_ACL_ANYONE_STRING))</span>
<a href="#l20.8189"></a><span id="l20.8189">     // if this is setting an ACL for me, cache it in the folder pref flags</span>
<a href="#l20.8190"></a><span id="l20.8190">     UpdateACLCache();</span>
<a href="#l20.8191"></a><span id="l20.8191"> </span>
<a href="#l20.8192"></a><span id="l20.8192">   return true;</span>
<a href="#l20.8193"></a><span id="l20.8193"> }</span>
<a href="#l20.8194"></a><span id="l20.8194"> </span>
<a href="#l20.8195"></a><span id="l20.8195"> NS_IMETHODIMP nsImapMailFolder::GetOtherUsersWithAccess(</span>
<a href="#l20.8196"></a><span id="l20.8196" class="difflineminus">-        nsIUTF8StringEnumerator** aResult)</span>
<a href="#l20.8197"></a><span id="l20.8197" class="difflineminus">-{</span>
<a href="#l20.8198"></a><span id="l20.8198" class="difflineplus">+    nsIUTF8StringEnumerator **aResult) {</span>
<a href="#l20.8199"></a><span id="l20.8199">   return GetFolderACL()-&gt;GetOtherUsers(aResult);</span>
<a href="#l20.8200"></a><span id="l20.8200"> }</span>
<a href="#l20.8201"></a><span id="l20.8201"> </span>
<a href="#l20.8202"></a><span id="l20.8202" class="difflineminus">-nsresult nsMsgIMAPFolderACL::GetOtherUsers(nsIUTF8StringEnumerator** aResult)</span>
<a href="#l20.8203"></a><span id="l20.8203" class="difflineminus">-{</span>
<a href="#l20.8204"></a><span id="l20.8204" class="difflineminus">-  nsTArray&lt;nsCString&gt;* resultArray = new nsTArray&lt;nsCString&gt;;</span>
<a href="#l20.8205"></a><span id="l20.8205" class="difflineplus">+nsresult nsMsgIMAPFolderACL::GetOtherUsers(nsIUTF8StringEnumerator **aResult) {</span>
<a href="#l20.8206"></a><span id="l20.8206" class="difflineplus">+  nsTArray&lt;nsCString&gt; *resultArray = new nsTArray&lt;nsCString&gt;;</span>
<a href="#l20.8207"></a><span id="l20.8207">   for (auto iter = m_rightsHash.Iter(); !iter.Done(); iter.Next()) {</span>
<a href="#l20.8208"></a><span id="l20.8208">     resultArray-&gt;AppendElement(iter.Key());</span>
<a href="#l20.8209"></a><span id="l20.8209">   }</span>
<a href="#l20.8210"></a><span id="l20.8210"> </span>
<a href="#l20.8211"></a><span id="l20.8211">   // enumerator will free resultArray</span>
<a href="#l20.8212"></a><span id="l20.8212">   return NS_NewAdoptingUTF8StringEnumerator(aResult, resultArray);</span>
<a href="#l20.8213"></a><span id="l20.8213"> }</span>
<a href="#l20.8214"></a><span id="l20.8214"> </span>
<a href="#l20.8215"></a><span id="l20.8215" class="difflineminus">-nsresult nsImapMailFolder::GetPermissionsForUser(const nsACString&amp; otherUser,</span>
<a href="#l20.8216"></a><span id="l20.8216" class="difflineminus">-        nsACString&amp; aResult)</span>
<a href="#l20.8217"></a><span id="l20.8217" class="difflineminus">-{</span>
<a href="#l20.8218"></a><span id="l20.8218" class="difflineplus">+nsresult nsImapMailFolder::GetPermissionsForUser(const nsACString &amp;otherUser,</span>
<a href="#l20.8219"></a><span id="l20.8219" class="difflineplus">+                                                 nsACString &amp;aResult) {</span>
<a href="#l20.8220"></a><span id="l20.8220">   nsCString str;</span>
<a href="#l20.8221"></a><span id="l20.8221">   nsresult rv = GetFolderACL()-&gt;GetRightsStringForUser(otherUser, str);</span>
<a href="#l20.8222"></a><span id="l20.8222">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.8223"></a><span id="l20.8223">   aResult = str;</span>
<a href="#l20.8224"></a><span id="l20.8224">   return NS_OK;</span>
<a href="#l20.8225"></a><span id="l20.8225"> }</span>
<a href="#l20.8226"></a><span id="l20.8226"> </span>
<a href="#l20.8227"></a><span id="l20.8227" class="difflineminus">-nsresult nsMsgIMAPFolderACL::GetRightsStringForUser(const nsACString&amp; inUserName, nsCString &amp;rights)</span>
<a href="#l20.8228"></a><span id="l20.8228" class="difflineminus">-{</span>
<a href="#l20.8229"></a><span id="l20.8229" class="difflineplus">+nsresult nsMsgIMAPFolderACL::GetRightsStringForUser(</span>
<a href="#l20.8230"></a><span id="l20.8230" class="difflineplus">+    const nsACString &amp;inUserName, nsCString &amp;rights) {</span>
<a href="#l20.8231"></a><span id="l20.8231">   nsCString userName;</span>
<a href="#l20.8232"></a><span id="l20.8232">   userName.Assign(inUserName);</span>
<a href="#l20.8233"></a><span id="l20.8233" class="difflineminus">-  if (userName.IsEmpty())</span>
<a href="#l20.8234"></a><span id="l20.8234" class="difflineminus">-  {</span>
<a href="#l20.8235"></a><span id="l20.8235" class="difflineminus">-    nsCOMPtr &lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.8236"></a><span id="l20.8236" class="difflineplus">+  if (userName.IsEmpty()) {</span>
<a href="#l20.8237"></a><span id="l20.8237" class="difflineplus">+    nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.8238"></a><span id="l20.8238"> </span>
<a href="#l20.8239"></a><span id="l20.8239">     nsresult rv = m_folder-&gt;GetServer(getter_AddRefs(server));</span>
<a href="#l20.8240"></a><span id="l20.8240">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.8241"></a><span id="l20.8241">     // we need the real user name to match with what the imap server returns</span>
<a href="#l20.8242"></a><span id="l20.8242">     // in the acl response.</span>
<a href="#l20.8243"></a><span id="l20.8243">     server-&gt;GetRealUsername(userName);</span>
<a href="#l20.8244"></a><span id="l20.8244">   }</span>
<a href="#l20.8245"></a><span id="l20.8245">   ToLowerCase(userName);</span>
<a href="#l20.8246"></a><span id="l20.8246">   m_rightsHash.Get(userName, &amp;rights);</span>
<a href="#l20.8247"></a><span id="l20.8247">   return NS_OK;</span>
<a href="#l20.8248"></a><span id="l20.8248"> }</span>
<a href="#l20.8249"></a><span id="l20.8249"> </span>
<a href="#l20.8250"></a><span id="l20.8250" class="difflineminus">-// First looks for individual user;  then looks for 'anyone' if the user isn't found.</span>
<a href="#l20.8251"></a><span id="l20.8251" class="difflineminus">-// Returns defaultIfNotFound, if neither are found.</span>
<a href="#l20.8252"></a><span id="l20.8252" class="difflineminus">-bool nsMsgIMAPFolderACL::GetFlagSetInRightsForUser(const nsACString&amp; userName, char flag, bool defaultIfNotFound)</span>
<a href="#l20.8253"></a><span id="l20.8253" class="difflineminus">-{</span>
<a href="#l20.8254"></a><span id="l20.8254" class="difflineplus">+// First looks for individual user;  then looks for 'anyone' if the user isn't</span>
<a href="#l20.8255"></a><span id="l20.8255" class="difflineplus">+// found. Returns defaultIfNotFound, if neither are found.</span>
<a href="#l20.8256"></a><span id="l20.8256" class="difflineplus">+bool nsMsgIMAPFolderACL::GetFlagSetInRightsForUser(const nsACString &amp;userName,</span>
<a href="#l20.8257"></a><span id="l20.8257" class="difflineplus">+                                                   char flag,</span>
<a href="#l20.8258"></a><span id="l20.8258" class="difflineplus">+                                                   bool defaultIfNotFound) {</span>
<a href="#l20.8259"></a><span id="l20.8259">   nsCString flags;</span>
<a href="#l20.8260"></a><span id="l20.8260">   nsresult rv = GetRightsStringForUser(userName, flags);</span>
<a href="#l20.8261"></a><span id="l20.8261">   NS_ENSURE_SUCCESS(rv, defaultIfNotFound);</span>
<a href="#l20.8262"></a><span id="l20.8262" class="difflineminus">-  if (flags.IsEmpty())</span>
<a href="#l20.8263"></a><span id="l20.8263" class="difflineminus">-  {</span>
<a href="#l20.8264"></a><span id="l20.8264" class="difflineplus">+  if (flags.IsEmpty()) {</span>
<a href="#l20.8265"></a><span id="l20.8265">     nsCString anyoneFlags;</span>
<a href="#l20.8266"></a><span id="l20.8266" class="difflineminus">-    GetRightsStringForUser(NS_LITERAL_CSTRING(IMAP_ACL_ANYONE_STRING), anyoneFlags);</span>
<a href="#l20.8267"></a><span id="l20.8267" class="difflineminus">-    if (anyoneFlags.IsEmpty())</span>
<a href="#l20.8268"></a><span id="l20.8268" class="difflineminus">-      return defaultIfNotFound;</span>
<a href="#l20.8269"></a><span id="l20.8269" class="difflineplus">+    GetRightsStringForUser(NS_LITERAL_CSTRING(IMAP_ACL_ANYONE_STRING),</span>
<a href="#l20.8270"></a><span id="l20.8270" class="difflineplus">+                           anyoneFlags);</span>
<a href="#l20.8271"></a><span id="l20.8271" class="difflineplus">+    if (anyoneFlags.IsEmpty()) return defaultIfNotFound;</span>
<a href="#l20.8272"></a><span id="l20.8272">     return (anyoneFlags.FindChar(flag) != kNotFound);</span>
<a href="#l20.8273"></a><span id="l20.8273">   }</span>
<a href="#l20.8274"></a><span id="l20.8274">   return (flags.FindChar(flag) != kNotFound);</span>
<a href="#l20.8275"></a><span id="l20.8275"> }</span>
<a href="#l20.8276"></a><span id="l20.8276"> </span>
<a href="#l20.8277"></a><span id="l20.8277" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanUserLookupFolder(const nsACString&amp; userName)</span>
<a href="#l20.8278"></a><span id="l20.8278" class="difflineminus">-{</span>
<a href="#l20.8279"></a><span id="l20.8279" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanUserLookupFolder(const nsACString &amp;userName) {</span>
<a href="#l20.8280"></a><span id="l20.8280">   return GetFlagSetInRightsForUser(userName, 'l', false);</span>
<a href="#l20.8281"></a><span id="l20.8281"> }</span>
<a href="#l20.8282"></a><span id="l20.8282"> </span>
<a href="#l20.8283"></a><span id="l20.8283" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanUserReadFolder(const nsACString&amp; userName)</span>
<a href="#l20.8284"></a><span id="l20.8284" class="difflineminus">-{</span>
<a href="#l20.8285"></a><span id="l20.8285" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanUserReadFolder(const nsACString &amp;userName) {</span>
<a href="#l20.8286"></a><span id="l20.8286">   return GetFlagSetInRightsForUser(userName, 'r', false);</span>
<a href="#l20.8287"></a><span id="l20.8287"> }</span>
<a href="#l20.8288"></a><span id="l20.8288"> </span>
<a href="#l20.8289"></a><span id="l20.8289" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanUserStoreSeenInFolder(const nsACString&amp; userName)</span>
<a href="#l20.8290"></a><span id="l20.8290" class="difflineminus">-{</span>
<a href="#l20.8291"></a><span id="l20.8291" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanUserStoreSeenInFolder(</span>
<a href="#l20.8292"></a><span id="l20.8292" class="difflineplus">+    const nsACString &amp;userName) {</span>
<a href="#l20.8293"></a><span id="l20.8293">   return GetFlagSetInRightsForUser(userName, 's', false);</span>
<a href="#l20.8294"></a><span id="l20.8294"> }</span>
<a href="#l20.8295"></a><span id="l20.8295"> </span>
<a href="#l20.8296"></a><span id="l20.8296" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanUserWriteFolder(const nsACString&amp; userName)</span>
<a href="#l20.8297"></a><span id="l20.8297" class="difflineminus">-{</span>
<a href="#l20.8298"></a><span id="l20.8298" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanUserWriteFolder(const nsACString &amp;userName) {</span>
<a href="#l20.8299"></a><span id="l20.8299">   return GetFlagSetInRightsForUser(userName, 'w', false);</span>
<a href="#l20.8300"></a><span id="l20.8300"> }</span>
<a href="#l20.8301"></a><span id="l20.8301"> </span>
<a href="#l20.8302"></a><span id="l20.8302" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanUserInsertInFolder(const nsACString&amp; userName)</span>
<a href="#l20.8303"></a><span id="l20.8303" class="difflineminus">-{</span>
<a href="#l20.8304"></a><span id="l20.8304" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanUserInsertInFolder(const nsACString &amp;userName) {</span>
<a href="#l20.8305"></a><span id="l20.8305">   return GetFlagSetInRightsForUser(userName, 'i', false);</span>
<a href="#l20.8306"></a><span id="l20.8306"> }</span>
<a href="#l20.8307"></a><span id="l20.8307"> </span>
<a href="#l20.8308"></a><span id="l20.8308" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanUserPostToFolder(const nsACString&amp; userName)</span>
<a href="#l20.8309"></a><span id="l20.8309" class="difflineminus">-{</span>
<a href="#l20.8310"></a><span id="l20.8310" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanUserPostToFolder(const nsACString &amp;userName) {</span>
<a href="#l20.8311"></a><span id="l20.8311">   return GetFlagSetInRightsForUser(userName, 'p', false);</span>
<a href="#l20.8312"></a><span id="l20.8312"> }</span>
<a href="#l20.8313"></a><span id="l20.8313"> </span>
<a href="#l20.8314"></a><span id="l20.8314" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanUserCreateSubfolder(const nsACString&amp; userName)</span>
<a href="#l20.8315"></a><span id="l20.8315" class="difflineminus">-{</span>
<a href="#l20.8316"></a><span id="l20.8316" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanUserCreateSubfolder(const nsACString &amp;userName) {</span>
<a href="#l20.8317"></a><span id="l20.8317">   return GetFlagSetInRightsForUser(userName, 'c', false);</span>
<a href="#l20.8318"></a><span id="l20.8318"> }</span>
<a href="#l20.8319"></a><span id="l20.8319"> </span>
<a href="#l20.8320"></a><span id="l20.8320" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanUserDeleteInFolder(const nsACString&amp; userName)</span>
<a href="#l20.8321"></a><span id="l20.8321" class="difflineminus">-{</span>
<a href="#l20.8322"></a><span id="l20.8322" class="difflineminus">-  return GetFlagSetInRightsForUser(userName, 'd', false)</span>
<a href="#l20.8323"></a><span id="l20.8323" class="difflineminus">-    || GetFlagSetInRightsForUser(userName, 't', false);</span>
<a href="#l20.8324"></a><span id="l20.8324" class="difflineminus">-}</span>
<a href="#l20.8325"></a><span id="l20.8325" class="difflineminus">-</span>
<a href="#l20.8326"></a><span id="l20.8326" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanUserAdministerFolder(const nsACString&amp; userName)</span>
<a href="#l20.8327"></a><span id="l20.8327" class="difflineminus">-{</span>
<a href="#l20.8328"></a><span id="l20.8328" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanUserDeleteInFolder(const nsACString &amp;userName) {</span>
<a href="#l20.8329"></a><span id="l20.8329" class="difflineplus">+  return GetFlagSetInRightsForUser(userName, 'd', false) ||</span>
<a href="#l20.8330"></a><span id="l20.8330" class="difflineplus">+         GetFlagSetInRightsForUser(userName, 't', false);</span>
<a href="#l20.8331"></a><span id="l20.8331" class="difflineplus">+}</span>
<a href="#l20.8332"></a><span id="l20.8332" class="difflineplus">+</span>
<a href="#l20.8333"></a><span id="l20.8333" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanUserAdministerFolder(</span>
<a href="#l20.8334"></a><span id="l20.8334" class="difflineplus">+    const nsACString &amp;userName) {</span>
<a href="#l20.8335"></a><span id="l20.8335">   return GetFlagSetInRightsForUser(userName, 'a', false);</span>
<a href="#l20.8336"></a><span id="l20.8336"> }</span>
<a href="#l20.8337"></a><span id="l20.8337"> </span>
<a href="#l20.8338"></a><span id="l20.8338" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanILookupFolder()</span>
<a href="#l20.8339"></a><span id="l20.8339" class="difflineminus">-{</span>
<a href="#l20.8340"></a><span id="l20.8340" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanILookupFolder() {</span>
<a href="#l20.8341"></a><span id="l20.8341">   return GetFlagSetInRightsForUser(EmptyCString(), 'l', true);</span>
<a href="#l20.8342"></a><span id="l20.8342"> }</span>
<a href="#l20.8343"></a><span id="l20.8343"> </span>
<a href="#l20.8344"></a><span id="l20.8344" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanIReadFolder()</span>
<a href="#l20.8345"></a><span id="l20.8345" class="difflineminus">-{</span>
<a href="#l20.8346"></a><span id="l20.8346" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanIReadFolder() {</span>
<a href="#l20.8347"></a><span id="l20.8347">   return GetFlagSetInRightsForUser(EmptyCString(), 'r', true);</span>
<a href="#l20.8348"></a><span id="l20.8348"> }</span>
<a href="#l20.8349"></a><span id="l20.8349"> </span>
<a href="#l20.8350"></a><span id="l20.8350" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanIStoreSeenInFolder()</span>
<a href="#l20.8351"></a><span id="l20.8351" class="difflineminus">-{</span>
<a href="#l20.8352"></a><span id="l20.8352" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanIStoreSeenInFolder() {</span>
<a href="#l20.8353"></a><span id="l20.8353">   return GetFlagSetInRightsForUser(EmptyCString(), 's', true);</span>
<a href="#l20.8354"></a><span id="l20.8354"> }</span>
<a href="#l20.8355"></a><span id="l20.8355"> </span>
<a href="#l20.8356"></a><span id="l20.8356" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanIWriteFolder()</span>
<a href="#l20.8357"></a><span id="l20.8357" class="difflineminus">-{</span>
<a href="#l20.8358"></a><span id="l20.8358" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanIWriteFolder() {</span>
<a href="#l20.8359"></a><span id="l20.8359">   return GetFlagSetInRightsForUser(EmptyCString(), 'w', true);</span>
<a href="#l20.8360"></a><span id="l20.8360"> }</span>
<a href="#l20.8361"></a><span id="l20.8361"> </span>
<a href="#l20.8362"></a><span id="l20.8362" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanIInsertInFolder()</span>
<a href="#l20.8363"></a><span id="l20.8363" class="difflineminus">-{</span>
<a href="#l20.8364"></a><span id="l20.8364" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanIInsertInFolder() {</span>
<a href="#l20.8365"></a><span id="l20.8365">   return GetFlagSetInRightsForUser(EmptyCString(), 'i', true);</span>
<a href="#l20.8366"></a><span id="l20.8366"> }</span>
<a href="#l20.8367"></a><span id="l20.8367"> </span>
<a href="#l20.8368"></a><span id="l20.8368" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanIPostToFolder()</span>
<a href="#l20.8369"></a><span id="l20.8369" class="difflineminus">-{</span>
<a href="#l20.8370"></a><span id="l20.8370" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanIPostToFolder() {</span>
<a href="#l20.8371"></a><span id="l20.8371">   return GetFlagSetInRightsForUser(EmptyCString(), 'p', true);</span>
<a href="#l20.8372"></a><span id="l20.8372"> }</span>
<a href="#l20.8373"></a><span id="l20.8373"> </span>
<a href="#l20.8374"></a><span id="l20.8374" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanICreateSubfolder()</span>
<a href="#l20.8375"></a><span id="l20.8375" class="difflineminus">-{</span>
<a href="#l20.8376"></a><span id="l20.8376" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanICreateSubfolder() {</span>
<a href="#l20.8377"></a><span id="l20.8377">   return GetFlagSetInRightsForUser(EmptyCString(), 'c', true);</span>
<a href="#l20.8378"></a><span id="l20.8378"> }</span>
<a href="#l20.8379"></a><span id="l20.8379"> </span>
<a href="#l20.8380"></a><span id="l20.8380" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanIDeleteInFolder()</span>
<a href="#l20.8381"></a><span id="l20.8381" class="difflineminus">-{</span>
<a href="#l20.8382"></a><span id="l20.8382" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanIDeleteInFolder() {</span>
<a href="#l20.8383"></a><span id="l20.8383">   return GetFlagSetInRightsForUser(EmptyCString(), 'd', true) ||</span>
<a href="#l20.8384"></a><span id="l20.8384" class="difflineminus">-    GetFlagSetInRightsForUser(EmptyCString(), 't', true);</span>
<a href="#l20.8385"></a><span id="l20.8385" class="difflineminus">-}</span>
<a href="#l20.8386"></a><span id="l20.8386" class="difflineminus">-</span>
<a href="#l20.8387"></a><span id="l20.8387" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanIAdministerFolder()</span>
<a href="#l20.8388"></a><span id="l20.8388" class="difflineminus">-{</span>
<a href="#l20.8389"></a><span id="l20.8389" class="difflineplus">+         GetFlagSetInRightsForUser(EmptyCString(), 't', true);</span>
<a href="#l20.8390"></a><span id="l20.8390" class="difflineplus">+}</span>
<a href="#l20.8391"></a><span id="l20.8391" class="difflineplus">+</span>
<a href="#l20.8392"></a><span id="l20.8392" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanIAdministerFolder() {</span>
<a href="#l20.8393"></a><span id="l20.8393">   return GetFlagSetInRightsForUser(EmptyCString(), 'a', true);</span>
<a href="#l20.8394"></a><span id="l20.8394"> }</span>
<a href="#l20.8395"></a><span id="l20.8395"> </span>
<a href="#l20.8396"></a><span id="l20.8396" class="difflineminus">-bool nsMsgIMAPFolderACL::GetCanIExpungeFolder()</span>
<a href="#l20.8397"></a><span id="l20.8397" class="difflineminus">-{</span>
<a href="#l20.8398"></a><span id="l20.8398" class="difflineplus">+bool nsMsgIMAPFolderACL::GetCanIExpungeFolder() {</span>
<a href="#l20.8399"></a><span id="l20.8399">   return GetFlagSetInRightsForUser(EmptyCString(), 'e', true) ||</span>
<a href="#l20.8400"></a><span id="l20.8400" class="difflineminus">-    GetFlagSetInRightsForUser(EmptyCString(), 'd', true);</span>
<a href="#l20.8401"></a><span id="l20.8401" class="difflineplus">+         GetFlagSetInRightsForUser(EmptyCString(), 'd', true);</span>
<a href="#l20.8402"></a><span id="l20.8402"> }</span>
<a href="#l20.8403"></a><span id="l20.8403"> </span>
<a href="#l20.8404"></a><span id="l20.8404"> // We use this to see if the ACLs think a folder is shared or not.</span>
<a href="#l20.8405"></a><span id="l20.8405"> // We will define &quot;Shared&quot; in 5.0 to mean:</span>
<a href="#l20.8406"></a><span id="l20.8406" class="difflineminus">-// At least one user other than the currently authenticated user has at least one</span>
<a href="#l20.8407"></a><span id="l20.8407" class="difflineminus">-// explicitly-listed ACL right on that folder.</span>
<a href="#l20.8408"></a><span id="l20.8408" class="difflineminus">-bool nsMsgIMAPFolderACL::GetIsFolderShared()</span>
<a href="#l20.8409"></a><span id="l20.8409" class="difflineminus">-{</span>
<a href="#l20.8410"></a><span id="l20.8410" class="difflineminus">-  // If we have more than one ACL count for this folder, which means that someone</span>
<a href="#l20.8411"></a><span id="l20.8411" class="difflineminus">-  // other than ourself has rights on it, then it is &quot;shared.&quot;</span>
<a href="#l20.8412"></a><span id="l20.8412" class="difflineminus">-  if (m_aclCount &gt; 1)</span>
<a href="#l20.8413"></a><span id="l20.8413" class="difflineminus">-    return true;</span>
<a href="#l20.8414"></a><span id="l20.8414" class="difflineplus">+// At least one user other than the currently authenticated user has at least</span>
<a href="#l20.8415"></a><span id="l20.8415" class="difflineplus">+// one explicitly-listed ACL right on that folder.</span>
<a href="#l20.8416"></a><span id="l20.8416" class="difflineplus">+bool nsMsgIMAPFolderACL::GetIsFolderShared() {</span>
<a href="#l20.8417"></a><span id="l20.8417" class="difflineplus">+  // If we have more than one ACL count for this folder, which means that</span>
<a href="#l20.8418"></a><span id="l20.8418" class="difflineplus">+  // someone other than ourself has rights on it, then it is &quot;shared.&quot;</span>
<a href="#l20.8419"></a><span id="l20.8419" class="difflineplus">+  if (m_aclCount &gt; 1) return true;</span>
<a href="#l20.8420"></a><span id="l20.8420"> </span>
<a href="#l20.8421"></a><span id="l20.8421">   // Or, if &quot;anyone&quot; has rights to it, it is shared.</span>
<a href="#l20.8422"></a><span id="l20.8422">   nsCString anyonesRights;</span>
<a href="#l20.8423"></a><span id="l20.8423">   m_rightsHash.Get(NS_LITERAL_CSTRING(IMAP_ACL_ANYONE_STRING), &amp;anyonesRights);</span>
<a href="#l20.8424"></a><span id="l20.8424">   return (!anyonesRights.IsEmpty());</span>
<a href="#l20.8425"></a><span id="l20.8425"> }</span>
<a href="#l20.8426"></a><span id="l20.8426"> </span>
<a href="#l20.8427"></a><span id="l20.8427" class="difflineminus">-bool nsMsgIMAPFolderACL::GetDoIHaveFullRightsForFolder()</span>
<a href="#l20.8428"></a><span id="l20.8428" class="difflineminus">-{</span>
<a href="#l20.8429"></a><span id="l20.8429" class="difflineminus">-  return (GetCanIReadFolder() &amp;&amp;</span>
<a href="#l20.8430"></a><span id="l20.8430" class="difflineminus">-    GetCanIWriteFolder() &amp;&amp;</span>
<a href="#l20.8431"></a><span id="l20.8431" class="difflineminus">-    GetCanIInsertInFolder() &amp;&amp;</span>
<a href="#l20.8432"></a><span id="l20.8432" class="difflineminus">-    GetCanIAdministerFolder() &amp;&amp;</span>
<a href="#l20.8433"></a><span id="l20.8433" class="difflineminus">-    GetCanICreateSubfolder() &amp;&amp;</span>
<a href="#l20.8434"></a><span id="l20.8434" class="difflineminus">-    GetCanIDeleteInFolder() &amp;&amp;</span>
<a href="#l20.8435"></a><span id="l20.8435" class="difflineminus">-    GetCanILookupFolder() &amp;&amp;</span>
<a href="#l20.8436"></a><span id="l20.8436" class="difflineminus">-    GetCanIStoreSeenInFolder() &amp;&amp;</span>
<a href="#l20.8437"></a><span id="l20.8437" class="difflineminus">-    GetCanIExpungeFolder() &amp;&amp;</span>
<a href="#l20.8438"></a><span id="l20.8438" class="difflineminus">-    GetCanIPostToFolder());</span>
<a href="#l20.8439"></a><span id="l20.8439" class="difflineplus">+bool nsMsgIMAPFolderACL::GetDoIHaveFullRightsForFolder() {</span>
<a href="#l20.8440"></a><span id="l20.8440" class="difflineplus">+  return (GetCanIReadFolder() &amp;&amp; GetCanIWriteFolder() &amp;&amp;</span>
<a href="#l20.8441"></a><span id="l20.8441" class="difflineplus">+          GetCanIInsertInFolder() &amp;&amp; GetCanIAdministerFolder() &amp;&amp;</span>
<a href="#l20.8442"></a><span id="l20.8442" class="difflineplus">+          GetCanICreateSubfolder() &amp;&amp; GetCanIDeleteInFolder() &amp;&amp;</span>
<a href="#l20.8443"></a><span id="l20.8443" class="difflineplus">+          GetCanILookupFolder() &amp;&amp; GetCanIStoreSeenInFolder() &amp;&amp;</span>
<a href="#l20.8444"></a><span id="l20.8444" class="difflineplus">+          GetCanIExpungeFolder() &amp;&amp; GetCanIPostToFolder());</span>
<a href="#l20.8445"></a><span id="l20.8445"> }</span>
<a href="#l20.8446"></a><span id="l20.8446"> </span>
<a href="#l20.8447"></a><span id="l20.8447"> // Returns a newly allocated string describing these rights</span>
<a href="#l20.8448"></a><span id="l20.8448" class="difflineminus">-nsresult nsMsgIMAPFolderACL::CreateACLRightsString(nsAString&amp; aRightsString)</span>
<a href="#l20.8449"></a><span id="l20.8449" class="difflineminus">-{</span>
<a href="#l20.8450"></a><span id="l20.8450" class="difflineplus">+nsresult nsMsgIMAPFolderACL::CreateACLRightsString(nsAString &amp;aRightsString) {</span>
<a href="#l20.8451"></a><span id="l20.8451">   nsString curRight;</span>
<a href="#l20.8452"></a><span id="l20.8452">   nsCOMPtr&lt;nsIStringBundle&gt; bundle;</span>
<a href="#l20.8453"></a><span id="l20.8453">   nsresult rv = IMAPGetStringBundle(getter_AddRefs(bundle));</span>
<a href="#l20.8454"></a><span id="l20.8454">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.8455"></a><span id="l20.8455"> </span>
<a href="#l20.8456"></a><span id="l20.8456">   if (GetDoIHaveFullRightsForFolder()) {</span>
<a href="#l20.8457"></a><span id="l20.8457">     nsAutoString result;</span>
<a href="#l20.8458"></a><span id="l20.8458">     rv = bundle-&gt;GetStringFromName(&quot;imapAclFullRights&quot;, result);</span>
<a href="#l20.8459"></a><span id="l20.8459">     aRightsString.Assign(result);</span>
<a href="#l20.8460"></a><span id="l20.8460">     return rv;</span>
<a href="#l20.8461"></a><span id="l20.8461">   }</span>
<a href="#l20.8462"></a><span id="l20.8462"> </span>
<a href="#l20.8463"></a><span id="l20.8463" class="difflineminus">-  if (GetCanIReadFolder())</span>
<a href="#l20.8464"></a><span id="l20.8464" class="difflineminus">-  {</span>
<a href="#l20.8465"></a><span id="l20.8465" class="difflineplus">+  if (GetCanIReadFolder()) {</span>
<a href="#l20.8466"></a><span id="l20.8466">     bundle-&gt;GetStringFromName(&quot;imapAclReadRight&quot;, curRight);</span>
<a href="#l20.8467"></a><span id="l20.8467">     aRightsString.Append(curRight);</span>
<a href="#l20.8468"></a><span id="l20.8468">   }</span>
<a href="#l20.8469"></a><span id="l20.8469" class="difflineminus">-  if (GetCanIWriteFolder())</span>
<a href="#l20.8470"></a><span id="l20.8470" class="difflineminus">-  {</span>
<a href="#l20.8471"></a><span id="l20.8471" class="difflineplus">+  if (GetCanIWriteFolder()) {</span>
<a href="#l20.8472"></a><span id="l20.8472">     if (!aRightsString.IsEmpty()) aRightsString.AppendLiteral(&quot;, &quot;);</span>
<a href="#l20.8473"></a><span id="l20.8473">     bundle-&gt;GetStringFromName(&quot;imapAclWriteRight&quot;, curRight);</span>
<a href="#l20.8474"></a><span id="l20.8474">     aRightsString.Append(curRight);</span>
<a href="#l20.8475"></a><span id="l20.8475">   }</span>
<a href="#l20.8476"></a><span id="l20.8476" class="difflineminus">-  if (GetCanIInsertInFolder())</span>
<a href="#l20.8477"></a><span id="l20.8477" class="difflineminus">-  {</span>
<a href="#l20.8478"></a><span id="l20.8478" class="difflineplus">+  if (GetCanIInsertInFolder()) {</span>
<a href="#l20.8479"></a><span id="l20.8479">     if (!aRightsString.IsEmpty()) aRightsString.AppendLiteral(&quot;, &quot;);</span>
<a href="#l20.8480"></a><span id="l20.8480">     bundle-&gt;GetStringFromName(&quot;imapAclInsertRight&quot;, curRight);</span>
<a href="#l20.8481"></a><span id="l20.8481">     aRightsString.Append(curRight);</span>
<a href="#l20.8482"></a><span id="l20.8482">   }</span>
<a href="#l20.8483"></a><span id="l20.8483" class="difflineminus">-  if (GetCanILookupFolder())</span>
<a href="#l20.8484"></a><span id="l20.8484" class="difflineminus">-  {</span>
<a href="#l20.8485"></a><span id="l20.8485" class="difflineplus">+  if (GetCanILookupFolder()) {</span>
<a href="#l20.8486"></a><span id="l20.8486">     if (!aRightsString.IsEmpty()) aRightsString.AppendLiteral(&quot;, &quot;);</span>
<a href="#l20.8487"></a><span id="l20.8487">     bundle-&gt;GetStringFromName(&quot;imapAclLookupRight&quot;, curRight);</span>
<a href="#l20.8488"></a><span id="l20.8488">     aRightsString.Append(curRight);</span>
<a href="#l20.8489"></a><span id="l20.8489">   }</span>
<a href="#l20.8490"></a><span id="l20.8490" class="difflineminus">-  if (GetCanIStoreSeenInFolder())</span>
<a href="#l20.8491"></a><span id="l20.8491" class="difflineminus">-  {</span>
<a href="#l20.8492"></a><span id="l20.8492" class="difflineplus">+  if (GetCanIStoreSeenInFolder()) {</span>
<a href="#l20.8493"></a><span id="l20.8493">     if (!aRightsString.IsEmpty()) aRightsString.AppendLiteral(&quot;, &quot;);</span>
<a href="#l20.8494"></a><span id="l20.8494">     bundle-&gt;GetStringFromName(&quot;imapAclSeenRight&quot;, curRight);</span>
<a href="#l20.8495"></a><span id="l20.8495">     aRightsString.Append(curRight);</span>
<a href="#l20.8496"></a><span id="l20.8496">   }</span>
<a href="#l20.8497"></a><span id="l20.8497" class="difflineminus">-  if (GetCanIDeleteInFolder())</span>
<a href="#l20.8498"></a><span id="l20.8498" class="difflineminus">-  {</span>
<a href="#l20.8499"></a><span id="l20.8499" class="difflineplus">+  if (GetCanIDeleteInFolder()) {</span>
<a href="#l20.8500"></a><span id="l20.8500">     if (!aRightsString.IsEmpty()) aRightsString.AppendLiteral(&quot;, &quot;);</span>
<a href="#l20.8501"></a><span id="l20.8501">     bundle-&gt;GetStringFromName(&quot;imapAclDeleteRight&quot;, curRight);</span>
<a href="#l20.8502"></a><span id="l20.8502">     aRightsString.Append(curRight);</span>
<a href="#l20.8503"></a><span id="l20.8503">   }</span>
<a href="#l20.8504"></a><span id="l20.8504" class="difflineminus">-  if (GetCanIExpungeFolder())</span>
<a href="#l20.8505"></a><span id="l20.8505" class="difflineminus">-  {</span>
<a href="#l20.8506"></a><span id="l20.8506" class="difflineminus">-    if (!aRightsString.IsEmpty())</span>
<a href="#l20.8507"></a><span id="l20.8507" class="difflineminus">-      aRightsString.AppendLiteral(&quot;, &quot;);</span>
<a href="#l20.8508"></a><span id="l20.8508" class="difflineplus">+  if (GetCanIExpungeFolder()) {</span>
<a href="#l20.8509"></a><span id="l20.8509" class="difflineplus">+    if (!aRightsString.IsEmpty()) aRightsString.AppendLiteral(&quot;, &quot;);</span>
<a href="#l20.8510"></a><span id="l20.8510">     bundle-&gt;GetStringFromName(&quot;imapAclExpungeRight&quot;, curRight);</span>
<a href="#l20.8511"></a><span id="l20.8511">     aRightsString.Append(curRight);</span>
<a href="#l20.8512"></a><span id="l20.8512">   }</span>
<a href="#l20.8513"></a><span id="l20.8513" class="difflineminus">-  if (GetCanICreateSubfolder())</span>
<a href="#l20.8514"></a><span id="l20.8514" class="difflineminus">-  {</span>
<a href="#l20.8515"></a><span id="l20.8515" class="difflineplus">+  if (GetCanICreateSubfolder()) {</span>
<a href="#l20.8516"></a><span id="l20.8516">     if (!aRightsString.IsEmpty()) aRightsString.AppendLiteral(&quot;, &quot;);</span>
<a href="#l20.8517"></a><span id="l20.8517">     bundle-&gt;GetStringFromName(&quot;imapAclCreateRight&quot;, curRight);</span>
<a href="#l20.8518"></a><span id="l20.8518">     aRightsString.Append(curRight);</span>
<a href="#l20.8519"></a><span id="l20.8519">   }</span>
<a href="#l20.8520"></a><span id="l20.8520" class="difflineminus">-  if (GetCanIPostToFolder())</span>
<a href="#l20.8521"></a><span id="l20.8521" class="difflineminus">-  {</span>
<a href="#l20.8522"></a><span id="l20.8522" class="difflineplus">+  if (GetCanIPostToFolder()) {</span>
<a href="#l20.8523"></a><span id="l20.8523">     if (!aRightsString.IsEmpty()) aRightsString.AppendLiteral(&quot;, &quot;);</span>
<a href="#l20.8524"></a><span id="l20.8524">     bundle-&gt;GetStringFromName(&quot;imapAclPostRight&quot;, curRight);</span>
<a href="#l20.8525"></a><span id="l20.8525">     aRightsString.Append(curRight);</span>
<a href="#l20.8526"></a><span id="l20.8526">   }</span>
<a href="#l20.8527"></a><span id="l20.8527" class="difflineminus">-  if (GetCanIAdministerFolder())</span>
<a href="#l20.8528"></a><span id="l20.8528" class="difflineminus">-  {</span>
<a href="#l20.8529"></a><span id="l20.8529" class="difflineplus">+  if (GetCanIAdministerFolder()) {</span>
<a href="#l20.8530"></a><span id="l20.8530">     if (!aRightsString.IsEmpty()) aRightsString.AppendLiteral(&quot;, &quot;);</span>
<a href="#l20.8531"></a><span id="l20.8531">     bundle-&gt;GetStringFromName(&quot;imapAclAdministerRight&quot;, curRight);</span>
<a href="#l20.8532"></a><span id="l20.8532">     aRightsString.Append(curRight);</span>
<a href="#l20.8533"></a><span id="l20.8533">   }</span>
<a href="#l20.8534"></a><span id="l20.8534">   return rv;</span>
<a href="#l20.8535"></a><span id="l20.8535"> }</span>
<a href="#l20.8536"></a><span id="l20.8536"> </span>
<a href="#l20.8537"></a><span id="l20.8537" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetFilePath(nsIFile ** aPathName)</span>
<a href="#l20.8538"></a><span id="l20.8538" class="difflineminus">-{</span>
<a href="#l20.8539"></a><span id="l20.8539" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetFilePath(nsIFile **aPathName) {</span>
<a href="#l20.8540"></a><span id="l20.8540">   // this will return a copy of mPath, which is what we want.</span>
<a href="#l20.8541"></a><span id="l20.8541">   // this will also initialize mPath using parseURI if it isn't already done</span>
<a href="#l20.8542"></a><span id="l20.8542">   return nsMsgDBFolder::GetFilePath(aPathName);</span>
<a href="#l20.8543"></a><span id="l20.8543"> }</span>
<a href="#l20.8544"></a><span id="l20.8544"> </span>
<a href="#l20.8545"></a><span id="l20.8545" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetFilePath(nsIFile * aPathName)</span>
<a href="#l20.8546"></a><span id="l20.8546" class="difflineminus">-{</span>
<a href="#l20.8547"></a><span id="l20.8547" class="difflineminus">-  return nsMsgDBFolder::SetFilePath(aPathName);   // call base class so mPath will get set</span>
<a href="#l20.8548"></a><span id="l20.8548" class="difflineminus">-}</span>
<a href="#l20.8549"></a><span id="l20.8549" class="difflineminus">-</span>
<a href="#l20.8550"></a><span id="l20.8550" class="difflineminus">-nsresult nsImapMailFolder::DisplayStatusMsg(nsIImapUrl *aImapUrl, const nsAString&amp; msg)</span>
<a href="#l20.8551"></a><span id="l20.8551" class="difflineminus">-{</span>
<a href="#l20.8552"></a><span id="l20.8552" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetFilePath(nsIFile *aPathName) {</span>
<a href="#l20.8553"></a><span id="l20.8553" class="difflineplus">+  return nsMsgDBFolder::SetFilePath(</span>
<a href="#l20.8554"></a><span id="l20.8554" class="difflineplus">+      aPathName);  // call base class so mPath will get set</span>
<a href="#l20.8555"></a><span id="l20.8555" class="difflineplus">+}</span>
<a href="#l20.8556"></a><span id="l20.8556" class="difflineplus">+</span>
<a href="#l20.8557"></a><span id="l20.8557" class="difflineplus">+nsresult nsImapMailFolder::DisplayStatusMsg(nsIImapUrl *aImapUrl,</span>
<a href="#l20.8558"></a><span id="l20.8558" class="difflineplus">+                                            const nsAString &amp;msg) {</span>
<a href="#l20.8559"></a><span id="l20.8559">   nsCOMPtr&lt;nsIImapMockChannel&gt; mockChannel;</span>
<a href="#l20.8560"></a><span id="l20.8560">   aImapUrl-&gt;GetMockChannel(getter_AddRefs(mockChannel));</span>
<a href="#l20.8561"></a><span id="l20.8561" class="difflineminus">-  if (mockChannel)</span>
<a href="#l20.8562"></a><span id="l20.8562" class="difflineminus">-  {</span>
<a href="#l20.8563"></a><span id="l20.8563" class="difflineplus">+  if (mockChannel) {</span>
<a href="#l20.8564"></a><span id="l20.8564">     nsCOMPtr&lt;nsIProgressEventSink&gt; progressSink;</span>
<a href="#l20.8565"></a><span id="l20.8565">     mockChannel-&gt;GetProgressEventSink(getter_AddRefs(progressSink));</span>
<a href="#l20.8566"></a><span id="l20.8566" class="difflineminus">-    if (progressSink)</span>
<a href="#l20.8567"></a><span id="l20.8567" class="difflineminus">-    {</span>
<a href="#l20.8568"></a><span id="l20.8568" class="difflineminus">-      progressSink-&gt;OnStatus(mockChannel, nullptr, NS_OK, PromiseFlatString(msg).get());      // XXX i18n message</span>
<a href="#l20.8569"></a><span id="l20.8569" class="difflineplus">+    if (progressSink) {</span>
<a href="#l20.8570"></a><span id="l20.8570" class="difflineplus">+      progressSink-&gt;OnStatus(mockChannel, nullptr, NS_OK,</span>
<a href="#l20.8571"></a><span id="l20.8571" class="difflineplus">+                             PromiseFlatString(msg).get());  // XXX i18n message</span>
<a href="#l20.8572"></a><span id="l20.8572">     }</span>
<a href="#l20.8573"></a><span id="l20.8573">   }</span>
<a href="#l20.8574"></a><span id="l20.8574">   return NS_OK;</span>
<a href="#l20.8575"></a><span id="l20.8575"> }</span>
<a href="#l20.8576"></a><span id="l20.8576"> </span>
<a href="#l20.8577"></a><span id="l20.8577"> NS_IMETHODIMP</span>
<a href="#l20.8578"></a><span id="l20.8578" class="difflineminus">-nsImapMailFolder::ProgressStatusString(nsIImapProtocol* aProtocol,</span>
<a href="#l20.8579"></a><span id="l20.8579" class="difflineminus">-                                       const char* aMsgName,</span>
<a href="#l20.8580"></a><span id="l20.8580" class="difflineminus">-                                       const char16_t * extraInfo)</span>
<a href="#l20.8581"></a><span id="l20.8581" class="difflineminus">-{</span>
<a href="#l20.8582"></a><span id="l20.8582" class="difflineplus">+nsImapMailFolder::ProgressStatusString(nsIImapProtocol *aProtocol,</span>
<a href="#l20.8583"></a><span id="l20.8583" class="difflineplus">+                                       const char *aMsgName,</span>
<a href="#l20.8584"></a><span id="l20.8584" class="difflineplus">+                                       const char16_t *extraInfo) {</span>
<a href="#l20.8585"></a><span id="l20.8585">   nsString progressMsg;</span>
<a href="#l20.8586"></a><span id="l20.8586"> </span>
<a href="#l20.8587"></a><span id="l20.8587">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.8588"></a><span id="l20.8588">   nsresult rv = GetServer(getter_AddRefs(server));</span>
<a href="#l20.8589"></a><span id="l20.8589" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; server)</span>
<a href="#l20.8590"></a><span id="l20.8590" class="difflineminus">-  {</span>
<a href="#l20.8591"></a><span id="l20.8591" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; server) {</span>
<a href="#l20.8592"></a><span id="l20.8592">     nsCOMPtr&lt;nsIImapServerSink&gt; serverSink = do_QueryInterface(server);</span>
<a href="#l20.8593"></a><span id="l20.8593" class="difflineminus">-    if (serverSink)</span>
<a href="#l20.8594"></a><span id="l20.8594" class="difflineminus">-      serverSink-&gt;GetImapStringByName(aMsgName, progressMsg);</span>
<a href="#l20.8595"></a><span id="l20.8595" class="difflineplus">+    if (serverSink) serverSink-&gt;GetImapStringByName(aMsgName, progressMsg);</span>
<a href="#l20.8596"></a><span id="l20.8596">   }</span>
<a href="#l20.8597"></a><span id="l20.8597">   if (progressMsg.IsEmpty())</span>
<a href="#l20.8598"></a><span id="l20.8598">     IMAPGetStringByName(aMsgName, getter_Copies(progressMsg));</span>
<a href="#l20.8599"></a><span id="l20.8599"> </span>
<a href="#l20.8600"></a><span id="l20.8600" class="difflineminus">-  if (aProtocol &amp;&amp; !progressMsg.IsEmpty())</span>
<a href="#l20.8601"></a><span id="l20.8601" class="difflineminus">-  {</span>
<a href="#l20.8602"></a><span id="l20.8602" class="difflineminus">-    nsCOMPtr &lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l20.8603"></a><span id="l20.8603" class="difflineplus">+  if (aProtocol &amp;&amp; !progressMsg.IsEmpty()) {</span>
<a href="#l20.8604"></a><span id="l20.8604" class="difflineplus">+    nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l20.8605"></a><span id="l20.8605">     aProtocol-&gt;GetRunningImapURL(getter_AddRefs(imapUrl));</span>
<a href="#l20.8606"></a><span id="l20.8606" class="difflineminus">-    if (imapUrl)</span>
<a href="#l20.8607"></a><span id="l20.8607" class="difflineminus">-    {</span>
<a href="#l20.8608"></a><span id="l20.8608" class="difflineminus">-      if (extraInfo)</span>
<a href="#l20.8609"></a><span id="l20.8609" class="difflineminus">-      {</span>
<a href="#l20.8610"></a><span id="l20.8610" class="difflineplus">+    if (imapUrl) {</span>
<a href="#l20.8611"></a><span id="l20.8611" class="difflineplus">+      if (extraInfo) {</span>
<a href="#l20.8612"></a><span id="l20.8612">         nsString printfString;</span>
<a href="#l20.8613"></a><span id="l20.8613">         nsTextFormatter::ssprintf(printfString, progressMsg.get(), extraInfo);</span>
<a href="#l20.8614"></a><span id="l20.8614">         progressMsg = printfString;</span>
<a href="#l20.8615"></a><span id="l20.8615">       }</span>
<a href="#l20.8616"></a><span id="l20.8616"> </span>
<a href="#l20.8617"></a><span id="l20.8617">       DisplayStatusMsg(imapUrl, progressMsg);</span>
<a href="#l20.8618"></a><span id="l20.8618">     }</span>
<a href="#l20.8619"></a><span id="l20.8619">   }</span>
<a href="#l20.8620"></a><span id="l20.8620">   return NS_OK;</span>
<a href="#l20.8621"></a><span id="l20.8621"> }</span>
<a href="#l20.8622"></a><span id="l20.8622"> </span>
<a href="#l20.8623"></a><span id="l20.8623"> NS_IMETHODIMP</span>
<a href="#l20.8624"></a><span id="l20.8624" class="difflineminus">-nsImapMailFolder::PercentProgress(nsIImapProtocol* aProtocol,</span>
<a href="#l20.8625"></a><span id="l20.8625" class="difflineminus">-                                  const char16_t * aMessage,</span>
<a href="#l20.8626"></a><span id="l20.8626" class="difflineminus">-                                  int64_t aCurrentProgress, int64_t aMaxProgress)</span>
<a href="#l20.8627"></a><span id="l20.8627" class="difflineminus">-{</span>
<a href="#l20.8628"></a><span id="l20.8628" class="difflineminus">-  if (aProtocol)</span>
<a href="#l20.8629"></a><span id="l20.8629" class="difflineminus">-  {</span>
<a href="#l20.8630"></a><span id="l20.8630" class="difflineminus">-    nsCOMPtr &lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l20.8631"></a><span id="l20.8631" class="difflineplus">+nsImapMailFolder::PercentProgress(nsIImapProtocol *aProtocol,</span>
<a href="#l20.8632"></a><span id="l20.8632" class="difflineplus">+                                  const char16_t *aMessage,</span>
<a href="#l20.8633"></a><span id="l20.8633" class="difflineplus">+                                  int64_t aCurrentProgress,</span>
<a href="#l20.8634"></a><span id="l20.8634" class="difflineplus">+                                  int64_t aMaxProgress) {</span>
<a href="#l20.8635"></a><span id="l20.8635" class="difflineplus">+  if (aProtocol) {</span>
<a href="#l20.8636"></a><span id="l20.8636" class="difflineplus">+    nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l20.8637"></a><span id="l20.8637">     aProtocol-&gt;GetRunningImapURL(getter_AddRefs(imapUrl));</span>
<a href="#l20.8638"></a><span id="l20.8638" class="difflineminus">-    if (imapUrl)</span>
<a href="#l20.8639"></a><span id="l20.8639" class="difflineminus">-    {</span>
<a href="#l20.8640"></a><span id="l20.8640" class="difflineplus">+    if (imapUrl) {</span>
<a href="#l20.8641"></a><span id="l20.8641">       nsCOMPtr&lt;nsIImapMockChannel&gt; mockChannel;</span>
<a href="#l20.8642"></a><span id="l20.8642">       imapUrl-&gt;GetMockChannel(getter_AddRefs(mockChannel));</span>
<a href="#l20.8643"></a><span id="l20.8643" class="difflineminus">-      if (mockChannel)</span>
<a href="#l20.8644"></a><span id="l20.8644" class="difflineminus">-      {</span>
<a href="#l20.8645"></a><span id="l20.8645" class="difflineplus">+      if (mockChannel) {</span>
<a href="#l20.8646"></a><span id="l20.8646">         nsCOMPtr&lt;nsIProgressEventSink&gt; progressSink;</span>
<a href="#l20.8647"></a><span id="l20.8647">         mockChannel-&gt;GetProgressEventSink(getter_AddRefs(progressSink));</span>
<a href="#l20.8648"></a><span id="l20.8648" class="difflineminus">-        if (progressSink)</span>
<a href="#l20.8649"></a><span id="l20.8649" class="difflineminus">-        {</span>
<a href="#l20.8650"></a><span id="l20.8650" class="difflineminus">-            progressSink-&gt;OnProgress(mockChannel, nullptr,</span>
<a href="#l20.8651"></a><span id="l20.8651" class="difflineminus">-                                     aCurrentProgress,</span>
<a href="#l20.8652"></a><span id="l20.8652" class="difflineminus">-                                     aMaxProgress);</span>
<a href="#l20.8653"></a><span id="l20.8653" class="difflineminus">-            if (aMessage)</span>
<a href="#l20.8654"></a><span id="l20.8654" class="difflineminus">-              progressSink-&gt;OnStatus(mockChannel, nullptr, NS_OK, aMessage); // XXX i18n message</span>
<a href="#l20.8655"></a><span id="l20.8655" class="difflineplus">+        if (progressSink) {</span>
<a href="#l20.8656"></a><span id="l20.8656" class="difflineplus">+          progressSink-&gt;OnProgress(mockChannel, nullptr, aCurrentProgress,</span>
<a href="#l20.8657"></a><span id="l20.8657" class="difflineplus">+                                   aMaxProgress);</span>
<a href="#l20.8658"></a><span id="l20.8658" class="difflineplus">+          if (aMessage)</span>
<a href="#l20.8659"></a><span id="l20.8659" class="difflineplus">+            progressSink-&gt;OnStatus(mockChannel, nullptr, NS_OK,</span>
<a href="#l20.8660"></a><span id="l20.8660" class="difflineplus">+                                   aMessage);  // XXX i18n message</span>
<a href="#l20.8661"></a><span id="l20.8661">         }</span>
<a href="#l20.8662"></a><span id="l20.8662">       }</span>
<a href="#l20.8663"></a><span id="l20.8663">     }</span>
<a href="#l20.8664"></a><span id="l20.8664">   }</span>
<a href="#l20.8665"></a><span id="l20.8665">   return NS_OK;</span>
<a href="#l20.8666"></a><span id="l20.8666"> }</span>
<a href="#l20.8667"></a><span id="l20.8667"> </span>
<a href="#l20.8668"></a><span id="l20.8668"> NS_IMETHODIMP</span>
<a href="#l20.8669"></a><span id="l20.8669" class="difflineminus">-nsImapMailFolder::CopyNextStreamMessage(bool copySucceeded, nsISupports *copyState)</span>
<a href="#l20.8670"></a><span id="l20.8670" class="difflineminus">-{</span>
<a href="#l20.8671"></a><span id="l20.8671" class="difflineminus">-  //if copy has failed it could be either user interrupted it or for some other reason</span>
<a href="#l20.8672"></a><span id="l20.8672" class="difflineminus">-  //don't do any subsequent copies or delete src messages if it is move</span>
<a href="#l20.8673"></a><span id="l20.8673" class="difflineminus">-  if (!copySucceeded)</span>
<a href="#l20.8674"></a><span id="l20.8674" class="difflineminus">-    return NS_OK;</span>
<a href="#l20.8675"></a><span id="l20.8675" class="difflineplus">+nsImapMailFolder::CopyNextStreamMessage(bool copySucceeded,</span>
<a href="#l20.8676"></a><span id="l20.8676" class="difflineplus">+                                        nsISupports *copyState) {</span>
<a href="#l20.8677"></a><span id="l20.8677" class="difflineplus">+  // if copy has failed it could be either user interrupted it or for some other</span>
<a href="#l20.8678"></a><span id="l20.8678" class="difflineplus">+  // reason don't do any subsequent copies or delete src messages if it is move</span>
<a href="#l20.8679"></a><span id="l20.8679" class="difflineplus">+  if (!copySucceeded) return NS_OK;</span>
<a href="#l20.8680"></a><span id="l20.8680">   nsresult rv;</span>
<a href="#l20.8681"></a><span id="l20.8681" class="difflineminus">-  nsCOMPtr&lt;nsImapMailCopyState&gt; mailCopyState = do_QueryInterface(copyState, &amp;rv);</span>
<a href="#l20.8682"></a><span id="l20.8682" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l20.8683"></a><span id="l20.8683" class="difflineminus">-  {</span>
<a href="#l20.8684"></a><span id="l20.8684" class="difflineminus">-    MOZ_LOG(IMAP, mozilla::LogLevel::Info, (&quot;QI copyState failed: %&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.8685"></a><span id="l20.8685" class="difflineminus">-    return rv; // this can fail...</span>
<a href="#l20.8686"></a><span id="l20.8686" class="difflineminus">-  }</span>
<a href="#l20.8687"></a><span id="l20.8687" class="difflineminus">-</span>
<a href="#l20.8688"></a><span id="l20.8688" class="difflineminus">-  if (!mailCopyState-&gt;m_streamCopy)</span>
<a href="#l20.8689"></a><span id="l20.8689" class="difflineminus">-    return NS_OK;</span>
<a href="#l20.8690"></a><span id="l20.8690" class="difflineplus">+  nsCOMPtr&lt;nsImapMailCopyState&gt; mailCopyState =</span>
<a href="#l20.8691"></a><span id="l20.8691" class="difflineplus">+      do_QueryInterface(copyState, &amp;rv);</span>
<a href="#l20.8692"></a><span id="l20.8692" class="difflineplus">+  if (NS_FAILED(rv)) {</span>
<a href="#l20.8693"></a><span id="l20.8693" class="difflineplus">+    MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l20.8694"></a><span id="l20.8694" class="difflineplus">+            (&quot;QI copyState failed: %&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.8695"></a><span id="l20.8695" class="difflineplus">+    return rv;  // this can fail...</span>
<a href="#l20.8696"></a><span id="l20.8696" class="difflineplus">+  }</span>
<a href="#l20.8697"></a><span id="l20.8697" class="difflineplus">+</span>
<a href="#l20.8698"></a><span id="l20.8698" class="difflineplus">+  if (!mailCopyState-&gt;m_streamCopy) return NS_OK;</span>
<a href="#l20.8699"></a><span id="l20.8699"> </span>
<a href="#l20.8700"></a><span id="l20.8700">   MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l20.8701"></a><span id="l20.8701" class="difflineminus">-    (&quot;CopyNextStreamMessage: Copying %u of %u&quot;, mailCopyState-&gt;m_curIndex, mailCopyState-&gt;m_totalCount));</span>
<a href="#l20.8702"></a><span id="l20.8702" class="difflineminus">-  if (mailCopyState-&gt;m_curIndex &lt; mailCopyState-&gt;m_totalCount)</span>
<a href="#l20.8703"></a><span id="l20.8703" class="difflineminus">-  {</span>
<a href="#l20.8704"></a><span id="l20.8704" class="difflineminus">-    mailCopyState-&gt;m_message = do_QueryElementAt(mailCopyState-&gt;m_messages,</span>
<a href="#l20.8705"></a><span id="l20.8705" class="difflineminus">-                                                 mailCopyState-&gt;m_curIndex,</span>
<a href="#l20.8706"></a><span id="l20.8706" class="difflineminus">-                                                 &amp;rv);</span>
<a href="#l20.8707"></a><span id="l20.8707" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l20.8708"></a><span id="l20.8708" class="difflineminus">-    {</span>
<a href="#l20.8709"></a><span id="l20.8709" class="difflineplus">+          (&quot;CopyNextStreamMessage: Copying %u of %u&quot;, mailCopyState-&gt;m_curIndex,</span>
<a href="#l20.8710"></a><span id="l20.8710" class="difflineplus">+           mailCopyState-&gt;m_totalCount));</span>
<a href="#l20.8711"></a><span id="l20.8711" class="difflineplus">+  if (mailCopyState-&gt;m_curIndex &lt; mailCopyState-&gt;m_totalCount) {</span>
<a href="#l20.8712"></a><span id="l20.8712" class="difflineplus">+    mailCopyState-&gt;m_message = do_QueryElementAt(</span>
<a href="#l20.8713"></a><span id="l20.8713" class="difflineplus">+        mailCopyState-&gt;m_messages, mailCopyState-&gt;m_curIndex, &amp;rv);</span>
<a href="#l20.8714"></a><span id="l20.8714" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.8715"></a><span id="l20.8715">       bool isRead;</span>
<a href="#l20.8716"></a><span id="l20.8716">       mailCopyState-&gt;m_message-&gt;GetIsRead(&amp;isRead);</span>
<a href="#l20.8717"></a><span id="l20.8717">       mailCopyState-&gt;m_unreadCount = (isRead) ? 0 : 1;</span>
<a href="#l20.8718"></a><span id="l20.8718" class="difflineminus">-      rv = CopyStreamMessage(mailCopyState-&gt;m_message,</span>
<a href="#l20.8719"></a><span id="l20.8719" class="difflineminus">-                             this, mailCopyState-&gt;m_msgWindow, mailCopyState-&gt;m_isMove);</span>
<a href="#l20.8720"></a><span id="l20.8720" class="difflineminus">-    }</span>
<a href="#l20.8721"></a><span id="l20.8721" class="difflineminus">-    else</span>
<a href="#l20.8722"></a><span id="l20.8722" class="difflineminus">-    {</span>
<a href="#l20.8723"></a><span id="l20.8723" class="difflineplus">+      rv = CopyStreamMessage(mailCopyState-&gt;m_message, this,</span>
<a href="#l20.8724"></a><span id="l20.8724" class="difflineplus">+                             mailCopyState-&gt;m_msgWindow,</span>
<a href="#l20.8725"></a><span id="l20.8725" class="difflineplus">+                             mailCopyState-&gt;m_isMove);</span>
<a href="#l20.8726"></a><span id="l20.8726" class="difflineplus">+    } else {</span>
<a href="#l20.8727"></a><span id="l20.8727">       MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l20.8728"></a><span id="l20.8728" class="difflineminus">-        (&quot;QueryElementAt %u failed: %&quot; PRIx32, mailCopyState-&gt;m_curIndex, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.8729"></a><span id="l20.8729" class="difflineminus">-    }</span>
<a href="#l20.8730"></a><span id="l20.8730" class="difflineminus">-  }</span>
<a href="#l20.8731"></a><span id="l20.8731" class="difflineminus">-  else</span>
<a href="#l20.8732"></a><span id="l20.8732" class="difflineminus">-  {</span>
<a href="#l20.8733"></a><span id="l20.8733" class="difflineplus">+              (&quot;QueryElementAt %u failed: %&quot; PRIx32, mailCopyState-&gt;m_curIndex,</span>
<a href="#l20.8734"></a><span id="l20.8734" class="difflineplus">+               static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l20.8735"></a><span id="l20.8735" class="difflineplus">+    }</span>
<a href="#l20.8736"></a><span id="l20.8736" class="difflineplus">+  } else {</span>
<a href="#l20.8737"></a><span id="l20.8737">     // Notify of move/copy completion in case we have some source headers</span>
<a href="#l20.8738"></a><span id="l20.8738" class="difflineminus">-    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.8739"></a><span id="l20.8739" class="difflineminus">-    if (notifier)</span>
<a href="#l20.8740"></a><span id="l20.8740" class="difflineminus">-    {</span>
<a href="#l20.8741"></a><span id="l20.8741" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(</span>
<a href="#l20.8742"></a><span id="l20.8742" class="difflineplus">+        do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.8743"></a><span id="l20.8743" class="difflineplus">+    if (notifier) {</span>
<a href="#l20.8744"></a><span id="l20.8744">       uint32_t numHdrs;</span>
<a href="#l20.8745"></a><span id="l20.8745">       mailCopyState-&gt;m_messages-&gt;GetLength(&amp;numHdrs);</span>
<a href="#l20.8746"></a><span id="l20.8746">       if (numHdrs)</span>
<a href="#l20.8747"></a><span id="l20.8747" class="difflineminus">-        notifier-&gt;NotifyMsgsMoveCopyCompleted(mailCopyState-&gt;m_isMove, mailCopyState-&gt;m_messages, this, nullptr);</span>
<a href="#l20.8748"></a><span id="l20.8748" class="difflineminus">-    }</span>
<a href="#l20.8749"></a><span id="l20.8749" class="difflineminus">-    if (mailCopyState-&gt;m_isMove)</span>
<a href="#l20.8750"></a><span id="l20.8750" class="difflineminus">-    {</span>
<a href="#l20.8751"></a><span id="l20.8751" class="difflineminus">-      nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder(do_QueryInterface(mailCopyState-&gt;m_srcSupport, &amp;rv));</span>
<a href="#l20.8752"></a><span id="l20.8752" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; srcFolder)</span>
<a href="#l20.8753"></a><span id="l20.8753" class="difflineminus">-      {</span>
<a href="#l20.8754"></a><span id="l20.8754" class="difflineminus">-        srcFolder-&gt;DeleteMessages(mailCopyState-&gt;m_messages, nullptr,</span>
<a href="#l20.8755"></a><span id="l20.8755" class="difflineminus">-          true, true, nullptr, false);</span>
<a href="#l20.8756"></a><span id="l20.8756" class="difflineplus">+        notifier-&gt;NotifyMsgsMoveCopyCompleted(</span>
<a href="#l20.8757"></a><span id="l20.8757" class="difflineplus">+            mailCopyState-&gt;m_isMove, mailCopyState-&gt;m_messages, this, nullptr);</span>
<a href="#l20.8758"></a><span id="l20.8758" class="difflineplus">+    }</span>
<a href="#l20.8759"></a><span id="l20.8759" class="difflineplus">+    if (mailCopyState-&gt;m_isMove) {</span>
<a href="#l20.8760"></a><span id="l20.8760" class="difflineplus">+      nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder(</span>
<a href="#l20.8761"></a><span id="l20.8761" class="difflineplus">+          do_QueryInterface(mailCopyState-&gt;m_srcSupport, &amp;rv));</span>
<a href="#l20.8762"></a><span id="l20.8762" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; srcFolder) {</span>
<a href="#l20.8763"></a><span id="l20.8763" class="difflineplus">+        srcFolder-&gt;DeleteMessages(mailCopyState-&gt;m_messages, nullptr, true,</span>
<a href="#l20.8764"></a><span id="l20.8764" class="difflineplus">+                                  true, nullptr, false);</span>
<a href="#l20.8765"></a><span id="l20.8765">         // we want to send this notification after the source messages have</span>
<a href="#l20.8766"></a><span id="l20.8766">         // been deleted.</span>
<a href="#l20.8767"></a><span id="l20.8767">         nsCOMPtr&lt;nsIMsgLocalMailFolder&gt; popFolder(do_QueryInterface(srcFolder));</span>
<a href="#l20.8768"></a><span id="l20.8768" class="difflineminus">-        if (popFolder)   //needed if move pop-&gt;imap to notify FE</span>
<a href="#l20.8769"></a><span id="l20.8769" class="difflineplus">+        if (popFolder)  // needed if move pop-&gt;imap to notify FE</span>
<a href="#l20.8770"></a><span id="l20.8770">           srcFolder-&gt;NotifyFolderEvent(kDeleteOrMoveMsgCompleted);</span>
<a href="#l20.8771"></a><span id="l20.8771">       }</span>
<a href="#l20.8772"></a><span id="l20.8772">     }</span>
<a href="#l20.8773"></a><span id="l20.8773">   }</span>
<a href="#l20.8774"></a><span id="l20.8774" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l20.8775"></a><span id="l20.8775" class="difflineminus">-    (void) OnCopyCompleted(mailCopyState-&gt;m_srcSupport, rv);</span>
<a href="#l20.8776"></a><span id="l20.8776" class="difflineplus">+  if (NS_FAILED(rv)) (void)OnCopyCompleted(mailCopyState-&gt;m_srcSupport, rv);</span>
<a href="#l20.8777"></a><span id="l20.8777"> </span>
<a href="#l20.8778"></a><span id="l20.8778">   return rv;</span>
<a href="#l20.8779"></a><span id="l20.8779"> }</span>
<a href="#l20.8780"></a><span id="l20.8780"> </span>
<a href="#l20.8781"></a><span id="l20.8781"> NS_IMETHODIMP</span>
<a href="#l20.8782"></a><span id="l20.8782" class="difflineminus">-nsImapMailFolder::SetUrlState(nsIImapProtocol* aProtocol,</span>
<a href="#l20.8783"></a><span id="l20.8783" class="difflineminus">-                              nsIMsgMailNewsUrl* aUrl,</span>
<a href="#l20.8784"></a><span id="l20.8784" class="difflineminus">-                              bool isRunning,</span>
<a href="#l20.8785"></a><span id="l20.8785" class="difflineminus">-                              bool aSuspend,</span>
<a href="#l20.8786"></a><span id="l20.8786" class="difflineminus">-                              nsresult statusCode)</span>
<a href="#l20.8787"></a><span id="l20.8787" class="difflineminus">-{</span>
<a href="#l20.8788"></a><span id="l20.8788" class="difflineplus">+nsImapMailFolder::SetUrlState(nsIImapProtocol *aProtocol,</span>
<a href="#l20.8789"></a><span id="l20.8789" class="difflineplus">+                              nsIMsgMailNewsUrl *aUrl, bool isRunning,</span>
<a href="#l20.8790"></a><span id="l20.8790" class="difflineplus">+                              bool aSuspend, nsresult statusCode) {</span>
<a href="#l20.8791"></a><span id="l20.8791">   // If we have no path, then the folder has been shutdown, and there's</span>
<a href="#l20.8792"></a><span id="l20.8792">   // no point in doing anything...</span>
<a href="#l20.8793"></a><span id="l20.8793" class="difflineminus">-  if (!mPath)</span>
<a href="#l20.8794"></a><span id="l20.8794" class="difflineminus">-    return NS_OK;</span>
<a href="#l20.8795"></a><span id="l20.8795" class="difflineminus">-  if (!isRunning)</span>
<a href="#l20.8796"></a><span id="l20.8796" class="difflineminus">-  {</span>
<a href="#l20.8797"></a><span id="l20.8797" class="difflineplus">+  if (!mPath) return NS_OK;</span>
<a href="#l20.8798"></a><span id="l20.8798" class="difflineplus">+  if (!isRunning) {</span>
<a href="#l20.8799"></a><span id="l20.8799">     ProgressStatusString(aProtocol, &quot;imapDone&quot;, nullptr);</span>
<a href="#l20.8800"></a><span id="l20.8800">     m_urlRunning = false;</span>
<a href="#l20.8801"></a><span id="l20.8801">     // if no protocol, then we're reading from the mem or disk cache</span>
<a href="#l20.8802"></a><span id="l20.8802">     // and we don't want to end the offline download just yet.</span>
<a href="#l20.8803"></a><span id="l20.8803" class="difflineminus">-    if (aProtocol)</span>
<a href="#l20.8804"></a><span id="l20.8804" class="difflineminus">-    {</span>
<a href="#l20.8805"></a><span id="l20.8805" class="difflineplus">+    if (aProtocol) {</span>
<a href="#l20.8806"></a><span id="l20.8806">       EndOfflineDownload();</span>
<a href="#l20.8807"></a><span id="l20.8807" class="difflineminus">-        m_downloadingFolderForOfflineUse = false;</span>
<a href="#l20.8808"></a><span id="l20.8808" class="difflineminus">-      }</span>
<a href="#l20.8809"></a><span id="l20.8809" class="difflineplus">+      m_downloadingFolderForOfflineUse = false;</span>
<a href="#l20.8810"></a><span id="l20.8810" class="difflineplus">+    }</span>
<a href="#l20.8811"></a><span id="l20.8811">     nsCOMPtr&lt;nsIImapUrl&gt; imapUrl(do_QueryInterface(aUrl));</span>
<a href="#l20.8812"></a><span id="l20.8812" class="difflineminus">-    if (imapUrl)</span>
<a href="#l20.8813"></a><span id="l20.8813" class="difflineminus">-    {</span>
<a href="#l20.8814"></a><span id="l20.8814" class="difflineplus">+    if (imapUrl) {</span>
<a href="#l20.8815"></a><span id="l20.8815">       nsImapAction imapAction;</span>
<a href="#l20.8816"></a><span id="l20.8816">       imapUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l20.8817"></a><span id="l20.8817">       // if the server doesn't support copyUID, then SetCopyResponseUid won't</span>
<a href="#l20.8818"></a><span id="l20.8818">       // get called, so we need to clear m_pendingOfflineMoves when the online</span>
<a href="#l20.8819"></a><span id="l20.8819">       // move operation has finished.</span>
<a href="#l20.8820"></a><span id="l20.8820">       if (imapAction == nsIImapUrl::nsImapOnlineMove)</span>
<a href="#l20.8821"></a><span id="l20.8821">         m_pendingOfflineMoves.Clear();</span>
<a href="#l20.8822"></a><span id="l20.8822">     }</span>
<a href="#l20.8823"></a><span id="l20.8823">   }</span>
<a href="#l20.8824"></a><span id="l20.8824" class="difflineminus">-  if (aUrl &amp;&amp; !aSuspend)</span>
<a href="#l20.8825"></a><span id="l20.8825" class="difflineminus">-      return aUrl-&gt;SetUrlState(isRunning, statusCode);</span>
<a href="#l20.8826"></a><span id="l20.8826" class="difflineplus">+  if (aUrl &amp;&amp; !aSuspend) return aUrl-&gt;SetUrlState(isRunning, statusCode);</span>
<a href="#l20.8827"></a><span id="l20.8827">   return statusCode;</span>
<a href="#l20.8828"></a><span id="l20.8828"> }</span>
<a href="#l20.8829"></a><span id="l20.8829"> </span>
<a href="#l20.8830"></a><span id="l20.8830"> // used when copying from local mail folder, or other imap server)</span>
<a href="#l20.8831"></a><span id="l20.8831" class="difflineminus">-nsresult</span>
<a href="#l20.8832"></a><span id="l20.8832" class="difflineminus">-nsImapMailFolder::CopyMessagesWithStream(nsIMsgFolder* srcFolder,</span>
<a href="#l20.8833"></a><span id="l20.8833" class="difflineminus">-                                nsIArray* messages,</span>
<a href="#l20.8834"></a><span id="l20.8834" class="difflineminus">-                                bool isMove,</span>
<a href="#l20.8835"></a><span id="l20.8835" class="difflineminus">-                                bool isCrossServerOp,</span>
<a href="#l20.8836"></a><span id="l20.8836" class="difflineminus">-                                nsIMsgWindow *msgWindow,</span>
<a href="#l20.8837"></a><span id="l20.8837" class="difflineminus">-                                nsIMsgCopyServiceListener* listener,</span>
<a href="#l20.8838"></a><span id="l20.8838" class="difflineminus">-                                bool allowUndo)</span>
<a href="#l20.8839"></a><span id="l20.8839" class="difflineminus">-{</span>
<a href="#l20.8840"></a><span id="l20.8840" class="difflineplus">+nsresult nsImapMailFolder::CopyMessagesWithStream(</span>
<a href="#l20.8841"></a><span id="l20.8841" class="difflineplus">+    nsIMsgFolder *srcFolder, nsIArray *messages, bool isMove,</span>
<a href="#l20.8842"></a><span id="l20.8842" class="difflineplus">+    bool isCrossServerOp, nsIMsgWindow *msgWindow,</span>
<a href="#l20.8843"></a><span id="l20.8843" class="difflineplus">+    nsIMsgCopyServiceListener *listener, bool allowUndo) {</span>
<a href="#l20.8844"></a><span id="l20.8844">   NS_ENSURE_ARG_POINTER(srcFolder);</span>
<a href="#l20.8845"></a><span id="l20.8845">   NS_ENSURE_ARG_POINTER(messages);</span>
<a href="#l20.8846"></a><span id="l20.8846">   nsresult rv;</span>
<a href="#l20.8847"></a><span id="l20.8847">   nsCOMPtr&lt;nsISupports&gt; aSupport(do_QueryInterface(srcFolder, &amp;rv));</span>
<a href="#l20.8848"></a><span id="l20.8848">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.8849"></a><span id="l20.8849" class="difflineminus">-  rv = InitCopyState(aSupport, messages, isMove, false, isCrossServerOp,</span>
<a href="#l20.8850"></a><span id="l20.8850" class="difflineminus">-                     0, EmptyCString(), listener, msgWindow, allowUndo);</span>
<a href="#l20.8851"></a><span id="l20.8851" class="difflineminus">-  if(NS_FAILED(rv))</span>
<a href="#l20.8852"></a><span id="l20.8852" class="difflineminus">-    return rv;</span>
<a href="#l20.8853"></a><span id="l20.8853" class="difflineplus">+  rv = InitCopyState(aSupport, messages, isMove, false, isCrossServerOp, 0,</span>
<a href="#l20.8854"></a><span id="l20.8854" class="difflineplus">+                     EmptyCString(), listener, msgWindow, allowUndo);</span>
<a href="#l20.8855"></a><span id="l20.8855" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.8856"></a><span id="l20.8856"> </span>
<a href="#l20.8857"></a><span id="l20.8857">   m_copyState-&gt;m_streamCopy = true;</span>
<a href="#l20.8858"></a><span id="l20.8858"> </span>
<a href="#l20.8859"></a><span id="l20.8859">   // ** jt - needs to create server to server move/copy undo msg txn</span>
<a href="#l20.8860"></a><span id="l20.8860" class="difflineminus">-  if (m_copyState-&gt;m_allowUndo)</span>
<a href="#l20.8861"></a><span id="l20.8861" class="difflineminus">-  {</span>
<a href="#l20.8862"></a><span id="l20.8862" class="difflineplus">+  if (m_copyState-&gt;m_allowUndo) {</span>
<a href="#l20.8863"></a><span id="l20.8863">     nsAutoCString messageIds;</span>
<a href="#l20.8864"></a><span id="l20.8864">     nsTArray&lt;nsMsgKey&gt; srcKeyArray;</span>
<a href="#l20.8865"></a><span id="l20.8865">     rv = BuildIdsAndKeyArray(messages, messageIds, srcKeyArray);</span>
<a href="#l20.8866"></a><span id="l20.8866"> </span>
<a href="#l20.8867"></a><span id="l20.8867">     RefPtr&lt;nsImapMoveCopyMsgTxn&gt; undoMsgTxn = new nsImapMoveCopyMsgTxn;</span>
<a href="#l20.8868"></a><span id="l20.8868"> </span>
<a href="#l20.8869"></a><span id="l20.8869" class="difflineminus">-    if (!undoMsgTxn || NS_FAILED(undoMsgTxn-&gt;Init(srcFolder, &amp;srcKeyArray, messageIds.get(), this,</span>
<a href="#l20.8870"></a><span id="l20.8870" class="difflineminus">-                                true, isMove)))</span>
<a href="#l20.8871"></a><span id="l20.8871" class="difflineplus">+    if (!undoMsgTxn ||</span>
<a href="#l20.8872"></a><span id="l20.8872" class="difflineplus">+        NS_FAILED(undoMsgTxn-&gt;Init(srcFolder, &amp;srcKeyArray, messageIds.get(),</span>
<a href="#l20.8873"></a><span id="l20.8873" class="difflineplus">+                                   this, true, isMove)))</span>
<a href="#l20.8874"></a><span id="l20.8874">       return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.8875"></a><span id="l20.8875"> </span>
<a href="#l20.8876"></a><span id="l20.8876" class="difflineminus">-    if (isMove)</span>
<a href="#l20.8877"></a><span id="l20.8877" class="difflineminus">-    {</span>
<a href="#l20.8878"></a><span id="l20.8878" class="difflineplus">+    if (isMove) {</span>
<a href="#l20.8879"></a><span id="l20.8879">       if (mFlags &amp; nsMsgFolderFlags::Trash)</span>
<a href="#l20.8880"></a><span id="l20.8880">         undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eDeleteMsg);</span>
<a href="#l20.8881"></a><span id="l20.8881">       else</span>
<a href="#l20.8882"></a><span id="l20.8882">         undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eMoveMsg);</span>
<a href="#l20.8883"></a><span id="l20.8883" class="difflineminus">-    }</span>
<a href="#l20.8884"></a><span id="l20.8884" class="difflineminus">-    else</span>
<a href="#l20.8885"></a><span id="l20.8885" class="difflineplus">+    } else</span>
<a href="#l20.8886"></a><span id="l20.8886">       undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eCopyMsg);</span>
<a href="#l20.8887"></a><span id="l20.8887">     m_copyState-&gt;m_undoMsgTxn = undoMsgTxn;</span>
<a href="#l20.8888"></a><span id="l20.8888">   }</span>
<a href="#l20.8889"></a><span id="l20.8889">   nsCOMPtr&lt;nsIMsgDBHdr&gt; msg;</span>
<a href="#l20.8890"></a><span id="l20.8890">   msg = do_QueryElementAt(messages, 0, &amp;rv);</span>
<a href="#l20.8891"></a><span id="l20.8891" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l20.8892"></a><span id="l20.8892" class="difflineminus">-    CopyStreamMessage(msg, this, msgWindow, isMove);</span>
<a href="#l20.8893"></a><span id="l20.8893" class="difflineminus">-  return rv; //we are clearing copy state in CopyMessages on failure</span>
<a href="#l20.8894"></a><span id="l20.8894" class="difflineminus">-}</span>
<a href="#l20.8895"></a><span id="l20.8895" class="difflineminus">-</span>
<a href="#l20.8896"></a><span id="l20.8896" class="difflineminus">-nsresult nsImapMailFolder::GetClearedOriginalOp(nsIMsgOfflineImapOperation *op, nsIMsgOfflineImapOperation **originalOp, nsIMsgDatabase **originalDB)</span>
<a href="#l20.8897"></a><span id="l20.8897" class="difflineminus">-{</span>
<a href="#l20.8898"></a><span id="l20.8898" class="difflineplus">+  if (NS_SUCCEEDED(rv)) CopyStreamMessage(msg, this, msgWindow, isMove);</span>
<a href="#l20.8899"></a><span id="l20.8899" class="difflineplus">+  return rv;  // we are clearing copy state in CopyMessages on failure</span>
<a href="#l20.8900"></a><span id="l20.8900" class="difflineplus">+}</span>
<a href="#l20.8901"></a><span id="l20.8901" class="difflineplus">+</span>
<a href="#l20.8902"></a><span id="l20.8902" class="difflineplus">+nsresult nsImapMailFolder::GetClearedOriginalOp(</span>
<a href="#l20.8903"></a><span id="l20.8903" class="difflineplus">+    nsIMsgOfflineImapOperation *op, nsIMsgOfflineImapOperation **originalOp,</span>
<a href="#l20.8904"></a><span id="l20.8904" class="difflineplus">+    nsIMsgDatabase **originalDB) {</span>
<a href="#l20.8905"></a><span id="l20.8905">   nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; returnOp;</span>
<a href="#l20.8906"></a><span id="l20.8906">   nsOfflineImapOperationType opType;</span>
<a href="#l20.8907"></a><span id="l20.8907">   op-&gt;GetOperation(&amp;opType);</span>
<a href="#l20.8908"></a><span id="l20.8908" class="difflineminus">-  NS_ASSERTION(opType &amp; nsIMsgOfflineImapOperation::kMoveResult, &quot;not an offline move op&quot;);</span>
<a href="#l20.8909"></a><span id="l20.8909" class="difflineplus">+  NS_ASSERTION(opType &amp; nsIMsgOfflineImapOperation::kMoveResult,</span>
<a href="#l20.8910"></a><span id="l20.8910" class="difflineplus">+               &quot;not an offline move op&quot;);</span>
<a href="#l20.8911"></a><span id="l20.8911"> </span>
<a href="#l20.8912"></a><span id="l20.8912">   nsCString sourceFolderURI;</span>
<a href="#l20.8913"></a><span id="l20.8913">   op-&gt;GetSourceFolderURI(getter_Copies(sourceFolderURI));</span>
<a href="#l20.8914"></a><span id="l20.8914"> </span>
<a href="#l20.8915"></a><span id="l20.8915">   nsresult rv;</span>
<a href="#l20.8916"></a><span id="l20.8916">   nsCOMPtr&lt;nsIMsgFolder&gt; sourceFolder;</span>
<a href="#l20.8917"></a><span id="l20.8917">   rv = GetOrCreateFolder(sourceFolderURI, getter_AddRefs(sourceFolder));</span>
<a href="#l20.8918"></a><span id="l20.8918">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.8919"></a><span id="l20.8919"> </span>
<a href="#l20.8920"></a><span id="l20.8920">   nsCOMPtr&lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l20.8921"></a><span id="l20.8921">   sourceFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(folderInfo), originalDB);</span>
<a href="#l20.8922"></a><span id="l20.8922" class="difflineminus">-  if (*originalDB)</span>
<a href="#l20.8923"></a><span id="l20.8923" class="difflineminus">-  {</span>
<a href="#l20.8924"></a><span id="l20.8924" class="difflineplus">+  if (*originalDB) {</span>
<a href="#l20.8925"></a><span id="l20.8925">     nsMsgKey originalKey;</span>
<a href="#l20.8926"></a><span id="l20.8926">     op-&gt;GetMessageKey(&amp;originalKey);</span>
<a href="#l20.8927"></a><span id="l20.8927" class="difflineminus">-    rv = (*originalDB)-&gt;GetOfflineOpForKey(originalKey, false, getter_AddRefs(returnOp));</span>
<a href="#l20.8928"></a><span id="l20.8928" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; returnOp)</span>
<a href="#l20.8929"></a><span id="l20.8929" class="difflineminus">-    {</span>
<a href="#l20.8930"></a><span id="l20.8930" class="difflineplus">+    rv = (*originalDB)</span>
<a href="#l20.8931"></a><span id="l20.8931" class="difflineplus">+             -&gt;GetOfflineOpForKey(originalKey, false, getter_AddRefs(returnOp));</span>
<a href="#l20.8932"></a><span id="l20.8932" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; returnOp) {</span>
<a href="#l20.8933"></a><span id="l20.8933">       nsCString moveDestination;</span>
<a href="#l20.8934"></a><span id="l20.8934">       nsCString thisFolderURI;</span>
<a href="#l20.8935"></a><span id="l20.8935">       GetURI(thisFolderURI);</span>
<a href="#l20.8936"></a><span id="l20.8936">       returnOp-&gt;GetDestinationFolderURI(getter_Copies(moveDestination));</span>
<a href="#l20.8937"></a><span id="l20.8937">       if (moveDestination.Equals(thisFolderURI))</span>
<a href="#l20.8938"></a><span id="l20.8938">         returnOp-&gt;ClearOperation(nsIMsgOfflineImapOperation::kMoveResult);</span>
<a href="#l20.8939"></a><span id="l20.8939">     }</span>
<a href="#l20.8940"></a><span id="l20.8940">   }</span>
<a href="#l20.8941"></a><span id="l20.8941">   returnOp.forget(originalOp);</span>
<a href="#l20.8942"></a><span id="l20.8942">   return rv;</span>
<a href="#l20.8943"></a><span id="l20.8943"> }</span>
<a href="#l20.8944"></a><span id="l20.8944"> </span>
<a href="#l20.8945"></a><span id="l20.8945" class="difflineminus">-nsresult nsImapMailFolder::GetOriginalOp(nsIMsgOfflineImapOperation *op, nsIMsgOfflineImapOperation **originalOp, nsIMsgDatabase **originalDB)</span>
<a href="#l20.8946"></a><span id="l20.8946" class="difflineminus">-{</span>
<a href="#l20.8947"></a><span id="l20.8947" class="difflineplus">+nsresult nsImapMailFolder::GetOriginalOp(</span>
<a href="#l20.8948"></a><span id="l20.8948" class="difflineplus">+    nsIMsgOfflineImapOperation *op, nsIMsgOfflineImapOperation **originalOp,</span>
<a href="#l20.8949"></a><span id="l20.8949" class="difflineplus">+    nsIMsgDatabase **originalDB) {</span>
<a href="#l20.8950"></a><span id="l20.8950">   nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; returnOp;</span>
<a href="#l20.8951"></a><span id="l20.8951">   nsCString sourceFolderURI;</span>
<a href="#l20.8952"></a><span id="l20.8952">   op-&gt;GetSourceFolderURI(getter_Copies(sourceFolderURI));</span>
<a href="#l20.8953"></a><span id="l20.8953"> </span>
<a href="#l20.8954"></a><span id="l20.8954">   nsresult rv;</span>
<a href="#l20.8955"></a><span id="l20.8955">   nsCOMPtr&lt;nsIMsgFolder&gt; sourceFolder;</span>
<a href="#l20.8956"></a><span id="l20.8956">   rv = GetOrCreateFolder(sourceFolderURI, getter_AddRefs(sourceFolder));</span>
<a href="#l20.8957"></a><span id="l20.8957">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.8958"></a><span id="l20.8958">   nsCOMPtr&lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l20.8959"></a><span id="l20.8959">   sourceFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(folderInfo), originalDB);</span>
<a href="#l20.8960"></a><span id="l20.8960" class="difflineminus">-  if (*originalDB)</span>
<a href="#l20.8961"></a><span id="l20.8961" class="difflineminus">-  {</span>
<a href="#l20.8962"></a><span id="l20.8962" class="difflineplus">+  if (*originalDB) {</span>
<a href="#l20.8963"></a><span id="l20.8963">     nsMsgKey originalKey;</span>
<a href="#l20.8964"></a><span id="l20.8964">     op-&gt;GetMessageKey(&amp;originalKey);</span>
<a href="#l20.8965"></a><span id="l20.8965" class="difflineminus">-    rv = (*originalDB)-&gt;GetOfflineOpForKey(originalKey, false, getter_AddRefs(returnOp));</span>
<a href="#l20.8966"></a><span id="l20.8966" class="difflineplus">+    rv = (*originalDB)</span>
<a href="#l20.8967"></a><span id="l20.8967" class="difflineplus">+             -&gt;GetOfflineOpForKey(originalKey, false, getter_AddRefs(returnOp));</span>
<a href="#l20.8968"></a><span id="l20.8968">   }</span>
<a href="#l20.8969"></a><span id="l20.8969">   returnOp.forget(originalOp);</span>
<a href="#l20.8970"></a><span id="l20.8970">   return rv;</span>
<a href="#l20.8971"></a><span id="l20.8971"> }</span>
<a href="#l20.8972"></a><span id="l20.8972"> </span>
<a href="#l20.8973"></a><span id="l20.8973"> nsresult nsImapMailFolder::CopyOfflineMsgBody(nsIMsgFolder *srcFolder,</span>
<a href="#l20.8974"></a><span id="l20.8974">                                               nsIMsgDBHdr *destHdr,</span>
<a href="#l20.8975"></a><span id="l20.8975">                                               nsIMsgDBHdr *origHdr,</span>
<a href="#l20.8976"></a><span id="l20.8976">                                               nsIInputStream *inputStream,</span>
<a href="#l20.8977"></a><span id="l20.8977" class="difflineminus">-                                              nsIOutputStream *outputStream)</span>
<a href="#l20.8978"></a><span id="l20.8978" class="difflineminus">-{</span>
<a href="#l20.8979"></a><span id="l20.8979" class="difflineplus">+                                              nsIOutputStream *outputStream) {</span>
<a href="#l20.8980"></a><span id="l20.8980">   nsresult rv;</span>
<a href="#l20.8981"></a><span id="l20.8981" class="difflineminus">-  nsCOMPtr &lt;nsISeekableStream&gt; seekable (do_QueryInterface(outputStream, &amp;rv));</span>
<a href="#l20.8982"></a><span id="l20.8982" class="difflineplus">+  nsCOMPtr&lt;nsISeekableStream&gt; seekable(do_QueryInterface(outputStream, &amp;rv));</span>
<a href="#l20.8983"></a><span id="l20.8983">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.8984"></a><span id="l20.8984">   uint64_t messageOffset;</span>
<a href="#l20.8985"></a><span id="l20.8985">   uint32_t messageSize;</span>
<a href="#l20.8986"></a><span id="l20.8986">   origHdr-&gt;GetMessageOffset(&amp;messageOffset);</span>
<a href="#l20.8987"></a><span id="l20.8987" class="difflineminus">-  if (!messageOffset)</span>
<a href="#l20.8988"></a><span id="l20.8988" class="difflineminus">-  {</span>
<a href="#l20.8989"></a><span id="l20.8989" class="difflineplus">+  if (!messageOffset) {</span>
<a href="#l20.8990"></a><span id="l20.8990">     // Some offline stores may contain a bug where the storeToken is set but</span>
<a href="#l20.8991"></a><span id="l20.8991">     // the messageOffset is zero. Detect cases like this, and use storeToken</span>
<a href="#l20.8992"></a><span id="l20.8992">     // to set the missing messageOffset. Note this assumes mbox.</span>
<a href="#l20.8993"></a><span id="l20.8993">     nsCOMPtr&lt;nsIMsgPluggableStore&gt; offlineStore;</span>
<a href="#l20.8994"></a><span id="l20.8994" class="difflineminus">-    (void) GetMsgStore(getter_AddRefs(offlineStore));</span>
<a href="#l20.8995"></a><span id="l20.8995" class="difflineminus">-    if (offlineStore)</span>
<a href="#l20.8996"></a><span id="l20.8996" class="difflineminus">-    {</span>
<a href="#l20.8997"></a><span id="l20.8997" class="difflineplus">+    (void)GetMsgStore(getter_AddRefs(offlineStore));</span>
<a href="#l20.8998"></a><span id="l20.8998" class="difflineplus">+    if (offlineStore) {</span>
<a href="#l20.8999"></a><span id="l20.8999">       nsAutoCString type;</span>
<a href="#l20.9000"></a><span id="l20.9000">       offlineStore-&gt;GetStoreType(type);</span>
<a href="#l20.9001"></a><span id="l20.9001" class="difflineminus">-      if (type.EqualsLiteral(&quot;mbox&quot;))</span>
<a href="#l20.9002"></a><span id="l20.9002" class="difflineminus">-      {</span>
<a href="#l20.9003"></a><span id="l20.9003" class="difflineplus">+      if (type.EqualsLiteral(&quot;mbox&quot;)) {</span>
<a href="#l20.9004"></a><span id="l20.9004">         nsCString storeToken;</span>
<a href="#l20.9005"></a><span id="l20.9005">         origHdr-&gt;GetStringProperty(&quot;storeToken&quot;, getter_Copies(storeToken));</span>
<a href="#l20.9006"></a><span id="l20.9006">         if (!storeToken.IsEmpty())</span>
<a href="#l20.9007"></a><span id="l20.9007">           messageOffset = ParseUint64Str(storeToken.get());</span>
<a href="#l20.9008"></a><span id="l20.9008">       }</span>
<a href="#l20.9009"></a><span id="l20.9009">     }</span>
<a href="#l20.9010"></a><span id="l20.9010">   }</span>
<a href="#l20.9011"></a><span id="l20.9011">   origHdr-&gt;GetOfflineMessageSize(&amp;messageSize);</span>
<a href="#l20.9012"></a><span id="l20.9012" class="difflineminus">-  if (!messageSize)</span>
<a href="#l20.9013"></a><span id="l20.9013" class="difflineminus">-  {</span>
<a href="#l20.9014"></a><span id="l20.9014" class="difflineplus">+  if (!messageSize) {</span>
<a href="#l20.9015"></a><span id="l20.9015">     nsCOMPtr&lt;nsIMsgLocalMailFolder&gt; localFolder = do_QueryInterface(srcFolder);</span>
<a href="#l20.9016"></a><span id="l20.9016" class="difflineminus">-    if (localFolder)   //can just use regular message size</span>
<a href="#l20.9017"></a><span id="l20.9017" class="difflineplus">+    if (localFolder)  // can just use regular message size</span>
<a href="#l20.9018"></a><span id="l20.9018">       origHdr-&gt;GetMessageSize(&amp;messageSize);</span>
<a href="#l20.9019"></a><span id="l20.9019">   }</span>
<a href="#l20.9020"></a><span id="l20.9020">   int64_t tellPos;</span>
<a href="#l20.9021"></a><span id="l20.9021">   seekable-&gt;Tell(&amp;tellPos);</span>
<a href="#l20.9022"></a><span id="l20.9022">   destHdr-&gt;SetMessageOffset(tellPos);</span>
<a href="#l20.9023"></a><span id="l20.9023">   nsCOMPtr&lt;nsISeekableStream&gt; seekStream = do_QueryInterface(inputStream);</span>
<a href="#l20.9024"></a><span id="l20.9024">   NS_ASSERTION(seekStream, &quot;non seekable stream - can't read from offline msg&quot;);</span>
<a href="#l20.9025"></a><span id="l20.9025" class="difflineminus">-  if (seekStream)</span>
<a href="#l20.9026"></a><span id="l20.9026" class="difflineminus">-  {</span>
<a href="#l20.9027"></a><span id="l20.9027" class="difflineplus">+  if (seekStream) {</span>
<a href="#l20.9028"></a><span id="l20.9028">     rv = seekStream-&gt;Seek(nsISeekableStream::NS_SEEK_SET, messageOffset);</span>
<a href="#l20.9029"></a><span id="l20.9029" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l20.9030"></a><span id="l20.9030" class="difflineminus">-    {</span>
<a href="#l20.9031"></a><span id="l20.9031" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.9032"></a><span id="l20.9032">       // now, copy the dest folder offline store msg to the temp file</span>
<a href="#l20.9033"></a><span id="l20.9033" class="difflineminus">-      char *inputBuffer = (char *) PR_Malloc(FILE_IO_BUFFER_SIZE);</span>
<a href="#l20.9034"></a><span id="l20.9034" class="difflineplus">+      char *inputBuffer = (char *)PR_Malloc(FILE_IO_BUFFER_SIZE);</span>
<a href="#l20.9035"></a><span id="l20.9035">       int32_t bytesLeft;</span>
<a href="#l20.9036"></a><span id="l20.9036">       uint32_t bytesRead, bytesWritten;</span>
<a href="#l20.9037"></a><span id="l20.9037">       bytesLeft = messageSize;</span>
<a href="#l20.9038"></a><span id="l20.9038">       rv = (inputBuffer) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.9039"></a><span id="l20.9039" class="difflineminus">-      while (bytesLeft &gt; 0 &amp;&amp; NS_SUCCEEDED(rv))</span>
<a href="#l20.9040"></a><span id="l20.9040" class="difflineminus">-      {</span>
<a href="#l20.9041"></a><span id="l20.9041" class="difflineplus">+      while (bytesLeft &gt; 0 &amp;&amp; NS_SUCCEEDED(rv)) {</span>
<a href="#l20.9042"></a><span id="l20.9042">         rv = inputStream-&gt;Read(inputBuffer, FILE_IO_BUFFER_SIZE, &amp;bytesRead);</span>
<a href="#l20.9043"></a><span id="l20.9043" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; bytesRead &gt; 0)</span>
<a href="#l20.9044"></a><span id="l20.9044" class="difflineminus">-        {</span>
<a href="#l20.9045"></a><span id="l20.9045" class="difflineminus">-          rv = outputStream-&gt;Write(inputBuffer, std::min((int32_t) bytesRead, bytesLeft), &amp;bytesWritten);</span>
<a href="#l20.9046"></a><span id="l20.9046" class="difflineminus">-          NS_ASSERTION((int32_t) bytesWritten == std::min((int32_t) bytesRead, bytesLeft), &quot;wrote out incorrect number of bytes&quot;);</span>
<a href="#l20.9047"></a><span id="l20.9047" class="difflineminus">-        }</span>
<a href="#l20.9048"></a><span id="l20.9048" class="difflineminus">-        else</span>
<a href="#l20.9049"></a><span id="l20.9049" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; bytesRead &gt; 0) {</span>
<a href="#l20.9050"></a><span id="l20.9050" class="difflineplus">+          rv = outputStream-&gt;Write(inputBuffer,</span>
<a href="#l20.9051"></a><span id="l20.9051" class="difflineplus">+                                   std::min((int32_t)bytesRead, bytesLeft),</span>
<a href="#l20.9052"></a><span id="l20.9052" class="difflineplus">+                                   &amp;bytesWritten);</span>
<a href="#l20.9053"></a><span id="l20.9053" class="difflineplus">+          NS_ASSERTION(</span>
<a href="#l20.9054"></a><span id="l20.9054" class="difflineplus">+              (int32_t)bytesWritten == std::min((int32_t)bytesRead, bytesLeft),</span>
<a href="#l20.9055"></a><span id="l20.9055" class="difflineplus">+              &quot;wrote out incorrect number of bytes&quot;);</span>
<a href="#l20.9056"></a><span id="l20.9056" class="difflineplus">+        } else</span>
<a href="#l20.9057"></a><span id="l20.9057">           break;</span>
<a href="#l20.9058"></a><span id="l20.9058">         bytesLeft -= bytesRead;</span>
<a href="#l20.9059"></a><span id="l20.9059">       }</span>
<a href="#l20.9060"></a><span id="l20.9060">       PR_FREEIF(inputBuffer);</span>
<a href="#l20.9061"></a><span id="l20.9061">     }</span>
<a href="#l20.9062"></a><span id="l20.9062">   }</span>
<a href="#l20.9063"></a><span id="l20.9063" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l20.9064"></a><span id="l20.9064" class="difflineminus">-  {</span>
<a href="#l20.9065"></a><span id="l20.9065" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.9066"></a><span id="l20.9066">     outputStream-&gt;Flush();</span>
<a href="#l20.9067"></a><span id="l20.9067">     uint32_t resultFlags;</span>
<a href="#l20.9068"></a><span id="l20.9068">     destHdr-&gt;OrFlags(nsMsgMessageFlags::Offline, &amp;resultFlags);</span>
<a href="#l20.9069"></a><span id="l20.9069">     destHdr-&gt;SetOfflineMessageSize(messageSize);</span>
<a href="#l20.9070"></a><span id="l20.9070">   }</span>
<a href="#l20.9071"></a><span id="l20.9071">   return rv;</span>
<a href="#l20.9072"></a><span id="l20.9072"> }</span>
<a href="#l20.9073"></a><span id="l20.9073"> </span>
<a href="#l20.9074"></a><span id="l20.9074" class="difflineminus">-nsresult nsImapMailFolder::FindOpenRange(nsMsgKey &amp;fakeBase, uint32_t srcCount)</span>
<a href="#l20.9075"></a><span id="l20.9075" class="difflineminus">-{</span>
<a href="#l20.9076"></a><span id="l20.9076" class="difflineplus">+nsresult nsImapMailFolder::FindOpenRange(nsMsgKey &amp;fakeBase,</span>
<a href="#l20.9077"></a><span id="l20.9077" class="difflineplus">+                                         uint32_t srcCount) {</span>
<a href="#l20.9078"></a><span id="l20.9078">   nsresult rv = GetDatabase();</span>
<a href="#l20.9079"></a><span id="l20.9079">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.9080"></a><span id="l20.9080"> </span>
<a href="#l20.9081"></a><span id="l20.9081">   nsMsgKey newBase = fakeBase - 1;</span>
<a href="#l20.9082"></a><span id="l20.9082">   uint32_t freeCount = 0;</span>
<a href="#l20.9083"></a><span id="l20.9083" class="difflineminus">-  while (freeCount != srcCount &amp;&amp; newBase &gt; 0)</span>
<a href="#l20.9084"></a><span id="l20.9084" class="difflineminus">-  {</span>
<a href="#l20.9085"></a><span id="l20.9085" class="difflineplus">+  while (freeCount != srcCount &amp;&amp; newBase &gt; 0) {</span>
<a href="#l20.9086"></a><span id="l20.9086">     bool containsKey;</span>
<a href="#l20.9087"></a><span id="l20.9087" class="difflineminus">-    if (NS_SUCCEEDED(mDatabase-&gt;ContainsKey(newBase, &amp;containsKey))</span>
<a href="#l20.9088"></a><span id="l20.9088" class="difflineminus">-        &amp;&amp; !containsKey)</span>
<a href="#l20.9089"></a><span id="l20.9089" class="difflineplus">+    if (NS_SUCCEEDED(mDatabase-&gt;ContainsKey(newBase, &amp;containsKey)) &amp;&amp;</span>
<a href="#l20.9090"></a><span id="l20.9090" class="difflineplus">+        !containsKey)</span>
<a href="#l20.9091"></a><span id="l20.9091">       freeCount++;</span>
<a href="#l20.9092"></a><span id="l20.9092">     else</span>
<a href="#l20.9093"></a><span id="l20.9093">       freeCount = 0;</span>
<a href="#l20.9094"></a><span id="l20.9094">     newBase--;</span>
<a href="#l20.9095"></a><span id="l20.9095">   }</span>
<a href="#l20.9096"></a><span id="l20.9096" class="difflineminus">-  if (!newBase)</span>
<a href="#l20.9097"></a><span id="l20.9097" class="difflineminus">-    return NS_ERROR_FAILURE;</span>
<a href="#l20.9098"></a><span id="l20.9098" class="difflineplus">+  if (!newBase) return NS_ERROR_FAILURE;</span>
<a href="#l20.9099"></a><span id="l20.9099">   fakeBase = newBase;</span>
<a href="#l20.9100"></a><span id="l20.9100">   return NS_OK;</span>
<a href="#l20.9101"></a><span id="l20.9101"> }</span>
<a href="#l20.9102"></a><span id="l20.9102"> </span>
<a href="#l20.9103"></a><span id="l20.9103"> // this imap folder is the destination of an offline move/copy.</span>
<a href="#l20.9104"></a><span id="l20.9104" class="difflineminus">-// We are either offline, or doing a pseudo-offline delete (where we do an offline</span>
<a href="#l20.9105"></a><span id="l20.9105" class="difflineminus">-// delete, load the next message, then playback the offline delete).</span>
<a href="#l20.9106"></a><span id="l20.9106" class="difflineminus">-nsresult nsImapMailFolder::CopyMessagesOffline(nsIMsgFolder* srcFolder,</span>
<a href="#l20.9107"></a><span id="l20.9107" class="difflineminus">-                               nsIArray* messages,</span>
<a href="#l20.9108"></a><span id="l20.9108" class="difflineminus">-                               bool isMove,</span>
<a href="#l20.9109"></a><span id="l20.9109" class="difflineminus">-                               nsIMsgWindow *msgWindow,</span>
<a href="#l20.9110"></a><span id="l20.9110" class="difflineminus">-                               nsIMsgCopyServiceListener* listener)</span>
<a href="#l20.9111"></a><span id="l20.9111" class="difflineminus">-{</span>
<a href="#l20.9112"></a><span id="l20.9112" class="difflineplus">+// We are either offline, or doing a pseudo-offline delete (where we do an</span>
<a href="#l20.9113"></a><span id="l20.9113" class="difflineplus">+// offline delete, load the next message, then playback the offline delete).</span>
<a href="#l20.9114"></a><span id="l20.9114" class="difflineplus">+nsresult nsImapMailFolder::CopyMessagesOffline(</span>
<a href="#l20.9115"></a><span id="l20.9115" class="difflineplus">+    nsIMsgFolder *srcFolder, nsIArray *messages, bool isMove,</span>
<a href="#l20.9116"></a><span id="l20.9116" class="difflineplus">+    nsIMsgWindow *msgWindow, nsIMsgCopyServiceListener *listener) {</span>
<a href="#l20.9117"></a><span id="l20.9117">   NS_ENSURE_ARG(messages);</span>
<a href="#l20.9118"></a><span id="l20.9118">   nsresult rv;</span>
<a href="#l20.9119"></a><span id="l20.9119">   nsresult stopit = NS_OK;</span>
<a href="#l20.9120"></a><span id="l20.9120" class="difflineminus">-  nsCOMPtr &lt;nsIMsgDatabase&gt; sourceMailDB;</span>
<a href="#l20.9121"></a><span id="l20.9121" class="difflineminus">-  nsCOMPtr &lt;nsIDBFolderInfo&gt; srcDbFolderInfo;</span>
<a href="#l20.9122"></a><span id="l20.9122" class="difflineminus">-  srcFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(srcDbFolderInfo), getter_AddRefs(sourceMailDB));</span>
<a href="#l20.9123"></a><span id="l20.9123" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDatabase&gt; sourceMailDB;</span>
<a href="#l20.9124"></a><span id="l20.9124" class="difflineplus">+  nsCOMPtr&lt;nsIDBFolderInfo&gt; srcDbFolderInfo;</span>
<a href="#l20.9125"></a><span id="l20.9125" class="difflineplus">+  srcFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(srcDbFolderInfo),</span>
<a href="#l20.9126"></a><span id="l20.9126" class="difflineplus">+                                  getter_AddRefs(sourceMailDB));</span>
<a href="#l20.9127"></a><span id="l20.9127">   bool deleteToTrash = false;</span>
<a href="#l20.9128"></a><span id="l20.9128">   bool deleteImmediately = false;</span>
<a href="#l20.9129"></a><span id="l20.9129">   uint32_t srcCount;</span>
<a href="#l20.9130"></a><span id="l20.9130">   messages-&gt;GetLength(&amp;srcCount);</span>
<a href="#l20.9131"></a><span id="l20.9131">   nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.9132"></a><span id="l20.9132">   rv = GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.9133"></a><span id="l20.9133" class="difflineminus">-  nsCOMPtr&lt;nsIMutableArray&gt; msgHdrsCopied(do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l20.9134"></a><span id="l20.9134" class="difflineplus">+  nsCOMPtr&lt;nsIMutableArray&gt; msgHdrsCopied(</span>
<a href="#l20.9135"></a><span id="l20.9135" class="difflineplus">+      do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l20.9136"></a><span id="l20.9136">   nsCOMPtr&lt;nsIMutableArray&gt; destMsgHdrs(do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l20.9137"></a><span id="l20.9137"> </span>
<a href="#l20.9138"></a><span id="l20.9138" class="difflineminus">-  if (!msgHdrsCopied || !destMsgHdrs)</span>
<a href="#l20.9139"></a><span id="l20.9139" class="difflineminus">-    return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.9140"></a><span id="l20.9140" class="difflineminus">-</span>
<a href="#l20.9141"></a><span id="l20.9141" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; imapServer)</span>
<a href="#l20.9142"></a><span id="l20.9142" class="difflineminus">-  {</span>
<a href="#l20.9143"></a><span id="l20.9143" class="difflineplus">+  if (!msgHdrsCopied || !destMsgHdrs) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.9144"></a><span id="l20.9144" class="difflineplus">+</span>
<a href="#l20.9145"></a><span id="l20.9145" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; imapServer) {</span>
<a href="#l20.9146"></a><span id="l20.9146">     nsMsgImapDeleteModel deleteModel;</span>
<a href="#l20.9147"></a><span id="l20.9147">     imapServer-&gt;GetDeleteModel(&amp;deleteModel);</span>
<a href="#l20.9148"></a><span id="l20.9148">     deleteToTrash = (deleteModel == nsMsgImapDeleteModels::MoveToTrash);</span>
<a href="#l20.9149"></a><span id="l20.9149">     deleteImmediately = (deleteModel == nsMsgImapDeleteModels::DeleteNoTrash);</span>
<a href="#l20.9150"></a><span id="l20.9150">   }</span>
<a href="#l20.9151"></a><span id="l20.9151"> </span>
<a href="#l20.9152"></a><span id="l20.9152">   // This array is used only when we are actually removing the messages from the</span>
<a href="#l20.9153"></a><span id="l20.9153">   // source database.</span>
<a href="#l20.9154"></a><span id="l20.9154" class="difflineminus">-  nsTArray&lt;nsMsgKey&gt; keysToDelete((isMove &amp;&amp; (deleteToTrash || deleteImmediately)) ? srcCount : 0);</span>
<a href="#l20.9155"></a><span id="l20.9155" class="difflineminus">-</span>
<a href="#l20.9156"></a><span id="l20.9156" class="difflineminus">-  if (sourceMailDB)</span>
<a href="#l20.9157"></a><span id="l20.9157" class="difflineminus">-  {</span>
<a href="#l20.9158"></a><span id="l20.9158" class="difflineminus">-    // save the future ops in the source DB, if this is not a imap-&gt;local copy/move</span>
<a href="#l20.9159"></a><span id="l20.9159" class="difflineminus">-    nsCOMPtr &lt;nsITransactionManager&gt; txnMgr;</span>
<a href="#l20.9160"></a><span id="l20.9160" class="difflineminus">-    if (msgWindow)</span>
<a href="#l20.9161"></a><span id="l20.9161" class="difflineminus">-      msgWindow-&gt;GetTransactionManager(getter_AddRefs(txnMgr));</span>
<a href="#l20.9162"></a><span id="l20.9162" class="difflineminus">-    if (txnMgr)</span>
<a href="#l20.9163"></a><span id="l20.9163" class="difflineminus">-      txnMgr-&gt;BeginBatch(nullptr);</span>
<a href="#l20.9164"></a><span id="l20.9164" class="difflineplus">+  nsTArray&lt;nsMsgKey&gt; keysToDelete(</span>
<a href="#l20.9165"></a><span id="l20.9165" class="difflineplus">+      (isMove &amp;&amp; (deleteToTrash || deleteImmediately)) ? srcCount : 0);</span>
<a href="#l20.9166"></a><span id="l20.9166" class="difflineplus">+</span>
<a href="#l20.9167"></a><span id="l20.9167" class="difflineplus">+  if (sourceMailDB) {</span>
<a href="#l20.9168"></a><span id="l20.9168" class="difflineplus">+    // save the future ops in the source DB, if this is not a imap-&gt;local</span>
<a href="#l20.9169"></a><span id="l20.9169" class="difflineplus">+    // copy/move</span>
<a href="#l20.9170"></a><span id="l20.9170" class="difflineplus">+    nsCOMPtr&lt;nsITransactionManager&gt; txnMgr;</span>
<a href="#l20.9171"></a><span id="l20.9171" class="difflineplus">+    if (msgWindow) msgWindow-&gt;GetTransactionManager(getter_AddRefs(txnMgr));</span>
<a href="#l20.9172"></a><span id="l20.9172" class="difflineplus">+    if (txnMgr) txnMgr-&gt;BeginBatch(nullptr);</span>
<a href="#l20.9173"></a><span id="l20.9173">     nsCOMPtr&lt;nsIMsgDatabase&gt; database;</span>
<a href="#l20.9174"></a><span id="l20.9174">     GetMsgDatabase(getter_AddRefs(database));</span>
<a href="#l20.9175"></a><span id="l20.9175" class="difflineminus">-    if (database)</span>
<a href="#l20.9176"></a><span id="l20.9176" class="difflineminus">-    {</span>
<a href="#l20.9177"></a><span id="l20.9177" class="difflineplus">+    if (database) {</span>
<a href="#l20.9178"></a><span id="l20.9178">       // get the highest key in the dest db, so we can make up our fake keys</span>
<a href="#l20.9179"></a><span id="l20.9179">       nsMsgKey fakeBase = 1;</span>
<a href="#l20.9180"></a><span id="l20.9180" class="difflineminus">-      nsCOMPtr &lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l20.9181"></a><span id="l20.9181" class="difflineplus">+      nsCOMPtr&lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l20.9182"></a><span id="l20.9182">       rv = database-&gt;GetDBFolderInfo(getter_AddRefs(folderInfo));</span>
<a href="#l20.9183"></a><span id="l20.9183">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.9184"></a><span id="l20.9184">       nsMsgKey highWaterMark = nsMsgKey_None;</span>
<a href="#l20.9185"></a><span id="l20.9185">       folderInfo-&gt;GetHighWater(&amp;highWaterMark);</span>
<a href="#l20.9186"></a><span id="l20.9186">       fakeBase += highWaterMark;</span>
<a href="#l20.9187"></a><span id="l20.9187">       nsMsgKey fakeTop = fakeBase + srcCount;</span>
<a href="#l20.9188"></a><span id="l20.9188">       // Check that we have enough room for the fake headers. If fakeTop</span>
<a href="#l20.9189"></a><span id="l20.9189">       // is &lt;= highWaterMark, we've overflowed.</span>
<a href="#l20.9190"></a><span id="l20.9190" class="difflineminus">-      if (fakeTop &lt;= highWaterMark || fakeTop == nsMsgKey_None)</span>
<a href="#l20.9191"></a><span id="l20.9191" class="difflineminus">-      {</span>
<a href="#l20.9192"></a><span id="l20.9192" class="difflineplus">+      if (fakeTop &lt;= highWaterMark || fakeTop == nsMsgKey_None) {</span>
<a href="#l20.9193"></a><span id="l20.9193">         rv = FindOpenRange(fakeBase, srcCount);</span>
<a href="#l20.9194"></a><span id="l20.9194">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.9195"></a><span id="l20.9195">       }</span>
<a href="#l20.9196"></a><span id="l20.9196">       // N.B. We must not return out of the for loop - we need the matching</span>
<a href="#l20.9197"></a><span id="l20.9197">       // end notifications to be sent.</span>
<a href="#l20.9198"></a><span id="l20.9198">       // We don't need to acquire the semaphor since this is synchronous</span>
<a href="#l20.9199"></a><span id="l20.9199">       // on the UI thread but we should check if the offline store is locked.</span>
<a href="#l20.9200"></a><span id="l20.9200">       bool isLocked;</span>
<a href="#l20.9201"></a><span id="l20.9201" class="difflineat">@@ -7137,284 +6504,265 @@ nsresult nsImapMailFolder::CopyMessagesO</span>
<a href="#l20.9202"></a><span id="l20.9202">       nsCOMPtr&lt;nsIInputStream&gt; inputStream;</span>
<a href="#l20.9203"></a><span id="l20.9203">       bool reusable = false;</span>
<a href="#l20.9204"></a><span id="l20.9204">       nsCOMPtr&lt;nsIOutputStream&gt; outputStream;</span>
<a href="#l20.9205"></a><span id="l20.9205">       nsTArray&lt;nsMsgKey&gt; addedKeys;</span>
<a href="#l20.9206"></a><span id="l20.9206">       nsTArray&lt;nsMsgKey&gt; srcKeyArray;</span>
<a href="#l20.9207"></a><span id="l20.9207">       nsCOMArray&lt;nsIMsgDBHdr&gt; addedHdrs;</span>
<a href="#l20.9208"></a><span id="l20.9208">       nsCOMArray&lt;nsIMsgDBHdr&gt; srcMsgs;</span>
<a href="#l20.9209"></a><span id="l20.9209">       nsOfflineImapOperationType moveCopyOpType;</span>
<a href="#l20.9210"></a><span id="l20.9210" class="difflineminus">-      nsOfflineImapOperationType deleteOpType = nsIMsgOfflineImapOperation::kDeletedMsg;</span>
<a href="#l20.9211"></a><span id="l20.9211" class="difflineplus">+      nsOfflineImapOperationType deleteOpType =</span>
<a href="#l20.9212"></a><span id="l20.9212" class="difflineplus">+          nsIMsgOfflineImapOperation::kDeletedMsg;</span>
<a href="#l20.9213"></a><span id="l20.9213">       if (!deleteToTrash)</span>
<a href="#l20.9214"></a><span id="l20.9214">         deleteOpType = nsIMsgOfflineImapOperation::kMsgMarkedDeleted;</span>
<a href="#l20.9215"></a><span id="l20.9215">       nsCString messageIds;</span>
<a href="#l20.9216"></a><span id="l20.9216">       rv = BuildIdsAndKeyArray(messages, messageIds, srcKeyArray);</span>
<a href="#l20.9217"></a><span id="l20.9217">       // put fake message in destination db, delete source if move</span>
<a href="#l20.9218"></a><span id="l20.9218">       EnableNotifications(nsIMsgFolder::allMessageCountNotifications, false);</span>
<a href="#l20.9219"></a><span id="l20.9219" class="difflineminus">-      for (uint32_t sourceKeyIndex = 0; NS_SUCCEEDED(stopit) &amp;&amp; (sourceKeyIndex &lt; srcCount); sourceKeyIndex++)</span>
<a href="#l20.9220"></a><span id="l20.9220" class="difflineminus">-      {</span>
<a href="#l20.9221"></a><span id="l20.9221" class="difflineplus">+      for (uint32_t sourceKeyIndex = 0;</span>
<a href="#l20.9222"></a><span id="l20.9222" class="difflineplus">+           NS_SUCCEEDED(stopit) &amp;&amp; (sourceKeyIndex &lt; srcCount);</span>
<a href="#l20.9223"></a><span id="l20.9223" class="difflineplus">+           sourceKeyIndex++) {</span>
<a href="#l20.9224"></a><span id="l20.9224">         bool messageReturningHome = false;</span>
<a href="#l20.9225"></a><span id="l20.9225">         nsCString originalSrcFolderURI;</span>
<a href="#l20.9226"></a><span id="l20.9226">         srcFolder-&gt;GetURI(originalSrcFolderURI);</span>
<a href="#l20.9227"></a><span id="l20.9227">         nsCOMPtr&lt;nsIMsgDBHdr&gt; message;</span>
<a href="#l20.9228"></a><span id="l20.9228">         message = do_QueryElementAt(messages, sourceKeyIndex);</span>
<a href="#l20.9229"></a><span id="l20.9229">         nsMsgKey originalKey;</span>
<a href="#l20.9230"></a><span id="l20.9230">         if (message)</span>
<a href="#l20.9231"></a><span id="l20.9231">           rv = message-&gt;GetMessageKey(&amp;originalKey);</span>
<a href="#l20.9232"></a><span id="l20.9232" class="difflineminus">-        else</span>
<a href="#l20.9233"></a><span id="l20.9233" class="difflineminus">-        {</span>
<a href="#l20.9234"></a><span id="l20.9234" class="difflineplus">+        else {</span>
<a href="#l20.9235"></a><span id="l20.9235">           NS_ERROR(&quot;bad msg in src array&quot;);</span>
<a href="#l20.9236"></a><span id="l20.9236">           continue;</span>
<a href="#l20.9237"></a><span id="l20.9237">         }</span>
<a href="#l20.9238"></a><span id="l20.9238">         nsMsgKey msgKey;</span>
<a href="#l20.9239"></a><span id="l20.9239">         message-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l20.9240"></a><span id="l20.9240" class="difflineminus">-        nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; sourceOp;</span>
<a href="#l20.9241"></a><span id="l20.9241" class="difflineminus">-        rv = sourceMailDB-&gt;GetOfflineOpForKey(originalKey, true, getter_AddRefs(sourceOp));</span>
<a href="#l20.9242"></a><span id="l20.9242" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; sourceOp)</span>
<a href="#l20.9243"></a><span id="l20.9243" class="difflineminus">-        {</span>
<a href="#l20.9244"></a><span id="l20.9244" class="difflineplus">+        nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; sourceOp;</span>
<a href="#l20.9245"></a><span id="l20.9245" class="difflineplus">+        rv = sourceMailDB-&gt;GetOfflineOpForKey(originalKey, true,</span>
<a href="#l20.9246"></a><span id="l20.9246" class="difflineplus">+                                              getter_AddRefs(sourceOp));</span>
<a href="#l20.9247"></a><span id="l20.9247" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; sourceOp) {</span>
<a href="#l20.9248"></a><span id="l20.9248">           srcFolder-&gt;SetFlag(nsMsgFolderFlags::OfflineEvents);</span>
<a href="#l20.9249"></a><span id="l20.9249" class="difflineminus">-          nsCOMPtr &lt;nsIMsgDatabase&gt; originalDB;</span>
<a href="#l20.9250"></a><span id="l20.9250" class="difflineplus">+          nsCOMPtr&lt;nsIMsgDatabase&gt; originalDB;</span>
<a href="#l20.9251"></a><span id="l20.9251">           nsOfflineImapOperationType opType;</span>
<a href="#l20.9252"></a><span id="l20.9252">           sourceOp-&gt;GetOperation(&amp;opType);</span>
<a href="#l20.9253"></a><span id="l20.9253" class="difflineminus">-          // if we already have an offline op for this key, then we need to see if it was</span>
<a href="#l20.9254"></a><span id="l20.9254" class="difflineminus">-          // moved into the source folder while offline</span>
<a href="#l20.9255"></a><span id="l20.9255" class="difflineminus">-          if (opType == nsIMsgOfflineImapOperation::kMoveResult) // offline move</span>
<a href="#l20.9256"></a><span id="l20.9256" class="difflineplus">+          // if we already have an offline op for this key, then we need to see</span>
<a href="#l20.9257"></a><span id="l20.9257" class="difflineplus">+          // if it was moved into the source folder while offline</span>
<a href="#l20.9258"></a><span id="l20.9258" class="difflineplus">+          if (opType ==</span>
<a href="#l20.9259"></a><span id="l20.9259" class="difflineplus">+              nsIMsgOfflineImapOperation::kMoveResult)  // offline move</span>
<a href="#l20.9260"></a><span id="l20.9260">           {</span>
<a href="#l20.9261"></a><span id="l20.9261" class="difflineminus">-            // gracious me, we are moving something we already moved while offline!</span>
<a href="#l20.9262"></a><span id="l20.9262" class="difflineminus">-            // find the original operation and clear it!</span>
<a href="#l20.9263"></a><span id="l20.9263" class="difflineminus">-            nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; originalOp;</span>
<a href="#l20.9264"></a><span id="l20.9264" class="difflineminus">-            rv = GetClearedOriginalOp(sourceOp, getter_AddRefs(originalOp), getter_AddRefs(originalDB));</span>
<a href="#l20.9265"></a><span id="l20.9265" class="difflineminus">-            if (originalOp)</span>
<a href="#l20.9266"></a><span id="l20.9266" class="difflineminus">-            {</span>
<a href="#l20.9267"></a><span id="l20.9267" class="difflineplus">+            // gracious me, we are moving something we already moved while</span>
<a href="#l20.9268"></a><span id="l20.9268" class="difflineplus">+            // offline! find the original operation and clear it!</span>
<a href="#l20.9269"></a><span id="l20.9269" class="difflineplus">+            nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; originalOp;</span>
<a href="#l20.9270"></a><span id="l20.9270" class="difflineplus">+            rv = GetClearedOriginalOp(sourceOp, getter_AddRefs(originalOp),</span>
<a href="#l20.9271"></a><span id="l20.9271" class="difflineplus">+                                      getter_AddRefs(originalDB));</span>
<a href="#l20.9272"></a><span id="l20.9272" class="difflineplus">+            if (originalOp) {</span>
<a href="#l20.9273"></a><span id="l20.9273">               nsCString srcFolderURI;</span>
<a href="#l20.9274"></a><span id="l20.9274">               srcFolder-&gt;GetURI(srcFolderURI);</span>
<a href="#l20.9275"></a><span id="l20.9275">               sourceOp-&gt;GetSourceFolderURI(getter_Copies(originalSrcFolderURI));</span>
<a href="#l20.9276"></a><span id="l20.9276">               sourceOp-&gt;GetMessageKey(&amp;originalKey);</span>
<a href="#l20.9277"></a><span id="l20.9277" class="difflineminus">-              if (isMove)</span>
<a href="#l20.9278"></a><span id="l20.9278" class="difflineminus">-                sourceMailDB-&gt;RemoveOfflineOp(sourceOp);</span>
<a href="#l20.9279"></a><span id="l20.9279" class="difflineplus">+              if (isMove) sourceMailDB-&gt;RemoveOfflineOp(sourceOp);</span>
<a href="#l20.9280"></a><span id="l20.9280">               sourceOp = originalOp;</span>
<a href="#l20.9281"></a><span id="l20.9281" class="difflineminus">-              if (originalSrcFolderURI.Equals(srcFolderURI))</span>
<a href="#l20.9282"></a><span id="l20.9282" class="difflineminus">-              {</span>
<a href="#l20.9283"></a><span id="l20.9283" class="difflineplus">+              if (originalSrcFolderURI.Equals(srcFolderURI)) {</span>
<a href="#l20.9284"></a><span id="l20.9284">                 messageReturningHome = true;</span>
<a href="#l20.9285"></a><span id="l20.9285">                 originalDB-&gt;RemoveOfflineOp(originalOp);</span>
<a href="#l20.9286"></a><span id="l20.9286">               }</span>
<a href="#l20.9287"></a><span id="l20.9287">             }</span>
<a href="#l20.9288"></a><span id="l20.9288">           }</span>
<a href="#l20.9289"></a><span id="l20.9289" class="difflineminus">-          if (!messageReturningHome)</span>
<a href="#l20.9290"></a><span id="l20.9290" class="difflineminus">-          {</span>
<a href="#l20.9291"></a><span id="l20.9291" class="difflineplus">+          if (!messageReturningHome) {</span>
<a href="#l20.9292"></a><span id="l20.9292">             nsCString folderURI;</span>
<a href="#l20.9293"></a><span id="l20.9293">             GetURI(folderURI);</span>
<a href="#l20.9294"></a><span id="l20.9294" class="difflineminus">-            if (isMove)</span>
<a href="#l20.9295"></a><span id="l20.9295" class="difflineminus">-            {</span>
<a href="#l20.9296"></a><span id="l20.9296" class="difflineplus">+            if (isMove) {</span>
<a href="#l20.9297"></a><span id="l20.9297">               uint32_t msgSize;</span>
<a href="#l20.9298"></a><span id="l20.9298">               uint32_t msgFlags;</span>
<a href="#l20.9299"></a><span id="l20.9299">               imapMessageFlagsType newImapFlags = 0;</span>
<a href="#l20.9300"></a><span id="l20.9300">               message-&gt;GetMessageSize(&amp;msgSize);</span>
<a href="#l20.9301"></a><span id="l20.9301">               message-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l20.9302"></a><span id="l20.9302" class="difflineminus">-              sourceOp-&gt;SetDestinationFolderURI(folderURI.get()); // offline move</span>
<a href="#l20.9303"></a><span id="l20.9303" class="difflineplus">+              sourceOp-&gt;SetDestinationFolderURI(</span>
<a href="#l20.9304"></a><span id="l20.9304" class="difflineplus">+                  folderURI.get());  // offline move</span>
<a href="#l20.9305"></a><span id="l20.9305">               sourceOp-&gt;SetOperation(nsIMsgOfflineImapOperation::kMsgMoved);</span>
<a href="#l20.9306"></a><span id="l20.9306">               sourceOp-&gt;SetMsgSize(msgSize);</span>
<a href="#l20.9307"></a><span id="l20.9307">               newImapFlags = msgFlags &amp; 0x7;</span>
<a href="#l20.9308"></a><span id="l20.9308">               if (msgFlags &amp; nsMsgMessageFlags::Forwarded)</span>
<a href="#l20.9309"></a><span id="l20.9309" class="difflineminus">-                newImapFlags |=  kImapMsgForwardedFlag;</span>
<a href="#l20.9310"></a><span id="l20.9310" class="difflineplus">+                newImapFlags |= kImapMsgForwardedFlag;</span>
<a href="#l20.9311"></a><span id="l20.9311">               sourceOp-&gt;SetNewFlags(newImapFlags);</span>
<a href="#l20.9312"></a><span id="l20.9312" class="difflineminus">-            }</span>
<a href="#l20.9313"></a><span id="l20.9313" class="difflineminus">-            else</span>
<a href="#l20.9314"></a><span id="l20.9314" class="difflineminus">-              sourceOp-&gt;AddMessageCopyOperation(folderURI.get()); // offline copy</span>
<a href="#l20.9315"></a><span id="l20.9315" class="difflineplus">+            } else</span>
<a href="#l20.9316"></a><span id="l20.9316" class="difflineplus">+              sourceOp-&gt;AddMessageCopyOperation(</span>
<a href="#l20.9317"></a><span id="l20.9317" class="difflineplus">+                  folderURI.get());  // offline copy</span>
<a href="#l20.9318"></a><span id="l20.9318"> </span>
<a href="#l20.9319"></a><span id="l20.9319">             sourceOp-&gt;GetOperation(&amp;moveCopyOpType);</span>
<a href="#l20.9320"></a><span id="l20.9320">             srcMsgs.AppendObject(message);</span>
<a href="#l20.9321"></a><span id="l20.9321">           }</span>
<a href="#l20.9322"></a><span id="l20.9322">           bool hasMsgOffline = false;</span>
<a href="#l20.9323"></a><span id="l20.9323">           srcFolder-&gt;HasMsgOffline(originalKey, &amp;hasMsgOffline);</span>
<a href="#l20.9324"></a><span id="l20.9324" class="difflineminus">-        }</span>
<a href="#l20.9325"></a><span id="l20.9325" class="difflineminus">-        else</span>
<a href="#l20.9326"></a><span id="l20.9326" class="difflineplus">+        } else</span>
<a href="#l20.9327"></a><span id="l20.9327">           stopit = NS_ERROR_FAILURE;</span>
<a href="#l20.9328"></a><span id="l20.9328"> </span>
<a href="#l20.9329"></a><span id="l20.9329" class="difflineminus">-        nsCOMPtr &lt;nsIMsgDBHdr&gt; mailHdr;</span>
<a href="#l20.9330"></a><span id="l20.9330" class="difflineminus">-        rv = sourceMailDB-&gt;GetMsgHdrForKey(originalKey, getter_AddRefs(mailHdr));</span>
<a href="#l20.9331"></a><span id="l20.9331" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; mailHdr)</span>
<a href="#l20.9332"></a><span id="l20.9332" class="difflineminus">-        {</span>
<a href="#l20.9333"></a><span id="l20.9333" class="difflineplus">+        nsCOMPtr&lt;nsIMsgDBHdr&gt; mailHdr;</span>
<a href="#l20.9334"></a><span id="l20.9334" class="difflineplus">+        rv =</span>
<a href="#l20.9335"></a><span id="l20.9335" class="difflineplus">+            sourceMailDB-&gt;GetMsgHdrForKey(originalKey, getter_AddRefs(mailHdr));</span>
<a href="#l20.9336"></a><span id="l20.9336" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; mailHdr) {</span>
<a href="#l20.9337"></a><span id="l20.9337">           bool successfulCopy = false;</span>
<a href="#l20.9338"></a><span id="l20.9338">           nsMsgKey srcDBhighWaterMark;</span>
<a href="#l20.9339"></a><span id="l20.9339">           srcDbFolderInfo-&gt;GetHighWater(&amp;srcDBhighWaterMark);</span>
<a href="#l20.9340"></a><span id="l20.9340"> </span>
<a href="#l20.9341"></a><span id="l20.9341" class="difflineminus">-          nsCOMPtr &lt;nsIMsgDBHdr&gt; newMailHdr;</span>
<a href="#l20.9342"></a><span id="l20.9342" class="difflineminus">-          rv = database-&gt;CopyHdrFromExistingHdr(fakeBase + sourceKeyIndex, mailHdr,</span>
<a href="#l20.9343"></a><span id="l20.9343" class="difflineminus">-            true, getter_AddRefs(newMailHdr));</span>
<a href="#l20.9344"></a><span id="l20.9344" class="difflineminus">-          if (!newMailHdr || NS_FAILED(rv))</span>
<a href="#l20.9345"></a><span id="l20.9345" class="difflineminus">-          {</span>
<a href="#l20.9346"></a><span id="l20.9346" class="difflineplus">+          nsCOMPtr&lt;nsIMsgDBHdr&gt; newMailHdr;</span>
<a href="#l20.9347"></a><span id="l20.9347" class="difflineplus">+          rv = database-&gt;CopyHdrFromExistingHdr(fakeBase + sourceKeyIndex,</span>
<a href="#l20.9348"></a><span id="l20.9348" class="difflineplus">+                                                mailHdr, true,</span>
<a href="#l20.9349"></a><span id="l20.9349" class="difflineplus">+                                                getter_AddRefs(newMailHdr));</span>
<a href="#l20.9350"></a><span id="l20.9350" class="difflineplus">+          if (!newMailHdr || NS_FAILED(rv)) {</span>
<a href="#l20.9351"></a><span id="l20.9351">             NS_ASSERTION(false, &quot;failed to copy hdr&quot;);</span>
<a href="#l20.9352"></a><span id="l20.9352">             stopit = rv;</span>
<a href="#l20.9353"></a><span id="l20.9353">           }</span>
<a href="#l20.9354"></a><span id="l20.9354"> </span>
<a href="#l20.9355"></a><span id="l20.9355" class="difflineminus">-          if (NS_SUCCEEDED(stopit))</span>
<a href="#l20.9356"></a><span id="l20.9356" class="difflineminus">-          {</span>
<a href="#l20.9357"></a><span id="l20.9357" class="difflineplus">+          if (NS_SUCCEEDED(stopit)) {</span>
<a href="#l20.9358"></a><span id="l20.9358">             bool hasMsgOffline = false;</span>
<a href="#l20.9359"></a><span id="l20.9359"> </span>
<a href="#l20.9360"></a><span id="l20.9360">             destMsgHdrs-&gt;AppendElement(newMailHdr);</span>
<a href="#l20.9361"></a><span id="l20.9361">             srcFolder-&gt;HasMsgOffline(originalKey, &amp;hasMsgOffline);</span>
<a href="#l20.9362"></a><span id="l20.9362">             newMailHdr-&gt;SetUint32Property(&quot;pseudoHdr&quot;, 1);</span>
<a href="#l20.9363"></a><span id="l20.9363">             if (!reusable)</span>
<a href="#l20.9364"></a><span id="l20.9364">               (void)srcFolder-&gt;GetMsgInputStream(newMailHdr, &amp;reusable,</span>
<a href="#l20.9365"></a><span id="l20.9365">                                                  getter_AddRefs(inputStream));</span>
<a href="#l20.9366"></a><span id="l20.9366"> </span>
<a href="#l20.9367"></a><span id="l20.9367" class="difflineminus">-            if (inputStream &amp;&amp; hasMsgOffline &amp;&amp; !isLocked)</span>
<a href="#l20.9368"></a><span id="l20.9368" class="difflineminus">-            {</span>
<a href="#l20.9369"></a><span id="l20.9369" class="difflineplus">+            if (inputStream &amp;&amp; hasMsgOffline &amp;&amp; !isLocked) {</span>
<a href="#l20.9370"></a><span id="l20.9370">               rv = GetOfflineStoreOutputStream(newMailHdr,</span>
<a href="#l20.9371"></a><span id="l20.9371">                                                getter_AddRefs(outputStream));</span>
<a href="#l20.9372"></a><span id="l20.9372">               NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.9373"></a><span id="l20.9373"> </span>
<a href="#l20.9374"></a><span id="l20.9374">               CopyOfflineMsgBody(srcFolder, newMailHdr, mailHdr, inputStream,</span>
<a href="#l20.9375"></a><span id="l20.9375">                                  outputStream);</span>
<a href="#l20.9376"></a><span id="l20.9376">               nsCOMPtr&lt;nsIMsgPluggableStore&gt; offlineStore;</span>
<a href="#l20.9377"></a><span id="l20.9377" class="difflineminus">-              (void) GetMsgStore(getter_AddRefs(offlineStore));</span>
<a href="#l20.9378"></a><span id="l20.9378" class="difflineplus">+              (void)GetMsgStore(getter_AddRefs(offlineStore));</span>
<a href="#l20.9379"></a><span id="l20.9379">               if (offlineStore)</span>
<a href="#l20.9380"></a><span id="l20.9380">                 offlineStore-&gt;FinishNewMessage(outputStream, newMailHdr);</span>
<a href="#l20.9381"></a><span id="l20.9381" class="difflineminus">-            }</span>
<a href="#l20.9382"></a><span id="l20.9382" class="difflineminus">-            else</span>
<a href="#l20.9383"></a><span id="l20.9383" class="difflineplus">+            } else</span>
<a href="#l20.9384"></a><span id="l20.9384">               database-&gt;MarkOffline(fakeBase + sourceKeyIndex, false, nullptr);</span>
<a href="#l20.9385"></a><span id="l20.9385"> </span>
<a href="#l20.9386"></a><span id="l20.9386" class="difflineminus">-            nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; destOp;</span>
<a href="#l20.9387"></a><span id="l20.9387" class="difflineminus">-            database-&gt;GetOfflineOpForKey(fakeBase + sourceKeyIndex, true, getter_AddRefs(destOp));</span>
<a href="#l20.9388"></a><span id="l20.9388" class="difflineminus">-            if (destOp)</span>
<a href="#l20.9389"></a><span id="l20.9389" class="difflineminus">-            {</span>
<a href="#l20.9390"></a><span id="l20.9390" class="difflineminus">-              // check if this is a move back to the original mailbox, in which case</span>
<a href="#l20.9391"></a><span id="l20.9391" class="difflineminus">-              // we just delete the offline operation.</span>
<a href="#l20.9392"></a><span id="l20.9392" class="difflineplus">+            nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; destOp;</span>
<a href="#l20.9393"></a><span id="l20.9393" class="difflineplus">+            database-&gt;GetOfflineOpForKey(fakeBase + sourceKeyIndex, true,</span>
<a href="#l20.9394"></a><span id="l20.9394" class="difflineplus">+                                         getter_AddRefs(destOp));</span>
<a href="#l20.9395"></a><span id="l20.9395" class="difflineplus">+            if (destOp) {</span>
<a href="#l20.9396"></a><span id="l20.9396" class="difflineplus">+              // check if this is a move back to the original mailbox, in which</span>
<a href="#l20.9397"></a><span id="l20.9397" class="difflineplus">+              // case we just delete the offline operation.</span>
<a href="#l20.9398"></a><span id="l20.9398">               if (messageReturningHome)</span>
<a href="#l20.9399"></a><span id="l20.9399">                 database-&gt;RemoveOfflineOp(destOp);</span>
<a href="#l20.9400"></a><span id="l20.9400" class="difflineminus">-              else</span>
<a href="#l20.9401"></a><span id="l20.9401" class="difflineminus">-              {</span>
<a href="#l20.9402"></a><span id="l20.9402" class="difflineplus">+              else {</span>
<a href="#l20.9403"></a><span id="l20.9403">                 SetFlag(nsMsgFolderFlags::OfflineEvents);</span>
<a href="#l20.9404"></a><span id="l20.9404">                 destOp-&gt;SetSourceFolderURI(originalSrcFolderURI.get());</span>
<a href="#l20.9405"></a><span id="l20.9405">                 destOp-&gt;SetSrcMessageKey(originalKey);</span>
<a href="#l20.9406"></a><span id="l20.9406">                 addedKeys.AppendElement(fakeBase + sourceKeyIndex);</span>
<a href="#l20.9407"></a><span id="l20.9407">                 addedHdrs.AppendObject(newMailHdr);</span>
<a href="#l20.9408"></a><span id="l20.9408">               }</span>
<a href="#l20.9409"></a><span id="l20.9409" class="difflineminus">-            }</span>
<a href="#l20.9410"></a><span id="l20.9410" class="difflineminus">-            else</span>
<a href="#l20.9411"></a><span id="l20.9411" class="difflineplus">+            } else</span>
<a href="#l20.9412"></a><span id="l20.9412">               stopit = NS_ERROR_FAILURE;</span>
<a href="#l20.9413"></a><span id="l20.9413">           }</span>
<a href="#l20.9414"></a><span id="l20.9414">           successfulCopy = NS_SUCCEEDED(stopit);</span>
<a href="#l20.9415"></a><span id="l20.9415">           nsMsgKey msgKey;</span>
<a href="#l20.9416"></a><span id="l20.9416">           mailHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l20.9417"></a><span id="l20.9417" class="difflineminus">-          if (isMove &amp;&amp; successfulCopy)</span>
<a href="#l20.9418"></a><span id="l20.9418" class="difflineminus">-          {</span>
<a href="#l20.9419"></a><span id="l20.9419" class="difflineplus">+          if (isMove &amp;&amp; successfulCopy) {</span>
<a href="#l20.9420"></a><span id="l20.9420">             if (deleteToTrash || deleteImmediately)</span>
<a href="#l20.9421"></a><span id="l20.9421">               keysToDelete.AppendElement(msgKey);</span>
<a href="#l20.9422"></a><span id="l20.9422">             else</span>
<a href="#l20.9423"></a><span id="l20.9423" class="difflineminus">-              sourceMailDB-&gt;MarkImapDeleted(msgKey, true, nullptr); // offline delete</span>
<a href="#l20.9424"></a><span id="l20.9424" class="difflineplus">+              sourceMailDB-&gt;MarkImapDeleted(msgKey, true,</span>
<a href="#l20.9425"></a><span id="l20.9425" class="difflineplus">+                                            nullptr);  // offline delete</span>
<a href="#l20.9426"></a><span id="l20.9426">           }</span>
<a href="#l20.9427"></a><span id="l20.9427">           if (successfulCopy)</span>
<a href="#l20.9428"></a><span id="l20.9428">             // This is for both moves and copies</span>
<a href="#l20.9429"></a><span id="l20.9429">             msgHdrsCopied-&gt;AppendElement(mailHdr);</span>
<a href="#l20.9430"></a><span id="l20.9430">         }</span>
<a href="#l20.9431"></a><span id="l20.9431">       }</span>
<a href="#l20.9432"></a><span id="l20.9432">       EnableNotifications(nsIMsgFolder::allMessageCountNotifications, true);</span>
<a href="#l20.9433"></a><span id="l20.9433" class="difflineminus">-      RefPtr&lt;nsImapOfflineTxn&gt; addHdrMsgTxn = new</span>
<a href="#l20.9434"></a><span id="l20.9434" class="difflineminus">-        nsImapOfflineTxn(this, &amp;addedKeys, nullptr, this, isMove, nsIMsgOfflineImapOperation::kAddedHeader,</span>
<a href="#l20.9435"></a><span id="l20.9435" class="difflineminus">-                         addedHdrs);</span>
<a href="#l20.9436"></a><span id="l20.9436" class="difflineminus">-      if (addHdrMsgTxn &amp;&amp; txnMgr)</span>
<a href="#l20.9437"></a><span id="l20.9437" class="difflineminus">-         txnMgr-&gt;DoTransaction(addHdrMsgTxn);</span>
<a href="#l20.9438"></a><span id="l20.9438" class="difflineminus">-      RefPtr&lt;nsImapOfflineTxn&gt; undoMsgTxn = new</span>
<a href="#l20.9439"></a><span id="l20.9439" class="difflineminus">-        nsImapOfflineTxn(srcFolder, &amp;srcKeyArray, messageIds.get(), this,</span>
<a href="#l20.9440"></a><span id="l20.9440" class="difflineminus">-                         isMove, moveCopyOpType, srcMsgs);</span>
<a href="#l20.9441"></a><span id="l20.9441" class="difflineminus">-      if (undoMsgTxn)</span>
<a href="#l20.9442"></a><span id="l20.9442" class="difflineminus">-      {</span>
<a href="#l20.9443"></a><span id="l20.9443" class="difflineminus">-        if (isMove)</span>
<a href="#l20.9444"></a><span id="l20.9444" class="difflineminus">-        {</span>
<a href="#l20.9445"></a><span id="l20.9445" class="difflineplus">+      RefPtr&lt;nsImapOfflineTxn&gt; addHdrMsgTxn = new nsImapOfflineTxn(</span>
<a href="#l20.9446"></a><span id="l20.9446" class="difflineplus">+          this, &amp;addedKeys, nullptr, this, isMove,</span>
<a href="#l20.9447"></a><span id="l20.9447" class="difflineplus">+          nsIMsgOfflineImapOperation::kAddedHeader, addedHdrs);</span>
<a href="#l20.9448"></a><span id="l20.9448" class="difflineplus">+      if (addHdrMsgTxn &amp;&amp; txnMgr) txnMgr-&gt;DoTransaction(addHdrMsgTxn);</span>
<a href="#l20.9449"></a><span id="l20.9449" class="difflineplus">+      RefPtr&lt;nsImapOfflineTxn&gt; undoMsgTxn =</span>
<a href="#l20.9450"></a><span id="l20.9450" class="difflineplus">+          new nsImapOfflineTxn(srcFolder, &amp;srcKeyArray, messageIds.get(), this,</span>
<a href="#l20.9451"></a><span id="l20.9451" class="difflineplus">+                               isMove, moveCopyOpType, srcMsgs);</span>
<a href="#l20.9452"></a><span id="l20.9452" class="difflineplus">+      if (undoMsgTxn) {</span>
<a href="#l20.9453"></a><span id="l20.9453" class="difflineplus">+        if (isMove) {</span>
<a href="#l20.9454"></a><span id="l20.9454">           undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eMoveMsg);</span>
<a href="#l20.9455"></a><span id="l20.9455" class="difflineminus">-          nsCOMPtr&lt;nsIMsgImapMailFolder&gt; srcIsImap(do_QueryInterface(srcFolder));</span>
<a href="#l20.9456"></a><span id="l20.9456" class="difflineplus">+          nsCOMPtr&lt;nsIMsgImapMailFolder&gt; srcIsImap(</span>
<a href="#l20.9457"></a><span id="l20.9457" class="difflineplus">+              do_QueryInterface(srcFolder));</span>
<a href="#l20.9458"></a><span id="l20.9458">           // remember this undo transaction so we can hook up the result</span>
<a href="#l20.9459"></a><span id="l20.9459">           // msg ids in the undo transaction.</span>
<a href="#l20.9460"></a><span id="l20.9460" class="difflineminus">-          if (srcIsImap)</span>
<a href="#l20.9461"></a><span id="l20.9461" class="difflineminus">-          {</span>
<a href="#l20.9462"></a><span id="l20.9462" class="difflineminus">-            nsImapMailFolder *srcImapFolder = static_cast&lt;nsImapMailFolder*&gt;(srcFolder);</span>
<a href="#l20.9463"></a><span id="l20.9463" class="difflineplus">+          if (srcIsImap) {</span>
<a href="#l20.9464"></a><span id="l20.9464" class="difflineplus">+            nsImapMailFolder *srcImapFolder =</span>
<a href="#l20.9465"></a><span id="l20.9465" class="difflineplus">+                static_cast&lt;nsImapMailFolder *&gt;(srcFolder);</span>
<a href="#l20.9466"></a><span id="l20.9466">             srcImapFolder-&gt;m_pendingOfflineMoves.AppendElement(undoMsgTxn);</span>
<a href="#l20.9467"></a><span id="l20.9467">           }</span>
<a href="#l20.9468"></a><span id="l20.9468" class="difflineminus">-        }</span>
<a href="#l20.9469"></a><span id="l20.9469" class="difflineminus">-        else</span>
<a href="#l20.9470"></a><span id="l20.9470" class="difflineplus">+        } else</span>
<a href="#l20.9471"></a><span id="l20.9471">           undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eCopyMsg);</span>
<a href="#l20.9472"></a><span id="l20.9472" class="difflineminus">-        // we're adding this undo action before the delete is successful. This is evil,</span>
<a href="#l20.9473"></a><span id="l20.9473" class="difflineminus">-        // but 4.5 did it as well.</span>
<a href="#l20.9474"></a><span id="l20.9474" class="difflineminus">-        if (txnMgr)</span>
<a href="#l20.9475"></a><span id="l20.9475" class="difflineminus">-          txnMgr-&gt;DoTransaction(undoMsgTxn);</span>
<a href="#l20.9476"></a><span id="l20.9476" class="difflineplus">+        // we're adding this undo action before the delete is successful. This</span>
<a href="#l20.9477"></a><span id="l20.9477" class="difflineplus">+        // is evil, but 4.5 did it as well.</span>
<a href="#l20.9478"></a><span id="l20.9478" class="difflineplus">+        if (txnMgr) txnMgr-&gt;DoTransaction(undoMsgTxn);</span>
<a href="#l20.9479"></a><span id="l20.9479">       }</span>
<a href="#l20.9480"></a><span id="l20.9480" class="difflineminus">-      undoMsgTxn = new</span>
<a href="#l20.9481"></a><span id="l20.9481" class="difflineminus">-        nsImapOfflineTxn(srcFolder, &amp;srcKeyArray, messageIds.get(), this, isMove,</span>
<a href="#l20.9482"></a><span id="l20.9482" class="difflineminus">-                         deleteOpType, srcMsgs);</span>
<a href="#l20.9483"></a><span id="l20.9483" class="difflineminus">-      if (undoMsgTxn)</span>
<a href="#l20.9484"></a><span id="l20.9484" class="difflineminus">-      {</span>
<a href="#l20.9485"></a><span id="l20.9485" class="difflineminus">-        if (isMove)</span>
<a href="#l20.9486"></a><span id="l20.9486" class="difflineminus">-        {</span>
<a href="#l20.9487"></a><span id="l20.9487" class="difflineplus">+      undoMsgTxn =</span>
<a href="#l20.9488"></a><span id="l20.9488" class="difflineplus">+          new nsImapOfflineTxn(srcFolder, &amp;srcKeyArray, messageIds.get(), this,</span>
<a href="#l20.9489"></a><span id="l20.9489" class="difflineplus">+                               isMove, deleteOpType, srcMsgs);</span>
<a href="#l20.9490"></a><span id="l20.9490" class="difflineplus">+      if (undoMsgTxn) {</span>
<a href="#l20.9491"></a><span id="l20.9491" class="difflineplus">+        if (isMove) {</span>
<a href="#l20.9492"></a><span id="l20.9492">           if (mFlags &amp; nsMsgFolderFlags::Trash)</span>
<a href="#l20.9493"></a><span id="l20.9493">             undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eDeleteMsg);</span>
<a href="#l20.9494"></a><span id="l20.9494">           else</span>
<a href="#l20.9495"></a><span id="l20.9495">             undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eMoveMsg);</span>
<a href="#l20.9496"></a><span id="l20.9496" class="difflineminus">-        }</span>
<a href="#l20.9497"></a><span id="l20.9497" class="difflineminus">-        else</span>
<a href="#l20.9498"></a><span id="l20.9498" class="difflineplus">+        } else</span>
<a href="#l20.9499"></a><span id="l20.9499">           undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eCopyMsg);</span>
<a href="#l20.9500"></a><span id="l20.9500" class="difflineminus">-        if (txnMgr)</span>
<a href="#l20.9501"></a><span id="l20.9501" class="difflineminus">-           txnMgr-&gt;DoTransaction(undoMsgTxn);</span>
<a href="#l20.9502"></a><span id="l20.9502" class="difflineplus">+        if (txnMgr) txnMgr-&gt;DoTransaction(undoMsgTxn);</span>
<a href="#l20.9503"></a><span id="l20.9503">       }</span>
<a href="#l20.9504"></a><span id="l20.9504" class="difflineminus">-      if (outputStream)</span>
<a href="#l20.9505"></a><span id="l20.9505" class="difflineminus">-        outputStream-&gt;Close();</span>
<a href="#l20.9506"></a><span id="l20.9506" class="difflineminus">-</span>
<a href="#l20.9507"></a><span id="l20.9507" class="difflineminus">-      if (isMove)</span>
<a href="#l20.9508"></a><span id="l20.9508" class="difflineminus">-        sourceMailDB-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.9509"></a><span id="l20.9509" class="difflineplus">+      if (outputStream) outputStream-&gt;Close();</span>
<a href="#l20.9510"></a><span id="l20.9510" class="difflineplus">+</span>
<a href="#l20.9511"></a><span id="l20.9511" class="difflineplus">+      if (isMove) sourceMailDB-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.9512"></a><span id="l20.9512">       database-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.9513"></a><span id="l20.9513">       SummaryChanged();</span>
<a href="#l20.9514"></a><span id="l20.9514">       srcFolder-&gt;SummaryChanged();</span>
<a href="#l20.9515"></a><span id="l20.9515">     }</span>
<a href="#l20.9516"></a><span id="l20.9516" class="difflineminus">-    if (txnMgr)</span>
<a href="#l20.9517"></a><span id="l20.9517" class="difflineminus">-      txnMgr-&gt;EndBatch(false);</span>
<a href="#l20.9518"></a><span id="l20.9518" class="difflineplus">+    if (txnMgr) txnMgr-&gt;EndBatch(false);</span>
<a href="#l20.9519"></a><span id="l20.9519">   }</span>
<a href="#l20.9520"></a><span id="l20.9520"> </span>
<a href="#l20.9521"></a><span id="l20.9521">   // Do this before delete, as it destroys the messages</span>
<a href="#l20.9522"></a><span id="l20.9522">   uint32_t numHdrs;</span>
<a href="#l20.9523"></a><span id="l20.9523">   msgHdrsCopied-&gt;GetLength(&amp;numHdrs);</span>
<a href="#l20.9524"></a><span id="l20.9524" class="difflineminus">-  if (numHdrs)</span>
<a href="#l20.9525"></a><span id="l20.9525" class="difflineminus">-  {</span>
<a href="#l20.9526"></a><span id="l20.9526" class="difflineminus">-    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.9527"></a><span id="l20.9527" class="difflineplus">+  if (numHdrs) {</span>
<a href="#l20.9528"></a><span id="l20.9528" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(</span>
<a href="#l20.9529"></a><span id="l20.9529" class="difflineplus">+        do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.9530"></a><span id="l20.9530">     if (notifier)</span>
<a href="#l20.9531"></a><span id="l20.9531" class="difflineminus">-      notifier-&gt;NotifyMsgsMoveCopyCompleted(isMove, msgHdrsCopied, this, destMsgHdrs);</span>
<a href="#l20.9532"></a><span id="l20.9532" class="difflineminus">-  }</span>
<a href="#l20.9533"></a><span id="l20.9533" class="difflineminus">-</span>
<a href="#l20.9534"></a><span id="l20.9534" class="difflineminus">-  if (isMove &amp;&amp; NS_SUCCEEDED(rv) &amp;&amp; (deleteToTrash || deleteImmediately))</span>
<a href="#l20.9535"></a><span id="l20.9535" class="difflineminus">-  {</span>
<a href="#l20.9536"></a><span id="l20.9536" class="difflineplus">+      notifier-&gt;NotifyMsgsMoveCopyCompleted(isMove, msgHdrsCopied, this,</span>
<a href="#l20.9537"></a><span id="l20.9537" class="difflineplus">+                                            destMsgHdrs);</span>
<a href="#l20.9538"></a><span id="l20.9538" class="difflineplus">+  }</span>
<a href="#l20.9539"></a><span id="l20.9539" class="difflineplus">+</span>
<a href="#l20.9540"></a><span id="l20.9540" class="difflineplus">+  if (isMove &amp;&amp; NS_SUCCEEDED(rv) &amp;&amp; (deleteToTrash || deleteImmediately)) {</span>
<a href="#l20.9541"></a><span id="l20.9541">     DeleteStoreMessages(keysToDelete, srcFolder);</span>
<a href="#l20.9542"></a><span id="l20.9542" class="difflineminus">-    srcFolder-&gt;EnableNotifications(nsIMsgFolder::allMessageCountNotifications, false);</span>
<a href="#l20.9543"></a><span id="l20.9543" class="difflineplus">+    srcFolder-&gt;EnableNotifications(nsIMsgFolder::allMessageCountNotifications,</span>
<a href="#l20.9544"></a><span id="l20.9544" class="difflineplus">+                                   false);</span>
<a href="#l20.9545"></a><span id="l20.9545">     sourceMailDB-&gt;DeleteMessages(keysToDelete.Length(), keysToDelete.Elements(),</span>
<a href="#l20.9546"></a><span id="l20.9546">                                  nullptr);</span>
<a href="#l20.9547"></a><span id="l20.9547" class="difflineminus">-    srcFolder-&gt;EnableNotifications(nsIMsgFolder::allMessageCountNotifications, true);</span>
<a href="#l20.9548"></a><span id="l20.9548" class="difflineplus">+    srcFolder-&gt;EnableNotifications(nsIMsgFolder::allMessageCountNotifications,</span>
<a href="#l20.9549"></a><span id="l20.9549" class="difflineplus">+                                   true);</span>
<a href="#l20.9550"></a><span id="l20.9550">   }</span>
<a href="#l20.9551"></a><span id="l20.9551"> </span>
<a href="#l20.9552"></a><span id="l20.9552">   nsCOMPtr&lt;nsISupports&gt; srcSupport = do_QueryInterface(srcFolder);</span>
<a href="#l20.9553"></a><span id="l20.9553">   OnCopyCompleted(srcSupport, rv);</span>
<a href="#l20.9554"></a><span id="l20.9554"> </span>
<a href="#l20.9555"></a><span id="l20.9555">   if (isMove)</span>
<a href="#l20.9556"></a><span id="l20.9556" class="difflineminus">-    srcFolder-&gt;NotifyFolderEvent(NS_SUCCEEDED(rv) ?</span>
<a href="#l20.9557"></a><span id="l20.9557" class="difflineminus">-                                 kDeleteOrMoveMsgCompleted :</span>
<a href="#l20.9558"></a><span id="l20.9558" class="difflineminus">-                                 kDeleteOrMoveMsgFailed);</span>
<a href="#l20.9559"></a><span id="l20.9559" class="difflineplus">+    srcFolder-&gt;NotifyFolderEvent(NS_SUCCEEDED(rv) ? kDeleteOrMoveMsgCompleted</span>
<a href="#l20.9560"></a><span id="l20.9560" class="difflineplus">+                                                  : kDeleteOrMoveMsgFailed);</span>
<a href="#l20.9561"></a><span id="l20.9561">   return rv;</span>
<a href="#l20.9562"></a><span id="l20.9562"> }</span>
<a href="#l20.9563"></a><span id="l20.9563"> </span>
<a href="#l20.9564"></a><span id="l20.9564" class="difflineminus">-void nsImapMailFolder::SetPendingAttributes(nsIArray* messages, bool aIsMove,</span>
<a href="#l20.9565"></a><span id="l20.9565" class="difflineminus">-                                            bool aSetOffline)</span>
<a href="#l20.9566"></a><span id="l20.9566" class="difflineminus">-{</span>
<a href="#l20.9567"></a><span id="l20.9567" class="difflineminus">-</span>
<a href="#l20.9568"></a><span id="l20.9568" class="difflineplus">+void nsImapMailFolder::SetPendingAttributes(nsIArray *messages, bool aIsMove,</span>
<a href="#l20.9569"></a><span id="l20.9569" class="difflineplus">+                                            bool aSetOffline) {</span>
<a href="#l20.9570"></a><span id="l20.9570">   GetDatabase();</span>
<a href="#l20.9571"></a><span id="l20.9571" class="difflineminus">-  if (!mDatabase)</span>
<a href="#l20.9572"></a><span id="l20.9572" class="difflineminus">-    return;</span>
<a href="#l20.9573"></a><span id="l20.9573" class="difflineplus">+  if (!mDatabase) return;</span>
<a href="#l20.9574"></a><span id="l20.9574"> </span>
<a href="#l20.9575"></a><span id="l20.9575">   uint32_t supportedUserFlags;</span>
<a href="#l20.9576"></a><span id="l20.9576">   GetSupportedUserFlags(&amp;supportedUserFlags);</span>
<a href="#l20.9577"></a><span id="l20.9577"> </span>
<a href="#l20.9578"></a><span id="l20.9578">   nsresult rv;</span>
<a href="#l20.9579"></a><span id="l20.9579" class="difflineminus">-  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l20.9580"></a><span id="l20.9580" class="difflineplus">+  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(</span>
<a href="#l20.9581"></a><span id="l20.9581" class="difflineplus">+      do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l20.9582"></a><span id="l20.9582">   NS_ENSURE_SUCCESS_VOID(rv);</span>
<a href="#l20.9583"></a><span id="l20.9583"> </span>
<a href="#l20.9584"></a><span id="l20.9584">   nsCString dontPreserve;</span>
<a href="#l20.9585"></a><span id="l20.9585"> </span>
<a href="#l20.9586"></a><span id="l20.9586">   // These preferences exist so that extensions can control which properties</span>
<a href="#l20.9587"></a><span id="l20.9587">   // are preserved in the database when a message is moved or copied. All</span>
<a href="#l20.9588"></a><span id="l20.9588">   // properties are preserved except those listed in these preferences</span>
<a href="#l20.9589"></a><span id="l20.9589">   if (aIsMove)</span>
<a href="#l20.9590"></a><span id="l20.9590" class="difflineat">@@ -7426,541 +6774,504 @@ void nsImapMailFolder::SetPendingAttribu</span>
<a href="#l20.9591"></a><span id="l20.9591"> </span>
<a href="#l20.9592"></a><span id="l20.9592">   // We'll add spaces at beginning and end so we can search for space-name-space</span>
<a href="#l20.9593"></a><span id="l20.9593">   nsCString dontPreserveEx(NS_LITERAL_CSTRING(&quot; &quot;));</span>
<a href="#l20.9594"></a><span id="l20.9594">   dontPreserveEx.Append(dontPreserve);</span>
<a href="#l20.9595"></a><span id="l20.9595">   dontPreserveEx.Append(' ');</span>
<a href="#l20.9596"></a><span id="l20.9596"> </span>
<a href="#l20.9597"></a><span id="l20.9597">   // these properties are set as integers below, so don't set them again</span>
<a href="#l20.9598"></a><span id="l20.9598">   // in the iteration through the properties</span>
<a href="#l20.9599"></a><span id="l20.9599" class="difflineminus">-  dontPreserveEx.AppendLiteral(&quot;offlineMsgSize msgOffset flags priority pseudoHdr &quot;);</span>
<a href="#l20.9600"></a><span id="l20.9600" class="difflineplus">+  dontPreserveEx.AppendLiteral(</span>
<a href="#l20.9601"></a><span id="l20.9601" class="difflineplus">+      &quot;offlineMsgSize msgOffset flags priority pseudoHdr &quot;);</span>
<a href="#l20.9602"></a><span id="l20.9602"> </span>
<a href="#l20.9603"></a><span id="l20.9603">   // these fields are either copied separately when the server does not support</span>
<a href="#l20.9604"></a><span id="l20.9604">   // custom IMAP flags, or managed directly through the flags</span>
<a href="#l20.9605"></a><span id="l20.9605">   dontPreserveEx.AppendLiteral(&quot;keywords label &quot;);</span>
<a href="#l20.9606"></a><span id="l20.9606"> </span>
<a href="#l20.9607"></a><span id="l20.9607">   uint32_t i, count;</span>
<a href="#l20.9608"></a><span id="l20.9608"> </span>
<a href="#l20.9609"></a><span id="l20.9609">   rv = messages-&gt;GetLength(&amp;count);</span>
<a href="#l20.9610"></a><span id="l20.9610">   NS_ENSURE_SUCCESS_VOID(rv);</span>
<a href="#l20.9611"></a><span id="l20.9611"> </span>
<a href="#l20.9612"></a><span id="l20.9612">   // check if any msg hdr has special flags or properties set</span>
<a href="#l20.9613"></a><span id="l20.9613">   // that we need to set on the dest hdr</span>
<a href="#l20.9614"></a><span id="l20.9614" class="difflineminus">-  for (i = 0; i &lt; count; i++)</span>
<a href="#l20.9615"></a><span id="l20.9615" class="difflineminus">-  {</span>
<a href="#l20.9616"></a><span id="l20.9616" class="difflineminus">-    nsCOMPtr &lt;nsIMsgDBHdr&gt; msgDBHdr = do_QueryElementAt(messages, i, &amp;rv);</span>
<a href="#l20.9617"></a><span id="l20.9617" class="difflineminus">-    if (mDatabase &amp;&amp; msgDBHdr)</span>
<a href="#l20.9618"></a><span id="l20.9618" class="difflineminus">-    {</span>
<a href="#l20.9619"></a><span id="l20.9619" class="difflineminus">-      if (!(supportedUserFlags &amp; kImapMsgSupportUserFlag))</span>
<a href="#l20.9620"></a><span id="l20.9620" class="difflineminus">-      {</span>
<a href="#l20.9621"></a><span id="l20.9621" class="difflineplus">+  for (i = 0; i &lt; count; i++) {</span>
<a href="#l20.9622"></a><span id="l20.9622" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; msgDBHdr = do_QueryElementAt(messages, i, &amp;rv);</span>
<a href="#l20.9623"></a><span id="l20.9623" class="difflineplus">+    if (mDatabase &amp;&amp; msgDBHdr) {</span>
<a href="#l20.9624"></a><span id="l20.9624" class="difflineplus">+      if (!(supportedUserFlags &amp; kImapMsgSupportUserFlag)) {</span>
<a href="#l20.9625"></a><span id="l20.9625">         nsMsgLabelValue label;</span>
<a href="#l20.9626"></a><span id="l20.9626">         msgDBHdr-&gt;GetLabel(&amp;label);</span>
<a href="#l20.9627"></a><span id="l20.9627" class="difflineminus">-        if (label != 0)</span>
<a href="#l20.9628"></a><span id="l20.9628" class="difflineminus">-        {</span>
<a href="#l20.9629"></a><span id="l20.9629" class="difflineplus">+        if (label != 0) {</span>
<a href="#l20.9630"></a><span id="l20.9630">           nsAutoCString labelStr;</span>
<a href="#l20.9631"></a><span id="l20.9631">           labelStr.AppendInt(label);</span>
<a href="#l20.9632"></a><span id="l20.9632" class="difflineminus">-          mDatabase-&gt;SetAttributeOnPendingHdr(msgDBHdr, &quot;label&quot;, labelStr.get());</span>
<a href="#l20.9633"></a><span id="l20.9633" class="difflineplus">+          mDatabase-&gt;SetAttributeOnPendingHdr(msgDBHdr, &quot;label&quot;,</span>
<a href="#l20.9634"></a><span id="l20.9634" class="difflineplus">+                                              labelStr.get());</span>
<a href="#l20.9635"></a><span id="l20.9635">         }</span>
<a href="#l20.9636"></a><span id="l20.9636">         nsCString keywords;</span>
<a href="#l20.9637"></a><span id="l20.9637">         msgDBHdr-&gt;GetStringProperty(&quot;keywords&quot;, getter_Copies(keywords));</span>
<a href="#l20.9638"></a><span id="l20.9638">         if (!keywords.IsEmpty())</span>
<a href="#l20.9639"></a><span id="l20.9639" class="difflineminus">-          mDatabase-&gt;SetAttributeOnPendingHdr(msgDBHdr, &quot;keywords&quot;, keywords.get());</span>
<a href="#l20.9640"></a><span id="l20.9640" class="difflineplus">+          mDatabase-&gt;SetAttributeOnPendingHdr(msgDBHdr, &quot;keywords&quot;,</span>
<a href="#l20.9641"></a><span id="l20.9641" class="difflineplus">+                                              keywords.get());</span>
<a href="#l20.9642"></a><span id="l20.9642">       }</span>
<a href="#l20.9643"></a><span id="l20.9643"> </span>
<a href="#l20.9644"></a><span id="l20.9644">       // do this even if the server supports user-defined flags.</span>
<a href="#l20.9645"></a><span id="l20.9645">       nsCOMPtr&lt;nsIUTF8StringEnumerator&gt; propertyEnumerator;</span>
<a href="#l20.9646"></a><span id="l20.9646" class="difflineminus">-      nsresult rv = msgDBHdr-&gt;GetPropertyEnumerator(getter_AddRefs(propertyEnumerator));</span>
<a href="#l20.9647"></a><span id="l20.9647" class="difflineplus">+      nsresult rv =</span>
<a href="#l20.9648"></a><span id="l20.9648" class="difflineplus">+          msgDBHdr-&gt;GetPropertyEnumerator(getter_AddRefs(propertyEnumerator));</span>
<a href="#l20.9649"></a><span id="l20.9649">       NS_ENSURE_SUCCESS_VOID(rv);</span>
<a href="#l20.9650"></a><span id="l20.9650"> </span>
<a href="#l20.9651"></a><span id="l20.9651">       nsAutoCString property;</span>
<a href="#l20.9652"></a><span id="l20.9652">       nsCString sourceString;</span>
<a href="#l20.9653"></a><span id="l20.9653">       bool hasMore;</span>
<a href="#l20.9654"></a><span id="l20.9654" class="difflineminus">-      while (NS_SUCCEEDED(propertyEnumerator-&gt;HasMore(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l20.9655"></a><span id="l20.9655" class="difflineminus">-      {</span>
<a href="#l20.9656"></a><span id="l20.9656" class="difflineplus">+      while (NS_SUCCEEDED(propertyEnumerator-&gt;HasMore(&amp;hasMore)) &amp;&amp; hasMore) {</span>
<a href="#l20.9657"></a><span id="l20.9657">         propertyEnumerator-&gt;GetNext(property);</span>
<a href="#l20.9658"></a><span id="l20.9658">         nsAutoCString propertyEx(NS_LITERAL_CSTRING(&quot; &quot;));</span>
<a href="#l20.9659"></a><span id="l20.9659">         propertyEx.Append(property);</span>
<a href="#l20.9660"></a><span id="l20.9660">         propertyEx.Append(' ');</span>
<a href="#l20.9661"></a><span id="l20.9661" class="difflineminus">-        if (dontPreserveEx.Find(propertyEx) != kNotFound)</span>
<a href="#l20.9662"></a><span id="l20.9662" class="difflineminus">-          continue;</span>
<a href="#l20.9663"></a><span id="l20.9663" class="difflineplus">+        if (dontPreserveEx.Find(propertyEx) != kNotFound) continue;</span>
<a href="#l20.9664"></a><span id="l20.9664"> </span>
<a href="#l20.9665"></a><span id="l20.9665">         nsCString sourceString;</span>
<a href="#l20.9666"></a><span id="l20.9666" class="difflineminus">-        msgDBHdr-&gt;GetStringProperty(property.get(), getter_Copies(sourceString));</span>
<a href="#l20.9667"></a><span id="l20.9667" class="difflineminus">-        mDatabase-&gt;SetAttributeOnPendingHdr(msgDBHdr, property.get(), sourceString.get());</span>
<a href="#l20.9668"></a><span id="l20.9668" class="difflineplus">+        msgDBHdr-&gt;GetStringProperty(property.get(),</span>
<a href="#l20.9669"></a><span id="l20.9669" class="difflineplus">+                                    getter_Copies(sourceString));</span>
<a href="#l20.9670"></a><span id="l20.9670" class="difflineplus">+        mDatabase-&gt;SetAttributeOnPendingHdr(msgDBHdr, property.get(),</span>
<a href="#l20.9671"></a><span id="l20.9671" class="difflineplus">+                                            sourceString.get());</span>
<a href="#l20.9672"></a><span id="l20.9672">       }</span>
<a href="#l20.9673"></a><span id="l20.9673"> </span>
<a href="#l20.9674"></a><span id="l20.9674">       uint32_t messageSize;</span>
<a href="#l20.9675"></a><span id="l20.9675">       uint64_t messageOffset;</span>
<a href="#l20.9676"></a><span id="l20.9676">       nsCString storeToken;</span>
<a href="#l20.9677"></a><span id="l20.9677">       msgDBHdr-&gt;GetMessageOffset(&amp;messageOffset);</span>
<a href="#l20.9678"></a><span id="l20.9678">       msgDBHdr-&gt;GetOfflineMessageSize(&amp;messageSize);</span>
<a href="#l20.9679"></a><span id="l20.9679">       msgDBHdr-&gt;GetStringProperty(&quot;storeToken&quot;, getter_Copies(storeToken));</span>
<a href="#l20.9680"></a><span id="l20.9680" class="difflineminus">-      if (messageSize)</span>
<a href="#l20.9681"></a><span id="l20.9681" class="difflineminus">-      {</span>
<a href="#l20.9682"></a><span id="l20.9682" class="difflineplus">+      if (messageSize) {</span>
<a href="#l20.9683"></a><span id="l20.9683">         mDatabase-&gt;SetUint32AttributeOnPendingHdr(msgDBHdr, &quot;offlineMsgSize&quot;,</span>
<a href="#l20.9684"></a><span id="l20.9684">                                                   messageSize);</span>
<a href="#l20.9685"></a><span id="l20.9685">         mDatabase-&gt;SetUint64AttributeOnPendingHdr(msgDBHdr, &quot;msgOffset&quot;,</span>
<a href="#l20.9686"></a><span id="l20.9686">                                                   messageOffset);</span>
<a href="#l20.9687"></a><span id="l20.9687">         // Not always setting &quot;flags&quot; attribute to nsMsgMessageFlags::Offline</span>
<a href="#l20.9688"></a><span id="l20.9688">         // here because it can cause missing parts (inline or attachments)</span>
<a href="#l20.9689"></a><span id="l20.9689">         // when messages are moved or copied manually or by filter action.</span>
<a href="#l20.9690"></a><span id="l20.9690">         if (aSetOffline)</span>
<a href="#l20.9691"></a><span id="l20.9691">           mDatabase-&gt;SetUint32AttributeOnPendingHdr(msgDBHdr, &quot;flags&quot;,</span>
<a href="#l20.9692"></a><span id="l20.9692">                                                     nsMsgMessageFlags::Offline);</span>
<a href="#l20.9693"></a><span id="l20.9693">         mDatabase-&gt;SetAttributeOnPendingHdr(msgDBHdr, &quot;storeToken&quot;,</span>
<a href="#l20.9694"></a><span id="l20.9694">                                             storeToken.get());</span>
<a href="#l20.9695"></a><span id="l20.9695">       }</span>
<a href="#l20.9696"></a><span id="l20.9696">       nsMsgPriorityValue priority;</span>
<a href="#l20.9697"></a><span id="l20.9697">       msgDBHdr-&gt;GetPriority(&amp;priority);</span>
<a href="#l20.9698"></a><span id="l20.9698" class="difflineminus">-      if(priority != 0)</span>
<a href="#l20.9699"></a><span id="l20.9699" class="difflineminus">-      {</span>
<a href="#l20.9700"></a><span id="l20.9700" class="difflineplus">+      if (priority != 0) {</span>
<a href="#l20.9701"></a><span id="l20.9701">         nsAutoCString priorityStr;</span>
<a href="#l20.9702"></a><span id="l20.9702">         priorityStr.AppendInt(priority);</span>
<a href="#l20.9703"></a><span id="l20.9703" class="difflineminus">-        mDatabase-&gt;SetAttributeOnPendingHdr(msgDBHdr, &quot;priority&quot;, priorityStr.get());</span>
<a href="#l20.9704"></a><span id="l20.9704" class="difflineplus">+        mDatabase-&gt;SetAttributeOnPendingHdr(msgDBHdr, &quot;priority&quot;,</span>
<a href="#l20.9705"></a><span id="l20.9705" class="difflineplus">+                                            priorityStr.get());</span>
<a href="#l20.9706"></a><span id="l20.9706">       }</span>
<a href="#l20.9707"></a><span id="l20.9707">     }</span>
<a href="#l20.9708"></a><span id="l20.9708">   }</span>
<a href="#l20.9709"></a><span id="l20.9709"> }</span>
<a href="#l20.9710"></a><span id="l20.9710"> </span>
<a href="#l20.9711"></a><span id="l20.9711"> NS_IMETHODIMP</span>
<a href="#l20.9712"></a><span id="l20.9712" class="difflineminus">-nsImapMailFolder::CopyMessages(nsIMsgFolder* srcFolder,</span>
<a href="#l20.9713"></a><span id="l20.9713" class="difflineminus">-                               nsIArray* messages,</span>
<a href="#l20.9714"></a><span id="l20.9714" class="difflineminus">-                               bool isMove,</span>
<a href="#l20.9715"></a><span id="l20.9715" class="difflineminus">-                               nsIMsgWindow *msgWindow,</span>
<a href="#l20.9716"></a><span id="l20.9716" class="difflineminus">-                               nsIMsgCopyServiceListener* listener,</span>
<a href="#l20.9717"></a><span id="l20.9717" class="difflineminus">-                               bool isFolder, //isFolder for future use when we do cross-server folder move/copy</span>
<a href="#l20.9718"></a><span id="l20.9718" class="difflineminus">-                               bool allowUndo)</span>
<a href="#l20.9719"></a><span id="l20.9719" class="difflineminus">-{</span>
<a href="#l20.9720"></a><span id="l20.9720" class="difflineplus">+nsImapMailFolder::CopyMessages(</span>
<a href="#l20.9721"></a><span id="l20.9721" class="difflineplus">+    nsIMsgFolder *srcFolder, nsIArray *messages, bool isMove,</span>
<a href="#l20.9722"></a><span id="l20.9722" class="difflineplus">+    nsIMsgWindow *msgWindow, nsIMsgCopyServiceListener *listener,</span>
<a href="#l20.9723"></a><span id="l20.9723" class="difflineplus">+    bool isFolder,  // isFolder for future use when we do cross-server folder</span>
<a href="#l20.9724"></a><span id="l20.9724" class="difflineplus">+                    // move/copy</span>
<a href="#l20.9725"></a><span id="l20.9725" class="difflineplus">+    bool allowUndo) {</span>
<a href="#l20.9726"></a><span id="l20.9726">   UpdateTimestamps(allowUndo);</span>
<a href="#l20.9727"></a><span id="l20.9727"> </span>
<a href="#l20.9728"></a><span id="l20.9728">   nsresult rv;</span>
<a href="#l20.9729"></a><span id="l20.9729" class="difflineminus">-  nsCOMPtr &lt;nsIMsgIncomingServer&gt; srcServer;</span>
<a href="#l20.9730"></a><span id="l20.9730" class="difflineminus">-  nsCOMPtr &lt;nsIMsgIncomingServer&gt; dstServer;</span>
<a href="#l20.9731"></a><span id="l20.9731" class="difflineplus">+  nsCOMPtr&lt;nsIMsgIncomingServer&gt; srcServer;</span>
<a href="#l20.9732"></a><span id="l20.9732" class="difflineplus">+  nsCOMPtr&lt;nsIMsgIncomingServer&gt; dstServer;</span>
<a href="#l20.9733"></a><span id="l20.9733">   nsCOMPtr&lt;nsISupports&gt; srcSupport = do_QueryInterface(srcFolder);</span>
<a href="#l20.9734"></a><span id="l20.9734">   bool sameServer = false;</span>
<a href="#l20.9735"></a><span id="l20.9735"> </span>
<a href="#l20.9736"></a><span id="l20.9736">   rv = srcFolder-&gt;GetServer(getter_AddRefs(srcServer));</span>
<a href="#l20.9737"></a><span id="l20.9737" class="difflineminus">-  if(NS_FAILED(rv)) goto done;</span>
<a href="#l20.9738"></a><span id="l20.9738" class="difflineplus">+  if (NS_FAILED(rv)) goto done;</span>
<a href="#l20.9739"></a><span id="l20.9739"> </span>
<a href="#l20.9740"></a><span id="l20.9740">   rv = GetServer(getter_AddRefs(dstServer));</span>
<a href="#l20.9741"></a><span id="l20.9741" class="difflineminus">-  if(NS_FAILED(rv)) goto done;</span>
<a href="#l20.9742"></a><span id="l20.9742" class="difflineplus">+  if (NS_FAILED(rv)) goto done;</span>
<a href="#l20.9743"></a><span id="l20.9743"> </span>
<a href="#l20.9744"></a><span id="l20.9744">   NS_ENSURE_TRUE(dstServer, NS_ERROR_NULL_POINTER);</span>
<a href="#l20.9745"></a><span id="l20.9745"> </span>
<a href="#l20.9746"></a><span id="l20.9746">   rv = dstServer-&gt;Equals(srcServer, &amp;sameServer);</span>
<a href="#l20.9747"></a><span id="l20.9747">   if (NS_FAILED(rv)) goto done;</span>
<a href="#l20.9748"></a><span id="l20.9748"> </span>
<a href="#l20.9749"></a><span id="l20.9749">   // in theory, if allowUndo is true, then this is a user initiated</span>
<a href="#l20.9750"></a><span id="l20.9750">   // action, and we should do it pseudo-offline. If it's not</span>
<a href="#l20.9751"></a><span id="l20.9751">   // user initiated (e.g., mail filters firing), then allowUndo is</span>
<a href="#l20.9752"></a><span id="l20.9752">   // false, and we should just do the action.</span>
<a href="#l20.9753"></a><span id="l20.9753" class="difflineminus">-  if (!WeAreOffline() &amp;&amp; sameServer &amp;&amp; allowUndo)</span>
<a href="#l20.9754"></a><span id="l20.9754" class="difflineminus">-  {</span>
<a href="#l20.9755"></a><span id="l20.9755" class="difflineplus">+  if (!WeAreOffline() &amp;&amp; sameServer &amp;&amp; allowUndo) {</span>
<a href="#l20.9756"></a><span id="l20.9756">     // complete the copy operation as in offline mode</span>
<a href="#l20.9757"></a><span id="l20.9757">     rv = CopyMessagesOffline(srcFolder, messages, isMove, msgWindow, listener);</span>
<a href="#l20.9758"></a><span id="l20.9758"> </span>
<a href="#l20.9759"></a><span id="l20.9759">     NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), &quot;error offline copy&quot;);</span>
<a href="#l20.9760"></a><span id="l20.9760">     // We'll warn if this fails, but we should still try to play back</span>
<a href="#l20.9761"></a><span id="l20.9761">     // offline ops, because it's possible the copy got far enough to</span>
<a href="#l20.9762"></a><span id="l20.9762">     // create the offline ops.</span>
<a href="#l20.9763"></a><span id="l20.9763"> </span>
<a href="#l20.9764"></a><span id="l20.9764" class="difflineminus">-    // We make sure that the source folder is an imap folder by limiting pseudo-offline</span>
<a href="#l20.9765"></a><span id="l20.9765" class="difflineminus">-    // operations to the same imap server. If we extend the code to cover non imap folders</span>
<a href="#l20.9766"></a><span id="l20.9766" class="difflineminus">-    // in the future (i.e. imap folder-&gt;local folder), then the following downcast</span>
<a href="#l20.9767"></a><span id="l20.9767" class="difflineminus">-    // will cause either a crash or compiler error. Do not forget to change it accordingly.</span>
<a href="#l20.9768"></a><span id="l20.9768" class="difflineminus">-    nsImapMailFolder *srcImapFolder = static_cast&lt;nsImapMailFolder*&gt;(srcFolder);</span>
<a href="#l20.9769"></a><span id="l20.9769" class="difflineplus">+    // We make sure that the source folder is an imap folder by limiting</span>
<a href="#l20.9770"></a><span id="l20.9770" class="difflineplus">+    // pseudo-offline operations to the same imap server. If we extend the code</span>
<a href="#l20.9771"></a><span id="l20.9771" class="difflineplus">+    // to cover non imap folders in the future (i.e. imap folder-&gt;local folder),</span>
<a href="#l20.9772"></a><span id="l20.9772" class="difflineplus">+    // then the following downcast will cause either a crash or compiler error.</span>
<a href="#l20.9773"></a><span id="l20.9773" class="difflineplus">+    // Do not forget to change it accordingly.</span>
<a href="#l20.9774"></a><span id="l20.9774" class="difflineplus">+    nsImapMailFolder *srcImapFolder =</span>
<a href="#l20.9775"></a><span id="l20.9775" class="difflineplus">+        static_cast&lt;nsImapMailFolder *&gt;(srcFolder);</span>
<a href="#l20.9776"></a><span id="l20.9776"> </span>
<a href="#l20.9777"></a><span id="l20.9777">     // lazily create playback timer if it is not already</span>
<a href="#l20.9778"></a><span id="l20.9778">     // created</span>
<a href="#l20.9779"></a><span id="l20.9779" class="difflineminus">-    if (!srcImapFolder-&gt;m_playbackTimer)</span>
<a href="#l20.9780"></a><span id="l20.9780" class="difflineminus">-    {</span>
<a href="#l20.9781"></a><span id="l20.9781" class="difflineplus">+    if (!srcImapFolder-&gt;m_playbackTimer) {</span>
<a href="#l20.9782"></a><span id="l20.9782">       rv = srcImapFolder-&gt;CreatePlaybackTimer();</span>
<a href="#l20.9783"></a><span id="l20.9783" class="difflineminus">-      NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.9784"></a><span id="l20.9784" class="difflineminus">-    }</span>
<a href="#l20.9785"></a><span id="l20.9785" class="difflineminus">-</span>
<a href="#l20.9786"></a><span id="l20.9786" class="difflineminus">-    if (srcImapFolder-&gt;m_playbackTimer)</span>
<a href="#l20.9787"></a><span id="l20.9787" class="difflineminus">-    {</span>
<a href="#l20.9788"></a><span id="l20.9788" class="difflineminus">-      // if there is no pending request, create a new one, and set the timer. Otherwise</span>
<a href="#l20.9789"></a><span id="l20.9789" class="difflineminus">-      // use the existing one to reset the timer.</span>
<a href="#l20.9790"></a><span id="l20.9790" class="difflineminus">-      // it is callback function's responsibility to delete the new request object</span>
<a href="#l20.9791"></a><span id="l20.9791" class="difflineminus">-      if (!srcImapFolder-&gt;m_pendingPlaybackReq)</span>
<a href="#l20.9792"></a><span id="l20.9792" class="difflineminus">-      {</span>
<a href="#l20.9793"></a><span id="l20.9793" class="difflineminus">-        srcImapFolder-&gt;m_pendingPlaybackReq = new nsPlaybackRequest(srcImapFolder, msgWindow);</span>
<a href="#l20.9794"></a><span id="l20.9794" class="difflineminus">-        if (!srcImapFolder-&gt;m_pendingPlaybackReq)</span>
<a href="#l20.9795"></a><span id="l20.9795" class="difflineminus">-          return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.9796"></a><span id="l20.9796" class="difflineplus">+      NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.9797"></a><span id="l20.9797" class="difflineplus">+    }</span>
<a href="#l20.9798"></a><span id="l20.9798" class="difflineplus">+</span>
<a href="#l20.9799"></a><span id="l20.9799" class="difflineplus">+    if (srcImapFolder-&gt;m_playbackTimer) {</span>
<a href="#l20.9800"></a><span id="l20.9800" class="difflineplus">+      // if there is no pending request, create a new one, and set the timer.</span>
<a href="#l20.9801"></a><span id="l20.9801" class="difflineplus">+      // Otherwise use the existing one to reset the timer. it is callback</span>
<a href="#l20.9802"></a><span id="l20.9802" class="difflineplus">+      // function's responsibility to delete the new request object</span>
<a href="#l20.9803"></a><span id="l20.9803" class="difflineplus">+      if (!srcImapFolder-&gt;m_pendingPlaybackReq) {</span>
<a href="#l20.9804"></a><span id="l20.9804" class="difflineplus">+        srcImapFolder-&gt;m_pendingPlaybackReq =</span>
<a href="#l20.9805"></a><span id="l20.9805" class="difflineplus">+            new nsPlaybackRequest(srcImapFolder, msgWindow);</span>
<a href="#l20.9806"></a><span id="l20.9806" class="difflineplus">+        if (!srcImapFolder-&gt;m_pendingPlaybackReq) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.9807"></a><span id="l20.9807">       }</span>
<a href="#l20.9808"></a><span id="l20.9808"> </span>
<a href="#l20.9809"></a><span id="l20.9809" class="difflineminus">-      srcImapFolder-&gt;m_playbackTimer-&gt;InitWithNamedFuncCallback(PlaybackTimerCallback,</span>
<a href="#l20.9810"></a><span id="l20.9810" class="difflineminus">-                                                                (void *) srcImapFolder-&gt;m_pendingPlaybackReq,</span>
<a href="#l20.9811"></a><span id="l20.9811" class="difflineminus">-                                                                PLAYBACK_TIMER_INTERVAL_IN_MS,</span>
<a href="#l20.9812"></a><span id="l20.9812" class="difflineminus">-                                                                nsITimer::TYPE_ONE_SHOT,</span>
<a href="#l20.9813"></a><span id="l20.9813" class="difflineminus">-                                                                &quot;nsImapMailFolder::PlaybackTimerCallback&quot;);</span>
<a href="#l20.9814"></a><span id="l20.9814" class="difflineplus">+      srcImapFolder-&gt;m_playbackTimer-&gt;InitWithNamedFuncCallback(</span>
<a href="#l20.9815"></a><span id="l20.9815" class="difflineplus">+          PlaybackTimerCallback, (void *)srcImapFolder-&gt;m_pendingPlaybackReq,</span>
<a href="#l20.9816"></a><span id="l20.9816" class="difflineplus">+          PLAYBACK_TIMER_INTERVAL_IN_MS, nsITimer::TYPE_ONE_SHOT,</span>
<a href="#l20.9817"></a><span id="l20.9817" class="difflineplus">+          &quot;nsImapMailFolder::PlaybackTimerCallback&quot;);</span>
<a href="#l20.9818"></a><span id="l20.9818">     }</span>
<a href="#l20.9819"></a><span id="l20.9819">     return rv;</span>
<a href="#l20.9820"></a><span id="l20.9820" class="difflineminus">-  }</span>
<a href="#l20.9821"></a><span id="l20.9821" class="difflineminus">-  else</span>
<a href="#l20.9822"></a><span id="l20.9822" class="difflineminus">-  {</span>
<a href="#l20.9823"></a><span id="l20.9823" class="difflineplus">+  } else {</span>
<a href="#l20.9824"></a><span id="l20.9824">     // sort the message array by key</span>
<a href="#l20.9825"></a><span id="l20.9825"> </span>
<a href="#l20.9826"></a><span id="l20.9826">     uint32_t numMsgs = 0;</span>
<a href="#l20.9827"></a><span id="l20.9827">     messages-&gt;GetLength(&amp;numMsgs);</span>
<a href="#l20.9828"></a><span id="l20.9828">     nsTArray&lt;nsMsgKey&gt; keyArray(numMsgs);</span>
<a href="#l20.9829"></a><span id="l20.9829" class="difflineminus">-    for (uint32_t i = 0; i &lt; numMsgs; i++)</span>
<a href="#l20.9830"></a><span id="l20.9830" class="difflineminus">-    {</span>
<a href="#l20.9831"></a><span id="l20.9831" class="difflineplus">+    for (uint32_t i = 0; i &lt; numMsgs; i++) {</span>
<a href="#l20.9832"></a><span id="l20.9832">       nsCOMPtr&lt;nsIMsgDBHdr&gt; aMessage = do_QueryElementAt(messages, i, &amp;rv);</span>
<a href="#l20.9833"></a><span id="l20.9833" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; aMessage)</span>
<a href="#l20.9834"></a><span id="l20.9834" class="difflineminus">-      {</span>
<a href="#l20.9835"></a><span id="l20.9835" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; aMessage) {</span>
<a href="#l20.9836"></a><span id="l20.9836">         nsMsgKey key;</span>
<a href="#l20.9837"></a><span id="l20.9837">         aMessage-&gt;GetMessageKey(&amp;key);</span>
<a href="#l20.9838"></a><span id="l20.9838">         keyArray.AppendElement(key);</span>
<a href="#l20.9839"></a><span id="l20.9839">       }</span>
<a href="#l20.9840"></a><span id="l20.9840">     }</span>
<a href="#l20.9841"></a><span id="l20.9841">     keyArray.Sort();</span>
<a href="#l20.9842"></a><span id="l20.9842"> </span>
<a href="#l20.9843"></a><span id="l20.9843" class="difflineminus">-    nsCOMPtr&lt;nsIMutableArray&gt; sortedMsgs(do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l20.9844"></a><span id="l20.9844" class="difflineplus">+    nsCOMPtr&lt;nsIMutableArray&gt; sortedMsgs(</span>
<a href="#l20.9845"></a><span id="l20.9845" class="difflineplus">+        do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l20.9846"></a><span id="l20.9846">     rv = MessagesInKeyOrder(keyArray, srcFolder, sortedMsgs);</span>
<a href="#l20.9847"></a><span id="l20.9847">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.9848"></a><span id="l20.9848"> </span>
<a href="#l20.9849"></a><span id="l20.9849">     if (WeAreOffline())</span>
<a href="#l20.9850"></a><span id="l20.9850" class="difflineminus">-      return CopyMessagesOffline(srcFolder, sortedMsgs, isMove, msgWindow, listener);</span>
<a href="#l20.9851"></a><span id="l20.9851" class="difflineminus">-</span>
<a href="#l20.9852"></a><span id="l20.9852" class="difflineminus">-    nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.9853"></a><span id="l20.9853" class="difflineminus">-    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.9854"></a><span id="l20.9854" class="difflineplus">+      return CopyMessagesOffline(srcFolder, sortedMsgs, isMove, msgWindow,</span>
<a href="#l20.9855"></a><span id="l20.9855" class="difflineplus">+                                 listener);</span>
<a href="#l20.9856"></a><span id="l20.9856" class="difflineplus">+</span>
<a href="#l20.9857"></a><span id="l20.9857" class="difflineplus">+    nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.9858"></a><span id="l20.9858" class="difflineplus">+        do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.9859"></a><span id="l20.9859" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.9860"></a><span id="l20.9860"> </span>
<a href="#l20.9861"></a><span id="l20.9861">     // 3rd parameter: Do not set offline flag.</span>
<a href="#l20.9862"></a><span id="l20.9862">     SetPendingAttributes(sortedMsgs, isMove, false);</span>
<a href="#l20.9863"></a><span id="l20.9863"> </span>
<a href="#l20.9864"></a><span id="l20.9864">     // if the folders aren't on the same server, do a stream base copy</span>
<a href="#l20.9865"></a><span id="l20.9865" class="difflineminus">-    if (!sameServer)</span>
<a href="#l20.9866"></a><span id="l20.9866" class="difflineminus">-    {</span>
<a href="#l20.9867"></a><span id="l20.9867" class="difflineminus">-      rv = CopyMessagesWithStream(srcFolder, sortedMsgs, isMove, true, msgWindow, listener, allowUndo);</span>
<a href="#l20.9868"></a><span id="l20.9868" class="difflineplus">+    if (!sameServer) {</span>
<a href="#l20.9869"></a><span id="l20.9869" class="difflineplus">+      rv = CopyMessagesWithStream(srcFolder, sortedMsgs, isMove, true,</span>
<a href="#l20.9870"></a><span id="l20.9870" class="difflineplus">+                                  msgWindow, listener, allowUndo);</span>
<a href="#l20.9871"></a><span id="l20.9871">       goto done;</span>
<a href="#l20.9872"></a><span id="l20.9872">     }</span>
<a href="#l20.9873"></a><span id="l20.9873"> </span>
<a href="#l20.9874"></a><span id="l20.9874">     nsAutoCString messageIds;</span>
<a href="#l20.9875"></a><span id="l20.9875">     rv = AllocateUidStringFromKeys(keyArray.Elements(), numMsgs, messageIds);</span>
<a href="#l20.9876"></a><span id="l20.9876" class="difflineminus">-    if(NS_FAILED(rv)) goto done;</span>
<a href="#l20.9877"></a><span id="l20.9877" class="difflineplus">+    if (NS_FAILED(rv)) goto done;</span>
<a href="#l20.9878"></a><span id="l20.9878"> </span>
<a href="#l20.9879"></a><span id="l20.9879">     nsCOMPtr&lt;nsIUrlListener&gt; urlListener;</span>
<a href="#l20.9880"></a><span id="l20.9880" class="difflineminus">-    rv = QueryInterface(NS_GET_IID(nsIUrlListener), getter_AddRefs(urlListener));</span>
<a href="#l20.9881"></a><span id="l20.9881" class="difflineminus">-    rv = InitCopyState(srcSupport, sortedMsgs, isMove, true, false,</span>
<a href="#l20.9882"></a><span id="l20.9882" class="difflineminus">-                       0, EmptyCString(), listener, msgWindow, allowUndo);</span>
<a href="#l20.9883"></a><span id="l20.9883" class="difflineplus">+    rv =</span>
<a href="#l20.9884"></a><span id="l20.9884" class="difflineplus">+        QueryInterface(NS_GET_IID(nsIUrlListener), getter_AddRefs(urlListener));</span>
<a href="#l20.9885"></a><span id="l20.9885" class="difflineplus">+    rv = InitCopyState(srcSupport, sortedMsgs, isMove, true, false, 0,</span>
<a href="#l20.9886"></a><span id="l20.9886" class="difflineplus">+                       EmptyCString(), listener, msgWindow, allowUndo);</span>
<a href="#l20.9887"></a><span id="l20.9887">     if (NS_FAILED(rv)) goto done;</span>
<a href="#l20.9888"></a><span id="l20.9888"> </span>
<a href="#l20.9889"></a><span id="l20.9889">     m_copyState-&gt;m_curIndex = m_copyState-&gt;m_totalCount;</span>
<a href="#l20.9890"></a><span id="l20.9890"> </span>
<a href="#l20.9891"></a><span id="l20.9891">     if (isMove)</span>
<a href="#l20.9892"></a><span id="l20.9892" class="difflineminus">-      srcFolder-&gt;EnableNotifications(allMessageCountNotifications, false);  //disable message count notification</span>
<a href="#l20.9893"></a><span id="l20.9893" class="difflineplus">+      srcFolder-&gt;EnableNotifications(</span>
<a href="#l20.9894"></a><span id="l20.9894" class="difflineplus">+          allMessageCountNotifications,</span>
<a href="#l20.9895"></a><span id="l20.9895" class="difflineplus">+          false);  // disable message count notification</span>
<a href="#l20.9896"></a><span id="l20.9896"> </span>
<a href="#l20.9897"></a><span id="l20.9897">     nsCOMPtr&lt;nsISupports&gt; copySupport = do_QueryInterface(m_copyState);</span>
<a href="#l20.9898"></a><span id="l20.9898" class="difflineminus">-    rv = imapService-&gt;OnlineMessageCopy(srcFolder, messageIds,</span>
<a href="#l20.9899"></a><span id="l20.9899" class="difflineminus">-                                        this, true, isMove,</span>
<a href="#l20.9900"></a><span id="l20.9900" class="difflineminus">-                                        urlListener, nullptr,</span>
<a href="#l20.9901"></a><span id="l20.9901" class="difflineplus">+    rv = imapService-&gt;OnlineMessageCopy(srcFolder, messageIds, this, true,</span>
<a href="#l20.9902"></a><span id="l20.9902" class="difflineplus">+                                        isMove, urlListener, nullptr,</span>
<a href="#l20.9903"></a><span id="l20.9903">                                         copySupport, msgWindow);</span>
<a href="#l20.9904"></a><span id="l20.9904" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; m_copyState-&gt;m_allowUndo)</span>
<a href="#l20.9905"></a><span id="l20.9905" class="difflineminus">-    {</span>
<a href="#l20.9906"></a><span id="l20.9906" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; m_copyState-&gt;m_allowUndo) {</span>
<a href="#l20.9907"></a><span id="l20.9907">       RefPtr&lt;nsImapMoveCopyMsgTxn&gt; undoMsgTxn = new nsImapMoveCopyMsgTxn;</span>
<a href="#l20.9908"></a><span id="l20.9908" class="difflineminus">-      if (!undoMsgTxn || NS_FAILED(undoMsgTxn-&gt;Init(srcFolder, &amp;keyArray,</span>
<a href="#l20.9909"></a><span id="l20.9909" class="difflineminus">-                                   messageIds.get(), this,</span>
<a href="#l20.9910"></a><span id="l20.9910" class="difflineminus">-                                   true, isMove)))</span>
<a href="#l20.9911"></a><span id="l20.9911" class="difflineplus">+      if (!undoMsgTxn ||</span>
<a href="#l20.9912"></a><span id="l20.9912" class="difflineplus">+          NS_FAILED(undoMsgTxn-&gt;Init(srcFolder, &amp;keyArray, messageIds.get(),</span>
<a href="#l20.9913"></a><span id="l20.9913" class="difflineplus">+                                     this, true, isMove)))</span>
<a href="#l20.9914"></a><span id="l20.9914">         return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.9915"></a><span id="l20.9915"> </span>
<a href="#l20.9916"></a><span id="l20.9916" class="difflineminus">-      if (isMove)</span>
<a href="#l20.9917"></a><span id="l20.9917" class="difflineminus">-      {</span>
<a href="#l20.9918"></a><span id="l20.9918" class="difflineplus">+      if (isMove) {</span>
<a href="#l20.9919"></a><span id="l20.9919">         if (mFlags &amp; nsMsgFolderFlags::Trash)</span>
<a href="#l20.9920"></a><span id="l20.9920">           undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eDeleteMsg);</span>
<a href="#l20.9921"></a><span id="l20.9921">         else</span>
<a href="#l20.9922"></a><span id="l20.9922">           undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eMoveMsg);</span>
<a href="#l20.9923"></a><span id="l20.9923" class="difflineminus">-      }</span>
<a href="#l20.9924"></a><span id="l20.9924" class="difflineminus">-      else</span>
<a href="#l20.9925"></a><span id="l20.9925" class="difflineplus">+      } else</span>
<a href="#l20.9926"></a><span id="l20.9926">         undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eCopyMsg);</span>
<a href="#l20.9927"></a><span id="l20.9927">       m_copyState-&gt;m_undoMsgTxn = undoMsgTxn;</span>
<a href="#l20.9928"></a><span id="l20.9928">     }</span>
<a href="#l20.9929"></a><span id="l20.9929"> </span>
<a href="#l20.9930"></a><span id="l20.9930" class="difflineminus">-  }//endif</span>
<a href="#l20.9931"></a><span id="l20.9931" class="difflineplus">+  }  // endif</span>
<a href="#l20.9932"></a><span id="l20.9932"> </span>
<a href="#l20.9933"></a><span id="l20.9933"> done:</span>
<a href="#l20.9934"></a><span id="l20.9934" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l20.9935"></a><span id="l20.9935" class="difflineminus">-  {</span>
<a href="#l20.9936"></a><span id="l20.9936" class="difflineminus">-    (void) OnCopyCompleted(srcSupport, rv);</span>
<a href="#l20.9937"></a><span id="l20.9937" class="difflineminus">-    if (isMove)</span>
<a href="#l20.9938"></a><span id="l20.9938" class="difflineminus">-    {</span>
<a href="#l20.9939"></a><span id="l20.9939" class="difflineminus">-      srcFolder-&gt;EnableNotifications(allMessageCountNotifications, true);  //enable message count notification</span>
<a href="#l20.9940"></a><span id="l20.9940" class="difflineplus">+  if (NS_FAILED(rv)) {</span>
<a href="#l20.9941"></a><span id="l20.9941" class="difflineplus">+    (void)OnCopyCompleted(srcSupport, rv);</span>
<a href="#l20.9942"></a><span id="l20.9942" class="difflineplus">+    if (isMove) {</span>
<a href="#l20.9943"></a><span id="l20.9943" class="difflineplus">+      srcFolder-&gt;EnableNotifications(</span>
<a href="#l20.9944"></a><span id="l20.9944" class="difflineplus">+          allMessageCountNotifications,</span>
<a href="#l20.9945"></a><span id="l20.9945" class="difflineplus">+          true);  // enable message count notification</span>
<a href="#l20.9946"></a><span id="l20.9946">       NotifyFolderEvent(kDeleteOrMoveMsgFailed);</span>
<a href="#l20.9947"></a><span id="l20.9947">     }</span>
<a href="#l20.9948"></a><span id="l20.9948">   }</span>
<a href="#l20.9949"></a><span id="l20.9949">   return rv;</span>
<a href="#l20.9950"></a><span id="l20.9950"> }</span>
<a href="#l20.9951"></a><span id="l20.9951"> </span>
<a href="#l20.9952"></a><span id="l20.9952" class="difflineminus">-class nsImapFolderCopyState final : public nsIUrlListener, public nsIMsgCopyServiceListener</span>
<a href="#l20.9953"></a><span id="l20.9953" class="difflineminus">-{</span>
<a href="#l20.9954"></a><span id="l20.9954" class="difflineminus">-public:</span>
<a href="#l20.9955"></a><span id="l20.9955" class="difflineplus">+class nsImapFolderCopyState final : public nsIUrlListener,</span>
<a href="#l20.9956"></a><span id="l20.9956" class="difflineplus">+                                    public nsIMsgCopyServiceListener {</span>
<a href="#l20.9957"></a><span id="l20.9957" class="difflineplus">+ public:</span>
<a href="#l20.9958"></a><span id="l20.9958">   nsImapFolderCopyState(nsIMsgFolder *destParent, nsIMsgFolder *srcFolder,</span>
<a href="#l20.9959"></a><span id="l20.9959" class="difflineminus">-                    bool isMoveFolder, nsIMsgWindow *msgWindow, nsIMsgCopyServiceListener *listener);</span>
<a href="#l20.9960"></a><span id="l20.9960" class="difflineplus">+                        bool isMoveFolder, nsIMsgWindow *msgWindow,</span>
<a href="#l20.9961"></a><span id="l20.9961" class="difflineplus">+                        nsIMsgCopyServiceListener *listener);</span>
<a href="#l20.9962"></a><span id="l20.9962"> </span>
<a href="#l20.9963"></a><span id="l20.9963">   NS_DECL_ISUPPORTS</span>
<a href="#l20.9964"></a><span id="l20.9964">   NS_DECL_NSIURLLISTENER</span>
<a href="#l20.9965"></a><span id="l20.9965">   NS_DECL_NSIMSGCOPYSERVICELISTENER</span>
<a href="#l20.9966"></a><span id="l20.9966"> </span>
<a href="#l20.9967"></a><span id="l20.9967">   nsresult StartNextCopy();</span>
<a href="#l20.9968"></a><span id="l20.9968">   nsresult AdvanceToNextFolder(nsresult aStatus);</span>
<a href="#l20.9969"></a><span id="l20.9969" class="difflineminus">-protected:</span>
<a href="#l20.9970"></a><span id="l20.9970" class="difflineplus">+</span>
<a href="#l20.9971"></a><span id="l20.9971" class="difflineplus">+ protected:</span>
<a href="#l20.9972"></a><span id="l20.9972">   ~nsImapFolderCopyState();</span>
<a href="#l20.9973"></a><span id="l20.9973">   RefPtr&lt;nsImapMailFolder&gt; m_newDestFolder;</span>
<a href="#l20.9974"></a><span id="l20.9974">   nsCOMPtr&lt;nsISupports&gt; m_origSrcFolder;</span>
<a href="#l20.9975"></a><span id="l20.9975">   nsCOMPtr&lt;nsIMsgFolder&gt; m_curDestParent;</span>
<a href="#l20.9976"></a><span id="l20.9976">   nsCOMPtr&lt;nsIMsgFolder&gt; m_curSrcFolder;</span>
<a href="#l20.9977"></a><span id="l20.9977" class="difflineminus">-  bool                    m_isMoveFolder;</span>
<a href="#l20.9978"></a><span id="l20.9978" class="difflineplus">+  bool m_isMoveFolder;</span>
<a href="#l20.9979"></a><span id="l20.9979">   nsCOMPtr&lt;nsIMsgCopyServiceListener&gt; m_copySrvcListener;</span>
<a href="#l20.9980"></a><span id="l20.9980">   nsCOMPtr&lt;nsIMsgWindow&gt; m_msgWindow;</span>
<a href="#l20.9981"></a><span id="l20.9981" class="difflineminus">-  int32_t                 m_childIndex;</span>
<a href="#l20.9982"></a><span id="l20.9982" class="difflineplus">+  int32_t m_childIndex;</span>
<a href="#l20.9983"></a><span id="l20.9983">   nsCOMArray&lt;nsIMsgFolder&gt; m_srcChildFolders;</span>
<a href="#l20.9984"></a><span id="l20.9984">   nsCOMArray&lt;nsIMsgFolder&gt; m_destParents;</span>
<a href="#l20.9985"></a><span id="l20.9985" class="difflineminus">-</span>
<a href="#l20.9986"></a><span id="l20.9986"> };</span>
<a href="#l20.9987"></a><span id="l20.9987"> </span>
<a href="#l20.9988"></a><span id="l20.9988" class="difflineminus">-NS_IMPL_ISUPPORTS(nsImapFolderCopyState, nsIUrlListener, nsIMsgCopyServiceListener)</span>
<a href="#l20.9989"></a><span id="l20.9989" class="difflineminus">-</span>
<a href="#l20.9990"></a><span id="l20.9990" class="difflineminus">-nsImapFolderCopyState::nsImapFolderCopyState(nsIMsgFolder *destParent, nsIMsgFolder *srcFolder,</span>
<a href="#l20.9991"></a><span id="l20.9991" class="difflineminus">-                                             bool isMoveFolder, nsIMsgWindow *msgWindow, nsIMsgCopyServiceListener *listener)</span>
<a href="#l20.9992"></a><span id="l20.9992" class="difflineminus">-{</span>
<a href="#l20.9993"></a><span id="l20.9993" class="difflineplus">+NS_IMPL_ISUPPORTS(nsImapFolderCopyState, nsIUrlListener,</span>
<a href="#l20.9994"></a><span id="l20.9994" class="difflineplus">+                  nsIMsgCopyServiceListener)</span>
<a href="#l20.9995"></a><span id="l20.9995" class="difflineplus">+</span>
<a href="#l20.9996"></a><span id="l20.9996" class="difflineplus">+nsImapFolderCopyState::nsImapFolderCopyState(</span>
<a href="#l20.9997"></a><span id="l20.9997" class="difflineplus">+    nsIMsgFolder *destParent, nsIMsgFolder *srcFolder, bool isMoveFolder,</span>
<a href="#l20.9998"></a><span id="l20.9998" class="difflineplus">+    nsIMsgWindow *msgWindow, nsIMsgCopyServiceListener *listener) {</span>
<a href="#l20.9999"></a><span id="l20.9999">   m_origSrcFolder = do_QueryInterface(srcFolder);</span>
<a href="#l20.10000"></a><span id="l20.10000">   m_curDestParent = destParent;</span>
<a href="#l20.10001"></a><span id="l20.10001">   m_curSrcFolder = srcFolder;</span>
<a href="#l20.10002"></a><span id="l20.10002">   m_isMoveFolder = isMoveFolder;</span>
<a href="#l20.10003"></a><span id="l20.10003">   m_msgWindow = msgWindow;</span>
<a href="#l20.10004"></a><span id="l20.10004">   m_copySrvcListener = listener;</span>
<a href="#l20.10005"></a><span id="l20.10005">   m_childIndex = -1;</span>
<a href="#l20.10006"></a><span id="l20.10006"> }</span>
<a href="#l20.10007"></a><span id="l20.10007"> </span>
<a href="#l20.10008"></a><span id="l20.10008" class="difflineminus">-nsImapFolderCopyState::~nsImapFolderCopyState()</span>
<a href="#l20.10009"></a><span id="l20.10009" class="difflineminus">-{</span>
<a href="#l20.10010"></a><span id="l20.10010" class="difflineminus">-}</span>
<a href="#l20.10011"></a><span id="l20.10011" class="difflineminus">-</span>
<a href="#l20.10012"></a><span id="l20.10012" class="difflineminus">-nsresult</span>
<a href="#l20.10013"></a><span id="l20.10013" class="difflineminus">-nsImapFolderCopyState::StartNextCopy()</span>
<a href="#l20.10014"></a><span id="l20.10014" class="difflineminus">-{</span>
<a href="#l20.10015"></a><span id="l20.10015" class="difflineplus">+nsImapFolderCopyState::~nsImapFolderCopyState() {}</span>
<a href="#l20.10016"></a><span id="l20.10016" class="difflineplus">+</span>
<a href="#l20.10017"></a><span id="l20.10017" class="difflineplus">+nsresult nsImapFolderCopyState::StartNextCopy() {</span>
<a href="#l20.10018"></a><span id="l20.10018">   nsresult rv;</span>
<a href="#l20.10019"></a><span id="l20.10019">   // first make sure dest folder exists.</span>
<a href="#l20.10020"></a><span id="l20.10020" class="difflineminus">-  nsCOMPtr &lt;nsIImapService&gt; imapService = do_GetService (NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.10021"></a><span id="l20.10021" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.10022"></a><span id="l20.10022" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.10023"></a><span id="l20.10023">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10024"></a><span id="l20.10024">   nsString folderName;</span>
<a href="#l20.10025"></a><span id="l20.10025">   m_curSrcFolder-&gt;GetName(folderName);</span>
<a href="#l20.10026"></a><span id="l20.10026"> </span>
<a href="#l20.10027"></a><span id="l20.10027" class="difflineminus">-  return imapService-&gt;EnsureFolderExists(m_curDestParent,</span>
<a href="#l20.10028"></a><span id="l20.10028" class="difflineminus">-                                         folderName,</span>
<a href="#l20.10029"></a><span id="l20.10029" class="difflineminus">-                                         this, nullptr);</span>
<a href="#l20.10030"></a><span id="l20.10030" class="difflineminus">-}</span>
<a href="#l20.10031"></a><span id="l20.10031" class="difflineminus">-</span>
<a href="#l20.10032"></a><span id="l20.10032" class="difflineminus">-nsresult nsImapFolderCopyState::AdvanceToNextFolder(nsresult aStatus)</span>
<a href="#l20.10033"></a><span id="l20.10033" class="difflineminus">-{</span>
<a href="#l20.10034"></a><span id="l20.10034" class="difflineplus">+  return imapService-&gt;EnsureFolderExists(m_curDestParent, folderName, this,</span>
<a href="#l20.10035"></a><span id="l20.10035" class="difflineplus">+                                         nullptr);</span>
<a href="#l20.10036"></a><span id="l20.10036" class="difflineplus">+}</span>
<a href="#l20.10037"></a><span id="l20.10037" class="difflineplus">+</span>
<a href="#l20.10038"></a><span id="l20.10038" class="difflineplus">+nsresult nsImapFolderCopyState::AdvanceToNextFolder(nsresult aStatus) {</span>
<a href="#l20.10039"></a><span id="l20.10039">   nsresult rv = NS_OK;</span>
<a href="#l20.10040"></a><span id="l20.10040">   m_childIndex++;</span>
<a href="#l20.10041"></a><span id="l20.10041" class="difflineminus">-  if (m_childIndex &gt;= m_srcChildFolders.Count())</span>
<a href="#l20.10042"></a><span id="l20.10042" class="difflineminus">-  {</span>
<a href="#l20.10043"></a><span id="l20.10043" class="difflineplus">+  if (m_childIndex &gt;= m_srcChildFolders.Count()) {</span>
<a href="#l20.10044"></a><span id="l20.10044">     if (m_newDestFolder)</span>
<a href="#l20.10045"></a><span id="l20.10045">       m_newDestFolder-&gt;OnCopyCompleted(m_origSrcFolder, aStatus);</span>
<a href="#l20.10046"></a><span id="l20.10046" class="difflineminus">-  }</span>
<a href="#l20.10047"></a><span id="l20.10047" class="difflineminus">-  else</span>
<a href="#l20.10048"></a><span id="l20.10048" class="difflineminus">-  {</span>
<a href="#l20.10049"></a><span id="l20.10049" class="difflineplus">+  } else {</span>
<a href="#l20.10050"></a><span id="l20.10050">     m_curDestParent = m_destParents[m_childIndex];</span>
<a href="#l20.10051"></a><span id="l20.10051">     m_curSrcFolder = m_srcChildFolders[m_childIndex];</span>
<a href="#l20.10052"></a><span id="l20.10052">     rv = StartNextCopy();</span>
<a href="#l20.10053"></a><span id="l20.10053">   }</span>
<a href="#l20.10054"></a><span id="l20.10054">   return rv;</span>
<a href="#l20.10055"></a><span id="l20.10055"> }</span>
<a href="#l20.10056"></a><span id="l20.10056"> </span>
<a href="#l20.10057"></a><span id="l20.10057"> NS_IMETHODIMP</span>
<a href="#l20.10058"></a><span id="l20.10058" class="difflineminus">-nsImapFolderCopyState::OnStartRunningUrl(nsIURI *aUrl)</span>
<a href="#l20.10059"></a><span id="l20.10059" class="difflineminus">-{</span>
<a href="#l20.10060"></a><span id="l20.10060" class="difflineplus">+nsImapFolderCopyState::OnStartRunningUrl(nsIURI *aUrl) {</span>
<a href="#l20.10061"></a><span id="l20.10061">   NS_ASSERTION(aUrl, &quot;sanity check - need to be be running non-null url&quot;);</span>
<a href="#l20.10062"></a><span id="l20.10062">   return NS_OK;</span>
<a href="#l20.10063"></a><span id="l20.10063"> }</span>
<a href="#l20.10064"></a><span id="l20.10064"> </span>
<a href="#l20.10065"></a><span id="l20.10065"> NS_IMETHODIMP</span>
<a href="#l20.10066"></a><span id="l20.10066" class="difflineminus">-nsImapFolderCopyState::OnStopRunningUrl(nsIURI *aUrl, nsresult aExitCode)</span>
<a href="#l20.10067"></a><span id="l20.10067" class="difflineminus">-{</span>
<a href="#l20.10068"></a><span id="l20.10068" class="difflineminus">-  if (NS_FAILED(aExitCode))</span>
<a href="#l20.10069"></a><span id="l20.10069" class="difflineminus">-  {</span>
<a href="#l20.10070"></a><span id="l20.10070" class="difflineminus">-    if (m_copySrvcListener)</span>
<a href="#l20.10071"></a><span id="l20.10071" class="difflineminus">-      m_copySrvcListener-&gt;OnStopCopy(aExitCode);</span>
<a href="#l20.10072"></a><span id="l20.10072" class="difflineminus">-    return aExitCode; // or NS_OK???</span>
<a href="#l20.10073"></a><span id="l20.10073" class="difflineplus">+nsImapFolderCopyState::OnStopRunningUrl(nsIURI *aUrl, nsresult aExitCode) {</span>
<a href="#l20.10074"></a><span id="l20.10074" class="difflineplus">+  if (NS_FAILED(aExitCode)) {</span>
<a href="#l20.10075"></a><span id="l20.10075" class="difflineplus">+    if (m_copySrvcListener) m_copySrvcListener-&gt;OnStopCopy(aExitCode);</span>
<a href="#l20.10076"></a><span id="l20.10076" class="difflineplus">+    return aExitCode;  // or NS_OK???</span>
<a href="#l20.10077"></a><span id="l20.10077">   }</span>
<a href="#l20.10078"></a><span id="l20.10078">   nsresult rv = NS_OK;</span>
<a href="#l20.10079"></a><span id="l20.10079" class="difflineminus">-  if (aUrl)</span>
<a href="#l20.10080"></a><span id="l20.10080" class="difflineminus">-  {</span>
<a href="#l20.10081"></a><span id="l20.10081" class="difflineplus">+  if (aUrl) {</span>
<a href="#l20.10082"></a><span id="l20.10082">     nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(aUrl);</span>
<a href="#l20.10083"></a><span id="l20.10083" class="difflineminus">-    if (imapUrl)</span>
<a href="#l20.10084"></a><span id="l20.10084" class="difflineminus">-    {</span>
<a href="#l20.10085"></a><span id="l20.10085" class="difflineplus">+    if (imapUrl) {</span>
<a href="#l20.10086"></a><span id="l20.10086">       nsImapAction imapAction = nsIImapUrl::nsImapTest;</span>
<a href="#l20.10087"></a><span id="l20.10087">       imapUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l20.10088"></a><span id="l20.10088"> </span>
<a href="#l20.10089"></a><span id="l20.10089" class="difflineminus">-      switch(imapAction)</span>
<a href="#l20.10090"></a><span id="l20.10090" class="difflineminus">-      {</span>
<a href="#l20.10091"></a><span id="l20.10091" class="difflineminus">-        case nsIImapUrl::nsImapEnsureExistsFolder:</span>
<a href="#l20.10092"></a><span id="l20.10092" class="difflineminus">-        {</span>
<a href="#l20.10093"></a><span id="l20.10093" class="difflineplus">+      switch (imapAction) {</span>
<a href="#l20.10094"></a><span id="l20.10094" class="difflineplus">+        case nsIImapUrl::nsImapEnsureExistsFolder: {</span>
<a href="#l20.10095"></a><span id="l20.10095">           nsCOMPtr&lt;nsIMsgFolder&gt; newMsgFolder;</span>
<a href="#l20.10096"></a><span id="l20.10096">           nsString folderName;</span>
<a href="#l20.10097"></a><span id="l20.10097">           nsCString utf7LeafName;</span>
<a href="#l20.10098"></a><span id="l20.10098">           m_curSrcFolder-&gt;GetName(folderName);</span>
<a href="#l20.10099"></a><span id="l20.10099">           rv = CopyUTF16toMUTF7(folderName, utf7LeafName);</span>
<a href="#l20.10100"></a><span id="l20.10100" class="difflineminus">-          rv = m_curDestParent-&gt;FindSubFolder(utf7LeafName, getter_AddRefs(newMsgFolder));</span>
<a href="#l20.10101"></a><span id="l20.10101" class="difflineminus">-          NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.10102"></a><span id="l20.10102" class="difflineplus">+          rv = m_curDestParent-&gt;FindSubFolder(utf7LeafName,</span>
<a href="#l20.10103"></a><span id="l20.10103" class="difflineplus">+                                              getter_AddRefs(newMsgFolder));</span>
<a href="#l20.10104"></a><span id="l20.10104" class="difflineplus">+          NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10105"></a><span id="l20.10105">           // save the first new folder so we can send a notification to the</span>
<a href="#l20.10106"></a><span id="l20.10106">           // copy service when this whole process is done.</span>
<a href="#l20.10107"></a><span id="l20.10107">           if (!m_newDestFolder)</span>
<a href="#l20.10108"></a><span id="l20.10108" class="difflineminus">-            m_newDestFolder = static_cast&lt;nsImapMailFolder*&gt;(newMsgFolder.get());</span>
<a href="#l20.10109"></a><span id="l20.10109" class="difflineplus">+            m_newDestFolder =</span>
<a href="#l20.10110"></a><span id="l20.10110" class="difflineplus">+                static_cast&lt;nsImapMailFolder *&gt;(newMsgFolder.get());</span>
<a href="#l20.10111"></a><span id="l20.10111"> </span>
<a href="#l20.10112"></a><span id="l20.10112">           // check if the source folder has children. If it does, list them</span>
<a href="#l20.10113"></a><span id="l20.10113">           // into m_srcChildFolders, and set m_destParents for the</span>
<a href="#l20.10114"></a><span id="l20.10114">           // corresponding indexes to the newly created folder.</span>
<a href="#l20.10115"></a><span id="l20.10115">           nsCOMPtr&lt;nsISimpleEnumerator&gt; enumerator;</span>
<a href="#l20.10116"></a><span id="l20.10116">           rv = m_curSrcFolder-&gt;GetSubFolders(getter_AddRefs(enumerator));</span>
<a href="#l20.10117"></a><span id="l20.10117">           NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10118"></a><span id="l20.10118"> </span>
<a href="#l20.10119"></a><span id="l20.10119">           nsCOMPtr&lt;nsISupports&gt; item;</span>
<a href="#l20.10120"></a><span id="l20.10120">           bool hasMore = false;</span>
<a href="#l20.10121"></a><span id="l20.10121">           uint32_t childIndex = 0;</span>
<a href="#l20.10122"></a><span id="l20.10122" class="difflineminus">-          while (NS_SUCCEEDED(enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l20.10123"></a><span id="l20.10123" class="difflineminus">-          {</span>
<a href="#l20.10124"></a><span id="l20.10124" class="difflineplus">+          while (NS_SUCCEEDED(enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp;</span>
<a href="#l20.10125"></a><span id="l20.10125" class="difflineplus">+                 hasMore) {</span>
<a href="#l20.10126"></a><span id="l20.10126">             rv = enumerator-&gt;GetNext(getter_AddRefs(item));</span>
<a href="#l20.10127"></a><span id="l20.10127">             nsCOMPtr&lt;nsIMsgFolder&gt; folder(do_QueryInterface(item, &amp;rv));</span>
<a href="#l20.10128"></a><span id="l20.10128" class="difflineminus">-            if (NS_SUCCEEDED(rv))</span>
<a href="#l20.10129"></a><span id="l20.10129" class="difflineminus">-            {</span>
<a href="#l20.10130"></a><span id="l20.10130" class="difflineminus">-              m_srcChildFolders.InsertElementAt(m_childIndex + childIndex + 1, folder);</span>
<a href="#l20.10131"></a><span id="l20.10131" class="difflineminus">-              m_destParents.InsertElementAt(m_childIndex + childIndex + 1, newMsgFolder);</span>
<a href="#l20.10132"></a><span id="l20.10132" class="difflineplus">+            if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.10133"></a><span id="l20.10133" class="difflineplus">+              m_srcChildFolders.InsertElementAt(m_childIndex + childIndex + 1,</span>
<a href="#l20.10134"></a><span id="l20.10134" class="difflineplus">+                                                folder);</span>
<a href="#l20.10135"></a><span id="l20.10135" class="difflineplus">+              m_destParents.InsertElementAt(m_childIndex + childIndex + 1,</span>
<a href="#l20.10136"></a><span id="l20.10136" class="difflineplus">+                                            newMsgFolder);</span>
<a href="#l20.10137"></a><span id="l20.10137">             }</span>
<a href="#l20.10138"></a><span id="l20.10138">             ++childIndex;</span>
<a href="#l20.10139"></a><span id="l20.10139">           }</span>
<a href="#l20.10140"></a><span id="l20.10140"> </span>
<a href="#l20.10141"></a><span id="l20.10141">           rv = m_curSrcFolder-&gt;GetMessages(getter_AddRefs(enumerator));</span>
<a href="#l20.10142"></a><span id="l20.10142" class="difflineminus">-          nsCOMPtr&lt;nsIMutableArray&gt; msgArray(do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l20.10143"></a><span id="l20.10143" class="difflineplus">+          nsCOMPtr&lt;nsIMutableArray&gt; msgArray(</span>
<a href="#l20.10144"></a><span id="l20.10144" class="difflineplus">+              do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l20.10145"></a><span id="l20.10145">           NS_ENSURE_TRUE(msgArray, rv);</span>
<a href="#l20.10146"></a><span id="l20.10146">           hasMore = false;</span>
<a href="#l20.10147"></a><span id="l20.10147"> </span>
<a href="#l20.10148"></a><span id="l20.10148" class="difflineminus">-          if (enumerator)</span>
<a href="#l20.10149"></a><span id="l20.10149" class="difflineminus">-            rv = enumerator-&gt;HasMoreElements(&amp;hasMore);</span>
<a href="#l20.10150"></a><span id="l20.10150" class="difflineminus">-</span>
<a href="#l20.10151"></a><span id="l20.10151" class="difflineminus">-          if (!hasMore)</span>
<a href="#l20.10152"></a><span id="l20.10152" class="difflineminus">-            return AdvanceToNextFolder(NS_OK);</span>
<a href="#l20.10153"></a><span id="l20.10153" class="difflineminus">-</span>
<a href="#l20.10154"></a><span id="l20.10154" class="difflineminus">-          while (NS_SUCCEEDED(rv) &amp;&amp; hasMore)</span>
<a href="#l20.10155"></a><span id="l20.10155" class="difflineminus">-          {</span>
<a href="#l20.10156"></a><span id="l20.10156" class="difflineplus">+          if (enumerator) rv = enumerator-&gt;HasMoreElements(&amp;hasMore);</span>
<a href="#l20.10157"></a><span id="l20.10157" class="difflineplus">+</span>
<a href="#l20.10158"></a><span id="l20.10158" class="difflineplus">+          if (!hasMore) return AdvanceToNextFolder(NS_OK);</span>
<a href="#l20.10159"></a><span id="l20.10159" class="difflineplus">+</span>
<a href="#l20.10160"></a><span id="l20.10160" class="difflineplus">+          while (NS_SUCCEEDED(rv) &amp;&amp; hasMore) {</span>
<a href="#l20.10161"></a><span id="l20.10161">             rv = enumerator-&gt;GetNext(getter_AddRefs(item));</span>
<a href="#l20.10162"></a><span id="l20.10162">             NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10163"></a><span id="l20.10163">             rv = msgArray-&gt;AppendElement(item);</span>
<a href="#l20.10164"></a><span id="l20.10164">             NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10165"></a><span id="l20.10165">             rv = enumerator-&gt;HasMoreElements(&amp;hasMore);</span>
<a href="#l20.10166"></a><span id="l20.10166">           }</span>
<a href="#l20.10167"></a><span id="l20.10167"> </span>
<a href="#l20.10168"></a><span id="l20.10168" class="difflineminus">-          nsCOMPtr&lt;nsIMsgCopyService&gt; copyService = do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.10169"></a><span id="l20.10169" class="difflineplus">+          nsCOMPtr&lt;nsIMsgCopyService&gt; copyService =</span>
<a href="#l20.10170"></a><span id="l20.10170" class="difflineplus">+              do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.10171"></a><span id="l20.10171">           NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10172"></a><span id="l20.10172" class="difflineminus">-          rv = copyService-&gt;CopyMessages(m_curSrcFolder,</span>
<a href="#l20.10173"></a><span id="l20.10173" class="difflineminus">-                             msgArray, newMsgFolder,</span>
<a href="#l20.10174"></a><span id="l20.10174" class="difflineminus">-                             m_isMoveFolder,</span>
<a href="#l20.10175"></a><span id="l20.10175" class="difflineminus">-                             this,</span>
<a href="#l20.10176"></a><span id="l20.10176" class="difflineminus">-                             m_msgWindow,</span>
<a href="#l20.10177"></a><span id="l20.10177" class="difflineminus">-                             false /* allowUndo */);</span>
<a href="#l20.10178"></a><span id="l20.10178" class="difflineminus">-        }</span>
<a href="#l20.10179"></a><span id="l20.10179" class="difflineminus">-        break;</span>
<a href="#l20.10180"></a><span id="l20.10180" class="difflineplus">+          rv = copyService-&gt;CopyMessages(m_curSrcFolder, msgArray, newMsgFolder,</span>
<a href="#l20.10181"></a><span id="l20.10181" class="difflineplus">+                                         m_isMoveFolder, this, m_msgWindow,</span>
<a href="#l20.10182"></a><span id="l20.10182" class="difflineplus">+                                         false /* allowUndo */);</span>
<a href="#l20.10183"></a><span id="l20.10183" class="difflineplus">+        } break;</span>
<a href="#l20.10184"></a><span id="l20.10184">       }</span>
<a href="#l20.10185"></a><span id="l20.10185">     }</span>
<a href="#l20.10186"></a><span id="l20.10186">   }</span>
<a href="#l20.10187"></a><span id="l20.10187">   return rv;</span>
<a href="#l20.10188"></a><span id="l20.10188"> }</span>
<a href="#l20.10189"></a><span id="l20.10189"> </span>
<a href="#l20.10190"></a><span id="l20.10190" class="difflineminus">-NS_IMETHODIMP nsImapFolderCopyState::OnStartCopy()</span>
<a href="#l20.10191"></a><span id="l20.10191" class="difflineminus">-{</span>
<a href="#l20.10192"></a><span id="l20.10192" class="difflineminus">-  return NS_OK;</span>
<a href="#l20.10193"></a><span id="l20.10193" class="difflineminus">-}</span>
<a href="#l20.10194"></a><span id="l20.10194" class="difflineplus">+NS_IMETHODIMP nsImapFolderCopyState::OnStartCopy() { return NS_OK; }</span>
<a href="#l20.10195"></a><span id="l20.10195"> </span>
<a href="#l20.10196"></a><span id="l20.10196"> /* void OnProgress (in uint32_t aProgress, in uint32_t aProgressMax); */</span>
<a href="#l20.10197"></a><span id="l20.10197" class="difflineminus">-NS_IMETHODIMP nsImapFolderCopyState::OnProgress(uint32_t aProgress, uint32_t aProgressMax)</span>
<a href="#l20.10198"></a><span id="l20.10198" class="difflineminus">-{</span>
<a href="#l20.10199"></a><span id="l20.10199" class="difflineplus">+NS_IMETHODIMP nsImapFolderCopyState::OnProgress(uint32_t aProgress,</span>
<a href="#l20.10200"></a><span id="l20.10200" class="difflineplus">+                                                uint32_t aProgressMax) {</span>
<a href="#l20.10201"></a><span id="l20.10201">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l20.10202"></a><span id="l20.10202"> }</span>
<a href="#l20.10203"></a><span id="l20.10203"> </span>
<a href="#l20.10204"></a><span id="l20.10204"> /* void SetMessageKey (in nsMsgKey aKey); */</span>
<a href="#l20.10205"></a><span id="l20.10205" class="difflineminus">-NS_IMETHODIMP nsImapFolderCopyState::SetMessageKey(nsMsgKey aKey)</span>
<a href="#l20.10206"></a><span id="l20.10206" class="difflineminus">-{</span>
<a href="#l20.10207"></a><span id="l20.10207" class="difflineplus">+NS_IMETHODIMP nsImapFolderCopyState::SetMessageKey(nsMsgKey aKey) {</span>
<a href="#l20.10208"></a><span id="l20.10208">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l20.10209"></a><span id="l20.10209"> }</span>
<a href="#l20.10210"></a><span id="l20.10210"> </span>
<a href="#l20.10211"></a><span id="l20.10211"> /* [noscript] void GetMessageId (in nsCString aMessageId); */</span>
<a href="#l20.10212"></a><span id="l20.10212" class="difflineminus">-NS_IMETHODIMP nsImapFolderCopyState::GetMessageId(nsACString&amp; messageId)</span>
<a href="#l20.10213"></a><span id="l20.10213" class="difflineminus">-{</span>
<a href="#l20.10214"></a><span id="l20.10214" class="difflineplus">+NS_IMETHODIMP nsImapFolderCopyState::GetMessageId(nsACString &amp;messageId) {</span>
<a href="#l20.10215"></a><span id="l20.10215">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l20.10216"></a><span id="l20.10216"> }</span>
<a href="#l20.10217"></a><span id="l20.10217"> </span>
<a href="#l20.10218"></a><span id="l20.10218"> /* void OnStopCopy (in nsresult aStatus); */</span>
<a href="#l20.10219"></a><span id="l20.10219" class="difflineminus">-NS_IMETHODIMP nsImapFolderCopyState::OnStopCopy(nsresult aStatus)</span>
<a href="#l20.10220"></a><span id="l20.10220" class="difflineminus">-{</span>
<a href="#l20.10221"></a><span id="l20.10221" class="difflineminus">-  if (NS_SUCCEEDED(aStatus))</span>
<a href="#l20.10222"></a><span id="l20.10222" class="difflineminus">-    return AdvanceToNextFolder(aStatus);</span>
<a href="#l20.10223"></a><span id="l20.10223" class="difflineminus">-  if (m_copySrvcListener)</span>
<a href="#l20.10224"></a><span id="l20.10224" class="difflineminus">-  {</span>
<a href="#l20.10225"></a><span id="l20.10225" class="difflineminus">-    (void) m_copySrvcListener-&gt;OnStopCopy(aStatus);</span>
<a href="#l20.10226"></a><span id="l20.10226" class="difflineplus">+NS_IMETHODIMP nsImapFolderCopyState::OnStopCopy(nsresult aStatus) {</span>
<a href="#l20.10227"></a><span id="l20.10227" class="difflineplus">+  if (NS_SUCCEEDED(aStatus)) return AdvanceToNextFolder(aStatus);</span>
<a href="#l20.10228"></a><span id="l20.10228" class="difflineplus">+  if (m_copySrvcListener) {</span>
<a href="#l20.10229"></a><span id="l20.10229" class="difflineplus">+    (void)m_copySrvcListener-&gt;OnStopCopy(aStatus);</span>
<a href="#l20.10230"></a><span id="l20.10230">     m_copySrvcListener = nullptr;</span>
<a href="#l20.10231"></a><span id="l20.10231">   }</span>
<a href="#l20.10232"></a><span id="l20.10232"> </span>
<a href="#l20.10233"></a><span id="l20.10233">   return NS_OK;</span>
<a href="#l20.10234"></a><span id="l20.10234"> }</span>
<a href="#l20.10235"></a><span id="l20.10235"> </span>
<a href="#l20.10236"></a><span id="l20.10236"> // &quot;this&quot; is the parent of the copied folder.</span>
<a href="#l20.10237"></a><span id="l20.10237"> NS_IMETHODIMP</span>
<a href="#l20.10238"></a><span id="l20.10238" class="difflineminus">-nsImapMailFolder::CopyFolder(nsIMsgFolder* srcFolder,</span>
<a href="#l20.10239"></a><span id="l20.10239" class="difflineminus">-                               bool isMoveFolder,</span>
<a href="#l20.10240"></a><span id="l20.10240" class="difflineminus">-                               nsIMsgWindow *msgWindow,</span>
<a href="#l20.10241"></a><span id="l20.10241" class="difflineminus">-                               nsIMsgCopyServiceListener* listener)</span>
<a href="#l20.10242"></a><span id="l20.10242" class="difflineminus">-{</span>
<a href="#l20.10243"></a><span id="l20.10243" class="difflineplus">+nsImapMailFolder::CopyFolder(nsIMsgFolder *srcFolder, bool isMoveFolder,</span>
<a href="#l20.10244"></a><span id="l20.10244" class="difflineplus">+                             nsIMsgWindow *msgWindow,</span>
<a href="#l20.10245"></a><span id="l20.10245" class="difflineplus">+                             nsIMsgCopyServiceListener *listener) {</span>
<a href="#l20.10246"></a><span id="l20.10246">   NS_ENSURE_ARG_POINTER(srcFolder);</span>
<a href="#l20.10247"></a><span id="l20.10247"> </span>
<a href="#l20.10248"></a><span id="l20.10248">   nsresult rv = NS_OK;</span>
<a href="#l20.10249"></a><span id="l20.10249"> </span>
<a href="#l20.10250"></a><span id="l20.10250" class="difflineminus">-  if (isMoveFolder)   //move folder permitted when dstFolder and the srcFolder are on same server</span>
<a href="#l20.10251"></a><span id="l20.10251" class="difflineplus">+  if (isMoveFolder)  // move folder permitted when dstFolder and the srcFolder</span>
<a href="#l20.10252"></a><span id="l20.10252" class="difflineplus">+                     // are on same server</span>
<a href="#l20.10253"></a><span id="l20.10253">   {</span>
<a href="#l20.10254"></a><span id="l20.10254">     uint32_t folderFlags = 0;</span>
<a href="#l20.10255"></a><span id="l20.10255" class="difflineminus">-    if (srcFolder)</span>
<a href="#l20.10256"></a><span id="l20.10256" class="difflineminus">-      srcFolder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l20.10257"></a><span id="l20.10257" class="difflineplus">+    if (srcFolder) srcFolder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l20.10258"></a><span id="l20.10258"> </span>
<a href="#l20.10259"></a><span id="l20.10259">     // if our source folder is a virtual folder</span>
<a href="#l20.10260"></a><span id="l20.10260" class="difflineminus">-    if (folderFlags &amp; nsMsgFolderFlags::Virtual)</span>
<a href="#l20.10261"></a><span id="l20.10261" class="difflineminus">-    {</span>
<a href="#l20.10262"></a><span id="l20.10262" class="difflineplus">+    if (folderFlags &amp; nsMsgFolderFlags::Virtual) {</span>
<a href="#l20.10263"></a><span id="l20.10263">       nsCOMPtr&lt;nsIMsgFolder&gt; newMsgFolder;</span>
<a href="#l20.10264"></a><span id="l20.10264">       nsString folderName;</span>
<a href="#l20.10265"></a><span id="l20.10265">       srcFolder-&gt;GetName(folderName);</span>
<a href="#l20.10266"></a><span id="l20.10266"> </span>
<a href="#l20.10267"></a><span id="l20.10267">       nsAutoString safeFolderName(folderName);</span>
<a href="#l20.10268"></a><span id="l20.10268">       NS_MsgHashIfNecessary(safeFolderName);</span>
<a href="#l20.10269"></a><span id="l20.10269"> </span>
<a href="#l20.10270"></a><span id="l20.10270">       srcFolder-&gt;ForceDBClosed();</span>
<a href="#l20.10271"></a><span id="l20.10271"> </span>
<a href="#l20.10272"></a><span id="l20.10272">       nsCOMPtr&lt;nsIFile&gt; oldPathFile;</span>
<a href="#l20.10273"></a><span id="l20.10273">       rv = srcFolder-&gt;GetFilePath(getter_AddRefs(oldPathFile));</span>
<a href="#l20.10274"></a><span id="l20.10274" class="difflineminus">-      NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.10275"></a><span id="l20.10275" class="difflineminus">-</span>
<a href="#l20.10276"></a><span id="l20.10276" class="difflineminus">-      nsCOMPtr &lt;nsIFile&gt; summaryFile;</span>
<a href="#l20.10277"></a><span id="l20.10277" class="difflineplus">+      NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10278"></a><span id="l20.10278" class="difflineplus">+</span>
<a href="#l20.10279"></a><span id="l20.10279" class="difflineplus">+      nsCOMPtr&lt;nsIFile&gt; summaryFile;</span>
<a href="#l20.10280"></a><span id="l20.10280">       GetSummaryFileLocation(oldPathFile, getter_AddRefs(summaryFile));</span>
<a href="#l20.10281"></a><span id="l20.10281"> </span>
<a href="#l20.10282"></a><span id="l20.10282">       nsCOMPtr&lt;nsIFile&gt; newPathFile;</span>
<a href="#l20.10283"></a><span id="l20.10283">       rv = GetFilePath(getter_AddRefs(newPathFile));</span>
<a href="#l20.10284"></a><span id="l20.10284" class="difflineminus">-      NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.10285"></a><span id="l20.10285" class="difflineplus">+      NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10286"></a><span id="l20.10286"> </span>
<a href="#l20.10287"></a><span id="l20.10287">       bool isDirectory = false;</span>
<a href="#l20.10288"></a><span id="l20.10288">       newPathFile-&gt;IsDirectory(&amp;isDirectory);</span>
<a href="#l20.10289"></a><span id="l20.10289" class="difflineminus">-      if (!isDirectory)</span>
<a href="#l20.10290"></a><span id="l20.10290" class="difflineminus">-      {</span>
<a href="#l20.10291"></a><span id="l20.10291" class="difflineplus">+      if (!isDirectory) {</span>
<a href="#l20.10292"></a><span id="l20.10292">         AddDirectorySeparator(newPathFile);</span>
<a href="#l20.10293"></a><span id="l20.10293">         rv = newPathFile-&gt;Create(nsIFile::DIRECTORY_TYPE, 0700);</span>
<a href="#l20.10294"></a><span id="l20.10294">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10295"></a><span id="l20.10295">       }</span>
<a href="#l20.10296"></a><span id="l20.10296"> </span>
<a href="#l20.10297"></a><span id="l20.10297">       rv = CheckIfFolderExists(folderName, this, msgWindow);</span>
<a href="#l20.10298"></a><span id="l20.10298" class="difflineminus">-      if(NS_FAILED(rv))</span>
<a href="#l20.10299"></a><span id="l20.10299" class="difflineminus">-        return rv;</span>
<a href="#l20.10300"></a><span id="l20.10300" class="difflineplus">+      if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.10301"></a><span id="l20.10301"> </span>
<a href="#l20.10302"></a><span id="l20.10302">       rv = summaryFile-&gt;CopyTo(newPathFile, EmptyString());</span>
<a href="#l20.10303"></a><span id="l20.10303">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10304"></a><span id="l20.10304"> </span>
<a href="#l20.10305"></a><span id="l20.10305">       rv = AddSubfolder(safeFolderName, getter_AddRefs(newMsgFolder));</span>
<a href="#l20.10306"></a><span id="l20.10306">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10307"></a><span id="l20.10307"> </span>
<a href="#l20.10308"></a><span id="l20.10308">       newMsgFolder-&gt;SetPrettyName(folderName);</span>
<a href="#l20.10309"></a><span id="l20.10309" class="difflineat">@@ -7970,878 +7281,803 @@ nsImapMailFolder::CopyFolder(nsIMsgFolde</span>
<a href="#l20.10310"></a><span id="l20.10310">       newMsgFolder-&gt;SetFlags(flags);</span>
<a href="#l20.10311"></a><span id="l20.10311"> </span>
<a href="#l20.10312"></a><span id="l20.10312">       NotifyItemAdded(newMsgFolder);</span>
<a href="#l20.10313"></a><span id="l20.10313"> </span>
<a href="#l20.10314"></a><span id="l20.10314">       // now remove the old folder</span>
<a href="#l20.10315"></a><span id="l20.10315">       nsCOMPtr&lt;nsIMsgFolder&gt; msgParent;</span>
<a href="#l20.10316"></a><span id="l20.10316">       srcFolder-&gt;GetParent(getter_AddRefs(msgParent));</span>
<a href="#l20.10317"></a><span id="l20.10317">       srcFolder-&gt;SetParent(nullptr);</span>
<a href="#l20.10318"></a><span id="l20.10318" class="difflineminus">-      if (msgParent)</span>
<a href="#l20.10319"></a><span id="l20.10319" class="difflineminus">-      {</span>
<a href="#l20.10320"></a><span id="l20.10320" class="difflineminus">-        msgParent-&gt;PropagateDelete(srcFolder, false, msgWindow);  // The files have already been moved, so delete storage false</span>
<a href="#l20.10321"></a><span id="l20.10321" class="difflineminus">-        oldPathFile-&gt;Remove(false);  //berkeley mailbox</span>
<a href="#l20.10322"></a><span id="l20.10322" class="difflineminus">-        nsCOMPtr &lt;nsIMsgDatabase&gt; srcDB; // we need to force closed the source db</span>
<a href="#l20.10323"></a><span id="l20.10323" class="difflineplus">+      if (msgParent) {</span>
<a href="#l20.10324"></a><span id="l20.10324" class="difflineplus">+        msgParent-&gt;PropagateDelete(</span>
<a href="#l20.10325"></a><span id="l20.10325" class="difflineplus">+            srcFolder, false, msgWindow);  // The files have already been moved,</span>
<a href="#l20.10326"></a><span id="l20.10326" class="difflineplus">+                                           // so delete storage false</span>
<a href="#l20.10327"></a><span id="l20.10327" class="difflineplus">+        oldPathFile-&gt;Remove(false);        // berkeley mailbox</span>
<a href="#l20.10328"></a><span id="l20.10328" class="difflineplus">+        nsCOMPtr&lt;nsIMsgDatabase&gt;</span>
<a href="#l20.10329"></a><span id="l20.10329" class="difflineplus">+            srcDB;  // we need to force closed the source db</span>
<a href="#l20.10330"></a><span id="l20.10330">         srcFolder-&gt;Delete();</span>
<a href="#l20.10331"></a><span id="l20.10331"> </span>
<a href="#l20.10332"></a><span id="l20.10332">         nsCOMPtr&lt;nsIFile&gt; parentPathFile;</span>
<a href="#l20.10333"></a><span id="l20.10333">         rv = msgParent-&gt;GetFilePath(getter_AddRefs(parentPathFile));</span>
<a href="#l20.10334"></a><span id="l20.10334" class="difflineminus">-        NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.10335"></a><span id="l20.10335" class="difflineplus">+        NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10336"></a><span id="l20.10336"> </span>
<a href="#l20.10337"></a><span id="l20.10337">         AddDirectorySeparator(parentPathFile);</span>
<a href="#l20.10338"></a><span id="l20.10338">         nsCOMPtr&lt;nsIDirectoryEnumerator&gt; children;</span>
<a href="#l20.10339"></a><span id="l20.10339">         parentPathFile-&gt;GetDirectoryEntries(getter_AddRefs(children));</span>
<a href="#l20.10340"></a><span id="l20.10340">         bool more;</span>
<a href="#l20.10341"></a><span id="l20.10341">         // checks if the directory is empty or not</span>
<a href="#l20.10342"></a><span id="l20.10342">         if (children &amp;&amp; NS_SUCCEEDED(children-&gt;HasMoreElements(&amp;more)) &amp;&amp; !more)</span>
<a href="#l20.10343"></a><span id="l20.10343">           parentPathFile-&gt;Remove(true);</span>
<a href="#l20.10344"></a><span id="l20.10344">       }</span>
<a href="#l20.10345"></a><span id="l20.10345" class="difflineminus">-    }</span>
<a href="#l20.10346"></a><span id="l20.10346" class="difflineminus">-    else // non-virtual folder</span>
<a href="#l20.10347"></a><span id="l20.10347" class="difflineplus">+    } else  // non-virtual folder</span>
<a href="#l20.10348"></a><span id="l20.10348">     {</span>
<a href="#l20.10349"></a><span id="l20.10349" class="difflineminus">-      nsCOMPtr &lt;nsIImapService&gt; imapService = do_GetService (NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.10350"></a><span id="l20.10350" class="difflineplus">+      nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.10351"></a><span id="l20.10351" class="difflineplus">+          do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.10352"></a><span id="l20.10352">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10353"></a><span id="l20.10353">       nsCOMPtr&lt;nsISupports&gt; srcSupport = do_QueryInterface(srcFolder);</span>
<a href="#l20.10354"></a><span id="l20.10354">       bool match = false;</span>
<a href="#l20.10355"></a><span id="l20.10355">       bool confirmed = false;</span>
<a href="#l20.10356"></a><span id="l20.10356" class="difflineminus">-      if (mFlags &amp; nsMsgFolderFlags::Trash)</span>
<a href="#l20.10357"></a><span id="l20.10357" class="difflineminus">-      {</span>
<a href="#l20.10358"></a><span id="l20.10358" class="difflineplus">+      if (mFlags &amp; nsMsgFolderFlags::Trash) {</span>
<a href="#l20.10359"></a><span id="l20.10359">         rv = srcFolder-&gt;MatchOrChangeFilterDestination(nullptr, false, &amp;match);</span>
<a href="#l20.10360"></a><span id="l20.10360" class="difflineminus">-        if (match)</span>
<a href="#l20.10361"></a><span id="l20.10361" class="difflineminus">-        {</span>
<a href="#l20.10362"></a><span id="l20.10362" class="difflineplus">+        if (match) {</span>
<a href="#l20.10363"></a><span id="l20.10363">           srcFolder-&gt;ConfirmFolderDeletionForFilter(msgWindow, &amp;confirmed);</span>
<a href="#l20.10364"></a><span id="l20.10364">           // should we return an error to copy service?</span>
<a href="#l20.10365"></a><span id="l20.10365">           // or send a notification?</span>
<a href="#l20.10366"></a><span id="l20.10366" class="difflineminus">-          if (!confirmed)</span>
<a href="#l20.10367"></a><span id="l20.10367" class="difflineminus">-            return NS_OK;</span>
<a href="#l20.10368"></a><span id="l20.10368" class="difflineplus">+          if (!confirmed) return NS_OK;</span>
<a href="#l20.10369"></a><span id="l20.10369">         }</span>
<a href="#l20.10370"></a><span id="l20.10370">       }</span>
<a href="#l20.10371"></a><span id="l20.10371" class="difflineminus">-      rv = InitCopyState(srcSupport, nullptr, false, false, false,</span>
<a href="#l20.10372"></a><span id="l20.10372" class="difflineminus">-                         0, EmptyCString(), listener, msgWindow, false);</span>
<a href="#l20.10373"></a><span id="l20.10373" class="difflineminus">-      if (NS_FAILED(rv))</span>
<a href="#l20.10374"></a><span id="l20.10374" class="difflineminus">-        return OnCopyCompleted(srcSupport, rv);</span>
<a href="#l20.10375"></a><span id="l20.10375" class="difflineminus">-</span>
<a href="#l20.10376"></a><span id="l20.10376" class="difflineminus">-      rv = imapService-&gt;MoveFolder(srcFolder,</span>
<a href="#l20.10377"></a><span id="l20.10377" class="difflineminus">-                                   this,</span>
<a href="#l20.10378"></a><span id="l20.10378" class="difflineminus">-                                   this,</span>
<a href="#l20.10379"></a><span id="l20.10379" class="difflineminus">-                                   msgWindow,</span>
<a href="#l20.10380"></a><span id="l20.10380" class="difflineminus">-                                   nullptr);</span>
<a href="#l20.10381"></a><span id="l20.10381" class="difflineminus">-    }</span>
<a href="#l20.10382"></a><span id="l20.10382" class="difflineminus">-  }</span>
<a href="#l20.10383"></a><span id="l20.10383" class="difflineminus">-  else // copying folder (should only be across server?)</span>
<a href="#l20.10384"></a><span id="l20.10384" class="difflineplus">+      rv = InitCopyState(srcSupport, nullptr, false, false, false, 0,</span>
<a href="#l20.10385"></a><span id="l20.10385" class="difflineplus">+                         EmptyCString(), listener, msgWindow, false);</span>
<a href="#l20.10386"></a><span id="l20.10386" class="difflineplus">+      if (NS_FAILED(rv)) return OnCopyCompleted(srcSupport, rv);</span>
<a href="#l20.10387"></a><span id="l20.10387" class="difflineplus">+</span>
<a href="#l20.10388"></a><span id="l20.10388" class="difflineplus">+      rv = imapService-&gt;MoveFolder(srcFolder, this, this, msgWindow, nullptr);</span>
<a href="#l20.10389"></a><span id="l20.10389" class="difflineplus">+    }</span>
<a href="#l20.10390"></a><span id="l20.10390" class="difflineplus">+  } else  // copying folder (should only be across server?)</span>
<a href="#l20.10391"></a><span id="l20.10391">   {</span>
<a href="#l20.10392"></a><span id="l20.10392" class="difflineminus">-    RefPtr&lt;nsImapFolderCopyState&gt; folderCopier =</span>
<a href="#l20.10393"></a><span id="l20.10393" class="difflineminus">-      new nsImapFolderCopyState(this, srcFolder, isMoveFolder, msgWindow, listener);</span>
<a href="#l20.10394"></a><span id="l20.10394" class="difflineplus">+    RefPtr&lt;nsImapFolderCopyState&gt; folderCopier = new nsImapFolderCopyState(</span>
<a href="#l20.10395"></a><span id="l20.10395" class="difflineplus">+        this, srcFolder, isMoveFolder, msgWindow, listener);</span>
<a href="#l20.10396"></a><span id="l20.10396">     return folderCopier-&gt;StartNextCopy();</span>
<a href="#l20.10397"></a><span id="l20.10397">   }</span>
<a href="#l20.10398"></a><span id="l20.10398">   return rv;</span>
<a href="#l20.10399"></a><span id="l20.10399"> }</span>
<a href="#l20.10400"></a><span id="l20.10400"> </span>
<a href="#l20.10401"></a><span id="l20.10401"> NS_IMETHODIMP</span>
<a href="#l20.10402"></a><span id="l20.10402" class="difflineminus">-nsImapMailFolder::CopyFileMessage(nsIFile* file,</span>
<a href="#l20.10403"></a><span id="l20.10403" class="difflineminus">-                                  nsIMsgDBHdr* msgToReplace,</span>
<a href="#l20.10404"></a><span id="l20.10404" class="difflineminus">-                                  bool isDraftOrTemplate,</span>
<a href="#l20.10405"></a><span id="l20.10405" class="difflineminus">-                                  uint32_t aNewMsgFlags,</span>
<a href="#l20.10406"></a><span id="l20.10406" class="difflineplus">+nsImapMailFolder::CopyFileMessage(nsIFile *file, nsIMsgDBHdr *msgToReplace,</span>
<a href="#l20.10407"></a><span id="l20.10407" class="difflineplus">+                                  bool isDraftOrTemplate, uint32_t aNewMsgFlags,</span>
<a href="#l20.10408"></a><span id="l20.10408">                                   const nsACString &amp;aNewMsgKeywords,</span>
<a href="#l20.10409"></a><span id="l20.10409">                                   nsIMsgWindow *msgWindow,</span>
<a href="#l20.10410"></a><span id="l20.10410" class="difflineminus">-                                  nsIMsgCopyServiceListener* listener)</span>
<a href="#l20.10411"></a><span id="l20.10411" class="difflineminus">-{</span>
<a href="#l20.10412"></a><span id="l20.10412" class="difflineminus">-    nsresult rv = NS_ERROR_NULL_POINTER;</span>
<a href="#l20.10413"></a><span id="l20.10413" class="difflineminus">-    nsMsgKey key = nsMsgKey_None;</span>
<a href="#l20.10414"></a><span id="l20.10414" class="difflineminus">-    nsAutoCString messageId;</span>
<a href="#l20.10415"></a><span id="l20.10415" class="difflineminus">-    nsCOMPtr&lt;nsIUrlListener&gt; urlListener;</span>
<a href="#l20.10416"></a><span id="l20.10416" class="difflineminus">-    nsCOMPtr&lt;nsIMutableArray&gt; messages(do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l20.10417"></a><span id="l20.10417" class="difflineminus">-    nsCOMPtr&lt;nsISupports&gt; srcSupport = do_QueryInterface(file, &amp;rv);</span>
<a href="#l20.10418"></a><span id="l20.10418" class="difflineminus">-</span>
<a href="#l20.10419"></a><span id="l20.10419" class="difflineminus">-    if (!messages)</span>
<a href="#l20.10420"></a><span id="l20.10420" class="difflineminus">-      return OnCopyCompleted(srcSupport, rv);</span>
<a href="#l20.10421"></a><span id="l20.10421" class="difflineminus">-</span>
<a href="#l20.10422"></a><span id="l20.10422" class="difflineminus">-    nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.10423"></a><span id="l20.10423" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l20.10424"></a><span id="l20.10424" class="difflineminus">-      return OnCopyCompleted(srcSupport, rv);</span>
<a href="#l20.10425"></a><span id="l20.10425" class="difflineminus">-</span>
<a href="#l20.10426"></a><span id="l20.10426" class="difflineminus">-    rv = QueryInterface(NS_GET_IID(nsIUrlListener), getter_AddRefs(urlListener));</span>
<a href="#l20.10427"></a><span id="l20.10427" class="difflineminus">-</span>
<a href="#l20.10428"></a><span id="l20.10428" class="difflineminus">-    if (msgToReplace)</span>
<a href="#l20.10429"></a><span id="l20.10429" class="difflineminus">-    {</span>
<a href="#l20.10430"></a><span id="l20.10430" class="difflineminus">-        rv = msgToReplace-&gt;GetMessageKey(&amp;key);</span>
<a href="#l20.10431"></a><span id="l20.10431" class="difflineminus">-        if (NS_SUCCEEDED(rv))</span>
<a href="#l20.10432"></a><span id="l20.10432" class="difflineminus">-        {</span>
<a href="#l20.10433"></a><span id="l20.10433" class="difflineminus">-          messageId.AppendInt((int32_t) key);</span>
<a href="#l20.10434"></a><span id="l20.10434" class="difflineminus">-          // Perhaps we have the message offline, but even if we do it is</span>
<a href="#l20.10435"></a><span id="l20.10435" class="difflineminus">-          // not valid, since the only time we do a file copy for an</span>
<a href="#l20.10436"></a><span id="l20.10436" class="difflineminus">-          // existing message is when we are changing the message.</span>
<a href="#l20.10437"></a><span id="l20.10437" class="difflineminus">-          // So set the offline size to 0 to force SetPendingAttributes to</span>
<a href="#l20.10438"></a><span id="l20.10438" class="difflineminus">-          // clear the offline message flag.</span>
<a href="#l20.10439"></a><span id="l20.10439" class="difflineminus">-          msgToReplace-&gt;SetOfflineMessageSize(0);</span>
<a href="#l20.10440"></a><span id="l20.10440" class="difflineminus">-          messages-&gt;AppendElement(msgToReplace);</span>
<a href="#l20.10441"></a><span id="l20.10441" class="difflineminus">-          SetPendingAttributes(messages, false, false);</span>
<a href="#l20.10442"></a><span id="l20.10442" class="difflineminus">-        }</span>
<a href="#l20.10443"></a><span id="l20.10443" class="difflineminus">-    }</span>
<a href="#l20.10444"></a><span id="l20.10444" class="difflineminus">-</span>
<a href="#l20.10445"></a><span id="l20.10445" class="difflineminus">-    bool isMove = (msgToReplace ? true : false);</span>
<a href="#l20.10446"></a><span id="l20.10446" class="difflineminus">-    rv = InitCopyState(srcSupport, messages, isMove, isDraftOrTemplate,</span>
<a href="#l20.10447"></a><span id="l20.10447" class="difflineminus">-                       false, aNewMsgFlags, aNewMsgKeywords, listener,</span>
<a href="#l20.10448"></a><span id="l20.10448" class="difflineminus">-                       msgWindow, false);</span>
<a href="#l20.10449"></a><span id="l20.10449" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l20.10450"></a><span id="l20.10450" class="difflineminus">-      return OnCopyCompleted(srcSupport, rv);</span>
<a href="#l20.10451"></a><span id="l20.10451" class="difflineminus">-</span>
<a href="#l20.10452"></a><span id="l20.10452" class="difflineminus">-    m_copyState-&gt;m_streamCopy = true;</span>
<a href="#l20.10453"></a><span id="l20.10453" class="difflineminus">-    nsCOMPtr&lt;nsISupports&gt; copySupport;</span>
<a href="#l20.10454"></a><span id="l20.10454" class="difflineminus">-    if( m_copyState )</span>
<a href="#l20.10455"></a><span id="l20.10455" class="difflineminus">-      copySupport = do_QueryInterface(m_copyState);</span>
<a href="#l20.10456"></a><span id="l20.10456" class="difflineminus">-    if (!isDraftOrTemplate)</span>
<a href="#l20.10457"></a><span id="l20.10457" class="difflineminus">-    {</span>
<a href="#l20.10458"></a><span id="l20.10458" class="difflineminus">-      m_copyState-&gt;m_totalCount = 1;</span>
<a href="#l20.10459"></a><span id="l20.10459" class="difflineminus">-      // This makes the IMAP APPEND set the INTERNALDATE for the msg copy</span>
<a href="#l20.10460"></a><span id="l20.10460" class="difflineminus">-      // we make when detaching/deleting attachments to the original msg date.</span>
<a href="#l20.10461"></a><span id="l20.10461" class="difflineminus">-      m_copyState-&gt;m_message = msgToReplace;</span>
<a href="#l20.10462"></a><span id="l20.10462" class="difflineminus">-    }</span>
<a href="#l20.10463"></a><span id="l20.10463" class="difflineminus">-    rv = imapService-&gt;AppendMessageFromFile(file, this, messageId,</span>
<a href="#l20.10464"></a><span id="l20.10464" class="difflineminus">-                                            true, isDraftOrTemplate,</span>
<a href="#l20.10465"></a><span id="l20.10465" class="difflineminus">-                                            urlListener, nullptr,</span>
<a href="#l20.10466"></a><span id="l20.10466" class="difflineminus">-                                            copySupport,</span>
<a href="#l20.10467"></a><span id="l20.10467" class="difflineminus">-                                            msgWindow);</span>
<a href="#l20.10468"></a><span id="l20.10468" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l20.10469"></a><span id="l20.10469" class="difflineminus">-      return OnCopyCompleted(srcSupport, rv);</span>
<a href="#l20.10470"></a><span id="l20.10470" class="difflineminus">-</span>
<a href="#l20.10471"></a><span id="l20.10471" class="difflineminus">-    return rv;</span>
<a href="#l20.10472"></a><span id="l20.10472" class="difflineminus">-}</span>
<a href="#l20.10473"></a><span id="l20.10473" class="difflineminus">-</span>
<a href="#l20.10474"></a><span id="l20.10474" class="difflineminus">-nsresult</span>
<a href="#l20.10475"></a><span id="l20.10475" class="difflineminus">-nsImapMailFolder::CopyStreamMessage(nsIMsgDBHdr* message,</span>
<a href="#l20.10476"></a><span id="l20.10476" class="difflineminus">-                                    nsIMsgFolder* dstFolder, // should be this</span>
<a href="#l20.10477"></a><span id="l20.10477" class="difflineminus">-                                    nsIMsgWindow *aMsgWindow,</span>
<a href="#l20.10478"></a><span id="l20.10478" class="difflineminus">-                                    bool isMove)</span>
<a href="#l20.10479"></a><span id="l20.10479" class="difflineminus">-{</span>
<a href="#l20.10480"></a><span id="l20.10480" class="difflineplus">+                                  nsIMsgCopyServiceListener *listener) {</span>
<a href="#l20.10481"></a><span id="l20.10481" class="difflineplus">+  nsresult rv = NS_ERROR_NULL_POINTER;</span>
<a href="#l20.10482"></a><span id="l20.10482" class="difflineplus">+  nsMsgKey key = nsMsgKey_None;</span>
<a href="#l20.10483"></a><span id="l20.10483" class="difflineplus">+  nsAutoCString messageId;</span>
<a href="#l20.10484"></a><span id="l20.10484" class="difflineplus">+  nsCOMPtr&lt;nsIUrlListener&gt; urlListener;</span>
<a href="#l20.10485"></a><span id="l20.10485" class="difflineplus">+  nsCOMPtr&lt;nsIMutableArray&gt; messages(do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l20.10486"></a><span id="l20.10486" class="difflineplus">+  nsCOMPtr&lt;nsISupports&gt; srcSupport = do_QueryInterface(file, &amp;rv);</span>
<a href="#l20.10487"></a><span id="l20.10487" class="difflineplus">+</span>
<a href="#l20.10488"></a><span id="l20.10488" class="difflineplus">+  if (!messages) return OnCopyCompleted(srcSupport, rv);</span>
<a href="#l20.10489"></a><span id="l20.10489" class="difflineplus">+</span>
<a href="#l20.10490"></a><span id="l20.10490" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.10491"></a><span id="l20.10491" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.10492"></a><span id="l20.10492" class="difflineplus">+  if (NS_FAILED(rv)) return OnCopyCompleted(srcSupport, rv);</span>
<a href="#l20.10493"></a><span id="l20.10493" class="difflineplus">+</span>
<a href="#l20.10494"></a><span id="l20.10494" class="difflineplus">+  rv = QueryInterface(NS_GET_IID(nsIUrlListener), getter_AddRefs(urlListener));</span>
<a href="#l20.10495"></a><span id="l20.10495" class="difflineplus">+</span>
<a href="#l20.10496"></a><span id="l20.10496" class="difflineplus">+  if (msgToReplace) {</span>
<a href="#l20.10497"></a><span id="l20.10497" class="difflineplus">+    rv = msgToReplace-&gt;GetMessageKey(&amp;key);</span>
<a href="#l20.10498"></a><span id="l20.10498" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.10499"></a><span id="l20.10499" class="difflineplus">+      messageId.AppendInt((int32_t)key);</span>
<a href="#l20.10500"></a><span id="l20.10500" class="difflineplus">+      // Perhaps we have the message offline, but even if we do it is</span>
<a href="#l20.10501"></a><span id="l20.10501" class="difflineplus">+      // not valid, since the only time we do a file copy for an</span>
<a href="#l20.10502"></a><span id="l20.10502" class="difflineplus">+      // existing message is when we are changing the message.</span>
<a href="#l20.10503"></a><span id="l20.10503" class="difflineplus">+      // So set the offline size to 0 to force SetPendingAttributes to</span>
<a href="#l20.10504"></a><span id="l20.10504" class="difflineplus">+      // clear the offline message flag.</span>
<a href="#l20.10505"></a><span id="l20.10505" class="difflineplus">+      msgToReplace-&gt;SetOfflineMessageSize(0);</span>
<a href="#l20.10506"></a><span id="l20.10506" class="difflineplus">+      messages-&gt;AppendElement(msgToReplace);</span>
<a href="#l20.10507"></a><span id="l20.10507" class="difflineplus">+      SetPendingAttributes(messages, false, false);</span>
<a href="#l20.10508"></a><span id="l20.10508" class="difflineplus">+    }</span>
<a href="#l20.10509"></a><span id="l20.10509" class="difflineplus">+  }</span>
<a href="#l20.10510"></a><span id="l20.10510" class="difflineplus">+</span>
<a href="#l20.10511"></a><span id="l20.10511" class="difflineplus">+  bool isMove = (msgToReplace ? true : false);</span>
<a href="#l20.10512"></a><span id="l20.10512" class="difflineplus">+  rv = InitCopyState(srcSupport, messages, isMove, isDraftOrTemplate, false,</span>
<a href="#l20.10513"></a><span id="l20.10513" class="difflineplus">+                     aNewMsgFlags, aNewMsgKeywords, listener, msgWindow, false);</span>
<a href="#l20.10514"></a><span id="l20.10514" class="difflineplus">+  if (NS_FAILED(rv)) return OnCopyCompleted(srcSupport, rv);</span>
<a href="#l20.10515"></a><span id="l20.10515" class="difflineplus">+</span>
<a href="#l20.10516"></a><span id="l20.10516" class="difflineplus">+  m_copyState-&gt;m_streamCopy = true;</span>
<a href="#l20.10517"></a><span id="l20.10517" class="difflineplus">+  nsCOMPtr&lt;nsISupports&gt; copySupport;</span>
<a href="#l20.10518"></a><span id="l20.10518" class="difflineplus">+  if (m_copyState) copySupport = do_QueryInterface(m_copyState);</span>
<a href="#l20.10519"></a><span id="l20.10519" class="difflineplus">+  if (!isDraftOrTemplate) {</span>
<a href="#l20.10520"></a><span id="l20.10520" class="difflineplus">+    m_copyState-&gt;m_totalCount = 1;</span>
<a href="#l20.10521"></a><span id="l20.10521" class="difflineplus">+    // This makes the IMAP APPEND set the INTERNALDATE for the msg copy</span>
<a href="#l20.10522"></a><span id="l20.10522" class="difflineplus">+    // we make when detaching/deleting attachments to the original msg date.</span>
<a href="#l20.10523"></a><span id="l20.10523" class="difflineplus">+    m_copyState-&gt;m_message = msgToReplace;</span>
<a href="#l20.10524"></a><span id="l20.10524" class="difflineplus">+  }</span>
<a href="#l20.10525"></a><span id="l20.10525" class="difflineplus">+  rv = imapService-&gt;AppendMessageFromFile(file, this, messageId, true,</span>
<a href="#l20.10526"></a><span id="l20.10526" class="difflineplus">+                                          isDraftOrTemplate, urlListener,</span>
<a href="#l20.10527"></a><span id="l20.10527" class="difflineplus">+                                          nullptr, copySupport, msgWindow);</span>
<a href="#l20.10528"></a><span id="l20.10528" class="difflineplus">+  if (NS_FAILED(rv)) return OnCopyCompleted(srcSupport, rv);</span>
<a href="#l20.10529"></a><span id="l20.10529" class="difflineplus">+</span>
<a href="#l20.10530"></a><span id="l20.10530" class="difflineplus">+  return rv;</span>
<a href="#l20.10531"></a><span id="l20.10531" class="difflineplus">+}</span>
<a href="#l20.10532"></a><span id="l20.10532" class="difflineplus">+</span>
<a href="#l20.10533"></a><span id="l20.10533" class="difflineplus">+nsresult nsImapMailFolder::CopyStreamMessage(</span>
<a href="#l20.10534"></a><span id="l20.10534" class="difflineplus">+    nsIMsgDBHdr *message,</span>
<a href="#l20.10535"></a><span id="l20.10535" class="difflineplus">+    nsIMsgFolder *dstFolder,  // should be this</span>
<a href="#l20.10536"></a><span id="l20.10536" class="difflineplus">+    nsIMsgWindow *aMsgWindow, bool isMove) {</span>
<a href="#l20.10537"></a><span id="l20.10537">   NS_ENSURE_ARG_POINTER(message);</span>
<a href="#l20.10538"></a><span id="l20.10538">   if (!m_copyState)</span>
<a href="#l20.10539"></a><span id="l20.10539" class="difflineminus">-    MOZ_LOG(IMAP, mozilla::LogLevel::Info, (&quot;CopyStreamMessage failed with null m_copyState&quot;));</span>
<a href="#l20.10540"></a><span id="l20.10540" class="difflineplus">+    MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l20.10541"></a><span id="l20.10541" class="difflineplus">+            (&quot;CopyStreamMessage failed with null m_copyState&quot;));</span>
<a href="#l20.10542"></a><span id="l20.10542">   NS_ENSURE_TRUE(m_copyState, NS_ERROR_NULL_POINTER);</span>
<a href="#l20.10543"></a><span id="l20.10543">   nsresult rv;</span>
<a href="#l20.10544"></a><span id="l20.10544" class="difflineminus">-  nsCOMPtr&lt;nsICopyMessageStreamListener&gt; copyStreamListener = do_CreateInstance(NS_COPYMESSAGESTREAMLISTENER_CONTRACTID, &amp;rv);</span>
<a href="#l20.10545"></a><span id="l20.10545" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.10546"></a><span id="l20.10546" class="difflineminus">-</span>
<a href="#l20.10547"></a><span id="l20.10547" class="difflineminus">-  nsCOMPtr&lt;nsICopyMessageListener&gt; copyListener(do_QueryInterface(dstFolder, &amp;rv));</span>
<a href="#l20.10548"></a><span id="l20.10548" class="difflineplus">+  nsCOMPtr&lt;nsICopyMessageStreamListener&gt; copyStreamListener =</span>
<a href="#l20.10549"></a><span id="l20.10549" class="difflineplus">+      do_CreateInstance(NS_COPYMESSAGESTREAMLISTENER_CONTRACTID, &amp;rv);</span>
<a href="#l20.10550"></a><span id="l20.10550" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10551"></a><span id="l20.10551" class="difflineplus">+</span>
<a href="#l20.10552"></a><span id="l20.10552" class="difflineplus">+  nsCOMPtr&lt;nsICopyMessageListener&gt; copyListener(</span>
<a href="#l20.10553"></a><span id="l20.10553" class="difflineplus">+      do_QueryInterface(dstFolder, &amp;rv));</span>
<a href="#l20.10554"></a><span id="l20.10554">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10555"></a><span id="l20.10555"> </span>
<a href="#l20.10556"></a><span id="l20.10556" class="difflineminus">-  nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder(do_QueryInterface(m_copyState-&gt;m_srcSupport, &amp;rv));</span>
<a href="#l20.10557"></a><span id="l20.10557" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder(</span>
<a href="#l20.10558"></a><span id="l20.10558" class="difflineplus">+      do_QueryInterface(m_copyState-&gt;m_srcSupport, &amp;rv));</span>
<a href="#l20.10559"></a><span id="l20.10559">   if (NS_FAILED(rv))</span>
<a href="#l20.10560"></a><span id="l20.10560" class="difflineminus">-    MOZ_LOG(IMAP, mozilla::LogLevel::Info, (&quot;CopyStreaMessage failed with null m_copyState-&gt;m_srcSupport&quot;));</span>
<a href="#l20.10561"></a><span id="l20.10561" class="difflineplus">+    MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l20.10562"></a><span id="l20.10562" class="difflineplus">+            (&quot;CopyStreaMessage failed with null m_copyState-&gt;m_srcSupport&quot;));</span>
<a href="#l20.10563"></a><span id="l20.10563">   if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.10564"></a><span id="l20.10564">   rv = copyStreamListener-&gt;Init(srcFolder, copyListener, nullptr);</span>
<a href="#l20.10565"></a><span id="l20.10565">   if (NS_FAILED(rv))</span>
<a href="#l20.10566"></a><span id="l20.10566" class="difflineminus">-    MOZ_LOG(IMAP, mozilla::LogLevel::Info, (&quot;CopyStreaMessage failed in copyStreamListener-&gt;Init&quot;));</span>
<a href="#l20.10567"></a><span id="l20.10567" class="difflineplus">+    MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l20.10568"></a><span id="l20.10568" class="difflineplus">+            (&quot;CopyStreaMessage failed in copyStreamListener-&gt;Init&quot;));</span>
<a href="#l20.10569"></a><span id="l20.10569">   if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.10570"></a><span id="l20.10570"> </span>
<a href="#l20.10571"></a><span id="l20.10571">   nsCString uri;</span>
<a href="#l20.10572"></a><span id="l20.10572">   srcFolder-&gt;GetUriForMsg(message, uri);</span>
<a href="#l20.10573"></a><span id="l20.10573"> </span>
<a href="#l20.10574"></a><span id="l20.10574">   if (!m_copyState-&gt;m_msgService)</span>
<a href="#l20.10575"></a><span id="l20.10575" class="difflineminus">-    rv = GetMessageServiceFromURI(uri, getter_AddRefs(m_copyState-&gt;m_msgService));</span>
<a href="#l20.10576"></a><span id="l20.10576" class="difflineminus">-</span>
<a href="#l20.10577"></a><span id="l20.10577" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; m_copyState-&gt;m_msgService)</span>
<a href="#l20.10578"></a><span id="l20.10578" class="difflineminus">-  {</span>
<a href="#l20.10579"></a><span id="l20.10579" class="difflineminus">-    nsCOMPtr&lt;nsIStreamListener&gt; streamListener(do_QueryInterface(copyStreamListener, &amp;rv));</span>
<a href="#l20.10580"></a><span id="l20.10580" class="difflineplus">+    rv = GetMessageServiceFromURI(uri,</span>
<a href="#l20.10581"></a><span id="l20.10581" class="difflineplus">+                                  getter_AddRefs(m_copyState-&gt;m_msgService));</span>
<a href="#l20.10582"></a><span id="l20.10582" class="difflineplus">+</span>
<a href="#l20.10583"></a><span id="l20.10583" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; m_copyState-&gt;m_msgService) {</span>
<a href="#l20.10584"></a><span id="l20.10584" class="difflineplus">+    nsCOMPtr&lt;nsIStreamListener&gt; streamListener(</span>
<a href="#l20.10585"></a><span id="l20.10585" class="difflineplus">+        do_QueryInterface(copyStreamListener, &amp;rv));</span>
<a href="#l20.10586"></a><span id="l20.10586">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10587"></a><span id="l20.10587"> </span>
<a href="#l20.10588"></a><span id="l20.10588">     // put up status message here, if copying more than one message.</span>
<a href="#l20.10589"></a><span id="l20.10589" class="difflineminus">-    if (m_copyState-&gt;m_totalCount &gt; 1)</span>
<a href="#l20.10590"></a><span id="l20.10590" class="difflineminus">-    {</span>
<a href="#l20.10591"></a><span id="l20.10591" class="difflineplus">+    if (m_copyState-&gt;m_totalCount &gt; 1) {</span>
<a href="#l20.10592"></a><span id="l20.10592">       nsString dstFolderName, progressText;</span>
<a href="#l20.10593"></a><span id="l20.10593">       GetName(dstFolderName);</span>
<a href="#l20.10594"></a><span id="l20.10594">       nsAutoString curMsgString;</span>
<a href="#l20.10595"></a><span id="l20.10595">       nsAutoString totalMsgString;</span>
<a href="#l20.10596"></a><span id="l20.10596">       totalMsgString.AppendInt(m_copyState-&gt;m_totalCount);</span>
<a href="#l20.10597"></a><span id="l20.10597">       curMsgString.AppendInt(m_copyState-&gt;m_curIndex + 1);</span>
<a href="#l20.10598"></a><span id="l20.10598"> </span>
<a href="#l20.10599"></a><span id="l20.10599" class="difflineminus">-      const char16_t *formatStrings[3] = {curMsgString.get(),</span>
<a href="#l20.10600"></a><span id="l20.10600" class="difflineminus">-                                            totalMsgString.get(),</span>
<a href="#l20.10601"></a><span id="l20.10601" class="difflineminus">-                                            dstFolderName.get()</span>
<a href="#l20.10602"></a><span id="l20.10602" class="difflineminus">-                                            };</span>
<a href="#l20.10603"></a><span id="l20.10603" class="difflineminus">-</span>
<a href="#l20.10604"></a><span id="l20.10604" class="difflineminus">-      nsCOMPtr &lt;nsIStringBundle&gt; bundle;</span>
<a href="#l20.10605"></a><span id="l20.10605" class="difflineplus">+      const char16_t *formatStrings[3] = {</span>
<a href="#l20.10606"></a><span id="l20.10606" class="difflineplus">+          curMsgString.get(), totalMsgString.get(), dstFolderName.get()};</span>
<a href="#l20.10607"></a><span id="l20.10607" class="difflineplus">+</span>
<a href="#l20.10608"></a><span id="l20.10608" class="difflineplus">+      nsCOMPtr&lt;nsIStringBundle&gt; bundle;</span>
<a href="#l20.10609"></a><span id="l20.10609">       rv = IMAPGetStringBundle(getter_AddRefs(bundle));</span>
<a href="#l20.10610"></a><span id="l20.10610">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10611"></a><span id="l20.10611" class="difflineminus">-      rv = bundle-&gt;FormatStringFromName(</span>
<a href="#l20.10612"></a><span id="l20.10612" class="difflineminus">-        &quot;imapCopyingMessageOf2&quot;,</span>
<a href="#l20.10613"></a><span id="l20.10613" class="difflineminus">-        formatStrings, 3, progressText);</span>
<a href="#l20.10614"></a><span id="l20.10614" class="difflineminus">-      nsCOMPtr &lt;nsIMsgStatusFeedback&gt; statusFeedback;</span>
<a href="#l20.10615"></a><span id="l20.10615" class="difflineplus">+      rv = bundle-&gt;FormatStringFromName(&quot;imapCopyingMessageOf2&quot;, formatStrings,</span>
<a href="#l20.10616"></a><span id="l20.10616" class="difflineplus">+                                        3, progressText);</span>
<a href="#l20.10617"></a><span id="l20.10617" class="difflineplus">+      nsCOMPtr&lt;nsIMsgStatusFeedback&gt; statusFeedback;</span>
<a href="#l20.10618"></a><span id="l20.10618">       if (m_copyState-&gt;m_msgWindow)</span>
<a href="#l20.10619"></a><span id="l20.10619" class="difflineminus">-        m_copyState-&gt;m_msgWindow-&gt;GetStatusFeedback(getter_AddRefs(statusFeedback));</span>
<a href="#l20.10620"></a><span id="l20.10620" class="difflineminus">-      if (statusFeedback)</span>
<a href="#l20.10621"></a><span id="l20.10621" class="difflineminus">-      {</span>
<a href="#l20.10622"></a><span id="l20.10622" class="difflineplus">+        m_copyState-&gt;m_msgWindow-&gt;GetStatusFeedback(</span>
<a href="#l20.10623"></a><span id="l20.10623" class="difflineplus">+            getter_AddRefs(statusFeedback));</span>
<a href="#l20.10624"></a><span id="l20.10624" class="difflineplus">+      if (statusFeedback) {</span>
<a href="#l20.10625"></a><span id="l20.10625">         statusFeedback-&gt;ShowStatusString(progressText);</span>
<a href="#l20.10626"></a><span id="l20.10626">         int32_t percent;</span>
<a href="#l20.10627"></a><span id="l20.10627" class="difflineminus">-        percent = (100 * m_copyState-&gt;m_curIndex) / (int32_t) m_copyState-&gt;m_totalCount;</span>
<a href="#l20.10628"></a><span id="l20.10628" class="difflineminus">-          statusFeedback-&gt;ShowProgress(percent);</span>
<a href="#l20.10629"></a><span id="l20.10629" class="difflineplus">+        percent = (100 * m_copyState-&gt;m_curIndex) /</span>
<a href="#l20.10630"></a><span id="l20.10630" class="difflineplus">+                  (int32_t)m_copyState-&gt;m_totalCount;</span>
<a href="#l20.10631"></a><span id="l20.10631" class="difflineplus">+        statusFeedback-&gt;ShowProgress(percent);</span>
<a href="#l20.10632"></a><span id="l20.10632">       }</span>
<a href="#l20.10633"></a><span id="l20.10633">     }</span>
<a href="#l20.10634"></a><span id="l20.10634">     nsCOMPtr&lt;nsIURI&gt; dummyNull;</span>
<a href="#l20.10635"></a><span id="l20.10635" class="difflineminus">-    rv = m_copyState-&gt;m_msgService-&gt;CopyMessage(uri.get(), streamListener,</span>
<a href="#l20.10636"></a><span id="l20.10636" class="difflineminus">-                                                isMove &amp;&amp; !m_copyState-&gt;m_isCrossServerOp, nullptr, aMsgWindow,</span>
<a href="#l20.10637"></a><span id="l20.10637" class="difflineminus">-                                                getter_AddRefs(dummyNull));</span>
<a href="#l20.10638"></a><span id="l20.10638" class="difflineplus">+    rv = m_copyState-&gt;m_msgService-&gt;CopyMessage(</span>
<a href="#l20.10639"></a><span id="l20.10639" class="difflineplus">+        uri.get(), streamListener, isMove &amp;&amp; !m_copyState-&gt;m_isCrossServerOp,</span>
<a href="#l20.10640"></a><span id="l20.10640" class="difflineplus">+        nullptr, aMsgWindow, getter_AddRefs(dummyNull));</span>
<a href="#l20.10641"></a><span id="l20.10641">     if (NS_FAILED(rv))</span>
<a href="#l20.10642"></a><span id="l20.10642" class="difflineminus">-      MOZ_LOG(IMAP, mozilla::LogLevel::Info, (&quot;CopyMessage failed: uri %s&quot;, uri.get()));</span>
<a href="#l20.10643"></a><span id="l20.10643" class="difflineplus">+      MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l20.10644"></a><span id="l20.10644" class="difflineplus">+              (&quot;CopyMessage failed: uri %s&quot;, uri.get()));</span>
<a href="#l20.10645"></a><span id="l20.10645">   }</span>
<a href="#l20.10646"></a><span id="l20.10646">   return rv;</span>
<a href="#l20.10647"></a><span id="l20.10647"> }</span>
<a href="#l20.10648"></a><span id="l20.10648"> </span>
<a href="#l20.10649"></a><span id="l20.10649" class="difflineminus">-nsImapMailCopyState::nsImapMailCopyState() :</span>
<a href="#l20.10650"></a><span id="l20.10650" class="difflineminus">-    m_isMove(false), m_selectedState(false),</span>
<a href="#l20.10651"></a><span id="l20.10651" class="difflineminus">-    m_isCrossServerOp(false), m_curIndex(0),</span>
<a href="#l20.10652"></a><span id="l20.10652" class="difflineminus">-    m_totalCount(0), m_streamCopy(false), m_dataBuffer(nullptr),</span>
<a href="#l20.10653"></a><span id="l20.10653" class="difflineminus">-    m_dataBufferSize(0), m_leftOver(0), m_allowUndo(false),</span>
<a href="#l20.10654"></a><span id="l20.10654" class="difflineminus">-    m_eatLF(false), m_newMsgFlags(0), m_appendUID(nsMsgKey_None)</span>
<a href="#l20.10655"></a><span id="l20.10655" class="difflineminus">-{</span>
<a href="#l20.10656"></a><span id="l20.10656" class="difflineminus">-}</span>
<a href="#l20.10657"></a><span id="l20.10657" class="difflineminus">-</span>
<a href="#l20.10658"></a><span id="l20.10658" class="difflineminus">-nsImapMailCopyState::~nsImapMailCopyState()</span>
<a href="#l20.10659"></a><span id="l20.10659" class="difflineminus">-{</span>
<a href="#l20.10660"></a><span id="l20.10660" class="difflineplus">+nsImapMailCopyState::nsImapMailCopyState()</span>
<a href="#l20.10661"></a><span id="l20.10661" class="difflineplus">+    : m_isMove(false),</span>
<a href="#l20.10662"></a><span id="l20.10662" class="difflineplus">+      m_selectedState(false),</span>
<a href="#l20.10663"></a><span id="l20.10663" class="difflineplus">+      m_isCrossServerOp(false),</span>
<a href="#l20.10664"></a><span id="l20.10664" class="difflineplus">+      m_curIndex(0),</span>
<a href="#l20.10665"></a><span id="l20.10665" class="difflineplus">+      m_totalCount(0),</span>
<a href="#l20.10666"></a><span id="l20.10666" class="difflineplus">+      m_streamCopy(false),</span>
<a href="#l20.10667"></a><span id="l20.10667" class="difflineplus">+      m_dataBuffer(nullptr),</span>
<a href="#l20.10668"></a><span id="l20.10668" class="difflineplus">+      m_dataBufferSize(0),</span>
<a href="#l20.10669"></a><span id="l20.10669" class="difflineplus">+      m_leftOver(0),</span>
<a href="#l20.10670"></a><span id="l20.10670" class="difflineplus">+      m_allowUndo(false),</span>
<a href="#l20.10671"></a><span id="l20.10671" class="difflineplus">+      m_eatLF(false),</span>
<a href="#l20.10672"></a><span id="l20.10672" class="difflineplus">+      m_newMsgFlags(0),</span>
<a href="#l20.10673"></a><span id="l20.10673" class="difflineplus">+      m_appendUID(nsMsgKey_None) {}</span>
<a href="#l20.10674"></a><span id="l20.10674" class="difflineplus">+</span>
<a href="#l20.10675"></a><span id="l20.10675" class="difflineplus">+nsImapMailCopyState::~nsImapMailCopyState() {</span>
<a href="#l20.10676"></a><span id="l20.10676">   PR_Free(m_dataBuffer);</span>
<a href="#l20.10677"></a><span id="l20.10677" class="difflineminus">-  if (m_msgService &amp;&amp; m_message)</span>
<a href="#l20.10678"></a><span id="l20.10678" class="difflineminus">-  {</span>
<a href="#l20.10679"></a><span id="l20.10679" class="difflineminus">-    nsCOMPtr &lt;nsIMsgFolder&gt; srcFolder = do_QueryInterface(m_srcSupport);</span>
<a href="#l20.10680"></a><span id="l20.10680" class="difflineminus">-    if (srcFolder)</span>
<a href="#l20.10681"></a><span id="l20.10681" class="difflineminus">-    {</span>
<a href="#l20.10682"></a><span id="l20.10682" class="difflineplus">+  if (m_msgService &amp;&amp; m_message) {</span>
<a href="#l20.10683"></a><span id="l20.10683" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder = do_QueryInterface(m_srcSupport);</span>
<a href="#l20.10684"></a><span id="l20.10684" class="difflineplus">+    if (srcFolder) {</span>
<a href="#l20.10685"></a><span id="l20.10685">       nsCString uri;</span>
<a href="#l20.10686"></a><span id="l20.10686">       srcFolder-&gt;GetUriForMsg(m_message, uri);</span>
<a href="#l20.10687"></a><span id="l20.10687">     }</span>
<a href="#l20.10688"></a><span id="l20.10688">   }</span>
<a href="#l20.10689"></a><span id="l20.10689" class="difflineminus">-  if (m_tmpFile)</span>
<a href="#l20.10690"></a><span id="l20.10690" class="difflineminus">-    m_tmpFile-&gt;Remove(false);</span>
<a href="#l20.10691"></a><span id="l20.10691" class="difflineminus">-}</span>
<a href="#l20.10692"></a><span id="l20.10692" class="difflineminus">-</span>
<a href="#l20.10693"></a><span id="l20.10693" class="difflineplus">+  if (m_tmpFile) m_tmpFile-&gt;Remove(false);</span>
<a href="#l20.10694"></a><span id="l20.10694" class="difflineplus">+}</span>
<a href="#l20.10695"></a><span id="l20.10695"> </span>
<a href="#l20.10696"></a><span id="l20.10696"> NS_IMPL_ISUPPORTS(nsImapMailCopyState, nsImapMailCopyState)</span>
<a href="#l20.10697"></a><span id="l20.10697"> </span>
<a href="#l20.10698"></a><span id="l20.10698" class="difflineminus">-nsresult</span>
<a href="#l20.10699"></a><span id="l20.10699" class="difflineminus">-nsImapMailFolder::InitCopyState(nsISupports* srcSupport,</span>
<a href="#l20.10700"></a><span id="l20.10700" class="difflineminus">-                                nsIArray* messages,</span>
<a href="#l20.10701"></a><span id="l20.10701" class="difflineminus">-                                bool isMove,</span>
<a href="#l20.10702"></a><span id="l20.10702" class="difflineminus">-                                bool selectedState,</span>
<a href="#l20.10703"></a><span id="l20.10703" class="difflineminus">-                                bool acrossServers,</span>
<a href="#l20.10704"></a><span id="l20.10704" class="difflineminus">-                                uint32_t newMsgFlags,</span>
<a href="#l20.10705"></a><span id="l20.10705" class="difflineminus">-                                const nsACString &amp;newMsgKeywords,</span>
<a href="#l20.10706"></a><span id="l20.10706" class="difflineminus">-                                nsIMsgCopyServiceListener* listener,</span>
<a href="#l20.10707"></a><span id="l20.10707" class="difflineminus">-                                nsIMsgWindow *msgWindow,</span>
<a href="#l20.10708"></a><span id="l20.10708" class="difflineminus">-                                bool allowUndo)</span>
<a href="#l20.10709"></a><span id="l20.10709" class="difflineminus">-{</span>
<a href="#l20.10710"></a><span id="l20.10710" class="difflineplus">+nsresult nsImapMailFolder::InitCopyState(</span>
<a href="#l20.10711"></a><span id="l20.10711" class="difflineplus">+    nsISupports *srcSupport, nsIArray *messages, bool isMove,</span>
<a href="#l20.10712"></a><span id="l20.10712" class="difflineplus">+    bool selectedState, bool acrossServers, uint32_t newMsgFlags,</span>
<a href="#l20.10713"></a><span id="l20.10713" class="difflineplus">+    const nsACString &amp;newMsgKeywords, nsIMsgCopyServiceListener *listener,</span>
<a href="#l20.10714"></a><span id="l20.10714" class="difflineplus">+    nsIMsgWindow *msgWindow, bool allowUndo) {</span>
<a href="#l20.10715"></a><span id="l20.10715">   NS_ENSURE_ARG_POINTER(srcSupport);</span>
<a href="#l20.10716"></a><span id="l20.10716">   NS_ENSURE_TRUE(!m_copyState, NS_ERROR_FAILURE);</span>
<a href="#l20.10717"></a><span id="l20.10717">   nsresult rv;</span>
<a href="#l20.10718"></a><span id="l20.10718"> </span>
<a href="#l20.10719"></a><span id="l20.10719">   m_copyState = new nsImapMailCopyState();</span>
<a href="#l20.10720"></a><span id="l20.10720" class="difflineminus">-  NS_ENSURE_TRUE(m_copyState,NS_ERROR_OUT_OF_MEMORY);</span>
<a href="#l20.10721"></a><span id="l20.10721" class="difflineplus">+  NS_ENSURE_TRUE(m_copyState, NS_ERROR_OUT_OF_MEMORY);</span>
<a href="#l20.10722"></a><span id="l20.10722"> </span>
<a href="#l20.10723"></a><span id="l20.10723">   m_copyState-&gt;m_isCrossServerOp = acrossServers;</span>
<a href="#l20.10724"></a><span id="l20.10724">   m_copyState-&gt;m_srcSupport = do_QueryInterface(srcSupport, &amp;rv);</span>
<a href="#l20.10725"></a><span id="l20.10725">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10726"></a><span id="l20.10726"> </span>
<a href="#l20.10727"></a><span id="l20.10727">   m_copyState-&gt;m_messages = messages;</span>
<a href="#l20.10728"></a><span id="l20.10728" class="difflineminus">-  if (messages)</span>
<a href="#l20.10729"></a><span id="l20.10729" class="difflineminus">-    rv = messages-&gt;GetLength(&amp;m_copyState-&gt;m_totalCount);</span>
<a href="#l20.10730"></a><span id="l20.10730" class="difflineminus">-  if (!m_copyState-&gt;m_isCrossServerOp)</span>
<a href="#l20.10731"></a><span id="l20.10731" class="difflineminus">-  {</span>
<a href="#l20.10732"></a><span id="l20.10732" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l20.10733"></a><span id="l20.10733" class="difflineminus">-    {</span>
<a href="#l20.10734"></a><span id="l20.10734" class="difflineminus">-        uint32_t numUnread = 0;</span>
<a href="#l20.10735"></a><span id="l20.10735" class="difflineminus">-        for (uint32_t keyIndex=0; keyIndex &lt; m_copyState-&gt;m_totalCount; keyIndex++)</span>
<a href="#l20.10736"></a><span id="l20.10736" class="difflineminus">-        {</span>
<a href="#l20.10737"></a><span id="l20.10737" class="difflineminus">-          nsCOMPtr&lt;nsIMsgDBHdr&gt; message = do_QueryElementAt(m_copyState-&gt;m_messages, keyIndex, &amp;rv);</span>
<a href="#l20.10738"></a><span id="l20.10738" class="difflineminus">-          // if the key is not there, then assume what the caller tells us to.</span>
<a href="#l20.10739"></a><span id="l20.10739" class="difflineminus">-          bool isRead = false;</span>
<a href="#l20.10740"></a><span id="l20.10740" class="difflineminus">-          uint32_t flags;</span>
<a href="#l20.10741"></a><span id="l20.10741" class="difflineminus">-          if (message )</span>
<a href="#l20.10742"></a><span id="l20.10742" class="difflineminus">-          {</span>
<a href="#l20.10743"></a><span id="l20.10743" class="difflineminus">-            message-&gt;GetFlags(&amp;flags);</span>
<a href="#l20.10744"></a><span id="l20.10744" class="difflineminus">-            isRead = flags &amp; nsMsgMessageFlags::Read;</span>
<a href="#l20.10745"></a><span id="l20.10745" class="difflineminus">-          }</span>
<a href="#l20.10746"></a><span id="l20.10746" class="difflineminus">-          if (!isRead)</span>
<a href="#l20.10747"></a><span id="l20.10747" class="difflineminus">-            numUnread++;</span>
<a href="#l20.10748"></a><span id="l20.10748" class="difflineplus">+  if (messages) rv = messages-&gt;GetLength(&amp;m_copyState-&gt;m_totalCount);</span>
<a href="#l20.10749"></a><span id="l20.10749" class="difflineplus">+  if (!m_copyState-&gt;m_isCrossServerOp) {</span>
<a href="#l20.10750"></a><span id="l20.10750" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.10751"></a><span id="l20.10751" class="difflineplus">+      uint32_t numUnread = 0;</span>
<a href="#l20.10752"></a><span id="l20.10752" class="difflineplus">+      for (uint32_t keyIndex = 0; keyIndex &lt; m_copyState-&gt;m_totalCount;</span>
<a href="#l20.10753"></a><span id="l20.10753" class="difflineplus">+           keyIndex++) {</span>
<a href="#l20.10754"></a><span id="l20.10754" class="difflineplus">+        nsCOMPtr&lt;nsIMsgDBHdr&gt; message =</span>
<a href="#l20.10755"></a><span id="l20.10755" class="difflineplus">+            do_QueryElementAt(m_copyState-&gt;m_messages, keyIndex, &amp;rv);</span>
<a href="#l20.10756"></a><span id="l20.10756" class="difflineplus">+        // if the key is not there, then assume what the caller tells us to.</span>
<a href="#l20.10757"></a><span id="l20.10757" class="difflineplus">+        bool isRead = false;</span>
<a href="#l20.10758"></a><span id="l20.10758" class="difflineplus">+        uint32_t flags;</span>
<a href="#l20.10759"></a><span id="l20.10759" class="difflineplus">+        if (message) {</span>
<a href="#l20.10760"></a><span id="l20.10760" class="difflineplus">+          message-&gt;GetFlags(&amp;flags);</span>
<a href="#l20.10761"></a><span id="l20.10761" class="difflineplus">+          isRead = flags &amp; nsMsgMessageFlags::Read;</span>
<a href="#l20.10762"></a><span id="l20.10762">         }</span>
<a href="#l20.10763"></a><span id="l20.10763" class="difflineminus">-        m_copyState-&gt;m_unreadCount = numUnread;</span>
<a href="#l20.10764"></a><span id="l20.10764" class="difflineminus">-    }</span>
<a href="#l20.10765"></a><span id="l20.10765" class="difflineminus">-  }</span>
<a href="#l20.10766"></a><span id="l20.10766" class="difflineminus">-  else</span>
<a href="#l20.10767"></a><span id="l20.10767" class="difflineminus">-  {</span>
<a href="#l20.10768"></a><span id="l20.10768" class="difflineminus">-    nsCOMPtr&lt;nsIMsgDBHdr&gt; message =</span>
<a href="#l20.10769"></a><span id="l20.10769" class="difflineminus">-        do_QueryElementAt(m_copyState-&gt;m_messages,</span>
<a href="#l20.10770"></a><span id="l20.10770" class="difflineminus">-                          m_copyState-&gt;m_curIndex, &amp;rv);</span>
<a href="#l20.10771"></a><span id="l20.10771" class="difflineminus">-      // if the key is not there, then assume what the caller tells us to.</span>
<a href="#l20.10772"></a><span id="l20.10772" class="difflineplus">+        if (!isRead) numUnread++;</span>
<a href="#l20.10773"></a><span id="l20.10773" class="difflineplus">+      }</span>
<a href="#l20.10774"></a><span id="l20.10774" class="difflineplus">+      m_copyState-&gt;m_unreadCount = numUnread;</span>
<a href="#l20.10775"></a><span id="l20.10775" class="difflineplus">+    }</span>
<a href="#l20.10776"></a><span id="l20.10776" class="difflineplus">+  } else {</span>
<a href="#l20.10777"></a><span id="l20.10777" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; message = do_QueryElementAt(</span>
<a href="#l20.10778"></a><span id="l20.10778" class="difflineplus">+        m_copyState-&gt;m_messages, m_copyState-&gt;m_curIndex, &amp;rv);</span>
<a href="#l20.10779"></a><span id="l20.10779" class="difflineplus">+    // if the key is not there, then assume what the caller tells us to.</span>
<a href="#l20.10780"></a><span id="l20.10780">     bool isRead = false;</span>
<a href="#l20.10781"></a><span id="l20.10781">     uint32_t flags;</span>
<a href="#l20.10782"></a><span id="l20.10782" class="difflineminus">-    if (message )</span>
<a href="#l20.10783"></a><span id="l20.10783" class="difflineminus">-    {</span>
<a href="#l20.10784"></a><span id="l20.10784" class="difflineplus">+    if (message) {</span>
<a href="#l20.10785"></a><span id="l20.10785">       message-&gt;GetFlags(&amp;flags);</span>
<a href="#l20.10786"></a><span id="l20.10786">       isRead = flags &amp; nsMsgMessageFlags::Read;</span>
<a href="#l20.10787"></a><span id="l20.10787">     }</span>
<a href="#l20.10788"></a><span id="l20.10788">     m_copyState-&gt;m_unreadCount = (isRead) ? 0 : 1;</span>
<a href="#l20.10789"></a><span id="l20.10789">   }</span>
<a href="#l20.10790"></a><span id="l20.10790"> </span>
<a href="#l20.10791"></a><span id="l20.10791">   m_copyState-&gt;m_isMove = isMove;</span>
<a href="#l20.10792"></a><span id="l20.10792">   m_copyState-&gt;m_newMsgFlags = newMsgFlags;</span>
<a href="#l20.10793"></a><span id="l20.10793">   m_copyState-&gt;m_newMsgKeywords = newMsgKeywords;</span>
<a href="#l20.10794"></a><span id="l20.10794">   m_copyState-&gt;m_allowUndo = allowUndo;</span>
<a href="#l20.10795"></a><span id="l20.10795">   m_copyState-&gt;m_selectedState = selectedState;</span>
<a href="#l20.10796"></a><span id="l20.10796">   m_copyState-&gt;m_msgWindow = msgWindow;</span>
<a href="#l20.10797"></a><span id="l20.10797" class="difflineminus">-  if (listener)</span>
<a href="#l20.10798"></a><span id="l20.10798" class="difflineminus">-    m_copyState-&gt;m_listener = listener;</span>
<a href="#l20.10799"></a><span id="l20.10799" class="difflineplus">+  if (listener) m_copyState-&gt;m_listener = listener;</span>
<a href="#l20.10800"></a><span id="l20.10800">   return NS_OK;</span>
<a href="#l20.10801"></a><span id="l20.10801"> }</span>
<a href="#l20.10802"></a><span id="l20.10802"> </span>
<a href="#l20.10803"></a><span id="l20.10803" class="difflineminus">-nsresult</span>
<a href="#l20.10804"></a><span id="l20.10804" class="difflineminus">-nsImapMailFolder::CopyFileToOfflineStore(nsIFile *srcFile, nsMsgKey msgKey)</span>
<a href="#l20.10805"></a><span id="l20.10805" class="difflineminus">-{</span>
<a href="#l20.10806"></a><span id="l20.10806" class="difflineplus">+nsresult nsImapMailFolder::CopyFileToOfflineStore(nsIFile *srcFile,</span>
<a href="#l20.10807"></a><span id="l20.10807" class="difflineplus">+                                                  nsMsgKey msgKey) {</span>
<a href="#l20.10808"></a><span id="l20.10808">   nsresult rv = GetDatabase();</span>
<a href="#l20.10809"></a><span id="l20.10809">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10810"></a><span id="l20.10810"> </span>
<a href="#l20.10811"></a><span id="l20.10811">   bool storeOffline = (mFlags &amp; nsMsgFolderFlags::Offline) &amp;&amp; !WeAreOffline();</span>
<a href="#l20.10812"></a><span id="l20.10812"> </span>
<a href="#l20.10813"></a><span id="l20.10813" class="difflineminus">-  if (msgKey == nsMsgKey_None)</span>
<a href="#l20.10814"></a><span id="l20.10814" class="difflineminus">-  {</span>
<a href="#l20.10815"></a><span id="l20.10815" class="difflineminus">-    // To support send filters, we need to store the message in the database when</span>
<a href="#l20.10816"></a><span id="l20.10816" class="difflineminus">-    // it is copied to the FCC folder. In that case, we know the UID of the</span>
<a href="#l20.10817"></a><span id="l20.10817" class="difflineplus">+  if (msgKey == nsMsgKey_None) {</span>
<a href="#l20.10818"></a><span id="l20.10818" class="difflineplus">+    // To support send filters, we need to store the message in the database</span>
<a href="#l20.10819"></a><span id="l20.10819" class="difflineplus">+    // when it is copied to the FCC folder. In that case, we know the UID of the</span>
<a href="#l20.10820"></a><span id="l20.10820">     // message and therefore have the correct msgKey. In other cases, where</span>
<a href="#l20.10821"></a><span id="l20.10821">     // we don't need the offline message copied, don't add to db.</span>
<a href="#l20.10822"></a><span id="l20.10822" class="difflineminus">-    if (!storeOffline)</span>
<a href="#l20.10823"></a><span id="l20.10823" class="difflineminus">-      return NS_OK;</span>
<a href="#l20.10824"></a><span id="l20.10824" class="difflineplus">+    if (!storeOffline) return NS_OK;</span>
<a href="#l20.10825"></a><span id="l20.10825"> </span>
<a href="#l20.10826"></a><span id="l20.10826">     mDatabase-&gt;GetNextFakeOfflineMsgKey(&amp;msgKey);</span>
<a href="#l20.10827"></a><span id="l20.10827">   }</span>
<a href="#l20.10828"></a><span id="l20.10828"> </span>
<a href="#l20.10829"></a><span id="l20.10829">   nsCOMPtr&lt;nsIMsgDBHdr&gt; fakeHdr;</span>
<a href="#l20.10830"></a><span id="l20.10830">   rv = mDatabase-&gt;CreateNewHdr(msgKey, getter_AddRefs(fakeHdr));</span>
<a href="#l20.10831"></a><span id="l20.10831">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10832"></a><span id="l20.10832">   fakeHdr-&gt;SetUint32Property(&quot;pseudoHdr&quot;, 1);</span>
<a href="#l20.10833"></a><span id="l20.10833"> </span>
<a href="#l20.10834"></a><span id="l20.10834">   // Should we add this to the offline store?</span>
<a href="#l20.10835"></a><span id="l20.10835">   nsCOMPtr&lt;nsIOutputStream&gt; offlineStore;</span>
<a href="#l20.10836"></a><span id="l20.10836" class="difflineminus">-  if (storeOffline)</span>
<a href="#l20.10837"></a><span id="l20.10837" class="difflineminus">-  {</span>
<a href="#l20.10838"></a><span id="l20.10838" class="difflineplus">+  if (storeOffline) {</span>
<a href="#l20.10839"></a><span id="l20.10839">     rv = GetOfflineStoreOutputStream(fakeHdr, getter_AddRefs(offlineStore));</span>
<a href="#l20.10840"></a><span id="l20.10840">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10841"></a><span id="l20.10841">   }</span>
<a href="#l20.10842"></a><span id="l20.10842"> </span>
<a href="#l20.10843"></a><span id="l20.10843">   // We set an offline kMoveResult because in any case we want to update this</span>
<a href="#l20.10844"></a><span id="l20.10844">   // msgHdr with one downloaded from the server, with possible additional</span>
<a href="#l20.10845"></a><span id="l20.10845">   // headers added.</span>
<a href="#l20.10846"></a><span id="l20.10846">   nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; op;</span>
<a href="#l20.10847"></a><span id="l20.10847">   rv = mDatabase-&gt;GetOfflineOpForKey(msgKey, true, getter_AddRefs(op));</span>
<a href="#l20.10848"></a><span id="l20.10848" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; op)</span>
<a href="#l20.10849"></a><span id="l20.10849" class="difflineminus">-  {</span>
<a href="#l20.10850"></a><span id="l20.10850" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; op) {</span>
<a href="#l20.10851"></a><span id="l20.10851">     nsCString destFolderUri;</span>
<a href="#l20.10852"></a><span id="l20.10852">     GetURI(destFolderUri);</span>
<a href="#l20.10853"></a><span id="l20.10853">     op-&gt;SetOperation(nsIMsgOfflineImapOperation::kMoveResult);</span>
<a href="#l20.10854"></a><span id="l20.10854">     op-&gt;SetDestinationFolderURI(destFolderUri.get());</span>
<a href="#l20.10855"></a><span id="l20.10855">     SetFlag(nsMsgFolderFlags::OfflineEvents);</span>
<a href="#l20.10856"></a><span id="l20.10856">   }</span>
<a href="#l20.10857"></a><span id="l20.10857"> </span>
<a href="#l20.10858"></a><span id="l20.10858">   nsCOMPtr&lt;nsIInputStream&gt; inputStream;</span>
<a href="#l20.10859"></a><span id="l20.10859">   nsCOMPtr&lt;nsIMsgParseMailMsgState&gt; msgParser =</span>
<a href="#l20.10860"></a><span id="l20.10860" class="difflineminus">-    do_CreateInstance(NS_PARSEMAILMSGSTATE_CONTRACTID, &amp;rv);</span>
<a href="#l20.10861"></a><span id="l20.10861" class="difflineplus">+      do_CreateInstance(NS_PARSEMAILMSGSTATE_CONTRACTID, &amp;rv);</span>
<a href="#l20.10862"></a><span id="l20.10862">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10863"></a><span id="l20.10863">   msgParser-&gt;SetMailDB(mDatabase);</span>
<a href="#l20.10864"></a><span id="l20.10864"> </span>
<a href="#l20.10865"></a><span id="l20.10865">   uint64_t offset = 0;</span>
<a href="#l20.10866"></a><span id="l20.10866" class="difflineminus">-  if (offlineStore)</span>
<a href="#l20.10867"></a><span id="l20.10867" class="difflineminus">-  {</span>
<a href="#l20.10868"></a><span id="l20.10868" class="difflineplus">+  if (offlineStore) {</span>
<a href="#l20.10869"></a><span id="l20.10869">     // Tell the parser to use the offset that will be in the dest stream,</span>
<a href="#l20.10870"></a><span id="l20.10870">     //   not the temp file.</span>
<a href="#l20.10871"></a><span id="l20.10871">     fakeHdr-&gt;GetMessageOffset(&amp;offset);</span>
<a href="#l20.10872"></a><span id="l20.10872">   }</span>
<a href="#l20.10873"></a><span id="l20.10873">   msgParser-&gt;SetEnvelopePos(offset);</span>
<a href="#l20.10874"></a><span id="l20.10874"> </span>
<a href="#l20.10875"></a><span id="l20.10875">   rv = NS_NewLocalFileInputStream(getter_AddRefs(inputStream), srcFile);</span>
<a href="#l20.10876"></a><span id="l20.10876" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; inputStream)</span>
<a href="#l20.10877"></a><span id="l20.10877" class="difflineminus">-  {</span>
<a href="#l20.10878"></a><span id="l20.10878" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; inputStream) {</span>
<a href="#l20.10879"></a><span id="l20.10879">     // Now, parse the temp file to (optionally) copy to</span>
<a href="#l20.10880"></a><span id="l20.10880">     // the offline store for the cur folder.</span>
<a href="#l20.10881"></a><span id="l20.10881">     RefPtr&lt;nsMsgLineStreamBuffer&gt; inputStreamBuffer =</span>
<a href="#l20.10882"></a><span id="l20.10882" class="difflineminus">-      new nsMsgLineStreamBuffer(FILE_IO_BUFFER_SIZE, true, false);</span>
<a href="#l20.10883"></a><span id="l20.10883" class="difflineplus">+        new nsMsgLineStreamBuffer(FILE_IO_BUFFER_SIZE, true, false);</span>
<a href="#l20.10884"></a><span id="l20.10884">     int64_t fileSize;</span>
<a href="#l20.10885"></a><span id="l20.10885">     srcFile-&gt;GetFileSize(&amp;fileSize);</span>
<a href="#l20.10886"></a><span id="l20.10886">     uint32_t bytesWritten;</span>
<a href="#l20.10887"></a><span id="l20.10887">     rv = NS_OK;</span>
<a href="#l20.10888"></a><span id="l20.10888">     msgParser-&gt;SetState(nsIMsgParseMailMsgState::ParseHeadersState);</span>
<a href="#l20.10889"></a><span id="l20.10889">     msgParser-&gt;SetNewMsgHdr(fakeHdr);</span>
<a href="#l20.10890"></a><span id="l20.10890">     bool needMoreData = false;</span>
<a href="#l20.10891"></a><span id="l20.10891" class="difflineminus">-    char * newLine = nullptr;</span>
<a href="#l20.10892"></a><span id="l20.10892" class="difflineplus">+    char *newLine = nullptr;</span>
<a href="#l20.10893"></a><span id="l20.10893">     uint32_t numBytesInLine = 0;</span>
<a href="#l20.10894"></a><span id="l20.10894" class="difflineminus">-    if (offlineStore)</span>
<a href="#l20.10895"></a><span id="l20.10895" class="difflineminus">-    {</span>
<a href="#l20.10896"></a><span id="l20.10896" class="difflineplus">+    if (offlineStore) {</span>
<a href="#l20.10897"></a><span id="l20.10897">       const char *envelope = &quot;From &quot; CRLF;</span>
<a href="#l20.10898"></a><span id="l20.10898">       offlineStore-&gt;Write(envelope, strlen(envelope), &amp;bytesWritten);</span>
<a href="#l20.10899"></a><span id="l20.10899">       fileSize += bytesWritten;</span>
<a href="#l20.10900"></a><span id="l20.10900">     }</span>
<a href="#l20.10901"></a><span id="l20.10901" class="difflineminus">-    do</span>
<a href="#l20.10902"></a><span id="l20.10902" class="difflineminus">-    {</span>
<a href="#l20.10903"></a><span id="l20.10903" class="difflineminus">-      newLine = inputStreamBuffer-&gt;ReadNextLine(inputStream, numBytesInLine, needMoreData);</span>
<a href="#l20.10904"></a><span id="l20.10904" class="difflineminus">-      if (newLine)</span>
<a href="#l20.10905"></a><span id="l20.10905" class="difflineminus">-      {</span>
<a href="#l20.10906"></a><span id="l20.10906" class="difflineplus">+    do {</span>
<a href="#l20.10907"></a><span id="l20.10907" class="difflineplus">+      newLine = inputStreamBuffer-&gt;ReadNextLine(inputStream, numBytesInLine,</span>
<a href="#l20.10908"></a><span id="l20.10908" class="difflineplus">+                                                needMoreData);</span>
<a href="#l20.10909"></a><span id="l20.10909" class="difflineplus">+      if (newLine) {</span>
<a href="#l20.10910"></a><span id="l20.10910">         msgParser-&gt;ParseAFolderLine(newLine, numBytesInLine);</span>
<a href="#l20.10911"></a><span id="l20.10911">         if (offlineStore)</span>
<a href="#l20.10912"></a><span id="l20.10912">           rv = offlineStore-&gt;Write(newLine, numBytesInLine, &amp;bytesWritten);</span>
<a href="#l20.10913"></a><span id="l20.10913"> </span>
<a href="#l20.10914"></a><span id="l20.10914">         free(newLine);</span>
<a href="#l20.10915"></a><span id="l20.10915">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10916"></a><span id="l20.10916">       }</span>
<a href="#l20.10917"></a><span id="l20.10917">     } while (newLine);</span>
<a href="#l20.10918"></a><span id="l20.10918"> </span>
<a href="#l20.10919"></a><span id="l20.10919">     msgParser-&gt;FinishHeader();</span>
<a href="#l20.10920"></a><span id="l20.10920">     uint32_t resultFlags;</span>
<a href="#l20.10921"></a><span id="l20.10921">     if (offlineStore)</span>
<a href="#l20.10922"></a><span id="l20.10922" class="difflineminus">-      fakeHdr-&gt;OrFlags(nsMsgMessageFlags::Offline | nsMsgMessageFlags::Read, &amp;resultFlags);</span>
<a href="#l20.10923"></a><span id="l20.10923" class="difflineplus">+      fakeHdr-&gt;OrFlags(nsMsgMessageFlags::Offline | nsMsgMessageFlags::Read,</span>
<a href="#l20.10924"></a><span id="l20.10924" class="difflineplus">+                       &amp;resultFlags);</span>
<a href="#l20.10925"></a><span id="l20.10925">     else</span>
<a href="#l20.10926"></a><span id="l20.10926">       fakeHdr-&gt;OrFlags(nsMsgMessageFlags::Read, &amp;resultFlags);</span>
<a href="#l20.10927"></a><span id="l20.10927" class="difflineminus">-    if (offlineStore)</span>
<a href="#l20.10928"></a><span id="l20.10928" class="difflineminus">-      fakeHdr-&gt;SetOfflineMessageSize(fileSize);</span>
<a href="#l20.10929"></a><span id="l20.10929" class="difflineplus">+    if (offlineStore) fakeHdr-&gt;SetOfflineMessageSize(fileSize);</span>
<a href="#l20.10930"></a><span id="l20.10930">     mDatabase-&gt;AddNewHdrToDB(fakeHdr, true /* notify */);</span>
<a href="#l20.10931"></a><span id="l20.10931"> </span>
<a href="#l20.10932"></a><span id="l20.10932">     // Call FinishNewMessage before setting pending attributes, as in</span>
<a href="#l20.10933"></a><span id="l20.10933">     //   maildir it copies from tmp to cur and may change the storeToken</span>
<a href="#l20.10934"></a><span id="l20.10934">     //   to get a unique filename.</span>
<a href="#l20.10935"></a><span id="l20.10935" class="difflineminus">-    if (offlineStore)</span>
<a href="#l20.10936"></a><span id="l20.10936" class="difflineminus">-    {</span>
<a href="#l20.10937"></a><span id="l20.10937" class="difflineplus">+    if (offlineStore) {</span>
<a href="#l20.10938"></a><span id="l20.10938">       nsCOMPtr&lt;nsIMsgPluggableStore&gt; msgStore;</span>
<a href="#l20.10939"></a><span id="l20.10939">       GetMsgStore(getter_AddRefs(msgStore));</span>
<a href="#l20.10940"></a><span id="l20.10940" class="difflineminus">-      if (msgStore)</span>
<a href="#l20.10941"></a><span id="l20.10941" class="difflineminus">-        msgStore-&gt;FinishNewMessage(offlineStore, fakeHdr);</span>
<a href="#l20.10942"></a><span id="l20.10942" class="difflineminus">-    }</span>
<a href="#l20.10943"></a><span id="l20.10943" class="difflineminus">-</span>
<a href="#l20.10944"></a><span id="l20.10944" class="difflineminus">-    nsCOMPtr&lt;nsIMutableArray&gt; messages(do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l20.10945"></a><span id="l20.10945" class="difflineplus">+      if (msgStore) msgStore-&gt;FinishNewMessage(offlineStore, fakeHdr);</span>
<a href="#l20.10946"></a><span id="l20.10946" class="difflineplus">+    }</span>
<a href="#l20.10947"></a><span id="l20.10947" class="difflineplus">+</span>
<a href="#l20.10948"></a><span id="l20.10948" class="difflineplus">+    nsCOMPtr&lt;nsIMutableArray&gt; messages(</span>
<a href="#l20.10949"></a><span id="l20.10949" class="difflineplus">+        do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l20.10950"></a><span id="l20.10950">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.10951"></a><span id="l20.10951">     messages-&gt;AppendElement(fakeHdr);</span>
<a href="#l20.10952"></a><span id="l20.10952"> </span>
<a href="#l20.10953"></a><span id="l20.10953">     // We are copying from a file to offline store so set offline flag.</span>
<a href="#l20.10954"></a><span id="l20.10954">     SetPendingAttributes(messages, false, true);</span>
<a href="#l20.10955"></a><span id="l20.10955"> </span>
<a href="#l20.10956"></a><span id="l20.10956">     // Gloda needs this notification to index the fake message.</span>
<a href="#l20.10957"></a><span id="l20.10957" class="difflineminus">-    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt;</span>
<a href="#l20.10958"></a><span id="l20.10958" class="difflineminus">-      notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.10959"></a><span id="l20.10959" class="difflineminus">-    if (notifier)</span>
<a href="#l20.10960"></a><span id="l20.10960" class="difflineminus">-      notifier-&gt;NotifyMsgsClassified(messages, false, false);</span>
<a href="#l20.10961"></a><span id="l20.10961" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(</span>
<a href="#l20.10962"></a><span id="l20.10962" class="difflineplus">+        do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.10963"></a><span id="l20.10963" class="difflineplus">+    if (notifier) notifier-&gt;NotifyMsgsClassified(messages, false, false);</span>
<a href="#l20.10964"></a><span id="l20.10964">     inputStream-&gt;Close();</span>
<a href="#l20.10965"></a><span id="l20.10965">     inputStream = nullptr;</span>
<a href="#l20.10966"></a><span id="l20.10966">   }</span>
<a href="#l20.10967"></a><span id="l20.10967" class="difflineminus">-  if (offlineStore)</span>
<a href="#l20.10968"></a><span id="l20.10968" class="difflineminus">-    offlineStore-&gt;Close();</span>
<a href="#l20.10969"></a><span id="l20.10969" class="difflineplus">+  if (offlineStore) offlineStore-&gt;Close();</span>
<a href="#l20.10970"></a><span id="l20.10970">   return rv;</span>
<a href="#l20.10971"></a><span id="l20.10971"> }</span>
<a href="#l20.10972"></a><span id="l20.10972"> </span>
<a href="#l20.10973"></a><span id="l20.10973" class="difflineminus">-nsresult</span>
<a href="#l20.10974"></a><span id="l20.10974" class="difflineminus">-nsImapMailFolder::OnCopyCompleted(nsISupports *srcSupport, nsresult rv)</span>
<a href="#l20.10975"></a><span id="l20.10975" class="difflineminus">-{</span>
<a href="#l20.10976"></a><span id="l20.10976" class="difflineplus">+nsresult nsImapMailFolder::OnCopyCompleted(nsISupports *srcSupport,</span>
<a href="#l20.10977"></a><span id="l20.10977" class="difflineplus">+                                           nsresult rv) {</span>
<a href="#l20.10978"></a><span id="l20.10978">   // if it's a file, and the copy succeeded, then fcc the offline</span>
<a href="#l20.10979"></a><span id="l20.10979">   // store, and add a kMoveResult offline op.</span>
<a href="#l20.10980"></a><span id="l20.10980" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; m_copyState)</span>
<a href="#l20.10981"></a><span id="l20.10981" class="difflineminus">-  {</span>
<a href="#l20.10982"></a><span id="l20.10982" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; m_copyState) {</span>
<a href="#l20.10983"></a><span id="l20.10983">     nsCOMPtr&lt;nsIFile&gt; srcFile(do_QueryInterface(srcSupport));</span>
<a href="#l20.10984"></a><span id="l20.10984">     if (srcFile)</span>
<a href="#l20.10985"></a><span id="l20.10985" class="difflineminus">-      (void) CopyFileToOfflineStore(srcFile, m_copyState-&gt;m_appendUID);</span>
<a href="#l20.10986"></a><span id="l20.10986" class="difflineplus">+      (void)CopyFileToOfflineStore(srcFile, m_copyState-&gt;m_appendUID);</span>
<a href="#l20.10987"></a><span id="l20.10987">   }</span>
<a href="#l20.10988"></a><span id="l20.10988">   m_copyState = nullptr;</span>
<a href="#l20.10989"></a><span id="l20.10989">   nsresult result;</span>
<a href="#l20.10990"></a><span id="l20.10990" class="difflineminus">-  nsCOMPtr&lt;nsIMsgCopyService&gt; copyService = do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;result);</span>
<a href="#l20.10991"></a><span id="l20.10991" class="difflineplus">+  nsCOMPtr&lt;nsIMsgCopyService&gt; copyService =</span>
<a href="#l20.10992"></a><span id="l20.10992" class="difflineplus">+      do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;result);</span>
<a href="#l20.10993"></a><span id="l20.10993">   NS_ENSURE_SUCCESS(result, result);</span>
<a href="#l20.10994"></a><span id="l20.10994">   return copyService-&gt;NotifyCompletion(srcSupport, this, rv);</span>
<a href="#l20.10995"></a><span id="l20.10995"> }</span>
<a href="#l20.10996"></a><span id="l20.10996"> </span>
<a href="#l20.10997"></a><span id="l20.10997" class="difflineminus">-nsresult nsImapMailFolder::CreateBaseMessageURI(const nsACString&amp; aURI)</span>
<a href="#l20.10998"></a><span id="l20.10998" class="difflineminus">-{</span>
<a href="#l20.10999"></a><span id="l20.10999" class="difflineplus">+nsresult nsImapMailFolder::CreateBaseMessageURI(const nsACString &amp;aURI) {</span>
<a href="#l20.11000"></a><span id="l20.11000">   return nsCreateImapBaseMessageURI(aURI, mBaseMessageURI);</span>
<a href="#l20.11001"></a><span id="l20.11001"> }</span>
<a href="#l20.11002"></a><span id="l20.11002"> </span>
<a href="#l20.11003"></a><span id="l20.11003" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetFolderURL(nsACString&amp; aFolderURL)</span>
<a href="#l20.11004"></a><span id="l20.11004" class="difflineminus">-{</span>
<a href="#l20.11005"></a><span id="l20.11005" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetFolderURL(nsACString &amp;aFolderURL) {</span>
<a href="#l20.11006"></a><span id="l20.11006">   nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l20.11007"></a><span id="l20.11007">   nsresult rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l20.11008"></a><span id="l20.11008">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11009"></a><span id="l20.11009">   rootFolder-&gt;GetURI(aFolderURL);</span>
<a href="#l20.11010"></a><span id="l20.11010" class="difflineminus">-  if (rootFolder == this)</span>
<a href="#l20.11011"></a><span id="l20.11011" class="difflineminus">-    return NS_OK;</span>
<a href="#l20.11012"></a><span id="l20.11012" class="difflineminus">-</span>
<a href="#l20.11013"></a><span id="l20.11013" class="difflineminus">-  NS_ASSERTION(mURI.Length() &gt; aFolderURL.Length(), &quot;Should match with a folder name!&quot;);</span>
<a href="#l20.11014"></a><span id="l20.11014" class="difflineplus">+  if (rootFolder == this) return NS_OK;</span>
<a href="#l20.11015"></a><span id="l20.11015" class="difflineplus">+</span>
<a href="#l20.11016"></a><span id="l20.11016" class="difflineplus">+  NS_ASSERTION(mURI.Length() &gt; aFolderURL.Length(),</span>
<a href="#l20.11017"></a><span id="l20.11017" class="difflineplus">+               &quot;Should match with a folder name!&quot;);</span>
<a href="#l20.11018"></a><span id="l20.11018">   nsCString escapedName;</span>
<a href="#l20.11019"></a><span id="l20.11019">   MsgEscapeString(Substring(mURI, aFolderURL.Length()),</span>
<a href="#l20.11020"></a><span id="l20.11020" class="difflineminus">-                  nsINetUtil::ESCAPE_URL_PATH,</span>
<a href="#l20.11021"></a><span id="l20.11021" class="difflineminus">-                  escapedName);</span>
<a href="#l20.11022"></a><span id="l20.11022" class="difflineminus">-  if (escapedName.IsEmpty())</span>
<a href="#l20.11023"></a><span id="l20.11023" class="difflineminus">-    return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.11024"></a><span id="l20.11024" class="difflineplus">+                  nsINetUtil::ESCAPE_URL_PATH, escapedName);</span>
<a href="#l20.11025"></a><span id="l20.11025" class="difflineplus">+  if (escapedName.IsEmpty()) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.11026"></a><span id="l20.11026">   aFolderURL.Append(escapedName);</span>
<a href="#l20.11027"></a><span id="l20.11027">   return NS_OK;</span>
<a href="#l20.11028"></a><span id="l20.11028"> }</span>
<a href="#l20.11029"></a><span id="l20.11029"> </span>
<a href="#l20.11030"></a><span id="l20.11030" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetFolderNeedsSubscribing(bool *bVal)</span>
<a href="#l20.11031"></a><span id="l20.11031" class="difflineminus">-{</span>
<a href="#l20.11032"></a><span id="l20.11032" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetFolderNeedsSubscribing(bool *bVal) {</span>
<a href="#l20.11033"></a><span id="l20.11033">   NS_ENSURE_ARG_POINTER(bVal);</span>
<a href="#l20.11034"></a><span id="l20.11034">   *bVal = m_folderNeedsSubscribing;</span>
<a href="#l20.11035"></a><span id="l20.11035">   return NS_OK;</span>
<a href="#l20.11036"></a><span id="l20.11036"> }</span>
<a href="#l20.11037"></a><span id="l20.11037"> </span>
<a href="#l20.11038"></a><span id="l20.11038" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetFolderNeedsSubscribing(bool bVal)</span>
<a href="#l20.11039"></a><span id="l20.11039" class="difflineminus">-{</span>
<a href="#l20.11040"></a><span id="l20.11040" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetFolderNeedsSubscribing(bool bVal) {</span>
<a href="#l20.11041"></a><span id="l20.11041">   m_folderNeedsSubscribing = bVal;</span>
<a href="#l20.11042"></a><span id="l20.11042">   return NS_OK;</span>
<a href="#l20.11043"></a><span id="l20.11043"> }</span>
<a href="#l20.11044"></a><span id="l20.11044"> </span>
<a href="#l20.11045"></a><span id="l20.11045" class="difflineminus">-nsMsgIMAPFolderACL * nsImapMailFolder::GetFolderACL()</span>
<a href="#l20.11046"></a><span id="l20.11046" class="difflineminus">-{</span>
<a href="#l20.11047"></a><span id="l20.11047" class="difflineminus">-  if (!m_folderACL)</span>
<a href="#l20.11048"></a><span id="l20.11048" class="difflineminus">-    m_folderACL = new nsMsgIMAPFolderACL(this);</span>
<a href="#l20.11049"></a><span id="l20.11049" class="difflineplus">+nsMsgIMAPFolderACL *nsImapMailFolder::GetFolderACL() {</span>
<a href="#l20.11050"></a><span id="l20.11050" class="difflineplus">+  if (!m_folderACL) m_folderACL = new nsMsgIMAPFolderACL(this);</span>
<a href="#l20.11051"></a><span id="l20.11051">   return m_folderACL;</span>
<a href="#l20.11052"></a><span id="l20.11052"> }</span>
<a href="#l20.11053"></a><span id="l20.11053"> </span>
<a href="#l20.11054"></a><span id="l20.11054" class="difflineminus">-nsresult nsImapMailFolder::CreateACLRightsStringForFolder(nsAString&amp; rightsString)</span>
<a href="#l20.11055"></a><span id="l20.11055" class="difflineminus">-{</span>
<a href="#l20.11056"></a><span id="l20.11056" class="difflineminus">-  GetFolderACL(); // lazy create</span>
<a href="#l20.11057"></a><span id="l20.11057" class="difflineplus">+nsresult nsImapMailFolder::CreateACLRightsStringForFolder(</span>
<a href="#l20.11058"></a><span id="l20.11058" class="difflineplus">+    nsAString &amp;rightsString) {</span>
<a href="#l20.11059"></a><span id="l20.11059" class="difflineplus">+  GetFolderACL();  // lazy create</span>
<a href="#l20.11060"></a><span id="l20.11060">   NS_ENSURE_TRUE(m_folderACL, NS_ERROR_NULL_POINTER);</span>
<a href="#l20.11061"></a><span id="l20.11061">   return m_folderACL-&gt;CreateACLRightsString(rightsString);</span>
<a href="#l20.11062"></a><span id="l20.11062"> }</span>
<a href="#l20.11063"></a><span id="l20.11063"> </span>
<a href="#l20.11064"></a><span id="l20.11064" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetFolderNeedsACLListed(bool *bVal)</span>
<a href="#l20.11065"></a><span id="l20.11065" class="difflineminus">-{</span>
<a href="#l20.11066"></a><span id="l20.11066" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetFolderNeedsACLListed(bool *bVal) {</span>
<a href="#l20.11067"></a><span id="l20.11067">   NS_ENSURE_ARG_POINTER(bVal);</span>
<a href="#l20.11068"></a><span id="l20.11068">   bool dontNeedACLListed = !m_folderNeedsACLListed;</span>
<a href="#l20.11069"></a><span id="l20.11069">   // if we haven't acl listed, and it's not a no select folder or the inbox,</span>
<a href="#l20.11070"></a><span id="l20.11070">   //  then we'll list the acl if it's not a namespace.</span>
<a href="#l20.11071"></a><span id="l20.11071" class="difflineminus">-  if (m_folderNeedsACLListed &amp;&amp; !(mFlags &amp; (nsMsgFolderFlags::ImapNoselect | nsMsgFolderFlags::Inbox)))</span>
<a href="#l20.11072"></a><span id="l20.11072" class="difflineplus">+  if (m_folderNeedsACLListed &amp;&amp;</span>
<a href="#l20.11073"></a><span id="l20.11073" class="difflineplus">+      !(mFlags &amp; (nsMsgFolderFlags::ImapNoselect | nsMsgFolderFlags::Inbox)))</span>
<a href="#l20.11074"></a><span id="l20.11074">     GetIsNamespace(&amp;dontNeedACLListed);</span>
<a href="#l20.11075"></a><span id="l20.11075">   *bVal = !dontNeedACLListed;</span>
<a href="#l20.11076"></a><span id="l20.11076">   return NS_OK;</span>
<a href="#l20.11077"></a><span id="l20.11077"> }</span>
<a href="#l20.11078"></a><span id="l20.11078"> </span>
<a href="#l20.11079"></a><span id="l20.11079" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetFolderNeedsACLListed(bool bVal)</span>
<a href="#l20.11080"></a><span id="l20.11080" class="difflineminus">-{</span>
<a href="#l20.11081"></a><span id="l20.11081" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetFolderNeedsACLListed(bool bVal) {</span>
<a href="#l20.11082"></a><span id="l20.11082">   m_folderNeedsACLListed = bVal;</span>
<a href="#l20.11083"></a><span id="l20.11083">   return NS_OK;</span>
<a href="#l20.11084"></a><span id="l20.11084"> }</span>
<a href="#l20.11085"></a><span id="l20.11085"> </span>
<a href="#l20.11086"></a><span id="l20.11086" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetIsNamespace(bool *aResult)</span>
<a href="#l20.11087"></a><span id="l20.11087" class="difflineminus">-{</span>
<a href="#l20.11088"></a><span id="l20.11088" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetIsNamespace(bool *aResult) {</span>
<a href="#l20.11089"></a><span id="l20.11089">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l20.11090"></a><span id="l20.11090">   nsresult rv = NS_OK;</span>
<a href="#l20.11091"></a><span id="l20.11091" class="difflineminus">-  if (!m_namespace)</span>
<a href="#l20.11092"></a><span id="l20.11092" class="difflineminus">-  {</span>
<a href="#l20.11093"></a><span id="l20.11093" class="difflineplus">+  if (!m_namespace) {</span>
<a href="#l20.11094"></a><span id="l20.11094"> #ifdef DEBUG_bienvenu</span>
<a href="#l20.11095"></a><span id="l20.11095">     // Make sure this isn't causing us to open the database</span>
<a href="#l20.11096"></a><span id="l20.11096" class="difflineminus">-    NS_ASSERTION(m_hierarchyDelimiter != kOnlineHierarchySeparatorUnknown, &quot;hierarchy delimiter not set&quot;);</span>
<a href="#l20.11097"></a><span id="l20.11097" class="difflineplus">+    NS_ASSERTION(m_hierarchyDelimiter != kOnlineHierarchySeparatorUnknown,</span>
<a href="#l20.11098"></a><span id="l20.11098" class="difflineplus">+                 &quot;hierarchy delimiter not set&quot;);</span>
<a href="#l20.11099"></a><span id="l20.11099"> #endif</span>
<a href="#l20.11100"></a><span id="l20.11100"> </span>
<a href="#l20.11101"></a><span id="l20.11101">     nsCString onlineName, serverKey;</span>
<a href="#l20.11102"></a><span id="l20.11102">     GetServerKey(serverKey);</span>
<a href="#l20.11103"></a><span id="l20.11103">     GetOnlineName(onlineName);</span>
<a href="#l20.11104"></a><span id="l20.11104">     char hierarchyDelimiter;</span>
<a href="#l20.11105"></a><span id="l20.11105">     GetHierarchyDelimiter(&amp;hierarchyDelimiter);</span>
<a href="#l20.11106"></a><span id="l20.11106"> </span>
<a href="#l20.11107"></a><span id="l20.11107" class="difflineminus">-    nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession = do_GetService(kCImapHostSessionList, &amp;rv);</span>
<a href="#l20.11108"></a><span id="l20.11108" class="difflineplus">+    nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession =</span>
<a href="#l20.11109"></a><span id="l20.11109" class="difflineplus">+        do_GetService(kCImapHostSessionList, &amp;rv);</span>
<a href="#l20.11110"></a><span id="l20.11110">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11111"></a><span id="l20.11111">     m_namespace = nsIMAPNamespaceList::GetNamespaceForFolder(</span>
<a href="#l20.11112"></a><span id="l20.11112" class="difflineminus">-                    serverKey.get(), onlineName.get(), hierarchyDelimiter);</span>
<a href="#l20.11113"></a><span id="l20.11113" class="difflineminus">-    if (m_namespace == nullptr)</span>
<a href="#l20.11114"></a><span id="l20.11114" class="difflineminus">-    {</span>
<a href="#l20.11115"></a><span id="l20.11115" class="difflineplus">+        serverKey.get(), onlineName.get(), hierarchyDelimiter);</span>
<a href="#l20.11116"></a><span id="l20.11116" class="difflineplus">+    if (m_namespace == nullptr) {</span>
<a href="#l20.11117"></a><span id="l20.11117">       if (mFlags &amp; nsMsgFolderFlags::ImapOtherUser)</span>
<a href="#l20.11118"></a><span id="l20.11118" class="difflineminus">-         rv = hostSession-&gt;GetDefaultNamespaceOfTypeForHost(serverKey.get(), kOtherUsersNamespace, m_namespace);</span>
<a href="#l20.11119"></a><span id="l20.11119" class="difflineplus">+        rv = hostSession-&gt;GetDefaultNamespaceOfTypeForHost(</span>
<a href="#l20.11120"></a><span id="l20.11120" class="difflineplus">+            serverKey.get(), kOtherUsersNamespace, m_namespace);</span>
<a href="#l20.11121"></a><span id="l20.11121">       else if (mFlags &amp; nsMsgFolderFlags::ImapPublic)</span>
<a href="#l20.11122"></a><span id="l20.11122" class="difflineminus">-        rv = hostSession-&gt;GetDefaultNamespaceOfTypeForHost(serverKey.get(), kPublicNamespace, m_namespace);</span>
<a href="#l20.11123"></a><span id="l20.11123" class="difflineplus">+        rv = hostSession-&gt;GetDefaultNamespaceOfTypeForHost(</span>
<a href="#l20.11124"></a><span id="l20.11124" class="difflineplus">+            serverKey.get(), kPublicNamespace, m_namespace);</span>
<a href="#l20.11125"></a><span id="l20.11125">       else</span>
<a href="#l20.11126"></a><span id="l20.11126" class="difflineminus">-        rv = hostSession-&gt;GetDefaultNamespaceOfTypeForHost(serverKey.get(), kPersonalNamespace, m_namespace);</span>
<a href="#l20.11127"></a><span id="l20.11127" class="difflineplus">+        rv = hostSession-&gt;GetDefaultNamespaceOfTypeForHost(</span>
<a href="#l20.11128"></a><span id="l20.11128" class="difflineplus">+            serverKey.get(), kPersonalNamespace, m_namespace);</span>
<a href="#l20.11129"></a><span id="l20.11129">     }</span>
<a href="#l20.11130"></a><span id="l20.11130">     NS_ASSERTION(m_namespace, &quot;failed to get namespace&quot;);</span>
<a href="#l20.11131"></a><span id="l20.11131" class="difflineminus">-    if (m_namespace)</span>
<a href="#l20.11132"></a><span id="l20.11132" class="difflineminus">-    {</span>
<a href="#l20.11133"></a><span id="l20.11133" class="difflineminus">-      nsIMAPNamespaceList::SuggestHierarchySeparatorForNamespace(m_namespace,</span>
<a href="#l20.11134"></a><span id="l20.11134" class="difflineminus">-                                                                 hierarchyDelimiter);</span>
<a href="#l20.11135"></a><span id="l20.11135" class="difflineplus">+    if (m_namespace) {</span>
<a href="#l20.11136"></a><span id="l20.11136" class="difflineplus">+      nsIMAPNamespaceList::SuggestHierarchySeparatorForNamespace(</span>
<a href="#l20.11137"></a><span id="l20.11137" class="difflineplus">+          m_namespace, hierarchyDelimiter);</span>
<a href="#l20.11138"></a><span id="l20.11138">       m_folderIsNamespace = nsIMAPNamespaceList::GetFolderIsNamespace(</span>
<a href="#l20.11139"></a><span id="l20.11139" class="difflineminus">-                              serverKey.get(), onlineName.get(),</span>
<a href="#l20.11140"></a><span id="l20.11140" class="difflineminus">-                              hierarchyDelimiter, m_namespace);</span>
<a href="#l20.11141"></a><span id="l20.11141" class="difflineplus">+          serverKey.get(), onlineName.get(), hierarchyDelimiter, m_namespace);</span>
<a href="#l20.11142"></a><span id="l20.11142">     }</span>
<a href="#l20.11143"></a><span id="l20.11143">   }</span>
<a href="#l20.11144"></a><span id="l20.11144">   *aResult = m_folderIsNamespace;</span>
<a href="#l20.11145"></a><span id="l20.11145">   return rv;</span>
<a href="#l20.11146"></a><span id="l20.11146"> }</span>
<a href="#l20.11147"></a><span id="l20.11147"> </span>
<a href="#l20.11148"></a><span id="l20.11148" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetIsNamespace(bool isNamespace)</span>
<a href="#l20.11149"></a><span id="l20.11149" class="difflineminus">-{</span>
<a href="#l20.11150"></a><span id="l20.11150" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetIsNamespace(bool isNamespace) {</span>
<a href="#l20.11151"></a><span id="l20.11151">   m_folderIsNamespace = isNamespace;</span>
<a href="#l20.11152"></a><span id="l20.11152">   return NS_OK;</span>
<a href="#l20.11153"></a><span id="l20.11153"> }</span>
<a href="#l20.11154"></a><span id="l20.11154"> </span>
<a href="#l20.11155"></a><span id="l20.11155" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::ResetNamespaceReferences()</span>
<a href="#l20.11156"></a><span id="l20.11156" class="difflineminus">-{</span>
<a href="#l20.11157"></a><span id="l20.11157" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::ResetNamespaceReferences() {</span>
<a href="#l20.11158"></a><span id="l20.11158">   nsCString serverKey;</span>
<a href="#l20.11159"></a><span id="l20.11159">   nsCString onlineName;</span>
<a href="#l20.11160"></a><span id="l20.11160">   GetServerKey(serverKey);</span>
<a href="#l20.11161"></a><span id="l20.11161">   GetOnlineName(onlineName);</span>
<a href="#l20.11162"></a><span id="l20.11162">   char hierarchyDelimiter;</span>
<a href="#l20.11163"></a><span id="l20.11163">   GetHierarchyDelimiter(&amp;hierarchyDelimiter);</span>
<a href="#l20.11164"></a><span id="l20.11164" class="difflineminus">-  m_namespace = nsIMAPNamespaceList::GetNamespaceForFolder(serverKey.get(),</span>
<a href="#l20.11165"></a><span id="l20.11165" class="difflineminus">-                                                           onlineName.get(),</span>
<a href="#l20.11166"></a><span id="l20.11166" class="difflineminus">-                                                           hierarchyDelimiter);</span>
<a href="#l20.11167"></a><span id="l20.11167" class="difflineplus">+  m_namespace = nsIMAPNamespaceList::GetNamespaceForFolder(</span>
<a href="#l20.11168"></a><span id="l20.11168" class="difflineplus">+      serverKey.get(), onlineName.get(), hierarchyDelimiter);</span>
<a href="#l20.11169"></a><span id="l20.11169">   m_folderIsNamespace = m_namespace ? nsIMAPNamespaceList::GetFolderIsNamespace(</span>
<a href="#l20.11170"></a><span id="l20.11170" class="difflineminus">-                                        serverKey.get(), onlineName.get(),</span>
<a href="#l20.11171"></a><span id="l20.11171" class="difflineminus">-                                        hierarchyDelimiter, m_namespace) : false;</span>
<a href="#l20.11172"></a><span id="l20.11172" class="difflineplus">+                                          serverKey.get(), onlineName.get(),</span>
<a href="#l20.11173"></a><span id="l20.11173" class="difflineplus">+                                          hierarchyDelimiter, m_namespace)</span>
<a href="#l20.11174"></a><span id="l20.11174" class="difflineplus">+                                    : false;</span>
<a href="#l20.11175"></a><span id="l20.11175"> </span>
<a href="#l20.11176"></a><span id="l20.11176">   nsCOMPtr&lt;nsISimpleEnumerator&gt; enumerator;</span>
<a href="#l20.11177"></a><span id="l20.11177">   GetSubFolders(getter_AddRefs(enumerator));</span>
<a href="#l20.11178"></a><span id="l20.11178" class="difflineminus">-  if (!enumerator)</span>
<a href="#l20.11179"></a><span id="l20.11179" class="difflineminus">-    return NS_OK;</span>
<a href="#l20.11180"></a><span id="l20.11180" class="difflineplus">+  if (!enumerator) return NS_OK;</span>
<a href="#l20.11181"></a><span id="l20.11181"> </span>
<a href="#l20.11182"></a><span id="l20.11182">   nsresult rv;</span>
<a href="#l20.11183"></a><span id="l20.11183">   bool hasMore;</span>
<a href="#l20.11184"></a><span id="l20.11184" class="difflineminus">-  while (NS_SUCCEEDED(enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l20.11185"></a><span id="l20.11185" class="difflineminus">-  {</span>
<a href="#l20.11186"></a><span id="l20.11186" class="difflineplus">+  while (NS_SUCCEEDED(enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore) {</span>
<a href="#l20.11187"></a><span id="l20.11187">     nsCOMPtr&lt;nsISupports&gt; item;</span>
<a href="#l20.11188"></a><span id="l20.11188">     rv = enumerator-&gt;GetNext(getter_AddRefs(item));</span>
<a href="#l20.11189"></a><span id="l20.11189" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l20.11190"></a><span id="l20.11190" class="difflineminus">-      break;</span>
<a href="#l20.11191"></a><span id="l20.11191" class="difflineplus">+    if (NS_FAILED(rv)) break;</span>
<a href="#l20.11192"></a><span id="l20.11192"> </span>
<a href="#l20.11193"></a><span id="l20.11193">     nsCOMPtr&lt;nsIMsgImapMailFolder&gt; folder(do_QueryInterface(item, &amp;rv));</span>
<a href="#l20.11194"></a><span id="l20.11194" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l20.11195"></a><span id="l20.11195" class="difflineminus">-      return rv;</span>
<a href="#l20.11196"></a><span id="l20.11196" class="difflineplus">+    if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.11197"></a><span id="l20.11197"> </span>
<a href="#l20.11198"></a><span id="l20.11198">     folder-&gt;ResetNamespaceReferences();</span>
<a href="#l20.11199"></a><span id="l20.11199">   }</span>
<a href="#l20.11200"></a><span id="l20.11200">   return rv;</span>
<a href="#l20.11201"></a><span id="l20.11201"> }</span>
<a href="#l20.11202"></a><span id="l20.11202"> </span>
<a href="#l20.11203"></a><span id="l20.11203" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::FindOnlineSubFolder(const nsACString&amp; targetOnlineName, nsIMsgImapMailFolder **aResultFolder)</span>
<a href="#l20.11204"></a><span id="l20.11204" class="difflineminus">-{</span>
<a href="#l20.11205"></a><span id="l20.11205" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::FindOnlineSubFolder(</span>
<a href="#l20.11206"></a><span id="l20.11206" class="difflineplus">+    const nsACString &amp;targetOnlineName, nsIMsgImapMailFolder **aResultFolder) {</span>
<a href="#l20.11207"></a><span id="l20.11207">   nsresult rv = NS_OK;</span>
<a href="#l20.11208"></a><span id="l20.11208"> </span>
<a href="#l20.11209"></a><span id="l20.11209">   nsCString onlineName;</span>
<a href="#l20.11210"></a><span id="l20.11210">   GetOnlineName(onlineName);</span>
<a href="#l20.11211"></a><span id="l20.11211"> </span>
<a href="#l20.11212"></a><span id="l20.11212">   if (onlineName.Equals(targetOnlineName))</span>
<a href="#l20.11213"></a><span id="l20.11213" class="difflineminus">-    return QueryInterface(NS_GET_IID(nsIMsgImapMailFolder), (void **) aResultFolder);</span>
<a href="#l20.11214"></a><span id="l20.11214" class="difflineplus">+    return QueryInterface(NS_GET_IID(nsIMsgImapMailFolder),</span>
<a href="#l20.11215"></a><span id="l20.11215" class="difflineplus">+                          (void **)aResultFolder);</span>
<a href="#l20.11216"></a><span id="l20.11216"> </span>
<a href="#l20.11217"></a><span id="l20.11217">   nsCOMPtr&lt;nsISimpleEnumerator&gt; enumerator;</span>
<a href="#l20.11218"></a><span id="l20.11218">   GetSubFolders(getter_AddRefs(enumerator));</span>
<a href="#l20.11219"></a><span id="l20.11219" class="difflineminus">-  if (!enumerator)</span>
<a href="#l20.11220"></a><span id="l20.11220" class="difflineminus">-    return NS_OK;</span>
<a href="#l20.11221"></a><span id="l20.11221" class="difflineplus">+  if (!enumerator) return NS_OK;</span>
<a href="#l20.11222"></a><span id="l20.11222"> </span>
<a href="#l20.11223"></a><span id="l20.11223">   bool hasMore;</span>
<a href="#l20.11224"></a><span id="l20.11224" class="difflineminus">-  while (NS_SUCCEEDED(enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l20.11225"></a><span id="l20.11225" class="difflineminus">-  {</span>
<a href="#l20.11226"></a><span id="l20.11226" class="difflineplus">+  while (NS_SUCCEEDED(enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore) {</span>
<a href="#l20.11227"></a><span id="l20.11227">     nsCOMPtr&lt;nsISupports&gt; item;</span>
<a href="#l20.11228"></a><span id="l20.11228">     rv = enumerator-&gt;GetNext(getter_AddRefs(item));</span>
<a href="#l20.11229"></a><span id="l20.11229" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l20.11230"></a><span id="l20.11230" class="difflineminus">-      break;</span>
<a href="#l20.11231"></a><span id="l20.11231" class="difflineplus">+    if (NS_FAILED(rv)) break;</span>
<a href="#l20.11232"></a><span id="l20.11232"> </span>
<a href="#l20.11233"></a><span id="l20.11233">     nsCOMPtr&lt;nsIMsgImapMailFolder&gt; folder(do_QueryInterface(item, &amp;rv));</span>
<a href="#l20.11234"></a><span id="l20.11234" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l20.11235"></a><span id="l20.11235" class="difflineminus">-      return rv;</span>
<a href="#l20.11236"></a><span id="l20.11236" class="difflineplus">+    if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.11237"></a><span id="l20.11237"> </span>
<a href="#l20.11238"></a><span id="l20.11238">     rv = folder-&gt;FindOnlineSubFolder(targetOnlineName, aResultFolder);</span>
<a href="#l20.11239"></a><span id="l20.11239" class="difflineminus">-    if (*aResultFolder)</span>
<a href="#l20.11240"></a><span id="l20.11240" class="difflineminus">-     return rv;</span>
<a href="#l20.11241"></a><span id="l20.11241" class="difflineplus">+    if (*aResultFolder) return rv;</span>
<a href="#l20.11242"></a><span id="l20.11242">   }</span>
<a href="#l20.11243"></a><span id="l20.11243">   return rv;</span>
<a href="#l20.11244"></a><span id="l20.11244"> }</span>
<a href="#l20.11245"></a><span id="l20.11245"> </span>
<a href="#l20.11246"></a><span id="l20.11246" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetFolderNeedsAdded(bool *bVal)</span>
<a href="#l20.11247"></a><span id="l20.11247" class="difflineminus">-{</span>
<a href="#l20.11248"></a><span id="l20.11248" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetFolderNeedsAdded(bool *bVal) {</span>
<a href="#l20.11249"></a><span id="l20.11249">   NS_ENSURE_ARG_POINTER(bVal);</span>
<a href="#l20.11250"></a><span id="l20.11250">   *bVal = m_folderNeedsAdded;</span>
<a href="#l20.11251"></a><span id="l20.11251">   return NS_OK;</span>
<a href="#l20.11252"></a><span id="l20.11252"> }</span>
<a href="#l20.11253"></a><span id="l20.11253"> </span>
<a href="#l20.11254"></a><span id="l20.11254" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetFolderNeedsAdded(bool bVal)</span>
<a href="#l20.11255"></a><span id="l20.11255" class="difflineminus">-{</span>
<a href="#l20.11256"></a><span id="l20.11256" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetFolderNeedsAdded(bool bVal) {</span>
<a href="#l20.11257"></a><span id="l20.11257">   m_folderNeedsAdded = bVal;</span>
<a href="#l20.11258"></a><span id="l20.11258">   return NS_OK;</span>
<a href="#l20.11259"></a><span id="l20.11259"> }</span>
<a href="#l20.11260"></a><span id="l20.11260"> </span>
<a href="#l20.11261"></a><span id="l20.11261" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetFolderQuotaCommandIssued(bool *aCmdIssued)</span>
<a href="#l20.11262"></a><span id="l20.11262" class="difflineminus">-{</span>
<a href="#l20.11263"></a><span id="l20.11263" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetFolderQuotaCommandIssued(bool *aCmdIssued) {</span>
<a href="#l20.11264"></a><span id="l20.11264">   NS_ENSURE_ARG_POINTER(aCmdIssued);</span>
<a href="#l20.11265"></a><span id="l20.11265">   *aCmdIssued = m_folderQuotaCommandIssued;</span>
<a href="#l20.11266"></a><span id="l20.11266">   return NS_OK;</span>
<a href="#l20.11267"></a><span id="l20.11267"> }</span>
<a href="#l20.11268"></a><span id="l20.11268"> </span>
<a href="#l20.11269"></a><span id="l20.11269" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetFolderQuotaCommandIssued(bool aCmdIssued)</span>
<a href="#l20.11270"></a><span id="l20.11270" class="difflineminus">-{</span>
<a href="#l20.11271"></a><span id="l20.11271" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetFolderQuotaCommandIssued(bool aCmdIssued) {</span>
<a href="#l20.11272"></a><span id="l20.11272">   m_folderQuotaCommandIssued = aCmdIssued;</span>
<a href="#l20.11273"></a><span id="l20.11273">   return NS_OK;</span>
<a href="#l20.11274"></a><span id="l20.11274"> }</span>
<a href="#l20.11275"></a><span id="l20.11275"> </span>
<a href="#l20.11276"></a><span id="l20.11276" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::SetFolderQuotaData(const nsACString &amp;aFolderQuotaRoot,</span>
<a href="#l20.11277"></a><span id="l20.11277" class="difflineminus">-                                                   uint32_t aFolderQuotaUsedKB,</span>
<a href="#l20.11278"></a><span id="l20.11278" class="difflineminus">-                                                    uint32_t aFolderQuotaMaxKB)</span>
<a href="#l20.11279"></a><span id="l20.11279" class="difflineminus">-{</span>
<a href="#l20.11280"></a><span id="l20.11280" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::SetFolderQuotaData(</span>
<a href="#l20.11281"></a><span id="l20.11281" class="difflineplus">+    const nsACString &amp;aFolderQuotaRoot, uint32_t aFolderQuotaUsedKB,</span>
<a href="#l20.11282"></a><span id="l20.11282" class="difflineplus">+    uint32_t aFolderQuotaMaxKB) {</span>
<a href="#l20.11283"></a><span id="l20.11283">   m_folderQuotaDataIsValid = true;</span>
<a href="#l20.11284"></a><span id="l20.11284">   m_folderQuotaRoot = aFolderQuotaRoot;</span>
<a href="#l20.11285"></a><span id="l20.11285">   m_folderQuotaUsedKB = aFolderQuotaUsedKB;</span>
<a href="#l20.11286"></a><span id="l20.11286">   m_folderQuotaMaxKB = aFolderQuotaMaxKB;</span>
<a href="#l20.11287"></a><span id="l20.11287">   return NS_OK;</span>
<a href="#l20.11288"></a><span id="l20.11288"> }</span>
<a href="#l20.11289"></a><span id="l20.11289"> </span>
<a href="#l20.11290"></a><span id="l20.11290" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetQuota(bool* aValid,</span>
<a href="#l20.11291"></a><span id="l20.11291" class="difflineminus">-                                         uint32_t* aUsed, uint32_t* aMax)</span>
<a href="#l20.11292"></a><span id="l20.11292" class="difflineminus">-{</span>
<a href="#l20.11293"></a><span id="l20.11293" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetQuota(bool *aValid, uint32_t *aUsed,</span>
<a href="#l20.11294"></a><span id="l20.11294" class="difflineplus">+                                         uint32_t *aMax) {</span>
<a href="#l20.11295"></a><span id="l20.11295">   NS_ENSURE_ARG_POINTER(aValid);</span>
<a href="#l20.11296"></a><span id="l20.11296">   NS_ENSURE_ARG_POINTER(aUsed);</span>
<a href="#l20.11297"></a><span id="l20.11297">   NS_ENSURE_ARG_POINTER(aMax);</span>
<a href="#l20.11298"></a><span id="l20.11298">   *aValid = m_folderQuotaDataIsValid;</span>
<a href="#l20.11299"></a><span id="l20.11299">   *aUsed = m_folderQuotaUsedKB;</span>
<a href="#l20.11300"></a><span id="l20.11300">   *aMax = m_folderQuotaMaxKB;</span>
<a href="#l20.11301"></a><span id="l20.11301">   return NS_OK;</span>
<a href="#l20.11302"></a><span id="l20.11302"> }</span>
<a href="#l20.11303"></a><span id="l20.11303"> </span>
<a href="#l20.11304"></a><span id="l20.11304" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::PerformExpand(nsIMsgWindow *aMsgWindow)</span>
<a href="#l20.11305"></a><span id="l20.11305" class="difflineminus">-{</span>
<a href="#l20.11306"></a><span id="l20.11306" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::PerformExpand(nsIMsgWindow *aMsgWindow) {</span>
<a href="#l20.11307"></a><span id="l20.11307">   nsresult rv;</span>
<a href="#l20.11308"></a><span id="l20.11308">   bool usingSubscription = false;</span>
<a href="#l20.11309"></a><span id="l20.11309">   nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.11310"></a><span id="l20.11310">   rv = GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.11311"></a><span id="l20.11311">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11312"></a><span id="l20.11312">   rv = imapServer-&gt;GetUsingSubscription(&amp;usingSubscription);</span>
<a href="#l20.11313"></a><span id="l20.11313" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; !usingSubscription)</span>
<a href="#l20.11314"></a><span id="l20.11314" class="difflineminus">-  {</span>
<a href="#l20.11315"></a><span id="l20.11315" class="difflineminus">-    nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.11316"></a><span id="l20.11316" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; !usingSubscription) {</span>
<a href="#l20.11317"></a><span id="l20.11317" class="difflineplus">+    nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.11318"></a><span id="l20.11318" class="difflineplus">+        do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.11319"></a><span id="l20.11319">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11320"></a><span id="l20.11320" class="difflineminus">-    rv = imapService-&gt;DiscoverChildren( this, this, m_onlineFolderName, nullptr);</span>
<a href="#l20.11321"></a><span id="l20.11321" class="difflineplus">+    rv = imapService-&gt;DiscoverChildren(this, this, m_onlineFolderName, nullptr);</span>
<a href="#l20.11322"></a><span id="l20.11322">   }</span>
<a href="#l20.11323"></a><span id="l20.11323">   return rv;</span>
<a href="#l20.11324"></a><span id="l20.11324"> }</span>
<a href="#l20.11325"></a><span id="l20.11325"> </span>
<a href="#l20.11326"></a><span id="l20.11326" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::RenameClient(nsIMsgWindow *msgWindow, nsIMsgFolder *msgFolder, const nsACString&amp; oldName, const nsACString&amp; newName)</span>
<a href="#l20.11327"></a><span id="l20.11327" class="difflineminus">-{</span>
<a href="#l20.11328"></a><span id="l20.11328" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::RenameClient(nsIMsgWindow *msgWindow,</span>
<a href="#l20.11329"></a><span id="l20.11329" class="difflineplus">+                                             nsIMsgFolder *msgFolder,</span>
<a href="#l20.11330"></a><span id="l20.11330" class="difflineplus">+                                             const nsACString &amp;oldName,</span>
<a href="#l20.11331"></a><span id="l20.11331" class="difflineplus">+                                             const nsACString &amp;newName) {</span>
<a href="#l20.11332"></a><span id="l20.11332">   nsresult rv;</span>
<a href="#l20.11333"></a><span id="l20.11333">   nsCOMPtr&lt;nsIFile&gt; pathFile;</span>
<a href="#l20.11334"></a><span id="l20.11334">   rv = GetFilePath(getter_AddRefs(pathFile));</span>
<a href="#l20.11335"></a><span id="l20.11335">   if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.11336"></a><span id="l20.11336"> </span>
<a href="#l20.11337"></a><span id="l20.11337" class="difflineminus">-  nsCOMPtr&lt;nsIMsgImapMailFolder&gt; oldImapFolder = do_QueryInterface(msgFolder, &amp;rv);</span>
<a href="#l20.11338"></a><span id="l20.11338" class="difflineplus">+  nsCOMPtr&lt;nsIMsgImapMailFolder&gt; oldImapFolder =</span>
<a href="#l20.11339"></a><span id="l20.11339" class="difflineplus">+      do_QueryInterface(msgFolder, &amp;rv);</span>
<a href="#l20.11340"></a><span id="l20.11340">   if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.11341"></a><span id="l20.11341"> </span>
<a href="#l20.11342"></a><span id="l20.11342">   char hierarchyDelimiter = '/';</span>
<a href="#l20.11343"></a><span id="l20.11343">   oldImapFolder-&gt;GetHierarchyDelimiter(&amp;hierarchyDelimiter);</span>
<a href="#l20.11344"></a><span id="l20.11344" class="difflineminus">-  int32_t boxflags=0;</span>
<a href="#l20.11345"></a><span id="l20.11345" class="difflineplus">+  int32_t boxflags = 0;</span>
<a href="#l20.11346"></a><span id="l20.11346">   oldImapFolder-&gt;GetBoxFlags(&amp;boxflags);</span>
<a href="#l20.11347"></a><span id="l20.11347"> </span>
<a href="#l20.11348"></a><span id="l20.11348">   nsAutoString newLeafName;</span>
<a href="#l20.11349"></a><span id="l20.11349">   NS_ConvertASCIItoUTF16 newNameString(newName);</span>
<a href="#l20.11350"></a><span id="l20.11350">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11351"></a><span id="l20.11351">   newLeafName = newNameString;</span>
<a href="#l20.11352"></a><span id="l20.11352">   nsAutoString folderNameStr;</span>
<a href="#l20.11353"></a><span id="l20.11353" class="difflineminus">-  int32_t folderStart = newLeafName.RFindChar('/');  //internal use of hierarchyDelimiter is always '/'</span>
<a href="#l20.11354"></a><span id="l20.11354" class="difflineminus">-  if (folderStart &gt; 0)</span>
<a href="#l20.11355"></a><span id="l20.11355" class="difflineminus">-  {</span>
<a href="#l20.11356"></a><span id="l20.11356" class="difflineplus">+  int32_t folderStart = newLeafName.RFindChar(</span>
<a href="#l20.11357"></a><span id="l20.11357" class="difflineplus">+      '/');  // internal use of hierarchyDelimiter is always '/'</span>
<a href="#l20.11358"></a><span id="l20.11358" class="difflineplus">+  if (folderStart &gt; 0) {</span>
<a href="#l20.11359"></a><span id="l20.11359">     newLeafName = Substring(newNameString, folderStart + 1);</span>
<a href="#l20.11360"></a><span id="l20.11360" class="difflineminus">-    CreateDirectoryForFolder(getter_AddRefs(pathFile));    //needed when we move a folder to a folder with no subfolders.</span>
<a href="#l20.11361"></a><span id="l20.11361" class="difflineplus">+    CreateDirectoryForFolder(</span>
<a href="#l20.11362"></a><span id="l20.11362" class="difflineplus">+        getter_AddRefs(pathFile));  // needed when we move a folder to a folder</span>
<a href="#l20.11363"></a><span id="l20.11363" class="difflineplus">+                                    // with no subfolders.</span>
<a href="#l20.11364"></a><span id="l20.11364">   }</span>
<a href="#l20.11365"></a><span id="l20.11365"> </span>
<a href="#l20.11366"></a><span id="l20.11366">   // if we get here, it's really a leaf, and &quot;this&quot; is the parent.</span>
<a href="#l20.11367"></a><span id="l20.11367">   folderNameStr = newLeafName;</span>
<a href="#l20.11368"></a><span id="l20.11368"> </span>
<a href="#l20.11369"></a><span id="l20.11369">   // Create an empty database for this mail folder, set its name from the user</span>
<a href="#l20.11370"></a><span id="l20.11370">   nsCOMPtr&lt;nsIMsgDatabase&gt; mailDBFactory;</span>
<a href="#l20.11371"></a><span id="l20.11371">   nsCOMPtr&lt;nsIMsgFolder&gt; child;</span>
<a href="#l20.11372"></a><span id="l20.11372" class="difflineminus">-  nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder;</span>
<a href="#l20.11373"></a><span id="l20.11373" class="difflineminus">-</span>
<a href="#l20.11374"></a><span id="l20.11374" class="difflineminus">-  nsCOMPtr&lt;nsIMsgDBService&gt; msgDBService = do_GetService(NS_MSGDB_SERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.11375"></a><span id="l20.11375" class="difflineplus">+  nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder;</span>
<a href="#l20.11376"></a><span id="l20.11376" class="difflineplus">+</span>
<a href="#l20.11377"></a><span id="l20.11377" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBService&gt; msgDBService =</span>
<a href="#l20.11378"></a><span id="l20.11378" class="difflineplus">+      do_GetService(NS_MSGDB_SERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.11379"></a><span id="l20.11379">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11380"></a><span id="l20.11380"> </span>
<a href="#l20.11381"></a><span id="l20.11381">   nsCOMPtr&lt;nsIMsgDatabase&gt; unusedDB;</span>
<a href="#l20.11382"></a><span id="l20.11382" class="difflineminus">-  nsCOMPtr &lt;nsIFile&gt; dbFile;</span>
<a href="#l20.11383"></a><span id="l20.11383" class="difflineplus">+  nsCOMPtr&lt;nsIFile&gt; dbFile;</span>
<a href="#l20.11384"></a><span id="l20.11384"> </span>
<a href="#l20.11385"></a><span id="l20.11385">   // warning, path will be changed</span>
<a href="#l20.11386"></a><span id="l20.11386">   rv = CreateFileForDB(folderNameStr, pathFile, getter_AddRefs(dbFile));</span>
<a href="#l20.11387"></a><span id="l20.11387" class="difflineminus">-  NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.11388"></a><span id="l20.11388" class="difflineminus">-</span>
<a href="#l20.11389"></a><span id="l20.11389" class="difflineminus">-  // Use openMailDBFromFile() and not OpenFolderDB() here, since we don't use the DB.</span>
<a href="#l20.11390"></a><span id="l20.11390" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11391"></a><span id="l20.11391" class="difflineplus">+</span>
<a href="#l20.11392"></a><span id="l20.11392" class="difflineplus">+  // Use openMailDBFromFile() and not OpenFolderDB() here, since we don't use</span>
<a href="#l20.11393"></a><span id="l20.11393" class="difflineplus">+  // the DB.</span>
<a href="#l20.11394"></a><span id="l20.11394">   rv = msgDBService-&gt;OpenMailDBFromFile(dbFile, nullptr, true, true,</span>
<a href="#l20.11395"></a><span id="l20.11395">                                         getter_AddRefs(unusedDB));</span>
<a href="#l20.11396"></a><span id="l20.11396" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; unusedDB)</span>
<a href="#l20.11397"></a><span id="l20.11397" class="difflineminus">-  {</span>
<a href="#l20.11398"></a><span id="l20.11398" class="difflineminus">-    //need to set the folder name</span>
<a href="#l20.11399"></a><span id="l20.11399" class="difflineminus">-    nsCOMPtr &lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l20.11400"></a><span id="l20.11400" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; unusedDB) {</span>
<a href="#l20.11401"></a><span id="l20.11401" class="difflineplus">+    // need to set the folder name</span>
<a href="#l20.11402"></a><span id="l20.11402" class="difflineplus">+    nsCOMPtr&lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l20.11403"></a><span id="l20.11403">     rv = unusedDB-&gt;GetDBFolderInfo(getter_AddRefs(folderInfo));</span>
<a href="#l20.11404"></a><span id="l20.11404"> </span>
<a href="#l20.11405"></a><span id="l20.11405" class="difflineminus">-    //Now let's create the actual new folder</span>
<a href="#l20.11406"></a><span id="l20.11406" class="difflineplus">+    // Now let's create the actual new folder</span>
<a href="#l20.11407"></a><span id="l20.11407">     rv = AddSubfolderWithPath(folderNameStr, dbFile, getter_AddRefs(child));</span>
<a href="#l20.11408"></a><span id="l20.11408" class="difflineminus">-    if (!child || NS_FAILED(rv))</span>
<a href="#l20.11409"></a><span id="l20.11409" class="difflineminus">-      return rv;</span>
<a href="#l20.11410"></a><span id="l20.11410" class="difflineplus">+    if (!child || NS_FAILED(rv)) return rv;</span>
<a href="#l20.11411"></a><span id="l20.11411">     nsAutoString unicodeName;</span>
<a href="#l20.11412"></a><span id="l20.11412" class="difflineminus">-    rv = CopyMUTF7toUTF16(NS_LossyConvertUTF16toASCII(folderNameStr), unicodeName);</span>
<a href="#l20.11413"></a><span id="l20.11413" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l20.11414"></a><span id="l20.11414" class="difflineminus">-      child-&gt;SetPrettyName(unicodeName);</span>
<a href="#l20.11415"></a><span id="l20.11415" class="difflineplus">+    rv = CopyMUTF7toUTF16(NS_LossyConvertUTF16toASCII(folderNameStr),</span>
<a href="#l20.11416"></a><span id="l20.11416" class="difflineplus">+                          unicodeName);</span>
<a href="#l20.11417"></a><span id="l20.11417" class="difflineplus">+    if (NS_SUCCEEDED(rv)) child-&gt;SetPrettyName(unicodeName);</span>
<a href="#l20.11418"></a><span id="l20.11418">     imapFolder = do_QueryInterface(child);</span>
<a href="#l20.11419"></a><span id="l20.11419" class="difflineminus">-    if (imapFolder)</span>
<a href="#l20.11420"></a><span id="l20.11420" class="difflineminus">-    {</span>
<a href="#l20.11421"></a><span id="l20.11421" class="difflineplus">+    if (imapFolder) {</span>
<a href="#l20.11422"></a><span id="l20.11422">       nsAutoCString onlineName(m_onlineFolderName);</span>
<a href="#l20.11423"></a><span id="l20.11423"> </span>
<a href="#l20.11424"></a><span id="l20.11424" class="difflineminus">-      if (!onlineName.IsEmpty())</span>
<a href="#l20.11425"></a><span id="l20.11425" class="difflineminus">-        onlineName.Append(hierarchyDelimiter);</span>
<a href="#l20.11426"></a><span id="l20.11426" class="difflineplus">+      if (!onlineName.IsEmpty()) onlineName.Append(hierarchyDelimiter);</span>
<a href="#l20.11427"></a><span id="l20.11427">       onlineName.Append(NS_LossyConvertUTF16toASCII(folderNameStr));</span>
<a href="#l20.11428"></a><span id="l20.11428">       imapFolder-&gt;SetVerifiedAsOnlineFolder(true);</span>
<a href="#l20.11429"></a><span id="l20.11429">       imapFolder-&gt;SetOnlineName(onlineName);</span>
<a href="#l20.11430"></a><span id="l20.11430">       imapFolder-&gt;SetHierarchyDelimiter(hierarchyDelimiter);</span>
<a href="#l20.11431"></a><span id="l20.11431">       imapFolder-&gt;SetBoxFlags(boxflags);</span>
<a href="#l20.11432"></a><span id="l20.11432">       // store the online name as the mailbox name in the db folder info</span>
<a href="#l20.11433"></a><span id="l20.11433">       // I don't think anyone uses the mailbox name, so we'll use it</span>
<a href="#l20.11434"></a><span id="l20.11434">       // to restore the online name when blowing away an imap db.</span>
<a href="#l20.11435"></a><span id="l20.11435" class="difflineminus">-      if (folderInfo)</span>
<a href="#l20.11436"></a><span id="l20.11436" class="difflineminus">-      {</span>
<a href="#l20.11437"></a><span id="l20.11437" class="difflineplus">+      if (folderInfo) {</span>
<a href="#l20.11438"></a><span id="l20.11438">         nsAutoString unicodeOnlineName;</span>
<a href="#l20.11439"></a><span id="l20.11439">         CopyASCIItoUTF16(onlineName, unicodeOnlineName);</span>
<a href="#l20.11440"></a><span id="l20.11440">         folderInfo-&gt;SetMailboxName(unicodeOnlineName);</span>
<a href="#l20.11441"></a><span id="l20.11441">       }</span>
<a href="#l20.11442"></a><span id="l20.11442">       bool changed = false;</span>
<a href="#l20.11443"></a><span id="l20.11443" class="difflineminus">-      msgFolder-&gt;MatchOrChangeFilterDestination(child, false /*caseInsensitive*/, &amp;changed);</span>
<a href="#l20.11444"></a><span id="l20.11444" class="difflineminus">-      if (changed)</span>
<a href="#l20.11445"></a><span id="l20.11445" class="difflineminus">-        msgFolder-&gt;AlertFilterChanged(msgWindow);</span>
<a href="#l20.11446"></a><span id="l20.11446" class="difflineplus">+      msgFolder-&gt;MatchOrChangeFilterDestination(</span>
<a href="#l20.11447"></a><span id="l20.11447" class="difflineplus">+          child, false /*caseInsensitive*/, &amp;changed);</span>
<a href="#l20.11448"></a><span id="l20.11448" class="difflineplus">+      if (changed) msgFolder-&gt;AlertFilterChanged(msgWindow);</span>
<a href="#l20.11449"></a><span id="l20.11449">     }</span>
<a href="#l20.11450"></a><span id="l20.11450">     unusedDB-&gt;SetSummaryValid(true);</span>
<a href="#l20.11451"></a><span id="l20.11451">     unusedDB-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.11452"></a><span id="l20.11452">     unusedDB-&gt;Close(true);</span>
<a href="#l20.11453"></a><span id="l20.11453">     child-&gt;RenameSubFolders(msgWindow, msgFolder);</span>
<a href="#l20.11454"></a><span id="l20.11454">     nsCOMPtr&lt;nsIMsgFolder&gt; msgParent;</span>
<a href="#l20.11455"></a><span id="l20.11455">     msgFolder-&gt;GetParent(getter_AddRefs(msgParent));</span>
<a href="#l20.11456"></a><span id="l20.11456">     msgFolder-&gt;SetParent(nullptr);</span>
<a href="#l20.11457"></a><span id="l20.11457">     // Reset online status now that the folder is renamed.</span>
<a href="#l20.11458"></a><span id="l20.11458" class="difflineminus">-    nsCOMPtr &lt;nsIMsgImapMailFolder&gt; oldImapFolder = do_QueryInterface(msgFolder);</span>
<a href="#l20.11459"></a><span id="l20.11459" class="difflineminus">-    if (oldImapFolder)</span>
<a href="#l20.11460"></a><span id="l20.11460" class="difflineminus">-      oldImapFolder-&gt;SetVerifiedAsOnlineFolder(false);</span>
<a href="#l20.11461"></a><span id="l20.11461" class="difflineminus">-    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.11462"></a><span id="l20.11462" class="difflineminus">-    if (notifier)</span>
<a href="#l20.11463"></a><span id="l20.11463" class="difflineminus">-      notifier-&gt;NotifyFolderRenamed(msgFolder, child);</span>
<a href="#l20.11464"></a><span id="l20.11464" class="difflineminus">-</span>
<a href="#l20.11465"></a><span id="l20.11465" class="difflineminus">-    // Do not propagate the deletion until after we have (synchronously) notified</span>
<a href="#l20.11466"></a><span id="l20.11466" class="difflineminus">-    // all listeners about the rename.  This allows them to access properties on</span>
<a href="#l20.11467"></a><span id="l20.11467" class="difflineminus">-    // the source folder without experiencing failures.</span>
<a href="#l20.11468"></a><span id="l20.11468" class="difflineminus">-    if (msgParent)</span>
<a href="#l20.11469"></a><span id="l20.11469" class="difflineminus">-      msgParent-&gt;PropagateDelete(msgFolder, true, nullptr);</span>
<a href="#l20.11470"></a><span id="l20.11470" class="difflineplus">+    nsCOMPtr&lt;nsIMsgImapMailFolder&gt; oldImapFolder = do_QueryInterface(msgFolder);</span>
<a href="#l20.11471"></a><span id="l20.11471" class="difflineplus">+    if (oldImapFolder) oldImapFolder-&gt;SetVerifiedAsOnlineFolder(false);</span>
<a href="#l20.11472"></a><span id="l20.11472" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(</span>
<a href="#l20.11473"></a><span id="l20.11473" class="difflineplus">+        do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l20.11474"></a><span id="l20.11474" class="difflineplus">+    if (notifier) notifier-&gt;NotifyFolderRenamed(msgFolder, child);</span>
<a href="#l20.11475"></a><span id="l20.11475" class="difflineplus">+</span>
<a href="#l20.11476"></a><span id="l20.11476" class="difflineplus">+    // Do not propagate the deletion until after we have (synchronously)</span>
<a href="#l20.11477"></a><span id="l20.11477" class="difflineplus">+    // notified all listeners about the rename.  This allows them to access</span>
<a href="#l20.11478"></a><span id="l20.11478" class="difflineplus">+    // properties on the source folder without experiencing failures.</span>
<a href="#l20.11479"></a><span id="l20.11479" class="difflineplus">+    if (msgParent) msgParent-&gt;PropagateDelete(msgFolder, true, nullptr);</span>
<a href="#l20.11480"></a><span id="l20.11480">     NotifyItemAdded(child);</span>
<a href="#l20.11481"></a><span id="l20.11481">   }</span>
<a href="#l20.11482"></a><span id="l20.11482">   return rv;</span>
<a href="#l20.11483"></a><span id="l20.11483"> }</span>
<a href="#l20.11484"></a><span id="l20.11484"> </span>
<a href="#l20.11485"></a><span id="l20.11485" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::RenameSubFolders(nsIMsgWindow *msgWindow, nsIMsgFolder *oldFolder)</span>
<a href="#l20.11486"></a><span id="l20.11486" class="difflineminus">-{</span>
<a href="#l20.11487"></a><span id="l20.11487" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::RenameSubFolders(nsIMsgWindow *msgWindow,</span>
<a href="#l20.11488"></a><span id="l20.11488" class="difflineplus">+                                                 nsIMsgFolder *oldFolder) {</span>
<a href="#l20.11489"></a><span id="l20.11489">   m_initialized = true;</span>
<a href="#l20.11490"></a><span id="l20.11490">   nsCOMPtr&lt;nsISimpleEnumerator&gt; enumerator;</span>
<a href="#l20.11491"></a><span id="l20.11491">   nsresult rv = oldFolder-&gt;GetSubFolders(getter_AddRefs(enumerator));</span>
<a href="#l20.11492"></a><span id="l20.11492">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11493"></a><span id="l20.11493"> </span>
<a href="#l20.11494"></a><span id="l20.11494">   bool hasMore;</span>
<a href="#l20.11495"></a><span id="l20.11495" class="difflineminus">-  while (NS_SUCCEEDED(enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l20.11496"></a><span id="l20.11496" class="difflineminus">-  {</span>
<a href="#l20.11497"></a><span id="l20.11497" class="difflineplus">+  while (NS_SUCCEEDED(enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore) {</span>
<a href="#l20.11498"></a><span id="l20.11498">     nsCOMPtr&lt;nsISupports&gt; item;</span>
<a href="#l20.11499"></a><span id="l20.11499" class="difflineminus">-    if (NS_FAILED(enumerator-&gt;GetNext(getter_AddRefs(item))))</span>
<a href="#l20.11500"></a><span id="l20.11500" class="difflineminus">-      continue;</span>
<a href="#l20.11501"></a><span id="l20.11501" class="difflineplus">+    if (NS_FAILED(enumerator-&gt;GetNext(getter_AddRefs(item)))) continue;</span>
<a href="#l20.11502"></a><span id="l20.11502"> </span>
<a href="#l20.11503"></a><span id="l20.11503">     nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder(do_QueryInterface(item, &amp;rv));</span>
<a href="#l20.11504"></a><span id="l20.11504" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l20.11505"></a><span id="l20.11505" class="difflineminus">-      return rv;</span>
<a href="#l20.11506"></a><span id="l20.11506" class="difflineplus">+    if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.11507"></a><span id="l20.11507"> </span>
<a href="#l20.11508"></a><span id="l20.11508">     nsCOMPtr&lt;nsIMsgImapMailFolder&gt; folder(do_QueryInterface(msgFolder, &amp;rv));</span>
<a href="#l20.11509"></a><span id="l20.11509" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l20.11510"></a><span id="l20.11510" class="difflineminus">-      return rv;</span>
<a href="#l20.11511"></a><span id="l20.11511" class="difflineplus">+    if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.11512"></a><span id="l20.11512"> </span>
<a href="#l20.11513"></a><span id="l20.11513">     char hierarchyDelimiter = '/';</span>
<a href="#l20.11514"></a><span id="l20.11514">     folder-&gt;GetHierarchyDelimiter(&amp;hierarchyDelimiter);</span>
<a href="#l20.11515"></a><span id="l20.11515"> </span>
<a href="#l20.11516"></a><span id="l20.11516">     int32_t boxflags;</span>
<a href="#l20.11517"></a><span id="l20.11517">     folder-&gt;GetBoxFlags(&amp;boxflags);</span>
<a href="#l20.11518"></a><span id="l20.11518"> </span>
<a href="#l20.11519"></a><span id="l20.11519">     bool verified;</span>
<a href="#l20.11520"></a><span id="l20.11520" class="difflineat">@@ -8855,17 +8091,18 @@ NS_IMETHODIMP nsImapMailFolder::RenameSu</span>
<a href="#l20.11521"></a><span id="l20.11521">     rv = GetFilePath(getter_AddRefs(newParentPathFile));</span>
<a href="#l20.11522"></a><span id="l20.11522">     if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.11523"></a><span id="l20.11523"> </span>
<a href="#l20.11524"></a><span id="l20.11524">     rv = AddDirectorySeparator(newParentPathFile);</span>
<a href="#l20.11525"></a><span id="l20.11525">     nsAutoCString oldLeafName;</span>
<a href="#l20.11526"></a><span id="l20.11526">     oldPathFile-&gt;GetNativeLeafName(oldLeafName);</span>
<a href="#l20.11527"></a><span id="l20.11527">     newParentPathFile-&gt;AppendNative(oldLeafName);</span>
<a href="#l20.11528"></a><span id="l20.11528"> </span>
<a href="#l20.11529"></a><span id="l20.11529" class="difflineminus">-    nsCOMPtr&lt;nsIFile&gt; newPathFile = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID, &amp;rv);</span>
<a href="#l20.11530"></a><span id="l20.11530" class="difflineplus">+    nsCOMPtr&lt;nsIFile&gt; newPathFile =</span>
<a href="#l20.11531"></a><span id="l20.11531" class="difflineplus">+        do_CreateInstance(NS_LOCAL_FILE_CONTRACTID, &amp;rv);</span>
<a href="#l20.11532"></a><span id="l20.11532">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11533"></a><span id="l20.11533">     newPathFile-&gt;InitWithFile(newParentPathFile);</span>
<a href="#l20.11534"></a><span id="l20.11534"> </span>
<a href="#l20.11535"></a><span id="l20.11535">     nsCOMPtr&lt;nsIFile&gt; dbFilePath = newPathFile;</span>
<a href="#l20.11536"></a><span id="l20.11536"> </span>
<a href="#l20.11537"></a><span id="l20.11537">     nsCOMPtr&lt;nsIMsgFolder&gt; child;</span>
<a href="#l20.11538"></a><span id="l20.11538"> </span>
<a href="#l20.11539"></a><span id="l20.11539">     nsString folderName;</span>
<a href="#l20.11540"></a><span id="l20.11540" class="difflineat">@@ -8875,657 +8112,622 @@ NS_IMETHODIMP nsImapMailFolder::RenameSu</span>
<a href="#l20.11541"></a><span id="l20.11541">     nsCString utf7LeafName;</span>
<a href="#l20.11542"></a><span id="l20.11542">     rv = CopyUTF16toMUTF7(folderName, utf7LeafName);</span>
<a href="#l20.11543"></a><span id="l20.11543">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11544"></a><span id="l20.11544"> </span>
<a href="#l20.11545"></a><span id="l20.11545">     // XXX : Fix this non-sense by fixing AddSubfolderWithPath</span>
<a href="#l20.11546"></a><span id="l20.11546">     nsAutoString unicodeLeafName;</span>
<a href="#l20.11547"></a><span id="l20.11547">     CopyASCIItoUTF16(utf7LeafName, unicodeLeafName);</span>
<a href="#l20.11548"></a><span id="l20.11548"> </span>
<a href="#l20.11549"></a><span id="l20.11549" class="difflineminus">-    rv = AddSubfolderWithPath(unicodeLeafName, dbFilePath, getter_AddRefs(child));</span>
<a href="#l20.11550"></a><span id="l20.11550" class="difflineplus">+    rv = AddSubfolderWithPath(unicodeLeafName, dbFilePath,</span>
<a href="#l20.11551"></a><span id="l20.11551" class="difflineplus">+                              getter_AddRefs(child));</span>
<a href="#l20.11552"></a><span id="l20.11552">     if (!child || NS_FAILED(rv)) return rv;</span>
<a href="#l20.11553"></a><span id="l20.11553"> </span>
<a href="#l20.11554"></a><span id="l20.11554">     child-&gt;SetName(folderName);</span>
<a href="#l20.11555"></a><span id="l20.11555" class="difflineminus">-    nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(child);</span>
<a href="#l20.11556"></a><span id="l20.11556" class="difflineplus">+    nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(child);</span>
<a href="#l20.11557"></a><span id="l20.11557">     nsCString onlineName;</span>
<a href="#l20.11558"></a><span id="l20.11558">     GetOnlineName(onlineName);</span>
<a href="#l20.11559"></a><span id="l20.11559">     nsAutoCString onlineCName(onlineName);</span>
<a href="#l20.11560"></a><span id="l20.11560">     onlineCName.Append(hierarchyDelimiter);</span>
<a href="#l20.11561"></a><span id="l20.11561">     onlineCName.Append(utf7LeafName);</span>
<a href="#l20.11562"></a><span id="l20.11562" class="difflineminus">-    if (imapFolder)</span>
<a href="#l20.11563"></a><span id="l20.11563" class="difflineminus">-    {</span>
<a href="#l20.11564"></a><span id="l20.11564" class="difflineminus">-     imapFolder-&gt;SetVerifiedAsOnlineFolder(verified);</span>
<a href="#l20.11565"></a><span id="l20.11565" class="difflineminus">-     imapFolder-&gt;SetOnlineName(onlineCName);</span>
<a href="#l20.11566"></a><span id="l20.11566" class="difflineminus">-     imapFolder-&gt;SetHierarchyDelimiter(hierarchyDelimiter);</span>
<a href="#l20.11567"></a><span id="l20.11567" class="difflineminus">-     imapFolder-&gt;SetBoxFlags(boxflags);</span>
<a href="#l20.11568"></a><span id="l20.11568" class="difflineminus">-</span>
<a href="#l20.11569"></a><span id="l20.11569" class="difflineminus">-     bool changed = false;</span>
<a href="#l20.11570"></a><span id="l20.11570" class="difflineminus">-     msgFolder-&gt;MatchOrChangeFilterDestination(child, false /*caseInsensitive*/, &amp;changed);</span>
<a href="#l20.11571"></a><span id="l20.11571" class="difflineminus">-     if (changed)</span>
<a href="#l20.11572"></a><span id="l20.11572" class="difflineminus">-       msgFolder-&gt;AlertFilterChanged(msgWindow);</span>
<a href="#l20.11573"></a><span id="l20.11573" class="difflineminus">-     child-&gt;RenameSubFolders(msgWindow, msgFolder);</span>
<a href="#l20.11574"></a><span id="l20.11574" class="difflineplus">+    if (imapFolder) {</span>
<a href="#l20.11575"></a><span id="l20.11575" class="difflineplus">+      imapFolder-&gt;SetVerifiedAsOnlineFolder(verified);</span>
<a href="#l20.11576"></a><span id="l20.11576" class="difflineplus">+      imapFolder-&gt;SetOnlineName(onlineCName);</span>
<a href="#l20.11577"></a><span id="l20.11577" class="difflineplus">+      imapFolder-&gt;SetHierarchyDelimiter(hierarchyDelimiter);</span>
<a href="#l20.11578"></a><span id="l20.11578" class="difflineplus">+      imapFolder-&gt;SetBoxFlags(boxflags);</span>
<a href="#l20.11579"></a><span id="l20.11579" class="difflineplus">+</span>
<a href="#l20.11580"></a><span id="l20.11580" class="difflineplus">+      bool changed = false;</span>
<a href="#l20.11581"></a><span id="l20.11581" class="difflineplus">+      msgFolder-&gt;MatchOrChangeFilterDestination(</span>
<a href="#l20.11582"></a><span id="l20.11582" class="difflineplus">+          child, false /*caseInsensitive*/, &amp;changed);</span>
<a href="#l20.11583"></a><span id="l20.11583" class="difflineplus">+      if (changed) msgFolder-&gt;AlertFilterChanged(msgWindow);</span>
<a href="#l20.11584"></a><span id="l20.11584" class="difflineplus">+      child-&gt;RenameSubFolders(msgWindow, msgFolder);</span>
<a href="#l20.11585"></a><span id="l20.11585">     }</span>
<a href="#l20.11586"></a><span id="l20.11586">   }</span>
<a href="#l20.11587"></a><span id="l20.11587">   return rv;</span>
<a href="#l20.11588"></a><span id="l20.11588"> }</span>
<a href="#l20.11589"></a><span id="l20.11589"> </span>
<a href="#l20.11590"></a><span id="l20.11590" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::IsCommandEnabled(const nsACString&amp; command, bool *result)</span>
<a href="#l20.11591"></a><span id="l20.11591" class="difflineminus">-{</span>
<a href="#l20.11592"></a><span id="l20.11592" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::IsCommandEnabled(const nsACString &amp;command,</span>
<a href="#l20.11593"></a><span id="l20.11593" class="difflineplus">+                                                 bool *result) {</span>
<a href="#l20.11594"></a><span id="l20.11594">   NS_ENSURE_ARG_POINTER(result);</span>
<a href="#l20.11595"></a><span id="l20.11595">   *result = !(WeAreOffline() &amp;&amp; (command.EqualsLiteral(&quot;cmd_renameFolder&quot;) ||</span>
<a href="#l20.11596"></a><span id="l20.11596">                                  command.EqualsLiteral(&quot;cmd_compactFolder&quot;) ||</span>
<a href="#l20.11597"></a><span id="l20.11597">                                  command.EqualsLiteral(&quot;button_compact&quot;) ||</span>
<a href="#l20.11598"></a><span id="l20.11598">                                  command.EqualsLiteral(&quot;cmd_delete&quot;) ||</span>
<a href="#l20.11599"></a><span id="l20.11599">                                  command.EqualsLiteral(&quot;button_delete&quot;)));</span>
<a href="#l20.11600"></a><span id="l20.11600">   return NS_OK;</span>
<a href="#l20.11601"></a><span id="l20.11601"> }</span>
<a href="#l20.11602"></a><span id="l20.11602"> </span>
<a href="#l20.11603"></a><span id="l20.11603"> NS_IMETHODIMP</span>
<a href="#l20.11604"></a><span id="l20.11604" class="difflineminus">-nsImapMailFolder::GetCanFileMessages(bool *aCanFileMessages)</span>
<a href="#l20.11605"></a><span id="l20.11605" class="difflineminus">-{</span>
<a href="#l20.11606"></a><span id="l20.11606" class="difflineplus">+nsImapMailFolder::GetCanFileMessages(bool *aCanFileMessages) {</span>
<a href="#l20.11607"></a><span id="l20.11607">   nsresult rv;</span>
<a href="#l20.11608"></a><span id="l20.11608">   *aCanFileMessages = true;</span>
<a href="#l20.11609"></a><span id="l20.11609"> </span>
<a href="#l20.11610"></a><span id="l20.11610">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.11611"></a><span id="l20.11611">   rv = GetServer(getter_AddRefs(server));</span>
<a href="#l20.11612"></a><span id="l20.11612">   if (NS_SUCCEEDED(rv) &amp;&amp; server)</span>
<a href="#l20.11613"></a><span id="l20.11613">     rv = server-&gt;GetCanFileMessagesOnServer(aCanFileMessages);</span>
<a href="#l20.11614"></a><span id="l20.11614"> </span>
<a href="#l20.11615"></a><span id="l20.11615">   if (*aCanFileMessages)</span>
<a href="#l20.11616"></a><span id="l20.11616">     rv = nsMsgDBFolder::GetCanFileMessages(aCanFileMessages);</span>
<a href="#l20.11617"></a><span id="l20.11617"> </span>
<a href="#l20.11618"></a><span id="l20.11618" class="difflineminus">-  if (*aCanFileMessages)</span>
<a href="#l20.11619"></a><span id="l20.11619" class="difflineminus">-  {</span>
<a href="#l20.11620"></a><span id="l20.11620" class="difflineplus">+  if (*aCanFileMessages) {</span>
<a href="#l20.11621"></a><span id="l20.11621">     bool noSelect;</span>
<a href="#l20.11622"></a><span id="l20.11622">     GetFlag(nsMsgFolderFlags::ImapNoselect, &amp;noSelect);</span>
<a href="#l20.11623"></a><span id="l20.11623" class="difflineminus">-    *aCanFileMessages = (noSelect) ? false : GetFolderACL()-&gt;GetCanIInsertInFolder();</span>
<a href="#l20.11624"></a><span id="l20.11624" class="difflineplus">+    *aCanFileMessages =</span>
<a href="#l20.11625"></a><span id="l20.11625" class="difflineplus">+        (noSelect) ? false : GetFolderACL()-&gt;GetCanIInsertInFolder();</span>
<a href="#l20.11626"></a><span id="l20.11626">     return NS_OK;</span>
<a href="#l20.11627"></a><span id="l20.11627">   }</span>
<a href="#l20.11628"></a><span id="l20.11628">   return rv;</span>
<a href="#l20.11629"></a><span id="l20.11629"> }</span>
<a href="#l20.11630"></a><span id="l20.11630"> </span>
<a href="#l20.11631"></a><span id="l20.11631"> NS_IMETHODIMP</span>
<a href="#l20.11632"></a><span id="l20.11632" class="difflineminus">-nsImapMailFolder::GetCanDeleteMessages(bool *aCanDeleteMessages)</span>
<a href="#l20.11633"></a><span id="l20.11633" class="difflineminus">-{</span>
<a href="#l20.11634"></a><span id="l20.11634" class="difflineplus">+nsImapMailFolder::GetCanDeleteMessages(bool *aCanDeleteMessages) {</span>
<a href="#l20.11635"></a><span id="l20.11635">   NS_ENSURE_ARG_POINTER(aCanDeleteMessages);</span>
<a href="#l20.11636"></a><span id="l20.11636">   *aCanDeleteMessages = GetFolderACL()-&gt;GetCanIDeleteInFolder();</span>
<a href="#l20.11637"></a><span id="l20.11637">   return NS_OK;</span>
<a href="#l20.11638"></a><span id="l20.11638"> }</span>
<a href="#l20.11639"></a><span id="l20.11639"> </span>
<a href="#l20.11640"></a><span id="l20.11640"> NS_IMETHODIMP</span>
<a href="#l20.11641"></a><span id="l20.11641" class="difflineminus">-nsImapMailFolder::GetPerformingBiff(bool *aPerformingBiff)</span>
<a href="#l20.11642"></a><span id="l20.11642" class="difflineminus">-{</span>
<a href="#l20.11643"></a><span id="l20.11643" class="difflineplus">+nsImapMailFolder::GetPerformingBiff(bool *aPerformingBiff) {</span>
<a href="#l20.11644"></a><span id="l20.11644">   NS_ENSURE_ARG_POINTER(aPerformingBiff);</span>
<a href="#l20.11645"></a><span id="l20.11645">   *aPerformingBiff = m_performingBiff;</span>
<a href="#l20.11646"></a><span id="l20.11646">   return NS_OK;</span>
<a href="#l20.11647"></a><span id="l20.11647"> }</span>
<a href="#l20.11648"></a><span id="l20.11648"> </span>
<a href="#l20.11649"></a><span id="l20.11649"> NS_IMETHODIMP</span>
<a href="#l20.11650"></a><span id="l20.11650" class="difflineminus">-nsImapMailFolder::SetPerformingBiff(bool aPerformingBiff)</span>
<a href="#l20.11651"></a><span id="l20.11651" class="difflineminus">-{</span>
<a href="#l20.11652"></a><span id="l20.11652" class="difflineplus">+nsImapMailFolder::SetPerformingBiff(bool aPerformingBiff) {</span>
<a href="#l20.11653"></a><span id="l20.11653">   m_performingBiff = aPerformingBiff;</span>
<a href="#l20.11654"></a><span id="l20.11654">   return NS_OK;</span>
<a href="#l20.11655"></a><span id="l20.11655"> }</span>
<a href="#l20.11656"></a><span id="l20.11656"> </span>
<a href="#l20.11657"></a><span id="l20.11657"> NS_IMETHODIMP</span>
<a href="#l20.11658"></a><span id="l20.11658" class="difflineminus">-nsImapMailFolder::SetFilterList(nsIMsgFilterList *aMsgFilterList)</span>
<a href="#l20.11659"></a><span id="l20.11659" class="difflineminus">-{</span>
<a href="#l20.11660"></a><span id="l20.11660" class="difflineplus">+nsImapMailFolder::SetFilterList(nsIMsgFilterList *aMsgFilterList) {</span>
<a href="#l20.11661"></a><span id="l20.11661">   m_filterList = aMsgFilterList;</span>
<a href="#l20.11662"></a><span id="l20.11662">   return nsMsgDBFolder::SetFilterList(aMsgFilterList);</span>
<a href="#l20.11663"></a><span id="l20.11663"> }</span>
<a href="#l20.11664"></a><span id="l20.11664"> </span>
<a href="#l20.11665"></a><span id="l20.11665" class="difflineminus">-nsresult nsImapMailFolder::GetMoveCoalescer()</span>
<a href="#l20.11666"></a><span id="l20.11666" class="difflineminus">-{</span>
<a href="#l20.11667"></a><span id="l20.11667" class="difflineplus">+nsresult nsImapMailFolder::GetMoveCoalescer() {</span>
<a href="#l20.11668"></a><span id="l20.11668">   if (!m_moveCoalescer)</span>
<a href="#l20.11669"></a><span id="l20.11669">     m_moveCoalescer = new nsImapMoveCoalescer(this, nullptr /* msgWindow */);</span>
<a href="#l20.11670"></a><span id="l20.11670">   return NS_OK;</span>
<a href="#l20.11671"></a><span id="l20.11671"> }</span>
<a href="#l20.11672"></a><span id="l20.11672"> </span>
<a href="#l20.11673"></a><span id="l20.11673"> NS_IMETHODIMP</span>
<a href="#l20.11674"></a><span id="l20.11674" class="difflineminus">-nsImapMailFolder::StoreCustomKeywords(nsIMsgWindow *aMsgWindow, const nsACString&amp; aFlagsToAdd,</span>
<a href="#l20.11675"></a><span id="l20.11675" class="difflineminus">-                                      const nsACString&amp; aFlagsToSubtract, nsMsgKey *aKeysToStore, uint32_t aNumKeys, nsIURI **_retval)</span>
<a href="#l20.11676"></a><span id="l20.11676" class="difflineminus">-{</span>
<a href="#l20.11677"></a><span id="l20.11677" class="difflineplus">+nsImapMailFolder::StoreCustomKeywords(nsIMsgWindow *aMsgWindow,</span>
<a href="#l20.11678"></a><span id="l20.11678" class="difflineplus">+                                      const nsACString &amp;aFlagsToAdd,</span>
<a href="#l20.11679"></a><span id="l20.11679" class="difflineplus">+                                      const nsACString &amp;aFlagsToSubtract,</span>
<a href="#l20.11680"></a><span id="l20.11680" class="difflineplus">+                                      nsMsgKey *aKeysToStore, uint32_t aNumKeys,</span>
<a href="#l20.11681"></a><span id="l20.11681" class="difflineplus">+                                      nsIURI **_retval) {</span>
<a href="#l20.11682"></a><span id="l20.11682">   nsresult rv;</span>
<a href="#l20.11683"></a><span id="l20.11683" class="difflineminus">-  if (WeAreOffline())</span>
<a href="#l20.11684"></a><span id="l20.11684" class="difflineminus">-  {</span>
<a href="#l20.11685"></a><span id="l20.11685" class="difflineplus">+  if (WeAreOffline()) {</span>
<a href="#l20.11686"></a><span id="l20.11686">     GetDatabase();</span>
<a href="#l20.11687"></a><span id="l20.11687" class="difflineminus">-    if (mDatabase)</span>
<a href="#l20.11688"></a><span id="l20.11688" class="difflineminus">-    {</span>
<a href="#l20.11689"></a><span id="l20.11689" class="difflineminus">-      for (uint32_t keyIndex = 0; keyIndex &lt; aNumKeys; keyIndex++)</span>
<a href="#l20.11690"></a><span id="l20.11690" class="difflineminus">-      {</span>
<a href="#l20.11691"></a><span id="l20.11691" class="difflineminus">-        nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; op;</span>
<a href="#l20.11692"></a><span id="l20.11692" class="difflineminus">-        rv = mDatabase-&gt;GetOfflineOpForKey(aKeysToStore[keyIndex], true, getter_AddRefs(op));</span>
<a href="#l20.11693"></a><span id="l20.11693" class="difflineplus">+    if (mDatabase) {</span>
<a href="#l20.11694"></a><span id="l20.11694" class="difflineplus">+      for (uint32_t keyIndex = 0; keyIndex &lt; aNumKeys; keyIndex++) {</span>
<a href="#l20.11695"></a><span id="l20.11695" class="difflineplus">+        nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; op;</span>
<a href="#l20.11696"></a><span id="l20.11696" class="difflineplus">+        rv = mDatabase-&gt;GetOfflineOpForKey(aKeysToStore[keyIndex], true,</span>
<a href="#l20.11697"></a><span id="l20.11697" class="difflineplus">+                                           getter_AddRefs(op));</span>
<a href="#l20.11698"></a><span id="l20.11698">         SetFlag(nsMsgFolderFlags::OfflineEvents);</span>
<a href="#l20.11699"></a><span id="l20.11699" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; op)</span>
<a href="#l20.11700"></a><span id="l20.11700" class="difflineminus">-        {</span>
<a href="#l20.11701"></a><span id="l20.11701" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; op) {</span>
<a href="#l20.11702"></a><span id="l20.11702">           if (!aFlagsToAdd.IsEmpty())</span>
<a href="#l20.11703"></a><span id="l20.11703">             op-&gt;AddKeywordToAdd(PromiseFlatCString(aFlagsToAdd).get());</span>
<a href="#l20.11704"></a><span id="l20.11704">           if (!aFlagsToSubtract.IsEmpty())</span>
<a href="#l20.11705"></a><span id="l20.11705">             op-&gt;AddKeywordToRemove(PromiseFlatCString(aFlagsToSubtract).get());</span>
<a href="#l20.11706"></a><span id="l20.11706">         }</span>
<a href="#l20.11707"></a><span id="l20.11707">       }</span>
<a href="#l20.11708"></a><span id="l20.11708" class="difflineminus">-      mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit); // flush offline ops</span>
<a href="#l20.11709"></a><span id="l20.11709" class="difflineplus">+      mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);  // flush offline ops</span>
<a href="#l20.11710"></a><span id="l20.11710">       return rv;</span>
<a href="#l20.11711"></a><span id="l20.11711">     }</span>
<a href="#l20.11712"></a><span id="l20.11712">   }</span>
<a href="#l20.11713"></a><span id="l20.11713" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService(do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l20.11714"></a><span id="l20.11714" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService(</span>
<a href="#l20.11715"></a><span id="l20.11715" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l20.11716"></a><span id="l20.11716">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11717"></a><span id="l20.11717">   nsAutoCString msgIds;</span>
<a href="#l20.11718"></a><span id="l20.11718">   AllocateUidStringFromKeys(aKeysToStore, aNumKeys, msgIds);</span>
<a href="#l20.11719"></a><span id="l20.11719">   return imapService-&gt;StoreCustomKeywords(this, aMsgWindow, aFlagsToAdd,</span>
<a href="#l20.11720"></a><span id="l20.11720">                                           aFlagsToSubtract, msgIds, _retval);</span>
<a href="#l20.11721"></a><span id="l20.11721"> }</span>
<a href="#l20.11722"></a><span id="l20.11722"> </span>
<a href="#l20.11723"></a><span id="l20.11723" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::NotifyIfNewMail()</span>
<a href="#l20.11724"></a><span id="l20.11724" class="difflineminus">-{</span>
<a href="#l20.11725"></a><span id="l20.11725" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::NotifyIfNewMail() {</span>
<a href="#l20.11726"></a><span id="l20.11726">   return PerformBiffNotifications();</span>
<a href="#l20.11727"></a><span id="l20.11727"> }</span>
<a href="#l20.11728"></a><span id="l20.11728"> </span>
<a href="#l20.11729"></a><span id="l20.11729" class="difflineminus">-bool nsImapMailFolder::ShowPreviewText()</span>
<a href="#l20.11730"></a><span id="l20.11730" class="difflineminus">-{</span>
<a href="#l20.11731"></a><span id="l20.11731" class="difflineplus">+bool nsImapMailFolder::ShowPreviewText() {</span>
<a href="#l20.11732"></a><span id="l20.11732">   bool showPreviewText = false;</span>
<a href="#l20.11733"></a><span id="l20.11733">   nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID));</span>
<a href="#l20.11734"></a><span id="l20.11734">   if (prefBranch)</span>
<a href="#l20.11735"></a><span id="l20.11735">     prefBranch-&gt;GetBoolPref(&quot;mail.biff.alert.show_preview&quot;, &amp;showPreviewText);</span>
<a href="#l20.11736"></a><span id="l20.11736">   return showPreviewText;</span>
<a href="#l20.11737"></a><span id="l20.11737"> }</span>
<a href="#l20.11738"></a><span id="l20.11738"> </span>
<a href="#l20.11739"></a><span id="l20.11739" class="difflineminus">-nsresult</span>
<a href="#l20.11740"></a><span id="l20.11740" class="difflineminus">-nsImapMailFolder::PlaybackCoalescedOperations()</span>
<a href="#l20.11741"></a><span id="l20.11741" class="difflineminus">-{</span>
<a href="#l20.11742"></a><span id="l20.11742" class="difflineminus">-  if (m_moveCoalescer)</span>
<a href="#l20.11743"></a><span id="l20.11743" class="difflineminus">-  {</span>
<a href="#l20.11744"></a><span id="l20.11744" class="difflineplus">+nsresult nsImapMailFolder::PlaybackCoalescedOperations() {</span>
<a href="#l20.11745"></a><span id="l20.11745" class="difflineplus">+  if (m_moveCoalescer) {</span>
<a href="#l20.11746"></a><span id="l20.11746">     nsTArray&lt;nsMsgKey&gt; *junkKeysToClassify = m_moveCoalescer-&gt;GetKeyBucket(0);</span>
<a href="#l20.11747"></a><span id="l20.11747">     if (junkKeysToClassify &amp;&amp; !junkKeysToClassify-&gt;IsEmpty())</span>
<a href="#l20.11748"></a><span id="l20.11748" class="difflineminus">-      StoreCustomKeywords(m_moveCoalescer-&gt;GetMsgWindow(), NS_LITERAL_CSTRING(&quot;Junk&quot;), EmptyCString(), junkKeysToClassify-&gt;Elements(), junkKeysToClassify-&gt;Length(), nullptr);</span>
<a href="#l20.11749"></a><span id="l20.11749" class="difflineplus">+      StoreCustomKeywords(m_moveCoalescer-&gt;GetMsgWindow(),</span>
<a href="#l20.11750"></a><span id="l20.11750" class="difflineplus">+                          NS_LITERAL_CSTRING(&quot;Junk&quot;), EmptyCString(),</span>
<a href="#l20.11751"></a><span id="l20.11751" class="difflineplus">+                          junkKeysToClassify-&gt;Elements(),</span>
<a href="#l20.11752"></a><span id="l20.11752" class="difflineplus">+                          junkKeysToClassify-&gt;Length(), nullptr);</span>
<a href="#l20.11753"></a><span id="l20.11753">     junkKeysToClassify-&gt;Clear();</span>
<a href="#l20.11754"></a><span id="l20.11754" class="difflineminus">-    nsTArray&lt;nsMsgKey&gt; *nonJunkKeysToClassify = m_moveCoalescer-&gt;GetKeyBucket(1);</span>
<a href="#l20.11755"></a><span id="l20.11755" class="difflineplus">+    nsTArray&lt;nsMsgKey&gt; *nonJunkKeysToClassify =</span>
<a href="#l20.11756"></a><span id="l20.11756" class="difflineplus">+        m_moveCoalescer-&gt;GetKeyBucket(1);</span>
<a href="#l20.11757"></a><span id="l20.11757">     if (nonJunkKeysToClassify &amp;&amp; !nonJunkKeysToClassify-&gt;IsEmpty())</span>
<a href="#l20.11758"></a><span id="l20.11758" class="difflineminus">-      StoreCustomKeywords(m_moveCoalescer-&gt;GetMsgWindow(), NS_LITERAL_CSTRING(&quot;NonJunk&quot;), EmptyCString(), nonJunkKeysToClassify-&gt;Elements(), nonJunkKeysToClassify-&gt;Length(), nullptr);</span>
<a href="#l20.11759"></a><span id="l20.11759" class="difflineplus">+      StoreCustomKeywords(m_moveCoalescer-&gt;GetMsgWindow(),</span>
<a href="#l20.11760"></a><span id="l20.11760" class="difflineplus">+                          NS_LITERAL_CSTRING(&quot;NonJunk&quot;), EmptyCString(),</span>
<a href="#l20.11761"></a><span id="l20.11761" class="difflineplus">+                          nonJunkKeysToClassify-&gt;Elements(),</span>
<a href="#l20.11762"></a><span id="l20.11762" class="difflineplus">+                          nonJunkKeysToClassify-&gt;Length(), nullptr);</span>
<a href="#l20.11763"></a><span id="l20.11763">     nonJunkKeysToClassify-&gt;Clear();</span>
<a href="#l20.11764"></a><span id="l20.11764">     return m_moveCoalescer-&gt;PlaybackMoves(ShowPreviewText());</span>
<a href="#l20.11765"></a><span id="l20.11765">   }</span>
<a href="#l20.11766"></a><span id="l20.11766" class="difflineminus">-  return NS_OK; // must not be any coalesced operations</span>
<a href="#l20.11767"></a><span id="l20.11767" class="difflineplus">+  return NS_OK;  // must not be any coalesced operations</span>
<a href="#l20.11768"></a><span id="l20.11768"> }</span>
<a href="#l20.11769"></a><span id="l20.11769"> </span>
<a href="#l20.11770"></a><span id="l20.11770"> NS_IMETHODIMP</span>
<a href="#l20.11771"></a><span id="l20.11771" class="difflineminus">-nsImapMailFolder::SetJunkScoreForMessages(nsIArray *aMessages, const nsACString&amp; aJunkScore)</span>
<a href="#l20.11772"></a><span id="l20.11772" class="difflineminus">-{</span>
<a href="#l20.11773"></a><span id="l20.11773" class="difflineplus">+nsImapMailFolder::SetJunkScoreForMessages(nsIArray *aMessages,</span>
<a href="#l20.11774"></a><span id="l20.11774" class="difflineplus">+                                          const nsACString &amp;aJunkScore) {</span>
<a href="#l20.11775"></a><span id="l20.11775">   NS_ENSURE_ARG(aMessages);</span>
<a href="#l20.11776"></a><span id="l20.11776"> </span>
<a href="#l20.11777"></a><span id="l20.11777">   nsresult rv = nsMsgDBFolder::SetJunkScoreForMessages(aMessages, aJunkScore);</span>
<a href="#l20.11778"></a><span id="l20.11778" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l20.11779"></a><span id="l20.11779" class="difflineminus">-  {</span>
<a href="#l20.11780"></a><span id="l20.11780" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.11781"></a><span id="l20.11781">     nsAutoCString messageIds;</span>
<a href="#l20.11782"></a><span id="l20.11782">     nsTArray&lt;nsMsgKey&gt; keys;</span>
<a href="#l20.11783"></a><span id="l20.11783">     nsresult rv = BuildIdsAndKeyArray(aMessages, messageIds, keys);</span>
<a href="#l20.11784"></a><span id="l20.11784">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11785"></a><span id="l20.11785" class="difflineminus">-    StoreCustomKeywords(nullptr, aJunkScore.EqualsLiteral(&quot;0&quot;) ? NS_LITERAL_CSTRING(&quot;NonJunk&quot;) : NS_LITERAL_CSTRING(&quot;Junk&quot;), EmptyCString(), keys.Elements(),</span>
<a href="#l20.11786"></a><span id="l20.11786" class="difflineminus">-      keys.Length(), nullptr);</span>
<a href="#l20.11787"></a><span id="l20.11787" class="difflineminus">-    if (mDatabase)</span>
<a href="#l20.11788"></a><span id="l20.11788" class="difflineminus">-      mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.11789"></a><span id="l20.11789" class="difflineplus">+    StoreCustomKeywords(</span>
<a href="#l20.11790"></a><span id="l20.11790" class="difflineplus">+        nullptr,</span>
<a href="#l20.11791"></a><span id="l20.11791" class="difflineplus">+        aJunkScore.EqualsLiteral(&quot;0&quot;) ? NS_LITERAL_CSTRING(&quot;NonJunk&quot;)</span>
<a href="#l20.11792"></a><span id="l20.11792" class="difflineplus">+                                      : NS_LITERAL_CSTRING(&quot;Junk&quot;),</span>
<a href="#l20.11793"></a><span id="l20.11793" class="difflineplus">+        EmptyCString(), keys.Elements(), keys.Length(), nullptr);</span>
<a href="#l20.11794"></a><span id="l20.11794" class="difflineplus">+    if (mDatabase) mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.11795"></a><span id="l20.11795">   }</span>
<a href="#l20.11796"></a><span id="l20.11796">   return rv;</span>
<a href="#l20.11797"></a><span id="l20.11797"> }</span>
<a href="#l20.11798"></a><span id="l20.11798"> </span>
<a href="#l20.11799"></a><span id="l20.11799"> NS_IMETHODIMP</span>
<a href="#l20.11800"></a><span id="l20.11800" class="difflineminus">-nsImapMailFolder::OnMessageClassified(const char * aMsgURI,</span>
<a href="#l20.11801"></a><span id="l20.11801" class="difflineminus">-  nsMsgJunkStatus aClassification,</span>
<a href="#l20.11802"></a><span id="l20.11802" class="difflineminus">-  uint32_t aJunkPercent)</span>
<a href="#l20.11803"></a><span id="l20.11803" class="difflineminus">-{</span>
<a href="#l20.11804"></a><span id="l20.11804" class="difflineminus">-  nsCOMPtr &lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.11805"></a><span id="l20.11805" class="difflineplus">+nsImapMailFolder::OnMessageClassified(const char *aMsgURI,</span>
<a href="#l20.11806"></a><span id="l20.11806" class="difflineplus">+                                      nsMsgJunkStatus aClassification,</span>
<a href="#l20.11807"></a><span id="l20.11807" class="difflineplus">+                                      uint32_t aJunkPercent) {</span>
<a href="#l20.11808"></a><span id="l20.11808" class="difflineplus">+  nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.11809"></a><span id="l20.11809">   nsresult rv = GetServer(getter_AddRefs(server));</span>
<a href="#l20.11810"></a><span id="l20.11810">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11811"></a><span id="l20.11811"> </span>
<a href="#l20.11812"></a><span id="l20.11812" class="difflineminus">-  if (aMsgURI) // not end of batch</span>
<a href="#l20.11813"></a><span id="l20.11813" class="difflineplus">+  if (aMsgURI)  // not end of batch</span>
<a href="#l20.11814"></a><span id="l20.11814">   {</span>
<a href="#l20.11815"></a><span id="l20.11815" class="difflineminus">-    nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l20.11816"></a><span id="l20.11816" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l20.11817"></a><span id="l20.11817">     rv = GetMsgDBHdrFromURI(aMsgURI, getter_AddRefs(msgHdr));</span>
<a href="#l20.11818"></a><span id="l20.11818">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11819"></a><span id="l20.11819"> </span>
<a href="#l20.11820"></a><span id="l20.11820">     nsMsgKey msgKey;</span>
<a href="#l20.11821"></a><span id="l20.11821">     rv = msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l20.11822"></a><span id="l20.11822">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11823"></a><span id="l20.11823"> </span>
<a href="#l20.11824"></a><span id="l20.11824">     // check if this message needs junk classification</span>
<a href="#l20.11825"></a><span id="l20.11825"> </span>
<a href="#l20.11826"></a><span id="l20.11826">     uint32_t processingFlags;</span>
<a href="#l20.11827"></a><span id="l20.11827">     GetProcessingFlags(msgKey, &amp;processingFlags);</span>
<a href="#l20.11828"></a><span id="l20.11828"> </span>
<a href="#l20.11829"></a><span id="l20.11829" class="difflineminus">-    if (processingFlags &amp; nsMsgProcessingFlags::ClassifyJunk)</span>
<a href="#l20.11830"></a><span id="l20.11830" class="difflineminus">-    {</span>
<a href="#l20.11831"></a><span id="l20.11831" class="difflineminus">-      nsMsgDBFolder::OnMessageClassified(aMsgURI, aClassification, aJunkPercent);</span>
<a href="#l20.11832"></a><span id="l20.11832" class="difflineplus">+    if (processingFlags &amp; nsMsgProcessingFlags::ClassifyJunk) {</span>
<a href="#l20.11833"></a><span id="l20.11833" class="difflineplus">+      nsMsgDBFolder::OnMessageClassified(aMsgURI, aClassification,</span>
<a href="#l20.11834"></a><span id="l20.11834" class="difflineplus">+                                         aJunkPercent);</span>
<a href="#l20.11835"></a><span id="l20.11835"> </span>
<a href="#l20.11836"></a><span id="l20.11836">       GetMoveCoalescer();</span>
<a href="#l20.11837"></a><span id="l20.11837" class="difflineminus">-      if (m_moveCoalescer)</span>
<a href="#l20.11838"></a><span id="l20.11838" class="difflineminus">-      {</span>
<a href="#l20.11839"></a><span id="l20.11839" class="difflineminus">-        nsTArray&lt;nsMsgKey&gt; *keysToClassify = m_moveCoalescer-&gt;GetKeyBucket((aClassification == nsIJunkMailPlugin::JUNK) ? 0 : 1);</span>
<a href="#l20.11840"></a><span id="l20.11840" class="difflineplus">+      if (m_moveCoalescer) {</span>
<a href="#l20.11841"></a><span id="l20.11841" class="difflineplus">+        nsTArray&lt;nsMsgKey&gt; *keysToClassify = m_moveCoalescer-&gt;GetKeyBucket(</span>
<a href="#l20.11842"></a><span id="l20.11842" class="difflineplus">+            (aClassification == nsIJunkMailPlugin::JUNK) ? 0 : 1);</span>
<a href="#l20.11843"></a><span id="l20.11843">         NS_ASSERTION(keysToClassify, &quot;error getting key bucket&quot;);</span>
<a href="#l20.11844"></a><span id="l20.11844" class="difflineminus">-        if (keysToClassify)</span>
<a href="#l20.11845"></a><span id="l20.11845" class="difflineminus">-          keysToClassify-&gt;AppendElement(msgKey);</span>
<a href="#l20.11846"></a><span id="l20.11846" class="difflineplus">+        if (keysToClassify) keysToClassify-&gt;AppendElement(msgKey);</span>
<a href="#l20.11847"></a><span id="l20.11847">       }</span>
<a href="#l20.11848"></a><span id="l20.11848" class="difflineminus">-      if (aClassification == nsIJunkMailPlugin::JUNK)</span>
<a href="#l20.11849"></a><span id="l20.11849" class="difflineminus">-      {</span>
<a href="#l20.11850"></a><span id="l20.11850" class="difflineplus">+      if (aClassification == nsIJunkMailPlugin::JUNK) {</span>
<a href="#l20.11851"></a><span id="l20.11851">         nsCOMPtr&lt;nsISpamSettings&gt; spamSettings;</span>
<a href="#l20.11852"></a><span id="l20.11852">         rv = server-&gt;GetSpamSettings(getter_AddRefs(spamSettings));</span>
<a href="#l20.11853"></a><span id="l20.11853">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11854"></a><span id="l20.11854"> </span>
<a href="#l20.11855"></a><span id="l20.11855">         bool markAsReadOnSpam;</span>
<a href="#l20.11856"></a><span id="l20.11856">         (void)spamSettings-&gt;GetMarkAsReadOnSpam(&amp;markAsReadOnSpam);</span>
<a href="#l20.11857"></a><span id="l20.11857" class="difflineminus">-        if (markAsReadOnSpam)</span>
<a href="#l20.11858"></a><span id="l20.11858" class="difflineminus">-        {</span>
<a href="#l20.11859"></a><span id="l20.11859" class="difflineminus">-          if (!m_junkMessagesToMarkAsRead)</span>
<a href="#l20.11860"></a><span id="l20.11860" class="difflineminus">-          {</span>
<a href="#l20.11861"></a><span id="l20.11861" class="difflineminus">-            m_junkMessagesToMarkAsRead = do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv);</span>
<a href="#l20.11862"></a><span id="l20.11862" class="difflineplus">+        if (markAsReadOnSpam) {</span>
<a href="#l20.11863"></a><span id="l20.11863" class="difflineplus">+          if (!m_junkMessagesToMarkAsRead) {</span>
<a href="#l20.11864"></a><span id="l20.11864" class="difflineplus">+            m_junkMessagesToMarkAsRead =</span>
<a href="#l20.11865"></a><span id="l20.11865" class="difflineplus">+                do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv);</span>
<a href="#l20.11866"></a><span id="l20.11866">             NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11867"></a><span id="l20.11867">           }</span>
<a href="#l20.11868"></a><span id="l20.11868">           m_junkMessagesToMarkAsRead-&gt;AppendElement(msgHdr);</span>
<a href="#l20.11869"></a><span id="l20.11869">         }</span>
<a href="#l20.11870"></a><span id="l20.11870"> </span>
<a href="#l20.11871"></a><span id="l20.11871">         bool willMoveMessage = false;</span>
<a href="#l20.11872"></a><span id="l20.11872"> </span>
<a href="#l20.11873"></a><span id="l20.11873">         // don't do the move when we are opening up</span>
<a href="#l20.11874"></a><span id="l20.11874">         // the junk mail folder or the trash folder</span>
<a href="#l20.11875"></a><span id="l20.11875">         // or when manually classifying messages in those folders</span>
<a href="#l20.11876"></a><span id="l20.11876" class="difflineminus">-        if (!(mFlags &amp; nsMsgFolderFlags::Junk || mFlags &amp; nsMsgFolderFlags::Trash))</span>
<a href="#l20.11877"></a><span id="l20.11877" class="difflineminus">-        {</span>
<a href="#l20.11878"></a><span id="l20.11878" class="difflineplus">+        if (!(mFlags &amp; nsMsgFolderFlags::Junk ||</span>
<a href="#l20.11879"></a><span id="l20.11879" class="difflineplus">+              mFlags &amp; nsMsgFolderFlags::Trash)) {</span>
<a href="#l20.11880"></a><span id="l20.11880">           bool moveOnSpam;</span>
<a href="#l20.11881"></a><span id="l20.11881">           (void)spamSettings-&gt;GetMoveOnSpam(&amp;moveOnSpam);</span>
<a href="#l20.11882"></a><span id="l20.11882" class="difflineminus">-          if (moveOnSpam)</span>
<a href="#l20.11883"></a><span id="l20.11883" class="difflineminus">-          {</span>
<a href="#l20.11884"></a><span id="l20.11884" class="difflineplus">+          if (moveOnSpam) {</span>
<a href="#l20.11885"></a><span id="l20.11885">             nsCString spamFolderURI;</span>
<a href="#l20.11886"></a><span id="l20.11886">             rv = spamSettings-&gt;GetSpamFolderURI(getter_Copies(spamFolderURI));</span>
<a href="#l20.11887"></a><span id="l20.11887">             NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11888"></a><span id="l20.11888"> </span>
<a href="#l20.11889"></a><span id="l20.11889" class="difflineminus">-            if (!spamFolderURI.IsEmpty())</span>
<a href="#l20.11890"></a><span id="l20.11890" class="difflineminus">-            {</span>
<a href="#l20.11891"></a><span id="l20.11891" class="difflineplus">+            if (!spamFolderURI.IsEmpty()) {</span>
<a href="#l20.11892"></a><span id="l20.11892">               rv = FindFolder(spamFolderURI, getter_AddRefs(mSpamFolder));</span>
<a href="#l20.11893"></a><span id="l20.11893">               NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11894"></a><span id="l20.11894" class="difflineminus">-              if (mSpamFolder)</span>
<a href="#l20.11895"></a><span id="l20.11895" class="difflineminus">-              {</span>
<a href="#l20.11896"></a><span id="l20.11896" class="difflineplus">+              if (mSpamFolder) {</span>
<a href="#l20.11897"></a><span id="l20.11897">                 rv = mSpamFolder-&gt;SetFlag(nsMsgFolderFlags::Junk);</span>
<a href="#l20.11898"></a><span id="l20.11898">                 NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11899"></a><span id="l20.11899">                 mSpamKeysToMove.AppendElement(msgKey);</span>
<a href="#l20.11900"></a><span id="l20.11900">                 willMoveMessage = true;</span>
<a href="#l20.11901"></a><span id="l20.11901" class="difflineminus">-              }</span>
<a href="#l20.11902"></a><span id="l20.11902" class="difflineminus">-              else</span>
<a href="#l20.11903"></a><span id="l20.11903" class="difflineminus">-              {</span>
<a href="#l20.11904"></a><span id="l20.11904" class="difflineplus">+              } else {</span>
<a href="#l20.11905"></a><span id="l20.11905">                 // XXX TODO</span>
<a href="#l20.11906"></a><span id="l20.11906">                 // JUNK MAIL RELATED</span>
<a href="#l20.11907"></a><span id="l20.11907">                 // the listener should do</span>
<a href="#l20.11908"></a><span id="l20.11908">                 // rv = folder-&gt;SetFlag(nsMsgFolderFlags::Junk);</span>
<a href="#l20.11909"></a><span id="l20.11909">                 // NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.11910"></a><span id="l20.11910">                 // if (NS_SUCCEEDED(GetMoveCoalescer())) {</span>
<a href="#l20.11911"></a><span id="l20.11911">                 //   m_moveCoalescer-&gt;AddMove(folder, msgKey);</span>
<a href="#l20.11912"></a><span id="l20.11912">                 //   willMoveMessage = true;</span>
<a href="#l20.11913"></a><span id="l20.11913">                 // }</span>
<a href="#l20.11914"></a><span id="l20.11914" class="difflineminus">-                rv = GetOrCreateJunkFolder(spamFolderURI, nullptr /* aListener */);</span>
<a href="#l20.11915"></a><span id="l20.11915" class="difflineplus">+                rv = GetOrCreateJunkFolder(spamFolderURI,</span>
<a href="#l20.11916"></a><span id="l20.11916" class="difflineplus">+                                           nullptr /* aListener */);</span>
<a href="#l20.11917"></a><span id="l20.11917">                 NS_ASSERTION(NS_SUCCEEDED(rv), &quot;GetOrCreateJunkFolder failed&quot;);</span>
<a href="#l20.11918"></a><span id="l20.11918">               }</span>
<a href="#l20.11919"></a><span id="l20.11919">             }</span>
<a href="#l20.11920"></a><span id="l20.11920">           }</span>
<a href="#l20.11921"></a><span id="l20.11921">         }</span>
<a href="#l20.11922"></a><span id="l20.11922">         rv = spamSettings-&gt;LogJunkHit(msgHdr, willMoveMessage);</span>
<a href="#l20.11923"></a><span id="l20.11923" class="difflineminus">-        NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.11924"></a><span id="l20.11924" class="difflineplus">+        NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11925"></a><span id="l20.11925">       }</span>
<a href="#l20.11926"></a><span id="l20.11926">     }</span>
<a href="#l20.11927"></a><span id="l20.11927">   }</span>
<a href="#l20.11928"></a><span id="l20.11928"> </span>
<a href="#l20.11929"></a><span id="l20.11929" class="difflineminus">-  else // end of batch</span>
<a href="#l20.11930"></a><span id="l20.11930" class="difflineplus">+  else  // end of batch</span>
<a href="#l20.11931"></a><span id="l20.11931">   {</span>
<a href="#l20.11932"></a><span id="l20.11932">     // Parent will apply post bayes filters.</span>
<a href="#l20.11933"></a><span id="l20.11933" class="difflineminus">-    nsMsgDBFolder::OnMessageClassified(nullptr, nsIJunkMailPlugin::UNCLASSIFIED, 0);</span>
<a href="#l20.11934"></a><span id="l20.11934" class="difflineminus">-</span>
<a href="#l20.11935"></a><span id="l20.11935" class="difflineminus">-    if (m_junkMessagesToMarkAsRead)</span>
<a href="#l20.11936"></a><span id="l20.11936" class="difflineminus">-    {</span>
<a href="#l20.11937"></a><span id="l20.11937" class="difflineplus">+    nsMsgDBFolder::OnMessageClassified(nullptr, nsIJunkMailPlugin::UNCLASSIFIED,</span>
<a href="#l20.11938"></a><span id="l20.11938" class="difflineplus">+                                       0);</span>
<a href="#l20.11939"></a><span id="l20.11939" class="difflineplus">+</span>
<a href="#l20.11940"></a><span id="l20.11940" class="difflineplus">+    if (m_junkMessagesToMarkAsRead) {</span>
<a href="#l20.11941"></a><span id="l20.11941">       uint32_t count;</span>
<a href="#l20.11942"></a><span id="l20.11942">       m_junkMessagesToMarkAsRead-&gt;GetLength(&amp;count);</span>
<a href="#l20.11943"></a><span id="l20.11943" class="difflineminus">-      if (count &gt; 0)</span>
<a href="#l20.11944"></a><span id="l20.11944" class="difflineminus">-      {</span>
<a href="#l20.11945"></a><span id="l20.11945" class="difflineplus">+      if (count &gt; 0) {</span>
<a href="#l20.11946"></a><span id="l20.11946">         rv = MarkMessagesRead(m_junkMessagesToMarkAsRead, true);</span>
<a href="#l20.11947"></a><span id="l20.11947" class="difflineminus">-        NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.11948"></a><span id="l20.11948" class="difflineplus">+        NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.11949"></a><span id="l20.11949">         m_junkMessagesToMarkAsRead-&gt;Clear();</span>
<a href="#l20.11950"></a><span id="l20.11950">       }</span>
<a href="#l20.11951"></a><span id="l20.11951">     }</span>
<a href="#l20.11952"></a><span id="l20.11952" class="difflineminus">-    if (!mSpamKeysToMove.IsEmpty())</span>
<a href="#l20.11953"></a><span id="l20.11953" class="difflineminus">-    {</span>
<a href="#l20.11954"></a><span id="l20.11954" class="difflineplus">+    if (!mSpamKeysToMove.IsEmpty()) {</span>
<a href="#l20.11955"></a><span id="l20.11955">       GetMoveCoalescer();</span>
<a href="#l20.11956"></a><span id="l20.11956" class="difflineminus">-      for (uint32_t keyIndex = 0; keyIndex &lt; mSpamKeysToMove.Length(); keyIndex++)</span>
<a href="#l20.11957"></a><span id="l20.11957" class="difflineminus">-      {</span>
<a href="#l20.11958"></a><span id="l20.11958" class="difflineplus">+      for (uint32_t keyIndex = 0; keyIndex &lt; mSpamKeysToMove.Length();</span>
<a href="#l20.11959"></a><span id="l20.11959" class="difflineplus">+           keyIndex++) {</span>
<a href="#l20.11960"></a><span id="l20.11960">         // If an upstream filter moved this message, don't move it here.</span>
<a href="#l20.11961"></a><span id="l20.11961">         nsMsgKey msgKey = mSpamKeysToMove.ElementAt(keyIndex);</span>
<a href="#l20.11962"></a><span id="l20.11962">         nsMsgProcessingFlagType processingFlags;</span>
<a href="#l20.11963"></a><span id="l20.11963">         GetProcessingFlags(msgKey, &amp;processingFlags);</span>
<a href="#l20.11964"></a><span id="l20.11964" class="difflineminus">-        if (!(processingFlags &amp; nsMsgProcessingFlags::FilterToMove))</span>
<a href="#l20.11965"></a><span id="l20.11965" class="difflineminus">-        {</span>
<a href="#l20.11966"></a><span id="l20.11966" class="difflineplus">+        if (!(processingFlags &amp; nsMsgProcessingFlags::FilterToMove)) {</span>
<a href="#l20.11967"></a><span id="l20.11967">           if (m_moveCoalescer &amp;&amp; mSpamFolder)</span>
<a href="#l20.11968"></a><span id="l20.11968">             m_moveCoalescer-&gt;AddMove(mSpamFolder, msgKey);</span>
<a href="#l20.11969"></a><span id="l20.11969" class="difflineminus">-        }</span>
<a href="#l20.11970"></a><span id="l20.11970" class="difflineminus">-        else</span>
<a href="#l20.11971"></a><span id="l20.11971" class="difflineminus">-        {</span>
<a href="#l20.11972"></a><span id="l20.11972" class="difflineplus">+        } else {</span>
<a href="#l20.11973"></a><span id="l20.11973">           // We don't need the FilterToMove flag anymore.</span>
<a href="#l20.11974"></a><span id="l20.11974">           AndProcessingFlags(msgKey, ~nsMsgProcessingFlags::FilterToMove);</span>
<a href="#l20.11975"></a><span id="l20.11975">         }</span>
<a href="#l20.11976"></a><span id="l20.11976">       }</span>
<a href="#l20.11977"></a><span id="l20.11977">       mSpamKeysToMove.Clear();</span>
<a href="#l20.11978"></a><span id="l20.11978">     }</span>
<a href="#l20.11979"></a><span id="l20.11979"> </span>
<a href="#l20.11980"></a><span id="l20.11980">     // Let's not hold onto the spam folder reference longer than necessary.</span>
<a href="#l20.11981"></a><span id="l20.11981">     mSpamFolder = nullptr;</span>
<a href="#l20.11982"></a><span id="l20.11982"> </span>
<a href="#l20.11983"></a><span id="l20.11983">     bool pendingMoves = m_moveCoalescer &amp;&amp; m_moveCoalescer-&gt;HasPendingMoves();</span>
<a href="#l20.11984"></a><span id="l20.11984">     PlaybackCoalescedOperations();</span>
<a href="#l20.11985"></a><span id="l20.11985">     // If we are performing biff for this folder, tell the server object</span>
<a href="#l20.11986"></a><span id="l20.11986" class="difflineminus">-    if ((!pendingMoves || !ShowPreviewText()) &amp;&amp; m_performingBiff)</span>
<a href="#l20.11987"></a><span id="l20.11987" class="difflineminus">-    {</span>
<a href="#l20.11988"></a><span id="l20.11988" class="difflineplus">+    if ((!pendingMoves || !ShowPreviewText()) &amp;&amp; m_performingBiff) {</span>
<a href="#l20.11989"></a><span id="l20.11989">       // we don't need to adjust the num new messages in this folder because</span>
<a href="#l20.11990"></a><span id="l20.11990">       // the playback moves code already did that.</span>
<a href="#l20.11991"></a><span id="l20.11991" class="difflineminus">-      (void) PerformBiffNotifications();</span>
<a href="#l20.11992"></a><span id="l20.11992" class="difflineplus">+      (void)PerformBiffNotifications();</span>
<a href="#l20.11993"></a><span id="l20.11993">       server-&gt;SetPerformingBiff(false);</span>
<a href="#l20.11994"></a><span id="l20.11994">       m_performingBiff = false;</span>
<a href="#l20.11995"></a><span id="l20.11995">     }</span>
<a href="#l20.11996"></a><span id="l20.11996">   }</span>
<a href="#l20.11997"></a><span id="l20.11997">   return NS_OK;</span>
<a href="#l20.11998"></a><span id="l20.11998"> }</span>
<a href="#l20.11999"></a><span id="l20.11999"> </span>
<a href="#l20.12000"></a><span id="l20.12000"> NS_IMETHODIMP</span>
<a href="#l20.12001"></a><span id="l20.12001" class="difflineminus">-nsImapMailFolder::GetShouldDownloadAllHeaders(bool *aResult)</span>
<a href="#l20.12002"></a><span id="l20.12002" class="difflineminus">-{</span>
<a href="#l20.12003"></a><span id="l20.12003" class="difflineplus">+nsImapMailFolder::GetShouldDownloadAllHeaders(bool *aResult) {</span>
<a href="#l20.12004"></a><span id="l20.12004">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l20.12005"></a><span id="l20.12005">   *aResult = false;</span>
<a href="#l20.12006"></a><span id="l20.12006" class="difflineminus">-  //for just the inbox, we check if the filter list has arbitrary headers.</span>
<a href="#l20.12007"></a><span id="l20.12007" class="difflineminus">-  //for all folders, check if we have a spam plugin that requires all headers</span>
<a href="#l20.12008"></a><span id="l20.12008" class="difflineminus">-  if (mFlags &amp; nsMsgFolderFlags::Inbox)</span>
<a href="#l20.12009"></a><span id="l20.12009" class="difflineminus">-  {</span>
<a href="#l20.12010"></a><span id="l20.12010" class="difflineminus">-    nsCOMPtr &lt;nsIMsgFilterList&gt; filterList;</span>
<a href="#l20.12011"></a><span id="l20.12011" class="difflineplus">+  // for just the inbox, we check if the filter list has arbitrary headers.</span>
<a href="#l20.12012"></a><span id="l20.12012" class="difflineplus">+  // for all folders, check if we have a spam plugin that requires all headers</span>
<a href="#l20.12013"></a><span id="l20.12013" class="difflineplus">+  if (mFlags &amp; nsMsgFolderFlags::Inbox) {</span>
<a href="#l20.12014"></a><span id="l20.12014" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFilterList&gt; filterList;</span>
<a href="#l20.12015"></a><span id="l20.12015">     nsresult rv = GetFilterList(nullptr, getter_AddRefs(filterList));</span>
<a href="#l20.12016"></a><span id="l20.12016" class="difflineminus">-    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.12017"></a><span id="l20.12017" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12018"></a><span id="l20.12018"> </span>
<a href="#l20.12019"></a><span id="l20.12019">     rv = filterList-&gt;GetShouldDownloadAllHeaders(aResult);</span>
<a href="#l20.12020"></a><span id="l20.12020" class="difflineminus">-    if (*aResult)</span>
<a href="#l20.12021"></a><span id="l20.12021" class="difflineminus">-      return rv;</span>
<a href="#l20.12022"></a><span id="l20.12022" class="difflineminus">-  }</span>
<a href="#l20.12023"></a><span id="l20.12023" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFilterPlugin&gt; filterPlugin;</span>
<a href="#l20.12024"></a><span id="l20.12024" class="difflineplus">+    if (*aResult) return rv;</span>
<a href="#l20.12025"></a><span id="l20.12025" class="difflineplus">+  }</span>
<a href="#l20.12026"></a><span id="l20.12026" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFilterPlugin&gt; filterPlugin;</span>
<a href="#l20.12027"></a><span id="l20.12027">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.12028"></a><span id="l20.12028"> </span>
<a href="#l20.12029"></a><span id="l20.12029">   if (NS_SUCCEEDED(GetServer(getter_AddRefs(server))))</span>
<a href="#l20.12030"></a><span id="l20.12030">     server-&gt;GetSpamFilterPlugin(getter_AddRefs(filterPlugin));</span>
<a href="#l20.12031"></a><span id="l20.12031"> </span>
<a href="#l20.12032"></a><span id="l20.12032" class="difflineminus">-  return (filterPlugin) ? filterPlugin-&gt;GetShouldDownloadAllHeaders(aResult) : NS_OK;</span>
<a href="#l20.12033"></a><span id="l20.12033" class="difflineminus">-}</span>
<a href="#l20.12034"></a><span id="l20.12034" class="difflineminus">-</span>
<a href="#l20.12035"></a><span id="l20.12035" class="difflineminus">-</span>
<a href="#l20.12036"></a><span id="l20.12036" class="difflineminus">-void nsImapMailFolder::GetTrashFolderName(nsAString &amp;aFolderName)</span>
<a href="#l20.12037"></a><span id="l20.12037" class="difflineminus">-{</span>
<a href="#l20.12038"></a><span id="l20.12038" class="difflineplus">+  return (filterPlugin) ? filterPlugin-&gt;GetShouldDownloadAllHeaders(aResult)</span>
<a href="#l20.12039"></a><span id="l20.12039" class="difflineplus">+                        : NS_OK;</span>
<a href="#l20.12040"></a><span id="l20.12040" class="difflineplus">+}</span>
<a href="#l20.12041"></a><span id="l20.12041" class="difflineplus">+</span>
<a href="#l20.12042"></a><span id="l20.12042" class="difflineplus">+void nsImapMailFolder::GetTrashFolderName(nsAString &amp;aFolderName) {</span>
<a href="#l20.12043"></a><span id="l20.12043">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l20.12044"></a><span id="l20.12044">   nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.12045"></a><span id="l20.12045">   nsresult rv;</span>
<a href="#l20.12046"></a><span id="l20.12046">   rv = GetServer(getter_AddRefs(server));</span>
<a href="#l20.12047"></a><span id="l20.12047">   if (NS_FAILED(rv)) return;</span>
<a href="#l20.12048"></a><span id="l20.12048">   imapServer = do_QueryInterface(server, &amp;rv);</span>
<a href="#l20.12049"></a><span id="l20.12049">   if (NS_FAILED(rv)) return;</span>
<a href="#l20.12050"></a><span id="l20.12050">   imapServer-&gt;GetTrashFolderName(aFolderName);</span>
<a href="#l20.12051"></a><span id="l20.12051">   return;</span>
<a href="#l20.12052"></a><span id="l20.12052"> }</span>
<a href="#l20.12053"></a><span id="l20.12053" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::FetchMsgPreviewText(nsMsgKey *aKeysToFetch, uint32_t aNumKeys,</span>
<a href="#l20.12054"></a><span id="l20.12054" class="difflineminus">-                                                 bool aLocalOnly, nsIUrlListener *aUrlListener,</span>
<a href="#l20.12055"></a><span id="l20.12055" class="difflineminus">-                                                 bool *aAsyncResults)</span>
<a href="#l20.12056"></a><span id="l20.12056" class="difflineminus">-{</span>
<a href="#l20.12057"></a><span id="l20.12057" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::FetchMsgPreviewText(</span>
<a href="#l20.12058"></a><span id="l20.12058" class="difflineplus">+    nsMsgKey *aKeysToFetch, uint32_t aNumKeys, bool aLocalOnly,</span>
<a href="#l20.12059"></a><span id="l20.12059" class="difflineplus">+    nsIUrlListener *aUrlListener, bool *aAsyncResults) {</span>
<a href="#l20.12060"></a><span id="l20.12060">   NS_ENSURE_ARG_POINTER(aKeysToFetch);</span>
<a href="#l20.12061"></a><span id="l20.12061">   NS_ENSURE_ARG_POINTER(aAsyncResults);</span>
<a href="#l20.12062"></a><span id="l20.12062"> </span>
<a href="#l20.12063"></a><span id="l20.12063">   nsTArray&lt;nsMsgKey&gt; keysToFetchFromServer;</span>
<a href="#l20.12064"></a><span id="l20.12064"> </span>
<a href="#l20.12065"></a><span id="l20.12065">   *aAsyncResults = false;</span>
<a href="#l20.12066"></a><span id="l20.12066">   nsresult rv = NS_OK;</span>
<a href="#l20.12067"></a><span id="l20.12067"> </span>
<a href="#l20.12068"></a><span id="l20.12068" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.12069"></a><span id="l20.12069" class="difflineminus">-  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12070"></a><span id="l20.12070" class="difflineminus">-  nsCOMPtr &lt;nsIMsgMessageService&gt; msgService = do_QueryInterface(imapService, &amp;rv);</span>
<a href="#l20.12071"></a><span id="l20.12071" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l20.12072"></a><span id="l20.12072" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l20.12073"></a><span id="l20.12073">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12074"></a><span id="l20.12074" class="difflineminus">-</span>
<a href="#l20.12075"></a><span id="l20.12075" class="difflineminus">-  for (uint32_t i = 0; i &lt; aNumKeys; i++)</span>
<a href="#l20.12076"></a><span id="l20.12076" class="difflineminus">-  {</span>
<a href="#l20.12077"></a><span id="l20.12077" class="difflineminus">-    nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l20.12078"></a><span id="l20.12078" class="difflineplus">+  nsCOMPtr&lt;nsIMsgMessageService&gt; msgService =</span>
<a href="#l20.12079"></a><span id="l20.12079" class="difflineplus">+      do_QueryInterface(imapService, &amp;rv);</span>
<a href="#l20.12080"></a><span id="l20.12080" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12081"></a><span id="l20.12081" class="difflineplus">+</span>
<a href="#l20.12082"></a><span id="l20.12082" class="difflineplus">+  for (uint32_t i = 0; i &lt; aNumKeys; i++) {</span>
<a href="#l20.12083"></a><span id="l20.12083" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l20.12084"></a><span id="l20.12084">     nsCString prevBody;</span>
<a href="#l20.12085"></a><span id="l20.12085">     rv = GetMessageHeader(aKeysToFetch[i], getter_AddRefs(msgHdr));</span>
<a href="#l20.12086"></a><span id="l20.12086">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12087"></a><span id="l20.12087">     // ignore messages that already have a preview body.</span>
<a href="#l20.12088"></a><span id="l20.12088">     msgHdr-&gt;GetStringProperty(&quot;preview&quot;, getter_Copies(prevBody));</span>
<a href="#l20.12089"></a><span id="l20.12089" class="difflineminus">-    if (!prevBody.IsEmpty())</span>
<a href="#l20.12090"></a><span id="l20.12090" class="difflineminus">-      continue;</span>
<a href="#l20.12091"></a><span id="l20.12091" class="difflineplus">+    if (!prevBody.IsEmpty()) continue;</span>
<a href="#l20.12092"></a><span id="l20.12092"> </span>
<a href="#l20.12093"></a><span id="l20.12093">     /* check if message is in memory cache or offline store. */</span>
<a href="#l20.12094"></a><span id="l20.12094" class="difflineminus">-    nsCOMPtr &lt;nsIURI&gt; url;</span>
<a href="#l20.12095"></a><span id="l20.12095" class="difflineplus">+    nsCOMPtr&lt;nsIURI&gt; url;</span>
<a href="#l20.12096"></a><span id="l20.12096">     nsCOMPtr&lt;nsIInputStream&gt; inputStream;</span>
<a href="#l20.12097"></a><span id="l20.12097">     nsCString messageUri;</span>
<a href="#l20.12098"></a><span id="l20.12098">     rv = GetUriForMsg(msgHdr, messageUri);</span>
<a href="#l20.12099"></a><span id="l20.12099" class="difflineminus">-    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.12100"></a><span id="l20.12100" class="difflineminus">-    rv = msgService-&gt;GetUrlForUri(messageUri.get(), getter_AddRefs(url), nullptr);</span>
<a href="#l20.12101"></a><span id="l20.12101" class="difflineminus">-    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l20.12102"></a><span id="l20.12102" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12103"></a><span id="l20.12103" class="difflineplus">+    rv = msgService-&gt;GetUrlForUri(messageUri.get(), getter_AddRefs(url),</span>
<a href="#l20.12104"></a><span id="l20.12104" class="difflineplus">+                                  nullptr);</span>
<a href="#l20.12105"></a><span id="l20.12105" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12106"></a><span id="l20.12106"> </span>
<a href="#l20.12107"></a><span id="l20.12107">     // Lets look in the offline store.</span>
<a href="#l20.12108"></a><span id="l20.12108">     uint32_t msgFlags;</span>
<a href="#l20.12109"></a><span id="l20.12109">     msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l20.12110"></a><span id="l20.12110">     nsMsgKey msgKey;</span>
<a href="#l20.12111"></a><span id="l20.12111">     msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l20.12112"></a><span id="l20.12112" class="difflineminus">-    if (msgFlags &amp; nsMsgMessageFlags::Offline)</span>
<a href="#l20.12113"></a><span id="l20.12113" class="difflineminus">-    {</span>
<a href="#l20.12114"></a><span id="l20.12114" class="difflineplus">+    if (msgFlags &amp; nsMsgMessageFlags::Offline) {</span>
<a href="#l20.12115"></a><span id="l20.12115">       int64_t messageOffset;</span>
<a href="#l20.12116"></a><span id="l20.12116">       uint32_t messageSize;</span>
<a href="#l20.12117"></a><span id="l20.12117" class="difflineminus">-      GetOfflineFileStream(msgKey, &amp;messageOffset, &amp;messageSize, getter_AddRefs(inputStream));</span>
<a href="#l20.12118"></a><span id="l20.12118" class="difflineminus">-      if (inputStream)</span>
<a href="#l20.12119"></a><span id="l20.12119" class="difflineminus">-        rv = GetMsgPreviewTextFromStream(msgHdr, inputStream);</span>
<a href="#l20.12120"></a><span id="l20.12120" class="difflineminus">-    }</span>
<a href="#l20.12121"></a><span id="l20.12121" class="difflineminus">-    else if (!aLocalOnly) {</span>
<a href="#l20.12122"></a><span id="l20.12122" class="difflineplus">+      GetOfflineFileStream(msgKey, &amp;messageOffset, &amp;messageSize,</span>
<a href="#l20.12123"></a><span id="l20.12123" class="difflineplus">+                           getter_AddRefs(inputStream));</span>
<a href="#l20.12124"></a><span id="l20.12124" class="difflineplus">+      if (inputStream) rv = GetMsgPreviewTextFromStream(msgHdr, inputStream);</span>
<a href="#l20.12125"></a><span id="l20.12125" class="difflineplus">+    } else if (!aLocalOnly) {</span>
<a href="#l20.12126"></a><span id="l20.12126">       keysToFetchFromServer.AppendElement(msgKey);</span>
<a href="#l20.12127"></a><span id="l20.12127">     }</span>
<a href="#l20.12128"></a><span id="l20.12128">   }</span>
<a href="#l20.12129"></a><span id="l20.12129" class="difflineminus">-  if (!keysToFetchFromServer.IsEmpty())</span>
<a href="#l20.12130"></a><span id="l20.12130" class="difflineminus">-  {</span>
<a href="#l20.12131"></a><span id="l20.12131" class="difflineplus">+  if (!keysToFetchFromServer.IsEmpty()) {</span>
<a href="#l20.12132"></a><span id="l20.12132">     uint32_t msgCount = keysToFetchFromServer.Length();</span>
<a href="#l20.12133"></a><span id="l20.12133">     nsAutoCString messageIds;</span>
<a href="#l20.12134"></a><span id="l20.12134" class="difflineminus">-    AllocateImapUidString(keysToFetchFromServer.Elements(), msgCount,</span>
<a href="#l20.12135"></a><span id="l20.12135" class="difflineminus">-                         nullptr, messageIds);</span>
<a href="#l20.12136"></a><span id="l20.12136" class="difflineminus">-    rv = imapService-&gt;GetBodyStart(this, aUrlListener,</span>
<a href="#l20.12137"></a><span id="l20.12137" class="difflineminus">-                                   messageIds, 2048, nullptr);</span>
<a href="#l20.12138"></a><span id="l20.12138" class="difflineminus">-    *aAsyncResults = true; // the preview text will be available async...</span>
<a href="#l20.12139"></a><span id="l20.12139" class="difflineplus">+    AllocateImapUidString(keysToFetchFromServer.Elements(), msgCount, nullptr,</span>
<a href="#l20.12140"></a><span id="l20.12140" class="difflineplus">+                          messageIds);</span>
<a href="#l20.12141"></a><span id="l20.12141" class="difflineplus">+    rv = imapService-&gt;GetBodyStart(this, aUrlListener, messageIds, 2048,</span>
<a href="#l20.12142"></a><span id="l20.12142" class="difflineplus">+                                   nullptr);</span>
<a href="#l20.12143"></a><span id="l20.12143" class="difflineplus">+    *aAsyncResults = true;  // the preview text will be available async...</span>
<a href="#l20.12144"></a><span id="l20.12144">   }</span>
<a href="#l20.12145"></a><span id="l20.12145">   return NS_OK;</span>
<a href="#l20.12146"></a><span id="l20.12146"> }</span>
<a href="#l20.12147"></a><span id="l20.12147"> </span>
<a href="#l20.12148"></a><span id="l20.12148" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::AddKeywordsToMessages(nsIArray *aMessages, const nsACString&amp; aKeywords)</span>
<a href="#l20.12149"></a><span id="l20.12149" class="difflineminus">-{</span>
<a href="#l20.12150"></a><span id="l20.12150" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::AddKeywordsToMessages(</span>
<a href="#l20.12151"></a><span id="l20.12151" class="difflineplus">+    nsIArray *aMessages, const nsACString &amp;aKeywords) {</span>
<a href="#l20.12152"></a><span id="l20.12152">   nsresult rv = nsMsgDBFolder::AddKeywordsToMessages(aMessages, aKeywords);</span>
<a href="#l20.12153"></a><span id="l20.12153" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l20.12154"></a><span id="l20.12154" class="difflineminus">-  {</span>
<a href="#l20.12155"></a><span id="l20.12155" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.12156"></a><span id="l20.12156">     nsAutoCString messageIds;</span>
<a href="#l20.12157"></a><span id="l20.12157">     nsTArray&lt;nsMsgKey&gt; keys;</span>
<a href="#l20.12158"></a><span id="l20.12158">     rv = BuildIdsAndKeyArray(aMessages, messageIds, keys);</span>
<a href="#l20.12159"></a><span id="l20.12159">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12160"></a><span id="l20.12160" class="difflineminus">-    rv = StoreCustomKeywords(nullptr, aKeywords, EmptyCString(), keys.Elements(), keys.Length(), nullptr);</span>
<a href="#l20.12161"></a><span id="l20.12161" class="difflineminus">-    if (mDatabase)</span>
<a href="#l20.12162"></a><span id="l20.12162" class="difflineminus">-      mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.12163"></a><span id="l20.12163" class="difflineplus">+    rv = StoreCustomKeywords(nullptr, aKeywords, EmptyCString(),</span>
<a href="#l20.12164"></a><span id="l20.12164" class="difflineplus">+                             keys.Elements(), keys.Length(), nullptr);</span>
<a href="#l20.12165"></a><span id="l20.12165" class="difflineplus">+    if (mDatabase) mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.12166"></a><span id="l20.12166">   }</span>
<a href="#l20.12167"></a><span id="l20.12167">   return rv;</span>
<a href="#l20.12168"></a><span id="l20.12168"> }</span>
<a href="#l20.12169"></a><span id="l20.12169"> </span>
<a href="#l20.12170"></a><span id="l20.12170" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::RemoveKeywordsFromMessages(nsIArray *aMessages, const nsACString&amp; aKeywords)</span>
<a href="#l20.12171"></a><span id="l20.12171" class="difflineminus">-{</span>
<a href="#l20.12172"></a><span id="l20.12172" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::RemoveKeywordsFromMessages(</span>
<a href="#l20.12173"></a><span id="l20.12173" class="difflineplus">+    nsIArray *aMessages, const nsACString &amp;aKeywords) {</span>
<a href="#l20.12174"></a><span id="l20.12174">   nsresult rv = nsMsgDBFolder::RemoveKeywordsFromMessages(aMessages, aKeywords);</span>
<a href="#l20.12175"></a><span id="l20.12175" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l20.12176"></a><span id="l20.12176" class="difflineminus">-  {</span>
<a href="#l20.12177"></a><span id="l20.12177" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l20.12178"></a><span id="l20.12178">     nsAutoCString messageIds;</span>
<a href="#l20.12179"></a><span id="l20.12179">     nsTArray&lt;nsMsgKey&gt; keys;</span>
<a href="#l20.12180"></a><span id="l20.12180">     nsresult rv = BuildIdsAndKeyArray(aMessages, messageIds, keys);</span>
<a href="#l20.12181"></a><span id="l20.12181">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12182"></a><span id="l20.12182" class="difflineminus">-    rv = StoreCustomKeywords(nullptr, EmptyCString(), aKeywords, keys.Elements(), keys.Length(), nullptr);</span>
<a href="#l20.12183"></a><span id="l20.12183" class="difflineminus">-    if (mDatabase)</span>
<a href="#l20.12184"></a><span id="l20.12184" class="difflineminus">-      mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.12185"></a><span id="l20.12185" class="difflineplus">+    rv = StoreCustomKeywords(nullptr, EmptyCString(), aKeywords,</span>
<a href="#l20.12186"></a><span id="l20.12186" class="difflineplus">+                             keys.Elements(), keys.Length(), nullptr);</span>
<a href="#l20.12187"></a><span id="l20.12187" class="difflineplus">+    if (mDatabase) mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l20.12188"></a><span id="l20.12188">   }</span>
<a href="#l20.12189"></a><span id="l20.12189">   return rv;</span>
<a href="#l20.12190"></a><span id="l20.12190"> }</span>
<a href="#l20.12191"></a><span id="l20.12191"> </span>
<a href="#l20.12192"></a><span id="l20.12192" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetCustomIdentity(nsIMsgIdentity **aIdentity)</span>
<a href="#l20.12193"></a><span id="l20.12193" class="difflineminus">-{</span>
<a href="#l20.12194"></a><span id="l20.12194" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetCustomIdentity(nsIMsgIdentity **aIdentity) {</span>
<a href="#l20.12195"></a><span id="l20.12195">   NS_ENSURE_ARG_POINTER(aIdentity);</span>
<a href="#l20.12196"></a><span id="l20.12196" class="difflineminus">-  if (mFlags &amp; nsMsgFolderFlags::ImapOtherUser)</span>
<a href="#l20.12197"></a><span id="l20.12197" class="difflineminus">-  {</span>
<a href="#l20.12198"></a><span id="l20.12198" class="difflineplus">+  if (mFlags &amp; nsMsgFolderFlags::ImapOtherUser) {</span>
<a href="#l20.12199"></a><span id="l20.12199">     nsresult rv;</span>
<a href="#l20.12200"></a><span id="l20.12200">     bool delegateOtherUsersFolders = false;</span>
<a href="#l20.12201"></a><span id="l20.12201" class="difflineminus">-    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l20.12202"></a><span id="l20.12202" class="difflineplus">+    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(</span>
<a href="#l20.12203"></a><span id="l20.12203" class="difflineplus">+        do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l20.12204"></a><span id="l20.12204">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12205"></a><span id="l20.12205" class="difflineminus">-    prefBranch-&gt;GetBoolPref(&quot;mail.imap.delegateOtherUsersFolders&quot;, &amp;delegateOtherUsersFolders);</span>
<a href="#l20.12206"></a><span id="l20.12206" class="difflineplus">+    prefBranch-&gt;GetBoolPref(&quot;mail.imap.delegateOtherUsersFolders&quot;,</span>
<a href="#l20.12207"></a><span id="l20.12207" class="difflineplus">+                            &amp;delegateOtherUsersFolders);</span>
<a href="#l20.12208"></a><span id="l20.12208">     // if we're automatically delegating other user's folders, we need to</span>
<a href="#l20.12209"></a><span id="l20.12209">     // cons up an e-mail address for the other user. We do that by</span>
<a href="#l20.12210"></a><span id="l20.12210">     // taking the other user's name and the current user's domain name,</span>
<a href="#l20.12211"></a><span id="l20.12211">     // assuming they'll be the same. So, &lt;otherUsersName&gt;@&lt;ourDomain&gt;</span>
<a href="#l20.12212"></a><span id="l20.12212" class="difflineminus">-    if (delegateOtherUsersFolders)</span>
<a href="#l20.12213"></a><span id="l20.12213" class="difflineminus">-    {</span>
<a href="#l20.12214"></a><span id="l20.12214" class="difflineplus">+    if (delegateOtherUsersFolders) {</span>
<a href="#l20.12215"></a><span id="l20.12215">       nsCOMPtr&lt;nsIMsgIncomingServer&gt; server = do_QueryReferent(mServer, &amp;rv);</span>
<a href="#l20.12216"></a><span id="l20.12216">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12217"></a><span id="l20.12217" class="difflineminus">-      nsCOMPtr&lt;nsIMsgAccountManager&gt; accountManager = do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l20.12218"></a><span id="l20.12218" class="difflineplus">+      nsCOMPtr&lt;nsIMsgAccountManager&gt; accountManager =</span>
<a href="#l20.12219"></a><span id="l20.12219" class="difflineplus">+          do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l20.12220"></a><span id="l20.12220">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12221"></a><span id="l20.12221" class="difflineminus">-      nsCOMPtr &lt;nsIMsgIdentity&gt; ourIdentity;</span>
<a href="#l20.12222"></a><span id="l20.12222" class="difflineminus">-      nsCOMPtr &lt;nsIMsgIdentity&gt; retIdentity;</span>
<a href="#l20.12223"></a><span id="l20.12223" class="difflineminus">-      nsCOMPtr &lt;nsIMsgAccount&gt; account;</span>
<a href="#l20.12224"></a><span id="l20.12224" class="difflineplus">+      nsCOMPtr&lt;nsIMsgIdentity&gt; ourIdentity;</span>
<a href="#l20.12225"></a><span id="l20.12225" class="difflineplus">+      nsCOMPtr&lt;nsIMsgIdentity&gt; retIdentity;</span>
<a href="#l20.12226"></a><span id="l20.12226" class="difflineplus">+      nsCOMPtr&lt;nsIMsgAccount&gt; account;</span>
<a href="#l20.12227"></a><span id="l20.12227">       nsCString foldersUserName;</span>
<a href="#l20.12228"></a><span id="l20.12228">       nsCString ourEmailAddress;</span>
<a href="#l20.12229"></a><span id="l20.12229"> </span>
<a href="#l20.12230"></a><span id="l20.12230">       accountManager-&gt;FindAccountForServer(server, getter_AddRefs(account));</span>
<a href="#l20.12231"></a><span id="l20.12231">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12232"></a><span id="l20.12232">       account-&gt;GetDefaultIdentity(getter_AddRefs(ourIdentity));</span>
<a href="#l20.12233"></a><span id="l20.12233">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12234"></a><span id="l20.12234">       ourIdentity-&gt;GetEmail(ourEmailAddress);</span>
<a href="#l20.12235"></a><span id="l20.12235">       int32_t atPos = ourEmailAddress.FindChar('@');</span>
<a href="#l20.12236"></a><span id="l20.12236" class="difflineminus">-      if (atPos != kNotFound)</span>
<a href="#l20.12237"></a><span id="l20.12237" class="difflineminus">-      {</span>
<a href="#l20.12238"></a><span id="l20.12238" class="difflineplus">+      if (atPos != kNotFound) {</span>
<a href="#l20.12239"></a><span id="l20.12239">         nsCString otherUsersEmailAddress;</span>
<a href="#l20.12240"></a><span id="l20.12240">         GetFolderOwnerUserName(otherUsersEmailAddress);</span>
<a href="#l20.12241"></a><span id="l20.12241" class="difflineminus">-        otherUsersEmailAddress.Append(Substring(ourEmailAddress, atPos, ourEmailAddress.Length()));</span>
<a href="#l20.12242"></a><span id="l20.12242" class="difflineplus">+        otherUsersEmailAddress.Append(</span>
<a href="#l20.12243"></a><span id="l20.12243" class="difflineplus">+            Substring(ourEmailAddress, atPos, ourEmailAddress.Length()));</span>
<a href="#l20.12244"></a><span id="l20.12244">         nsCOMPtr&lt;nsIArray&gt; identities;</span>
<a href="#l20.12245"></a><span id="l20.12245" class="difflineminus">-        rv = accountManager-&gt;GetIdentitiesForServer(server, getter_AddRefs(identities));</span>
<a href="#l20.12246"></a><span id="l20.12246" class="difflineplus">+        rv = accountManager-&gt;GetIdentitiesForServer(server,</span>
<a href="#l20.12247"></a><span id="l20.12247" class="difflineplus">+                                                    getter_AddRefs(identities));</span>
<a href="#l20.12248"></a><span id="l20.12248">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12249"></a><span id="l20.12249">         uint32_t numIdentities;</span>
<a href="#l20.12250"></a><span id="l20.12250">         rv = identities-&gt;GetLength(&amp;numIdentities);</span>
<a href="#l20.12251"></a><span id="l20.12251">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12252"></a><span id="l20.12252" class="difflineminus">-        for (uint32_t identityIndex = 0; identityIndex &lt; numIdentities; identityIndex++)</span>
<a href="#l20.12253"></a><span id="l20.12253" class="difflineminus">-        {</span>
<a href="#l20.12254"></a><span id="l20.12254" class="difflineminus">-          nsCOMPtr&lt;nsIMsgIdentity&gt; identity = do_QueryElementAt(identities, identityIndex);</span>
<a href="#l20.12255"></a><span id="l20.12255" class="difflineminus">-          if (!identity)</span>
<a href="#l20.12256"></a><span id="l20.12256" class="difflineminus">-            continue;</span>
<a href="#l20.12257"></a><span id="l20.12257" class="difflineplus">+        for (uint32_t identityIndex = 0; identityIndex &lt; numIdentities;</span>
<a href="#l20.12258"></a><span id="l20.12258" class="difflineplus">+             identityIndex++) {</span>
<a href="#l20.12259"></a><span id="l20.12259" class="difflineplus">+          nsCOMPtr&lt;nsIMsgIdentity&gt; identity =</span>
<a href="#l20.12260"></a><span id="l20.12260" class="difflineplus">+              do_QueryElementAt(identities, identityIndex);</span>
<a href="#l20.12261"></a><span id="l20.12261" class="difflineplus">+          if (!identity) continue;</span>
<a href="#l20.12262"></a><span id="l20.12262">           nsCString identityEmail;</span>
<a href="#l20.12263"></a><span id="l20.12263">           identity-&gt;GetEmail(identityEmail);</span>
<a href="#l20.12264"></a><span id="l20.12264" class="difflineminus">-          if (identityEmail.Equals(otherUsersEmailAddress))</span>
<a href="#l20.12265"></a><span id="l20.12265" class="difflineminus">-          {</span>
<a href="#l20.12266"></a><span id="l20.12266" class="difflineminus">-            retIdentity = identity;;</span>
<a href="#l20.12267"></a><span id="l20.12267" class="difflineplus">+          if (identityEmail.Equals(otherUsersEmailAddress)) {</span>
<a href="#l20.12268"></a><span id="l20.12268" class="difflineplus">+            retIdentity = identity;</span>
<a href="#l20.12269"></a><span id="l20.12269" class="difflineplus">+            ;</span>
<a href="#l20.12270"></a><span id="l20.12270">             break;</span>
<a href="#l20.12271"></a><span id="l20.12271">           }</span>
<a href="#l20.12272"></a><span id="l20.12272">         }</span>
<a href="#l20.12273"></a><span id="l20.12273" class="difflineminus">-        if (!retIdentity)</span>
<a href="#l20.12274"></a><span id="l20.12274" class="difflineminus">-        {</span>
<a href="#l20.12275"></a><span id="l20.12275" class="difflineplus">+        if (!retIdentity) {</span>
<a href="#l20.12276"></a><span id="l20.12276">           // create the identity</span>
<a href="#l20.12277"></a><span id="l20.12277">           rv = accountManager-&gt;CreateIdentity(getter_AddRefs(retIdentity));</span>
<a href="#l20.12278"></a><span id="l20.12278">           NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12279"></a><span id="l20.12279">           retIdentity-&gt;SetEmail(otherUsersEmailAddress);</span>
<a href="#l20.12280"></a><span id="l20.12280" class="difflineminus">-          nsCOMPtr &lt;nsIMsgAccount&gt; account;</span>
<a href="#l20.12281"></a><span id="l20.12281" class="difflineplus">+          nsCOMPtr&lt;nsIMsgAccount&gt; account;</span>
<a href="#l20.12282"></a><span id="l20.12282">           accountManager-&gt;FindAccountForServer(server, getter_AddRefs(account));</span>
<a href="#l20.12283"></a><span id="l20.12283">           NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12284"></a><span id="l20.12284">           account-&gt;AddIdentity(retIdentity);</span>
<a href="#l20.12285"></a><span id="l20.12285">         }</span>
<a href="#l20.12286"></a><span id="l20.12286">       }</span>
<a href="#l20.12287"></a><span id="l20.12287" class="difflineminus">-      if (retIdentity)</span>
<a href="#l20.12288"></a><span id="l20.12288" class="difflineminus">-      {</span>
<a href="#l20.12289"></a><span id="l20.12289" class="difflineplus">+      if (retIdentity) {</span>
<a href="#l20.12290"></a><span id="l20.12290">         retIdentity.forget(aIdentity);</span>
<a href="#l20.12291"></a><span id="l20.12291">         return NS_OK;</span>
<a href="#l20.12292"></a><span id="l20.12292">       }</span>
<a href="#l20.12293"></a><span id="l20.12293">     }</span>
<a href="#l20.12294"></a><span id="l20.12294">   }</span>
<a href="#l20.12295"></a><span id="l20.12295">   return nsMsgDBFolder::GetCustomIdentity(aIdentity);</span>
<a href="#l20.12296"></a><span id="l20.12296"> }</span>
<a href="#l20.12297"></a><span id="l20.12297"> </span>
<a href="#l20.12298"></a><span id="l20.12298" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::ChangePendingTotal(int32_t aDelta)</span>
<a href="#l20.12299"></a><span id="l20.12299" class="difflineminus">-{</span>
<a href="#l20.12300"></a><span id="l20.12300" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::ChangePendingTotal(int32_t aDelta) {</span>
<a href="#l20.12301"></a><span id="l20.12301">   ChangeNumPendingTotalMessages(aDelta);</span>
<a href="#l20.12302"></a><span id="l20.12302" class="difflineminus">-  if (aDelta &gt; 0)</span>
<a href="#l20.12303"></a><span id="l20.12303" class="difflineminus">-    NotifyHasPendingMsgs();</span>
<a href="#l20.12304"></a><span id="l20.12304" class="difflineplus">+  if (aDelta &gt; 0) NotifyHasPendingMsgs();</span>
<a href="#l20.12305"></a><span id="l20.12305">   return NS_OK;</span>
<a href="#l20.12306"></a><span id="l20.12306"> }</span>
<a href="#l20.12307"></a><span id="l20.12307"> </span>
<a href="#l20.12308"></a><span id="l20.12308" class="difflineminus">-void nsImapMailFolder::NotifyHasPendingMsgs()</span>
<a href="#l20.12309"></a><span id="l20.12309" class="difflineminus">-{</span>
<a href="#l20.12310"></a><span id="l20.12310" class="difflineplus">+void nsImapMailFolder::NotifyHasPendingMsgs() {</span>
<a href="#l20.12311"></a><span id="l20.12311">   InitAutoSyncState();</span>
<a href="#l20.12312"></a><span id="l20.12312">   nsresult rv;</span>
<a href="#l20.12313"></a><span id="l20.12313" class="difflineminus">-  nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr = do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l20.12314"></a><span id="l20.12314" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l20.12315"></a><span id="l20.12315" class="difflineminus">-    autoSyncMgr-&gt;OnFolderHasPendingMsgs(m_autoSyncStateObj);</span>
<a href="#l20.12316"></a><span id="l20.12316" class="difflineplus">+  nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr =</span>
<a href="#l20.12317"></a><span id="l20.12317" class="difflineplus">+      do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l20.12318"></a><span id="l20.12318" class="difflineplus">+  if (NS_SUCCEEDED(rv)) autoSyncMgr-&gt;OnFolderHasPendingMsgs(m_autoSyncStateObj);</span>
<a href="#l20.12319"></a><span id="l20.12319"> }</span>
<a href="#l20.12320"></a><span id="l20.12320"> </span>
<a href="#l20.12321"></a><span id="l20.12321"> /* void changePendingUnread (in long aDelta); */</span>
<a href="#l20.12322"></a><span id="l20.12322" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::ChangePendingUnread(int32_t aDelta)</span>
<a href="#l20.12323"></a><span id="l20.12323" class="difflineminus">-{</span>
<a href="#l20.12324"></a><span id="l20.12324" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::ChangePendingUnread(int32_t aDelta) {</span>
<a href="#l20.12325"></a><span id="l20.12325">   ChangeNumPendingUnread(aDelta);</span>
<a href="#l20.12326"></a><span id="l20.12326">   return NS_OK;</span>
<a href="#l20.12327"></a><span id="l20.12327"> }</span>
<a href="#l20.12328"></a><span id="l20.12328"> </span>
<a href="#l20.12329"></a><span id="l20.12329" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetServerRecent(int32_t *aServerRecent)</span>
<a href="#l20.12330"></a><span id="l20.12330" class="difflineminus">-{</span>
<a href="#l20.12331"></a><span id="l20.12331" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetServerRecent(int32_t *aServerRecent) {</span>
<a href="#l20.12332"></a><span id="l20.12332">   NS_ENSURE_ARG_POINTER(aServerRecent);</span>
<a href="#l20.12333"></a><span id="l20.12333">   *aServerRecent = m_numServerRecentMessages;</span>
<a href="#l20.12334"></a><span id="l20.12334">   return NS_OK;</span>
<a href="#l20.12335"></a><span id="l20.12335"> }</span>
<a href="#l20.12336"></a><span id="l20.12336"> </span>
<a href="#l20.12337"></a><span id="l20.12337" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetServerTotal(int32_t *aServerTotal)</span>
<a href="#l20.12338"></a><span id="l20.12338" class="difflineminus">-{</span>
<a href="#l20.12339"></a><span id="l20.12339" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetServerTotal(int32_t *aServerTotal) {</span>
<a href="#l20.12340"></a><span id="l20.12340">   NS_ENSURE_ARG_POINTER(aServerTotal);</span>
<a href="#l20.12341"></a><span id="l20.12341">   *aServerTotal = m_numServerTotalMessages;</span>
<a href="#l20.12342"></a><span id="l20.12342">   return NS_OK;</span>
<a href="#l20.12343"></a><span id="l20.12343"> }</span>
<a href="#l20.12344"></a><span id="l20.12344"> </span>
<a href="#l20.12345"></a><span id="l20.12345" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetServerUnseen(int32_t *aServerUnseen)</span>
<a href="#l20.12346"></a><span id="l20.12346" class="difflineminus">-{</span>
<a href="#l20.12347"></a><span id="l20.12347" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetServerUnseen(int32_t *aServerUnseen) {</span>
<a href="#l20.12348"></a><span id="l20.12348">   NS_ENSURE_ARG_POINTER(aServerUnseen);</span>
<a href="#l20.12349"></a><span id="l20.12349">   *aServerUnseen = m_numServerUnseenMessages;</span>
<a href="#l20.12350"></a><span id="l20.12350">   return NS_OK;</span>
<a href="#l20.12351"></a><span id="l20.12351"> }</span>
<a href="#l20.12352"></a><span id="l20.12352"> </span>
<a href="#l20.12353"></a><span id="l20.12353" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetServerNextUID(int32_t *aNextUID)</span>
<a href="#l20.12354"></a><span id="l20.12354" class="difflineminus">-{</span>
<a href="#l20.12355"></a><span id="l20.12355" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetServerNextUID(int32_t *aNextUID) {</span>
<a href="#l20.12356"></a><span id="l20.12356">   NS_ENSURE_ARG_POINTER(aNextUID);</span>
<a href="#l20.12357"></a><span id="l20.12357">   *aNextUID = m_nextUID;</span>
<a href="#l20.12358"></a><span id="l20.12358">   return NS_OK;</span>
<a href="#l20.12359"></a><span id="l20.12359"> }</span>
<a href="#l20.12360"></a><span id="l20.12360"> </span>
<a href="#l20.12361"></a><span id="l20.12361" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetAutoSyncStateObj(nsIAutoSyncState **autoSyncStateObj)</span>
<a href="#l20.12362"></a><span id="l20.12362" class="difflineminus">-{</span>
<a href="#l20.12363"></a><span id="l20.12363" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetAutoSyncStateObj(</span>
<a href="#l20.12364"></a><span id="l20.12364" class="difflineplus">+    nsIAutoSyncState **autoSyncStateObj) {</span>
<a href="#l20.12365"></a><span id="l20.12365">   NS_ENSURE_ARG_POINTER(autoSyncStateObj);</span>
<a href="#l20.12366"></a><span id="l20.12366"> </span>
<a href="#l20.12367"></a><span id="l20.12367">   // create auto-sync state object lazily</span>
<a href="#l20.12368"></a><span id="l20.12368">   InitAutoSyncState();</span>
<a href="#l20.12369"></a><span id="l20.12369"> </span>
<a href="#l20.12370"></a><span id="l20.12370">   NS_IF_ADDREF(*autoSyncStateObj = m_autoSyncStateObj);</span>
<a href="#l20.12371"></a><span id="l20.12371">   return NS_OK;</span>
<a href="#l20.12372"></a><span id="l20.12372"> }</span>
<a href="#l20.12373"></a><span id="l20.12373"> </span>
<a href="#l20.12374"></a><span id="l20.12374" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::InitiateAutoSync(nsIUrlListener *aUrlListener)</span>
<a href="#l20.12375"></a><span id="l20.12375" class="difflineminus">-{</span>
<a href="#l20.12376"></a><span id="l20.12376" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::InitiateAutoSync(nsIUrlListener *aUrlListener) {</span>
<a href="#l20.12377"></a><span id="l20.12377">   nsCString folderName;</span>
<a href="#l20.12378"></a><span id="l20.12378">   GetURI(folderName);</span>
<a href="#l20.12379"></a><span id="l20.12379" class="difflineminus">-  MOZ_LOG(gAutoSyncLog, mozilla::LogLevel::Debug, (&quot;Updating folder: %s&quot;, folderName.get()));</span>
<a href="#l20.12380"></a><span id="l20.12380" class="difflineplus">+  MOZ_LOG(gAutoSyncLog, mozilla::LogLevel::Debug,</span>
<a href="#l20.12381"></a><span id="l20.12381" class="difflineplus">+          (&quot;Updating folder: %s&quot;, folderName.get()));</span>
<a href="#l20.12382"></a><span id="l20.12382"> </span>
<a href="#l20.12383"></a><span id="l20.12383">   // HACK: if UpdateFolder finds out that it can't open</span>
<a href="#l20.12384"></a><span id="l20.12384">   // the folder, it doesn't set the url listener and returns</span>
<a href="#l20.12385"></a><span id="l20.12385">   // no error. In this case, we return success from this call</span>
<a href="#l20.12386"></a><span id="l20.12386">   // but the caller never gets a notification on its url listener.</span>
<a href="#l20.12387"></a><span id="l20.12387">   bool canOpenThisFolder = true;</span>
<a href="#l20.12388"></a><span id="l20.12388">   GetCanOpenFolder(&amp;canOpenThisFolder);</span>
<a href="#l20.12389"></a><span id="l20.12389"> </span>
<a href="#l20.12390"></a><span id="l20.12390" class="difflineminus">-  if (!canOpenThisFolder)</span>
<a href="#l20.12391"></a><span id="l20.12391" class="difflineminus">-  {</span>
<a href="#l20.12392"></a><span id="l20.12392" class="difflineminus">-    MOZ_LOG(gAutoSyncLog, mozilla::LogLevel::Debug, (&quot;Cannot update folder: %s&quot;, folderName.get()));</span>
<a href="#l20.12393"></a><span id="l20.12393" class="difflineplus">+  if (!canOpenThisFolder) {</span>
<a href="#l20.12394"></a><span id="l20.12394" class="difflineplus">+    MOZ_LOG(gAutoSyncLog, mozilla::LogLevel::Debug,</span>
<a href="#l20.12395"></a><span id="l20.12395" class="difflineplus">+            (&quot;Cannot update folder: %s&quot;, folderName.get()));</span>
<a href="#l20.12396"></a><span id="l20.12396">     return NS_ERROR_FAILURE;</span>
<a href="#l20.12397"></a><span id="l20.12397">   }</span>
<a href="#l20.12398"></a><span id="l20.12398"> </span>
<a href="#l20.12399"></a><span id="l20.12399">   // create auto-sync state object lazily</span>
<a href="#l20.12400"></a><span id="l20.12400">   InitAutoSyncState();</span>
<a href="#l20.12401"></a><span id="l20.12401"> </span>
<a href="#l20.12402"></a><span id="l20.12402">   // make sure we get the counts from the folder cache.</span>
<a href="#l20.12403"></a><span id="l20.12403">   ReadDBFolderInfo(false);</span>
<a href="#l20.12404"></a><span id="l20.12404" class="difflineat">@@ -9542,268 +8744,245 @@ NS_IMETHODIMP nsImapMailFolder::Initiate</span>
<a href="#l20.12405"></a><span id="l20.12405">   // we update, and update it when the STATUS call finishes. This deals with</span>
<a href="#l20.12406"></a><span id="l20.12406">   // the case where biff is doing a STATUS on a non-inbox folder, which</span>
<a href="#l20.12407"></a><span id="l20.12407">   // can make autosync think the counts aren't changing.</span>
<a href="#l20.12408"></a><span id="l20.12408">   PRTime lastUpdateTime;</span>
<a href="#l20.12409"></a><span id="l20.12409">   m_autoSyncStateObj-&gt;GetLastUpdateTime(&amp;lastUpdateTime);</span>
<a href="#l20.12410"></a><span id="l20.12410">   if (!lastUpdateTime)</span>
<a href="#l20.12411"></a><span id="l20.12411">     m_autoSyncStateObj-&gt;SetServerCounts(m_numServerTotalMessages,</span>
<a href="#l20.12412"></a><span id="l20.12412">                                         m_numServerRecentMessages,</span>
<a href="#l20.12413"></a><span id="l20.12413" class="difflineminus">-                                        m_numServerUnseenMessages,</span>
<a href="#l20.12414"></a><span id="l20.12414" class="difflineminus">-                                        m_nextUID);</span>
<a href="#l20.12415"></a><span id="l20.12415" class="difflineplus">+                                        m_numServerUnseenMessages, m_nextUID);</span>
<a href="#l20.12416"></a><span id="l20.12416">   // Issue a STATUS command and see if any counts changed.</span>
<a href="#l20.12417"></a><span id="l20.12417">   m_autoSyncStateObj-&gt;SetState(nsAutoSyncState::stStatusIssued);</span>
<a href="#l20.12418"></a><span id="l20.12418">   // The OnStopRunningUrl method of the autosync state obj</span>
<a href="#l20.12419"></a><span id="l20.12419">   // will check if the counts or next uid have changed,</span>
<a href="#l20.12420"></a><span id="l20.12420">   // and if so, will issue an UpdateFolder().</span>
<a href="#l20.12421"></a><span id="l20.12421">   rv = UpdateStatus(m_autoSyncStateObj, nullptr);</span>
<a href="#l20.12422"></a><span id="l20.12422">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12423"></a><span id="l20.12423"> </span>
<a href="#l20.12424"></a><span id="l20.12424">   // record the last update time</span>
<a href="#l20.12425"></a><span id="l20.12425">   m_autoSyncStateObj-&gt;SetLastUpdateTime(PR_Now());</span>
<a href="#l20.12426"></a><span id="l20.12426"> </span>
<a href="#l20.12427"></a><span id="l20.12427">   return NS_OK;</span>
<a href="#l20.12428"></a><span id="l20.12428"> }</span>
<a href="#l20.12429"></a><span id="l20.12429"> </span>
<a href="#l20.12430"></a><span id="l20.12430" class="difflineminus">-nsresult nsImapMailFolder::CreatePlaybackTimer()</span>
<a href="#l20.12431"></a><span id="l20.12431" class="difflineminus">-{</span>
<a href="#l20.12432"></a><span id="l20.12432" class="difflineplus">+nsresult nsImapMailFolder::CreatePlaybackTimer() {</span>
<a href="#l20.12433"></a><span id="l20.12433">   nsresult rv = NS_OK;</span>
<a href="#l20.12434"></a><span id="l20.12434" class="difflineminus">-  if (!m_playbackTimer)</span>
<a href="#l20.12435"></a><span id="l20.12435" class="difflineminus">-  {</span>
<a href="#l20.12436"></a><span id="l20.12436" class="difflineplus">+  if (!m_playbackTimer) {</span>
<a href="#l20.12437"></a><span id="l20.12437">     m_playbackTimer = do_CreateInstance(NS_TIMER_CONTRACTID, &amp;rv);</span>
<a href="#l20.12438"></a><span id="l20.12438" class="difflineminus">-    NS_ASSERTION(NS_SUCCEEDED(rv),&quot;failed to create pseudo-offline operation timer in nsImapMailFolder&quot;);</span>
<a href="#l20.12439"></a><span id="l20.12439" class="difflineplus">+    NS_ASSERTION(</span>
<a href="#l20.12440"></a><span id="l20.12440" class="difflineplus">+        NS_SUCCEEDED(rv),</span>
<a href="#l20.12441"></a><span id="l20.12441" class="difflineplus">+        &quot;failed to create pseudo-offline operation timer in nsImapMailFolder&quot;);</span>
<a href="#l20.12442"></a><span id="l20.12442">   }</span>
<a href="#l20.12443"></a><span id="l20.12443">   return rv;</span>
<a href="#l20.12444"></a><span id="l20.12444"> }</span>
<a href="#l20.12445"></a><span id="l20.12445"> </span>
<a href="#l20.12446"></a><span id="l20.12446" class="difflineminus">-void nsImapMailFolder::PlaybackTimerCallback(nsITimer *aTimer, void *aClosure)</span>
<a href="#l20.12447"></a><span id="l20.12447" class="difflineminus">-{</span>
<a href="#l20.12448"></a><span id="l20.12448" class="difflineminus">-  nsPlaybackRequest *request = static_cast&lt;nsPlaybackRequest*&gt;(aClosure);</span>
<a href="#l20.12449"></a><span id="l20.12449" class="difflineminus">-</span>
<a href="#l20.12450"></a><span id="l20.12450" class="difflineminus">-  NS_ASSERTION(request-&gt;SrcFolder-&gt;m_pendingPlaybackReq == request, &quot;wrong playback request pointer&quot;);</span>
<a href="#l20.12451"></a><span id="l20.12451" class="difflineminus">-</span>
<a href="#l20.12452"></a><span id="l20.12452" class="difflineminus">-  RefPtr&lt;nsImapOfflineSync&gt; offlineSync = new nsImapOfflineSync(request-&gt;MsgWindow, nullptr, request-&gt;SrcFolder, true);</span>
<a href="#l20.12453"></a><span id="l20.12453" class="difflineminus">-  if (offlineSync)</span>
<a href="#l20.12454"></a><span id="l20.12454" class="difflineminus">-  {</span>
<a href="#l20.12455"></a><span id="l20.12455" class="difflineplus">+void nsImapMailFolder::PlaybackTimerCallback(nsITimer *aTimer, void *aClosure) {</span>
<a href="#l20.12456"></a><span id="l20.12456" class="difflineplus">+  nsPlaybackRequest *request = static_cast&lt;nsPlaybackRequest *&gt;(aClosure);</span>
<a href="#l20.12457"></a><span id="l20.12457" class="difflineplus">+</span>
<a href="#l20.12458"></a><span id="l20.12458" class="difflineplus">+  NS_ASSERTION(request-&gt;SrcFolder-&gt;m_pendingPlaybackReq == request,</span>
<a href="#l20.12459"></a><span id="l20.12459" class="difflineplus">+               &quot;wrong playback request pointer&quot;);</span>
<a href="#l20.12460"></a><span id="l20.12460" class="difflineplus">+</span>
<a href="#l20.12461"></a><span id="l20.12461" class="difflineplus">+  RefPtr&lt;nsImapOfflineSync&gt; offlineSync = new nsImapOfflineSync(</span>
<a href="#l20.12462"></a><span id="l20.12462" class="difflineplus">+      request-&gt;MsgWindow, nullptr, request-&gt;SrcFolder, true);</span>
<a href="#l20.12463"></a><span id="l20.12463" class="difflineplus">+  if (offlineSync) {</span>
<a href="#l20.12464"></a><span id="l20.12464">     mozilla::DebugOnly&lt;nsresult&gt; rv = offlineSync-&gt;ProcessNextOperation();</span>
<a href="#l20.12465"></a><span id="l20.12465">     NS_ASSERTION(NS_SUCCEEDED(rv), &quot;pseudo-offline playback is not successful&quot;);</span>
<a href="#l20.12466"></a><span id="l20.12466">   }</span>
<a href="#l20.12467"></a><span id="l20.12467"> </span>
<a href="#l20.12468"></a><span id="l20.12468">   // release request struct</span>
<a href="#l20.12469"></a><span id="l20.12469">   request-&gt;SrcFolder-&gt;m_pendingPlaybackReq = nullptr;</span>
<a href="#l20.12470"></a><span id="l20.12470">   delete request;</span>
<a href="#l20.12471"></a><span id="l20.12471"> }</span>
<a href="#l20.12472"></a><span id="l20.12472"> </span>
<a href="#l20.12473"></a><span id="l20.12473" class="difflineminus">-void nsImapMailFolder::InitAutoSyncState()</span>
<a href="#l20.12474"></a><span id="l20.12474" class="difflineminus">-{</span>
<a href="#l20.12475"></a><span id="l20.12475" class="difflineminus">-  if (!m_autoSyncStateObj)</span>
<a href="#l20.12476"></a><span id="l20.12476" class="difflineminus">-    m_autoSyncStateObj = new nsAutoSyncState(this);</span>
<a href="#l20.12477"></a><span id="l20.12477" class="difflineminus">-}</span>
<a href="#l20.12478"></a><span id="l20.12478" class="difflineminus">-</span>
<a href="#l20.12479"></a><span id="l20.12479" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::HasMsgOffline(nsMsgKey msgKey, bool *_retval)</span>
<a href="#l20.12480"></a><span id="l20.12480" class="difflineminus">-{</span>
<a href="#l20.12481"></a><span id="l20.12481" class="difflineplus">+void nsImapMailFolder::InitAutoSyncState() {</span>
<a href="#l20.12482"></a><span id="l20.12482" class="difflineplus">+  if (!m_autoSyncStateObj) m_autoSyncStateObj = new nsAutoSyncState(this);</span>
<a href="#l20.12483"></a><span id="l20.12483" class="difflineplus">+}</span>
<a href="#l20.12484"></a><span id="l20.12484" class="difflineplus">+</span>
<a href="#l20.12485"></a><span id="l20.12485" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::HasMsgOffline(nsMsgKey msgKey, bool *_retval) {</span>
<a href="#l20.12486"></a><span id="l20.12486">   NS_ENSURE_ARG_POINTER(_retval);</span>
<a href="#l20.12487"></a><span id="l20.12487">   *_retval = false;</span>
<a href="#l20.12488"></a><span id="l20.12488">   nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l20.12489"></a><span id="l20.12489">   nsresult rv = GetOfflineMsgFolder(msgKey, getter_AddRefs(msgFolder));</span>
<a href="#l20.12490"></a><span id="l20.12490" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; msgFolder)</span>
<a href="#l20.12491"></a><span id="l20.12491" class="difflineminus">-    *_retval = true;</span>
<a href="#l20.12492"></a><span id="l20.12492" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; msgFolder) *_retval = true;</span>
<a href="#l20.12493"></a><span id="l20.12493">   return NS_OK;</span>
<a href="#l20.12494"></a><span id="l20.12494" class="difflineminus">-</span>
<a href="#l20.12495"></a><span id="l20.12495" class="difflineminus">-}</span>
<a href="#l20.12496"></a><span id="l20.12496" class="difflineminus">-</span>
<a href="#l20.12497"></a><span id="l20.12497" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetOfflineMsgFolder(nsMsgKey msgKey, nsIMsgFolder **aMsgFolder)</span>
<a href="#l20.12498"></a><span id="l20.12498" class="difflineminus">-{</span>
<a href="#l20.12499"></a><span id="l20.12499" class="difflineplus">+}</span>
<a href="#l20.12500"></a><span id="l20.12500" class="difflineplus">+</span>
<a href="#l20.12501"></a><span id="l20.12501" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetOfflineMsgFolder(nsMsgKey msgKey,</span>
<a href="#l20.12502"></a><span id="l20.12502" class="difflineplus">+                                                    nsIMsgFolder **aMsgFolder) {</span>
<a href="#l20.12503"></a><span id="l20.12503">   // Check if we have the message in the current folder.</span>
<a href="#l20.12504"></a><span id="l20.12504">   NS_ENSURE_ARG_POINTER(aMsgFolder);</span>
<a href="#l20.12505"></a><span id="l20.12505">   nsCOMPtr&lt;nsIMsgFolder&gt; subMsgFolder;</span>
<a href="#l20.12506"></a><span id="l20.12506">   nsresult rv = GetDatabase();</span>
<a href="#l20.12507"></a><span id="l20.12507">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12508"></a><span id="l20.12508"> </span>
<a href="#l20.12509"></a><span id="l20.12509">   nsCOMPtr&lt;nsIMsgDBHdr&gt; hdr;</span>
<a href="#l20.12510"></a><span id="l20.12510">   rv = mDatabase-&gt;GetMsgHdrForKey(msgKey, getter_AddRefs(hdr));</span>
<a href="#l20.12511"></a><span id="l20.12511" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l20.12512"></a><span id="l20.12512" class="difflineminus">-    return rv;</span>
<a href="#l20.12513"></a><span id="l20.12513" class="difflineminus">-</span>
<a href="#l20.12514"></a><span id="l20.12514" class="difflineminus">-  if (hdr)</span>
<a href="#l20.12515"></a><span id="l20.12515" class="difflineminus">-  {</span>
<a href="#l20.12516"></a><span id="l20.12516" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.12517"></a><span id="l20.12517" class="difflineplus">+</span>
<a href="#l20.12518"></a><span id="l20.12518" class="difflineplus">+  if (hdr) {</span>
<a href="#l20.12519"></a><span id="l20.12519">     uint32_t msgFlags = 0;</span>
<a href="#l20.12520"></a><span id="l20.12520">     hdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l20.12521"></a><span id="l20.12521">     // Check if we already have this message body offline</span>
<a href="#l20.12522"></a><span id="l20.12522" class="difflineminus">-    if ((msgFlags &amp; nsMsgMessageFlags::Offline))</span>
<a href="#l20.12523"></a><span id="l20.12523" class="difflineminus">-    {</span>
<a href="#l20.12524"></a><span id="l20.12524" class="difflineplus">+    if ((msgFlags &amp; nsMsgMessageFlags::Offline)) {</span>
<a href="#l20.12525"></a><span id="l20.12525">       NS_IF_ADDREF(*aMsgFolder = this);</span>
<a href="#l20.12526"></a><span id="l20.12526">       return NS_OK;</span>
<a href="#l20.12527"></a><span id="l20.12527">     }</span>
<a href="#l20.12528"></a><span id="l20.12528">   }</span>
<a href="#l20.12529"></a><span id="l20.12529"> </span>
<a href="#l20.12530"></a><span id="l20.12530" class="difflineminus">-  if (!*aMsgFolder)</span>
<a href="#l20.12531"></a><span id="l20.12531" class="difflineminus">-  {</span>
<a href="#l20.12532"></a><span id="l20.12532" class="difflineminus">-    // Checking the existence of message in other folders in case of GMail Server</span>
<a href="#l20.12533"></a><span id="l20.12533" class="difflineplus">+  if (!*aMsgFolder) {</span>
<a href="#l20.12534"></a><span id="l20.12534" class="difflineplus">+    // Checking the existence of message in other folders in case of GMail</span>
<a href="#l20.12535"></a><span id="l20.12535" class="difflineplus">+    // Server</span>
<a href="#l20.12536"></a><span id="l20.12536">     bool isGMail;</span>
<a href="#l20.12537"></a><span id="l20.12537">     nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer;</span>
<a href="#l20.12538"></a><span id="l20.12538">     rv = GetImapIncomingServer(getter_AddRefs(imapServer));</span>
<a href="#l20.12539"></a><span id="l20.12539">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12540"></a><span id="l20.12540">     rv = imapServer-&gt;GetIsGMailServer(&amp;isGMail);</span>
<a href="#l20.12541"></a><span id="l20.12541">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12542"></a><span id="l20.12542"> </span>
<a href="#l20.12543"></a><span id="l20.12543" class="difflineminus">-    if (isGMail)</span>
<a href="#l20.12544"></a><span id="l20.12544" class="difflineminus">-    {</span>
<a href="#l20.12545"></a><span id="l20.12545" class="difflineplus">+    if (isGMail) {</span>
<a href="#l20.12546"></a><span id="l20.12546">       nsCString labels;</span>
<a href="#l20.12547"></a><span id="l20.12547">       nsTArray&lt;nsCString&gt; labelNames;</span>
<a href="#l20.12548"></a><span id="l20.12548">       hdr-&gt;GetStringProperty(&quot;X-GM-LABELS&quot;, getter_Copies(labels));</span>
<a href="#l20.12549"></a><span id="l20.12549">       ParseString(labels, ' ', labelNames);</span>
<a href="#l20.12550"></a><span id="l20.12550">       nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l20.12551"></a><span id="l20.12551">       nsCOMPtr&lt;nsIMsgImapMailFolder&gt; subFolder;</span>
<a href="#l20.12552"></a><span id="l20.12552" class="difflineminus">-      for (uint32_t i = 0; i &lt; labelNames.Length(); i++)</span>
<a href="#l20.12553"></a><span id="l20.12553" class="difflineminus">-      {</span>
<a href="#l20.12554"></a><span id="l20.12554" class="difflineplus">+      for (uint32_t i = 0; i &lt; labelNames.Length(); i++) {</span>
<a href="#l20.12555"></a><span id="l20.12555">         rv = GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l20.12556"></a><span id="l20.12556" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; (rootFolder))</span>
<a href="#l20.12557"></a><span id="l20.12557" class="difflineminus">-        {</span>
<a href="#l20.12558"></a><span id="l20.12558" class="difflineminus">-          nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapRootFolder = do_QueryInterface(rootFolder);</span>
<a href="#l20.12559"></a><span id="l20.12559" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; (rootFolder)) {</span>
<a href="#l20.12560"></a><span id="l20.12560" class="difflineplus">+          nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapRootFolder =</span>
<a href="#l20.12561"></a><span id="l20.12561" class="difflineplus">+              do_QueryInterface(rootFolder);</span>
<a href="#l20.12562"></a><span id="l20.12562">           if (labelNames[i].EqualsLiteral(&quot;\&quot;\\\\Draft\&quot;&quot;))</span>
<a href="#l20.12563"></a><span id="l20.12563" class="difflineminus">-             rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Drafts,</span>
<a href="#l20.12564"></a><span id="l20.12564" class="difflineminus">-                                                 getter_AddRefs(subMsgFolder));</span>
<a href="#l20.12565"></a><span id="l20.12565" class="difflineplus">+            rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Drafts,</span>
<a href="#l20.12566"></a><span id="l20.12566" class="difflineplus">+                                                getter_AddRefs(subMsgFolder));</span>
<a href="#l20.12567"></a><span id="l20.12567">           if (labelNames[i].EqualsLiteral(&quot;\&quot;\\\\Inbox\&quot;&quot;))</span>
<a href="#l20.12568"></a><span id="l20.12568" class="difflineminus">-             rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Inbox,</span>
<a href="#l20.12569"></a><span id="l20.12569" class="difflineminus">-                                                 getter_AddRefs(subMsgFolder));</span>
<a href="#l20.12570"></a><span id="l20.12570" class="difflineplus">+            rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Inbox,</span>
<a href="#l20.12571"></a><span id="l20.12571" class="difflineplus">+                                                getter_AddRefs(subMsgFolder));</span>
<a href="#l20.12572"></a><span id="l20.12572">           if (labelNames[i].EqualsLiteral(&quot;\&quot;\\\\All Mail\&quot;&quot;))</span>
<a href="#l20.12573"></a><span id="l20.12573" class="difflineminus">-             rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Archive,</span>
<a href="#l20.12574"></a><span id="l20.12574" class="difflineminus">-                                                 getter_AddRefs(subMsgFolder));</span>
<a href="#l20.12575"></a><span id="l20.12575" class="difflineplus">+            rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Archive,</span>
<a href="#l20.12576"></a><span id="l20.12576" class="difflineplus">+                                                getter_AddRefs(subMsgFolder));</span>
<a href="#l20.12577"></a><span id="l20.12577">           if (labelNames[i].EqualsLiteral(&quot;\&quot;\\\\Trash\&quot;&quot;))</span>
<a href="#l20.12578"></a><span id="l20.12578" class="difflineminus">-             rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Trash,</span>
<a href="#l20.12579"></a><span id="l20.12579" class="difflineminus">-                                                 getter_AddRefs(subMsgFolder));</span>
<a href="#l20.12580"></a><span id="l20.12580" class="difflineplus">+            rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Trash,</span>
<a href="#l20.12581"></a><span id="l20.12581" class="difflineplus">+                                                getter_AddRefs(subMsgFolder));</span>
<a href="#l20.12582"></a><span id="l20.12582">           if (labelNames[i].EqualsLiteral(&quot;\&quot;\\\\Spam\&quot;&quot;))</span>
<a href="#l20.12583"></a><span id="l20.12583" class="difflineminus">-             rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Junk,</span>
<a href="#l20.12584"></a><span id="l20.12584" class="difflineminus">-                                                 getter_AddRefs(subMsgFolder));</span>
<a href="#l20.12585"></a><span id="l20.12585" class="difflineplus">+            rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Junk,</span>
<a href="#l20.12586"></a><span id="l20.12586" class="difflineplus">+                                                getter_AddRefs(subMsgFolder));</span>
<a href="#l20.12587"></a><span id="l20.12587">           if (labelNames[i].EqualsLiteral(&quot;\&quot;\\\\Sent\&quot;&quot;))</span>
<a href="#l20.12588"></a><span id="l20.12588" class="difflineminus">-             rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::SentMail,</span>
<a href="#l20.12589"></a><span id="l20.12589" class="difflineminus">-                                                 getter_AddRefs(subMsgFolder));</span>
<a href="#l20.12590"></a><span id="l20.12590" class="difflineminus">-          if (labelNames[i].Find(&quot;[Imap]/&quot;, /* ignoreCase = */ true) != kNotFound)</span>
<a href="#l20.12591"></a><span id="l20.12591" class="difflineminus">-          {</span>
<a href="#l20.12592"></a><span id="l20.12592" class="difflineplus">+            rv = rootFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::SentMail,</span>
<a href="#l20.12593"></a><span id="l20.12593" class="difflineplus">+                                                getter_AddRefs(subMsgFolder));</span>
<a href="#l20.12594"></a><span id="l20.12594" class="difflineplus">+          if (labelNames[i].Find(&quot;[Imap]/&quot;, /* ignoreCase = */ true) !=</span>
<a href="#l20.12595"></a><span id="l20.12595" class="difflineplus">+              kNotFound) {</span>
<a href="#l20.12596"></a><span id="l20.12596">             MsgReplaceSubstring(labelNames[i], &quot;[Imap]/&quot;, &quot;&quot;);</span>
<a href="#l20.12597"></a><span id="l20.12597" class="difflineminus">-            imapRootFolder-&gt;FindOnlineSubFolder(labelNames[i], getter_AddRefs(subFolder));</span>
<a href="#l20.12598"></a><span id="l20.12598" class="difflineplus">+            imapRootFolder-&gt;FindOnlineSubFolder(labelNames[i],</span>
<a href="#l20.12599"></a><span id="l20.12599" class="difflineplus">+                                                getter_AddRefs(subFolder));</span>
<a href="#l20.12600"></a><span id="l20.12600">             subMsgFolder = do_QueryInterface(subFolder);</span>
<a href="#l20.12601"></a><span id="l20.12601">           }</span>
<a href="#l20.12602"></a><span id="l20.12602" class="difflineminus">-          if (!subMsgFolder)</span>
<a href="#l20.12603"></a><span id="l20.12603" class="difflineminus">-          {</span>
<a href="#l20.12604"></a><span id="l20.12604" class="difflineminus">-            imapRootFolder-&gt;FindOnlineSubFolder(labelNames[i], getter_AddRefs(subFolder));</span>
<a href="#l20.12605"></a><span id="l20.12605" class="difflineplus">+          if (!subMsgFolder) {</span>
<a href="#l20.12606"></a><span id="l20.12606" class="difflineplus">+            imapRootFolder-&gt;FindOnlineSubFolder(labelNames[i],</span>
<a href="#l20.12607"></a><span id="l20.12607" class="difflineplus">+                                                getter_AddRefs(subFolder));</span>
<a href="#l20.12608"></a><span id="l20.12608">             subMsgFolder = do_QueryInterface(subFolder);</span>
<a href="#l20.12609"></a><span id="l20.12609">           }</span>
<a href="#l20.12610"></a><span id="l20.12610" class="difflineminus">-          if (subMsgFolder)</span>
<a href="#l20.12611"></a><span id="l20.12611" class="difflineminus">-          {</span>
<a href="#l20.12612"></a><span id="l20.12612" class="difflineplus">+          if (subMsgFolder) {</span>
<a href="#l20.12613"></a><span id="l20.12613">             nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l20.12614"></a><span id="l20.12614">             subMsgFolder-&gt;GetMsgDatabase(getter_AddRefs(db));</span>
<a href="#l20.12615"></a><span id="l20.12615" class="difflineminus">-            if (db)</span>
<a href="#l20.12616"></a><span id="l20.12616" class="difflineminus">-            {</span>
<a href="#l20.12617"></a><span id="l20.12617" class="difflineplus">+            if (db) {</span>
<a href="#l20.12618"></a><span id="l20.12618">               nsCOMPtr&lt;nsIMsgDBHdr&gt; retHdr;</span>
<a href="#l20.12619"></a><span id="l20.12619">               nsCString gmMsgID;</span>
<a href="#l20.12620"></a><span id="l20.12620">               hdr-&gt;GetStringProperty(&quot;X-GM-MSGID&quot;, getter_Copies(gmMsgID));</span>
<a href="#l20.12621"></a><span id="l20.12621" class="difflineminus">-              rv = db-&gt;GetMsgHdrForGMMsgID(gmMsgID.get(), getter_AddRefs(retHdr));</span>
<a href="#l20.12622"></a><span id="l20.12622" class="difflineminus">-              if (NS_FAILED(rv))</span>
<a href="#l20.12623"></a><span id="l20.12623" class="difflineminus">-                return rv;</span>
<a href="#l20.12624"></a><span id="l20.12624" class="difflineminus">-              if (retHdr)</span>
<a href="#l20.12625"></a><span id="l20.12625" class="difflineminus">-              {</span>
<a href="#l20.12626"></a><span id="l20.12626" class="difflineplus">+              rv = db-&gt;GetMsgHdrForGMMsgID(gmMsgID.get(),</span>
<a href="#l20.12627"></a><span id="l20.12627" class="difflineplus">+                                           getter_AddRefs(retHdr));</span>
<a href="#l20.12628"></a><span id="l20.12628" class="difflineplus">+              if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.12629"></a><span id="l20.12629" class="difflineplus">+              if (retHdr) {</span>
<a href="#l20.12630"></a><span id="l20.12630">                 uint32_t gmFlags = 0;</span>
<a href="#l20.12631"></a><span id="l20.12631">                 retHdr-&gt;GetFlags(&amp;gmFlags);</span>
<a href="#l20.12632"></a><span id="l20.12632" class="difflineminus">-                if ((gmFlags &amp; nsMsgMessageFlags::Offline))</span>
<a href="#l20.12633"></a><span id="l20.12633" class="difflineminus">-                {</span>
<a href="#l20.12634"></a><span id="l20.12634" class="difflineplus">+                if ((gmFlags &amp; nsMsgMessageFlags::Offline)) {</span>
<a href="#l20.12635"></a><span id="l20.12635">                   subMsgFolder.forget(aMsgFolder);</span>
<a href="#l20.12636"></a><span id="l20.12636">                   // Focus on first positive result.</span>
<a href="#l20.12637"></a><span id="l20.12637">                   return NS_OK;</span>
<a href="#l20.12638"></a><span id="l20.12638">                 }</span>
<a href="#l20.12639"></a><span id="l20.12639">               }</span>
<a href="#l20.12640"></a><span id="l20.12640">             }</span>
<a href="#l20.12641"></a><span id="l20.12641">           }</span>
<a href="#l20.12642"></a><span id="l20.12642">         }</span>
<a href="#l20.12643"></a><span id="l20.12643">       }</span>
<a href="#l20.12644"></a><span id="l20.12644">     }</span>
<a href="#l20.12645"></a><span id="l20.12645">   }</span>
<a href="#l20.12646"></a><span id="l20.12646">   return NS_OK;</span>
<a href="#l20.12647"></a><span id="l20.12647"> }</span>
<a href="#l20.12648"></a><span id="l20.12648"> </span>
<a href="#l20.12649"></a><span id="l20.12649" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetOfflineFileStream(nsMsgKey msgKey, int64_t *offset, uint32_t *size, nsIInputStream **aFileStream)</span>
<a href="#l20.12650"></a><span id="l20.12650" class="difflineminus">-{</span>
<a href="#l20.12651"></a><span id="l20.12651" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetOfflineFileStream(</span>
<a href="#l20.12652"></a><span id="l20.12652" class="difflineplus">+    nsMsgKey msgKey, int64_t *offset, uint32_t *size,</span>
<a href="#l20.12653"></a><span id="l20.12653" class="difflineplus">+    nsIInputStream **aFileStream) {</span>
<a href="#l20.12654"></a><span id="l20.12654">   NS_ENSURE_ARG(aFileStream);</span>
<a href="#l20.12655"></a><span id="l20.12655">   nsCOMPtr&lt;nsIMsgFolder&gt; offlineFolder;</span>
<a href="#l20.12656"></a><span id="l20.12656">   nsresult rv = GetOfflineMsgFolder(msgKey, getter_AddRefs(offlineFolder));</span>
<a href="#l20.12657"></a><span id="l20.12657">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12658"></a><span id="l20.12658" class="difflineminus">-  if(!offlineFolder)</span>
<a href="#l20.12659"></a><span id="l20.12659" class="difflineminus">-    return NS_ERROR_FAILURE;</span>
<a href="#l20.12660"></a><span id="l20.12660" class="difflineplus">+  if (!offlineFolder) return NS_ERROR_FAILURE;</span>
<a href="#l20.12661"></a><span id="l20.12661"> </span>
<a href="#l20.12662"></a><span id="l20.12662">   rv = GetDatabase();</span>
<a href="#l20.12663"></a><span id="l20.12663">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l20.12664"></a><span id="l20.12664"> </span>
<a href="#l20.12665"></a><span id="l20.12665">   if (offlineFolder == this)</span>
<a href="#l20.12666"></a><span id="l20.12666" class="difflineminus">-    return nsMsgDBFolder::GetOfflineFileStream(msgKey, offset, size, aFileStream);</span>
<a href="#l20.12667"></a><span id="l20.12667" class="difflineplus">+    return nsMsgDBFolder::GetOfflineFileStream(msgKey, offset, size,</span>
<a href="#l20.12668"></a><span id="l20.12668" class="difflineplus">+                                               aFileStream);</span>
<a href="#l20.12669"></a><span id="l20.12669"> </span>
<a href="#l20.12670"></a><span id="l20.12670">   nsCOMPtr&lt;nsIMsgDBHdr&gt; hdr;</span>
<a href="#l20.12671"></a><span id="l20.12671">   rv = mDatabase-&gt;GetMsgHdrForKey(msgKey, getter_AddRefs(hdr));</span>
<a href="#l20.12672"></a><span id="l20.12672" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l20.12673"></a><span id="l20.12673" class="difflineminus">-    return rv;</span>
<a href="#l20.12674"></a><span id="l20.12674" class="difflineminus">-  if (hdr)</span>
<a href="#l20.12675"></a><span id="l20.12675" class="difflineminus">-  {</span>
<a href="#l20.12676"></a><span id="l20.12676" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.12677"></a><span id="l20.12677" class="difflineplus">+  if (hdr) {</span>
<a href="#l20.12678"></a><span id="l20.12678">     nsCString gmMsgID;</span>
<a href="#l20.12679"></a><span id="l20.12679">     hdr-&gt;GetStringProperty(&quot;X-GM-MSGID&quot;, getter_Copies(gmMsgID));</span>
<a href="#l20.12680"></a><span id="l20.12680">     nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l20.12681"></a><span id="l20.12681">     offlineFolder-&gt;GetMsgDatabase(getter_AddRefs(db));</span>
<a href="#l20.12682"></a><span id="l20.12682">     rv = db-&gt;GetMsgHdrForGMMsgID(gmMsgID.get(), getter_AddRefs(hdr));</span>
<a href="#l20.12683"></a><span id="l20.12683" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l20.12684"></a><span id="l20.12684" class="difflineminus">-      return rv;</span>
<a href="#l20.12685"></a><span id="l20.12685" class="difflineplus">+    if (NS_FAILED(rv)) return rv;</span>
<a href="#l20.12686"></a><span id="l20.12686">     nsMsgKey newMsgKey;</span>
<a href="#l20.12687"></a><span id="l20.12687">     hdr-&gt;GetMessageKey(&amp;newMsgKey);</span>
<a href="#l20.12688"></a><span id="l20.12688" class="difflineminus">-    return offlineFolder-&gt;GetOfflineFileStream(newMsgKey, offset, size, aFileStream);</span>
<a href="#l20.12689"></a><span id="l20.12689" class="difflineplus">+    return offlineFolder-&gt;GetOfflineFileStream(newMsgKey, offset, size,</span>
<a href="#l20.12690"></a><span id="l20.12690" class="difflineplus">+                                               aFileStream);</span>
<a href="#l20.12691"></a><span id="l20.12691">   }</span>
<a href="#l20.12692"></a><span id="l20.12692">   return NS_OK;</span>
<a href="#l20.12693"></a><span id="l20.12693"> }</span>
<a href="#l20.12694"></a><span id="l20.12694"> </span>
<a href="#l20.12695"></a><span id="l20.12695" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::GetIncomingServerType(nsACString&amp; serverType)</span>
<a href="#l20.12696"></a><span id="l20.12696" class="difflineminus">-{</span>
<a href="#l20.12697"></a><span id="l20.12697" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetIncomingServerType(nsACString &amp;serverType) {</span>
<a href="#l20.12698"></a><span id="l20.12698">   serverType.AssignLiteral(&quot;imap&quot;);</span>
<a href="#l20.12699"></a><span id="l20.12699">   return NS_OK;</span>
<a href="#l20.12700"></a><span id="l20.12700"> }</span>
<a href="#l20.12701"></a><span id="l20.12701"> </span>
<a href="#l20.12702"></a><span id="l20.12702" class="difflineminus">-void nsImapMailFolder::DeleteStoreMessages(nsIArray* aMessages)</span>
<a href="#l20.12703"></a><span id="l20.12703" class="difflineminus">-{</span>
<a href="#l20.12704"></a><span id="l20.12704" class="difflineplus">+void nsImapMailFolder::DeleteStoreMessages(nsIArray *aMessages) {</span>
<a href="#l20.12705"></a><span id="l20.12705">   // Delete messages for pluggable stores that do not support compaction.</span>
<a href="#l20.12706"></a><span id="l20.12706">   nsCOMPtr&lt;nsIMsgPluggableStore&gt; offlineStore;</span>
<a href="#l20.12707"></a><span id="l20.12707" class="difflineminus">-  (void) GetMsgStore(getter_AddRefs(offlineStore));</span>
<a href="#l20.12708"></a><span id="l20.12708" class="difflineminus">-</span>
<a href="#l20.12709"></a><span id="l20.12709" class="difflineminus">-  if (offlineStore)</span>
<a href="#l20.12710"></a><span id="l20.12710" class="difflineminus">-  {</span>
<a href="#l20.12711"></a><span id="l20.12711" class="difflineplus">+  (void)GetMsgStore(getter_AddRefs(offlineStore));</span>
<a href="#l20.12712"></a><span id="l20.12712" class="difflineplus">+</span>
<a href="#l20.12713"></a><span id="l20.12713" class="difflineplus">+  if (offlineStore) {</span>
<a href="#l20.12714"></a><span id="l20.12714">     bool supportsCompaction;</span>
<a href="#l20.12715"></a><span id="l20.12715">     offlineStore-&gt;GetSupportsCompaction(&amp;supportsCompaction);</span>
<a href="#l20.12716"></a><span id="l20.12716" class="difflineminus">-    if (!supportsCompaction)</span>
<a href="#l20.12717"></a><span id="l20.12717" class="difflineminus">-      offlineStore-&gt;DeleteMessages(aMessages);</span>
<a href="#l20.12718"></a><span id="l20.12718" class="difflineminus">-  }</span>
<a href="#l20.12719"></a><span id="l20.12719" class="difflineminus">-}</span>
<a href="#l20.12720"></a><span id="l20.12720" class="difflineminus">-</span>
<a href="#l20.12721"></a><span id="l20.12721" class="difflineminus">-void nsImapMailFolder::DeleteStoreMessages(nsTArray&lt;nsMsgKey&gt; &amp;aMessages)</span>
<a href="#l20.12722"></a><span id="l20.12722" class="difflineminus">-{</span>
<a href="#l20.12723"></a><span id="l20.12723" class="difflineplus">+    if (!supportsCompaction) offlineStore-&gt;DeleteMessages(aMessages);</span>
<a href="#l20.12724"></a><span id="l20.12724" class="difflineplus">+  }</span>
<a href="#l20.12725"></a><span id="l20.12725" class="difflineplus">+}</span>
<a href="#l20.12726"></a><span id="l20.12726" class="difflineplus">+</span>
<a href="#l20.12727"></a><span id="l20.12727" class="difflineplus">+void nsImapMailFolder::DeleteStoreMessages(nsTArray&lt;nsMsgKey&gt; &amp;aMessages) {</span>
<a href="#l20.12728"></a><span id="l20.12728">   DeleteStoreMessages(aMessages, this);</span>
<a href="#l20.12729"></a><span id="l20.12729"> }</span>
<a href="#l20.12730"></a><span id="l20.12730"> </span>
<a href="#l20.12731"></a><span id="l20.12731"> void nsImapMailFolder::DeleteStoreMessages(nsTArray&lt;nsMsgKey&gt; &amp;aMessages,</span>
<a href="#l20.12732"></a><span id="l20.12732" class="difflineminus">-                                           nsIMsgFolder* aFolder)</span>
<a href="#l20.12733"></a><span id="l20.12733" class="difflineminus">-{</span>
<a href="#l20.12734"></a><span id="l20.12734" class="difflineplus">+                                           nsIMsgFolder *aFolder) {</span>
<a href="#l20.12735"></a><span id="l20.12735">   // Delete messages for pluggable stores that do not support compaction.</span>
<a href="#l20.12736"></a><span id="l20.12736">   NS_ASSERTION(aFolder, &quot;Missing Source Folder&quot;);</span>
<a href="#l20.12737"></a><span id="l20.12737">   nsCOMPtr&lt;nsIMsgPluggableStore&gt; offlineStore;</span>
<a href="#l20.12738"></a><span id="l20.12738" class="difflineminus">-  (void) aFolder-&gt;GetMsgStore(getter_AddRefs(offlineStore));</span>
<a href="#l20.12739"></a><span id="l20.12739" class="difflineminus">-  if (offlineStore)</span>
<a href="#l20.12740"></a><span id="l20.12740" class="difflineminus">-  {</span>
<a href="#l20.12741"></a><span id="l20.12741" class="difflineplus">+  (void)aFolder-&gt;GetMsgStore(getter_AddRefs(offlineStore));</span>
<a href="#l20.12742"></a><span id="l20.12742" class="difflineplus">+  if (offlineStore) {</span>
<a href="#l20.12743"></a><span id="l20.12743">     bool supportsCompaction;</span>
<a href="#l20.12744"></a><span id="l20.12744">     offlineStore-&gt;GetSupportsCompaction(&amp;supportsCompaction);</span>
<a href="#l20.12745"></a><span id="l20.12745" class="difflineminus">-    if (!supportsCompaction)</span>
<a href="#l20.12746"></a><span id="l20.12746" class="difflineminus">-    {</span>
<a href="#l20.12747"></a><span id="l20.12747" class="difflineplus">+    if (!supportsCompaction) {</span>
<a href="#l20.12748"></a><span id="l20.12748">       nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l20.12749"></a><span id="l20.12749">       aFolder-&gt;GetMsgDatabase(getter_AddRefs(db));</span>
<a href="#l20.12750"></a><span id="l20.12750">       nsresult rv = NS_ERROR_FAILURE;</span>
<a href="#l20.12751"></a><span id="l20.12751" class="difflineminus">-      nsCOMPtr&lt;nsIMutableArray&gt; messages(do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l20.12752"></a><span id="l20.12752" class="difflineminus">-      if (db)</span>
<a href="#l20.12753"></a><span id="l20.12753" class="difflineminus">-        rv = MsgGetHeadersFromKeys(db, aMessages, messages);</span>
<a href="#l20.12754"></a><span id="l20.12754" class="difflineplus">+      nsCOMPtr&lt;nsIMutableArray&gt; messages(</span>
<a href="#l20.12755"></a><span id="l20.12755" class="difflineplus">+          do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l20.12756"></a><span id="l20.12756" class="difflineplus">+      if (db) rv = MsgGetHeadersFromKeys(db, aMessages, messages);</span>
<a href="#l20.12757"></a><span id="l20.12757">       if (NS_SUCCEEDED(rv))</span>
<a href="#l20.12758"></a><span id="l20.12758">         offlineStore-&gt;DeleteMessages(messages);</span>
<a href="#l20.12759"></a><span id="l20.12759">       else</span>
<a href="#l20.12760"></a><span id="l20.12760">         NS_WARNING(&quot;Failed to get database&quot;);</span>
<a href="#l20.12761"></a><span id="l20.12761">     }</span>
<a href="#l20.12762"></a><span id="l20.12762">   }</span>
<a href="#l20.12763"></a><span id="l20.12763"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/mailnews/imap/src/nsImapMailFolder.h</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapMailFolder.h</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -1,24 +1,24 @@</span>
<a href="#l21.4"></a><span id="l21.4"> /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l21.5"></a><span id="l21.5"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l21.6"></a><span id="l21.6">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l21.7"></a><span id="l21.7">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l21.8"></a><span id="l21.8"> #ifndef nsImapMailFolder_h__</span>
<a href="#l21.9"></a><span id="l21.9"> #define nsImapMailFolder_h__</span>
<a href="#l21.10"></a><span id="l21.10"> </span>
<a href="#l21.11"></a><span id="l21.11"> #include &quot;mozilla/Attributes.h&quot;</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-#include &quot;nsImapCore.h&quot; // so that consumers including ImapMailFolder.h also get the kImapMsg* constants</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+#include &quot;nsImapCore.h&quot;  // so that consumers including ImapMailFolder.h also get the kImapMsg* constants</span>
<a href="#l21.14"></a><span id="l21.14"> #include &quot;nsMsgDBFolder.h&quot;</span>
<a href="#l21.15"></a><span id="l21.15"> #include &quot;nsIImapMailFolderSink.h&quot;</span>
<a href="#l21.16"></a><span id="l21.16"> #include &quot;nsIImapMessageSink.h&quot;</span>
<a href="#l21.17"></a><span id="l21.17"> #include &quot;nsICopyMessageListener.h&quot;</span>
<a href="#l21.18"></a><span id="l21.18"> #include &quot;nsIUrlListener.h&quot;</span>
<a href="#l21.19"></a><span id="l21.19"> #include &quot;nsAutoPtr.h&quot;</span>
<a href="#l21.20"></a><span id="l21.20" class="difflineminus">-#include &quot;nsIImapIncomingServer.h&quot; // we need this for its IID</span>
<a href="#l21.21"></a><span id="l21.21" class="difflineplus">+#include &quot;nsIImapIncomingServer.h&quot;  // we need this for its IID</span>
<a href="#l21.22"></a><span id="l21.22"> #include &quot;nsIMsgParseMailMsgState.h&quot;</span>
<a href="#l21.23"></a><span id="l21.23"> #include &quot;nsImapUndoTxn.h&quot;</span>
<a href="#l21.24"></a><span id="l21.24"> #include &quot;nsIMsgMessageService.h&quot;</span>
<a href="#l21.25"></a><span id="l21.25"> #include &quot;nsIMsgFilterHitNotify.h&quot;</span>
<a href="#l21.26"></a><span id="l21.26"> #include &quot;nsIMsgFilterList.h&quot;</span>
<a href="#l21.27"></a><span id="l21.27"> #include &quot;prmon.h&quot;</span>
<a href="#l21.28"></a><span id="l21.28"> #include &quot;nsIMsgImapMailFolder.h&quot;</span>
<a href="#l21.29"></a><span id="l21.29"> #include &quot;nsIMsgThread.h&quot;</span>
<a href="#l21.30"></a><span id="l21.30" class="difflineat">@@ -33,100 +33,107 @@</span>
<a href="#l21.31"></a><span id="l21.31"> #include &quot;nsAutoSyncState.h&quot;</span>
<a href="#l21.32"></a><span id="l21.32"> </span>
<a href="#l21.33"></a><span id="l21.33"> class nsImapMoveCoalescer;</span>
<a href="#l21.34"></a><span id="l21.34"> class nsIMsgIdentity;</span>
<a href="#l21.35"></a><span id="l21.35"> class nsIMsgOfflineImapOperation;</span>
<a href="#l21.36"></a><span id="l21.36"> </span>
<a href="#l21.37"></a><span id="l21.37"> #define COPY_BUFFER_SIZE 16384</span>
<a href="#l21.38"></a><span id="l21.38"> </span>
<a href="#l21.39"></a><span id="l21.39" class="difflineminus">-#define NS_IMAPMAILCOPYSTATE_IID \</span>
<a href="#l21.40"></a><span id="l21.40" class="difflineminus">-{ 0xb64534f0, 0x3d53, 0x11d3, \</span>
<a href="#l21.41"></a><span id="l21.41" class="difflineminus">-    { 0xac, 0x2a, 0x00, 0x80, 0x5f, 0x8a, 0xc9, 0x68 } }</span>
<a href="#l21.42"></a><span id="l21.42" class="difflineplus">+#define NS_IMAPMAILCOPYSTATE_IID                     \</span>
<a href="#l21.43"></a><span id="l21.43" class="difflineplus">+  {                                                  \</span>
<a href="#l21.44"></a><span id="l21.44" class="difflineplus">+    0xb64534f0, 0x3d53, 0x11d3, {                    \</span>
<a href="#l21.45"></a><span id="l21.45" class="difflineplus">+      0xac, 0x2a, 0x00, 0x80, 0x5f, 0x8a, 0xc9, 0x68 \</span>
<a href="#l21.46"></a><span id="l21.46" class="difflineplus">+    }                                                \</span>
<a href="#l21.47"></a><span id="l21.47" class="difflineplus">+  }</span>
<a href="#l21.48"></a><span id="l21.48"> </span>
<a href="#l21.49"></a><span id="l21.49" class="difflineminus">-class nsImapMailCopyState: public nsISupports</span>
<a href="#l21.50"></a><span id="l21.50" class="difflineminus">-{</span>
<a href="#l21.51"></a><span id="l21.51" class="difflineminus">-public:</span>
<a href="#l21.52"></a><span id="l21.52" class="difflineminus">-    NS_DECLARE_STATIC_IID_ACCESSOR(NS_IMAPMAILCOPYSTATE_IID)</span>
<a href="#l21.53"></a><span id="l21.53" class="difflineminus">-</span>
<a href="#l21.54"></a><span id="l21.54" class="difflineminus">-    NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l21.55"></a><span id="l21.55" class="difflineplus">+class nsImapMailCopyState : public nsISupports {</span>
<a href="#l21.56"></a><span id="l21.56" class="difflineplus">+ public:</span>
<a href="#l21.57"></a><span id="l21.57" class="difflineplus">+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IMAPMAILCOPYSTATE_IID)</span>
<a href="#l21.58"></a><span id="l21.58"> </span>
<a href="#l21.59"></a><span id="l21.59" class="difflineminus">-    nsImapMailCopyState();</span>
<a href="#l21.60"></a><span id="l21.60" class="difflineplus">+  NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l21.61"></a><span id="l21.61" class="difflineplus">+</span>
<a href="#l21.62"></a><span id="l21.62" class="difflineplus">+  nsImapMailCopyState();</span>
<a href="#l21.63"></a><span id="l21.63"> </span>
<a href="#l21.64"></a><span id="l21.64" class="difflineminus">-    nsCOMPtr&lt;nsISupports&gt; m_srcSupport; // source file spec or folder</span>
<a href="#l21.65"></a><span id="l21.65" class="difflineminus">-    nsCOMPtr&lt;nsIArray&gt; m_messages; // array of source messages</span>
<a href="#l21.66"></a><span id="l21.66" class="difflineminus">-    RefPtr&lt;nsImapMoveCopyMsgTxn&gt; m_undoMsgTxn; // undo object with this copy operation</span>
<a href="#l21.67"></a><span id="l21.67" class="difflineminus">-    nsCOMPtr&lt;nsIMsgDBHdr&gt; m_message; // current message to be copied</span>
<a href="#l21.68"></a><span id="l21.68" class="difflineminus">-    nsCOMPtr&lt;nsIMsgCopyServiceListener&gt; m_listener; // listener of this copy</span>
<a href="#l21.69"></a><span id="l21.69" class="difflineminus">-                                                    // operation</span>
<a href="#l21.70"></a><span id="l21.70" class="difflineminus">-    nsCOMPtr&lt;nsIFile&gt; m_tmpFile; // temp file spec for copy operation</span>
<a href="#l21.71"></a><span id="l21.71" class="difflineminus">-    nsCOMPtr&lt;nsIMsgWindow&gt; m_msgWindow; // msg window for copy operation</span>
<a href="#l21.72"></a><span id="l21.72" class="difflineplus">+  nsCOMPtr&lt;nsISupports&gt; m_srcSupport;  // source file spec or folder</span>
<a href="#l21.73"></a><span id="l21.73" class="difflineplus">+  nsCOMPtr&lt;nsIArray&gt; m_messages;       // array of source messages</span>
<a href="#l21.74"></a><span id="l21.74" class="difflineplus">+  RefPtr&lt;nsImapMoveCopyMsgTxn&gt;</span>
<a href="#l21.75"></a><span id="l21.75" class="difflineplus">+      m_undoMsgTxn;                 // undo object with this copy operation</span>
<a href="#l21.76"></a><span id="l21.76" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBHdr&gt; m_message;  // current message to be copied</span>
<a href="#l21.77"></a><span id="l21.77" class="difflineplus">+  nsCOMPtr&lt;nsIMsgCopyServiceListener&gt; m_listener;  // listener of this copy</span>
<a href="#l21.78"></a><span id="l21.78" class="difflineplus">+                                                   // operation</span>
<a href="#l21.79"></a><span id="l21.79" class="difflineplus">+  nsCOMPtr&lt;nsIFile&gt; m_tmpFile;         // temp file spec for copy operation</span>
<a href="#l21.80"></a><span id="l21.80" class="difflineplus">+  nsCOMPtr&lt;nsIMsgWindow&gt; m_msgWindow;  // msg window for copy operation</span>
<a href="#l21.81"></a><span id="l21.81"> </span>
<a href="#l21.82"></a><span id="l21.82" class="difflineminus">-    nsCOMPtr&lt;nsIMsgMessageService&gt; m_msgService; // source folder message service; can</span>
<a href="#l21.83"></a><span id="l21.83" class="difflineminus">-                                        // be Nntp, Mailbox, or Imap</span>
<a href="#l21.84"></a><span id="l21.84" class="difflineminus">-    bool m_isMove;             // is a move</span>
<a href="#l21.85"></a><span id="l21.85" class="difflineminus">-    bool m_selectedState;      // needs to be in selected state; append msg</span>
<a href="#l21.86"></a><span id="l21.86" class="difflineminus">-    bool m_isCrossServerOp; // are we copying between imap servers?</span>
<a href="#l21.87"></a><span id="l21.87" class="difflineminus">-    uint32_t m_curIndex; // message index to the message array which we are</span>
<a href="#l21.88"></a><span id="l21.88" class="difflineminus">-                         // copying</span>
<a href="#l21.89"></a><span id="l21.89" class="difflineminus">-    uint32_t m_totalCount;// total count of messages we have to do</span>
<a href="#l21.90"></a><span id="l21.90" class="difflineminus">-    uint32_t m_unreadCount; // num unread messages we're moving</span>
<a href="#l21.91"></a><span id="l21.91" class="difflineminus">-    bool m_streamCopy;</span>
<a href="#l21.92"></a><span id="l21.92" class="difflineminus">-    char *m_dataBuffer; // temporary buffer for this copy operation</span>
<a href="#l21.93"></a><span id="l21.93" class="difflineminus">-    nsCOMPtr&lt;nsIOutputStream&gt; m_msgFileStream;         // temporary file (processed mail)</span>
<a href="#l21.94"></a><span id="l21.94" class="difflineminus">-    uint32_t m_dataBufferSize;</span>
<a href="#l21.95"></a><span id="l21.95" class="difflineminus">-    uint32_t m_leftOver;</span>
<a href="#l21.96"></a><span id="l21.96" class="difflineminus">-    bool m_allowUndo;</span>
<a href="#l21.97"></a><span id="l21.97" class="difflineminus">-    bool m_eatLF;</span>
<a href="#l21.98"></a><span id="l21.98" class="difflineminus">-    uint32_t m_newMsgFlags; // only used if there's no m_message</span>
<a href="#l21.99"></a><span id="l21.99" class="difflineminus">-    nsCString m_newMsgKeywords; // ditto</span>
<a href="#l21.100"></a><span id="l21.100" class="difflineminus">-    // If the server supports UIDPLUS, this is the UID for the append,</span>
<a href="#l21.101"></a><span id="l21.101" class="difflineminus">-    // if we're doing an append.</span>
<a href="#l21.102"></a><span id="l21.102" class="difflineminus">-    nsMsgKey m_appendUID;</span>
<a href="#l21.103"></a><span id="l21.103" class="difflineplus">+  nsCOMPtr&lt;nsIMsgMessageService&gt;</span>
<a href="#l21.104"></a><span id="l21.104" class="difflineplus">+      m_msgService;        // source folder message service; can</span>
<a href="#l21.105"></a><span id="l21.105" class="difflineplus">+                           // be Nntp, Mailbox, or Imap</span>
<a href="#l21.106"></a><span id="l21.106" class="difflineplus">+  bool m_isMove;           // is a move</span>
<a href="#l21.107"></a><span id="l21.107" class="difflineplus">+  bool m_selectedState;    // needs to be in selected state; append msg</span>
<a href="#l21.108"></a><span id="l21.108" class="difflineplus">+  bool m_isCrossServerOp;  // are we copying between imap servers?</span>
<a href="#l21.109"></a><span id="l21.109" class="difflineplus">+  uint32_t m_curIndex;     // message index to the message array which we are</span>
<a href="#l21.110"></a><span id="l21.110" class="difflineplus">+                           // copying</span>
<a href="#l21.111"></a><span id="l21.111" class="difflineplus">+  uint32_t m_totalCount;   // total count of messages we have to do</span>
<a href="#l21.112"></a><span id="l21.112" class="difflineplus">+  uint32_t m_unreadCount;  // num unread messages we're moving</span>
<a href="#l21.113"></a><span id="l21.113" class="difflineplus">+  bool m_streamCopy;</span>
<a href="#l21.114"></a><span id="l21.114" class="difflineplus">+  char *m_dataBuffer;  // temporary buffer for this copy operation</span>
<a href="#l21.115"></a><span id="l21.115" class="difflineplus">+  nsCOMPtr&lt;nsIOutputStream&gt; m_msgFileStream;  // temporary file (processed mail)</span>
<a href="#l21.116"></a><span id="l21.116" class="difflineplus">+  uint32_t m_dataBufferSize;</span>
<a href="#l21.117"></a><span id="l21.117" class="difflineplus">+  uint32_t m_leftOver;</span>
<a href="#l21.118"></a><span id="l21.118" class="difflineplus">+  bool m_allowUndo;</span>
<a href="#l21.119"></a><span id="l21.119" class="difflineplus">+  bool m_eatLF;</span>
<a href="#l21.120"></a><span id="l21.120" class="difflineplus">+  uint32_t m_newMsgFlags;      // only used if there's no m_message</span>
<a href="#l21.121"></a><span id="l21.121" class="difflineplus">+  nsCString m_newMsgKeywords;  // ditto</span>
<a href="#l21.122"></a><span id="l21.122" class="difflineplus">+  // If the server supports UIDPLUS, this is the UID for the append,</span>
<a href="#l21.123"></a><span id="l21.123" class="difflineplus">+  // if we're doing an append.</span>
<a href="#l21.124"></a><span id="l21.124" class="difflineplus">+  nsMsgKey m_appendUID;</span>
<a href="#l21.125"></a><span id="l21.125"> </span>
<a href="#l21.126"></a><span id="l21.126" class="difflineminus">-private:</span>
<a href="#l21.127"></a><span id="l21.127" class="difflineminus">-    virtual ~nsImapMailCopyState();</span>
<a href="#l21.128"></a><span id="l21.128" class="difflineplus">+ private:</span>
<a href="#l21.129"></a><span id="l21.129" class="difflineplus">+  virtual ~nsImapMailCopyState();</span>
<a href="#l21.130"></a><span id="l21.130"> };</span>
<a href="#l21.131"></a><span id="l21.131"> </span>
<a href="#l21.132"></a><span id="l21.132"> NS_DEFINE_STATIC_IID_ACCESSOR(nsImapMailCopyState, NS_IMAPMAILCOPYSTATE_IID)</span>
<a href="#l21.133"></a><span id="l21.133"> </span>
<a href="#l21.134"></a><span id="l21.134"> // ACLs for this folder.</span>
<a href="#l21.135"></a><span id="l21.135"> // Generally, we will try to always query this class when performing</span>
<a href="#l21.136"></a><span id="l21.136"> // an operation on the folder.</span>
<a href="#l21.137"></a><span id="l21.137"> // If the server doesn't support ACLs, none of this data will be filled in.</span>
<a href="#l21.138"></a><span id="l21.138"> // Therefore, we can assume that if we look up ourselves and don't find</span>
<a href="#l21.139"></a><span id="l21.139" class="difflineminus">-// any info (and also look up &quot;anyone&quot;) then we have full rights, that is, ACLs don't exist.</span>
<a href="#l21.140"></a><span id="l21.140" class="difflineplus">+// any info (and also look up &quot;anyone&quot;) then we have full rights, that is, ACLs</span>
<a href="#l21.141"></a><span id="l21.141" class="difflineplus">+// don't exist.</span>
<a href="#l21.142"></a><span id="l21.142"> class nsImapMailFolder;</span>
<a href="#l21.143"></a><span id="l21.143"> </span>
<a href="#l21.144"></a><span id="l21.144" class="difflineminus">-#define IMAP_ACL_READ_FLAG 0x0000001 /* SELECT, CHECK, FETCH, PARTIAL, SEARCH, COPY from folder */</span>
<a href="#l21.145"></a><span id="l21.145" class="difflineminus">-#define IMAP_ACL_STORE_SEEN_FLAG 0x0000002 /* STORE SEEN flag */</span>
<a href="#l21.146"></a><span id="l21.146" class="difflineminus">-#define IMAP_ACL_WRITE_FLAG 0x0000004 /* STORE flags other than SEEN and DELETED */</span>
<a href="#l21.147"></a><span id="l21.147" class="difflineminus">-#define IMAP_ACL_INSERT_FLAG 0x0000008 /* APPEND, COPY into folder */</span>
<a href="#l21.148"></a><span id="l21.148" class="difflineminus">-#define IMAP_ACL_POST_FLAG 0x0000010 /* Can I send mail to the submission address for folder? */</span>
<a href="#l21.149"></a><span id="l21.149" class="difflineminus">-#define IMAP_ACL_CREATE_SUBFOLDER_FLAG 0x0000020 /* Can I CREATE a subfolder of this folder? */</span>
<a href="#l21.150"></a><span id="l21.150" class="difflineminus">-#define IMAP_ACL_DELETE_FLAG 0x0000040 /* STORE DELETED flag */</span>
<a href="#l21.151"></a><span id="l21.151" class="difflineminus">-#define IMAP_ACL_ADMINISTER_FLAG 0x0000080 /* perform SETACL */</span>
<a href="#l21.152"></a><span id="l21.152" class="difflineminus">-#define IMAP_ACL_RETRIEVED_FLAG 0x0000100 /* ACL info for this folder has been initialized */</span>
<a href="#l21.153"></a><span id="l21.153" class="difflineminus">-#define IMAP_ACL_EXPUNGE_FLAG 0x0000200 // can EXPUNGE or do implicit EXPUNGE on CLOSE</span>
<a href="#l21.154"></a><span id="l21.154" class="difflineminus">-#define IMAP_ACL_DELETE_FOLDER 0x0000400 // can DELETE/RENAME folder</span>
<a href="#l21.155"></a><span id="l21.155" class="difflineplus">+// clang-format off</span>
<a href="#l21.156"></a><span id="l21.156" class="difflineplus">+#define IMAP_ACL_READ_FLAG             0x0000001 // SELECT, CHECK, FETCH, PARTIAL, SEARCH, COPY from folder</span>
<a href="#l21.157"></a><span id="l21.157" class="difflineplus">+#define IMAP_ACL_STORE_SEEN_FLAG       0x0000002 // STORE SEEN flag</span>
<a href="#l21.158"></a><span id="l21.158" class="difflineplus">+#define IMAP_ACL_WRITE_FLAG            0x0000004 // STORE flags other than SEEN and DELETED</span>
<a href="#l21.159"></a><span id="l21.159" class="difflineplus">+#define IMAP_ACL_INSERT_FLAG           0x0000008 // APPEND, COPY into folder */</span>
<a href="#l21.160"></a><span id="l21.160" class="difflineplus">+#define IMAP_ACL_POST_FLAG             0x0000010 // Can I send mail to the submission address for folder?</span>
<a href="#l21.161"></a><span id="l21.161" class="difflineplus">+#define IMAP_ACL_CREATE_SUBFOLDER_FLAG 0x0000020 // Can I CREATE a subfolder of this folder?</span>
<a href="#l21.162"></a><span id="l21.162" class="difflineplus">+#define IMAP_ACL_DELETE_FLAG           0x0000040 // STORE DELETED flag</span>
<a href="#l21.163"></a><span id="l21.163" class="difflineplus">+#define IMAP_ACL_ADMINISTER_FLAG       0x0000080 // perform SETACL</span>
<a href="#l21.164"></a><span id="l21.164" class="difflineplus">+#define IMAP_ACL_RETRIEVED_FLAG        0x0000100 // ACL info for this folder has been initialized</span>
<a href="#l21.165"></a><span id="l21.165" class="difflineplus">+#define IMAP_ACL_EXPUNGE_FLAG          0x0000200 // can EXPUNGE or do implicit EXPUNGE on CLOSE</span>
<a href="#l21.166"></a><span id="l21.166" class="difflineplus">+#define IMAP_ACL_DELETE_FOLDER         0x0000400 // can DELETE/RENAME folder</span>
<a href="#l21.167"></a><span id="l21.167" class="difflineplus">+// clang-format on</span>
<a href="#l21.168"></a><span id="l21.168"> </span>
<a href="#l21.169"></a><span id="l21.169" class="difflineminus">-class nsMsgIMAPFolderACL</span>
<a href="#l21.170"></a><span id="l21.170" class="difflineminus">-{</span>
<a href="#l21.171"></a><span id="l21.171" class="difflineminus">-public:</span>
<a href="#l21.172"></a><span id="l21.172" class="difflineplus">+class nsMsgIMAPFolderACL {</span>
<a href="#l21.173"></a><span id="l21.173" class="difflineplus">+ public:</span>
<a href="#l21.174"></a><span id="l21.174">   explicit nsMsgIMAPFolderACL(nsImapMailFolder *folder);</span>
<a href="#l21.175"></a><span id="l21.175">   ~nsMsgIMAPFolderACL();</span>
<a href="#l21.176"></a><span id="l21.176"> </span>
<a href="#l21.177"></a><span id="l21.177" class="difflineminus">-  bool SetFolderRightsForUser(const nsACString&amp; userName, const nsACString&amp; rights);</span>
<a href="#l21.178"></a><span id="l21.178" class="difflineminus">-</span>
<a href="#l21.179"></a><span id="l21.179" class="difflineminus">-public:</span>
<a href="#l21.180"></a><span id="l21.180" class="difflineplus">+  bool SetFolderRightsForUser(const nsACString &amp;userName,</span>
<a href="#l21.181"></a><span id="l21.181" class="difflineplus">+                              const nsACString &amp;rights);</span>
<a href="#l21.182"></a><span id="l21.182"> </span>
<a href="#l21.183"></a><span id="l21.183" class="difflineplus">+ public:</span>
<a href="#l21.184"></a><span id="l21.184">   // generic for any user, although we might not use them in</span>
<a href="#l21.185"></a><span id="l21.185" class="difflineminus">-  // DO NOT use these for looking up information about the currently authenticated user.</span>
<a href="#l21.186"></a><span id="l21.186" class="difflineminus">-  // (There are some different checks and defaults we do).</span>
<a href="#l21.187"></a><span id="l21.187" class="difflineplus">+  // DO NOT use these for looking up information about the currently</span>
<a href="#l21.188"></a><span id="l21.188" class="difflineplus">+  // authenticated user. (There are some different checks and defaults we do).</span>
<a href="#l21.189"></a><span id="l21.189">   // Instead, use the functions below, GetICan....()</span>
<a href="#l21.190"></a><span id="l21.190" class="difflineplus">+  // clang-format off</span>
<a href="#l21.191"></a><span id="l21.191">   bool GetCanUserLookupFolder(const nsACString&amp; userName);      // Is folder visible to LIST/LSUB?</span>
<a href="#l21.192"></a><span id="l21.192">   bool GetCanUserReadFolder(const nsACString&amp; userName);        // SELECT, CHECK, FETCH, PARTIAL, SEARCH, COPY from folder?</span>
<a href="#l21.193"></a><span id="l21.193">   bool GetCanUserStoreSeenInFolder(const nsACString&amp; userName); // STORE SEEN flag?</span>
<a href="#l21.194"></a><span id="l21.194">   bool GetCanUserWriteFolder(const nsACString&amp; userName);       // STORE flags other than SEEN and DELETED?</span>
<a href="#l21.195"></a><span id="l21.195">   bool GetCanUserInsertInFolder(const nsACString&amp; userName);    // APPEND, COPY into folder?</span>
<a href="#l21.196"></a><span id="l21.196">   bool GetCanUserPostToFolder(const nsACString&amp; userName);      // Can I send mail to the submission address for folder?</span>
<a href="#l21.197"></a><span id="l21.197">   bool GetCanUserCreateSubfolder(const nsACString&amp; userName);   // Can I CREATE a subfolder of this folder?</span>
<a href="#l21.198"></a><span id="l21.198">   bool GetCanUserDeleteInFolder(const nsACString&amp; userName);    // STORE DELETED flag, perform EXPUNGE?</span>
<a href="#l21.199"></a><span id="l21.199" class="difflineat">@@ -139,305 +146,333 @@ public:</span>
<a href="#l21.200"></a><span id="l21.200">   bool GetCanIStoreSeenInFolder(); // STORE SEEN flag?</span>
<a href="#l21.201"></a><span id="l21.201">   bool GetCanIWriteFolder();       // STORE flags other than SEEN and DELETED?</span>
<a href="#l21.202"></a><span id="l21.202">   bool GetCanIInsertInFolder();    // APPEND, COPY into folder?</span>
<a href="#l21.203"></a><span id="l21.203">   bool GetCanIPostToFolder();      // Can I send mail to the submission address for folder?</span>
<a href="#l21.204"></a><span id="l21.204">   bool GetCanICreateSubfolder();   // Can I CREATE a subfolder of this folder?</span>
<a href="#l21.205"></a><span id="l21.205">   bool GetCanIDeleteInFolder();    // STORE DELETED flag?</span>
<a href="#l21.206"></a><span id="l21.206">   bool GetCanIAdministerFolder();  // perform SETACL?</span>
<a href="#l21.207"></a><span id="l21.207">   bool GetCanIExpungeFolder();     // perform EXPUNGE?</span>
<a href="#l21.208"></a><span id="l21.208" class="difflineplus">+  // clang-format on</span>
<a href="#l21.209"></a><span id="l21.209"> </span>
<a href="#l21.210"></a><span id="l21.210" class="difflineminus">-  bool GetDoIHaveFullRightsForFolder(); // Returns TRUE if I have full rights on this folder (all of the above return TRUE)</span>
<a href="#l21.211"></a><span id="l21.211" class="difflineplus">+  bool GetDoIHaveFullRightsForFolder();  // Returns TRUE if I have full rights</span>
<a href="#l21.212"></a><span id="l21.212" class="difflineplus">+                                         // on this folder (all of the above</span>
<a href="#l21.213"></a><span id="l21.213" class="difflineplus">+                                         // return TRUE)</span>
<a href="#l21.214"></a><span id="l21.214"> </span>
<a href="#l21.215"></a><span id="l21.215" class="difflineminus">-  bool GetIsFolderShared(); // We use this to see if the ACLs think a folder is shared or not.</span>
<a href="#l21.216"></a><span id="l21.216" class="difflineplus">+  bool GetIsFolderShared();  // We use this to see if the ACLs think a folder is</span>
<a href="#l21.217"></a><span id="l21.217" class="difflineplus">+                             // shared or not.</span>
<a href="#l21.218"></a><span id="l21.218">   // We will define &quot;Shared&quot; in 5.0 to mean:</span>
<a href="#l21.219"></a><span id="l21.219" class="difflineminus">-  // At least one user other than the currently authenticated user has at least one</span>
<a href="#l21.220"></a><span id="l21.220" class="difflineminus">-  // explicitly-listed ACL right on that folder.</span>
<a href="#l21.221"></a><span id="l21.221" class="difflineplus">+  // At least one user other than the currently authenticated user has at least</span>
<a href="#l21.222"></a><span id="l21.222" class="difflineplus">+  // one explicitly-listed ACL right on that folder.</span>
<a href="#l21.223"></a><span id="l21.223"> </span>
<a href="#l21.224"></a><span id="l21.224">   // Returns a newly allocated string describing these rights</span>
<a href="#l21.225"></a><span id="l21.225" class="difflineminus">-  nsresult CreateACLRightsString(nsAString&amp; rightsString);</span>
<a href="#l21.226"></a><span id="l21.226" class="difflineplus">+  nsresult CreateACLRightsString(nsAString &amp;rightsString);</span>
<a href="#l21.227"></a><span id="l21.227"> </span>
<a href="#l21.228"></a><span id="l21.228" class="difflineminus">-  nsresult GetRightsStringForUser(const nsACString&amp; userName, nsCString &amp;rights);</span>
<a href="#l21.229"></a><span id="l21.229" class="difflineplus">+  nsresult GetRightsStringForUser(const nsACString &amp;userName,</span>
<a href="#l21.230"></a><span id="l21.230" class="difflineplus">+                                  nsCString &amp;rights);</span>
<a href="#l21.231"></a><span id="l21.231"> </span>
<a href="#l21.232"></a><span id="l21.232" class="difflineminus">-  nsresult GetOtherUsers(nsIUTF8StringEnumerator** aResult);</span>
<a href="#l21.233"></a><span id="l21.233" class="difflineplus">+  nsresult GetOtherUsers(nsIUTF8StringEnumerator **aResult);</span>
<a href="#l21.234"></a><span id="l21.234"> </span>
<a href="#l21.235"></a><span id="l21.235" class="difflineminus">-protected:</span>
<a href="#l21.236"></a><span id="l21.236" class="difflineminus">-  bool GetFlagSetInRightsForUser(const nsACString&amp; userName, char flag, bool defaultIfNotFound);</span>
<a href="#l21.237"></a><span id="l21.237" class="difflineplus">+ protected:</span>
<a href="#l21.238"></a><span id="l21.238" class="difflineplus">+  bool GetFlagSetInRightsForUser(const nsACString &amp;userName, char flag,</span>
<a href="#l21.239"></a><span id="l21.239" class="difflineplus">+                                 bool defaultIfNotFound);</span>
<a href="#l21.240"></a><span id="l21.240">   void BuildInitialACLFromCache();</span>
<a href="#l21.241"></a><span id="l21.241">   void UpdateACLCache();</span>
<a href="#l21.242"></a><span id="l21.242"> </span>
<a href="#l21.243"></a><span id="l21.243" class="difflineminus">-protected:</span>
<a href="#l21.244"></a><span id="l21.244" class="difflineminus">-  nsDataHashtable &lt;nsCStringHashKey, nsCString&gt; m_rightsHash; // Hash table, mapping username strings to rights strings.</span>
<a href="#l21.245"></a><span id="l21.245" class="difflineplus">+ protected:</span>
<a href="#l21.246"></a><span id="l21.246" class="difflineplus">+  nsDataHashtable&lt;nsCStringHashKey, nsCString&gt;</span>
<a href="#l21.247"></a><span id="l21.247" class="difflineplus">+      m_rightsHash;  // Hash table, mapping username strings to rights strings.</span>
<a href="#l21.248"></a><span id="l21.248">   nsImapMailFolder *m_folder;</span>
<a href="#l21.249"></a><span id="l21.249" class="difflineminus">-  int32_t        m_aclCount;</span>
<a href="#l21.250"></a><span id="l21.250" class="difflineminus">-</span>
<a href="#l21.251"></a><span id="l21.251" class="difflineplus">+  int32_t m_aclCount;</span>
<a href="#l21.252"></a><span id="l21.252"> };</span>
<a href="#l21.253"></a><span id="l21.253"> </span>
<a href="#l21.254"></a><span id="l21.254"> /**</span>
<a href="#l21.255"></a><span id="l21.255">  * Encapsulates parameters required to playback offline ops</span>
<a href="#l21.256"></a><span id="l21.256">  * on given folder.</span>
<a href="#l21.257"></a><span id="l21.257">  */</span>
<a href="#l21.258"></a><span id="l21.258" class="difflineminus">-struct nsPlaybackRequest</span>
<a href="#l21.259"></a><span id="l21.259" class="difflineminus">-{</span>
<a href="#l21.260"></a><span id="l21.260" class="difflineminus">-  explicit nsPlaybackRequest(nsImapMailFolder *srcFolder, nsIMsgWindow *msgWindow)</span>
<a href="#l21.261"></a><span id="l21.261" class="difflineminus">-    : SrcFolder(srcFolder), MsgWindow(msgWindow)</span>
<a href="#l21.262"></a><span id="l21.262" class="difflineminus">-  {</span>
<a href="#l21.263"></a><span id="l21.263" class="difflineminus">-  }</span>
<a href="#l21.264"></a><span id="l21.264" class="difflineplus">+struct nsPlaybackRequest {</span>
<a href="#l21.265"></a><span id="l21.265" class="difflineplus">+  explicit nsPlaybackRequest(nsImapMailFolder *srcFolder,</span>
<a href="#l21.266"></a><span id="l21.266" class="difflineplus">+                             nsIMsgWindow *msgWindow)</span>
<a href="#l21.267"></a><span id="l21.267" class="difflineplus">+      : SrcFolder(srcFolder), MsgWindow(msgWindow) {}</span>
<a href="#l21.268"></a><span id="l21.268">   nsImapMailFolder *SrcFolder;</span>
<a href="#l21.269"></a><span id="l21.269">   nsCOMPtr&lt;nsIMsgWindow&gt; MsgWindow;</span>
<a href="#l21.270"></a><span id="l21.270"> };</span>
<a href="#l21.271"></a><span id="l21.271"> </span>
<a href="#l21.272"></a><span id="l21.272" class="difflineminus">-class nsImapMailFolder :  public nsMsgDBFolder,</span>
<a href="#l21.273"></a><span id="l21.273" class="difflineminus">-                          public nsIMsgImapMailFolder,</span>
<a href="#l21.274"></a><span id="l21.274" class="difflineminus">-                          public nsIImapMailFolderSink,</span>
<a href="#l21.275"></a><span id="l21.275" class="difflineminus">-                          public nsIImapMessageSink,</span>
<a href="#l21.276"></a><span id="l21.276" class="difflineminus">-                          public nsICopyMessageListener,</span>
<a href="#l21.277"></a><span id="l21.277" class="difflineminus">-                          public nsIMsgFilterHitNotify</span>
<a href="#l21.278"></a><span id="l21.278" class="difflineminus">-{</span>
<a href="#l21.279"></a><span id="l21.279" class="difflineminus">- static const uint32_t PLAYBACK_TIMER_INTERVAL_IN_MS = 500;</span>
<a href="#l21.280"></a><span id="l21.280" class="difflineminus">-public:</span>
<a href="#l21.281"></a><span id="l21.281" class="difflineplus">+class nsImapMailFolder : public nsMsgDBFolder,</span>
<a href="#l21.282"></a><span id="l21.282" class="difflineplus">+                         public nsIMsgImapMailFolder,</span>
<a href="#l21.283"></a><span id="l21.283" class="difflineplus">+                         public nsIImapMailFolderSink,</span>
<a href="#l21.284"></a><span id="l21.284" class="difflineplus">+                         public nsIImapMessageSink,</span>
<a href="#l21.285"></a><span id="l21.285" class="difflineplus">+                         public nsICopyMessageListener,</span>
<a href="#l21.286"></a><span id="l21.286" class="difflineplus">+                         public nsIMsgFilterHitNotify {</span>
<a href="#l21.287"></a><span id="l21.287" class="difflineplus">+  static const uint32_t PLAYBACK_TIMER_INTERVAL_IN_MS = 500;</span>
<a href="#l21.288"></a><span id="l21.288" class="difflineplus">+</span>
<a href="#l21.289"></a><span id="l21.289" class="difflineplus">+ public:</span>
<a href="#l21.290"></a><span id="l21.290">   nsImapMailFolder();</span>
<a href="#l21.291"></a><span id="l21.291"> </span>
<a href="#l21.292"></a><span id="l21.292">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l21.293"></a><span id="l21.293"> </span>
<a href="#l21.294"></a><span id="l21.294">   // nsIMsgFolder methods:</span>
<a href="#l21.295"></a><span id="l21.295">   NS_IMETHOD GetSubFolders(nsISimpleEnumerator **aResult) override;</span>
<a href="#l21.296"></a><span id="l21.296"> </span>
<a href="#l21.297"></a><span id="l21.297" class="difflineminus">-  NS_IMETHOD GetMessages(nsISimpleEnumerator* *result) override;</span>
<a href="#l21.298"></a><span id="l21.298" class="difflineplus">+  NS_IMETHOD GetMessages(nsISimpleEnumerator **result) override;</span>
<a href="#l21.299"></a><span id="l21.299">   NS_IMETHOD UpdateFolder(nsIMsgWindow *aWindow) override;</span>
<a href="#l21.300"></a><span id="l21.300"> </span>
<a href="#l21.301"></a><span id="l21.301" class="difflineminus">-  NS_IMETHOD CreateSubfolder(const nsAString&amp; folderName,nsIMsgWindow *msgWindow ) override;</span>
<a href="#l21.302"></a><span id="l21.302" class="difflineminus">-  NS_IMETHOD AddSubfolder(const nsAString&amp; aName, nsIMsgFolder** aChild) override;</span>
<a href="#l21.303"></a><span id="l21.303" class="difflineminus">-  NS_IMETHODIMP CreateStorageIfMissing(nsIUrlListener* urlListener) override;</span>
<a href="#l21.304"></a><span id="l21.304" class="difflineplus">+  NS_IMETHOD CreateSubfolder(const nsAString &amp;folderName,</span>
<a href="#l21.305"></a><span id="l21.305" class="difflineplus">+                             nsIMsgWindow *msgWindow) override;</span>
<a href="#l21.306"></a><span id="l21.306" class="difflineplus">+  NS_IMETHOD AddSubfolder(const nsAString &amp;aName,</span>
<a href="#l21.307"></a><span id="l21.307" class="difflineplus">+                          nsIMsgFolder **aChild) override;</span>
<a href="#l21.308"></a><span id="l21.308" class="difflineplus">+  NS_IMETHODIMP CreateStorageIfMissing(nsIUrlListener *urlListener) override;</span>
<a href="#l21.309"></a><span id="l21.309"> </span>
<a href="#l21.310"></a><span id="l21.310" class="difflineminus">-  NS_IMETHOD Compact(nsIUrlListener *aListener, nsIMsgWindow *aMsgWindow) override;</span>
<a href="#l21.311"></a><span id="l21.311" class="difflineplus">+  NS_IMETHOD Compact(nsIUrlListener *aListener,</span>
<a href="#l21.312"></a><span id="l21.312" class="difflineplus">+                     nsIMsgWindow *aMsgWindow) override;</span>
<a href="#l21.313"></a><span id="l21.313">   NS_IMETHOD CompactAll(nsIUrlListener *aListener, nsIMsgWindow *aMsgWindow,</span>
<a href="#l21.314"></a><span id="l21.314">                         bool aCompactOfflineAlso) override;</span>
<a href="#l21.315"></a><span id="l21.315" class="difflineminus">-  NS_IMETHOD EmptyTrash(nsIMsgWindow *msgWindow, nsIUrlListener *aListener) override;</span>
<a href="#l21.316"></a><span id="l21.316" class="difflineminus">-  NS_IMETHOD CopyDataToOutputStreamForAppend(nsIInputStream *aIStream,</span>
<a href="#l21.317"></a><span id="l21.317" class="difflineminus">-                     int32_t aLength, nsIOutputStream *outputStream) override;</span>
<a href="#l21.318"></a><span id="l21.318" class="difflineplus">+  NS_IMETHOD EmptyTrash(nsIMsgWindow *msgWindow,</span>
<a href="#l21.319"></a><span id="l21.319" class="difflineplus">+                        nsIUrlListener *aListener) override;</span>
<a href="#l21.320"></a><span id="l21.320" class="difflineplus">+  NS_IMETHOD CopyDataToOutputStreamForAppend(</span>
<a href="#l21.321"></a><span id="l21.321" class="difflineplus">+      nsIInputStream *aIStream, int32_t aLength,</span>
<a href="#l21.322"></a><span id="l21.322" class="difflineplus">+      nsIOutputStream *outputStream) override;</span>
<a href="#l21.323"></a><span id="l21.323">   NS_IMETHOD CopyDataDone() override;</span>
<a href="#l21.324"></a><span id="l21.324" class="difflineminus">-  NS_IMETHOD Delete () override;</span>
<a href="#l21.325"></a><span id="l21.325" class="difflineminus">-  NS_IMETHOD Rename (const nsAString&amp; newName, nsIMsgWindow *msgWindow) override;</span>
<a href="#l21.326"></a><span id="l21.326" class="difflineminus">-  NS_IMETHOD RenameSubFolders(nsIMsgWindow *msgWindow, nsIMsgFolder *oldFolder) override;</span>
<a href="#l21.327"></a><span id="l21.327" class="difflineplus">+  NS_IMETHOD Delete() override;</span>
<a href="#l21.328"></a><span id="l21.328" class="difflineplus">+  NS_IMETHOD Rename(const nsAString &amp;newName, nsIMsgWindow *msgWindow) override;</span>
<a href="#l21.329"></a><span id="l21.329" class="difflineplus">+  NS_IMETHOD RenameSubFolders(nsIMsgWindow *msgWindow,</span>
<a href="#l21.330"></a><span id="l21.330" class="difflineplus">+                              nsIMsgFolder *oldFolder) override;</span>
<a href="#l21.331"></a><span id="l21.331">   NS_IMETHOD GetNoSelect(bool *aResult) override;</span>
<a href="#l21.332"></a><span id="l21.332"> </span>
<a href="#l21.333"></a><span id="l21.333" class="difflineminus">-  NS_IMETHOD GetPrettyName(nsAString&amp; prettyName) override; // Override of the base, for top-level mail folder</span>
<a href="#l21.334"></a><span id="l21.334" class="difflineplus">+  NS_IMETHOD GetPrettyName(nsAString &amp;prettyName)</span>
<a href="#l21.335"></a><span id="l21.335" class="difflineplus">+      override;  // Override of the base, for top-level mail folder</span>
<a href="#l21.336"></a><span id="l21.336"> </span>
<a href="#l21.337"></a><span id="l21.337" class="difflineminus">-  NS_IMETHOD GetFolderURL(nsACString&amp; url) override;</span>
<a href="#l21.338"></a><span id="l21.338" class="difflineplus">+  NS_IMETHOD GetFolderURL(nsACString &amp;url) override;</span>
<a href="#l21.339"></a><span id="l21.339"> </span>
<a href="#l21.340"></a><span id="l21.340">   NS_IMETHOD UpdateSummaryTotals(bool force) override;</span>
<a href="#l21.341"></a><span id="l21.341"> </span>
<a href="#l21.342"></a><span id="l21.342" class="difflineminus">-  NS_IMETHOD GetDeletable (bool *deletable) override;</span>
<a href="#l21.343"></a><span id="l21.343" class="difflineplus">+  NS_IMETHOD GetDeletable(bool *deletable) override;</span>
<a href="#l21.344"></a><span id="l21.344"> </span>
<a href="#l21.345"></a><span id="l21.345">   NS_IMETHOD GetSizeOnDisk(int64_t *size) override;</span>
<a href="#l21.346"></a><span id="l21.346"> </span>
<a href="#l21.347"></a><span id="l21.347">   NS_IMETHOD GetCanCreateSubfolders(bool *aResult) override;</span>
<a href="#l21.348"></a><span id="l21.348">   NS_IMETHOD GetCanSubscribe(bool *aResult) override;</span>
<a href="#l21.349"></a><span id="l21.349"> </span>
<a href="#l21.350"></a><span id="l21.350">   NS_IMETHOD ApplyRetentionSettings() override;</span>
<a href="#l21.351"></a><span id="l21.351"> </span>
<a href="#l21.352"></a><span id="l21.352" class="difflineminus">-  NS_IMETHOD AddMessageDispositionState(nsIMsgDBHdr *aMessage, nsMsgDispositionState aDispositionFlag) override;</span>
<a href="#l21.353"></a><span id="l21.353" class="difflineplus">+  NS_IMETHOD AddMessageDispositionState(</span>
<a href="#l21.354"></a><span id="l21.354" class="difflineplus">+      nsIMsgDBHdr *aMessage, nsMsgDispositionState aDispositionFlag) override;</span>
<a href="#l21.355"></a><span id="l21.355">   NS_IMETHOD MarkMessagesRead(nsIArray *messages, bool markRead) override;</span>
<a href="#l21.356"></a><span id="l21.356">   NS_IMETHOD MarkAllMessagesRead(nsIMsgWindow *aMsgWindow) override;</span>
<a href="#l21.357"></a><span id="l21.357">   NS_IMETHOD MarkMessagesFlagged(nsIArray *messages, bool markFlagged) override;</span>
<a href="#l21.358"></a><span id="l21.358">   NS_IMETHOD MarkThreadRead(nsIMsgThread *thread) override;</span>
<a href="#l21.359"></a><span id="l21.359" class="difflineminus">-  NS_IMETHOD SetLabelForMessages(nsIArray *aMessages, nsMsgLabelValue aLabel) override;</span>
<a href="#l21.360"></a><span id="l21.360" class="difflineminus">-  NS_IMETHOD SetJunkScoreForMessages(nsIArray *aMessages, const nsACString&amp; aJunkScore) override;</span>
<a href="#l21.361"></a><span id="l21.361" class="difflineminus">-  NS_IMETHOD DeleteSubFolders(nsIArray *folders, nsIMsgWindow *msgWindow) override;</span>
<a href="#l21.362"></a><span id="l21.362" class="difflineminus">-  NS_IMETHOD ReadFromFolderCacheElem(nsIMsgFolderCacheElement *element) override;</span>
<a href="#l21.363"></a><span id="l21.363" class="difflineplus">+  NS_IMETHOD SetLabelForMessages(nsIArray *aMessages,</span>
<a href="#l21.364"></a><span id="l21.364" class="difflineplus">+                                 nsMsgLabelValue aLabel) override;</span>
<a href="#l21.365"></a><span id="l21.365" class="difflineplus">+  NS_IMETHOD SetJunkScoreForMessages(nsIArray *aMessages,</span>
<a href="#l21.366"></a><span id="l21.366" class="difflineplus">+                                     const nsACString &amp;aJunkScore) override;</span>
<a href="#l21.367"></a><span id="l21.367" class="difflineplus">+  NS_IMETHOD DeleteSubFolders(nsIArray *folders,</span>
<a href="#l21.368"></a><span id="l21.368" class="difflineplus">+                              nsIMsgWindow *msgWindow) override;</span>
<a href="#l21.369"></a><span id="l21.369" class="difflineplus">+  NS_IMETHOD ReadFromFolderCacheElem(</span>
<a href="#l21.370"></a><span id="l21.370" class="difflineplus">+      nsIMsgFolderCacheElement *element) override;</span>
<a href="#l21.371"></a><span id="l21.371">   NS_IMETHOD WriteToFolderCacheElem(nsIMsgFolderCacheElement *element) override;</span>
<a href="#l21.372"></a><span id="l21.372"> </span>
<a href="#l21.373"></a><span id="l21.373">   NS_IMETHOD GetDBFolderInfoAndDB(nsIDBFolderInfo **folderInfo,</span>
<a href="#l21.374"></a><span id="l21.374">                                   nsIMsgDatabase **db) override;</span>
<a href="#l21.375"></a><span id="l21.375" class="difflineminus">-  NS_IMETHOD DeleteMessages(nsIArray *messages,</span>
<a href="#l21.376"></a><span id="l21.376" class="difflineminus">-                            nsIMsgWindow *msgWindow, bool</span>
<a href="#l21.377"></a><span id="l21.377" class="difflineminus">-                            deleteStorage, bool isMove,</span>
<a href="#l21.378"></a><span id="l21.378" class="difflineminus">-                            nsIMsgCopyServiceListener* listener, bool allowUndo) override;</span>
<a href="#l21.379"></a><span id="l21.379" class="difflineminus">-  NS_IMETHOD CopyMessages(nsIMsgFolder *srcFolder,</span>
<a href="#l21.380"></a><span id="l21.380" class="difflineminus">-                          nsIArray* messages,</span>
<a href="#l21.381"></a><span id="l21.381" class="difflineplus">+  NS_IMETHOD DeleteMessages(nsIArray *messages, nsIMsgWindow *msgWindow,</span>
<a href="#l21.382"></a><span id="l21.382" class="difflineplus">+                            bool deleteStorage, bool isMove,</span>
<a href="#l21.383"></a><span id="l21.383" class="difflineplus">+                            nsIMsgCopyServiceListener *listener,</span>
<a href="#l21.384"></a><span id="l21.384" class="difflineplus">+                            bool allowUndo) override;</span>
<a href="#l21.385"></a><span id="l21.385" class="difflineplus">+  NS_IMETHOD CopyMessages(nsIMsgFolder *srcFolder, nsIArray *messages,</span>
<a href="#l21.386"></a><span id="l21.386">                           bool isMove, nsIMsgWindow *msgWindow,</span>
<a href="#l21.387"></a><span id="l21.387" class="difflineminus">-                          nsIMsgCopyServiceListener* listener, bool isFolder,</span>
<a href="#l21.388"></a><span id="l21.388" class="difflineplus">+                          nsIMsgCopyServiceListener *listener, bool isFolder,</span>
<a href="#l21.389"></a><span id="l21.389">                           bool allowUndo) override;</span>
<a href="#l21.390"></a><span id="l21.390" class="difflineminus">-  NS_IMETHOD CopyFolder(nsIMsgFolder *srcFolder, bool isMove, nsIMsgWindow *msgWindow,</span>
<a href="#l21.391"></a><span id="l21.391" class="difflineminus">-                        nsIMsgCopyServiceListener* listener) override;</span>
<a href="#l21.392"></a><span id="l21.392" class="difflineminus">-  NS_IMETHOD CopyFileMessage(nsIFile* file,</span>
<a href="#l21.393"></a><span id="l21.393" class="difflineminus">-                              nsIMsgDBHdr* msgToReplace,</span>
<a href="#l21.394"></a><span id="l21.394" class="difflineminus">-                              bool isDraftOrTemplate,</span>
<a href="#l21.395"></a><span id="l21.395" class="difflineminus">-                              uint32_t aNewMsgFlags,</span>
<a href="#l21.396"></a><span id="l21.396" class="difflineminus">-                              const nsACString &amp;aNewMsgKeywords,</span>
<a href="#l21.397"></a><span id="l21.397" class="difflineminus">-                              nsIMsgWindow *msgWindow,</span>
<a href="#l21.398"></a><span id="l21.398" class="difflineminus">-                              nsIMsgCopyServiceListener* listener) override;</span>
<a href="#l21.399"></a><span id="l21.399" class="difflineminus">-  NS_IMETHOD GetNewMessages(nsIMsgWindow *aWindow, nsIUrlListener *aListener) override;</span>
<a href="#l21.400"></a><span id="l21.400" class="difflineplus">+  NS_IMETHOD CopyFolder(nsIMsgFolder *srcFolder, bool isMove,</span>
<a href="#l21.401"></a><span id="l21.401" class="difflineplus">+                        nsIMsgWindow *msgWindow,</span>
<a href="#l21.402"></a><span id="l21.402" class="difflineplus">+                        nsIMsgCopyServiceListener *listener) override;</span>
<a href="#l21.403"></a><span id="l21.403" class="difflineplus">+  NS_IMETHOD CopyFileMessage(nsIFile *file, nsIMsgDBHdr *msgToReplace,</span>
<a href="#l21.404"></a><span id="l21.404" class="difflineplus">+                             bool isDraftOrTemplate, uint32_t aNewMsgFlags,</span>
<a href="#l21.405"></a><span id="l21.405" class="difflineplus">+                             const nsACString &amp;aNewMsgKeywords,</span>
<a href="#l21.406"></a><span id="l21.406" class="difflineplus">+                             nsIMsgWindow *msgWindow,</span>
<a href="#l21.407"></a><span id="l21.407" class="difflineplus">+                             nsIMsgCopyServiceListener *listener) override;</span>
<a href="#l21.408"></a><span id="l21.408" class="difflineplus">+  NS_IMETHOD GetNewMessages(nsIMsgWindow *aWindow,</span>
<a href="#l21.409"></a><span id="l21.409" class="difflineplus">+                            nsIUrlListener *aListener) override;</span>
<a href="#l21.410"></a><span id="l21.410"> </span>
<a href="#l21.411"></a><span id="l21.411" class="difflineminus">-  NS_IMETHOD GetFilePath(nsIFile** aPathName) override;</span>
<a href="#l21.412"></a><span id="l21.412" class="difflineminus">-  NS_IMETHOD SetFilePath(nsIFile * aPath) override;</span>
<a href="#l21.413"></a><span id="l21.413" class="difflineplus">+  NS_IMETHOD GetFilePath(nsIFile **aPathName) override;</span>
<a href="#l21.414"></a><span id="l21.414" class="difflineplus">+  NS_IMETHOD SetFilePath(nsIFile *aPath) override;</span>
<a href="#l21.415"></a><span id="l21.415"> </span>
<a href="#l21.416"></a><span id="l21.416">   NS_IMETHOD Shutdown(bool shutdownChildren) override;</span>
<a href="#l21.417"></a><span id="l21.417"> </span>
<a href="#l21.418"></a><span id="l21.418" class="difflineminus">-  NS_IMETHOD DownloadMessagesForOffline(nsIArray *messages, nsIMsgWindow *msgWindow) override;</span>
<a href="#l21.419"></a><span id="l21.419" class="difflineplus">+  NS_IMETHOD DownloadMessagesForOffline(nsIArray *messages,</span>
<a href="#l21.420"></a><span id="l21.420" class="difflineplus">+                                        nsIMsgWindow *msgWindow) override;</span>
<a href="#l21.421"></a><span id="l21.421"> </span>
<a href="#l21.422"></a><span id="l21.422" class="difflineminus">-  NS_IMETHOD DownloadAllForOffline(nsIUrlListener *listener, nsIMsgWindow *msgWindow) override;</span>
<a href="#l21.423"></a><span id="l21.423" class="difflineplus">+  NS_IMETHOD DownloadAllForOffline(nsIUrlListener *listener,</span>
<a href="#l21.424"></a><span id="l21.424" class="difflineplus">+                                   nsIMsgWindow *msgWindow) override;</span>
<a href="#l21.425"></a><span id="l21.425">   NS_IMETHOD GetCanFileMessages(bool *aCanFileMessages) override;</span>
<a href="#l21.426"></a><span id="l21.426">   NS_IMETHOD GetCanDeleteMessages(bool *aCanDeleteMessages) override;</span>
<a href="#l21.427"></a><span id="l21.427">   NS_IMETHOD FetchMsgPreviewText(nsMsgKey *aKeysToFetch, uint32_t aNumKeys,</span>
<a href="#l21.428"></a><span id="l21.428">                                  bool aLocalOnly, nsIUrlListener *aUrlListener,</span>
<a href="#l21.429"></a><span id="l21.429">                                  bool *aAsyncResults) override;</span>
<a href="#l21.430"></a><span id="l21.430"> </span>
<a href="#l21.431"></a><span id="l21.431" class="difflineminus">-  NS_IMETHOD AddKeywordsToMessages(nsIArray *aMessages, const nsACString&amp; aKeywords) override;</span>
<a href="#l21.432"></a><span id="l21.432" class="difflineminus">-  NS_IMETHOD RemoveKeywordsFromMessages(nsIArray *aMessages, const nsACString&amp; aKeywords) override;</span>
<a href="#l21.433"></a><span id="l21.433" class="difflineplus">+  NS_IMETHOD AddKeywordsToMessages(nsIArray *aMessages,</span>
<a href="#l21.434"></a><span id="l21.434" class="difflineplus">+                                   const nsACString &amp;aKeywords) override;</span>
<a href="#l21.435"></a><span id="l21.435" class="difflineplus">+  NS_IMETHOD RemoveKeywordsFromMessages(nsIArray *aMessages,</span>
<a href="#l21.436"></a><span id="l21.436" class="difflineplus">+                                        const nsACString &amp;aKeywords) override;</span>
<a href="#l21.437"></a><span id="l21.437"> </span>
<a href="#l21.438"></a><span id="l21.438">   NS_IMETHOD NotifyCompactCompleted() override;</span>
<a href="#l21.439"></a><span id="l21.439"> </span>
<a href="#l21.440"></a><span id="l21.440">   // overrides nsMsgDBFolder::HasMsgOffline()</span>
<a href="#l21.441"></a><span id="l21.441">   NS_IMETHOD HasMsgOffline(nsMsgKey msgKey, bool *_retval) override;</span>
<a href="#l21.442"></a><span id="l21.442">   // overrides nsMsgDBFolder::GetOfflineFileStream()</span>
<a href="#l21.443"></a><span id="l21.443" class="difflineminus">-  NS_IMETHOD GetOfflineFileStream(nsMsgKey msgKey, int64_t *offset, uint32_t *size, nsIInputStream **aFileStream) override;</span>
<a href="#l21.444"></a><span id="l21.444" class="difflineplus">+  NS_IMETHOD GetOfflineFileStream(nsMsgKey msgKey, int64_t *offset,</span>
<a href="#l21.445"></a><span id="l21.445" class="difflineplus">+                                  uint32_t *size,</span>
<a href="#l21.446"></a><span id="l21.446" class="difflineplus">+                                  nsIInputStream **aFileStream) override;</span>
<a href="#l21.447"></a><span id="l21.447"> </span>
<a href="#l21.448"></a><span id="l21.448">   NS_DECL_NSIMSGIMAPMAILFOLDER</span>
<a href="#l21.449"></a><span id="l21.449">   NS_DECL_NSIIMAPMAILFOLDERSINK</span>
<a href="#l21.450"></a><span id="l21.450">   NS_DECL_NSIIMAPMESSAGESINK</span>
<a href="#l21.451"></a><span id="l21.451">   NS_DECL_NSICOPYMESSAGELISTENER</span>
<a href="#l21.452"></a><span id="l21.452"> </span>
<a href="#l21.453"></a><span id="l21.453">   // nsIUrlListener methods</span>
<a href="#l21.454"></a><span id="l21.454" class="difflineminus">-  NS_IMETHOD OnStartRunningUrl(nsIURI * aUrl) override;</span>
<a href="#l21.455"></a><span id="l21.455" class="difflineminus">-  NS_IMETHOD OnStopRunningUrl(nsIURI * aUrl, nsresult aExitCode) override;</span>
<a href="#l21.456"></a><span id="l21.456" class="difflineplus">+  NS_IMETHOD OnStartRunningUrl(nsIURI *aUrl) override;</span>
<a href="#l21.457"></a><span id="l21.457" class="difflineplus">+  NS_IMETHOD OnStopRunningUrl(nsIURI *aUrl, nsresult aExitCode) override;</span>
<a href="#l21.458"></a><span id="l21.458"> </span>
<a href="#l21.459"></a><span id="l21.459">   NS_DECL_NSIMSGFILTERHITNOTIFY</span>
<a href="#l21.460"></a><span id="l21.460">   NS_DECL_NSIJUNKMAILCLASSIFICATIONLISTENER</span>
<a href="#l21.461"></a><span id="l21.461"> </span>
<a href="#l21.462"></a><span id="l21.462" class="difflineminus">-  NS_IMETHOD IsCommandEnabled(const nsACString&amp; command, bool *result) override;</span>
<a href="#l21.463"></a><span id="l21.463" class="difflineplus">+  NS_IMETHOD IsCommandEnabled(const nsACString &amp;command, bool *result) override;</span>
<a href="#l21.464"></a><span id="l21.464">   NS_IMETHOD SetFilterList(nsIMsgFilterList *aMsgFilterList) override;</span>
<a href="#l21.465"></a><span id="l21.465">   NS_IMETHOD GetCustomIdentity(nsIMsgIdentity **aIdentity) override;</span>
<a href="#l21.466"></a><span id="l21.466"> </span>
<a href="#l21.467"></a><span id="l21.467" class="difflineminus">- /**</span>
<a href="#l21.468"></a><span id="l21.468" class="difflineminus">-  * This method is used to locate a folder where a msg could be present, not just</span>
<a href="#l21.469"></a><span id="l21.469" class="difflineminus">-  * the folder where the message first arrives, this method searches for the existence</span>
<a href="#l21.470"></a><span id="l21.470" class="difflineminus">-  * of msg in all the folders/labels that we retrieve from X-GM-LABELS also.</span>
<a href="#l21.471"></a><span id="l21.471" class="difflineminus">-  * overrides nsMsgDBFolder::GetOfflineMsgFolder()</span>
<a href="#l21.472"></a><span id="l21.472" class="difflineminus">-  *  @param msgKey key  of the msg for which we are trying to get the folder;</span>
<a href="#l21.473"></a><span id="l21.473" class="difflineminus">-  *  @param aMsgFolder  required folder;</span>
<a href="#l21.474"></a><span id="l21.474" class="difflineminus">-  */</span>
<a href="#l21.475"></a><span id="l21.475" class="difflineminus">-  NS_IMETHOD GetOfflineMsgFolder(nsMsgKey msgKey, nsIMsgFolder **aMsgFolder) override;</span>
<a href="#l21.476"></a><span id="l21.476" class="difflineplus">+  /**</span>
<a href="#l21.477"></a><span id="l21.477" class="difflineplus">+   * This method is used to locate a folder where a msg could be present, not</span>
<a href="#l21.478"></a><span id="l21.478" class="difflineplus">+   * just the folder where the message first arrives, this method searches for</span>
<a href="#l21.479"></a><span id="l21.479" class="difflineplus">+   * the existence of msg in all the folders/labels that we retrieve from</span>
<a href="#l21.480"></a><span id="l21.480" class="difflineplus">+   * X-GM-LABELS also. overrides nsMsgDBFolder::GetOfflineMsgFolder()</span>
<a href="#l21.481"></a><span id="l21.481" class="difflineplus">+   *  @param msgKey key  of the msg for which we are trying to get the folder;</span>
<a href="#l21.482"></a><span id="l21.482" class="difflineplus">+   *  @param aMsgFolder  required folder;</span>
<a href="#l21.483"></a><span id="l21.483" class="difflineplus">+   */</span>
<a href="#l21.484"></a><span id="l21.484" class="difflineplus">+  NS_IMETHOD GetOfflineMsgFolder(nsMsgKey msgKey,</span>
<a href="#l21.485"></a><span id="l21.485" class="difflineplus">+                                 nsIMsgFolder **aMsgFolder) override;</span>
<a href="#l21.486"></a><span id="l21.486"> </span>
<a href="#l21.487"></a><span id="l21.487" class="difflineminus">-  NS_IMETHOD GetIncomingServerType(nsACString&amp; serverType) override;</span>
<a href="#l21.488"></a><span id="l21.488" class="difflineplus">+  NS_IMETHOD GetIncomingServerType(nsACString &amp;serverType) override;</span>
<a href="#l21.489"></a><span id="l21.489"> </span>
<a href="#l21.490"></a><span id="l21.490" class="difflineminus">-  nsresult AddSubfolderWithPath(nsAString&amp; name, nsIFile *dbPath, nsIMsgFolder **child, bool brandNew = false);</span>
<a href="#l21.491"></a><span id="l21.491" class="difflineplus">+  nsresult AddSubfolderWithPath(nsAString &amp;name, nsIFile *dbPath,</span>
<a href="#l21.492"></a><span id="l21.492" class="difflineplus">+                                nsIMsgFolder **child, bool brandNew = false);</span>
<a href="#l21.493"></a><span id="l21.493">   nsresult MoveIncorporatedMessage(nsIMsgDBHdr *mailHdr,</span>
<a href="#l21.494"></a><span id="l21.494" class="difflineminus">-                                  nsIMsgDatabase *sourceDB,</span>
<a href="#l21.495"></a><span id="l21.495" class="difflineminus">-                                  const nsACString&amp; destFolder,</span>
<a href="#l21.496"></a><span id="l21.496" class="difflineminus">-                                  nsIMsgFilter *filter,</span>
<a href="#l21.497"></a><span id="l21.497" class="difflineminus">-                                  nsIMsgWindow *msgWindow);</span>
<a href="#l21.498"></a><span id="l21.498" class="difflineplus">+                                   nsIMsgDatabase *sourceDB,</span>
<a href="#l21.499"></a><span id="l21.499" class="difflineplus">+                                   const nsACString &amp;destFolder,</span>
<a href="#l21.500"></a><span id="l21.500" class="difflineplus">+                                   nsIMsgFilter *filter,</span>
<a href="#l21.501"></a><span id="l21.501" class="difflineplus">+                                   nsIMsgWindow *msgWindow);</span>
<a href="#l21.502"></a><span id="l21.502"> </span>
<a href="#l21.503"></a><span id="l21.503">   // send notification to copy service listener.</span>
<a href="#l21.504"></a><span id="l21.504">   nsresult OnCopyCompleted(nsISupports *srcSupport, nsresult exitCode);</span>
<a href="#l21.505"></a><span id="l21.505"> </span>
<a href="#l21.506"></a><span id="l21.506" class="difflineminus">-  static nsresult  AllocateUidStringFromKeys(nsMsgKey *keys, uint32_t numKeys, nsCString &amp;msgIds);</span>
<a href="#l21.507"></a><span id="l21.507" class="difflineminus">-  static nsresult  BuildIdsAndKeyArray(nsIArray* messages, nsCString&amp; msgIds, nsTArray&lt;nsMsgKey&gt;&amp; keyArray);</span>
<a href="#l21.508"></a><span id="l21.508" class="difflineplus">+  static nsresult AllocateUidStringFromKeys(nsMsgKey *keys, uint32_t numKeys,</span>
<a href="#l21.509"></a><span id="l21.509" class="difflineplus">+                                            nsCString &amp;msgIds);</span>
<a href="#l21.510"></a><span id="l21.510" class="difflineplus">+  static nsresult BuildIdsAndKeyArray(nsIArray *messages, nsCString &amp;msgIds,</span>
<a href="#l21.511"></a><span id="l21.511" class="difflineplus">+                                      nsTArray&lt;nsMsgKey&gt; &amp;keyArray);</span>
<a href="#l21.512"></a><span id="l21.512"> </span>
<a href="#l21.513"></a><span id="l21.513">   // these might end up as an nsIImapMailFolder attribute.</span>
<a href="#l21.514"></a><span id="l21.514">   nsresult SetSupportedUserFlags(uint32_t userFlags);</span>
<a href="#l21.515"></a><span id="l21.515">   nsresult GetSupportedUserFlags(uint32_t *userFlags);</span>
<a href="#l21.516"></a><span id="l21.516"> </span>
<a href="#l21.517"></a><span id="l21.517">   // Find the start of a range of msgKeys that can hold srcCount headers.</span>
<a href="#l21.518"></a><span id="l21.518">   nsresult FindOpenRange(nsMsgKey &amp;fakeBase, uint32_t srcCount);</span>
<a href="#l21.519"></a><span id="l21.519"> </span>
<a href="#l21.520"></a><span id="l21.520" class="difflineminus">-protected:</span>
<a href="#l21.521"></a><span id="l21.521" class="difflineplus">+ protected:</span>
<a href="#l21.522"></a><span id="l21.522">   virtual ~nsImapMailFolder();</span>
<a href="#l21.523"></a><span id="l21.523">   // Helper methods</span>
<a href="#l21.524"></a><span id="l21.524"> </span>
<a href="#l21.525"></a><span id="l21.525" class="difflineminus">-  virtual nsresult CreateChildFromURI(const nsCString &amp;uri, nsIMsgFolder **folder) override;</span>
<a href="#l21.526"></a><span id="l21.526" class="difflineminus">-  void FindKeysToAdd(const nsTArray&lt;nsMsgKey&gt; &amp;existingKeys, nsTArray&lt;nsMsgKey&gt;</span>
<a href="#l21.527"></a><span id="l21.527" class="difflineminus">-    &amp;keysToFetch, uint32_t &amp;numNewUnread, nsIImapFlagAndUidState *flagState);</span>
<a href="#l21.528"></a><span id="l21.528" class="difflineminus">-  void FindKeysToDelete(const nsTArray&lt;nsMsgKey&gt; &amp;existingKeys, nsTArray&lt;nsMsgKey&gt;</span>
<a href="#l21.529"></a><span id="l21.529" class="difflineminus">-    &amp;keysToFetch, nsIImapFlagAndUidState *flagState, uint32_t boxFlags);</span>
<a href="#l21.530"></a><span id="l21.530" class="difflineminus">-  void PrepareToAddHeadersToMailDB(nsIImapProtocol* aProtocol);</span>
<a href="#l21.531"></a><span id="l21.531" class="difflineminus">-  void TweakHeaderFlags(nsIImapProtocol* aProtocol, nsIMsgDBHdr *tweakMe);</span>
<a href="#l21.532"></a><span id="l21.532" class="difflineplus">+  virtual nsresult CreateChildFromURI(const nsCString &amp;uri,</span>
<a href="#l21.533"></a><span id="l21.533" class="difflineplus">+                                      nsIMsgFolder **folder) override;</span>
<a href="#l21.534"></a><span id="l21.534" class="difflineplus">+  void FindKeysToAdd(const nsTArray&lt;nsMsgKey&gt; &amp;existingKeys,</span>
<a href="#l21.535"></a><span id="l21.535" class="difflineplus">+                     nsTArray&lt;nsMsgKey&gt; &amp;keysToFetch, uint32_t &amp;numNewUnread,</span>
<a href="#l21.536"></a><span id="l21.536" class="difflineplus">+                     nsIImapFlagAndUidState *flagState);</span>
<a href="#l21.537"></a><span id="l21.537" class="difflineplus">+  void FindKeysToDelete(const nsTArray&lt;nsMsgKey&gt; &amp;existingKeys,</span>
<a href="#l21.538"></a><span id="l21.538" class="difflineplus">+                        nsTArray&lt;nsMsgKey&gt; &amp;keysToFetch,</span>
<a href="#l21.539"></a><span id="l21.539" class="difflineplus">+                        nsIImapFlagAndUidState *flagState, uint32_t boxFlags);</span>
<a href="#l21.540"></a><span id="l21.540" class="difflineplus">+  void PrepareToAddHeadersToMailDB(nsIImapProtocol *aProtocol);</span>
<a href="#l21.541"></a><span id="l21.541" class="difflineplus">+  void TweakHeaderFlags(nsIImapProtocol *aProtocol, nsIMsgDBHdr *tweakMe);</span>
<a href="#l21.542"></a><span id="l21.542"> </span>
<a href="#l21.543"></a><span id="l21.543">   nsresult SyncFlags(nsIImapFlagAndUidState *flagState);</span>
<a href="#l21.544"></a><span id="l21.544">   nsresult HandleCustomFlags(nsMsgKey uidOfMessage, nsIMsgDBHdr *dbHdr,</span>
<a href="#l21.545"></a><span id="l21.545" class="difflineminus">-                             uint16_t userFlags, nsCString&amp; keywords,</span>
<a href="#l21.546"></a><span id="l21.546" class="difflineplus">+                             uint16_t userFlags, nsCString &amp;keywords,</span>
<a href="#l21.547"></a><span id="l21.547">                              nsIImapFlagAndUidState *flagState);</span>
<a href="#l21.548"></a><span id="l21.548">   nsresult NotifyMessageFlagsFromHdr(nsIMsgDBHdr *dbHdr, nsMsgKey msgKey,</span>
<a href="#l21.549"></a><span id="l21.549">                                      uint32_t flags);</span>
<a href="#l21.550"></a><span id="l21.550"> </span>
<a href="#l21.551"></a><span id="l21.551" class="difflineminus">-  nsresult SetupHeaderParseStream(uint32_t size, const nsACString&amp; content_type, nsIMailboxSpec *boxSpec);</span>
<a href="#l21.552"></a><span id="l21.552" class="difflineminus">-  nsresult  ParseAdoptedHeaderLine(const char *messageLine, nsMsgKey msgKey);</span>
<a href="#l21.553"></a><span id="l21.553" class="difflineminus">-  nsresult  NormalEndHeaderParseStream(nsIImapProtocol *aProtocol, nsIImapUrl *imapUrl);</span>
<a href="#l21.554"></a><span id="l21.554" class="difflineplus">+  nsresult SetupHeaderParseStream(uint32_t size, const nsACString &amp;content_type,</span>
<a href="#l21.555"></a><span id="l21.555" class="difflineplus">+                                  nsIMailboxSpec *boxSpec);</span>
<a href="#l21.556"></a><span id="l21.556" class="difflineplus">+  nsresult ParseAdoptedHeaderLine(const char *messageLine, nsMsgKey msgKey);</span>
<a href="#l21.557"></a><span id="l21.557" class="difflineplus">+  nsresult NormalEndHeaderParseStream(nsIImapProtocol *aProtocol,</span>
<a href="#l21.558"></a><span id="l21.558" class="difflineplus">+                                      nsIImapUrl *imapUrl);</span>
<a href="#l21.559"></a><span id="l21.559"> </span>
<a href="#l21.560"></a><span id="l21.560">   void EndOfflineDownload();</span>
<a href="#l21.561"></a><span id="l21.561"> </span>
<a href="#l21.562"></a><span id="l21.562">   /**</span>
<a href="#l21.563"></a><span id="l21.563">    * At the end of a file-to-folder copy operation, copy the file to the</span>
<a href="#l21.564"></a><span id="l21.564">    * offline store and/or add to the message database, (if needed).</span>
<a href="#l21.565"></a><span id="l21.565">    *</span>
<a href="#l21.566"></a><span id="l21.566">    * @param srcFile       file containing the message key</span>
<a href="#l21.567"></a><span id="l21.567">    * @param msgKey        key to use for the new messages</span>
<a href="#l21.568"></a><span id="l21.568">    */</span>
<a href="#l21.569"></a><span id="l21.569">   nsresult CopyFileToOfflineStore(nsIFile *srcFile, nsMsgKey msgKey);</span>
<a href="#l21.570"></a><span id="l21.570"> </span>
<a href="#l21.571"></a><span id="l21.571" class="difflineminus">-  nsresult MarkMessagesImapDeleted(nsTArray&lt;nsMsgKey&gt; *keyArray, bool deleted, nsIMsgDatabase *db);</span>
<a href="#l21.572"></a><span id="l21.572" class="difflineplus">+  nsresult MarkMessagesImapDeleted(nsTArray&lt;nsMsgKey&gt; *keyArray, bool deleted,</span>
<a href="#l21.573"></a><span id="l21.573" class="difflineplus">+                                   nsIMsgDatabase *db);</span>
<a href="#l21.574"></a><span id="l21.574"> </span>
<a href="#l21.575"></a><span id="l21.575">   // Notifies imap autosync that it should update this folder when it</span>
<a href="#l21.576"></a><span id="l21.576">   // gets a chance.</span>
<a href="#l21.577"></a><span id="l21.577">   void NotifyHasPendingMsgs();</span>
<a href="#l21.578"></a><span id="l21.578">   void UpdatePendingCounts();</span>
<a href="#l21.579"></a><span id="l21.579" class="difflineminus">-  void SetIMAPDeletedFlag(nsIMsgDatabase *mailDB, const nsTArray&lt;nsMsgKey&gt; &amp;msgids, bool markDeleted);</span>
<a href="#l21.580"></a><span id="l21.580" class="difflineplus">+  void SetIMAPDeletedFlag(nsIMsgDatabase *mailDB,</span>
<a href="#l21.581"></a><span id="l21.581" class="difflineplus">+                          const nsTArray&lt;nsMsgKey&gt; &amp;msgids, bool markDeleted);</span>
<a href="#l21.582"></a><span id="l21.582">   virtual bool ShowDeletedMessages();</span>
<a href="#l21.583"></a><span id="l21.583">   virtual bool DeleteIsMoveToTrash();</span>
<a href="#l21.584"></a><span id="l21.584" class="difflineminus">-  nsresult GetFolder(const nsACString&amp; name, nsIMsgFolder **pFolder);</span>
<a href="#l21.585"></a><span id="l21.585" class="difflineplus">+  nsresult GetFolder(const nsACString &amp;name, nsIMsgFolder **pFolder);</span>
<a href="#l21.586"></a><span id="l21.586">   nsresult GetTrashFolder(nsIMsgFolder **pTrashFolder);</span>
<a href="#l21.587"></a><span id="l21.587" class="difflineminus">-  bool TrashOrDescendentOfTrash(nsIMsgFolder* folder);</span>
<a href="#l21.588"></a><span id="l21.588" class="difflineplus">+  bool TrashOrDescendentOfTrash(nsIMsgFolder *folder);</span>
<a href="#l21.589"></a><span id="l21.589">   static bool ShouldCheckAllFolders(nsIImapIncomingServer *imapServer);</span>
<a href="#l21.590"></a><span id="l21.590" class="difflineminus">-  nsresult GetServerKey(nsACString&amp; serverKey);</span>
<a href="#l21.591"></a><span id="l21.591" class="difflineminus">-  nsresult DisplayStatusMsg(nsIImapUrl *aImapUrl, const nsAString&amp; msg);</span>
<a href="#l21.592"></a><span id="l21.592" class="difflineplus">+  nsresult GetServerKey(nsACString &amp;serverKey);</span>
<a href="#l21.593"></a><span id="l21.593" class="difflineplus">+  nsresult DisplayStatusMsg(nsIImapUrl *aImapUrl, const nsAString &amp;msg);</span>
<a href="#l21.594"></a><span id="l21.594"> </span>
<a href="#l21.595"></a><span id="l21.595" class="difflineminus">-  //nsresult RenameLocal(const char *newName);</span>
<a href="#l21.596"></a><span id="l21.596" class="difflineplus">+  // nsresult RenameLocal(const char *newName);</span>
<a href="#l21.597"></a><span id="l21.597">   nsresult AddDirectorySeparator(nsIFile *path);</span>
<a href="#l21.598"></a><span id="l21.598">   nsresult CreateSubFolders(nsIFile *path);</span>
<a href="#l21.599"></a><span id="l21.599">   nsresult GetDatabase() override;</span>
<a href="#l21.600"></a><span id="l21.600"> </span>
<a href="#l21.601"></a><span id="l21.601" class="difflineminus">-  nsresult        GetFolderOwnerUserName(nsACString&amp; userName);</span>
<a href="#l21.602"></a><span id="l21.602" class="difflineplus">+  nsresult GetFolderOwnerUserName(nsACString &amp;userName);</span>
<a href="#l21.603"></a><span id="l21.603">   nsIMAPNamespace *GetNamespaceForFolder();</span>
<a href="#l21.604"></a><span id="l21.604" class="difflineminus">-  void            SetNamespaceForFolder(nsIMAPNamespace *ns);</span>
<a href="#l21.605"></a><span id="l21.605" class="difflineplus">+  void SetNamespaceForFolder(nsIMAPNamespace *ns);</span>
<a href="#l21.606"></a><span id="l21.606"> </span>
<a href="#l21.607"></a><span id="l21.607" class="difflineminus">-  nsMsgIMAPFolderACL * GetFolderACL();</span>
<a href="#l21.608"></a><span id="l21.608" class="difflineminus">-  nsresult CreateACLRightsStringForFolder(nsAString&amp; rightsString);</span>
<a href="#l21.609"></a><span id="l21.609" class="difflineplus">+  nsMsgIMAPFolderACL *GetFolderACL();</span>
<a href="#l21.610"></a><span id="l21.610" class="difflineplus">+  nsresult CreateACLRightsStringForFolder(nsAString &amp;rightsString);</span>
<a href="#l21.611"></a><span id="l21.611">   nsresult GetBodysToDownload(nsTArray&lt;nsMsgKey&gt; *keysOfMessagesToDownload);</span>
<a href="#l21.612"></a><span id="l21.612">   // Uber message copy service</span>
<a href="#l21.613"></a><span id="l21.613" class="difflineminus">-  nsresult CopyMessagesWithStream(nsIMsgFolder* srcFolder,</span>
<a href="#l21.614"></a><span id="l21.614" class="difflineminus">-                                    nsIArray* messages,</span>
<a href="#l21.615"></a><span id="l21.615" class="difflineminus">-                                    bool isMove,</span>
<a href="#l21.616"></a><span id="l21.616" class="difflineminus">-                                    bool isCrossServerOp,</span>
<a href="#l21.617"></a><span id="l21.617" class="difflineminus">-                                    nsIMsgWindow *msgWindow,</span>
<a href="#l21.618"></a><span id="l21.618" class="difflineminus">-                                    nsIMsgCopyServiceListener* listener, bool allowUndo);</span>
<a href="#l21.619"></a><span id="l21.619" class="difflineminus">-  nsresult CopyStreamMessage(nsIMsgDBHdr* message, nsIMsgFolder* dstFolder,</span>
<a href="#l21.620"></a><span id="l21.620" class="difflineminus">-                            nsIMsgWindow *msgWindow, bool isMove);</span>
<a href="#l21.621"></a><span id="l21.621" class="difflineminus">-  nsresult InitCopyState(nsISupports* srcSupport,</span>
<a href="#l21.622"></a><span id="l21.622" class="difflineminus">-                          nsIArray* messages,</span>
<a href="#l21.623"></a><span id="l21.623" class="difflineminus">-                          bool isMove,</span>
<a href="#l21.624"></a><span id="l21.624" class="difflineminus">-                          bool selectedState,</span>
<a href="#l21.625"></a><span id="l21.625" class="difflineminus">-                          bool acrossServers,</span>
<a href="#l21.626"></a><span id="l21.626" class="difflineminus">-                          uint32_t newMsgFlags,</span>
<a href="#l21.627"></a><span id="l21.627" class="difflineminus">-                          const nsACString &amp;newMsgKeywords,</span>
<a href="#l21.628"></a><span id="l21.628" class="difflineminus">-                          nsIMsgCopyServiceListener* listener,</span>
<a href="#l21.629"></a><span id="l21.629" class="difflineminus">-                          nsIMsgWindow *msgWindow,</span>
<a href="#l21.630"></a><span id="l21.630" class="difflineminus">-                          bool allowUndo);</span>
<a href="#l21.631"></a><span id="l21.631" class="difflineplus">+  nsresult CopyMessagesWithStream(nsIMsgFolder *srcFolder, nsIArray *messages,</span>
<a href="#l21.632"></a><span id="l21.632" class="difflineplus">+                                  bool isMove, bool isCrossServerOp,</span>
<a href="#l21.633"></a><span id="l21.633" class="difflineplus">+                                  nsIMsgWindow *msgWindow,</span>
<a href="#l21.634"></a><span id="l21.634" class="difflineplus">+                                  nsIMsgCopyServiceListener *listener,</span>
<a href="#l21.635"></a><span id="l21.635" class="difflineplus">+                                  bool allowUndo);</span>
<a href="#l21.636"></a><span id="l21.636" class="difflineplus">+  nsresult CopyStreamMessage(nsIMsgDBHdr *message, nsIMsgFolder *dstFolder,</span>
<a href="#l21.637"></a><span id="l21.637" class="difflineplus">+                             nsIMsgWindow *msgWindow, bool isMove);</span>
<a href="#l21.638"></a><span id="l21.638" class="difflineplus">+  nsresult InitCopyState(nsISupports *srcSupport, nsIArray *messages,</span>
<a href="#l21.639"></a><span id="l21.639" class="difflineplus">+                         bool isMove, bool selectedState, bool acrossServers,</span>
<a href="#l21.640"></a><span id="l21.640" class="difflineplus">+                         uint32_t newMsgFlags, const nsACString &amp;newMsgKeywords,</span>
<a href="#l21.641"></a><span id="l21.641" class="difflineplus">+                         nsIMsgCopyServiceListener *listener,</span>
<a href="#l21.642"></a><span id="l21.642" class="difflineplus">+                         nsIMsgWindow *msgWindow, bool allowUndo);</span>
<a href="#l21.643"></a><span id="l21.643">   nsresult GetMoveCoalescer();</span>
<a href="#l21.644"></a><span id="l21.644">   nsresult PlaybackCoalescedOperations();</span>
<a href="#l21.645"></a><span id="l21.645" class="difflineminus">-  virtual nsresult CreateBaseMessageURI(const nsACString&amp; aURI) override;</span>
<a href="#l21.646"></a><span id="l21.646" class="difflineplus">+  virtual nsresult CreateBaseMessageURI(const nsACString &amp;aURI) override;</span>
<a href="#l21.647"></a><span id="l21.647">   // offline-ish methods</span>
<a href="#l21.648"></a><span id="l21.648" class="difflineminus">-  nsresult GetClearedOriginalOp(nsIMsgOfflineImapOperation *op, nsIMsgOfflineImapOperation **originalOp, nsIMsgDatabase **originalDB);</span>
<a href="#l21.649"></a><span id="l21.649" class="difflineminus">-  nsresult GetOriginalOp(nsIMsgOfflineImapOperation *op, nsIMsgOfflineImapOperation **originalOp, nsIMsgDatabase **originalDB);</span>
<a href="#l21.650"></a><span id="l21.650" class="difflineminus">-  nsresult CopyMessagesOffline(nsIMsgFolder* srcFolder,</span>
<a href="#l21.651"></a><span id="l21.651" class="difflineminus">-                                nsIArray* messages,</span>
<a href="#l21.652"></a><span id="l21.652" class="difflineminus">-                                bool isMove,</span>
<a href="#l21.653"></a><span id="l21.653" class="difflineminus">-                                nsIMsgWindow *msgWindow,</span>
<a href="#l21.654"></a><span id="l21.654" class="difflineminus">-                                nsIMsgCopyServiceListener* listener);</span>
<a href="#l21.655"></a><span id="l21.655" class="difflineminus">-  void SetPendingAttributes(nsIArray* messages, bool aIsMove, bool aSetOffline);</span>
<a href="#l21.656"></a><span id="l21.656" class="difflineplus">+  nsresult GetClearedOriginalOp(nsIMsgOfflineImapOperation *op,</span>
<a href="#l21.657"></a><span id="l21.657" class="difflineplus">+                                nsIMsgOfflineImapOperation **originalOp,</span>
<a href="#l21.658"></a><span id="l21.658" class="difflineplus">+                                nsIMsgDatabase **originalDB);</span>
<a href="#l21.659"></a><span id="l21.659" class="difflineplus">+  nsresult GetOriginalOp(nsIMsgOfflineImapOperation *op,</span>
<a href="#l21.660"></a><span id="l21.660" class="difflineplus">+                         nsIMsgOfflineImapOperation **originalOp,</span>
<a href="#l21.661"></a><span id="l21.661" class="difflineplus">+                         nsIMsgDatabase **originalDB);</span>
<a href="#l21.662"></a><span id="l21.662" class="difflineplus">+  nsresult CopyMessagesOffline(nsIMsgFolder *srcFolder, nsIArray *messages,</span>
<a href="#l21.663"></a><span id="l21.663" class="difflineplus">+                               bool isMove, nsIMsgWindow *msgWindow,</span>
<a href="#l21.664"></a><span id="l21.664" class="difflineplus">+                               nsIMsgCopyServiceListener *listener);</span>
<a href="#l21.665"></a><span id="l21.665" class="difflineplus">+  void SetPendingAttributes(nsIArray *messages, bool aIsMove, bool aSetOffline);</span>
<a href="#l21.666"></a><span id="l21.666"> </span>
<a href="#l21.667"></a><span id="l21.667">   nsresult CopyOfflineMsgBody(nsIMsgFolder *srcFolder, nsIMsgDBHdr *destHdr,</span>
<a href="#l21.668"></a><span id="l21.668">                               nsIMsgDBHdr *origHdr, nsIInputStream *inputStream,</span>
<a href="#l21.669"></a><span id="l21.669">                               nsIOutputStream *outputStream);</span>
<a href="#l21.670"></a><span id="l21.670"> </span>
<a href="#l21.671"></a><span id="l21.671">   void GetTrashFolderName(nsAString &amp;aFolderName);</span>
<a href="#l21.672"></a><span id="l21.672">   bool ShowPreviewText();</span>
<a href="#l21.673"></a><span id="l21.673"> </span>
<a href="#l21.674"></a><span id="l21.674" class="difflineat">@@ -449,19 +484,21 @@ protected:</span>
<a href="#l21.675"></a><span id="l21.675">   // Allocate and initialize associated auto-sync state object.</span>
<a href="#l21.676"></a><span id="l21.676">   void InitAutoSyncState();</span>
<a href="#l21.677"></a><span id="l21.677"> </span>
<a href="#l21.678"></a><span id="l21.678">   bool m_initialized;</span>
<a href="#l21.679"></a><span id="l21.679">   bool m_haveDiscoveredAllFolders;</span>
<a href="#l21.680"></a><span id="l21.680">   nsCOMPtr&lt;nsIMsgParseMailMsgState&gt; m_msgParser;</span>
<a href="#l21.681"></a><span id="l21.681">   nsCOMPtr&lt;nsIMsgFilterList&gt; m_filterList;</span>
<a href="#l21.682"></a><span id="l21.682">   nsCOMPtr&lt;nsIMsgFilterPlugin&gt; m_filterPlugin;  // XXX should be a list</span>
<a href="#l21.683"></a><span id="l21.683" class="difflineminus">-  // used with filter plugins to know when we've finished classifying and can playback moves</span>
<a href="#l21.684"></a><span id="l21.684" class="difflineplus">+  // used with filter plugins to know when we've finished classifying and can</span>
<a href="#l21.685"></a><span id="l21.685" class="difflineplus">+  // playback moves</span>
<a href="#l21.686"></a><span id="l21.686">   bool m_msgMovedByFilter;</span>
<a href="#l21.687"></a><span id="l21.687" class="difflineminus">-  RefPtr&lt;nsImapMoveCoalescer&gt; m_moveCoalescer; // strictly owned by the nsImapMailFolder</span>
<a href="#l21.688"></a><span id="l21.688" class="difflineplus">+  RefPtr&lt;nsImapMoveCoalescer&gt;</span>
<a href="#l21.689"></a><span id="l21.689" class="difflineplus">+      m_moveCoalescer;  // strictly owned by the nsImapMailFolder</span>
<a href="#l21.690"></a><span id="l21.690">   nsCOMPtr&lt;nsIMutableArray&gt; m_junkMessagesToMarkAsRead;</span>
<a href="#l21.691"></a><span id="l21.691">   /// list of keys to be moved to the junk folder</span>
<a href="#l21.692"></a><span id="l21.692">   nsTArray&lt;nsMsgKey&gt; mSpamKeysToMove;</span>
<a href="#l21.693"></a><span id="l21.693">   /// the junk destination folder</span>
<a href="#l21.694"></a><span id="l21.694">   nsCOMPtr&lt;nsIMsgFolder&gt; mSpamFolder;</span>
<a href="#l21.695"></a><span id="l21.695">   nsMsgKey m_curMsgUid;</span>
<a href="#l21.696"></a><span id="l21.696">   uint32_t m_uidValidity;</span>
<a href="#l21.697"></a><span id="l21.697"> </span>
<a href="#l21.698"></a><span id="l21.698" class="difflineat">@@ -469,49 +506,51 @@ protected:</span>
<a href="#l21.699"></a><span id="l21.699">   // They include deleted messages, so they can differ from the generic</span>
<a href="#l21.700"></a><span id="l21.700">   // folder total and unread counts.</span>
<a href="#l21.701"></a><span id="l21.701">   int32_t m_numServerRecentMessages;</span>
<a href="#l21.702"></a><span id="l21.702">   int32_t m_numServerUnseenMessages;</span>
<a href="#l21.703"></a><span id="l21.703">   int32_t m_numServerTotalMessages;</span>
<a href="#l21.704"></a><span id="l21.704">   // if server supports UIDNEXT, we store it here.</span>
<a href="#l21.705"></a><span id="l21.705">   int32_t m_nextUID;</span>
<a href="#l21.706"></a><span id="l21.706"> </span>
<a href="#l21.707"></a><span id="l21.707" class="difflineminus">-  int32_t  m_nextMessageByteLength;</span>
<a href="#l21.708"></a><span id="l21.708" class="difflineplus">+  int32_t m_nextMessageByteLength;</span>
<a href="#l21.709"></a><span id="l21.709">   nsCOMPtr&lt;nsIUrlListener&gt; m_urlListener;</span>
<a href="#l21.710"></a><span id="l21.710">   bool m_urlRunning;</span>
<a href="#l21.711"></a><span id="l21.711"> </span>
<a href="#l21.712"></a><span id="l21.712">   // undo move/copy transaction support</span>
<a href="#l21.713"></a><span id="l21.713">   RefPtr&lt;nsMsgTxn&gt; m_pendingUndoTxn;</span>
<a href="#l21.714"></a><span id="l21.714">   RefPtr&lt;nsImapMailCopyState&gt; m_copyState;</span>
<a href="#l21.715"></a><span id="l21.715">   char m_hierarchyDelimiter;</span>
<a href="#l21.716"></a><span id="l21.716">   int32_t m_boxFlags;</span>
<a href="#l21.717"></a><span id="l21.717">   nsCString m_onlineFolderName;</span>
<a href="#l21.718"></a><span id="l21.718">   nsCString m_ownerUserName;  // username of the &quot;other user,&quot; as in</span>
<a href="#l21.719"></a><span id="l21.719">   // &quot;Other Users' Mailboxes&quot;</span>
<a href="#l21.720"></a><span id="l21.720"> </span>
<a href="#l21.721"></a><span id="l21.721" class="difflineminus">-  nsCString m_adminUrl;   // url to run to set admin privileges for this folder</span>
<a href="#l21.722"></a><span id="l21.722" class="difflineminus">-  nsIMAPNamespace  *m_namespace;</span>
<a href="#l21.723"></a><span id="l21.723" class="difflineplus">+  nsCString m_adminUrl;  // url to run to set admin privileges for this folder</span>
<a href="#l21.724"></a><span id="l21.724" class="difflineplus">+  nsIMAPNamespace *m_namespace;</span>
<a href="#l21.725"></a><span id="l21.725">   bool m_verifiedAsOnlineFolder;</span>
<a href="#l21.726"></a><span id="l21.726" class="difflineminus">-  bool m_explicitlyVerify; // whether or not we need to explicitly verify this through LIST</span>
<a href="#l21.727"></a><span id="l21.727" class="difflineplus">+  bool m_explicitlyVerify;  // whether or not we need to explicitly verify this</span>
<a href="#l21.728"></a><span id="l21.728" class="difflineplus">+                            // through LIST</span>
<a href="#l21.729"></a><span id="l21.729">   bool m_folderIsNamespace;</span>
<a href="#l21.730"></a><span id="l21.730">   bool m_folderNeedsSubscribing;</span>
<a href="#l21.731"></a><span id="l21.731">   bool m_folderNeedsAdded;</span>
<a href="#l21.732"></a><span id="l21.732">   bool m_folderNeedsACLListed;</span>
<a href="#l21.733"></a><span id="l21.733">   bool m_performingBiff;</span>
<a href="#l21.734"></a><span id="l21.734">   bool m_folderQuotaCommandIssued;</span>
<a href="#l21.735"></a><span id="l21.735">   bool m_folderQuotaDataIsValid;</span>
<a href="#l21.736"></a><span id="l21.736">   bool m_updatingFolder;</span>
<a href="#l21.737"></a><span id="l21.737">   // These two vars are used to keep track of compaction state so we can know</span>
<a href="#l21.738"></a><span id="l21.738">   // when to send a done notification.</span>
<a href="#l21.739"></a><span id="l21.739">   bool m_compactingOfflineStore;</span>
<a href="#l21.740"></a><span id="l21.740">   bool m_expunging;</span>
<a href="#l21.741"></a><span id="l21.741" class="difflineminus">-  bool m_applyIncomingFilters; // apply filters to this folder, even if not the inbox</span>
<a href="#l21.742"></a><span id="l21.742" class="difflineplus">+  bool m_applyIncomingFilters;  // apply filters to this folder, even if not the</span>
<a href="#l21.743"></a><span id="l21.743" class="difflineplus">+                                // inbox</span>
<a href="#l21.744"></a><span id="l21.744">   nsMsgIMAPFolderACL *m_folderACL;</span>
<a href="#l21.745"></a><span id="l21.745" class="difflineminus">-  uint32_t     m_aclFlags;</span>
<a href="#l21.746"></a><span id="l21.746" class="difflineminus">-  uint32_t     m_supportedUserFlags;</span>
<a href="#l21.747"></a><span id="l21.747" class="difflineplus">+  uint32_t m_aclFlags;</span>
<a href="#l21.748"></a><span id="l21.748" class="difflineplus">+  uint32_t m_supportedUserFlags;</span>
<a href="#l21.749"></a><span id="l21.749"> </span>
<a href="#l21.750"></a><span id="l21.750">   // determines if we are on GMail server</span>
<a href="#l21.751"></a><span id="l21.751">   bool m_isGmailServer;</span>
<a href="#l21.752"></a><span id="l21.752">   // offline imap support</span>
<a href="#l21.753"></a><span id="l21.753">   bool m_downloadingFolderForOfflineUse;</span>
<a href="#l21.754"></a><span id="l21.754">   bool m_filterListRequiresBody;</span>
<a href="#l21.755"></a><span id="l21.755"> </span>
<a href="#l21.756"></a><span id="l21.756">   // auto-sync (automatic message download) support</span>
<a href="#l21.757"></a><span id="l21.757" class="difflineat">@@ -535,13 +574,14 @@ protected:</span>
<a href="#l21.758"></a><span id="l21.758"> </span>
<a href="#l21.759"></a><span id="l21.759">   /**</span>
<a href="#l21.760"></a><span id="l21.760">    * delete if appropriate local storage for messages in this folder</span>
<a href="#l21.761"></a><span id="l21.761">    *</span>
<a href="#l21.762"></a><span id="l21.762">    * @parm aMessages array (of nsIMsgDBHdr) of messages to delete</span>
<a href="#l21.763"></a><span id="l21.763">    *       (or an array of message keys)</span>
<a href="#l21.764"></a><span id="l21.764">    * @parm aSrcFolder the folder containing the messages (optional)</span>
<a href="#l21.765"></a><span id="l21.765">    */</span>
<a href="#l21.766"></a><span id="l21.766" class="difflineminus">-  void DeleteStoreMessages(nsIArray* aMessages);</span>
<a href="#l21.767"></a><span id="l21.767" class="difflineplus">+  void DeleteStoreMessages(nsIArray *aMessages);</span>
<a href="#l21.768"></a><span id="l21.768">   void DeleteStoreMessages(nsTArray&lt;nsMsgKey&gt; &amp;aMessages);</span>
<a href="#l21.769"></a><span id="l21.769" class="difflineminus">-  static void DeleteStoreMessages(nsTArray&lt;nsMsgKey&gt; &amp;aMessages, nsIMsgFolder* aFolder);</span>
<a href="#l21.770"></a><span id="l21.770" class="difflineplus">+  static void DeleteStoreMessages(nsTArray&lt;nsMsgKey&gt; &amp;aMessages,</span>
<a href="#l21.771"></a><span id="l21.771" class="difflineplus">+                                  nsIMsgFolder *aFolder);</span>
<a href="#l21.772"></a><span id="l21.772"> };</span>
<a href="#l21.773"></a><span id="l21.773"> #endif</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/4b0de666d1a4">4b0de666d1a4</a> at 2020-07-30T19:32:33Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

