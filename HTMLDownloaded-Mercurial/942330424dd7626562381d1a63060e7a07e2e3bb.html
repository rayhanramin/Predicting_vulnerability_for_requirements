<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 996:942330424dd7626562381d1a63060e7a07e2e3bb</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 942330424dd7626562381d1a63060e7a07e2e3bb" />
<meta property="og:url" content="/comm-central/rev/942330424dd7626562381d1a63060e7a07e2e3bb" />
<meta property="og:description" content="Changes for our JS message representation made in parallel with my changes for" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 942330424dd7626562381d1a63060e7a07e2e3bb 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/942330424dd7626562381d1a63060e7a07e2e3bb">shortlog</a> |
<a href="/comm-central/log/942330424dd7626562381d1a63060e7a07e2e3bb">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/942330424dd7626562381d1a63060e7a07e2e3bb">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/942330424dd7626562381d1a63060e7a07e2e3bb">files</a> |
changeset |
<a href="/comm-central/raw-rev/942330424dd7626562381d1a63060e7a07e2e3bb">raw</a>  | <a href="/comm-central/archive/942330424dd7626562381d1a63060e7a07e2e3bb.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
Changes for our JS message representation made in parallel with my changes for
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Mon, 27 Oct 2008 01:29:40 -0700</td></tr>

<tr>
 <td>changeset 996</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/942330424dd7626562381d1a63060e7a07e2e3bb">942330424dd7626562381d1a63060e7a07e2e3bb</a></td>
</tr>



<tr>
<td>parent 995</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/4f73d25ae3c1b3bf1f27cfdec534580139263e57">4f73d25ae3c1b3bf1f27cfdec534580139263e57</a>
</td>
</tr>

<tr>
<td>child 997</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/1a1437838c7c932dd9c1dde84e0c49d458d8dabf">1a1437838c7c932dd9c1dde84e0c49d458d8dabf</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=942330424dd7626562381d1a63060e7a07e2e3bb">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>

<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=447842">447842</a></td></tr>




</table></div>

<div class="page_body description">Changes for our JS message representation made in parallel with my changes for
the patch on <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=447842">bug 447842</a>.  This allows us to just index the text body parts.
We should probably have a fallback to transforming the HTML to text if we have
no text parts, but baby steps...</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/942330424dd7626562381d1a63060e7a07e2e3bb/components/jsmimeemitter.js">components/jsmimeemitter.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/942330424dd7626562381d1a63060e7a07e2e3bb/components/jsmimeemitter.js">file</a> |
<a href="/comm-central/annotate/942330424dd7626562381d1a63060e7a07e2e3bb/components/jsmimeemitter.js">annotate</a> |
<a href="/comm-central/diff/942330424dd7626562381d1a63060e7a07e2e3bb/components/jsmimeemitter.js">diff</a> |
<a href="/comm-central/comparison/942330424dd7626562381d1a63060e7a07e2e3bb/components/jsmimeemitter.js">comparison</a> |
<a href="/comm-central/log/942330424dd7626562381d1a63060e7a07e2e3bb/components/jsmimeemitter.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/942330424dd7626562381d1a63060e7a07e2e3bb/modules/indexer.js">modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/942330424dd7626562381d1a63060e7a07e2e3bb/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/942330424dd7626562381d1a63060e7a07e2e3bb/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/942330424dd7626562381d1a63060e7a07e2e3bb/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/942330424dd7626562381d1a63060e7a07e2e3bb/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/942330424dd7626562381d1a63060e7a07e2e3bb/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/942330424dd7626562381d1a63060e7a07e2e3bb/modules/mimemsg.js">modules/mimemsg.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/942330424dd7626562381d1a63060e7a07e2e3bb/modules/mimemsg.js">file</a> |
<a href="/comm-central/annotate/942330424dd7626562381d1a63060e7a07e2e3bb/modules/mimemsg.js">annotate</a> |
<a href="/comm-central/diff/942330424dd7626562381d1a63060e7a07e2e3bb/modules/mimemsg.js">diff</a> |
<a href="/comm-central/comparison/942330424dd7626562381d1a63060e7a07e2e3bb/modules/mimemsg.js">comparison</a> |
<a href="/comm-central/log/942330424dd7626562381d1a63060e7a07e2e3bb/modules/mimemsg.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/components/jsmimeemitter.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/components/jsmimeemitter.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -37,16 +37,21 @@</span>
<a href="#l1.4"></a><span id="l1.4"> </span>
<a href="#l1.5"></a><span id="l1.5"> const Cc = Components.classes;</span>
<a href="#l1.6"></a><span id="l1.6"> const Ci = Components.interfaces;</span>
<a href="#l1.7"></a><span id="l1.7"> const Cr = Components.results;</span>
<a href="#l1.8"></a><span id="l1.8"> const Cu = Components.utils;</span>
<a href="#l1.9"></a><span id="l1.9"> </span>
<a href="#l1.10"></a><span id="l1.10"> Cu.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+const kStateUnknown = 0;</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+const kStateInHeaders = 1;</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+const kStateInBody = 2;</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+const kStateInAttachment = 3;</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+</span>
<a href="#l1.17"></a><span id="l1.17"> /**</span>
<a href="#l1.18"></a><span id="l1.18">  * Custom nsIMimeEmitter to build a sub-optimal javascript representation of a</span>
<a href="#l1.19"></a><span id="l1.19">  *  MIME message.  The intent is that a better mechanism than is evolved to</span>
<a href="#l1.20"></a><span id="l1.20">  *  provide a javascript-accessible representation of the message.</span>
<a href="#l1.21"></a><span id="l1.21">  *</span>
<a href="#l1.22"></a><span id="l1.22">  * Processing occurs in two passes.  During the first pass, libmime is parsing</span>
<a href="#l1.23"></a><span id="l1.23">  *  the stream it is receiving, and generating header and body events for all</span>
<a href="#l1.24"></a><span id="l1.24">  *  MimeMessage instances it encounters.  This provides us with the knowledge</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineat">@@ -79,16 +84,22 @@ function MimeMessageEmitter() {</span>
<a href="#l1.26"></a><span id="l1.26">   </span>
<a href="#l1.27"></a><span id="l1.27">   this._rootMsg = null;</span>
<a href="#l1.28"></a><span id="l1.28">   this._messageStack = [];</span>
<a href="#l1.29"></a><span id="l1.29">   this._parentMsg = null;</span>
<a href="#l1.30"></a><span id="l1.30">   this._curMsg = null;</span>
<a href="#l1.31"></a><span id="l1.31">   </span>
<a href="#l1.32"></a><span id="l1.32">   this._messageIndex = 0;</span>
<a href="#l1.33"></a><span id="l1.33">   this._allSubMessages = [];</span>
<a href="#l1.34"></a><span id="l1.34" class="difflineplus">+  </span>
<a href="#l1.35"></a><span id="l1.35" class="difflineplus">+  this._partMap = {};</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineplus">+  this._curPart = null;</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineplus">+  this._curBodyPart = null;</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineplus">+  </span>
<a href="#l1.39"></a><span id="l1.39" class="difflineplus">+  this._state = kStateUnknown;</span>
<a href="#l1.40"></a><span id="l1.40"> }</span>
<a href="#l1.41"></a><span id="l1.41"> </span>
<a href="#l1.42"></a><span id="l1.42"> MimeMessageEmitter.prototype = {</span>
<a href="#l1.43"></a><span id="l1.43">   classDescription: &quot;JS Mime Message Emitter&quot;,</span>
<a href="#l1.44"></a><span id="l1.44">   classID: Components.ID(&quot;{8cddbbbc-7ced-46b0-a936-8cddd1928c24}&quot;),</span>
<a href="#l1.45"></a><span id="l1.45">   contractID: &quot;@mozilla.org/gloda/jsmimeemitter;1&quot;,</span>
<a href="#l1.46"></a><span id="l1.46">   </span>
<a href="#l1.47"></a><span id="l1.47">   _partRE: new RegExp(&quot;^[^?]+\?(?:[^&amp;]+&amp;)*part=([^&amp;]+)(?:&amp;[^&amp;]+)*$&quot;),</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineat">@@ -99,64 +110,120 @@ MimeMessageEmitter.prototype = {</span>
<a href="#l1.49"></a><span id="l1.49">       &quot;@mozilla.org/messenger/mimeemitter;1?type=application/x-js-mime-message&quot;,</span>
<a href="#l1.50"></a><span id="l1.50">   }],</span>
<a href="#l1.51"></a><span id="l1.51">   </span>
<a href="#l1.52"></a><span id="l1.52">   QueryInterface: XPCOMUtils.generateQI([Ci.nsIMimeEmitter]),</span>
<a href="#l1.53"></a><span id="l1.53"> </span>
<a href="#l1.54"></a><span id="l1.54">   initialize: function mime_emitter_initialize(aUrl, aChannel, aFormat) {</span>
<a href="#l1.55"></a><span id="l1.55">     this._url = aUrl;</span>
<a href="#l1.56"></a><span id="l1.56">     this._curMsg = this._parentMsg = this._rootMsg = new this._mimeMsg.MimeMessage();</span>
<a href="#l1.57"></a><span id="l1.57" class="difflineplus">+    this._curMsg.partName = &quot;&quot;;</span>
<a href="#l1.58"></a><span id="l1.58" class="difflineplus">+    this._partMap[&quot;&quot;] = this._curMsg;</span>
<a href="#l1.59"></a><span id="l1.59">     </span>
<a href="#l1.60"></a><span id="l1.60">     this._mimeMsg.MsgHdrToMimeMessage.RESULT_RENDEVOUZ[aUrl.spec] =</span>
<a href="#l1.61"></a><span id="l1.61">       this._rootMsg;</span>
<a href="#l1.62"></a><span id="l1.62">     </span>
<a href="#l1.63"></a><span id="l1.63">     this._channel = aChannel;</span>
<a href="#l1.64"></a><span id="l1.64">   },</span>
<a href="#l1.65"></a><span id="l1.65">   </span>
<a href="#l1.66"></a><span id="l1.66">   complete: function mime_emitter_complete() {</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineminus">-    // null out everything we can.  secretive cycles are eating us alive.</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineplus">+    // dump(&quot;!!!!\n!!!!\n!!!!\n&quot; + this._rootMsg.prettyString() + &quot;\n&quot;);</span>
<a href="#l1.69"></a><span id="l1.69">     this._url = null;</span>
<a href="#l1.70"></a><span id="l1.70">     this._channel = null;</span>
<a href="#l1.71"></a><span id="l1.71">     </span>
<a href="#l1.72"></a><span id="l1.72">     this._inputStream = null;</span>
<a href="#l1.73"></a><span id="l1.73">     this._outputStream = null;</span>
<a href="#l1.74"></a><span id="l1.74">     </span>
<a href="#l1.75"></a><span id="l1.75">     this._outputListener = null;</span>
<a href="#l1.76"></a><span id="l1.76"> </span>
<a href="#l1.77"></a><span id="l1.77">     this._curMsg = this._parentMsg = this._messageStack = this._rootMsg = null;</span>
<a href="#l1.78"></a><span id="l1.78">     this._messageIndex = null;</span>
<a href="#l1.79"></a><span id="l1.79">     this._allSubMessages = null;</span>
<a href="#l1.80"></a><span id="l1.80" class="difflineplus">+    </span>
<a href="#l1.81"></a><span id="l1.81" class="difflineplus">+    this._partMap = null;</span>
<a href="#l1.82"></a><span id="l1.82" class="difflineplus">+    this._curPart = null;</span>
<a href="#l1.83"></a><span id="l1.83" class="difflineplus">+    this._curBodyPart = null;</span>
<a href="#l1.84"></a><span id="l1.84">   },</span>
<a href="#l1.85"></a><span id="l1.85">   </span>
<a href="#l1.86"></a><span id="l1.86">   setPipe: function mime_emitter_setPipe(aInputStream, aOutputStream) {</span>
<a href="#l1.87"></a><span id="l1.87">     this._inputStream = aInputStream;</span>
<a href="#l1.88"></a><span id="l1.88">     this._outputStream = aOutputStream;</span>
<a href="#l1.89"></a><span id="l1.89">   },</span>
<a href="#l1.90"></a><span id="l1.90">   set outputListener(aListener) {</span>
<a href="#l1.91"></a><span id="l1.91">     this._outputListener = aListener;</span>
<a href="#l1.92"></a><span id="l1.92">   },</span>
<a href="#l1.93"></a><span id="l1.93">   get outputListener() {</span>
<a href="#l1.94"></a><span id="l1.94">     return this._outputListener;</span>
<a href="#l1.95"></a><span id="l1.95">   }, </span>
<a href="#l1.96"></a><span id="l1.96">   </span>
<a href="#l1.97"></a><span id="l1.97" class="difflineplus">+  _beginPayload: function mime_emitter__beginPayload(aContentType, aIsPart) {</span>
<a href="#l1.98"></a><span id="l1.98" class="difflineplus">+    aContentType = aContentType.toLowerCase();</span>
<a href="#l1.99"></a><span id="l1.99" class="difflineplus">+    if (aContentType == &quot;text/plain&quot; || aContentType == &quot;text/html&quot;) {</span>
<a href="#l1.100"></a><span id="l1.100" class="difflineplus">+      this._curBodyPart = new this._mimeMsg.MimeBody(aContentType, aIsPart);</span>
<a href="#l1.101"></a><span id="l1.101" class="difflineplus">+      this._parentMsg.bodyParts.push(this._curBodyPart);</span>
<a href="#l1.102"></a><span id="l1.102" class="difflineplus">+      this._curPart = aIsPart ? this._curBodyPart : null;</span>
<a href="#l1.103"></a><span id="l1.103" class="difflineplus">+    }</span>
<a href="#l1.104"></a><span id="l1.104" class="difflineplus">+    else if (aContentType == &quot;message/rfc822&quot;) {</span>
<a href="#l1.105"></a><span id="l1.105" class="difflineplus">+      // startBody will take care of this</span>
<a href="#l1.106"></a><span id="l1.106" class="difflineplus">+      this._curPart = this._curBodyPart = null;</span>
<a href="#l1.107"></a><span id="l1.107" class="difflineplus">+    }</span>
<a href="#l1.108"></a><span id="l1.108" class="difflineplus">+    // this is going to fall-down with TNEF encapsulation and such, we really</span>
<a href="#l1.109"></a><span id="l1.109" class="difflineplus">+    //  need to just be consuming the object model.</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineplus">+    else if (aContentType.indexOf(&quot;multipart/&quot;) == 0) {</span>
<a href="#l1.111"></a><span id="l1.111" class="difflineplus">+      this._curBodyPart = null;</span>
<a href="#l1.112"></a><span id="l1.112" class="difflineplus">+      // alternatives are always parts for part numbering purposes</span>
<a href="#l1.113"></a><span id="l1.113" class="difflineplus">+      this._curPart = aIsPart ? new this._mimeMsg.MimeContainer(aContentType)</span>
<a href="#l1.114"></a><span id="l1.114" class="difflineplus">+                              : null;</span>
<a href="#l1.115"></a><span id="l1.115" class="difflineplus">+    }</span>
<a href="#l1.116"></a><span id="l1.116" class="difflineplus">+    else {</span>
<a href="#l1.117"></a><span id="l1.117" class="difflineplus">+      this._curBodyPart = null;</span>
<a href="#l1.118"></a><span id="l1.118" class="difflineplus">+      this._curPart = aIsPart ?</span>
<a href="#l1.119"></a><span id="l1.119" class="difflineplus">+        new this._mimeMsg.MimeUnknown(aContentType, aIsPart) : null;</span>
<a href="#l1.120"></a><span id="l1.120" class="difflineplus">+    }</span>
<a href="#l1.121"></a><span id="l1.121" class="difflineplus">+  },</span>
<a href="#l1.122"></a><span id="l1.122" class="difflineplus">+  </span>
<a href="#l1.123"></a><span id="l1.123">   // ----- Header Routines</span>
<a href="#l1.124"></a><span id="l1.124">   startHeader: function mime_emitter_startHeader(aIsRootMailHeader,</span>
<a href="#l1.125"></a><span id="l1.125">       aIsHeaderOnly, aMsgID, aOutputCharset) {</span>
<a href="#l1.126"></a><span id="l1.126" class="difflineminus">-    </span>
<a href="#l1.127"></a><span id="l1.127" class="difflineplus">+    this._state = kStateInHeaders;</span>
<a href="#l1.128"></a><span id="l1.128">     if (aIsRootMailHeader) {</span>
<a href="#l1.129"></a><span id="l1.129">       this.updateCharacterSet(aOutputCharset);</span>
<a href="#l1.130"></a><span id="l1.130">       // nothing to do curMsg-wise, already initialized.</span>
<a href="#l1.131"></a><span id="l1.131">     }</span>
<a href="#l1.132"></a><span id="l1.132">     else {</span>
<a href="#l1.133"></a><span id="l1.133">       this._curMsg = new this._mimeMsg.MimeMessage();</span>
<a href="#l1.134"></a><span id="l1.134" class="difflineplus">+      </span>
<a href="#l1.135"></a><span id="l1.135" class="difflineplus">+      this._curMsg.partName = this._savedPartPath;</span>
<a href="#l1.136"></a><span id="l1.136" class="difflineplus">+      this._placePart(this._curMsg);</span>
<a href="#l1.137"></a><span id="l1.137" class="difflineplus">+      delete this._savedPartPath;</span>
<a href="#l1.138"></a><span id="l1.138" class="difflineplus">+      </span>
<a href="#l1.139"></a><span id="l1.139">       this._parentMsg.messages.push(this._curMsg);</span>
<a href="#l1.140"></a><span id="l1.140">       this._allSubMessages.push(this._curMsg);</span>
<a href="#l1.141"></a><span id="l1.141">     }</span>
<a href="#l1.142"></a><span id="l1.142">   },</span>
<a href="#l1.143"></a><span id="l1.143">   addHeaderField: function mime_emitter_addHeaderField(aField, aValue) {</span>
<a href="#l1.144"></a><span id="l1.144" class="difflineplus">+    if (this._state == kStateInBody) {</span>
<a href="#l1.145"></a><span id="l1.145" class="difflineplus">+      aField = aField.toLowerCase();</span>
<a href="#l1.146"></a><span id="l1.146" class="difflineplus">+      let indexSemi = aValue.indexOf(&quot;;&quot;);</span>
<a href="#l1.147"></a><span id="l1.147" class="difflineplus">+      if (indexSemi &gt;= 0)</span>
<a href="#l1.148"></a><span id="l1.148" class="difflineplus">+        aValue = aValue.substring(0, indexSemi);</span>
<a href="#l1.149"></a><span id="l1.149" class="difflineplus">+      if (aField == &quot;content-type&quot;)</span>
<a href="#l1.150"></a><span id="l1.150" class="difflineplus">+        this._beginPayload(aValue, true);</span>
<a href="#l1.151"></a><span id="l1.151" class="difflineplus">+      else if (aField == &quot;x-jsemitter-part-path&quot;) {</span>
<a href="#l1.152"></a><span id="l1.152" class="difflineplus">+        if (this._curPart) {</span>
<a href="#l1.153"></a><span id="l1.153" class="difflineplus">+          this._curPart.partName = aValue;</span>
<a href="#l1.154"></a><span id="l1.154" class="difflineplus">+          this._placePart(this._curPart);</span>
<a href="#l1.155"></a><span id="l1.155" class="difflineplus">+        }</span>
<a href="#l1.156"></a><span id="l1.156" class="difflineplus">+        else</span>
<a href="#l1.157"></a><span id="l1.157" class="difflineplus">+          this._savedPartPath = aValue;</span>
<a href="#l1.158"></a><span id="l1.158" class="difflineplus">+      }</span>
<a href="#l1.159"></a><span id="l1.159" class="difflineplus">+      return;</span>
<a href="#l1.160"></a><span id="l1.160" class="difflineplus">+    }</span>
<a href="#l1.161"></a><span id="l1.161" class="difflineplus">+    if (this._state != kStateInHeaders)</span>
<a href="#l1.162"></a><span id="l1.162" class="difflineplus">+      return;</span>
<a href="#l1.163"></a><span id="l1.163">     let lowerField = aField.toLowerCase();</span>
<a href="#l1.164"></a><span id="l1.164">     if (lowerField in this._curMsg.headers)</span>
<a href="#l1.165"></a><span id="l1.165">       this._curMsg.headers[lowerField].push(aValue);</span>
<a href="#l1.166"></a><span id="l1.166">     else</span>
<a href="#l1.167"></a><span id="l1.167">       this._curMsg.headers[lowerField] = [aValue];</span>
<a href="#l1.168"></a><span id="l1.168">   },</span>
<a href="#l1.169"></a><span id="l1.169">   addAllHeaders: function mime_emitter_addAllHeaders(aAllHeaders, aHeaderSize) {</span>
<a href="#l1.170"></a><span id="l1.170">     // This is called by the parsing code after the calls to AddHeaderField (or</span>
<a href="#l1.171"></a><span id="l1.171" class="difflineat">@@ -196,16 +263,57 @@ MimeMessageEmitter.prototype = {</span>
<a href="#l1.172"></a><span id="l1.172">       </span>
<a href="#l1.173"></a><span id="l1.173">       this._channel.contentType = curContentType;</span>
<a href="#l1.174"></a><span id="l1.174">       this._channel.contentCharset = aCharset;</span>
<a href="#l1.175"></a><span id="l1.175">     }</span>
<a href="#l1.176"></a><span id="l1.176">     */</span>
<a href="#l1.177"></a><span id="l1.177">   },</span>
<a href="#l1.178"></a><span id="l1.178">   </span>
<a href="#l1.179"></a><span id="l1.179">   /**</span>
<a href="#l1.180"></a><span id="l1.180" class="difflineplus">+   * Place a part in its proper location.  We know that we are called as a</span>
<a href="#l1.181"></a><span id="l1.181" class="difflineplus">+   *  result of in-order traversal, so this is wildly easy to deal with.</span>
<a href="#l1.182"></a><span id="l1.182" class="difflineplus">+   */</span>
<a href="#l1.183"></a><span id="l1.183" class="difflineplus">+  _placePart: function(aPart) {</span>
<a href="#l1.184"></a><span id="l1.184" class="difflineplus">+    let partName = aPart.partName;</span>
<a href="#l1.185"></a><span id="l1.185" class="difflineplus">+    this._partMap[partName] = aPart;</span>
<a href="#l1.186"></a><span id="l1.186" class="difflineplus">+    let parentName = partName.substring(0, partName.lastIndexOf(&quot;.&quot;));</span>
<a href="#l1.187"></a><span id="l1.187" class="difflineplus">+    let parentPart = this._partMap[parentName];</span>
<a href="#l1.188"></a><span id="l1.188" class="difflineplus">+    parentPart.parts.push(aPart);</span>
<a href="#l1.189"></a><span id="l1.189" class="difflineplus">+  },</span>
<a href="#l1.190"></a><span id="l1.190" class="difflineplus">+  </span>
<a href="#l1.191"></a><span id="l1.191" class="difflineplus">+  /**</span>
<a href="#l1.192"></a><span id="l1.192" class="difflineplus">+   * In the case of attachments, we need to replace an existing part with a</span>
<a href="#l1.193"></a><span id="l1.193" class="difflineplus">+   *  more representative part...</span>
<a href="#l1.194"></a><span id="l1.194" class="difflineplus">+   */</span>
<a href="#l1.195"></a><span id="l1.195" class="difflineplus">+  _replacePart: function(aPart) {</span>
<a href="#l1.196"></a><span id="l1.196" class="difflineplus">+    let partName = aPart.partName;</span>
<a href="#l1.197"></a><span id="l1.197" class="difflineplus">+    this._partMap[partName] = aPart;</span>
<a href="#l1.198"></a><span id="l1.198" class="difflineplus">+    </span>
<a href="#l1.199"></a><span id="l1.199" class="difflineplus">+    let parentName = partName.substring(0, partName.lastIndexOf(&quot;.&quot;));</span>
<a href="#l1.200"></a><span id="l1.200" class="difflineplus">+    let parentPart = this._partMap[parentName];</span>
<a href="#l1.201"></a><span id="l1.201" class="difflineplus">+    </span>
<a href="#l1.202"></a><span id="l1.202" class="difflineplus">+    let childNamePart = partName.substring(partName.lastIndexOf(&quot;.&quot;)+1);</span>
<a href="#l1.203"></a><span id="l1.203" class="difflineplus">+    let childIndex = parseInt(childNamePart) - 1;</span>
<a href="#l1.204"></a><span id="l1.204" class="difflineplus">+    </span>
<a href="#l1.205"></a><span id="l1.205" class="difflineplus">+    let oldPart = parentPart.parts[childIndex];</span>
<a href="#l1.206"></a><span id="l1.206" class="difflineplus">+    parentPart.parts[childIndex] = aPart;</span>
<a href="#l1.207"></a><span id="l1.207" class="difflineplus">+    aPart.parts = oldPart.parts;</span>
<a href="#l1.208"></a><span id="l1.208" class="difflineplus">+</span>
<a href="#l1.209"></a><span id="l1.209" class="difflineplus">+    // - remove it if it was a body part.  This can happen for text/plain</span>
<a href="#l1.210"></a><span id="l1.210" class="difflineplus">+    //  attachments.  Like patches.</span>
<a href="#l1.211"></a><span id="l1.211" class="difflineplus">+    // (climb the parents until we find a message/bodyparts holder...)</span>
<a href="#l1.212"></a><span id="l1.212" class="difflineplus">+    while (parentPart.partName &amp;&amp; !parentPart.bodyParts) {</span>
<a href="#l1.213"></a><span id="l1.213" class="difflineplus">+      parentName = parentName.substring(0, parentName.lastIndexOf(&quot;.&quot;));</span>
<a href="#l1.214"></a><span id="l1.214" class="difflineplus">+      parentPart = this._partMap[parentName];</span>
<a href="#l1.215"></a><span id="l1.215" class="difflineplus">+    }</span>
<a href="#l1.216"></a><span id="l1.216" class="difflineplus">+    if (parentPart.bodyParts &amp;&amp; parentPart.bodyParts.indexOf(oldPart) &gt;= 0)</span>
<a href="#l1.217"></a><span id="l1.217" class="difflineplus">+      parentPart.bodyParts.splice(parentPart.bodyParts.indexOf(oldPart), 1);</span>
<a href="#l1.218"></a><span id="l1.218" class="difflineplus">+  },</span>
<a href="#l1.219"></a><span id="l1.219" class="difflineplus">+  </span>
<a href="#l1.220"></a><span id="l1.220" class="difflineplus">+  /**</span>
<a href="#l1.221"></a><span id="l1.221">    * Put a part at its proper location.  We rely on this method to be called</span>
<a href="#l1.222"></a><span id="l1.222">    *  in the the sequence generated by StartAttachment (an in-order traversal</span>
<a href="#l1.223"></a><span id="l1.223">    *  of the MIME structure).</span>
<a href="#l1.224"></a><span id="l1.224">    */</span>
<a href="#l1.225"></a><span id="l1.225">   _putPart: function(aPartPath, aPathSoFar, aPart, aParent) {</span>
<a href="#l1.226"></a><span id="l1.226">     let dotIndex = aPartPath.indexOf(&quot;.&quot;);</span>
<a href="#l1.227"></a><span id="l1.227">     let curPath, remPath;</span>
<a href="#l1.228"></a><span id="l1.228">     if (dotIndex &gt;= 0) {</span>
<a href="#l1.229"></a><span id="l1.229" class="difflineat">@@ -214,87 +322,117 @@ MimeMessageEmitter.prototype = {</span>
<a href="#l1.230"></a><span id="l1.230">     }</span>
<a href="#l1.231"></a><span id="l1.231">     else {</span>
<a href="#l1.232"></a><span id="l1.232">       curPath = aPartPath;</span>
<a href="#l1.233"></a><span id="l1.233">       remPath = null;</span>
<a href="#l1.234"></a><span id="l1.234">     }</span>
<a href="#l1.235"></a><span id="l1.235">     let newPathSoFar = aPathSoFar + &quot;.&quot; + curPath;</span>
<a href="#l1.236"></a><span id="l1.236">     let curIndex = parseInt(curPath) - 1;</span>
<a href="#l1.237"></a><span id="l1.237"> </span>
<a href="#l1.238"></a><span id="l1.238" class="difflineminus">-    // add MimeUnknowns for parts that should already exist</span>
<a href="#l1.239"></a><span id="l1.239" class="difflineplus">+    // for parts that should exist, try and find them in the part map, otherwise</span>
<a href="#l1.240"></a><span id="l1.240" class="difflineplus">+    //  create MimeUnknowns</span>
<a href="#l1.241"></a><span id="l1.241">     while (curIndex &gt; aParent.parts.length) {</span>
<a href="#l1.242"></a><span id="l1.242" class="difflineminus">-      aParent.parts.push(new this._mimeMsg.MimeUnknown(newPathSoFar));</span>
<a href="#l1.243"></a><span id="l1.243" class="difflineplus">+      let tempPath = aPathSoFar + &quot;.&quot; + aParent.parts.length;</span>
<a href="#l1.244"></a><span id="l1.244" class="difflineplus">+      if (tempPath in this._partMap)</span>
<a href="#l1.245"></a><span id="l1.245" class="difflineplus">+        aParent.parts.push(this._partMap[tempPath]);</span>
<a href="#l1.246"></a><span id="l1.246" class="difflineplus">+      else {</span>
<a href="#l1.247"></a><span id="l1.247" class="difflineplus">+        let newPart = new this._mimeMsg.MimeUnknown(&quot;unknown/unknown&quot;, true);</span>
<a href="#l1.248"></a><span id="l1.248" class="difflineplus">+        newPart.partName = tempPath;</span>
<a href="#l1.249"></a><span id="l1.249" class="difflineplus">+        aParent.parts.push(newPart);</span>
<a href="#l1.250"></a><span id="l1.250" class="difflineplus">+      }</span>
<a href="#l1.251"></a><span id="l1.251">     }</span>
<a href="#l1.252"></a><span id="l1.252">     </span>
<a href="#l1.253"></a><span id="l1.253">     // are we a leaf?</span>
<a href="#l1.254"></a><span id="l1.254">     if (remPath !== null) {</span>
<a href="#l1.255"></a><span id="l1.255">       // no, we are not a leaf</span>
<a href="#l1.256"></a><span id="l1.256">       if (curIndex == aParent.parts.length) {</span>
<a href="#l1.257"></a><span id="l1.257">         // and we need to add a container</span>
<a href="#l1.258"></a><span id="l1.258" class="difflineminus">-        aParent.parts.push(new this._mimeMsg.MimeContainer(newPathSoFar));</span>
<a href="#l1.259"></a><span id="l1.259" class="difflineplus">+        if (newPathSoFar in this._partMap)</span>
<a href="#l1.260"></a><span id="l1.260" class="difflineplus">+          aParent.parts.push(this._partMap[newPathSoFar]);</span>
<a href="#l1.261"></a><span id="l1.261" class="difflineplus">+        else {</span>
<a href="#l1.262"></a><span id="l1.262" class="difflineplus">+          let newPart = new this._mimeMsg.MimeContainer(&quot;multipart/unknown&quot;,</span>
<a href="#l1.263"></a><span id="l1.263" class="difflineplus">+                                                        true);</span>
<a href="#l1.264"></a><span id="l1.264" class="difflineplus">+          newPart.partName = newPathSoFar;</span>
<a href="#l1.265"></a><span id="l1.265" class="difflineplus">+          aParent.parts.push(newPart);</span>
<a href="#l1.266"></a><span id="l1.266" class="difflineplus">+        }</span>
<a href="#l1.267"></a><span id="l1.267">       }</span>
<a href="#l1.268"></a><span id="l1.268">       this._putPart(remPath, newPathSoFar, aPart, aParent.parts[curIndex]);</span>
<a href="#l1.269"></a><span id="l1.269">     }</span>
<a href="#l1.270"></a><span id="l1.270">     else {</span>
<a href="#l1.271"></a><span id="l1.271">       // yes, we are a leaf, we just go here...</span>
<a href="#l1.272"></a><span id="l1.272">       aParent.parts.push(aPart);</span>
<a href="#l1.273"></a><span id="l1.273">     }</span>
<a href="#l1.274"></a><span id="l1.274">   },</span>
<a href="#l1.275"></a><span id="l1.275">   </span>
<a href="#l1.276"></a><span id="l1.276">   // ----- Attachment Routines</span>
<a href="#l1.277"></a><span id="l1.277">   // The attachment processing happens after the initial streaming phase (during</span>
<a href="#l1.278"></a><span id="l1.278">   //  which time we receive the messages, both bodies and headers).  Our caller</span>
<a href="#l1.279"></a><span id="l1.279">   //  traverses the libmime child object hierarchy, emitting an attachment for</span>
<a href="#l1.280"></a><span id="l1.280">   //  each leaf object or sub-message.</span>
<a href="#l1.281"></a><span id="l1.281">   startAttachment: function mime_emitter_startAttachment(aName, aContentType,</span>
<a href="#l1.282"></a><span id="l1.282">       aUrl, aNotDownloaded) {</span>
<a href="#l1.283"></a><span id="l1.283" class="difflineminus">-    </span>
<a href="#l1.284"></a><span id="l1.284" class="difflineplus">+    this._state = kStateInAttachment;</span>
<a href="#l1.285"></a><span id="l1.285">     // we need to strip our magic flags from the URL</span>
<a href="#l1.286"></a><span id="l1.286">     aURl = aUrl.replace(&quot;header=filter&amp;emitter=js&amp;&quot;, &quot;&quot;);</span>
<a href="#l1.287"></a><span id="l1.287">     </span>
<a href="#l1.288"></a><span id="l1.288">     // the url should contain a part= piece that tells us the part name, which</span>
<a href="#l1.289"></a><span id="l1.289">     //  we then use to figure out where.</span>
<a href="#l1.290"></a><span id="l1.290">     let partMatch = this._partRE.exec(aUrl);</span>
<a href="#l1.291"></a><span id="l1.291">     let partName = partMatch[1];</span>
<a href="#l1.292"></a><span id="l1.292"> </span>
<a href="#l1.293"></a><span id="l1.293">     let part;</span>
<a href="#l1.294"></a><span id="l1.294">     if (aContentType == &quot;message/rfc822&quot;) {</span>
<a href="#l1.295"></a><span id="l1.295" class="difflineminus">-      // since we are assuming an in-order traversal, it's safe to assume that</span>
<a href="#l1.296"></a><span id="l1.296" class="difflineminus">-      //  we will see the messages in the same order we previously saw them.</span>
<a href="#l1.297"></a><span id="l1.297" class="difflineminus">-      part = this._allSubMessages[this._messageIndex++];</span>
<a href="#l1.298"></a><span id="l1.298" class="difflineminus">-      part.partName = partName;</span>
<a href="#l1.299"></a><span id="l1.299" class="difflineplus">+      // we already have all we need to know about the message, ignore it</span>
<a href="#l1.300"></a><span id="l1.300" class="difflineplus">+      return;</span>
<a href="#l1.301"></a><span id="l1.301">     }</span>
<a href="#l1.302"></a><span id="l1.302">     else {</span>
<a href="#l1.303"></a><span id="l1.303">       // create the attachment</span>
<a href="#l1.304"></a><span id="l1.304">       part = new this._mimeMsg.MimeMessageAttachment(partName,</span>
<a href="#l1.305"></a><span id="l1.305">           aName, aContentType, aUrl, aNotDownloaded);</span>
<a href="#l1.306"></a><span id="l1.306">     }</span>
<a href="#l1.307"></a><span id="l1.307">     </span>
<a href="#l1.308"></a><span id="l1.308" class="difflineminus">-    this._putPart(part.partName.substring(2), &quot;1&quot;,</span>
<a href="#l1.309"></a><span id="l1.309" class="difflineminus">-                  part, this._rootMsg);</span>
<a href="#l1.310"></a><span id="l1.310" class="difflineplus">+    if (part.isRealAttachment) {</span>
<a href="#l1.311"></a><span id="l1.311" class="difflineplus">+      // replace the existing part with the attachment...</span>
<a href="#l1.312"></a><span id="l1.312" class="difflineplus">+      this._replacePart(part);</span>
<a href="#l1.313"></a><span id="l1.313" class="difflineplus">+    }</span>
<a href="#l1.314"></a><span id="l1.314">   },</span>
<a href="#l1.315"></a><span id="l1.315">   addAttachmentField: function mime_emitter_addAttachmentField(aField, aValue) {</span>
<a href="#l1.316"></a><span id="l1.316">     // this only gives us X-Mozilla-PartURL, which is the same as aUrl we</span>
<a href="#l1.317"></a><span id="l1.317">     //  already got previously, so need to do anything with this.</span>
<a href="#l1.318"></a><span id="l1.318">   },</span>
<a href="#l1.319"></a><span id="l1.319">   endAttachment: function mime_emitter_endAttachment() {</span>
<a href="#l1.320"></a><span id="l1.320">     // don't need to do anything here, since we don't care about the headers.</span>
<a href="#l1.321"></a><span id="l1.321">   },</span>
<a href="#l1.322"></a><span id="l1.322">   endAllAttachments: function mime_emitter_endAllAttachments() {</span>
<a href="#l1.323"></a><span id="l1.323">     // nop</span>
<a href="#l1.324"></a><span id="l1.324">   },</span>
<a href="#l1.325"></a><span id="l1.325">   </span>
<a href="#l1.326"></a><span id="l1.326">   // ----- Body Routines</span>
<a href="#l1.327"></a><span id="l1.327">   startBody: function mime_emitter_startBody(aIsBodyOnly, aMsgID, aOutCharset) {</span>
<a href="#l1.328"></a><span id="l1.328" class="difflineplus">+    this._state = kStateInBody;</span>
<a href="#l1.329"></a><span id="l1.329" class="difflineplus">+    </span>
<a href="#l1.330"></a><span id="l1.330">     this._messageStack.push(this._curMsg);</span>
<a href="#l1.331"></a><span id="l1.331">     this._parentMsg = this._curMsg;</span>
<a href="#l1.332"></a><span id="l1.332" class="difflineplus">+</span>
<a href="#l1.333"></a><span id="l1.333" class="difflineplus">+    // begin payload processing</span>
<a href="#l1.334"></a><span id="l1.334" class="difflineplus">+    let contentType = this._curMsg.get(&quot;content-type&quot;, &quot;text/plain&quot;);</span>
<a href="#l1.335"></a><span id="l1.335" class="difflineplus">+    let indexSemi = contentType.indexOf(&quot;;&quot;);</span>
<a href="#l1.336"></a><span id="l1.336" class="difflineplus">+    if (indexSemi &gt;= 0)</span>
<a href="#l1.337"></a><span id="l1.337" class="difflineplus">+      contentType = contentType.substring(0, indexSemi);</span>
<a href="#l1.338"></a><span id="l1.338" class="difflineplus">+    this._beginPayload(contentType, true);</span>
<a href="#l1.339"></a><span id="l1.339" class="difflineplus">+    if (this._parentMsg.partName == &quot;&quot;)</span>
<a href="#l1.340"></a><span id="l1.340" class="difflineplus">+      this._curPart.partName = &quot;1&quot;;</span>
<a href="#l1.341"></a><span id="l1.341" class="difflineplus">+    else</span>
<a href="#l1.342"></a><span id="l1.342" class="difflineplus">+      this._curPart.partName = this._curMsg.partName + &quot;.1&quot;;</span>
<a href="#l1.343"></a><span id="l1.343" class="difflineplus">+    this._placePart(this._curPart);</span>
<a href="#l1.344"></a><span id="l1.344">   },</span>
<a href="#l1.345"></a><span id="l1.345">   </span>
<a href="#l1.346"></a><span id="l1.346">   writeBody: function mime_emitter_writeBody(aBuf, aSize, aOutAmountWritten) {</span>
<a href="#l1.347"></a><span id="l1.347" class="difflineminus">-    this._curMsg.body += aBuf;</span>
<a href="#l1.348"></a><span id="l1.348" class="difflineplus">+    if (this._curBodyPart)</span>
<a href="#l1.349"></a><span id="l1.349" class="difflineplus">+      this._curBodyPart.body += aBuf;</span>
<a href="#l1.350"></a><span id="l1.350">   },</span>
<a href="#l1.351"></a><span id="l1.351">   </span>
<a href="#l1.352"></a><span id="l1.352">   endBody: function mime_emitter_endBody() {</span>
<a href="#l1.353"></a><span id="l1.353">     this._messageStack.pop();</span>
<a href="#l1.354"></a><span id="l1.354">     this._parentMsg = this._messageStack[this._messageStack.length - 1];</span>
<a href="#l1.355"></a><span id="l1.355">   },</span>
<a href="#l1.356"></a><span id="l1.356">   </span>
<a href="#l1.357"></a><span id="l1.357">   // ----- Generic Write (confusing)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/modules/indexer.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/modules/indexer.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -2013,17 +2013,17 @@ var GlodaIndexer = {</span>
<a href="#l2.4"></a><span id="l2.4">   _indexMessage: function gloda_indexMessage(aMsgHdr, aCallbackHandle) {</span>
<a href="#l2.5"></a><span id="l2.5">     this._log.debug(&quot;*** Indexing message: &quot; + aMsgHdr.messageKey + &quot; : &quot; +</span>
<a href="#l2.6"></a><span id="l2.6">                     aMsgHdr.subject);</span>
<a href="#l2.7"></a><span id="l2.7">     MsgHdrToMimeMessage(aMsgHdr, aCallbackHandle.callbackThis,</span>
<a href="#l2.8"></a><span id="l2.8">         aCallbackHandle.callback);</span>
<a href="#l2.9"></a><span id="l2.9">     let [,aMimeMsg] = yield this.kWorkAsync;</span>
<a href="#l2.10"></a><span id="l2.10"> </span>
<a href="#l2.11"></a><span id="l2.11">     if (aMimeMsg)</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-      this._log.debug(&quot;  * Got Body! Length: &quot; + aMimeMsg.body.length);</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+      this._log.debug(&quot;  * Got Mime Message!&quot;);</span>
<a href="#l2.14"></a><span id="l2.14">     else</span>
<a href="#l2.15"></a><span id="l2.15">       this._log.debug(&quot;  * Did not get body!&quot;);</span>
<a href="#l2.16"></a><span id="l2.16"> </span>
<a href="#l2.17"></a><span id="l2.17">     // -- Find/create the conversation the message belongs to.</span>
<a href="#l2.18"></a><span id="l2.18">     // Our invariant is that all messages that exist in the database belong to</span>
<a href="#l2.19"></a><span id="l2.19">     //  a conversation.</span>
<a href="#l2.20"></a><span id="l2.20">     </span>
<a href="#l2.21"></a><span id="l2.21">     // - See if any of the ancestors exist and have a conversationID...</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineat">@@ -2153,18 +2153,16 @@ var GlodaIndexer = {</span>
<a href="#l2.23"></a><span id="l2.23">                                 if (att.isRealAttachment)];</span>
<a href="#l2.24"></a><span id="l2.24">       // we need some kind of delimeter for the names.  we use a newline.</span>
<a href="#l2.25"></a><span id="l2.25">       if (allAttachmentNames)</span>
<a href="#l2.26"></a><span id="l2.26">         attachmentNames = allAttachmentNames.join(&quot;\n&quot;);</span>
<a href="#l2.27"></a><span id="l2.27">     } </span>
<a href="#l2.28"></a><span id="l2.28">     </span>
<a href="#l2.29"></a><span id="l2.29">     let isNew;</span>
<a href="#l2.30"></a><span id="l2.30">     if (curMsg === null) {</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineminus">-      this._log.debug(&quot;...creating new message.  body length: &quot; +</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineminus">-                      (aMimeMsg ? aMimeMsg.body.length : null));</span>
<a href="#l2.33"></a><span id="l2.33">       curMsg = this._datastore.createMessage(aMsgHdr.folder,</span>
<a href="#l2.34"></a><span id="l2.34">                                              aMsgHdr.messageKey,                </span>
<a href="#l2.35"></a><span id="l2.35">                                              conversationID,</span>
<a href="#l2.36"></a><span id="l2.36">                                              aMsgHdr.date,</span>
<a href="#l2.37"></a><span id="l2.37">                                              aMsgHdr.messageId);</span>
<a href="#l2.38"></a><span id="l2.38">       curMsg._conversation = conversation;</span>
<a href="#l2.39"></a><span id="l2.39">       isNew = true;</span>
<a href="#l2.40"></a><span id="l2.40">     }</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineat">@@ -2177,17 +2175,17 @@ var GlodaIndexer = {</span>
<a href="#l2.42"></a><span id="l2.42">       // note: we are assuming that our matching logic is flawless in that</span>
<a href="#l2.43"></a><span id="l2.43">       //  if this message was not a ghost, we are assuming the 'body'</span>
<a href="#l2.44"></a><span id="l2.44">       //  associated with the id is still exactly the same.  It is conceivable</span>
<a href="#l2.45"></a><span id="l2.45">       //  that there are cases where this is not true.</span>
<a href="#l2.46"></a><span id="l2.46">     }</span>
<a href="#l2.47"></a><span id="l2.47">     </span>
<a href="#l2.48"></a><span id="l2.48">     if (isNew) {</span>
<a href="#l2.49"></a><span id="l2.49">       curMsg._subject = aMsgHdr.subject;</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineminus">-      curMsg._body = aMimeMsg &amp;&amp; aMimeMsg.body;</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineplus">+      curMsg._body = aMimeMsg &amp;&amp; aMimeMsg.bodyPlain;</span>
<a href="#l2.52"></a><span id="l2.52">       curMsg._attachmentNames = attachmentNames;</span>
<a href="#l2.53"></a><span id="l2.53">     }</span>
<a href="#l2.54"></a><span id="l2.54">     </span>
<a href="#l2.55"></a><span id="l2.55">     yield aCallbackHandle.pushAndGo(</span>
<a href="#l2.56"></a><span id="l2.56">         Gloda.grokNounItem(curMsg, {header: aMsgHdr, mime: aMimeMsg}, isNew,</span>
<a href="#l2.57"></a><span id="l2.57">             aCallbackHandle));</span>
<a href="#l2.58"></a><span id="l2.58">     </span>
<a href="#l2.59"></a><span id="l2.59">     // we want to update the header for messages only after the transaction</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/modules/mimemsg.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/modules/mimemsg.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -31,17 +31,17 @@</span>
<a href="#l3.4"></a><span id="l3.4">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l3.5"></a><span id="l3.5">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l3.6"></a><span id="l3.6">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l3.7"></a><span id="l3.7">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l3.8"></a><span id="l3.8">  * </span>
<a href="#l3.9"></a><span id="l3.9">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l3.10"></a><span id="l3.10"> </span>
<a href="#l3.11"></a><span id="l3.11"> EXPORTED_SYMBOLS = ['MsgHdrToMimeMessage',</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-                    'MimeMessage', 'MimeContainer', 'MimeUnknown',</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+                    'MimeMessage', 'MimeContainer', 'MimeBody', 'MimeUnknown',</span>
<a href="#l3.14"></a><span id="l3.14">                     'MimeMessageAttachment'];</span>
<a href="#l3.15"></a><span id="l3.15"> </span>
<a href="#l3.16"></a><span id="l3.16"> const Cc = Components.classes;</span>
<a href="#l3.17"></a><span id="l3.17"> const Ci = Components.interfaces;</span>
<a href="#l3.18"></a><span id="l3.18"> const Cr = Components.results;</span>
<a href="#l3.19"></a><span id="l3.19"> const Cu = Components.utils;</span>
<a href="#l3.20"></a><span id="l3.20"> </span>
<a href="#l3.21"></a><span id="l3.21"> Components.utils.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineat">@@ -165,32 +165,43 @@ function MsgHdrToMimeMessage(aMsgHdr, aC</span>
<a href="#l3.23"></a><span id="l3.23"> MsgHdrToMimeMessage.RESULT_RENDEVOUZ = {};</span>
<a href="#l3.24"></a><span id="l3.24"> </span>
<a href="#l3.25"></a><span id="l3.25"> /**</span>
<a href="#l3.26"></a><span id="l3.26">  * @ivar partName The MIME part, ex &quot;1.2.2.1&quot;.  The partName of a (top-level)</span>
<a href="#l3.27"></a><span id="l3.27">  *     message is &quot;1&quot;, its first child is &quot;1.1&quot;, its second child is &quot;1.2&quot;,</span>
<a href="#l3.28"></a><span id="l3.28">  *     its first child's first child is &quot;1.1.1&quot;, etc.</span>
<a href="#l3.29"></a><span id="l3.29">  * @ivar headers Maps lower-cased header field names to a list of the values</span>
<a href="#l3.30"></a><span id="l3.30">  *     seen for the given header.  Use get or getAll as convenience helpers.</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineminus">- * @ivar body The body of the message.</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+ * @ivar bodyParts A list of the MimeBody instances that belong to this message.</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+ *     If there are nested messages, any bodies under the nested messages will</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineplus">+ *     belong to those messages.</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+ * @ivar bodyPartsPlain A list of the MimeBody instances with a content type of</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+ *     text/plain.</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineplus">+ * @ivar bodyPlain The concatenation of all of the bodyPartsPlain bodies into a</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineplus">+ *     single string.</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+ * @ivar bodyPartsHTML A list of the MimeBody instances with a content type of</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+ *     text/html.</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineplus">+ * @ivar bodyHTML The concatentation of all of the bodyPartsHTML bodies into a</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineplus">+ *     single string. </span>
<a href="#l3.43"></a><span id="l3.43">  * @ivar messages A list of the sub-message children of this message.  Strict</span>
<a href="#l3.44"></a><span id="l3.44">  *     MIME part hierarchy is not maintained; a sub-message's parent is the</span>
<a href="#l3.45"></a><span id="l3.45">  *     closest sub-message above it.  Sub-messages can also be found in the</span>
<a href="#l3.46"></a><span id="l3.46">  *     parts list, if you want a more strict traversal.</span>
<a href="#l3.47"></a><span id="l3.47">  * @ivar parts The list of the MIME part children of this message.  Children</span>
<a href="#l3.48"></a><span id="l3.48">  *     will be either MimeMessage instances, MimeMessageAttachment instances,</span>
<a href="#l3.49"></a><span id="l3.49">  *     MimeContainer instances, or MimeUnknown instances.  The latter two are</span>
<a href="#l3.50"></a><span id="l3.50">  *     the result of limitations in the Javascript representation generation  </span>
<a href="#l3.51"></a><span id="l3.51">  *     at this time, combined with the need to most accurately represent the</span>
<a href="#l3.52"></a><span id="l3.52">  *     MIME structure.</span>
<a href="#l3.53"></a><span id="l3.53">  */</span>
<a href="#l3.54"></a><span id="l3.54"> function MimeMessage() {</span>
<a href="#l3.55"></a><span id="l3.55">   this.partName = null;</span>
<a href="#l3.56"></a><span id="l3.56">   this.headers = {};</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineminus">-  this.body = &quot;&quot;;</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+  </span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+  this.bodyParts = [];</span>
<a href="#l3.60"></a><span id="l3.60"> </span>
<a href="#l3.61"></a><span id="l3.61">   this.messages = [];</span>
<a href="#l3.62"></a><span id="l3.62">   this.attachments = [];</span>
<a href="#l3.63"></a><span id="l3.63"> </span>
<a href="#l3.64"></a><span id="l3.64">   this.parts = [];</span>
<a href="#l3.65"></a><span id="l3.65"> }</span>
<a href="#l3.66"></a><span id="l3.66"> </span>
<a href="#l3.67"></a><span id="l3.67"> MimeMessage.prototype = {</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineat">@@ -248,16 +259,48 @@ MimeMessage.prototype = {</span>
<a href="#l3.69"></a><span id="l3.69">   get allAttachments() {</span>
<a href="#l3.70"></a><span id="l3.70">     let results = []; // messages are not attachments, don't include self</span>
<a href="#l3.71"></a><span id="l3.71">     for (let iChild = 0; iChild &lt; this.parts.length; iChild++) {</span>
<a href="#l3.72"></a><span id="l3.72">       let child = this.parts[iChild];</span>
<a href="#l3.73"></a><span id="l3.73">       results = results.concat(child.allAttachments);</span>
<a href="#l3.74"></a><span id="l3.74">     }</span>
<a href="#l3.75"></a><span id="l3.75">     return results;</span>
<a href="#l3.76"></a><span id="l3.76">   },</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineplus">+  </span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+  /**</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineplus">+   * @return a list of all of the plaintext body parts of this message.</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineplus">+   */</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineplus">+  get bodyPartsPlain() {</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineplus">+    return [part for each ([, part] in Iterator(this.bodyParts)) if</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineplus">+            (part.contentType == &quot;text/plain&quot;)];</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineplus">+  },</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineplus">+  /**</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineplus">+   * @return all of the plaintext body parts of this message, concatenated</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineplus">+   *  together into a single string.</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineplus">+   */</span>
<a href="#l3.89"></a><span id="l3.89" class="difflineplus">+  get bodyPlain() {</span>
<a href="#l3.90"></a><span id="l3.90" class="difflineplus">+    return [bodyPart.body for each</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+            ([, bodyPart] in Iterator(this.bodyPartsPlain))].join(&quot;&quot;);</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineplus">+  },</span>
<a href="#l3.93"></a><span id="l3.93" class="difflineplus">+  /**</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineplus">+   * @return a list of all of the HTML body parts of this message.</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineplus">+   */</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineplus">+  get bodyPartsHTML() {</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineplus">+    return [part for each ([, part] in Iterator(this.bodyParts)) if</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineplus">+        (part.contentType == &quot;text/html&quot;)];</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineplus">+  },</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineplus">+  /**</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineplus">+   * @return all of the HTML body parts of this message, concatenated together</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineplus">+   *  into a single string.</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineplus">+   */</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineplus">+  get bodyHTML() {</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineplus">+    return [bodyPart.body for each</span>
<a href="#l3.106"></a><span id="l3.106" class="difflineplus">+            ([, bodyPart] in Iterator(this.bodyPartsHTML))].join(&quot;&quot;);</span>
<a href="#l3.107"></a><span id="l3.107" class="difflineplus">+  },</span>
<a href="#l3.108"></a><span id="l3.108" class="difflineplus">+  </span>
<a href="#l3.109"></a><span id="l3.109">   /**</span>
<a href="#l3.110"></a><span id="l3.110">    * Convert the message and its hierarchy into a &quot;pretty string&quot;.  The message</span>
<a href="#l3.111"></a><span id="l3.111">    *  and each MIME part get their own line.  The string never ends with a</span>
<a href="#l3.112"></a><span id="l3.112">    *  newline.  For a non-multi-part message, only a single line will be</span>
<a href="#l3.113"></a><span id="l3.113">    *  returned.</span>
<a href="#l3.114"></a><span id="l3.114">    * Messages have their subject displayed, attachments have their filename and</span>
<a href="#l3.115"></a><span id="l3.115">    *  content-type (ex: image/jpeg) displayed.  &quot;Filler&quot; classes simply have</span>
<a href="#l3.116"></a><span id="l3.116">    *  their class displayed.</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineat">@@ -273,57 +316,117 @@ MimeMessage.prototype = {</span>
<a href="#l3.118"></a><span id="l3.118">       let part = this.parts[iPart];</span>
<a href="#l3.119"></a><span id="l3.119">       s += &quot;\n&quot; + nextIndent + (iPart+1) + &quot; &quot; + part.prettyString(nextIndent);</span>
<a href="#l3.120"></a><span id="l3.120">     }</span>
<a href="#l3.121"></a><span id="l3.121">     </span>
<a href="#l3.122"></a><span id="l3.122">     return s;</span>
<a href="#l3.123"></a><span id="l3.123">   },</span>
<a href="#l3.124"></a><span id="l3.124"> };</span>
<a href="#l3.125"></a><span id="l3.125"> </span>
<a href="#l3.126"></a><span id="l3.126" class="difflineminus">-function MimeContainer(aPartName) {</span>
<a href="#l3.127"></a><span id="l3.127" class="difflineminus">-  this.partName = aPartName;</span>
<a href="#l3.128"></a><span id="l3.128" class="difflineplus">+/**</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineplus">+ * @ivar contentType The content-type of this container.</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineplus">+ * @ivar parts The parts held by this container.  These can be instances of any</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineplus">+ *      of the classes found in this file.</span>
<a href="#l3.132"></a><span id="l3.132" class="difflineplus">+ */</span>
<a href="#l3.133"></a><span id="l3.133" class="difflineplus">+function MimeContainer(aContentType) {</span>
<a href="#l3.134"></a><span id="l3.134" class="difflineplus">+  this.partName = null;</span>
<a href="#l3.135"></a><span id="l3.135" class="difflineplus">+  this.contentType = aContentType;</span>
<a href="#l3.136"></a><span id="l3.136">   this.parts = [];</span>
<a href="#l3.137"></a><span id="l3.137"> }</span>
<a href="#l3.138"></a><span id="l3.138"> </span>
<a href="#l3.139"></a><span id="l3.139"> MimeContainer.prototype = {</span>
<a href="#l3.140"></a><span id="l3.140">   get allAttachments() {</span>
<a href="#l3.141"></a><span id="l3.141">     let results = [];</span>
<a href="#l3.142"></a><span id="l3.142">     for (let iChild = 0; iChild &lt; this.parts.length; iChild++) {</span>
<a href="#l3.143"></a><span id="l3.143">       let child = this.parts[iChild];</span>
<a href="#l3.144"></a><span id="l3.144">       results = results.concat(child.allAttachments);</span>
<a href="#l3.145"></a><span id="l3.145">     }</span>
<a href="#l3.146"></a><span id="l3.146">     return results;</span>
<a href="#l3.147"></a><span id="l3.147">   },</span>
<a href="#l3.148"></a><span id="l3.148">   prettyString: function MimeContainer_prettyString(aIndent) {</span>
<a href="#l3.149"></a><span id="l3.149">     let nextIndent = aIndent + &quot;  &quot;;</span>
<a href="#l3.150"></a><span id="l3.150">   </span>
<a href="#l3.151"></a><span id="l3.151" class="difflineminus">-    let s = &quot;Container&quot;;</span>
<a href="#l3.152"></a><span id="l3.152" class="difflineplus">+    let s = &quot;Container: &quot; + this.contentType;</span>
<a href="#l3.153"></a><span id="l3.153">     </span>
<a href="#l3.154"></a><span id="l3.154">     for (let iPart = 0; iPart &lt; this.parts.length; iPart++) {</span>
<a href="#l3.155"></a><span id="l3.155">       let part = this.parts[iPart];</span>
<a href="#l3.156"></a><span id="l3.156">       s += &quot;\n&quot; + nextIndent + (iPart+1) + &quot; &quot; + part.prettyString(nextIndent);</span>
<a href="#l3.157"></a><span id="l3.157">     }</span>
<a href="#l3.158"></a><span id="l3.158">     </span>
<a href="#l3.159"></a><span id="l3.159">     return s;</span>
<a href="#l3.160"></a><span id="l3.160">   },</span>
<a href="#l3.161"></a><span id="l3.161" class="difflineplus">+  toString: function MimeContainer_toString() {</span>
<a href="#l3.162"></a><span id="l3.162" class="difflineplus">+    return &quot;Container: &quot; + this.contentType;</span>
<a href="#l3.163"></a><span id="l3.163" class="difflineplus">+  }</span>
<a href="#l3.164"></a><span id="l3.164" class="difflineplus">+}</span>
<a href="#l3.165"></a><span id="l3.165" class="difflineplus">+</span>
<a href="#l3.166"></a><span id="l3.166" class="difflineplus">+/**</span>
<a href="#l3.167"></a><span id="l3.167" class="difflineplus">+ * @class Represents a body portion that we understand and do not believe to be</span>
<a href="#l3.168"></a><span id="l3.168" class="difflineplus">+ *  a proper attachment.  This means text/plain or text/html and it has no</span>
<a href="#l3.169"></a><span id="l3.169" class="difflineplus">+ *  filename.  (A filename suggests an attachment.)</span>
<a href="#l3.170"></a><span id="l3.170" class="difflineplus">+ *  </span>
<a href="#l3.171"></a><span id="l3.171" class="difflineplus">+ * @ivar contentType The content type of this body materal; text/plain or</span>
<a href="#l3.172"></a><span id="l3.172" class="difflineplus">+ *     text/html.</span>
<a href="#l3.173"></a><span id="l3.173" class="difflineplus">+ * @ivar body The actual body content.</span>
<a href="#l3.174"></a><span id="l3.174" class="difflineplus">+ */</span>
<a href="#l3.175"></a><span id="l3.175" class="difflineplus">+function MimeBody(aContentType, aIsPart) {</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineplus">+  this.partName = null;</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineplus">+  this.contentType = aContentType;</span>
<a href="#l3.178"></a><span id="l3.178" class="difflineplus">+  this.isPart = aIsPart;</span>
<a href="#l3.179"></a><span id="l3.179" class="difflineplus">+  this.body = &quot;&quot;;</span>
<a href="#l3.180"></a><span id="l3.180"> }</span>
<a href="#l3.181"></a><span id="l3.181"> </span>
<a href="#l3.182"></a><span id="l3.182" class="difflineminus">-function MimeUnknown(aPartName) {</span>
<a href="#l3.183"></a><span id="l3.183" class="difflineminus">-  this.partName = aPartName;</span>
<a href="#l3.184"></a><span id="l3.184" class="difflineplus">+MimeBody.prototype = {</span>
<a href="#l3.185"></a><span id="l3.185" class="difflineplus">+  get allAttachments() {</span>
<a href="#l3.186"></a><span id="l3.186" class="difflineplus">+    return []; // we are a leaf</span>
<a href="#l3.187"></a><span id="l3.187" class="difflineplus">+  },</span>
<a href="#l3.188"></a><span id="l3.188" class="difflineplus">+  prettyString: function MimeBody_prettyString(aIndent) {</span>
<a href="#l3.189"></a><span id="l3.189" class="difflineplus">+    return &quot;Body: &quot; + this.contentType + &quot; (&quot; + this.body.length + &quot; bytes)&quot;;</span>
<a href="#l3.190"></a><span id="l3.190" class="difflineplus">+  },</span>
<a href="#l3.191"></a><span id="l3.191" class="difflineplus">+  toString: function MimeBody_toString() {</span>
<a href="#l3.192"></a><span id="l3.192" class="difflineplus">+    return &quot;Body: &quot; + this.contentType + &quot; (&quot; + this.body.length + &quot; bytes)&quot;;</span>
<a href="#l3.193"></a><span id="l3.193" class="difflineplus">+  }</span>
<a href="#l3.194"></a><span id="l3.194" class="difflineplus">+}</span>
<a href="#l3.195"></a><span id="l3.195" class="difflineplus">+</span>
<a href="#l3.196"></a><span id="l3.196" class="difflineplus">+/**</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineplus">+ * @class A MIME Leaf node that doesn't have a filename so we assume it's not</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineplus">+ *  intended to be an attachment proper.  This is probably meant for inline</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineplus">+ *  display or is the result of someone amusing themselves by composing messages</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineplus">+ *  by hand or a bad client.  This class should probably be renamed or we should</span>
<a href="#l3.201"></a><span id="l3.201" class="difflineplus">+ *  introduce a better named class that we try and use in preference to this</span>
<a href="#l3.202"></a><span id="l3.202" class="difflineplus">+ *  class.</span>
<a href="#l3.203"></a><span id="l3.203" class="difflineplus">+ * </span>
<a href="#l3.204"></a><span id="l3.204" class="difflineplus">+ * @ivar contentType The content type of this part.</span>
<a href="#l3.205"></a><span id="l3.205" class="difflineplus">+ */</span>
<a href="#l3.206"></a><span id="l3.206" class="difflineplus">+function MimeUnknown(aContentType, aIsPart) {</span>
<a href="#l3.207"></a><span id="l3.207" class="difflineplus">+  this.partName = null;</span>
<a href="#l3.208"></a><span id="l3.208" class="difflineplus">+  this.contentType = aContentType;</span>
<a href="#l3.209"></a><span id="l3.209" class="difflineplus">+  this.isPart = aIsPart;</span>
<a href="#l3.210"></a><span id="l3.210"> }</span>
<a href="#l3.211"></a><span id="l3.211"> </span>
<a href="#l3.212"></a><span id="l3.212"> MimeUnknown.prototype = {</span>
<a href="#l3.213"></a><span id="l3.213">   get allAttachments() {</span>
<a href="#l3.214"></a><span id="l3.214">     return []; // we are a leaf</span>
<a href="#l3.215"></a><span id="l3.215">   },</span>
<a href="#l3.216"></a><span id="l3.216">   prettyString: function MimeUnknown_prettyString(aIndent) {</span>
<a href="#l3.217"></a><span id="l3.217" class="difflineminus">-    return &quot;Unknown&quot;;</span>
<a href="#l3.218"></a><span id="l3.218" class="difflineplus">+    return &quot;Unknown: &quot; + this.contentType;</span>
<a href="#l3.219"></a><span id="l3.219">   },</span>
<a href="#l3.220"></a><span id="l3.220" class="difflineplus">+  toString: function MimeUnknown_toString() {</span>
<a href="#l3.221"></a><span id="l3.221" class="difflineplus">+    return &quot;Unknown: &quot; + this.contentType;</span>
<a href="#l3.222"></a><span id="l3.222" class="difflineplus">+  }</span>
<a href="#l3.223"></a><span id="l3.223"> }</span>
<a href="#l3.224"></a><span id="l3.224"> </span>
<a href="#l3.225"></a><span id="l3.225" class="difflineplus">+/**</span>
<a href="#l3.226"></a><span id="l3.226" class="difflineplus">+ * @class An attachment proper.  We think it's an attachment because it has a</span>
<a href="#l3.227"></a><span id="l3.227" class="difflineplus">+ *  filename that libmime was able to figure out.</span>
<a href="#l3.228"></a><span id="l3.228" class="difflineplus">+ * </span>
<a href="#l3.229"></a><span id="l3.229" class="difflineplus">+ * @ivar contentType The MIME content type of this part.</span>
<a href="#l3.230"></a><span id="l3.230" class="difflineplus">+ * @ivar The filename of this attachment.</span>
<a href="#l3.231"></a><span id="l3.231" class="difflineplus">+ * @ivar The URL to stream if you want the contents of this part.</span>
<a href="#l3.232"></a><span id="l3.232" class="difflineplus">+ */</span>
<a href="#l3.233"></a><span id="l3.233"> function MimeMessageAttachment(aPartName, aName, aContentType, aUrl,</span>
<a href="#l3.234"></a><span id="l3.234">                                aIsExternal) {</span>
<a href="#l3.235"></a><span id="l3.235">   this.partName = aPartName;</span>
<a href="#l3.236"></a><span id="l3.236">   this.name = aName;</span>
<a href="#l3.237"></a><span id="l3.237">   this.contentType = aContentType;</span>
<a href="#l3.238"></a><span id="l3.238">   this.url = aUrl;</span>
<a href="#l3.239"></a><span id="l3.239">   this.isExternal = aIsExternal;</span>
<a href="#l3.240"></a><span id="l3.240">   </span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

