<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 989:dde2741d963e2e3bb72e9c74b394d3661f22a8e4</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ dde2741d963e2e3bb72e9c74b394d3661f22a8e4" />
<meta property="og:url" content="/comm-central/rev/dde2741d963e2e3bb72e9c74b394d3661f22a8e4" />
<meta property="og:description" content="things are working with exptoolbar" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / dde2741d963e2e3bb72e9c74b394d3661f22a8e4 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/dde2741d963e2e3bb72e9c74b394d3661f22a8e4">shortlog</a> |
<a href="/comm-central/log/dde2741d963e2e3bb72e9c74b394d3661f22a8e4">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/dde2741d963e2e3bb72e9c74b394d3661f22a8e4">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/dde2741d963e2e3bb72e9c74b394d3661f22a8e4">files</a> |
changeset |
<a href="/comm-central/raw-rev/dde2741d963e2e3bb72e9c74b394d3661f22a8e4">raw</a>  | <a href="/comm-central/archive/dde2741d963e2e3bb72e9c74b394d3661f22a8e4.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
things are working with exptoolbar
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Fri, 24 Oct 2008 08:30:34 -0700</td></tr>

<tr>
 <td>changeset 989</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/dde2741d963e2e3bb72e9c74b394d3661f22a8e4">dde2741d963e2e3bb72e9c74b394d3661f22a8e4</a></td>
</tr>



<tr>
<td>parent 988</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/1be012dd374f93311ca7e932d922cffd55f0e961">1be012dd374f93311ca7e932d922cffd55f0e961</a>
</td>
</tr>

<tr>
<td>child 990</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/16c6a95db57ed5db0a990778ce6a93d64e7c11d9">16c6a95db57ed5db0a990778ce6a93d64e7c11d9</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=dde2741d963e2e3bb72e9c74b394d3661f22a8e4">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">things are working with exptoolbar</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/components/glautocomp.js">components/glautocomp.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/components/glautocomp.js">file</a> |
<a href="/comm-central/annotate/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/components/glautocomp.js">annotate</a> |
<a href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/components/glautocomp.js">diff</a> |
<a href="/comm-central/comparison/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/components/glautocomp.js">comparison</a> |
<a href="/comm-central/log/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/components/glautocomp.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/databind.js">modules/databind.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/databind.js">file</a> |
<a href="/comm-central/annotate/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/databind.js">annotate</a> |
<a href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/databind.js">diff</a> |
<a href="/comm-central/comparison/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/databind.js">comparison</a> |
<a href="/comm-central/log/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/databind.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/datamodel.js">modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/everybody.js">modules/everybody.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/everybody.js">file</a> |
<a href="/comm-central/annotate/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/everybody.js">annotate</a> |
<a href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/everybody.js">diff</a> |
<a href="/comm-central/comparison/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/everybody.js">comparison</a> |
<a href="/comm-central/log/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/everybody.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/fundattr.js">modules/fundattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/fundattr.js">file</a> |
<a href="/comm-central/annotate/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/fundattr.js">annotate</a> |
<a href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/fundattr.js">diff</a> |
<a href="/comm-central/comparison/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/fundattr.js">comparison</a> |
<a href="/comm-central/log/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/fundattr.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/indexer.js">modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/query.js">modules/query.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/query.js">file</a> |
<a href="/comm-central/annotate/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/query.js">annotate</a> |
<a href="/comm-central/diff/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/query.js">diff</a> |
<a href="/comm-central/comparison/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/query.js">comparison</a> |
<a href="/comm-central/log/dde2741d963e2e3bb72e9c74b394d3661f22a8e4/modules/query.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/components/glautocomp.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/components/glautocomp.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -182,16 +182,18 @@ const MAX_POPULAR_CONTACTS = 200;</span>
<a href="#l1.4"></a><span id="l1.4"> /**</span>
<a href="#l1.5"></a><span id="l1.5">  * Complete contacts/identities based on name/email.  Instant phase is based on</span>
<a href="#l1.6"></a><span id="l1.6">  *  a suffix-tree built of popular contacts/identities.  Delayed phase relies</span>
<a href="#l1.7"></a><span id="l1.7">  *  on a LIKE search of all known contacts.</span>
<a href="#l1.8"></a><span id="l1.8">  */</span>
<a href="#l1.9"></a><span id="l1.9"> function ContactIdentityCompleter() {</span>
<a href="#l1.10"></a><span id="l1.10">   // get all the contacts</span>
<a href="#l1.11"></a><span id="l1.11">   let contactQuery = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+dump(&quot;cq.ob: &quot; + contactQuery.orderBy + &quot;\n&quot;);</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+dump(&quot;cq.limit: &quot; + contactQuery.limit + &quot;\n&quot;);</span>
<a href="#l1.14"></a><span id="l1.14">   contactQuery.orderBy(&quot;-popularity&quot;).limit(MAX_POPULAR_CONTACTS);</span>
<a href="#l1.15"></a><span id="l1.15">   this.contactCollection = contactQuery.getCollection(this, null);</span>
<a href="#l1.16"></a><span id="l1.16"> }</span>
<a href="#l1.17"></a><span id="l1.17"> ContactIdentityCompleter.prototype = {</span>
<a href="#l1.18"></a><span id="l1.18">   _popularitySorter: function(a, b){ return b.popularity - a.popularity; },</span>
<a href="#l1.19"></a><span id="l1.19">   complete: function ContactIdentityCompleter_complete(aResult, aString) {</span>
<a href="#l1.20"></a><span id="l1.20">     if (aString.length &lt; 3)</span>
<a href="#l1.21"></a><span id="l1.21">       return false;</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineat">@@ -372,23 +374,26 @@ MessageTagCompleter.prototype = {</span>
<a href="#l1.23"></a><span id="l1.23">   complete: function MessageTagCompleter_complete(aResult, aString) {</span>
<a href="#l1.24"></a><span id="l1.24">     return false;</span>
<a href="#l1.25"></a><span id="l1.25">   }</span>
<a href="#l1.26"></a><span id="l1.26"> };</span>
<a href="#l1.27"></a><span id="l1.27"> </span>
<a href="#l1.28"></a><span id="l1.28"> function nsAutoCompleteGloda() {</span>
<a href="#l1.29"></a><span id="l1.29">   this.wrappedJSObject = this;</span>
<a href="#l1.30"></a><span id="l1.30"> </span>
<a href="#l1.31"></a><span id="l1.31" class="difflineplus">+dump(&quot;imports...\n&quot;);</span>
<a href="#l1.32"></a><span id="l1.32">   // set up our awesome globals!</span>
<a href="#l1.33"></a><span id="l1.33">   if (Gloda === null) {</span>
<a href="#l1.34"></a><span id="l1.34">     let loadNS = {};</span>
<a href="#l1.35"></a><span id="l1.35"> </span>
<a href="#l1.36"></a><span id="l1.36" class="difflineplus">+dump(&quot;  public...\n&quot;);</span>
<a href="#l1.37"></a><span id="l1.37">     Cu.import(&quot;resource://gloda/modules/public.js&quot;, loadNS);</span>
<a href="#l1.38"></a><span id="l1.38">     Gloda = loadNS.Gloda;</span>
<a href="#l1.39"></a><span id="l1.39"> </span>
<a href="#l1.40"></a><span id="l1.40" class="difflineplus">+dump(&quot;  utils...\n&quot;);</span>
<a href="#l1.41"></a><span id="l1.41">     Cu.import(&quot;resource://gloda/modules/utils.js&quot;, loadNS);</span>
<a href="#l1.42"></a><span id="l1.42">     GlodaUtils = loadNS.GlodaUtils;</span>
<a href="#l1.43"></a><span id="l1.43">     Cu.import(&quot;resource://gloda/modules/suffixtree.js&quot;, loadNS);</span>
<a href="#l1.44"></a><span id="l1.44">     MultiSuffixTree = loadNS.MultiSuffixTree;</span>
<a href="#l1.45"></a><span id="l1.45">     Cu.import(&quot;resource://gloda/modules/noun_freetag.js&quot;, loadNS);</span>
<a href="#l1.46"></a><span id="l1.46">     FreeTagNoun = loadNS.FreeTagNoun;</span>
<a href="#l1.47"></a><span id="l1.47"> </span>
<a href="#l1.48"></a><span id="l1.48">     Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;, loadNS);</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineat">@@ -396,18 +401,26 @@ function nsAutoCompleteGloda() {</span>
<a href="#l1.50"></a><span id="l1.50">   }</span>
<a href="#l1.51"></a><span id="l1.51"> </span>
<a href="#l1.52"></a><span id="l1.52">   LOG.debug(&quot;initializing completers&quot;);</span>
<a href="#l1.53"></a><span id="l1.53"> </span>
<a href="#l1.54"></a><span id="l1.54">   this.completers = [];</span>
<a href="#l1.55"></a><span id="l1.55">   </span>
<a href="#l1.56"></a><span id="l1.56">   this.curResult = null;</span>
<a href="#l1.57"></a><span id="l1.57"> </span>
<a href="#l1.58"></a><span id="l1.58" class="difflineplus">+dump(&quot;init CIC\n&quot;);</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineplus">+  LOG.debug(&quot;initializing ContactIdentityCompleter&quot;);</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineplus">+  try {</span>
<a href="#l1.61"></a><span id="l1.61">   this.completers.push(new ContactIdentityCompleter());</span>
<a href="#l1.62"></a><span id="l1.62" class="difflineplus">+  } catch (ex) {dump(&quot;CICEX: &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);}</span>
<a href="#l1.63"></a><span id="l1.63" class="difflineplus">+dump(&quot;init CTC\n&quot;);</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineplus">+  LOG.debug(&quot;initializing ContactTagCompleter&quot;);</span>
<a href="#l1.65"></a><span id="l1.65">   this.completers.push(new ContactTagCompleter());</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineplus">+dump(&quot;init MTC\n&quot;);</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineplus">+  LOG.debug(&quot;initializing MessageTagCompleter&quot;);</span>
<a href="#l1.68"></a><span id="l1.68">   this.completers.push(new MessageTagCompleter());</span>
<a href="#l1.69"></a><span id="l1.69">   </span>
<a href="#l1.70"></a><span id="l1.70">   LOG.debug(&quot;initialized completers&quot;);</span>
<a href="#l1.71"></a><span id="l1.71"> }</span>
<a href="#l1.72"></a><span id="l1.72"> </span>
<a href="#l1.73"></a><span id="l1.73"> nsAutoCompleteGloda.prototype = {</span>
<a href="#l1.74"></a><span id="l1.74">   classDescription: &quot;AutoCompleteGloda&quot;,</span>
<a href="#l1.75"></a><span id="l1.75">   contractID: &quot;@mozilla.org/autocomplete/search;1?name=gloda&quot;,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/modules/databind.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/modules/databind.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -39,78 +39,108 @@ EXPORTED_SYMBOLS = [&quot;GlodaDatabind&quot;];</span>
<a href="#l2.4"></a><span id="l2.4"> </span>
<a href="#l2.5"></a><span id="l2.5"> const Cc = Components.classes;</span>
<a href="#l2.6"></a><span id="l2.6"> const Ci = Components.interfaces;</span>
<a href="#l2.7"></a><span id="l2.7"> const Cr = Components.results;</span>
<a href="#l2.8"></a><span id="l2.8"> const Cu = Components.utils;</span>
<a href="#l2.9"></a><span id="l2.9"> </span>
<a href="#l2.10"></a><span id="l2.10"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+function DatabindCallback(aDatabind, aCallbackThis, aCallback, aOneShot) {</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+  this._databind = aDatabind;</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+  this._callbackThis = aCallbackThis;</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+  this._callback = aCallback;</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+  this._oneShot = aOneShot;</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+}</span>
<a href="#l2.18"></a><span id="l2.18" class="difflineplus">+DatabindCallback.prototype = {</span>
<a href="#l2.19"></a><span id="l2.19" class="difflineplus">+  handleResult: function (aResultSet) {</span>
<a href="#l2.20"></a><span id="l2.20" class="difflineplus">+    let rows = [];</span>
<a href="#l2.21"></a><span id="l2.21" class="difflineplus">+    let rowResult;</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineplus">+    let getVariant = this._databind._datastore._getVariant;</span>
<a href="#l2.23"></a><span id="l2.23" class="difflineplus">+    while (rowResult = aResultSet.getNextRow()) {</span>
<a href="#l2.24"></a><span id="l2.24" class="difflineplus">+      let row = {};</span>
<a href="#l2.25"></a><span id="l2.25" class="difflineplus">+      for each (let [iCol, colDef] in</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineplus">+                Iterator(this._databind._tableDef.columns)) {</span>
<a href="#l2.27"></a><span id="l2.27" class="difflineplus">+        let colName = colDef[0];</span>
<a href="#l2.28"></a><span id="l2.28" class="difflineplus">+        row[colName] = getVariant(rowResult, iCol);</span>
<a href="#l2.29"></a><span id="l2.29" class="difflineplus">+      }</span>
<a href="#l2.30"></a><span id="l2.30" class="difflineplus">+      rows.push(row);</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+    }</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+    this._callback.call(this._callbackThis, rows, false);</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineplus">+  },</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+  handleError: function (aError) {</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+  },</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+  handleCompletion: function () {</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+    this._callback.call(this._callbackThis, [], true);</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+    this._databind._datastore._asyncCompleted();</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineplus">+  },</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineplus">+}</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineplus">+</span>
<a href="#l2.42"></a><span id="l2.42"> function GlodaDatabind(aTableDef, aDatastore) {</span>
<a href="#l2.43"></a><span id="l2.43">   this._tableDef = aTableDef;</span>
<a href="#l2.44"></a><span id="l2.44">   this._datastore = aDatastore;</span>
<a href="#l2.45"></a><span id="l2.45">   this._log = Log4Moz.Service.getLogger(&quot;gloda.databind.&quot; + aTableDef.name);</span>
<a href="#l2.46"></a><span id="l2.46">   </span>
<a href="#l2.47"></a><span id="l2.47">   let insertSql = &quot;INSERT INTO &quot; + this._tableDef._realName + &quot; (&quot; +</span>
<a href="#l2.48"></a><span id="l2.48">     [coldef[0] for each</span>
<a href="#l2.49"></a><span id="l2.49">      ([i, coldef] in Iterator(this._tableDef.columns))].join(&quot;, &quot;) +</span>
<a href="#l2.50"></a><span id="l2.50">     &quot;) VALUES (&quot; +</span>
<a href="#l2.51"></a><span id="l2.51">     [(&quot;:&quot; + coldef[0]) for each</span>
<a href="#l2.52"></a><span id="l2.52">      ([i, coldef] in Iterator(this._tableDef.columns))].join(&quot;, &quot;) +</span>
<a href="#l2.53"></a><span id="l2.53">     &quot;)&quot;;</span>
<a href="#l2.54"></a><span id="l2.54">   </span>
<a href="#l2.55"></a><span id="l2.55" class="difflineminus">-  this._insertStmt = aDatastore._createStatement(insertSql);</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+  this._insertStmt = aDatastore._createAsyncStatement(insertSql);</span>
<a href="#l2.57"></a><span id="l2.57">   </span>
<a href="#l2.58"></a><span id="l2.58">   this._stmtCache = {};</span>
<a href="#l2.59"></a><span id="l2.59"> }</span>
<a href="#l2.60"></a><span id="l2.60"> </span>
<a href="#l2.61"></a><span id="l2.61"> GlodaDatabind.prototype = {</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineminus">-  </span>
<a href="#l2.63"></a><span id="l2.63" class="difflineplus">+  /*</span>
<a href="#l2.64"></a><span id="l2.64">   getHighId: function(aLessThan) {</span>
<a href="#l2.65"></a><span id="l2.65">     let sql = &quot;select MAX(id) AS m_id FROM &quot; + this._tableDef._realName;</span>
<a href="#l2.66"></a><span id="l2.66">     if (aLessThan !== undefined)</span>
<a href="#l2.67"></a><span id="l2.67">       sql += &quot; WHERE id &lt; &quot; + aLessThan;</span>
<a href="#l2.68"></a><span id="l2.68">   dump(&quot;SQL: &quot; + sql);</span>
<a href="#l2.69"></a><span id="l2.69">     let stmt = this._datastore._createStatement(sql);</span>
<a href="#l2.70"></a><span id="l2.70">   dump(&quot;created\n&quot;);</span>
<a href="#l2.71"></a><span id="l2.71">     let highId = 0;</span>
<a href="#l2.72"></a><span id="l2.72">     if (stmt.step()) {</span>
<a href="#l2.73"></a><span id="l2.73">       dump(&quot;stepped, retrieving\n&quot;);</span>
<a href="#l2.74"></a><span id="l2.74">       highId = stmt.row[&quot;m_id&quot;];</span>
<a href="#l2.75"></a><span id="l2.75">     }</span>
<a href="#l2.76"></a><span id="l2.76">     stmt.reset();</span>
<a href="#l2.77"></a><span id="l2.77">     </span>
<a href="#l2.78"></a><span id="l2.78">     return highId;</span>
<a href="#l2.79"></a><span id="l2.79">   },</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineminus">-  </span>
<a href="#l2.81"></a><span id="l2.81" class="difflineminus">-  selectOne: function(aColName, aColValue) {</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineplus">+  */</span>
<a href="#l2.83"></a><span id="l2.83" class="difflineplus">+    </span>
<a href="#l2.84"></a><span id="l2.84" class="difflineplus">+  select: function(aColName, aColValue, aCallbackThis, aCallback) {</span>
<a href="#l2.85"></a><span id="l2.85">     let stmt;</span>
<a href="#l2.86"></a><span id="l2.86">     if (!(aColName in this._stmtCache)) {</span>
<a href="#l2.87"></a><span id="l2.87" class="difflineminus">-      stmt = this._datastore._createStatement(&quot;SELECT * FROM &quot; +</span>
<a href="#l2.88"></a><span id="l2.88" class="difflineminus">-        this._tableDef._realName + &quot; WHERE &quot; + aColName + &quot; = :value&quot;);</span>
<a href="#l2.89"></a><span id="l2.89" class="difflineplus">+      let sqlString = &quot;SELECT * FROM &quot; + this._tableDef._realName;</span>
<a href="#l2.90"></a><span id="l2.90" class="difflineplus">+      if (aColName)</span>
<a href="#l2.91"></a><span id="l2.91" class="difflineplus">+        sqlString += &quot; WHERE &quot; + aColName + &quot; = :value&quot;;</span>
<a href="#l2.92"></a><span id="l2.92" class="difflineplus">+      stmt = this._datastore._createAsyncStatement(sqlString);</span>
<a href="#l2.93"></a><span id="l2.93">       this._stmtCache[aColName] = stmt;</span>
<a href="#l2.94"></a><span id="l2.94">     }</span>
<a href="#l2.95"></a><span id="l2.95">     else</span>
<a href="#l2.96"></a><span id="l2.96">       stmt = this._stmtCache[aColName];</span>
<a href="#l2.97"></a><span id="l2.97">     </span>
<a href="#l2.98"></a><span id="l2.98" class="difflineplus">+    if (aColName)</span>
<a href="#l2.99"></a><span id="l2.99" class="difflineplus">+      this._datastore._bindVariant(stmt, 0, aColValue);</span>
<a href="#l2.100"></a><span id="l2.100">     // so, we're tricky-like and lazy and actually return the row, so we don't</span>
<a href="#l2.101"></a><span id="l2.101">     //  want to reset until the user tries to use the statement again, as I</span>
<a href="#l2.102"></a><span id="l2.102">     //  fear we would otherwise lose our awesome row binding (and have to copy</span>
<a href="#l2.103"></a><span id="l2.103">     //  it, etc.)</span>
<a href="#l2.104"></a><span id="l2.104" class="difflineminus">-    stmt.reset();</span>
<a href="#l2.105"></a><span id="l2.105" class="difflineminus">-    </span>
<a href="#l2.106"></a><span id="l2.106" class="difflineminus">-    stmt.params.value = aColValue;</span>
<a href="#l2.107"></a><span id="l2.107" class="difflineminus">-    let row = null;</span>
<a href="#l2.108"></a><span id="l2.108" class="difflineminus">-    if (stmt.step())</span>
<a href="#l2.109"></a><span id="l2.109" class="difflineminus">-      row = stmt.row;</span>
<a href="#l2.110"></a><span id="l2.110" class="difflineminus">-    </span>
<a href="#l2.111"></a><span id="l2.111" class="difflineminus">-    return row;</span>
<a href="#l2.112"></a><span id="l2.112" class="difflineplus">+    stmt.executeAsync(new DatabindCallback(this, aCallbackThis, aCallback));</span>
<a href="#l2.113"></a><span id="l2.113">   },</span>
<a href="#l2.114"></a><span id="l2.114">   </span>
<a href="#l2.115"></a><span id="l2.115" class="difflineminus">-  insert: function(aValueDict) {</span>
<a href="#l2.116"></a><span id="l2.116" class="difflineplus">+  insert: function(aValueDicts) {</span>
<a href="#l2.117"></a><span id="l2.117">     let stmt = this._insertStmt;</span>
<a href="#l2.118"></a><span id="l2.118" class="difflineminus">-    for each (let [iColDef, colDef] in Iterator(this._tableDef.columns)) {</span>
<a href="#l2.119"></a><span id="l2.119" class="difflineminus">-      this._log.debug(&quot;insert arg: &quot; + colDef[0] + &quot;=&quot; + aValueDict[colDef[0]]);</span>
<a href="#l2.120"></a><span id="l2.120" class="difflineminus">-      stmt.params[colDef[0]] = aValueDict[colDef[0]];</span>
<a href="#l2.121"></a><span id="l2.121" class="difflineplus">+    for each (let [,valueDict] in Iterator(aValueDicts)) {</span>
<a href="#l2.122"></a><span id="l2.122" class="difflineplus">+      for each (let [iColDef, colDef] in Iterator(this._tableDef.columns)) {</span>
<a href="#l2.123"></a><span id="l2.123" class="difflineplus">+        this._log.debug(&quot;insert arg: &quot; + colDef[0] + &quot;=&quot; + valueDict[colDef[0]]);</span>
<a href="#l2.124"></a><span id="l2.124" class="difflineplus">+        stmt.params[colDef[0]] = valueDict[colDef[0]];</span>
<a href="#l2.125"></a><span id="l2.125" class="difflineplus">+      }</span>
<a href="#l2.126"></a><span id="l2.126" class="difflineplus">+      stmt.executeAsync(this._datastore.trackAsync());</span>
<a href="#l2.127"></a><span id="l2.127">     }</span>
<a href="#l2.128"></a><span id="l2.128" class="difflineminus">-    stmt.execute();</span>
<a href="#l2.129"></a><span id="l2.129">   }</span>
<a href="#l2.130"></a><span id="l2.130"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/modules/datamodel.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/modules/datamodel.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -118,23 +118,23 @@ GlodaAttributeDBDef.prototype = {</span>
<a href="#l3.4"></a><span id="l3.4">       }</span>
<a href="#l3.5"></a><span id="l3.5">       else {</span>
<a href="#l3.6"></a><span id="l3.6">         return [[this._id, nounDef.toParamAndValue(aInstanceValues)[1]]];</span>
<a href="#l3.7"></a><span id="l3.7">       }</span>
<a href="#l3.8"></a><span id="l3.8">     }</span>
<a href="#l3.9"></a><span id="l3.9">     else {</span>
<a href="#l3.10"></a><span id="l3.10">       let dbAttributes = [];</span>
<a href="#l3.11"></a><span id="l3.11">       if (nounDef.usesParameter) {</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-        for each (let [iValue, instanceValue] in Iterator(aInstanceValues)) {</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+        for each (let [, instanceValue] in Iterator(aInstanceValues)) {</span>
<a href="#l3.14"></a><span id="l3.14">           let [param, dbValue] = nounDef.toParamAndValue(aInstanceValues);</span>
<a href="#l3.15"></a><span id="l3.15">           dbAttributes.push([this.bindParameter(param), dbValue]);</span>
<a href="#l3.16"></a><span id="l3.16">         }</span>
<a href="#l3.17"></a><span id="l3.17">       }</span>
<a href="#l3.18"></a><span id="l3.18">       else {</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineminus">-        for each (let [iValue, instanceValue] in Iterator(aInstanceValues)) {</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+        for each (let [, instanceValue] in Iterator(aInstanceValues)) {</span>
<a href="#l3.21"></a><span id="l3.21">           dbAttributes.push([this._id,</span>
<a href="#l3.22"></a><span id="l3.22">                              nounDef.toParamAndValue(instanceValue)[1]]);</span>
<a href="#l3.23"></a><span id="l3.23">         }</span>
<a href="#l3.24"></a><span id="l3.24">       }</span>
<a href="#l3.25"></a><span id="l3.25">       return dbAttributes;</span>
<a href="#l3.26"></a><span id="l3.26">     }</span>
<a href="#l3.27"></a><span id="l3.27">   },</span>
<a href="#l3.28"></a><span id="l3.28"> </span>
<a href="#l3.29"></a><span id="l3.29" class="difflineat">@@ -195,17 +195,17 @@ GlodaConversation.prototype = {</span>
<a href="#l3.30"></a><span id="l3.30">   get id() { return this._id; },</span>
<a href="#l3.31"></a><span id="l3.31">   get subject() { return this._subject; },</span>
<a href="#l3.32"></a><span id="l3.32">   get oldestMessageDate() { return this._oldestMessageDate; },</span>
<a href="#l3.33"></a><span id="l3.33">   get newestMessageDate() { return this._newestMessageDate; },</span>
<a href="#l3.34"></a><span id="l3.34">   </span>
<a href="#l3.35"></a><span id="l3.35">   getMessagesCollection: function gloda_conversation_getMessagesCollection(</span>
<a href="#l3.36"></a><span id="l3.36">     aListener, aData) {</span>
<a href="#l3.37"></a><span id="l3.37">     let query = new GlodaMessage.prototype.NOUN_DEF.queryClass();</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineminus">-    query.conversation(this._id);</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+    query.conversation(this._id).orderBy(&quot;date&quot;);</span>
<a href="#l3.40"></a><span id="l3.40">     return query.getCollection(aListener, aData);</span>
<a href="#l3.41"></a><span id="l3.41">   },</span>
<a href="#l3.42"></a><span id="l3.42"> </span>
<a href="#l3.43"></a><span id="l3.43">   toString: function gloda_conversation_toString() {</span>
<a href="#l3.44"></a><span id="l3.44">     return &quot;Conversation:&quot; + this._id;</span>
<a href="#l3.45"></a><span id="l3.45">   },</span>
<a href="#l3.46"></a><span id="l3.46"> };</span>
<a href="#l3.47"></a><span id="l3.47"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -86,25 +86,28 @@ MessagesByMessageIdCallback.prototype = </span>
<a href="#l4.4"></a><span id="l4.4">   onQueryCompleted: function gloda_ds_mbmi_onQueryCompleted(aCollection) {</span>
<a href="#l4.5"></a><span id="l4.5">     MBM_LOG.debug(&quot;query completed, notifying... &quot; + this.results);</span>
<a href="#l4.6"></a><span id="l4.6">     // we no longer need to unify; it is done for us.</span>
<a href="#l4.7"></a><span id="l4.7"> </span>
<a href="#l4.8"></a><span id="l4.8">     this.callback.call(this.callbackThis, this.results);</span>
<a href="#l4.9"></a><span id="l4.9">   }</span>
<a href="#l4.10"></a><span id="l4.10"> };</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+let PCH_LOG = Log4Moz.Service.getLogger(&quot;gloda.ds.pch&quot;);</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+</span>
<a href="#l4.14"></a><span id="l4.14"> function PostCommitHandler(aCallbacks) {</span>
<a href="#l4.15"></a><span id="l4.15">   this.callbacks = aCallbacks;</span>
<a href="#l4.16"></a><span id="l4.16"> }</span>
<a href="#l4.17"></a><span id="l4.17"> </span>
<a href="#l4.18"></a><span id="l4.18"> PostCommitHandler.prototype = {</span>
<a href="#l4.19"></a><span id="l4.19">   handleResult: function gloda_ds_pch_handleResult(aResultSet) {</span>
<a href="#l4.20"></a><span id="l4.20">   },</span>
<a href="#l4.21"></a><span id="l4.21">   </span>
<a href="#l4.22"></a><span id="l4.22">   handleError: function gloda_ds_pch_handleError(aError) {</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineplus">+    PCH_LOG.error(&quot;database error:&quot; + aError)</span>
<a href="#l4.24"></a><span id="l4.24">   },</span>
<a href="#l4.25"></a><span id="l4.25">   </span>
<a href="#l4.26"></a><span id="l4.26">   handleCompletion: function gloda_ds_pch_handleCompletion(aReason) {</span>
<a href="#l4.27"></a><span id="l4.27">     if (aReason == Ci.mozIStorageStatementCallback.REASON_FINISHED) {</span>
<a href="#l4.28"></a><span id="l4.28">       for each (let [iCallback, callback] in Iterator(this.callbacks)) {</span>
<a href="#l4.29"></a><span id="l4.29">         try {</span>
<a href="#l4.30"></a><span id="l4.30">           callback();</span>
<a href="#l4.31"></a><span id="l4.31">         }</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineat">@@ -136,17 +139,17 @@ let QueryFromQueryResolver = {</span>
<a href="#l4.33"></a><span id="l4.33">     }</span>
<a href="#l4.34"></a><span id="l4.34">     </span>
<a href="#l4.35"></a><span id="l4.35">     let referencesByNounID = originColl.masterCollection.referencesByNounID;</span>
<a href="#l4.36"></a><span id="l4.36">     let inverseReferencesByNounID = </span>
<a href="#l4.37"></a><span id="l4.37">       originColl.masterCollection.inverseReferencesByNounID;</span>
<a href="#l4.38"></a><span id="l4.38"> </span>
<a href="#l4.39"></a><span id="l4.39">     if (originColl.pendingItems) {</span>
<a href="#l4.40"></a><span id="l4.40">       for (let [, item] in Iterator(originColl.pendingItems)) {</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineminus">-        QFQ_LOG.debug(&quot;QFQR: loading deferred &quot; + item.NOUN_ID + &quot;:&quot; + item.id);</span>
<a href="#l4.42"></a><span id="l4.42" class="difflineplus">+        //QFQ_LOG.debug(&quot;QFQR: loading deferred &quot; + item.NOUN_ID + &quot;:&quot; + item.id);</span>
<a href="#l4.43"></a><span id="l4.43">         GlodaDatastore.loadNounDeferredDeps(item, referencesByNounID,</span>
<a href="#l4.44"></a><span id="l4.44">             inverseReferencesByNounID);</span>
<a href="#l4.45"></a><span id="l4.45">       }</span>
<a href="#l4.46"></a><span id="l4.46">       </span>
<a href="#l4.47"></a><span id="l4.47">       // we need to consider the possibility that we are racing a collection very</span>
<a href="#l4.48"></a><span id="l4.48">       //  much like our own.  as such, this means we need to perform cache</span>
<a href="#l4.49"></a><span id="l4.49">       //  unification as our last step.</span>
<a href="#l4.50"></a><span id="l4.50">       GlodaCollectionManager.cacheLoadUnify(originColl._nounDef.id,</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineat">@@ -219,34 +222,33 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l4.52"></a><span id="l4.52">     let row;</span>
<a href="#l4.53"></a><span id="l4.53">     let nounDef = this.nounDef;</span>
<a href="#l4.54"></a><span id="l4.54">     let nounID = nounDef.id;</span>
<a href="#l4.55"></a><span id="l4.55">     while (row = aResultSet.getNextRow()) {</span>
<a href="#l4.56"></a><span id="l4.56">       let item = nounDef.objFromRow.call(nounDef.datastore, row);</span>
<a href="#l4.57"></a><span id="l4.57">       // try and replace the item with one from the cache, if we can</span>
<a href="#l4.58"></a><span id="l4.58">       let cachedItem = GlodaCollectionManager.cacheLookupOne(nounID, item.id,</span>
<a href="#l4.59"></a><span id="l4.59">                                                              false);</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineminus">-      QFQ_LOG.debug(&quot;loading item &quot; + nounDef.id + &quot;:&quot; + item.id + &quot; existing: &quot; +</span>
<a href="#l4.61"></a><span id="l4.61" class="difflineminus">-          this.selfReferences[item.id] + &quot; cached: &quot; + cachedItem);</span>
<a href="#l4.62"></a><span id="l4.62" class="difflineplus">+      //QFQ_LOG.debug(&quot;loading item &quot; + nounDef.id + &quot;:&quot; + item.id + &quot; existing: &quot; +</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineplus">+      //    this.selfReferences[item.id] + &quot; cached: &quot; + cachedItem);</span>
<a href="#l4.64"></a><span id="l4.64">       if (cachedItem)</span>
<a href="#l4.65"></a><span id="l4.65">         item = cachedItem;</span>
<a href="#l4.66"></a><span id="l4.66">       // we may already have been loaded by this process</span>
<a href="#l4.67"></a><span id="l4.67">       else if (this.selfReferences[item.id] != null)</span>
<a href="#l4.68"></a><span id="l4.68">         item = this.selfReferences[item.id];</span>
<a href="#l4.69"></a><span id="l4.69">       // perform loading logic which may produce reference dependencies</span>
<a href="#l4.70"></a><span id="l4.70">       else</span>
<a href="#l4.71"></a><span id="l4.71">         this.needsLoads = </span>
<a href="#l4.72"></a><span id="l4.72">           GlodaDatastore.loadNounItem(item, this.referencesByNounID,</span>
<a href="#l4.73"></a><span id="l4.73">                                       this.inverseReferencesByNounID) ||</span>
<a href="#l4.74"></a><span id="l4.74">           this.needsLoads;</span>
<a href="#l4.75"></a><span id="l4.75">       </span>
<a href="#l4.76"></a><span id="l4.76">       // add ourself to the references by our id</span>
<a href="#l4.77"></a><span id="l4.77" class="difflineminus">-QFQ_LOG.debug(&quot;saving item &quot; + nounDef.id + &quot;:&quot; + item.id + &quot; to self-refs&quot;);</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineplus">+//QFQ_LOG.debug(&quot;saving item &quot; + nounDef.id + &quot;:&quot; + item.id + &quot; to self-refs&quot;);</span>
<a href="#l4.79"></a><span id="l4.79">       this.selfReferences[item.id] = item;</span>
<a href="#l4.80"></a><span id="l4.80" class="difflineminus">-QFQ_LOG.info(&quot;self-refs: &quot;+ Log4Moz.enumerateProperties(this.selfReferences).join(&quot;,&quot;));</span>
<a href="#l4.81"></a><span id="l4.81">       </span>
<a href="#l4.82"></a><span id="l4.82">       // if we're tracking it, add ourselves to our parent's list of children</span>
<a href="#l4.83"></a><span id="l4.83">       //  too</span>
<a href="#l4.84"></a><span id="l4.84">       if (this.selfInverseReferences) {</span>
<a href="#l4.85"></a><span id="l4.85">         let parentID = item[nounDef.parentColumnAttr.idStorageAttributeName];</span>
<a href="#l4.86"></a><span id="l4.86">         let childrenList = this.selfInverseReferences[parentID];</span>
<a href="#l4.87"></a><span id="l4.87">         if (childrenList === undefined)</span>
<a href="#l4.88"></a><span id="l4.88">           childrenList = this.selfInverseReferences[parentID] = [];</span>
<a href="#l4.89"></a><span id="l4.89" class="difflineat">@@ -354,26 +356,29 @@ QFQ_LOG.info(&quot;self-refs: &quot;+ Log4Moz.enum</span>
<a href="#l4.90"></a><span id="l4.90">       this.collection.deferredCount--;</span>
<a href="#l4.91"></a><span id="l4.91">       this.collection.resolvedCount++;</span>
<a href="#l4.92"></a><span id="l4.92">     }</span>
<a href="#l4.93"></a><span id="l4.93">     </span>
<a href="#l4.94"></a><span id="l4.94">     QFQ_LOG.debug(&quot;  defer: &quot; + this.collection.deferredCount +</span>
<a href="#l4.95"></a><span id="l4.95">                   &quot; resolved: &quot; + this.collection.resolvedCount);</span>
<a href="#l4.96"></a><span id="l4.96">     </span>
<a href="#l4.97"></a><span id="l4.97">     // process immediately and kick-up to the master collection...</span>
<a href="#l4.98"></a><span id="l4.98" class="difflineminus">-    if (this.collection.deferredCount &lt;= 0) {</span>
<a href="#l4.99"></a><span id="l4.99" class="difflineminus">-      // this guy will resolve everyone using referencesByNounID and issue the</span>
<a href="#l4.100"></a><span id="l4.100" class="difflineminus">-      //  call to this.collection._onItemsAdded to propagate things to the</span>
<a href="#l4.101"></a><span id="l4.101" class="difflineminus">-      //  next concerned subCollection or the actual listener if this is the</span>
<a href="#l4.102"></a><span id="l4.102" class="difflineminus">-      //  master collection.  (Also, call _onQueryCompleted).</span>
<a href="#l4.103"></a><span id="l4.103" class="difflineminus">-      QueryFromQueryResolver.onItemsAdded(null, {data: this.collection}, true);</span>
<a href="#l4.104"></a><span id="l4.104" class="difflineminus">-      QueryFromQueryResolver.onQueryCompleted({data: this.collection});</span>
<a href="#l4.105"></a><span id="l4.105" class="difflineplus">+    try {</span>
<a href="#l4.106"></a><span id="l4.106" class="difflineplus">+      if (this.collection.deferredCount &lt;= 0) {</span>
<a href="#l4.107"></a><span id="l4.107" class="difflineplus">+        // this guy will resolve everyone using referencesByNounID and issue the</span>
<a href="#l4.108"></a><span id="l4.108" class="difflineplus">+        //  call to this.collection._onItemsAdded to propagate things to the</span>
<a href="#l4.109"></a><span id="l4.109" class="difflineplus">+        //  next concerned subCollection or the actual listener if this is the</span>
<a href="#l4.110"></a><span id="l4.110" class="difflineplus">+        //  master collection.  (Also, call _onQueryCompleted).</span>
<a href="#l4.111"></a><span id="l4.111" class="difflineplus">+        QueryFromQueryResolver.onItemsAdded(null, {data: this.collection}, true);</span>
<a href="#l4.112"></a><span id="l4.112" class="difflineplus">+        QueryFromQueryResolver.onQueryCompleted({data: this.collection});</span>
<a href="#l4.113"></a><span id="l4.113" class="difflineplus">+      }</span>
<a href="#l4.114"></a><span id="l4.114">     }</span>
<a href="#l4.115"></a><span id="l4.115" class="difflineminus">-</span>
<a href="#l4.116"></a><span id="l4.116" class="difflineminus">-    GlodaDatastore._asyncCompleted();</span>
<a href="#l4.117"></a><span id="l4.117" class="difflineplus">+    finally {</span>
<a href="#l4.118"></a><span id="l4.118" class="difflineplus">+      GlodaDatastore._asyncCompleted();</span>
<a href="#l4.119"></a><span id="l4.119" class="difflineplus">+    }</span>
<a href="#l4.120"></a><span id="l4.120">   }</span>
<a href="#l4.121"></a><span id="l4.121"> };</span>
<a href="#l4.122"></a><span id="l4.122"> </span>
<a href="#l4.123"></a><span id="l4.123"> </span>
<a href="#l4.124"></a><span id="l4.124"> /**</span>
<a href="#l4.125"></a><span id="l4.125">  * Database abstraction layer.  Contains explicit SQL schemas for our</span>
<a href="#l4.126"></a><span id="l4.126">  *  fundamental representations (core 'nouns', if you will) as well as</span>
<a href="#l4.127"></a><span id="l4.127">  *  specialized functions for then dealing with each type of object.  At the</span>
<a href="#l4.128"></a><span id="l4.128" class="difflineat">@@ -849,38 +854,38 @@ var GlodaDatastore = {</span>
<a href="#l4.129"></a><span id="l4.129">   },</span>
<a href="#l4.130"></a><span id="l4.130"> </span>
<a href="#l4.131"></a><span id="l4.131">   /**</span>
<a href="#l4.132"></a><span id="l4.132">    * Our table definition used here is slightly different from that used</span>
<a href="#l4.133"></a><span id="l4.133">    *  internally, because we are potentially creating a sort of crappy ORM and</span>
<a href="#l4.134"></a><span id="l4.134">    *  we don't want to have to parse the column names out.</span>
<a href="#l4.135"></a><span id="l4.135">    */</span>
<a href="#l4.136"></a><span id="l4.136">   createTableIfNotExists: function gloda_ds_createTableIfNotExists(aTableDef) {</span>
<a href="#l4.137"></a><span id="l4.137" class="difflineminus">-    aTableDef._realName = &quot;plugin_&quot; + aTableDef.name;</span>
<a href="#l4.138"></a><span id="l4.138" class="difflineplus">+    aTableDef._realName = &quot;ext_&quot; + aTableDef.name;</span>
<a href="#l4.139"></a><span id="l4.139"> </span>
<a href="#l4.140"></a><span id="l4.140">     // first, check if the table exists</span>
<a href="#l4.141"></a><span id="l4.141" class="difflineminus">-    if (!this.syncConnection.tableExists(aTableDef._realName)) {</span>
<a href="#l4.142"></a><span id="l4.142" class="difflineplus">+    if (!this.asyncConnection.tableExists(aTableDef._realName)) {</span>
<a href="#l4.143"></a><span id="l4.143">       try {</span>
<a href="#l4.144"></a><span id="l4.144" class="difflineminus">-        this.syncConnection.createTable(aTableDef._realName,</span>
<a href="#l4.145"></a><span id="l4.145" class="difflineplus">+        this.asyncConnection.createTable(aTableDef._realName,</span>
<a href="#l4.146"></a><span id="l4.146">           [coldef.join(&quot; &quot;) for each</span>
<a href="#l4.147"></a><span id="l4.147">            ([i, coldef] in Iterator(aTableDef.columns))].join(&quot;, &quot;));</span>
<a href="#l4.148"></a><span id="l4.148">       }</span>
<a href="#l4.149"></a><span id="l4.149">       catch (ex) {</span>
<a href="#l4.150"></a><span id="l4.150">          this._log.error(&quot;Problem creating table &quot; + aTableDef.name + &quot; &quot; +</span>
<a href="#l4.151"></a><span id="l4.151">            &quot;because: &quot; + ex + &quot; at &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber);</span>
<a href="#l4.152"></a><span id="l4.152">          return null;</span>
<a href="#l4.153"></a><span id="l4.153">       }</span>
<a href="#l4.154"></a><span id="l4.154"> </span>
<a href="#l4.155"></a><span id="l4.155">       for (let indexName in aTableDef.indices) {</span>
<a href="#l4.156"></a><span id="l4.156">         let indexColumns = aTableDef.indices[indexName];</span>
<a href="#l4.157"></a><span id="l4.157"> </span>
<a href="#l4.158"></a><span id="l4.158">         try {</span>
<a href="#l4.159"></a><span id="l4.159">           let indexSql = &quot;CREATE INDEX &quot; + indexName + &quot; ON &quot; +</span>
<a href="#l4.160"></a><span id="l4.160">             aTableDef._realName + &quot; (&quot; + indexColumns.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l4.161"></a><span id="l4.161" class="difflineminus">-          this.syncConnection.executeSimpleSQL(indexSql);</span>
<a href="#l4.162"></a><span id="l4.162" class="difflineplus">+          this.asyncConnection.executeSimpleSQL(indexSql);</span>
<a href="#l4.163"></a><span id="l4.163">         }</span>
<a href="#l4.164"></a><span id="l4.164">         catch (ex) {</span>
<a href="#l4.165"></a><span id="l4.165">           this._log.error(&quot;Problem creating index &quot; + indexName + &quot; for &quot; +</span>
<a href="#l4.166"></a><span id="l4.166">             &quot;table &quot; + aTableDef.name + &quot; because &quot; + ex + &quot; at &quot; +</span>
<a href="#l4.167"></a><span id="l4.167">             ex.fileName + &quot;:&quot; + ex.lineNumber);</span>
<a href="#l4.168"></a><span id="l4.168">         }</span>
<a href="#l4.169"></a><span id="l4.169">       }</span>
<a href="#l4.170"></a><span id="l4.170">     }</span>
<a href="#l4.171"></a><span id="l4.171" class="difflineat">@@ -1092,17 +1097,17 @@ var GlodaDatastore = {</span>
<a href="#l4.172"></a><span id="l4.172">   _commitTransaction: function gloda_ds_commitTransaction() {</span>
<a href="#l4.173"></a><span id="l4.173">     this._transactionDepth--;</span>
<a href="#l4.174"></a><span id="l4.174">     if (this._transactionDepth == 0) {</span>
<a href="#l4.175"></a><span id="l4.175">       try {</span>
<a href="#l4.176"></a><span id="l4.176">         if (this._transactionGood)</span>
<a href="#l4.177"></a><span id="l4.177">           this._commitTransactionStatement.executeAsync(</span>
<a href="#l4.178"></a><span id="l4.178">             new PostCommitHandler(this._pendingPostCommitCallbacks));</span>
<a href="#l4.179"></a><span id="l4.179">         else</span>
<a href="#l4.180"></a><span id="l4.180" class="difflineminus">-          this._rollbackTransaction.executeAsync(this.trackAsync());</span>
<a href="#l4.181"></a><span id="l4.181" class="difflineplus">+          this._rollbackTransactionStatement.executeAsync(this.trackAsync());</span>
<a href="#l4.182"></a><span id="l4.182">       }</span>
<a href="#l4.183"></a><span id="l4.183">       catch (ex) {</span>
<a href="#l4.184"></a><span id="l4.184">         this._log.error(&quot;Commit problem: &quot; + ex);</span>
<a href="#l4.185"></a><span id="l4.185">       }</span>
<a href="#l4.186"></a><span id="l4.186">       this._pendingPostCommitCallbacks = [];</span>
<a href="#l4.187"></a><span id="l4.187">     }</span>
<a href="#l4.188"></a><span id="l4.188">   },</span>
<a href="#l4.189"></a><span id="l4.189">   /**</span>
<a href="#l4.190"></a><span id="l4.190" class="difflineat">@@ -2663,47 +2668,47 @@ var GlodaDatastore = {</span>
<a href="#l4.191"></a><span id="l4.191">   loadNounItem: function gloda_ds_loadNounItem(aItem, aReferencesByNounID,</span>
<a href="#l4.192"></a><span id="l4.192">       aInverseReferencesByNounID) {</span>
<a href="#l4.193"></a><span id="l4.193">     let attribIDToDBDefAndParam = this._attributeIDToDBDefAndParam;</span>
<a href="#l4.194"></a><span id="l4.194">     </span>
<a href="#l4.195"></a><span id="l4.195">     let hadDeps = aItem._deps != null;</span>
<a href="#l4.196"></a><span id="l4.196">     let deps = aItem._deps || {};</span>
<a href="#l4.197"></a><span id="l4.197">     let hasDeps = false;</span>
<a href="#l4.198"></a><span id="l4.198">     </span>
<a href="#l4.199"></a><span id="l4.199" class="difflineminus">-    this._log.debug(&quot;  hadDeps: &quot; + hadDeps + &quot; deps: &quot; + </span>
<a href="#l4.200"></a><span id="l4.200" class="difflineminus">-        Log4Moz.enumerateProperties(deps).join(&quot;,&quot;));</span>
<a href="#l4.201"></a><span id="l4.201" class="difflineplus">+    //this._log.debug(&quot;  hadDeps: &quot; + hadDeps + &quot; deps: &quot; + </span>
<a href="#l4.202"></a><span id="l4.202" class="difflineplus">+    //    Log4Moz.enumerateProperties(deps).join(&quot;,&quot;));</span>
<a href="#l4.203"></a><span id="l4.203">     </span>
<a href="#l4.204"></a><span id="l4.204">     for each (let [, attrib] in Iterator(aItem.NOUN_DEF.specialLoadAttribs)) {</span>
<a href="#l4.205"></a><span id="l4.205">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l4.206"></a><span id="l4.206">       </span>
<a href="#l4.207"></a><span id="l4.207">       if (attrib.special === this.kSpecialColumnChildren) {</span>
<a href="#l4.208"></a><span id="l4.208">         let invReferences = aInverseReferencesByNounID[objectNounDef.id];</span>
<a href="#l4.209"></a><span id="l4.209">         if (invReferences === undefined)</span>
<a href="#l4.210"></a><span id="l4.210">           invReferences = aInverseReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l4.211"></a><span id="l4.211">         // only contribute if it's not already pending or there</span>
<a href="#l4.212"></a><span id="l4.212">         if (!(attrib.id in deps) &amp;&amp; aItem[attrib.storageAttributeName] == null){</span>
<a href="#l4.213"></a><span id="l4.213" class="difflineminus">-          this._log.debug(&quot;   Adding inv ref for: &quot; + aItem.id);</span>
<a href="#l4.214"></a><span id="l4.214" class="difflineplus">+          //this._log.debug(&quot;   Adding inv ref for: &quot; + aItem.id);</span>
<a href="#l4.215"></a><span id="l4.215">           if (!(aItem.id in invReferences))</span>
<a href="#l4.216"></a><span id="l4.216">             invReferences[aItem.id] = null;</span>
<a href="#l4.217"></a><span id="l4.217">           deps[attrib.id] = null;</span>
<a href="#l4.218"></a><span id="l4.218">           hasDeps = true;</span>
<a href="#l4.219"></a><span id="l4.219">         }</span>
<a href="#l4.220"></a><span id="l4.220">       }</span>
<a href="#l4.221"></a><span id="l4.221">       else if (attrib.special === this.kSpecialColumnParent) {</span>
<a href="#l4.222"></a><span id="l4.222">         let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l4.223"></a><span id="l4.223">         if (references === undefined)</span>
<a href="#l4.224"></a><span id="l4.224">           references = aReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l4.225"></a><span id="l4.225">         // nothing to contribute if it's already there</span>
<a href="#l4.226"></a><span id="l4.226">         if (!(attrib.id in deps) &amp;&amp; </span>
<a href="#l4.227"></a><span id="l4.227">             aItem[attrib.valueStorageAttributeName] == null) {</span>
<a href="#l4.228"></a><span id="l4.228">           let parentID = aItem[attrib.idStorageAttributeName];</span>
<a href="#l4.229"></a><span id="l4.229">           if (!(parentID in references))</span>
<a href="#l4.230"></a><span id="l4.230">             references[parentID] = null;</span>
<a href="#l4.231"></a><span id="l4.231" class="difflineminus">-          this._log.debug(&quot;   Adding parent ref for: &quot; +</span>
<a href="#l4.232"></a><span id="l4.232" class="difflineminus">-            aItem[attrib.idStorageAttributeName]);</span>
<a href="#l4.233"></a><span id="l4.233" class="difflineplus">+          //this._log.debug(&quot;   Adding parent ref for: &quot; +</span>
<a href="#l4.234"></a><span id="l4.234" class="difflineplus">+          //  aItem[attrib.idStorageAttributeName]);</span>
<a href="#l4.235"></a><span id="l4.235">           deps[attrib.id] = null;</span>
<a href="#l4.236"></a><span id="l4.236">           hasDeps = true;</span>
<a href="#l4.237"></a><span id="l4.237">         }</span>
<a href="#l4.238"></a><span id="l4.238">         else {</span>
<a href="#l4.239"></a><span id="l4.239">           this._log.debug(&quot;  paranoia value storage: &quot; + aItem[attrib.valueStorageAttributeName]);</span>
<a href="#l4.240"></a><span id="l4.240">         }</span>
<a href="#l4.241"></a><span id="l4.241">       }</span>
<a href="#l4.242"></a><span id="l4.242">     }</span>
<a href="#l4.243"></a><span id="l4.243" class="difflineat">@@ -2793,34 +2798,30 @@ var GlodaDatastore = {</span>
<a href="#l4.244"></a><span id="l4.244">       let dbAttrib = attribIDToDBDefAndParam[attribId][0];</span>
<a href="#l4.245"></a><span id="l4.245">       let attrib = dbAttrib.attrDef;</span>
<a href="#l4.246"></a><span id="l4.246">       </span>
<a href="#l4.247"></a><span id="l4.247">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l4.248"></a><span id="l4.248">       let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l4.249"></a><span id="l4.249">       if (attrib.special) {</span>
<a href="#l4.250"></a><span id="l4.250">         if (attrib.special === this.kSpecialColumnChildren) {</span>
<a href="#l4.251"></a><span id="l4.251">           let inverseReferences = aInverseReferencesByNounID[objectNounDef.id];</span>
<a href="#l4.252"></a><span id="l4.252" class="difflineminus">-          this._log.info(&quot;inverse assignment: &quot; + objectNounDef.id +</span>
<a href="#l4.253"></a><span id="l4.253" class="difflineminus">-              &quot; of &quot; + aItem.id +</span>
<a href="#l4.254"></a><span id="l4.254" class="difflineminus">-              &quot; inverse refs: &quot; + Log4Moz.enumerateProperties(inverseReferences).join(&quot;,&quot;))</span>
<a href="#l4.255"></a><span id="l4.255" class="difflineplus">+          //this._log.info(&quot;inverse assignment: &quot; + objectNounDef.id +</span>
<a href="#l4.256"></a><span id="l4.256" class="difflineplus">+          //    &quot; of &quot; + aItem.id)</span>
<a href="#l4.257"></a><span id="l4.257">           aItem[attrib.storageAttributeName] = inverseReferences[aItem.id];</span>
<a href="#l4.258"></a><span id="l4.258">         }</span>
<a href="#l4.259"></a><span id="l4.259">         else if (attrib.special === this.kSpecialColumnParent) {</span>
<a href="#l4.260"></a><span id="l4.260" class="difflineminus">-          this._log.info(&quot;parent column load: &quot; + objectNounDef.id +</span>
<a href="#l4.261"></a><span id="l4.261" class="difflineminus">-              &quot; storage value: &quot; + aItem[attrib.idStorageAttributeName] +</span>
<a href="#l4.262"></a><span id="l4.262" class="difflineminus">-              &quot; refs: &quot; + references[aItem[attrib.idStorageAttributeName]]);</span>
<a href="#l4.263"></a><span id="l4.263" class="difflineminus">-          this._log.info(&quot;references: &quot;+ Log4Moz.enumerateProperties(references).join(&quot;,&quot;));</span>
<a href="#l4.264"></a><span id="l4.264" class="difflineplus">+          //this._log.info(&quot;parent column load: &quot; + objectNounDef.id +</span>
<a href="#l4.265"></a><span id="l4.265" class="difflineplus">+          //    &quot; storage value: &quot; + aItem[attrib.idStorageAttributeName]);</span>
<a href="#l4.266"></a><span id="l4.266">           aItem[attrib.valueStorageAttributeName] =</span>
<a href="#l4.267"></a><span id="l4.267">             references[aItem[attrib.idStorageAttributeName]];</span>
<a href="#l4.268"></a><span id="l4.268">         }</span>
<a href="#l4.269"></a><span id="l4.269">       }</span>
<a href="#l4.270"></a><span id="l4.270">       else if (objectNounDef.tableName) {</span>
<a href="#l4.271"></a><span id="l4.271" class="difflineminus">-        this._log.info(&quot;trying to load: &quot; + objectNounDef.id + &quot; refs: &quot; +</span>
<a href="#l4.272"></a><span id="l4.272" class="difflineminus">-            jsonValue + &quot;: &quot; + Log4Moz.enumerateProperties(jsonValue).join(&quot;,&quot;));</span>
<a href="#l4.273"></a><span id="l4.273" class="difflineminus">-        this._log.info(&quot;references: &quot;+ Log4Moz.enumerateProperties(references).join(&quot;,&quot;));</span>
<a href="#l4.274"></a><span id="l4.274" class="difflineplus">+        //this._log.info(&quot;trying to load: &quot; + objectNounDef.id + &quot; refs: &quot; +</span>
<a href="#l4.275"></a><span id="l4.275" class="difflineplus">+        //    jsonValue + &quot;: &quot; + Log4Moz.enumerateProperties(jsonValue).join(&quot;,&quot;));</span>
<a href="#l4.276"></a><span id="l4.276">         if (attrib.singular)</span>
<a href="#l4.277"></a><span id="l4.277">           aItem[attrib.boundName] = references[jsonValue];</span>
<a href="#l4.278"></a><span id="l4.278">         else</span>
<a href="#l4.279"></a><span id="l4.279">           aItem[attrib.boundName] = [references[val] for each</span>
<a href="#l4.280"></a><span id="l4.280">                                      ([, val] in Iterator(jsonValue))];</span>
<a href="#l4.281"></a><span id="l4.281">       }</span>
<a href="#l4.282"></a><span id="l4.282">       else if (objectNounDef.contributeObjDependencies) {</span>
<a href="#l4.283"></a><span id="l4.283">         aItem[attrib.boundName] =</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/modules/everybody.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/modules/everybody.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -79,10 +79,12 @@ function loadModule(aModuleURI, aNSContr</span>
<a href="#l5.4"></a><span id="l5.4">     LOG.info(&quot;+++ inited &quot; + aModuleURI);</span>
<a href="#l5.5"></a><span id="l5.5">   }</span>
<a href="#l5.6"></a><span id="l5.6">   return true;</span>
<a href="#l5.7"></a><span id="l5.7"> }</span>
<a href="#l5.8"></a><span id="l5.8"> </span>
<a href="#l5.9"></a><span id="l5.9"> loadModule(&quot;resource://gloda/modules/fundattr.js&quot;, &quot;GlodaFundAttr&quot;);</span>
<a href="#l5.10"></a><span id="l5.10"> loadModule(&quot;resource://gloda/modules/explattr.js&quot;, &quot;GlodaExplicitAttr&quot;);</span>
<a href="#l5.11"></a><span id="l5.11"> </span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+loadModule(&quot;resource://gloda/modules/noun_tag.js&quot;);</span>
<a href="#l5.13"></a><span id="l5.13"> loadModule(&quot;resource://gloda/modules/noun_freetag.js&quot;);</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+loadModule(&quot;resource://gloda/modules/noun_mimetype.js&quot;);</span>
<a href="#l5.15"></a><span id="l5.15"> loadModule(&quot;resource://gloda/modules/index_ab.js&quot;, &quot;GlodaABAttrs&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/modules/fundattr.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/modules/fundattr.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -43,16 +43,19 @@ const Cr = Components.results;</span>
<a href="#l6.4"></a><span id="l6.4"> const Cu = Components.utils;</span>
<a href="#l6.5"></a><span id="l6.5"> </span>
<a href="#l6.6"></a><span id="l6.6"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l6.7"></a><span id="l6.7"> </span>
<a href="#l6.8"></a><span id="l6.8"> Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l6.9"></a><span id="l6.9"> Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l6.10"></a><span id="l6.10"> Cu.import(&quot;resource://gloda/modules/datastore.js&quot;);</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/noun_mimetype.js&quot;);</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+</span>
<a href="#l6.15"></a><span id="l6.15"> /**</span>
<a href="#l6.16"></a><span id="l6.16">  * @namespace The Gloda Fundamental Attribute provider is a special attribute</span>
<a href="#l6.17"></a><span id="l6.17">  *  provider; it provides attributes that the rest of the providers should be</span>
<a href="#l6.18"></a><span id="l6.18">  *  able to assume exist.  Also, it may end up accessing things at a lower level</span>
<a href="#l6.19"></a><span id="l6.19">  *  than most extension providers should do.  In summary, don't mimic this code</span>
<a href="#l6.20"></a><span id="l6.20">  *  unless you won't complain when your code breaks.</span>
<a href="#l6.21"></a><span id="l6.21">  */</span>
<a href="#l6.22"></a><span id="l6.22"> var GlodaFundAttr = {</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineat">@@ -196,16 +199,27 @@ var GlodaFundAttr = {</span>
<a href="#l6.24"></a><span id="l6.24">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l6.25"></a><span id="l6.25">                         attributeName: &quot;date&quot;,</span>
<a href="#l6.26"></a><span id="l6.26">                         singular: true,</span>
<a href="#l6.27"></a><span id="l6.27">                         special: Gloda.kSpecialColumn,</span>
<a href="#l6.28"></a><span id="l6.28">                         specialColumnName: &quot;date&quot;,</span>
<a href="#l6.29"></a><span id="l6.29">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l6.30"></a><span id="l6.30">                         objectNoun: Gloda.NOUN_DATE,</span>
<a href="#l6.31"></a><span id="l6.31">                         }); // tested-by: test_attributes_fundamental</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+    </span>
<a href="#l6.33"></a><span id="l6.33" class="difflineplus">+    // Attachment MIME Types</span>
<a href="#l6.34"></a><span id="l6.34" class="difflineplus">+    this._attrAttachmentTypes = Gloda.defineAttribute({</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineplus">+      provider: this,</span>
<a href="#l6.36"></a><span id="l6.36" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l6.38"></a><span id="l6.38" class="difflineplus">+      attributeName: &quot;attachmentTypes&quot;,</span>
<a href="#l6.39"></a><span id="l6.39" class="difflineplus">+      singular: false,</span>
<a href="#l6.40"></a><span id="l6.40" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineplus">+      objectNoun: Gloda.NOUN_MIME_TYPE,</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineplus">+      });</span>
<a href="#l6.43"></a><span id="l6.43"> </span>
<a href="#l6.44"></a><span id="l6.44">     // --- Optimization</span>
<a href="#l6.45"></a><span id="l6.45">     // Involves.  Means any of from/to/cc.  The queries get ugly enough without</span>
<a href="#l6.46"></a><span id="l6.46">     //   this that it seems to justify the cost, especially given the frequent</span>
<a href="#l6.47"></a><span id="l6.47">     //   use case.  (In fact, post-filtering for the specific from/to/cc is</span>
<a href="#l6.48"></a><span id="l6.48">     //   probably justifiable rather than losing this attribute...)</span>
<a href="#l6.49"></a><span id="l6.49">     this._attrInvolves = Gloda.defineAttribute({</span>
<a href="#l6.50"></a><span id="l6.50">       provider: this,</span>
<a href="#l6.51"></a><span id="l6.51" class="difflineat">@@ -220,47 +234,47 @@ var GlodaFundAttr = {</span>
<a href="#l6.52"></a><span id="l6.52">     // From Me To</span>
<a href="#l6.53"></a><span id="l6.53">     this._attrFromMeTo = Gloda.defineAttribute({</span>
<a href="#l6.54"></a><span id="l6.54">       provider: this,</span>
<a href="#l6.55"></a><span id="l6.55">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l6.56"></a><span id="l6.56">       attributeType: Gloda.kAttrOptimization,</span>
<a href="#l6.57"></a><span id="l6.57">       attributeName: &quot;fromMeTo&quot;,</span>
<a href="#l6.58"></a><span id="l6.58">       singular: false,</span>
<a href="#l6.59"></a><span id="l6.59">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l6.60"></a><span id="l6.60" class="difflineminus">-      objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l6.61"></a><span id="l6.61" class="difflineplus">+      objectNoun: Gloda.NOUN_PARAM_IDENTITY,</span>
<a href="#l6.62"></a><span id="l6.62">       }); // not-tested</span>
<a href="#l6.63"></a><span id="l6.63">     // From Me Cc</span>
<a href="#l6.64"></a><span id="l6.64">     this._attrFromMeCc = Gloda.defineAttribute({</span>
<a href="#l6.65"></a><span id="l6.65">       provider: this,</span>
<a href="#l6.66"></a><span id="l6.66">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l6.67"></a><span id="l6.67">       attributeType: Gloda.kAttrOptimization,</span>
<a href="#l6.68"></a><span id="l6.68">       attributeName: &quot;fromMeCc&quot;,</span>
<a href="#l6.69"></a><span id="l6.69">       singular: false,</span>
<a href="#l6.70"></a><span id="l6.70">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l6.71"></a><span id="l6.71" class="difflineminus">-      objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l6.72"></a><span id="l6.72" class="difflineplus">+      objectNoun: Gloda.NOUN_PARAM_IDENTITY,</span>
<a href="#l6.73"></a><span id="l6.73">       }); // not-tested</span>
<a href="#l6.74"></a><span id="l6.74">     // To Me</span>
<a href="#l6.75"></a><span id="l6.75">     this._attrToMe = Gloda.defineAttribute({</span>
<a href="#l6.76"></a><span id="l6.76">       provider: this,</span>
<a href="#l6.77"></a><span id="l6.77">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l6.78"></a><span id="l6.78">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l6.79"></a><span id="l6.79">       attributeName: &quot;toMe&quot;,</span>
<a href="#l6.80"></a><span id="l6.80">       singular: false,</span>
<a href="#l6.81"></a><span id="l6.81">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l6.82"></a><span id="l6.82" class="difflineminus">-      objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l6.83"></a><span id="l6.83" class="difflineplus">+      objectNoun: Gloda.NOUN_PARAM_IDENTITY,</span>
<a href="#l6.84"></a><span id="l6.84">       }); // not-tested</span>
<a href="#l6.85"></a><span id="l6.85">     // Cc Me</span>
<a href="#l6.86"></a><span id="l6.86">     this._attrCcMe = Gloda.defineAttribute({</span>
<a href="#l6.87"></a><span id="l6.87">       provider: this,</span>
<a href="#l6.88"></a><span id="l6.88">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l6.89"></a><span id="l6.89">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l6.90"></a><span id="l6.90">       attributeName: &quot;ccMe&quot;,</span>
<a href="#l6.91"></a><span id="l6.91">       singular: false,</span>
<a href="#l6.92"></a><span id="l6.92">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l6.93"></a><span id="l6.93" class="difflineminus">-      objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l6.94"></a><span id="l6.94" class="difflineplus">+      objectNoun: Gloda.NOUN_PARAM_IDENTITY,</span>
<a href="#l6.95"></a><span id="l6.95">       }); // not-tested</span>
<a href="#l6.96"></a><span id="l6.96"> </span>
<a href="#l6.97"></a><span id="l6.97"> </span>
<a href="#l6.98"></a><span id="l6.98">     // -- Mailing List</span>
<a href="#l6.99"></a><span id="l6.99">     // Non-singular, but a hard call.  Namely, it is obvious that a message can</span>
<a href="#l6.100"></a><span id="l6.100">     //  be addressed to multiple mailing lists.  However, I don't see how you</span>
<a href="#l6.101"></a><span id="l6.101">     //  could receive a message with more than one set of List-* headers,</span>
<a href="#l6.102"></a><span id="l6.102">     //  since each list-serve would each send you a copy.  Based on our current</span>
<a href="#l6.103"></a><span id="l6.103" class="difflineat">@@ -297,42 +311,16 @@ var GlodaFundAttr = {</span>
<a href="#l6.104"></a><span id="l6.104">    *   processing.)</span>
<a href="#l6.105"></a><span id="l6.105">    * - Newsgroups.  Same deal as mailing lists.</span>
<a href="#l6.106"></a><span id="l6.106">    */</span>
<a href="#l6.107"></a><span id="l6.107">   process: function gloda_fundattr_process(aGlodaMessage, aRawReps,</span>
<a href="#l6.108"></a><span id="l6.108">                                            aIsNew, aCallbackHandle) {</span>
<a href="#l6.109"></a><span id="l6.109">     let aMsgHdr = aRawReps.header;</span>
<a href="#l6.110"></a><span id="l6.110">     let aMimeMsg = aRawReps.mime;</span>
<a href="#l6.111"></a><span id="l6.111">     </span>
<a href="#l6.112"></a><span id="l6.112" class="difflineminus">-    let involvedIdentities = {};</span>
<a href="#l6.113"></a><span id="l6.113" class="difflineminus">-    </span>
<a href="#l6.114"></a><span id="l6.114" class="difflineminus">-    let involved = aGlodaMessage.involved;</span>
<a href="#l6.115"></a><span id="l6.115" class="difflineminus">-    if (involved === undefined)</span>
<a href="#l6.116"></a><span id="l6.116" class="difflineminus">-      involved = aGlodaMessage.involved = [];</span>
<a href="#l6.117"></a><span id="l6.117" class="difflineminus">-    let to = aGlodaMessage.to;</span>
<a href="#l6.118"></a><span id="l6.118" class="difflineminus">-    if (to === undefined)</span>
<a href="#l6.119"></a><span id="l6.119" class="difflineminus">-      to = aGlodaMessage.to = [];</span>
<a href="#l6.120"></a><span id="l6.120" class="difflineminus">-    let cc = aGlodaMessage.cc;</span>
<a href="#l6.121"></a><span id="l6.121" class="difflineminus">-    if (cc === undefined)</span>
<a href="#l6.122"></a><span id="l6.122" class="difflineminus">-      cc = aGlodaMessage.cc = [];</span>
<a href="#l6.123"></a><span id="l6.123" class="difflineminus">-    </span>
<a href="#l6.124"></a><span id="l6.124" class="difflineminus">-    // me specialization optimizations</span>
<a href="#l6.125"></a><span id="l6.125" class="difflineminus">-    let toMe = aGlodaMessage.toMe;</span>
<a href="#l6.126"></a><span id="l6.126" class="difflineminus">-    if (toMe === undefined)</span>
<a href="#l6.127"></a><span id="l6.127" class="difflineminus">-      toMe = aGlodaMessage.toMe = [];</span>
<a href="#l6.128"></a><span id="l6.128" class="difflineminus">-    let fromMeTo = aGlodaMessage.fromMeTo;</span>
<a href="#l6.129"></a><span id="l6.129" class="difflineminus">-    if (fromMeTo === undefined)</span>
<a href="#l6.130"></a><span id="l6.130" class="difflineminus">-      fromMeTo = aGlodaMessage.fromMeTo = [];</span>
<a href="#l6.131"></a><span id="l6.131" class="difflineminus">-    let ccMe = aGlodaMessage.ccMe;</span>
<a href="#l6.132"></a><span id="l6.132" class="difflineminus">-    if (ccMe === undefined)</span>
<a href="#l6.133"></a><span id="l6.133" class="difflineminus">-      ccMe = aGlodaMessage.ccMe = [];</span>
<a href="#l6.134"></a><span id="l6.134" class="difflineminus">-    let fromMeCc = aGlodaMessage.fromMeCc;</span>
<a href="#l6.135"></a><span id="l6.135" class="difflineminus">-    if (fromMeCc === undefined)</span>
<a href="#l6.136"></a><span id="l6.136" class="difflineminus">-      fromMeCc = aGlodaMessage.fromMeCc = [];</span>
<a href="#l6.137"></a><span id="l6.137" class="difflineminus">-    </span>
<a href="#l6.138"></a><span id="l6.138">     // -- From</span>
<a href="#l6.139"></a><span id="l6.139">     // Let's use replyTo if available.</span>
<a href="#l6.140"></a><span id="l6.140">     // er, since we are just dealing with mailing lists for now, forget the</span>
<a href="#l6.141"></a><span id="l6.141">     //  reply-to...</span>
<a href="#l6.142"></a><span id="l6.142">     // TODO: deal with default charset issues</span>
<a href="#l6.143"></a><span id="l6.143">     let author = null;</span>
<a href="#l6.144"></a><span id="l6.144">     /*</span>
<a href="#l6.145"></a><span id="l6.145">     try {</span>
<a href="#l6.146"></a><span id="l6.146" class="difflineat">@@ -352,68 +340,104 @@ var GlodaFundAttr = {</span>
<a href="#l6.147"></a><span id="l6.147"> </span>
<a href="#l6.148"></a><span id="l6.148">     if (authorIdentities.length == 0) {</span>
<a href="#l6.149"></a><span id="l6.149">       this._log.error(&quot;Message with subject '&quot; + aMsgHdr.mime2DecodedSubject +</span>
<a href="#l6.150"></a><span id="l6.150">                       &quot;' somehow lacks a valid author.  Bailing.&quot;);</span>
<a href="#l6.151"></a><span id="l6.151">       return; // being a generator, this generates an exception; we like.</span>
<a href="#l6.152"></a><span id="l6.152">     }</span>
<a href="#l6.153"></a><span id="l6.153">     let authorIdentity = authorIdentities[0];</span>
<a href="#l6.154"></a><span id="l6.154">     aGlodaMessage.from = authorIdentity;</span>
<a href="#l6.155"></a><span id="l6.155" class="difflineminus">-    involved.push(authorIdentity);</span>
<a href="#l6.156"></a><span id="l6.156" class="difflineminus">-    involvedIdentities[authorIdentity.id] = true;</span>
<a href="#l6.157"></a><span id="l6.157" class="difflineminus">-    </span>
<a href="#l6.158"></a><span id="l6.158" class="difflineminus">-    let myIdentities = Gloda.myIdentities; // needless optimization?</span>
<a href="#l6.159"></a><span id="l6.159" class="difflineminus">-    let isFromMe = authorIdentity.id in myIdentities;</span>
<a href="#l6.160"></a><span id="l6.160" class="difflineminus">-    </span>
<a href="#l6.161"></a><span id="l6.161" class="difflineplus">+</span>
<a href="#l6.162"></a><span id="l6.162">     // -- To, Cc</span>
<a href="#l6.163"></a><span id="l6.163" class="difflineminus">-    // TODO: handle mailing list semantics (use my visterity logic as a first</span>
<a href="#l6.164"></a><span id="l6.164" class="difflineminus">-    //  pass.)</span>
<a href="#l6.165"></a><span id="l6.165" class="difflineminus">-    for (let iTo = 0; iTo &lt; toIdentities.length; iTo++) {</span>
<a href="#l6.166"></a><span id="l6.166" class="difflineminus">-      let toIdentity = toIdentities[iTo];</span>
<a href="#l6.167"></a><span id="l6.167" class="difflineminus">-      to.push(toIdentity);</span>
<a href="#l6.168"></a><span id="l6.168" class="difflineminus">-      if (!(toIdentity.id in involvedIdentities)) {</span>
<a href="#l6.169"></a><span id="l6.169" class="difflineminus">-        involved.push(toIdentity);</span>
<a href="#l6.170"></a><span id="l6.170" class="difflineminus">-        involvedIdentities[toIdentity.id] = true;</span>
<a href="#l6.171"></a><span id="l6.171" class="difflineplus">+    aGlodaMessage.to = toIdentities;</span>
<a href="#l6.172"></a><span id="l6.172" class="difflineplus">+    aGlodaMessage.cc = ccIdentities;</span>
<a href="#l6.173"></a><span id="l6.173" class="difflineplus">+    </span>
<a href="#l6.174"></a><span id="l6.174" class="difflineplus">+    // -- Attachments</span>
<a href="#l6.175"></a><span id="l6.175" class="difflineplus">+    let attachmentTypes = [];</span>
<a href="#l6.176"></a><span id="l6.176" class="difflineplus">+    for each (let attachment in aMimeMsg.allAttachments) {</span>
<a href="#l6.177"></a><span id="l6.177" class="difflineplus">+      if (attachment.isRealAttachment) {</span>
<a href="#l6.178"></a><span id="l6.178" class="difflineplus">+        attachmentTypes.push(MimeTypeNoun.getMimeType(attachment.contentType));</span>
<a href="#l6.179"></a><span id="l6.179">       }</span>
<a href="#l6.180"></a><span id="l6.180" class="difflineplus">+    }</span>
<a href="#l6.181"></a><span id="l6.181" class="difflineplus">+    if (attachmentTypes.length) {</span>
<a href="#l6.182"></a><span id="l6.182" class="difflineplus">+      aGlodaMessage.attachmentTypes = attachmentTypes;</span>
<a href="#l6.183"></a><span id="l6.183" class="difflineplus">+    }</span>
<a href="#l6.184"></a><span id="l6.184" class="difflineplus">+    </span>
<a href="#l6.185"></a><span id="l6.185" class="difflineplus">+    // TODO: deal with mailing lists, including implicit-to.  this will require</span>
<a href="#l6.186"></a><span id="l6.186" class="difflineplus">+    //  convincing the indexer to pass us in the previous message if it is</span>
<a href="#l6.187"></a><span id="l6.187" class="difflineplus">+    //  available.  (which we'll simply pass to everyone... it can help body</span>
<a href="#l6.188"></a><span id="l6.188" class="difflineplus">+    //  logic for quoting purposes, etc. too.)</span>
<a href="#l6.189"></a><span id="l6.189" class="difflineplus">+    </span>
<a href="#l6.190"></a><span id="l6.190" class="difflineplus">+    yield Gloda.kWorkDone;</span>
<a href="#l6.191"></a><span id="l6.191" class="difflineplus">+  },</span>
<a href="#l6.192"></a><span id="l6.192" class="difflineplus">+  </span>
<a href="#l6.193"></a><span id="l6.193" class="difflineplus">+  optimize: function gloda_fundattr_process(aGlodaMessage, aRawReps,</span>
<a href="#l6.194"></a><span id="l6.194" class="difflineplus">+      aIsNew, aCallbackHandle) {</span>
<a href="#l6.195"></a><span id="l6.195" class="difflineplus">+</span>
<a href="#l6.196"></a><span id="l6.196" class="difflineplus">+    let involvesIdentities = {};</span>
<a href="#l6.197"></a><span id="l6.197" class="difflineplus">+    let involves = aGlodaMessage.involves || [];</span>
<a href="#l6.198"></a><span id="l6.198" class="difflineplus">+    </span>
<a href="#l6.199"></a><span id="l6.199" class="difflineplus">+    // me specialization optimizations</span>
<a href="#l6.200"></a><span id="l6.200" class="difflineplus">+    let toMe = aGlodaMessage.toMe || [];</span>
<a href="#l6.201"></a><span id="l6.201" class="difflineplus">+    let fromMeTo = aGlodaMessage.fromMeTo || [];</span>
<a href="#l6.202"></a><span id="l6.202" class="difflineplus">+    let ccMe = aGlodaMessage.ccMe || [];</span>
<a href="#l6.203"></a><span id="l6.203" class="difflineplus">+    let fromMeCc = aGlodaMessage.fromMeCc || [];</span>
<a href="#l6.204"></a><span id="l6.204" class="difflineplus">+</span>
<a href="#l6.205"></a><span id="l6.205" class="difflineplus">+    let myIdentities = Gloda.myIdentities; // needless optimization?</span>
<a href="#l6.206"></a><span id="l6.206" class="difflineplus">+    let authorIdentity = aGlodaMessage.from;</span>
<a href="#l6.207"></a><span id="l6.207" class="difflineplus">+    let isFromMe = authorIdentity.id in myIdentities;</span>
<a href="#l6.208"></a><span id="l6.208" class="difflineplus">+</span>
<a href="#l6.209"></a><span id="l6.209" class="difflineplus">+    involves.push(authorIdentity);</span>
<a href="#l6.210"></a><span id="l6.210" class="difflineplus">+    involvesIdentities[authorIdentity.id] = true;</span>
<a href="#l6.211"></a><span id="l6.211" class="difflineplus">+    </span>
<a href="#l6.212"></a><span id="l6.212" class="difflineplus">+    for each (let [,toIdentity] in Iterator(aGlodaMessage.to)) {</span>
<a href="#l6.213"></a><span id="l6.213" class="difflineplus">+      if (!(toIdentity.id in involvesIdentities)) {</span>
<a href="#l6.214"></a><span id="l6.214" class="difflineplus">+        involves.push(toIdentity);</span>
<a href="#l6.215"></a><span id="l6.215" class="difflineplus">+        involvesIdentities[toIdentity.id] = true;</span>
<a href="#l6.216"></a><span id="l6.216" class="difflineplus">+      }</span>
<a href="#l6.217"></a><span id="l6.217" class="difflineplus">+      </span>
<a href="#l6.218"></a><span id="l6.218">       // optimization attribute to-me ('I' am the parameter)</span>
<a href="#l6.219"></a><span id="l6.219">       if (toIdentity.id in myIdentities) {</span>
<a href="#l6.220"></a><span id="l6.220">         toMe.push([toIdentity, authorIdentity]);</span>
<a href="#l6.221"></a><span id="l6.221">         if (aIsNew)</span>
<a href="#l6.222"></a><span id="l6.222">           authorIdentity.contact.popularity += this.POPULARITY_TO_ME;</span>
<a href="#l6.223"></a><span id="l6.223">       }</span>
<a href="#l6.224"></a><span id="l6.224">       // optimization attribute from-me-to ('I' am the parameter)</span>
<a href="#l6.225"></a><span id="l6.225">       if (isFromMe) {</span>
<a href="#l6.226"></a><span id="l6.226">         fromMeTo.push([authorIdentity, toIdentity]);</span>
<a href="#l6.227"></a><span id="l6.227">         // also, popularity</span>
<a href="#l6.228"></a><span id="l6.228">         if (aIsNew)</span>
<a href="#l6.229"></a><span id="l6.229">           toIdentity.contact.popularity += this.POPULARITY_FROM_ME_TO;</span>
<a href="#l6.230"></a><span id="l6.230">       }</span>
<a href="#l6.231"></a><span id="l6.231">     }</span>
<a href="#l6.232"></a><span id="l6.232" class="difflineminus">-    for (let iCc = 0; iCc &lt; ccIdentities.length; iCc++) {</span>
<a href="#l6.233"></a><span id="l6.233" class="difflineminus">-      let ccIdentity = ccIdentities[iCc];</span>
<a href="#l6.234"></a><span id="l6.234" class="difflineminus">-      cc.push(ccIdentity);</span>
<a href="#l6.235"></a><span id="l6.235" class="difflineminus">-      if (!(ccIdentity.id in involvedIdentities)) {</span>
<a href="#l6.236"></a><span id="l6.236" class="difflineminus">-        involved.push(ccIdentity);</span>
<a href="#l6.237"></a><span id="l6.237" class="difflineminus">-        involvedIdentities[ccIdentity.id] = true;</span>
<a href="#l6.238"></a><span id="l6.238" class="difflineplus">+    for each (let [,ccIdentity] in Iterator(aGlodaMessage.cc)) {</span>
<a href="#l6.239"></a><span id="l6.239" class="difflineplus">+      if (!(ccIdentity.id in involvesIdentities)) {</span>
<a href="#l6.240"></a><span id="l6.240" class="difflineplus">+        involves.push(ccIdentity);</span>
<a href="#l6.241"></a><span id="l6.241" class="difflineplus">+        involvesIdentities[ccIdentity.id] = true;</span>
<a href="#l6.242"></a><span id="l6.242">       }</span>
<a href="#l6.243"></a><span id="l6.243">       // optimization attribute cc-me ('I' am the parameter)</span>
<a href="#l6.244"></a><span id="l6.244">       if (ccIdentity.id in myIdentities) {</span>
<a href="#l6.245"></a><span id="l6.245">         ccMe.push([ccIdentity, authorIdentity]);</span>
<a href="#l6.246"></a><span id="l6.246">         if (aIsNew)</span>
<a href="#l6.247"></a><span id="l6.247">           authorIdentity.contact.popularity += this.POPULARITY_CC_ME;</span>
<a href="#l6.248"></a><span id="l6.248">       }</span>
<a href="#l6.249"></a><span id="l6.249">       // optimization attribute from-me-to ('I' am the parameter)</span>
<a href="#l6.250"></a><span id="l6.250">       if (isFromMe) {</span>
<a href="#l6.251"></a><span id="l6.251">         fromMeCc.push([authorIdentity, ccIdentity]);</span>
<a href="#l6.252"></a><span id="l6.252">         // also, popularity</span>
<a href="#l6.253"></a><span id="l6.253">         if (aIsNew)</span>
<a href="#l6.254"></a><span id="l6.254">           ccIdentity.contact.popularity += this.POPULARITY_FROM_ME_CC;</span>
<a href="#l6.255"></a><span id="l6.255">       }</span>
<a href="#l6.256"></a><span id="l6.256">     }</span>
<a href="#l6.257"></a><span id="l6.257">     </span>
<a href="#l6.258"></a><span id="l6.258" class="difflineminus">-    // TODO: deal with mailing lists, including implicit-to.  this will require</span>
<a href="#l6.259"></a><span id="l6.259" class="difflineminus">-    //  convincing the indexer to pass us in the previous message if it is</span>
<a href="#l6.260"></a><span id="l6.260" class="difflineminus">-    //  available.  (which we'll simply pass to everyone... it can help body</span>
<a href="#l6.261"></a><span id="l6.261" class="difflineminus">-    //  logic for quoting purposes, etc. too.)</span>
<a href="#l6.262"></a><span id="l6.262" class="difflineminus">-    </span>
<a href="#l6.263"></a><span id="l6.263" class="difflineplus">+    aGlodaMessage.involves = involves;</span>
<a href="#l6.264"></a><span id="l6.264" class="difflineplus">+    if (toMe.length)</span>
<a href="#l6.265"></a><span id="l6.265" class="difflineplus">+      aGlodaMessage.toMe = toMe;</span>
<a href="#l6.266"></a><span id="l6.266" class="difflineplus">+    if (fromMeTo.length)</span>
<a href="#l6.267"></a><span id="l6.267" class="difflineplus">+      aGlodaMessage.fromMeTo = fromMeTo;</span>
<a href="#l6.268"></a><span id="l6.268" class="difflineplus">+    if (ccMe.length)</span>
<a href="#l6.269"></a><span id="l6.269" class="difflineplus">+      aGlodaMessage.ccMe = ccMe;</span>
<a href="#l6.270"></a><span id="l6.270" class="difflineplus">+    if (fromMeCc.length)</span>
<a href="#l6.271"></a><span id="l6.271" class="difflineplus">+      aGlodaMessage.fromMeCc = fromMeCc;</span>
<a href="#l6.272"></a><span id="l6.272" class="difflineplus">+</span>
<a href="#l6.273"></a><span id="l6.273">     yield Gloda.kWorkDone;</span>
<a href="#l6.274"></a><span id="l6.274">   },</span>
<a href="#l6.275"></a><span id="l6.275"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -555,16 +555,21 @@ var Gloda = {</span>
<a href="#l7.4"></a><span id="l7.4">    *  style MATCH queries, or is okay with us just gluing them together with</span>
<a href="#l7.5"></a><span id="l7.5">    *  &quot; OR &quot; when used in an or-constraint case.  Gloda's query mechanism</span>
<a href="#l7.6"></a><span id="l7.6">    *  currently lacks the ability to to compile Gloda-style and-constraints</span>
<a href="#l7.7"></a><span id="l7.7">    *  into a single MATCH query, but it will turn out okay, just less</span>
<a href="#l7.8"></a><span id="l7.8">    *  efficiently than it could.</span>
<a href="#l7.9"></a><span id="l7.9">    */</span>
<a href="#l7.10"></a><span id="l7.10">   NOUN_FULLTEXT: 20,</span>
<a href="#l7.11"></a><span id="l7.11">   /**</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineplus">+   * Represents a MIME Type.  We currently lack any human-intelligible</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+   *  descriptions of mime types.</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+   */</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+  NOUN_MIME_TYPE: 40, </span>
<a href="#l7.16"></a><span id="l7.16" class="difflineplus">+  /**</span>
<a href="#l7.17"></a><span id="l7.17">    * Captures a message tag as well as when the tag's presence was observed,</span>
<a href="#l7.18"></a><span id="l7.18">    *  hoping to approximate when the tag was applied.  It's a somewhat dubious</span>
<a href="#l7.19"></a><span id="l7.19">    *  attempt to not waste our opporunity to store a value along with the tag.</span>
<a href="#l7.20"></a><span id="l7.20">    *  (The tag is actually stored as an attribute parameter on the attribute</span>
<a href="#l7.21"></a><span id="l7.21">    *  definition, rather than a value in the attribute 'instance' for the</span>
<a href="#l7.22"></a><span id="l7.22">    *  message.)</span>
<a href="#l7.23"></a><span id="l7.23">    */</span>
<a href="#l7.24"></a><span id="l7.24">   NOUN_TAG: 50,</span>
<a href="#l7.25"></a><span id="l7.25" class="difflineat">@@ -704,16 +709,17 @@ var Gloda = {</span>
<a href="#l7.26"></a><span id="l7.26">     }</span>
<a href="#l7.27"></a><span id="l7.27">     aNounDef.attribsByBoundName = {};</span>
<a href="#l7.28"></a><span id="l7.28">     </span>
<a href="#l7.29"></a><span id="l7.29">     this._nounNameToNounID[aNounDef.name] = aNounID;</span>
<a href="#l7.30"></a><span id="l7.30">     this._nounIDToDef[aNounID] = aNounDef;</span>
<a href="#l7.31"></a><span id="l7.31">     aNounDef.actions = [];</span>
<a href="#l7.32"></a><span id="l7.32">     </span>
<a href="#l7.33"></a><span id="l7.33">     this._attrProviderOrderByNoun[aNounDef.id] = [];</span>
<a href="#l7.34"></a><span id="l7.34" class="difflineplus">+    this._attrOptimizerOrderByNoun[aNounDef.id] = [];</span>
<a href="#l7.35"></a><span id="l7.35">     this._attrProvidersByNoun[aNounDef.id] = {};</span>
<a href="#l7.36"></a><span id="l7.36">   },</span>
<a href="#l7.37"></a><span id="l7.37"> </span>
<a href="#l7.38"></a><span id="l7.38">   /**</span>
<a href="#l7.39"></a><span id="l7.39">    * Lookup a noun (ID) suitable for passing to defineAttribute's various</span>
<a href="#l7.40"></a><span id="l7.40">    *  noun arguments.  Throws an exception if the noun with the given name</span>
<a href="#l7.41"></a><span id="l7.41">    *  cannot be found; the assumption is that you can't live without the noun.</span>
<a href="#l7.42"></a><span id="l7.42">    */</span>
<a href="#l7.43"></a><span id="l7.43" class="difflineat">@@ -779,16 +785,18 @@ var Gloda = {</span>
<a href="#l7.44"></a><span id="l7.44">     if (!nounDef)</span>
<a href="#l7.45"></a><span id="l7.45">       return [];</span>
<a href="#l7.46"></a><span id="l7.46">     return [action for each ([i, action] in Iterator(nounDef.actions))</span>
<a href="#l7.47"></a><span id="l7.47">             if (!aActionType || (action.actionType == aActionType))];</span>
<a href="#l7.48"></a><span id="l7.48">   },</span>
<a href="#l7.49"></a><span id="l7.49"> </span>
<a href="#l7.50"></a><span id="l7.50">   /** Attribute providers in the sequence to process them. */</span>
<a href="#l7.51"></a><span id="l7.51">   _attrProviderOrderByNoun: {},</span>
<a href="#l7.52"></a><span id="l7.52" class="difflineplus">+  /** Attribute providers that provide optimizers, in the sequence to proc. */</span>
<a href="#l7.53"></a><span id="l7.53" class="difflineplus">+  _attrOptimizerOrderByNoun: {},</span>
<a href="#l7.54"></a><span id="l7.54">   /** Maps attribute providers to the list of attributes they provide */</span>
<a href="#l7.55"></a><span id="l7.55">   _attrProviders: {},</span>
<a href="#l7.56"></a><span id="l7.56">   /**</span>
<a href="#l7.57"></a><span id="l7.57">    * Maps nouns to their attribute providers to a list of the attributes they</span>
<a href="#l7.58"></a><span id="l7.58">    *  provide for the noun.</span>
<a href="#l7.59"></a><span id="l7.59">    */</span>
<a href="#l7.60"></a><span id="l7.60">   _attrProvidersByNoun: {},</span>
<a href="#l7.61"></a><span id="l7.61"> </span>
<a href="#l7.62"></a><span id="l7.62" class="difflineat">@@ -838,17 +846,17 @@ var Gloda = {</span>
<a href="#l7.63"></a><span id="l7.63">       }}, this.NOUN_FULLTEXT);</span>
<a href="#l7.64"></a><span id="l7.64"> </span>
<a href="#l7.65"></a><span id="l7.65">     this.defineNoun({</span>
<a href="#l7.66"></a><span id="l7.66">       name: &quot;folder&quot;,</span>
<a href="#l7.67"></a><span id="l7.67">       class: GlodaFolder,</span>
<a href="#l7.68"></a><span id="l7.68">       allowsArbitraryAttrs: false,</span>
<a href="#l7.69"></a><span id="l7.69">       toParamAndValue: function(aFolderOrGlodaFolder) {</span>
<a href="#l7.70"></a><span id="l7.70">         if (aFolderOrGlodaFolder instanceof GlodaFolder)</span>
<a href="#l7.71"></a><span id="l7.71" class="difflineminus">-          return [null, aFolderOrURI.id];</span>
<a href="#l7.72"></a><span id="l7.72" class="difflineplus">+          return [null, aFolderOrGlodaFolder.id];</span>
<a href="#l7.73"></a><span id="l7.73">         else</span>
<a href="#l7.74"></a><span id="l7.74">           return [null, GlodaDatastore._mapFolder(aFolderOrGlodaFolder).id];</span>
<a href="#l7.75"></a><span id="l7.75">       }}, this.NOUN_FOLDER);</span>
<a href="#l7.76"></a><span id="l7.76">     this.defineNoun({</span>
<a href="#l7.77"></a><span id="l7.77">       name: &quot;conversation&quot;,</span>
<a href="#l7.78"></a><span id="l7.78">       class: GlodaConversation,</span>
<a href="#l7.79"></a><span id="l7.79">       allowsArbitraryAttrs: false,</span>
<a href="#l7.80"></a><span id="l7.80">       cache: true, cacheCost: 512,</span>
<a href="#l7.81"></a><span id="l7.81" class="difflineat">@@ -948,17 +956,17 @@ var Gloda = {</span>
<a href="#l7.82"></a><span id="l7.82">         return [added, removed];</span>
<a href="#l7.83"></a><span id="l7.83">       },</span>
<a href="#l7.84"></a><span id="l7.84">       contributeObjDependencies: function(aJsonValues, aReferencesByNounID,</span>
<a href="#l7.85"></a><span id="l7.85">           aInverseReferencesByNounID) {</span>
<a href="#l7.86"></a><span id="l7.86">         // nothing to do with a zero-length list</span>
<a href="#l7.87"></a><span id="l7.87">         if (aJsonValues.length == 0)</span>
<a href="#l7.88"></a><span id="l7.88">           return false;</span>
<a href="#l7.89"></a><span id="l7.89">       </span>
<a href="#l7.90"></a><span id="l7.90" class="difflineminus">-        let nounIdentityDef = Gloda._nounIDToDef[this.NOUN_IDENTITY]</span>
<a href="#l7.91"></a><span id="l7.91" class="difflineplus">+        let nounIdentityDef = Gloda._nounIDToDef[Gloda.NOUN_IDENTITY]</span>
<a href="#l7.92"></a><span id="l7.92">         let references = aReferencesByNounID[nounIdentityDef.id];</span>
<a href="#l7.93"></a><span id="l7.93">         if (references === undefined)</span>
<a href="#l7.94"></a><span id="l7.94">           references = aReferencesByNounID[nounIdentityDef.id] = {};</span>
<a href="#l7.95"></a><span id="l7.95">         </span>
<a href="#l7.96"></a><span id="l7.96">         for each (let [, tupe] in Iterator(aJsonValues)) {</span>
<a href="#l7.97"></a><span id="l7.97">           let [originIdentityID, targetIdentityID] = tupe;</span>
<a href="#l7.98"></a><span id="l7.98">           if (!(originIdentityID in references))</span>
<a href="#l7.99"></a><span id="l7.99">             references[originIdentityID] = null;</span>
<a href="#l7.100"></a><span id="l7.100" class="difflineat">@@ -966,27 +974,30 @@ var Gloda = {</span>
<a href="#l7.101"></a><span id="l7.101">             references[targetIdentityID] = null;</span>
<a href="#l7.102"></a><span id="l7.102">         }</span>
<a href="#l7.103"></a><span id="l7.103">         </span>
<a href="#l7.104"></a><span id="l7.104">         return true;</span>
<a href="#l7.105"></a><span id="l7.105">       },</span>
<a href="#l7.106"></a><span id="l7.106">       resolveObjDependencies: function(aJsonValues, aReferencesByNounID,</span>
<a href="#l7.107"></a><span id="l7.107">           aInverseReferencesByNounID) {</span>
<a href="#l7.108"></a><span id="l7.108">         let references =</span>
<a href="#l7.109"></a><span id="l7.109" class="difflineminus">-          aReferencesByNounID[this.NOUN_IDENTITY];</span>
<a href="#l7.110"></a><span id="l7.110" class="difflineplus">+          aReferencesByNounID[Gloda.NOUN_IDENTITY];</span>
<a href="#l7.111"></a><span id="l7.111">         </span>
<a href="#l7.112"></a><span id="l7.112">         let results = [];</span>
<a href="#l7.113"></a><span id="l7.113">         for each (let [, tupe] in Iterator(aJsonValues)) {</span>
<a href="#l7.114"></a><span id="l7.114">           let [originIdentityID, targetIdentityID] = tupe;</span>
<a href="#l7.115"></a><span id="l7.115">           results.push([references[originIdentityID],</span>
<a href="#l7.116"></a><span id="l7.116">                         references[targetIdentityID]]);</span>
<a href="#l7.117"></a><span id="l7.117">         }</span>
<a href="#l7.118"></a><span id="l7.118">         </span>
<a href="#l7.119"></a><span id="l7.119">         return results;</span>
<a href="#l7.120"></a><span id="l7.120">       },</span>
<a href="#l7.121"></a><span id="l7.121" class="difflineplus">+      toJSON: function (aIdentityTuple) {</span>
<a href="#l7.122"></a><span id="l7.122" class="difflineplus">+        return [aIdentityTuple[0].id, aIdentityTuple[1].id];</span>
<a href="#l7.123"></a><span id="l7.123" class="difflineplus">+      },</span>
<a href="#l7.124"></a><span id="l7.124">       toParamAndValue: function(aIdentityTuple) {</span>
<a href="#l7.125"></a><span id="l7.125">         return [aIdentityTuple[0].id, aIdentityTuple[1].id];</span>
<a href="#l7.126"></a><span id="l7.126">       }}, this.NOUN_PARAM_IDENTITY);</span>
<a href="#l7.127"></a><span id="l7.127"> </span>
<a href="#l7.128"></a><span id="l7.128">     GlodaDatastore.getAllAttributes();</span>
<a href="#l7.129"></a><span id="l7.129">   },</span>
<a href="#l7.130"></a><span id="l7.130"> </span>
<a href="#l7.131"></a><span id="l7.131">   /**</span>
<a href="#l7.132"></a><span id="l7.132" class="difflineat">@@ -1168,16 +1179,18 @@ var Gloda = {</span>
<a href="#l7.133"></a><span id="l7.133">       let subjectType = aAttrDef.subjectNouns[iSubject];</span>
<a href="#l7.134"></a><span id="l7.134">       let subjectNounDef = this._nounIDToDef[subjectType];</span>
<a href="#l7.135"></a><span id="l7.135">       this._bindAttribute(aAttrDef, subjectNounDef);</span>
<a href="#l7.136"></a><span id="l7.136"> </span>
<a href="#l7.137"></a><span id="l7.137">       // update the provider maps...</span>
<a href="#l7.138"></a><span id="l7.138">       if (this._attrProviderOrderByNoun[subjectType]</span>
<a href="#l7.139"></a><span id="l7.139">               .indexOf(aAttrDef.provider) == -1) {</span>
<a href="#l7.140"></a><span id="l7.140">         this._attrProviderOrderByNoun[subjectType].push(aAttrDef.provider);</span>
<a href="#l7.141"></a><span id="l7.141" class="difflineplus">+        if (aAttrDef.provider.optimize)</span>
<a href="#l7.142"></a><span id="l7.142" class="difflineplus">+          this._attrOptimizerOrderByNoun[subjectType].push(aAttrDef.provider);</span>
<a href="#l7.143"></a><span id="l7.143">         this._attrProvidersByNoun[subjectType][aAttrDef.provider] = [];</span>
<a href="#l7.144"></a><span id="l7.144">       }</span>
<a href="#l7.145"></a><span id="l7.145">       this._attrProvidersByNoun[subjectType][aAttrDef.provider].push(aAttrDef);</span>
<a href="#l7.146"></a><span id="l7.146">       </span>
<a href="#l7.147"></a><span id="l7.147">       subjectNounDef.attribsByBoundName[aAttrDef.boundName] = aAttrDef;</span>
<a href="#l7.148"></a><span id="l7.148">       </span>
<a href="#l7.149"></a><span id="l7.149">       if (aAttrDef.special &amp; this.kSpecialColumn)</span>
<a href="#l7.150"></a><span id="l7.150">         subjectNounDef.specialLoadAttribs.push(aAttrDef);</span>
<a href="#l7.151"></a><span id="l7.151" class="difflineat">@@ -1323,17 +1336,17 @@ var Gloda = {</span>
<a href="#l7.152"></a><span id="l7.152">    * - In-memory representation.</span>
<a href="#l7.153"></a><span id="l7.153">    * - JSON-able representation.</span>
<a href="#l7.154"></a><span id="l7.154">    */</span>
<a href="#l7.155"></a><span id="l7.155">   grokNounItem: function gloda_ns_grokNounItem(aItem, aRawReps, aIsNew,</span>
<a href="#l7.156"></a><span id="l7.156">       aCallbackHandle) {</span>
<a href="#l7.157"></a><span id="l7.157">     let itemNounDef = this._nounIDToDef[aItem.NOUN_ID];</span>
<a href="#l7.158"></a><span id="l7.158">     let attribsByBoundName = itemNounDef.attribsByBoundName;</span>
<a href="#l7.159"></a><span id="l7.159">     </span>
<a href="#l7.160"></a><span id="l7.160" class="difflineminus">-    this._log.debug(&quot;grokNounItem: &quot; + itemNounDef.name);</span>
<a href="#l7.161"></a><span id="l7.161" class="difflineplus">+    this._log.info(&quot; ** grokNounItem: &quot; + itemNounDef.name);</span>
<a href="#l7.162"></a><span id="l7.162">     </span>
<a href="#l7.163"></a><span id="l7.163">     let addDBAttribs = [];</span>
<a href="#l7.164"></a><span id="l7.164">     let removeDBAttribs = [];</span>
<a href="#l7.165"></a><span id="l7.165">     </span>
<a href="#l7.166"></a><span id="l7.166">     let jsonDict = {};</span>
<a href="#l7.167"></a><span id="l7.167">     </span>
<a href="#l7.168"></a><span id="l7.168">     let aOldItem;</span>
<a href="#l7.169"></a><span id="l7.169">     if (aIsNew) // there is no old item if we are new.</span>
<a href="#l7.170"></a><span id="l7.170" class="difflineat">@@ -1343,23 +1356,31 @@ var Gloda = {</span>
<a href="#l7.171"></a><span id="l7.171">       // we want to create a clone of the existing item so that we can know the</span>
<a href="#l7.172"></a><span id="l7.172">       //  deltas that happened for indexing purposes</span>
<a href="#l7.173"></a><span id="l7.173">       aItem = aItem._clone();</span>
<a href="#l7.174"></a><span id="l7.174">     }</span>
<a href="#l7.175"></a><span id="l7.175">   </span>
<a href="#l7.176"></a><span id="l7.176">     // Have the attribute providers directly set properties on the aItem</span>
<a href="#l7.177"></a><span id="l7.177">     let attrProviders = this._attrProviderOrderByNoun[aItem.NOUN_ID];</span>
<a href="#l7.178"></a><span id="l7.178">     for (let iProvider = 0; iProvider &lt; attrProviders.length; iProvider++) {</span>
<a href="#l7.179"></a><span id="l7.179" class="difflineminus">-      this._log.debug(&quot;  provider: &quot; + attrProviders[iProvider].providerName);</span>
<a href="#l7.180"></a><span id="l7.180" class="difflineplus">+      this._log.info(&quot;  * provider: &quot; + attrProviders[iProvider].providerName);</span>
<a href="#l7.181"></a><span id="l7.181">       yield aCallbackHandle.pushAndGo(</span>
<a href="#l7.182"></a><span id="l7.182">         attrProviders[iProvider].process(aItem, aRawReps, aIsNew,</span>
<a href="#l7.183"></a><span id="l7.183">                                          aCallbackHandle));</span>
<a href="#l7.184"></a><span id="l7.184">     }</span>
<a href="#l7.185"></a><span id="l7.185">     </span>
<a href="#l7.186"></a><span id="l7.186" class="difflineminus">-    this._log.debug(&quot; done with providers.&quot;);</span>
<a href="#l7.187"></a><span id="l7.187" class="difflineplus">+    let attrOptimizers = this._attrOptimizerOrderByNoun[aItem.NOUN_ID];</span>
<a href="#l7.188"></a><span id="l7.188" class="difflineplus">+    for (let iProvider = 0; iProvider &lt; attrOptimizers.length; iProvider++) {</span>
<a href="#l7.189"></a><span id="l7.189" class="difflineplus">+      this._log.info(&quot;  * optimizer: &quot; + attrOptimizers[iProvider].providerName);</span>
<a href="#l7.190"></a><span id="l7.190" class="difflineplus">+      yield aCallbackHandle.pushAndGo(</span>
<a href="#l7.191"></a><span id="l7.191" class="difflineplus">+        attrOptimizers[iProvider].optimize(aItem, aRawReps, aIsNew,</span>
<a href="#l7.192"></a><span id="l7.192" class="difflineplus">+                                           aCallbackHandle));</span>
<a href="#l7.193"></a><span id="l7.193" class="difflineplus">+    }</span>
<a href="#l7.194"></a><span id="l7.194" class="difflineplus">+    </span>
<a href="#l7.195"></a><span id="l7.195" class="difflineplus">+    this._log.info(&quot; ** done with providers.&quot;);</span>
<a href="#l7.196"></a><span id="l7.196">   </span>
<a href="#l7.197"></a><span id="l7.197">     // Iterate over the attributes on the item</span>
<a href="#l7.198"></a><span id="l7.198">     for each (let [key, value] in Iterator(aItem)) {</span>
<a href="#l7.199"></a><span id="l7.199">       // ignore keys that start with underscores, they are private and not</span>
<a href="#l7.200"></a><span id="l7.200">       //  persisted by our attribute mechanism.  (they are directly handled by</span>
<a href="#l7.201"></a><span id="l7.201">       //  the object implementation.)</span>
<a href="#l7.202"></a><span id="l7.202">       if (key[0] == &quot;_&quot;)</span>
<a href="#l7.203"></a><span id="l7.203">         continue;</span>
<a href="#l7.204"></a><span id="l7.204" class="difflineat">@@ -1389,31 +1410,38 @@ var Gloda = {</span>
<a href="#l7.205"></a><span id="l7.205">           jsonDict[attrib.id] = value;</span>
<a href="#l7.206"></a><span id="l7.206">       }</span>
<a href="#l7.207"></a><span id="l7.207">       </span>
<a href="#l7.208"></a><span id="l7.208">       // perform a delta analysis against the old value, if we have one</span>
<a href="#l7.209"></a><span id="l7.209">       let oldValue = aOldItem[key];</span>
<a href="#l7.210"></a><span id="l7.210">       if (oldValue !== undefined) {</span>
<a href="#l7.211"></a><span id="l7.211">         // in the singular case if they don't match, it's one add and one remove</span>
<a href="#l7.212"></a><span id="l7.212">         if (attrib.singular) {</span>
<a href="#l7.213"></a><span id="l7.213" class="difflineminus">-          if (value != oldValue) {</span>
<a href="#l7.214"></a><span id="l7.214" class="difflineminus">-            addDBAttribs.push(attribDB.convertValuesToDBAttributes(value)[0]);</span>
<a href="#l7.215"></a><span id="l7.215" class="difflineplus">+          // test for identicality, failing that, see if they have explicit</span>
<a href="#l7.216"></a><span id="l7.216" class="difflineplus">+          //  equals support.</span>
<a href="#l7.217"></a><span id="l7.217" class="difflineplus">+          if ((value !== oldValue) &amp;&amp;</span>
<a href="#l7.218"></a><span id="l7.218" class="difflineplus">+              (!value.equals || !value.equals(oldValue))) {</span>
<a href="#l7.219"></a><span id="l7.219" class="difflineplus">+            this._log.debug(&quot;%% want to add1 &quot; + value + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes([value]));</span>
<a href="#l7.220"></a><span id="l7.220" class="difflineplus">+            this._log.debug(&quot;%% want to rem1 &quot; + oldValue + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes([oldValue]));</span>
<a href="#l7.221"></a><span id="l7.221" class="difflineplus">+            addDBAttribs.push(attribDB.convertValuesToDBAttributes([value])[0]);</span>
<a href="#l7.222"></a><span id="l7.222">             removeDBAttribs.push(</span>
<a href="#l7.223"></a><span id="l7.223" class="difflineminus">-              attribDB.convertValuesToDBAttributes(oldValue)[0]);</span>
<a href="#l7.224"></a><span id="l7.224" class="difflineplus">+              attribDB.convertValuesToDBAttributes([oldValue])[0]);</span>
<a href="#l7.225"></a><span id="l7.225">           }</span>
<a href="#l7.226"></a><span id="l7.226">         }</span>
<a href="#l7.227"></a><span id="l7.227">         // in the plural case, we have to figure the deltas accounting for</span>
<a href="#l7.228"></a><span id="l7.228">         //  possible changes in ordering (which is insignificant from an</span>
<a href="#l7.229"></a><span id="l7.229">         //  indexing perspective)</span>
<a href="#l7.230"></a><span id="l7.230">         // some nouns may not meet === equivalence needs, so must provide a</span>
<a href="#l7.231"></a><span id="l7.231">         //  custom computeDelta method to help us out</span>
<a href="#l7.232"></a><span id="l7.232">         else if (objectNounDef.computeDelta) {</span>
<a href="#l7.233"></a><span id="l7.233">           let [valuesAdded, valuesRemoved] = </span>
<a href="#l7.234"></a><span id="l7.234">             objectNounDef.computeDelta(value, oldValue);</span>
<a href="#l7.235"></a><span id="l7.235">           // convert the values to database-style attribute rows</span>
<a href="#l7.236"></a><span id="l7.236" class="difflineplus">+          this._log.debug(&quot;%% want to add &quot; + valuesAdded + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l7.237"></a><span id="l7.237" class="difflineplus">+          this._log.debug(&quot;%% want to rem &quot; + valuesRemoved + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l7.238"></a><span id="l7.238">           addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l7.239"></a><span id="l7.239">             attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l7.240"></a><span id="l7.240">           removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l7.241"></a><span id="l7.241">             attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l7.242"></a><span id="l7.242">         }</span>
<a href="#l7.243"></a><span id="l7.243">         else {</span>
<a href="#l7.244"></a><span id="l7.244">           // build a map of the previous values; we will delete the values as</span>
<a href="#l7.245"></a><span id="l7.245">           //  we see them so that we will know what old values are no longer</span>
<a href="#l7.246"></a><span id="l7.246" class="difflineat">@@ -1428,45 +1456,51 @@ var Gloda = {</span>
<a href="#l7.247"></a><span id="l7.247">             if (curValue in oldValueMap)</span>
<a href="#l7.248"></a><span id="l7.248">               delete oldValueMap[curValue];</span>
<a href="#l7.249"></a><span id="l7.249">             else</span>
<a href="#l7.250"></a><span id="l7.250">               valuesAdded.push(curValue);</span>
<a href="#l7.251"></a><span id="l7.251">           }</span>
<a href="#l7.252"></a><span id="l7.252">           // anything still on oldValueMap was removed.</span>
<a href="#l7.253"></a><span id="l7.253">           let valuesRemoved = [val for (val in Iterator(oldValueMap, true))];</span>
<a href="#l7.254"></a><span id="l7.254">           // convert the values to database-style attribute rows</span>
<a href="#l7.255"></a><span id="l7.255" class="difflineplus">+          this._log.debug(&quot;%% want to add &quot; + valuesAdded + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l7.256"></a><span id="l7.256" class="difflineplus">+          this._log.debug(&quot;%% want to rem &quot; + valuesRemoved + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l7.257"></a><span id="l7.257">           addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l7.258"></a><span id="l7.258">             attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l7.259"></a><span id="l7.259">           removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l7.260"></a><span id="l7.260">             attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l7.261"></a><span id="l7.261">         }</span>
<a href="#l7.262"></a><span id="l7.262">       </span>
<a href="#l7.263"></a><span id="l7.263">         // delete the old values to mark that we have processed them</span>
<a href="#l7.264"></a><span id="l7.264">         delete aOldItem[key];</span>
<a href="#l7.265"></a><span id="l7.265">       }</span>
<a href="#l7.266"></a><span id="l7.266">       // no old value, all attributes are new</span>
<a href="#l7.267"></a><span id="l7.267">       else {</span>
<a href="#l7.268"></a><span id="l7.268" class="difflineplus">+        if (attrib.singular)</span>
<a href="#l7.269"></a><span id="l7.269" class="difflineplus">+          value = [value];</span>
<a href="#l7.270"></a><span id="l7.270" class="difflineplus">+        this._log.debug(&quot;%% want to add &quot; + value + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l7.271"></a><span id="l7.271">         addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l7.272"></a><span id="l7.272">                                 attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l7.273"></a><span id="l7.273">       }</span>
<a href="#l7.274"></a><span id="l7.274">     }</span>
<a href="#l7.275"></a><span id="l7.275">     </span>
<a href="#l7.276"></a><span id="l7.276">     // Iterate over any remaining values in old items for purge purposes.</span>
<a href="#l7.277"></a><span id="l7.277">     for each (let [key, value] in Iterator(aOldItem)) {</span>
<a href="#l7.278"></a><span id="l7.278">       // ignore keys that start with underscores, they are private and not</span>
<a href="#l7.279"></a><span id="l7.279">       //  persisted by our attribute mechanism.  (they are directly handled by</span>
<a href="#l7.280"></a><span id="l7.280">       //  the object implementation.)</span>
<a href="#l7.281"></a><span id="l7.281">       if (key[0] == &quot;_&quot;)</span>
<a href="#l7.282"></a><span id="l7.282">         continue;</span>
<a href="#l7.283"></a><span id="l7.283">       // find the attribute definition that corresponds to this key</span>
<a href="#l7.284"></a><span id="l7.284">       let attrib = attribsByBoundName[key];</span>
<a href="#l7.285"></a><span id="l7.285" class="difflineplus">+      let attribDB = attrib.dbDef;</span>
<a href="#l7.286"></a><span id="l7.286">       // if there's no attribute, that's not good, but not horrible.</span>
<a href="#l7.287"></a><span id="l7.287">       if (attrib === undefined)</span>
<a href="#l7.288"></a><span id="l7.288">         continue;</span>
<a href="#l7.289"></a><span id="l7.289" class="difflineminus">-      </span>
<a href="#l7.290"></a><span id="l7.290" class="difflineplus">+      this._log.debug(&quot;%% want to remove &quot; + value + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l7.291"></a><span id="l7.291">       removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l7.292"></a><span id="l7.292">                                  attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l7.293"></a><span id="l7.293">     }</span>
<a href="#l7.294"></a><span id="l7.294">     </span>
<a href="#l7.295"></a><span id="l7.295">     aItem._jsonText = this._json.encode(jsonDict);</span>
<a href="#l7.296"></a><span id="l7.296">     this._log.debug(&quot;  json text: &quot; + aItem._jsonText);</span>
<a href="#l7.297"></a><span id="l7.297">     </span>
<a href="#l7.298"></a><span id="l7.298">     if (aIsNew) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/modules/indexer.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/modules/indexer.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -63,16 +63,19 @@ Cu.import(&quot;resource://gloda/modules/mime</span>
<a href="#l8.4"></a><span id="l8.4"> </span>
<a href="#l8.5"></a><span id="l8.5"> // for list comprehension fun</span>
<a href="#l8.6"></a><span id="l8.6"> function range(begin, end) {</span>
<a href="#l8.7"></a><span id="l8.7">   for (let i = begin; i &lt; end; ++i) {</span>
<a href="#l8.8"></a><span id="l8.8">     yield i;</span>
<a href="#l8.9"></a><span id="l8.9">   }</span>
<a href="#l8.10"></a><span id="l8.10"> }</span>
<a href="#l8.11"></a><span id="l8.11"> </span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+const GFI = Log4Moz.Service.getLogger(&quot;gloda.fixiterator&quot;);</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+</span>
<a href="#l8.15"></a><span id="l8.15"> // FROM STEEL (a la Joey Minta/jminta)</span>
<a href="#l8.16"></a><span id="l8.16"> // (and to go away when STEEL is checked in, although we may also want to</span>
<a href="#l8.17"></a><span id="l8.17"> //  consider just specializing the code in the few places this method is used.)</span>
<a href="#l8.18"></a><span id="l8.18"> /**</span>
<a href="#l8.19"></a><span id="l8.19">  * This function will take a variety of xpcom iterators designed for c++ and turn</span>
<a href="#l8.20"></a><span id="l8.20">  * them into a nice JavaScript style object that can be iterated using for...in</span>
<a href="#l8.21"></a><span id="l8.21">  *</span>
<a href="#l8.22"></a><span id="l8.22">  * Currently, we support the following types of xpcom iterators:</span>
<a href="#l8.23"></a><span id="l8.23" class="difflineat">@@ -108,16 +111,17 @@ function fixIterator(aEnum, aIface) {</span>
<a href="#l8.24"></a><span id="l8.24">     let iter = function() {</span>
<a href="#l8.25"></a><span id="l8.25">       while (!done) {</span>
<a href="#l8.26"></a><span id="l8.26">         try {</span>
<a href="#l8.27"></a><span id="l8.27">           //rets.push(aEnum.currentItem().QueryInterface(face));</span>
<a href="#l8.28"></a><span id="l8.28">           yield aEnum.currentItem().QueryInterface(face);</span>
<a href="#l8.29"></a><span id="l8.29">           aEnum.next();</span>
<a href="#l8.30"></a><span id="l8.30">         } catch(ex) {</span>
<a href="#l8.31"></a><span id="l8.31">           done = true;</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+          GFI.error(face + &quot; =&gt; &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex)</span>
<a href="#l8.33"></a><span id="l8.33">         }</span>
<a href="#l8.34"></a><span id="l8.34">       }</span>
<a href="#l8.35"></a><span id="l8.35">     };</span>
<a href="#l8.36"></a><span id="l8.36"> </span>
<a href="#l8.37"></a><span id="l8.37">     return { __iterator__: iter };</span>
<a href="#l8.38"></a><span id="l8.38">   } catch(ex) {}</span>
<a href="#l8.39"></a><span id="l8.39">   </span>
<a href="#l8.40"></a><span id="l8.40">   // how about nsISimpleEnumerator? this one is nice and simple</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineat">@@ -705,17 +709,16 @@ var GlodaIndexer = {</span>
<a href="#l8.42"></a><span id="l8.42">         status = Gloda.kIndexerIndexing;</span>
<a href="#l8.43"></a><span id="l8.43">       else if (job.deltaType == 0)</span>
<a href="#l8.44"></a><span id="l8.44">         status = Gloda.kIndexerMoving;</span>
<a href="#l8.45"></a><span id="l8.45">       else</span>
<a href="#l8.46"></a><span id="l8.46">         status = Gloda.kIndexerRemoving;</span>
<a href="#l8.47"></a><span id="l8.47">         </span>
<a href="#l8.48"></a><span id="l8.48">       let prettyName = (this._indexingFolder !== null) ?</span>
<a href="#l8.49"></a><span id="l8.49">                        this._indexingFolder.prettiestName : null;</span>
<a href="#l8.50"></a><span id="l8.50" class="difflineminus">-      status = status + &quot; &quot; + prettyName;</span>
<a href="#l8.51"></a><span id="l8.51"> </span>
<a href="#l8.52"></a><span id="l8.52">       jobIndex = this._indexingJobCount-1;</span>
<a href="#l8.53"></a><span id="l8.53">       jobTotal = this._indexingJobGoal;</span>
<a href="#l8.54"></a><span id="l8.54">       jobItemIndex = job.offset;</span>
<a href="#l8.55"></a><span id="l8.55">       jobItemGoal  = job.goal;</span>
<a href="#l8.56"></a><span id="l8.56">     }</span>
<a href="#l8.57"></a><span id="l8.57">     else {</span>
<a href="#l8.58"></a><span id="l8.58">       status = Gloda.kIndexerIdle;</span>
<a href="#l8.59"></a><span id="l8.59" class="difflineat">@@ -1061,19 +1064,22 @@ var GlodaIndexer = {</span>
<a href="#l8.60"></a><span id="l8.60">               this._workBatchData = this._callbackHandle.popWithResult();</span>
<a href="#l8.61"></a><span id="l8.61">               tokensLeft++; // don't eat a token for this pass</span>
<a href="#l8.62"></a><span id="l8.62">               continue;</span>
<a href="#l8.63"></a><span id="l8.63">           }</span>
<a href="#l8.64"></a><span id="l8.64">         }</span>
<a href="#l8.65"></a><span id="l8.65">         catch (ex) {</span>
<a href="#l8.66"></a><span id="l8.66">           this._log.warn(&quot;Bailing on job (at &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l8.67"></a><span id="l8.67">               ex.lineNumber + &quot;) because: &quot; + ex);</span>
<a href="#l8.68"></a><span id="l8.68" class="difflineplus">+          // make sure we no longer have a current folder</span>
<a href="#l8.69"></a><span id="l8.69">           this._indexerLeaveFolder(true);</span>
<a href="#l8.70"></a><span id="l8.70">           this._curIndexingJob = null;</span>
<a href="#l8.71"></a><span id="l8.71" class="difflineplus">+          // clear out our current generators and our related data</span>
<a href="#l8.72"></a><span id="l8.72">           this._callbackHandle.cleanup();</span>
<a href="#l8.73"></a><span id="l8.73" class="difflineplus">+          this._workBatchData = undefined;</span>
<a href="#l8.74"></a><span id="l8.74">         }</span>
<a href="#l8.75"></a><span id="l8.75">       }</span>
<a href="#l8.76"></a><span id="l8.76">       </span>
<a href="#l8.77"></a><span id="l8.77">       // take a breather by having the caller re-schedule us sometime in the</span>
<a href="#l8.78"></a><span id="l8.78">       //  future, but only if we're going to perform another loop iteration.</span>
<a href="#l8.79"></a><span id="l8.79">       if (commitTokens &gt; 0)</span>
<a href="#l8.80"></a><span id="l8.80">         yield this.kWorkPause;</span>
<a href="#l8.81"></a><span id="l8.81">     }</span>
<a href="#l8.82"></a><span id="l8.82" class="difflineat">@@ -2052,19 +2058,19 @@ var GlodaIndexer = {</span>
<a href="#l8.83"></a><span id="l8.83">           // we only care about the first instance of the message because we are</span>
<a href="#l8.84"></a><span id="l8.84">           //  able to guarantee the invariant that all messages with the same</span>
<a href="#l8.85"></a><span id="l8.85">           //  message id belong to the same conversation. </span>
<a href="#l8.86"></a><span id="l8.86">           let ancestor = ancestorList[0];</span>
<a href="#l8.87"></a><span id="l8.87">           if (conversationID === null)</span>
<a href="#l8.88"></a><span id="l8.88">             conversationID = ancestor.conversationID;</span>
<a href="#l8.89"></a><span id="l8.89">           else if (conversationID != ancestor.conversationID)</span>
<a href="#l8.90"></a><span id="l8.90">             this._log.error(&quot;Inconsistency in conversations invariant on &quot; +</span>
<a href="#l8.91"></a><span id="l8.91" class="difflineminus">-                            ancestor.messageID + &quot;.  It has conv id &quot; +</span>
<a href="#l8.92"></a><span id="l8.92" class="difflineplus">+                            ancestor.headerMessageID + &quot;.  It has conv id &quot; +</span>
<a href="#l8.93"></a><span id="l8.93">                             ancestor.conversationID + &quot; but expected &quot; + </span>
<a href="#l8.94"></a><span id="l8.94" class="difflineminus">-                            conversationID);</span>
<a href="#l8.95"></a><span id="l8.95" class="difflineplus">+                            conversationID + &quot;. ID: &quot; + ancestor.id);</span>
<a href="#l8.96"></a><span id="l8.96">         }</span>
<a href="#l8.97"></a><span id="l8.97">       }</span>
<a href="#l8.98"></a><span id="l8.98">     }</span>
<a href="#l8.99"></a><span id="l8.99">     </span>
<a href="#l8.100"></a><span id="l8.100">     let conversation = null;</span>
<a href="#l8.101"></a><span id="l8.101">     // nobody had one?  create a new conversation</span>
<a href="#l8.102"></a><span id="l8.102">     if (conversationID === null) {</span>
<a href="#l8.103"></a><span id="l8.103">       // (the create method could issue the id, making the call return</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/modules/query.js</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/modules/query.js</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -85,20 +85,22 @@ GlodaQueryClass.prototype = {</span>
<a href="#l9.4"></a><span id="l9.4">     return orQuery;</span>
<a href="#l9.5"></a><span id="l9.5">   },</span>
<a href="#l9.6"></a><span id="l9.6">   </span>
<a href="#l9.7"></a><span id="l9.7">   orderBy: function gloda_query_orderBy() {</span>
<a href="#l9.8"></a><span id="l9.8">     for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l9.9"></a><span id="l9.9">       let arg = arguments[iArg];</span>
<a href="#l9.10"></a><span id="l9.10">       this._order.push(arg);</span>
<a href="#l9.11"></a><span id="l9.11">     }</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineplus">+    return this;</span>
<a href="#l9.13"></a><span id="l9.13">   },</span>
<a href="#l9.14"></a><span id="l9.14">   </span>
<a href="#l9.15"></a><span id="l9.15">   limit: function gloda_query_limit(aLimit) {</span>
<a href="#l9.16"></a><span id="l9.16">     this._limit = aLimit;</span>
<a href="#l9.17"></a><span id="l9.17" class="difflineplus">+    return this;</span>
<a href="#l9.18"></a><span id="l9.18">   },</span>
<a href="#l9.19"></a><span id="l9.19">   </span>
<a href="#l9.20"></a><span id="l9.20">   /**</span>
<a href="#l9.21"></a><span id="l9.21">    * Return a collection asynchronously populated by this collection.  You must</span>
<a href="#l9.22"></a><span id="l9.22">    *  provide a listener to receive notifications from the collection as it</span>
<a href="#l9.23"></a><span id="l9.23">    *  receives updates.  The listener object should implement onItemsAdded,</span>
<a href="#l9.24"></a><span id="l9.24">    *  onItemsModified, and onItemsRemoved methods, all of which take a single</span>
<a href="#l9.25"></a><span id="l9.25">    *  argument which is the list of items which have been added, modified, or</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

