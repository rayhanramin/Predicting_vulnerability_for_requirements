<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 979:7d39e7afd1751d830e2eabe8f69801905a413e9a</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 7d39e7afd1751d830e2eabe8f69801905a413e9a" />
<meta property="og:url" content="/comm-central/rev/7d39e7afd1751d830e2eabe8f69801905a413e9a" />
<meta property="og:description" content="status commit of refactoring; pretty good shape:" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 7d39e7afd1751d830e2eabe8f69801905a413e9a 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/7d39e7afd1751d830e2eabe8f69801905a413e9a">shortlog</a> |
<a href="/comm-central/log/7d39e7afd1751d830e2eabe8f69801905a413e9a">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/7d39e7afd1751d830e2eabe8f69801905a413e9a">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/7d39e7afd1751d830e2eabe8f69801905a413e9a">files</a> |
changeset |
<a href="/comm-central/raw-rev/7d39e7afd1751d830e2eabe8f69801905a413e9a">raw</a>  | <a href="/comm-central/archive/7d39e7afd1751d830e2eabe8f69801905a413e9a.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
status commit of refactoring; pretty good shape:
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Sun, 19 Oct 2008 03:51:00 -0700</td></tr>

<tr>
 <td>changeset 979</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/7d39e7afd1751d830e2eabe8f69801905a413e9a">7d39e7afd1751d830e2eabe8f69801905a413e9a</a></td>
</tr>



<tr>
<td>parent 978</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/fc01f4852a99fc70aade625c2a929de943530615">fc01f4852a99fc70aade625c2a929de943530615</a>
</td>
</tr>

<tr>
<td>child 980</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/1640a675f6d98000c103dc484aecc7c27f69b624">1640a675f6d98000c103dc484aecc7c27f69b624</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=7d39e7afd1751d830e2eabe8f69801905a413e9a">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">status commit of refactoring; pretty good shape:
 * message loads identity loads contact loads identities works
 * message loads conversation works
 * the above means that all manners of horrible lookup mechanisms (from cache,
from disk, from prior yet still outstanding collection lookups, etc.
 * indexing seems to work</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/collection.js">modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/collection.js">file</a> |
<a href="/comm-central/annotate/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/collection.js">comparison</a> |
<a href="/comm-central/log/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/fundattr.js">modules/fundattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/fundattr.js">file</a> |
<a href="/comm-central/annotate/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/fundattr.js">annotate</a> |
<a href="/comm-central/diff/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/fundattr.js">diff</a> |
<a href="/comm-central/comparison/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/fundattr.js">comparison</a> |
<a href="/comm-central/log/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/fundattr.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/index_ab.js">modules/index_ab.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/index_ab.js">file</a> |
<a href="/comm-central/annotate/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/index_ab.js">annotate</a> |
<a href="/comm-central/diff/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/index_ab.js">diff</a> |
<a href="/comm-central/comparison/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/index_ab.js">comparison</a> |
<a href="/comm-central/log/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/index_ab.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/indexer.js">modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/7d39e7afd1751d830e2eabe8f69801905a413e9a/modules/indexer.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/modules/collection.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/modules/collection.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -135,45 +135,45 @@ var GlodaCollectionManager = {</span>
<a href="#l1.4"></a><span id="l1.4">     return null;</span>
<a href="#l1.5"></a><span id="l1.5">   },</span>
<a href="#l1.6"></a><span id="l1.6"> </span>
<a href="#l1.7"></a><span id="l1.7">   /**</span>
<a href="#l1.8"></a><span id="l1.8">    * Lookup multiple nouns by ID from the cache/existing collections.</span>
<a href="#l1.9"></a><span id="l1.9">    * @return [The number that were found, the number that were not found.]</span>
<a href="#l1.10"></a><span id="l1.10">    */</span>
<a href="#l1.11"></a><span id="l1.11">   cacheLookupMany: function gloda_colm_cacheLookupMany(aNounID, aIDMap,</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-      aDoCache) {</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+      aTargetMap, aDoCache) {</span>
<a href="#l1.14"></a><span id="l1.14">     let foundCount = 0, notFoundCount = 0, notFound = {};</span>
<a href="#l1.15"></a><span id="l1.15">     </span>
<a href="#l1.16"></a><span id="l1.16">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l1.17"></a><span id="l1.17">     </span>
<a href="#l1.18"></a><span id="l1.18">     if (cache) {</span>
<a href="#l1.19"></a><span id="l1.19">       for (let key in aIDMap) {</span>
<a href="#l1.20"></a><span id="l1.20">         let cacheValue = cache._idMap[key];</span>
<a href="#l1.21"></a><span id="l1.21">         if (cacheValue === undefined) {</span>
<a href="#l1.22"></a><span id="l1.22">           notFoundCount++;</span>
<a href="#l1.23"></a><span id="l1.23">           notFound[key] = null;</span>
<a href="#l1.24"></a><span id="l1.24">         }</span>
<a href="#l1.25"></a><span id="l1.25">         else {</span>
<a href="#l1.26"></a><span id="l1.26">           foundCount++;</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineminus">-          aIDMap[key] = cacheValue;</span>
<a href="#l1.28"></a><span id="l1.28" class="difflineplus">+          aTargetMap[key] = cacheValue;</span>
<a href="#l1.29"></a><span id="l1.29">           cache.hit(cacheValue);</span>
<a href="#l1.30"></a><span id="l1.30">         }</span>
<a href="#l1.31"></a><span id="l1.31">       }</span>
<a href="#l1.32"></a><span id="l1.32">     }</span>
<a href="#l1.33"></a><span id="l1.33"> </span>
<a href="#l1.34"></a><span id="l1.34">     if (aDoCache === false)</span>
<a href="#l1.35"></a><span id="l1.35">       cache = null;</span>
<a href="#l1.36"></a><span id="l1.36">     </span>
<a href="#l1.37"></a><span id="l1.37">     for each (let [iCollection, collection] in</span>
<a href="#l1.38"></a><span id="l1.38">               Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l1.39"></a><span id="l1.39">       for (let key in notFound) {</span>
<a href="#l1.40"></a><span id="l1.40">         let collValue = collection._idMap[key];</span>
<a href="#l1.41"></a><span id="l1.41">         if (collValue !== undefined) {</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineminus">-          aIDMap[key] = collValue;</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+          aTargetMap[key] = collValue;</span>
<a href="#l1.44"></a><span id="l1.44">           delete notFound[key];</span>
<a href="#l1.45"></a><span id="l1.45">           foundCount++;</span>
<a href="#l1.46"></a><span id="l1.46">           notFoundCount--;</span>
<a href="#l1.47"></a><span id="l1.47">           if (cache)</span>
<a href="#l1.48"></a><span id="l1.48">             cache.add([collValue]);</span>
<a href="#l1.49"></a><span id="l1.49">         }</span>
<a href="#l1.50"></a><span id="l1.50">       }</span>
<a href="#l1.51"></a><span id="l1.51">     }</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineat">@@ -450,17 +450,17 @@ function GlodaCollection(aNounDef, aItem</span>
<a href="#l1.53"></a><span id="l1.53">   </span>
<a href="#l1.54"></a><span id="l1.54">   this.query = aQuery || null;</span>
<a href="#l1.55"></a><span id="l1.55">   this._listener = aListener || null;</span>
<a href="#l1.56"></a><span id="l1.56">   </span>
<a href="#l1.57"></a><span id="l1.57">   this.deferredCount = 0;</span>
<a href="#l1.58"></a><span id="l1.58">   this.resolvedCount = 0;</span>
<a href="#l1.59"></a><span id="l1.59">   </span>
<a href="#l1.60"></a><span id="l1.60">   if (aMasterCollection) {</span>
<a href="#l1.61"></a><span id="l1.61" class="difflineminus">-    this.masterCollection = aMasterCollection;</span>
<a href="#l1.62"></a><span id="l1.62" class="difflineplus">+    this.masterCollection = aMasterCollection.masterCollection;</span>
<a href="#l1.63"></a><span id="l1.63">   }</span>
<a href="#l1.64"></a><span id="l1.64">   else {</span>
<a href="#l1.65"></a><span id="l1.65">     this.masterCollection = this;</span>
<a href="#l1.66"></a><span id="l1.66">     this.referencesByNounID = {};</span>
<a href="#l1.67"></a><span id="l1.67">     this.inverseReferencesByNounID = {};</span>
<a href="#l1.68"></a><span id="l1.68">     this.subCollections = {};</span>
<a href="#l1.69"></a><span id="l1.69">   }</span>
<a href="#l1.70"></a><span id="l1.70"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -116,181 +116,248 @@ PostCommitHandler.prototype = {</span>
<a href="#l2.4"></a><span id="l2.4">     }</span>
<a href="#l2.5"></a><span id="l2.5">     GlodaDatastore._asyncCompleted();</span>
<a href="#l2.6"></a><span id="l2.6">   }</span>
<a href="#l2.7"></a><span id="l2.7"> };</span>
<a href="#l2.8"></a><span id="l2.8"> </span>
<a href="#l2.9"></a><span id="l2.9"> let QFQ_LOG = Log4Moz.Service.getLogger(&quot;gloda.ds.qfq&quot;);</span>
<a href="#l2.10"></a><span id="l2.10"> </span>
<a href="#l2.11"></a><span id="l2.11"> let QueryFromQueryResolver = {</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-  onItemsAdded: function(aItems, aCollection, aFake) {</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+  onItemsAdded: function(aIgnoredItems, aCollection, aFake) {</span>
<a href="#l2.14"></a><span id="l2.14">     let originColl = aCollection.data;</span>
<a href="#l2.15"></a><span id="l2.15"> </span>
<a href="#l2.16"></a><span id="l2.16">     if (!aFake) {</span>
<a href="#l2.17"></a><span id="l2.17">       originColl.deferredCount--;</span>
<a href="#l2.18"></a><span id="l2.18">       originColl.resolvedCount++;</span>
<a href="#l2.19"></a><span id="l2.19">     }</span>
<a href="#l2.20"></a><span id="l2.20">     </span>
<a href="#l2.21"></a><span id="l2.21">     // bail if we are still pending on some other load completion</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineminus">-    if (originColl.deferredCount &gt; 0)</span>
<a href="#l2.23"></a><span id="l2.23" class="difflineplus">+    if (originColl.deferredCount &gt; 0) {</span>
<a href="#l2.24"></a><span id="l2.24" class="difflineplus">+      QFQ_LOG.debug(&quot;QFQR: bailing &quot; + originColl._nounDef.name);</span>
<a href="#l2.25"></a><span id="l2.25">       return;</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineplus">+    }</span>
<a href="#l2.27"></a><span id="l2.27">     </span>
<a href="#l2.28"></a><span id="l2.28">     let referencesByNounID = originColl.masterCollection.referencesByNounID;</span>
<a href="#l2.29"></a><span id="l2.29">     let inverseReferencesByNounID = </span>
<a href="#l2.30"></a><span id="l2.30" class="difflineminus">-      originColl.masterCollection.inverseReferencesByNounID</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+      originColl.masterCollection.inverseReferencesByNounID;</span>
<a href="#l2.32"></a><span id="l2.32"> </span>
<a href="#l2.33"></a><span id="l2.33" class="difflineminus">-    QFQ_LOG.debug(&quot;QFQR: onItemsAdded: &quot; + originColl._nounDef.name);</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineminus">-    </span>
<a href="#l2.35"></a><span id="l2.35" class="difflineminus">-    for (let [, item] in Iterator(originColl.pendingItems)) {</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineminus">-      GlodaDatastore.loadNounDeferredDeps(item, referencesByNounID,</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineminus">-          inverseReferencesByNounID);</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+    if (originColl.pendingItems) {</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineplus">+      for (let [, item] in Iterator(originColl.pendingItems)) {</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineplus">+        GlodaDatastore.loadNounDeferredDeps(item, referencesByNounID,</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineplus">+            inverseReferencesByNounID);</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineplus">+      }</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineplus">+      </span>
<a href="#l2.44"></a><span id="l2.44" class="difflineplus">+      // we need to consider the possibility that we are racing a collection very</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineplus">+      //  much like our own.  as such, this means we need to perform cache</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+      //  unification as our last step.</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineplus">+      GlodaCollectionManager.cacheLoadUnify(originColl._nounDef.id,</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineplus">+        originColl.pendingItems, false);</span>
<a href="#l2.49"></a><span id="l2.49" class="difflineplus">+  </span>
<a href="#l2.50"></a><span id="l2.50" class="difflineplus">+      // just directly tell the collection about the items.  we know the query</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineplus">+      //  matches (at least until we introduce predicates that we cannot express</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineplus">+      //  in SQL.)</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineplus">+      QFQ_LOG.debug(&quot; QFQR: about to trigger listener: &quot; + originColl._listener +</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineplus">+          &quot;with collection: &quot; + originColl._nounDef.name);</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+      originColl._onItemsAdded(originColl.pendingItems);</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+      delete originColl.pendingItems;</span>
<a href="#l2.57"></a><span id="l2.57">     }</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineminus">-    </span>
<a href="#l2.59"></a><span id="l2.59" class="difflineminus">-    // we need to consider the possibility that we are racing a collection very</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineminus">-    //  much like our own.  as such, this means we need to perform cache</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineminus">-    //  unification as our last step.</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineminus">-    GlodaCollectionManager.cacheLoadUnify(originColl._nounDef.id,</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineminus">-      originColl.pendingItems, false);</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineminus">-</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineminus">-    // just directly tell the collection about the items.  we know the query</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineminus">-    //  matches (at least until we introduce predicates that we cannot express</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineminus">-    //  in SQL.)</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineminus">-    originColl._onItemsAdded(originColl.pendingItems);</span>
<a href="#l2.69"></a><span id="l2.69" class="difflineminus">-    delete originColl.pendingItems;</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineminus">-    </span>
<a href="#l2.71"></a><span id="l2.71" class="difflineminus">-    originColl._onQueryCompleted();</span>
<a href="#l2.72"></a><span id="l2.72">   },</span>
<a href="#l2.73"></a><span id="l2.73">   onItemsModified: function() {</span>
<a href="#l2.74"></a><span id="l2.74">   },</span>
<a href="#l2.75"></a><span id="l2.75">   onItemsRemoved: function() {</span>
<a href="#l2.76"></a><span id="l2.76">   },</span>
<a href="#l2.77"></a><span id="l2.77" class="difflineminus">-  onQueryCompleted: function() {</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineplus">+  onQueryCompleted: function(aCollection) {</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineplus">+    let originColl = aCollection.data;</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineplus">+    if (originColl.deferredCount &lt;= 0) {</span>
<a href="#l2.81"></a><span id="l2.81" class="difflineplus">+      originColl._onQueryCompleted();</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineplus">+    }</span>
<a href="#l2.83"></a><span id="l2.83">   },</span>
<a href="#l2.84"></a><span id="l2.84"> };</span>
<a href="#l2.85"></a><span id="l2.85"> </span>
<a href="#l2.86"></a><span id="l2.86"> /**</span>
<a href="#l2.87"></a><span id="l2.87">  * @class Handles the results from a GlodaDatastore.queryFromQuery call.</span>
<a href="#l2.88"></a><span id="l2.88">  * @constructor</span>
<a href="#l2.89"></a><span id="l2.89">  */</span>
<a href="#l2.90"></a><span id="l2.90"> function QueryFromQueryCallback(aStatement, aNounDef, aCollection) {</span>
<a href="#l2.91"></a><span id="l2.91">   this.statement = aStatement;</span>
<a href="#l2.92"></a><span id="l2.92">   this.nounDef = aNounDef;</span>
<a href="#l2.93"></a><span id="l2.93">   this.collection = aCollection;</span>
<a href="#l2.94"></a><span id="l2.94">   </span>
<a href="#l2.95"></a><span id="l2.95">   QFQ_LOG.debug(&quot;Creating QFQCallback for noun: &quot; + aNounDef.name);</span>
<a href="#l2.96"></a><span id="l2.96">   </span>
<a href="#l2.97"></a><span id="l2.97">   // the master collection holds the referencesByNounID</span>
<a href="#l2.98"></a><span id="l2.98" class="difflineminus">-  this.referencesByNounID =</span>
<a href="#l2.99"></a><span id="l2.99" class="difflineplus">+  this.referencesByNounID = {};</span>
<a href="#l2.100"></a><span id="l2.100" class="difflineplus">+  this.masterReferencesByNounID =</span>
<a href="#l2.101"></a><span id="l2.101">     this.collection.masterCollection.referencesByNounID;</span>
<a href="#l2.102"></a><span id="l2.102" class="difflineminus">-  this.inverseReferencesByNounID =</span>
<a href="#l2.103"></a><span id="l2.103" class="difflineplus">+  this.inverseReferencesByNounID = {};</span>
<a href="#l2.104"></a><span id="l2.104" class="difflineplus">+  this.masterInverseReferencesByNounID =</span>
<a href="#l2.105"></a><span id="l2.105">     this.collection.masterCollection.inverseReferencesByNounID;</span>
<a href="#l2.106"></a><span id="l2.106">   // we need to contribute our references as we load things; we need this </span>
<a href="#l2.107"></a><span id="l2.107">   //  because of the potential for circular dependencies and our inability to</span>
<a href="#l2.108"></a><span id="l2.108">   //  put things into the caching layer (or collection's _idMap) until we have</span>
<a href="#l2.109"></a><span id="l2.109">   //  fully resolved things.</span>
<a href="#l2.110"></a><span id="l2.110" class="difflineminus">-  if (this.nounDef.id in this.referencesByNounID)</span>
<a href="#l2.111"></a><span id="l2.111" class="difflineminus">-    this.selfReferences = this.referencesByNounID[this.nounDef.id];</span>
<a href="#l2.112"></a><span id="l2.112" class="difflineplus">+  if (this.nounDef.id in this.masterReferencesByNounID)</span>
<a href="#l2.113"></a><span id="l2.113" class="difflineplus">+    this.selfReferences = this.masterReferencesByNounID[this.nounDef.id];</span>
<a href="#l2.114"></a><span id="l2.114">   else</span>
<a href="#l2.115"></a><span id="l2.115" class="difflineminus">-    this.selfReferences = this.referencesByNounID[this.nounDef.id] = {};</span>
<a href="#l2.116"></a><span id="l2.116" class="difflineplus">+    this.selfReferences = this.masterReferencesByNounID[this.nounDef.id] = {};</span>
<a href="#l2.117"></a><span id="l2.117" class="difflineplus">+  if (this.nounDef.parentColumnAttr) {</span>
<a href="#l2.118"></a><span id="l2.118" class="difflineplus">+    if (this.nounDef.id in this.masterInverseReferencesByNounID)</span>
<a href="#l2.119"></a><span id="l2.119" class="difflineplus">+      this.selfInverseReferences =</span>
<a href="#l2.120"></a><span id="l2.120" class="difflineplus">+        this.masterInverseReferencesByNounID[this.nounDef.id];</span>
<a href="#l2.121"></a><span id="l2.121" class="difflineplus">+    else</span>
<a href="#l2.122"></a><span id="l2.122" class="difflineplus">+      this.selfInverseReferences =</span>
<a href="#l2.123"></a><span id="l2.123" class="difflineplus">+        this.masterInverseReferencesByNounID[this.nounDef.id] = {};</span>
<a href="#l2.124"></a><span id="l2.124" class="difflineplus">+  }</span>
<a href="#l2.125"></a><span id="l2.125" class="difflineplus">+  </span>
<a href="#l2.126"></a><span id="l2.126" class="difflineplus">+  this.needsLoads = false;</span>
<a href="#l2.127"></a><span id="l2.127">   </span>
<a href="#l2.128"></a><span id="l2.128">   GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l2.129"></a><span id="l2.129"> }</span>
<a href="#l2.130"></a><span id="l2.130"> </span>
<a href="#l2.131"></a><span id="l2.131"> QueryFromQueryCallback.prototype = {</span>
<a href="#l2.132"></a><span id="l2.132">   handleResult: function gloda_ds_qfq_handleResult(aResultSet) {</span>
<a href="#l2.133"></a><span id="l2.133">     let pendingItems = this.collection.pendingItems;</span>
<a href="#l2.134"></a><span id="l2.134">     let row;</span>
<a href="#l2.135"></a><span id="l2.135">     let nounDef = this.nounDef;</span>
<a href="#l2.136"></a><span id="l2.136">     let nounID = nounDef.id;</span>
<a href="#l2.137"></a><span id="l2.137">     while (row = aResultSet.getNextRow()) {</span>
<a href="#l2.138"></a><span id="l2.138">       let item = nounDef.objFromRow.call(nounDef.datastore, row);</span>
<a href="#l2.139"></a><span id="l2.139" class="difflineplus">+QFQ_LOG.debug(&quot;loading item &quot; + nounDef.id + &quot;:&quot; + item.id + &quot; existing: &quot; +</span>
<a href="#l2.140"></a><span id="l2.140" class="difflineplus">+    this.selfReferences[item.id]);</span>
<a href="#l2.141"></a><span id="l2.141">       // try and replace the item with one from the cache, if we can</span>
<a href="#l2.142"></a><span id="l2.142">       let cachedItem = GlodaCollectionManager.cacheLookupOne(nounID, item.id,</span>
<a href="#l2.143"></a><span id="l2.143">                                                              false);</span>
<a href="#l2.144"></a><span id="l2.144">       if (cachedItem)</span>
<a href="#l2.145"></a><span id="l2.145">         item = cachedItem;</span>
<a href="#l2.146"></a><span id="l2.146" class="difflineplus">+      // we may already have been loaded by this process</span>
<a href="#l2.147"></a><span id="l2.147" class="difflineplus">+      else if (this.selfReferences[item.id] != null)</span>
<a href="#l2.148"></a><span id="l2.148" class="difflineplus">+        item = this.selfReferences[item.id];</span>
<a href="#l2.149"></a><span id="l2.149">       // perform loading logic which may produce reference dependencies</span>
<a href="#l2.150"></a><span id="l2.150" class="difflineminus">-      else if (nounDef.allowsArbitraryAttrs) </span>
<a href="#l2.151"></a><span id="l2.151" class="difflineminus">-        GlodaDatastore.loadNounItem(item, this.referencesByNounID,</span>
<a href="#l2.152"></a><span id="l2.152" class="difflineminus">-            this.inverseReferencesByNounID);</span>
<a href="#l2.153"></a><span id="l2.153" class="difflineplus">+      else</span>
<a href="#l2.154"></a><span id="l2.154" class="difflineplus">+        this.needsLoads = this.needsLoads ||</span>
<a href="#l2.155"></a><span id="l2.155" class="difflineplus">+          GlodaDatastore.loadNounItem(item, this.referencesByNounID,</span>
<a href="#l2.156"></a><span id="l2.156" class="difflineplus">+                                      this.inverseReferencesByNounID);</span>
<a href="#l2.157"></a><span id="l2.157">       </span>
<a href="#l2.158"></a><span id="l2.158" class="difflineplus">+      // add ourself to the references by our id</span>
<a href="#l2.159"></a><span id="l2.159">       this.selfReferences[item.id] = item;</span>
<a href="#l2.160"></a><span id="l2.160" class="difflineplus">+      // if we're tracking it, add ourselves to our parent's list of children</span>
<a href="#l2.161"></a><span id="l2.161" class="difflineplus">+      //  too</span>
<a href="#l2.162"></a><span id="l2.162" class="difflineplus">+      if (this.selfInverseReferences) {</span>
<a href="#l2.163"></a><span id="l2.163" class="difflineplus">+        let parentID = item[nounDef.parentColumnAttr.idStorageAttributeName];</span>
<a href="#l2.164"></a><span id="l2.164" class="difflineplus">+        let childrenList = this.selfInverseReferences[parentID];</span>
<a href="#l2.165"></a><span id="l2.165" class="difflineplus">+        if (childrenList === undefined)</span>
<a href="#l2.166"></a><span id="l2.166" class="difflineplus">+          childrenList = this.selfInverseReferences[parentID] = [];</span>
<a href="#l2.167"></a><span id="l2.167" class="difflineplus">+        childrenList.push(item);</span>
<a href="#l2.168"></a><span id="l2.168" class="difflineplus">+      }</span>
<a href="#l2.169"></a><span id="l2.169" class="difflineplus">+      </span>
<a href="#l2.170"></a><span id="l2.170">       pendingItems.push(item);</span>
<a href="#l2.171"></a><span id="l2.171">     }</span>
<a href="#l2.172"></a><span id="l2.172">   },</span>
<a href="#l2.173"></a><span id="l2.173"> </span>
<a href="#l2.174"></a><span id="l2.174">   handleError: function gloda_ds_qfq_handleError(aError) {</span>
<a href="#l2.175"></a><span id="l2.175">     GlodaDatastore._log.error(&quot;Async queryFromQuery error: &quot; +</span>
<a href="#l2.176"></a><span id="l2.176">       aError.result + &quot;: &quot; + aError.message);</span>
<a href="#l2.177"></a><span id="l2.177">   },</span>
<a href="#l2.178"></a><span id="l2.178"> </span>
<a href="#l2.179"></a><span id="l2.179">   handleCompletion: function gloda_ds_qfq_handleCompletion(aReason) {</span>
<a href="#l2.180"></a><span id="l2.180">     this.statement.finalize();</span>
<a href="#l2.181"></a><span id="l2.181">     this.statement = null;</span>
<a href="#l2.182"></a><span id="l2.182">     </span>
<a href="#l2.183"></a><span id="l2.183">     QFQ_LOG.debug(&quot;handleCompletion: &quot; + this.collection._nounDef.name);</span>
<a href="#l2.184"></a><span id="l2.184">     </span>
<a href="#l2.185"></a><span id="l2.185" class="difflineminus">-    for each (let [nounID, references] in Iterator(this.referencesByNounID)) {</span>
<a href="#l2.186"></a><span id="l2.186" class="difflineminus">-      if (nounID == this.nounDef.id)</span>
<a href="#l2.187"></a><span id="l2.187" class="difflineminus">-        continue;</span>
<a href="#l2.188"></a><span id="l2.188" class="difflineminus">-      let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l2.189"></a><span id="l2.189" class="difflineminus">-      QFQ_LOG.debug(&quot;  have references for noun: &quot; + nounDef.name);</span>
<a href="#l2.190"></a><span id="l2.190" class="difflineminus">-      // try and load them out of the cache/existing collections.  items in the</span>
<a href="#l2.191"></a><span id="l2.191" class="difflineminus">-      //  cache will be fully formed, which is nice for us.</span>
<a href="#l2.192"></a><span id="l2.192" class="difflineminus">-      // XXX this mechanism will get dubious when we have multiple paths to a</span>
<a href="#l2.193"></a><span id="l2.193" class="difflineminus">-      //  single noun-type.  For example, a -&gt; b -&gt; c, a-&gt; c; two paths to c</span>
<a href="#l2.194"></a><span id="l2.194" class="difflineminus">-      //  and we're looking at issuing two requests to c, the latter of which</span>
<a href="#l2.195"></a><span id="l2.195" class="difflineminus">-      //  will be a superset of the first one.  This does not currently pose</span>
<a href="#l2.196"></a><span id="l2.196" class="difflineminus">-      //  a problem because we only have a -&gt; b -&gt; c -&gt; b, and sequential</span>
<a href="#l2.197"></a><span id="l2.197" class="difflineminus">-      //  processing means no alarms and no surprises.</span>
<a href="#l2.198"></a><span id="l2.198" class="difflineminus">-      let [foundCount, notFoundCount, notFound] =</span>
<a href="#l2.199"></a><span id="l2.199" class="difflineminus">-        GlodaCollectionManager.cacheLookupMany(nounDef.id, references);</span>
<a href="#l2.200"></a><span id="l2.200" class="difflineminus">-      QFQ_LOG.debug(&quot;  found: &quot; + foundCount + &quot; not found: &quot; + notFoundCount);</span>
<a href="#l2.201"></a><span id="l2.201" class="difflineminus">-      if (notFoundCount === 0) {</span>
<a href="#l2.202"></a><span id="l2.202" class="difflineminus">-        this.collection.resolvedCount++;</span>
<a href="#l2.203"></a><span id="l2.203" class="difflineplus">+    if (this.needsLoads) {</span>
<a href="#l2.204"></a><span id="l2.204" class="difflineplus">+      for each (let [nounID, references] in Iterator(this.referencesByNounID)) {</span>
<a href="#l2.205"></a><span id="l2.205" class="difflineplus">+        if (nounID == this.nounDef.id)</span>
<a href="#l2.206"></a><span id="l2.206" class="difflineplus">+          continue;</span>
<a href="#l2.207"></a><span id="l2.207" class="difflineplus">+        let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l2.208"></a><span id="l2.208" class="difflineplus">+        QFQ_LOG.debug(&quot;  have references for noun: &quot; + nounDef.name);</span>
<a href="#l2.209"></a><span id="l2.209" class="difflineplus">+        // try and load them out of the cache/existing collections.  items in the</span>
<a href="#l2.210"></a><span id="l2.210" class="difflineplus">+        //  cache will be fully formed, which is nice for us.</span>
<a href="#l2.211"></a><span id="l2.211" class="difflineplus">+        // XXX this mechanism will get dubious when we have multiple paths to a</span>
<a href="#l2.212"></a><span id="l2.212" class="difflineplus">+        //  single noun-type.  For example, a -&gt; b -&gt; c, a-&gt; c; two paths to c</span>
<a href="#l2.213"></a><span id="l2.213" class="difflineplus">+        //  and we're looking at issuing two requests to c, the latter of which</span>
<a href="#l2.214"></a><span id="l2.214" class="difflineplus">+        //  will be a superset of the first one.  This does not currently pose</span>
<a href="#l2.215"></a><span id="l2.215" class="difflineplus">+        //  a problem because we only have a -&gt; b -&gt; c -&gt; b, and sequential</span>
<a href="#l2.216"></a><span id="l2.216" class="difflineplus">+        //  processing means no alarms and no surprises.</span>
<a href="#l2.217"></a><span id="l2.217" class="difflineplus">+        let masterReferences = this.masterReferencesByNounID[nounID];</span>
<a href="#l2.218"></a><span id="l2.218" class="difflineplus">+        if (masterReferences === undefined)</span>
<a href="#l2.219"></a><span id="l2.219" class="difflineplus">+          masterReferences = this.masterReferencesByNounID[nounID] = {};</span>
<a href="#l2.220"></a><span id="l2.220" class="difflineplus">+        let outReferences;</span>
<a href="#l2.221"></a><span id="l2.221" class="difflineplus">+        if (this.selfInverseReferences)</span>
<a href="#l2.222"></a><span id="l2.222" class="difflineplus">+          outReferences = {};</span>
<a href="#l2.223"></a><span id="l2.223" class="difflineplus">+        else</span>
<a href="#l2.224"></a><span id="l2.224" class="difflineplus">+          outReferences = masterReferences;</span>
<a href="#l2.225"></a><span id="l2.225" class="difflineplus">+        let [foundCount, notFoundCount, notFound] =</span>
<a href="#l2.226"></a><span id="l2.226" class="difflineplus">+          GlodaCollectionManager.cacheLookupMany(nounDef.id, references,</span>
<a href="#l2.227"></a><span id="l2.227" class="difflineplus">+              outReferences);</span>
<a href="#l2.228"></a><span id="l2.228" class="difflineplus">+</span>
<a href="#l2.229"></a><span id="l2.229" class="difflineplus">+        if (this.selfInverseReferences) {</span>
<a href="#l2.230"></a><span id="l2.230" class="difflineplus">+          for each (let item in outReferences) {</span>
<a href="#l2.231"></a><span id="l2.231" class="difflineplus">+            masterReferences[item.id] = item;</span>
<a href="#l2.232"></a><span id="l2.232" class="difflineplus">+            let parentID = item[nounDef.parentColumnAttr.idStorageAttributeName];</span>
<a href="#l2.233"></a><span id="l2.233" class="difflineplus">+            let childrenList = this.selfInverseReferences[parentID];</span>
<a href="#l2.234"></a><span id="l2.234" class="difflineplus">+            if (childrenList === undefined)</span>
<a href="#l2.235"></a><span id="l2.235" class="difflineplus">+              childrenList = this.selfInverseReferences[parentID] = [];</span>
<a href="#l2.236"></a><span id="l2.236" class="difflineplus">+            childrenList.push(item);</span>
<a href="#l2.237"></a><span id="l2.237" class="difflineplus">+          }</span>
<a href="#l2.238"></a><span id="l2.238" class="difflineplus">+        }</span>
<a href="#l2.239"></a><span id="l2.239" class="difflineplus">+        </span>
<a href="#l2.240"></a><span id="l2.240" class="difflineplus">+        QFQ_LOG.debug(&quot;  found: &quot; + foundCount + &quot; not found: &quot; + notFoundCount);</span>
<a href="#l2.241"></a><span id="l2.241" class="difflineplus">+        if (notFoundCount === 0) {</span>
<a href="#l2.242"></a><span id="l2.242" class="difflineplus">+          this.collection.resolvedCount++;</span>
<a href="#l2.243"></a><span id="l2.243" class="difflineplus">+        }</span>
<a href="#l2.244"></a><span id="l2.244" class="difflineplus">+        else {</span>
<a href="#l2.245"></a><span id="l2.245" class="difflineplus">+          this.collection.deferredCount++;</span>
<a href="#l2.246"></a><span id="l2.246" class="difflineplus">+          let query = new nounDef.queryClass();</span>
<a href="#l2.247"></a><span id="l2.247" class="difflineplus">+          query.id.apply(query, [id for (id in notFound)]);</span>
<a href="#l2.248"></a><span id="l2.248" class="difflineplus">+          </span>
<a href="#l2.249"></a><span id="l2.249" class="difflineplus">+          this.collection.masterCollection.subCollections[nounDef.id] = </span>
<a href="#l2.250"></a><span id="l2.250" class="difflineplus">+            GlodaDatastore.queryFromQuery(query, QueryFromQueryResolver, </span>
<a href="#l2.251"></a><span id="l2.251" class="difflineplus">+              this.collection,</span>
<a href="#l2.252"></a><span id="l2.252" class="difflineplus">+              // we fully expect/allow for there being no such subcollection yet.</span>
<a href="#l2.253"></a><span id="l2.253" class="difflineplus">+              this.collection.masterCollection.subCollections[nounDef.id],</span>
<a href="#l2.254"></a><span id="l2.254" class="difflineplus">+              this.collection.masterCollection);</span>
<a href="#l2.255"></a><span id="l2.255" class="difflineplus">+        }</span>
<a href="#l2.256"></a><span id="l2.256">       }</span>
<a href="#l2.257"></a><span id="l2.257" class="difflineminus">-      else {</span>
<a href="#l2.258"></a><span id="l2.258" class="difflineplus">+      </span>
<a href="#l2.259"></a><span id="l2.259" class="difflineplus">+      for each (let [nounID, inverseReferences] in</span>
<a href="#l2.260"></a><span id="l2.260" class="difflineplus">+          Iterator(this.inverseReferencesByNounID)) {</span>
<a href="#l2.261"></a><span id="l2.261">         this.collection.deferredCount++;</span>
<a href="#l2.262"></a><span id="l2.262" class="difflineplus">+        let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l2.263"></a><span id="l2.263" class="difflineplus">+        </span>
<a href="#l2.264"></a><span id="l2.264" class="difflineplus">+        QFQ_LOG.debug(&quot;Want to load inverse via &quot; + nounDef.parentColumnAttr.boundName);</span>
<a href="#l2.265"></a><span id="l2.265" class="difflineplus">+  </span>
<a href="#l2.266"></a><span id="l2.266">         let query = new nounDef.queryClass();</span>
<a href="#l2.267"></a><span id="l2.267" class="difflineminus">-        query.id.apply(query, [id for (id in notFound)]);</span>
<a href="#l2.268"></a><span id="l2.268" class="difflineminus">-        </span>
<a href="#l2.269"></a><span id="l2.269" class="difflineplus">+        // we want to constrain using the parent column</span>
<a href="#l2.270"></a><span id="l2.270" class="difflineplus">+        let queryConstrainer = query[nounDef.parentColumnAttr.boundName];</span>
<a href="#l2.271"></a><span id="l2.271" class="difflineplus">+        queryConstrainer.apply(query, [pid for (pid in inverseReferences)]);</span>
<a href="#l2.272"></a><span id="l2.272">         this.collection.masterCollection.subCollections[nounDef.id] = </span>
<a href="#l2.273"></a><span id="l2.273" class="difflineminus">-          GlodaDatastore.queryFromQuery(query, null, this.collection,</span>
<a href="#l2.274"></a><span id="l2.274" class="difflineplus">+          GlodaDatastore.queryFromQuery(query, QueryFromQueryResolver,</span>
<a href="#l2.275"></a><span id="l2.275" class="difflineplus">+            this.collection,</span>
<a href="#l2.276"></a><span id="l2.276">             // we fully expect/allow for there being no such subcollection yet.</span>
<a href="#l2.277"></a><span id="l2.277">             this.collection.masterCollection.subCollections[nounDef.id],</span>
<a href="#l2.278"></a><span id="l2.278">             this.collection.masterCollection);</span>
<a href="#l2.279"></a><span id="l2.279">       }</span>
<a href="#l2.280"></a><span id="l2.280">     }</span>
<a href="#l2.281"></a><span id="l2.281" class="difflineminus">-    </span>
<a href="#l2.282"></a><span id="l2.282" class="difflineminus">-    for each (let [nounID, inverseReferencess] in</span>
<a href="#l2.283"></a><span id="l2.283" class="difflineminus">-        Iterator(this.inverseReferencesByNounID)) {</span>
<a href="#l2.284"></a><span id="l2.284" class="difflineminus">-      this.collection.deferredCount++;</span>
<a href="#l2.285"></a><span id="l2.285" class="difflineminus">-      let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l2.286"></a><span id="l2.286" class="difflineminus">-</span>
<a href="#l2.287"></a><span id="l2.287" class="difflineminus">-      let query = nounDef.queryClass();</span>
<a href="#l2.288"></a><span id="l2.288" class="difflineminus">-      // we want to constrain using the parent column</span>
<a href="#l2.289"></a><span id="l2.289" class="difflineminus">-      let queryConstrainer = query[nounDef.parentColumnAttr.boundName];</span>
<a href="#l2.290"></a><span id="l2.290" class="difflineminus">-      queryConstrainer.apply(query, [pid for (pid in inverseReferences)]);</span>
<a href="#l2.291"></a><span id="l2.291" class="difflineminus">-      this.collection.masterCollection.subCollections[nounDef.id] = </span>
<a href="#l2.292"></a><span id="l2.292" class="difflineminus">-        GlodaDatastore.queryFromQuery(query, null, this.collection,</span>
<a href="#l2.293"></a><span id="l2.293" class="difflineminus">-          // we fully expect/allow for there being no such subcollection yet.</span>
<a href="#l2.294"></a><span id="l2.294" class="difflineminus">-          this.collection.masterCollection.subCollections[nounDef.id],</span>
<a href="#l2.295"></a><span id="l2.295" class="difflineminus">-          this.collection.masterCollection);</span>
<a href="#l2.296"></a><span id="l2.296" class="difflineplus">+    else {</span>
<a href="#l2.297"></a><span id="l2.297" class="difflineplus">+      this.collection.deferredCount--;</span>
<a href="#l2.298"></a><span id="l2.298" class="difflineplus">+      this.collection.resolvedCount++;</span>
<a href="#l2.299"></a><span id="l2.299">     }</span>
<a href="#l2.300"></a><span id="l2.300">     </span>
<a href="#l2.301"></a><span id="l2.301">     QFQ_LOG.debug(&quot;  defer: &quot; + this.collection.deferredCount +</span>
<a href="#l2.302"></a><span id="l2.302">                   &quot; resolved: &quot; + this.collection.resolvedCount);</span>
<a href="#l2.303"></a><span id="l2.303">     </span>
<a href="#l2.304"></a><span id="l2.304">     // process immediately and kick-up to the master collection...</span>
<a href="#l2.305"></a><span id="l2.305" class="difflineminus">-    if (!this.collection.deferredCount) {</span>
<a href="#l2.306"></a><span id="l2.306" class="difflineplus">+    if (this.collection.deferredCount &lt;= 0) {</span>
<a href="#l2.307"></a><span id="l2.307">       // this guy will resolve everyone using referencesByNounID and issue the</span>
<a href="#l2.308"></a><span id="l2.308">       //  call to this.collection._onItemsAdded to propagate things to the</span>
<a href="#l2.309"></a><span id="l2.309">       //  next concerned subCollection or the actual listener if this is the</span>
<a href="#l2.310"></a><span id="l2.310">       //  master collection.  (Also, call _onQueryCompleted).</span>
<a href="#l2.311"></a><span id="l2.311">       QueryFromQueryResolver.onItemsAdded(null, {data: this.collection}, true);</span>
<a href="#l2.312"></a><span id="l2.312" class="difflineplus">+      QueryFromQueryResolver.onQueryCompleted({data: this.collection});</span>
<a href="#l2.313"></a><span id="l2.313">     }</span>
<a href="#l2.314"></a><span id="l2.314"> </span>
<a href="#l2.315"></a><span id="l2.315">     GlodaDatastore._asyncCompleted();</span>
<a href="#l2.316"></a><span id="l2.316">   }</span>
<a href="#l2.317"></a><span id="l2.317"> };</span>
<a href="#l2.318"></a><span id="l2.318"> </span>
<a href="#l2.319"></a><span id="l2.319"> </span>
<a href="#l2.320"></a><span id="l2.320"> /**</span>
<a href="#l2.321"></a><span id="l2.321" class="difflineat">@@ -2381,17 +2448,17 @@ var GlodaDatastore = {</span>
<a href="#l2.322"></a><span id="l2.322">    *  a set of constraints relating to the noun type associated with the query.</span>
<a href="#l2.323"></a><span id="l2.323">    *  A GlodaCollection is returned containing the results of the look-up.</span>
<a href="#l2.324"></a><span id="l2.324">    *  By default the collection is &quot;live&quot;, and will mutate (generating events to</span>
<a href="#l2.325"></a><span id="l2.325">    *  its listener) as the state of the database changes.</span>
<a href="#l2.326"></a><span id="l2.326">    * This functionality is made user/extension visible by the Query's</span>
<a href="#l2.327"></a><span id="l2.327">    *  getCollection (asynchronous).</span>
<a href="#l2.328"></a><span id="l2.328">    */</span>
<a href="#l2.329"></a><span id="l2.329">   queryFromQuery: function gloda_ds_queryFromQuery(aQuery, aListener,</span>
<a href="#l2.330"></a><span id="l2.330" class="difflineminus">-      aListenerData, aExistingCollection) {</span>
<a href="#l2.331"></a><span id="l2.331" class="difflineplus">+      aListenerData, aExistingCollection, aMasterCollection) {</span>
<a href="#l2.332"></a><span id="l2.332">     // when changing this method, be sure that GlodaQuery's testMatch function</span>
<a href="#l2.333"></a><span id="l2.333">     //  likewise has its changes made.</span>
<a href="#l2.334"></a><span id="l2.334">     let nounDef = aQuery._nounDef;</span>
<a href="#l2.335"></a><span id="l2.335"> </span>
<a href="#l2.336"></a><span id="l2.336">     let whereClauses = [];</span>
<a href="#l2.337"></a><span id="l2.337">     let unionQueries = [aQuery].concat(aQuery._unions);</span>
<a href="#l2.338"></a><span id="l2.338">     let boundArgs = [];</span>
<a href="#l2.339"></a><span id="l2.339"> </span>
<a href="#l2.340"></a><span id="l2.340" class="difflineat">@@ -2441,17 +2508,17 @@ var GlodaDatastore = {</span>
<a href="#l2.341"></a><span id="l2.341">               this._convertToDBValuesAndGroupByAttributeID(attrDef,</span>
<a href="#l2.342"></a><span id="l2.342">                                                            constraintValues)) {</span>
<a href="#l2.343"></a><span id="l2.343">             if (attrID !== undefined)</span>
<a href="#l2.344"></a><span id="l2.344">               clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l2.345"></a><span id="l2.345">                   &quot; AND &quot; + valueColumnName + &quot; IN (&quot; +</span>
<a href="#l2.346"></a><span id="l2.346">                   values.join(&quot;,&quot;) + &quot;))&quot;);</span>
<a href="#l2.347"></a><span id="l2.347">             else</span>
<a href="#l2.348"></a><span id="l2.348">               clauses.push(&quot;(&quot; + valueColumnName + &quot; IN (&quot; +</span>
<a href="#l2.349"></a><span id="l2.349" class="difflineminus">-                  values.join(&quot;,&quot;) + &quot;)&quot;);</span>
<a href="#l2.350"></a><span id="l2.350" class="difflineplus">+                  values.join(&quot;,&quot;) + &quot;))&quot;);</span>
<a href="#l2.351"></a><span id="l2.351">           }</span>
<a href="#l2.352"></a><span id="l2.352">           test = clauses.join(&quot; OR &quot;);</span>
<a href="#l2.353"></a><span id="l2.353">         }</span>
<a href="#l2.354"></a><span id="l2.354">         else if (constraintType === this.kConstraintRanges) {</span>
<a href="#l2.355"></a><span id="l2.355">           let clauses = [];</span>
<a href="#l2.356"></a><span id="l2.356">           for each ([attrID, dbStrings] in</span>
<a href="#l2.357"></a><span id="l2.357">               this._convertRangesToDBStringsAndGroupByAttributeID(attrDef,</span>
<a href="#l2.358"></a><span id="l2.358">                               constraintValues, valueColumnName)) {</span>
<a href="#l2.359"></a><span id="l2.359" class="difflineat">@@ -2537,77 +2604,103 @@ var GlodaDatastore = {</span>
<a href="#l2.360"></a><span id="l2.360">     if (aQuery._limit) {</span>
<a href="#l2.361"></a><span id="l2.361">       sqlString += &quot; LIMIT ?&quot;;</span>
<a href="#l2.362"></a><span id="l2.362">       boundArgs.push(aQuery._limit); </span>
<a href="#l2.363"></a><span id="l2.363">     }</span>
<a href="#l2.364"></a><span id="l2.364"> </span>
<a href="#l2.365"></a><span id="l2.365">     this._log.debug(&quot;QUERY FROM QUERY: &quot; + sqlString + &quot; ARGS: &quot; + boundArgs);</span>
<a href="#l2.366"></a><span id="l2.366">     </span>
<a href="#l2.367"></a><span id="l2.367">     return this._queryFromSQLString(sqlString, boundArgs, nounDef, aQuery,</span>
<a href="#l2.368"></a><span id="l2.368" class="difflineminus">-        aListener, aListenerData, aExistingCollection);</span>
<a href="#l2.369"></a><span id="l2.369" class="difflineplus">+        aListener, aListenerData, aExistingCollection, aMasterCollection);</span>
<a href="#l2.370"></a><span id="l2.370">   },</span>
<a href="#l2.371"></a><span id="l2.371">   </span>
<a href="#l2.372"></a><span id="l2.372">   _queryFromSQLString: function gloda_ds__queryFromSQLString(aSqlString,</span>
<a href="#l2.373"></a><span id="l2.373">       aBoundArgs, aNounDef, aQuery, aListener, aListenerData,</span>
<a href="#l2.374"></a><span id="l2.374" class="difflineminus">-      aExistingCollection) {</span>
<a href="#l2.375"></a><span id="l2.375" class="difflineplus">+      aExistingCollection, aMasterCollection) {</span>
<a href="#l2.376"></a><span id="l2.376">     let statement = this._createAsyncStatement(aSqlString, true);</span>
<a href="#l2.377"></a><span id="l2.377">     for (let [iBinding, bindingValue] in Iterator(aBoundArgs)) {</span>
<a href="#l2.378"></a><span id="l2.378">       this._bindVariant(statement, iBinding, bindingValue);</span>
<a href="#l2.379"></a><span id="l2.379">     }</span>
<a href="#l2.380"></a><span id="l2.380"> </span>
<a href="#l2.381"></a><span id="l2.381">     let collection;</span>
<a href="#l2.382"></a><span id="l2.382">     if (aExistingCollection)</span>
<a href="#l2.383"></a><span id="l2.383">       collection = aExistingCollection;</span>
<a href="#l2.384"></a><span id="l2.384">     else {</span>
<a href="#l2.385"></a><span id="l2.385" class="difflineminus">-      collection = new GlodaCollection(aNounDef, [], aQuery, aListener);</span>
<a href="#l2.386"></a><span id="l2.386" class="difflineplus">+      collection = new GlodaCollection(aNounDef, [], aQuery, aListener,</span>
<a href="#l2.387"></a><span id="l2.387" class="difflineplus">+                                       aMasterCollection);</span>
<a href="#l2.388"></a><span id="l2.388">       GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l2.389"></a><span id="l2.389" class="difflineplus">+      // we don't want to overwrite the existing listener or its data, but this</span>
<a href="#l2.390"></a><span id="l2.390" class="difflineplus">+      //  does raise the question about what should happen if we get passed in</span>
<a href="#l2.391"></a><span id="l2.391" class="difflineplus">+      //  a different listener and/or data.</span>
<a href="#l2.392"></a><span id="l2.392" class="difflineplus">+      if (aListenerData !== undefined)</span>
<a href="#l2.393"></a><span id="l2.393" class="difflineplus">+        collection.data = aListenerData;</span>
<a href="#l2.394"></a><span id="l2.394">     }</span>
<a href="#l2.395"></a><span id="l2.395" class="difflineminus">-    if (aListenerData !== undefined)</span>
<a href="#l2.396"></a><span id="l2.396" class="difflineminus">-      collection.data = aListenerData;</span>
<a href="#l2.397"></a><span id="l2.397"> </span>
<a href="#l2.398"></a><span id="l2.398">     statement.executeAsync(new QueryFromQueryCallback(statement, aNounDef,</span>
<a href="#l2.399"></a><span id="l2.399">       collection));</span>
<a href="#l2.400"></a><span id="l2.400">     statement.finalize();</span>
<a href="#l2.401"></a><span id="l2.401">     return collection;</span>
<a href="#l2.402"></a><span id="l2.402">   },</span>
<a href="#l2.403"></a><span id="l2.403"> </span>
<a href="#l2.404"></a><span id="l2.404">   /**</span>
<a href="#l2.405"></a><span id="l2.405">    * </span>
<a href="#l2.406"></a><span id="l2.406">    * </span>
<a href="#l2.407"></a><span id="l2.407">    */</span>
<a href="#l2.408"></a><span id="l2.408">   loadNounItem: function gloda_ds_loadNounItem(aItem, aReferencesByNounID,</span>
<a href="#l2.409"></a><span id="l2.409">       aInverseReferencesByNounID) {</span>
<a href="#l2.410"></a><span id="l2.410" class="difflineminus">-    this._log.debug(&quot; load json: &quot; + aItem._jsonText);</span>
<a href="#l2.411"></a><span id="l2.411" class="difflineminus">-    let jsonDict = this._json.decode(aItem._jsonText);</span>
<a href="#l2.412"></a><span id="l2.412" class="difflineminus">-    delete aItem._jsonText;</span>
<a href="#l2.413"></a><span id="l2.413" class="difflineminus">-    </span>
<a href="#l2.414"></a><span id="l2.414">     let attribIDToDBDefAndParam = this._attributeIDToDBDefAndParam;</span>
<a href="#l2.415"></a><span id="l2.415">     </span>
<a href="#l2.416"></a><span id="l2.416" class="difflineminus">-    let deps = {};</span>
<a href="#l2.417"></a><span id="l2.417" class="difflineplus">+    let hadDeps = aItem._deps != null;</span>
<a href="#l2.418"></a><span id="l2.418" class="difflineplus">+    let deps = aItem._deps || {};</span>
<a href="#l2.419"></a><span id="l2.419">     let hasDeps = false;</span>
<a href="#l2.420"></a><span id="l2.420">     </span>
<a href="#l2.421"></a><span id="l2.421">     for each (let [, attrib] in Iterator(aItem.NOUN_DEF.specialLoadAttribs)) {</span>
<a href="#l2.422"></a><span id="l2.422">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l2.423"></a><span id="l2.423">       </span>
<a href="#l2.424"></a><span id="l2.424">       if (attrib.special === this.kSpecialColumnChildren) {</span>
<a href="#l2.425"></a><span id="l2.425">         let invReferences = aInverseReferencesByNounID[objectNounDef.id];</span>
<a href="#l2.426"></a><span id="l2.426">         if (invReferences === undefined)</span>
<a href="#l2.427"></a><span id="l2.427">           invReferences = aInverseReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l2.428"></a><span id="l2.428" class="difflineminus">-        invReferences[aItem.id] = null;</span>
<a href="#l2.429"></a><span id="l2.429" class="difflineplus">+        // only contribute if it's not already pending or there</span>
<a href="#l2.430"></a><span id="l2.430" class="difflineplus">+        if (!(attrib.id in deps) &amp;&amp; aItem[attrib.storageAttributeName] == null){</span>
<a href="#l2.431"></a><span id="l2.431" class="difflineplus">+          this._log.debug(&quot;   Adding inv ref for: &quot; + aItem.id);</span>
<a href="#l2.432"></a><span id="l2.432" class="difflineplus">+          invReferences[aItem.id] = null;</span>
<a href="#l2.433"></a><span id="l2.433" class="difflineplus">+          deps[attrib.id] = null;</span>
<a href="#l2.434"></a><span id="l2.434" class="difflineplus">+          hasDeps = true;</span>
<a href="#l2.435"></a><span id="l2.435" class="difflineplus">+        }</span>
<a href="#l2.436"></a><span id="l2.436">       }</span>
<a href="#l2.437"></a><span id="l2.437">       else if (attrib.special === this.kSpecialColumnParent) {</span>
<a href="#l2.438"></a><span id="l2.438">         let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l2.439"></a><span id="l2.439">         if (references === undefined)</span>
<a href="#l2.440"></a><span id="l2.440">           references = aReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l2.441"></a><span id="l2.441" class="difflineminus">-        references[aItem[attrib.idStorageAttributeName]] = null;</span>
<a href="#l2.442"></a><span id="l2.442" class="difflineminus">-        deps[attrib.id] = null;</span>
<a href="#l2.443"></a><span id="l2.443" class="difflineminus">-        hasDeps = true;</span>
<a href="#l2.444"></a><span id="l2.444" class="difflineplus">+        // nothing to contribute if it's already there</span>
<a href="#l2.445"></a><span id="l2.445" class="difflineplus">+        if (!(attrib.id in deps) &amp;&amp; </span>
<a href="#l2.446"></a><span id="l2.446" class="difflineplus">+            aItem[attrib.valueStorageAttributeName] == null) {</span>
<a href="#l2.447"></a><span id="l2.447" class="difflineplus">+          references[aItem[attrib.idStorageAttributeName]] = null;</span>
<a href="#l2.448"></a><span id="l2.448" class="difflineplus">+          this._log.debug(&quot;   Adding parent ref for: &quot; +</span>
<a href="#l2.449"></a><span id="l2.449" class="difflineplus">+            aItem[attrib.idStorageAttributeName]);</span>
<a href="#l2.450"></a><span id="l2.450" class="difflineplus">+          deps[attrib.id] = null;</span>
<a href="#l2.451"></a><span id="l2.451" class="difflineplus">+          hasDeps = true;</span>
<a href="#l2.452"></a><span id="l2.452" class="difflineplus">+        }</span>
<a href="#l2.453"></a><span id="l2.453">       }</span>
<a href="#l2.454"></a><span id="l2.454">     }</span>
<a href="#l2.455"></a><span id="l2.455">     </span>
<a href="#l2.456"></a><span id="l2.456" class="difflineplus">+    // bail here if arbitrary values are not allowed, there just is no</span>
<a href="#l2.457"></a><span id="l2.457" class="difflineplus">+    //  encoded json, or we already had dependencies for this guy, implying</span>
<a href="#l2.458"></a><span id="l2.458" class="difflineplus">+    //  the json pass has already been performed</span>
<a href="#l2.459"></a><span id="l2.459" class="difflineplus">+    if (!aItem.NOUN_DEF.allowsArbitraryAttrs || !aItem._jsonText || hadDeps) {</span>
<a href="#l2.460"></a><span id="l2.460" class="difflineplus">+      if (hasDeps)</span>
<a href="#l2.461"></a><span id="l2.461" class="difflineplus">+        aItem._deps = deps;</span>
<a href="#l2.462"></a><span id="l2.462" class="difflineplus">+      return hasDeps;</span>
<a href="#l2.463"></a><span id="l2.463" class="difflineplus">+    }</span>
<a href="#l2.464"></a><span id="l2.464" class="difflineplus">+</span>
<a href="#l2.465"></a><span id="l2.465" class="difflineplus">+    this._log.debug(&quot; load json: &quot; + aItem._jsonText);</span>
<a href="#l2.466"></a><span id="l2.466" class="difflineplus">+    let jsonDict = this._json.decode(aItem._jsonText);</span>
<a href="#l2.467"></a><span id="l2.467" class="difflineplus">+    delete aItem._jsonText;</span>
<a href="#l2.468"></a><span id="l2.468" class="difflineplus">+    </span>
<a href="#l2.469"></a><span id="l2.469">     // Iterate over the attributes on the item</span>
<a href="#l2.470"></a><span id="l2.470">     for each (let [attribId, jsonValue] in Iterator(jsonDict)) {</span>
<a href="#l2.471"></a><span id="l2.471">       // find the attribute definition that corresponds to this key</span>
<a href="#l2.472"></a><span id="l2.472">       let dbAttrib = attribIDToDBDefAndParam[attribId][0];</span>
<a href="#l2.473"></a><span id="l2.473">       // the attribute should only fail to exist if an extension was removed</span>
<a href="#l2.474"></a><span id="l2.474">       if (dbAttrib === undefined)</span>
<a href="#l2.475"></a><span id="l2.475">         continue;</span>
<a href="#l2.476"></a><span id="l2.476">       </span>
<a href="#l2.477"></a><span id="l2.477" class="difflineat">@@ -2679,16 +2772,19 @@ var GlodaDatastore = {</span>
<a href="#l2.478"></a><span id="l2.478">           aItem[attrib.storageAttributeName] = inverseReferences[aItem.id];</span>
<a href="#l2.479"></a><span id="l2.479">         }</span>
<a href="#l2.480"></a><span id="l2.480">         else if (attrib.special === this.kSpecialColumnParent) {</span>
<a href="#l2.481"></a><span id="l2.481">           aItem[attrib.valueStorageAttributeName] =</span>
<a href="#l2.482"></a><span id="l2.482">             references[aItem[attrib.idStorageAttributeName]];</span>
<a href="#l2.483"></a><span id="l2.483">         }</span>
<a href="#l2.484"></a><span id="l2.484">       }</span>
<a href="#l2.485"></a><span id="l2.485">       else if (objectNounDef.tableName) {</span>
<a href="#l2.486"></a><span id="l2.486" class="difflineplus">+        this._log.info(&quot;trying to load: &quot; + objectNounDef.id + &quot; refs: &quot; +</span>
<a href="#l2.487"></a><span id="l2.487" class="difflineplus">+            jsonValue + &quot;: &quot; + Log4Moz.enumerateProperties(jsonValue).join(&quot;,&quot;));</span>
<a href="#l2.488"></a><span id="l2.488" class="difflineplus">+        this._log.info(&quot;references: &quot;+ Log4Moz.enumerateProperties(references).join(&quot;,&quot;));</span>
<a href="#l2.489"></a><span id="l2.489">         if (attrib.singular)</span>
<a href="#l2.490"></a><span id="l2.490">           aItem[attrib.boundName] = references[jsonValue];</span>
<a href="#l2.491"></a><span id="l2.491">         else</span>
<a href="#l2.492"></a><span id="l2.492">           aItem[attrib.boundName] = [references[val] for each</span>
<a href="#l2.493"></a><span id="l2.493">                                      ([, val] in Iterator(jsonValue))];</span>
<a href="#l2.494"></a><span id="l2.494">       }</span>
<a href="#l2.495"></a><span id="l2.495">       else if (objectNounDef.contributeObjDependencies) {</span>
<a href="#l2.496"></a><span id="l2.496">         aItem[attrib.boundName] =</span>
<a href="#l2.497"></a><span id="l2.497" class="difflineat">@@ -2782,30 +2878,33 @@ var GlodaDatastore = {</span>
<a href="#l2.498"></a><span id="l2.498">       ucs.bindStringParameter(5, aContact._jsonText);</span>
<a href="#l2.499"></a><span id="l2.499">     else</span>
<a href="#l2.500"></a><span id="l2.500">       ucs.bindNullParameter(5);</span>
<a href="#l2.501"></a><span id="l2.501"> </span>
<a href="#l2.502"></a><span id="l2.502">     ucs.executeAsync(this.trackAsync());</span>
<a href="#l2.503"></a><span id="l2.503">   },</span>
<a href="#l2.504"></a><span id="l2.504"> </span>
<a href="#l2.505"></a><span id="l2.505">   _contactFromRow: function gloda_ds_contactFromRow(aRow) {</span>
<a href="#l2.506"></a><span id="l2.506" class="difflineminus">-    let directoryUUID, contactUUID;</span>
<a href="#l2.507"></a><span id="l2.507" class="difflineplus">+    let directoryUUID, contactUUID, jsonText;</span>
<a href="#l2.508"></a><span id="l2.508">     if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l2.509"></a><span id="l2.509">       directoryUUID = null;</span>
<a href="#l2.510"></a><span id="l2.510">     else</span>
<a href="#l2.511"></a><span id="l2.511">       directoryUUID = aRow.getString(1);</span>
<a href="#l2.512"></a><span id="l2.512">     if (aRow.getTypeOfIndex(2) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l2.513"></a><span id="l2.513">       contactUUID = null;</span>
<a href="#l2.514"></a><span id="l2.514">     else</span>
<a href="#l2.515"></a><span id="l2.515">       contactUUID = aRow.getString(2);</span>
<a href="#l2.516"></a><span id="l2.516" class="difflineplus">+    if (aRow.getTypeOfIndex(6) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l2.517"></a><span id="l2.517" class="difflineplus">+      jsonText = undefined;</span>
<a href="#l2.518"></a><span id="l2.518" class="difflineplus">+    else</span>
<a href="#l2.519"></a><span id="l2.519" class="difflineplus">+      jsonText = aRow.getString(6);</span>
<a href="#l2.520"></a><span id="l2.520"> </span>
<a href="#l2.521"></a><span id="l2.521">     return new GlodaContact(this, aRow.getInt64(0), directoryUUID,</span>
<a href="#l2.522"></a><span id="l2.522">                             contactUUID, aRow.getString(5),</span>
<a href="#l2.523"></a><span id="l2.523" class="difflineminus">-                            aRow.getInt64(3), aRow.getInt64(4),</span>
<a href="#l2.524"></a><span id="l2.524" class="difflineminus">-                            aRow.getString(5));</span>
<a href="#l2.525"></a><span id="l2.525" class="difflineplus">+                            aRow.getInt64(3), aRow.getInt64(4), jsonText);</span>
<a href="#l2.526"></a><span id="l2.526">   },</span>
<a href="#l2.527"></a><span id="l2.527"> </span>
<a href="#l2.528"></a><span id="l2.528">   get _selectContactByIDStatement() {</span>
<a href="#l2.529"></a><span id="l2.529">     let statement = this._createSyncStatement(</span>
<a href="#l2.530"></a><span id="l2.530">       &quot;SELECT * FROM contacts WHERE id = ?1&quot;);</span>
<a href="#l2.531"></a><span id="l2.531">     this.__defineGetter__(&quot;_selectContactByIDStatement&quot;,</span>
<a href="#l2.532"></a><span id="l2.532">       function() statement);</span>
<a href="#l2.533"></a><span id="l2.533">     return this._selectContactByIDStatement;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/modules/fundattr.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/modules/fundattr.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -125,16 +125,31 @@ var GlodaFundAttr = {</span>
<a href="#l3.4"></a><span id="l3.4">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l3.5"></a><span id="l3.5">       attributeName: &quot;bodyMatches&quot;,</span>
<a href="#l3.6"></a><span id="l3.6">       singular: true,</span>
<a href="#l3.7"></a><span id="l3.7">       special: Gloda.kSpecialFulltext,</span>
<a href="#l3.8"></a><span id="l3.8">       specialColumnName: &quot;body&quot;,</span>
<a href="#l3.9"></a><span id="l3.9">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l3.10"></a><span id="l3.10">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l3.11"></a><span id="l3.11">       }); // not-tested</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+    </span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+    // conversation</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+    this._attrConversation = Gloda.defineAttribute({</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+      provider: this,</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+      attributeName: &quot;conversation&quot;,</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+      singular: true,</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+      special: Gloda.kSpecialColumnParent,</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+      specialColumnName: &quot;conversationID&quot;,</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineplus">+      idStorageAttributeName: &quot;_conversationID&quot;,</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineplus">+      valueStorageAttributeName: &quot;_conversation&quot;, </span>
<a href="#l3.24"></a><span id="l3.24" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineplus">+      objectNoun: Gloda.NOUN_CONVERSATION,</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineplus">+      });</span>
<a href="#l3.27"></a><span id="l3.27">   </span>
<a href="#l3.28"></a><span id="l3.28">     // --- Fundamental</span>
<a href="#l3.29"></a><span id="l3.29">     // From</span>
<a href="#l3.30"></a><span id="l3.30">     this._attrFrom = Gloda.defineAttribute({</span>
<a href="#l3.31"></a><span id="l3.31">                         provider: this,</span>
<a href="#l3.32"></a><span id="l3.32">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l3.33"></a><span id="l3.33">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l3.34"></a><span id="l3.34">                         attributeName: &quot;from&quot;,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -880,17 +880,18 @@ var Gloda = {</span>
<a href="#l4.4"></a><span id="l4.4">       cache: true, cacheCost: 2048,</span>
<a href="#l4.5"></a><span id="l4.5">       tableName: &quot;messages&quot;,</span>
<a href="#l4.6"></a><span id="l4.6">       attrTableName: &quot;messageAttributes&quot;, attrIDColumnName: &quot;messageID&quot;,</span>
<a href="#l4.7"></a><span id="l4.7">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._messageFromRow,</span>
<a href="#l4.8"></a><span id="l4.8">       dbAttribAdjuster: GlodaDatastore.adjustMessageAttributes,</span>
<a href="#l4.9"></a><span id="l4.9">       objInsert: GlodaDatastore.insertMessage,</span>
<a href="#l4.10"></a><span id="l4.10">       objUpdate: GlodaDatastore.updateMessage,</span>
<a href="#l4.11"></a><span id="l4.11">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-        return GlodaDatastore.getMessageByID(aID);</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+        // XXX we need some form of official semantics on references to messages</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+        return aID;</span>
<a href="#l4.15"></a><span id="l4.15">       },</span>
<a href="#l4.16"></a><span id="l4.16">       toParamAndValue: function(aMessage) {</span>
<a href="#l4.17"></a><span id="l4.17">         if (aMessage instanceof GlodaMessage)</span>
<a href="#l4.18"></a><span id="l4.18">           return [null, aMessage.id];</span>
<a href="#l4.19"></a><span id="l4.19">         else // assume they're just passing the id directly</span>
<a href="#l4.20"></a><span id="l4.20">           return [null, aMessage];</span>
<a href="#l4.21"></a><span id="l4.21">       }}, this.NOUN_MESSAGE);</span>
<a href="#l4.22"></a><span id="l4.22">     this.defineNoun({</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineat">@@ -1385,17 +1386,18 @@ var Gloda = {</span>
<a href="#l4.24"></a><span id="l4.24">       //  the object implementation.)</span>
<a href="#l4.25"></a><span id="l4.25">       if (key[0] == &quot;_&quot;)</span>
<a href="#l4.26"></a><span id="l4.26">         continue;</span>
<a href="#l4.27"></a><span id="l4.27">       // find the attribute definition that corresponds to this key</span>
<a href="#l4.28"></a><span id="l4.28">       let attrib = attribsByBoundName[key];</span>
<a href="#l4.29"></a><span id="l4.29">       // if there's no attribute, that's not good, but not horrible.</span>
<a href="#l4.30"></a><span id="l4.30">       if (attrib === undefined)</span>
<a href="#l4.31"></a><span id="l4.31">         continue;</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineminus">-      </span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+      let attribDB = attrib.dbDef;</span>
<a href="#l4.35"></a><span id="l4.35">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l4.36"></a><span id="l4.36">       </span>
<a href="#l4.37"></a><span id="l4.37">       // - translate for our JSON rep</span>
<a href="#l4.38"></a><span id="l4.38">       if (attrib.singular) {</span>
<a href="#l4.39"></a><span id="l4.39">         if (objectNounDef.toJSON)</span>
<a href="#l4.40"></a><span id="l4.40">           jsonDict[attrib.id] = objectNounDef.toJSON(value);</span>
<a href="#l4.41"></a><span id="l4.41">         else</span>
<a href="#l4.42"></a><span id="l4.42">           jsonDict[attrib.id] = value; </span>
<a href="#l4.43"></a><span id="l4.43" class="difflineat">@@ -1411,34 +1413,34 @@ var Gloda = {</span>
<a href="#l4.44"></a><span id="l4.44">       }</span>
<a href="#l4.45"></a><span id="l4.45">       </span>
<a href="#l4.46"></a><span id="l4.46">       // perform a delta analysis against the old value, if we have one</span>
<a href="#l4.47"></a><span id="l4.47">       let oldValue = aOldItem[key];</span>
<a href="#l4.48"></a><span id="l4.48">       if (oldValue !== undefined) {</span>
<a href="#l4.49"></a><span id="l4.49">         // in the singular case if they don't match, it's one add and one remove</span>
<a href="#l4.50"></a><span id="l4.50">         if (attrib.singular) {</span>
<a href="#l4.51"></a><span id="l4.51">           if (value != oldValue) {</span>
<a href="#l4.52"></a><span id="l4.52" class="difflineminus">-            addDBAttribs.push(attrib.convertValuesToDBAttributes(value)[0]);</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineplus">+            addDBAttribs.push(attribDB.convertValuesToDBAttributes(value)[0]);</span>
<a href="#l4.54"></a><span id="l4.54">             removeDBAttribs.push(</span>
<a href="#l4.55"></a><span id="l4.55" class="difflineminus">-              attrib.convertValuesToDBAttributes(oldValue)[0]);</span>
<a href="#l4.56"></a><span id="l4.56" class="difflineplus">+              attribDB.convertValuesToDBAttributes(oldValue)[0]);</span>
<a href="#l4.57"></a><span id="l4.57">           }</span>
<a href="#l4.58"></a><span id="l4.58">         }</span>
<a href="#l4.59"></a><span id="l4.59">         // in the plural case, we have to figure the deltas accounting for</span>
<a href="#l4.60"></a><span id="l4.60">         //  possible changes in ordering (which is insignificant from an</span>
<a href="#l4.61"></a><span id="l4.61">         //  indexing perspective)</span>
<a href="#l4.62"></a><span id="l4.62">         // some nouns may not meet === equivalence needs, so must provide a</span>
<a href="#l4.63"></a><span id="l4.63">         //  custom computeDelta method to help us out</span>
<a href="#l4.64"></a><span id="l4.64">         else if (objectNounDef.computeDelta) {</span>
<a href="#l4.65"></a><span id="l4.65">           let [valuesAdded, valuesRemoved] = </span>
<a href="#l4.66"></a><span id="l4.66">             objectNounDef.computeDelta(value, oldValue);</span>
<a href="#l4.67"></a><span id="l4.67">           // convert the values to database-style attribute rows</span>
<a href="#l4.68"></a><span id="l4.68">           addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineminus">-            attrib.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineplus">+            attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l4.71"></a><span id="l4.71">           removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l4.72"></a><span id="l4.72" class="difflineminus">-            attrib.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l4.73"></a><span id="l4.73" class="difflineplus">+            attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l4.74"></a><span id="l4.74">         }</span>
<a href="#l4.75"></a><span id="l4.75">         else {</span>
<a href="#l4.76"></a><span id="l4.76">           // build a map of the previous values; we will delete the values as</span>
<a href="#l4.77"></a><span id="l4.77">           //  we see them so that we will know what old values are no longer</span>
<a href="#l4.78"></a><span id="l4.78">           //  present in the current set of values.</span>
<a href="#l4.79"></a><span id="l4.79">           let oldValueMap = {};</span>
<a href="#l4.80"></a><span id="l4.80">           for each (let [iAnOldValue, anOldValue] in Iterator(oldValue)) {</span>
<a href="#l4.81"></a><span id="l4.81">             oldValueMap[anOldValue] = true;</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineat">@@ -1450,28 +1452,28 @@ var Gloda = {</span>
<a href="#l4.83"></a><span id="l4.83">               delete oldValueMap[curValue];</span>
<a href="#l4.84"></a><span id="l4.84">             else</span>
<a href="#l4.85"></a><span id="l4.85">               valuesAdded.push(curValue);</span>
<a href="#l4.86"></a><span id="l4.86">           }</span>
<a href="#l4.87"></a><span id="l4.87">           // anything still on oldValueMap was removed.</span>
<a href="#l4.88"></a><span id="l4.88">           let valuesRemoved = [val for (val in Iterator(oldValueMap, true))];</span>
<a href="#l4.89"></a><span id="l4.89">           // convert the values to database-style attribute rows</span>
<a href="#l4.90"></a><span id="l4.90">           addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineminus">-            attrib.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineplus">+            attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l4.93"></a><span id="l4.93">           removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineminus">-            attrib.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l4.95"></a><span id="l4.95" class="difflineplus">+            attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l4.96"></a><span id="l4.96">         }</span>
<a href="#l4.97"></a><span id="l4.97">       </span>
<a href="#l4.98"></a><span id="l4.98">         // delete the old values to mark that we have processed them</span>
<a href="#l4.99"></a><span id="l4.99">         delete aOldItem[key];</span>
<a href="#l4.100"></a><span id="l4.100">       }</span>
<a href="#l4.101"></a><span id="l4.101">       // no old value, all attributes are new</span>
<a href="#l4.102"></a><span id="l4.102">       else {</span>
<a href="#l4.103"></a><span id="l4.103">         addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l4.104"></a><span id="l4.104" class="difflineminus">-                                attrib.dbDef.convertValuesToDBAttributes(value));</span>
<a href="#l4.105"></a><span id="l4.105" class="difflineplus">+                                attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l4.106"></a><span id="l4.106">       }</span>
<a href="#l4.107"></a><span id="l4.107">     }</span>
<a href="#l4.108"></a><span id="l4.108">     </span>
<a href="#l4.109"></a><span id="l4.109">     // Iterate over any remaining values in old items for purge purposes.</span>
<a href="#l4.110"></a><span id="l4.110">     for each (let [key, value] in Iterator(aOldItem)) {</span>
<a href="#l4.111"></a><span id="l4.111">       // ignore keys that start with underscores, they are private and not</span>
<a href="#l4.112"></a><span id="l4.112">       //  persisted by our attribute mechanism.  (they are directly handled by</span>
<a href="#l4.113"></a><span id="l4.113">       //  the object implementation.)</span>
<a href="#l4.114"></a><span id="l4.114" class="difflineat">@@ -1479,17 +1481,17 @@ var Gloda = {</span>
<a href="#l4.115"></a><span id="l4.115">         continue;</span>
<a href="#l4.116"></a><span id="l4.116">       // find the attribute definition that corresponds to this key</span>
<a href="#l4.117"></a><span id="l4.117">       let attrib = attribsByBoundName[key];</span>
<a href="#l4.118"></a><span id="l4.118">       // if there's no attribute, that's not good, but not horrible.</span>
<a href="#l4.119"></a><span id="l4.119">       if (attrib === undefined)</span>
<a href="#l4.120"></a><span id="l4.120">         continue;</span>
<a href="#l4.121"></a><span id="l4.121">       </span>
<a href="#l4.122"></a><span id="l4.122">       removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l4.123"></a><span id="l4.123" class="difflineminus">-                                 attrib.convertValuesToDBAttributes(value));</span>
<a href="#l4.124"></a><span id="l4.124" class="difflineplus">+                                 attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l4.125"></a><span id="l4.125">     }</span>
<a href="#l4.126"></a><span id="l4.126">     </span>
<a href="#l4.127"></a><span id="l4.127">     aItem._jsonText = this._json.encode(jsonDict);</span>
<a href="#l4.128"></a><span id="l4.128">     this._log.debug(&quot;  json text: &quot; + aItem._jsonText);</span>
<a href="#l4.129"></a><span id="l4.129">     </span>
<a href="#l4.130"></a><span id="l4.130">     if (aIsNew) {</span>
<a href="#l4.131"></a><span id="l4.131">       this._log.debug(&quot; inserting item&quot;);</span>
<a href="#l4.132"></a><span id="l4.132">       itemNounDef.objInsert.call(itemNounDef.datastore, aItem);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/modules/index_ab.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/modules/index_ab.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -184,17 +184,17 @@ var GlodaABAttrs = {</span>
<a href="#l5.4"></a><span id="l5.4"> </span>
<a href="#l5.5"></a><span id="l5.5">     /* ***** Identities ***** */</span>
<a href="#l5.6"></a><span id="l5.6">     this._attrIdentityContact = Gloda.defineAttribute({</span>
<a href="#l5.7"></a><span id="l5.7">       provider: this,</span>
<a href="#l5.8"></a><span id="l5.8">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l5.9"></a><span id="l5.9">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l5.10"></a><span id="l5.10">       attributeName: &quot;contact&quot;,</span>
<a href="#l5.11"></a><span id="l5.11">       singular: true,</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-      special: Gloda.kSpecialColumn,</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+      special: Gloda.kSpecialColumnParent,</span>
<a href="#l5.14"></a><span id="l5.14">       specialColumnName: &quot;contactID&quot;, // the column in the db</span>
<a href="#l5.15"></a><span id="l5.15">       idStorageAttributeName: &quot;_contactID&quot;,</span>
<a href="#l5.16"></a><span id="l5.16">       valueStorageAttributeName: &quot;_contact&quot;, </span>
<a href="#l5.17"></a><span id="l5.17">       subjectNouns: [Gloda.NOUN_IDENTITY],</span>
<a href="#l5.18"></a><span id="l5.18">       objectNoun: Gloda.NOUN_CONTACT,</span>
<a href="#l5.19"></a><span id="l5.19">       }); // tested-by: test_attributes_fundamental</span>
<a href="#l5.20"></a><span id="l5.20">     this._attrIdentityKind = Gloda.defineAttribute({</span>
<a href="#l5.21"></a><span id="l5.21">       provider: this,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/modules/indexer.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/modules/indexer.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -1002,16 +1002,18 @@ var GlodaIndexer = {</span>
<a href="#l6.4"></a><span id="l6.4">        last yield kWorkAsync */</span>
<a href="#l6.5"></a><span id="l6.5">     onItemsAdded: function() {},</span>
<a href="#l6.6"></a><span id="l6.6">     onItemsModified: function() {},</span>
<a href="#l6.7"></a><span id="l6.7">     onItemsRemoved: function() {},</span>
<a href="#l6.8"></a><span id="l6.8">     onQueryCompleted: function(aCollection) {</span>
<a href="#l6.9"></a><span id="l6.9">       GlodaIndexer.callbackDriver();</span>
<a href="#l6.10"></a><span id="l6.10">     }</span>
<a href="#l6.11"></a><span id="l6.11">   },</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+  _forceGCCounter: 0,</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+  FORCE_GC_THRESHOLD: 256,</span>
<a href="#l6.14"></a><span id="l6.14">   _workBatchData: undefined,</span>
<a href="#l6.15"></a><span id="l6.15">   /**</span>
<a href="#l6.16"></a><span id="l6.16">    * The workBatch generator handles a single 'batch' of processing, managing</span>
<a href="#l6.17"></a><span id="l6.17">    *  the database transaction and keeping track of &quot;tokens&quot;.  It drives the</span>
<a href="#l6.18"></a><span id="l6.18">    *  _actualWorker generator which is doing the work.</span>
<a href="#l6.19"></a><span id="l6.19">    * workBatch will only produce kWorkAsync and kWorkDone notifications.</span>
<a href="#l6.20"></a><span id="l6.20">    *  If _actualWorker returns kWorkSync and there are still tokens available,</span>
<a href="#l6.21"></a><span id="l6.21">    *  workBatch will keep driving _actualWorker until it encounters a</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineat">@@ -1020,16 +1022,23 @@ var GlodaIndexer = {</span>
<a href="#l6.23"></a><span id="l6.23">    */</span>
<a href="#l6.24"></a><span id="l6.24">   workBatch: function gloda_index_workBatch() {</span>
<a href="#l6.25"></a><span id="l6.25">     let commitTokens = this._indexCommitTokens;</span>
<a href="#l6.26"></a><span id="l6.26">     GlodaDatastore._beginTransaction();</span>
<a href="#l6.27"></a><span id="l6.27"> </span>
<a href="#l6.28"></a><span id="l6.28">     while (commitTokens &gt; 0) {</span>
<a href="#l6.29"></a><span id="l6.29">       for (let tokensLeft = this._indexTokens; tokensLeft &gt; 0;</span>
<a href="#l6.30"></a><span id="l6.30">           tokensLeft--, commitTokens--) {</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineplus">+        // we need to periodically force a GC to avoid excessive process size</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+        //  and because nsAutoLock is a jerk on debug builds</span>
<a href="#l6.33"></a><span id="l6.33" class="difflineplus">+        if (++this._forceGCCounter &gt;= this.FORCE_GC_THRESHOLD) {</span>
<a href="#l6.34"></a><span id="l6.34" class="difflineplus">+          Cu.forceGC();</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineplus">+          this._forceGCCounter = 0;</span>
<a href="#l6.36"></a><span id="l6.36" class="difflineplus">+        }</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineplus">+        </span>
<a href="#l6.38"></a><span id="l6.38">         if ((this._callbackHandle.activeIterator === null) &amp;&amp;</span>
<a href="#l6.39"></a><span id="l6.39">             !this._hireJobWorker()) {</span>
<a href="#l6.40"></a><span id="l6.40">           commitTokens = 0;</span>
<a href="#l6.41"></a><span id="l6.41">           break;</span>
<a href="#l6.42"></a><span id="l6.42">         }</span>
<a href="#l6.43"></a><span id="l6.43">       </span>
<a href="#l6.44"></a><span id="l6.44">         // XXX for performance, we may want to move the try outside the for loop</span>
<a href="#l6.45"></a><span id="l6.45">         //  with a quasi-redundant outer loop that shunts control back inside</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

