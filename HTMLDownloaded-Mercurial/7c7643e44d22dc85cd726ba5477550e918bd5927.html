<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 1211:7c7643e44d22dc85cd726ba5477550e918bd5927</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 7c7643e44d22dc85cd726ba5477550e918bd5927" />
<meta property="og:url" content="/comm-central/rev/7c7643e44d22dc85cd726ba5477550e918bd5927" />
<meta property="og:description" content="Bug 465122 - &quot;Gloda: Does not close msf files on initial indexing&quot; [r=bienvenu]" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 7c7643e44d22dc85cd726ba5477550e918bd5927 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/7c7643e44d22dc85cd726ba5477550e918bd5927">shortlog</a> |
<a href="/comm-central/log/7c7643e44d22dc85cd726ba5477550e918bd5927">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/7c7643e44d22dc85cd726ba5477550e918bd5927">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/7c7643e44d22dc85cd726ba5477550e918bd5927">files</a> |
changeset |
<a href="/comm-central/raw-rev/7c7643e44d22dc85cd726ba5477550e918bd5927">raw</a>  | <a href="/comm-central/archive/7c7643e44d22dc85cd726ba5477550e918bd5927.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=465122">Bug 465122</a> - &quot;Gloda: Does not close msf files on initial indexing&quot; [r=bienvenu]
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#98;&#117;&#103;&#109;&#97;&#105;&#108;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Mon, 24 Nov 2008 20:39:07 +0000</td></tr>

<tr>
 <td>changeset 1211</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/7c7643e44d22dc85cd726ba5477550e918bd5927">7c7643e44d22dc85cd726ba5477550e918bd5927</a></td>
</tr>



<tr>
<td>parent 1210</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/a23ff27acc0617ba82be67a9d3049208c77d589e">a23ff27acc0617ba82be67a9d3049208c77d589e</a>
</td>
</tr>

<tr>
<td>child 1212</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/3344935c103c75eb519eab57df8d7c5e648900b0">3344935c103c75eb519eab57df8d7c5e648900b0</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=7c7643e44d22dc85cd726ba5477550e918bd5927">936</a></td></tr>
<tr><td>push user</td><td>bugzilla@standard8.plus.com</td></tr>
<tr><td>push date</td><td class="date age">Mon, 24 Nov 2008 20:40:33 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@7c7643e44d22 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=7c7643e44d22dc85cd726ba5477550e918bd5927">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=7c7643e44d22dc85cd726ba5477550e918bd5927&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=7c7643e44d22dc85cd726ba5477550e918bd5927&newProject=comm-central&newRevision=a23ff27acc0617ba82be67a9d3049208c77d589e&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=7c7643e44d22dc85cd726ba5477550e918bd5927&newProject=comm-central&newRevision=a23ff27acc0617ba82be67a9d3049208c77d589e&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=7c7643e44d22dc85cd726ba5477550e918bd5927&newProject=comm-central&newRevision=a23ff27acc0617ba82be67a9d3049208c77d589e&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28bienvenu%29&revcount=50">bienvenu</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=465122">465122</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=465122">Bug 465122</a> - &quot;Gloda: Does not close msf files on initial indexing&quot; [r=bienvenu]</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/datamodel.js">mailnews/db/gloda/modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/datastore.js">mailnews/db/gloda/modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/indexer.js">mailnews/db/gloda/modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/test/resources/glodaTestHelper.js">mailnews/db/gloda/test/resources/glodaTestHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/test/resources/glodaTestHelper.js">file</a> |
<a href="/comm-central/annotate/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/test/resources/glodaTestHelper.js">annotate</a> |
<a href="/comm-central/diff/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/test/resources/glodaTestHelper.js">diff</a> |
<a href="/comm-central/comparison/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/test/resources/glodaTestHelper.js">comparison</a> |
<a href="/comm-central/log/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/test/resources/glodaTestHelper.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">file</a> |
<a href="/comm-central/annotate/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">annotate</a> |
<a href="/comm-central/diff/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">diff</a> |
<a href="/comm-central/comparison/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">comparison</a> |
<a href="/comm-central/log/7c7643e44d22dc85cd726ba5477550e918bd5927/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -217,40 +217,154 @@ GlodaConversation.prototype = {</span>
<a href="#l1.4"></a><span id="l1.4"> };</span>
<a href="#l1.5"></a><span id="l1.5"> </span>
<a href="#l1.6"></a><span id="l1.6"> function GlodaFolder(aDatastore, aID, aURI, aDirtyStatus, aPrettyName) {</span>
<a href="#l1.7"></a><span id="l1.7">   this._datastore = aDatastore;</span>
<a href="#l1.8"></a><span id="l1.8">   this._id = aID;</span>
<a href="#l1.9"></a><span id="l1.9">   this._uri = aURI;</span>
<a href="#l1.10"></a><span id="l1.10">   this._dirtyStatus = aDirtyStatus;</span>
<a href="#l1.11"></a><span id="l1.11">   this._prettyName = aPrettyName;</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+  this._xpcomFolder = null;</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+  this._activeIndexing = false;</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+  this._activeHeaderRetrievalLastStamp = 0;</span>
<a href="#l1.15"></a><span id="l1.15"> }</span>
<a href="#l1.16"></a><span id="l1.16"> </span>
<a href="#l1.17"></a><span id="l1.17"> GlodaFolder.prototype = {</span>
<a href="#l1.18"></a><span id="l1.18">   NOUN_ID: 100,</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+  </span>
<a href="#l1.20"></a><span id="l1.20">   /** The folder is believed to be up-to-date */</span>
<a href="#l1.21"></a><span id="l1.21">   kFolderClean: 0,</span>
<a href="#l1.22"></a><span id="l1.22">   /** The folder has some un-indexed or dirty messages */</span>
<a href="#l1.23"></a><span id="l1.23">   kFolderDirty: 1,</span>
<a href="#l1.24"></a><span id="l1.24">   /** The folder needs to be entirely re-indexed, regardless of the flags on</span>
<a href="#l1.25"></a><span id="l1.25">    * the messages in the folder. This state will be downgraded to dirty */</span>
<a href="#l1.26"></a><span id="l1.26">   kFolderFilthy: 2,</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineplus">+  </span>
<a href="#l1.28"></a><span id="l1.28">   get id() { return this._id; },</span>
<a href="#l1.29"></a><span id="l1.29">   get uri() { return this._uri; },</span>
<a href="#l1.30"></a><span id="l1.30">   get dirtyStatus() { return this._dirtyStatus; },</span>
<a href="#l1.31"></a><span id="l1.31">   set dirtyStatus(aNewStatus) {</span>
<a href="#l1.32"></a><span id="l1.32">     if (aNewStatus != this._dirtyStatus) {</span>
<a href="#l1.33"></a><span id="l1.33">       this._dirtyStatus = aNewStatus;</span>
<a href="#l1.34"></a><span id="l1.34">       this._datastore.updateFolderDirtyStatus(this);</span>
<a href="#l1.35"></a><span id="l1.35">     }</span>
<a href="#l1.36"></a><span id="l1.36">   },</span>
<a href="#l1.37"></a><span id="l1.37">   get name() { return this._prettyName; },</span>
<a href="#l1.38"></a><span id="l1.38">   toString: function gloda_folder_toString() {</span>
<a href="#l1.39"></a><span id="l1.39">     return &quot;Folder:&quot; + this._id;</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineminus">-  }</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineplus">+  },</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+  /** We are going to index this folder. */</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+  kActivityIndexing: 0,</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+  /** Asking for the folder to perform header retrievals. */</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineplus">+  kActivityHeaderRetrieval: 1,</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+  </span>
<a href="#l1.48"></a><span id="l1.48" class="difflineplus">+  /** Is this folder known to be actively used for indexing? */</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineplus">+  _activeIndexing: false,</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineplus">+  /** Get our indexing status. */</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+  get indexing() {</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineplus">+    return this._activeIndexing;</span>
<a href="#l1.53"></a><span id="l1.53" class="difflineplus">+  },</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineplus">+  /**</span>
<a href="#l1.55"></a><span id="l1.55" class="difflineplus">+   * Set our indexing status.  Normally, this will be enabled through passing</span>
<a href="#l1.56"></a><span id="l1.56" class="difflineplus">+   *  an activity type of kActivityIndexing (which will set us), but we will</span>
<a href="#l1.57"></a><span id="l1.57" class="difflineplus">+   *  still need to be explicitly disabled by the indexing code.</span>
<a href="#l1.58"></a><span id="l1.58" class="difflineplus">+   * When disabling indexing, we will call forgetFolderIfUnused to take care of</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineplus">+   *  shutting things down.</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineplus">+   * We are not responsible for committing changes to the message database!</span>
<a href="#l1.61"></a><span id="l1.61" class="difflineplus">+   *  That is on you! </span>
<a href="#l1.62"></a><span id="l1.62" class="difflineplus">+   */</span>
<a href="#l1.63"></a><span id="l1.63" class="difflineplus">+  set indexing(aIndexing) {</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineplus">+    this._activeIndexing = aIndexing;</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineplus">+    if (!aIndexing)</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineplus">+      this.forgetFolderIfUnused();</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineplus">+  },</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineplus">+  /** When was this folder last used for header retrieval purposes? */</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineplus">+  _activeHeaderRetrievalLastStamp: 0,</span>
<a href="#l1.70"></a><span id="l1.70" class="difflineplus">+  </span>
<a href="#l1.71"></a><span id="l1.71" class="difflineplus">+  /**</span>
<a href="#l1.72"></a><span id="l1.72" class="difflineplus">+   * Retrieve the nsIMsgFolder instance corresponding to this folder, providing</span>
<a href="#l1.73"></a><span id="l1.73" class="difflineplus">+   *  an explanation of why you are requesting it for tracking/cleanup purposes.</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineplus">+   * </span>
<a href="#l1.75"></a><span id="l1.75" class="difflineplus">+   * @param aActivity One of the kActivity* constants.  If you pass</span>
<a href="#l1.76"></a><span id="l1.76" class="difflineplus">+   *     kActivityIndexing, we will set indexing for you, but you will need to</span>
<a href="#l1.77"></a><span id="l1.77" class="difflineplus">+   *     clear it when you are done.</span>
<a href="#l1.78"></a><span id="l1.78" class="difflineplus">+   * @return The nsIMsgFolder if available, null on failure.</span>
<a href="#l1.79"></a><span id="l1.79" class="difflineplus">+   */</span>
<a href="#l1.80"></a><span id="l1.80" class="difflineplus">+  getXPCOMFolder: function gloda_folder_getXPCOMFolder(aActivity) {</span>
<a href="#l1.81"></a><span id="l1.81" class="difflineplus">+    if (!this._xpcomFolder) {</span>
<a href="#l1.82"></a><span id="l1.82" class="difflineplus">+      let rdfService = Cc['@mozilla.org/rdf/rdf-service;1']</span>
<a href="#l1.83"></a><span id="l1.83" class="difflineplus">+                         .getService(Ci.nsIRDFService);</span>
<a href="#l1.84"></a><span id="l1.84" class="difflineplus">+      this._xpcomFolder = rdfService.GetResource(this.uri)</span>
<a href="#l1.85"></a><span id="l1.85" class="difflineplus">+                                    .QueryInterface(Ci.nsIMsgFolder);</span>
<a href="#l1.86"></a><span id="l1.86" class="difflineplus">+    }</span>
<a href="#l1.87"></a><span id="l1.87" class="difflineplus">+    switch (aActivity) {</span>
<a href="#l1.88"></a><span id="l1.88" class="difflineplus">+      case this.kActivityIndexing:</span>
<a href="#l1.89"></a><span id="l1.89" class="difflineplus">+        // mark us as indexing, but don't bother with live tracking.  we do</span>
<a href="#l1.90"></a><span id="l1.90" class="difflineplus">+        //  that independently and only for header retrieval.</span>
<a href="#l1.91"></a><span id="l1.91" class="difflineplus">+        this.indexing = true;</span>
<a href="#l1.92"></a><span id="l1.92" class="difflineplus">+        break;</span>
<a href="#l1.93"></a><span id="l1.93" class="difflineplus">+      case this.kActivityHeaderRetrieval:</span>
<a href="#l1.94"></a><span id="l1.94" class="difflineplus">+        if (this._activeHeaderRetrievalLastStamp === 0)</span>
<a href="#l1.95"></a><span id="l1.95" class="difflineplus">+          this._datastore.markFolderLive(this);</span>
<a href="#l1.96"></a><span id="l1.96" class="difflineplus">+        this._activeHeaderRetrievalLastStamp = Date.now();</span>
<a href="#l1.97"></a><span id="l1.97" class="difflineplus">+        break;</span>
<a href="#l1.98"></a><span id="l1.98" class="difflineplus">+    }</span>
<a href="#l1.99"></a><span id="l1.99" class="difflineplus">+    </span>
<a href="#l1.100"></a><span id="l1.100" class="difflineplus">+    return this._xpcomFolder;</span>
<a href="#l1.101"></a><span id="l1.101" class="difflineplus">+  },</span>
<a href="#l1.102"></a><span id="l1.102" class="difflineplus">+  </span>
<a href="#l1.103"></a><span id="l1.103" class="difflineplus">+  /**</span>
<a href="#l1.104"></a><span id="l1.104" class="difflineplus">+   * How many milliseconds must a folder have not had any header retrieval</span>
<a href="#l1.105"></a><span id="l1.105" class="difflineplus">+   *  activity before it's okay to lose the database reference?</span>
<a href="#l1.106"></a><span id="l1.106" class="difflineplus">+   */</span>
<a href="#l1.107"></a><span id="l1.107" class="difflineplus">+  ACCEPTABLY_OLD_THRESHOLD: 10000,</span>
<a href="#l1.108"></a><span id="l1.108" class="difflineplus">+  </span>
<a href="#l1.109"></a><span id="l1.109" class="difflineplus">+  /**</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineplus">+   * Cleans up our nsIMsgFolder reference if we have one and it's not &quot;in use&quot;.</span>
<a href="#l1.111"></a><span id="l1.111" class="difflineplus">+   * In use, from our perspective, means that it is not being used for indexing</span>
<a href="#l1.112"></a><span id="l1.112" class="difflineplus">+   *  and some arbitrary interval of time has elapsed since it was last</span>
<a href="#l1.113"></a><span id="l1.113" class="difflineplus">+   *  retrieved for header retrieval reasons.  The time interval is because if</span>
<a href="#l1.114"></a><span id="l1.114" class="difflineplus">+   *  we have one GlodaMessage requesting a header, there's a high probability</span>
<a href="#l1.115"></a><span id="l1.115" class="difflineplus">+   *  that another message will request a header in the near future.</span>
<a href="#l1.116"></a><span id="l1.116" class="difflineplus">+   * Because setting indexing to false disables us, we are written in an</span>
<a href="#l1.117"></a><span id="l1.117" class="difflineplus">+   *  idempotent fashion.  (It is possible for disabling indexing's call to us</span>
<a href="#l1.118"></a><span id="l1.118" class="difflineplus">+   *  to cause us to return true but for the datastore's timer call to have not</span>
<a href="#l1.119"></a><span id="l1.119" class="difflineplus">+   *  yet triggered.)</span>
<a href="#l1.120"></a><span id="l1.120" class="difflineplus">+   * </span>
<a href="#l1.121"></a><span id="l1.121" class="difflineplus">+   * @returns true if we are cleaned up and can be considered 'dead', false if</span>
<a href="#l1.122"></a><span id="l1.122" class="difflineplus">+   *     we should still be considered alive and this method should be called</span>
<a href="#l1.123"></a><span id="l1.123" class="difflineplus">+   *     again in the future.</span>
<a href="#l1.124"></a><span id="l1.124" class="difflineplus">+   */</span>
<a href="#l1.125"></a><span id="l1.125" class="difflineplus">+  forgetFolderIfUnused: function gloda_folder_forgetFolderIfUnused() {</span>
<a href="#l1.126"></a><span id="l1.126" class="difflineplus">+    // we are not cleaning/cleaned up if we are indexing</span>
<a href="#l1.127"></a><span id="l1.127" class="difflineplus">+    if (this._activeIndexing)</span>
<a href="#l1.128"></a><span id="l1.128" class="difflineplus">+      return false;</span>
<a href="#l1.129"></a><span id="l1.129" class="difflineplus">+    </span>
<a href="#l1.130"></a><span id="l1.130" class="difflineplus">+    // set a point in the past as the threshold.  the timestamp must be older</span>
<a href="#l1.131"></a><span id="l1.131" class="difflineplus">+    //  than this to be eligible for cleanup.</span>
<a href="#l1.132"></a><span id="l1.132" class="difflineplus">+    let acceptablyOld = Date.now() - this.ACCEPTABLY_OLD_THRESHOLD;</span>
<a href="#l1.133"></a><span id="l1.133" class="difflineplus">+    // we are not cleaning/cleaned up if we have retrieved a header more</span>
<a href="#l1.134"></a><span id="l1.134" class="difflineplus">+    //  recently than the acceptably old threshold.</span>
<a href="#l1.135"></a><span id="l1.135" class="difflineplus">+    if (this._activeHeaderRetrievalLastStamp &gt; acceptablyOld)</span>
<a href="#l1.136"></a><span id="l1.136" class="difflineplus">+      return false;</span>
<a href="#l1.137"></a><span id="l1.137" class="difflineplus">+    </span>
<a href="#l1.138"></a><span id="l1.138" class="difflineplus">+    if (this._xpcomFolder) {</span>
<a href="#l1.139"></a><span id="l1.139" class="difflineplus">+      // This is the key action we take; the nsIMsgFolder will continue to</span>
<a href="#l1.140"></a><span id="l1.140" class="difflineplus">+      //  exist, but we want it to forget about its database so that it can</span>
<a href="#l1.141"></a><span id="l1.141" class="difflineplus">+      //  be closed and its memory can be reclaimed.</span>
<a href="#l1.142"></a><span id="l1.142" class="difflineplus">+      this._xpcomFolder.setMsgDatabase(null);</span>
<a href="#l1.143"></a><span id="l1.143" class="difflineplus">+      this._xpcomFolder = null;</span>
<a href="#l1.144"></a><span id="l1.144" class="difflineplus">+      // since the last retrieval time tracks whether we have marked live or</span>
<a href="#l1.145"></a><span id="l1.145" class="difflineplus">+      //  not, this needs to be reset to 0 too.</span>
<a href="#l1.146"></a><span id="l1.146" class="difflineplus">+      this._activeHeaderRetrievalLastStamp = 0;</span>
<a href="#l1.147"></a><span id="l1.147" class="difflineplus">+    }</span>
<a href="#l1.148"></a><span id="l1.148" class="difflineplus">+    </span>
<a href="#l1.149"></a><span id="l1.149" class="difflineplus">+    return true;</span>
<a href="#l1.150"></a><span id="l1.150" class="difflineplus">+  },</span>
<a href="#l1.151"></a><span id="l1.151"> }</span>
<a href="#l1.152"></a><span id="l1.152"> </span>
<a href="#l1.153"></a><span id="l1.153"> /**</span>
<a href="#l1.154"></a><span id="l1.154">  * @class A message representation.</span>
<a href="#l1.155"></a><span id="l1.155">  */</span>
<a href="#l1.156"></a><span id="l1.156"> function GlodaMessage(aDatastore, aID, aFolderID, aMessageKey,</span>
<a href="#l1.157"></a><span id="l1.157">                       aConversationID, aConversation, aDate,</span>
<a href="#l1.158"></a><span id="l1.158">                       aHeaderMessageID, aDeleted, aJsonText) {</span>
<a href="#l1.159"></a><span id="l1.159" class="difflineat">@@ -278,16 +392,22 @@ GlodaMessage.prototype = {</span>
<a href="#l1.160"></a><span id="l1.160">   get messageKey() { return this._messageKey; },</span>
<a href="#l1.161"></a><span id="l1.161">   get conversationID() { return this._conversationID; },</span>
<a href="#l1.162"></a><span id="l1.162">   // conversation is special</span>
<a href="#l1.163"></a><span id="l1.163">   get headerMessageID() { return this._headerMessageID; },</span>
<a href="#l1.164"></a><span id="l1.164">   </span>
<a href="#l1.165"></a><span id="l1.165">   get date() { return this._date; },</span>
<a href="#l1.166"></a><span id="l1.166">   set date(aNewDate) { this._date = aNewDate; },</span>
<a href="#l1.167"></a><span id="l1.167"> </span>
<a href="#l1.168"></a><span id="l1.168" class="difflineplus">+  get folder() {</span>
<a href="#l1.169"></a><span id="l1.169" class="difflineplus">+    if (this._folderID != null)</span>
<a href="#l1.170"></a><span id="l1.170" class="difflineplus">+      return this._datastore._mapFolderID(this._folderID);</span>
<a href="#l1.171"></a><span id="l1.171" class="difflineplus">+    else</span>
<a href="#l1.172"></a><span id="l1.172" class="difflineplus">+      return null;    </span>
<a href="#l1.173"></a><span id="l1.173" class="difflineplus">+  },</span>
<a href="#l1.174"></a><span id="l1.174">   get folderURI() {</span>
<a href="#l1.175"></a><span id="l1.175">     if (this._folderID != null)</span>
<a href="#l1.176"></a><span id="l1.176">       return this._datastore._mapFolderID(this._folderID).uri;</span>
<a href="#l1.177"></a><span id="l1.177">     else</span>
<a href="#l1.178"></a><span id="l1.178">       return null;</span>
<a href="#l1.179"></a><span id="l1.179">   },</span>
<a href="#l1.180"></a><span id="l1.180">   get conversation() {</span>
<a href="#l1.181"></a><span id="l1.181">     return this._conversation;</span>
<a href="#l1.182"></a><span id="l1.182" class="difflineat">@@ -318,27 +438,40 @@ GlodaMessage.prototype = {</span>
<a href="#l1.183"></a><span id="l1.183">     this.date = null;</span>
<a href="#l1.184"></a><span id="l1.184">     this._headerMessageID = null;</span>
<a href="#l1.185"></a><span id="l1.185"> </span>
<a href="#l1.186"></a><span id="l1.186">     this._datastore = null;</span>
<a href="#l1.187"></a><span id="l1.187">   },</span>
<a href="#l1.188"></a><span id="l1.188"> </span>
<a href="#l1.189"></a><span id="l1.189">   /**</span>
<a href="#l1.190"></a><span id="l1.190">    * Return the underlying nsIMsgDBHdr from the folder storage for this, or</span>
<a href="#l1.191"></a><span id="l1.191" class="difflineminus">-   *  null if the message does not exist for one reason or another.</span>
<a href="#l1.192"></a><span id="l1.192" class="difflineminus">-   * This method no longer caches the result, so it's up to you.</span>
<a href="#l1.193"></a><span id="l1.193" class="difflineplus">+   *  null if the message does not exist for one reason or another.  We may log</span>
<a href="#l1.194"></a><span id="l1.194" class="difflineplus">+   *  to our logger in the failure cases.</span>
<a href="#l1.195"></a><span id="l1.195" class="difflineplus">+   *  </span>
<a href="#l1.196"></a><span id="l1.196" class="difflineplus">+   * This method no longer caches the result, so if you need to hold onto it,</span>
<a href="#l1.197"></a><span id="l1.197" class="difflineplus">+   *  hold onto it.</span>
<a href="#l1.198"></a><span id="l1.198" class="difflineplus">+   *</span>
<a href="#l1.199"></a><span id="l1.199" class="difflineplus">+   * In the process of retrieving the underlying message header, we may have to</span>
<a href="#l1.200"></a><span id="l1.200" class="difflineplus">+   *  open the message header database associated with the folder.  This may</span>
<a href="#l1.201"></a><span id="l1.201" class="difflineplus">+   *  result in blocking while the load happens, so you may want to try and find</span>
<a href="#l1.202"></a><span id="l1.202" class="difflineplus">+   *  an alternate way to initiate the load before calling us.</span>
<a href="#l1.203"></a><span id="l1.203" class="difflineplus">+   * We provide hinting to the GlodaDatastore via the GlodaFolder so that it</span>
<a href="#l1.204"></a><span id="l1.204" class="difflineplus">+   *  knows when it's a good time for it to go and detach from the database.</span>
<a href="#l1.205"></a><span id="l1.205" class="difflineplus">+   * </span>
<a href="#l1.206"></a><span id="l1.206" class="difflineplus">+   * @returns The nsIMsgDBHdr associated with this message if available, null on</span>
<a href="#l1.207"></a><span id="l1.207" class="difflineplus">+   *     failure.</span>
<a href="#l1.208"></a><span id="l1.208">    */</span>
<a href="#l1.209"></a><span id="l1.209">   get folderMessage() {</span>
<a href="#l1.210"></a><span id="l1.210">     if (this._folderID === null || this._messageKey === null)</span>
<a href="#l1.211"></a><span id="l1.211">       return null;</span>
<a href="#l1.212"></a><span id="l1.212" class="difflineminus">-    let rdfService = Cc['@mozilla.org/rdf/rdf-service;1'].</span>
<a href="#l1.213"></a><span id="l1.213" class="difflineminus">-                     getService(Ci.nsIRDFService);</span>
<a href="#l1.214"></a><span id="l1.214" class="difflineminus">-    let folder = rdfService.GetResource(</span>
<a href="#l1.215"></a><span id="l1.215" class="difflineminus">-                   this._datastore._mapFolderID(this._folderID).uri);</span>
<a href="#l1.216"></a><span id="l1.216" class="difflineminus">-    if (folder instanceof Ci.nsIMsgFolder) {</span>
<a href="#l1.217"></a><span id="l1.217" class="difflineplus">+    </span>
<a href="#l1.218"></a><span id="l1.218" class="difflineplus">+    let glodaFolder = this._datastore._mapFolderID(this._folderID);</span>
<a href="#l1.219"></a><span id="l1.219" class="difflineplus">+    let folder = glodaFolder.getXPCOMFolder(</span>
<a href="#l1.220"></a><span id="l1.220" class="difflineplus">+                   glodaFolder.kActivityHeaderRetrieval);</span>
<a href="#l1.221"></a><span id="l1.221" class="difflineplus">+    if (folder) {</span>
<a href="#l1.222"></a><span id="l1.222">       let folderMessage = folder.GetMessageHeader(this._messageKey);</span>
<a href="#l1.223"></a><span id="l1.223">       if (folderMessage !== null) {</span>
<a href="#l1.224"></a><span id="l1.224">         // verify the message-id header matches what we expect...</span>
<a href="#l1.225"></a><span id="l1.225">         if (folderMessage.messageId != this._headerMessageID) {</span>
<a href="#l1.226"></a><span id="l1.226">           LOG.info(&quot;Message with message key does not match expected &quot; +</span>
<a href="#l1.227"></a><span id="l1.227">                    &quot;header! (&quot; + this._headerMessageID + &quot; expected, got &quot; +</span>
<a href="#l1.228"></a><span id="l1.228">                    folderMessage.messageId + &quot;)&quot;);</span>
<a href="#l1.229"></a><span id="l1.229">           folderMessage = null;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -775,16 +775,22 @@ var GlodaDatastore = {</span>
<a href="#l2.4"></a><span id="l2.4">     //  manage that.</span>
<a href="#l2.5"></a><span id="l2.5">     this._log.debug(&quot;Populating managed id counters.&quot;);</span>
<a href="#l2.6"></a><span id="l2.6">     this._populateAttributeDefManagedId();</span>
<a href="#l2.7"></a><span id="l2.7">     this._populateConversationManagedId();</span>
<a href="#l2.8"></a><span id="l2.8">     this._populateMessageManagedId();</span>
<a href="#l2.9"></a><span id="l2.9">     this._populateContactManagedId();</span>
<a href="#l2.10"></a><span id="l2.10">     this._populateIdentityManagedId();</span>
<a href="#l2.11"></a><span id="l2.11">     </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+    // create the timer we use to periodically drop our references to folders</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+    //  we no longer need XPCOM references to (or more significantly, their</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+    //  message databases.)</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+    this._folderCleanupTimer =</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+      Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+    </span>
<a href="#l2.18"></a><span id="l2.18">     this._log.debug(&quot;Completed datastore initialization.&quot;);</span>
<a href="#l2.19"></a><span id="l2.19">   },</span>
<a href="#l2.20"></a><span id="l2.20"> </span>
<a href="#l2.21"></a><span id="l2.21">   /**</span>
<a href="#l2.22"></a><span id="l2.22">    * Initiate database shutdown; because this might requiring waiting for</span>
<a href="#l2.23"></a><span id="l2.23">    *  outstanding synchronous events to drain, we allow the caller to pass in</span>
<a href="#l2.24"></a><span id="l2.24">    *  a callback to invoke if we are unable to complete shutdown within this</span>
<a href="#l2.25"></a><span id="l2.25">    *  call.</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineat">@@ -796,16 +802,21 @@ var GlodaDatastore = {</span>
<a href="#l2.27"></a><span id="l2.27">     // clear out any transaction</span>
<a href="#l2.28"></a><span id="l2.28">     while (this._transactionDepth) {</span>
<a href="#l2.29"></a><span id="l2.29">       this._log.info(&quot;Closing pending transaction out for shutdown.&quot;);</span>
<a href="#l2.30"></a><span id="l2.30">       // just schedule this function to be run again once the transaction has</span>
<a href="#l2.31"></a><span id="l2.31">       //  been closed out.</span>
<a href="#l2.32"></a><span id="l2.32">       this._commitTransaction();</span>
<a href="#l2.33"></a><span id="l2.33">     }</span>
<a href="#l2.34"></a><span id="l2.34"> </span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+    // shutdown our folder cleanup timer, if active and null it out.</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+    if (this._folderCleanupActive)</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+      this._folderCleanupTimer.cancel();</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+    this._folderCleanupTimer = null;</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineplus">+    </span>
<a href="#l2.40"></a><span id="l2.40">     let datastore = this;</span>
<a href="#l2.41"></a><span id="l2.41"> </span>
<a href="#l2.42"></a><span id="l2.42">     function finish_cleanup() {</span>
<a href="#l2.43"></a><span id="l2.43">       datastore._cleanupAsyncStatements();</span>
<a href="#l2.44"></a><span id="l2.44">       datastore._cleanupSyncStatements();</span>
<a href="#l2.45"></a><span id="l2.45">       datastore._log.info(&quot;Closing db connection&quot;);</span>
<a href="#l2.46"></a><span id="l2.46">       datastore.asyncConnection.close();</span>
<a href="#l2.47"></a><span id="l2.47">       datastore.asyncConnection = null;</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineat">@@ -1370,18 +1381,22 @@ var GlodaDatastore = {</span>
<a href="#l2.49"></a><span id="l2.49">   },</span>
<a href="#l2.50"></a><span id="l2.50"> </span>
<a href="#l2.51"></a><span id="l2.51">   _folderKnown: function gloda_ds_folderKnown(aFolder) {</span>
<a href="#l2.52"></a><span id="l2.52">     let folderURI = aFolder.URI;</span>
<a href="#l2.53"></a><span id="l2.53">     return folderURI in this._folderByURI;</span>
<a href="#l2.54"></a><span id="l2.54">   },</span>
<a href="#l2.55"></a><span id="l2.55"> </span>
<a href="#l2.56"></a><span id="l2.56">   /**</span>
<a href="#l2.57"></a><span id="l2.57" class="difflineminus">-   * Map a folder URI to a folder ID, creating the mapping if it does not yet</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineminus">-   *  exist.</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineplus">+   * Map a folder URI to a GlodaFolder instance, creating the mapping if it does</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineplus">+   *  not yet exist.</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineplus">+   * </span>
<a href="#l2.62"></a><span id="l2.62" class="difflineplus">+   * @param aFolder The nsIMsgFolder instance you would like the GlodaFolder</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineplus">+   *     instance for.</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineplus">+   * @returns The existing or newly created GlodaFolder instance.</span>
<a href="#l2.65"></a><span id="l2.65">    */</span>
<a href="#l2.66"></a><span id="l2.66">   _mapFolder: function gloda_ds_mapFolderURI(aFolder) {</span>
<a href="#l2.67"></a><span id="l2.67">     let folderURI = aFolder.URI;</span>
<a href="#l2.68"></a><span id="l2.68">     if (folderURI in this._folderByURI) {</span>
<a href="#l2.69"></a><span id="l2.69">       return this._folderByURI[folderURI];</span>
<a href="#l2.70"></a><span id="l2.70">     }</span>
<a href="#l2.71"></a><span id="l2.71"> </span>
<a href="#l2.72"></a><span id="l2.72">     let folderID = this._nextFolderId++;</span>
<a href="#l2.73"></a><span id="l2.73" class="difflineat">@@ -1397,16 +1412,24 @@ var GlodaDatastore = {</span>
<a href="#l2.74"></a><span id="l2.74">     this._insertFolderLocationStatement.executeAsync(this.trackAsync());</span>
<a href="#l2.75"></a><span id="l2.75"> </span>
<a href="#l2.76"></a><span id="l2.76">     this._folderByURI[folderURI] = folder;</span>
<a href="#l2.77"></a><span id="l2.77">     this._folderByID[folderID] = folder;</span>
<a href="#l2.78"></a><span id="l2.78">     this._log.debug(&quot;!! mapped &quot; + folder.id + &quot; from &quot; + folderURI);</span>
<a href="#l2.79"></a><span id="l2.79">     return folder;</span>
<a href="#l2.80"></a><span id="l2.80">   },</span>
<a href="#l2.81"></a><span id="l2.81"> </span>
<a href="#l2.82"></a><span id="l2.82" class="difflineplus">+  /**</span>
<a href="#l2.83"></a><span id="l2.83" class="difflineplus">+   * Map an integer gloda folder ID to the corresponding GlodaFolder instance.  </span>
<a href="#l2.84"></a><span id="l2.84" class="difflineplus">+   * </span>
<a href="#l2.85"></a><span id="l2.85" class="difflineplus">+   * @param aFolderID The known valid gloda folder ID for which you would like</span>
<a href="#l2.86"></a><span id="l2.86" class="difflineplus">+   *     a GlodaFolder instance.</span>
<a href="#l2.87"></a><span id="l2.87" class="difflineplus">+   * @return The GlodaFolder instance with the given id.  If no such instance</span>
<a href="#l2.88"></a><span id="l2.88" class="difflineplus">+   *     exists, we will throw an exception.</span>
<a href="#l2.89"></a><span id="l2.89" class="difflineplus">+   */</span>
<a href="#l2.90"></a><span id="l2.90">   _mapFolderID: function gloda_ds_mapFolderID(aFolderID) {</span>
<a href="#l2.91"></a><span id="l2.91">     if (aFolderID === null)</span>
<a href="#l2.92"></a><span id="l2.92">       return null;</span>
<a href="#l2.93"></a><span id="l2.93">     if (aFolderID in this._folderByID)</span>
<a href="#l2.94"></a><span id="l2.94">       return this._folderByID[aFolderID];</span>
<a href="#l2.95"></a><span id="l2.95">     throw &quot;Got impossible folder ID: &quot; + aFolderID;</span>
<a href="#l2.96"></a><span id="l2.96">   },</span>
<a href="#l2.97"></a><span id="l2.97"> </span>
<a href="#l2.98"></a><span id="l2.98" class="difflineat">@@ -1462,17 +1485,88 @@ var GlodaDatastore = {</span>
<a href="#l2.99"></a><span id="l2.99">     return this._deleteFolderByIDStatement;</span>
<a href="#l2.100"></a><span id="l2.100">   },</span>
<a href="#l2.101"></a><span id="l2.101"> </span>
<a href="#l2.102"></a><span id="l2.102">   deleteFolderByID: function gloda_ds_deleteFolder(aFolderID) {</span>
<a href="#l2.103"></a><span id="l2.103">     let dfbis = this._deleteFolderByIDStatement;</span>
<a href="#l2.104"></a><span id="l2.104">     dfbis.bindInt64Parameter(0, aFolderID);</span>
<a href="#l2.105"></a><span id="l2.105">     dfbis.executeAsync(this.trackAsync());</span>
<a href="#l2.106"></a><span id="l2.106">   },</span>
<a href="#l2.107"></a><span id="l2.107" class="difflineplus">+  </span>
<a href="#l2.108"></a><span id="l2.108" class="difflineplus">+  /**</span>
<a href="#l2.109"></a><span id="l2.109" class="difflineplus">+   * This timer drives our folder cleanup logic that is in charge of dropping</span>
<a href="#l2.110"></a><span id="l2.110" class="difflineplus">+   *  our folder references and more importantly the folder's msgDatabase</span>
<a href="#l2.111"></a><span id="l2.111" class="difflineplus">+   *  reference, but only if they are no longer in use.</span>
<a href="#l2.112"></a><span id="l2.112" class="difflineplus">+   * This timer is only active when we have one or more live gloda folders (as</span>
<a href="#l2.113"></a><span id="l2.113" class="difflineplus">+   *  tracked by _liveGlodaFolders).  Although we choose our timer interval to</span>
<a href="#l2.114"></a><span id="l2.114" class="difflineplus">+   *  be power-friendly, it doesn't really matter because unless the user or the</span>
<a href="#l2.115"></a><span id="l2.115" class="difflineplus">+   *  indexing process is actively doing things, all of the folders will 'die'</span>
<a href="#l2.116"></a><span id="l2.116" class="difflineplus">+   *  and so we will stop scheduling the timer.</span>
<a href="#l2.117"></a><span id="l2.117" class="difflineplus">+   */</span>
<a href="#l2.118"></a><span id="l2.118" class="difflineplus">+  _folderCleanupTimer: null,</span>
<a href="#l2.119"></a><span id="l2.119" class="difflineplus">+  </span>
<a href="#l2.120"></a><span id="l2.120" class="difflineplus">+  /**</span>
<a href="#l2.121"></a><span id="l2.121" class="difflineplus">+   * When true, we have a folder cleanup timer event active.</span>
<a href="#l2.122"></a><span id="l2.122" class="difflineplus">+   */</span>
<a href="#l2.123"></a><span id="l2.123" class="difflineplus">+  _folderCleanupActive: false,</span>
<a href="#l2.124"></a><span id="l2.124" class="difflineplus">+  </span>
<a href="#l2.125"></a><span id="l2.125" class="difflineplus">+  /**</span>
<a href="#l2.126"></a><span id="l2.126" class="difflineplus">+   * Interval at which we call the folder cleanup code, in milliseconds.</span>
<a href="#l2.127"></a><span id="l2.127" class="difflineplus">+   */</span>
<a href="#l2.128"></a><span id="l2.128" class="difflineplus">+  _folderCleanupTimerInterval: 2000,</span>
<a href="#l2.129"></a><span id="l2.129" class="difflineplus">+  </span>
<a href="#l2.130"></a><span id="l2.130" class="difflineplus">+  /**</span>
<a href="#l2.131"></a><span id="l2.131" class="difflineplus">+   * Maps the id of 'live' GlodaFolders to the instances.  If a GlodaFolder is</span>
<a href="#l2.132"></a><span id="l2.132" class="difflineplus">+   *  in here, it means that it has a reference to its nsIMsgDBFolder which</span>
<a href="#l2.133"></a><span id="l2.133" class="difflineplus">+   *  should have an open nsIMsgDatabase that we will need to close.  This does</span>
<a href="#l2.134"></a><span id="l2.134" class="difflineplus">+   *  not count folders that are being indexed unless they have also been used</span>
<a href="#l2.135"></a><span id="l2.135" class="difflineplus">+   *  for header retrieval.</span>
<a href="#l2.136"></a><span id="l2.136" class="difflineplus">+   */</span>
<a href="#l2.137"></a><span id="l2.137" class="difflineplus">+  _liveGlodaFolders: {},</span>
<a href="#l2.138"></a><span id="l2.138"> </span>
<a href="#l2.139"></a><span id="l2.139" class="difflineplus">+  /**</span>
<a href="#l2.140"></a><span id="l2.140" class="difflineplus">+   * Mark a GlodaFolder as having a live reference to its nsIMsgFolder with an</span>
<a href="#l2.141"></a><span id="l2.141" class="difflineplus">+   *  implied opened associated message database.  GlodaFolder calls this when</span>
<a href="#l2.142"></a><span id="l2.142" class="difflineplus">+   *  it first acquires its reference.  It is removed from the list of live</span>
<a href="#l2.143"></a><span id="l2.143" class="difflineplus">+   *  folders only when our timer check calls the GlodaFolder's</span>
<a href="#l2.144"></a><span id="l2.144" class="difflineplus">+   *  forgetFolderIfUnused method and that method returns true.</span>
<a href="#l2.145"></a><span id="l2.145" class="difflineplus">+   */</span>
<a href="#l2.146"></a><span id="l2.146" class="difflineplus">+  markFolderLive: function gloda_ds_markFolderLive(aGlodaFolder) {</span>
<a href="#l2.147"></a><span id="l2.147" class="difflineplus">+    this._liveGlodaFolders[aGlodaFolder.id] = aGlodaFolder;</span>
<a href="#l2.148"></a><span id="l2.148" class="difflineplus">+    if (!this._folderCleanupActive) {</span>
<a href="#l2.149"></a><span id="l2.149" class="difflineplus">+      this._folderCleanupTimer.initWithCallback(this._performFolderCleanup,</span>
<a href="#l2.150"></a><span id="l2.150" class="difflineplus">+        this._folderCleanupTimerInterval, Ci.nsITimer.TYPE_REPEATING_SLACK);</span>
<a href="#l2.151"></a><span id="l2.151" class="difflineplus">+      this._folderCleanupActive = true;</span>
<a href="#l2.152"></a><span id="l2.152" class="difflineplus">+    }</span>
<a href="#l2.153"></a><span id="l2.153" class="difflineplus">+  },</span>
<a href="#l2.154"></a><span id="l2.154" class="difflineplus">+  </span>
<a href="#l2.155"></a><span id="l2.155" class="difflineplus">+  /**</span>
<a href="#l2.156"></a><span id="l2.156" class="difflineplus">+   * Timer-driven folder cleanup logic.  For every live folder tracked in</span>
<a href="#l2.157"></a><span id="l2.157" class="difflineplus">+   *  _liveGlodaFolders, we call their forgetFolderIfUnused method each time</span>
<a href="#l2.158"></a><span id="l2.158" class="difflineplus">+   *  until they return true indicating they have cleaned themselves up.</span>
<a href="#l2.159"></a><span id="l2.159" class="difflineplus">+   * This method is called without a 'this' context! </span>
<a href="#l2.160"></a><span id="l2.160" class="difflineplus">+   */</span>
<a href="#l2.161"></a><span id="l2.161" class="difflineplus">+  _performFolderCleanup: function gloda_ds_performFolderCleanup() {</span>
<a href="#l2.162"></a><span id="l2.162" class="difflineplus">+    // we only need to keep going if there is at least one folder in the table</span>
<a href="#l2.163"></a><span id="l2.163" class="difflineplus">+    //  that is still alive after this pass.</span>
<a href="#l2.164"></a><span id="l2.164" class="difflineplus">+    let keepGoing = false;</span>
<a href="#l2.165"></a><span id="l2.165" class="difflineplus">+    for each (let glodaFolder in GlodaDatastore._liveGlodaFolders) {</span>
<a href="#l2.166"></a><span id="l2.166" class="difflineplus">+      // returns true if it is now 'dead' and doesn't need this heartbeat check</span>
<a href="#l2.167"></a><span id="l2.167" class="difflineplus">+      if (glodaFolder.forgetFolderIfUnused())</span>
<a href="#l2.168"></a><span id="l2.168" class="difflineplus">+        delete GlodaDatastore._liveGlodaFolders[glodaFolder.id];</span>
<a href="#l2.169"></a><span id="l2.169" class="difflineplus">+      else</span>
<a href="#l2.170"></a><span id="l2.170" class="difflineplus">+        keepGoing = true;</span>
<a href="#l2.171"></a><span id="l2.171" class="difflineplus">+    }</span>
<a href="#l2.172"></a><span id="l2.172" class="difflineplus">+    </span>
<a href="#l2.173"></a><span id="l2.173" class="difflineplus">+    if (!keepGoing) {</span>
<a href="#l2.174"></a><span id="l2.174" class="difflineplus">+      GlodaDatastore._folderCleanupTimer.cancel();</span>
<a href="#l2.175"></a><span id="l2.175" class="difflineplus">+      GlodaDatastore._folderCleanupActive = false;</span>
<a href="#l2.176"></a><span id="l2.176" class="difflineplus">+    }</span>
<a href="#l2.177"></a><span id="l2.177" class="difflineplus">+  },</span>
<a href="#l2.178"></a><span id="l2.178" class="difflineplus">+  </span>
<a href="#l2.179"></a><span id="l2.179">   /* ********** Conversation ********** */</span>
<a href="#l2.180"></a><span id="l2.180">   /** The next conversation id to allocate.  Initialize at startup. */</span>
<a href="#l2.181"></a><span id="l2.181">   _nextConversationId: 1,</span>
<a href="#l2.182"></a><span id="l2.182"> </span>
<a href="#l2.183"></a><span id="l2.183">   _populateConversationManagedId: function () {</span>
<a href="#l2.184"></a><span id="l2.184">     let stmt = this._createSyncStatement(</span>
<a href="#l2.185"></a><span id="l2.185">       &quot;SELECT MAX(id) FROM conversations&quot;, true);</span>
<a href="#l2.186"></a><span id="l2.186">     if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -790,19 +790,26 @@ var GlodaIndexer = {</span>
<a href="#l3.4"></a><span id="l3.4">     for (let iListener = this._indexListeners.length-1; iListener &gt;= 0; </span>
<a href="#l3.5"></a><span id="l3.5">          iListener--) {</span>
<a href="#l3.6"></a><span id="l3.6">       let listener = this._indexListeners[iListener];</span>
<a href="#l3.7"></a><span id="l3.7">       listener(status, prettyName, jobIndex, jobTotal, jobItemIndex,</span>
<a href="#l3.8"></a><span id="l3.8">                jobItemGoal);</span>
<a href="#l3.9"></a><span id="l3.9">     }</span>
<a href="#l3.10"></a><span id="l3.10">   },</span>
<a href="#l3.11"></a><span id="l3.11">   </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-  _indexingFolderID: null,</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+  /** The GlodaFolder corresponding to the folder we are indexing. */</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+  _indexingGlodaFolder: null,</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+  /** The nsIMsgFolder we are currently indexing. */</span>
<a href="#l3.16"></a><span id="l3.16">   _indexingFolder: null,</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+  /** The nsIMsgDatabase we are currently indexing. */</span>
<a href="#l3.18"></a><span id="l3.18">   _indexingDatabase: null,</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+  /**</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+   * The iterator we are using to iterate over the headers in</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+   *  this._indexingDatabase.</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineplus">+   */</span>
<a href="#l3.23"></a><span id="l3.23">   _indexingIterator: null,</span>
<a href="#l3.24"></a><span id="l3.24">   </span>
<a href="#l3.25"></a><span id="l3.25">   /** folder whose entry we are pending on */</span>
<a href="#l3.26"></a><span id="l3.26">   _pendingFolderEntry: null,</span>
<a href="#l3.27"></a><span id="l3.27">   </span>
<a href="#l3.28"></a><span id="l3.28">   /**</span>
<a href="#l3.29"></a><span id="l3.29">    * Common logic that we want to deal with the given folder ID.  Besides</span>
<a href="#l3.30"></a><span id="l3.30">    *  cutting down on duplicate code, this ensures that we are listening on</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineat">@@ -817,62 +824,62 @@ var GlodaIndexer = {</span>
<a href="#l3.32"></a><span id="l3.32">                                                                aNeedIterator) {</span>
<a href="#l3.33"></a><span id="l3.33">     // if leave folder was't cleared first, remove the listener; everyone else</span>
<a href="#l3.34"></a><span id="l3.34">     //  will be nulled out in the exception handler below if things go south</span>
<a href="#l3.35"></a><span id="l3.35">     //  on this folder.</span>
<a href="#l3.36"></a><span id="l3.36">     if (this._indexingFolder !== null) {</span>
<a href="#l3.37"></a><span id="l3.37">       this._indexingDatabase.RemoveListener(this._databaseAnnouncerListener);</span>
<a href="#l3.38"></a><span id="l3.38">     }</span>
<a href="#l3.39"></a><span id="l3.39">     </span>
<a href="#l3.40"></a><span id="l3.40" class="difflineminus">-    let glodaFolder = GlodaDatastore._mapFolderID(aFolderID);</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineminus">-  </span>
<a href="#l3.42"></a><span id="l3.42" class="difflineminus">-    let rdfService = Cc['@mozilla.org/rdf/rdf-service;1'].</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineminus">-                     getService(Ci.nsIRDFService);</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineminus">-    let folder = rdfService.GetResource(glodaFolder.uri);</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineminus">-    folder.QueryInterface(Ci.nsIMsgFolder); // (we want to explode in the try</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineminus">-    // if this guy wasn't what we wanted)</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineminus">-    this._indexingFolder = folder;</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineminus">-    this._indexingFolderID = aFolderID;</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineplus">+    this._indexingGlodaFolder = GlodaDatastore._mapFolderID(aFolderID);</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineplus">+    this._indexingFolder = this._indexingGlodaFolder.getXPCOMFolder(</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+                             this._indexingGlodaFolder.kActivityIndexing);</span>
<a href="#l3.52"></a><span id="l3.52"> </span>
<a href="#l3.53"></a><span id="l3.53">     try {</span>
<a href="#l3.54"></a><span id="l3.54">       // The msf may need to be created or otherwise updated for local folders.</span>
<a href="#l3.55"></a><span id="l3.55">       // This may require yielding until such time as the msf has been created.</span>
<a href="#l3.56"></a><span id="l3.56">       try {</span>
<a href="#l3.57"></a><span id="l3.57">         if (this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder) {</span>
<a href="#l3.58"></a><span id="l3.58">           this._indexingDatabase =</span>
<a href="#l3.59"></a><span id="l3.59">             this._indexingFolder.getDatabaseWithReparse(this._indexingFolder,</span>
<a href="#l3.60"></a><span id="l3.60">                                                         null);</span>
<a href="#l3.61"></a><span id="l3.61">         }</span>
<a href="#l3.62"></a><span id="l3.62">         // we need do nothing special for IMAP, news, or other</span>
<a href="#l3.63"></a><span id="l3.63">       }</span>
<a href="#l3.64"></a><span id="l3.64">       catch ( e if e.result == Cr.NS_ERROR_NOT_INITIALIZED) {</span>
<a href="#l3.65"></a><span id="l3.65">         // this means that we need to pend on the update.</span>
<a href="#l3.66"></a><span id="l3.66">         this._log.debug(&quot;Pending on folder load...&quot;);</span>
<a href="#l3.67"></a><span id="l3.67">         this._pendingFolderEntry = this._indexingFolder;</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineplus">+        // do not set _indexingGlodaFolder.indexing to false at this point,</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineplus">+        //  because it might decide to sever the nsIMsgFolder's reference to the</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineplus">+        //  database which would, at the very least, confuse things.</span>
<a href="#l3.71"></a><span id="l3.71">         this._indexingFolder = null;</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineminus">-        this._indexingFolderID = null;</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineplus">+        this._indexingGlodaFolder = null;</span>
<a href="#l3.74"></a><span id="l3.74">         this._indexingDatabase = null;</span>
<a href="#l3.75"></a><span id="l3.75">         this._indexingIterator = null;</span>
<a href="#l3.76"></a><span id="l3.76">         return this.kWorkAsync;</span>
<a href="#l3.77"></a><span id="l3.77">       }</span>
<a href="#l3.78"></a><span id="l3.78">       // we get an nsIMsgDatabase out of this (unsurprisingly) which</span>
<a href="#l3.79"></a><span id="l3.79">       //  explicitly inherits from nsIDBChangeAnnouncer, which has the</span>
<a href="#l3.80"></a><span id="l3.80">       //  AddListener call we want.</span>
<a href="#l3.81"></a><span id="l3.81">       if (this._indexingDatabase == null)</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineminus">-        this._indexingDatabase = folder.getMsgDatabase(null);</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineplus">+        this._indexingDatabase = this._indexingFolder.getMsgDatabase(null);</span>
<a href="#l3.84"></a><span id="l3.84">       if (aNeedIterator)</span>
<a href="#l3.85"></a><span id="l3.85">         this._indexerGetIterator();</span>
<a href="#l3.86"></a><span id="l3.86">       this._indexingDatabase.AddListener(this._databaseAnnouncerListener);</span>
<a href="#l3.87"></a><span id="l3.87">     }</span>
<a href="#l3.88"></a><span id="l3.88">     catch (ex) {</span>
<a href="#l3.89"></a><span id="l3.89">       this._log.error(&quot;Problem entering folder: &quot; +</span>
<a href="#l3.90"></a><span id="l3.90" class="difflineminus">-                      folder.prettiestName + &quot;, skipping.&quot;);</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+                      (this._indexingFolder ?</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineplus">+                         this._indexingFolder.prettiestName : &quot;unknown&quot;) + </span>
<a href="#l3.93"></a><span id="l3.93" class="difflineplus">+                      &quot;, skipping.&quot;);</span>
<a href="#l3.94"></a><span id="l3.94">       this._log.error(&quot;Error was: &quot; + ex);</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineplus">+      this._indexingGlodaFolder.indexing = false;</span>
<a href="#l3.96"></a><span id="l3.96">       this._indexingFolder = null;</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineminus">-      this._indexingFolderID = null;</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineplus">+      this._indexingGlodaFolder = null;</span>
<a href="#l3.99"></a><span id="l3.99">       this._indexingDatabase = null;</span>
<a href="#l3.100"></a><span id="l3.100">       this._indexingIterator = null;</span>
<a href="#l3.101"></a><span id="l3.101">       </span>
<a href="#l3.102"></a><span id="l3.102">       // re-throw, we just wanted to make sure this junk is cleaned up and</span>
<a href="#l3.103"></a><span id="l3.103">       //  get localized error logging...</span>
<a href="#l3.104"></a><span id="l3.104">       throw ex;</span>
<a href="#l3.105"></a><span id="l3.105">     }</span>
<a href="#l3.106"></a><span id="l3.106">     </span>
<a href="#l3.107"></a><span id="l3.107" class="difflineat">@@ -882,21 +889,24 @@ var GlodaIndexer = {</span>
<a href="#l3.108"></a><span id="l3.108">   _indexerGetIterator: function gloda_indexer_indexerGetIterator() {</span>
<a href="#l3.109"></a><span id="l3.109">     this._indexingIterator = fixIterator(</span>
<a href="#l3.110"></a><span id="l3.110">                                this._indexingDatabase.EnumerateMessages(),</span>
<a href="#l3.111"></a><span id="l3.111">                                Ci.nsIMsgDBHdr);</span>
<a href="#l3.112"></a><span id="l3.112">   },</span>
<a href="#l3.113"></a><span id="l3.113">   </span>
<a href="#l3.114"></a><span id="l3.114">   _indexerLeaveFolder: function gloda_index_indexerLeaveFolder(aExpected) {</span>
<a href="#l3.115"></a><span id="l3.115">     if (this._indexingFolder !== null) {</span>
<a href="#l3.116"></a><span id="l3.116" class="difflineplus">+      this._indexingDatabase.Commit(Ci.nsMsgDBCommitType.kLargeCommit);</span>
<a href="#l3.117"></a><span id="l3.117">       // remove our listener!</span>
<a href="#l3.118"></a><span id="l3.118">       this._indexingDatabase.RemoveListener(this._databaseAnnouncerListener);</span>
<a href="#l3.119"></a><span id="l3.119" class="difflineplus">+      // let the gloda folder know we are done indexing</span>
<a href="#l3.120"></a><span id="l3.120" class="difflineplus">+      this._indexingGlodaFolder.indexing = false;</span>
<a href="#l3.121"></a><span id="l3.121">       // null everyone out</span>
<a href="#l3.122"></a><span id="l3.122">       this._indexingFolder = null;</span>
<a href="#l3.123"></a><span id="l3.123" class="difflineminus">-      this._indexingFolderID = null;</span>
<a href="#l3.124"></a><span id="l3.124" class="difflineplus">+      this._indexingGlodaFolder = null;</span>
<a href="#l3.125"></a><span id="l3.125">       this._indexingDatabase = null;</span>
<a href="#l3.126"></a><span id="l3.126">       this._indexingIterator = null;</span>
<a href="#l3.127"></a><span id="l3.127">       // ...including the active job:</span>
<a href="#l3.128"></a><span id="l3.128">       this._curIndexingJob = null;</span>
<a href="#l3.129"></a><span id="l3.129">     }</span>
<a href="#l3.130"></a><span id="l3.130">   },</span>
<a href="#l3.131"></a><span id="l3.131">   </span>
<a href="#l3.132"></a><span id="l3.132">   /**</span>
<a href="#l3.133"></a><span id="l3.133" class="difflineat">@@ -1414,17 +1424,18 @@ var GlodaIndexer = {</span>
<a href="#l3.134"></a><span id="l3.134">    */</span>
<a href="#l3.135"></a><span id="l3.135">   _worker_messageIndex: function gloda_worker_messageAdd(aJob) {</span>
<a href="#l3.136"></a><span id="l3.136">     for (; aJob.offset &lt; aJob.items.length; aJob.offset++) {</span>
<a href="#l3.137"></a><span id="l3.137">       let item = aJob.items[aJob.offset];</span>
<a href="#l3.138"></a><span id="l3.138">       // item is either [folder ID, message key] or</span>
<a href="#l3.139"></a><span id="l3.139">       //                [folder ID, message ID]</span>
<a href="#l3.140"></a><span id="l3.140"> </span>
<a href="#l3.141"></a><span id="l3.141">       // get in the folder</span>
<a href="#l3.142"></a><span id="l3.142" class="difflineminus">-      if (this._indexingFolderID != item[0])</span>
<a href="#l3.143"></a><span id="l3.143" class="difflineplus">+      if (!this._indexingGlodaFolder ||</span>
<a href="#l3.144"></a><span id="l3.144" class="difflineplus">+          this._indexingGlodaFolder.id != item[0])</span>
<a href="#l3.145"></a><span id="l3.145">         yield this._indexerEnterFolder(item[0], false);</span>
<a href="#l3.146"></a><span id="l3.146"> </span>
<a href="#l3.147"></a><span id="l3.147">       let msgHdr;</span>
<a href="#l3.148"></a><span id="l3.148">       if (typeof item[1] == &quot;number&quot;)</span>
<a href="#l3.149"></a><span id="l3.149">         msgHdr = this._indexingFolder.GetMessageHeader(item[1]);</span>
<a href="#l3.150"></a><span id="l3.150">       else</span>
<a href="#l3.151"></a><span id="l3.151">         // same deal as in move processing.</span>
<a href="#l3.152"></a><span id="l3.152">         // TODO fixme to not assume singular message-id's.</span>
<a href="#l3.153"></a><span id="l3.153" class="difflineat">@@ -2179,29 +2190,30 @@ var GlodaIndexer = {</span>
<a href="#l3.154"></a><span id="l3.154">       </span>
<a href="#l3.155"></a><span id="l3.155">       if (candMsg.folderURI == aMsgHdr.folder.URI) {</span>
<a href="#l3.156"></a><span id="l3.156">         // if we are in the same folder and we have the same message key, we</span>
<a href="#l3.157"></a><span id="l3.157">         //  are definitely the same, stop looking.</span>
<a href="#l3.158"></a><span id="l3.158">         if (candMsg.messageKey == aMsgHdr.messageKey) {</span>
<a href="#l3.159"></a><span id="l3.159">           curMsg = candMsg;</span>
<a href="#l3.160"></a><span id="l3.160">           break;</span>
<a href="#l3.161"></a><span id="l3.161">         }</span>
<a href="#l3.162"></a><span id="l3.162" class="difflineminus">-        // if we are in the same folder and the candidate message has a null</span>
<a href="#l3.163"></a><span id="l3.163" class="difflineplus">+        // if (we are in the same folder and) the candidate message has a null</span>
<a href="#l3.164"></a><span id="l3.164">         //  message key, we treat it as our best option unless we find an exact</span>
<a href="#l3.165"></a><span id="l3.165">         //  key match. (this would happen because the 'move' notification case</span>
<a href="#l3.166"></a><span id="l3.166">         //  has to deal with not knowing the target message key.  this case</span>
<a href="#l3.167"></a><span id="l3.167">         //  will hopefully be somewhat improved in the future to not go through</span>
<a href="#l3.168"></a><span id="l3.168">         //  this path which mandates re-indexing of the message in its entirety)</span>
<a href="#l3.169"></a><span id="l3.169">         if (candMsg.messageKey === null)</span>
<a href="#l3.170"></a><span id="l3.170">           curMsg = candMsg;</span>
<a href="#l3.171"></a><span id="l3.171" class="difflineminus">-        // if we are in the same folder and the candidate message's underlying</span>
<a href="#l3.172"></a><span id="l3.172" class="difflineplus">+        // if (we are in the same folder and) the candidate message's underlying</span>
<a href="#l3.173"></a><span id="l3.173">         //  message no longer exists/matches, we'll assume we are the same but</span>
<a href="#l3.174"></a><span id="l3.174">         //  were betrayed by a re-indexing or something, but we have to make</span>
<a href="#l3.175"></a><span id="l3.175">         //  sure a perfect match doesn't turn up.</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineminus">-        else if ((curMsg === null) &amp;&amp; (candMsg.folderMessage === null))</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineplus">+        else if ((curMsg === null) &amp;&amp;</span>
<a href="#l3.178"></a><span id="l3.178" class="difflineplus">+                 (aMsgHdr.folder.GetMessageHeader(candMsg.messageKey) === null))</span>
<a href="#l3.179"></a><span id="l3.179">           curMsg = candMsg;</span>
<a href="#l3.180"></a><span id="l3.180">       }</span>
<a href="#l3.181"></a><span id="l3.181">       // our choice of last resort, but still okay, is a ghost message</span>
<a href="#l3.182"></a><span id="l3.182">       else if ((curMsg === null) &amp;&amp; (candMsg.folderID === null)) {</span>
<a href="#l3.183"></a><span id="l3.183">         curMsg = candMsg;</span>
<a href="#l3.184"></a><span id="l3.184">       }</span>
<a href="#l3.185"></a><span id="l3.185">     }</span>
<a href="#l3.186"></a><span id="l3.186">     </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/db/gloda/test/resources/glodaTestHelper.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/db/gloda/test/resources/glodaTestHelper.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -318,67 +318,98 @@ function killFakeServer() {</span>
<a href="#l4.4"></a><span id="l4.4">  * Our catch-all collection listener.  Any time a new message gets indexed,</span>
<a href="#l4.5"></a><span id="l4.5">  *  we should receive an onItemsAdded call.  Any time an existing message</span>
<a href="#l4.6"></a><span id="l4.6">  *  gets reindexed, we should receive an onItemsModified call.  Any time an</span>
<a href="#l4.7"></a><span id="l4.7">  *  existing message actually gets purged from the system, we should receive</span>
<a href="#l4.8"></a><span id="l4.8">  *  an onItemsRemoved call.</span>
<a href="#l4.9"></a><span id="l4.9">  */</span>
<a href="#l4.10"></a><span id="l4.10"> var messageCollectionListener = {</span>
<a href="#l4.11"></a><span id="l4.11">   onItemsAdded: function(aItems) {</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-    dump(&quot;onItemsAdded\n&quot;);</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+    dump(&quot;@@@ messageCollectionListener.onItemsAdded\n&quot;);</span>
<a href="#l4.14"></a><span id="l4.14">     let ims = indexMessageState;</span>
<a href="#l4.15"></a><span id="l4.15">     ims.glodaMessages = ims.glodaMessages.concat(aItems);</span>
<a href="#l4.16"></a><span id="l4.16">   },</span>
<a href="#l4.17"></a><span id="l4.17">   </span>
<a href="#l4.18"></a><span id="l4.18">   onItemsModified: function(aItems) {</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineminus">-    dump(&quot;onItemsModified\n&quot;);</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineplus">+    dump(&quot;@@@ messageCollectionListener.onItemsModified\n&quot;);</span>
<a href="#l4.21"></a><span id="l4.21">     let ims = indexMessageState;</span>
<a href="#l4.22"></a><span id="l4.22">     ims.glodaMessages = ims.glodaMessages.concat(aItems);</span>
<a href="#l4.23"></a><span id="l4.23">   },</span>
<a href="#l4.24"></a><span id="l4.24">   </span>
<a href="#l4.25"></a><span id="l4.25">   onItemsRemoved: function(aItems) {</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineplus">+    dump(&quot;!!! messageCollectionListener.onItemsRemoved\n&quot;);</span>
<a href="#l4.27"></a><span id="l4.27">   }</span>
<a href="#l4.28"></a><span id="l4.28"> };</span>
<a href="#l4.29"></a><span id="l4.29"> </span>
<a href="#l4.30"></a><span id="l4.30"> /**</span>
<a href="#l4.31"></a><span id="l4.31">  * Gloda indexer listener, used to know when all active indexing jobs have</span>
<a href="#l4.32"></a><span id="l4.32">  *  completed so that we can try and process all the things that should have</span>
<a href="#l4.33"></a><span id="l4.33">  *  been processed.</span>
<a href="#l4.34"></a><span id="l4.34">  */</span>
<a href="#l4.35"></a><span id="l4.35"> var messageIndexerListener = {</span>
<a href="#l4.36"></a><span id="l4.36">   onIndexNotification: function(aStatus, aPrettyName, aJobIndex, aJobTotal,</span>
<a href="#l4.37"></a><span id="l4.37">                                 aJobItemIndex, aJobItemGoal) {</span>
<a href="#l4.38"></a><span id="l4.38">     // we only care if indexing has just completed...</span>
<a href="#l4.39"></a><span id="l4.39">     if (!GlodaIndexer.indexing) {</span>
<a href="#l4.40"></a><span id="l4.40">       let ims = indexMessageState;</span>
<a href="#l4.41"></a><span id="l4.41">       </span>
<a href="#l4.42"></a><span id="l4.42">       // this is just the synthetic notification if inputMessages is null</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineminus">-      if (ims.inputMessages === null)</span>
<a href="#l4.44"></a><span id="l4.44" class="difflineminus">-       return;</span>
<a href="#l4.45"></a><span id="l4.45" class="difflineplus">+      if (ims.inputMessages === null) {</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineplus">+        dump(&quot;((( ignoring indexing notification, assuming synthetic &quot; +</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineplus">+             &quot;notification.\n&quot;);</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineplus">+        return;</span>
<a href="#l4.49"></a><span id="l4.49" class="difflineplus">+      }</span>
<a href="#l4.50"></a><span id="l4.50"> </span>
<a href="#l4.51"></a><span id="l4.51">       // if we haven't seen all the messages we should see, assume that the</span>
<a href="#l4.52"></a><span id="l4.52">       //  rest are on their way, and are just coming in a subsequent job...</span>
<a href="#l4.53"></a><span id="l4.53">       // (Also, the first time we register our listener, we will get a synthetic</span>
<a href="#l4.54"></a><span id="l4.54">       //  idle status; at least if the indexer is idle.)</span>
<a href="#l4.55"></a><span id="l4.55">       if (ims.glodaMessages.length &lt; ims.inputMessages.length) {</span>
<a href="#l4.56"></a><span id="l4.56" class="difflineplus">+        dump(&quot;((( indexing is no longer indexing, but we're still expecting &quot; +</span>
<a href="#l4.57"></a><span id="l4.57" class="difflineplus">+             &quot;more results, ignoring.\n&quot;);</span>
<a href="#l4.58"></a><span id="l4.58">         return;</span>
<a href="#l4.59"></a><span id="l4.59">       }</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineplus">+      </span>
<a href="#l4.61"></a><span id="l4.61" class="difflineplus">+      dump(&quot;((( indexer notification (&quot; + ims.glodaMessages.length + </span>
<a href="#l4.62"></a><span id="l4.62" class="difflineplus">+           &quot; messages) about to verify: &quot; +</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineplus">+           (ims.verifier ? ims.verifier.name : &quot;none&quot;) + &quot; and complete: &quot; +</span>
<a href="#l4.64"></a><span id="l4.64" class="difflineplus">+           (ims.onDone ? ims.onDone.name : &quot;none&quot;) + &quot;\n&quot;);</span>
<a href="#l4.65"></a><span id="l4.65">     </span>
<a href="#l4.66"></a><span id="l4.66">       // call the verifier.  (we expect them to generate an exception if the</span>
<a href="#l4.67"></a><span id="l4.67">       //  verification fails, using do_check_*/do_throw; we don't care about</span>
<a href="#l4.68"></a><span id="l4.68">       //  the return value except to propagate forward to subsequent calls.)</span>
<a href="#l4.69"></a><span id="l4.69">       for (let iMessage=0; iMessage &lt; ims.inputMessages.length; iMessage++) {</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineminus">-        if (ims.verifier)</span>
<a href="#l4.71"></a><span id="l4.71" class="difflineminus">-          ims.previousValue = ims.verifier(ims.inputMessages[iMessage],</span>
<a href="#l4.72"></a><span id="l4.72" class="difflineminus">-                                           ims.glodaMessages[iMessage],</span>
<a href="#l4.73"></a><span id="l4.73" class="difflineminus">-                                           ims.previousValue);</span>
<a href="#l4.74"></a><span id="l4.74" class="difflineplus">+        if (ims.verifier) {</span>
<a href="#l4.75"></a><span id="l4.75" class="difflineplus">+          try {</span>
<a href="#l4.76"></a><span id="l4.76" class="difflineplus">+            ims.previousValue = ims.verifier(ims.inputMessages[iMessage],</span>
<a href="#l4.77"></a><span id="l4.77" class="difflineplus">+                                             ims.glodaMessages[iMessage],</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineplus">+                                             ims.previousValue);</span>
<a href="#l4.79"></a><span id="l4.79" class="difflineplus">+          }</span>
<a href="#l4.80"></a><span id="l4.80" class="difflineplus">+          catch (ex) {</span>
<a href="#l4.81"></a><span id="l4.81" class="difflineplus">+            do_throw(&quot;Exception during verification via &quot; + ims.verifier.name +</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineplus">+                &quot; on message index: &quot; + iMessage + &quot; previous value: &quot; +</span>
<a href="#l4.83"></a><span id="l4.83" class="difflineplus">+                ims.previousValue + &quot; gloda message: &quot; +</span>
<a href="#l4.84"></a><span id="l4.84" class="difflineplus">+                ims.glodaMessages[iMessage] + &quot;\nexception: &quot; + ex);</span>
<a href="#l4.85"></a><span id="l4.85" class="difflineplus">+          }</span>
<a href="#l4.86"></a><span id="l4.86" class="difflineplus">+        }</span>
<a href="#l4.87"></a><span id="l4.87">       }</span>
<a href="#l4.88"></a><span id="l4.88"> </span>
<a href="#l4.89"></a><span id="l4.89" class="difflineminus">-      if (ims.onDone)</span>
<a href="#l4.90"></a><span id="l4.90" class="difflineminus">-        ims.onDone();</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineplus">+      if (ims.onDone) {</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineplus">+        try {</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineplus">+          ims.onDone();</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineplus">+        }</span>
<a href="#l4.95"></a><span id="l4.95" class="difflineplus">+        catch (ex) {</span>
<a href="#l4.96"></a><span id="l4.96" class="difflineplus">+          do_throw(&quot;Exception calling ims.onDone (&quot; + ims.onDone.name + &quot;): &quot; + </span>
<a href="#l4.97"></a><span id="l4.97" class="difflineplus">+              ex);</span>
<a href="#l4.98"></a><span id="l4.98" class="difflineplus">+        }</span>
<a href="#l4.99"></a><span id="l4.99" class="difflineplus">+      }</span>
<a href="#l4.100"></a><span id="l4.100" class="difflineplus">+    }</span>
<a href="#l4.101"></a><span id="l4.101" class="difflineplus">+    else {</span>
<a href="#l4.102"></a><span id="l4.102" class="difflineplus">+      dump(&quot;((( gloda indexing listener notification. indexing: &quot; +</span>
<a href="#l4.103"></a><span id="l4.103" class="difflineplus">+           GlodaIndexer.indexing + &quot; status: &quot; + aStatus + &quot;\n&quot;);</span>
<a href="#l4.104"></a><span id="l4.104">     }</span>
<a href="#l4.105"></a><span id="l4.105">   }</span>
<a href="#l4.106"></a><span id="l4.106"> };</span>
<a href="#l4.107"></a><span id="l4.107"> </span>
<a href="#l4.108"></a><span id="l4.108"> /**</span>
<a href="#l4.109"></a><span id="l4.109">  * Given a function that generates a set of synthetic messages, feed those</span>
<a href="#l4.110"></a><span id="l4.110">  *  messages to gloda to be indexed, verifying the resulting indexed messages</span>
<a href="#l4.111"></a><span id="l4.111">  *  have the desired properties by calling the provided verification function.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1">new file mode 100644</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineminus">--- /dev/null</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js</span>
<a href="#l5.4"></a><span id="l5.4" class="difflineat">@@ -0,0 +1,117 @@</span>
<a href="#l5.5"></a><span id="l5.5" class="difflineplus">+/* This file tests whether we cleanup after ourselves, msf-wise.</span>
<a href="#l5.6"></a><span id="l5.6" class="difflineplus">+ * This is very much a white-box test; we want to make sure that all the parts</span>
<a href="#l5.7"></a><span id="l5.7" class="difflineplus">+ *  of the mechanism are actually doing what we think they should be doing.</span>
<a href="#l5.8"></a><span id="l5.8" class="difflineplus">+ * </span>
<a href="#l5.9"></a><span id="l5.9" class="difflineplus">+ * This test should stand on its own!  It should not be lumped together with</span>
<a href="#l5.10"></a><span id="l5.10" class="difflineplus">+ *  other tests unless you take care to fix all our meddling.</span>
<a href="#l5.11"></a><span id="l5.11" class="difflineplus">+ */</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+do_import_script(&quot;../mailnews/db/gloda/test/resources/messageGenerator.js&quot;);</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+do_import_script(&quot;../mailnews/db/gloda/test/resources/glodaTestHelper.js&quot;);</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineplus">+// Create a message generator</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineplus">+var msgGen = new MessageGenerator();</span>
<a href="#l5.18"></a><span id="l5.18" class="difflineplus">+// Create a message scenario generator using that message generator</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineplus">+var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineplus">+</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+// we need datamodel to be able to manipulate the GlodaFolder prototype...</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+Components.utils.import(&quot;resource://app/modules/gloda/datamodel.js&quot;);</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+// we need datastore to run amok in the GlodaDatastore internals</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineplus">+Components.utils.import(&quot;resource://app/modules/gloda/datastore.js&quot;);</span>
<a href="#l5.25"></a><span id="l5.25" class="difflineplus">+</span>
<a href="#l5.26"></a><span id="l5.26" class="difflineplus">+/**</span>
<a href="#l5.27"></a><span id="l5.27" class="difflineplus">+ * @return the number of live gloda folders tracked by</span>
<a href="#l5.28"></a><span id="l5.28" class="difflineplus">+ *     GlodaDatastore._liveGlodaFolders.</span>
<a href="#l5.29"></a><span id="l5.29" class="difflineplus">+ */</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineplus">+function getLiveFolderCount() {</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineplus">+  return [key for each (key in GlodaDatastore._liveGlodaFolders)].length;</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+}</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineplus">+</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+/**</span>
<a href="#l5.35"></a><span id="l5.35" class="difflineplus">+ * Meddle with internals of live folder tracking, create a synthetic message and</span>
<a href="#l5.36"></a><span id="l5.36" class="difflineplus">+ *  index it. We do the actual work involving the headers and folders in </span>
<a href="#l5.37"></a><span id="l5.37" class="difflineplus">+ *  poke_and_verify_msf_closure. </span>
<a href="#l5.38"></a><span id="l5.38" class="difflineplus">+ */</span>
<a href="#l5.39"></a><span id="l5.39" class="difflineplus">+function test_msf_closure() {</span>
<a href="#l5.40"></a><span id="l5.40" class="difflineplus">+  // before doing anything, the indexer should not be tracking any live folders</span>
<a href="#l5.41"></a><span id="l5.41" class="difflineplus">+  do_check_false(GlodaDatastore._folderCleanupActive);</span>
<a href="#l5.42"></a><span id="l5.42" class="difflineplus">+  do_check_eq(0, getLiveFolderCount());</span>
<a href="#l5.43"></a><span id="l5.43" class="difflineplus">+  </span>
<a href="#l5.44"></a><span id="l5.44" class="difflineplus">+  // make the datastore's folder cleanup timer never be at risk of firing</span>
<a href="#l5.45"></a><span id="l5.45" class="difflineplus">+  GlodaIndexer._folderCleanupTimerInterval = 1000000000;</span>
<a href="#l5.46"></a><span id="l5.46" class="difflineplus">+  // set the acceptably old threshold so it will never age out</span>
<a href="#l5.47"></a><span id="l5.47" class="difflineplus">+  GlodaFolder.prototype.ACCEPTABLY_OLD_THRESHOLD = 1000000000;</span>
<a href="#l5.48"></a><span id="l5.48" class="difflineplus">+  </span>
<a href="#l5.49"></a><span id="l5.49" class="difflineplus">+  // create a synthetic message</span>
<a href="#l5.50"></a><span id="l5.50" class="difflineplus">+  let smsg = msgGen.makeMessage();</span>
<a href="#l5.51"></a><span id="l5.51" class="difflineplus">+  </span>
<a href="#l5.52"></a><span id="l5.52" class="difflineplus">+  indexMessages([smsg], poke_and_verify_msf_closure, next_test);</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineplus">+}</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineplus">+</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineplus">+/**</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+ * Grab the message header, see live folder, cleanup live folders, make sure</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+ *  live folder stayed live, change constants so folder can die, cleanup live</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineplus">+ *  folders, make sure folder died. </span>
<a href="#l5.59"></a><span id="l5.59" class="difflineplus">+ * </span>
<a href="#l5.60"></a><span id="l5.60" class="difflineplus">+ * @param aSynthMessage The synthetic message we indexed.</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineplus">+ * @param aGlodaMessage Its exciting gloda representation</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineplus">+ */</span>
<a href="#l5.63"></a><span id="l5.63" class="difflineplus">+function poke_and_verify_msf_closure(aSynthMessage, aGlodaMessage) {</span>
<a href="#l5.64"></a><span id="l5.64" class="difflineplus">+  // get the nsIMsgDBHdr</span>
<a href="#l5.65"></a><span id="l5.65" class="difflineplus">+  let header = aGlodaMessage.folderMessage;</span>
<a href="#l5.66"></a><span id="l5.66" class="difflineplus">+  // if we don't have a header, this test is unlikely to work...</span>
<a href="#l5.67"></a><span id="l5.67" class="difflineplus">+  do_check_neq(header, null);</span>
<a href="#l5.68"></a><span id="l5.68" class="difflineplus">+  </span>
<a href="#l5.69"></a><span id="l5.69" class="difflineplus">+  // we need a reference to the glodaFolder</span>
<a href="#l5.70"></a><span id="l5.70" class="difflineplus">+  let glodaFolder = aGlodaMessage.folder;</span>
<a href="#l5.71"></a><span id="l5.71" class="difflineplus">+  </span>
<a href="#l5.72"></a><span id="l5.72" class="difflineplus">+  // -- check that everyone is tracking things correctly</span>
<a href="#l5.73"></a><span id="l5.73" class="difflineplus">+  // the message's folder should be holding an XPCOM reference to the folder</span>
<a href="#l5.74"></a><span id="l5.74" class="difflineplus">+  do_check_neq(glodaFolder._xpcomFolder, null);</span>
<a href="#l5.75"></a><span id="l5.75" class="difflineplus">+  // the cleanup timer should now be alive</span>
<a href="#l5.76"></a><span id="l5.76" class="difflineplus">+  do_check_true(GlodaDatastore._folderCleanupActive);</span>
<a href="#l5.77"></a><span id="l5.77" class="difflineplus">+  // live folder count should be one</span>
<a href="#l5.78"></a><span id="l5.78" class="difflineplus">+  do_check_eq(1, getLiveFolderCount());</span>
<a href="#l5.79"></a><span id="l5.79" class="difflineplus">+  </span>
<a href="#l5.80"></a><span id="l5.80" class="difflineplus">+  // -- simulate a timer cleanup firing...</span>
<a href="#l5.81"></a><span id="l5.81" class="difflineplus">+  GlodaDatastore._performFolderCleanup();</span>
<a href="#l5.82"></a><span id="l5.82" class="difflineplus">+  </span>
<a href="#l5.83"></a><span id="l5.83" class="difflineplus">+  // -- verify that things are still as they were before the cleanup firing</span>
<a href="#l5.84"></a><span id="l5.84" class="difflineplus">+  // the message's folder should be holding an XPCOM reference to the folder</span>
<a href="#l5.85"></a><span id="l5.85" class="difflineplus">+  do_check_neq(glodaFolder._xpcomFolder, null);</span>
<a href="#l5.86"></a><span id="l5.86" class="difflineplus">+  // the cleanup timer should now be alive</span>
<a href="#l5.87"></a><span id="l5.87" class="difflineplus">+  do_check_true(GlodaDatastore._folderCleanupActive);</span>
<a href="#l5.88"></a><span id="l5.88" class="difflineplus">+  // live folder count should be one</span>
<a href="#l5.89"></a><span id="l5.89" class="difflineplus">+  do_check_eq(1, getLiveFolderCount());</span>
<a href="#l5.90"></a><span id="l5.90" class="difflineplus">+</span>
<a href="#l5.91"></a><span id="l5.91" class="difflineplus">+  // -- change oldness constant so that it cannot help but be true</span>
<a href="#l5.92"></a><span id="l5.92" class="difflineplus">+  // (the goal is to avoid getting tricked by the granularity of the timer</span>
<a href="#l5.93"></a><span id="l5.93" class="difflineplus">+  //  updates, as well as to make sure our logic is right by skewing the</span>
<a href="#l5.94"></a><span id="l5.94" class="difflineplus">+  //  constant wildly, so that if our logic was backwards, we would fail.)</span>
<a href="#l5.95"></a><span id="l5.95" class="difflineplus">+  // put the threshold 1000 seconds in the future; the event must be older than</span>
<a href="#l5.96"></a><span id="l5.96" class="difflineplus">+  //  the future, for obvious reasons.</span>
<a href="#l5.97"></a><span id="l5.97" class="difflineplus">+  GlodaFolder.prototype.ACCEPTABLY_OLD_THRESHOLD = -1000000;</span>
<a href="#l5.98"></a><span id="l5.98" class="difflineplus">+</span>
<a href="#l5.99"></a><span id="l5.99" class="difflineplus">+  // -- simulate a timer cleanup firing...</span>
<a href="#l5.100"></a><span id="l5.100" class="difflineplus">+  GlodaDatastore._performFolderCleanup();</span>
<a href="#l5.101"></a><span id="l5.101" class="difflineplus">+</span>
<a href="#l5.102"></a><span id="l5.102" class="difflineplus">+  // -- verify that cleanup has occurred and the cleanup mechanism shutdown.</span>
<a href="#l5.103"></a><span id="l5.103" class="difflineplus">+  // the message's folder should no longer be holding an XPCOM reference</span>
<a href="#l5.104"></a><span id="l5.104" class="difflineplus">+  do_check_eq(glodaFolder._xpcomFolder, null);</span>
<a href="#l5.105"></a><span id="l5.105" class="difflineplus">+  // the cleanup timer should now be dead</span>
<a href="#l5.106"></a><span id="l5.106" class="difflineplus">+  do_check_false(GlodaDatastore._folderCleanupActive);</span>
<a href="#l5.107"></a><span id="l5.107" class="difflineplus">+  // live folder count should be zero</span>
<a href="#l5.108"></a><span id="l5.108" class="difflineplus">+  do_check_eq(0, getLiveFolderCount());</span>
<a href="#l5.109"></a><span id="l5.109" class="difflineplus">+}</span>
<a href="#l5.110"></a><span id="l5.110" class="difflineplus">+</span>
<a href="#l5.111"></a><span id="l5.111" class="difflineplus">+var tests = [</span>
<a href="#l5.112"></a><span id="l5.112" class="difflineplus">+  test_msf_closure,</span>
<a href="#l5.113"></a><span id="l5.113" class="difflineplus">+];</span>
<a href="#l5.114"></a><span id="l5.114" class="difflineplus">+</span>
<a href="#l5.115"></a><span id="l5.115" class="difflineplus">+function run_test() {</span>
<a href="#l5.116"></a><span id="l5.116" class="difflineplus">+  // No need to involve the fake-server, plus mbox injection has the direct</span>
<a href="#l5.117"></a><span id="l5.117" class="difflineplus">+  //  side-effect of creating folders that are not the inbox, which in theory</span>
<a href="#l5.118"></a><span id="l5.118" class="difflineplus">+  //  makes us less brittle.  (Less likely other code will interfere.)</span>
<a href="#l5.119"></a><span id="l5.119" class="difflineplus">+  injectMessagesUsing(INJECT_MBOX);</span>
<a href="#l5.120"></a><span id="l5.120" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l5.121"></a><span id="l5.121" class="difflineplus">+}</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

