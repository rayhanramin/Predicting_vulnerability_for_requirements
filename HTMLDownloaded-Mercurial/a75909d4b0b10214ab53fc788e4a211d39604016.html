<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 5412:a75909d4b0b10214ab53fc788e4a211d39604016</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ a75909d4b0b10214ab53fc788e4a211d39604016" />
<meta property="og:url" content="/comm-central/rev/a75909d4b0b10214ab53fc788e4a211d39604016" />
<meta property="og:description" content="Bug 540110 - test-folder-display-helpers.js' waitForEval timeouts should be treated as failures, logHelper should be mozmill aware. r=sid0" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / a75909d4b0b10214ab53fc788e4a211d39604016 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/a75909d4b0b10214ab53fc788e4a211d39604016">shortlog</a> |
<a href="/comm-central/log/a75909d4b0b10214ab53fc788e4a211d39604016">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/a75909d4b0b10214ab53fc788e4a211d39604016">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/a75909d4b0b10214ab53fc788e4a211d39604016">files</a> |
changeset |
<a href="/comm-central/raw-rev/a75909d4b0b10214ab53fc788e4a211d39604016">raw</a>  | <a href="/comm-central/archive/a75909d4b0b10214ab53fc788e4a211d39604016.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=540110">Bug 540110</a> - test-folder-display-helpers.js' waitForEval timeouts should be treated as failures, logHelper should be mozmill aware. r=sid0
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Fri, 09 Apr 2010 00:16:04 -0700</td></tr>

<tr>
 <td>changeset 5412</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/a75909d4b0b10214ab53fc788e4a211d39604016">a75909d4b0b10214ab53fc788e4a211d39604016</a></td>
</tr>



<tr>
<td>parent 5411</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/bd72fc3badc3704558232805e0e7789a920344fd">bd72fc3badc3704558232805e0e7789a920344fd</a>
</td>
</tr>

<tr>
<td>child 5413</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/6cb656f5dc98196aeb929f4b09ab303c7e60a9ba">6cb656f5dc98196aeb929f4b09ab303c7e60a9ba</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=a75909d4b0b10214ab53fc788e4a211d39604016">4177</a></td></tr>
<tr><td>push user</td><td>bugmail@asutherland.org</td></tr>
<tr><td>push date</td><td class="date age">Fri, 09 Apr 2010 07:16:46 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@6cb656f5dc98 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=6cb656f5dc98196aeb929f4b09ab303c7e60a9ba">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=6cb656f5dc98196aeb929f4b09ab303c7e60a9ba&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=6cb656f5dc98196aeb929f4b09ab303c7e60a9ba&newProject=comm-central&newRevision=a75909d4b0b10214ab53fc788e4a211d39604016&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=6cb656f5dc98196aeb929f4b09ab303c7e60a9ba&newProject=comm-central&newRevision=a75909d4b0b10214ab53fc788e4a211d39604016&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=6cb656f5dc98196aeb929f4b09ab303c7e60a9ba&newProject=comm-central&newRevision=a75909d4b0b10214ab53fc788e4a211d39604016&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28sid0%29&revcount=50">sid0</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=540110">540110</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=540110">Bug 540110</a> - test-folder-display-helpers.js' waitForEval timeouts should be treated as failures, logHelper should be mozmill aware. r=sid0</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a75909d4b0b10214ab53fc788e4a211d39604016/mail/test/mozmill/shared-modules/test-folder-display-helpers.js">mail/test/mozmill/shared-modules/test-folder-display-helpers.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a75909d4b0b10214ab53fc788e4a211d39604016/mail/test/mozmill/shared-modules/test-folder-display-helpers.js">file</a> |
<a href="/comm-central/annotate/a75909d4b0b10214ab53fc788e4a211d39604016/mail/test/mozmill/shared-modules/test-folder-display-helpers.js">annotate</a> |
<a href="/comm-central/diff/a75909d4b0b10214ab53fc788e4a211d39604016/mail/test/mozmill/shared-modules/test-folder-display-helpers.js">diff</a> |
<a href="/comm-central/comparison/a75909d4b0b10214ab53fc788e4a211d39604016/mail/test/mozmill/shared-modules/test-folder-display-helpers.js">comparison</a> |
<a href="/comm-central/log/a75909d4b0b10214ab53fc788e4a211d39604016/mail/test/mozmill/shared-modules/test-folder-display-helpers.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a75909d4b0b10214ab53fc788e4a211d39604016/mail/test/mozmill/shared-modules/test-window-helpers.js">mail/test/mozmill/shared-modules/test-window-helpers.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a75909d4b0b10214ab53fc788e4a211d39604016/mail/test/mozmill/shared-modules/test-window-helpers.js">file</a> |
<a href="/comm-central/annotate/a75909d4b0b10214ab53fc788e4a211d39604016/mail/test/mozmill/shared-modules/test-window-helpers.js">annotate</a> |
<a href="/comm-central/diff/a75909d4b0b10214ab53fc788e4a211d39604016/mail/test/mozmill/shared-modules/test-window-helpers.js">diff</a> |
<a href="/comm-central/comparison/a75909d4b0b10214ab53fc788e4a211d39604016/mail/test/mozmill/shared-modules/test-window-helpers.js">comparison</a> |
<a href="/comm-central/log/a75909d4b0b10214ab53fc788e4a211d39604016/mail/test/mozmill/shared-modules/test-window-helpers.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/modules/connotent.js">mailnews/db/gloda/modules/connotent.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/modules/connotent.js">file</a> |
<a href="/comm-central/annotate/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/modules/connotent.js">annotate</a> |
<a href="/comm-central/diff/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/modules/connotent.js">diff</a> |
<a href="/comm-central/comparison/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/modules/connotent.js">comparison</a> |
<a href="/comm-central/log/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/modules/connotent.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/test/unit/resources/folderEventLogHelper.js">mailnews/db/gloda/test/unit/resources/folderEventLogHelper.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/test/unit/resources/folderEventLogHelper.js">diff</a> |
<a href="/comm-central/comparison/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/test/unit/resources/folderEventLogHelper.js">comparison</a> |
<a href="/comm-central/log/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/test/unit/resources/folderEventLogHelper.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">file</a> |
<a href="/comm-central/annotate/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">annotate</a> |
<a href="/comm-central/diff/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">diff</a> |
<a href="/comm-central/comparison/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">comparison</a> |
<a href="/comm-central/log/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/test/resources/folderEventLogHelper.js">mailnews/test/resources/folderEventLogHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/test/resources/folderEventLogHelper.js">file</a> |
<a href="/comm-central/annotate/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/test/resources/folderEventLogHelper.js">annotate</a> |
<a href="/comm-central/diff/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/test/resources/folderEventLogHelper.js">diff</a> |
<a href="/comm-central/comparison/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/test/resources/folderEventLogHelper.js">comparison</a> |
<a href="/comm-central/log/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/test/resources/folderEventLogHelper.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/test/resources/logHelper.js">mailnews/test/resources/logHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/test/resources/logHelper.js">file</a> |
<a href="/comm-central/annotate/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/test/resources/logHelper.js">annotate</a> |
<a href="/comm-central/diff/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/test/resources/logHelper.js">diff</a> |
<a href="/comm-central/comparison/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/test/resources/logHelper.js">comparison</a> |
<a href="/comm-central/log/a75909d4b0b10214ab53fc788e4a211d39604016/mailnews/test/resources/logHelper.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mail/test/mozmill/shared-modules/test-folder-display-helpers.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mail/test/mozmill/shared-modules/test-folder-display-helpers.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -124,41 +124,62 @@ function setupModule() {</span>
<a href="#l1.4"></a><span id="l1.4">   initialized = true;</span>
<a href="#l1.5"></a><span id="l1.5"> </span>
<a href="#l1.6"></a><span id="l1.6">   testHelperModule = {</span>
<a href="#l1.7"></a><span id="l1.7">     Cc: Cc,</span>
<a href="#l1.8"></a><span id="l1.8">     Ci: Ci,</span>
<a href="#l1.9"></a><span id="l1.9">     Cu: Cu,</span>
<a href="#l1.10"></a><span id="l1.10">     // fake some xpcshell stuff</span>
<a href="#l1.11"></a><span id="l1.11">     _TEST_FILE: [&quot;mozmill&quot;],</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+    _do_not_wrap_xpcshell: true,</span>
<a href="#l1.13"></a><span id="l1.13">     do_throw: function(aMsg) {</span>
<a href="#l1.14"></a><span id="l1.14">       throw new Error(aMsg);</span>
<a href="#l1.15"></a><span id="l1.15">     },</span>
<a href="#l1.16"></a><span id="l1.16">     do_check_eq: function() {},</span>
<a href="#l1.17"></a><span id="l1.17">     do_check_neq: function() {},</span>
<a href="#l1.18"></a><span id="l1.18">   };</span>
<a href="#l1.19"></a><span id="l1.19"> </span>
<a href="#l1.20"></a><span id="l1.20">   // The xpcshell test resources assume they are loaded into a single global</span>
<a href="#l1.21"></a><span id="l1.21">   //  namespace, so we need to help them out to maintain their delusion.</span>
<a href="#l1.22"></a><span id="l1.22">   load_via_src_path('mailnews/test/resources/logHelper.js',</span>
<a href="#l1.23"></a><span id="l1.23">                     testHelperModule);</span>
<a href="#l1.24"></a><span id="l1.24">   mark_action = testHelperModule.mark_action;</span>
<a href="#l1.25"></a><span id="l1.25">   mark_failure = testHelperModule.mark_failure;</span>
<a href="#l1.26"></a><span id="l1.26"> </span>
<a href="#l1.27"></a><span id="l1.27" class="difflineplus">+  // Hook-up logHelper to the mozmill event system...</span>
<a href="#l1.28"></a><span id="l1.28" class="difflineplus">+  let curTestFile = null;</span>
<a href="#l1.29"></a><span id="l1.29" class="difflineplus">+  frame.events.addListener(&quot;setTest&quot;, function(obj) {</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineplus">+      if (obj.filename != curTestFile) {</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineplus">+        testHelperModule.mark_test_start(obj.filename);</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+        curTestFile = obj.filename;</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineplus">+      }</span>
<a href="#l1.34"></a><span id="l1.34" class="difflineplus">+      testHelperModule.mark_sub_test_start(obj.name);</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineplus">+    });</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineplus">+  frame.events.addListener(&quot;fail&quot;, function(obj) {</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineplus">+      testHelperModule._xpcshellLogger.info(</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineplus">+        testHelperModule._testLoggerActiveContext,</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineplus">+        new testHelperModule._Failure(obj.exception.message, obj.exception));</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineplus">+    });</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineplus">+</span>
<a href="#l1.42"></a><span id="l1.42">   load_via_src_path('mailnews/test/resources/asyncTestUtils.js',</span>
<a href="#l1.43"></a><span id="l1.43">                     testHelperModule);</span>
<a href="#l1.44"></a><span id="l1.44">   load_via_src_path('mailnews/test/resources/messageGenerator.js',</span>
<a href="#l1.45"></a><span id="l1.45">                     testHelperModule);</span>
<a href="#l1.46"></a><span id="l1.46">   load_via_src_path('mailnews/test/resources/messageModifier.js',</span>
<a href="#l1.47"></a><span id="l1.47">                     testHelperModule);</span>
<a href="#l1.48"></a><span id="l1.48">   load_via_src_path('mailnews/test/resources/messageInjection.js',</span>
<a href="#l1.49"></a><span id="l1.49">                     testHelperModule);</span>
<a href="#l1.50"></a><span id="l1.50">   load_via_src_path('mail/base/test/unit/resources/viewWrapperTestUtils.js',</span>
<a href="#l1.51"></a><span id="l1.51">                     testHelperModule);</span>
<a href="#l1.52"></a><span id="l1.52"> </span>
<a href="#l1.53"></a><span id="l1.53" class="difflineplus">+  // provide super helpful folder event info (when logHelper cares)</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineplus">+  load_via_src_path('mailnews/test/resources/folderEventLogHelper.js',</span>
<a href="#l1.55"></a><span id="l1.55" class="difflineplus">+                    testHelperModule);</span>
<a href="#l1.56"></a><span id="l1.56" class="difflineplus">+  testHelperModule.registerFolderEventLogHelper();</span>
<a href="#l1.57"></a><span id="l1.57" class="difflineplus">+</span>
<a href="#l1.58"></a><span id="l1.58">   // messageInjection wants a gMessageGenerator (and so do we)</span>
<a href="#l1.59"></a><span id="l1.59">   msgGen = new testHelperModule.MessageGenerator();</span>
<a href="#l1.60"></a><span id="l1.60">   testHelperModule.gMessageGenerator = msgGen;</span>
<a href="#l1.61"></a><span id="l1.61">   testHelperModule.gMessageScenarioFactory =</span>
<a href="#l1.62"></a><span id="l1.62">     new testHelperModule.MessageScenarioFactory(msgGen);</span>
<a href="#l1.63"></a><span id="l1.63"> </span>
<a href="#l1.64"></a><span id="l1.64">   make_new_sets_in_folders = make_new_sets_in_folder =</span>
<a href="#l1.65"></a><span id="l1.65">     testHelperModule.make_new_sets_in_folders;</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineat">@@ -331,46 +352,45 @@ function create_thread(aCount) {</span>
<a href="#l1.67"></a><span id="l1.67">  *</span>
<a href="#l1.68"></a><span id="l1.68">  * @param {SyntheticMessage} aMsg</span>
<a href="#l1.69"></a><span id="l1.69">  * @param {Object} aFolder</span>
<a href="#l1.70"></a><span id="l1.70">  */</span>
<a href="#l1.71"></a><span id="l1.71"> function add_message_to_folder(aFolder, aMsg) {</span>
<a href="#l1.72"></a><span id="l1.72">   // should presumably use async_run here, but since setupAccountStuff is</span>
<a href="#l1.73"></a><span id="l1.73">   // using a local store, it should be safe to assume synchronicity</span>
<a href="#l1.74"></a><span id="l1.74">   add_sets_to_folders([aFolder],</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineminus">-                      [new testHelperModule.SyntheticMessageSet([aMsg])]); </span>
<a href="#l1.76"></a><span id="l1.76" class="difflineplus">+                      [new testHelperModule.SyntheticMessageSet([aMsg])]);</span>
<a href="#l1.77"></a><span id="l1.77"> }</span>
<a href="#l1.78"></a><span id="l1.78"> </span>
<a href="#l1.79"></a><span id="l1.79"> /**</span>
<a href="#l1.80"></a><span id="l1.80">  * Make sure we are entering the folder from not having been in the folder.  We</span>
<a href="#l1.81"></a><span id="l1.81">  *  will leave the folder and come back if we have to.</span>
<a href="#l1.82"></a><span id="l1.82">  */</span>
<a href="#l1.83"></a><span id="l1.83"> function enter_folder(aFolder) {</span>
<a href="#l1.84"></a><span id="l1.84">   // Drain the event queue prior to doing any work.  It's possible that there's</span>
<a href="#l1.85"></a><span id="l1.85">   //  a pending setTimeout(0) that needs to get fired.</span>
<a href="#l1.86"></a><span id="l1.86">   controller.sleep(0);</span>
<a href="#l1.87"></a><span id="l1.87">   // if we're already selected, go back to the root...</span>
<a href="#l1.88"></a><span id="l1.88">   if (mc.folderDisplay.displayedFolder == aFolder)</span>
<a href="#l1.89"></a><span id="l1.89">     enter_folder(aFolder.rootFolder);</span>
<a href="#l1.90"></a><span id="l1.90"> </span>
<a href="#l1.91"></a><span id="l1.91" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;enter_folder&quot;, [aFolder]);</span>
<a href="#l1.92"></a><span id="l1.92" class="difflineplus">+</span>
<a href="#l1.93"></a><span id="l1.93">   // this selection event may not be synchronous...</span>
<a href="#l1.94"></a><span id="l1.94">   mc.folderTreeView.selectFolder(aFolder);</span>
<a href="#l1.95"></a><span id="l1.95">   // ... so wait until it goes through by waiting on the displayedFolder...</span>
<a href="#l1.96"></a><span id="l1.96">   function isDisplayedFolder() {</span>
<a href="#l1.97"></a><span id="l1.97">     return mc.folderDisplay.displayedFolder == aFolder;</span>
<a href="#l1.98"></a><span id="l1.98">   }</span>
<a href="#l1.99"></a><span id="l1.99" class="difflineminus">-  controller.waitForEval('subject()', NORMAL_TIMEOUT, FAST_INTERVAL,</span>
<a href="#l1.100"></a><span id="l1.100" class="difflineminus">-                         isDisplayedFolder);</span>
<a href="#l1.101"></a><span id="l1.101" class="difflineplus">+  if (!controller.waitForEval('subject()', NORMAL_TIMEOUT, FAST_INTERVAL,</span>
<a href="#l1.102"></a><span id="l1.102" class="difflineplus">+                              isDisplayedFolder))</span>
<a href="#l1.103"></a><span id="l1.103" class="difflineplus">+    mark_failure([&quot;Timeout trying to enter folder&quot;, aFolder]);</span>
<a href="#l1.104"></a><span id="l1.104"> </span>
<a href="#l1.105"></a><span id="l1.105">   wait_for_all_messages_to_load();</span>
<a href="#l1.106"></a><span id="l1.106"> </span>
<a href="#l1.107"></a><span id="l1.107" class="difflineminus">-  // XXX folder summary will impact this, but for now, nothing should be</span>
<a href="#l1.108"></a><span id="l1.108" class="difflineminus">-  //  shown when we enter the folder.</span>
<a href="#l1.109"></a><span id="l1.109" class="difflineminus">-  wait_for_blank_content_pane();</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineminus">-</span>
<a href="#l1.111"></a><span id="l1.111">   // and drain the event queue</span>
<a href="#l1.112"></a><span id="l1.112">   controller.sleep(0);</span>
<a href="#l1.113"></a><span id="l1.113"> }</span>
<a href="#l1.114"></a><span id="l1.114"> </span>
<a href="#l1.115"></a><span id="l1.115"> /**</span>
<a href="#l1.116"></a><span id="l1.116">  * Make sure we are in the given folder, entering it if we were not.</span>
<a href="#l1.117"></a><span id="l1.117">  *</span>
<a href="#l1.118"></a><span id="l1.118">  * @return The tab info of the current tab (a more persistent identifier for</span>
<a href="#l1.119"></a><span id="l1.119" class="difflineat">@@ -393,16 +413,18 @@ function be_in_folder(aFolder) {</span>
<a href="#l1.120"></a><span id="l1.120">  *</span>
<a href="#l1.121"></a><span id="l1.121">  * @return The tab info of the current tab (a more persistent identifier for</span>
<a href="#l1.122"></a><span id="l1.122">  *     tabs than the index, which will change as tabs open/close).</span>
<a href="#l1.123"></a><span id="l1.123">  */</span>
<a href="#l1.124"></a><span id="l1.124"> function open_folder_in_new_tab(aFolder) {</span>
<a href="#l1.125"></a><span id="l1.125">   // save the current tab as the 'other' tab</span>
<a href="#l1.126"></a><span id="l1.126">   otherTab = mc.tabmail.currentTabInfo;</span>
<a href="#l1.127"></a><span id="l1.127">   mc.tabmail.openTab(&quot;folder&quot;, {folder: aFolder});</span>
<a href="#l1.128"></a><span id="l1.128" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;open_folder_in_new_tab&quot;,</span>
<a href="#l1.129"></a><span id="l1.129" class="difflineplus">+              [&quot;folder&quot;, aFolder, &quot;tab info&quot;, mc.tabmail.currentTabInfo]);</span>
<a href="#l1.130"></a><span id="l1.130">   wait_for_all_messages_to_load();</span>
<a href="#l1.131"></a><span id="l1.131">   return mc.tabmail.currentTabInfo;</span>
<a href="#l1.132"></a><span id="l1.132"> }</span>
<a href="#l1.133"></a><span id="l1.133"> </span>
<a href="#l1.134"></a><span id="l1.134"> /**</span>
<a href="#l1.135"></a><span id="l1.135">  * Open the selected message(s) by pressing Enter. The mail.openMessageBehavior</span>
<a href="#l1.136"></a><span id="l1.136">  * pref is supposed to determine how the messages are opened.</span>
<a href="#l1.137"></a><span id="l1.137">  *</span>
<a href="#l1.138"></a><span id="l1.138" class="difflineat">@@ -412,16 +434,18 @@ function open_folder_in_new_tab(aFolder)</span>
<a href="#l1.139"></a><span id="l1.139">  * @param aController The controller in whose context to do this, defaults to</span>
<a href="#l1.140"></a><span id="l1.140">  *     |mc| if omitted.</span>
<a href="#l1.141"></a><span id="l1.141">  */</span>
<a href="#l1.142"></a><span id="l1.142"> function open_selected_messages(aController) {</span>
<a href="#l1.143"></a><span id="l1.143">   if (aController === undefined)</span>
<a href="#l1.144"></a><span id="l1.144">     aController = mc;</span>
<a href="#l1.145"></a><span id="l1.145">   // Focus the thread tree</span>
<a href="#l1.146"></a><span id="l1.146">   aController.threadTree.focus();</span>
<a href="#l1.147"></a><span id="l1.147" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;open_selected_messages&quot;,</span>
<a href="#l1.148"></a><span id="l1.148" class="difflineplus">+              mc.folderDisplay.selectedMessages);</span>
<a href="#l1.149"></a><span id="l1.149">   // Open whatever's selected</span>
<a href="#l1.150"></a><span id="l1.150">   press_enter(aController);</span>
<a href="#l1.151"></a><span id="l1.151"> }</span>
<a href="#l1.152"></a><span id="l1.152"> </span>
<a href="#l1.153"></a><span id="l1.153"> var open_selected_message = open_selected_messages;</span>
<a href="#l1.154"></a><span id="l1.154"> </span>
<a href="#l1.155"></a><span id="l1.155"> /**</span>
<a href="#l1.156"></a><span id="l1.156">  * Create a new tab displaying the currently selected message, making that tab</span>
<a href="#l1.157"></a><span id="l1.157" class="difflineat">@@ -447,26 +471,34 @@ function open_selected_message_in_new_ta</span>
<a href="#l1.158"></a><span id="l1.158">   // We won't trigger a new message load if we're in the background</span>
<a href="#l1.159"></a><span id="l1.159">   wait_for_message_display_completion(mc, !aBackground);</span>
<a href="#l1.160"></a><span id="l1.160"> </span>
<a href="#l1.161"></a><span id="l1.161">   // check that the tab count increased</span>
<a href="#l1.162"></a><span id="l1.162">   if (mc.tabmail.tabContainer.childNodes.length != preCount + 1)</span>
<a href="#l1.163"></a><span id="l1.163">     throw new Error(&quot;The tab never actually got opened!&quot;);</span>
<a href="#l1.164"></a><span id="l1.164"> </span>
<a href="#l1.165"></a><span id="l1.165">   // We append new tabs at the end, so return the last tab</span>
<a href="#l1.166"></a><span id="l1.166" class="difflineminus">-  return mc.tabmail.tabInfo[mc.tabmail.tabContainer.childNodes.length - 1];</span>
<a href="#l1.167"></a><span id="l1.167" class="difflineplus">+  let newTab =</span>
<a href="#l1.168"></a><span id="l1.168" class="difflineplus">+    mc.tabmail.tabInfo[mc.tabmail.tabContainer.childNodes.length - 1];</span>
<a href="#l1.169"></a><span id="l1.169" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;open_selected_message_in_new_tab&quot;,</span>
<a href="#l1.170"></a><span id="l1.170" class="difflineplus">+              [&quot;message&quot;, mc.folderDisplay.selectedMessage,</span>
<a href="#l1.171"></a><span id="l1.171" class="difflineplus">+               &quot;background?&quot;, Boolean(aBackground),</span>
<a href="#l1.172"></a><span id="l1.172" class="difflineplus">+               &quot;new tab&quot;, newTab, &quot;current tab&quot;, mc.tabmail.currentTabInfo]);</span>
<a href="#l1.173"></a><span id="l1.173" class="difflineplus">+  return newTab;</span>
<a href="#l1.174"></a><span id="l1.174"> }</span>
<a href="#l1.175"></a><span id="l1.175"> </span>
<a href="#l1.176"></a><span id="l1.176"> /**</span>
<a href="#l1.177"></a><span id="l1.177">  * Create a new window displaying the currently selected message.  We do not</span>
<a href="#l1.178"></a><span id="l1.178">  *  return until the message has finished loading.</span>
<a href="#l1.179"></a><span id="l1.179">  *</span>
<a href="#l1.180"></a><span id="l1.180">  * @return The MozmillController-wrapped new window.</span>
<a href="#l1.181"></a><span id="l1.181">  */</span>
<a href="#l1.182"></a><span id="l1.182"> function open_selected_message_in_new_window() {</span>
<a href="#l1.183"></a><span id="l1.183" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;open_selected_message_in_new_window&quot;,</span>
<a href="#l1.184"></a><span id="l1.184" class="difflineplus">+              [&quot;message&quot;, mc.folderDisplay.selectedMessage]);</span>
<a href="#l1.185"></a><span id="l1.185">   windowHelper.plan_for_new_window(&quot;mail:messageWindow&quot;);</span>
<a href="#l1.186"></a><span id="l1.186">   mc.window.MsgOpenNewWindowForMessage();</span>
<a href="#l1.187"></a><span id="l1.187">   let msgc = windowHelper.wait_for_new_window(&quot;mail:messageWindow&quot;);</span>
<a href="#l1.188"></a><span id="l1.188">   wait_for_message_display_completion(msgc, true);</span>
<a href="#l1.189"></a><span id="l1.189">   return msgc;</span>
<a href="#l1.190"></a><span id="l1.190"> }</span>
<a href="#l1.191"></a><span id="l1.191"> </span>
<a href="#l1.192"></a><span id="l1.192"> /**</span>
<a href="#l1.193"></a><span id="l1.193" class="difflineat">@@ -478,16 +510,19 @@ function open_selected_message_in_new_wi</span>
<a href="#l1.194"></a><span id="l1.194">  * @param aMsgHdr The message header to display.</span>
<a href="#l1.195"></a><span id="l1.195">  * @param [aExpectNew3Pane] This should be set to true if it is expected that a</span>
<a href="#l1.196"></a><span id="l1.196">  *                          new 3-pane window will be opened as a result of</span>
<a href="#l1.197"></a><span id="l1.197">  *                          the API call.</span>
<a href="#l1.198"></a><span id="l1.198">  *</span>
<a href="#l1.199"></a><span id="l1.199">  * @returns The currently selected tab, guaranteed to be a folder tab.</span>
<a href="#l1.200"></a><span id="l1.200">  */</span>
<a href="#l1.201"></a><span id="l1.201"> function display_message_in_folder_tab(aMsgHdr, aExpectNew3Pane) {</span>
<a href="#l1.202"></a><span id="l1.202" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;display_message_in_folder_tab&quot;,</span>
<a href="#l1.203"></a><span id="l1.203" class="difflineplus">+              [&quot;message&quot;, aMsgHdr,</span>
<a href="#l1.204"></a><span id="l1.204" class="difflineplus">+               &quot;new 3 pane expected?&quot;, Boolean(aExpectNew3Pane)]);</span>
<a href="#l1.205"></a><span id="l1.205">   if (aExpectNew3Pane)</span>
<a href="#l1.206"></a><span id="l1.206">     windowHelper.plan_for_new_window(&quot;mail:3pane&quot;);</span>
<a href="#l1.207"></a><span id="l1.207">   MailUtils.displayMessageInFolderTab(aMsgHdr);</span>
<a href="#l1.208"></a><span id="l1.208">   if (aExpectNew3Pane)</span>
<a href="#l1.209"></a><span id="l1.209">     mc = windowHelper.wait_for_new_window(&quot;mail:3pane&quot;);</span>
<a href="#l1.210"></a><span id="l1.210"> </span>
<a href="#l1.211"></a><span id="l1.211">   wait_for_message_display_completion(mc, true);</span>
<a href="#l1.212"></a><span id="l1.212"> </span>
<a href="#l1.213"></a><span id="l1.213" class="difflineat">@@ -514,16 +549,17 @@ function switch_tab(aNewTab) {</span>
<a href="#l1.214"></a><span id="l1.214">   if (aNewTab == mc.tabmail.currentTabInfo)</span>
<a href="#l1.215"></a><span id="l1.215">     return;</span>
<a href="#l1.216"></a><span id="l1.216"> </span>
<a href="#l1.217"></a><span id="l1.217">   // If we're still loading a message at this point, wait for that to finish</span>
<a href="#l1.218"></a><span id="l1.218">   wait_for_message_display_completion();</span>
<a href="#l1.219"></a><span id="l1.219">   let targetTab = (aNewTab != null) ? aNewTab : otherTab;</span>
<a href="#l1.220"></a><span id="l1.220">   // now the current tab will be the 'other' tab after we switch</span>
<a href="#l1.221"></a><span id="l1.221">   otherTab = mc.tabmail.currentTabInfo;</span>
<a href="#l1.222"></a><span id="l1.222" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;switch_tab&quot;, [&quot;old tab&quot;, otherTab, &quot;new tab&quot;, targetTab]);</span>
<a href="#l1.223"></a><span id="l1.223"> </span>
<a href="#l1.224"></a><span id="l1.224">   // If the target tab's folder display has a something selected and its message</span>
<a href="#l1.225"></a><span id="l1.225">   // pane is visible, plan for a message display.</span>
<a href="#l1.226"></a><span id="l1.226">   if (targetTab.messageDisplay.visible &amp;&amp; targetTab.folderDisplay.selectedCount)</span>
<a href="#l1.227"></a><span id="l1.227">     plan_for_message_display(targetTab);</span>
<a href="#l1.228"></a><span id="l1.228"> </span>
<a href="#l1.229"></a><span id="l1.229">   mc.tabmail.switchToTab(targetTab);</span>
<a href="#l1.230"></a><span id="l1.230">   if (mc.messageDisplay.visible) {</span>
<a href="#l1.231"></a><span id="l1.231" class="difflineat">@@ -538,58 +574,63 @@ function switch_tab(aNewTab) {</span>
<a href="#l1.232"></a><span id="l1.232"> </span>
<a href="#l1.233"></a><span id="l1.233"> /**</span>
<a href="#l1.234"></a><span id="l1.234">  * Assert that the currently selected tab is the given one.</span>
<a href="#l1.235"></a><span id="l1.235">  *</span>
<a href="#l1.236"></a><span id="l1.236">  * @param aTab The tab that should currently be selected.</span>
<a href="#l1.237"></a><span id="l1.237">  */</span>
<a href="#l1.238"></a><span id="l1.238"> function assert_selected_tab(aTab) {</span>
<a href="#l1.239"></a><span id="l1.239">   if (mc.tabmail.currentTabInfo != aTab)</span>
<a href="#l1.240"></a><span id="l1.240" class="difflineminus">-    throw new Error(&quot;The currently selected tab should be at index &quot; +</span>
<a href="#l1.241"></a><span id="l1.241" class="difflineminus">-        mc.tabmail.tabInfo.indexOf(aTab) + &quot;, but is actually at index &quot; +</span>
<a href="#l1.242"></a><span id="l1.242" class="difflineminus">-        mc.tabmail.tabInfo.indexOf(mc.tabmail.currentTabInfo));</span>
<a href="#l1.243"></a><span id="l1.243" class="difflineplus">+    mark_failure([&quot;The currently selected tab should be&quot;, aTab,</span>
<a href="#l1.244"></a><span id="l1.244" class="difflineplus">+        &quot;(index: &quot; + mc.tabmail.tabInfo.indexOf(aTab) + &quot;) but is&quot;,</span>
<a href="#l1.245"></a><span id="l1.245" class="difflineplus">+        mc.tabmail.currentTabInfo,</span>
<a href="#l1.246"></a><span id="l1.246" class="difflineplus">+        &quot;(index: &quot; + mc.tabmail.tabInfo.indexOf(mc.tabmail.currentTabInfo) +</span>
<a href="#l1.247"></a><span id="l1.247" class="difflineplus">+        &quot;) tabs:&quot;, mc.tabmail.tabInfo,</span>
<a href="#l1.248"></a><span id="l1.248" class="difflineplus">+        ]);</span>
<a href="#l1.249"></a><span id="l1.249"> }</span>
<a href="#l1.250"></a><span id="l1.250"> </span>
<a href="#l1.251"></a><span id="l1.251"> /**</span>
<a href="#l1.252"></a><span id="l1.252">  * Assert that the currently selected tab is _not_ the given one.</span>
<a href="#l1.253"></a><span id="l1.253">  *</span>
<a href="#l1.254"></a><span id="l1.254">  * @param aTab The tab that should currently not be selected.</span>
<a href="#l1.255"></a><span id="l1.255">  */</span>
<a href="#l1.256"></a><span id="l1.256"> function assert_not_selected_tab(aTab) {</span>
<a href="#l1.257"></a><span id="l1.257">   if (mc.tabmail.currentTabInfo == aTab)</span>
<a href="#l1.258"></a><span id="l1.258" class="difflineminus">-    throw new Error(&quot;The currently selected tab should not be the one at &quot; +</span>
<a href="#l1.259"></a><span id="l1.259" class="difflineminus">-        &quot;index &quot; + mc.tabmail.tabInfo.indexOf(aTab) + &quot;, but is actually so.&quot;);</span>
<a href="#l1.260"></a><span id="l1.260" class="difflineplus">+    mark_failure([&quot;The currently selected tab should not be&quot;, aTab,</span>
<a href="#l1.261"></a><span id="l1.261" class="difflineplus">+                  &quot;but is. Tabs:&quot;, mc.tabmail.tabInfo]);</span>
<a href="#l1.262"></a><span id="l1.262"> }</span>
<a href="#l1.263"></a><span id="l1.263"> </span>
<a href="#l1.264"></a><span id="l1.264"> /**</span>
<a href="#l1.265"></a><span id="l1.265">  * Assert that the given tab has the given mode name. Valid mode names include</span>
<a href="#l1.266"></a><span id="l1.266">  * &quot;message&quot; and &quot;folder&quot;.</span>
<a href="#l1.267"></a><span id="l1.267">  *</span>
<a href="#l1.268"></a><span id="l1.268">  * @param aTab A Tab. The currently selected tab if null.</span>
<a href="#l1.269"></a><span id="l1.269">  * @param aModeName A string that should match the mode name of the tab.</span>
<a href="#l1.270"></a><span id="l1.270">  */</span>
<a href="#l1.271"></a><span id="l1.271"> function assert_tab_mode_name(aTab, aModeName) {</span>
<a href="#l1.272"></a><span id="l1.272">   if (!aTab)</span>
<a href="#l1.273"></a><span id="l1.273">     aTab = mc.tabmail.currentTabInfo;</span>
<a href="#l1.274"></a><span id="l1.274"> </span>
<a href="#l1.275"></a><span id="l1.275">   if (aTab.mode.type != aModeName)</span>
<a href="#l1.276"></a><span id="l1.276" class="difflineminus">-    throw new Error(&quot;Tab should be of type &quot; + aModeName +</span>
<a href="#l1.277"></a><span id="l1.277" class="difflineminus">-                    &quot;, but is actually of type &quot; + aTab.mode.type + &quot;.&quot;);</span>
<a href="#l1.278"></a><span id="l1.278" class="difflineplus">+    mark_failure([&quot;Tab&quot;, aTab, &quot;should be of type&quot;, aModeName,</span>
<a href="#l1.279"></a><span id="l1.279" class="difflineplus">+                  &quot;but is actually of type&quot;, aTab.mode.type,</span>
<a href="#l1.280"></a><span id="l1.280" class="difflineplus">+                  &quot;Tabs:&quot;, mc.tabmail.tabInfo]);</span>
<a href="#l1.281"></a><span id="l1.281"> }</span>
<a href="#l1.282"></a><span id="l1.282"> </span>
<a href="#l1.283"></a><span id="l1.283"> /**</span>
<a href="#l1.284"></a><span id="l1.284">  * Assert that the number of tabs open matches the value given.</span>
<a href="#l1.285"></a><span id="l1.285">  *</span>
<a href="#l1.286"></a><span id="l1.286">  * @param aNumber The number of tabs that should be open.</span>
<a href="#l1.287"></a><span id="l1.287">  */</span>
<a href="#l1.288"></a><span id="l1.288"> function assert_number_of_tabs_open(aNumber) {</span>
<a href="#l1.289"></a><span id="l1.289">   let actualNumber = mc.tabmail.tabContainer.childNodes.length;</span>
<a href="#l1.290"></a><span id="l1.290">   if (actualNumber != aNumber)</span>
<a href="#l1.291"></a><span id="l1.291" class="difflineminus">-    throw new Error(&quot;There should be &quot; + aNumber + &quot; tabs open, but there &quot; +</span>
<a href="#l1.292"></a><span id="l1.292" class="difflineminus">-                    &quot;are actually &quot; + actualNumber + &quot; tabs open.&quot;);</span>
<a href="#l1.293"></a><span id="l1.293" class="difflineplus">+    mark_failure([&quot;There should be &quot; + aNumber + &quot; tabs open, but there &quot; +</span>
<a href="#l1.294"></a><span id="l1.294" class="difflineplus">+                  &quot;are actually &quot; + actualNumber + &quot; tabs open. Tabs:&quot;,</span>
<a href="#l1.295"></a><span id="l1.295" class="difflineplus">+                   mc.tabmail.tabInfo]);</span>
<a href="#l1.296"></a><span id="l1.296"> }</span>
<a href="#l1.297"></a><span id="l1.297"> </span>
<a href="#l1.298"></a><span id="l1.298"> /**</span>
<a href="#l1.299"></a><span id="l1.299">  * Assert that the given tab's title is based on the provided folder or</span>
<a href="#l1.300"></a><span id="l1.300">  *  message.</span>
<a href="#l1.301"></a><span id="l1.301">  *</span>
<a href="#l1.302"></a><span id="l1.302">  * @param aTab A Tab.</span>
<a href="#l1.303"></a><span id="l1.303">  * @param aWhat Either an nsIMsgFolder or an nsIMsgDBHdr</span>
<a href="#l1.304"></a><span id="l1.304" class="difflineat">@@ -597,25 +638,28 @@ function assert_number_of_tabs_open(aNum</span>
<a href="#l1.305"></a><span id="l1.305"> function assert_tab_titled_from(aTab, aWhat) {</span>
<a href="#l1.306"></a><span id="l1.306">   let text;</span>
<a href="#l1.307"></a><span id="l1.307">   if (aWhat instanceof Ci.nsIMsgFolder)</span>
<a href="#l1.308"></a><span id="l1.308">     text = aWhat.prettiestName;</span>
<a href="#l1.309"></a><span id="l1.309">   else if (aWhat instanceof Ci.nsIMsgDBHdr)</span>
<a href="#l1.310"></a><span id="l1.310">     text = aWhat.mime2DecodedSubject;</span>
<a href="#l1.311"></a><span id="l1.311"> </span>
<a href="#l1.312"></a><span id="l1.312">   if (aTab.title.indexOf(text) == -1)</span>
<a href="#l1.313"></a><span id="l1.313" class="difflineminus">-    throw new Error(&quot;Tab title should include '&quot; + text + &quot;' but does not.&quot; +</span>
<a href="#l1.314"></a><span id="l1.314" class="difflineminus">-                    &quot; (Current title: '&quot; + aTab.title + &quot;'&quot;);</span>
<a href="#l1.315"></a><span id="l1.315" class="difflineplus">+    mark_failure([&quot;Tab title of tab&quot;, aTab,</span>
<a href="#l1.316"></a><span id="l1.316" class="difflineplus">+                  &quot;should include '&quot; + text + &quot;' but does not.&quot; +</span>
<a href="#l1.317"></a><span id="l1.317" class="difflineplus">+                  &quot; (Current title: '&quot; + aTab.title + &quot;')&quot;]);</span>
<a href="#l1.318"></a><span id="l1.318"> }</span>
<a href="#l1.319"></a><span id="l1.319"> </span>
<a href="#l1.320"></a><span id="l1.320"> /**</span>
<a href="#l1.321"></a><span id="l1.321">  * Close a tab.  If no tab is specified, it is assumed you want to close the</span>
<a href="#l1.322"></a><span id="l1.322">  *  current tab.</span>
<a href="#l1.323"></a><span id="l1.323">  */</span>
<a href="#l1.324"></a><span id="l1.324"> function close_tab(aTabToClose) {</span>
<a href="#l1.325"></a><span id="l1.325" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;close_tab&quot;, [aTabToClose]);</span>
<a href="#l1.326"></a><span id="l1.326" class="difflineplus">+</span>
<a href="#l1.327"></a><span id="l1.327">   if (typeof aTabToClose == &quot;number&quot;)</span>
<a href="#l1.328"></a><span id="l1.328">     aTabToClose = mc.tabmail.tabInfo[aTabToClose];</span>
<a href="#l1.329"></a><span id="l1.329"> </span>
<a href="#l1.330"></a><span id="l1.330">   // get the current tab count so we can make sure the tab actually opened.</span>
<a href="#l1.331"></a><span id="l1.331">   let preCount = mc.tabmail.tabContainer.childNodes.length;</span>
<a href="#l1.332"></a><span id="l1.332"> </span>
<a href="#l1.333"></a><span id="l1.333">   // If we're closing the current tab, a message or summary might be displayed</span>
<a href="#l1.334"></a><span id="l1.334">   // in the tab we'll select next.</span>
<a href="#l1.335"></a><span id="l1.335" class="difflineat">@@ -644,23 +688,25 @@ function close_tab(aTabToClose) {</span>
<a href="#l1.336"></a><span id="l1.336">   if (mc.tabmail.tabContainer.childNodes.length != preCount - 1)</span>
<a href="#l1.337"></a><span id="l1.337">     throw new Error(&quot;The tab never actually got closed!&quot;);</span>
<a href="#l1.338"></a><span id="l1.338"> }</span>
<a href="#l1.339"></a><span id="l1.339"> </span>
<a href="#l1.340"></a><span id="l1.340"> /**</span>
<a href="#l1.341"></a><span id="l1.341">  * Close a message window by calling window.close() on the controller.</span>
<a href="#l1.342"></a><span id="l1.342">  */</span>
<a href="#l1.343"></a><span id="l1.343"> function close_message_window(aController) {</span>
<a href="#l1.344"></a><span id="l1.344" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;close_message_window&quot;, []);</span>
<a href="#l1.345"></a><span id="l1.345">   windowHelper.close_window(aController);</span>
<a href="#l1.346"></a><span id="l1.346"> }</span>
<a href="#l1.347"></a><span id="l1.347"> </span>
<a href="#l1.348"></a><span id="l1.348"> /**</span>
<a href="#l1.349"></a><span id="l1.349">  * Clear the selection.  I'm not sure how we're pretending we did that.</span>
<a href="#l1.350"></a><span id="l1.350">  */</span>
<a href="#l1.351"></a><span id="l1.351"> function select_none(aController) {</span>
<a href="#l1.352"></a><span id="l1.352" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;select_none&quot;, []);</span>
<a href="#l1.353"></a><span id="l1.353">   if (aController === undefined)</span>
<a href="#l1.354"></a><span id="l1.354">     aController = mc;</span>
<a href="#l1.355"></a><span id="l1.355">   wait_for_message_display_completion();</span>
<a href="#l1.356"></a><span id="l1.356">   aController.dbView.selection.clearSelection();</span>
<a href="#l1.357"></a><span id="l1.357">   // Because the selection event may not be generated immediately, we need to</span>
<a href="#l1.358"></a><span id="l1.358">   //  spin until the message display thinks it is not displaying a message,</span>
<a href="#l1.359"></a><span id="l1.359">   //  which is the sign that the event actually happened.</span>
<a href="#l1.360"></a><span id="l1.360">   function noMessageChecker() {</span>
<a href="#l1.361"></a><span id="l1.361" class="difflineat">@@ -711,16 +757,18 @@ function _normalize_view_index(aViewInde</span>
<a href="#l1.362"></a><span id="l1.362"> function select_click_row(aViewIndex, aController) {</span>
<a href="#l1.363"></a><span id="l1.363">   if (aController === undefined)</span>
<a href="#l1.364"></a><span id="l1.364">     aController = mc;</span>
<a href="#l1.365"></a><span id="l1.365">   let hasMessageDisplay = &quot;messageDisplay&quot; in aController;</span>
<a href="#l1.366"></a><span id="l1.366">   if (hasMessageDisplay)</span>
<a href="#l1.367"></a><span id="l1.367">     wait_for_message_display_completion(aController);</span>
<a href="#l1.368"></a><span id="l1.368">   aViewIndex = _normalize_view_index(aViewIndex, aController);</span>
<a href="#l1.369"></a><span id="l1.369"> </span>
<a href="#l1.370"></a><span id="l1.370" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;select_click_row&quot;, [aViewIndex]);</span>
<a href="#l1.371"></a><span id="l1.371" class="difflineplus">+</span>
<a href="#l1.372"></a><span id="l1.372">   // this should set the current index as well as setting the selection.</span>
<a href="#l1.373"></a><span id="l1.373">   aController.dbView.selection.select(aViewIndex);</span>
<a href="#l1.374"></a><span id="l1.374">   if (hasMessageDisplay)</span>
<a href="#l1.375"></a><span id="l1.375">     wait_for_message_display_completion(aController,</span>
<a href="#l1.376"></a><span id="l1.376">                                         aController.messageDisplay.visible);</span>
<a href="#l1.377"></a><span id="l1.377">   return aController.dbView.getMsgHdrAt(aViewIndex);</span>
<a href="#l1.378"></a><span id="l1.378"> }</span>
<a href="#l1.379"></a><span id="l1.379"> </span>
<a href="#l1.380"></a><span id="l1.380" class="difflineat">@@ -730,16 +778,17 @@ function select_click_row(aViewIndex, aC</span>
<a href="#l1.381"></a><span id="l1.381">  * @param aViewIndex If &gt;= 0, the view index provided, if &lt; 0, a reference to</span>
<a href="#l1.382"></a><span id="l1.382">  *     a view index counting from the last row in the tree.  -1 indicates the</span>
<a href="#l1.383"></a><span id="l1.383">  *     last message in the tree, -2 the second to last, etc.</span>
<a href="#l1.384"></a><span id="l1.384">  *</span>
<a href="#l1.385"></a><span id="l1.385">  */</span>
<a href="#l1.386"></a><span id="l1.386"> function toggle_thread_row(aViewIndex) {</span>
<a href="#l1.387"></a><span id="l1.387">   wait_for_message_display_completion();</span>
<a href="#l1.388"></a><span id="l1.388">   aViewIndex = _normalize_view_index(aViewIndex);</span>
<a href="#l1.389"></a><span id="l1.389" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;toggle_thread_row&quot;, [aViewIndex]);</span>
<a href="#l1.390"></a><span id="l1.390">   mc.dbView.toggleOpenState(aViewIndex);</span>
<a href="#l1.391"></a><span id="l1.391">   wait_for_message_display_completion(mc, mc.messageDisplay.visible);</span>
<a href="#l1.392"></a><span id="l1.392"> }</span>
<a href="#l1.393"></a><span id="l1.393"> </span>
<a href="#l1.394"></a><span id="l1.394"> </span>
<a href="#l1.395"></a><span id="l1.395"> /**</span>
<a href="#l1.396"></a><span id="l1.396">  * Pretend we are clicking on a row with our mouse with the control key pressed,</span>
<a href="#l1.397"></a><span id="l1.397">  *  resulting in the addition/removal of just that row to/from the selection.</span>
<a href="#l1.398"></a><span id="l1.398" class="difflineat">@@ -754,16 +803,19 @@ function select_control_click_row(aViewI</span>
<a href="#l1.399"></a><span id="l1.399">   wait_for_message_display_completion();</span>
<a href="#l1.400"></a><span id="l1.400">   aViewIndex = _normalize_view_index(aViewIndex);</span>
<a href="#l1.401"></a><span id="l1.401">   // Control-clicking augments the selection and moves the current index.  It</span>
<a href="#l1.402"></a><span id="l1.402">   //  also clears the shift pivot, but that's fine as it falls back to the</span>
<a href="#l1.403"></a><span id="l1.403">   //  current index if there is no shift pivot, which works for duplicating</span>
<a href="#l1.404"></a><span id="l1.404">   //  actual behavior.</span>
<a href="#l1.405"></a><span id="l1.405">   mc.dbView.selection.rangedSelect(aViewIndex, aViewIndex, true);</span>
<a href="#l1.406"></a><span id="l1.406">   mc.dbView.selection.currentIndex = aViewIndex;</span>
<a href="#l1.407"></a><span id="l1.407" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;select_control_click_row&quot;,</span>
<a href="#l1.408"></a><span id="l1.408" class="difflineplus">+              [&quot;index&quot;, aViewIndex,</span>
<a href="#l1.409"></a><span id="l1.409" class="difflineplus">+               &quot;selected messages:&quot;, mc.folderDisplay.selectedMessages]);</span>
<a href="#l1.410"></a><span id="l1.410">   // give the event queue a chance to drain...</span>
<a href="#l1.411"></a><span id="l1.411">   controller.sleep(0);</span>
<a href="#l1.412"></a><span id="l1.412">   wait_for_message_display_completion();</span>
<a href="#l1.413"></a><span id="l1.413">   return mc.dbView.getMsgHdrAt(aViewIndex);</span>
<a href="#l1.414"></a><span id="l1.414"> }</span>
<a href="#l1.415"></a><span id="l1.415"> </span>
<a href="#l1.416"></a><span id="l1.416"> /**</span>
<a href="#l1.417"></a><span id="l1.417">  * Pretend we are clicking on a row with our mouse with the shift key pressed,</span>
<a href="#l1.418"></a><span id="l1.418" class="difflineat">@@ -786,16 +838,19 @@ function select_shift_click_row(aViewInd</span>
<a href="#l1.419"></a><span id="l1.419">   aViewIndex = _normalize_view_index(aViewIndex, aController);</span>
<a href="#l1.420"></a><span id="l1.420"> </span>
<a href="#l1.421"></a><span id="l1.421">   // Passing -1 as the start range checks the shift-pivot, which should be -1,</span>
<a href="#l1.422"></a><span id="l1.422">   //  so it should fall over to the current index, which is what we want.  It</span>
<a href="#l1.423"></a><span id="l1.423">   //  will then set the shift-pivot to the previously-current-index and update</span>
<a href="#l1.424"></a><span id="l1.424">   //  the current index to be what we shift-clicked on.  All matches user</span>
<a href="#l1.425"></a><span id="l1.425">   //  interaction.</span>
<a href="#l1.426"></a><span id="l1.426">   aController.dbView.selection.rangedSelect(-1, aViewIndex, false);</span>
<a href="#l1.427"></a><span id="l1.427" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;select_shift_click_row&quot;,</span>
<a href="#l1.428"></a><span id="l1.428" class="difflineplus">+              [&quot;index&quot;, aViewIndex,</span>
<a href="#l1.429"></a><span id="l1.429" class="difflineplus">+               &quot;selected messages:&quot;, mc.folderDisplay.selectedMessages]);</span>
<a href="#l1.430"></a><span id="l1.430">   // give the event queue a chance to drain...</span>
<a href="#l1.431"></a><span id="l1.431">   controller.sleep(0);</span>
<a href="#l1.432"></a><span id="l1.432">   if (hasMessageDisplay)</span>
<a href="#l1.433"></a><span id="l1.433">     wait_for_message_display_completion(aController);</span>
<a href="#l1.434"></a><span id="l1.434">   return aController.folderDisplay.selectedMessages;</span>
<a href="#l1.435"></a><span id="l1.435"> }</span>
<a href="#l1.436"></a><span id="l1.436"> </span>
<a href="#l1.437"></a><span id="l1.437"> /**</span>
<a href="#l1.438"></a><span id="l1.438" class="difflineat">@@ -833,28 +888,32 @@ function _row_click_helper(aTree, aViewI</span>
<a href="#l1.439"></a><span id="l1.439">  *  the side-effect of opening up a pop-up which it is then on _your_ head</span>
<a href="#l1.440"></a><span id="l1.440">  *  to do something with or close.  However, we have helpful popup function</span>
<a href="#l1.441"></a><span id="l1.441">  *  helpers because I'm so nice.</span>
<a href="#l1.442"></a><span id="l1.442">  *</span>
<a href="#l1.443"></a><span id="l1.443">  * @return The message header that you clicked on.</span>
<a href="#l1.444"></a><span id="l1.444">  */</span>
<a href="#l1.445"></a><span id="l1.445"> function right_click_on_row(aViewIndex) {</span>
<a href="#l1.446"></a><span id="l1.446">   let msgHdr = mc.dbView.getMsgHdrAt(aViewIndex);</span>
<a href="#l1.447"></a><span id="l1.447" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;right_click_on_row&quot;,</span>
<a href="#l1.448"></a><span id="l1.448" class="difflineplus">+              [&quot;index&quot;, aViewIndex, &quot;message header&quot;, msgHdr]);</span>
<a href="#l1.449"></a><span id="l1.449">   _row_click_helper(mc.threadTree, aViewIndex, 2);</span>
<a href="#l1.450"></a><span id="l1.450">   return msgHdr;</span>
<a href="#l1.451"></a><span id="l1.451"> }</span>
<a href="#l1.452"></a><span id="l1.452"> </span>
<a href="#l1.453"></a><span id="l1.453"> /**</span>
<a href="#l1.454"></a><span id="l1.454">  * Middle-click on the tree-view in question, presumably opening a new message</span>
<a href="#l1.455"></a><span id="l1.455">  *  tab.</span>
<a href="#l1.456"></a><span id="l1.456">  *</span>
<a href="#l1.457"></a><span id="l1.457">  * @return [The new tab, the message that you clicked on.]</span>
<a href="#l1.458"></a><span id="l1.458">  */</span>
<a href="#l1.459"></a><span id="l1.459"> function middle_click_on_row(aViewIndex) {</span>
<a href="#l1.460"></a><span id="l1.460">   let msgHdr = mc.dbView.getMsgHdrAt(aViewIndex);</span>
<a href="#l1.461"></a><span id="l1.461" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;middle_click_on_row&quot;,</span>
<a href="#l1.462"></a><span id="l1.462" class="difflineplus">+              [&quot;index&quot;, aViewIndex, &quot;message header&quot;, msgHdr]);</span>
<a href="#l1.463"></a><span id="l1.463">   _row_click_helper(mc.threadTree, aViewIndex, 1);</span>
<a href="#l1.464"></a><span id="l1.464">   // We append new tabs at the end, so return the last tab</span>
<a href="#l1.465"></a><span id="l1.465">   return [mc.tabmail.tabInfo[mc.tabmail.tabContainer.childNodes.length - 1],</span>
<a href="#l1.466"></a><span id="l1.466">           msgHdr];</span>
<a href="#l1.467"></a><span id="l1.467"> }</span>
<a href="#l1.468"></a><span id="l1.468"> </span>
<a href="#l1.469"></a><span id="l1.469"> /**</span>
<a href="#l1.470"></a><span id="l1.470">  * Assert that the given row index is currently visible in the thread pane view.</span>
<a href="#l1.471"></a><span id="l1.471" class="difflineat">@@ -869,17 +928,16 @@ function assert_row_visible(aViewIndex) </span>
<a href="#l1.472"></a><span id="l1.472"> }</span>
<a href="#l1.473"></a><span id="l1.473"> </span>
<a href="#l1.474"></a><span id="l1.474"> /**</span>
<a href="#l1.475"></a><span id="l1.475">  * Assert that the given folder mode is the current one.</span>
<a href="#l1.476"></a><span id="l1.476">  *</span>
<a href="#l1.477"></a><span id="l1.477">  * @param aMode The expected folder mode.</span>
<a href="#l1.478"></a><span id="l1.478">  * @param [aController] The controller in whose context to do this, defaults to</span>
<a href="#l1.479"></a><span id="l1.479">  *     |mc| if omitted.</span>
<a href="#l1.480"></a><span id="l1.480" class="difflineminus">- </span>
<a href="#l1.481"></a><span id="l1.481">  */</span>
<a href="#l1.482"></a><span id="l1.482"> function assert_folder_mode(aMode, aController) {</span>
<a href="#l1.483"></a><span id="l1.483">   if (aController === undefined)</span>
<a href="#l1.484"></a><span id="l1.484">     aController = mc;</span>
<a href="#l1.485"></a><span id="l1.485">   let actualMode = aController.folderTreeView.mode;</span>
<a href="#l1.486"></a><span id="l1.486">   if (actualMode != aMode)</span>
<a href="#l1.487"></a><span id="l1.487">     throw new Error(&quot;The folder mode should be &quot; + aMode +</span>
<a href="#l1.488"></a><span id="l1.488">                     &quot;, but is actually &quot; + actualMode);</span>
<a href="#l1.489"></a><span id="l1.489" class="difflineat">@@ -974,16 +1032,17 @@ function assert_folder_expanded(aFolder)</span>
<a href="#l1.490"></a><span id="l1.490"> }</span>
<a href="#l1.491"></a><span id="l1.491"> </span>
<a href="#l1.492"></a><span id="l1.492"> /**</span>
<a href="#l1.493"></a><span id="l1.493">  * Clear the selection in the folder tree view.</span>
<a href="#l1.494"></a><span id="l1.494">  */</span>
<a href="#l1.495"></a><span id="l1.495"> function select_no_folders() {</span>
<a href="#l1.496"></a><span id="l1.496">   wait_for_message_display_completion();</span>
<a href="#l1.497"></a><span id="l1.497">   mc.folderTreeView.selection.clearSelection();</span>
<a href="#l1.498"></a><span id="l1.498" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;select_no_folder&quot;, []);</span>
<a href="#l1.499"></a><span id="l1.499">   // give the event queue a chance to drain...</span>
<a href="#l1.500"></a><span id="l1.500">   controller.sleep(0);</span>
<a href="#l1.501"></a><span id="l1.501"> }</span>
<a href="#l1.502"></a><span id="l1.502"> </span>
<a href="#l1.503"></a><span id="l1.503"> /**</span>
<a href="#l1.504"></a><span id="l1.504">  * Pretend we are clicking on a folder with our mouse.</span>
<a href="#l1.505"></a><span id="l1.505">  *</span>
<a href="#l1.506"></a><span id="l1.506">  * @param aFolder The folder to click on. This needs to be present in the</span>
<a href="#l1.507"></a><span id="l1.507" class="difflineat">@@ -993,16 +1052,19 @@ function select_no_folders() {</span>
<a href="#l1.508"></a><span id="l1.508">  */</span>
<a href="#l1.509"></a><span id="l1.509"> function select_click_folder(aFolder) {</span>
<a href="#l1.510"></a><span id="l1.510">   wait_for_all_messages_to_load();</span>
<a href="#l1.511"></a><span id="l1.511"> </span>
<a href="#l1.512"></a><span id="l1.512">   // this should set the current index as well as setting the selection.</span>
<a href="#l1.513"></a><span id="l1.513">   let viewIndex = mc.folderTreeView.getIndexOfFolder(aFolder);</span>
<a href="#l1.514"></a><span id="l1.514">   mc.folderTreeView.selection.select(viewIndex);</span>
<a href="#l1.515"></a><span id="l1.515">   wait_for_all_messages_to_load();</span>
<a href="#l1.516"></a><span id="l1.516" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;select_click_folder&quot;,</span>
<a href="#l1.517"></a><span id="l1.517" class="difflineplus">+              [&quot;clicked:&quot;, aFolder,</span>
<a href="#l1.518"></a><span id="l1.518" class="difflineplus">+               &quot;now selected:&quot;, mc.folderTreeView.getSelectedFolders()]);</span>
<a href="#l1.519"></a><span id="l1.519">   // drain the event queue</span>
<a href="#l1.520"></a><span id="l1.520">   controller.sleep(0);</span>
<a href="#l1.521"></a><span id="l1.521"> </span>
<a href="#l1.522"></a><span id="l1.522">   return viewIndex;</span>
<a href="#l1.523"></a><span id="l1.523"> }</span>
<a href="#l1.524"></a><span id="l1.524"> </span>
<a href="#l1.525"></a><span id="l1.525"> /**</span>
<a href="#l1.526"></a><span id="l1.526">  * Pretend we are clicking on a folder with our mouse with the shift key pressed.</span>
<a href="#l1.527"></a><span id="l1.527" class="difflineat">@@ -1018,16 +1080,19 @@ function select_shift_click_folder(aFold</span>
<a href="#l1.528"></a><span id="l1.528">   let viewIndex = mc.folderTreeView.getIndexOfFolder(aFolder);</span>
<a href="#l1.529"></a><span id="l1.529">   // Passing -1 as the start range checks the shift-pivot, which should be -1,</span>
<a href="#l1.530"></a><span id="l1.530">   //  so it should fall over to the current index, which is what we want.  It</span>
<a href="#l1.531"></a><span id="l1.531">   //  will then set the shift-pivot to the previously-current-index and update</span>
<a href="#l1.532"></a><span id="l1.532">   //  the current index to be what we shift-clicked on.  All matches user</span>
<a href="#l1.533"></a><span id="l1.533">   //  interaction.</span>
<a href="#l1.534"></a><span id="l1.534">   mc.folderTreeView.selection.rangedSelect(-1, viewIndex, false);</span>
<a href="#l1.535"></a><span id="l1.535">   wait_for_all_messages_to_load();</span>
<a href="#l1.536"></a><span id="l1.536" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;select_shift_click_folder&quot;,</span>
<a href="#l1.537"></a><span id="l1.537" class="difflineplus">+              [&quot;clicked:&quot;, aFolder,</span>
<a href="#l1.538"></a><span id="l1.538" class="difflineplus">+               &quot;now selected:&quot;, mc.folderTreeView.getSelectedFolders()]);</span>
<a href="#l1.539"></a><span id="l1.539">   // give the event queue a chance to drain...</span>
<a href="#l1.540"></a><span id="l1.540">   controller.sleep(0);</span>
<a href="#l1.541"></a><span id="l1.541"> </span>
<a href="#l1.542"></a><span id="l1.542">   return mc.folderTreeView.getSelectedFolders();</span>
<a href="#l1.543"></a><span id="l1.543"> }</span>
<a href="#l1.544"></a><span id="l1.544"> </span>
<a href="#l1.545"></a><span id="l1.545"> /**</span>
<a href="#l1.546"></a><span id="l1.546">  * Right click on the folder tree view. With any luck, this will have the</span>
<a href="#l1.547"></a><span id="l1.547" class="difflineat">@@ -1037,30 +1102,32 @@ function select_shift_click_folder(aFold</span>
<a href="#l1.548"></a><span id="l1.548">  *</span>
<a href="#l1.549"></a><span id="l1.549">  * @note The argument is a folder here, unlike in the message case, so beware.</span>
<a href="#l1.550"></a><span id="l1.550">  *</span>
<a href="#l1.551"></a><span id="l1.551">  * @return The view index that you clicked on.</span>
<a href="#l1.552"></a><span id="l1.552">  */</span>
<a href="#l1.553"></a><span id="l1.553"> function right_click_on_folder(aFolder) {</span>
<a href="#l1.554"></a><span id="l1.554">   // Figure out the view index</span>
<a href="#l1.555"></a><span id="l1.555">   let viewIndex = mc.folderTreeView.getIndexOfFolder(aFolder);</span>
<a href="#l1.556"></a><span id="l1.556" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;right_click_on_folder&quot;, [aFolder]);</span>
<a href="#l1.557"></a><span id="l1.557">   _row_click_helper(mc.folderTree, viewIndex, 2);</span>
<a href="#l1.558"></a><span id="l1.558">   return viewIndex;</span>
<a href="#l1.559"></a><span id="l1.559"> }</span>
<a href="#l1.560"></a><span id="l1.560"> </span>
<a href="#l1.561"></a><span id="l1.561"> /**</span>
<a href="#l1.562"></a><span id="l1.562">  * Middle-click on the folder tree view, presumably opening a new folder tab.</span>
<a href="#l1.563"></a><span id="l1.563">  *</span>
<a href="#l1.564"></a><span id="l1.564">  * @note The argument is a folder here, unlike in the message case, so beware.</span>
<a href="#l1.565"></a><span id="l1.565">  *</span>
<a href="#l1.566"></a><span id="l1.566">  * @return [The new tab, the view index that you clicked on.]</span>
<a href="#l1.567"></a><span id="l1.567">  */</span>
<a href="#l1.568"></a><span id="l1.568"> function middle_click_on_folder(aFolder) {</span>
<a href="#l1.569"></a><span id="l1.569">   // Figure out the view index</span>
<a href="#l1.570"></a><span id="l1.570">   let viewIndex = mc.folderTreeView.getIndexOfFolder(aFolder);</span>
<a href="#l1.571"></a><span id="l1.571" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;middle_click_on_folder&quot;, [aFolder]);</span>
<a href="#l1.572"></a><span id="l1.572">   _row_click_helper(mc.folderTree, viewIndex, 1);</span>
<a href="#l1.573"></a><span id="l1.573">   // We append new tabs at the end, so return the last tab</span>
<a href="#l1.574"></a><span id="l1.574">   return [mc.tabmail.tabInfo[mc.tabmail.tabContainer.childNodes.length - 1],</span>
<a href="#l1.575"></a><span id="l1.575">           viewIndex];</span>
<a href="#l1.576"></a><span id="l1.576"> }</span>
<a href="#l1.577"></a><span id="l1.577"> </span>
<a href="#l1.578"></a><span id="l1.578"> /**</span>
<a href="#l1.579"></a><span id="l1.579">  * Get a reference to the smart folder with the given name.</span>
<a href="#l1.580"></a><span id="l1.580" class="difflineat">@@ -1077,28 +1144,31 @@ function get_smart_folder_named(aFolderN</span>
<a href="#l1.581"></a><span id="l1.581"> </span>
<a href="#l1.582"></a><span id="l1.582"> /**</span>
<a href="#l1.583"></a><span id="l1.583">  * Assuming the context popup is popped-up (via right_click_on_row), select</span>
<a href="#l1.584"></a><span id="l1.584">  *  the deletion option.  If the popup is not popped up, you are out of luck.</span>
<a href="#l1.585"></a><span id="l1.585">  */</span>
<a href="#l1.586"></a><span id="l1.586"> function delete_via_popup() {</span>
<a href="#l1.587"></a><span id="l1.587">   plan_to_wait_for_folder_events(&quot;DeleteOrMoveMsgCompleted&quot;,</span>
<a href="#l1.588"></a><span id="l1.588">                                  &quot;DeleteOrMoveMsgFailed&quot;);</span>
<a href="#l1.589"></a><span id="l1.589" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;delete_via_popup&quot;,</span>
<a href="#l1.590"></a><span id="l1.590" class="difflineplus">+              [&quot;selected messages:&quot;, mc.folderDisplay.selectedMessages]);</span>
<a href="#l1.591"></a><span id="l1.591">   mc.click(mc.eid(&quot;mailContext-delete&quot;));</span>
<a href="#l1.592"></a><span id="l1.592">   // for reasons unknown, the pop-up does not close itself?</span>
<a href="#l1.593"></a><span id="l1.593">   close_popup();</span>
<a href="#l1.594"></a><span id="l1.594">   wait_for_folder_events();</span>
<a href="#l1.595"></a><span id="l1.595"> }</span>
<a href="#l1.596"></a><span id="l1.596"> </span>
<a href="#l1.597"></a><span id="l1.597"> /**</span>
<a href="#l1.598"></a><span id="l1.598">  * Close the open pop-up.</span>
<a href="#l1.599"></a><span id="l1.599">  */</span>
<a href="#l1.600"></a><span id="l1.600"> function close_popup(aController) {</span>
<a href="#l1.601"></a><span id="l1.601">   if (aController === undefined)</span>
<a href="#l1.602"></a><span id="l1.602">     aController = mc;</span>
<a href="#l1.603"></a><span id="l1.603" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;close_popup&quot;, []);</span>
<a href="#l1.604"></a><span id="l1.604">   aController.keypress(aController.eid(&quot;mailContext&quot;), &quot;VK_ESCAPE&quot;, {});</span>
<a href="#l1.605"></a><span id="l1.605">   // drain event queue</span>
<a href="#l1.606"></a><span id="l1.606">   aController.sleep(0);</span>
<a href="#l1.607"></a><span id="l1.607"> }</span>
<a href="#l1.608"></a><span id="l1.608"> </span>
<a href="#l1.609"></a><span id="l1.609"> /**</span>
<a href="#l1.610"></a><span id="l1.610">  * Pretend we are pressing the delete key, triggering message deletion of the</span>
<a href="#l1.611"></a><span id="l1.611">  *  selected messages.</span>
<a href="#l1.612"></a><span id="l1.612" class="difflineat">@@ -1108,16 +1178,19 @@ function close_popup(aController) {</span>
<a href="#l1.613"></a><span id="l1.613">  */</span>
<a href="#l1.614"></a><span id="l1.614"> function press_delete(aController) {</span>
<a href="#l1.615"></a><span id="l1.615">   if (aController === undefined)</span>
<a href="#l1.616"></a><span id="l1.616">     aController = mc;</span>
<a href="#l1.617"></a><span id="l1.617">   // if something is loading, make sure it finishes loading...</span>
<a href="#l1.618"></a><span id="l1.618">   wait_for_message_display_completion(aController);</span>
<a href="#l1.619"></a><span id="l1.619">   plan_to_wait_for_folder_events(&quot;DeleteOrMoveMsgCompleted&quot;,</span>
<a href="#l1.620"></a><span id="l1.620">                                  &quot;DeleteOrMoveMsgFailed&quot;);</span>
<a href="#l1.621"></a><span id="l1.621" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;press_delete&quot;,</span>
<a href="#l1.622"></a><span id="l1.622" class="difflineplus">+              [&quot;selected messages:&quot;,</span>
<a href="#l1.623"></a><span id="l1.623" class="difflineplus">+               aController.folderDisplay.selectedMessages]);</span>
<a href="#l1.624"></a><span id="l1.624">   aController.keypress(aController == mc ? mc.eThreadTree : null,</span>
<a href="#l1.625"></a><span id="l1.625">                        &quot;VK_DELETE&quot;, {});</span>
<a href="#l1.626"></a><span id="l1.626">   wait_for_folder_events();</span>
<a href="#l1.627"></a><span id="l1.627"> }</span>
<a href="#l1.628"></a><span id="l1.628"> </span>
<a href="#l1.629"></a><span id="l1.629"> /**</span>
<a href="#l1.630"></a><span id="l1.630">  * Archive the selected messages, and wait for it to complete.</span>
<a href="#l1.631"></a><span id="l1.631">  *</span>
<a href="#l1.632"></a><span id="l1.632" class="difflineat">@@ -1154,35 +1227,38 @@ function archive_selected_messages(aCont</span>
<a href="#l1.633"></a><span id="l1.633">  *     |mc| if omitted.</span>
<a href="#l1.634"></a><span id="l1.634">  */</span>
<a href="#l1.635"></a><span id="l1.635"> function press_enter(aController) {</span>
<a href="#l1.636"></a><span id="l1.636">   if (aController === undefined)</span>
<a href="#l1.637"></a><span id="l1.637">     aController = mc;</span>
<a href="#l1.638"></a><span id="l1.638">   // if something is loading, make sure it finishes loading...</span>
<a href="#l1.639"></a><span id="l1.639">   if (&quot;messageDisplay&quot; in aController)</span>
<a href="#l1.640"></a><span id="l1.640">     wait_for_message_display_completion(aController);</span>
<a href="#l1.641"></a><span id="l1.641" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;press_enter&quot;,</span>
<a href="#l1.642"></a><span id="l1.642" class="difflineplus">+              [&quot;selected messages:&quot;,</span>
<a href="#l1.643"></a><span id="l1.643" class="difflineplus">+               aController.folderDisplay.selectedMessages]);</span>
<a href="#l1.644"></a><span id="l1.644">   aController.keypress(aController == mc ? mc.eThreadTree : null,</span>
<a href="#l1.645"></a><span id="l1.645">                        &quot;VK_RETURN&quot;, {});</span>
<a href="#l1.646"></a><span id="l1.646">   // The caller's going to have to wait for message display completion</span>
<a href="#l1.647"></a><span id="l1.647"> }</span>
<a href="#l1.648"></a><span id="l1.648"> </span>
<a href="#l1.649"></a><span id="l1.649"> /**</span>
<a href="#l1.650"></a><span id="l1.650">  * Wait for the |folderDisplay| on aController (defaults to mc if omitted) to</span>
<a href="#l1.651"></a><span id="l1.651">  *  finish loading.  This generally only matters for folders that have an active</span>
<a href="#l1.652"></a><span id="l1.652">  *  search.</span>
<a href="#l1.653"></a><span id="l1.653">  * This method is generally called automatically most of the time, and you</span>
<a href="#l1.654"></a><span id="l1.654">  *  should not need to call it yourself unless you are operating outside the</span>
<a href="#l1.655"></a><span id="l1.655">  *  helper methods in this file.</span>
<a href="#l1.656"></a><span id="l1.656">  */</span>
<a href="#l1.657"></a><span id="l1.657"> function wait_for_all_messages_to_load(aController) {</span>
<a href="#l1.658"></a><span id="l1.658">   if (aController === undefined)</span>
<a href="#l1.659"></a><span id="l1.659">     aController = mc;</span>
<a href="#l1.660"></a><span id="l1.660" class="difflineminus">-  if(!controller.waitForEval('subject.allMessagesLoaded', NORMAL_TIMEOUT,</span>
<a href="#l1.661"></a><span id="l1.661" class="difflineplus">+  if (!controller.waitForEval('subject.allMessagesLoaded', NORMAL_TIMEOUT,</span>
<a href="#l1.662"></a><span id="l1.662">                               FAST_INTERVAL, aController.folderDisplay))</span>
<a href="#l1.663"></a><span id="l1.663" class="difflineminus">-    throw new Error(&quot;Messages never finished loading.  Timed Out.&quot;);</span>
<a href="#l1.664"></a><span id="l1.664" class="difflineplus">+    mark_failure([&quot;Messages never finished loading.  Timed Out.&quot;]);</span>
<a href="#l1.665"></a><span id="l1.665">   // the above may return immediately, meaning the event queue might not get a</span>
<a href="#l1.666"></a><span id="l1.666">   //  chance.  give it a chance now.</span>
<a href="#l1.667"></a><span id="l1.667">   aController.sleep(0);</span>
<a href="#l1.668"></a><span id="l1.668"> }</span>
<a href="#l1.669"></a><span id="l1.669"> </span>
<a href="#l1.670"></a><span id="l1.670"> /**</span>
<a href="#l1.671"></a><span id="l1.671">  * Call this before triggering a message display that you are going to wait for</span>
<a href="#l1.672"></a><span id="l1.672">  *  using |wait_for_message_display_completion| where you are passing true for</span>
<a href="#l1.673"></a><span id="l1.673" class="difflineat">@@ -1272,19 +1348,19 @@ function wait_for_message_display_comple</span>
<a href="#l1.674"></a><span id="l1.674">       let urlRunningObj = {};</span>
<a href="#l1.675"></a><span id="l1.675">       uri.GetUrlState(urlRunningObj);</span>
<a href="#l1.676"></a><span id="l1.676">       // GetUrlState returns true if the url is still running</span>
<a href="#l1.677"></a><span id="l1.677">       return !urlRunningObj.value;</span>
<a href="#l1.678"></a><span id="l1.678">     }</span>
<a href="#l1.679"></a><span id="l1.679">     // not a mailnews URL, just check the busy flags...</span>
<a href="#l1.680"></a><span id="l1.680">     return !docShell.busyFlags;</span>
<a href="#l1.681"></a><span id="l1.681">   };</span>
<a href="#l1.682"></a><span id="l1.682" class="difflineminus">-  controller.waitForEval('subject()',</span>
<a href="#l1.683"></a><span id="l1.683" class="difflineminus">-                         NORMAL_TIMEOUT,</span>
<a href="#l1.684"></a><span id="l1.684" class="difflineminus">-                         FAST_INTERVAL, isLoadedChecker);</span>
<a href="#l1.685"></a><span id="l1.685" class="difflineplus">+  if (!controller.waitForEval('subject()', NORMAL_TIMEOUT, FAST_INTERVAL,</span>
<a href="#l1.686"></a><span id="l1.686" class="difflineplus">+                              isLoadedChecker))</span>
<a href="#l1.687"></a><span id="l1.687" class="difflineplus">+    mark_failure([&quot;Timed out waiting for message display completion.&quot;]);</span>
<a href="#l1.688"></a><span id="l1.688">   // the above may return immediately, meaning the event queue might not get a</span>
<a href="#l1.689"></a><span id="l1.689">   //  chance.  give it a chance now.</span>
<a href="#l1.690"></a><span id="l1.690">   aController.sleep(0);</span>
<a href="#l1.691"></a><span id="l1.691"> }</span>
<a href="#l1.692"></a><span id="l1.692"> </span>
<a href="#l1.693"></a><span id="l1.693"> /**</span>
<a href="#l1.694"></a><span id="l1.694">  * Wait for the content pane to be blank because no message is to be displayed.</span>
<a href="#l1.695"></a><span id="l1.695">  * You would not want to call this once folder summaries land and if they are</span>
<a href="#l1.696"></a><span id="l1.696" class="difflineat">@@ -1294,19 +1370,20 @@ function wait_for_message_display_comple</span>
<a href="#l1.697"></a><span id="l1.697">  */</span>
<a href="#l1.698"></a><span id="l1.698"> function wait_for_blank_content_pane(aController) {</span>
<a href="#l1.699"></a><span id="l1.699">   if (aController === undefined)</span>
<a href="#l1.700"></a><span id="l1.700">     aController = mc;</span>
<a href="#l1.701"></a><span id="l1.701"> </span>
<a href="#l1.702"></a><span id="l1.702">   let isBlankChecker = function() {</span>
<a href="#l1.703"></a><span id="l1.703">     return aController.window.content.location.href == &quot;about:blank&quot;;</span>
<a href="#l1.704"></a><span id="l1.704">   };</span>
<a href="#l1.705"></a><span id="l1.705" class="difflineminus">-  controller.waitForEval('subject()',</span>
<a href="#l1.706"></a><span id="l1.706" class="difflineminus">-                         NORMAL_TIMEOUT,</span>
<a href="#l1.707"></a><span id="l1.707" class="difflineminus">-                         FAST_INTERVAL, isBlankChecker);</span>
<a href="#l1.708"></a><span id="l1.708" class="difflineplus">+  if (!controller.waitForEval('subject()', NORMAL_TIMEOUT, FAST_INTERVAL,</span>
<a href="#l1.709"></a><span id="l1.709" class="difflineplus">+                              isBlankChecker))</span>
<a href="#l1.710"></a><span id="l1.710" class="difflineplus">+    mark_failure([&quot;Timeout waiting for blank content pane.  Current location:&quot;,</span>
<a href="#l1.711"></a><span id="l1.711" class="difflineplus">+                  aController.window.content.location.href]);</span>
<a href="#l1.712"></a><span id="l1.712">   // the above may return immediately, meaning the event queue might not get a</span>
<a href="#l1.713"></a><span id="l1.713">   //  chance.  give it a chance now.</span>
<a href="#l1.714"></a><span id="l1.714">   aController.sleep(0);</span>
<a href="#l1.715"></a><span id="l1.715"> }</span>
<a href="#l1.716"></a><span id="l1.716"> </span>
<a href="#l1.717"></a><span id="l1.717"> </span>
<a href="#l1.718"></a><span id="l1.718"> var FolderListener = {</span>
<a href="#l1.719"></a><span id="l1.719">   _inited: false,</span>
<a href="#l1.720"></a><span id="l1.720" class="difflineat">@@ -1329,18 +1406,19 @@ var FolderListener = {</span>
<a href="#l1.721"></a><span id="l1.721">     this.sawEvents = false;</span>
<a href="#l1.722"></a><span id="l1.722">     this.watchingFor = [];</span>
<a href="#l1.723"></a><span id="l1.723">     for (let i = 0; i &lt; arguments.length; i++)</span>
<a href="#l1.724"></a><span id="l1.724">       this.watchingFor[i] = arguments[i];</span>
<a href="#l1.725"></a><span id="l1.725">   },</span>
<a href="#l1.726"></a><span id="l1.726">   waitForEvents: function FolderListener_waitForEvents() {</span>
<a href="#l1.727"></a><span id="l1.727">     if (this.sawEvents)</span>
<a href="#l1.728"></a><span id="l1.728">       return;</span>
<a href="#l1.729"></a><span id="l1.729" class="difflineminus">-    controller.waitForEval('subject.sawEvents', NORMAL_TIMEOUT,</span>
<a href="#l1.730"></a><span id="l1.730" class="difflineminus">-                           FAST_INTERVAL, this);</span>
<a href="#l1.731"></a><span id="l1.731" class="difflineplus">+    if (!controller.waitForEval('subject.sawEvents', NORMAL_TIMEOUT,</span>
<a href="#l1.732"></a><span id="l1.732" class="difflineplus">+                                FAST_INTERVAL, this))</span>
<a href="#l1.733"></a><span id="l1.733" class="difflineplus">+      mark_failure([&quot;Timeout waiting for events:&quot;, this.watchingFor]);</span>
<a href="#l1.734"></a><span id="l1.734">   },</span>
<a href="#l1.735"></a><span id="l1.735"> </span>
<a href="#l1.736"></a><span id="l1.736">   OnItemEvent: function FolderNotificationHelper_OnItemEvent(</span>
<a href="#l1.737"></a><span id="l1.737">       aFolder, aEvent) {</span>
<a href="#l1.738"></a><span id="l1.738">     if (!this.watchingFor)</span>
<a href="#l1.739"></a><span id="l1.739">       return;</span>
<a href="#l1.740"></a><span id="l1.740">     if (this.watchingFor.indexOf(aEvent.toString()) != -1) {</span>
<a href="#l1.741"></a><span id="l1.741">       this.watchingFor = null;</span>
<a href="#l1.742"></a><span id="l1.742" class="difflineat">@@ -1391,19 +1469,19 @@ function assert_messages_in_view(aSynSet</span>
<a href="#l1.743"></a><span id="l1.743">  */</span>
<a href="#l1.744"></a><span id="l1.744"> function assert_messages_not_in_view(aMessages, aController) {</span>
<a href="#l1.745"></a><span id="l1.745">   if (aController === undefined)</span>
<a href="#l1.746"></a><span id="l1.746">     aController = mc;</span>
<a href="#l1.747"></a><span id="l1.747">   if (aMessages instanceof Ci.nsIMsgDBHdr)</span>
<a href="#l1.748"></a><span id="l1.748">     aMessages = [aMessages];</span>
<a href="#l1.749"></a><span id="l1.749">   for each (let [, msgHdr] in Iterator(aMessages)) {</span>
<a href="#l1.750"></a><span id="l1.750">     if (mc.dbView.findIndexOfMsgHdr(msgHdr, true) != nsMsgViewIndex_None)</span>
<a href="#l1.751"></a><span id="l1.751" class="difflineminus">-      throw new Error(&quot;Message header is present in view but should not be: &quot; +</span>
<a href="#l1.752"></a><span id="l1.752" class="difflineminus">-                       msgHdr.mime2DecodedSubject + &quot; index: &quot; +</span>
<a href="#l1.753"></a><span id="l1.753" class="difflineminus">-                       mc.dbView.findIndexOfMsgHdr(msgHdr, true));</span>
<a href="#l1.754"></a><span id="l1.754" class="difflineplus">+      mark_failure([&quot;Message header is present in view but should not be:&quot;,</span>
<a href="#l1.755"></a><span id="l1.755" class="difflineplus">+                    msgHdr, &quot;index:&quot;,</span>
<a href="#l1.756"></a><span id="l1.756" class="difflineplus">+                    mc.dbView.findIndexOfMsgHdr(msgHdr, true)]);</span>
<a href="#l1.757"></a><span id="l1.757">   }</span>
<a href="#l1.758"></a><span id="l1.758"> }</span>
<a href="#l1.759"></a><span id="l1.759"> var assert_message_not_in_view = assert_messages_not_in_view;</span>
<a href="#l1.760"></a><span id="l1.760"> </span>
<a href="#l1.761"></a><span id="l1.761"> /**</span>
<a href="#l1.762"></a><span id="l1.762">  * When displaying a folder, assert that the message pane is visible and all the</span>
<a href="#l1.763"></a><span id="l1.763">  *  menus, splitters, etc. are set up right.</span>
<a href="#l1.764"></a><span id="l1.764">  */</span>
<a href="#l1.765"></a><span id="l1.765" class="difflineat">@@ -1576,18 +1654,18 @@ function assert_selected() {</span>
<a href="#l1.766"></a><span id="l1.766">   let [troller, desiredIndices] =</span>
<a href="#l1.767"></a><span id="l1.767">     _process_row_message_arguments.apply(this, arguments);</span>
<a href="#l1.768"></a><span id="l1.768"> </span>
<a href="#l1.769"></a><span id="l1.769">   // - get the actual selection (already sorted by integer value)</span>
<a href="#l1.770"></a><span id="l1.770">   let selectedIndices = troller.folderDisplay.selectedIndices;</span>
<a href="#l1.771"></a><span id="l1.771">   // - test selection equivalence</span>
<a href="#l1.772"></a><span id="l1.772">   // which is the same as string equivalence in this case. muah hah hah.</span>
<a href="#l1.773"></a><span id="l1.773">   if (desiredIndices.toString() != selectedIndices.toString())</span>
<a href="#l1.774"></a><span id="l1.774" class="difflineminus">-    throw new Error(&quot;Desired selection is: &quot; + desiredIndices + &quot; but actual &quot; +</span>
<a href="#l1.775"></a><span id="l1.775" class="difflineminus">-                    &quot;selection is: &quot; + selectedIndices);</span>
<a href="#l1.776"></a><span id="l1.776" class="difflineplus">+    mark_failure([&quot;Desired selection is:&quot;, desiredIndices,</span>
<a href="#l1.777"></a><span id="l1.777" class="difflineplus">+                  &quot;but actual selection is: &quot;, selectedIndices]);</span>
<a href="#l1.778"></a><span id="l1.778"> </span>
<a href="#l1.779"></a><span id="l1.779">   return [troller, desiredIndices];</span>
<a href="#l1.780"></a><span id="l1.780"> }</span>
<a href="#l1.781"></a><span id="l1.781"> </span>
<a href="#l1.782"></a><span id="l1.782"> /**</span>
<a href="#l1.783"></a><span id="l1.783">  * Assert that the given set of messages is displayed, but not necessarily</span>
<a href="#l1.784"></a><span id="l1.784">  *  selected.  Unless you are dealing with transient selection issues or some</span>
<a href="#l1.785"></a><span id="l1.785">  *  other situation where the FolderDisplay should not be correlated with the</span>
<a href="#l1.786"></a><span id="l1.786" class="difflineat">@@ -1837,16 +1915,19 @@ function assert_expanded() {</span>
<a href="#l1.787"></a><span id="l1.787">  *     get from getElementById.</span>
<a href="#l1.788"></a><span id="l1.788">  * @param aElementId The id attribute of the toolbaritem item you want added to</span>
<a href="#l1.789"></a><span id="l1.789">  *     the toolbar (not the id of the thing inside the toolbaritem tag!).</span>
<a href="#l1.790"></a><span id="l1.790">  *     We take the id name rather than element itself because if not already</span>
<a href="#l1.791"></a><span id="l1.791">  *     present the element is off floating in DOM limbo.  (The toolbar widget</span>
<a href="#l1.792"></a><span id="l1.792">  *     calls removeChild on the palette.)</span>
<a href="#l1.793"></a><span id="l1.793">  */</span>
<a href="#l1.794"></a><span id="l1.794"> function add_to_toolbar(aToolbarElement, aElementId) {</span>
<a href="#l1.795"></a><span id="l1.795" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;add_to_toolbar&quot;,</span>
<a href="#l1.796"></a><span id="l1.796" class="difflineplus">+              [&quot;adding&quot;, aElementId,</span>
<a href="#l1.797"></a><span id="l1.797" class="difflineplus">+               &quot;current set&quot;, aToolbarElement.currentSet]);</span>
<a href="#l1.798"></a><span id="l1.798">   let currentSet = aToolbarElement.currentSet.split(&quot;,&quot;);</span>
<a href="#l1.799"></a><span id="l1.799">   if (currentSet.indexOf(aElementId) == -1) {</span>
<a href="#l1.800"></a><span id="l1.800">     currentSet.unshift(aElementId);</span>
<a href="#l1.801"></a><span id="l1.801">     aToolbarElement.currentSet = currentSet.join(&quot;,&quot;);</span>
<a href="#l1.802"></a><span id="l1.802">   }</span>
<a href="#l1.803"></a><span id="l1.803"> }</span>
<a href="#l1.804"></a><span id="l1.804"> </span>
<a href="#l1.805"></a><span id="l1.805"> /**</span>
<a href="#l1.806"></a><span id="l1.806" class="difflineat">@@ -1854,16 +1935,19 @@ function add_to_toolbar(aToolbarElement,</span>
<a href="#l1.807"></a><span id="l1.807">  *  |add_to_toolbar| to add the item in the first place.</span>
<a href="#l1.808"></a><span id="l1.808">  *</span>
<a href="#l1.809"></a><span id="l1.809">  * @param aToolbarElement The DOM element that is the toolbar, like you would</span>
<a href="#l1.810"></a><span id="l1.810">  *     get from getElementById.</span>
<a href="#l1.811"></a><span id="l1.811">  * @param aElementId The id attribute of the item you want removed to the</span>
<a href="#l1.812"></a><span id="l1.812">  *     toolbar.</span>
<a href="#l1.813"></a><span id="l1.813">  */</span>
<a href="#l1.814"></a><span id="l1.814"> function remove_from_toolbar(aToolbarElement, aElementId) {</span>
<a href="#l1.815"></a><span id="l1.815" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;remove_from_toolbar&quot;,</span>
<a href="#l1.816"></a><span id="l1.816" class="difflineplus">+              [&quot;removing&quot;, aElementId,</span>
<a href="#l1.817"></a><span id="l1.817" class="difflineplus">+               &quot;current set&quot;, aToolbarElement.currentSet]);</span>
<a href="#l1.818"></a><span id="l1.818">   let currentSet = aToolbarElement.currentSet.split(&quot;,&quot;);</span>
<a href="#l1.819"></a><span id="l1.819">   if (currentSet.indexOf(aElementId) != -1) {</span>
<a href="#l1.820"></a><span id="l1.820">     currentSet.splice(currentSet.indexOf(aElementId), 1);</span>
<a href="#l1.821"></a><span id="l1.821">     aToolbarElement.currentSet = currentSet.join(&quot;,&quot;);</span>
<a href="#l1.822"></a><span id="l1.822">   }</span>
<a href="#l1.823"></a><span id="l1.823"> }</span>
<a href="#l1.824"></a><span id="l1.824"> </span>
<a href="#l1.825"></a><span id="l1.825"> var RECOGNIZED_WINDOWS = [&quot;messagepane&quot;, &quot;multimessage&quot;];</span>
<a href="#l1.826"></a><span id="l1.826" class="difflineat">@@ -2089,19 +2173,18 @@ let assert_folder_selected = assert_fold</span>
<a href="#l1.827"></a><span id="l1.827">  *</span>
<a href="#l1.828"></a><span id="l1.828">  * In each case, since we can only have one folder displayed, we only look at</span>
<a href="#l1.829"></a><span id="l1.829">  * the first folder you pass in.</span>
<a href="#l1.830"></a><span id="l1.830">  */</span>
<a href="#l1.831"></a><span id="l1.831"> function assert_folder_displayed() {</span>
<a href="#l1.832"></a><span id="l1.832">   let [troller, desiredFolders] =</span>
<a href="#l1.833"></a><span id="l1.833">     _process_row_folder_arguments.apply(this, arguments);</span>
<a href="#l1.834"></a><span id="l1.834">   if (troller.folderDisplay.displayedFolder != desiredFolders[0])</span>
<a href="#l1.835"></a><span id="l1.835" class="difflineminus">-    throw new Error(&quot;The displayed folder should be &quot; +</span>
<a href="#l1.836"></a><span id="l1.836" class="difflineminus">-        desiredFolders[0].prettiestName + &quot;, but is actually &quot; +</span>
<a href="#l1.837"></a><span id="l1.837" class="difflineminus">-        troller.folderDisplay.displayedFolder.prettiestName);</span>
<a href="#l1.838"></a><span id="l1.838" class="difflineplus">+    mark_failure([&quot;The displayed folder should be&quot;, desiredFolders[0],</span>
<a href="#l1.839"></a><span id="l1.839" class="difflineplus">+                  &quot;but is actually&quot;, troller.folderDisplay.displayedFolder]);</span>
<a href="#l1.840"></a><span id="l1.840"> }</span>
<a href="#l1.841"></a><span id="l1.841"> </span>
<a href="#l1.842"></a><span id="l1.842"> /**</span>
<a href="#l1.843"></a><span id="l1.843">  * Asserts that the folders corresponding to the one or more folder spec</span>
<a href="#l1.844"></a><span id="l1.844">  * arguments are selected and displayed. If you specify multiple folders,</span>
<a href="#l1.845"></a><span id="l1.845">  * we verify that all of them are selected and that the first folder you pass</span>
<a href="#l1.846"></a><span id="l1.846">  * in is the one displayed. (If you don't pass in any folders, we can't assume</span>
<a href="#l1.847"></a><span id="l1.847">  * anything, so we don't test that case.)</span>
<a href="#l1.848"></a><span id="l1.848" class="difflineat">@@ -2114,19 +2197,19 @@ function assert_folder_displayed() {</span>
<a href="#l1.849"></a><span id="l1.849">  * - An nsIMsgFolder.</span>
<a href="#l1.850"></a><span id="l1.850">  * - A list of nsIMsgFolders.</span>
<a href="#l1.851"></a><span id="l1.851">  */</span>
<a href="#l1.852"></a><span id="l1.852"> function assert_folders_selected_and_displayed() {</span>
<a href="#l1.853"></a><span id="l1.853">   let [troller, desiredFolders] = assert_folders_selected.apply(this,</span>
<a href="#l1.854"></a><span id="l1.854">                                                                 arguments);</span>
<a href="#l1.855"></a><span id="l1.855">   if (desiredFolders.length &gt; 0) {</span>
<a href="#l1.856"></a><span id="l1.856">       if (troller.folderDisplay.displayedFolder != desiredFolders[0])</span>
<a href="#l1.857"></a><span id="l1.857" class="difflineminus">-        throw new Error(&quot;The displayed folder should be &quot; +</span>
<a href="#l1.858"></a><span id="l1.858" class="difflineminus">-            desiredFolders[0].prettiestName + &quot;, but is actually &quot; +</span>
<a href="#l1.859"></a><span id="l1.859" class="difflineminus">-            troller.folderDisplay.displayedFolder.prettiestName);</span>
<a href="#l1.860"></a><span id="l1.860" class="difflineplus">+        mark_failure([&quot;The displayed folder should be&quot;, desiredFolders[0],</span>
<a href="#l1.861"></a><span id="l1.861" class="difflineplus">+                      &quot;but is actually&quot;,</span>
<a href="#l1.862"></a><span id="l1.862" class="difflineplus">+                      troller.folderDisplay.displayedFolder]);</span>
<a href="#l1.863"></a><span id="l1.863">   }</span>
<a href="#l1.864"></a><span id="l1.864"> }</span>
<a href="#l1.865"></a><span id="l1.865"> </span>
<a href="#l1.866"></a><span id="l1.866"> let assert_no_folders_selected = assert_folders_selected_and_displayed;</span>
<a href="#l1.867"></a><span id="l1.867"> let assert_folder_selected_and_displayed =</span>
<a href="#l1.868"></a><span id="l1.868">     assert_folders_selected_and_displayed;</span>
<a href="#l1.869"></a><span id="l1.869"> </span>
<a href="#l1.870"></a><span id="l1.870"> /**</span>
<a href="#l1.871"></a><span id="l1.871" class="difflineat">@@ -2154,56 +2237,61 @@ function _prettify_folder_array(aArray) </span>
<a href="#l1.872"></a><span id="l1.872">   return aArray.map(function (folder) folder.prettiestName).join(&quot;, &quot;);</span>
<a href="#l1.873"></a><span id="l1.873"> }</span>
<a href="#l1.874"></a><span id="l1.874"> </span>
<a href="#l1.875"></a><span id="l1.875"> /**</span>
<a href="#l1.876"></a><span id="l1.876">  * Put the view in unthreaded mode.</span>
<a href="#l1.877"></a><span id="l1.877">  */</span>
<a href="#l1.878"></a><span id="l1.878"> function make_display_unthreaded() {</span>
<a href="#l1.879"></a><span id="l1.879">   wait_for_message_display_completion();</span>
<a href="#l1.880"></a><span id="l1.880" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;make_folder_display_unthreaded&quot;, []);</span>
<a href="#l1.881"></a><span id="l1.881">   mc.folderDisplay.view.showUnthreaded = true;</span>
<a href="#l1.882"></a><span id="l1.882">   // drain event queue</span>
<a href="#l1.883"></a><span id="l1.883">   mc.sleep(0);</span>
<a href="#l1.884"></a><span id="l1.884"> }</span>
<a href="#l1.885"></a><span id="l1.885"> </span>
<a href="#l1.886"></a><span id="l1.886"> /**</span>
<a href="#l1.887"></a><span id="l1.887">  * Put the view in threaded mode.</span>
<a href="#l1.888"></a><span id="l1.888">  */</span>
<a href="#l1.889"></a><span id="l1.889"> function make_display_threaded() {</span>
<a href="#l1.890"></a><span id="l1.890">   wait_for_message_display_completion();</span>
<a href="#l1.891"></a><span id="l1.891" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;make_folder_display_threaded&quot;, []);</span>
<a href="#l1.892"></a><span id="l1.892">   mc.folderDisplay.view.showThreaded = true;</span>
<a href="#l1.893"></a><span id="l1.893">   // drain event queue</span>
<a href="#l1.894"></a><span id="l1.894">   mc.sleep(0);</span>
<a href="#l1.895"></a><span id="l1.895"> }</span>
<a href="#l1.896"></a><span id="l1.896"> </span>
<a href="#l1.897"></a><span id="l1.897"> /**</span>
<a href="#l1.898"></a><span id="l1.898">  * Put the view in group-by-sort mode.</span>
<a href="#l1.899"></a><span id="l1.899">  */</span>
<a href="#l1.900"></a><span id="l1.900"> function make_display_grouped() {</span>
<a href="#l1.901"></a><span id="l1.901">   wait_for_message_display_completion();</span>
<a href="#l1.902"></a><span id="l1.902" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;make_folder_display_grouped&quot;, []);</span>
<a href="#l1.903"></a><span id="l1.903">   mc.folderDisplay.view.showGroupedBySort = true;</span>
<a href="#l1.904"></a><span id="l1.904">   // drain event queue</span>
<a href="#l1.905"></a><span id="l1.905">   mc.sleep(0);</span>
<a href="#l1.906"></a><span id="l1.906"> }</span>
<a href="#l1.907"></a><span id="l1.907"> </span>
<a href="#l1.908"></a><span id="l1.908"> /**</span>
<a href="#l1.909"></a><span id="l1.909">  * Collapse all threads in the current view.</span>
<a href="#l1.910"></a><span id="l1.910">  */</span>
<a href="#l1.911"></a><span id="l1.911"> function collapse_all_threads() {</span>
<a href="#l1.912"></a><span id="l1.912">   wait_for_message_display_completion();</span>
<a href="#l1.913"></a><span id="l1.913" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;collapse_all_threads&quot;, []);</span>
<a href="#l1.914"></a><span id="l1.914">   mc.folderDisplay.doCommand(Ci.nsMsgViewCommandType.collapseAll);</span>
<a href="#l1.915"></a><span id="l1.915">   // drain event queue</span>
<a href="#l1.916"></a><span id="l1.916">   mc.sleep(0);</span>
<a href="#l1.917"></a><span id="l1.917"> }</span>
<a href="#l1.918"></a><span id="l1.918"> </span>
<a href="#l1.919"></a><span id="l1.919"> /**</span>
<a href="#l1.920"></a><span id="l1.920">  * Set whether to show unread messages only in the current view.</span>
<a href="#l1.921"></a><span id="l1.921">  */</span>
<a href="#l1.922"></a><span id="l1.922"> function set_show_unread_only(aShowUnreadOnly) {</span>
<a href="#l1.923"></a><span id="l1.923">   wait_for_message_display_completion();</span>
<a href="#l1.924"></a><span id="l1.924" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;set_show_unread_only&quot;, [aShowUnreadOnly]);</span>
<a href="#l1.925"></a><span id="l1.925">   mc.folderDisplay.view.showUnreadOnly = aShowUnreadOnly;</span>
<a href="#l1.926"></a><span id="l1.926">   wait_for_all_messages_to_load();</span>
<a href="#l1.927"></a><span id="l1.927">   wait_for_message_display_completion();</span>
<a href="#l1.928"></a><span id="l1.928">   // drain event queue</span>
<a href="#l1.929"></a><span id="l1.929">   mc.sleep(0);</span>
<a href="#l1.930"></a><span id="l1.930"> }</span>
<a href="#l1.931"></a><span id="l1.931"> </span>
<a href="#l1.932"></a><span id="l1.932"> /**</span>
<a href="#l1.933"></a><span id="l1.933" class="difflineat">@@ -2227,16 +2315,18 @@ function assert_not_showing_unread_only(</span>
<a href="#l1.934"></a><span id="l1.934"> }</span>
<a href="#l1.935"></a><span id="l1.935"> </span>
<a href="#l1.936"></a><span id="l1.936"> /**</span>
<a href="#l1.937"></a><span id="l1.937">  * Set the mail view filter for the current view. The aData parameter is for</span>
<a href="#l1.938"></a><span id="l1.938">  * tags (e.g. you can specify &quot;$label1&quot; for the first tag).</span>
<a href="#l1.939"></a><span id="l1.939">  */</span>
<a href="#l1.940"></a><span id="l1.940"> function set_mail_view(aMailViewIndex, aData) {</span>
<a href="#l1.941"></a><span id="l1.941">   wait_for_message_display_completion();</span>
<a href="#l1.942"></a><span id="l1.942" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;set_mail_view&quot;,</span>
<a href="#l1.943"></a><span id="l1.943" class="difflineplus">+              [&quot;index&quot;, aMailViewIndex, &quot;mail view data&quot;, aData]);</span>
<a href="#l1.944"></a><span id="l1.944">   mc.folderDisplay.view.setMailView(aMailViewIndex, aData);</span>
<a href="#l1.945"></a><span id="l1.945">   wait_for_all_messages_to_load();</span>
<a href="#l1.946"></a><span id="l1.946">   wait_for_message_display_completion();</span>
<a href="#l1.947"></a><span id="l1.947">   // drain event queue</span>
<a href="#l1.948"></a><span id="l1.948">   mc.sleep(0);</span>
<a href="#l1.949"></a><span id="l1.949"> }</span>
<a href="#l1.950"></a><span id="l1.950"> </span>
<a href="#l1.951"></a><span id="l1.951"> /**</span>
<a href="#l1.952"></a><span id="l1.952" class="difflineat">@@ -2255,16 +2345,17 @@ function assert_mail_view(aMailViewIndex</span>
<a href="#l1.953"></a><span id="l1.953">                     &quot;, but is actually &quot; + actualMailViewData);</span>
<a href="#l1.954"></a><span id="l1.954"> }</span>
<a href="#l1.955"></a><span id="l1.955"> </span>
<a href="#l1.956"></a><span id="l1.956"> /**</span>
<a href="#l1.957"></a><span id="l1.957">  * Expand all threads in the current view.</span>
<a href="#l1.958"></a><span id="l1.958">  */</span>
<a href="#l1.959"></a><span id="l1.959"> function expand_all_threads() {</span>
<a href="#l1.960"></a><span id="l1.960">   wait_for_message_display_completion();</span>
<a href="#l1.961"></a><span id="l1.961" class="difflineplus">+  mark_action(&quot;fdh&quot;, &quot;expand_all_threads&quot;, []);</span>
<a href="#l1.962"></a><span id="l1.962">   mc.folderDisplay.doCommand(Ci.nsMsgViewCommandType.expandAll);</span>
<a href="#l1.963"></a><span id="l1.963">   // drain event queue</span>
<a href="#l1.964"></a><span id="l1.964">   mc.sleep(0);</span>
<a href="#l1.965"></a><span id="l1.965"> }</span>
<a href="#l1.966"></a><span id="l1.966"> </span>
<a href="#l1.967"></a><span id="l1.967"> /**</span>
<a href="#l1.968"></a><span id="l1.968">  * Set the mail.openMessageBehavior pref.</span>
<a href="#l1.969"></a><span id="l1.969">  *</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mail/test/mozmill/shared-modules/test-window-helpers.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mail/test/mozmill/shared-modules/test-window-helpers.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -175,29 +175,28 @@ var WindowWatcher = {</span>
<a href="#l2.4"></a><span id="l2.4">   waitingForOpen: null,</span>
<a href="#l2.5"></a><span id="l2.5">   /**</span>
<a href="#l2.6"></a><span id="l2.6">    * Wait for the given windowType to open and finish loading.</span>
<a href="#l2.7"></a><span id="l2.7">    *</span>
<a href="#l2.8"></a><span id="l2.8">    * @return The window wrapped in a MozMillController.</span>
<a href="#l2.9"></a><span id="l2.9">    */</span>
<a href="#l2.10"></a><span id="l2.10">   waitForWindowOpen: function WindowWatcher_waitForWindowOpen(aWindowType) {</span>
<a href="#l2.11"></a><span id="l2.11">     this.waitingForOpen = aWindowType;</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-    controller.waitForEval(</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineminus">-      'subject.monitorizeOpen()',</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineminus">-      this._firstWindowOpened ? WINDOW_OPEN_TIMEOUT_MS</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineminus">-                              : FIRST_WINDOW_EVER_TIMEOUT_MS,</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineminus">-      this._firstWindowOpened ? WINDOW_OPEN_CHECK_INTERVAL_MS</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineminus">-                              : FIRST_WINDOW_CHECK_INTERVAL_MS,</span>
<a href="#l2.18"></a><span id="l2.18" class="difflineminus">-      this);</span>
<a href="#l2.19"></a><span id="l2.19" class="difflineplus">+    if (!controller.waitForEval(</span>
<a href="#l2.20"></a><span id="l2.20" class="difflineplus">+          'subject.monitorizeOpen()',</span>
<a href="#l2.21"></a><span id="l2.21" class="difflineplus">+          this._firstWindowOpened ? WINDOW_OPEN_TIMEOUT_MS</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineplus">+            : FIRST_WINDOW_EVER_TIMEOUT_MS,</span>
<a href="#l2.23"></a><span id="l2.23" class="difflineplus">+          this._firstWindowOpened ? WINDOW_OPEN_CHECK_INTERVAL_MS</span>
<a href="#l2.24"></a><span id="l2.24" class="difflineplus">+            : FIRST_WINDOW_CHECK_INTERVAL_MS,</span>
<a href="#l2.25"></a><span id="l2.25" class="difflineplus">+          this))</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineplus">+      throw new Error(&quot;Timed out waiting for window open!&quot;);</span>
<a href="#l2.27"></a><span id="l2.27">     this.waitingForOpen = null;</span>
<a href="#l2.28"></a><span id="l2.28">     let xulWindow = this.waitingList[aWindowType];</span>
<a href="#l2.29"></a><span id="l2.29" class="difflineminus">-dump(&quot;### XUL window: &quot; + xulWindow + &quot;\n&quot;);</span>
<a href="#l2.30"></a><span id="l2.30">     let domWindow = xulWindow.docShell.QueryInterface(Ci.nsIInterfaceRequestor)</span>
<a href="#l2.31"></a><span id="l2.31">                                       .getInterface(Ci.nsIDOMWindowInternal);</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineminus">-dump(&quot;domWindow: &quot; + domWindow + &quot;\n&quot;);</span>
<a href="#l2.33"></a><span id="l2.33">     delete this.waitingList[aWindowType];</span>
<a href="#l2.34"></a><span id="l2.34">     // spin the event loop to make sure any setTimeout 0 calls have gotten their</span>
<a href="#l2.35"></a><span id="l2.35">     //  time in the sun.</span>
<a href="#l2.36"></a><span id="l2.36">     controller.sleep(0);</span>
<a href="#l2.37"></a><span id="l2.37">     this._firstWindowOpened = true;</span>
<a href="#l2.38"></a><span id="l2.38">     return new controller.MozMillController(domWindow);</span>
<a href="#l2.39"></a><span id="l2.39">   },</span>
<a href="#l2.40"></a><span id="l2.40"> </span>
<a href="#l2.41"></a><span id="l2.41" class="difflineat">@@ -288,19 +287,20 @@ dump(&quot;canceled!\n&quot;);</span>
<a href="#l2.42"></a><span id="l2.42">    * Symmetry for planForModalDialog; conceptually provides the waiting.  In</span>
<a href="#l2.43"></a><span id="l2.43">    *  reality, all we do is potentially soak up the event loop a little to</span>
<a href="#l2.44"></a><span id="l2.44">    */</span>
<a href="#l2.45"></a><span id="l2.45">   waitForModalDialog: function WindowWatcher_waitForModalDialog(aWindowType) {</span>
<a href="#l2.46"></a><span id="l2.46">     // did the window already come and go?</span>
<a href="#l2.47"></a><span id="l2.47">     if (this.subTestFunc == null)</span>
<a href="#l2.48"></a><span id="l2.48">       return;</span>
<a href="#l2.49"></a><span id="l2.49">     // spin the event loop until we the window has come and gone.</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineminus">-    controller.waitForEval(</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineminus">-      'subject.waitingForOpen == null &amp;&amp; subject.monitorizeClose()',</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineminus">-      WINDOW_OPEN_TIMEOUT_MS, WINDOW_OPEN_CHECK_INTERVAL_MS, this);</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineplus">+    if (!controller.waitForEval(</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineplus">+           'subject.waitingForOpen == null &amp;&amp; subject.monitorizeClose()',</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+            WINDOW_OPEN_TIMEOUT_MS, WINDOW_OPEN_CHECK_INTERVAL_MS, this))</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+      throw new Error(&quot;Timeout waiting for modal dialog to open.&quot;);</span>
<a href="#l2.57"></a><span id="l2.57">     this.waitingForClose = null;</span>
<a href="#l2.58"></a><span id="l2.58">   },</span>
<a href="#l2.59"></a><span id="l2.59"> </span>
<a href="#l2.60"></a><span id="l2.60">   planForWindowClose: function WindowWatcher_planForWindowClose(aXULWindow) {</span>
<a href="#l2.61"></a><span id="l2.61">     let windowType =</span>
<a href="#l2.62"></a><span id="l2.62">       aXULWindow.document.documentElement.getAttribute(&quot;windowtype&quot;) ||</span>
<a href="#l2.63"></a><span id="l2.63">       aXULWindow.document.documentElement.getAttribute(&quot;id&quot;);</span>
<a href="#l2.64"></a><span id="l2.64">     this.waitingList[windowType] = aXULWindow;</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineat">@@ -308,19 +308,20 @@ dump(&quot;canceled!\n&quot;);</span>
<a href="#l2.66"></a><span id="l2.66">   },</span>
<a href="#l2.67"></a><span id="l2.67"> </span>
<a href="#l2.68"></a><span id="l2.68">   /**</span>
<a href="#l2.69"></a><span id="l2.69">    * The current windowType we are waiting to close.  Same deal as</span>
<a href="#l2.70"></a><span id="l2.70">    *  waitingForOpen, this makes the eval less crazy.</span>
<a href="#l2.71"></a><span id="l2.71">    */</span>
<a href="#l2.72"></a><span id="l2.72">   waitingForClose: null,</span>
<a href="#l2.73"></a><span id="l2.73">   waitForWindowClose: function WindowWatcher_waitForWindowClose() {</span>
<a href="#l2.74"></a><span id="l2.74" class="difflineminus">-    controller.waitForEval('subject.monitorizeClose()',</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineminus">-                           WINDOW_CLOSE_TIMEOUT_MS,</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineminus">-                           WINDOW_CLOSE_CHECK_INTERVAL_MS, this);</span>
<a href="#l2.77"></a><span id="l2.77" class="difflineplus">+    if (!controller.waitForEval('subject.monitorizeClose()',</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineplus">+                                WINDOW_CLOSE_TIMEOUT_MS,</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineplus">+                                WINDOW_CLOSE_CHECK_INTERVAL_MS, this))</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineplus">+      throw new Error(&quot;Timeout waiting for window to close!&quot;);</span>
<a href="#l2.81"></a><span id="l2.81">     let didDisappear = this.waitingList[this.waitingForClose] == null;</span>
<a href="#l2.82"></a><span id="l2.82">     delete this.waitingList[windowType];</span>
<a href="#l2.83"></a><span id="l2.83">     let windowType = this.waitingForClose;</span>
<a href="#l2.84"></a><span id="l2.84">     this.waitingForClose = null;</span>
<a href="#l2.85"></a><span id="l2.85">     if (!didDisappear)</span>
<a href="#l2.86"></a><span id="l2.86">       throw new Error(windowType + &quot; window did not disappear!&quot;);</span>
<a href="#l2.87"></a><span id="l2.87">   },</span>
<a href="#l2.88"></a><span id="l2.88"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/db/gloda/modules/connotent.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/connotent.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -15,17 +15,17 @@</span>
<a href="#l3.4"></a><span id="l3.4">  *</span>
<a href="#l3.5"></a><span id="l3.5">  * The Initial Developer of the Original Code is</span>
<a href="#l3.6"></a><span id="l3.6">  * Mozilla Messaging, Inc.</span>
<a href="#l3.7"></a><span id="l3.7">  * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l3.8"></a><span id="l3.8">  * the Initial Developer. All Rights Reserved.</span>
<a href="#l3.9"></a><span id="l3.9">  *</span>
<a href="#l3.10"></a><span id="l3.10">  * Contributor(s):</span>
<a href="#l3.11"></a><span id="l3.11">  *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">- *   David Ascerh &lt;dascher@mozillamessaging.com&gt;</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+ *   David Ascher &lt;dascher@mozillamessaging.com&gt;</span>
<a href="#l3.14"></a><span id="l3.14">  *</span>
<a href="#l3.15"></a><span id="l3.15">  * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l3.16"></a><span id="l3.16">  * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l3.17"></a><span id="l3.17">  * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l3.18"></a><span id="l3.18">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l3.19"></a><span id="l3.19">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l3.20"></a><span id="l3.20">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l3.21"></a><span id="l3.21">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineat">@@ -81,17 +81,17 @@ function mimeMsgToContentAndMeta(aMimeMs</span>
<a href="#l3.23"></a><span id="l3.23">  * If the actual length of the message is greater than |length|, then the return</span>
<a href="#l3.24"></a><span id="l3.24">  * value is the first (length-1) characters with an ellipsis appended.</span>
<a href="#l3.25"></a><span id="l3.25">  * @return an array containing the text of the snippet, and the meta dictionary</span>
<a href="#l3.26"></a><span id="l3.26">  * that the Gloda content providers may have filled with useful data.</span>
<a href="#l3.27"></a><span id="l3.27">  */</span>
<a href="#l3.28"></a><span id="l3.28"> </span>
<a href="#l3.29"></a><span id="l3.29"> function mimeMsgToContentSnippetAndMeta(aMimeMsg, folder, length) {</span>
<a href="#l3.30"></a><span id="l3.30">   let [content, meta] = mimeMsgToContentAndMeta(aMimeMsg, folder);</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineminus">-  </span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+</span>
<a href="#l3.33"></a><span id="l3.33">   let text = content.getContentSnippet(length + 1);</span>
<a href="#l3.34"></a><span id="l3.34">   if (length &amp;&amp; text.length &gt; length)</span>
<a href="#l3.35"></a><span id="l3.35">     text = text.substring(0, length-1) + &quot;\u2026&quot;; // ellipsis</span>
<a href="#l3.36"></a><span id="l3.36"> </span>
<a href="#l3.37"></a><span id="l3.37">   return [text, meta];</span>
<a href="#l3.38"></a><span id="l3.38"> }</span>
<a href="#l3.39"></a><span id="l3.39"> </span>
<a href="#l3.40"></a><span id="l3.40"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -58,17 +58,17 @@ load(&quot;../../mailnews/resources/mailDirSe</span>
<a href="#l4.4"></a><span id="l4.4"> load(&quot;../../mailnews/resources/mailTestUtils.js&quot;);</span>
<a href="#l4.5"></a><span id="l4.5"> load(&quot;../../mailnews/resources/logHelper.js&quot;);</span>
<a href="#l4.6"></a><span id="l4.6"> load(&quot;../../mailnews/resources/asyncTestUtils.js&quot;);</span>
<a href="#l4.7"></a><span id="l4.7"> </span>
<a href="#l4.8"></a><span id="l4.8"> load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l4.9"></a><span id="l4.9"> load(&quot;../../mailnews/resources/messageModifier.js&quot;);</span>
<a href="#l4.10"></a><span id="l4.10"> load(&quot;../../mailnews/resources/messageInjection.js&quot;);</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-load(&quot;resources/folderEventLogHelper.js&quot;);</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+load(&quot;../../mailnews/resources/folderEventLogHelper.js&quot;);</span>
<a href="#l4.14"></a><span id="l4.14"> // register this before gloda gets a chance to do anything so that</span>
<a href="#l4.15"></a><span id="l4.15"> registerFolderEventLogHelper();</span>
<a href="#l4.16"></a><span id="l4.16"> </span>
<a href="#l4.17"></a><span id="l4.17"> </span>
<a href="#l4.18"></a><span id="l4.18"> // Create a message generator</span>
<a href="#l4.19"></a><span id="l4.19"> const msgGen = gMessageGenerator = new MessageGenerator();</span>
<a href="#l4.20"></a><span id="l4.20"> // Create a message scenario generator using that message generator</span>
<a href="#l4.21"></a><span id="l4.21"> const scenarios = gMessageScenarioFactory = new MessageScenarioFactory(msgGen);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1">rename from mailnews/db/gloda/test/unit/resources/folderEventLogHelper.js</span>
<a href="#l5.2"></a><span id="l5.2">rename to mailnews/test/resources/folderEventLogHelper.js</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/test/resources/logHelper.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/test/resources/logHelper.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -66,16 +66,21 @@ let _errorConsoleTunnel = {</span>
<a href="#l6.4"></a><span id="l6.4">         (aMessage.errorMessage.indexOf(&quot;Error console says&quot;) == -1) &amp;&amp;</span>
<a href="#l6.5"></a><span id="l6.5">         // MOZILLA_1_9_2_BRANCH fix: gre-resources alias causes an expected</span>
<a href="#l6.6"></a><span id="l6.6">         //  warning that should not cause us to fail.</span>
<a href="#l6.7"></a><span id="l6.7">         (aMessage.errorMessage.indexOf(&quot;Duplicate resource declaration&quot;) == -1))</span>
<a href="#l6.8"></a><span id="l6.8">       mark_failure([&quot;Error console says&quot;, aMessage]);</span>
<a href="#l6.9"></a><span id="l6.9">   }</span>
<a href="#l6.10"></a><span id="l6.10"> };</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+// This defaults to undefined and is for use by test-folder-display-helpers</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+//  so that it can pre-initialize the value so that when we are evaluated in</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+//  its subscript loader we see a value of 'true'.</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+var _do_not_wrap_xpcshell;</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+</span>
<a href="#l6.17"></a><span id="l6.17"> /**</span>
<a href="#l6.18"></a><span id="l6.18">  * Initialize logging.  The idea is to:</span>
<a href="#l6.19"></a><span id="l6.19">  *</span>
<a href="#l6.20"></a><span id="l6.20">  * - Always create a dump appender on 'test'.</span>
<a href="#l6.21"></a><span id="l6.21">  * - Check if there's a desire to use a logsploder style network connection</span>
<a href="#l6.22"></a><span id="l6.22">  *    based on the presence of an appropriate file in 'tmp'.  This should be</span>
<a href="#l6.23"></a><span id="l6.23">  *    harmless in cases where there is not such a file.</span>
<a href="#l6.24"></a><span id="l6.24">  *</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineat">@@ -115,17 +120,18 @@ function _init_log_helper() {</span>
<a href="#l6.26"></a><span id="l6.26"> </span>
<a href="#l6.27"></a><span id="l6.27">   // Create a console listener reporting thinger in all cases.  Since XPCOM</span>
<a href="#l6.28"></a><span id="l6.28">   //  failures will show up via the error console, this allows our test to fail</span>
<a href="#l6.29"></a><span id="l6.29">   //  in more situations where we might otherwise silently be cool with bad</span>
<a href="#l6.30"></a><span id="l6.30">   //  things happening.</span>
<a href="#l6.31"></a><span id="l6.31">   _errorConsoleTunnel.initialize();</span>
<a href="#l6.32"></a><span id="l6.32"> </span>
<a href="#l6.33"></a><span id="l6.33">   if (_logHelperInterestedListeners) {</span>
<a href="#l6.34"></a><span id="l6.34" class="difflineminus">-    _wrap_xpcshell_functions();</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineplus">+    if (!_do_not_wrap_xpcshell)</span>
<a href="#l6.36"></a><span id="l6.36" class="difflineplus">+      _wrap_xpcshell_functions();</span>
<a href="#l6.37"></a><span id="l6.37"> </span>
<a href="#l6.38"></a><span id="l6.38">     // Send a message telling the listeners about the test file being run.</span>
<a href="#l6.39"></a><span id="l6.39">     _xpcshellLogger.info({</span>
<a href="#l6.40"></a><span id="l6.40">       _jsonMe: true,</span>
<a href="#l6.41"></a><span id="l6.41">       _isContext: true,</span>
<a href="#l6.42"></a><span id="l6.42">       _specialContext: &quot;lifecycle&quot;,</span>
<a href="#l6.43"></a><span id="l6.43">       _id: &quot;start&quot;,</span>
<a href="#l6.44"></a><span id="l6.44">       testFile: _TEST_FILE,</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineat">@@ -249,50 +255,58 @@ function _explode_flags(aFlagWord, aFlag</span>
<a href="#l6.46"></a><span id="l6.46">   }</span>
<a href="#l6.47"></a><span id="l6.47"> </span>
<a href="#l6.48"></a><span id="l6.48">   return flagList;</span>
<a href="#l6.49"></a><span id="l6.49"> }</span>
<a href="#l6.50"></a><span id="l6.50"> </span>
<a href="#l6.51"></a><span id="l6.51"> let _registered_json_normalizers = [];</span>
<a href="#l6.52"></a><span id="l6.52"> </span>
<a href="#l6.53"></a><span id="l6.53"> /**</span>
<a href="#l6.54"></a><span id="l6.54" class="difflineminus">- * Like __simple_obj_copy but it does not assume things are objects.  This is</span>
<a href="#l6.55"></a><span id="l6.55" class="difflineminus">- *  used by obj copying for aray copyiong.</span>
<a href="#l6.56"></a><span id="l6.56" class="difflineplus">+ * Copy natives or objects, deferring to _normalize_for_json for objects.</span>
<a href="#l6.57"></a><span id="l6.57">  */</span>
<a href="#l6.58"></a><span id="l6.58" class="difflineminus">-function __simple_value_copy(aObj, aDepthAllowed) {</span>
<a href="#l6.59"></a><span id="l6.59" class="difflineplus">+function __value_copy(aObj, aDepthAllowed) {</span>
<a href="#l6.60"></a><span id="l6.60">   if (aObj == null || typeof(aObj) != &quot;object&quot;)</span>
<a href="#l6.61"></a><span id="l6.61">     return aObj;</span>
<a href="#l6.62"></a><span id="l6.62" class="difflineminus">-  return __simple_obj_copy(aObj, aDepthAllowed);</span>
<a href="#l6.63"></a><span id="l6.63" class="difflineplus">+  return _normalize_for_json(aObj, aDepthAllowed, true);</span>
<a href="#l6.64"></a><span id="l6.64"> }</span>
<a href="#l6.65"></a><span id="l6.65"> </span>
<a href="#l6.66"></a><span id="l6.66"> /**</span>
<a href="#l6.67"></a><span id="l6.67">  * Simple object copier to limit accidentally JSON-ing a ridiculously complex</span>
<a href="#l6.68"></a><span id="l6.68">  *  object graph or getting tripped up by prototypes.</span>
<a href="#l6.69"></a><span id="l6.69">  *</span>
<a href="#l6.70"></a><span id="l6.70">  * @param aObj Input object.</span>
<a href="#l6.71"></a><span id="l6.71">  * @param aDepthAllowed How many times we are allowed to recursively call</span>
<a href="#l6.72"></a><span id="l6.72">  *     ourselves.</span>
<a href="#l6.73"></a><span id="l6.73">  */</span>
<a href="#l6.74"></a><span id="l6.74"> function __simple_obj_copy(aObj, aDepthAllowed) {</span>
<a href="#l6.75"></a><span id="l6.75">   let oot = {};</span>
<a href="#l6.76"></a><span id="l6.76">   let nextDepth = aDepthAllowed - 1;</span>
<a href="#l6.77"></a><span id="l6.77" class="difflineminus">-  for each (let [key, value] in Iterator(aObj)) {</span>
<a href="#l6.78"></a><span id="l6.78" class="difflineplus">+  for each (let key in Iterator(aObj, true)) {</span>
<a href="#l6.79"></a><span id="l6.79" class="difflineplus">+    // avoid triggering getters</span>
<a href="#l6.80"></a><span id="l6.80" class="difflineplus">+    if (aObj.__lookupGetter__(key)) {</span>
<a href="#l6.81"></a><span id="l6.81" class="difflineplus">+      oot[key] = &quot;*getter*&quot;;</span>
<a href="#l6.82"></a><span id="l6.82" class="difflineplus">+      continue;</span>
<a href="#l6.83"></a><span id="l6.83" class="difflineplus">+    }</span>
<a href="#l6.84"></a><span id="l6.84" class="difflineplus">+    let value = aObj[key];</span>
<a href="#l6.85"></a><span id="l6.85" class="difflineplus">+</span>
<a href="#l6.86"></a><span id="l6.86">     if (value == null) {</span>
<a href="#l6.87"></a><span id="l6.87">       oot[key] = null;</span>
<a href="#l6.88"></a><span id="l6.88">     }</span>
<a href="#l6.89"></a><span id="l6.89">     else if (typeof(value) != &quot;object&quot;) {</span>
<a href="#l6.90"></a><span id="l6.90">       oot[key] = value;</span>
<a href="#l6.91"></a><span id="l6.91">     }</span>
<a href="#l6.92"></a><span id="l6.92">     // steal control flow if no more depth is allowed</span>
<a href="#l6.93"></a><span id="l6.93">     else if (!aDepthAllowed) {</span>
<a href="#l6.94"></a><span id="l6.94">       oot[key] = &quot;truncated, string rep: &quot; + value.toString();</span>
<a href="#l6.95"></a><span id="l6.95">     }</span>
<a href="#l6.96"></a><span id="l6.96">     // array?  we don't count that as depth for now.</span>
<a href="#l6.97"></a><span id="l6.97" class="difflineminus">-    else if (&quot;length&quot; in value) {</span>
<a href="#l6.98"></a><span id="l6.98" class="difflineminus">-      oot[key] = [__simple_value_copy(v, nextDepth) for each</span>
<a href="#l6.99"></a><span id="l6.99" class="difflineplus">+    else if ((&quot;length&quot; in value) &amp;&amp;</span>
<a href="#l6.100"></a><span id="l6.100" class="difflineplus">+             (&quot;constructor&quot; in value) &amp;&amp;</span>
<a href="#l6.101"></a><span id="l6.101" class="difflineplus">+             (value.constructor.name == &quot;Array&quot;)) {</span>
<a href="#l6.102"></a><span id="l6.102" class="difflineplus">+      oot[key] = [__value_copy(v, nextDepth) for each</span>
<a href="#l6.103"></a><span id="l6.103">                    ([, v] in Iterator(value))];</span>
<a href="#l6.104"></a><span id="l6.104">     }</span>
<a href="#l6.105"></a><span id="l6.105">     // it's another object! woo!</span>
<a href="#l6.106"></a><span id="l6.106">     else {</span>
<a href="#l6.107"></a><span id="l6.107">       oot[key] = _normalize_for_json(value, nextDepth, true);</span>
<a href="#l6.108"></a><span id="l6.108">     }</span>
<a href="#l6.109"></a><span id="l6.109">   }</span>
<a href="#l6.110"></a><span id="l6.110"> </span>
<a href="#l6.111"></a><span id="l6.111" class="difflineat">@@ -396,16 +410,22 @@ function _normalize_for_json(aObj, aDept</span>
<a href="#l6.112"></a><span id="l6.112">     };</span>
<a href="#l6.113"></a><span id="l6.113">   }</span>
<a href="#l6.114"></a><span id="l6.114">   else {</span>
<a href="#l6.115"></a><span id="l6.115">     for each (let [, [checkType, handler]] in</span>
<a href="#l6.116"></a><span id="l6.116">               Iterator(_registered_json_normalizers)) {</span>
<a href="#l6.117"></a><span id="l6.117">       if (aObj instanceof checkType)</span>
<a href="#l6.118"></a><span id="l6.118">         return handler(aObj);</span>
<a href="#l6.119"></a><span id="l6.119">     }</span>
<a href="#l6.120"></a><span id="l6.120" class="difflineplus">+</span>
<a href="#l6.121"></a><span id="l6.121" class="difflineplus">+    // Do not fall into simple object walking if this is an XPCOM interface.</span>
<a href="#l6.122"></a><span id="l6.122" class="difflineplus">+    //  We might run across getters and that leads to nothing good.</span>
<a href="#l6.123"></a><span id="l6.123" class="difflineplus">+    if (aObj instanceof Ci.nsISupports) {</span>
<a href="#l6.124"></a><span id="l6.124" class="difflineplus">+      return aObj.toString();</span>
<a href="#l6.125"></a><span id="l6.125" class="difflineplus">+    }</span>
<a href="#l6.126"></a><span id="l6.126">   }</span>
<a href="#l6.127"></a><span id="l6.127"> </span>
<a href="#l6.128"></a><span id="l6.128">   let simple_obj = __simple_obj_copy(aObj, aDepthAllowed);</span>
<a href="#l6.129"></a><span id="l6.129">   if (!aJsonMeNotNeeded)</span>
<a href="#l6.130"></a><span id="l6.130">     simple_obj.__proto__ = _fake_json_proto;</span>
<a href="#l6.131"></a><span id="l6.131">   return simple_obj;</span>
<a href="#l6.132"></a><span id="l6.132"> }</span>
<a href="#l6.133"></a><span id="l6.133"> </span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

