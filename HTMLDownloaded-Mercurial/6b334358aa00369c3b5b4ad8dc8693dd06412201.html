<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 890:6b334358aa00369c3b5b4ad8dc8693dd06412201</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 6b334358aa00369c3b5b4ad8dc8693dd06412201" />
<meta property="og:url" content="/comm-central/rev/6b334358aa00369c3b5b4ad8dc8693dd06412201" />
<meta property="og:description" content="bolster gloda.js documentation.  some of the new phrasings may be somewhat" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 6b334358aa00369c3b5b4ad8dc8693dd06412201 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/6b334358aa00369c3b5b4ad8dc8693dd06412201">shortlog</a> |
<a href="/comm-central/log/6b334358aa00369c3b5b4ad8dc8693dd06412201">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/6b334358aa00369c3b5b4ad8dc8693dd06412201">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/6b334358aa00369c3b5b4ad8dc8693dd06412201">files</a> |
changeset |
<a href="/comm-central/raw-rev/6b334358aa00369c3b5b4ad8dc8693dd06412201">raw</a>  | <a href="/comm-central/archive/6b334358aa00369c3b5b4ad8dc8693dd06412201.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
bolster gloda.js documentation.  some of the new phrasings may be somewhat
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Mon, 25 Aug 2008 00:54:06 -0700</td></tr>

<tr>
 <td>changeset 890</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/6b334358aa00369c3b5b4ad8dc8693dd06412201">6b334358aa00369c3b5b4ad8dc8693dd06412201</a></td>
</tr>



<tr>
<td>parent 889</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/efb99ec644fe2b5eee65b73ec3bdbca80f867335">efb99ec644fe2b5eee65b73ec3bdbca80f867335</a>
</td>
</tr>

<tr>
<td>child 891</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/8d9b309a3e492c611f31313de64e2025a573d92f">8d9b309a3e492c611f31313de64e2025a573d92f</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=6b334358aa00369c3b5b4ad8dc8693dd06412201">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">bolster gloda.js documentation.  some of the new phrasings may be somewhat
awkward, but that's what (subsequent) editing is for.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/6b334358aa00369c3b5b4ad8dc8693dd06412201/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/6b334358aa00369c3b5b4ad8dc8693dd06412201/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/6b334358aa00369c3b5b4ad8dc8693dd06412201/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/6b334358aa00369c3b5b4ad8dc8693dd06412201/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/6b334358aa00369c3b5b4ad8dc8693dd06412201/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/6b334358aa00369c3b5b4ad8dc8693dd06412201/modules/gloda.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -46,27 +46,49 @@ Cu.import(&quot;resource://gloda/modules/log4</span>
<a href="#l1.4"></a><span id="l1.4"> </span>
<a href="#l1.5"></a><span id="l1.5"> Cu.import(&quot;resource://gloda/modules/datastore.js&quot;);</span>
<a href="#l1.6"></a><span id="l1.6"> Cu.import(&quot;resource://gloda/modules/datamodel.js&quot;);</span>
<a href="#l1.7"></a><span id="l1.7"> Cu.import(&quot;resource://gloda/modules/collection.js&quot;);</span>
<a href="#l1.8"></a><span id="l1.8"> Cu.import(&quot;resource://gloda/modules/query.js&quot;);</span>
<a href="#l1.9"></a><span id="l1.9"> Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l1.10"></a><span id="l1.10"> </span>
<a href="#l1.11"></a><span id="l1.11"> /**</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">- * </span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+ * This object/namespace provides the user-visible (and extension visible)</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+ *  global database functionality.  There is currently a dependency/ordering</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+ *  problem in that the concept of 'gloda' also includes some logic that is</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+ *  contributed by built-in extensions, if you will.  Those built-in extensions</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+ *  (fundattr.js, explattr.js) also import this file.  To avoid a circular</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineplus">+ *  dependency, those built-in extensions are loaded by everybody.js.  The</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+ *  simplest/best solution is probably to move everybody.js to be gloda.js and</span>
<a href="#l1.20"></a><span id="l1.20" class="difflineplus">+ *  have it re-export only 'Gloda'.  gloda.js (this file) can then move to be</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineplus">+ *  gloda_int.js (or whatever our eventual naming scheme is), which built-in</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineplus">+ *  extensions can explicitly rely upon.</span>
<a href="#l1.23"></a><span id="l1.23">  */</span>
<a href="#l1.24"></a><span id="l1.24"> let Gloda = {</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineplus">+  /**</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineplus">+   * Initialize logging, the datastore (SQLite database), the core nouns and</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineplus">+   *  attributes, and the contact and identities that belong to the presumed</span>
<a href="#l1.28"></a><span id="l1.28" class="difflineplus">+   *  current user (based on accounts).</span>
<a href="#l1.29"></a><span id="l1.29" class="difflineplus">+   *</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineplus">+   * Additional nouns and the core attribute providers are initialized by the</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineplus">+   *  everybody.js module which ensures all of those dependencies are loaded</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+   *  (and initialized).</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineplus">+   */</span>
<a href="#l1.34"></a><span id="l1.34">   _init: function gloda_ns_init() {</span>
<a href="#l1.35"></a><span id="l1.35">     this._initLogging();</span>
<a href="#l1.36"></a><span id="l1.36">     GlodaDatastore._init();</span>
<a href="#l1.37"></a><span id="l1.37">     this._initAttributes();</span>
<a href="#l1.38"></a><span id="l1.38">     this._initMyIdentities();</span>
<a href="#l1.39"></a><span id="l1.39">   },</span>
<a href="#l1.40"></a><span id="l1.40">   </span>
<a href="#l1.41"></a><span id="l1.41">   _log: null,</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+  /**</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+   * Initialize logging; the error console window gets Warning/Error, and stdout</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+   *  (via dump) gets everything.</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+   */</span>
<a href="#l1.46"></a><span id="l1.46">   _initLogging: function gloda_ns_initLogging() {</span>
<a href="#l1.47"></a><span id="l1.47">     let formatter = new Log4Moz.BasicFormatter();</span>
<a href="#l1.48"></a><span id="l1.48">     let root = Log4Moz.Service.rootLogger;</span>
<a href="#l1.49"></a><span id="l1.49">     root.level = Log4Moz.Level.Debug;</span>
<a href="#l1.50"></a><span id="l1.50"> </span>
<a href="#l1.51"></a><span id="l1.51">     let capp = new Log4Moz.ConsoleAppender(formatter);</span>
<a href="#l1.52"></a><span id="l1.52">     capp.level = Log4Moz.Level.Warn;</span>
<a href="#l1.53"></a><span id="l1.53">     root.addAppender(capp);</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineat">@@ -74,32 +96,44 @@ let Gloda = {</span>
<a href="#l1.55"></a><span id="l1.55">     let dapp = new Log4Moz.DumpAppender(formatter);</span>
<a href="#l1.56"></a><span id="l1.56">     dapp.level = Log4Moz.Level.All;</span>
<a href="#l1.57"></a><span id="l1.57">     root.addAppender(dapp);</span>
<a href="#l1.58"></a><span id="l1.58">     </span>
<a href="#l1.59"></a><span id="l1.59">     this._log = Log4Moz.Service.getLogger(&quot;gloda.NS&quot;);</span>
<a href="#l1.60"></a><span id="l1.60">     this._log.info(&quot;Logging Initialized&quot;);</span>
<a href="#l1.61"></a><span id="l1.61">   },</span>
<a href="#l1.62"></a><span id="l1.62">   </span>
<a href="#l1.63"></a><span id="l1.63" class="difflineplus">+  /**</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineplus">+   * Given an nsIMsgDBHdr, return the gloda message object that corresponds to</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineplus">+   *  it.  If no such message exists, null is returned.</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineplus">+   *</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineplus">+   * Ideally, if gloda is unable to locate a gloda message corresponding to the</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineplus">+   *  header, and it has not been told to avoid indexing the message (based on</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineplus">+   *  folder or other criteria), and the message is not currently queued for</span>
<a href="#l1.70"></a><span id="l1.70" class="difflineplus">+   *  indexing, it should take some action to resolve the issue.  Either by</span>
<a href="#l1.71"></a><span id="l1.71" class="difflineplus">+   *  indexing the single message, or checking if an entire folder has been</span>
<a href="#l1.72"></a><span id="l1.72" class="difflineplus">+   *  overlooked, etc.</span>
<a href="#l1.73"></a><span id="l1.73" class="difflineplus">+   */</span>
<a href="#l1.74"></a><span id="l1.74">   getMessageForHeader: function gloda_ns_getMessageForHeader(aMsgHdr) {</span>
<a href="#l1.75"></a><span id="l1.75">     let message = GlodaDatastore.getMessageFromLocation(aMsgHdr.folder.URI,</span>
<a href="#l1.76"></a><span id="l1.76">                                                         aMsgHdr.messageKey);</span>
<a href="#l1.77"></a><span id="l1.77">     if (message === null) {</span>
<a href="#l1.78"></a><span id="l1.78">       message = GlodaDatastore.getMessageByMessageID(aMsgHdr.messageId);</span>
<a href="#l1.79"></a><span id="l1.79">       this._log.info(&quot;Fell back to locating message by id; actual message &quot; +</span>
<a href="#l1.80"></a><span id="l1.80">                      &quot;key is: &quot; + aMsgHdr.messageKey + &quot; database key: &quot; +</span>
<a href="#l1.81"></a><span id="l1.81">                      message.messageKey);</span>
<a href="#l1.82"></a><span id="l1.82">     }</span>
<a href="#l1.83"></a><span id="l1.83">     </span>
<a href="#l1.84"></a><span id="l1.84">     return message;</span>
<a href="#l1.85"></a><span id="l1.85">   },</span>
<a href="#l1.86"></a><span id="l1.86">   </span>
<a href="#l1.87"></a><span id="l1.87">   /**</span>
<a href="#l1.88"></a><span id="l1.88" class="difflineminus">-   * Given a full mail address (ex: &quot;Bob Smith&quot; &lt;bob@smith.com&gt;), return the</span>
<a href="#l1.89"></a><span id="l1.89" class="difflineminus">-   *  identity that corresponds to that mail address, creating it if required.</span>
<a href="#l1.90"></a><span id="l1.90" class="difflineplus">+   * Given one or more full mail addresses (ex: &quot;Bob Smith&quot; &lt;bob@smith.com&gt;),</span>
<a href="#l1.91"></a><span id="l1.91" class="difflineplus">+   *  return a list of the identities that corresponds to each mail address,</span>
<a href="#l1.92"></a><span id="l1.92" class="difflineplus">+   *  creating them as required.</span>
<a href="#l1.93"></a><span id="l1.93">    */</span>
<a href="#l1.94"></a><span id="l1.94">   getIdentitiesForFullMailAddresses:</span>
<a href="#l1.95"></a><span id="l1.95">       function gloda_ns_getIdentitiesForMailAddresses(aMailAddresses) {</span>
<a href="#l1.96"></a><span id="l1.96">     let parsed = GlodaUtils.parseMailAddresses(aMailAddresses);</span>
<a href="#l1.97"></a><span id="l1.97">     </span>
<a href="#l1.98"></a><span id="l1.98">     let identities = [];</span>
<a href="#l1.99"></a><span id="l1.99">     for (let iAddress=0; iAddress &lt; parsed.count; iAddress++) {</span>
<a href="#l1.100"></a><span id="l1.100">       let identity = GlodaDatastore.getIdentity(&quot;email&quot;,</span>
<a href="#l1.101"></a><span id="l1.101" class="difflineat">@@ -124,39 +158,56 @@ let Gloda = {</span>
<a href="#l1.102"></a><span id="l1.102">                                                  &quot;&quot;, false);</span>
<a href="#l1.103"></a><span id="l1.103">       }</span>
<a href="#l1.104"></a><span id="l1.104">       identities.push(identity);</span>
<a href="#l1.105"></a><span id="l1.105">     }</span>
<a href="#l1.106"></a><span id="l1.106">     </span>
<a href="#l1.107"></a><span id="l1.107">     return identities;</span>
<a href="#l1.108"></a><span id="l1.108">   },</span>
<a href="#l1.109"></a><span id="l1.109">   </span>
<a href="#l1.110"></a><span id="l1.110" class="difflineplus">+  /**</span>
<a href="#l1.111"></a><span id="l1.111" class="difflineplus">+   * Given a full mail address (ex: &quot;Bob Smith&quot; &lt;bob@smith.com&gt;), return the</span>
<a href="#l1.112"></a><span id="l1.112" class="difflineplus">+   *  identity that corresponds to that mail address, creating it if required.</span>
<a href="#l1.113"></a><span id="l1.113" class="difflineplus">+   *  (If you want the contact, it is easily retrieved via the 'contact'</span>
<a href="#l1.114"></a><span id="l1.114" class="difflineplus">+   *  attribute on the identity.)</span>
<a href="#l1.115"></a><span id="l1.115" class="difflineplus">+   */</span>
<a href="#l1.116"></a><span id="l1.116">   getIdentityForFullMailAddress:</span>
<a href="#l1.117"></a><span id="l1.117">       function gloda_ns_getIdentityForFullMailAddress(aMailAddress) {</span>
<a href="#l1.118"></a><span id="l1.118">     let identities = this.getIdentitiesForFullMailAddresses(aMailAddress);</span>
<a href="#l1.119"></a><span id="l1.119">     if (identities.length != 1) {</span>
<a href="#l1.120"></a><span id="l1.120">       this._log.info(&quot;Expected exactly 1 address, got &quot; + identities.length +</span>
<a href="#l1.121"></a><span id="l1.121">                      &quot; for address: &quot; + aMailAddress);</span>
<a href="#l1.122"></a><span id="l1.122">       return null;</span>
<a href="#l1.123"></a><span id="l1.123">     }    </span>
<a href="#l1.124"></a><span id="l1.124">     </span>
<a href="#l1.125"></a><span id="l1.125">     return identities[0];</span>
<a href="#l1.126"></a><span id="l1.126">   },</span>
<a href="#l1.127"></a><span id="l1.127">   </span>
<a href="#l1.128"></a><span id="l1.128">   /**</span>
<a href="#l1.129"></a><span id="l1.129">    * Dictionary of the user's known identities; key is the identity id, value</span>
<a href="#l1.130"></a><span id="l1.130" class="difflineminus">-   *  is the actual identity.</span>
<a href="#l1.131"></a><span id="l1.131" class="difflineplus">+   *  is the actual identity.  This is populated by _initMyIdentities based on</span>
<a href="#l1.132"></a><span id="l1.132" class="difflineplus">+   *  the accounts defined.</span>
<a href="#l1.133"></a><span id="l1.133">    */</span>
<a href="#l1.134"></a><span id="l1.134">   myIdentities: {},</span>
<a href="#l1.135"></a><span id="l1.135" class="difflineplus">+  /**</span>
<a href="#l1.136"></a><span id="l1.136" class="difflineplus">+   * The contact corresponding to the current user.  We are assuming that only</span>
<a href="#l1.137"></a><span id="l1.137" class="difflineplus">+   *  a single user/human being uses the current profile.  This is known to be</span>
<a href="#l1.138"></a><span id="l1.138" class="difflineplus">+   *  a flawed assumption, but is the best first approximation available.</span>
<a href="#l1.139"></a><span id="l1.139" class="difflineplus">+   *</span>
<a href="#l1.140"></a><span id="l1.140" class="difflineplus">+   * @TODO attempt to deal with multile people using the same profile</span>
<a href="#l1.141"></a><span id="l1.141" class="difflineplus">+   */</span>
<a href="#l1.142"></a><span id="l1.142">   myContact: null,</span>
<a href="#l1.143"></a><span id="l1.143">   /**</span>
<a href="#l1.144"></a><span id="l1.144" class="difflineminus">-   * Populate myIdentities with all of our identities.  Also, populate</span>
<a href="#l1.145"></a><span id="l1.145" class="difflineminus">-   *  myContact.</span>
<a href="#l1.146"></a><span id="l1.146" class="difflineplus">+   * Populate myIdentities with all of our identities.  Currently we do this</span>
<a href="#l1.147"></a><span id="l1.147" class="difflineplus">+   *  by assuming that there is one human/user per profile, and that all of the</span>
<a href="#l1.148"></a><span id="l1.148" class="difflineplus">+   *  accounts defined in the profile belong to them.  The single contact is</span>
<a href="#l1.149"></a><span id="l1.149" class="difflineplus">+   *  stored on myContact.</span>
<a href="#l1.150"></a><span id="l1.150">    *</span>
<a href="#l1.151"></a><span id="l1.151">    * @TODO deal with account addition/modification/removal</span>
<a href="#l1.152"></a><span id="l1.152" class="difflineplus">+   * @TODO attempt to deal with multiple people using the same profile</span>
<a href="#l1.153"></a><span id="l1.153">    */</span>
<a href="#l1.154"></a><span id="l1.154">   _initMyIdentities: function gloda_ns_initMyIdentities() {</span>
<a href="#l1.155"></a><span id="l1.155">     let myContact = null;</span>
<a href="#l1.156"></a><span id="l1.156">     let myIdentities = {};</span>
<a href="#l1.157"></a><span id="l1.157">     let myEmailAddresses = {}; // process each email at most once; stored here</span>
<a href="#l1.158"></a><span id="l1.158">     </span>
<a href="#l1.159"></a><span id="l1.159">     let fullName = null;</span>
<a href="#l1.160"></a><span id="l1.160">     let existingIdentities = [];</span>
<a href="#l1.161"></a><span id="l1.161" class="difflineat">@@ -264,80 +315,167 @@ let Gloda = {</span>
<a href="#l1.162"></a><span id="l1.162">   /**</span>
<a href="#l1.163"></a><span id="l1.163">    * An attribute that is indirectly the result of a user's behaviour.  For</span>
<a href="#l1.164"></a><span id="l1.164">    *  example, if a user consults a message multiple times, we may conclude that</span>
<a href="#l1.165"></a><span id="l1.165">    *  the user finds the message interesting.  It is &quot;implied&quot;, if you will,</span>
<a href="#l1.166"></a><span id="l1.166">    *  that the message is interesting.</span>
<a href="#l1.167"></a><span id="l1.167">    */</span>
<a href="#l1.168"></a><span id="l1.168">   kAttrImplicit: 4,</span>
<a href="#l1.169"></a><span id="l1.169">   </span>
<a href="#l1.170"></a><span id="l1.170" class="difflineplus">+  /**</span>
<a href="#l1.171"></a><span id="l1.171" class="difflineplus">+   * This attribute is not 'special'; it is stored as a (thing id, attribute id,</span>
<a href="#l1.172"></a><span id="l1.172" class="difflineplus">+   *  attribute id) tuple in the database rather than on thing's row or on</span>
<a href="#l1.173"></a><span id="l1.173" class="difflineplus">+   *  thing's fulltext row.  (Where &quot;thing&quot; could be a message or any other</span>
<a href="#l1.174"></a><span id="l1.174" class="difflineplus">+   *  first class noun.)</span>
<a href="#l1.175"></a><span id="l1.175" class="difflineplus">+   */</span>
<a href="#l1.176"></a><span id="l1.176">   kSpecialNotAtAll: 0,</span>
<a href="#l1.177"></a><span id="l1.177">   /**</span>
<a href="#l1.178"></a><span id="l1.178">    * This attribute is stored as a column on the row for the noun.  The</span>
<a href="#l1.179"></a><span id="l1.179">    *  attribute definition should include this value as 'special' and the</span>
<a href="#l1.180"></a><span id="l1.180">    *  column name that stores the attribute as 'specialColumnName'.</span>
<a href="#l1.181"></a><span id="l1.181">    */</span>
<a href="#l1.182"></a><span id="l1.182">   kSpecialColumn: 1,</span>
<a href="#l1.183"></a><span id="l1.183">   /**</span>
<a href="#l1.184"></a><span id="l1.184">    * This attribute is stored as a fulltext column on the fulltext table for</span>
<a href="#l1.185"></a><span id="l1.185">    *  the noun.  The attribute defintion should include this value as 'special'</span>
<a href="#l1.186"></a><span id="l1.186">    *  and the column name that stores the table as 'specialColumnName'.</span>
<a href="#l1.187"></a><span id="l1.187">    */</span>
<a href="#l1.188"></a><span id="l1.188">   kSpecialFulltext: 2,</span>
<a href="#l1.189"></a><span id="l1.189">   </span>
<a href="#l1.190"></a><span id="l1.190" class="difflineplus">+  /**</span>
<a href="#l1.191"></a><span id="l1.191" class="difflineplus">+   * The extensionName used for the attributes defined by core gloda plugins</span>
<a href="#l1.192"></a><span id="l1.192" class="difflineplus">+   *  such as fundattr.js and explattr.js.</span>
<a href="#l1.193"></a><span id="l1.193" class="difflineplus">+   */</span>
<a href="#l1.194"></a><span id="l1.194">   BUILT_IN: &quot;built-in&quot;,</span>
<a href="#l1.195"></a><span id="l1.195">   </span>
<a href="#l1.196"></a><span id="l1.196" class="difflineplus">+  </span>
<a href="#l1.197"></a><span id="l1.197" class="difflineplus">+  /*</span>
<a href="#l1.198"></a><span id="l1.198" class="difflineplus">+   * The following are explicit noun IDs.  While most extension-provided nouns</span>
<a href="#l1.199"></a><span id="l1.199" class="difflineplus">+   *  will have dynamically allocated id's that are looked up by name, these</span>
<a href="#l1.200"></a><span id="l1.200" class="difflineplus">+   *  id's can be relied upon to exist and be accessible via these</span>
<a href="#l1.201"></a><span id="l1.201" class="difflineplus">+   *  pseudo-constants.  It's not really clear that we need these, although it</span>
<a href="#l1.202"></a><span id="l1.202" class="difflineplus">+   *  does potentially simplify code to not have to look up all of their nouns</span>
<a href="#l1.203"></a><span id="l1.203" class="difflineplus">+   *  at initialization time.</span>
<a href="#l1.204"></a><span id="l1.204" class="difflineplus">+   */</span>
<a href="#l1.205"></a><span id="l1.205" class="difflineplus">+  /**</span>
<a href="#l1.206"></a><span id="l1.206" class="difflineplus">+   * Boolean values, expressed as 0/1 in the database and non-continuous for</span>
<a href="#l1.207"></a><span id="l1.207" class="difflineplus">+   *  constraint purposes.  Like numbers, such nouns require their attributes</span>
<a href="#l1.208"></a><span id="l1.208" class="difflineplus">+   *  to provide them with context, lacking any of their own.</span>
<a href="#l1.209"></a><span id="l1.209" class="difflineplus">+   * Having this as a noun type may be a bad idea; a change of nomenclature</span>
<a href="#l1.210"></a><span id="l1.210" class="difflineplus">+   *  (so that we are not claiming a boolean value is a noun, but still using</span>
<a href="#l1.211"></a><span id="l1.211" class="difflineplus">+   *  it in the same way) or implementation to require each boolean noun</span>
<a href="#l1.212"></a><span id="l1.212" class="difflineplus">+   *  actually be its own noun may be in order.</span>
<a href="#l1.213"></a><span id="l1.213" class="difflineplus">+   */</span>
<a href="#l1.214"></a><span id="l1.214">   NOUN_BOOLEAN: 1,</span>
<a href="#l1.215"></a><span id="l1.215" class="difflineplus">+  /**</span>
<a href="#l1.216"></a><span id="l1.216" class="difflineplus">+   * A number, which could mean an integer or floating point values.  We treat</span>
<a href="#l1.217"></a><span id="l1.217" class="difflineplus">+   *  these as continuous, meaning that queries on them can have ranged</span>
<a href="#l1.218"></a><span id="l1.218" class="difflineplus">+   *  constraints expressed on them.  Lacking any inherent context, numbers</span>
<a href="#l1.219"></a><span id="l1.219" class="difflineplus">+   *  depend on their attributes to parameterize them as required.</span>
<a href="#l1.220"></a><span id="l1.220" class="difflineplus">+   * Same deal as with NOUN_BOOLEAN, we may need to change this up conceptually.</span>
<a href="#l1.221"></a><span id="l1.221" class="difflineplus">+   */</span>
<a href="#l1.222"></a><span id="l1.222">   NOUN_NUMBER: 2,</span>
<a href="#l1.223"></a><span id="l1.223">   /** A date, encoded as a PRTime, represented as a js Date object. */</span>
<a href="#l1.224"></a><span id="l1.224">   NOUN_DATE: 10,</span>
<a href="#l1.225"></a><span id="l1.225">   /**</span>
<a href="#l1.226"></a><span id="l1.226">    * Fulltext search support, somewhat magical.  This is only intended to be</span>
<a href="#l1.227"></a><span id="l1.227">    *  used for kSpecialFulltext attributes, and exclusively as a constraint</span>
<a href="#l1.228"></a><span id="l1.228">    *  mechanism.  The values are always represented as strings.  It is presumed</span>
<a href="#l1.229"></a><span id="l1.229">    *  that the user of this functionality knows how to generate SQLite FTS3</span>
<a href="#l1.230"></a><span id="l1.230">    *  style MATCH queries, or is okay with us just gluing them together with</span>
<a href="#l1.231"></a><span id="l1.231">    *  &quot; OR &quot; when used in an or-constraint case.  Gloda's query mechanism</span>
<a href="#l1.232"></a><span id="l1.232">    *  currently lacks the ability to to compile Gloda-style and-constraints</span>
<a href="#l1.233"></a><span id="l1.233">    *  into a single MATCH query, but it will turn out okay, just less</span>
<a href="#l1.234"></a><span id="l1.234">    *  efficiently than it could.</span>
<a href="#l1.235"></a><span id="l1.235">    */</span>
<a href="#l1.236"></a><span id="l1.236">   NOUN_FULLTEXT: 20,</span>
<a href="#l1.237"></a><span id="l1.237" class="difflineplus">+  /**</span>
<a href="#l1.238"></a><span id="l1.238" class="difflineplus">+   * Captures a message tag as well as when the tag's presence was observed,</span>
<a href="#l1.239"></a><span id="l1.239" class="difflineplus">+   *  hoping to approximate when the tag was applied.  It's a somewhat dubious</span>
<a href="#l1.240"></a><span id="l1.240" class="difflineplus">+   *  attempt to not waste our opporunity to store a value along with the tag.</span>
<a href="#l1.241"></a><span id="l1.241" class="difflineplus">+   *  (The tag is actually stored as an attribute parameter on the attribute</span>
<a href="#l1.242"></a><span id="l1.242" class="difflineplus">+   *  definition, rather than a value in the attribute 'instance' for the</span>
<a href="#l1.243"></a><span id="l1.243" class="difflineplus">+   *  message.)</span>
<a href="#l1.244"></a><span id="l1.244" class="difflineplus">+   */</span>
<a href="#l1.245"></a><span id="l1.245">   NOUN_TAG: 50,</span>
<a href="#l1.246"></a><span id="l1.246" class="difflineplus">+  /**</span>
<a href="#l1.247"></a><span id="l1.247" class="difflineplus">+   * Doesn't actually work owing to a lack of an object to represent a folder.</span>
<a href="#l1.248"></a><span id="l1.248" class="difflineplus">+   *  We do expose the folderURI and folderID of a message, but need to map that</span>
<a href="#l1.249"></a><span id="l1.249" class="difflineplus">+   *  to a good abstraction.  Probably something thin around a SteelFolder or</span>
<a href="#l1.250"></a><span id="l1.250" class="difflineplus">+   *  the like; we would contribute the functionality to easily move from a</span>
<a href="#l1.251"></a><span id="l1.251" class="difflineplus">+   *  folder to the list of gloda messages in that folder, as well as the</span>
<a href="#l1.252"></a><span id="l1.252" class="difflineplus">+   *  indexing preferences for that folder.</span>
<a href="#l1.253"></a><span id="l1.253" class="difflineplus">+   * @TODO folder noun and related abstraction</span>
<a href="#l1.254"></a><span id="l1.254" class="difflineplus">+   */</span>
<a href="#l1.255"></a><span id="l1.255">   NOUN_FOLDER: 100,</span>
<a href="#l1.256"></a><span id="l1.256" class="difflineplus">+  /**</span>
<a href="#l1.257"></a><span id="l1.257" class="difflineplus">+   * All messages belong to a conversation.  See datamodel.js for the</span>
<a href="#l1.258"></a><span id="l1.258" class="difflineplus">+   *  definition of the GlodaConversation class.</span>
<a href="#l1.259"></a><span id="l1.259" class="difflineplus">+   */</span>
<a href="#l1.260"></a><span id="l1.260">   NOUN_CONVERSATION: GlodaConversation.prototype.NOUN_ID, // 101</span>
<a href="#l1.261"></a><span id="l1.261" class="difflineplus">+  /**</span>
<a href="#l1.262"></a><span id="l1.262" class="difflineplus">+   * A one-to-one correspondence with underlying (indexed) nsIMsgDBHdr</span>
<a href="#l1.263"></a><span id="l1.263" class="difflineplus">+   *  instances.  See datamodel.js for the definition of the GlodaMessage class.</span>
<a href="#l1.264"></a><span id="l1.264" class="difflineplus">+   */</span>
<a href="#l1.265"></a><span id="l1.265">   NOUN_MESSAGE: GlodaMessage.prototype.NOUN_ID, // 102</span>
<a href="#l1.266"></a><span id="l1.266" class="difflineplus">+  /**</span>
<a href="#l1.267"></a><span id="l1.267" class="difflineplus">+   * Corresponds to a human being, who may have multiple electronic identities</span>
<a href="#l1.268"></a><span id="l1.268" class="difflineplus">+   *  (a la NOUN_IDENTITY).  There is no requirement for association with an</span>
<a href="#l1.269"></a><span id="l1.269" class="difflineplus">+   *  address book contact, although when the address book contact exists,</span>
<a href="#l1.270"></a><span id="l1.270" class="difflineplus">+   *  we want to be associated with it.  See datamodel.js for the definition</span>
<a href="#l1.271"></a><span id="l1.271" class="difflineplus">+   *  of the GlodaContact class.</span>
<a href="#l1.272"></a><span id="l1.272" class="difflineplus">+   */</span>
<a href="#l1.273"></a><span id="l1.273">   NOUN_CONTACT: GlodaContact.prototype.NOUN_ID, // 103</span>
<a href="#l1.274"></a><span id="l1.274" class="difflineplus">+  /**</span>
<a href="#l1.275"></a><span id="l1.275" class="difflineplus">+   * A single identity of a contact, who may have one or more.  E-mail accounts,</span>
<a href="#l1.276"></a><span id="l1.276" class="difflineplus">+   *  instant messaging accounts, social network site accounts, etc. are each</span>
<a href="#l1.277"></a><span id="l1.277" class="difflineplus">+   *  identities.  See datamodel.js for the definition of the GlodaIdentity</span>
<a href="#l1.278"></a><span id="l1.278" class="difflineplus">+   *  class.</span>
<a href="#l1.279"></a><span id="l1.279" class="difflineplus">+   */</span>
<a href="#l1.280"></a><span id="l1.280">   NOUN_IDENTITY: GlodaIdentity.prototype.NOUN_ID, // 104</span>
<a href="#l1.281"></a><span id="l1.281">   </span>
<a href="#l1.282"></a><span id="l1.282">   /**</span>
<a href="#l1.283"></a><span id="l1.283">    * Parameterized identities, for use in the from-me, to-me, cc-me optimization</span>
<a href="#l1.284"></a><span id="l1.284" class="difflineminus">-   *  cases.  Not for reuse without some thought.</span>
<a href="#l1.285"></a><span id="l1.285" class="difflineplus">+   *  cases.  Not for reuse without some thought.  These nouns use the parameter</span>
<a href="#l1.286"></a><span id="l1.286" class="difflineplus">+   *  to store the 'me' identity that we are talking about, and the value to</span>
<a href="#l1.287"></a><span id="l1.287" class="difflineplus">+   *  store the identity of the other party.  So in both the from-me and to-me</span>
<a href="#l1.288"></a><span id="l1.288" class="difflineplus">+   *  cases involving 'me' and 'foo@bar', the 'me' identity is always stored via</span>
<a href="#l1.289"></a><span id="l1.289" class="difflineplus">+   *  the attribute parameter, and the 'foo@bar' identity is always stored as</span>
<a href="#l1.290"></a><span id="l1.290" class="difflineplus">+   *  the attribute value.  See fundattr.js for more information on this, but</span>
<a href="#l1.291"></a><span id="l1.291" class="difflineplus">+   *  you probably shouldn't be touching this unless you are fundattr.</span>
<a href="#l1.292"></a><span id="l1.292">    */</span>
<a href="#l1.293"></a><span id="l1.293">   NOUN_PARAM_IDENTITY: 200,</span>
<a href="#l1.294"></a><span id="l1.294">   </span>
<a href="#l1.295"></a><span id="l1.295">   /** Next Noun ID to hand out, these don't need to be persisted (for now). */</span>
<a href="#l1.296"></a><span id="l1.296">   _nextNounID: 1000,</span>
<a href="#l1.297"></a><span id="l1.297"> </span>
<a href="#l1.298"></a><span id="l1.298" class="difflineplus">+  /**</span>
<a href="#l1.299"></a><span id="l1.299" class="difflineplus">+   * Maps noun names to noun IDs.</span>
<a href="#l1.300"></a><span id="l1.300" class="difflineplus">+   */</span>
<a href="#l1.301"></a><span id="l1.301">   _nounNameToNounID: {},</span>
<a href="#l1.302"></a><span id="l1.302" class="difflineplus">+  /**</span>
<a href="#l1.303"></a><span id="l1.303" class="difflineplus">+   * Maps noun IDs to noun meta dictionaries.  (Noun meta dictionaries being</span>
<a href="#l1.304"></a><span id="l1.304" class="difflineplus">+   *  the dictionary provided to us at the time a noun was defined, plus some</span>
<a href="#l1.305"></a><span id="l1.305" class="difflineplus">+   *  additional stuff we put in there.)</span>
<a href="#l1.306"></a><span id="l1.306" class="difflineplus">+   */</span>
<a href="#l1.307"></a><span id="l1.307">   _nounIDToMeta: {},</span>
<a href="#l1.308"></a><span id="l1.308">   </span>
<a href="#l1.309"></a><span id="l1.309">   /**</span>
<a href="#l1.310"></a><span id="l1.310">    * Define a noun.  Takes a dictionary with the following keys/values:</span>
<a href="#l1.311"></a><span id="l1.311">    *</span>
<a href="#l1.312"></a><span id="l1.312">    * @param name The name of the noun.  This is not a display name (anything</span>
<a href="#l1.313"></a><span id="l1.313">    *     being displayed needs to be localized, after all), but simply the</span>
<a href="#l1.314"></a><span id="l1.314">    *     canonical name for debugging purposes and for people to pass to</span>
<a href="#l1.315"></a><span id="l1.315">    *     lookupNoun.  The suggested convention is lower-case-dash-delimited,</span>
<a href="#l1.316"></a><span id="l1.316">    *     with names being singular (since it's a single noun we are referring</span>
<a href="#l1.317"></a><span id="l1.317">    *     to.)</span>
<a href="#l1.318"></a><span id="l1.318">    * @param class The 'class' to which an instance of the noun will belong (aka</span>
<a href="#l1.319"></a><span id="l1.319">    *     will pass an instanceof test).</span>
<a href="#l1.320"></a><span id="l1.320">    * @param firstClass Is this a 'first class noun'/can it be a subject, AKA can</span>
<a href="#l1.321"></a><span id="l1.321" class="difflineminus">-   *     this noun have attributes stored on it that relate it to other things?  For</span>
<a href="#l1.322"></a><span id="l1.322" class="difflineplus">+   *     this noun have attributes stored on it that relate it to other things?</span>
<a href="#l1.323"></a><span id="l1.323">    *     For example, a message is first-class; we store attributes of</span>
<a href="#l1.324"></a><span id="l1.324">    *     messages.  A date is not first-class now, nor is it likely to be; we</span>
<a href="#l1.325"></a><span id="l1.325">    *     will not store attributes about a date, although dates will be the</span>
<a href="#l1.326"></a><span id="l1.326">    *     objects of other subjects.  (For example: we might associate a date</span>
<a href="#l1.327"></a><span id="l1.327">    *     with a calendar event, but the date is an attribute of the calendar</span>
<a href="#l1.328"></a><span id="l1.328">    *     event and not vice versa.) </span>
<a href="#l1.329"></a><span id="l1.329">    * @param usesParameter A boolean indicating whether this noun requires use</span>
<a href="#l1.330"></a><span id="l1.330">    *     of the 'parameter' BLOB storage field on the attribute bindings in the</span>
<a href="#l1.331"></a><span id="l1.331" class="difflineat">@@ -388,34 +526,87 @@ let Gloda = {</span>
<a href="#l1.332"></a><span id="l1.332">       return this._nounNameToNounID[aNounName];</span>
<a href="#l1.333"></a><span id="l1.333">     </span>
<a href="#l1.334"></a><span id="l1.334">     throw Error(&quot;Unable to locate noun with name '&quot; + aNounName + &quot;', but I &quot; +</span>
<a href="#l1.335"></a><span id="l1.335">                 &quot;do know about: &quot; +</span>
<a href="#l1.336"></a><span id="l1.336">                 [propName for</span>
<a href="#l1.337"></a><span id="l1.337">                  (propName in this._nounNameToNounID)].join(&quot;, &quot;)); </span>
<a href="#l1.338"></a><span id="l1.338">   },</span>
<a href="#l1.339"></a><span id="l1.339">   </span>
<a href="#l1.340"></a><span id="l1.340" class="difflineplus">+  /**</span>
<a href="#l1.341"></a><span id="l1.341" class="difflineplus">+   * Define an action on a noun.  During the prototype stage, this was conceived</span>
<a href="#l1.342"></a><span id="l1.342" class="difflineplus">+   *  of as a way to expose all the constraints possible given a noun.  For</span>
<a href="#l1.343"></a><span id="l1.343" class="difflineplus">+   *  example, if you have an identity or a contact, you could use this to</span>
<a href="#l1.344"></a><span id="l1.344" class="difflineplus">+   *  see all the messages sent from/to a given contact.  It was likewise</span>
<a href="#l1.345"></a><span id="l1.345" class="difflineplus">+   *  thought potentially usable for future expansion.  For example, you could</span>
<a href="#l1.346"></a><span id="l1.346" class="difflineplus">+   *  also decide to send an e-mail to a contact when you have the contact</span>
<a href="#l1.347"></a><span id="l1.347" class="difflineplus">+   *  instance available.</span>
<a href="#l1.348"></a><span id="l1.348" class="difflineplus">+   * Outside of the 'expmess' checkbox-happy prototype, this functionality is</span>
<a href="#l1.349"></a><span id="l1.349" class="difflineplus">+   *  not used.  As such, this functionality should be considered in flux and</span>
<a href="#l1.350"></a><span id="l1.350" class="difflineplus">+   *  subject to changes.  Also, very open to specific suggestsions motivated</span>
<a href="#l1.351"></a><span id="l1.351" class="difflineplus">+   *  by use cases.</span>
<a href="#l1.352"></a><span id="l1.352" class="difflineplus">+   * One conceptual issue raised by this mechanism is the interaction of actions</span>
<a href="#l1.353"></a><span id="l1.353" class="difflineplus">+   *  with facts like &quot;this message is read&quot;.  We currently implement the 'fact'</span>
<a href="#l1.354"></a><span id="l1.354" class="difflineplus">+   *  by defining an attribute with a 'boolean' noun type.  To deal with this,</span>
<a href="#l1.355"></a><span id="l1.355" class="difflineplus">+   *  in various places we pass-in the attribute as well as the noun value.</span>
<a href="#l1.356"></a><span id="l1.356" class="difflineplus">+   *  Since the relationships for booleans and integers in these cases is</span>
<a href="#l1.357"></a><span id="l1.357" class="difflineplus">+   *  standard and well-defined, this works out pretty well, but suggests we</span>
<a href="#l1.358"></a><span id="l1.358" class="difflineplus">+   *  need to think things through.</span>
<a href="#l1.359"></a><span id="l1.359" class="difflineplus">+   *</span>
<a href="#l1.360"></a><span id="l1.360" class="difflineplus">+   * @param The ID of the noun you want to define an action on.</span>
<a href="#l1.361"></a><span id="l1.361" class="difflineplus">+   * @param The dictionary describing the noun.  The dictionary should have</span>
<a href="#l1.362"></a><span id="l1.362" class="difflineplus">+   *     the following fields:</span>
<a href="#l1.363"></a><span id="l1.363" class="difflineplus">+   * - actionType: a string indicating the type of action.  Currently, only</span>
<a href="#l1.364"></a><span id="l1.364" class="difflineplus">+   *   &quot;filter&quot; is a legal value.</span>
<a href="#l1.365"></a><span id="l1.365" class="difflineplus">+   * - actionTarget: the noun ID of the noun type on which this action is</span>
<a href="#l1.366"></a><span id="l1.366" class="difflineplus">+   *   applicable.  For example,</span>
<a href="#l1.367"></a><span id="l1.367" class="difflineplus">+   *</span>
<a href="#l1.368"></a><span id="l1.368" class="difflineplus">+   * The following should be present for actionType==&quot;filter&quot;;</span>
<a href="#l1.369"></a><span id="l1.369" class="difflineplus">+   * - shortName: The name that should be used to display this constraint.  For</span>
<a href="#l1.370"></a><span id="l1.370" class="difflineplus">+   *   example, a checkbox-heavy UI might display a checkbox for each constraint</span>
<a href="#l1.371"></a><span id="l1.371" class="difflineplus">+   *   using shortName as the label.</span>
<a href="#l1.372"></a><span id="l1.372" class="difflineplus">+   * - makeConstraint: A function that takes the attribute that is the source</span>
<a href="#l1.373"></a><span id="l1.373" class="difflineplus">+   *   of the noun and the noun instance as arguments, and returns APV-style</span>
<a href="#l1.374"></a><span id="l1.374" class="difflineplus">+   *   constraints.  Since the APV-style query mechanism is now deprecated,</span>
<a href="#l1.375"></a><span id="l1.375" class="difflineplus">+   *   this signature is deprecated.  Probably the way to update this would be</span>
<a href="#l1.376"></a><span id="l1.376" class="difflineplus">+   *   to pass in the query instance that constraints should be contributed to.</span>
<a href="#l1.377"></a><span id="l1.377" class="difflineplus">+   */</span>
<a href="#l1.378"></a><span id="l1.378">   defineNounAction: function gloda_ns_defineNounAction(aNounID, aActionMeta) {</span>
<a href="#l1.379"></a><span id="l1.379">     let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l1.380"></a><span id="l1.380">     nounMeta.actions.push(aActionMeta);</span>
<a href="#l1.381"></a><span id="l1.381">   },</span>
<a href="#l1.382"></a><span id="l1.382">   </span>
<a href="#l1.383"></a><span id="l1.383" class="difflineplus">+  /**</span>
<a href="#l1.384"></a><span id="l1.384" class="difflineplus">+   * Retrieve all of the actions (as defined using defineNounAction) for the</span>
<a href="#l1.385"></a><span id="l1.385" class="difflineplus">+   *  given noun type (via noun ID) with the given action type (ex: filter).</span>
<a href="#l1.386"></a><span id="l1.386" class="difflineplus">+   */</span>
<a href="#l1.387"></a><span id="l1.387">   getNounActions: function gloda_ns_getNounActions(aNounID, aActionType) {</span>
<a href="#l1.388"></a><span id="l1.388">     let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l1.389"></a><span id="l1.389">     if (!nounMeta)</span>
<a href="#l1.390"></a><span id="l1.390">       return [];</span>
<a href="#l1.391"></a><span id="l1.391">     return [action for each (action in nounMeta.actions)</span>
<a href="#l1.392"></a><span id="l1.392">             if (!aActionType || (action.actionType == aActionType))];</span>
<a href="#l1.393"></a><span id="l1.393">   },</span>
<a href="#l1.394"></a><span id="l1.394">   </span>
<a href="#l1.395"></a><span id="l1.395">   /** Attribute providers in the sequence to process them. */</span>
<a href="#l1.396"></a><span id="l1.396">   _attrProviderOrder: [],</span>
<a href="#l1.397"></a><span id="l1.397">   /** Maps attribute providers to the list of attributes they provide */</span>
<a href="#l1.398"></a><span id="l1.398">   _attrProviders: {},</span>
<a href="#l1.399"></a><span id="l1.399">   </span>
<a href="#l1.400"></a><span id="l1.400" class="difflineplus">+  /**</span>
<a href="#l1.401"></a><span id="l1.401" class="difflineplus">+   * Define the core nouns (that are not defined elsewhere) and a few noun</span>
<a href="#l1.402"></a><span id="l1.402" class="difflineplus">+   *  actions.  Core nouns could be defined in other files, assuming dependency</span>
<a href="#l1.403"></a><span id="l1.403" class="difflineplus">+   *  issues are resolved via the everybody.js mechanism or something else.</span>
<a href="#l1.404"></a><span id="l1.404" class="difflineplus">+   *  Right now, noun_tag defines the tag noun.  If we broke more of these out,</span>
<a href="#l1.405"></a><span id="l1.405" class="difflineplus">+   *  we would probably want to move the 'class' code from datamodel.js, the</span>
<a href="#l1.406"></a><span id="l1.406" class="difflineplus">+   *  SQL table def and helper code from datastore.js (and this code) to their</span>
<a href="#l1.407"></a><span id="l1.407" class="difflineplus">+   *  own noun_*.js files.  There are some trade-offs to be made, and I think</span>
<a href="#l1.408"></a><span id="l1.408" class="difflineplus">+   *  we can deal with those once we start to integrate lightning/calendar and</span>
<a href="#l1.409"></a><span id="l1.409" class="difflineplus">+   *  our noun space gets large and more heterogeneous.</span>
<a href="#l1.410"></a><span id="l1.410" class="difflineplus">+   */</span>
<a href="#l1.411"></a><span id="l1.411">   _initAttributes: function gloda_ns_initAttributes() {</span>
<a href="#l1.412"></a><span id="l1.412">     this.defineNoun({</span>
<a href="#l1.413"></a><span id="l1.413">       name: &quot;bool&quot;,</span>
<a href="#l1.414"></a><span id="l1.414">       class: Boolean, firstClass: false,</span>
<a href="#l1.415"></a><span id="l1.415">       fromParamAndValue: function(aParam, aVal) {</span>
<a href="#l1.416"></a><span id="l1.416">         if(aVal != 0) return true; else return false;</span>
<a href="#l1.417"></a><span id="l1.417">       },</span>
<a href="#l1.418"></a><span id="l1.418">       toParamAndValue: function(aBool) {</span>
<a href="#l1.419"></a><span id="l1.419" class="difflineat">@@ -567,17 +758,26 @@ let Gloda = {</span>
<a href="#l1.420"></a><span id="l1.420">       actionTarget: Gloda.NOUN_MESSAGE,</span>
<a href="#l1.421"></a><span id="l1.421">       shortName: &quot;false&quot;,</span>
<a href="#l1.422"></a><span id="l1.422">       makeConstraint: function(aAttrDef, aIdentity) {</span>
<a href="#l1.423"></a><span id="l1.423">         return [aAttrDef, null, 0];</span>
<a href="#l1.424"></a><span id="l1.424">       },</span>
<a href="#l1.425"></a><span id="l1.425">       });</span>
<a href="#l1.426"></a><span id="l1.426">   },</span>
<a href="#l1.427"></a><span id="l1.427">   </span>
<a href="#l1.428"></a><span id="l1.428" class="difflineminus">-  </span>
<a href="#l1.429"></a><span id="l1.429" class="difflineplus">+  /**</span>
<a href="#l1.430"></a><span id="l1.430" class="difflineplus">+   * Create accessor functions to 'bind' an attribute to underlying normalized</span>
<a href="#l1.431"></a><span id="l1.431" class="difflineplus">+   *  attribute storage, as well as creating the appropriate query object</span>
<a href="#l1.432"></a><span id="l1.432" class="difflineplus">+   *  constraint helper functions.  This name is somewhat of a misnomer because</span>
<a href="#l1.433"></a><span id="l1.433" class="difflineplus">+   *  special attributes are not 'bound' (because specific/non-generic per-class</span>
<a href="#l1.434"></a><span id="l1.434" class="difflineplus">+   *  code provides the properties) but still depend on this method to</span>
<a href="#l1.435"></a><span id="l1.435" class="difflineplus">+   *  establish their constraint helper methods.</span>
<a href="#l1.436"></a><span id="l1.436" class="difflineplus">+   *</span>
<a href="#l1.437"></a><span id="l1.437" class="difflineplus">+   * @XXX potentially rename to not suggest binding is required.</span>
<a href="#l1.438"></a><span id="l1.438" class="difflineplus">+   */</span>
<a href="#l1.439"></a><span id="l1.439">   _bindAttribute: function gloda_ns_bindAttr(aAttr, aSubjectType, aObjectType,</span>
<a href="#l1.440"></a><span id="l1.440">                                              aSingular, aDoBind, aBindName) {</span>
<a href="#l1.441"></a><span id="l1.441">     if (!(aSubjectType in this._nounIDToMeta))</span>
<a href="#l1.442"></a><span id="l1.442">       throw Error(&quot;Invalid subject type: &quot; + aSubjectType);</span>
<a href="#l1.443"></a><span id="l1.443">     </span>
<a href="#l1.444"></a><span id="l1.444">     let nounMeta = this._nounIDToMeta[aObjectType];</span>
<a href="#l1.445"></a><span id="l1.445">     let subjectNounMeta = this._nounIDToMeta[aSubjectType];</span>
<a href="#l1.446"></a><span id="l1.446">     </span>
<a href="#l1.447"></a><span id="l1.447" class="difflineat">@@ -811,38 +1011,90 @@ let Gloda = {</span>
<a href="#l1.448"></a><span id="l1.448">     }</span>
<a href="#l1.449"></a><span id="l1.449"> </span>
<a href="#l1.450"></a><span id="l1.450">     this._attrProviders[aAttrDef.provider.providerName].push(attr);</span>
<a href="#l1.451"></a><span id="l1.451">     if (!objectNounMeta.usesParameter)</span>
<a href="#l1.452"></a><span id="l1.452">       GlodaDatastore._attributeIDToDef[attrID] = [attr, null];</span>
<a href="#l1.453"></a><span id="l1.453">     return attr;</span>
<a href="#l1.454"></a><span id="l1.454">   },</span>
<a href="#l1.455"></a><span id="l1.455">   </span>
<a href="#l1.456"></a><span id="l1.456" class="difflineplus">+  /**</span>
<a href="#l1.457"></a><span id="l1.457" class="difflineplus">+   * Retrieve the attribute provided by the given extension with the given</span>
<a href="#l1.458"></a><span id="l1.458" class="difflineplus">+   *  attribute name.  The original idea was that plugins would effectively</span>
<a href="#l1.459"></a><span id="l1.459" class="difflineplus">+   *  name-space attributes, helping avoid collisions.  Since we are leaning</span>
<a href="#l1.460"></a><span id="l1.460" class="difflineplus">+   *  towards using binding heavily, this doesn't really help, as the collisions</span>
<a href="#l1.461"></a><span id="l1.461" class="difflineplus">+   *  will just occur on the attribute name instead.  Also, this can turn</span>
<a href="#l1.462"></a><span id="l1.462" class="difflineplus">+   *  extensions into liars as name changes/moves to core/etc. happen.</span>
<a href="#l1.463"></a><span id="l1.463" class="difflineplus">+   * @TODO consider removing the extension name argument parameter requirement</span>
<a href="#l1.464"></a><span id="l1.464" class="difflineplus">+   */</span>
<a href="#l1.465"></a><span id="l1.465">   getAttrDef: function gloda_ns_getAttrDef(aPluginName, aAttrName) {</span>
<a href="#l1.466"></a><span id="l1.466">     let compoundName = aPluginName + &quot;:&quot; + aAttrName;</span>
<a href="#l1.467"></a><span id="l1.467">     return GlodaDatastore._attributes[compoundName];</span>
<a href="#l1.468"></a><span id="l1.468">   },</span>
<a href="#l1.469"></a><span id="l1.469">   </span>
<a href="#l1.470"></a><span id="l1.470">   /**</span>
<a href="#l1.471"></a><span id="l1.471" class="difflineminus">-   * Define a table for plug-ins.  The argument should be a dictionary with</span>
<a href="#l1.472"></a><span id="l1.472" class="difflineminus">-   *  the following keys:</span>
<a href="#l1.473"></a><span id="l1.473" class="difflineplus">+   * Define a SQL table for plug-ins.  This is intended to be used by</span>
<a href="#l1.474"></a><span id="l1.474" class="difflineplus">+   *  extensions/plug-ins whose storage needs exceed those provided by the</span>
<a href="#l1.475"></a><span id="l1.475" class="difflineplus">+   *  attribute parameter (on the attribute definition)/attribute value (on the</span>
<a href="#l1.476"></a><span id="l1.476" class="difflineplus">+   *  attribute instance) idiom.  (This includes extensions whose parameter</span>
<a href="#l1.477"></a><span id="l1.477" class="difflineplus">+   *  usage would exceed acceptable cardinality.)  They can create a table</span>
<a href="#l1.478"></a><span id="l1.478" class="difflineplus">+   *  to store information on their nouns, using their row id (commonly &quot;id&quot;)</span>
<a href="#l1.479"></a><span id="l1.479" class="difflineplus">+   *  as the attribute value.</span>
<a href="#l1.480"></a><span id="l1.480" class="difflineplus">+   * The current implementation was for a prototype and this should not be</span>
<a href="#l1.481"></a><span id="l1.481" class="difflineplus">+   *  interpreted as our final approach.  Our goal is just to make it easy to</span>
<a href="#l1.482"></a><span id="l1.482" class="difflineplus">+   *  add your own data-type and have it interact with the rest of the gloda</span>
<a href="#l1.483"></a><span id="l1.483" class="difflineplus">+   *  schema.  We don't really want to be a be-all, end-all JS ORM (object</span>
<a href="#l1.484"></a><span id="l1.484" class="difflineplus">+   *  relational mapper), though we started down that road.</span>
<a href="#l1.485"></a><span id="l1.485" class="difflineplus">+   *</span>
<a href="#l1.486"></a><span id="l1.486" class="difflineplus">+   * The argument should be a dictionary with the following keys:</span>
<a href="#l1.487"></a><span id="l1.487">    * @param name The table name; don't conflict with other things!</span>
<a href="#l1.488"></a><span id="l1.488">    * @param columns A list of [column name, sqlite type] tuples.  You should</span>
<a href="#l1.489"></a><span id="l1.489">    *     always include a definition like [&quot;id&quot;, &quot;INTEGER PRIMARY KEY&quot;] for</span>
<a href="#l1.490"></a><span id="l1.490">    *     now.</span>
<a href="#l1.491"></a><span id="l1.491">    * @param indices A dictionary of lists of column names, where the key name</span>
<a href="#l1.492"></a><span id="l1.492">    *     becomes the index name.  Ex: {foo: [&quot;bar&quot;]} results in an index on</span>
<a href="#l1.493"></a><span id="l1.493">    *     the column &quot;bar&quot; where the index is named &quot;foo&quot;.</span>
<a href="#l1.494"></a><span id="l1.494">    */</span>
<a href="#l1.495"></a><span id="l1.495">   defineTable: function gloda_ns_defineTable(aTableDef) {</span>
<a href="#l1.496"></a><span id="l1.496">     return GlodaDatastore.createTableIfNotExists(aTableDef);</span>
<a href="#l1.497"></a><span id="l1.497">   },</span>
<a href="#l1.498"></a><span id="l1.498">   </span>
<a href="#l1.499"></a><span id="l1.499">   /**</span>
<a href="#l1.500"></a><span id="l1.500" class="difflineminus">-   * Create a new query for the given noun-type.</span>
<a href="#l1.501"></a><span id="l1.501" class="difflineplus">+   * Create a new query instance for the given noun-type.  This provides</span>
<a href="#l1.502"></a><span id="l1.502" class="difflineplus">+   *  a generic way to provide constraint-based queries of any first-class</span>
<a href="#l1.503"></a><span id="l1.503" class="difflineplus">+   *  nouns supported by the system.</span>
<a href="#l1.504"></a><span id="l1.504" class="difflineplus">+   *</span>
<a href="#l1.505"></a><span id="l1.505" class="difflineplus">+   * The idea is that every attribute on an object can be used to express</span>
<a href="#l1.506"></a><span id="l1.506" class="difflineplus">+   *  a constraint on the query object.  Constraints implicitly 'AND' together,</span>
<a href="#l1.507"></a><span id="l1.507" class="difflineplus">+   *  but providing multiple arguments to a constraint function results in an</span>
<a href="#l1.508"></a><span id="l1.508" class="difflineplus">+   *  'OR'ing of those values.  Additionally, you can call or() on the returned</span>
<a href="#l1.509"></a><span id="l1.509" class="difflineplus">+   *  query to create an alternate query that is effectively a giant OR against</span>
<a href="#l1.510"></a><span id="l1.510" class="difflineplus">+   *  all the constraints you create on the main query object (or any other</span>
<a href="#l1.511"></a><span id="l1.511" class="difflineplus">+   *  alternate queries returned by or()).  (Note: there is no nesting of these</span>
<a href="#l1.512"></a><span id="l1.512" class="difflineplus">+   *  alternate queries. query.or().or() is equivalent to query.or())</span>
<a href="#l1.513"></a><span id="l1.513" class="difflineplus">+   * For each attribute, there is a constraint with the same name that takes</span>
<a href="#l1.514"></a><span id="l1.514" class="difflineplus">+   *  one or more arguments.  The arguments represent a set of OR values that</span>
<a href="#l1.515"></a><span id="l1.515" class="difflineplus">+   *  objects matching the query can have.  (If you want the constraint</span>
<a href="#l1.516"></a><span id="l1.516" class="difflineplus">+   *  effectively ANDed together, just invoke the constraint function</span>
<a href="#l1.517"></a><span id="l1.517" class="difflineplus">+   *  multiple times.)  For example, newQuery(NOUN_PERSON).age(25) would</span>
<a href="#l1.518"></a><span id="l1.518" class="difflineplus">+   *  constraint to all the people aged 25, while age(25, 26) would constrain</span>
<a href="#l1.519"></a><span id="l1.519" class="difflineplus">+   *  to all the people age 25 or 26.</span>
<a href="#l1.520"></a><span id="l1.520" class="difflineplus">+   * For each attribute with a 'continuous' noun, there is a constraint with the</span>
<a href="#l1.521"></a><span id="l1.521" class="difflineplus">+   *  attribute name with &quot;Range&quot; appended.  It takes two arguments which are an</span>
<a href="#l1.522"></a><span id="l1.522" class="difflineplus">+   *  inclusive lower bound and an inclusive lower bound for values in the</span>
<a href="#l1.523"></a><span id="l1.523" class="difflineplus">+   *  range.  If you would like an open-ended range on either side, pass null</span>
<a href="#l1.524"></a><span id="l1.524" class="difflineplus">+   *  for that argument.  If you would like to specify multiple ranges that</span>
<a href="#l1.525"></a><span id="l1.525" class="difflineplus">+   *  should be ORed together, simply pass additional (pairs of) arguments.</span>
<a href="#l1.526"></a><span id="l1.526" class="difflineplus">+   *  For example, newQuery(NOUN_PERSON).age(25,100) would constraint to all</span>
<a href="#l1.527"></a><span id="l1.527" class="difflineplus">+   *  the people who are &gt;= 25 and &lt;= 100.  Likewise age(25, null) would just</span>
<a href="#l1.528"></a><span id="l1.528" class="difflineplus">+   *  return all the people who are 25 or older.  And age(25,30,35,40) would</span>
<a href="#l1.529"></a><span id="l1.529" class="difflineplus">+   *  return people who are either 25-30 or 35-30.</span>
<a href="#l1.530"></a><span id="l1.530" class="difflineplus">+   * There are also full-text constraint columns.  In a nutshell, their</span>
<a href="#l1.531"></a><span id="l1.531" class="difflineplus">+   *  arguments are the strings that should be passed to the SQLite FTS3</span>
<a href="#l1.532"></a><span id="l1.532" class="difflineplus">+   *  MATCH clause.</span>
<a href="#l1.533"></a><span id="l1.533">    */</span>
<a href="#l1.534"></a><span id="l1.534">   newQuery: function gloda_ns_newQuery(aNounID) {</span>
<a href="#l1.535"></a><span id="l1.535">     let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l1.536"></a><span id="l1.536">     return new nounMeta.queryClass();</span>
<a href="#l1.537"></a><span id="l1.537">   },</span>
<a href="#l1.538"></a><span id="l1.538">   </span>
<a href="#l1.539"></a><span id="l1.539">   /**</span>
<a href="#l1.540"></a><span id="l1.540">    * Create a collection/query for the given noun-type that only matches the</span>
<a href="#l1.541"></a><span id="l1.541" class="difflineat">@@ -853,16 +1105,28 @@ let Gloda = {</span>
<a href="#l1.542"></a><span id="l1.542">     let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l1.543"></a><span id="l1.543">     let collection = new GlodaCollection(aItems, null, null)</span>
<a href="#l1.544"></a><span id="l1.544">     let query = new nounMeta.explicitQueryClass(collection);</span>
<a href="#l1.545"></a><span id="l1.545">     collection.query = query;</span>
<a href="#l1.546"></a><span id="l1.546">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l1.547"></a><span id="l1.547">     return collection;</span>
<a href="#l1.548"></a><span id="l1.548">   },</span>
<a href="#l1.549"></a><span id="l1.549">   </span>
<a href="#l1.550"></a><span id="l1.550" class="difflineplus">+  /**</span>
<a href="#l1.551"></a><span id="l1.551" class="difflineplus">+   * Process the given GlodaMessage, determining all the attributes it should</span>
<a href="#l1.552"></a><span id="l1.552" class="difflineplus">+   *  possess.  This should not be publicly exposed here for multiple reasons.</span>
<a href="#l1.553"></a><span id="l1.553" class="difflineplus">+   * What we eventually want is the ability for pluggable (non-message specific)</span>
<a href="#l1.554"></a><span id="l1.554" class="difflineplus">+   *  indexers to be added to the system, and for them to register via this</span>
<a href="#l1.555"></a><span id="l1.555" class="difflineplus">+   *  Gloda interface.  However, we don't want that mechanism directly exposed</span>
<a href="#l1.556"></a><span id="l1.556" class="difflineplus">+   *  to user/extension code, at least in the sense that it seems like we are</span>
<a href="#l1.557"></a><span id="l1.557" class="difflineplus">+   *  suggesting they should use it.</span>
<a href="#l1.558"></a><span id="l1.558" class="difflineplus">+   * This method should probably end up generalized, and implicitly integrated</span>
<a href="#l1.559"></a><span id="l1.559" class="difflineplus">+   *  into things as a result of registering an indexing mechanism for a given</span>
<a href="#l1.560"></a><span id="l1.560" class="difflineplus">+   *  noun type.</span>
<a href="#l1.561"></a><span id="l1.561" class="difflineplus">+   */</span>
<a href="#l1.562"></a><span id="l1.562">   processMessage: function gloda_ns_processMessage(aMessage, aMsgHdr,</span>
<a href="#l1.563"></a><span id="l1.563">                                                    aMimeMsg, aIsNew) {</span>
<a href="#l1.564"></a><span id="l1.564">     // For now, we are ridiculously lazy and simply nuke all existing attributes</span>
<a href="#l1.565"></a><span id="l1.565">     //  before applying the new attributes.</span>
<a href="#l1.566"></a><span id="l1.566">     aMessage._datastore.clearMessageAttributes(aMessage);</span>
<a href="#l1.567"></a><span id="l1.567">     </span>
<a href="#l1.568"></a><span id="l1.568">     let allAttribs = [];</span>
<a href="#l1.569"></a><span id="l1.569">   </span>
<a href="#l1.570"></a><span id="l1.570" class="difflineat">@@ -898,14 +1162,22 @@ let Gloda = {</span>
<a href="#l1.571"></a><span id="l1.571">       }</span>
<a href="#l1.572"></a><span id="l1.572">     }</span>
<a href="#l1.573"></a><span id="l1.573">     </span>
<a href="#l1.574"></a><span id="l1.574">     this._log.debug(&quot;about to insert: &quot; + outAttribs);</span>
<a href="#l1.575"></a><span id="l1.575">     </span>
<a href="#l1.576"></a><span id="l1.576">     GlodaDatastore.insertMessageAttributes(aMessage, outAttribs);</span>
<a href="#l1.577"></a><span id="l1.577">   },</span>
<a href="#l1.578"></a><span id="l1.578">   </span>
<a href="#l1.579"></a><span id="l1.579" class="difflineplus">+  /**</span>
<a href="#l1.580"></a><span id="l1.580" class="difflineplus">+   * Deprecated mechanism for querying for messages.  Use newQuery now,</span>
<a href="#l1.581"></a><span id="l1.581" class="difflineplus">+   *  specifying the message noun id.  Still works for now, but not for long.</span>
<a href="#l1.582"></a><span id="l1.582" class="difflineplus">+   */</span>
<a href="#l1.583"></a><span id="l1.583">   queryMessagesAPV: function gloda_ns_queryMessagesAPV(aAPVs) {</span>
<a href="#l1.584"></a><span id="l1.584">     return GlodaDatastore.queryMessagesAPV(aAPVs);</span>
<a href="#l1.585"></a><span id="l1.585">   },</span>
<a href="#l1.586"></a><span id="l1.586"> };</span>
<a href="#l1.587"></a><span id="l1.587"> </span>
<a href="#l1.588"></a><span id="l1.588" class="difflineplus">+/* and initialize the Gloda object/NS before we return... */</span>
<a href="#l1.589"></a><span id="l1.589"> Gloda._init();</span>
<a href="#l1.590"></a><span id="l1.590" class="difflineplus">+/* but don't forget that we effectively depend on everybody.js too, and</span>
<a href="#l1.591"></a><span id="l1.591" class="difflineplus">+   currently on our importer to be importing that if they need us fully armed</span>
<a href="#l1.592"></a><span id="l1.592" class="difflineplus">+   and operational. */</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

