<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 22195:16c7195a1573d4df9fe392153467fa21664ae12f</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 16c7195a1573d4df9fe392153467fa21664ae12f" />
<meta property="og:url" content="/comm-central/rev/16c7195a1573d4df9fe392153467fa21664ae12f" />
<meta property="og:description" content="Bug 1385573 - whitespace only changes for nsMsgThreadedDBView.cpp, nsMsgXFViewThread.cpp, nsMsgXFVirtualFolderDBView.cpp. r=jorgk" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 16c7195a1573d4df9fe392153467fa21664ae12f 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/16c7195a1573d4df9fe392153467fa21664ae12f">shortlog</a> |
<a href="/comm-central/log/16c7195a1573d4df9fe392153467fa21664ae12f">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/16c7195a1573d4df9fe392153467fa21664ae12f">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/16c7195a1573d4df9fe392153467fa21664ae12f">files</a> |
changeset |
<a href="/comm-central/raw-rev/16c7195a1573d4df9fe392153467fa21664ae12f">raw</a>  | <a href="/comm-central/archive/16c7195a1573d4df9fe392153467fa21664ae12f.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1385573">Bug 1385573</a> - whitespace only changes for nsMsgThreadedDBView.cpp, nsMsgXFViewThread.cpp, nsMsgXFVirtualFolderDBView.cpp. r=jorgk
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#97;&#108;&#116;&#97;&#56;&#56;&#32;&#60;&#97;&#108;&#116;&#97;&#56;&#56;&#62;</td></tr>
<tr><td></td><td class="date age">Fri, 22 Sep 2017 12:57:00 +0200</td></tr>

<tr>
 <td>changeset 22195</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/16c7195a1573d4df9fe392153467fa21664ae12f">16c7195a1573d4df9fe392153467fa21664ae12f</a></td>
</tr>



<tr>
<td>parent 22194</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/2fd8773a88edfdb49aaf9f5532d8f35ca2f6f80f">2fd8773a88edfdb49aaf9f5532d8f35ca2f6f80f</a>
</td>
</tr>

<tr>
<td>child 22196</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/00c6dfa4467952eab4dfd3fbdf097fe89232c399">00c6dfa4467952eab4dfd3fbdf097fe89232c399</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=16c7195a1573d4df9fe392153467fa21664ae12f">13546</a></td></tr>
<tr><td>push user</td><td>mozilla@jorgk.com</td></tr>
<tr><td>push date</td><td class="date age">Fri, 22 Sep 2017 21:49:41 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@00c6dfa44679 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=00c6dfa4467952eab4dfd3fbdf097fe89232c399">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=00c6dfa4467952eab4dfd3fbdf097fe89232c399&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=00c6dfa4467952eab4dfd3fbdf097fe89232c399&newProject=comm-central&newRevision=2a13941913ba2a27ed98f02e750595c75b705969&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=00c6dfa4467952eab4dfd3fbdf097fe89232c399&newProject=comm-central&newRevision=2a13941913ba2a27ed98f02e750595c75b705969&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=00c6dfa4467952eab4dfd3fbdf097fe89232c399&newProject=comm-central&newRevision=2a13941913ba2a27ed98f02e750595c75b705969&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28jorgk%29&revcount=50">jorgk</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1385573">1385573</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1385573">Bug 1385573</a> - whitespace only changes for nsMsgThreadedDBView.cpp, nsMsgXFViewThread.cpp, nsMsgXFVirtualFolderDBView.cpp. r=jorgk</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgThreadedDBView.cpp">mailnews/base/src/nsMsgThreadedDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgThreadedDBView.cpp">file</a> |
<a href="/comm-central/annotate/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgThreadedDBView.cpp">annotate</a> |
<a href="/comm-central/diff/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgThreadedDBView.cpp">diff</a> |
<a href="/comm-central/comparison/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgThreadedDBView.cpp">comparison</a> |
<a href="/comm-central/log/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgThreadedDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgXFViewThread.cpp">mailnews/base/src/nsMsgXFViewThread.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgXFViewThread.cpp">file</a> |
<a href="/comm-central/annotate/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgXFViewThread.cpp">annotate</a> |
<a href="/comm-central/diff/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgXFViewThread.cpp">diff</a> |
<a href="/comm-central/comparison/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgXFViewThread.cpp">comparison</a> |
<a href="/comm-central/log/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgXFViewThread.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">file</a> |
<a href="/comm-central/annotate/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">annotate</a> |
<a href="/comm-central/diff/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">diff</a> |
<a href="/comm-central/comparison/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">comparison</a> |
<a href="/comm-central/log/16c7195a1573d4df9fe392153467fa21664ae12f/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/base/src/nsMsgThreadedDBView.cpp</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgThreadedDBView.cpp</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -6,68 +6,81 @@</span>
<a href="#l1.4"></a><span id="l1.4"> #include &quot;msgCore.h&quot;</span>
<a href="#l1.5"></a><span id="l1.5"> #include &quot;nsMsgThreadedDBView.h&quot;</span>
<a href="#l1.6"></a><span id="l1.6"> #include &quot;nsIMsgHdr.h&quot;</span>
<a href="#l1.7"></a><span id="l1.7"> #include &quot;nsIMsgThread.h&quot;</span>
<a href="#l1.8"></a><span id="l1.8"> #include &quot;nsIDBFolderInfo.h&quot;</span>
<a href="#l1.9"></a><span id="l1.9"> #include &quot;nsIMsgSearchSession.h&quot;</span>
<a href="#l1.10"></a><span id="l1.10"> #include &quot;nsMsgMessageFlags.h&quot;</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-#define MSGHDR_CACHE_LOOK_AHEAD_SIZE  25    // Allocate this more to avoid reallocation on new mail.</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineminus">-#define MSGHDR_CACHE_MAX_SIZE         8192  // Max msghdr cache entries.</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+// Allocate this more to avoid reallocation on new mail.</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+#define MSGHDR_CACHE_LOOK_AHEAD_SIZE  25</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+// Max msghdr cache entries.</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+#define MSGHDR_CACHE_MAX_SIZE         8192</span>
<a href="#l1.18"></a><span id="l1.18"> #define MSGHDR_CACHE_DEFAULT_SIZE     100</span>
<a href="#l1.19"></a><span id="l1.19"> </span>
<a href="#l1.20"></a><span id="l1.20"> nsMsgThreadedDBView::nsMsgThreadedDBView()</span>
<a href="#l1.21"></a><span id="l1.21"> {</span>
<a href="#l1.22"></a><span id="l1.22">   /* member initializers and constructor code */</span>
<a href="#l1.23"></a><span id="l1.23">   m_havePrevView = false;</span>
<a href="#l1.24"></a><span id="l1.24"> }</span>
<a href="#l1.25"></a><span id="l1.25"> </span>
<a href="#l1.26"></a><span id="l1.26"> nsMsgThreadedDBView::~nsMsgThreadedDBView()</span>
<a href="#l1.27"></a><span id="l1.27"> {</span>
<a href="#l1.28"></a><span id="l1.28">   /* destructor code */</span>
<a href="#l1.29"></a><span id="l1.29"> }</span>
<a href="#l1.30"></a><span id="l1.30"> </span>
<a href="#l1.31"></a><span id="l1.31" class="difflineminus">-NS_IMETHODIMP nsMsgThreadedDBView::Open(nsIMsgFolder *folder, nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder, nsMsgViewFlagsTypeValue viewFlags, int32_t *pCount)</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineplus">+nsMsgThreadedDBView::Open(nsIMsgFolder *folder,</span>
<a href="#l1.34"></a><span id="l1.34" class="difflineplus">+                          nsMsgViewSortTypeValue sortType,</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineplus">+                          nsMsgViewSortOrderValue sortOrder,</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineplus">+                          nsMsgViewFlagsTypeValue viewFlags,</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineplus">+                          int32_t *pCount)</span>
<a href="#l1.38"></a><span id="l1.38"> {</span>
<a href="#l1.39"></a><span id="l1.39">   nsresult rv = nsMsgDBView::Open(folder, sortType, sortOrder, viewFlags, pCount);</span>
<a href="#l1.40"></a><span id="l1.40">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.41"></a><span id="l1.41"> </span>
<a href="#l1.42"></a><span id="l1.42">   if (!m_db)</span>
<a href="#l1.43"></a><span id="l1.43">     return NS_ERROR_NULL_POINTER;</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+</span>
<a href="#l1.45"></a><span id="l1.45">   // Preset msg hdr cache size for performance reason.</span>
<a href="#l1.46"></a><span id="l1.46">   int32_t totalMessages, unreadMessages;</span>
<a href="#l1.47"></a><span id="l1.47">   nsCOMPtr &lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l1.48"></a><span id="l1.48">   PersistFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l1.49"></a><span id="l1.49">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineminus">-  // save off sort type and order, view type and flags</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineplus">+  // Save off sort type and order, view type and flags.</span>
<a href="#l1.53"></a><span id="l1.53">   dbFolderInfo-&gt;GetNumUnreadMessages(&amp;unreadMessages);</span>
<a href="#l1.54"></a><span id="l1.54">   dbFolderInfo-&gt;GetNumMessages(&amp;totalMessages);</span>
<a href="#l1.55"></a><span id="l1.55">   if (m_viewFlags &amp; nsMsgViewFlagsType::kUnreadOnly)</span>
<a href="#l1.56"></a><span id="l1.56">   {</span>
<a href="#l1.57"></a><span id="l1.57">     // Set unread msg size + extra entries to avoid reallocation on new mail.</span>
<a href="#l1.58"></a><span id="l1.58">     totalMessages = (uint32_t)unreadMessages+MSGHDR_CACHE_LOOK_AHEAD_SIZE;</span>
<a href="#l1.59"></a><span id="l1.59">   }</span>
<a href="#l1.60"></a><span id="l1.60">   else</span>
<a href="#l1.61"></a><span id="l1.61">   {</span>
<a href="#l1.62"></a><span id="l1.62">     if (totalMessages &gt; MSGHDR_CACHE_MAX_SIZE)</span>
<a href="#l1.63"></a><span id="l1.63" class="difflineminus">-      totalMessages = MSGHDR_CACHE_MAX_SIZE;        // use max default</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineplus">+      // Use max default.</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineplus">+      totalMessages = MSGHDR_CACHE_MAX_SIZE;</span>
<a href="#l1.66"></a><span id="l1.66">     else if (totalMessages &gt; 0)</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineminus">-      totalMessages += MSGHDR_CACHE_LOOK_AHEAD_SIZE;// allocate extra entries to avoid reallocation on new mail.</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineplus">+      // Allocate extra entries to avoid reallocation on new mail.</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineplus">+      totalMessages += MSGHDR_CACHE_LOOK_AHEAD_SIZE;</span>
<a href="#l1.70"></a><span id="l1.70">   }</span>
<a href="#l1.71"></a><span id="l1.71" class="difflineminus">-  // if total messages is 0, then we probably don't have any idea how many headers are in the db</span>
<a href="#l1.72"></a><span id="l1.72" class="difflineminus">-  // so we have no business setting the cache size.</span>
<a href="#l1.73"></a><span id="l1.73" class="difflineplus">+</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineplus">+  // If total messages is 0, then we probably don't have any idea how many</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineplus">+  // headers are in the db so we have no business setting the cache size.</span>
<a href="#l1.76"></a><span id="l1.76">   if (totalMessages &gt; 0)</span>
<a href="#l1.77"></a><span id="l1.77">     m_db-&gt;SetMsgHdrCacheSize((uint32_t)totalMessages);</span>
<a href="#l1.78"></a><span id="l1.78"> </span>
<a href="#l1.79"></a><span id="l1.79">   if (pCount)</span>
<a href="#l1.80"></a><span id="l1.80">     *pCount = 0;</span>
<a href="#l1.81"></a><span id="l1.81" class="difflineplus">+</span>
<a href="#l1.82"></a><span id="l1.82">   rv = InitThreadedView(pCount);</span>
<a href="#l1.83"></a><span id="l1.83"> </span>
<a href="#l1.84"></a><span id="l1.84" class="difflineminus">-  // this is a hack, but we're trying to find a way to correct</span>
<a href="#l1.85"></a><span id="l1.85" class="difflineplus">+  // This is a hack, but we're trying to find a way to correct</span>
<a href="#l1.86"></a><span id="l1.86">   // incorrect total and unread msg counts w/o paying a big</span>
<a href="#l1.87"></a><span id="l1.87">   // performance penalty. So, if we're not threaded, just add</span>
<a href="#l1.88"></a><span id="l1.88">   // up the total and unread messages in the view and see if that</span>
<a href="#l1.89"></a><span id="l1.89">   // matches what the db totals say. Except ignored threads are</span>
<a href="#l1.90"></a><span id="l1.90">   // going to throw us off...hmm. Unless we just look at the</span>
<a href="#l1.91"></a><span id="l1.91">   // unread counts which is what mostly tweaks people anyway...</span>
<a href="#l1.92"></a><span id="l1.92">   int32_t unreadMsgsInView = 0;</span>
<a href="#l1.93"></a><span id="l1.93">   if (!(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l1.94"></a><span id="l1.94" class="difflineat">@@ -76,116 +89,139 @@ NS_IMETHODIMP nsMsgThreadedDBView::Open(</span>
<a href="#l1.95"></a><span id="l1.95">     {</span>
<a href="#l1.96"></a><span id="l1.96">       if (!(m_flags[--i] &amp; nsMsgMessageFlags::Read))</span>
<a href="#l1.97"></a><span id="l1.97">         ++unreadMsgsInView;</span>
<a href="#l1.98"></a><span id="l1.98">     }</span>
<a href="#l1.99"></a><span id="l1.99"> </span>
<a href="#l1.100"></a><span id="l1.100">     if (unreadMessages != unreadMsgsInView)</span>
<a href="#l1.101"></a><span id="l1.101">       m_db-&gt;SyncCounts();</span>
<a href="#l1.102"></a><span id="l1.102">   }</span>
<a href="#l1.103"></a><span id="l1.103" class="difflineplus">+</span>
<a href="#l1.104"></a><span id="l1.104">   m_db-&gt;SetMsgHdrCacheSize(MSGHDR_CACHE_DEFAULT_SIZE);</span>
<a href="#l1.105"></a><span id="l1.105"> </span>
<a href="#l1.106"></a><span id="l1.106">   return rv;</span>
<a href="#l1.107"></a><span id="l1.107"> }</span>
<a href="#l1.108"></a><span id="l1.108"> </span>
<a href="#l1.109"></a><span id="l1.109" class="difflineminus">-NS_IMETHODIMP nsMsgThreadedDBView::Close()</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l1.111"></a><span id="l1.111" class="difflineplus">+nsMsgThreadedDBView::Close()</span>
<a href="#l1.112"></a><span id="l1.112"> {</span>
<a href="#l1.113"></a><span id="l1.113">   return nsMsgDBView::Close();</span>
<a href="#l1.114"></a><span id="l1.114"> }</span>
<a href="#l1.115"></a><span id="l1.115"> </span>
<a href="#l1.116"></a><span id="l1.116" class="difflineminus">-nsresult nsMsgThreadedDBView::InitThreadedView(int32_t *pCount)</span>
<a href="#l1.117"></a><span id="l1.117" class="difflineplus">+nsresult</span>
<a href="#l1.118"></a><span id="l1.118" class="difflineplus">+nsMsgThreadedDBView::InitThreadedView(int32_t *pCount)</span>
<a href="#l1.119"></a><span id="l1.119"> {</span>
<a href="#l1.120"></a><span id="l1.120">   nsresult rv;</span>
<a href="#l1.121"></a><span id="l1.121"> </span>
<a href="#l1.122"></a><span id="l1.122">   m_keys.Clear();</span>
<a href="#l1.123"></a><span id="l1.123">   m_flags.Clear();</span>
<a href="#l1.124"></a><span id="l1.124">   m_levels.Clear();</span>
<a href="#l1.125"></a><span id="l1.125">   m_prevKeys.Clear();</span>
<a href="#l1.126"></a><span id="l1.126">   m_prevFlags.Clear();</span>
<a href="#l1.127"></a><span id="l1.127">   m_prevLevels.Clear();</span>
<a href="#l1.128"></a><span id="l1.128">   m_havePrevView = false;</span>
<a href="#l1.129"></a><span id="l1.129" class="difflineminus">-  nsresult getSortrv = NS_OK; // ### TODO m_db-&gt;GetSortInfo(&amp;sortType, &amp;sortOrder);</span>
<a href="#l1.130"></a><span id="l1.130" class="difflineplus">+  nsresult getSortrv = NS_OK;</span>
<a href="#l1.131"></a><span id="l1.131" class="difflineplus">+  // XXX TODO m_db-&gt;GetSortInfo(&amp;sortType, &amp;sortOrder);</span>
<a href="#l1.132"></a><span id="l1.132"> </span>
<a href="#l1.133"></a><span id="l1.133" class="difflineminus">-  // list all the ids into m_keys.</span>
<a href="#l1.134"></a><span id="l1.134" class="difflineplus">+  // List all the ids into m_keys.</span>
<a href="#l1.135"></a><span id="l1.135">   nsMsgKey startMsg = 0;</span>
<a href="#l1.136"></a><span id="l1.136">   do</span>
<a href="#l1.137"></a><span id="l1.137">   {</span>
<a href="#l1.138"></a><span id="l1.138">     const int32_t kIdChunkSize = 400;</span>
<a href="#l1.139"></a><span id="l1.139">     int32_t  numListed = 0;</span>
<a href="#l1.140"></a><span id="l1.140">     nsMsgKey idArray[kIdChunkSize];</span>
<a href="#l1.141"></a><span id="l1.141">     int32_t  flagArray[kIdChunkSize];</span>
<a href="#l1.142"></a><span id="l1.142">     char     levelArray[kIdChunkSize];</span>
<a href="#l1.143"></a><span id="l1.143"> </span>
<a href="#l1.144"></a><span id="l1.144" class="difflineminus">-    rv = ListThreadIds(&amp;startMsg, (m_viewFlags &amp; nsMsgViewFlagsType::kUnreadOnly) != 0, idArray, flagArray,</span>
<a href="#l1.145"></a><span id="l1.145" class="difflineminus">-      levelArray, kIdChunkSize, &amp;numListed, nullptr);</span>
<a href="#l1.146"></a><span id="l1.146" class="difflineplus">+    rv = ListThreadIds(&amp;startMsg,</span>
<a href="#l1.147"></a><span id="l1.147" class="difflineplus">+                       (m_viewFlags &amp; nsMsgViewFlagsType::kUnreadOnly) != 0,</span>
<a href="#l1.148"></a><span id="l1.148" class="difflineplus">+                       idArray,</span>
<a href="#l1.149"></a><span id="l1.149" class="difflineplus">+                       flagArray,</span>
<a href="#l1.150"></a><span id="l1.150" class="difflineplus">+                       levelArray,</span>
<a href="#l1.151"></a><span id="l1.151" class="difflineplus">+                       kIdChunkSize,</span>
<a href="#l1.152"></a><span id="l1.152" class="difflineplus">+                       &amp;numListed,</span>
<a href="#l1.153"></a><span id="l1.153" class="difflineplus">+                       nullptr);</span>
<a href="#l1.154"></a><span id="l1.154" class="difflineplus">+</span>
<a href="#l1.155"></a><span id="l1.155">     if (NS_SUCCEEDED(rv))</span>
<a href="#l1.156"></a><span id="l1.156">     {</span>
<a href="#l1.157"></a><span id="l1.157">       int32_t numAdded = AddKeys(idArray, flagArray, levelArray, m_sortType, numListed);</span>
<a href="#l1.158"></a><span id="l1.158">       if (pCount)</span>
<a href="#l1.159"></a><span id="l1.159">         *pCount += numAdded;</span>
<a href="#l1.160"></a><span id="l1.160">     }</span>
<a href="#l1.161"></a><span id="l1.161"> </span>
<a href="#l1.162"></a><span id="l1.162">   } while (NS_SUCCEEDED(rv) &amp;&amp; startMsg != nsMsgKey_None);</span>
<a href="#l1.163"></a><span id="l1.163"> </span>
<a href="#l1.164"></a><span id="l1.164">   if (NS_SUCCEEDED(getSortrv))</span>
<a href="#l1.165"></a><span id="l1.165">   {</span>
<a href="#l1.166"></a><span id="l1.166">     rv = InitSort(m_sortType, m_sortOrder);</span>
<a href="#l1.167"></a><span id="l1.167">     SaveSortInfo(m_sortType, m_sortOrder);</span>
<a href="#l1.168"></a><span id="l1.168"> </span>
<a href="#l1.169"></a><span id="l1.169">   }</span>
<a href="#l1.170"></a><span id="l1.170" class="difflineplus">+</span>
<a href="#l1.171"></a><span id="l1.171">   return rv;</span>
<a href="#l1.172"></a><span id="l1.172"> }</span>
<a href="#l1.173"></a><span id="l1.173"> </span>
<a href="#l1.174"></a><span id="l1.174" class="difflineminus">-nsresult nsMsgThreadedDBView::SortThreads(nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder)</span>
<a href="#l1.175"></a><span id="l1.175" class="difflineplus">+nsresult</span>
<a href="#l1.176"></a><span id="l1.176" class="difflineplus">+nsMsgThreadedDBView::SortThreads(nsMsgViewSortTypeValue sortType,</span>
<a href="#l1.177"></a><span id="l1.177" class="difflineplus">+                                 nsMsgViewSortOrderValue sortOrder)</span>
<a href="#l1.178"></a><span id="l1.178"> {</span>
<a href="#l1.179"></a><span id="l1.179" class="difflineminus">-  NS_PRECONDITION(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay, &quot;trying to sort unthreaded threads&quot;);</span>
<a href="#l1.180"></a><span id="l1.180" class="difflineplus">+  NS_PRECONDITION(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay,</span>
<a href="#l1.181"></a><span id="l1.181" class="difflineplus">+                  &quot;trying to sort unthreaded threads&quot;);</span>
<a href="#l1.182"></a><span id="l1.182"> </span>
<a href="#l1.183"></a><span id="l1.183">   uint32_t numThreads = 0;</span>
<a href="#l1.184"></a><span id="l1.184" class="difflineminus">-  // the idea here is that copy the current view,  then build up an m_keys and m_flags array of just the top level</span>
<a href="#l1.185"></a><span id="l1.185" class="difflineminus">-  // messages in the view, and then call nsMsgDBView::Sort(sortType, sortOrder).</span>
<a href="#l1.186"></a><span id="l1.186" class="difflineminus">-  // Then, we expand the threads in the result array that were expanded in the original view (perhaps by copying</span>
<a href="#l1.187"></a><span id="l1.187" class="difflineminus">-  // from the original view, but more likely just be calling expand).</span>
<a href="#l1.188"></a><span id="l1.188" class="difflineplus">+  // The idea here is that copy the current view, then build up an m_keys and</span>
<a href="#l1.189"></a><span id="l1.189" class="difflineplus">+  // m_flags array of just the top level messages in the view, and then call</span>
<a href="#l1.190"></a><span id="l1.190" class="difflineplus">+  // nsMsgDBView::Sort(sortType, sortOrder).</span>
<a href="#l1.191"></a><span id="l1.191" class="difflineplus">+  // Then, we expand the threads in the result array that were expanded in the</span>
<a href="#l1.192"></a><span id="l1.192" class="difflineplus">+  // original view (perhaps by copying from the original view, but more likely</span>
<a href="#l1.193"></a><span id="l1.193" class="difflineplus">+  // just be calling expand).</span>
<a href="#l1.194"></a><span id="l1.194">   for (uint32_t i = 0; i &lt; m_keys.Length(); i++)</span>
<a href="#l1.195"></a><span id="l1.195">   {</span>
<a href="#l1.196"></a><span id="l1.196">     if (m_flags[i] &amp; MSG_VIEW_FLAG_ISTHREAD)</span>
<a href="#l1.197"></a><span id="l1.197">     {</span>
<a href="#l1.198"></a><span id="l1.198">       if (numThreads &lt; i)</span>
<a href="#l1.199"></a><span id="l1.199">       {</span>
<a href="#l1.200"></a><span id="l1.200">         m_keys[numThreads] = m_keys[i];</span>
<a href="#l1.201"></a><span id="l1.201">         m_flags[numThreads] = m_flags[i];</span>
<a href="#l1.202"></a><span id="l1.202">       }</span>
<a href="#l1.203"></a><span id="l1.203" class="difflineplus">+</span>
<a href="#l1.204"></a><span id="l1.204">       m_levels[numThreads] = 0;</span>
<a href="#l1.205"></a><span id="l1.205">       numThreads++;</span>
<a href="#l1.206"></a><span id="l1.206">     }</span>
<a href="#l1.207"></a><span id="l1.207">   }</span>
<a href="#l1.208"></a><span id="l1.208" class="difflineplus">+</span>
<a href="#l1.209"></a><span id="l1.209">   m_keys.SetLength(numThreads);</span>
<a href="#l1.210"></a><span id="l1.210">   m_flags.SetLength(numThreads);</span>
<a href="#l1.211"></a><span id="l1.211">   m_levels.SetLength(numThreads);</span>
<a href="#l1.212"></a><span id="l1.212">   //m_viewFlags &amp;= ~nsMsgViewFlagsType::kThreadedDisplay;</span>
<a href="#l1.213"></a><span id="l1.213">   m_sortType = nsMsgViewSortType::byNone; // sort from scratch</span>
<a href="#l1.214"></a><span id="l1.214">   nsMsgDBView::Sort(sortType, sortOrder);</span>
<a href="#l1.215"></a><span id="l1.215">   m_viewFlags |= nsMsgViewFlagsType::kThreadedDisplay;</span>
<a href="#l1.216"></a><span id="l1.216">   SetSuppressChangeNotifications(true);</span>
<a href="#l1.217"></a><span id="l1.217" class="difflineminus">-  // Loop through the original array, for each thread that's expanded, find it in the new array</span>
<a href="#l1.218"></a><span id="l1.218" class="difflineminus">-  // and expand the thread. We have to update MSG_VIEW_FLAG_HAS_CHILDREN because</span>
<a href="#l1.219"></a><span id="l1.219" class="difflineminus">-  // we may be going from a flat sort, which doesn't maintain that flag,</span>
<a href="#l1.220"></a><span id="l1.220" class="difflineminus">-  // to a threaded sort, which requires that flag.</span>
<a href="#l1.221"></a><span id="l1.221" class="difflineplus">+</span>
<a href="#l1.222"></a><span id="l1.222" class="difflineplus">+  // Loop through the original array, for each thread that's expanded,</span>
<a href="#l1.223"></a><span id="l1.223" class="difflineplus">+  // find it in the new array and expand the thread. We have to update</span>
<a href="#l1.224"></a><span id="l1.224" class="difflineplus">+  // MSG_VIEW_FLAG_HAS_CHILDREN because we may be going from a flat sort,</span>
<a href="#l1.225"></a><span id="l1.225" class="difflineplus">+  // which doesn't maintain that flag, to a threaded sort, which requires</span>
<a href="#l1.226"></a><span id="l1.226" class="difflineplus">+  // that flag.</span>
<a href="#l1.227"></a><span id="l1.227">   for (uint32_t j = 0; j &lt; m_keys.Length(); j++)</span>
<a href="#l1.228"></a><span id="l1.228">   {</span>
<a href="#l1.229"></a><span id="l1.229">     uint32_t flags = m_flags[j];</span>
<a href="#l1.230"></a><span id="l1.230" class="difflineminus">-    if ((flags &amp; (MSG_VIEW_FLAG_HASCHILDREN | nsMsgMessageFlags::Elided)) == MSG_VIEW_FLAG_HASCHILDREN)</span>
<a href="#l1.231"></a><span id="l1.231" class="difflineplus">+    if ((flags &amp; (MSG_VIEW_FLAG_HASCHILDREN |</span>
<a href="#l1.232"></a><span id="l1.232" class="difflineplus">+                  nsMsgMessageFlags::Elided)) == MSG_VIEW_FLAG_HASCHILDREN)</span>
<a href="#l1.233"></a><span id="l1.233">     {</span>
<a href="#l1.234"></a><span id="l1.234">       uint32_t numExpanded;</span>
<a href="#l1.235"></a><span id="l1.235">       m_flags[j] = flags | nsMsgMessageFlags::Elided;</span>
<a href="#l1.236"></a><span id="l1.236">       ExpandByIndex(j, &amp;numExpanded);</span>
<a href="#l1.237"></a><span id="l1.237">       j += numExpanded;</span>
<a href="#l1.238"></a><span id="l1.238">       if (numExpanded &gt; 0)</span>
<a href="#l1.239"></a><span id="l1.239">         m_flags[j - numExpanded] = flags | MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l1.240"></a><span id="l1.240">     }</span>
<a href="#l1.241"></a><span id="l1.241" class="difflineminus">-    else if (flags &amp; MSG_VIEW_FLAG_ISTHREAD &amp;&amp; ! (flags &amp; MSG_VIEW_FLAG_HASCHILDREN))</span>
<a href="#l1.242"></a><span id="l1.242" class="difflineplus">+    else if (flags &amp; MSG_VIEW_FLAG_ISTHREAD &amp;&amp;</span>
<a href="#l1.243"></a><span id="l1.243" class="difflineplus">+             !(flags &amp; MSG_VIEW_FLAG_HASCHILDREN))</span>
<a href="#l1.244"></a><span id="l1.244">     {</span>
<a href="#l1.245"></a><span id="l1.245">       nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l1.246"></a><span id="l1.246">       nsCOMPtr &lt;nsIMsgThread&gt; pThread;</span>
<a href="#l1.247"></a><span id="l1.247">       m_db-&gt;GetMsgHdrForKey(m_keys[j], getter_AddRefs(msgHdr));</span>
<a href="#l1.248"></a><span id="l1.248">       if (msgHdr)</span>
<a href="#l1.249"></a><span id="l1.249">       {</span>
<a href="#l1.250"></a><span id="l1.250">         m_db-&gt;GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(pThread));</span>
<a href="#l1.251"></a><span id="l1.251">         if (pThread)</span>
<a href="#l1.252"></a><span id="l1.252" class="difflineat">@@ -193,408 +229,508 @@ nsresult nsMsgThreadedDBView::SortThread</span>
<a href="#l1.253"></a><span id="l1.253">           uint32_t numChildren;</span>
<a href="#l1.254"></a><span id="l1.254">           pThread-&gt;GetNumChildren(&amp;numChildren);</span>
<a href="#l1.255"></a><span id="l1.255">           if (numChildren &gt; 1)</span>
<a href="#l1.256"></a><span id="l1.256">             m_flags[j] = flags | MSG_VIEW_FLAG_HASCHILDREN | nsMsgMessageFlags::Elided;</span>
<a href="#l1.257"></a><span id="l1.257">         }</span>
<a href="#l1.258"></a><span id="l1.258">       }</span>
<a href="#l1.259"></a><span id="l1.259">     }</span>
<a href="#l1.260"></a><span id="l1.260">   }</span>
<a href="#l1.261"></a><span id="l1.261" class="difflineplus">+</span>
<a href="#l1.262"></a><span id="l1.262">   SetSuppressChangeNotifications(false);</span>
<a href="#l1.263"></a><span id="l1.263"> </span>
<a href="#l1.264"></a><span id="l1.264">   return NS_OK;</span>
<a href="#l1.265"></a><span id="l1.265"> }</span>
<a href="#l1.266"></a><span id="l1.266"> </span>
<a href="#l1.267"></a><span id="l1.267" class="difflineminus">-int32_t nsMsgThreadedDBView::AddKeys(nsMsgKey *pKeys, int32_t *pFlags, const char *pLevels, nsMsgViewSortTypeValue sortType, int32_t numKeysToAdd)</span>
<a href="#l1.268"></a><span id="l1.268" class="difflineminus">-</span>
<a href="#l1.269"></a><span id="l1.269" class="difflineplus">+int32_t</span>
<a href="#l1.270"></a><span id="l1.270" class="difflineplus">+nsMsgThreadedDBView::AddKeys(nsMsgKey *pKeys,</span>
<a href="#l1.271"></a><span id="l1.271" class="difflineplus">+                             int32_t *pFlags,</span>
<a href="#l1.272"></a><span id="l1.272" class="difflineplus">+                             const char *pLevels,</span>
<a href="#l1.273"></a><span id="l1.273" class="difflineplus">+                             nsMsgViewSortTypeValue sortType,</span>
<a href="#l1.274"></a><span id="l1.274" class="difflineplus">+                             int32_t numKeysToAdd)</span>
<a href="#l1.275"></a><span id="l1.275"> {</span>
<a href="#l1.276"></a><span id="l1.276" class="difflineminus">-  int32_t	numAdded = 0;</span>
<a href="#l1.277"></a><span id="l1.277" class="difflineplus">+  int32_t numAdded = 0;</span>
<a href="#l1.278"></a><span id="l1.278">   // Allocate enough space first to avoid memory allocation/deallocation.</span>
<a href="#l1.279"></a><span id="l1.279">   m_keys.SetCapacity(m_keys.Length() + numKeysToAdd);</span>
<a href="#l1.280"></a><span id="l1.280">   m_flags.SetCapacity(m_flags.Length() + numKeysToAdd);</span>
<a href="#l1.281"></a><span id="l1.281">   m_levels.SetCapacity(m_levels.Length() + numKeysToAdd);</span>
<a href="#l1.282"></a><span id="l1.282">   for (int32_t i = 0; i &lt; numKeysToAdd; i++)</span>
<a href="#l1.283"></a><span id="l1.283">   {</span>
<a href="#l1.284"></a><span id="l1.284">     int32_t threadFlag = pFlags[i];</span>
<a href="#l1.285"></a><span id="l1.285">     int32_t flag = threadFlag;</span>
<a href="#l1.286"></a><span id="l1.286"> </span>
<a href="#l1.287"></a><span id="l1.287" class="difflineminus">-    // skip ignored threads.</span>
<a href="#l1.288"></a><span id="l1.288" class="difflineplus">+    // Skip ignored threads.</span>
<a href="#l1.289"></a><span id="l1.289">     if ((threadFlag &amp; nsMsgMessageFlags::Ignored) &amp;&amp; !(m_viewFlags &amp; nsMsgViewFlagsType::kShowIgnored))</span>
<a href="#l1.290"></a><span id="l1.290">       continue;</span>
<a href="#l1.291"></a><span id="l1.291"> </span>
<a href="#l1.292"></a><span id="l1.292" class="difflineminus">-    // skip ignored subthreads</span>
<a href="#l1.293"></a><span id="l1.293" class="difflineplus">+    // Skip ignored subthreads</span>
<a href="#l1.294"></a><span id="l1.294">     nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l1.295"></a><span id="l1.295">     m_db-&gt;GetMsgHdrForKey(pKeys[i], getter_AddRefs(msgHdr));</span>
<a href="#l1.296"></a><span id="l1.296">     if (!(m_viewFlags &amp; nsMsgViewFlagsType::kShowIgnored))</span>
<a href="#l1.297"></a><span id="l1.297">     {</span>
<a href="#l1.298"></a><span id="l1.298">       bool killed;</span>
<a href="#l1.299"></a><span id="l1.299">       msgHdr-&gt;GetIsKilled(&amp;killed);</span>
<a href="#l1.300"></a><span id="l1.300">       if (killed)</span>
<a href="#l1.301"></a><span id="l1.301">         continue;</span>
<a href="#l1.302"></a><span id="l1.302">     }</span>
<a href="#l1.303"></a><span id="l1.303"> </span>
<a href="#l1.304"></a><span id="l1.304" class="difflineminus">-    // by default, make threads collapsed, unless we're in only viewing new msgs</span>
<a href="#l1.305"></a><span id="l1.305" class="difflineplus">+    // By default, make threads collapsed unless we're only viewing new msgs.</span>
<a href="#l1.306"></a><span id="l1.306"> </span>
<a href="#l1.307"></a><span id="l1.307">     if (flag &amp; MSG_VIEW_FLAG_HASCHILDREN)</span>
<a href="#l1.308"></a><span id="l1.308">       flag |= nsMsgMessageFlags::Elided;</span>
<a href="#l1.309"></a><span id="l1.309" class="difflineminus">-    // should this be persistent? Doesn't seem to need to be.</span>
<a href="#l1.310"></a><span id="l1.310" class="difflineplus">+</span>
<a href="#l1.311"></a><span id="l1.311" class="difflineplus">+    // Should this be persistent? Doesn't seem to need to be.</span>
<a href="#l1.312"></a><span id="l1.312">     flag |= MSG_VIEW_FLAG_ISTHREAD;</span>
<a href="#l1.313"></a><span id="l1.313">     m_keys.AppendElement(pKeys[i]);</span>
<a href="#l1.314"></a><span id="l1.314">     m_flags.AppendElement(flag);</span>
<a href="#l1.315"></a><span id="l1.315">     m_levels.AppendElement(pLevels[i]);</span>
<a href="#l1.316"></a><span id="l1.316">     numAdded++;</span>
<a href="#l1.317"></a><span id="l1.317" class="difflineminus">-    // we expand as we build the view, which allows us to insert at the end of the key array,</span>
<a href="#l1.318"></a><span id="l1.318" class="difflineminus">-    // instead of the middle, and is much faster.</span>
<a href="#l1.319"></a><span id="l1.319" class="difflineminus">-    if ((!(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay) || m_viewFlags &amp; nsMsgViewFlagsType::kExpandAll) &amp;&amp; flag &amp; nsMsgMessageFlags::Elided)</span>
<a href="#l1.320"></a><span id="l1.320" class="difflineplus">+</span>
<a href="#l1.321"></a><span id="l1.321" class="difflineplus">+    // We expand as we build the view, which allows us to insert at the end</span>
<a href="#l1.322"></a><span id="l1.322" class="difflineplus">+    // of the key array, instead of the middle, and is much faster.</span>
<a href="#l1.323"></a><span id="l1.323" class="difflineplus">+    if ((!(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay) ||</span>
<a href="#l1.324"></a><span id="l1.324" class="difflineplus">+         m_viewFlags &amp; nsMsgViewFlagsType::kExpandAll) &amp;&amp;</span>
<a href="#l1.325"></a><span id="l1.325" class="difflineplus">+        flag &amp; nsMsgMessageFlags::Elided)</span>
<a href="#l1.326"></a><span id="l1.326" class="difflineplus">+    {</span>
<a href="#l1.327"></a><span id="l1.327">        ExpandByIndex(m_keys.Length() - 1, NULL);</span>
<a href="#l1.328"></a><span id="l1.328" class="difflineplus">+    }</span>
<a href="#l1.329"></a><span id="l1.329">   }</span>
<a href="#l1.330"></a><span id="l1.330" class="difflineplus">+</span>
<a href="#l1.331"></a><span id="l1.331">   return numAdded;</span>
<a href="#l1.332"></a><span id="l1.332"> }</span>
<a href="#l1.333"></a><span id="l1.333"> </span>
<a href="#l1.334"></a><span id="l1.334" class="difflineminus">-NS_IMETHODIMP nsMsgThreadedDBView::Sort(nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder)</span>
<a href="#l1.335"></a><span id="l1.335" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l1.336"></a><span id="l1.336" class="difflineplus">+nsMsgThreadedDBView::Sort(nsMsgViewSortTypeValue sortType,</span>
<a href="#l1.337"></a><span id="l1.337" class="difflineplus">+                          nsMsgViewSortOrderValue sortOrder)</span>
<a href="#l1.338"></a><span id="l1.338"> {</span>
<a href="#l1.339"></a><span id="l1.339">   nsresult rv;</span>
<a href="#l1.340"></a><span id="l1.340"> </span>
<a href="#l1.341"></a><span id="l1.341">   int32_t rowCountBeforeSort = GetSize();</span>
<a href="#l1.342"></a><span id="l1.342"> </span>
<a href="#l1.343"></a><span id="l1.343">   if (!rowCountBeforeSort)</span>
<a href="#l1.344"></a><span id="l1.344">   {</span>
<a href="#l1.345"></a><span id="l1.345" class="difflineminus">-    // still need to setup our flags even when no articles - bug 98183.</span>
<a href="#l1.346"></a><span id="l1.346" class="difflineplus">+    // Still need to setup our flags even when no articles - bug 98183.</span>
<a href="#l1.347"></a><span id="l1.347">     m_sortType = sortType;</span>
<a href="#l1.348"></a><span id="l1.348" class="difflineminus">-    if (sortType == nsMsgViewSortType::byThread &amp;&amp; ! (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l1.349"></a><span id="l1.349" class="difflineplus">+    if (sortType == nsMsgViewSortType::byThread &amp;&amp;</span>
<a href="#l1.350"></a><span id="l1.350" class="difflineplus">+        !(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l1.351"></a><span id="l1.351" class="difflineplus">+    {</span>
<a href="#l1.352"></a><span id="l1.352">       SetViewFlags(m_viewFlags | nsMsgViewFlagsType::kThreadedDisplay);</span>
<a href="#l1.353"></a><span id="l1.353" class="difflineplus">+    }</span>
<a href="#l1.354"></a><span id="l1.354" class="difflineplus">+</span>
<a href="#l1.355"></a><span id="l1.355">     SaveSortInfo(sortType, sortOrder);</span>
<a href="#l1.356"></a><span id="l1.356">     return NS_OK;</span>
<a href="#l1.357"></a><span id="l1.357">   }</span>
<a href="#l1.358"></a><span id="l1.358"> </span>
<a href="#l1.359"></a><span id="l1.359">   if (!m_checkedCustomColumns &amp;&amp; CustomColumnsInSortAndNotRegistered())</span>
<a href="#l1.360"></a><span id="l1.360">     return NS_OK;</span>
<a href="#l1.361"></a><span id="l1.361"> </span>
<a href="#l1.362"></a><span id="l1.362" class="difflineminus">-  // sort threads by sort order</span>
<a href="#l1.363"></a><span id="l1.363" class="difflineminus">-  bool sortThreads = m_viewFlags &amp; (nsMsgViewFlagsType::kThreadedDisplay | nsMsgViewFlagsType::kGroupBySort);</span>
<a href="#l1.364"></a><span id="l1.364" class="difflineplus">+  // Sort threads by sort order.</span>
<a href="#l1.365"></a><span id="l1.365" class="difflineplus">+  bool sortThreads = m_viewFlags &amp; (nsMsgViewFlagsType::kThreadedDisplay |</span>
<a href="#l1.366"></a><span id="l1.366" class="difflineplus">+                                    nsMsgViewFlagsType::kGroupBySort);</span>
<a href="#l1.367"></a><span id="l1.367"> </span>
<a href="#l1.368"></a><span id="l1.368" class="difflineminus">-  // if sort type is by thread, and we're already threaded, change sort type to byId</span>
<a href="#l1.369"></a><span id="l1.369" class="difflineminus">-  if (sortType == nsMsgViewSortType::byThread &amp;&amp; (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay) != 0)</span>
<a href="#l1.370"></a><span id="l1.370" class="difflineplus">+  // If sort type is by thread, and we're already threaded, change sort type</span>
<a href="#l1.371"></a><span id="l1.371" class="difflineplus">+  // to byId.</span>
<a href="#l1.372"></a><span id="l1.372" class="difflineplus">+  if (sortType == nsMsgViewSortType::byThread &amp;&amp;</span>
<a href="#l1.373"></a><span id="l1.373" class="difflineplus">+      (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay) != 0)</span>
<a href="#l1.374"></a><span id="l1.374" class="difflineplus">+  {</span>
<a href="#l1.375"></a><span id="l1.375">     sortType = nsMsgViewSortType::byId;</span>
<a href="#l1.376"></a><span id="l1.376" class="difflineplus">+  }</span>
<a href="#l1.377"></a><span id="l1.377"> </span>
<a href="#l1.378"></a><span id="l1.378">   nsMsgKey preservedKey;</span>
<a href="#l1.379"></a><span id="l1.379">   AutoTArray&lt;nsMsgKey, 1&gt; preservedSelection;</span>
<a href="#l1.380"></a><span id="l1.380">   SaveAndClearSelection(&amp;preservedKey, preservedSelection);</span>
<a href="#l1.381"></a><span id="l1.381" class="difflineminus">-  // if the client wants us to forget our cached id arrays, they</span>
<a href="#l1.382"></a><span id="l1.382" class="difflineplus">+  // If the client wants us to forget our cached id arrays, they</span>
<a href="#l1.383"></a><span id="l1.383">   // should build a new view. If this isn't good enough, we</span>
<a href="#l1.384"></a><span id="l1.384">   // need a method to do that.</span>
<a href="#l1.385"></a><span id="l1.385">   if (sortType != m_sortType || !m_sortValid || sortThreads)</span>
<a href="#l1.386"></a><span id="l1.386">   {</span>
<a href="#l1.387"></a><span id="l1.387">     SaveSortInfo(sortType, sortOrder);</span>
<a href="#l1.388"></a><span id="l1.388">     if (sortType == nsMsgViewSortType::byThread)</span>
<a href="#l1.389"></a><span id="l1.389">     {</span>
<a href="#l1.390"></a><span id="l1.390">       m_sortType = sortType;</span>
<a href="#l1.391"></a><span id="l1.391">       m_viewFlags |= nsMsgViewFlagsType::kThreadedDisplay;</span>
<a href="#l1.392"></a><span id="l1.392">       m_viewFlags &amp;= ~nsMsgViewFlagsType::kGroupBySort;</span>
<a href="#l1.393"></a><span id="l1.393">       if ( m_havePrevView)</span>
<a href="#l1.394"></a><span id="l1.394">       {</span>
<a href="#l1.395"></a><span id="l1.395" class="difflineminus">-        // restore saved id array and flags array</span>
<a href="#l1.396"></a><span id="l1.396" class="difflineplus">+        // Restore saved id array and flags array.</span>
<a href="#l1.397"></a><span id="l1.397">         m_keys = m_prevKeys;</span>
<a href="#l1.398"></a><span id="l1.398">         m_flags = m_prevFlags;</span>
<a href="#l1.399"></a><span id="l1.399">         m_levels = m_prevLevels;</span>
<a href="#l1.400"></a><span id="l1.400">         m_sortValid = true;</span>
<a href="#l1.401"></a><span id="l1.401"> </span>
<a href="#l1.402"></a><span id="l1.402" class="difflineminus">-        // the sort may have changed the number of rows</span>
<a href="#l1.403"></a><span id="l1.403" class="difflineplus">+        // The sort may have changed the number of rows</span>
<a href="#l1.404"></a><span id="l1.404">         // before we restore the selection, tell the tree</span>
<a href="#l1.405"></a><span id="l1.405">         // do this before we call restore selection</span>
<a href="#l1.406"></a><span id="l1.406">         // this is safe when there is no selection.</span>
<a href="#l1.407"></a><span id="l1.407">         rv = AdjustRowCount(rowCountBeforeSort, GetSize());</span>
<a href="#l1.408"></a><span id="l1.408"> </span>
<a href="#l1.409"></a><span id="l1.409">         RestoreSelection(preservedKey, preservedSelection);</span>
<a href="#l1.410"></a><span id="l1.410" class="difflineminus">-        if (mTree) mTree-&gt;Invalidate();</span>
<a href="#l1.411"></a><span id="l1.411" class="difflineplus">+        if (mTree)</span>
<a href="#l1.412"></a><span id="l1.412" class="difflineplus">+          mTree-&gt;Invalidate();</span>
<a href="#l1.413"></a><span id="l1.413" class="difflineplus">+</span>
<a href="#l1.414"></a><span id="l1.414">         return NS_OK;</span>
<a href="#l1.415"></a><span id="l1.415">       }</span>
<a href="#l1.416"></a><span id="l1.416">       else</span>
<a href="#l1.417"></a><span id="l1.417">       {</span>
<a href="#l1.418"></a><span id="l1.418" class="difflineminus">-        // set sort info in anticipation of what Init will do.</span>
<a href="#l1.419"></a><span id="l1.419" class="difflineminus">-        InitThreadedView(nullptr);	// build up thread list.</span>
<a href="#l1.420"></a><span id="l1.420" class="difflineplus">+        // Set sort info in anticipation of what Init will do.</span>
<a href="#l1.421"></a><span id="l1.421" class="difflineplus">+        // Build up thread list.</span>
<a href="#l1.422"></a><span id="l1.422" class="difflineplus">+        InitThreadedView(nullptr);</span>
<a href="#l1.423"></a><span id="l1.423">         if (sortOrder != nsMsgViewSortOrder::ascending)</span>
<a href="#l1.424"></a><span id="l1.424">           Sort(sortType, sortOrder);</span>
<a href="#l1.425"></a><span id="l1.425"> </span>
<a href="#l1.426"></a><span id="l1.426" class="difflineminus">-        // the sort may have changed the number of rows</span>
<a href="#l1.427"></a><span id="l1.427" class="difflineplus">+        // The sort may have changed the number of rows</span>
<a href="#l1.428"></a><span id="l1.428">         // before we update the selection, tell the tree</span>
<a href="#l1.429"></a><span id="l1.429">         // do this before we call restore selection</span>
<a href="#l1.430"></a><span id="l1.430">         // this is safe when there is no selection.</span>
<a href="#l1.431"></a><span id="l1.431">         rv = AdjustRowCount(rowCountBeforeSort, GetSize());</span>
<a href="#l1.432"></a><span id="l1.432"> </span>
<a href="#l1.433"></a><span id="l1.433">         RestoreSelection(preservedKey, preservedSelection);</span>
<a href="#l1.434"></a><span id="l1.434" class="difflineminus">-        if (mTree) mTree-&gt;Invalidate();</span>
<a href="#l1.435"></a><span id="l1.435" class="difflineplus">+        if (mTree)</span>
<a href="#l1.436"></a><span id="l1.436" class="difflineplus">+          mTree-&gt;Invalidate();</span>
<a href="#l1.437"></a><span id="l1.437" class="difflineplus">+</span>
<a href="#l1.438"></a><span id="l1.438">         return NS_OK;</span>
<a href="#l1.439"></a><span id="l1.439">       }</span>
<a href="#l1.440"></a><span id="l1.440">     }</span>
<a href="#l1.441"></a><span id="l1.441" class="difflineminus">-    else if (sortType  != nsMsgViewSortType::byThread &amp;&amp; (m_sortType == nsMsgViewSortType::byThread  || sortThreads)/* &amp;&amp; !m_havePrevView*/)</span>
<a href="#l1.442"></a><span id="l1.442" class="difflineplus">+    else if (sortType  != nsMsgViewSortType::byThread &amp;&amp;</span>
<a href="#l1.443"></a><span id="l1.443" class="difflineplus">+             (m_sortType == nsMsgViewSortType::byThread  || sortThreads)</span>
<a href="#l1.444"></a><span id="l1.444" class="difflineplus">+             /* &amp;&amp; !m_havePrevView*/)</span>
<a href="#l1.445"></a><span id="l1.445">     {</span>
<a href="#l1.446"></a><span id="l1.446">       if (sortThreads)</span>
<a href="#l1.447"></a><span id="l1.447">       {</span>
<a href="#l1.448"></a><span id="l1.448">         SortThreads(sortType, sortOrder);</span>
<a href="#l1.449"></a><span id="l1.449" class="difflineminus">-        sortType = nsMsgViewSortType::byThread; // hack so base class won't do anything</span>
<a href="#l1.450"></a><span id="l1.450" class="difflineplus">+        // Hack so base class won't do anything.</span>
<a href="#l1.451"></a><span id="l1.451" class="difflineplus">+        sortType = nsMsgViewSortType::byThread;</span>
<a href="#l1.452"></a><span id="l1.452">       }</span>
<a href="#l1.453"></a><span id="l1.453">       else</span>
<a href="#l1.454"></a><span id="l1.454">       {</span>
<a href="#l1.455"></a><span id="l1.455" class="difflineminus">-        // going from SortByThread to non-thread sort - must build new key, level,and flags arrays</span>
<a href="#l1.456"></a><span id="l1.456" class="difflineplus">+        // Going from SortByThread to non-thread sort - must build new key,</span>
<a href="#l1.457"></a><span id="l1.457" class="difflineplus">+        // level, and flags arrays.</span>
<a href="#l1.458"></a><span id="l1.458">         m_prevKeys = m_keys;</span>
<a href="#l1.459"></a><span id="l1.459">         m_prevFlags = m_flags;</span>
<a href="#l1.460"></a><span id="l1.460">         m_prevLevels = m_levels;</span>
<a href="#l1.461"></a><span id="l1.461" class="difflineminus">-        // do this before we sort, so that we'll use the cheap method</span>
<a href="#l1.462"></a><span id="l1.462" class="difflineplus">+        // Do this before we sort, so that we'll use the cheap method</span>
<a href="#l1.463"></a><span id="l1.463">         // of expanding.</span>
<a href="#l1.464"></a><span id="l1.464">         m_viewFlags &amp;= ~(nsMsgViewFlagsType::kThreadedDisplay | nsMsgViewFlagsType::kGroupBySort);</span>
<a href="#l1.465"></a><span id="l1.465">         ExpandAll();</span>
<a href="#l1.466"></a><span id="l1.466" class="difflineminus">-        //			m_idArray.RemoveAll();</span>
<a href="#l1.467"></a><span id="l1.467" class="difflineminus">-        //			m_flags.Clear();</span>
<a href="#l1.468"></a><span id="l1.468" class="difflineplus">+        // m_idArray.RemoveAll();</span>
<a href="#l1.469"></a><span id="l1.469" class="difflineplus">+        // m_flags.Clear();</span>
<a href="#l1.470"></a><span id="l1.470">         m_havePrevView = true;</span>
<a href="#l1.471"></a><span id="l1.471">       }</span>
<a href="#l1.472"></a><span id="l1.472">     }</span>
<a href="#l1.473"></a><span id="l1.473">   }</span>
<a href="#l1.474"></a><span id="l1.474" class="difflineminus">-  else if (m_sortOrder != sortOrder)// check for toggling the sort</span>
<a href="#l1.475"></a><span id="l1.475" class="difflineplus">+  else if (m_sortOrder != sortOrder)</span>
<a href="#l1.476"></a><span id="l1.476">   {</span>
<a href="#l1.477"></a><span id="l1.477" class="difflineplus">+    // Check for toggling the sort.</span>
<a href="#l1.478"></a><span id="l1.478">     nsMsgDBView::Sort(sortType, sortOrder);</span>
<a href="#l1.479"></a><span id="l1.479">   }</span>
<a href="#l1.480"></a><span id="l1.480" class="difflineplus">+</span>
<a href="#l1.481"></a><span id="l1.481">   if (!sortThreads)</span>
<a href="#l1.482"></a><span id="l1.482">   {</span>
<a href="#l1.483"></a><span id="l1.483" class="difflineminus">-    // call the base class in case we're not sorting by thread</span>
<a href="#l1.484"></a><span id="l1.484" class="difflineplus">+    // Call the base class in case we're not sorting by thread.</span>
<a href="#l1.485"></a><span id="l1.485">     rv = nsMsgDBView::Sort(sortType, sortOrder);</span>
<a href="#l1.486"></a><span id="l1.486">     SaveSortInfo(sortType, sortOrder);</span>
<a href="#l1.487"></a><span id="l1.487">   }</span>
<a href="#l1.488"></a><span id="l1.488" class="difflineminus">-  // the sort may have changed the number of rows</span>
<a href="#l1.489"></a><span id="l1.489" class="difflineplus">+</span>
<a href="#l1.490"></a><span id="l1.490" class="difflineplus">+  // The sort may have changed the number of rows</span>
<a href="#l1.491"></a><span id="l1.491">   // before we restore the selection, tell the tree</span>
<a href="#l1.492"></a><span id="l1.492">   // do this before we call restore selection</span>
<a href="#l1.493"></a><span id="l1.493">   // this is safe when there is no selection.</span>
<a href="#l1.494"></a><span id="l1.494">   rv = AdjustRowCount(rowCountBeforeSort, GetSize());</span>
<a href="#l1.495"></a><span id="l1.495"> </span>
<a href="#l1.496"></a><span id="l1.496">   RestoreSelection(preservedKey, preservedSelection);</span>
<a href="#l1.497"></a><span id="l1.497" class="difflineminus">-  if (mTree) mTree-&gt;Invalidate();</span>
<a href="#l1.498"></a><span id="l1.498" class="difflineplus">+  if (mTree)</span>
<a href="#l1.499"></a><span id="l1.499" class="difflineplus">+    mTree-&gt;Invalidate();</span>
<a href="#l1.500"></a><span id="l1.500" class="difflineplus">+</span>
<a href="#l1.501"></a><span id="l1.501">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l1.502"></a><span id="l1.502">   return NS_OK;</span>
<a href="#l1.503"></a><span id="l1.503"> }</span>
<a href="#l1.504"></a><span id="l1.504"> </span>
<a href="#l1.505"></a><span id="l1.505" class="difflineminus">-// list the ids of the top-level thread ids starting at id == startMsg. This actually returns</span>
<a href="#l1.506"></a><span id="l1.506" class="difflineminus">-// the ids of the first message in each thread.</span>
<a href="#l1.507"></a><span id="l1.507" class="difflineminus">-nsresult nsMsgThreadedDBView::ListThreadIds(nsMsgKey *startMsg, bool unreadOnly, nsMsgKey *pOutput, int32_t *pFlags, char *pLevels,</span>
<a href="#l1.508"></a><span id="l1.508" class="difflineminus">-									 int32_t numToList, int32_t *pNumListed, int32_t *pTotalHeaders)</span>
<a href="#l1.509"></a><span id="l1.509" class="difflineplus">+// List the ids of the top-level thread ids starting at id == startMsg.</span>
<a href="#l1.510"></a><span id="l1.510" class="difflineplus">+// This actually returns the ids of the first message in each thread.</span>
<a href="#l1.511"></a><span id="l1.511" class="difflineplus">+nsresult</span>
<a href="#l1.512"></a><span id="l1.512" class="difflineplus">+nsMsgThreadedDBView::ListThreadIds(nsMsgKey *startMsg,</span>
<a href="#l1.513"></a><span id="l1.513" class="difflineplus">+                                   bool unreadOnly,</span>
<a href="#l1.514"></a><span id="l1.514" class="difflineplus">+                                   nsMsgKey *pOutput,</span>
<a href="#l1.515"></a><span id="l1.515" class="difflineplus">+                                   int32_t *pFlags,</span>
<a href="#l1.516"></a><span id="l1.516" class="difflineplus">+                                   char *pLevels,</span>
<a href="#l1.517"></a><span id="l1.517" class="difflineplus">+                                   int32_t numToList,</span>
<a href="#l1.518"></a><span id="l1.518" class="difflineplus">+                                   int32_t *pNumListed,</span>
<a href="#l1.519"></a><span id="l1.519" class="difflineplus">+                                   int32_t *pTotalHeaders)</span>
<a href="#l1.520"></a><span id="l1.520"> {</span>
<a href="#l1.521"></a><span id="l1.521">   nsresult rv = NS_OK;</span>
<a href="#l1.522"></a><span id="l1.522" class="difflineminus">-  // N.B..don't ret before assigning numListed to *pNumListed</span>
<a href="#l1.523"></a><span id="l1.523" class="difflineminus">-  int32_t	numListed = 0;</span>
<a href="#l1.524"></a><span id="l1.524" class="difflineplus">+  // N.B..don't ret before assigning numListed to *pNumListed.</span>
<a href="#l1.525"></a><span id="l1.525" class="difflineplus">+  int32_t numListed = 0;</span>
<a href="#l1.526"></a><span id="l1.526"> </span>
<a href="#l1.527"></a><span id="l1.527">   if (*startMsg &gt; 0)</span>
<a href="#l1.528"></a><span id="l1.528">   {</span>
<a href="#l1.529"></a><span id="l1.529" class="difflineminus">-    NS_ASSERTION(m_threadEnumerator != nullptr, &quot;where's our iterator?&quot;);	// for now, we'll just have to rely on the caller leaving</span>
<a href="#l1.530"></a><span id="l1.530" class="difflineplus">+    // For now, we'll just have to rely on the caller leaving</span>
<a href="#l1.531"></a><span id="l1.531">     // the iterator in the right place.</span>
<a href="#l1.532"></a><span id="l1.532" class="difflineplus">+    NS_ASSERTION(m_threadEnumerator != nullptr, &quot;where's our iterator?&quot;);</span>
<a href="#l1.533"></a><span id="l1.533">   }</span>
<a href="#l1.534"></a><span id="l1.534">   else</span>
<a href="#l1.535"></a><span id="l1.535">   {</span>
<a href="#l1.536"></a><span id="l1.536">     NS_ASSERTION(m_db, &quot;no db&quot;);</span>
<a href="#l1.537"></a><span id="l1.537" class="difflineminus">-    if (!m_db) return NS_ERROR_UNEXPECTED;</span>
<a href="#l1.538"></a><span id="l1.538" class="difflineplus">+    if (!m_db)</span>
<a href="#l1.539"></a><span id="l1.539" class="difflineplus">+      return NS_ERROR_UNEXPECTED;</span>
<a href="#l1.540"></a><span id="l1.540" class="difflineplus">+</span>
<a href="#l1.541"></a><span id="l1.541">     rv = m_db-&gt;EnumerateThreads(getter_AddRefs(m_threadEnumerator));</span>
<a href="#l1.542"></a><span id="l1.542">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.543"></a><span id="l1.543">   }</span>
<a href="#l1.544"></a><span id="l1.544"> </span>
<a href="#l1.545"></a><span id="l1.545">   bool hasMore = false;</span>
<a href="#l1.546"></a><span id="l1.546"> </span>
<a href="#l1.547"></a><span id="l1.547">   nsCOMPtr &lt;nsIMsgThread&gt; threadHdr ;</span>
<a href="#l1.548"></a><span id="l1.548" class="difflineminus">-  int32_t	threadsRemoved = 0;</span>
<a href="#l1.549"></a><span id="l1.549" class="difflineplus">+  int32_t threadsRemoved = 0;</span>
<a href="#l1.550"></a><span id="l1.550">   while (numListed &lt; numToList &amp;&amp;</span>
<a href="#l1.551"></a><span id="l1.551">          NS_SUCCEEDED(rv = m_threadEnumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp;</span>
<a href="#l1.552"></a><span id="l1.552">          hasMore)</span>
<a href="#l1.553"></a><span id="l1.553">   {</span>
<a href="#l1.554"></a><span id="l1.554">     nsCOMPtr &lt;nsISupports&gt; supports;</span>
<a href="#l1.555"></a><span id="l1.555">     rv = m_threadEnumerator-&gt;GetNext(getter_AddRefs(supports));</span>
<a href="#l1.556"></a><span id="l1.556">     if (NS_FAILED(rv))</span>
<a href="#l1.557"></a><span id="l1.557">     {</span>
<a href="#l1.558"></a><span id="l1.558">       threadHdr = nullptr;</span>
<a href="#l1.559"></a><span id="l1.559">       break;</span>
<a href="#l1.560"></a><span id="l1.560">     }</span>
<a href="#l1.561"></a><span id="l1.561" class="difflineplus">+</span>
<a href="#l1.562"></a><span id="l1.562">     threadHdr = do_QueryInterface(supports);</span>
<a href="#l1.563"></a><span id="l1.563">     if (!threadHdr)</span>
<a href="#l1.564"></a><span id="l1.564">       break;</span>
<a href="#l1.565"></a><span id="l1.565" class="difflineplus">+</span>
<a href="#l1.566"></a><span id="l1.566">     nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l1.567"></a><span id="l1.567">     uint32_t numChildren;</span>
<a href="#l1.568"></a><span id="l1.568">     if (unreadOnly)</span>
<a href="#l1.569"></a><span id="l1.569">       threadHdr-&gt;GetNumUnreadChildren(&amp;numChildren);</span>
<a href="#l1.570"></a><span id="l1.570">     else</span>
<a href="#l1.571"></a><span id="l1.571">       threadHdr-&gt;GetNumChildren(&amp;numChildren);</span>
<a href="#l1.572"></a><span id="l1.572" class="difflineplus">+</span>
<a href="#l1.573"></a><span id="l1.573">     uint32_t threadFlags;</span>
<a href="#l1.574"></a><span id="l1.574">     threadHdr-&gt;GetFlags(&amp;threadFlags);</span>
<a href="#l1.575"></a><span id="l1.575" class="difflineminus">-    if (numChildren != 0)	// not empty thread</span>
<a href="#l1.576"></a><span id="l1.576" class="difflineplus">+    if (numChildren != 0)</span>
<a href="#l1.577"></a><span id="l1.577">     {</span>
<a href="#l1.578"></a><span id="l1.578" class="difflineplus">+      // Not an empty thread.</span>
<a href="#l1.579"></a><span id="l1.579">       int32_t unusedRootIndex;</span>
<a href="#l1.580"></a><span id="l1.580">       if (pTotalHeaders)</span>
<a href="#l1.581"></a><span id="l1.581">         *pTotalHeaders += numChildren;</span>
<a href="#l1.582"></a><span id="l1.582" class="difflineplus">+</span>
<a href="#l1.583"></a><span id="l1.583">       if (unreadOnly)</span>
<a href="#l1.584"></a><span id="l1.584">         rv = threadHdr-&gt;GetFirstUnreadChild(getter_AddRefs(msgHdr));</span>
<a href="#l1.585"></a><span id="l1.585">       else</span>
<a href="#l1.586"></a><span id="l1.586">         rv = threadHdr-&gt;GetRootHdr(&amp;unusedRootIndex, getter_AddRefs(msgHdr));</span>
<a href="#l1.587"></a><span id="l1.587" class="difflineplus">+</span>
<a href="#l1.588"></a><span id="l1.588">       if (NS_SUCCEEDED(rv) &amp;&amp; msgHdr != nullptr &amp;&amp; WantsThisThread(threadHdr))</span>
<a href="#l1.589"></a><span id="l1.589">       {</span>
<a href="#l1.590"></a><span id="l1.590">         uint32_t msgFlags;</span>
<a href="#l1.591"></a><span id="l1.591">         uint32_t newMsgFlags;</span>
<a href="#l1.592"></a><span id="l1.592">         nsMsgKey msgKey;</span>
<a href="#l1.593"></a><span id="l1.593">         msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l1.594"></a><span id="l1.594">         msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l1.595"></a><span id="l1.595" class="difflineminus">-        // turn off high byte of msg flags - used for view flags.</span>
<a href="#l1.596"></a><span id="l1.596" class="difflineplus">+        // Turn off high byte of msg flags - used for view flags.</span>
<a href="#l1.597"></a><span id="l1.597">         msgFlags &amp;= ~MSG_VIEW_FLAGS;</span>
<a href="#l1.598"></a><span id="l1.598">         pOutput[numListed] = msgKey;</span>
<a href="#l1.599"></a><span id="l1.599">         pLevels[numListed] = 0;</span>
<a href="#l1.600"></a><span id="l1.600" class="difflineminus">-        // turn off these flags on msg hdr - they belong in thread</span>
<a href="#l1.601"></a><span id="l1.601" class="difflineplus">+        // Turn off these flags on msg hdr - they belong in thread.</span>
<a href="#l1.602"></a><span id="l1.602">         msgHdr-&gt;AndFlags(~(nsMsgMessageFlags::Watched), &amp;newMsgFlags);</span>
<a href="#l1.603"></a><span id="l1.603">         AdjustReadFlag(msgHdr, &amp;msgFlags);</span>
<a href="#l1.604"></a><span id="l1.604" class="difflineminus">-        // try adding in MSG_VIEW_FLAG_ISTHREAD flag for unreadonly view.</span>
<a href="#l1.605"></a><span id="l1.605" class="difflineplus">+        // Try adding in MSG_VIEW_FLAG_ISTHREAD flag for unreadonly view.</span>
<a href="#l1.606"></a><span id="l1.606">         pFlags[numListed] = msgFlags | MSG_VIEW_FLAG_ISTHREAD | threadFlags;</span>
<a href="#l1.607"></a><span id="l1.607">         if (numChildren &gt; 1)</span>
<a href="#l1.608"></a><span id="l1.608">           pFlags[numListed] |= MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l1.609"></a><span id="l1.609"> </span>
<a href="#l1.610"></a><span id="l1.610">         numListed++;</span>
<a href="#l1.611"></a><span id="l1.611">       }</span>
<a href="#l1.612"></a><span id="l1.612">       else</span>
<a href="#l1.613"></a><span id="l1.613" class="difflineminus">-        NS_ASSERTION(NS_SUCCEEDED(rv) &amp;&amp; msgHdr, &quot;couldn't get header for some reason&quot;);</span>
<a href="#l1.614"></a><span id="l1.614" class="difflineplus">+      {</span>
<a href="#l1.615"></a><span id="l1.615" class="difflineplus">+        NS_ASSERTION(NS_SUCCEEDED(rv) &amp;&amp; msgHdr,</span>
<a href="#l1.616"></a><span id="l1.616" class="difflineplus">+                     &quot;couldn't get header for some reason&quot;);</span>
<a href="#l1.617"></a><span id="l1.617" class="difflineplus">+      }</span>
<a href="#l1.618"></a><span id="l1.618">     }</span>
<a href="#l1.619"></a><span id="l1.619" class="difflineminus">-    else if (threadsRemoved &lt; 10 &amp;&amp; !(threadFlags &amp; (nsMsgMessageFlags::Watched | nsMsgMessageFlags::Ignored)))</span>
<a href="#l1.620"></a><span id="l1.620" class="difflineplus">+    else if (threadsRemoved &lt; 10 &amp;&amp;</span>
<a href="#l1.621"></a><span id="l1.621" class="difflineplus">+             !(threadFlags &amp; (nsMsgMessageFlags::Watched |</span>
<a href="#l1.622"></a><span id="l1.622" class="difflineplus">+                              nsMsgMessageFlags::Ignored)))</span>
<a href="#l1.623"></a><span id="l1.623">     {</span>
<a href="#l1.624"></a><span id="l1.624">       // ### remove thread.</span>
<a href="#l1.625"></a><span id="l1.625" class="difflineminus">-      threadsRemoved++;	// don't want to remove all empty threads first time</span>
<a href="#l1.626"></a><span id="l1.626" class="difflineminus">-      // around as it will choke preformance for upgrade.</span>
<a href="#l1.627"></a><span id="l1.627" class="difflineplus">+      // Don't want to remove all empty threads first time around as it will</span>
<a href="#l1.628"></a><span id="l1.628" class="difflineplus">+      // choke preformance for upgrade.</span>
<a href="#l1.629"></a><span id="l1.629" class="difflineplus">+      threadsRemoved++;</span>
<a href="#l1.630"></a><span id="l1.630"> #ifdef DEBUG_bienvenu</span>
<a href="#l1.631"></a><span id="l1.631">       printf(&quot;removing empty non-ignored non-watched thread\n&quot;);</span>
<a href="#l1.632"></a><span id="l1.632"> #endif</span>
<a href="#l1.633"></a><span id="l1.633">     }</span>
<a href="#l1.634"></a><span id="l1.634">   }</span>
<a href="#l1.635"></a><span id="l1.635"> </span>
<a href="#l1.636"></a><span id="l1.636">   if (hasMore &amp;&amp; threadHdr)</span>
<a href="#l1.637"></a><span id="l1.637">   {</span>
<a href="#l1.638"></a><span id="l1.638">     threadHdr-&gt;GetThreadKey(startMsg);</span>
<a href="#l1.639"></a><span id="l1.639">   }</span>
<a href="#l1.640"></a><span id="l1.640">   else</span>
<a href="#l1.641"></a><span id="l1.641">   {</span>
<a href="#l1.642"></a><span id="l1.642">     *startMsg = nsMsgKey_None;</span>
<a href="#l1.643"></a><span id="l1.643">     nsCOMPtr &lt;nsIDBChangeListener&gt; dbListener = do_QueryInterface(m_threadEnumerator);</span>
<a href="#l1.644"></a><span id="l1.644" class="difflineminus">-    // this is needed to make the thread enumerator release its reference to the db.</span>
<a href="#l1.645"></a><span id="l1.645" class="difflineplus">+    // This is needed to make the thread enumerator release its reference</span>
<a href="#l1.646"></a><span id="l1.646" class="difflineplus">+    // to the db.</span>
<a href="#l1.647"></a><span id="l1.647">     if (dbListener)</span>
<a href="#l1.648"></a><span id="l1.648">       dbListener-&gt;OnAnnouncerGoingAway(nullptr);</span>
<a href="#l1.649"></a><span id="l1.649" class="difflineplus">+</span>
<a href="#l1.650"></a><span id="l1.650">     m_threadEnumerator = nullptr;</span>
<a href="#l1.651"></a><span id="l1.651">   }</span>
<a href="#l1.652"></a><span id="l1.652" class="difflineplus">+</span>
<a href="#l1.653"></a><span id="l1.653">   *pNumListed = numListed;</span>
<a href="#l1.654"></a><span id="l1.654">   return rv;</span>
<a href="#l1.655"></a><span id="l1.655"> }</span>
<a href="#l1.656"></a><span id="l1.656"> </span>
<a href="#l1.657"></a><span id="l1.657" class="difflineminus">-void	nsMsgThreadedDBView::OnExtraFlagChanged(nsMsgViewIndex index, uint32_t extraFlag)</span>
<a href="#l1.658"></a><span id="l1.658" class="difflineplus">+void</span>
<a href="#l1.659"></a><span id="l1.659" class="difflineplus">+nsMsgThreadedDBView::OnExtraFlagChanged(nsMsgViewIndex index,</span>
<a href="#l1.660"></a><span id="l1.660" class="difflineplus">+                                        uint32_t extraFlag)</span>
<a href="#l1.661"></a><span id="l1.661"> {</span>
<a href="#l1.662"></a><span id="l1.662">   if (IsValidIndex(index))</span>
<a href="#l1.663"></a><span id="l1.663">   {</span>
<a href="#l1.664"></a><span id="l1.664">     if (m_havePrevView)</span>
<a href="#l1.665"></a><span id="l1.665">     {</span>
<a href="#l1.666"></a><span id="l1.666">       nsMsgKey keyChanged = m_keys[index];</span>
<a href="#l1.667"></a><span id="l1.667">       nsMsgViewIndex prevViewIndex = m_prevKeys.IndexOf(keyChanged);</span>
<a href="#l1.668"></a><span id="l1.668">       if (prevViewIndex != nsMsgViewIndex_None)</span>
<a href="#l1.669"></a><span id="l1.669">       {</span>
<a href="#l1.670"></a><span id="l1.670">         uint32_t prevFlag = m_prevFlags[prevViewIndex];</span>
<a href="#l1.671"></a><span id="l1.671" class="difflineminus">-        // don't want to change the elided bit, or has children or is thread</span>
<a href="#l1.672"></a><span id="l1.672" class="difflineplus">+        // Don't want to change the elided bit, or has children or is thread.</span>
<a href="#l1.673"></a><span id="l1.673">         if (prevFlag &amp; nsMsgMessageFlags::Elided)</span>
<a href="#l1.674"></a><span id="l1.674">           extraFlag |= nsMsgMessageFlags::Elided;</span>
<a href="#l1.675"></a><span id="l1.675">         else</span>
<a href="#l1.676"></a><span id="l1.676">           extraFlag &amp;= ~nsMsgMessageFlags::Elided;</span>
<a href="#l1.677"></a><span id="l1.677" class="difflineplus">+</span>
<a href="#l1.678"></a><span id="l1.678">         if (prevFlag &amp; MSG_VIEW_FLAG_ISTHREAD)</span>
<a href="#l1.679"></a><span id="l1.679">           extraFlag |= MSG_VIEW_FLAG_ISTHREAD;</span>
<a href="#l1.680"></a><span id="l1.680">         else</span>
<a href="#l1.681"></a><span id="l1.681">           extraFlag &amp;= ~MSG_VIEW_FLAG_ISTHREAD;</span>
<a href="#l1.682"></a><span id="l1.682" class="difflineplus">+</span>
<a href="#l1.683"></a><span id="l1.683">         if (prevFlag &amp; MSG_VIEW_FLAG_HASCHILDREN)</span>
<a href="#l1.684"></a><span id="l1.684">           extraFlag |= MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l1.685"></a><span id="l1.685">         else</span>
<a href="#l1.686"></a><span id="l1.686">           extraFlag &amp;= ~MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l1.687"></a><span id="l1.687" class="difflineminus">-        m_prevFlags[prevViewIndex] = extraFlag; // will this be right?</span>
<a href="#l1.688"></a><span id="l1.688" class="difflineplus">+</span>
<a href="#l1.689"></a><span id="l1.689" class="difflineplus">+        // Will this be right?</span>
<a href="#l1.690"></a><span id="l1.690" class="difflineplus">+        m_prevFlags[prevViewIndex] = extraFlag;</span>
<a href="#l1.691"></a><span id="l1.691">       }</span>
<a href="#l1.692"></a><span id="l1.692">     }</span>
<a href="#l1.693"></a><span id="l1.693">   }</span>
<a href="#l1.694"></a><span id="l1.694" class="difflineminus">-  // we don't really know what's changed, but to be on the safe side, set the sort invalid</span>
<a href="#l1.695"></a><span id="l1.695" class="difflineminus">-  // so that reverse sort will pick it up.</span>
<a href="#l1.696"></a><span id="l1.696" class="difflineminus">-  if (m_sortType == nsMsgViewSortType::byStatus || m_sortType == nsMsgViewSortType::byFlagged ||</span>
<a href="#l1.697"></a><span id="l1.697" class="difflineminus">-    m_sortType == nsMsgViewSortType::byUnread || m_sortType == nsMsgViewSortType::byPriority)</span>
<a href="#l1.698"></a><span id="l1.698" class="difflineplus">+</span>
<a href="#l1.699"></a><span id="l1.699" class="difflineplus">+  // We don't really know what's changed, but to be on the safe side, set the</span>
<a href="#l1.700"></a><span id="l1.700" class="difflineplus">+  // sort invalid so that reverse sort will pick it up.</span>
<a href="#l1.701"></a><span id="l1.701" class="difflineplus">+  if (m_sortType == nsMsgViewSortType::byStatus ||</span>
<a href="#l1.702"></a><span id="l1.702" class="difflineplus">+      m_sortType == nsMsgViewSortType::byFlagged ||</span>
<a href="#l1.703"></a><span id="l1.703" class="difflineplus">+      m_sortType == nsMsgViewSortType::byUnread ||</span>
<a href="#l1.704"></a><span id="l1.704" class="difflineplus">+      m_sortType == nsMsgViewSortType::byPriority)</span>
<a href="#l1.705"></a><span id="l1.705" class="difflineplus">+  {</span>
<a href="#l1.706"></a><span id="l1.706">     m_sortValid = false;</span>
<a href="#l1.707"></a><span id="l1.707" class="difflineplus">+  }</span>
<a href="#l1.708"></a><span id="l1.708"> }</span>
<a href="#l1.709"></a><span id="l1.709"> </span>
<a href="#l1.710"></a><span id="l1.710" class="difflineminus">-void nsMsgThreadedDBView::OnHeaderAddedOrDeleted()</span>
<a href="#l1.711"></a><span id="l1.711" class="difflineplus">+void</span>
<a href="#l1.712"></a><span id="l1.712" class="difflineplus">+nsMsgThreadedDBView::OnHeaderAddedOrDeleted()</span>
<a href="#l1.713"></a><span id="l1.713"> {</span>
<a href="#l1.714"></a><span id="l1.714">   ClearPrevIdArray();</span>
<a href="#l1.715"></a><span id="l1.715"> }</span>
<a href="#l1.716"></a><span id="l1.716"> </span>
<a href="#l1.717"></a><span id="l1.717" class="difflineminus">-void nsMsgThreadedDBView::ClearPrevIdArray()</span>
<a href="#l1.718"></a><span id="l1.718" class="difflineplus">+void</span>
<a href="#l1.719"></a><span id="l1.719" class="difflineplus">+nsMsgThreadedDBView::ClearPrevIdArray()</span>
<a href="#l1.720"></a><span id="l1.720"> {</span>
<a href="#l1.721"></a><span id="l1.721">   m_prevKeys.Clear();</span>
<a href="#l1.722"></a><span id="l1.722">   m_prevLevels.Clear();</span>
<a href="#l1.723"></a><span id="l1.723">   m_prevFlags.Clear();</span>
<a href="#l1.724"></a><span id="l1.724">   m_havePrevView = false;</span>
<a href="#l1.725"></a><span id="l1.725"> }</span>
<a href="#l1.726"></a><span id="l1.726"> </span>
<a href="#l1.727"></a><span id="l1.727" class="difflineminus">-nsresult nsMsgThreadedDBView::InitSort(nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder)</span>
<a href="#l1.728"></a><span id="l1.728" class="difflineplus">+nsresult</span>
<a href="#l1.729"></a><span id="l1.729" class="difflineplus">+nsMsgThreadedDBView::InitSort(nsMsgViewSortTypeValue sortType,</span>
<a href="#l1.730"></a><span id="l1.730" class="difflineplus">+                              nsMsgViewSortOrderValue sortOrder)</span>
<a href="#l1.731"></a><span id="l1.731"> {</span>
<a href="#l1.732"></a><span id="l1.732" class="difflineplus">+  // Nothing to do.</span>
<a href="#l1.733"></a><span id="l1.733">   if (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort)</span>
<a href="#l1.734"></a><span id="l1.734" class="difflineminus">-    return NS_OK; // nothing to do.</span>
<a href="#l1.735"></a><span id="l1.735" class="difflineplus">+    return NS_OK;</span>
<a href="#l1.736"></a><span id="l1.736"> </span>
<a href="#l1.737"></a><span id="l1.737">   if (sortType == nsMsgViewSortType::byThread)</span>
<a href="#l1.738"></a><span id="l1.738">   {</span>
<a href="#l1.739"></a><span id="l1.739" class="difflineminus">-    nsMsgDBView::Sort(nsMsgViewSortType::byId, sortOrder); // sort top level threads by id.</span>
<a href="#l1.740"></a><span id="l1.740" class="difflineplus">+    // Sort top level threads by id.</span>
<a href="#l1.741"></a><span id="l1.741" class="difflineplus">+    nsMsgDBView::Sort(nsMsgViewSortType::byId, sortOrder);</span>
<a href="#l1.742"></a><span id="l1.742">     m_sortType = nsMsgViewSortType::byThread;</span>
<a href="#l1.743"></a><span id="l1.743">     m_viewFlags |= nsMsgViewFlagsType::kThreadedDisplay;</span>
<a href="#l1.744"></a><span id="l1.744">     m_viewFlags &amp;= ~nsMsgViewFlagsType::kGroupBySort;</span>
<a href="#l1.745"></a><span id="l1.745" class="difflineminus">-    SetViewFlags(m_viewFlags); // persist the view flags.</span>
<a href="#l1.746"></a><span id="l1.746" class="difflineminus">-    //		m_db-&gt;SetSortInfo(m_sortType, sortOrder);</span>
<a href="#l1.747"></a><span id="l1.747" class="difflineplus">+    // Persist the view flags.</span>
<a href="#l1.748"></a><span id="l1.748" class="difflineplus">+    SetViewFlags(m_viewFlags);</span>
<a href="#l1.749"></a><span id="l1.749" class="difflineplus">+    // m_db-&gt;SetSortInfo(m_sortType, sortOrder);</span>
<a href="#l1.750"></a><span id="l1.750">   }</span>
<a href="#l1.751"></a><span id="l1.751"> //  else</span>
<a href="#l1.752"></a><span id="l1.752"> //    m_viewFlags &amp;= ~nsMsgViewFlagsType::kThreadedDisplay;</span>
<a href="#l1.753"></a><span id="l1.753"> </span>
<a href="#l1.754"></a><span id="l1.754" class="difflineminus">-  // by default, the unread only view should have all threads expanded.</span>
<a href="#l1.755"></a><span id="l1.755" class="difflineminus">-  if ((m_viewFlags &amp; (nsMsgViewFlagsType::kUnreadOnly|nsMsgViewFlagsType::kExpandAll))</span>
<a href="#l1.756"></a><span id="l1.756" class="difflineminus">-      &amp;&amp; (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l1.757"></a><span id="l1.757" class="difflineplus">+</span>
<a href="#l1.758"></a><span id="l1.758" class="difflineplus">+  // By default, the unread only view should have all threads expanded.</span>
<a href="#l1.759"></a><span id="l1.759" class="difflineplus">+  if ((m_viewFlags &amp; (nsMsgViewFlagsType::kUnreadOnly |</span>
<a href="#l1.760"></a><span id="l1.760" class="difflineplus">+                      nsMsgViewFlagsType::kExpandAll)) &amp;&amp;</span>
<a href="#l1.761"></a><span id="l1.761" class="difflineplus">+      (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l1.762"></a><span id="l1.762" class="difflineplus">+  {</span>
<a href="#l1.763"></a><span id="l1.763">     ExpandAll();</span>
<a href="#l1.764"></a><span id="l1.764" class="difflineminus">-  if (! (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l1.765"></a><span id="l1.765" class="difflineminus">-    ExpandAll(); // for now, expand all and do a flat sort.</span>
<a href="#l1.766"></a><span id="l1.766" class="difflineplus">+  }</span>
<a href="#l1.767"></a><span id="l1.767" class="difflineplus">+</span>
<a href="#l1.768"></a><span id="l1.768" class="difflineplus">+  if (!(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l1.769"></a><span id="l1.769" class="difflineplus">+  {</span>
<a href="#l1.770"></a><span id="l1.770" class="difflineplus">+    // For now, expand all and do a flat sort.</span>
<a href="#l1.771"></a><span id="l1.771" class="difflineplus">+    ExpandAll();</span>
<a href="#l1.772"></a><span id="l1.772" class="difflineplus">+  }</span>
<a href="#l1.773"></a><span id="l1.773"> </span>
<a href="#l1.774"></a><span id="l1.774">   Sort(sortType, sortOrder);</span>
<a href="#l1.775"></a><span id="l1.775" class="difflineminus">-  if (sortType != nsMsgViewSortType::byThread)	// forget prev view, since it has everything expanded.</span>
<a href="#l1.776"></a><span id="l1.776" class="difflineplus">+  if (sortType != nsMsgViewSortType::byThread)</span>
<a href="#l1.777"></a><span id="l1.777" class="difflineplus">+  {</span>
<a href="#l1.778"></a><span id="l1.778" class="difflineplus">+    // Forget prev view, since it has everything expanded.</span>
<a href="#l1.779"></a><span id="l1.779">     ClearPrevIdArray();</span>
<a href="#l1.780"></a><span id="l1.780" class="difflineplus">+  }</span>
<a href="#l1.781"></a><span id="l1.781" class="difflineplus">+</span>
<a href="#l1.782"></a><span id="l1.782">   return NS_OK;</span>
<a href="#l1.783"></a><span id="l1.783"> }</span>
<a href="#l1.784"></a><span id="l1.784"> </span>
<a href="#l1.785"></a><span id="l1.785" class="difflineminus">-nsresult nsMsgThreadedDBView::OnNewHeader(nsIMsgDBHdr *newHdr, nsMsgKey aParentKey, bool ensureListed)</span>
<a href="#l1.786"></a><span id="l1.786" class="difflineplus">+nsresult</span>
<a href="#l1.787"></a><span id="l1.787" class="difflineplus">+nsMsgThreadedDBView::OnNewHeader(nsIMsgDBHdr *newHdr,</span>
<a href="#l1.788"></a><span id="l1.788" class="difflineplus">+                                 nsMsgKey aParentKey,</span>
<a href="#l1.789"></a><span id="l1.789" class="difflineplus">+                                 bool ensureListed)</span>
<a href="#l1.790"></a><span id="l1.790"> {</span>
<a href="#l1.791"></a><span id="l1.791">   if (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort)</span>
<a href="#l1.792"></a><span id="l1.792">     return nsMsgGroupView::OnNewHeader(newHdr, aParentKey, ensureListed);</span>
<a href="#l1.793"></a><span id="l1.793"> </span>
<a href="#l1.794"></a><span id="l1.794">   NS_ENSURE_TRUE(newHdr, NS_MSG_MESSAGE_NOT_FOUND);</span>
<a href="#l1.795"></a><span id="l1.795"> </span>
<a href="#l1.796"></a><span id="l1.796">   nsMsgKey newKey;</span>
<a href="#l1.797"></a><span id="l1.797">   newHdr-&gt;GetMessageKey(&amp;newKey);</span>
<a href="#l1.798"></a><span id="l1.798"> </span>
<a href="#l1.799"></a><span id="l1.799" class="difflineminus">-  // views can override this behaviour, which is to append to view.</span>
<a href="#l1.800"></a><span id="l1.800" class="difflineplus">+  // Views can override this behaviour, which is to append to view.</span>
<a href="#l1.801"></a><span id="l1.801">   // This is the mail behaviour, but threaded views want</span>
<a href="#l1.802"></a><span id="l1.802">   // to insert in order...</span>
<a href="#l1.803"></a><span id="l1.803">   uint32_t msgFlags;</span>
<a href="#l1.804"></a><span id="l1.804">   newHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l1.805"></a><span id="l1.805" class="difflineminus">-  if ((m_viewFlags &amp; nsMsgViewFlagsType::kUnreadOnly) &amp;&amp; !ensureListed &amp;&amp;</span>
<a href="#l1.806"></a><span id="l1.806" class="difflineminus">-      (msgFlags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l1.807"></a><span id="l1.807" class="difflineplus">+  if (m_viewFlags &amp; nsMsgViewFlagsType::kUnreadOnly &amp;&amp;</span>
<a href="#l1.808"></a><span id="l1.808" class="difflineplus">+      !ensureListed &amp;&amp;</span>
<a href="#l1.809"></a><span id="l1.809" class="difflineplus">+      msgFlags &amp; nsMsgMessageFlags::Read)</span>
<a href="#l1.810"></a><span id="l1.810" class="difflineplus">+  {</span>
<a href="#l1.811"></a><span id="l1.811">     return NS_OK;</span>
<a href="#l1.812"></a><span id="l1.812" class="difflineplus">+  }</span>
<a href="#l1.813"></a><span id="l1.813" class="difflineplus">+</span>
<a href="#l1.814"></a><span id="l1.814">   // Currently, we only add the header in a threaded view if it's a thread.</span>
<a href="#l1.815"></a><span id="l1.815">   // We used to check if this was the first header in the thread, but that's</span>
<a href="#l1.816"></a><span id="l1.816">   // a bit harder in the unreadOnly view. But we'll catch it below.</span>
<a href="#l1.817"></a><span id="l1.817"> </span>
<a href="#l1.818"></a><span id="l1.818" class="difflineminus">-  // if not threaded display just add it to the view.</span>
<a href="#l1.819"></a><span id="l1.819" class="difflineplus">+  // If not threaded display just add it to the view.</span>
<a href="#l1.820"></a><span id="l1.820">   if (!(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l1.821"></a><span id="l1.821">     return AddHdr(newHdr);</span>
<a href="#l1.822"></a><span id="l1.822"> </span>
<a href="#l1.823"></a><span id="l1.823" class="difflineminus">-  // need to find the thread we added this to so we can change the hasnew flag</span>
<a href="#l1.824"></a><span id="l1.824" class="difflineminus">-  // added message to existing thread, but not to view</span>
<a href="#l1.825"></a><span id="l1.825" class="difflineplus">+  // Need to find the thread we added this to so we can change the hasnew flag</span>
<a href="#l1.826"></a><span id="l1.826" class="difflineplus">+  // added message to existing thread, but not to view.</span>
<a href="#l1.827"></a><span id="l1.827">   // Fix flags on thread header.</span>
<a href="#l1.828"></a><span id="l1.828">   int32_t threadCount;</span>
<a href="#l1.829"></a><span id="l1.829">   uint32_t threadFlags;</span>
<a href="#l1.830"></a><span id="l1.830">   bool moveThread = false;</span>
<a href="#l1.831"></a><span id="l1.831" class="difflineminus">-  nsMsgViewIndex threadIndex = ThreadIndexOfMsg(newKey, nsMsgViewIndex_None, &amp;threadCount, &amp;threadFlags);</span>
<a href="#l1.832"></a><span id="l1.832" class="difflineplus">+  nsMsgViewIndex threadIndex = ThreadIndexOfMsg(newKey, nsMsgViewIndex_None,</span>
<a href="#l1.833"></a><span id="l1.833" class="difflineplus">+                                                &amp;threadCount, &amp;threadFlags);</span>
<a href="#l1.834"></a><span id="l1.834">   bool threadRootIsDisplayed = false;</span>
<a href="#l1.835"></a><span id="l1.835"> </span>
<a href="#l1.836"></a><span id="l1.836">   nsCOMPtr &lt;nsIMsgThread&gt; threadHdr;</span>
<a href="#l1.837"></a><span id="l1.837">   m_db-&gt;GetThreadContainingMsgHdr(newHdr, getter_AddRefs(threadHdr));</span>
<a href="#l1.838"></a><span id="l1.838">   if (threadHdr &amp;&amp; m_sortType == nsMsgViewSortType::byDate)</span>
<a href="#l1.839"></a><span id="l1.839">   {</span>
<a href="#l1.840"></a><span id="l1.840">     uint32_t newestMsgInThread = 0, msgDate = 0;</span>
<a href="#l1.841"></a><span id="l1.841">     threadHdr-&gt;GetNewestMsgDate(&amp;newestMsgInThread);</span>
<a href="#l1.842"></a><span id="l1.842" class="difflineat">@@ -606,39 +742,43 @@ nsresult nsMsgThreadedDBView::OnNewHeade</span>
<a href="#l1.843"></a><span id="l1.843">   {</span>
<a href="#l1.844"></a><span id="l1.844">     threadRootIsDisplayed = (m_currentlyDisplayedViewIndex == threadIndex);</span>
<a href="#l1.845"></a><span id="l1.845">     uint32_t flags = m_flags[threadIndex];</span>
<a href="#l1.846"></a><span id="l1.846">     if (!(flags &amp; MSG_VIEW_FLAG_HASCHILDREN))</span>
<a href="#l1.847"></a><span id="l1.847">     {</span>
<a href="#l1.848"></a><span id="l1.848">       flags |= MSG_VIEW_FLAG_HASCHILDREN | MSG_VIEW_FLAG_ISTHREAD;</span>
<a href="#l1.849"></a><span id="l1.849">       if (!(m_viewFlags &amp; nsMsgViewFlagsType::kUnreadOnly))</span>
<a href="#l1.850"></a><span id="l1.850">         flags |= nsMsgMessageFlags::Elided;</span>
<a href="#l1.851"></a><span id="l1.851" class="difflineplus">+</span>
<a href="#l1.852"></a><span id="l1.852">       m_flags[threadIndex] = flags;</span>
<a href="#l1.853"></a><span id="l1.853">     }</span>
<a href="#l1.854"></a><span id="l1.854"> </span>
<a href="#l1.855"></a><span id="l1.855">     if (!(flags &amp; nsMsgMessageFlags::Elided))</span>
<a href="#l1.856"></a><span id="l1.856" class="difflineminus">-    { // thread is expanded</span>
<a href="#l1.857"></a><span id="l1.857" class="difflineminus">-      // insert child into thread</span>
<a href="#l1.858"></a><span id="l1.858" class="difflineminus">-      // levels of other hdrs may have changed!</span>
<a href="#l1.859"></a><span id="l1.859" class="difflineplus">+    {</span>
<a href="#l1.860"></a><span id="l1.860" class="difflineplus">+      // Thread is expanded.</span>
<a href="#l1.861"></a><span id="l1.861" class="difflineplus">+      // Insert child into thread.</span>
<a href="#l1.862"></a><span id="l1.862" class="difflineplus">+      // Levels of other hdrs may have changed!</span>
<a href="#l1.863"></a><span id="l1.863">       uint32_t newFlags = msgFlags;</span>
<a href="#l1.864"></a><span id="l1.864">       int32_t level = 0;</span>
<a href="#l1.865"></a><span id="l1.865">       nsMsgViewIndex insertIndex = threadIndex;</span>
<a href="#l1.866"></a><span id="l1.866">       if (aParentKey == nsMsgKey_None)</span>
<a href="#l1.867"></a><span id="l1.867">       {</span>
<a href="#l1.868"></a><span id="l1.868">         newFlags |= MSG_VIEW_FLAG_ISTHREAD | MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l1.869"></a><span id="l1.869">       }</span>
<a href="#l1.870"></a><span id="l1.870">       else</span>
<a href="#l1.871"></a><span id="l1.871">       {</span>
<a href="#l1.872"></a><span id="l1.872">         nsMsgViewIndex parentIndex = FindParentInThread(aParentKey, threadIndex);</span>
<a href="#l1.873"></a><span id="l1.873">         level = m_levels[parentIndex] + 1;</span>
<a href="#l1.874"></a><span id="l1.874">         insertIndex = GetInsertInfoForNewHdr(newHdr, parentIndex, level);</span>
<a href="#l1.875"></a><span id="l1.875">       }</span>
<a href="#l1.876"></a><span id="l1.876" class="difflineplus">+</span>
<a href="#l1.877"></a><span id="l1.877">       InsertMsgHdrAt(insertIndex, newHdr, newKey, newFlags, level);</span>
<a href="#l1.878"></a><span id="l1.878" class="difflineminus">-      // the call to NoteChange() has to happen after we add the key</span>
<a href="#l1.879"></a><span id="l1.879" class="difflineminus">-      // as NoteChange() will call RowCountChanged() which will call our GetRowCount()</span>
<a href="#l1.880"></a><span id="l1.880" class="difflineplus">+      // The call to NoteChange() has to happen after we add the key as</span>
<a href="#l1.881"></a><span id="l1.881" class="difflineplus">+      // NoteChange() will call RowCountChanged() which will call our</span>
<a href="#l1.882"></a><span id="l1.882" class="difflineplus">+      // GetRowCount().</span>
<a href="#l1.883"></a><span id="l1.883">       NoteChange(insertIndex, 1, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l1.884"></a><span id="l1.884"> </span>
<a href="#l1.885"></a><span id="l1.885">       if (aParentKey == nsMsgKey_None)</span>
<a href="#l1.886"></a><span id="l1.886">       {</span>
<a href="#l1.887"></a><span id="l1.887">         // this header is the new king! try collapsing the existing thread,</span>
<a href="#l1.888"></a><span id="l1.888">         // removing it, installing this header as king, and expanding it.</span>
<a href="#l1.889"></a><span id="l1.889">         CollapseByIndex(threadIndex, nullptr);</span>
<a href="#l1.890"></a><span id="l1.890">         // call base class, so child won't get promoted.</span>
<a href="#l1.891"></a><span id="l1.891" class="difflineat">@@ -663,77 +803,95 @@ nsresult nsMsgThreadedDBView::OnNewHeade</span>
<a href="#l1.892"></a><span id="l1.892"> </span>
<a href="#l1.893"></a><span id="l1.893">     if (moveThread)</span>
<a href="#l1.894"></a><span id="l1.894">       MoveThreadAt(threadIndex);</span>
<a href="#l1.895"></a><span id="l1.895">     else</span>
<a href="#l1.896"></a><span id="l1.896">       // note change, to update the parent thread's unread and total counts</span>
<a href="#l1.897"></a><span id="l1.897">       NoteChange(threadIndex, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l1.898"></a><span id="l1.898">   }</span>
<a href="#l1.899"></a><span id="l1.899">   else if (threadHdr)</span>
<a href="#l1.900"></a><span id="l1.900" class="difflineminus">-    // adding msg to thread that's not in view.</span>
<a href="#l1.901"></a><span id="l1.901" class="difflineplus">+  {</span>
<a href="#l1.902"></a><span id="l1.902" class="difflineplus">+    // Adding msg to thread that's not in view.</span>
<a href="#l1.903"></a><span id="l1.903">     AddMsgToThreadNotInView(threadHdr, newHdr, ensureListed);</span>
<a href="#l1.904"></a><span id="l1.904" class="difflineplus">+  }</span>
<a href="#l1.905"></a><span id="l1.905"> </span>
<a href="#l1.906"></a><span id="l1.906">   return NS_OK;</span>
<a href="#l1.907"></a><span id="l1.907"> }</span>
<a href="#l1.908"></a><span id="l1.908"> </span>
<a href="#l1.909"></a><span id="l1.909" class="difflineminus">-</span>
<a href="#l1.910"></a><span id="l1.910" class="difflineminus">-NS_IMETHODIMP nsMsgThreadedDBView::OnParentChanged (nsMsgKey aKeyChanged, nsMsgKey oldParent, nsMsgKey newParent, nsIDBChangeListener *aInstigator)</span>
<a href="#l1.911"></a><span id="l1.911" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l1.912"></a><span id="l1.912" class="difflineplus">+nsMsgThreadedDBView::OnParentChanged (nsMsgKey aKeyChanged,</span>
<a href="#l1.913"></a><span id="l1.913" class="difflineplus">+                                      nsMsgKey oldParent,</span>
<a href="#l1.914"></a><span id="l1.914" class="difflineplus">+                                      nsMsgKey newParent,</span>
<a href="#l1.915"></a><span id="l1.915" class="difflineplus">+                                      nsIDBChangeListener *aInstigator)</span>
<a href="#l1.916"></a><span id="l1.916"> {</span>
<a href="#l1.917"></a><span id="l1.917" class="difflineminus">-  // we need to adjust the level of the hdr whose parent changed, and invalidate that row,</span>
<a href="#l1.918"></a><span id="l1.918" class="difflineminus">-  // iff we're in threaded mode.</span>
<a href="#l1.919"></a><span id="l1.919" class="difflineplus">+  // We need to adjust the level of the hdr whose parent changed, and</span>
<a href="#l1.920"></a><span id="l1.920" class="difflineplus">+  // invalidate that row, iff we're in threaded mode.</span>
<a href="#l1.921"></a><span id="l1.921"> #if 0</span>
<a href="#l1.922"></a><span id="l1.922">   // This code never runs due to the if (false) and Clang complains about it</span>
<a href="#l1.923"></a><span id="l1.923">   // so it is ifdefed out for now.</span>
<a href="#l1.924"></a><span id="l1.924">   if (false &amp;&amp; m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay)</span>
<a href="#l1.925"></a><span id="l1.925">   {</span>
<a href="#l1.926"></a><span id="l1.926">     nsMsgViewIndex childIndex = FindViewIndex(aKeyChanged);</span>
<a href="#l1.927"></a><span id="l1.927">     if (childIndex != nsMsgViewIndex_None)</span>
<a href="#l1.928"></a><span id="l1.928">     {</span>
<a href="#l1.929"></a><span id="l1.929">       nsMsgViewIndex parentIndex = FindViewIndex(newParent);</span>
<a href="#l1.930"></a><span id="l1.930" class="difflineminus">-      int32_t newParentLevel = (parentIndex == nsMsgViewIndex_None) ? -1 : m_levels[parentIndex];</span>
<a href="#l1.931"></a><span id="l1.931" class="difflineplus">+      int32_t newParentLevel =</span>
<a href="#l1.932"></a><span id="l1.932" class="difflineplus">+        (parentIndex == nsMsgViewIndex_None) ? -1 : m_levels[parentIndex];</span>
<a href="#l1.933"></a><span id="l1.933" class="difflineplus">+</span>
<a href="#l1.934"></a><span id="l1.934">       nsMsgViewIndex oldParentIndex = FindViewIndex(oldParent);</span>
<a href="#l1.935"></a><span id="l1.935" class="difflineminus">-      int32_t oldParentLevel = (oldParentIndex != nsMsgViewIndex_None || newParent == nsMsgKey_None)</span>
<a href="#l1.936"></a><span id="l1.936" class="difflineminus">-        ? m_levels[oldParentIndex] : -1 ;</span>
<a href="#l1.937"></a><span id="l1.937" class="difflineplus">+</span>
<a href="#l1.938"></a><span id="l1.938" class="difflineplus">+      int32_t oldParentLevel =</span>
<a href="#l1.939"></a><span id="l1.939" class="difflineplus">+        (oldParentIndex != nsMsgViewIndex_None ||</span>
<a href="#l1.940"></a><span id="l1.940" class="difflineplus">+         newParent == nsMsgKey_None) ? m_levels[oldParentIndex] : -1 ;</span>
<a href="#l1.941"></a><span id="l1.941" class="difflineplus">+</span>
<a href="#l1.942"></a><span id="l1.942">       int32_t levelChanged = m_levels[childIndex];</span>
<a href="#l1.943"></a><span id="l1.943">       int32_t parentDelta = oldParentLevel - newParentLevel;</span>
<a href="#l1.944"></a><span id="l1.944">       m_levels[childIndex] = (newParent == nsMsgKey_None) ? 0 : newParentLevel + 1;</span>
<a href="#l1.945"></a><span id="l1.945">       if (parentDelta &gt; 0)</span>
<a href="#l1.946"></a><span id="l1.946">       {</span>
<a href="#l1.947"></a><span id="l1.947" class="difflineminus">-        for (nsMsgViewIndex viewIndex = childIndex + 1; viewIndex &lt; GetSize() &amp;&amp; m_levels[viewIndex] &gt; levelChanged;  viewIndex++)</span>
<a href="#l1.948"></a><span id="l1.948" class="difflineplus">+        for (nsMsgViewIndex viewIndex = childIndex + 1;</span>
<a href="#l1.949"></a><span id="l1.949" class="difflineplus">+             viewIndex &lt; GetSize() &amp;&amp; m_levels[viewIndex] &gt; levelChanged;</span>
<a href="#l1.950"></a><span id="l1.950" class="difflineplus">+             viewIndex++)</span>
<a href="#l1.951"></a><span id="l1.951">         {</span>
<a href="#l1.952"></a><span id="l1.952">           m_levels[viewIndex] = m_levels[viewIndex] - parentDelta;</span>
<a href="#l1.953"></a><span id="l1.953">           NoteChange(viewIndex, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l1.954"></a><span id="l1.954">         }</span>
<a href="#l1.955"></a><span id="l1.955">       }</span>
<a href="#l1.956"></a><span id="l1.956" class="difflineplus">+</span>
<a href="#l1.957"></a><span id="l1.957">       NoteChange(childIndex, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l1.958"></a><span id="l1.958">     }</span>
<a href="#l1.959"></a><span id="l1.959">   }</span>
<a href="#l1.960"></a><span id="l1.960"> #endif</span>
<a href="#l1.961"></a><span id="l1.961">   return NS_OK;</span>
<a href="#l1.962"></a><span id="l1.962"> }</span>
<a href="#l1.963"></a><span id="l1.963"> </span>
<a href="#l1.964"></a><span id="l1.964" class="difflineminus">-</span>
<a href="#l1.965"></a><span id="l1.965" class="difflineminus">-nsMsgViewIndex nsMsgThreadedDBView::GetInsertInfoForNewHdr(nsIMsgDBHdr *newHdr, nsMsgViewIndex parentIndex, int32_t targetLevel)</span>
<a href="#l1.966"></a><span id="l1.966" class="difflineplus">+nsMsgViewIndex</span>
<a href="#l1.967"></a><span id="l1.967" class="difflineplus">+nsMsgThreadedDBView::GetInsertInfoForNewHdr(nsIMsgDBHdr *newHdr,</span>
<a href="#l1.968"></a><span id="l1.968" class="difflineplus">+                                            nsMsgViewIndex parentIndex,</span>
<a href="#l1.969"></a><span id="l1.969" class="difflineplus">+                                            int32_t targetLevel)</span>
<a href="#l1.970"></a><span id="l1.970"> {</span>
<a href="#l1.971"></a><span id="l1.971">   uint32_t viewSize = GetSize();</span>
<a href="#l1.972"></a><span id="l1.972">   while (++parentIndex &lt; viewSize)</span>
<a href="#l1.973"></a><span id="l1.973">   {</span>
<a href="#l1.974"></a><span id="l1.974" class="difflineminus">-    // loop until we find a message at a level less than or equal to the parent level</span>
<a href="#l1.975"></a><span id="l1.975" class="difflineplus">+    // Loop until we find a message at a level less than or equal to the</span>
<a href="#l1.976"></a><span id="l1.976" class="difflineplus">+    // parent level</span>
<a href="#l1.977"></a><span id="l1.977">     if (m_levels[parentIndex] &lt; targetLevel)</span>
<a href="#l1.978"></a><span id="l1.978">       break;</span>
<a href="#l1.979"></a><span id="l1.979">   }</span>
<a href="#l1.980"></a><span id="l1.980" class="difflineplus">+</span>
<a href="#l1.981"></a><span id="l1.981">   return parentIndex;</span>
<a href="#l1.982"></a><span id="l1.982"> }</span>
<a href="#l1.983"></a><span id="l1.983"> </span>
<a href="#l1.984"></a><span id="l1.984"> // This method removes the thread at threadIndex from the view</span>
<a href="#l1.985"></a><span id="l1.985"> // and puts it back in its new position, determined by the sort order.</span>
<a href="#l1.986"></a><span id="l1.986"> // And, if the selection is affected, save and restore the selection.</span>
<a href="#l1.987"></a><span id="l1.987" class="difflineminus">-void nsMsgThreadedDBView::MoveThreadAt(nsMsgViewIndex threadIndex)</span>
<a href="#l1.988"></a><span id="l1.988" class="difflineplus">+void</span>
<a href="#l1.989"></a><span id="l1.989" class="difflineplus">+nsMsgThreadedDBView::MoveThreadAt(nsMsgViewIndex threadIndex)</span>
<a href="#l1.990"></a><span id="l1.990"> {</span>
<a href="#l1.991"></a><span id="l1.991" class="difflineminus">-  // we need to check if the thread is collapsed or not...</span>
<a href="#l1.992"></a><span id="l1.992" class="difflineplus">+  // We need to check if the thread is collapsed or not...</span>
<a href="#l1.993"></a><span id="l1.993">   // We want to turn off tree notifications so that we don't</span>
<a href="#l1.994"></a><span id="l1.994">   // reload the current message.</span>
<a href="#l1.995"></a><span id="l1.995">   // We also need to invalidate the range between where the thread was</span>
<a href="#l1.996"></a><span id="l1.996">   // and where it ended up.</span>
<a href="#l1.997"></a><span id="l1.997">   bool changesDisabled = mSuppressChangeNotification;</span>
<a href="#l1.998"></a><span id="l1.998">   if (!changesDisabled)</span>
<a href="#l1.999"></a><span id="l1.999">     SetSuppressChangeNotifications(true);</span>
<a href="#l1.1000"></a><span id="l1.1000"> </span>
<a href="#l1.1001"></a><span id="l1.1001" class="difflineat">@@ -742,111 +900,126 @@ void nsMsgThreadedDBView::MoveThreadAt(n</span>
<a href="#l1.1002"></a><span id="l1.1002">   GetMsgHdrForViewIndex(threadIndex, getter_AddRefs(threadHdr));</span>
<a href="#l1.1003"></a><span id="l1.1003">   int32_t childCount = 0;</span>
<a href="#l1.1004"></a><span id="l1.1004"> </span>
<a href="#l1.1005"></a><span id="l1.1005">   nsMsgKey preservedKey;</span>
<a href="#l1.1006"></a><span id="l1.1006">   AutoTArray&lt;nsMsgKey, 1&gt; preservedSelection;</span>
<a href="#l1.1007"></a><span id="l1.1007">   int32_t selectionCount;</span>
<a href="#l1.1008"></a><span id="l1.1008">   int32_t currentIndex;</span>
<a href="#l1.1009"></a><span id="l1.1009">   bool hasSelection = mTree &amp;&amp; mTreeSelection &amp;&amp;</span>
<a href="#l1.1010"></a><span id="l1.1010" class="difflineminus">-                        ((NS_SUCCEEDED(mTreeSelection-&gt;GetCurrentIndex(&amp;currentIndex)) &amp;&amp;</span>
<a href="#l1.1011"></a><span id="l1.1011" class="difflineminus">-                         currentIndex &gt;= 0 &amp;&amp; (uint32_t)currentIndex &lt; GetSize()) ||</span>
<a href="#l1.1012"></a><span id="l1.1012" class="difflineminus">-                         (NS_SUCCEEDED(mTreeSelection-&gt;GetRangeCount(&amp;selectionCount)) &amp;&amp;</span>
<a href="#l1.1013"></a><span id="l1.1013" class="difflineminus">-                          selectionCount &gt; 0));</span>
<a href="#l1.1014"></a><span id="l1.1014" class="difflineplus">+                      ((NS_SUCCEEDED(mTreeSelection-&gt;GetCurrentIndex(&amp;currentIndex)) &amp;&amp;</span>
<a href="#l1.1015"></a><span id="l1.1015" class="difflineplus">+                        currentIndex &gt;= 0 &amp;&amp; (uint32_t)currentIndex &lt; GetSize()) ||</span>
<a href="#l1.1016"></a><span id="l1.1016" class="difflineplus">+                       (NS_SUCCEEDED(mTreeSelection-&gt;GetRangeCount(&amp;selectionCount)) &amp;&amp;</span>
<a href="#l1.1017"></a><span id="l1.1017" class="difflineplus">+                        selectionCount &gt; 0));</span>
<a href="#l1.1018"></a><span id="l1.1018">   if (hasSelection)</span>
<a href="#l1.1019"></a><span id="l1.1019">     SaveAndClearSelection(&amp;preservedKey, preservedSelection);</span>
<a href="#l1.1020"></a><span id="l1.1020" class="difflineplus">+</span>
<a href="#l1.1021"></a><span id="l1.1021">   uint32_t saveFlags = m_flags[threadIndex];</span>
<a href="#l1.1022"></a><span id="l1.1022">   bool threadIsExpanded = !(saveFlags &amp; nsMsgMessageFlags::Elided);</span>
<a href="#l1.1023"></a><span id="l1.1023"> </span>
<a href="#l1.1024"></a><span id="l1.1024">   if (threadIsExpanded)</span>
<a href="#l1.1025"></a><span id="l1.1025">   {</span>
<a href="#l1.1026"></a><span id="l1.1026">     ExpansionDelta(threadIndex, &amp;childCount);</span>
<a href="#l1.1027"></a><span id="l1.1027">     childCount = -childCount;</span>
<a href="#l1.1028"></a><span id="l1.1028">   }</span>
<a href="#l1.1029"></a><span id="l1.1029" class="difflineplus">+</span>
<a href="#l1.1030"></a><span id="l1.1030">   nsTArray&lt;nsMsgKey&gt; threadKeys;</span>
<a href="#l1.1031"></a><span id="l1.1031">   nsTArray&lt;uint32_t&gt; threadFlags;</span>
<a href="#l1.1032"></a><span id="l1.1032">   nsTArray&lt;uint8_t&gt; threadLevels;</span>
<a href="#l1.1033"></a><span id="l1.1033"> </span>
<a href="#l1.1034"></a><span id="l1.1034">   if (threadIsExpanded)</span>
<a href="#l1.1035"></a><span id="l1.1035">   {</span>
<a href="#l1.1036"></a><span id="l1.1036">     threadKeys.SetCapacity(childCount);</span>
<a href="#l1.1037"></a><span id="l1.1037">     threadFlags.SetCapacity(childCount);</span>
<a href="#l1.1038"></a><span id="l1.1038">     threadLevels.SetCapacity(childCount);</span>
<a href="#l1.1039"></a><span id="l1.1039">     for (nsMsgViewIndex index = threadIndex + 1;</span>
<a href="#l1.1040"></a><span id="l1.1040" class="difflineminus">-        index &lt; GetSize() &amp;&amp; m_levels[index]; index++)</span>
<a href="#l1.1041"></a><span id="l1.1041" class="difflineplus">+         index &lt; GetSize() &amp;&amp; m_levels[index];</span>
<a href="#l1.1042"></a><span id="l1.1042" class="difflineplus">+         index++)</span>
<a href="#l1.1043"></a><span id="l1.1043">     {</span>
<a href="#l1.1044"></a><span id="l1.1044">       threadKeys.AppendElement(m_keys[index]);</span>
<a href="#l1.1045"></a><span id="l1.1045">       threadFlags.AppendElement(m_flags[index]);</span>
<a href="#l1.1046"></a><span id="l1.1046">       threadLevels.AppendElement(m_levels[index]);</span>
<a href="#l1.1047"></a><span id="l1.1047">     }</span>
<a href="#l1.1048"></a><span id="l1.1048" class="difflineplus">+</span>
<a href="#l1.1049"></a><span id="l1.1049">     uint32_t collapseCount;</span>
<a href="#l1.1050"></a><span id="l1.1050">     CollapseByIndex(threadIndex, &amp;collapseCount);</span>
<a href="#l1.1051"></a><span id="l1.1051">   }</span>
<a href="#l1.1052"></a><span id="l1.1052" class="difflineplus">+</span>
<a href="#l1.1053"></a><span id="l1.1053">   nsMsgDBView::RemoveByIndex(threadIndex);</span>
<a href="#l1.1054"></a><span id="l1.1054">   nsMsgViewIndex newIndex = nsMsgViewIndex_None;</span>
<a href="#l1.1055"></a><span id="l1.1055">   AddHdr(threadHdr, &amp;newIndex);</span>
<a href="#l1.1056"></a><span id="l1.1056"> </span>
<a href="#l1.1057"></a><span id="l1.1057">   // AddHdr doesn't always set newIndex, and getting it to do so</span>
<a href="#l1.1058"></a><span id="l1.1058">   // is going to require some refactoring.</span>
<a href="#l1.1059"></a><span id="l1.1059">   if (newIndex == nsMsgViewIndex_None)</span>
<a href="#l1.1060"></a><span id="l1.1060">     newIndex = FindHdr(threadHdr);</span>
<a href="#l1.1061"></a><span id="l1.1061"> </span>
<a href="#l1.1062"></a><span id="l1.1062">   if (threadIsExpanded)</span>
<a href="#l1.1063"></a><span id="l1.1063">   {</span>
<a href="#l1.1064"></a><span id="l1.1064">     m_keys.InsertElementsAt(newIndex + 1, threadKeys);</span>
<a href="#l1.1065"></a><span id="l1.1065">     m_flags.InsertElementsAt(newIndex + 1, threadFlags);</span>
<a href="#l1.1066"></a><span id="l1.1066">     m_levels.InsertElementsAt(newIndex + 1, threadLevels);</span>
<a href="#l1.1067"></a><span id="l1.1067">   }</span>
<a href="#l1.1068"></a><span id="l1.1068" class="difflineplus">+</span>
<a href="#l1.1069"></a><span id="l1.1069">   if (newIndex == nsMsgViewIndex_None)</span>
<a href="#l1.1070"></a><span id="l1.1070">   {</span>
<a href="#l1.1071"></a><span id="l1.1071">      NS_WARNING(&quot;newIndex=-1 in MoveThreadAt&quot;);</span>
<a href="#l1.1072"></a><span id="l1.1072">      newIndex = 0;</span>
<a href="#l1.1073"></a><span id="l1.1073">   }</span>
<a href="#l1.1074"></a><span id="l1.1074" class="difflineplus">+</span>
<a href="#l1.1075"></a><span id="l1.1075">   m_flags[newIndex] = saveFlags;</span>
<a href="#l1.1076"></a><span id="l1.1076" class="difflineminus">-  // unfreeze selection.</span>
<a href="#l1.1077"></a><span id="l1.1077" class="difflineplus">+  // Unfreeze selection.</span>
<a href="#l1.1078"></a><span id="l1.1078">   if (hasSelection)</span>
<a href="#l1.1079"></a><span id="l1.1079">     RestoreSelection(preservedKey, preservedSelection);</span>
<a href="#l1.1080"></a><span id="l1.1080"> </span>
<a href="#l1.1081"></a><span id="l1.1081">   if (!changesDisabled)</span>
<a href="#l1.1082"></a><span id="l1.1082">     SetSuppressChangeNotifications(false);</span>
<a href="#l1.1083"></a><span id="l1.1083" class="difflineplus">+</span>
<a href="#l1.1084"></a><span id="l1.1084">   nsMsgViewIndex lowIndex = threadIndex &lt; newIndex ? threadIndex : newIndex;</span>
<a href="#l1.1085"></a><span id="l1.1085">   nsMsgViewIndex highIndex = lowIndex == threadIndex ? newIndex : threadIndex;</span>
<a href="#l1.1086"></a><span id="l1.1086" class="difflineplus">+</span>
<a href="#l1.1087"></a><span id="l1.1087">   NoteChange(lowIndex, highIndex - lowIndex + childCount + 1,</span>
<a href="#l1.1088"></a><span id="l1.1088">              nsMsgViewNotificationCode::changed);</span>
<a href="#l1.1089"></a><span id="l1.1089"> }</span>
<a href="#l1.1090"></a><span id="l1.1090" class="difflineminus">-nsresult nsMsgThreadedDBView::AddMsgToThreadNotInView(nsIMsgThread *threadHdr, nsIMsgDBHdr *msgHdr, bool ensureListed)</span>
<a href="#l1.1091"></a><span id="l1.1091" class="difflineplus">+</span>
<a href="#l1.1092"></a><span id="l1.1092" class="difflineplus">+nsresult</span>
<a href="#l1.1093"></a><span id="l1.1093" class="difflineplus">+nsMsgThreadedDBView::AddMsgToThreadNotInView(nsIMsgThread *threadHdr,</span>
<a href="#l1.1094"></a><span id="l1.1094" class="difflineplus">+                                             nsIMsgDBHdr *msgHdr,</span>
<a href="#l1.1095"></a><span id="l1.1095" class="difflineplus">+                                             bool ensureListed)</span>
<a href="#l1.1096"></a><span id="l1.1096"> {</span>
<a href="#l1.1097"></a><span id="l1.1097">   nsresult rv = NS_OK;</span>
<a href="#l1.1098"></a><span id="l1.1098">   uint32_t threadFlags;</span>
<a href="#l1.1099"></a><span id="l1.1099">   threadHdr-&gt;GetFlags(&amp;threadFlags);</span>
<a href="#l1.1100"></a><span id="l1.1100">   if (!(threadFlags &amp; nsMsgMessageFlags::Ignored))</span>
<a href="#l1.1101"></a><span id="l1.1101">   {</span>
<a href="#l1.1102"></a><span id="l1.1102">     bool msgKilled;</span>
<a href="#l1.1103"></a><span id="l1.1103">     msgHdr-&gt;GetIsKilled(&amp;msgKilled);</span>
<a href="#l1.1104"></a><span id="l1.1104">     if (!msgKilled)</span>
<a href="#l1.1105"></a><span id="l1.1105">       rv = nsMsgDBView::AddHdr(msgHdr);</span>
<a href="#l1.1106"></a><span id="l1.1106">   }</span>
<a href="#l1.1107"></a><span id="l1.1107" class="difflineplus">+</span>
<a href="#l1.1108"></a><span id="l1.1108">   return rv;</span>
<a href="#l1.1109"></a><span id="l1.1109"> }</span>
<a href="#l1.1110"></a><span id="l1.1110"> </span>
<a href="#l1.1111"></a><span id="l1.1111"> // This method just removes the specified line from the view. It does</span>
<a href="#l1.1112"></a><span id="l1.1112"> // NOT delete it from the database.</span>
<a href="#l1.1113"></a><span id="l1.1113" class="difflineminus">-nsresult nsMsgThreadedDBView::RemoveByIndex(nsMsgViewIndex index)</span>
<a href="#l1.1114"></a><span id="l1.1114" class="difflineplus">+nsresult</span>
<a href="#l1.1115"></a><span id="l1.1115" class="difflineplus">+nsMsgThreadedDBView::RemoveByIndex(nsMsgViewIndex index)</span>
<a href="#l1.1116"></a><span id="l1.1116"> {</span>
<a href="#l1.1117"></a><span id="l1.1117">   nsresult rv = NS_OK;</span>
<a href="#l1.1118"></a><span id="l1.1118">   int32_t flags;</span>
<a href="#l1.1119"></a><span id="l1.1119"> </span>
<a href="#l1.1120"></a><span id="l1.1120">   if (!IsValidIndex(index))</span>
<a href="#l1.1121"></a><span id="l1.1121">     return NS_MSG_INVALID_DBVIEW_INDEX;</span>
<a href="#l1.1122"></a><span id="l1.1122"> </span>
<a href="#l1.1123"></a><span id="l1.1123">   OnHeaderAddedOrDeleted();</span>
<a href="#l1.1124"></a><span id="l1.1124"> </span>
<a href="#l1.1125"></a><span id="l1.1125">   flags = m_flags[index];</span>
<a href="#l1.1126"></a><span id="l1.1126"> </span>
<a href="#l1.1127"></a><span id="l1.1127" class="difflineminus">-  if (! (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l1.1128"></a><span id="l1.1128" class="difflineplus">+  if (!(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l1.1129"></a><span id="l1.1129">     return nsMsgDBView::RemoveByIndex(index);</span>
<a href="#l1.1130"></a><span id="l1.1130"> </span>
<a href="#l1.1131"></a><span id="l1.1131">   nsCOMPtr&lt;nsIMsgThread&gt; threadHdr;</span>
<a href="#l1.1132"></a><span id="l1.1132">   GetThreadContainingIndex(index, getter_AddRefs(threadHdr));</span>
<a href="#l1.1133"></a><span id="l1.1133">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.1134"></a><span id="l1.1134">   uint32_t numThreadChildren = 0;</span>
<a href="#l1.1135"></a><span id="l1.1135">   // If we can't get a thread, it's already deleted and thus has 0 children.</span>
<a href="#l1.1136"></a><span id="l1.1136">   if (threadHdr)</span>
<a href="#l1.1137"></a><span id="l1.1137" class="difflineat">@@ -876,16 +1049,17 @@ nsresult nsMsgThreadedDBView::RemoveByIn</span>
<a href="#l1.1138"></a><span id="l1.1138">           if (numThreadChildren &gt; 1)</span>
<a href="#l1.1139"></a><span id="l1.1139">             flag |= MSG_VIEW_FLAG_ISTHREAD | MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l1.1140"></a><span id="l1.1140"> </span>
<a href="#l1.1141"></a><span id="l1.1141">           m_flags[index] = flag;</span>
<a href="#l1.1142"></a><span id="l1.1142">           m_levels[index] = 0;</span>
<a href="#l1.1143"></a><span id="l1.1143">         }</span>
<a href="#l1.1144"></a><span id="l1.1144">       }</span>
<a href="#l1.1145"></a><span id="l1.1145">     }</span>
<a href="#l1.1146"></a><span id="l1.1146" class="difflineplus">+</span>
<a href="#l1.1147"></a><span id="l1.1147">     return rv;</span>
<a href="#l1.1148"></a><span id="l1.1148">   }</span>
<a href="#l1.1149"></a><span id="l1.1149">   else if (!(flags &amp; MSG_VIEW_FLAG_ISTHREAD))</span>
<a href="#l1.1150"></a><span id="l1.1150">   {</span>
<a href="#l1.1151"></a><span id="l1.1151">     // We're not deleting the top level msg, but top level msg might be the</span>
<a href="#l1.1152"></a><span id="l1.1152">     // only msg in thread now.</span>
<a href="#l1.1153"></a><span id="l1.1153">     if (threadHdr &amp;&amp; numThreadChildren == 1)</span>
<a href="#l1.1154"></a><span id="l1.1154">     {</span>
<a href="#l1.1155"></a><span id="l1.1155" class="difflineat">@@ -901,79 +1075,88 @@ nsresult nsMsgThreadedDBView::RemoveByIn</span>
<a href="#l1.1156"></a><span id="l1.1156">                      nsMsgMessageFlags::Elided |</span>
<a href="#l1.1157"></a><span id="l1.1157">                      MSG_VIEW_FLAG_HASCHILDREN);</span>
<a href="#l1.1158"></a><span id="l1.1158">           m_flags[threadIndex] = flags;</span>
<a href="#l1.1159"></a><span id="l1.1159">           NoteChange(threadIndex, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l1.1160"></a><span id="l1.1160">         }</span>
<a href="#l1.1161"></a><span id="l1.1161">       }</span>
<a href="#l1.1162"></a><span id="l1.1162"> </span>
<a href="#l1.1163"></a><span id="l1.1163">     }</span>
<a href="#l1.1164"></a><span id="l1.1164" class="difflineplus">+</span>
<a href="#l1.1165"></a><span id="l1.1165">     return nsMsgDBView::RemoveByIndex(index);</span>
<a href="#l1.1166"></a><span id="l1.1166">   }</span>
<a href="#l1.1167"></a><span id="l1.1167" class="difflineplus">+</span>
<a href="#l1.1168"></a><span id="l1.1168">   // Deleting collapsed thread header is special case. Child will be promoted,</span>
<a href="#l1.1169"></a><span id="l1.1169">   // so just tell FE that line changed, not that it was deleted.</span>
<a href="#l1.1170"></a><span id="l1.1170">   // Header has aleady been deleted from thread.</span>
<a href="#l1.1171"></a><span id="l1.1171">   if (threadHdr &amp;&amp; numThreadChildren &gt; 0)</span>
<a href="#l1.1172"></a><span id="l1.1172">   {</span>
<a href="#l1.1173"></a><span id="l1.1173" class="difflineminus">-    // change the id array and flags array to reflect the child header.</span>
<a href="#l1.1174"></a><span id="l1.1174" class="difflineplus">+    // Change the id array and flags array to reflect the child header.</span>
<a href="#l1.1175"></a><span id="l1.1175">     // If we're not deleting the header, we want the second header,</span>
<a href="#l1.1176"></a><span id="l1.1176">     // Otherwise, the first one (which just got promoted).</span>
<a href="#l1.1177"></a><span id="l1.1177">     nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l1.1178"></a><span id="l1.1178">     rv = threadHdr-&gt;GetChildHdrAt(0, getter_AddRefs(msgHdr));</span>
<a href="#l1.1179"></a><span id="l1.1179">     if (msgHdr != nullptr)</span>
<a href="#l1.1180"></a><span id="l1.1180">     {</span>
<a href="#l1.1181"></a><span id="l1.1181">       msgHdr-&gt;GetMessageKey(&amp;m_keys[index]);</span>
<a href="#l1.1182"></a><span id="l1.1182" class="difflineminus">-</span>
<a href="#l1.1183"></a><span id="l1.1183">       uint32_t flag = 0;</span>
<a href="#l1.1184"></a><span id="l1.1184">       msgHdr-&gt;GetFlags(&amp;flag);</span>
<a href="#l1.1185"></a><span id="l1.1185">       flag |= MSG_VIEW_FLAG_ISTHREAD;</span>
<a href="#l1.1186"></a><span id="l1.1186"> </span>
<a href="#l1.1187"></a><span id="l1.1187" class="difflineminus">-      // if only hdr in thread (with one about to be deleted)</span>
<a href="#l1.1188"></a><span id="l1.1188" class="difflineplus">+      // If only hdr in thread (with one about to be deleted).</span>
<a href="#l1.1189"></a><span id="l1.1189">       if (numThreadChildren == 1)</span>
<a href="#l1.1190"></a><span id="l1.1190">       {</span>
<a href="#l1.1191"></a><span id="l1.1191" class="difflineminus">-        // adjust flags.</span>
<a href="#l1.1192"></a><span id="l1.1192" class="difflineplus">+        // Adjust flags.</span>
<a href="#l1.1193"></a><span id="l1.1193">         flag &amp;=  ~MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l1.1194"></a><span id="l1.1194">         flag &amp;= ~nsMsgMessageFlags::Elided;</span>
<a href="#l1.1195"></a><span id="l1.1195" class="difflineminus">-        // tell FE that thread header needs to be repainted.</span>
<a href="#l1.1196"></a><span id="l1.1196" class="difflineplus">+        // Tell FE that thread header needs to be repainted.</span>
<a href="#l1.1197"></a><span id="l1.1197">         NoteChange(index, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l1.1198"></a><span id="l1.1198">       }</span>
<a href="#l1.1199"></a><span id="l1.1199">       else</span>
<a href="#l1.1200"></a><span id="l1.1200">       {</span>
<a href="#l1.1201"></a><span id="l1.1201">         flag |= MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l1.1202"></a><span id="l1.1202">         flag |= nsMsgMessageFlags::Elided;</span>
<a href="#l1.1203"></a><span id="l1.1203">       }</span>
<a href="#l1.1204"></a><span id="l1.1204" class="difflineplus">+</span>
<a href="#l1.1205"></a><span id="l1.1205">       m_flags[index] = flag;</span>
<a href="#l1.1206"></a><span id="l1.1206">       mIndicesToNoteChange.RemoveElement(index);</span>
<a href="#l1.1207"></a><span id="l1.1207">     }</span>
<a href="#l1.1208"></a><span id="l1.1208">     else</span>
<a href="#l1.1209"></a><span id="l1.1209" class="difflineminus">-      NS_ASSERTION(false, &quot;couldn't find thread child&quot;);	</span>
<a href="#l1.1210"></a><span id="l1.1210" class="difflineplus">+    {</span>
<a href="#l1.1211"></a><span id="l1.1211" class="difflineplus">+      NS_ASSERTION(false, &quot;couldn't find thread child&quot;);</span>
<a href="#l1.1212"></a><span id="l1.1212" class="difflineplus">+    }</span>
<a href="#l1.1213"></a><span id="l1.1213"> </span>
<a href="#l1.1214"></a><span id="l1.1214" class="difflineminus">-    NoteChange(index, 1, nsMsgViewNotificationCode::changed);	</span>
<a href="#l1.1215"></a><span id="l1.1215" class="difflineplus">+    NoteChange(index, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l1.1216"></a><span id="l1.1216">   }</span>
<a href="#l1.1217"></a><span id="l1.1217">   else</span>
<a href="#l1.1218"></a><span id="l1.1218">   {</span>
<a href="#l1.1219"></a><span id="l1.1219" class="difflineminus">-    // we may have deleted a whole, collapsed thread - if so,</span>
<a href="#l1.1220"></a><span id="l1.1220" class="difflineplus">+    // We may have deleted a whole, collapsed thread - if so,</span>
<a href="#l1.1221"></a><span id="l1.1221">     // ensure that the current index will be noted as changed.</span>
<a href="#l1.1222"></a><span id="l1.1222">     if (!mIndicesToNoteChange.Contains(index))</span>
<a href="#l1.1223"></a><span id="l1.1223">       mIndicesToNoteChange.AppendElement(index);</span>
<a href="#l1.1224"></a><span id="l1.1224"> </span>
<a href="#l1.1225"></a><span id="l1.1225">     rv = nsMsgDBView::RemoveByIndex(index);</span>
<a href="#l1.1226"></a><span id="l1.1226">   }</span>
<a href="#l1.1227"></a><span id="l1.1227" class="difflineplus">+</span>
<a href="#l1.1228"></a><span id="l1.1228">   return rv;</span>
<a href="#l1.1229"></a><span id="l1.1229"> }</span>
<a href="#l1.1230"></a><span id="l1.1230"> </span>
<a href="#l1.1231"></a><span id="l1.1231" class="difflineminus">-NS_IMETHODIMP nsMsgThreadedDBView::GetViewType(nsMsgViewTypeValue *aViewType)</span>
<a href="#l1.1232"></a><span id="l1.1232" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l1.1233"></a><span id="l1.1233" class="difflineplus">+nsMsgThreadedDBView::GetViewType(nsMsgViewTypeValue *aViewType)</span>
<a href="#l1.1234"></a><span id="l1.1234"> {</span>
<a href="#l1.1235"></a><span id="l1.1235" class="difflineminus">-    NS_ENSURE_ARG_POINTER(aViewType);</span>
<a href="#l1.1236"></a><span id="l1.1236" class="difflineminus">-    *aViewType = nsMsgViewType::eShowAllThreads;</span>
<a href="#l1.1237"></a><span id="l1.1237" class="difflineminus">-    return NS_OK;</span>
<a href="#l1.1238"></a><span id="l1.1238" class="difflineplus">+  NS_ENSURE_ARG_POINTER(aViewType);</span>
<a href="#l1.1239"></a><span id="l1.1239" class="difflineplus">+  *aViewType = nsMsgViewType::eShowAllThreads;</span>
<a href="#l1.1240"></a><span id="l1.1240" class="difflineplus">+  return NS_OK;</span>
<a href="#l1.1241"></a><span id="l1.1241"> }</span>
<a href="#l1.1242"></a><span id="l1.1242"> </span>
<a href="#l1.1243"></a><span id="l1.1243"> NS_IMETHODIMP</span>
<a href="#l1.1244"></a><span id="l1.1244" class="difflineminus">-nsMsgThreadedDBView::CloneDBView(nsIMessenger *aMessengerInstance, nsIMsgWindow *aMsgWindow, nsIMsgDBViewCommandUpdater *aCmdUpdater, nsIMsgDBView **_retval)</span>
<a href="#l1.1245"></a><span id="l1.1245" class="difflineplus">+nsMsgThreadedDBView::CloneDBView(nsIMessenger *aMessengerInstance,</span>
<a href="#l1.1246"></a><span id="l1.1246" class="difflineplus">+                                 nsIMsgWindow *aMsgWindow,</span>
<a href="#l1.1247"></a><span id="l1.1247" class="difflineplus">+                                 nsIMsgDBViewCommandUpdater *aCmdUpdater,</span>
<a href="#l1.1248"></a><span id="l1.1248" class="difflineplus">+                                 nsIMsgDBView **_retval)</span>
<a href="#l1.1249"></a><span id="l1.1249"> {</span>
<a href="#l1.1250"></a><span id="l1.1250">   nsMsgThreadedDBView* newMsgDBView = new nsMsgThreadedDBView();</span>
<a href="#l1.1251"></a><span id="l1.1251"> </span>
<a href="#l1.1252"></a><span id="l1.1252">   if (!newMsgDBView)</span>
<a href="#l1.1253"></a><span id="l1.1253">     return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l1.1254"></a><span id="l1.1254"> </span>
<a href="#l1.1255"></a><span id="l1.1255">   nsresult rv = CopyDBView(newMsgDBView, aMessengerInstance, aMsgWindow, aCmdUpdater);</span>
<a href="#l1.1256"></a><span id="l1.1256">   NS_ENSURE_SUCCESS(rv,rv);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/base/src/nsMsgXFViewThread.cpp</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgXFViewThread.cpp</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -5,97 +5,109 @@</span>
<a href="#l2.4"></a><span id="l2.4"> </span>
<a href="#l2.5"></a><span id="l2.5"> #include &quot;msgCore.h&quot;</span>
<a href="#l2.6"></a><span id="l2.6"> #include &quot;nsMsgXFViewThread.h&quot;</span>
<a href="#l2.7"></a><span id="l2.7"> #include &quot;nsMsgSearchDBView.h&quot;</span>
<a href="#l2.8"></a><span id="l2.8"> #include &quot;nsMsgMessageFlags.h&quot;</span>
<a href="#l2.9"></a><span id="l2.9"> </span>
<a href="#l2.10"></a><span id="l2.10"> NS_IMPL_ISUPPORTS(nsMsgXFViewThread, nsIMsgThread)</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-nsMsgXFViewThread::nsMsgXFViewThread(nsMsgSearchDBView *view, nsMsgKey threadId)</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+nsMsgXFViewThread::nsMsgXFViewThread(nsMsgSearchDBView *view,</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+                                     nsMsgKey threadId)</span>
<a href="#l2.15"></a><span id="l2.15"> {</span>
<a href="#l2.16"></a><span id="l2.16">   m_numUnreadChildren = 0;</span>
<a href="#l2.17"></a><span id="l2.17">   m_numChildren = 0;</span>
<a href="#l2.18"></a><span id="l2.18">   m_flags = 0;</span>
<a href="#l2.19"></a><span id="l2.19">   m_newestMsgDate = 0;</span>
<a href="#l2.20"></a><span id="l2.20">   m_view = view;</span>
<a href="#l2.21"></a><span id="l2.21">   m_threadId = threadId;</span>
<a href="#l2.22"></a><span id="l2.22"> }</span>
<a href="#l2.23"></a><span id="l2.23"> </span>
<a href="#l2.24"></a><span id="l2.24"> nsMsgXFViewThread::~nsMsgXFViewThread()</span>
<a href="#l2.25"></a><span id="l2.25"> {</span>
<a href="#l2.26"></a><span id="l2.26"> }</span>
<a href="#l2.27"></a><span id="l2.27"> </span>
<a href="#l2.28"></a><span id="l2.28" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::SetThreadKey(nsMsgKey threadKey)</span>
<a href="#l2.29"></a><span id="l2.29" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.30"></a><span id="l2.30" class="difflineplus">+nsMsgXFViewThread::SetThreadKey(nsMsgKey threadKey)</span>
<a href="#l2.31"></a><span id="l2.31"> {</span>
<a href="#l2.32"></a><span id="l2.32">   m_threadId = threadKey;</span>
<a href="#l2.33"></a><span id="l2.33">   return NS_OK;</span>
<a href="#l2.34"></a><span id="l2.34"> }</span>
<a href="#l2.35"></a><span id="l2.35"> </span>
<a href="#l2.36"></a><span id="l2.36" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::GetThreadKey(nsMsgKey *aResult)</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+nsMsgXFViewThread::GetThreadKey(nsMsgKey *aResult)</span>
<a href="#l2.39"></a><span id="l2.39"> {</span>
<a href="#l2.40"></a><span id="l2.40">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l2.41"></a><span id="l2.41">   *aResult = m_threadId;</span>
<a href="#l2.42"></a><span id="l2.42">   return NS_OK;</span>
<a href="#l2.43"></a><span id="l2.43"> }</span>
<a href="#l2.44"></a><span id="l2.44"> </span>
<a href="#l2.45"></a><span id="l2.45" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::GetFlags(uint32_t *aFlags)</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineplus">+nsMsgXFViewThread::GetFlags(uint32_t *aFlags)</span>
<a href="#l2.48"></a><span id="l2.48"> {</span>
<a href="#l2.49"></a><span id="l2.49">   NS_ENSURE_ARG_POINTER(aFlags);</span>
<a href="#l2.50"></a><span id="l2.50">   *aFlags = m_flags;</span>
<a href="#l2.51"></a><span id="l2.51">   return NS_OK;</span>
<a href="#l2.52"></a><span id="l2.52"> }</span>
<a href="#l2.53"></a><span id="l2.53"> </span>
<a href="#l2.54"></a><span id="l2.54" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::SetFlags(uint32_t aFlags)</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+nsMsgXFViewThread::SetFlags(uint32_t aFlags)</span>
<a href="#l2.57"></a><span id="l2.57"> {</span>
<a href="#l2.58"></a><span id="l2.58">   m_flags = aFlags;</span>
<a href="#l2.59"></a><span id="l2.59">   return NS_OK;</span>
<a href="#l2.60"></a><span id="l2.60"> }</span>
<a href="#l2.61"></a><span id="l2.61"> </span>
<a href="#l2.62"></a><span id="l2.62" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::SetSubject(const nsACString&amp; aSubject)</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineplus">+nsMsgXFViewThread::SetSubject(const nsACString&amp; aSubject)</span>
<a href="#l2.65"></a><span id="l2.65"> {</span>
<a href="#l2.66"></a><span id="l2.66">   NS_ASSERTION(false, &quot;shouldn't call this&quot;);</span>
<a href="#l2.67"></a><span id="l2.67">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l2.68"></a><span id="l2.68"> }</span>
<a href="#l2.69"></a><span id="l2.69"> </span>
<a href="#l2.70"></a><span id="l2.70" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::GetSubject(nsACString&amp; result)</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.72"></a><span id="l2.72" class="difflineplus">+nsMsgXFViewThread::GetSubject(nsACString&amp; result)</span>
<a href="#l2.73"></a><span id="l2.73"> {</span>
<a href="#l2.74"></a><span id="l2.74">   NS_ASSERTION(false, &quot;shouldn't call this&quot;);</span>
<a href="#l2.75"></a><span id="l2.75">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l2.76"></a><span id="l2.76"> }</span>
<a href="#l2.77"></a><span id="l2.77"> </span>
<a href="#l2.78"></a><span id="l2.78" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::GetNumChildren(uint32_t *aNumChildren)</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineplus">+nsMsgXFViewThread::GetNumChildren(uint32_t *aNumChildren)</span>
<a href="#l2.81"></a><span id="l2.81"> {</span>
<a href="#l2.82"></a><span id="l2.82">   NS_ENSURE_ARG_POINTER(aNumChildren);</span>
<a href="#l2.83"></a><span id="l2.83">   *aNumChildren = m_keys.Length();</span>
<a href="#l2.84"></a><span id="l2.84">   return NS_OK;</span>
<a href="#l2.85"></a><span id="l2.85"> }</span>
<a href="#l2.86"></a><span id="l2.86"> </span>
<a href="#l2.87"></a><span id="l2.87" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::GetNumUnreadChildren (uint32_t *aNumUnreadChildren)</span>
<a href="#l2.88"></a><span id="l2.88" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.89"></a><span id="l2.89" class="difflineplus">+nsMsgXFViewThread::GetNumUnreadChildren (uint32_t *aNumUnreadChildren)</span>
<a href="#l2.90"></a><span id="l2.90"> {</span>
<a href="#l2.91"></a><span id="l2.91">   NS_ENSURE_ARG_POINTER(aNumUnreadChildren);</span>
<a href="#l2.92"></a><span id="l2.92">   *aNumUnreadChildren = m_numUnreadChildren;</span>
<a href="#l2.93"></a><span id="l2.93">   return NS_OK;</span>
<a href="#l2.94"></a><span id="l2.94"> }</span>
<a href="#l2.95"></a><span id="l2.95"> </span>
<a href="#l2.96"></a><span id="l2.96"> NS_IMETHODIMP</span>
<a href="#l2.97"></a><span id="l2.97" class="difflineminus">-nsMsgXFViewThread::AddChild(nsIMsgDBHdr *aNewHdr, nsIMsgDBHdr *aInReplyTo,</span>
<a href="#l2.98"></a><span id="l2.98" class="difflineminus">-                            bool aThreadInThread, nsIDBChangeAnnouncer *aAnnouncer)</span>
<a href="#l2.99"></a><span id="l2.99" class="difflineplus">+nsMsgXFViewThread::AddChild(nsIMsgDBHdr *aNewHdr,</span>
<a href="#l2.100"></a><span id="l2.100" class="difflineplus">+                            nsIMsgDBHdr *aInReplyTo,</span>
<a href="#l2.101"></a><span id="l2.101" class="difflineplus">+                            bool aThreadInThread,</span>
<a href="#l2.102"></a><span id="l2.102" class="difflineplus">+                            nsIDBChangeAnnouncer *aAnnouncer)</span>
<a href="#l2.103"></a><span id="l2.103"> {</span>
<a href="#l2.104"></a><span id="l2.104">   uint32_t whereInserted;</span>
<a href="#l2.105"></a><span id="l2.105">   return AddHdr(aNewHdr, false, whereInserted, nullptr);</span>
<a href="#l2.106"></a><span id="l2.106"> }</span>
<a href="#l2.107"></a><span id="l2.107"> </span>
<a href="#l2.108"></a><span id="l2.108"> // Returns the parent of the newly added header. If reparentChildren</span>
<a href="#l2.109"></a><span id="l2.109"> // is true, we believe that the new header is a parent of an existing</span>
<a href="#l2.110"></a><span id="l2.110"> // header, and we should find it, and reparent it.</span>
<a href="#l2.111"></a><span id="l2.111" class="difflineminus">-nsresult nsMsgXFViewThread::AddHdr(nsIMsgDBHdr *newHdr,</span>
<a href="#l2.112"></a><span id="l2.112" class="difflineminus">-                                   bool reparentChildren,</span>
<a href="#l2.113"></a><span id="l2.113" class="difflineminus">-                                   uint32_t &amp;whereInserted,</span>
<a href="#l2.114"></a><span id="l2.114" class="difflineminus">-                                   nsIMsgDBHdr **outParent)</span>
<a href="#l2.115"></a><span id="l2.115" class="difflineplus">+nsresult</span>
<a href="#l2.116"></a><span id="l2.116" class="difflineplus">+nsMsgXFViewThread::AddHdr(nsIMsgDBHdr *newHdr,</span>
<a href="#l2.117"></a><span id="l2.117" class="difflineplus">+                          bool reparentChildren,</span>
<a href="#l2.118"></a><span id="l2.118" class="difflineplus">+                          uint32_t &amp;whereInserted,</span>
<a href="#l2.119"></a><span id="l2.119" class="difflineplus">+                          nsIMsgDBHdr **outParent)</span>
<a href="#l2.120"></a><span id="l2.120"> {</span>
<a href="#l2.121"></a><span id="l2.121">   nsCOMPtr&lt;nsIMsgFolder&gt; newHdrFolder;</span>
<a href="#l2.122"></a><span id="l2.122">   newHdr-&gt;GetFolder(getter_AddRefs(newHdrFolder));</span>
<a href="#l2.123"></a><span id="l2.123"> </span>
<a href="#l2.124"></a><span id="l2.124">   uint32_t newHdrFlags = 0;</span>
<a href="#l2.125"></a><span id="l2.125">   uint32_t msgDate;</span>
<a href="#l2.126"></a><span id="l2.126">   nsMsgKey newHdrKey = 0;</span>
<a href="#l2.127"></a><span id="l2.127"> </span>
<a href="#l2.128"></a><span id="l2.128" class="difflineat">@@ -114,16 +126,17 @@ nsresult nsMsgXFViewThread::AddHdr(nsIMs</span>
<a href="#l2.129"></a><span id="l2.129"> </span>
<a href="#l2.130"></a><span id="l2.130">   if (m_numChildren == 1)</span>
<a href="#l2.131"></a><span id="l2.131">   {</span>
<a href="#l2.132"></a><span id="l2.132">     m_keys.InsertElementAt(0, newHdrKey);</span>
<a href="#l2.133"></a><span id="l2.133">     m_levels.InsertElementAt(0, 0);</span>
<a href="#l2.134"></a><span id="l2.134">     m_folders.InsertObjectAt(newHdrFolder, 0);</span>
<a href="#l2.135"></a><span id="l2.135">     if (outParent)</span>
<a href="#l2.136"></a><span id="l2.136">       *outParent = nullptr;</span>
<a href="#l2.137"></a><span id="l2.137" class="difflineplus">+</span>
<a href="#l2.138"></a><span id="l2.138">     whereInserted = 0;</span>
<a href="#l2.139"></a><span id="l2.139">     return NS_OK;</span>
<a href="#l2.140"></a><span id="l2.140">   }</span>
<a href="#l2.141"></a><span id="l2.141"> </span>
<a href="#l2.142"></a><span id="l2.142">   // Find our parent, if any, in the thread. Starting at the newest</span>
<a href="#l2.143"></a><span id="l2.143">   // reference, and working our way back, see if we've mapped that reference</span>
<a href="#l2.144"></a><span id="l2.144">   // to this thread.</span>
<a href="#l2.145"></a><span id="l2.145">   uint16_t numReferences;</span>
<a href="#l2.146"></a><span id="l2.146" class="difflineat">@@ -145,88 +158,98 @@ nsresult nsMsgXFViewThread::AddHdr(nsIMs</span>
<a href="#l2.147"></a><span id="l2.147">     if (parent)</span>
<a href="#l2.148"></a><span id="l2.148">     {</span>
<a href="#l2.149"></a><span id="l2.149">       parentIndex = HdrIndex(parent);</span>
<a href="#l2.150"></a><span id="l2.150">       if (parentIndex == -1)</span>
<a href="#l2.151"></a><span id="l2.151">       {</span>
<a href="#l2.152"></a><span id="l2.152">         NS_ERROR(&quot;how did we get in the wrong thread?&quot;);</span>
<a href="#l2.153"></a><span id="l2.153">         parent = nullptr;</span>
<a href="#l2.154"></a><span id="l2.154">       }</span>
<a href="#l2.155"></a><span id="l2.155" class="difflineplus">+</span>
<a href="#l2.156"></a><span id="l2.156">       break;</span>
<a href="#l2.157"></a><span id="l2.157">     }</span>
<a href="#l2.158"></a><span id="l2.158">   }</span>
<a href="#l2.159"></a><span id="l2.159" class="difflineplus">+</span>
<a href="#l2.160"></a><span id="l2.160">   if (parent)</span>
<a href="#l2.161"></a><span id="l2.161">   {</span>
<a href="#l2.162"></a><span id="l2.162">     uint32_t parentLevel = m_levels[parentIndex];</span>
<a href="#l2.163"></a><span id="l2.163">     nsMsgKey parentKey;</span>
<a href="#l2.164"></a><span id="l2.164">     parent-&gt;GetMessageKey(&amp;parentKey);</span>
<a href="#l2.165"></a><span id="l2.165">     nsCOMPtr&lt;nsIMsgFolder&gt; parentFolder;</span>
<a href="#l2.166"></a><span id="l2.166">     parent-&gt;GetFolder(getter_AddRefs(parentFolder));</span>
<a href="#l2.167"></a><span id="l2.167"> </span>
<a href="#l2.168"></a><span id="l2.168">     if (outParent)</span>
<a href="#l2.169"></a><span id="l2.169">       parent.forget(outParent);</span>
<a href="#l2.170"></a><span id="l2.170"> </span>
<a href="#l2.171"></a><span id="l2.171" class="difflineminus">-    // iterate over our parents' children until we find one we're older than,</span>
<a href="#l2.172"></a><span id="l2.172" class="difflineplus">+    // Iterate over our parents' children until we find one we're older than,</span>
<a href="#l2.173"></a><span id="l2.173">     // and insert ourselves before it, or as the last child. In other words,</span>
<a href="#l2.174"></a><span id="l2.174">     // insert, sorted by date.</span>
<a href="#l2.175"></a><span id="l2.175">     uint32_t msgDate, childDate;</span>
<a href="#l2.176"></a><span id="l2.176">     newHdr-&gt;GetDateInSeconds(&amp;msgDate);</span>
<a href="#l2.177"></a><span id="l2.177">     nsCOMPtr&lt;nsIMsgDBHdr&gt; child;</span>
<a href="#l2.178"></a><span id="l2.178">     nsMsgViewIndex i;</span>
<a href="#l2.179"></a><span id="l2.179">     nsMsgViewIndex insertIndex = m_keys.Length();</span>
<a href="#l2.180"></a><span id="l2.180">     uint32_t insertLevel = parentLevel + 1;</span>
<a href="#l2.181"></a><span id="l2.181">     for (i = parentIndex;</span>
<a href="#l2.182"></a><span id="l2.182" class="difflineminus">-         i &lt; m_keys.Length() &amp;&amp; (i == (nsMsgViewIndex)parentIndex || m_levels[i] &gt;= parentLevel);</span>
<a href="#l2.183"></a><span id="l2.183" class="difflineplus">+         i &lt; m_keys.Length() &amp;&amp;</span>
<a href="#l2.184"></a><span id="l2.184" class="difflineplus">+           (i == (nsMsgViewIndex)parentIndex || m_levels[i] &gt;= parentLevel);</span>
<a href="#l2.185"></a><span id="l2.185">          i++)</span>
<a href="#l2.186"></a><span id="l2.186">     {</span>
<a href="#l2.187"></a><span id="l2.187">       GetChildHdrAt(i, getter_AddRefs(child));</span>
<a href="#l2.188"></a><span id="l2.188">       if (child)</span>
<a href="#l2.189"></a><span id="l2.189">       {</span>
<a href="#l2.190"></a><span id="l2.190">         if (reparentChildren &amp;&amp; IsHdrParentOf(newHdr, child))</span>
<a href="#l2.191"></a><span id="l2.191">         {</span>
<a href="#l2.192"></a><span id="l2.192">           insertIndex = i;</span>
<a href="#l2.193"></a><span id="l2.193" class="difflineminus">-          // bump all the children of the current child, and the child</span>
<a href="#l2.194"></a><span id="l2.194" class="difflineplus">+          // Bump all the children of the current child, and the child.</span>
<a href="#l2.195"></a><span id="l2.195">           nsMsgViewIndex j = insertIndex;</span>
<a href="#l2.196"></a><span id="l2.196">           uint8_t childLevel = m_levels[insertIndex];</span>
<a href="#l2.197"></a><span id="l2.197">           do</span>
<a href="#l2.198"></a><span id="l2.198">           {</span>
<a href="#l2.199"></a><span id="l2.199">             m_levels[j] = m_levels[j] + 1;</span>
<a href="#l2.200"></a><span id="l2.200">             j++;</span>
<a href="#l2.201"></a><span id="l2.201">           }</span>
<a href="#l2.202"></a><span id="l2.202">           while (j &lt; m_keys.Length() &amp;&amp; m_levels[j] &gt; childLevel);</span>
<a href="#l2.203"></a><span id="l2.203">           break;</span>
<a href="#l2.204"></a><span id="l2.204">         }</span>
<a href="#l2.205"></a><span id="l2.205" class="difflineminus">-        else if (m_levels[i] == parentLevel + 1) // possible sibling</span>
<a href="#l2.206"></a><span id="l2.206" class="difflineplus">+        else if (m_levels[i] == parentLevel + 1)</span>
<a href="#l2.207"></a><span id="l2.207">         {</span>
<a href="#l2.208"></a><span id="l2.208" class="difflineplus">+          // Possible sibling.</span>
<a href="#l2.209"></a><span id="l2.209">           child-&gt;GetDateInSeconds(&amp;childDate);</span>
<a href="#l2.210"></a><span id="l2.210">           if (msgDate &lt; childDate)</span>
<a href="#l2.211"></a><span id="l2.211">           {</span>
<a href="#l2.212"></a><span id="l2.212" class="difflineminus">-            // if we think we need to reparent, remember this</span>
<a href="#l2.213"></a><span id="l2.213" class="difflineminus">-            // insert index, but keep looking for children.</span>
<a href="#l2.214"></a><span id="l2.214" class="difflineplus">+            // If we think we need to reparent, remember this insert index,</span>
<a href="#l2.215"></a><span id="l2.215" class="difflineplus">+            // but keep looking for children.</span>
<a href="#l2.216"></a><span id="l2.216">             insertIndex = i;</span>
<a href="#l2.217"></a><span id="l2.217">             insertLevel = m_levels[i];</span>
<a href="#l2.218"></a><span id="l2.218" class="difflineminus">-            // if the sibling we're inserting after has children, we need</span>
<a href="#l2.219"></a><span id="l2.219" class="difflineplus">+            // If the sibling we're inserting after has children, we need</span>
<a href="#l2.220"></a><span id="l2.220">             // to go after the children.</span>
<a href="#l2.221"></a><span id="l2.221" class="difflineminus">-            while (insertIndex + 1 &lt; m_keys.Length() &amp;&amp; m_levels[insertIndex + 1] &gt; insertLevel)</span>
<a href="#l2.222"></a><span id="l2.222" class="difflineplus">+            while (insertIndex + 1 &lt; m_keys.Length() &amp;&amp;</span>
<a href="#l2.223"></a><span id="l2.223" class="difflineplus">+                   m_levels[insertIndex + 1] &gt; insertLevel)</span>
<a href="#l2.224"></a><span id="l2.224" class="difflineplus">+            {</span>
<a href="#l2.225"></a><span id="l2.225">               insertIndex++;</span>
<a href="#l2.226"></a><span id="l2.226" class="difflineplus">+            }</span>
<a href="#l2.227"></a><span id="l2.227" class="difflineplus">+</span>
<a href="#l2.228"></a><span id="l2.228">             if (!reparentChildren)</span>
<a href="#l2.229"></a><span id="l2.229">               break;</span>
<a href="#l2.230"></a><span id="l2.230">           }</span>
<a href="#l2.231"></a><span id="l2.231">         }</span>
<a href="#l2.232"></a><span id="l2.232">       }</span>
<a href="#l2.233"></a><span id="l2.233">     }</span>
<a href="#l2.234"></a><span id="l2.234" class="difflineplus">+</span>
<a href="#l2.235"></a><span id="l2.235">     m_keys.InsertElementAt(insertIndex, newHdrKey);</span>
<a href="#l2.236"></a><span id="l2.236">     m_levels.InsertElementAt(insertIndex, insertLevel);</span>
<a href="#l2.237"></a><span id="l2.237">     m_folders.InsertObjectAt(newHdrFolder, insertIndex);</span>
<a href="#l2.238"></a><span id="l2.238">     whereInserted = insertIndex;</span>
<a href="#l2.239"></a><span id="l2.239">   }</span>
<a href="#l2.240"></a><span id="l2.240">   else</span>
<a href="#l2.241"></a><span id="l2.241">   {</span>
<a href="#l2.242"></a><span id="l2.242">     if (outParent)</span>
<a href="#l2.243"></a><span id="l2.243">       *outParent = nullptr;</span>
<a href="#l2.244"></a><span id="l2.244" class="difflineplus">+</span>
<a href="#l2.245"></a><span id="l2.245">     nsCOMPtr&lt;nsIMsgDBHdr&gt; rootHdr;</span>
<a href="#l2.246"></a><span id="l2.246">     GetChildHdrAt(0, getter_AddRefs(rootHdr));</span>
<a href="#l2.247"></a><span id="l2.247">     // If the new header is a parent of the root then it should be promoted.</span>
<a href="#l2.248"></a><span id="l2.248">     if (rootHdr &amp;&amp; IsHdrParentOf(newHdr, rootHdr))</span>
<a href="#l2.249"></a><span id="l2.249">     {</span>
<a href="#l2.250"></a><span id="l2.250">       m_keys.InsertElementAt(0, newHdrKey);</span>
<a href="#l2.251"></a><span id="l2.251">       m_levels.InsertElementAt(0, 0);</span>
<a href="#l2.252"></a><span id="l2.252">       m_folders.InsertObjectAt(newHdrFolder, 0);</span>
<a href="#l2.253"></a><span id="l2.253" class="difflineat">@@ -237,16 +260,17 @@ nsresult nsMsgXFViewThread::AddHdr(nsIMs</span>
<a href="#l2.254"></a><span id="l2.254">     }</span>
<a href="#l2.255"></a><span id="l2.255">     else</span>
<a href="#l2.256"></a><span id="l2.256">     {</span>
<a href="#l2.257"></a><span id="l2.257">       m_keys.AppendElement(newHdrKey);</span>
<a href="#l2.258"></a><span id="l2.258">       m_levels.AppendElement(1);</span>
<a href="#l2.259"></a><span id="l2.259">       m_folders.AppendObject(newHdrFolder);</span>
<a href="#l2.260"></a><span id="l2.260">       if (outParent)</span>
<a href="#l2.261"></a><span id="l2.261">         rootHdr.forget(outParent);</span>
<a href="#l2.262"></a><span id="l2.262" class="difflineplus">+</span>
<a href="#l2.263"></a><span id="l2.263">       whereInserted = m_keys.Length() -1;</span>
<a href="#l2.264"></a><span id="l2.264">     }</span>
<a href="#l2.265"></a><span id="l2.265">   }</span>
<a href="#l2.266"></a><span id="l2.266"> </span>
<a href="#l2.267"></a><span id="l2.267">   // ### TODO handle the case where the root header starts</span>
<a href="#l2.268"></a><span id="l2.268">   // with Re, and the new one doesn't, and is earlier. In that</span>
<a href="#l2.269"></a><span id="l2.269">   // case, we want to promote the new header to root.</span>
<a href="#l2.270"></a><span id="l2.270"> </span>
<a href="#l2.271"></a><span id="l2.271" class="difflineat">@@ -261,152 +285,181 @@ nsresult nsMsgXFViewThread::AddHdr(nsIMs</span>
<a href="#l2.272"></a><span id="l2.272"> //    rv = GetRootHdr(nullptr, getter_AddRefs(topLevelHdr));</span>
<a href="#l2.273"></a><span id="l2.273"> //    if (NS_SUCCEEDED(rv) &amp;&amp; topLevelHdr)</span>
<a href="#l2.274"></a><span id="l2.274"> //    {</span>
<a href="#l2.275"></a><span id="l2.275"> //      topLevelHdr-&gt;GetDate(&amp;topLevelHdrDate);</span>
<a href="#l2.276"></a><span id="l2.276"> //      if (newHdrDate &lt; topLevelHdrDate)</span>
<a href="#l2.277"></a><span id="l2.277"> </span>
<a href="#l2.278"></a><span id="l2.278"> //    }</span>
<a href="#l2.279"></a><span id="l2.279"> //  }</span>
<a href="#l2.280"></a><span id="l2.280" class="difflineplus">+</span>
<a href="#l2.281"></a><span id="l2.281">   return NS_OK;</span>
<a href="#l2.282"></a><span id="l2.282"> }</span>
<a href="#l2.283"></a><span id="l2.283"> </span>
<a href="#l2.284"></a><span id="l2.284" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::GetChildHdrAt(uint32_t aIndex, nsIMsgDBHdr **aResult)</span>
<a href="#l2.285"></a><span id="l2.285" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.286"></a><span id="l2.286" class="difflineplus">+nsMsgXFViewThread::GetChildHdrAt(uint32_t aIndex,</span>
<a href="#l2.287"></a><span id="l2.287" class="difflineplus">+                                 nsIMsgDBHdr **aResult)</span>
<a href="#l2.288"></a><span id="l2.288"> {</span>
<a href="#l2.289"></a><span id="l2.289">   if (aIndex &gt;= m_keys.Length())</span>
<a href="#l2.290"></a><span id="l2.290">     return NS_MSG_MESSAGE_NOT_FOUND;</span>
<a href="#l2.291"></a><span id="l2.291" class="difflineplus">+</span>
<a href="#l2.292"></a><span id="l2.292">   nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l2.293"></a><span id="l2.293">   nsresult rv = m_folders[aIndex]-&gt;GetMsgDatabase(getter_AddRefs(db));</span>
<a href="#l2.294"></a><span id="l2.294">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l2.295"></a><span id="l2.295">   return db-&gt;GetMsgHdrForKey(m_keys[aIndex], aResult);</span>
<a href="#l2.296"></a><span id="l2.296"> }</span>
<a href="#l2.297"></a><span id="l2.297"> </span>
<a href="#l2.298"></a><span id="l2.298" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::RemoveChildAt(uint32_t aIndex)</span>
<a href="#l2.299"></a><span id="l2.299" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.300"></a><span id="l2.300" class="difflineplus">+nsMsgXFViewThread::RemoveChildAt(uint32_t aIndex)</span>
<a href="#l2.301"></a><span id="l2.301"> {</span>
<a href="#l2.302"></a><span id="l2.302">   m_keys.RemoveElementAt(aIndex);</span>
<a href="#l2.303"></a><span id="l2.303">   m_levels.RemoveElementAt(aIndex);</span>
<a href="#l2.304"></a><span id="l2.304">   m_folders.RemoveObjectAt(aIndex);</span>
<a href="#l2.305"></a><span id="l2.305">   return NS_OK;</span>
<a href="#l2.306"></a><span id="l2.306"> }</span>
<a href="#l2.307"></a><span id="l2.307"> </span>
<a href="#l2.308"></a><span id="l2.308" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::RemoveChildHdr(nsIMsgDBHdr *child, nsIDBChangeAnnouncer *announcer)</span>
<a href="#l2.309"></a><span id="l2.309" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.310"></a><span id="l2.310" class="difflineplus">+nsMsgXFViewThread::RemoveChildHdr(nsIMsgDBHdr *child,</span>
<a href="#l2.311"></a><span id="l2.311" class="difflineplus">+                                  nsIDBChangeAnnouncer *announcer)</span>
<a href="#l2.312"></a><span id="l2.312"> {</span>
<a href="#l2.313"></a><span id="l2.313">   NS_ENSURE_ARG_POINTER(child);</span>
<a href="#l2.314"></a><span id="l2.314">   nsMsgKey msgKey;</span>
<a href="#l2.315"></a><span id="l2.315">   uint32_t msgFlags;</span>
<a href="#l2.316"></a><span id="l2.316">   child-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l2.317"></a><span id="l2.317">   child-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l2.318"></a><span id="l2.318">   nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l2.319"></a><span id="l2.319">   child-&gt;GetFolder(getter_AddRefs(msgFolder));</span>
<a href="#l2.320"></a><span id="l2.320" class="difflineminus">-  // if this was the newest msg, clear the newest msg date so we'll recalc.</span>
<a href="#l2.321"></a><span id="l2.321" class="difflineplus">+  // If this was the newest msg, clear the newest msg date so we'll recalc.</span>
<a href="#l2.322"></a><span id="l2.322">   uint32_t date;</span>
<a href="#l2.323"></a><span id="l2.323">   child-&gt;GetDateInSeconds(&amp;date);</span>
<a href="#l2.324"></a><span id="l2.324">   if (date == m_newestMsgDate)</span>
<a href="#l2.325"></a><span id="l2.325">     SetNewestMsgDate(0);</span>
<a href="#l2.326"></a><span id="l2.326"> </span>
<a href="#l2.327"></a><span id="l2.327">   for (uint32_t childIndex = 0; childIndex &lt; m_keys.Length(); childIndex++)</span>
<a href="#l2.328"></a><span id="l2.328">   {</span>
<a href="#l2.329"></a><span id="l2.329">     if (m_keys[childIndex] == msgKey &amp;&amp; m_folders[childIndex] == msgFolder)</span>
<a href="#l2.330"></a><span id="l2.330">     {</span>
<a href="#l2.331"></a><span id="l2.331">       uint8_t levelRemoved = m_keys[childIndex];</span>
<a href="#l2.332"></a><span id="l2.332" class="difflineminus">-      // Adjust the levels of all the children of this header</span>
<a href="#l2.333"></a><span id="l2.333" class="difflineplus">+      // Adjust the levels of all the children of this header.</span>
<a href="#l2.334"></a><span id="l2.334">       nsMsgViewIndex i;</span>
<a href="#l2.335"></a><span id="l2.335">       for (i = childIndex + 1;</span>
<a href="#l2.336"></a><span id="l2.336" class="difflineminus">-               i &lt; m_keys.Length() &amp;&amp; m_levels[i] &gt; levelRemoved; i++)</span>
<a href="#l2.337"></a><span id="l2.337" class="difflineminus">-            m_levels[i] = m_levels[i] - 1;</span>
<a href="#l2.338"></a><span id="l2.338" class="difflineplus">+           i &lt; m_keys.Length() &amp;&amp; m_levels[i] &gt; levelRemoved;</span>
<a href="#l2.339"></a><span id="l2.339" class="difflineplus">+           i++)</span>
<a href="#l2.340"></a><span id="l2.340" class="difflineplus">+      {</span>
<a href="#l2.341"></a><span id="l2.341" class="difflineplus">+        m_levels[i] = m_levels[i] - 1;</span>
<a href="#l2.342"></a><span id="l2.342" class="difflineplus">+      }</span>
<a href="#l2.343"></a><span id="l2.343"> </span>
<a href="#l2.344"></a><span id="l2.344">       m_view-&gt;NoteChange(childIndex + 1, i - childIndex + 1,</span>
<a href="#l2.345"></a><span id="l2.345">                          nsMsgViewNotificationCode::changed);</span>
<a href="#l2.346"></a><span id="l2.346">       m_keys.RemoveElementAt(childIndex);</span>
<a href="#l2.347"></a><span id="l2.347">       m_levels.RemoveElementAt(childIndex);</span>
<a href="#l2.348"></a><span id="l2.348">       m_folders.RemoveObjectAt(childIndex);</span>
<a href="#l2.349"></a><span id="l2.349">       if (!(msgFlags &amp; nsMsgMessageFlags::Read))</span>
<a href="#l2.350"></a><span id="l2.350">         ChangeUnreadChildCount(-1);</span>
<a href="#l2.351"></a><span id="l2.351" class="difflineplus">+</span>
<a href="#l2.352"></a><span id="l2.352">       ChangeChildCount(-1);</span>
<a href="#l2.353"></a><span id="l2.353">       return NS_OK;</span>
<a href="#l2.354"></a><span id="l2.354">     }</span>
<a href="#l2.355"></a><span id="l2.355">   }</span>
<a href="#l2.356"></a><span id="l2.356" class="difflineplus">+</span>
<a href="#l2.357"></a><span id="l2.357">   return NS_ERROR_FAILURE;</span>
<a href="#l2.358"></a><span id="l2.358"> }</span>
<a href="#l2.359"></a><span id="l2.359"> </span>
<a href="#l2.360"></a><span id="l2.360" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::GetRootHdr(int32_t *aResultIndex, nsIMsgDBHdr **aResult)</span>
<a href="#l2.361"></a><span id="l2.361" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.362"></a><span id="l2.362" class="difflineplus">+nsMsgXFViewThread::GetRootHdr(int32_t *aResultIndex,</span>
<a href="#l2.363"></a><span id="l2.363" class="difflineplus">+                              nsIMsgDBHdr **aResult)</span>
<a href="#l2.364"></a><span id="l2.364"> {</span>
<a href="#l2.365"></a><span id="l2.365">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l2.366"></a><span id="l2.366">   if (aResultIndex)</span>
<a href="#l2.367"></a><span id="l2.367">     *aResultIndex = 0;</span>
<a href="#l2.368"></a><span id="l2.368" class="difflineplus">+</span>
<a href="#l2.369"></a><span id="l2.369">   return GetChildHdrAt(0, aResult);</span>
<a href="#l2.370"></a><span id="l2.370"> }</span>
<a href="#l2.371"></a><span id="l2.371"> </span>
<a href="#l2.372"></a><span id="l2.372" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::GetChildKeyAt(uint32_t aIndex, nsMsgKey *aResult)</span>
<a href="#l2.373"></a><span id="l2.373" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.374"></a><span id="l2.374" class="difflineplus">+nsMsgXFViewThread::GetChildKeyAt(uint32_t aIndex,</span>
<a href="#l2.375"></a><span id="l2.375" class="difflineplus">+                                 nsMsgKey *aResult)</span>
<a href="#l2.376"></a><span id="l2.376"> {</span>
<a href="#l2.377"></a><span id="l2.377">   NS_ASSERTION(false, &quot;shouldn't call this&quot;);</span>
<a href="#l2.378"></a><span id="l2.378">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l2.379"></a><span id="l2.379"> }</span>
<a href="#l2.380"></a><span id="l2.380"> </span>
<a href="#l2.381"></a><span id="l2.381" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::GetChild(nsMsgKey msgKey, nsIMsgDBHdr **aResult)</span>
<a href="#l2.382"></a><span id="l2.382" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.383"></a><span id="l2.383" class="difflineplus">+nsMsgXFViewThread::GetChild(nsMsgKey msgKey,</span>
<a href="#l2.384"></a><span id="l2.384" class="difflineplus">+                            nsIMsgDBHdr **aResult)</span>
<a href="#l2.385"></a><span id="l2.385"> {</span>
<a href="#l2.386"></a><span id="l2.386">   NS_ASSERTION(false, &quot;shouldn't call this&quot;);</span>
<a href="#l2.387"></a><span id="l2.387">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l2.388"></a><span id="l2.388"> }</span>
<a href="#l2.389"></a><span id="l2.389"> </span>
<a href="#l2.390"></a><span id="l2.390"> </span>
<a href="#l2.391"></a><span id="l2.391" class="difflineminus">-int32_t nsMsgXFViewThread::HdrIndex(nsIMsgDBHdr *hdr)</span>
<a href="#l2.392"></a><span id="l2.392" class="difflineplus">+int32_t</span>
<a href="#l2.393"></a><span id="l2.393" class="difflineplus">+nsMsgXFViewThread::HdrIndex(nsIMsgDBHdr *hdr)</span>
<a href="#l2.394"></a><span id="l2.394"> {</span>
<a href="#l2.395"></a><span id="l2.395">   nsMsgKey msgKey;</span>
<a href="#l2.396"></a><span id="l2.396">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l2.397"></a><span id="l2.397">   hdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l2.398"></a><span id="l2.398">   hdr-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l2.399"></a><span id="l2.399">   for (uint32_t i = 0; i &lt; m_keys.Length(); i++)</span>
<a href="#l2.400"></a><span id="l2.400">   {</span>
<a href="#l2.401"></a><span id="l2.401">     if (m_keys[i] == msgKey &amp;&amp; m_folders[i] == folder)</span>
<a href="#l2.402"></a><span id="l2.402">       return i;</span>
<a href="#l2.403"></a><span id="l2.403">   }</span>
<a href="#l2.404"></a><span id="l2.404" class="difflineplus">+</span>
<a href="#l2.405"></a><span id="l2.405">   return -1;</span>
<a href="#l2.406"></a><span id="l2.406"> }</span>
<a href="#l2.407"></a><span id="l2.407"> </span>
<a href="#l2.408"></a><span id="l2.408" class="difflineminus">-void nsMsgXFViewThread::ChangeUnreadChildCount(int32_t delta)</span>
<a href="#l2.409"></a><span id="l2.409" class="difflineplus">+void</span>
<a href="#l2.410"></a><span id="l2.410" class="difflineplus">+nsMsgXFViewThread::ChangeUnreadChildCount(int32_t delta)</span>
<a href="#l2.411"></a><span id="l2.411"> {</span>
<a href="#l2.412"></a><span id="l2.412">   m_numUnreadChildren += delta;</span>
<a href="#l2.413"></a><span id="l2.413"> }</span>
<a href="#l2.414"></a><span id="l2.414"> </span>
<a href="#l2.415"></a><span id="l2.415" class="difflineminus">-void nsMsgXFViewThread::ChangeChildCount(int32_t delta)</span>
<a href="#l2.416"></a><span id="l2.416" class="difflineplus">+void</span>
<a href="#l2.417"></a><span id="l2.417" class="difflineplus">+nsMsgXFViewThread::ChangeChildCount(int32_t delta)</span>
<a href="#l2.418"></a><span id="l2.418"> {</span>
<a href="#l2.419"></a><span id="l2.419">   m_numChildren += delta;</span>
<a href="#l2.420"></a><span id="l2.420"> }</span>
<a href="#l2.421"></a><span id="l2.421"> </span>
<a href="#l2.422"></a><span id="l2.422" class="difflineminus">-bool nsMsgXFViewThread::IsHdrParentOf(nsIMsgDBHdr *possibleParent,</span>
<a href="#l2.423"></a><span id="l2.423" class="difflineminus">-                                        nsIMsgDBHdr *possibleChild)</span>
<a href="#l2.424"></a><span id="l2.424" class="difflineplus">+bool</span>
<a href="#l2.425"></a><span id="l2.425" class="difflineplus">+nsMsgXFViewThread::IsHdrParentOf(nsIMsgDBHdr *possibleParent,</span>
<a href="#l2.426"></a><span id="l2.426" class="difflineplus">+                                 nsIMsgDBHdr *possibleChild)</span>
<a href="#l2.427"></a><span id="l2.427"> {</span>
<a href="#l2.428"></a><span id="l2.428">   uint16_t referenceToCheck = 0;</span>
<a href="#l2.429"></a><span id="l2.429">   possibleChild-&gt;GetNumReferences(&amp;referenceToCheck);</span>
<a href="#l2.430"></a><span id="l2.430">   nsAutoCString reference;</span>
<a href="#l2.431"></a><span id="l2.431"> </span>
<a href="#l2.432"></a><span id="l2.432">   nsCString messageId;</span>
<a href="#l2.433"></a><span id="l2.433">   possibleParent-&gt;GetMessageId(getter_Copies(messageId));</span>
<a href="#l2.434"></a><span id="l2.434"> </span>
<a href="#l2.435"></a><span id="l2.435">   while (referenceToCheck &gt; 0)</span>
<a href="#l2.436"></a><span id="l2.436">   {</span>
<a href="#l2.437"></a><span id="l2.437">     possibleChild-&gt;GetStringReference(referenceToCheck - 1, reference);</span>
<a href="#l2.438"></a><span id="l2.438"> </span>
<a href="#l2.439"></a><span id="l2.439">     if (reference.Equals(messageId))</span>
<a href="#l2.440"></a><span id="l2.440">       return true;</span>
<a href="#l2.441"></a><span id="l2.441" class="difflineminus">-    // if reference didn't match, check if this ref is for a non-existent</span>
<a href="#l2.442"></a><span id="l2.442" class="difflineplus">+</span>
<a href="#l2.443"></a><span id="l2.443" class="difflineplus">+    // If reference didn't match, check if this ref is for a non-existent</span>
<a href="#l2.444"></a><span id="l2.444">     // header. If it is, continue looking at ancestors.</span>
<a href="#l2.445"></a><span id="l2.445">     nsCOMPtr&lt;nsIMsgDBHdr&gt; refHdr;</span>
<a href="#l2.446"></a><span id="l2.446">     m_view-&gt;GetMsgHdrFromHash(reference, getter_AddRefs(refHdr));</span>
<a href="#l2.447"></a><span id="l2.447">     if (refHdr)</span>
<a href="#l2.448"></a><span id="l2.448">       break;</span>
<a href="#l2.449"></a><span id="l2.449" class="difflineplus">+</span>
<a href="#l2.450"></a><span id="l2.450">     referenceToCheck--;</span>
<a href="#l2.451"></a><span id="l2.451">   }</span>
<a href="#l2.452"></a><span id="l2.452" class="difflineplus">+</span>
<a href="#l2.453"></a><span id="l2.453">   return false;</span>
<a href="#l2.454"></a><span id="l2.454"> }</span>
<a href="#l2.455"></a><span id="l2.455"> </span>
<a href="#l2.456"></a><span id="l2.456" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::GetNewestMsgDate(uint32_t *aResult)</span>
<a href="#l2.457"></a><span id="l2.457" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.458"></a><span id="l2.458" class="difflineplus">+nsMsgXFViewThread::GetNewestMsgDate(uint32_t *aResult)</span>
<a href="#l2.459"></a><span id="l2.459"> {</span>
<a href="#l2.460"></a><span id="l2.460" class="difflineminus">-  // if this hasn't been set, figure it out by enumerating the msgs in the thread.</span>
<a href="#l2.461"></a><span id="l2.461" class="difflineplus">+  // If this hasn't been set, figure it out by enumerating the msgs in the</span>
<a href="#l2.462"></a><span id="l2.462" class="difflineplus">+  // thread.</span>
<a href="#l2.463"></a><span id="l2.463">   if (!m_newestMsgDate)</span>
<a href="#l2.464"></a><span id="l2.464">   {</span>
<a href="#l2.465"></a><span id="l2.465">     uint32_t numChildren;</span>
<a href="#l2.466"></a><span id="l2.466">     nsresult rv = NS_OK;</span>
<a href="#l2.467"></a><span id="l2.467"> </span>
<a href="#l2.468"></a><span id="l2.468">     GetNumChildren(&amp;numChildren);</span>
<a href="#l2.469"></a><span id="l2.469"> </span>
<a href="#l2.470"></a><span id="l2.470">     if ((int32_t) numChildren &lt; 0)</span>
<a href="#l2.471"></a><span id="l2.471" class="difflineat">@@ -420,33 +473,37 @@ NS_IMETHODIMP nsMsgXFViewThread::GetNewe</span>
<a href="#l2.472"></a><span id="l2.472">       {</span>
<a href="#l2.473"></a><span id="l2.473">         uint32_t msgDate;</span>
<a href="#l2.474"></a><span id="l2.474">         child-&gt;GetDateInSeconds(&amp;msgDate);</span>
<a href="#l2.475"></a><span id="l2.475">         if (msgDate &gt; m_newestMsgDate)</span>
<a href="#l2.476"></a><span id="l2.476">           m_newestMsgDate = msgDate;</span>
<a href="#l2.477"></a><span id="l2.477">       }</span>
<a href="#l2.478"></a><span id="l2.478">     }</span>
<a href="#l2.479"></a><span id="l2.479">   }</span>
<a href="#l2.480"></a><span id="l2.480" class="difflineplus">+</span>
<a href="#l2.481"></a><span id="l2.481">   *aResult = m_newestMsgDate;</span>
<a href="#l2.482"></a><span id="l2.482">   return NS_OK;</span>
<a href="#l2.483"></a><span id="l2.483"> }</span>
<a href="#l2.484"></a><span id="l2.484"> </span>
<a href="#l2.485"></a><span id="l2.485" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::SetNewestMsgDate(uint32_t aNewestMsgDate)</span>
<a href="#l2.486"></a><span id="l2.486" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.487"></a><span id="l2.487" class="difflineplus">+nsMsgXFViewThread::SetNewestMsgDate(uint32_t aNewestMsgDate)</span>
<a href="#l2.488"></a><span id="l2.488"> {</span>
<a href="#l2.489"></a><span id="l2.489">   m_newestMsgDate = aNewestMsgDate;</span>
<a href="#l2.490"></a><span id="l2.490">   return NS_OK;</span>
<a href="#l2.491"></a><span id="l2.491"> }</span>
<a href="#l2.492"></a><span id="l2.492"> </span>
<a href="#l2.493"></a><span id="l2.493" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::MarkChildRead(bool aRead)</span>
<a href="#l2.494"></a><span id="l2.494" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.495"></a><span id="l2.495" class="difflineplus">+nsMsgXFViewThread::MarkChildRead(bool aRead)</span>
<a href="#l2.496"></a><span id="l2.496"> {</span>
<a href="#l2.497"></a><span id="l2.497">   ChangeUnreadChildCount(aRead ? -1 : 1);</span>
<a href="#l2.498"></a><span id="l2.498">   return NS_OK;</span>
<a href="#l2.499"></a><span id="l2.499"> }</span>
<a href="#l2.500"></a><span id="l2.500"> </span>
<a href="#l2.501"></a><span id="l2.501" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::GetFirstUnreadChild(nsIMsgDBHdr **aResult)</span>
<a href="#l2.502"></a><span id="l2.502" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.503"></a><span id="l2.503" class="difflineplus">+nsMsgXFViewThread::GetFirstUnreadChild(nsIMsgDBHdr **aResult)</span>
<a href="#l2.504"></a><span id="l2.504"> {</span>
<a href="#l2.505"></a><span id="l2.505">   NS_ENSURE_ARG(aResult);</span>
<a href="#l2.506"></a><span id="l2.506">   uint32_t numChildren;</span>
<a href="#l2.507"></a><span id="l2.507">   nsresult rv = NS_OK;</span>
<a href="#l2.508"></a><span id="l2.508"> </span>
<a href="#l2.509"></a><span id="l2.509">   GetNumChildren(&amp;numChildren);</span>
<a href="#l2.510"></a><span id="l2.510"> </span>
<a href="#l2.511"></a><span id="l2.511">   if ((int32_t) numChildren &lt; 0)</span>
<a href="#l2.512"></a><span id="l2.512" class="difflineat">@@ -461,23 +518,27 @@ NS_IMETHODIMP nsMsgXFViewThread::GetFirs</span>
<a href="#l2.513"></a><span id="l2.513">       nsMsgKey msgKey;</span>
<a href="#l2.514"></a><span id="l2.514">       child-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l2.515"></a><span id="l2.515"> </span>
<a href="#l2.516"></a><span id="l2.516">       bool isRead;</span>
<a href="#l2.517"></a><span id="l2.517">       nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l2.518"></a><span id="l2.518">       nsresult rv = m_folders[childIndex]-&gt;GetMsgDatabase(getter_AddRefs(db));</span>
<a href="#l2.519"></a><span id="l2.519">       if (NS_SUCCEEDED(rv))</span>
<a href="#l2.520"></a><span id="l2.520">         rv = db-&gt;IsRead(msgKey, &amp;isRead);</span>
<a href="#l2.521"></a><span id="l2.521" class="difflineplus">+</span>
<a href="#l2.522"></a><span id="l2.522">       if (NS_SUCCEEDED(rv) &amp;&amp; !isRead)</span>
<a href="#l2.523"></a><span id="l2.523">       {</span>
<a href="#l2.524"></a><span id="l2.524">         child.forget(aResult);</span>
<a href="#l2.525"></a><span id="l2.525">         break;</span>
<a href="#l2.526"></a><span id="l2.526">       }</span>
<a href="#l2.527"></a><span id="l2.527">     }</span>
<a href="#l2.528"></a><span id="l2.528">   }</span>
<a href="#l2.529"></a><span id="l2.529" class="difflineplus">+</span>
<a href="#l2.530"></a><span id="l2.530">   return rv;</span>
<a href="#l2.531"></a><span id="l2.531"> }</span>
<a href="#l2.532"></a><span id="l2.532" class="difflineminus">-NS_IMETHODIMP nsMsgXFViewThread::EnumerateMessages(nsMsgKey aParentKey,</span>
<a href="#l2.533"></a><span id="l2.533" class="difflineminus">-                                                   nsISimpleEnumerator **aResult)</span>
<a href="#l2.534"></a><span id="l2.534" class="difflineplus">+</span>
<a href="#l2.535"></a><span id="l2.535" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.536"></a><span id="l2.536" class="difflineplus">+nsMsgXFViewThread::EnumerateMessages(nsMsgKey aParentKey,</span>
<a href="#l2.537"></a><span id="l2.537" class="difflineplus">+                                     nsISimpleEnumerator **aResult)</span>
<a href="#l2.538"></a><span id="l2.538"> {</span>
<a href="#l2.539"></a><span id="l2.539">   NS_ERROR(&quot;shouldn't call this&quot;);</span>
<a href="#l2.540"></a><span id="l2.540">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l2.541"></a><span id="l2.541"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -27,57 +27,66 @@ nsMsgXFVirtualFolderDBView::nsMsgXFVirtu</span>
<a href="#l3.4"></a><span id="l3.4">   m_doingQuickSearch = false;</span>
<a href="#l3.5"></a><span id="l3.5">   m_totalMessagesInView = 0;</span>
<a href="#l3.6"></a><span id="l3.6"> }</span>
<a href="#l3.7"></a><span id="l3.7"> </span>
<a href="#l3.8"></a><span id="l3.8"> nsMsgXFVirtualFolderDBView::~nsMsgXFVirtualFolderDBView()</span>
<a href="#l3.9"></a><span id="l3.9"> {</span>
<a href="#l3.10"></a><span id="l3.10"> }</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-NS_IMETHODIMP nsMsgXFVirtualFolderDBView::Open(nsIMsgFolder *folder,</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">-                                               nsMsgViewSortTypeValue sortType,</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineminus">-                                               nsMsgViewSortOrderValue sortOrder,</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineminus">-                                               nsMsgViewFlagsTypeValue viewFlags,</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineminus">-                                               int32_t *pCount)</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+nsMsgXFVirtualFolderDBView::Open(nsIMsgFolder *folder,</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+                                 nsMsgViewSortTypeValue sortType,</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+                                 nsMsgViewSortOrderValue sortOrder,</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+                                 nsMsgViewFlagsTypeValue viewFlags,</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineplus">+                                 int32_t *pCount)</span>
<a href="#l3.23"></a><span id="l3.23"> {</span>
<a href="#l3.24"></a><span id="l3.24">   m_viewFolder = folder;</span>
<a href="#l3.25"></a><span id="l3.25">   return nsMsgSearchDBView::Open(folder, sortType, sortOrder, viewFlags, pCount);</span>
<a href="#l3.26"></a><span id="l3.26"> }</span>
<a href="#l3.27"></a><span id="l3.27"> </span>
<a href="#l3.28"></a><span id="l3.28" class="difflineminus">-void nsMsgXFVirtualFolderDBView::RemovePendingDBListeners()</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineplus">+void</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineplus">+nsMsgXFVirtualFolderDBView::RemovePendingDBListeners()</span>
<a href="#l3.31"></a><span id="l3.31"> {</span>
<a href="#l3.32"></a><span id="l3.32">   nsresult rv;</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineminus">-  nsCOMPtr&lt;nsIMsgDBService&gt; msgDBService = do_GetService(NS_MSGDB_SERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineminus">-  // UnregisterPendingListener will return an error when there are no more instances</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineminus">-  // of this object registered as pending listeners.</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBService&gt; msgDBService =</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineplus">+    do_GetService(NS_MSGDB_SERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineplus">+</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+  // UnregisterPendingListener will return an error when there are no more</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+  // instances of this object registered as pending listeners.</span>
<a href="#l3.41"></a><span id="l3.41">   while (NS_SUCCEEDED(rv))</span>
<a href="#l3.42"></a><span id="l3.42">     rv = msgDBService-&gt;UnregisterPendingListener(this);</span>
<a href="#l3.43"></a><span id="l3.43"> }</span>
<a href="#l3.44"></a><span id="l3.44"> </span>
<a href="#l3.45"></a><span id="l3.45" class="difflineminus">-NS_IMETHODIMP nsMsgXFVirtualFolderDBView::Close()</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+nsMsgXFVirtualFolderDBView::Close()</span>
<a href="#l3.48"></a><span id="l3.48"> {</span>
<a href="#l3.49"></a><span id="l3.49">   RemovePendingDBListeners();</span>
<a href="#l3.50"></a><span id="l3.50">   return nsMsgSearchDBView::Close();</span>
<a href="#l3.51"></a><span id="l3.51"> }</span>
<a href="#l3.52"></a><span id="l3.52"> </span>
<a href="#l3.53"></a><span id="l3.53"> NS_IMETHODIMP</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineminus">-nsMsgXFVirtualFolderDBView::CloneDBView(nsIMessenger *aMessengerInstance, nsIMsgWindow *aMsgWindow,</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineminus">-                                        nsIMsgDBViewCommandUpdater *aCmdUpdater, nsIMsgDBView **_retval)</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+nsMsgXFVirtualFolderDBView::CloneDBView(nsIMessenger *aMessengerInstance,</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+                                        nsIMsgWindow *aMsgWindow,</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+                                        nsIMsgDBViewCommandUpdater *aCmdUpdater,</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+                                        nsIMsgDBView **_retval)</span>
<a href="#l3.60"></a><span id="l3.60"> {</span>
<a href="#l3.61"></a><span id="l3.61">   nsMsgXFVirtualFolderDBView* newMsgDBView = new nsMsgXFVirtualFolderDBView();</span>
<a href="#l3.62"></a><span id="l3.62">   nsresult rv = CopyDBView(newMsgDBView, aMessengerInstance, aMsgWindow, aCmdUpdater);</span>
<a href="#l3.63"></a><span id="l3.63">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l3.64"></a><span id="l3.64"> </span>
<a href="#l3.65"></a><span id="l3.65">   NS_IF_ADDREF(*_retval = newMsgDBView);</span>
<a href="#l3.66"></a><span id="l3.66">   return NS_OK;</span>
<a href="#l3.67"></a><span id="l3.67"> }</span>
<a href="#l3.68"></a><span id="l3.68"> </span>
<a href="#l3.69"></a><span id="l3.69"> NS_IMETHODIMP</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineminus">-nsMsgXFVirtualFolderDBView::CopyDBView(nsMsgDBView *aNewMsgDBView, nsIMessenger *aMessengerInstance,</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineminus">-                                       nsIMsgWindow *aMsgWindow, nsIMsgDBViewCommandUpdater *aCmdUpdater)</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineplus">+nsMsgXFVirtualFolderDBView::CopyDBView(nsMsgDBView *aNewMsgDBView,</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineplus">+                                       nsIMessenger *aMessengerInstance,</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineplus">+                                       nsIMsgWindow *aMsgWindow,</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineplus">+                                       nsIMsgDBViewCommandUpdater *aCmdUpdater)</span>
<a href="#l3.76"></a><span id="l3.76"> {</span>
<a href="#l3.77"></a><span id="l3.77">   nsMsgSearchDBView::CopyDBView(aNewMsgDBView, aMessengerInstance, aMsgWindow, aCmdUpdater);</span>
<a href="#l3.78"></a><span id="l3.78"> </span>
<a href="#l3.79"></a><span id="l3.79">   nsMsgXFVirtualFolderDBView* newMsgDBView = (nsMsgXFVirtualFolderDBView *) aNewMsgDBView;</span>
<a href="#l3.80"></a><span id="l3.80"> </span>
<a href="#l3.81"></a><span id="l3.81">   newMsgDBView-&gt;m_viewFolder = m_viewFolder;</span>
<a href="#l3.82"></a><span id="l3.82">   newMsgDBView-&gt;m_searchSession = m_searchSession;</span>
<a href="#l3.83"></a><span id="l3.83"> </span>
<a href="#l3.84"></a><span id="l3.84" class="difflineat">@@ -98,251 +107,288 @@ nsMsgXFVirtualFolderDBView::CopyDBView(n</span>
<a href="#l3.85"></a><span id="l3.85">     searchSession-&gt;GetNthSearchScope(i, &amp;scopeId, getter_AddRefs(searchFolder));</span>
<a href="#l3.86"></a><span id="l3.86">     if (searchFolder)</span>
<a href="#l3.87"></a><span id="l3.87">       msgDBService-&gt;RegisterPendingListener(searchFolder, newMsgDBView);</span>
<a href="#l3.88"></a><span id="l3.88">   }</span>
<a href="#l3.89"></a><span id="l3.89"> </span>
<a href="#l3.90"></a><span id="l3.90">   return NS_OK;</span>
<a href="#l3.91"></a><span id="l3.91"> }</span>
<a href="#l3.92"></a><span id="l3.92"> </span>
<a href="#l3.93"></a><span id="l3.93" class="difflineminus">-NS_IMETHODIMP nsMsgXFVirtualFolderDBView::GetViewType(nsMsgViewTypeValue *aViewType)</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineplus">+nsMsgXFVirtualFolderDBView::GetViewType(nsMsgViewTypeValue *aViewType)</span>
<a href="#l3.96"></a><span id="l3.96"> {</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineminus">-    NS_ENSURE_ARG_POINTER(aViewType);</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineminus">-    *aViewType = nsMsgViewType::eShowVirtualFolderResults;</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineplus">+  NS_ENSURE_ARG_POINTER(aViewType);</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineplus">+  *aViewType = nsMsgViewType::eShowVirtualFolderResults;</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.103"></a><span id="l3.103"> }</span>
<a href="#l3.104"></a><span id="l3.104"> </span>
<a href="#l3.105"></a><span id="l3.105" class="difflineminus">-nsresult nsMsgXFVirtualFolderDBView::OnNewHeader(nsIMsgDBHdr *newHdr, nsMsgKey aParentKey, bool /*ensureListed*/)</span>
<a href="#l3.106"></a><span id="l3.106" class="difflineplus">+nsresult</span>
<a href="#l3.107"></a><span id="l3.107" class="difflineplus">+nsMsgXFVirtualFolderDBView::OnNewHeader(nsIMsgDBHdr *newHdr,</span>
<a href="#l3.108"></a><span id="l3.108" class="difflineplus">+                                        nsMsgKey aParentKey,</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineplus">+                                        bool /*ensureListed*/)</span>
<a href="#l3.110"></a><span id="l3.110"> {</span>
<a href="#l3.111"></a><span id="l3.111">   if (newHdr)</span>
<a href="#l3.112"></a><span id="l3.112">   {</span>
<a href="#l3.113"></a><span id="l3.113">     bool match = false;</span>
<a href="#l3.114"></a><span id="l3.114" class="difflineminus">-    nsCOMPtr &lt;nsIMsgSearchSession&gt; searchSession = do_QueryReferent(m_searchSession);</span>
<a href="#l3.115"></a><span id="l3.115" class="difflineplus">+    nsCOMPtr &lt;nsIMsgSearchSession&gt; searchSession =</span>
<a href="#l3.116"></a><span id="l3.116" class="difflineplus">+      do_QueryReferent(m_searchSession);</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineplus">+</span>
<a href="#l3.118"></a><span id="l3.118">     if (searchSession)</span>
<a href="#l3.119"></a><span id="l3.119">       searchSession-&gt;MatchHdr(newHdr, m_db, &amp;match);</span>
<a href="#l3.120"></a><span id="l3.120" class="difflineplus">+</span>
<a href="#l3.121"></a><span id="l3.121">     if (!match)</span>
<a href="#l3.122"></a><span id="l3.122">       match = WasHdrRecentlyDeleted(newHdr);</span>
<a href="#l3.123"></a><span id="l3.123" class="difflineplus">+</span>
<a href="#l3.124"></a><span id="l3.124">     if (match)</span>
<a href="#l3.125"></a><span id="l3.125">     {</span>
<a href="#l3.126"></a><span id="l3.126">       nsCOMPtr &lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.127"></a><span id="l3.127">       newHdr-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l3.128"></a><span id="l3.128">       bool saveDoingSearch = m_doingSearch;</span>
<a href="#l3.129"></a><span id="l3.129">       m_doingSearch = false;</span>
<a href="#l3.130"></a><span id="l3.130">       OnSearchHit(newHdr, folder);</span>
<a href="#l3.131"></a><span id="l3.131">       m_doingSearch = saveDoingSearch;</span>
<a href="#l3.132"></a><span id="l3.132">     }</span>
<a href="#l3.133"></a><span id="l3.133">   }</span>
<a href="#l3.134"></a><span id="l3.134">   return NS_OK;</span>
<a href="#l3.135"></a><span id="l3.135"> }</span>
<a href="#l3.136"></a><span id="l3.136"> </span>
<a href="#l3.137"></a><span id="l3.137" class="difflineminus">-NS_IMETHODIMP nsMsgXFVirtualFolderDBView::OnHdrPropertyChanged(nsIMsgDBHdr *aHdrChanged,</span>
<a href="#l3.138"></a><span id="l3.138" class="difflineminus">-                bool aPreChange, uint32_t *aStatus, nsIDBChangeListener *aInstigator)</span>
<a href="#l3.139"></a><span id="l3.139" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l3.140"></a><span id="l3.140" class="difflineplus">+nsMsgXFVirtualFolderDBView::OnHdrPropertyChanged(nsIMsgDBHdr *aHdrChanged,</span>
<a href="#l3.141"></a><span id="l3.141" class="difflineplus">+                                                 bool aPreChange,</span>
<a href="#l3.142"></a><span id="l3.142" class="difflineplus">+                                                 uint32_t *aStatus,</span>
<a href="#l3.143"></a><span id="l3.143" class="difflineplus">+                                                 nsIDBChangeListener *aInstigator)</span>
<a href="#l3.144"></a><span id="l3.144"> {</span>
<a href="#l3.145"></a><span id="l3.145">   // If the junk mail plugin just activated on a message, then</span>
<a href="#l3.146"></a><span id="l3.146">   // we'll allow filters to remove from view.</span>
<a href="#l3.147"></a><span id="l3.147">   // Otherwise, just update the view line.</span>
<a href="#l3.148"></a><span id="l3.148">   //</span>
<a href="#l3.149"></a><span id="l3.149">   // Note this will not add newly matched headers to the view. This is</span>
<a href="#l3.150"></a><span id="l3.150">   // probably a bug that needs fixing.</span>
<a href="#l3.151"></a><span id="l3.151"> </span>
<a href="#l3.152"></a><span id="l3.152">   NS_ENSURE_ARG_POINTER(aStatus);</span>
<a href="#l3.153"></a><span id="l3.153">   NS_ENSURE_ARG_POINTER(aHdrChanged);</span>
<a href="#l3.154"></a><span id="l3.154"> </span>
<a href="#l3.155"></a><span id="l3.155">   nsMsgViewIndex index = FindHdr(aHdrChanged);</span>
<a href="#l3.156"></a><span id="l3.156" class="difflineminus">-  if (index == nsMsgViewIndex_None) // message does not appear in view</span>
<a href="#l3.157"></a><span id="l3.157" class="difflineplus">+  // Message does not appear in view.</span>
<a href="#l3.158"></a><span id="l3.158" class="difflineplus">+  if (index == nsMsgViewIndex_None)</span>
<a href="#l3.159"></a><span id="l3.159">     return NS_OK;</span>
<a href="#l3.160"></a><span id="l3.160"> </span>
<a href="#l3.161"></a><span id="l3.161">   nsCString originStr;</span>
<a href="#l3.162"></a><span id="l3.162">   (void) aHdrChanged-&gt;GetStringProperty(&quot;junkscoreorigin&quot;, getter_Copies(originStr));</span>
<a href="#l3.163"></a><span id="l3.163" class="difflineminus">-  // check for &quot;plugin&quot; with only first character for performance</span>
<a href="#l3.164"></a><span id="l3.164" class="difflineplus">+  // Check for &quot;plugin&quot; with only first character for performance.</span>
<a href="#l3.165"></a><span id="l3.165">   bool plugin = (originStr.get()[0] == 'p');</span>
<a href="#l3.166"></a><span id="l3.166"> </span>
<a href="#l3.167"></a><span id="l3.167">   if (aPreChange)</span>
<a href="#l3.168"></a><span id="l3.168">   {</span>
<a href="#l3.169"></a><span id="l3.169" class="difflineminus">-    // first call, done prior to the change</span>
<a href="#l3.170"></a><span id="l3.170" class="difflineplus">+    // First call, done prior to the change.</span>
<a href="#l3.171"></a><span id="l3.171">     *aStatus = plugin;</span>
<a href="#l3.172"></a><span id="l3.172">     return NS_OK;</span>
<a href="#l3.173"></a><span id="l3.173">   }</span>
<a href="#l3.174"></a><span id="l3.174"> </span>
<a href="#l3.175"></a><span id="l3.175" class="difflineminus">-  // second call, done after the change</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineplus">+  // Second call, done after the change.</span>
<a href="#l3.177"></a><span id="l3.177">   bool wasPlugin = *aStatus;</span>
<a href="#l3.178"></a><span id="l3.178"> </span>
<a href="#l3.179"></a><span id="l3.179">   bool match = true;</span>
<a href="#l3.180"></a><span id="l3.180">   nsCOMPtr&lt;nsIMsgSearchSession&gt; searchSession(do_QueryReferent(m_searchSession));</span>
<a href="#l3.181"></a><span id="l3.181">   if (searchSession)</span>
<a href="#l3.182"></a><span id="l3.182">     searchSession-&gt;MatchHdr(aHdrChanged, m_db, &amp;match);</span>
<a href="#l3.183"></a><span id="l3.183"> </span>
<a href="#l3.184"></a><span id="l3.184">   if (!match &amp;&amp; plugin &amp;&amp; !wasPlugin)</span>
<a href="#l3.185"></a><span id="l3.185" class="difflineminus">-    RemoveByIndex(index); // remove hdr from view</span>
<a href="#l3.186"></a><span id="l3.186" class="difflineplus">+    // Remove hdr from view.</span>
<a href="#l3.187"></a><span id="l3.187" class="difflineplus">+    RemoveByIndex(index);</span>
<a href="#l3.188"></a><span id="l3.188">   else</span>
<a href="#l3.189"></a><span id="l3.189">     NoteChange(index, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l3.190"></a><span id="l3.190"> </span>
<a href="#l3.191"></a><span id="l3.191">   return NS_OK;</span>
<a href="#l3.192"></a><span id="l3.192"> }</span>
<a href="#l3.193"></a><span id="l3.193"> </span>
<a href="#l3.194"></a><span id="l3.194" class="difflineminus">-void nsMsgXFVirtualFolderDBView::UpdateCacheAndViewForFolder(nsIMsgFolder *folder, nsMsgKey *newHits, uint32_t numNewHits)</span>
<a href="#l3.195"></a><span id="l3.195" class="difflineplus">+void</span>
<a href="#l3.196"></a><span id="l3.196" class="difflineplus">+nsMsgXFVirtualFolderDBView::UpdateCacheAndViewForFolder(nsIMsgFolder *folder,</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineplus">+                                                        nsMsgKey *newHits,</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineplus">+                                                        uint32_t numNewHits)</span>
<a href="#l3.199"></a><span id="l3.199"> {</span>
<a href="#l3.200"></a><span id="l3.200">   nsCOMPtr &lt;nsIMsgDatabase&gt; db;</span>
<a href="#l3.201"></a><span id="l3.201">   nsresult rv = folder-&gt;GetMsgDatabase(getter_AddRefs(db));</span>
<a href="#l3.202"></a><span id="l3.202">   if (NS_SUCCEEDED(rv) &amp;&amp; db)</span>
<a href="#l3.203"></a><span id="l3.203">   {</span>
<a href="#l3.204"></a><span id="l3.204">     nsCString searchUri;</span>
<a href="#l3.205"></a><span id="l3.205">     m_viewFolder-&gt;GetURI(searchUri);</span>
<a href="#l3.206"></a><span id="l3.206">     uint32_t numBadHits;</span>
<a href="#l3.207"></a><span id="l3.207">     nsMsgKey *badHits;</span>
<a href="#l3.208"></a><span id="l3.208" class="difflineminus">-    rv = db-&gt;RefreshCache(searchUri.get(), numNewHits, newHits,</span>
<a href="#l3.209"></a><span id="l3.209" class="difflineminus">-                     &amp;numBadHits, &amp;badHits);</span>
<a href="#l3.210"></a><span id="l3.210" class="difflineplus">+    rv = db-&gt;RefreshCache(searchUri.get(),</span>
<a href="#l3.211"></a><span id="l3.211" class="difflineplus">+                          numNewHits,</span>
<a href="#l3.212"></a><span id="l3.212" class="difflineplus">+                          newHits,</span>
<a href="#l3.213"></a><span id="l3.213" class="difflineplus">+                          &amp;numBadHits,</span>
<a href="#l3.214"></a><span id="l3.214" class="difflineplus">+                          &amp;badHits);</span>
<a href="#l3.215"></a><span id="l3.215">     if (NS_SUCCEEDED(rv))</span>
<a href="#l3.216"></a><span id="l3.216">     {</span>
<a href="#l3.217"></a><span id="l3.217">       nsCOMPtr&lt;nsIMsgDBHdr&gt; badHdr;</span>
<a href="#l3.218"></a><span id="l3.218">       for (uint32_t badHitIndex = 0; badHitIndex &lt; numBadHits; badHitIndex++)</span>
<a href="#l3.219"></a><span id="l3.219">       {</span>
<a href="#l3.220"></a><span id="l3.220">         // ### of course, this isn't quite right, since we should be</span>
<a href="#l3.221"></a><span id="l3.221">         // using FindHdr, and we shouldn't be expanding the threads.</span>
<a href="#l3.222"></a><span id="l3.222">         db-&gt;GetMsgHdrForKey(badHits[badHitIndex], getter_AddRefs(badHdr));</span>
<a href="#l3.223"></a><span id="l3.223" class="difflineminus">-        // let nsMsgSearchDBView decide what to do about this header</span>
<a href="#l3.224"></a><span id="l3.224" class="difflineplus">+        // Let nsMsgSearchDBView decide what to do about this header</span>
<a href="#l3.225"></a><span id="l3.225">         // getting removed.</span>
<a href="#l3.226"></a><span id="l3.226">         if (badHdr)</span>
<a href="#l3.227"></a><span id="l3.227">           OnHdrDeleted(badHdr, nsMsgKey_None, 0, this);</span>
<a href="#l3.228"></a><span id="l3.228">       }</span>
<a href="#l3.229"></a><span id="l3.229" class="difflineplus">+</span>
<a href="#l3.230"></a><span id="l3.230">       delete [] badHits;</span>
<a href="#l3.231"></a><span id="l3.231">     }</span>
<a href="#l3.232"></a><span id="l3.232">   }</span>
<a href="#l3.233"></a><span id="l3.233"> }</span>
<a href="#l3.234"></a><span id="l3.234"> </span>
<a href="#l3.235"></a><span id="l3.235" class="difflineminus">-void nsMsgXFVirtualFolderDBView::UpdateCacheAndViewForPrevSearchedFolders(nsIMsgFolder *curSearchFolder)</span>
<a href="#l3.236"></a><span id="l3.236" class="difflineplus">+void</span>
<a href="#l3.237"></a><span id="l3.237" class="difflineplus">+nsMsgXFVirtualFolderDBView::UpdateCacheAndViewForPrevSearchedFolders(nsIMsgFolder *curSearchFolder)</span>
<a href="#l3.238"></a><span id="l3.238"> {</span>
<a href="#l3.239"></a><span id="l3.239">   // Handle the most recent folder with hits, if any.</span>
<a href="#l3.240"></a><span id="l3.240">   if (m_curFolderGettingHits)</span>
<a href="#l3.241"></a><span id="l3.241">   {</span>
<a href="#l3.242"></a><span id="l3.242">     uint32_t count = m_hdrHits.Count();</span>
<a href="#l3.243"></a><span id="l3.243">     nsTArray&lt;nsMsgKey&gt; newHits;</span>
<a href="#l3.244"></a><span id="l3.244">     newHits.SetLength(count);</span>
<a href="#l3.245"></a><span id="l3.245">     for (uint32_t i = 0; i &lt; count; i++)</span>
<a href="#l3.246"></a><span id="l3.246">       m_hdrHits[i]-&gt;GetMessageKey(&amp;newHits[i]);</span>
<a href="#l3.247"></a><span id="l3.247"> </span>
<a href="#l3.248"></a><span id="l3.248">     newHits.Sort();</span>
<a href="#l3.249"></a><span id="l3.249" class="difflineminus">-    UpdateCacheAndViewForFolder(m_curFolderGettingHits, newHits.Elements(), newHits.Length());</span>
<a href="#l3.250"></a><span id="l3.250" class="difflineplus">+    UpdateCacheAndViewForFolder(m_curFolderGettingHits,</span>
<a href="#l3.251"></a><span id="l3.251" class="difflineplus">+                                newHits.Elements(),</span>
<a href="#l3.252"></a><span id="l3.252" class="difflineplus">+                                newHits.Length());</span>
<a href="#l3.253"></a><span id="l3.253">     m_foldersSearchingOver.RemoveObject(m_curFolderGettingHits);</span>
<a href="#l3.254"></a><span id="l3.254">   }</span>
<a href="#l3.255"></a><span id="l3.255"> </span>
<a href="#l3.256"></a><span id="l3.256">   while (m_foldersSearchingOver.Count() &gt; 0)</span>
<a href="#l3.257"></a><span id="l3.257">   {</span>
<a href="#l3.258"></a><span id="l3.258" class="difflineminus">-    // this new folder has cached hits.</span>
<a href="#l3.259"></a><span id="l3.259" class="difflineplus">+    // This new folder has cached hits.</span>
<a href="#l3.260"></a><span id="l3.260">     if (m_foldersSearchingOver[0] == curSearchFolder)</span>
<a href="#l3.261"></a><span id="l3.261">     {</span>
<a href="#l3.262"></a><span id="l3.262">       m_curFolderHasCachedHits = true;</span>
<a href="#l3.263"></a><span id="l3.263">       m_foldersSearchingOver.RemoveObjectAt(0);</span>
<a href="#l3.264"></a><span id="l3.264">       break;</span>
<a href="#l3.265"></a><span id="l3.265">     }</span>
<a href="#l3.266"></a><span id="l3.266">     else</span>
<a href="#l3.267"></a><span id="l3.267">     {</span>
<a href="#l3.268"></a><span id="l3.268" class="difflineminus">-      // this must be a folder that had no hits with the current search.</span>
<a href="#l3.269"></a><span id="l3.269" class="difflineplus">+      // This must be a folder that had no hits with the current search.</span>
<a href="#l3.270"></a><span id="l3.270">       // So all cached hits, if any, need to be removed.</span>
<a href="#l3.271"></a><span id="l3.271">       UpdateCacheAndViewForFolder(m_foldersSearchingOver[0], nullptr, 0);</span>
<a href="#l3.272"></a><span id="l3.272">       m_foldersSearchingOver.RemoveObjectAt(0);</span>
<a href="#l3.273"></a><span id="l3.273">     }</span>
<a href="#l3.274"></a><span id="l3.274">   }</span>
<a href="#l3.275"></a><span id="l3.275"> }</span>
<a href="#l3.276"></a><span id="l3.276"> NS_IMETHODIMP</span>
<a href="#l3.277"></a><span id="l3.277" class="difflineminus">-nsMsgXFVirtualFolderDBView::OnSearchHit(nsIMsgDBHdr* aMsgHdr, nsIMsgFolder *aFolder)</span>
<a href="#l3.278"></a><span id="l3.278" class="difflineplus">+nsMsgXFVirtualFolderDBView::OnSearchHit(nsIMsgDBHdr* aMsgHdr,</span>
<a href="#l3.279"></a><span id="l3.279" class="difflineplus">+                                        nsIMsgFolder *aFolder)</span>
<a href="#l3.280"></a><span id="l3.280"> {</span>
<a href="#l3.281"></a><span id="l3.281">   NS_ENSURE_ARG(aMsgHdr);</span>
<a href="#l3.282"></a><span id="l3.282">   NS_ENSURE_ARG(aFolder);</span>
<a href="#l3.283"></a><span id="l3.283"> </span>
<a href="#l3.284"></a><span id="l3.284">   nsCOMPtr&lt;nsIMsgDatabase&gt; dbToUse;</span>
<a href="#l3.285"></a><span id="l3.285">   nsCOMPtr&lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l3.286"></a><span id="l3.286">   aFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(folderInfo), getter_AddRefs(dbToUse));</span>
<a href="#l3.287"></a><span id="l3.287"> </span>
<a href="#l3.288"></a><span id="l3.288">   if (m_curFolderGettingHits != aFolder &amp;&amp; m_doingSearch &amp;&amp; !m_doingQuickSearch)</span>
<a href="#l3.289"></a><span id="l3.289">   {</span>
<a href="#l3.290"></a><span id="l3.290">     m_curFolderHasCachedHits = false;</span>
<a href="#l3.291"></a><span id="l3.291" class="difflineminus">-    // since we've gotten a hit for a new folder, the searches for</span>
<a href="#l3.292"></a><span id="l3.292" class="difflineplus">+    // Since we've gotten a hit for a new folder, the searches for</span>
<a href="#l3.293"></a><span id="l3.293">     // any previous folders are done, so deal with stale cached hits</span>
<a href="#l3.294"></a><span id="l3.294">     // for those folders now.</span>
<a href="#l3.295"></a><span id="l3.295">     UpdateCacheAndViewForPrevSearchedFolders(aFolder);</span>
<a href="#l3.296"></a><span id="l3.296">     m_curFolderGettingHits = aFolder;</span>
<a href="#l3.297"></a><span id="l3.297">     m_hdrHits.Clear();</span>
<a href="#l3.298"></a><span id="l3.298">     m_curFolderStartKeyIndex = m_keys.Length();</span>
<a href="#l3.299"></a><span id="l3.299">   }</span>
<a href="#l3.300"></a><span id="l3.300" class="difflineplus">+</span>
<a href="#l3.301"></a><span id="l3.301">   bool hdrInCache = false;</span>
<a href="#l3.302"></a><span id="l3.302">   nsCString searchUri;</span>
<a href="#l3.303"></a><span id="l3.303">   if (!m_doingQuickSearch)</span>
<a href="#l3.304"></a><span id="l3.304">   {</span>
<a href="#l3.305"></a><span id="l3.305">     m_viewFolder-&gt;GetURI(searchUri);</span>
<a href="#l3.306"></a><span id="l3.306">     dbToUse-&gt;HdrIsInCache(searchUri.get(), aMsgHdr, &amp;hdrInCache);</span>
<a href="#l3.307"></a><span id="l3.307">   }</span>
<a href="#l3.308"></a><span id="l3.308" class="difflineplus">+</span>
<a href="#l3.309"></a><span id="l3.309">   if (!m_doingSearch || !m_curFolderHasCachedHits || !hdrInCache)</span>
<a href="#l3.310"></a><span id="l3.310">   {</span>
<a href="#l3.311"></a><span id="l3.311">     if (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort)</span>
<a href="#l3.312"></a><span id="l3.312">       nsMsgGroupView::OnNewHeader(aMsgHdr, nsMsgKey_None, true);</span>
<a href="#l3.313"></a><span id="l3.313">     else if (m_sortValid)</span>
<a href="#l3.314"></a><span id="l3.314">       InsertHdrFromFolder(aMsgHdr, aFolder);</span>
<a href="#l3.315"></a><span id="l3.315">     else</span>
<a href="#l3.316"></a><span id="l3.316">       AddHdrFromFolder(aMsgHdr, aFolder);</span>
<a href="#l3.317"></a><span id="l3.317">   }</span>
<a href="#l3.318"></a><span id="l3.318" class="difflineplus">+</span>
<a href="#l3.319"></a><span id="l3.319">   m_hdrHits.AppendObject(aMsgHdr);</span>
<a href="#l3.320"></a><span id="l3.320">   m_totalMessagesInView++;</span>
<a href="#l3.321"></a><span id="l3.321"> </span>
<a href="#l3.322"></a><span id="l3.322">   return NS_OK;</span>
<a href="#l3.323"></a><span id="l3.323"> }</span>
<a href="#l3.324"></a><span id="l3.324"> </span>
<a href="#l3.325"></a><span id="l3.325"> NS_IMETHODIMP</span>
<a href="#l3.326"></a><span id="l3.326"> nsMsgXFVirtualFolderDBView::OnSearchDone(nsresult status)</span>
<a href="#l3.327"></a><span id="l3.327"> {</span>
<a href="#l3.328"></a><span id="l3.328">   NS_ENSURE_TRUE(m_viewFolder, NS_ERROR_NOT_INITIALIZED);</span>
<a href="#l3.329"></a><span id="l3.329"> </span>
<a href="#l3.330"></a><span id="l3.330" class="difflineminus">-  // handle any non verified hits we haven't handled yet.</span>
<a href="#l3.331"></a><span id="l3.331" class="difflineplus">+  // Handle any non verified hits we haven't handled yet.</span>
<a href="#l3.332"></a><span id="l3.332">   if (NS_SUCCEEDED(status) &amp;&amp; !m_doingQuickSearch &amp;&amp; status != NS_MSG_SEARCH_INTERRUPTED)</span>
<a href="#l3.333"></a><span id="l3.333">     UpdateCacheAndViewForPrevSearchedFolders(nullptr);</span>
<a href="#l3.334"></a><span id="l3.334"> </span>
<a href="#l3.335"></a><span id="l3.335">   m_doingSearch = false;</span>
<a href="#l3.336"></a><span id="l3.336" class="difflineminus">-  //we want to set imap delete model once the search is over because setting next</span>
<a href="#l3.337"></a><span id="l3.337" class="difflineminus">-  //message after deletion will happen before deleting the message and search scope</span>
<a href="#l3.338"></a><span id="l3.338" class="difflineminus">-  //can change with every search.</span>
<a href="#l3.339"></a><span id="l3.339" class="difflineminus">-  mDeleteModel = nsMsgImapDeleteModels::MoveToTrash;  //set to default in case it is non-imap folder</span>
<a href="#l3.340"></a><span id="l3.340" class="difflineplus">+  // We want to set imap delete model once the search is over because setting</span>
<a href="#l3.341"></a><span id="l3.341" class="difflineplus">+  // next message after deletion will happen before deleting the message and</span>
<a href="#l3.342"></a><span id="l3.342" class="difflineplus">+  // search scope can change with every search.</span>
<a href="#l3.343"></a><span id="l3.343" class="difflineplus">+</span>
<a href="#l3.344"></a><span id="l3.344" class="difflineplus">+  // Set to default in case it is non-imap folder.</span>
<a href="#l3.345"></a><span id="l3.345" class="difflineplus">+  mDeleteModel = nsMsgImapDeleteModels::MoveToTrash;</span>
<a href="#l3.346"></a><span id="l3.346">   nsIMsgFolder *curFolder = m_folders.SafeObjectAt(0);</span>
<a href="#l3.347"></a><span id="l3.347">   if (curFolder)</span>
<a href="#l3.348"></a><span id="l3.348">     GetImapDeleteModel(curFolder);</span>
<a href="#l3.349"></a><span id="l3.349"> </span>
<a href="#l3.350"></a><span id="l3.350">   nsCOMPtr&lt;nsIMsgDatabase&gt; virtDatabase;</span>
<a href="#l3.351"></a><span id="l3.351">   nsCOMPtr&lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l3.352"></a><span id="l3.352" class="difflineminus">-  nsresult rv = m_viewFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(dbFolderInfo), getter_AddRefs(virtDatabase));</span>
<a href="#l3.353"></a><span id="l3.353" class="difflineplus">+  nsresult rv = m_viewFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(dbFolderInfo),</span>
<a href="#l3.354"></a><span id="l3.354" class="difflineplus">+                                                   getter_AddRefs(virtDatabase));</span>
<a href="#l3.355"></a><span id="l3.355">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.356"></a><span id="l3.356" class="difflineminus">-  // count up the number of unread and total messages from the view, and set those in the</span>
<a href="#l3.357"></a><span id="l3.357" class="difflineminus">-  // folder - easier than trying to keep the count up to date in the face of</span>
<a href="#l3.358"></a><span id="l3.358" class="difflineminus">-  // search hits coming in while the user is reading/deleting messages.</span>
<a href="#l3.359"></a><span id="l3.359" class="difflineplus">+  // Count up the number of unread and total messages from the view, and set</span>
<a href="#l3.360"></a><span id="l3.360" class="difflineplus">+  // those in the folder - easier than trying to keep the count up to date in</span>
<a href="#l3.361"></a><span id="l3.361" class="difflineplus">+  // the face of search hits coming in while the user is reading/deleting</span>
<a href="#l3.362"></a><span id="l3.362" class="difflineplus">+  // messages.</span>
<a href="#l3.363"></a><span id="l3.363">   uint32_t numUnread = 0;</span>
<a href="#l3.364"></a><span id="l3.364">   for (uint32_t i = 0; i &lt; m_flags.Length(); i++)</span>
<a href="#l3.365"></a><span id="l3.365" class="difflineplus">+  {</span>
<a href="#l3.366"></a><span id="l3.366">     if (m_flags[i] &amp; nsMsgMessageFlags::Elided)</span>
<a href="#l3.367"></a><span id="l3.367">     {</span>
<a href="#l3.368"></a><span id="l3.368">       nsCOMPtr&lt;nsIMsgThread&gt; thread;</span>
<a href="#l3.369"></a><span id="l3.369">       GetThreadContainingIndex(i, getter_AddRefs(thread));</span>
<a href="#l3.370"></a><span id="l3.370">       if (thread)</span>
<a href="#l3.371"></a><span id="l3.371">       {</span>
<a href="#l3.372"></a><span id="l3.372">         uint32_t unreadInThread;</span>
<a href="#l3.373"></a><span id="l3.373">         thread-&gt;GetNumUnreadChildren(&amp;unreadInThread);</span>
<a href="#l3.374"></a><span id="l3.374">         numUnread += unreadInThread;</span>
<a href="#l3.375"></a><span id="l3.375">       }</span>
<a href="#l3.376"></a><span id="l3.376">     }</span>
<a href="#l3.377"></a><span id="l3.377">     else</span>
<a href="#l3.378"></a><span id="l3.378">     {</span>
<a href="#l3.379"></a><span id="l3.379">       if (!(m_flags[i] &amp; nsMsgMessageFlags::Read))</span>
<a href="#l3.380"></a><span id="l3.380">         numUnread++;</span>
<a href="#l3.381"></a><span id="l3.381">     }</span>
<a href="#l3.382"></a><span id="l3.382" class="difflineplus">+  }</span>
<a href="#l3.383"></a><span id="l3.383" class="difflineplus">+</span>
<a href="#l3.384"></a><span id="l3.384">   dbFolderInfo-&gt;SetNumUnreadMessages(numUnread);</span>
<a href="#l3.385"></a><span id="l3.385">   dbFolderInfo-&gt;SetNumMessages(m_totalMessagesInView);</span>
<a href="#l3.386"></a><span id="l3.386" class="difflineminus">-  m_viewFolder-&gt;UpdateSummaryTotals(true); // force update from db.</span>
<a href="#l3.387"></a><span id="l3.387" class="difflineplus">+  // Force update from db.</span>
<a href="#l3.388"></a><span id="l3.388" class="difflineplus">+  m_viewFolder-&gt;UpdateSummaryTotals(true);</span>
<a href="#l3.389"></a><span id="l3.389">   virtDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l3.390"></a><span id="l3.390">   if (!m_sortValid &amp;&amp; m_sortType != nsMsgViewSortType::byThread &amp;&amp;</span>
<a href="#l3.391"></a><span id="l3.391">       !(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l3.392"></a><span id="l3.392">   {</span>
<a href="#l3.393"></a><span id="l3.393" class="difflineminus">-    m_sortValid = false;       //sort the results</span>
<a href="#l3.394"></a><span id="l3.394" class="difflineplus">+    // Sort the results.</span>
<a href="#l3.395"></a><span id="l3.395" class="difflineplus">+    m_sortValid = false;</span>
<a href="#l3.396"></a><span id="l3.396">     Sort(m_sortType, m_sortOrder);</span>
<a href="#l3.397"></a><span id="l3.397">   }</span>
<a href="#l3.398"></a><span id="l3.398" class="difflineplus">+</span>
<a href="#l3.399"></a><span id="l3.399">   m_foldersSearchingOver.Clear();</span>
<a href="#l3.400"></a><span id="l3.400">   m_curFolderGettingHits = nullptr;</span>
<a href="#l3.401"></a><span id="l3.401">   return rv;</span>
<a href="#l3.402"></a><span id="l3.402"> }</span>
<a href="#l3.403"></a><span id="l3.403"> </span>
<a href="#l3.404"></a><span id="l3.404"> </span>
<a href="#l3.405"></a><span id="l3.405"> NS_IMETHODIMP</span>
<a href="#l3.406"></a><span id="l3.406"> nsMsgXFVirtualFolderDBView::OnNewSearch()</span>
<a href="#l3.407"></a><span id="l3.407" class="difflineat">@@ -352,54 +398,60 @@ nsMsgXFVirtualFolderDBView::OnNewSearch(</span>
<a href="#l3.408"></a><span id="l3.408">   RemovePendingDBListeners();</span>
<a href="#l3.409"></a><span id="l3.409">   m_doingSearch = true;</span>
<a href="#l3.410"></a><span id="l3.410">   m_totalMessagesInView = 0;</span>
<a href="#l3.411"></a><span id="l3.411">   m_folders.Clear();</span>
<a href="#l3.412"></a><span id="l3.412">   m_keys.Clear();</span>
<a href="#l3.413"></a><span id="l3.413">   m_levels.Clear();</span>
<a href="#l3.414"></a><span id="l3.414">   m_flags.Clear();</span>
<a href="#l3.415"></a><span id="l3.415"> </span>
<a href="#l3.416"></a><span id="l3.416" class="difflineminus">-  // needs to happen after we remove the keys, since RowCountChanged() will call our GetRowCount()</span>
<a href="#l3.417"></a><span id="l3.417" class="difflineplus">+  // Needs to happen after we remove the keys, since RowCountChanged() will</span>
<a href="#l3.418"></a><span id="l3.418" class="difflineplus">+  // call our GetRowCount().</span>
<a href="#l3.419"></a><span id="l3.419">   if (mTree)</span>
<a href="#l3.420"></a><span id="l3.420">     mTree-&gt;RowCountChanged(0, -oldSize);</span>
<a href="#l3.421"></a><span id="l3.421"> </span>
<a href="#l3.422"></a><span id="l3.422" class="difflineminus">-  // to use the search results cache, we'll need to iterate over the scopes in the</span>
<a href="#l3.423"></a><span id="l3.423" class="difflineminus">-  // search session, calling getNthSearchScope for i = 0; i &lt; searchSession.countSearchScopes; i++</span>
<a href="#l3.424"></a><span id="l3.424" class="difflineminus">-  // and for each folder, then open the db and pull out the cached hits, add them to the view.</span>
<a href="#l3.425"></a><span id="l3.425" class="difflineminus">-  // For each hit in a new folder, we'll then clean up the stale hits from the previous folder(s).</span>
<a href="#l3.426"></a><span id="l3.426" class="difflineplus">+  // To use the search results cache, we'll need to iterate over the scopes</span>
<a href="#l3.427"></a><span id="l3.427" class="difflineplus">+  // in the search session, calling getNthSearchScope</span>
<a href="#l3.428"></a><span id="l3.428" class="difflineplus">+  // for i = 0; i &lt; searchSession.countSearchScopes; i++</span>
<a href="#l3.429"></a><span id="l3.429" class="difflineplus">+  // and for each folder, then open the db and pull out the cached hits,</span>
<a href="#l3.430"></a><span id="l3.430" class="difflineplus">+  // add them to the view. For each hit in a new folder, we'll then clean up</span>
<a href="#l3.431"></a><span id="l3.431" class="difflineplus">+  // the stale hits from the previous folder(s).</span>
<a href="#l3.432"></a><span id="l3.432"> </span>
<a href="#l3.433"></a><span id="l3.433">   int32_t scopeCount;</span>
<a href="#l3.434"></a><span id="l3.434">   nsCOMPtr&lt;nsIMsgSearchSession&gt; searchSession = do_QueryReferent(m_searchSession);</span>
<a href="#l3.435"></a><span id="l3.435" class="difflineminus">-  NS_ENSURE_TRUE(searchSession, NS_OK); // just ignore</span>
<a href="#l3.436"></a><span id="l3.436" class="difflineplus">+  // Just ignore.</span>
<a href="#l3.437"></a><span id="l3.437" class="difflineplus">+  NS_ENSURE_TRUE(searchSession, NS_OK);</span>
<a href="#l3.438"></a><span id="l3.438">   nsCOMPtr&lt;nsIMsgDBService&gt; msgDBService = do_GetService(NS_MSGDB_SERVICE_CONTRACTID);</span>
<a href="#l3.439"></a><span id="l3.439">   searchSession-&gt;CountSearchScopes(&amp;scopeCount);</span>
<a href="#l3.440"></a><span id="l3.440"> </span>
<a href="#l3.441"></a><span id="l3.441">   // Figure out how many search terms the virtual folder has.</span>
<a href="#l3.442"></a><span id="l3.442">   nsCOMPtr&lt;nsIMsgDatabase&gt; virtDatabase;</span>
<a href="#l3.443"></a><span id="l3.443">   nsCOMPtr&lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l3.444"></a><span id="l3.444" class="difflineminus">-  nsresult rv = m_viewFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(dbFolderInfo), getter_AddRefs(virtDatabase));</span>
<a href="#l3.445"></a><span id="l3.445" class="difflineplus">+  nsresult rv = m_viewFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(dbFolderInfo),</span>
<a href="#l3.446"></a><span id="l3.446" class="difflineplus">+                                                   getter_AddRefs(virtDatabase));</span>
<a href="#l3.447"></a><span id="l3.447">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.448"></a><span id="l3.448"> </span>
<a href="#l3.449"></a><span id="l3.449">   nsCString terms;</span>
<a href="#l3.450"></a><span id="l3.450">   dbFolderInfo-&gt;GetCharProperty(&quot;searchStr&quot;, terms);</span>
<a href="#l3.451"></a><span id="l3.451">   nsCOMPtr&lt;nsIMutableArray&gt; searchTerms;</span>
<a href="#l3.452"></a><span id="l3.452">   rv = searchSession-&gt;GetSearchTerms(getter_AddRefs(searchTerms));</span>
<a href="#l3.453"></a><span id="l3.453">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.454"></a><span id="l3.454">   nsCString curSearchAsString;</span>
<a href="#l3.455"></a><span id="l3.455"> </span>
<a href="#l3.456"></a><span id="l3.456">   rv = MsgTermListToString(searchTerms, curSearchAsString);</span>
<a href="#l3.457"></a><span id="l3.457">   // Trim off the initial AND/OR, which is irrelevant and inconsistent between</span>
<a href="#l3.458"></a><span id="l3.458">   // what searchSpec.js generates, and what's in virtualFolders.dat.</span>
<a href="#l3.459"></a><span id="l3.459" class="difflineminus">-  curSearchAsString.Cut(0, StringBeginsWith(curSearchAsString, NS_LITERAL_CSTRING(&quot;AND&quot;)) ? 3 : 2);</span>
<a href="#l3.460"></a><span id="l3.460" class="difflineplus">+  curSearchAsString.Cut(0, StringBeginsWith(curSearchAsString,</span>
<a href="#l3.461"></a><span id="l3.461" class="difflineplus">+                                            NS_LITERAL_CSTRING(&quot;AND&quot;)) ? 3 : 2);</span>
<a href="#l3.462"></a><span id="l3.462">   terms.Cut(0, StringBeginsWith(terms, NS_LITERAL_CSTRING(&quot;AND&quot;)) ? 3 : 2);</span>
<a href="#l3.463"></a><span id="l3.463"> </span>
<a href="#l3.464"></a><span id="l3.464">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.465"></a><span id="l3.465" class="difflineminus">-  // If the search session search string doesn't match the vf search str, then we're doing</span>
<a href="#l3.466"></a><span id="l3.466" class="difflineminus">-  // quick search, which means we don't want to invalidate cached results, or</span>
<a href="#l3.467"></a><span id="l3.467" class="difflineminus">-  // used cached results.</span>
<a href="#l3.468"></a><span id="l3.468" class="difflineplus">+  // If the search session search string doesn't match the vf search str,</span>
<a href="#l3.469"></a><span id="l3.469" class="difflineplus">+  // then we're doing quick search, which means we don't want to invalidate</span>
<a href="#l3.470"></a><span id="l3.470" class="difflineplus">+  // cached results, or used cached results.</span>
<a href="#l3.471"></a><span id="l3.471">   m_doingQuickSearch = !curSearchAsString.Equals(terms);</span>
<a href="#l3.472"></a><span id="l3.472"> </span>
<a href="#l3.473"></a><span id="l3.473">   if (mTree &amp;&amp; !m_doingQuickSearch)</span>
<a href="#l3.474"></a><span id="l3.474">     mTree-&gt;BeginUpdateBatch();</span>
<a href="#l3.475"></a><span id="l3.475"> </span>
<a href="#l3.476"></a><span id="l3.476">   for (int32_t i = 0; i &lt; scopeCount; i++)</span>
<a href="#l3.477"></a><span id="l3.477">   {</span>
<a href="#l3.478"></a><span id="l3.478">     nsMsgSearchScopeValue scopeId;</span>
<a href="#l3.479"></a><span id="l3.479" class="difflineat">@@ -413,18 +465,20 @@ nsMsgXFVirtualFolderDBView::OnNewSearch(</span>
<a href="#l3.480"></a><span id="l3.480">       m_viewFolder-&gt;GetURI(searchUri);</span>
<a href="#l3.481"></a><span id="l3.481">       nsresult rv = searchFolder-&gt;GetMsgDatabase(getter_AddRefs(searchDB));</span>
<a href="#l3.482"></a><span id="l3.482">       if (NS_SUCCEEDED(rv) &amp;&amp; searchDB)</span>
<a href="#l3.483"></a><span id="l3.483">       {</span>
<a href="#l3.484"></a><span id="l3.484">         if (msgDBService)</span>
<a href="#l3.485"></a><span id="l3.485">           msgDBService-&gt;RegisterPendingListener(searchFolder, this);</span>
<a href="#l3.486"></a><span id="l3.486"> </span>
<a href="#l3.487"></a><span id="l3.487">         m_foldersSearchingOver.AppendObject(searchFolder);</span>
<a href="#l3.488"></a><span id="l3.488" class="difflineminus">-        if (m_doingQuickSearch) // ignore cached hits in quick search case.</span>
<a href="#l3.489"></a><span id="l3.489" class="difflineplus">+        // Ignore cached hits in quick search case.</span>
<a href="#l3.490"></a><span id="l3.490" class="difflineplus">+        if (m_doingQuickSearch)</span>
<a href="#l3.491"></a><span id="l3.491">           continue;</span>
<a href="#l3.492"></a><span id="l3.492" class="difflineplus">+</span>
<a href="#l3.493"></a><span id="l3.493">         searchDB-&gt;GetCachedHits(searchUri.get(), getter_AddRefs(cachedHits));</span>
<a href="#l3.494"></a><span id="l3.494">         bool hasMore;</span>
<a href="#l3.495"></a><span id="l3.495">         if (cachedHits)</span>
<a href="#l3.496"></a><span id="l3.496">         {</span>
<a href="#l3.497"></a><span id="l3.497">           cachedHits-&gt;HasMoreElements(&amp;hasMore);</span>
<a href="#l3.498"></a><span id="l3.498">           if (hasMore)</span>
<a href="#l3.499"></a><span id="l3.499">           {</span>
<a href="#l3.500"></a><span id="l3.500">             mozilla::DebugOnly&lt;nsMsgKey&gt; prevKey = nsMsgKey_None;</span>
<a href="#l3.501"></a><span id="l3.501" class="difflineat">@@ -441,69 +495,78 @@ nsMsgXFVirtualFolderDBView::OnNewSearch(</span>
<a href="#l3.502"></a><span id="l3.502">                 NS_ASSERTION(prevKey == nsMsgKey_None || msgKey &gt; prevKey,</span>
<a href="#l3.503"></a><span id="l3.503">                              &quot;cached Hits not sorted&quot;);</span>
<a href="#l3.504"></a><span id="l3.504"> #ifdef DEBUG</span>
<a href="#l3.505"></a><span id="l3.505">                 prevKey = msgKey;</span>
<a href="#l3.506"></a><span id="l3.506"> #endif</span>
<a href="#l3.507"></a><span id="l3.507">                 AddHdrFromFolder(pHeader, searchFolder);</span>
<a href="#l3.508"></a><span id="l3.508">               }</span>
<a href="#l3.509"></a><span id="l3.509">               else</span>
<a href="#l3.510"></a><span id="l3.510" class="difflineplus">+              {</span>
<a href="#l3.511"></a><span id="l3.511">                 break;</span>
<a href="#l3.512"></a><span id="l3.512" class="difflineplus">+              }</span>
<a href="#l3.513"></a><span id="l3.513" class="difflineplus">+</span>
<a href="#l3.514"></a><span id="l3.514">               cachedHits-&gt;HasMoreElements(&amp;hasMore);</span>
<a href="#l3.515"></a><span id="l3.515">             }</span>
<a href="#l3.516"></a><span id="l3.516">           }</span>
<a href="#l3.517"></a><span id="l3.517">         }</span>
<a href="#l3.518"></a><span id="l3.518">       }</span>
<a href="#l3.519"></a><span id="l3.519">     }</span>
<a href="#l3.520"></a><span id="l3.520">   }</span>
<a href="#l3.521"></a><span id="l3.521" class="difflineplus">+</span>
<a href="#l3.522"></a><span id="l3.522">   if (mTree &amp;&amp; !m_doingQuickSearch)</span>
<a href="#l3.523"></a><span id="l3.523">     mTree-&gt;EndUpdateBatch();</span>
<a href="#l3.524"></a><span id="l3.524"> </span>
<a href="#l3.525"></a><span id="l3.525">   m_curFolderStartKeyIndex = 0;</span>
<a href="#l3.526"></a><span id="l3.526">   m_curFolderGettingHits = nullptr;</span>
<a href="#l3.527"></a><span id="l3.527">   m_curFolderHasCachedHits = false;</span>
<a href="#l3.528"></a><span id="l3.528"> </span>
<a href="#l3.529"></a><span id="l3.529" class="difflineminus">-  // if we have cached hits, sort them.</span>
<a href="#l3.530"></a><span id="l3.530" class="difflineplus">+  // If we have cached hits, sort them.</span>
<a href="#l3.531"></a><span id="l3.531">   if (GetSize() &gt; 0)</span>
<a href="#l3.532"></a><span id="l3.532">   {</span>
<a href="#l3.533"></a><span id="l3.533" class="difflineminus">-    // currently, we keep threaded views sorted while we build them.</span>
<a href="#l3.534"></a><span id="l3.534" class="difflineplus">+    // Currently, we keep threaded views sorted while we build them.</span>
<a href="#l3.535"></a><span id="l3.535">     if (m_sortType != nsMsgViewSortType::byThread &amp;&amp;</span>
<a href="#l3.536"></a><span id="l3.536">       !(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l3.537"></a><span id="l3.537">     {</span>
<a href="#l3.538"></a><span id="l3.538" class="difflineminus">-      m_sortValid = false;       //sort the results</span>
<a href="#l3.539"></a><span id="l3.539" class="difflineplus">+      // Sort the results.</span>
<a href="#l3.540"></a><span id="l3.540" class="difflineplus">+      m_sortValid = false;</span>
<a href="#l3.541"></a><span id="l3.541">       Sort(m_sortType, m_sortOrder);</span>
<a href="#l3.542"></a><span id="l3.542">     }</span>
<a href="#l3.543"></a><span id="l3.543">   }</span>
<a href="#l3.544"></a><span id="l3.544" class="difflineplus">+</span>
<a href="#l3.545"></a><span id="l3.545">   return NS_OK;</span>
<a href="#l3.546"></a><span id="l3.546"> }</span>
<a href="#l3.547"></a><span id="l3.547"> </span>
<a href="#l3.548"></a><span id="l3.548" class="difflineminus">-</span>
<a href="#l3.549"></a><span id="l3.549" class="difflineminus">-NS_IMETHODIMP nsMsgXFVirtualFolderDBView::DoCommand(nsMsgViewCommandTypeValue command)</span>
<a href="#l3.550"></a><span id="l3.550" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l3.551"></a><span id="l3.551" class="difflineplus">+nsMsgXFVirtualFolderDBView::DoCommand(nsMsgViewCommandTypeValue command)</span>
<a href="#l3.552"></a><span id="l3.552"> {</span>
<a href="#l3.553"></a><span id="l3.553" class="difflineminus">-    return nsMsgSearchDBView::DoCommand(command);</span>
<a href="#l3.554"></a><span id="l3.554" class="difflineplus">+  return nsMsgSearchDBView::DoCommand(command);</span>
<a href="#l3.555"></a><span id="l3.555"> }</span>
<a href="#l3.556"></a><span id="l3.556"> </span>
<a href="#l3.557"></a><span id="l3.557" class="difflineminus">-</span>
<a href="#l3.558"></a><span id="l3.558" class="difflineminus">-</span>
<a href="#l3.559"></a><span id="l3.559" class="difflineminus">-NS_IMETHODIMP nsMsgXFVirtualFolderDBView::GetMsgFolder(nsIMsgFolder **aMsgFolder)</span>
<a href="#l3.560"></a><span id="l3.560" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l3.561"></a><span id="l3.561" class="difflineplus">+nsMsgXFVirtualFolderDBView::GetMsgFolder(nsIMsgFolder **aMsgFolder)</span>
<a href="#l3.562"></a><span id="l3.562"> {</span>
<a href="#l3.563"></a><span id="l3.563">   NS_ENSURE_ARG_POINTER(aMsgFolder);</span>
<a href="#l3.564"></a><span id="l3.564">   NS_IF_ADDREF(*aMsgFolder = m_viewFolder);</span>
<a href="#l3.565"></a><span id="l3.565">   return NS_OK;</span>
<a href="#l3.566"></a><span id="l3.566"> }</span>
<a href="#l3.567"></a><span id="l3.567"> </span>
<a href="#l3.568"></a><span id="l3.568" class="difflineminus">-NS_IMETHODIMP nsMsgXFVirtualFolderDBView::SetViewFlags(nsMsgViewFlagsTypeValue aViewFlags)</span>
<a href="#l3.569"></a><span id="l3.569" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l3.570"></a><span id="l3.570" class="difflineplus">+nsMsgXFVirtualFolderDBView::SetViewFlags(nsMsgViewFlagsTypeValue aViewFlags)</span>
<a href="#l3.571"></a><span id="l3.571"> {</span>
<a href="#l3.572"></a><span id="l3.572">   nsresult rv = NS_OK;</span>
<a href="#l3.573"></a><span id="l3.573" class="difflineminus">-  // if the grouping/threading has changed, rebuild the view</span>
<a href="#l3.574"></a><span id="l3.574" class="difflineplus">+  // If the grouping/threading has changed, rebuild the view.</span>
<a href="#l3.575"></a><span id="l3.575">   if ((m_viewFlags &amp; (nsMsgViewFlagsType::kGroupBySort |</span>
<a href="#l3.576"></a><span id="l3.576">                       nsMsgViewFlagsType::kThreadedDisplay)) !=</span>
<a href="#l3.577"></a><span id="l3.577">       (aViewFlags &amp; (nsMsgViewFlagsType::kGroupBySort |</span>
<a href="#l3.578"></a><span id="l3.578">                      nsMsgViewFlagsType::kThreadedDisplay)))</span>
<a href="#l3.579"></a><span id="l3.579" class="difflineplus">+  {</span>
<a href="#l3.580"></a><span id="l3.580">     rv = RebuildView(aViewFlags);</span>
<a href="#l3.581"></a><span id="l3.581" class="difflineplus">+  }</span>
<a href="#l3.582"></a><span id="l3.582" class="difflineplus">+</span>
<a href="#l3.583"></a><span id="l3.583">   nsMsgDBView::SetViewFlags(aViewFlags);</span>
<a href="#l3.584"></a><span id="l3.584">   return rv;</span>
<a href="#l3.585"></a><span id="l3.585"> }</span>
<a href="#l3.586"></a><span id="l3.586"> </span>
<a href="#l3.587"></a><span id="l3.587"> </span>
<a href="#l3.588"></a><span id="l3.588"> nsresult</span>
<a href="#l3.589"></a><span id="l3.589"> nsMsgXFVirtualFolderDBView::GetMessageEnumerator(nsISimpleEnumerator **enumerator)</span>
<a href="#l3.590"></a><span id="l3.590"> {</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

