<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 2945:87e6de24a564a56d4132785223071bb5ff938a03</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 87e6de24a564a56d4132785223071bb5ff938a03" />
<meta property="og:url" content="/comm-central/rev/87e6de24a564a56d4132785223071bb5ff938a03" />
<meta property="og:description" content="Bug 474701 - gloda global search on toolbar, folder display refactoring mega-bug. gloda search layer v3. r+sr=bienvenu." />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 87e6de24a564a56d4132785223071bb5ff938a03 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/87e6de24a564a56d4132785223071bb5ff938a03">shortlog</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/87e6de24a564a56d4132785223071bb5ff938a03">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03">files</a> |
changeset |
<a href="/comm-central/raw-rev/87e6de24a564a56d4132785223071bb5ff938a03">raw</a>  | <a href="/comm-central/archive/87e6de24a564a56d4132785223071bb5ff938a03.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=474701">Bug 474701</a> - gloda global search on toolbar, folder display refactoring mega-bug. gloda search layer v3. r+sr=bienvenu.
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Thu, 25 Jun 2009 21:57:59 -0700</td></tr>

<tr>
 <td>changeset 2945</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/87e6de24a564a56d4132785223071bb5ff938a03">87e6de24a564a56d4132785223071bb5ff938a03</a></td>
</tr>



<tr>
<td>parent 2944</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/5d02eacab64bb60e2d6046164118827275ea8d83">5d02eacab64bb60e2d6046164118827275ea8d83</a>
</td>
</tr>

<tr>
<td>child 2946</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/781f622cb9b73a2a0c825a1065716c9984d3b461">781f622cb9b73a2a0c825a1065716c9984d3b461</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=87e6de24a564a56d4132785223071bb5ff938a03">2386</a></td></tr>
<tr><td>push user</td><td>bugmail@asutherland.org</td></tr>
<tr><td>push date</td><td class="date age">Fri, 26 Jun 2009 04:58:19 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@87e6de24a564 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=87e6de24a564a56d4132785223071bb5ff938a03">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=87e6de24a564a56d4132785223071bb5ff938a03&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=87e6de24a564a56d4132785223071bb5ff938a03&newProject=comm-central&newRevision=87e6de24a564a56d4132785223071bb5ff938a03&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=87e6de24a564a56d4132785223071bb5ff938a03&newProject=comm-central&newRevision=87e6de24a564a56d4132785223071bb5ff938a03&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=87e6de24a564a56d4132785223071bb5ff938a03&newProject=comm-central&newRevision=87e6de24a564a56d4132785223071bb5ff938a03&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>

<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=474701">474701</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=474701">Bug 474701</a> - gloda global search on toolbar, folder display refactoring mega-bug. gloda search layer v3. r+sr=bienvenu.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/extraCustomizeItems.xul">mail/base/content/extraCustomizeItems.xul</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/extraCustomizeItems.xul">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/extraCustomizeItems.xul">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/extraCustomizeItems.xul">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/extraCustomizeItems.xul">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/extraCustomizeItems.xul">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/mailWindowOverlay.js">mail/base/content/mailWindowOverlay.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/mailWindowOverlay.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/mailWindowOverlay.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/mailWindowOverlay.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/mailWindowOverlay.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/mailWindowOverlay.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/messenger.css">mail/base/content/messenger.css</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/messenger.css">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/messenger.css">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/messenger.css">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/messenger.css">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/messenger.css">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/messenger.xul">mail/base/content/messenger.xul</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/messenger.xul">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/messenger.xul">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/messenger.xul">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/messenger.xul">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/messenger.xul">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/msgMail3PaneWindow.js">mail/base/content/msgMail3PaneWindow.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/msgMail3PaneWindow.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/msgMail3PaneWindow.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/msgMail3PaneWindow.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/msgMail3PaneWindow.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/msgMail3PaneWindow.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/search.xml">mail/base/content/search.xml</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/search.xml">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/search.xml">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/search.xml">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/search.xml">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mail/base/content/search.xml">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/locales/en-US/chrome/messenger/messenger.dtd">mail/locales/en-US/chrome/messenger/messenger.dtd</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mail/locales/en-US/chrome/messenger/messenger.dtd">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mail/locales/en-US/chrome/messenger/messenger.dtd">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/locales/en-US/chrome/messenger/messenger.dtd">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mail/locales/en-US/chrome/messenger/messenger.dtd">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mail/locales/en-US/chrome/messenger/messenger.dtd">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/locales/en-US/chrome/messenger/search.properties">mail/locales/en-US/chrome/messenger/search.properties</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mail/locales/en-US/chrome/messenger/search.properties">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mail/locales/en-US/chrome/messenger/search.properties">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mail/locales/en-US/chrome/messenger/search.properties">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mail/locales/en-US/chrome/messenger/search.properties">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mail/locales/en-US/chrome/messenger/search.properties">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/base/src/searchSpec.js">mailnews/base/src/searchSpec.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/base/src/searchSpec.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/base/src/searchSpec.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/base/src/searchSpec.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/base/src/searchSpec.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/base/src/searchSpec.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/collection.js">mailnews/db/gloda/modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/collection.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/collection.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/connotent.js">mailnews/db/gloda/modules/connotent.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/connotent.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/connotent.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/connotent.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/connotent.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/connotent.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/databind.js">mailnews/db/gloda/modules/databind.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/databind.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/databind.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/databind.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/databind.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/databind.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/datamodel.js">mailnews/db/gloda/modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/datastore.js">mailnews/db/gloda/modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/dbview.js">mailnews/db/gloda/modules/dbview.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/dbview.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/dbview.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/dbview.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/dbview.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/dbview.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/explattr.js">mailnews/db/gloda/modules/explattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/explattr.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/explattr.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/explattr.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/explattr.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/explattr.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/fundattr.js">mailnews/db/gloda/modules/fundattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/fundattr.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/fundattr.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/fundattr.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/fundattr.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/fundattr.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/gloda.js">mailnews/db/gloda/modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/indexer.js">mailnews/db/gloda/modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/msg_search.js">mailnews/db/gloda/modules/msg_search.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/msg_search.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/msg_search.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/msg_search.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/msg_search.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/msg_search.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/query.js">mailnews/db/gloda/modules/query.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/query.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/query.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/query.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/query.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/modules/query.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/resources/genericIndexer.js">mailnews/db/gloda/test/unit/resources/genericIndexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/resources/genericIndexer.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/resources/genericIndexer.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/resources/genericIndexer.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/resources/genericIndexer.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/resources/genericIndexer.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_index_messages.js">mailnews/db/gloda/test/unit/test_index_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_index_messages.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_index_messages.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_index_messages.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_index_messages.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_index_messages.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_query_core.js">mailnews/db/gloda/test/unit/test_query_core.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_query_core.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_query_core.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_query_core.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_query_core.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_query_core.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_query_messages.js">mailnews/db/gloda/test/unit/test_query_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_query_messages.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_query_messages.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_query_messages.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_query_messages.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_query_messages.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_search_messages.js">mailnews/db/gloda/test/unit/test_search_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_search_messages.js">file</a> |
<a href="/comm-central/annotate/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_search_messages.js">annotate</a> |
<a href="/comm-central/diff/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_search_messages.js">diff</a> |
<a href="/comm-central/comparison/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_search_messages.js">comparison</a> |
<a href="/comm-central/log/87e6de24a564a56d4132785223071bb5ff938a03/mailnews/db/gloda/test/unit/test_search_messages.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mail/base/content/extraCustomizeItems.xul</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mail/base/content/extraCustomizeItems.xul</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -48,16 +48,26 @@</span>
<a href="#l1.4"></a><span id="l1.4">   %msgViewPickerDTD;</span>
<a href="#l1.5"></a><span id="l1.5">   &lt;!ENTITY % brandDTD SYSTEM &quot;chrome://branding/locale/brand.dtd&quot;&gt;</span>
<a href="#l1.6"></a><span id="l1.6">   %brandDTD;</span>
<a href="#l1.7"></a><span id="l1.7"> ]&gt;</span>
<a href="#l1.8"></a><span id="l1.8"> </span>
<a href="#l1.9"></a><span id="l1.9"> &lt;overlay xmlns=&quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;&gt;</span>
<a href="#l1.10"></a><span id="l1.10"> </span>
<a href="#l1.11"></a><span id="l1.11">   &lt;toolbarpalette id=&quot;MailToolbarPalette&quot;&gt;</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+    &lt;!-- gloda search widget; provides global (message) searching.  --&gt;</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+    &lt;toolbaritem id=&quot;gloda-search&quot; insertafter=&quot;search-container&quot;</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+                 title=&quot;&amp;glodaSearch.title;&quot;</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+                 align=&quot;center&quot;</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+                 class=&quot;chromeclass-toolbar-additional&quot;&gt;</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+      &lt;textbox id=&quot;glodaSearchInput&quot; flex=&quot;1&quot; type=&quot;search&quot;</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineplus">+               searchbutton=&quot;true&quot;</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+               emptytext=&quot;&amp;glodaSearchBar.emptyText;&quot;/&gt;</span>
<a href="#l1.20"></a><span id="l1.20" class="difflineplus">+    &lt;/toolbaritem&gt;</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineplus">+</span>
<a href="#l1.22"></a><span id="l1.22">     &lt;toolbaritem id=&quot;search-container&quot; insertafter=&quot;button-stop&quot;</span>
<a href="#l1.23"></a><span id="l1.23">                  title=&quot;&amp;searchItem.title;&quot;</span>
<a href="#l1.24"></a><span id="l1.24">                  align=&quot;center&quot;</span>
<a href="#l1.25"></a><span id="l1.25">                  class=&quot;chromeclass-toolbar-additional&quot;&gt;</span>
<a href="#l1.26"></a><span id="l1.26">       &lt;textbox id=&quot;searchInput&quot; timeout=&quot;800&quot; flex=&quot;1&quot;</span>
<a href="#l1.27"></a><span id="l1.27">                onfocus=&quot;onSearchInputFocus(event);&quot;</span>
<a href="#l1.28"></a><span id="l1.28">                onclick=&quot;onSearchInputClick(event);&quot;</span>
<a href="#l1.29"></a><span id="l1.29">                onmousedown=&quot;onSearchInputMousedown(event);&quot;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mail/base/content/mailWindowOverlay.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mail/base/content/mailWindowOverlay.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -41,16 +41,18 @@</span>
<a href="#l2.4"></a><span id="l2.4">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l2.5"></a><span id="l2.5">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l2.6"></a><span id="l2.6">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l2.7"></a><span id="l2.7">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l2.8"></a><span id="l2.8">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l2.9"></a><span id="l2.9">  *</span>
<a href="#l2.10"></a><span id="l2.10">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+Components.utils.import(&quot;resource://app/modules/gloda/dbview.js&quot;);</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+</span>
<a href="#l2.14"></a><span id="l2.14"> const ADDR_DB_LARGE_COMMIT       = 1;</span>
<a href="#l2.15"></a><span id="l2.15"> </span>
<a href="#l2.16"></a><span id="l2.16"> const kClassicMailLayout = 0;</span>
<a href="#l2.17"></a><span id="l2.17"> const kWideMailLayout = 1;</span>
<a href="#l2.18"></a><span id="l2.18"> const kVerticalMailLayout = 2;</span>
<a href="#l2.19"></a><span id="l2.19"> </span>
<a href="#l2.20"></a><span id="l2.20"> // Per message header flags to keep track of whether the user is allowing remote</span>
<a href="#l2.21"></a><span id="l2.21"> // content for a particular message.</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineat">@@ -1774,17 +1776,69 @@ let mailTabType = {</span>
<a href="#l2.23"></a><span id="l2.23">           aTab.title = &quot;Re: &quot;;</span>
<a href="#l2.24"></a><span id="l2.24">         if (aMsgHdr.mime2DecodedSubject)</span>
<a href="#l2.25"></a><span id="l2.25">           aTab.title += aMsgHdr.mime2DecodedSubject;</span>
<a href="#l2.26"></a><span id="l2.26"> </span>
<a href="#l2.27"></a><span id="l2.27">         aTab.title += &quot; - &quot; + aMsgHdr.folder.prettyName;</span>
<a href="#l2.28"></a><span id="l2.28">         if (this._getNumberOfRealAccounts() &gt; 1)</span>
<a href="#l2.29"></a><span id="l2.29">           aTab.title += &quot; - &quot; + aMsgHdr.folder.server.prettyName;</span>
<a href="#l2.30"></a><span id="l2.30">       }</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineminus">-    }</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+    },</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineplus">+    /**</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+     * The glodaSearch view displays a gloda-backed nsMsgDBView with only the</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+     *  thread pane and (potentially) the message pane displayed; the folder</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+     *  pane is forced hidden.</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+     */</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+    glodaSearch: {</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineplus">+      type: &quot;glodaSearch&quot;,</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineplus">+      /// The set of panes that are legal to be displayed in this mode</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineplus">+      legalPanes: {</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineplus">+        folder: false,</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineplus">+        thread: true,</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineplus">+        message: true,</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineplus">+        glodaFacets: false,</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+      },</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineplus">+      desiredColumns: {</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineplus">+        flaggedCol: true,</span>
<a href="#l2.49"></a><span id="l2.49" class="difflineplus">+        subjectCol: true,</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineplus">+        senderCol: true,</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineplus">+        dateCol: true,</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineplus">+      },</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineplus">+      /**</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineplus">+       * Open a new tab whose view is backed by a gloda search.</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+       *</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+       * @param searchString</span>
<a href="#l2.57"></a><span id="l2.57" class="difflineplus">+       * @param facetString</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineplus">+       *     - everything:</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineplus">+       *     - subject:</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineplus">+       *     - involves:</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineplus">+       *     - to:</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineplus">+       *     - from:</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineplus">+       *     - body:</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineplus">+       * @param location Either a GlodaFolder or the string &quot;everywhere&quot;.</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineplus">+       */</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineplus">+      openTab: function(aTab, searchString, facetString, location) {</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineplus">+        // make sure the search string bundle is loaded</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineplus">+        getDocumentElements();</span>
<a href="#l2.69"></a><span id="l2.69" class="difflineplus">+        aTab.title = gSearchBundle.getFormattedString(&quot;glodaSearchTabTitle&quot;,</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineplus">+                                                      [searchString]);</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+        aTab.glodaSearchInputValue = searchString;</span>
<a href="#l2.72"></a><span id="l2.72" class="difflineplus">+        aTab.searchString = searchString;</span>
<a href="#l2.73"></a><span id="l2.73" class="difflineplus">+        aTab.facetString = facetString;</span>
<a href="#l2.74"></a><span id="l2.74" class="difflineplus">+</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineplus">+        aTab.glodaSynView = new GlodaSyntheticSearchView(searchString,</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineplus">+                                                         facetString,</span>
<a href="#l2.77"></a><span id="l2.77" class="difflineplus">+                                                         location);</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineplus">+</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineplus">+        this.openTab(aTab, false, new MessagePaneDisplayWidget());</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineplus">+        aTab.folderDisplay.show(aTab.glodaSynView);</span>
<a href="#l2.81"></a><span id="l2.81" class="difflineplus">+        aTab.folderDisplay.setVisibleColumns(aTab.mode.desiredColumns);</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineplus">+        aTab.folderDisplay.makeActive();</span>
<a href="#l2.83"></a><span id="l2.83" class="difflineplus">+      },</span>
<a href="#l2.84"></a><span id="l2.84" class="difflineplus">+    },</span>
<a href="#l2.85"></a><span id="l2.85">   },</span>
<a href="#l2.86"></a><span id="l2.86"> </span>
<a href="#l2.87"></a><span id="l2.87">   _getNumberOfRealAccounts : function() {</span>
<a href="#l2.88"></a><span id="l2.88">     let mgr = Components.classes[&quot;@mozilla.org/messenger/account-manager;1&quot;]</span>
<a href="#l2.89"></a><span id="l2.89">                         .getService(Components.interfaces.nsIMsgAccountManager);</span>
<a href="#l2.90"></a><span id="l2.90">     let accountCount = mgr.accounts.Count();</span>
<a href="#l2.91"></a><span id="l2.91">     // If we have an account, we also always have a &quot;Local Folders&quot; account.</span>
<a href="#l2.92"></a><span id="l2.92">     return accountCount &gt; 0 ? (accountCount - 1) : 0;</span>
<a href="#l2.93"></a><span id="l2.93" class="difflineat">@@ -1916,18 +1970,18 @@ let mailTabType = {</span>
<a href="#l2.94"></a><span id="l2.94">     } catch (ex) {}</span>
<a href="#l2.95"></a><span id="l2.95"> </span>
<a href="#l2.96"></a><span id="l2.96">     // -- message pane</span>
<a href="#l2.97"></a><span id="l2.97">     // the message pane can only be collapsed when the thread pane is legal</span>
<a href="#l2.98"></a><span id="l2.98">     document.getElementById(&quot;messagepanebox&quot;).collapsed =</span>
<a href="#l2.99"></a><span id="l2.99">       aLegalStates.thread &amp;&amp; !aVisibleStates.message;</span>
<a href="#l2.100"></a><span id="l2.100"> </span>
<a href="#l2.101"></a><span id="l2.101">     // -- gloda facets</span>
<a href="#l2.102"></a><span id="l2.102" class="difflineminus">-    //document.getElementById(&quot;glodaSearchFacets&quot;).hidden =</span>
<a href="#l2.103"></a><span id="l2.103" class="difflineminus">-    //  !aLegalStates.glodaFacets;</span>
<a href="#l2.104"></a><span id="l2.104" class="difflineplus">+    document.getElementById(&quot;glodaSearchFacets&quot;).hidden =</span>
<a href="#l2.105"></a><span id="l2.105" class="difflineplus">+      !aLegalStates.glodaFacets;</span>
<a href="#l2.106"></a><span id="l2.106">   },</span>
<a href="#l2.107"></a><span id="l2.107"> </span>
<a href="#l2.108"></a><span id="l2.108">   showTab: function(aTab) {</span>
<a href="#l2.109"></a><span id="l2.109">     // Set the messagepane as the primary browser for content.</span>
<a href="#l2.110"></a><span id="l2.110">     document.getElementById(&quot;messagepane&quot;).setAttribute(&quot;type&quot;,</span>
<a href="#l2.111"></a><span id="l2.111">                                                         &quot;content-primary&quot;);</span>
<a href="#l2.112"></a><span id="l2.112"> </span>
<a href="#l2.113"></a><span id="l2.113">     aTab.folderDisplay.makeActive();</span>
<a href="#l2.114"></a><span id="l2.114" class="difflineat">@@ -1962,16 +2016,53 @@ let mailTabType = {</span>
<a href="#l2.115"></a><span id="l2.115">     DefaultController.onEvent(aEvent);</span>
<a href="#l2.116"></a><span id="l2.116">   },</span>
<a href="#l2.117"></a><span id="l2.117"> </span>
<a href="#l2.118"></a><span id="l2.118">   getBrowser: function(aTab) {</span>
<a href="#l2.119"></a><span id="l2.119">     // We currently use the messagepane element for all tab types.</span>
<a href="#l2.120"></a><span id="l2.120">     return document.getElementById(&quot;messagepane&quot;);</span>
<a href="#l2.121"></a><span id="l2.121">   }</span>
<a href="#l2.122"></a><span id="l2.122"> };</span>
<a href="#l2.123"></a><span id="l2.123" class="difflineplus">+/**</span>
<a href="#l2.124"></a><span id="l2.124" class="difflineplus">+ * The glodaSearch tab mode has a UI widget outside of the mailTabType's</span>
<a href="#l2.125"></a><span id="l2.125" class="difflineplus">+ *  display panel, the #glodaSearchInput textbox.  This means we need to use a</span>
<a href="#l2.126"></a><span id="l2.126" class="difflineplus">+ *  tab monitor so that we can appropriately update the contents of the textbox.</span>
<a href="#l2.127"></a><span id="l2.127" class="difflineplus">+ * Every time a tab is changed, we save the state of the text box and restore</span>
<a href="#l2.128"></a><span id="l2.128" class="difflineplus">+ *  its previous value for the tab we are switching to, as well as whether this</span>
<a href="#l2.129"></a><span id="l2.129" class="difflineplus">+ *  value is a change to the currently-used value (if it is a glodaSearch) tab.</span>
<a href="#l2.130"></a><span id="l2.130" class="difflineplus">+ *  The behaviour rationale for this is that the glodaSearchInput is like the</span>
<a href="#l2.131"></a><span id="l2.131" class="difflineplus">+ *  URL bar.  When you are on a glodaSearch tab, we need to show you your</span>
<a href="#l2.132"></a><span id="l2.132" class="difflineplus">+ *  current value, including any &quot;uncommitted&quot; (you haven't hit enter yet)</span>
<a href="#l2.133"></a><span id="l2.133" class="difflineplus">+ *  changes.  It's not entirely clear that imitating this behaviour on</span>
<a href="#l2.134"></a><span id="l2.134" class="difflineplus">+ *  non-glodaSearch tabs makes a lot of sense, but it is consistent, so we do</span>
<a href="#l2.135"></a><span id="l2.135" class="difflineplus">+ *  so.  The counter-example to this choice is the search box in firefox, but</span>
<a href="#l2.136"></a><span id="l2.136" class="difflineplus">+ *  it never updates when you switch tabs, so it is arguably less of a fit.</span>
<a href="#l2.137"></a><span id="l2.137" class="difflineplus">+ */</span>
<a href="#l2.138"></a><span id="l2.138" class="difflineplus">+var glodaSearchTabMonitor = {</span>
<a href="#l2.139"></a><span id="l2.139" class="difflineplus">+  onTabTitleChanged: function() {},</span>
<a href="#l2.140"></a><span id="l2.140" class="difflineplus">+  onTabSwitched: function glodaSearchTabMonitor_onTabSwitch(aTab, aOldTab) {</span>
<a href="#l2.141"></a><span id="l2.141" class="difflineplus">+    let inputNode = document.getElementById(&quot;glodaSearchInput&quot;);</span>
<a href="#l2.142"></a><span id="l2.142" class="difflineplus">+    if (!inputNode)</span>
<a href="#l2.143"></a><span id="l2.143" class="difflineplus">+      return;</span>
<a href="#l2.144"></a><span id="l2.144" class="difflineplus">+</span>
<a href="#l2.145"></a><span id="l2.145" class="difflineplus">+    // save the current search field value</span>
<a href="#l2.146"></a><span id="l2.146" class="difflineplus">+    if (aOldTab)</span>
<a href="#l2.147"></a><span id="l2.147" class="difflineplus">+      aOldTab.glodaSearchInputValue = inputNode.value;</span>
<a href="#l2.148"></a><span id="l2.148" class="difflineplus">+    // load (or clear if there is none) the persisted search field value</span>
<a href="#l2.149"></a><span id="l2.149" class="difflineplus">+    inputNode.value = aTab.glodaSearchInputValue || &quot;&quot;;</span>
<a href="#l2.150"></a><span id="l2.150" class="difflineplus">+</span>
<a href="#l2.151"></a><span id="l2.151" class="difflineplus">+    // If the mode is glodaSearch and the search is unchanged, then we want to</span>
<a href="#l2.152"></a><span id="l2.152" class="difflineplus">+    //  set the icon state of the input box to be the 'clear' icon.</span>
<a href="#l2.153"></a><span id="l2.153" class="difflineplus">+    if (aTab.mode.name == &quot;glodaSearch&quot;) {</span>
<a href="#l2.154"></a><span id="l2.154" class="difflineplus">+      if (aTab.searchString == aTab.glodaSearchInputValue)</span>
<a href="#l2.155"></a><span id="l2.155" class="difflineplus">+        inputNode._searchIcons.selectedIndex = 1;</span>
<a href="#l2.156"></a><span id="l2.156" class="difflineplus">+    }</span>
<a href="#l2.157"></a><span id="l2.157" class="difflineplus">+  }</span>
<a href="#l2.158"></a><span id="l2.158" class="difflineplus">+};</span>
<a href="#l2.159"></a><span id="l2.159" class="difflineplus">+</span>
<a href="#l2.160"></a><span id="l2.160"> </span>
<a href="#l2.161"></a><span id="l2.161"> function MsgOpenNewWindowForFolder(folderURI, msgKeyToSelect)</span>
<a href="#l2.162"></a><span id="l2.162"> {</span>
<a href="#l2.163"></a><span id="l2.163">   if (folderURI) {</span>
<a href="#l2.164"></a><span id="l2.164">     window.openDialog(&quot;chrome://messenger/content/&quot;, &quot;_blank&quot;,</span>
<a href="#l2.165"></a><span id="l2.165">                       &quot;chrome,all,dialog=no&quot;, folderURI, msgKeyToSelect);</span>
<a href="#l2.166"></a><span id="l2.166">     return;</span>
<a href="#l2.167"></a><span id="l2.167">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mail/base/content/messenger.css</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mail/base/content/messenger.css</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -159,16 +159,24 @@ searchterm {</span>
<a href="#l3.4"></a><span id="l3.4"> .ruleactiontarget[type=&quot;replytomessage&quot;] {</span>
<a href="#l3.5"></a><span id="l3.5">   -moz-binding: url(&quot;chrome://messenger/content/searchWidgets.xml#ruleactiontarget-replyto&quot;);</span>
<a href="#l3.6"></a><span id="l3.6"> }</span>
<a href="#l3.7"></a><span id="l3.7"> </span>
<a href="#l3.8"></a><span id="l3.8"> dummy.usesMailWidgets {</span>
<a href="#l3.9"></a><span id="l3.9">   -moz-binding: url(&quot;chrome://messenger/content/mailWidgets.xml#dummy&quot;);</span>
<a href="#l3.10"></a><span id="l3.10"> }</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+#glodaSearchInput {</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+  -moz-binding: url(&quot;chrome://messenger/content/search.xml#glodaSearch&quot;);</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+}</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+#glodaSearchFacets {</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+  -moz-binding: url(&quot;chrome://messenger/content/search.xml#glodaFacets&quot;);</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+}</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+</span>
<a href="#l3.20"></a><span id="l3.20"> #searchInput {</span>
<a href="#l3.21"></a><span id="l3.21">   -moz-binding: url(&quot;chrome://messenger/content/search.xml#searchbar&quot;);</span>
<a href="#l3.22"></a><span id="l3.22"> }</span>
<a href="#l3.23"></a><span id="l3.23"> </span>
<a href="#l3.24"></a><span id="l3.24"> #quick-search-button {</span>
<a href="#l3.25"></a><span id="l3.25">   -moz-binding: url(&quot;chrome://messenger/content/search.xml#searchBarDropMarker&quot;);</span>
<a href="#l3.26"></a><span id="l3.26">   cursor: default;</span>
<a href="#l3.27"></a><span id="l3.27">   -moz-user-focus: none;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mail/base/content/messenger.xul</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mail/base/content/messenger.xul</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -53,16 +53,20 @@</span>
<a href="#l4.4"></a><span id="l4.4"> &lt;!ENTITY % messengerDTD SYSTEM &quot;chrome://messenger/locale/messenger.dtd&quot; &gt;</span>
<a href="#l4.5"></a><span id="l4.5"> %messengerDTD;</span>
<a href="#l4.6"></a><span id="l4.6"> &lt;!ENTITY % customizeToolbarDTD SYSTEM &quot;chrome://global/locale/customizeToolbar.dtd&quot;&gt;</span>
<a href="#l4.7"></a><span id="l4.7"> %customizeToolbarDTD;</span>
<a href="#l4.8"></a><span id="l4.8"> &lt;!ENTITY % globalDTD SYSTEM &quot;chrome://global/locale/global.dtd&quot;&gt;</span>
<a href="#l4.9"></a><span id="l4.9"> %globalDTD;</span>
<a href="#l4.10"></a><span id="l4.10"> ]&gt;</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+&lt;!--</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+  - The 'what you think of when you think of thunderbird' window;</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+  -  3-pane view inside of tabs.</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineplus">+  --&gt;</span>
<a href="#l4.16"></a><span id="l4.16"> &lt;window id=&quot;messengerWindow&quot;</span>
<a href="#l4.17"></a><span id="l4.17">         xmlns=&quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;</span>
<a href="#l4.18"></a><span id="l4.18">         title=&quot;&amp;titledefault.label;&quot;</span>
<a href="#l4.19"></a><span id="l4.19">         titlemodifier=&quot;&amp;titledefault.label;&quot;</span>
<a href="#l4.20"></a><span id="l4.20">         titlemenuseparator=&quot;&amp;titleSeparator.label;&quot;</span>
<a href="#l4.21"></a><span id="l4.21">         onload=&quot;OnLoadMessenger()&quot;</span>
<a href="#l4.22"></a><span id="l4.22">         onunload=&quot;OnUnloadMessenger()&quot;</span>
<a href="#l4.23"></a><span id="l4.23">         screenX=&quot;10&quot; screenY=&quot;10&quot;</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineat">@@ -181,16 +185,22 @@</span>
<a href="#l4.25"></a><span id="l4.25">   &lt;/toolbox&gt;</span>
<a href="#l4.26"></a><span id="l4.26">   &lt;!-- XXX This extension point (tabmail-container) is only temporary!</span>
<a href="#l4.27"></a><span id="l4.27">        Horizontal space shouldn't be wasted if it isn't absolutely critical.</span>
<a href="#l4.28"></a><span id="l4.28">        A mechanism for adding sidebar panes will be added in bug 476154. --&gt;</span>
<a href="#l4.29"></a><span id="l4.29">   &lt;hbox id=&quot;tabmail-container&quot; flex=&quot;1&quot;&gt;</span>
<a href="#l4.30"></a><span id="l4.30">     &lt;tabmail id=&quot;tabmail&quot; flex=&quot;1&quot; panelcontainer=&quot;tabpanelcontainer&quot;&gt;</span>
<a href="#l4.31"></a><span id="l4.31">       &lt;hbox id=&quot;tabmail-buttons&quot;/&gt;</span>
<a href="#l4.32"></a><span id="l4.32">       &lt;tabpanels id=&quot;tabpanelcontainer&quot; flex=&quot;1&quot; class=&quot;plain&quot; selectedIndex=&quot;0&quot;&gt;</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+        &lt;!-- mailContent is the container used for the &quot;wide&quot; layout. Normally,</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+             all it contains is the &quot;messengerBox&quot; box.  However, in &quot;wide&quot; mode</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+             the message pane and its splitter transplant themselves into the box</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+             (respectively, messagepanebox and threadpane-splitter).  This gives us</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+             the folder pane next to the thread view, with the message pane/reader</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+             beneath both of them. --&gt;</span>
<a href="#l4.39"></a><span id="l4.39">         &lt;box id=&quot;mailContent&quot; orient=&quot;vertical&quot; flex=&quot;1&quot;&gt;</span>
<a href="#l4.40"></a><span id="l4.40">           &lt;box id=&quot;messengerBox&quot; orient=&quot;horizontal&quot; flex=&quot;1&quot; minheight=&quot;100&quot; height=&quot;100&quot; persist=&quot;height&quot;&gt;</span>
<a href="#l4.41"></a><span id="l4.41">             &lt;vbox id=&quot;folderPaneBox&quot; minwidth=&quot;100&quot; width=&quot;200&quot; persist=&quot;collapsed width&quot;&gt;</span>
<a href="#l4.42"></a><span id="l4.42">               &lt;label id=&quot;folderColumnLabel&quot; hidden=&quot;true&quot; value=&quot;&amp;folderColumn.label;&quot;/&gt;</span>
<a href="#l4.43"></a><span id="l4.43">               &lt;sidebarheader id=&quot;folderPaneHeader&quot; align=&quot;center&quot;&gt;</span>
<a href="#l4.44"></a><span id="l4.44">                 &lt;label id=&quot;folderpane-title&quot;/&gt;</span>
<a href="#l4.45"></a><span id="l4.45">                 &lt;spacer flex=&quot;1&quot;/&gt;</span>
<a href="#l4.46"></a><span id="l4.46">                 &lt;toolbarbutton id=&quot;folderview-cycler-prev&quot;</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineat">@@ -235,22 +245,30 @@</span>
<a href="#l4.48"></a><span id="l4.48">               &lt;box orient=&quot;vertical&quot; id=&quot;messagesBox&quot; flex=&quot;1&quot;&gt;</span>
<a href="#l4.49"></a><span id="l4.49">                 &lt;deck id=&quot;displayDeck&quot; flex=&quot;1&quot; selectedIndex=&quot;0&quot;</span>
<a href="#l4.50"></a><span id="l4.50">                       minheight=&quot;100&quot; height=&quot;100&quot; persist=&quot;height&quot;</span>
<a href="#l4.51"></a><span id="l4.51">                       onselect=&quot;ObserveDisplayDeckChange(event)&quot;&gt;</span>
<a href="#l4.52"></a><span id="l4.52">                   &lt;!-- first panel in displayDeck is Account Central --&gt;</span>
<a href="#l4.53"></a><span id="l4.53">                   &lt;vbox id=&quot;accountCentralBox&quot; flex=&quot;1&quot;&gt;</span>
<a href="#l4.54"></a><span id="l4.54">                     &lt;iframe name=&quot;accountCentralPane&quot; width=&quot;150&quot; flex=&quot;1&quot; src=&quot;about:blank&quot;/&gt;</span>
<a href="#l4.55"></a><span id="l4.55">                   &lt;/vbox&gt;</span>
<a href="#l4.56"></a><span id="l4.56" class="difflineplus">+                  &lt;!-- The threadPaneBox is the basis for the vertical view and you</span>
<a href="#l4.57"></a><span id="l4.57" class="difflineplus">+                       should not put anything in it, because the messagepane will</span>
<a href="#l4.58"></a><span id="l4.58" class="difflineplus">+                       get transplanted in there. (In the vertical view, the elements</span>
<a href="#l4.59"></a><span id="l4.59" class="difflineplus">+                       end up being: threadPaneBox, threadpane-splitter, messagepanebox)</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineplus">+                    --&gt;</span>
<a href="#l4.61"></a><span id="l4.61">                   &lt;!-- second panel is the threadPane --&gt;</span>
<a href="#l4.62"></a><span id="l4.62">                   &lt;hbox id=&quot;threadPaneBox&quot;&gt;</span>
<a href="#l4.63"></a><span id="l4.63">                    &lt;!-- The threadContentArea was specially created to be a place for</span>
<a href="#l4.64"></a><span id="l4.64">                         things that want to be above/below the thread pane, regardless</span>
<a href="#l4.65"></a><span id="l4.65">                         of where the message reader (&quot;messagepane&quot;) gets off to. --&gt;</span>
<a href="#l4.66"></a><span id="l4.66">                    &lt;vbox id=&quot;threadContentArea&quot; flex=&quot;1&quot;&gt;</span>
<a href="#l4.67"></a><span id="l4.67" class="difflineplus">+                    &lt;!-- Gloda search facets UI for use when dealing with a gloda-backed</span>
<a href="#l4.68"></a><span id="l4.68" class="difflineplus">+                         search view, implemented by glodaFacets XBL in search.xml. --&gt;</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineplus">+                    &lt;box id=&quot;glodaSearchFacets&quot;/&gt;</span>
<a href="#l4.70"></a><span id="l4.70">                     &lt;tree id=&quot;threadTree&quot;</span>
<a href="#l4.71"></a><span id="l4.71">                           persist=&quot;lastfoldersent width&quot;</span>
<a href="#l4.72"></a><span id="l4.72">                           treelines=&quot;true&quot;</span>
<a href="#l4.73"></a><span id="l4.73">                           flex=&quot;2&quot;</span>
<a href="#l4.74"></a><span id="l4.74">                           enableColumnDrag=&quot;true&quot;</span>
<a href="#l4.75"></a><span id="l4.75">                           _selectDelay=&quot;250&quot;</span>
<a href="#l4.76"></a><span id="l4.76">                           class=&quot;plain&quot;</span>
<a href="#l4.77"></a><span id="l4.77">                           lastfoldersent=&quot;false&quot;</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineat">@@ -319,16 +337,26 @@</span>
<a href="#l4.79"></a><span id="l4.79">                         &lt;treecol id=&quot;totalCol&quot; persist=&quot;hidden ordinal width&quot; flex=&quot;1&quot; hidden=&quot;true&quot;</span>
<a href="#l4.80"></a><span id="l4.80">                                  label=&quot;&amp;totalColumn.label;&quot; tooltiptext=&quot;&amp;totalColumn.tooltip;&quot;/&gt;</span>
<a href="#l4.81"></a><span id="l4.81">                         &lt;splitter class=&quot;tree-splitter&quot;/&gt;</span>
<a href="#l4.82"></a><span id="l4.82">                         &lt;treecol id=&quot;locationCol&quot; persist=&quot;width&quot; flex=&quot;1&quot; hidden=&quot;true&quot; ignoreincolumnpicker=&quot;true&quot;</span>
<a href="#l4.83"></a><span id="l4.83">                                  label=&quot;&amp;locationColumn.label;&quot; tooltiptext=&quot;&amp;locationColumn.tooltip;&quot;/&gt;</span>
<a href="#l4.84"></a><span id="l4.84">                         &lt;splitter class=&quot;tree-splitter&quot;/&gt;</span>
<a href="#l4.85"></a><span id="l4.85">                         &lt;treecol id=&quot;idCol&quot; persist=&quot;hidden ordinal width&quot; flex=&quot;1&quot; hidden=&quot;true&quot;</span>
<a href="#l4.86"></a><span id="l4.86">                                  label=&quot;&amp;idColumn.label;&quot; tooltiptext=&quot;&amp;idColumn.tooltip;&quot;/&gt;</span>
<a href="#l4.87"></a><span id="l4.87" class="difflineplus">+                        &lt;splitter class=&quot;tree-splitter&quot;/&gt;</span>
<a href="#l4.88"></a><span id="l4.88" class="difflineplus">+                        &lt;treecol id=&quot;glodaWhyCol&quot; persist=&quot;ordinal width&quot; flex=&quot;1&quot;</span>
<a href="#l4.89"></a><span id="l4.89" class="difflineplus">+                                 hidden=&quot;true&quot; ignoreincolumnpicker=&quot;true&quot;</span>
<a href="#l4.90"></a><span id="l4.90" class="difflineplus">+                                 label=&quot;&amp;glodaWhyColumn.label;&quot;</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineplus">+                                 tooltiptext=&quot;&amp;glodaWhyColumn.tooltip;&quot;/&gt;</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineplus">+                        &lt;splitter class=&quot;tree-splitter&quot;/&gt;</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineplus">+                        &lt;treecol id=&quot;glodaScoreCol&quot; persist=&quot;ordinal width&quot; flex=&quot;1&quot;</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineplus">+                                 hidden=&quot;true&quot; ignoreincolumnpicker=&quot;true&quot;</span>
<a href="#l4.95"></a><span id="l4.95" class="difflineplus">+                                 label=&quot;&amp;glodaScoreColumn.label;&quot;</span>
<a href="#l4.96"></a><span id="l4.96" class="difflineplus">+                                 tooltiptext=&quot;&amp;glodaScoreColumn.tooltip;&quot;/&gt;</span>
<a href="#l4.97"></a><span id="l4.97">                       &lt;/treecols&gt;</span>
<a href="#l4.98"></a><span id="l4.98">                     &lt;treechildren ondraggesture=&quot;threadPaneOnDragStart(event);&quot;/&gt;</span>
<a href="#l4.99"></a><span id="l4.99">                   &lt;/tree&gt;</span>
<a href="#l4.100"></a><span id="l4.100">                  &lt;/vbox&gt;</span>
<a href="#l4.101"></a><span id="l4.101">                 &lt;/hbox&gt;</span>
<a href="#l4.102"></a><span id="l4.102">                 &lt;!-- extensions may overlay in additional panels; don't assume that there are only 2! --&gt;</span>
<a href="#l4.103"></a><span id="l4.103">                 &lt;/deck&gt; &lt;!-- displayDeck --&gt;</span>
<a href="#l4.104"></a><span id="l4.104"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mail/base/content/msgMail3PaneWindow.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mail/base/content/msgMail3PaneWindow.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -285,16 +285,17 @@ function OnLoadMessenger()</span>
<a href="#l5.4"></a><span id="l5.4">   //  folder for display, and we want gFolderDisplay setup and ready to handle</span>
<a href="#l5.5"></a><span id="l5.5">   //  that event chain.</span>
<a href="#l5.6"></a><span id="l5.6">   // Also, we definitely need to register the tab type prior to the call to</span>
<a href="#l5.7"></a><span id="l5.7">   //  specialTabs.openSpecialTabsOnStartup below.</span>
<a href="#l5.8"></a><span id="l5.8">   let tabmail = document.getElementById('tabmail');</span>
<a href="#l5.9"></a><span id="l5.9">   if (tabmail)</span>
<a href="#l5.10"></a><span id="l5.10">   {</span>
<a href="#l5.11"></a><span id="l5.11">     tabmail.registerTabType(mailTabType);</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+    tabmail.registerTabMonitor(glodaSearchTabMonitor);</span>
<a href="#l5.13"></a><span id="l5.13">     tabmail.registerTabMonitor(QuickSearchTabMonitor);</span>
<a href="#l5.14"></a><span id="l5.14">     tabmail.openFirstTab();</span>
<a href="#l5.15"></a><span id="l5.15">   }</span>
<a href="#l5.16"></a><span id="l5.16"> </span>
<a href="#l5.17"></a><span id="l5.17">   // verifyAccounts returns true if the callback won't be called</span>
<a href="#l5.18"></a><span id="l5.18">   // We also don't want the account wizard to open if any sort of account exists</span>
<a href="#l5.19"></a><span id="l5.19">   if (verifyAccounts(LoadPostAccountWizard, false))</span>
<a href="#l5.20"></a><span id="l5.20">     LoadPostAccountWizard();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mail/base/content/search.xml</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mail/base/content/search.xml</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -1,59 +1,232 @@</span>
<a href="#l6.4"></a><span id="l6.4"> &lt;?xml version=&quot;1.0&quot;?&gt;</span>
<a href="#l6.5"></a><span id="l6.5"> </span>
<a href="#l6.6"></a><span id="l6.6" class="difflineminus">-# -*- Mode: HTML -*-</span>
<a href="#l6.7"></a><span id="l6.7" class="difflineminus">-# ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l6.8"></a><span id="l6.8" class="difflineminus">-# Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l6.9"></a><span id="l6.9" class="difflineminus">-#</span>
<a href="#l6.10"></a><span id="l6.10" class="difflineminus">-# The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l6.11"></a><span id="l6.11" class="difflineminus">-# 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-# the License. You may obtain a copy of the License at</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineminus">-# http://www.mozilla.org/MPL/</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineminus">-#</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineminus">-# Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineminus">-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineminus">-# for the specific language governing rights and limitations under the</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineminus">-# License.</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineminus">-#</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineminus">-# The Original Code is Mozilla Communicator client code, released</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineminus">-# March 31, 1998.</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineminus">-#</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineminus">-# The Initial Developer of the Original Code is</span>
<a href="#l6.24"></a><span id="l6.24" class="difflineminus">-# Netscape Communications Corporation.</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineminus">-# Portions created by the Initial Developer are Copyright (C) 1998-1999</span>
<a href="#l6.26"></a><span id="l6.26" class="difflineminus">-# the Initial Developer. All Rights Reserved.</span>
<a href="#l6.27"></a><span id="l6.27" class="difflineminus">-#</span>
<a href="#l6.28"></a><span id="l6.28" class="difflineminus">-# Contributor(s):</span>
<a href="#l6.29"></a><span id="l6.29" class="difflineminus">-#   Scott MacGregor &lt;mscott@mozilla.org&gt;</span>
<a href="#l6.30"></a><span id="l6.30" class="difflineminus">-#</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineminus">-# Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineminus">-# either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),</span>
<a href="#l6.33"></a><span id="l6.33" class="difflineminus">-# or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l6.34"></a><span id="l6.34" class="difflineminus">-# in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineminus">-# of those above. If you wish to allow use of your version of this file only</span>
<a href="#l6.36"></a><span id="l6.36" class="difflineminus">-# under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineminus">-# use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l6.38"></a><span id="l6.38" class="difflineminus">-# decision by deleting the provisions above and replace them with the notice</span>
<a href="#l6.39"></a><span id="l6.39" class="difflineminus">-# and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l6.40"></a><span id="l6.40" class="difflineminus">-# the provisions above, a recipient may use your version of this file under</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineminus">-# the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineminus">-# ***** END LICENSE BLOCK *****</span>
<a href="#l6.43"></a><span id="l6.43" class="difflineplus">+&lt;!-- ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineplus">+  - Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineplus">+  -</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineplus">+  - The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l6.47"></a><span id="l6.47" class="difflineplus">+  - 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l6.48"></a><span id="l6.48" class="difflineplus">+  - the License. You may obtain a copy of the License at</span>
<a href="#l6.49"></a><span id="l6.49" class="difflineplus">+  - http://www.mozilla.org/MPL/</span>
<a href="#l6.50"></a><span id="l6.50" class="difflineplus">+  -</span>
<a href="#l6.51"></a><span id="l6.51" class="difflineplus">+  - Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l6.52"></a><span id="l6.52" class="difflineplus">+  - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l6.53"></a><span id="l6.53" class="difflineplus">+  - for the specific language governing rights and limitations under the</span>
<a href="#l6.54"></a><span id="l6.54" class="difflineplus">+  - License.</span>
<a href="#l6.55"></a><span id="l6.55" class="difflineplus">+  -</span>
<a href="#l6.56"></a><span id="l6.56" class="difflineplus">+  - The Original Code is Mozilla Communicator client code, released</span>
<a href="#l6.57"></a><span id="l6.57" class="difflineplus">+  - March 31, 1998.</span>
<a href="#l6.58"></a><span id="l6.58" class="difflineplus">+  -</span>
<a href="#l6.59"></a><span id="l6.59" class="difflineplus">+  - The Initial Developer of the Original Code is</span>
<a href="#l6.60"></a><span id="l6.60" class="difflineplus">+  - Netscape Communications Corporation.</span>
<a href="#l6.61"></a><span id="l6.61" class="difflineplus">+  - Portions created by the Initial Developer are Copyright (C) 1998-1999</span>
<a href="#l6.62"></a><span id="l6.62" class="difflineplus">+  - the Initial Developer. All Rights Reserved.</span>
<a href="#l6.63"></a><span id="l6.63" class="difflineplus">+  -</span>
<a href="#l6.64"></a><span id="l6.64" class="difflineplus">+  - Contributor(s):</span>
<a href="#l6.65"></a><span id="l6.65" class="difflineplus">+  -   Scott MacGregor &lt;mscott@mozilla.org&gt;</span>
<a href="#l6.66"></a><span id="l6.66" class="difflineplus">+  -</span>
<a href="#l6.67"></a><span id="l6.67" class="difflineplus">+  - Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l6.68"></a><span id="l6.68" class="difflineplus">+  - either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),</span>
<a href="#l6.69"></a><span id="l6.69" class="difflineplus">+  - or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l6.70"></a><span id="l6.70" class="difflineplus">+  - in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l6.71"></a><span id="l6.71" class="difflineplus">+  - of those above. If you wish to allow use of your version of this file only</span>
<a href="#l6.72"></a><span id="l6.72" class="difflineplus">+  - under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l6.73"></a><span id="l6.73" class="difflineplus">+  - use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l6.74"></a><span id="l6.74" class="difflineplus">+  - decision by deleting the provisions above and replace them with the notice</span>
<a href="#l6.75"></a><span id="l6.75" class="difflineplus">+  - and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l6.76"></a><span id="l6.76" class="difflineplus">+  - the provisions above, a recipient may use your version of this file under</span>
<a href="#l6.77"></a><span id="l6.77" class="difflineplus">+  - the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l6.78"></a><span id="l6.78" class="difflineplus">+  - ***** END LICENSE BLOCK ***** --&gt;</span>
<a href="#l6.79"></a><span id="l6.79"> </span>
<a href="#l6.80"></a><span id="l6.80"> &lt;!DOCTYPE bindings [</span>
<a href="#l6.81"></a><span id="l6.81"> &lt;!ENTITY % globalDTD SYSTEM &quot;chrome://global/locale/global.dtd&quot;&gt;</span>
<a href="#l6.82"></a><span id="l6.82"> %globalDTD;</span>
<a href="#l6.83"></a><span id="l6.83" class="difflineplus">+&lt;!ENTITY % messengerDTD SYSTEM &quot;chrome://messenger/locale/messenger.dtd&quot;&gt;</span>
<a href="#l6.84"></a><span id="l6.84" class="difflineplus">+%messengerDTD;</span>
<a href="#l6.85"></a><span id="l6.85"> ]&gt;</span>
<a href="#l6.86"></a><span id="l6.86"> </span>
<a href="#l6.87"></a><span id="l6.87"> &lt;bindings id=&quot;SearchBindings&quot;</span>
<a href="#l6.88"></a><span id="l6.88">    xmlns=&quot;http://www.mozilla.org/xbl&quot;</span>
<a href="#l6.89"></a><span id="l6.89">    xmlns:html=&quot;http://www.w3.org/1999/xhtml&quot;</span>
<a href="#l6.90"></a><span id="l6.90">    xmlns:xul=&quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;</span>
<a href="#l6.91"></a><span id="l6.91">    xmlns:xbl=&quot;http://www.mozilla.org/xbl&quot;&gt;</span>
<a href="#l6.92"></a><span id="l6.92"> </span>
<a href="#l6.93"></a><span id="l6.93" class="difflineplus">+  &lt;!--</span>
<a href="#l6.94"></a><span id="l6.94" class="difflineplus">+    - The glodaSearch binding implements a gloda-backed search mechanism.  The</span>
<a href="#l6.95"></a><span id="l6.95" class="difflineplus">+    -  actual search logic comes from the glodaSearch tab mode in the</span>
<a href="#l6.96"></a><span id="l6.96" class="difflineplus">+    -  mailTabType definition.  This binding serves as a means to display and </span>
<a href="#l6.97"></a><span id="l6.97" class="difflineplus">+    -  alter the current search query if a &quot;glodaSearch&quot; tab is displayed, or</span>
<a href="#l6.98"></a><span id="l6.98" class="difflineplus">+    -  enter a search query and spawn a new &quot;glodaSearch&quot; tab if one is</span>
<a href="#l6.99"></a><span id="l6.99" class="difflineplus">+    -  currently not displayed.  The &quot;glodaFacets&quot; binding also is used to</span>
<a href="#l6.100"></a><span id="l6.100" class="difflineplus">+    -  display/modify the parameters of the search when on a &quot;glodaSearch&quot; tab.</span>
<a href="#l6.101"></a><span id="l6.101" class="difflineplus">+    --&gt;</span>
<a href="#l6.102"></a><span id="l6.102" class="difflineplus">+  &lt;binding id=&quot;glodaSearch&quot; extends=&quot;chrome://global/content/bindings/textbox.xml#search-textbox&quot;&gt;</span>
<a href="#l6.103"></a><span id="l6.103" class="difflineplus">+    &lt;resources&gt;</span>
<a href="#l6.104"></a><span id="l6.104" class="difflineplus">+      &lt;stylesheet src=&quot;chrome://messenger/skin/searchBox.css&quot;/&gt;</span>
<a href="#l6.105"></a><span id="l6.105" class="difflineplus">+    &lt;/resources&gt;</span>
<a href="#l6.106"></a><span id="l6.106" class="difflineplus">+</span>
<a href="#l6.107"></a><span id="l6.107" class="difflineplus">+    &lt;handlers&gt;</span>
<a href="#l6.108"></a><span id="l6.108" class="difflineplus">+      &lt;handler event=&quot;command&quot;&gt;&lt;![CDATA[</span>
<a href="#l6.109"></a><span id="l6.109" class="difflineplus">+        if (this.value) {</span>
<a href="#l6.110"></a><span id="l6.110" class="difflineplus">+          let searchString = this.value;</span>
<a href="#l6.111"></a><span id="l6.111" class="difflineplus">+          let tabmail = document.getElementById(&quot;tabmail&quot;);</span>
<a href="#l6.112"></a><span id="l6.112" class="difflineplus">+          // If the current tab is a gloda search tab, reset the value</span>
<a href="#l6.113"></a><span id="l6.113" class="difflineplus">+          //  to the initial search value.  Otherwise, clear it.  This</span>
<a href="#l6.114"></a><span id="l6.114" class="difflineplus">+          //  is the value that is going to be saved with the current</span>
<a href="#l6.115"></a><span id="l6.115" class="difflineplus">+          //  tab when we switch back to it next.</span>
<a href="#l6.116"></a><span id="l6.116" class="difflineplus">+          if (tabmail.currentTabInfo.mode.name == &quot;glodaSearch&quot;)</span>
<a href="#l6.117"></a><span id="l6.117" class="difflineplus">+            this.value = tabmail.currentTabInfo.searchString;</span>
<a href="#l6.118"></a><span id="l6.118" class="difflineplus">+          else</span>
<a href="#l6.119"></a><span id="l6.119" class="difflineplus">+            this.value = &quot;&quot;;</span>
<a href="#l6.120"></a><span id="l6.120" class="difflineplus">+          // open a new tab with our dude</span>
<a href="#l6.121"></a><span id="l6.121" class="difflineplus">+          tabmail.openTab(&quot;glodaSearch&quot;, searchString, &quot;everything&quot;, &quot;everywhere&quot;);</span>
<a href="#l6.122"></a><span id="l6.122" class="difflineplus">+        }</span>
<a href="#l6.123"></a><span id="l6.123" class="difflineplus">+      ]]&gt;&lt;/handler&gt;</span>
<a href="#l6.124"></a><span id="l6.124" class="difflineplus">+    &lt;/handlers&gt;</span>
<a href="#l6.125"></a><span id="l6.125" class="difflineplus">+    </span>
<a href="#l6.126"></a><span id="l6.126" class="difflineplus">+  &lt;/binding&gt;</span>
<a href="#l6.127"></a><span id="l6.127" class="difflineplus">+</span>
<a href="#l6.128"></a><span id="l6.128" class="difflineplus">+  &lt;!--</span>
<a href="#l6.129"></a><span id="l6.129" class="difflineplus">+    - The glodaFacets binding is used to display additional search constraints</span>
<a href="#l6.130"></a><span id="l6.130" class="difflineplus">+    -  on a &quot;glodaSearch&quot; tab's gloda-backed search.  Because we live in the</span>
<a href="#l6.131"></a><span id="l6.131" class="difflineplus">+    -  &quot;mailContent&quot; panel reused by the &quot;glodaSearch&quot; tab mode, we are always</span>
<a href="#l6.132"></a><span id="l6.132" class="difflineplus">+    -  present, even when we should not be displayed (namely for &quot;folder&quot; and</span>
<a href="#l6.133"></a><span id="l6.133" class="difflineplus">+    -  &quot;message&quot; tab modes).  We leave it up to the mailTabType and glodaSearch</span>
<a href="#l6.134"></a><span id="l6.134" class="difflineplus">+    -  tab mode to ensure that we are shown/hidden at the right times.  (We</span>
<a href="#l6.135"></a><span id="l6.135" class="difflineplus">+    -  could do this ourselves as a tabmail tab monitor, but it is more</span>
<a href="#l6.136"></a><span id="l6.136" class="difflineplus">+    -  intuitive to have our behaviour/relationship made explicit.)</span>
<a href="#l6.137"></a><span id="l6.137" class="difflineplus">+    --&gt;</span>
<a href="#l6.138"></a><span id="l6.138" class="difflineplus">+  &lt;binding id=&quot;glodaFacets&quot;&gt;</span>
<a href="#l6.139"></a><span id="l6.139" class="difflineplus">+    &lt;resources&gt;</span>
<a href="#l6.140"></a><span id="l6.140" class="difflineplus">+      &lt;stylesheet src=&quot;chrome://messenger/skin/searchBox.css&quot;/&gt;</span>
<a href="#l6.141"></a><span id="l6.141" class="difflineplus">+    &lt;/resources&gt;</span>
<a href="#l6.142"></a><span id="l6.142" class="difflineplus">+    &lt;content orientation=&quot;horizontal&quot; hidden=&quot;true&quot;&gt;</span>
<a href="#l6.143"></a><span id="l6.143" class="difflineplus">+      &lt;xul:label control=&quot;glodaFacetType&quot; value=&quot;&amp;glodaSearchBar.facet.label;&quot;/&gt;</span>
<a href="#l6.144"></a><span id="l6.144" class="difflineplus">+      &lt;xul:menulist id=&quot;glodaFacetType&quot;&gt;</span>
<a href="#l6.145"></a><span id="l6.145" class="difflineplus">+        &lt;xul:menupopup&gt;</span>
<a href="#l6.146"></a><span id="l6.146" class="difflineplus">+          &lt;xul:menuitem label=&quot;&amp;glodaSearchFacet.everything.label;&quot;</span>
<a href="#l6.147"></a><span id="l6.147" class="difflineplus">+                        value=&quot;everything&quot;/&gt;</span>
<a href="#l6.148"></a><span id="l6.148" class="difflineplus">+          &lt;xul:menuitem label=&quot;&amp;glodaSearchFacet.subject.label;&quot;</span>
<a href="#l6.149"></a><span id="l6.149" class="difflineplus">+                        value=&quot;subject&quot;/&gt;</span>
<a href="#l6.150"></a><span id="l6.150" class="difflineplus">+          &lt;xul:menuitem label=&quot;&amp;glodaSearchFacet.involves.label;&quot;</span>
<a href="#l6.151"></a><span id="l6.151" class="difflineplus">+                        value=&quot;involves&quot;/&gt;</span>
<a href="#l6.152"></a><span id="l6.152" class="difflineplus">+          &lt;xul:menuitem label=&quot;&amp;glodaSearchFacet.to.label;&quot;</span>
<a href="#l6.153"></a><span id="l6.153" class="difflineplus">+                        value=&quot;to&quot;/&gt;</span>
<a href="#l6.154"></a><span id="l6.154" class="difflineplus">+          &lt;xul:menuitem label=&quot;&amp;glodaSearchFacet.from.label;&quot;</span>
<a href="#l6.155"></a><span id="l6.155" class="difflineplus">+                        value=&quot;from&quot;/&gt;</span>
<a href="#l6.156"></a><span id="l6.156" class="difflineplus">+          &lt;xul:menuitem label=&quot;&amp;glodaSearchFacet.body.label;&quot;</span>
<a href="#l6.157"></a><span id="l6.157" class="difflineplus">+                        value=&quot;body&quot;/&gt;</span>
<a href="#l6.158"></a><span id="l6.158" class="difflineplus">+        &lt;/xul:menupopup&gt;</span>
<a href="#l6.159"></a><span id="l6.159" class="difflineplus">+      &lt;/xul:menulist&gt;</span>
<a href="#l6.160"></a><span id="l6.160" class="difflineplus">+      &lt;xul:label control=&quot;glodaFacetLocation&quot;</span>
<a href="#l6.161"></a><span id="l6.161" class="difflineplus">+                 value=&quot;&amp;glodaSearchBar.location.label;&quot;/&gt;</span>
<a href="#l6.162"></a><span id="l6.162" class="difflineplus">+      &lt;xul:menulist id=&quot;glodaFacetLocation&quot; anonid=&quot;glodaFacetLocation&quot;&gt;</span>
<a href="#l6.163"></a><span id="l6.163" class="difflineplus">+        &lt;xul:menupopup&gt;</span>
<a href="#l6.164"></a><span id="l6.164" class="difflineplus">+          &lt;xul:menuitem label=&quot;&amp;glodaSearchFacet.everywhere.label;&quot; value=&quot;everywhere&quot;/&gt;</span>
<a href="#l6.165"></a><span id="l6.165" class="difflineplus">+          &lt;xul:menuitem anonid=&quot;currentFolder&quot; label=&quot;&quot; value=&quot;currentFolder&quot; hidden=&quot;true&quot;/&gt;</span>
<a href="#l6.166"></a><span id="l6.166" class="difflineplus">+          &lt;xul:menu label=&quot;&amp;glodaSearchFacet.folder.label;&quot;&gt;</span>
<a href="#l6.167"></a><span id="l6.167" class="difflineplus">+            &lt;xul:menupopup type=&quot;folder&quot;/&gt;</span>
<a href="#l6.168"></a><span id="l6.168" class="difflineplus">+          &lt;/xul:menu&gt;</span>
<a href="#l6.169"></a><span id="l6.169" class="difflineplus">+        &lt;/xul:menupopup&gt;</span>
<a href="#l6.170"></a><span id="l6.170" class="difflineplus">+      &lt;/xul:menulist&gt;</span>
<a href="#l6.171"></a><span id="l6.171" class="difflineplus">+    &lt;/content&gt;</span>
<a href="#l6.172"></a><span id="l6.172" class="difflineplus">+</span>
<a href="#l6.173"></a><span id="l6.173" class="difflineplus">+    &lt;implementation&gt;</span>
<a href="#l6.174"></a><span id="l6.174" class="difflineplus">+      &lt;constructor&gt;</span>
<a href="#l6.175"></a><span id="l6.175" class="difflineplus">+        &lt;![CDATA[</span>
<a href="#l6.176"></a><span id="l6.176" class="difflineplus">+          this._facetTypeNode =</span>
<a href="#l6.177"></a><span id="l6.177" class="difflineplus">+            document.getAnonymousElementByAttribute(this, &quot;id&quot;,</span>
<a href="#l6.178"></a><span id="l6.178" class="difflineplus">+                                                    &quot;glodaFacetType&quot;);</span>
<a href="#l6.179"></a><span id="l6.179" class="difflineplus">+          this._facetLocationNode =</span>
<a href="#l6.180"></a><span id="l6.180" class="difflineplus">+            document.getAnonymousElementByAttribute(this, &quot;id&quot;,</span>
<a href="#l6.181"></a><span id="l6.181" class="difflineplus">+                                                    &quot;glodaFacetLocation&quot;);</span>
<a href="#l6.182"></a><span id="l6.182" class="difflineplus">+          this._currentFolderNode =</span>
<a href="#l6.183"></a><span id="l6.183" class="difflineplus">+            document.getAnonymousElementByAttribute(this, &quot;anonid&quot;,</span>
<a href="#l6.184"></a><span id="l6.184" class="difflineplus">+                                                    &quot;currentFolder&quot;);</span>
<a href="#l6.185"></a><span id="l6.185" class="difflineplus">+        ]]&gt;</span>
<a href="#l6.186"></a><span id="l6.186" class="difflineplus">+      &lt;/constructor&gt;</span>
<a href="#l6.187"></a><span id="l6.187" class="difflineplus">+      &lt;method name=&quot;updateStateFromCurrentTab&quot;&gt;</span>
<a href="#l6.188"></a><span id="l6.188" class="difflineplus">+        &lt;body&gt;&lt;![CDATA[</span>
<a href="#l6.189"></a><span id="l6.189" class="difflineplus">+        /**</span>
<a href="#l6.190"></a><span id="l6.190" class="difflineplus">+         * Update our display state to match the state of the current tab.</span>
<a href="#l6.191"></a><span id="l6.191" class="difflineplus">+         */</span>
<a href="#l6.192"></a><span id="l6.192" class="difflineplus">+          let tabmail = document.getElementById(&quot;tabmail&quot;);</span>
<a href="#l6.193"></a><span id="l6.193" class="difflineplus">+          let tabInfo = tabMail.currentTabInfo;</span>
<a href="#l6.194"></a><span id="l6.194" class="difflineplus">+          </span>
<a href="#l6.195"></a><span id="l6.195" class="difflineplus">+          this._facetTypeNode.value = tabInfo.facetString;</span>
<a href="#l6.196"></a><span id="l6.196" class="difflineplus">+          if (typeof(tabInfo.location) == &quot;string&quot;)</span>
<a href="#l6.197"></a><span id="l6.197" class="difflineplus">+            this._facetLocationNode.value = tabInfo.location;</span>
<a href="#l6.198"></a><span id="l6.198" class="difflineplus">+          else {</span>
<a href="#l6.199"></a><span id="l6.199" class="difflineplus">+          </span>
<a href="#l6.200"></a><span id="l6.200" class="difflineplus">+          }</span>
<a href="#l6.201"></a><span id="l6.201" class="difflineplus">+        ]]&gt;&lt;/body&gt;</span>
<a href="#l6.202"></a><span id="l6.202" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l6.203"></a><span id="l6.203" class="difflineplus">+      &lt;method name=&quot;setLocationFacetToFolder&quot;&gt;</span>
<a href="#l6.204"></a><span id="l6.204" class="difflineplus">+        &lt;body&gt;&lt;![CDATA[</span>
<a href="#l6.205"></a><span id="l6.205" class="difflineplus">+        /**</span>
<a href="#l6.206"></a><span id="l6.206" class="difflineplus">+         * Update our display state to match the state of the current tab.</span>
<a href="#l6.207"></a><span id="l6.207" class="difflineplus">+         */</span>
<a href="#l6.208"></a><span id="l6.208" class="difflineplus">+          let tabmail = document.getElementById(&quot;tabmail&quot;);</span>
<a href="#l6.209"></a><span id="l6.209" class="difflineplus">+          let tabInfo = tabMail.currentTabInfo;</span>
<a href="#l6.210"></a><span id="l6.210" class="difflineplus">+          </span>
<a href="#l6.211"></a><span id="l6.211" class="difflineplus">+          this._facetTypeNode.value = tabInfo.facetString;</span>
<a href="#l6.212"></a><span id="l6.212" class="difflineplus">+          if (typeof(tabInfo.location) == &quot;string&quot;)</span>
<a href="#l6.213"></a><span id="l6.213" class="difflineplus">+            this._facetLocationNode.value = tabInfo.location;</span>
<a href="#l6.214"></a><span id="l6.214" class="difflineplus">+          else {</span>
<a href="#l6.215"></a><span id="l6.215" class="difflineplus">+          </span>
<a href="#l6.216"></a><span id="l6.216" class="difflineplus">+          }</span>
<a href="#l6.217"></a><span id="l6.217" class="difflineplus">+        ]]&gt;&lt;/body&gt;</span>
<a href="#l6.218"></a><span id="l6.218" class="difflineplus">+</span>
<a href="#l6.219"></a><span id="l6.219" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l6.220"></a><span id="l6.220" class="difflineplus">+    &lt;/implementation&gt;</span>
<a href="#l6.221"></a><span id="l6.221" class="difflineplus">+    </span>
<a href="#l6.222"></a><span id="l6.222" class="difflineplus">+    &lt;handlers&gt;</span>
<a href="#l6.223"></a><span id="l6.223" class="difflineplus">+      &lt;handler event=&quot;command&quot; phase=&quot;bubble&quot;&gt;&lt;![CDATA[</span>
<a href="#l6.224"></a><span id="l6.224" class="difflineplus">+        // Have widgetNode be our immediate child, with nodes being a list of</span>
<a href="#l6.225"></a><span id="l6.225" class="difflineplus">+        //  the descendent nodes between eventNode and the actual target.</span>
<a href="#l6.226"></a><span id="l6.226" class="difflineplus">+        // This allows us to know which of our widgets actually got clicked on,</span>
<a href="#l6.227"></a><span id="l6.227" class="difflineplus">+        //  plus makes subsequent processing easier.  (Alternatively, we could</span>
<a href="#l6.228"></a><span id="l6.228" class="difflineplus">+        //  register a command listener on each of our widgets, but that is</span>
<a href="#l6.229"></a><span id="l6.229" class="difflineplus">+        //  arguably just as ugly.) </span>
<a href="#l6.230"></a><span id="l6.230" class="difflineplus">+        let nodes = [];</span>
<a href="#l6.231"></a><span id="l6.231" class="difflineplus">+        let widgetNode = event.originalTarget;</span>
<a href="#l6.232"></a><span id="l6.232" class="difflineplus">+        while (widgetNode.parentNode != this) {</span>
<a href="#l6.233"></a><span id="l6.233" class="difflineplus">+          nodes.unshift(widgetNode);</span>
<a href="#l6.234"></a><span id="l6.234" class="difflineplus">+          widgetNode = widgetNode.parentNode;</span>
<a href="#l6.235"></a><span id="l6.235" class="difflineplus">+        }</span>
<a href="#l6.236"></a><span id="l6.236" class="difflineplus">+        </span>
<a href="#l6.237"></a><span id="l6.237" class="difflineplus">+        // -- Type Facet</span>
<a href="#l6.238"></a><span id="l6.238" class="difflineplus">+        if (widgetNode == this._facetTypeNode) {</span>
<a href="#l6.239"></a><span id="l6.239" class="difflineplus">+        </span>
<a href="#l6.240"></a><span id="l6.240" class="difflineplus">+        }</span>
<a href="#l6.241"></a><span id="l6.241" class="difflineplus">+        // -- Location Facet</span>
<a href="#l6.242"></a><span id="l6.242" class="difflineplus">+        else if (widgetNode == this._facetLocationNode) {</span>
<a href="#l6.243"></a><span id="l6.243" class="difflineplus">+          if (event.originalTarget._folder) {</span>
<a href="#l6.244"></a><span id="l6.244" class="difflineplus">+            let folder = event.originalTarget._folder;</span>
<a href="#l6.245"></a><span id="l6.245" class="difflineplus">+            this._currentFolderNode.label =</span>
<a href="#l6.246"></a><span id="l6.246" class="difflineplus">+              [node._folder.prettiestName</span>
<a href="#l6.247"></a><span id="l6.247" class="difflineplus">+               for each ([, node] in Iterator(nodes))</span>
<a href="#l6.248"></a><span id="l6.248" class="difflineplus">+               if (node._folder)].join(&quot;/&quot;);</span>
<a href="#l6.249"></a><span id="l6.249" class="difflineplus">+            this._currentFolderNode.hidden = false;</span>
<a href="#l6.250"></a><span id="l6.250" class="difflineplus">+            this._facetLocationNode.selectedItem = this._currentFolderNode;</span>
<a href="#l6.251"></a><span id="l6.251" class="difflineplus">+          }</span>
<a href="#l6.252"></a><span id="l6.252" class="difflineplus">+        }</span>
<a href="#l6.253"></a><span id="l6.253" class="difflineplus">+        </span>
<a href="#l6.254"></a><span id="l6.254" class="difflineplus">+        dump(&quot;Selected folder: &quot; + event.originalTarget._folder + &quot;\n&quot;);</span>
<a href="#l6.255"></a><span id="l6.255" class="difflineplus">+        dump(&quot;event: &quot; + event + &quot;\n&quot;);</span>
<a href="#l6.256"></a><span id="l6.256" class="difflineplus">+        dump(&quot;target: &quot; + event.originalTarget + &quot;\n&quot;);</span>
<a href="#l6.257"></a><span id="l6.257" class="difflineplus">+        dump(&quot;event target id: &quot; + event.originalTarget.id + &quot;\n&quot;);</span>
<a href="#l6.258"></a><span id="l6.258" class="difflineplus">+        dump(&quot;event tag: &quot; + event.originalTarget.tagName + &quot;\n&quot;);</span>
<a href="#l6.259"></a><span id="l6.259" class="difflineplus">+      ]]&gt;&lt;/handler&gt;</span>
<a href="#l6.260"></a><span id="l6.260" class="difflineplus">+    &lt;/handlers&gt;</span>
<a href="#l6.261"></a><span id="l6.261" class="difflineplus">+    </span>
<a href="#l6.262"></a><span id="l6.262" class="difflineplus">+  &lt;/binding&gt;</span>
<a href="#l6.263"></a><span id="l6.263" class="difflineplus">+</span>
<a href="#l6.264"></a><span id="l6.264" class="difflineplus">+</span>
<a href="#l6.265"></a><span id="l6.265">   &lt;binding id=&quot;searchbar&quot; extends=&quot;chrome://global/content/bindings/textbox.xml#timed-textbox&quot;&gt;</span>
<a href="#l6.266"></a><span id="l6.266">     &lt;resources&gt;</span>
<a href="#l6.267"></a><span id="l6.267">       &lt;stylesheet src=&quot;chrome://messenger/skin/searchBox.css&quot;/&gt;</span>
<a href="#l6.268"></a><span id="l6.268">     &lt;/resources&gt;</span>
<a href="#l6.269"></a><span id="l6.269">     &lt;content&gt; </span>
<a href="#l6.270"></a><span id="l6.270">       &lt;children/&gt;</span>
<a href="#l6.271"></a><span id="l6.271">       &lt;xul:hbox class=&quot;quick-search-textbox textbox-input-box&quot; flex=&quot;1&quot;&gt;</span>
<a href="#l6.272"></a><span id="l6.272">         &lt;html:input class=&quot;textbox-input&quot; flex=&quot;1&quot; anonid=&quot;input&quot; allowevents=&quot;true&quot;</span>
<a href="#l6.273"></a><span id="l6.273" class="difflineat">@@ -190,19 +363,20 @@</span>
<a href="#l6.274"></a><span id="l6.274">             nextMenuItem.setAttribute('checked', 'true');</span>
<a href="#l6.275"></a><span id="l6.275">             menuPopup.setAttribute('value', this.searchMode);</span>
<a href="#l6.276"></a><span id="l6.276">           }</span>
<a href="#l6.277"></a><span id="l6.277">         ]]&gt;&lt;/handler&gt;</span>
<a href="#l6.278"></a><span id="l6.278"> </span>
<a href="#l6.279"></a><span id="l6.279">         &lt;handler event=&quot;keypress&quot; keycode=&quot;VK_DOWN&quot; modifiers=&quot;alt&quot; phase=&quot;capturing&quot; action=&quot;return this.openmenupopup();&quot;/&gt;</span>
<a href="#l6.280"></a><span id="l6.280">         &lt;handler event=&quot;keypress&quot; keycode=&quot;VK_UP&quot;   modifiers=&quot;alt&quot; phase=&quot;capturing&quot; action=&quot;return this.openmenupopup();&quot;/&gt;</span>
<a href="#l6.281"></a><span id="l6.281"> </span>
<a href="#l6.282"></a><span id="l6.282" class="difflineminus">-#ifndef XP_MACOSX</span>
<a href="#l6.283"></a><span id="l6.283" class="difflineminus">-      &lt;handler event=&quot;keypress&quot; keycode=&quot;VK_F4&quot; phase=&quot;capturing&quot; action=&quot;return this.openmenupopup();&quot;/&gt;</span>
<a href="#l6.284"></a><span id="l6.284" class="difflineminus">-#endif</span>
<a href="#l6.285"></a><span id="l6.285" class="difflineplus">+      &lt;handler event=&quot;keypress&quot; keycode=&quot;VK_F4&quot; phase=&quot;capturing&quot;&gt;&lt;![CDATA[</span>
<a href="#l6.286"></a><span id="l6.286" class="difflineplus">+        if (window.navigator.oscpu.substring(0, 3).toLowerCase() != &quot;mac&quot;)</span>
<a href="#l6.287"></a><span id="l6.287" class="difflineplus">+          return this.openmenupopup();</span>
<a href="#l6.288"></a><span id="l6.288" class="difflineplus">+      ]]&gt;&lt;/handler&gt;</span>
<a href="#l6.289"></a><span id="l6.289"> </span>
<a href="#l6.290"></a><span id="l6.290">       &lt;handler event=&quot;dragdrop&quot; phase=&quot;capturing&quot;&gt;</span>
<a href="#l6.291"></a><span id="l6.291">         nsDragAndDrop.drop(event, this.searchInputDNDObserver);</span>
<a href="#l6.292"></a><span id="l6.292">       &lt;/handler&gt;</span>
<a href="#l6.293"></a><span id="l6.293">     &lt;/handlers&gt;</span>
<a href="#l6.294"></a><span id="l6.294">   &lt;/binding&gt;</span>
<a href="#l6.295"></a><span id="l6.295">   </span>
<a href="#l6.296"></a><span id="l6.296">   &lt;binding id=&quot;searchBarDropMarker&quot;&gt;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mail/locales/en-US/chrome/messenger/messenger.dtd</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mail/locales/en-US/chrome/messenger/messenger.dtd</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -617,16 +617,21 @@ you can use these alternative items. Oth</span>
<a href="#l7.4"></a><span id="l7.4"> &lt;!ENTITY starredColumn.label &quot;Starred&quot;&gt;</span>
<a href="#l7.5"></a><span id="l7.5"> &lt;!ENTITY locationColumn.label &quot;Location&quot;&gt;</span>
<a href="#l7.6"></a><span id="l7.6"> &lt;!ENTITY idColumn.label &quot;Order Received&quot;&gt;</span>
<a href="#l7.7"></a><span id="l7.7"> &lt;!ENTITY attachmentColumn.label &quot;Attachments&quot;&gt;</span>
<a href="#l7.8"></a><span id="l7.8"> &lt;!-- LOCALIZATION NOTE (glodaWhyColumn.label): explains why a message is</span>
<a href="#l7.9"></a><span id="l7.9">      present in the gloda search results.  The values can be found in</span>
<a href="#l7.10"></a><span id="l7.10">      messenger.properties with a prefix of &quot;glodaSearch_results_why_&quot;. --&gt;</span>
<a href="#l7.11"></a><span id="l7.11"> &lt;!ENTITY glodaWhyColumn.label &quot;Why&quot;&gt;</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineplus">+&lt;!-- LOCALIZATION NOTE (glodaScoreColumn.label): provides the numerical</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+     score assigned to the message as a result of the search.  The column</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+     primarily exists to be sorted by, and its contents will probably have</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+     little meaning for most users. --&gt;</span>
<a href="#l7.16"></a><span id="l7.16" class="difflineplus">+&lt;!ENTITY glodaScoreColumn.label &quot;Score&quot;&gt;</span>
<a href="#l7.17"></a><span id="l7.17"> </span>
<a href="#l7.18"></a><span id="l7.18"> &lt;!-- Thread Pane Tooltips --&gt;</span>
<a href="#l7.19"></a><span id="l7.19"> &lt;!ENTITY columnChooser.tooltip &quot;Click to select columns to display&quot;&gt;</span>
<a href="#l7.20"></a><span id="l7.20"> &lt;!ENTITY threadColumn.tooltip &quot;Click to display message threads&quot;&gt;</span>
<a href="#l7.21"></a><span id="l7.21"> &lt;!ENTITY fromColumn.tooltip &quot;Click to sort by from&quot;&gt;</span>
<a href="#l7.22"></a><span id="l7.22"> &lt;!ENTITY recipientColumn.tooltip &quot;Click to sort by recipient&quot;&gt;</span>
<a href="#l7.23"></a><span id="l7.23"> &lt;!ENTITY subjectColumn.tooltip &quot;Click to sort by subject&quot;&gt;</span>
<a href="#l7.24"></a><span id="l7.24"> &lt;!ENTITY dateColumn.tooltip &quot;Click to sort by date&quot;&gt;</span>
<a href="#l7.25"></a><span id="l7.25" class="difflineat">@@ -640,16 +645,17 @@ you can use these alternative items. Oth</span>
<a href="#l7.26"></a><span id="l7.26"> &lt;!ENTITY totalColumn.tooltip &quot;Total number of messages in thread&quot;&gt;</span>
<a href="#l7.27"></a><span id="l7.27"> &lt;!ENTITY readColumn.tooltip &quot;Click to sort by read&quot;&gt;</span>
<a href="#l7.28"></a><span id="l7.28"> &lt;!ENTITY receivedColumn.tooltip &quot;Click to sort by date received&quot;&gt;</span>
<a href="#l7.29"></a><span id="l7.29"> &lt;!ENTITY starredColumn.tooltip &quot;Click to sort by star&quot;&gt;</span>
<a href="#l7.30"></a><span id="l7.30"> &lt;!ENTITY locationColumn.tooltip &quot;Click to sort by location&quot;&gt;</span>
<a href="#l7.31"></a><span id="l7.31"> &lt;!ENTITY idColumn.tooltip &quot;Click to sort by order received&quot;&gt;</span>
<a href="#l7.32"></a><span id="l7.32"> &lt;!ENTITY attachmentColumn.tooltip &quot;Click to sort by attachments&quot;&gt;</span>
<a href="#l7.33"></a><span id="l7.33"> &lt;!ENTITY glodaWhyColumn.tooltip &quot;Click to sort by why the message is in your search results&quot;&gt;</span>
<a href="#l7.34"></a><span id="l7.34" class="difflineplus">+&lt;!ENTITY glodaScoreColumn.tooltip &quot;Click to sort by the search score&quot;&gt;</span>
<a href="#l7.35"></a><span id="l7.35"> </span>
<a href="#l7.36"></a><span id="l7.36"> &lt;!-- Thread Pane Context Menu --&gt;</span>
<a href="#l7.37"></a><span id="l7.37"> &lt;!ENTITY contextOpenNewWindow.label &quot;Open Message in New Window&quot;&gt;</span>
<a href="#l7.38"></a><span id="l7.38"> &lt;!ENTITY contextOpenNewWindow.accesskey &quot;W&quot;&gt;</span>
<a href="#l7.39"></a><span id="l7.39"> &lt;!ENTITY contextOpenNewTab.label &quot;Open Message in New Tab&quot;&gt;</span>
<a href="#l7.40"></a><span id="l7.40"> &lt;!ENTITY contextOpenNewTab.accesskey &quot;T&quot;&gt;</span>
<a href="#l7.41"></a><span id="l7.41"> &lt;!ENTITY contextEditAsNew.label &quot;Edit As New…&quot;&gt;</span>
<a href="#l7.42"></a><span id="l7.42"> &lt;!ENTITY contextEditAsNew.accesskey &quot;E&quot;&gt;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mail/locales/en-US/chrome/messenger/search.properties</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mail/locales/en-US/chrome/messenger/search.properties</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -16,8 +16,12 @@ searchSuccessMessages=%S matches found</span>
<a href="#l8.4"></a><span id="l8.4"> searchFailureMessage=No matches found</span>
<a href="#l8.5"></a><span id="l8.5"> labelForStopButton=Stop</span>
<a href="#l8.6"></a><span id="l8.6"> labelForSearchButton=Search</span>
<a href="#l8.7"></a><span id="l8.7"> labelForStopButton.accesskey=S</span>
<a href="#l8.8"></a><span id="l8.8"> labelForSearchButton.accesskey=S</span>
<a href="#l8.9"></a><span id="l8.9"> </span>
<a href="#l8.10"></a><span id="l8.10"> moreButtonTooltipText=Add a new rule</span>
<a href="#l8.11"></a><span id="l8.11"> lessButtonTooltipText=Remove this rule</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+# LOCALIZATION NOTE (glodaSearchTabTitle): The title to use for global database</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+#  search tabs.  Include &quot;%S&quot; where you want the search string to be inserted.</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+glodaSearchTabTitle=Search: %S</span>
<a href="#l8.16"></a><span id="l8.16">\ No newline at end of file</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/base/src/searchSpec.js</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/base/src/searchSpec.js</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -124,38 +124,56 @@ SearchSpec.prototype = {</span>
<a href="#l9.4"></a><span id="l9.4">    *  need to make sure that the session listener gets added after the DBView</span>
<a href="#l9.5"></a><span id="l9.5">    *  caused us to introduce this method.  (We want the DB View's OnDone method</span>
<a href="#l9.6"></a><span id="l9.6">    *  to run before our listener, as it may do important work.)</span>
<a href="#l9.7"></a><span id="l9.7">    */</span>
<a href="#l9.8"></a><span id="l9.8">   associateView: function SearchSpec_associateView(aDBView) {</span>
<a href="#l9.9"></a><span id="l9.9">     if (this.hasSearchTerms) {</span>
<a href="#l9.10"></a><span id="l9.10">       this.updateSession();</span>
<a href="#l9.11"></a><span id="l9.11"> </span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-      if (!this._sessionListener)</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineminus">-        this._sessionListener = new SearchSpecListener(this);</span>
<a href="#l9.14"></a><span id="l9.14" class="difflineplus">+      if (this.owner.isSynthetic) {</span>
<a href="#l9.15"></a><span id="l9.15" class="difflineplus">+        this.owner._syntheticView.search(new FilteringSyntheticListener(this));</span>
<a href="#l9.16"></a><span id="l9.16" class="difflineplus">+      }</span>
<a href="#l9.17"></a><span id="l9.17" class="difflineplus">+      else {</span>
<a href="#l9.18"></a><span id="l9.18" class="difflineplus">+        if (!this._sessionListener)</span>
<a href="#l9.19"></a><span id="l9.19" class="difflineplus">+          this._sessionListener = new SearchSpecListener(this);</span>
<a href="#l9.20"></a><span id="l9.20" class="difflineplus">+</span>
<a href="#l9.21"></a><span id="l9.21" class="difflineplus">+        this.session.registerListener(aDBView);</span>
<a href="#l9.22"></a><span id="l9.22" class="difflineplus">+        aDBView.searchSession = this._session;</span>
<a href="#l9.23"></a><span id="l9.23" class="difflineplus">+        this._session.registerListener(this._sessionListener);</span>
<a href="#l9.24"></a><span id="l9.24" class="difflineplus">+        this._listenersRegistered = true;</span>
<a href="#l9.25"></a><span id="l9.25"> </span>
<a href="#l9.26"></a><span id="l9.26" class="difflineminus">-      this.session.registerListener(aDBView);</span>
<a href="#l9.27"></a><span id="l9.27" class="difflineminus">-      aDBView.searchSession = this._session;</span>
<a href="#l9.28"></a><span id="l9.28" class="difflineminus">-      this._session.registerListener(this._sessionListener);</span>
<a href="#l9.29"></a><span id="l9.29" class="difflineminus">-      this._listenersRegistered = true;</span>
<a href="#l9.30"></a><span id="l9.30" class="difflineminus">-</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineminus">-      this.owner.searching = true;</span>
<a href="#l9.32"></a><span id="l9.32" class="difflineminus">-      this.session.search(this.owner.listener.msgWindow);</span>
<a href="#l9.33"></a><span id="l9.33" class="difflineplus">+        this.owner.searching = true;</span>
<a href="#l9.34"></a><span id="l9.34" class="difflineplus">+        this.session.search(this.owner.listener.msgWindow);</span>
<a href="#l9.35"></a><span id="l9.35" class="difflineplus">+      }</span>
<a href="#l9.36"></a><span id="l9.36" class="difflineplus">+    }</span>
<a href="#l9.37"></a><span id="l9.37" class="difflineplus">+    // if it's synthetic but we have no search terms, hook the output of the</span>
<a href="#l9.38"></a><span id="l9.38" class="difflineplus">+    //  synthetic view directly up to the search nsIMsgDBView</span>
<a href="#l9.39"></a><span id="l9.39" class="difflineplus">+    else if (this.owner.isSynthetic) {</span>
<a href="#l9.40"></a><span id="l9.40" class="difflineplus">+      let owner = this.owner;</span>
<a href="#l9.41"></a><span id="l9.41" class="difflineplus">+      owner.searching = true;</span>
<a href="#l9.42"></a><span id="l9.42" class="difflineplus">+      this.owner._syntheticView.search(</span>
<a href="#l9.43"></a><span id="l9.43" class="difflineplus">+        aDBView.QueryInterface(Ci.nsIMsgSearchNotify),</span>
<a href="#l9.44"></a><span id="l9.44" class="difflineplus">+        function() { owner.searching = false; });</span>
<a href="#l9.45"></a><span id="l9.45">     }</span>
<a href="#l9.46"></a><span id="l9.46">   },</span>
<a href="#l9.47"></a><span id="l9.47">   /**</span>
<a href="#l9.48"></a><span id="l9.48">    * Stop any active search and stop the db view being a search listener (if it</span>
<a href="#l9.49"></a><span id="l9.49">    *  is one).</span>
<a href="#l9.50"></a><span id="l9.50">    */</span>
<a href="#l9.51"></a><span id="l9.51">   dissociateView: function SearchSpec_dissociateView(aDBView) {</span>
<a href="#l9.52"></a><span id="l9.52">     // If we are currently searching, interrupt the search.  This will</span>
<a href="#l9.53"></a><span id="l9.53">     //  immediately notify the listeners that the search is done with and</span>
<a href="#l9.54"></a><span id="l9.54">     //  clear the searching flag for us.</span>
<a href="#l9.55"></a><span id="l9.55" class="difflineminus">-    if (this.owner.searching)</span>
<a href="#l9.56"></a><span id="l9.56" class="difflineminus">-      this.session.interruptSearch();</span>
<a href="#l9.57"></a><span id="l9.57" class="difflineplus">+    if (this.owner.searching) {</span>
<a href="#l9.58"></a><span id="l9.58" class="difflineplus">+      if (this.owner.isSynthetic)</span>
<a href="#l9.59"></a><span id="l9.59" class="difflineplus">+        this.owner._syntheticView.abortSearch();</span>
<a href="#l9.60"></a><span id="l9.60" class="difflineplus">+      else</span>
<a href="#l9.61"></a><span id="l9.61" class="difflineplus">+        this.session.interruptSearch();</span>
<a href="#l9.62"></a><span id="l9.62" class="difflineplus">+    }</span>
<a href="#l9.63"></a><span id="l9.63"> </span>
<a href="#l9.64"></a><span id="l9.64">     if (this._listenersRegistered) {</span>
<a href="#l9.65"></a><span id="l9.65">       this._session.unregisterListener(this._sessionListener);</span>
<a href="#l9.66"></a><span id="l9.66">       this._session.unregisterListener(aDBView);</span>
<a href="#l9.67"></a><span id="l9.67">       aDBView.searchSession = null;</span>
<a href="#l9.68"></a><span id="l9.68">       this._listenersRegistered = false;</span>
<a href="#l9.69"></a><span id="l9.69">     }</span>
<a href="#l9.70"></a><span id="l9.70">   },</span>
<a href="#l9.71"></a><span id="l9.71" class="difflineat">@@ -346,16 +364,25 @@ SearchSpec.prototype = {</span>
<a href="#l9.72"></a><span id="l9.72">                                         nsIMsgSearchTerm)) {</span>
<a href="#l9.73"></a><span id="l9.73">         if (term.attrib == nsMsgSearchAttrib.Body)</span>
<a href="#l9.74"></a><span id="l9.74">           haveBodyTerm = true;</span>
<a href="#l9.75"></a><span id="l9.75">         session.appendTerm(term);</span>
<a href="#l9.76"></a><span id="l9.76">       }</span>
<a href="#l9.77"></a><span id="l9.77">     }</span>
<a href="#l9.78"></a><span id="l9.78"> </span>
<a href="#l9.79"></a><span id="l9.79">     // -- apply scopes</span>
<a href="#l9.80"></a><span id="l9.80" class="difflineplus">+    // If it is a synthetic view, create a single bogus scope so that we can use</span>
<a href="#l9.81"></a><span id="l9.81" class="difflineplus">+    //  MatchHdr.</span>
<a href="#l9.82"></a><span id="l9.82" class="difflineplus">+    if (this.owner.isSynthetic) {</span>
<a href="#l9.83"></a><span id="l9.83" class="difflineplus">+      // We don't want to pass in a folder, and we don't want to use the</span>
<a href="#l9.84"></a><span id="l9.84" class="difflineplus">+      //  allSearchableGroups scope, so we cheat and use AddDirectoryScopeTerm.</span>
<a href="#l9.85"></a><span id="l9.85" class="difflineplus">+      session.addDirectoryScopeTerm(nsMsgSearchScope.offlineMail);</span>
<a href="#l9.86"></a><span id="l9.86" class="difflineplus">+      return;</span>
<a href="#l9.87"></a><span id="l9.87" class="difflineplus">+    }</span>
<a href="#l9.88"></a><span id="l9.88" class="difflineplus">+</span>
<a href="#l9.89"></a><span id="l9.89">     // We are filtering if we have mail view terms or user terms.  When</span>
<a href="#l9.90"></a><span id="l9.90">     //  filtering, we bias towards offline search.  The only time we would use</span>
<a href="#l9.91"></a><span id="l9.91">     //  an online search when filtering is if one of the constraints uses the</span>
<a href="#l9.92"></a><span id="l9.92">     //  body attribute and the folder is not marked for offline access.</span>
<a href="#l9.93"></a><span id="l9.93">     // We are not filtering if we only have virtual folder terms, in which case</span>
<a href="#l9.94"></a><span id="l9.94">     //  we honor the onlineSearch attribute.  This means that we use the</span>
<a href="#l9.95"></a><span id="l9.95">     //  folder's server's searchScope if the folder is not explicitly marked</span>
<a href="#l9.96"></a><span id="l9.96">     //  offline.</span>
<a href="#l9.97"></a><span id="l9.97" class="difflineat">@@ -482,9 +509,41 @@ SearchSpecListener.prototype = {</span>
<a href="#l9.98"></a><span id="l9.98">     viewWrapper.searching = false;</span>
<a href="#l9.99"></a><span id="l9.99">     // If we were not interrupted, it's okay to notify listeners that messages</span>
<a href="#l9.100"></a><span id="l9.100">     //  were loaded.  If we were interrupted, no one wants to know; we are</span>
<a href="#l9.101"></a><span id="l9.101">     //  only interrupted when we ourselves are dissociating a view.  In that</span>
<a href="#l9.102"></a><span id="l9.102">     //  case, there is no view to refer to, so it doesn't make sense to notify.</span>
<a href="#l9.103"></a><span id="l9.103">     if (aStatus != NS_MSG_SEARCH_INTERRUPTED)</span>
<a href="#l9.104"></a><span id="l9.104">       viewWrapper.listener.onAllMessagesLoaded();</span>
<a href="#l9.105"></a><span id="l9.105">   },</span>
<a href="#l9.106"></a><span id="l9.106" class="difflineminus">-};</span>
<a href="#l9.107"></a><span id="l9.107">\ No newline at end of file</span>
<a href="#l9.108"></a><span id="l9.108" class="difflineplus">+};</span>
<a href="#l9.109"></a><span id="l9.109" class="difflineplus">+</span>
<a href="#l9.110"></a><span id="l9.110" class="difflineplus">+/**</span>
<a href="#l9.111"></a><span id="l9.111" class="difflineplus">+ * Pretend to implement the nsIMsgSearchNotify interface, checking all matches</span>
<a href="#l9.112"></a><span id="l9.112" class="difflineplus">+ *  we are given against the search session on the search spec.  If they pass,</span>
<a href="#l9.113"></a><span id="l9.113" class="difflineplus">+ *  relay them to the underlying db view, otherwise quietly eat them.</span>
<a href="#l9.114"></a><span id="l9.114" class="difflineplus">+ * This is what allows us to use mail-views and quick searches against</span>
<a href="#l9.115"></a><span id="l9.115" class="difflineplus">+ *  gloda-backed searches.</span>
<a href="#l9.116"></a><span id="l9.116" class="difflineplus">+ */</span>
<a href="#l9.117"></a><span id="l9.117" class="difflineplus">+function FilteringSyntheticListener(aSearchSpec) {</span>
<a href="#l9.118"></a><span id="l9.118" class="difflineplus">+  this.searchSpec = aSearchSpec;</span>
<a href="#l9.119"></a><span id="l9.119" class="difflineplus">+  this.session = this.searchSpec.session;</span>
<a href="#l9.120"></a><span id="l9.120" class="difflineplus">+  this.dbView =</span>
<a href="#l9.121"></a><span id="l9.121" class="difflineplus">+    this.searchSpec.owner.dbView.QueryInterface(Ci.nsIMsgSearchNotify);</span>
<a href="#l9.122"></a><span id="l9.122" class="difflineplus">+}</span>
<a href="#l9.123"></a><span id="l9.123" class="difflineplus">+FilteringSyntheticListener.prototype = {</span>
<a href="#l9.124"></a><span id="l9.124" class="difflineplus">+  onNewSearch: function FilteringSyntheticListener_onNewSearch() {</span>
<a href="#l9.125"></a><span id="l9.125" class="difflineplus">+    this.searchSpec.owner.searching = true;</span>
<a href="#l9.126"></a><span id="l9.126" class="difflineplus">+    this.dbView.onNewSearch();</span>
<a href="#l9.127"></a><span id="l9.127" class="difflineplus">+  },</span>
<a href="#l9.128"></a><span id="l9.128" class="difflineplus">+  onSearchHit:</span>
<a href="#l9.129"></a><span id="l9.129" class="difflineplus">+      function FilteringSyntheticListener_onSearchHit(aMsgHdr, aFolder) {</span>
<a href="#l9.130"></a><span id="l9.130" class="difflineplus">+    // We don't need to worry about msgDatabase opening the database.</span>
<a href="#l9.131"></a><span id="l9.131" class="difflineplus">+    // It is (obviously) already open, and presumably gloda is already on the</span>
<a href="#l9.132"></a><span id="l9.132" class="difflineplus">+    //  hook to perform the cleanup (assuming gloda is backing this search).</span>
<a href="#l9.133"></a><span id="l9.133" class="difflineplus">+    if (this.session.MatchHdr(aMsgHdr, aFolder.msgDatabase))</span>
<a href="#l9.134"></a><span id="l9.134" class="difflineplus">+      this.dbView.onSearchHit(aMsgHdr, aFolder);</span>
<a href="#l9.135"></a><span id="l9.135" class="difflineplus">+  },</span>
<a href="#l9.136"></a><span id="l9.136" class="difflineplus">+  onSearchDone: function FilteringSyntheticListener_OnSearchDone(aStatus) {</span>
<a href="#l9.137"></a><span id="l9.137" class="difflineplus">+    this.searchSpec.owner.searching = false;</span>
<a href="#l9.138"></a><span id="l9.138" class="difflineplus">+    this.dbView.onSearchDone(aStatus);</span>
<a href="#l9.139"></a><span id="l9.139" class="difflineplus">+  }</span>
<a href="#l9.140"></a><span id="l9.140" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/db/gloda/modules/collection.js</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/collection.js</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -1,16 +1,16 @@</span>
<a href="#l10.4"></a><span id="l10.4"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l10.5"></a><span id="l10.5">  *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l10.6"></a><span id="l10.6">  *</span>
<a href="#l10.7"></a><span id="l10.7">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l10.8"></a><span id="l10.8">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l10.9"></a><span id="l10.9">  * the License. You may obtain a copy of the License at</span>
<a href="#l10.10"></a><span id="l10.10">  * http://www.mozilla.org/MPL/</span>
<a href="#l10.11"></a><span id="l10.11" class="difflineminus">- * </span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+ *</span>
<a href="#l10.13"></a><span id="l10.13">  * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l10.14"></a><span id="l10.14">  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l10.15"></a><span id="l10.15">  * for the specific language governing rights and limitations under the</span>
<a href="#l10.16"></a><span id="l10.16">  * License.</span>
<a href="#l10.17"></a><span id="l10.17">  *</span>
<a href="#l10.18"></a><span id="l10.18">  * The Original Code is Thunderbird Global Database.</span>
<a href="#l10.19"></a><span id="l10.19">  *</span>
<a href="#l10.20"></a><span id="l10.20">  * The Initial Developer of the Original Code is</span>
<a href="#l10.21"></a><span id="l10.21" class="difflineat">@@ -27,32 +27,32 @@</span>
<a href="#l10.22"></a><span id="l10.22">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l10.23"></a><span id="l10.23">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l10.24"></a><span id="l10.24">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l10.25"></a><span id="l10.25">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l10.26"></a><span id="l10.26">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l10.27"></a><span id="l10.27">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l10.28"></a><span id="l10.28">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l10.29"></a><span id="l10.29">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l10.30"></a><span id="l10.30" class="difflineminus">- * </span>
<a href="#l10.31"></a><span id="l10.31" class="difflineplus">+ *</span>
<a href="#l10.32"></a><span id="l10.32">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l10.33"></a><span id="l10.33"> </span>
<a href="#l10.34"></a><span id="l10.34"> EXPORTED_SYMBOLS = ['GlodaCollection', 'GlodaCollectionManager'];</span>
<a href="#l10.35"></a><span id="l10.35"> </span>
<a href="#l10.36"></a><span id="l10.36"> const Cc = Components.classes;</span>
<a href="#l10.37"></a><span id="l10.37"> const Ci = Components.interfaces;</span>
<a href="#l10.38"></a><span id="l10.38"> const Cr = Components.results;</span>
<a href="#l10.39"></a><span id="l10.39"> const Cu = Components.utils;</span>
<a href="#l10.40"></a><span id="l10.40"> </span>
<a href="#l10.41"></a><span id="l10.41"> Cu.import(&quot;resource://app/modules/gloda/log4moz.js&quot;);</span>
<a href="#l10.42"></a><span id="l10.42"> </span>
<a href="#l10.43"></a><span id="l10.43"> const LOG = Log4Moz.repository.getLogger(&quot;gloda.collection&quot;);</span>
<a href="#l10.44"></a><span id="l10.44"> </span>
<a href="#l10.45"></a><span id="l10.45"> /**</span>
<a href="#l10.46"></a><span id="l10.46" class="difflineminus">- * @namespace Central registry and logic for all collections. </span>
<a href="#l10.47"></a><span id="l10.47" class="difflineplus">+ * @namespace Central registry and logic for all collections.</span>
<a href="#l10.48"></a><span id="l10.48">  *</span>
<a href="#l10.49"></a><span id="l10.49">  * The collection manager is a singleton that has the following tasks:</span>
<a href="#l10.50"></a><span id="l10.50">  * - Let views of objects (nouns) know when their objects have changed.  For</span>
<a href="#l10.51"></a><span id="l10.51">  *   example, an attribute has changed due to user action.</span>
<a href="#l10.52"></a><span id="l10.52">  * - Let views of objects based on queries know when new objects match their</span>
<a href="#l10.53"></a><span id="l10.53">  *   query, or when their existing objects no longer match due to changes.</span>
<a href="#l10.54"></a><span id="l10.54">  * - Caching/object-identity maintenance.  It is ideal if we only ever have</span>
<a href="#l10.55"></a><span id="l10.55">  *   one instance of an object at a time.  (More specifically, only one instance</span>
<a href="#l10.56"></a><span id="l10.56" class="difflineat">@@ -77,79 +77,79 @@ var GlodaCollectionManager = {</span>
<a href="#l10.57"></a><span id="l10.57">     else {</span>
<a href="#l10.58"></a><span id="l10.58">       // purge dead weak references while we're at it</span>
<a href="#l10.59"></a><span id="l10.59">       collections = this._collectionsByNoun[nounID].filter(function (aRef) {</span>
<a href="#l10.60"></a><span id="l10.60">         return aRef.get(); });</span>
<a href="#l10.61"></a><span id="l10.61">       this._collectionsByNoun[nounID] = collections;</span>
<a href="#l10.62"></a><span id="l10.62">     }</span>
<a href="#l10.63"></a><span id="l10.63">     collections.push(Cu.getWeakReference(aCollection));</span>
<a href="#l10.64"></a><span id="l10.64">   },</span>
<a href="#l10.65"></a><span id="l10.65" class="difflineminus">-  </span>
<a href="#l10.66"></a><span id="l10.66" class="difflineplus">+</span>
<a href="#l10.67"></a><span id="l10.67">   getCollectionsForNounID: function gloda_colm_getCollectionsForNounID(aNounID){</span>
<a href="#l10.68"></a><span id="l10.68">     if (!(aNounID in this._collectionsByNoun))</span>
<a href="#l10.69"></a><span id="l10.69">       return [];</span>
<a href="#l10.70"></a><span id="l10.70" class="difflineminus">-    </span>
<a href="#l10.71"></a><span id="l10.71" class="difflineplus">+</span>
<a href="#l10.72"></a><span id="l10.72">     // generator would be nice, but I suspect get() is too expensive to use</span>
<a href="#l10.73"></a><span id="l10.73">     //  twice (guard/predicate and value)</span>
<a href="#l10.74"></a><span id="l10.74">     let weakCollections = this._collectionsByNoun[aNounID];</span>
<a href="#l10.75"></a><span id="l10.75">     let collections = [];</span>
<a href="#l10.76"></a><span id="l10.76">     for (let iColl = 0; iColl &lt; weakCollections.length; iColl++) {</span>
<a href="#l10.77"></a><span id="l10.77">       let collection = weakCollections[iColl].get();</span>
<a href="#l10.78"></a><span id="l10.78">       if (collection)</span>
<a href="#l10.79"></a><span id="l10.79">         collections.push(collection);</span>
<a href="#l10.80"></a><span id="l10.80">     }</span>
<a href="#l10.81"></a><span id="l10.81">     return collections;</span>
<a href="#l10.82"></a><span id="l10.82">   },</span>
<a href="#l10.83"></a><span id="l10.83" class="difflineminus">-  </span>
<a href="#l10.84"></a><span id="l10.84" class="difflineplus">+</span>
<a href="#l10.85"></a><span id="l10.85">   defineCache: function gloda_colm_defineCache(aNounDef, aCacheSize) {</span>
<a href="#l10.86"></a><span id="l10.86">     this._cachesByNoun[aNounDef.id] = new GlodaLRUCacheCollection(aNounDef,</span>
<a href="#l10.87"></a><span id="l10.87">                                                                    aCacheSize);</span>
<a href="#l10.88"></a><span id="l10.88">   },</span>
<a href="#l10.89"></a><span id="l10.89" class="difflineminus">-  </span>
<a href="#l10.90"></a><span id="l10.90" class="difflineplus">+</span>
<a href="#l10.91"></a><span id="l10.91">   /**</span>
<a href="#l10.92"></a><span id="l10.92">    * Attempt to locate an instance of the object of the given noun type with the</span>
<a href="#l10.93"></a><span id="l10.93">    *  given id.  Counts as a cache hit if found.  (And if it was't in a cache,</span>
<a href="#l10.94"></a><span id="l10.94">    *  but rather a collection, it is added to the cache.)</span>
<a href="#l10.95"></a><span id="l10.95">    */</span>
<a href="#l10.96"></a><span id="l10.96">   cacheLookupOne: function gloda_colm_cacheLookupOne(aNounID, aID, aDoCache) {</span>
<a href="#l10.97"></a><span id="l10.97">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l10.98"></a><span id="l10.98" class="difflineminus">-    </span>
<a href="#l10.99"></a><span id="l10.99" class="difflineplus">+</span>
<a href="#l10.100"></a><span id="l10.100">     if (cache) {</span>
<a href="#l10.101"></a><span id="l10.101">       if (aID in cache._idMap) {</span>
<a href="#l10.102"></a><span id="l10.102">         let item = cache._idMap[aID];</span>
<a href="#l10.103"></a><span id="l10.103">         return cache.hit(item);</span>
<a href="#l10.104"></a><span id="l10.104">       }</span>
<a href="#l10.105"></a><span id="l10.105">     }</span>
<a href="#l10.106"></a><span id="l10.106" class="difflineminus">-    </span>
<a href="#l10.107"></a><span id="l10.107" class="difflineplus">+</span>
<a href="#l10.108"></a><span id="l10.108">     if (aDoCache === false)</span>
<a href="#l10.109"></a><span id="l10.109">       cache = null;</span>
<a href="#l10.110"></a><span id="l10.110" class="difflineminus">-  </span>
<a href="#l10.111"></a><span id="l10.111" class="difflineplus">+</span>
<a href="#l10.112"></a><span id="l10.112">     for each (let [iCollection, collection] in</span>
<a href="#l10.113"></a><span id="l10.113">               Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l10.114"></a><span id="l10.114">       if (aID in collection._idMap) {</span>
<a href="#l10.115"></a><span id="l10.115">         let item = collection._idMap[aID];</span>
<a href="#l10.116"></a><span id="l10.116">         if (cache)</span>
<a href="#l10.117"></a><span id="l10.117">           cache.add([item]);</span>
<a href="#l10.118"></a><span id="l10.118">         return item;</span>
<a href="#l10.119"></a><span id="l10.119">       }</span>
<a href="#l10.120"></a><span id="l10.120">     }</span>
<a href="#l10.121"></a><span id="l10.121" class="difflineminus">-    </span>
<a href="#l10.122"></a><span id="l10.122" class="difflineplus">+</span>
<a href="#l10.123"></a><span id="l10.123">     return null;</span>
<a href="#l10.124"></a><span id="l10.124">   },</span>
<a href="#l10.125"></a><span id="l10.125"> </span>
<a href="#l10.126"></a><span id="l10.126">   /**</span>
<a href="#l10.127"></a><span id="l10.127">    * Lookup multiple nouns by ID from the cache/existing collections.</span>
<a href="#l10.128"></a><span id="l10.128">    * @return [The number that were found, the number that were not found.]</span>
<a href="#l10.129"></a><span id="l10.129">    */</span>
<a href="#l10.130"></a><span id="l10.130">   cacheLookupMany: function gloda_colm_cacheLookupMany(aNounID, aIDMap,</span>
<a href="#l10.131"></a><span id="l10.131">       aTargetMap, aDoCache) {</span>
<a href="#l10.132"></a><span id="l10.132">     let foundCount = 0, notFoundCount = 0, notFound = {};</span>
<a href="#l10.133"></a><span id="l10.133" class="difflineminus">-    </span>
<a href="#l10.134"></a><span id="l10.134" class="difflineplus">+</span>
<a href="#l10.135"></a><span id="l10.135">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l10.136"></a><span id="l10.136" class="difflineminus">-    </span>
<a href="#l10.137"></a><span id="l10.137" class="difflineplus">+</span>
<a href="#l10.138"></a><span id="l10.138">     if (cache) {</span>
<a href="#l10.139"></a><span id="l10.139">       for (let key in aIDMap) {</span>
<a href="#l10.140"></a><span id="l10.140">         let cacheValue = cache._idMap[key];</span>
<a href="#l10.141"></a><span id="l10.141">         if (cacheValue === undefined) {</span>
<a href="#l10.142"></a><span id="l10.142">           notFoundCount++;</span>
<a href="#l10.143"></a><span id="l10.143">           notFound[key] = null;</span>
<a href="#l10.144"></a><span id="l10.144">         }</span>
<a href="#l10.145"></a><span id="l10.145">         else {</span>
<a href="#l10.146"></a><span id="l10.146" class="difflineat">@@ -157,68 +157,68 @@ var GlodaCollectionManager = {</span>
<a href="#l10.147"></a><span id="l10.147">           aTargetMap[key] = cacheValue;</span>
<a href="#l10.148"></a><span id="l10.148">           cache.hit(cacheValue);</span>
<a href="#l10.149"></a><span id="l10.149">         }</span>
<a href="#l10.150"></a><span id="l10.150">       }</span>
<a href="#l10.151"></a><span id="l10.151">     }</span>
<a href="#l10.152"></a><span id="l10.152"> </span>
<a href="#l10.153"></a><span id="l10.153">     if (aDoCache === false)</span>
<a href="#l10.154"></a><span id="l10.154">       cache = null;</span>
<a href="#l10.155"></a><span id="l10.155" class="difflineminus">-    </span>
<a href="#l10.156"></a><span id="l10.156" class="difflineplus">+</span>
<a href="#l10.157"></a><span id="l10.157">     for each (let [iCollection, collection] in</span>
<a href="#l10.158"></a><span id="l10.158">               Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l10.159"></a><span id="l10.159">       for (let key in notFound) {</span>
<a href="#l10.160"></a><span id="l10.160">         let collValue = collection._idMap[key];</span>
<a href="#l10.161"></a><span id="l10.161">         if (collValue !== undefined) {</span>
<a href="#l10.162"></a><span id="l10.162">           aTargetMap[key] = collValue;</span>
<a href="#l10.163"></a><span id="l10.163">           delete notFound[key];</span>
<a href="#l10.164"></a><span id="l10.164">           foundCount++;</span>
<a href="#l10.165"></a><span id="l10.165">           notFoundCount--;</span>
<a href="#l10.166"></a><span id="l10.166">           if (cache)</span>
<a href="#l10.167"></a><span id="l10.167">             cache.add([collValue]);</span>
<a href="#l10.168"></a><span id="l10.168">         }</span>
<a href="#l10.169"></a><span id="l10.169">       }</span>
<a href="#l10.170"></a><span id="l10.170">     }</span>
<a href="#l10.171"></a><span id="l10.171" class="difflineminus">-    </span>
<a href="#l10.172"></a><span id="l10.172" class="difflineplus">+</span>
<a href="#l10.173"></a><span id="l10.173">     return [foundCount, notFoundCount, notFound];</span>
<a href="#l10.174"></a><span id="l10.174">   },</span>
<a href="#l10.175"></a><span id="l10.175" class="difflineminus">-  </span>
<a href="#l10.176"></a><span id="l10.176" class="difflineplus">+</span>
<a href="#l10.177"></a><span id="l10.177">   /**</span>
<a href="#l10.178"></a><span id="l10.178">    * Attempt to locate an instance of the object of the given noun type with the</span>
<a href="#l10.179"></a><span id="l10.179">    *  given id.  Counts as a cache hit if found.  (And if it was't in a cache,</span>
<a href="#l10.180"></a><span id="l10.180">    *  but rather a collection, it is added to the cache.)</span>
<a href="#l10.181"></a><span id="l10.181">    */</span>
<a href="#l10.182"></a><span id="l10.182">   cacheLookupOneByUniqueValue:</span>
<a href="#l10.183"></a><span id="l10.183">       function gloda_colm_cacheLookupOneByUniqueValue(aNounID, aUniqueValue,</span>
<a href="#l10.184"></a><span id="l10.184">                                                       aDoCache) {</span>
<a href="#l10.185"></a><span id="l10.185">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l10.186"></a><span id="l10.186" class="difflineminus">-    </span>
<a href="#l10.187"></a><span id="l10.187" class="difflineplus">+</span>
<a href="#l10.188"></a><span id="l10.188">     if (cache) {</span>
<a href="#l10.189"></a><span id="l10.189">       if (aUniqueValue in cache._uniqueValueMap) {</span>
<a href="#l10.190"></a><span id="l10.190">         let item = cache._uniqueValueMap[aUniqueValue];</span>
<a href="#l10.191"></a><span id="l10.191">         return cache.hit(item);</span>
<a href="#l10.192"></a><span id="l10.192">       }</span>
<a href="#l10.193"></a><span id="l10.193">     }</span>
<a href="#l10.194"></a><span id="l10.194" class="difflineminus">-    </span>
<a href="#l10.195"></a><span id="l10.195" class="difflineplus">+</span>
<a href="#l10.196"></a><span id="l10.196">     if (aDoCache === false)</span>
<a href="#l10.197"></a><span id="l10.197">       cache = null;</span>
<a href="#l10.198"></a><span id="l10.198" class="difflineminus">-  </span>
<a href="#l10.199"></a><span id="l10.199" class="difflineplus">+</span>
<a href="#l10.200"></a><span id="l10.200">     for each (let [iCollection, collection] in</span>
<a href="#l10.201"></a><span id="l10.201">               Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l10.202"></a><span id="l10.202">       if (aUniqueValue in collection._uniqueValueMap) {</span>
<a href="#l10.203"></a><span id="l10.203">         let item = collection._uniqueValueMap[aUniqueValue];</span>
<a href="#l10.204"></a><span id="l10.204">         if (cache)</span>
<a href="#l10.205"></a><span id="l10.205">           cache.add([item]);</span>
<a href="#l10.206"></a><span id="l10.206">         return item;</span>
<a href="#l10.207"></a><span id="l10.207">       }</span>
<a href="#l10.208"></a><span id="l10.208">     }</span>
<a href="#l10.209"></a><span id="l10.209" class="difflineminus">-    </span>
<a href="#l10.210"></a><span id="l10.210" class="difflineplus">+</span>
<a href="#l10.211"></a><span id="l10.211">     return null;</span>
<a href="#l10.212"></a><span id="l10.212">   },</span>
<a href="#l10.213"></a><span id="l10.213" class="difflineminus">-  </span>
<a href="#l10.214"></a><span id="l10.214" class="difflineplus">+</span>
<a href="#l10.215"></a><span id="l10.215">   /**</span>
<a href="#l10.216"></a><span id="l10.216">    * Checks whether the provided item with the given id is actually a duplicate</span>
<a href="#l10.217"></a><span id="l10.217">    *  of an instance that already exists in the cache/a collection.  If it is,</span>
<a href="#l10.218"></a><span id="l10.218">    *  the pre-existing instance is returned and counts as a cache hit.  If it</span>
<a href="#l10.219"></a><span id="l10.219">    *  is not, the passed-in instance is added to the cache and returned.</span>
<a href="#l10.220"></a><span id="l10.220">    */</span>
<a href="#l10.221"></a><span id="l10.221">   cacheLoadUnifyOne: function gloda_colm_cacheLoadUnifyOne(aItem) {</span>
<a href="#l10.222"></a><span id="l10.222">     let items = [aItem];</span>
<a href="#l10.223"></a><span id="l10.223" class="difflineat">@@ -232,54 +232,54 @@ var GlodaCollectionManager = {</span>
<a href="#l10.224"></a><span id="l10.224">    *  instances are replaced by those instances in the provided list, and each</span>
<a href="#l10.225"></a><span id="l10.225">    *  counts as a cache hit.  Items without pre-existing instances are added</span>
<a href="#l10.226"></a><span id="l10.226">    *  to the cache and left intact.</span>
<a href="#l10.227"></a><span id="l10.227">    */</span>
<a href="#l10.228"></a><span id="l10.228">   cacheLoadUnify: function gloda_colm_cacheLoadUnify(aNounID, aItems,</span>
<a href="#l10.229"></a><span id="l10.229">       aCacheIfMissing) {</span>
<a href="#l10.230"></a><span id="l10.230">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l10.231"></a><span id="l10.231">     if (aCacheIfMissing === undefined)</span>
<a href="#l10.232"></a><span id="l10.232" class="difflineminus">-      aCacheIfMissing = true; </span>
<a href="#l10.233"></a><span id="l10.233" class="difflineminus">-    </span>
<a href="#l10.234"></a><span id="l10.234" class="difflineplus">+      aCacheIfMissing = true;</span>
<a href="#l10.235"></a><span id="l10.235" class="difflineplus">+</span>
<a href="#l10.236"></a><span id="l10.236">     // track the items we haven't yet found in a cache/collection (value) and</span>
<a href="#l10.237"></a><span id="l10.237">     //  their index in aItems (key).  We're somewhat abusing the dictionary</span>
<a href="#l10.238"></a><span id="l10.238">     //  metaphor with the intent of storing tuples here.  We also do it because</span>
<a href="#l10.239"></a><span id="l10.239">     //  it allows random-access deletion theoretically without cost.  (Since</span>
<a href="#l10.240"></a><span id="l10.240">     //  we delete during iteration, that may be wrong, but it sounds like the</span>
<a href="#l10.241"></a><span id="l10.241">     //  semantics still work?)</span>
<a href="#l10.242"></a><span id="l10.242">     let unresolvedIndexToItem = {};</span>
<a href="#l10.243"></a><span id="l10.243">     let numUnresolved = 0;</span>
<a href="#l10.244"></a><span id="l10.244" class="difflineminus">-    </span>
<a href="#l10.245"></a><span id="l10.245" class="difflineplus">+</span>
<a href="#l10.246"></a><span id="l10.246">     if (cache) {</span>
<a href="#l10.247"></a><span id="l10.247">       for (let iItem = 0; iItem &lt; aItems.length; iItem++) {</span>
<a href="#l10.248"></a><span id="l10.248">         let item = aItems[iItem];</span>
<a href="#l10.249"></a><span id="l10.249" class="difflineminus">-        </span>
<a href="#l10.250"></a><span id="l10.250" class="difflineplus">+</span>
<a href="#l10.251"></a><span id="l10.251">         if (item.id in cache._idMap) {</span>
<a href="#l10.252"></a><span id="l10.252">           let realItem = cache._idMap[item.id];</span>
<a href="#l10.253"></a><span id="l10.253">           // update the caller's array with the reference to the 'real' item</span>
<a href="#l10.254"></a><span id="l10.254">           aItems[iItem] = realItem;</span>
<a href="#l10.255"></a><span id="l10.255">           cache.hit(realItem);</span>
<a href="#l10.256"></a><span id="l10.256">         }</span>
<a href="#l10.257"></a><span id="l10.257">         else {</span>
<a href="#l10.258"></a><span id="l10.258">           unresolvedIndexToItem[iItem] = item;</span>
<a href="#l10.259"></a><span id="l10.259">           numUnresolved++;</span>
<a href="#l10.260"></a><span id="l10.260">         }</span>
<a href="#l10.261"></a><span id="l10.261">       }</span>
<a href="#l10.262"></a><span id="l10.262" class="difflineminus">-      </span>
<a href="#l10.263"></a><span id="l10.263" class="difflineplus">+</span>
<a href="#l10.264"></a><span id="l10.264">       // we're done if everyone was a hit.</span>
<a href="#l10.265"></a><span id="l10.265">       if (numUnresolved == 0)</span>
<a href="#l10.266"></a><span id="l10.266">         return;</span>
<a href="#l10.267"></a><span id="l10.267">     }</span>
<a href="#l10.268"></a><span id="l10.268">     else {</span>
<a href="#l10.269"></a><span id="l10.269">       for (let iItem = 0; iItem &lt; aItems.length; iItem++) {</span>
<a href="#l10.270"></a><span id="l10.270">         unresolvedIndexToItem[iItem] = aItems[iItem];</span>
<a href="#l10.271"></a><span id="l10.271">       }</span>
<a href="#l10.272"></a><span id="l10.272">       numUnresolved = aItems.length;</span>
<a href="#l10.273"></a><span id="l10.273">     }</span>
<a href="#l10.274"></a><span id="l10.274" class="difflineminus">-  </span>
<a href="#l10.275"></a><span id="l10.275" class="difflineplus">+</span>
<a href="#l10.276"></a><span id="l10.276">     let needToCache = [];</span>
<a href="#l10.277"></a><span id="l10.277">     // next, let's fall back to our collections</span>
<a href="#l10.278"></a><span id="l10.278">     for each (let [iCollection, collection] in</span>
<a href="#l10.279"></a><span id="l10.279">               Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l10.280"></a><span id="l10.280">       for (let [iItem, item] in Iterator(unresolvedIndexToItem)) {</span>
<a href="#l10.281"></a><span id="l10.281">         if (item.id in collection._idMap) {</span>
<a href="#l10.282"></a><span id="l10.282">           let realItem = collection._idMap[item.id];</span>
<a href="#l10.283"></a><span id="l10.283">           // update the caller's array to now have the 'real' object</span>
<a href="#l10.284"></a><span id="l10.284" class="difflineat">@@ -289,55 +289,55 @@ var GlodaCollectionManager = {</span>
<a href="#l10.285"></a><span id="l10.285">           // we no longer need to resolve this item...</span>
<a href="#l10.286"></a><span id="l10.286">           delete unresolvedIndexToItem[iItem];</span>
<a href="#l10.287"></a><span id="l10.287">           // stop checking collections if we got everybody</span>
<a href="#l10.288"></a><span id="l10.288">           if (--numUnresolved == 0)</span>
<a href="#l10.289"></a><span id="l10.289">             break;</span>
<a href="#l10.290"></a><span id="l10.290">         }</span>
<a href="#l10.291"></a><span id="l10.291">       }</span>
<a href="#l10.292"></a><span id="l10.292">     }</span>
<a href="#l10.293"></a><span id="l10.293" class="difflineminus">-    </span>
<a href="#l10.294"></a><span id="l10.294" class="difflineplus">+</span>
<a href="#l10.295"></a><span id="l10.295">     // anything left in unresolvedIndexToItem should be added to the cache</span>
<a href="#l10.296"></a><span id="l10.296">     //  unless !aCacheIfMissing.  plus, we already have 'needToCache'</span>
<a href="#l10.297"></a><span id="l10.297">     if (cache &amp;&amp; aCacheIfMissing) {</span>
<a href="#l10.298"></a><span id="l10.298">       cache.add(needToCache.concat([val for each</span>
<a href="#l10.299"></a><span id="l10.299">                                     (val in unresolvedIndexToItem)]));</span>
<a href="#l10.300"></a><span id="l10.300">     }</span>
<a href="#l10.301"></a><span id="l10.301" class="difflineminus">-    </span>
<a href="#l10.302"></a><span id="l10.302" class="difflineplus">+</span>
<a href="#l10.303"></a><span id="l10.303">     return aItems;</span>
<a href="#l10.304"></a><span id="l10.304">   },</span>
<a href="#l10.305"></a><span id="l10.305" class="difflineminus">-  </span>
<a href="#l10.306"></a><span id="l10.306" class="difflineplus">+</span>
<a href="#l10.307"></a><span id="l10.307">   cacheCommitDirty: function glod_colm_cacheCommitDirty() {</span>
<a href="#l10.308"></a><span id="l10.308">     for each (let cache in this._cachesByNoun) {</span>
<a href="#l10.309"></a><span id="l10.309">       cache.commitDirty();</span>
<a href="#l10.310"></a><span id="l10.310">     }</span>
<a href="#l10.311"></a><span id="l10.311">   },</span>
<a href="#l10.312"></a><span id="l10.312"> </span>
<a href="#l10.313"></a><span id="l10.313">   /**</span>
<a href="#l10.314"></a><span id="l10.314">    * Notifies the collection manager that an item has been loaded and should</span>
<a href="#l10.315"></a><span id="l10.315">    *  be cached, assuming caching is active.</span>
<a href="#l10.316"></a><span id="l10.316" class="difflineminus">-   */    </span>
<a href="#l10.317"></a><span id="l10.317" class="difflineplus">+   */</span>
<a href="#l10.318"></a><span id="l10.318">   itemLoaded: function gloda_colm_itemsLoaded(aItem) {</span>
<a href="#l10.319"></a><span id="l10.319">     let cache = this._cachesByNoun[aItem.NOUN_ID];</span>
<a href="#l10.320"></a><span id="l10.320">     if (cache) {</span>
<a href="#l10.321"></a><span id="l10.321">       cache.add([aItem]);</span>
<a href="#l10.322"></a><span id="l10.322">     }</span>
<a href="#l10.323"></a><span id="l10.323">   },</span>
<a href="#l10.324"></a><span id="l10.324"> </span>
<a href="#l10.325"></a><span id="l10.325">   /**</span>
<a href="#l10.326"></a><span id="l10.326">    * Notifies the collection manager that multiple items has been loaded and</span>
<a href="#l10.327"></a><span id="l10.327">    *  should be cached, assuming caching is active.</span>
<a href="#l10.328"></a><span id="l10.328" class="difflineminus">-   */  </span>
<a href="#l10.329"></a><span id="l10.329" class="difflineplus">+   */</span>
<a href="#l10.330"></a><span id="l10.330">   itemsLoaded: function gloda_colm_itemsLoaded(aNounID, aItems) {</span>
<a href="#l10.331"></a><span id="l10.331">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l10.332"></a><span id="l10.332">     if (cache) {</span>
<a href="#l10.333"></a><span id="l10.333">       cache.add(aItems);</span>
<a href="#l10.334"></a><span id="l10.334">     }</span>
<a href="#l10.335"></a><span id="l10.335">   },</span>
<a href="#l10.336"></a><span id="l10.336" class="difflineminus">-  </span>
<a href="#l10.337"></a><span id="l10.337" class="difflineplus">+</span>
<a href="#l10.338"></a><span id="l10.338">   /**</span>
<a href="#l10.339"></a><span id="l10.339">    * This should be called when items are added to the global database.  This</span>
<a href="#l10.340"></a><span id="l10.340">    *  should generally mean during indexing by indexers or an attribute</span>
<a href="#l10.341"></a><span id="l10.341">    *  provider.</span>
<a href="#l10.342"></a><span id="l10.342">    * We walk all existing collections for the given noun type and add the items</span>
<a href="#l10.343"></a><span id="l10.343">    *  to the collection if the item meets the query that defines the collection.</span>
<a href="#l10.344"></a><span id="l10.344">    */</span>
<a href="#l10.345"></a><span id="l10.345">   itemsAdded: function gloda_colm_itemsAdded(aNounID, aItems) {</span>
<a href="#l10.346"></a><span id="l10.346" class="difflineat">@@ -424,64 +424,67 @@ var GlodaCollectionManager = {</span>
<a href="#l10.347"></a><span id="l10.347"> </span>
<a href="#l10.348"></a><span id="l10.348"> /**</span>
<a href="#l10.349"></a><span id="l10.349">  * @class A current view of the set of first-class nouns meeting a given query.</span>
<a href="#l10.350"></a><span id="l10.350">  *  Assuming a listener is present, events are</span>
<a href="#l10.351"></a><span id="l10.351">  *  generated when new objects meet the query, existing objects no longer meet</span>
<a href="#l10.352"></a><span id="l10.352">  *  the query, or existing objects have experienced a change in attributes that</span>
<a href="#l10.353"></a><span id="l10.353">  *  does not affect their ability to be present (but the listener may care about</span>
<a href="#l10.354"></a><span id="l10.354">  *  because it is exposing those attributes).</span>
<a href="#l10.355"></a><span id="l10.355" class="difflineminus">- * @constructor </span>
<a href="#l10.356"></a><span id="l10.356" class="difflineplus">+ * @constructor</span>
<a href="#l10.357"></a><span id="l10.357">  */</span>
<a href="#l10.358"></a><span id="l10.358"> function GlodaCollection(aNounDef, aItems, aQuery, aListener,</span>
<a href="#l10.359"></a><span id="l10.359">       aMasterCollection) {</span>
<a href="#l10.360"></a><span id="l10.360">   // if aNounDef is null, we are just being invoked for subclassing</span>
<a href="#l10.361"></a><span id="l10.361">   if (aNounDef === undefined)</span>
<a href="#l10.362"></a><span id="l10.362">     return;</span>
<a href="#l10.363"></a><span id="l10.363"> </span>
<a href="#l10.364"></a><span id="l10.364">   this._nounDef = aNounDef;</span>
<a href="#l10.365"></a><span id="l10.365">   // should we also maintain a unique value mapping...</span>
<a href="#l10.366"></a><span id="l10.366">   if (this._nounDef.usesUniqueValue)</span>
<a href="#l10.367"></a><span id="l10.367">     this._uniqueValueMap = {};</span>
<a href="#l10.368"></a><span id="l10.368"> </span>
<a href="#l10.369"></a><span id="l10.369">   this.pendingItems = [];</span>
<a href="#l10.370"></a><span id="l10.370">   this._pendingIdMap = {};</span>
<a href="#l10.371"></a><span id="l10.371">   this.items = [];</span>
<a href="#l10.372"></a><span id="l10.372">   this._idMap = {};</span>
<a href="#l10.373"></a><span id="l10.373" class="difflineminus">-  </span>
<a href="#l10.374"></a><span id="l10.374" class="difflineplus">+</span>
<a href="#l10.375"></a><span id="l10.375">   // force the listener to null for our call to _onItemsAdded; no events for</span>
<a href="#l10.376"></a><span id="l10.376">   //  the initial load-out.</span>
<a href="#l10.377"></a><span id="l10.377">   this._listener = null;</span>
<a href="#l10.378"></a><span id="l10.378">   if (aItems &amp;&amp; aItems.length)</span>
<a href="#l10.379"></a><span id="l10.379">     this._onItemsAdded(aItems);</span>
<a href="#l10.380"></a><span id="l10.380" class="difflineminus">-  </span>
<a href="#l10.381"></a><span id="l10.381" class="difflineplus">+</span>
<a href="#l10.382"></a><span id="l10.382">   this.query = aQuery || null;</span>
<a href="#l10.383"></a><span id="l10.383" class="difflineminus">-  if (this.query)</span>
<a href="#l10.384"></a><span id="l10.384" class="difflineplus">+  if (this.query) {</span>
<a href="#l10.385"></a><span id="l10.385">     this.query.collection = this;</span>
<a href="#l10.386"></a><span id="l10.386" class="difflineplus">+    if (this.query.options.stashColumns)</span>
<a href="#l10.387"></a><span id="l10.387" class="difflineplus">+      this.stashedColumns = {};</span>
<a href="#l10.388"></a><span id="l10.388" class="difflineplus">+  }</span>
<a href="#l10.389"></a><span id="l10.389">   this._listener = aListener || null;</span>
<a href="#l10.390"></a><span id="l10.390" class="difflineminus">-  </span>
<a href="#l10.391"></a><span id="l10.391" class="difflineplus">+</span>
<a href="#l10.392"></a><span id="l10.392">   this.deferredCount = 0;</span>
<a href="#l10.393"></a><span id="l10.393">   this.resolvedCount = 0;</span>
<a href="#l10.394"></a><span id="l10.394" class="difflineminus">-  </span>
<a href="#l10.395"></a><span id="l10.395" class="difflineplus">+</span>
<a href="#l10.396"></a><span id="l10.396">   if (aMasterCollection) {</span>
<a href="#l10.397"></a><span id="l10.397">     this.masterCollection = aMasterCollection.masterCollection;</span>
<a href="#l10.398"></a><span id="l10.398">   }</span>
<a href="#l10.399"></a><span id="l10.399">   else {</span>
<a href="#l10.400"></a><span id="l10.400">     this.masterCollection = this;</span>
<a href="#l10.401"></a><span id="l10.401">     /** a dictionary of dictionaries. at the top level, the keys are noun IDs.</span>
<a href="#l10.402"></a><span id="l10.402">      * each of these sub-dictionaries maps the IDs of desired noun instances to</span>
<a href="#l10.403"></a><span id="l10.403">      * the actual instance, or null if it has not yet been loaded.</span>
<a href="#l10.404"></a><span id="l10.404" class="difflineminus">-     */ </span>
<a href="#l10.405"></a><span id="l10.405" class="difflineplus">+     */</span>
<a href="#l10.406"></a><span id="l10.406">     this.referencesByNounID = {};</span>
<a href="#l10.407"></a><span id="l10.407">     /**</span>
<a href="#l10.408"></a><span id="l10.408">      * a dictionary of dictionaries. at the top level, the keys are noun IDs.</span>
<a href="#l10.409"></a><span id="l10.409">      * each of the sub-dictionaries maps the IDs of the _recognized parent</span>
<a href="#l10.410"></a><span id="l10.410">      * noun_ to the list of children, or null if the list has not yet been</span>
<a href="#l10.411"></a><span id="l10.411">      * populated.</span>
<a href="#l10.412"></a><span id="l10.412" class="difflineminus">-     * </span>
<a href="#l10.413"></a><span id="l10.413" class="difflineplus">+     *</span>
<a href="#l10.414"></a><span id="l10.414">      * So if we have a noun definition A with ID 1 who is the recognized parent</span>
<a href="#l10.415"></a><span id="l10.415">      *  noun of noun definition B with ID 2, AND we have an instance A(1) with</span>
<a href="#l10.416"></a><span id="l10.416">      *  two children B(10), B(11), then an example might be: {2: {1: [10, 11]}}.</span>
<a href="#l10.417"></a><span id="l10.417">      */</span>
<a href="#l10.418"></a><span id="l10.418">     this.inverseReferencesByNounID = {};</span>
<a href="#l10.419"></a><span id="l10.419">     this.subCollections = {};</span>
<a href="#l10.420"></a><span id="l10.420">   }</span>
<a href="#l10.421"></a><span id="l10.421"> }</span>
<a href="#l10.422"></a><span id="l10.422" class="difflineat">@@ -500,17 +503,17 @@ GlodaCollection.prototype = {</span>
<a href="#l10.423"></a><span id="l10.423">    *  initial database query.  It will, however, receive onItemsModified</span>
<a href="#l10.424"></a><span id="l10.424">    *  notifications if items in the collection are re-indexed.</span>
<a href="#l10.425"></a><span id="l10.425">    */</span>
<a href="#l10.426"></a><span id="l10.426">   becomeExplicit: function gloda_coll_becomeExplicit() {</span>
<a href="#l10.427"></a><span id="l10.427">     if (!(this.query instanceof this._nounDef.explicitQueryClass)) {</span>
<a href="#l10.428"></a><span id="l10.428">       this.query = new this._nounDef.explicitQueryClass(this);</span>
<a href="#l10.429"></a><span id="l10.429">     }</span>
<a href="#l10.430"></a><span id="l10.430">   },</span>
<a href="#l10.431"></a><span id="l10.431" class="difflineminus">-  </span>
<a href="#l10.432"></a><span id="l10.432" class="difflineplus">+</span>
<a href="#l10.433"></a><span id="l10.433">   /**</span>
<a href="#l10.434"></a><span id="l10.434">    * Clear the contents of this collection.  This only makes sense for explicit</span>
<a href="#l10.435"></a><span id="l10.435">    *  collections or wildcard collections.  (Actual query-based collections</span>
<a href="#l10.436"></a><span id="l10.436">    *  should represent the state of the query, so unless we're going to delete</span>
<a href="#l10.437"></a><span id="l10.437">    *  all the items, clearing the collection would violate that constraint.)</span>
<a href="#l10.438"></a><span id="l10.438">    */</span>
<a href="#l10.439"></a><span id="l10.439">   clear: function gloda_coll_clear() {</span>
<a href="#l10.440"></a><span id="l10.440">     this._idMap = {};</span>
<a href="#l10.441"></a><span id="l10.441" class="difflineat">@@ -532,34 +535,34 @@ GlodaCollection.prototype = {</span>
<a href="#l10.442"></a><span id="l10.442">         this._idMap[item.id] = item;</span>
<a href="#l10.443"></a><span id="l10.443">       }</span>
<a href="#l10.444"></a><span id="l10.444">     }</span>
<a href="#l10.445"></a><span id="l10.445">     if (this._listener) {</span>
<a href="#l10.446"></a><span id="l10.446">       try {</span>
<a href="#l10.447"></a><span id="l10.447">         this._listener.onItemsAdded(aItems, this);</span>
<a href="#l10.448"></a><span id="l10.448">       }</span>
<a href="#l10.449"></a><span id="l10.449">       catch (ex) {</span>
<a href="#l10.450"></a><span id="l10.450" class="difflineminus">-        LOG.error(&quot;caught exception from listener in onItemsAdded: &quot; + </span>
<a href="#l10.451"></a><span id="l10.451" class="difflineplus">+        LOG.error(&quot;caught exception from listener in onItemsAdded: &quot; +</span>
<a href="#l10.452"></a><span id="l10.452">             ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l10.453"></a><span id="l10.453">       }</span>
<a href="#l10.454"></a><span id="l10.454">     }</span>
<a href="#l10.455"></a><span id="l10.455">   },</span>
<a href="#l10.456"></a><span id="l10.456" class="difflineminus">-  </span>
<a href="#l10.457"></a><span id="l10.457" class="difflineplus">+</span>
<a href="#l10.458"></a><span id="l10.458">   _onItemsModified: function gloda_coll_onItemsModified(aItems) {</span>
<a href="#l10.459"></a><span id="l10.459">     if (this._listener) {</span>
<a href="#l10.460"></a><span id="l10.460">       try {</span>
<a href="#l10.461"></a><span id="l10.461">         this._listener.onItemsModified(aItems, this);</span>
<a href="#l10.462"></a><span id="l10.462">       }</span>
<a href="#l10.463"></a><span id="l10.463">       catch (ex) {</span>
<a href="#l10.464"></a><span id="l10.464" class="difflineminus">-        LOG.error(&quot;caught exception from listener in onItemsModified: &quot; + </span>
<a href="#l10.465"></a><span id="l10.465" class="difflineplus">+        LOG.error(&quot;caught exception from listener in onItemsModified: &quot; +</span>
<a href="#l10.466"></a><span id="l10.466">             ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l10.467"></a><span id="l10.467">       }</span>
<a href="#l10.468"></a><span id="l10.468">     }</span>
<a href="#l10.469"></a><span id="l10.469">   },</span>
<a href="#l10.470"></a><span id="l10.470" class="difflineminus">-  </span>
<a href="#l10.471"></a><span id="l10.471" class="difflineplus">+</span>
<a href="#l10.472"></a><span id="l10.472">   /**</span>
<a href="#l10.473"></a><span id="l10.473">    * Given a list of items that definitely no longer belong in this collection,</span>
<a href="#l10.474"></a><span id="l10.474">    *  remove them from the collection and notify the listener.  The 'tricky'</span>
<a href="#l10.475"></a><span id="l10.475">    *  part is that we need to remove the deleted items from our list of items.</span>
<a href="#l10.476"></a><span id="l10.476">    */</span>
<a href="#l10.477"></a><span id="l10.477">   _onItemsRemoved: function gloda_coll_onItemsRemoved(aItems) {</span>
<a href="#l10.478"></a><span id="l10.478">     // we want to avoid the O(n^2) deletion performance case, and deletion</span>
<a href="#l10.479"></a><span id="l10.479">     //  should be rare enough that the extra cost of building the deletion map</span>
<a href="#l10.480"></a><span id="l10.480" class="difflineat">@@ -576,23 +579,23 @@ GlodaCollection.prototype = {</span>
<a href="#l10.481"></a><span id="l10.481">     // in-place filter.  probably needless optimization.</span>
<a href="#l10.482"></a><span id="l10.482">     let iWrite=0;</span>
<a href="#l10.483"></a><span id="l10.483">     for (let iRead = 0; iRead &lt; items.length; iRead++) {</span>
<a href="#l10.484"></a><span id="l10.484">       let item = items[iRead];</span>
<a href="#l10.485"></a><span id="l10.485">       if (!(item.id in deleteMap))</span>
<a href="#l10.486"></a><span id="l10.486">         items[iWrite++] = item;</span>
<a href="#l10.487"></a><span id="l10.487">     }</span>
<a href="#l10.488"></a><span id="l10.488">     items.slice(iWrite);</span>
<a href="#l10.489"></a><span id="l10.489" class="difflineminus">-    </span>
<a href="#l10.490"></a><span id="l10.490" class="difflineplus">+</span>
<a href="#l10.491"></a><span id="l10.491">     if (this._listener) {</span>
<a href="#l10.492"></a><span id="l10.492">       try {</span>
<a href="#l10.493"></a><span id="l10.493">         this._listener.onItemsRemoved(aItems, this);</span>
<a href="#l10.494"></a><span id="l10.494">       }</span>
<a href="#l10.495"></a><span id="l10.495">       catch (ex) {</span>
<a href="#l10.496"></a><span id="l10.496" class="difflineminus">-        LOG.error(&quot;caught exception from listener in onItemsRemoved: &quot; + </span>
<a href="#l10.497"></a><span id="l10.497" class="difflineplus">+        LOG.error(&quot;caught exception from listener in onItemsRemoved: &quot; +</span>
<a href="#l10.498"></a><span id="l10.498">             ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l10.499"></a><span id="l10.499">       }</span>
<a href="#l10.500"></a><span id="l10.500">     }</span>
<a href="#l10.501"></a><span id="l10.501">   },</span>
<a href="#l10.502"></a><span id="l10.502"> </span>
<a href="#l10.503"></a><span id="l10.503">   _onQueryCompleted: function gloda_coll_onQueryCompleted() {</span>
<a href="#l10.504"></a><span id="l10.504">     if (this._listener &amp;&amp; this._listener.onQueryCompleted)</span>
<a href="#l10.505"></a><span id="l10.505">       this._listener.onQueryCompleted(this);</span>
<a href="#l10.506"></a><span id="l10.506" class="difflineat">@@ -600,17 +603,17 @@ GlodaCollection.prototype = {</span>
<a href="#l10.507"></a><span id="l10.507"> };</span>
<a href="#l10.508"></a><span id="l10.508"> </span>
<a href="#l10.509"></a><span id="l10.509"> /**</span>
<a href="#l10.510"></a><span id="l10.510">  * Create an LRU cache collection for the given noun with the given size.</span>
<a href="#l10.511"></a><span id="l10.511">  * @constructor</span>
<a href="#l10.512"></a><span id="l10.512">  */</span>
<a href="#l10.513"></a><span id="l10.513"> function GlodaLRUCacheCollection(aNounDef, aCacheSize) {</span>
<a href="#l10.514"></a><span id="l10.514">   GlodaCollection.call(this, aNounDef, null, null, null);</span>
<a href="#l10.515"></a><span id="l10.515" class="difflineminus">-  </span>
<a href="#l10.516"></a><span id="l10.516" class="difflineplus">+</span>
<a href="#l10.517"></a><span id="l10.517">   this._head = null; // aka oldest!</span>
<a href="#l10.518"></a><span id="l10.518">   this._tail = null; // aka newest!</span>
<a href="#l10.519"></a><span id="l10.519">   this._size = 0;</span>
<a href="#l10.520"></a><span id="l10.520">   // let's keep things sane, and simplify our logic a little...</span>
<a href="#l10.521"></a><span id="l10.521">   if (aCacheSize &lt; 32)</span>
<a href="#l10.522"></a><span id="l10.522">     aCacheSize = 32;</span>
<a href="#l10.523"></a><span id="l10.523">   this._maxCacheSize = aCacheSize;</span>
<a href="#l10.524"></a><span id="l10.524"> }</span>
<a href="#l10.525"></a><span id="l10.525" class="difflineat">@@ -627,100 +630,100 @@ GlodaLRUCacheCollection.prototype.add = </span>
<a href="#l10.526"></a><span id="l10.526">     if (item.id in this._idMap) {</span>
<a href="#l10.527"></a><span id="l10.527">       // DEBUGME so, we're dealing with this, but it shouldn't happen.  need</span>
<a href="#l10.528"></a><span id="l10.528">       //  trace-debuggage.</span>
<a href="#l10.529"></a><span id="l10.529">       continue;</span>
<a href="#l10.530"></a><span id="l10.530">     }</span>
<a href="#l10.531"></a><span id="l10.531">     this._idMap[item.id] = item;</span>
<a href="#l10.532"></a><span id="l10.532">     if (this._uniqueValueMap)</span>
<a href="#l10.533"></a><span id="l10.533">       this._uniqueValueMap[item.uniqueValue] = item;</span>
<a href="#l10.534"></a><span id="l10.534" class="difflineminus">-    </span>
<a href="#l10.535"></a><span id="l10.535" class="difflineplus">+</span>
<a href="#l10.536"></a><span id="l10.536">     item._lruPrev = this._tail;</span>
<a href="#l10.537"></a><span id="l10.537">     // we do have to make sure that we will set _head the first time we insert</span>
<a href="#l10.538"></a><span id="l10.538">     //  something</span>
<a href="#l10.539"></a><span id="l10.539">     if (this._tail !== null)</span>
<a href="#l10.540"></a><span id="l10.540">       this._tail._lruNext = item;</span>
<a href="#l10.541"></a><span id="l10.541">     else</span>
<a href="#l10.542"></a><span id="l10.542">       this._head = item;</span>
<a href="#l10.543"></a><span id="l10.543">     item._lruNext = null;</span>
<a href="#l10.544"></a><span id="l10.544">     this._tail = item;</span>
<a href="#l10.545"></a><span id="l10.545" class="difflineminus">-    </span>
<a href="#l10.546"></a><span id="l10.546" class="difflineplus">+</span>
<a href="#l10.547"></a><span id="l10.547">     this._size++;</span>
<a href="#l10.548"></a><span id="l10.548">   }</span>
<a href="#l10.549"></a><span id="l10.549" class="difflineminus">-  </span>
<a href="#l10.550"></a><span id="l10.550" class="difflineplus">+</span>
<a href="#l10.551"></a><span id="l10.551">   while (this._size &gt; this._maxCacheSize) {</span>
<a href="#l10.552"></a><span id="l10.552">     let item = this._head;</span>
<a href="#l10.553"></a><span id="l10.553" class="difflineminus">-    </span>
<a href="#l10.554"></a><span id="l10.554" class="difflineplus">+</span>
<a href="#l10.555"></a><span id="l10.555">     // we never have to deal with the possibility of needing to make _head/_tail</span>
<a href="#l10.556"></a><span id="l10.556">     //  null.</span>
<a href="#l10.557"></a><span id="l10.557">     this._head = item._lruNext;</span>
<a href="#l10.558"></a><span id="l10.558">     this._head._lruPrev = null;</span>
<a href="#l10.559"></a><span id="l10.559">     // (because we are nice, we will delete the properties...)</span>
<a href="#l10.560"></a><span id="l10.560">     delete item._lruNext;</span>
<a href="#l10.561"></a><span id="l10.561">     delete item._lruPrev;</span>
<a href="#l10.562"></a><span id="l10.562" class="difflineminus">-    </span>
<a href="#l10.563"></a><span id="l10.563" class="difflineplus">+</span>
<a href="#l10.564"></a><span id="l10.564">     // nuke from our id map</span>
<a href="#l10.565"></a><span id="l10.565">     delete this._idMap[item.id];</span>
<a href="#l10.566"></a><span id="l10.566">     if (this._uniqueValueMap)</span>
<a href="#l10.567"></a><span id="l10.567">       delete this._uniqueValueMap[item.uniqueValue];</span>
<a href="#l10.568"></a><span id="l10.568" class="difflineminus">-    </span>
<a href="#l10.569"></a><span id="l10.569" class="difflineplus">+</span>
<a href="#l10.570"></a><span id="l10.570">     // flush dirty items to disk (they may not have this attribute, in which</span>
<a href="#l10.571"></a><span id="l10.571">     //  case, this returns false, which is fine.)</span>
<a href="#l10.572"></a><span id="l10.572">     if (item.dirty) {</span>
<a href="#l10.573"></a><span id="l10.573">       this._nounDef.objUpdate.call(this._nounDef.datastore, item);</span>
<a href="#l10.574"></a><span id="l10.574">       delete item.dirty;</span>
<a href="#l10.575"></a><span id="l10.575">     }</span>
<a href="#l10.576"></a><span id="l10.576" class="difflineminus">-    </span>
<a href="#l10.577"></a><span id="l10.577" class="difflineplus">+</span>
<a href="#l10.578"></a><span id="l10.578">     this._size--;</span>
<a href="#l10.579"></a><span id="l10.579">   }</span>
<a href="#l10.580"></a><span id="l10.580"> };</span>
<a href="#l10.581"></a><span id="l10.581"> </span>
<a href="#l10.582"></a><span id="l10.582"> GlodaLRUCacheCollection.prototype.hit = function cache_hit(aItem) {</span>
<a href="#l10.583"></a><span id="l10.583">   // don't do anything in the 0 or 1 items case, or if we're already</span>
<a href="#l10.584"></a><span id="l10.584">   //  the last item</span>
<a href="#l10.585"></a><span id="l10.585">   if ((this._head === this._tail) || (this._tail === aItem))</span>
<a href="#l10.586"></a><span id="l10.586">     return aItem;</span>
<a href="#l10.587"></a><span id="l10.587"> </span>
<a href="#l10.588"></a><span id="l10.588" class="difflineminus">-  // - unlink the item  </span>
<a href="#l10.589"></a><span id="l10.589" class="difflineplus">+  // - unlink the item</span>
<a href="#l10.590"></a><span id="l10.590">   if (aItem._lruPrev !== null)</span>
<a href="#l10.591"></a><span id="l10.591">     aItem._lruPrev._lruNext = aItem._lruNext;</span>
<a href="#l10.592"></a><span id="l10.592">   else</span>
<a href="#l10.593"></a><span id="l10.593">     this._head = aItem._lruNext;</span>
<a href="#l10.594"></a><span id="l10.594">   // (_lruNext cannot be null)</span>
<a href="#l10.595"></a><span id="l10.595">   aItem._lruNext._lruPrev = aItem._lruPrev;</span>
<a href="#l10.596"></a><span id="l10.596">   // - link it in to the end</span>
<a href="#l10.597"></a><span id="l10.597" class="difflineminus">-  this._tail._lruNext = aItem; </span>
<a href="#l10.598"></a><span id="l10.598" class="difflineplus">+  this._tail._lruNext = aItem;</span>
<a href="#l10.599"></a><span id="l10.599">   aItem._lruPrev = this._tail;</span>
<a href="#l10.600"></a><span id="l10.600">   aItem._lruNext = null;</span>
<a href="#l10.601"></a><span id="l10.601">   // update tail tracking</span>
<a href="#l10.602"></a><span id="l10.602">   this._tail = aItem;</span>
<a href="#l10.603"></a><span id="l10.603" class="difflineminus">-  </span>
<a href="#l10.604"></a><span id="l10.604" class="difflineplus">+</span>
<a href="#l10.605"></a><span id="l10.605">   return aItem;</span>
<a href="#l10.606"></a><span id="l10.606"> };</span>
<a href="#l10.607"></a><span id="l10.607"> </span>
<a href="#l10.608"></a><span id="l10.608"> GlodaLRUCacheCollection.prototype.deleted = function cache_deleted(aItem) {</span>
<a href="#l10.609"></a><span id="l10.609" class="difflineminus">-  // unlink the item  </span>
<a href="#l10.610"></a><span id="l10.610" class="difflineplus">+  // unlink the item</span>
<a href="#l10.611"></a><span id="l10.611">   if (aItem._lruPrev !== null)</span>
<a href="#l10.612"></a><span id="l10.612">     aItem._lruPrev._lruNext = aItem._lruNext;</span>
<a href="#l10.613"></a><span id="l10.613">   else</span>
<a href="#l10.614"></a><span id="l10.614">     this._head = aItem._lruNext;</span>
<a href="#l10.615"></a><span id="l10.615">   if (aItem._lruNext !== null)</span>
<a href="#l10.616"></a><span id="l10.616">     aItem._lruNext._lruPrev = aItem._lruPrev;</span>
<a href="#l10.617"></a><span id="l10.617">   else</span>
<a href="#l10.618"></a><span id="l10.618">     this._tail = aItem._lruPrev;</span>
<a href="#l10.619"></a><span id="l10.619"> </span>
<a href="#l10.620"></a><span id="l10.620">   // (because we are nice, we will delete the properties...)</span>
<a href="#l10.621"></a><span id="l10.621">   delete aItem._lruNext;</span>
<a href="#l10.622"></a><span id="l10.622">   delete aItem._lruPrev;</span>
<a href="#l10.623"></a><span id="l10.623" class="difflineminus">-    </span>
<a href="#l10.624"></a><span id="l10.624" class="difflineplus">+</span>
<a href="#l10.625"></a><span id="l10.625">   // nuke from our id map</span>
<a href="#l10.626"></a><span id="l10.626">   delete this._idMap[aItem.id];</span>
<a href="#l10.627"></a><span id="l10.627">   if (this._uniqueValueMap)</span>
<a href="#l10.628"></a><span id="l10.628">     delete this._uniqueValueMap[aItem.uniqueValue];</span>
<a href="#l10.629"></a><span id="l10.629" class="difflineminus">-  </span>
<a href="#l10.630"></a><span id="l10.630" class="difflineplus">+</span>
<a href="#l10.631"></a><span id="l10.631">   this._size--;</span>
<a href="#l10.632"></a><span id="l10.632"> }</span>
<a href="#l10.633"></a><span id="l10.633"> </span>
<a href="#l10.634"></a><span id="l10.634"> /**</span>
<a href="#l10.635"></a><span id="l10.635">  * If any of the cached items are dirty, commit them, and make them no longer</span>
<a href="#l10.636"></a><span id="l10.636">  *  dirty.</span>
<a href="#l10.637"></a><span id="l10.637">  */</span>
<a href="#l10.638"></a><span id="l10.638"> GlodaLRUCacheCollection.prototype.commitDirty = function cache_commitDirty() {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/db/gloda/modules/connotent.js</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/connotent.js</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -1,16 +1,16 @@</span>
<a href="#l11.4"></a><span id="l11.4"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l11.5"></a><span id="l11.5">  *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l11.6"></a><span id="l11.6">  *</span>
<a href="#l11.7"></a><span id="l11.7">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l11.8"></a><span id="l11.8">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l11.9"></a><span id="l11.9">  * the License. You may obtain a copy of the License at</span>
<a href="#l11.10"></a><span id="l11.10">  * http://www.mozilla.org/MPL/</span>
<a href="#l11.11"></a><span id="l11.11" class="difflineminus">- * </span>
<a href="#l11.12"></a><span id="l11.12" class="difflineplus">+ *</span>
<a href="#l11.13"></a><span id="l11.13">  * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l11.14"></a><span id="l11.14">  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l11.15"></a><span id="l11.15">  * for the specific language governing rights and limitations under the</span>
<a href="#l11.16"></a><span id="l11.16">  * License.</span>
<a href="#l11.17"></a><span id="l11.17">  *</span>
<a href="#l11.18"></a><span id="l11.18">  * The Original Code is Thunderbird Global Database.</span>
<a href="#l11.19"></a><span id="l11.19">  *</span>
<a href="#l11.20"></a><span id="l11.20">  * The Initial Developer of the Original Code is</span>
<a href="#l11.21"></a><span id="l11.21" class="difflineat">@@ -28,17 +28,17 @@</span>
<a href="#l11.22"></a><span id="l11.22">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l11.23"></a><span id="l11.23">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l11.24"></a><span id="l11.24">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l11.25"></a><span id="l11.25">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l11.26"></a><span id="l11.26">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l11.27"></a><span id="l11.27">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l11.28"></a><span id="l11.28">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l11.29"></a><span id="l11.29">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l11.30"></a><span id="l11.30" class="difflineminus">- * </span>
<a href="#l11.31"></a><span id="l11.31" class="difflineplus">+ *</span>
<a href="#l11.32"></a><span id="l11.32">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l11.33"></a><span id="l11.33"> </span>
<a href="#l11.34"></a><span id="l11.34"> EXPORTED_SYMBOLS = ['GlodaContent', 'whittlerRegistry',</span>
<a href="#l11.35"></a><span id="l11.35">                     'mimeMsgToContentAndMeta', 'mimeMsgToContentSnippetAndMeta'];</span>
<a href="#l11.36"></a><span id="l11.36"> </span>
<a href="#l11.37"></a><span id="l11.37"> const Cc = Components.classes;</span>
<a href="#l11.38"></a><span id="l11.38"> const Ci = Components.interfaces;</span>
<a href="#l11.39"></a><span id="l11.39"> const Cr = Components.results;</span>
<a href="#l11.40"></a><span id="l11.40" class="difflineat">@@ -128,77 +128,77 @@ function GlodaContent() {</span>
<a href="#l11.41"></a><span id="l11.41">   this._contentPriority = null;</span>
<a href="#l11.42"></a><span id="l11.42">   this._producing = false;</span>
<a href="#l11.43"></a><span id="l11.43">   this._hunks = [];</span>
<a href="#l11.44"></a><span id="l11.44"> }</span>
<a href="#l11.45"></a><span id="l11.45"> </span>
<a href="#l11.46"></a><span id="l11.46"> GlodaContent.prototype = {</span>
<a href="#l11.47"></a><span id="l11.47">   kPriorityBase: 0,</span>
<a href="#l11.48"></a><span id="l11.48">   kPriorityPerfect: 100,</span>
<a href="#l11.49"></a><span id="l11.49" class="difflineminus">-  </span>
<a href="#l11.50"></a><span id="l11.50" class="difflineplus">+</span>
<a href="#l11.51"></a><span id="l11.51">   kHunkMeta: 1,</span>
<a href="#l11.52"></a><span id="l11.52">   kHunkQuoted: 2,</span>
<a href="#l11.53"></a><span id="l11.53">   kHunkContent: 3,</span>
<a href="#l11.54"></a><span id="l11.54" class="difflineminus">-  </span>
<a href="#l11.55"></a><span id="l11.55" class="difflineplus">+</span>
<a href="#l11.56"></a><span id="l11.56">   _resetContent: function gloda_content__resetContent() {</span>
<a href="#l11.57"></a><span id="l11.57">     this._keysAndValues = [];</span>
<a href="#l11.58"></a><span id="l11.58">     this._keysAndDeltaValues = [];</span>
<a href="#l11.59"></a><span id="l11.59">     this._hunks = [];</span>
<a href="#l11.60"></a><span id="l11.60">     this._curHunk = null;</span>
<a href="#l11.61"></a><span id="l11.61">   },</span>
<a href="#l11.62"></a><span id="l11.62" class="difflineminus">-  </span>
<a href="#l11.63"></a><span id="l11.63" class="difflineplus">+</span>
<a href="#l11.64"></a><span id="l11.64">   /* ===== Consumer API ===== */</span>
<a href="#l11.65"></a><span id="l11.65">   hasContent: function gloda_content_hasContent() {</span>
<a href="#l11.66"></a><span id="l11.66">     return (this._contentPriority != null);</span>
<a href="#l11.67"></a><span id="l11.67">   },</span>
<a href="#l11.68"></a><span id="l11.68" class="difflineminus">-  </span>
<a href="#l11.69"></a><span id="l11.69" class="difflineplus">+</span>
<a href="#l11.70"></a><span id="l11.70">   /**</span>
<a href="#l11.71"></a><span id="l11.71">    * Return content suitable for snippet display.  This means that no quoting</span>
<a href="#l11.72"></a><span id="l11.72">    *  or meta-data should be returned.</span>
<a href="#l11.73"></a><span id="l11.73" class="difflineminus">-   * </span>
<a href="#l11.74"></a><span id="l11.74" class="difflineplus">+   *</span>
<a href="#l11.75"></a><span id="l11.75">    * @param aMaxLength The maximum snippet length desired.</span>
<a href="#l11.76"></a><span id="l11.76">    */</span>
<a href="#l11.77"></a><span id="l11.77">   getContentSnippet: function gloda_content_getContentSnippet(aMaxLength) {</span>
<a href="#l11.78"></a><span id="l11.78">     let content = this.getContentString();</span>
<a href="#l11.79"></a><span id="l11.79">     if (aMaxLength)</span>
<a href="#l11.80"></a><span id="l11.80">       content = content.substring(0, aMaxLength);</span>
<a href="#l11.81"></a><span id="l11.81">     return content;</span>
<a href="#l11.82"></a><span id="l11.82">   },</span>
<a href="#l11.83"></a><span id="l11.83" class="difflineminus">-  </span>
<a href="#l11.84"></a><span id="l11.84" class="difflineplus">+</span>
<a href="#l11.85"></a><span id="l11.85">   getContentString: function gloda_content_getContent(aIndexingPurposes) {</span>
<a href="#l11.86"></a><span id="l11.86">     let data = &quot;&quot;;</span>
<a href="#l11.87"></a><span id="l11.87">     for each (let [, hunk] in Iterator(this._hunks)) {</span>
<a href="#l11.88"></a><span id="l11.88">       if (hunk.hunkType == this.kHunkContent) {</span>
<a href="#l11.89"></a><span id="l11.89">         if (data)</span>
<a href="#l11.90"></a><span id="l11.90">           data += &quot;\n&quot; + hunk.data;</span>
<a href="#l11.91"></a><span id="l11.91">         else</span>
<a href="#l11.92"></a><span id="l11.92">           data = hunk.data;</span>
<a href="#l11.93"></a><span id="l11.93">       }</span>
<a href="#l11.94"></a><span id="l11.94">     }</span>
<a href="#l11.95"></a><span id="l11.95" class="difflineminus">-    </span>
<a href="#l11.96"></a><span id="l11.96" class="difflineplus">+</span>
<a href="#l11.97"></a><span id="l11.97">     if (aIndexingPurposes) {</span>
<a href="#l11.98"></a><span id="l11.98">       // append the values for indexing.  we assume the keywords are cruft.</span>
<a href="#l11.99"></a><span id="l11.99">       // this may be crazy, but things that aren't a science aren't an exact</span>
<a href="#l11.100"></a><span id="l11.100">       // science.</span>
<a href="#l11.101"></a><span id="l11.101">       for each (let [, kv] in Iterator(this._keysAndValues)) {</span>
<a href="#l11.102"></a><span id="l11.102">         data += &quot;\n&quot; + kv[1];</span>
<a href="#l11.103"></a><span id="l11.103">       }</span>
<a href="#l11.104"></a><span id="l11.104">       for each (let [, kon] in Iterator(this._keysAndValues)) {</span>
<a href="#l11.105"></a><span id="l11.105">         data += &quot;\n&quot; + kon[1] + &quot;\n&quot; + kon[2];</span>
<a href="#l11.106"></a><span id="l11.106">       }</span>
<a href="#l11.107"></a><span id="l11.107">     }</span>
<a href="#l11.108"></a><span id="l11.108" class="difflineminus">-    </span>
<a href="#l11.109"></a><span id="l11.109" class="difflineplus">+</span>
<a href="#l11.110"></a><span id="l11.110">     return data;</span>
<a href="#l11.111"></a><span id="l11.111">   },</span>
<a href="#l11.112"></a><span id="l11.112" class="difflineminus">-  </span>
<a href="#l11.113"></a><span id="l11.113" class="difflineplus">+</span>
<a href="#l11.114"></a><span id="l11.114">   /* ===== Producer API ===== */</span>
<a href="#l11.115"></a><span id="l11.115">   /**</span>
<a href="#l11.116"></a><span id="l11.116">    * Called by a producer with the priority they believe their interpretation</span>
<a href="#l11.117"></a><span id="l11.117">    *  of the content comes in at.</span>
<a href="#l11.118"></a><span id="l11.118" class="difflineminus">-   * </span>
<a href="#l11.119"></a><span id="l11.119" class="difflineplus">+   *</span>
<a href="#l11.120"></a><span id="l11.120">    * @returns true if we believe the producer's interpretation will be</span>
<a href="#l11.121"></a><span id="l11.121">    *     interesting and they should go ahead and generate events.  We return</span>
<a href="#l11.122"></a><span id="l11.122">    *     false if we don't think they are interesting, in which case they should</span>
<a href="#l11.123"></a><span id="l11.123">    *     probably not issue calls to us, although we don't care.  (We will</span>
<a href="#l11.124"></a><span id="l11.124">    *     ignore their calls if we return false, this allows the simplification</span>
<a href="#l11.125"></a><span id="l11.125">    *     of code that needs to run anyways.)</span>
<a href="#l11.126"></a><span id="l11.126">    */</span>
<a href="#l11.127"></a><span id="l11.127">   volunteerContent: function gloda_content_volunteerContent(aPriority) {</span>
<a href="#l11.128"></a><span id="l11.128" class="difflineat">@@ -206,102 +206,102 @@ GlodaContent.prototype = {</span>
<a href="#l11.129"></a><span id="l11.129">       this._contentPriority = aPriority;</span>
<a href="#l11.130"></a><span id="l11.130">       this._resetContent();</span>
<a href="#l11.131"></a><span id="l11.131">       this._producing = true;</span>
<a href="#l11.132"></a><span id="l11.132">       return true;</span>
<a href="#l11.133"></a><span id="l11.133">     }</span>
<a href="#l11.134"></a><span id="l11.134">     this._producing = false;</span>
<a href="#l11.135"></a><span id="l11.135">     return false;</span>
<a href="#l11.136"></a><span id="l11.136">   },</span>
<a href="#l11.137"></a><span id="l11.137" class="difflineminus">-  </span>
<a href="#l11.138"></a><span id="l11.138" class="difflineplus">+</span>
<a href="#l11.139"></a><span id="l11.139">   keyValue: function gloda_content_keyValue(aKey, aValue) {</span>
<a href="#l11.140"></a><span id="l11.140">     if (!this._producing)</span>
<a href="#l11.141"></a><span id="l11.141">       return;</span>
<a href="#l11.142"></a><span id="l11.142"> </span>
<a href="#l11.143"></a><span id="l11.143">     this._keysAndValues.push([aKey, aValue]);</span>
<a href="#l11.144"></a><span id="l11.144">   },</span>
<a href="#l11.145"></a><span id="l11.145">   keyValueDelta: function gloda_content_keyValueDelta (aKey, aOldValue,</span>
<a href="#l11.146"></a><span id="l11.146">       aNewValue) {</span>
<a href="#l11.147"></a><span id="l11.147">     if (!this._producing)</span>
<a href="#l11.148"></a><span id="l11.148">       return;</span>
<a href="#l11.149"></a><span id="l11.149"> </span>
<a href="#l11.150"></a><span id="l11.150">     this._keysAndDeltaValues.push([aKey, aOldValue, aNewValue]);</span>
<a href="#l11.151"></a><span id="l11.151">   },</span>
<a href="#l11.152"></a><span id="l11.152" class="difflineminus">-  </span>
<a href="#l11.153"></a><span id="l11.153" class="difflineplus">+</span>
<a href="#l11.154"></a><span id="l11.154">   /**</span>
<a href="#l11.155"></a><span id="l11.155">    * Meta lines are lines that have to do with the content but are not the</span>
<a href="#l11.156"></a><span id="l11.156">    *  content and can generally be related to an attribute that has been derived</span>
<a href="#l11.157"></a><span id="l11.157">    *  and stored on the item.</span>
<a href="#l11.158"></a><span id="l11.158">    * For example, a bugzilla bug may note that an attachment was created; this</span>
<a href="#l11.159"></a><span id="l11.159">    *  is not content and wouldn't be desired in a snippet, but is still</span>
<a href="#l11.160"></a><span id="l11.160">    *  potentially interesting meta-data.</span>
<a href="#l11.161"></a><span id="l11.161" class="difflineminus">-   * </span>
<a href="#l11.162"></a><span id="l11.162" class="difflineplus">+   *</span>
<a href="#l11.163"></a><span id="l11.163">    * @param aLineOrLines The line or list of lines that are meta-data.</span>
<a href="#l11.164"></a><span id="l11.164">    * @param aAttr The attribute this meta-data is associated with.</span>
<a href="#l11.165"></a><span id="l11.165">    * @param aIndex If the attribute is non-singular, indicate the specific</span>
<a href="#l11.166"></a><span id="l11.166">    *     index of the item in the attribute's bound list that the meta-data</span>
<a href="#l11.167"></a><span id="l11.167">    *     is associated with.</span>
<a href="#l11.168"></a><span id="l11.168">    */</span>
<a href="#l11.169"></a><span id="l11.169">   meta: function gloda_content_meta(aLineOrLines, aAttr, aIndex) {</span>
<a href="#l11.170"></a><span id="l11.170">     if (!this._producing)</span>
<a href="#l11.171"></a><span id="l11.171">       return;</span>
<a href="#l11.172"></a><span id="l11.172" class="difflineminus">-    </span>
<a href="#l11.173"></a><span id="l11.173" class="difflineplus">+</span>
<a href="#l11.174"></a><span id="l11.174">     let data;</span>
<a href="#l11.175"></a><span id="l11.175">     if (typeof(aLineOrLines) == &quot;string&quot;)</span>
<a href="#l11.176"></a><span id="l11.176">       data = aLineOrLines;</span>
<a href="#l11.177"></a><span id="l11.177">     else</span>
<a href="#l11.178"></a><span id="l11.178">       data = aLineOrLines.join(&quot;\n&quot;);</span>
<a href="#l11.179"></a><span id="l11.179" class="difflineminus">-    </span>
<a href="#l11.180"></a><span id="l11.180" class="difflineplus">+</span>
<a href="#l11.181"></a><span id="l11.181">     this._curHunk = {hunkType: this.kHunkMeta, attr: aAttr, index: aIndex,</span>
<a href="#l11.182"></a><span id="l11.182">                      data: data};</span>
<a href="#l11.183"></a><span id="l11.183">     this._hunks.push(this._curHunk);</span>
<a href="#l11.184"></a><span id="l11.184">   },</span>
<a href="#l11.185"></a><span id="l11.185">   /**</span>
<a href="#l11.186"></a><span id="l11.186">    * Quoted lines reference previous messages or what not.</span>
<a href="#l11.187"></a><span id="l11.187" class="difflineminus">-   * </span>
<a href="#l11.188"></a><span id="l11.188" class="difflineplus">+   *</span>
<a href="#l11.189"></a><span id="l11.189">    * @param aLineOrLiens The line or list of lines that are quoted.</span>
<a href="#l11.190"></a><span id="l11.190">    * @param aDepth The depth of the quoting.</span>
<a href="#l11.191"></a><span id="l11.191">    * @param aOrigin The item that originated the original content, if known.</span>
<a href="#l11.192"></a><span id="l11.192">    *     For example, perhaps a GlodaMessage?</span>
<a href="#l11.193"></a><span id="l11.193">    * @param aTarget A reference to the location in the original content, if</span>
<a href="#l11.194"></a><span id="l11.194" class="difflineminus">-   *     known.  For example, the index of a line in a message or something?  </span>
<a href="#l11.195"></a><span id="l11.195" class="difflineplus">+   *     known.  For example, the index of a line in a message or something?</span>
<a href="#l11.196"></a><span id="l11.196">    */</span>
<a href="#l11.197"></a><span id="l11.197">   quoted: function gloda_content_quoted(aLineOrLines, aDepth, aOrigin,</span>
<a href="#l11.198"></a><span id="l11.198">       aTarget) {</span>
<a href="#l11.199"></a><span id="l11.199">     if (!this._producing)</span>
<a href="#l11.200"></a><span id="l11.200">       return;</span>
<a href="#l11.201"></a><span id="l11.201" class="difflineminus">-    </span>
<a href="#l11.202"></a><span id="l11.202" class="difflineplus">+</span>
<a href="#l11.203"></a><span id="l11.203">     let data;</span>
<a href="#l11.204"></a><span id="l11.204">     if (typeof(aLineOrLines) == &quot;string&quot;)</span>
<a href="#l11.205"></a><span id="l11.205">       data = aLineOrLines;</span>
<a href="#l11.206"></a><span id="l11.206">     else</span>
<a href="#l11.207"></a><span id="l11.207">       data = aLineOrLines.join(&quot;\n&quot;);</span>
<a href="#l11.208"></a><span id="l11.208"> </span>
<a href="#l11.209"></a><span id="l11.209">     if (!this._curHunk ||</span>
<a href="#l11.210"></a><span id="l11.210">         this._curHunk.hunkType != this.kHunkQuoted ||</span>
<a href="#l11.211"></a><span id="l11.211">         this._curHunk.depth != aDepth ||</span>
<a href="#l11.212"></a><span id="l11.212">         this._curHunk.origin != aOrigin || this._curHunk.target != aTarget) {</span>
<a href="#l11.213"></a><span id="l11.213">       this._curHunk = {hunkType: this.kHunkQuoted, data: data,</span>
<a href="#l11.214"></a><span id="l11.214">                        depth: aDepth, origin: aOrigin, target: aTarget};</span>
<a href="#l11.215"></a><span id="l11.215">       this._hunks.push(this._curHunk);</span>
<a href="#l11.216"></a><span id="l11.216">     }</span>
<a href="#l11.217"></a><span id="l11.217">     else</span>
<a href="#l11.218"></a><span id="l11.218" class="difflineminus">-      this._curHunk.data += &quot;\n&quot; + data; </span>
<a href="#l11.219"></a><span id="l11.219" class="difflineplus">+      this._curHunk.data += &quot;\n&quot; + data;</span>
<a href="#l11.220"></a><span id="l11.220">   },</span>
<a href="#l11.221"></a><span id="l11.221" class="difflineminus">-  </span>
<a href="#l11.222"></a><span id="l11.222" class="difflineplus">+</span>
<a href="#l11.223"></a><span id="l11.223">   content: function gloda_content_content(aLineOrLines) {</span>
<a href="#l11.224"></a><span id="l11.224">     if (!this._producing)</span>
<a href="#l11.225"></a><span id="l11.225">       return;</span>
<a href="#l11.226"></a><span id="l11.226"> </span>
<a href="#l11.227"></a><span id="l11.227">     let data;</span>
<a href="#l11.228"></a><span id="l11.228">     if (typeof(aLineOrLines) == &quot;string&quot;)</span>
<a href="#l11.229"></a><span id="l11.229">       data = aLineOrLines;</span>
<a href="#l11.230"></a><span id="l11.230">     else</span>
<a href="#l11.231"></a><span id="l11.231">       data = aLineOrLines.join(&quot;\n&quot;);</span>
<a href="#l11.232"></a><span id="l11.232" class="difflineminus">-    </span>
<a href="#l11.233"></a><span id="l11.233" class="difflineplus">+</span>
<a href="#l11.234"></a><span id="l11.234">     if (!this._curHunk || this._curHunk.hunkType != this.kHunkContent) {</span>
<a href="#l11.235"></a><span id="l11.235">       this._curHunk = {hunkType: this.kHunkContent, data: data};</span>
<a href="#l11.236"></a><span id="l11.236">       this._hunks.push(this._curHunk);</span>
<a href="#l11.237"></a><span id="l11.237">     }</span>
<a href="#l11.238"></a><span id="l11.238">     else</span>
<a href="#l11.239"></a><span id="l11.239">       this._curHunk.data += &quot;\n&quot; + data;</span>
<a href="#l11.240"></a><span id="l11.240">   },</span>
<a href="#l11.241"></a><span id="l11.241" class="difflineminus">-}</span>
<a href="#l11.242"></a><span id="l11.242" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/mailnews/db/gloda/modules/databind.js</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/databind.js</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -1,16 +1,16 @@</span>
<a href="#l12.4"></a><span id="l12.4"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l12.5"></a><span id="l12.5">  *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l12.6"></a><span id="l12.6">  *</span>
<a href="#l12.7"></a><span id="l12.7">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l12.8"></a><span id="l12.8">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l12.9"></a><span id="l12.9">  * the License. You may obtain a copy of the License at</span>
<a href="#l12.10"></a><span id="l12.10">  * http://www.mozilla.org/MPL/</span>
<a href="#l12.11"></a><span id="l12.11" class="difflineminus">- * </span>
<a href="#l12.12"></a><span id="l12.12" class="difflineplus">+ *</span>
<a href="#l12.13"></a><span id="l12.13">  * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l12.14"></a><span id="l12.14">  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l12.15"></a><span id="l12.15">  * for the specific language governing rights and limitations under the</span>
<a href="#l12.16"></a><span id="l12.16">  * License.</span>
<a href="#l12.17"></a><span id="l12.17">  *</span>
<a href="#l12.18"></a><span id="l12.18">  * The Original Code is Thunderbird Global Database.</span>
<a href="#l12.19"></a><span id="l12.19">  *</span>
<a href="#l12.20"></a><span id="l12.20">  * The Initial Developer of the Original Code is</span>
<a href="#l12.21"></a><span id="l12.21" class="difflineat">@@ -27,17 +27,17 @@</span>
<a href="#l12.22"></a><span id="l12.22">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l12.23"></a><span id="l12.23">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l12.24"></a><span id="l12.24">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l12.25"></a><span id="l12.25">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l12.26"></a><span id="l12.26">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l12.27"></a><span id="l12.27">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l12.28"></a><span id="l12.28">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l12.29"></a><span id="l12.29">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l12.30"></a><span id="l12.30" class="difflineminus">- * </span>
<a href="#l12.31"></a><span id="l12.31" class="difflineplus">+ *</span>
<a href="#l12.32"></a><span id="l12.32">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l12.33"></a><span id="l12.33"> </span>
<a href="#l12.34"></a><span id="l12.34"> EXPORTED_SYMBOLS = [&quot;GlodaDatabind&quot;];</span>
<a href="#l12.35"></a><span id="l12.35"> </span>
<a href="#l12.36"></a><span id="l12.36"> const Cc = Components.classes;</span>
<a href="#l12.37"></a><span id="l12.37"> const Ci = Components.interfaces;</span>
<a href="#l12.38"></a><span id="l12.38"> const Cr = Components.results;</span>
<a href="#l12.39"></a><span id="l12.39"> const Cu = Components.utils;</span>
<a href="#l12.40"></a><span id="l12.40" class="difflineat">@@ -47,90 +47,135 @@ Cu.import(&quot;resource://app/modules/gloda/</span>
<a href="#l12.41"></a><span id="l12.41"> let DBC_LOG = Log4Moz.repository.getLogger(&quot;gloda.ds.dbc&quot;);</span>
<a href="#l12.42"></a><span id="l12.42"> </span>
<a href="#l12.43"></a><span id="l12.43"> function GlodaDatabind(aNounDef, aDatastore) {</span>
<a href="#l12.44"></a><span id="l12.44">   this._nounDef = aNounDef;</span>
<a href="#l12.45"></a><span id="l12.45">   this._tableName = aNounDef.tableName;</span>
<a href="#l12.46"></a><span id="l12.46">   this._tableDef = aNounDef.schema;</span>
<a href="#l12.47"></a><span id="l12.47">   this._datastore = aDatastore;</span>
<a href="#l12.48"></a><span id="l12.48">   this._log = Log4Moz.repository.getLogger(&quot;gloda.databind.&quot; + this._tableName);</span>
<a href="#l12.49"></a><span id="l12.49" class="difflineminus">-  </span>
<a href="#l12.50"></a><span id="l12.50" class="difflineplus">+</span>
<a href="#l12.51"></a><span id="l12.51">   // process the column definitions and make sure they have an attribute mapping</span>
<a href="#l12.52"></a><span id="l12.52">   for each (let [, coldef] in Iterator(this._tableDef.columns)) {</span>
<a href="#l12.53"></a><span id="l12.53">     // default to the other dude's thing.</span>
<a href="#l12.54"></a><span id="l12.54">     if (coldef.length &lt; 3)</span>
<a href="#l12.55"></a><span id="l12.55">       coldef[2] = coldef[0];</span>
<a href="#l12.56"></a><span id="l12.56">     if (coldef[0] == &quot;id&quot;)</span>
<a href="#l12.57"></a><span id="l12.57">       this._idAttr = coldef[2];</span>
<a href="#l12.58"></a><span id="l12.58">   }</span>
<a href="#l12.59"></a><span id="l12.59"> </span>
<a href="#l12.60"></a><span id="l12.60">   this._nextId = 1;</span>
<a href="#l12.61"></a><span id="l12.61">   let stmt = this._datastore._createSyncStatement(</span>
<a href="#l12.62"></a><span id="l12.62">     &quot;SELECT MAX(id) FROM &quot; + this._tableName, true);</span>
<a href="#l12.63"></a><span id="l12.63">   if (stmt.executeStep()) {  // no chance of this SQLITE_BUSY on this call</span>
<a href="#l12.64"></a><span id="l12.64">     this._nextId = stmt.getInt64(0) + 1;</span>
<a href="#l12.65"></a><span id="l12.65">   }</span>
<a href="#l12.66"></a><span id="l12.66">   stmt.finalize();</span>
<a href="#l12.67"></a><span id="l12.67" class="difflineminus">-  </span>
<a href="#l12.68"></a><span id="l12.68" class="difflineplus">+</span>
<a href="#l12.69"></a><span id="l12.69">   let insertSql = &quot;INSERT INTO &quot; + this._tableName + &quot; (&quot; +</span>
<a href="#l12.70"></a><span id="l12.70">     [coldef[0] for each</span>
<a href="#l12.71"></a><span id="l12.71">      ([, coldef] in Iterator(this._tableDef.columns))].join(&quot;, &quot;) +</span>
<a href="#l12.72"></a><span id="l12.72">     &quot;) VALUES (&quot; +</span>
<a href="#l12.73"></a><span id="l12.73">     [(&quot;:&quot; + coldef[0]) for each</span>
<a href="#l12.74"></a><span id="l12.74">      ([, coldef] in Iterator(this._tableDef.columns))].join(&quot;, &quot;) +</span>
<a href="#l12.75"></a><span id="l12.75">     &quot;)&quot;;</span>
<a href="#l12.76"></a><span id="l12.76"> </span>
<a href="#l12.77"></a><span id="l12.77">   // For the update, we want the 'id' to be a constraint and not a value</span>
<a href="#l12.78"></a><span id="l12.78">   //  that gets set...</span>
<a href="#l12.79"></a><span id="l12.79">   let updateSql = &quot;UPDATE &quot; + this._tableName + &quot; SET &quot; +</span>
<a href="#l12.80"></a><span id="l12.80" class="difflineminus">-    [(coldef[0] + &quot;= ? &quot;) for each</span>
<a href="#l12.81"></a><span id="l12.81" class="difflineplus">+    [(coldef[0] + &quot;= :&quot; + coldef[0]) for each</span>
<a href="#l12.82"></a><span id="l12.82">      ([, coldef] in Iterator(this._tableDef.columns)) if</span>
<a href="#l12.83"></a><span id="l12.83">      (coldef[0] != &quot;id&quot;)].join(&quot;, &quot;) +</span>
<a href="#l12.84"></a><span id="l12.84">     &quot; WHERE id = :id&quot;;</span>
<a href="#l12.85"></a><span id="l12.85" class="difflineminus">-  </span>
<a href="#l12.86"></a><span id="l12.86" class="difflineplus">+</span>
<a href="#l12.87"></a><span id="l12.87">   this._insertStmt = aDatastore._createAsyncStatement(insertSql);</span>
<a href="#l12.88"></a><span id="l12.88">   this._updateStmt = aDatastore._createAsyncStatement(updateSql);</span>
<a href="#l12.89"></a><span id="l12.89" class="difflineplus">+</span>
<a href="#l12.90"></a><span id="l12.90" class="difflineplus">+  if (this._tableDef.fulltextColumns) {</span>
<a href="#l12.91"></a><span id="l12.91" class="difflineplus">+    let insertFulltextSql = &quot;INSERT INTO &quot; + this._tableName + &quot;Text (docid,&quot; +</span>
<a href="#l12.92"></a><span id="l12.92" class="difflineplus">+      [coldef[0] for each</span>
<a href="#l12.93"></a><span id="l12.93" class="difflineplus">+       ([, coldef] in Iterator(this._tableDef.fulltextColumns))].join(&quot;, &quot;) +</span>
<a href="#l12.94"></a><span id="l12.94" class="difflineplus">+      &quot;) VALUES (:id,&quot; +</span>
<a href="#l12.95"></a><span id="l12.95" class="difflineplus">+      [(&quot;:&quot; + coldef[0]) for each</span>
<a href="#l12.96"></a><span id="l12.96" class="difflineplus">+       ([, coldef] in Iterator(this._tableDef.fulltextColumns))].join(&quot;, &quot;) +</span>
<a href="#l12.97"></a><span id="l12.97" class="difflineplus">+      &quot;)&quot;;</span>
<a href="#l12.98"></a><span id="l12.98" class="difflineplus">+</span>
<a href="#l12.99"></a><span id="l12.99" class="difflineplus">+    // For the update, we want the 'id' to be a constraint and not a value</span>
<a href="#l12.100"></a><span id="l12.100" class="difflineplus">+    //  that gets set...</span>
<a href="#l12.101"></a><span id="l12.101" class="difflineplus">+    let updateFulltextSql = &quot;UPDATE &quot; + this._tableName + &quot;Text SET &quot; +</span>
<a href="#l12.102"></a><span id="l12.102" class="difflineplus">+      [(coldef[0] + &quot;= :&quot; + coldef[0]) for each</span>
<a href="#l12.103"></a><span id="l12.103" class="difflineplus">+       ([, coldef] in Iterator(this._tableDef.fulltextColumns)) if</span>
<a href="#l12.104"></a><span id="l12.104" class="difflineplus">+       (coldef[0] != &quot;id&quot;)].join(&quot;, &quot;) +</span>
<a href="#l12.105"></a><span id="l12.105" class="difflineplus">+      &quot; WHERE docid = :id&quot;;</span>
<a href="#l12.106"></a><span id="l12.106" class="difflineplus">+</span>
<a href="#l12.107"></a><span id="l12.107" class="difflineplus">+    this._insertFulltextStmt =</span>
<a href="#l12.108"></a><span id="l12.108" class="difflineplus">+      aDatastore._createAsyncStatement(insertFulltextSql);</span>
<a href="#l12.109"></a><span id="l12.109" class="difflineplus">+    this._updateFulltextStmt =</span>
<a href="#l12.110"></a><span id="l12.110" class="difflineplus">+      aDatastore._createAsyncStatement(updateFulltextSql);</span>
<a href="#l12.111"></a><span id="l12.111" class="difflineplus">+  }</span>
<a href="#l12.112"></a><span id="l12.112"> }</span>
<a href="#l12.113"></a><span id="l12.113"> </span>
<a href="#l12.114"></a><span id="l12.114"> GlodaDatabind.prototype = {</span>
<a href="#l12.115"></a><span id="l12.115">   objFromRow: function(aRow) {</span>
<a href="#l12.116"></a><span id="l12.116">     let getVariant = this._datastore._getVariant;</span>
<a href="#l12.117"></a><span id="l12.117">     let obj = new this._nounDef.class();</span>
<a href="#l12.118"></a><span id="l12.118">     for each (let [iCol, colDef] in Iterator(this._tableDef.columns)) {</span>
<a href="#l12.119"></a><span id="l12.119">       obj[colDef[2]] = getVariant(aRow, iCol);</span>
<a href="#l12.120"></a><span id="l12.120">     }</span>
<a href="#l12.121"></a><span id="l12.121">     return obj;</span>
<a href="#l12.122"></a><span id="l12.122">   },</span>
<a href="#l12.123"></a><span id="l12.123" class="difflineminus">-  </span>
<a href="#l12.124"></a><span id="l12.124" class="difflineplus">+</span>
<a href="#l12.125"></a><span id="l12.125">   objInsert: function(aThing) {</span>
<a href="#l12.126"></a><span id="l12.126">     if (!aThing[this._idAttr])</span>
<a href="#l12.127"></a><span id="l12.127">       aThing[this._idAttr] = this._nextId++;</span>
<a href="#l12.128"></a><span id="l12.128" class="difflineminus">-    </span>
<a href="#l12.129"></a><span id="l12.129" class="difflineplus">+</span>
<a href="#l12.130"></a><span id="l12.130">     let stmt = this._insertStmt;</span>
<a href="#l12.131"></a><span id="l12.131">     for each (let [iColDef, colDef] in Iterator(this._tableDef.columns)) {</span>
<a href="#l12.132"></a><span id="l12.132">       stmt.params[colDef[0]] = aThing[colDef[2]];</span>
<a href="#l12.133"></a><span id="l12.133">     }</span>
<a href="#l12.134"></a><span id="l12.134" class="difflineplus">+</span>
<a href="#l12.135"></a><span id="l12.135">     stmt.executeAsync(this._datastore.trackAsync());</span>
<a href="#l12.136"></a><span id="l12.136" class="difflineplus">+</span>
<a href="#l12.137"></a><span id="l12.137" class="difflineplus">+    if (this._insertFulltextStmt) {</span>
<a href="#l12.138"></a><span id="l12.138" class="difflineplus">+      stmt = this._insertFulltextStmt;</span>
<a href="#l12.139"></a><span id="l12.139" class="difflineplus">+      stmt.params.id = aThing[this._idAttr];</span>
<a href="#l12.140"></a><span id="l12.140" class="difflineplus">+      for each (let [iColDef, colDef] in</span>
<a href="#l12.141"></a><span id="l12.141" class="difflineplus">+                Iterator(this._tableDef.fulltextColumns)) {</span>
<a href="#l12.142"></a><span id="l12.142" class="difflineplus">+        stmt.params[colDef[0]] = aThing[colDef[2]];</span>
<a href="#l12.143"></a><span id="l12.143" class="difflineplus">+      }</span>
<a href="#l12.144"></a><span id="l12.144" class="difflineplus">+      stmt.executeAsync(this._datastore.trackAsync());</span>
<a href="#l12.145"></a><span id="l12.145" class="difflineplus">+    }</span>
<a href="#l12.146"></a><span id="l12.146">   },</span>
<a href="#l12.147"></a><span id="l12.147" class="difflineminus">-  </span>
<a href="#l12.148"></a><span id="l12.148" class="difflineplus">+</span>
<a href="#l12.149"></a><span id="l12.149">   objUpdate: function(aThing) {</span>
<a href="#l12.150"></a><span id="l12.150">     let stmt = this._insertStmt;</span>
<a href="#l12.151"></a><span id="l12.151">     // note, we specially bound the location of 'id' for the insert, but since</span>
<a href="#l12.152"></a><span id="l12.152">     //  we're using named bindings, there is nothing special about setting it</span>
<a href="#l12.153"></a><span id="l12.153">     for each (let [iColDef, colDef] in Iterator(this._tableDef.columns)) {</span>
<a href="#l12.154"></a><span id="l12.154">       stmt.params[colDef[0]] = aThing[colDef[2]];</span>
<a href="#l12.155"></a><span id="l12.155">     }</span>
<a href="#l12.156"></a><span id="l12.156">     stmt.executeAsync(this._datastore.trackAsync());</span>
<a href="#l12.157"></a><span id="l12.157" class="difflineplus">+</span>
<a href="#l12.158"></a><span id="l12.158" class="difflineplus">+    if (this._updateFulltextStmt) {</span>
<a href="#l12.159"></a><span id="l12.159" class="difflineplus">+      stmt = this._updateFulltextStmt;</span>
<a href="#l12.160"></a><span id="l12.160" class="difflineplus">+      // fulltextColumns does't include id/docid, need to explicitly set it</span>
<a href="#l12.161"></a><span id="l12.161" class="difflineplus">+      stmt.params.id = aThing[this._idAttr];</span>
<a href="#l12.162"></a><span id="l12.162" class="difflineplus">+      for each (let [iColDef, colDef] in</span>
<a href="#l12.163"></a><span id="l12.163" class="difflineplus">+                Iterator(this._tableDef.fulltextColumns)) {</span>
<a href="#l12.164"></a><span id="l12.164" class="difflineplus">+        stmt.params[colDef[0]] = aThing[colDef[2]];</span>
<a href="#l12.165"></a><span id="l12.165" class="difflineplus">+      }</span>
<a href="#l12.166"></a><span id="l12.166" class="difflineplus">+      stmt.executeAsync(this._datastore.trackAsync());</span>
<a href="#l12.167"></a><span id="l12.167" class="difflineplus">+    }</span>
<a href="#l12.168"></a><span id="l12.168">   },</span>
<a href="#l12.169"></a><span id="l12.169" class="difflineminus">-  </span>
<a href="#l12.170"></a><span id="l12.170" class="difflineplus">+</span>
<a href="#l12.171"></a><span id="l12.171">   adjustAttributes: function() {</span>
<a href="#l12.172"></a><span id="l12.172">     // just proxy the call over to the datastore... we have to do this for</span>
<a href="#l12.173"></a><span id="l12.173">     //  'this' reasons.  we don't refactor things to avoid this because it does</span>
<a href="#l12.174"></a><span id="l12.174">     //  make some sense to have all the methods exposed from a single object,</span>
<a href="#l12.175"></a><span id="l12.175">     //  even if the implementation does live elsewhere.</span>
<a href="#l12.176"></a><span id="l12.176">     return this._datastore.adjustAttributes.apply(this._datastore, arguments);</span>
<a href="#l12.177"></a><span id="l12.177">   },</span>
<a href="#l12.178"></a><span id="l12.178" class="difflineminus">-  </span>
<a href="#l12.179"></a><span id="l12.179" class="difflineplus">+</span>
<a href="#l12.180"></a><span id="l12.180">   // also proxied...</span>
<a href="#l12.181"></a><span id="l12.181">   queryFromQuery: function() {</span>
<a href="#l12.182"></a><span id="l12.182">     return this._datastore.queryFromQuery.apply(this._datastore, arguments);</span>
<a href="#l12.183"></a><span id="l12.183">   }</span>
<a href="#l12.184"></a><span id="l12.184"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -49,40 +49,40 @@ const LOG = Log4Moz.repository.getLogger</span>
<a href="#l13.4"></a><span id="l13.4"> </span>
<a href="#l13.5"></a><span id="l13.5"> Cu.import(&quot;resource://app/modules/gloda/utils.js&quot;);</span>
<a href="#l13.6"></a><span id="l13.6"> </span>
<a href="#l13.7"></a><span id="l13.7"> /**</span>
<a href="#l13.8"></a><span id="l13.8">  * @class Represents a gloda attribute definition's DB form.  This class</span>
<a href="#l13.9"></a><span id="l13.9">  *  stores the information in the database relating to this attribute</span>
<a href="#l13.10"></a><span id="l13.10">  *  definition.  Access its attrDef attribute to get at the realy juicy data.</span>
<a href="#l13.11"></a><span id="l13.11">  *  This main interesting thing this class does is serve as the keeper of the</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">- *  mapping from parameters to attribute ids in the database if this is a </span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+ *  mapping from parameters to attribute ids in the database if this is a</span>
<a href="#l13.14"></a><span id="l13.14">  *  parameterized attribute.</span>
<a href="#l13.15"></a><span id="l13.15">  */</span>
<a href="#l13.16"></a><span id="l13.16"> function GlodaAttributeDBDef(aDatastore, aID, aCompoundName, aAttrType,</span>
<a href="#l13.17"></a><span id="l13.17">                            aPluginName, aAttrName) {</span>
<a href="#l13.18"></a><span id="l13.18">   this._datastore = aDatastore;</span>
<a href="#l13.19"></a><span id="l13.19">   this._id = aID;</span>
<a href="#l13.20"></a><span id="l13.20">   this._compoundName = aCompoundName;</span>
<a href="#l13.21"></a><span id="l13.21">   this._attrType = aAttrType;</span>
<a href="#l13.22"></a><span id="l13.22">   this._pluginName = aPluginName;</span>
<a href="#l13.23"></a><span id="l13.23">   this._attrName = aAttrName;</span>
<a href="#l13.24"></a><span id="l13.24" class="difflineminus">-  </span>
<a href="#l13.25"></a><span id="l13.25" class="difflineplus">+</span>
<a href="#l13.26"></a><span id="l13.26">   this.attrDef = null;</span>
<a href="#l13.27"></a><span id="l13.27"> </span>
<a href="#l13.28"></a><span id="l13.28">   /** Map parameter values to the underlying database id. */</span>
<a href="#l13.29"></a><span id="l13.29">   this._parameterBindings = {};</span>
<a href="#l13.30"></a><span id="l13.30"> }</span>
<a href="#l13.31"></a><span id="l13.31"> </span>
<a href="#l13.32"></a><span id="l13.32"> GlodaAttributeDBDef.prototype = {</span>
<a href="#l13.33"></a><span id="l13.33">   get id() { return this._id; },</span>
<a href="#l13.34"></a><span id="l13.34">   get attributeName() { return this._attrName; },</span>
<a href="#l13.35"></a><span id="l13.35"> </span>
<a href="#l13.36"></a><span id="l13.36">   get parameterBindings() { return this._parameterBindings; },</span>
<a href="#l13.37"></a><span id="l13.37" class="difflineminus">-  </span>
<a href="#l13.38"></a><span id="l13.38" class="difflineplus">+</span>
<a href="#l13.39"></a><span id="l13.39">   /**</span>
<a href="#l13.40"></a><span id="l13.40">    * Bind a parameter value to the attribute definition, allowing use of the</span>
<a href="#l13.41"></a><span id="l13.41">    *  attribute-parameter as an attribute.</span>
<a href="#l13.42"></a><span id="l13.42">    *</span>
<a href="#l13.43"></a><span id="l13.43">    * @return</span>
<a href="#l13.44"></a><span id="l13.44">    */</span>
<a href="#l13.45"></a><span id="l13.45">   bindParameter: function gloda_attr_bindParameter(aValue) {</span>
<a href="#l13.46"></a><span id="l13.46">     // people probably shouldn't call us with null, but handle it</span>
<a href="#l13.47"></a><span id="l13.47" class="difflineat">@@ -159,17 +159,17 @@ let GlodaHasAttributesMixIn = {</span>
<a href="#l13.48"></a><span id="l13.48">       }</span>
<a href="#l13.49"></a><span id="l13.49">       else {</span>
<a href="#l13.50"></a><span id="l13.50">         // ignore attributes with no values</span>
<a href="#l13.51"></a><span id="l13.51">         if (value.length)</span>
<a href="#l13.52"></a><span id="l13.52">           yield [attrDef, value];</span>
<a href="#l13.53"></a><span id="l13.53">       }</span>
<a href="#l13.54"></a><span id="l13.54">     }</span>
<a href="#l13.55"></a><span id="l13.55">   },</span>
<a href="#l13.56"></a><span id="l13.56" class="difflineminus">-  </span>
<a href="#l13.57"></a><span id="l13.57" class="difflineplus">+</span>
<a href="#l13.58"></a><span id="l13.58">   domContribute: function gloda_attrix_domContribute(aDomNode) {</span>
<a href="#l13.59"></a><span id="l13.59">     let nounDef = this.NOUN_DEF;</span>
<a href="#l13.60"></a><span id="l13.60">     for each (let [attrName, attr] in</span>
<a href="#l13.61"></a><span id="l13.61">         Iterator(nounDef.domExposeAttribsByBoundName)) {</span>
<a href="#l13.62"></a><span id="l13.62">       if (this[attrName])</span>
<a href="#l13.63"></a><span id="l13.63">         aDomNode.setAttribute(attr.domExpose, this[attrName]);</span>
<a href="#l13.64"></a><span id="l13.64">     }</span>
<a href="#l13.65"></a><span id="l13.65">   },</span>
<a href="#l13.66"></a><span id="l13.66" class="difflineat">@@ -198,97 +198,122 @@ function GlodaConversation(aDatastore, a</span>
<a href="#l13.67"></a><span id="l13.67"> }</span>
<a href="#l13.68"></a><span id="l13.68"> </span>
<a href="#l13.69"></a><span id="l13.69"> GlodaConversation.prototype = {</span>
<a href="#l13.70"></a><span id="l13.70">   NOUN_ID: 101,</span>
<a href="#l13.71"></a><span id="l13.71">   get id() { return this._id; },</span>
<a href="#l13.72"></a><span id="l13.72">   get subject() { return this._subject; },</span>
<a href="#l13.73"></a><span id="l13.73">   get oldestMessageDate() { return this._oldestMessageDate; },</span>
<a href="#l13.74"></a><span id="l13.74">   get newestMessageDate() { return this._newestMessageDate; },</span>
<a href="#l13.75"></a><span id="l13.75" class="difflineminus">-  </span>
<a href="#l13.76"></a><span id="l13.76" class="difflineplus">+</span>
<a href="#l13.77"></a><span id="l13.77">   getMessagesCollection: function gloda_conversation_getMessagesCollection(</span>
<a href="#l13.78"></a><span id="l13.78">     aListener, aData) {</span>
<a href="#l13.79"></a><span id="l13.79">     let query = new GlodaMessage.prototype.NOUN_DEF.queryClass();</span>
<a href="#l13.80"></a><span id="l13.80">     query.conversation(this._id).orderBy(&quot;date&quot;);</span>
<a href="#l13.81"></a><span id="l13.81">     return query.getCollection(aListener, aData);</span>
<a href="#l13.82"></a><span id="l13.82">   },</span>
<a href="#l13.83"></a><span id="l13.83"> </span>
<a href="#l13.84"></a><span id="l13.84">   toString: function gloda_conversation_toString() {</span>
<a href="#l13.85"></a><span id="l13.85">     return &quot;Conversation:&quot; + this._id;</span>
<a href="#l13.86"></a><span id="l13.86">   },</span>
<a href="#l13.87"></a><span id="l13.87"> };</span>
<a href="#l13.88"></a><span id="l13.88"> </span>
<a href="#l13.89"></a><span id="l13.89" class="difflineminus">-function GlodaFolder(aDatastore, aID, aURI, aDirtyStatus, aPrettyName) {</span>
<a href="#l13.90"></a><span id="l13.90" class="difflineplus">+function GlodaFolder(aDatastore, aID, aURI, aDirtyStatus, aPrettyName,</span>
<a href="#l13.91"></a><span id="l13.91" class="difflineplus">+                     aIndexingPriority) {</span>
<a href="#l13.92"></a><span id="l13.92">   this._datastore = aDatastore;</span>
<a href="#l13.93"></a><span id="l13.93">   this._id = aID;</span>
<a href="#l13.94"></a><span id="l13.94">   this._uri = aURI;</span>
<a href="#l13.95"></a><span id="l13.95">   this._dirtyStatus = aDirtyStatus;</span>
<a href="#l13.96"></a><span id="l13.96">   this._prettyName = aPrettyName;</span>
<a href="#l13.97"></a><span id="l13.97">   this._xpcomFolder = null;</span>
<a href="#l13.98"></a><span id="l13.98">   this._activeIndexing = false;</span>
<a href="#l13.99"></a><span id="l13.99">   this._activeHeaderRetrievalLastStamp = 0;</span>
<a href="#l13.100"></a><span id="l13.100" class="difflineplus">+  this._indexingPriority = aIndexingPriority;</span>
<a href="#l13.101"></a><span id="l13.101" class="difflineplus">+  this._deleted = false;</span>
<a href="#l13.102"></a><span id="l13.102"> }</span>
<a href="#l13.103"></a><span id="l13.103"> </span>
<a href="#l13.104"></a><span id="l13.104"> GlodaFolder.prototype = {</span>
<a href="#l13.105"></a><span id="l13.105">   NOUN_ID: 100,</span>
<a href="#l13.106"></a><span id="l13.106" class="difflineminus">-  </span>
<a href="#l13.107"></a><span id="l13.107" class="difflineplus">+</span>
<a href="#l13.108"></a><span id="l13.108">   /** The folder is believed to be up-to-date */</span>
<a href="#l13.109"></a><span id="l13.109">   kFolderClean: 0,</span>
<a href="#l13.110"></a><span id="l13.110">   /** The folder has some un-indexed or dirty messages */</span>
<a href="#l13.111"></a><span id="l13.111">   kFolderDirty: 1,</span>
<a href="#l13.112"></a><span id="l13.112">   /** The folder needs to be entirely re-indexed, regardless of the flags on</span>
<a href="#l13.113"></a><span id="l13.113">    * the messages in the folder. This state will be downgraded to dirty */</span>
<a href="#l13.114"></a><span id="l13.114">   kFolderFilthy: 2,</span>
<a href="#l13.115"></a><span id="l13.115" class="difflineminus">-  </span>
<a href="#l13.116"></a><span id="l13.116" class="difflineplus">+</span>
<a href="#l13.117"></a><span id="l13.117" class="difflineplus">+  /** The folder should never be indexed. */</span>
<a href="#l13.118"></a><span id="l13.118" class="difflineplus">+  kIndexingNeverPriority: -1,</span>
<a href="#l13.119"></a><span id="l13.119" class="difflineplus">+  /** The lowest priority assigned to a folder. */</span>
<a href="#l13.120"></a><span id="l13.120" class="difflineplus">+  kIndexingLowestPriority: 0,</span>
<a href="#l13.121"></a><span id="l13.121" class="difflineplus">+  /** The highest priority assigned to a folder. */</span>
<a href="#l13.122"></a><span id="l13.122" class="difflineplus">+  kIndexingHighestPriority: 100,</span>
<a href="#l13.123"></a><span id="l13.123" class="difflineplus">+</span>
<a href="#l13.124"></a><span id="l13.124" class="difflineplus">+  /** The indexing priority for a folder if no other priority is assigned. */</span>
<a href="#l13.125"></a><span id="l13.125" class="difflineplus">+  kIndexingDefaultPriority: 20,</span>
<a href="#l13.126"></a><span id="l13.126" class="difflineplus">+  /** Folders marked check new are slightly more important I guess. */</span>
<a href="#l13.127"></a><span id="l13.127" class="difflineplus">+  kIndexingCheckNewPriority: 30,</span>
<a href="#l13.128"></a><span id="l13.128" class="difflineplus">+  /** Favorite folders are more interesting to the user, presumably. */</span>
<a href="#l13.129"></a><span id="l13.129" class="difflineplus">+  kIndexingFavoritePriority: 40,</span>
<a href="#l13.130"></a><span id="l13.130" class="difflineplus">+  /** The indexing priority for inboxes. */</span>
<a href="#l13.131"></a><span id="l13.131" class="difflineplus">+  kIndexingInboxPriority: 50,</span>
<a href="#l13.132"></a><span id="l13.132" class="difflineplus">+  /** The indexing priority for sent mail folders. */</span>
<a href="#l13.133"></a><span id="l13.133" class="difflineplus">+  kIndexingSentMailPriority: 60,</span>
<a href="#l13.134"></a><span id="l13.134" class="difflineplus">+</span>
<a href="#l13.135"></a><span id="l13.135">   get id() { return this._id; },</span>
<a href="#l13.136"></a><span id="l13.136">   get uri() { return this._uri; },</span>
<a href="#l13.137"></a><span id="l13.137">   get dirtyStatus() { return this._dirtyStatus; },</span>
<a href="#l13.138"></a><span id="l13.138">   set dirtyStatus(aNewStatus) {</span>
<a href="#l13.139"></a><span id="l13.139">     if (aNewStatus != this._dirtyStatus) {</span>
<a href="#l13.140"></a><span id="l13.140">       this._dirtyStatus = aNewStatus;</span>
<a href="#l13.141"></a><span id="l13.141">       this._datastore.updateFolderDirtyStatus(this);</span>
<a href="#l13.142"></a><span id="l13.142">     }</span>
<a href="#l13.143"></a><span id="l13.143">   },</span>
<a href="#l13.144"></a><span id="l13.144">   get name() { return this._prettyName; },</span>
<a href="#l13.145"></a><span id="l13.145">   toString: function gloda_folder_toString() {</span>
<a href="#l13.146"></a><span id="l13.146">     return &quot;Folder:&quot; + this._id;</span>
<a href="#l13.147"></a><span id="l13.147">   },</span>
<a href="#l13.148"></a><span id="l13.148"> </span>
<a href="#l13.149"></a><span id="l13.149" class="difflineplus">+  get indexingPriority() {</span>
<a href="#l13.150"></a><span id="l13.150" class="difflineplus">+    return this._indexingPriority;</span>
<a href="#l13.151"></a><span id="l13.151" class="difflineplus">+  },</span>
<a href="#l13.152"></a><span id="l13.152" class="difflineplus">+</span>
<a href="#l13.153"></a><span id="l13.153">   /** We are going to index this folder. */</span>
<a href="#l13.154"></a><span id="l13.154">   kActivityIndexing: 0,</span>
<a href="#l13.155"></a><span id="l13.155">   /** Asking for the folder to perform header retrievals. */</span>
<a href="#l13.156"></a><span id="l13.156">   kActivityHeaderRetrieval: 1,</span>
<a href="#l13.157"></a><span id="l13.157" class="difflineminus">-  </span>
<a href="#l13.158"></a><span id="l13.158" class="difflineplus">+</span>
<a href="#l13.159"></a><span id="l13.159">   /** Is this folder known to be actively used for indexing? */</span>
<a href="#l13.160"></a><span id="l13.160">   _activeIndexing: false,</span>
<a href="#l13.161"></a><span id="l13.161">   /** Get our indexing status. */</span>
<a href="#l13.162"></a><span id="l13.162">   get indexing() {</span>
<a href="#l13.163"></a><span id="l13.163">     return this._activeIndexing;</span>
<a href="#l13.164"></a><span id="l13.164">   },</span>
<a href="#l13.165"></a><span id="l13.165">   /**</span>
<a href="#l13.166"></a><span id="l13.166">    * Set our indexing status.  Normally, this will be enabled through passing</span>
<a href="#l13.167"></a><span id="l13.167">    *  an activity type of kActivityIndexing (which will set us), but we will</span>
<a href="#l13.168"></a><span id="l13.168">    *  still need to be explicitly disabled by the indexing code.</span>
<a href="#l13.169"></a><span id="l13.169">    * When disabling indexing, we will call forgetFolderIfUnused to take care of</span>
<a href="#l13.170"></a><span id="l13.170">    *  shutting things down.</span>
<a href="#l13.171"></a><span id="l13.171">    * We are not responsible for committing changes to the message database!</span>
<a href="#l13.172"></a><span id="l13.172" class="difflineminus">-   *  That is on you! </span>
<a href="#l13.173"></a><span id="l13.173" class="difflineplus">+   *  That is on you!</span>
<a href="#l13.174"></a><span id="l13.174">    */</span>
<a href="#l13.175"></a><span id="l13.175">   set indexing(aIndexing) {</span>
<a href="#l13.176"></a><span id="l13.176">     this._activeIndexing = aIndexing;</span>
<a href="#l13.177"></a><span id="l13.177">     if (!aIndexing)</span>
<a href="#l13.178"></a><span id="l13.178">       this.forgetFolderIfUnused();</span>
<a href="#l13.179"></a><span id="l13.179">   },</span>
<a href="#l13.180"></a><span id="l13.180">   /** When was this folder last used for header retrieval purposes? */</span>
<a href="#l13.181"></a><span id="l13.181">   _activeHeaderRetrievalLastStamp: 0,</span>
<a href="#l13.182"></a><span id="l13.182" class="difflineminus">-  </span>
<a href="#l13.183"></a><span id="l13.183" class="difflineplus">+</span>
<a href="#l13.184"></a><span id="l13.184">   /**</span>
<a href="#l13.185"></a><span id="l13.185">    * Retrieve the nsIMsgFolder instance corresponding to this folder, providing</span>
<a href="#l13.186"></a><span id="l13.186">    *  an explanation of why you are requesting it for tracking/cleanup purposes.</span>
<a href="#l13.187"></a><span id="l13.187" class="difflineminus">-   * </span>
<a href="#l13.188"></a><span id="l13.188" class="difflineplus">+   *</span>
<a href="#l13.189"></a><span id="l13.189">    * @param aActivity One of the kActivity* constants.  If you pass</span>
<a href="#l13.190"></a><span id="l13.190">    *     kActivityIndexing, we will set indexing for you, but you will need to</span>
<a href="#l13.191"></a><span id="l13.191">    *     clear it when you are done.</span>
<a href="#l13.192"></a><span id="l13.192">    * @return The nsIMsgFolder if available, null on failure.</span>
<a href="#l13.193"></a><span id="l13.193">    */</span>
<a href="#l13.194"></a><span id="l13.194">   getXPCOMFolder: function gloda_folder_getXPCOMFolder(aActivity) {</span>
<a href="#l13.195"></a><span id="l13.195">     if (!this._xpcomFolder) {</span>
<a href="#l13.196"></a><span id="l13.196">       let rdfService = Cc['@mozilla.org/rdf/rdf-service;1']</span>
<a href="#l13.197"></a><span id="l13.197" class="difflineat">@@ -303,86 +328,88 @@ GlodaFolder.prototype = {</span>
<a href="#l13.198"></a><span id="l13.198">         this.indexing = true;</span>
<a href="#l13.199"></a><span id="l13.199">         break;</span>
<a href="#l13.200"></a><span id="l13.200">       case this.kActivityHeaderRetrieval:</span>
<a href="#l13.201"></a><span id="l13.201">         if (this._activeHeaderRetrievalLastStamp === 0)</span>
<a href="#l13.202"></a><span id="l13.202">           this._datastore.markFolderLive(this);</span>
<a href="#l13.203"></a><span id="l13.203">         this._activeHeaderRetrievalLastStamp = Date.now();</span>
<a href="#l13.204"></a><span id="l13.204">         break;</span>
<a href="#l13.205"></a><span id="l13.205">     }</span>
<a href="#l13.206"></a><span id="l13.206" class="difflineminus">-    </span>
<a href="#l13.207"></a><span id="l13.207" class="difflineplus">+</span>
<a href="#l13.208"></a><span id="l13.208">     return this._xpcomFolder;</span>
<a href="#l13.209"></a><span id="l13.209">   },</span>
<a href="#l13.210"></a><span id="l13.210" class="difflineminus">-  </span>
<a href="#l13.211"></a><span id="l13.211" class="difflineplus">+</span>
<a href="#l13.212"></a><span id="l13.212">   /**</span>
<a href="#l13.213"></a><span id="l13.213">    * How many milliseconds must a folder have not had any header retrieval</span>
<a href="#l13.214"></a><span id="l13.214">    *  activity before it's okay to lose the database reference?</span>
<a href="#l13.215"></a><span id="l13.215">    */</span>
<a href="#l13.216"></a><span id="l13.216">   ACCEPTABLY_OLD_THRESHOLD: 10000,</span>
<a href="#l13.217"></a><span id="l13.217" class="difflineminus">-  </span>
<a href="#l13.218"></a><span id="l13.218" class="difflineplus">+</span>
<a href="#l13.219"></a><span id="l13.219">   /**</span>
<a href="#l13.220"></a><span id="l13.220">    * Cleans up our nsIMsgFolder reference if we have one and it's not &quot;in use&quot;.</span>
<a href="#l13.221"></a><span id="l13.221">    * In use, from our perspective, means that it is not being used for indexing</span>
<a href="#l13.222"></a><span id="l13.222">    *  and some arbitrary interval of time has elapsed since it was last</span>
<a href="#l13.223"></a><span id="l13.223">    *  retrieved for header retrieval reasons.  The time interval is because if</span>
<a href="#l13.224"></a><span id="l13.224">    *  we have one GlodaMessage requesting a header, there's a high probability</span>
<a href="#l13.225"></a><span id="l13.225">    *  that another message will request a header in the near future.</span>
<a href="#l13.226"></a><span id="l13.226">    * Because setting indexing to false disables us, we are written in an</span>
<a href="#l13.227"></a><span id="l13.227">    *  idempotent fashion.  (It is possible for disabling indexing's call to us</span>
<a href="#l13.228"></a><span id="l13.228">    *  to cause us to return true but for the datastore's timer call to have not</span>
<a href="#l13.229"></a><span id="l13.229">    *  yet triggered.)</span>
<a href="#l13.230"></a><span id="l13.230" class="difflineminus">-   * </span>
<a href="#l13.231"></a><span id="l13.231" class="difflineplus">+   *</span>
<a href="#l13.232"></a><span id="l13.232">    * @returns true if we are cleaned up and can be considered 'dead', false if</span>
<a href="#l13.233"></a><span id="l13.233">    *     we should still be considered alive and this method should be called</span>
<a href="#l13.234"></a><span id="l13.234">    *     again in the future.</span>
<a href="#l13.235"></a><span id="l13.235">    */</span>
<a href="#l13.236"></a><span id="l13.236">   forgetFolderIfUnused: function gloda_folder_forgetFolderIfUnused() {</span>
<a href="#l13.237"></a><span id="l13.237">     // we are not cleaning/cleaned up if we are indexing</span>
<a href="#l13.238"></a><span id="l13.238">     if (this._activeIndexing)</span>
<a href="#l13.239"></a><span id="l13.239">       return false;</span>
<a href="#l13.240"></a><span id="l13.240" class="difflineminus">-    </span>
<a href="#l13.241"></a><span id="l13.241" class="difflineplus">+</span>
<a href="#l13.242"></a><span id="l13.242">     // set a point in the past as the threshold.  the timestamp must be older</span>
<a href="#l13.243"></a><span id="l13.243">     //  than this to be eligible for cleanup.</span>
<a href="#l13.244"></a><span id="l13.244">     let acceptablyOld = Date.now() - this.ACCEPTABLY_OLD_THRESHOLD;</span>
<a href="#l13.245"></a><span id="l13.245">     // we are not cleaning/cleaned up if we have retrieved a header more</span>
<a href="#l13.246"></a><span id="l13.246">     //  recently than the acceptably old threshold.</span>
<a href="#l13.247"></a><span id="l13.247">     if (this._activeHeaderRetrievalLastStamp &gt; acceptablyOld)</span>
<a href="#l13.248"></a><span id="l13.248">       return false;</span>
<a href="#l13.249"></a><span id="l13.249" class="difflineminus">-    </span>
<a href="#l13.250"></a><span id="l13.250" class="difflineplus">+</span>
<a href="#l13.251"></a><span id="l13.251">     if (this._xpcomFolder) {</span>
<a href="#l13.252"></a><span id="l13.252">       // This is the key action we take; the nsIMsgFolder will continue to</span>
<a href="#l13.253"></a><span id="l13.253">       //  exist, but we want it to forget about its database so that it can</span>
<a href="#l13.254"></a><span id="l13.254">       //  be closed and its memory can be reclaimed.</span>
<a href="#l13.255"></a><span id="l13.255">       this._xpcomFolder.msgDatabase = null;</span>
<a href="#l13.256"></a><span id="l13.256">       this._xpcomFolder = null;</span>
<a href="#l13.257"></a><span id="l13.257">       // since the last retrieval time tracks whether we have marked live or</span>
<a href="#l13.258"></a><span id="l13.258">       //  not, this needs to be reset to 0 too.</span>
<a href="#l13.259"></a><span id="l13.259">       this._activeHeaderRetrievalLastStamp = 0;</span>
<a href="#l13.260"></a><span id="l13.260">     }</span>
<a href="#l13.261"></a><span id="l13.261" class="difflineminus">-    </span>
<a href="#l13.262"></a><span id="l13.262" class="difflineplus">+</span>
<a href="#l13.263"></a><span id="l13.263">     return true;</span>
<a href="#l13.264"></a><span id="l13.264">   },</span>
<a href="#l13.265"></a><span id="l13.265" class="difflineminus">-}</span>
<a href="#l13.266"></a><span id="l13.266" class="difflineplus">+};</span>
<a href="#l13.267"></a><span id="l13.267"> </span>
<a href="#l13.268"></a><span id="l13.268"> /**</span>
<a href="#l13.269"></a><span id="l13.269">  * @class A message representation.</span>
<a href="#l13.270"></a><span id="l13.270">  */</span>
<a href="#l13.271"></a><span id="l13.271"> function GlodaMessage(aDatastore, aID, aFolderID, aMessageKey,</span>
<a href="#l13.272"></a><span id="l13.272">                       aConversationID, aConversation, aDate,</span>
<a href="#l13.273"></a><span id="l13.273">                       aHeaderMessageID, aDeleted, aJsonText,</span>
<a href="#l13.274"></a><span id="l13.274" class="difflineplus">+                      aNotability,</span>
<a href="#l13.275"></a><span id="l13.275">                       aSubject, aIndexedBodyText, aAttachmentNames) {</span>
<a href="#l13.276"></a><span id="l13.276">   this._datastore = aDatastore;</span>
<a href="#l13.277"></a><span id="l13.277">   this._id = aID;</span>
<a href="#l13.278"></a><span id="l13.278">   this._folderID = aFolderID;</span>
<a href="#l13.279"></a><span id="l13.279">   this._messageKey = aMessageKey;</span>
<a href="#l13.280"></a><span id="l13.280">   this._conversationID = aConversationID;</span>
<a href="#l13.281"></a><span id="l13.281">   this._conversation = aConversation;</span>
<a href="#l13.282"></a><span id="l13.282">   this._date = aDate;</span>
<a href="#l13.283"></a><span id="l13.283">   this._headerMessageID = aHeaderMessageID;</span>
<a href="#l13.284"></a><span id="l13.284">   this._jsonText = aJsonText;</span>
<a href="#l13.285"></a><span id="l13.285" class="difflineplus">+  this._notability = aNotability;</span>
<a href="#l13.286"></a><span id="l13.286">   this._subject = aSubject;</span>
<a href="#l13.287"></a><span id="l13.287">   this._indexedBodyText = aIndexedBodyText;</span>
<a href="#l13.288"></a><span id="l13.288">   this._attachmentNames = aAttachmentNames;</span>
<a href="#l13.289"></a><span id="l13.289"> </span>
<a href="#l13.290"></a><span id="l13.290">   // only set _deleted if we're deleted, otherwise the undefined does our</span>
<a href="#l13.291"></a><span id="l13.291">   //  speaking for us.</span>
<a href="#l13.292"></a><span id="l13.292">   if (aDeleted)</span>
<a href="#l13.293"></a><span id="l13.293">     this._deleted = aDeleted;</span>
<a href="#l13.294"></a><span id="l13.294" class="difflineat">@@ -391,29 +418,31 @@ function GlodaMessage(aDatastore, aID, a</span>
<a href="#l13.295"></a><span id="l13.295"> GlodaMessage.prototype = {</span>
<a href="#l13.296"></a><span id="l13.296">   NOUN_ID: 102,</span>
<a href="#l13.297"></a><span id="l13.297">   get id() { return this._id; },</span>
<a href="#l13.298"></a><span id="l13.298">   get folderID() { return this._folderID; },</span>
<a href="#l13.299"></a><span id="l13.299">   get messageKey() { return this._messageKey; },</span>
<a href="#l13.300"></a><span id="l13.300">   get conversationID() { return this._conversationID; },</span>
<a href="#l13.301"></a><span id="l13.301">   // conversation is special</span>
<a href="#l13.302"></a><span id="l13.302">   get headerMessageID() { return this._headerMessageID; },</span>
<a href="#l13.303"></a><span id="l13.303" class="difflineminus">-  </span>
<a href="#l13.304"></a><span id="l13.304" class="difflineplus">+  get notability() { return this._notability; },</span>
<a href="#l13.305"></a><span id="l13.305" class="difflineplus">+  set notability(aNotability) { this._notability = aNotability; },</span>
<a href="#l13.306"></a><span id="l13.306" class="difflineplus">+</span>
<a href="#l13.307"></a><span id="l13.307">   get subject() { return this._subject; },</span>
<a href="#l13.308"></a><span id="l13.308">   get indexedBodyText() { return this._indexedBodyText; },</span>
<a href="#l13.309"></a><span id="l13.309">   get attachmentNames() { return this._attachmentNames; },</span>
<a href="#l13.310"></a><span id="l13.310" class="difflineminus">-  </span>
<a href="#l13.311"></a><span id="l13.311" class="difflineplus">+</span>
<a href="#l13.312"></a><span id="l13.312">   get date() { return this._date; },</span>
<a href="#l13.313"></a><span id="l13.313">   set date(aNewDate) { this._date = aNewDate; },</span>
<a href="#l13.314"></a><span id="l13.314"> </span>
<a href="#l13.315"></a><span id="l13.315">   get folder() {</span>
<a href="#l13.316"></a><span id="l13.316">     if (this._folderID != null)</span>
<a href="#l13.317"></a><span id="l13.317">       return this._datastore._mapFolderID(this._folderID);</span>
<a href="#l13.318"></a><span id="l13.318">     else</span>
<a href="#l13.319"></a><span id="l13.319" class="difflineminus">-      return null;    </span>
<a href="#l13.320"></a><span id="l13.320" class="difflineplus">+      return null;</span>
<a href="#l13.321"></a><span id="l13.321">   },</span>
<a href="#l13.322"></a><span id="l13.322">   get folderURI() {</span>
<a href="#l13.323"></a><span id="l13.323">     if (this._folderID != null)</span>
<a href="#l13.324"></a><span id="l13.324">       return this._datastore._mapFolderID(this._folderID).uri;</span>
<a href="#l13.325"></a><span id="l13.325">     else</span>
<a href="#l13.326"></a><span id="l13.326">       return null;</span>
<a href="#l13.327"></a><span id="l13.327">   },</span>
<a href="#l13.328"></a><span id="l13.328">   get conversation() {</span>
<a href="#l13.329"></a><span id="l13.329" class="difflineat">@@ -447,39 +476,45 @@ GlodaMessage.prototype = {</span>
<a href="#l13.330"></a><span id="l13.330"> </span>
<a href="#l13.331"></a><span id="l13.331">     this._datastore = null;</span>
<a href="#l13.332"></a><span id="l13.332">   },</span>
<a href="#l13.333"></a><span id="l13.333"> </span>
<a href="#l13.334"></a><span id="l13.334">   /**</span>
<a href="#l13.335"></a><span id="l13.335">    * Return the underlying nsIMsgDBHdr from the folder storage for this, or</span>
<a href="#l13.336"></a><span id="l13.336">    *  null if the message does not exist for one reason or another.  We may log</span>
<a href="#l13.337"></a><span id="l13.337">    *  to our logger in the failure cases.</span>
<a href="#l13.338"></a><span id="l13.338" class="difflineminus">-   *  </span>
<a href="#l13.339"></a><span id="l13.339" class="difflineplus">+   *</span>
<a href="#l13.340"></a><span id="l13.340">    * This method no longer caches the result, so if you need to hold onto it,</span>
<a href="#l13.341"></a><span id="l13.341">    *  hold onto it.</span>
<a href="#l13.342"></a><span id="l13.342">    *</span>
<a href="#l13.343"></a><span id="l13.343">    * In the process of retrieving the underlying message header, we may have to</span>
<a href="#l13.344"></a><span id="l13.344">    *  open the message header database associated with the folder.  This may</span>
<a href="#l13.345"></a><span id="l13.345">    *  result in blocking while the load happens, so you may want to try and find</span>
<a href="#l13.346"></a><span id="l13.346">    *  an alternate way to initiate the load before calling us.</span>
<a href="#l13.347"></a><span id="l13.347">    * We provide hinting to the GlodaDatastore via the GlodaFolder so that it</span>
<a href="#l13.348"></a><span id="l13.348">    *  knows when it's a good time for it to go and detach from the database.</span>
<a href="#l13.349"></a><span id="l13.349" class="difflineminus">-   * </span>
<a href="#l13.350"></a><span id="l13.350" class="difflineplus">+   *</span>
<a href="#l13.351"></a><span id="l13.351">    * @returns The nsIMsgDBHdr associated with this message if available, null on</span>
<a href="#l13.352"></a><span id="l13.352">    *     failure.</span>
<a href="#l13.353"></a><span id="l13.353">    */</span>
<a href="#l13.354"></a><span id="l13.354">   get folderMessage() {</span>
<a href="#l13.355"></a><span id="l13.355">     if (this._folderID === null || this._messageKey === null)</span>
<a href="#l13.356"></a><span id="l13.356">       return null;</span>
<a href="#l13.357"></a><span id="l13.357" class="difflineminus">-    </span>
<a href="#l13.358"></a><span id="l13.358" class="difflineplus">+</span>
<a href="#l13.359"></a><span id="l13.359">     let glodaFolder = this._datastore._mapFolderID(this._folderID);</span>
<a href="#l13.360"></a><span id="l13.360">     let folder = glodaFolder.getXPCOMFolder(</span>
<a href="#l13.361"></a><span id="l13.361">                    glodaFolder.kActivityHeaderRetrieval);</span>
<a href="#l13.362"></a><span id="l13.362">     if (folder) {</span>
<a href="#l13.363"></a><span id="l13.363" class="difflineminus">-      let folderMessage = folder.GetMessageHeader(this._messageKey);</span>
<a href="#l13.364"></a><span id="l13.364" class="difflineplus">+      let folderMessage;</span>
<a href="#l13.365"></a><span id="l13.365" class="difflineplus">+      try {</span>
<a href="#l13.366"></a><span id="l13.366" class="difflineplus">+        folderMessage = folder.GetMessageHeader(this._messageKey);</span>
<a href="#l13.367"></a><span id="l13.367" class="difflineplus">+      }</span>
<a href="#l13.368"></a><span id="l13.368" class="difflineplus">+      catch (ex) {</span>
<a href="#l13.369"></a><span id="l13.369" class="difflineplus">+        folderMessage = null;</span>
<a href="#l13.370"></a><span id="l13.370" class="difflineplus">+      }</span>
<a href="#l13.371"></a><span id="l13.371">       if (folderMessage !== null) {</span>
<a href="#l13.372"></a><span id="l13.372">         // verify the message-id header matches what we expect...</span>
<a href="#l13.373"></a><span id="l13.373">         if (folderMessage.messageId != this._headerMessageID) {</span>
<a href="#l13.374"></a><span id="l13.374">           LOG.info(&quot;Message with message key does not match expected &quot; +</span>
<a href="#l13.375"></a><span id="l13.375">                    &quot;header! (&quot; + this._headerMessageID + &quot; expected, got &quot; +</span>
<a href="#l13.376"></a><span id="l13.376">                    folderMessage.messageId + &quot;)&quot;);</span>
<a href="#l13.377"></a><span id="l13.377">           folderMessage = null;</span>
<a href="#l13.378"></a><span id="l13.378">         }</span>
<a href="#l13.379"></a><span id="l13.379" class="difflineat">@@ -546,17 +581,17 @@ GlodaContact.prototype = {</span>
<a href="#l13.380"></a><span id="l13.380"> </span>
<a href="#l13.381"></a><span id="l13.381">   get identities() {</span>
<a href="#l13.382"></a><span id="l13.382">     return this._identities;</span>
<a href="#l13.383"></a><span id="l13.383">   },</span>
<a href="#l13.384"></a><span id="l13.384"> </span>
<a href="#l13.385"></a><span id="l13.385">   toString: function gloda_contact_toString() {</span>
<a href="#l13.386"></a><span id="l13.386">     return &quot;Contact:&quot; + this._id;</span>
<a href="#l13.387"></a><span id="l13.387">   },</span>
<a href="#l13.388"></a><span id="l13.388" class="difflineminus">-  </span>
<a href="#l13.389"></a><span id="l13.389" class="difflineplus">+</span>
<a href="#l13.390"></a><span id="l13.390">   get accessibleLabel() {</span>
<a href="#l13.391"></a><span id="l13.391">     return &quot;Contact: &quot; + this._name;</span>
<a href="#l13.392"></a><span id="l13.392">   },</span>
<a href="#l13.393"></a><span id="l13.393"> </span>
<a href="#l13.394"></a><span id="l13.394">   _clone: function gloda_contact_clone() {</span>
<a href="#l13.395"></a><span id="l13.395">     return new GlodaContact(this._datastore, this._id, this._directoryUUID,</span>
<a href="#l13.396"></a><span id="l13.396">       this._contactUUID, this._name, this._popularity, this._frecency);</span>
<a href="#l13.397"></a><span id="l13.397">   },</span>
<a href="#l13.398"></a><span id="l13.398" class="difflineat">@@ -572,16 +607,20 @@ function GlodaIdentity(aDatastore, aID, </span>
<a href="#l13.399"></a><span id="l13.399">   this._datastore = aDatastore;</span>
<a href="#l13.400"></a><span id="l13.400">   this._id = aID;</span>
<a href="#l13.401"></a><span id="l13.401">   this._contactID = aContactID;</span>
<a href="#l13.402"></a><span id="l13.402">   this._contact = aContact;</span>
<a href="#l13.403"></a><span id="l13.403">   this._kind = aKind;</span>
<a href="#l13.404"></a><span id="l13.404">   this._value = aValue;</span>
<a href="#l13.405"></a><span id="l13.405">   this._description = aDescription;</span>
<a href="#l13.406"></a><span id="l13.406">   this._isRelay = aIsRelay;</span>
<a href="#l13.407"></a><span id="l13.407" class="difflineplus">+  /// cached positive indicator of a card.  false means we don't know, not that</span>
<a href="#l13.408"></a><span id="l13.408" class="difflineplus">+  ///  we are confident there is no card.  (Users may star contacts with</span>
<a href="#l13.409"></a><span id="l13.409" class="difflineplus">+  ///  frequency, we don't want to latch on an erroneous value.)</span>
<a href="#l13.410"></a><span id="l13.410" class="difflineplus">+  this._hasAddressBookCard = false;</span>
<a href="#l13.411"></a><span id="l13.411"> }</span>
<a href="#l13.412"></a><span id="l13.412"> </span>
<a href="#l13.413"></a><span id="l13.413"> GlodaIdentity.prototype = {</span>
<a href="#l13.414"></a><span id="l13.414">   NOUN_ID: 104,</span>
<a href="#l13.415"></a><span id="l13.415">   get id() { return this._id; },</span>
<a href="#l13.416"></a><span id="l13.416">   get contactID() { return this._contactID; },</span>
<a href="#l13.417"></a><span id="l13.417">   get contact() { return this._contact; },</span>
<a href="#l13.418"></a><span id="l13.418">   get kind() { return this._kind; },</span>
<a href="#l13.419"></a><span id="l13.419" class="difflineat">@@ -593,18 +632,37 @@ GlodaIdentity.prototype = {</span>
<a href="#l13.420"></a><span id="l13.420">     return this._kind + &quot;@&quot; + this._value;</span>
<a href="#l13.421"></a><span id="l13.421">   },</span>
<a href="#l13.422"></a><span id="l13.422"> </span>
<a href="#l13.423"></a><span id="l13.423">   toString: function gloda_identity_toString() {</span>
<a href="#l13.424"></a><span id="l13.424">     return &quot;Identity:&quot; + this._kind + &quot;:&quot; + this._value;</span>
<a href="#l13.425"></a><span id="l13.425">   },</span>
<a href="#l13.426"></a><span id="l13.426"> </span>
<a href="#l13.427"></a><span id="l13.427">   get abCard() {</span>
<a href="#l13.428"></a><span id="l13.428" class="difflineminus">-    return GlodaUtils.getCardForEmail(this._value);</span>
<a href="#l13.429"></a><span id="l13.429" class="difflineplus">+    // for our purposes, the address book only speaks email</span>
<a href="#l13.430"></a><span id="l13.430" class="difflineplus">+    if (this._kind != &quot;email&quot;)</span>
<a href="#l13.431"></a><span id="l13.431" class="difflineplus">+      return false;</span>
<a href="#l13.432"></a><span id="l13.432" class="difflineplus">+    let card = GlodaUtils.getCardForEmail(this._value);</span>
<a href="#l13.433"></a><span id="l13.433" class="difflineplus">+    if (card)</span>
<a href="#l13.434"></a><span id="l13.434" class="difflineplus">+      this._hasAddressBookCard = true;</span>
<a href="#l13.435"></a><span id="l13.435" class="difflineplus">+    return card;</span>
<a href="#l13.436"></a><span id="l13.436">   },</span>
<a href="#l13.437"></a><span id="l13.437" class="difflineminus">-  </span>
<a href="#l13.438"></a><span id="l13.438" class="difflineplus">+</span>
<a href="#l13.439"></a><span id="l13.439" class="difflineplus">+  /**</span>
<a href="#l13.440"></a><span id="l13.440" class="difflineplus">+   * Indicate whether this person is in the user's address book. This differs</span>
<a href="#l13.441"></a><span id="l13.441" class="difflineplus">+   *  from abCard in that its semantics are cheaper.  We can cache/flag that</span>
<a href="#l13.442"></a><span id="l13.442" class="difflineplus">+   *  the identity is in the address book on disk whereas we can't keep the</span>
<a href="#l13.443"></a><span id="l13.443" class="difflineplus">+   *  card reference live easily right now (until UUIDs happen...)</span>
<a href="#l13.444"></a><span id="l13.444" class="difflineplus">+   * However, we currently don't cache the value, lest it screw us.</span>
<a href="#l13.445"></a><span id="l13.445" class="difflineplus">+   */</span>
<a href="#l13.446"></a><span id="l13.446" class="difflineplus">+  get inAddressBook() {</span>
<a href="#l13.447"></a><span id="l13.447" class="difflineplus">+    if (this._hasAddressBookCard)</span>
<a href="#l13.448"></a><span id="l13.448" class="difflineplus">+      return true;</span>
<a href="#l13.449"></a><span id="l13.449" class="difflineplus">+    return this.abCard &amp;&amp; true;</span>
<a href="#l13.450"></a><span id="l13.450" class="difflineplus">+  },</span>
<a href="#l13.451"></a><span id="l13.451" class="difflineplus">+</span>
<a href="#l13.452"></a><span id="l13.452">   pictureURL: function(aSize) {</span>
<a href="#l13.453"></a><span id="l13.453">     let md5hash = GlodaUtils.md5HashString(this._value);</span>
<a href="#l13.454"></a><span id="l13.454">     let gravURL = &quot;http://www.gravatar.com/avatar/&quot; + md5hash +</span>
<a href="#l13.455"></a><span id="l13.455">                                 &quot;?d=identicon&amp;s=&quot; + aSize + &quot;&amp;r=g&quot;;</span>
<a href="#l13.456"></a><span id="l13.456">     return gravURL;</span>
<a href="#l13.457"></a><span id="l13.457">   }</span>
<a href="#l13.458"></a><span id="l13.458"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -86,17 +86,17 @@ MessagesByMessageIdCallback.prototype = </span>
<a href="#l14.4"></a><span id="l14.4">     }</span>
<a href="#l14.5"></a><span id="l14.5">   },</span>
<a href="#l14.6"></a><span id="l14.6">   onItemsModified: function () {},</span>
<a href="#l14.7"></a><span id="l14.7">   onItemsRemoved: function () {},</span>
<a href="#l14.8"></a><span id="l14.8">   onQueryCompleted: function gloda_ds_mbmi_onQueryCompleted(aCollection) {</span>
<a href="#l14.9"></a><span id="l14.9">     // just outright bail if we are shutdown</span>
<a href="#l14.10"></a><span id="l14.10">     if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l14.11"></a><span id="l14.11">       return;</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">-    </span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+</span>
<a href="#l14.14"></a><span id="l14.14">     MBM_LOG.debug(&quot;query completed, notifying... &quot; + this.results);</span>
<a href="#l14.15"></a><span id="l14.15">     // we no longer need to unify; it is done for us.</span>
<a href="#l14.16"></a><span id="l14.16"> </span>
<a href="#l14.17"></a><span id="l14.17">     this.callback.call(this.callbackThis, this.results);</span>
<a href="#l14.18"></a><span id="l14.18">   }</span>
<a href="#l14.19"></a><span id="l14.19"> };</span>
<a href="#l14.20"></a><span id="l14.20"> </span>
<a href="#l14.21"></a><span id="l14.21"> let PCH_LOG = Log4Moz.repository.getLogger(&quot;gloda.ds.pch&quot;);</span>
<a href="#l14.22"></a><span id="l14.22" class="difflineat">@@ -104,21 +104,21 @@ let PCH_LOG = Log4Moz.repository.getLogg</span>
<a href="#l14.23"></a><span id="l14.23"> function PostCommitHandler(aCallbacks) {</span>
<a href="#l14.24"></a><span id="l14.24">   this.callbacks = aCallbacks;</span>
<a href="#l14.25"></a><span id="l14.25">   GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l14.26"></a><span id="l14.26"> }</span>
<a href="#l14.27"></a><span id="l14.27"> </span>
<a href="#l14.28"></a><span id="l14.28"> PostCommitHandler.prototype = {</span>
<a href="#l14.29"></a><span id="l14.29">   handleResult: function gloda_ds_pch_handleResult(aResultSet) {</span>
<a href="#l14.30"></a><span id="l14.30">   },</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineminus">-  </span>
<a href="#l14.32"></a><span id="l14.32" class="difflineplus">+</span>
<a href="#l14.33"></a><span id="l14.33">   handleError: function gloda_ds_pch_handleError(aError) {</span>
<a href="#l14.34"></a><span id="l14.34">     PCH_LOG.error(&quot;database error:&quot; + aError)</span>
<a href="#l14.35"></a><span id="l14.35">   },</span>
<a href="#l14.36"></a><span id="l14.36" class="difflineminus">-  </span>
<a href="#l14.37"></a><span id="l14.37" class="difflineplus">+</span>
<a href="#l14.38"></a><span id="l14.38">   handleCompletion: function gloda_ds_pch_handleCompletion(aReason) {</span>
<a href="#l14.39"></a><span id="l14.39">     // just outright bail if we are shutdown</span>
<a href="#l14.40"></a><span id="l14.40">     if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l14.41"></a><span id="l14.41">       return;</span>
<a href="#l14.42"></a><span id="l14.42"> </span>
<a href="#l14.43"></a><span id="l14.43">     if (aReason == Ci.mozIStorageStatementCallback.REASON_FINISHED) {</span>
<a href="#l14.44"></a><span id="l14.44">       for each (let [iCallback, callback] in Iterator(this.callbacks)) {</span>
<a href="#l14.45"></a><span id="l14.45">         try {</span>
<a href="#l14.46"></a><span id="l14.46" class="difflineat">@@ -131,17 +131,17 @@ PostCommitHandler.prototype = {</span>
<a href="#l14.47"></a><span id="l14.47">       }</span>
<a href="#l14.48"></a><span id="l14.48">     }</span>
<a href="#l14.49"></a><span id="l14.49">     try {</span>
<a href="#l14.50"></a><span id="l14.50">       GlodaDatastore._asyncCompleted();</span>
<a href="#l14.51"></a><span id="l14.51">     }</span>
<a href="#l14.52"></a><span id="l14.52">     catch (e) {</span>
<a href="#l14.53"></a><span id="l14.53">       PCH_LOG.error(&quot;Exception in handleCompletion: &quot; + e);</span>
<a href="#l14.54"></a><span id="l14.54">     }</span>
<a href="#l14.55"></a><span id="l14.55" class="difflineminus">-      </span>
<a href="#l14.56"></a><span id="l14.56" class="difflineplus">+</span>
<a href="#l14.57"></a><span id="l14.57">   }</span>
<a href="#l14.58"></a><span id="l14.58"> };</span>
<a href="#l14.59"></a><span id="l14.59"> </span>
<a href="#l14.60"></a><span id="l14.60"> let QFQ_LOG = Log4Moz.repository.getLogger(&quot;gloda.ds.qfq&quot;);</span>
<a href="#l14.61"></a><span id="l14.61"> </span>
<a href="#l14.62"></a><span id="l14.62"> let QueryFromQueryResolver = {</span>
<a href="#l14.63"></a><span id="l14.63">   onItemsAdded: function(aIgnoredItems, aCollection, aFake) {</span>
<a href="#l14.64"></a><span id="l14.64">     let originColl = aCollection.dataStack ? aCollection.dataStack.pop()</span>
<a href="#l14.65"></a><span id="l14.65" class="difflineat">@@ -151,40 +151,40 @@ let QueryFromQueryResolver = {</span>
<a href="#l14.66"></a><span id="l14.66">       aCollection.completionShifter.push(originColl);</span>
<a href="#l14.67"></a><span id="l14.67">     else</span>
<a href="#l14.68"></a><span id="l14.68">       aCollection.completionShifter = [originColl];</span>
<a href="#l14.69"></a><span id="l14.69"> </span>
<a href="#l14.70"></a><span id="l14.70">     if (!aFake) {</span>
<a href="#l14.71"></a><span id="l14.71">       originColl.deferredCount--;</span>
<a href="#l14.72"></a><span id="l14.72">       originColl.resolvedCount++;</span>
<a href="#l14.73"></a><span id="l14.73">     }</span>
<a href="#l14.74"></a><span id="l14.74" class="difflineminus">-    </span>
<a href="#l14.75"></a><span id="l14.75" class="difflineplus">+</span>
<a href="#l14.76"></a><span id="l14.76">     // bail if we are still pending on some other load completion</span>
<a href="#l14.77"></a><span id="l14.77">     if (originColl.deferredCount &gt; 0) {</span>
<a href="#l14.78"></a><span id="l14.78">       //QFQ_LOG.debug(&quot;QFQR: bailing &quot; + originColl._nounDef.name);</span>
<a href="#l14.79"></a><span id="l14.79">       return;</span>
<a href="#l14.80"></a><span id="l14.80">     }</span>
<a href="#l14.81"></a><span id="l14.81" class="difflineminus">-    </span>
<a href="#l14.82"></a><span id="l14.82" class="difflineplus">+</span>
<a href="#l14.83"></a><span id="l14.83">     let referencesByNounID = originColl.masterCollection.referencesByNounID;</span>
<a href="#l14.84"></a><span id="l14.84" class="difflineminus">-    let inverseReferencesByNounID = </span>
<a href="#l14.85"></a><span id="l14.85" class="difflineplus">+    let inverseReferencesByNounID =</span>
<a href="#l14.86"></a><span id="l14.86">       originColl.masterCollection.inverseReferencesByNounID;</span>
<a href="#l14.87"></a><span id="l14.87"> </span>
<a href="#l14.88"></a><span id="l14.88">     if (originColl.pendingItems) {</span>
<a href="#l14.89"></a><span id="l14.89">       for (let [, item] in Iterator(originColl.pendingItems)) {</span>
<a href="#l14.90"></a><span id="l14.90">         //QFQ_LOG.debug(&quot;QFQR: loading deferred &quot; + item.NOUN_ID + &quot;:&quot; + item.id);</span>
<a href="#l14.91"></a><span id="l14.91">         GlodaDatastore.loadNounDeferredDeps(item, referencesByNounID,</span>
<a href="#l14.92"></a><span id="l14.92">             inverseReferencesByNounID);</span>
<a href="#l14.93"></a><span id="l14.93">       }</span>
<a href="#l14.94"></a><span id="l14.94" class="difflineminus">-      </span>
<a href="#l14.95"></a><span id="l14.95" class="difflineplus">+</span>
<a href="#l14.96"></a><span id="l14.96">       // we need to consider the possibility that we are racing a collection very</span>
<a href="#l14.97"></a><span id="l14.97">       //  much like our own.  as such, this means we need to perform cache</span>
<a href="#l14.98"></a><span id="l14.98">       //  unification as our last step.</span>
<a href="#l14.99"></a><span id="l14.99">       GlodaCollectionManager.cacheLoadUnify(originColl._nounDef.id,</span>
<a href="#l14.100"></a><span id="l14.100">         originColl.pendingItems, false);</span>
<a href="#l14.101"></a><span id="l14.101" class="difflineminus">-  </span>
<a href="#l14.102"></a><span id="l14.102" class="difflineplus">+</span>
<a href="#l14.103"></a><span id="l14.103">       // just directly tell the collection about the items.  we know the query</span>
<a href="#l14.104"></a><span id="l14.104">       //  matches (at least until we introduce predicates that we cannot express</span>
<a href="#l14.105"></a><span id="l14.105">       //  in SQL.)</span>
<a href="#l14.106"></a><span id="l14.106">       //QFQ_LOG.debug(&quot; QFQR: about to trigger listener: &quot; + originColl._listener +</span>
<a href="#l14.107"></a><span id="l14.107">       //    &quot;with collection: &quot; + originColl._nounDef.name);</span>
<a href="#l14.108"></a><span id="l14.108">       originColl._onItemsAdded(originColl.pendingItems);</span>
<a href="#l14.109"></a><span id="l14.109">       delete originColl.pendingItems;</span>
<a href="#l14.110"></a><span id="l14.110">       delete originColl._pendingIdMap;</span>
<a href="#l14.111"></a><span id="l14.111" class="difflineat">@@ -208,124 +208,132 @@ let QueryFromQueryResolver = {</span>
<a href="#l14.112"></a><span id="l14.112"> /**</span>
<a href="#l14.113"></a><span id="l14.113">  * @class Handles the results from a GlodaDatastore.queryFromQuery call.</span>
<a href="#l14.114"></a><span id="l14.114">  * @constructor</span>
<a href="#l14.115"></a><span id="l14.115">  */</span>
<a href="#l14.116"></a><span id="l14.116"> function QueryFromQueryCallback(aStatement, aNounDef, aCollection) {</span>
<a href="#l14.117"></a><span id="l14.117">   this.statement = aStatement;</span>
<a href="#l14.118"></a><span id="l14.118">   this.nounDef = aNounDef;</span>
<a href="#l14.119"></a><span id="l14.119">   this.collection = aCollection;</span>
<a href="#l14.120"></a><span id="l14.120" class="difflineminus">-  </span>
<a href="#l14.121"></a><span id="l14.121" class="difflineplus">+</span>
<a href="#l14.122"></a><span id="l14.122">   //QFQ_LOG.debug(&quot;Creating QFQCallback for noun: &quot; + aNounDef.name);</span>
<a href="#l14.123"></a><span id="l14.123" class="difflineminus">-  </span>
<a href="#l14.124"></a><span id="l14.124" class="difflineplus">+</span>
<a href="#l14.125"></a><span id="l14.125">   // the master collection holds the referencesByNounID</span>
<a href="#l14.126"></a><span id="l14.126">   this.referencesByNounID = {};</span>
<a href="#l14.127"></a><span id="l14.127">   this.masterReferencesByNounID =</span>
<a href="#l14.128"></a><span id="l14.128">     this.collection.masterCollection.referencesByNounID;</span>
<a href="#l14.129"></a><span id="l14.129">   this.inverseReferencesByNounID = {};</span>
<a href="#l14.130"></a><span id="l14.130">   this.masterInverseReferencesByNounID =</span>
<a href="#l14.131"></a><span id="l14.131">     this.collection.masterCollection.inverseReferencesByNounID;</span>
<a href="#l14.132"></a><span id="l14.132" class="difflineminus">-  // we need to contribute our references as we load things; we need this </span>
<a href="#l14.133"></a><span id="l14.133" class="difflineplus">+  // we need to contribute our references as we load things; we need this</span>
<a href="#l14.134"></a><span id="l14.134">   //  because of the potential for circular dependencies and our inability to</span>
<a href="#l14.135"></a><span id="l14.135">   //  put things into the caching layer (or collection's _idMap) until we have</span>
<a href="#l14.136"></a><span id="l14.136">   //  fully resolved things.</span>
<a href="#l14.137"></a><span id="l14.137">   if (this.nounDef.id in this.masterReferencesByNounID)</span>
<a href="#l14.138"></a><span id="l14.138">     this.selfReferences = this.masterReferencesByNounID[this.nounDef.id];</span>
<a href="#l14.139"></a><span id="l14.139">   else</span>
<a href="#l14.140"></a><span id="l14.140">     this.selfReferences = this.masterReferencesByNounID[this.nounDef.id] = {};</span>
<a href="#l14.141"></a><span id="l14.141">   if (this.nounDef.parentColumnAttr) {</span>
<a href="#l14.142"></a><span id="l14.142">     if (this.nounDef.id in this.masterInverseReferencesByNounID)</span>
<a href="#l14.143"></a><span id="l14.143">       this.selfInverseReferences =</span>
<a href="#l14.144"></a><span id="l14.144">         this.masterInverseReferencesByNounID[this.nounDef.id];</span>
<a href="#l14.145"></a><span id="l14.145">     else</span>
<a href="#l14.146"></a><span id="l14.146">       this.selfInverseReferences =</span>
<a href="#l14.147"></a><span id="l14.147">         this.masterInverseReferencesByNounID[this.nounDef.id] = {};</span>
<a href="#l14.148"></a><span id="l14.148">   }</span>
<a href="#l14.149"></a><span id="l14.149" class="difflineminus">-  </span>
<a href="#l14.150"></a><span id="l14.150" class="difflineplus">+</span>
<a href="#l14.151"></a><span id="l14.151">   this.needsLoads = false;</span>
<a href="#l14.152"></a><span id="l14.152" class="difflineminus">-  </span>
<a href="#l14.153"></a><span id="l14.153" class="difflineplus">+</span>
<a href="#l14.154"></a><span id="l14.154">   GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l14.155"></a><span id="l14.155"> }</span>
<a href="#l14.156"></a><span id="l14.156"> </span>
<a href="#l14.157"></a><span id="l14.157"> QueryFromQueryCallback.prototype = {</span>
<a href="#l14.158"></a><span id="l14.158">   handleResult: function gloda_ds_qfq_handleResult(aResultSet) {</span>
<a href="#l14.159"></a><span id="l14.159">     try {</span>
<a href="#l14.160"></a><span id="l14.160">       // just outright bail if we are shutdown</span>
<a href="#l14.161"></a><span id="l14.161">       if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l14.162"></a><span id="l14.162">         return;</span>
<a href="#l14.163"></a><span id="l14.163"> </span>
<a href="#l14.164"></a><span id="l14.164">       let pendingItems = this.collection.pendingItems;</span>
<a href="#l14.165"></a><span id="l14.165">       let pendingIdMap = this.collection._pendingIdMap;</span>
<a href="#l14.166"></a><span id="l14.166">       let row;</span>
<a href="#l14.167"></a><span id="l14.167">       let nounDef = this.nounDef;</span>
<a href="#l14.168"></a><span id="l14.168">       let nounID = nounDef.id;</span>
<a href="#l14.169"></a><span id="l14.169" class="difflineminus">-      while (row = aResultSet.getNextRow()) {</span>
<a href="#l14.170"></a><span id="l14.170" class="difflineplus">+      while ((row = aResultSet.getNextRow())) {</span>
<a href="#l14.171"></a><span id="l14.171">         let item = nounDef.objFromRow.call(nounDef.datastore, row);</span>
<a href="#l14.172"></a><span id="l14.172" class="difflineplus">+        if (this.collection.stashedColumns) {</span>
<a href="#l14.173"></a><span id="l14.173" class="difflineplus">+          let stashed = this.collection.stashedColumns[item.id] = [];</span>
<a href="#l14.174"></a><span id="l14.174" class="difflineplus">+          for (let [,iCol] in</span>
<a href="#l14.175"></a><span id="l14.175" class="difflineplus">+               Iterator(this.collection.query.options.stashColumns)) {</span>
<a href="#l14.176"></a><span id="l14.176" class="difflineplus">+            stashed.push(GlodaDatastore._getVariant(row, iCol));</span>
<a href="#l14.177"></a><span id="l14.177" class="difflineplus">+          }</span>
<a href="#l14.178"></a><span id="l14.178" class="difflineplus">+        }</span>
<a href="#l14.179"></a><span id="l14.179">         // try and replace the item with one from the cache, if we can</span>
<a href="#l14.180"></a><span id="l14.180">         let cachedItem = GlodaCollectionManager.cacheLookupOne(nounID, item.id,</span>
<a href="#l14.181"></a><span id="l14.181">                                                                false);</span>
<a href="#l14.182"></a><span id="l14.182" class="difflineminus">-        </span>
<a href="#l14.183"></a><span id="l14.183" class="difflineplus">+</span>
<a href="#l14.184"></a><span id="l14.184">         // if we already have a copy in the pending id map, skip it</span>
<a href="#l14.185"></a><span id="l14.185">         if (item.id in pendingIdMap)</span>
<a href="#l14.186"></a><span id="l14.186">           continue;</span>
<a href="#l14.187"></a><span id="l14.187" class="difflineminus">-        </span>
<a href="#l14.188"></a><span id="l14.188" class="difflineplus">+</span>
<a href="#l14.189"></a><span id="l14.189">         //QFQ_LOG.debug(&quot;loading item &quot; + nounDef.id + &quot;:&quot; + item.id + &quot; existing: &quot; +</span>
<a href="#l14.190"></a><span id="l14.190">         //    this.selfReferences[item.id] + &quot; cached: &quot; + cachedItem);</span>
<a href="#l14.191"></a><span id="l14.191">         if (cachedItem)</span>
<a href="#l14.192"></a><span id="l14.192">           item = cachedItem;</span>
<a href="#l14.193"></a><span id="l14.193">         // we may already have been loaded by this process</span>
<a href="#l14.194"></a><span id="l14.194">         else if (this.selfReferences[item.id] != null)</span>
<a href="#l14.195"></a><span id="l14.195">           item = this.selfReferences[item.id];</span>
<a href="#l14.196"></a><span id="l14.196">         // perform loading logic which may produce reference dependencies</span>
<a href="#l14.197"></a><span id="l14.197">         else</span>
<a href="#l14.198"></a><span id="l14.198" class="difflineminus">-          this.needsLoads = </span>
<a href="#l14.199"></a><span id="l14.199" class="difflineplus">+          this.needsLoads =</span>
<a href="#l14.200"></a><span id="l14.200">             GlodaDatastore.loadNounItem(item, this.referencesByNounID,</span>
<a href="#l14.201"></a><span id="l14.201">                                         this.inverseReferencesByNounID) ||</span>
<a href="#l14.202"></a><span id="l14.202">             this.needsLoads;</span>
<a href="#l14.203"></a><span id="l14.203" class="difflineminus">-        </span>
<a href="#l14.204"></a><span id="l14.204" class="difflineplus">+</span>
<a href="#l14.205"></a><span id="l14.205">         // add ourself to the references by our id</span>
<a href="#l14.206"></a><span id="l14.206">         // QFQ_LOG.debug(&quot;saving item &quot; + nounDef.id + &quot;:&quot; + item.id + &quot; to self-refs&quot;);</span>
<a href="#l14.207"></a><span id="l14.207">         this.selfReferences[item.id] = item;</span>
<a href="#l14.208"></a><span id="l14.208" class="difflineminus">-        </span>
<a href="#l14.209"></a><span id="l14.209" class="difflineplus">+</span>
<a href="#l14.210"></a><span id="l14.210">         // if we're tracking it, add ourselves to our parent's list of children</span>
<a href="#l14.211"></a><span id="l14.211">         //  too</span>
<a href="#l14.212"></a><span id="l14.212">         if (this.selfInverseReferences) {</span>
<a href="#l14.213"></a><span id="l14.213">           let parentID = item[nounDef.parentColumnAttr.idStorageAttributeName];</span>
<a href="#l14.214"></a><span id="l14.214">           let childrenList = this.selfInverseReferences[parentID];</span>
<a href="#l14.215"></a><span id="l14.215">           if (childrenList === undefined)</span>
<a href="#l14.216"></a><span id="l14.216">             childrenList = this.selfInverseReferences[parentID] = [];</span>
<a href="#l14.217"></a><span id="l14.217">           childrenList.push(item);</span>
<a href="#l14.218"></a><span id="l14.218">         }</span>
<a href="#l14.219"></a><span id="l14.219" class="difflineminus">-        </span>
<a href="#l14.220"></a><span id="l14.220" class="difflineplus">+</span>
<a href="#l14.221"></a><span id="l14.221">         pendingItems.push(item);</span>
<a href="#l14.222"></a><span id="l14.222">         pendingIdMap[item.id] = item;</span>
<a href="#l14.223"></a><span id="l14.223">       }</span>
<a href="#l14.224"></a><span id="l14.224">     }</span>
<a href="#l14.225"></a><span id="l14.225">     catch (e) {</span>
<a href="#l14.226"></a><span id="l14.226" class="difflineminus">-      GlodaDatastore._log.error(&quot;Exception in handleResult: &quot; + e);</span>
<a href="#l14.227"></a><span id="l14.227" class="difflineplus">+      GlodaDatastore._log.error(&quot;Exception in handleResult: (&quot; + e.fileName +</span>
<a href="#l14.228"></a><span id="l14.228" class="difflineplus">+                                &quot;:&quot; + e.lineNumber + &quot;): &quot; + e);</span>
<a href="#l14.229"></a><span id="l14.229">     }</span>
<a href="#l14.230"></a><span id="l14.230">   },</span>
<a href="#l14.231"></a><span id="l14.231"> </span>
<a href="#l14.232"></a><span id="l14.232">   handleError: function gloda_ds_qfq_handleError(aError) {</span>
<a href="#l14.233"></a><span id="l14.233">     GlodaDatastore._log.error(&quot;Async queryFromQuery error: &quot; +</span>
<a href="#l14.234"></a><span id="l14.234">       aError.result + &quot;: &quot; + aError.message);</span>
<a href="#l14.235"></a><span id="l14.235">   },</span>
<a href="#l14.236"></a><span id="l14.236"> </span>
<a href="#l14.237"></a><span id="l14.237">   handleCompletion: function gloda_ds_qfq_handleCompletion(aReason) {</span>
<a href="#l14.238"></a><span id="l14.238">     try {</span>
<a href="#l14.239"></a><span id="l14.239">       try {</span>
<a href="#l14.240"></a><span id="l14.240">         this.statement.finalize();</span>
<a href="#l14.241"></a><span id="l14.241">         this.statement = null;</span>
<a href="#l14.242"></a><span id="l14.242" class="difflineminus">-        </span>
<a href="#l14.243"></a><span id="l14.243" class="difflineplus">+</span>
<a href="#l14.244"></a><span id="l14.244">         // just outright bail if we are shutdown</span>
<a href="#l14.245"></a><span id="l14.245">         if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l14.246"></a><span id="l14.246">           return;</span>
<a href="#l14.247"></a><span id="l14.247" class="difflineminus">-        </span>
<a href="#l14.248"></a><span id="l14.248" class="difflineplus">+</span>
<a href="#l14.249"></a><span id="l14.249">         //QFQ_LOG.debug(&quot;handleCompletion: &quot; + this.collection._nounDef.name);</span>
<a href="#l14.250"></a><span id="l14.250" class="difflineminus">-        </span>
<a href="#l14.251"></a><span id="l14.251" class="difflineplus">+</span>
<a href="#l14.252"></a><span id="l14.252">         if (this.needsLoads) {</span>
<a href="#l14.253"></a><span id="l14.253">           for each (let [nounID, references] in Iterator(this.referencesByNounID)) {</span>
<a href="#l14.254"></a><span id="l14.254">             if (nounID == this.nounDef.id)</span>
<a href="#l14.255"></a><span id="l14.255">               continue;</span>
<a href="#l14.256"></a><span id="l14.256">             let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l14.257"></a><span id="l14.257">             //QFQ_LOG.debug(&quot;  have references for noun: &quot; + nounDef.name);</span>
<a href="#l14.258"></a><span id="l14.258">             // try and load them out of the cache/existing collections.  items in the</span>
<a href="#l14.259"></a><span id="l14.259">             //  cache will be fully formed, which is nice for us.</span>
<a href="#l14.260"></a><span id="l14.260" class="difflineat">@@ -341,83 +349,83 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l14.261"></a><span id="l14.261">             let outReferences;</span>
<a href="#l14.262"></a><span id="l14.262">             if (nounDef.parentColumnAttr)</span>
<a href="#l14.263"></a><span id="l14.263">               outReferences = {};</span>
<a href="#l14.264"></a><span id="l14.264">             else</span>
<a href="#l14.265"></a><span id="l14.265">               outReferences = masterReferences;</span>
<a href="#l14.266"></a><span id="l14.266">             let [foundCount, notFoundCount, notFound] =</span>
<a href="#l14.267"></a><span id="l14.267">               GlodaCollectionManager.cacheLookupMany(nounDef.id, references,</span>
<a href="#l14.268"></a><span id="l14.268">                   outReferences);</span>
<a href="#l14.269"></a><span id="l14.269" class="difflineminus">-    </span>
<a href="#l14.270"></a><span id="l14.270" class="difflineplus">+</span>
<a href="#l14.271"></a><span id="l14.271">             if (nounDef.parentColumnAttr) {</span>
<a href="#l14.272"></a><span id="l14.272">               let inverseReferences;</span>
<a href="#l14.273"></a><span id="l14.273">               if (nounDef.id in this.masterInverseReferencesByNounID)</span>
<a href="#l14.274"></a><span id="l14.274">                 inverseReferences =</span>
<a href="#l14.275"></a><span id="l14.275">                   this.masterInverseReferencesByNounID[nounDef.id];</span>
<a href="#l14.276"></a><span id="l14.276">               else</span>
<a href="#l14.277"></a><span id="l14.277">                 inverseReferences =</span>
<a href="#l14.278"></a><span id="l14.278">                   this.masterInverseReferencesByNounID[nounDef.id] = {};</span>
<a href="#l14.279"></a><span id="l14.279" class="difflineminus">-              </span>
<a href="#l14.280"></a><span id="l14.280" class="difflineplus">+</span>
<a href="#l14.281"></a><span id="l14.281">               for each (let item in outReferences) {</span>
<a href="#l14.282"></a><span id="l14.282">                 masterReferences[item.id] = item;</span>
<a href="#l14.283"></a><span id="l14.283">                 let parentID = item[nounDef.parentColumnAttr.idStorageAttributeName];</span>
<a href="#l14.284"></a><span id="l14.284">                 let childrenList = inverseReferences[parentID];</span>
<a href="#l14.285"></a><span id="l14.285">                 if (childrenList === undefined)</span>
<a href="#l14.286"></a><span id="l14.286">                   childrenList = inverseReferences[parentID] = [];</span>
<a href="#l14.287"></a><span id="l14.287">                 childrenList.push(item);</span>
<a href="#l14.288"></a><span id="l14.288">               }</span>
<a href="#l14.289"></a><span id="l14.289">             }</span>
<a href="#l14.290"></a><span id="l14.290" class="difflineminus">-            </span>
<a href="#l14.291"></a><span id="l14.291" class="difflineplus">+</span>
<a href="#l14.292"></a><span id="l14.292">             //QFQ_LOG.debug(&quot;  found: &quot; + foundCount + &quot; not found: &quot; + notFoundCount);</span>
<a href="#l14.293"></a><span id="l14.293">             if (notFoundCount === 0) {</span>
<a href="#l14.294"></a><span id="l14.294">               this.collection.resolvedCount++;</span>
<a href="#l14.295"></a><span id="l14.295">             }</span>
<a href="#l14.296"></a><span id="l14.296">             else {</span>
<a href="#l14.297"></a><span id="l14.297">               this.collection.deferredCount++;</span>
<a href="#l14.298"></a><span id="l14.298">               let query = new nounDef.queryClass();</span>
<a href="#l14.299"></a><span id="l14.299">               query.id.apply(query, [id for (id in notFound)]);</span>
<a href="#l14.300"></a><span id="l14.300" class="difflineminus">-              </span>
<a href="#l14.301"></a><span id="l14.301" class="difflineminus">-              this.collection.masterCollection.subCollections[nounDef.id] = </span>
<a href="#l14.302"></a><span id="l14.302" class="difflineminus">-                GlodaDatastore.queryFromQuery(query, QueryFromQueryResolver, </span>
<a href="#l14.303"></a><span id="l14.303" class="difflineplus">+</span>
<a href="#l14.304"></a><span id="l14.304" class="difflineplus">+              this.collection.masterCollection.subCollections[nounDef.id] =</span>
<a href="#l14.305"></a><span id="l14.305" class="difflineplus">+                GlodaDatastore.queryFromQuery(query, QueryFromQueryResolver,</span>
<a href="#l14.306"></a><span id="l14.306">                   this.collection,</span>
<a href="#l14.307"></a><span id="l14.307">                   // we fully expect/allow for there being no such subcollection yet.</span>
<a href="#l14.308"></a><span id="l14.308">                   this.collection.masterCollection.subCollections[nounDef.id],</span>
<a href="#l14.309"></a><span id="l14.309">                   this.collection.masterCollection,</span>
<a href="#l14.310"></a><span id="l14.310">                   /* become explicit */ true);</span>
<a href="#l14.311"></a><span id="l14.311">             }</span>
<a href="#l14.312"></a><span id="l14.312">           }</span>
<a href="#l14.313"></a><span id="l14.313" class="difflineminus">-          </span>
<a href="#l14.314"></a><span id="l14.314" class="difflineplus">+</span>
<a href="#l14.315"></a><span id="l14.315">           for each (let [nounID, inverseReferences] in</span>
<a href="#l14.316"></a><span id="l14.316">               Iterator(this.inverseReferencesByNounID)) {</span>
<a href="#l14.317"></a><span id="l14.317">             this.collection.deferredCount++;</span>
<a href="#l14.318"></a><span id="l14.318">             let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l14.319"></a><span id="l14.319" class="difflineminus">-            </span>
<a href="#l14.320"></a><span id="l14.320" class="difflineplus">+</span>
<a href="#l14.321"></a><span id="l14.321">             //QFQ_LOG.debug(&quot;Want to load inverse via &quot; + nounDef.parentColumnAttr.boundName);</span>
<a href="#l14.322"></a><span id="l14.322" class="difflineminus">-      </span>
<a href="#l14.323"></a><span id="l14.323" class="difflineplus">+</span>
<a href="#l14.324"></a><span id="l14.324">             let query = new nounDef.queryClass();</span>
<a href="#l14.325"></a><span id="l14.325">             // we want to constrain using the parent column</span>
<a href="#l14.326"></a><span id="l14.326">             let queryConstrainer = query[nounDef.parentColumnAttr.boundName];</span>
<a href="#l14.327"></a><span id="l14.327">             queryConstrainer.apply(query, [pid for (pid in inverseReferences)]);</span>
<a href="#l14.328"></a><span id="l14.328" class="difflineminus">-            this.collection.masterCollection.subCollections[nounDef.id] = </span>
<a href="#l14.329"></a><span id="l14.329" class="difflineplus">+            this.collection.masterCollection.subCollections[nounDef.id] =</span>
<a href="#l14.330"></a><span id="l14.330">               GlodaDatastore.queryFromQuery(query, QueryFromQueryResolver,</span>
<a href="#l14.331"></a><span id="l14.331">                 this.collection,</span>
<a href="#l14.332"></a><span id="l14.332">                 // we fully expect/allow for there being no such subcollection yet.</span>
<a href="#l14.333"></a><span id="l14.333">                 this.collection.masterCollection.subCollections[nounDef.id],</span>
<a href="#l14.334"></a><span id="l14.334">                 this.collection.masterCollection,</span>
<a href="#l14.335"></a><span id="l14.335">                 /* become explicit */ true);</span>
<a href="#l14.336"></a><span id="l14.336">           }</span>
<a href="#l14.337"></a><span id="l14.337">         }</span>
<a href="#l14.338"></a><span id="l14.338">         else {</span>
<a href="#l14.339"></a><span id="l14.339">           this.collection.deferredCount--;</span>
<a href="#l14.340"></a><span id="l14.340">           this.collection.resolvedCount++;</span>
<a href="#l14.341"></a><span id="l14.341">         }</span>
<a href="#l14.342"></a><span id="l14.342" class="difflineminus">-        </span>
<a href="#l14.343"></a><span id="l14.343" class="difflineplus">+</span>
<a href="#l14.344"></a><span id="l14.344">         //QFQ_LOG.debug(&quot;  defer: &quot; + this.collection.deferredCount +</span>
<a href="#l14.345"></a><span id="l14.345">         //              &quot; resolved: &quot; + this.collection.resolvedCount);</span>
<a href="#l14.346"></a><span id="l14.346" class="difflineminus">-        </span>
<a href="#l14.347"></a><span id="l14.347" class="difflineplus">+</span>
<a href="#l14.348"></a><span id="l14.348">         // process immediately and kick-up to the master collection...</span>
<a href="#l14.349"></a><span id="l14.349">         if (this.collection.deferredCount &lt;= 0) {</span>
<a href="#l14.350"></a><span id="l14.350">           // this guy will resolve everyone using referencesByNounID and issue the</span>
<a href="#l14.351"></a><span id="l14.351">           //  call to this.collection._onItemsAdded to propagate things to the</span>
<a href="#l14.352"></a><span id="l14.352">           //  next concerned subCollection or the actual listener if this is the</span>
<a href="#l14.353"></a><span id="l14.353">           //  master collection.  (Also, call _onQueryCompleted).</span>
<a href="#l14.354"></a><span id="l14.354">           QueryFromQueryResolver.onItemsAdded(null, {data: this.collection}, true);</span>
<a href="#l14.355"></a><span id="l14.355">           QueryFromQueryResolver.onQueryCompleted({data: this.collection});</span>
<a href="#l14.356"></a><span id="l14.356" class="difflineat">@@ -530,37 +538,38 @@ var GlodaDatastore = {</span>
<a href="#l14.357"></a><span id="l14.357"> </span>
<a href="#l14.358"></a><span id="l14.358">   /* see Gloda's documentation for these constants */</span>
<a href="#l14.359"></a><span id="l14.359">   kSpecialNotAtAll: 0,</span>
<a href="#l14.360"></a><span id="l14.360">   kSpecialColumn: 16,</span>
<a href="#l14.361"></a><span id="l14.361">   kSpecialColumnChildren: 16|1,</span>
<a href="#l14.362"></a><span id="l14.362">   kSpecialColumnParent: 16|2,</span>
<a href="#l14.363"></a><span id="l14.363">   kSpecialString: 32,</span>
<a href="#l14.364"></a><span id="l14.364">   kSpecialFulltext: 64,</span>
<a href="#l14.365"></a><span id="l14.365" class="difflineminus">-  </span>
<a href="#l14.366"></a><span id="l14.366" class="difflineplus">+</span>
<a href="#l14.367"></a><span id="l14.367">   kConstraintIdIn: 0,</span>
<a href="#l14.368"></a><span id="l14.368">   kConstraintIn: 1,</span>
<a href="#l14.369"></a><span id="l14.369">   kConstraintRanges: 2,</span>
<a href="#l14.370"></a><span id="l14.370">   kConstraintEquals: 3,</span>
<a href="#l14.371"></a><span id="l14.371">   kConstraintStringLike: 4,</span>
<a href="#l14.372"></a><span id="l14.372">   kConstraintFulltext: 5,</span>
<a href="#l14.373"></a><span id="l14.373"> </span>
<a href="#l14.374"></a><span id="l14.374">   /* ******************* SCHEMA ******************* */</span>
<a href="#l14.375"></a><span id="l14.375"> </span>
<a href="#l14.376"></a><span id="l14.376" class="difflineminus">-  _schemaVersion: 11,</span>
<a href="#l14.377"></a><span id="l14.377" class="difflineplus">+  _schemaVersion: 12,</span>
<a href="#l14.378"></a><span id="l14.378">   _schema: {</span>
<a href="#l14.379"></a><span id="l14.379">     tables: {</span>
<a href="#l14.380"></a><span id="l14.380"> </span>
<a href="#l14.381"></a><span id="l14.381">       // ----- Messages</span>
<a href="#l14.382"></a><span id="l14.382">       folderLocations: {</span>
<a href="#l14.383"></a><span id="l14.383">         columns: [</span>
<a href="#l14.384"></a><span id="l14.384">           [&quot;id&quot;, &quot;INTEGER PRIMARY KEY&quot;],</span>
<a href="#l14.385"></a><span id="l14.385">           [&quot;folderURI&quot;, &quot;TEXT NOT NULL&quot;],</span>
<a href="#l14.386"></a><span id="l14.386">           [&quot;dirtyStatus&quot;, &quot;INTEGER NOT NULL&quot;],</span>
<a href="#l14.387"></a><span id="l14.387">           [&quot;name&quot;, &quot;TEXT NOT NULL&quot;],</span>
<a href="#l14.388"></a><span id="l14.388" class="difflineplus">+          [&quot;indexingPriority&quot;, &quot;INTEGER NOT NULL&quot;],</span>
<a href="#l14.389"></a><span id="l14.389">         ],</span>
<a href="#l14.390"></a><span id="l14.390"> </span>
<a href="#l14.391"></a><span id="l14.391">         triggers: {</span>
<a href="#l14.392"></a><span id="l14.392">           delete: &quot;DELETE from messages WHERE folderID = OLD.id&quot;,</span>
<a href="#l14.393"></a><span id="l14.393">         },</span>
<a href="#l14.394"></a><span id="l14.394">       },</span>
<a href="#l14.395"></a><span id="l14.395"> </span>
<a href="#l14.396"></a><span id="l14.396">       conversations: {</span>
<a href="#l14.397"></a><span id="l14.397" class="difflineat">@@ -602,30 +611,37 @@ var GlodaDatastore = {</span>
<a href="#l14.398"></a><span id="l14.398">           [&quot;conversationID&quot;, &quot;INTEGER NOT NULL REFERENCES conversations(id)&quot;],</span>
<a href="#l14.399"></a><span id="l14.399">           [&quot;date&quot;, &quot;INTEGER&quot;],</span>
<a href="#l14.400"></a><span id="l14.400">           // we used to have the parentID, but because of the very real</span>
<a href="#l14.401"></a><span id="l14.401">           //  possibility of multiple copies of a message with a given</span>
<a href="#l14.402"></a><span id="l14.402">           //  message-id, the parentID concept is unreliable.</span>
<a href="#l14.403"></a><span id="l14.403">           [&quot;headerMessageID&quot;, &quot;TEXT&quot;],</span>
<a href="#l14.404"></a><span id="l14.404">           [&quot;deleted&quot;, &quot;INTEGER NOT NULL default 0&quot;],</span>
<a href="#l14.405"></a><span id="l14.405">           [&quot;jsonAttributes&quot;, &quot;TEXT&quot;],</span>
<a href="#l14.406"></a><span id="l14.406" class="difflineplus">+          // Notability attempts to capture the static 'interestingness' of a</span>
<a href="#l14.407"></a><span id="l14.407" class="difflineplus">+          //  message as a result of being starred/flagged, labeled, read</span>
<a href="#l14.408"></a><span id="l14.408" class="difflineplus">+          //  multiple times, authored by someone in your address book or that</span>
<a href="#l14.409"></a><span id="l14.409" class="difflineplus">+          //  you converse with a lot, etc.</span>
<a href="#l14.410"></a><span id="l14.410" class="difflineplus">+          [&quot;notability&quot;, &quot;INTEGER NOT NULL default 0&quot;],</span>
<a href="#l14.411"></a><span id="l14.411">         ],</span>
<a href="#l14.412"></a><span id="l14.412"> </span>
<a href="#l14.413"></a><span id="l14.413">         indices: {</span>
<a href="#l14.414"></a><span id="l14.414">           messageLocation: ['folderID', 'messageKey'],</span>
<a href="#l14.415"></a><span id="l14.415">           headerMessageID: ['headerMessageID'],</span>
<a href="#l14.416"></a><span id="l14.416">           conversationID: ['conversationID'],</span>
<a href="#l14.417"></a><span id="l14.417">           date: ['date'],</span>
<a href="#l14.418"></a><span id="l14.418">           deleted: ['deleted'],</span>
<a href="#l14.419"></a><span id="l14.419">         },</span>
<a href="#l14.420"></a><span id="l14.420"> </span>
<a href="#l14.421"></a><span id="l14.421">         fulltextColumns: [</span>
<a href="#l14.422"></a><span id="l14.422">           [&quot;subject&quot;, &quot;TEXT&quot;],</span>
<a href="#l14.423"></a><span id="l14.423">           [&quot;body&quot;, &quot;TEXT&quot;],</span>
<a href="#l14.424"></a><span id="l14.424">           [&quot;attachmentNames&quot;, &quot;TEXT&quot;],</span>
<a href="#l14.425"></a><span id="l14.425" class="difflineplus">+          [&quot;author&quot;, &quot;TEXT&quot;],</span>
<a href="#l14.426"></a><span id="l14.426" class="difflineplus">+          [&quot;recipients&quot;, &quot;TEXT&quot;],</span>
<a href="#l14.427"></a><span id="l14.427">         ],</span>
<a href="#l14.428"></a><span id="l14.428"> </span>
<a href="#l14.429"></a><span id="l14.429">         triggers: {</span>
<a href="#l14.430"></a><span id="l14.430">           delete: &quot;DELETE FROM messageAttributes WHERE messageID = OLD.id&quot;,</span>
<a href="#l14.431"></a><span id="l14.431">         },</span>
<a href="#l14.432"></a><span id="l14.432">       },</span>
<a href="#l14.433"></a><span id="l14.433"> </span>
<a href="#l14.434"></a><span id="l14.434">       // ----- Attributes</span>
<a href="#l14.435"></a><span id="l14.435" class="difflineat">@@ -737,17 +753,17 @@ var GlodaDatastore = {</span>
<a href="#l14.436"></a><span id="l14.436">   /**</span>
<a href="#l14.437"></a><span id="l14.437">    * Initialize logging, create the database if it doesn't exist, &quot;upgrade&quot; it</span>
<a href="#l14.438"></a><span id="l14.438">    *  if it does and it's not up-to-date, fill our authoritative folder uri/id</span>
<a href="#l14.439"></a><span id="l14.439">    *  mapping.</span>
<a href="#l14.440"></a><span id="l14.440">    */</span>
<a href="#l14.441"></a><span id="l14.441">   _init: function gloda_ds_init(aNsJSON, aNounIDToDef) {</span>
<a href="#l14.442"></a><span id="l14.442">     this._log = Log4Moz.repository.getLogger(&quot;gloda.datastore&quot;);</span>
<a href="#l14.443"></a><span id="l14.443">     this._log.debug(&quot;Beginning datastore initialization.&quot;);</span>
<a href="#l14.444"></a><span id="l14.444" class="difflineminus">-    </span>
<a href="#l14.445"></a><span id="l14.445" class="difflineplus">+</span>
<a href="#l14.446"></a><span id="l14.446">     this._json = aNsJSON;</span>
<a href="#l14.447"></a><span id="l14.447">     this._nounIDToDef = aNounIDToDef;</span>
<a href="#l14.448"></a><span id="l14.448"> </span>
<a href="#l14.449"></a><span id="l14.449">     // Get the path to our global database</span>
<a href="#l14.450"></a><span id="l14.450">     var dirService = Cc[&quot;@mozilla.org/file/directory_service;1&quot;].</span>
<a href="#l14.451"></a><span id="l14.451">                      getService(Ci.nsIProperties);</span>
<a href="#l14.452"></a><span id="l14.452">     var dbFile = dirService.get(&quot;ProfD&quot;, Ci.nsIFile);</span>
<a href="#l14.453"></a><span id="l14.453">     dbFile.append(&quot;global-messages-db.sqlite&quot;);</span>
<a href="#l14.454"></a><span id="l14.454" class="difflineat">@@ -792,28 +808,28 @@ var GlodaDatastore = {</span>
<a href="#l14.455"></a><span id="l14.455">     // we need to figure out the next id's for all of the tables where we</span>
<a href="#l14.456"></a><span id="l14.456">     //  manage that.</span>
<a href="#l14.457"></a><span id="l14.457">     this._log.debug(&quot;Populating managed id counters.&quot;);</span>
<a href="#l14.458"></a><span id="l14.458">     this._populateAttributeDefManagedId();</span>
<a href="#l14.459"></a><span id="l14.459">     this._populateConversationManagedId();</span>
<a href="#l14.460"></a><span id="l14.460">     this._populateMessageManagedId();</span>
<a href="#l14.461"></a><span id="l14.461">     this._populateContactManagedId();</span>
<a href="#l14.462"></a><span id="l14.462">     this._populateIdentityManagedId();</span>
<a href="#l14.463"></a><span id="l14.463" class="difflineminus">-    </span>
<a href="#l14.464"></a><span id="l14.464" class="difflineplus">+</span>
<a href="#l14.465"></a><span id="l14.465">     // create the timer we use to periodically drop our references to folders</span>
<a href="#l14.466"></a><span id="l14.466">     //  we no longer need XPCOM references to (or more significantly, their</span>
<a href="#l14.467"></a><span id="l14.467">     //  message databases.)</span>
<a href="#l14.468"></a><span id="l14.468">     this._folderCleanupTimer =</span>
<a href="#l14.469"></a><span id="l14.469">       Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l14.470"></a><span id="l14.470" class="difflineminus">-    </span>
<a href="#l14.471"></a><span id="l14.471" class="difflineplus">+</span>
<a href="#l14.472"></a><span id="l14.472">     this._log.debug(&quot;Completed datastore initialization.&quot;);</span>
<a href="#l14.473"></a><span id="l14.473">   },</span>
<a href="#l14.474"></a><span id="l14.474"> </span>
<a href="#l14.475"></a><span id="l14.475">   datastoreIsShutdown: false,</span>
<a href="#l14.476"></a><span id="l14.476" class="difflineminus">-  </span>
<a href="#l14.477"></a><span id="l14.477" class="difflineplus">+</span>
<a href="#l14.478"></a><span id="l14.478">   /**</span>
<a href="#l14.479"></a><span id="l14.479">    * Perform datastore shutdown.</span>
<a href="#l14.480"></a><span id="l14.480">    */</span>
<a href="#l14.481"></a><span id="l14.481">   shutdown: function gloda_ds_shutdown() {</span>
<a href="#l14.482"></a><span id="l14.482">     // clear out any pending transaction by committing it.</span>
<a href="#l14.483"></a><span id="l14.483">     // Although you might worry that this is potentially an arbitrary and</span>
<a href="#l14.484"></a><span id="l14.484">     //  inconsistent point to issue a commit, it is not.  Because we are going</span>
<a href="#l14.485"></a><span id="l14.485">     //  to be called from the main/UI thread, that means the indexer cannot be</span>
<a href="#l14.486"></a><span id="l14.486" class="difflineat">@@ -821,36 +837,36 @@ var GlodaDatastore = {</span>
<a href="#l14.487"></a><span id="l14.487">     //  when the database state AS ISSUED is coherent.  As noted below, the</span>
<a href="#l14.488"></a><span id="l14.488">     //  async execution queue will actually be drained to completion.</span>
<a href="#l14.489"></a><span id="l14.489">     while (this._transactionDepth) {</span>
<a href="#l14.490"></a><span id="l14.490">       this._log.info(&quot;Closing pending transaction out for shutdown.&quot;);</span>
<a href="#l14.491"></a><span id="l14.491">       // just schedule this function to be run again once the transaction has</span>
<a href="#l14.492"></a><span id="l14.492">       //  been closed out.</span>
<a href="#l14.493"></a><span id="l14.493">       this._commitTransaction();</span>
<a href="#l14.494"></a><span id="l14.494">     }</span>
<a href="#l14.495"></a><span id="l14.495" class="difflineminus">-    </span>
<a href="#l14.496"></a><span id="l14.496" class="difflineplus">+</span>
<a href="#l14.497"></a><span id="l14.497">     this.datastoreIsShutdown = true;</span>
<a href="#l14.498"></a><span id="l14.498"> </span>
<a href="#l14.499"></a><span id="l14.499">     // shutdown our folder cleanup timer, if active and null it out.</span>
<a href="#l14.500"></a><span id="l14.500">     if (this._folderCleanupActive)</span>
<a href="#l14.501"></a><span id="l14.501">       this._folderCleanupTimer.cancel();</span>
<a href="#l14.502"></a><span id="l14.502">     this._folderCleanupTimer = null;</span>
<a href="#l14.503"></a><span id="l14.503"> </span>
<a href="#l14.504"></a><span id="l14.504">     this._log.info(&quot;Closing db connection&quot;);</span>
<a href="#l14.505"></a><span id="l14.505" class="difflineminus">-    </span>
<a href="#l14.506"></a><span id="l14.506" class="difflineplus">+</span>
<a href="#l14.507"></a><span id="l14.507">     // we do not expect exceptions, but it's a good idea to avoid having our</span>
<a href="#l14.508"></a><span id="l14.508">     //  shutdown process explode.</span>
<a href="#l14.509"></a><span id="l14.509">     try {</span>
<a href="#l14.510"></a><span id="l14.510">       this._cleanupAsyncStatements();</span>
<a href="#l14.511"></a><span id="l14.511">       this._cleanupSyncStatements();</span>
<a href="#l14.512"></a><span id="l14.512">     }</span>
<a href="#l14.513"></a><span id="l14.513">     catch (ex) {</span>
<a href="#l14.514"></a><span id="l14.514">       this._log.debug(&quot;Unexpected exception during statement cleanup: &quot; + ex);</span>
<a href="#l14.515"></a><span id="l14.515">     }</span>
<a href="#l14.516"></a><span id="l14.516" class="difflineminus">-    </span>
<a href="#l14.517"></a><span id="l14.517" class="difflineplus">+</span>
<a href="#l14.518"></a><span id="l14.518">     // it's conceivable we might get a spurious exception here, but we really</span>
<a href="#l14.519"></a><span id="l14.519">     //  shouldn't get one.  again, we want to ensure shutdown runs to completion</span>
<a href="#l14.520"></a><span id="l14.520">     //  and doesn't break our caller.</span>
<a href="#l14.521"></a><span id="l14.521">     try {</span>
<a href="#l14.522"></a><span id="l14.522">       // This currently causes all pending asynchronous operations to be run to</span>
<a href="#l14.523"></a><span id="l14.523">       //  completion.  this simplifies things from a correctness perspective,</span>
<a href="#l14.524"></a><span id="l14.524">       //  and, honestly, is a lot easier than us tracking all of the async</span>
<a href="#l14.525"></a><span id="l14.525">       //  event tasks so that we can explicitly cancel them.</span>
<a href="#l14.526"></a><span id="l14.526" class="difflineat">@@ -861,17 +877,17 @@ var GlodaDatastore = {</span>
<a href="#l14.527"></a><span id="l14.527">       //  update the database state for a single message.</span>
<a href="#l14.528"></a><span id="l14.528">       // However, the potential for multiple pending expensive queries does</span>
<a href="#l14.529"></a><span id="l14.529">       //  exist, and it may be advisable to attempt to track and cancel those.</span>
<a href="#l14.530"></a><span id="l14.530">       //  For simplicity we don't currently do this, and I expect this should</span>
<a href="#l14.531"></a><span id="l14.531">       //  not pose a major problem, but those are famous last words.</span>
<a href="#l14.532"></a><span id="l14.532">       this.asyncConnection.close();</span>
<a href="#l14.533"></a><span id="l14.533">     }</span>
<a href="#l14.534"></a><span id="l14.534">     catch (ex) {</span>
<a href="#l14.535"></a><span id="l14.535" class="difflineminus">-      this._log.debug(&quot;Potentially expected exception during connection &quot; + </span>
<a href="#l14.536"></a><span id="l14.536" class="difflineplus">+      this._log.debug(&quot;Potentially expected exception during connection &quot; +</span>
<a href="#l14.537"></a><span id="l14.537">                       &quot;closure: &quot; + ex);</span>
<a href="#l14.538"></a><span id="l14.538">     }</span>
<a href="#l14.539"></a><span id="l14.539"> </span>
<a href="#l14.540"></a><span id="l14.540">     this.asyncConnection = null;</span>
<a href="#l14.541"></a><span id="l14.541">     this.syncConnection = null;</span>
<a href="#l14.542"></a><span id="l14.542">   },</span>
<a href="#l14.543"></a><span id="l14.543"> </span>
<a href="#l14.544"></a><span id="l14.544">   /**</span>
<a href="#l14.545"></a><span id="l14.545" class="difflineat">@@ -964,66 +980,55 @@ var GlodaDatastore = {</span>
<a href="#l14.546"></a><span id="l14.546">       // it doesn't! create it (and its potentially many variants)</span>
<a href="#l14.547"></a><span id="l14.547">       try {</span>
<a href="#l14.548"></a><span id="l14.548">         this._createTableSchema(this.asyncConnection, aNounDef.tableName,</span>
<a href="#l14.549"></a><span id="l14.549">                                 aNounDef.schema);</span>
<a href="#l14.550"></a><span id="l14.550">       }</span>
<a href="#l14.551"></a><span id="l14.551">       catch (ex) {</span>
<a href="#l14.552"></a><span id="l14.552">          this._log.error(&quot;Problem creating table &quot; + aNounDef.tableName + &quot; &quot; +</span>
<a href="#l14.553"></a><span id="l14.553">            &quot;because: &quot; + ex + &quot; at &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber);</span>
<a href="#l14.554"></a><span id="l14.554" class="difflineminus">-         return null;</span>
<a href="#l14.555"></a><span id="l14.555" class="difflineplus">+         return;</span>
<a href="#l14.556"></a><span id="l14.556">       }</span>
<a href="#l14.557"></a><span id="l14.557">     }</span>
<a href="#l14.558"></a><span id="l14.558"> </span>
<a href="#l14.559"></a><span id="l14.559">     aNounDef._dataBinder = new GlodaDatabind(aNounDef, this);</span>
<a href="#l14.560"></a><span id="l14.560">     aNounDef.datastore = aNounDef._dataBinder;</span>
<a href="#l14.561"></a><span id="l14.561">     aNounDef.objFromRow = aNounDef._dataBinder.objFromRow;</span>
<a href="#l14.562"></a><span id="l14.562">     aNounDef.objInsert = aNounDef._dataBinder.objInsert;</span>
<a href="#l14.563"></a><span id="l14.563">     aNounDef.objUpdate = aNounDef._dataBinder.objUpdate;</span>
<a href="#l14.564"></a><span id="l14.564">     aNounDef.dbAttribAdjuster = aNounDef._dataBinder.adjustAttributes;</span>
<a href="#l14.565"></a><span id="l14.565"> </span>
<a href="#l14.566"></a><span id="l14.566">     if (aNounDef.schema.genericAttributes) {</span>
<a href="#l14.567"></a><span id="l14.567">       aNounDef.attrTableName = aNounDef.tableName + &quot;Attributes&quot;;</span>
<a href="#l14.568"></a><span id="l14.568">       aNounDef.attrIDColumnName = &quot;nounID&quot;;</span>
<a href="#l14.569"></a><span id="l14.569">     }</span>
<a href="#l14.570"></a><span id="l14.570">   },</span>
<a href="#l14.571"></a><span id="l14.571"> </span>
<a href="#l14.572"></a><span id="l14.572" class="difflineplus">+  /**</span>
<a href="#l14.573"></a><span id="l14.573" class="difflineplus">+   * Migrate the database _to the latest version_.  We only keep enough logic</span>
<a href="#l14.574"></a><span id="l14.574" class="difflineplus">+   *  around to get us to the recent version.  This code is not a time machine!</span>
<a href="#l14.575"></a><span id="l14.575" class="difflineplus">+   *  If we need to blow away the database to get to the most recent version,</span>
<a href="#l14.576"></a><span id="l14.576" class="difflineplus">+   *  then that's the sum total of the migration!</span>
<a href="#l14.577"></a><span id="l14.577" class="difflineplus">+   */</span>
<a href="#l14.578"></a><span id="l14.578">   _migrate: function gloda_ds_migrate(aDBService, aDBFile, aDBConnection,</span>
<a href="#l14.579"></a><span id="l14.579">                                       aCurVersion, aNewVersion) {</span>
<a href="#l14.580"></a><span id="l14.580" class="difflineminus">-    // we purged our way up to version 8, so we can/must purge prior to 8.</span>
<a href="#l14.581"></a><span id="l14.581" class="difflineminus">-    if (aCurVersion &lt; 8) {</span>
<a href="#l14.582"></a><span id="l14.582" class="difflineplus">+</span>
<a href="#l14.583"></a><span id="l14.583" class="difflineplus">+    // version 12:</span>
<a href="#l14.584"></a><span id="l14.584" class="difflineplus">+    // - notability column added</span>
<a href="#l14.585"></a><span id="l14.585" class="difflineplus">+    // version 13:</span>
<a href="#l14.586"></a><span id="l14.586" class="difflineplus">+    // - we are adding a new fulltext index column. blow away!</span>
<a href="#l14.587"></a><span id="l14.587" class="difflineplus">+    if (aCurVersion &lt; 13) {</span>
<a href="#l14.588"></a><span id="l14.588">       aDBConnection.close();</span>
<a href="#l14.589"></a><span id="l14.589">       aDBFile.remove(false);</span>
<a href="#l14.590"></a><span id="l14.590">       this._log.warn(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l14.591"></a><span id="l14.591">       return this._createDB(aDBService, aDBFile);</span>
<a href="#l14.592"></a><span id="l14.592">     }</span>
<a href="#l14.593"></a><span id="l14.593" class="difflineminus">-    // version 9 just adds the contactAttributes table</span>
<a href="#l14.594"></a><span id="l14.594" class="difflineminus">-    if (aCurVersion &lt; 9) {</span>
<a href="#l14.595"></a><span id="l14.595" class="difflineminus">-      this._createTableSchema(aDBConnection, &quot;contactAttributes&quot;);</span>
<a href="#l14.596"></a><span id="l14.596" class="difflineminus">-    }</span>
<a href="#l14.597"></a><span id="l14.597" class="difflineminus">-    // version 10:</span>
<a href="#l14.598"></a><span id="l14.598" class="difflineminus">-    // we have so many changes here, not to mention semantic changes, that</span>
<a href="#l14.599"></a><span id="l14.599" class="difflineminus">-    //  purging is the right answer.</span>
<a href="#l14.600"></a><span id="l14.600" class="difflineminus">-    // - adds dirtyStatus, name to folderLocations</span>
<a href="#l14.601"></a><span id="l14.601" class="difflineminus">-    // - removes messageAttribFetch index from messageAttributes</span>
<a href="#l14.602"></a><span id="l14.602" class="difflineminus">-    // - removes conversationAttribFetch index from messageAttributes</span>
<a href="#l14.603"></a><span id="l14.603" class="difflineminus">-    // - removes contactAttribFetch index from contactAttributes</span>
<a href="#l14.604"></a><span id="l14.604" class="difflineminus">-    // - adds jsonAttributes column to messages table</span>
<a href="#l14.605"></a><span id="l14.605" class="difflineminus">-    // - adds jsonAttributes column to contacts table</span>
<a href="#l14.606"></a><span id="l14.606" class="difflineminus">-    // version 11:</span>
<a href="#l14.607"></a><span id="l14.607" class="difflineminus">-    // we, uh, had a bad conversation invariant bug. reindexing required.</span>
<a href="#l14.608"></a><span id="l14.608" class="difflineminus">-    if (aCurVersion &lt; 11) {</span>
<a href="#l14.609"></a><span id="l14.609" class="difflineminus">-      aDBConnection.close();</span>
<a href="#l14.610"></a><span id="l14.610" class="difflineminus">-      aDBFile.remove(false);</span>
<a href="#l14.611"></a><span id="l14.611" class="difflineminus">-      this._log.warn(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l14.612"></a><span id="l14.612" class="difflineminus">-      return this._createDB(aDBService, aDBFile);</span>
<a href="#l14.613"></a><span id="l14.613" class="difflineminus">-    }</span>
<a href="#l14.614"></a><span id="l14.614" class="difflineminus">-    </span>
<a href="#l14.615"></a><span id="l14.615" class="difflineplus">+</span>
<a href="#l14.616"></a><span id="l14.616">     aDBConnection.schemaVersion = aNewVersion;</span>
<a href="#l14.617"></a><span id="l14.617" class="difflineminus">-    </span>
<a href="#l14.618"></a><span id="l14.618" class="difflineplus">+</span>
<a href="#l14.619"></a><span id="l14.619">     return aDBConnection;</span>
<a href="#l14.620"></a><span id="l14.620">   },</span>
<a href="#l14.621"></a><span id="l14.621"> </span>
<a href="#l14.622"></a><span id="l14.622">   _outstandingAsyncStatements: [],</span>
<a href="#l14.623"></a><span id="l14.623"> </span>
<a href="#l14.624"></a><span id="l14.624">   _createAsyncStatement: function gloda_ds_createAsyncStatement(aSQLString,</span>
<a href="#l14.625"></a><span id="l14.625">                                                                 aWillFinalize) {</span>
<a href="#l14.626"></a><span id="l14.626">     let statement = null;</span>
<a href="#l14.627"></a><span id="l14.627" class="difflineat">@@ -1384,18 +1389,19 @@ var GlodaDatastore = {</span>
<a href="#l14.628"></a><span id="l14.628">   },</span>
<a href="#l14.629"></a><span id="l14.629"> </span>
<a href="#l14.630"></a><span id="l14.630">   /* ********** Folders ********** */</span>
<a href="#l14.631"></a><span id="l14.631">   /** next folder (row) id to issue, populated by _getAllFolderMappings. */</span>
<a href="#l14.632"></a><span id="l14.632">   _nextFolderId: 1,</span>
<a href="#l14.633"></a><span id="l14.633"> </span>
<a href="#l14.634"></a><span id="l14.634">   get _insertFolderLocationStatement() {</span>
<a href="#l14.635"></a><span id="l14.635">     let statement = this._createAsyncStatement(</span>
<a href="#l14.636"></a><span id="l14.636" class="difflineminus">-      &quot;INSERT INTO folderLocations (id, folderURI, dirtyStatus, name) VALUES \</span>
<a href="#l14.637"></a><span id="l14.637" class="difflineminus">-        (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l14.638"></a><span id="l14.638" class="difflineplus">+      &quot;INSERT INTO folderLocations (id, folderURI, dirtyStatus, name, \</span>
<a href="#l14.639"></a><span id="l14.639" class="difflineplus">+                                    indexingPriority) VALUES \</span>
<a href="#l14.640"></a><span id="l14.640" class="difflineplus">+        (?1, ?2, ?3, ?4, ?5)&quot;);</span>
<a href="#l14.641"></a><span id="l14.641">     this.__defineGetter__(&quot;_insertFolderLocationStatement&quot;,</span>
<a href="#l14.642"></a><span id="l14.642">       function() statement);</span>
<a href="#l14.643"></a><span id="l14.643">     return this._insertFolderLocationStatement;</span>
<a href="#l14.644"></a><span id="l14.644">   },</span>
<a href="#l14.645"></a><span id="l14.645"> </span>
<a href="#l14.646"></a><span id="l14.646">   /**</span>
<a href="#l14.647"></a><span id="l14.647">    * Authoritative map from folder URI to folder ID.  (Authoritative in the</span>
<a href="#l14.648"></a><span id="l14.648">    *  sense that this map exactly represents the state of the underlying</span>
<a href="#l14.649"></a><span id="l14.649" class="difflineat">@@ -1403,27 +1409,29 @@ var GlodaDatastore = {</span>
<a href="#l14.650"></a><span id="l14.650">    */</span>
<a href="#l14.651"></a><span id="l14.651">   _folderByURI: {},</span>
<a href="#l14.652"></a><span id="l14.652">   /** Authoritative map from folder ID to folder URI */</span>
<a href="#l14.653"></a><span id="l14.653">   _folderByID: {},</span>
<a href="#l14.654"></a><span id="l14.654"> </span>
<a href="#l14.655"></a><span id="l14.655">   /** Intialize our _folderByURI/_folderByID mappings, called by _init(). */</span>
<a href="#l14.656"></a><span id="l14.656">   _getAllFolderMappings: function gloda_ds_getAllFolderMappings() {</span>
<a href="#l14.657"></a><span id="l14.657">     let stmt = this._createSyncStatement(</span>
<a href="#l14.658"></a><span id="l14.658" class="difflineminus">-      &quot;SELECT id, folderURI, dirtyStatus, name FROM folderLocations&quot;, true);</span>
<a href="#l14.659"></a><span id="l14.659" class="difflineplus">+      &quot;SELECT id, folderURI, dirtyStatus, name, indexingPriority \</span>
<a href="#l14.660"></a><span id="l14.660" class="difflineplus">+        FROM folderLocations&quot;, true);</span>
<a href="#l14.661"></a><span id="l14.661"> </span>
<a href="#l14.662"></a><span id="l14.662">     while (stmt.executeStep()) {  // no chance of this SQLITE_BUSY on this call</span>
<a href="#l14.663"></a><span id="l14.663">       let folderID = stmt.getInt64(0);</span>
<a href="#l14.664"></a><span id="l14.664">       let folderURI = stmt.getString(1);</span>
<a href="#l14.665"></a><span id="l14.665">       let dirtyStatus = stmt.getInt32(2);</span>
<a href="#l14.666"></a><span id="l14.666">       let folderName = stmt.getString(3);</span>
<a href="#l14.667"></a><span id="l14.667" class="difflineminus">-      </span>
<a href="#l14.668"></a><span id="l14.668" class="difflineplus">+      let indexingPriority = stmt.getInt32(4);</span>
<a href="#l14.669"></a><span id="l14.669" class="difflineplus">+</span>
<a href="#l14.670"></a><span id="l14.670">       let folder = new GlodaFolder(this, folderID, folderURI, dirtyStatus,</span>
<a href="#l14.671"></a><span id="l14.671" class="difflineminus">-                                   folderName);</span>
<a href="#l14.672"></a><span id="l14.672" class="difflineminus">-      </span>
<a href="#l14.673"></a><span id="l14.673" class="difflineplus">+                                   folderName, indexingPriority);</span>
<a href="#l14.674"></a><span id="l14.674" class="difflineplus">+</span>
<a href="#l14.675"></a><span id="l14.675">       this._folderByURI[folderURI] = folder;</span>
<a href="#l14.676"></a><span id="l14.676">       this._folderByID[folderID] = folder;</span>
<a href="#l14.677"></a><span id="l14.677"> </span>
<a href="#l14.678"></a><span id="l14.678">       if (folderID &gt;= this._nextFolderId)</span>
<a href="#l14.679"></a><span id="l14.679">         this._nextFolderId = folderID + 1;</span>
<a href="#l14.680"></a><span id="l14.680">     }</span>
<a href="#l14.681"></a><span id="l14.681">     stmt.finalize();</span>
<a href="#l14.682"></a><span id="l14.682">   },</span>
<a href="#l14.683"></a><span id="l14.683" class="difflineat">@@ -1431,48 +1439,64 @@ var GlodaDatastore = {</span>
<a href="#l14.684"></a><span id="l14.684">   _folderKnown: function gloda_ds_folderKnown(aFolder) {</span>
<a href="#l14.685"></a><span id="l14.685">     let folderURI = aFolder.URI;</span>
<a href="#l14.686"></a><span id="l14.686">     return folderURI in this._folderByURI;</span>
<a href="#l14.687"></a><span id="l14.687">   },</span>
<a href="#l14.688"></a><span id="l14.688"> </span>
<a href="#l14.689"></a><span id="l14.689">   /**</span>
<a href="#l14.690"></a><span id="l14.690">    * Map a folder URI to a GlodaFolder instance, creating the mapping if it does</span>
<a href="#l14.691"></a><span id="l14.691">    *  not yet exist.</span>
<a href="#l14.692"></a><span id="l14.692" class="difflineminus">-   * </span>
<a href="#l14.693"></a><span id="l14.693" class="difflineplus">+   *</span>
<a href="#l14.694"></a><span id="l14.694">    * @param aFolder The nsIMsgFolder instance you would like the GlodaFolder</span>
<a href="#l14.695"></a><span id="l14.695">    *     instance for.</span>
<a href="#l14.696"></a><span id="l14.696">    * @returns The existing or newly created GlodaFolder instance.</span>
<a href="#l14.697"></a><span id="l14.697">    */</span>
<a href="#l14.698"></a><span id="l14.698">   _mapFolder: function gloda_ds_mapFolderURI(aFolder) {</span>
<a href="#l14.699"></a><span id="l14.699">     let folderURI = aFolder.URI;</span>
<a href="#l14.700"></a><span id="l14.700">     if (folderURI in this._folderByURI) {</span>
<a href="#l14.701"></a><span id="l14.701">       return this._folderByURI[folderURI];</span>
<a href="#l14.702"></a><span id="l14.702">     }</span>
<a href="#l14.703"></a><span id="l14.703"> </span>
<a href="#l14.704"></a><span id="l14.704">     let folderID = this._nextFolderId++;</span>
<a href="#l14.705"></a><span id="l14.705" class="difflineminus">-    </span>
<a href="#l14.706"></a><span id="l14.706" class="difflineplus">+</span>
<a href="#l14.707"></a><span id="l14.707" class="difflineplus">+    let indexingPriority = GlodaFolder.prototype.kIndexingDefaultPriority;</span>
<a href="#l14.708"></a><span id="l14.708" class="difflineplus">+    // do not walk into trash/junk folders.</span>
<a href="#l14.709"></a><span id="l14.709" class="difflineplus">+    if (aFolder.flags &amp; (Ci.nsMsgFolderFlags.Trash |</span>
<a href="#l14.710"></a><span id="l14.710" class="difflineplus">+                         Ci.nsMsgFolderFlags.Junk))</span>
<a href="#l14.711"></a><span id="l14.711" class="difflineplus">+      indexingPriority = GlodaFolder.prototype.kIndexingNeverPriority;</span>
<a href="#l14.712"></a><span id="l14.712" class="difflineplus">+    else if (aFolder.flags &amp; Ci.nsMsgFolderFlags.Inbox)</span>
<a href="#l14.713"></a><span id="l14.713" class="difflineplus">+      indexingPriority = GlodaFolder.prototype.kIndexingInboxPriority;</span>
<a href="#l14.714"></a><span id="l14.714" class="difflineplus">+    else if (aFolder.flags &amp; Ci.nsMsgFolderFlags.SentMail)</span>
<a href="#l14.715"></a><span id="l14.715" class="difflineplus">+      indexingPriority = GlodaFolder.prototype.kIndexingSentMailPriority;</span>
<a href="#l14.716"></a><span id="l14.716" class="difflineplus">+    else if (aFolder.flags &amp; Ci.nsMsgFolderFlags.Favorite)</span>
<a href="#l14.717"></a><span id="l14.717" class="difflineplus">+      indexingPriority = GlodaFolder.prototype.kIndexingFavoritePriority;</span>
<a href="#l14.718"></a><span id="l14.718" class="difflineplus">+    else if (aFolder.flags &amp; Ci.nsMsgFolderFlags.CheckNew)</span>
<a href="#l14.719"></a><span id="l14.719" class="difflineplus">+      indexingPriority = GlodaFolder.prototype.kIndexingCheckNewPriority;</span>
<a href="#l14.720"></a><span id="l14.720">     let folder = new GlodaFolder(this, folderID, folderURI,</span>
<a href="#l14.721"></a><span id="l14.721" class="difflineminus">-      GlodaFolder.prototype.kFolderFilthy, aFolder.prettiestName);</span>
<a href="#l14.722"></a><span id="l14.722" class="difflineminus">-    </span>
<a href="#l14.723"></a><span id="l14.723" class="difflineminus">-    this._insertFolderLocationStatement.bindInt64Parameter(0, folder.id)</span>
<a href="#l14.724"></a><span id="l14.724" class="difflineplus">+      GlodaFolder.prototype.kFolderFilthy, aFolder.prettiestName,</span>
<a href="#l14.725"></a><span id="l14.725" class="difflineplus">+      indexingPriority);</span>
<a href="#l14.726"></a><span id="l14.726" class="difflineplus">+</span>
<a href="#l14.727"></a><span id="l14.727" class="difflineplus">+    this._insertFolderLocationStatement.bindInt64Parameter(0, folder.id);</span>
<a href="#l14.728"></a><span id="l14.728">     this._insertFolderLocationStatement.bindStringParameter(1, folder.uri);</span>
<a href="#l14.729"></a><span id="l14.729">     this._insertFolderLocationStatement.bindInt64Parameter(2,</span>
<a href="#l14.730"></a><span id="l14.730">                                                            folder.dirtyStatus);</span>
<a href="#l14.731"></a><span id="l14.731">     this._insertFolderLocationStatement.bindStringParameter(3, folder.name);</span>
<a href="#l14.732"></a><span id="l14.732" class="difflineplus">+    this._insertFolderLocationStatement.bindInt64Parameter(</span>
<a href="#l14.733"></a><span id="l14.733" class="difflineplus">+      4, folder.indexingPriority);</span>
<a href="#l14.734"></a><span id="l14.734">     this._insertFolderLocationStatement.executeAsync(this.trackAsync());</span>
<a href="#l14.735"></a><span id="l14.735"> </span>
<a href="#l14.736"></a><span id="l14.736">     this._folderByURI[folderURI] = folder;</span>
<a href="#l14.737"></a><span id="l14.737">     this._folderByID[folderID] = folder;</span>
<a href="#l14.738"></a><span id="l14.738">     this._log.debug(&quot;!! mapped &quot; + folder.id + &quot; from &quot; + folderURI);</span>
<a href="#l14.739"></a><span id="l14.739">     return folder;</span>
<a href="#l14.740"></a><span id="l14.740">   },</span>
<a href="#l14.741"></a><span id="l14.741"> </span>
<a href="#l14.742"></a><span id="l14.742">   /**</span>
<a href="#l14.743"></a><span id="l14.743" class="difflineminus">-   * Map an integer gloda folder ID to the corresponding GlodaFolder instance.  </span>
<a href="#l14.744"></a><span id="l14.744" class="difflineminus">-   * </span>
<a href="#l14.745"></a><span id="l14.745" class="difflineplus">+   * Map an integer gloda folder ID to the corresponding GlodaFolder instance.</span>
<a href="#l14.746"></a><span id="l14.746" class="difflineplus">+   *</span>
<a href="#l14.747"></a><span id="l14.747">    * @param aFolderID The known valid gloda folder ID for which you would like</span>
<a href="#l14.748"></a><span id="l14.748">    *     a GlodaFolder instance.</span>
<a href="#l14.749"></a><span id="l14.749">    * @return The GlodaFolder instance with the given id.  If no such instance</span>
<a href="#l14.750"></a><span id="l14.750">    *     exists, we will throw an exception.</span>
<a href="#l14.751"></a><span id="l14.751">    */</span>
<a href="#l14.752"></a><span id="l14.752">   _mapFolderID: function gloda_ds_mapFolderID(aFolderID) {</span>
<a href="#l14.753"></a><span id="l14.753">     if (aFolderID === null)</span>
<a href="#l14.754"></a><span id="l14.754">       return null;</span>
<a href="#l14.755"></a><span id="l14.755" class="difflineat">@@ -1509,63 +1533,63 @@ var GlodaDatastore = {</span>
<a href="#l14.756"></a><span id="l14.756">   /**</span>
<a href="#l14.757"></a><span id="l14.757">    * Non-recursive asynchronous folder renaming based on the URI.</span>
<a href="#l14.758"></a><span id="l14.758">    *</span>
<a href="#l14.759"></a><span id="l14.759">    * @TODO provide a mechanism for recursive folder renames or have a higher</span>
<a href="#l14.760"></a><span id="l14.760">    *     layer deal with it and remove this note.</span>
<a href="#l14.761"></a><span id="l14.761">    */</span>
<a href="#l14.762"></a><span id="l14.762">   renameFolder: function gloda_ds_renameFolder(aOldFolder, aNewURI) {</span>
<a href="#l14.763"></a><span id="l14.763">     let folder = this._mapFolder(aOldFolder); // ensure the folder is mapped</span>
<a href="#l14.764"></a><span id="l14.764" class="difflineminus">-    let oldURI = folder.uri; </span>
<a href="#l14.765"></a><span id="l14.765" class="difflineplus">+    let oldURI = folder.uri;</span>
<a href="#l14.766"></a><span id="l14.766">     this._folderByURI[aNewURI] = folder;</span>
<a href="#l14.767"></a><span id="l14.767">     folder._uri = aNewURI;</span>
<a href="#l14.768"></a><span id="l14.768">     this._log.info(&quot;renaming folder URI &quot; + oldURI + &quot; to &quot; + aNewURI);</span>
<a href="#l14.769"></a><span id="l14.769">     this._updateFolderLocationStatement.bindStringParameter(1, folder.id);</span>
<a href="#l14.770"></a><span id="l14.770">     this._updateFolderLocationStatement.bindStringParameter(0, aNewURI);</span>
<a href="#l14.771"></a><span id="l14.771">     this._updateFolderLocationStatement.executeAsync(this.trackAsync());</span>
<a href="#l14.772"></a><span id="l14.772" class="difflineminus">-    </span>
<a href="#l14.773"></a><span id="l14.773" class="difflineplus">+</span>
<a href="#l14.774"></a><span id="l14.774">     delete this._folderByURI[oldURI];</span>
<a href="#l14.775"></a><span id="l14.775">   },</span>
<a href="#l14.776"></a><span id="l14.776"> </span>
<a href="#l14.777"></a><span id="l14.777">   get _deleteFolderByIDStatement() {</span>
<a href="#l14.778"></a><span id="l14.778">     let statement = this._createAsyncStatement(</span>
<a href="#l14.779"></a><span id="l14.779">       &quot;DELETE FROM folderLocations WHERE id = ?1&quot;);</span>
<a href="#l14.780"></a><span id="l14.780">     this.__defineGetter__(&quot;_deleteFolderByIDStatement&quot;,</span>
<a href="#l14.781"></a><span id="l14.781">       function() statement);</span>
<a href="#l14.782"></a><span id="l14.782">     return this._deleteFolderByIDStatement;</span>
<a href="#l14.783"></a><span id="l14.783">   },</span>
<a href="#l14.784"></a><span id="l14.784"> </span>
<a href="#l14.785"></a><span id="l14.785">   deleteFolderByID: function gloda_ds_deleteFolder(aFolderID) {</span>
<a href="#l14.786"></a><span id="l14.786">     let dfbis = this._deleteFolderByIDStatement;</span>
<a href="#l14.787"></a><span id="l14.787">     dfbis.bindInt64Parameter(0, aFolderID);</span>
<a href="#l14.788"></a><span id="l14.788">     dfbis.executeAsync(this.trackAsync());</span>
<a href="#l14.789"></a><span id="l14.789">   },</span>
<a href="#l14.790"></a><span id="l14.790" class="difflineminus">-  </span>
<a href="#l14.791"></a><span id="l14.791" class="difflineplus">+</span>
<a href="#l14.792"></a><span id="l14.792">   /**</span>
<a href="#l14.793"></a><span id="l14.793">    * This timer drives our folder cleanup logic that is in charge of dropping</span>
<a href="#l14.794"></a><span id="l14.794">    *  our folder references and more importantly the folder's msgDatabase</span>
<a href="#l14.795"></a><span id="l14.795">    *  reference, but only if they are no longer in use.</span>
<a href="#l14.796"></a><span id="l14.796">    * This timer is only active when we have one or more live gloda folders (as</span>
<a href="#l14.797"></a><span id="l14.797">    *  tracked by _liveGlodaFolders).  Although we choose our timer interval to</span>
<a href="#l14.798"></a><span id="l14.798">    *  be power-friendly, it doesn't really matter because unless the user or the</span>
<a href="#l14.799"></a><span id="l14.799">    *  indexing process is actively doing things, all of the folders will 'die'</span>
<a href="#l14.800"></a><span id="l14.800">    *  and so we will stop scheduling the timer.</span>
<a href="#l14.801"></a><span id="l14.801">    */</span>
<a href="#l14.802"></a><span id="l14.802">   _folderCleanupTimer: null,</span>
<a href="#l14.803"></a><span id="l14.803" class="difflineminus">-  </span>
<a href="#l14.804"></a><span id="l14.804" class="difflineplus">+</span>
<a href="#l14.805"></a><span id="l14.805">   /**</span>
<a href="#l14.806"></a><span id="l14.806">    * When true, we have a folder cleanup timer event active.</span>
<a href="#l14.807"></a><span id="l14.807">    */</span>
<a href="#l14.808"></a><span id="l14.808">   _folderCleanupActive: false,</span>
<a href="#l14.809"></a><span id="l14.809" class="difflineminus">-  </span>
<a href="#l14.810"></a><span id="l14.810" class="difflineplus">+</span>
<a href="#l14.811"></a><span id="l14.811">   /**</span>
<a href="#l14.812"></a><span id="l14.812">    * Interval at which we call the folder cleanup code, in milliseconds.</span>
<a href="#l14.813"></a><span id="l14.813">    */</span>
<a href="#l14.814"></a><span id="l14.814">   _folderCleanupTimerInterval: 2000,</span>
<a href="#l14.815"></a><span id="l14.815" class="difflineminus">-  </span>
<a href="#l14.816"></a><span id="l14.816" class="difflineplus">+</span>
<a href="#l14.817"></a><span id="l14.817">   /**</span>
<a href="#l14.818"></a><span id="l14.818">    * Maps the id of 'live' GlodaFolders to the instances.  If a GlodaFolder is</span>
<a href="#l14.819"></a><span id="l14.819">    *  in here, it means that it has a reference to its nsIMsgDBFolder which</span>
<a href="#l14.820"></a><span id="l14.820">    *  should have an open nsIMsgDatabase that we will need to close.  This does</span>
<a href="#l14.821"></a><span id="l14.821">    *  not count folders that are being indexed unless they have also been used</span>
<a href="#l14.822"></a><span id="l14.822">    *  for header retrieval.</span>
<a href="#l14.823"></a><span id="l14.823">    */</span>
<a href="#l14.824"></a><span id="l14.824">   _liveGlodaFolders: {},</span>
<a href="#l14.825"></a><span id="l14.825" class="difflineat">@@ -1580,41 +1604,41 @@ var GlodaDatastore = {</span>
<a href="#l14.826"></a><span id="l14.826">   markFolderLive: function gloda_ds_markFolderLive(aGlodaFolder) {</span>
<a href="#l14.827"></a><span id="l14.827">     this._liveGlodaFolders[aGlodaFolder.id] = aGlodaFolder;</span>
<a href="#l14.828"></a><span id="l14.828">     if (!this._folderCleanupActive) {</span>
<a href="#l14.829"></a><span id="l14.829">       this._folderCleanupTimer.initWithCallback(this._performFolderCleanup,</span>
<a href="#l14.830"></a><span id="l14.830">         this._folderCleanupTimerInterval, Ci.nsITimer.TYPE_REPEATING_SLACK);</span>
<a href="#l14.831"></a><span id="l14.831">       this._folderCleanupActive = true;</span>
<a href="#l14.832"></a><span id="l14.832">     }</span>
<a href="#l14.833"></a><span id="l14.833">   },</span>
<a href="#l14.834"></a><span id="l14.834" class="difflineminus">-  </span>
<a href="#l14.835"></a><span id="l14.835" class="difflineplus">+</span>
<a href="#l14.836"></a><span id="l14.836">   /**</span>
<a href="#l14.837"></a><span id="l14.837">    * Timer-driven folder cleanup logic.  For every live folder tracked in</span>
<a href="#l14.838"></a><span id="l14.838">    *  _liveGlodaFolders, we call their forgetFolderIfUnused method each time</span>
<a href="#l14.839"></a><span id="l14.839">    *  until they return true indicating they have cleaned themselves up.</span>
<a href="#l14.840"></a><span id="l14.840" class="difflineminus">-   * This method is called without a 'this' context! </span>
<a href="#l14.841"></a><span id="l14.841" class="difflineplus">+   * This method is called without a 'this' context!</span>
<a href="#l14.842"></a><span id="l14.842">    */</span>
<a href="#l14.843"></a><span id="l14.843">   _performFolderCleanup: function gloda_ds_performFolderCleanup() {</span>
<a href="#l14.844"></a><span id="l14.844">     // we only need to keep going if there is at least one folder in the table</span>
<a href="#l14.845"></a><span id="l14.845">     //  that is still alive after this pass.</span>
<a href="#l14.846"></a><span id="l14.846">     let keepGoing = false;</span>
<a href="#l14.847"></a><span id="l14.847">     for each (let glodaFolder in GlodaDatastore._liveGlodaFolders) {</span>
<a href="#l14.848"></a><span id="l14.848">       // returns true if it is now 'dead' and doesn't need this heartbeat check</span>
<a href="#l14.849"></a><span id="l14.849">       if (glodaFolder.forgetFolderIfUnused())</span>
<a href="#l14.850"></a><span id="l14.850">         delete GlodaDatastore._liveGlodaFolders[glodaFolder.id];</span>
<a href="#l14.851"></a><span id="l14.851">       else</span>
<a href="#l14.852"></a><span id="l14.852">         keepGoing = true;</span>
<a href="#l14.853"></a><span id="l14.853">     }</span>
<a href="#l14.854"></a><span id="l14.854" class="difflineminus">-    </span>
<a href="#l14.855"></a><span id="l14.855" class="difflineplus">+</span>
<a href="#l14.856"></a><span id="l14.856">     if (!keepGoing) {</span>
<a href="#l14.857"></a><span id="l14.857">       GlodaDatastore._folderCleanupTimer.cancel();</span>
<a href="#l14.858"></a><span id="l14.858">       GlodaDatastore._folderCleanupActive = false;</span>
<a href="#l14.859"></a><span id="l14.859">     }</span>
<a href="#l14.860"></a><span id="l14.860">   },</span>
<a href="#l14.861"></a><span id="l14.861" class="difflineminus">-  </span>
<a href="#l14.862"></a><span id="l14.862" class="difflineplus">+</span>
<a href="#l14.863"></a><span id="l14.863">   /* ********** Conversation ********** */</span>
<a href="#l14.864"></a><span id="l14.864">   /** The next conversation id to allocate.  Initialize at startup. */</span>
<a href="#l14.865"></a><span id="l14.865">   _nextConversationId: 1,</span>
<a href="#l14.866"></a><span id="l14.866"> </span>
<a href="#l14.867"></a><span id="l14.867">   _populateConversationManagedId: function () {</span>
<a href="#l14.868"></a><span id="l14.868">     let stmt = this._createSyncStatement(</span>
<a href="#l14.869"></a><span id="l14.869">       &quot;SELECT MAX(id) FROM conversations&quot;, true);</span>
<a href="#l14.870"></a><span id="l14.870">     if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span>
<a href="#l14.871"></a><span id="l14.871" class="difflineat">@@ -1757,26 +1781,27 @@ var GlodaDatastore = {</span>
<a href="#l14.872"></a><span id="l14.872">       this._nextMessageId = stmt.getInt64(0) + 1;</span>
<a href="#l14.873"></a><span id="l14.873">     }</span>
<a href="#l14.874"></a><span id="l14.874">     stmt.finalize();</span>
<a href="#l14.875"></a><span id="l14.875">   },</span>
<a href="#l14.876"></a><span id="l14.876"> </span>
<a href="#l14.877"></a><span id="l14.877">   get _insertMessageStatement() {</span>
<a href="#l14.878"></a><span id="l14.878">     let statement = this._createAsyncStatement(</span>
<a href="#l14.879"></a><span id="l14.879">       &quot;INSERT INTO messages (id, folderID, messageKey, conversationID, date, \</span>
<a href="#l14.880"></a><span id="l14.880" class="difflineminus">-                             headerMessageID, jsonAttributes) \</span>
<a href="#l14.881"></a><span id="l14.881" class="difflineminus">-              VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)&quot;);</span>
<a href="#l14.882"></a><span id="l14.882" class="difflineplus">+                             headerMessageID, jsonAttributes, notability) \</span>
<a href="#l14.883"></a><span id="l14.883" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)&quot;);</span>
<a href="#l14.884"></a><span id="l14.884">     this.__defineGetter__(&quot;_insertMessageStatement&quot;, function() statement);</span>
<a href="#l14.885"></a><span id="l14.885">     return this._insertMessageStatement;</span>
<a href="#l14.886"></a><span id="l14.886">   },</span>
<a href="#l14.887"></a><span id="l14.887"> </span>
<a href="#l14.888"></a><span id="l14.888">   get _insertMessageTextStatement() {</span>
<a href="#l14.889"></a><span id="l14.889">     let statement = this._createAsyncStatement(</span>
<a href="#l14.890"></a><span id="l14.890" class="difflineminus">-      &quot;INSERT INTO messagesText (docid, subject, body, attachmentNames) \</span>
<a href="#l14.891"></a><span id="l14.891" class="difflineminus">-              VALUES (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l14.892"></a><span id="l14.892" class="difflineplus">+      &quot;INSERT INTO messagesText (docid, subject, body, attachmentNames, \</span>
<a href="#l14.893"></a><span id="l14.893" class="difflineplus">+                                 author, recipients) \</span>
<a href="#l14.894"></a><span id="l14.894" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4, ?5, ?6)&quot;);</span>
<a href="#l14.895"></a><span id="l14.895">     this.__defineGetter__(&quot;_insertMessageTextStatement&quot;, function() statement);</span>
<a href="#l14.896"></a><span id="l14.896">     return this._insertMessageTextStatement;</span>
<a href="#l14.897"></a><span id="l14.897">   },</span>
<a href="#l14.898"></a><span id="l14.898"> </span>
<a href="#l14.899"></a><span id="l14.899">   /**</span>
<a href="#l14.900"></a><span id="l14.900">    * Create a GlodaMessage with the given properties.  Because this is only half</span>
<a href="#l14.901"></a><span id="l14.901">    *  of the process of creating a message (the attributes still need to be</span>
<a href="#l14.902"></a><span id="l14.902">    *  completed), it's on the caller's head to call GlodaCollectionManager's</span>
<a href="#l14.903"></a><span id="l14.903" class="difflineat">@@ -1793,33 +1818,36 @@ var GlodaDatastore = {</span>
<a href="#l14.904"></a><span id="l14.904">       folderID = this._mapFolder(aFolder).id;</span>
<a href="#l14.905"></a><span id="l14.905">     }</span>
<a href="#l14.906"></a><span id="l14.906">     else {</span>
<a href="#l14.907"></a><span id="l14.907">       folderID = null;</span>
<a href="#l14.908"></a><span id="l14.908">     }</span>
<a href="#l14.909"></a><span id="l14.909"> </span>
<a href="#l14.910"></a><span id="l14.910">     let messageID = this._nextMessageId++;</span>
<a href="#l14.911"></a><span id="l14.911"> </span>
<a href="#l14.912"></a><span id="l14.912" class="difflineminus">-    let message = new GlodaMessage(this, messageID, folderID,</span>
<a href="#l14.913"></a><span id="l14.913" class="difflineminus">-                            aMessageKey, aConversationID, null,</span>
<a href="#l14.914"></a><span id="l14.914" class="difflineminus">-                            aDatePRTime ? new Date(aDatePRTime / 1000) : null,</span>
<a href="#l14.915"></a><span id="l14.915" class="difflineminus">-                            aHeaderMessageID);</span>
<a href="#l14.916"></a><span id="l14.916" class="difflineplus">+    let message = new GlodaMessage(</span>
<a href="#l14.917"></a><span id="l14.917" class="difflineplus">+      this, messageID, folderID,</span>
<a href="#l14.918"></a><span id="l14.918" class="difflineplus">+      aMessageKey,</span>
<a href="#l14.919"></a><span id="l14.919" class="difflineplus">+      aConversationID, /* conversation */ null,</span>
<a href="#l14.920"></a><span id="l14.920" class="difflineplus">+      aDatePRTime ? new Date(aDatePRTime / 1000) : null,</span>
<a href="#l14.921"></a><span id="l14.921" class="difflineplus">+      aHeaderMessageID,</span>
<a href="#l14.922"></a><span id="l14.922" class="difflineplus">+      /* deleted */ false, /* jsonText */ undefined, /* notability*/ 0);</span>
<a href="#l14.923"></a><span id="l14.923"> </span>
<a href="#l14.924"></a><span id="l14.924">     this._log.debug(&quot;CreateMessage: &quot; + folderID + &quot;, &quot; + aMessageKey + &quot;, &quot; +</span>
<a href="#l14.925"></a><span id="l14.925">                     aConversationID + &quot;, &quot; + aDatePRTime + &quot;, &quot; +</span>
<a href="#l14.926"></a><span id="l14.926">                     aHeaderMessageID);</span>
<a href="#l14.927"></a><span id="l14.927"> </span>
<a href="#l14.928"></a><span id="l14.928">     // We would love to notify the collection manager about the message at this</span>
<a href="#l14.929"></a><span id="l14.929">     //  point (at least if it's not a ghost), but we can't yet.  We need to wait</span>
<a href="#l14.930"></a><span id="l14.930">     //  until the attributes have been indexed, which means it's out of our</span>
<a href="#l14.931"></a><span id="l14.931">     //  hands.  (Gloda.processMessage does it.)</span>
<a href="#l14.932"></a><span id="l14.932"> </span>
<a href="#l14.933"></a><span id="l14.933">     return message;</span>
<a href="#l14.934"></a><span id="l14.934">   },</span>
<a href="#l14.935"></a><span id="l14.935" class="difflineminus">-  </span>
<a href="#l14.936"></a><span id="l14.936" class="difflineplus">+</span>
<a href="#l14.937"></a><span id="l14.937">   insertMessage: function gloda_ds_insertMessage(aMessage) {</span>
<a href="#l14.938"></a><span id="l14.938">     let ims = this._insertMessageStatement;</span>
<a href="#l14.939"></a><span id="l14.939">     ims.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l14.940"></a><span id="l14.940">     if (aMessage.folderID == null)</span>
<a href="#l14.941"></a><span id="l14.941">       ims.bindNullParameter(1);</span>
<a href="#l14.942"></a><span id="l14.942">     else</span>
<a href="#l14.943"></a><span id="l14.943">       ims.bindInt64Parameter(1, aMessage.folderID);</span>
<a href="#l14.944"></a><span id="l14.944">     if (aMessage.messageKey == null)</span>
<a href="#l14.945"></a><span id="l14.945" class="difflineat">@@ -1831,16 +1859,17 @@ var GlodaDatastore = {</span>
<a href="#l14.946"></a><span id="l14.946">       ims.bindNullParameter(4);</span>
<a href="#l14.947"></a><span id="l14.947">     else</span>
<a href="#l14.948"></a><span id="l14.948">       ims.bindInt64Parameter(4, aMessage.date * 1000);</span>
<a href="#l14.949"></a><span id="l14.949">     ims.bindStringParameter(5, aMessage.headerMessageID);</span>
<a href="#l14.950"></a><span id="l14.950">     if (aMessage._jsonText)</span>
<a href="#l14.951"></a><span id="l14.951">       ims.bindStringParameter(6, aMessage._jsonText);</span>
<a href="#l14.952"></a><span id="l14.952">     else</span>
<a href="#l14.953"></a><span id="l14.953">       ims.bindNullParameter(6);</span>
<a href="#l14.954"></a><span id="l14.954" class="difflineplus">+    ims.bindInt64Parameter(7, aMessage.notability);</span>
<a href="#l14.955"></a><span id="l14.955"> </span>
<a href="#l14.956"></a><span id="l14.956">     try {</span>
<a href="#l14.957"></a><span id="l14.957">        ims.executeAsync(this.trackAsync());</span>
<a href="#l14.958"></a><span id="l14.958">     }</span>
<a href="#l14.959"></a><span id="l14.959">     catch(ex) {</span>
<a href="#l14.960"></a><span id="l14.960">        throw(&quot;error executing statement... &quot; +</span>
<a href="#l14.961"></a><span id="l14.961">              this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l14.962"></a><span id="l14.962">              this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l14.963"></a><span id="l14.963" class="difflineat">@@ -1849,26 +1878,28 @@ var GlodaDatastore = {</span>
<a href="#l14.964"></a><span id="l14.964">     // we only create the full-text row if the body is non-null.</span>
<a href="#l14.965"></a><span id="l14.965">     // so, even though body might be null, we still want to create the</span>
<a href="#l14.966"></a><span id="l14.966">     //  full-text search row</span>
<a href="#l14.967"></a><span id="l14.967">     if (aMessage._bodyLines) {</span>
<a href="#l14.968"></a><span id="l14.968">       if (aMessage._content &amp;&amp; aMessage._content.hasContent())</span>
<a href="#l14.969"></a><span id="l14.969">         aMessage._indexedBodyText = aMessage._content.getContentString(true);</span>
<a href="#l14.970"></a><span id="l14.970">       else</span>
<a href="#l14.971"></a><span id="l14.971">         aMessage._indexedBodyText = aMessage._bodyLines.join(&quot;\n&quot;);</span>
<a href="#l14.972"></a><span id="l14.972" class="difflineminus">-      </span>
<a href="#l14.973"></a><span id="l14.973" class="difflineplus">+</span>
<a href="#l14.974"></a><span id="l14.974">       let imts = this._insertMessageTextStatement;</span>
<a href="#l14.975"></a><span id="l14.975">       imts.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l14.976"></a><span id="l14.976">       imts.bindStringParameter(1, aMessage._subject);</span>
<a href="#l14.977"></a><span id="l14.977">       imts.bindStringParameter(2, aMessage._indexedBodyText);</span>
<a href="#l14.978"></a><span id="l14.978">       if (aMessage._attachmentNames === null)</span>
<a href="#l14.979"></a><span id="l14.979">         imts.bindNullParameter(3);</span>
<a href="#l14.980"></a><span id="l14.980">       else</span>
<a href="#l14.981"></a><span id="l14.981">         imts.bindStringParameter(3, aMessage._attachmentNames.join(&quot;\n&quot;));</span>
<a href="#l14.982"></a><span id="l14.982" class="difflineminus">-      </span>
<a href="#l14.983"></a><span id="l14.983" class="difflineplus">+      imts.bindStringParameter(4, aMessage._indexAuthor);</span>
<a href="#l14.984"></a><span id="l14.984" class="difflineplus">+      imts.bindStringParameter(5, aMessage._indexRecipients);</span>
<a href="#l14.985"></a><span id="l14.985" class="difflineplus">+</span>
<a href="#l14.986"></a><span id="l14.986">       try {</span>
<a href="#l14.987"></a><span id="l14.987">          imts.executeAsync(this.trackAsync());</span>
<a href="#l14.988"></a><span id="l14.988">       }</span>
<a href="#l14.989"></a><span id="l14.989">       catch(ex) {</span>
<a href="#l14.990"></a><span id="l14.990">          throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l14.991"></a><span id="l14.991">                this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l14.992"></a><span id="l14.992">                this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l14.993"></a><span id="l14.993">       }</span>
<a href="#l14.994"></a><span id="l14.994" class="difflineat">@@ -1877,30 +1908,31 @@ var GlodaDatastore = {</span>
<a href="#l14.995"></a><span id="l14.995"> </span>
<a href="#l14.996"></a><span id="l14.996">   get _updateMessageStatement() {</span>
<a href="#l14.997"></a><span id="l14.997">     let statement = this._createAsyncStatement(</span>
<a href="#l14.998"></a><span id="l14.998">       &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l14.999"></a><span id="l14.999">                            messageKey = ?2, \</span>
<a href="#l14.1000"></a><span id="l14.1000">                            conversationID = ?3, \</span>
<a href="#l14.1001"></a><span id="l14.1001">                            date = ?4, \</span>
<a href="#l14.1002"></a><span id="l14.1002">                            headerMessageID = ?5, \</span>
<a href="#l14.1003"></a><span id="l14.1003" class="difflineminus">-                           jsonAttributes = ?6 \</span>
<a href="#l14.1004"></a><span id="l14.1004" class="difflineminus">-              WHERE id = ?7&quot;);</span>
<a href="#l14.1005"></a><span id="l14.1005" class="difflineplus">+                           jsonAttributes = ?6, \</span>
<a href="#l14.1006"></a><span id="l14.1006" class="difflineplus">+                           notability = ?7 \</span>
<a href="#l14.1007"></a><span id="l14.1007" class="difflineplus">+              WHERE id = ?8&quot;);</span>
<a href="#l14.1008"></a><span id="l14.1008">     this.__defineGetter__(&quot;_updateMessageStatement&quot;, function() statement);</span>
<a href="#l14.1009"></a><span id="l14.1009">     return this._updateMessageStatement;</span>
<a href="#l14.1010"></a><span id="l14.1010">   },</span>
<a href="#l14.1011"></a><span id="l14.1011"> </span>
<a href="#l14.1012"></a><span id="l14.1012">   /**</span>
<a href="#l14.1013"></a><span id="l14.1013">    * Update the database row associated with the message.  If aBody is supplied,</span>
<a href="#l14.1014"></a><span id="l14.1014">    *  the associated full-text row is created; it is assumed that it did not</span>
<a href="#l14.1015"></a><span id="l14.1015">    *  previously exist.</span>
<a href="#l14.1016"></a><span id="l14.1016">    */</span>
<a href="#l14.1017"></a><span id="l14.1017">   updateMessage: function gloda_ds_updateMessage(aMessage) {</span>
<a href="#l14.1018"></a><span id="l14.1018">     let ums = this._updateMessageStatement;</span>
<a href="#l14.1019"></a><span id="l14.1019" class="difflineminus">-    ums.bindInt64Parameter(6, aMessage.id);</span>
<a href="#l14.1020"></a><span id="l14.1020" class="difflineplus">+    ums.bindInt64Parameter(7, aMessage.id);</span>
<a href="#l14.1021"></a><span id="l14.1021">     if (aMessage.folderID === null)</span>
<a href="#l14.1022"></a><span id="l14.1022">       ums.bindNullParameter(0);</span>
<a href="#l14.1023"></a><span id="l14.1023">     else</span>
<a href="#l14.1024"></a><span id="l14.1024">       ums.bindInt64Parameter(0, aMessage.folderID);</span>
<a href="#l14.1025"></a><span id="l14.1025">     if (aMessage.messageKey === null)</span>
<a href="#l14.1026"></a><span id="l14.1026">       ums.bindNullParameter(1);</span>
<a href="#l14.1027"></a><span id="l14.1027">     else</span>
<a href="#l14.1028"></a><span id="l14.1028">       ums.bindInt64Parameter(1, aMessage.messageKey);</span>
<a href="#l14.1029"></a><span id="l14.1029" class="difflineat">@@ -1909,34 +1941,37 @@ var GlodaDatastore = {</span>
<a href="#l14.1030"></a><span id="l14.1030">       ums.bindNullParameter(3);</span>
<a href="#l14.1031"></a><span id="l14.1031">     else</span>
<a href="#l14.1032"></a><span id="l14.1032">       ums.bindInt64Parameter(3, aMessage.date * 1000);</span>
<a href="#l14.1033"></a><span id="l14.1033">     ums.bindStringParameter(4, aMessage.headerMessageID);</span>
<a href="#l14.1034"></a><span id="l14.1034">     if (aMessage._jsonText)</span>
<a href="#l14.1035"></a><span id="l14.1035">       ums.bindStringParameter(5, aMessage._jsonText);</span>
<a href="#l14.1036"></a><span id="l14.1036">     else</span>
<a href="#l14.1037"></a><span id="l14.1037">       ums.bindNullParameter(5);</span>
<a href="#l14.1038"></a><span id="l14.1038" class="difflineplus">+    ums.bindInt64Parameter(6, aMessage.notability);</span>
<a href="#l14.1039"></a><span id="l14.1039"> </span>
<a href="#l14.1040"></a><span id="l14.1040">     ums.executeAsync(this.trackAsync());</span>
<a href="#l14.1041"></a><span id="l14.1041"> </span>
<a href="#l14.1042"></a><span id="l14.1042">     if (aMessage._isNew &amp;&amp; aMessage._bodyLines) {</span>
<a href="#l14.1043"></a><span id="l14.1043">       if (aMessage._content &amp;&amp; aMessage._content.hasContent())</span>
<a href="#l14.1044"></a><span id="l14.1044">         aMessage._indexedBodyText = aMessage._content.getContentString(true);</span>
<a href="#l14.1045"></a><span id="l14.1045">       else</span>
<a href="#l14.1046"></a><span id="l14.1046">         aMessage._indexedBodyText = aMessage._bodyLines.join(&quot;\n&quot;);</span>
<a href="#l14.1047"></a><span id="l14.1047" class="difflineminus">-      </span>
<a href="#l14.1048"></a><span id="l14.1048" class="difflineplus">+</span>
<a href="#l14.1049"></a><span id="l14.1049">       let imts = this._insertMessageTextStatement;</span>
<a href="#l14.1050"></a><span id="l14.1050">       imts.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l14.1051"></a><span id="l14.1051">       imts.bindStringParameter(1, aMessage._subject);</span>
<a href="#l14.1052"></a><span id="l14.1052">       imts.bindStringParameter(2, aMessage._indexedBodyText);</span>
<a href="#l14.1053"></a><span id="l14.1053">       if (aMessage._attachmentNames === null)</span>
<a href="#l14.1054"></a><span id="l14.1054">         imts.bindNullParameter(3);</span>
<a href="#l14.1055"></a><span id="l14.1055">       else</span>
<a href="#l14.1056"></a><span id="l14.1056">         imts.bindStringParameter(3, aMessage._attachmentNames.join(&quot;\n&quot;));</span>
<a href="#l14.1057"></a><span id="l14.1057" class="difflineminus">-      </span>
<a href="#l14.1058"></a><span id="l14.1058" class="difflineplus">+      imts.bindStringParameter(4, aMessage._indexAuthor);</span>
<a href="#l14.1059"></a><span id="l14.1059" class="difflineplus">+      imts.bindStringParameter(5, aMessage._indexRecipients);</span>
<a href="#l14.1060"></a><span id="l14.1060" class="difflineplus">+</span>
<a href="#l14.1061"></a><span id="l14.1061">       try {</span>
<a href="#l14.1062"></a><span id="l14.1062">          imts.executeAsync(this.trackAsync());</span>
<a href="#l14.1063"></a><span id="l14.1063">       }</span>
<a href="#l14.1064"></a><span id="l14.1064">       catch(ex) {</span>
<a href="#l14.1065"></a><span id="l14.1065">          throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l14.1066"></a><span id="l14.1066">                this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l14.1067"></a><span id="l14.1067">                this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l14.1068"></a><span id="l14.1068">       }</span>
<a href="#l14.1069"></a><span id="l14.1069" class="difflineat">@@ -1964,17 +1999,17 @@ var GlodaDatastore = {</span>
<a href="#l14.1070"></a><span id="l14.1070">   updateMessageLocations: function gloda_ds_updateMessageLocations(aMessageIds,</span>
<a href="#l14.1071"></a><span id="l14.1071">       aNewMessageKeys, aDestFolder) {</span>
<a href="#l14.1072"></a><span id="l14.1072">     let statement = this._updateMessageLocationStatement;</span>
<a href="#l14.1073"></a><span id="l14.1073">     let destFolderID = this._mapFolder(aDestFolder).id;</span>
<a href="#l14.1074"></a><span id="l14.1074"> </span>
<a href="#l14.1075"></a><span id="l14.1075">     let modifiedItems = [];</span>
<a href="#l14.1076"></a><span id="l14.1076"> </span>
<a href="#l14.1077"></a><span id="l14.1077">     for (let iMsg = 0; iMsg &lt; aMessageIds.length; iMsg++) {</span>
<a href="#l14.1078"></a><span id="l14.1078" class="difflineminus">-      let id = aMessageIds[iMsg]</span>
<a href="#l14.1079"></a><span id="l14.1079" class="difflineplus">+      let id = aMessageIds[iMsg];</span>
<a href="#l14.1080"></a><span id="l14.1080">       statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l14.1081"></a><span id="l14.1081">       statement.bindInt64Parameter(1, aNewMessageKeys[iMsg]);</span>
<a href="#l14.1082"></a><span id="l14.1082">       statement.bindInt64Parameter(2, id);</span>
<a href="#l14.1083"></a><span id="l14.1083">       statement.executeAsync(this.trackAsync());</span>
<a href="#l14.1084"></a><span id="l14.1084"> </span>
<a href="#l14.1085"></a><span id="l14.1085">       // so, if the message is currently loaded, we also need to change it up...</span>
<a href="#l14.1086"></a><span id="l14.1086">       let message = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l14.1087"></a><span id="l14.1087">         GlodaMessage.prototype.NOUN_ID, id);</span>
<a href="#l14.1088"></a><span id="l14.1088" class="difflineat">@@ -2046,38 +2081,40 @@ var GlodaDatastore = {</span>
<a href="#l14.1089"></a><span id="l14.1089">       date = null;</span>
<a href="#l14.1090"></a><span id="l14.1090">     else</span>
<a href="#l14.1091"></a><span id="l14.1091">       date = new Date(aRow.getInt64(4) / 1000);</span>
<a href="#l14.1092"></a><span id="l14.1092">     if (aRow.getTypeOfIndex(7) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l14.1093"></a><span id="l14.1093">       jsonText = undefined;</span>
<a href="#l14.1094"></a><span id="l14.1094">     else</span>
<a href="#l14.1095"></a><span id="l14.1095">       jsonText = aRow.getString(7);</span>
<a href="#l14.1096"></a><span id="l14.1096">     // only queryFromQuery queries will have these columns</span>
<a href="#l14.1097"></a><span id="l14.1097" class="difflineminus">-    if (aRow.numEntries == 11) {</span>
<a href="#l14.1098"></a><span id="l14.1098" class="difflineminus">-      if (aRow.getTypeOfIndex(8) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l14.1099"></a><span id="l14.1099" class="difflineplus">+    if (aRow.numEntries == 14) {</span>
<a href="#l14.1100"></a><span id="l14.1100" class="difflineplus">+      if (aRow.getTypeOfIndex(9) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l14.1101"></a><span id="l14.1101">         subject = undefined;</span>
<a href="#l14.1102"></a><span id="l14.1102">       else</span>
<a href="#l14.1103"></a><span id="l14.1103" class="difflineminus">-        subject = aRow.getString(8);</span>
<a href="#l14.1104"></a><span id="l14.1104" class="difflineminus">-      if (aRow.getTypeOfIndex(9) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l14.1105"></a><span id="l14.1105" class="difflineplus">+        subject = aRow.getString(9);</span>
<a href="#l14.1106"></a><span id="l14.1106" class="difflineplus">+      if (aRow.getTypeOfIndex(10) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l14.1107"></a><span id="l14.1107">         indexedBodyText = undefined;</span>
<a href="#l14.1108"></a><span id="l14.1108">       else</span>
<a href="#l14.1109"></a><span id="l14.1109" class="difflineminus">-        indexedBodyText = aRow.getString(9);</span>
<a href="#l14.1110"></a><span id="l14.1110" class="difflineminus">-      if (aRow.getTypeOfIndex(10) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l14.1111"></a><span id="l14.1111" class="difflineplus">+        indexedBodyText = aRow.getString(10);</span>
<a href="#l14.1112"></a><span id="l14.1112" class="difflineplus">+      if (aRow.getTypeOfIndex(11) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l14.1113"></a><span id="l14.1113">         attachmentNames = null;</span>
<a href="#l14.1114"></a><span id="l14.1114">       else {</span>
<a href="#l14.1115"></a><span id="l14.1115" class="difflineminus">-        attachmentNames = aRow.getString(10);</span>
<a href="#l14.1116"></a><span id="l14.1116" class="difflineplus">+        attachmentNames = aRow.getString(11);</span>
<a href="#l14.1117"></a><span id="l14.1117">         if (attachmentNames)</span>
<a href="#l14.1118"></a><span id="l14.1118">           attachmentNames = attachmentNames.split(&quot;\n&quot;);</span>
<a href="#l14.1119"></a><span id="l14.1119">         else</span>
<a href="#l14.1120"></a><span id="l14.1120">           attachmentNames = null;</span>
<a href="#l14.1121"></a><span id="l14.1121">       }</span>
<a href="#l14.1122"></a><span id="l14.1122" class="difflineplus">+      // we ignore 12, author</span>
<a href="#l14.1123"></a><span id="l14.1123" class="difflineplus">+      // we ignore 13, recipients</span>
<a href="#l14.1124"></a><span id="l14.1124">     }</span>
<a href="#l14.1125"></a><span id="l14.1125">     return new GlodaMessage(this, aRow.getInt64(0), folderId, messageKey,</span>
<a href="#l14.1126"></a><span id="l14.1126">                             aRow.getInt64(3), null, date, aRow.getString(5),</span>
<a href="#l14.1127"></a><span id="l14.1127" class="difflineminus">-                            aRow.getInt64(6), jsonText,</span>
<a href="#l14.1128"></a><span id="l14.1128" class="difflineplus">+                            aRow.getInt64(6), jsonText, aRow.getInt64(8),</span>
<a href="#l14.1129"></a><span id="l14.1129">                             subject, indexedBodyText, attachmentNames);</span>
<a href="#l14.1130"></a><span id="l14.1130">   },</span>
<a href="#l14.1131"></a><span id="l14.1131"> </span>
<a href="#l14.1132"></a><span id="l14.1132">   get _selectMessageByIDStatement() {</span>
<a href="#l14.1133"></a><span id="l14.1133">     let statement = this._createSyncStatement(</span>
<a href="#l14.1134"></a><span id="l14.1134">       &quot;SELECT id, folderID, messageKey, conversationID, date, headerMessageID, \</span>
<a href="#l14.1135"></a><span id="l14.1135">            deleted FROM messages WHERE id = ?1&quot;);</span>
<a href="#l14.1136"></a><span id="l14.1136">     this.__defineGetter__(&quot;_selectMessageByIDStatement&quot;,</span>
<a href="#l14.1137"></a><span id="l14.1137" class="difflineat">@@ -2189,22 +2226,22 @@ var GlodaDatastore = {</span>
<a href="#l14.1138"></a><span id="l14.1138"> </span>
<a href="#l14.1139"></a><span id="l14.1139">     // Unfortunately, IN doesn't work with statement binding mechanisms, and</span>
<a href="#l14.1140"></a><span id="l14.1140">     //  a chain of ORed tests really can't be bound unless we create one per</span>
<a href="#l14.1141"></a><span id="l14.1141">     //  value of N (seems silly).</span>
<a href="#l14.1142"></a><span id="l14.1142">     let quotedIDs = [&quot;'&quot; + msgID.replace(&quot;'&quot;, &quot;''&quot;, &quot;g&quot;) + &quot;'&quot; for each</span>
<a href="#l14.1143"></a><span id="l14.1143">                      ([i, msgID] in Iterator(aMessageIDs))]</span>
<a href="#l14.1144"></a><span id="l14.1144">     let sqlString = &quot;SELECT * FROM messages WHERE headerMessageID IN (&quot; +</span>
<a href="#l14.1145"></a><span id="l14.1145">                     quotedIDs + &quot;)&quot;;</span>
<a href="#l14.1146"></a><span id="l14.1146" class="difflineminus">-    </span>
<a href="#l14.1147"></a><span id="l14.1147" class="difflineplus">+</span>
<a href="#l14.1148"></a><span id="l14.1148">     let nounDef = GlodaMessage.prototype.NOUN_DEF;</span>
<a href="#l14.1149"></a><span id="l14.1149">     let listener = new MessagesByMessageIdCallback(msgIDToIndex, results,</span>
<a href="#l14.1150"></a><span id="l14.1150">         aCallback, aCallbackThis);</span>
<a href="#l14.1151"></a><span id="l14.1151">     // Use a null query because we don't want any update notifications about our</span>
<a href="#l14.1152"></a><span id="l14.1152" class="difflineminus">-    //  collection.  They would just confuse and anger the listener. </span>
<a href="#l14.1153"></a><span id="l14.1153" class="difflineplus">+    //  collection.  They would just confuse and anger the listener.</span>
<a href="#l14.1154"></a><span id="l14.1154">     let query = new nounDef.nullQueryClass();</span>
<a href="#l14.1155"></a><span id="l14.1155">     return this._queryFromSQLString(sqlString, [], nounDef,</span>
<a href="#l14.1156"></a><span id="l14.1156">         query, listener);</span>
<a href="#l14.1157"></a><span id="l14.1157">   },</span>
<a href="#l14.1158"></a><span id="l14.1158"> </span>
<a href="#l14.1159"></a><span id="l14.1159">   get _updateMessagesMarkDeletedByFolderID() {</span>
<a href="#l14.1160"></a><span id="l14.1160">     let statement = this._createAsyncStatement(</span>
<a href="#l14.1161"></a><span id="l14.1161">       &quot;UPDATE messages SET folderID = NULL, messageKey = NULL, \</span>
<a href="#l14.1162"></a><span id="l14.1162" class="difflineat">@@ -2557,17 +2594,17 @@ var GlodaDatastore = {</span>
<a href="#l14.1163"></a><span id="l14.1163">   clearAttributes: function gloda_ds_clearAttributes(aItem) {</span>
<a href="#l14.1164"></a><span id="l14.1164">     let nounDef = aItem.NOUN_DEF;</span>
<a href="#l14.1165"></a><span id="l14.1165">     let dbMeta = nounMeta._dbMeta;</span>
<a href="#l14.1166"></a><span id="l14.1166">     if (dbMeta.clearAttrStatement === undefined) {</span>
<a href="#l14.1167"></a><span id="l14.1167">       dbMeta.clearAttrStatement = this._createAsyncStatement(</span>
<a href="#l14.1168"></a><span id="l14.1168">         &quot;DELETE FROM &quot; + nounDef.attrTableName + &quot; WHERE &quot; +</span>
<a href="#l14.1169"></a><span id="l14.1169">         nounDef.attrIDColumnName + &quot; = ?1&quot;);</span>
<a href="#l14.1170"></a><span id="l14.1170">     }</span>
<a href="#l14.1171"></a><span id="l14.1171" class="difflineminus">-  </span>
<a href="#l14.1172"></a><span id="l14.1172" class="difflineplus">+</span>
<a href="#l14.1173"></a><span id="l14.1173">     if (aItem.id != null) {</span>
<a href="#l14.1174"></a><span id="l14.1174">       dbMeta.clearAttrStatement.bindInt64Parameter(0, aItem.id);</span>
<a href="#l14.1175"></a><span id="l14.1175">       dbMeta.clearAttrStatement.executeAsync(this.trackAsync());</span>
<a href="#l14.1176"></a><span id="l14.1176">     }</span>
<a href="#l14.1177"></a><span id="l14.1177">   },</span>
<a href="#l14.1178"></a><span id="l14.1178"> </span>
<a href="#l14.1179"></a><span id="l14.1179">   /**</span>
<a href="#l14.1180"></a><span id="l14.1180">    * escapeStringForLIKE is only available on statements, and sometimes we want</span>
<a href="#l14.1181"></a><span id="l14.1181" class="difflineat">@@ -2589,17 +2626,17 @@ var GlodaDatastore = {</span>
<a href="#l14.1182"></a><span id="l14.1182">       for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l14.1183"></a><span id="l14.1183">         let dbValue = objectNounDef.toParamAndValue(aValues[iValue])[1];</span>
<a href="#l14.1184"></a><span id="l14.1184">         if (dbValue != null)</span>
<a href="#l14.1185"></a><span id="l14.1185">           dbValues.push(dbValue);</span>
<a href="#l14.1186"></a><span id="l14.1186">       }</span>
<a href="#l14.1187"></a><span id="l14.1187">       yield [aAttrDef.special ? undefined : aAttrDef.id, dbValues];</span>
<a href="#l14.1188"></a><span id="l14.1188">       return;</span>
<a href="#l14.1189"></a><span id="l14.1189">     }</span>
<a href="#l14.1190"></a><span id="l14.1190" class="difflineminus">-    </span>
<a href="#l14.1191"></a><span id="l14.1191" class="difflineplus">+</span>
<a href="#l14.1192"></a><span id="l14.1192">     let curParam, attrID, dbValues;</span>
<a href="#l14.1193"></a><span id="l14.1193">     let attrDBDef = aAttrDef.dbDef;</span>
<a href="#l14.1194"></a><span id="l14.1194">     for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l14.1195"></a><span id="l14.1195">       let [dbParam, dbValue] = objectNounDef.toParamAndValue(aValues[iValue]);</span>
<a href="#l14.1196"></a><span id="l14.1196">       if (curParam === undefined) {</span>
<a href="#l14.1197"></a><span id="l14.1197">         curParam = dbParam;</span>
<a href="#l14.1198"></a><span id="l14.1198">         attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l14.1199"></a><span id="l14.1199">         if (dbValue != null)</span>
<a href="#l14.1200"></a><span id="l14.1200" class="difflineat">@@ -2643,31 +2680,31 @@ var GlodaDatastore = {</span>
<a href="#l14.1201"></a><span id="l14.1201">         else // no one is null!</span>
<a href="#l14.1202"></a><span id="l14.1202">           dbStrings.push(aValueColumnName + &quot; BETWEEN &quot; +</span>
<a href="#l14.1203"></a><span id="l14.1203">                          objectNounDef.toParamAndValue(lowerVal)[1] + &quot; AND &quot; +</span>
<a href="#l14.1204"></a><span id="l14.1204">                          objectNounDef.toParamAndValue(upperVal)[1]);</span>
<a href="#l14.1205"></a><span id="l14.1205">       }</span>
<a href="#l14.1206"></a><span id="l14.1206">       yield [aAttrDef.special ? undefined : aAttrDef.id, dbStrings];</span>
<a href="#l14.1207"></a><span id="l14.1207">       return;</span>
<a href="#l14.1208"></a><span id="l14.1208">     }</span>
<a href="#l14.1209"></a><span id="l14.1209" class="difflineminus">-    </span>
<a href="#l14.1210"></a><span id="l14.1210" class="difflineplus">+</span>
<a href="#l14.1211"></a><span id="l14.1211">     let curParam, attrID, dbStrings;</span>
<a href="#l14.1212"></a><span id="l14.1212">     let attrDBDef = aAttrDef.dbDef;</span>
<a href="#l14.1213"></a><span id="l14.1213">     for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l14.1214"></a><span id="l14.1214">       let [lowerVal, upperVal] = aValues[iValue];</span>
<a href="#l14.1215"></a><span id="l14.1215"> </span>
<a href="#l14.1216"></a><span id="l14.1216">       let dbString, dbParam, lowerDBVal, upperDBVal;</span>
<a href="#l14.1217"></a><span id="l14.1217">       // they both can't be null.  that is the law.</span>
<a href="#l14.1218"></a><span id="l14.1218">       if (lowerVal == null) {</span>
<a href="#l14.1219"></a><span id="l14.1219">         [dbParam, upperDBVal] = objectNounDef.toParamAndValue(upperVal);</span>
<a href="#l14.1220"></a><span id="l14.1220">         dbString = aValueColumnName + &quot; &lt;= &quot; + upperDBVal;</span>
<a href="#l14.1221"></a><span id="l14.1221">       }</span>
<a href="#l14.1222"></a><span id="l14.1222">       else if (upperVal == null) {</span>
<a href="#l14.1223"></a><span id="l14.1223">         [dbParam, lowerDBVal] = objectNounDef.toParamAndValue(lowerVal);</span>
<a href="#l14.1224"></a><span id="l14.1224" class="difflineminus">-        dbString = aValueColumnName + &quot; &gt;= &quot; + lowerDBVal; </span>
<a href="#l14.1225"></a><span id="l14.1225" class="difflineplus">+        dbString = aValueColumnName + &quot; &gt;= &quot; + lowerDBVal;</span>
<a href="#l14.1226"></a><span id="l14.1226">       }</span>
<a href="#l14.1227"></a><span id="l14.1227">       else { // no one is null!</span>
<a href="#l14.1228"></a><span id="l14.1228">         [dbParam, lowerDBVal] = objectNounDef.toParamAndValue(lowerVal);</span>
<a href="#l14.1229"></a><span id="l14.1229">         dbString = aValueColumnName + &quot; BETWEEN &quot; + lowerDBVal + &quot; AND &quot; +</span>
<a href="#l14.1230"></a><span id="l14.1230">                    objectNounDef.toParamAndValue(upperVal)[1];</span>
<a href="#l14.1231"></a><span id="l14.1231">       }</span>
<a href="#l14.1232"></a><span id="l14.1232"> </span>
<a href="#l14.1233"></a><span id="l14.1233">       if (curParam === undefined) {</span>
<a href="#l14.1234"></a><span id="l14.1234" class="difflineat">@@ -2702,65 +2739,66 @@ var GlodaDatastore = {</span>
<a href="#l14.1235"></a><span id="l14.1235">       aListenerData, aExistingCollection, aMasterCollection, aBecomeExplicit) {</span>
<a href="#l14.1236"></a><span id="l14.1236">     // when changing this method, be sure that GlodaQuery's testMatch function</span>
<a href="#l14.1237"></a><span id="l14.1237">     //  likewise has its changes made.</span>
<a href="#l14.1238"></a><span id="l14.1238">     let nounDef = aQuery._nounDef;</span>
<a href="#l14.1239"></a><span id="l14.1239"> </span>
<a href="#l14.1240"></a><span id="l14.1240">     let whereClauses = [];</span>
<a href="#l14.1241"></a><span id="l14.1241">     let unionQueries = [aQuery].concat(aQuery._unions);</span>
<a href="#l14.1242"></a><span id="l14.1242">     let boundArgs = [];</span>
<a href="#l14.1243"></a><span id="l14.1243" class="difflineminus">-    </span>
<a href="#l14.1244"></a><span id="l14.1244" class="difflineplus">+</span>
<a href="#l14.1245"></a><span id="l14.1245">     // Use the dbQueryValidityConstraintSuffix to provide constraints that</span>
<a href="#l14.1246"></a><span id="l14.1246">     //  filter items down to those that are valid for the query mechanism to</span>
<a href="#l14.1247"></a><span id="l14.1247">     //  return.  For example, in the case of messages, deleted or ghost</span>
<a href="#l14.1248"></a><span id="l14.1248">     //  messages should not be returned by this query layer.  We require</span>
<a href="#l14.1249"></a><span id="l14.1249">     //  hand-rolled SQL to do that for now.</span>
<a href="#l14.1250"></a><span id="l14.1250">     let validityConstraintSuffix  =</span>
<a href="#l14.1251"></a><span id="l14.1251">       nounDef.dbQueryValidityConstraintSuffix || &quot;&quot;;</span>
<a href="#l14.1252"></a><span id="l14.1252"> </span>
<a href="#l14.1253"></a><span id="l14.1253">     for (let iUnion = 0; iUnion &lt; unionQueries.length; iUnion++) {</span>
<a href="#l14.1254"></a><span id="l14.1254">       let curQuery = unionQueries[iUnion];</span>
<a href="#l14.1255"></a><span id="l14.1255">       let selects = [];</span>
<a href="#l14.1256"></a><span id="l14.1256" class="difflineminus">-      </span>
<a href="#l14.1257"></a><span id="l14.1257" class="difflineplus">+</span>
<a href="#l14.1258"></a><span id="l14.1258">       let lastConstraintWasSpecial = false;</span>
<a href="#l14.1259"></a><span id="l14.1259">       let curConstraintIsSpecial;</span>
<a href="#l14.1260"></a><span id="l14.1260"> </span>
<a href="#l14.1261"></a><span id="l14.1261">       for (let iConstraint = 0; iConstraint &lt; curQuery._constraints.length;</span>
<a href="#l14.1262"></a><span id="l14.1262">            iConstraint++) {</span>
<a href="#l14.1263"></a><span id="l14.1263">         let constraint = curQuery._constraints[iConstraint];</span>
<a href="#l14.1264"></a><span id="l14.1264">         let [constraintType, attrDef] = constraint;</span>
<a href="#l14.1265"></a><span id="l14.1265">         let constraintValues = constraint.slice(2);</span>
<a href="#l14.1266"></a><span id="l14.1266" class="difflineminus">-        </span>
<a href="#l14.1267"></a><span id="l14.1267" class="difflineminus">-        let idColumnName, tableColumnName;</span>
<a href="#l14.1268"></a><span id="l14.1268" class="difflineplus">+</span>
<a href="#l14.1269"></a><span id="l14.1269" class="difflineplus">+        let tableName, idColumnName, tableColumnName, valueColumnName;</span>
<a href="#l14.1270"></a><span id="l14.1270">         if (constraintType == this.kConstraintIdIn) {</span>
<a href="#l14.1271"></a><span id="l14.1271">           // we don't need any of the next cases' setup code, and we especially</span>
<a href="#l14.1272"></a><span id="l14.1272">           //  would prefer that attrDef isn't accessed since it's null for us.</span>
<a href="#l14.1273"></a><span id="l14.1273">         }</span>
<a href="#l14.1274"></a><span id="l14.1274">         else if (attrDef.special) {</span>
<a href="#l14.1275"></a><span id="l14.1275">           tableName = nounDef.tableName;</span>
<a href="#l14.1276"></a><span id="l14.1276">           idColumnName = &quot;id&quot;; // canonical id for a table is &quot;id&quot;.</span>
<a href="#l14.1277"></a><span id="l14.1277">           valueColumnName = attrDef.specialColumnName;</span>
<a href="#l14.1278"></a><span id="l14.1278">           curConstraintIsSpecial = true;</span>
<a href="#l14.1279"></a><span id="l14.1279">         }</span>
<a href="#l14.1280"></a><span id="l14.1280">         else {</span>
<a href="#l14.1281"></a><span id="l14.1281">           tableName = nounDef.attrTableName;</span>
<a href="#l14.1282"></a><span id="l14.1282">           idColumnName = nounDef.attrIDColumnName;</span>
<a href="#l14.1283"></a><span id="l14.1283">           valueColumnName = &quot;value&quot;;</span>
<a href="#l14.1284"></a><span id="l14.1284">           curConstraintIsSpecial = false;</span>
<a href="#l14.1285"></a><span id="l14.1285">         }</span>
<a href="#l14.1286"></a><span id="l14.1286" class="difflineminus">-        </span>
<a href="#l14.1287"></a><span id="l14.1287" class="difflineplus">+</span>
<a href="#l14.1288"></a><span id="l14.1288">         let select = null, test = null, bindArgs = null;</span>
<a href="#l14.1289"></a><span id="l14.1289">         if (constraintType === this.kConstraintIdIn) {</span>
<a href="#l14.1290"></a><span id="l14.1290">           // this is somewhat of a trick.  this does mean that this can be the</span>
<a href="#l14.1291"></a><span id="l14.1291">           //  only constraint.  Namely, our idiom is:</span>
<a href="#l14.1292"></a><span id="l14.1292">           // SELECT * FROM blah WHERE id IN (a INTERSECT b INTERSECT c)</span>
<a href="#l14.1293"></a><span id="l14.1293">           //  but if we only have 'a', then that becomes &quot;...IN (a)&quot;, and if</span>
<a href="#l14.1294"></a><span id="l14.1294" class="difflineminus">-          //  'a' is not a select but a list of id's... tricky, no?  </span>
<a href="#l14.1295"></a><span id="l14.1295" class="difflineplus">+          //  'a' is not a select but a list of id's... tricky, no?</span>
<a href="#l14.1296"></a><span id="l14.1296">           select = constraintValues.join(&quot;,&quot;);</span>
<a href="#l14.1297"></a><span id="l14.1297">         }</span>
<a href="#l14.1298"></a><span id="l14.1298" class="difflineplus">+        // @testpoint gloda.datastore.sqlgen.kConstraintIn</span>
<a href="#l14.1299"></a><span id="l14.1299">         else if (constraintType === this.kConstraintIn) {</span>
<a href="#l14.1300"></a><span id="l14.1300">           let clauses = [];</span>
<a href="#l14.1301"></a><span id="l14.1301">           for each ([attrID, values] in</span>
<a href="#l14.1302"></a><span id="l14.1302">               this._convertToDBValuesAndGroupByAttributeID(attrDef,</span>
<a href="#l14.1303"></a><span id="l14.1303">                                                            constraintValues)) {</span>
<a href="#l14.1304"></a><span id="l14.1304">             let clausePart;</span>
<a href="#l14.1305"></a><span id="l14.1305">             if (attrID !== undefined)</span>
<a href="#l14.1306"></a><span id="l14.1306">               clausePart = &quot;(attributeID = &quot; + attrID +</span>
<a href="#l14.1307"></a><span id="l14.1307" class="difflineat">@@ -2781,125 +2819,136 @@ var GlodaDatastore = {</span>
<a href="#l14.1308"></a><span id="l14.1308">                               &quot;))&quot;;</span>
<a href="#l14.1309"></a><span id="l14.1309">             }</span>
<a href="#l14.1310"></a><span id="l14.1310">             else</span>
<a href="#l14.1311"></a><span id="l14.1311">               clausePart += &quot;)&quot;;</span>
<a href="#l14.1312"></a><span id="l14.1312">             clauses.push(clausePart);</span>
<a href="#l14.1313"></a><span id="l14.1313">           }</span>
<a href="#l14.1314"></a><span id="l14.1314">           test = clauses.join(&quot; OR &quot;);</span>
<a href="#l14.1315"></a><span id="l14.1315">         }</span>
<a href="#l14.1316"></a><span id="l14.1316" class="difflineplus">+        // @testpoint gloda.datastore.sqlgen.kConstraintRanges</span>
<a href="#l14.1317"></a><span id="l14.1317">         else if (constraintType === this.kConstraintRanges) {</span>
<a href="#l14.1318"></a><span id="l14.1318">           let clauses = [];</span>
<a href="#l14.1319"></a><span id="l14.1319">           for each ([attrID, dbStrings] in</span>
<a href="#l14.1320"></a><span id="l14.1320">               this._convertRangesToDBStringsAndGroupByAttributeID(attrDef,</span>
<a href="#l14.1321"></a><span id="l14.1321">                               constraintValues, valueColumnName)) {</span>
<a href="#l14.1322"></a><span id="l14.1322">             if (attrID !== undefined)</span>
<a href="#l14.1323"></a><span id="l14.1323">               clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l14.1324"></a><span id="l14.1324">                            &quot; AND (&quot; + dbStrings.join(&quot; OR &quot;) + &quot;))&quot;);</span>
<a href="#l14.1325"></a><span id="l14.1325">             else</span>
<a href="#l14.1326"></a><span id="l14.1326">               clauses.push(&quot;(&quot; + dbStrings.join(&quot; OR &quot;) + &quot;)&quot;);</span>
<a href="#l14.1327"></a><span id="l14.1327">           }</span>
<a href="#l14.1328"></a><span id="l14.1328">           test = clauses.join(&quot; OR &quot;);</span>
<a href="#l14.1329"></a><span id="l14.1329">         }</span>
<a href="#l14.1330"></a><span id="l14.1330" class="difflineplus">+        // @testpoint gloda.datastore.sqlgen.kConstraintEquals</span>
<a href="#l14.1331"></a><span id="l14.1331">         else if (constraintType === this.kConstraintEquals) {</span>
<a href="#l14.1332"></a><span id="l14.1332">           let clauses = [];</span>
<a href="#l14.1333"></a><span id="l14.1333">           for each ([attrID, values] in</span>
<a href="#l14.1334"></a><span id="l14.1334">               this._convertToDBValuesAndGroupByAttributeID(attrDef,</span>
<a href="#l14.1335"></a><span id="l14.1335">                                                            constraintValues)) {</span>
<a href="#l14.1336"></a><span id="l14.1336">             if (attrID !== undefined)</span>
<a href="#l14.1337"></a><span id="l14.1337">               clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l14.1338"></a><span id="l14.1338">                   &quot; AND (&quot; + [valueColumnName + &quot; = ?&quot; for each</span>
<a href="#l14.1339"></a><span id="l14.1339">                   (value in values)].join(&quot; OR &quot;) + &quot;))&quot;);</span>
<a href="#l14.1340"></a><span id="l14.1340">             else</span>
<a href="#l14.1341"></a><span id="l14.1341">               clauses.push(&quot;(&quot; + [valueColumnName + &quot; = ?&quot; for each</span>
<a href="#l14.1342"></a><span id="l14.1342">                   (value in values)].join(&quot; OR &quot;) + &quot;)&quot;);</span>
<a href="#l14.1343"></a><span id="l14.1343">             boundArgs.push.apply(boundArgs, values);</span>
<a href="#l14.1344"></a><span id="l14.1344">           }</span>
<a href="#l14.1345"></a><span id="l14.1345">           test = clauses.join(&quot; OR &quot;);</span>
<a href="#l14.1346"></a><span id="l14.1346">         }</span>
<a href="#l14.1347"></a><span id="l14.1347" class="difflineplus">+        // @testpoint gloda.datastore.sqlgen.kConstraintStringLike</span>
<a href="#l14.1348"></a><span id="l14.1348">         else if (constraintType === this.kConstraintStringLike) {</span>
<a href="#l14.1349"></a><span id="l14.1349" class="difflineminus">-          likePayload = '';</span>
<a href="#l14.1350"></a><span id="l14.1350" class="difflineplus">+          let likePayload = '';</span>
<a href="#l14.1351"></a><span id="l14.1351">           for each (let [iValuePart, valuePart] in Iterator(constraintValues)) {</span>
<a href="#l14.1352"></a><span id="l14.1352">             if (typeof valuePart == &quot;string&quot;)</span>
<a href="#l14.1353"></a><span id="l14.1353">               likePayload += this._escapeLikeStatement.escapeStringForLIKE(</span>
<a href="#l14.1354"></a><span id="l14.1354">                 valuePart, &quot;/&quot;);</span>
<a href="#l14.1355"></a><span id="l14.1355">             else</span>
<a href="#l14.1356"></a><span id="l14.1356">               likePayload += &quot;%&quot;;</span>
<a href="#l14.1357"></a><span id="l14.1357">           }</span>
<a href="#l14.1358"></a><span id="l14.1358">           test = valueColumnName + &quot; LIKE ? ESCAPE '/'&quot;;</span>
<a href="#l14.1359"></a><span id="l14.1359">           boundArgs.push(likePayload);</span>
<a href="#l14.1360"></a><span id="l14.1360">         }</span>
<a href="#l14.1361"></a><span id="l14.1361" class="difflineplus">+        // @testpoint gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l14.1362"></a><span id="l14.1362">         else if (constraintType === this.kConstraintFulltext) {</span>
<a href="#l14.1363"></a><span id="l14.1363">           let matchStr = constraintValues[0];</span>
<a href="#l14.1364"></a><span id="l14.1364">           select = &quot;SELECT docid FROM &quot; + nounDef.tableName + &quot;Text&quot; +</span>
<a href="#l14.1365"></a><span id="l14.1365">             &quot; WHERE &quot; + attrDef.specialColumnName + &quot; MATCH ?&quot;;</span>
<a href="#l14.1366"></a><span id="l14.1366">           boundArgs.push(matchStr);</span>
<a href="#l14.1367"></a><span id="l14.1367">         }</span>
<a href="#l14.1368"></a><span id="l14.1368" class="difflineminus">-        </span>
<a href="#l14.1369"></a><span id="l14.1369" class="difflineplus">+</span>
<a href="#l14.1370"></a><span id="l14.1370">         if (curConstraintIsSpecial &amp;&amp; lastConstraintWasSpecial &amp;&amp; test) {</span>
<a href="#l14.1371"></a><span id="l14.1371">           selects[selects.length-1] += &quot; AND &quot; + test;</span>
<a href="#l14.1372"></a><span id="l14.1372">         }</span>
<a href="#l14.1373"></a><span id="l14.1373">         else if (select)</span>
<a href="#l14.1374"></a><span id="l14.1374" class="difflineminus">-          selects.push(select)</span>
<a href="#l14.1375"></a><span id="l14.1375" class="difflineplus">+          selects.push(select);</span>
<a href="#l14.1376"></a><span id="l14.1376">         else if (test) {</span>
<a href="#l14.1377"></a><span id="l14.1377">           select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName + &quot; WHERE &quot; +</span>
<a href="#l14.1378"></a><span id="l14.1378">               test;</span>
<a href="#l14.1379"></a><span id="l14.1379">           selects.push(select);</span>
<a href="#l14.1380"></a><span id="l14.1380">         }</span>
<a href="#l14.1381"></a><span id="l14.1381">         else</span>
<a href="#l14.1382"></a><span id="l14.1382" class="difflineminus">-          this._log.warning(&quot;Unable to translate constraint of type &quot; + </span>
<a href="#l14.1383"></a><span id="l14.1383" class="difflineplus">+          this._log.warning(&quot;Unable to translate constraint of type &quot; +</span>
<a href="#l14.1384"></a><span id="l14.1384">             constraintType + &quot; on attribute bound as &quot; + aAttrDef.boundName);</span>
<a href="#l14.1385"></a><span id="l14.1385"> </span>
<a href="#l14.1386"></a><span id="l14.1386">         lastConstraintWasSpecial = curConstraintIsSpecial;</span>
<a href="#l14.1387"></a><span id="l14.1387">       }</span>
<a href="#l14.1388"></a><span id="l14.1388"> </span>
<a href="#l14.1389"></a><span id="l14.1389">       if (selects.length)</span>
<a href="#l14.1390"></a><span id="l14.1390">         whereClauses.push(&quot;id IN (&quot; + selects.join(&quot; INTERSECT &quot;) + &quot;)&quot; +</span>
<a href="#l14.1391"></a><span id="l14.1391">                           validityConstraintSuffix);</span>
<a href="#l14.1392"></a><span id="l14.1392">     }</span>
<a href="#l14.1393"></a><span id="l14.1393"> </span>
<a href="#l14.1394"></a><span id="l14.1394">     let sqlString = &quot;SELECT * FROM &quot; + nounDef.tableName;</span>
<a href="#l14.1395"></a><span id="l14.1395" class="difflineminus">-    if (nounDef.dbQueryJoinMagic)</span>
<a href="#l14.1396"></a><span id="l14.1396" class="difflineplus">+    if (nounDef.dbQueryJoinMagic &amp;&amp; !aQuery.options.noMagic)</span>
<a href="#l14.1397"></a><span id="l14.1397">       sqlString += nounDef.dbQueryJoinMagic;</span>
<a href="#l14.1398"></a><span id="l14.1398">     if (whereClauses.length)</span>
<a href="#l14.1399"></a><span id="l14.1399">       sqlString += &quot; WHERE (&quot; + whereClauses.join(&quot;) OR (&quot;) + &quot;)&quot;;</span>
<a href="#l14.1400"></a><span id="l14.1400" class="difflineminus">-    </span>
<a href="#l14.1401"></a><span id="l14.1401" class="difflineplus">+</span>
<a href="#l14.1402"></a><span id="l14.1402" class="difflineplus">+    if (aQuery.options.explicitSQL)</span>
<a href="#l14.1403"></a><span id="l14.1403" class="difflineplus">+      sqlString = aQuery.options.explicitSQL;</span>
<a href="#l14.1404"></a><span id="l14.1404" class="difflineplus">+</span>
<a href="#l14.1405"></a><span id="l14.1405" class="difflineplus">+    if (aQuery.options.outerWrapColumns)</span>
<a href="#l14.1406"></a><span id="l14.1406" class="difflineplus">+      sqlString = &quot;SELECT *, &quot; + aQuery.options.outerWrapColumns.join(&quot;, &quot;) +</span>
<a href="#l14.1407"></a><span id="l14.1407" class="difflineplus">+                  &quot; FROM (&quot; + sqlString + &quot;)&quot;;</span>
<a href="#l14.1408"></a><span id="l14.1408" class="difflineplus">+</span>
<a href="#l14.1409"></a><span id="l14.1409">     if (aQuery._order.length) {</span>
<a href="#l14.1410"></a><span id="l14.1410">       let orderClauses = [];</span>
<a href="#l14.1411"></a><span id="l14.1411">       for (let [, colName] in Iterator(aQuery._order)) {</span>
<a href="#l14.1412"></a><span id="l14.1412">          if (colName[0] == &quot;-&quot;)</span>
<a href="#l14.1413"></a><span id="l14.1413">            orderClauses.push(colName.substring(1) + &quot; DESC&quot;);</span>
<a href="#l14.1414"></a><span id="l14.1414">          else</span>
<a href="#l14.1415"></a><span id="l14.1415">            orderClauses.push(colName + &quot; ASC&quot;);</span>
<a href="#l14.1416"></a><span id="l14.1416">       }</span>
<a href="#l14.1417"></a><span id="l14.1417">       sqlString += &quot; ORDER BY &quot; + orderClauses.join(&quot;, &quot;);</span>
<a href="#l14.1418"></a><span id="l14.1418">     }</span>
<a href="#l14.1419"></a><span id="l14.1419" class="difflineminus">-    </span>
<a href="#l14.1420"></a><span id="l14.1420" class="difflineplus">+</span>
<a href="#l14.1421"></a><span id="l14.1421">     if (aQuery._limit) {</span>
<a href="#l14.1422"></a><span id="l14.1422">       sqlString += &quot; LIMIT ?&quot;;</span>
<a href="#l14.1423"></a><span id="l14.1423" class="difflineminus">-      boundArgs.push(aQuery._limit); </span>
<a href="#l14.1424"></a><span id="l14.1424" class="difflineplus">+      boundArgs.push(aQuery._limit);</span>
<a href="#l14.1425"></a><span id="l14.1425">     }</span>
<a href="#l14.1426"></a><span id="l14.1426"> </span>
<a href="#l14.1427"></a><span id="l14.1427">     this._log.debug(&quot;QUERY FROM QUERY: &quot; + sqlString + &quot; ARGS: &quot; + boundArgs);</span>
<a href="#l14.1428"></a><span id="l14.1428" class="difflineminus">-    </span>
<a href="#l14.1429"></a><span id="l14.1429" class="difflineplus">+</span>
<a href="#l14.1430"></a><span id="l14.1430">     // if we want to become explicit, replace the query (which has already</span>
<a href="#l14.1431"></a><span id="l14.1431">     //  provided our actual SQL query) with an explicit query.  This will be</span>
<a href="#l14.1432"></a><span id="l14.1432">     //  what gets attached to the collection in the event we create a new</span>
<a href="#l14.1433"></a><span id="l14.1433">     //  collection.  If we are reusing one, we assume that the explicitness,</span>
<a href="#l14.1434"></a><span id="l14.1434">     //  if desired, already happened.</span>
<a href="#l14.1435"></a><span id="l14.1435">     // (we do not need to pass an argument to the explicitQueryClass constructor</span>
<a href="#l14.1436"></a><span id="l14.1436">     //  because it will be passed in to the collection's constructor, which will</span>
<a href="#l14.1437"></a><span id="l14.1437">     //  ensure that the collection attribute gets set.)</span>
<a href="#l14.1438"></a><span id="l14.1438">     if (aBecomeExplicit)</span>
<a href="#l14.1439"></a><span id="l14.1439">       aQuery = new nounDef.explicitQueryClass();</span>
<a href="#l14.1440"></a><span id="l14.1440"> </span>
<a href="#l14.1441"></a><span id="l14.1441">     return this._queryFromSQLString(sqlString, boundArgs, nounDef, aQuery,</span>
<a href="#l14.1442"></a><span id="l14.1442">         aListener, aListenerData, aExistingCollection, aMasterCollection);</span>
<a href="#l14.1443"></a><span id="l14.1443">   },</span>
<a href="#l14.1444"></a><span id="l14.1444" class="difflineminus">-  </span>
<a href="#l14.1445"></a><span id="l14.1445" class="difflineplus">+</span>
<a href="#l14.1446"></a><span id="l14.1446">   _queryFromSQLString: function gloda_ds__queryFromSQLString(aSqlString,</span>
<a href="#l14.1447"></a><span id="l14.1447">       aBoundArgs, aNounDef, aQuery, aListener, aListenerData,</span>
<a href="#l14.1448"></a><span id="l14.1448">       aExistingCollection, aMasterCollection) {</span>
<a href="#l14.1449"></a><span id="l14.1449">     let statement = this._createAsyncStatement(aSqlString, true);</span>
<a href="#l14.1450"></a><span id="l14.1450">     for (let [iBinding, bindingValue] in Iterator(aBoundArgs)) {</span>
<a href="#l14.1451"></a><span id="l14.1451">       this._bindVariant(statement, iBinding, bindingValue);</span>
<a href="#l14.1452"></a><span id="l14.1452">     }</span>
<a href="#l14.1453"></a><span id="l14.1453"> </span>
<a href="#l14.1454"></a><span id="l14.1454" class="difflineat">@@ -2925,33 +2974,33 @@ var GlodaDatastore = {</span>
<a href="#l14.1455"></a><span id="l14.1455"> </span>
<a href="#l14.1456"></a><span id="l14.1456">     statement.executeAsync(new QueryFromQueryCallback(statement, aNounDef,</span>
<a href="#l14.1457"></a><span id="l14.1457">       collection));</span>
<a href="#l14.1458"></a><span id="l14.1458">     statement.finalize();</span>
<a href="#l14.1459"></a><span id="l14.1459">     return collection;</span>
<a href="#l14.1460"></a><span id="l14.1460">   },</span>
<a href="#l14.1461"></a><span id="l14.1461"> </span>
<a href="#l14.1462"></a><span id="l14.1462">   /**</span>
<a href="#l14.1463"></a><span id="l14.1463" class="difflineminus">-   * </span>
<a href="#l14.1464"></a><span id="l14.1464" class="difflineminus">-   * </span>
<a href="#l14.1465"></a><span id="l14.1465" class="difflineplus">+   *</span>
<a href="#l14.1466"></a><span id="l14.1466" class="difflineplus">+   *</span>
<a href="#l14.1467"></a><span id="l14.1467">    */</span>
<a href="#l14.1468"></a><span id="l14.1468">   loadNounItem: function gloda_ds_loadNounItem(aItem, aReferencesByNounID,</span>
<a href="#l14.1469"></a><span id="l14.1469">       aInverseReferencesByNounID) {</span>
<a href="#l14.1470"></a><span id="l14.1470">     let attribIDToDBDefAndParam = this._attributeIDToDBDefAndParam;</span>
<a href="#l14.1471"></a><span id="l14.1471" class="difflineminus">-    </span>
<a href="#l14.1472"></a><span id="l14.1472" class="difflineplus">+</span>
<a href="#l14.1473"></a><span id="l14.1473">     let hadDeps = aItem._deps != null;</span>
<a href="#l14.1474"></a><span id="l14.1474">     let deps = aItem._deps || {};</span>
<a href="#l14.1475"></a><span id="l14.1475">     let hasDeps = false;</span>
<a href="#l14.1476"></a><span id="l14.1476" class="difflineminus">-    </span>
<a href="#l14.1477"></a><span id="l14.1477" class="difflineminus">-    //this._log.debug(&quot;  hadDeps: &quot; + hadDeps + &quot; deps: &quot; + </span>
<a href="#l14.1478"></a><span id="l14.1478" class="difflineplus">+</span>
<a href="#l14.1479"></a><span id="l14.1479" class="difflineplus">+    //this._log.debug(&quot;  hadDeps: &quot; + hadDeps + &quot; deps: &quot; +</span>
<a href="#l14.1480"></a><span id="l14.1480">     //    Log4Moz.enumerateProperties(deps).join(&quot;,&quot;));</span>
<a href="#l14.1481"></a><span id="l14.1481" class="difflineminus">-    </span>
<a href="#l14.1482"></a><span id="l14.1482" class="difflineplus">+</span>
<a href="#l14.1483"></a><span id="l14.1483">     for each (let [, attrib] in Iterator(aItem.NOUN_DEF.specialLoadAttribs)) {</span>
<a href="#l14.1484"></a><span id="l14.1484">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l14.1485"></a><span id="l14.1485" class="difflineminus">-      </span>
<a href="#l14.1486"></a><span id="l14.1486" class="difflineplus">+</span>
<a href="#l14.1487"></a><span id="l14.1487">       if (attrib.special === this.kSpecialColumnChildren) {</span>
<a href="#l14.1488"></a><span id="l14.1488">         let invReferences = aInverseReferencesByNounID[objectNounDef.id];</span>
<a href="#l14.1489"></a><span id="l14.1489">         if (invReferences === undefined)</span>
<a href="#l14.1490"></a><span id="l14.1490">           invReferences = aInverseReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l14.1491"></a><span id="l14.1491">         // only contribute if it's not already pending or there</span>
<a href="#l14.1492"></a><span id="l14.1492">         if (!(attrib.id in deps) &amp;&amp; aItem[attrib.storageAttributeName] == null){</span>
<a href="#l14.1493"></a><span id="l14.1493">           //this._log.debug(&quot;   Adding inv ref for: &quot; + aItem.id);</span>
<a href="#l14.1494"></a><span id="l14.1494">           if (!(aItem.id in invReferences))</span>
<a href="#l14.1495"></a><span id="l14.1495" class="difflineat">@@ -2960,75 +3009,75 @@ var GlodaDatastore = {</span>
<a href="#l14.1496"></a><span id="l14.1496">           hasDeps = true;</span>
<a href="#l14.1497"></a><span id="l14.1497">         }</span>
<a href="#l14.1498"></a><span id="l14.1498">       }</span>
<a href="#l14.1499"></a><span id="l14.1499">       else if (attrib.special === this.kSpecialColumnParent) {</span>
<a href="#l14.1500"></a><span id="l14.1500">         let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l14.1501"></a><span id="l14.1501">         if (references === undefined)</span>
<a href="#l14.1502"></a><span id="l14.1502">           references = aReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l14.1503"></a><span id="l14.1503">         // nothing to contribute if it's already there</span>
<a href="#l14.1504"></a><span id="l14.1504" class="difflineminus">-        if (!(attrib.id in deps) &amp;&amp; </span>
<a href="#l14.1505"></a><span id="l14.1505" class="difflineplus">+        if (!(attrib.id in deps) &amp;&amp;</span>
<a href="#l14.1506"></a><span id="l14.1506">             aItem[attrib.valueStorageAttributeName] == null) {</span>
<a href="#l14.1507"></a><span id="l14.1507">           let parentID = aItem[attrib.idStorageAttributeName];</span>
<a href="#l14.1508"></a><span id="l14.1508">           if (!(parentID in references))</span>
<a href="#l14.1509"></a><span id="l14.1509">             references[parentID] = null;</span>
<a href="#l14.1510"></a><span id="l14.1510">           //this._log.debug(&quot;   Adding parent ref for: &quot; +</span>
<a href="#l14.1511"></a><span id="l14.1511">           //  aItem[attrib.idStorageAttributeName]);</span>
<a href="#l14.1512"></a><span id="l14.1512">           deps[attrib.id] = null;</span>
<a href="#l14.1513"></a><span id="l14.1513">           hasDeps = true;</span>
<a href="#l14.1514"></a><span id="l14.1514">         }</span>
<a href="#l14.1515"></a><span id="l14.1515">         else {</span>
<a href="#l14.1516"></a><span id="l14.1516">           this._log.debug(&quot;  paranoia value storage: &quot; + aItem[attrib.valueStorageAttributeName]);</span>
<a href="#l14.1517"></a><span id="l14.1517">         }</span>
<a href="#l14.1518"></a><span id="l14.1518">       }</span>
<a href="#l14.1519"></a><span id="l14.1519">     }</span>
<a href="#l14.1520"></a><span id="l14.1520" class="difflineminus">-    </span>
<a href="#l14.1521"></a><span id="l14.1521" class="difflineplus">+</span>
<a href="#l14.1522"></a><span id="l14.1522">     // bail here if arbitrary values are not allowed, there just is no</span>
<a href="#l14.1523"></a><span id="l14.1523">     //  encoded json, or we already had dependencies for this guy, implying</span>
<a href="#l14.1524"></a><span id="l14.1524">     //  the json pass has already been performed</span>
<a href="#l14.1525"></a><span id="l14.1525">     if (!aItem.NOUN_DEF.allowsArbitraryAttrs || !aItem._jsonText || hadDeps) {</span>
<a href="#l14.1526"></a><span id="l14.1526">       if (hasDeps)</span>
<a href="#l14.1527"></a><span id="l14.1527">         aItem._deps = deps;</span>
<a href="#l14.1528"></a><span id="l14.1528">       return hasDeps;</span>
<a href="#l14.1529"></a><span id="l14.1529">     }</span>
<a href="#l14.1530"></a><span id="l14.1530"> </span>
<a href="#l14.1531"></a><span id="l14.1531">     //this._log.debug(&quot; load json: &quot; + aItem._jsonText);</span>
<a href="#l14.1532"></a><span id="l14.1532">     let jsonDict = this._json.decode(aItem._jsonText);</span>
<a href="#l14.1533"></a><span id="l14.1533">     delete aItem._jsonText;</span>
<a href="#l14.1534"></a><span id="l14.1534" class="difflineminus">-    </span>
<a href="#l14.1535"></a><span id="l14.1535" class="difflineplus">+</span>
<a href="#l14.1536"></a><span id="l14.1536">     // Iterate over the attributes on the item</span>
<a href="#l14.1537"></a><span id="l14.1537">     for each (let [attribId, jsonValue] in Iterator(jsonDict)) {</span>
<a href="#l14.1538"></a><span id="l14.1538">       // find the attribute definition that corresponds to this key</span>
<a href="#l14.1539"></a><span id="l14.1539">       let dbAttrib = attribIDToDBDefAndParam[attribId][0];</span>
<a href="#l14.1540"></a><span id="l14.1540">       // the attribute should only fail to exist if an extension was removed</span>
<a href="#l14.1541"></a><span id="l14.1541">       if (dbAttrib === undefined)</span>
<a href="#l14.1542"></a><span id="l14.1542">         continue;</span>
<a href="#l14.1543"></a><span id="l14.1543" class="difflineminus">-      </span>
<a href="#l14.1544"></a><span id="l14.1544" class="difflineplus">+</span>
<a href="#l14.1545"></a><span id="l14.1545">       let attrib = dbAttrib.attrDef;</span>
<a href="#l14.1546"></a><span id="l14.1546">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l14.1547"></a><span id="l14.1547" class="difflineminus">-      </span>
<a href="#l14.1548"></a><span id="l14.1548" class="difflineplus">+</span>
<a href="#l14.1549"></a><span id="l14.1549">       // if it has a tableName member, then it's a persistent object that needs</span>
<a href="#l14.1550"></a><span id="l14.1550">       //  to be loaded, which also means we need to hold it in a collection</span>
<a href="#l14.1551"></a><span id="l14.1551">       //  owned by our collection.</span>
<a href="#l14.1552"></a><span id="l14.1552">       if (objectNounDef.tableName) {</span>
<a href="#l14.1553"></a><span id="l14.1553">         let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l14.1554"></a><span id="l14.1554">         if (references === undefined)</span>
<a href="#l14.1555"></a><span id="l14.1555">           references = aReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l14.1556"></a><span id="l14.1556" class="difflineminus">-          </span>
<a href="#l14.1557"></a><span id="l14.1557" class="difflineplus">+</span>
<a href="#l14.1558"></a><span id="l14.1558">         if (attrib.singular) {</span>
<a href="#l14.1559"></a><span id="l14.1559">           if (!(jsonValue in references))</span>
<a href="#l14.1560"></a><span id="l14.1560">             references[jsonValue] = null;</span>
<a href="#l14.1561"></a><span id="l14.1561">         }</span>
<a href="#l14.1562"></a><span id="l14.1562">         else {</span>
<a href="#l14.1563"></a><span id="l14.1563">           for each (let [, anID] in Iterator(jsonValue)) {</span>
<a href="#l14.1564"></a><span id="l14.1564">             if (!(anID in references))</span>
<a href="#l14.1565"></a><span id="l14.1565">             references[anID] = null;</span>
<a href="#l14.1566"></a><span id="l14.1566">           }</span>
<a href="#l14.1567"></a><span id="l14.1567">         }</span>
<a href="#l14.1568"></a><span id="l14.1568" class="difflineminus">-        </span>
<a href="#l14.1569"></a><span id="l14.1569" class="difflineplus">+</span>
<a href="#l14.1570"></a><span id="l14.1570">         deps[attribId] = jsonValue;</span>
<a href="#l14.1571"></a><span id="l14.1571">         hasDeps = true;</span>
<a href="#l14.1572"></a><span id="l14.1572">       }</span>
<a href="#l14.1573"></a><span id="l14.1573">       /* if it has custom contribution logic, use it */</span>
<a href="#l14.1574"></a><span id="l14.1574">       else if (objectNounDef.contributeObjDependencies) {</span>
<a href="#l14.1575"></a><span id="l14.1575">         if (objectNounDef.contributeObjDependencies(jsonValue,</span>
<a href="#l14.1576"></a><span id="l14.1576">                              aReferencesByNounID, aInverseReferencesByNounID)) {</span>
<a href="#l14.1577"></a><span id="l14.1577">           deps[attribId] = jsonValue;</span>
<a href="#l14.1578"></a><span id="l14.1578" class="difflineat">@@ -3044,37 +3093,37 @@ var GlodaDatastore = {</span>
<a href="#l14.1579"></a><span id="l14.1579">         else</span>
<a href="#l14.1580"></a><span id="l14.1580">           aItem[attrib.boundName] = [objectNounDef.fromJSON(val) for each</span>
<a href="#l14.1581"></a><span id="l14.1581">             ([, val] in Iterator(jsonValue))];</span>
<a href="#l14.1582"></a><span id="l14.1582">       }</span>
<a href="#l14.1583"></a><span id="l14.1583">       // it's fine as is</span>
<a href="#l14.1584"></a><span id="l14.1584">       else</span>
<a href="#l14.1585"></a><span id="l14.1585">         aItem[attrib.boundName] = jsonValue;</span>
<a href="#l14.1586"></a><span id="l14.1586">     }</span>
<a href="#l14.1587"></a><span id="l14.1587" class="difflineminus">-    </span>
<a href="#l14.1588"></a><span id="l14.1588" class="difflineplus">+</span>
<a href="#l14.1589"></a><span id="l14.1589">     if (hasDeps)</span>
<a href="#l14.1590"></a><span id="l14.1590">       aItem._deps = deps;</span>
<a href="#l14.1591"></a><span id="l14.1591">     return hasDeps;</span>
<a href="#l14.1592"></a><span id="l14.1592">   },</span>
<a href="#l14.1593"></a><span id="l14.1593" class="difflineminus">-  </span>
<a href="#l14.1594"></a><span id="l14.1594" class="difflineplus">+</span>
<a href="#l14.1595"></a><span id="l14.1595">   loadNounDeferredDeps: function gloda_ds_loadNounDeferredDeps(aItem,</span>
<a href="#l14.1596"></a><span id="l14.1596">       aReferencesByNounID, aInverseReferencesByNounID) {</span>
<a href="#l14.1597"></a><span id="l14.1597">     if (aItem._deps === undefined)</span>
<a href="#l14.1598"></a><span id="l14.1598">       return;</span>
<a href="#l14.1599"></a><span id="l14.1599"> </span>
<a href="#l14.1600"></a><span id="l14.1600" class="difflineminus">-    //this._log.debug(&quot;  loading deferred, deps: &quot; + </span>
<a href="#l14.1601"></a><span id="l14.1601" class="difflineplus">+    //this._log.debug(&quot;  loading deferred, deps: &quot; +</span>
<a href="#l14.1602"></a><span id="l14.1602">     //    Log4Moz.enumerateProperties(aItem._deps).join(&quot;,&quot;));</span>
<a href="#l14.1603"></a><span id="l14.1603"> </span>
<a href="#l14.1604"></a><span id="l14.1604" class="difflineminus">-    </span>
<a href="#l14.1605"></a><span id="l14.1605" class="difflineplus">+</span>
<a href="#l14.1606"></a><span id="l14.1606">     let attribIDToDBDefAndParam = this._attributeIDToDBDefAndParam;</span>
<a href="#l14.1607"></a><span id="l14.1607"> </span>
<a href="#l14.1608"></a><span id="l14.1608">     for (let [attribId, jsonValue] in Iterator(aItem._deps)) {</span>
<a href="#l14.1609"></a><span id="l14.1609">       let dbAttrib = attribIDToDBDefAndParam[attribId][0];</span>
<a href="#l14.1610"></a><span id="l14.1610">       let attrib = dbAttrib.attrDef;</span>
<a href="#l14.1611"></a><span id="l14.1611" class="difflineminus">-      </span>
<a href="#l14.1612"></a><span id="l14.1612" class="difflineplus">+</span>
<a href="#l14.1613"></a><span id="l14.1613">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l14.1614"></a><span id="l14.1614">       let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l14.1615"></a><span id="l14.1615">       if (attrib.special) {</span>
<a href="#l14.1616"></a><span id="l14.1616">         if (attrib.special === this.kSpecialColumnChildren) {</span>
<a href="#l14.1617"></a><span id="l14.1617">           let inverseReferences = aInverseReferencesByNounID[objectNounDef.id];</span>
<a href="#l14.1618"></a><span id="l14.1618">           //this._log.info(&quot;inverse assignment: &quot; + objectNounDef.id +</span>
<a href="#l14.1619"></a><span id="l14.1619">           //    &quot; of &quot; + aItem.id)</span>
<a href="#l14.1620"></a><span id="l14.1620">           aItem[attrib.storageAttributeName] = inverseReferences[aItem.id];</span>
<a href="#l14.1621"></a><span id="l14.1621" class="difflineat">@@ -3097,17 +3146,17 @@ var GlodaDatastore = {</span>
<a href="#l14.1622"></a><span id="l14.1622">       }</span>
<a href="#l14.1623"></a><span id="l14.1623">       else if (objectNounDef.contributeObjDependencies) {</span>
<a href="#l14.1624"></a><span id="l14.1624">         aItem[attrib.boundName] =</span>
<a href="#l14.1625"></a><span id="l14.1625">           objectNounDef.resolveObjDependencies(jsonValue, aReferencesByNounID,</span>
<a href="#l14.1626"></a><span id="l14.1626">             aInverseReferencesByNounID);</span>
<a href="#l14.1627"></a><span id="l14.1627">       }</span>
<a href="#l14.1628"></a><span id="l14.1628">       // there is no other case</span>
<a href="#l14.1629"></a><span id="l14.1629">     }</span>
<a href="#l14.1630"></a><span id="l14.1630" class="difflineminus">-    </span>
<a href="#l14.1631"></a><span id="l14.1631" class="difflineplus">+</span>
<a href="#l14.1632"></a><span id="l14.1632">     delete aItem._deps;</span>
<a href="#l14.1633"></a><span id="l14.1633">   },</span>
<a href="#l14.1634"></a><span id="l14.1634"> </span>
<a href="#l14.1635"></a><span id="l14.1635">   /* ********** Contact ********** */</span>
<a href="#l14.1636"></a><span id="l14.1636">   _nextContactId: 1,</span>
<a href="#l14.1637"></a><span id="l14.1637"> </span>
<a href="#l14.1638"></a><span id="l14.1638">   _populateContactManagedId: function () {</span>
<a href="#l14.1639"></a><span id="l14.1639">     let stmt = this._createSyncStatement(&quot;SELECT MAX(id) FROM contacts&quot;, true);</span>
<a href="#l14.1640"></a><span id="l14.1640" class="difflineat">@@ -3130,17 +3179,17 @@ var GlodaDatastore = {</span>
<a href="#l14.1641"></a><span id="l14.1641">       aName, aPopularity, aFrecency) {</span>
<a href="#l14.1642"></a><span id="l14.1642">     let contactID = this._nextContactId++;</span>
<a href="#l14.1643"></a><span id="l14.1643">     this._log.debug(&quot;createContact: &quot; + contactID + &quot;: &quot; + aName);</span>
<a href="#l14.1644"></a><span id="l14.1644">     let contact = new GlodaContact(this, contactID,</span>
<a href="#l14.1645"></a><span id="l14.1645">                                    aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l14.1646"></a><span id="l14.1646">                                    aPopularity, aFrecency);</span>
<a href="#l14.1647"></a><span id="l14.1647">     return contact;</span>
<a href="#l14.1648"></a><span id="l14.1648">   },</span>
<a href="#l14.1649"></a><span id="l14.1649" class="difflineminus">-  </span>
<a href="#l14.1650"></a><span id="l14.1650" class="difflineplus">+</span>
<a href="#l14.1651"></a><span id="l14.1651">   insertContact: function gloda_ds_insertContact(aContact) {</span>
<a href="#l14.1652"></a><span id="l14.1652">     let ics = this._insertContactStatement;</span>
<a href="#l14.1653"></a><span id="l14.1653">     ics.bindInt64Parameter(0, aContact.id);</span>
<a href="#l14.1654"></a><span id="l14.1654">     if (aContact.directoryUUID == null)</span>
<a href="#l14.1655"></a><span id="l14.1655">       ics.bindNullParameter(1);</span>
<a href="#l14.1656"></a><span id="l14.1656">     else</span>
<a href="#l14.1657"></a><span id="l14.1657">       ics.bindStringParameter(1, aContact.directoryUUID);</span>
<a href="#l14.1658"></a><span id="l14.1658">     if (aContact.contactUUID == null)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1">new file mode 100644</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineminus">--- /dev/null</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/dbview.js</span>
<a href="#l15.4"></a><span id="l15.4" class="difflineat">@@ -0,0 +1,192 @@</span>
<a href="#l15.5"></a><span id="l15.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l15.6"></a><span id="l15.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l15.7"></a><span id="l15.7" class="difflineplus">+ *</span>
<a href="#l15.8"></a><span id="l15.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l15.9"></a><span id="l15.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l15.10"></a><span id="l15.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l15.11"></a><span id="l15.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineplus">+ *</span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l15.14"></a><span id="l15.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l15.15"></a><span id="l15.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l15.16"></a><span id="l15.16" class="difflineplus">+ * License.</span>
<a href="#l15.17"></a><span id="l15.17" class="difflineplus">+ *</span>
<a href="#l15.18"></a><span id="l15.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l15.19"></a><span id="l15.19" class="difflineplus">+ *</span>
<a href="#l15.20"></a><span id="l15.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l15.21"></a><span id="l15.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l15.22"></a><span id="l15.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l15.23"></a><span id="l15.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l15.24"></a><span id="l15.24" class="difflineplus">+ *</span>
<a href="#l15.25"></a><span id="l15.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l15.26"></a><span id="l15.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l15.27"></a><span id="l15.27" class="difflineplus">+ *</span>
<a href="#l15.28"></a><span id="l15.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l15.29"></a><span id="l15.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l15.30"></a><span id="l15.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l15.31"></a><span id="l15.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l15.32"></a><span id="l15.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l15.33"></a><span id="l15.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l15.34"></a><span id="l15.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l15.35"></a><span id="l15.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l15.36"></a><span id="l15.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l15.37"></a><span id="l15.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l15.38"></a><span id="l15.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l15.39"></a><span id="l15.39" class="difflineplus">+ *</span>
<a href="#l15.40"></a><span id="l15.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l15.41"></a><span id="l15.41" class="difflineplus">+</span>
<a href="#l15.42"></a><span id="l15.42" class="difflineplus">+/*</span>
<a href="#l15.43"></a><span id="l15.43" class="difflineplus">+ * This file is charged with providing you a way to have a pretty gloda-backed</span>
<a href="#l15.44"></a><span id="l15.44" class="difflineplus">+ *  nsIMsgDBView.</span>
<a href="#l15.45"></a><span id="l15.45" class="difflineplus">+ */</span>
<a href="#l15.46"></a><span id="l15.46" class="difflineplus">+</span>
<a href="#l15.47"></a><span id="l15.47" class="difflineplus">+EXPORTED_SYMBOLS = [&quot;GlodaSyntheticSearchView&quot;, &quot;GlodaViewFactory&quot;];</span>
<a href="#l15.48"></a><span id="l15.48" class="difflineplus">+</span>
<a href="#l15.49"></a><span id="l15.49" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l15.50"></a><span id="l15.50" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l15.51"></a><span id="l15.51" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l15.52"></a><span id="l15.52" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l15.53"></a><span id="l15.53" class="difflineplus">+</span>
<a href="#l15.54"></a><span id="l15.54" class="difflineplus">+Cu.import(&quot;resource://app/modules/gloda/log4moz.js&quot;);</span>
<a href="#l15.55"></a><span id="l15.55" class="difflineplus">+</span>
<a href="#l15.56"></a><span id="l15.56" class="difflineplus">+Cu.import(&quot;resource://app/modules/gloda/public.js&quot;);</span>
<a href="#l15.57"></a><span id="l15.57" class="difflineplus">+Cu.import(&quot;resource://app/modules/gloda/msg_search.js&quot;);</span>
<a href="#l15.58"></a><span id="l15.58" class="difflineplus">+</span>
<a href="#l15.59"></a><span id="l15.59" class="difflineplus">+function GlodaScoreColumn(aSearcher) {</span>
<a href="#l15.60"></a><span id="l15.60" class="difflineplus">+  this.searcher = aSearcher;</span>
<a href="#l15.61"></a><span id="l15.61" class="difflineplus">+}</span>
<a href="#l15.62"></a><span id="l15.62" class="difflineplus">+GlodaScoreColumn.prototype = {</span>
<a href="#l15.63"></a><span id="l15.63" class="difflineplus">+  id: &quot;glodaScoreCol&quot;,</span>
<a href="#l15.64"></a><span id="l15.64" class="difflineplus">+  bindToView: function (aDBView) {</span>
<a href="#l15.65"></a><span id="l15.65" class="difflineplus">+    this.dbView = aDBView;</span>
<a href="#l15.66"></a><span id="l15.66" class="difflineplus">+  },</span>
<a href="#l15.67"></a><span id="l15.67" class="difflineplus">+</span>
<a href="#l15.68"></a><span id="l15.68" class="difflineplus">+  getCellText: function(row, col) {</span>
<a href="#l15.69"></a><span id="l15.69" class="difflineplus">+    let folder = this.dbView.getFolderForViewIndex(row);</span>
<a href="#l15.70"></a><span id="l15.70" class="difflineplus">+    let key = this.dbView.getKeyAt(row);</span>
<a href="#l15.71"></a><span id="l15.71" class="difflineplus">+    return &quot;&quot; + this.searcher.scoresByUriAndKey[folder.URI + &quot;-&quot; + key];</span>
<a href="#l15.72"></a><span id="l15.72" class="difflineplus">+  },</span>
<a href="#l15.73"></a><span id="l15.73" class="difflineplus">+  getSortLongForRow:   function(hdr) {</span>
<a href="#l15.74"></a><span id="l15.74" class="difflineplus">+    return this.searcher.scoresByUriAndKey[</span>
<a href="#l15.75"></a><span id="l15.75" class="difflineplus">+      hdr.folder.URI + &quot;-&quot; + hdr.messageKey] || 0;</span>
<a href="#l15.76"></a><span id="l15.76" class="difflineplus">+  },</span>
<a href="#l15.77"></a><span id="l15.77" class="difflineplus">+  isString: function() {</span>
<a href="#l15.78"></a><span id="l15.78" class="difflineplus">+    return false;</span>
<a href="#l15.79"></a><span id="l15.79" class="difflineplus">+  },</span>
<a href="#l15.80"></a><span id="l15.80" class="difflineplus">+</span>
<a href="#l15.81"></a><span id="l15.81" class="difflineplus">+  getCellProperties:   function(row, col, props){},</span>
<a href="#l15.82"></a><span id="l15.82" class="difflineplus">+  getRowProperties:    function(row, props){},</span>
<a href="#l15.83"></a><span id="l15.83" class="difflineplus">+  getImageSrc:         function(row, col) {return null;},</span>
<a href="#l15.84"></a><span id="l15.84" class="difflineplus">+  getSortStringForRow: function(hdr) {</span>
<a href="#l15.85"></a><span id="l15.85" class="difflineplus">+    return null;</span>
<a href="#l15.86"></a><span id="l15.86" class="difflineplus">+  },</span>
<a href="#l15.87"></a><span id="l15.87" class="difflineplus">+};</span>
<a href="#l15.88"></a><span id="l15.88" class="difflineplus">+</span>
<a href="#l15.89"></a><span id="l15.89" class="difflineplus">+function GlodaWhyColumn(aSearcher) {</span>
<a href="#l15.90"></a><span id="l15.90" class="difflineplus">+  this.searcher = aSearcher;</span>
<a href="#l15.91"></a><span id="l15.91" class="difflineplus">+}</span>
<a href="#l15.92"></a><span id="l15.92" class="difflineplus">+GlodaWhyColumn.prototype = {</span>
<a href="#l15.93"></a><span id="l15.93" class="difflineplus">+  id: &quot;glodaWhyCol&quot;,</span>
<a href="#l15.94"></a><span id="l15.94" class="difflineplus">+  bindToView: function (aDBView) {</span>
<a href="#l15.95"></a><span id="l15.95" class="difflineplus">+    this.dbView = aDBView;</span>
<a href="#l15.96"></a><span id="l15.96" class="difflineplus">+  },</span>
<a href="#l15.97"></a><span id="l15.97" class="difflineplus">+</span>
<a href="#l15.98"></a><span id="l15.98" class="difflineplus">+  getCellText: function(row, col) {</span>
<a href="#l15.99"></a><span id="l15.99" class="difflineplus">+    let folder = this.dbView.getFolderForViewIndex(row);</span>
<a href="#l15.100"></a><span id="l15.100" class="difflineplus">+    let key = this.dbView.getKeyAt(row);</span>
<a href="#l15.101"></a><span id="l15.101" class="difflineplus">+    return this.searcher.whysByUriAndKey[folder.URI + &quot;-&quot; + key] || &quot;&quot;;</span>
<a href="#l15.102"></a><span id="l15.102" class="difflineplus">+  },</span>
<a href="#l15.103"></a><span id="l15.103" class="difflineplus">+  getSortStringForRow: function(hdr) {</span>
<a href="#l15.104"></a><span id="l15.104" class="difflineplus">+    return this.searcher.whysByUriAndKey[hdr.folder.URI + &quot;-&quot; + hdr.messageKey]</span>
<a href="#l15.105"></a><span id="l15.105" class="difflineplus">+      || &quot;&quot;;</span>
<a href="#l15.106"></a><span id="l15.106" class="difflineplus">+  },</span>
<a href="#l15.107"></a><span id="l15.107" class="difflineplus">+  isString: function() {</span>
<a href="#l15.108"></a><span id="l15.108" class="difflineplus">+    return true;</span>
<a href="#l15.109"></a><span id="l15.109" class="difflineplus">+  },</span>
<a href="#l15.110"></a><span id="l15.110" class="difflineplus">+</span>
<a href="#l15.111"></a><span id="l15.111" class="difflineplus">+  getCellProperties:   function(row, col, props){},</span>
<a href="#l15.112"></a><span id="l15.112" class="difflineplus">+  getRowProperties:    function(row, props){},</span>
<a href="#l15.113"></a><span id="l15.113" class="difflineplus">+  getImageSrc:         function(row, col) {return null;},</span>
<a href="#l15.114"></a><span id="l15.114" class="difflineplus">+  getSortLongForRow:   function(hdr) {return 0;}</span>
<a href="#l15.115"></a><span id="l15.115" class="difflineplus">+};</span>
<a href="#l15.116"></a><span id="l15.116" class="difflineplus">+</span>
<a href="#l15.117"></a><span id="l15.117" class="difflineplus">+function GlodaSyntheticSearchView(aSearchString, aFacetString, aLocation) {</span>
<a href="#l15.118"></a><span id="l15.118" class="difflineplus">+  this.searcher = new GlodaMsgSearcher(this, aSearchString.split(&quot; &quot;));</span>
<a href="#l15.119"></a><span id="l15.119" class="difflineplus">+</span>
<a href="#l15.120"></a><span id="l15.120" class="difflineplus">+  this._whyColumn = new GlodaWhyColumn(this.searcher);</span>
<a href="#l15.121"></a><span id="l15.121" class="difflineplus">+  this._scoreColumn = new GlodaScoreColumn(this.searcher);</span>
<a href="#l15.122"></a><span id="l15.122" class="difflineplus">+</span>
<a href="#l15.123"></a><span id="l15.123" class="difflineplus">+  this.customColumns = [this._whyColumn, this._scoreColumn];</span>
<a href="#l15.124"></a><span id="l15.124" class="difflineplus">+</span>
<a href="#l15.125"></a><span id="l15.125" class="difflineplus">+  this.collection = null;</span>
<a href="#l15.126"></a><span id="l15.126" class="difflineplus">+  this._whyMap = {};</span>
<a href="#l15.127"></a><span id="l15.127" class="difflineplus">+  this._scoreMap = {};</span>
<a href="#l15.128"></a><span id="l15.128" class="difflineplus">+</span>
<a href="#l15.129"></a><span id="l15.129" class="difflineplus">+  this.searchString = aSearchString;</span>
<a href="#l15.130"></a><span id="l15.130" class="difflineplus">+  this.facetString = aFacetString;</span>
<a href="#l15.131"></a><span id="l15.131" class="difflineplus">+  this.location = aLocation;</span>
<a href="#l15.132"></a><span id="l15.132" class="difflineplus">+}</span>
<a href="#l15.133"></a><span id="l15.133" class="difflineplus">+GlodaSyntheticSearchView.prototype = {</span>
<a href="#l15.134"></a><span id="l15.134" class="difflineplus">+  defaultSort: [[&quot;glodaScoreCol&quot;, Ci.nsMsgViewSortOrder.descending]],</span>
<a href="#l15.135"></a><span id="l15.135" class="difflineplus">+</span>
<a href="#l15.136"></a><span id="l15.136" class="difflineplus">+  /**</span>
<a href="#l15.137"></a><span id="l15.137" class="difflineplus">+   * Request the search be performed and notification provided to</span>
<a href="#l15.138"></a><span id="l15.138" class="difflineplus">+   *  aSearchListener.  If results are already available, they should</span>
<a href="#l15.139"></a><span id="l15.139" class="difflineplus">+   *  be provided to aSearchListener without re-performing the search.</span>
<a href="#l15.140"></a><span id="l15.140" class="difflineplus">+   */</span>
<a href="#l15.141"></a><span id="l15.141" class="difflineplus">+  search: function(aSearchListener, aCompletionCallback) {</span>
<a href="#l15.142"></a><span id="l15.142" class="difflineplus">+    this.searchListener = aSearchListener;</span>
<a href="#l15.143"></a><span id="l15.143" class="difflineplus">+    this.completionCallback = aCompletionCallback;</span>
<a href="#l15.144"></a><span id="l15.144" class="difflineplus">+</span>
<a href="#l15.145"></a><span id="l15.145" class="difflineplus">+    this.searchListener.onNewSearch();</span>
<a href="#l15.146"></a><span id="l15.146" class="difflineplus">+    if (this.collection) {</span>
<a href="#l15.147"></a><span id="l15.147" class="difflineplus">+      this.reportResults(this.collection.items);</span>
<a href="#l15.148"></a><span id="l15.148" class="difflineplus">+      // we're not really aborting, but it closes things out nicely</span>
<a href="#l15.149"></a><span id="l15.149" class="difflineplus">+      this.abortSearch();</span>
<a href="#l15.150"></a><span id="l15.150" class="difflineplus">+      return;</span>
<a href="#l15.151"></a><span id="l15.151" class="difflineplus">+    }</span>
<a href="#l15.152"></a><span id="l15.152" class="difflineplus">+</span>
<a href="#l15.153"></a><span id="l15.153" class="difflineplus">+    this.collection = this.searcher.go();</span>
<a href="#l15.154"></a><span id="l15.154" class="difflineplus">+  },</span>
<a href="#l15.155"></a><span id="l15.155" class="difflineplus">+</span>
<a href="#l15.156"></a><span id="l15.156" class="difflineplus">+  abortSearch: function() {</span>
<a href="#l15.157"></a><span id="l15.157" class="difflineplus">+    if (this.searchListener)</span>
<a href="#l15.158"></a><span id="l15.158" class="difflineplus">+      this.searchListener.onSearchDone(Cr.NS_OK);</span>
<a href="#l15.159"></a><span id="l15.159" class="difflineplus">+    if (this.completionCallback)</span>
<a href="#l15.160"></a><span id="l15.160" class="difflineplus">+      this.completionCallback();</span>
<a href="#l15.161"></a><span id="l15.161" class="difflineplus">+    this.searchListener = null;</span>
<a href="#l15.162"></a><span id="l15.162" class="difflineplus">+    this.completionCallback = null;</span>
<a href="#l15.163"></a><span id="l15.163" class="difflineplus">+  },</span>
<a href="#l15.164"></a><span id="l15.164" class="difflineplus">+</span>
<a href="#l15.165"></a><span id="l15.165" class="difflineplus">+  reportResults: function(aItems) {</span>
<a href="#l15.166"></a><span id="l15.166" class="difflineplus">+    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l15.167"></a><span id="l15.167" class="difflineplus">+      let hdr = item.folderMessage;</span>
<a href="#l15.168"></a><span id="l15.168" class="difflineplus">+      this.searchListener.onSearchHit(hdr, hdr.folder);</span>
<a href="#l15.169"></a><span id="l15.169" class="difflineplus">+    }</span>
<a href="#l15.170"></a><span id="l15.170" class="difflineplus">+  },</span>
<a href="#l15.171"></a><span id="l15.171" class="difflineplus">+</span>
<a href="#l15.172"></a><span id="l15.172" class="difflineplus">+  // --- collection listener</span>
<a href="#l15.173"></a><span id="l15.173" class="difflineplus">+  onItemsAdded: function(aItems, aCollection) {</span>
<a href="#l15.174"></a><span id="l15.174" class="difflineplus">+    if (this.searchListener)</span>
<a href="#l15.175"></a><span id="l15.175" class="difflineplus">+      this.reportResults(aItems);</span>
<a href="#l15.176"></a><span id="l15.176" class="difflineplus">+  },</span>
<a href="#l15.177"></a><span id="l15.177" class="difflineplus">+  onItemsModified: function(aItems, aCollection) {</span>
<a href="#l15.178"></a><span id="l15.178" class="difflineplus">+  },</span>
<a href="#l15.179"></a><span id="l15.179" class="difflineplus">+  onItemsRemoved: function(aItems, aCollection) {</span>
<a href="#l15.180"></a><span id="l15.180" class="difflineplus">+  },</span>
<a href="#l15.181"></a><span id="l15.181" class="difflineplus">+  onQueryCompleted: function(aCollection) {</span>
<a href="#l15.182"></a><span id="l15.182" class="difflineplus">+    this.searchListener.onSearchDone(Cr.NS_OK);</span>
<a href="#l15.183"></a><span id="l15.183" class="difflineplus">+    if (this.completionCallback)</span>
<a href="#l15.184"></a><span id="l15.184" class="difflineplus">+      this.completionCallback();</span>
<a href="#l15.185"></a><span id="l15.185" class="difflineplus">+  },</span>
<a href="#l15.186"></a><span id="l15.186" class="difflineplus">+};</span>
<a href="#l15.187"></a><span id="l15.187" class="difflineplus">+</span>
<a href="#l15.188"></a><span id="l15.188" class="difflineplus">+var GlodaViewFactory = {</span>
<a href="#l15.189"></a><span id="l15.189" class="difflineplus">+  kFacetEverything: &quot;everything&quot;,</span>
<a href="#l15.190"></a><span id="l15.190" class="difflineplus">+  kFacetSubject: &quot;subject&quot;,</span>
<a href="#l15.191"></a><span id="l15.191" class="difflineplus">+  kFacetBody: &quot;body&quot;,</span>
<a href="#l15.192"></a><span id="l15.192" class="difflineplus">+  kFacetAttachments: &quot;attachments&quot;,</span>
<a href="#l15.193"></a><span id="l15.193" class="difflineplus">+  kFacetInvolves: &quot;involves&quot;,</span>
<a href="#l15.194"></a><span id="l15.194" class="difflineplus">+  kFacetTo: &quot;to&quot;,</span>
<a href="#l15.195"></a><span id="l15.195" class="difflineplus">+  kFacetFrom: &quot;from&quot;,</span>
<a href="#l15.196"></a><span id="l15.196" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/mailnews/db/gloda/modules/explattr.js</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/explattr.js</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -1,16 +1,16 @@</span>
<a href="#l16.4"></a><span id="l16.4"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l16.5"></a><span id="l16.5">  *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l16.6"></a><span id="l16.6">  *</span>
<a href="#l16.7"></a><span id="l16.7">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l16.8"></a><span id="l16.8">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l16.9"></a><span id="l16.9">  * the License. You may obtain a copy of the License at</span>
<a href="#l16.10"></a><span id="l16.10">  * http://www.mozilla.org/MPL/</span>
<a href="#l16.11"></a><span id="l16.11" class="difflineminus">- * </span>
<a href="#l16.12"></a><span id="l16.12" class="difflineplus">+ *</span>
<a href="#l16.13"></a><span id="l16.13">  * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l16.14"></a><span id="l16.14">  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l16.15"></a><span id="l16.15">  * for the specific language governing rights and limitations under the</span>
<a href="#l16.16"></a><span id="l16.16">  * License.</span>
<a href="#l16.17"></a><span id="l16.17">  *</span>
<a href="#l16.18"></a><span id="l16.18">  * The Original Code is Thunderbird Global Database.</span>
<a href="#l16.19"></a><span id="l16.19">  *</span>
<a href="#l16.20"></a><span id="l16.20">  * The Initial Developer of the Original Code is</span>
<a href="#l16.21"></a><span id="l16.21" class="difflineat">@@ -27,17 +27,17 @@</span>
<a href="#l16.22"></a><span id="l16.22">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l16.23"></a><span id="l16.23">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l16.24"></a><span id="l16.24">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l16.25"></a><span id="l16.25">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l16.26"></a><span id="l16.26">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l16.27"></a><span id="l16.27">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l16.28"></a><span id="l16.28">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l16.29"></a><span id="l16.29">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l16.30"></a><span id="l16.30" class="difflineminus">- * </span>
<a href="#l16.31"></a><span id="l16.31" class="difflineplus">+ *</span>
<a href="#l16.32"></a><span id="l16.32">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l16.33"></a><span id="l16.33"> </span>
<a href="#l16.34"></a><span id="l16.34"> /*</span>
<a href="#l16.35"></a><span id="l16.35">  * This file provides the &quot;explicit attribute&quot; provider for messages.  It is</span>
<a href="#l16.36"></a><span id="l16.36">  *  concerned with attributes that are the result of user actions.  For example,</span>
<a href="#l16.37"></a><span id="l16.37">  *  whether a message is starred (flagged), message tags, whether it is</span>
<a href="#l16.38"></a><span id="l16.38">  *  read/unread, etc.</span>
<a href="#l16.39"></a><span id="l16.39">  */</span>
<a href="#l16.40"></a><span id="l16.40" class="difflineat">@@ -59,42 +59,49 @@ Cu.import(&quot;resource://app/modules/gloda/</span>
<a href="#l16.41"></a><span id="l16.41"> const EXT_BUILTIN = &quot;built-in&quot;;</span>
<a href="#l16.42"></a><span id="l16.42"> const FA_TAG = &quot;TAG&quot;;</span>
<a href="#l16.43"></a><span id="l16.43"> const FA_STAR = &quot;STAR&quot;;</span>
<a href="#l16.44"></a><span id="l16.44"> const FA_READ = &quot;READ&quot;;</span>
<a href="#l16.45"></a><span id="l16.45"> </span>
<a href="#l16.46"></a><span id="l16.46"> /**</span>
<a href="#l16.47"></a><span id="l16.47">  * @namespace Explicit attribute provider.  Indexes/defines attributes that are</span>
<a href="#l16.48"></a><span id="l16.48">  *  explicitly a result of user action.  This dubiously includes marking a</span>
<a href="#l16.49"></a><span id="l16.49" class="difflineminus">- *  message as read. </span>
<a href="#l16.50"></a><span id="l16.50" class="difflineplus">+ *  message as read.</span>
<a href="#l16.51"></a><span id="l16.51">  */</span>
<a href="#l16.52"></a><span id="l16.52"> var GlodaExplicitAttr = {</span>
<a href="#l16.53"></a><span id="l16.53">   providerName: &quot;gloda.explattr&quot;,</span>
<a href="#l16.54"></a><span id="l16.54">   _log: null,</span>
<a href="#l16.55"></a><span id="l16.55">   _msgTagService: null,</span>
<a href="#l16.56"></a><span id="l16.56"> </span>
<a href="#l16.57"></a><span id="l16.57">   init: function gloda_explattr_init() {</span>
<a href="#l16.58"></a><span id="l16.58">     this._log =  Log4Moz.repository.getLogger(&quot;gloda.explattr&quot;);</span>
<a href="#l16.59"></a><span id="l16.59"> </span>
<a href="#l16.60"></a><span id="l16.60">     this._msgTagService = Cc[&quot;@mozilla.org/messenger/tagservice;1&quot;].</span>
<a href="#l16.61"></a><span id="l16.61">                           getService(Ci.nsIMsgTagService);</span>
<a href="#l16.62"></a><span id="l16.62" class="difflineminus">-  </span>
<a href="#l16.63"></a><span id="l16.63" class="difflineplus">+</span>
<a href="#l16.64"></a><span id="l16.64">     try {</span>
<a href="#l16.65"></a><span id="l16.65">       this.defineAttributes();</span>
<a href="#l16.66"></a><span id="l16.66">     }</span>
<a href="#l16.67"></a><span id="l16.67">     catch (ex) {</span>
<a href="#l16.68"></a><span id="l16.68">       this._log.error(&quot;Error in init: &quot; + ex);</span>
<a href="#l16.69"></a><span id="l16.69">       throw ex;</span>
<a href="#l16.70"></a><span id="l16.70">     }</span>
<a href="#l16.71"></a><span id="l16.71">   },</span>
<a href="#l16.72"></a><span id="l16.72"> </span>
<a href="#l16.73"></a><span id="l16.73" class="difflineplus">+  /** Boost for starred messages. */</span>
<a href="#l16.74"></a><span id="l16.74" class="difflineplus">+  NOTABILITY_STARRED: 16,</span>
<a href="#l16.75"></a><span id="l16.75" class="difflineplus">+  /** Boost for tagged messages, first tag. */</span>
<a href="#l16.76"></a><span id="l16.76" class="difflineplus">+  NOTABILITY_TAGGED_FIRST: 8,</span>
<a href="#l16.77"></a><span id="l16.77" class="difflineplus">+  /** Boost for tagged messages, each additional tag. */</span>
<a href="#l16.78"></a><span id="l16.78" class="difflineplus">+  NOTABILITY_TAGGED_ADDL: 1,</span>
<a href="#l16.79"></a><span id="l16.79" class="difflineplus">+</span>
<a href="#l16.80"></a><span id="l16.80">   _attrTag: null,</span>
<a href="#l16.81"></a><span id="l16.81">   _attrStar: null,</span>
<a href="#l16.82"></a><span id="l16.82">   _attrRead: null,</span>
<a href="#l16.83"></a><span id="l16.83" class="difflineminus">-  </span>
<a href="#l16.84"></a><span id="l16.84" class="difflineplus">+</span>
<a href="#l16.85"></a><span id="l16.85">   defineAttributes: function() {</span>
<a href="#l16.86"></a><span id="l16.86">     // Tag</span>
<a href="#l16.87"></a><span id="l16.87">     this._attrTag = Gloda.defineAttribute({</span>
<a href="#l16.88"></a><span id="l16.88">                         provider: this,</span>
<a href="#l16.89"></a><span id="l16.89">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l16.90"></a><span id="l16.90">                         attributeType: Gloda.kAttrExplicit,</span>
<a href="#l16.91"></a><span id="l16.91">                         attributeName: &quot;tag&quot;,</span>
<a href="#l16.92"></a><span id="l16.92">                         bindName: &quot;tags&quot;,</span>
<a href="#l16.93"></a><span id="l16.93" class="difflineat">@@ -124,40 +131,62 @@ var GlodaExplicitAttr = {</span>
<a href="#l16.94"></a><span id="l16.94">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l16.95"></a><span id="l16.95">                         attributeType: Gloda.kAttrExplicit,</span>
<a href="#l16.96"></a><span id="l16.96">                         attributeName: &quot;read&quot;,</span>
<a href="#l16.97"></a><span id="l16.97">                         singular: true,</span>
<a href="#l16.98"></a><span id="l16.98">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l16.99"></a><span id="l16.99">                         objectNoun: Gloda.NOUN_BOOLEAN,</span>
<a href="#l16.100"></a><span id="l16.100">                         parameterNoun: null,</span>
<a href="#l16.101"></a><span id="l16.101">                         }); // tested-by: test_attributes_explicit</span>
<a href="#l16.102"></a><span id="l16.102" class="difflineminus">-    </span>
<a href="#l16.103"></a><span id="l16.103" class="difflineplus">+</span>
<a href="#l16.104"></a><span id="l16.104">   },</span>
<a href="#l16.105"></a><span id="l16.105" class="difflineminus">-  </span>
<a href="#l16.106"></a><span id="l16.106" class="difflineplus">+</span>
<a href="#l16.107"></a><span id="l16.107">   process: function Gloda_explattr_process(aGlodaMessage, aRawReps, aIsNew,</span>
<a href="#l16.108"></a><span id="l16.108">                                            aCallbackHandle) {</span>
<a href="#l16.109"></a><span id="l16.109">     let aMsgHdr = aRawReps.header;</span>
<a href="#l16.110"></a><span id="l16.110" class="difflineminus">-    </span>
<a href="#l16.111"></a><span id="l16.111" class="difflineplus">+</span>
<a href="#l16.112"></a><span id="l16.112">     aGlodaMessage.starred = aMsgHdr.isFlagged;</span>
<a href="#l16.113"></a><span id="l16.113" class="difflineplus">+    if (aGlodaMessage.starred)</span>
<a href="#l16.114"></a><span id="l16.114" class="difflineplus">+      aGlodaMessage.notability += this.NOTABILITY_STARRED;</span>
<a href="#l16.115"></a><span id="l16.115" class="difflineplus">+</span>
<a href="#l16.116"></a><span id="l16.116">     aGlodaMessage.read = aMsgHdr.isRead;</span>
<a href="#l16.117"></a><span id="l16.117" class="difflineminus">-    </span>
<a href="#l16.118"></a><span id="l16.118" class="difflineplus">+</span>
<a href="#l16.119"></a><span id="l16.119">     let tags = aGlodaMessage.tags = [];</span>
<a href="#l16.120"></a><span id="l16.120" class="difflineminus">-    </span>
<a href="#l16.121"></a><span id="l16.121" class="difflineplus">+</span>
<a href="#l16.122"></a><span id="l16.122">     // -- Tag</span>
<a href="#l16.123"></a><span id="l16.123">     // build a map of the keywords</span>
<a href="#l16.124"></a><span id="l16.124">     let keywords = aMsgHdr.getStringProperty(&quot;keywords&quot;);</span>
<a href="#l16.125"></a><span id="l16.125">     let keywordList = keywords.split(' ');</span>
<a href="#l16.126"></a><span id="l16.126">     let keywordMap = {};</span>
<a href="#l16.127"></a><span id="l16.127">     for (let iKeyword = 0; iKeyword &lt; keywordList.length; iKeyword++) {</span>
<a href="#l16.128"></a><span id="l16.128">       let keyword = keywordList[iKeyword];</span>
<a href="#l16.129"></a><span id="l16.129">       keywordMap[keyword] = true;</span>
<a href="#l16.130"></a><span id="l16.130">     }</span>
<a href="#l16.131"></a><span id="l16.131"> </span>
<a href="#l16.132"></a><span id="l16.132">     let tagArray = this._msgTagService.getAllTags({});</span>
<a href="#l16.133"></a><span id="l16.133">     for (let iTag = 0; iTag &lt; tagArray.length; iTag++) {</span>
<a href="#l16.134"></a><span id="l16.134">       let tag = tagArray[iTag];</span>
<a href="#l16.135"></a><span id="l16.135">       if (tag.key in keywordMap)</span>
<a href="#l16.136"></a><span id="l16.136">         tags.push(tag);</span>
<a href="#l16.137"></a><span id="l16.137">     }</span>
<a href="#l16.138"></a><span id="l16.138" class="difflineminus">-    </span>
<a href="#l16.139"></a><span id="l16.139" class="difflineplus">+</span>
<a href="#l16.140"></a><span id="l16.140" class="difflineplus">+    if (tags.length)</span>
<a href="#l16.141"></a><span id="l16.141" class="difflineplus">+      aGlodaMessage.notability += this.NOTABILITY_TAGGED_FIRST +</span>
<a href="#l16.142"></a><span id="l16.142" class="difflineplus">+        (tags.length - 1) * this.NOTABILITY_TAGGED_ADDL;</span>
<a href="#l16.143"></a><span id="l16.143" class="difflineplus">+</span>
<a href="#l16.144"></a><span id="l16.144">     yield Gloda.kWorkDone;</span>
<a href="#l16.145"></a><span id="l16.145">   },</span>
<a href="#l16.146"></a><span id="l16.146" class="difflineplus">+</span>
<a href="#l16.147"></a><span id="l16.147" class="difflineplus">+  /**</span>
<a href="#l16.148"></a><span id="l16.148" class="difflineplus">+   * Duplicates the notability logic from process().  Arguably process should</span>
<a href="#l16.149"></a><span id="l16.149" class="difflineplus">+   *  be factored to call us, grokNounItem should be factored to call us, or we</span>
<a href="#l16.150"></a><span id="l16.150" class="difflineplus">+   *  should get sufficiently fancy that our code wildly diverges.</span>
<a href="#l16.151"></a><span id="l16.151" class="difflineplus">+   */</span>
<a href="#l16.152"></a><span id="l16.152" class="difflineplus">+  score: function Gloda_explattr_score(aMessage, aContext) {</span>
<a href="#l16.153"></a><span id="l16.153" class="difflineplus">+    let score = 0;</span>
<a href="#l16.154"></a><span id="l16.154" class="difflineplus">+    if (aMessage.starred)</span>
<a href="#l16.155"></a><span id="l16.155" class="difflineplus">+      score += this.NOTABILITY_STARRED;</span>
<a href="#l16.156"></a><span id="l16.156" class="difflineplus">+    if (aMessage.tags.length)</span>
<a href="#l16.157"></a><span id="l16.157" class="difflineplus">+      score += this.NOTABILITY_TAGGED_FIRST +</span>
<a href="#l16.158"></a><span id="l16.158" class="difflineplus">+        (aMessage.tags.length - 1) * this.NOTABILITY_TAGGED_ADDL;</span>
<a href="#l16.159"></a><span id="l16.159" class="difflineplus">+    return score;</span>
<a href="#l16.160"></a><span id="l16.160" class="difflineplus">+  },</span>
<a href="#l16.161"></a><span id="l16.161"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/mailnews/db/gloda/modules/fundattr.js</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/fundattr.js</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -74,16 +74,27 @@ var GlodaFundAttr = {</span>
<a href="#l17.4"></a><span id="l17.4">     }</span>
<a href="#l17.5"></a><span id="l17.5">   },</span>
<a href="#l17.6"></a><span id="l17.6"> </span>
<a href="#l17.7"></a><span id="l17.7">   POPULARITY_FROM_ME_TO: 10,</span>
<a href="#l17.8"></a><span id="l17.8">   POPULARITY_FROM_ME_CC: 4,</span>
<a href="#l17.9"></a><span id="l17.9">   POPULARITY_TO_ME: 5,</span>
<a href="#l17.10"></a><span id="l17.10">   POPULARITY_CC_ME: 1,</span>
<a href="#l17.11"></a><span id="l17.11"> </span>
<a href="#l17.12"></a><span id="l17.12" class="difflineplus">+  /** Boost for messages 'I' sent */</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+  NOTABILITY_FROM_ME: 10,</span>
<a href="#l17.14"></a><span id="l17.14" class="difflineplus">+  /** Boost for messages involving 'me'. */</span>
<a href="#l17.15"></a><span id="l17.15" class="difflineplus">+  NOTABILITY_INVOLVING_ME: 1,</span>
<a href="#l17.16"></a><span id="l17.16" class="difflineplus">+  /** Boost for message from someone in 'my' address book. */</span>
<a href="#l17.17"></a><span id="l17.17" class="difflineplus">+  NOTABILITY_FROM_IN_ADDR_BOOK: 10,</span>
<a href="#l17.18"></a><span id="l17.18" class="difflineplus">+  /** Boost for the first person involved in my address book. */</span>
<a href="#l17.19"></a><span id="l17.19" class="difflineplus">+  NOTABILITY_INVOLVING_ADDR_BOOK_FIRST: 8,</span>
<a href="#l17.20"></a><span id="l17.20" class="difflineplus">+  /** Boost for each additional person involved in my address book. */</span>
<a href="#l17.21"></a><span id="l17.21" class="difflineplus">+  NOTABILITY_INVOLVING_ADDR_BOOK_ADDL: 2,</span>
<a href="#l17.22"></a><span id="l17.22" class="difflineplus">+</span>
<a href="#l17.23"></a><span id="l17.23">   _attrConvSubject: null,</span>
<a href="#l17.24"></a><span id="l17.24">   _attrFolder: null,</span>
<a href="#l17.25"></a><span id="l17.25">   _attrBody: null,</span>
<a href="#l17.26"></a><span id="l17.26">   _attrFrom: null,</span>
<a href="#l17.27"></a><span id="l17.27">   _attrFromMe: null,</span>
<a href="#l17.28"></a><span id="l17.28">   _attrTo: null,</span>
<a href="#l17.29"></a><span id="l17.29">   _attrToMe: null,</span>
<a href="#l17.30"></a><span id="l17.30">   _attrCc: null,</span>
<a href="#l17.31"></a><span id="l17.31" class="difflineat">@@ -127,69 +138,100 @@ var GlodaFundAttr = {</span>
<a href="#l17.32"></a><span id="l17.32">       special: Gloda.kSpecialColumn,</span>
<a href="#l17.33"></a><span id="l17.33">       specialColumnName: &quot;messageKey&quot;,</span>
<a href="#l17.34"></a><span id="l17.34">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l17.35"></a><span id="l17.35">       objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l17.36"></a><span id="l17.36">       }); // tested-by: test_attributes_fundamental</span>
<a href="#l17.37"></a><span id="l17.37"> </span>
<a href="#l17.38"></a><span id="l17.38">     // -- fulltext search helpers</span>
<a href="#l17.39"></a><span id="l17.39">     // fulltextMatches.  Match over message subject, body, and attachments</span>
<a href="#l17.40"></a><span id="l17.40" class="difflineplus">+    // @testpoint gloda.noun.message.attr.fulltextMatches</span>
<a href="#l17.41"></a><span id="l17.41">     this._attrFulltext = Gloda.defineAttribute({</span>
<a href="#l17.42"></a><span id="l17.42">       provider: this,</span>
<a href="#l17.43"></a><span id="l17.43">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l17.44"></a><span id="l17.44">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l17.45"></a><span id="l17.45">       attributeName: &quot;fulltextMatches&quot;,</span>
<a href="#l17.46"></a><span id="l17.46">       singular: true,</span>
<a href="#l17.47"></a><span id="l17.47">       special: Gloda.kSpecialFulltext,</span>
<a href="#l17.48"></a><span id="l17.48">       specialColumnName: &quot;messagesText&quot;,</span>
<a href="#l17.49"></a><span id="l17.49">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l17.50"></a><span id="l17.50">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l17.51"></a><span id="l17.51" class="difflineminus">-      }); // not-tested</span>
<a href="#l17.52"></a><span id="l17.52" class="difflineplus">+      });</span>
<a href="#l17.53"></a><span id="l17.53"> </span>
<a href="#l17.54"></a><span id="l17.54">     // subjectMatches.  Fulltext match on subject</span>
<a href="#l17.55"></a><span id="l17.55" class="difflineplus">+    // @testpoint gloda.noun.message.attr.subjectMatches</span>
<a href="#l17.56"></a><span id="l17.56">     this._attrSubjectText = Gloda.defineAttribute({</span>
<a href="#l17.57"></a><span id="l17.57">       provider: this,</span>
<a href="#l17.58"></a><span id="l17.58">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l17.59"></a><span id="l17.59">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l17.60"></a><span id="l17.60">       attributeName: &quot;subjectMatches&quot;,</span>
<a href="#l17.61"></a><span id="l17.61">       singular: true,</span>
<a href="#l17.62"></a><span id="l17.62">       special: Gloda.kSpecialFulltext,</span>
<a href="#l17.63"></a><span id="l17.63">       specialColumnName: &quot;subject&quot;,</span>
<a href="#l17.64"></a><span id="l17.64">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l17.65"></a><span id="l17.65">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l17.66"></a><span id="l17.66" class="difflineminus">-      }); // not-tested</span>
<a href="#l17.67"></a><span id="l17.67" class="difflineplus">+      });</span>
<a href="#l17.68"></a><span id="l17.68"> </span>
<a href="#l17.69"></a><span id="l17.69">     // bodyMatches. super-synthetic full-text matching...</span>
<a href="#l17.70"></a><span id="l17.70" class="difflineplus">+    // @testpoint gloda.noun.message.attr.bodyMatches</span>
<a href="#l17.71"></a><span id="l17.71">     this._attrBody = Gloda.defineAttribute({</span>
<a href="#l17.72"></a><span id="l17.72">       provider: this,</span>
<a href="#l17.73"></a><span id="l17.73">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l17.74"></a><span id="l17.74">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l17.75"></a><span id="l17.75">       attributeName: &quot;bodyMatches&quot;,</span>
<a href="#l17.76"></a><span id="l17.76">       singular: true,</span>
<a href="#l17.77"></a><span id="l17.77">       special: Gloda.kSpecialFulltext,</span>
<a href="#l17.78"></a><span id="l17.78">       specialColumnName: &quot;body&quot;,</span>
<a href="#l17.79"></a><span id="l17.79">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l17.80"></a><span id="l17.80">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l17.81"></a><span id="l17.81" class="difflineminus">-      }); // not-tested</span>
<a href="#l17.82"></a><span id="l17.82" class="difflineplus">+      });</span>
<a href="#l17.83"></a><span id="l17.83"> </span>
<a href="#l17.84"></a><span id="l17.84">     // attachmentNamesMatch</span>
<a href="#l17.85"></a><span id="l17.85" class="difflineplus">+    // @testpoint gloda.noun.message.attr.attachmentNamesMatch</span>
<a href="#l17.86"></a><span id="l17.86">     this._attrAttachmentNames = Gloda.defineAttribute({</span>
<a href="#l17.87"></a><span id="l17.87">       provider: this,</span>
<a href="#l17.88"></a><span id="l17.88">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l17.89"></a><span id="l17.89">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l17.90"></a><span id="l17.90">       attributeName: &quot;attachmentNamesMatch&quot;,</span>
<a href="#l17.91"></a><span id="l17.91">       singular: true,</span>
<a href="#l17.92"></a><span id="l17.92">       special: Gloda.kSpecialFulltext,</span>
<a href="#l17.93"></a><span id="l17.93">       specialColumnName: &quot;attachmentNames&quot;,</span>
<a href="#l17.94"></a><span id="l17.94">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l17.95"></a><span id="l17.95">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l17.96"></a><span id="l17.96" class="difflineminus">-      }); // not-tested</span>
<a href="#l17.97"></a><span id="l17.97" class="difflineplus">+      });</span>
<a href="#l17.98"></a><span id="l17.98" class="difflineplus">+</span>
<a href="#l17.99"></a><span id="l17.99" class="difflineplus">+    // @testpoint gloda.noun.message.attr.authorMatches</span>
<a href="#l17.100"></a><span id="l17.100" class="difflineplus">+    this._attrAuthorFulltext = Gloda.defineAttribute({</span>
<a href="#l17.101"></a><span id="l17.101" class="difflineplus">+      provider: this,</span>
<a href="#l17.102"></a><span id="l17.102" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l17.103"></a><span id="l17.103" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l17.104"></a><span id="l17.104" class="difflineplus">+      attributeName: &quot;authorMatches&quot;,</span>
<a href="#l17.105"></a><span id="l17.105" class="difflineplus">+      singular: true,</span>
<a href="#l17.106"></a><span id="l17.106" class="difflineplus">+      special: Gloda.kSpecialFulltext,</span>
<a href="#l17.107"></a><span id="l17.107" class="difflineplus">+      specialColumnName: &quot;author&quot;,</span>
<a href="#l17.108"></a><span id="l17.108" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l17.109"></a><span id="l17.109" class="difflineplus">+      objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l17.110"></a><span id="l17.110" class="difflineplus">+      });</span>
<a href="#l17.111"></a><span id="l17.111" class="difflineplus">+</span>
<a href="#l17.112"></a><span id="l17.112" class="difflineplus">+    // @testpoint gloda.noun.message.attr.recipientsMatch</span>
<a href="#l17.113"></a><span id="l17.113" class="difflineplus">+    this._attrRecipientsFulltext = Gloda.defineAttribute({</span>
<a href="#l17.114"></a><span id="l17.114" class="difflineplus">+      provider: this,</span>
<a href="#l17.115"></a><span id="l17.115" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l17.116"></a><span id="l17.116" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l17.117"></a><span id="l17.117" class="difflineplus">+      attributeName: &quot;recipientsMatch&quot;,</span>
<a href="#l17.118"></a><span id="l17.118" class="difflineplus">+      singular: true,</span>
<a href="#l17.119"></a><span id="l17.119" class="difflineplus">+      special: Gloda.kSpecialFulltext,</span>
<a href="#l17.120"></a><span id="l17.120" class="difflineplus">+      specialColumnName: &quot;recipients&quot;,</span>
<a href="#l17.121"></a><span id="l17.121" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l17.122"></a><span id="l17.122" class="difflineplus">+      objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l17.123"></a><span id="l17.123" class="difflineplus">+      });</span>
<a href="#l17.124"></a><span id="l17.124"> </span>
<a href="#l17.125"></a><span id="l17.125">     // --- synthetic stuff for some reason</span>
<a href="#l17.126"></a><span id="l17.126">     // conversation</span>
<a href="#l17.127"></a><span id="l17.127" class="difflineplus">+    // @testpoint gloda.noun.message.attr.conversation</span>
<a href="#l17.128"></a><span id="l17.128">     this._attrConversation = Gloda.defineAttribute({</span>
<a href="#l17.129"></a><span id="l17.129">       provider: this,</span>
<a href="#l17.130"></a><span id="l17.130">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l17.131"></a><span id="l17.131">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l17.132"></a><span id="l17.132">       attributeName: &quot;conversation&quot;,</span>
<a href="#l17.133"></a><span id="l17.133">       singular: true,</span>
<a href="#l17.134"></a><span id="l17.134">       special: Gloda.kSpecialColumnParent,</span>
<a href="#l17.135"></a><span id="l17.135">       specialColumnName: &quot;conversationID&quot;,</span>
<a href="#l17.136"></a><span id="l17.136" class="difflineat">@@ -364,22 +406,22 @@ var GlodaFundAttr = {</span>
<a href="#l17.137"></a><span id="l17.137">     /*</span>
<a href="#l17.138"></a><span id="l17.138">     try {</span>
<a href="#l17.139"></a><span id="l17.139">       author = aMsgHdr.getStringProperty(&quot;replyTo&quot;);</span>
<a href="#l17.140"></a><span id="l17.140">     }</span>
<a href="#l17.141"></a><span id="l17.141">     catch (ex) {</span>
<a href="#l17.142"></a><span id="l17.142">     }</span>
<a href="#l17.143"></a><span id="l17.143">     */</span>
<a href="#l17.144"></a><span id="l17.144">     if (author == null || author == &quot;&quot;)</span>
<a href="#l17.145"></a><span id="l17.145" class="difflineminus">-      author = aMsgHdr.author;</span>
<a href="#l17.146"></a><span id="l17.146" class="difflineplus">+      author = aMsgHdr.mime2DecodedAuthor;</span>
<a href="#l17.147"></a><span id="l17.147"> </span>
<a href="#l17.148"></a><span id="l17.148">     let [authorIdentities, toIdentities, ccIdentities] =</span>
<a href="#l17.149"></a><span id="l17.149">       yield aCallbackHandle.pushAndGo(</span>
<a href="#l17.150"></a><span id="l17.150">         Gloda.getOrCreateMailIdentities(aCallbackHandle,</span>
<a href="#l17.151"></a><span id="l17.151" class="difflineminus">-                                        author, aMsgHdr.recipients,</span>
<a href="#l17.152"></a><span id="l17.152" class="difflineplus">+                                        author, aMsgHdr.mime2DecodedRecipients,</span>
<a href="#l17.153"></a><span id="l17.153">                                         aMsgHdr.ccList));</span>
<a href="#l17.154"></a><span id="l17.154"> </span>
<a href="#l17.155"></a><span id="l17.155">     if (authorIdentities.length == 0) {</span>
<a href="#l17.156"></a><span id="l17.156">       this._log.error(&quot;Message with subject '&quot; + aMsgHdr.mime2DecodedSubject +</span>
<a href="#l17.157"></a><span id="l17.157">                       &quot;' somehow lacks a valid author.  Bailing.&quot;);</span>
<a href="#l17.158"></a><span id="l17.158">       return; // being a generator, this generates an exception; we like.</span>
<a href="#l17.159"></a><span id="l17.159">     }</span>
<a href="#l17.160"></a><span id="l17.160">     let authorIdentity = authorIdentities[0];</span>
<a href="#l17.161"></a><span id="l17.161" class="difflineat">@@ -403,39 +445,68 @@ var GlodaFundAttr = {</span>
<a href="#l17.162"></a><span id="l17.162">     // TODO: deal with mailing lists, including implicit-to.  this will require</span>
<a href="#l17.163"></a><span id="l17.163">     //  convincing the indexer to pass us in the previous message if it is</span>
<a href="#l17.164"></a><span id="l17.164">     //  available.  (which we'll simply pass to everyone... it can help body</span>
<a href="#l17.165"></a><span id="l17.165">     //  logic for quoting purposes, etc. too.)</span>
<a href="#l17.166"></a><span id="l17.166"> </span>
<a href="#l17.167"></a><span id="l17.167">     yield Gloda.kWorkDone;</span>
<a href="#l17.168"></a><span id="l17.168">   },</span>
<a href="#l17.169"></a><span id="l17.169"> </span>
<a href="#l17.170"></a><span id="l17.170" class="difflineminus">-  optimize: function gloda_fundattr_process(aGlodaMessage, aRawReps,</span>
<a href="#l17.171"></a><span id="l17.171" class="difflineplus">+  optimize: function gloda_fundattr_optimize(aGlodaMessage, aRawReps,</span>
<a href="#l17.172"></a><span id="l17.172">       aIsNew, aCallbackHandle) {</span>
<a href="#l17.173"></a><span id="l17.173"> </span>
<a href="#l17.174"></a><span id="l17.174" class="difflineplus">+    let aMsgHdr = aRawReps.header;</span>
<a href="#l17.175"></a><span id="l17.175" class="difflineplus">+</span>
<a href="#l17.176"></a><span id="l17.176">     let involvesIdentities = {};</span>
<a href="#l17.177"></a><span id="l17.177">     let involves = aGlodaMessage.involves || [];</span>
<a href="#l17.178"></a><span id="l17.178"> </span>
<a href="#l17.179"></a><span id="l17.179">     // me specialization optimizations</span>
<a href="#l17.180"></a><span id="l17.180">     let toMe = aGlodaMessage.toMe || [];</span>
<a href="#l17.181"></a><span id="l17.181">     let fromMeTo = aGlodaMessage.fromMeTo || [];</span>
<a href="#l17.182"></a><span id="l17.182">     let ccMe = aGlodaMessage.ccMe || [];</span>
<a href="#l17.183"></a><span id="l17.183">     let fromMeCc = aGlodaMessage.fromMeCc || [];</span>
<a href="#l17.184"></a><span id="l17.184"> </span>
<a href="#l17.185"></a><span id="l17.185">     let myIdentities = Gloda.myIdentities; // needless optimization?</span>
<a href="#l17.186"></a><span id="l17.186">     let authorIdentity = aGlodaMessage.from;</span>
<a href="#l17.187"></a><span id="l17.187">     let isFromMe = authorIdentity.id in myIdentities;</span>
<a href="#l17.188"></a><span id="l17.188"> </span>
<a href="#l17.189"></a><span id="l17.189" class="difflineplus">+    // The fulltext search column for the author.  We want to have in here:</span>
<a href="#l17.190"></a><span id="l17.190" class="difflineplus">+    // - The e-mail address and display name as enclosed on the message.</span>
<a href="#l17.191"></a><span id="l17.191" class="difflineplus">+    // - The name per the address book card for this e-mail address, if we have</span>
<a href="#l17.192"></a><span id="l17.192" class="difflineplus">+    //   one.</span>
<a href="#l17.193"></a><span id="l17.193" class="difflineplus">+    aGlodaMessage._indexAuthor = aMsgHdr.mime2DecodedAuthor;</span>
<a href="#l17.194"></a><span id="l17.194" class="difflineplus">+    // The fulltext search column for the recipients. (same deal)</span>
<a href="#l17.195"></a><span id="l17.195" class="difflineplus">+    aGlodaMessage._indexRecipients = aMsgHdr.mime2DecodedRecipients;</span>
<a href="#l17.196"></a><span id="l17.196" class="difflineplus">+</span>
<a href="#l17.197"></a><span id="l17.197" class="difflineplus">+    if (isFromMe)</span>
<a href="#l17.198"></a><span id="l17.198" class="difflineplus">+      aGlodaMessage.notability += this.NOTABILITY_FROM_ME;</span>
<a href="#l17.199"></a><span id="l17.199" class="difflineplus">+    else {</span>
<a href="#l17.200"></a><span id="l17.200" class="difflineplus">+      let authorCard = authorIdentity.abCard;</span>
<a href="#l17.201"></a><span id="l17.201" class="difflineplus">+      if (authorCard) {</span>
<a href="#l17.202"></a><span id="l17.202" class="difflineplus">+        aGlodaMessage.notability += this.NOTABILITY_FROM_IN_ADDR_BOOK;</span>
<a href="#l17.203"></a><span id="l17.203" class="difflineplus">+        // @testpoint gloda.noun.message.attr.authorMatches</span>
<a href="#l17.204"></a><span id="l17.204" class="difflineplus">+        aGlodaMessage._indexAuthor += ' ' + authorCard.displayName;</span>
<a href="#l17.205"></a><span id="l17.205" class="difflineplus">+      }</span>
<a href="#l17.206"></a><span id="l17.206" class="difflineplus">+    }</span>
<a href="#l17.207"></a><span id="l17.207" class="difflineplus">+</span>
<a href="#l17.208"></a><span id="l17.208">     involves.push(authorIdentity);</span>
<a href="#l17.209"></a><span id="l17.209">     involvesIdentities[authorIdentity.id] = true;</span>
<a href="#l17.210"></a><span id="l17.210"> </span>
<a href="#l17.211"></a><span id="l17.211" class="difflineplus">+    let involvedAddrBookCount = 0;</span>
<a href="#l17.212"></a><span id="l17.212" class="difflineplus">+</span>
<a href="#l17.213"></a><span id="l17.213">     for each (let [,toIdentity] in Iterator(aGlodaMessage.to)) {</span>
<a href="#l17.214"></a><span id="l17.214">       if (!(toIdentity.id in involvesIdentities)) {</span>
<a href="#l17.215"></a><span id="l17.215">         involves.push(toIdentity);</span>
<a href="#l17.216"></a><span id="l17.216">         involvesIdentities[toIdentity.id] = true;</span>
<a href="#l17.217"></a><span id="l17.217" class="difflineplus">+        let toCard = toIdentity.abCard;</span>
<a href="#l17.218"></a><span id="l17.218" class="difflineplus">+        if (toCard) {</span>
<a href="#l17.219"></a><span id="l17.219" class="difflineplus">+          involvedAddrBookCount++;</span>
<a href="#l17.220"></a><span id="l17.220" class="difflineplus">+          // @testpoint gloda.noun.message.attr.recipientsMatch</span>
<a href="#l17.221"></a><span id="l17.221" class="difflineplus">+          aGlodaMessage._indexRecipients += ' ' + toCard.displayName;</span>
<a href="#l17.222"></a><span id="l17.222" class="difflineplus">+        }</span>
<a href="#l17.223"></a><span id="l17.223">       }</span>
<a href="#l17.224"></a><span id="l17.224"> </span>
<a href="#l17.225"></a><span id="l17.225">       // optimization attribute to-me ('I' am the parameter)</span>
<a href="#l17.226"></a><span id="l17.226">       if (toIdentity.id in myIdentities) {</span>
<a href="#l17.227"></a><span id="l17.227">         toMe.push([toIdentity, authorIdentity]);</span>
<a href="#l17.228"></a><span id="l17.228">         if (aIsNew)</span>
<a href="#l17.229"></a><span id="l17.229">           authorIdentity.contact.popularity += this.POPULARITY_TO_ME;</span>
<a href="#l17.230"></a><span id="l17.230">       }</span>
<a href="#l17.231"></a><span id="l17.231" class="difflineat">@@ -446,50 +517,91 @@ var GlodaFundAttr = {</span>
<a href="#l17.232"></a><span id="l17.232">         if (aIsNew)</span>
<a href="#l17.233"></a><span id="l17.233">           toIdentity.contact.popularity += this.POPULARITY_FROM_ME_TO;</span>
<a href="#l17.234"></a><span id="l17.234">       }</span>
<a href="#l17.235"></a><span id="l17.235">     }</span>
<a href="#l17.236"></a><span id="l17.236">     for each (let [,ccIdentity] in Iterator(aGlodaMessage.cc)) {</span>
<a href="#l17.237"></a><span id="l17.237">       if (!(ccIdentity.id in involvesIdentities)) {</span>
<a href="#l17.238"></a><span id="l17.238">         involves.push(ccIdentity);</span>
<a href="#l17.239"></a><span id="l17.239">         involvesIdentities[ccIdentity.id] = true;</span>
<a href="#l17.240"></a><span id="l17.240" class="difflineplus">+        let ccCard = ccIdentity.abCard;</span>
<a href="#l17.241"></a><span id="l17.241" class="difflineplus">+        if (ccCard) {</span>
<a href="#l17.242"></a><span id="l17.242" class="difflineplus">+          involvedAddrBookCount++;</span>
<a href="#l17.243"></a><span id="l17.243" class="difflineplus">+          // @testpoint gloda.noun.message.attr.recipientsMatch</span>
<a href="#l17.244"></a><span id="l17.244" class="difflineplus">+          aGlodaMessage._indexRecipients += ' ' + ccCard.displayName;</span>
<a href="#l17.245"></a><span id="l17.245" class="difflineplus">+        }</span>
<a href="#l17.246"></a><span id="l17.246">       }</span>
<a href="#l17.247"></a><span id="l17.247">       // optimization attribute cc-me ('I' am the parameter)</span>
<a href="#l17.248"></a><span id="l17.248">       if (ccIdentity.id in myIdentities) {</span>
<a href="#l17.249"></a><span id="l17.249">         ccMe.push([ccIdentity, authorIdentity]);</span>
<a href="#l17.250"></a><span id="l17.250">         if (aIsNew)</span>
<a href="#l17.251"></a><span id="l17.251">           authorIdentity.contact.popularity += this.POPULARITY_CC_ME;</span>
<a href="#l17.252"></a><span id="l17.252">       }</span>
<a href="#l17.253"></a><span id="l17.253">       // optimization attribute from-me-to ('I' am the parameter)</span>
<a href="#l17.254"></a><span id="l17.254">       if (isFromMe) {</span>
<a href="#l17.255"></a><span id="l17.255">         fromMeCc.push([authorIdentity, ccIdentity]);</span>
<a href="#l17.256"></a><span id="l17.256">         // also, popularity</span>
<a href="#l17.257"></a><span id="l17.257">         if (aIsNew)</span>
<a href="#l17.258"></a><span id="l17.258">           ccIdentity.contact.popularity += this.POPULARITY_FROM_ME_CC;</span>
<a href="#l17.259"></a><span id="l17.259">       }</span>
<a href="#l17.260"></a><span id="l17.260">     }</span>
<a href="#l17.261"></a><span id="l17.261"> </span>
<a href="#l17.262"></a><span id="l17.262" class="difflineplus">+    if (involvedAddrBookCount)</span>
<a href="#l17.263"></a><span id="l17.263" class="difflineplus">+      aGlodaMessage.notability += this.NOTABILITY_INVOLVING_ADDR_BOOK_FIRST +</span>
<a href="#l17.264"></a><span id="l17.264" class="difflineplus">+        (involvedAddrBookCount - 1) * this.NOTABILITY_INVOLVING_ADDR_BOOK_ADDL;</span>
<a href="#l17.265"></a><span id="l17.265" class="difflineplus">+</span>
<a href="#l17.266"></a><span id="l17.266">     aGlodaMessage.involves = involves;</span>
<a href="#l17.267"></a><span id="l17.267" class="difflineminus">-    if (toMe.length)</span>
<a href="#l17.268"></a><span id="l17.268" class="difflineplus">+    if (toMe.length) {</span>
<a href="#l17.269"></a><span id="l17.269">       aGlodaMessage.toMe = toMe;</span>
<a href="#l17.270"></a><span id="l17.270" class="difflineplus">+      aGlodaMessage.notability += this.NOTABILITY_INVOLVING_ME;</span>
<a href="#l17.271"></a><span id="l17.271" class="difflineplus">+    }</span>
<a href="#l17.272"></a><span id="l17.272">     if (fromMeTo.length)</span>
<a href="#l17.273"></a><span id="l17.273">       aGlodaMessage.fromMeTo = fromMeTo;</span>
<a href="#l17.274"></a><span id="l17.274">     if (ccMe.length)</span>
<a href="#l17.275"></a><span id="l17.275">       aGlodaMessage.ccMe = ccMe;</span>
<a href="#l17.276"></a><span id="l17.276">     if (fromMeCc.length)</span>
<a href="#l17.277"></a><span id="l17.277">       aGlodaMessage.fromMeCc = fromMeCc;</span>
<a href="#l17.278"></a><span id="l17.278"> </span>
<a href="#l17.279"></a><span id="l17.279">     if (aRawReps.bodyLines &amp;&amp;</span>
<a href="#l17.280"></a><span id="l17.280">         this.contentWhittle({}, aRawReps.bodyLines, aRawReps.content)) {</span>
<a href="#l17.281"></a><span id="l17.281">       // we were going to do something here?</span>
<a href="#l17.282"></a><span id="l17.282">     }</span>
<a href="#l17.283"></a><span id="l17.283"> </span>
<a href="#l17.284"></a><span id="l17.284">     yield Gloda.kWorkDone;</span>
<a href="#l17.285"></a><span id="l17.285">   },</span>
<a href="#l17.286"></a><span id="l17.286"> </span>
<a href="#l17.287"></a><span id="l17.287" class="difflineplus">+  /**</span>
<a href="#l17.288"></a><span id="l17.288" class="difflineplus">+   * Duplicates the notability logic from optimize().  Arguably optimize should</span>
<a href="#l17.289"></a><span id="l17.289" class="difflineplus">+   *  be factored to call us, grokNounItem should be factored to call us, or we</span>
<a href="#l17.290"></a><span id="l17.290" class="difflineplus">+   *  should get sufficiently fancy that our code wildly diverges.</span>
<a href="#l17.291"></a><span id="l17.291" class="difflineplus">+   */</span>
<a href="#l17.292"></a><span id="l17.292" class="difflineplus">+  score: function gloda_fundattr_score(aMessage, aContext) {</span>
<a href="#l17.293"></a><span id="l17.293" class="difflineplus">+    let score = 0;</span>
<a href="#l17.294"></a><span id="l17.294" class="difflineplus">+</span>
<a href="#l17.295"></a><span id="l17.295" class="difflineplus">+    let authorIdentity = aMessage.from;</span>
<a href="#l17.296"></a><span id="l17.296" class="difflineplus">+    if (authorIdentity.id in Gloda.myIdentities)</span>
<a href="#l17.297"></a><span id="l17.297" class="difflineplus">+      score += this.NOTABILITY_FROM_ME;</span>
<a href="#l17.298"></a><span id="l17.298" class="difflineplus">+    else if (authorIdentity.inAddressBook)</span>
<a href="#l17.299"></a><span id="l17.299" class="difflineplus">+      score += this.NOTABILITY_FROM_IN_ADDR_BOOK;</span>
<a href="#l17.300"></a><span id="l17.300" class="difflineplus">+    if (aMessage.toMe)</span>
<a href="#l17.301"></a><span id="l17.301" class="difflineplus">+      score += this.NOTABILITY_INVOLVING_ME;</span>
<a href="#l17.302"></a><span id="l17.302" class="difflineplus">+</span>
<a href="#l17.303"></a><span id="l17.303" class="difflineplus">+    let involvedAddrBookCount = 0;</span>
<a href="#l17.304"></a><span id="l17.304" class="difflineplus">+    for (let [, identity] in Iterator(aMessage.to))</span>
<a href="#l17.305"></a><span id="l17.305" class="difflineplus">+      if (identity.inAddressBook)</span>
<a href="#l17.306"></a><span id="l17.306" class="difflineplus">+        involvedAddrBookCount++;</span>
<a href="#l17.307"></a><span id="l17.307" class="difflineplus">+    for (let [, identity] in Iterator(aMessage.cc))</span>
<a href="#l17.308"></a><span id="l17.308" class="difflineplus">+      if (identity.inAddressBook)</span>
<a href="#l17.309"></a><span id="l17.309" class="difflineplus">+        involvedAddrBookCount++;</span>
<a href="#l17.310"></a><span id="l17.310" class="difflineplus">+    if (involvedAddrBookCount)</span>
<a href="#l17.311"></a><span id="l17.311" class="difflineplus">+      score += this.NOTABILITY_INVOLVING_ADDR_BOOK_FIRST +</span>
<a href="#l17.312"></a><span id="l17.312" class="difflineplus">+        (involvedAddrBookCount - 1) * this.NOTABILITY_INVOLVING_ADDR_BOOK_ADDL;</span>
<a href="#l17.313"></a><span id="l17.313" class="difflineplus">+    return score;</span>
<a href="#l17.314"></a><span id="l17.314" class="difflineplus">+  },</span>
<a href="#l17.315"></a><span id="l17.315" class="difflineplus">+</span>
<a href="#l17.316"></a><span id="l17.316">   _countQuoteDepthAndNormalize:</span>
<a href="#l17.317"></a><span id="l17.317">     function gloda_fundattr__countQuoteDepthAndNormalize(aLine) {</span>
<a href="#l17.318"></a><span id="l17.318">     let count = 0;</span>
<a href="#l17.319"></a><span id="l17.319">     let lastStartOffset = 0;</span>
<a href="#l17.320"></a><span id="l17.320"> </span>
<a href="#l17.321"></a><span id="l17.321">     for (let i = 0; i &lt; aLine.length; i++) {</span>
<a href="#l17.322"></a><span id="l17.322">       let c = aLine[i];</span>
<a href="#l17.323"></a><span id="l17.323">       if (c == &quot;&gt;&quot;) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/mailnews/db/gloda/modules/gloda.js</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/gloda.js</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -257,16 +257,18 @@ var Gloda = {</span>
<a href="#l18.4"></a><span id="l18.4">    *  the collection when this method returns.)</span>
<a href="#l18.5"></a><span id="l18.5">    *</span>
<a href="#l18.6"></a><span id="l18.6">    * @param aMsgHdr The header of the message you want the gloda message for.</span>
<a href="#l18.7"></a><span id="l18.7">    * @param aListener The listener that should be registered with the collection</span>
<a href="#l18.8"></a><span id="l18.8">    * @param aData The (optional) value to set as the data attribute on the</span>
<a href="#l18.9"></a><span id="l18.9">    *     collection.</span>
<a href="#l18.10"></a><span id="l18.10">    *</span>
<a href="#l18.11"></a><span id="l18.11">    * @return The collection that will receive the results.</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineplus">+   *</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+   * @testpoint gloda.ns.getMessageCollectionForHeader()</span>
<a href="#l18.14"></a><span id="l18.14">    */</span>
<a href="#l18.15"></a><span id="l18.15">   getMessageCollectionForHeader: function gloda_ns_getMessageForHeader(aMsgHdr,</span>
<a href="#l18.16"></a><span id="l18.16">       aListener, aData) {</span>
<a href="#l18.17"></a><span id="l18.17">     let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l18.18"></a><span id="l18.18">     query.folder(aMsgHdr.folder).messageKey(aMsgHdr.messageKey);</span>
<a href="#l18.19"></a><span id="l18.19">     return query.getCollection(aListener, aData);</span>
<a href="#l18.20"></a><span id="l18.20">   },</span>
<a href="#l18.21"></a><span id="l18.21"> </span>
<a href="#l18.22"></a><span id="l18.22" class="difflineat">@@ -281,16 +283,18 @@ var Gloda = {</span>
<a href="#l18.23"></a><span id="l18.23">    *</span>
<a href="#l18.24"></a><span id="l18.24">    * @param aHeaders A javascript Array or and XPCOM list that fixIterator can</span>
<a href="#l18.25"></a><span id="l18.25">    *     can handle.</span>
<a href="#l18.26"></a><span id="l18.26">    * @param aListener The listener that should be registered with the collection</span>
<a href="#l18.27"></a><span id="l18.27">    * @param aData The (optional) value to set as the data attribute on the</span>
<a href="#l18.28"></a><span id="l18.28">    *     collection.</span>
<a href="#l18.29"></a><span id="l18.29">    *</span>
<a href="#l18.30"></a><span id="l18.30">    * @return The collection that will receive the results.</span>
<a href="#l18.31"></a><span id="l18.31" class="difflineplus">+   *</span>
<a href="#l18.32"></a><span id="l18.32" class="difflineplus">+   * @testpoint gloda.ns.getMessageCollectionForHeaders()</span>
<a href="#l18.33"></a><span id="l18.33">    */</span>
<a href="#l18.34"></a><span id="l18.34">   getMessageCollectionForHeaders: function gloda_ns_getMessagesForHeaders(</span>
<a href="#l18.35"></a><span id="l18.35">       aHeaders, aListener, aData) {</span>
<a href="#l18.36"></a><span id="l18.36">     // group the headers by the folder they are found in</span>
<a href="#l18.37"></a><span id="l18.37">     let headersByFolder = {};</span>
<a href="#l18.38"></a><span id="l18.38">     let iter;</span>
<a href="#l18.39"></a><span id="l18.39">     for (let header in fixIterator(aHeaders)) {</span>
<a href="#l18.40"></a><span id="l18.40">       let folderURI = header.folder.URI;</span>
<a href="#l18.41"></a><span id="l18.41" class="difflineat">@@ -315,16 +319,19 @@ var Gloda = {</span>
<a href="#l18.42"></a><span id="l18.42">       clause.folder(folder);</span>
<a href="#l18.43"></a><span id="l18.43">       let messageKeys = [hdr.messageKey for each (hdr in headersForFolder)];</span>
<a href="#l18.44"></a><span id="l18.44">       clause.messageKey.apply(clause, messageKeys);</span>
<a href="#l18.45"></a><span id="l18.45">     }</span>
<a href="#l18.46"></a><span id="l18.46"> </span>
<a href="#l18.47"></a><span id="l18.47">     return query.getCollection(aListener, aData);</span>
<a href="#l18.48"></a><span id="l18.48">   },</span>
<a href="#l18.49"></a><span id="l18.49"> </span>
<a href="#l18.50"></a><span id="l18.50" class="difflineplus">+  /**</span>
<a href="#l18.51"></a><span id="l18.51" class="difflineplus">+   * @testpoint gloda.ns.getMessageContent</span>
<a href="#l18.52"></a><span id="l18.52" class="difflineplus">+   */</span>
<a href="#l18.53"></a><span id="l18.53">   getMessageContent: function gloda_ns_getMessageContent(aGlodaMessage, aMimeMsg) {</span>
<a href="#l18.54"></a><span id="l18.54">     return mimeMsgToContentAndMeta(aMimeMsg, aGlodaMessage.folderMessage.folder)[0];</span>
<a href="#l18.55"></a><span id="l18.55">   },</span>
<a href="#l18.56"></a><span id="l18.56"> </span>
<a href="#l18.57"></a><span id="l18.57">   getFolderForFolder: function gloda_ns_getFolderForFolder(aMsgFolder) {</span>
<a href="#l18.58"></a><span id="l18.58">     return GlodaDatastore._mapFolder(aMsgFolder);</span>
<a href="#l18.59"></a><span id="l18.59">   },</span>
<a href="#l18.60"></a><span id="l18.60"> </span>
<a href="#l18.61"></a><span id="l18.61" class="difflineat">@@ -818,16 +825,21 @@ var Gloda = {</span>
<a href="#l18.62"></a><span id="l18.62">    *       the column &quot;bar&quot; where the index is named &quot;foo&quot;.</span>
<a href="#l18.63"></a><span id="l18.63">   */</span>
<a href="#l18.64"></a><span id="l18.64">   defineNoun: function gloda_ns_defineNoun(aNounDef, aNounID) {</span>
<a href="#l18.65"></a><span id="l18.65">     this._log.info(&quot;Defining noun: &quot; + aNounDef.name);</span>
<a href="#l18.66"></a><span id="l18.66">     if (aNounID === undefined)</span>
<a href="#l18.67"></a><span id="l18.67">       aNounID = this._nextNounID++;</span>
<a href="#l18.68"></a><span id="l18.68">     aNounDef.id = aNounID;</span>
<a href="#l18.69"></a><span id="l18.69"> </span>
<a href="#l18.70"></a><span id="l18.70" class="difflineplus">+    // Let people whose editors get angry about illegal attribute names use</span>
<a href="#l18.71"></a><span id="l18.71" class="difflineplus">+    //  clazz instead of class.</span>
<a href="#l18.72"></a><span id="l18.72" class="difflineplus">+    if (aNounDef.clazz)</span>
<a href="#l18.73"></a><span id="l18.73" class="difflineplus">+      aNounDef.class = aNounDef.clazz;</span>
<a href="#l18.74"></a><span id="l18.74" class="difflineplus">+</span>
<a href="#l18.75"></a><span id="l18.75">     // We allow nouns to have data tables associated with them where we do all</span>
<a href="#l18.76"></a><span id="l18.76">     //  the legwork.  The schema attribute is the gateway to this magical world</span>
<a href="#l18.77"></a><span id="l18.77">     //  of functionality.  Said door is officially unsupported.</span>
<a href="#l18.78"></a><span id="l18.78">     if (aNounDef.schema) {</span>
<a href="#l18.79"></a><span id="l18.79">       if (aNounDef.schema.name)</span>
<a href="#l18.80"></a><span id="l18.80">         aNounDef.tableName = &quot;ext_&quot; + aNounDef.schema.name;</span>
<a href="#l18.81"></a><span id="l18.81">       else</span>
<a href="#l18.82"></a><span id="l18.82">         aNounDef.tableName = &quot;ext_&quot; + aNounDef.name;</span>
<a href="#l18.83"></a><span id="l18.83" class="difflineat">@@ -843,16 +855,17 @@ var Gloda = {</span>
<a href="#l18.84"></a><span id="l18.84">     }</span>
<a href="#l18.85"></a><span id="l18.85"> </span>
<a href="#l18.86"></a><span id="l18.86">     // if it has a table, you can query on it.  seems straight-forward.</span>
<a href="#l18.87"></a><span id="l18.87">     if (aNounDef.tableName) {</span>
<a href="#l18.88"></a><span id="l18.88">       [aNounDef.queryClass, aNounDef.nullQueryClass,</span>
<a href="#l18.89"></a><span id="l18.89">        aNounDef.explicitQueryClass, aNounDef.wildcardQueryClass] =</span>
<a href="#l18.90"></a><span id="l18.90">           GlodaQueryClassFactory(aNounDef);</span>
<a href="#l18.91"></a><span id="l18.91">       aNounDef._dbMeta = {};</span>
<a href="#l18.92"></a><span id="l18.92" class="difflineplus">+      aNounDef.class.prototype.NOUN_ID = aNounDef.id;</span>
<a href="#l18.93"></a><span id="l18.93">       aNounDef.class.prototype.NOUN_DEF = aNounDef;</span>
<a href="#l18.94"></a><span id="l18.94">       aNounDef.toJSON = this._managedToJSON;</span>
<a href="#l18.95"></a><span id="l18.95"> </span>
<a href="#l18.96"></a><span id="l18.96">       aNounDef.specialLoadAttribs = [];</span>
<a href="#l18.97"></a><span id="l18.97"> </span>
<a href="#l18.98"></a><span id="l18.98">       // - define the 'id' constrainer</span>
<a href="#l18.99"></a><span id="l18.99">       let idConstrainer = function() {</span>
<a href="#l18.100"></a><span id="l18.100">         let constraint = [GlodaDatastore.kConstraintIdIn, null];</span>
<a href="#l18.101"></a><span id="l18.101" class="difflineat">@@ -986,115 +999,115 @@ var Gloda = {</span>
<a href="#l18.102"></a><span id="l18.102">    *  SQL table def and helper code from datastore.js (and this code) to their</span>
<a href="#l18.103"></a><span id="l18.103">    *  own noun_*.js files.  There are some trade-offs to be made, and I think</span>
<a href="#l18.104"></a><span id="l18.104">    *  we can deal with those once we start to integrate lightning/calendar and</span>
<a href="#l18.105"></a><span id="l18.105">    *  our noun space gets large and more heterogeneous.</span>
<a href="#l18.106"></a><span id="l18.106">    */</span>
<a href="#l18.107"></a><span id="l18.107">   _initAttributes: function gloda_ns_initAttributes() {</span>
<a href="#l18.108"></a><span id="l18.108">     this.defineNoun({</span>
<a href="#l18.109"></a><span id="l18.109">       name: &quot;bool&quot;,</span>
<a href="#l18.110"></a><span id="l18.110" class="difflineminus">-      class: Boolean, allowsArbitraryAttrs: false,</span>
<a href="#l18.111"></a><span id="l18.111" class="difflineplus">+      clazz: Boolean, allowsArbitraryAttrs: false,</span>
<a href="#l18.112"></a><span id="l18.112">       toParamAndValue: function(aBool) {</span>
<a href="#l18.113"></a><span id="l18.113">         return [null, aBool ? 1 : 0];</span>
<a href="#l18.114"></a><span id="l18.114">       }}, this.NOUN_BOOLEAN);</span>
<a href="#l18.115"></a><span id="l18.115">     this.defineNoun({</span>
<a href="#l18.116"></a><span id="l18.116">       name: &quot;number&quot;,</span>
<a href="#l18.117"></a><span id="l18.117" class="difflineminus">-      class: Number, allowsArbitraryAttrs: false, continuous: true,</span>
<a href="#l18.118"></a><span id="l18.118" class="difflineplus">+      clazz: Number, allowsArbitraryAttrs: false, continuous: true,</span>
<a href="#l18.119"></a><span id="l18.119">       toParamAndValue: function(aNum) {</span>
<a href="#l18.120"></a><span id="l18.120">         return [null, aNum];</span>
<a href="#l18.121"></a><span id="l18.121">       }}, this.NOUN_NUMBER);</span>
<a href="#l18.122"></a><span id="l18.122">     this.defineNoun({</span>
<a href="#l18.123"></a><span id="l18.123">       name: &quot;string&quot;,</span>
<a href="#l18.124"></a><span id="l18.124" class="difflineminus">-      class: String, allowsArbitraryAttrs: false,</span>
<a href="#l18.125"></a><span id="l18.125" class="difflineplus">+      clazz: String, allowsArbitraryAttrs: false,</span>
<a href="#l18.126"></a><span id="l18.126">       toParamAndValue: function(aString) {</span>
<a href="#l18.127"></a><span id="l18.127">         return [null, aString];</span>
<a href="#l18.128"></a><span id="l18.128">       }}, this.NOUN_STRING);</span>
<a href="#l18.129"></a><span id="l18.129">     this.defineNoun({</span>
<a href="#l18.130"></a><span id="l18.130">       name: &quot;date&quot;,</span>
<a href="#l18.131"></a><span id="l18.131" class="difflineminus">-      class: Date, allowsArbitraryAttrs: false, continuous: true,</span>
<a href="#l18.132"></a><span id="l18.132" class="difflineplus">+      clazz: Date, allowsArbitraryAttrs: false, continuous: true,</span>
<a href="#l18.133"></a><span id="l18.133">       toParamAndValue: function(aDate) {</span>
<a href="#l18.134"></a><span id="l18.134">         return [null, aDate.valueOf() * 1000];</span>
<a href="#l18.135"></a><span id="l18.135">       }}, this.NOUN_DATE);</span>
<a href="#l18.136"></a><span id="l18.136">     this.defineNoun({</span>
<a href="#l18.137"></a><span id="l18.137">       name: &quot;fulltext&quot;,</span>
<a href="#l18.138"></a><span id="l18.138" class="difflineminus">-      class: String, allowsArbitraryAttrs: false, continuous: false,</span>
<a href="#l18.139"></a><span id="l18.139" class="difflineplus">+      clazz: String, allowsArbitraryAttrs: false, continuous: false,</span>
<a href="#l18.140"></a><span id="l18.140">       // as noted on NOUN_FULLTEXT, we just pass the string around.  it never</span>
<a href="#l18.141"></a><span id="l18.141">       //  hits the database, so it's okay.</span>
<a href="#l18.142"></a><span id="l18.142">       toParamAndValue: function(aString) {</span>
<a href="#l18.143"></a><span id="l18.143">         return [null, aString];</span>
<a href="#l18.144"></a><span id="l18.144">       }}, this.NOUN_FULLTEXT);</span>
<a href="#l18.145"></a><span id="l18.145"> </span>
<a href="#l18.146"></a><span id="l18.146">     this.defineNoun({</span>
<a href="#l18.147"></a><span id="l18.147">       name: &quot;folder&quot;,</span>
<a href="#l18.148"></a><span id="l18.148" class="difflineminus">-      class: GlodaFolder,</span>
<a href="#l18.149"></a><span id="l18.149" class="difflineplus">+      clazz: GlodaFolder,</span>
<a href="#l18.150"></a><span id="l18.150">       allowsArbitraryAttrs: false,</span>
<a href="#l18.151"></a><span id="l18.151">       toParamAndValue: function(aFolderOrGlodaFolder) {</span>
<a href="#l18.152"></a><span id="l18.152">         if (aFolderOrGlodaFolder instanceof GlodaFolder)</span>
<a href="#l18.153"></a><span id="l18.153">           return [null, aFolderOrGlodaFolder.id];</span>
<a href="#l18.154"></a><span id="l18.154">         else</span>
<a href="#l18.155"></a><span id="l18.155">           return [null, GlodaDatastore._mapFolder(aFolderOrGlodaFolder).id];</span>
<a href="#l18.156"></a><span id="l18.156">       }}, this.NOUN_FOLDER);</span>
<a href="#l18.157"></a><span id="l18.157">     this.defineNoun({</span>
<a href="#l18.158"></a><span id="l18.158">       name: &quot;conversation&quot;,</span>
<a href="#l18.159"></a><span id="l18.159" class="difflineminus">-      class: GlodaConversation,</span>
<a href="#l18.160"></a><span id="l18.160" class="difflineplus">+      clazz: GlodaConversation,</span>
<a href="#l18.161"></a><span id="l18.161">       allowsArbitraryAttrs: false,</span>
<a href="#l18.162"></a><span id="l18.162">       cache: true, cacheCost: 512,</span>
<a href="#l18.163"></a><span id="l18.163">       tableName: &quot;conversations&quot;,</span>
<a href="#l18.164"></a><span id="l18.164">       attrTableName: &quot;messageAttributes&quot;, attrIDColumnName: &quot;conversationID&quot;,</span>
<a href="#l18.165"></a><span id="l18.165">       datastore: GlodaDatastore,</span>
<a href="#l18.166"></a><span id="l18.166">       objFromRow: GlodaDatastore._conversationFromRow,</span>
<a href="#l18.167"></a><span id="l18.167">       toParamAndValue: function(aConversation) {</span>
<a href="#l18.168"></a><span id="l18.168">         if (aConversation instanceof GlodaConversation)</span>
<a href="#l18.169"></a><span id="l18.169">           return [null, aConversation.id];</span>
<a href="#l18.170"></a><span id="l18.170">         else // assume they're just passing the id directly</span>
<a href="#l18.171"></a><span id="l18.171">           return [null, aConversation];</span>
<a href="#l18.172"></a><span id="l18.172">       }}, this.NOUN_CONVERSATION);</span>
<a href="#l18.173"></a><span id="l18.173">     this.defineNoun({</span>
<a href="#l18.174"></a><span id="l18.174">       name: &quot;message&quot;,</span>
<a href="#l18.175"></a><span id="l18.175" class="difflineminus">-      class: GlodaMessage,</span>
<a href="#l18.176"></a><span id="l18.176" class="difflineplus">+      clazz: GlodaMessage,</span>
<a href="#l18.177"></a><span id="l18.177">       allowsArbitraryAttrs: true,</span>
<a href="#l18.178"></a><span id="l18.178">       cache: true, cacheCost: 2048,</span>
<a href="#l18.179"></a><span id="l18.179">       tableName: &quot;messages&quot;,</span>
<a href="#l18.180"></a><span id="l18.180">       // we will always have a fulltext row, even for messages where we don't</span>
<a href="#l18.181"></a><span id="l18.181">       //  have the body available.  this is because we want the subject indexed.</span>
<a href="#l18.182"></a><span id="l18.182">       dbQueryJoinMagic:</span>
<a href="#l18.183"></a><span id="l18.183">         &quot; INNER JOIN messagesText ON messages.id = messagesText.rowid&quot;,</span>
<a href="#l18.184"></a><span id="l18.184">       attrTableName: &quot;messageAttributes&quot;, attrIDColumnName: &quot;messageID&quot;,</span>
<a href="#l18.185"></a><span id="l18.185">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._messageFromRow,</span>
<a href="#l18.186"></a><span id="l18.186">       dbAttribAdjuster: GlodaDatastore.adjustMessageAttributes,</span>
<a href="#l18.187"></a><span id="l18.187">       dbQueryValidityConstraintSuffix:</span>
<a href="#l18.188"></a><span id="l18.188" class="difflineminus">-        &quot; AND deleted = 0 AND folderID IS NOT NULL AND messageKey IS NOT NULL&quot;,</span>
<a href="#l18.189"></a><span id="l18.189" class="difflineplus">+        &quot; AND +deleted = 0 AND +folderID IS NOT NULL AND +messageKey IS NOT NULL&quot;,</span>
<a href="#l18.190"></a><span id="l18.190">       objInsert: GlodaDatastore.insertMessage,</span>
<a href="#l18.191"></a><span id="l18.191">       objUpdate: GlodaDatastore.updateMessage,</span>
<a href="#l18.192"></a><span id="l18.192">       toParamAndValue: function(aMessage) {</span>
<a href="#l18.193"></a><span id="l18.193">         if (aMessage instanceof GlodaMessage)</span>
<a href="#l18.194"></a><span id="l18.194">           return [null, aMessage.id];</span>
<a href="#l18.195"></a><span id="l18.195">         else // assume they're just passing the id directly</span>
<a href="#l18.196"></a><span id="l18.196">           return [null, aMessage];</span>
<a href="#l18.197"></a><span id="l18.197">       }}, this.NOUN_MESSAGE);</span>
<a href="#l18.198"></a><span id="l18.198">     this.defineNoun({</span>
<a href="#l18.199"></a><span id="l18.199">       name: &quot;contact&quot;,</span>
<a href="#l18.200"></a><span id="l18.200" class="difflineminus">-      class: GlodaContact,</span>
<a href="#l18.201"></a><span id="l18.201" class="difflineplus">+      clazz: GlodaContact,</span>
<a href="#l18.202"></a><span id="l18.202">       allowsArbitraryAttrs: true,</span>
<a href="#l18.203"></a><span id="l18.203">       cache: true, cacheCost: 128,</span>
<a href="#l18.204"></a><span id="l18.204">       tableName: &quot;contacts&quot;,</span>
<a href="#l18.205"></a><span id="l18.205">       attrTableName: &quot;contactAttributes&quot;, attrIDColumnName: &quot;contactID&quot;,</span>
<a href="#l18.206"></a><span id="l18.206">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._contactFromRow,</span>
<a href="#l18.207"></a><span id="l18.207">       dbAttribAdjuster: GlodaDatastore.adjustAttributes,</span>
<a href="#l18.208"></a><span id="l18.208">       objInsert: GlodaDatastore.insertContact,</span>
<a href="#l18.209"></a><span id="l18.209">       objUpdate: GlodaDatastore.updateContact,</span>
<a href="#l18.210"></a><span id="l18.210">       toParamAndValue: function(aContact) {</span>
<a href="#l18.211"></a><span id="l18.211">         if (aContact instanceof GlodaContact)</span>
<a href="#l18.212"></a><span id="l18.212">           return [null, aContact.id];</span>
<a href="#l18.213"></a><span id="l18.213">         else // assume they're just passing the id directly</span>
<a href="#l18.214"></a><span id="l18.214">           return [null, aContact];</span>
<a href="#l18.215"></a><span id="l18.215">       }}, this.NOUN_CONTACT);</span>
<a href="#l18.216"></a><span id="l18.216">     this.defineNoun({</span>
<a href="#l18.217"></a><span id="l18.217">       name: &quot;identity&quot;,</span>
<a href="#l18.218"></a><span id="l18.218" class="difflineminus">-      class: GlodaIdentity,</span>
<a href="#l18.219"></a><span id="l18.219" class="difflineplus">+      clazz: GlodaIdentity,</span>
<a href="#l18.220"></a><span id="l18.220">       allowsArbitraryAttrs: false,</span>
<a href="#l18.221"></a><span id="l18.221">       cache: true, cacheCost: 128,</span>
<a href="#l18.222"></a><span id="l18.222">       usesUniqueValue: true,</span>
<a href="#l18.223"></a><span id="l18.223">       tableName: &quot;identities&quot;,</span>
<a href="#l18.224"></a><span id="l18.224">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._identityFromRow,</span>
<a href="#l18.225"></a><span id="l18.225">       toParamAndValue: function(aIdentity) {</span>
<a href="#l18.226"></a><span id="l18.226">         if (aIdentity instanceof GlodaIdentity)</span>
<a href="#l18.227"></a><span id="l18.227">           return [null, aIdentity.id];</span>
<a href="#l18.228"></a><span id="l18.228" class="difflineat">@@ -1103,17 +1116,17 @@ var Gloda = {</span>
<a href="#l18.229"></a><span id="l18.229">       }}, this.NOUN_IDENTITY);</span>
<a href="#l18.230"></a><span id="l18.230"> </span>
<a href="#l18.231"></a><span id="l18.231">     // parameterized identity is just two identities; we store the first one</span>
<a href="#l18.232"></a><span id="l18.232">     //  (whose value set must be very constrainted, like the 'me' identities)</span>
<a href="#l18.233"></a><span id="l18.233">     //  as the parameter, the second (which does not need to be constrained)</span>
<a href="#l18.234"></a><span id="l18.234">     //  as the value.</span>
<a href="#l18.235"></a><span id="l18.235">     this.defineNoun({</span>
<a href="#l18.236"></a><span id="l18.236">       name: &quot;parameterized-identity&quot;,</span>
<a href="#l18.237"></a><span id="l18.237" class="difflineminus">-      class: null,</span>
<a href="#l18.238"></a><span id="l18.238" class="difflineplus">+      clazz: null,</span>
<a href="#l18.239"></a><span id="l18.239">       allowsArbitraryAttrs: false,</span>
<a href="#l18.240"></a><span id="l18.240">       computeDelta: function(aCurValues, aOldValues) {</span>
<a href="#l18.241"></a><span id="l18.241">         let oldMap = {};</span>
<a href="#l18.242"></a><span id="l18.242">         for each (let [, tupe] in Iterator(aOldValues)) {</span>
<a href="#l18.243"></a><span id="l18.243">           let [originIdentity, targetIdentity] = tupe;</span>
<a href="#l18.244"></a><span id="l18.244">           let targets = oldMap[originIdentity];</span>
<a href="#l18.245"></a><span id="l18.245">           if (targets === undefined)</span>
<a href="#l18.246"></a><span id="l18.246">             targets = oldMap[originIdentity] = {};</span>
<a href="#l18.247"></a><span id="l18.247" class="difflineat">@@ -1139,17 +1152,17 @@ var Gloda = {</span>
<a href="#l18.248"></a><span id="l18.248">         return [added, removed];</span>
<a href="#l18.249"></a><span id="l18.249">       },</span>
<a href="#l18.250"></a><span id="l18.250">       contributeObjDependencies: function(aJsonValues, aReferencesByNounID,</span>
<a href="#l18.251"></a><span id="l18.251">           aInverseReferencesByNounID) {</span>
<a href="#l18.252"></a><span id="l18.252">         // nothing to do with a zero-length list</span>
<a href="#l18.253"></a><span id="l18.253">         if (aJsonValues.length == 0)</span>
<a href="#l18.254"></a><span id="l18.254">           return false;</span>
<a href="#l18.255"></a><span id="l18.255"> </span>
<a href="#l18.256"></a><span id="l18.256" class="difflineminus">-        let nounIdentityDef = Gloda._nounIDToDef[Gloda.NOUN_IDENTITY]</span>
<a href="#l18.257"></a><span id="l18.257" class="difflineplus">+        let nounIdentityDef = Gloda._nounIDToDef[Gloda.NOUN_IDENTITY];</span>
<a href="#l18.258"></a><span id="l18.258">         let references = aReferencesByNounID[nounIdentityDef.id];</span>
<a href="#l18.259"></a><span id="l18.259">         if (references === undefined)</span>
<a href="#l18.260"></a><span id="l18.260">           references = aReferencesByNounID[nounIdentityDef.id] = {};</span>
<a href="#l18.261"></a><span id="l18.261"> </span>
<a href="#l18.262"></a><span id="l18.262">         for each (let [, tupe] in Iterator(aJsonValues)) {</span>
<a href="#l18.263"></a><span id="l18.263">           let [originIdentityID, targetIdentityID] = tupe;</span>
<a href="#l18.264"></a><span id="l18.264">           if (!(originIdentityID in references))</span>
<a href="#l18.265"></a><span id="l18.265">             references[originIdentityID] = null;</span>
<a href="#l18.266"></a><span id="l18.266" class="difflineat">@@ -1227,34 +1240,34 @@ var Gloda = {</span>
<a href="#l18.267"></a><span id="l18.267">         // takes one or more tuples of [lower bound, upper bound]</span>
<a href="#l18.268"></a><span id="l18.268">         let rangedConstrainer = function() {</span>
<a href="#l18.269"></a><span id="l18.269">           let constraint = [GlodaDatastore.kConstraintRanges, aAttrDef];</span>
<a href="#l18.270"></a><span id="l18.270">           for (let iArg = 0; iArg &lt; arguments.length; iArg++ ) {</span>
<a href="#l18.271"></a><span id="l18.271">             constraint.push(arguments[iArg]);</span>
<a href="#l18.272"></a><span id="l18.272">           }</span>
<a href="#l18.273"></a><span id="l18.273">           this._constraints.push(constraint);</span>
<a href="#l18.274"></a><span id="l18.274">           return this;</span>
<a href="#l18.275"></a><span id="l18.275" class="difflineminus">-        }</span>
<a href="#l18.276"></a><span id="l18.276" class="difflineplus">+        };</span>
<a href="#l18.277"></a><span id="l18.277"> </span>
<a href="#l18.278"></a><span id="l18.278">         aSubjectNounDef.queryClass.prototype[aAttrDef.boundName + &quot;Range&quot;] =</span>
<a href="#l18.279"></a><span id="l18.279">           rangedConstrainer;</span>
<a href="#l18.280"></a><span id="l18.280">       }</span>
<a href="#l18.281"></a><span id="l18.281"> </span>
<a href="#l18.282"></a><span id="l18.282">       // - string LIKE helper for special on-row attributes: fooLike</span>
<a href="#l18.283"></a><span id="l18.283">       // (it is impossible to store a string as an indexed attribute, which is</span>
<a href="#l18.284"></a><span id="l18.284">       //  why we do this for on-row only.)</span>
<a href="#l18.285"></a><span id="l18.285">       if (aAttrDef.special == this.kSpecialString) {</span>
<a href="#l18.286"></a><span id="l18.286">         let likeConstrainer = function() {</span>
<a href="#l18.287"></a><span id="l18.287">           let constraint = [GlodaDatastore.kConstraintStringLike, aAttrDef];</span>
<a href="#l18.288"></a><span id="l18.288">           for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l18.289"></a><span id="l18.289">             constraint.push(arguments[iArg]);</span>
<a href="#l18.290"></a><span id="l18.290">           }</span>
<a href="#l18.291"></a><span id="l18.291">           this._constraints.push(constraint);</span>
<a href="#l18.292"></a><span id="l18.292">           return this;</span>
<a href="#l18.293"></a><span id="l18.293" class="difflineminus">-        }</span>
<a href="#l18.294"></a><span id="l18.294" class="difflineplus">+        };</span>
<a href="#l18.295"></a><span id="l18.295"> </span>
<a href="#l18.296"></a><span id="l18.296">         aSubjectNounDef.queryClass.prototype[aAttrDef.boundName + &quot;Like&quot;] =</span>
<a href="#l18.297"></a><span id="l18.297">           likeConstrainer;</span>
<a href="#l18.298"></a><span id="l18.298">       }</span>
<a href="#l18.299"></a><span id="l18.299">     }</span>
<a href="#l18.300"></a><span id="l18.300">   },</span>
<a href="#l18.301"></a><span id="l18.301"> </span>
<a href="#l18.302"></a><span id="l18.302">   /**</span>
<a href="#l18.303"></a><span id="l18.303" class="difflineat">@@ -1442,30 +1455,34 @@ var Gloda = {</span>
<a href="#l18.304"></a><span id="l18.304">    *  should be ORed together, simply pass additional (pairs of) arguments.</span>
<a href="#l18.305"></a><span id="l18.305">    *  For example, newQuery(NOUN_PERSON).age(25,100) would constraint to all</span>
<a href="#l18.306"></a><span id="l18.306">    *  the people who are &gt;= 25 and &lt;= 100.  Likewise age(25, null) would just</span>
<a href="#l18.307"></a><span id="l18.307">    *  return all the people who are 25 or older.  And age(25,30,35,40) would</span>
<a href="#l18.308"></a><span id="l18.308">    *  return people who are either 25-30 or 35-30.</span>
<a href="#l18.309"></a><span id="l18.309">    * There are also full-text constraint columns.  In a nutshell, their</span>
<a href="#l18.310"></a><span id="l18.310">    *  arguments are the strings that should be passed to the SQLite FTS3</span>
<a href="#l18.311"></a><span id="l18.311">    *  MATCH clause.</span>
<a href="#l18.312"></a><span id="l18.312" class="difflineplus">+   *</span>
<a href="#l18.313"></a><span id="l18.313" class="difflineplus">+   * @param aNounID The (integer) noun-id of the noun you want to query on.</span>
<a href="#l18.314"></a><span id="l18.314" class="difflineplus">+   * @param aOptions an optional dictionary of query options, see the GlodaQuery</span>
<a href="#l18.315"></a><span id="l18.315" class="difflineplus">+   *     class documentation.</span>
<a href="#l18.316"></a><span id="l18.316">    */</span>
<a href="#l18.317"></a><span id="l18.317" class="difflineminus">-  newQuery: function gloda_ns_newQuery(aNounID) {</span>
<a href="#l18.318"></a><span id="l18.318" class="difflineplus">+  newQuery: function gloda_ns_newQuery(aNounID, aOptions) {</span>
<a href="#l18.319"></a><span id="l18.319">     let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l18.320"></a><span id="l18.320" class="difflineminus">-    return new nounDef.queryClass();</span>
<a href="#l18.321"></a><span id="l18.321" class="difflineplus">+    return new nounDef.queryClass(aOptions);</span>
<a href="#l18.322"></a><span id="l18.322">   },</span>
<a href="#l18.323"></a><span id="l18.323"> </span>
<a href="#l18.324"></a><span id="l18.324">   /**</span>
<a href="#l18.325"></a><span id="l18.325">    * Create a collection/query for the given noun-type that only matches the</span>
<a href="#l18.326"></a><span id="l18.326">    *  provided items.  This is to be used when you have an explicit set of items</span>
<a href="#l18.327"></a><span id="l18.327">    *  that you would still like to receive updates for.</span>
<a href="#l18.328"></a><span id="l18.328">    */</span>
<a href="#l18.329"></a><span id="l18.329">   explicitCollection: function gloda_ns_explicitCollection(aNounID, aItems) {</span>
<a href="#l18.330"></a><span id="l18.330">     let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l18.331"></a><span id="l18.331" class="difflineminus">-    let collection = new GlodaCollection(nounDef, aItems, null, null)</span>
<a href="#l18.332"></a><span id="l18.332" class="difflineplus">+    let collection = new GlodaCollection(nounDef, aItems, null, null);</span>
<a href="#l18.333"></a><span id="l18.333">     let query = new nounDef.explicitQueryClass(collection);</span>
<a href="#l18.334"></a><span id="l18.334">     collection.query = query;</span>
<a href="#l18.335"></a><span id="l18.335">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l18.336"></a><span id="l18.336">     return collection;</span>
<a href="#l18.337"></a><span id="l18.337">   },</span>
<a href="#l18.338"></a><span id="l18.338"> </span>
<a href="#l18.339"></a><span id="l18.339">   /**</span>
<a href="#l18.340"></a><span id="l18.340">    * Debugging 'wildcard' collection creation support.  A wildcard collection</span>
<a href="#l18.341"></a><span id="l18.341" class="difflineat">@@ -1475,17 +1492,17 @@ var Gloda = {</span>
<a href="#l18.342"></a><span id="l18.342">    *  etc.</span>
<a href="#l18.343"></a><span id="l18.343">    * Because the items are added to the collection without limit, this will</span>
<a href="#l18.344"></a><span id="l18.344">    *  result in a leak if you don't do something to clean up after the</span>
<a href="#l18.345"></a><span id="l18.345">    *  collection.  (Forgetting about the collection will suffice, as it is still</span>
<a href="#l18.346"></a><span id="l18.346">    *  weakly held.)</span>
<a href="#l18.347"></a><span id="l18.347">    */</span>
<a href="#l18.348"></a><span id="l18.348">   _wildcardCollection: function gloda_ns_wildcardCollection(aNounID, aItems) {</span>
<a href="#l18.349"></a><span id="l18.349">     let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l18.350"></a><span id="l18.350" class="difflineminus">-    let collection = new GlodaCollection(nounDef, aItems, null, null)</span>
<a href="#l18.351"></a><span id="l18.351" class="difflineplus">+    let collection = new GlodaCollection(nounDef, aItems, null, null);</span>
<a href="#l18.352"></a><span id="l18.352">     let query = new nounDef.wildcardQueryClass(collection);</span>
<a href="#l18.353"></a><span id="l18.353">     collection.query = query;</span>
<a href="#l18.354"></a><span id="l18.354">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l18.355"></a><span id="l18.355">     return collection;</span>
<a href="#l18.356"></a><span id="l18.356">   },</span>
<a href="#l18.357"></a><span id="l18.357"> </span>
<a href="#l18.358"></a><span id="l18.358">   /**</span>
<a href="#l18.359"></a><span id="l18.359">    * Populate a gloda representation of an item given the thus-far built</span>
<a href="#l18.360"></a><span id="l18.360" class="difflineat">@@ -1515,17 +1532,17 @@ var Gloda = {</span>
<a href="#l18.361"></a><span id="l18.361">    * @param aCallbackHandle The GlodaIndexer-style callback handle that is being</span>
<a href="#l18.362"></a><span id="l18.362">    *     used to drive this processing in an async fashion.  (See</span>
<a href="#l18.363"></a><span id="l18.363">    *     GlodaIndexer._callbackHandle).</span>
<a href="#l18.364"></a><span id="l18.364">    * @param aDoCache Should we allow this item to be contributed to its noun</span>
<a href="#l18.365"></a><span id="l18.365">    *     cache?</span>
<a href="#l18.366"></a><span id="l18.366">    */</span>
<a href="#l18.367"></a><span id="l18.367">   grokNounItem: function gloda_ns_grokNounItem(aItem, aRawReps,</span>
<a href="#l18.368"></a><span id="l18.368">       aIsConceptuallyNew, aIsRecordNew, aCallbackHandle, aDoCache) {</span>
<a href="#l18.369"></a><span id="l18.369" class="difflineminus">-    let itemNounDef = this._nounIDToDef[aItem.NOUN_ID];</span>
<a href="#l18.370"></a><span id="l18.370" class="difflineplus">+    let itemNounDef = aItem.NOUN_DEF;</span>
<a href="#l18.371"></a><span id="l18.371">     let attribsByBoundName = itemNounDef.attribsByBoundName;</span>
<a href="#l18.372"></a><span id="l18.372"> </span>
<a href="#l18.373"></a><span id="l18.373">     this._log.info(&quot; ** grokNounItem: &quot; + itemNounDef.name);</span>
<a href="#l18.374"></a><span id="l18.374"> </span>
<a href="#l18.375"></a><span id="l18.375">     let addDBAttribs = [];</span>
<a href="#l18.376"></a><span id="l18.376">     let removeDBAttribs = [];</span>
<a href="#l18.377"></a><span id="l18.377"> </span>
<a href="#l18.378"></a><span id="l18.378">     let jsonDict = {};</span>
<a href="#l18.379"></a><span id="l18.379" class="difflineat">@@ -1536,25 +1553,25 @@ var Gloda = {</span>
<a href="#l18.380"></a><span id="l18.380">     else {</span>
<a href="#l18.381"></a><span id="l18.381">       aOldItem = aItem;</span>
<a href="#l18.382"></a><span id="l18.382">       // we want to create a clone of the existing item so that we can know the</span>
<a href="#l18.383"></a><span id="l18.383">       //  deltas that happened for indexing purposes</span>
<a href="#l18.384"></a><span id="l18.384">       aItem = aItem._clone();</span>
<a href="#l18.385"></a><span id="l18.385">     }</span>
<a href="#l18.386"></a><span id="l18.386"> </span>
<a href="#l18.387"></a><span id="l18.387">     // Have the attribute providers directly set properties on the aItem</span>
<a href="#l18.388"></a><span id="l18.388" class="difflineminus">-    let attrProviders = this._attrProviderOrderByNoun[aItem.NOUN_ID];</span>
<a href="#l18.389"></a><span id="l18.389" class="difflineplus">+    let attrProviders = this._attrProviderOrderByNoun[itemNounDef.id];</span>
<a href="#l18.390"></a><span id="l18.390">     for (let iProvider = 0; iProvider &lt; attrProviders.length; iProvider++) {</span>
<a href="#l18.391"></a><span id="l18.391">       this._log.info(&quot;  * provider: &quot; + attrProviders[iProvider].providerName);</span>
<a href="#l18.392"></a><span id="l18.392">       yield aCallbackHandle.pushAndGo(</span>
<a href="#l18.393"></a><span id="l18.393">         attrProviders[iProvider].process(aItem, aRawReps, aIsConceptuallyNew,</span>
<a href="#l18.394"></a><span id="l18.394">                                          aCallbackHandle));</span>
<a href="#l18.395"></a><span id="l18.395">     }</span>
<a href="#l18.396"></a><span id="l18.396"> </span>
<a href="#l18.397"></a><span id="l18.397" class="difflineminus">-    let attrOptimizers = this._attrOptimizerOrderByNoun[aItem.NOUN_ID];</span>
<a href="#l18.398"></a><span id="l18.398" class="difflineplus">+    let attrOptimizers = this._attrOptimizerOrderByNoun[itemNounDef.id];</span>
<a href="#l18.399"></a><span id="l18.399">     for (let iProvider = 0; iProvider &lt; attrOptimizers.length; iProvider++) {</span>
<a href="#l18.400"></a><span id="l18.400">       this._log.info(&quot;  * optimizer: &quot; + attrOptimizers[iProvider].providerName);</span>
<a href="#l18.401"></a><span id="l18.401">       yield aCallbackHandle.pushAndGo(</span>
<a href="#l18.402"></a><span id="l18.402">         attrOptimizers[iProvider].optimize(aItem, aRawReps, aIsConceptuallyNew,</span>
<a href="#l18.403"></a><span id="l18.403">                                            aCallbackHandle));</span>
<a href="#l18.404"></a><span id="l18.404">     }</span>
<a href="#l18.405"></a><span id="l18.405"> </span>
<a href="#l18.406"></a><span id="l18.406">     this._log.info(&quot; ** done with providers.&quot;);</span>
<a href="#l18.407"></a><span id="l18.407" class="difflineat">@@ -1715,16 +1732,50 @@ var Gloda = {</span>
<a href="#l18.408"></a><span id="l18.408">       else</span>
<a href="#l18.409"></a><span id="l18.409">         GlodaCollectionManager.itemsModified(aOldItem.NOUN_ID, [aOldItem]);</span>
<a href="#l18.410"></a><span id="l18.410">     }</span>
<a href="#l18.411"></a><span id="l18.411"> </span>
<a href="#l18.412"></a><span id="l18.412">     this._log.debug(&quot; done grokking.&quot;);</span>
<a href="#l18.413"></a><span id="l18.413"> </span>
<a href="#l18.414"></a><span id="l18.414">     yield this.kWorkDone;</span>
<a href="#l18.415"></a><span id="l18.415">   },</span>
<a href="#l18.416"></a><span id="l18.416" class="difflineplus">+</span>
<a href="#l18.417"></a><span id="l18.417" class="difflineplus">+  /**</span>
<a href="#l18.418"></a><span id="l18.418" class="difflineplus">+   * Processes a list of noun instances for their score within a given context.</span>
<a href="#l18.419"></a><span id="l18.419" class="difflineplus">+   *  This is primarily intended for use by search ranking mechanisms, but could</span>
<a href="#l18.420"></a><span id="l18.420" class="difflineplus">+   *  be used elsewhere too.  (It does, however, depend on the complicity of the</span>
<a href="#l18.421"></a><span id="l18.421" class="difflineplus">+   *  score method implementations to not get confused.)</span>
<a href="#l18.422"></a><span id="l18.422" class="difflineplus">+   *</span>
<a href="#l18.423"></a><span id="l18.423" class="difflineplus">+   * @param aItems The non-empty list of items to score.</span>
<a href="#l18.424"></a><span id="l18.424" class="difflineplus">+   * @param aContext A noun-specific dictionary that we just pass to the funcs.</span>
<a href="#l18.425"></a><span id="l18.425" class="difflineplus">+   * @param aExtraScoreFuncs A list of extra scoring functions to apply.</span>
<a href="#l18.426"></a><span id="l18.426" class="difflineplus">+   * @returns A list of integer scores equal in length to aItems.</span>
<a href="#l18.427"></a><span id="l18.427" class="difflineplus">+   */</span>
<a href="#l18.428"></a><span id="l18.428" class="difflineplus">+  scoreNounItems: function gloda_ns_grokNounItem(aItems, aContext,</span>
<a href="#l18.429"></a><span id="l18.429" class="difflineplus">+                                                 aExtraScoreFuncs) {</span>
<a href="#l18.430"></a><span id="l18.430" class="difflineplus">+    let itemNounDef = aItems[0].NOUN_DEF;</span>
<a href="#l18.431"></a><span id="l18.431" class="difflineplus">+    let scores = [];</span>
<a href="#l18.432"></a><span id="l18.432" class="difflineplus">+    if (aExtraScoreFuncs == null)</span>
<a href="#l18.433"></a><span id="l18.433" class="difflineplus">+      aExtraScoreFuncs = [];</span>
<a href="#l18.434"></a><span id="l18.434" class="difflineplus">+</span>
<a href="#l18.435"></a><span id="l18.435" class="difflineplus">+    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l18.436"></a><span id="l18.436" class="difflineplus">+      let score = 0;</span>
<a href="#l18.437"></a><span id="l18.437" class="difflineplus">+      let attrProviders = this._attrProviderOrderByNoun[itemNounDef.id];</span>
<a href="#l18.438"></a><span id="l18.438" class="difflineplus">+      for (let iProvider = 0; iProvider &lt; attrProviders.length; iProvider++) {</span>
<a href="#l18.439"></a><span id="l18.439" class="difflineplus">+        let provider = attrProviders[iProvider];</span>
<a href="#l18.440"></a><span id="l18.440" class="difflineplus">+        if (provider.score)</span>
<a href="#l18.441"></a><span id="l18.441" class="difflineplus">+          score += provider.score(item);</span>
<a href="#l18.442"></a><span id="l18.442" class="difflineplus">+      }</span>
<a href="#l18.443"></a><span id="l18.443" class="difflineplus">+      for (let [, extraScoreFunc] in Iterator(aExtraScoreFuncs))</span>
<a href="#l18.444"></a><span id="l18.444" class="difflineplus">+        score += extraScoreFunc(item, aContext);</span>
<a href="#l18.445"></a><span id="l18.445" class="difflineplus">+      scores.push(score);</span>
<a href="#l18.446"></a><span id="l18.446" class="difflineplus">+    }</span>
<a href="#l18.447"></a><span id="l18.447" class="difflineplus">+</span>
<a href="#l18.448"></a><span id="l18.448" class="difflineplus">+    return scores;</span>
<a href="#l18.449"></a><span id="l18.449" class="difflineplus">+  }</span>
<a href="#l18.450"></a><span id="l18.450"> };</span>
<a href="#l18.451"></a><span id="l18.451"> </span>
<a href="#l18.452"></a><span id="l18.452"> /* and initialize the Gloda object/NS before we return... */</span>
<a href="#l18.453"></a><span id="l18.453"> try {</span>
<a href="#l18.454"></a><span id="l18.454">   Gloda._init();</span>
<a href="#l18.455"></a><span id="l18.455"> }</span>
<a href="#l18.456"></a><span id="l18.456"> catch (ex) {</span>
<a href="#l18.457"></a><span id="l18.457">   Gloda._log.debug(&quot;Exception during Gloda init (&quot; + ex.fileName + &quot;:&quot; +</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -1,16 +1,16 @@</span>
<a href="#l19.4"></a><span id="l19.4"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l19.5"></a><span id="l19.5">  *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l19.6"></a><span id="l19.6">  *</span>
<a href="#l19.7"></a><span id="l19.7">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l19.8"></a><span id="l19.8">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l19.9"></a><span id="l19.9">  * the License. You may obtain a copy of the License at</span>
<a href="#l19.10"></a><span id="l19.10">  * http://www.mozilla.org/MPL/</span>
<a href="#l19.11"></a><span id="l19.11" class="difflineminus">- * </span>
<a href="#l19.12"></a><span id="l19.12" class="difflineplus">+ *</span>
<a href="#l19.13"></a><span id="l19.13">  * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l19.14"></a><span id="l19.14">  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l19.15"></a><span id="l19.15">  * for the specific language governing rights and limitations under the</span>
<a href="#l19.16"></a><span id="l19.16">  * License.</span>
<a href="#l19.17"></a><span id="l19.17">  *</span>
<a href="#l19.18"></a><span id="l19.18">  * The Original Code is Thunderbird Global Database.</span>
<a href="#l19.19"></a><span id="l19.19">  *</span>
<a href="#l19.20"></a><span id="l19.20">  * The Initial Developer of the Original Code is</span>
<a href="#l19.21"></a><span id="l19.21" class="difflineat">@@ -27,17 +27,17 @@</span>
<a href="#l19.22"></a><span id="l19.22">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l19.23"></a><span id="l19.23">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l19.24"></a><span id="l19.24">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l19.25"></a><span id="l19.25">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l19.26"></a><span id="l19.26">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l19.27"></a><span id="l19.27">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l19.28"></a><span id="l19.28">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l19.29"></a><span id="l19.29">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l19.30"></a><span id="l19.30" class="difflineminus">- * </span>
<a href="#l19.31"></a><span id="l19.31" class="difflineplus">+ *</span>
<a href="#l19.32"></a><span id="l19.32">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l19.33"></a><span id="l19.33"> </span>
<a href="#l19.34"></a><span id="l19.34"> /*</span>
<a href="#l19.35"></a><span id="l19.35">  * This file currently contains a fairly general implementation of asynchronous</span>
<a href="#l19.36"></a><span id="l19.36">  *  indexing with a very explicit message indexing implementation.  As gloda</span>
<a href="#l19.37"></a><span id="l19.37">  *  will eventually want to index more than just messages, the message-specific</span>
<a href="#l19.38"></a><span id="l19.38">  *  things should ideally lose their special hold on this file.  This will</span>
<a href="#l19.39"></a><span id="l19.39">  *  benefit readability/size as well.</span>
<a href="#l19.40"></a><span id="l19.40" class="difflineat">@@ -105,17 +105,17 @@ function fixIterator(aEnum, aIface) {</span>
<a href="#l19.41"></a><span id="l19.41">     aEnum.QueryInterface(Ci.nsISupportsArray);</span>
<a href="#l19.42"></a><span id="l19.42">     let iter = function() {</span>
<a href="#l19.43"></a><span id="l19.43">       let count = aEnum.Count();</span>
<a href="#l19.44"></a><span id="l19.44">       for (let i = 0; i &lt; count; i++)</span>
<a href="#l19.45"></a><span id="l19.45">         yield aEnum.GetElementAt(i).QueryInterface(face);</span>
<a href="#l19.46"></a><span id="l19.46">     }</span>
<a href="#l19.47"></a><span id="l19.47">     return { __iterator__: iter };</span>
<a href="#l19.48"></a><span id="l19.48">   } catch(ex) {}</span>
<a href="#l19.49"></a><span id="l19.49" class="difflineminus">-  </span>
<a href="#l19.50"></a><span id="l19.50" class="difflineplus">+</span>
<a href="#l19.51"></a><span id="l19.51">   // Now try nsIEnumerator</span>
<a href="#l19.52"></a><span id="l19.52">   try {</span>
<a href="#l19.53"></a><span id="l19.53">     aEnum.QueryInterface(Ci.nsIEnumerator);</span>
<a href="#l19.54"></a><span id="l19.54">     let done = false;</span>
<a href="#l19.55"></a><span id="l19.55">     let iter = function() {</span>
<a href="#l19.56"></a><span id="l19.56">       while (!done) {</span>
<a href="#l19.57"></a><span id="l19.57">         try {</span>
<a href="#l19.58"></a><span id="l19.58">           //rets.push(aEnum.currentItem().QueryInterface(face));</span>
<a href="#l19.59"></a><span id="l19.59" class="difflineat">@@ -125,17 +125,17 @@ function fixIterator(aEnum, aIface) {</span>
<a href="#l19.60"></a><span id="l19.60">           done = true;</span>
<a href="#l19.61"></a><span id="l19.61">           GFI.error(face + &quot; =&gt; &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex)</span>
<a href="#l19.62"></a><span id="l19.62">         }</span>
<a href="#l19.63"></a><span id="l19.63">       }</span>
<a href="#l19.64"></a><span id="l19.64">     };</span>
<a href="#l19.65"></a><span id="l19.65"> </span>
<a href="#l19.66"></a><span id="l19.66">     return { __iterator__: iter };</span>
<a href="#l19.67"></a><span id="l19.67">   } catch(ex) {}</span>
<a href="#l19.68"></a><span id="l19.68" class="difflineminus">-  </span>
<a href="#l19.69"></a><span id="l19.69" class="difflineplus">+</span>
<a href="#l19.70"></a><span id="l19.70">   // how about nsISimpleEnumerator? this one is nice and simple</span>
<a href="#l19.71"></a><span id="l19.71">   try {</span>
<a href="#l19.72"></a><span id="l19.72">     aEnum.QueryInterface(Ci.nsISimpleEnumerator);</span>
<a href="#l19.73"></a><span id="l19.73">     let iter = function () {</span>
<a href="#l19.74"></a><span id="l19.74">       while (aEnum.hasMoreElements())</span>
<a href="#l19.75"></a><span id="l19.75">         yield aEnum.getNext().QueryInterface(face);</span>
<a href="#l19.76"></a><span id="l19.76">     }</span>
<a href="#l19.77"></a><span id="l19.77">     return { __iterator__: iter };</span>
<a href="#l19.78"></a><span id="l19.78" class="difflineat">@@ -182,21 +182,21 @@ function MakeCleanMsgHdrCallback(aMsgHdr</span>
<a href="#l19.79"></a><span id="l19.79">  *     decrease.  This is used by the status notification code in conjunction</span>
<a href="#l19.80"></a><span id="l19.80">  *     with the goal.</span>
<a href="#l19.81"></a><span id="l19.81">  * @ivar recoverable Integer indicating if this job is recoverable, and how</span>
<a href="#l19.82"></a><span id="l19.82">  *     many failures we should allow for before we give up.  By default, this is</span>
<a href="#l19.83"></a><span id="l19.83">  *     set to 10, but your job should choose a more appopriate number itself.</span>
<a href="#l19.84"></a><span id="l19.84">  *</span>
<a href="#l19.85"></a><span id="l19.85">  * @constructor</span>
<a href="#l19.86"></a><span id="l19.86">  */</span>
<a href="#l19.87"></a><span id="l19.87" class="difflineminus">-function IndexingJob(aJobType, aDeltaType, aID) {</span>
<a href="#l19.88"></a><span id="l19.88" class="difflineplus">+function IndexingJob(aJobType, aDeltaType, aID, aItems) {</span>
<a href="#l19.89"></a><span id="l19.89">   this.jobType = aJobType;</span>
<a href="#l19.90"></a><span id="l19.90">   this.deltaType = aDeltaType;</span>
<a href="#l19.91"></a><span id="l19.91">   this.id = aID;</span>
<a href="#l19.92"></a><span id="l19.92" class="difflineminus">-  this.items = [];</span>
<a href="#l19.93"></a><span id="l19.93" class="difflineplus">+  this.items = (aItems != null) ? aItems : [];</span>
<a href="#l19.94"></a><span id="l19.94">   this.offset = 0;</span>
<a href="#l19.95"></a><span id="l19.95">   this.goal = null;</span>
<a href="#l19.96"></a><span id="l19.96">   this.recoverable = 10;</span>
<a href="#l19.97"></a><span id="l19.97"> }</span>
<a href="#l19.98"></a><span id="l19.98"> </span>
<a href="#l19.99"></a><span id="l19.99"> /**</span>
<a href="#l19.100"></a><span id="l19.100">  * @namespace Core indexing logic, plus message-specific indexing logic.</span>
<a href="#l19.101"></a><span id="l19.101">  *</span>
<a href="#l19.102"></a><span id="l19.102" class="difflineat">@@ -208,17 +208,17 @@ function IndexingJob(aJobType, aDeltaTyp</span>
<a href="#l19.103"></a><span id="l19.103">  *   fasion.</span>
<a href="#l19.104"></a><span id="l19.104">  * - We should not interfere with the user's thunderbird usage.</span>
<a href="#l19.105"></a><span id="l19.105">  *</span>
<a href="#l19.106"></a><span id="l19.106">  * Correctness</span>
<a href="#l19.107"></a><span id="l19.107">  * - Quitting should not result in any information loss; we should (eventually)</span>
<a href="#l19.108"></a><span id="l19.108">  *   end up at the same indexed state regardless of whether a user lets</span>
<a href="#l19.109"></a><span id="l19.109">  *   indexing run to completion or restarts thunderbird in the middle of the</span>
<a href="#l19.110"></a><span id="l19.110">  *   process.  (It is okay to take slightly longer in the latter case.)</span>
<a href="#l19.111"></a><span id="l19.111" class="difflineminus">- * </span>
<a href="#l19.112"></a><span id="l19.112" class="difflineplus">+ *</span>
<a href="#l19.113"></a><span id="l19.113">  * Worst Case Scenario Avoidance</span>
<a href="#l19.114"></a><span id="l19.114">  * - We should try to be O(1) memory-wise regardless of what notifications</span>
<a href="#l19.115"></a><span id="l19.115">  *   are thrown at us.</span>
<a href="#l19.116"></a><span id="l19.116">  *</span>
<a href="#l19.117"></a><span id="l19.117">  * === Indexing Strategy</span>
<a href="#l19.118"></a><span id="l19.118">  * To these ends, we implement things like so:</span>
<a href="#l19.119"></a><span id="l19.119">  *</span>
<a href="#l19.120"></a><span id="l19.120">  * Mesage State Tracking</span>
<a href="#l19.121"></a><span id="l19.121" class="difflineat">@@ -246,38 +246,38 @@ function IndexingJob(aJobType, aDeltaTyp</span>
<a href="#l19.122"></a><span id="l19.122">  *   or are dirty.</span>
<a href="#l19.123"></a><span id="l19.123">  * - For local folders, we use GetDatabaseWithReparse to ensure that the .msf</span>
<a href="#l19.124"></a><span id="l19.124">  *   file exists.  For IMAP folders, we simply use GetDatabase because we know</span>
<a href="#l19.125"></a><span id="l19.125">  *   the auto-sync logic will make sure that the folder is up-to-date and we</span>
<a href="#l19.126"></a><span id="l19.126">  *   want to avoid creating problems through use of updateFolder.</span>
<a href="#l19.127"></a><span id="l19.127">  *</span>
<a href="#l19.128"></a><span id="l19.128">  * Indexing Throttling</span>
<a href="#l19.129"></a><span id="l19.129">  * - Unless we believe everything is up-to-date, then we are always indexing.</span>
<a href="#l19.130"></a><span id="l19.130" class="difflineminus">- *   We must be able to process messages </span>
<a href="#l19.131"></a><span id="l19.131" class="difflineplus">+ *   We must be able to process messages</span>
<a href="#l19.132"></a><span id="l19.132">  *</span>
<a href="#l19.133"></a><span id="l19.133">  *</span>
<a href="#l19.134"></a><span id="l19.134">  * === Message Indexing</span>
<a href="#l19.135"></a><span id="l19.135" class="difflineminus">- * </span>
<a href="#l19.136"></a><span id="l19.136" class="difflineplus">+ *</span>
<a href="#l19.137"></a><span id="l19.137">  * We are good at listening to nsIMsgFolderListener events.  Unfortunately,</span>
<a href="#l19.138"></a><span id="l19.138">  *  MailNews isn't pervasively thorough at generating these yet (newsgroups</span>
<a href="#l19.139"></a><span id="l19.139">  *  don't produce them, probably not RSS either.)  This provides us with</span>
<a href="#l19.140"></a><span id="l19.140">  *  message addition, moves/copies, and deletion.</span>
<a href="#l19.141"></a><span id="l19.141">  * We are not good at listening to nsIFolderListener events.  This means we fail</span>
<a href="#l19.142"></a><span id="l19.142">  *  to update ourselves when a message is changed because of a change in tags,</span>
<a href="#l19.143"></a><span id="l19.143">  *  read status/starred status/etc.  (Well, in fairness, events aren't actually</span>
<a href="#l19.144"></a><span id="l19.144">  *  generated in all of those cases either, yet, but we should try.)  We need</span>
<a href="#l19.145"></a><span id="l19.145">  *  to handle this.</span>
<a href="#l19.146"></a><span id="l19.146">  *</span>
<a href="#l19.147"></a><span id="l19.147">  * Currently, when we index a message, when it comes to attributes, we ignore</span>
<a href="#l19.148"></a><span id="l19.148">  *  all that has come before us and simply blow away the attributes and apply</span>
<a href="#l19.149"></a><span id="l19.149">  *  those provided by the attribute providers anew.  This is not particularly</span>
<a href="#l19.150"></a><span id="l19.150">  *  efficient for anyone.  Also, I think we probably screw this up now that we</span>
<a href="#l19.151"></a><span id="l19.151">  *  have object identity support.  Uh, so, this should be improved, but</span>
<a href="#l19.152"></a><span id="l19.152">  *  certainly works.</span>
<a href="#l19.153"></a><span id="l19.153" class="difflineminus">- * </span>
<a href="#l19.154"></a><span id="l19.154" class="difflineplus">+ *</span>
<a href="#l19.155"></a><span id="l19.155">  */</span>
<a href="#l19.156"></a><span id="l19.156"> var GlodaIndexer = {</span>
<a href="#l19.157"></a><span id="l19.157">   /**</span>
<a href="#l19.158"></a><span id="l19.158">    * A partial attempt to generalize to support multiple databases.  Each</span>
<a href="#l19.159"></a><span id="l19.159">    *  database would have its own datastore would have its own indexer.  But</span>
<a href="#l19.160"></a><span id="l19.160">    *  we rather inter-mingle our use of this field with the singleton global</span>
<a href="#l19.161"></a><span id="l19.161">    *  GlodaDatastore.</span>
<a href="#l19.162"></a><span id="l19.162">    */</span>
<a href="#l19.163"></a><span id="l19.163" class="difflineat">@@ -286,17 +286,17 @@ var GlodaIndexer = {</span>
<a href="#l19.164"></a><span id="l19.164">   /**</span>
<a href="#l19.165"></a><span id="l19.165">    * Our nsITimer that we use to schedule ourselves on the main thread</span>
<a href="#l19.166"></a><span id="l19.166">    *  intermittently.  The timer always exists but may not always be active.</span>
<a href="#l19.167"></a><span id="l19.167">    */</span>
<a href="#l19.168"></a><span id="l19.168">   _timer: null,</span>
<a href="#l19.169"></a><span id="l19.169">   /**</span>
<a href="#l19.170"></a><span id="l19.170">    * Our nsITimer that we use to schedule events in the &quot;far&quot; future.  For now,</span>
<a href="#l19.171"></a><span id="l19.171">    *  this means not compelling an initial indexing sweep until some number of</span>
<a href="#l19.172"></a><span id="l19.172" class="difflineminus">-   *  seconds after startup. </span>
<a href="#l19.173"></a><span id="l19.173" class="difflineplus">+   *  seconds after startup.</span>
<a href="#l19.174"></a><span id="l19.174">    */</span>
<a href="#l19.175"></a><span id="l19.175">   _longTimer: null,</span>
<a href="#l19.176"></a><span id="l19.176">   /**</span>
<a href="#l19.177"></a><span id="l19.177">    * Our performance stopwatch that helps us adapt our indexing constants so</span>
<a href="#l19.178"></a><span id="l19.178">    *  as to not explode your computer.  Kind of us, no?</span>
<a href="#l19.179"></a><span id="l19.179">    */</span>
<a href="#l19.180"></a><span id="l19.180">   _perfStopwatch: null,</span>
<a href="#l19.181"></a><span id="l19.181">   /**</span>
<a href="#l19.182"></a><span id="l19.182" class="difflineat">@@ -306,30 +306,30 @@ var GlodaIndexer = {</span>
<a href="#l19.183"></a><span id="l19.183"> </span>
<a href="#l19.184"></a><span id="l19.184">   _inited: false,</span>
<a href="#l19.185"></a><span id="l19.185">   /**</span>
<a href="#l19.186"></a><span id="l19.186">    * Initialize the indexer.</span>
<a href="#l19.187"></a><span id="l19.187">    */</span>
<a href="#l19.188"></a><span id="l19.188">   _init: function gloda_index_init() {</span>
<a href="#l19.189"></a><span id="l19.189">     if (this._inited)</span>
<a href="#l19.190"></a><span id="l19.190">       return;</span>
<a href="#l19.191"></a><span id="l19.191" class="difflineminus">-    </span>
<a href="#l19.192"></a><span id="l19.192" class="difflineplus">+</span>
<a href="#l19.193"></a><span id="l19.193">     this._inited = true;</span>
<a href="#l19.194"></a><span id="l19.194" class="difflineminus">-    </span>
<a href="#l19.195"></a><span id="l19.195" class="difflineplus">+</span>
<a href="#l19.196"></a><span id="l19.196">     // initialize our listeners' this pointers</span>
<a href="#l19.197"></a><span id="l19.197">     this._databaseAnnouncerListener.indexer = this;</span>
<a href="#l19.198"></a><span id="l19.198">     this._msgFolderListener.indexer = this;</span>
<a href="#l19.199"></a><span id="l19.199" class="difflineminus">-    </span>
<a href="#l19.200"></a><span id="l19.200" class="difflineplus">+</span>
<a href="#l19.201"></a><span id="l19.201">     this._callbackHandle.init();</span>
<a href="#l19.202"></a><span id="l19.202" class="difflineminus">-    </span>
<a href="#l19.203"></a><span id="l19.203" class="difflineplus">+</span>
<a href="#l19.204"></a><span id="l19.204">     // create the timer that drives our intermittent indexing</span>
<a href="#l19.205"></a><span id="l19.205">     this._timer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l19.206"></a><span id="l19.206">     // create the timer for larger offsets independent of indexing</span>
<a href="#l19.207"></a><span id="l19.207">     this._longTimer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l19.208"></a><span id="l19.208" class="difflineminus">-    </span>
<a href="#l19.209"></a><span id="l19.209" class="difflineplus">+</span>
<a href="#l19.210"></a><span id="l19.210">     // create our performance stopwatch and timer</span>
<a href="#l19.211"></a><span id="l19.211">     try {</span>
<a href="#l19.212"></a><span id="l19.212">     this._perfStopwatch = Cc[&quot;@mozilla.org/stopwatch;1&quot;]</span>
<a href="#l19.213"></a><span id="l19.213">                             .createInstance(Ci.nsIStopwatch);</span>
<a href="#l19.214"></a><span id="l19.214">     } catch (ex) {</span>
<a href="#l19.215"></a><span id="l19.215">       this._log.error(&quot;problem creating stopwatch!: &quot; + ex);</span>
<a href="#l19.216"></a><span id="l19.216">     }</span>
<a href="#l19.217"></a><span id="l19.217">     this._perfTimer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l19.218"></a><span id="l19.218" class="difflineat">@@ -350,92 +350,92 @@ var GlodaIndexer = {</span>
<a href="#l19.219"></a><span id="l19.219">       performInitialSweep = branch.getBoolPref(&quot;perform_initial_sweep&quot;);</span>
<a href="#l19.220"></a><span id="l19.220">     } catch (ex) {}</span>
<a href="#l19.221"></a><span id="l19.221">     // pretend we have already performed an initial sweep...</span>
<a href="#l19.222"></a><span id="l19.222">     if (!performInitialSweep)</span>
<a href="#l19.223"></a><span id="l19.223">       this._initialSweepPerformed = true;</span>
<a href="#l19.224"></a><span id="l19.224"> </span>
<a href="#l19.225"></a><span id="l19.225">     this.enabled = eventDrivenEnabled;</span>
<a href="#l19.226"></a><span id="l19.226">   },</span>
<a href="#l19.227"></a><span id="l19.227" class="difflineminus">-  </span>
<a href="#l19.228"></a><span id="l19.228" class="difflineplus">+</span>
<a href="#l19.229"></a><span id="l19.229">   /**</span>
<a href="#l19.230"></a><span id="l19.230">    * When shutdown, indexing immediately ceases and no further progress should</span>
<a href="#l19.231"></a><span id="l19.231">    *  be made.  This flag goes true once, and never returns to false.  Being</span>
<a href="#l19.232"></a><span id="l19.232">    *  in this state is a destructive thing from whence we cannot recover.</span>
<a href="#l19.233"></a><span id="l19.233">    */</span>
<a href="#l19.234"></a><span id="l19.234">   _indexerIsShutdown: false,</span>
<a href="#l19.235"></a><span id="l19.235" class="difflineminus">-  </span>
<a href="#l19.236"></a><span id="l19.236" class="difflineplus">+</span>
<a href="#l19.237"></a><span id="l19.237">   /**</span>
<a href="#l19.238"></a><span id="l19.238">    * Shutdown the indexing process and datastore as quickly as possible in</span>
<a href="#l19.239"></a><span id="l19.239">    *  a synchronous fashion.</span>
<a href="#l19.240"></a><span id="l19.240" class="difflineminus">-   * </span>
<a href="#l19.241"></a><span id="l19.241" class="difflineplus">+   *</span>
<a href="#l19.242"></a><span id="l19.242">    * @returns true on full and immediate shutdown, false if we need to pend on</span>
<a href="#l19.243"></a><span id="l19.243">    *     something asynchronous.</span>
<a href="#l19.244"></a><span id="l19.244">    */</span>
<a href="#l19.245"></a><span id="l19.245">   _shutdown: function gloda_index_shutdown() {</span>
<a href="#l19.246"></a><span id="l19.246">     // no more timer events, please</span>
<a href="#l19.247"></a><span id="l19.247">     try {</span>
<a href="#l19.248"></a><span id="l19.248">       this._timer.cancel();</span>
<a href="#l19.249"></a><span id="l19.249">     } catch (ex) {}</span>
<a href="#l19.250"></a><span id="l19.250">     this._timer = null;</span>
<a href="#l19.251"></a><span id="l19.251">     try {</span>
<a href="#l19.252"></a><span id="l19.252">       this._longTimer.cancel();</span>
<a href="#l19.253"></a><span id="l19.253">     } catch (ex) {}</span>
<a href="#l19.254"></a><span id="l19.254">     this._longTimer = null;</span>
<a href="#l19.255"></a><span id="l19.255" class="difflineminus">-    </span>
<a href="#l19.256"></a><span id="l19.256" class="difflineplus">+</span>
<a href="#l19.257"></a><span id="l19.257">     this._perfStopwatch = null;</span>
<a href="#l19.258"></a><span id="l19.258">     try {</span>
<a href="#l19.259"></a><span id="l19.259">       this._perfTimer.cancel();</span>
<a href="#l19.260"></a><span id="l19.260">     } catch (ex) {}</span>
<a href="#l19.261"></a><span id="l19.261">     this._perfTimer = null;</span>
<a href="#l19.262"></a><span id="l19.262"> </span>
<a href="#l19.263"></a><span id="l19.263">     // Remove listeners to avoid reference cycles on the off chance one of them</span>
<a href="#l19.264"></a><span id="l19.264">     // holds a reference to the indexer object.</span>
<a href="#l19.265"></a><span id="l19.265">     this._indexListeners = [];</span>
<a href="#l19.266"></a><span id="l19.266" class="difflineminus">-    </span>
<a href="#l19.267"></a><span id="l19.267" class="difflineplus">+</span>
<a href="#l19.268"></a><span id="l19.268">     this._indexerIsShutdown = true;</span>
<a href="#l19.269"></a><span id="l19.269" class="difflineminus">-    </span>
<a href="#l19.270"></a><span id="l19.270" class="difflineplus">+</span>
<a href="#l19.271"></a><span id="l19.271">     if (!this.enabled)</span>
<a href="#l19.272"></a><span id="l19.272">       return true;</span>
<a href="#l19.273"></a><span id="l19.273" class="difflineminus">-    </span>
<a href="#l19.274"></a><span id="l19.274" class="difflineplus">+</span>
<a href="#l19.275"></a><span id="l19.275">     this._log.info(&quot;Shutting Down&quot;);</span>
<a href="#l19.276"></a><span id="l19.276"> </span>
<a href="#l19.277"></a><span id="l19.277">     this.suppressIndexing = true;</span>
<a href="#l19.278"></a><span id="l19.278">     this._indexerLeaveFolder(); // nop if we aren't &quot;in&quot; a folder</span>
<a href="#l19.279"></a><span id="l19.279">     this._callbackHandle.cleanup();</span>
<a href="#l19.280"></a><span id="l19.280">     this._workBatchData = undefined;</span>
<a href="#l19.281"></a><span id="l19.281">     this.enabled = false;</span>
<a href="#l19.282"></a><span id="l19.282"> </span>
<a href="#l19.283"></a><span id="l19.283">     GlodaDatastore.shutdown();</span>
<a href="#l19.284"></a><span id="l19.284">   },</span>
<a href="#l19.285"></a><span id="l19.285" class="difflineminus">-  </span>
<a href="#l19.286"></a><span id="l19.286" class="difflineplus">+</span>
<a href="#l19.287"></a><span id="l19.287">   _otherIndexers: [],</span>
<a href="#l19.288"></a><span id="l19.288">   registerIndexer: function gloda_index_registerIndexer(aIndexer) {</span>
<a href="#l19.289"></a><span id="l19.289">     this._log.info(&quot;Registering indexer: &quot; + aIndexer.name);</span>
<a href="#l19.290"></a><span id="l19.290">     this._otherIndexers.push(aIndexer);</span>
<a href="#l19.291"></a><span id="l19.291" class="difflineminus">-    </span>
<a href="#l19.292"></a><span id="l19.292" class="difflineplus">+</span>
<a href="#l19.293"></a><span id="l19.293">     try {</span>
<a href="#l19.294"></a><span id="l19.294">       for each (let [iWorker, workerInfo] in Iterator(aIndexer.workers)) {</span>
<a href="#l19.295"></a><span id="l19.295">         let [workerCode, workerFunc] = workerInfo;</span>
<a href="#l19.296"></a><span id="l19.296">         this._otherIndexerWorkers[workerCode] = [aIndexer, workerFunc];</span>
<a href="#l19.297"></a><span id="l19.297">       }</span>
<a href="#l19.298"></a><span id="l19.298">     }</span>
<a href="#l19.299"></a><span id="l19.299">     catch (ex) {</span>
<a href="#l19.300"></a><span id="l19.300" class="difflineminus">-      this._log.warning(&quot;Helper indexer threw exception on worker enum.&quot;);</span>
<a href="#l19.301"></a><span id="l19.301" class="difflineplus">+      this._log.warn(&quot;Helper indexer threw exception on worker enum.&quot;);</span>
<a href="#l19.302"></a><span id="l19.302">     }</span>
<a href="#l19.303"></a><span id="l19.303" class="difflineminus">-    </span>
<a href="#l19.304"></a><span id="l19.304" class="difflineplus">+</span>
<a href="#l19.305"></a><span id="l19.305">     if (this._enabled) {</span>
<a href="#l19.306"></a><span id="l19.306">       try {</span>
<a href="#l19.307"></a><span id="l19.307">         aIndexer.enable();</span>
<a href="#l19.308"></a><span id="l19.308">       } catch (ex) {</span>
<a href="#l19.309"></a><span id="l19.309" class="difflineminus">-        this._log.warning(&quot;Helper indexer threw exception on enable: &quot; + ex);</span>
<a href="#l19.310"></a><span id="l19.310" class="difflineplus">+        this._log.warn(&quot;Helper indexer threw exception on enable: &quot; + ex);</span>
<a href="#l19.311"></a><span id="l19.311">       }</span>
<a href="#l19.312"></a><span id="l19.312">     }</span>
<a href="#l19.313"></a><span id="l19.313">   },</span>
<a href="#l19.314"></a><span id="l19.314" class="difflineminus">-  </span>
<a href="#l19.315"></a><span id="l19.315" class="difflineplus">+</span>
<a href="#l19.316"></a><span id="l19.316">   /**</span>
<a href="#l19.317"></a><span id="l19.317">    * Are we enabled, read: are we processing change events?</span>
<a href="#l19.318"></a><span id="l19.318">    */</span>
<a href="#l19.319"></a><span id="l19.319">   _enabled: false,</span>
<a href="#l19.320"></a><span id="l19.320">   get enabled() { return this._enabled; },</span>
<a href="#l19.321"></a><span id="l19.321">   set enabled(aEnable) {</span>
<a href="#l19.322"></a><span id="l19.322">     if (!this._enabled &amp;&amp; aEnable) {</span>
<a href="#l19.323"></a><span id="l19.323">       // register for:</span>
<a href="#l19.324"></a><span id="l19.324" class="difflineat">@@ -444,89 +444,89 @@ var GlodaIndexer = {</span>
<a href="#l19.325"></a><span id="l19.325">       // - property changes (so we know when a message's read/starred state have</span>
<a href="#l19.326"></a><span id="l19.326">       //   changed.)</span>
<a href="#l19.327"></a><span id="l19.327">       let mailSession = Cc[&quot;@mozilla.org/messenger/services/session;1&quot;].</span>
<a href="#l19.328"></a><span id="l19.328">                           getService(Ci.nsIMsgMailSession);</span>
<a href="#l19.329"></a><span id="l19.329">       this._folderListener._init(this);</span>
<a href="#l19.330"></a><span id="l19.330">       mailSession.AddFolderListener(this._folderListener,</span>
<a href="#l19.331"></a><span id="l19.331">                                     Ci.nsIFolderListener.propertyFlagChanged |</span>
<a href="#l19.332"></a><span id="l19.332">                                     Ci.nsIFolderListener.event);</span>
<a href="#l19.333"></a><span id="l19.333" class="difflineminus">-  </span>
<a href="#l19.334"></a><span id="l19.334" class="difflineplus">+</span>
<a href="#l19.335"></a><span id="l19.335">       // register for shutdown, offline notifications</span>
<a href="#l19.336"></a><span id="l19.336">       let observerService = Cc[&quot;@mozilla.org/observer-service;1&quot;].</span>
<a href="#l19.337"></a><span id="l19.337">                               getService(Ci.nsIObserverService);</span>
<a href="#l19.338"></a><span id="l19.338">       observerService.addObserver(this, &quot;network:offline-status-changed&quot;, false);</span>
<a href="#l19.339"></a><span id="l19.339">       observerService.addObserver(this, &quot;quit-application&quot;, false);</span>
<a href="#l19.340"></a><span id="l19.340" class="difflineminus">-  </span>
<a href="#l19.341"></a><span id="l19.341" class="difflineplus">+</span>
<a href="#l19.342"></a><span id="l19.342">       // register for idle notification</span>
<a href="#l19.343"></a><span id="l19.343">       let idleService = Cc[&quot;@mozilla.org/widget/idleservice;1&quot;].</span>
<a href="#l19.344"></a><span id="l19.344">                           getService(Ci.nsIIdleService);</span>
<a href="#l19.345"></a><span id="l19.345">       idleService.addIdleObserver(this, this._indexIdleThresholdSecs);</span>
<a href="#l19.346"></a><span id="l19.346"> </span>
<a href="#l19.347"></a><span id="l19.347">       let notificationService =</span>
<a href="#l19.348"></a><span id="l19.348">         Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l19.349"></a><span id="l19.349">         getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l19.350"></a><span id="l19.350">       notificationService.addListener(this._msgFolderListener,</span>
<a href="#l19.351"></a><span id="l19.351">                                       Ci.nsIMsgFolderNotificationService.all &amp;</span>
<a href="#l19.352"></a><span id="l19.352">                                       ~Ci.nsIMsgFolderNotificationService.folderAdded);</span>
<a href="#l19.353"></a><span id="l19.353" class="difflineminus">-      </span>
<a href="#l19.354"></a><span id="l19.354" class="difflineplus">+</span>
<a href="#l19.355"></a><span id="l19.355">       this._enabled = true;</span>
<a href="#l19.356"></a><span id="l19.356" class="difflineminus">-      </span>
<a href="#l19.357"></a><span id="l19.357" class="difflineplus">+</span>
<a href="#l19.358"></a><span id="l19.358">       for each (let [iIndexer, indexer] in Iterator(this._otherIndexers)) {</span>
<a href="#l19.359"></a><span id="l19.359">         try {</span>
<a href="#l19.360"></a><span id="l19.360">           indexer.enable();</span>
<a href="#l19.361"></a><span id="l19.361">         } catch (ex) {</span>
<a href="#l19.362"></a><span id="l19.362" class="difflineminus">-          this._log.warning(&quot;Helper indexer threw exception on enable: &quot; + ex);</span>
<a href="#l19.363"></a><span id="l19.363" class="difflineplus">+          this._log.warn(&quot;Helper indexer threw exception on enable: &quot; + ex);</span>
<a href="#l19.364"></a><span id="l19.364">         }</span>
<a href="#l19.365"></a><span id="l19.365">       }</span>
<a href="#l19.366"></a><span id="l19.366" class="difflineminus">-      </span>
<a href="#l19.367"></a><span id="l19.367" class="difflineplus">+</span>
<a href="#l19.368"></a><span id="l19.368">       // if we have an accumulated desire to index things, kick it off again.</span>
<a href="#l19.369"></a><span id="l19.369">       if (this._indexingDesired) {</span>
<a href="#l19.370"></a><span id="l19.370">         this._indexingDesired = false; // it's edge-triggered for now</span>
<a href="#l19.371"></a><span id="l19.371">         this.indexing = true;</span>
<a href="#l19.372"></a><span id="l19.372">       }</span>
<a href="#l19.373"></a><span id="l19.373" class="difflineminus">-      </span>
<a href="#l19.374"></a><span id="l19.374" class="difflineplus">+</span>
<a href="#l19.375"></a><span id="l19.375">       // if we have not done an initial sweep, schedule scheduling one.</span>
<a href="#l19.376"></a><span id="l19.376">       if (!this._initialSweepPerformed)</span>
<a href="#l19.377"></a><span id="l19.377">         this._longTimer.initWithCallback(this._scheduleInitialSweep,</span>
<a href="#l19.378"></a><span id="l19.378">           this._initialSweepDelay, Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l19.379"></a><span id="l19.379">     }</span>
<a href="#l19.380"></a><span id="l19.380">     else if (this._enabled &amp;&amp; !aEnable) {</span>
<a href="#l19.381"></a><span id="l19.381">       for each (let [iIndexer, indexer] in Iterator(this._otherIndexers)) {</span>
<a href="#l19.382"></a><span id="l19.382">         try {</span>
<a href="#l19.383"></a><span id="l19.383">           indexer.disable();</span>
<a href="#l19.384"></a><span id="l19.384">         } catch (ex) {</span>
<a href="#l19.385"></a><span id="l19.385" class="difflineminus">-          this._log.warning(&quot;Helper indexer threw exception on disable: &quot; + ex);</span>
<a href="#l19.386"></a><span id="l19.386" class="difflineplus">+          this._log.warn(&quot;Helper indexer threw exception on disable: &quot; + ex);</span>
<a href="#l19.387"></a><span id="l19.387">         }</span>
<a href="#l19.388"></a><span id="l19.388">       }</span>
<a href="#l19.389"></a><span id="l19.389"> </span>
<a href="#l19.390"></a><span id="l19.390">       // remove observer; no more events to observe!</span>
<a href="#l19.391"></a><span id="l19.391">       let observerService = Cc[&quot;@mozilla.org/observer-service;1&quot;].</span>
<a href="#l19.392"></a><span id="l19.392">                               getService(Ci.nsIObserverService);</span>
<a href="#l19.393"></a><span id="l19.393">       observerService.removeObserver(this, &quot;network:offline-status-changed&quot;);</span>
<a href="#l19.394"></a><span id="l19.394">       observerService.removeObserver(this, &quot;quit-application&quot;);</span>
<a href="#l19.395"></a><span id="l19.395" class="difflineminus">-  </span>
<a href="#l19.396"></a><span id="l19.396" class="difflineplus">+</span>
<a href="#l19.397"></a><span id="l19.397">       // remove idle</span>
<a href="#l19.398"></a><span id="l19.398">       let idleService = Cc[&quot;@mozilla.org/widget/idleservice;1&quot;].</span>
<a href="#l19.399"></a><span id="l19.399">                           getService(Ci.nsIIdleService);</span>
<a href="#l19.400"></a><span id="l19.400">       idleService.removeIdleObserver(this, this._indexIdleThresholdSecs);</span>
<a href="#l19.401"></a><span id="l19.401" class="difflineminus">-  </span>
<a href="#l19.402"></a><span id="l19.402" class="difflineplus">+</span>
<a href="#l19.403"></a><span id="l19.403">       // remove FolderLoaded notification listener</span>
<a href="#l19.404"></a><span id="l19.404">       let mailSession = Cc[&quot;@mozilla.org/messenger/services/session;1&quot;].</span>
<a href="#l19.405"></a><span id="l19.405">                           getService(Ci.nsIMsgMailSession);</span>
<a href="#l19.406"></a><span id="l19.406">       mailSession.RemoveFolderListener(this._folderListener);</span>
<a href="#l19.407"></a><span id="l19.407"> </span>
<a href="#l19.408"></a><span id="l19.408">       let notificationService =</span>
<a href="#l19.409"></a><span id="l19.409">         Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l19.410"></a><span id="l19.410">         getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l19.411"></a><span id="l19.411">       notificationService.removeListener(this._msgFolderListener);</span>
<a href="#l19.412"></a><span id="l19.412" class="difflineminus">-      </span>
<a href="#l19.413"></a><span id="l19.413" class="difflineplus">+</span>
<a href="#l19.414"></a><span id="l19.414">       this._enabled = false;</span>
<a href="#l19.415"></a><span id="l19.415">     }</span>
<a href="#l19.416"></a><span id="l19.416" class="difflineminus">-    </span>
<a href="#l19.417"></a><span id="l19.417" class="difflineplus">+</span>
<a href="#l19.418"></a><span id="l19.418">     this._log.info(&quot;Event-Driven Indexing is now &quot; + this._enabled);</span>
<a href="#l19.419"></a><span id="l19.419">   },</span>
<a href="#l19.420"></a><span id="l19.420"> </span>
<a href="#l19.421"></a><span id="l19.421">   /** Track whether indexing is desired (we have jobs to prosecute). */</span>
<a href="#l19.422"></a><span id="l19.422">   _indexingDesired: false,</span>
<a href="#l19.423"></a><span id="l19.423">   /**</span>
<a href="#l19.424"></a><span id="l19.424">    * Track whether we have an actively pending callback or timer event.  We do</span>
<a href="#l19.425"></a><span id="l19.425">    *  this so we don't experience a transient suppression and accidentally</span>
<a href="#l19.426"></a><span id="l19.426" class="difflineat">@@ -562,28 +562,28 @@ var GlodaIndexer = {</span>
<a href="#l19.427"></a><span id="l19.427">                                      Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l19.428"></a><span id="l19.428">         // Start the performance sampling timer since indexing is now active.</span>
<a href="#l19.429"></a><span id="l19.429">         // (That's the dude who tracks processor utilization and adjusts our</span>
<a href="#l19.430"></a><span id="l19.430">         // indexing constants.)</span>
<a href="#l19.431"></a><span id="l19.431">         this.perfSampling = true;</span>
<a href="#l19.432"></a><span id="l19.432">       }</span>
<a href="#l19.433"></a><span id="l19.433">     }</span>
<a href="#l19.434"></a><span id="l19.434">   },</span>
<a href="#l19.435"></a><span id="l19.435" class="difflineminus">-  </span>
<a href="#l19.436"></a><span id="l19.436" class="difflineplus">+</span>
<a href="#l19.437"></a><span id="l19.437">   _suppressIndexing: false,</span>
<a href="#l19.438"></a><span id="l19.438">   /**</span>
<a href="#l19.439"></a><span id="l19.439">    * Set whether or not indexing should be suppressed.  This is to allow us to</span>
<a href="#l19.440"></a><span id="l19.440">    *  avoid running down a laptop's battery when it is not on AC.  Only code</span>
<a href="#l19.441"></a><span id="l19.441">    *  in charge of regulating that tracking should be setting this variable; if</span>
<a href="#l19.442"></a><span id="l19.442">    *  other factors want to contribute to such a decision, this logic needs to</span>
<a href="#l19.443"></a><span id="l19.443">    *  be changed to track that, since last-write currently wins.</span>
<a href="#l19.444"></a><span id="l19.444">    */</span>
<a href="#l19.445"></a><span id="l19.445">   set suppressIndexing(aShouldSuppress) {</span>
<a href="#l19.446"></a><span id="l19.446">     this._suppressIndexing = aShouldSuppress;</span>
<a href="#l19.447"></a><span id="l19.447" class="difflineminus">-    </span>
<a href="#l19.448"></a><span id="l19.448" class="difflineplus">+</span>
<a href="#l19.449"></a><span id="l19.449">     // re-start processing if we are no longer suppressing, there is work yet</span>
<a href="#l19.450"></a><span id="l19.450">     //  to do, and the indexing process had actually stopped.</span>
<a href="#l19.451"></a><span id="l19.451">     if (!this._suppressIndexing &amp;&amp; this._indexingDesired &amp;&amp;</span>
<a href="#l19.452"></a><span id="l19.452">         !this._indexingActive) {</span>
<a href="#l19.453"></a><span id="l19.453">         this._log.info(&quot;+++ Indexing Queue Processing Resuming&quot;);</span>
<a href="#l19.454"></a><span id="l19.454">         this._indexingActive = true;</span>
<a href="#l19.455"></a><span id="l19.455">         this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l19.456"></a><span id="l19.456">                                      this._indexInterval,</span>
<a href="#l19.457"></a><span id="l19.457" class="difflineat">@@ -600,40 +600,42 @@ var GlodaIndexer = {</span>
<a href="#l19.458"></a><span id="l19.458"> </span>
<a href="#l19.459"></a><span id="l19.459">   /**</span>
<a href="#l19.460"></a><span id="l19.460">    * Our timer-driven callback to schedule our first initial indexing sweep.</span>
<a href="#l19.461"></a><span id="l19.461">    *  Because it is invoked by an nsITimer it operates without the benefit of</span>
<a href="#l19.462"></a><span id="l19.462">    *  a 'this' context and must use GlodaIndexer instead of this.</span>
<a href="#l19.463"></a><span id="l19.463">    * Since an initial sweep could have been performed before we get invoked,</span>
<a href="#l19.464"></a><span id="l19.464">    *  we need to check whether an initial sweep is still desired before trying</span>
<a href="#l19.465"></a><span id="l19.465">    *  to schedule one.  We don't need to worry about whether one is active</span>
<a href="#l19.466"></a><span id="l19.466" class="difflineminus">-   *  because the indexingSweepNeeded takes care of that.  </span>
<a href="#l19.467"></a><span id="l19.467" class="difflineplus">+   *  because the indexingSweepNeeded takes care of that.</span>
<a href="#l19.468"></a><span id="l19.468">    */</span>
<a href="#l19.469"></a><span id="l19.469">   _scheduleInitialSweep: function gloda_index_scheduleInitialSweep() {</span>
<a href="#l19.470"></a><span id="l19.470">     if (!GlodaIndexer._initialSweepPerformed)</span>
<a href="#l19.471"></a><span id="l19.471">       GlodaIndexer.indexingSweepNeeded = true;</span>
<a href="#l19.472"></a><span id="l19.472">   },</span>
<a href="#l19.473"></a><span id="l19.473" class="difflineminus">-  </span>
<a href="#l19.474"></a><span id="l19.474" class="difflineplus">+</span>
<a href="#l19.475"></a><span id="l19.475">   _initialSweepPerformed: false,</span>
<a href="#l19.476"></a><span id="l19.476">   _indexingSweepActive: false,</span>
<a href="#l19.477"></a><span id="l19.477">   /**</span>
<a href="#l19.478"></a><span id="l19.478">    * Indicate that an indexing sweep is desired.  We kick-off an indexing</span>
<a href="#l19.479"></a><span id="l19.479">    *  sweep at start-up and whenever we receive an event-based notification</span>
<a href="#l19.480"></a><span id="l19.480">    *  that we either can't process as an event or that we normally handle</span>
<a href="#l19.481"></a><span id="l19.481">    *  during the sweep pass anyways.</span>
<a href="#l19.482"></a><span id="l19.482">    */</span>
<a href="#l19.483"></a><span id="l19.483">   set indexingSweepNeeded(aNeeded) {</span>
<a href="#l19.484"></a><span id="l19.484">     if (!this._indexingSweepActive &amp;&amp; aNeeded) {</span>
<a href="#l19.485"></a><span id="l19.485" class="difflineminus">-      this._indexQueue.push(new IndexingJob(&quot;sweep&quot;, 0, null));</span>
<a href="#l19.486"></a><span id="l19.486" class="difflineplus">+      let job = new IndexingJob(&quot;sweep&quot;, 0, null);</span>
<a href="#l19.487"></a><span id="l19.487" class="difflineplus">+      job.mappedFolders = false;</span>
<a href="#l19.488"></a><span id="l19.488" class="difflineplus">+      this._indexQueue.push(job);</span>
<a href="#l19.489"></a><span id="l19.489">       this._indexingJobGoal++;</span>
<a href="#l19.490"></a><span id="l19.490">       this._indexingSweepActive = true;</span>
<a href="#l19.491"></a><span id="l19.491">       this.indexing = true;</span>
<a href="#l19.492"></a><span id="l19.492">     }</span>
<a href="#l19.493"></a><span id="l19.493">   },</span>
<a href="#l19.494"></a><span id="l19.494" class="difflineminus">-  </span>
<a href="#l19.495"></a><span id="l19.495" class="difflineplus">+</span>
<a href="#l19.496"></a><span id="l19.496">   /**</span>
<a href="#l19.497"></a><span id="l19.497">    * Number of milliseconds between performance samples.</span>
<a href="#l19.498"></a><span id="l19.498">    */</span>
<a href="#l19.499"></a><span id="l19.499">   _PERF_SAMPLE_RATE_MS: 1000,</span>
<a href="#l19.500"></a><span id="l19.500">   set perfSampling(aEnable) {</span>
<a href="#l19.501"></a><span id="l19.501">     if (aEnable) {</span>
<a href="#l19.502"></a><span id="l19.502">       this._perfSamples = [];</span>
<a href="#l19.503"></a><span id="l19.503">       this._perfTimer.initWithCallback(this._perfTimerFire,</span>
<a href="#l19.504"></a><span id="l19.504" class="difflineat">@@ -646,17 +648,17 @@ var GlodaIndexer = {</span>
<a href="#l19.505"></a><span id="l19.505">       // we stop the stopwatch mainly so our state makes sense to anyone</span>
<a href="#l19.506"></a><span id="l19.506">       //  debugging and for our unit test.  In reality, the stopwatch only</span>
<a href="#l19.507"></a><span id="l19.507">       //  does work on the calls to start and stop, and no expense is incurred</span>
<a href="#l19.508"></a><span id="l19.508">       //  in the interim, so this is actually expense with no benefit.  But it's</span>
<a href="#l19.509"></a><span id="l19.509">       //  not much of an expense.</span>
<a href="#l19.510"></a><span id="l19.510">       this._perfStopwatch.stop();</span>
<a href="#l19.511"></a><span id="l19.511">     }</span>
<a href="#l19.512"></a><span id="l19.512">   },</span>
<a href="#l19.513"></a><span id="l19.513" class="difflineminus">-  </span>
<a href="#l19.514"></a><span id="l19.514" class="difflineplus">+</span>
<a href="#l19.515"></a><span id="l19.515">   /**</span>
<a href="#l19.516"></a><span id="l19.516">    * Number of performance samples to average together.  We average to try and</span>
<a href="#l19.517"></a><span id="l19.517">    *  stabilize our decision making in the face of transient thunderbird CPU</span>
<a href="#l19.518"></a><span id="l19.518">    *  utilization spikes that are not our fault.  (User activity, garbage</span>
<a href="#l19.519"></a><span id="l19.519">    *  collection, etc.</span>
<a href="#l19.520"></a><span id="l19.520">    */</span>
<a href="#l19.521"></a><span id="l19.521">   _perfSamplePointCount: 2,</span>
<a href="#l19.522"></a><span id="l19.522">   _perfSamples: [],</span>
<a href="#l19.523"></a><span id="l19.523" class="difflineat">@@ -689,218 +691,218 @@ var GlodaIndexer = {</span>
<a href="#l19.524"></a><span id="l19.524">   _MAX_TIMER_INTERVAL_MS: 400,</span>
<a href="#l19.525"></a><span id="l19.525">   /**</span>
<a href="#l19.526"></a><span id="l19.526">    * Periodic performance adjustment logic.  The overall goal is to adjust our</span>
<a href="#l19.527"></a><span id="l19.527">    *  rate of work so that we don't interfere with the user's activities when</span>
<a href="#l19.528"></a><span id="l19.528">    *  they are around (non-idle), and the system in general (when idle).  Being</span>
<a href="#l19.529"></a><span id="l19.529">    *  nice when idle isn't quite as important, but is a good idea so that when</span>
<a href="#l19.530"></a><span id="l19.530">    *  the user un-idles we are able to back off nicely.  Also, we give other</span>
<a href="#l19.531"></a><span id="l19.531">    *  processes on the system a chance to do something.</span>
<a href="#l19.532"></a><span id="l19.532" class="difflineminus">-   * </span>
<a href="#l19.533"></a><span id="l19.533" class="difflineplus">+   *</span>
<a href="#l19.534"></a><span id="l19.534">    * The two knobs we have to play with are:</span>
<a href="#l19.535"></a><span id="l19.535">    * - The amount of time we sleep between work batch processing.  Keep in mind</span>
<a href="#l19.536"></a><span id="l19.536">    *   that many of our operations are actually asynchronous, so we aren't</span>
<a href="#l19.537"></a><span id="l19.537">    *   entirely starving the event queue.  However, a lot of the async stuff</span>
<a href="#l19.538"></a><span id="l19.538">    *   can end up not having any actual delay between events. For example, we</span>
<a href="#l19.539"></a><span id="l19.539">    *   only index offline message bodies, so there's no network latency</span>
<a href="#l19.540"></a><span id="l19.540">    *   involved, just disk IO; the only meaningful latency will be the initial</span>
<a href="#l19.541"></a><span id="l19.541">    *   disk seek (if there is one... pre-fetching may seriously be our friend).</span>
<a href="#l19.542"></a><span id="l19.542">    * - The amount of work we do between intentional sleeps (number of tokens).</span>
<a href="#l19.543"></a><span id="l19.543" class="difflineminus">-   * </span>
<a href="#l19.544"></a><span id="l19.544" class="difflineplus">+   *</span>
<a href="#l19.545"></a><span id="l19.545">    * In order to maintain responsiveness, I assert that we want to minimize the</span>
<a href="#l19.546"></a><span id="l19.546">    *  length of the time we are dominating the event queue.  This suggests</span>
<a href="#l19.547"></a><span id="l19.547">    *  that we want break up our blocks of work frequently.  But not so</span>
<a href="#l19.548"></a><span id="l19.548">    *  frequently that there is a lot of waste.  Accordingly our algorithm is</span>
<a href="#l19.549"></a><span id="l19.549">    *  basically:</span>
<a href="#l19.550"></a><span id="l19.550" class="difflineminus">-   *  </span>
<a href="#l19.551"></a><span id="l19.551" class="difflineplus">+   *</span>
<a href="#l19.552"></a><span id="l19.552">    * Using too much cpu:</span>
<a href="#l19.553"></a><span id="l19.553">    *  First, do less work per slice = reduce tokens.</span>
<a href="#l19.554"></a><span id="l19.554">    *  Second, space our work batches out more = increase sleep time.</span>
<a href="#l19.555"></a><span id="l19.555" class="difflineminus">-   *  </span>
<a href="#l19.556"></a><span id="l19.556" class="difflineplus">+   *</span>
<a href="#l19.557"></a><span id="l19.557">    * Using less cpu than budgeted:</span>
<a href="#l19.558"></a><span id="l19.558">    *  First, reduce the spacing between our work batches = decrease sleep time.</span>
<a href="#l19.559"></a><span id="l19.559">    *  Second, do more work per slice = increase tokens.</span>
<a href="#l19.560"></a><span id="l19.560">    */</span>
<a href="#l19.561"></a><span id="l19.561">   perfTimerFire: function perfTimerFire() {</span>
<a href="#l19.562"></a><span id="l19.562">     let stopwatch = this._perfStopwatch;</span>
<a href="#l19.563"></a><span id="l19.563">     stopwatch.stop();</span>
<a href="#l19.564"></a><span id="l19.564" class="difflineminus">-    </span>
<a href="#l19.565"></a><span id="l19.565" class="difflineplus">+</span>
<a href="#l19.566"></a><span id="l19.566">     let realTime = stopwatch.realTimeSeconds;</span>
<a href="#l19.567"></a><span id="l19.567">     let cpuTime = stopwatch.cpuTimeSeconds;</span>
<a href="#l19.568"></a><span id="l19.568" class="difflineminus">-    </span>
<a href="#l19.569"></a><span id="l19.569" class="difflineplus">+</span>
<a href="#l19.570"></a><span id="l19.570">     let dir = &quot;none&quot;, averagePercent = 0;</span>
<a href="#l19.571"></a><span id="l19.571">     if (realTime) {</span>
<a href="#l19.572"></a><span id="l19.572">       while (this._perfSamples.length &gt;= this._perfSamplePointCount)</span>
<a href="#l19.573"></a><span id="l19.573">         this._perfSamples.shift();</span>
<a href="#l19.574"></a><span id="l19.574" class="difflineminus">-      </span>
<a href="#l19.575"></a><span id="l19.575" class="difflineplus">+</span>
<a href="#l19.576"></a><span id="l19.576">       let cpuPercent = cpuTime / realTime;</span>
<a href="#l19.577"></a><span id="l19.577">       this._perfSamples.push(cpuPercent);</span>
<a href="#l19.578"></a><span id="l19.578" class="difflineminus">-      </span>
<a href="#l19.579"></a><span id="l19.579" class="difflineminus">-      if (this._perfSamples.length == this._perfSamplePointCount) { </span>
<a href="#l19.580"></a><span id="l19.580" class="difflineplus">+</span>
<a href="#l19.581"></a><span id="l19.581" class="difflineplus">+      if (this._perfSamples.length == this._perfSamplePointCount) {</span>
<a href="#l19.582"></a><span id="l19.582">         for (let i = 0; i &lt; this._perfSamples.length; i++)</span>
<a href="#l19.583"></a><span id="l19.583">           averagePercent += this._perfSamples[i];</span>
<a href="#l19.584"></a><span id="l19.584">         averagePercent /= this._perfSamples.length;</span>
<a href="#l19.585"></a><span id="l19.585" class="difflineminus">-        </span>
<a href="#l19.586"></a><span id="l19.586" class="difflineplus">+</span>
<a href="#l19.587"></a><span id="l19.587">         if (averagePercent &gt; this._cpuTarget) {</span>
<a href="#l19.588"></a><span id="l19.588">           dir = &quot;down&quot;;</span>
<a href="#l19.589"></a><span id="l19.589">           if (this._indexTokens &gt; 1)</span>
<a href="#l19.590"></a><span id="l19.590">             this._indexTokens--;</span>
<a href="#l19.591"></a><span id="l19.591">           else if (this._indexInterval &lt; this._MAX_TIMER_INTERVAL_MS)</span>
<a href="#l19.592"></a><span id="l19.592">             this._indexInterval += this._TIMER_STEP_SIZE;</span>
<a href="#l19.593"></a><span id="l19.593">         }</span>
<a href="#l19.594"></a><span id="l19.594">         else if (averagePercent + 0.1 &lt; this._cpuTarget) {</span>
<a href="#l19.595"></a><span id="l19.595">           dir = &quot;up&quot;;</span>
<a href="#l19.596"></a><span id="l19.596">           if (this._indexInterval &gt; this._MIN_TIMER_INTERVAL_MS)</span>
<a href="#l19.597"></a><span id="l19.597">             this._indexInterval -= this._TIMER_STEP_SIZE;</span>
<a href="#l19.598"></a><span id="l19.598">           else</span>
<a href="#l19.599"></a><span id="l19.599">             this._indexTokens++;</span>
<a href="#l19.600"></a><span id="l19.600">         }</span>
<a href="#l19.601"></a><span id="l19.601">       }</span>
<a href="#l19.602"></a><span id="l19.602" class="difflineminus">-    </span>
<a href="#l19.603"></a><span id="l19.603" class="difflineplus">+</span>
<a href="#l19.604"></a><span id="l19.604">       GlodaIndexer._log.debug(&quot;PERFORMANCE &quot; + dir +</span>
<a href="#l19.605"></a><span id="l19.605">                               &quot; average: &quot; + averagePercent +</span>
<a href="#l19.606"></a><span id="l19.606">                               &quot; interval: &quot; + this._indexInterval +</span>
<a href="#l19.607"></a><span id="l19.607">                               &quot; tokens: &quot; + this._indexTokens);</span>
<a href="#l19.608"></a><span id="l19.608">     }</span>
<a href="#l19.609"></a><span id="l19.609" class="difflineminus">-    </span>
<a href="#l19.610"></a><span id="l19.610" class="difflineplus">+</span>
<a href="#l19.611"></a><span id="l19.611">     stopwatch.start();</span>
<a href="#l19.612"></a><span id="l19.612">   },</span>
<a href="#l19.613"></a><span id="l19.613" class="difflineminus">-  </span>
<a href="#l19.614"></a><span id="l19.614" class="difflineplus">+</span>
<a href="#l19.615"></a><span id="l19.615">   /**</span>
<a href="#l19.616"></a><span id="l19.616">    * Indicates that we have pending deletions to process, meaning that there</span>
<a href="#l19.617"></a><span id="l19.617">    *  are gloda message rows flagged for deletion.  If this value is a boolean,</span>
<a href="#l19.618"></a><span id="l19.618">    *  it means the value is known reliably.  If this value is null, it means</span>
<a href="#l19.619"></a><span id="l19.619">    *  that we don't know, likely because we have started up and have not checked</span>
<a href="#l19.620"></a><span id="l19.620">    *  the database.</span>
<a href="#l19.621"></a><span id="l19.621">    */</span>
<a href="#l19.622"></a><span id="l19.622">   pendingDeletions: null,</span>
<a href="#l19.623"></a><span id="l19.623" class="difflineminus">-  </span>
<a href="#l19.624"></a><span id="l19.624" class="difflineplus">+</span>
<a href="#l19.625"></a><span id="l19.625">   /**</span>
<a href="#l19.626"></a><span id="l19.626">    * The message (or folder state) is believed up-to-date.</span>
<a href="#l19.627"></a><span id="l19.627">    */</span>
<a href="#l19.628"></a><span id="l19.628">   kMessageClean: 0,</span>
<a href="#l19.629"></a><span id="l19.629">   /**</span>
<a href="#l19.630"></a><span id="l19.630">    * The message (or folder) is known to not be up-to-date. In the case of</span>
<a href="#l19.631"></a><span id="l19.631">    *  folders, this means that some of the messages in the folder may be dirty.</span>
<a href="#l19.632"></a><span id="l19.632">    *  However, because of the way our indexing works, it is possible there may</span>
<a href="#l19.633"></a><span id="l19.633">    *  actually be no dirty messages in a folder.  (We attempt to process</span>
<a href="#l19.634"></a><span id="l19.634">    *  messages in an event-driven fashion for a finite number of messages, but</span>
<a href="#l19.635"></a><span id="l19.635">    *  because we can quit without completing processing of the queue, we need to</span>
<a href="#l19.636"></a><span id="l19.636">    *  mark the folder dirty, just-in-case.)  (We could do some extra leg-work</span>
<a href="#l19.637"></a><span id="l19.637" class="difflineminus">-   *  and do a better job of marking the folder clean again.)   </span>
<a href="#l19.638"></a><span id="l19.638" class="difflineplus">+   *  and do a better job of marking the folder clean again.)</span>
<a href="#l19.639"></a><span id="l19.639">    */</span>
<a href="#l19.640"></a><span id="l19.640">   kMessageDirty: 1,</span>
<a href="#l19.641"></a><span id="l19.641">   /**</span>
<a href="#l19.642"></a><span id="l19.642">    * We have not indexed the folder at all, but messages in the folder think</span>
<a href="#l19.643"></a><span id="l19.643">    *  they are indexed.  Once we mark all the messages in the folder as being</span>
<a href="#l19.644"></a><span id="l19.644">    *  dirty so that they don't confuse us, we downgrade the folder's dirty</span>
<a href="#l19.645"></a><span id="l19.645">    *  status to just kMessageDirty.</span>
<a href="#l19.646"></a><span id="l19.646">    */</span>
<a href="#l19.647"></a><span id="l19.647">   kMessageFilthy: 2,</span>
<a href="#l19.648"></a><span id="l19.648"> </span>
<a href="#l19.649"></a><span id="l19.649">   kWorkSync: Gloda.kWorkSync,</span>
<a href="#l19.650"></a><span id="l19.650">   kWorkAsync: Gloda.kWorkAsync,</span>
<a href="#l19.651"></a><span id="l19.651">   kWorkDone: Gloda.kWorkDone,</span>
<a href="#l19.652"></a><span id="l19.652">   kWorkPause: Gloda.kWorkPause,</span>
<a href="#l19.653"></a><span id="l19.653">   kWorkDoneWithResult: Gloda.kWorkDoneWithResult,</span>
<a href="#l19.654"></a><span id="l19.654" class="difflineminus">-  </span>
<a href="#l19.655"></a><span id="l19.655" class="difflineplus">+</span>
<a href="#l19.656"></a><span id="l19.656">   /**</span>
<a href="#l19.657"></a><span id="l19.657">    * Our current job number, out of _indexingJobGoal.  Although our jobs comes</span>
<a href="#l19.658"></a><span id="l19.658">    *  from _indexQueue, this is not an offset into that list because we forget</span>
<a href="#l19.659"></a><span id="l19.659">    *  jobs once we complete them.  As such, this value is strictly for progress</span>
<a href="#l19.660"></a><span id="l19.660">    *  tracking.</span>
<a href="#l19.661"></a><span id="l19.661" class="difflineminus">-   */ </span>
<a href="#l19.662"></a><span id="l19.662" class="difflineplus">+   */</span>
<a href="#l19.663"></a><span id="l19.663">   _indexingJobCount: 0,</span>
<a href="#l19.664"></a><span id="l19.664">   /**</span>
<a href="#l19.665"></a><span id="l19.665">    * Total number of jobs to process in this current indexing session; may</span>
<a href="#l19.666"></a><span id="l19.666">    *  increase as new jobs are added to the _indexQueue.  This value won't</span>
<a href="#l19.667"></a><span id="l19.667">    *  decrease until the indexing session is completed (and we become idle),</span>
<a href="#l19.668"></a><span id="l19.668">    *  and then it will go to zero.</span>
<a href="#l19.669"></a><span id="l19.669">    */</span>
<a href="#l19.670"></a><span id="l19.670">   _indexingJobGoal: 0,</span>
<a href="#l19.671"></a><span id="l19.671" class="difflineminus">-  </span>
<a href="#l19.672"></a><span id="l19.672" class="difflineplus">+</span>
<a href="#l19.673"></a><span id="l19.673">   /**</span>
<a href="#l19.674"></a><span id="l19.674">    * A list of IndexingJob instances to process.</span>
<a href="#l19.675"></a><span id="l19.675">    * - ['account', account object]</span>
<a href="#l19.676"></a><span id="l19.676">    * - ['folder', folder URI]</span>
<a href="#l19.677"></a><span id="l19.677">    * - ['message', delta type, message header, folder ID, message key,</span>
<a href="#l19.678"></a><span id="l19.678">    *      message ID]</span>
<a href="#l19.679"></a><span id="l19.679">    *   (we use folder ID instead of URI so that renames can't trick us)</span>
<a href="#l19.680"></a><span id="l19.680">    */</span>
<a href="#l19.681"></a><span id="l19.681">   _indexQueue: [],</span>
<a href="#l19.682"></a><span id="l19.682" class="difflineminus">-  </span>
<a href="#l19.683"></a><span id="l19.683" class="difflineplus">+</span>
<a href="#l19.684"></a><span id="l19.684">   /**</span>
<a href="#l19.685"></a><span id="l19.685">    * The current indexing job.</span>
<a href="#l19.686"></a><span id="l19.686">    */</span>
<a href="#l19.687"></a><span id="l19.687">   _curIndexingJob: null,</span>
<a href="#l19.688"></a><span id="l19.688" class="difflineminus">-  </span>
<a href="#l19.689"></a><span id="l19.689" class="difflineplus">+</span>
<a href="#l19.690"></a><span id="l19.690">   /**</span>
<a href="#l19.691"></a><span id="l19.691">    * A message addition job yet to be (completely) processed.  Since message</span>
<a href="#l19.692"></a><span id="l19.692">    *  addition events come to us one-by-one, in order to aggregate them into a</span>
<a href="#l19.693"></a><span id="l19.693">    *  job, we need something like this.  It's up to the indexing loop to</span>
<a href="#l19.694"></a><span id="l19.694">    *  decide when to null this out; it can either do it when it first starts</span>
<a href="#l19.695"></a><span id="l19.695">    *  processing it, or when it has processed the last thing.  It's really a</span>
<a href="#l19.696"></a><span id="l19.696">    *  question of whether we want retrograde motion in the folder progress bar</span>
<a href="#l19.697"></a><span id="l19.697">    *  or the message progress bar.</span>
<a href="#l19.698"></a><span id="l19.698">    */</span>
<a href="#l19.699"></a><span id="l19.699">   _pendingAddJob: null,</span>
<a href="#l19.700"></a><span id="l19.700" class="difflineminus">-  </span>
<a href="#l19.701"></a><span id="l19.701" class="difflineplus">+</span>
<a href="#l19.702"></a><span id="l19.702">   /**</span>
<a href="#l19.703"></a><span id="l19.703">    * The number of seconds before we declare the user idle and step up our</span>
<a href="#l19.704"></a><span id="l19.704">    *  indexing.</span>
<a href="#l19.705"></a><span id="l19.705">    */</span>
<a href="#l19.706"></a><span id="l19.706">   _indexIdleThresholdSecs: 15,</span>
<a href="#l19.707"></a><span id="l19.707" class="difflineminus">-  </span>
<a href="#l19.708"></a><span id="l19.708" class="difflineplus">+</span>
<a href="#l19.709"></a><span id="l19.709">   /**</span>
<a href="#l19.710"></a><span id="l19.710">    * The time delay in milliseconds before we should schedule our initial sweep.</span>
<a href="#l19.711"></a><span id="l19.711">    */</span>
<a href="#l19.712"></a><span id="l19.712">   _initialSweepDelay: 10000,</span>
<a href="#l19.713"></a><span id="l19.713" class="difflineminus">-  </span>
<a href="#l19.714"></a><span id="l19.714" class="difflineplus">+</span>
<a href="#l19.715"></a><span id="l19.715">   _cpuTarget: 0.4,</span>
<a href="#l19.716"></a><span id="l19.716">   _cpuTarget_whenActive: 0.4,</span>
<a href="#l19.717"></a><span id="l19.717">   _cpuTarget_whenIdle: 0.8,</span>
<a href="#l19.718"></a><span id="l19.718" class="difflineminus">-  </span>
<a href="#l19.719"></a><span id="l19.719" class="difflineplus">+</span>
<a href="#l19.720"></a><span id="l19.720">   /**</span>
<a href="#l19.721"></a><span id="l19.721">    * The time interval, in milliseconds between performing indexing work.</span>
<a href="#l19.722"></a><span id="l19.722">    *  This may be altered by user session (in)activity.</span>
<a href="#l19.723"></a><span id="l19.723" class="difflineminus">-   */ </span>
<a href="#l19.724"></a><span id="l19.724" class="difflineplus">+   */</span>
<a href="#l19.725"></a><span id="l19.725">   _indexInterval: 60,</span>
<a href="#l19.726"></a><span id="l19.726">   _indexInterval_whenActive: 60,</span>
<a href="#l19.727"></a><span id="l19.727">   _indexInterval_whenIdle: 20,</span>
<a href="#l19.728"></a><span id="l19.728">   /**</span>
<a href="#l19.729"></a><span id="l19.729">    * Number of indexing 'tokens' we are allowed to consume before yielding for</span>
<a href="#l19.730"></a><span id="l19.730">    *  each incremental pass.  Consider a single token equal to indexing a single</span>
<a href="#l19.731"></a><span id="l19.731">    *  medium-sized message.  This may be altered by user session (in)activity.</span>
<a href="#l19.732"></a><span id="l19.732">    * Because we fetch message bodies, which is potentially asynchronous, this</span>
<a href="#l19.733"></a><span id="l19.733">    *  is not a precise knob to twiddle.</span>
<a href="#l19.734"></a><span id="l19.734">    */</span>
<a href="#l19.735"></a><span id="l19.735">   _indexTokens: 5,</span>
<a href="#l19.736"></a><span id="l19.736">   _indexTokens_whenActive: 5,</span>
<a href="#l19.737"></a><span id="l19.737">   _indexTokens_whenIdle: 10,</span>
<a href="#l19.738"></a><span id="l19.738" class="difflineminus">-  </span>
<a href="#l19.739"></a><span id="l19.739" class="difflineplus">+</span>
<a href="#l19.740"></a><span id="l19.740">   /**</span>
<a href="#l19.741"></a><span id="l19.741">    * Number of indexing 'tokens' we consume before we issue a commit.  The</span>
<a href="#l19.742"></a><span id="l19.742">    *  goal is to de-couple our time scheduling from our commit schedule.  It's</span>
<a href="#l19.743"></a><span id="l19.743">    *  far better for user responsiveness to take lots of little bites instead</span>
<a href="#l19.744"></a><span id="l19.744" class="difflineminus">-   *  of a few big ones, but bites that result in commits cannot be little... </span>
<a href="#l19.745"></a><span id="l19.745" class="difflineplus">+   *  of a few big ones, but bites that result in commits cannot be little...</span>
<a href="#l19.746"></a><span id="l19.746">    */</span>
<a href="#l19.747"></a><span id="l19.747">   _indexCommitTokens: 40,</span>
<a href="#l19.748"></a><span id="l19.748" class="difflineminus">-  </span>
<a href="#l19.749"></a><span id="l19.749" class="difflineplus">+</span>
<a href="#l19.750"></a><span id="l19.750">   /**</span>
<a href="#l19.751"></a><span id="l19.751">    * The number of messages that we should queue for processing before letting</span>
<a href="#l19.752"></a><span id="l19.752">    *  them fall on the floor and relying on our folder-walking logic to ensure</span>
<a href="#l19.753"></a><span id="l19.753">    *  that the messages are indexed.</span>
<a href="#l19.754"></a><span id="l19.754">    * The reason we allow for queueing messages in an event-driven fashion is</span>
<a href="#l19.755"></a><span id="l19.755">    *  that once we have reached a steady-state, it is preferable to be able to</span>
<a href="#l19.756"></a><span id="l19.756">    *  deal with new messages and modified meta-data in a prompt fasion rather</span>
<a href="#l19.757"></a><span id="l19.757">    *  than having to (potentially) walk every folder in the system just to find</span>
<a href="#l19.758"></a><span id="l19.758">    *  the message that the user changed the tag on.</span>
<a href="#l19.759"></a><span id="l19.759">    */</span>
<a href="#l19.760"></a><span id="l19.760">   _indexMaxEventQueueMessages: 20,</span>
<a href="#l19.761"></a><span id="l19.761" class="difflineminus">-  </span>
<a href="#l19.762"></a><span id="l19.762" class="difflineplus">+</span>
<a href="#l19.763"></a><span id="l19.763">   _indexListeners: [],</span>
<a href="#l19.764"></a><span id="l19.764">   /**</span>
<a href="#l19.765"></a><span id="l19.765">    * Add an indexing progress listener.  The listener will be notified of at</span>
<a href="#l19.766"></a><span id="l19.766">    *  least all major status changes (idle -&gt; indexing, indexing -&gt; idle), plus</span>
<a href="#l19.767"></a><span id="l19.767">    *  arbitrary progress updates during the indexing process.</span>
<a href="#l19.768"></a><span id="l19.768">    * If indexing is not active when the listener is added, a synthetic idle</span>
<a href="#l19.769"></a><span id="l19.769">    *  notification will be generated.</span>
<a href="#l19.770"></a><span id="l19.770">    *</span>
<a href="#l19.771"></a><span id="l19.771" class="difflineat">@@ -935,90 +937,90 @@ var GlodaIndexer = {</span>
<a href="#l19.772"></a><span id="l19.772">   /**</span>
<a href="#l19.773"></a><span id="l19.773">    * Helper method to tell listeners what we're up to.  For code simplicity,</span>
<a href="#l19.774"></a><span id="l19.774">    *  the caller is just deciding when to send this update (preferably at</span>
<a href="#l19.775"></a><span id="l19.775">    *  reasonable intervals), and doesn't need to provide any indication of</span>
<a href="#l19.776"></a><span id="l19.776">    *  state... we figure that out ourselves.</span>
<a href="#l19.777"></a><span id="l19.777">    */</span>
<a href="#l19.778"></a><span id="l19.778">   _notifyListeners: function gloda_index_notifyListeners() {</span>
<a href="#l19.779"></a><span id="l19.779">     let status, prettyName, jobIndex, jobTotal, jobItemIndex, jobItemGoal;</span>
<a href="#l19.780"></a><span id="l19.780" class="difflineminus">-    </span>
<a href="#l19.781"></a><span id="l19.781" class="difflineplus">+</span>
<a href="#l19.782"></a><span id="l19.782">     if (this.indexing &amp;&amp; this._curIndexingJob) {</span>
<a href="#l19.783"></a><span id="l19.783">       let job = this._curIndexingJob;</span>
<a href="#l19.784"></a><span id="l19.784">       if (job.deltaType &gt; 0)</span>
<a href="#l19.785"></a><span id="l19.785">         status = Gloda.kIndexerIndexing;</span>
<a href="#l19.786"></a><span id="l19.786">       else if (job.deltaType == 0)</span>
<a href="#l19.787"></a><span id="l19.787">         status = Gloda.kIndexerMoving;</span>
<a href="#l19.788"></a><span id="l19.788">       else</span>
<a href="#l19.789"></a><span id="l19.789">         status = Gloda.kIndexerRemoving;</span>
<a href="#l19.790"></a><span id="l19.790" class="difflineminus">-        </span>
<a href="#l19.791"></a><span id="l19.791" class="difflineplus">+</span>
<a href="#l19.792"></a><span id="l19.792">       prettyName = (this._indexingFolder !== null) ?</span>
<a href="#l19.793"></a><span id="l19.793">                    this._indexingFolder.prettiestName : null;</span>
<a href="#l19.794"></a><span id="l19.794"> </span>
<a href="#l19.795"></a><span id="l19.795">       jobIndex = this._indexingJobCount-1;</span>
<a href="#l19.796"></a><span id="l19.796">       jobTotal = this._indexingJobGoal;</span>
<a href="#l19.797"></a><span id="l19.797">       jobItemIndex = job.offset;</span>
<a href="#l19.798"></a><span id="l19.798">       jobItemGoal  = job.goal;</span>
<a href="#l19.799"></a><span id="l19.799">     }</span>
<a href="#l19.800"></a><span id="l19.800">     else {</span>
<a href="#l19.801"></a><span id="l19.801">       status = Gloda.kIndexerIdle;</span>
<a href="#l19.802"></a><span id="l19.802">       prettyName = null;</span>
<a href="#l19.803"></a><span id="l19.803">       jobIndex = 0;</span>
<a href="#l19.804"></a><span id="l19.804">       jobTotal = 1;</span>
<a href="#l19.805"></a><span id="l19.805">       jobItemIndex = 0;</span>
<a href="#l19.806"></a><span id="l19.806">       jobItemGoal = 1;</span>
<a href="#l19.807"></a><span id="l19.807">     }</span>
<a href="#l19.808"></a><span id="l19.808" class="difflineminus">-      </span>
<a href="#l19.809"></a><span id="l19.809" class="difflineminus">-    for (let iListener = this._indexListeners.length-1; iListener &gt;= 0; </span>
<a href="#l19.810"></a><span id="l19.810" class="difflineplus">+</span>
<a href="#l19.811"></a><span id="l19.811" class="difflineplus">+    for (let iListener = this._indexListeners.length-1; iListener &gt;= 0;</span>
<a href="#l19.812"></a><span id="l19.812">          iListener--) {</span>
<a href="#l19.813"></a><span id="l19.813">       let listener = this._indexListeners[iListener];</span>
<a href="#l19.814"></a><span id="l19.814">       try {</span>
<a href="#l19.815"></a><span id="l19.815">         listener(status, prettyName, jobIndex, jobTotal, jobItemIndex,</span>
<a href="#l19.816"></a><span id="l19.816">                  jobItemGoal);</span>
<a href="#l19.817"></a><span id="l19.817">       }</span>
<a href="#l19.818"></a><span id="l19.818">       catch(ex) {</span>
<a href="#l19.819"></a><span id="l19.819">         this._log.error(ex);</span>
<a href="#l19.820"></a><span id="l19.820">       }</span>
<a href="#l19.821"></a><span id="l19.821">     }</span>
<a href="#l19.822"></a><span id="l19.822">   },</span>
<a href="#l19.823"></a><span id="l19.823" class="difflineminus">-  </span>
<a href="#l19.824"></a><span id="l19.824" class="difflineplus">+</span>
<a href="#l19.825"></a><span id="l19.825">   /** The GlodaFolder corresponding to the folder we are indexing. */</span>
<a href="#l19.826"></a><span id="l19.826">   _indexingGlodaFolder: null,</span>
<a href="#l19.827"></a><span id="l19.827">   /** The nsIMsgFolder we are currently indexing. */</span>
<a href="#l19.828"></a><span id="l19.828">   _indexingFolder: null,</span>
<a href="#l19.829"></a><span id="l19.829">   /** The nsIMsgDatabase we are currently indexing. */</span>
<a href="#l19.830"></a><span id="l19.830">   _indexingDatabase: null,</span>
<a href="#l19.831"></a><span id="l19.831">   /**</span>
<a href="#l19.832"></a><span id="l19.832">    * The iterator we are using to iterate over the headers in</span>
<a href="#l19.833"></a><span id="l19.833">    *  this._indexingDatabase.</span>
<a href="#l19.834"></a><span id="l19.834">    */</span>
<a href="#l19.835"></a><span id="l19.835">   _indexingIterator: null,</span>
<a href="#l19.836"></a><span id="l19.836" class="difflineminus">-  </span>
<a href="#l19.837"></a><span id="l19.837" class="difflineplus">+</span>
<a href="#l19.838"></a><span id="l19.838">   /** folder whose entry we are pending on */</span>
<a href="#l19.839"></a><span id="l19.839">   _pendingFolderEntry: null,</span>
<a href="#l19.840"></a><span id="l19.840">   /** if we are pending on a folder, do we want an iterator too? */</span>
<a href="#l19.841"></a><span id="l19.841">   _pendingFolderWantsIterator: false,</span>
<a href="#l19.842"></a><span id="l19.842" class="difflineminus">-  </span>
<a href="#l19.843"></a><span id="l19.843" class="difflineplus">+</span>
<a href="#l19.844"></a><span id="l19.844">   /**</span>
<a href="#l19.845"></a><span id="l19.845">    * Common logic that we want to deal with the given folder ID.  Besides</span>
<a href="#l19.846"></a><span id="l19.846">    *  cutting down on duplicate code, this ensures that we are listening on</span>
<a href="#l19.847"></a><span id="l19.847">    *  the folder in case it tries to go away when we are using it.</span>
<a href="#l19.848"></a><span id="l19.848">    *</span>
<a href="#l19.849"></a><span id="l19.849">    * @return true when the folder was successfully entered, false when we need</span>
<a href="#l19.850"></a><span id="l19.850">    *     to pend on notification of updating of the folder (due to re-parsing</span>
<a href="#l19.851"></a><span id="l19.851">    *     or what have you).  In the event of an actual problem, an exception</span>
<a href="#l19.852"></a><span id="l19.852">    *     will escape.</span>
<a href="#l19.853"></a><span id="l19.853">    */</span>
<a href="#l19.854"></a><span id="l19.854">   _indexerEnterFolder: function gloda_index_indexerEnterFolder(aFolderID,</span>
<a href="#l19.855"></a><span id="l19.855">                                                                aNeedIterator) {</span>
<a href="#l19.856"></a><span id="l19.856">     // leave the folder if we haven't explicitly left it.</span>
<a href="#l19.857"></a><span id="l19.857">     if (this._indexingFolder !== null) {</span>
<a href="#l19.858"></a><span id="l19.858">       this._indexerLeaveFolder();</span>
<a href="#l19.859"></a><span id="l19.859">     }</span>
<a href="#l19.860"></a><span id="l19.860" class="difflineminus">-    </span>
<a href="#l19.861"></a><span id="l19.861" class="difflineplus">+</span>
<a href="#l19.862"></a><span id="l19.862">     this._indexingGlodaFolder = GlodaDatastore._mapFolderID(aFolderID);</span>
<a href="#l19.863"></a><span id="l19.863">     this._indexingFolder = this._indexingGlodaFolder.getXPCOMFolder(</span>
<a href="#l19.864"></a><span id="l19.864">                              this._indexingGlodaFolder.kActivityIndexing);</span>
<a href="#l19.865"></a><span id="l19.865"> </span>
<a href="#l19.866"></a><span id="l19.866">     // The processor utilization required to enter a folder is not our</span>
<a href="#l19.867"></a><span id="l19.867">     //  fault; don't sample this.  We turn it back on once we are in the folder.</span>
<a href="#l19.868"></a><span id="l19.868">     this.perfSampling = false;</span>
<a href="#l19.869"></a><span id="l19.869"> </span>
<a href="#l19.870"></a><span id="l19.870" class="difflineat">@@ -1060,96 +1062,96 @@ var GlodaIndexer = {</span>
<a href="#l19.871"></a><span id="l19.871">         this._indexerGetIterator();</span>
<a href="#l19.872"></a><span id="l19.872">       // re-enable performance sampling; we're responsible for our actions again</span>
<a href="#l19.873"></a><span id="l19.873">       this.perfSampling = true;</span>
<a href="#l19.874"></a><span id="l19.874">       this._indexingDatabase.AddListener(this._databaseAnnouncerListener);</span>
<a href="#l19.875"></a><span id="l19.875">     }</span>
<a href="#l19.876"></a><span id="l19.876">     catch (ex) {</span>
<a href="#l19.877"></a><span id="l19.877">       this._log.error(&quot;Problem entering folder: &quot; +</span>
<a href="#l19.878"></a><span id="l19.878">                       (this._indexingFolder ?</span>
<a href="#l19.879"></a><span id="l19.879" class="difflineminus">-                         this._indexingFolder.prettiestName : &quot;unknown&quot;) + </span>
<a href="#l19.880"></a><span id="l19.880" class="difflineplus">+                         this._indexingFolder.prettiestName : &quot;unknown&quot;) +</span>
<a href="#l19.881"></a><span id="l19.881">                       &quot;, skipping. Error was: &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l19.882"></a><span id="l19.882">                       ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l19.883"></a><span id="l19.883">       this._indexingGlodaFolder.indexing = false;</span>
<a href="#l19.884"></a><span id="l19.884">       this._indexingFolder = null;</span>
<a href="#l19.885"></a><span id="l19.885">       this._indexingGlodaFolder = null;</span>
<a href="#l19.886"></a><span id="l19.886">       this._indexingDatabase = null;</span>
<a href="#l19.887"></a><span id="l19.887">       this._indexingIterator = null;</span>
<a href="#l19.888"></a><span id="l19.888" class="difflineminus">-      </span>
<a href="#l19.889"></a><span id="l19.889" class="difflineplus">+</span>
<a href="#l19.890"></a><span id="l19.890">       // re-throw, we just wanted to make sure this junk is cleaned up and</span>
<a href="#l19.891"></a><span id="l19.891">       //  get localized error logging...</span>
<a href="#l19.892"></a><span id="l19.892">       throw ex;</span>
<a href="#l19.893"></a><span id="l19.893">     }</span>
<a href="#l19.894"></a><span id="l19.894" class="difflineminus">-    </span>
<a href="#l19.895"></a><span id="l19.895" class="difflineplus">+</span>
<a href="#l19.896"></a><span id="l19.896">     return this.kWorkSync;</span>
<a href="#l19.897"></a><span id="l19.897">   },</span>
<a href="#l19.898"></a><span id="l19.898" class="difflineminus">-  </span>
<a href="#l19.899"></a><span id="l19.899" class="difflineplus">+</span>
<a href="#l19.900"></a><span id="l19.900">   /**</span>
<a href="#l19.901"></a><span id="l19.901">    * If the folder was still parsing/updating when we tried to enter, then this</span>
<a href="#l19.902"></a><span id="l19.902">    *  handler will get called by the listener who got the FolderLoaded message.</span>
<a href="#l19.903"></a><span id="l19.903">    * All we need to do is get the database reference, register a listener on</span>
<a href="#l19.904"></a><span id="l19.904">    *  the db, and retrieve an iterator if desired.</span>
<a href="#l19.905"></a><span id="l19.905">    */</span>
<a href="#l19.906"></a><span id="l19.906">   _indexerCompletePendingFolderEntry:</span>
<a href="#l19.907"></a><span id="l19.907">       function gloda_indexer_indexerCompletePendingFolderEntry() {</span>
<a href="#l19.908"></a><span id="l19.908">     this._indexingDatabase = this._indexingFolder.msgDatabase;</span>
<a href="#l19.909"></a><span id="l19.909">     if (this._pendingFolderWantsIterator)</span>
<a href="#l19.910"></a><span id="l19.910">       this._indexerGetIterator();</span>
<a href="#l19.911"></a><span id="l19.911">     this._indexingDatabase.AddListener(this._databaseAnnouncerListener);</span>
<a href="#l19.912"></a><span id="l19.912">     this._log.debug(&quot;...Folder Loaded!&quot;);</span>
<a href="#l19.913"></a><span id="l19.913">     // re-enable performance sampling; we're responsible for our actions again</span>
<a href="#l19.914"></a><span id="l19.914">     this.perfSampling = true;</span>
<a href="#l19.915"></a><span id="l19.915"> </span>
<a href="#l19.916"></a><span id="l19.916" class="difflineminus">-    // the load is no longer pending; we certainly don't want more notifications </span>
<a href="#l19.917"></a><span id="l19.917" class="difflineplus">+    // the load is no longer pending; we certainly don't want more notifications</span>
<a href="#l19.918"></a><span id="l19.918">     this._pendingFolderEntry = null;</span>
<a href="#l19.919"></a><span id="l19.919">     // indexerEnterFolder returned kWorkAsync, which means we need to notify</span>
<a href="#l19.920"></a><span id="l19.920">     //  the callback driver to get things going again.</span>
<a href="#l19.921"></a><span id="l19.921">     this.callbackDriver();</span>
<a href="#l19.922"></a><span id="l19.922">   },</span>
<a href="#l19.923"></a><span id="l19.923" class="difflineminus">-  </span>
<a href="#l19.924"></a><span id="l19.924" class="difflineplus">+</span>
<a href="#l19.925"></a><span id="l19.925">   _indexerGetIterator: function gloda_indexer_indexerGetIterator() {</span>
<a href="#l19.926"></a><span id="l19.926">     this._indexingIterator = fixIterator(</span>
<a href="#l19.927"></a><span id="l19.927">                                this._indexingDatabase.EnumerateMessages(),</span>
<a href="#l19.928"></a><span id="l19.928">                                Ci.nsIMsgDBHdr);</span>
<a href="#l19.929"></a><span id="l19.929">   },</span>
<a href="#l19.930"></a><span id="l19.930" class="difflineminus">-  </span>
<a href="#l19.931"></a><span id="l19.931" class="difflineplus">+</span>
<a href="#l19.932"></a><span id="l19.932">   _indexerLeaveFolder: function gloda_index_indexerLeaveFolder(aExpected) {</span>
<a href="#l19.933"></a><span id="l19.933">     if (this._indexingFolder !== null) {</span>
<a href="#l19.934"></a><span id="l19.934">       if (this._indexingDatabase) {</span>
<a href="#l19.935"></a><span id="l19.935">         this._indexingDatabase.Commit(Ci.nsMsgDBCommitType.kLargeCommit);</span>
<a href="#l19.936"></a><span id="l19.936">         // remove our listener!</span>
<a href="#l19.937"></a><span id="l19.937">         this._indexingDatabase.RemoveListener(this._databaseAnnouncerListener);</span>
<a href="#l19.938"></a><span id="l19.938">       }</span>
<a href="#l19.939"></a><span id="l19.939">       // let the gloda folder know we are done indexing</span>
<a href="#l19.940"></a><span id="l19.940">       this._indexingGlodaFolder.indexing = false;</span>
<a href="#l19.941"></a><span id="l19.941">       // null everyone out</span>
<a href="#l19.942"></a><span id="l19.942">       this._indexingFolder = null;</span>
<a href="#l19.943"></a><span id="l19.943">       this._indexingGlodaFolder = null;</span>
<a href="#l19.944"></a><span id="l19.944">       this._indexingDatabase = null;</span>
<a href="#l19.945"></a><span id="l19.945">       this._indexingIterator = null;</span>
<a href="#l19.946"></a><span id="l19.946">     }</span>
<a href="#l19.947"></a><span id="l19.947">   },</span>
<a href="#l19.948"></a><span id="l19.948" class="difflineminus">-  </span>
<a href="#l19.949"></a><span id="l19.949" class="difflineplus">+</span>
<a href="#l19.950"></a><span id="l19.950">   /**</span>
<a href="#l19.951"></a><span id="l19.951">    * Event fed to us by our nsIFolderListener when a folder is loaded.  We use</span>
<a href="#l19.952"></a><span id="l19.952">    *  this event to two ends:</span>
<a href="#l19.953"></a><span id="l19.953">    *</span>
<a href="#l19.954"></a><span id="l19.954">    * - Know when a folder we were trying to open to index is actually ready to</span>
<a href="#l19.955"></a><span id="l19.955">    *   be indexed.  (The summary may have not existed, may have been out of</span>
<a href="#l19.956"></a><span id="l19.956">    *   date, or otherwise.)</span>
<a href="#l19.957"></a><span id="l19.957" class="difflineminus">-   * - Know when </span>
<a href="#l19.958"></a><span id="l19.958" class="difflineplus">+   * - Know when</span>
<a href="#l19.959"></a><span id="l19.959">    *</span>
<a href="#l19.960"></a><span id="l19.960">    * @param aFolder An nsIMsgFolder, already QI'd.</span>
<a href="#l19.961"></a><span id="l19.961">    */</span>
<a href="#l19.962"></a><span id="l19.962">   _onFolderLoaded: function gloda_index_onFolderLoaded(aFolder) {</span>
<a href="#l19.963"></a><span id="l19.963">     if ((this._pendingFolderEntry !== null) &amp;&amp;</span>
<a href="#l19.964"></a><span id="l19.964">         (aFolder.URI == this._pendingFolderEntry.URI))</span>
<a href="#l19.965"></a><span id="l19.965">       this._indexerCompletePendingFolderEntry();</span>
<a href="#l19.966"></a><span id="l19.966">   },</span>
<a href="#l19.967"></a><span id="l19.967" class="difflineminus">-  </span>
<a href="#l19.968"></a><span id="l19.968" class="difflineplus">+</span>
<a href="#l19.969"></a><span id="l19.969">   /**</span>
<a href="#l19.970"></a><span id="l19.970">    * A simple wrapper to make 'this' be right for incrementalIndex.</span>
<a href="#l19.971"></a><span id="l19.971">    */</span>
<a href="#l19.972"></a><span id="l19.972">   _wrapCallbackDriver: function gloda_index_wrapCallbackDriver() {</span>
<a href="#l19.973"></a><span id="l19.973">     GlodaIndexer.callbackDriver();</span>
<a href="#l19.974"></a><span id="l19.974">   },</span>
<a href="#l19.975"></a><span id="l19.975"> </span>
<a href="#l19.976"></a><span id="l19.976">   /**</span>
<a href="#l19.977"></a><span id="l19.977" class="difflineat">@@ -1168,67 +1170,67 @@ var GlodaIndexer = {</span>
<a href="#l19.978"></a><span id="l19.978">    *  we re-schedule ourselves after a time delay (controlled by _indexInterval)</span>
<a href="#l19.979"></a><span id="l19.979">    *  and return.  (We use one-shot timers because repeating-slack does not</span>
<a href="#l19.980"></a><span id="l19.980">    *  know enough to deal with our (current) asynchronous nature.)</span>
<a href="#l19.981"></a><span id="l19.981">    */</span>
<a href="#l19.982"></a><span id="l19.982">   callbackDriver: function gloda_index_callbackDriver() {</span>
<a href="#l19.983"></a><span id="l19.983">     // just bail if we are shutdown</span>
<a href="#l19.984"></a><span id="l19.984">     if (this._indexerIsShutdown)</span>
<a href="#l19.985"></a><span id="l19.985">       return;</span>
<a href="#l19.986"></a><span id="l19.986" class="difflineminus">-    </span>
<a href="#l19.987"></a><span id="l19.987" class="difflineplus">+</span>
<a href="#l19.988"></a><span id="l19.988">     // it is conceivable that someone we call will call something that in some</span>
<a href="#l19.989"></a><span id="l19.989">     //  cases might be asynchronous, and in other cases immediately generate</span>
<a href="#l19.990"></a><span id="l19.990">     //  events without returning.  In the interest of (stack-depth) sanity,</span>
<a href="#l19.991"></a><span id="l19.991">     //  let's handle this by performing a minimal time-delay callback.</span>
<a href="#l19.992"></a><span id="l19.992">     // this is also now a good thing sequencing-wise.  if we get our callback</span>
<a href="#l19.993"></a><span id="l19.993">     //  with data before the underlying function has yielded, we obviously can't</span>
<a href="#l19.994"></a><span id="l19.994">     //  cram the data in yet.  Our options in this case are to either mark the</span>
<a href="#l19.995"></a><span id="l19.995">     //  fact that the callback has already happened and immediately return to</span>
<a href="#l19.996"></a><span id="l19.996">     //  the iterator when it does bubble up the kWorkAsync, or we can do as we</span>
<a href="#l19.997"></a><span id="l19.997" class="difflineminus">-    //  have been doing, but save the </span>
<a href="#l19.998"></a><span id="l19.998" class="difflineplus">+    //  have been doing, but save the</span>
<a href="#l19.999"></a><span id="l19.999">     if (this._inCallback) {</span>
<a href="#l19.1000"></a><span id="l19.1000">       this._savedCallbackArgs = arguments;</span>
<a href="#l19.1001"></a><span id="l19.1001">       this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l19.1002"></a><span id="l19.1002">                                    0,</span>
<a href="#l19.1003"></a><span id="l19.1003">                                    Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l19.1004"></a><span id="l19.1004">       return;</span>
<a href="#l19.1005"></a><span id="l19.1005">     }</span>
<a href="#l19.1006"></a><span id="l19.1006">     this._inCallback = true;</span>
<a href="#l19.1007"></a><span id="l19.1007"> </span>
<a href="#l19.1008"></a><span id="l19.1008">     try {</span>
<a href="#l19.1009"></a><span id="l19.1009">       if (this._batch === null)</span>
<a href="#l19.1010"></a><span id="l19.1010">         this._batch = this.workBatch();</span>
<a href="#l19.1011"></a><span id="l19.1011" class="difflineminus">-      </span>
<a href="#l19.1012"></a><span id="l19.1012" class="difflineplus">+</span>
<a href="#l19.1013"></a><span id="l19.1013">       // kWorkAsync, kWorkDone, kWorkPause are allowed out; kWorkSync is not</span>
<a href="#l19.1014"></a><span id="l19.1014">       // On kWorkDone, we want to schedule another timer to fire on us if we are</span>
<a href="#l19.1015"></a><span id="l19.1015">       //  not done indexing.  (On kWorkAsync, we don't care what happens, because</span>
<a href="#l19.1016"></a><span id="l19.1016">       //  someone else will be receiving the callback, and they will call us when</span>
<a href="#l19.1017"></a><span id="l19.1017">       //  they are done doing their thing.</span>
<a href="#l19.1018"></a><span id="l19.1018">       let args;</span>
<a href="#l19.1019"></a><span id="l19.1019">       if (this._savedCallbackArgs != null) {</span>
<a href="#l19.1020"></a><span id="l19.1020">         args = this._savedCallbackArgs;</span>
<a href="#l19.1021"></a><span id="l19.1021">         this._savedCallbackArgs = null;</span>
<a href="#l19.1022"></a><span id="l19.1022">       }</span>
<a href="#l19.1023"></a><span id="l19.1023">       else</span>
<a href="#l19.1024"></a><span id="l19.1024">         args = arguments; //Array.slice.call(arguments);</span>
<a href="#l19.1025"></a><span id="l19.1025" class="difflineminus">-      </span>
<a href="#l19.1026"></a><span id="l19.1026" class="difflineplus">+</span>
<a href="#l19.1027"></a><span id="l19.1027">       let result;</span>
<a href="#l19.1028"></a><span id="l19.1028">       if (args.length == 0)</span>
<a href="#l19.1029"></a><span id="l19.1029">         result = this._batch.next();</span>
<a href="#l19.1030"></a><span id="l19.1030">       else if (args.length == 1)</span>
<a href="#l19.1031"></a><span id="l19.1031">         result = this._batch.send(args[0]);</span>
<a href="#l19.1032"></a><span id="l19.1032">       else // arguments works with destructuring assignment</span>
<a href="#l19.1033"></a><span id="l19.1033">         result = this._batch.send(args);</span>
<a href="#l19.1034"></a><span id="l19.1034">       switch (result) {</span>
<a href="#l19.1035"></a><span id="l19.1035">         // job's done, close the batch and re-schedule ourselves if there's more</span>
<a href="#l19.1036"></a><span id="l19.1036">         //  to do.</span>
<a href="#l19.1037"></a><span id="l19.1037">         case this.kWorkDone:</span>
<a href="#l19.1038"></a><span id="l19.1038">           this._batch.close();</span>
<a href="#l19.1039"></a><span id="l19.1039">           this._batch = null;</span>
<a href="#l19.1040"></a><span id="l19.1040" class="difflineminus">-          // (intentional fall-through to re-scheduling logic) </span>
<a href="#l19.1041"></a><span id="l19.1041" class="difflineplus">+          // (intentional fall-through to re-scheduling logic)</span>
<a href="#l19.1042"></a><span id="l19.1042">         // the batch wants to get re-scheduled, do so.</span>
<a href="#l19.1043"></a><span id="l19.1043">         case this.kWorkPause:</span>
<a href="#l19.1044"></a><span id="l19.1044">           if (this.indexing)</span>
<a href="#l19.1045"></a><span id="l19.1045">             this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l19.1046"></a><span id="l19.1046">                                          this._indexInterval,</span>
<a href="#l19.1047"></a><span id="l19.1047">                                          Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l19.1048"></a><span id="l19.1048">           else { // it's important to indicate no more callbacks are in flight</span>
<a href="#l19.1049"></a><span id="l19.1049">             this._indexingActive = false;</span>
<a href="#l19.1050"></a><span id="l19.1050" class="difflineat">@@ -1237,17 +1239,17 @@ var GlodaIndexer = {</span>
<a href="#l19.1051"></a><span id="l19.1051">           }</span>
<a href="#l19.1052"></a><span id="l19.1052">           break;</span>
<a href="#l19.1053"></a><span id="l19.1053">         case this.kWorkAsync:</span>
<a href="#l19.1054"></a><span id="l19.1054">           // there is nothing to do.  some other code is now responsible for</span>
<a href="#l19.1055"></a><span id="l19.1055">           //  calling us.</span>
<a href="#l19.1056"></a><span id="l19.1056">           break;</span>
<a href="#l19.1057"></a><span id="l19.1057">       }</span>
<a href="#l19.1058"></a><span id="l19.1058">     }</span>
<a href="#l19.1059"></a><span id="l19.1059" class="difflineminus">-    finally {    </span>
<a href="#l19.1060"></a><span id="l19.1060" class="difflineplus">+    finally {</span>
<a href="#l19.1061"></a><span id="l19.1061">       this._inCallback = false;</span>
<a href="#l19.1062"></a><span id="l19.1062">     }</span>
<a href="#l19.1063"></a><span id="l19.1063">   },</span>
<a href="#l19.1064"></a><span id="l19.1064"> </span>
<a href="#l19.1065"></a><span id="l19.1065">   _callbackHandle: {</span>
<a href="#l19.1066"></a><span id="l19.1066">     init: function gloda_index_callbackhandle_init() {</span>
<a href="#l19.1067"></a><span id="l19.1067">       this.wrappedCallback = GlodaIndexer._wrapCallbackDriver;</span>
<a href="#l19.1068"></a><span id="l19.1068">       this.callbackThis = GlodaIndexer;</span>
<a href="#l19.1069"></a><span id="l19.1069" class="difflineat">@@ -1288,17 +1290,17 @@ var GlodaIndexer = {</span>
<a href="#l19.1070"></a><span id="l19.1070">       this._result = null;</span>
<a href="#l19.1071"></a><span id="l19.1071">       return result;</span>
<a href="#l19.1072"></a><span id="l19.1072">     },</span>
<a href="#l19.1073"></a><span id="l19.1073">     _result: null,</span>
<a href="#l19.1074"></a><span id="l19.1074">     doneWithResult: function gloda_index_callbackhandle_doneWithResult(aResult){</span>
<a href="#l19.1075"></a><span id="l19.1075">       this._result = aResult;</span>
<a href="#l19.1076"></a><span id="l19.1076">       return Gloda.kWorkDoneWithResult;</span>
<a href="#l19.1077"></a><span id="l19.1077">     },</span>
<a href="#l19.1078"></a><span id="l19.1078" class="difflineminus">-    </span>
<a href="#l19.1079"></a><span id="l19.1079" class="difflineplus">+</span>
<a href="#l19.1080"></a><span id="l19.1080">     /* be able to serve as a collection listener, resuming the active iterator's</span>
<a href="#l19.1081"></a><span id="l19.1081">        last yield kWorkAsync */</span>
<a href="#l19.1082"></a><span id="l19.1082">     onItemsAdded: function() {},</span>
<a href="#l19.1083"></a><span id="l19.1083">     onItemsModified: function() {},</span>
<a href="#l19.1084"></a><span id="l19.1084">     onItemsRemoved: function() {},</span>
<a href="#l19.1085"></a><span id="l19.1085">     onQueryCompleted: function(aCollection) {</span>
<a href="#l19.1086"></a><span id="l19.1086">       GlodaIndexer.callbackDriver();</span>
<a href="#l19.1087"></a><span id="l19.1087">     }</span>
<a href="#l19.1088"></a><span id="l19.1088" class="difflineat">@@ -1307,17 +1309,17 @@ var GlodaIndexer = {</span>
<a href="#l19.1089"></a><span id="l19.1089">   /**</span>
<a href="#l19.1090"></a><span id="l19.1090">    * The workBatch generator handles a single 'batch' of processing, managing</span>
<a href="#l19.1091"></a><span id="l19.1091">    *  the database transaction and keeping track of &quot;tokens&quot;.  It drives the</span>
<a href="#l19.1092"></a><span id="l19.1092">    *  _actualWorker generator which is doing the work.</span>
<a href="#l19.1093"></a><span id="l19.1093">    * workBatch will only produce kWorkAsync and kWorkDone notifications.</span>
<a href="#l19.1094"></a><span id="l19.1094">    *  If _actualWorker returns kWorkSync and there are still tokens available,</span>
<a href="#l19.1095"></a><span id="l19.1095">    *  workBatch will keep driving _actualWorker until it encounters a</span>
<a href="#l19.1096"></a><span id="l19.1096">    *  kWorkAsync (which workBatch will yield to callbackDriver), or it runs</span>
<a href="#l19.1097"></a><span id="l19.1097" class="difflineminus">-   *  out of tokens and yields a kWorkDone. </span>
<a href="#l19.1098"></a><span id="l19.1098" class="difflineplus">+   *  out of tokens and yields a kWorkDone.</span>
<a href="#l19.1099"></a><span id="l19.1099">    */</span>
<a href="#l19.1100"></a><span id="l19.1100">   workBatch: function gloda_index_workBatch() {</span>
<a href="#l19.1101"></a><span id="l19.1101">     let commitTokens = this._indexCommitTokens;</span>
<a href="#l19.1102"></a><span id="l19.1102">     GlodaDatastore._beginTransaction();</span>
<a href="#l19.1103"></a><span id="l19.1103"> </span>
<a href="#l19.1104"></a><span id="l19.1104">     while (commitTokens &gt; 0) {</span>
<a href="#l19.1105"></a><span id="l19.1105">       // both explicit work activity points (sync + async) and transfer of</span>
<a href="#l19.1106"></a><span id="l19.1106">       //  control return (via kWorkDone*) results in a token being eaten.  The</span>
<a href="#l19.1107"></a><span id="l19.1107" class="difflineat">@@ -1328,23 +1330,23 @@ var GlodaIndexer = {</span>
<a href="#l19.1108"></a><span id="l19.1108">       for (let tokensLeft = this._indexTokens; tokensLeft &gt; 0;</span>
<a href="#l19.1109"></a><span id="l19.1109">           tokensLeft--, commitTokens--) {</span>
<a href="#l19.1110"></a><span id="l19.1110">         // we need to periodically force a GC to avoid excessive process size</span>
<a href="#l19.1111"></a><span id="l19.1111">         //  and because nsAutoLock is a jerk on debug builds</span>
<a href="#l19.1112"></a><span id="l19.1112">         // there is a constant in GlodaUtils that may need to be adjusted (and</span>
<a href="#l19.1113"></a><span id="l19.1113">         //  potentially augmented with time-awareness) as token logic is</span>
<a href="#l19.1114"></a><span id="l19.1114">         //  adjusted; or just for tuning purposes.</span>
<a href="#l19.1115"></a><span id="l19.1115">         GlodaUtils.maybeGarbageCollect();</span>
<a href="#l19.1116"></a><span id="l19.1116" class="difflineminus">-        </span>
<a href="#l19.1117"></a><span id="l19.1117" class="difflineplus">+</span>
<a href="#l19.1118"></a><span id="l19.1118">         if ((this._callbackHandle.activeIterator === null) &amp;&amp;</span>
<a href="#l19.1119"></a><span id="l19.1119">             !this._hireJobWorker()) {</span>
<a href="#l19.1120"></a><span id="l19.1120">           commitTokens = 0;</span>
<a href="#l19.1121"></a><span id="l19.1121">           break;</span>
<a href="#l19.1122"></a><span id="l19.1122">         }</span>
<a href="#l19.1123"></a><span id="l19.1123" class="difflineminus">-      </span>
<a href="#l19.1124"></a><span id="l19.1124" class="difflineplus">+</span>
<a href="#l19.1125"></a><span id="l19.1125">         // XXX for performance, we may want to move the try outside the for loop</span>
<a href="#l19.1126"></a><span id="l19.1126">         //  with a quasi-redundant outer loop that shunts control back inside</span>
<a href="#l19.1127"></a><span id="l19.1127">         //  if we left the loop due to an exception (without consuming all the</span>
<a href="#l19.1128"></a><span id="l19.1128">         //  tokens.)</span>
<a href="#l19.1129"></a><span id="l19.1129">         try {</span>
<a href="#l19.1130"></a><span id="l19.1130">           switch (this._callbackHandle.activeIterator.send(this._workBatchData)) {</span>
<a href="#l19.1131"></a><span id="l19.1131">             case this.kWorkSync:</span>
<a href="#l19.1132"></a><span id="l19.1132">               this._workBatchData = undefined;</span>
<a href="#l19.1133"></a><span id="l19.1133" class="difflineat">@@ -1359,17 +1361,17 @@ var GlodaIndexer = {</span>
<a href="#l19.1134"></a><span id="l19.1134">             case this.kWorkDoneWithResult:</span>
<a href="#l19.1135"></a><span id="l19.1135">               this._workBatchData = this._callbackHandle.popWithResult();</span>
<a href="#l19.1136"></a><span id="l19.1136">               continue;</span>
<a href="#l19.1137"></a><span id="l19.1137">           }</span>
<a href="#l19.1138"></a><span id="l19.1138">         }</span>
<a href="#l19.1139"></a><span id="l19.1139">         catch (ex) {</span>
<a href="#l19.1140"></a><span id="l19.1140">           // Try and recover if the job is recoverable and the iterator that</span>
<a href="#l19.1141"></a><span id="l19.1141">           //  experienced the problem wasn't the job worker.  (If it was the</span>
<a href="#l19.1142"></a><span id="l19.1142" class="difflineminus">-          //  job worker, we can't rely on its state to be intact.) </span>
<a href="#l19.1143"></a><span id="l19.1143" class="difflineplus">+          //  job worker, we can't rely on its state to be intact.)</span>
<a href="#l19.1144"></a><span id="l19.1144">           if (this._curIndexingJob.recoverable &gt; 0 &amp;&amp;</span>
<a href="#l19.1145"></a><span id="l19.1145">               this._callbackHandle.activeStack.length &gt; 1) {</span>
<a href="#l19.1146"></a><span id="l19.1146">             this._curIndexingJob.recoverable--;</span>
<a href="#l19.1147"></a><span id="l19.1147">             this._log.warn(&quot;Problem during job, trying to recover.  Problem &quot; +</span>
<a href="#l19.1148"></a><span id="l19.1148">               &quot;was at &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l19.1149"></a><span id="l19.1149">             // cleanup but leave the job's iterator intact.</span>
<a href="#l19.1150"></a><span id="l19.1150">             this._callbackHandle.cleanup(1);</span>
<a href="#l19.1151"></a><span id="l19.1151">             // the data must now be invalid</span>
<a href="#l19.1152"></a><span id="l19.1152" class="difflineat">@@ -1382,92 +1384,92 @@ var GlodaIndexer = {</span>
<a href="#l19.1153"></a><span id="l19.1153">             this._indexerLeaveFolder(true);</span>
<a href="#l19.1154"></a><span id="l19.1154">             this._curIndexingJob = null;</span>
<a href="#l19.1155"></a><span id="l19.1155">             // clear out our current generators and our related data</span>
<a href="#l19.1156"></a><span id="l19.1156">             this._callbackHandle.cleanup();</span>
<a href="#l19.1157"></a><span id="l19.1157">             this._workBatchData = undefined;</span>
<a href="#l19.1158"></a><span id="l19.1158">           }</span>
<a href="#l19.1159"></a><span id="l19.1159">         }</span>
<a href="#l19.1160"></a><span id="l19.1160">       }</span>
<a href="#l19.1161"></a><span id="l19.1161" class="difflineminus">-      </span>
<a href="#l19.1162"></a><span id="l19.1162" class="difflineplus">+</span>
<a href="#l19.1163"></a><span id="l19.1163">       // take a breather by having the caller re-schedule us sometime in the</span>
<a href="#l19.1164"></a><span id="l19.1164">       //  future, but only if we're going to perform another loop iteration.</span>
<a href="#l19.1165"></a><span id="l19.1165">       if (commitTokens &gt; 0)</span>
<a href="#l19.1166"></a><span id="l19.1166">         yield this.kWorkPause;</span>
<a href="#l19.1167"></a><span id="l19.1167">     }</span>
<a href="#l19.1168"></a><span id="l19.1168">     // XXX doing the dirty commit/check every time could be pretty expensive...</span>
<a href="#l19.1169"></a><span id="l19.1169">     GlodaCollectionManager.cacheCommitDirty();</span>
<a href="#l19.1170"></a><span id="l19.1170">     GlodaDatastore._commitTransaction();</span>
<a href="#l19.1171"></a><span id="l19.1171" class="difflineminus">-    </span>
<a href="#l19.1172"></a><span id="l19.1172" class="difflineplus">+</span>
<a href="#l19.1173"></a><span id="l19.1173">     // try and get a job if we don't have one for the sake of the notification</span>
<a href="#l19.1174"></a><span id="l19.1174">     if (this.indexing &amp;&amp; (this._actualWorker === null))</span>
<a href="#l19.1175"></a><span id="l19.1175">       this._hireJobWorker();</span>
<a href="#l19.1176"></a><span id="l19.1176">     else</span>
<a href="#l19.1177"></a><span id="l19.1177">       this._notifyListeners();</span>
<a href="#l19.1178"></a><span id="l19.1178" class="difflineminus">-    </span>
<a href="#l19.1179"></a><span id="l19.1179" class="difflineplus">+</span>
<a href="#l19.1180"></a><span id="l19.1180">     yield this.kWorkDone;</span>
<a href="#l19.1181"></a><span id="l19.1181">   },</span>
<a href="#l19.1182"></a><span id="l19.1182"> </span>
<a href="#l19.1183"></a><span id="l19.1183">   _otherIndexerWorkers: {},</span>
<a href="#l19.1184"></a><span id="l19.1184">   /**</span>
<a href="#l19.1185"></a><span id="l19.1185">    * Perform the initialization step and return a generator if there is any</span>
<a href="#l19.1186"></a><span id="l19.1186">    *  steady-state processing to be had.</span>
<a href="#l19.1187"></a><span id="l19.1187">    */</span>
<a href="#l19.1188"></a><span id="l19.1188">   _hireJobWorker: function gloda_index_hireJobWorker() {</span>
<a href="#l19.1189"></a><span id="l19.1189">     if (this._indexQueue.length == 0) {</span>
<a href="#l19.1190"></a><span id="l19.1190">       this._log.info(&quot;--- Done indexing, disabling timer renewal.&quot;);</span>
<a href="#l19.1191"></a><span id="l19.1191" class="difflineminus">-      </span>
<a href="#l19.1192"></a><span id="l19.1192" class="difflineplus">+</span>
<a href="#l19.1193"></a><span id="l19.1193">       if (this._indexingFolder !== null) {</span>
<a href="#l19.1194"></a><span id="l19.1194">         this._indexerLeaveFolder(true);</span>
<a href="#l19.1195"></a><span id="l19.1195">       }</span>
<a href="#l19.1196"></a><span id="l19.1196" class="difflineminus">-      </span>
<a href="#l19.1197"></a><span id="l19.1197" class="difflineplus">+</span>
<a href="#l19.1198"></a><span id="l19.1198">       this._curIndexingJob = null;</span>
<a href="#l19.1199"></a><span id="l19.1199">       this._indexingDesired = false;</span>
<a href="#l19.1200"></a><span id="l19.1200">       // we're not indexing anymore, so we're not sampling anymore</span>
<a href="#l19.1201"></a><span id="l19.1201">       this.perfSampling = false;</span>
<a href="#l19.1202"></a><span id="l19.1202">       this._indexingJobCount = 0;</span>
<a href="#l19.1203"></a><span id="l19.1203">       this._indexingJobGoal = 0;</span>
<a href="#l19.1204"></a><span id="l19.1204">       return false;</span>
<a href="#l19.1205"></a><span id="l19.1205">     }</span>
<a href="#l19.1206"></a><span id="l19.1206"> </span>
<a href="#l19.1207"></a><span id="l19.1207">     //this._log.debug(&quot;++ Pulling job from queue of size &quot; +</span>
<a href="#l19.1208"></a><span id="l19.1208">     //                this._indexQueue.length);</span>
<a href="#l19.1209"></a><span id="l19.1209">     let job = this._curIndexingJob = this._indexQueue.shift();</span>
<a href="#l19.1210"></a><span id="l19.1210">     this._indexingJobCount++;</span>
<a href="#l19.1211"></a><span id="l19.1211">     //this._log.debug(&quot;++ Pulled job: &quot; + job.jobType + &quot;, &quot; +</span>
<a href="#l19.1212"></a><span id="l19.1212">     //                job.deltaType + &quot;, &quot; + job.id);</span>
<a href="#l19.1213"></a><span id="l19.1213">     let generator = null;</span>
<a href="#l19.1214"></a><span id="l19.1214" class="difflineminus">-    </span>
<a href="#l19.1215"></a><span id="l19.1215" class="difflineplus">+</span>
<a href="#l19.1216"></a><span id="l19.1216">     if (job.jobType == &quot;sweep&quot;) {</span>
<a href="#l19.1217"></a><span id="l19.1217">       generator = this._worker_indexingSweep(job);</span>
<a href="#l19.1218"></a><span id="l19.1218">     }</span>
<a href="#l19.1219"></a><span id="l19.1219">     else if (job.jobType == &quot;folder&quot;) {</span>
<a href="#l19.1220"></a><span id="l19.1220">       generator = this._worker_folderIndex(job);</span>
<a href="#l19.1221"></a><span id="l19.1221">     }</span>
<a href="#l19.1222"></a><span id="l19.1222">     else if(job.jobType == &quot;message&quot;) {</span>
<a href="#l19.1223"></a><span id="l19.1223">       // we do not want new work items to be added as we are processing, so</span>
<a href="#l19.1224"></a><span id="l19.1224">       //  clear _pendingAddJob.  A new job will be created as needed.</span>
<a href="#l19.1225"></a><span id="l19.1225">       if (job === this._pendingAddJob)</span>
<a href="#l19.1226"></a><span id="l19.1226">         this._pendingAddJob = null;</span>
<a href="#l19.1227"></a><span id="l19.1227">       // update our goal from the items length</span>
<a href="#l19.1228"></a><span id="l19.1228">       job.goal = job.items.length;</span>
<a href="#l19.1229"></a><span id="l19.1229" class="difflineminus">-                  </span>
<a href="#l19.1230"></a><span id="l19.1230" class="difflineplus">+</span>
<a href="#l19.1231"></a><span id="l19.1231">       generator = this._worker_messageIndex(job);</span>
<a href="#l19.1232"></a><span id="l19.1232">     }</span>
<a href="#l19.1233"></a><span id="l19.1233">     else if (job.jobType == &quot;delete&quot;) {</span>
<a href="#l19.1234"></a><span id="l19.1234">       // we'll count the block processing as a cost of 1...</span>
<a href="#l19.1235"></a><span id="l19.1235">       job.goal = 1;</span>
<a href="#l19.1236"></a><span id="l19.1236">       generator = this._worker_processDeletes(job);</span>
<a href="#l19.1237"></a><span id="l19.1237">     }</span>
<a href="#l19.1238"></a><span id="l19.1238">     else if (job.jobType in this._otherIndexerWorkers) {</span>
<a href="#l19.1239"></a><span id="l19.1239">       let [indexer, workerFunc] = this._otherIndexerWorkers[job.jobType];</span>
<a href="#l19.1240"></a><span id="l19.1240">       generator = workerFunc.call(indexer, job, this._callbackHandle);</span>
<a href="#l19.1241"></a><span id="l19.1241">     }</span>
<a href="#l19.1242"></a><span id="l19.1242">     else {</span>
<a href="#l19.1243"></a><span id="l19.1243" class="difflineminus">-      this._log.warning(&quot;Unknown job type: &quot; + job.jobType);</span>
<a href="#l19.1244"></a><span id="l19.1244" class="difflineplus">+      this._log.warn(&quot;Unknown job type: &quot; + job.jobType);</span>
<a href="#l19.1245"></a><span id="l19.1245">     }</span>
<a href="#l19.1246"></a><span id="l19.1246"> </span>
<a href="#l19.1247"></a><span id="l19.1247">     this._notifyListeners();</span>
<a href="#l19.1248"></a><span id="l19.1248"> </span>
<a href="#l19.1249"></a><span id="l19.1249">     if (generator) {</span>
<a href="#l19.1250"></a><span id="l19.1250">       this._callbackHandle.push(generator);</span>
<a href="#l19.1251"></a><span id="l19.1251">       return true;</span>
<a href="#l19.1252"></a><span id="l19.1252">     }</span>
<a href="#l19.1253"></a><span id="l19.1253" class="difflineat">@@ -1487,119 +1489,119 @@ var GlodaIndexer = {</span>
<a href="#l19.1254"></a><span id="l19.1254">    *  folder to index.  This avoids needing to maintain a perfect model of the</span>
<a href="#l19.1255"></a><span id="l19.1255">    *  folder hierarchy at all times.  (We may eventually want to do that, but</span>
<a href="#l19.1256"></a><span id="l19.1256">    *  this is sufficient and safe for now.)  Although our use of dirty flags on</span>
<a href="#l19.1257"></a><span id="l19.1257">    *  the folders allows us to avoid tracking the 'last folder' we processed,</span>
<a href="#l19.1258"></a><span id="l19.1258">    *  we do so to avoid getting 'trapped' in a folder with a high rate of</span>
<a href="#l19.1259"></a><span id="l19.1259">    *  changes.</span>
<a href="#l19.1260"></a><span id="l19.1260">    */</span>
<a href="#l19.1261"></a><span id="l19.1261">   _worker_indexingSweep: function gloda_worker_indexingSweep(aJob) {</span>
<a href="#l19.1262"></a><span id="l19.1262" class="difflineminus">-    // walk the folders</span>
<a href="#l19.1263"></a><span id="l19.1263" class="difflineminus">-    let accountManager = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;].</span>
<a href="#l19.1264"></a><span id="l19.1264" class="difflineplus">+    if (!aJob.mappedFolders) {</span>
<a href="#l19.1265"></a><span id="l19.1265" class="difflineplus">+      // Walk the folders and make sure all the folders we would want to index</span>
<a href="#l19.1266"></a><span id="l19.1266" class="difflineplus">+      //  are mapped.  Build up a list of GlodaFolders as we go, so that we can</span>
<a href="#l19.1267"></a><span id="l19.1267" class="difflineplus">+      //  sort them by their indexing priority.</span>
<a href="#l19.1268"></a><span id="l19.1268" class="difflineplus">+      let foldersToProcess = aJob.foldersToProcess = [];</span>
<a href="#l19.1269"></a><span id="l19.1269" class="difflineplus">+</span>
<a href="#l19.1270"></a><span id="l19.1270" class="difflineplus">+      let accountManager = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;].</span>
<a href="#l19.1271"></a><span id="l19.1271">                            getService(Ci.nsIMsgAccountManager);</span>
<a href="#l19.1272"></a><span id="l19.1272" class="difflineminus">-    let servers = accountManager.allServers;</span>
<a href="#l19.1273"></a><span id="l19.1273" class="difflineminus">-    let useNextFolder = false;</span>
<a href="#l19.1274"></a><span id="l19.1274" class="difflineminus">-    </span>
<a href="#l19.1275"></a><span id="l19.1275" class="difflineminus">-    if (aJob.lastFolderIndexedUri === undefined)</span>
<a href="#l19.1276"></a><span id="l19.1276" class="difflineminus">-      aJob.lastFolderIndexedUri = '';</span>
<a href="#l19.1277"></a><span id="l19.1277" class="difflineminus">-  </span>
<a href="#l19.1278"></a><span id="l19.1278" class="difflineminus">-    for (let i = 0; i &lt; servers.Count(); i++)</span>
<a href="#l19.1279"></a><span id="l19.1279" class="difflineminus">-    {</span>
<a href="#l19.1280"></a><span id="l19.1280" class="difflineminus">-      let server = servers.QueryElementAt(i, Ci.nsIMsgIncomingServer);</span>
<a href="#l19.1281"></a><span id="l19.1281" class="difflineminus">-      let rootFolder = server.rootFolder;</span>
<a href="#l19.1282"></a><span id="l19.1282" class="difflineminus">-      </span>
<a href="#l19.1283"></a><span id="l19.1283" class="difflineminus">-      let allFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l19.1284"></a><span id="l19.1284" class="difflineminus">-                         createInstance(Ci.nsISupportsArray);</span>
<a href="#l19.1285"></a><span id="l19.1285" class="difflineminus">-      rootFolder.ListDescendents(allFolders);</span>
<a href="#l19.1286"></a><span id="l19.1286" class="difflineminus">-      let numFolders = allFolders.Count();</span>
<a href="#l19.1287"></a><span id="l19.1287" class="difflineminus">-      for (let folderIndex = 0; folderIndex &lt; numFolders; folderIndex++)</span>
<a href="#l19.1288"></a><span id="l19.1288" class="difflineminus">-      {</span>
<a href="#l19.1289"></a><span id="l19.1289" class="difflineminus">-        let folder = allFolders.GetElementAt(folderIndex).QueryInterface(</span>
<a href="#l19.1290"></a><span id="l19.1290" class="difflineminus">-                                                            Ci.nsIMsgFolder);</span>
<a href="#l19.1291"></a><span id="l19.1291" class="difflineplus">+      let servers = accountManager.allServers;</span>
<a href="#l19.1292"></a><span id="l19.1292" class="difflineplus">+      for (let i = 0; i &lt; servers.Count(); i++) {</span>
<a href="#l19.1293"></a><span id="l19.1293" class="difflineplus">+        let server = servers.QueryElementAt(i, Ci.nsIMsgIncomingServer);</span>
<a href="#l19.1294"></a><span id="l19.1294" class="difflineplus">+        let rootFolder = server.rootFolder;</span>
<a href="#l19.1295"></a><span id="l19.1295"> </span>
<a href="#l19.1296"></a><span id="l19.1296" class="difflineminus">-        if (!this.shouldIndexFolder(folder))</span>
<a href="#l19.1297"></a><span id="l19.1297" class="difflineminus">-          continue;</span>
<a href="#l19.1298"></a><span id="l19.1298" class="difflineminus">-        </span>
<a href="#l19.1299"></a><span id="l19.1299" class="difflineminus">-        // we could also check nsMsgFolderFlags.Mail conceivably...</span>
<a href="#l19.1300"></a><span id="l19.1300" class="difflineminus">-        let isLocal = folder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l19.1301"></a><span id="l19.1301" class="difflineminus">-        // we only index local folders or IMAP folders that are marked offline.</span>
<a href="#l19.1302"></a><span id="l19.1302" class="difflineminus">-        if (!isLocal &amp;&amp; !(folder.flags &amp; Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l19.1303"></a><span id="l19.1303" class="difflineminus">-          continue;</span>
<a href="#l19.1304"></a><span id="l19.1304" class="difflineplus">+        let allFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l19.1305"></a><span id="l19.1305" class="difflineplus">+          createInstance(Ci.nsISupportsArray);</span>
<a href="#l19.1306"></a><span id="l19.1306" class="difflineplus">+        rootFolder.ListDescendents(allFolders);</span>
<a href="#l19.1307"></a><span id="l19.1307" class="difflineplus">+        let numFolders = allFolders.Count();</span>
<a href="#l19.1308"></a><span id="l19.1308" class="difflineplus">+        for (let folderIndex = 0; folderIndex &lt; numFolders; folderIndex++) {</span>
<a href="#l19.1309"></a><span id="l19.1309" class="difflineplus">+          let folder = allFolders.GetElementAt(folderIndex).QueryInterface(</span>
<a href="#l19.1310"></a><span id="l19.1310" class="difflineplus">+            Ci.nsIMsgFolder);</span>
<a href="#l19.1311"></a><span id="l19.1311" class="difflineplus">+          if (!this.shouldIndexFolder(folder))</span>
<a href="#l19.1312"></a><span id="l19.1312" class="difflineplus">+            continue;</span>
<a href="#l19.1313"></a><span id="l19.1313" class="difflineplus">+          // we could also check nsMsgFolderFlags.Mail conceivably...</span>
<a href="#l19.1314"></a><span id="l19.1314" class="difflineplus">+          let isLocal = folder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l19.1315"></a><span id="l19.1315" class="difflineplus">+          // we only index local folders or IMAP folders that are marked offline</span>
<a href="#l19.1316"></a><span id="l19.1316" class="difflineplus">+          if (!isLocal &amp;&amp; !(folder.flags &amp; Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l19.1317"></a><span id="l19.1317" class="difflineplus">+            continue;</span>
<a href="#l19.1318"></a><span id="l19.1318"> </span>
<a href="#l19.1319"></a><span id="l19.1319" class="difflineminus">-        // if no folder was indexed (or the pref's not set), just use the first folder</span>
<a href="#l19.1320"></a><span id="l19.1320" class="difflineminus">-        if (!aJob.lastFolderIndexedUri || useNextFolder)</span>
<a href="#l19.1321"></a><span id="l19.1321" class="difflineminus">-        {</span>
<a href="#l19.1322"></a><span id="l19.1322" class="difflineminus">-          // make sure the folder is dirty before accepting this job...</span>
<a href="#l19.1323"></a><span id="l19.1323" class="difflineminus">-          let glodaFolder = GlodaDatastore._mapFolder(folder);</span>
<a href="#l19.1324"></a><span id="l19.1324" class="difflineminus">-          if (!glodaFolder.dirtyStatus)</span>
<a href="#l19.1325"></a><span id="l19.1325" class="difflineminus">-            continue;</span>
<a href="#l19.1326"></a><span id="l19.1326" class="difflineminus">-        </span>
<a href="#l19.1327"></a><span id="l19.1327" class="difflineminus">-          aJob.lastFolderIndexedUri = folder.URI;</span>
<a href="#l19.1328"></a><span id="l19.1328" class="difflineminus">-          this._indexingJobGoal += 2;</span>
<a href="#l19.1329"></a><span id="l19.1329" class="difflineminus">-          // add a job for the folder indexing</span>
<a href="#l19.1330"></a><span id="l19.1330" class="difflineminus">-          this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 0,</span>
<a href="#l19.1331"></a><span id="l19.1331" class="difflineminus">-              this._datastore._mapFolder(folder).id));</span>
<a href="#l19.1332"></a><span id="l19.1332" class="difflineminus">-          // re-schedule this job (although this worker will die)</span>
<a href="#l19.1333"></a><span id="l19.1333" class="difflineminus">-          this._indexQueue.push(aJob);</span>
<a href="#l19.1334"></a><span id="l19.1334" class="difflineminus">-          yield this.kWorkDone;</span>
<a href="#l19.1335"></a><span id="l19.1335" class="difflineminus">-        }</span>
<a href="#l19.1336"></a><span id="l19.1336" class="difflineminus">-        else</span>
<a href="#l19.1337"></a><span id="l19.1337" class="difflineminus">-        {</span>
<a href="#l19.1338"></a><span id="l19.1338" class="difflineminus">-          if (aJob.lastFolderIndexedUri == folder.URI)</span>
<a href="#l19.1339"></a><span id="l19.1339" class="difflineminus">-            useNextFolder = true;</span>
<a href="#l19.1340"></a><span id="l19.1340" class="difflineplus">+          let glodaFolder = Gloda.getFolderForFolder(folder);</span>
<a href="#l19.1341"></a><span id="l19.1341" class="difflineplus">+          if (glodaFolder.indexingPriority !=</span>
<a href="#l19.1342"></a><span id="l19.1342" class="difflineplus">+              glodaFolder.kIndexingNeverPriority)</span>
<a href="#l19.1343"></a><span id="l19.1343" class="difflineplus">+            foldersToProcess.push(glodaFolder);</span>
<a href="#l19.1344"></a><span id="l19.1344">         }</span>
<a href="#l19.1345"></a><span id="l19.1345">       }</span>
<a href="#l19.1346"></a><span id="l19.1346" class="difflineplus">+</span>
<a href="#l19.1347"></a><span id="l19.1347" class="difflineplus">+      // sort the folders by priority (descending)</span>
<a href="#l19.1348"></a><span id="l19.1348" class="difflineplus">+      foldersToProcess.sort(function (a, b) {</span>
<a href="#l19.1349"></a><span id="l19.1349" class="difflineplus">+        return b.indexingPriority - a.indexingPriority;</span>
<a href="#l19.1350"></a><span id="l19.1350" class="difflineplus">+      });</span>
<a href="#l19.1351"></a><span id="l19.1351" class="difflineplus">+</span>
<a href="#l19.1352"></a><span id="l19.1352" class="difflineplus">+      aJob.mappedFolders = true;</span>
<a href="#l19.1353"></a><span id="l19.1353">     }</span>
<a href="#l19.1354"></a><span id="l19.1354" class="difflineminus">-    </span>
<a href="#l19.1355"></a><span id="l19.1355" class="difflineplus">+</span>
<a href="#l19.1356"></a><span id="l19.1356" class="difflineplus">+    // - process the folders (in sorted order)</span>
<a href="#l19.1357"></a><span id="l19.1357" class="difflineplus">+    while (aJob.foldersToProcess.length) {</span>
<a href="#l19.1358"></a><span id="l19.1358" class="difflineplus">+      let glodaFolder = aJob.foldersToProcess.shift();</span>
<a href="#l19.1359"></a><span id="l19.1359" class="difflineplus">+      if (glodaFolder._deleted || !glodaFolder.dirtyStatus)</span>
<a href="#l19.1360"></a><span id="l19.1360" class="difflineplus">+        continue;</span>
<a href="#l19.1361"></a><span id="l19.1361" class="difflineplus">+</span>
<a href="#l19.1362"></a><span id="l19.1362" class="difflineplus">+      this._indexingJobGoal += 2;</span>
<a href="#l19.1363"></a><span id="l19.1363" class="difflineplus">+      // add a job for the folder indexing</span>
<a href="#l19.1364"></a><span id="l19.1364" class="difflineplus">+      this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 0, glodaFolder.id));</span>
<a href="#l19.1365"></a><span id="l19.1365" class="difflineplus">+      // re-schedule this job (although this worker will die)</span>
<a href="#l19.1366"></a><span id="l19.1366" class="difflineplus">+      this._indexQueue.push(aJob);</span>
<a href="#l19.1367"></a><span id="l19.1367" class="difflineplus">+      yield this.kWorkDone;</span>
<a href="#l19.1368"></a><span id="l19.1368" class="difflineplus">+    }</span>
<a href="#l19.1369"></a><span id="l19.1369" class="difflineplus">+</span>
<a href="#l19.1370"></a><span id="l19.1370">     // consider deletion</span>
<a href="#l19.1371"></a><span id="l19.1371">     if (this.pendingDeletion || this.pendingDeletion === null) {</span>
<a href="#l19.1372"></a><span id="l19.1372">       this._indexingJobGoal++;</span>
<a href="#l19.1373"></a><span id="l19.1373">       this._indexQueue.push(new IndexingJob(&quot;delete&quot;, 0, null));</span>
<a href="#l19.1374"></a><span id="l19.1374">       // no need to set this.indexing to true, it must be true if we are here.</span>
<a href="#l19.1375"></a><span id="l19.1375">     }</span>
<a href="#l19.1376"></a><span id="l19.1376" class="difflineminus">-    </span>
<a href="#l19.1377"></a><span id="l19.1377" class="difflineplus">+</span>
<a href="#l19.1378"></a><span id="l19.1378">     // if this is our first sweep, give the other indexers a chance to do their</span>
<a href="#l19.1379"></a><span id="l19.1379">     //  own initial sweep.  it's on them to schedule their own job if they have</span>
<a href="#l19.1380"></a><span id="l19.1380">     //  a lot to do, but if they only have a little to do, they can get away</span>
<a href="#l19.1381"></a><span id="l19.1381">     //  with it, as we yield a sync after each one.</span>
<a href="#l19.1382"></a><span id="l19.1382">     if (!this._initialSweepPerformed) {</span>
<a href="#l19.1383"></a><span id="l19.1383">       for each (let [iIndexer, indexer] in Iterator(this._otherIndexers)) {</span>
<a href="#l19.1384"></a><span id="l19.1384">         try {</span>
<a href="#l19.1385"></a><span id="l19.1385">           indexer.initialSweep();</span>
<a href="#l19.1386"></a><span id="l19.1386">         }</span>
<a href="#l19.1387"></a><span id="l19.1387">         catch (ex) {</span>
<a href="#l19.1388"></a><span id="l19.1388" class="difflineminus">-          this._log.warning(&quot;Helper indexer threw exception on initial sweep:&quot; +</span>
<a href="#l19.1389"></a><span id="l19.1389" class="difflineminus">-                            ex);</span>
<a href="#l19.1390"></a><span id="l19.1390" class="difflineplus">+          this._log.warn(&quot;Helper indexer threw exception on initial sweep:&quot; +</span>
<a href="#l19.1391"></a><span id="l19.1391" class="difflineplus">+                         ex);</span>
<a href="#l19.1392"></a><span id="l19.1392">         }</span>
<a href="#l19.1393"></a><span id="l19.1393">         yield this.kWorkSync;</span>
<a href="#l19.1394"></a><span id="l19.1394">       }</span>
<a href="#l19.1395"></a><span id="l19.1395">       this._initialSweepPerformed = true;</span>
<a href="#l19.1396"></a><span id="l19.1396">     }</span>
<a href="#l19.1397"></a><span id="l19.1397" class="difflineminus">-    </span>
<a href="#l19.1398"></a><span id="l19.1398" class="difflineplus">+</span>
<a href="#l19.1399"></a><span id="l19.1399">     // we don't have any more work to do...</span>
<a href="#l19.1400"></a><span id="l19.1400">     this._indexingSweepActive = false;</span>
<a href="#l19.1401"></a><span id="l19.1401">     yield this.kWorkDone;</span>
<a href="#l19.1402"></a><span id="l19.1402">   },</span>
<a href="#l19.1403"></a><span id="l19.1403"> </span>
<a href="#l19.1404"></a><span id="l19.1404">   /**</span>
<a href="#l19.1405"></a><span id="l19.1405">    * Index the contents of a folder.</span>
<a href="#l19.1406"></a><span id="l19.1406">    */</span>
<a href="#l19.1407"></a><span id="l19.1407">   _worker_folderIndex: function gloda_worker_folderIndex(aJob) {</span>
<a href="#l19.1408"></a><span id="l19.1408">     yield this._indexerEnterFolder(aJob.id, true);</span>
<a href="#l19.1409"></a><span id="l19.1409" class="difflineminus">-    </span>
<a href="#l19.1410"></a><span id="l19.1410" class="difflineplus">+</span>
<a href="#l19.1411"></a><span id="l19.1411">     if (!this.shouldIndexFolder(this._indexingFolder))</span>
<a href="#l19.1412"></a><span id="l19.1412">       yield this.kWorkDone;</span>
<a href="#l19.1413"></a><span id="l19.1413"> </span>
<a href="#l19.1414"></a><span id="l19.1414">     // Make sure listeners get notified about this job.</span>
<a href="#l19.1415"></a><span id="l19.1415">     this._notifyListeners();</span>
<a href="#l19.1416"></a><span id="l19.1416"> </span>
<a href="#l19.1417"></a><span id="l19.1417">     // there is of course a cost to all this header investigation even if we</span>
<a href="#l19.1418"></a><span id="l19.1418" class="difflineminus">-    //  don't do something.  so we will yield with kWorkSync for every block. </span>
<a href="#l19.1419"></a><span id="l19.1419" class="difflineplus">+    //  don't do something.  so we will yield with kWorkSync for every block.</span>
<a href="#l19.1420"></a><span id="l19.1420">     const HEADER_CHECK_BLOCK_SIZE = 10;</span>
<a href="#l19.1421"></a><span id="l19.1421" class="difflineminus">-    </span>
<a href="#l19.1422"></a><span id="l19.1422" class="difflineplus">+</span>
<a href="#l19.1423"></a><span id="l19.1423">     let isLocal = this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l19.1424"></a><span id="l19.1424">     // we can safely presume if we are here that this folder has been selected</span>
<a href="#l19.1425"></a><span id="l19.1425">     //  for offline processing...</span>
<a href="#l19.1426"></a><span id="l19.1426"> </span>
<a href="#l19.1427"></a><span id="l19.1427">     // Handle the filthy case.  A filthy folder may have misleading properties</span>
<a href="#l19.1428"></a><span id="l19.1428">     //  on the message that claim the message is indexed.  They are misleading</span>
<a href="#l19.1429"></a><span id="l19.1429">     //  because the database, for whatever reason, does not have the messages</span>
<a href="#l19.1430"></a><span id="l19.1430">     //  (accurately) indexed.</span>
<a href="#l19.1431"></a><span id="l19.1431" class="difflineat">@@ -1612,28 +1614,28 @@ var GlodaIndexer = {</span>
<a href="#l19.1432"></a><span id="l19.1432">     //  pathological situation.)</span>
<a href="#l19.1433"></a><span id="l19.1433">     let glodaFolder = GlodaDatastore._mapFolder(this._indexingFolder);</span>
<a href="#l19.1434"></a><span id="l19.1434">     if (glodaFolder.dirtyStatus == glodaFolder.kFolderFilthy) {</span>
<a href="#l19.1435"></a><span id="l19.1435">       let count = 0;</span>
<a href="#l19.1436"></a><span id="l19.1436">       for (let msgHdr in this._indexingIterator) {</span>
<a href="#l19.1437"></a><span id="l19.1437">         // we still need to avoid locking up the UI, pause periodically...</span>
<a href="#l19.1438"></a><span id="l19.1438">         if (++count % HEADER_CHECK_BLOCK_SIZE == 0)</span>
<a href="#l19.1439"></a><span id="l19.1439">           yield this.kWorkSync;</span>
<a href="#l19.1440"></a><span id="l19.1440" class="difflineminus">-        </span>
<a href="#l19.1441"></a><span id="l19.1441" class="difflineplus">+</span>
<a href="#l19.1442"></a><span id="l19.1442">         let glodaMessageId = msgHdr.getUint32Property(</span>
<a href="#l19.1443"></a><span id="l19.1443">           GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l19.1444"></a><span id="l19.1444">         // if it has a gloda message id, we need to mark it filthy</span>
<a href="#l19.1445"></a><span id="l19.1445">         if (glodaMessageId != 0)</span>
<a href="#l19.1446"></a><span id="l19.1446">           msgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, this.kMessageFilthy);</span>
<a href="#l19.1447"></a><span id="l19.1447">         // if it doesn't have a gloda message id, we will definitely index it,</span>
<a href="#l19.1448"></a><span id="l19.1448">         //  so no action is required.</span>
<a href="#l19.1449"></a><span id="l19.1449">       }</span>
<a href="#l19.1450"></a><span id="l19.1450">       // this will automatically persist to the database</span>
<a href="#l19.1451"></a><span id="l19.1451">       glodaFolder.dirtyStatus = glodaFolder.kFolderDirty;</span>
<a href="#l19.1452"></a><span id="l19.1452" class="difflineminus">-      </span>
<a href="#l19.1453"></a><span id="l19.1453" class="difflineplus">+</span>
<a href="#l19.1454"></a><span id="l19.1454">       // We used up the iterator, get a new one.</span>
<a href="#l19.1455"></a><span id="l19.1455">       this._indexerGetIterator();</span>
<a href="#l19.1456"></a><span id="l19.1456">     }</span>
<a href="#l19.1457"></a><span id="l19.1457"> </span>
<a href="#l19.1458"></a><span id="l19.1458">     // Whether or not the given message should be indexed.  Messages should</span>
<a href="#l19.1459"></a><span id="l19.1459">     // be indexed if they're indexable (local or offline and not expunged)</span>
<a href="#l19.1460"></a><span id="l19.1460">     // and either haven't been indexed or are dirty.</span>
<a href="#l19.1461"></a><span id="l19.1461">     let shouldIndexMessage = function(msgHdr) {</span>
<a href="#l19.1462"></a><span id="l19.1462" class="difflineat">@@ -1689,25 +1691,25 @@ var GlodaIndexer = {</span>
<a href="#l19.1463"></a><span id="l19.1463">           ++aJob.offset;</span>
<a href="#l19.1464"></a><span id="l19.1464">           this._log.debug(&quot;&gt;&gt;&gt;  _indexMessage&quot;);</span>
<a href="#l19.1465"></a><span id="l19.1465">           yield this._callbackHandle.pushAndGo(this._indexMessage(msgHdr,</span>
<a href="#l19.1466"></a><span id="l19.1466">               this._callbackHandle));</span>
<a href="#l19.1467"></a><span id="l19.1467">           this._log.debug(&quot;&lt;&lt;&lt;  _indexMessage&quot;);</span>
<a href="#l19.1468"></a><span id="l19.1468">         }</span>
<a href="#l19.1469"></a><span id="l19.1469">       }</span>
<a href="#l19.1470"></a><span id="l19.1470">     }</span>
<a href="#l19.1471"></a><span id="l19.1471" class="difflineminus">-    </span>
<a href="#l19.1472"></a><span id="l19.1472" class="difflineplus">+</span>
<a href="#l19.1473"></a><span id="l19.1473">     glodaFolder.dirtyStatus = glodaFolder.kFolderClean;</span>
<a href="#l19.1474"></a><span id="l19.1474" class="difflineminus">-    </span>
<a href="#l19.1475"></a><span id="l19.1475" class="difflineplus">+</span>
<a href="#l19.1476"></a><span id="l19.1476">     // by definition, it's not likely we'll visit this folder again anytime soon</span>
<a href="#l19.1477"></a><span id="l19.1477">     this._indexerLeaveFolder();</span>
<a href="#l19.1478"></a><span id="l19.1478" class="difflineminus">-    </span>
<a href="#l19.1479"></a><span id="l19.1479" class="difflineplus">+</span>
<a href="#l19.1480"></a><span id="l19.1480">     yield this.kWorkDone;</span>
<a href="#l19.1481"></a><span id="l19.1481">   },</span>
<a href="#l19.1482"></a><span id="l19.1482" class="difflineminus">-  </span>
<a href="#l19.1483"></a><span id="l19.1483" class="difflineplus">+</span>
<a href="#l19.1484"></a><span id="l19.1484">   /**</span>
<a href="#l19.1485"></a><span id="l19.1485">    * Index a specific list of messages that we know to index from</span>
<a href="#l19.1486"></a><span id="l19.1486">    *  event-notification hints.</span>
<a href="#l19.1487"></a><span id="l19.1487">    */</span>
<a href="#l19.1488"></a><span id="l19.1488">   _worker_messageIndex: function gloda_worker_messageAdd(aJob) {</span>
<a href="#l19.1489"></a><span id="l19.1489">     // if we are already in the correct folder, our &quot;get in the folder&quot; clause</span>
<a href="#l19.1490"></a><span id="l19.1490">     //  will not execute, so we need to make sure this value is accurate in</span>
<a href="#l19.1491"></a><span id="l19.1491">     //  that case.  (and we want to avoid multiple checks...)</span>
<a href="#l19.1492"></a><span id="l19.1492" class="difflineat">@@ -1721,43 +1723,43 @@ var GlodaIndexer = {</span>
<a href="#l19.1493"></a><span id="l19.1493">       // get in the folder</span>
<a href="#l19.1494"></a><span id="l19.1494">       if (!this._indexingGlodaFolder ||</span>
<a href="#l19.1495"></a><span id="l19.1495">           this._indexingGlodaFolder.id != item[0]) {</span>
<a href="#l19.1496"></a><span id="l19.1496">         yield this._indexerEnterFolder(item[0], false);</span>
<a href="#l19.1497"></a><span id="l19.1497"> </span>
<a href="#l19.1498"></a><span id="l19.1498">         // stay out of folders we should not be in!</span>
<a href="#l19.1499"></a><span id="l19.1499">         if (!this.shouldIndexFolder(this._indexingFolder))</span>
<a href="#l19.1500"></a><span id="l19.1500">           continue;</span>
<a href="#l19.1501"></a><span id="l19.1501" class="difflineminus">-        </span>
<a href="#l19.1502"></a><span id="l19.1502" class="difflineplus">+</span>
<a href="#l19.1503"></a><span id="l19.1503">         folderIsLocal =</span>
<a href="#l19.1504"></a><span id="l19.1504">           this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l19.1505"></a><span id="l19.1505">       }</span>
<a href="#l19.1506"></a><span id="l19.1506"> </span>
<a href="#l19.1507"></a><span id="l19.1507">       let msgHdr;</span>
<a href="#l19.1508"></a><span id="l19.1508">       if (typeof item[1] == &quot;number&quot;)</span>
<a href="#l19.1509"></a><span id="l19.1509">         msgHdr = this._indexingFolder.GetMessageHeader(item[1]);</span>
<a href="#l19.1510"></a><span id="l19.1510">       else</span>
<a href="#l19.1511"></a><span id="l19.1511">         // same deal as in move processing.</span>
<a href="#l19.1512"></a><span id="l19.1512">         // TODO fixme to not assume singular message-id's.</span>
<a href="#l19.1513"></a><span id="l19.1513">         msgHdr = this._indexingDatabase.getMsgHdrForMessageID(item[1]);</span>
<a href="#l19.1514"></a><span id="l19.1514" class="difflineminus">-      </span>
<a href="#l19.1515"></a><span id="l19.1515" class="difflineplus">+</span>
<a href="#l19.1516"></a><span id="l19.1516">       // it needs a header, the header needs to not be expunged, plus, the</span>
<a href="#l19.1517"></a><span id="l19.1517">       //  message needs to be considered offline.</span>
<a href="#l19.1518"></a><span id="l19.1518">       if (msgHdr &amp;&amp;</span>
<a href="#l19.1519"></a><span id="l19.1519">           !(msgHdr.flags &amp; Components.interfaces.nsMsgMessageFlags.Expunged) &amp;&amp;</span>
<a href="#l19.1520"></a><span id="l19.1520">           (folderIsLocal ||</span>
<a href="#l19.1521"></a><span id="l19.1521">            (msgHdr.flags &amp; Components.interfaces.nsMsgMessageFlags.Offline)))</span>
<a href="#l19.1522"></a><span id="l19.1522">         yield this._callbackHandle.pushAndGo(this._indexMessage(msgHdr,</span>
<a href="#l19.1523"></a><span id="l19.1523">             this._callbackHandle));</span>
<a href="#l19.1524"></a><span id="l19.1524">       else</span>
<a href="#l19.1525"></a><span id="l19.1525">         yield this.kWorkSync;</span>
<a href="#l19.1526"></a><span id="l19.1526">     }</span>
<a href="#l19.1527"></a><span id="l19.1527">     yield this.kWorkDone;</span>
<a href="#l19.1528"></a><span id="l19.1528">   },</span>
<a href="#l19.1529"></a><span id="l19.1529" class="difflineminus">-  </span>
<a href="#l19.1530"></a><span id="l19.1530" class="difflineplus">+</span>
<a href="#l19.1531"></a><span id="l19.1531">   /**</span>
<a href="#l19.1532"></a><span id="l19.1532">    * Process pending deletes...</span>
<a href="#l19.1533"></a><span id="l19.1533">    */</span>
<a href="#l19.1534"></a><span id="l19.1534">   _worker_processDeletes: function gloda_worker_processDeletes(aJob,</span>
<a href="#l19.1535"></a><span id="l19.1535">       aCallbackHandle) {</span>
<a href="#l19.1536"></a><span id="l19.1536">     // get a block of messages to delete.  for now, let's just do this</span>
<a href="#l19.1537"></a><span id="l19.1537">     //  synchronously.  we don't care if there are un-landed delete changes</span>
<a href="#l19.1538"></a><span id="l19.1538">     //  on the asynchronous thread.  (well, there is a potential race that</span>
<a href="#l19.1539"></a><span id="l19.1539" class="difflineat">@@ -1768,53 +1770,53 @@ var GlodaIndexer = {</span>
<a href="#l19.1540"></a><span id="l19.1540">     let processedAny = false;</span>
<a href="#l19.1541"></a><span id="l19.1541">     while (messagesToDelete.length) {</span>
<a href="#l19.1542"></a><span id="l19.1542">       aJob.goal += messagesToDelete.length;</span>
<a href="#l19.1543"></a><span id="l19.1543">       for each (let [iMessage, message] in Iterator(messagesToDelete)) {</span>
<a href="#l19.1544"></a><span id="l19.1544">         yield aCallbackHandle.pushAndGo(this._deleteMessage(message));</span>
<a href="#l19.1545"></a><span id="l19.1545">         aJob.offset++;</span>
<a href="#l19.1546"></a><span id="l19.1546">         yield this.kWorkSync;</span>
<a href="#l19.1547"></a><span id="l19.1547">       }</span>
<a href="#l19.1548"></a><span id="l19.1548" class="difflineminus">-      </span>
<a href="#l19.1549"></a><span id="l19.1549" class="difflineplus">+</span>
<a href="#l19.1550"></a><span id="l19.1550">       processedAny = true;</span>
<a href="#l19.1551"></a><span id="l19.1551" class="difflineminus">-      messagesToDelete = this._datastore.getDeletedMessageBlock(); </span>
<a href="#l19.1552"></a><span id="l19.1552" class="difflineplus">+      messagesToDelete = this._datastore.getDeletedMessageBlock();</span>
<a href="#l19.1553"></a><span id="l19.1553">     }</span>
<a href="#l19.1554"></a><span id="l19.1554">     if (processedAny)</span>
<a href="#l19.1555"></a><span id="l19.1555">       this.pendingDeletions = false;</span>
<a href="#l19.1556"></a><span id="l19.1556" class="difflineminus">-    </span>
<a href="#l19.1557"></a><span id="l19.1557" class="difflineplus">+</span>
<a href="#l19.1558"></a><span id="l19.1558">     yield this.kWorkDone;</span>
<a href="#l19.1559"></a><span id="l19.1559">   },</span>
<a href="#l19.1560"></a><span id="l19.1560"> </span>
<a href="#l19.1561"></a><span id="l19.1561">   /**</span>
<a href="#l19.1562"></a><span id="l19.1562">    * Determine whether a folder is suitable for indexing.</span>
<a href="#l19.1563"></a><span id="l19.1563" class="difflineminus">-   * </span>
<a href="#l19.1564"></a><span id="l19.1564" class="difflineplus">+   *</span>
<a href="#l19.1565"></a><span id="l19.1565">    * @param aMsgFolder An nsIMsgFolder you want to see if we should index.</span>
<a href="#l19.1566"></a><span id="l19.1566" class="difflineminus">-   * </span>
<a href="#l19.1567"></a><span id="l19.1567" class="difflineplus">+   *</span>
<a href="#l19.1568"></a><span id="l19.1568">    * @returns true if we want to index messages in this type of folder, false if</span>
<a href="#l19.1569"></a><span id="l19.1569">    *     we do not.</span>
<a href="#l19.1570"></a><span id="l19.1570">    */</span>
<a href="#l19.1571"></a><span id="l19.1571">   shouldIndexFolder: function(aMsgFolder) {</span>
<a href="#l19.1572"></a><span id="l19.1572">     let folderFlags = aMsgFolder.flags;</span>
<a href="#l19.1573"></a><span id="l19.1573">     // only index mail folders but stay out of virtual folders</span>
<a href="#l19.1574"></a><span id="l19.1574">     return ((folderFlags &amp; Ci.nsMsgFolderFlags.Mail) &amp;&amp;</span>
<a href="#l19.1575"></a><span id="l19.1575">             !(folderFlags &amp; Ci.nsMsgFolderFlags.Virtual));</span>
<a href="#l19.1576"></a><span id="l19.1576">   },</span>
<a href="#l19.1577"></a><span id="l19.1577" class="difflineminus">-  </span>
<a href="#l19.1578"></a><span id="l19.1578" class="difflineplus">+</span>
<a href="#l19.1579"></a><span id="l19.1579">   /**</span>
<a href="#l19.1580"></a><span id="l19.1580">    * Queue all of the folders of all of the accounts of the current profile</span>
<a href="#l19.1581"></a><span id="l19.1581">    *  for indexing.  We traverse all folders and queue them immediately to try</span>
<a href="#l19.1582"></a><span id="l19.1582">    *  and have an accurate estimate of the number of folders that need to be</span>
<a href="#l19.1583"></a><span id="l19.1583">    *  indexed.  (We previously queued accounts rather than immediately</span>
<a href="#l19.1584"></a><span id="l19.1584">    *  walking their list of folders.)</span>
<a href="#l19.1585"></a><span id="l19.1585">    */</span>
<a href="#l19.1586"></a><span id="l19.1586">   indexEverything: function glodaIndexEverything() {</span>
<a href="#l19.1587"></a><span id="l19.1587">     this._log.info(&quot;Queueing all accounts for indexing.&quot;);</span>
<a href="#l19.1588"></a><span id="l19.1588">     let msgAccountManager = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;].</span>
<a href="#l19.1589"></a><span id="l19.1589">                             getService(Ci.nsIMsgAccountManager);</span>
<a href="#l19.1590"></a><span id="l19.1590" class="difflineminus">-    </span>
<a href="#l19.1591"></a><span id="l19.1591" class="difflineplus">+</span>
<a href="#l19.1592"></a><span id="l19.1592">     GlodaDatastore._beginTransaction();</span>
<a href="#l19.1593"></a><span id="l19.1593">     let sideEffects = [this.indexAccount(account) for each</span>
<a href="#l19.1594"></a><span id="l19.1594">                        (account in fixIterator(msgAccountManager.accounts,</span>
<a href="#l19.1595"></a><span id="l19.1595">                                                Ci.nsIMsgAccount))];</span>
<a href="#l19.1596"></a><span id="l19.1596">     GlodaDatastore._commitTransaction();</span>
<a href="#l19.1597"></a><span id="l19.1597">   },</span>
<a href="#l19.1598"></a><span id="l19.1598"> </span>
<a href="#l19.1599"></a><span id="l19.1599">   /**</span>
<a href="#l19.1600"></a><span id="l19.1600" class="difflineat">@@ -1832,60 +1834,60 @@ var GlodaIndexer = {</span>
<a href="#l19.1601"></a><span id="l19.1601">       let folderJobs = [];</span>
<a href="#l19.1602"></a><span id="l19.1602">       for (let folderIndex = 0; folderIndex &lt; numFolders; folderIndex++) {</span>
<a href="#l19.1603"></a><span id="l19.1603">         let folder = allFolders.GetElementAt(folderIndex).QueryInterface(</span>
<a href="#l19.1604"></a><span id="l19.1604">                                                             Ci.nsIMsgFolder);</span>
<a href="#l19.1605"></a><span id="l19.1605">         if (this.shouldIndexFolder(folder))</span>
<a href="#l19.1606"></a><span id="l19.1606">           folderJobs.push(</span>
<a href="#l19.1607"></a><span id="l19.1607">             new IndexingJob(&quot;folder&quot;, 1, GlodaDatastore._mapFolder(folder).id));</span>
<a href="#l19.1608"></a><span id="l19.1608">       }</span>
<a href="#l19.1609"></a><span id="l19.1609" class="difflineminus">-      </span>
<a href="#l19.1610"></a><span id="l19.1610" class="difflineplus">+</span>
<a href="#l19.1611"></a><span id="l19.1611">       this._indexingJobGoal += folderJobs.length;</span>
<a href="#l19.1612"></a><span id="l19.1612">       this._indexQueue = this._indexQueue.concat(folderJobs);</span>
<a href="#l19.1613"></a><span id="l19.1613">       this.indexing = true;</span>
<a href="#l19.1614"></a><span id="l19.1614">     }</span>
<a href="#l19.1615"></a><span id="l19.1615">     else {</span>
<a href="#l19.1616"></a><span id="l19.1616">       this._log.info(&quot;Skipping Account, root folder not nsIMsgFolder&quot;);</span>
<a href="#l19.1617"></a><span id="l19.1617">     }</span>
<a href="#l19.1618"></a><span id="l19.1618">   },</span>
<a href="#l19.1619"></a><span id="l19.1619"> </span>
<a href="#l19.1620"></a><span id="l19.1620">   indexJob: function glodaIndexJob(aJob) {</span>
<a href="#l19.1621"></a><span id="l19.1621">     this._log.info(&quot;Queue-ing job for indexing: &quot; + aJob.jobType);</span>
<a href="#l19.1622"></a><span id="l19.1622" class="difflineminus">-    </span>
<a href="#l19.1623"></a><span id="l19.1623" class="difflineplus">+</span>
<a href="#l19.1624"></a><span id="l19.1624">     this._indexQueue.push(aJob);</span>
<a href="#l19.1625"></a><span id="l19.1625">     this._indexingJobGoal++;</span>
<a href="#l19.1626"></a><span id="l19.1626">     this.indexing = true;</span>
<a href="#l19.1627"></a><span id="l19.1627">   },</span>
<a href="#l19.1628"></a><span id="l19.1628" class="difflineminus">-  </span>
<a href="#l19.1629"></a><span id="l19.1629" class="difflineplus">+</span>
<a href="#l19.1630"></a><span id="l19.1630">   /**</span>
<a href="#l19.1631"></a><span id="l19.1631">    * Queue a single folder for indexing given an nsIMsgFolder.</span>
<a href="#l19.1632"></a><span id="l19.1632">    */</span>
<a href="#l19.1633"></a><span id="l19.1633">   indexFolder: function glodaIndexFolder(aFolder) {</span>
<a href="#l19.1634"></a><span id="l19.1634">     this._log.info(&quot;Queue-ing folder for indexing: &quot; + aFolder.prettiestName);</span>
<a href="#l19.1635"></a><span id="l19.1635" class="difflineminus">-    </span>
<a href="#l19.1636"></a><span id="l19.1636" class="difflineplus">+</span>
<a href="#l19.1637"></a><span id="l19.1637">     this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 1,</span>
<a href="#l19.1638"></a><span id="l19.1638">                           GlodaDatastore._mapFolder(aFolder).id));</span>
<a href="#l19.1639"></a><span id="l19.1639">     this._indexingJobGoal++;</span>
<a href="#l19.1640"></a><span id="l19.1640">     this.indexing = true;</span>
<a href="#l19.1641"></a><span id="l19.1641">   },</span>
<a href="#l19.1642"></a><span id="l19.1642" class="difflineminus">-  </span>
<a href="#l19.1643"></a><span id="l19.1643" class="difflineplus">+</span>
<a href="#l19.1644"></a><span id="l19.1644">   /**</span>
<a href="#l19.1645"></a><span id="l19.1645">    * Queue a list of messages for indexing.</span>
<a href="#l19.1646"></a><span id="l19.1646">    *</span>
<a href="#l19.1647"></a><span id="l19.1647">    * @param aFoldersAndMessages List of [nsIMsgFolder, message key] tuples.</span>
<a href="#l19.1648"></a><span id="l19.1648">    */</span>
<a href="#l19.1649"></a><span id="l19.1649">   indexMessages: function gloda_index_indexMessages(aFoldersAndMessages) {</span>
<a href="#l19.1650"></a><span id="l19.1650">     let job = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l19.1651"></a><span id="l19.1651">     job.items = [[GlodaDatastore._mapFolder(fm[0]).id, fm[1]] for each</span>
<a href="#l19.1652"></a><span id="l19.1652">                  ([i, fm] in Iterator(aFoldersAndMessages))];</span>
<a href="#l19.1653"></a><span id="l19.1653">     this._indexQueue.push(job);</span>
<a href="#l19.1654"></a><span id="l19.1654">     this._indexingJobGoal++;</span>
<a href="#l19.1655"></a><span id="l19.1655">     this.indexing = true;</span>
<a href="#l19.1656"></a><span id="l19.1656">   },</span>
<a href="#l19.1657"></a><span id="l19.1657" class="difflineminus">-  </span>
<a href="#l19.1658"></a><span id="l19.1658" class="difflineplus">+</span>
<a href="#l19.1659"></a><span id="l19.1659">   /* *********** Event Processing *********** */</span>
<a href="#l19.1660"></a><span id="l19.1660">   observe: function gloda_indexer_observe(aSubject, aTopic, aData) {</span>
<a href="#l19.1661"></a><span id="l19.1661">     // idle</span>
<a href="#l19.1662"></a><span id="l19.1662">     if (aTopic == &quot;idle&quot;) {</span>
<a href="#l19.1663"></a><span id="l19.1663">       if (this.indexing)</span>
<a href="#l19.1664"></a><span id="l19.1664">         this._log.debug(&quot;Detected idle, throttling up.&quot;);</span>
<a href="#l19.1665"></a><span id="l19.1665">       // save off our adapted active values</span>
<a href="#l19.1666"></a><span id="l19.1666">       this._indexInterval_whenActive = this._indexInterval;</span>
<a href="#l19.1667"></a><span id="l19.1667" class="difflineat">@@ -1916,30 +1918,30 @@ var GlodaIndexer = {</span>
<a href="#l19.1668"></a><span id="l19.1668">       }</span>
<a href="#l19.1669"></a><span id="l19.1669">     }</span>
<a href="#l19.1670"></a><span id="l19.1670">     // shutdown fallback</span>
<a href="#l19.1671"></a><span id="l19.1671">     else if (aTopic == &quot;quit-application&quot;) {</span>
<a href="#l19.1672"></a><span id="l19.1672">       this._shutdown();</span>
<a href="#l19.1673"></a><span id="l19.1673">     }</span>
<a href="#l19.1674"></a><span id="l19.1674">   },</span>
<a href="#l19.1675"></a><span id="l19.1675"> </span>
<a href="#l19.1676"></a><span id="l19.1676" class="difflineminus">-  /* ***** Folder Changes ***** */  </span>
<a href="#l19.1677"></a><span id="l19.1677" class="difflineplus">+  /* ***** Folder Changes ***** */</span>
<a href="#l19.1678"></a><span id="l19.1678">   /**</span>
<a href="#l19.1679"></a><span id="l19.1679">    * All additions and removals are queued for processing.  Indexing messages</span>
<a href="#l19.1680"></a><span id="l19.1680">    *  is potentially phenomenally expensive, and deletion can still be</span>
<a href="#l19.1681"></a><span id="l19.1681">    *  relatively expensive due to our need to delete the message, its</span>
<a href="#l19.1682"></a><span id="l19.1682">    *  attributes, and all attributes that reference it.  Additionally,</span>
<a href="#l19.1683"></a><span id="l19.1683">    *  attribute deletion costs are higher than attribute look-up because</span>
<a href="#l19.1684"></a><span id="l19.1684">    *  there is the actual row plus its 3 indices, and our covering indices are</span>
<a href="#l19.1685"></a><span id="l19.1685">    *  no help there.</span>
<a href="#l19.1686"></a><span id="l19.1686" class="difflineminus">-   *  </span>
<a href="#l19.1687"></a><span id="l19.1687" class="difflineplus">+   *</span>
<a href="#l19.1688"></a><span id="l19.1688">    */</span>
<a href="#l19.1689"></a><span id="l19.1689">   _msgFolderListener: {</span>
<a href="#l19.1690"></a><span id="l19.1690">     indexer: null,</span>
<a href="#l19.1691"></a><span id="l19.1691" class="difflineminus">-    </span>
<a href="#l19.1692"></a><span id="l19.1692" class="difflineplus">+</span>
<a href="#l19.1693"></a><span id="l19.1693">     /**</span>
<a href="#l19.1694"></a><span id="l19.1694">      * Handle a new-to-thunderbird message, meaning a newly fetched message</span>
<a href="#l19.1695"></a><span id="l19.1695">      *  (local folder) one revealed by synching with the server (IMAP).  Because</span>
<a href="#l19.1696"></a><span id="l19.1696">      *  the new-to-IMAP case requires Thunderbird to have opened the folder,</span>
<a href="#l19.1697"></a><span id="l19.1697">      *  we either need to depend on MailNews to be aggressive about looking</span>
<a href="#l19.1698"></a><span id="l19.1698">      *  for new messages in folders or try and do it ourselves.  For now, we</span>
<a href="#l19.1699"></a><span id="l19.1699">      *  leave it up to MailNews proper.</span>
<a href="#l19.1700"></a><span id="l19.1700">      *</span>
<a href="#l19.1701"></a><span id="l19.1701" class="difflineat">@@ -1955,17 +1957,17 @@ var GlodaIndexer = {</span>
<a href="#l19.1702"></a><span id="l19.1702">     msgAdded: function gloda_indexer_msgAdded(aMsgHdr) {</span>
<a href="#l19.1703"></a><span id="l19.1703">       // make sure the message is eligible for indexing...</span>
<a href="#l19.1704"></a><span id="l19.1704">       let msgFolder = aMsgHdr.folder;</span>
<a href="#l19.1705"></a><span id="l19.1705">       if (!this.indexer.shouldIndexFolder(msgFolder))</span>
<a href="#l19.1706"></a><span id="l19.1706">         return;</span>
<a href="#l19.1707"></a><span id="l19.1707">       let isFolderLocal = msgFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l19.1708"></a><span id="l19.1708">       if (!isFolderLocal &amp;&amp; !(msgFolder.flags&amp;Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l19.1709"></a><span id="l19.1709">         return;</span>
<a href="#l19.1710"></a><span id="l19.1710" class="difflineminus">-      </span>
<a href="#l19.1711"></a><span id="l19.1711" class="difflineplus">+</span>
<a href="#l19.1712"></a><span id="l19.1712">       // mark the folder dirty so we know to look in it, but there is no need</span>
<a href="#l19.1713"></a><span id="l19.1713">       //  to mark the message because it will lack a gloda-id anyways.</span>
<a href="#l19.1714"></a><span id="l19.1714">       let glodaFolder = GlodaDatastore._mapFolder(msgFolder);</span>
<a href="#l19.1715"></a><span id="l19.1715">       glodaFolder.dirtyStatus = true;</span>
<a href="#l19.1716"></a><span id="l19.1716"> </span>
<a href="#l19.1717"></a><span id="l19.1717">       if (this.indexer._pendingAddJob === null) {</span>
<a href="#l19.1718"></a><span id="l19.1718">         this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l19.1719"></a><span id="l19.1719">         this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l19.1720"></a><span id="l19.1720" class="difflineat">@@ -1979,51 +1981,51 @@ var GlodaIndexer = {</span>
<a href="#l19.1721"></a><span id="l19.1721">         this.indexer.indexing = true;</span>
<a href="#l19.1722"></a><span id="l19.1722">         this.indexer._log.debug(&quot;msgAdded notification, event indexing&quot;);</span>
<a href="#l19.1723"></a><span id="l19.1723">       }</span>
<a href="#l19.1724"></a><span id="l19.1724">       else {</span>
<a href="#l19.1725"></a><span id="l19.1725">         this.indexer.indexingSweepNeeded = true;</span>
<a href="#l19.1726"></a><span id="l19.1726">         this.indexer._log.debug(&quot;msgAdded notification, sweep indexing&quot;);</span>
<a href="#l19.1727"></a><span id="l19.1727">       }</span>
<a href="#l19.1728"></a><span id="l19.1728">     },</span>
<a href="#l19.1729"></a><span id="l19.1729" class="difflineminus">-    </span>
<a href="#l19.1730"></a><span id="l19.1730" class="difflineplus">+</span>
<a href="#l19.1731"></a><span id="l19.1731">     /**</span>
<a href="#l19.1732"></a><span id="l19.1732">      * Handle real, actual deletion (move to trash and IMAP deletion model</span>
<a href="#l19.1733"></a><span id="l19.1733">      *  don't count; we only see the deletion here when it becomes forever,</span>
<a href="#l19.1734"></a><span id="l19.1734">      *  or rather _just before_ it becomes forever.  Because the header is</span>
<a href="#l19.1735"></a><span id="l19.1735">      *  going away, we need to either process things immediately or extract the</span>
<a href="#l19.1736"></a><span id="l19.1736">      *  information required to purge it later without the header.</span>
<a href="#l19.1737"></a><span id="l19.1737">      * To this end, we mark all messages that were indexed in the gloda message</span>
<a href="#l19.1738"></a><span id="l19.1738">      *  database as deleted.  We set our pending deletions flag to let our</span>
<a href="#l19.1739"></a><span id="l19.1739">      *  indexing logic know that after its next wave of folder traversal, it</span>
<a href="#l19.1740"></a><span id="l19.1740">      *  should perform a deletion pass.  If it turns out the messages are coming</span>
<a href="#l19.1741"></a><span id="l19.1741">      *  back, the fact that deletion is thus deferred can be handy, as we can</span>
<a href="#l19.1742"></a><span id="l19.1742" class="difflineminus">-     *  reuse the existing gloda message. </span>
<a href="#l19.1743"></a><span id="l19.1743" class="difflineplus">+     *  reuse the existing gloda message.</span>
<a href="#l19.1744"></a><span id="l19.1744">      */</span>
<a href="#l19.1745"></a><span id="l19.1745">     msgsDeleted: function gloda_indexer_msgsDeleted(aMsgHdrs) {</span>
<a href="#l19.1746"></a><span id="l19.1746">       this.indexer._log.debug(&quot;msgsDeleted notification&quot;);</span>
<a href="#l19.1747"></a><span id="l19.1747" class="difflineminus">-      </span>
<a href="#l19.1748"></a><span id="l19.1748" class="difflineplus">+</span>
<a href="#l19.1749"></a><span id="l19.1749">       let glodaMessageIds = [];</span>
<a href="#l19.1750"></a><span id="l19.1750" class="difflineminus">-      </span>
<a href="#l19.1751"></a><span id="l19.1751" class="difflineplus">+</span>
<a href="#l19.1752"></a><span id="l19.1752">       let deleteJob = new IndexingJob(&quot;message&quot;, -1, null);</span>
<a href="#l19.1753"></a><span id="l19.1753">       for (let iMsgHdr = 0; iMsgHdr &lt; aMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l19.1754"></a><span id="l19.1754">         let msgHdr = aMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l19.1755"></a><span id="l19.1755">         try {</span>
<a href="#l19.1756"></a><span id="l19.1756">           glodaMessageIds.push(msgHdr.getUint32Property(</span>
<a href="#l19.1757"></a><span id="l19.1757">             GLODA_MESSAGE_ID_PROPERTY));</span>
<a href="#l19.1758"></a><span id="l19.1758">         }</span>
<a href="#l19.1759"></a><span id="l19.1759">         catch (ex) {}</span>
<a href="#l19.1760"></a><span id="l19.1760">       }</span>
<a href="#l19.1761"></a><span id="l19.1761" class="difflineminus">-      </span>
<a href="#l19.1762"></a><span id="l19.1762" class="difflineplus">+</span>
<a href="#l19.1763"></a><span id="l19.1763">       if (glodaMessageIds.length) {</span>
<a href="#l19.1764"></a><span id="l19.1764">         this.indexer._datastore.markMessagesDeletedByIDs(glodaMessageIds);</span>
<a href="#l19.1765"></a><span id="l19.1765">         this.indexer.pendingDeletions = true;</span>
<a href="#l19.1766"></a><span id="l19.1766">       }</span>
<a href="#l19.1767"></a><span id="l19.1767">     },</span>
<a href="#l19.1768"></a><span id="l19.1768" class="difflineminus">-    </span>
<a href="#l19.1769"></a><span id="l19.1769" class="difflineplus">+</span>
<a href="#l19.1770"></a><span id="l19.1770">     /**</span>
<a href="#l19.1771"></a><span id="l19.1771">      * Process a move or copy.</span>
<a href="#l19.1772"></a><span id="l19.1772">      * Moves to a local folder can be dealt with (relatively) efficiently; the</span>
<a href="#l19.1773"></a><span id="l19.1773">      *  target message headers exist at the time of the notification.  The trick</span>
<a href="#l19.1774"></a><span id="l19.1774">      *  is that we aren't provided with them.</span>
<a href="#l19.1775"></a><span id="l19.1775">      * Moves to an IMAP folder are troublesome because mailnews may not actually</span>
<a href="#l19.1776"></a><span id="l19.1776">      *  know anything about the messages in their new location.  If there isn't</span>
<a href="#l19.1777"></a><span id="l19.1777">      *  a currently open connection to the destination folder, we will only hear</span>
<a href="#l19.1778"></a><span id="l19.1778" class="difflineat">@@ -2076,29 +2078,29 @@ var GlodaIndexer = {</span>
<a href="#l19.1779"></a><span id="l19.1779">                   glodaIds.push(glodaId);</span>
<a href="#l19.1780"></a><span id="l19.1780">                   newMessageKeys.push(destMsgHdr.messageKey);</span>
<a href="#l19.1781"></a><span id="l19.1781">                 }</span>
<a href="#l19.1782"></a><span id="l19.1782">                 // no gloda id means it hasn't been indexed, so the move isn't</span>
<a href="#l19.1783"></a><span id="l19.1783">                 //  required.</span>
<a href="#l19.1784"></a><span id="l19.1784">                 catch (ex) {}</span>
<a href="#l19.1785"></a><span id="l19.1785">               }</span>
<a href="#l19.1786"></a><span id="l19.1786">             }</span>
<a href="#l19.1787"></a><span id="l19.1787" class="difflineminus">-            </span>
<a href="#l19.1788"></a><span id="l19.1788" class="difflineplus">+</span>
<a href="#l19.1789"></a><span id="l19.1789">             // this method takes care to update the in-memory representations</span>
<a href="#l19.1790"></a><span id="l19.1790">             //  too; we don't need to do anything</span>
<a href="#l19.1791"></a><span id="l19.1791">             this.indexer._datastore.updateMessageLocations(glodaIds,</span>
<a href="#l19.1792"></a><span id="l19.1792">               newMessageKeys, aDestFolder);</span>
<a href="#l19.1793"></a><span id="l19.1793">           }</span>
<a href="#l19.1794"></a><span id="l19.1794">           // target is IMAP or something we equally don't understand</span>
<a href="#l19.1795"></a><span id="l19.1795">           else {</span>
<a href="#l19.1796"></a><span id="l19.1796">             // XXX the srcFolder will always be the same for now, but we</span>
<a href="#l19.1797"></a><span id="l19.1797">             //  probably don't want to depend on it, or at least want a unit</span>
<a href="#l19.1798"></a><span id="l19.1798">             //  test that will break if it changes...</span>
<a href="#l19.1799"></a><span id="l19.1799">             let srcFolder = aSrcMsgHdrs.queryElementAt(0,Ci.nsIMsgDBHdr).folder;</span>
<a href="#l19.1800"></a><span id="l19.1800" class="difflineminus">-    </span>
<a href="#l19.1801"></a><span id="l19.1801" class="difflineplus">+</span>
<a href="#l19.1802"></a><span id="l19.1802">             // get the current (about to be nulled) messageKeys and build the</span>
<a href="#l19.1803"></a><span id="l19.1803">             //  job list too.</span>
<a href="#l19.1804"></a><span id="l19.1804">             let messageKeys = [];</span>
<a href="#l19.1805"></a><span id="l19.1805">             for (let iMsgHdr = 0; iMsgHdr &lt; aSrcMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l19.1806"></a><span id="l19.1806">               let msgHdr = aSrcMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l19.1807"></a><span id="l19.1807">               messageKeys.push(msgHdr.messageKey);</span>
<a href="#l19.1808"></a><span id="l19.1808">             }</span>
<a href="#l19.1809"></a><span id="l19.1809">             // XXX we could extract the gloda message id's instead.</span>
<a href="#l19.1810"></a><span id="l19.1810" class="difflineat">@@ -2116,53 +2118,54 @@ var GlodaIndexer = {</span>
<a href="#l19.1811"></a><span id="l19.1811">           destGlodaFolder.dirtyStatus = true;</span>
<a href="#l19.1812"></a><span id="l19.1812">           this.indexer.indexingSweepNeeded = true;</span>
<a href="#l19.1813"></a><span id="l19.1813">         }</span>
<a href="#l19.1814"></a><span id="l19.1814">       } catch (ex) {</span>
<a href="#l19.1815"></a><span id="l19.1815">         this.indexer._log.error(&quot;Problem encountered during message move/copy&quot; +</span>
<a href="#l19.1816"></a><span id="l19.1816">           &quot;: &quot; + ex);</span>
<a href="#l19.1817"></a><span id="l19.1817">       }</span>
<a href="#l19.1818"></a><span id="l19.1818">     },</span>
<a href="#l19.1819"></a><span id="l19.1819" class="difflineminus">-    </span>
<a href="#l19.1820"></a><span id="l19.1820" class="difflineplus">+</span>
<a href="#l19.1821"></a><span id="l19.1821">     /**</span>
<a href="#l19.1822"></a><span id="l19.1822">      * Handles folder no-longer-exists-ence.  We mark all messages as deleted</span>
<a href="#l19.1823"></a><span id="l19.1823">      *  and remove the folder from our URI table.  Currently, if a folder that</span>
<a href="#l19.1824"></a><span id="l19.1824">      *  contains other folders is deleted, we may either receive one</span>
<a href="#l19.1825"></a><span id="l19.1825">      *  notification for the folder that is deleted, or a notification for the</span>
<a href="#l19.1826"></a><span id="l19.1826">      *  folder and one for each of its descendents.  This depends upon the</span>
<a href="#l19.1827"></a><span id="l19.1827">      *  underlying account implementation, so we explicitly handle each case.</span>
<a href="#l19.1828"></a><span id="l19.1828">      *  Namely, we treat it as if we're only planning on getting one, but we</span>
<a href="#l19.1829"></a><span id="l19.1829">      *  handle if the children are already gone for some reason.</span>
<a href="#l19.1830"></a><span id="l19.1830">      */</span>
<a href="#l19.1831"></a><span id="l19.1831">     folderDeleted: function gloda_indexer_folderDeleted(aFolder) {</span>
<a href="#l19.1832"></a><span id="l19.1832">       this.indexer._log.debug(&quot;folderDeleted notification&quot;);</span>
<a href="#l19.1833"></a><span id="l19.1833" class="difflineminus">-      </span>
<a href="#l19.1834"></a><span id="l19.1834" class="difflineminus">-      delFunc = function(aFolder, indexer) {</span>
<a href="#l19.1835"></a><span id="l19.1835" class="difflineplus">+</span>
<a href="#l19.1836"></a><span id="l19.1836" class="difflineplus">+      let delFunc = function(aFolder, indexer) {</span>
<a href="#l19.1837"></a><span id="l19.1837">         if (indexer._datastore._folderKnown(aFolder)) {</span>
<a href="#l19.1838"></a><span id="l19.1838">           let folder = GlodaDatastore._mapFolder(aFolder);</span>
<a href="#l19.1839"></a><span id="l19.1839" class="difflineplus">+          folder._deleted = true;</span>
<a href="#l19.1840"></a><span id="l19.1840">           indexer._datastore.markMessagesDeletedByFolderID(folder.id);</span>
<a href="#l19.1841"></a><span id="l19.1841">           indexer._datastore.deleteFolderByID(folder.id);</span>
<a href="#l19.1842"></a><span id="l19.1842">         }</span>
<a href="#l19.1843"></a><span id="l19.1843">       };</span>
<a href="#l19.1844"></a><span id="l19.1844"> </span>
<a href="#l19.1845"></a><span id="l19.1845">       let descendentFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l19.1846"></a><span id="l19.1846">                                 createInstance(Ci.nsISupportsArray);</span>
<a href="#l19.1847"></a><span id="l19.1847">       aFolder.ListDescendents(descendentFolders);</span>
<a href="#l19.1848"></a><span id="l19.1848" class="difflineminus">-      </span>
<a href="#l19.1849"></a><span id="l19.1849" class="difflineplus">+</span>
<a href="#l19.1850"></a><span id="l19.1850">       // (the order of operations does not matter; child, non-child, whatever.)</span>
<a href="#l19.1851"></a><span id="l19.1851">       // delete the parent</span>
<a href="#l19.1852"></a><span id="l19.1852">       delFunc(aFolder, this.indexer);</span>
<a href="#l19.1853"></a><span id="l19.1853">       // delete all its descendents</span>
<a href="#l19.1854"></a><span id="l19.1854">       for (let folder in fixIterator(descendentFolders, Ci.nsIMsgFolder)) {</span>
<a href="#l19.1855"></a><span id="l19.1855">         delFunc(folder, this.indexer);</span>
<a href="#l19.1856"></a><span id="l19.1856">       }</span>
<a href="#l19.1857"></a><span id="l19.1857" class="difflineminus">-        </span>
<a href="#l19.1858"></a><span id="l19.1858" class="difflineplus">+</span>
<a href="#l19.1859"></a><span id="l19.1859">       this.indexer.pendingDeletions = true;</span>
<a href="#l19.1860"></a><span id="l19.1860">     },</span>
<a href="#l19.1861"></a><span id="l19.1861" class="difflineminus">-    </span>
<a href="#l19.1862"></a><span id="l19.1862" class="difflineplus">+</span>
<a href="#l19.1863"></a><span id="l19.1863">     /**</span>
<a href="#l19.1864"></a><span id="l19.1864">      * Handle a folder being copied or moved.</span>
<a href="#l19.1865"></a><span id="l19.1865">      * Moves are handled by a helper function shared with _folderRenameHelper</span>
<a href="#l19.1866"></a><span id="l19.1866">      *  (which takes care of any nesting involved).</span>
<a href="#l19.1867"></a><span id="l19.1867">      * Copies are actually ignored, because our periodic indexing traversal</span>
<a href="#l19.1868"></a><span id="l19.1868">      *  should discover these automatically.  We could hint ourselves into</span>
<a href="#l19.1869"></a><span id="l19.1869">      *  action, but arguably a set of completely duplicate messages is not</span>
<a href="#l19.1870"></a><span id="l19.1870">      *  a high priority for indexing.</span>
<a href="#l19.1871"></a><span id="l19.1871" class="difflineat">@@ -2174,147 +2177,147 @@ var GlodaIndexer = {</span>
<a href="#l19.1872"></a><span id="l19.1872">       if (aMove) {</span>
<a href="#l19.1873"></a><span id="l19.1873">         let srcURI = aSrcFolder.URI;</span>
<a href="#l19.1874"></a><span id="l19.1874">         let targetURI = aDestFolder.URI +</span>
<a href="#l19.1875"></a><span id="l19.1875">                         srcURI.substring(srcURI.lastIndexOf(&quot;/&quot;));</span>
<a href="#l19.1876"></a><span id="l19.1876">         return this._folderRenameHelper(aSrcFolder, targetURI);</span>
<a href="#l19.1877"></a><span id="l19.1877">       }</span>
<a href="#l19.1878"></a><span id="l19.1878">       this.indexer.indexingSweepNeeded = true;</span>
<a href="#l19.1879"></a><span id="l19.1879">     },</span>
<a href="#l19.1880"></a><span id="l19.1880" class="difflineminus">-    </span>
<a href="#l19.1881"></a><span id="l19.1881" class="difflineplus">+</span>
<a href="#l19.1882"></a><span id="l19.1882">     /**</span>
<a href="#l19.1883"></a><span id="l19.1883">      * We just need to update the URI &lt;-&gt; ID maps and the row in the database,</span>
<a href="#l19.1884"></a><span id="l19.1884">      *  all of which is actually done by the datastore for us.</span>
<a href="#l19.1885"></a><span id="l19.1885">      * This method needs to deal with the complexity where local folders will</span>
<a href="#l19.1886"></a><span id="l19.1886">      *  generate a rename notification for each sub-folder, but IMAP folders</span>
<a href="#l19.1887"></a><span id="l19.1887">      *  will generate only a single notification.  Our logic primarily handles</span>
<a href="#l19.1888"></a><span id="l19.1888">      *  this by not exploding if the original folder no longer exists.</span>
<a href="#l19.1889"></a><span id="l19.1889">      */</span>
<a href="#l19.1890"></a><span id="l19.1890">     _folderRenameHelper: function gloda_indexer_folderRenameHelper(aOrigFolder,</span>
<a href="#l19.1891"></a><span id="l19.1891">                                                                    aNewURI) {</span>
<a href="#l19.1892"></a><span id="l19.1892">       let descendentFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l19.1893"></a><span id="l19.1893">                                 createInstance(Ci.nsISupportsArray);</span>
<a href="#l19.1894"></a><span id="l19.1894">       aOrigFolder.ListDescendents(descendentFolders);</span>
<a href="#l19.1895"></a><span id="l19.1895" class="difflineminus">-      </span>
<a href="#l19.1896"></a><span id="l19.1896" class="difflineplus">+</span>
<a href="#l19.1897"></a><span id="l19.1897">       let origURI = aOrigFolder.URI;</span>
<a href="#l19.1898"></a><span id="l19.1898">       // this rename is straightforward.</span>
<a href="#l19.1899"></a><span id="l19.1899">       GlodaDatastore.renameFolder(aOrigFolder, aNewURI);</span>
<a href="#l19.1900"></a><span id="l19.1900" class="difflineminus">-      </span>
<a href="#l19.1901"></a><span id="l19.1901" class="difflineplus">+</span>
<a href="#l19.1902"></a><span id="l19.1902">       for (let folder in fixIterator(descendentFolders, Ci.nsIMsgFolder)) {</span>
<a href="#l19.1903"></a><span id="l19.1903">         let oldSubURI = folder.URI;</span>
<a href="#l19.1904"></a><span id="l19.1904">         // mangle a new URI from the old URI.  we could also try and do a</span>
<a href="#l19.1905"></a><span id="l19.1905">         //  parallel traversal of the new folder hierarchy, but that seems like</span>
<a href="#l19.1906"></a><span id="l19.1906">         //  more work.</span>
<a href="#l19.1907"></a><span id="l19.1907">         let newSubURI = aNewURI + oldSubURI.substring(origURI.length)</span>
<a href="#l19.1908"></a><span id="l19.1908">         this.indexer._datastore.renameFolder(oldSubURI, newSubURI);</span>
<a href="#l19.1909"></a><span id="l19.1909">       }</span>
<a href="#l19.1910"></a><span id="l19.1910"> </span>
<a href="#l19.1911"></a><span id="l19.1911">       this.indexer._log.debug(&quot;folder renamed: &quot; + origURI + &quot; to &quot; + aNewURI);</span>
<a href="#l19.1912"></a><span id="l19.1912">     },</span>
<a href="#l19.1913"></a><span id="l19.1913" class="difflineminus">-    </span>
<a href="#l19.1914"></a><span id="l19.1914" class="difflineplus">+</span>
<a href="#l19.1915"></a><span id="l19.1915">     /**</span>
<a href="#l19.1916"></a><span id="l19.1916">      * Handle folder renames, dispatching to our rename helper (which also</span>
<a href="#l19.1917"></a><span id="l19.1917">      *  takes care of any nested folder issues.)</span>
<a href="#l19.1918"></a><span id="l19.1918">      */</span>
<a href="#l19.1919"></a><span id="l19.1919">     folderRenamed: function gloda_indexer_folderRenamed(aOrigFolder,</span>
<a href="#l19.1920"></a><span id="l19.1920">                                                         aNewFolder) {</span>
<a href="#l19.1921"></a><span id="l19.1921">       this._folderRenameHelper(aOrigFolder, aNewFolder.URI);</span>
<a href="#l19.1922"></a><span id="l19.1922">     },</span>
<a href="#l19.1923"></a><span id="l19.1923" class="difflineminus">-    </span>
<a href="#l19.1924"></a><span id="l19.1924" class="difflineplus">+</span>
<a href="#l19.1925"></a><span id="l19.1925">     itemEvent: function gloda_indexer_itemEvent(aItem, aEvent, aData) {</span>
<a href="#l19.1926"></a><span id="l19.1926">       // nop.  this is an expansion method on the part of the interface and has</span>
<a href="#l19.1927"></a><span id="l19.1927">       //  no known events that we need to handle.</span>
<a href="#l19.1928"></a><span id="l19.1928">     },</span>
<a href="#l19.1929"></a><span id="l19.1929">   },</span>
<a href="#l19.1930"></a><span id="l19.1930" class="difflineminus">-  </span>
<a href="#l19.1931"></a><span id="l19.1931" class="difflineplus">+</span>
<a href="#l19.1932"></a><span id="l19.1932">   /**</span>
<a href="#l19.1933"></a><span id="l19.1933">    * A nsIFolderListener (listening on nsIMsgMailSession so we get all of</span>
<a href="#l19.1934"></a><span id="l19.1934">    *  these events) PRIMARILY to get folder loaded notifications.  Because of</span>
<a href="#l19.1935"></a><span id="l19.1935">    *  deficiencies in the nsIMsgFolderListener's events at this time, we also</span>
<a href="#l19.1936"></a><span id="l19.1936">    *  get our folder-added and newsgroup notifications from here for now.  (This</span>
<a href="#l19.1937"></a><span id="l19.1937" class="difflineminus">-   *  will be rectified.)  </span>
<a href="#l19.1938"></a><span id="l19.1938" class="difflineplus">+   *  will be rectified.)</span>
<a href="#l19.1939"></a><span id="l19.1939">    */</span>
<a href="#l19.1940"></a><span id="l19.1940">   _folderListener: {</span>
<a href="#l19.1941"></a><span id="l19.1941">     indexer: null,</span>
<a href="#l19.1942"></a><span id="l19.1942">     _kFolderLoadedAtom: null,</span>
<a href="#l19.1943"></a><span id="l19.1943">     _kKeywordsAtom: null,</span>
<a href="#l19.1944"></a><span id="l19.1944">     _kStatusAtom: null,</span>
<a href="#l19.1945"></a><span id="l19.1945">     _kFlaggedAtom: null,</span>
<a href="#l19.1946"></a><span id="l19.1946">     _kJunkStatusChangedAtom: null,</span>
<a href="#l19.1947"></a><span id="l19.1947" class="difflineminus">-    </span>
<a href="#l19.1948"></a><span id="l19.1948" class="difflineplus">+</span>
<a href="#l19.1949"></a><span id="l19.1949">     _init: function gloda_indexer_fl_init(aIndexer) {</span>
<a href="#l19.1950"></a><span id="l19.1950">       this.indexer = aIndexer;</span>
<a href="#l19.1951"></a><span id="l19.1951">       let atomService = Cc[&quot;@mozilla.org/atom-service;1&quot;].</span>
<a href="#l19.1952"></a><span id="l19.1952">                         getService(Ci.nsIAtomService);</span>
<a href="#l19.1953"></a><span id="l19.1953">       this._kFolderLoadedAtom = atomService.getAtom(&quot;FolderLoaded&quot;);</span>
<a href="#l19.1954"></a><span id="l19.1954">       // we explicitly know about these things rather than bothering with some</span>
<a href="#l19.1955"></a><span id="l19.1955">       //  form of registration scheme because these aren't going to change much.</span>
<a href="#l19.1956"></a><span id="l19.1956">       this._kKeywordsAtom = atomService.getAtom(&quot;Keywords&quot;);</span>
<a href="#l19.1957"></a><span id="l19.1957">       this._kStatusAtom = atomService.getAtom(&quot;Status&quot;);</span>
<a href="#l19.1958"></a><span id="l19.1958">       this._kFlaggedAtom = atomService.getAtom(&quot;Flagged&quot;);</span>
<a href="#l19.1959"></a><span id="l19.1959">       this._kJunkStatusChangedAtom = atomService.getAtom(&quot;JunkStatusChanged&quot;);</span>
<a href="#l19.1960"></a><span id="l19.1960">     },</span>
<a href="#l19.1961"></a><span id="l19.1961" class="difflineminus">-    </span>
<a href="#l19.1962"></a><span id="l19.1962" class="difflineplus">+</span>
<a href="#l19.1963"></a><span id="l19.1963">     /**</span>
<a href="#l19.1964"></a><span id="l19.1964">      * Helper method to do the leg-work associated with flagging a message</span>
<a href="#l19.1965"></a><span id="l19.1965">      *  for re-indexing because of some change in meta-state that happened to</span>
<a href="#l19.1966"></a><span id="l19.1966">      *  it.  Job-wise, we treat this as a message addition; we are uniquely</span>
<a href="#l19.1967"></a><span id="l19.1967">      *  identifying the message by providing its folder ID and message key, and</span>
<a href="#l19.1968"></a><span id="l19.1968">      *  the indexer will cleanly map this to the existing gloda message.</span>
<a href="#l19.1969"></a><span id="l19.1969">      */</span>
<a href="#l19.1970"></a><span id="l19.1970">     _reindexChangedMessage: function gloda_indexer_reindexChangedMessage(</span>
<a href="#l19.1971"></a><span id="l19.1971">         aMsgHdr) {</span>
<a href="#l19.1972"></a><span id="l19.1972">       // make sure the message is eligible for indexing...</span>
<a href="#l19.1973"></a><span id="l19.1973">       let msgFolder = aMsgHdr.folder;</span>
<a href="#l19.1974"></a><span id="l19.1974">       if (!this.indexer.shouldIndexFolder(msgFolder))</span>
<a href="#l19.1975"></a><span id="l19.1975">         return;</span>
<a href="#l19.1976"></a><span id="l19.1976">       let isFolderLocal = msgFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l19.1977"></a><span id="l19.1977">       if (!isFolderLocal &amp;&amp; !(msgFolder.flags&amp;Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l19.1978"></a><span id="l19.1978">         return;</span>
<a href="#l19.1979"></a><span id="l19.1979" class="difflineminus">-    </span>
<a href="#l19.1980"></a><span id="l19.1980" class="difflineplus">+</span>
<a href="#l19.1981"></a><span id="l19.1981">       // mark the message as dirty</span>
<a href="#l19.1982"></a><span id="l19.1982">       // (We could check for the presence of the gloda message id property</span>
<a href="#l19.1983"></a><span id="l19.1983">       //  first to know whether we technically need the dirty property.  I'm</span>
<a href="#l19.1984"></a><span id="l19.1984" class="difflineminus">-      //  not sure whether it is worth the high-probability exception cost.) </span>
<a href="#l19.1985"></a><span id="l19.1985" class="difflineplus">+      //  not sure whether it is worth the high-probability exception cost.)</span>
<a href="#l19.1986"></a><span id="l19.1986">       aMsgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, 1);</span>
<a href="#l19.1987"></a><span id="l19.1987">       // mark the folder dirty too, so we know to look inside</span>
<a href="#l19.1988"></a><span id="l19.1988">       let glodaFolder = GlodaDatastore._mapFolder(msgFolder);</span>
<a href="#l19.1989"></a><span id="l19.1989">       glodaFolder.dirtyStatus = true;</span>
<a href="#l19.1990"></a><span id="l19.1990" class="difflineminus">-      </span>
<a href="#l19.1991"></a><span id="l19.1991" class="difflineplus">+</span>
<a href="#l19.1992"></a><span id="l19.1992">       if (this.indexer._pendingAddJob === null) {</span>
<a href="#l19.1993"></a><span id="l19.1993">         this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l19.1994"></a><span id="l19.1994">         this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l19.1995"></a><span id="l19.1995">         this.indexer._indexingJobGoal++;</span>
<a href="#l19.1996"></a><span id="l19.1996">       }</span>
<a href="#l19.1997"></a><span id="l19.1997">       // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l19.1998"></a><span id="l19.1998">       if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l19.1999"></a><span id="l19.1999">           this.indexer._indexMaxEventQueueMessages)</span>
<a href="#l19.2000"></a><span id="l19.2000">         this.indexer._pendingAddJob.items.push(</span>
<a href="#l19.2001"></a><span id="l19.2001">           [GlodaDatastore._mapFolder(msgFolder).id,</span>
<a href="#l19.2002"></a><span id="l19.2002">            aMsgHdr.messageKey]);</span>
<a href="#l19.2003"></a><span id="l19.2003">       this.indexer.indexing = true;</span>
<a href="#l19.2004"></a><span id="l19.2004">     },</span>
<a href="#l19.2005"></a><span id="l19.2005" class="difflineminus">-  </span>
<a href="#l19.2006"></a><span id="l19.2006" class="difflineplus">+</span>
<a href="#l19.2007"></a><span id="l19.2007">     OnItemAdded: function gloda_indexer_OnItemAdded(aParentItem, aItem) {</span>
<a href="#l19.2008"></a><span id="l19.2008">     },</span>
<a href="#l19.2009"></a><span id="l19.2009">     OnItemRemoved: function gloda_indexer_OnItemRemoved(aParentItem, aItem) {</span>
<a href="#l19.2010"></a><span id="l19.2010">     },</span>
<a href="#l19.2011"></a><span id="l19.2011">     OnItemPropertyChanged: function gloda_indexer_OnItemPropertyChanged(</span>
<a href="#l19.2012"></a><span id="l19.2012">                              aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l19.2013"></a><span id="l19.2013">     },</span>
<a href="#l19.2014"></a><span id="l19.2014">     OnItemIntPropertyChanged: function gloda_indexer_OnItemIntPropertyChanged(</span>
<a href="#l19.2015"></a><span id="l19.2015">                                 aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l19.2016"></a><span id="l19.2016">     },</span>
<a href="#l19.2017"></a><span id="l19.2017">     OnItemBoolPropertyChanged: function gloda_indexer_OnItemBoolPropertyChanged(</span>
<a href="#l19.2018"></a><span id="l19.2018">                                 aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l19.2019"></a><span id="l19.2019">     },</span>
<a href="#l19.2020"></a><span id="l19.2020">     OnItemUnicharPropertyChanged:</span>
<a href="#l19.2021"></a><span id="l19.2021">         function gloda_indexer_OnItemUnicharPropertyChanged(</span>
<a href="#l19.2022"></a><span id="l19.2022">           aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l19.2023"></a><span id="l19.2023" class="difflineminus">-      </span>
<a href="#l19.2024"></a><span id="l19.2024" class="difflineplus">+</span>
<a href="#l19.2025"></a><span id="l19.2025">     },</span>
<a href="#l19.2026"></a><span id="l19.2026">     /**</span>
<a href="#l19.2027"></a><span id="l19.2027">      * Notice when user activity changes a message's status, or automated</span>
<a href="#l19.2028"></a><span id="l19.2028">      *  junk processing flags a message as junk.</span>
<a href="#l19.2029"></a><span id="l19.2029">      */</span>
<a href="#l19.2030"></a><span id="l19.2030">     OnItemPropertyFlagChanged: function gloda_indexer_OnItemPropertyFlagChanged(</span>
<a href="#l19.2031"></a><span id="l19.2031">                                 aMsgHdr, aProperty, aOldValue, aNewValue) {</span>
<a href="#l19.2032"></a><span id="l19.2032">       if (aProperty == this._kKeywordsAtom ||</span>
<a href="#l19.2033"></a><span id="l19.2033" class="difflineat">@@ -2322,57 +2325,57 @@ var GlodaIndexer = {</span>
<a href="#l19.2034"></a><span id="l19.2034">           aProperty == this._kFlaggedAtom ||</span>
<a href="#l19.2035"></a><span id="l19.2035">           aProperty == this._kJunkStatusChangedAtom) {</span>
<a href="#l19.2036"></a><span id="l19.2036">         if (this.indexer.enabled) {</span>
<a href="#l19.2037"></a><span id="l19.2037">           this.indexer._log.debug(&quot;ItemPropertyFlagChanged notification&quot;);</span>
<a href="#l19.2038"></a><span id="l19.2038">           this._reindexChangedMessage(aMsgHdr);</span>
<a href="#l19.2039"></a><span id="l19.2039">         }</span>
<a href="#l19.2040"></a><span id="l19.2040">       }</span>
<a href="#l19.2041"></a><span id="l19.2041">     },</span>
<a href="#l19.2042"></a><span id="l19.2042" class="difflineminus">-    </span>
<a href="#l19.2043"></a><span id="l19.2043" class="difflineplus">+</span>
<a href="#l19.2044"></a><span id="l19.2044">     /**</span>
<a href="#l19.2045"></a><span id="l19.2045">      * Get folder loaded notifications for folders that had to do some</span>
<a href="#l19.2046"></a><span id="l19.2046">      *  (asynchronous) processing before they could be opened.</span>
<a href="#l19.2047"></a><span id="l19.2047">      */</span>
<a href="#l19.2048"></a><span id="l19.2048">     OnItemEvent: function gloda_indexer_OnItemEvent(aFolder, aEvent) {</span>
<a href="#l19.2049"></a><span id="l19.2049">       if (aEvent == this._kFolderLoadedAtom)</span>
<a href="#l19.2050"></a><span id="l19.2050">         this.indexer._onFolderLoaded(aFolder);</span>
<a href="#l19.2051"></a><span id="l19.2051">     },</span>
<a href="#l19.2052"></a><span id="l19.2052">   },</span>
<a href="#l19.2053"></a><span id="l19.2053" class="difflineminus">-  </span>
<a href="#l19.2054"></a><span id="l19.2054" class="difflineplus">+</span>
<a href="#l19.2055"></a><span id="l19.2055">   /* ***** Rebuilding / Reindexing ***** */</span>
<a href="#l19.2056"></a><span id="l19.2056">   // TODO: implement a folder observer doodad to handle rebuilding / reindexing</span>
<a href="#l19.2057"></a><span id="l19.2057">   /**</span>
<a href="#l19.2058"></a><span id="l19.2058">    * Allow us to invalidate an outstanding folder traversal because the</span>
<a href="#l19.2059"></a><span id="l19.2059" class="difflineminus">-   *  underlying database is going away.  We use other means for detecting </span>
<a href="#l19.2060"></a><span id="l19.2060" class="difflineplus">+   *  underlying database is going away.  We use other means for detecting</span>
<a href="#l19.2061"></a><span id="l19.2061">    *  modifications of the message (labeling, marked (un)read, starred, etc.)</span>
<a href="#l19.2062"></a><span id="l19.2062">    *</span>
<a href="#l19.2063"></a><span id="l19.2063">    * This is an nsIDBChangeListener listening to an nsIDBChangeAnnouncer.  To</span>
<a href="#l19.2064"></a><span id="l19.2064">    *  add ourselves, we get us a nice nsMsgDatabase, query it to the announcer,</span>
<a href="#l19.2065"></a><span id="l19.2065">    *  then call AddListener.</span>
<a href="#l19.2066"></a><span id="l19.2066">    */</span>
<a href="#l19.2067"></a><span id="l19.2067">   _databaseAnnouncerListener: {</span>
<a href="#l19.2068"></a><span id="l19.2068">     indexer: null,</span>
<a href="#l19.2069"></a><span id="l19.2069">     onAnnouncerGoingAway: function gloda_indexer_dbGoingAway(</span>
<a href="#l19.2070"></a><span id="l19.2070">                                          aDBChangeAnnouncer) {</span>
<a href="#l19.2071"></a><span id="l19.2071">       this.indexer._indexerLeaveFolder(false);</span>
<a href="#l19.2072"></a><span id="l19.2072">     },</span>
<a href="#l19.2073"></a><span id="l19.2073" class="difflineminus">-    </span>
<a href="#l19.2074"></a><span id="l19.2074" class="difflineplus">+</span>
<a href="#l19.2075"></a><span id="l19.2075">     onHdrFlagsChanged: function(aHdrChanged, aOldFlags, aNewFlags, aInstigator) {},</span>
<a href="#l19.2076"></a><span id="l19.2076">     onHdrDeleted: function(aHdrChanged, aParentKey, aFlags, aInstigator) {},</span>
<a href="#l19.2077"></a><span id="l19.2077">     onHdrAdded: function(aHdrChanged, aParentKey, aFlags, aInstigator) {},</span>
<a href="#l19.2078"></a><span id="l19.2078" class="difflineminus">-    onParentChanged: function(aKeyChanged, aOldParent, aNewParent, </span>
<a href="#l19.2079"></a><span id="l19.2079" class="difflineplus">+    onParentChanged: function(aKeyChanged, aOldParent, aNewParent,</span>
<a href="#l19.2080"></a><span id="l19.2080">                               aInstigator) {},</span>
<a href="#l19.2081"></a><span id="l19.2081">     onReadChanged: function(aInstigator) {},</span>
<a href="#l19.2082"></a><span id="l19.2082">     onJunkScoreChanged: function(aInstigator) {},</span>
<a href="#l19.2083"></a><span id="l19.2083">     onHdrPropertyChanged: function (aHdrToChange, aPreChange, aStatus,</span>
<a href="#l19.2084"></a><span id="l19.2084">                                     aInstigator) {},</span>
<a href="#l19.2085"></a><span id="l19.2085">     onEvent: function (aDB, aEvent) {},</span>
<a href="#l19.2086"></a><span id="l19.2086">   },</span>
<a href="#l19.2087"></a><span id="l19.2087" class="difflineminus">-  </span>
<a href="#l19.2088"></a><span id="l19.2088" class="difflineplus">+</span>
<a href="#l19.2089"></a><span id="l19.2089">   _indexMessage: function gloda_indexMessage(aMsgHdr, aCallbackHandle) {</span>
<a href="#l19.2090"></a><span id="l19.2090">     this._log.debug(&quot;*** Indexing message: &quot; + aMsgHdr.messageKey + &quot; : &quot; +</span>
<a href="#l19.2091"></a><span id="l19.2091">                     aMsgHdr.subject);</span>
<a href="#l19.2092"></a><span id="l19.2092">     MsgHdrToMimeMessage(aMsgHdr, aCallbackHandle.callbackThis,</span>
<a href="#l19.2093"></a><span id="l19.2093">         aCallbackHandle.callback);</span>
<a href="#l19.2094"></a><span id="l19.2094">     let [,aMimeMsg] = yield this.kWorkAsync;</span>
<a href="#l19.2095"></a><span id="l19.2095"> </span>
<a href="#l19.2096"></a><span id="l19.2096">     if (this._unitTestSuperVerbose) {</span>
<a href="#l19.2097"></a><span id="l19.2097" class="difflineat">@@ -2380,113 +2383,113 @@ var GlodaIndexer = {</span>
<a href="#l19.2098"></a><span id="l19.2098">         this._log.debug(&quot;  * Got Mime &quot; + aMimeMsg.prettyString());</span>
<a href="#l19.2099"></a><span id="l19.2099">       else</span>
<a href="#l19.2100"></a><span id="l19.2100">         this._log.debug(&quot;  * NO MIME MESSAGE!!!\n&quot;);</span>
<a href="#l19.2101"></a><span id="l19.2101">     }</span>
<a href="#l19.2102"></a><span id="l19.2102"> </span>
<a href="#l19.2103"></a><span id="l19.2103">     // -- Find/create the conversation the message belongs to.</span>
<a href="#l19.2104"></a><span id="l19.2104">     // Our invariant is that all messages that exist in the database belong to</span>
<a href="#l19.2105"></a><span id="l19.2105">     //  a conversation.</span>
<a href="#l19.2106"></a><span id="l19.2106" class="difflineminus">-    </span>
<a href="#l19.2107"></a><span id="l19.2107" class="difflineplus">+</span>
<a href="#l19.2108"></a><span id="l19.2108">     // - See if any of the ancestors exist and have a conversationID...</span>
<a href="#l19.2109"></a><span id="l19.2109">     // (references are ordered from old [0] to new [n-1])</span>
<a href="#l19.2110"></a><span id="l19.2110">     let references = [aMsgHdr.getStringReference(i) for each</span>
<a href="#l19.2111"></a><span id="l19.2111">                       (i in range(0, aMsgHdr.numReferences))];</span>
<a href="#l19.2112"></a><span id="l19.2112">     // also see if we already know about the message...</span>
<a href="#l19.2113"></a><span id="l19.2113">     references.push(aMsgHdr.messageId);</span>
<a href="#l19.2114"></a><span id="l19.2114" class="difflineminus">-    </span>
<a href="#l19.2115"></a><span id="l19.2115" class="difflineplus">+</span>
<a href="#l19.2116"></a><span id="l19.2116">     this._datastore.getMessagesByMessageID(references, aCallbackHandle.callback,</span>
<a href="#l19.2117"></a><span id="l19.2117">       aCallbackHandle.callbackThis);</span>
<a href="#l19.2118"></a><span id="l19.2118">     // (ancestorLists has a direct correspondence to the message ids)</span>
<a href="#l19.2119"></a><span id="l19.2119" class="difflineminus">-    let ancestorLists = yield this.kWorkAsync; </span>
<a href="#l19.2120"></a><span id="l19.2120" class="difflineminus">-    </span>
<a href="#l19.2121"></a><span id="l19.2121" class="difflineplus">+    let ancestorLists = yield this.kWorkAsync;</span>
<a href="#l19.2122"></a><span id="l19.2122" class="difflineplus">+</span>
<a href="#l19.2123"></a><span id="l19.2123">     this._log.debug(&quot;ancestors raw: &quot; + ancestorLists);</span>
<a href="#l19.2124"></a><span id="l19.2124">     this._log.debug(&quot;ref len: &quot; + references.length + &quot; anc len: &quot; + ancestorLists.length);</span>
<a href="#l19.2125"></a><span id="l19.2125">     this._log.debug(&quot;references: &quot; + Log4Moz.enumerateProperties(references).join(&quot;,&quot;));</span>
<a href="#l19.2126"></a><span id="l19.2126">     this._log.debug(&quot;ancestors: &quot; + Log4Moz.enumerateProperties(ancestorLists).join(&quot;,&quot;));</span>
<a href="#l19.2127"></a><span id="l19.2127" class="difflineminus">-    </span>
<a href="#l19.2128"></a><span id="l19.2128" class="difflineplus">+</span>
<a href="#l19.2129"></a><span id="l19.2129">     // pull our current message lookup results off</span>
<a href="#l19.2130"></a><span id="l19.2130">     references.pop();</span>
<a href="#l19.2131"></a><span id="l19.2131">     let candidateCurMsgs = ancestorLists.pop();</span>
<a href="#l19.2132"></a><span id="l19.2132" class="difflineminus">-    </span>
<a href="#l19.2133"></a><span id="l19.2133" class="difflineplus">+</span>
<a href="#l19.2134"></a><span id="l19.2134">     let conversationID = null;</span>
<a href="#l19.2135"></a><span id="l19.2135">     let conversation = null;</span>
<a href="#l19.2136"></a><span id="l19.2136">     // -- figure out the conversation ID</span>
<a href="#l19.2137"></a><span id="l19.2137">     // if we have a clone/already exist, just use his conversation ID</span>
<a href="#l19.2138"></a><span id="l19.2138">     if (candidateCurMsgs.length &gt; 0) {</span>
<a href="#l19.2139"></a><span id="l19.2139">       conversationID = candidateCurMsgs[0].conversationID;</span>
<a href="#l19.2140"></a><span id="l19.2140">       conversation = candidateCurMsgs[0].conversation;</span>
<a href="#l19.2141"></a><span id="l19.2141">     }</span>
<a href="#l19.2142"></a><span id="l19.2142">     // otherwise check out our ancestors</span>
<a href="#l19.2143"></a><span id="l19.2143">     else {</span>
<a href="#l19.2144"></a><span id="l19.2144">       // (walk from closest to furthest ancestor)</span>
<a href="#l19.2145"></a><span id="l19.2145">       for (let iAncestor = ancestorLists.length-1; iAncestor &gt;= 0;</span>
<a href="#l19.2146"></a><span id="l19.2146">           --iAncestor) {</span>
<a href="#l19.2147"></a><span id="l19.2147">         let ancestorList = ancestorLists[iAncestor];</span>
<a href="#l19.2148"></a><span id="l19.2148" class="difflineminus">-        </span>
<a href="#l19.2149"></a><span id="l19.2149" class="difflineplus">+</span>
<a href="#l19.2150"></a><span id="l19.2150">         if (ancestorList.length &gt; 0) {</span>
<a href="#l19.2151"></a><span id="l19.2151">           // we only care about the first instance of the message because we are</span>
<a href="#l19.2152"></a><span id="l19.2152">           //  able to guarantee the invariant that all messages with the same</span>
<a href="#l19.2153"></a><span id="l19.2153" class="difflineminus">-          //  message id belong to the same conversation. </span>
<a href="#l19.2154"></a><span id="l19.2154" class="difflineplus">+          //  message id belong to the same conversation.</span>
<a href="#l19.2155"></a><span id="l19.2155">           let ancestor = ancestorList[0];</span>
<a href="#l19.2156"></a><span id="l19.2156">           if (conversationID === null) {</span>
<a href="#l19.2157"></a><span id="l19.2157">             conversationID = ancestor.conversationID;</span>
<a href="#l19.2158"></a><span id="l19.2158">             conversation = ancestor.conversation;</span>
<a href="#l19.2159"></a><span id="l19.2159">           }</span>
<a href="#l19.2160"></a><span id="l19.2160">           else if (conversationID != ancestor.conversationID)</span>
<a href="#l19.2161"></a><span id="l19.2161">             this._log.error(&quot;Inconsistency in conversations invariant on &quot; +</span>
<a href="#l19.2162"></a><span id="l19.2162">                             ancestor.headerMessageID + &quot;.  It has conv id &quot; +</span>
<a href="#l19.2163"></a><span id="l19.2163" class="difflineminus">-                            ancestor.conversationID + &quot; but expected &quot; + </span>
<a href="#l19.2164"></a><span id="l19.2164" class="difflineplus">+                            ancestor.conversationID + &quot; but expected &quot; +</span>
<a href="#l19.2165"></a><span id="l19.2165">                             conversationID + &quot;. ID: &quot; + ancestor.id);</span>
<a href="#l19.2166"></a><span id="l19.2166">         }</span>
<a href="#l19.2167"></a><span id="l19.2167">       }</span>
<a href="#l19.2168"></a><span id="l19.2168">     }</span>
<a href="#l19.2169"></a><span id="l19.2169" class="difflineminus">-    </span>
<a href="#l19.2170"></a><span id="l19.2170" class="difflineplus">+</span>
<a href="#l19.2171"></a><span id="l19.2171">     // nobody had one?  create a new conversation</span>
<a href="#l19.2172"></a><span id="l19.2172">     if (conversationID === null) {</span>
<a href="#l19.2173"></a><span id="l19.2173">       // (the create method could issue the id, making the call return</span>
<a href="#l19.2174"></a><span id="l19.2174">       //  without waiting for the database...)</span>
<a href="#l19.2175"></a><span id="l19.2175">       conversation = this._datastore.createConversation(</span>
<a href="#l19.2176"></a><span id="l19.2176">           aMsgHdr.mime2DecodedSubject, null, null);</span>
<a href="#l19.2177"></a><span id="l19.2177">       conversationID = conversation.id;</span>
<a href="#l19.2178"></a><span id="l19.2178">     }</span>
<a href="#l19.2179"></a><span id="l19.2179" class="difflineminus">-    </span>
<a href="#l19.2180"></a><span id="l19.2180" class="difflineplus">+</span>
<a href="#l19.2181"></a><span id="l19.2181">     // Walk from furthest to closest ancestor, creating the ancestors that don't</span>
<a href="#l19.2182"></a><span id="l19.2182">     //  exist. (This is possible if previous messages that were consumed in this</span>
<a href="#l19.2183"></a><span id="l19.2183">     //  thread only had an in-reply-to or for some reason did not otherwise</span>
<a href="#l19.2184"></a><span id="l19.2184">     //  provide the full references chain.)</span>
<a href="#l19.2185"></a><span id="l19.2185">     for (let iAncestor = 0; iAncestor &lt; ancestorLists.length; ++iAncestor) {</span>
<a href="#l19.2186"></a><span id="l19.2186">       let ancestorList = ancestorLists[iAncestor];</span>
<a href="#l19.2187"></a><span id="l19.2187" class="difflineminus">-      </span>
<a href="#l19.2188"></a><span id="l19.2188" class="difflineplus">+</span>
<a href="#l19.2189"></a><span id="l19.2189">       if (ancestorList.length == 0) {</span>
<a href="#l19.2190"></a><span id="l19.2190">         this._log.debug(&quot;creating message with: null, &quot; + conversationID +</span>
<a href="#l19.2191"></a><span id="l19.2191">                         &quot;, &quot; + references[iAncestor] +</span>
<a href="#l19.2192"></a><span id="l19.2192">                         &quot;, null.&quot;);</span>
<a href="#l19.2193"></a><span id="l19.2193">         let ancestor = this._datastore.createMessage(null, null, // ghost</span>
<a href="#l19.2194"></a><span id="l19.2194">                                                      conversationID, null,</span>
<a href="#l19.2195"></a><span id="l19.2195">                                                      references[iAncestor],</span>
<a href="#l19.2196"></a><span id="l19.2196">                                                      null, // no subject</span>
<a href="#l19.2197"></a><span id="l19.2197">                                                      null, // no body</span>
<a href="#l19.2198"></a><span id="l19.2198">                                                      null); // no attachments</span>
<a href="#l19.2199"></a><span id="l19.2199">         this._datastore.insertMessage(ancestor);</span>
<a href="#l19.2200"></a><span id="l19.2200">         ancestorLists[iAncestor].push(ancestor);</span>
<a href="#l19.2201"></a><span id="l19.2201">       }</span>
<a href="#l19.2202"></a><span id="l19.2202">     }</span>
<a href="#l19.2203"></a><span id="l19.2203">     // now all our ancestors exist, though they may be ghost-like...</span>
<a href="#l19.2204"></a><span id="l19.2204" class="difflineminus">-    </span>
<a href="#l19.2205"></a><span id="l19.2205" class="difflineplus">+</span>
<a href="#l19.2206"></a><span id="l19.2206">     // find if there's a ghost version of our message or we already have indexed</span>
<a href="#l19.2207"></a><span id="l19.2207">     //  this message.</span>
<a href="#l19.2208"></a><span id="l19.2208">     let curMsg = null;</span>
<a href="#l19.2209"></a><span id="l19.2209">     this._log.debug(candidateCurMsgs.length + &quot; candidate messages&quot;);</span>
<a href="#l19.2210"></a><span id="l19.2210">     for (let iCurCand = 0; iCurCand &lt; candidateCurMsgs.length; iCurCand++) {</span>
<a href="#l19.2211"></a><span id="l19.2211">       let candMsg = candidateCurMsgs[iCurCand];</span>
<a href="#l19.2212"></a><span id="l19.2212"> </span>
<a href="#l19.2213"></a><span id="l19.2213">       this._log.debug(&quot;candidate folderID: &quot; + candMsg.folderID +</span>
<a href="#l19.2214"></a><span id="l19.2214">                       &quot; messageKey: &quot; + candMsg.messageKey);</span>
<a href="#l19.2215"></a><span id="l19.2215" class="difflineminus">-      </span>
<a href="#l19.2216"></a><span id="l19.2216" class="difflineplus">+</span>
<a href="#l19.2217"></a><span id="l19.2217">       if (candMsg.folderURI == aMsgHdr.folder.URI) {</span>
<a href="#l19.2218"></a><span id="l19.2218">         // if we are in the same folder and we have the same message key, we</span>
<a href="#l19.2219"></a><span id="l19.2219">         //  are definitely the same, stop looking.</span>
<a href="#l19.2220"></a><span id="l19.2220">         if (candMsg.messageKey == aMsgHdr.messageKey) {</span>
<a href="#l19.2221"></a><span id="l19.2221">           curMsg = candMsg;</span>
<a href="#l19.2222"></a><span id="l19.2222">           break;</span>
<a href="#l19.2223"></a><span id="l19.2223">         }</span>
<a href="#l19.2224"></a><span id="l19.2224">         // if (we are in the same folder and) the candidate message has a null</span>
<a href="#l19.2225"></a><span id="l19.2225" class="difflineat">@@ -2505,82 +2508,90 @@ var GlodaIndexer = {</span>
<a href="#l19.2226"></a><span id="l19.2226">                  (aMsgHdr.folder.GetMessageHeader(candMsg.messageKey) === null))</span>
<a href="#l19.2227"></a><span id="l19.2227">           curMsg = candMsg;</span>
<a href="#l19.2228"></a><span id="l19.2228">       }</span>
<a href="#l19.2229"></a><span id="l19.2229">       // our choice of last resort, but still okay, is a ghost message</span>
<a href="#l19.2230"></a><span id="l19.2230">       else if ((curMsg === null) &amp;&amp; (candMsg.folderID === null)) {</span>
<a href="#l19.2231"></a><span id="l19.2231">         curMsg = candMsg;</span>
<a href="#l19.2232"></a><span id="l19.2232">       }</span>
<a href="#l19.2233"></a><span id="l19.2233">     }</span>
<a href="#l19.2234"></a><span id="l19.2234" class="difflineminus">-    </span>
<a href="#l19.2235"></a><span id="l19.2235" class="difflineplus">+</span>
<a href="#l19.2236"></a><span id="l19.2236">     let attachmentNames = null;</span>
<a href="#l19.2237"></a><span id="l19.2237">     if (aMimeMsg) {</span>
<a href="#l19.2238"></a><span id="l19.2238">       attachmentNames = [att.name for each</span>
<a href="#l19.2239"></a><span id="l19.2239">                          ([i, att] in Iterator(aMimeMsg.allAttachments))</span>
<a href="#l19.2240"></a><span id="l19.2240">                          if (att.isRealAttachment)];</span>
<a href="#l19.2241"></a><span id="l19.2241" class="difflineminus">-    } </span>
<a href="#l19.2242"></a><span id="l19.2242" class="difflineminus">-    </span>
<a href="#l19.2243"></a><span id="l19.2243" class="difflineplus">+    }</span>
<a href="#l19.2244"></a><span id="l19.2244" class="difflineplus">+</span>
<a href="#l19.2245"></a><span id="l19.2245">     let isConceptuallyNew, isRecordNew;</span>
<a href="#l19.2246"></a><span id="l19.2246">     if (curMsg === null) {</span>
<a href="#l19.2247"></a><span id="l19.2247">       curMsg = this._datastore.createMessage(aMsgHdr.folder,</span>
<a href="#l19.2248"></a><span id="l19.2248" class="difflineminus">-                                             aMsgHdr.messageKey,                </span>
<a href="#l19.2249"></a><span id="l19.2249" class="difflineplus">+                                             aMsgHdr.messageKey,</span>
<a href="#l19.2250"></a><span id="l19.2250">                                              conversationID,</span>
<a href="#l19.2251"></a><span id="l19.2251">                                              aMsgHdr.date,</span>
<a href="#l19.2252"></a><span id="l19.2252">                                              aMsgHdr.messageId);</span>
<a href="#l19.2253"></a><span id="l19.2253">       curMsg._conversation = conversation;</span>
<a href="#l19.2254"></a><span id="l19.2254">       isConceptuallyNew = isRecordNew = true;</span>
<a href="#l19.2255"></a><span id="l19.2255">     }</span>
<a href="#l19.2256"></a><span id="l19.2256">     else {</span>
<a href="#l19.2257"></a><span id="l19.2257">       isRecordNew = false;</span>
<a href="#l19.2258"></a><span id="l19.2258">       isConceptuallyNew = (curMsg._folderID === null); // aka was-a-ghost</span>
<a href="#l19.2259"></a><span id="l19.2259">       // (messageKey can be null if it's not new in the move-case)</span>
<a href="#l19.2260"></a><span id="l19.2260">       curMsg._folderID = this._datastore._mapFolder(aMsgHdr.folder).id;</span>
<a href="#l19.2261"></a><span id="l19.2261">       curMsg._messageKey = aMsgHdr.messageKey;</span>
<a href="#l19.2262"></a><span id="l19.2262" class="difflineminus">-      curMsg.date = new Date(aMsgHdr.date / 1000); </span>
<a href="#l19.2263"></a><span id="l19.2263" class="difflineplus">+      curMsg.date = new Date(aMsgHdr.date / 1000);</span>
<a href="#l19.2264"></a><span id="l19.2264">       // note: we are assuming that our matching logic is flawless in that</span>
<a href="#l19.2265"></a><span id="l19.2265">       //  if this message was not a ghost, we are assuming the 'body'</span>
<a href="#l19.2266"></a><span id="l19.2266">       //  associated with the id is still exactly the same.  It is conceivable</span>
<a href="#l19.2267"></a><span id="l19.2267">       //  that there are cases where this is not true.</span>
<a href="#l19.2268"></a><span id="l19.2268">     }</span>
<a href="#l19.2269"></a><span id="l19.2269"> </span>
<a href="#l19.2270"></a><span id="l19.2270">     if (aMimeMsg) {</span>
<a href="#l19.2271"></a><span id="l19.2271">       let bodyPlain = aMimeMsg.coerceBodyToPlaintext(aMsgHdr.folder);</span>
<a href="#l19.2272"></a><span id="l19.2272">       if (bodyPlain) {</span>
<a href="#l19.2273"></a><span id="l19.2273">         curMsg._bodyLines = bodyPlain.split(/\r?\n/);</span>
<a href="#l19.2274"></a><span id="l19.2274">         curMsg._content = new GlodaContent();</span>
<a href="#l19.2275"></a><span id="l19.2275">       }</span>
<a href="#l19.2276"></a><span id="l19.2276">     }</span>
<a href="#l19.2277"></a><span id="l19.2277" class="difflineminus">-    </span>
<a href="#l19.2278"></a><span id="l19.2278" class="difflineplus">+</span>
<a href="#l19.2279"></a><span id="l19.2279">     if (isConceptuallyNew) {</span>
<a href="#l19.2280"></a><span id="l19.2280">       curMsg._isNew = true;</span>
<a href="#l19.2281"></a><span id="l19.2281">       // curMsg._indexedBodyText is set by GlodaDatastore.insertMessage or</span>
<a href="#l19.2282"></a><span id="l19.2282">       //  GlodaDatastore.updateMessage</span>
<a href="#l19.2283"></a><span id="l19.2283">       curMsg._subject = aMsgHdr.mime2DecodedSubject;</span>
<a href="#l19.2284"></a><span id="l19.2284">       curMsg._attachmentNames = attachmentNames;</span>
<a href="#l19.2285"></a><span id="l19.2285" class="difflineplus">+</span>
<a href="#l19.2286"></a><span id="l19.2286" class="difflineplus">+      // curMsg._indexAuthor gets set by fundattr.js</span>
<a href="#l19.2287"></a><span id="l19.2287" class="difflineplus">+      // curMsg._indexRecipients gets set by fundattr.js</span>
<a href="#l19.2288"></a><span id="l19.2288">     }</span>
<a href="#l19.2289"></a><span id="l19.2289" class="difflineminus">-    </span>
<a href="#l19.2290"></a><span id="l19.2290" class="difflineplus">+</span>
<a href="#l19.2291"></a><span id="l19.2291" class="difflineplus">+    // zero the notability so everything in grokNounItem can just increment</span>
<a href="#l19.2292"></a><span id="l19.2292" class="difflineplus">+    curMsg.notability = 0;</span>
<a href="#l19.2293"></a><span id="l19.2293" class="difflineplus">+</span>
<a href="#l19.2294"></a><span id="l19.2294">     yield aCallbackHandle.pushAndGo(</span>
<a href="#l19.2295"></a><span id="l19.2295">         Gloda.grokNounItem(curMsg,</span>
<a href="#l19.2296"></a><span id="l19.2296">             {header: aMsgHdr, mime: aMimeMsg,</span>
<a href="#l19.2297"></a><span id="l19.2297">              bodyLines: curMsg._bodyLines, content: curMsg._content},</span>
<a href="#l19.2298"></a><span id="l19.2298">             isConceptuallyNew, isRecordNew,</span>
<a href="#l19.2299"></a><span id="l19.2299">             aCallbackHandle));</span>
<a href="#l19.2300"></a><span id="l19.2300" class="difflineminus">-    </span>
<a href="#l19.2301"></a><span id="l19.2301" class="difflineplus">+</span>
<a href="#l19.2302"></a><span id="l19.2302">     delete curMsg._bodyLines;</span>
<a href="#l19.2303"></a><span id="l19.2303">     delete curMsg._content;</span>
<a href="#l19.2304"></a><span id="l19.2304">     delete curMsg._isNew;</span>
<a href="#l19.2305"></a><span id="l19.2305" class="difflineminus">-    </span>
<a href="#l19.2306"></a><span id="l19.2306" class="difflineplus">+    delete curMsg._indexAuthor;</span>
<a href="#l19.2307"></a><span id="l19.2307" class="difflineplus">+    delete curMsg._indexRecipients;</span>
<a href="#l19.2308"></a><span id="l19.2308" class="difflineplus">+</span>
<a href="#l19.2309"></a><span id="l19.2309">     // we want to update the header for messages only after the transaction</span>
<a href="#l19.2310"></a><span id="l19.2310">     //  irrevocably hits the disk.  otherwise we could get confused if the</span>
<a href="#l19.2311"></a><span id="l19.2311">     //  transaction rolls back or what not.</span>
<a href="#l19.2312"></a><span id="l19.2312">     GlodaDatastore.runPostCommit(MakeCleanMsgHdrCallback(aMsgHdr, curMsg.id));</span>
<a href="#l19.2313"></a><span id="l19.2313" class="difflineminus">-    </span>
<a href="#l19.2314"></a><span id="l19.2314" class="difflineplus">+</span>
<a href="#l19.2315"></a><span id="l19.2315">     yield this.kWorkDone;</span>
<a href="#l19.2316"></a><span id="l19.2316">   },</span>
<a href="#l19.2317"></a><span id="l19.2317" class="difflineminus">-  </span>
<a href="#l19.2318"></a><span id="l19.2318" class="difflineplus">+</span>
<a href="#l19.2319"></a><span id="l19.2319">   /**</span>
<a href="#l19.2320"></a><span id="l19.2320">    * Wipe a message out of existence from our index.  This is slightly more</span>
<a href="#l19.2321"></a><span id="l19.2321">    *  tricky than one would first expect because there are potentially</span>
<a href="#l19.2322"></a><span id="l19.2322">    *  attributes not immediately associated with this message that reference</span>
<a href="#l19.2323"></a><span id="l19.2323">    *  the message.  Not only that, but deletion of messages may leave a</span>
<a href="#l19.2324"></a><span id="l19.2324">    *  conversation posessing only ghost messages, which we don't want, so we</span>
<a href="#l19.2325"></a><span id="l19.2325">    *  need to nuke the moot conversation and its moot ghost messages.</span>
<a href="#l19.2326"></a><span id="l19.2326">    * For now, we are actually punting on that trickiness, and the exact</span>
<a href="#l19.2327"></a><span id="l19.2327" class="difflineat">@@ -2599,43 +2610,43 @@ var GlodaIndexer = {</span>
<a href="#l19.2328"></a><span id="l19.2328">    * @TODO: implement deletion of attributes that reference (deleted) messages</span>
<a href="#l19.2329"></a><span id="l19.2329">    */</span>
<a href="#l19.2330"></a><span id="l19.2330">   _deleteMessage: function gloda_index_deleteMessage(aMessage) {</span>
<a href="#l19.2331"></a><span id="l19.2331">     // -- delete our attributes</span>
<a href="#l19.2332"></a><span id="l19.2332">     // delete the message's attributes (if we implement the cascade delete, that</span>
<a href="#l19.2333"></a><span id="l19.2333">     //  could do the honors for us... right now we define the trigger in our</span>
<a href="#l19.2334"></a><span id="l19.2334">     //  schema but the back-end ignores it)</span>
<a href="#l19.2335"></a><span id="l19.2335">     aMessage._datastore.clearMessageAttributes(aMessage);</span>
<a href="#l19.2336"></a><span id="l19.2336" class="difflineminus">-    </span>
<a href="#l19.2337"></a><span id="l19.2337" class="difflineplus">+</span>
<a href="#l19.2338"></a><span id="l19.2338">     // -- delete our message or ghost us, and maybe nuke the whole conversation</span>
<a href="#l19.2339"></a><span id="l19.2339">     // look at the other messages in the conversation.</span>
<a href="#l19.2340"></a><span id="l19.2340">     let conversationCollection = aMessage.conversation.getMessagesCollection(</span>
<a href="#l19.2341"></a><span id="l19.2341">         aCallbackHandle);</span>
<a href="#l19.2342"></a><span id="l19.2342">     yield this.kWorkAsync;</span>
<a href="#l19.2343"></a><span id="l19.2343">     let conversationMsgs = conversationCollection.items;</span>
<a href="#l19.2344"></a><span id="l19.2344" class="difflineminus">-    </span>
<a href="#l19.2345"></a><span id="l19.2345" class="difflineplus">+</span>
<a href="#l19.2346"></a><span id="l19.2346">     let ghosts = [];</span>
<a href="#l19.2347"></a><span id="l19.2347">     let twinMessage = null;</span>
<a href="#l19.2348"></a><span id="l19.2348">     for (let iMsg = 0; iMsg &lt; conversationMsgs.length; iMsg++) {</span>
<a href="#l19.2349"></a><span id="l19.2349">       let convMsg = conversationMsgs[iMsg];</span>
<a href="#l19.2350"></a><span id="l19.2350" class="difflineminus">-      </span>
<a href="#l19.2351"></a><span id="l19.2351" class="difflineplus">+</span>
<a href="#l19.2352"></a><span id="l19.2352">       // ignore our message</span>
<a href="#l19.2353"></a><span id="l19.2353">       if (convMsg.id == aMessage.id)</span>
<a href="#l19.2354"></a><span id="l19.2354">         continue;</span>
<a href="#l19.2355"></a><span id="l19.2355" class="difflineminus">-      </span>
<a href="#l19.2356"></a><span id="l19.2356" class="difflineplus">+</span>
<a href="#l19.2357"></a><span id="l19.2357">       if (convMsg.folderID !== null) {</span>
<a href="#l19.2358"></a><span id="l19.2358">         if (convMsg.headerMessageID == aMessage.headerMessageID) {</span>
<a href="#l19.2359"></a><span id="l19.2359">           twinMessage = convMsg;</span>
<a href="#l19.2360"></a><span id="l19.2360">         }</span>
<a href="#l19.2361"></a><span id="l19.2361">       }</span>
<a href="#l19.2362"></a><span id="l19.2362">       else {</span>
<a href="#l19.2363"></a><span id="l19.2363">         ghosts.push(convMsg);</span>
<a href="#l19.2364"></a><span id="l19.2364">       }</span>
<a href="#l19.2365"></a><span id="l19.2365">     }</span>
<a href="#l19.2366"></a><span id="l19.2366" class="difflineminus">-    </span>
<a href="#l19.2367"></a><span id="l19.2367" class="difflineplus">+</span>
<a href="#l19.2368"></a><span id="l19.2368">     // is everyone else a ghost? (note that conversationMsgs includes us, but</span>
<a href="#l19.2369"></a><span id="l19.2369">     //  ghosts cannot)</span>
<a href="#l19.2370"></a><span id="l19.2370">     if ((conversationMsgs.length - 1) == ghosts.length) {</span>
<a href="#l19.2371"></a><span id="l19.2371">       // obliterate the conversation including aMessage.</span>
<a href="#l19.2372"></a><span id="l19.2372">       // since everyone else is a ghost they have no attributes.  however, the</span>
<a href="#l19.2373"></a><span id="l19.2373">       //  conversation may some day have attributes targeted against it, so it</span>
<a href="#l19.2374"></a><span id="l19.2374">       //  gets a helper.</span>
<a href="#l19.2375"></a><span id="l19.2375">       this._deleteConversationOfMessage(aMessage);</span>
<a href="#l19.2376"></a><span id="l19.2376" class="difflineat">@@ -2647,20 +2658,20 @@ var GlodaIndexer = {</span>
<a href="#l19.2377"></a><span id="l19.2377">         aMessage._datastore.deleteMessageByID(aMessage.id);</span>
<a href="#l19.2378"></a><span id="l19.2378">         aMessage._nuke();</span>
<a href="#l19.2379"></a><span id="l19.2379">       }</span>
<a href="#l19.2380"></a><span id="l19.2380">       else { // ghost us</span>
<a href="#l19.2381"></a><span id="l19.2381">         aMessage._ghost();</span>
<a href="#l19.2382"></a><span id="l19.2382">         aMessage._datastore.updateMessage(aMessage);</span>
<a href="#l19.2383"></a><span id="l19.2383">       }</span>
<a href="#l19.2384"></a><span id="l19.2384">     }</span>
<a href="#l19.2385"></a><span id="l19.2385" class="difflineminus">-    </span>
<a href="#l19.2386"></a><span id="l19.2386" class="difflineplus">+</span>
<a href="#l19.2387"></a><span id="l19.2387">     yield this.kWorkDone;</span>
<a href="#l19.2388"></a><span id="l19.2388">   },</span>
<a href="#l19.2389"></a><span id="l19.2389" class="difflineminus">-  </span>
<a href="#l19.2390"></a><span id="l19.2390" class="difflineplus">+</span>
<a href="#l19.2391"></a><span id="l19.2391">   /**</span>
<a href="#l19.2392"></a><span id="l19.2392">    * Delete an entire conversation, using the passed-in message which must be</span>
<a href="#l19.2393"></a><span id="l19.2393">    *  the last non-ghost in the conversation and have its attributes all</span>
<a href="#l19.2394"></a><span id="l19.2394">    *  deleted.  This function issues the batch delete of all the ghosts (and the</span>
<a href="#l19.2395"></a><span id="l19.2395">    *  message), and in the future will take care to nuke any attributes</span>
<a href="#l19.2396"></a><span id="l19.2396">    *  referencing the conversation.</span>
<a href="#l19.2397"></a><span id="l19.2397">    */</span>
<a href="#l19.2398"></a><span id="l19.2398">   _deleteConversationOfMessage:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1">new file mode 100644</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineminus">--- /dev/null</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/msg_search.js</span>
<a href="#l20.4"></a><span id="l20.4" class="difflineat">@@ -0,0 +1,256 @@</span>
<a href="#l20.5"></a><span id="l20.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l20.6"></a><span id="l20.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l20.7"></a><span id="l20.7" class="difflineplus">+ *</span>
<a href="#l20.8"></a><span id="l20.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l20.9"></a><span id="l20.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l20.10"></a><span id="l20.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l20.11"></a><span id="l20.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineplus">+ *</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l20.14"></a><span id="l20.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l20.15"></a><span id="l20.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l20.16"></a><span id="l20.16" class="difflineplus">+ * License.</span>
<a href="#l20.17"></a><span id="l20.17" class="difflineplus">+ *</span>
<a href="#l20.18"></a><span id="l20.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l20.19"></a><span id="l20.19" class="difflineplus">+ *</span>
<a href="#l20.20"></a><span id="l20.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l20.21"></a><span id="l20.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l20.22"></a><span id="l20.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l20.23"></a><span id="l20.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l20.24"></a><span id="l20.24" class="difflineplus">+ *</span>
<a href="#l20.25"></a><span id="l20.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l20.26"></a><span id="l20.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l20.27"></a><span id="l20.27" class="difflineplus">+ *</span>
<a href="#l20.28"></a><span id="l20.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l20.29"></a><span id="l20.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l20.30"></a><span id="l20.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l20.31"></a><span id="l20.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l20.32"></a><span id="l20.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l20.33"></a><span id="l20.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l20.34"></a><span id="l20.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l20.35"></a><span id="l20.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l20.36"></a><span id="l20.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l20.37"></a><span id="l20.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l20.38"></a><span id="l20.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l20.39"></a><span id="l20.39" class="difflineplus">+ *</span>
<a href="#l20.40"></a><span id="l20.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l20.41"></a><span id="l20.41" class="difflineplus">+</span>
<a href="#l20.42"></a><span id="l20.42" class="difflineplus">+EXPORTED_SYMBOLS = [&quot;GlodaMsgSearcher&quot;];</span>
<a href="#l20.43"></a><span id="l20.43" class="difflineplus">+</span>
<a href="#l20.44"></a><span id="l20.44" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l20.45"></a><span id="l20.45" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l20.46"></a><span id="l20.46" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l20.47"></a><span id="l20.47" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l20.48"></a><span id="l20.48" class="difflineplus">+</span>
<a href="#l20.49"></a><span id="l20.49" class="difflineplus">+Cu.import(&quot;resource://app/modules/gloda/public.js&quot;);</span>
<a href="#l20.50"></a><span id="l20.50" class="difflineplus">+</span>
<a href="#l20.51"></a><span id="l20.51" class="difflineplus">+/**</span>
<a href="#l20.52"></a><span id="l20.52" class="difflineplus">+ * How much time boost should a 'score point' amount to?  The authoritative,</span>
<a href="#l20.53"></a><span id="l20.53" class="difflineplus">+ *  incontrivertible answer, across all time and space, is a week.</span>
<a href="#l20.54"></a><span id="l20.54" class="difflineplus">+ *  Note that gloda stores timestamps as PRTimes for no exceedingly good</span>
<a href="#l20.55"></a><span id="l20.55" class="difflineplus">+ *  reason.</span>
<a href="#l20.56"></a><span id="l20.56" class="difflineplus">+ */</span>
<a href="#l20.57"></a><span id="l20.57" class="difflineplus">+const FUZZSCORE_TIMESTAMP_FACTOR = 1000 * 1000 * 60 * 60 * 24 * 7;</span>
<a href="#l20.58"></a><span id="l20.58" class="difflineplus">+</span>
<a href="#l20.59"></a><span id="l20.59" class="difflineplus">+/**</span>
<a href="#l20.60"></a><span id="l20.60" class="difflineplus">+ * How many score points for each fulltext match?</span>
<a href="#l20.61"></a><span id="l20.61" class="difflineplus">+ */</span>
<a href="#l20.62"></a><span id="l20.62" class="difflineplus">+const FUZZSCORE_FOR_FULLTEXT_MATCH = 1;</span>
<a href="#l20.63"></a><span id="l20.63" class="difflineplus">+</span>
<a href="#l20.64"></a><span id="l20.64" class="difflineplus">+/**</span>
<a href="#l20.65"></a><span id="l20.65" class="difflineplus">+ * Roughly how many characters are in each offset match.  SQLite division is</span>
<a href="#l20.66"></a><span id="l20.66" class="difflineplus">+ *  truncating, so we can have this be slightly higher than the minimum case</span>
<a href="#l20.67"></a><span id="l20.67" class="difflineplus">+ *  (&quot;x x x x&quot;) in recognition that message bodies may be more than 10</span>
<a href="#l20.68"></a><span id="l20.68" class="difflineplus">+ *  characters long and have OFFSET_CHARS_FUZZ help us out so we are still</span>
<a href="#l20.69"></a><span id="l20.69" class="difflineplus">+ *  approximately correct at lower offsets.</span>
<a href="#l20.70"></a><span id="l20.70" class="difflineplus">+ */</span>
<a href="#l20.71"></a><span id="l20.71" class="difflineplus">+const OFFSET_CHARS_PER_FULLTEXT_MATCH = 10;</span>
<a href="#l20.72"></a><span id="l20.72" class="difflineplus">+/**</span>
<a href="#l20.73"></a><span id="l20.73" class="difflineplus">+ * How many characters we should add to the length(osets) to adjust for lack of</span>
<a href="#l20.74"></a><span id="l20.74" class="difflineplus">+ *  trailing whitespace for just one match, but also to compensate for having</span>
<a href="#l20.75"></a><span id="l20.75" class="difflineplus">+ *  OFFSETS_CHARS_PER_FULLTEXT_MATCH be biased towards the existence of</span>
<a href="#l20.76"></a><span id="l20.76" class="difflineplus">+ *  multi-digit character offsets.</span>
<a href="#l20.77"></a><span id="l20.77" class="difflineplus">+ * This value is currently arbitrarily chosen, feel free to do an analysis and</span>
<a href="#l20.78"></a><span id="l20.78" class="difflineplus">+ *  pick a better one.</span>
<a href="#l20.79"></a><span id="l20.79" class="difflineplus">+ */</span>
<a href="#l20.80"></a><span id="l20.80" class="difflineplus">+const OFFSET_CHARS_FUZZ = 6;</span>
<a href="#l20.81"></a><span id="l20.81" class="difflineplus">+</span>
<a href="#l20.82"></a><span id="l20.82" class="difflineplus">+const OFFSET_FUZZSCORE_SQL_SNIPPET =</span>
<a href="#l20.83"></a><span id="l20.83" class="difflineplus">+  &quot;(((length(osets) + &quot; + OFFSET_CHARS_FUZZ + &quot;) / &quot; +</span>
<a href="#l20.84"></a><span id="l20.84" class="difflineplus">+    OFFSET_CHARS_PER_FULLTEXT_MATCH + &quot;) * &quot; +</span>
<a href="#l20.85"></a><span id="l20.85" class="difflineplus">+    FUZZSCORE_FOR_FULLTEXT_MATCH + &quot;)&quot;;</span>
<a href="#l20.86"></a><span id="l20.86" class="difflineplus">+</span>
<a href="#l20.87"></a><span id="l20.87" class="difflineplus">+const FUZZSCORE_SQL_SNIPPET =</span>
<a href="#l20.88"></a><span id="l20.88" class="difflineplus">+  &quot;(&quot; + OFFSET_FUZZSCORE_SQL_SNIPPET + &quot; + notability)&quot;;</span>
<a href="#l20.89"></a><span id="l20.89" class="difflineplus">+</span>
<a href="#l20.90"></a><span id="l20.90" class="difflineplus">+const DASCORE_SQL_SNIPPET =</span>
<a href="#l20.91"></a><span id="l20.91" class="difflineplus">+  &quot;((&quot; + FUZZSCORE_SQL_SNIPPET + &quot; * &quot; + FUZZSCORE_TIMESTAMP_FACTOR +</span>
<a href="#l20.92"></a><span id="l20.92" class="difflineplus">+    &quot;) + date)&quot;;</span>
<a href="#l20.93"></a><span id="l20.93" class="difflineplus">+</span>
<a href="#l20.94"></a><span id="l20.94" class="difflineplus">+const FULLTEXT_QUERY_EXPLICIT_SQL =</span>
<a href="#l20.95"></a><span id="l20.95" class="difflineplus">+  &quot;SELECT messages.*, offsets(messagesText) AS osets &quot; +</span>
<a href="#l20.96"></a><span id="l20.96" class="difflineplus">+    &quot;FROM messages, messagesText WHERE messagesText MATCH ?&quot; +</span>
<a href="#l20.97"></a><span id="l20.97" class="difflineplus">+    &quot; AND messages.id == messagesText.docid&quot;;</span>
<a href="#l20.98"></a><span id="l20.98" class="difflineplus">+</span>
<a href="#l20.99"></a><span id="l20.99" class="difflineplus">+</span>
<a href="#l20.100"></a><span id="l20.100" class="difflineplus">+function identityFunc(x) {</span>
<a href="#l20.101"></a><span id="l20.101" class="difflineplus">+  return x;</span>
<a href="#l20.102"></a><span id="l20.102" class="difflineplus">+}</span>
<a href="#l20.103"></a><span id="l20.103" class="difflineplus">+</span>
<a href="#l20.104"></a><span id="l20.104" class="difflineplus">+function oneLessMaxZero(x) {</span>
<a href="#l20.105"></a><span id="l20.105" class="difflineplus">+  if (x &lt;= 1)</span>
<a href="#l20.106"></a><span id="l20.106" class="difflineplus">+    return 0;</span>
<a href="#l20.107"></a><span id="l20.107" class="difflineplus">+  else</span>
<a href="#l20.108"></a><span id="l20.108" class="difflineplus">+    return x - 1;</span>
<a href="#l20.109"></a><span id="l20.109" class="difflineplus">+}</span>
<a href="#l20.110"></a><span id="l20.110" class="difflineplus">+</span>
<a href="#l20.111"></a><span id="l20.111" class="difflineplus">+function reduceSum(accum, curValue) {</span>
<a href="#l20.112"></a><span id="l20.112" class="difflineplus">+  return accum + curValue;</span>
<a href="#l20.113"></a><span id="l20.113" class="difflineplus">+}</span>
<a href="#l20.114"></a><span id="l20.114" class="difflineplus">+</span>
<a href="#l20.115"></a><span id="l20.115" class="difflineplus">+/*</span>
<a href="#l20.116"></a><span id="l20.116" class="difflineplus">+ * Columns are: subject, body, attachment names, author, recipients</span>
<a href="#l20.117"></a><span id="l20.117" class="difflineplus">+ */</span>
<a href="#l20.118"></a><span id="l20.118" class="difflineplus">+</span>
<a href="#l20.119"></a><span id="l20.119" class="difflineplus">+/**</span>
<a href="#l20.120"></a><span id="l20.120" class="difflineplus">+ * Scores if all search terms match in a column.  We bias against author</span>
<a href="#l20.121"></a><span id="l20.121" class="difflineplus">+ *  slightly and recipient a bit more in this case because a search that</span>
<a href="#l20.122"></a><span id="l20.122" class="difflineplus">+ *  entirely matches just on a person should give a mention of that person</span>
<a href="#l20.123"></a><span id="l20.123" class="difflineplus">+ *  in the subject or attachment a fighting chance.</span>
<a href="#l20.124"></a><span id="l20.124" class="difflineplus">+ * Keep in mind that because of our indexing in the face of address book</span>
<a href="#l20.125"></a><span id="l20.125" class="difflineplus">+ *  contacts (namely, we index the name used in the e-mail as well as the</span>
<a href="#l20.126"></a><span id="l20.126" class="difflineplus">+ *  display name on the address book card associated with the e-mail adress)</span>
<a href="#l20.127"></a><span id="l20.127" class="difflineplus">+ *  a contact is going to bias towards matching multiple times.</span>
<a href="#l20.128"></a><span id="l20.128" class="difflineplus">+ */</span>
<a href="#l20.129"></a><span id="l20.129" class="difflineplus">+const COLUMN_ALL_MATCH_SCORES = [20, 4, 20, 16, 12];</span>
<a href="#l20.130"></a><span id="l20.130" class="difflineplus">+/**</span>
<a href="#l20.131"></a><span id="l20.131" class="difflineplus">+ * Score for each distinct term that matches in the column.  This is capped</span>
<a href="#l20.132"></a><span id="l20.132" class="difflineplus">+ *  by COLUMN_ALL_SCORES.</span>
<a href="#l20.133"></a><span id="l20.133" class="difflineplus">+ */</span>
<a href="#l20.134"></a><span id="l20.134" class="difflineplus">+const COLUMN_PARTIAL_PER_MATCH_SCORES = [4, 1, 4, 4, 3];</span>
<a href="#l20.135"></a><span id="l20.135" class="difflineplus">+/**</span>
<a href="#l20.136"></a><span id="l20.136" class="difflineplus">+ * If a term matches multiple times, what is the marginal score for each</span>
<a href="#l20.137"></a><span id="l20.137" class="difflineplus">+ *  additional match.  We count the total number of matches beyond the</span>
<a href="#l20.138"></a><span id="l20.138" class="difflineplus">+ *  first match for each term.  In other words, if we have 3 terms which</span>
<a href="#l20.139"></a><span id="l20.139" class="difflineplus">+ *  matched 5, 3, and 0 times, then the total from our perspective is</span>
<a href="#l20.140"></a><span id="l20.140" class="difflineplus">+ *  (5 - 1) + (3 - 1) + 0 = 4 + 2 + 0 = 6.  We take the minimum of that value</span>
<a href="#l20.141"></a><span id="l20.141" class="difflineplus">+ *  and the value in COLUMN_MULTIPLE_MATCH_LIMIT and multiply by the value in</span>
<a href="#l20.142"></a><span id="l20.142" class="difflineplus">+ *  COLUMN_MULTIPLE_MATCH_SCORES.</span>
<a href="#l20.143"></a><span id="l20.143" class="difflineplus">+ */</span>
<a href="#l20.144"></a><span id="l20.144" class="difflineplus">+const COLUMN_MULTIPLE_MATCH_SCORES = [0, 1, 0, 0, 0];</span>
<a href="#l20.145"></a><span id="l20.145" class="difflineplus">+const COLUMN_MULTIPLE_MATCH_LIMIT = [0, 10, 0, 0, 0];</span>
<a href="#l20.146"></a><span id="l20.146" class="difflineplus">+</span>
<a href="#l20.147"></a><span id="l20.147" class="difflineplus">+/**</span>
<a href="#l20.148"></a><span id="l20.148" class="difflineplus">+ * Score the message on its offsets (from stashedColumns).</span>
<a href="#l20.149"></a><span id="l20.149" class="difflineplus">+ */</span>
<a href="#l20.150"></a><span id="l20.150" class="difflineplus">+function scoreOffsets(aMessage, aContext) {</span>
<a href="#l20.151"></a><span id="l20.151" class="difflineplus">+  let score = 0;</span>
<a href="#l20.152"></a><span id="l20.152" class="difflineplus">+</span>
<a href="#l20.153"></a><span id="l20.153" class="difflineplus">+  let termTemplate = [0 for each (term in Iterator(aContext.terms, true))];</span>
<a href="#l20.154"></a><span id="l20.154" class="difflineplus">+  // for each column, a list of the incidence of each term</span>
<a href="#l20.155"></a><span id="l20.155" class="difflineplus">+  let columnTermIncidence = [termTemplate.concat(),</span>
<a href="#l20.156"></a><span id="l20.156" class="difflineplus">+                             termTemplate.concat(),</span>
<a href="#l20.157"></a><span id="l20.157" class="difflineplus">+                             termTemplate.concat(),</span>
<a href="#l20.158"></a><span id="l20.158" class="difflineplus">+                             termTemplate.concat(),</span>
<a href="#l20.159"></a><span id="l20.159" class="difflineplus">+                             termTemplate.concat()];</span>
<a href="#l20.160"></a><span id="l20.160" class="difflineplus">+</span>
<a href="#l20.161"></a><span id="l20.161" class="difflineplus">+  // we need a friendlyParseInt because otherwise the radix stuff happens</span>
<a href="#l20.162"></a><span id="l20.162" class="difflineplus">+  //  because of the extra arguments map parses.  curse you, map!</span>
<a href="#l20.163"></a><span id="l20.163" class="difflineplus">+  let offsetNums =</span>
<a href="#l20.164"></a><span id="l20.164" class="difflineplus">+    [parseInt(x) for each (x in aContext.stashedColumns[aMessage.id][0].split(&quot; &quot;))];</span>
<a href="#l20.165"></a><span id="l20.165" class="difflineplus">+  for (let i=0; i &lt; offsetNums.length; i += 4) {</span>
<a href="#l20.166"></a><span id="l20.166" class="difflineplus">+    let columnIndex = offsetNums[i];</span>
<a href="#l20.167"></a><span id="l20.167" class="difflineplus">+    let termIndex = offsetNums[i+1];</span>
<a href="#l20.168"></a><span id="l20.168" class="difflineplus">+    columnTermIncidence[columnIndex][termIndex]++;</span>
<a href="#l20.169"></a><span id="l20.169" class="difflineplus">+  }</span>
<a href="#l20.170"></a><span id="l20.170" class="difflineplus">+</span>
<a href="#l20.171"></a><span id="l20.171" class="difflineplus">+  for (let iColumn = 0; iColumn &lt; COLUMN_ALL_MATCH_SCORES.length; iColumn++) {</span>
<a href="#l20.172"></a><span id="l20.172" class="difflineplus">+    let termIncidence = columnTermIncidence[iColumn];</span>
<a href="#l20.173"></a><span id="l20.173" class="difflineplus">+    // bestow all match credit</span>
<a href="#l20.174"></a><span id="l20.174" class="difflineplus">+    if (termIncidence.every(identityFunc))</span>
<a href="#l20.175"></a><span id="l20.175" class="difflineplus">+      score += COLUMN_ALL_MATCH_SCORES[iColumn];</span>
<a href="#l20.176"></a><span id="l20.176" class="difflineplus">+    // bestow partial match credit</span>
<a href="#l20.177"></a><span id="l20.177" class="difflineplus">+    else if (termIncidence.some(identityFunc))</span>
<a href="#l20.178"></a><span id="l20.178" class="difflineplus">+      score += Math.min(COLUMN_ALL_MATCH_SCORES[iColumn],</span>
<a href="#l20.179"></a><span id="l20.179" class="difflineplus">+                        COLUMN_PARTIAL_PER_MATCH_SCORES[iColumn] *</span>
<a href="#l20.180"></a><span id="l20.180" class="difflineplus">+                          termIncidence.filter(identityFunc).length);</span>
<a href="#l20.181"></a><span id="l20.181" class="difflineplus">+    // bestow multiple match credit</span>
<a href="#l20.182"></a><span id="l20.182" class="difflineplus">+    score += Math.min(termIncidence.map(oneLessMaxZero).reduce(reduceSum, 0),</span>
<a href="#l20.183"></a><span id="l20.183" class="difflineplus">+                      COLUMN_MULTIPLE_MATCH_LIMIT[iColumn]) *</span>
<a href="#l20.184"></a><span id="l20.184" class="difflineplus">+             COLUMN_MULTIPLE_MATCH_SCORES[iColumn];</span>
<a href="#l20.185"></a><span id="l20.185" class="difflineplus">+  }</span>
<a href="#l20.186"></a><span id="l20.186" class="difflineplus">+</span>
<a href="#l20.187"></a><span id="l20.187" class="difflineplus">+  return score;</span>
<a href="#l20.188"></a><span id="l20.188" class="difflineplus">+}</span>
<a href="#l20.189"></a><span id="l20.189" class="difflineplus">+</span>
<a href="#l20.190"></a><span id="l20.190" class="difflineplus">+</span>
<a href="#l20.191"></a><span id="l20.191" class="difflineplus">+function GlodaMsgSearcher(aViewWrapper, aFulltextTerms) {</span>
<a href="#l20.192"></a><span id="l20.192" class="difflineplus">+  this.viewWrapper = aViewWrapper;</span>
<a href="#l20.193"></a><span id="l20.193" class="difflineplus">+</span>
<a href="#l20.194"></a><span id="l20.194" class="difflineplus">+  this.fulltextTerms = aFulltextTerms;</span>
<a href="#l20.195"></a><span id="l20.195" class="difflineplus">+</span>
<a href="#l20.196"></a><span id="l20.196" class="difflineplus">+  this.query = null;</span>
<a href="#l20.197"></a><span id="l20.197" class="difflineplus">+  this.collection = null;</span>
<a href="#l20.198"></a><span id="l20.198" class="difflineplus">+</span>
<a href="#l20.199"></a><span id="l20.199" class="difflineplus">+  this.scoresByUriAndKey = {};</span>
<a href="#l20.200"></a><span id="l20.200" class="difflineplus">+  this.whysByUriAndKey = {};</span>
<a href="#l20.201"></a><span id="l20.201" class="difflineplus">+}</span>
<a href="#l20.202"></a><span id="l20.202" class="difflineplus">+GlodaMsgSearcher.prototype = {</span>
<a href="#l20.203"></a><span id="l20.203" class="difflineplus">+  /**</span>
<a href="#l20.204"></a><span id="l20.204" class="difflineplus">+   * Number of messages to retrieve initially.</span>
<a href="#l20.205"></a><span id="l20.205" class="difflineplus">+   */</span>
<a href="#l20.206"></a><span id="l20.206" class="difflineplus">+  retrievalLimit: 100,</span>
<a href="#l20.207"></a><span id="l20.207" class="difflineplus">+</span>
<a href="#l20.208"></a><span id="l20.208" class="difflineplus">+  buildFulltextQuery: function GlodaMsgSearcher_buildFulltextQuery() {</span>
<a href="#l20.209"></a><span id="l20.209" class="difflineplus">+    let query = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l20.210"></a><span id="l20.210" class="difflineplus">+      noMagic: true,</span>
<a href="#l20.211"></a><span id="l20.211" class="difflineplus">+      explicitSQL: FULLTEXT_QUERY_EXPLICIT_SQL,</span>
<a href="#l20.212"></a><span id="l20.212" class="difflineplus">+      // osets is 0-based column number 9 (volatile to column changes)</span>
<a href="#l20.213"></a><span id="l20.213" class="difflineplus">+      // dascore becomes 0-based column number 10</span>
<a href="#l20.214"></a><span id="l20.214" class="difflineplus">+      outerWrapColumns: [DASCORE_SQL_SNIPPET + &quot; AS dascore&quot;],</span>
<a href="#l20.215"></a><span id="l20.215" class="difflineplus">+      // save the offset column for extra analysis</span>
<a href="#l20.216"></a><span id="l20.216" class="difflineplus">+      stashColumns: [9]</span>
<a href="#l20.217"></a><span id="l20.217" class="difflineplus">+    });</span>
<a href="#l20.218"></a><span id="l20.218" class="difflineplus">+</span>
<a href="#l20.219"></a><span id="l20.219" class="difflineplus">+    query.fulltextMatches(this.fulltextTerms.join(&quot; &quot;));</span>
<a href="#l20.220"></a><span id="l20.220" class="difflineplus">+    query.orderBy('-dascore');</span>
<a href="#l20.221"></a><span id="l20.221" class="difflineplus">+    query.limit(this.retrievalLimit);</span>
<a href="#l20.222"></a><span id="l20.222" class="difflineplus">+</span>
<a href="#l20.223"></a><span id="l20.223" class="difflineplus">+    return query;</span>
<a href="#l20.224"></a><span id="l20.224" class="difflineplus">+  },</span>
<a href="#l20.225"></a><span id="l20.225" class="difflineplus">+</span>
<a href="#l20.226"></a><span id="l20.226" class="difflineplus">+  go: function GlodaMsgSearcher_go() {</span>
<a href="#l20.227"></a><span id="l20.227" class="difflineplus">+    this.query = this.buildFulltextQuery();</span>
<a href="#l20.228"></a><span id="l20.228" class="difflineplus">+    this.collection = this.query.getCollection(this);</span>
<a href="#l20.229"></a><span id="l20.229" class="difflineplus">+</span>
<a href="#l20.230"></a><span id="l20.230" class="difflineplus">+    return this.collection;</span>
<a href="#l20.231"></a><span id="l20.231" class="difflineplus">+  },</span>
<a href="#l20.232"></a><span id="l20.232" class="difflineplus">+</span>
<a href="#l20.233"></a><span id="l20.233" class="difflineplus">+  onItemsAdded: function GlodaMsgSearcher_onItemsAdded(aItems, aCollection) {</span>
<a href="#l20.234"></a><span id="l20.234" class="difflineplus">+    let scores = Gloda.scoreNounItems(</span>
<a href="#l20.235"></a><span id="l20.235" class="difflineplus">+      aItems,</span>
<a href="#l20.236"></a><span id="l20.236" class="difflineplus">+      {</span>
<a href="#l20.237"></a><span id="l20.237" class="difflineplus">+        terms: this.fulltextTerms,</span>
<a href="#l20.238"></a><span id="l20.238" class="difflineplus">+        stashedColumns: aCollection.stashedColumns</span>
<a href="#l20.239"></a><span id="l20.239" class="difflineplus">+      },</span>
<a href="#l20.240"></a><span id="l20.240" class="difflineplus">+      [scoreOffsets]);</span>
<a href="#l20.241"></a><span id="l20.241" class="difflineplus">+    let actualItems = [];</span>
<a href="#l20.242"></a><span id="l20.242" class="difflineplus">+    for (let i = 0; i &lt; aItems.length; i++) {</span>
<a href="#l20.243"></a><span id="l20.243" class="difflineplus">+      let item = aItems[i];</span>
<a href="#l20.244"></a><span id="l20.244" class="difflineplus">+      let score = scores[i];</span>
<a href="#l20.245"></a><span id="l20.245" class="difflineplus">+</span>
<a href="#l20.246"></a><span id="l20.246" class="difflineplus">+      let hdr = item.folderMessage;</span>
<a href="#l20.247"></a><span id="l20.247" class="difflineplus">+      if (hdr) {</span>
<a href="#l20.248"></a><span id="l20.248" class="difflineplus">+        this.scoresByUriAndKey[hdr.folder.URI + &quot;-&quot; + hdr.messageKey] = score;</span>
<a href="#l20.249"></a><span id="l20.249" class="difflineplus">+        actualItems.push(item);</span>
<a href="#l20.250"></a><span id="l20.250" class="difflineplus">+      }</span>
<a href="#l20.251"></a><span id="l20.251" class="difflineplus">+    }</span>
<a href="#l20.252"></a><span id="l20.252" class="difflineplus">+</span>
<a href="#l20.253"></a><span id="l20.253" class="difflineplus">+    this.viewWrapper.onItemsAdded(actualItems, aCollection);</span>
<a href="#l20.254"></a><span id="l20.254" class="difflineplus">+  },</span>
<a href="#l20.255"></a><span id="l20.255" class="difflineplus">+  onItemsModified: function GlodaMsgSearcher_onItemsModified() {},</span>
<a href="#l20.256"></a><span id="l20.256" class="difflineplus">+  onItemsRemoved: function GlodaMsgSearcher_onItemsRemoved() {},</span>
<a href="#l20.257"></a><span id="l20.257" class="difflineplus">+  onQueryCompleted: function GlodaMsgSearcher_onQueryCompleted(aCollection) {</span>
<a href="#l20.258"></a><span id="l20.258" class="difflineplus">+    this.viewWrapper.onQueryCompleted(aCollection);</span>
<a href="#l20.259"></a><span id="l20.259" class="difflineplus">+  },</span>
<a href="#l20.260"></a><span id="l20.260" class="difflineplus">+};</span>
<a href="#l20.261"></a><span id="l20.261">\ No newline at end of file</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/mailnews/db/gloda/modules/query.js</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/query.js</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -1,16 +1,16 @@</span>
<a href="#l21.4"></a><span id="l21.4"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l21.5"></a><span id="l21.5">  *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l21.6"></a><span id="l21.6">  *</span>
<a href="#l21.7"></a><span id="l21.7">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l21.8"></a><span id="l21.8">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l21.9"></a><span id="l21.9">  * the License. You may obtain a copy of the License at</span>
<a href="#l21.10"></a><span id="l21.10">  * http://www.mozilla.org/MPL/</span>
<a href="#l21.11"></a><span id="l21.11" class="difflineminus">- * </span>
<a href="#l21.12"></a><span id="l21.12" class="difflineplus">+ *</span>
<a href="#l21.13"></a><span id="l21.13">  * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l21.14"></a><span id="l21.14">  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l21.15"></a><span id="l21.15">  * for the specific language governing rights and limitations under the</span>
<a href="#l21.16"></a><span id="l21.16">  * License.</span>
<a href="#l21.17"></a><span id="l21.17">  *</span>
<a href="#l21.18"></a><span id="l21.18">  * The Original Code is Thunderbird Global Database.</span>
<a href="#l21.19"></a><span id="l21.19">  *</span>
<a href="#l21.20"></a><span id="l21.20">  * The Initial Developer of the Original Code is</span>
<a href="#l21.21"></a><span id="l21.21" class="difflineat">@@ -27,17 +27,17 @@</span>
<a href="#l21.22"></a><span id="l21.22">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l21.23"></a><span id="l21.23">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l21.24"></a><span id="l21.24">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l21.25"></a><span id="l21.25">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l21.26"></a><span id="l21.26">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l21.27"></a><span id="l21.27">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l21.28"></a><span id="l21.28">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l21.29"></a><span id="l21.29">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l21.30"></a><span id="l21.30" class="difflineminus">- * </span>
<a href="#l21.31"></a><span id="l21.31" class="difflineplus">+ *</span>
<a href="#l21.32"></a><span id="l21.32">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l21.33"></a><span id="l21.33"> </span>
<a href="#l21.34"></a><span id="l21.34"> EXPORTED_SYMBOLS = [&quot;GlodaQueryClassFactory&quot;];</span>
<a href="#l21.35"></a><span id="l21.35"> </span>
<a href="#l21.36"></a><span id="l21.36"> const Cc = Components.classes;</span>
<a href="#l21.37"></a><span id="l21.37"> const Ci = Components.interfaces;</span>
<a href="#l21.38"></a><span id="l21.38"> const Cr = Components.results;</span>
<a href="#l21.39"></a><span id="l21.39"> const Cu = Components.utils;</span>
<a href="#l21.40"></a><span id="l21.40" class="difflineat">@@ -46,109 +46,135 @@ Cu.import(&quot;resource://app/modules/gloda/</span>
<a href="#l21.41"></a><span id="l21.41"> </span>
<a href="#l21.42"></a><span id="l21.42"> // GlodaDatastore has some constants we need, and oddly enough, there was no</span>
<a href="#l21.43"></a><span id="l21.43"> //  load dependency preventing us from doing this.</span>
<a href="#l21.44"></a><span id="l21.44"> Cu.import(&quot;resource://app/modules/gloda/datastore.js&quot;);</span>
<a href="#l21.45"></a><span id="l21.45"> </span>
<a href="#l21.46"></a><span id="l21.46"> /**</span>
<a href="#l21.47"></a><span id="l21.47">  * @class Query class core; each noun gets its own sub-class where attributes</span>
<a href="#l21.48"></a><span id="l21.48">  *  have helper methods bound.</span>
<a href="#l21.49"></a><span id="l21.49" class="difflineminus">- * </span>
<a href="#l21.50"></a><span id="l21.50" class="difflineplus">+ *</span>
<a href="#l21.51"></a><span id="l21.51" class="difflineplus">+ * @param aOptions A dictionary of options.  Current legal options are:</span>
<a href="#l21.52"></a><span id="l21.52" class="difflineplus">+ *     - noMagic: Indicates that the noun's dbQueryJoinMagic should be ignored.</span>
<a href="#l21.53"></a><span id="l21.53" class="difflineplus">+ *                Currently, this means that messages will not have their</span>
<a href="#l21.54"></a><span id="l21.54" class="difflineplus">+ *                full-text indexed values re-attached.  This is planned to be</span>
<a href="#l21.55"></a><span id="l21.55" class="difflineplus">+ *                offset by having queries/cache lookups that do not request</span>
<a href="#l21.56"></a><span id="l21.56" class="difflineplus">+ *                noMagic to ensure that their data does get loaded.</span>
<a href="#l21.57"></a><span id="l21.57" class="difflineplus">+ *     - explicitSQL: A hand-rolled alternate representation for the core</span>
<a href="#l21.58"></a><span id="l21.58" class="difflineplus">+ *           SELECT portion of the SQL query.  The queryFromQuery logic still</span>
<a href="#l21.59"></a><span id="l21.59" class="difflineplus">+ *           generates its normal query, we just ignore its result in favor of</span>
<a href="#l21.60"></a><span id="l21.60" class="difflineplus">+ *           your provided value.  This means that the positional parameter</span>
<a href="#l21.61"></a><span id="l21.61" class="difflineplus">+ *           list is still built and you should/must rely on those bound</span>
<a href="#l21.62"></a><span id="l21.62" class="difflineplus">+ *           parameters (using '?').  The replacement occurs prior to the</span>
<a href="#l21.63"></a><span id="l21.63" class="difflineplus">+ *           outerWrapColumns, ORDER BY, and LIMIT contributions to the query.</span>
<a href="#l21.64"></a><span id="l21.64" class="difflineplus">+ *     - outerWrapColumns: If provided, wraps the query in a &quot;SELECT *,blah</span>
<a href="#l21.65"></a><span id="l21.65" class="difflineplus">+ *           FROM (actual query)&quot; where blah is your list of outerWrapColumns</span>
<a href="#l21.66"></a><span id="l21.66" class="difflineplus">+ *           made comma-delimited.  The idea is that this allows you to</span>
<a href="#l21.67"></a><span id="l21.67" class="difflineplus">+ *           reference the result of expressions inside the query using their</span>
<a href="#l21.68"></a><span id="l21.68" class="difflineplus">+ *           names rather than having to duplicate the logic.  In practice,</span>
<a href="#l21.69"></a><span id="l21.69" class="difflineplus">+ *           this makes things more readable but is unlikely to improve</span>
<a href="#l21.70"></a><span id="l21.70" class="difflineplus">+ *           performance.  (Namely, my use of 'offsets' for full-text stuff</span>
<a href="#l21.71"></a><span id="l21.71" class="difflineplus">+ *           ends up in the EXPLAIN plan twice despite this.)</span>
<a href="#l21.72"></a><span id="l21.72" class="difflineplus">+ *</span>
<a href="#l21.73"></a><span id="l21.73">  * @property _owner The query instance that holds the list of unions...</span>
<a href="#l21.74"></a><span id="l21.74">  * @property _constraints A list of (lists of OR constraints) that are ANDed</span>
<a href="#l21.75"></a><span id="l21.75">  *     together.  For example [[FROM bob, FROM jim], [DATE last week]] would</span>
<a href="#l21.76"></a><span id="l21.76">  *     be requesting us to find all the messages from either bob or jim, and</span>
<a href="#l21.77"></a><span id="l21.77">  *     sent in the last week.</span>
<a href="#l21.78"></a><span id="l21.78">  * @property _unions A list of other queries whose results are unioned with our</span>
<a href="#l21.79"></a><span id="l21.79">  *     own.  There is no concept of nesting or sub-queries apart from this</span>
<a href="#l21.80"></a><span id="l21.80">  *     mechanism.</span>
<a href="#l21.81"></a><span id="l21.81">  */</span>
<a href="#l21.82"></a><span id="l21.82" class="difflineminus">-function GlodaQueryClass() {</span>
<a href="#l21.83"></a><span id="l21.83" class="difflineplus">+function GlodaQueryClass(aOptions) {</span>
<a href="#l21.84"></a><span id="l21.84" class="difflineplus">+  this.options = (aOptions != null) ? aOptions : {};</span>
<a href="#l21.85"></a><span id="l21.85" class="difflineplus">+</span>
<a href="#l21.86"></a><span id="l21.86">   // if we are an 'or' clause, who is our parent whom other 'or' clauses should</span>
<a href="#l21.87"></a><span id="l21.87">   //  spawn from...</span>
<a href="#l21.88"></a><span id="l21.88">   this._owner = null;</span>
<a href="#l21.89"></a><span id="l21.89">   // our personal chain of and-ing.</span>
<a href="#l21.90"></a><span id="l21.90">   this._constraints = [];</span>
<a href="#l21.91"></a><span id="l21.91">   // the other instances we union with</span>
<a href="#l21.92"></a><span id="l21.92">   this._unions = [];</span>
<a href="#l21.93"></a><span id="l21.93" class="difflineminus">-  </span>
<a href="#l21.94"></a><span id="l21.94" class="difflineplus">+</span>
<a href="#l21.95"></a><span id="l21.95">   this._order = [];</span>
<a href="#l21.96"></a><span id="l21.96">   this._limit = 0;</span>
<a href="#l21.97"></a><span id="l21.97"> }</span>
<a href="#l21.98"></a><span id="l21.98"> </span>
<a href="#l21.99"></a><span id="l21.99"> GlodaQueryClass.prototype = {</span>
<a href="#l21.100"></a><span id="l21.100">   WILDCARD: {},</span>
<a href="#l21.101"></a><span id="l21.101" class="difflineminus">-  </span>
<a href="#l21.102"></a><span id="l21.102" class="difflineplus">+</span>
<a href="#l21.103"></a><span id="l21.103">   get constraintCount() {</span>
<a href="#l21.104"></a><span id="l21.104">     return this._constraints.length;</span>
<a href="#l21.105"></a><span id="l21.105">   },</span>
<a href="#l21.106"></a><span id="l21.106" class="difflineminus">-  </span>
<a href="#l21.107"></a><span id="l21.107" class="difflineplus">+</span>
<a href="#l21.108"></a><span id="l21.108">   or: function gloda_query_or() {</span>
<a href="#l21.109"></a><span id="l21.109">     let owner = this._owner || this;</span>
<a href="#l21.110"></a><span id="l21.110">     let orQuery = new this._queryClass();</span>
<a href="#l21.111"></a><span id="l21.111">     orQuery._owner = owner;</span>
<a href="#l21.112"></a><span id="l21.112">     owner._unions.push(orQuery);</span>
<a href="#l21.113"></a><span id="l21.113">     return orQuery;</span>
<a href="#l21.114"></a><span id="l21.114">   },</span>
<a href="#l21.115"></a><span id="l21.115" class="difflineminus">-  </span>
<a href="#l21.116"></a><span id="l21.116" class="difflineplus">+</span>
<a href="#l21.117"></a><span id="l21.117">   orderBy: function gloda_query_orderBy() {</span>
<a href="#l21.118"></a><span id="l21.118">     for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l21.119"></a><span id="l21.119">       let arg = arguments[iArg];</span>
<a href="#l21.120"></a><span id="l21.120">       this._order.push(arg);</span>
<a href="#l21.121"></a><span id="l21.121">     }</span>
<a href="#l21.122"></a><span id="l21.122">     return this;</span>
<a href="#l21.123"></a><span id="l21.123">   },</span>
<a href="#l21.124"></a><span id="l21.124" class="difflineminus">-  </span>
<a href="#l21.125"></a><span id="l21.125" class="difflineplus">+</span>
<a href="#l21.126"></a><span id="l21.126">   limit: function gloda_query_limit(aLimit) {</span>
<a href="#l21.127"></a><span id="l21.127">     this._limit = aLimit;</span>
<a href="#l21.128"></a><span id="l21.128">     return this;</span>
<a href="#l21.129"></a><span id="l21.129">   },</span>
<a href="#l21.130"></a><span id="l21.130" class="difflineminus">-  </span>
<a href="#l21.131"></a><span id="l21.131" class="difflineplus">+</span>
<a href="#l21.132"></a><span id="l21.132">   /**</span>
<a href="#l21.133"></a><span id="l21.133">    * Return a collection asynchronously populated by this collection.  You must</span>
<a href="#l21.134"></a><span id="l21.134">    *  provide a listener to receive notifications from the collection as it</span>
<a href="#l21.135"></a><span id="l21.135">    *  receives updates.  The listener object should implement onItemsAdded,</span>
<a href="#l21.136"></a><span id="l21.136">    *  onItemsModified, and onItemsRemoved methods, all of which take a single</span>
<a href="#l21.137"></a><span id="l21.137">    *  argument which is the list of items which have been added, modified, or</span>
<a href="#l21.138"></a><span id="l21.138">    *  removed respectively.</span>
<a href="#l21.139"></a><span id="l21.139">    */</span>
<a href="#l21.140"></a><span id="l21.140">   getCollection: function gloda_query_getCollection(aListener, aData) {</span>
<a href="#l21.141"></a><span id="l21.141">     return this._nounDef.datastore.queryFromQuery(this, aListener, aData);</span>
<a href="#l21.142"></a><span id="l21.142">   },</span>
<a href="#l21.143"></a><span id="l21.143" class="difflineminus">-  </span>
<a href="#l21.144"></a><span id="l21.144" class="difflineplus">+</span>
<a href="#l21.145"></a><span id="l21.145">   /**</span>
<a href="#l21.146"></a><span id="l21.146">    * Test whether the given first-class noun instance satisfies this query.</span>
<a href="#l21.147"></a><span id="l21.147" class="difflineminus">-   * </span>
<a href="#l21.148"></a><span id="l21.148" class="difflineplus">+   *</span>
<a href="#l21.149"></a><span id="l21.149" class="difflineplus">+   * @testpoint gloda.query.test</span>
<a href="#l21.150"></a><span id="l21.150">    */</span>
<a href="#l21.151"></a><span id="l21.151">   test: function gloda_query_test(aObj) {</span>
<a href="#l21.152"></a><span id="l21.152">     // when changing this method, be sure that GlodaDatastore's queryFromQuery</span>
<a href="#l21.153"></a><span id="l21.153" class="difflineminus">-    //  method likewise has any required changes made. </span>
<a href="#l21.154"></a><span id="l21.154" class="difflineplus">+    //  method likewise has any required changes made.</span>
<a href="#l21.155"></a><span id="l21.155">     let unionQueries = [this].concat(this._unions);</span>
<a href="#l21.156"></a><span id="l21.156" class="difflineminus">-    </span>
<a href="#l21.157"></a><span id="l21.157" class="difflineplus">+</span>
<a href="#l21.158"></a><span id="l21.158">     for (let iUnion = 0; iUnion &lt; unionQueries.length; iUnion++) {</span>
<a href="#l21.159"></a><span id="l21.159">       let curQuery = unionQueries[iUnion];</span>
<a href="#l21.160"></a><span id="l21.160"> </span>
<a href="#l21.161"></a><span id="l21.161">       // assume success until a specific (or) constraint proves us wrong</span>
<a href="#l21.162"></a><span id="l21.162">       let querySatisfied = true;</span>
<a href="#l21.163"></a><span id="l21.163" class="difflineminus">-      for (let iConstraint = 0; iConstraint &lt; curQuery._constraints.length; </span>
<a href="#l21.164"></a><span id="l21.164" class="difflineplus">+      for (let iConstraint = 0; iConstraint &lt; curQuery._constraints.length;</span>
<a href="#l21.165"></a><span id="l21.165">            iConstraint++) {</span>
<a href="#l21.166"></a><span id="l21.166">         let constraint = curQuery._constraints[iConstraint];</span>
<a href="#l21.167"></a><span id="l21.167">         let [constraintType, attrDef] = constraint;</span>
<a href="#l21.168"></a><span id="l21.168">         let constraintValues = constraint.slice(2);</span>
<a href="#l21.169"></a><span id="l21.169"> </span>
<a href="#l21.170"></a><span id="l21.170">         if (constraintType === GlodaDatastore.kConstraintIdIn) {</span>
<a href="#l21.171"></a><span id="l21.171">           if (constraintValues.indexOf(aObj.id) == -1) {</span>
<a href="#l21.172"></a><span id="l21.172">             querySatisfied = false;</span>
<a href="#l21.173"></a><span id="l21.173">             break;</span>
<a href="#l21.174"></a><span id="l21.174">           }</span>
<a href="#l21.175"></a><span id="l21.175">         }</span>
<a href="#l21.176"></a><span id="l21.176" class="difflineplus">+        // @testpoint gloda.query.test.kConstraintIn</span>
<a href="#l21.177"></a><span id="l21.177">         else if ((constraintType === GlodaDatastore.kConstraintIn) ||</span>
<a href="#l21.178"></a><span id="l21.178">                  (constraintType === GlodaDatastore.kConstraintEquals)) {</span>
<a href="#l21.179"></a><span id="l21.179">           let objectNounDef = attrDef.objectNounDef;</span>
<a href="#l21.180"></a><span id="l21.180" class="difflineminus">-          </span>
<a href="#l21.181"></a><span id="l21.181" class="difflineplus">+</span>
<a href="#l21.182"></a><span id="l21.182">           // if they provide an equals comparator, use that.</span>
<a href="#l21.183"></a><span id="l21.183">           // (note: the next case has better optimization possibilities than</span>
<a href="#l21.184"></a><span id="l21.184">           //  this mechanism, but of course has higher initialization costs or</span>
<a href="#l21.185"></a><span id="l21.185">           //  code complexity costs...)</span>
<a href="#l21.186"></a><span id="l21.186">           if (objectNounDef.equals) {</span>
<a href="#l21.187"></a><span id="l21.187">             let testValues;</span>
<a href="#l21.188"></a><span id="l21.188">             if (attrDef.singular)</span>
<a href="#l21.189"></a><span id="l21.189">               testValues = [aObj[attrDef.boundName]];</span>
<a href="#l21.190"></a><span id="l21.190" class="difflineat">@@ -197,19 +223,20 @@ GlodaQueryClass.prototype = {</span>
<a href="#l21.191"></a><span id="l21.191">                 break;</span>
<a href="#l21.192"></a><span id="l21.192">             }</span>
<a href="#l21.193"></a><span id="l21.193">             if (!foundMatch) {</span>
<a href="#l21.194"></a><span id="l21.194">               querySatisfied = false;</span>
<a href="#l21.195"></a><span id="l21.195">               break;</span>
<a href="#l21.196"></a><span id="l21.196">             }</span>
<a href="#l21.197"></a><span id="l21.197">           }</span>
<a href="#l21.198"></a><span id="l21.198">         }</span>
<a href="#l21.199"></a><span id="l21.199" class="difflineplus">+        // @testpoint gloda.query.test.kConstraintRanges</span>
<a href="#l21.200"></a><span id="l21.200">         else if (constraintType === GlodaDatastore.kConstraintRanges) {</span>
<a href="#l21.201"></a><span id="l21.201">           let objectNounDef = attrDef.objectNounDef;</span>
<a href="#l21.202"></a><span id="l21.202" class="difflineminus">-          </span>
<a href="#l21.203"></a><span id="l21.203" class="difflineplus">+</span>
<a href="#l21.204"></a><span id="l21.204">           let testValues;</span>
<a href="#l21.205"></a><span id="l21.205">           if (attrDef.singular)</span>
<a href="#l21.206"></a><span id="l21.206">             testValues = [aObj[attrDef.boundName]];</span>
<a href="#l21.207"></a><span id="l21.207">           else</span>
<a href="#l21.208"></a><span id="l21.208">             testValues = aObj[attrDef.boundName];</span>
<a href="#l21.209"></a><span id="l21.209"> </span>
<a href="#l21.210"></a><span id="l21.210">           let foundMatch = false;</span>
<a href="#l21.211"></a><span id="l21.211">           for each (let [,testValue] in Iterator(testValues)) {</span>
<a href="#l21.212"></a><span id="l21.212" class="difflineat">@@ -247,16 +274,17 @@ GlodaQueryClass.prototype = {</span>
<a href="#l21.213"></a><span id="l21.213">             if (foundMatch)</span>
<a href="#l21.214"></a><span id="l21.214">               break;</span>
<a href="#l21.215"></a><span id="l21.215">           }</span>
<a href="#l21.216"></a><span id="l21.216">           if (!foundMatch) {</span>
<a href="#l21.217"></a><span id="l21.217">             querySatisfied = false;</span>
<a href="#l21.218"></a><span id="l21.218">             break;</span>
<a href="#l21.219"></a><span id="l21.219">           }</span>
<a href="#l21.220"></a><span id="l21.220">         }</span>
<a href="#l21.221"></a><span id="l21.221" class="difflineplus">+        // @testpoint gloda.query.test.kConstraintStringLike</span>
<a href="#l21.222"></a><span id="l21.222">         else if (constraintType === GlodaDatastore.kConstraintStringLike) {</span>
<a href="#l21.223"></a><span id="l21.223">           let curIndex = 0;</span>
<a href="#l21.224"></a><span id="l21.224">           let value = aObj[attrDef.boundName];</span>
<a href="#l21.225"></a><span id="l21.225">           // the attribute must be singular, we don't support arrays of strings.</span>
<a href="#l21.226"></a><span id="l21.226">           for each (let [iValuePart, valuePart] in Iterator(constraintValues)) {</span>
<a href="#l21.227"></a><span id="l21.227">             if (typeof valuePart == &quot;string&quot;) {</span>
<a href="#l21.228"></a><span id="l21.228">               let index = value.indexOf(valuePart);</span>
<a href="#l21.229"></a><span id="l21.229">               // if curIndex is null, we just need any match</span>
<a href="#l21.230"></a><span id="l21.230" class="difflineat">@@ -278,35 +306,42 @@ GlodaQueryClass.prototype = {</span>
<a href="#l21.231"></a><span id="l21.231">             }</span>
<a href="#l21.232"></a><span id="l21.232">             else // wild!</span>
<a href="#l21.233"></a><span id="l21.233">               curIndex = null;</span>
<a href="#l21.234"></a><span id="l21.234">           }</span>
<a href="#l21.235"></a><span id="l21.235">           // curIndex must be null or equal to the length of the string</span>
<a href="#l21.236"></a><span id="l21.236">           if (querySatisfied &amp;&amp; curIndex !== null &amp;&amp; curIndex != value.length)</span>
<a href="#l21.237"></a><span id="l21.237">             querySatisfied = false;</span>
<a href="#l21.238"></a><span id="l21.238">         }</span>
<a href="#l21.239"></a><span id="l21.239" class="difflineplus">+        // @testpoint gloda.query.test.kConstraintFulltext</span>
<a href="#l21.240"></a><span id="l21.240">         else if (constraintType === GlodaDatastore.kConstraintFulltext) {</span>
<a href="#l21.241"></a><span id="l21.241" class="difflineminus">-          // this is beyond our powers.  don't match.</span>
<a href="#l21.242"></a><span id="l21.242" class="difflineminus">-          querySatisfied = false;</span>
<a href="#l21.243"></a><span id="l21.243" class="difflineplus">+          // this is beyond our powers. Even if we have the fulltext content in</span>
<a href="#l21.244"></a><span id="l21.244" class="difflineplus">+          //  memory, which we may not, the tokenization and such to perform</span>
<a href="#l21.245"></a><span id="l21.245" class="difflineplus">+          //  the testing gets very complicated in the face of i18n, etc.</span>
<a href="#l21.246"></a><span id="l21.246" class="difflineplus">+          // so, let's fail if the item is not already in the collection, and</span>
<a href="#l21.247"></a><span id="l21.247" class="difflineplus">+          //  let the testing continue if it is.  (some other constraint may no</span>
<a href="#l21.248"></a><span id="l21.248" class="difflineplus">+          //  longer apply...)</span>
<a href="#l21.249"></a><span id="l21.249" class="difflineplus">+          if (!(aObj.id in this.collection._idMap))</span>
<a href="#l21.250"></a><span id="l21.250" class="difflineplus">+            querySatisfied = false;</span>
<a href="#l21.251"></a><span id="l21.251">         }</span>
<a href="#l21.252"></a><span id="l21.252" class="difflineminus">-        </span>
<a href="#l21.253"></a><span id="l21.253" class="difflineplus">+</span>
<a href="#l21.254"></a><span id="l21.254">         if (!querySatisfied)</span>
<a href="#l21.255"></a><span id="l21.255">           break;</span>
<a href="#l21.256"></a><span id="l21.256">       }</span>
<a href="#l21.257"></a><span id="l21.257" class="difflineminus">-      </span>
<a href="#l21.258"></a><span id="l21.258" class="difflineplus">+</span>
<a href="#l21.259"></a><span id="l21.259">       if (querySatisfied)</span>
<a href="#l21.260"></a><span id="l21.260">         return true;</span>
<a href="#l21.261"></a><span id="l21.261">     }</span>
<a href="#l21.262"></a><span id="l21.262">     return false;</span>
<a href="#l21.263"></a><span id="l21.263">   },</span>
<a href="#l21.264"></a><span id="l21.264"> };</span>
<a href="#l21.265"></a><span id="l21.265"> </span>
<a href="#l21.266"></a><span id="l21.266"> /**</span>
<a href="#l21.267"></a><span id="l21.267">  * @class A query that never matches anything.</span>
<a href="#l21.268"></a><span id="l21.268" class="difflineminus">- * </span>
<a href="#l21.269"></a><span id="l21.269" class="difflineplus">+ *</span>
<a href="#l21.270"></a><span id="l21.270">  * Collections corresponding to this query are intentionally frozen in time and</span>
<a href="#l21.271"></a><span id="l21.271">  *  do not want to be notified of any updates.  We need the collection to be</span>
<a href="#l21.272"></a><span id="l21.272">  *  registered with the collection manager so that the noun instances in the</span>
<a href="#l21.273"></a><span id="l21.273">  *  collection are always 'reachable' via the collection for as long as we might</span>
<a href="#l21.274"></a><span id="l21.274">  *  be handing out references to the instances.  (The other way to avoid updates</span>
<a href="#l21.275"></a><span id="l21.275">  *  would be to not register the collection, but then items might not be</span>
<a href="#l21.276"></a><span id="l21.276">  *  reachable.)</span>
<a href="#l21.277"></a><span id="l21.277">  * This is intended to be used in implementation details behind the gloda</span>
<a href="#l21.278"></a><span id="l21.278" class="difflineat">@@ -319,109 +354,121 @@ GlodaQueryClass.prototype = {</span>
<a href="#l21.279"></a><span id="l21.279">  *  receives an itemsAdded event, a GlodaExplicitQueryClass would result in</span>
<a href="#l21.280"></a><span id="l21.280">  *  an item added notification in that case, which would wildly not be desired.</span>
<a href="#l21.281"></a><span id="l21.281">  */</span>
<a href="#l21.282"></a><span id="l21.282"> function GlodaNullQueryClass() {</span>
<a href="#l21.283"></a><span id="l21.283"> }</span>
<a href="#l21.284"></a><span id="l21.284"> </span>
<a href="#l21.285"></a><span id="l21.285"> GlodaNullQueryClass.prototype = {</span>
<a href="#l21.286"></a><span id="l21.286">   /**</span>
<a href="#l21.287"></a><span id="l21.287" class="difflineplus">+   * No options; they are currently only needed for SQL query generation, which</span>
<a href="#l21.288"></a><span id="l21.288" class="difflineplus">+   *  does not happen for null queries.</span>
<a href="#l21.289"></a><span id="l21.289" class="difflineplus">+   */</span>
<a href="#l21.290"></a><span id="l21.290" class="difflineplus">+  options: {},</span>
<a href="#l21.291"></a><span id="l21.291" class="difflineplus">+</span>
<a href="#l21.292"></a><span id="l21.292" class="difflineplus">+  /**</span>
<a href="#l21.293"></a><span id="l21.293">    * Provide a duck-typing way of indicating to GlodaCollectionManager that our</span>
<a href="#l21.294"></a><span id="l21.294">    *  associated collection just doesn't want anything to change.  Our test</span>
<a href="#l21.295"></a><span id="l21.295">    *  function is able to convey most of it, but special-casing has to happen</span>
<a href="#l21.296"></a><span id="l21.296">    *  somewhere, so it happens here.</span>
<a href="#l21.297"></a><span id="l21.297">    */</span>
<a href="#l21.298"></a><span id="l21.298">   frozen: true,</span>
<a href="#l21.299"></a><span id="l21.299" class="difflineminus">-  </span>
<a href="#l21.300"></a><span id="l21.300" class="difflineplus">+</span>
<a href="#l21.301"></a><span id="l21.301">   /**</span>
<a href="#l21.302"></a><span id="l21.302">    * Since our query never matches anything, it doesn't make sense to let</span>
<a href="#l21.303"></a><span id="l21.303">    *  someone attempt to construct a boolean OR involving us.</span>
<a href="#l21.304"></a><span id="l21.304" class="difflineminus">-   *  </span>
<a href="#l21.305"></a><span id="l21.305" class="difflineplus">+   *</span>
<a href="#l21.306"></a><span id="l21.306">    * @returns null</span>
<a href="#l21.307"></a><span id="l21.307">    */</span>
<a href="#l21.308"></a><span id="l21.308">   or: function() {</span>
<a href="#l21.309"></a><span id="l21.309">     return null;</span>
<a href="#l21.310"></a><span id="l21.310">   },</span>
<a href="#l21.311"></a><span id="l21.311" class="difflineminus">-  </span>
<a href="#l21.312"></a><span id="l21.312" class="difflineplus">+</span>
<a href="#l21.313"></a><span id="l21.313">   /**</span>
<a href="#l21.314"></a><span id="l21.314">    * Return nothing (null) because it does not make sense to create a collection</span>
<a href="#l21.315"></a><span id="l21.315">    *  based on a null query.  This method is normally used (on a normal query)</span>
<a href="#l21.316"></a><span id="l21.316">    *  to return a collection populated by the constraints of the query.  We</span>
<a href="#l21.317"></a><span id="l21.317">    *  match nothing, so we should return nothing.  More importantly, you are</span>
<a href="#l21.318"></a><span id="l21.318">    *  currently doing something wrong if you try and do this, so null is</span>
<a href="#l21.319"></a><span id="l21.319">    *  appropriate.  It may turn out that it makes sense for us to return an</span>
<a href="#l21.320"></a><span id="l21.320">    *  empty collection in the future for sentinel value purposes, but we'll</span>
<a href="#l21.321"></a><span id="l21.321">    *  cross that bridge when we come to it.</span>
<a href="#l21.322"></a><span id="l21.322" class="difflineminus">-   *  </span>
<a href="#l21.323"></a><span id="l21.323" class="difflineminus">-   * @returns null  </span>
<a href="#l21.324"></a><span id="l21.324" class="difflineplus">+   *</span>
<a href="#l21.325"></a><span id="l21.325" class="difflineplus">+   * @returns null</span>
<a href="#l21.326"></a><span id="l21.326">    */</span>
<a href="#l21.327"></a><span id="l21.327">   getCollection: function() {</span>
<a href="#l21.328"></a><span id="l21.328">     return null;</span>
<a href="#l21.329"></a><span id="l21.329">   },</span>
<a href="#l21.330"></a><span id="l21.330" class="difflineminus">-  </span>
<a href="#l21.331"></a><span id="l21.331" class="difflineplus">+</span>
<a href="#l21.332"></a><span id="l21.332">   /**</span>
<a href="#l21.333"></a><span id="l21.333">    * Never matches anything.</span>
<a href="#l21.334"></a><span id="l21.334" class="difflineminus">-   * </span>
<a href="#l21.335"></a><span id="l21.335" class="difflineplus">+   *</span>
<a href="#l21.336"></a><span id="l21.336">    * @param aObj The object someone wants us to test for relevance to our</span>
<a href="#l21.337"></a><span id="l21.337">    *     associated collection.  But we don't care!  Not a fig!</span>
<a href="#l21.338"></a><span id="l21.338">    * @returns false</span>
<a href="#l21.339"></a><span id="l21.339">    */</span>
<a href="#l21.340"></a><span id="l21.340">   test: function gloda_query_null_test(aObj) {</span>
<a href="#l21.341"></a><span id="l21.341">     return false;</span>
<a href="#l21.342"></a><span id="l21.342">   }</span>
<a href="#l21.343"></a><span id="l21.343"> };</span>
<a href="#l21.344"></a><span id="l21.344"> </span>
<a href="#l21.345"></a><span id="l21.345"> /**</span>
<a href="#l21.346"></a><span id="l21.346">  * @class A query that only 'tests' for already belonging to the collection.</span>
<a href="#l21.347"></a><span id="l21.347" class="difflineminus">- * </span>
<a href="#l21.348"></a><span id="l21.348" class="difflineplus">+ *</span>
<a href="#l21.349"></a><span id="l21.349">  * This type of collection is useful for when you (or rather your listener)</span>
<a href="#l21.350"></a><span id="l21.350">  *  are interested in hearing about modifications to your collection or removals</span>
<a href="#l21.351"></a><span id="l21.351">  *  from your collection because of deletion, but do not want to be notified</span>
<a href="#l21.352"></a><span id="l21.352" class="difflineminus">- *  about newly indexed items matching your normal query constraints. </span>
<a href="#l21.353"></a><span id="l21.353" class="difflineminus">- * </span>
<a href="#l21.354"></a><span id="l21.354" class="difflineplus">+ *  about newly indexed items matching your normal query constraints.</span>
<a href="#l21.355"></a><span id="l21.355" class="difflineplus">+ *</span>
<a href="#l21.356"></a><span id="l21.356">  * @param aCollection The collection this query belongs to.  This needs to be</span>
<a href="#l21.357"></a><span id="l21.357">  *     passed-in here or the collection should set the attribute directly when</span>
<a href="#l21.358"></a><span id="l21.358">  *     the query is passed in to a collection's constructor.</span>
<a href="#l21.359"></a><span id="l21.359">  */</span>
<a href="#l21.360"></a><span id="l21.360"> function GlodaExplicitQueryClass(aCollection) {</span>
<a href="#l21.361"></a><span id="l21.361">   this.collection = aCollection;</span>
<a href="#l21.362"></a><span id="l21.362"> }</span>
<a href="#l21.363"></a><span id="l21.363"> </span>
<a href="#l21.364"></a><span id="l21.364"> GlodaExplicitQueryClass.prototype = {</span>
<a href="#l21.365"></a><span id="l21.365">   /**</span>
<a href="#l21.366"></a><span id="l21.366" class="difflineplus">+   * No options; they are currently only needed for SQL query generation, which</span>
<a href="#l21.367"></a><span id="l21.367" class="difflineplus">+   *  does not happen for explicit queries.</span>
<a href="#l21.368"></a><span id="l21.368" class="difflineplus">+   */</span>
<a href="#l21.369"></a><span id="l21.369" class="difflineplus">+  options: {},</span>
<a href="#l21.370"></a><span id="l21.370" class="difflineplus">+</span>
<a href="#l21.371"></a><span id="l21.371" class="difflineplus">+  /**</span>
<a href="#l21.372"></a><span id="l21.372">    * Since our query is intended to only match the contents of our collection,</span>
<a href="#l21.373"></a><span id="l21.373">    *  it doesn't make sense to let someone attempt to construct a boolean OR</span>
<a href="#l21.374"></a><span id="l21.374">    *  involving us.</span>
<a href="#l21.375"></a><span id="l21.375" class="difflineminus">-   *  </span>
<a href="#l21.376"></a><span id="l21.376" class="difflineplus">+   *</span>
<a href="#l21.377"></a><span id="l21.377">    * @returns null</span>
<a href="#l21.378"></a><span id="l21.378">    */</span>
<a href="#l21.379"></a><span id="l21.379">   or: function() {</span>
<a href="#l21.380"></a><span id="l21.380">     return null;</span>
<a href="#l21.381"></a><span id="l21.381">   },</span>
<a href="#l21.382"></a><span id="l21.382"> </span>
<a href="#l21.383"></a><span id="l21.383">   /**</span>
<a href="#l21.384"></a><span id="l21.384">    * Return nothing (null) because it does not make sense to create a collection</span>
<a href="#l21.385"></a><span id="l21.385">    *  based on an explicit query.  This method is normally used (on a normal</span>
<a href="#l21.386"></a><span id="l21.386">    *  query) to return a collection populated by the constraints of the query.</span>
<a href="#l21.387"></a><span id="l21.387">    *  In the case of an explicit query, we expect it will be associated with</span>
<a href="#l21.388"></a><span id="l21.388">    *  either a hand-created collection or the results of a normal query that is</span>
<a href="#l21.389"></a><span id="l21.389">    *  immediately converted into an explicit query.  In all likelihood, calling</span>
<a href="#l21.390"></a><span id="l21.390">    *  this method on an instance of this type is an error, so it is helpful to</span>
<a href="#l21.391"></a><span id="l21.391">    *  return null because people will error hard.</span>
<a href="#l21.392"></a><span id="l21.392" class="difflineminus">-   *  </span>
<a href="#l21.393"></a><span id="l21.393" class="difflineminus">-   * @returns null  </span>
<a href="#l21.394"></a><span id="l21.394" class="difflineplus">+   *</span>
<a href="#l21.395"></a><span id="l21.395" class="difflineplus">+   * @returns null</span>
<a href="#l21.396"></a><span id="l21.396">    */</span>
<a href="#l21.397"></a><span id="l21.397">   getCollection: function() {</span>
<a href="#l21.398"></a><span id="l21.398">     return null;</span>
<a href="#l21.399"></a><span id="l21.399">   },</span>
<a href="#l21.400"></a><span id="l21.400" class="difflineminus">-  </span>
<a href="#l21.401"></a><span id="l21.401" class="difflineplus">+</span>
<a href="#l21.402"></a><span id="l21.402">   /**</span>
<a href="#l21.403"></a><span id="l21.403">    * Matches only items that are already in the collection associated with this</span>
<a href="#l21.404"></a><span id="l21.404">    *  query (by id).</span>
<a href="#l21.405"></a><span id="l21.405" class="difflineminus">-   * </span>
<a href="#l21.406"></a><span id="l21.406" class="difflineplus">+   *</span>
<a href="#l21.407"></a><span id="l21.407">    * @param aObj The object/item to test for already being in the associated</span>
<a href="#l21.408"></a><span id="l21.408">    *     collection.</span>
<a href="#l21.409"></a><span id="l21.409">    * @returns true when the object is in the associated collection, otherwise</span>
<a href="#l21.410"></a><span id="l21.410">    *     false.</span>
<a href="#l21.411"></a><span id="l21.411">    */</span>
<a href="#l21.412"></a><span id="l21.412">   test: function gloda_query_explicit_test(aObj) {</span>
<a href="#l21.413"></a><span id="l21.413">     return (aObj.id in this.collection._idMap);</span>
<a href="#l21.414"></a><span id="l21.414">   }</span>
<a href="#l21.415"></a><span id="l21.415" class="difflineat">@@ -430,16 +477,21 @@ GlodaExplicitQueryClass.prototype = {</span>
<a href="#l21.416"></a><span id="l21.416"> /**</span>
<a href="#l21.417"></a><span id="l21.417">  * @class A query that 'tests' true for everything.  Intended for debugging purposes</span>
<a href="#l21.418"></a><span id="l21.418">  *  only.</span>
<a href="#l21.419"></a><span id="l21.419">  */</span>
<a href="#l21.420"></a><span id="l21.420"> function GlodaWildcardQueryClass() {</span>
<a href="#l21.421"></a><span id="l21.421"> }</span>
<a href="#l21.422"></a><span id="l21.422"> </span>
<a href="#l21.423"></a><span id="l21.423"> GlodaWildcardQueryClass.prototype = {</span>
<a href="#l21.424"></a><span id="l21.424" class="difflineplus">+  /**</span>
<a href="#l21.425"></a><span id="l21.425" class="difflineplus">+   * No options; they are currently only needed for SQL query generation.</span>
<a href="#l21.426"></a><span id="l21.426" class="difflineplus">+   */</span>
<a href="#l21.427"></a><span id="l21.427" class="difflineplus">+  options: {},</span>
<a href="#l21.428"></a><span id="l21.428" class="difflineplus">+</span>
<a href="#l21.429"></a><span id="l21.429">   // don't let people try and mess with us</span>
<a href="#l21.430"></a><span id="l21.430">   or: function() { return null; },</span>
<a href="#l21.431"></a><span id="l21.431">   // don't let people try and query on us (until we have a real use case for</span>
<a href="#l21.432"></a><span id="l21.432">   //  that...)</span>
<a href="#l21.433"></a><span id="l21.433">   getCollection: function() { return null; },</span>
<a href="#l21.434"></a><span id="l21.434">   /**</span>
<a href="#l21.435"></a><span id="l21.435">    * Everybody wins!</span>
<a href="#l21.436"></a><span id="l21.436">    */</span>
<a href="#l21.437"></a><span id="l21.437" class="difflineat">@@ -451,41 +503,41 @@ GlodaWildcardQueryClass.prototype = {</span>
<a href="#l21.438"></a><span id="l21.438"> /**</span>
<a href="#l21.439"></a><span id="l21.439">  * Factory method to effectively create per-noun subclasses of GlodaQueryClass,</span>
<a href="#l21.440"></a><span id="l21.440">  *  GlodaNullQueryClass, GlodaExplicitQueryClass, and GlodaWildcardQueryClass.</span>
<a href="#l21.441"></a><span id="l21.441">  *  For GlodaQueryClass this allows us to add per-noun helpers.  For the others,</span>
<a href="#l21.442"></a><span id="l21.442">  *  this is merely a means of allowing us to attach the (per-noun) nounDef to</span>
<a href="#l21.443"></a><span id="l21.443">  *  the 'class'.</span>
<a href="#l21.444"></a><span id="l21.444">  */</span>
<a href="#l21.445"></a><span id="l21.445"> function GlodaQueryClassFactory(aNounDef) {</span>
<a href="#l21.446"></a><span id="l21.446" class="difflineminus">-  let newQueryClass = function() {</span>
<a href="#l21.447"></a><span id="l21.447" class="difflineminus">-    GlodaQueryClass.call(this);</span>
<a href="#l21.448"></a><span id="l21.448" class="difflineminus">-  }; </span>
<a href="#l21.449"></a><span id="l21.449" class="difflineplus">+  let newQueryClass = function(aOptions) {</span>
<a href="#l21.450"></a><span id="l21.450" class="difflineplus">+    GlodaQueryClass.call(this, aOptions);</span>
<a href="#l21.451"></a><span id="l21.451" class="difflineplus">+  };</span>
<a href="#l21.452"></a><span id="l21.452">   newQueryClass.prototype = new GlodaQueryClass();</span>
<a href="#l21.453"></a><span id="l21.453">   newQueryClass.prototype._queryClass = newQueryClass;</span>
<a href="#l21.454"></a><span id="l21.454">   newQueryClass.prototype._nounDef = aNounDef;</span>
<a href="#l21.455"></a><span id="l21.455"> </span>
<a href="#l21.456"></a><span id="l21.456">   let newNullClass = function(aCollection) {</span>
<a href="#l21.457"></a><span id="l21.457">     GlodaNullQueryClass.call(this);</span>
<a href="#l21.458"></a><span id="l21.458">     this.collection = aCollection;</span>
<a href="#l21.459"></a><span id="l21.459">   };</span>
<a href="#l21.460"></a><span id="l21.460">   newNullClass.prototype = new GlodaNullQueryClass();</span>
<a href="#l21.461"></a><span id="l21.461">   newNullClass.prototype._queryClass = newNullClass;</span>
<a href="#l21.462"></a><span id="l21.462">   newNullClass.prototype._nounDef = aNounDef;</span>
<a href="#l21.463"></a><span id="l21.463" class="difflineminus">-  </span>
<a href="#l21.464"></a><span id="l21.464" class="difflineplus">+</span>
<a href="#l21.465"></a><span id="l21.465">   let newExplicitClass = function(aCollection) {</span>
<a href="#l21.466"></a><span id="l21.466">     GlodaExplicitQueryClass.call(this);</span>
<a href="#l21.467"></a><span id="l21.467">     this.collection = aCollection;</span>
<a href="#l21.468"></a><span id="l21.468">   };</span>
<a href="#l21.469"></a><span id="l21.469">   newExplicitClass.prototype = new GlodaExplicitQueryClass();</span>
<a href="#l21.470"></a><span id="l21.470">   newExplicitClass.prototype._queryClass = newExplicitClass;</span>
<a href="#l21.471"></a><span id="l21.471">   newExplicitClass.prototype._nounDef = aNounDef;</span>
<a href="#l21.472"></a><span id="l21.472"> </span>
<a href="#l21.473"></a><span id="l21.473">   let newWildcardClass = function(aCollection) {</span>
<a href="#l21.474"></a><span id="l21.474">     GlodaWildcardQueryClass.call(this);</span>
<a href="#l21.475"></a><span id="l21.475">     this.collection = aCollection;</span>
<a href="#l21.476"></a><span id="l21.476">   };</span>
<a href="#l21.477"></a><span id="l21.477">   newWildcardClass.prototype = new GlodaWildcardQueryClass();</span>
<a href="#l21.478"></a><span id="l21.478">   newWildcardClass.prototype._queryClass = newWildcardClass;</span>
<a href="#l21.479"></a><span id="l21.479">   newWildcardClass.prototype._nounDef = aNounDef;</span>
<a href="#l21.480"></a><span id="l21.480" class="difflineminus">-  </span>
<a href="#l21.481"></a><span id="l21.481" class="difflineplus">+</span>
<a href="#l21.482"></a><span id="l21.482">   return [newQueryClass, newNullClass, newExplicitClass, newWildcardClass];</span>
<a href="#l21.483"></a><span id="l21.483"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1">new file mode 100644</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineminus">--- /dev/null</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/resources/genericIndexer.js</span>
<a href="#l22.4"></a><span id="l22.4" class="difflineat">@@ -0,0 +1,43 @@</span>
<a href="#l22.5"></a><span id="l22.5" class="difflineplus">+/**</span>
<a href="#l22.6"></a><span id="l22.6" class="difflineplus">+ * Generic indexing mechanism; does nothing special, just uses</span>
<a href="#l22.7"></a><span id="l22.7" class="difflineplus">+ *  Gloda.grokNounItem.  Call GenericIndexer.indexNewObjects() to queue</span>
<a href="#l22.8"></a><span id="l22.8" class="difflineplus">+ *  queue your objects for initial indexing.</span>
<a href="#l22.9"></a><span id="l22.9" class="difflineplus">+ */</span>
<a href="#l22.10"></a><span id="l22.10" class="difflineplus">+var GenericIndexer = {</span>
<a href="#l22.11"></a><span id="l22.11" class="difflineplus">+  _log: Log4Moz.repository.getLogger(&quot;gloda.indexer.generic&quot;),</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineplus">+  /* public interface */</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+  name: &quot;generic_indexer&quot;,</span>
<a href="#l22.14"></a><span id="l22.14" class="difflineplus">+  enable: function() {</span>
<a href="#l22.15"></a><span id="l22.15" class="difflineplus">+    this.enabled = true;</span>
<a href="#l22.16"></a><span id="l22.16" class="difflineplus">+  },</span>
<a href="#l22.17"></a><span id="l22.17" class="difflineplus">+  disable: function() {</span>
<a href="#l22.18"></a><span id="l22.18" class="difflineplus">+    this.enabled = false;</span>
<a href="#l22.19"></a><span id="l22.19" class="difflineplus">+  },</span>
<a href="#l22.20"></a><span id="l22.20" class="difflineplus">+  get workers() {</span>
<a href="#l22.21"></a><span id="l22.21" class="difflineplus">+    return [[&quot;generic-new&quot;, this._worker_index_generic_new]];</span>
<a href="#l22.22"></a><span id="l22.22" class="difflineplus">+  },</span>
<a href="#l22.23"></a><span id="l22.23" class="difflineplus">+  initialSweep: function() {</span>
<a href="#l22.24"></a><span id="l22.24" class="difflineplus">+  },</span>
<a href="#l22.25"></a><span id="l22.25" class="difflineplus">+  /* mock interface */</span>
<a href="#l22.26"></a><span id="l22.26" class="difflineplus">+  enabled: false,</span>
<a href="#l22.27"></a><span id="l22.27" class="difflineplus">+  initialSweepCalled: false,</span>
<a href="#l22.28"></a><span id="l22.28" class="difflineplus">+  indexNewObjects: function(aObjects) {</span>
<a href="#l22.29"></a><span id="l22.29" class="difflineplus">+    this._log.debug(&quot;enqueuing &quot; + aObjects.length +</span>
<a href="#l22.30"></a><span id="l22.30" class="difflineplus">+      &quot; new generic objects with id: &quot; + aObjects[0].NOUN_ID);</span>
<a href="#l22.31"></a><span id="l22.31" class="difflineplus">+    GlodaIndexer.indexJob(new IndexingJob(&quot;generic-new&quot;, 0, null, aObjects.concat()));</span>
<a href="#l22.32"></a><span id="l22.32" class="difflineplus">+  },</span>
<a href="#l22.33"></a><span id="l22.33" class="difflineplus">+  /* implementation */</span>
<a href="#l22.34"></a><span id="l22.34" class="difflineplus">+  _worker_index_generic_new: function(aJob, aCallbackHandle) {</span>
<a href="#l22.35"></a><span id="l22.35" class="difflineplus">+    this._log.debug(&quot;Beginning indexing &quot; + aJob.items.length + &quot; generic new items&quot;);</span>
<a href="#l22.36"></a><span id="l22.36" class="difflineplus">+    for (let [, item] in Iterator(aJob.items)) {</span>
<a href="#l22.37"></a><span id="l22.37" class="difflineplus">+      this._log.debug(&quot;Indexing: &quot; + item);</span>
<a href="#l22.38"></a><span id="l22.38" class="difflineplus">+      yield aCallbackHandle.pushAndGo(</span>
<a href="#l22.39"></a><span id="l22.39" class="difflineplus">+        Gloda.grokNounItem(item, {}, true, true, aCallbackHandle,</span>
<a href="#l22.40"></a><span id="l22.40" class="difflineplus">+                           item.NOUN_DEF.cache));</span>
<a href="#l22.41"></a><span id="l22.41" class="difflineplus">+    }</span>
<a href="#l22.42"></a><span id="l22.42" class="difflineplus">+</span>
<a href="#l22.43"></a><span id="l22.43" class="difflineplus">+    yield GlodaIndexer.kWorkDone;</span>
<a href="#l22.44"></a><span id="l22.44" class="difflineplus">+    this._log.debug(&quot;Done indexing&quot;);</span>
<a href="#l22.45"></a><span id="l22.45" class="difflineplus">+  }</span>
<a href="#l22.46"></a><span id="l22.46" class="difflineplus">+};</span>
<a href="#l22.47"></a><span id="l22.47" class="difflineplus">+GlodaIndexer.registerIndexer(GenericIndexer);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -33,16 +33,32 @@</span>
<a href="#l23.4"></a><span id="l23.4">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l23.5"></a><span id="l23.5">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l23.6"></a><span id="l23.6">  *</span>
<a href="#l23.7"></a><span id="l23.7">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l23.8"></a><span id="l23.8"> </span>
<a href="#l23.9"></a><span id="l23.9"> // -- Pull in the POP3 fake-server / local account helper code</span>
<a href="#l23.10"></a><span id="l23.10"> load(&quot;../../test_mailnewslocal/unit/head_maillocal.js&quot;);</span>
<a href="#l23.11"></a><span id="l23.11"> </span>
<a href="#l23.12"></a><span id="l23.12" class="difflineplus">+/**</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+ * Create a 'me' identity of &quot;me@localhost&quot; for the benefit of Gloda.  At the</span>
<a href="#l23.14"></a><span id="l23.14" class="difflineplus">+ *  time of this writing, Gloda only initializes Gloda.myIdentities and</span>
<a href="#l23.15"></a><span id="l23.15" class="difflineplus">+ *  Gloda.myContact at startup with no event-driven updates.  As such, this</span>
<a href="#l23.16"></a><span id="l23.16" class="difflineplus">+ *  function needs to be called prior to gloda startup.</span>
<a href="#l23.17"></a><span id="l23.17" class="difflineplus">+ */</span>
<a href="#l23.18"></a><span id="l23.18" class="difflineplus">+function createMeIdentity() {</span>
<a href="#l23.19"></a><span id="l23.19" class="difflineplus">+  var acctMgr = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;]</span>
<a href="#l23.20"></a><span id="l23.20" class="difflineplus">+                  .getService(Ci.nsIMsgAccountManager);</span>
<a href="#l23.21"></a><span id="l23.21" class="difflineplus">+  let identity = acctMgr.createIdentity;</span>
<a href="#l23.22"></a><span id="l23.22" class="difflineplus">+  identity.email = &quot;me@localhost&quot;;</span>
<a href="#l23.23"></a><span id="l23.23" class="difflineplus">+  identity.fullName = &quot;Me&quot;;</span>
<a href="#l23.24"></a><span id="l23.24" class="difflineplus">+}</span>
<a href="#l23.25"></a><span id="l23.25" class="difflineplus">+// and run it now...</span>
<a href="#l23.26"></a><span id="l23.26" class="difflineplus">+createMeIdentity();</span>
<a href="#l23.27"></a><span id="l23.27" class="difflineplus">+</span>
<a href="#l23.28"></a><span id="l23.28"> // -- Set the gloda prefs</span>
<a href="#l23.29"></a><span id="l23.29"> const gPrefs = Cc[&quot;@mozilla.org/preferences-service;1&quot;]</span>
<a href="#l23.30"></a><span id="l23.30">                  .getService(Ci.nsIPrefBranch);</span>
<a href="#l23.31"></a><span id="l23.31"> // yes to indexing</span>
<a href="#l23.32"></a><span id="l23.32"> gPrefs.setBoolPref(&quot;mailnews.database.global.indexer.enabled&quot;, true);</span>
<a href="#l23.33"></a><span id="l23.33"> // no to a sweep we don't control</span>
<a href="#l23.34"></a><span id="l23.34"> gPrefs.setBoolPref(&quot;mailnews.database.global.indexer.perform_initial_sweep&quot;,</span>
<a href="#l23.35"></a><span id="l23.35">     false);</span>
<a href="#l23.36"></a><span id="l23.36" class="difflineat">@@ -747,17 +763,17 @@ function twiddleAndTest(aSynthMsg, aActi</span>
<a href="#l23.37"></a><span id="l23.37">       twiddle_next_attr(smsg, gmsg);</span>
<a href="#l23.38"></a><span id="l23.38">     else</span>
<a href="#l23.39"></a><span id="l23.39">       next_test();</span>
<a href="#l23.40"></a><span id="l23.40">   }</span>
<a href="#l23.41"></a><span id="l23.41"> </span>
<a href="#l23.42"></a><span id="l23.42">   indexMessages([aSynthMsg], twiddle_next_attr);</span>
<a href="#l23.43"></a><span id="l23.43"> }</span>
<a href="#l23.44"></a><span id="l23.44"> </span>
<a href="#l23.45"></a><span id="l23.45" class="difflineminus">-_defaultExpectationExtractors = {};</span>
<a href="#l23.46"></a><span id="l23.46" class="difflineplus">+var _defaultExpectationExtractors = {};</span>
<a href="#l23.47"></a><span id="l23.47"> _defaultExpectationExtractors[Gloda.NOUN_MESSAGE] = [</span>
<a href="#l23.48"></a><span id="l23.48">   function expectExtract_message_gloda(aGlodaMessage) {</span>
<a href="#l23.49"></a><span id="l23.49">     return aGlodaMessage.headerMessageID;</span>
<a href="#l23.50"></a><span id="l23.50">   },</span>
<a href="#l23.51"></a><span id="l23.51">   function expectExtract_message_synth(aSynthMessage) {</span>
<a href="#l23.52"></a><span id="l23.52">     return aSynthMessage.messageId;</span>
<a href="#l23.53"></a><span id="l23.53">   }</span>
<a href="#l23.54"></a><span id="l23.54"> ];</span>
<a href="#l23.55"></a><span id="l23.55" class="difflineat">@@ -777,20 +793,25 @@ function twiddleAndTest(aSynthMsg, aActi</span>
<a href="#l23.56"></a><span id="l23.56">     return aAddress;</span>
<a href="#l23.57"></a><span id="l23.57">   }</span>
<a href="#l23.58"></a><span id="l23.58"> ];</span>
<a href="#l23.59"></a><span id="l23.59"> </span>
<a href="#l23.60"></a><span id="l23.60"> function expectExtract_default_toString(aThing) {</span>
<a href="#l23.61"></a><span id="l23.61">   return aThing.toString();</span>
<a href="#l23.62"></a><span id="l23.62"> }</span>
<a href="#l23.63"></a><span id="l23.63"> </span>
<a href="#l23.64"></a><span id="l23.64" class="difflineminus">-function QueryExpectationListener(aExpectedSet, aGlodaExtractor) {</span>
<a href="#l23.65"></a><span id="l23.65" class="difflineplus">+/// see {queryExpect} for info on what we do</span>
<a href="#l23.66"></a><span id="l23.66" class="difflineplus">+function QueryExpectationListener(aExpectedSet, aGlodaExtractor, aOrderVerifier) {</span>
<a href="#l23.67"></a><span id="l23.67">   this.expectedSet = aExpectedSet;</span>
<a href="#l23.68"></a><span id="l23.68">   this.glodaExtractor = aGlodaExtractor;</span>
<a href="#l23.69"></a><span id="l23.69" class="difflineplus">+  this.orderVerifier = aOrderVerifier;</span>
<a href="#l23.70"></a><span id="l23.70">   this.completed = false;</span>
<a href="#l23.71"></a><span id="l23.71" class="difflineplus">+  // track our current 'index' in the results for the (optional) order verifier,</span>
<a href="#l23.72"></a><span id="l23.72" class="difflineplus">+  //  but also so we can provide slightly more useful debug output</span>
<a href="#l23.73"></a><span id="l23.73" class="difflineplus">+  this.nextIndex = 0;</span>
<a href="#l23.74"></a><span id="l23.74"> }</span>
<a href="#l23.75"></a><span id="l23.75"> </span>
<a href="#l23.76"></a><span id="l23.76"> QueryExpectationListener.prototype = {</span>
<a href="#l23.77"></a><span id="l23.77">   onItemsAdded: function query_expectation_onItemsAdded(aItems, aCollection) {</span>
<a href="#l23.78"></a><span id="l23.78">     for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l23.79"></a><span id="l23.79">       let glodaStringRep;</span>
<a href="#l23.80"></a><span id="l23.80">       try {</span>
<a href="#l23.81"></a><span id="l23.81">         glodaStringRep = this.glodaExtractor(item);</span>
<a href="#l23.82"></a><span id="l23.82" class="difflineat">@@ -806,16 +827,35 @@ QueryExpectationListener.prototype = {</span>
<a href="#l23.83"></a><span id="l23.83">       else {</span>
<a href="#l23.84"></a><span id="l23.84">         ddumpObject(item, &quot;item&quot;, 0);</span>
<a href="#l23.85"></a><span id="l23.85">         ddumpObject(this.expectedSet, &quot;expectedSet&quot;, 1);</span>
<a href="#l23.86"></a><span id="l23.86">         dump(&quot;glodaStringRep: &quot; + glodaStringRep + &quot;\n&quot;);</span>
<a href="#l23.87"></a><span id="l23.87">         do_throw(&quot;Query returned unexpected result! gloda rep:&quot; +</span>
<a href="#l23.88"></a><span id="l23.88">                  glodaStringRep);</span>
<a href="#l23.89"></a><span id="l23.89">       }</span>
<a href="#l23.90"></a><span id="l23.90"> </span>
<a href="#l23.91"></a><span id="l23.91" class="difflineplus">+      if (this.orderVerifier) {</span>
<a href="#l23.92"></a><span id="l23.92" class="difflineplus">+        try {</span>
<a href="#l23.93"></a><span id="l23.93" class="difflineplus">+          this.orderVerifier(this.nextIndex, item, aCollection);</span>
<a href="#l23.94"></a><span id="l23.94" class="difflineplus">+        }</span>
<a href="#l23.95"></a><span id="l23.95" class="difflineplus">+        catch (ex) {</span>
<a href="#l23.96"></a><span id="l23.96" class="difflineplus">+          // if the order was wrong, we could probably go for an output of what</span>
<a href="#l23.97"></a><span id="l23.97" class="difflineplus">+          //  we actually got...</span>
<a href="#l23.98"></a><span id="l23.98" class="difflineplus">+          dump(&quot;!!! ORDER PROBLEM, SO ORDER DUMP!\n&quot;);</span>
<a href="#l23.99"></a><span id="l23.99" class="difflineplus">+          for each (let [iThing, thing] in Iterator(aItems)) {</span>
<a href="#l23.100"></a><span id="l23.100" class="difflineplus">+            dump(iThing + &quot;: &quot; + thing +</span>
<a href="#l23.101"></a><span id="l23.101" class="difflineplus">+                 (aCollection.stashedColumns ?</span>
<a href="#l23.102"></a><span id="l23.102" class="difflineplus">+                  (&quot;. &quot; + aCollection.stashedColumns[thing.id].join(&quot;, &quot;)) :</span>
<a href="#l23.103"></a><span id="l23.103" class="difflineplus">+                  &quot;&quot;) + &quot;\n&quot;);</span>
<a href="#l23.104"></a><span id="l23.104" class="difflineplus">+          }</span>
<a href="#l23.105"></a><span id="l23.105" class="difflineplus">+          throw ex;</span>
<a href="#l23.106"></a><span id="l23.106" class="difflineplus">+        }</span>
<a href="#l23.107"></a><span id="l23.107" class="difflineplus">+      }</span>
<a href="#l23.108"></a><span id="l23.108" class="difflineplus">+      this.nextIndex++;</span>
<a href="#l23.109"></a><span id="l23.109" class="difflineplus">+</span>
<a href="#l23.110"></a><span id="l23.110">       // make sure the query's test method agrees with the database about this</span>
<a href="#l23.111"></a><span id="l23.111">       if (!aCollection.query.test(item))</span>
<a href="#l23.112"></a><span id="l23.112">         do_throw(&quot;Query test returned false when it should have been true on &quot; +</span>
<a href="#l23.113"></a><span id="l23.113">                  &quot;extracted: &quot; + glodaStringRep + &quot; item: &quot; + item);</span>
<a href="#l23.114"></a><span id="l23.114">     }</span>
<a href="#l23.115"></a><span id="l23.115">   },</span>
<a href="#l23.116"></a><span id="l23.116">   onItemsModified: function query_expectation_onItemsModified(aItems,</span>
<a href="#l23.117"></a><span id="l23.117">       aCollection) {</span>
<a href="#l23.118"></a><span id="l23.118" class="difflineat">@@ -824,18 +864,19 @@ QueryExpectationListener.prototype = {</span>
<a href="#l23.119"></a><span id="l23.119">       aCollection) {</span>
<a href="#l23.120"></a><span id="l23.120">   },</span>
<a href="#l23.121"></a><span id="l23.121">   onQueryCompleted: function query_expectation_onQueryCompleted(aCollection) {</span>
<a href="#l23.122"></a><span id="l23.122">     // we may continue to match newly added items if we leave our query as it</span>
<a href="#l23.123"></a><span id="l23.123">     //  is, so let's become explicit to avoid related troubles.</span>
<a href="#l23.124"></a><span id="l23.124">     aCollection.becomeExplicit();</span>
<a href="#l23.125"></a><span id="l23.125"> </span>
<a href="#l23.126"></a><span id="l23.126">     // expectedSet should now be empty</span>
<a href="#l23.127"></a><span id="l23.127" class="difflineminus">-    for each (let [key, value] in this.expectedSet) {</span>
<a href="#l23.128"></a><span id="l23.128" class="difflineminus">-      do_throw(&quot;Query should have returned &quot; + key + &quot;(&quot; + value + &quot;)&quot;);</span>
<a href="#l23.129"></a><span id="l23.129" class="difflineplus">+    for each (let [key, value] in Iterator(this.expectedSet)) {</span>
<a href="#l23.130"></a><span id="l23.130" class="difflineplus">+      dump(&quot;I have seen &quot; + this.nextIndex + &quot; results, but not:\n&quot;);</span>
<a href="#l23.131"></a><span id="l23.131" class="difflineplus">+      do_throw(&quot;Query should have returned &quot; + key + &quot; (&quot; + value + &quot;)&quot;);</span>
<a href="#l23.132"></a><span id="l23.132">     }</span>
<a href="#l23.133"></a><span id="l23.133"> </span>
<a href="#l23.134"></a><span id="l23.134">     dump(&quot;&gt;&gt;&gt; queryCompleted, advancing to next test\n&quot;);</span>
<a href="#l23.135"></a><span id="l23.135">     next_test();</span>
<a href="#l23.136"></a><span id="l23.136">   },</span>
<a href="#l23.137"></a><span id="l23.137"> }</span>
<a href="#l23.138"></a><span id="l23.138"> </span>
<a href="#l23.139"></a><span id="l23.139"> /**</span>
<a href="#l23.140"></a><span id="l23.140" class="difflineat">@@ -858,27 +899,31 @@ QueryExpectationListener.prototype = {</span>
<a href="#l23.141"></a><span id="l23.141">  *         arguments to query.getCollection.</span>
<a href="#l23.142"></a><span id="l23.142">  *     - nounId: The (numeric) noun id of the noun type expected to be returned.</span>
<a href="#l23.143"></a><span id="l23.143">  * @param aExpectedSet The list of expected results from the query.</span>
<a href="#l23.144"></a><span id="l23.144">  * @param aGlodaExtractor The extractor function to take an instance of the</span>
<a href="#l23.145"></a><span id="l23.145">  *     gloda representation and return a string for comparison/equivalence</span>
<a href="#l23.146"></a><span id="l23.146">  *     against that returned by the expected extractor (against the input</span>
<a href="#l23.147"></a><span id="l23.147">  *     instance in aExpectedSet.)  The value returned must be unique for all</span>
<a href="#l23.148"></a><span id="l23.148">  *     of the expected gloda representations of the expected set.  If omitted,</span>
<a href="#l23.149"></a><span id="l23.149" class="difflineminus">- *     the default extractor for the gloda noun type is used.</span>
<a href="#l23.150"></a><span id="l23.150" class="difflineplus">+ *     the default extractor for the gloda noun type is used.  If no default</span>
<a href="#l23.151"></a><span id="l23.151" class="difflineplus">+ *     extractor exists, toString is called on the item.</span>
<a href="#l23.152"></a><span id="l23.152">  * @param aExpectedExtractor The extractor function to take an instance from the</span>
<a href="#l23.153"></a><span id="l23.153">  *     values in the aExpectedSet and return a string for comparison/equivalence</span>
<a href="#l23.154"></a><span id="l23.154">  *     against that returned by the gloda extractor.  The value returned must</span>
<a href="#l23.155"></a><span id="l23.155">  *     be unique for all of the values in the expected set.  If omitted, the</span>
<a href="#l23.156"></a><span id="l23.156">  *     default extractor for the presumed input type based on the gloda noun</span>
<a href="#l23.157"></a><span id="l23.157" class="difflineminus">- *     type used for the query is used.</span>
<a href="#l23.158"></a><span id="l23.158" class="difflineplus">+ *     type used for the query is used, failing over to toString.</span>
<a href="#l23.159"></a><span id="l23.159" class="difflineplus">+ * @param aOrderVerifier Optional function to verify the order the results are</span>
<a href="#l23.160"></a><span id="l23.160" class="difflineplus">+ *     received in.  Function signature should be of the form (aZeroBasedIndex,</span>
<a href="#l23.161"></a><span id="l23.161" class="difflineplus">+ *     aItem, aCollectionResultIsFor).</span>
<a href="#l23.162"></a><span id="l23.162">  * @returns The collection created from the query.</span>
<a href="#l23.163"></a><span id="l23.163">  */</span>
<a href="#l23.164"></a><span id="l23.164"> function queryExpect(aQuery, aExpectedSet, aGlodaExtractor,</span>
<a href="#l23.165"></a><span id="l23.165" class="difflineminus">-    aExpectedExtractor) {</span>
<a href="#l23.166"></a><span id="l23.166" class="difflineplus">+    aExpectedExtractor, aOrderVerifier) {</span>
<a href="#l23.167"></a><span id="l23.167">   if (aQuery.test)</span>
<a href="#l23.168"></a><span id="l23.168">     aQuery = {queryFunc: aQuery.getCollection, queryThis: aQuery, args: [],</span>
<a href="#l23.169"></a><span id="l23.169">               nounId: aQuery._nounDef.id};</span>
<a href="#l23.170"></a><span id="l23.170"> </span>
<a href="#l23.171"></a><span id="l23.171">   // - set extractor functions to defaults if omitted</span>
<a href="#l23.172"></a><span id="l23.172">   if (aGlodaExtractor == null) {</span>
<a href="#l23.173"></a><span id="l23.173">     if (_defaultExpectationExtractors[aQuery.nounId] !== undefined)</span>
<a href="#l23.174"></a><span id="l23.174">       aGlodaExtractor = _defaultExpectationExtractors[aQuery.nounId][0];</span>
<a href="#l23.175"></a><span id="l23.175" class="difflineat">@@ -901,17 +946,18 @@ function queryExpect(aQuery, aExpectedSe</span>
<a href="#l23.176"></a><span id="l23.176">     catch (ex) {</span>
<a href="#l23.177"></a><span id="l23.177">       do_throw(&quot;Expected extractor threw during query expectation for item: &quot; +</span>
<a href="#l23.178"></a><span id="l23.178">                item + &quot; exception: &quot; + ex);</span>
<a href="#l23.179"></a><span id="l23.179">     }</span>
<a href="#l23.180"></a><span id="l23.180">   }</span>
<a href="#l23.181"></a><span id="l23.181"> </span>
<a href="#l23.182"></a><span id="l23.182">   // - create the listener...</span>
<a href="#l23.183"></a><span id="l23.183">   aQuery.args.push(new QueryExpectationListener(expectedSet,</span>
<a href="#l23.184"></a><span id="l23.184" class="difflineminus">-                                                aGlodaExtractor));</span>
<a href="#l23.185"></a><span id="l23.185" class="difflineplus">+                                                aGlodaExtractor,</span>
<a href="#l23.186"></a><span id="l23.186" class="difflineplus">+                                                aOrderVerifier));</span>
<a href="#l23.187"></a><span id="l23.187">   return aQuery.queryFunc.apply(aQuery.queryThis, aQuery.args);</span>
<a href="#l23.188"></a><span id="l23.188"> }</span>
<a href="#l23.189"></a><span id="l23.189"> </span>
<a href="#l23.190"></a><span id="l23.190"> /**</span>
<a href="#l23.191"></a><span id="l23.191">  * Call the provided callback once the database has run all the async statements</span>
<a href="#l23.192"></a><span id="l23.192">  *  whose execution was queued prior to this call.</span>
<a href="#l23.193"></a><span id="l23.193">  * @param aCallback The callback to call.  No 'this' provided.</span>
<a href="#l23.194"></a><span id="l23.194">  */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_messages.js</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_messages.js</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -59,66 +59,75 @@ var fundamentalGlodaMessageId;</span>
<a href="#l24.4"></a><span id="l24.4">  *  by gloda's fundattr.js and perhaps the core message indexing logic itself</span>
<a href="#l24.5"></a><span id="l24.5">  *  (which show up as kSpecial* attributes in fundattr.js anyways.)</span>
<a href="#l24.6"></a><span id="l24.6">  */</span>
<a href="#l24.7"></a><span id="l24.7"> function test_attributes_fundamental() {</span>
<a href="#l24.8"></a><span id="l24.8">   // create a synthetic message</span>
<a href="#l24.9"></a><span id="l24.9">   let smsg = msgGen.makeMessage();</span>
<a href="#l24.10"></a><span id="l24.10">   // save it off for test_attributes_fundamental_from_disk</span>
<a href="#l24.11"></a><span id="l24.11">   fundamentalSyntheticMessage = smsg;</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineminus">-  </span>
<a href="#l24.13"></a><span id="l24.13" class="difflineplus">+</span>
<a href="#l24.14"></a><span id="l24.14">   indexMessages([smsg], verify_attributes_fundamental, next_test);</span>
<a href="#l24.15"></a><span id="l24.15"> }</span>
<a href="#l24.16"></a><span id="l24.16"> </span>
<a href="#l24.17"></a><span id="l24.17"> function verify_attributes_fundamental(smsg, gmsg) {</span>
<a href="#l24.18"></a><span id="l24.18" class="difflineminus">-  // save off the message id for test_attributes_fundamental_from_disk</span>
<a href="#l24.19"></a><span id="l24.19" class="difflineminus">-  fundamentalGlodaMessageId = gmsg.id;</span>
<a href="#l24.20"></a><span id="l24.20" class="difflineminus">-  </span>
<a href="#l24.21"></a><span id="l24.21" class="difflineminus">-  do_check_eq(gmsg.folderURI, gLocalInboxFolder.URI);</span>
<a href="#l24.22"></a><span id="l24.22" class="difflineminus">-  </span>
<a href="#l24.23"></a><span id="l24.23" class="difflineminus">-  // -- subject</span>
<a href="#l24.24"></a><span id="l24.24" class="difflineminus">-  do_check_eq(smsg.subject, gmsg.conversation.subject);</span>
<a href="#l24.25"></a><span id="l24.25" class="difflineminus">-  do_check_eq(smsg.subject, gmsg.subject);</span>
<a href="#l24.26"></a><span id="l24.26" class="difflineminus">-  </span>
<a href="#l24.27"></a><span id="l24.27" class="difflineminus">-  // -- contact/identity information</span>
<a href="#l24.28"></a><span id="l24.28" class="difflineminus">-  // - from</span>
<a href="#l24.29"></a><span id="l24.29" class="difflineminus">-  // check the e-mail address</span>
<a href="#l24.30"></a><span id="l24.30" class="difflineminus">-  do_check_eq(gmsg.from.kind, &quot;email&quot;);</span>
<a href="#l24.31"></a><span id="l24.31" class="difflineminus">-  do_check_eq(smsg.fromAddress, gmsg.from.value);</span>
<a href="#l24.32"></a><span id="l24.32" class="difflineminus">-  // check the name</span>
<a href="#l24.33"></a><span id="l24.33" class="difflineminus">-  do_check_eq(smsg.fromName, gmsg.from.contact.name);</span>
<a href="#l24.34"></a><span id="l24.34" class="difflineminus">-  </span>
<a href="#l24.35"></a><span id="l24.35" class="difflineminus">-  // - to</span>
<a href="#l24.36"></a><span id="l24.36" class="difflineminus">-  do_check_eq(smsg.toAddress, gmsg.to[0].value);</span>
<a href="#l24.37"></a><span id="l24.37" class="difflineminus">-  do_check_eq(smsg.toName, gmsg.to[0].contact.name);</span>
<a href="#l24.38"></a><span id="l24.38" class="difflineminus">-  </span>
<a href="#l24.39"></a><span id="l24.39" class="difflineminus">-  // date</span>
<a href="#l24.40"></a><span id="l24.40" class="difflineminus">-  do_check_eq(smsg.date.valueOf(), gmsg.date.valueOf());</span>
<a href="#l24.41"></a><span id="l24.41" class="difflineplus">+  try {</span>
<a href="#l24.42"></a><span id="l24.42" class="difflineplus">+    // save off the message id for test_attributes_fundamental_from_disk</span>
<a href="#l24.43"></a><span id="l24.43" class="difflineplus">+    fundamentalGlodaMessageId = gmsg.id;</span>
<a href="#l24.44"></a><span id="l24.44" class="difflineplus">+</span>
<a href="#l24.45"></a><span id="l24.45" class="difflineplus">+    do_check_eq(gmsg.folderURI, gLocalInboxFolder.URI);</span>
<a href="#l24.46"></a><span id="l24.46" class="difflineplus">+</span>
<a href="#l24.47"></a><span id="l24.47" class="difflineplus">+    // -- subject</span>
<a href="#l24.48"></a><span id="l24.48" class="difflineplus">+    do_check_eq(smsg.subject, gmsg.conversation.subject);</span>
<a href="#l24.49"></a><span id="l24.49" class="difflineplus">+    do_check_eq(smsg.subject, gmsg.subject);</span>
<a href="#l24.50"></a><span id="l24.50" class="difflineplus">+</span>
<a href="#l24.51"></a><span id="l24.51" class="difflineplus">+    // -- contact/identity information</span>
<a href="#l24.52"></a><span id="l24.52" class="difflineplus">+    // - from</span>
<a href="#l24.53"></a><span id="l24.53" class="difflineplus">+    // check the e-mail address</span>
<a href="#l24.54"></a><span id="l24.54" class="difflineplus">+    do_check_eq(gmsg.from.kind, &quot;email&quot;);</span>
<a href="#l24.55"></a><span id="l24.55" class="difflineplus">+    do_check_eq(smsg.fromAddress, gmsg.from.value);</span>
<a href="#l24.56"></a><span id="l24.56" class="difflineplus">+    // check the name</span>
<a href="#l24.57"></a><span id="l24.57" class="difflineplus">+    do_check_eq(smsg.fromName, gmsg.from.contact.name);</span>
<a href="#l24.58"></a><span id="l24.58" class="difflineplus">+</span>
<a href="#l24.59"></a><span id="l24.59" class="difflineplus">+    // - to</span>
<a href="#l24.60"></a><span id="l24.60" class="difflineplus">+    do_check_eq(smsg.toAddress, gmsg.to[0].value);</span>
<a href="#l24.61"></a><span id="l24.61" class="difflineplus">+    do_check_eq(smsg.toName, gmsg.to[0].contact.name);</span>
<a href="#l24.62"></a><span id="l24.62" class="difflineplus">+</span>
<a href="#l24.63"></a><span id="l24.63" class="difflineplus">+    // date</span>
<a href="#l24.64"></a><span id="l24.64" class="difflineplus">+    do_check_eq(smsg.date.valueOf(), gmsg.date.valueOf());</span>
<a href="#l24.65"></a><span id="l24.65" class="difflineplus">+  }</span>
<a href="#l24.66"></a><span id="l24.66" class="difflineplus">+  catch (ex) {</span>
<a href="#l24.67"></a><span id="l24.67" class="difflineplus">+    // print out some info on the various states of the messages...</span>
<a href="#l24.68"></a><span id="l24.68" class="difflineplus">+    dump(&quot;***** FUNDAMENTAL ATTRIBUTE NON-MATCH\n&quot;);</span>
<a href="#l24.69"></a><span id="l24.69" class="difflineplus">+    ddumpObject(smsg, &quot;smsg&quot;, 0);</span>
<a href="#l24.70"></a><span id="l24.70" class="difflineplus">+    ddumpObject(gmsg, &quot;gmsg&quot;, 0);</span>
<a href="#l24.71"></a><span id="l24.71" class="difflineplus">+    throw ex;</span>
<a href="#l24.72"></a><span id="l24.72" class="difflineplus">+  }</span>
<a href="#l24.73"></a><span id="l24.73"> }</span>
<a href="#l24.74"></a><span id="l24.74"> </span>
<a href="#l24.75"></a><span id="l24.75"> /**</span>
<a href="#l24.76"></a><span id="l24.76">  * We want to make sure that all of the fundamental properties also are there</span>
<a href="#l24.77"></a><span id="l24.77">  *  when we load them from disk.  Nuke our cache, query the message back up.</span>
<a href="#l24.78"></a><span id="l24.78">  *  We previously used getMessagesByMessageID to get the message back, but he</span>
<a href="#l24.79"></a><span id="l24.79">  *  does not perform a full load-out like a query does, so we need to use our</span>
<a href="#l24.80"></a><span id="l24.80">  *  query mechanism for this.</span>
<a href="#l24.81"></a><span id="l24.81">  */</span>
<a href="#l24.82"></a><span id="l24.82"> function test_attributes_fundamental_from_disk() {</span>
<a href="#l24.83"></a><span id="l24.83">   nukeGlodaCachesAndCollections();</span>
<a href="#l24.84"></a><span id="l24.84" class="difflineminus">-  </span>
<a href="#l24.85"></a><span id="l24.85" class="difflineplus">+</span>
<a href="#l24.86"></a><span id="l24.86">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE).id(fundamentalGlodaMessageId);</span>
<a href="#l24.87"></a><span id="l24.87">   queryExpect(query, [fundamentalSyntheticMessage],</span>
<a href="#l24.88"></a><span id="l24.88">       verify_attributes_fundamental_from_disk,</span>
<a href="#l24.89"></a><span id="l24.89">       function (smsg) { return smsg.messageId; } );</span>
<a href="#l24.90"></a><span id="l24.90"> }</span>
<a href="#l24.91"></a><span id="l24.91"> </span>
<a href="#l24.92"></a><span id="l24.92"> /**</span>
<a href="#l24.93"></a><span id="l24.93">  * We are just a wrapper around verify_attributes_fundamental, adapting the</span>
<a href="#l24.94"></a><span id="l24.94">  *  return callback from getMessagesByMessageID.</span>
<a href="#l24.95"></a><span id="l24.95" class="difflineminus">- * </span>
<a href="#l24.96"></a><span id="l24.96" class="difflineplus">+ *</span>
<a href="#l24.97"></a><span id="l24.97">  * @param aGlodaMessageLists This should be [[theGlodaMessage]].</span>
<a href="#l24.98"></a><span id="l24.98">  */</span>
<a href="#l24.99"></a><span id="l24.99"> function verify_attributes_fundamental_from_disk(aGlodaMessage) {</span>
<a href="#l24.100"></a><span id="l24.100">   // return the message id for test_attributes_fundamental_from_disk's benefit</span>
<a href="#l24.101"></a><span id="l24.101">   verify_attributes_fundamental(fundamentalSyntheticMessage,</span>
<a href="#l24.102"></a><span id="l24.102">                                 aGlodaMessage);</span>
<a href="#l24.103"></a><span id="l24.103">   return aGlodaMessage.headerMessageID;</span>
<a href="#l24.104"></a><span id="l24.104"> }</span>
<a href="#l24.105"></a><span id="l24.105" class="difflineat">@@ -177,32 +186,32 @@ function test_attributes_explicit() {</span>
<a href="#l24.106"></a><span id="l24.106"> </span>
<a href="#l24.107"></a><span id="l24.107"> function do_moveMessage(aMsgHdr, aDestFolder) {</span>
<a href="#l24.108"></a><span id="l24.108">   gCopyService.CopyMessages(aMsgHdr.folder,</span>
<a href="#l24.109"></a><span id="l24.109">     toXPCOMArray(aMsgHdr, Components.interfaces.nsIMutableArray),</span>
<a href="#l24.110"></a><span id="l24.110">     aDestFolder, true, null, null, true);</span>
<a href="#l24.111"></a><span id="l24.111"> }</span>
<a href="#l24.112"></a><span id="l24.112"> </span>
<a href="#l24.113"></a><span id="l24.113"> function verify_messageLocation(aMsgHdr, aMessage, aDestFolder) {</span>
<a href="#l24.114"></a><span id="l24.114" class="difflineminus">-  do_check_eq(aMessage.folderURI, aDestFolder.URI); </span>
<a href="#l24.115"></a><span id="l24.115" class="difflineplus">+  do_check_eq(aMessage.folderURI, aDestFolder.URI);</span>
<a href="#l24.116"></a><span id="l24.116"> }</span>
<a href="#l24.117"></a><span id="l24.117"> </span>
<a href="#l24.118"></a><span id="l24.118"> /* ===== Message Moving ===== */</span>
<a href="#l24.119"></a><span id="l24.119"> const gCopyService = Cc[&quot;@mozilla.org/messenger/messagecopyservice;1&quot;]</span>
<a href="#l24.120"></a><span id="l24.120">                       .getService(Ci.nsIMsgCopyService);</span>
<a href="#l24.121"></a><span id="l24.121"> </span>
<a href="#l24.122"></a><span id="l24.122"> function test_message_moving() {</span>
<a href="#l24.123"></a><span id="l24.123">   let rootFolder = gLocalIncomingServer.rootMsgFolder;</span>
<a href="#l24.124"></a><span id="l24.124">   let destFolder = rootFolder.addSubfolder(&quot;move1&quot;);</span>
<a href="#l24.125"></a><span id="l24.125" class="difflineminus">-  </span>
<a href="#l24.126"></a><span id="l24.126" class="difflineplus">+</span>
<a href="#l24.127"></a><span id="l24.127">   let moveTestActions = [</span>
<a href="#l24.128"></a><span id="l24.128">     [do_moveMessage, verify_messageLocation, destFolder],</span>
<a href="#l24.129"></a><span id="l24.129">     [do_moveMessage, verify_messageLocation, gLocalInboxFolder],</span>
<a href="#l24.130"></a><span id="l24.130">   ];</span>
<a href="#l24.131"></a><span id="l24.131" class="difflineminus">-  </span>
<a href="#l24.132"></a><span id="l24.132" class="difflineplus">+</span>
<a href="#l24.133"></a><span id="l24.133">   let smsg = msgGen.makeMessage();</span>
<a href="#l24.134"></a><span id="l24.134">   twiddleAndTest(smsg, moveTestActions);</span>
<a href="#l24.135"></a><span id="l24.135"> }</span>
<a href="#l24.136"></a><span id="l24.136"> </span>
<a href="#l24.137"></a><span id="l24.137"> /* ===== Message Deletion ===== */</span>
<a href="#l24.138"></a><span id="l24.138"> function test_message_deletion() {</span>
<a href="#l24.139"></a><span id="l24.139"> }</span>
<a href="#l24.140"></a><span id="l24.140"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_query_core.js</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_query_core.js</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -1,123 +1,163 @@</span>
<a href="#l25.4"></a><span id="l25.4"> /*</span>
<a href="#l25.5"></a><span id="l25.5">  * Test the mechanics our query functionality.  Tests in this file are intended</span>
<a href="#l25.6"></a><span id="l25.6">  *  to cover extreme boundary cases and things that are just unlikely to happen</span>
<a href="#l25.7"></a><span id="l25.7">  *  in reasonable message use-cases.  (Which is to say, it could be hard to</span>
<a href="#l25.8"></a><span id="l25.8">  *  formulate a set of synthetic messages that result in the situation we want</span>
<a href="#l25.9"></a><span id="l25.9" class="difflineminus">- *  to test for.)  </span>
<a href="#l25.10"></a><span id="l25.10" class="difflineplus">+ *  to test for.)</span>
<a href="#l25.11"></a><span id="l25.11">  */</span>
<a href="#l25.12"></a><span id="l25.12"> </span>
<a href="#l25.13"></a><span id="l25.13"> load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l25.14"></a><span id="l25.14" class="difflineplus">+load(&quot;resources/genericIndexer.js&quot;);</span>
<a href="#l25.15"></a><span id="l25.15"> </span>
<a href="#l25.16"></a><span id="l25.16"> /* ===== Test Noun ===== */</span>
<a href="#l25.17"></a><span id="l25.17"> /*</span>
<a href="#l25.18"></a><span id="l25.18">  * Introduce a simple noun type for our testing so that we can avoid having to</span>
<a href="#l25.19"></a><span id="l25.19" class="difflineminus">- * deal with the semantics of messages/friends and all their complexity. </span>
<a href="#l25.20"></a><span id="l25.20" class="difflineplus">+ * deal with the semantics of messages/friends and all their complexity.</span>
<a href="#l25.21"></a><span id="l25.21">  */</span>
<a href="#l25.22"></a><span id="l25.22"> </span>
<a href="#l25.23"></a><span id="l25.23" class="difflineminus">-Widget = function () {</span>
<a href="#l25.24"></a><span id="l25.24" class="difflineplus">+function Widget(inum, date, str, notability, text1, text2) {</span>
<a href="#l25.25"></a><span id="l25.25" class="difflineplus">+  this._inum = inum;</span>
<a href="#l25.26"></a><span id="l25.26" class="difflineplus">+  this._date = date;</span>
<a href="#l25.27"></a><span id="l25.27" class="difflineplus">+  this._str = str;</span>
<a href="#l25.28"></a><span id="l25.28" class="difflineplus">+  this._notability = notability;</span>
<a href="#l25.29"></a><span id="l25.29" class="difflineplus">+  this._text1 = text1;</span>
<a href="#l25.30"></a><span id="l25.30" class="difflineplus">+  this._text2 = text2;</span>
<a href="#l25.31"></a><span id="l25.31"> }</span>
<a href="#l25.32"></a><span id="l25.32"> Widget.prototype = {</span>
<a href="#l25.33"></a><span id="l25.33" class="difflineplus">+  // gloda's attribute idiom demands that row attributes be prefixed with a '_'</span>
<a href="#l25.34"></a><span id="l25.34" class="difflineplus">+  //  (because Gloda.grokNounItem detects attributes by just walking...).  This</span>
<a href="#l25.35"></a><span id="l25.35" class="difflineplus">+  //  could be resolved by having the special attributes moot these dudes, but</span>
<a href="#l25.36"></a><span id="l25.36" class="difflineplus">+  //  that's not how things are right now.</span>
<a href="#l25.37"></a><span id="l25.37" class="difflineplus">+  get inum() { return this._inum; },</span>
<a href="#l25.38"></a><span id="l25.38" class="difflineplus">+  set inum(aVal) { this._inum = aVal; },</span>
<a href="#l25.39"></a><span id="l25.39" class="difflineplus">+  get date() { return this._date; },</span>
<a href="#l25.40"></a><span id="l25.40" class="difflineplus">+  set date(aVal) { this._date = aVal; },</span>
<a href="#l25.41"></a><span id="l25.41" class="difflineplus">+  get str() { return this._str; },</span>
<a href="#l25.42"></a><span id="l25.42" class="difflineplus">+  set str(aVal) { this._str = aVal; },</span>
<a href="#l25.43"></a><span id="l25.43" class="difflineplus">+  get notability() { return this._notability; },</span>
<a href="#l25.44"></a><span id="l25.44" class="difflineplus">+  set notability(aVal) { this._notability = aVal; },</span>
<a href="#l25.45"></a><span id="l25.45" class="difflineplus">+  get text1() { return this._text1; },</span>
<a href="#l25.46"></a><span id="l25.46" class="difflineplus">+  set text1(aVal) { this._text1 = aVal; },</span>
<a href="#l25.47"></a><span id="l25.47" class="difflineplus">+  get text2() { return this._text2; },</span>
<a href="#l25.48"></a><span id="l25.48" class="difflineplus">+  set text2(aVal) { this._text2 = aVal; },</span>
<a href="#l25.49"></a><span id="l25.49" class="difflineplus">+</span>
<a href="#l25.50"></a><span id="l25.50">   toString: function () {</span>
<a href="#l25.51"></a><span id="l25.51">     return &quot;&quot; + this.id;</span>
<a href="#l25.52"></a><span id="l25.52">   }</span>
<a href="#l25.53"></a><span id="l25.53"> };</span>
<a href="#l25.54"></a><span id="l25.54"> </span>
<a href="#l25.55"></a><span id="l25.55"> var WidgetProvider = {</span>
<a href="#l25.56"></a><span id="l25.56">   providerName: &quot;widget&quot;,</span>
<a href="#l25.57"></a><span id="l25.57" class="difflineminus">-  process: function () {}</span>
<a href="#l25.58"></a><span id="l25.58" class="difflineplus">+  process: function () {</span>
<a href="#l25.59"></a><span id="l25.59" class="difflineplus">+    yield Gloda.kWorkDone;</span>
<a href="#l25.60"></a><span id="l25.60" class="difflineplus">+  }</span>
<a href="#l25.61"></a><span id="l25.61"> };</span>
<a href="#l25.62"></a><span id="l25.62"> </span>
<a href="#l25.63"></a><span id="l25.63"> var WidgetNoun;</span>
<a href="#l25.64"></a><span id="l25.64"> function setup_test_noun_and_attributes() {</span>
<a href="#l25.65"></a><span id="l25.65">   // --- noun</span>
<a href="#l25.66"></a><span id="l25.66">   WidgetNoun = Gloda.defineNoun({</span>
<a href="#l25.67"></a><span id="l25.67">     name: &quot;widget&quot;,</span>
<a href="#l25.68"></a><span id="l25.68" class="difflineminus">-    class: Widget,</span>
<a href="#l25.69"></a><span id="l25.69" class="difflineplus">+    clazz: Widget,</span>
<a href="#l25.70"></a><span id="l25.70">     allowArbitraryAttrs: true,</span>
<a href="#l25.71"></a><span id="l25.71">     schema: {</span>
<a href="#l25.72"></a><span id="l25.72">       columns: [['id', 'INTEGER PRIMARY KEY'],</span>
<a href="#l25.73"></a><span id="l25.73" class="difflineminus">-                ['intCol', 'NUMBER'],</span>
<a href="#l25.74"></a><span id="l25.74" class="difflineminus">-                ['strCol', 'STRING']],</span>
<a href="#l25.75"></a><span id="l25.75" class="difflineplus">+                ['intCol', 'NUMBER', 'inum'],</span>
<a href="#l25.76"></a><span id="l25.76" class="difflineplus">+                ['dateCol', 'NUMBER', 'date'],</span>
<a href="#l25.77"></a><span id="l25.77" class="difflineplus">+                ['strCol', 'STRING', 'str'],</span>
<a href="#l25.78"></a><span id="l25.78" class="difflineplus">+                ['notabilityCol', 'NUMBER', 'notability'],</span>
<a href="#l25.79"></a><span id="l25.79" class="difflineplus">+                ['textOne', 'STRING', 'text1'],</span>
<a href="#l25.80"></a><span id="l25.80" class="difflineplus">+                ['textTwo', 'STRING', 'text2']],</span>
<a href="#l25.81"></a><span id="l25.81">       indices: {intCol: ['intCol'],</span>
<a href="#l25.82"></a><span id="l25.82">                 strCol: ['strCol']},</span>
<a href="#l25.83"></a><span id="l25.83" class="difflineminus">-      fulltextColumns: [['fulltextOne', 'TEXT'],</span>
<a href="#l25.84"></a><span id="l25.84" class="difflineminus">-                        ['fulltextTwo', 'TEXT']],</span>
<a href="#l25.85"></a><span id="l25.85" class="difflineplus">+      fulltextColumns: [['fulltextOne', 'TEXT', 'text1'],</span>
<a href="#l25.86"></a><span id="l25.86" class="difflineplus">+                        ['fulltextTwo', 'TEXT', 'text2']],</span>
<a href="#l25.87"></a><span id="l25.87">       genericAttributes: true</span>
<a href="#l25.88"></a><span id="l25.88">     }</span>
<a href="#l25.89"></a><span id="l25.89">   });</span>
<a href="#l25.90"></a><span id="l25.90" class="difflineminus">-  </span>
<a href="#l25.91"></a><span id="l25.91" class="difflineplus">+</span>
<a href="#l25.92"></a><span id="l25.92">   EXT_NAME = &quot;test&quot;;</span>
<a href="#l25.93"></a><span id="l25.93" class="difflineminus">-  </span>
<a href="#l25.94"></a><span id="l25.94" class="difflineplus">+</span>
<a href="#l25.95"></a><span id="l25.95">   // --- special (on-row) attributes</span>
<a href="#l25.96"></a><span id="l25.96">   Gloda.defineAttribute({</span>
<a href="#l25.97"></a><span id="l25.97" class="difflineminus">-    provider: this, extensionName: EXT_NAME,</span>
<a href="#l25.98"></a><span id="l25.98" class="difflineplus">+    provider: WidgetProvider, extensionName: EXT_NAME,</span>
<a href="#l25.99"></a><span id="l25.99">     attributeType: Gloda.kAttrFundamental,</span>
<a href="#l25.100"></a><span id="l25.100">     attributeName: &quot;intCol&quot;,</span>
<a href="#l25.101"></a><span id="l25.101">     singular: true,</span>
<a href="#l25.102"></a><span id="l25.102">     special: Gloda.kSpecialColumn,</span>
<a href="#l25.103"></a><span id="l25.103">     specialColumnName: &quot;intCol&quot;,</span>
<a href="#l25.104"></a><span id="l25.104">     subjectNouns: [WidgetNoun.id],</span>
<a href="#l25.105"></a><span id="l25.105">     objectNoun: Gloda.NOUN_NUMBER</span>
<a href="#l25.106"></a><span id="l25.106">   });</span>
<a href="#l25.107"></a><span id="l25.107">   Gloda.defineAttribute({</span>
<a href="#l25.108"></a><span id="l25.108" class="difflineminus">-    provider: this, extensionName: EXT_NAME,</span>
<a href="#l25.109"></a><span id="l25.109" class="difflineplus">+    provider: WidgetProvider, extensionName: EXT_NAME,</span>
<a href="#l25.110"></a><span id="l25.110" class="difflineplus">+    attributeType: Gloda.kAttrFundamental,</span>
<a href="#l25.111"></a><span id="l25.111" class="difflineplus">+    attributeName: &quot;dateCol&quot;,</span>
<a href="#l25.112"></a><span id="l25.112" class="difflineplus">+    singular: true,</span>
<a href="#l25.113"></a><span id="l25.113" class="difflineplus">+    special: Gloda.kSpecialColumn,</span>
<a href="#l25.114"></a><span id="l25.114" class="difflineplus">+    specialColumnName: &quot;dateCol&quot;,</span>
<a href="#l25.115"></a><span id="l25.115" class="difflineplus">+    subjectNouns: [WidgetNoun.id],</span>
<a href="#l25.116"></a><span id="l25.116" class="difflineplus">+    objectNoun: Gloda.NOUN_DATE</span>
<a href="#l25.117"></a><span id="l25.117" class="difflineplus">+  });</span>
<a href="#l25.118"></a><span id="l25.118" class="difflineplus">+  Gloda.defineAttribute({</span>
<a href="#l25.119"></a><span id="l25.119" class="difflineplus">+    provider: WidgetProvider, extensionName: EXT_NAME,</span>
<a href="#l25.120"></a><span id="l25.120">     attributeType: Gloda.kAttrFundamental,</span>
<a href="#l25.121"></a><span id="l25.121">     attributeName: &quot;strCol&quot;,</span>
<a href="#l25.122"></a><span id="l25.122">     singular: true,</span>
<a href="#l25.123"></a><span id="l25.123">     special: Gloda.kSpecialString,</span>
<a href="#l25.124"></a><span id="l25.124">     specialColumnName: &quot;strCol&quot;,</span>
<a href="#l25.125"></a><span id="l25.125">     subjectNouns: [WidgetNoun.id],</span>
<a href="#l25.126"></a><span id="l25.126">     objectNoun: Gloda.NOUN_STRING</span>
<a href="#l25.127"></a><span id="l25.127">   });</span>
<a href="#l25.128"></a><span id="l25.128" class="difflineminus">-  </span>
<a href="#l25.129"></a><span id="l25.129" class="difflineminus">-  </span>
<a href="#l25.130"></a><span id="l25.130" class="difflineplus">+</span>
<a href="#l25.131"></a><span id="l25.131" class="difflineplus">+</span>
<a href="#l25.132"></a><span id="l25.132">   // --- fulltext attributes</span>
<a href="#l25.133"></a><span id="l25.133">   Gloda.defineAttribute({</span>
<a href="#l25.134"></a><span id="l25.134" class="difflineminus">-    provider: this, extensionName: EXT_NAME,</span>
<a href="#l25.135"></a><span id="l25.135" class="difflineplus">+    provider: WidgetProvider, extensionName: EXT_NAME,</span>
<a href="#l25.136"></a><span id="l25.136">     attributeType: Gloda.kAttrFundamental,</span>
<a href="#l25.137"></a><span id="l25.137">     attributeName: &quot;fulltextOne&quot;,</span>
<a href="#l25.138"></a><span id="l25.138">     singular: true,</span>
<a href="#l25.139"></a><span id="l25.139">     special: Gloda.kSpecialFulltext,</span>
<a href="#l25.140"></a><span id="l25.140">     specialColumnName: &quot;fulltextOne&quot;,</span>
<a href="#l25.141"></a><span id="l25.141">     subjectNouns: [WidgetNoun.id],</span>
<a href="#l25.142"></a><span id="l25.142">     objectNoun: Gloda.NOUN_FULLTEXT</span>
<a href="#l25.143"></a><span id="l25.143">   });</span>
<a href="#l25.144"></a><span id="l25.144">   Gloda.defineAttribute({</span>
<a href="#l25.145"></a><span id="l25.145" class="difflineminus">-    provider: this, extensionName: EXT_NAME,</span>
<a href="#l25.146"></a><span id="l25.146" class="difflineplus">+    provider: WidgetProvider, extensionName: EXT_NAME,</span>
<a href="#l25.147"></a><span id="l25.147">     attributeType: Gloda.kAttrFundamental,</span>
<a href="#l25.148"></a><span id="l25.148">     attributeName: &quot;fulltextTwo&quot;,</span>
<a href="#l25.149"></a><span id="l25.149">     singular: true,</span>
<a href="#l25.150"></a><span id="l25.150">     special: Gloda.kSpecialFulltext,</span>
<a href="#l25.151"></a><span id="l25.151">     specialColumnName: &quot;fulltextTwo&quot;,</span>
<a href="#l25.152"></a><span id="l25.152">     subjectNouns: [WidgetNoun.id],</span>
<a href="#l25.153"></a><span id="l25.153">     objectNoun: Gloda.NOUN_FULLTEXT</span>
<a href="#l25.154"></a><span id="l25.154">   });</span>
<a href="#l25.155"></a><span id="l25.155">   Gloda.defineAttribute({</span>
<a href="#l25.156"></a><span id="l25.156" class="difflineminus">-    provider: this, extensionName: EXT_NAME,</span>
<a href="#l25.157"></a><span id="l25.157" class="difflineplus">+    provider: WidgetProvider, extensionName: EXT_NAME,</span>
<a href="#l25.158"></a><span id="l25.158">     attributeType: Gloda.kAttrFundamental,</span>
<a href="#l25.159"></a><span id="l25.159">     attributeName: &quot;fulltextAll&quot;,</span>
<a href="#l25.160"></a><span id="l25.160">     singular: true,</span>
<a href="#l25.161"></a><span id="l25.161">     special: Gloda.kSpecialFulltext,</span>
<a href="#l25.162"></a><span id="l25.162">     specialColumnName: WidgetNoun.tableName + &quot;Text&quot;,</span>
<a href="#l25.163"></a><span id="l25.163">     subjectNouns: [WidgetNoun.id],</span>
<a href="#l25.164"></a><span id="l25.164">     objectNoun: Gloda.NOUN_FULLTEXT</span>
<a href="#l25.165"></a><span id="l25.165">   });</span>
<a href="#l25.166"></a><span id="l25.166" class="difflineminus">-  </span>
<a href="#l25.167"></a><span id="l25.167" class="difflineplus">+</span>
<a href="#l25.168"></a><span id="l25.168">   // --- external (attribute-storage) attributes</span>
<a href="#l25.169"></a><span id="l25.169">   Gloda.defineAttribute({</span>
<a href="#l25.170"></a><span id="l25.170" class="difflineminus">-    provider: this, extensionName: EXT_NAME,</span>
<a href="#l25.171"></a><span id="l25.171" class="difflineplus">+    provider: WidgetProvider, extensionName: EXT_NAME,</span>
<a href="#l25.172"></a><span id="l25.172">     attributeType: Gloda.kAttrFundamental,</span>
<a href="#l25.173"></a><span id="l25.173">     attributeName: &quot;singleIntAttr&quot;,</span>
<a href="#l25.174"></a><span id="l25.174">     singular: true,</span>
<a href="#l25.175"></a><span id="l25.175">     subjectNouns: [WidgetNoun.id],</span>
<a href="#l25.176"></a><span id="l25.176">     objectNoun: Gloda.NOUN_NUMBER</span>
<a href="#l25.177"></a><span id="l25.177">   });</span>
<a href="#l25.178"></a><span id="l25.178" class="difflineminus">-  </span>
<a href="#l25.179"></a><span id="l25.179" class="difflineplus">+</span>
<a href="#l25.180"></a><span id="l25.180">   next_test();</span>
<a href="#l25.181"></a><span id="l25.181"> }</span>
<a href="#l25.182"></a><span id="l25.182"> </span>
<a href="#l25.183"></a><span id="l25.183"> /* ===== Tests ===== */</span>
<a href="#l25.184"></a><span id="l25.184"> </span>
<a href="#l25.185"></a><span id="l25.185"> ALPHABET = &quot;abcdefghijklmnopqrstuvwxyz&quot;;</span>
<a href="#l25.186"></a><span id="l25.186"> function test_lots_of_string_constraints() {</span>
<a href="#l25.187"></a><span id="l25.187">   let stringConstraints = [];</span>
<a href="#l25.188"></a><span id="l25.188" class="difflineat">@@ -127,27 +167,157 @@ function test_lots_of_string_constraints</span>
<a href="#l25.189"></a><span id="l25.189">                            ALPHABET[Math.floor(i / (ALPHABET.length)) %</span>
<a href="#l25.190"></a><span id="l25.190">                                     ALPHABET.length] +</span>
<a href="#l25.191"></a><span id="l25.191">                            ALPHABET[i % ALPHABET.length] +</span>
<a href="#l25.192"></a><span id="l25.192">                            // throw in something that will explode if not quoted</span>
<a href="#l25.193"></a><span id="l25.193">                            // (and use an uneven number of things so if we fail</span>
<a href="#l25.194"></a><span id="l25.194">                            // to quote it won't get quietly eaten.)</span>
<a href="#l25.195"></a><span id="l25.195">                            &quot;'&quot; + '&quot;');</span>
<a href="#l25.196"></a><span id="l25.196">   }</span>
<a href="#l25.197"></a><span id="l25.197" class="difflineminus">-  </span>
<a href="#l25.198"></a><span id="l25.198" class="difflineplus">+</span>
<a href="#l25.199"></a><span id="l25.199">   let query = Gloda.newQuery(WidgetNoun.id);</span>
<a href="#l25.200"></a><span id="l25.200">   query.strCol.apply(query, stringConstraints);</span>
<a href="#l25.201"></a><span id="l25.201" class="difflineminus">-  </span>
<a href="#l25.202"></a><span id="l25.202" class="difflineplus">+</span>
<a href="#l25.203"></a><span id="l25.203">   queryExpect(query, []);</span>
<a href="#l25.204"></a><span id="l25.204"> }</span>
<a href="#l25.205"></a><span id="l25.205"> </span>
<a href="#l25.206"></a><span id="l25.206" class="difflineplus">+/* === Search === */</span>
<a href="#l25.207"></a><span id="l25.207" class="difflineplus">+/*</span>
<a href="#l25.208"></a><span id="l25.208" class="difflineplus">+ * The conceit of our search is that more recent messages are better than older</span>
<a href="#l25.209"></a><span id="l25.209" class="difflineplus">+ *  messages.  But at the same time, we care about some messages more than</span>
<a href="#l25.210"></a><span id="l25.210" class="difflineplus">+ *  others (in general), and we care about messages that match search terms</span>
<a href="#l25.211"></a><span id="l25.211" class="difflineplus">+ *  more strongly too.  So we introduce a general 'score' heuristic which we</span>
<a href="#l25.212"></a><span id="l25.212" class="difflineplus">+ *  then apply to message timestamps to make them appear more recent.  We</span>
<a href="#l25.213"></a><span id="l25.213" class="difflineplus">+ *  then order by this 'date score' hybrid, which we dub &quot;dascore&quot;.  Such a</span>
<a href="#l25.214"></a><span id="l25.214" class="difflineplus">+ *  flattening heuristic is over-simple, but believed to be sufficient to</span>
<a href="#l25.215"></a><span id="l25.215" class="difflineplus">+ *  generally get us the messsages we want.  Post-processing based can then</span>
<a href="#l25.216"></a><span id="l25.216" class="difflineplus">+ *  be more multi-dimensional and what not, but that is beyond the scope of</span>
<a href="#l25.217"></a><span id="l25.217" class="difflineplus">+ *  this unit test.</span>
<a href="#l25.218"></a><span id="l25.218" class="difflineplus">+ */</span>
<a href="#l25.219"></a><span id="l25.219" class="difflineplus">+</span>
<a href="#l25.220"></a><span id="l25.220" class="difflineplus">+/**</span>
<a href="#l25.221"></a><span id="l25.221" class="difflineplus">+ * How much time boost should a 'score point' amount to?  The authoritative,</span>
<a href="#l25.222"></a><span id="l25.222" class="difflineplus">+ *  incontrivertible answer, across all time and space, is a week.</span>
<a href="#l25.223"></a><span id="l25.223" class="difflineplus">+ *  Note that gloda stores timestamps as PRTimes for no exceedingly good</span>
<a href="#l25.224"></a><span id="l25.224" class="difflineplus">+ *  reason.</span>
<a href="#l25.225"></a><span id="l25.225" class="difflineplus">+ */</span>
<a href="#l25.226"></a><span id="l25.226" class="difflineplus">+const SCORE_TIMESTAMP_FACTOR = 1000 * 1000 * 60 * 60 * 24 * 7;</span>
<a href="#l25.227"></a><span id="l25.227" class="difflineplus">+</span>
<a href="#l25.228"></a><span id="l25.228" class="difflineplus">+/**</span>
<a href="#l25.229"></a><span id="l25.229" class="difflineplus">+ * How many score points for each fulltext match?</span>
<a href="#l25.230"></a><span id="l25.230" class="difflineplus">+ */</span>
<a href="#l25.231"></a><span id="l25.231" class="difflineplus">+const SCORE_FOR_FULLTEXT_MATCH = 1;</span>
<a href="#l25.232"></a><span id="l25.232" class="difflineplus">+</span>
<a href="#l25.233"></a><span id="l25.233" class="difflineplus">+/**</span>
<a href="#l25.234"></a><span id="l25.234" class="difflineplus">+ * Roughly how many characters are in each offset match.</span>
<a href="#l25.235"></a><span id="l25.235" class="difflineplus">+ */</span>
<a href="#l25.236"></a><span id="l25.236" class="difflineplus">+const OFFSET_CHARS_PER_FULLTEXT_MATCH = 8;</span>
<a href="#l25.237"></a><span id="l25.237" class="difflineplus">+</span>
<a href="#l25.238"></a><span id="l25.238" class="difflineplus">+var fooWidgets = null;</span>
<a href="#l25.239"></a><span id="l25.239" class="difflineplus">+var barBazWidgets = null;</span>
<a href="#l25.240"></a><span id="l25.240" class="difflineplus">+</span>
<a href="#l25.241"></a><span id="l25.241" class="difflineplus">+function setup_search_ranking_idiom() {</span>
<a href="#l25.242"></a><span id="l25.242" class="difflineplus">+  // --- build some widgets for testing.  use inum to represent the expected</span>
<a href="#l25.243"></a><span id="l25.243" class="difflineplus">+  //  result sequence</span>
<a href="#l25.244"></a><span id="l25.244" class="difflineplus">+  // setup a base date...</span>
<a href="#l25.245"></a><span id="l25.245" class="difflineplus">+  let origin = new Date(&quot;2008/01/01&quot;);</span>
<a href="#l25.246"></a><span id="l25.246" class="difflineplus">+  let daymore = new Date(&quot;2008/01/02&quot;);</span>
<a href="#l25.247"></a><span id="l25.247" class="difflineplus">+  let monthmore = new Date(&quot;2008/02/01&quot;);</span>
<a href="#l25.248"></a><span id="l25.248" class="difflineplus">+  fooWidgets = [</span>
<a href="#l25.249"></a><span id="l25.249" class="difflineplus">+    // -- setup the term &quot;foo&quot; to do frequency tests</span>
<a href="#l25.250"></a><span id="l25.250" class="difflineplus">+    new Widget(5, origin, &quot;&quot;, 0, &quot;&quot;, &quot;foo&quot;),</span>
<a href="#l25.251"></a><span id="l25.251" class="difflineplus">+    new Widget(4, origin, &quot;&quot;, 0, &quot;&quot;, &quot;foo foo&quot;),</span>
<a href="#l25.252"></a><span id="l25.252" class="difflineplus">+    new Widget(3, origin, &quot;&quot;, 0, &quot;foo&quot;, &quot;foo foo&quot;),</span>
<a href="#l25.253"></a><span id="l25.253" class="difflineplus">+    new Widget(2, origin, &quot;&quot;, 0, &quot;foo foo&quot;, &quot;foo foo&quot;),</span>
<a href="#l25.254"></a><span id="l25.254" class="difflineplus">+    new Widget(1, origin, &quot;&quot;, 0, &quot;foo foo&quot;, &quot;foo foo foo&quot;),</span>
<a href="#l25.255"></a><span id="l25.255" class="difflineplus">+    new Widget(0, origin, &quot;&quot;, 0, &quot;foo foo foo&quot;, &quot;foo foo foo&quot;)</span>
<a href="#l25.256"></a><span id="l25.256" class="difflineplus">+  ];</span>
<a href="#l25.257"></a><span id="l25.257" class="difflineplus">+  barBazWidgets = [</span>
<a href="#l25.258"></a><span id="l25.258" class="difflineplus">+    // -- setup score and matches to boost older messages over newer messages</span>
<a href="#l25.259"></a><span id="l25.259" class="difflineplus">+    new Widget(7, origin, &quot;&quot;, 0, &quot;&quot;, &quot;bar&quot;), // score boost: 1 + date: 0</span>
<a href="#l25.260"></a><span id="l25.260" class="difflineplus">+    new Widget(6, daymore, &quot;&quot;, 0, &quot;&quot;, &quot;bar&quot;), // 1 + 0+</span>
<a href="#l25.261"></a><span id="l25.261" class="difflineplus">+    new Widget(5, origin, &quot;&quot;, 1, &quot;&quot;, &quot;bar&quot;), // 2 + 0</span>
<a href="#l25.262"></a><span id="l25.262" class="difflineplus">+    new Widget(4, daymore, &quot;&quot;, 0, &quot;bar&quot;, &quot;bar&quot;), // 2 + 0+</span>
<a href="#l25.263"></a><span id="l25.263" class="difflineplus">+    new Widget(3, origin, &quot;&quot;, 1, &quot;bar&quot;, &quot;baz&quot;), // 3 + 0</span>
<a href="#l25.264"></a><span id="l25.264" class="difflineplus">+    new Widget(2, monthmore, &quot;&quot;, 0, &quot;&quot;, &quot;bar&quot;), // 1 + 4</span>
<a href="#l25.265"></a><span id="l25.265" class="difflineplus">+    new Widget(1, origin, &quot;&quot;, 0, &quot;bar baz&quot;, &quot;bar baz bar bar&quot;), // 6 + 0</span>
<a href="#l25.266"></a><span id="l25.266" class="difflineplus">+    new Widget(0, origin, &quot;&quot;, 1, &quot;bar baz&quot;, &quot;bar baz bar bar&quot;) // 7 + 0</span>
<a href="#l25.267"></a><span id="l25.267" class="difflineplus">+  ];</span>
<a href="#l25.268"></a><span id="l25.268" class="difflineplus">+  runOnIndexingComplete(next_test);</span>
<a href="#l25.269"></a><span id="l25.269" class="difflineplus">+  GenericIndexer.indexNewObjects(fooWidgets.concat(barBazWidgets));</span>
<a href="#l25.270"></a><span id="l25.270" class="difflineplus">+}</span>
<a href="#l25.271"></a><span id="l25.271" class="difflineplus">+</span>
<a href="#l25.272"></a><span id="l25.272" class="difflineplus">+// add one because the last snippet shouldn't have a trailing space</span>
<a href="#l25.273"></a><span id="l25.273" class="difflineplus">+const OFFSET_SCORE_SQL_SNIPPET =</span>
<a href="#l25.274"></a><span id="l25.274" class="difflineplus">+  &quot;(((length(osets) + 1) / &quot; + OFFSET_CHARS_PER_FULLTEXT_MATCH + &quot;) * &quot; +</span>
<a href="#l25.275"></a><span id="l25.275" class="difflineplus">+  SCORE_FOR_FULLTEXT_MATCH + &quot;)&quot;;</span>
<a href="#l25.276"></a><span id="l25.276" class="difflineplus">+</span>
<a href="#l25.277"></a><span id="l25.277" class="difflineplus">+const SCORE_SQL_SNIPPET =</span>
<a href="#l25.278"></a><span id="l25.278" class="difflineplus">+  &quot;(&quot; + OFFSET_SCORE_SQL_SNIPPET + &quot; + notabilityCol)&quot;;</span>
<a href="#l25.279"></a><span id="l25.279" class="difflineplus">+</span>
<a href="#l25.280"></a><span id="l25.280" class="difflineplus">+const DASCORE_SQL_SNIPPET =</span>
<a href="#l25.281"></a><span id="l25.281" class="difflineplus">+  &quot;((&quot; + SCORE_SQL_SNIPPET + &quot; * &quot; + SCORE_TIMESTAMP_FACTOR + &quot;) + dateCol)&quot;;</span>
<a href="#l25.282"></a><span id="l25.282" class="difflineplus">+</span>
<a href="#l25.283"></a><span id="l25.283" class="difflineplus">+const WIDGET_FULLTEXT_QUERY_EXPLICIT_SQL =</span>
<a href="#l25.284"></a><span id="l25.284" class="difflineplus">+  &quot;SELECT ext_widget.*, offsets(ext_widgetText) AS osets &quot; +</span>
<a href="#l25.285"></a><span id="l25.285" class="difflineplus">+    &quot;FROM ext_widget, ext_widgetText WHERE ext_widgetText MATCH ?&quot; +</span>
<a href="#l25.286"></a><span id="l25.286" class="difflineplus">+    &quot; AND ext_widget.id == ext_widgetText.docid&quot;;</span>
<a href="#l25.287"></a><span id="l25.287" class="difflineplus">+</span>
<a href="#l25.288"></a><span id="l25.288" class="difflineplus">+/**</span>
<a href="#l25.289"></a><span id="l25.289" class="difflineplus">+ * Used by queryExpect to verify</span>
<a href="#l25.290"></a><span id="l25.290" class="difflineplus">+ */</span>
<a href="#l25.291"></a><span id="l25.291" class="difflineplus">+function verify_widget_order_and_stashing(aZeroBasedIndex, aWidget,</span>
<a href="#l25.292"></a><span id="l25.292" class="difflineplus">+                                          aCollection) {</span>
<a href="#l25.293"></a><span id="l25.293" class="difflineplus">+  do_check_eq(aZeroBasedIndex, aWidget.inum);</span>
<a href="#l25.294"></a><span id="l25.294" class="difflineplus">+  if (!aCollection.stashedColumns[aWidget.id] ||</span>
<a href="#l25.295"></a><span id="l25.295" class="difflineplus">+      !aCollection.stashedColumns[aWidget.id].length)</span>
<a href="#l25.296"></a><span id="l25.296" class="difflineplus">+    do_throw(&quot;no stashed information for widget: &quot; + aWidget);</span>
<a href="#l25.297"></a><span id="l25.297" class="difflineplus">+}</span>
<a href="#l25.298"></a><span id="l25.298" class="difflineplus">+</span>
<a href="#l25.299"></a><span id="l25.299" class="difflineplus">+/**</span>
<a href="#l25.300"></a><span id="l25.300" class="difflineplus">+ * Test the fundamentals of the search ranking idiom we use elsewhere.  This</span>
<a href="#l25.301"></a><span id="l25.301" class="difflineplus">+ *  is primarily a simplified</span>
<a href="#l25.302"></a><span id="l25.302" class="difflineplus">+ */</span>
<a href="#l25.303"></a><span id="l25.303" class="difflineplus">+function test_search_ranking_idiom_offsets() {</span>
<a href="#l25.304"></a><span id="l25.304" class="difflineplus">+  let query = Gloda.newQuery(WidgetNoun.id, {</span>
<a href="#l25.305"></a><span id="l25.305" class="difflineplus">+    explicitSQL: WIDGET_FULLTEXT_QUERY_EXPLICIT_SQL,</span>
<a href="#l25.306"></a><span id="l25.306" class="difflineplus">+    // osets becomes 0-based column number 7</span>
<a href="#l25.307"></a><span id="l25.307" class="difflineplus">+    // dascore becomes 0-based column number 8</span>
<a href="#l25.308"></a><span id="l25.308" class="difflineplus">+    outerWrapColumns: [DASCORE_SQL_SNIPPET + &quot; AS dascore&quot;],</span>
<a href="#l25.309"></a><span id="l25.309" class="difflineplus">+    // save our extra columns for analysis and debugging</span>
<a href="#l25.310"></a><span id="l25.310" class="difflineplus">+    stashColumns: [7, 8]</span>
<a href="#l25.311"></a><span id="l25.311" class="difflineplus">+  });</span>
<a href="#l25.312"></a><span id="l25.312" class="difflineplus">+  query.fulltextAll(&quot;foo&quot;);</span>
<a href="#l25.313"></a><span id="l25.313" class="difflineplus">+  query.orderBy('-dascore');</span>
<a href="#l25.314"></a><span id="l25.314" class="difflineplus">+  queryExpect(query, fooWidgets, null, null, verify_widget_order_and_stashing);</span>
<a href="#l25.315"></a><span id="l25.315" class="difflineplus">+}</span>
<a href="#l25.316"></a><span id="l25.316" class="difflineplus">+</span>
<a href="#l25.317"></a><span id="l25.317" class="difflineplus">+function test_search_ranking_idiom_score() {</span>
<a href="#l25.318"></a><span id="l25.318" class="difflineplus">+  let query = Gloda.newQuery(WidgetNoun.id, {</span>
<a href="#l25.319"></a><span id="l25.319" class="difflineplus">+    explicitSQL: WIDGET_FULLTEXT_QUERY_EXPLICIT_SQL,</span>
<a href="#l25.320"></a><span id="l25.320" class="difflineplus">+    // osets becomes 0-based column number 7</span>
<a href="#l25.321"></a><span id="l25.321" class="difflineplus">+    // dascore becomes 0-based column number 8</span>
<a href="#l25.322"></a><span id="l25.322" class="difflineplus">+    outerWrapColumns: [DASCORE_SQL_SNIPPET + &quot; AS dascore&quot;,</span>
<a href="#l25.323"></a><span id="l25.323" class="difflineplus">+                       SCORE_SQL_SNIPPET + &quot; AS dabore&quot;, &quot;dateCol&quot;],</span>
<a href="#l25.324"></a><span id="l25.324" class="difflineplus">+    // save our extra columns for analysis and debugging</span>
<a href="#l25.325"></a><span id="l25.325" class="difflineplus">+    stashColumns: [7, 8, 9, 10]</span>
<a href="#l25.326"></a><span id="l25.326" class="difflineplus">+  });</span>
<a href="#l25.327"></a><span id="l25.327" class="difflineplus">+  query.fulltextAll(&quot;bar OR baz&quot;);</span>
<a href="#l25.328"></a><span id="l25.328" class="difflineplus">+  query.orderBy('-dascore');</span>
<a href="#l25.329"></a><span id="l25.329" class="difflineplus">+  queryExpect(query, barBazWidgets, null, null, verify_widget_order_and_stashing);</span>
<a href="#l25.330"></a><span id="l25.330" class="difflineplus">+}</span>
<a href="#l25.331"></a><span id="l25.331" class="difflineplus">+</span>
<a href="#l25.332"></a><span id="l25.332" class="difflineplus">+</span>
<a href="#l25.333"></a><span id="l25.333"> /* ===== Driver ===== */</span>
<a href="#l25.334"></a><span id="l25.334"> </span>
<a href="#l25.335"></a><span id="l25.335"> var tests = [</span>
<a href="#l25.336"></a><span id="l25.336">   setup_test_noun_and_attributes,</span>
<a href="#l25.337"></a><span id="l25.337">   test_lots_of_string_constraints,</span>
<a href="#l25.338"></a><span id="l25.338" class="difflineplus">+  setup_search_ranking_idiom,</span>
<a href="#l25.339"></a><span id="l25.339" class="difflineplus">+  test_search_ranking_idiom_offsets,</span>
<a href="#l25.340"></a><span id="l25.340" class="difflineplus">+  test_search_ranking_idiom_score,</span>
<a href="#l25.341"></a><span id="l25.341"> ];</span>
<a href="#l25.342"></a><span id="l25.342"> </span>
<a href="#l25.343"></a><span id="l25.343"> function run_test() {</span>
<a href="#l25.344"></a><span id="l25.344">   // use mbox injection so we get multiple folders...</span>
<a href="#l25.345"></a><span id="l25.345">   injectMessagesUsing(INJECT_MBOX);</span>
<a href="#l25.346"></a><span id="l25.346">   glodaHelperRunTests(tests);</span>
<a href="#l25.347"></a><span id="l25.347"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_query_messages.js</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_query_messages.js</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -1,145 +1,226 @@</span>
<a href="#l26.4"></a><span id="l26.4" class="difflineminus">-/* This file tests our querying support.</span>
<a href="#l26.5"></a><span id="l26.5" class="difflineplus">+/*</span>
<a href="#l26.6"></a><span id="l26.6" class="difflineplus">+ * This file tests our querying support.  We build up a deterministic little</span>
<a href="#l26.7"></a><span id="l26.7" class="difflineplus">+ *  'world' of messages spread across multiple conversations, multiple folders</span>
<a href="#l26.8"></a><span id="l26.8" class="difflineplus">+ *  and multiple authors.  To verify expected negative results, in addition to</span>
<a href="#l26.9"></a><span id="l26.9" class="difflineplus">+ *  the 'peoples' in our world clique, we also have 'outlier' contacts that do</span>
<a href="#l26.10"></a><span id="l26.10" class="difflineplus">+ *  not communicate with the others (but are also spread across folders).</span>
<a href="#l26.11"></a><span id="l26.11" class="difflineplus">+ *</span>
<a href="#l26.12"></a><span id="l26.12" class="difflineplus">+ * This is broadly intended to test all of our query features and mechanisms</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineplus">+ *  (apart from our specialized search implementation, which is tested by</span>
<a href="#l26.14"></a><span id="l26.14" class="difflineplus">+ *  test_search_messages.js), but is probably not the place to test specific</span>
<a href="#l26.15"></a><span id="l26.15" class="difflineplus">+ *  edge-cases if they do not easily fit into the 'world' data set.</span>
<a href="#l26.16"></a><span id="l26.16" class="difflineplus">+ *</span>
<a href="#l26.17"></a><span id="l26.17" class="difflineplus">+ * I feel like having the 'world' mishmash as a data source may muddle things</span>
<a href="#l26.18"></a><span id="l26.18" class="difflineplus">+ *  more than it should, but it is hard to deny the benefit of not having to</span>
<a href="#l26.19"></a><span id="l26.19" class="difflineplus">+ *  define a bunch of message corpuses entirely specialized for each test.</span>
<a href="#l26.20"></a><span id="l26.20">  */</span>
<a href="#l26.21"></a><span id="l26.21"> </span>
<a href="#l26.22"></a><span id="l26.22"> load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l26.23"></a><span id="l26.23"> load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l26.24"></a><span id="l26.24"> </span>
<a href="#l26.25"></a><span id="l26.25"> // Create a message generator</span>
<a href="#l26.26"></a><span id="l26.26"> var msgGen = new MessageGenerator();</span>
<a href="#l26.27"></a><span id="l26.27"> // Create a message scenario generator using that message generator</span>
<a href="#l26.28"></a><span id="l26.28"> var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l26.29"></a><span id="l26.29"> </span>
<a href="#l26.30"></a><span id="l26.30"> /* ===== Populate ===== */</span>
<a href="#l26.31"></a><span id="l26.31"> var world = {</span>
<a href="#l26.32"></a><span id="l26.32">   phase: 0,</span>
<a href="#l26.33"></a><span id="l26.33" class="difflineminus">-    </span>
<a href="#l26.34"></a><span id="l26.34" class="difflineplus">+</span>
<a href="#l26.35"></a><span id="l26.35" class="difflineplus">+  // a list of tuples of [name, email] of length NUM_AUTHORS</span>
<a href="#l26.36"></a><span id="l26.36">   peoples: null,</span>
<a href="#l26.37"></a><span id="l26.37">   NUM_AUTHORS: 5,</span>
<a href="#l26.38"></a><span id="l26.38" class="difflineplus">+  // maps each author (as defined by their email address) to the list of</span>
<a href="#l26.39"></a><span id="l26.39" class="difflineplus">+  //  (synthetic) messages they have 'authored'</span>
<a href="#l26.40"></a><span id="l26.40">   authorGroups: {},</span>
<a href="#l26.41"></a><span id="l26.41" class="difflineminus">-  </span>
<a href="#l26.42"></a><span id="l26.42" class="difflineplus">+</span>
<a href="#l26.43"></a><span id="l26.43">   NUM_CONVERSATIONS: 3,</span>
<a href="#l26.44"></a><span id="l26.44" class="difflineplus">+  // the last message (so far) in each conversation</span>
<a href="#l26.45"></a><span id="l26.45">   lastMessagesInConvos: [],</span>
<a href="#l26.46"></a><span id="l26.46" class="difflineplus">+  // maps the message-id of the root message in a conversation to the list of</span>
<a href="#l26.47"></a><span id="l26.47" class="difflineplus">+  //  synthetic messages in the conversation</span>
<a href="#l26.48"></a><span id="l26.48">   conversationGroups: {},</span>
<a href="#l26.49"></a><span id="l26.49" class="difflineplus">+  // a list of lists of synthetic messages, organized by the conversation they</span>
<a href="#l26.50"></a><span id="l26.50" class="difflineplus">+  //  belong to.</span>
<a href="#l26.51"></a><span id="l26.51">   conversationLists: [],</span>
<a href="#l26.52"></a><span id="l26.52" class="difflineplus">+  // a list of gloda conversation id's, each corresponding to the entries in</span>
<a href="#l26.53"></a><span id="l26.53" class="difflineplus">+  // converastionLists.</span>
<a href="#l26.54"></a><span id="l26.54">   glodaConversationIds: [],</span>
<a href="#l26.55"></a><span id="l26.55" class="difflineminus">-  </span>
<a href="#l26.56"></a><span id="l26.56" class="difflineplus">+</span>
<a href="#l26.57"></a><span id="l26.57">   NUM_FOLDERS: 2,</span>
<a href="#l26.58"></a><span id="l26.58">   MESSAGES_PER_FOLDER: 11,</span>
<a href="#l26.59"></a><span id="l26.59" class="difflineplus">+  // a list of lists of synthetic messages, one list per folder</span>
<a href="#l26.60"></a><span id="l26.60">   folderClumps: [],</span>
<a href="#l26.61"></a><span id="l26.61" class="difflineminus">-  folderGroups: {},</span>
<a href="#l26.62"></a><span id="l26.62" class="difflineplus">+  // a list of nsIMsgFolders, with each folder containing the messages in the</span>
<a href="#l26.63"></a><span id="l26.63" class="difflineplus">+  //  corresponding list in folderClumps</span>
<a href="#l26.64"></a><span id="l26.64">   glodaFolders: [],</span>
<a href="#l26.65"></a><span id="l26.65" class="difflineminus">-  </span>
<a href="#l26.66"></a><span id="l26.66" class="difflineplus">+</span>
<a href="#l26.67"></a><span id="l26.67">   outlierAuthor: null,</span>
<a href="#l26.68"></a><span id="l26.68">   outlierFriend: null,</span>
<a href="#l26.69"></a><span id="l26.69" class="difflineminus">-  outliers: [],</span>
<a href="#l26.70"></a><span id="l26.70" class="difflineminus">-  </span>
<a href="#l26.71"></a><span id="l26.71" class="difflineplus">+</span>
<a href="#l26.72"></a><span id="l26.72" class="difflineplus">+  // messages authored by contacts in the &quot;peoples&quot; group</span>
<a href="#l26.73"></a><span id="l26.73">   peoplesMessages: [],</span>
<a href="#l26.74"></a><span id="l26.74" class="difflineplus">+  // messages authored by outlierAuthor and outlierFriend</span>
<a href="#l26.75"></a><span id="l26.75">   outlierMessages: []</span>
<a href="#l26.76"></a><span id="l26.76"> };</span>
<a href="#l26.77"></a><span id="l26.77"> </span>
<a href="#l26.78"></a><span id="l26.78"> /**</span>
<a href="#l26.79"></a><span id="l26.79" class="difflineplus">+ * Given a number, provide a unique term.  This is for the benefit of the search</span>
<a href="#l26.80"></a><span id="l26.80" class="difflineplus">+ *  logic.  This entails using a unique prefix to avoid accidental collision</span>
<a href="#l26.81"></a><span id="l26.81" class="difflineplus">+ *  with terms outside our control and then just generating unique character</span>
<a href="#l26.82"></a><span id="l26.82" class="difflineplus">+ *  strings in a vaguely base-26 style.  To avoid the porter stemmer causing odd</span>
<a href="#l26.83"></a><span id="l26.83" class="difflineplus">+ *  things to happen we actually double every numerically driven character.</span>
<a href="#l26.84"></a><span id="l26.84" class="difflineplus">+ */</span>
<a href="#l26.85"></a><span id="l26.85" class="difflineplus">+function uniqueTermGenerator(aNum) {</span>
<a href="#l26.86"></a><span id="l26.86" class="difflineplus">+  let s = 'uniq';</span>
<a href="#l26.87"></a><span id="l26.87" class="difflineplus">+  do {</span>
<a href="#l26.88"></a><span id="l26.88" class="difflineplus">+    let l = String.fromCharCode(97 + (aNum % 26));</span>
<a href="#l26.89"></a><span id="l26.89" class="difflineplus">+    s += l + l;</span>
<a href="#l26.90"></a><span id="l26.90" class="difflineplus">+    aNum = Math.floor(aNum / 26);</span>
<a href="#l26.91"></a><span id="l26.91" class="difflineplus">+  }</span>
<a href="#l26.92"></a><span id="l26.92" class="difflineplus">+  while(aNum)</span>
<a href="#l26.93"></a><span id="l26.93" class="difflineplus">+  return s;</span>
<a href="#l26.94"></a><span id="l26.94" class="difflineplus">+}</span>
<a href="#l26.95"></a><span id="l26.95" class="difflineplus">+</span>
<a href="#l26.96"></a><span id="l26.96" class="difflineplus">+const UNIQUE_OFFSET_CONV = 0;</span>
<a href="#l26.97"></a><span id="l26.97" class="difflineplus">+const UNIQUE_OFFSET_AUTHOR = 26;</span>
<a href="#l26.98"></a><span id="l26.98" class="difflineplus">+const UNIQUE_OFFSET_BODY = 0;</span>
<a href="#l26.99"></a><span id="l26.99" class="difflineplus">+const UNIQUE_OFFSET_SUBJECT = 26 * 26;</span>
<a href="#l26.100"></a><span id="l26.100" class="difflineplus">+const UNIQUE_OFFSET_ATTACHMENT = 26 * 26 * 26;</span>
<a href="#l26.101"></a><span id="l26.101" class="difflineplus">+</span>
<a href="#l26.102"></a><span id="l26.102" class="difflineplus">+/**</span>
<a href="#l26.103"></a><span id="l26.103">  * Categorize a synthetic message by conversation/folder/people in the 'world'</span>
<a href="#l26.104"></a><span id="l26.104">  *  structure.  This is then used by the test code to generate and verify query</span>
<a href="#l26.105"></a><span id="l26.105">  *  data.</span>
<a href="#l26.106"></a><span id="l26.106">  *</span>
<a href="#l26.107"></a><span id="l26.107">  * @param aSynthMessage The synthetic message.</span>
<a href="#l26.108"></a><span id="l26.108">  */</span>
<a href="#l26.109"></a><span id="l26.109"> function categorizeMessage(aSynthMessage) {</span>
<a href="#l26.110"></a><span id="l26.110">   // lump by author</span>
<a href="#l26.111"></a><span id="l26.111">   let author = aSynthMessage.fromAddress;</span>
<a href="#l26.112"></a><span id="l26.112">   if (!(author in world.authorGroups))</span>
<a href="#l26.113"></a><span id="l26.113">     world.authorGroups[author] = [];</span>
<a href="#l26.114"></a><span id="l26.114">   world.authorGroups[author].push(aSynthMessage);</span>
<a href="#l26.115"></a><span id="l26.115" class="difflineminus">-  </span>
<a href="#l26.116"></a><span id="l26.116" class="difflineplus">+</span>
<a href="#l26.117"></a><span id="l26.117">   // lump by conversation, keying off of the originator's message id</span>
<a href="#l26.118"></a><span id="l26.118">   let originator = aSynthMessage;</span>
<a href="#l26.119"></a><span id="l26.119">   while (originator.parent) {</span>
<a href="#l26.120"></a><span id="l26.120">     originator = originator.parent;</span>
<a href="#l26.121"></a><span id="l26.121">   }</span>
<a href="#l26.122"></a><span id="l26.122">   if (!(originator.messageId in world.conversationGroups))</span>
<a href="#l26.123"></a><span id="l26.123">     world.conversationGroups[originator.messageId] = [];</span>
<a href="#l26.124"></a><span id="l26.124">   world.conversationGroups[originator.messageId].push(aSynthMessage);</span>
<a href="#l26.125"></a><span id="l26.125">   world.conversationLists[aSynthMessage.iConvo].push(aSynthMessage);</span>
<a href="#l26.126"></a><span id="l26.126" class="difflineminus">-  </span>
<a href="#l26.127"></a><span id="l26.127" class="difflineplus">+</span>
<a href="#l26.128"></a><span id="l26.128">   // folder lumping happens in a big glob</span>
<a href="#l26.129"></a><span id="l26.129"> }</span>
<a href="#l26.130"></a><span id="l26.130"> </span>
<a href="#l26.131"></a><span id="l26.131"> /**</span>
<a href="#l26.132"></a><span id="l26.132">  * Generate messages in a single folder, categorizing them as we go.</span>
<a href="#l26.133"></a><span id="l26.133" class="difflineplus">+ *</span>
<a href="#l26.134"></a><span id="l26.134" class="difflineplus">+ * Key message characteristics:</span>
<a href="#l26.135"></a><span id="l26.135" class="difflineplus">+ * - Whenever a 'peoples' sends a message, they send it to all 'peoples',</span>
<a href="#l26.136"></a><span id="l26.136" class="difflineplus">+ *   including themselves.</span>
<a href="#l26.137"></a><span id="l26.137">  */</span>
<a href="#l26.138"></a><span id="l26.138"> function generateFolderMessages() {</span>
<a href="#l26.139"></a><span id="l26.139" class="difflineminus">-  let messages = [];</span>
<a href="#l26.140"></a><span id="l26.140" class="difflineminus">-  </span>
<a href="#l26.141"></a><span id="l26.141" class="difflineplus">+  let messages = [], smsg;</span>
<a href="#l26.142"></a><span id="l26.142" class="difflineplus">+</span>
<a href="#l26.143"></a><span id="l26.143">   let iAuthor = 0;</span>
<a href="#l26.144"></a><span id="l26.144">   for (let iMessage = 0; iMessage &lt; world.MESSAGES_PER_FOLDER; iMessage++) {</span>
<a href="#l26.145"></a><span id="l26.145">     let iConvo = iMessage % world.NUM_CONVERSATIONS;</span>
<a href="#l26.146"></a><span id="l26.146" class="difflineminus">-    let smsg = msgGen.makeMessage({</span>
<a href="#l26.147"></a><span id="l26.147" class="difflineminus">-      inReplyTo: world.lastMessagesInConvos[iConvo]</span>
<a href="#l26.148"></a><span id="l26.148" class="difflineminus">-    });</span>
<a href="#l26.149"></a><span id="l26.149" class="difflineplus">+</span>
<a href="#l26.150"></a><span id="l26.150">     // we need missing messages to create ghosts, so periodically add an extra</span>
<a href="#l26.151"></a><span id="l26.151" class="difflineminus">-    //  unknown into the equation</span>
<a href="#l26.152"></a><span id="l26.152" class="difflineminus">-    if ((iMessage % 3) == 0)</span>
<a href="#l26.153"></a><span id="l26.153" class="difflineplus">+    //  unknown into the equation.  we do this prior to the below step because</span>
<a href="#l26.154"></a><span id="l26.154" class="difflineplus">+    //  then we don't hose up all the fancy body creation the next step does</span>
<a href="#l26.155"></a><span id="l26.155" class="difflineplus">+    if ((iMessage % 3) == 1)</span>
<a href="#l26.156"></a><span id="l26.156">       smsg = msgGen.makeMessage({inReplyTo: smsg});</span>
<a href="#l26.157"></a><span id="l26.157" class="difflineminus">-    </span>
<a href="#l26.158"></a><span id="l26.158" class="difflineplus">+</span>
<a href="#l26.159"></a><span id="l26.159" class="difflineplus">+    let convUniqueSubject = uniqueTermGenerator(</span>
<a href="#l26.160"></a><span id="l26.160" class="difflineplus">+      UNIQUE_OFFSET_SUBJECT + UNIQUE_OFFSET_CONV + iConvo);</span>
<a href="#l26.161"></a><span id="l26.161" class="difflineplus">+    let convUniqueBody = uniqueTermGenerator(</span>
<a href="#l26.162"></a><span id="l26.162" class="difflineplus">+      UNIQUE_OFFSET_BODY + UNIQUE_OFFSET_CONV + iConvo);</span>
<a href="#l26.163"></a><span id="l26.163" class="difflineplus">+    let authorUniqueBody = uniqueTermGenerator(</span>
<a href="#l26.164"></a><span id="l26.164" class="difflineplus">+      UNIQUE_OFFSET_BODY + UNIQUE_OFFSET_AUTHOR + iAuthor);</span>
<a href="#l26.165"></a><span id="l26.165" class="difflineplus">+    let convUniqueAttachment = uniqueTermGenerator(</span>
<a href="#l26.166"></a><span id="l26.166" class="difflineplus">+      UNIQUE_OFFSET_ATTACHMENT + UNIQUE_OFFSET_CONV + iConvo);</span>
<a href="#l26.167"></a><span id="l26.167" class="difflineplus">+    smsg = msgGen.makeMessage({</span>
<a href="#l26.168"></a><span id="l26.168" class="difflineplus">+      inReplyTo: world.lastMessagesInConvos[iConvo],</span>
<a href="#l26.169"></a><span id="l26.169" class="difflineplus">+      // note that the reply-logic will ignore our subject, luckily that does</span>
<a href="#l26.170"></a><span id="l26.170" class="difflineplus">+      //  not matter! (since it will just copy the subject)</span>
<a href="#l26.171"></a><span id="l26.171" class="difflineplus">+      subject: convUniqueSubject,</span>
<a href="#l26.172"></a><span id="l26.172" class="difflineplus">+      body: {</span>
<a href="#l26.173"></a><span id="l26.173" class="difflineplus">+        body: convUniqueBody + &quot; &quot; + authorUniqueBody,</span>
<a href="#l26.174"></a><span id="l26.174" class="difflineplus">+      },</span>
<a href="#l26.175"></a><span id="l26.175" class="difflineplus">+      attachments: [</span>
<a href="#l26.176"></a><span id="l26.176" class="difflineplus">+        {</span>
<a href="#l26.177"></a><span id="l26.177" class="difflineplus">+          filename: convUniqueAttachment + '.conv',</span>
<a href="#l26.178"></a><span id="l26.178" class="difflineplus">+          body: 'content does not matter. only life matters.',</span>
<a href="#l26.179"></a><span id="l26.179" class="difflineplus">+          contentType: 'application/x-test',</span>
<a href="#l26.180"></a><span id="l26.180" class="difflineplus">+        }</span>
<a href="#l26.181"></a><span id="l26.181" class="difflineplus">+      ],</span>
<a href="#l26.182"></a><span id="l26.182" class="difflineplus">+    });</span>
<a href="#l26.183"></a><span id="l26.183" class="difflineplus">+</span>
<a href="#l26.184"></a><span id="l26.184" class="difflineplus">+</span>
<a href="#l26.185"></a><span id="l26.185">     // makeMessage is not exceedingly clever right now, we need to overwrite</span>
<a href="#l26.186"></a><span id="l26.186">     //  From and To...</span>
<a href="#l26.187"></a><span id="l26.187">     smsg.from = world.peoples[iAuthor];</span>
<a href="#l26.188"></a><span id="l26.188">     iAuthor = (iAuthor + iConvo + 1) % world.NUM_AUTHORS;</span>
<a href="#l26.189"></a><span id="l26.189">     // so, everyone is talking to everyone for this stuff</span>
<a href="#l26.190"></a><span id="l26.190">     smsg.to = world.peoples;</span>
<a href="#l26.191"></a><span id="l26.191">     world.lastMessagesInConvos[iConvo] = smsg;</span>
<a href="#l26.192"></a><span id="l26.192">     // simplify categorizeMessage and glodaInfoStasher's life</span>
<a href="#l26.193"></a><span id="l26.193">     smsg.iConvo = iConvo;</span>
<a href="#l26.194"></a><span id="l26.194" class="difflineminus">-    </span>
<a href="#l26.195"></a><span id="l26.195" class="difflineplus">+</span>
<a href="#l26.196"></a><span id="l26.196">     categorizeMessage(smsg);</span>
<a href="#l26.197"></a><span id="l26.197">     messages.push(smsg);</span>
<a href="#l26.198"></a><span id="l26.198">     world.peoplesMessages.push(smsg);</span>
<a href="#l26.199"></a><span id="l26.199">   }</span>
<a href="#l26.200"></a><span id="l26.200" class="difflineminus">-  </span>
<a href="#l26.201"></a><span id="l26.201" class="difflineplus">+</span>
<a href="#l26.202"></a><span id="l26.202">   smsg = msgGen.makeMessage();</span>
<a href="#l26.203"></a><span id="l26.203">   smsg.from = world.outlierAuthor;</span>
<a href="#l26.204"></a><span id="l26.204">   smsg.to = [world.outlierFriend];</span>
<a href="#l26.205"></a><span id="l26.205">   // do not lump it</span>
<a href="#l26.206"></a><span id="l26.206">   messages.push(smsg);</span>
<a href="#l26.207"></a><span id="l26.207">   world.outlierMessages.push(smsg);</span>
<a href="#l26.208"></a><span id="l26.208" class="difflineminus">-  </span>
<a href="#l26.209"></a><span id="l26.209" class="difflineplus">+</span>
<a href="#l26.210"></a><span id="l26.210">   world.folderClumps.push(messages);</span>
<a href="#l26.211"></a><span id="l26.211" class="difflineminus">-  </span>
<a href="#l26.212"></a><span id="l26.212" class="difflineplus">+</span>
<a href="#l26.213"></a><span id="l26.213">   return messages;</span>
<a href="#l26.214"></a><span id="l26.214"> }</span>
<a href="#l26.215"></a><span id="l26.215"> </span>
<a href="#l26.216"></a><span id="l26.216" class="difflineminus">-/** </span>
<a href="#l26.217"></a><span id="l26.217" class="difflineplus">+/**</span>
<a href="#l26.218"></a><span id="l26.218">  * To save ourselves some lookup trouble, pretend to be a verification</span>
<a href="#l26.219"></a><span id="l26.219">  *  function so we get easy access to the gloda translations of the messages so</span>
<a href="#l26.220"></a><span id="l26.220" class="difflineminus">- *  we can cram this in various places. </span>
<a href="#l26.221"></a><span id="l26.221" class="difflineplus">+ *  we can cram this in various places.</span>
<a href="#l26.222"></a><span id="l26.222">  */</span>
<a href="#l26.223"></a><span id="l26.223"> function glodaInfoStasher(aSynthMessage, aGlodaMessage) {</span>
<a href="#l26.224"></a><span id="l26.224">   if (aSynthMessage.iConvo !== undefined)</span>
<a href="#l26.225"></a><span id="l26.225">     world.glodaConversationIds[aSynthMessage.iConvo] =</span>
<a href="#l26.226"></a><span id="l26.226">       aGlodaMessage.conversation.id;</span>
<a href="#l26.227"></a><span id="l26.227">   if (world.glodaFolders.length &lt;= world.phase)</span>
<a href="#l26.228"></a><span id="l26.228">     world.glodaFolders.push(aGlodaMessage.folder);</span>
<a href="#l26.229"></a><span id="l26.229"> }</span>
<a href="#l26.230"></a><span id="l26.230"> </span>
<a href="#l26.231"></a><span id="l26.231"> // first, we must populate our message store with delicious messages.</span>
<a href="#l26.232"></a><span id="l26.232"> function setup_populate() {</span>
<a href="#l26.233"></a><span id="l26.233">   world.glodaHolderCollection = Gloda.explicitCollection(Gloda.NOUN_MESSAGE,</span>
<a href="#l26.234"></a><span id="l26.234">     []);</span>
<a href="#l26.235"></a><span id="l26.235" class="difflineminus">-  </span>
<a href="#l26.236"></a><span id="l26.236" class="difflineplus">+</span>
<a href="#l26.237"></a><span id="l26.237">   world.peoples = msgGen.makeNamesAndAddresses(world.NUM_AUTHORS);</span>
<a href="#l26.238"></a><span id="l26.238">   world.outlierAuthor = msgGen.makeNameAndAddress();</span>
<a href="#l26.239"></a><span id="l26.239">   world.outlierFriend = msgGen.makeNameAndAddress();</span>
<a href="#l26.240"></a><span id="l26.240" class="difflineplus">+  // set up the per-conversation values with blanks initially</span>
<a href="#l26.241"></a><span id="l26.241">   for (let iConvo = 0; iConvo &lt; world.NUM_CONVERSATIONS; iConvo++) {</span>
<a href="#l26.242"></a><span id="l26.242">     world.lastMessagesInConvos.push(null);</span>
<a href="#l26.243"></a><span id="l26.243">     world.conversationLists.push([]);</span>
<a href="#l26.244"></a><span id="l26.244">     world.glodaConversationIds.push(null);</span>
<a href="#l26.245"></a><span id="l26.245">   }</span>
<a href="#l26.246"></a><span id="l26.246" class="difflineminus">-  </span>
<a href="#l26.247"></a><span id="l26.247" class="difflineplus">+</span>
<a href="#l26.248"></a><span id="l26.248">   indexMessages(generateFolderMessages(), glodaInfoStasher,</span>
<a href="#l26.249"></a><span id="l26.249">                 setup_populate_phase_two);</span>
<a href="#l26.250"></a><span id="l26.250"> }</span>
<a href="#l26.251"></a><span id="l26.251"> </span>
<a href="#l26.252"></a><span id="l26.252"> function setup_populate_phase_two() {</span>
<a href="#l26.253"></a><span id="l26.253">   world.phase++;</span>
<a href="#l26.254"></a><span id="l26.254">   indexMessages(generateFolderMessages(), glodaInfoStasher, next_test);</span>
<a href="#l26.255"></a><span id="l26.255"> }</span>
<a href="#l26.256"></a><span id="l26.256" class="difflineat">@@ -148,144 +229,183 @@ function setup_populate_phase_two() {</span>
<a href="#l26.257"></a><span id="l26.257"> </span>
<a href="#l26.258"></a><span id="l26.258"> /* === messages === */</span>
<a href="#l26.259"></a><span id="l26.259"> </span>
<a href="#l26.260"></a><span id="l26.260"> /**</span>
<a href="#l26.261"></a><span id="l26.261">  * Takes a list of mutually exclusive queries and a list of the resulting</span>
<a href="#l26.262"></a><span id="l26.262">  *  collections and ensures that the collections from one query do not pass the</span>
<a href="#l26.263"></a><span id="l26.263">  *  query.test() method of one of the other queries.  To restate, the queries</span>
<a href="#l26.264"></a><span id="l26.264">  *  must not have any overlapping results, or we will get angry without</span>
<a href="#l26.265"></a><span id="l26.265" class="difflineminus">- *  justification. </span>
<a href="#l26.266"></a><span id="l26.266" class="difflineplus">+ *  justification.</span>
<a href="#l26.267"></a><span id="l26.267">  */</span>
<a href="#l26.268"></a><span id="l26.268"> function verify_nonMatches(aQueries, aCollections) {</span>
<a href="#l26.269"></a><span id="l26.269">   for (let i = 0; i &lt; aCollections.length; i++) {</span>
<a href="#l26.270"></a><span id="l26.270">     let testQuery = aQueries[i];</span>
<a href="#l26.271"></a><span id="l26.271">     let nonmatches =</span>
<a href="#l26.272"></a><span id="l26.272">       aCollections[(i+1) % aCollections.length].items;</span>
<a href="#l26.273"></a><span id="l26.273" class="difflineminus">-    </span>
<a href="#l26.274"></a><span id="l26.274" class="difflineplus">+</span>
<a href="#l26.275"></a><span id="l26.275">     for each (let [, item] in Iterator(nonmatches)) {</span>
<a href="#l26.276"></a><span id="l26.276">       if (testQuery.test(item)) {</span>
<a href="#l26.277"></a><span id="l26.277">         ddumpObject(item, &quot;item&quot;, 0);</span>
<a href="#l26.278"></a><span id="l26.278">         ddumpObject(testQuery._constraints, &quot;constraints&quot;, 2);</span>
<a href="#l26.279"></a><span id="l26.279">         do_throw(&quot;Something should not match query.test(), but it does: &quot; +</span>
<a href="#l26.280"></a><span id="l26.280">                  item);</span>
<a href="#l26.281"></a><span id="l26.281">       }</span>
<a href="#l26.282"></a><span id="l26.282">     }</span>
<a href="#l26.283"></a><span id="l26.283">   }</span>
<a href="#l26.284"></a><span id="l26.284"> }</span>
<a href="#l26.285"></a><span id="l26.285"> </span>
<a href="#l26.286"></a><span id="l26.286"> var ts_convNum = 0;</span>
<a href="#l26.287"></a><span id="l26.287" class="difflineplus">+/* preserved state for the non-match testing performed by</span>
<a href="#l26.288"></a><span id="l26.288" class="difflineplus">+ *  test_query_messages_by_conversation_nonmatches.</span>
<a href="#l26.289"></a><span id="l26.289" class="difflineplus">+ */</span>
<a href="#l26.290"></a><span id="l26.290"> var ts_convQueries = [];</span>
<a href="#l26.291"></a><span id="l26.291"> var ts_convCollections = [];</span>
<a href="#l26.292"></a><span id="l26.292" class="difflineplus">+/**</span>
<a href="#l26.293"></a><span id="l26.293" class="difflineplus">+ * Query conversations by gloda conversation-id, saving the queries and</span>
<a href="#l26.294"></a><span id="l26.294" class="difflineplus">+ *  resulting collections in ts_convQueries and ts_convCollections for the</span>
<a href="#l26.295"></a><span id="l26.295" class="difflineplus">+ *  use of test_query_messages_by_conversation_nonmatches who verifies the</span>
<a href="#l26.296"></a><span id="l26.296" class="difflineplus">+ *  query.test() logic doesn't match on things it should not match on.</span>
<a href="#l26.297"></a><span id="l26.297" class="difflineplus">+ *</span>
<a href="#l26.298"></a><span id="l26.298" class="difflineplus">+ * @tests gloda.noun.message.attr.conversation</span>
<a href="#l26.299"></a><span id="l26.299" class="difflineplus">+ * @tests gloda.datastore.sqlgen.kConstraintIn</span>
<a href="#l26.300"></a><span id="l26.300" class="difflineplus">+ */</span>
<a href="#l26.301"></a><span id="l26.301"> function test_query_messages_by_conversation() {</span>
<a href="#l26.302"></a><span id="l26.302">   let convNum = ts_convNum++;</span>
<a href="#l26.303"></a><span id="l26.303">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l26.304"></a><span id="l26.304">   query.conversation(world.glodaConversationIds[convNum]);</span>
<a href="#l26.305"></a><span id="l26.305" class="difflineminus">-  </span>
<a href="#l26.306"></a><span id="l26.306" class="difflineplus">+</span>
<a href="#l26.307"></a><span id="l26.307">   ts_convQueries.push(query);</span>
<a href="#l26.308"></a><span id="l26.308">   ts_convCollections.push(queryExpect(query, world.conversationLists[convNum]));</span>
<a href="#l26.309"></a><span id="l26.309">   // queryExpect calls next_test</span>
<a href="#l26.310"></a><span id="l26.310"> }</span>
<a href="#l26.311"></a><span id="l26.311"> </span>
<a href="#l26.312"></a><span id="l26.312" class="difflineplus">+/**</span>
<a href="#l26.313"></a><span id="l26.313" class="difflineplus">+ * @tests gloda.query.test.kConstraintIn</span>
<a href="#l26.314"></a><span id="l26.314" class="difflineplus">+ */</span>
<a href="#l26.315"></a><span id="l26.315"> function test_query_messages_by_conversation_nonmatches() {</span>
<a href="#l26.316"></a><span id="l26.316">   verify_nonMatches(ts_convQueries, ts_convCollections);</span>
<a href="#l26.317"></a><span id="l26.317">   next_test();</span>
<a href="#l26.318"></a><span id="l26.318"> }</span>
<a href="#l26.319"></a><span id="l26.319"> </span>
<a href="#l26.320"></a><span id="l26.320"> var ts_folderNum = 0;</span>
<a href="#l26.321"></a><span id="l26.321"> var ts_folderQueries = [];</span>
<a href="#l26.322"></a><span id="l26.322"> var ts_folderCollections = [];</span>
<a href="#l26.323"></a><span id="l26.323" class="difflineplus">+/**</span>
<a href="#l26.324"></a><span id="l26.324" class="difflineplus">+ * @tests gloda.noun.message.attr.folder</span>
<a href="#l26.325"></a><span id="l26.325" class="difflineplus">+ * @tests gloda.datastore.sqlgen.kConstraintIn</span>
<a href="#l26.326"></a><span id="l26.326" class="difflineplus">+ */</span>
<a href="#l26.327"></a><span id="l26.327"> function test_query_messages_by_folder() {</span>
<a href="#l26.328"></a><span id="l26.328">   let folderNum = ts_folderNum++;</span>
<a href="#l26.329"></a><span id="l26.329">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l26.330"></a><span id="l26.330">   query.folder(world.glodaFolders[folderNum]);</span>
<a href="#l26.331"></a><span id="l26.331" class="difflineminus">-  </span>
<a href="#l26.332"></a><span id="l26.332" class="difflineplus">+</span>
<a href="#l26.333"></a><span id="l26.333">   ts_folderQueries.push(query);</span>
<a href="#l26.334"></a><span id="l26.334">   ts_folderCollections.push(queryExpect(query, world.folderClumps[folderNum]));</span>
<a href="#l26.335"></a><span id="l26.335">   // queryExpect calls next_test</span>
<a href="#l26.336"></a><span id="l26.336"> }</span>
<a href="#l26.337"></a><span id="l26.337"> </span>
<a href="#l26.338"></a><span id="l26.338" class="difflineplus">+/**</span>
<a href="#l26.339"></a><span id="l26.339" class="difflineplus">+ * @tests gloda.query.test.kConstraintIn</span>
<a href="#l26.340"></a><span id="l26.340" class="difflineplus">+ */</span>
<a href="#l26.341"></a><span id="l26.341"> function test_query_messages_by_folder_nonmatches() {</span>
<a href="#l26.342"></a><span id="l26.342">   verify_nonMatches(ts_folderQueries, ts_folderCollections);</span>
<a href="#l26.343"></a><span id="l26.343">   next_test();</span>
<a href="#l26.344"></a><span id="l26.344"> }</span>
<a href="#l26.345"></a><span id="l26.345"> </span>
<a href="#l26.346"></a><span id="l26.346"> /**</span>
<a href="#l26.347"></a><span id="l26.347" class="difflineminus">- * @tests Gloda.getMessageCollectionForHeader</span>
<a href="#l26.348"></a><span id="l26.348" class="difflineplus">+ * @tests Gloda.ns.getMessageCollectionForHeader()</span>
<a href="#l26.349"></a><span id="l26.349">  */</span>
<a href="#l26.350"></a><span id="l26.350"> function test_get_message_for_header() {</span>
<a href="#l26.351"></a><span id="l26.351">   // pick an arbitrary message</span>
<a href="#l26.352"></a><span id="l26.352">   let glodaMessage = ts_convCollections[1].items[0];</span>
<a href="#l26.353"></a><span id="l26.353">   // find the synthetic message that matches (ordering must not be assumed)</span>
<a href="#l26.354"></a><span id="l26.354">   let synthMessage = [sm for each (sm in world.conversationLists[1])</span>
<a href="#l26.355"></a><span id="l26.355">                       if (sm.messageId == glodaMessage.headerMessageID)][0];</span>
<a href="#l26.356"></a><span id="l26.356">   queryExpect({queryFunc: Gloda.getMessageCollectionForHeader,</span>
<a href="#l26.357"></a><span id="l26.357">                queryThis: Gloda,</span>
<a href="#l26.358"></a><span id="l26.358">                args: [glodaMessage.folderMessage], nounId: Gloda.NOUN_MESSAGE},</span>
<a href="#l26.359"></a><span id="l26.359">               [synthMessage]);</span>
<a href="#l26.360"></a><span id="l26.360">   // queryExpect calls next_test</span>
<a href="#l26.361"></a><span id="l26.361"> }</span>
<a href="#l26.362"></a><span id="l26.362"> </span>
<a href="#l26.363"></a><span id="l26.363"> /**</span>
<a href="#l26.364"></a><span id="l26.364" class="difflineminus">- * @tests Gloda.getMessageCollectionForHeaders</span>
<a href="#l26.365"></a><span id="l26.365" class="difflineplus">+ * @tests Gloda.ns.getMessageCollectionForHeaders()</span>
<a href="#l26.366"></a><span id="l26.366">  */</span>
<a href="#l26.367"></a><span id="l26.367"> function test_get_messages_for_headers() {</span>
<a href="#l26.368"></a><span id="l26.368">   let messageCollection = ts_convCollections[0];</span>
<a href="#l26.369"></a><span id="l26.369">   let headers = [m.folderMessage for each (m in messageCollection.items)];</span>
<a href="#l26.370"></a><span id="l26.370">   queryExpect({queryFunc: Gloda.getMessageCollectionForHeaders,</span>
<a href="#l26.371"></a><span id="l26.371">                queryThis: Gloda,</span>
<a href="#l26.372"></a><span id="l26.372">                args: [headers], nounId: Gloda.NOUN_MESSAGE},</span>
<a href="#l26.373"></a><span id="l26.373">               world.conversationLists[0]);</span>
<a href="#l26.374"></a><span id="l26.374">   // queryExpect calls next_test</span>
<a href="#l26.375"></a><span id="l26.375"> }</span>
<a href="#l26.376"></a><span id="l26.376"> </span>
<a href="#l26.377"></a><span id="l26.377"> // at this point we go run the identity and contact tests for side-effects</span>
<a href="#l26.378"></a><span id="l26.378"> </span>
<a href="#l26.379"></a><span id="l26.379"> var ts_messageIdentityQueries = [];</span>
<a href="#l26.380"></a><span id="l26.380"> var ts_messageIdentityCollections = [];</span>
<a href="#l26.381"></a><span id="l26.381" class="difflineplus">+/**</span>
<a href="#l26.382"></a><span id="l26.382" class="difflineplus">+ * @tests gloda.noun.message.attr.involves</span>
<a href="#l26.383"></a><span id="l26.383" class="difflineplus">+ * @tests gloda.datastore.sqlgen.kConstraintIn</span>
<a href="#l26.384"></a><span id="l26.384" class="difflineplus">+ */</span>
<a href="#l26.385"></a><span id="l26.385"> function test_query_messages_by_identity_peoples() {</span>
<a href="#l26.386"></a><span id="l26.386">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l26.387"></a><span id="l26.387">   query.involves(peoplesIdentityCollection.items[0]);</span>
<a href="#l26.388"></a><span id="l26.388" class="difflineminus">-  </span>
<a href="#l26.389"></a><span id="l26.389" class="difflineplus">+</span>
<a href="#l26.390"></a><span id="l26.390">   ts_messageIdentityQueries.push(query);</span>
<a href="#l26.391"></a><span id="l26.391">   ts_messageIdentityCollections.push(queryExpect(query, world.peoplesMessages));</span>
<a href="#l26.392"></a><span id="l26.392">   // queryExpect calls next_test</span>
<a href="#l26.393"></a><span id="l26.393"> }</span>
<a href="#l26.394"></a><span id="l26.394"> </span>
<a href="#l26.395"></a><span id="l26.395" class="difflineplus">+/**</span>
<a href="#l26.396"></a><span id="l26.396" class="difflineplus">+ * @tests gloda.noun.message.attr.involves</span>
<a href="#l26.397"></a><span id="l26.397" class="difflineplus">+ */</span>
<a href="#l26.398"></a><span id="l26.398"> function test_query_messages_by_identity_outlier() {</span>
<a href="#l26.399"></a><span id="l26.399">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l26.400"></a><span id="l26.400">   query.involves(outlierIdentityCollection.items[0]);</span>
<a href="#l26.401"></a><span id="l26.401">   // this also tests our ability to have two intersecting constraints! hooray!</span>
<a href="#l26.402"></a><span id="l26.402">   query.involves(outlierIdentityCollection.items[1]);</span>
<a href="#l26.403"></a><span id="l26.403" class="difflineminus">-  </span>
<a href="#l26.404"></a><span id="l26.404" class="difflineplus">+</span>
<a href="#l26.405"></a><span id="l26.405">   ts_messageIdentityQueries.push(query);</span>
<a href="#l26.406"></a><span id="l26.406">   ts_messageIdentityCollections.push(queryExpect(query, world.outlierMessages));</span>
<a href="#l26.407"></a><span id="l26.407">   // queryExpect calls next_test</span>
<a href="#l26.408"></a><span id="l26.408"> }</span>
<a href="#l26.409"></a><span id="l26.409"> </span>
<a href="#l26.410"></a><span id="l26.410" class="difflineplus">+/**</span>
<a href="#l26.411"></a><span id="l26.411" class="difflineplus">+ * @tests gloda.query.test.kConstraintIn</span>
<a href="#l26.412"></a><span id="l26.412" class="difflineplus">+ */</span>
<a href="#l26.413"></a><span id="l26.413"> function test_query_messages_by_identity_nonmatches() {</span>
<a href="#l26.414"></a><span id="l26.414">   verify_nonMatches(ts_messageIdentityQueries, ts_messageIdentityCollections);</span>
<a href="#l26.415"></a><span id="l26.415">   next_test();</span>
<a href="#l26.416"></a><span id="l26.416"> }</span>
<a href="#l26.417"></a><span id="l26.417"> </span>
<a href="#l26.418"></a><span id="l26.418"> function test_query_messages_by_contact() {</span>
<a href="#l26.419"></a><span id="l26.419">   // IOU</span>
<a href="#l26.420"></a><span id="l26.420">   next_test();</span>
<a href="#l26.421"></a><span id="l26.421"> }</span>
<a href="#l26.422"></a><span id="l26.422"> </span>
<a href="#l26.423"></a><span id="l26.423"> var ts_messagesDateQuery;</span>
<a href="#l26.424"></a><span id="l26.424" class="difflineplus">+/**</span>
<a href="#l26.425"></a><span id="l26.425" class="difflineplus">+ * @tests gloda.noun.message.attr.date</span>
<a href="#l26.426"></a><span id="l26.426" class="difflineplus">+ * @tests gloda.datastore.sqlgen.kConstraintRanges</span>
<a href="#l26.427"></a><span id="l26.427" class="difflineplus">+ */</span>
<a href="#l26.428"></a><span id="l26.428"> function test_query_messages_by_date() {</span>
<a href="#l26.429"></a><span id="l26.429">   ts_messagesDateQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l26.430"></a><span id="l26.430">   // we are clearly relying on knowing the generation sequence here,</span>
<a href="#l26.431"></a><span id="l26.431">   //  fuggedaboutit</span>
<a href="#l26.432"></a><span id="l26.432">   ts_messagesDateQuery.dateRange([world.peoplesMessages[1].date,</span>
<a href="#l26.433"></a><span id="l26.433">                                   world.peoplesMessages[2].date]);</span>
<a href="#l26.434"></a><span id="l26.434">   queryExpect(ts_messagesDateQuery, world.peoplesMessages.slice(1, 3));</span>
<a href="#l26.435"></a><span id="l26.435"> }</span>
<a href="#l26.436"></a><span id="l26.436"> </span>
<a href="#l26.437"></a><span id="l26.437" class="difflineplus">+/**</span>
<a href="#l26.438"></a><span id="l26.438" class="difflineplus">+ * @tests gloda.query.test.kConstraintRanges</span>
<a href="#l26.439"></a><span id="l26.439" class="difflineplus">+ */</span>
<a href="#l26.440"></a><span id="l26.440"> function test_query_messages_by_date_nonmatches() {</span>
<a href="#l26.441"></a><span id="l26.441">   if (ts_messagesDateQuery.test(world.peoplesMessages[0]) ||</span>
<a href="#l26.442"></a><span id="l26.442">       ts_messagesDateQuery.test(world.peoplesMessages[3])) {</span>
<a href="#l26.443"></a><span id="l26.443">     do_throw(&quot;The date testing mechanism is busted.&quot;);</span>
<a href="#l26.444"></a><span id="l26.444">   }</span>
<a href="#l26.445"></a><span id="l26.445">   next_test();</span>
<a href="#l26.446"></a><span id="l26.446"> }</span>
<a href="#l26.447"></a><span id="l26.447"> </span>
<a href="#l26.448"></a><span id="l26.448" class="difflineat">@@ -298,43 +418,148 @@ function test_query_contacts_by_populari</span>
<a href="#l26.449"></a><span id="l26.449"> </span>
<a href="#l26.450"></a><span id="l26.450"> /* === identities === */</span>
<a href="#l26.451"></a><span id="l26.451"> </span>
<a href="#l26.452"></a><span id="l26.452"> /* ===== Text-based queries ===== */</span>
<a href="#l26.453"></a><span id="l26.453"> </span>
<a href="#l26.454"></a><span id="l26.454"> /* === conversations === */</span>
<a href="#l26.455"></a><span id="l26.455"> </span>
<a href="#l26.456"></a><span id="l26.456"> function test_query_conversations_by_subject_text() {</span>
<a href="#l26.457"></a><span id="l26.457" class="difflineminus">-  // IOU</span>
<a href="#l26.458"></a><span id="l26.458">   next_test();</span>
<a href="#l26.459"></a><span id="l26.459"> }</span>
<a href="#l26.460"></a><span id="l26.460"> </span>
<a href="#l26.461"></a><span id="l26.461"> /* === messages === */</span>
<a href="#l26.462"></a><span id="l26.462"> </span>
<a href="#l26.463"></a><span id="l26.463" class="difflineplus">+/**</span>
<a href="#l26.464"></a><span id="l26.464" class="difflineplus">+ * Test subject searching using the conversation unique subject term.</span>
<a href="#l26.465"></a><span id="l26.465" class="difflineplus">+ *</span>
<a href="#l26.466"></a><span id="l26.466" class="difflineplus">+ * @tests gloda.noun.message.attr.subjectMatches</span>
<a href="#l26.467"></a><span id="l26.467" class="difflineplus">+ * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l26.468"></a><span id="l26.468" class="difflineplus">+ */</span>
<a href="#l26.469"></a><span id="l26.469" class="difflineplus">+function test_query_messages_by_subject_text() {</span>
<a href="#l26.470"></a><span id="l26.470" class="difflineplus">+  // we only need to use one conversation</span>
<a href="#l26.471"></a><span id="l26.471" class="difflineplus">+  let convNum = 0;</span>
<a href="#l26.472"></a><span id="l26.472" class="difflineplus">+dump(&quot;convNum: &quot; + convNum + &quot; blah: &quot; + world.conversationLists[convNum] + &quot;\n&quot;);</span>
<a href="#l26.473"></a><span id="l26.473" class="difflineplus">+  let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l26.474"></a><span id="l26.474" class="difflineplus">+  let convSubjectTerm = uniqueTermGenerator(</span>
<a href="#l26.475"></a><span id="l26.475" class="difflineplus">+    UNIQUE_OFFSET_SUBJECT + UNIQUE_OFFSET_CONV + convNum);</span>
<a href="#l26.476"></a><span id="l26.476" class="difflineplus">+  query.subjectMatches(convSubjectTerm);</span>
<a href="#l26.477"></a><span id="l26.477" class="difflineplus">+  queryExpect(query, world.conversationLists[convNum]); // calls next_test</span>
<a href="#l26.478"></a><span id="l26.478" class="difflineplus">+}</span>
<a href="#l26.479"></a><span id="l26.479" class="difflineplus">+</span>
<a href="#l26.480"></a><span id="l26.480" class="difflineplus">+/**</span>
<a href="#l26.481"></a><span id="l26.481" class="difflineplus">+ * Test body searching using the conversation unique body term.</span>
<a href="#l26.482"></a><span id="l26.482" class="difflineplus">+ *</span>
<a href="#l26.483"></a><span id="l26.483" class="difflineplus">+ * @tests gloda.noun.message.attr.bodyMatches</span>
<a href="#l26.484"></a><span id="l26.484" class="difflineplus">+ * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l26.485"></a><span id="l26.485" class="difflineplus">+ */</span>
<a href="#l26.486"></a><span id="l26.486"> function test_query_messages_by_body_text() {</span>
<a href="#l26.487"></a><span id="l26.487" class="difflineminus">-  // IOU</span>
<a href="#l26.488"></a><span id="l26.488" class="difflineminus">-  next_test();</span>
<a href="#l26.489"></a><span id="l26.489" class="difflineplus">+  // we only need to use one conversation</span>
<a href="#l26.490"></a><span id="l26.490" class="difflineplus">+  let convNum = 0;</span>
<a href="#l26.491"></a><span id="l26.491" class="difflineplus">+  let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l26.492"></a><span id="l26.492" class="difflineplus">+  let convBodyTerm = uniqueTermGenerator(</span>
<a href="#l26.493"></a><span id="l26.493" class="difflineplus">+    UNIQUE_OFFSET_BODY + UNIQUE_OFFSET_CONV + convNum);</span>
<a href="#l26.494"></a><span id="l26.494" class="difflineplus">+  query.bodyMatches(convBodyTerm);</span>
<a href="#l26.495"></a><span id="l26.495" class="difflineplus">+  queryExpect(query, world.conversationLists[convNum]); // calls next_test</span>
<a href="#l26.496"></a><span id="l26.496" class="difflineplus">+}</span>
<a href="#l26.497"></a><span id="l26.497" class="difflineplus">+</span>
<a href="#l26.498"></a><span id="l26.498" class="difflineplus">+/**</span>
<a href="#l26.499"></a><span id="l26.499" class="difflineplus">+ * Test attachment name searching using the conversation unique attachment term.</span>
<a href="#l26.500"></a><span id="l26.500" class="difflineplus">+ *</span>
<a href="#l26.501"></a><span id="l26.501" class="difflineplus">+ * @tests gloda.noun.message.attr.attachmentNamesMatch</span>
<a href="#l26.502"></a><span id="l26.502" class="difflineplus">+ * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l26.503"></a><span id="l26.503" class="difflineplus">+ */</span>
<a href="#l26.504"></a><span id="l26.504" class="difflineplus">+function test_query_messages_by_attachment_names() {</span>
<a href="#l26.505"></a><span id="l26.505" class="difflineplus">+  let convNum = 0;</span>
<a href="#l26.506"></a><span id="l26.506" class="difflineplus">+  let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l26.507"></a><span id="l26.507" class="difflineplus">+  let convUniqueAttachment = uniqueTermGenerator(</span>
<a href="#l26.508"></a><span id="l26.508" class="difflineplus">+    UNIQUE_OFFSET_ATTACHMENT + UNIQUE_OFFSET_CONV + convNum);</span>
<a href="#l26.509"></a><span id="l26.509" class="difflineplus">+  query.attachmentNamesMatch(convUniqueAttachment);</span>
<a href="#l26.510"></a><span id="l26.510" class="difflineplus">+  queryExpect(query, world.conversationLists[convNum]); // calls next_test</span>
<a href="#l26.511"></a><span id="l26.511" class="difflineplus">+}</span>
<a href="#l26.512"></a><span id="l26.512" class="difflineplus">+</span>
<a href="#l26.513"></a><span id="l26.513" class="difflineplus">+/**</span>
<a href="#l26.514"></a><span id="l26.514" class="difflineplus">+ * Test author name fulltext searching using an arbitrary author.</span>
<a href="#l26.515"></a><span id="l26.515" class="difflineplus">+ *</span>
<a href="#l26.516"></a><span id="l26.516" class="difflineplus">+ * @tests gloda.noun.message.attr.authorMatches</span>
<a href="#l26.517"></a><span id="l26.517" class="difflineplus">+ * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l26.518"></a><span id="l26.518" class="difflineplus">+ */</span>
<a href="#l26.519"></a><span id="l26.519" class="difflineplus">+function test_query_messages_by_authorMatches_name() {</span>
<a href="#l26.520"></a><span id="l26.520" class="difflineplus">+  let [authorName, authorMail] = world.peoples[0];</span>
<a href="#l26.521"></a><span id="l26.521" class="difflineplus">+  let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l26.522"></a><span id="l26.522" class="difflineplus">+  query.authorMatches(authorName);</span>
<a href="#l26.523"></a><span id="l26.523" class="difflineplus">+  queryExpect(query, world.authorGroups[authorMail]); // calls next_test</span>
<a href="#l26.524"></a><span id="l26.524" class="difflineplus">+}</span>
<a href="#l26.525"></a><span id="l26.525" class="difflineplus">+</span>
<a href="#l26.526"></a><span id="l26.526" class="difflineplus">+/**</span>
<a href="#l26.527"></a><span id="l26.527" class="difflineplus">+ * Test author mail address fulltext searching using an arbitrary author.</span>
<a href="#l26.528"></a><span id="l26.528" class="difflineplus">+ *</span>
<a href="#l26.529"></a><span id="l26.529" class="difflineplus">+ * @tests gloda.noun.message.attr.authorMatches</span>
<a href="#l26.530"></a><span id="l26.530" class="difflineplus">+ * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l26.531"></a><span id="l26.531" class="difflineplus">+ */</span>
<a href="#l26.532"></a><span id="l26.532" class="difflineplus">+function test_query_messages_by_authorMatches_email() {</span>
<a href="#l26.533"></a><span id="l26.533" class="difflineplus">+  let [authorName, authorMail] = world.peoples[0];</span>
<a href="#l26.534"></a><span id="l26.534" class="difflineplus">+  let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l26.535"></a><span id="l26.535" class="difflineplus">+  query.authorMatches(authorMail);</span>
<a href="#l26.536"></a><span id="l26.536" class="difflineplus">+  queryExpect(query, world.authorGroups[authorMail]); // calls next_test</span>
<a href="#l26.537"></a><span id="l26.537" class="difflineplus">+}</span>
<a href="#l26.538"></a><span id="l26.538" class="difflineplus">+</span>
<a href="#l26.539"></a><span id="l26.539" class="difflineplus">+/**</span>
<a href="#l26.540"></a><span id="l26.540" class="difflineplus">+ * Test recipient name fulltext searching using an arbitrary recipient. Since</span>
<a href="#l26.541"></a><span id="l26.541" class="difflineplus">+ *  all 'peoples' messages are sent to all of them, any choice from peoples</span>
<a href="#l26.542"></a><span id="l26.542" class="difflineplus">+ *  gets us all 'peoplesMessages'.</span>
<a href="#l26.543"></a><span id="l26.543" class="difflineplus">+ *</span>
<a href="#l26.544"></a><span id="l26.544" class="difflineplus">+ * @tests gloda.noun.message.attr.recipientsMatch</span>
<a href="#l26.545"></a><span id="l26.545" class="difflineplus">+ * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l26.546"></a><span id="l26.546" class="difflineplus">+ */</span>
<a href="#l26.547"></a><span id="l26.547" class="difflineplus">+function test_query_messages_by_recipients_name() {</span>
<a href="#l26.548"></a><span id="l26.548" class="difflineplus">+  let [name,] = world.peoples[0];</span>
<a href="#l26.549"></a><span id="l26.549" class="difflineplus">+  let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l26.550"></a><span id="l26.550" class="difflineplus">+  query.recipientsMatch(name);</span>
<a href="#l26.551"></a><span id="l26.551" class="difflineplus">+  queryExpect(query, world.peoplesMessages); // calls next_test</span>
<a href="#l26.552"></a><span id="l26.552" class="difflineplus">+}</span>
<a href="#l26.553"></a><span id="l26.553" class="difflineplus">+</span>
<a href="#l26.554"></a><span id="l26.554" class="difflineplus">+/**</span>
<a href="#l26.555"></a><span id="l26.555" class="difflineplus">+ * Test recipient mail fulltext searching using an arbitrary recipient. Since</span>
<a href="#l26.556"></a><span id="l26.556" class="difflineplus">+ *  all 'peoples' messages are sent to all of them, any choice from peoples</span>
<a href="#l26.557"></a><span id="l26.557" class="difflineplus">+ *  gets us all 'peoplesMessages'.</span>
<a href="#l26.558"></a><span id="l26.558" class="difflineplus">+ *</span>
<a href="#l26.559"></a><span id="l26.559" class="difflineplus">+ * @tests gloda.noun.message.attr.recipientsMatch</span>
<a href="#l26.560"></a><span id="l26.560" class="difflineplus">+ * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l26.561"></a><span id="l26.561" class="difflineplus">+ */</span>
<a href="#l26.562"></a><span id="l26.562" class="difflineplus">+function test_query_messages_by_recipients_email() {</span>
<a href="#l26.563"></a><span id="l26.563" class="difflineplus">+  let [, mail] = world.peoples[0];</span>
<a href="#l26.564"></a><span id="l26.564" class="difflineplus">+  let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l26.565"></a><span id="l26.565" class="difflineplus">+  query.recipientsMatch(mail);</span>
<a href="#l26.566"></a><span id="l26.566" class="difflineplus">+  queryExpect(query, world.peoplesMessages); // calls next_test</span>
<a href="#l26.567"></a><span id="l26.567"> }</span>
<a href="#l26.568"></a><span id="l26.568"> </span>
<a href="#l26.569"></a><span id="l26.569"> /* === contacts === */</span>
<a href="#l26.570"></a><span id="l26.570"> </span>
<a href="#l26.571"></a><span id="l26.571"> var contactLikeQuery;</span>
<a href="#l26.572"></a><span id="l26.572" class="difflineplus">+/**</span>
<a href="#l26.573"></a><span id="l26.573" class="difflineplus">+ * @tests gloda.noun.contact.attr.name</span>
<a href="#l26.574"></a><span id="l26.574" class="difflineplus">+ * @tests gloda.datastore.sqlgen.kConstraintStringLike</span>
<a href="#l26.575"></a><span id="l26.575" class="difflineplus">+ */</span>
<a href="#l26.576"></a><span id="l26.576"> function test_query_contacts_by_name() {</span>
<a href="#l26.577"></a><span id="l26.577">   // let's use like... we need to test that...</span>
<a href="#l26.578"></a><span id="l26.578">   contactLikeQuery = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l26.579"></a><span id="l26.579">   let personName = world.peoples[0][0];</span>
<a href="#l26.580"></a><span id="l26.580">   // chop off the first and last letter...  this isn't the most edge-case</span>
<a href="#l26.581"></a><span id="l26.581">   //  handling way to roll, but LOOK OVER THERE? IS THAT ELVIS?</span>
<a href="#l26.582"></a><span id="l26.582">   let personNameSubstring = personName.substring(1, personName.length-1);</span>
<a href="#l26.583"></a><span id="l26.583">   contactLikeQuery.nameLike(contactLikeQuery.WILD, personNameSubstring,</span>
<a href="#l26.584"></a><span id="l26.584">                             contactLikeQuery.WILD);</span>
<a href="#l26.585"></a><span id="l26.585" class="difflineminus">-  </span>
<a href="#l26.586"></a><span id="l26.586" class="difflineplus">+</span>
<a href="#l26.587"></a><span id="l26.587">   queryExpect(contactLikeQuery, [personName]);</span>
<a href="#l26.588"></a><span id="l26.588"> }</span>
<a href="#l26.589"></a><span id="l26.589"> </span>
<a href="#l26.590"></a><span id="l26.590" class="difflineplus">+/**</span>
<a href="#l26.591"></a><span id="l26.591" class="difflineplus">+ * @tests gloda.query.test.kConstraintStringLike</span>
<a href="#l26.592"></a><span id="l26.592" class="difflineplus">+ */</span>
<a href="#l26.593"></a><span id="l26.593"> function test_query_contacts_by_name_nonmatch() {</span>
<a href="#l26.594"></a><span id="l26.594">   let otherContact = outlierIdentityCollection.items[0].contact;</span>
<a href="#l26.595"></a><span id="l26.595">   if (contactLikeQuery.test(otherContact)) {</span>
<a href="#l26.596"></a><span id="l26.596">     do_throw(&quot;The string LIKE mechanism as applied to contacts does not work.&quot;);</span>
<a href="#l26.597"></a><span id="l26.597">   }</span>
<a href="#l26.598"></a><span id="l26.598">   next_test();</span>
<a href="#l26.599"></a><span id="l26.599"> }</span>
<a href="#l26.600"></a><span id="l26.600"> </span>
<a href="#l26.601"></a><span id="l26.601" class="difflineat">@@ -385,16 +610,25 @@ var tests = [</span>
<a href="#l26.602"></a><span id="l26.602">   test_query_identities_for_outliers,</span>
<a href="#l26.603"></a><span id="l26.603">   test_query_identities_by_kind_and_value_nonmatches,</span>
<a href="#l26.604"></a><span id="l26.604">   // back to messages!</span>
<a href="#l26.605"></a><span id="l26.605">   test_query_messages_by_identity_peoples,</span>
<a href="#l26.606"></a><span id="l26.606">   test_query_messages_by_identity_outlier,</span>
<a href="#l26.607"></a><span id="l26.607">   test_query_messages_by_identity_nonmatches,</span>
<a href="#l26.608"></a><span id="l26.608">   test_query_messages_by_date,</span>
<a href="#l26.609"></a><span id="l26.609">   test_query_messages_by_date_nonmatches,</span>
<a href="#l26.610"></a><span id="l26.610" class="difflineplus">+  // fulltext</span>
<a href="#l26.611"></a><span id="l26.611" class="difflineplus">+  test_query_messages_by_subject_text,</span>
<a href="#l26.612"></a><span id="l26.612" class="difflineplus">+  test_query_messages_by_body_text,</span>
<a href="#l26.613"></a><span id="l26.613" class="difflineplus">+  test_query_messages_by_attachment_names,</span>
<a href="#l26.614"></a><span id="l26.614" class="difflineplus">+  test_query_messages_by_authorMatches_name,</span>
<a href="#l26.615"></a><span id="l26.615" class="difflineplus">+  test_query_messages_by_authorMatches_email,</span>
<a href="#l26.616"></a><span id="l26.616" class="difflineplus">+  test_query_messages_by_recipients_name,</span>
<a href="#l26.617"></a><span id="l26.617" class="difflineplus">+  test_query_messages_by_recipients_email,</span>
<a href="#l26.618"></a><span id="l26.618" class="difflineplus">+  // like</span>
<a href="#l26.619"></a><span id="l26.619">   test_query_contacts_by_name,</span>
<a href="#l26.620"></a><span id="l26.620">   test_query_contacts_by_name_nonmatch</span>
<a href="#l26.621"></a><span id="l26.621"> ];</span>
<a href="#l26.622"></a><span id="l26.622"> </span>
<a href="#l26.623"></a><span id="l26.623"> function run_test() {</span>
<a href="#l26.624"></a><span id="l26.624">   // use mbox injection so we get multiple folders...</span>
<a href="#l26.625"></a><span id="l26.625">   injectMessagesUsing(INJECT_MBOX);</span>
<a href="#l26.626"></a><span id="l26.626">   glodaHelperRunTests(tests);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1">new file mode 100644</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineminus">--- /dev/null</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_search_messages.js</span>
<a href="#l27.4"></a><span id="l27.4" class="difflineat">@@ -0,0 +1,90 @@</span>
<a href="#l27.5"></a><span id="l27.5" class="difflineplus">+/*</span>
<a href="#l27.6"></a><span id="l27.6" class="difflineplus">+ *</span>
<a href="#l27.7"></a><span id="l27.7" class="difflineplus">+ */</span>
<a href="#l27.8"></a><span id="l27.8" class="difflineplus">+</span>
<a href="#l27.9"></a><span id="l27.9" class="difflineplus">+load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l27.10"></a><span id="l27.10" class="difflineplus">+load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l27.11"></a><span id="l27.11" class="difflineplus">+</span>
<a href="#l27.12"></a><span id="l27.12" class="difflineplus">+Components.utils.import(&quot;resource://app/modules/gloda/msg_search.js&quot;);</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineplus">+</span>
<a href="#l27.14"></a><span id="l27.14" class="difflineplus">+// Create a message generator</span>
<a href="#l27.15"></a><span id="l27.15" class="difflineplus">+var msgGen = new MessageGenerator();</span>
<a href="#l27.16"></a><span id="l27.16" class="difflineplus">+// Create a message scenario generator using that message generator</span>
<a href="#l27.17"></a><span id="l27.17" class="difflineplus">+var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l27.18"></a><span id="l27.18" class="difflineplus">+</span>
<a href="#l27.19"></a><span id="l27.19" class="difflineplus">+var synthMessagesByCategory = {};</span>
<a href="#l27.20"></a><span id="l27.20" class="difflineplus">+</span>
<a href="#l27.21"></a><span id="l27.21" class="difflineplus">+var abFriends = null;</span>
<a href="#l27.22"></a><span id="l27.22" class="difflineplus">+</span>
<a href="#l27.23"></a><span id="l27.23" class="difflineplus">+function makeCatSynMsg(aCategories, aSynArgs) {</span>
<a href="#l27.24"></a><span id="l27.24" class="difflineplus">+</span>
<a href="#l27.25"></a><span id="l27.25" class="difflineplus">+}</span>
<a href="#l27.26"></a><span id="l27.26" class="difflineplus">+</span>
<a href="#l27.27"></a><span id="l27.27" class="difflineplus">+/**</span>
<a href="#l27.28"></a><span id="l27.28" class="difflineplus">+ *</span>
<a href="#l27.29"></a><span id="l27.29" class="difflineplus">+ *</span>
<a href="#l27.30"></a><span id="l27.30" class="difflineplus">+ *</span>
<a href="#l27.31"></a><span id="l27.31" class="difflineplus">+ * Base requirements:</span>
<a href="#l27.32"></a><span id="l27.32" class="difflineplus">+ * - Messages distributed over multiple folders.</span>
<a href="#l27.33"></a><span id="l27.33" class="difflineplus">+ * - All messages must match our base query of &quot;baz&quot;.</span>
<a href="#l27.34"></a><span id="l27.34" class="difflineplus">+ *</span>
<a href="#l27.35"></a><span id="l27.35" class="difflineplus">+ * Intended functionality corpus will be used to test:</span>
<a href="#l27.36"></a><span id="l27.36" class="difflineplus">+ * - Subject as more important than body.</span>
<a href="#l27.37"></a><span id="l27.37" class="difflineplus">+ * - Message attachment name as more important than body.</span>
<a href="#l27.38"></a><span id="l27.38" class="difflineplus">+ * - Inclusion of all search terms not attributable to contacts is bonused.</span>
<a href="#l27.39"></a><span id="l27.39" class="difflineplus">+ * - Involvement of self and contacts in the address book is tested.</span>
<a href="#l27.40"></a><span id="l27.40" class="difflineplus">+ */</span>
<a href="#l27.41"></a><span id="l27.41" class="difflineplus">+function setup_search_messages() {</span>
<a href="#l27.42"></a><span id="l27.42" class="difflineplus">+  let meAddress = [Gloda.myContact.name, Gloda.myContact.identities[0].value];</span>
<a href="#l27.43"></a><span id="l27.43" class="difflineplus">+  let abFriend1 = msgGen.makeNameAndAddress();</span>
<a href="#l27.44"></a><span id="l27.44" class="difflineplus">+  let abFriend2 = msgGen.makeNameAndAddress();</span>
<a href="#l27.45"></a><span id="l27.45" class="difflineplus">+  abFriends = [abFriend1, abFriend2];</span>
<a href="#l27.46"></a><span id="l27.46" class="difflineplus">+</span>
<a href="#l27.47"></a><span id="l27.47" class="difflineplus">+  makeCatSynMsg([&quot;from:me&quot;, &quot;body&quot;],</span>
<a href="#l27.48"></a><span id="l27.48" class="difflineplus">+    {from: meAddress, subject: &quot;blah&quot;, body: {body: &quot;baz&quot;}});</span>
<a href="#l27.49"></a><span id="l27.49" class="difflineplus">+  makeCatSynMsg([&quot;from:friend&quot;, &quot;body&quot;],</span>
<a href="#l27.50"></a><span id="l27.50" class="difflineplus">+    {from: abFriend1, subject: &quot;blah&quot;, body: {body: &quot;baz&quot;}});</span>
<a href="#l27.51"></a><span id="l27.51" class="difflineplus">+  makeCatSynMsg([&quot;from:me&quot;, &quot;to:friend&quot;, &quot;body&quot;],</span>
<a href="#l27.52"></a><span id="l27.52" class="difflineplus">+    {from: meAddress, to: [abFriend1], subject: &quot;blah&quot;, body: {body: &quot;baz&quot;}});</span>
<a href="#l27.53"></a><span id="l27.53" class="difflineplus">+  makeCatSynMsg([&quot;from:friend&quot;, &quot;to:friend&quot;, &quot;body&quot;],</span>
<a href="#l27.54"></a><span id="l27.54" class="difflineplus">+    {from: abFriend1, to: [abFriend2], subject: &quot;blah&quot;, body: {body: &quot;baz&quot;}});</span>
<a href="#l27.55"></a><span id="l27.55" class="difflineplus">+</span>
<a href="#l27.56"></a><span id="l27.56" class="difflineplus">+  makeCatSynMsg([&quot;subject&quot;],</span>
<a href="#l27.57"></a><span id="l27.57" class="difflineplus">+    {subject: &quot;baz&quot;, body: {body: &quot;blah&quot;}});</span>
<a href="#l27.58"></a><span id="l27.58" class="difflineplus">+  makeCatSynMsg([&quot;subject&quot;, &quot;body&quot;],</span>
<a href="#l27.59"></a><span id="l27.59" class="difflineplus">+    {subject: &quot;baz&quot;, body: {body: &quot;baz&quot;}});</span>
<a href="#l27.60"></a><span id="l27.60" class="difflineplus">+  makeCatSynMsg([&quot;attachment&quot;],</span>
<a href="#l27.61"></a><span id="l27.61" class="difflineplus">+    {subject: &quot;blah&quot;, body: {body: &quot;blah&quot;},</span>
<a href="#l27.62"></a><span id="l27.62" class="difflineplus">+     attachments: [{filename: &quot;baz.blah&quot;, body: &quot;blah&quot;}]});</span>
<a href="#l27.63"></a><span id="l27.63" class="difflineplus">+}</span>
<a href="#l27.64"></a><span id="l27.64" class="difflineplus">+</span>
<a href="#l27.65"></a><span id="l27.65" class="difflineplus">+var gSearcher;</span>
<a href="#l27.66"></a><span id="l27.66" class="difflineplus">+</span>
<a href="#l27.67"></a><span id="l27.67" class="difflineplus">+function run_search() {</span>
<a href="#l27.68"></a><span id="l27.68" class="difflineplus">+  gSearcher = new GlodaMsgSearcher();</span>
<a href="#l27.69"></a><span id="l27.69" class="difflineplus">+</span>
<a href="#l27.70"></a><span id="l27.70" class="difflineplus">+}</span>
<a href="#l27.71"></a><span id="l27.71" class="difflineplus">+</span>
<a href="#l27.72"></a><span id="l27.72" class="difflineplus">+/**</span>
<a href="#l27.73"></a><span id="l27.73" class="difflineplus">+ * We have the following scoring heuristics for unfaceted search:</span>
<a href="#l27.74"></a><span id="l27.74" class="difflineplus">+ * - Message Annotation Bonuses:</span>
<a href="#l27.75"></a><span id="l27.75" class="difflineplus">+ *   - Starred Messages (Strong)</span>
<a href="#l27.76"></a><span id="l27.76" class="difflineplus">+ *   - Tagged Messages (Weak; may be automated and represent boring things.)</span>
<a href="#l27.77"></a><span id="l27.77" class="difflineplus">+ * - Message Interest Bonuses.  We don't track message interest yet.  Psych!</span>
<a href="#l27.78"></a><span id="l27.78" class="difflineplus">+ * - Contact match bonus:</span>
<a href="#l27.79"></a><span id="l27.79" class="difflineplus">+ *   - We found a limited set of cont</span>
<a href="#l27.80"></a><span id="l27.80" class="difflineplus">+ *</span>
<a href="#l27.81"></a><span id="l27.81" class="difflineplus">+ * Our general testing sequence is this:</span>
<a href="#l27.82"></a><span id="l27.82" class="difflineplus">+ * - Create a bunch of messages and index them [setup_search_messages]</span>
<a href="#l27.83"></a><span id="l27.83" class="difflineplus">+ * - Peform any desired mutations on those messages or the involved contacts</span>
<a href="#l27.84"></a><span id="l27.84" class="difflineplus">+ *   (star/tag/etc.) [twiddle_search_messages]</span>
<a href="#l27.85"></a><span id="l27.85" class="difflineplus">+ * - Issue our search query</span>
<a href="#l27.86"></a><span id="l27.86" class="difflineplus">+ * - Re-score the results from the search query</span>
<a href="#l27.87"></a><span id="l27.87" class="difflineplus">+ */</span>
<a href="#l27.88"></a><span id="l27.88" class="difflineplus">+function verify_unfaceted_heuristics() {</span>
<a href="#l27.89"></a><span id="l27.89" class="difflineplus">+</span>
<a href="#l27.90"></a><span id="l27.90" class="difflineplus">+}</span>
<a href="#l27.91"></a><span id="l27.91" class="difflineplus">+</span>
<a href="#l27.92"></a><span id="l27.92" class="difflineplus">+function run_test() {</span>
<a href="#l27.93"></a><span id="l27.93" class="difflineplus">+  </span>
<a href="#l27.94"></a><span id="l27.94" class="difflineplus">+}</span>
<a href="#l27.95"></a><span id="l27.95">\ No newline at end of file</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

