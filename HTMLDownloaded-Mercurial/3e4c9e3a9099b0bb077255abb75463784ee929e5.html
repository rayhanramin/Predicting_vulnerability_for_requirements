<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 19881:3e4c9e3a9099b0bb077255abb75463784ee929e5</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 3e4c9e3a9099b0bb077255abb75463784ee929e5" />
<meta property="og:url" content="/comm-central/rev/3e4c9e3a9099b0bb077255abb75463784ee929e5" />
<meta property="og:description" content="Bug 1294260 - Part 6: fix some compile warnings in mork, potentially problematic. r=jorgk CLOSED TREE" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 3e4c9e3a9099b0bb077255abb75463784ee929e5 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/3e4c9e3a9099b0bb077255abb75463784ee929e5">shortlog</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/3e4c9e3a9099b0bb077255abb75463784ee929e5">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5">files</a> |
changeset |
<a href="/comm-central/raw-rev/3e4c9e3a9099b0bb077255abb75463784ee929e5">raw</a>  | <a href="/comm-central/archive/3e4c9e3a9099b0bb077255abb75463784ee929e5.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1294260">Bug 1294260</a> - Part 6: fix some compile warnings in mork, potentially problematic. r=jorgk CLOSED TREE
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#97;&#99;&#101;&#109;&#97;&#110;&#32;&#60;&#97;&#99;&#101;&#108;&#105;&#115;&#116;&#115;&#64;&#97;&#116;&#108;&#97;&#115;&#46;&#115;&#107;&#62;</td></tr>
<tr><td></td><td class="date age">Sun, 14 Aug 2016 20:16:25 +0200</td></tr>

<tr>
 <td>changeset 19881</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/3e4c9e3a9099b0bb077255abb75463784ee929e5">3e4c9e3a9099b0bb077255abb75463784ee929e5</a></td>
</tr>



<tr>
<td>parent 19880</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/28876b046ec271296611b271d6329937889dc694">28876b046ec271296611b271d6329937889dc694</a>
</td>
</tr>

<tr>
<td>child 19882</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/7f35b399aa0050d2cdc1f83e7aac54230b9d03e1">7f35b399aa0050d2cdc1f83e7aac54230b9d03e1</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=3e4c9e3a9099b0bb077255abb75463784ee929e5">12176</a></td></tr>
<tr><td>push user</td><td>acelists@atlas.sk</td></tr>
<tr><td>push date</td><td class="date age">Sun, 14 Aug 2016 18:17:46 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@3e4c9e3a9099 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=3e4c9e3a9099b0bb077255abb75463784ee929e5">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=3e4c9e3a9099b0bb077255abb75463784ee929e5&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=3e4c9e3a9099b0bb077255abb75463784ee929e5&newProject=comm-central&newRevision=3e4c9e3a9099b0bb077255abb75463784ee929e5&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=3e4c9e3a9099b0bb077255abb75463784ee929e5&newProject=comm-central&newRevision=3e4c9e3a9099b0bb077255abb75463784ee929e5&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=3e4c9e3a9099b0bb077255abb75463784ee929e5&newProject=comm-central&newRevision=3e4c9e3a9099b0bb077255abb75463784ee929e5&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28jorgk%29&revcount=50">jorgk</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1294260">1294260</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1294260">Bug 1294260</a> - Part 6: fix some compile warnings in mork, potentially problematic. r=jorgk CLOSED TREE</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/build/nsMorkFactory.cpp">db/mork/build/nsMorkFactory.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/build/nsMorkFactory.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/build/nsMorkFactory.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/build/nsMorkFactory.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/build/nsMorkFactory.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/build/nsMorkFactory.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/public/mdb.h">db/mork/public/mdb.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/public/mdb.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/public/mdb.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/public/mdb.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/public/mdb.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/public/mdb.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkArray.cpp">db/mork/src/morkArray.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkArray.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkArray.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkArray.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkArray.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkArray.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkArray.h">db/mork/src/morkArray.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkArray.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkArray.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkArray.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkArray.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkArray.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtom.cpp">db/mork/src/morkAtom.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtom.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtom.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtom.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtom.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtom.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomMap.cpp">db/mork/src/morkAtomMap.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomMap.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomMap.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomMap.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomMap.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomMap.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomMap.h">db/mork/src/morkAtomMap.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomMap.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomMap.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomMap.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomMap.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomMap.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomSpace.cpp">db/mork/src/morkAtomSpace.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomSpace.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomSpace.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomSpace.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomSpace.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomSpace.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomSpace.h">db/mork/src/morkAtomSpace.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomSpace.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomSpace.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomSpace.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomSpace.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkAtomSpace.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBead.cpp">db/mork/src/morkBead.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBead.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBead.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBead.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBead.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBead.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBead.h">db/mork/src/morkBead.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBead.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBead.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBead.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBead.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBead.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBuilder.cpp">db/mork/src/morkBuilder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBuilder.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBuilder.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBuilder.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBuilder.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBuilder.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBuilder.h">db/mork/src/morkBuilder.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBuilder.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBuilder.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBuilder.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBuilder.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkBuilder.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCellObject.cpp">db/mork/src/morkCellObject.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCellObject.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCellObject.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCellObject.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCellObject.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCellObject.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCellObject.h">db/mork/src/morkCellObject.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCellObject.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCellObject.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCellObject.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCellObject.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCellObject.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkConfig.cpp">db/mork/src/morkConfig.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkConfig.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkConfig.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkConfig.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkConfig.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkConfig.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCursor.cpp">db/mork/src/morkCursor.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCursor.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCursor.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCursor.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCursor.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCursor.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCursor.h">db/mork/src/morkCursor.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCursor.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCursor.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCursor.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCursor.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkCursor.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkDeque.cpp">db/mork/src/morkDeque.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkDeque.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkDeque.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkDeque.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkDeque.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkDeque.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkEnv.cpp">db/mork/src/morkEnv.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkEnv.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkEnv.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkEnv.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkEnv.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkEnv.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkEnv.h">db/mork/src/morkEnv.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkEnv.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkEnv.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkEnv.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkEnv.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkEnv.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFactory.cpp">db/mork/src/morkFactory.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFactory.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFactory.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFactory.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFactory.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFactory.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFactory.h">db/mork/src/morkFactory.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFactory.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFactory.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFactory.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFactory.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFactory.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFile.cpp">db/mork/src/morkFile.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFile.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFile.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFile.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFile.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFile.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFile.h">db/mork/src/morkFile.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFile.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFile.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFile.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFile.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkFile.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkHandle.cpp">db/mork/src/morkHandle.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkHandle.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkHandle.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkHandle.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkHandle.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkHandle.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkHandle.h">db/mork/src/morkHandle.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkHandle.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkHandle.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkHandle.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkHandle.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkHandle.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkIntMap.cpp">db/mork/src/morkIntMap.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkIntMap.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkIntMap.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkIntMap.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkIntMap.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkIntMap.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkIntMap.h">db/mork/src/morkIntMap.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkIntMap.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkIntMap.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkIntMap.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkIntMap.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkIntMap.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkMap.cpp">db/mork/src/morkMap.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkMap.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkMap.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkMap.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkMap.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkMap.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkMap.h">db/mork/src/morkMap.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkMap.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkMap.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkMap.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkMap.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkMap.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNode.cpp">db/mork/src/morkNode.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNode.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNode.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNode.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNode.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNode.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNode.h">db/mork/src/morkNode.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNode.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNode.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNode.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNode.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNode.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNodeMap.cpp">db/mork/src/morkNodeMap.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNodeMap.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNodeMap.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNodeMap.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNodeMap.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNodeMap.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNodeMap.h">db/mork/src/morkNodeMap.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNodeMap.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNodeMap.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNodeMap.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNodeMap.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkNodeMap.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkObject.cpp">db/mork/src/morkObject.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkObject.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkObject.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkObject.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkObject.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkObject.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkObject.h">db/mork/src/morkObject.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkObject.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkObject.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkObject.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkObject.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkObject.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkParser.cpp">db/mork/src/morkParser.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkParser.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkParser.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkParser.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkParser.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkParser.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkParser.h">db/mork/src/morkParser.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkParser.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkParser.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkParser.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkParser.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkParser.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPool.cpp">db/mork/src/morkPool.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPool.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPool.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPool.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPool.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPool.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPool.h">db/mork/src/morkPool.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPool.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPool.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPool.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPool.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPool.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPortTableCursor.cpp">db/mork/src/morkPortTableCursor.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPortTableCursor.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPortTableCursor.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPortTableCursor.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPortTableCursor.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPortTableCursor.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPortTableCursor.h">db/mork/src/morkPortTableCursor.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPortTableCursor.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPortTableCursor.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPortTableCursor.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPortTableCursor.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkPortTableCursor.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkProbeMap.cpp">db/mork/src/morkProbeMap.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkProbeMap.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkProbeMap.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkProbeMap.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkProbeMap.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkProbeMap.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkProbeMap.h">db/mork/src/morkProbeMap.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkProbeMap.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkProbeMap.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkProbeMap.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkProbeMap.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkProbeMap.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkQuickSort.cpp">db/mork/src/morkQuickSort.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkQuickSort.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkQuickSort.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkQuickSort.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkQuickSort.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkQuickSort.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRow.cpp">db/mork/src/morkRow.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRow.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRow.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRow.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRow.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRow.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowCellCursor.cpp">db/mork/src/morkRowCellCursor.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowCellCursor.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowCellCursor.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowCellCursor.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowCellCursor.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowCellCursor.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowCellCursor.h">db/mork/src/morkRowCellCursor.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowCellCursor.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowCellCursor.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowCellCursor.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowCellCursor.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowCellCursor.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowMap.cpp">db/mork/src/morkRowMap.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowMap.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowMap.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowMap.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowMap.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowMap.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowMap.h">db/mork/src/morkRowMap.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowMap.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowMap.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowMap.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowMap.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowMap.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowObject.cpp">db/mork/src/morkRowObject.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowObject.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowObject.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowObject.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowObject.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowObject.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowObject.h">db/mork/src/morkRowObject.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowObject.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowObject.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowObject.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowObject.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowObject.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowSpace.cpp">db/mork/src/morkRowSpace.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowSpace.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowSpace.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowSpace.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowSpace.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowSpace.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowSpace.h">db/mork/src/morkRowSpace.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowSpace.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowSpace.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowSpace.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowSpace.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkRowSpace.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkSearchRowCursor.cpp">db/mork/src/morkSearchRowCursor.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkSearchRowCursor.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkSearchRowCursor.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkSearchRowCursor.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkSearchRowCursor.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkSearchRowCursor.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkSpace.cpp">db/mork/src/morkSpace.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkSpace.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkSpace.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkSpace.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkSpace.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkSpace.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStore.cpp">db/mork/src/morkStore.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStore.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStore.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStore.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStore.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStore.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStore.h">db/mork/src/morkStore.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStore.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStore.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStore.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStore.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStore.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStream.cpp">db/mork/src/morkStream.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStream.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStream.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStream.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStream.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStream.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStream.h">db/mork/src/morkStream.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStream.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStream.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStream.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStream.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkStream.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTable.cpp">db/mork/src/morkTable.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTable.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTable.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTable.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTable.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTable.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTable.h">db/mork/src/morkTable.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTable.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTable.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTable.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTable.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTable.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTableRowCursor.cpp">db/mork/src/morkTableRowCursor.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTableRowCursor.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTableRowCursor.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTableRowCursor.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTableRowCursor.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTableRowCursor.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTableRowCursor.h">db/mork/src/morkTableRowCursor.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTableRowCursor.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTableRowCursor.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTableRowCursor.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTableRowCursor.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkTableRowCursor.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkThumb.cpp">db/mork/src/morkThumb.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkThumb.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkThumb.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkThumb.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkThumb.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkThumb.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkThumb.h">db/mork/src/morkThumb.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkThumb.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkThumb.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkThumb.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkThumb.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkThumb.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkUniqRowCursor.h">db/mork/src/morkUniqRowCursor.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkUniqRowCursor.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkUniqRowCursor.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkUniqRowCursor.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkUniqRowCursor.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkUniqRowCursor.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkWriter.cpp">db/mork/src/morkWriter.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkWriter.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkWriter.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkWriter.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkWriter.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkWriter.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkWriter.h">db/mork/src/morkWriter.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkWriter.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkWriter.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkWriter.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkWriter.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkWriter.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkYarn.cpp">db/mork/src/morkYarn.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkYarn.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkYarn.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkYarn.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkYarn.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkYarn.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkYarn.h">db/mork/src/morkYarn.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkYarn.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkYarn.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkYarn.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkYarn.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkYarn.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkZone.cpp">db/mork/src/morkZone.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkZone.cpp">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkZone.cpp">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkZone.cpp">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkZone.cpp">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkZone.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkZone.h">db/mork/src/morkZone.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkZone.h">file</a> |
<a href="/comm-central/annotate/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkZone.h">annotate</a> |
<a href="/comm-central/diff/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkZone.h">diff</a> |
<a href="/comm-central/comparison/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkZone.h">comparison</a> |
<a href="/comm-central/log/3e4c9e3a9099b0bb077255abb75463784ee929e5/db/mork/src/morkZone.h">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/db/mork/build/nsMorkFactory.cpp</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/db/mork/build/nsMorkFactory.cpp</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -9,19 +9,19 @@</span>
<a href="#l1.4"></a><span id="l1.4"> #include &quot;nsIMdbFactoryFactory.h&quot;</span>
<a href="#l1.5"></a><span id="l1.5"> #include &quot;mdb.h&quot;</span>
<a href="#l1.6"></a><span id="l1.6"> </span>
<a href="#l1.7"></a><span id="l1.7"> class nsMorkFactoryService final : public nsIMdbFactoryService</span>
<a href="#l1.8"></a><span id="l1.8"> {</span>
<a href="#l1.9"></a><span id="l1.9"> public:</span>
<a href="#l1.10"></a><span id="l1.10">   nsMorkFactoryService() {};</span>
<a href="#l1.11"></a><span id="l1.11">   // nsISupports methods</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-  NS_DECL_ISUPPORTS </span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+  NS_DECL_ISUPPORTS</span>
<a href="#l1.14"></a><span id="l1.14"> </span>
<a href="#l1.15"></a><span id="l1.15" class="difflineminus">-  NS_IMETHOD GetMdbFactory(nsIMdbFactory **aFactory);</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+  NS_IMETHOD GetMdbFactory(nsIMdbFactory **aFactory) override;</span>
<a href="#l1.17"></a><span id="l1.17"> </span>
<a href="#l1.18"></a><span id="l1.18"> protected:</span>
<a href="#l1.19"></a><span id="l1.19">   ~nsMorkFactoryService() {}</span>
<a href="#l1.20"></a><span id="l1.20">   nsCOMPtr&lt;nsIMdbFactory&gt; mMdbFactory;</span>
<a href="#l1.21"></a><span id="l1.21"> };</span>
<a href="#l1.22"></a><span id="l1.22"> </span>
<a href="#l1.23"></a><span id="l1.23"> NS_GENERIC_FACTORY_CONSTRUCTOR(nsMorkFactoryService)</span>
<a href="#l1.24"></a><span id="l1.24"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/db/mork/public/mdb.h</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/db/mork/public/mdb.h</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -454,16 +454,18 @@ public:</span>
<a href="#l2.4"></a><span id="l2.4">   NS_IMETHOD Alloc(nsIMdbEnv* ev, // allocate a piece of memory</span>
<a href="#l2.5"></a><span id="l2.5">     mdb_size inSize,        // requested byte size of new memory block </span>
<a href="#l2.6"></a><span id="l2.6">     void** outBlock) = 0;   // memory block of inSize bytes, or nil</span>
<a href="#l2.7"></a><span id="l2.7">     </span>
<a href="#l2.8"></a><span id="l2.8">   NS_IMETHOD Free(nsIMdbEnv* ev, // free block from Alloc or Resize()</span>
<a href="#l2.9"></a><span id="l2.9">     void* ioBlock) = 0;     // block to be destroyed/deallocated</span>
<a href="#l2.10"></a><span id="l2.10"> </span>
<a href="#l2.11"></a><span id="l2.11">   virtual size_t GetUsedSize() = 0;</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+  virtual ~nsIMdbHeap() {};</span>
<a href="#l2.14"></a><span id="l2.14"> // } ===== end nsIMdbHeap methods =====</span>
<a href="#l2.15"></a><span id="l2.15"> };</span>
<a href="#l2.16"></a><span id="l2.16"> </span>
<a href="#l2.17"></a><span id="l2.17"> /*| nsIMdbCPlusHeap: Alloc() with global ::new(), Free() with global ::delete(). </span>
<a href="#l2.18"></a><span id="l2.18"> **| Resize() is done by ::new() followed by ::delete().</span>
<a href="#l2.19"></a><span id="l2.19"> |*/</span>
<a href="#l2.20"></a><span id="l2.20"> class nsIMdbCPlusHeap { // caller-supplied memory management interface</span>
<a href="#l2.21"></a><span id="l2.21"> public:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/db/mork/src/morkArray.cpp</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/db/mork/src/morkArray.cpp</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -83,35 +83,30 @@ morkArray::morkArray(morkEnv* ev, const </span>
<a href="#l3.4"></a><span id="l3.4">     else</span>
<a href="#l3.5"></a><span id="l3.5">       ev-&gt;NilPointerError();</span>
<a href="#l3.6"></a><span id="l3.6">   }</span>
<a href="#l3.7"></a><span id="l3.7"> }</span>
<a href="#l3.8"></a><span id="l3.8"> </span>
<a href="#l3.9"></a><span id="l3.9"> /*public non-poly*/ void</span>
<a href="#l3.10"></a><span id="l3.10"> morkArray::CloseArray(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l3.11"></a><span id="l3.11"> {</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-  if ( this )</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">-  {</span>
<a href="#l3.14"></a><span id="l3.14">     if ( this-&gt;IsNode() )</span>
<a href="#l3.15"></a><span id="l3.15">     {</span>
<a href="#l3.16"></a><span id="l3.16">       if ( mArray_Heap &amp;&amp; mArray_Slots )</span>
<a href="#l3.17"></a><span id="l3.17">         mArray_Heap-&gt;Free(ev-&gt;AsMdbEnv(), mArray_Slots);</span>
<a href="#l3.18"></a><span id="l3.18">         </span>
<a href="#l3.19"></a><span id="l3.19">       mArray_Slots = 0;</span>
<a href="#l3.20"></a><span id="l3.20">       mArray_Size = 0;</span>
<a href="#l3.21"></a><span id="l3.21">       mArray_Fill = 0;</span>
<a href="#l3.22"></a><span id="l3.22">       ++mArray_Seed;</span>
<a href="#l3.23"></a><span id="l3.23">       nsIMdbHeap_SlotStrongHeap((nsIMdbHeap*) 0, ev, &amp;mArray_Heap);</span>
<a href="#l3.24"></a><span id="l3.24">       this-&gt;MarkShut();</span>
<a href="#l3.25"></a><span id="l3.25">     }</span>
<a href="#l3.26"></a><span id="l3.26">     else</span>
<a href="#l3.27"></a><span id="l3.27">       this-&gt;NonNodeError(ev);</span>
<a href="#l3.28"></a><span id="l3.28" class="difflineminus">-  }</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineminus">-  else</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l3.31"></a><span id="l3.31"> }</span>
<a href="#l3.32"></a><span id="l3.32"> </span>
<a href="#l3.33"></a><span id="l3.33"> // } ===== end morkNode methods =====</span>
<a href="#l3.34"></a><span id="l3.34"> // ````` ````` ````` ````` ````` </span>
<a href="#l3.35"></a><span id="l3.35"> </span>
<a href="#l3.36"></a><span id="l3.36"> /*static*/ void</span>
<a href="#l3.37"></a><span id="l3.37"> morkArray::NonArrayTypeError(morkEnv* ev)</span>
<a href="#l3.38"></a><span id="l3.38"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/db/mork/src/morkArray.h</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/db/mork/src/morkArray.h</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -35,17 +35,17 @@ public: // state is public because the e</span>
<a href="#l4.4"></a><span id="l4.4">   void**       mArray_Slots; // array of pointers</span>
<a href="#l4.5"></a><span id="l4.5">   nsIMdbHeap*  mArray_Heap;  // required heap for allocating mArray_Slots</span>
<a href="#l4.6"></a><span id="l4.6">   mork_fill    mArray_Fill;  // logical count of used slots in mArray_Slots</span>
<a href="#l4.7"></a><span id="l4.7">   mork_size    mArray_Size;  // physical count of mArray_Slots ( &gt;= Fill)</span>
<a href="#l4.8"></a><span id="l4.8">   mork_seed    mArray_Seed;  // change counter for syncing with iterators</span>
<a href="#l4.9"></a><span id="l4.9">   </span>
<a href="#l4.10"></a><span id="l4.10"> // { ===== begin morkNode interface =====</span>
<a href="#l4.11"></a><span id="l4.11"> public: // morkNode virtual methods</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseArray()</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseArray()</span>
<a href="#l4.14"></a><span id="l4.14">   virtual ~morkArray(); // assert that close executed earlier</span>
<a href="#l4.15"></a><span id="l4.15">   </span>
<a href="#l4.16"></a><span id="l4.16"> public: // morkArray construction &amp; destruction</span>
<a href="#l4.17"></a><span id="l4.17">   morkArray(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l4.18"></a><span id="l4.18">     nsIMdbHeap* ioHeap, mork_size inSize, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l4.19"></a><span id="l4.19">   void CloseArray(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l4.20"></a><span id="l4.20"> </span>
<a href="#l4.21"></a><span id="l4.21"> private: // copying is not allowed</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/db/mork/src/morkAtom.cpp</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/db/mork/src/morkAtom.cpp</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -32,18 +32,16 @@</span>
<a href="#l5.4"></a><span id="l5.4"> mork_bool</span>
<a href="#l5.5"></a><span id="l5.5"> morkAtom::GetYarn(mdbYarn* outYarn) const</span>
<a href="#l5.6"></a><span id="l5.6"> {</span>
<a href="#l5.7"></a><span id="l5.7">   const void* source = 0;  </span>
<a href="#l5.8"></a><span id="l5.8">   mdb_fill fill = 0; </span>
<a href="#l5.9"></a><span id="l5.9">   mdb_cscode form = 0;</span>
<a href="#l5.10"></a><span id="l5.10">   outYarn-&gt;mYarn_More = 0;</span>
<a href="#l5.11"></a><span id="l5.11"> </span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-  if ( this )</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineminus">-  {</span>
<a href="#l5.14"></a><span id="l5.14">     if ( this-&gt;IsWeeBook() )</span>
<a href="#l5.15"></a><span id="l5.15">     {</span>
<a href="#l5.16"></a><span id="l5.16">       morkWeeBookAtom* weeBook = (morkWeeBookAtom*) this;</span>
<a href="#l5.17"></a><span id="l5.17">       source = weeBook-&gt;mWeeBookAtom_Body;</span>
<a href="#l5.18"></a><span id="l5.18">       fill = weeBook-&gt;mAtom_Size;</span>
<a href="#l5.19"></a><span id="l5.19">     }</span>
<a href="#l5.20"></a><span id="l5.20">     else if ( this-&gt;IsBigBook() )</span>
<a href="#l5.21"></a><span id="l5.21">     {</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineat">@@ -60,17 +58,17 @@ morkAtom::GetYarn(mdbYarn* outYarn) cons</span>
<a href="#l5.23"></a><span id="l5.23">     }</span>
<a href="#l5.24"></a><span id="l5.24">     else if ( this-&gt;IsBigAnon() )</span>
<a href="#l5.25"></a><span id="l5.25">     {</span>
<a href="#l5.26"></a><span id="l5.26">       morkBigAnonAtom* bigAnon = (morkBigAnonAtom*) this;</span>
<a href="#l5.27"></a><span id="l5.27">       source = bigAnon-&gt;mBigAnonAtom_Body;</span>
<a href="#l5.28"></a><span id="l5.28">       fill = bigAnon-&gt;mBigAnonAtom_Size;</span>
<a href="#l5.29"></a><span id="l5.29">       form = bigAnon-&gt;mBigAnonAtom_Form;</span>
<a href="#l5.30"></a><span id="l5.30">     }</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineminus">-  }</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+</span>
<a href="#l5.33"></a><span id="l5.33">   if ( source &amp;&amp; fill ) // have an atom with nonempty content?</span>
<a href="#l5.34"></a><span id="l5.34">   {</span>
<a href="#l5.35"></a><span id="l5.35">     // if we have too many bytes, and yarn seems growable:</span>
<a href="#l5.36"></a><span id="l5.36">     if ( fill &gt; outYarn-&gt;mYarn_Size &amp;&amp; outYarn-&gt;mYarn_Grow ) // try grow?</span>
<a href="#l5.37"></a><span id="l5.37">       (*outYarn-&gt;mYarn_Grow)(outYarn, (mdb_size) fill); // request bigger</span>
<a href="#l5.38"></a><span id="l5.38">       </span>
<a href="#l5.39"></a><span id="l5.39">     mdb_size size = outYarn-&gt;mYarn_Size; // max dest size</span>
<a href="#l5.40"></a><span id="l5.40">     if ( fill &gt; size ) // too much atom content?</span>
<a href="#l5.41"></a><span id="l5.41" class="difflineat">@@ -335,20 +333,20 @@ morkBookAtom::NonBookAtomTypeError(morkE</span>
<a href="#l5.42"></a><span id="l5.42">   ev-&gt;NewError(&quot;non morkBookAtom&quot;);</span>
<a href="#l5.43"></a><span id="l5.43"> }</span>
<a href="#l5.44"></a><span id="l5.44"> </span>
<a href="#l5.45"></a><span id="l5.45"> mork_u4</span>
<a href="#l5.46"></a><span id="l5.46"> morkBookAtom::HashFormAndBody(morkEnv* ev) const</span>
<a href="#l5.47"></a><span id="l5.47"> {</span>
<a href="#l5.48"></a><span id="l5.48">   // This hash is obviously a variation of the dragon book string hash.</span>
<a href="#l5.49"></a><span id="l5.49">   // (I won't bother to explain or rationalize this usage for you.)</span>
<a href="#l5.50"></a><span id="l5.50" class="difflineminus">-  </span>
<a href="#l5.51"></a><span id="l5.51" class="difflineminus">-  register mork_u4 outHash = 0; // hash value returned</span>
<a href="#l5.52"></a><span id="l5.52" class="difflineminus">-  register unsigned char c; // next character</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineminus">-  register const mork_u1* body; // body of bytes to hash</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineplus">+</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineplus">+  mork_u4 outHash = 0; // hash value returned</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+  unsigned char c; // next character</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+  const mork_u1* body; // body of bytes to hash</span>
<a href="#l5.58"></a><span id="l5.58">   mork_size size = 0; // the number of bytes to hash</span>
<a href="#l5.59"></a><span id="l5.59"> </span>
<a href="#l5.60"></a><span id="l5.60">   if ( this-&gt;IsWeeBook() )</span>
<a href="#l5.61"></a><span id="l5.61">   {</span>
<a href="#l5.62"></a><span id="l5.62">     size = mAtom_Size;</span>
<a href="#l5.63"></a><span id="l5.63">     body = ((const morkWeeBookAtom*) this)-&gt;mWeeBookAtom_Body;</span>
<a href="#l5.64"></a><span id="l5.64">   }</span>
<a href="#l5.65"></a><span id="l5.65">   else if ( this-&gt;IsBigBook() )</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/db/mork/src/morkAtomMap.cpp</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/db/mork/src/morkAtomMap.cpp</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -79,32 +79,27 @@ morkAtomAidMap::morkAtomAidMap(morkEnv* </span>
<a href="#l6.4"></a><span id="l6.4"> {</span>
<a href="#l6.5"></a><span id="l6.5">   if ( ev-&gt;Good() )</span>
<a href="#l6.6"></a><span id="l6.6">     mNode_Derived = morkDerived_kAtomAidMap;</span>
<a href="#l6.7"></a><span id="l6.7"> }</span>
<a href="#l6.8"></a><span id="l6.8"> </span>
<a href="#l6.9"></a><span id="l6.9"> /*public non-poly*/ void</span>
<a href="#l6.10"></a><span id="l6.10"> morkAtomAidMap::CloseAtomAidMap(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l6.11"></a><span id="l6.11"> {</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-  if ( this )</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineminus">-  {</span>
<a href="#l6.14"></a><span id="l6.14">     if ( this-&gt;IsNode() )</span>
<a href="#l6.15"></a><span id="l6.15">     {</span>
<a href="#l6.16"></a><span id="l6.16"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l6.17"></a><span id="l6.17">       this-&gt;CloseProbeMap(ev);</span>
<a href="#l6.18"></a><span id="l6.18"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l6.19"></a><span id="l6.19">       this-&gt;CloseMap(ev);</span>
<a href="#l6.20"></a><span id="l6.20"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l6.21"></a><span id="l6.21">       this-&gt;MarkShut();</span>
<a href="#l6.22"></a><span id="l6.22">     }</span>
<a href="#l6.23"></a><span id="l6.23">     else</span>
<a href="#l6.24"></a><span id="l6.24">       this-&gt;NonNodeError(ev);</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineminus">-  }</span>
<a href="#l6.26"></a><span id="l6.26" class="difflineminus">-  else</span>
<a href="#l6.27"></a><span id="l6.27" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l6.28"></a><span id="l6.28"> }</span>
<a href="#l6.29"></a><span id="l6.29"> </span>
<a href="#l6.30"></a><span id="l6.30"> // } ===== end morkNode methods =====</span>
<a href="#l6.31"></a><span id="l6.31"> // ````` ````` ````` ````` ````` </span>
<a href="#l6.32"></a><span id="l6.32"> </span>
<a href="#l6.33"></a><span id="l6.33"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l6.34"></a><span id="l6.34"> </span>
<a href="#l6.35"></a><span id="l6.35">   /*virtual*/ mork_test // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l6.36"></a><span id="l6.36" class="difflineat">@@ -274,32 +269,27 @@ morkAtomBodyMap::morkAtomBodyMap(morkEnv</span>
<a href="#l6.37"></a><span id="l6.37"> {</span>
<a href="#l6.38"></a><span id="l6.38">   if ( ev-&gt;Good() )</span>
<a href="#l6.39"></a><span id="l6.39">     mNode_Derived = morkDerived_kAtomBodyMap;</span>
<a href="#l6.40"></a><span id="l6.40"> }</span>
<a href="#l6.41"></a><span id="l6.41"> </span>
<a href="#l6.42"></a><span id="l6.42"> /*public non-poly*/ void</span>
<a href="#l6.43"></a><span id="l6.43"> morkAtomBodyMap::CloseAtomBodyMap(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l6.44"></a><span id="l6.44"> {</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineminus">-  if ( this )</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineminus">-  {</span>
<a href="#l6.47"></a><span id="l6.47">     if ( this-&gt;IsNode() )</span>
<a href="#l6.48"></a><span id="l6.48">     {</span>
<a href="#l6.49"></a><span id="l6.49"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l6.50"></a><span id="l6.50">       this-&gt;CloseProbeMap(ev);</span>
<a href="#l6.51"></a><span id="l6.51"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l6.52"></a><span id="l6.52">       this-&gt;CloseMap(ev);</span>
<a href="#l6.53"></a><span id="l6.53"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l6.54"></a><span id="l6.54">       this-&gt;MarkShut();</span>
<a href="#l6.55"></a><span id="l6.55">     }</span>
<a href="#l6.56"></a><span id="l6.56">     else</span>
<a href="#l6.57"></a><span id="l6.57">       this-&gt;NonNodeError(ev);</span>
<a href="#l6.58"></a><span id="l6.58" class="difflineminus">-  }</span>
<a href="#l6.59"></a><span id="l6.59" class="difflineminus">-  else</span>
<a href="#l6.60"></a><span id="l6.60" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l6.61"></a><span id="l6.61"> }</span>
<a href="#l6.62"></a><span id="l6.62"> </span>
<a href="#l6.63"></a><span id="l6.63"> // } ===== end morkNode methods =====</span>
<a href="#l6.64"></a><span id="l6.64"> // ````` ````` ````` ````` ````` </span>
<a href="#l6.65"></a><span id="l6.65"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l6.66"></a><span id="l6.66"> </span>
<a href="#l6.67"></a><span id="l6.67">   /*virtual*/ mork_test // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l6.68"></a><span id="l6.68">   morkAtomBodyMap::MapTest(morkEnv* ev, const void* inMapKey,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/db/mork/src/morkAtomMap.h</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/db/mork/src/morkAtomMap.h</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -37,39 +37,39 @@</span>
<a href="#l7.4"></a><span id="l7.4"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.5"></a><span id="l7.5"> class morkAtomAidMap : public morkProbeMap { // for mapping tokens to maps</span>
<a href="#l7.6"></a><span id="l7.6"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.7"></a><span id="l7.7"> class morkAtomAidMap : public morkMap { // for mapping tokens to maps</span>
<a href="#l7.8"></a><span id="l7.8"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.9"></a><span id="l7.9"> </span>
<a href="#l7.10"></a><span id="l7.10"> // { ===== begin morkNode interface =====</span>
<a href="#l7.11"></a><span id="l7.11"> public: // morkNode virtual methods</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseAtomAidMap() only if open</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseAtomAidMap() only if open</span>
<a href="#l7.14"></a><span id="l7.14">   virtual ~morkAtomAidMap(); // assert that CloseAtomAidMap() executed earlier</span>
<a href="#l7.15"></a><span id="l7.15">   </span>
<a href="#l7.16"></a><span id="l7.16"> public: // morkMap construction &amp; destruction</span>
<a href="#l7.17"></a><span id="l7.17">   morkAtomAidMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l7.18"></a><span id="l7.18">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l7.19"></a><span id="l7.19">   void CloseAtomAidMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l7.20"></a><span id="l7.20"> </span>
<a href="#l7.21"></a><span id="l7.21"> public: // dynamic type identification</span>
<a href="#l7.22"></a><span id="l7.22">   mork_bool IsAtomAidMap() const</span>
<a href="#l7.23"></a><span id="l7.23">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kAtomAidMap; }</span>
<a href="#l7.24"></a><span id="l7.24"> // } ===== end morkNode methods =====</span>
<a href="#l7.25"></a><span id="l7.25"> </span>
<a href="#l7.26"></a><span id="l7.26"> public:</span>
<a href="#l7.27"></a><span id="l7.27"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.28"></a><span id="l7.28">   // { ===== begin morkProbeMap methods =====</span>
<a href="#l7.29"></a><span id="l7.29">   virtual mork_test // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l7.30"></a><span id="l7.30" class="difflineminus">-  MapTest(morkEnv* ev, const void* inMapKey, const void* inAppKey) const;</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineplus">+  MapTest(morkEnv* ev, const void* inMapKey, const void* inAppKey) const override;</span>
<a href="#l7.32"></a><span id="l7.32"> </span>
<a href="#l7.33"></a><span id="l7.33">   virtual mork_u4 // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l7.34"></a><span id="l7.34" class="difflineminus">-  MapHash(morkEnv* ev, const void* inAppKey) const;</span>
<a href="#l7.35"></a><span id="l7.35" class="difflineplus">+  MapHash(morkEnv* ev, const void* inAppKey) const override;</span>
<a href="#l7.36"></a><span id="l7.36"> </span>
<a href="#l7.37"></a><span id="l7.37" class="difflineminus">-  virtual mork_u4 ProbeMapHashMapKey(morkEnv* ev, const void* inMapKey) const;</span>
<a href="#l7.38"></a><span id="l7.38" class="difflineplus">+  virtual mork_u4 ProbeMapHashMapKey(morkEnv* ev, const void* inMapKey) const override;</span>
<a href="#l7.39"></a><span id="l7.39"> </span>
<a href="#l7.40"></a><span id="l7.40">   // virtual mork_bool ProbeMapIsKeyNil(morkEnv* ev, void* ioMapKey);</span>
<a href="#l7.41"></a><span id="l7.41"> </span>
<a href="#l7.42"></a><span id="l7.42">   // virtual void ProbeMapClearKey(morkEnv* ev, // put 'nil' alls keys inside map</span>
<a href="#l7.43"></a><span id="l7.43">   //   void* ioMapKey, mork_count inKeyCount); // array of keys inside map</span>
<a href="#l7.44"></a><span id="l7.44"> </span>
<a href="#l7.45"></a><span id="l7.45">   // virtual void ProbeMapPushIn(morkEnv* ev, // move (key,val) into the map</span>
<a href="#l7.46"></a><span id="l7.46">   //   const void* inAppKey, const void* inAppVal, // (key,val) outside map</span>
<a href="#l7.47"></a><span id="l7.47" class="difflineat">@@ -77,21 +77,21 @@ public:</span>
<a href="#l7.48"></a><span id="l7.48"> </span>
<a href="#l7.49"></a><span id="l7.49">   // virtual void ProbeMapPullOut(morkEnv* ev, // move (key,val) out from the map</span>
<a href="#l7.50"></a><span id="l7.50">   //   const void* inMapKey, const void* inMapVal, // (key,val) inside map</span>
<a href="#l7.51"></a><span id="l7.51">   //   void* outAppKey, void* outAppVal) const;    // (key,val) outside map</span>
<a href="#l7.52"></a><span id="l7.52">   // } ===== end morkProbeMap methods =====</span>
<a href="#l7.53"></a><span id="l7.53"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.54"></a><span id="l7.54"> // { ===== begin morkMap poly interface =====</span>
<a href="#l7.55"></a><span id="l7.55">   virtual mork_bool // note: equal(a,b) implies hash(a) == hash(b)</span>
<a href="#l7.56"></a><span id="l7.56" class="difflineminus">-  Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const;</span>
<a href="#l7.57"></a><span id="l7.57" class="difflineplus">+  Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const override;</span>
<a href="#l7.58"></a><span id="l7.58">   // implemented using morkBookAtom::HashAid()</span>
<a href="#l7.59"></a><span id="l7.59"> </span>
<a href="#l7.60"></a><span id="l7.60">   virtual mork_u4 // note: equal(a,b) implies hash(a) == hash(b)</span>
<a href="#l7.61"></a><span id="l7.61" class="difflineminus">-  Hash(morkEnv* ev, const void* inKey) const;</span>
<a href="#l7.62"></a><span id="l7.62" class="difflineplus">+  Hash(morkEnv* ev, const void* inKey) const override;</span>
<a href="#l7.63"></a><span id="l7.63">   // implemented using morkBookAtom::EqualAid()</span>
<a href="#l7.64"></a><span id="l7.64"> // } ===== end morkMap poly interface =====</span>
<a href="#l7.65"></a><span id="l7.65"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.66"></a><span id="l7.66"> </span>
<a href="#l7.67"></a><span id="l7.67"> public: // other map methods</span>
<a href="#l7.68"></a><span id="l7.68"> </span>
<a href="#l7.69"></a><span id="l7.69">   mork_bool      AddAtom(morkEnv* ev, morkBookAtom* ioAtom);</span>
<a href="#l7.70"></a><span id="l7.70">   // AddAtom() returns ev-&gt;Good()</span>
<a href="#l7.71"></a><span id="l7.71" class="difflineat">@@ -166,39 +166,39 @@ public:</span>
<a href="#l7.72"></a><span id="l7.72"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.73"></a><span id="l7.73"> class morkAtomBodyMap : public morkProbeMap { // for mapping tokens to maps</span>
<a href="#l7.74"></a><span id="l7.74"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.75"></a><span id="l7.75"> class morkAtomBodyMap : public morkMap { // for mapping tokens to maps</span>
<a href="#l7.76"></a><span id="l7.76"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.77"></a><span id="l7.77"> </span>
<a href="#l7.78"></a><span id="l7.78"> // { ===== begin morkNode interface =====</span>
<a href="#l7.79"></a><span id="l7.79"> public: // morkNode virtual methods</span>
<a href="#l7.80"></a><span id="l7.80" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseAtomBodyMap() only if open</span>
<a href="#l7.81"></a><span id="l7.81" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseAtomBodyMap() only if open</span>
<a href="#l7.82"></a><span id="l7.82">   virtual ~morkAtomBodyMap(); // assert CloseAtomBodyMap() executed earlier</span>
<a href="#l7.83"></a><span id="l7.83">   </span>
<a href="#l7.84"></a><span id="l7.84"> public: // morkMap construction &amp; destruction</span>
<a href="#l7.85"></a><span id="l7.85">   morkAtomBodyMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l7.86"></a><span id="l7.86">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l7.87"></a><span id="l7.87">   void CloseAtomBodyMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l7.88"></a><span id="l7.88"> </span>
<a href="#l7.89"></a><span id="l7.89"> public: // dynamic type identification</span>
<a href="#l7.90"></a><span id="l7.90">   mork_bool IsAtomBodyMap() const</span>
<a href="#l7.91"></a><span id="l7.91">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kAtomBodyMap; }</span>
<a href="#l7.92"></a><span id="l7.92"> // } ===== end morkNode methods =====</span>
<a href="#l7.93"></a><span id="l7.93"> </span>
<a href="#l7.94"></a><span id="l7.94"> public:</span>
<a href="#l7.95"></a><span id="l7.95"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.96"></a><span id="l7.96">   // { ===== begin morkProbeMap methods =====</span>
<a href="#l7.97"></a><span id="l7.97">   virtual mork_test // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l7.98"></a><span id="l7.98" class="difflineminus">-  MapTest(morkEnv* ev, const void* inMapKey, const void* inAppKey) const;</span>
<a href="#l7.99"></a><span id="l7.99" class="difflineplus">+  MapTest(morkEnv* ev, const void* inMapKey, const void* inAppKey) const override;</span>
<a href="#l7.100"></a><span id="l7.100"> </span>
<a href="#l7.101"></a><span id="l7.101">   virtual mork_u4 // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l7.102"></a><span id="l7.102" class="difflineminus">-  MapHash(morkEnv* ev, const void* inAppKey) const;</span>
<a href="#l7.103"></a><span id="l7.103" class="difflineplus">+  MapHash(morkEnv* ev, const void* inAppKey) const override;</span>
<a href="#l7.104"></a><span id="l7.104"> </span>
<a href="#l7.105"></a><span id="l7.105" class="difflineminus">-  virtual mork_u4 ProbeMapHashMapKey(morkEnv* ev, const void* inMapKey) const;</span>
<a href="#l7.106"></a><span id="l7.106" class="difflineplus">+  virtual mork_u4 ProbeMapHashMapKey(morkEnv* ev, const void* inMapKey) const override;</span>
<a href="#l7.107"></a><span id="l7.107"> </span>
<a href="#l7.108"></a><span id="l7.108">   // virtual mork_bool ProbeMapIsKeyNil(morkEnv* ev, void* ioMapKey);</span>
<a href="#l7.109"></a><span id="l7.109"> </span>
<a href="#l7.110"></a><span id="l7.110">   // virtual void ProbeMapClearKey(morkEnv* ev, // put 'nil' alls keys inside map</span>
<a href="#l7.111"></a><span id="l7.111">   //   void* ioMapKey, mork_count inKeyCount); // array of keys inside map</span>
<a href="#l7.112"></a><span id="l7.112"> </span>
<a href="#l7.113"></a><span id="l7.113">   // virtual void ProbeMapPushIn(morkEnv* ev, // move (key,val) into the map</span>
<a href="#l7.114"></a><span id="l7.114">   //   const void* inAppKey, const void* inAppVal, // (key,val) outside map</span>
<a href="#l7.115"></a><span id="l7.115" class="difflineat">@@ -206,21 +206,21 @@ public:</span>
<a href="#l7.116"></a><span id="l7.116"> </span>
<a href="#l7.117"></a><span id="l7.117">   // virtual void ProbeMapPullOut(morkEnv* ev, // move (key,val) out from the map</span>
<a href="#l7.118"></a><span id="l7.118">   //   const void* inMapKey, const void* inMapVal, // (key,val) inside map</span>
<a href="#l7.119"></a><span id="l7.119">   //   void* outAppKey, void* outAppVal) const;    // (key,val) outside map</span>
<a href="#l7.120"></a><span id="l7.120">   // } ===== end morkProbeMap methods =====</span>
<a href="#l7.121"></a><span id="l7.121"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.122"></a><span id="l7.122"> // { ===== begin morkMap poly interface =====</span>
<a href="#l7.123"></a><span id="l7.123">   virtual mork_bool // note: equal(a,b) implies hash(a) == hash(b)</span>
<a href="#l7.124"></a><span id="l7.124" class="difflineminus">-  Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const;</span>
<a href="#l7.125"></a><span id="l7.125" class="difflineplus">+  Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const override;</span>
<a href="#l7.126"></a><span id="l7.126">   // implemented using morkBookAtom::EqualFormAndBody()</span>
<a href="#l7.127"></a><span id="l7.127"> </span>
<a href="#l7.128"></a><span id="l7.128">   virtual mork_u4 // note: equal(a,b) implies hash(a) == hash(b)</span>
<a href="#l7.129"></a><span id="l7.129" class="difflineminus">-  Hash(morkEnv* ev, const void* inKey) const;</span>
<a href="#l7.130"></a><span id="l7.130" class="difflineplus">+  Hash(morkEnv* ev, const void* inKey) const override;</span>
<a href="#l7.131"></a><span id="l7.131">   // implemented using morkBookAtom::HashFormAndBody()</span>
<a href="#l7.132"></a><span id="l7.132"> // } ===== end morkMap poly interface =====</span>
<a href="#l7.133"></a><span id="l7.133"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.134"></a><span id="l7.134"> </span>
<a href="#l7.135"></a><span id="l7.135"> public: // other map methods</span>
<a href="#l7.136"></a><span id="l7.136"> </span>
<a href="#l7.137"></a><span id="l7.137">   mork_bool      AddAtom(morkEnv* ev, morkBookAtom* ioAtom);</span>
<a href="#l7.138"></a><span id="l7.138">   // AddAtom() returns ev-&gt;Good()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/db/mork/src/morkAtomSpace.cpp</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/db/mork/src/morkAtomSpace.cpp</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -86,36 +86,31 @@ morkAtomSpace::morkAtomSpace(morkEnv* ev</span>
<a href="#l8.4"></a><span id="l8.4">   // the morkSpace base constructor handles any dirty propagation</span>
<a href="#l8.5"></a><span id="l8.5">   if ( ev-&gt;Good() )</span>
<a href="#l8.6"></a><span id="l8.6">     mNode_Derived = morkDerived_kAtomSpace;</span>
<a href="#l8.7"></a><span id="l8.7"> }</span>
<a href="#l8.8"></a><span id="l8.8"> </span>
<a href="#l8.9"></a><span id="l8.9"> /*public non-poly*/ void</span>
<a href="#l8.10"></a><span id="l8.10"> morkAtomSpace::CloseAtomSpace(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l8.11"></a><span id="l8.11"> {</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-  if ( this )</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineminus">-  {</span>
<a href="#l8.14"></a><span id="l8.14">     if ( this-&gt;IsNode() )</span>
<a href="#l8.15"></a><span id="l8.15">     {</span>
<a href="#l8.16"></a><span id="l8.16">       mAtomSpace_AtomBodies.CloseMorkNode(ev);</span>
<a href="#l8.17"></a><span id="l8.17">       morkStore* store = mSpace_Store;</span>
<a href="#l8.18"></a><span id="l8.18">       if ( store )</span>
<a href="#l8.19"></a><span id="l8.19">         this-&gt;CutAllAtoms(ev, &amp;store-&gt;mStore_Pool);</span>
<a href="#l8.20"></a><span id="l8.20">       </span>
<a href="#l8.21"></a><span id="l8.21">       mAtomSpace_AtomAids.CloseMorkNode(ev);</span>
<a href="#l8.22"></a><span id="l8.22">       this-&gt;CloseSpace(ev);</span>
<a href="#l8.23"></a><span id="l8.23">       mAtomSpace_HighUnderId = 0;</span>
<a href="#l8.24"></a><span id="l8.24">       mAtomSpace_HighOverId = 0;</span>
<a href="#l8.25"></a><span id="l8.25">       this-&gt;MarkShut();</span>
<a href="#l8.26"></a><span id="l8.26">     }</span>
<a href="#l8.27"></a><span id="l8.27">     else</span>
<a href="#l8.28"></a><span id="l8.28">       this-&gt;NonNodeError(ev);</span>
<a href="#l8.29"></a><span id="l8.29" class="difflineminus">-  }</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineminus">-  else</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l8.32"></a><span id="l8.32"> }</span>
<a href="#l8.33"></a><span id="l8.33"> </span>
<a href="#l8.34"></a><span id="l8.34"> // } ===== end morkNode methods =====</span>
<a href="#l8.35"></a><span id="l8.35"> // ````` ````` ````` ````` ````` </span>
<a href="#l8.36"></a><span id="l8.36"> </span>
<a href="#l8.37"></a><span id="l8.37"> /*static*/ void</span>
<a href="#l8.38"></a><span id="l8.38"> morkAtomSpace::NonAtomSpaceTypeError(morkEnv* ev)</span>
<a href="#l8.39"></a><span id="l8.39"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/db/mork/src/morkAtomSpace.h</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/db/mork/src/morkAtomSpace.h</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -89,17 +89,17 @@ public: // more specific dirty methods f</span>
<a href="#l9.4"></a><span id="l9.4">   void SetAtomSpaceDirty() { this-&gt;SetNodeDirty(); }</span>
<a href="#l9.5"></a><span id="l9.5">   void SetAtomSpaceClean() { this-&gt;SetNodeClean(); }</span>
<a href="#l9.6"></a><span id="l9.6">   </span>
<a href="#l9.7"></a><span id="l9.7">   mork_bool IsAtomSpaceClean() const { return this-&gt;IsNodeClean(); }</span>
<a href="#l9.8"></a><span id="l9.8">   mork_bool IsAtomSpaceDirty() const { return this-&gt;IsNodeDirty(); }</span>
<a href="#l9.9"></a><span id="l9.9"> </span>
<a href="#l9.10"></a><span id="l9.10"> // { ===== begin morkNode interface =====</span>
<a href="#l9.11"></a><span id="l9.11"> public: // morkNode virtual methods</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseAtomSpace() only if open</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseAtomSpace() only if open</span>
<a href="#l9.14"></a><span id="l9.14">   virtual ~morkAtomSpace(); // assert that CloseAtomSpace() executed earlier</span>
<a href="#l9.15"></a><span id="l9.15">   </span>
<a href="#l9.16"></a><span id="l9.16"> public: // morkMap construction &amp; destruction</span>
<a href="#l9.17"></a><span id="l9.17">   morkAtomSpace(morkEnv* ev, const morkUsage&amp; inUsage, mork_scope inScope, </span>
<a href="#l9.18"></a><span id="l9.18">     morkStore* ioStore, nsIMdbHeap* ioNodeHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l9.19"></a><span id="l9.19">   void CloseAtomSpace(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l9.20"></a><span id="l9.20"> </span>
<a href="#l9.21"></a><span id="l9.21"> public: // dynamic type identification</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/db/mork/src/morkBead.cpp</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/db/mork/src/morkBead.cpp</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -71,31 +71,26 @@ morkBead::morkBead(morkEnv* ev,</span>
<a href="#l10.4"></a><span id="l10.4">     if ( ev-&gt;Good() )</span>
<a href="#l10.5"></a><span id="l10.5">       mNode_Derived = morkDerived_kBead;</span>
<a href="#l10.6"></a><span id="l10.6">   }</span>
<a href="#l10.7"></a><span id="l10.7"> }</span>
<a href="#l10.8"></a><span id="l10.8"> </span>
<a href="#l10.9"></a><span id="l10.9"> /*public non-poly*/ void</span>
<a href="#l10.10"></a><span id="l10.10"> morkBead::CloseBead(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l10.11"></a><span id="l10.11"> {</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-  if ( this )</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineminus">-  {</span>
<a href="#l10.14"></a><span id="l10.14">     if ( this-&gt;IsNode() )</span>
<a href="#l10.15"></a><span id="l10.15">     {</span>
<a href="#l10.16"></a><span id="l10.16">       if ( !this-&gt;IsShutNode() )</span>
<a href="#l10.17"></a><span id="l10.17">       {</span>
<a href="#l10.18"></a><span id="l10.18">         mBead_Color = 0;</span>
<a href="#l10.19"></a><span id="l10.19">         this-&gt;MarkShut();</span>
<a href="#l10.20"></a><span id="l10.20">       }</span>
<a href="#l10.21"></a><span id="l10.21">     }</span>
<a href="#l10.22"></a><span id="l10.22">     else</span>
<a href="#l10.23"></a><span id="l10.23">       this-&gt;NonNodeError(ev);</span>
<a href="#l10.24"></a><span id="l10.24" class="difflineminus">-  }</span>
<a href="#l10.25"></a><span id="l10.25" class="difflineminus">-  else</span>
<a href="#l10.26"></a><span id="l10.26" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l10.27"></a><span id="l10.27"> }</span>
<a href="#l10.28"></a><span id="l10.28"> </span>
<a href="#l10.29"></a><span id="l10.29"> // } ===== end morkNode methods =====</span>
<a href="#l10.30"></a><span id="l10.30"> // ````` ````` ````` ````` ````` </span>
<a href="#l10.31"></a><span id="l10.31"> </span>
<a href="#l10.32"></a><span id="l10.32"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l10.33"></a><span id="l10.33"> </span>
<a href="#l10.34"></a><span id="l10.34"> // ````` ````` ````` ````` ````` </span>
<a href="#l10.35"></a><span id="l10.35" class="difflineat">@@ -126,29 +121,24 @@ morkBeadMap::morkBeadMap(morkEnv* ev,</span>
<a href="#l10.36"></a><span id="l10.36"> {</span>
<a href="#l10.37"></a><span id="l10.37">   if ( ev-&gt;Good() )</span>
<a href="#l10.38"></a><span id="l10.38">     mNode_Derived = morkDerived_kBeadMap;</span>
<a href="#l10.39"></a><span id="l10.39"> }</span>
<a href="#l10.40"></a><span id="l10.40"> </span>
<a href="#l10.41"></a><span id="l10.41"> /*public non-poly*/ void</span>
<a href="#l10.42"></a><span id="l10.42"> morkBeadMap::CloseBeadMap(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l10.43"></a><span id="l10.43"> {</span>
<a href="#l10.44"></a><span id="l10.44" class="difflineminus">-  if ( this )</span>
<a href="#l10.45"></a><span id="l10.45" class="difflineminus">-  {</span>
<a href="#l10.46"></a><span id="l10.46">     if ( this-&gt;IsNode() )</span>
<a href="#l10.47"></a><span id="l10.47">     {</span>
<a href="#l10.48"></a><span id="l10.48">       this-&gt;CutAllBeads(ev);</span>
<a href="#l10.49"></a><span id="l10.49">       this-&gt;CloseMap(ev);</span>
<a href="#l10.50"></a><span id="l10.50">       this-&gt;MarkShut();</span>
<a href="#l10.51"></a><span id="l10.51">     }</span>
<a href="#l10.52"></a><span id="l10.52">     else</span>
<a href="#l10.53"></a><span id="l10.53">       this-&gt;NonNodeError(ev);</span>
<a href="#l10.54"></a><span id="l10.54" class="difflineminus">-  }</span>
<a href="#l10.55"></a><span id="l10.55" class="difflineminus">-  else</span>
<a href="#l10.56"></a><span id="l10.56" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l10.57"></a><span id="l10.57"> }</span>
<a href="#l10.58"></a><span id="l10.58"> </span>
<a href="#l10.59"></a><span id="l10.59"> // } ===== end morkNode methods =====</span>
<a href="#l10.60"></a><span id="l10.60"> // ````` ````` ````` ````` ````` </span>
<a href="#l10.61"></a><span id="l10.61"> </span>
<a href="#l10.62"></a><span id="l10.62"> mork_bool</span>
<a href="#l10.63"></a><span id="l10.63"> morkBeadMap::AddBead(morkEnv* ev, morkBead* ioBead)</span>
<a href="#l10.64"></a><span id="l10.64">   // the AddBead() boolean return equals ev-&gt;Good().</span>
<a href="#l10.65"></a><span id="l10.65" class="difflineat">@@ -310,29 +300,24 @@ morkBeadProbeMap::morkBeadProbeMap(morkE</span>
<a href="#l10.66"></a><span id="l10.66"> {</span>
<a href="#l10.67"></a><span id="l10.67">   if ( ev-&gt;Good() )</span>
<a href="#l10.68"></a><span id="l10.68">     mNode_Derived = morkDerived_kBeadProbeMap;</span>
<a href="#l10.69"></a><span id="l10.69"> }</span>
<a href="#l10.70"></a><span id="l10.70"> </span>
<a href="#l10.71"></a><span id="l10.71"> /*public non-poly*/ void</span>
<a href="#l10.72"></a><span id="l10.72"> morkBeadProbeMap::CloseBeadProbeMap(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l10.73"></a><span id="l10.73"> {</span>
<a href="#l10.74"></a><span id="l10.74" class="difflineminus">-  if ( this )</span>
<a href="#l10.75"></a><span id="l10.75" class="difflineminus">-  {</span>
<a href="#l10.76"></a><span id="l10.76">     if ( this-&gt;IsNode() )</span>
<a href="#l10.77"></a><span id="l10.77">     {</span>
<a href="#l10.78"></a><span id="l10.78">       this-&gt;CutAllBeads(ev);</span>
<a href="#l10.79"></a><span id="l10.79">       this-&gt;CloseProbeMap(ev);</span>
<a href="#l10.80"></a><span id="l10.80">       this-&gt;MarkShut();</span>
<a href="#l10.81"></a><span id="l10.81">     }</span>
<a href="#l10.82"></a><span id="l10.82">     else</span>
<a href="#l10.83"></a><span id="l10.83">       this-&gt;NonNodeError(ev);</span>
<a href="#l10.84"></a><span id="l10.84" class="difflineminus">-  }</span>
<a href="#l10.85"></a><span id="l10.85" class="difflineminus">-  else</span>
<a href="#l10.86"></a><span id="l10.86" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l10.87"></a><span id="l10.87"> }</span>
<a href="#l10.88"></a><span id="l10.88"> </span>
<a href="#l10.89"></a><span id="l10.89"> // } ===== end morkNode methods =====</span>
<a href="#l10.90"></a><span id="l10.90"> // ````` ````` ````` ````` ````` </span>
<a href="#l10.91"></a><span id="l10.91"> </span>
<a href="#l10.92"></a><span id="l10.92"> /*virtual*/ mork_test // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l10.93"></a><span id="l10.93"> morkBeadProbeMap::MapTest(morkEnv* ev, const void* inMapKey,</span>
<a href="#l10.94"></a><span id="l10.94">   const void* inAppKey) const</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/db/mork/src/morkBead.h</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/db/mork/src/morkBead.h</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -53,17 +53,17 @@ public: // state is public because the e</span>
<a href="#l11.4"></a><span id="l11.4"> public: // Hash() and Equal() for bead maps are same for all subclasses:</span>
<a href="#l11.5"></a><span id="l11.5"> </span>
<a href="#l11.6"></a><span id="l11.6">   mork_u4 BeadHash() const { return (mork_u4) mBead_Color; }</span>
<a href="#l11.7"></a><span id="l11.7">   mork_bool BeadEqual(const morkBead* inBead) const</span>
<a href="#l11.8"></a><span id="l11.8">   { return ( mBead_Color == inBead-&gt;mBead_Color); }</span>
<a href="#l11.9"></a><span id="l11.9">   </span>
<a href="#l11.10"></a><span id="l11.10"> // { ===== begin morkNode interface =====</span>
<a href="#l11.11"></a><span id="l11.11"> public: // morkNode virtual methods</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseBead() only if open</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseBead() only if open</span>
<a href="#l11.14"></a><span id="l11.14">   virtual ~morkBead(); // assert that CloseBead() executed earlier</span>
<a href="#l11.15"></a><span id="l11.15">   </span>
<a href="#l11.16"></a><span id="l11.16"> public: // special case for stack construction for map usage:</span>
<a href="#l11.17"></a><span id="l11.17">   morkBead(mork_color inBeadColor); // stack-based bead instance</span>
<a href="#l11.18"></a><span id="l11.18">   </span>
<a href="#l11.19"></a><span id="l11.19"> protected: // special case for morkObject:</span>
<a href="#l11.20"></a><span id="l11.20">   morkBead(const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l11.21"></a><span id="l11.21">     mork_color inBeadColor);</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineat">@@ -100,36 +100,36 @@ public: // typesafe refcounting inlines </span>
<a href="#l11.23"></a><span id="l11.23"> </span>
<a href="#l11.24"></a><span id="l11.24"> /*| morkBeadMap: maps bead -&gt; bead (key only using mBead_Color)</span>
<a href="#l11.25"></a><span id="l11.25"> |*/</span>
<a href="#l11.26"></a><span id="l11.26"> class morkBeadMap : public morkMap {</span>
<a href="#l11.27"></a><span id="l11.27"> </span>
<a href="#l11.28"></a><span id="l11.28"> </span>
<a href="#l11.29"></a><span id="l11.29"> // { ===== begin morkNode interface =====</span>
<a href="#l11.30"></a><span id="l11.30"> public: // morkNode virtual methods</span>
<a href="#l11.31"></a><span id="l11.31" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseBeadMap() only if open</span>
<a href="#l11.32"></a><span id="l11.32" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseBeadMap() only if open</span>
<a href="#l11.33"></a><span id="l11.33">   virtual ~morkBeadMap(); // assert that CloseBeadMap() executed earlier</span>
<a href="#l11.34"></a><span id="l11.34">   </span>
<a href="#l11.35"></a><span id="l11.35"> public: // morkMap construction &amp; destruction</span>
<a href="#l11.36"></a><span id="l11.36">   morkBeadMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l11.37"></a><span id="l11.37">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l11.38"></a><span id="l11.38">   void CloseBeadMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l11.39"></a><span id="l11.39"> </span>
<a href="#l11.40"></a><span id="l11.40"> public: // dynamic type identification</span>
<a href="#l11.41"></a><span id="l11.41">   mork_bool IsBeadMap() const</span>
<a href="#l11.42"></a><span id="l11.42">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kBeadMap; }</span>
<a href="#l11.43"></a><span id="l11.43"> // } ===== end morkNode methods =====</span>
<a href="#l11.44"></a><span id="l11.44"> </span>
<a href="#l11.45"></a><span id="l11.45"> // { ===== begin morkMap poly interface =====</span>
<a href="#l11.46"></a><span id="l11.46"> public:</span>
<a href="#l11.47"></a><span id="l11.47">   virtual mork_bool // *((mork_u4*) inKeyA) == *((mork_u4*) inKeyB)</span>
<a href="#l11.48"></a><span id="l11.48" class="difflineminus">-  Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const;</span>
<a href="#l11.49"></a><span id="l11.49" class="difflineplus">+  Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const override;</span>
<a href="#l11.50"></a><span id="l11.50"> </span>
<a href="#l11.51"></a><span id="l11.51">   virtual mork_u4 // some integer function of *((mork_u4*) inKey)</span>
<a href="#l11.52"></a><span id="l11.52" class="difflineminus">-  Hash(morkEnv* ev, const void* inKey) const;</span>
<a href="#l11.53"></a><span id="l11.53" class="difflineplus">+  Hash(morkEnv* ev, const void* inKey) const override;</span>
<a href="#l11.54"></a><span id="l11.54"> // } ===== end morkMap poly interface =====</span>
<a href="#l11.55"></a><span id="l11.55"> </span>
<a href="#l11.56"></a><span id="l11.56"> public: // other map methods</span>
<a href="#l11.57"></a><span id="l11.57"> </span>
<a href="#l11.58"></a><span id="l11.58">   mork_bool  AddBead(morkEnv* ev, morkBead* ioBead);</span>
<a href="#l11.59"></a><span id="l11.59">   // the AddBead() boolean return equals ev-&gt;Good().</span>
<a href="#l11.60"></a><span id="l11.60"> </span>
<a href="#l11.61"></a><span id="l11.61">   mork_bool  CutBead(morkEnv* ev, mork_color inColor);</span>
<a href="#l11.62"></a><span id="l11.62" class="difflineat">@@ -165,38 +165,38 @@ public:</span>
<a href="#l11.63"></a><span id="l11.63"> </span>
<a href="#l11.64"></a><span id="l11.64"> /*| morkBeadProbeMap: maps bead -&gt; bead (key only using mBead_Color)</span>
<a href="#l11.65"></a><span id="l11.65"> |*/</span>
<a href="#l11.66"></a><span id="l11.66"> class morkBeadProbeMap : public morkProbeMap {</span>
<a href="#l11.67"></a><span id="l11.67"> </span>
<a href="#l11.68"></a><span id="l11.68"> </span>
<a href="#l11.69"></a><span id="l11.69"> // { ===== begin morkNode interface =====</span>
<a href="#l11.70"></a><span id="l11.70"> public: // morkNode virtual methods</span>
<a href="#l11.71"></a><span id="l11.71" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseBeadProbeMap() only if open</span>
<a href="#l11.72"></a><span id="l11.72" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseBeadProbeMap() only if open</span>
<a href="#l11.73"></a><span id="l11.73">   virtual ~morkBeadProbeMap(); // assert that CloseBeadProbeMap() executed earlier</span>
<a href="#l11.74"></a><span id="l11.74" class="difflineminus">-  </span>
<a href="#l11.75"></a><span id="l11.75" class="difflineplus">+</span>
<a href="#l11.76"></a><span id="l11.76"> public: // morkMap construction &amp; destruction</span>
<a href="#l11.77"></a><span id="l11.77">   morkBeadProbeMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l11.78"></a><span id="l11.78">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l11.79"></a><span id="l11.79">   void CloseBeadProbeMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l11.80"></a><span id="l11.80"> </span>
<a href="#l11.81"></a><span id="l11.81"> public: // dynamic type identification</span>
<a href="#l11.82"></a><span id="l11.82">   mork_bool IsBeadProbeMap() const</span>
<a href="#l11.83"></a><span id="l11.83">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kBeadProbeMap; }</span>
<a href="#l11.84"></a><span id="l11.84"> // } ===== end morkNode methods =====</span>
<a href="#l11.85"></a><span id="l11.85"> </span>
<a href="#l11.86"></a><span id="l11.86">   // { ===== begin morkProbeMap methods =====</span>
<a href="#l11.87"></a><span id="l11.87"> public:</span>
<a href="#l11.88"></a><span id="l11.88">   virtual mork_test // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l11.89"></a><span id="l11.89" class="difflineminus">-  MapTest(morkEnv* ev, const void* inMapKey, const void* inAppKey) const;</span>
<a href="#l11.90"></a><span id="l11.90" class="difflineplus">+  MapTest(morkEnv* ev, const void* inMapKey, const void* inAppKey) const override;</span>
<a href="#l11.91"></a><span id="l11.91"> </span>
<a href="#l11.92"></a><span id="l11.92">   virtual mork_u4 // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l11.93"></a><span id="l11.93" class="difflineminus">-  MapHash(morkEnv* ev, const void* inAppKey) const;</span>
<a href="#l11.94"></a><span id="l11.94" class="difflineplus">+  MapHash(morkEnv* ev, const void* inAppKey) const override;</span>
<a href="#l11.95"></a><span id="l11.95"> </span>
<a href="#l11.96"></a><span id="l11.96" class="difflineminus">-  virtual mork_u4 ProbeMapHashMapKey(morkEnv* ev, const void* inMapKey) const;</span>
<a href="#l11.97"></a><span id="l11.97" class="difflineplus">+  virtual mork_u4 ProbeMapHashMapKey(morkEnv* ev, const void* inMapKey) const override;</span>
<a href="#l11.98"></a><span id="l11.98"> </span>
<a href="#l11.99"></a><span id="l11.99">   // virtual mork_bool ProbeMapIsKeyNil(morkEnv* ev, void* ioMapKey);</span>
<a href="#l11.100"></a><span id="l11.100"> </span>
<a href="#l11.101"></a><span id="l11.101">   // virtual void ProbeMapClearKey(morkEnv* ev, // put 'nil' alls keys inside map</span>
<a href="#l11.102"></a><span id="l11.102">   //   void* ioMapKey, mork_count inKeyCount); // array of keys inside map</span>
<a href="#l11.103"></a><span id="l11.103"> </span>
<a href="#l11.104"></a><span id="l11.104">   // virtual void ProbeMapPushIn(morkEnv* ev, // move (key,val) into the map</span>
<a href="#l11.105"></a><span id="l11.105">   //   const void* inAppKey, const void* inAppVal, // (key,val) outside map</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/db/mork/src/morkBuilder.cpp</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/db/mork/src/morkBuilder.cpp</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -153,18 +153,16 @@ morkBuilder::morkBuilder(morkEnv* ev,</span>
<a href="#l12.4"></a><span id="l12.4">       ev-&gt;NilPointerError();</span>
<a href="#l12.5"></a><span id="l12.5">   }</span>
<a href="#l12.6"></a><span id="l12.6">    </span>
<a href="#l12.7"></a><span id="l12.7"> }</span>
<a href="#l12.8"></a><span id="l12.8"> </span>
<a href="#l12.9"></a><span id="l12.9"> /*public non-poly*/ void</span>
<a href="#l12.10"></a><span id="l12.10"> morkBuilder::CloseBuilder(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l12.11"></a><span id="l12.11"> {</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-  if ( this )</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineminus">-  {</span>
<a href="#l12.14"></a><span id="l12.14">     if ( this-&gt;IsNode() )</span>
<a href="#l12.15"></a><span id="l12.15">     {</span>
<a href="#l12.16"></a><span id="l12.16">       mBuilder_Row = 0;</span>
<a href="#l12.17"></a><span id="l12.17">       mBuilder_Cell = 0;</span>
<a href="#l12.18"></a><span id="l12.18">       mBuilder_MetaTokenSlot = 0;</span>
<a href="#l12.19"></a><span id="l12.19">       </span>
<a href="#l12.20"></a><span id="l12.20">       morkTable::SlotStrongTable((morkTable*) 0, ev, &amp;mBuilder_Table);</span>
<a href="#l12.21"></a><span id="l12.21">       morkStore::SlotWeakStore((morkStore*) 0, ev, &amp;mBuilder_Store);</span>
<a href="#l12.22"></a><span id="l12.22" class="difflineat">@@ -180,19 +178,16 @@ morkBuilder::CloseBuilder(morkEnv* ev) /</span>
<a href="#l12.23"></a><span id="l12.23"> </span>
<a href="#l12.24"></a><span id="l12.24">       morkAtomSpace::SlotStrongAtomSpace((morkAtomSpace*) 0, ev,</span>
<a href="#l12.25"></a><span id="l12.25">         &amp;mBuilder_ScopeAtomSpace);</span>
<a href="#l12.26"></a><span id="l12.26">       this-&gt;CloseParser(ev);</span>
<a href="#l12.27"></a><span id="l12.27">       this-&gt;MarkShut();</span>
<a href="#l12.28"></a><span id="l12.28">     }</span>
<a href="#l12.29"></a><span id="l12.29">     else</span>
<a href="#l12.30"></a><span id="l12.30">       this-&gt;NonNodeError(ev);</span>
<a href="#l12.31"></a><span id="l12.31" class="difflineminus">-  }</span>
<a href="#l12.32"></a><span id="l12.32" class="difflineminus">-  else</span>
<a href="#l12.33"></a><span id="l12.33" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l12.34"></a><span id="l12.34"> }</span>
<a href="#l12.35"></a><span id="l12.35"> </span>
<a href="#l12.36"></a><span id="l12.36"> // } ===== end morkNode methods =====</span>
<a href="#l12.37"></a><span id="l12.37"> // ````` ````` ````` ````` ````` </span>
<a href="#l12.38"></a><span id="l12.38"> </span>
<a href="#l12.39"></a><span id="l12.39"> /*static*/ void</span>
<a href="#l12.40"></a><span id="l12.40"> morkBuilder::NonBuilderTypeError(morkEnv* ev)</span>
<a href="#l12.41"></a><span id="l12.41"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/db/mork/src/morkBuilder.h</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/db/mork/src/morkBuilder.h</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -165,17 +165,17 @@ protected: // protected morkBuilder memb</span>
<a href="#l13.4"></a><span id="l13.4">   </span>
<a href="#l13.5"></a><span id="l13.5"> protected: // protected inlines</span>
<a href="#l13.6"></a><span id="l13.6"> </span>
<a href="#l13.7"></a><span id="l13.7">   mork_bool  CellVectorIsFull() const</span>
<a href="#l13.8"></a><span id="l13.8">   { return ( mBuilder_CellsVecFill == morkBuilder_kCellsVecSize ); }</span>
<a href="#l13.9"></a><span id="l13.9">   </span>
<a href="#l13.10"></a><span id="l13.10"> // { ===== begin morkNode interface =====</span>
<a href="#l13.11"></a><span id="l13.11"> public: // morkNode virtual methods</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseBuilder() only if open</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseBuilder() only if open</span>
<a href="#l13.14"></a><span id="l13.14">   virtual ~morkBuilder(); // assert that CloseBuilder() executed earlier</span>
<a href="#l13.15"></a><span id="l13.15">   </span>
<a href="#l13.16"></a><span id="l13.16"> public: // morkYarn construction &amp; destruction</span>
<a href="#l13.17"></a><span id="l13.17">   morkBuilder(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l13.18"></a><span id="l13.18">     morkStream* ioStream,  // the readonly stream for input bytes</span>
<a href="#l13.19"></a><span id="l13.19">     mdb_count inBytesPerParseSegment, // target for ParseMore()</span>
<a href="#l13.20"></a><span id="l13.20">     nsIMdbHeap* ioSlotHeap, morkStore* ioStore</span>
<a href="#l13.21"></a><span id="l13.21">     );</span>
<a href="#l13.22"></a><span id="l13.22" class="difflineat">@@ -208,86 +208,86 @@ public: // other builder methods</span>
<a href="#l13.23"></a><span id="l13.23"> </span>
<a href="#l13.24"></a><span id="l13.24">   void FlushBuilderCells(morkEnv* ev);</span>
<a href="#l13.25"></a><span id="l13.25">   </span>
<a href="#l13.26"></a><span id="l13.26"> // ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l13.27"></a><span id="l13.27"> public: // in virtual morkParser methods, data flow subclass to parser</span>
<a href="#l13.28"></a><span id="l13.28"> </span>
<a href="#l13.29"></a><span id="l13.29">     virtual void MidToYarn(morkEnv* ev,</span>
<a href="#l13.30"></a><span id="l13.30">       const morkMid&amp; inMid,  // typically an alias to concat with strings</span>
<a href="#l13.31"></a><span id="l13.31" class="difflineminus">-      mdbYarn* outYarn);</span>
<a href="#l13.32"></a><span id="l13.32" class="difflineplus">+      mdbYarn* outYarn) override;</span>
<a href="#l13.33"></a><span id="l13.33">     // The parser might ask that some aliases be turned into yarns, so they</span>
<a href="#l13.34"></a><span id="l13.34">     // can be concatenated into longer blobs under some circumstances.  This</span>
<a href="#l13.35"></a><span id="l13.35">     // is an alternative to using a long and complex callback for many parts</span>
<a href="#l13.36"></a><span id="l13.36">     // for a single cell value.</span>
<a href="#l13.37"></a><span id="l13.37">   </span>
<a href="#l13.38"></a><span id="l13.38"> // ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l13.39"></a><span id="l13.39"> public: // out virtual morkParser methods, data flow parser to subclass</span>
<a href="#l13.40"></a><span id="l13.40"> </span>
<a href="#l13.41"></a><span id="l13.41" class="difflineminus">-  virtual void OnNewPort(morkEnv* ev, const morkPlace&amp; inPlace);</span>
<a href="#l13.42"></a><span id="l13.42" class="difflineminus">-  virtual void OnPortGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch);  </span>
<a href="#l13.43"></a><span id="l13.43" class="difflineminus">-  virtual void OnPortEnd(morkEnv* ev, const morkSpan&amp; inSpan);  </span>
<a href="#l13.44"></a><span id="l13.44" class="difflineplus">+  virtual void OnNewPort(morkEnv* ev, const morkPlace&amp; inPlace) override;</span>
<a href="#l13.45"></a><span id="l13.45" class="difflineplus">+  virtual void OnPortGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) override;</span>
<a href="#l13.46"></a><span id="l13.46" class="difflineplus">+  virtual void OnPortEnd(morkEnv* ev, const morkSpan&amp; inSpan) override;</span>
<a href="#l13.47"></a><span id="l13.47"> </span>
<a href="#l13.48"></a><span id="l13.48" class="difflineminus">-  virtual void OnNewGroup(morkEnv* ev, const morkPlace&amp; inPlace, mork_gid inGid);</span>
<a href="#l13.49"></a><span id="l13.49" class="difflineminus">-  virtual void OnGroupGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch);  </span>
<a href="#l13.50"></a><span id="l13.50" class="difflineminus">-  virtual void OnGroupCommitEnd(morkEnv* ev, const morkSpan&amp; inSpan);  </span>
<a href="#l13.51"></a><span id="l13.51" class="difflineminus">-  virtual void OnGroupAbortEnd(morkEnv* ev, const morkSpan&amp; inSpan);  </span>
<a href="#l13.52"></a><span id="l13.52" class="difflineplus">+  virtual void OnNewGroup(morkEnv* ev, const morkPlace&amp; inPlace, mork_gid inGid) override;</span>
<a href="#l13.53"></a><span id="l13.53" class="difflineplus">+  virtual void OnGroupGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) override;</span>
<a href="#l13.54"></a><span id="l13.54" class="difflineplus">+  virtual void OnGroupCommitEnd(morkEnv* ev, const morkSpan&amp; inSpan) override;</span>
<a href="#l13.55"></a><span id="l13.55" class="difflineplus">+  virtual void OnGroupAbortEnd(morkEnv* ev, const morkSpan&amp; inSpan) override;</span>
<a href="#l13.56"></a><span id="l13.56"> </span>
<a href="#l13.57"></a><span id="l13.57" class="difflineminus">-  virtual void OnNewPortRow(morkEnv* ev, const morkPlace&amp; inPlace, </span>
<a href="#l13.58"></a><span id="l13.58" class="difflineminus">-    const morkMid&amp; inMid, mork_change inChange);</span>
<a href="#l13.59"></a><span id="l13.59" class="difflineminus">-  virtual void OnPortRowGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch);  </span>
<a href="#l13.60"></a><span id="l13.60" class="difflineminus">-  virtual void OnPortRowEnd(morkEnv* ev, const morkSpan&amp; inSpan);  </span>
<a href="#l13.61"></a><span id="l13.61" class="difflineplus">+  virtual void OnNewPortRow(morkEnv* ev, const morkPlace&amp; inPlace,</span>
<a href="#l13.62"></a><span id="l13.62" class="difflineplus">+    const morkMid&amp; inMid, mork_change inChange) override;</span>
<a href="#l13.63"></a><span id="l13.63" class="difflineplus">+  virtual void OnPortRowGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) override;</span>
<a href="#l13.64"></a><span id="l13.64" class="difflineplus">+  virtual void OnPortRowEnd(morkEnv* ev, const morkSpan&amp; inSpan) override;</span>
<a href="#l13.65"></a><span id="l13.65"> </span>
<a href="#l13.66"></a><span id="l13.66">   virtual void OnNewTable(morkEnv* ev, const morkPlace&amp; inPlace,</span>
<a href="#l13.67"></a><span id="l13.67" class="difflineminus">-    const morkMid&amp; inMid, mork_bool inCutAllRows);</span>
<a href="#l13.68"></a><span id="l13.68" class="difflineminus">-  virtual void OnTableGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch);</span>
<a href="#l13.69"></a><span id="l13.69" class="difflineminus">-  virtual void OnTableEnd(morkEnv* ev, const morkSpan&amp; inSpan);</span>
<a href="#l13.70"></a><span id="l13.70" class="difflineplus">+    const morkMid&amp; inMid, mork_bool inCutAllRows) override;</span>
<a href="#l13.71"></a><span id="l13.71" class="difflineplus">+  virtual void OnTableGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) override;</span>
<a href="#l13.72"></a><span id="l13.72" class="difflineplus">+  virtual void OnTableEnd(morkEnv* ev, const morkSpan&amp; inSpan) override;</span>
<a href="#l13.73"></a><span id="l13.73">     </span>
<a href="#l13.74"></a><span id="l13.74" class="difflineminus">-  virtual void OnNewMeta(morkEnv* ev, const morkPlace&amp; inPlace);</span>
<a href="#l13.75"></a><span id="l13.75" class="difflineminus">-  virtual void OnMetaGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch);</span>
<a href="#l13.76"></a><span id="l13.76" class="difflineminus">-  virtual void OnMetaEnd(morkEnv* ev, const morkSpan&amp; inSpan);</span>
<a href="#l13.77"></a><span id="l13.77" class="difflineplus">+  virtual void OnNewMeta(morkEnv* ev, const morkPlace&amp; inPlace) override;</span>
<a href="#l13.78"></a><span id="l13.78" class="difflineplus">+  virtual void OnMetaGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) override;</span>
<a href="#l13.79"></a><span id="l13.79" class="difflineplus">+  virtual void OnMetaEnd(morkEnv* ev, const morkSpan&amp; inSpan) override;</span>
<a href="#l13.80"></a><span id="l13.80"> </span>
<a href="#l13.81"></a><span id="l13.81" class="difflineminus">-  virtual void OnMinusRow(morkEnv* ev);</span>
<a href="#l13.82"></a><span id="l13.82" class="difflineminus">-  virtual void OnNewRow(morkEnv* ev, const morkPlace&amp; inPlace, </span>
<a href="#l13.83"></a><span id="l13.83" class="difflineminus">-    const morkMid&amp; inMid, mork_bool inCutAllCols);</span>
<a href="#l13.84"></a><span id="l13.84" class="difflineminus">-  virtual void OnRowPos(morkEnv* ev, mork_pos inRowPos);  </span>
<a href="#l13.85"></a><span id="l13.85" class="difflineminus">-  virtual void OnRowGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch);  </span>
<a href="#l13.86"></a><span id="l13.86" class="difflineminus">-  virtual void OnRowEnd(morkEnv* ev, const morkSpan&amp; inSpan);  </span>
<a href="#l13.87"></a><span id="l13.87" class="difflineplus">+  virtual void OnMinusRow(morkEnv* ev) override;</span>
<a href="#l13.88"></a><span id="l13.88" class="difflineplus">+  virtual void OnNewRow(morkEnv* ev, const morkPlace&amp; inPlace,</span>
<a href="#l13.89"></a><span id="l13.89" class="difflineplus">+    const morkMid&amp; inMid, mork_bool inCutAllCols) override;</span>
<a href="#l13.90"></a><span id="l13.90" class="difflineplus">+  virtual void OnRowPos(morkEnv* ev, mork_pos inRowPos) override;</span>
<a href="#l13.91"></a><span id="l13.91" class="difflineplus">+  virtual void OnRowGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) override;</span>
<a href="#l13.92"></a><span id="l13.92" class="difflineplus">+  virtual void OnRowEnd(morkEnv* ev, const morkSpan&amp; inSpan) override;</span>
<a href="#l13.93"></a><span id="l13.93"> </span>
<a href="#l13.94"></a><span id="l13.94" class="difflineminus">-  virtual void OnNewDict(morkEnv* ev, const morkPlace&amp; inPlace);</span>
<a href="#l13.95"></a><span id="l13.95" class="difflineminus">-  virtual void OnDictGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch);  </span>
<a href="#l13.96"></a><span id="l13.96" class="difflineminus">-  virtual void OnDictEnd(morkEnv* ev, const morkSpan&amp; inSpan);  </span>
<a href="#l13.97"></a><span id="l13.97" class="difflineplus">+  virtual void OnNewDict(morkEnv* ev, const morkPlace&amp; inPlace) override;</span>
<a href="#l13.98"></a><span id="l13.98" class="difflineplus">+  virtual void OnDictGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) override;</span>
<a href="#l13.99"></a><span id="l13.99" class="difflineplus">+  virtual void OnDictEnd(morkEnv* ev, const morkSpan&amp; inSpan) override;</span>
<a href="#l13.100"></a><span id="l13.100"> </span>
<a href="#l13.101"></a><span id="l13.101">   virtual void OnAlias(morkEnv* ev, const morkSpan&amp; inSpan,</span>
<a href="#l13.102"></a><span id="l13.102" class="difflineminus">-    const morkMid&amp; inMid);</span>
<a href="#l13.103"></a><span id="l13.103" class="difflineplus">+    const morkMid&amp; inMid) override;</span>
<a href="#l13.104"></a><span id="l13.104"> </span>
<a href="#l13.105"></a><span id="l13.105" class="difflineminus">-  virtual void OnAliasGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch);</span>
<a href="#l13.106"></a><span id="l13.106" class="difflineplus">+  virtual void OnAliasGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) override;</span>
<a href="#l13.107"></a><span id="l13.107"> </span>
<a href="#l13.108"></a><span id="l13.108" class="difflineminus">-  virtual void OnMinusCell(morkEnv* ev);</span>
<a href="#l13.109"></a><span id="l13.109" class="difflineplus">+  virtual void OnMinusCell(morkEnv* ev) override;</span>
<a href="#l13.110"></a><span id="l13.110">   virtual void OnNewCell(morkEnv* ev, const morkPlace&amp; inPlace,</span>
<a href="#l13.111"></a><span id="l13.111" class="difflineminus">-    const morkMid* inMid, const morkBuf* inBuf);</span>
<a href="#l13.112"></a><span id="l13.112" class="difflineplus">+    const morkMid* inMid, const morkBuf* inBuf) override;</span>
<a href="#l13.113"></a><span id="l13.113">   // Exactly one of inMid and inBuf is nil, and the other is non-nil.</span>
<a href="#l13.114"></a><span id="l13.114">   // When hex ID syntax is used for a column, then inMid is not nil, and</span>
<a href="#l13.115"></a><span id="l13.115">   // when a naked string names a column, then inBuf is not nil.</span>
<a href="#l13.116"></a><span id="l13.116"> </span>
<a href="#l13.117"></a><span id="l13.117" class="difflineminus">-  virtual void OnCellGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch);</span>
<a href="#l13.118"></a><span id="l13.118" class="difflineminus">-  virtual void OnCellForm(morkEnv* ev, mork_cscode inCharsetFormat);</span>
<a href="#l13.119"></a><span id="l13.119" class="difflineminus">-  virtual void OnCellEnd(morkEnv* ev, const morkSpan&amp; inSpan);</span>
<a href="#l13.120"></a><span id="l13.120" class="difflineminus">-    </span>
<a href="#l13.121"></a><span id="l13.121" class="difflineplus">+  virtual void OnCellGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) override;</span>
<a href="#l13.122"></a><span id="l13.122" class="difflineplus">+  virtual void OnCellForm(morkEnv* ev, mork_cscode inCharsetFormat) override;</span>
<a href="#l13.123"></a><span id="l13.123" class="difflineplus">+  virtual void OnCellEnd(morkEnv* ev, const morkSpan&amp; inSpan) override;</span>
<a href="#l13.124"></a><span id="l13.124" class="difflineplus">+</span>
<a href="#l13.125"></a><span id="l13.125">   virtual void OnValue(morkEnv* ev, const morkSpan&amp; inSpan,</span>
<a href="#l13.126"></a><span id="l13.126" class="difflineminus">-    const morkBuf&amp; inBuf);</span>
<a href="#l13.127"></a><span id="l13.127" class="difflineplus">+    const morkBuf&amp; inBuf) override;</span>
<a href="#l13.128"></a><span id="l13.128"> </span>
<a href="#l13.129"></a><span id="l13.129">   virtual void OnValueMid(morkEnv* ev, const morkSpan&amp; inSpan,</span>
<a href="#l13.130"></a><span id="l13.130" class="difflineminus">-    const morkMid&amp; inMid);</span>
<a href="#l13.131"></a><span id="l13.131" class="difflineplus">+    const morkMid&amp; inMid) override;</span>
<a href="#l13.132"></a><span id="l13.132"> </span>
<a href="#l13.133"></a><span id="l13.133">   virtual void OnRowMid(morkEnv* ev, const morkSpan&amp; inSpan,</span>
<a href="#l13.134"></a><span id="l13.134" class="difflineminus">-    const morkMid&amp; inMid);</span>
<a href="#l13.135"></a><span id="l13.135" class="difflineplus">+    const morkMid&amp; inMid) override;</span>
<a href="#l13.136"></a><span id="l13.136"> </span>
<a href="#l13.137"></a><span id="l13.137">   virtual void OnTableMid(morkEnv* ev, const morkSpan&amp; inSpan,</span>
<a href="#l13.138"></a><span id="l13.138" class="difflineminus">-    const morkMid&amp; inMid);</span>
<a href="#l13.139"></a><span id="l13.139" class="difflineplus">+    const morkMid&amp; inMid) override;</span>
<a href="#l13.140"></a><span id="l13.140">   </span>
<a href="#l13.141"></a><span id="l13.141"> // ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l13.142"></a><span id="l13.142"> public: // public non-poly morkBuilder methods</span>
<a href="#l13.143"></a><span id="l13.143">   </span>
<a href="#l13.144"></a><span id="l13.144">   </span>
<a href="#l13.145"></a><span id="l13.145"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l13.146"></a><span id="l13.146">   static void SlotWeakBuilder(morkBuilder* me,</span>
<a href="#l13.147"></a><span id="l13.147">     morkEnv* ev, morkBuilder** ioSlot)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/db/mork/src/morkCellObject.cpp</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/db/mork/src/morkCellObject.cpp</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -111,32 +111,27 @@ morkCellObject::morkCellObject(morkEnv* </span>
<a href="#l14.4"></a><span id="l14.4">   }</span>
<a href="#l14.5"></a><span id="l14.5"> }</span>
<a href="#l14.6"></a><span id="l14.6"> </span>
<a href="#l14.7"></a><span id="l14.7"> NS_IMPL_ISUPPORTS_INHERITED(morkCellObject, morkObject, nsIMdbCell)</span>
<a href="#l14.8"></a><span id="l14.8"> </span>
<a href="#l14.9"></a><span id="l14.9"> /*public non-poly*/ void</span>
<a href="#l14.10"></a><span id="l14.10"> morkCellObject::CloseCellObject(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l14.11"></a><span id="l14.11"> {</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">-  if ( this )</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineminus">-  {</span>
<a href="#l14.14"></a><span id="l14.14">     if ( this-&gt;IsNode() )</span>
<a href="#l14.15"></a><span id="l14.15">     {</span>
<a href="#l14.16"></a><span id="l14.16">       NS_RELEASE(mCellObject_RowObject);</span>
<a href="#l14.17"></a><span id="l14.17">       mCellObject_Row = 0;</span>
<a href="#l14.18"></a><span id="l14.18">       mCellObject_Cell = 0;</span>
<a href="#l14.19"></a><span id="l14.19">       mCellObject_RowSeed = 0;</span>
<a href="#l14.20"></a><span id="l14.20">       this-&gt;CloseObject(ev);</span>
<a href="#l14.21"></a><span id="l14.21">       this-&gt;MarkShut();</span>
<a href="#l14.22"></a><span id="l14.22">     }</span>
<a href="#l14.23"></a><span id="l14.23">     else</span>
<a href="#l14.24"></a><span id="l14.24">       this-&gt;NonNodeError(ev);</span>
<a href="#l14.25"></a><span id="l14.25" class="difflineminus">-  }</span>
<a href="#l14.26"></a><span id="l14.26" class="difflineminus">-  else</span>
<a href="#l14.27"></a><span id="l14.27" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l14.28"></a><span id="l14.28"> }</span>
<a href="#l14.29"></a><span id="l14.29"> </span>
<a href="#l14.30"></a><span id="l14.30"> // } ===== end morkNode methods =====</span>
<a href="#l14.31"></a><span id="l14.31"> // ````` ````` ````` ````` ````` </span>
<a href="#l14.32"></a><span id="l14.32"> </span>
<a href="#l14.33"></a><span id="l14.33"> mork_bool</span>
<a href="#l14.34"></a><span id="l14.34"> morkCellObject::ResyncWithRow(morkEnv* ev)</span>
<a href="#l14.35"></a><span id="l14.35"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/db/mork/src/morkCellObject.h</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/db/mork/src/morkCellObject.h</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -45,94 +45,94 @@ public: // state is public because the e</span>
<a href="#l15.4"></a><span id="l15.4">   morkRow*        mCellObject_Row;        // cell's row if still in row object</span>
<a href="#l15.5"></a><span id="l15.5">   morkCell*       mCellObject_Cell;       // cell in row if rowseed matches</span>
<a href="#l15.6"></a><span id="l15.6">   mork_column     mCellObject_Col;        // col of cell last living in pos</span>
<a href="#l15.7"></a><span id="l15.7">   mork_u2         mCellObject_RowSeed;    // copy of row's seed</span>
<a href="#l15.8"></a><span id="l15.8">   mork_u2         mCellObject_Pos;        // position of cell in row</span>
<a href="#l15.9"></a><span id="l15.9">   </span>
<a href="#l15.10"></a><span id="l15.10"> // { ===== begin morkNode interface =====</span>
<a href="#l15.11"></a><span id="l15.11"> public: // morkNode virtual methods</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseCellObject() only if open</span>
<a href="#l15.13"></a><span id="l15.13" class="difflineminus">-  </span>
<a href="#l15.14"></a><span id="l15.14" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseCellObject() only if open</span>
<a href="#l15.15"></a><span id="l15.15" class="difflineplus">+</span>
<a href="#l15.16"></a><span id="l15.16"> public: // morkCellObject construction &amp; destruction</span>
<a href="#l15.17"></a><span id="l15.17">   morkCellObject(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l15.18"></a><span id="l15.18">     nsIMdbHeap* ioHeap, morkRow* ioRow, morkCell* ioCell,</span>
<a href="#l15.19"></a><span id="l15.19">     mork_column inCol, mork_pos inPos);</span>
<a href="#l15.20"></a><span id="l15.20">   void CloseCellObject(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l15.21"></a><span id="l15.21"> </span>
<a href="#l15.22"></a><span id="l15.22">   NS_IMETHOD SetBlob(nsIMdbEnv* ev,</span>
<a href="#l15.23"></a><span id="l15.23" class="difflineminus">-    nsIMdbBlob* ioBlob); // reads inBlob slots</span>
<a href="#l15.24"></a><span id="l15.24" class="difflineplus">+    nsIMdbBlob* ioBlob) override; // reads inBlob slots</span>
<a href="#l15.25"></a><span id="l15.25">   // when inBlob is in the same suite, this might be fastest cell-to-cell</span>
<a href="#l15.26"></a><span id="l15.26" class="difflineminus">-  </span>
<a href="#l15.27"></a><span id="l15.27" class="difflineplus">+</span>
<a href="#l15.28"></a><span id="l15.28">   NS_IMETHOD ClearBlob( // make empty (so content has zero length)</span>
<a href="#l15.29"></a><span id="l15.29" class="difflineminus">-    nsIMdbEnv* ev);</span>
<a href="#l15.30"></a><span id="l15.30" class="difflineplus">+    nsIMdbEnv* ev) override;</span>
<a href="#l15.31"></a><span id="l15.31">   // clearing a yarn is like SetYarn() with empty yarn instance content</span>
<a href="#l15.32"></a><span id="l15.32" class="difflineminus">-  </span>
<a href="#l15.33"></a><span id="l15.33" class="difflineplus">+</span>
<a href="#l15.34"></a><span id="l15.34">   NS_IMETHOD GetBlobFill(nsIMdbEnv* ev,</span>
<a href="#l15.35"></a><span id="l15.35" class="difflineminus">-    mdb_fill* outFill);  // size of blob </span>
<a href="#l15.36"></a><span id="l15.36" class="difflineplus">+    mdb_fill* outFill) override;  // size of blob</span>
<a href="#l15.37"></a><span id="l15.37">   // Same value that would be put into mYarn_Fill, if one called GetYarn()</span>
<a href="#l15.38"></a><span id="l15.38">   // with a yarn instance that had mYarn_Buf==nil and mYarn_Size==0.</span>
<a href="#l15.39"></a><span id="l15.39" class="difflineminus">-  </span>
<a href="#l15.40"></a><span id="l15.40" class="difflineminus">-  NS_IMETHOD SetYarn(nsIMdbEnv* ev, </span>
<a href="#l15.41"></a><span id="l15.41" class="difflineminus">-    const mdbYarn* inYarn);   // reads from yarn slots</span>
<a href="#l15.42"></a><span id="l15.42" class="difflineplus">+</span>
<a href="#l15.43"></a><span id="l15.43" class="difflineplus">+  NS_IMETHOD SetYarn(nsIMdbEnv* ev,</span>
<a href="#l15.44"></a><span id="l15.44" class="difflineplus">+    const mdbYarn* inYarn) override;   // reads from yarn slots</span>
<a href="#l15.45"></a><span id="l15.45">   // make this text object contain content from the yarn's buffer</span>
<a href="#l15.46"></a><span id="l15.46" class="difflineminus">-  </span>
<a href="#l15.47"></a><span id="l15.47" class="difflineminus">-  NS_IMETHOD GetYarn(nsIMdbEnv* ev, </span>
<a href="#l15.48"></a><span id="l15.48" class="difflineminus">-    mdbYarn* outYarn);  // writes some yarn slots </span>
<a href="#l15.49"></a><span id="l15.49" class="difflineplus">+</span>
<a href="#l15.50"></a><span id="l15.50" class="difflineplus">+  NS_IMETHOD GetYarn(nsIMdbEnv* ev,</span>
<a href="#l15.51"></a><span id="l15.51" class="difflineplus">+    mdbYarn* outYarn) override;  // writes some yarn slots</span>
<a href="#l15.52"></a><span id="l15.52">   // copy content into the yarn buffer, and update mYarn_Fill and mYarn_Form</span>
<a href="#l15.53"></a><span id="l15.53" class="difflineminus">-  </span>
<a href="#l15.54"></a><span id="l15.54" class="difflineminus">-  NS_IMETHOD AliasYarn(nsIMdbEnv* ev, </span>
<a href="#l15.55"></a><span id="l15.55" class="difflineminus">-    mdbYarn* outYarn); // writes ALL yarn slots</span>
<a href="#l15.56"></a><span id="l15.56" class="difflineminus">-  NS_IMETHOD SetColumn(nsIMdbEnv* ev, mdb_column inColumn); </span>
<a href="#l15.57"></a><span id="l15.57" class="difflineminus">-  NS_IMETHOD GetColumn(nsIMdbEnv* ev, mdb_column* outColumn);</span>
<a href="#l15.58"></a><span id="l15.58" class="difflineminus">-  </span>
<a href="#l15.59"></a><span id="l15.59" class="difflineplus">+</span>
<a href="#l15.60"></a><span id="l15.60" class="difflineplus">+  NS_IMETHOD AliasYarn(nsIMdbEnv* ev,</span>
<a href="#l15.61"></a><span id="l15.61" class="difflineplus">+    mdbYarn* outYarn) override; // writes ALL yarn slots</span>
<a href="#l15.62"></a><span id="l15.62" class="difflineplus">+  NS_IMETHOD SetColumn(nsIMdbEnv* ev, mdb_column inColumn) override;</span>
<a href="#l15.63"></a><span id="l15.63" class="difflineplus">+  NS_IMETHOD GetColumn(nsIMdbEnv* ev, mdb_column* outColumn) override;</span>
<a href="#l15.64"></a><span id="l15.64" class="difflineplus">+</span>
<a href="#l15.65"></a><span id="l15.65">   NS_IMETHOD GetCellInfo(  // all cell metainfo except actual content</span>
<a href="#l15.66"></a><span id="l15.66" class="difflineminus">-    nsIMdbEnv* ev, </span>
<a href="#l15.67"></a><span id="l15.67" class="difflineplus">+    nsIMdbEnv* ev,</span>
<a href="#l15.68"></a><span id="l15.68">     mdb_column* outColumn,           // the column in the containing row</span>
<a href="#l15.69"></a><span id="l15.69">     mdb_fill*   outBlobFill,         // the size of text content in bytes</span>
<a href="#l15.70"></a><span id="l15.70">     mdbOid*     outChildOid,         // oid of possible row or table child</span>
<a href="#l15.71"></a><span id="l15.71" class="difflineminus">-    mdb_bool*   outIsRowChild);  // nonzero if child, and a row child</span>
<a href="#l15.72"></a><span id="l15.72" class="difflineplus">+    mdb_bool*   outIsRowChild) override; // nonzero if child, and a row child</span>
<a href="#l15.73"></a><span id="l15.73"> </span>
<a href="#l15.74"></a><span id="l15.74">   // Checking all cell metainfo is a good way to avoid forcing a large cell</span>
<a href="#l15.75"></a><span id="l15.75">   // in to memory when you don't actually want to use the content.</span>
<a href="#l15.76"></a><span id="l15.76" class="difflineminus">-  </span>
<a href="#l15.77"></a><span id="l15.77" class="difflineplus">+</span>
<a href="#l15.78"></a><span id="l15.78">   NS_IMETHOD GetRow(nsIMdbEnv* ev, // parent row for this cell</span>
<a href="#l15.79"></a><span id="l15.79" class="difflineminus">-    nsIMdbRow** acqRow);</span>
<a href="#l15.80"></a><span id="l15.80" class="difflineplus">+    nsIMdbRow** acqRow) override;</span>
<a href="#l15.81"></a><span id="l15.81">   NS_IMETHOD GetPort(nsIMdbEnv* ev, // port containing cell</span>
<a href="#l15.82"></a><span id="l15.82" class="difflineminus">-    nsIMdbPort** acqPort);</span>
<a href="#l15.83"></a><span id="l15.83" class="difflineplus">+    nsIMdbPort** acqPort) override;</span>
<a href="#l15.84"></a><span id="l15.84">   // } ----- end attribute methods -----</span>
<a href="#l15.85"></a><span id="l15.85"> </span>
<a href="#l15.86"></a><span id="l15.86">   // { ----- begin children methods -----</span>
<a href="#l15.87"></a><span id="l15.87">   NS_IMETHOD HasAnyChild( // does cell have a child instead of text?</span>
<a href="#l15.88"></a><span id="l15.88">     nsIMdbEnv* ev,</span>
<a href="#l15.89"></a><span id="l15.89">     mdbOid* outOid,  // out id of row or table (or unbound if no child)</span>
<a href="#l15.90"></a><span id="l15.90" class="difflineminus">-    mdb_bool* outIsRow); // nonzero if child is a row (rather than a table)</span>
<a href="#l15.91"></a><span id="l15.91" class="difflineplus">+    mdb_bool* outIsRow) override; // nonzero if child is a row (rather than a table)</span>
<a href="#l15.92"></a><span id="l15.92"> </span>
<a href="#l15.93"></a><span id="l15.93">   NS_IMETHOD GetAnyChild( // access table of specific attribute</span>
<a href="#l15.94"></a><span id="l15.94">     nsIMdbEnv* ev, // context</span>
<a href="#l15.95"></a><span id="l15.95">     nsIMdbRow** acqRow, // child row (or null)</span>
<a href="#l15.96"></a><span id="l15.96" class="difflineminus">-    nsIMdbTable** acqTable); // child table (or null)</span>
<a href="#l15.97"></a><span id="l15.97" class="difflineplus">+    nsIMdbTable** acqTable) override; // child table (or null)</span>
<a href="#l15.98"></a><span id="l15.98"> </span>
<a href="#l15.99"></a><span id="l15.99"> </span>
<a href="#l15.100"></a><span id="l15.100">   NS_IMETHOD SetChildRow( // access table of specific attribute</span>
<a href="#l15.101"></a><span id="l15.101">     nsIMdbEnv* ev, // context</span>
<a href="#l15.102"></a><span id="l15.102" class="difflineminus">-    nsIMdbRow* ioRow); // inRow must be bound inside this same db port</span>
<a href="#l15.103"></a><span id="l15.103" class="difflineplus">+    nsIMdbRow* ioRow) override; // inRow must be bound inside this same db port</span>
<a href="#l15.104"></a><span id="l15.104"> </span>
<a href="#l15.105"></a><span id="l15.105">   NS_IMETHOD GetChildRow( // access row of specific attribute</span>
<a href="#l15.106"></a><span id="l15.106">     nsIMdbEnv* ev, // context</span>
<a href="#l15.107"></a><span id="l15.107" class="difflineminus">-    nsIMdbRow** acqRow); // acquire child row (or nil if no child)</span>
<a href="#l15.108"></a><span id="l15.108" class="difflineplus">+    nsIMdbRow** acqRow) override; // acquire child row (or nil if no child)</span>
<a href="#l15.109"></a><span id="l15.109"> </span>
<a href="#l15.110"></a><span id="l15.110"> </span>
<a href="#l15.111"></a><span id="l15.111">   NS_IMETHOD SetChildTable( // access table of specific attribute</span>
<a href="#l15.112"></a><span id="l15.112">     nsIMdbEnv* ev, // context</span>
<a href="#l15.113"></a><span id="l15.113" class="difflineminus">-    nsIMdbTable* inTable); // table must be bound inside this same db port</span>
<a href="#l15.114"></a><span id="l15.114" class="difflineplus">+    nsIMdbTable* inTable) override; // table must be bound inside this same db port</span>
<a href="#l15.115"></a><span id="l15.115"> </span>
<a href="#l15.116"></a><span id="l15.116">   NS_IMETHOD GetChildTable( // access table of specific attribute</span>
<a href="#l15.117"></a><span id="l15.117">     nsIMdbEnv* ev, // context</span>
<a href="#l15.118"></a><span id="l15.118" class="difflineminus">-    nsIMdbTable** acqTable); // acquire child table (or nil if no child)</span>
<a href="#l15.119"></a><span id="l15.119" class="difflineplus">+    nsIMdbTable** acqTable) override; // acquire child table (or nil if no child)</span>
<a href="#l15.120"></a><span id="l15.120">   // } ----- end children methods -----</span>
<a href="#l15.121"></a><span id="l15.121"> </span>
<a href="#l15.122"></a><span id="l15.122"> // } ===== end nsIMdbCell methods =====</span>
<a href="#l15.123"></a><span id="l15.123"> private: // copying is not allowed</span>
<a href="#l15.124"></a><span id="l15.124">   virtual ~morkCellObject(); // assert that CloseCellObject() executed earlier</span>
<a href="#l15.125"></a><span id="l15.125">   morkCellObject(const morkCellObject&amp; other);</span>
<a href="#l15.126"></a><span id="l15.126">   morkCellObject&amp; operator=(const morkCellObject&amp; other);</span>
<a href="#l15.127"></a><span id="l15.127"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/db/mork/src/morkConfig.cpp</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/db/mork/src/morkConfig.cpp</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -25,20 +25,20 @@ void mork_assertion_signal(const char* i</span>
<a href="#l16.4"></a><span id="l16.4"> #endif /*MORK_WIN*/</span>
<a href="#l16.5"></a><span id="l16.5"> }</span>
<a href="#l16.6"></a><span id="l16.6"> </span>
<a href="#l16.7"></a><span id="l16.7"> #ifdef MORK_PROVIDE_STDLIB</span>
<a href="#l16.8"></a><span id="l16.8"> </span>
<a href="#l16.9"></a><span id="l16.9"> MORK_LIB_IMPL(mork_i4)</span>
<a href="#l16.10"></a><span id="l16.10"> mork_memcmp(const void* inOne, const void* inTwo, mork_size inSize)</span>
<a href="#l16.11"></a><span id="l16.11"> {</span>
<a href="#l16.12"></a><span id="l16.12" class="difflineminus">-  register const mork_u1* t = (const mork_u1*) inTwo;</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineminus">-  register const mork_u1* s = (const mork_u1*) inOne;</span>
<a href="#l16.14"></a><span id="l16.14" class="difflineplus">+  const mork_u1* t = (const mork_u1*) inTwo;</span>
<a href="#l16.15"></a><span id="l16.15" class="difflineplus">+  const mork_u1* s = (const mork_u1*) inOne;</span>
<a href="#l16.16"></a><span id="l16.16">   const mork_u1* end = s + inSize;</span>
<a href="#l16.17"></a><span id="l16.17" class="difflineminus">-  register mork_i4 delta;</span>
<a href="#l16.18"></a><span id="l16.18" class="difflineplus">+  mork_i4 delta;</span>
<a href="#l16.19"></a><span id="l16.19">   </span>
<a href="#l16.20"></a><span id="l16.20">   while ( s &lt; end )</span>
<a href="#l16.21"></a><span id="l16.21">   {</span>
<a href="#l16.22"></a><span id="l16.22">     delta = ((mork_i4) *s) - ((mork_i4) *t);</span>
<a href="#l16.23"></a><span id="l16.23">     if ( delta )</span>
<a href="#l16.24"></a><span id="l16.24">       return delta;</span>
<a href="#l16.25"></a><span id="l16.25">     else</span>
<a href="#l16.26"></a><span id="l16.26">     {</span>
<a href="#l16.27"></a><span id="l16.27" class="difflineat">@@ -47,19 +47,19 @@ mork_memcmp(const void* inOne, const voi</span>
<a href="#l16.28"></a><span id="l16.28">     }</span>
<a href="#l16.29"></a><span id="l16.29">   }</span>
<a href="#l16.30"></a><span id="l16.30">   return 0;</span>
<a href="#l16.31"></a><span id="l16.31"> }</span>
<a href="#l16.32"></a><span id="l16.32"> </span>
<a href="#l16.33"></a><span id="l16.33"> MORK_LIB_IMPL(void)</span>
<a href="#l16.34"></a><span id="l16.34"> mork_memcpy(void* outDst, const void* inSrc, mork_size inSize)</span>
<a href="#l16.35"></a><span id="l16.35"> {</span>
<a href="#l16.36"></a><span id="l16.36" class="difflineminus">-  register mork_u1* d = (mork_u1*) outDst;</span>
<a href="#l16.37"></a><span id="l16.37" class="difflineplus">+  mork_u1* d = (mork_u1*) outDst;</span>
<a href="#l16.38"></a><span id="l16.38">   mork_u1* end = d + inSize;</span>
<a href="#l16.39"></a><span id="l16.39" class="difflineminus">-  register const mork_u1* s = ((const mork_u1*) inSrc);</span>
<a href="#l16.40"></a><span id="l16.40" class="difflineplus">+  const mork_u1* s = ((const mork_u1*) inSrc);</span>
<a href="#l16.41"></a><span id="l16.41">   </span>
<a href="#l16.42"></a><span id="l16.42">   while ( inSize &gt;= 8 )</span>
<a href="#l16.43"></a><span id="l16.43">   {</span>
<a href="#l16.44"></a><span id="l16.44">     *d++ = *s++;</span>
<a href="#l16.45"></a><span id="l16.45">     *d++ = *s++;</span>
<a href="#l16.46"></a><span id="l16.46">     *d++ = *s++;</span>
<a href="#l16.47"></a><span id="l16.47">     *d++ = *s++;</span>
<a href="#l16.48"></a><span id="l16.48">     </span>
<a href="#l16.49"></a><span id="l16.49" class="difflineat">@@ -73,18 +73,18 @@ mork_memcpy(void* outDst, const void* in</span>
<a href="#l16.50"></a><span id="l16.50">   </span>
<a href="#l16.51"></a><span id="l16.51">   while ( d &lt; end )</span>
<a href="#l16.52"></a><span id="l16.52">     *d++ = *s++;</span>
<a href="#l16.53"></a><span id="l16.53"> }</span>
<a href="#l16.54"></a><span id="l16.54"> </span>
<a href="#l16.55"></a><span id="l16.55"> MORK_LIB_IMPL(void)</span>
<a href="#l16.56"></a><span id="l16.56"> mork_memmove(void* outDst, const void* inSrc, mork_size inSize)</span>
<a href="#l16.57"></a><span id="l16.57"> {</span>
<a href="#l16.58"></a><span id="l16.58" class="difflineminus">-  register mork_u1* d = (mork_u1*) outDst;</span>
<a href="#l16.59"></a><span id="l16.59" class="difflineminus">-  register const mork_u1* s = (const mork_u1*) inSrc;</span>
<a href="#l16.60"></a><span id="l16.60" class="difflineplus">+  mork_u1* d = (mork_u1*) outDst;</span>
<a href="#l16.61"></a><span id="l16.61" class="difflineplus">+  const mork_u1* s = (const mork_u1*) inSrc;</span>
<a href="#l16.62"></a><span id="l16.62">   if ( d != s &amp;&amp; inSize ) // copy is necessary?</span>
<a href="#l16.63"></a><span id="l16.63">   {</span>
<a href="#l16.64"></a><span id="l16.64">     const mork_u1* srcEnd = s + inSize; // one past last source byte</span>
<a href="#l16.65"></a><span id="l16.65">     </span>
<a href="#l16.66"></a><span id="l16.66">     if ( d &gt; s &amp;&amp; d &lt; srcEnd ) // overlap? need to copy backwards?</span>
<a href="#l16.67"></a><span id="l16.67">     {</span>
<a href="#l16.68"></a><span id="l16.68">       s = srcEnd; // start one past last source byte</span>
<a href="#l16.69"></a><span id="l16.69">       d += inSize; // start one past last dest byte</span>
<a href="#l16.70"></a><span id="l16.70" class="difflineat">@@ -123,78 +123,78 @@ mork_memmove(void* outDst, const void* i</span>
<a href="#l16.71"></a><span id="l16.71">         *d++ = *s++;</span>
<a href="#l16.72"></a><span id="l16.72">     }</span>
<a href="#l16.73"></a><span id="l16.73">   }</span>
<a href="#l16.74"></a><span id="l16.74"> }</span>
<a href="#l16.75"></a><span id="l16.75"> </span>
<a href="#l16.76"></a><span id="l16.76"> MORK_LIB_IMPL(void)</span>
<a href="#l16.77"></a><span id="l16.77"> mork_memset(void* outDst, int inByte, mork_size inSize)</span>
<a href="#l16.78"></a><span id="l16.78"> {</span>
<a href="#l16.79"></a><span id="l16.79" class="difflineminus">-  register mork_u1* d = (mork_u1*) outDst;</span>
<a href="#l16.80"></a><span id="l16.80" class="difflineplus">+  mork_u1* d = (mork_u1*) outDst;</span>
<a href="#l16.81"></a><span id="l16.81">   mork_u1* end = d + inSize;</span>
<a href="#l16.82"></a><span id="l16.82">   while ( d &lt; end )</span>
<a href="#l16.83"></a><span id="l16.83">     *d++ = (mork_u1) inByte;</span>
<a href="#l16.84"></a><span id="l16.84"> }</span>
<a href="#l16.85"></a><span id="l16.85"> </span>
<a href="#l16.86"></a><span id="l16.86"> MORK_LIB_IMPL(void)</span>
<a href="#l16.87"></a><span id="l16.87"> mork_strcpy(void* outDst, const void* inSrc)</span>
<a href="#l16.88"></a><span id="l16.88"> {</span>
<a href="#l16.89"></a><span id="l16.89">   // back up one first to support preincrement</span>
<a href="#l16.90"></a><span id="l16.90" class="difflineminus">-  register mork_u1* d = ((mork_u1*) outDst) - 1;</span>
<a href="#l16.91"></a><span id="l16.91" class="difflineminus">-  register const mork_u1* s = ((const mork_u1*) inSrc) - 1;</span>
<a href="#l16.92"></a><span id="l16.92" class="difflineplus">+  mork_u1* d = ((mork_u1*) outDst) - 1;</span>
<a href="#l16.93"></a><span id="l16.93" class="difflineplus">+  const mork_u1* s = ((const mork_u1*) inSrc) - 1;</span>
<a href="#l16.94"></a><span id="l16.94">   while ( ( *++d = *++s ) != 0 )</span>
<a href="#l16.95"></a><span id="l16.95">     /* empty */;</span>
<a href="#l16.96"></a><span id="l16.96"> }</span>
<a href="#l16.97"></a><span id="l16.97"> </span>
<a href="#l16.98"></a><span id="l16.98"> MORK_LIB_IMPL(mork_i4)</span>
<a href="#l16.99"></a><span id="l16.99"> mork_strcmp(const void* inOne, const void* inTwo)</span>
<a href="#l16.100"></a><span id="l16.100"> {</span>
<a href="#l16.101"></a><span id="l16.101" class="difflineminus">-  register const mork_u1* t = (const mork_u1*) inTwo;</span>
<a href="#l16.102"></a><span id="l16.102" class="difflineminus">-  register const mork_u1* s = ((const mork_u1*) inOne);</span>
<a href="#l16.103"></a><span id="l16.103" class="difflineminus">-  register mork_i4 a;</span>
<a href="#l16.104"></a><span id="l16.104" class="difflineminus">-  register mork_i4 b;</span>
<a href="#l16.105"></a><span id="l16.105" class="difflineminus">-  register mork_i4 delta;</span>
<a href="#l16.106"></a><span id="l16.106" class="difflineplus">+  const mork_u1* t = (const mork_u1*) inTwo;</span>
<a href="#l16.107"></a><span id="l16.107" class="difflineplus">+  const mork_u1* s = ((const mork_u1*) inOne);</span>
<a href="#l16.108"></a><span id="l16.108" class="difflineplus">+  mork_i4 a;</span>
<a href="#l16.109"></a><span id="l16.109" class="difflineplus">+  mork_i4 b;</span>
<a href="#l16.110"></a><span id="l16.110" class="difflineplus">+  mork_i4 delta;</span>
<a href="#l16.111"></a><span id="l16.111">   </span>
<a href="#l16.112"></a><span id="l16.112">   do</span>
<a href="#l16.113"></a><span id="l16.113">   {</span>
<a href="#l16.114"></a><span id="l16.114">     a = (mork_i4) *s++;</span>
<a href="#l16.115"></a><span id="l16.115">     b = (mork_i4) *t++;</span>
<a href="#l16.116"></a><span id="l16.116">     delta = a - b;</span>
<a href="#l16.117"></a><span id="l16.117">   }</span>
<a href="#l16.118"></a><span id="l16.118">   while ( !delta &amp;&amp; a &amp;&amp; b );</span>
<a href="#l16.119"></a><span id="l16.119">   </span>
<a href="#l16.120"></a><span id="l16.120">   return delta;</span>
<a href="#l16.121"></a><span id="l16.121"> }</span>
<a href="#l16.122"></a><span id="l16.122"> </span>
<a href="#l16.123"></a><span id="l16.123"> MORK_LIB_IMPL(mork_i4)</span>
<a href="#l16.124"></a><span id="l16.124"> mork_strncmp(const void* inOne, const void* inTwo, mork_size inSize)</span>
<a href="#l16.125"></a><span id="l16.125"> {</span>
<a href="#l16.126"></a><span id="l16.126" class="difflineminus">-  register const mork_u1* t = (const mork_u1*) inTwo;</span>
<a href="#l16.127"></a><span id="l16.127" class="difflineminus">-  register const mork_u1* s = (const mork_u1*) inOne;</span>
<a href="#l16.128"></a><span id="l16.128" class="difflineplus">+  const mork_u1* t = (const mork_u1*) inTwo;</span>
<a href="#l16.129"></a><span id="l16.129" class="difflineplus">+  const mork_u1* s = (const mork_u1*) inOne;</span>
<a href="#l16.130"></a><span id="l16.130">   const mork_u1* end = s + inSize;</span>
<a href="#l16.131"></a><span id="l16.131" class="difflineminus">-  register mork_i4 delta;</span>
<a href="#l16.132"></a><span id="l16.132" class="difflineminus">-  register mork_i4 a;</span>
<a href="#l16.133"></a><span id="l16.133" class="difflineminus">-  register mork_i4 b;</span>
<a href="#l16.134"></a><span id="l16.134" class="difflineplus">+  mork_i4 delta;</span>
<a href="#l16.135"></a><span id="l16.135" class="difflineplus">+  mork_i4 a;</span>
<a href="#l16.136"></a><span id="l16.136" class="difflineplus">+  mork_i4 b;</span>
<a href="#l16.137"></a><span id="l16.137">   </span>
<a href="#l16.138"></a><span id="l16.138">   while ( s &lt; end )</span>
<a href="#l16.139"></a><span id="l16.139">   {</span>
<a href="#l16.140"></a><span id="l16.140">     a = (mork_i4) *s++;</span>
<a href="#l16.141"></a><span id="l16.141">     b = (mork_i4) *t++;</span>
<a href="#l16.142"></a><span id="l16.142">     delta = a - b;</span>
<a href="#l16.143"></a><span id="l16.143">     if ( delta || !a || !b )</span>
<a href="#l16.144"></a><span id="l16.144">       return delta;</span>
<a href="#l16.145"></a><span id="l16.145">   }</span>
<a href="#l16.146"></a><span id="l16.146">   return 0;</span>
<a href="#l16.147"></a><span id="l16.147"> }</span>
<a href="#l16.148"></a><span id="l16.148"> </span>
<a href="#l16.149"></a><span id="l16.149"> MORK_LIB_IMPL(mork_size)</span>
<a href="#l16.150"></a><span id="l16.150"> mork_strlen(const void* inString)</span>
<a href="#l16.151"></a><span id="l16.151"> {</span>
<a href="#l16.152"></a><span id="l16.152">   // back up one first to support preincrement</span>
<a href="#l16.153"></a><span id="l16.153" class="difflineminus">-  register const mork_u1* s = ((const mork_u1*) inString) - 1;</span>
<a href="#l16.154"></a><span id="l16.154" class="difflineplus">+  const mork_u1* s = ((const mork_u1*) inString) - 1;</span>
<a href="#l16.155"></a><span id="l16.155">   while ( *++s ) // preincrement is cheapest</span>
<a href="#l16.156"></a><span id="l16.156">     /* empty */;</span>
<a href="#l16.157"></a><span id="l16.157">   </span>
<a href="#l16.158"></a><span id="l16.158">   return s - ((const mork_u1*) inString); // distance from original address</span>
<a href="#l16.159"></a><span id="l16.159"> }</span>
<a href="#l16.160"></a><span id="l16.160"> </span>
<a href="#l16.161"></a><span id="l16.161"> #endif /*MORK_PROVIDE_STDLIB*/</span>
<a href="#l16.162"></a><span id="l16.162"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/db/mork/src/morkCursor.cpp</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/db/mork/src/morkCursor.cpp</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -60,29 +60,24 @@ morkCursor::morkCursor(morkEnv* ev,</span>
<a href="#l17.4"></a><span id="l17.4">     mNode_Derived = morkDerived_kCursor;</span>
<a href="#l17.5"></a><span id="l17.5"> }</span>
<a href="#l17.6"></a><span id="l17.6"> </span>
<a href="#l17.7"></a><span id="l17.7"> NS_IMPL_ISUPPORTS_INHERITED(morkCursor, morkObject, nsIMdbCursor)</span>
<a href="#l17.8"></a><span id="l17.8"> </span>
<a href="#l17.9"></a><span id="l17.9"> /*public non-poly*/ void</span>
<a href="#l17.10"></a><span id="l17.10"> morkCursor::CloseCursor(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l17.11"></a><span id="l17.11"> {</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineminus">-  if ( this )</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineminus">-  {</span>
<a href="#l17.14"></a><span id="l17.14">     if ( this-&gt;IsNode() )</span>
<a href="#l17.15"></a><span id="l17.15">     {</span>
<a href="#l17.16"></a><span id="l17.16">       mCursor_Seed = 0;</span>
<a href="#l17.17"></a><span id="l17.17">       mCursor_Pos = -1;</span>
<a href="#l17.18"></a><span id="l17.18">       this-&gt;MarkShut();</span>
<a href="#l17.19"></a><span id="l17.19">     }</span>
<a href="#l17.20"></a><span id="l17.20">     else</span>
<a href="#l17.21"></a><span id="l17.21">       this-&gt;NonNodeError(ev);</span>
<a href="#l17.22"></a><span id="l17.22" class="difflineminus">-  }</span>
<a href="#l17.23"></a><span id="l17.23" class="difflineminus">-  else</span>
<a href="#l17.24"></a><span id="l17.24" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l17.25"></a><span id="l17.25"> }</span>
<a href="#l17.26"></a><span id="l17.26"> </span>
<a href="#l17.27"></a><span id="l17.27"> // { ----- begin ref counting for well-behaved cyclic graphs -----</span>
<a href="#l17.28"></a><span id="l17.28"> NS_IMETHODIMP</span>
<a href="#l17.29"></a><span id="l17.29"> morkCursor::GetWeakRefCount(nsIMdbEnv* mev, // weak refs</span>
<a href="#l17.30"></a><span id="l17.30">   mdb_count* outCount)</span>
<a href="#l17.31"></a><span id="l17.31"> {</span>
<a href="#l17.32"></a><span id="l17.32">   *outCount = WeakRefsOnly();</span>
<a href="#l17.33"></a><span id="l17.33" class="difflineat">@@ -97,36 +92,53 @@ morkCursor::GetStrongRefCount(nsIMdbEnv*</span>
<a href="#l17.34"></a><span id="l17.34"> }</span>
<a href="#l17.35"></a><span id="l17.35"> // ### TODO - clean up this cast, if required</span>
<a href="#l17.36"></a><span id="l17.36"> NS_IMETHODIMP</span>
<a href="#l17.37"></a><span id="l17.37"> morkCursor::AddWeakRef(nsIMdbEnv* mev)</span>
<a href="#l17.38"></a><span id="l17.38"> {</span>
<a href="#l17.39"></a><span id="l17.39">   // XXX Casting mork_refs to nsresult</span>
<a href="#l17.40"></a><span id="l17.40">   return static_cast&lt;nsresult&gt;(morkNode::AddWeakRef((morkEnv *) mev));</span>
<a href="#l17.41"></a><span id="l17.41"> }</span>
<a href="#l17.42"></a><span id="l17.42" class="difflineplus">+</span>
<a href="#l17.43"></a><span id="l17.43" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l17.44"></a><span id="l17.44" class="difflineplus">+NS_IMETHODIMP_(mork_uses)</span>
<a href="#l17.45"></a><span id="l17.45" class="difflineplus">+morkCursor::AddStrongRef(morkEnv* mev)</span>
<a href="#l17.46"></a><span id="l17.46" class="difflineplus">+{</span>
<a href="#l17.47"></a><span id="l17.47" class="difflineplus">+  return morkNode::AddStrongRef(mev);</span>
<a href="#l17.48"></a><span id="l17.48" class="difflineplus">+}</span>
<a href="#l17.49"></a><span id="l17.49" class="difflineplus">+#endif</span>
<a href="#l17.50"></a><span id="l17.50" class="difflineplus">+</span>
<a href="#l17.51"></a><span id="l17.51"> NS_IMETHODIMP_(mork_uses)</span>
<a href="#l17.52"></a><span id="l17.52"> morkCursor::AddStrongRef(nsIMdbEnv* mev)</span>
<a href="#l17.53"></a><span id="l17.53"> {</span>
<a href="#l17.54"></a><span id="l17.54">   return morkNode::AddStrongRef((morkEnv *) mev);</span>
<a href="#l17.55"></a><span id="l17.55"> }</span>
<a href="#l17.56"></a><span id="l17.56"> </span>
<a href="#l17.57"></a><span id="l17.57"> NS_IMETHODIMP</span>
<a href="#l17.58"></a><span id="l17.58"> morkCursor::CutWeakRef(nsIMdbEnv* mev)</span>
<a href="#l17.59"></a><span id="l17.59"> {</span>
<a href="#l17.60"></a><span id="l17.60">   // XXX Casting mork_refs to nsresult</span>
<a href="#l17.61"></a><span id="l17.61">   return static_cast&lt;nsresult&gt;(morkNode::CutWeakRef((morkEnv *) mev));</span>
<a href="#l17.62"></a><span id="l17.62"> }</span>
<a href="#l17.63"></a><span id="l17.63" class="difflineplus">+</span>
<a href="#l17.64"></a><span id="l17.64" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l17.65"></a><span id="l17.65" class="difflineplus">+NS_IMETHODIMP_(mork_uses)</span>
<a href="#l17.66"></a><span id="l17.66" class="difflineplus">+morkCursor::CutStrongRef(morkEnv* mev)</span>
<a href="#l17.67"></a><span id="l17.67" class="difflineplus">+{</span>
<a href="#l17.68"></a><span id="l17.68" class="difflineplus">+  return morkNode::CutStrongRef(mev);</span>
<a href="#l17.69"></a><span id="l17.69" class="difflineplus">+}</span>
<a href="#l17.70"></a><span id="l17.70" class="difflineplus">+#endif</span>
<a href="#l17.71"></a><span id="l17.71" class="difflineplus">+</span>
<a href="#l17.72"></a><span id="l17.72"> NS_IMETHODIMP</span>
<a href="#l17.73"></a><span id="l17.73"> morkCursor::CutStrongRef(nsIMdbEnv* mev)</span>
<a href="#l17.74"></a><span id="l17.74"> {</span>
<a href="#l17.75"></a><span id="l17.75">   // XXX Casting mork_uses to nsresult</span>
<a href="#l17.76"></a><span id="l17.76">   return static_cast&lt;nsresult&gt;(morkNode::CutStrongRef((morkEnv *) mev));</span>
<a href="#l17.77"></a><span id="l17.77"> }</span>
<a href="#l17.78"></a><span id="l17.78"> </span>
<a href="#l17.79"></a><span id="l17.79" class="difflineminus">-  </span>
<a href="#l17.80"></a><span id="l17.80"> NS_IMETHODIMP</span>
<a href="#l17.81"></a><span id="l17.81"> morkCursor::CloseMdbObject(nsIMdbEnv* mev)</span>
<a href="#l17.82"></a><span id="l17.82"> {</span>
<a href="#l17.83"></a><span id="l17.83">   return morkNode::CloseMdbObject((morkEnv *) mev);</span>
<a href="#l17.84"></a><span id="l17.84"> }</span>
<a href="#l17.85"></a><span id="l17.85"> </span>
<a href="#l17.86"></a><span id="l17.86"> NS_IMETHODIMP</span>
<a href="#l17.87"></a><span id="l17.87"> morkCursor::IsOpenMdbObject(nsIMdbEnv* mev, mdb_bool* outOpen)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/db/mork/src/morkCursor.h</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/db/mork/src/morkCursor.h</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -33,63 +33,71 @@ class morkCursor : public morkObject, pu</span>
<a href="#l18.4"></a><span id="l18.4"> </span>
<a href="#l18.5"></a><span id="l18.5">   // mork_color   mBead_Color;   // ID for this bead</span>
<a href="#l18.6"></a><span id="l18.6">   // morkHandle*  mObject_Handle;  // weak ref to handle for this object</span>
<a href="#l18.7"></a><span id="l18.7"> </span>
<a href="#l18.8"></a><span id="l18.8"> public: // state is public because the entire Mork system is private</span>
<a href="#l18.9"></a><span id="l18.9">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l18.10"></a><span id="l18.10"> </span>
<a href="#l18.11"></a><span id="l18.11">   // { ----- begin attribute methods -----</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineminus">-  NS_IMETHOD IsFrozenMdbObject(nsIMdbEnv* ev, mdb_bool* outIsReadonly);</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+  NS_IMETHOD IsFrozenMdbObject(nsIMdbEnv* ev, mdb_bool* outIsReadonly) override;</span>
<a href="#l18.14"></a><span id="l18.14">   // same as nsIMdbPort::GetIsPortReadonly() when this object is inside a port.</span>
<a href="#l18.15"></a><span id="l18.15">   // } ----- end attribute methods -----</span>
<a href="#l18.16"></a><span id="l18.16"> </span>
<a href="#l18.17"></a><span id="l18.17">   // { ----- begin ref counting for well-behaved cyclic graphs -----</span>
<a href="#l18.18"></a><span id="l18.18">   NS_IMETHOD GetWeakRefCount(nsIMdbEnv* ev, // weak refs</span>
<a href="#l18.19"></a><span id="l18.19" class="difflineminus">-    mdb_count* outCount);  </span>
<a href="#l18.20"></a><span id="l18.20" class="difflineplus">+    mdb_count* outCount) override;</span>
<a href="#l18.21"></a><span id="l18.21">   NS_IMETHOD GetStrongRefCount(nsIMdbEnv* ev, // strong refs</span>
<a href="#l18.22"></a><span id="l18.22" class="difflineminus">-    mdb_count* outCount);</span>
<a href="#l18.23"></a><span id="l18.23" class="difflineplus">+    mdb_count* outCount) override;</span>
<a href="#l18.24"></a><span id="l18.24"> </span>
<a href="#l18.25"></a><span id="l18.25" class="difflineminus">-  NS_IMETHOD AddWeakRef(nsIMdbEnv* ev);</span>
<a href="#l18.26"></a><span id="l18.26" class="difflineminus">-    NS_IMETHOD_(mork_uses) AddStrongRef(nsIMdbEnv* ev);</span>
<a href="#l18.27"></a><span id="l18.27" class="difflineplus">+  NS_IMETHOD AddWeakRef(nsIMdbEnv* ev) override;</span>
<a href="#l18.28"></a><span id="l18.28" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l18.29"></a><span id="l18.29" class="difflineplus">+  // The first declaration of AddStrongRef is to suppress -Werror,-Woverloaded-virtual.</span>
<a href="#l18.30"></a><span id="l18.30" class="difflineplus">+  NS_IMETHOD_(mork_uses) AddStrongRef(morkEnv* ev) override;</span>
<a href="#l18.31"></a><span id="l18.31" class="difflineplus">+#endif</span>
<a href="#l18.32"></a><span id="l18.32" class="difflineplus">+  NS_IMETHOD_(mork_uses) AddStrongRef(nsIMdbEnv* ev) override;</span>
<a href="#l18.33"></a><span id="l18.33"> </span>
<a href="#l18.34"></a><span id="l18.34" class="difflineminus">-  NS_IMETHOD CutWeakRef(nsIMdbEnv* ev);</span>
<a href="#l18.35"></a><span id="l18.35" class="difflineminus">-  NS_IMETHOD CutStrongRef(nsIMdbEnv* ev);</span>
<a href="#l18.36"></a><span id="l18.36" class="difflineminus">-  </span>
<a href="#l18.37"></a><span id="l18.37" class="difflineminus">-  NS_IMETHOD CloseMdbObject(nsIMdbEnv* ev); // called at strong refs zero</span>
<a href="#l18.38"></a><span id="l18.38" class="difflineminus">-  NS_IMETHOD IsOpenMdbObject(nsIMdbEnv* ev, mdb_bool* outOpen);</span>
<a href="#l18.39"></a><span id="l18.39" class="difflineplus">+  NS_IMETHOD CutWeakRef(nsIMdbEnv* ev) override;</span>
<a href="#l18.40"></a><span id="l18.40" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l18.41"></a><span id="l18.41" class="difflineplus">+  // The first declaration of CutStrongRef is to suppress -Werror,-Woverloaded-virtual.</span>
<a href="#l18.42"></a><span id="l18.42" class="difflineplus">+  NS_IMETHOD_(mork_uses) CutStrongRef(morkEnv* ev) override;</span>
<a href="#l18.43"></a><span id="l18.43" class="difflineplus">+#endif</span>
<a href="#l18.44"></a><span id="l18.44" class="difflineplus">+  NS_IMETHOD CutStrongRef(nsIMdbEnv* ev) override;</span>
<a href="#l18.45"></a><span id="l18.45" class="difflineplus">+</span>
<a href="#l18.46"></a><span id="l18.46" class="difflineplus">+  NS_IMETHOD CloseMdbObject(nsIMdbEnv* ev) override; // called at strong refs zero</span>
<a href="#l18.47"></a><span id="l18.47" class="difflineplus">+  NS_IMETHOD IsOpenMdbObject(nsIMdbEnv* ev, mdb_bool* outOpen) override;</span>
<a href="#l18.48"></a><span id="l18.48">   // } ----- end ref counting -----</span>
<a href="#l18.49"></a><span id="l18.49">   </span>
<a href="#l18.50"></a><span id="l18.50"> // } ===== end nsIMdbObject methods =====</span>
<a href="#l18.51"></a><span id="l18.51"> </span>
<a href="#l18.52"></a><span id="l18.52"> // { ===== begin nsIMdbCursor methods =====</span>
<a href="#l18.53"></a><span id="l18.53"> </span>
<a href="#l18.54"></a><span id="l18.54">   // { ----- begin attribute methods -----</span>
<a href="#l18.55"></a><span id="l18.55" class="difflineminus">-  NS_IMETHOD GetCount(nsIMdbEnv* ev, mdb_count* outCount); // readonly</span>
<a href="#l18.56"></a><span id="l18.56" class="difflineminus">-  NS_IMETHOD GetSeed(nsIMdbEnv* ev, mdb_seed* outSeed);    // readonly</span>
<a href="#l18.57"></a><span id="l18.57" class="difflineminus">-  </span>
<a href="#l18.58"></a><span id="l18.58" class="difflineminus">-  NS_IMETHOD SetPos(nsIMdbEnv* ev, mdb_pos inPos);   // mutable</span>
<a href="#l18.59"></a><span id="l18.59" class="difflineminus">-  NS_IMETHOD GetPos(nsIMdbEnv* ev, mdb_pos* outPos);</span>
<a href="#l18.60"></a><span id="l18.60" class="difflineminus">-  </span>
<a href="#l18.61"></a><span id="l18.61" class="difflineminus">-  NS_IMETHOD SetDoFailOnSeedOutOfSync(nsIMdbEnv* ev, mdb_bool inFail);</span>
<a href="#l18.62"></a><span id="l18.62" class="difflineminus">-  NS_IMETHOD GetDoFailOnSeedOutOfSync(nsIMdbEnv* ev, mdb_bool* outFail);</span>
<a href="#l18.63"></a><span id="l18.63" class="difflineplus">+  NS_IMETHOD GetCount(nsIMdbEnv* ev, mdb_count* outCount) override; // readonly</span>
<a href="#l18.64"></a><span id="l18.64" class="difflineplus">+  NS_IMETHOD GetSeed(nsIMdbEnv* ev, mdb_seed* outSeed) override;    // readonly</span>
<a href="#l18.65"></a><span id="l18.65" class="difflineplus">+</span>
<a href="#l18.66"></a><span id="l18.66" class="difflineplus">+  NS_IMETHOD SetPos(nsIMdbEnv* ev, mdb_pos inPos) override;   // mutable</span>
<a href="#l18.67"></a><span id="l18.67" class="difflineplus">+  NS_IMETHOD GetPos(nsIMdbEnv* ev, mdb_pos* outPos) override;</span>
<a href="#l18.68"></a><span id="l18.68" class="difflineplus">+</span>
<a href="#l18.69"></a><span id="l18.69" class="difflineplus">+  NS_IMETHOD SetDoFailOnSeedOutOfSync(nsIMdbEnv* ev, mdb_bool inFail) override;</span>
<a href="#l18.70"></a><span id="l18.70" class="difflineplus">+  NS_IMETHOD GetDoFailOnSeedOutOfSync(nsIMdbEnv* ev, mdb_bool* outFail) override;</span>
<a href="#l18.71"></a><span id="l18.71">   // } ----- end attribute methods -----</span>
<a href="#l18.72"></a><span id="l18.72"> </span>
<a href="#l18.73"></a><span id="l18.73"> // } ===== end nsIMdbCursor methods =====</span>
<a href="#l18.74"></a><span id="l18.74">     </span>
<a href="#l18.75"></a><span id="l18.75">   // } ----- end attribute methods -----</span>
<a href="#l18.76"></a><span id="l18.76"> </span>
<a href="#l18.77"></a><span id="l18.77">   mork_seed  mCursor_Seed;</span>
<a href="#l18.78"></a><span id="l18.78">   mork_pos   mCursor_Pos;</span>
<a href="#l18.79"></a><span id="l18.79">   mork_bool  mCursor_DoFailOnSeedOutOfSync;</span>
<a href="#l18.80"></a><span id="l18.80">   mork_u1    mCursor_Pad[ 3 ]; // explicitly pad to u4 alignment</span>
<a href="#l18.81"></a><span id="l18.81">   </span>
<a href="#l18.82"></a><span id="l18.82"> // { ===== begin morkNode interface =====</span>
<a href="#l18.83"></a><span id="l18.83"> public: // morkNode virtual methods</span>
<a href="#l18.84"></a><span id="l18.84" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseCursor() only if open</span>
<a href="#l18.85"></a><span id="l18.85" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseCursor() only if open</span>
<a href="#l18.86"></a><span id="l18.86">   </span>
<a href="#l18.87"></a><span id="l18.87"> public: // morkCursor construction &amp; destruction</span>
<a href="#l18.88"></a><span id="l18.88">   morkCursor(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap);</span>
<a href="#l18.89"></a><span id="l18.89">   void CloseCursor(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l18.90"></a><span id="l18.90"> </span>
<a href="#l18.91"></a><span id="l18.91"> protected:</span>
<a href="#l18.92"></a><span id="l18.92">   virtual ~morkCursor(); // assert that CloseCursor() executed earlier</span>
<a href="#l18.93"></a><span id="l18.93"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/db/mork/src/morkDeque.cpp</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/db/mork/src/morkDeque.cpp</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -52,34 +52,28 @@ which are used interchangeably with the </span>
<a href="#l19.4"></a><span id="l19.4"> morkNext::morkNext() : mNext_Link( 0 )</span>
<a href="#l19.5"></a><span id="l19.5"> {</span>
<a href="#l19.6"></a><span id="l19.6"> }</span>
<a href="#l19.7"></a><span id="l19.7"> </span>
<a href="#l19.8"></a><span id="l19.8"> /*static*/ void*</span>
<a href="#l19.9"></a><span id="l19.9"> morkNext::MakeNewNext(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev)</span>
<a href="#l19.10"></a><span id="l19.10"> {</span>
<a href="#l19.11"></a><span id="l19.11">   void* next = 0;</span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-  if ( &amp;ioHeap )</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineminus">-  {</span>
<a href="#l19.14"></a><span id="l19.14">     ioHeap.Alloc(ev-&gt;AsMdbEnv(), inSize, (void**) &amp;next);</span>
<a href="#l19.15"></a><span id="l19.15">     if ( !next )</span>
<a href="#l19.16"></a><span id="l19.16">       ev-&gt;OutOfMemoryError();</span>
<a href="#l19.17"></a><span id="l19.17" class="difflineminus">-  }</span>
<a href="#l19.18"></a><span id="l19.18" class="difflineminus">-  else</span>
<a href="#l19.19"></a><span id="l19.19" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l19.20"></a><span id="l19.20" class="difflineminus">-  </span>
<a href="#l19.21"></a><span id="l19.21" class="difflineplus">+</span>
<a href="#l19.22"></a><span id="l19.22">   return next;</span>
<a href="#l19.23"></a><span id="l19.23"> }</span>
<a href="#l19.24"></a><span id="l19.24"> </span>
<a href="#l19.25"></a><span id="l19.25"> /*static*/</span>
<a href="#l19.26"></a><span id="l19.26"> void morkNext::ZapOldNext(morkEnv* ev, nsIMdbHeap* ioHeap)</span>
<a href="#l19.27"></a><span id="l19.27"> {</span>
<a href="#l19.28"></a><span id="l19.28">   if ( ioHeap )</span>
<a href="#l19.29"></a><span id="l19.29">   {</span>
<a href="#l19.30"></a><span id="l19.30" class="difflineminus">-    if ( this )</span>
<a href="#l19.31"></a><span id="l19.31">       ioHeap-&gt;Free(ev-&gt;AsMdbEnv(), this);</span>
<a href="#l19.32"></a><span id="l19.32">   }</span>
<a href="#l19.33"></a><span id="l19.33">   else</span>
<a href="#l19.34"></a><span id="l19.34">     ev-&gt;NilPointerError();</span>
<a href="#l19.35"></a><span id="l19.35"> }</span>
<a href="#l19.36"></a><span id="l19.36"> </span>
<a href="#l19.37"></a><span id="l19.37"> /*=============================================================================</span>
<a href="#l19.38"></a><span id="l19.38">  * morkList: simple, singly-linked list</span>
<a href="#l19.39"></a><span id="l19.39" class="difflineat">@@ -169,34 +163,28 @@ void morkList::PushTail(morkNext* ioLink</span>
<a href="#l19.40"></a><span id="l19.40"> morkLink::morkLink() : mLink_Next( 0 ), mLink_Prev( 0 )</span>
<a href="#l19.41"></a><span id="l19.41"> {</span>
<a href="#l19.42"></a><span id="l19.42"> }</span>
<a href="#l19.43"></a><span id="l19.43"> </span>
<a href="#l19.44"></a><span id="l19.44"> /*static*/ void*</span>
<a href="#l19.45"></a><span id="l19.45"> morkLink::MakeNewLink(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev)</span>
<a href="#l19.46"></a><span id="l19.46"> {</span>
<a href="#l19.47"></a><span id="l19.47">   void* alink = 0;</span>
<a href="#l19.48"></a><span id="l19.48" class="difflineminus">-  if ( &amp;ioHeap )</span>
<a href="#l19.49"></a><span id="l19.49" class="difflineminus">-  {</span>
<a href="#l19.50"></a><span id="l19.50">     ioHeap.Alloc(ev-&gt;AsMdbEnv(), inSize, (void**) &amp;alink);</span>
<a href="#l19.51"></a><span id="l19.51">     if ( !alink )</span>
<a href="#l19.52"></a><span id="l19.52">       ev-&gt;OutOfMemoryError();</span>
<a href="#l19.53"></a><span id="l19.53" class="difflineminus">-  }</span>
<a href="#l19.54"></a><span id="l19.54" class="difflineminus">-  else</span>
<a href="#l19.55"></a><span id="l19.55" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l19.56"></a><span id="l19.56" class="difflineminus">-  </span>
<a href="#l19.57"></a><span id="l19.57" class="difflineplus">+</span>
<a href="#l19.58"></a><span id="l19.58">   return alink;</span>
<a href="#l19.59"></a><span id="l19.59"> }</span>
<a href="#l19.60"></a><span id="l19.60"> </span>
<a href="#l19.61"></a><span id="l19.61"> /*static*/</span>
<a href="#l19.62"></a><span id="l19.62"> void morkLink::ZapOldLink(morkEnv* ev, nsIMdbHeap* ioHeap)</span>
<a href="#l19.63"></a><span id="l19.63"> {</span>
<a href="#l19.64"></a><span id="l19.64">   if ( ioHeap )</span>
<a href="#l19.65"></a><span id="l19.65">   {</span>
<a href="#l19.66"></a><span id="l19.66" class="difflineminus">-    if ( this )</span>
<a href="#l19.67"></a><span id="l19.67">       ioHeap-&gt;Free(ev-&gt;AsMdbEnv(), this);</span>
<a href="#l19.68"></a><span id="l19.68">   }</span>
<a href="#l19.69"></a><span id="l19.69">   else</span>
<a href="#l19.70"></a><span id="l19.70">     ev-&gt;NilPointerError();</span>
<a href="#l19.71"></a><span id="l19.71"> }</span>
<a href="#l19.72"></a><span id="l19.72">   </span>
<a href="#l19.73"></a><span id="l19.73"> /*=============================================================================</span>
<a href="#l19.74"></a><span id="l19.74">  * morkDeque: doubly linked list modeled after VAX queue instructions</span>
<a href="#l19.75"></a><span id="l19.75" class="difflineat">@@ -239,62 +227,62 @@ morkDeque::RemoveLast() /*i*/</span>
<a href="#l19.76"></a><span id="l19.76"> }</span>
<a href="#l19.77"></a><span id="l19.77"> </span>
<a href="#l19.78"></a><span id="l19.78"> /*| At: </span>
<a href="#l19.79"></a><span id="l19.79"> |*/</span>
<a href="#l19.80"></a><span id="l19.80"> morkLink*</span>
<a href="#l19.81"></a><span id="l19.81"> morkDeque::At(mork_pos index) const /*i*/</span>
<a href="#l19.82"></a><span id="l19.82">   /* indexes are one based (and not zero based) */</span>
<a href="#l19.83"></a><span id="l19.83"> { </span>
<a href="#l19.84"></a><span id="l19.84" class="difflineminus">-  register mork_num count = 0;</span>
<a href="#l19.85"></a><span id="l19.85" class="difflineminus">-  register morkLink* alink;</span>
<a href="#l19.86"></a><span id="l19.86" class="difflineplus">+  mork_num count = 0;</span>
<a href="#l19.87"></a><span id="l19.87" class="difflineplus">+  morkLink* alink;</span>
<a href="#l19.88"></a><span id="l19.88">   for ( alink = this-&gt;First(); alink; alink = this-&gt;After(alink) )</span>
<a href="#l19.89"></a><span id="l19.89">   {</span>
<a href="#l19.90"></a><span id="l19.90">     if ( ++count == (mork_num) index )</span>
<a href="#l19.91"></a><span id="l19.91">       break;</span>
<a href="#l19.92"></a><span id="l19.92">   }</span>
<a href="#l19.93"></a><span id="l19.93">   return alink;</span>
<a href="#l19.94"></a><span id="l19.94"> }</span>
<a href="#l19.95"></a><span id="l19.95"> </span>
<a href="#l19.96"></a><span id="l19.96"> /*| IndexOf: </span>
<a href="#l19.97"></a><span id="l19.97"> |*/</span>
<a href="#l19.98"></a><span id="l19.98"> mork_pos</span>
<a href="#l19.99"></a><span id="l19.99"> morkDeque::IndexOf(const morkLink* member) const /*i*/</span>
<a href="#l19.100"></a><span id="l19.100">   /* indexes are one based (and not zero based) */</span>
<a href="#l19.101"></a><span id="l19.101">   /* zero means member is not in deque */</span>
<a href="#l19.102"></a><span id="l19.102"> { </span>
<a href="#l19.103"></a><span id="l19.103" class="difflineminus">-  register mork_num count = 0;</span>
<a href="#l19.104"></a><span id="l19.104" class="difflineminus">-  register const morkLink* alink;</span>
<a href="#l19.105"></a><span id="l19.105" class="difflineplus">+  mork_num count = 0;</span>
<a href="#l19.106"></a><span id="l19.106" class="difflineplus">+  const morkLink* alink;</span>
<a href="#l19.107"></a><span id="l19.107">   for ( alink = this-&gt;First(); alink; alink = this-&gt;After(alink) )</span>
<a href="#l19.108"></a><span id="l19.108">   {</span>
<a href="#l19.109"></a><span id="l19.109">     ++count;</span>
<a href="#l19.110"></a><span id="l19.110">     if ( member == alink )</span>
<a href="#l19.111"></a><span id="l19.111">       return (mork_pos) count;</span>
<a href="#l19.112"></a><span id="l19.112">   }</span>
<a href="#l19.113"></a><span id="l19.113">   return 0;</span>
<a href="#l19.114"></a><span id="l19.114"> }</span>
<a href="#l19.115"></a><span id="l19.115"> </span>
<a href="#l19.116"></a><span id="l19.116"> /*| Length: </span>
<a href="#l19.117"></a><span id="l19.117"> |*/</span>
<a href="#l19.118"></a><span id="l19.118"> mork_num</span>
<a href="#l19.119"></a><span id="l19.119"> morkDeque::Length() const /*i*/</span>
<a href="#l19.120"></a><span id="l19.120"> { </span>
<a href="#l19.121"></a><span id="l19.121" class="difflineminus">-  register mork_num count = 0;</span>
<a href="#l19.122"></a><span id="l19.122" class="difflineminus">-  register morkLink* alink;</span>
<a href="#l19.123"></a><span id="l19.123" class="difflineplus">+  mork_num count = 0;</span>
<a href="#l19.124"></a><span id="l19.124" class="difflineplus">+  morkLink* alink;</span>
<a href="#l19.125"></a><span id="l19.125">   for ( alink = this-&gt;First(); alink; alink = this-&gt;After(alink) )</span>
<a href="#l19.126"></a><span id="l19.126">     ++count;</span>
<a href="#l19.127"></a><span id="l19.127">   return count;</span>
<a href="#l19.128"></a><span id="l19.128"> }</span>
<a href="#l19.129"></a><span id="l19.129"> </span>
<a href="#l19.130"></a><span id="l19.130"> /*| LengthCompare: </span>
<a href="#l19.131"></a><span id="l19.131"> |*/</span>
<a href="#l19.132"></a><span id="l19.132"> int</span>
<a href="#l19.133"></a><span id="l19.133"> morkDeque::LengthCompare(mork_num c) const /*i*/</span>
<a href="#l19.134"></a><span id="l19.134"> { </span>
<a href="#l19.135"></a><span id="l19.135" class="difflineminus">-  register mork_num count = 0;</span>
<a href="#l19.136"></a><span id="l19.136" class="difflineminus">-  register const morkLink* alink;</span>
<a href="#l19.137"></a><span id="l19.137" class="difflineplus">+  mork_num count = 0;</span>
<a href="#l19.138"></a><span id="l19.138" class="difflineplus">+  const morkLink* alink;</span>
<a href="#l19.139"></a><span id="l19.139">   for ( alink = this-&gt;First(); alink; alink = this-&gt;After(alink) )</span>
<a href="#l19.140"></a><span id="l19.140">   {</span>
<a href="#l19.141"></a><span id="l19.141">     if ( ++count &gt; c )</span>
<a href="#l19.142"></a><span id="l19.142">       return 1;</span>
<a href="#l19.143"></a><span id="l19.143">   }</span>
<a href="#l19.144"></a><span id="l19.144">   return ( count == c )? 0 : -1;</span>
<a href="#l19.145"></a><span id="l19.145"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/db/mork/src/morkEnv.cpp</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/db/mork/src/morkEnv.cpp</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -158,18 +158,16 @@ morkEnv::morkEnv(morkEnv* ev, /*i*/</span>
<a href="#l20.4"></a><span id="l20.4">   else</span>
<a href="#l20.5"></a><span id="l20.5">     ev-&gt;NilPointerError();</span>
<a href="#l20.6"></a><span id="l20.6"> }</span>
<a href="#l20.7"></a><span id="l20.7"> </span>
<a href="#l20.8"></a><span id="l20.8"> NS_IMPL_ISUPPORTS_INHERITED(morkEnv, morkObject, nsIMdbEnv)</span>
<a href="#l20.9"></a><span id="l20.9"> /*public non-poly*/ void</span>
<a href="#l20.10"></a><span id="l20.10"> morkEnv::CloseEnv(morkEnv* ev) /*i*/ // called by CloseMorkNode();</span>
<a href="#l20.11"></a><span id="l20.11"> {</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineminus">-  if ( this )</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineminus">-  {</span>
<a href="#l20.14"></a><span id="l20.14">     if ( this-&gt;IsNode() )</span>
<a href="#l20.15"></a><span id="l20.15">     {</span>
<a href="#l20.16"></a><span id="l20.16">       // $$$ release mEnv_SelfAsMdbEnv??</span>
<a href="#l20.17"></a><span id="l20.17">       // $$$ release mEnv_ErrorHook??</span>
<a href="#l20.18"></a><span id="l20.18">       </span>
<a href="#l20.19"></a><span id="l20.19">       mEnv_SelfAsMdbEnv = 0;</span>
<a href="#l20.20"></a><span id="l20.20">       mEnv_ErrorHook = 0;</span>
<a href="#l20.21"></a><span id="l20.21">       </span>
<a href="#l20.22"></a><span id="l20.22" class="difflineat">@@ -192,19 +190,16 @@ morkEnv::CloseEnv(morkEnv* ev) /*i*/ // </span>
<a href="#l20.23"></a><span id="l20.23">         // how do we free this? might need to get rid of asserts.</span>
<a href="#l20.24"></a><span id="l20.24">       }</span>
<a href="#l20.25"></a><span id="l20.25">       // mEnv_Factory is NOT refcounted</span>
<a href="#l20.26"></a><span id="l20.26">       </span>
<a href="#l20.27"></a><span id="l20.27">       this-&gt;MarkShut();</span>
<a href="#l20.28"></a><span id="l20.28">     }</span>
<a href="#l20.29"></a><span id="l20.29">     else</span>
<a href="#l20.30"></a><span id="l20.30">       this-&gt;NonNodeError(ev);</span>
<a href="#l20.31"></a><span id="l20.31" class="difflineminus">-  }</span>
<a href="#l20.32"></a><span id="l20.32" class="difflineminus">-  else</span>
<a href="#l20.33"></a><span id="l20.33" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l20.34"></a><span id="l20.34"> }</span>
<a href="#l20.35"></a><span id="l20.35"> </span>
<a href="#l20.36"></a><span id="l20.36"> // } ===== end morkNode methods =====</span>
<a href="#l20.37"></a><span id="l20.37"> // ````` ````` ````` ````` ````` </span>
<a href="#l20.38"></a><span id="l20.38"> </span>
<a href="#l20.39"></a><span id="l20.39"> mork_size</span>
<a href="#l20.40"></a><span id="l20.40"> morkEnv::OidAsHex(void* outBuf, const mdbOid&amp; inOid)</span>
<a href="#l20.41"></a><span id="l20.41"> // sprintf(buf, &quot;%lX:^%lX&quot;, (long) inOid.mOid_Id, (long) inOid.mOid_Scope);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/db/mork/src/morkEnv.h</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/db/mork/src/morkEnv.h</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -85,46 +85,45 @@ public: // state is public because the e</span>
<a href="#l21.4"></a><span id="l21.4">   mork_bool         mEnv_DoTrace;</span>
<a href="#l21.5"></a><span id="l21.5">   mork_able         mEnv_AutoClear;</span>
<a href="#l21.6"></a><span id="l21.6">   mork_bool         mEnv_ShouldAbort;</span>
<a href="#l21.7"></a><span id="l21.7">   mork_bool         mEnv_BeVerbose;</span>
<a href="#l21.8"></a><span id="l21.8">   mork_bool         mEnv_OwnsHeap;</span>
<a href="#l21.9"></a><span id="l21.9">   </span>
<a href="#l21.10"></a><span id="l21.10"> // { ===== begin morkNode interface =====</span>
<a href="#l21.11"></a><span id="l21.11"> public: // morkNode virtual methods</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseEnv() only if open</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseEnv() only if open</span>
<a href="#l21.14"></a><span id="l21.14">   virtual ~morkEnv(); // assert that CloseEnv() executed earlier</span>
<a href="#l21.15"></a><span id="l21.15">   </span>
<a href="#l21.16"></a><span id="l21.16">   // { ----- begin attribute methods -----</span>
<a href="#l21.17"></a><span id="l21.17">   NS_IMETHOD GetErrorCount(mdb_count* outCount,</span>
<a href="#l21.18"></a><span id="l21.18" class="difflineminus">-    mdb_bool* outShouldAbort);</span>
<a href="#l21.19"></a><span id="l21.19" class="difflineplus">+    mdb_bool* outShouldAbort) override;</span>
<a href="#l21.20"></a><span id="l21.20">   NS_IMETHOD GetWarningCount(mdb_count* outCount,</span>
<a href="#l21.21"></a><span id="l21.21" class="difflineminus">-    mdb_bool* outShouldAbort);</span>
<a href="#l21.22"></a><span id="l21.22" class="difflineplus">+    mdb_bool* outShouldAbort) override;</span>
<a href="#l21.23"></a><span id="l21.23">   </span>
<a href="#l21.24"></a><span id="l21.24" class="difflineminus">-  NS_IMETHOD GetEnvBeVerbose(mdb_bool* outBeVerbose);</span>
<a href="#l21.25"></a><span id="l21.25" class="difflineminus">-  NS_IMETHOD SetEnvBeVerbose(mdb_bool inBeVerbose);</span>
<a href="#l21.26"></a><span id="l21.26" class="difflineplus">+  NS_IMETHOD GetEnvBeVerbose(mdb_bool* outBeVerbose) override;</span>
<a href="#l21.27"></a><span id="l21.27" class="difflineplus">+  NS_IMETHOD SetEnvBeVerbose(mdb_bool inBeVerbose) override;</span>
<a href="#l21.28"></a><span id="l21.28">   </span>
<a href="#l21.29"></a><span id="l21.29" class="difflineminus">-  NS_IMETHOD GetDoTrace(mdb_bool* outDoTrace);</span>
<a href="#l21.30"></a><span id="l21.30" class="difflineminus">-  NS_IMETHOD SetDoTrace(mdb_bool inDoTrace);</span>
<a href="#l21.31"></a><span id="l21.31" class="difflineplus">+  NS_IMETHOD GetDoTrace(mdb_bool* outDoTrace) override;</span>
<a href="#l21.32"></a><span id="l21.32" class="difflineplus">+  NS_IMETHOD SetDoTrace(mdb_bool inDoTrace) override;</span>
<a href="#l21.33"></a><span id="l21.33">   </span>
<a href="#l21.34"></a><span id="l21.34" class="difflineminus">-  NS_IMETHOD GetAutoClear(mdb_bool* outAutoClear);</span>
<a href="#l21.35"></a><span id="l21.35" class="difflineminus">-  NS_IMETHOD SetAutoClear(mdb_bool inAutoClear);</span>
<a href="#l21.36"></a><span id="l21.36" class="difflineplus">+  NS_IMETHOD GetAutoClear(mdb_bool* outAutoClear) override;</span>
<a href="#l21.37"></a><span id="l21.37" class="difflineplus">+  NS_IMETHOD SetAutoClear(mdb_bool inAutoClear) override;</span>
<a href="#l21.38"></a><span id="l21.38">   </span>
<a href="#l21.39"></a><span id="l21.39" class="difflineminus">-  NS_IMETHOD GetErrorHook(nsIMdbErrorHook** acqErrorHook);</span>
<a href="#l21.40"></a><span id="l21.40" class="difflineplus">+  NS_IMETHOD GetErrorHook(nsIMdbErrorHook** acqErrorHook) override;</span>
<a href="#l21.41"></a><span id="l21.41">   NS_IMETHOD SetErrorHook(</span>
<a href="#l21.42"></a><span id="l21.42" class="difflineminus">-    nsIMdbErrorHook* ioErrorHook); // becomes referenced</span>
<a href="#l21.43"></a><span id="l21.43" class="difflineplus">+    nsIMdbErrorHook* ioErrorHook) override; // becomes referenced</span>
<a href="#l21.44"></a><span id="l21.44">   </span>
<a href="#l21.45"></a><span id="l21.45" class="difflineminus">-  NS_IMETHOD GetHeap(nsIMdbHeap** acqHeap);</span>
<a href="#l21.46"></a><span id="l21.46" class="difflineminus">-  NS_IMETHOD SetHeap(</span>
<a href="#l21.47"></a><span id="l21.47" class="difflineminus">-    nsIMdbHeap* ioHeap); // becomes referenced</span>
<a href="#l21.48"></a><span id="l21.48" class="difflineplus">+  NS_IMETHOD GetHeap(nsIMdbHeap** acqHeap) override;</span>
<a href="#l21.49"></a><span id="l21.49" class="difflineplus">+  NS_IMETHOD SetHeap(nsIMdbHeap* ioHeap) override; // becomes referenced</span>
<a href="#l21.50"></a><span id="l21.50">   // } ----- end attribute methods -----</span>
<a href="#l21.51"></a><span id="l21.51">   </span>
<a href="#l21.52"></a><span id="l21.52" class="difflineminus">-  NS_IMETHOD ClearErrors(); // clear errors beore re-entering db API</span>
<a href="#l21.53"></a><span id="l21.53" class="difflineminus">-  NS_IMETHOD ClearWarnings(); // clear warnings</span>
<a href="#l21.54"></a><span id="l21.54" class="difflineminus">-  NS_IMETHOD ClearErrorsAndWarnings(); // clear both errors &amp; warnings</span>
<a href="#l21.55"></a><span id="l21.55" class="difflineplus">+  NS_IMETHOD ClearErrors() override; // clear errors beore re-entering db API</span>
<a href="#l21.56"></a><span id="l21.56" class="difflineplus">+  NS_IMETHOD ClearWarnings() override; // clear warnings</span>
<a href="#l21.57"></a><span id="l21.57" class="difflineplus">+  NS_IMETHOD ClearErrorsAndWarnings() override; // clear both errors &amp; warnings</span>
<a href="#l21.58"></a><span id="l21.58"> // } ===== end nsIMdbEnv methods =====</span>
<a href="#l21.59"></a><span id="l21.59"> public: // morkEnv construction &amp; destruction</span>
<a href="#l21.60"></a><span id="l21.60">   morkEnv(const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l21.61"></a><span id="l21.61">     morkFactory* ioFactory, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l21.62"></a><span id="l21.62">   morkEnv(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap, </span>
<a href="#l21.63"></a><span id="l21.63">      nsIMdbEnv* inSelfAsMdbEnv, morkFactory* ioFactory,</span>
<a href="#l21.64"></a><span id="l21.64">      nsIMdbHeap* ioSlotHeap);</span>
<a href="#l21.65"></a><span id="l21.65">   void CloseEnv(morkEnv* ev); // called by CloseMorkNode();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/db/mork/src/morkFactory.cpp</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/db/mork/src/morkFactory.cpp</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -117,29 +117,24 @@ extern &quot;C&quot; nsIMdbFactory* MakeMdbFactory</span>
<a href="#l22.4"></a><span id="l22.4"> {</span>
<a href="#l22.5"></a><span id="l22.5">   return new morkFactory(new orkinHeap());</span>
<a href="#l22.6"></a><span id="l22.6"> }</span>
<a href="#l22.7"></a><span id="l22.7"> </span>
<a href="#l22.8"></a><span id="l22.8"> </span>
<a href="#l22.9"></a><span id="l22.9"> /*public non-poly*/ void</span>
<a href="#l22.10"></a><span id="l22.10"> morkFactory::CloseFactory(morkEnv* ev) /*i*/ // called by CloseMorkNode();</span>
<a href="#l22.11"></a><span id="l22.11"> {</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineminus">-  if ( this )</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineminus">-  {</span>
<a href="#l22.14"></a><span id="l22.14">     if ( this-&gt;IsNode() )</span>
<a href="#l22.15"></a><span id="l22.15">     {</span>
<a href="#l22.16"></a><span id="l22.16">       mFactory_Env.CloseMorkNode(ev);</span>
<a href="#l22.17"></a><span id="l22.17">       this-&gt;CloseObject(ev);</span>
<a href="#l22.18"></a><span id="l22.18">       this-&gt;MarkShut();</span>
<a href="#l22.19"></a><span id="l22.19">     }</span>
<a href="#l22.20"></a><span id="l22.20">     else</span>
<a href="#l22.21"></a><span id="l22.21">       this-&gt;NonNodeError(ev);</span>
<a href="#l22.22"></a><span id="l22.22" class="difflineminus">-  }</span>
<a href="#l22.23"></a><span id="l22.23" class="difflineminus">-  else</span>
<a href="#l22.24"></a><span id="l22.24" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l22.25"></a><span id="l22.25"> }</span>
<a href="#l22.26"></a><span id="l22.26"> </span>
<a href="#l22.27"></a><span id="l22.27"> // } ===== end morkNode methods =====</span>
<a href="#l22.28"></a><span id="l22.28"> // ````` ````` ````` ````` ````` </span>
<a href="#l22.29"></a><span id="l22.29"> </span>
<a href="#l22.30"></a><span id="l22.30"> morkEnv* morkFactory::GetInternalFactoryEnv(nsresult* outErr)</span>
<a href="#l22.31"></a><span id="l22.31"> {</span>
<a href="#l22.32"></a><span id="l22.32">   morkEnv* outEnv = 0;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/db/mork/src/morkFactory.h</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/db/mork/src/morkFactory.h</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -50,115 +50,115 @@ class morkFactory : public morkObject, p</span>
<a href="#l23.4"></a><span id="l23.4"> public: // state is public because the entire Mork system is private</span>
<a href="#l23.5"></a><span id="l23.5"> </span>
<a href="#l23.6"></a><span id="l23.6">   morkEnv        mFactory_Env; // private env instance used internally</span>
<a href="#l23.7"></a><span id="l23.7">   orkinHeap      mFactory_Heap;</span>
<a href="#l23.8"></a><span id="l23.8"> </span>
<a href="#l23.9"></a><span id="l23.9">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l23.10"></a><span id="l23.10"> // { ===== begin morkNode interface =====</span>
<a href="#l23.11"></a><span id="l23.11"> public: // morkFactory virtual methods</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseFactory() only if open</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseFactory() only if open</span>
<a href="#l23.14"></a><span id="l23.14"> </span>
<a href="#l23.15"></a><span id="l23.15"> </span>
<a href="#l23.16"></a><span id="l23.16"> // { ===== begin nsIMdbFactory methods =====</span>
<a href="#l23.17"></a><span id="l23.17"> </span>
<a href="#l23.18"></a><span id="l23.18">   // { ----- begin file methods -----</span>
<a href="#l23.19"></a><span id="l23.19">   NS_IMETHOD OpenOldFile(nsIMdbEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l23.20"></a><span id="l23.20">     const char* inFilePath,</span>
<a href="#l23.21"></a><span id="l23.21" class="difflineminus">-    mdb_bool inFrozen, nsIMdbFile** acqFile);</span>
<a href="#l23.22"></a><span id="l23.22" class="difflineplus">+    mdb_bool inFrozen, nsIMdbFile** acqFile) override;</span>
<a href="#l23.23"></a><span id="l23.23">   // Choose some subclass of nsIMdbFile to instantiate, in order to read</span>
<a href="#l23.24"></a><span id="l23.24">   // (and write if not frozen) the file known by inFilePath.  The file</span>
<a href="#l23.25"></a><span id="l23.25">   // returned should be open and ready for use, and presumably positioned</span>
<a href="#l23.26"></a><span id="l23.26">   // at the first byte position of the file.  The exact manner in which</span>
<a href="#l23.27"></a><span id="l23.27">   // files must be opened is considered a subclass specific detail, and</span>
<a href="#l23.28"></a><span id="l23.28">   // other portions or Mork source code don't want to know how it's done.</span>
<a href="#l23.29"></a><span id="l23.29"> </span>
<a href="#l23.30"></a><span id="l23.30">   NS_IMETHOD CreateNewFile(nsIMdbEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l23.31"></a><span id="l23.31">     const char* inFilePath,</span>
<a href="#l23.32"></a><span id="l23.32" class="difflineminus">-    nsIMdbFile** acqFile);</span>
<a href="#l23.33"></a><span id="l23.33" class="difflineplus">+    nsIMdbFile** acqFile) override;</span>
<a href="#l23.34"></a><span id="l23.34">   // Choose some subclass of nsIMdbFile to instantiate, in order to read</span>
<a href="#l23.35"></a><span id="l23.35">   // (and write if not frozen) the file known by inFilePath.  The file</span>
<a href="#l23.36"></a><span id="l23.36">   // returned should be created and ready for use, and presumably positioned</span>
<a href="#l23.37"></a><span id="l23.37">   // at the first byte position of the file.  The exact manner in which</span>
<a href="#l23.38"></a><span id="l23.38">   // files must be opened is considered a subclass specific detail, and</span>
<a href="#l23.39"></a><span id="l23.39">   // other portions or Mork source code don't want to know how it's done.</span>
<a href="#l23.40"></a><span id="l23.40">   // } ----- end file methods -----</span>
<a href="#l23.41"></a><span id="l23.41"> </span>
<a href="#l23.42"></a><span id="l23.42">   // { ----- begin env methods -----</span>
<a href="#l23.43"></a><span id="l23.43" class="difflineminus">-  NS_IMETHOD MakeEnv(nsIMdbHeap* ioHeap, nsIMdbEnv** acqEnv); // new env</span>
<a href="#l23.44"></a><span id="l23.44" class="difflineplus">+  NS_IMETHOD MakeEnv(nsIMdbHeap* ioHeap, nsIMdbEnv** acqEnv) override; // new env</span>
<a href="#l23.45"></a><span id="l23.45">   // ioHeap can be nil, causing a MakeHeap() style heap instance to be used</span>
<a href="#l23.46"></a><span id="l23.46">   // } ----- end env methods -----</span>
<a href="#l23.47"></a><span id="l23.47"> </span>
<a href="#l23.48"></a><span id="l23.48">   // { ----- begin heap methods -----</span>
<a href="#l23.49"></a><span id="l23.49" class="difflineminus">-  NS_IMETHOD MakeHeap(nsIMdbEnv* ev, nsIMdbHeap** acqHeap); // new heap</span>
<a href="#l23.50"></a><span id="l23.50" class="difflineplus">+  NS_IMETHOD MakeHeap(nsIMdbEnv* ev, nsIMdbHeap** acqHeap) override; // new heap</span>
<a href="#l23.51"></a><span id="l23.51">   // } ----- end heap methods -----</span>
<a href="#l23.52"></a><span id="l23.52"> </span>
<a href="#l23.53"></a><span id="l23.53">   // { ----- begin row methods -----</span>
<a href="#l23.54"></a><span id="l23.54" class="difflineminus">-  NS_IMETHOD MakeRow(nsIMdbEnv* ev, nsIMdbHeap* ioHeap, nsIMdbRow** acqRow); // new row</span>
<a href="#l23.55"></a><span id="l23.55" class="difflineplus">+  NS_IMETHOD MakeRow(nsIMdbEnv* ev, nsIMdbHeap* ioHeap, nsIMdbRow** acqRow) override; // new row</span>
<a href="#l23.56"></a><span id="l23.56">   // ioHeap can be nil, causing the heap associated with ev to be used</span>
<a href="#l23.57"></a><span id="l23.57">   // } ----- end row methods -----</span>
<a href="#l23.58"></a><span id="l23.58" class="difflineminus">-  </span>
<a href="#l23.59"></a><span id="l23.59" class="difflineplus">+</span>
<a href="#l23.60"></a><span id="l23.60">   // { ----- begin port methods -----</span>
<a href="#l23.61"></a><span id="l23.61">   NS_IMETHOD CanOpenFilePort(</span>
<a href="#l23.62"></a><span id="l23.62">     nsIMdbEnv* ev, // context</span>
<a href="#l23.63"></a><span id="l23.63">     // const char* inFilePath, // the file to investigate</span>
<a href="#l23.64"></a><span id="l23.64">     // const mdbYarn* inFirst512Bytes,</span>
<a href="#l23.65"></a><span id="l23.65">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l23.66"></a><span id="l23.66">     mdb_bool* outCanOpen, // whether OpenFilePort() might succeed</span>
<a href="#l23.67"></a><span id="l23.67" class="difflineminus">-    mdbYarn* outFormatVersion); // informal file format description</span>
<a href="#l23.68"></a><span id="l23.68" class="difflineminus">-    </span>
<a href="#l23.69"></a><span id="l23.69" class="difflineplus">+    mdbYarn* outFormatVersion) override; // informal file format description</span>
<a href="#l23.70"></a><span id="l23.70" class="difflineplus">+</span>
<a href="#l23.71"></a><span id="l23.71">   NS_IMETHOD OpenFilePort(</span>
<a href="#l23.72"></a><span id="l23.72">     nsIMdbEnv* ev, // context</span>
<a href="#l23.73"></a><span id="l23.73">     nsIMdbHeap* ioHeap, // can be nil to cause ev's heap attribute to be used</span>
<a href="#l23.74"></a><span id="l23.74">     // const char* inFilePath, // the file to open for readonly import</span>
<a href="#l23.75"></a><span id="l23.75">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l23.76"></a><span id="l23.76">     const mdbOpenPolicy* inOpenPolicy, // runtime policies for using db</span>
<a href="#l23.77"></a><span id="l23.77" class="difflineminus">-    nsIMdbThumb** acqThumb); // acquire thumb for incremental port open</span>
<a href="#l23.78"></a><span id="l23.78" class="difflineplus">+    nsIMdbThumb** acqThumb) override; // acquire thumb for incremental port open</span>
<a href="#l23.79"></a><span id="l23.79">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l23.80"></a><span id="l23.80">   // then call nsIMdbFactory::ThumbToOpenPort() to get the port instance.</span>
<a href="#l23.81"></a><span id="l23.81"> </span>
<a href="#l23.82"></a><span id="l23.82">   NS_IMETHOD ThumbToOpenPort( // redeeming a completed thumb from OpenFilePort()</span>
<a href="#l23.83"></a><span id="l23.83">     nsIMdbEnv* ev, // context</span>
<a href="#l23.84"></a><span id="l23.84">     nsIMdbThumb* ioThumb, // thumb from OpenFilePort() with done status</span>
<a href="#l23.85"></a><span id="l23.85" class="difflineminus">-    nsIMdbPort** acqPort); // acquire new port object</span>
<a href="#l23.86"></a><span id="l23.86" class="difflineplus">+    nsIMdbPort** acqPort) override; // acquire new port object</span>
<a href="#l23.87"></a><span id="l23.87">   // } ----- end port methods -----</span>
<a href="#l23.88"></a><span id="l23.88" class="difflineminus">-  </span>
<a href="#l23.89"></a><span id="l23.89" class="difflineplus">+</span>
<a href="#l23.90"></a><span id="l23.90">   // { ----- begin store methods -----</span>
<a href="#l23.91"></a><span id="l23.91">   NS_IMETHOD CanOpenFileStore(</span>
<a href="#l23.92"></a><span id="l23.92">     nsIMdbEnv* ev, // context</span>
<a href="#l23.93"></a><span id="l23.93">     // const char* inFilePath, // the file to investigate</span>
<a href="#l23.94"></a><span id="l23.94">     // const mdbYarn* inFirst512Bytes,</span>
<a href="#l23.95"></a><span id="l23.95">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l23.96"></a><span id="l23.96">     mdb_bool* outCanOpenAsStore, // whether OpenFileStore() might succeed</span>
<a href="#l23.97"></a><span id="l23.97">     mdb_bool* outCanOpenAsPort, // whether OpenFilePort() might succeed</span>
<a href="#l23.98"></a><span id="l23.98" class="difflineminus">-    mdbYarn* outFormatVersion); // informal file format description</span>
<a href="#l23.99"></a><span id="l23.99" class="difflineminus">-    </span>
<a href="#l23.100"></a><span id="l23.100" class="difflineplus">+    mdbYarn* outFormatVersion) override; // informal file format description</span>
<a href="#l23.101"></a><span id="l23.101" class="difflineplus">+</span>
<a href="#l23.102"></a><span id="l23.102">   NS_IMETHOD OpenFileStore( // open an existing database</span>
<a href="#l23.103"></a><span id="l23.103">     nsIMdbEnv* ev, // context</span>
<a href="#l23.104"></a><span id="l23.104">     nsIMdbHeap* ioHeap, // can be nil to cause ev's heap attribute to be used</span>
<a href="#l23.105"></a><span id="l23.105">     // const char* inFilePath, // the file to open for general db usage</span>
<a href="#l23.106"></a><span id="l23.106">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l23.107"></a><span id="l23.107">     const mdbOpenPolicy* inOpenPolicy, // runtime policies for using db</span>
<a href="#l23.108"></a><span id="l23.108" class="difflineminus">-    nsIMdbThumb** acqThumb); // acquire thumb for incremental store open</span>
<a href="#l23.109"></a><span id="l23.109" class="difflineplus">+    nsIMdbThumb** acqThumb) override; // acquire thumb for incremental store open</span>
<a href="#l23.110"></a><span id="l23.110">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l23.111"></a><span id="l23.111">   // then call nsIMdbFactory::ThumbToOpenStore() to get the store instance.</span>
<a href="#l23.112"></a><span id="l23.112" class="difflineminus">-    </span>
<a href="#l23.113"></a><span id="l23.113" class="difflineplus">+</span>
<a href="#l23.114"></a><span id="l23.114">   NS_IMETHOD</span>
<a href="#l23.115"></a><span id="l23.115">   ThumbToOpenStore( // redeem completed thumb from OpenFileStore()</span>
<a href="#l23.116"></a><span id="l23.116">     nsIMdbEnv* ev, // context</span>
<a href="#l23.117"></a><span id="l23.117">     nsIMdbThumb* ioThumb, // thumb from OpenFileStore() with done status</span>
<a href="#l23.118"></a><span id="l23.118" class="difflineminus">-    nsIMdbStore** acqStore); // acquire new db store object</span>
<a href="#l23.119"></a><span id="l23.119" class="difflineminus">-  </span>
<a href="#l23.120"></a><span id="l23.120" class="difflineplus">+    nsIMdbStore** acqStore) override; // acquire new db store object</span>
<a href="#l23.121"></a><span id="l23.121" class="difflineplus">+</span>
<a href="#l23.122"></a><span id="l23.122">   NS_IMETHOD CreateNewFileStore( // create a new db with minimal content</span>
<a href="#l23.123"></a><span id="l23.123">     nsIMdbEnv* ev, // context</span>
<a href="#l23.124"></a><span id="l23.124">     nsIMdbHeap* ioHeap, // can be nil to cause ev's heap attribute to be used</span>
<a href="#l23.125"></a><span id="l23.125">     // const char* inFilePath, // name of file which should not yet exist</span>
<a href="#l23.126"></a><span id="l23.126">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l23.127"></a><span id="l23.127">     const mdbOpenPolicy* inOpenPolicy, // runtime policies for using db</span>
<a href="#l23.128"></a><span id="l23.128" class="difflineminus">-    nsIMdbStore** acqStore); // acquire new db store object</span>
<a href="#l23.129"></a><span id="l23.129" class="difflineplus">+    nsIMdbStore** acqStore) override; // acquire new db store object</span>
<a href="#l23.130"></a><span id="l23.130">   // } ----- end store methods -----</span>
<a href="#l23.131"></a><span id="l23.131"> </span>
<a href="#l23.132"></a><span id="l23.132"> // } ===== end nsIMdbFactory methods =====</span>
<a href="#l23.133"></a><span id="l23.133">   </span>
<a href="#l23.134"></a><span id="l23.134"> public: // morkYarn construction &amp; destruction</span>
<a href="#l23.135"></a><span id="l23.135">   morkFactory(); // uses orkinHeap</span>
<a href="#l23.136"></a><span id="l23.136">   morkFactory(nsIMdbHeap* ioHeap); // caller supplied heap</span>
<a href="#l23.137"></a><span id="l23.137">   morkFactory(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/db/mork/src/morkFile.cpp</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/db/mork/src/morkFile.cpp</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -79,18 +79,16 @@ morkFile::morkFile(morkEnv* ev, const mo</span>
<a href="#l24.4"></a><span id="l24.4">       ev-&gt;NilPointerError();</span>
<a href="#l24.5"></a><span id="l24.5">   }</span>
<a href="#l24.6"></a><span id="l24.6"> }</span>
<a href="#l24.7"></a><span id="l24.7"> </span>
<a href="#l24.8"></a><span id="l24.8"> NS_IMPL_ISUPPORTS_INHERITED(morkFile, morkObject, nsIMdbFile)</span>
<a href="#l24.9"></a><span id="l24.9"> /*public non-poly*/ void</span>
<a href="#l24.10"></a><span id="l24.10"> morkFile::CloseFile(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l24.11"></a><span id="l24.11"> {</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineminus">-  if ( this )</span>
<a href="#l24.13"></a><span id="l24.13" class="difflineminus">-  {</span>
<a href="#l24.14"></a><span id="l24.14">     if ( this-&gt;IsNode() )</span>
<a href="#l24.15"></a><span id="l24.15">     {</span>
<a href="#l24.16"></a><span id="l24.16">       mFile_Frozen = 0;</span>
<a href="#l24.17"></a><span id="l24.17">       mFile_DoTrace = 0;</span>
<a href="#l24.18"></a><span id="l24.18">       mFile_IoOpen = 0;</span>
<a href="#l24.19"></a><span id="l24.19">       mFile_Active = 0;</span>
<a href="#l24.20"></a><span id="l24.20">       </span>
<a href="#l24.21"></a><span id="l24.21">       if ( mFile_Name )</span>
<a href="#l24.22"></a><span id="l24.22" class="difflineat">@@ -98,19 +96,16 @@ morkFile::CloseFile(morkEnv* ev) // call</span>
<a href="#l24.23"></a><span id="l24.23"> </span>
<a href="#l24.24"></a><span id="l24.24">       nsIMdbHeap_SlotStrongHeap((nsIMdbHeap*) 0, ev, &amp;mFile_SlotHeap);</span>
<a href="#l24.25"></a><span id="l24.25">       nsIMdbFile_SlotStrongFile((nsIMdbFile*) 0, ev, &amp;mFile_Thief);</span>
<a href="#l24.26"></a><span id="l24.26"> </span>
<a href="#l24.27"></a><span id="l24.27">       this-&gt;MarkShut();</span>
<a href="#l24.28"></a><span id="l24.28">     }</span>
<a href="#l24.29"></a><span id="l24.29">     else</span>
<a href="#l24.30"></a><span id="l24.30">       this-&gt;NonNodeError(ev);</span>
<a href="#l24.31"></a><span id="l24.31" class="difflineminus">-  }</span>
<a href="#l24.32"></a><span id="l24.32" class="difflineminus">-  else</span>
<a href="#l24.33"></a><span id="l24.33" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l24.34"></a><span id="l24.34"> }</span>
<a href="#l24.35"></a><span id="l24.35"> </span>
<a href="#l24.36"></a><span id="l24.36"> // } ===== end morkNode methods =====</span>
<a href="#l24.37"></a><span id="l24.37"> // ````` ````` ````` ````` ````` </span>
<a href="#l24.38"></a><span id="l24.38"> </span>
<a href="#l24.39"></a><span id="l24.39"> /*static*/ morkFile*</span>
<a href="#l24.40"></a><span id="l24.40"> morkFile::OpenOldFile(morkEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l24.41"></a><span id="l24.41">   const char* inFilePath, mork_bool inFrozen)</span>
<a href="#l24.42"></a><span id="l24.42" class="difflineat">@@ -367,35 +362,30 @@ morkStdioFile::~morkStdioFile() // asser</span>
<a href="#l24.43"></a><span id="l24.43">   if (mStdioFile_File)</span>
<a href="#l24.44"></a><span id="l24.44">     CloseStdioFile(mMorkEnv);</span>
<a href="#l24.45"></a><span id="l24.45">   MORK_ASSERT(mStdioFile_File==0);</span>
<a href="#l24.46"></a><span id="l24.46"> }</span>
<a href="#l24.47"></a><span id="l24.47"> </span>
<a href="#l24.48"></a><span id="l24.48"> /*public non-poly*/ void</span>
<a href="#l24.49"></a><span id="l24.49"> morkStdioFile::CloseStdioFile(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l24.50"></a><span id="l24.50"> {</span>
<a href="#l24.51"></a><span id="l24.51" class="difflineminus">-  if ( this )</span>
<a href="#l24.52"></a><span id="l24.52" class="difflineminus">-  {</span>
<a href="#l24.53"></a><span id="l24.53">     if ( this-&gt;IsNode() )</span>
<a href="#l24.54"></a><span id="l24.54">     {</span>
<a href="#l24.55"></a><span id="l24.55">       if ( mStdioFile_File &amp;&amp; this-&gt;FileActive() &amp;&amp; this-&gt;FileIoOpen() )</span>
<a href="#l24.56"></a><span id="l24.56">       {</span>
<a href="#l24.57"></a><span id="l24.57">         this-&gt;CloseStdio(ev);</span>
<a href="#l24.58"></a><span id="l24.58">       }</span>
<a href="#l24.59"></a><span id="l24.59">       </span>
<a href="#l24.60"></a><span id="l24.60">       mStdioFile_File = 0;</span>
<a href="#l24.61"></a><span id="l24.61">       </span>
<a href="#l24.62"></a><span id="l24.62">       this-&gt;CloseFile(ev);</span>
<a href="#l24.63"></a><span id="l24.63">       this-&gt;MarkShut();</span>
<a href="#l24.64"></a><span id="l24.64">     }</span>
<a href="#l24.65"></a><span id="l24.65">     else</span>
<a href="#l24.66"></a><span id="l24.66">       this-&gt;NonNodeError(ev);</span>
<a href="#l24.67"></a><span id="l24.67" class="difflineminus">-  }</span>
<a href="#l24.68"></a><span id="l24.68" class="difflineminus">-  else</span>
<a href="#l24.69"></a><span id="l24.69" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l24.70"></a><span id="l24.70"> }</span>
<a href="#l24.71"></a><span id="l24.71"> </span>
<a href="#l24.72"></a><span id="l24.72"> // } ===== end morkNode methods =====</span>
<a href="#l24.73"></a><span id="l24.73"> // ````` ````` ````` ````` ````` </span>
<a href="#l24.74"></a><span id="l24.74"> </span>
<a href="#l24.75"></a><span id="l24.75"> // compatible with the morkFile::MakeFile() entry point</span>
<a href="#l24.76"></a><span id="l24.76"> </span>
<a href="#l24.77"></a><span id="l24.77"> /*static*/ morkStdioFile* </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/db/mork/src/morkFile.h</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/db/mork/src/morkFile.h</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -92,18 +92,18 @@ protected: // protected morkFile members</span>
<a href="#l25.4"></a><span id="l25.4">   char*       mFile_Name; // can be nil if SetFileName() is never called</span>
<a href="#l25.5"></a><span id="l25.5">   // mFile_Name convention: managed with morkEnv::CopyString()/FreeString()</span>
<a href="#l25.6"></a><span id="l25.6"> </span>
<a href="#l25.7"></a><span id="l25.7">   nsIMdbFile* mFile_Thief; // from a call to orkinFile::Steal()</span>
<a href="#l25.8"></a><span id="l25.8">   </span>
<a href="#l25.9"></a><span id="l25.9"> // { ===== begin morkNode interface =====</span>
<a href="#l25.10"></a><span id="l25.10"> public: // morkNode virtual methods</span>
<a href="#l25.11"></a><span id="l25.11">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l25.12"></a><span id="l25.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseFile() only if open</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineminus">-  </span>
<a href="#l25.14"></a><span id="l25.14" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseFile() only if open</span>
<a href="#l25.15"></a><span id="l25.15" class="difflineplus">+</span>
<a href="#l25.16"></a><span id="l25.16"> public: // morkFile construction &amp; destruction</span>
<a href="#l25.17"></a><span id="l25.17">   morkFile(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l25.18"></a><span id="l25.18">     nsIMdbHeap* ioSlotHeap);</span>
<a href="#l25.19"></a><span id="l25.19">   void CloseFile(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l25.20"></a><span id="l25.20"> </span>
<a href="#l25.21"></a><span id="l25.21"> private: // copying is not allowed</span>
<a href="#l25.22"></a><span id="l25.22">   morkFile(const morkFile&amp; other);</span>
<a href="#l25.23"></a><span id="l25.23">   morkFile&amp; operator=(const morkFile&amp; other);</span>
<a href="#l25.24"></a><span id="l25.24" class="difflineat">@@ -183,50 +183,50 @@ public: // typesafe refcounting inlines </span>
<a href="#l25.25"></a><span id="l25.25">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l25.26"></a><span id="l25.26">   </span>
<a href="#l25.27"></a><span id="l25.27">   static void SlotStrongFile(morkFile* me,</span>
<a href="#l25.28"></a><span id="l25.28">     morkEnv* ev, morkFile** ioSlot)</span>
<a href="#l25.29"></a><span id="l25.29">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l25.30"></a><span id="l25.30"> public:</span>
<a href="#l25.31"></a><span id="l25.31">   virtual mork_pos   Length(morkEnv* ev) const = 0; // eof</span>
<a href="#l25.32"></a><span id="l25.32">   // nsIMdbFile methods</span>
<a href="#l25.33"></a><span id="l25.33" class="difflineminus">-  NS_IMETHOD Tell(nsIMdbEnv* ev, mdb_pos* outPos) const = 0;</span>
<a href="#l25.34"></a><span id="l25.34" class="difflineminus">-  NS_IMETHOD Seek(nsIMdbEnv* ev, mdb_pos inPos, mdb_pos *outPos) = 0;</span>
<a href="#l25.35"></a><span id="l25.35" class="difflineminus">-  NS_IMETHOD Eof(nsIMdbEnv* ev, mdb_pos* outPos);</span>
<a href="#l25.36"></a><span id="l25.36" class="difflineplus">+  NS_IMETHOD Tell(nsIMdbEnv* ev, mdb_pos* outPos) const override = 0;</span>
<a href="#l25.37"></a><span id="l25.37" class="difflineplus">+  NS_IMETHOD Seek(nsIMdbEnv* ev, mdb_pos inPos, mdb_pos *outPos) override =  0;</span>
<a href="#l25.38"></a><span id="l25.38" class="difflineplus">+  NS_IMETHOD Eof(nsIMdbEnv* ev, mdb_pos* outPos) override;</span>
<a href="#l25.39"></a><span id="l25.39">   // } ----- end pos methods -----</span>
<a href="#l25.40"></a><span id="l25.40"> </span>
<a href="#l25.41"></a><span id="l25.41">   // { ----- begin read methods -----</span>
<a href="#l25.42"></a><span id="l25.42">   NS_IMETHOD Read(nsIMdbEnv* ev, void* outBuf, mdb_size inSize,</span>
<a href="#l25.43"></a><span id="l25.43" class="difflineminus">-    mdb_size* outActualSize) = 0;</span>
<a href="#l25.44"></a><span id="l25.44" class="difflineplus">+    mdb_size* outActualSize) override = 0;</span>
<a href="#l25.45"></a><span id="l25.45">   NS_IMETHOD Get(nsIMdbEnv* ev, void* outBuf, mdb_size inSize,</span>
<a href="#l25.46"></a><span id="l25.46" class="difflineminus">-    mdb_pos inPos, mdb_size* outActualSize);</span>
<a href="#l25.47"></a><span id="l25.47" class="difflineplus">+    mdb_pos inPos, mdb_size* outActualSize) override;</span>
<a href="#l25.48"></a><span id="l25.48">   // } ----- end read methods -----</span>
<a href="#l25.49"></a><span id="l25.49">     </span>
<a href="#l25.50"></a><span id="l25.50">   // { ----- begin write methods -----</span>
<a href="#l25.51"></a><span id="l25.51">   NS_IMETHOD  Write(nsIMdbEnv* ev, const void* inBuf, mdb_size inSize,</span>
<a href="#l25.52"></a><span id="l25.52" class="difflineminus">-    mdb_size* outActualSize) = 0;</span>
<a href="#l25.53"></a><span id="l25.53" class="difflineplus">+    mdb_size* outActualSize) override = 0;</span>
<a href="#l25.54"></a><span id="l25.54">   NS_IMETHOD  Put(nsIMdbEnv* ev, const void* inBuf, mdb_size inSize,</span>
<a href="#l25.55"></a><span id="l25.55" class="difflineminus">-    mdb_pos inPos, mdb_size* outActualSize);</span>
<a href="#l25.56"></a><span id="l25.56" class="difflineminus">-  NS_IMETHOD  Flush(nsIMdbEnv* ev) = 0;</span>
<a href="#l25.57"></a><span id="l25.57" class="difflineplus">+    mdb_pos inPos, mdb_size* outActualSize) override;</span>
<a href="#l25.58"></a><span id="l25.58" class="difflineplus">+  NS_IMETHOD  Flush(nsIMdbEnv* ev) override = 0;</span>
<a href="#l25.59"></a><span id="l25.59">   // } ----- end attribute methods -----</span>
<a href="#l25.60"></a><span id="l25.60">     </span>
<a href="#l25.61"></a><span id="l25.61">   // { ----- begin path methods -----</span>
<a href="#l25.62"></a><span id="l25.62" class="difflineminus">-  NS_IMETHOD  Path(nsIMdbEnv* ev, mdbYarn* outFilePath);</span>
<a href="#l25.63"></a><span id="l25.63" class="difflineplus">+  NS_IMETHOD  Path(nsIMdbEnv* ev, mdbYarn* outFilePath) override ;</span>
<a href="#l25.64"></a><span id="l25.64">   // } ----- end path methods -----</span>
<a href="#l25.65"></a><span id="l25.65">     </span>
<a href="#l25.66"></a><span id="l25.66">   // { ----- begin replacement methods -----</span>
<a href="#l25.67"></a><span id="l25.67" class="difflineminus">-  NS_IMETHOD  Steal(nsIMdbEnv* ev, nsIMdbFile* ioThief) = 0;</span>
<a href="#l25.68"></a><span id="l25.68" class="difflineminus">-  NS_IMETHOD  Thief(nsIMdbEnv* ev, nsIMdbFile** acqThief);</span>
<a href="#l25.69"></a><span id="l25.69" class="difflineplus">+  NS_IMETHOD  Steal(nsIMdbEnv* ev, nsIMdbFile* ioThief) override = 0;</span>
<a href="#l25.70"></a><span id="l25.70" class="difflineplus">+  NS_IMETHOD  Thief(nsIMdbEnv* ev, nsIMdbFile** acqThief) override;</span>
<a href="#l25.71"></a><span id="l25.71">   // } ----- end replacement methods -----</span>
<a href="#l25.72"></a><span id="l25.72"> </span>
<a href="#l25.73"></a><span id="l25.73">   // { ----- begin versioning methods -----</span>
<a href="#l25.74"></a><span id="l25.74" class="difflineminus">-  NS_IMETHOD BecomeTrunk(nsIMdbEnv* ev) = 0;</span>
<a href="#l25.75"></a><span id="l25.75" class="difflineplus">+  NS_IMETHOD BecomeTrunk(nsIMdbEnv* ev) override = 0;</span>
<a href="#l25.76"></a><span id="l25.76"> </span>
<a href="#l25.77"></a><span id="l25.77">   NS_IMETHOD AcquireBud(nsIMdbEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l25.78"></a><span id="l25.78" class="difflineminus">-    nsIMdbFile** acqBud) = 0; </span>
<a href="#l25.79"></a><span id="l25.79" class="difflineplus">+    nsIMdbFile** acqBud) override = 0;</span>
<a href="#l25.80"></a><span id="l25.80">   // } ----- end versioning methods -----</span>
<a href="#l25.81"></a><span id="l25.81"> </span>
<a href="#l25.82"></a><span id="l25.82"> // } ===== end nsIMdbFile methods =====</span>
<a href="#l25.83"></a><span id="l25.83"> </span>
<a href="#l25.84"></a><span id="l25.84"> };</span>
<a href="#l25.85"></a><span id="l25.85"> </span>
<a href="#l25.86"></a><span id="l25.86"> /*=============================================================================</span>
<a href="#l25.87"></a><span id="l25.87">  * morkStdioFile: concrete file using standard C file io</span>
<a href="#l25.88"></a><span id="l25.88" class="difflineat">@@ -236,22 +236,22 @@ public:</span>
<a href="#l25.89"></a><span id="l25.89"> </span>
<a href="#l25.90"></a><span id="l25.90"> class morkStdioFile /*d*/ : public morkFile { /* `` copied from IronDoc `` */</span>
<a href="#l25.91"></a><span id="l25.91"> </span>
<a href="#l25.92"></a><span id="l25.92"> // ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l25.93"></a><span id="l25.93"> protected: // protected morkStdioFile members</span>
<a href="#l25.94"></a><span id="l25.94"> </span>
<a href="#l25.95"></a><span id="l25.95">   void* mStdioFile_File;</span>
<a href="#l25.96"></a><span id="l25.96">   // actually type FILE*, but using opaque void* type</span>
<a href="#l25.97"></a><span id="l25.97" class="difflineminus">-  </span>
<a href="#l25.98"></a><span id="l25.98" class="difflineplus">+</span>
<a href="#l25.99"></a><span id="l25.99"> // { ===== begin morkNode interface =====</span>
<a href="#l25.100"></a><span id="l25.100"> public: // morkNode virtual methods</span>
<a href="#l25.101"></a><span id="l25.101" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseStdioFile() only if open</span>
<a href="#l25.102"></a><span id="l25.102" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseStdioFile() only if open</span>
<a href="#l25.103"></a><span id="l25.103">   virtual ~morkStdioFile(); // assert that CloseStdioFile() executed earlier</span>
<a href="#l25.104"></a><span id="l25.104" class="difflineminus">-  </span>
<a href="#l25.105"></a><span id="l25.105" class="difflineplus">+</span>
<a href="#l25.106"></a><span id="l25.106"> public: // morkStdioFile construction &amp; destruction</span>
<a href="#l25.107"></a><span id="l25.107">   morkStdioFile(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l25.108"></a><span id="l25.108">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l25.109"></a><span id="l25.109">   void CloseStdioFile(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l25.110"></a><span id="l25.110"> </span>
<a href="#l25.111"></a><span id="l25.111"> private: // copying is not allowed</span>
<a href="#l25.112"></a><span id="l25.112">   morkStdioFile(const morkStdioFile&amp; other);</span>
<a href="#l25.113"></a><span id="l25.113">   morkStdioFile&amp; operator=(const morkStdioFile&amp; other);</span>
<a href="#l25.114"></a><span id="l25.114" class="difflineat">@@ -268,43 +268,42 @@ public: // typing</span>
<a href="#l25.115"></a><span id="l25.115"> public: // compatible with the morkFile::OpenOldFile() entry point</span>
<a href="#l25.116"></a><span id="l25.116"> </span>
<a href="#l25.117"></a><span id="l25.117">   static morkStdioFile* OpenOldStdioFile(morkEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l25.118"></a><span id="l25.118">     const char* inFilePath, mork_bool inFrozen);</span>
<a href="#l25.119"></a><span id="l25.119"> </span>
<a href="#l25.120"></a><span id="l25.120">   static morkStdioFile* CreateNewStdioFile(morkEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l25.121"></a><span id="l25.121">     const char* inFilePath);</span>
<a href="#l25.122"></a><span id="l25.122"> </span>
<a href="#l25.123"></a><span id="l25.123" class="difflineminus">-  virtual mork_pos   Length(morkEnv* ev) const; // eof</span>
<a href="#l25.124"></a><span id="l25.124" class="difflineplus">+  virtual mork_pos   Length(morkEnv* ev) const override; // eof</span>
<a href="#l25.125"></a><span id="l25.125"> </span>
<a href="#l25.126"></a><span id="l25.126" class="difflineminus">-  NS_IMETHOD Tell(nsIMdbEnv* ev, mdb_pos* outPos) const;</span>
<a href="#l25.127"></a><span id="l25.127" class="difflineminus">-  NS_IMETHOD Seek(nsIMdbEnv* ev, mdb_pos inPos, mdb_pos *outPos);</span>
<a href="#l25.128"></a><span id="l25.128" class="difflineplus">+  NS_IMETHOD Tell(nsIMdbEnv* ev, mdb_pos* outPos) const override;</span>
<a href="#l25.129"></a><span id="l25.129" class="difflineplus">+  NS_IMETHOD Seek(nsIMdbEnv* ev, mdb_pos inPos, mdb_pos *outPos) override;</span>
<a href="#l25.130"></a><span id="l25.130"> //  NS_IMETHOD Eof(nsIMdbEnv* ev, mdb_pos* outPos);</span>
<a href="#l25.131"></a><span id="l25.131">   // } ----- end pos methods -----</span>
<a href="#l25.132"></a><span id="l25.132"> </span>
<a href="#l25.133"></a><span id="l25.133">   // { ----- begin read methods -----</span>
<a href="#l25.134"></a><span id="l25.134">   NS_IMETHOD Read(nsIMdbEnv* ev, void* outBuf, mdb_size inSize,</span>
<a href="#l25.135"></a><span id="l25.135" class="difflineminus">-    mdb_size* outActualSize);</span>
<a href="#l25.136"></a><span id="l25.136" class="difflineminus">-    </span>
<a href="#l25.137"></a><span id="l25.137" class="difflineplus">+    mdb_size* outActualSize) override;</span>
<a href="#l25.138"></a><span id="l25.138" class="difflineplus">+</span>
<a href="#l25.139"></a><span id="l25.139">   // { ----- begin write methods -----</span>
<a href="#l25.140"></a><span id="l25.140">   NS_IMETHOD  Write(nsIMdbEnv* ev, const void* inBuf, mdb_size inSize,</span>
<a href="#l25.141"></a><span id="l25.141" class="difflineminus">-    mdb_size* outActualSize);</span>
<a href="#l25.142"></a><span id="l25.142" class="difflineplus">+    mdb_size* outActualSize) override;</span>
<a href="#l25.143"></a><span id="l25.143"> //  NS_IMETHOD  Put(nsIMdbEnv* ev, const void* inBuf, mdb_size inSize,</span>
<a href="#l25.144"></a><span id="l25.144"> //    mdb_pos inPos, mdb_size* outActualSize);</span>
<a href="#l25.145"></a><span id="l25.145" class="difflineminus">-  NS_IMETHOD  Flush(nsIMdbEnv* ev);</span>
<a href="#l25.146"></a><span id="l25.146" class="difflineplus">+  NS_IMETHOD  Flush(nsIMdbEnv* ev) override;</span>
<a href="#l25.147"></a><span id="l25.147">   // } ----- end attribute methods -----</span>
<a href="#l25.148"></a><span id="l25.148" class="difflineminus">-    </span>
<a href="#l25.149"></a><span id="l25.149" class="difflineminus">-  NS_IMETHOD  Steal(nsIMdbEnv* ev, nsIMdbFile* ioThief);</span>
<a href="#l25.150"></a><span id="l25.150" class="difflineminus">-   </span>
<a href="#l25.151"></a><span id="l25.151" class="difflineplus">+</span>
<a href="#l25.152"></a><span id="l25.152" class="difflineplus">+  NS_IMETHOD  Steal(nsIMdbEnv* ev, nsIMdbFile* ioThief) override;</span>
<a href="#l25.153"></a><span id="l25.153"> </span>
<a href="#l25.154"></a><span id="l25.154">   // { ----- begin versioning methods -----</span>
<a href="#l25.155"></a><span id="l25.155" class="difflineminus">-  NS_IMETHOD BecomeTrunk(nsIMdbEnv* ev);</span>
<a href="#l25.156"></a><span id="l25.156" class="difflineplus">+  NS_IMETHOD BecomeTrunk(nsIMdbEnv* ev) override;</span>
<a href="#l25.157"></a><span id="l25.157"> </span>
<a href="#l25.158"></a><span id="l25.158">   NS_IMETHOD AcquireBud(nsIMdbEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l25.159"></a><span id="l25.159" class="difflineminus">-    nsIMdbFile** acqBud); </span>
<a href="#l25.160"></a><span id="l25.160" class="difflineplus">+    nsIMdbFile** acqBud) override;</span>
<a href="#l25.161"></a><span id="l25.161">   // } ----- end versioning methods -----</span>
<a href="#l25.162"></a><span id="l25.162"> </span>
<a href="#l25.163"></a><span id="l25.163"> // } ===== end nsIMdbFile methods =====</span>
<a href="#l25.164"></a><span id="l25.164"> </span>
<a href="#l25.165"></a><span id="l25.165"> // ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l25.166"></a><span id="l25.166"> </span>
<a href="#l25.167"></a><span id="l25.167"> // ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l25.168"></a><span id="l25.168"> protected: // protected non-poly morkStdioFile methods</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/db/mork/src/morkHandle.cpp</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/db/mork/src/morkHandle.cpp</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -83,18 +83,16 @@ morkHandle::morkHandle(morkEnv* ev, // n</span>
<a href="#l26.4"></a><span id="l26.4">   }</span>
<a href="#l26.5"></a><span id="l26.5">   else</span>
<a href="#l26.6"></a><span id="l26.6">     ev-&gt;NilPointerError();</span>
<a href="#l26.7"></a><span id="l26.7"> }</span>
<a href="#l26.8"></a><span id="l26.8"> </span>
<a href="#l26.9"></a><span id="l26.9"> /*public non-poly*/ void</span>
<a href="#l26.10"></a><span id="l26.10"> morkHandle::CloseHandle(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l26.11"></a><span id="l26.11"> {</span>
<a href="#l26.12"></a><span id="l26.12" class="difflineminus">-  if ( this )</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineminus">-  {</span>
<a href="#l26.14"></a><span id="l26.14">     if ( this-&gt;IsNode() )</span>
<a href="#l26.15"></a><span id="l26.15">     {</span>
<a href="#l26.16"></a><span id="l26.16">       morkObject* obj = mHandle_Object;</span>
<a href="#l26.17"></a><span id="l26.17">       mork_bool objDidRefSelf = ( obj &amp;&amp; obj-&gt;mObject_Handle == this );</span>
<a href="#l26.18"></a><span id="l26.18">       if ( objDidRefSelf )</span>
<a href="#l26.19"></a><span id="l26.19">         obj-&gt;mObject_Handle = 0; // drop the reference</span>
<a href="#l26.20"></a><span id="l26.20">       </span>
<a href="#l26.21"></a><span id="l26.21">       morkObject::SlotStrongObject((morkObject*) 0, ev, &amp;mHandle_Object);</span>
<a href="#l26.22"></a><span id="l26.22" class="difflineat">@@ -102,19 +100,16 @@ morkHandle::CloseHandle(morkEnv* ev) // </span>
<a href="#l26.23"></a><span id="l26.23">       // note mHandle_Tag MUST stay morkHandle_kTag for morkNode::ZapOld()</span>
<a href="#l26.24"></a><span id="l26.24">       this-&gt;MarkShut();</span>
<a href="#l26.25"></a><span id="l26.25"> </span>
<a href="#l26.26"></a><span id="l26.26">       if ( objDidRefSelf )</span>
<a href="#l26.27"></a><span id="l26.27">         this-&gt;CutWeakRef(ev); // do last, because it might self destroy</span>
<a href="#l26.28"></a><span id="l26.28">     }</span>
<a href="#l26.29"></a><span id="l26.29">     else</span>
<a href="#l26.30"></a><span id="l26.30">       this-&gt;NonNodeError(ev);</span>
<a href="#l26.31"></a><span id="l26.31" class="difflineminus">-  }</span>
<a href="#l26.32"></a><span id="l26.32" class="difflineminus">-  else</span>
<a href="#l26.33"></a><span id="l26.33" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l26.34"></a><span id="l26.34"> }</span>
<a href="#l26.35"></a><span id="l26.35"> </span>
<a href="#l26.36"></a><span id="l26.36"> // } ===== end morkNode methods =====</span>
<a href="#l26.37"></a><span id="l26.37"> // ````` ````` ````` ````` ````` </span>
<a href="#l26.38"></a><span id="l26.38"> </span>
<a href="#l26.39"></a><span id="l26.39"> void morkHandle::NilFactoryError(morkEnv* ev) const</span>
<a href="#l26.40"></a><span id="l26.40"> {</span>
<a href="#l26.41"></a><span id="l26.41">   ev-&gt;NewError(&quot;nil mHandle_Factory&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1" class="difflineminus">--- a/db/mork/src/morkHandle.h</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineplus">+++ b/db/mork/src/morkHandle.h</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineat">@@ -54,17 +54,17 @@ public: // state is public because the e</span>
<a href="#l27.4"></a><span id="l27.4">   mork_u4         mHandle_Tag;     // must equal morkHandle_kTag</span>
<a href="#l27.5"></a><span id="l27.5">   morkEnv*        mHandle_Env;     // pool that allocated this handle</span>
<a href="#l27.6"></a><span id="l27.6">   morkHandleFace* mHandle_Face;    // cookie from pool containing this</span>
<a href="#l27.7"></a><span id="l27.7">   morkObject*     mHandle_Object;  // object this handle wraps for MDB API</span>
<a href="#l27.8"></a><span id="l27.8">   mork_magic      mHandle_Magic;   // magic sig different in each subclass</span>
<a href="#l27.9"></a><span id="l27.9">   </span>
<a href="#l27.10"></a><span id="l27.10"> // { ===== begin morkNode interface =====</span>
<a href="#l27.11"></a><span id="l27.11"> public: // morkNode virtual methods</span>
<a href="#l27.12"></a><span id="l27.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseHandle() only if open</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseHandle() only if open</span>
<a href="#l27.14"></a><span id="l27.14">   virtual ~morkHandle(); // assert that CloseHandle() executed earlier</span>
<a href="#l27.15"></a><span id="l27.15">   </span>
<a href="#l27.16"></a><span id="l27.16"> public: // morkHandle construction &amp; destruction</span>
<a href="#l27.17"></a><span id="l27.17">   morkHandle(morkEnv* ev, // note morkUsage is always morkUsage_kPool</span>
<a href="#l27.18"></a><span id="l27.18">     morkHandleFace* ioFace,  // must not be nil, cookie for this handle</span>
<a href="#l27.19"></a><span id="l27.19">     morkObject* ioObject,    // must not be nil, the object for this handle</span>
<a href="#l27.20"></a><span id="l27.20">     mork_magic inMagic);     // magic sig to denote specific subclass</span>
<a href="#l27.21"></a><span id="l27.21">   void CloseHandle(morkEnv* ev); // called by CloseMorkNode();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1" class="difflineminus">--- a/db/mork/src/morkIntMap.cpp</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineplus">+++ b/db/mork/src/morkIntMap.cpp</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineat">@@ -58,28 +58,23 @@ morkIntMap::morkIntMap(morkEnv* ev,</span>
<a href="#l28.4"></a><span id="l28.4"> {</span>
<a href="#l28.5"></a><span id="l28.5">   if ( ev-&gt;Good() )</span>
<a href="#l28.6"></a><span id="l28.6">     mNode_Derived = morkDerived_kIntMap;</span>
<a href="#l28.7"></a><span id="l28.7"> }</span>
<a href="#l28.8"></a><span id="l28.8"> </span>
<a href="#l28.9"></a><span id="l28.9"> /*public non-poly*/ void</span>
<a href="#l28.10"></a><span id="l28.10"> morkIntMap::CloseIntMap(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l28.11"></a><span id="l28.11"> {</span>
<a href="#l28.12"></a><span id="l28.12" class="difflineminus">-  if ( this )</span>
<a href="#l28.13"></a><span id="l28.13" class="difflineminus">-  {</span>
<a href="#l28.14"></a><span id="l28.14">     if ( this-&gt;IsNode() )</span>
<a href="#l28.15"></a><span id="l28.15">     {</span>
<a href="#l28.16"></a><span id="l28.16">       this-&gt;CloseMap(ev);</span>
<a href="#l28.17"></a><span id="l28.17">       this-&gt;MarkShut();</span>
<a href="#l28.18"></a><span id="l28.18">     }</span>
<a href="#l28.19"></a><span id="l28.19">     else</span>
<a href="#l28.20"></a><span id="l28.20">       this-&gt;NonNodeError(ev);</span>
<a href="#l28.21"></a><span id="l28.21" class="difflineminus">-  }</span>
<a href="#l28.22"></a><span id="l28.22" class="difflineminus">-  else</span>
<a href="#l28.23"></a><span id="l28.23" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l28.24"></a><span id="l28.24"> }</span>
<a href="#l28.25"></a><span id="l28.25"> </span>
<a href="#l28.26"></a><span id="l28.26"> // } ===== end morkNode methods =====</span>
<a href="#l28.27"></a><span id="l28.27"> // ````` ````` ````` ````` ````` </span>
<a href="#l28.28"></a><span id="l28.28"> </span>
<a href="#l28.29"></a><span id="l28.29"> // { ===== begin morkMap poly interface =====</span>
<a href="#l28.30"></a><span id="l28.30"> /*virtual*/ mork_bool // *((mork_u4*) inKeyA) == *((mork_u4*) inKeyB)</span>
<a href="#l28.31"></a><span id="l28.31"> morkIntMap::Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const</span>
<a href="#l28.32"></a><span id="l28.32" class="difflineat">@@ -167,28 +162,23 @@ morkPointerMap::morkPointerMap(morkEnv* </span>
<a href="#l28.33"></a><span id="l28.33"> {</span>
<a href="#l28.34"></a><span id="l28.34">   if ( ev-&gt;Good() )</span>
<a href="#l28.35"></a><span id="l28.35">     mNode_Derived = morkDerived_kPointerMap;</span>
<a href="#l28.36"></a><span id="l28.36"> }</span>
<a href="#l28.37"></a><span id="l28.37"> </span>
<a href="#l28.38"></a><span id="l28.38"> /*public non-poly*/ void</span>
<a href="#l28.39"></a><span id="l28.39"> morkPointerMap::ClosePointerMap(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l28.40"></a><span id="l28.40"> {</span>
<a href="#l28.41"></a><span id="l28.41" class="difflineminus">-  if ( this )</span>
<a href="#l28.42"></a><span id="l28.42" class="difflineminus">-  {</span>
<a href="#l28.43"></a><span id="l28.43">     if ( this-&gt;IsNode() )</span>
<a href="#l28.44"></a><span id="l28.44">     {</span>
<a href="#l28.45"></a><span id="l28.45">       this-&gt;CloseMap(ev);</span>
<a href="#l28.46"></a><span id="l28.46">       this-&gt;MarkShut();</span>
<a href="#l28.47"></a><span id="l28.47">     }</span>
<a href="#l28.48"></a><span id="l28.48">     else</span>
<a href="#l28.49"></a><span id="l28.49">       this-&gt;NonNodeError(ev);</span>
<a href="#l28.50"></a><span id="l28.50" class="difflineminus">-  }</span>
<a href="#l28.51"></a><span id="l28.51" class="difflineminus">-  else</span>
<a href="#l28.52"></a><span id="l28.52" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l28.53"></a><span id="l28.53"> }</span>
<a href="#l28.54"></a><span id="l28.54"> </span>
<a href="#l28.55"></a><span id="l28.55"> // } ===== end morkNode methods =====</span>
<a href="#l28.56"></a><span id="l28.56"> // ````` ````` ````` ````` ````` </span>
<a href="#l28.57"></a><span id="l28.57"> </span>
<a href="#l28.58"></a><span id="l28.58"> // { ===== begin morkMap poly interface =====</span>
<a href="#l28.59"></a><span id="l28.59"> /*virtual*/ mork_bool // *((void**) inKeyA) == *((void**) inKeyB)</span>
<a href="#l28.60"></a><span id="l28.60"> morkPointerMap::Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1" class="difflineminus">--- a/db/mork/src/morkIntMap.h</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineplus">+++ b/db/mork/src/morkIntMap.h</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineat">@@ -25,37 +25,37 @@</span>
<a href="#l29.4"></a><span id="l29.4"> #define morkIntMap_kStartSlotCount 256</span>
<a href="#l29.5"></a><span id="l29.5"> </span>
<a href="#l29.6"></a><span id="l29.6"> /*| morkIntMap: maps mork_token -&gt; morkNode</span>
<a href="#l29.7"></a><span id="l29.7"> |*/</span>
<a href="#l29.8"></a><span id="l29.8"> class morkIntMap : public morkMap { // for mapping tokens to maps</span>
<a href="#l29.9"></a><span id="l29.9"> </span>
<a href="#l29.10"></a><span id="l29.10"> // { ===== begin morkNode interface =====</span>
<a href="#l29.11"></a><span id="l29.11"> public: // morkNode virtual methods</span>
<a href="#l29.12"></a><span id="l29.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseIntMap() only if open</span>
<a href="#l29.13"></a><span id="l29.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseIntMap() only if open</span>
<a href="#l29.14"></a><span id="l29.14">   virtual ~morkIntMap(); // assert that CloseIntMap() executed earlier</span>
<a href="#l29.15"></a><span id="l29.15">   </span>
<a href="#l29.16"></a><span id="l29.16"> public: // morkMap construction &amp; destruction</span>
<a href="#l29.17"></a><span id="l29.17"> </span>
<a href="#l29.18"></a><span id="l29.18">   // keySize for morkIntMap equals sizeof(mork_u4)</span>
<a href="#l29.19"></a><span id="l29.19">   morkIntMap(morkEnv* ev, const morkUsage&amp; inUsage, mork_size inValSize,</span>
<a href="#l29.20"></a><span id="l29.20">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap, mork_bool inHoldChanges);</span>
<a href="#l29.21"></a><span id="l29.21">   void CloseIntMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l29.22"></a><span id="l29.22"> </span>
<a href="#l29.23"></a><span id="l29.23"> public: // dynamic type identification</span>
<a href="#l29.24"></a><span id="l29.24">   mork_bool IsIntMap() const</span>
<a href="#l29.25"></a><span id="l29.25">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kIntMap; }</span>
<a href="#l29.26"></a><span id="l29.26"> // } ===== end morkNode methods =====</span>
<a href="#l29.27"></a><span id="l29.27"> </span>
<a href="#l29.28"></a><span id="l29.28"> // { ===== begin morkMap poly interface =====</span>
<a href="#l29.29"></a><span id="l29.29">   virtual mork_bool // *((mork_u4*) inKeyA) == *((mork_u4*) inKeyB)</span>
<a href="#l29.30"></a><span id="l29.30" class="difflineminus">-  Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const;</span>
<a href="#l29.31"></a><span id="l29.31" class="difflineplus">+  Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const override;</span>
<a href="#l29.32"></a><span id="l29.32"> </span>
<a href="#l29.33"></a><span id="l29.33">   virtual mork_u4 // some integer function of *((mork_u4*) inKey)</span>
<a href="#l29.34"></a><span id="l29.34" class="difflineminus">-  Hash(morkEnv* ev, const void* inKey) const;</span>
<a href="#l29.35"></a><span id="l29.35" class="difflineplus">+  Hash(morkEnv* ev, const void* inKey) const override;</span>
<a href="#l29.36"></a><span id="l29.36"> // } ===== end morkMap poly interface =====</span>
<a href="#l29.37"></a><span id="l29.37"> </span>
<a href="#l29.38"></a><span id="l29.38"> public: // other map methods</span>
<a href="#l29.39"></a><span id="l29.39"> </span>
<a href="#l29.40"></a><span id="l29.40">   mork_bool  AddInt(morkEnv* ev, mork_u4 inKey, void* ioAddress);</span>
<a href="#l29.41"></a><span id="l29.41">   // the AddInt() boolean return equals ev-&gt;Good().</span>
<a href="#l29.42"></a><span id="l29.42"> </span>
<a href="#l29.43"></a><span id="l29.43">   mork_bool  CutInt(morkEnv* ev, mork_u4 inKey);</span>
<a href="#l29.44"></a><span id="l29.44" class="difflineat">@@ -85,17 +85,17 @@ public: // other map methods</span>
<a href="#l29.45"></a><span id="l29.45"> **| being very careful about the size and usage assumptions of those</span>
<a href="#l29.46"></a><span id="l29.46"> **| clients using the smaller data type.  So we just go ahead and use</span>
<a href="#l29.47"></a><span id="l29.47"> **| morkPointerMap for hash tables using pointer key types.</span>
<a href="#l29.48"></a><span id="l29.48"> |*/</span>
<a href="#l29.49"></a><span id="l29.49"> class morkPointerMap : public morkMap { // for mapping tokens to maps</span>
<a href="#l29.50"></a><span id="l29.50"> </span>
<a href="#l29.51"></a><span id="l29.51"> // { ===== begin morkNode interface =====</span>
<a href="#l29.52"></a><span id="l29.52"> public: // morkNode virtual methods</span>
<a href="#l29.53"></a><span id="l29.53" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // ClosePointerMap() only if open</span>
<a href="#l29.54"></a><span id="l29.54" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // ClosePointerMap() only if open</span>
<a href="#l29.55"></a><span id="l29.55">   virtual ~morkPointerMap(); // assert that ClosePointerMap() executed earlier</span>
<a href="#l29.56"></a><span id="l29.56">   </span>
<a href="#l29.57"></a><span id="l29.57"> public: // morkMap construction &amp; destruction</span>
<a href="#l29.58"></a><span id="l29.58"> </span>
<a href="#l29.59"></a><span id="l29.59">   // keySize for morkPointerMap equals sizeof(mork_u4)</span>
<a href="#l29.60"></a><span id="l29.60">   morkPointerMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l29.61"></a><span id="l29.61">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l29.62"></a><span id="l29.62">   void ClosePointerMap(morkEnv* ev); // called by CloseMorkNode();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l30.1"></a><span id="l30.1" class="difflineminus">--- a/db/mork/src/morkMap.cpp</span>
<a href="#l30.2"></a><span id="l30.2" class="difflineplus">+++ b/db/mork/src/morkMap.cpp</span>
<a href="#l30.3"></a><span id="l30.3" class="difflineat">@@ -120,18 +120,16 @@ morkMap::~morkMap() // assert CloseMap()</span>
<a href="#l30.4"></a><span id="l30.4">   MORK_ASSERT(mMap_Vals==0);</span>
<a href="#l30.5"></a><span id="l30.5">   MORK_ASSERT(mMap_Changes==0);</span>
<a href="#l30.6"></a><span id="l30.6">   MORK_ASSERT(mMap_Assocs==0);</span>
<a href="#l30.7"></a><span id="l30.7"> }</span>
<a href="#l30.8"></a><span id="l30.8"> </span>
<a href="#l30.9"></a><span id="l30.9"> /*public non-poly*/ void</span>
<a href="#l30.10"></a><span id="l30.10"> morkMap::CloseMap(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l30.11"></a><span id="l30.11"> {</span>
<a href="#l30.12"></a><span id="l30.12" class="difflineminus">-  if ( this )</span>
<a href="#l30.13"></a><span id="l30.13" class="difflineminus">-  {</span>
<a href="#l30.14"></a><span id="l30.14">     if ( this-&gt;IsNode() )</span>
<a href="#l30.15"></a><span id="l30.15">     {</span>
<a href="#l30.16"></a><span id="l30.16">       nsIMdbHeap* heap = mMap_Heap;</span>
<a href="#l30.17"></a><span id="l30.17">       if ( heap ) /* need to free the arrays? */</span>
<a href="#l30.18"></a><span id="l30.18">       {</span>
<a href="#l30.19"></a><span id="l30.19">         nsIMdbEnv* menv = ev-&gt;AsMdbEnv();</span>
<a href="#l30.20"></a><span id="l30.20">         </span>
<a href="#l30.21"></a><span id="l30.21">         if ( mMap_Keys )</span>
<a href="#l30.22"></a><span id="l30.22" class="difflineat">@@ -155,19 +153,16 @@ morkMap::CloseMap(morkEnv* ev) // called</span>
<a href="#l30.23"></a><span id="l30.23">       mMap_Assocs = 0;</span>
<a href="#l30.24"></a><span id="l30.24">       mMap_Changes = 0;</span>
<a href="#l30.25"></a><span id="l30.25">       mMap_FreeList = 0;</span>
<a href="#l30.26"></a><span id="l30.26">       MORK_MEMSET(&amp;mMap_Form, 0, sizeof(morkMapForm));</span>
<a href="#l30.27"></a><span id="l30.27">       this-&gt;MarkShut();</span>
<a href="#l30.28"></a><span id="l30.28">     }</span>
<a href="#l30.29"></a><span id="l30.29">     else</span>
<a href="#l30.30"></a><span id="l30.30">       this-&gt;NonNodeError(ev);</span>
<a href="#l30.31"></a><span id="l30.31" class="difflineminus">-  }</span>
<a href="#l30.32"></a><span id="l30.32" class="difflineminus">-  else</span>
<a href="#l30.33"></a><span id="l30.33" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l30.34"></a><span id="l30.34"> }</span>
<a href="#l30.35"></a><span id="l30.35"> </span>
<a href="#l30.36"></a><span id="l30.36"> // } ===== end morkNode methods =====</span>
<a href="#l30.37"></a><span id="l30.37"> // ````` ````` ````` ````` ````` </span>
<a href="#l30.38"></a><span id="l30.38"> </span>
<a href="#l30.39"></a><span id="l30.39"> void</span>
<a href="#l30.40"></a><span id="l30.40"> morkMap::clear_map(morkEnv* ev, nsIMdbHeap* ioSlotHeap)</span>
<a href="#l30.41"></a><span id="l30.41"> {</span>
<a href="#l30.42"></a><span id="l30.42" class="difflineat">@@ -221,18 +216,16 @@ void</span>
<a href="#l30.43"></a><span id="l30.43"> morkMap::NewIterOutOfSyncError(morkEnv* ev)</span>
<a href="#l30.44"></a><span id="l30.44"> {</span>
<a href="#l30.45"></a><span id="l30.45">   ev-&gt;NewError(&quot;map iter out of sync&quot;);</span>
<a href="#l30.46"></a><span id="l30.46"> }</span>
<a href="#l30.47"></a><span id="l30.47"> </span>
<a href="#l30.48"></a><span id="l30.48"> void morkMap::NewBadMapError(morkEnv* ev)</span>
<a href="#l30.49"></a><span id="l30.49"> {</span>
<a href="#l30.50"></a><span id="l30.50">   ev-&gt;NewError(&quot;bad morkMap tag&quot;);</span>
<a href="#l30.51"></a><span id="l30.51" class="difflineminus">-  if ( !this )</span>
<a href="#l30.52"></a><span id="l30.52" class="difflineminus">-    ev-&gt;NewError(&quot;nil morkMap instance&quot;);</span>
<a href="#l30.53"></a><span id="l30.53"> }</span>
<a href="#l30.54"></a><span id="l30.54"> </span>
<a href="#l30.55"></a><span id="l30.55"> void morkMap::NewSlotsUnderflowWarning(morkEnv* ev)</span>
<a href="#l30.56"></a><span id="l30.56"> {</span>
<a href="#l30.57"></a><span id="l30.57">   ev-&gt;NewWarning(&quot;member count underflow&quot;);</span>
<a href="#l30.58"></a><span id="l30.58"> }</span>
<a href="#l30.59"></a><span id="l30.59"> </span>
<a href="#l30.60"></a><span id="l30.60"> void morkMap::InitMap(morkEnv* ev, mork_size inSlots)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l31.1"></a><span id="l31.1" class="difflineminus">--- a/db/mork/src/morkMap.h</span>
<a href="#l31.2"></a><span id="l31.2" class="difflineplus">+++ b/db/mork/src/morkMap.h</span>
<a href="#l31.3"></a><span id="l31.3" class="difflineat">@@ -222,17 +222,17 @@ public: // state is public because the e</span>
<a href="#l31.4"></a><span id="l31.4">   </span>
<a href="#l31.5"></a><span id="l31.5">   morkAssoc*        mMap_FreeList; // list of unused mMap_Assocs array slots </span>
<a href="#l31.6"></a><span id="l31.6"> </span>
<a href="#l31.7"></a><span id="l31.7"> public: // getters (morkProbeMap compatibility)</span>
<a href="#l31.8"></a><span id="l31.8">   mork_fill        MapFill() const { return mMap_Fill; }</span>
<a href="#l31.9"></a><span id="l31.9">   </span>
<a href="#l31.10"></a><span id="l31.10"> // { ===== begin morkNode interface =====</span>
<a href="#l31.11"></a><span id="l31.11"> public: // morkNode virtual methods</span>
<a href="#l31.12"></a><span id="l31.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseMap() only if open</span>
<a href="#l31.13"></a><span id="l31.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseMap() only if open</span>
<a href="#l31.14"></a><span id="l31.14">   virtual ~morkMap(); // assert that CloseMap() executed earlier</span>
<a href="#l31.15"></a><span id="l31.15">   </span>
<a href="#l31.16"></a><span id="l31.16"> public: // morkMap construction &amp; destruction</span>
<a href="#l31.17"></a><span id="l31.17">   morkMap(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioNodeHeap, </span>
<a href="#l31.18"></a><span id="l31.18">     mork_size inKeySize, mork_size inValSize,</span>
<a href="#l31.19"></a><span id="l31.19">     mork_size inSlots, nsIMdbHeap* ioSlotHeap, mork_bool inHoldChanges);</span>
<a href="#l31.20"></a><span id="l31.20">   </span>
<a href="#l31.21"></a><span id="l31.21">   void CloseMap(morkEnv* ev); // called by </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l32.1"></a><span id="l32.1" class="difflineminus">--- a/db/mork/src/morkNode.cpp</span>
<a href="#l32.2"></a><span id="l32.2" class="difflineplus">+++ b/db/mork/src/morkNode.cpp</span>
<a href="#l32.3"></a><span id="l32.3" class="difflineat">@@ -140,33 +140,26 @@ morkUsage::morkUsage(mork_usage code)</span>
<a href="#l32.4"></a><span id="l32.4"> }</span>
<a href="#l32.5"></a><span id="l32.5"> </span>
<a href="#l32.6"></a><span id="l32.6"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l32.7"></a><span id="l32.7"> </span>
<a href="#l32.8"></a><span id="l32.8"> /*static*/ void*</span>
<a href="#l32.9"></a><span id="l32.9"> morkNode::MakeNew(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev)</span>
<a href="#l32.10"></a><span id="l32.10"> {</span>
<a href="#l32.11"></a><span id="l32.11">   void* node = 0;</span>
<a href="#l32.12"></a><span id="l32.12" class="difflineminus">-  if ( &amp;ioHeap )</span>
<a href="#l32.13"></a><span id="l32.13" class="difflineminus">-  {</span>
<a href="#l32.14"></a><span id="l32.14">     ioHeap.Alloc(ev-&gt;AsMdbEnv(), inSize, (void **) &amp;node);</span>
<a href="#l32.15"></a><span id="l32.15">     if ( !node )</span>
<a href="#l32.16"></a><span id="l32.16">       ev-&gt;OutOfMemoryError();</span>
<a href="#l32.17"></a><span id="l32.17" class="difflineminus">-  }</span>
<a href="#l32.18"></a><span id="l32.18" class="difflineminus">-  else</span>
<a href="#l32.19"></a><span id="l32.19" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l32.20"></a><span id="l32.20" class="difflineminus">-  </span>
<a href="#l32.21"></a><span id="l32.21" class="difflineplus">+</span>
<a href="#l32.22"></a><span id="l32.22">   return node;</span>
<a href="#l32.23"></a><span id="l32.23"> }</span>
<a href="#l32.24"></a><span id="l32.24"> </span>
<a href="#l32.25"></a><span id="l32.25"> /*public non-poly*/ void</span>
<a href="#l32.26"></a><span id="l32.26"> morkNode::ZapOld(morkEnv* ev, nsIMdbHeap* ioHeap)</span>
<a href="#l32.27"></a><span id="l32.27"> {</span>
<a href="#l32.28"></a><span id="l32.28" class="difflineminus">-  if ( this )</span>
<a href="#l32.29"></a><span id="l32.29" class="difflineminus">-  {</span>
<a href="#l32.30"></a><span id="l32.30">     if ( this-&gt;IsNode() )</span>
<a href="#l32.31"></a><span id="l32.31">     {</span>
<a href="#l32.32"></a><span id="l32.32">       mork_usage usage = mNode_Usage; // mNode_Usage before ~morkNode</span>
<a href="#l32.33"></a><span id="l32.33">       this-&gt;morkNode::~morkNode(); // first call polymorphic destructor</span>
<a href="#l32.34"></a><span id="l32.34">       if ( ioHeap ) // was this node heap allocated?</span>
<a href="#l32.35"></a><span id="l32.35">         ioHeap-&gt;Free(ev-&gt;AsMdbEnv(), this);</span>
<a href="#l32.36"></a><span id="l32.36">       else if ( usage == morkUsage_kPool ) // mNode_Usage before ~morkNode</span>
<a href="#l32.37"></a><span id="l32.37">       {</span>
<a href="#l32.38"></a><span id="l32.38" class="difflineat">@@ -182,19 +175,16 @@ morkNode::ZapOld(morkEnv* ev, nsIMdbHeap</span>
<a href="#l32.39"></a><span id="l32.39">           }</span>
<a href="#l32.40"></a><span id="l32.40">           else</span>
<a href="#l32.41"></a><span id="l32.41">             ev-&gt;NilPointerError();</span>
<a href="#l32.42"></a><span id="l32.42">         }</span>
<a href="#l32.43"></a><span id="l32.43">       }</span>
<a href="#l32.44"></a><span id="l32.44">     }</span>
<a href="#l32.45"></a><span id="l32.45">     else</span>
<a href="#l32.46"></a><span id="l32.46">       this-&gt;NonNodeError(ev);</span>
<a href="#l32.47"></a><span id="l32.47" class="difflineminus">-  }</span>
<a href="#l32.48"></a><span id="l32.48" class="difflineminus">-  else</span>
<a href="#l32.49"></a><span id="l32.49" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l32.50"></a><span id="l32.50"> }</span>
<a href="#l32.51"></a><span id="l32.51"> </span>
<a href="#l32.52"></a><span id="l32.52"> /*public virtual*/ void</span>
<a href="#l32.53"></a><span id="l32.53"> morkNode::CloseMorkNode(morkEnv* ev) // CloseNode() only if open</span>
<a href="#l32.54"></a><span id="l32.54"> {</span>
<a href="#l32.55"></a><span id="l32.55">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l32.56"></a><span id="l32.56">   {</span>
<a href="#l32.57"></a><span id="l32.57">     this-&gt;MarkClosing();</span>
<a href="#l32.58"></a><span id="l32.58" class="difflineat">@@ -347,25 +337,20 @@ morkNode::RefsUnderflowWarning(morkEnv* </span>
<a href="#l32.59"></a><span id="l32.59"> morkNode::UsesUnderflowWarning(morkEnv* ev) const // mNode_Uses underflow</span>
<a href="#l32.60"></a><span id="l32.60"> {</span>
<a href="#l32.61"></a><span id="l32.61">   ev-&gt;NewWarning(&quot;mNode_Uses underflow&quot;);</span>
<a href="#l32.62"></a><span id="l32.62"> }</span>
<a href="#l32.63"></a><span id="l32.63"> </span>
<a href="#l32.64"></a><span id="l32.64"> /*public non-poly*/ void</span>
<a href="#l32.65"></a><span id="l32.65"> morkNode::CloseNode(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l32.66"></a><span id="l32.66"> {</span>
<a href="#l32.67"></a><span id="l32.67" class="difflineminus">-  if ( this )</span>
<a href="#l32.68"></a><span id="l32.68" class="difflineminus">-  {</span>
<a href="#l32.69"></a><span id="l32.69">     if ( this-&gt;IsNode() )</span>
<a href="#l32.70"></a><span id="l32.70">       this-&gt;MarkShut();</span>
<a href="#l32.71"></a><span id="l32.71">     else</span>
<a href="#l32.72"></a><span id="l32.72">       this-&gt;NonNodeError(ev);</span>
<a href="#l32.73"></a><span id="l32.73" class="difflineminus">-  }</span>
<a href="#l32.74"></a><span id="l32.74" class="difflineminus">-  else</span>
<a href="#l32.75"></a><span id="l32.75" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l32.76"></a><span id="l32.76"> }</span>
<a href="#l32.77"></a><span id="l32.77"> </span>
<a href="#l32.78"></a><span id="l32.78"> </span>
<a href="#l32.79"></a><span id="l32.79"> extern void // utility method very similar to morkNode::SlotStrongNode():</span>
<a href="#l32.80"></a><span id="l32.80"> nsIMdbFile_SlotStrongFile(nsIMdbFile* self, morkEnv* ev, nsIMdbFile** ioSlot)</span>
<a href="#l32.81"></a><span id="l32.81">   // If *ioSlot is non-nil, that file is released by CutStrongRef() and</span>
<a href="#l32.82"></a><span id="l32.82">   // then zeroed out.  Then if self is non-nil, this is acquired by</span>
<a href="#l32.83"></a><span id="l32.83">   // calling AddStrongRef(), and if the return value shows success,</span>
<a href="#l32.84"></a><span id="l32.84" class="difflineat">@@ -388,17 +373,16 @@ nsIMdbFile_SlotStrongFile(nsIMdbFile* se</span>
<a href="#l32.85"></a><span id="l32.85"> void // utility method very similar to morkNode::SlotStrongNode():</span>
<a href="#l32.86"></a><span id="l32.86"> nsIMdbHeap_SlotStrongHeap(nsIMdbHeap* self, morkEnv* ev, nsIMdbHeap** ioSlot)</span>
<a href="#l32.87"></a><span id="l32.87">   // If *ioSlot is non-nil, that heap is released by CutStrongRef() and</span>
<a href="#l32.88"></a><span id="l32.88">   // then zeroed out.  Then if self is non-nil, self is acquired by</span>
<a href="#l32.89"></a><span id="l32.89">   // calling AddStrongRef(), and if the return value shows success,</span>
<a href="#l32.90"></a><span id="l32.90">   // then self is put into slot *ioSlot.  Note self can be nil, so we</span>
<a href="#l32.91"></a><span id="l32.91">   // permit expression 'nsIMdbHeap_SlotStrongHeap(0, ev, &amp;slot)'.</span>
<a href="#l32.92"></a><span id="l32.92"> {</span>
<a href="#l32.93"></a><span id="l32.93" class="difflineminus">-  nsIMdbEnv* menv = ev-&gt;AsMdbEnv();</span>
<a href="#l32.94"></a><span id="l32.94">   nsIMdbHeap* heap = *ioSlot;</span>
<a href="#l32.95"></a><span id="l32.95">   if ( self != heap )</span>
<a href="#l32.96"></a><span id="l32.96">   {</span>
<a href="#l32.97"></a><span id="l32.97">     if ( heap )</span>
<a href="#l32.98"></a><span id="l32.98">       *ioSlot = 0;</span>
<a href="#l32.99"></a><span id="l32.99"> </span>
<a href="#l32.100"></a><span id="l32.100">     if (self &amp;&amp; ev-&gt;Good())</span>
<a href="#l32.101"></a><span id="l32.101">       *ioSlot = self;</span>
<a href="#l32.102"></a><span id="l32.102" class="difflineat">@@ -448,18 +432,16 @@ morkNode::SlotWeakNode(morkNode* me, mor</span>
<a href="#l32.103"></a><span id="l32.103">       *ioSlot = me;</span>
<a href="#l32.104"></a><span id="l32.104">   }</span>
<a href="#l32.105"></a><span id="l32.105"> }</span>
<a href="#l32.106"></a><span id="l32.106"> </span>
<a href="#l32.107"></a><span id="l32.107"> /*public non-poly*/ mork_uses</span>
<a href="#l32.108"></a><span id="l32.108"> morkNode::AddStrongRef(morkEnv* ev)</span>
<a href="#l32.109"></a><span id="l32.109"> {</span>
<a href="#l32.110"></a><span id="l32.110">   mork_uses outUses = 0;</span>
<a href="#l32.111"></a><span id="l32.111" class="difflineminus">-  if ( this )</span>
<a href="#l32.112"></a><span id="l32.112" class="difflineminus">-  {</span>
<a href="#l32.113"></a><span id="l32.113">     if ( this-&gt;IsNode() )</span>
<a href="#l32.114"></a><span id="l32.114">     {</span>
<a href="#l32.115"></a><span id="l32.115">       mork_uses uses = mNode_Uses;</span>
<a href="#l32.116"></a><span id="l32.116">       mork_refs refs = mNode_Refs;</span>
<a href="#l32.117"></a><span id="l32.117">       if ( refs &lt; uses ) // need to fix broken refs/uses relation?</span>
<a href="#l32.118"></a><span id="l32.118">       { </span>
<a href="#l32.119"></a><span id="l32.119">         this-&gt;RefsUnderUsesWarning(ev);</span>
<a href="#l32.120"></a><span id="l32.120">         mNode_Refs = mNode_Uses = refs = uses;</span>
<a href="#l32.121"></a><span id="l32.121" class="difflineat">@@ -471,28 +453,23 @@ morkNode::AddStrongRef(morkEnv* ev)</span>
<a href="#l32.122"></a><span id="l32.122">       }</span>
<a href="#l32.123"></a><span id="l32.123">       else</span>
<a href="#l32.124"></a><span id="l32.124">         this-&gt;RefsOverflowWarning(ev);</span>
<a href="#l32.125"></a><span id="l32.125"> </span>
<a href="#l32.126"></a><span id="l32.126">       outUses = uses;</span>
<a href="#l32.127"></a><span id="l32.127">     }</span>
<a href="#l32.128"></a><span id="l32.128">     else</span>
<a href="#l32.129"></a><span id="l32.129">       this-&gt;NonNodeError(ev);</span>
<a href="#l32.130"></a><span id="l32.130" class="difflineminus">-  }</span>
<a href="#l32.131"></a><span id="l32.131" class="difflineminus">-  else</span>
<a href="#l32.132"></a><span id="l32.132" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l32.133"></a><span id="l32.133">   return outUses;</span>
<a href="#l32.134"></a><span id="l32.134"> }</span>
<a href="#l32.135"></a><span id="l32.135"> </span>
<a href="#l32.136"></a><span id="l32.136"> /*private non-poly*/ mork_bool</span>
<a href="#l32.137"></a><span id="l32.137"> morkNode::cut_use_count(morkEnv* ev) // just one part of CutStrongRef()</span>
<a href="#l32.138"></a><span id="l32.138"> {</span>
<a href="#l32.139"></a><span id="l32.139">   mork_bool didCut = morkBool_kFalse;</span>
<a href="#l32.140"></a><span id="l32.140" class="difflineminus">-  if ( this )</span>
<a href="#l32.141"></a><span id="l32.141" class="difflineminus">-  {</span>
<a href="#l32.142"></a><span id="l32.142">     if ( this-&gt;IsNode() )</span>
<a href="#l32.143"></a><span id="l32.143">     {</span>
<a href="#l32.144"></a><span id="l32.144">       mork_uses uses = mNode_Uses;</span>
<a href="#l32.145"></a><span id="l32.145">       if ( uses ) // not yet zero?</span>
<a href="#l32.146"></a><span id="l32.146">         mNode_Uses = --uses;</span>
<a href="#l32.147"></a><span id="l32.147">       else</span>
<a href="#l32.148"></a><span id="l32.148">         this-&gt;UsesUnderflowWarning(ev);</span>
<a href="#l32.149"></a><span id="l32.149"> </span>
<a href="#l32.150"></a><span id="l32.150" class="difflineat">@@ -508,71 +485,58 @@ morkNode::cut_use_count(morkEnv* ev) // </span>
<a href="#l32.151"></a><span id="l32.151">           }</span>
<a href="#l32.152"></a><span id="l32.152">           this-&gt;CloseMorkNode(ev); // polymorphic self close</span>
<a href="#l32.153"></a><span id="l32.153">           // (Note CutNode() is not polymorphic -- so don't call that.)</span>
<a href="#l32.154"></a><span id="l32.154">         }</span>
<a href="#l32.155"></a><span id="l32.155">       }</span>
<a href="#l32.156"></a><span id="l32.156">     }</span>
<a href="#l32.157"></a><span id="l32.157">     else</span>
<a href="#l32.158"></a><span id="l32.158">       this-&gt;NonNodeError(ev);</span>
<a href="#l32.159"></a><span id="l32.159" class="difflineminus">-  }</span>
<a href="#l32.160"></a><span id="l32.160" class="difflineminus">-  else</span>
<a href="#l32.161"></a><span id="l32.161" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l32.162"></a><span id="l32.162">   return didCut;</span>
<a href="#l32.163"></a><span id="l32.163"> }</span>
<a href="#l32.164"></a><span id="l32.164"> </span>
<a href="#l32.165"></a><span id="l32.165"> /*public non-poly*/ mork_uses</span>
<a href="#l32.166"></a><span id="l32.166"> morkNode::CutStrongRef(morkEnv* ev)</span>
<a href="#l32.167"></a><span id="l32.167"> {</span>
<a href="#l32.168"></a><span id="l32.168">   mork_refs outRefs = 0;</span>
<a href="#l32.169"></a><span id="l32.169" class="difflineminus">-  if ( this )</span>
<a href="#l32.170"></a><span id="l32.170" class="difflineminus">-  {</span>
<a href="#l32.171"></a><span id="l32.171">     if ( this-&gt;IsNode() )</span>
<a href="#l32.172"></a><span id="l32.172">     {</span>
<a href="#l32.173"></a><span id="l32.173">       if ( this-&gt;cut_use_count(ev) )</span>
<a href="#l32.174"></a><span id="l32.174">         outRefs = this-&gt;CutWeakRef(ev);</span>
<a href="#l32.175"></a><span id="l32.175">     }</span>
<a href="#l32.176"></a><span id="l32.176">     else</span>
<a href="#l32.177"></a><span id="l32.177">       this-&gt;NonNodeError(ev);</span>
<a href="#l32.178"></a><span id="l32.178" class="difflineminus">-  }</span>
<a href="#l32.179"></a><span id="l32.179" class="difflineminus">-  else</span>
<a href="#l32.180"></a><span id="l32.180" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l32.181"></a><span id="l32.181" class="difflineplus">+</span>
<a href="#l32.182"></a><span id="l32.182">   return outRefs;</span>
<a href="#l32.183"></a><span id="l32.183"> }</span>
<a href="#l32.184"></a><span id="l32.184"> </span>
<a href="#l32.185"></a><span id="l32.185"> /*public non-poly*/ mork_refs</span>
<a href="#l32.186"></a><span id="l32.186"> morkNode::AddWeakRef(morkEnv* ev)</span>
<a href="#l32.187"></a><span id="l32.187"> {</span>
<a href="#l32.188"></a><span id="l32.188">   mork_refs outRefs = 0;</span>
<a href="#l32.189"></a><span id="l32.189" class="difflineminus">-  if ( this )</span>
<a href="#l32.190"></a><span id="l32.190" class="difflineminus">-  {</span>
<a href="#l32.191"></a><span id="l32.191">     if ( this-&gt;IsNode() )</span>
<a href="#l32.192"></a><span id="l32.192">     {</span>
<a href="#l32.193"></a><span id="l32.193">       mork_refs refs = mNode_Refs;</span>
<a href="#l32.194"></a><span id="l32.194">       if ( refs &lt; morkNode_kMaxRefCount ) // not too great?</span>
<a href="#l32.195"></a><span id="l32.195">         mNode_Refs = ++refs;</span>
<a href="#l32.196"></a><span id="l32.196">       else</span>
<a href="#l32.197"></a><span id="l32.197">         this-&gt;RefsOverflowWarning(ev);</span>
<a href="#l32.198"></a><span id="l32.198">         </span>
<a href="#l32.199"></a><span id="l32.199">       outRefs = refs;</span>
<a href="#l32.200"></a><span id="l32.200">     }</span>
<a href="#l32.201"></a><span id="l32.201">     else</span>
<a href="#l32.202"></a><span id="l32.202">       this-&gt;NonNodeError(ev);</span>
<a href="#l32.203"></a><span id="l32.203" class="difflineminus">-  }</span>
<a href="#l32.204"></a><span id="l32.204" class="difflineminus">-  else</span>
<a href="#l32.205"></a><span id="l32.205" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l32.206"></a><span id="l32.206" class="difflineplus">+</span>
<a href="#l32.207"></a><span id="l32.207">   return outRefs;</span>
<a href="#l32.208"></a><span id="l32.208"> }</span>
<a href="#l32.209"></a><span id="l32.209"> </span>
<a href="#l32.210"></a><span id="l32.210"> /*public non-poly*/ mork_refs</span>
<a href="#l32.211"></a><span id="l32.211"> morkNode::CutWeakRef(morkEnv* ev)</span>
<a href="#l32.212"></a><span id="l32.212"> {</span>
<a href="#l32.213"></a><span id="l32.213">   mork_refs outRefs = 0;</span>
<a href="#l32.214"></a><span id="l32.214" class="difflineminus">-  if ( this )</span>
<a href="#l32.215"></a><span id="l32.215" class="difflineminus">-  {</span>
<a href="#l32.216"></a><span id="l32.216">     if ( this-&gt;IsNode() )</span>
<a href="#l32.217"></a><span id="l32.217">     {</span>
<a href="#l32.218"></a><span id="l32.218">       mork_uses uses = mNode_Uses;</span>
<a href="#l32.219"></a><span id="l32.219">       mork_refs refs = mNode_Refs;</span>
<a href="#l32.220"></a><span id="l32.220">       if ( refs ) // not yet zero?</span>
<a href="#l32.221"></a><span id="l32.221">         mNode_Refs = --refs;</span>
<a href="#l32.222"></a><span id="l32.222">       else</span>
<a href="#l32.223"></a><span id="l32.223">         this-&gt;RefsUnderflowWarning(ev);</span>
<a href="#l32.224"></a><span id="l32.224" class="difflineat">@@ -584,19 +548,17 @@ morkNode::CutWeakRef(morkEnv* ev)</span>
<a href="#l32.225"></a><span id="l32.225">       }</span>
<a href="#l32.226"></a><span id="l32.226">         </span>
<a href="#l32.227"></a><span id="l32.227">       outRefs = refs;</span>
<a href="#l32.228"></a><span id="l32.228">       if ( !refs ) // last reference gone? time to destroy node?</span>
<a href="#l32.229"></a><span id="l32.229">         this-&gt;ZapOld(ev, mNode_Heap); // self destroy, use this no longer</span>
<a href="#l32.230"></a><span id="l32.230">     }</span>
<a href="#l32.231"></a><span id="l32.231">     else</span>
<a href="#l32.232"></a><span id="l32.232">       this-&gt;NonNodeError(ev);</span>
<a href="#l32.233"></a><span id="l32.233" class="difflineminus">-  }</span>
<a href="#l32.234"></a><span id="l32.234" class="difflineminus">-  else</span>
<a href="#l32.235"></a><span id="l32.235" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l32.236"></a><span id="l32.236" class="difflineplus">+</span>
<a href="#l32.237"></a><span id="l32.237">   return outRefs;</span>
<a href="#l32.238"></a><span id="l32.238"> }</span>
<a href="#l32.239"></a><span id="l32.239"> </span>
<a href="#l32.240"></a><span id="l32.240"> static const char morkNode_kBroken[] = &quot;broken&quot;;</span>
<a href="#l32.241"></a><span id="l32.241"> </span>
<a href="#l32.242"></a><span id="l32.242"> /*public non-poly*/ const char*</span>
<a href="#l32.243"></a><span id="l32.243"> morkNode::GetNodeAccessAsString() const // e.g. &quot;open&quot;, &quot;shut&quot;, etc.</span>
<a href="#l32.244"></a><span id="l32.244"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l33.1"></a><span id="l33.1" class="difflineminus">--- a/db/mork/src/morkNode.h</span>
<a href="#l33.2"></a><span id="l33.2" class="difflineplus">+++ b/db/mork/src/morkNode.h</span>
<a href="#l33.3"></a><span id="l33.3" class="difflineat">@@ -164,20 +164,20 @@ protected: // construction without an an</span>
<a href="#l33.4"></a><span id="l33.4">   morkNode(const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap);</span>
<a href="#l33.5"></a><span id="l33.5"> </span>
<a href="#l33.6"></a><span id="l33.6">   morkNode(mork_usage inCode); // usage == inCode, heap == nil</span>
<a href="#l33.7"></a><span id="l33.7"> </span>
<a href="#l33.8"></a><span id="l33.8"> // { ===== begin basic node interface =====</span>
<a href="#l33.9"></a><span id="l33.9"> public: // morkNode virtual methods</span>
<a href="#l33.10"></a><span id="l33.10">   // virtual FlushMorkNode(morkEnv* ev, morkStream* ioStream);</span>
<a href="#l33.11"></a><span id="l33.11">   // virtual WriteMorkNode(morkEnv* ev, morkStream* ioStream);</span>
<a href="#l33.12"></a><span id="l33.12" class="difflineminus">-  </span>
<a href="#l33.13"></a><span id="l33.13" class="difflineplus">+</span>
<a href="#l33.14"></a><span id="l33.14">   virtual ~morkNode(); // assert that CloseNode() executed earlier</span>
<a href="#l33.15"></a><span id="l33.15">   virtual void CloseMorkNode(morkEnv* ev); // CloseNode() only if open</span>
<a href="#l33.16"></a><span id="l33.16" class="difflineminus">-  </span>
<a href="#l33.17"></a><span id="l33.17" class="difflineplus">+</span>
<a href="#l33.18"></a><span id="l33.18">   // CloseMorkNode() is the polymorphic close method called when uses==0,</span>
<a href="#l33.19"></a><span id="l33.19">   // which must do NOTHING at all when IsOpenNode() is not true.  Otherwise,</span>
<a href="#l33.20"></a><span id="l33.20">   // CloseMorkNode() should call a static close method specific to an object.</span>
<a href="#l33.21"></a><span id="l33.21">   // Each such static close method should either call inherited static close</span>
<a href="#l33.22"></a><span id="l33.22">   // methods, or else perform the consolidated effect of calling them, where</span>
<a href="#l33.23"></a><span id="l33.23">   // subclasses should closely track any changes in base classes with care.</span>
<a href="#l33.24"></a><span id="l33.24">   </span>
<a href="#l33.25"></a><span id="l33.25"> public: // morkNode construction</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l34.1"></a><span id="l34.1" class="difflineminus">--- a/db/mork/src/morkNodeMap.cpp</span>
<a href="#l34.2"></a><span id="l34.2" class="difflineplus">+++ b/db/mork/src/morkNodeMap.cpp</span>
<a href="#l34.3"></a><span id="l34.3" class="difflineat">@@ -61,29 +61,24 @@ morkNodeMap::morkNodeMap(morkEnv* ev,</span>
<a href="#l34.4"></a><span id="l34.4"> {</span>
<a href="#l34.5"></a><span id="l34.5">   if ( ev-&gt;Good() )</span>
<a href="#l34.6"></a><span id="l34.6">     mNode_Derived = morkDerived_kNodeMap;</span>
<a href="#l34.7"></a><span id="l34.7"> }</span>
<a href="#l34.8"></a><span id="l34.8"> </span>
<a href="#l34.9"></a><span id="l34.9"> /*public non-poly*/ void</span>
<a href="#l34.10"></a><span id="l34.10"> morkNodeMap::CloseNodeMap(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l34.11"></a><span id="l34.11"> {</span>
<a href="#l34.12"></a><span id="l34.12" class="difflineminus">-  if ( this )</span>
<a href="#l34.13"></a><span id="l34.13" class="difflineminus">-  {</span>
<a href="#l34.14"></a><span id="l34.14">     if ( this-&gt;IsNode() )</span>
<a href="#l34.15"></a><span id="l34.15">     {</span>
<a href="#l34.16"></a><span id="l34.16">       this-&gt;CutAllNodes(ev);</span>
<a href="#l34.17"></a><span id="l34.17">       this-&gt;CloseMap(ev);</span>
<a href="#l34.18"></a><span id="l34.18">       this-&gt;MarkShut();</span>
<a href="#l34.19"></a><span id="l34.19">     }</span>
<a href="#l34.20"></a><span id="l34.20">     else</span>
<a href="#l34.21"></a><span id="l34.21">       this-&gt;NonNodeError(ev);</span>
<a href="#l34.22"></a><span id="l34.22" class="difflineminus">-  }</span>
<a href="#l34.23"></a><span id="l34.23" class="difflineminus">-  else</span>
<a href="#l34.24"></a><span id="l34.24" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l34.25"></a><span id="l34.25"> }</span>
<a href="#l34.26"></a><span id="l34.26"> </span>
<a href="#l34.27"></a><span id="l34.27"> // } ===== end morkNode methods =====</span>
<a href="#l34.28"></a><span id="l34.28"> // ````` ````` ````` ````` ````` </span>
<a href="#l34.29"></a><span id="l34.29"> </span>
<a href="#l34.30"></a><span id="l34.30"> mork_bool</span>
<a href="#l34.31"></a><span id="l34.31"> morkNodeMap::AddNode(morkEnv* ev, mork_token inToken, morkNode* ioNode)</span>
<a href="#l34.32"></a><span id="l34.32">   // the AddNode() method return value equals ev-&gt;Good().</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l35.1"></a><span id="l35.1" class="difflineminus">--- a/db/mork/src/morkNodeMap.h</span>
<a href="#l35.2"></a><span id="l35.2" class="difflineplus">+++ b/db/mork/src/morkNodeMap.h</span>
<a href="#l35.3"></a><span id="l35.3" class="difflineat">@@ -29,19 +29,19 @@</span>
<a href="#l35.4"></a><span id="l35.4"> #define morkNodeMap_kStartSlotCount 512</span>
<a href="#l35.5"></a><span id="l35.5"> </span>
<a href="#l35.6"></a><span id="l35.6"> /*| morkNodeMap: maps mork_token -&gt; morkNode</span>
<a href="#l35.7"></a><span id="l35.7"> |*/</span>
<a href="#l35.8"></a><span id="l35.8"> class morkNodeMap : public morkIntMap { // for mapping tokens to nodes</span>
<a href="#l35.9"></a><span id="l35.9"> </span>
<a href="#l35.10"></a><span id="l35.10"> // { ===== begin morkNode interface =====</span>
<a href="#l35.11"></a><span id="l35.11"> public: // morkNode virtual methods</span>
<a href="#l35.12"></a><span id="l35.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseNodeMap() only if open</span>
<a href="#l35.13"></a><span id="l35.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseNodeMap() only if open</span>
<a href="#l35.14"></a><span id="l35.14">   virtual ~morkNodeMap(); // assert that CloseNodeMap() executed earlier</span>
<a href="#l35.15"></a><span id="l35.15" class="difflineminus">-  </span>
<a href="#l35.16"></a><span id="l35.16" class="difflineplus">+</span>
<a href="#l35.17"></a><span id="l35.17"> public: // morkMap construction &amp; destruction</span>
<a href="#l35.18"></a><span id="l35.18">   morkNodeMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l35.19"></a><span id="l35.19">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l35.20"></a><span id="l35.20">   void CloseNodeMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l35.21"></a><span id="l35.21"> </span>
<a href="#l35.22"></a><span id="l35.22"> public: // dynamic type identification</span>
<a href="#l35.23"></a><span id="l35.23">   mork_bool IsNodeMap() const</span>
<a href="#l35.24"></a><span id="l35.24">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kNodeMap; }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l36.1"></a><span id="l36.1" class="difflineminus">--- a/db/mork/src/morkObject.cpp</span>
<a href="#l36.2"></a><span id="l36.2" class="difflineplus">+++ b/db/mork/src/morkObject.cpp</span>
<a href="#l36.3"></a><span id="l36.3" class="difflineat">@@ -81,34 +81,29 @@ morkObject::morkObject(morkEnv* ev,</span>
<a href="#l36.4"></a><span id="l36.4">     if ( ev-&gt;Good() )</span>
<a href="#l36.5"></a><span id="l36.5">       mNode_Derived = morkDerived_kObject;</span>
<a href="#l36.6"></a><span id="l36.6">   }</span>
<a href="#l36.7"></a><span id="l36.7"> }</span>
<a href="#l36.8"></a><span id="l36.8"> </span>
<a href="#l36.9"></a><span id="l36.9"> /*public non-poly*/ void</span>
<a href="#l36.10"></a><span id="l36.10"> morkObject::CloseObject(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l36.11"></a><span id="l36.11"> {</span>
<a href="#l36.12"></a><span id="l36.12" class="difflineminus">-  if ( this )</span>
<a href="#l36.13"></a><span id="l36.13" class="difflineminus">-  {</span>
<a href="#l36.14"></a><span id="l36.14">     if ( this-&gt;IsNode() )</span>
<a href="#l36.15"></a><span id="l36.15">     {</span>
<a href="#l36.16"></a><span id="l36.16">       if ( !this-&gt;IsShutNode() )</span>
<a href="#l36.17"></a><span id="l36.17">       {</span>
<a href="#l36.18"></a><span id="l36.18">         if ( mObject_Handle )</span>
<a href="#l36.19"></a><span id="l36.19">           morkHandle::SlotWeakHandle((morkHandle*) 0L, ev, &amp;mObject_Handle);</span>
<a href="#l36.20"></a><span id="l36.20">           </span>
<a href="#l36.21"></a><span id="l36.21">         mBead_Color = 0; // this-&gt;CloseBead(ev);</span>
<a href="#l36.22"></a><span id="l36.22">         this-&gt;MarkShut();</span>
<a href="#l36.23"></a><span id="l36.23">       }</span>
<a href="#l36.24"></a><span id="l36.24">     }</span>
<a href="#l36.25"></a><span id="l36.25">     else</span>
<a href="#l36.26"></a><span id="l36.26">       this-&gt;NonNodeError(ev);</span>
<a href="#l36.27"></a><span id="l36.27" class="difflineminus">-  }</span>
<a href="#l36.28"></a><span id="l36.28" class="difflineminus">-  else</span>
<a href="#l36.29"></a><span id="l36.29" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l36.30"></a><span id="l36.30"> }</span>
<a href="#l36.31"></a><span id="l36.31"> </span>
<a href="#l36.32"></a><span id="l36.32"> // } ===== end morkNode methods =====</span>
<a href="#l36.33"></a><span id="l36.33"> // ````` ````` ````` ````` ````` </span>
<a href="#l36.34"></a><span id="l36.34"> </span>
<a href="#l36.35"></a><span id="l36.35"> // { ----- begin factory methods -----</span>
<a href="#l36.36"></a><span id="l36.36"> NS_IMETHODIMP</span>
<a href="#l36.37"></a><span id="l36.37"> morkObject::GetMdbFactory(nsIMdbEnv* mev, nsIMdbFactory** acqFactory)</span>
<a href="#l36.38"></a><span id="l36.38" class="difflineat">@@ -141,36 +136,53 @@ morkObject::GetStrongRefCount(nsIMdbEnv*</span>
<a href="#l36.39"></a><span id="l36.39"> }</span>
<a href="#l36.40"></a><span id="l36.40"> // ### TODO - clean up this cast, if required</span>
<a href="#l36.41"></a><span id="l36.41"> NS_IMETHODIMP</span>
<a href="#l36.42"></a><span id="l36.42"> morkObject::AddWeakRef(nsIMdbEnv* mev)</span>
<a href="#l36.43"></a><span id="l36.43"> {</span>
<a href="#l36.44"></a><span id="l36.44">   // XXX Casting mork_refs to nsresult</span>
<a href="#l36.45"></a><span id="l36.45">   return static_cast&lt;nsresult&gt;(morkNode::AddWeakRef((morkEnv *) mev));</span>
<a href="#l36.46"></a><span id="l36.46"> }</span>
<a href="#l36.47"></a><span id="l36.47" class="difflineplus">+</span>
<a href="#l36.48"></a><span id="l36.48" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l36.49"></a><span id="l36.49" class="difflineplus">+NS_IMETHODIMP_(mork_uses)</span>
<a href="#l36.50"></a><span id="l36.50" class="difflineplus">+morkObject::AddStrongRef(morkEnv* mev)</span>
<a href="#l36.51"></a><span id="l36.51" class="difflineplus">+{</span>
<a href="#l36.52"></a><span id="l36.52" class="difflineplus">+  return morkNode::AddStrongRef(mev);</span>
<a href="#l36.53"></a><span id="l36.53" class="difflineplus">+}</span>
<a href="#l36.54"></a><span id="l36.54" class="difflineplus">+#endif</span>
<a href="#l36.55"></a><span id="l36.55" class="difflineplus">+</span>
<a href="#l36.56"></a><span id="l36.56"> NS_IMETHODIMP_(mork_uses)</span>
<a href="#l36.57"></a><span id="l36.57"> morkObject::AddStrongRef(nsIMdbEnv* mev)</span>
<a href="#l36.58"></a><span id="l36.58"> {</span>
<a href="#l36.59"></a><span id="l36.59">   return morkNode::AddStrongRef((morkEnv *) mev);</span>
<a href="#l36.60"></a><span id="l36.60"> }</span>
<a href="#l36.61"></a><span id="l36.61"> </span>
<a href="#l36.62"></a><span id="l36.62"> NS_IMETHODIMP</span>
<a href="#l36.63"></a><span id="l36.63"> morkObject::CutWeakRef(nsIMdbEnv* mev)</span>
<a href="#l36.64"></a><span id="l36.64"> {</span>
<a href="#l36.65"></a><span id="l36.65">   // XXX Casting mork_refs to nsresult</span>
<a href="#l36.66"></a><span id="l36.66">   return static_cast&lt;nsresult&gt;(morkNode::CutWeakRef((morkEnv *) mev));</span>
<a href="#l36.67"></a><span id="l36.67"> }</span>
<a href="#l36.68"></a><span id="l36.68" class="difflineplus">+</span>
<a href="#l36.69"></a><span id="l36.69" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l36.70"></a><span id="l36.70" class="difflineplus">+NS_IMETHODIMP_(mork_uses)</span>
<a href="#l36.71"></a><span id="l36.71" class="difflineplus">+morkObject::CutStrongRef(morkEnv* mev)</span>
<a href="#l36.72"></a><span id="l36.72" class="difflineplus">+{</span>
<a href="#l36.73"></a><span id="l36.73" class="difflineplus">+  return morkNode::CutStrongRef(mev);</span>
<a href="#l36.74"></a><span id="l36.74" class="difflineplus">+}</span>
<a href="#l36.75"></a><span id="l36.75" class="difflineplus">+#endif</span>
<a href="#l36.76"></a><span id="l36.76" class="difflineplus">+</span>
<a href="#l36.77"></a><span id="l36.77"> NS_IMETHODIMP</span>
<a href="#l36.78"></a><span id="l36.78"> morkObject::CutStrongRef(nsIMdbEnv* mev)</span>
<a href="#l36.79"></a><span id="l36.79"> {</span>
<a href="#l36.80"></a><span id="l36.80">   // XXX Casting mork_refs to nsresult</span>
<a href="#l36.81"></a><span id="l36.81">   return static_cast&lt;nsresult&gt;(morkNode::CutStrongRef((morkEnv *) mev));</span>
<a href="#l36.82"></a><span id="l36.82"> }</span>
<a href="#l36.83"></a><span id="l36.83"> </span>
<a href="#l36.84"></a><span id="l36.84" class="difflineminus">-  </span>
<a href="#l36.85"></a><span id="l36.85"> NS_IMETHODIMP</span>
<a href="#l36.86"></a><span id="l36.86"> morkObject::CloseMdbObject(nsIMdbEnv* mev)</span>
<a href="#l36.87"></a><span id="l36.87"> {</span>
<a href="#l36.88"></a><span id="l36.88">   return morkNode::CloseMdbObject((morkEnv *) mev);</span>
<a href="#l36.89"></a><span id="l36.89"> }</span>
<a href="#l36.90"></a><span id="l36.90"> </span>
<a href="#l36.91"></a><span id="l36.91"> NS_IMETHODIMP</span>
<a href="#l36.92"></a><span id="l36.92"> morkObject::IsOpenMdbObject(nsIMdbEnv* mev, mdb_bool* outOpen)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l37.1"></a><span id="l37.1" class="difflineminus">--- a/db/mork/src/morkObject.h</span>
<a href="#l37.2"></a><span id="l37.2" class="difflineplus">+++ b/db/mork/src/morkObject.h</span>
<a href="#l37.3"></a><span id="l37.3" class="difflineat">@@ -54,53 +54,61 @@ class morkObject : public morkBead, publ</span>
<a href="#l37.4"></a><span id="l37.4">   </span>
<a href="#l37.5"></a><span id="l37.5"> public: // state is public because the entire Mork system is private</span>
<a href="#l37.6"></a><span id="l37.6"> </span>
<a href="#l37.7"></a><span id="l37.7">   morkHandle*      mObject_Handle;   // weak ref to handle for this object</span>
<a href="#l37.8"></a><span id="l37.8"> </span>
<a href="#l37.9"></a><span id="l37.9">   morkEnv * mMorkEnv; // weak ref to environment this object created in.</span>
<a href="#l37.10"></a><span id="l37.10"> // { ===== begin morkNode interface =====</span>
<a href="#l37.11"></a><span id="l37.11"> public: // morkNode virtual methods</span>
<a href="#l37.12"></a><span id="l37.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseObject() only if open</span>
<a href="#l37.13"></a><span id="l37.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseObject() only if open</span>
<a href="#l37.14"></a><span id="l37.14"> #ifdef MORK_DEBUG_HEAP_STATS</span>
<a href="#l37.15"></a><span id="l37.15">   void operator delete(void* ioAddress, size_t size)</span>
<a href="#l37.16"></a><span id="l37.16">   { </span>
<a href="#l37.17"></a><span id="l37.17">     mork_u4* array = (mork_u4*) ioAddress;</span>
<a href="#l37.18"></a><span id="l37.18">     array -= 3;</span>
<a href="#l37.19"></a><span id="l37.19">     orkinHeap *heap = (orkinHeap *) *array;</span>
<a href="#l37.20"></a><span id="l37.20">     if (heap)</span>
<a href="#l37.21"></a><span id="l37.21">       heap-&gt;Free(nullptr, ioAddress);</span>
<a href="#l37.22"></a><span id="l37.22">   }</span>
<a href="#l37.23"></a><span id="l37.23"> #endif</span>
<a href="#l37.24"></a><span id="l37.24"> </span>
<a href="#l37.25"></a><span id="l37.25">   NS_DECL_ISUPPORTS</span>
<a href="#l37.26"></a><span id="l37.26"> </span>
<a href="#l37.27"></a><span id="l37.27">     // { ----- begin attribute methods -----</span>
<a href="#l37.28"></a><span id="l37.28" class="difflineminus">-  NS_IMETHOD IsFrozenMdbObject(nsIMdbEnv* ev, mdb_bool* outIsReadonly);</span>
<a href="#l37.29"></a><span id="l37.29" class="difflineplus">+  NS_IMETHOD IsFrozenMdbObject(nsIMdbEnv* ev, mdb_bool* outIsReadonly) override;</span>
<a href="#l37.30"></a><span id="l37.30">   // same as nsIMdbPort::GetIsPortReadonly() when this object is inside a port.</span>
<a href="#l37.31"></a><span id="l37.31">   // } ----- end attribute methods -----</span>
<a href="#l37.32"></a><span id="l37.32"> </span>
<a href="#l37.33"></a><span id="l37.33">   // { ----- begin factory methods -----</span>
<a href="#l37.34"></a><span id="l37.34" class="difflineminus">-  NS_IMETHOD GetMdbFactory(nsIMdbEnv* ev, nsIMdbFactory** acqFactory); </span>
<a href="#l37.35"></a><span id="l37.35" class="difflineplus">+  NS_IMETHOD GetMdbFactory(nsIMdbEnv* ev, nsIMdbFactory** acqFactory) override;</span>
<a href="#l37.36"></a><span id="l37.36">   // } ----- end factory methods -----</span>
<a href="#l37.37"></a><span id="l37.37"> </span>
<a href="#l37.38"></a><span id="l37.38">   // { ----- begin ref counting for well-behaved cyclic graphs -----</span>
<a href="#l37.39"></a><span id="l37.39">   NS_IMETHOD GetWeakRefCount(nsIMdbEnv* ev, // weak refs</span>
<a href="#l37.40"></a><span id="l37.40" class="difflineminus">-    mdb_count* outCount);  </span>
<a href="#l37.41"></a><span id="l37.41" class="difflineplus">+    mdb_count* outCount) override;</span>
<a href="#l37.42"></a><span id="l37.42">   NS_IMETHOD GetStrongRefCount(nsIMdbEnv* ev, // strong refs</span>
<a href="#l37.43"></a><span id="l37.43" class="difflineminus">-    mdb_count* outCount);</span>
<a href="#l37.44"></a><span id="l37.44" class="difflineplus">+    mdb_count* outCount) override;</span>
<a href="#l37.45"></a><span id="l37.45"> </span>
<a href="#l37.46"></a><span id="l37.46" class="difflineminus">-  NS_IMETHOD AddWeakRef(nsIMdbEnv* ev);</span>
<a href="#l37.47"></a><span id="l37.47" class="difflineminus">-  NS_IMETHOD_(mork_uses) AddStrongRef(nsIMdbEnv* ev);</span>
<a href="#l37.48"></a><span id="l37.48" class="difflineplus">+  NS_IMETHOD AddWeakRef(nsIMdbEnv* ev) override;</span>
<a href="#l37.49"></a><span id="l37.49" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l37.50"></a><span id="l37.50" class="difflineplus">+  // The first declaration of AddStrongRef is to suppress -Werror,-Woverloaded-virtual.</span>
<a href="#l37.51"></a><span id="l37.51" class="difflineplus">+  NS_IMETHOD_(mork_uses) AddStrongRef(morkEnv* ev) override;</span>
<a href="#l37.52"></a><span id="l37.52" class="difflineplus">+#endif</span>
<a href="#l37.53"></a><span id="l37.53" class="difflineplus">+  NS_IMETHOD_(mork_uses) AddStrongRef(nsIMdbEnv* ev) override;</span>
<a href="#l37.54"></a><span id="l37.54"> </span>
<a href="#l37.55"></a><span id="l37.55" class="difflineminus">-  NS_IMETHOD CutWeakRef(nsIMdbEnv* ev);</span>
<a href="#l37.56"></a><span id="l37.56" class="difflineminus">-  NS_IMETHOD CutStrongRef(nsIMdbEnv* ev);</span>
<a href="#l37.57"></a><span id="l37.57" class="difflineminus">-  </span>
<a href="#l37.58"></a><span id="l37.58" class="difflineminus">-  NS_IMETHOD CloseMdbObject(nsIMdbEnv* ev); // called at strong refs zero</span>
<a href="#l37.59"></a><span id="l37.59" class="difflineminus">-  NS_IMETHOD IsOpenMdbObject(nsIMdbEnv* ev, mdb_bool* outOpen);</span>
<a href="#l37.60"></a><span id="l37.60" class="difflineplus">+  NS_IMETHOD CutWeakRef(nsIMdbEnv* ev) override;</span>
<a href="#l37.61"></a><span id="l37.61" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l37.62"></a><span id="l37.62" class="difflineplus">+  // The first declaration of CutStrongRef is to suppress -Werror,-Woverloaded-virtual.</span>
<a href="#l37.63"></a><span id="l37.63" class="difflineplus">+  NS_IMETHOD_(mork_uses) CutStrongRef(morkEnv* ev) override;</span>
<a href="#l37.64"></a><span id="l37.64" class="difflineplus">+#endif</span>
<a href="#l37.65"></a><span id="l37.65" class="difflineplus">+  NS_IMETHOD CutStrongRef(nsIMdbEnv* ev) override;</span>
<a href="#l37.66"></a><span id="l37.66" class="difflineplus">+</span>
<a href="#l37.67"></a><span id="l37.67" class="difflineplus">+  NS_IMETHOD CloseMdbObject(nsIMdbEnv* ev) override; // called at strong refs zero</span>
<a href="#l37.68"></a><span id="l37.68" class="difflineplus">+  NS_IMETHOD IsOpenMdbObject(nsIMdbEnv* ev, mdb_bool* outOpen) override;</span>
<a href="#l37.69"></a><span id="l37.69">   // } ----- end ref counting -----</span>
<a href="#l37.70"></a><span id="l37.70">   </span>
<a href="#l37.71"></a><span id="l37.71"> </span>
<a href="#l37.72"></a><span id="l37.72"> protected: // special case construction of first env without preceding env</span>
<a href="#l37.73"></a><span id="l37.73">   morkObject(const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l37.74"></a><span id="l37.74">     mork_color inBeadColor);</span>
<a href="#l37.75"></a><span id="l37.75">   virtual ~morkObject(); // assert that CloseObject() executed earlier</span>
<a href="#l37.76"></a><span id="l37.76">   </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l38.1"></a><span id="l38.1" class="difflineminus">--- a/db/mork/src/morkParser.cpp</span>
<a href="#l38.2"></a><span id="l38.2" class="difflineplus">+++ b/db/mork/src/morkParser.cpp</span>
<a href="#l38.3"></a><span id="l38.3" class="difflineat">@@ -141,36 +141,31 @@ morkParser::morkParser(morkEnv* ev,</span>
<a href="#l38.4"></a><span id="l38.4">   }</span>
<a href="#l38.5"></a><span id="l38.5">   else</span>
<a href="#l38.6"></a><span id="l38.6">     ev-&gt;NilPointerError();</span>
<a href="#l38.7"></a><span id="l38.7"> }</span>
<a href="#l38.8"></a><span id="l38.8"> </span>
<a href="#l38.9"></a><span id="l38.9"> /*public non-poly*/ void</span>
<a href="#l38.10"></a><span id="l38.10"> morkParser::CloseParser(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l38.11"></a><span id="l38.11"> {</span>
<a href="#l38.12"></a><span id="l38.12" class="difflineminus">-  if ( this )</span>
<a href="#l38.13"></a><span id="l38.13" class="difflineminus">-  {</span>
<a href="#l38.14"></a><span id="l38.14">     if ( this-&gt;IsNode() )</span>
<a href="#l38.15"></a><span id="l38.15">     {</span>
<a href="#l38.16"></a><span id="l38.16">       if ( !this-&gt;IsShutNode() )</span>
<a href="#l38.17"></a><span id="l38.17">       {</span>
<a href="#l38.18"></a><span id="l38.18">         mParser_ScopeCoil.CloseCoil(ev);</span>
<a href="#l38.19"></a><span id="l38.19">         mParser_ValueCoil.CloseCoil(ev);</span>
<a href="#l38.20"></a><span id="l38.20">         mParser_ColumnCoil.CloseCoil(ev);</span>
<a href="#l38.21"></a><span id="l38.21">         mParser_StringCoil.CloseCoil(ev);</span>
<a href="#l38.22"></a><span id="l38.22">         nsIMdbHeap_SlotStrongHeap((nsIMdbHeap*) 0, ev, &amp;mParser_Heap);</span>
<a href="#l38.23"></a><span id="l38.23">         morkStream::SlotStrongStream((morkStream*) 0, ev, &amp;mParser_Stream);</span>
<a href="#l38.24"></a><span id="l38.24">         this-&gt;MarkShut();</span>
<a href="#l38.25"></a><span id="l38.25">       }</span>
<a href="#l38.26"></a><span id="l38.26">     }</span>
<a href="#l38.27"></a><span id="l38.27">     else</span>
<a href="#l38.28"></a><span id="l38.28">       this-&gt;NonNodeError(ev);</span>
<a href="#l38.29"></a><span id="l38.29" class="difflineminus">-  }</span>
<a href="#l38.30"></a><span id="l38.30" class="difflineminus">-  else</span>
<a href="#l38.31"></a><span id="l38.31" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l38.32"></a><span id="l38.32"> }</span>
<a href="#l38.33"></a><span id="l38.33"> </span>
<a href="#l38.34"></a><span id="l38.34"> // } ===== end morkNode methods =====</span>
<a href="#l38.35"></a><span id="l38.35"> // ````` ````` ````` ````` ````` </span>
<a href="#l38.36"></a><span id="l38.36"> </span>
<a href="#l38.37"></a><span id="l38.37"> /*protected non-poly*/ void</span>
<a href="#l38.38"></a><span id="l38.38"> morkParser::NonGoodParserError(morkEnv* ev) // when GoodParserTag() is false</span>
<a href="#l38.39"></a><span id="l38.39"> {</span>
<a href="#l38.40"></a><span id="l38.40" class="difflineat">@@ -283,17 +278,17 @@ morkParser::StopParse(morkEnv* ev)</span>
<a href="#l38.41"></a><span id="l38.41"> }</span>
<a href="#l38.42"></a><span id="l38.42"> </span>
<a href="#l38.43"></a><span id="l38.43"> int morkParser::eat_comment(morkEnv* ev) // last char was '/'</span>
<a href="#l38.44"></a><span id="l38.44"> {</span>
<a href="#l38.45"></a><span id="l38.45">   morkStream* s = mParser_Stream;</span>
<a href="#l38.46"></a><span id="l38.46">   // Note morkStream::Getc() returns EOF when an error occurs, so</span>
<a href="#l38.47"></a><span id="l38.47">   // we don't need to check for both c != EOF and ev-&gt;Good() below.</span>
<a href="#l38.48"></a><span id="l38.48">   </span>
<a href="#l38.49"></a><span id="l38.49" class="difflineminus">-  register int c = s-&gt;Getc(ev);</span>
<a href="#l38.50"></a><span id="l38.50" class="difflineplus">+  int c = s-&gt;Getc(ev);</span>
<a href="#l38.51"></a><span id="l38.51">   if ( c == '/' ) // C++ style comment?</span>
<a href="#l38.52"></a><span id="l38.52">   {</span>
<a href="#l38.53"></a><span id="l38.53">     while ( (c = s-&gt;Getc(ev)) != EOF &amp;&amp; c != 0xA &amp;&amp; c != 0xD )</span>
<a href="#l38.54"></a><span id="l38.54">       /* empty */;</span>
<a href="#l38.55"></a><span id="l38.55">       </span>
<a href="#l38.56"></a><span id="l38.56">     if ( c == 0xA || c == 0xD )</span>
<a href="#l38.57"></a><span id="l38.57">       c = this-&gt;eat_line_break(ev, c);</span>
<a href="#l38.58"></a><span id="l38.58">   }</span>
<a href="#l38.59"></a><span id="l38.59" class="difflineat">@@ -342,44 +337,44 @@ int morkParser::eat_comment(morkEnv* ev)</span>
<a href="#l38.60"></a><span id="l38.60">     ev-&gt;NewWarning(&quot;expected / or *&quot;);</span>
<a href="#l38.61"></a><span id="l38.61">   </span>
<a href="#l38.62"></a><span id="l38.62">   return c;</span>
<a href="#l38.63"></a><span id="l38.63"> }</span>
<a href="#l38.64"></a><span id="l38.64"> </span>
<a href="#l38.65"></a><span id="l38.65"> int morkParser::eat_line_break(morkEnv* ev, int inLast)</span>
<a href="#l38.66"></a><span id="l38.66"> {</span>
<a href="#l38.67"></a><span id="l38.67">   morkStream* s = mParser_Stream;</span>
<a href="#l38.68"></a><span id="l38.68" class="difflineminus">-  register int c = s-&gt;Getc(ev); // get next char after 0xA or 0xD</span>
<a href="#l38.69"></a><span id="l38.69" class="difflineplus">+  int c = s-&gt;Getc(ev); // get next char after 0xA or 0xD</span>
<a href="#l38.70"></a><span id="l38.70">   this-&gt;CountLineBreak();</span>
<a href="#l38.71"></a><span id="l38.71">   if ( c == 0xA || c == 0xD ) // another line break character?</span>
<a href="#l38.72"></a><span id="l38.72">   {</span>
<a href="#l38.73"></a><span id="l38.73">     if ( c != inLast ) // not the same as the last one?</span>
<a href="#l38.74"></a><span id="l38.74">       c = s-&gt;Getc(ev); // get next char after two-byte linebreak</span>
<a href="#l38.75"></a><span id="l38.75">   }</span>
<a href="#l38.76"></a><span id="l38.76">   return c;</span>
<a href="#l38.77"></a><span id="l38.77"> }</span>
<a href="#l38.78"></a><span id="l38.78"> </span>
<a href="#l38.79"></a><span id="l38.79"> int morkParser::eat_line_continue(morkEnv* ev) // last char was '\'</span>
<a href="#l38.80"></a><span id="l38.80"> {</span>
<a href="#l38.81"></a><span id="l38.81">   morkStream* s = mParser_Stream;</span>
<a href="#l38.82"></a><span id="l38.82" class="difflineminus">-  register int c = s-&gt;Getc(ev);</span>
<a href="#l38.83"></a><span id="l38.83" class="difflineplus">+  int c = s-&gt;Getc(ev);</span>
<a href="#l38.84"></a><span id="l38.84">   if ( c == 0xA || c == 0xD ) // linebreak follows \ as expected?</span>
<a href="#l38.85"></a><span id="l38.85">   {</span>
<a href="#l38.86"></a><span id="l38.86">     c = this-&gt;eat_line_break(ev, c);</span>
<a href="#l38.87"></a><span id="l38.87">   }</span>
<a href="#l38.88"></a><span id="l38.88">   else</span>
<a href="#l38.89"></a><span id="l38.89">     ev-&gt;NewWarning(&quot;expected linebreak&quot;);</span>
<a href="#l38.90"></a><span id="l38.90">   </span>
<a href="#l38.91"></a><span id="l38.91">   return c;</span>
<a href="#l38.92"></a><span id="l38.92"> }</span>
<a href="#l38.93"></a><span id="l38.93"> </span>
<a href="#l38.94"></a><span id="l38.94"> int morkParser::NextChar(morkEnv* ev) // next non-white content</span>
<a href="#l38.95"></a><span id="l38.95"> {</span>
<a href="#l38.96"></a><span id="l38.96">   morkStream* s = mParser_Stream;</span>
<a href="#l38.97"></a><span id="l38.97" class="difflineminus">-  register int c = s-&gt;Getc(ev);</span>
<a href="#l38.98"></a><span id="l38.98" class="difflineplus">+  int c = s-&gt;Getc(ev);</span>
<a href="#l38.99"></a><span id="l38.99">   while ( c &gt; 0 &amp;&amp; ev-&gt;Good() )</span>
<a href="#l38.100"></a><span id="l38.100">   {</span>
<a href="#l38.101"></a><span id="l38.101">     if ( c == '/' )</span>
<a href="#l38.102"></a><span id="l38.102">       c = this-&gt;eat_comment(ev);</span>
<a href="#l38.103"></a><span id="l38.103">     else if ( c == 0xA || c == 0xD )</span>
<a href="#l38.104"></a><span id="l38.104">       c = this-&gt;eat_line_break(ev, c);</span>
<a href="#l38.105"></a><span id="l38.105">     else if ( c == '\\' )</span>
<a href="#l38.106"></a><span id="l38.106">       c = this-&gt;eat_line_continue(ev);</span>
<a href="#l38.107"></a><span id="l38.107" class="difflineat">@@ -429,17 +424,17 @@ morkParser::OnTableState(morkEnv* ev)</span>
<a href="#l38.108"></a><span id="l38.108"> }</span>
<a href="#l38.109"></a><span id="l38.109"> </span>
<a href="#l38.110"></a><span id="l38.110"> void</span>
<a href="#l38.111"></a><span id="l38.111"> morkParser::OnDictState(morkEnv* ev)</span>
<a href="#l38.112"></a><span id="l38.112"> {</span>
<a href="#l38.113"></a><span id="l38.113">   ev-&gt;StubMethodOnlyError();</span>
<a href="#l38.114"></a><span id="l38.114"> }</span>
<a href="#l38.115"></a><span id="l38.115"> </span>
<a href="#l38.116"></a><span id="l38.116" class="difflineminus">-morkBuf* morkParser::ReadName(morkEnv* ev, register int c)</span>
<a href="#l38.117"></a><span id="l38.117" class="difflineplus">+morkBuf* morkParser::ReadName(morkEnv* ev, int c)</span>
<a href="#l38.118"></a><span id="l38.118"> {</span>
<a href="#l38.119"></a><span id="l38.119">   morkBuf* outBuf = 0;</span>
<a href="#l38.120"></a><span id="l38.120">   </span>
<a href="#l38.121"></a><span id="l38.121">   if ( !morkCh_IsName(c) )</span>
<a href="#l38.122"></a><span id="l38.122">     ev-&gt;NewError(&quot;not a name char&quot;);</span>
<a href="#l38.123"></a><span id="l38.123"> </span>
<a href="#l38.124"></a><span id="l38.124">   morkCoil* coil = &amp;mParser_ColumnCoil;</span>
<a href="#l38.125"></a><span id="l38.125">   coil-&gt;ClearBufFill();</span>
<a href="#l38.126"></a><span id="l38.126" class="difflineat">@@ -475,17 +470,17 @@ morkBuf* morkParser::ReadName(morkEnv* e</span>
<a href="#l38.127"></a><span id="l38.127"> mork_bool</span>
<a href="#l38.128"></a><span id="l38.128"> morkParser::ReadMid(morkEnv* ev, morkMid* outMid)</span>
<a href="#l38.129"></a><span id="l38.129"> {</span>
<a href="#l38.130"></a><span id="l38.130">   outMid-&gt;ClearMid();</span>
<a href="#l38.131"></a><span id="l38.131">   </span>
<a href="#l38.132"></a><span id="l38.132">   morkStream* s = mParser_Stream;</span>
<a href="#l38.133"></a><span id="l38.133">   int next;</span>
<a href="#l38.134"></a><span id="l38.134">   outMid-&gt;mMid_Oid.mOid_Id = this-&gt;ReadHex(ev, &amp;next);</span>
<a href="#l38.135"></a><span id="l38.135" class="difflineminus">-  register int c = next;</span>
<a href="#l38.136"></a><span id="l38.136" class="difflineplus">+  int c = next;</span>
<a href="#l38.137"></a><span id="l38.137">   if ( c == ':' )</span>
<a href="#l38.138"></a><span id="l38.138">   {</span>
<a href="#l38.139"></a><span id="l38.139">     if ( (c = s-&gt;Getc(ev)) != EOF &amp;&amp; ev-&gt;Good() )</span>
<a href="#l38.140"></a><span id="l38.140">     {</span>
<a href="#l38.141"></a><span id="l38.141">       if ( c == '^' )</span>
<a href="#l38.142"></a><span id="l38.142">       {</span>
<a href="#l38.143"></a><span id="l38.143">         outMid-&gt;mMid_Oid.mOid_Scope = this-&gt;ReadHex(ev, &amp;next);</span>
<a href="#l38.144"></a><span id="l38.144">         if ( ev-&gt;Good() )</span>
<a href="#l38.145"></a><span id="l38.145" class="difflineat">@@ -512,17 +507,17 @@ void</span>
<a href="#l38.146"></a><span id="l38.146"> morkParser::ReadCell(morkEnv* ev)</span>
<a href="#l38.147"></a><span id="l38.147"> {</span>
<a href="#l38.148"></a><span id="l38.148">   mParser_CellMid.ClearMid();</span>
<a href="#l38.149"></a><span id="l38.149">   // this-&gt;StartSpanOnLastByte(ev, &amp;mParser_CellSpan);</span>
<a href="#l38.150"></a><span id="l38.150">   morkMid* cellMid = 0; // if mid syntax is used for column</span>
<a href="#l38.151"></a><span id="l38.151">   morkBuf* cellBuf = 0; // if naked string is used for column</span>
<a href="#l38.152"></a><span id="l38.152"> </span>
<a href="#l38.153"></a><span id="l38.153">   morkStream* s = mParser_Stream;</span>
<a href="#l38.154"></a><span id="l38.154" class="difflineminus">-  register int c;</span>
<a href="#l38.155"></a><span id="l38.155" class="difflineplus">+  int c;</span>
<a href="#l38.156"></a><span id="l38.156">   if ( (c = s-&gt;Getc(ev)) != EOF &amp;&amp; ev-&gt;Good() )</span>
<a href="#l38.157"></a><span id="l38.157">   {</span>
<a href="#l38.158"></a><span id="l38.158">     // this-&gt;StartSpanOnLastByte(ev, &amp;mParser_ColumnSpan);</span>
<a href="#l38.159"></a><span id="l38.159">     if ( c == '^' )</span>
<a href="#l38.160"></a><span id="l38.160">     {</span>
<a href="#l38.161"></a><span id="l38.161">       cellMid = &amp;mParser_CellMid;</span>
<a href="#l38.162"></a><span id="l38.162">       this-&gt;ReadMid(ev, cellMid);</span>
<a href="#l38.163"></a><span id="l38.163">       // if ( !mParser_CellMid.mMid_Oid.mOid_Scope )</span>
<a href="#l38.164"></a><span id="l38.164" class="difflineat">@@ -793,17 +788,17 @@ void morkParser::ReadTable(morkEnv* ev)</span>
<a href="#l38.165"></a><span id="l38.165"> </span>
<a href="#l38.166"></a><span id="l38.166"> mork_id morkParser::ReadHex(morkEnv* ev, int* outNextChar)</span>
<a href="#l38.167"></a><span id="l38.167"> // zm:Hex   ::= [0-9a-fA-F] /* a single hex digit */</span>
<a href="#l38.168"></a><span id="l38.168"> // zm:Hex+  ::= zm:Hex | zm:Hex zm:Hex+</span>
<a href="#l38.169"></a><span id="l38.169"> {</span>
<a href="#l38.170"></a><span id="l38.170">   mork_id hex = 0;</span>
<a href="#l38.171"></a><span id="l38.171"> </span>
<a href="#l38.172"></a><span id="l38.172">   morkStream* s = mParser_Stream;</span>
<a href="#l38.173"></a><span id="l38.173" class="difflineminus">-  register int c = this-&gt;NextChar(ev);</span>
<a href="#l38.174"></a><span id="l38.174" class="difflineplus">+  int c = this-&gt;NextChar(ev);</span>
<a href="#l38.175"></a><span id="l38.175">     </span>
<a href="#l38.176"></a><span id="l38.176">   if ( ev-&gt;Good() )</span>
<a href="#l38.177"></a><span id="l38.177">   {</span>
<a href="#l38.178"></a><span id="l38.178">     if ( c != EOF )</span>
<a href="#l38.179"></a><span id="l38.179">     {</span>
<a href="#l38.180"></a><span id="l38.180">       if ( morkCh_IsHex(c) )</span>
<a href="#l38.181"></a><span id="l38.181">       {</span>
<a href="#l38.182"></a><span id="l38.182">         do</span>
<a href="#l38.183"></a><span id="l38.183" class="difflineat">@@ -864,17 +859,17 @@ morkBuf* morkParser::ReadValue(morkEnv* </span>
<a href="#l38.184"></a><span id="l38.184">   coil-&gt;ClearBufFill();</span>
<a href="#l38.185"></a><span id="l38.185"> </span>
<a href="#l38.186"></a><span id="l38.186">   morkSpool* spool = &amp;mParser_ValueSpool;</span>
<a href="#l38.187"></a><span id="l38.187">   spool-&gt;Seek(ev, /*pos*/ 0);</span>
<a href="#l38.188"></a><span id="l38.188">   </span>
<a href="#l38.189"></a><span id="l38.189">   if ( ev-&gt;Good() )</span>
<a href="#l38.190"></a><span id="l38.190">   {</span>
<a href="#l38.191"></a><span id="l38.191">     morkStream* s = mParser_Stream;</span>
<a href="#l38.192"></a><span id="l38.192" class="difflineminus">-    register int c;</span>
<a href="#l38.193"></a><span id="l38.193" class="difflineplus">+    int c;</span>
<a href="#l38.194"></a><span id="l38.194">     while ( (c = s-&gt;Getc(ev)) != EOF &amp;&amp; c != ')' &amp;&amp; ev-&gt;Good() )</span>
<a href="#l38.195"></a><span id="l38.195">     {</span>
<a href="#l38.196"></a><span id="l38.196">       if ( c == '\\' ) // next char is escaped by '\'? </span>
<a href="#l38.197"></a><span id="l38.197">       {</span>
<a href="#l38.198"></a><span id="l38.198">         if ( (c = s-&gt;Getc(ev)) == 0xA || c == 0xD ) // linebreak after \?</span>
<a href="#l38.199"></a><span id="l38.199">         {</span>
<a href="#l38.200"></a><span id="l38.200">           c = this-&gt;eat_line_break(ev, c);</span>
<a href="#l38.201"></a><span id="l38.201">           if ( c == ')' || c == '\\' || c == '$' )</span>
<a href="#l38.202"></a><span id="l38.202" class="difflineat">@@ -991,17 +986,17 @@ void morkParser::ReadCellForm(morkEnv *e</span>
<a href="#l38.203"></a><span id="l38.203"> void morkParser::ReadAlias(morkEnv* ev)</span>
<a href="#l38.204"></a><span id="l38.204"> // zm:Alias     ::= zm:S? '(' ('#')? zm:Hex+ zm:S? zm:Value ')'</span>
<a href="#l38.205"></a><span id="l38.205"> // zm:Value   ::= '=' ([^)$\] | '\' zm:NonCRLF | zm:Continue | zm:Dollar)*</span>
<a href="#l38.206"></a><span id="l38.206"> {</span>
<a href="#l38.207"></a><span id="l38.207">   // this-&gt;StartSpanOnLastByte(ev, &amp;mParser_AliasSpan);</span>
<a href="#l38.208"></a><span id="l38.208"> </span>
<a href="#l38.209"></a><span id="l38.209">   int nextChar;</span>
<a href="#l38.210"></a><span id="l38.210">   mork_id hex = this-&gt;ReadHex(ev, &amp;nextChar);</span>
<a href="#l38.211"></a><span id="l38.211" class="difflineminus">-  register int c = nextChar;</span>
<a href="#l38.212"></a><span id="l38.212" class="difflineplus">+  int c = nextChar;</span>
<a href="#l38.213"></a><span id="l38.213"> </span>
<a href="#l38.214"></a><span id="l38.214">   mParser_Mid.ClearMid();</span>
<a href="#l38.215"></a><span id="l38.215">   mParser_Mid.mMid_Oid.mOid_Id = hex;</span>
<a href="#l38.216"></a><span id="l38.216"> </span>
<a href="#l38.217"></a><span id="l38.217">   if ( morkCh_IsWhite(c) &amp;&amp; ev-&gt;Good() )</span>
<a href="#l38.218"></a><span id="l38.218">     c = this-&gt;NextChar(ev);</span>
<a href="#l38.219"></a><span id="l38.219"> </span>
<a href="#l38.220"></a><span id="l38.220">   if ( ev-&gt;Good() )</span>
<a href="#l38.221"></a><span id="l38.221" class="difflineat">@@ -1102,17 +1097,17 @@ morkParser::NonParserTypeError(morkEnv* </span>
<a href="#l38.222"></a><span id="l38.222">   ev-&gt;NewError(&quot;non morkParser&quot;);</span>
<a href="#l38.223"></a><span id="l38.223"> }</span>
<a href="#l38.224"></a><span id="l38.224"> </span>
<a href="#l38.225"></a><span id="l38.225"> mork_bool morkParser::MatchPattern(morkEnv* ev, const char* inPattern)</span>
<a href="#l38.226"></a><span id="l38.226"> {</span>
<a href="#l38.227"></a><span id="l38.227">   // if an error occurs, we want original inPattern in the debugger:</span>
<a href="#l38.228"></a><span id="l38.228">   const char* pattern = inPattern; // mutable copy of pointer</span>
<a href="#l38.229"></a><span id="l38.229">   morkStream* s = mParser_Stream;</span>
<a href="#l38.230"></a><span id="l38.230" class="difflineminus">-  register int c;</span>
<a href="#l38.231"></a><span id="l38.231" class="difflineplus">+  int c;</span>
<a href="#l38.232"></a><span id="l38.232">   while ( *pattern &amp;&amp; ev-&gt;Good() )</span>
<a href="#l38.233"></a><span id="l38.233">   {</span>
<a href="#l38.234"></a><span id="l38.234">     char byte = *pattern++;</span>
<a href="#l38.235"></a><span id="l38.235">     if ( (c = s-&gt;Getc(ev)) != byte )</span>
<a href="#l38.236"></a><span id="l38.236">     {</span>
<a href="#l38.237"></a><span id="l38.237">       ev-&gt;NewError(&quot;byte not in expected pattern&quot;);</span>
<a href="#l38.238"></a><span id="l38.238">     }</span>
<a href="#l38.239"></a><span id="l38.239">   }</span>
<a href="#l38.240"></a><span id="l38.240" class="difflineat">@@ -1122,17 +1117,17 @@ mork_bool morkParser::MatchPattern(morkE</span>
<a href="#l38.241"></a><span id="l38.241"> mork_bool morkParser::FindGroupEnd(morkEnv* ev)</span>
<a href="#l38.242"></a><span id="l38.242"> {</span>
<a href="#l38.243"></a><span id="l38.243">   mork_bool foundEnd = morkBool_kFalse;</span>
<a href="#l38.244"></a><span id="l38.244">   </span>
<a href="#l38.245"></a><span id="l38.245">   // char gidBuf[ 64 ]; // to hold hex pattern we want</span>
<a href="#l38.246"></a><span id="l38.246">   // (void) ev-&gt;TokenAsHex(gidBuf, mParser_GroupId);</span>
<a href="#l38.247"></a><span id="l38.247">   </span>
<a href="#l38.248"></a><span id="l38.248">   morkStream* s = mParser_Stream;</span>
<a href="#l38.249"></a><span id="l38.249" class="difflineminus">-  register int c;</span>
<a href="#l38.250"></a><span id="l38.250" class="difflineplus">+  int c;</span>
<a href="#l38.251"></a><span id="l38.251">   </span>
<a href="#l38.252"></a><span id="l38.252">   while ( (c = s-&gt;Getc(ev)) != EOF &amp;&amp; ev-&gt;Good() &amp;&amp; !foundEnd )</span>
<a href="#l38.253"></a><span id="l38.253">   {</span>
<a href="#l38.254"></a><span id="l38.254">     if ( c == '@' ) // maybe start of group ending?</span>
<a href="#l38.255"></a><span id="l38.255">     {</span>
<a href="#l38.256"></a><span id="l38.256">       // this-&gt;EndSpanOnThisByte(ev, &amp;mParser_GroupSpan);</span>
<a href="#l38.257"></a><span id="l38.257">       if ( (c = s-&gt;Getc(ev)) == '$' ) // '$' follows '@' ?</span>
<a href="#l38.258"></a><span id="l38.258">       {</span>
<a href="#l38.259"></a><span id="l38.259" class="difflineat">@@ -1159,17 +1154,17 @@ mork_bool morkParser::FindGroupEnd(morkE</span>
<a href="#l38.260"></a><span id="l38.260"> void morkParser::ReadGroup(morkEnv* mev)</span>
<a href="#l38.261"></a><span id="l38.261"> {</span>
<a href="#l38.262"></a><span id="l38.262">   nsIMdbEnv *ev = mev-&gt;AsMdbEnv();</span>
<a href="#l38.263"></a><span id="l38.263">   int next = 0;</span>
<a href="#l38.264"></a><span id="l38.264">   mParser_GroupId = this-&gt;ReadHex(mev, &amp;next);</span>
<a href="#l38.265"></a><span id="l38.265">   if ( next == '{' )</span>
<a href="#l38.266"></a><span id="l38.266">   {</span>
<a href="#l38.267"></a><span id="l38.267">     morkStream* s = mParser_Stream;</span>
<a href="#l38.268"></a><span id="l38.268" class="difflineminus">-     register int c;</span>
<a href="#l38.269"></a><span id="l38.269" class="difflineplus">+     int c;</span>
<a href="#l38.270"></a><span id="l38.270">     if ( (c = s-&gt;Getc(mev)) == '@' )</span>
<a href="#l38.271"></a><span id="l38.271">     {</span>
<a href="#l38.272"></a><span id="l38.272">     	// we really need the following span inside morkBuilder::OnNewGroup():</span>
<a href="#l38.273"></a><span id="l38.273">       this-&gt;StartSpanOnThisByte(mev, &amp;mParser_GroupSpan);</span>
<a href="#l38.274"></a><span id="l38.274">       mork_pos startPos = mParser_GroupSpan.mSpan_Start.mPlace_Pos;</span>
<a href="#l38.275"></a><span id="l38.275"> </span>
<a href="#l38.276"></a><span id="l38.276">       // if ( !store-&gt;mStore_FirstCommitGroupPos )</span>
<a href="#l38.277"></a><span id="l38.277">       //   store-&gt;mStore_FirstCommitGroupPos = startPos;</span>
<a href="#l38.278"></a><span id="l38.278" class="difflineat">@@ -1207,17 +1202,17 @@ mork_bool morkParser::ReadAt(morkEnv* ev</span>
<a href="#l38.279"></a><span id="l38.279"> // zm:GroupCommit ::= zm:S? '@$$}' zm:Hex+ '}@'  /* id matches start id */</span>
<a href="#l38.280"></a><span id="l38.280"> // zm:GroupAbort  ::= zm:S? '@$$}~~}@' /* id matches start id */</span>
<a href="#l38.281"></a><span id="l38.281"> /* We must allow started transactions to be aborted in summary files. */</span>
<a href="#l38.282"></a><span id="l38.282"> /* Note '$$' will never occur unescaped in values we will see in Mork. */</span>
<a href="#l38.283"></a><span id="l38.283"> {</span>
<a href="#l38.284"></a><span id="l38.284">   if ( this-&gt;MatchPattern(ev, &quot;$$&quot;) )</span>
<a href="#l38.285"></a><span id="l38.285">   {</span>
<a href="#l38.286"></a><span id="l38.286">     morkStream* s = mParser_Stream;</span>
<a href="#l38.287"></a><span id="l38.287" class="difflineminus">-     register int c;</span>
<a href="#l38.288"></a><span id="l38.288" class="difflineplus">+     int c;</span>
<a href="#l38.289"></a><span id="l38.289">     if ( ((c = s-&gt;Getc(ev)) == '{' || c == '}') &amp;&amp; ev-&gt;Good() )</span>
<a href="#l38.290"></a><span id="l38.290">      {</span>
<a href="#l38.291"></a><span id="l38.291">        if ( c == '{' ) // start of new group?</span>
<a href="#l38.292"></a><span id="l38.292">        {</span>
<a href="#l38.293"></a><span id="l38.293">          if ( !inInsideGroup )</span>
<a href="#l38.294"></a><span id="l38.294">            this-&gt;ReadGroup(ev);</span>
<a href="#l38.295"></a><span id="l38.295">          else</span>
<a href="#l38.296"></a><span id="l38.296">            ev-&gt;NewError(&quot;nested @$${ inside another group&quot;);</span>
<a href="#l38.297"></a><span id="l38.297" class="difflineat">@@ -1238,17 +1233,17 @@ mork_bool morkParser::ReadAt(morkEnv* ev</span>
<a href="#l38.298"></a><span id="l38.298">   }</span>
<a href="#l38.299"></a><span id="l38.299">   return ev-&gt;Good();</span>
<a href="#l38.300"></a><span id="l38.300"> }</span>
<a href="#l38.301"></a><span id="l38.301"> </span>
<a href="#l38.302"></a><span id="l38.302"> mork_bool morkParser::ReadEndGroupId(morkEnv* ev)</span>
<a href="#l38.303"></a><span id="l38.303"> {</span>
<a href="#l38.304"></a><span id="l38.304">   mork_bool outSawGroupId = morkBool_kFalse;</span>
<a href="#l38.305"></a><span id="l38.305">   morkStream* s = mParser_Stream;</span>
<a href="#l38.306"></a><span id="l38.306" class="difflineminus">-  register int c;</span>
<a href="#l38.307"></a><span id="l38.307" class="difflineplus">+  int c;</span>
<a href="#l38.308"></a><span id="l38.308">   if ( (c = s-&gt;Getc(ev)) != EOF &amp;&amp; ev-&gt;Good() )</span>
<a href="#l38.309"></a><span id="l38.309">   {</span>
<a href="#l38.310"></a><span id="l38.310">     if ( c == '~' ) // transaction is aborted?</span>
<a href="#l38.311"></a><span id="l38.311">     {</span>
<a href="#l38.312"></a><span id="l38.312">       this-&gt;MatchPattern(ev, &quot;~}@&quot;); // finish rest of pattern</span>
<a href="#l38.313"></a><span id="l38.313">     }</span>
<a href="#l38.314"></a><span id="l38.314">     else // push back byte and read expected trailing hex id</span>
<a href="#l38.315"></a><span id="l38.315">     {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l39.1"></a><span id="l39.1" class="difflineminus">--- a/db/mork/src/morkParser.h</span>
<a href="#l39.2"></a><span id="l39.2" class="difflineplus">+++ b/db/mork/src/morkParser.h</span>
<a href="#l39.3"></a><span id="l39.3" class="difflineat">@@ -289,22 +289,22 @@ private: // convenience inlines</span>
<a href="#l39.4"></a><span id="l39.4">   mork_pos HerePos() const</span>
<a href="#l39.5"></a><span id="l39.5">   { return mParser_PortSpan.mSpan_End.mPlace_Pos; }</span>
<a href="#l39.6"></a><span id="l39.6"> </span>
<a href="#l39.7"></a><span id="l39.7">   void SetHerePos(mork_pos inPos)</span>
<a href="#l39.8"></a><span id="l39.8">   { mParser_PortSpan.mSpan_End.mPlace_Pos = inPos; }</span>
<a href="#l39.9"></a><span id="l39.9"> </span>
<a href="#l39.10"></a><span id="l39.10">   void CountLineBreak()</span>
<a href="#l39.11"></a><span id="l39.11">   { ++mParser_PortSpan.mSpan_End.mPlace_Line; }</span>
<a href="#l39.12"></a><span id="l39.12" class="difflineminus">-  </span>
<a href="#l39.13"></a><span id="l39.13" class="difflineplus">+</span>
<a href="#l39.14"></a><span id="l39.14"> // { ===== begin morkNode interface =====</span>
<a href="#l39.15"></a><span id="l39.15"> public: // morkNode virtual methods</span>
<a href="#l39.16"></a><span id="l39.16" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseParser() only if open</span>
<a href="#l39.17"></a><span id="l39.17" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseParser() only if open</span>
<a href="#l39.18"></a><span id="l39.18">   virtual ~morkParser(); // assert that CloseParser() executed earlier</span>
<a href="#l39.19"></a><span id="l39.19" class="difflineminus">-  </span>
<a href="#l39.20"></a><span id="l39.20" class="difflineplus">+</span>
<a href="#l39.21"></a><span id="l39.21"> public: // morkYarn construction &amp; destruction</span>
<a href="#l39.22"></a><span id="l39.22">   morkParser(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l39.23"></a><span id="l39.23">     morkStream* ioStream,  // the readonly stream for input bytes</span>
<a href="#l39.24"></a><span id="l39.24">     mdb_count inBytesPerParseSegment, // target for ParseMore()</span>
<a href="#l39.25"></a><span id="l39.25">     nsIMdbHeap* ioSlotHeap);</span>
<a href="#l39.26"></a><span id="l39.26">       </span>
<a href="#l39.27"></a><span id="l39.27">   void CloseParser(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l39.28"></a><span id="l39.28"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l40.1"></a><span id="l40.1" class="difflineminus">--- a/db/mork/src/morkPool.cpp</span>
<a href="#l40.2"></a><span id="l40.2" class="difflineplus">+++ b/db/mork/src/morkPool.cpp</span>
<a href="#l40.3"></a><span id="l40.3" class="difflineat">@@ -104,18 +104,16 @@ morkPool::morkPool(morkEnv* ev,</span>
<a href="#l40.4"></a><span id="l40.4">   }</span>
<a href="#l40.5"></a><span id="l40.5">   else</span>
<a href="#l40.6"></a><span id="l40.6">     ev-&gt;NilPointerError();</span>
<a href="#l40.7"></a><span id="l40.7"> }</span>
<a href="#l40.8"></a><span id="l40.8"> </span>
<a href="#l40.9"></a><span id="l40.9"> /*public non-poly*/ void</span>
<a href="#l40.10"></a><span id="l40.10"> morkPool::ClosePool(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l40.11"></a><span id="l40.11"> {</span>
<a href="#l40.12"></a><span id="l40.12" class="difflineminus">-  if ( this )</span>
<a href="#l40.13"></a><span id="l40.13" class="difflineminus">-  {</span>
<a href="#l40.14"></a><span id="l40.14">     if ( this-&gt;IsNode() )</span>
<a href="#l40.15"></a><span id="l40.15">     {</span>
<a href="#l40.16"></a><span id="l40.16"> #ifdef morkZone_CONFIG_ARENA</span>
<a href="#l40.17"></a><span id="l40.17"> #else /*morkZone_CONFIG_ARENA*/</span>
<a href="#l40.18"></a><span id="l40.18">     //MORK_USED_1(ioZone);</span>
<a href="#l40.19"></a><span id="l40.19"> #endif /*morkZone_CONFIG_ARENA*/</span>
<a href="#l40.20"></a><span id="l40.20"> </span>
<a href="#l40.21"></a><span id="l40.21">       nsIMdbHeap* heap = mPool_Heap;</span>
<a href="#l40.22"></a><span id="l40.22" class="difflineat">@@ -129,19 +127,16 @@ morkPool::ClosePool(morkEnv* ev) // call</span>
<a href="#l40.23"></a><span id="l40.23">       d = &amp;mPool_UsedHandleFrames;</span>
<a href="#l40.24"></a><span id="l40.24">       while ( (aLink = d-&gt;RemoveFirst()) != 0 )</span>
<a href="#l40.25"></a><span id="l40.25">         heap-&gt;Free(mev, aLink);</span>
<a href="#l40.26"></a><span id="l40.26">   </span>
<a href="#l40.27"></a><span id="l40.27">       this-&gt;MarkShut();</span>
<a href="#l40.28"></a><span id="l40.28">     }</span>
<a href="#l40.29"></a><span id="l40.29">     else</span>
<a href="#l40.30"></a><span id="l40.30">       this-&gt;NonNodeError(ev);</span>
<a href="#l40.31"></a><span id="l40.31" class="difflineminus">-  }</span>
<a href="#l40.32"></a><span id="l40.32" class="difflineminus">-  else</span>
<a href="#l40.33"></a><span id="l40.33" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l40.34"></a><span id="l40.34"> }</span>
<a href="#l40.35"></a><span id="l40.35"> </span>
<a href="#l40.36"></a><span id="l40.36"> // } ===== end morkNode methods =====</span>
<a href="#l40.37"></a><span id="l40.37"> // ````` ````` ````` ````` ````` </span>
<a href="#l40.38"></a><span id="l40.38"> </span>
<a href="#l40.39"></a><span id="l40.39"> </span>
<a href="#l40.40"></a><span id="l40.40"> // alloc and free individual instances of handles (inside hand frames):</span>
<a href="#l40.41"></a><span id="l40.41"> morkHandleFace*</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l41.1"></a><span id="l41.1" class="difflineminus">--- a/db/mork/src/morkPool.h</span>
<a href="#l41.2"></a><span id="l41.2" class="difflineplus">+++ b/db/mork/src/morkPool.h</span>
<a href="#l41.3"></a><span id="l41.3" class="difflineat">@@ -54,22 +54,22 @@ public: // state is public because the e</span>
<a href="#l41.4"></a><span id="l41.4">   morkDeque    mPool_Blocks;      // linked list of large blocks from heap</span>
<a href="#l41.5"></a><span id="l41.5">   </span>
<a href="#l41.6"></a><span id="l41.6">   // These two lists contain instances of morkHandleFrame:</span>
<a href="#l41.7"></a><span id="l41.7">   morkDeque    mPool_UsedHandleFrames; // handle frames currently being used</span>
<a href="#l41.8"></a><span id="l41.8">   morkDeque    mPool_FreeHandleFrames; // handle frames currently in free list</span>
<a href="#l41.9"></a><span id="l41.9">   </span>
<a href="#l41.10"></a><span id="l41.10">   mork_count   mPool_UsedFramesCount; // length of mPool_UsedHandleFrames</span>
<a href="#l41.11"></a><span id="l41.11">   mork_count   mPool_FreeFramesCount; // length of mPool_UsedHandleFrames</span>
<a href="#l41.12"></a><span id="l41.12" class="difflineminus">-    </span>
<a href="#l41.13"></a><span id="l41.13" class="difflineplus">+</span>
<a href="#l41.14"></a><span id="l41.14"> // { ===== begin morkNode interface =====</span>
<a href="#l41.15"></a><span id="l41.15"> public: // morkNode virtual methods</span>
<a href="#l41.16"></a><span id="l41.16">   virtual void CloseMorkNode(morkEnv* ev); // ClosePool() only if open</span>
<a href="#l41.17"></a><span id="l41.17">   virtual ~morkPool(); // assert that ClosePool() executed earlier</span>
<a href="#l41.18"></a><span id="l41.18" class="difflineminus">-  </span>
<a href="#l41.19"></a><span id="l41.19" class="difflineplus">+</span>
<a href="#l41.20"></a><span id="l41.20"> public: // morkPool construction &amp; destruction</span>
<a href="#l41.21"></a><span id="l41.21">   morkPool(const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l41.22"></a><span id="l41.22">     nsIMdbHeap* ioSlotHeap);</span>
<a href="#l41.23"></a><span id="l41.23">   morkPool(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l41.24"></a><span id="l41.24">     nsIMdbHeap* ioSlotHeap);</span>
<a href="#l41.25"></a><span id="l41.25">   void ClosePool(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l41.26"></a><span id="l41.26"> </span>
<a href="#l41.27"></a><span id="l41.27"> private: // copying is not allowed</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l42.1"></a><span id="l42.1" class="difflineminus">--- a/db/mork/src/morkPortTableCursor.cpp</span>
<a href="#l42.2"></a><span id="l42.2" class="difflineplus">+++ b/db/mork/src/morkPortTableCursor.cpp</span>
<a href="#l42.3"></a><span id="l42.3" class="difflineat">@@ -105,34 +105,29 @@ morkPortTableCursor::CanUsePortTableCurs</span>
<a href="#l42.4"></a><span id="l42.4">   MORK_ASSERT(outEnv);</span>
<a href="#l42.5"></a><span id="l42.5">   return outEnv;</span>
<a href="#l42.6"></a><span id="l42.6"> }</span>
<a href="#l42.7"></a><span id="l42.7"> </span>
<a href="#l42.8"></a><span id="l42.8"> </span>
<a href="#l42.9"></a><span id="l42.9"> /*public non-poly*/ void</span>
<a href="#l42.10"></a><span id="l42.10"> morkPortTableCursor::ClosePortTableCursor(morkEnv* ev) </span>
<a href="#l42.11"></a><span id="l42.11"> {</span>
<a href="#l42.12"></a><span id="l42.12" class="difflineminus">-  if ( this )</span>
<a href="#l42.13"></a><span id="l42.13" class="difflineminus">-  {</span>
<a href="#l42.14"></a><span id="l42.14">     if ( this-&gt;IsNode() )</span>
<a href="#l42.15"></a><span id="l42.15">     {</span>
<a href="#l42.16"></a><span id="l42.16">       mCursor_Pos = -1;</span>
<a href="#l42.17"></a><span id="l42.17">       mCursor_Seed = 0;</span>
<a href="#l42.18"></a><span id="l42.18">       mPortTableCursor_LastTable = 0;</span>
<a href="#l42.19"></a><span id="l42.19">       morkStore::SlotWeakStore((morkStore*) 0, ev, &amp;mPortTableCursor_Store);</span>
<a href="#l42.20"></a><span id="l42.20">       morkRowSpace::SlotStrongRowSpace((morkRowSpace*) 0, ev,</span>
<a href="#l42.21"></a><span id="l42.21">         &amp;mPortTableCursor_RowSpace);</span>
<a href="#l42.22"></a><span id="l42.22">       this-&gt;CloseCursor(ev);</span>
<a href="#l42.23"></a><span id="l42.23">       this-&gt;MarkShut();</span>
<a href="#l42.24"></a><span id="l42.24">     }</span>
<a href="#l42.25"></a><span id="l42.25">     else</span>
<a href="#l42.26"></a><span id="l42.26">       this-&gt;NonNodeError(ev);</span>
<a href="#l42.27"></a><span id="l42.27" class="difflineminus">-  }</span>
<a href="#l42.28"></a><span id="l42.28" class="difflineminus">-  else</span>
<a href="#l42.29"></a><span id="l42.29" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l42.30"></a><span id="l42.30"> }</span>
<a href="#l42.31"></a><span id="l42.31"> </span>
<a href="#l42.32"></a><span id="l42.32"> // } ===== end morkNode methods =====</span>
<a href="#l42.33"></a><span id="l42.33"> // ````` ````` ````` ````` ````` </span>
<a href="#l42.34"></a><span id="l42.34"> </span>
<a href="#l42.35"></a><span id="l42.35"> /*static*/ void</span>
<a href="#l42.36"></a><span id="l42.36"> morkPortTableCursor::NilCursorStoreError(morkEnv* ev)</span>
<a href="#l42.37"></a><span id="l42.37"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l43.1"></a><span id="l43.1" class="difflineminus">--- a/db/mork/src/morkPortTableCursor.h</span>
<a href="#l43.2"></a><span id="l43.2" class="difflineplus">+++ b/db/mork/src/morkPortTableCursor.h</span>
<a href="#l43.3"></a><span id="l43.3" class="difflineat">@@ -41,34 +41,34 @@ public:</span>
<a href="#l43.4"></a><span id="l43.4"> </span>
<a href="#l43.5"></a><span id="l43.5">   // mork_seed  mCursor_Seed;</span>
<a href="#l43.6"></a><span id="l43.6">   // mork_pos   mCursor_Pos;</span>
<a href="#l43.7"></a><span id="l43.7">   // mork_bool  mCursor_DoFailOnSeedOutOfSync;</span>
<a href="#l43.8"></a><span id="l43.8">   // mork_u1    mCursor_Pad[ 3 ]; // explicitly pad to u4 alignment</span>
<a href="#l43.9"></a><span id="l43.9"> </span>
<a href="#l43.10"></a><span id="l43.10"> public: // state is public because the entire Mork system is private</span>
<a href="#l43.11"></a><span id="l43.11">   // { ----- begin attribute methods -----</span>
<a href="#l43.12"></a><span id="l43.12" class="difflineminus">-  NS_IMETHOD SetPort(nsIMdbEnv* ev, nsIMdbPort* ioPort); // sets pos to -1</span>
<a href="#l43.13"></a><span id="l43.13" class="difflineminus">-  NS_IMETHOD GetPort(nsIMdbEnv* ev, nsIMdbPort** acqPort);</span>
<a href="#l43.14"></a><span id="l43.14" class="difflineminus">-  </span>
<a href="#l43.15"></a><span id="l43.15" class="difflineplus">+  NS_IMETHOD SetPort(nsIMdbEnv* ev, nsIMdbPort* ioPort) override; // sets pos to -1</span>
<a href="#l43.16"></a><span id="l43.16" class="difflineplus">+  NS_IMETHOD GetPort(nsIMdbEnv* ev, nsIMdbPort** acqPort) override;</span>
<a href="#l43.17"></a><span id="l43.17" class="difflineplus">+</span>
<a href="#l43.18"></a><span id="l43.18">   NS_IMETHOD SetRowScope(nsIMdbEnv* ev, // sets pos to -1</span>
<a href="#l43.19"></a><span id="l43.19" class="difflineminus">-    mdb_scope inRowScope);</span>
<a href="#l43.20"></a><span id="l43.20" class="difflineminus">-  NS_IMETHOD GetRowScope(nsIMdbEnv* ev, mdb_scope* outRowScope); </span>
<a href="#l43.21"></a><span id="l43.21" class="difflineplus">+    mdb_scope inRowScope) override;</span>
<a href="#l43.22"></a><span id="l43.22" class="difflineplus">+  NS_IMETHOD GetRowScope(nsIMdbEnv* ev, mdb_scope* outRowScope) override;</span>
<a href="#l43.23"></a><span id="l43.23">   // setting row scope to zero iterates over all row scopes in port</span>
<a href="#l43.24"></a><span id="l43.24" class="difflineminus">-    </span>
<a href="#l43.25"></a><span id="l43.25" class="difflineplus">+</span>
<a href="#l43.26"></a><span id="l43.26">   NS_IMETHOD SetTableKind(nsIMdbEnv* ev, // sets pos to -1</span>
<a href="#l43.27"></a><span id="l43.27" class="difflineminus">-    mdb_kind inTableKind);</span>
<a href="#l43.28"></a><span id="l43.28" class="difflineminus">-  NS_IMETHOD GetTableKind(nsIMdbEnv* ev, mdb_kind* outTableKind);</span>
<a href="#l43.29"></a><span id="l43.29" class="difflineplus">+    mdb_kind inTableKind) override;</span>
<a href="#l43.30"></a><span id="l43.30" class="difflineplus">+  NS_IMETHOD GetTableKind(nsIMdbEnv* ev, mdb_kind* outTableKind) override;</span>
<a href="#l43.31"></a><span id="l43.31">   // setting table kind to zero iterates over all table kinds in row scope</span>
<a href="#l43.32"></a><span id="l43.32">   // } ----- end attribute methods -----</span>
<a href="#l43.33"></a><span id="l43.33"> </span>
<a href="#l43.34"></a><span id="l43.34">   // { ----- begin table iteration methods -----</span>
<a href="#l43.35"></a><span id="l43.35">   NS_IMETHOD NextTable( // get table at next position in the db</span>
<a href="#l43.36"></a><span id="l43.36">     nsIMdbEnv* ev, // context</span>
<a href="#l43.37"></a><span id="l43.37" class="difflineminus">-    nsIMdbTable** acqTable); // the next table in the iteration</span>
<a href="#l43.38"></a><span id="l43.38" class="difflineplus">+    nsIMdbTable** acqTable) override; // the next table in the iteration</span>
<a href="#l43.39"></a><span id="l43.39">   // } ----- end table iteration methods -----</span>
<a href="#l43.40"></a><span id="l43.40">   morkStore*    mPortTableCursor_Store;  // weak ref to store</span>
<a href="#l43.41"></a><span id="l43.41">   </span>
<a href="#l43.42"></a><span id="l43.42">   mdb_scope     mPortTableCursor_RowScope;</span>
<a href="#l43.43"></a><span id="l43.43">   mdb_kind      mPortTableCursor_TableKind;</span>
<a href="#l43.44"></a><span id="l43.44">   </span>
<a href="#l43.45"></a><span id="l43.45">   // We only care if LastTable is non-nil, so it is not refcounted;</span>
<a href="#l43.46"></a><span id="l43.46">   // so you must never access table state or methods using LastTable:</span>
<a href="#l43.47"></a><span id="l43.47" class="difflineat">@@ -82,18 +82,18 @@ public: // state is public because the e</span>
<a href="#l43.48"></a><span id="l43.48">   // these booleans indicate when the table or space iterator is exhausted:</span>
<a href="#l43.49"></a><span id="l43.49">   </span>
<a href="#l43.50"></a><span id="l43.50">   mork_bool           mPortTableCursor_TablesDidEnd; // no more tables?</span>
<a href="#l43.51"></a><span id="l43.51">   mork_bool           mPortTableCursor_SpacesDidEnd; // no more spaces?</span>
<a href="#l43.52"></a><span id="l43.52">   mork_u1             mPortTableCursor_Pad[ 2 ]; // for u4 alignment</span>
<a href="#l43.53"></a><span id="l43.53">    </span>
<a href="#l43.54"></a><span id="l43.54"> // { ===== begin morkNode interface =====</span>
<a href="#l43.55"></a><span id="l43.55"> public: // morkNode virtual methods</span>
<a href="#l43.56"></a><span id="l43.56" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // ClosePortTableCursor()</span>
<a href="#l43.57"></a><span id="l43.57" class="difflineminus">-  </span>
<a href="#l43.58"></a><span id="l43.58" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // ClosePortTableCursor()</span>
<a href="#l43.59"></a><span id="l43.59" class="difflineplus">+</span>
<a href="#l43.60"></a><span id="l43.60"> public: // morkPortTableCursor construction &amp; destruction</span>
<a href="#l43.61"></a><span id="l43.61">   morkPortTableCursor(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l43.62"></a><span id="l43.62">     nsIMdbHeap* ioHeap, morkStore* ioStore, mdb_scope inRowScope,</span>
<a href="#l43.63"></a><span id="l43.63">       mdb_kind inTableKind, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l43.64"></a><span id="l43.64">   void ClosePortTableCursor(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l43.65"></a><span id="l43.65"> </span>
<a href="#l43.66"></a><span id="l43.66"> private: // copying is not allowed</span>
<a href="#l43.67"></a><span id="l43.67">   morkPortTableCursor(const morkPortTableCursor&amp; other);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l44.1"></a><span id="l44.1" class="difflineminus">--- a/db/mork/src/morkProbeMap.cpp</span>
<a href="#l44.2"></a><span id="l44.2" class="difflineplus">+++ b/db/mork/src/morkProbeMap.cpp</span>
<a href="#l44.3"></a><span id="l44.3" class="difflineat">@@ -82,18 +82,16 @@ void morkMapScratch::halt_map_scratch(mo</span>
<a href="#l44.4"></a><span id="l44.4"> </span>
<a href="#l44.5"></a><span id="l44.5"> </span>
<a href="#l44.6"></a><span id="l44.6"> /*============================================================================*/</span>
<a href="#l44.7"></a><span id="l44.7"> /* morkProbeMap */</span>
<a href="#l44.8"></a><span id="l44.8"> </span>
<a href="#l44.9"></a><span id="l44.9"> void morkProbeMap::ProbeMapBadTagError(morkEnv* ev) const</span>
<a href="#l44.10"></a><span id="l44.10"> {</span>
<a href="#l44.11"></a><span id="l44.11">   ev-&gt;NewError(&quot;bad sProbeMap_Tag&quot;);</span>
<a href="#l44.12"></a><span id="l44.12" class="difflineminus">-  if ( !this )</span>
<a href="#l44.13"></a><span id="l44.13" class="difflineminus">-    ev-&gt;NewError(&quot;nil morkProbeMap&quot;);</span>
<a href="#l44.14"></a><span id="l44.14"> }</span>
<a href="#l44.15"></a><span id="l44.15"> </span>
<a href="#l44.16"></a><span id="l44.16"> void morkProbeMap::WrapWithNoVoidSlotError(morkEnv* ev) const</span>
<a href="#l44.17"></a><span id="l44.17"> {</span>
<a href="#l44.18"></a><span id="l44.18">   ev-&gt;NewError(&quot;wrap without void morkProbeMap slot&quot;);</span>
<a href="#l44.19"></a><span id="l44.19"> }</span>
<a href="#l44.20"></a><span id="l44.20"> </span>
<a href="#l44.21"></a><span id="l44.21"> void morkProbeMap::GrowFailsMaxFillError(morkEnv* ev) const</span>
<a href="#l44.22"></a><span id="l44.22" class="difflineat">@@ -441,18 +439,16 @@ morkProbeMap::CloseMorkNode(morkEnv* ev)</span>
<a href="#l44.23"></a><span id="l44.23">     this-&gt;MarkClosing();</span>
<a href="#l44.24"></a><span id="l44.24">     this-&gt;CloseProbeMap(ev);</span>
<a href="#l44.25"></a><span id="l44.25">     this-&gt;MarkShut();</span>
<a href="#l44.26"></a><span id="l44.26">   }</span>
<a href="#l44.27"></a><span id="l44.27"> }</span>
<a href="#l44.28"></a><span id="l44.28"> </span>
<a href="#l44.29"></a><span id="l44.29"> void morkProbeMap::CloseProbeMap(morkEnv* ev)</span>
<a href="#l44.30"></a><span id="l44.30"> {</span>
<a href="#l44.31"></a><span id="l44.31" class="difflineminus">-  if ( this )</span>
<a href="#l44.32"></a><span id="l44.32" class="difflineminus">-  {</span>
<a href="#l44.33"></a><span id="l44.33">     if ( this-&gt;IsNode() )</span>
<a href="#l44.34"></a><span id="l44.34">     {</span>
<a href="#l44.35"></a><span id="l44.35">       nsIMdbHeap* heap = sMap_Heap;</span>
<a href="#l44.36"></a><span id="l44.36">       if ( heap ) // able to free map arrays?</span>
<a href="#l44.37"></a><span id="l44.37">       {</span>
<a href="#l44.38"></a><span id="l44.38">         void* block = sMap_Keys;</span>
<a href="#l44.39"></a><span id="l44.39">         if ( block )</span>
<a href="#l44.40"></a><span id="l44.40">         {</span>
<a href="#l44.41"></a><span id="l44.41" class="difflineat">@@ -473,19 +469,16 @@ void morkProbeMap::CloseProbeMap(morkEnv</span>
<a href="#l44.42"></a><span id="l44.42">       this-&gt;CloseNode(ev);</span>
<a href="#l44.43"></a><span id="l44.43">       sProbeMap_Tag = 0;</span>
<a href="#l44.44"></a><span id="l44.44">       sProbeMap_MaxFill = 0;</span>
<a href="#l44.45"></a><span id="l44.45">       </span>
<a href="#l44.46"></a><span id="l44.46">       this-&gt;MarkShut();</span>
<a href="#l44.47"></a><span id="l44.47">     }</span>
<a href="#l44.48"></a><span id="l44.48">     else</span>
<a href="#l44.49"></a><span id="l44.49">       this-&gt;NonNodeError(ev);</span>
<a href="#l44.50"></a><span id="l44.50" class="difflineminus">-  }</span>
<a href="#l44.51"></a><span id="l44.51" class="difflineminus">-  else</span>
<a href="#l44.52"></a><span id="l44.52" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l44.53"></a><span id="l44.53"> }</span>
<a href="#l44.54"></a><span id="l44.54"> </span>
<a href="#l44.55"></a><span id="l44.55"> void*</span>
<a href="#l44.56"></a><span id="l44.56"> morkProbeMap::clear_alloc(morkEnv* ev, mork_size inSize)</span>
<a href="#l44.57"></a><span id="l44.57"> {</span>
<a href="#l44.58"></a><span id="l44.58">   void* p = 0;</span>
<a href="#l44.59"></a><span id="l44.59">   nsIMdbHeap* heap = sMap_Heap;</span>
<a href="#l44.60"></a><span id="l44.60">   if ( heap )</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l45.1"></a><span id="l45.1" class="difflineminus">--- a/db/mork/src/morkProbeMap.h</span>
<a href="#l45.2"></a><span id="l45.2" class="difflineplus">+++ b/db/mork/src/morkProbeMap.h</span>
<a href="#l45.3"></a><span id="l45.3" class="difflineat">@@ -328,17 +328,17 @@ public:</span>
<a href="#l45.4"></a><span id="l45.4">     // no val move at all when either inMapVal or outAppVal is nil.  Note that</span>
<a href="#l45.5"></a><span id="l45.5">     // inMapVal should always be nil when this-&gt;MapValSize() is nil.</span>
<a href="#l45.6"></a><span id="l45.6">   </span>
<a href="#l45.7"></a><span id="l45.7">   // } ===== end morkProbeMap methods =====</span>
<a href="#l45.8"></a><span id="l45.8">     </span>
<a href="#l45.9"></a><span id="l45.9">   </span>
<a href="#l45.10"></a><span id="l45.10"> // { ===== begin morkNode interface =====</span>
<a href="#l45.11"></a><span id="l45.11"> public: // morkNode virtual methods</span>
<a href="#l45.12"></a><span id="l45.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseProbeMap() only if open</span>
<a href="#l45.13"></a><span id="l45.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseProbeMap() only if open</span>
<a href="#l45.14"></a><span id="l45.14">   virtual ~morkProbeMap(); // assert that CloseProbeMap() executed earlier</span>
<a href="#l45.15"></a><span id="l45.15">   </span>
<a href="#l45.16"></a><span id="l45.16"> public: // morkProbeMap construction &amp; destruction</span>
<a href="#l45.17"></a><span id="l45.17">   morkProbeMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l45.18"></a><span id="l45.18">   nsIMdbHeap* ioNodeHeap,</span>
<a href="#l45.19"></a><span id="l45.19">   mork_size inKeySize, mork_size inValSize,</span>
<a href="#l45.20"></a><span id="l45.20">   nsIMdbHeap* ioMapHeap, mork_size inSlots,</span>
<a href="#l45.21"></a><span id="l45.21">   mork_bool inZeroIsClearKey);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l46.1"></a><span id="l46.1" class="difflineminus">--- a/db/mork/src/morkQuickSort.cpp</span>
<a href="#l46.2"></a><span id="l46.2" class="difflineplus">+++ b/db/mork/src/morkQuickSort.cpp</span>
<a href="#l46.3"></a><span id="l46.3" class="difflineat">@@ -59,20 +59,20 @@ morkQS_med3(mork_u1 *, mork_u1 *, mork_u</span>
<a href="#l46.4"></a><span id="l46.4"> static INLINE void</span>
<a href="#l46.5"></a><span id="l46.5"> morkQS_swapfunc(mork_u1 *, mork_u1 *, int, int);</span>
<a href="#l46.6"></a><span id="l46.6"> </span>
<a href="#l46.7"></a><span id="l46.7"> /*</span>
<a href="#l46.8"></a><span id="l46.8">  * Qsort routine from Bentley &amp; McIlroy's &quot;Engineering a Sort Function&quot;.</span>
<a href="#l46.9"></a><span id="l46.9">  */</span>
<a href="#l46.10"></a><span id="l46.10"> #define morkQS_swapcode(TYPE, parmi, parmj, n) {     \</span>
<a href="#l46.11"></a><span id="l46.11">   long i = (n) / sizeof (TYPE);       \</span>
<a href="#l46.12"></a><span id="l46.12" class="difflineminus">-  register TYPE *pi = (TYPE *) (parmi);     \</span>
<a href="#l46.13"></a><span id="l46.13" class="difflineminus">-  register TYPE *pj = (TYPE *) (parmj);     \</span>
<a href="#l46.14"></a><span id="l46.14" class="difflineplus">+  TYPE *pi = (TYPE *) (parmi);     \</span>
<a href="#l46.15"></a><span id="l46.15" class="difflineplus">+  TYPE *pj = (TYPE *) (parmj);     \</span>
<a href="#l46.16"></a><span id="l46.16">   do {             \</span>
<a href="#l46.17"></a><span id="l46.17" class="difflineminus">-    register TYPE  t = *pi;    \</span>
<a href="#l46.18"></a><span id="l46.18" class="difflineplus">+    TYPE  t = *pi;    \</span>
<a href="#l46.19"></a><span id="l46.19">     *pi++ = *pj;        \</span>
<a href="#l46.20"></a><span id="l46.20">     *pj++ = t;        \</span>
<a href="#l46.21"></a><span id="l46.21">         } while (--i &gt; 0);        \</span>
<a href="#l46.22"></a><span id="l46.22"> }</span>
<a href="#l46.23"></a><span id="l46.23"> </span>
<a href="#l46.24"></a><span id="l46.24"> #define morkQS_SwapInit(a, es) swaptype = (a - (mork_u1 *)0) % sizeof(long) || \</span>
<a href="#l46.25"></a><span id="l46.25">   es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;</span>
<a href="#l46.26"></a><span id="l46.26"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l47.1"></a><span id="l47.1" class="difflineminus">--- a/db/mork/src/morkRow.cpp</span>
<a href="#l47.2"></a><span id="l47.2" class="difflineplus">+++ b/db/mork/src/morkRow.cpp</span>
<a href="#l47.3"></a><span id="l47.3" class="difflineat">@@ -530,17 +530,17 @@ morkRow::GetCell(morkEnv* ev, mdb_column</span>
<a href="#l47.4"></a><span id="l47.4"> mork_aid</span>
<a href="#l47.5"></a><span id="l47.5"> morkRow::GetCellAtomAid(morkEnv* ev, mdb_column inColumn) const</span>
<a href="#l47.6"></a><span id="l47.6">   // GetCellAtomAid() finds the cell with column inColumn, and sees if the</span>
<a href="#l47.7"></a><span id="l47.7">   // atom has a token ID, and returns the atom's ID if there is one.  Or</span>
<a href="#l47.8"></a><span id="l47.8">   // else zero is returned if there is no such column, or no atom, or if</span>
<a href="#l47.9"></a><span id="l47.9">   // the atom has no ID to return.  This method is intended to support</span>
<a href="#l47.10"></a><span id="l47.10">   // efficient updating of column indexes for rows in a row space.</span>
<a href="#l47.11"></a><span id="l47.11"> {</span>
<a href="#l47.12"></a><span id="l47.12" class="difflineminus">-  if ( this &amp;&amp; this-&gt;IsRow() )</span>
<a href="#l47.13"></a><span id="l47.13" class="difflineplus">+  if (this-&gt;IsRow())</span>
<a href="#l47.14"></a><span id="l47.14">   {</span>
<a href="#l47.15"></a><span id="l47.15">     morkCell* cells = mRow_Cells;</span>
<a href="#l47.16"></a><span id="l47.16">     if ( cells )</span>
<a href="#l47.17"></a><span id="l47.17">     {</span>
<a href="#l47.18"></a><span id="l47.18">       morkCell* end = cells + mRow_Length;</span>
<a href="#l47.19"></a><span id="l47.19">       while ( cells &lt; end )</span>
<a href="#l47.20"></a><span id="l47.20">       {</span>
<a href="#l47.21"></a><span id="l47.21">         mork_column col = cells-&gt;GetColumn();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l48.1"></a><span id="l48.1" class="difflineminus">--- a/db/mork/src/morkRowCellCursor.cpp</span>
<a href="#l48.2"></a><span id="l48.2" class="difflineplus">+++ b/db/mork/src/morkRowCellCursor.cpp</span>
<a href="#l48.3"></a><span id="l48.3" class="difflineat">@@ -98,32 +98,27 @@ morkRowCellCursor::morkRowCellCursor(mor</span>
<a href="#l48.4"></a><span id="l48.4">   }</span>
<a href="#l48.5"></a><span id="l48.5"> }</span>
<a href="#l48.6"></a><span id="l48.6"> </span>
<a href="#l48.7"></a><span id="l48.7"> NS_IMPL_ISUPPORTS_INHERITED(morkRowCellCursor, morkCursor, nsIMdbRowCellCursor)</span>
<a href="#l48.8"></a><span id="l48.8"> </span>
<a href="#l48.9"></a><span id="l48.9"> /*public non-poly*/ void</span>
<a href="#l48.10"></a><span id="l48.10"> morkRowCellCursor::CloseRowCellCursor(morkEnv* ev) </span>
<a href="#l48.11"></a><span id="l48.11"> {</span>
<a href="#l48.12"></a><span id="l48.12" class="difflineminus">-  if ( this )</span>
<a href="#l48.13"></a><span id="l48.13" class="difflineminus">-  {</span>
<a href="#l48.14"></a><span id="l48.14">     if ( this-&gt;IsNode() )</span>
<a href="#l48.15"></a><span id="l48.15">     {</span>
<a href="#l48.16"></a><span id="l48.16">       mCursor_Pos = -1;</span>
<a href="#l48.17"></a><span id="l48.17">       mCursor_Seed = 0;</span>
<a href="#l48.18"></a><span id="l48.18">       morkRowObject::SlotStrongRowObject((morkRowObject*) 0, ev,</span>
<a href="#l48.19"></a><span id="l48.19">         &amp;mRowCellCursor_RowObject);</span>
<a href="#l48.20"></a><span id="l48.20">       this-&gt;CloseCursor(ev);</span>
<a href="#l48.21"></a><span id="l48.21">       this-&gt;MarkShut();</span>
<a href="#l48.22"></a><span id="l48.22">     }</span>
<a href="#l48.23"></a><span id="l48.23">     else</span>
<a href="#l48.24"></a><span id="l48.24">       this-&gt;NonNodeError(ev);</span>
<a href="#l48.25"></a><span id="l48.25" class="difflineminus">-  }</span>
<a href="#l48.26"></a><span id="l48.26" class="difflineminus">-  else</span>
<a href="#l48.27"></a><span id="l48.27" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l48.28"></a><span id="l48.28"> }</span>
<a href="#l48.29"></a><span id="l48.29"> </span>
<a href="#l48.30"></a><span id="l48.30"> // } ===== end morkNode methods =====</span>
<a href="#l48.31"></a><span id="l48.31"> // ````` ````` ````` ````` ````` </span>
<a href="#l48.32"></a><span id="l48.32"> </span>
<a href="#l48.33"></a><span id="l48.33"> /*static*/ void</span>
<a href="#l48.34"></a><span id="l48.34"> morkRowCellCursor::NilRowObjectError(morkEnv* ev)</span>
<a href="#l48.35"></a><span id="l48.35"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l49.1"></a><span id="l49.1" class="difflineminus">--- a/db/mork/src/morkRowCellCursor.h</span>
<a href="#l49.2"></a><span id="l49.2" class="difflineplus">+++ b/db/mork/src/morkRowCellCursor.h</span>
<a href="#l49.3"></a><span id="l49.3" class="difflineat">@@ -39,60 +39,60 @@ class morkRowCellCursor : public morkCur</span>
<a href="#l49.4"></a><span id="l49.4">   // mork_bool  mCursor_DoFailOnSeedOutOfSync;</span>
<a href="#l49.5"></a><span id="l49.5">   // mork_u1    mCursor_Pad[ 3 ]; // explicitly pad to u4 alignment</span>
<a href="#l49.6"></a><span id="l49.6"> </span>
<a href="#l49.7"></a><span id="l49.7"> public: // state is public because the entire Mork system is private</span>
<a href="#l49.8"></a><span id="l49.8"> </span>
<a href="#l49.9"></a><span id="l49.9">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l49.10"></a><span id="l49.10">   morkRowObject*   mRowCellCursor_RowObject;  // strong ref to row</span>
<a href="#l49.11"></a><span id="l49.11">   mork_column      mRowCellCursor_Col;        // col of cell last at mCursor_Pos</span>
<a href="#l49.12"></a><span id="l49.12" class="difflineminus">-  </span>
<a href="#l49.13"></a><span id="l49.13" class="difflineplus">+</span>
<a href="#l49.14"></a><span id="l49.14"> // { ===== begin morkNode interface =====</span>
<a href="#l49.15"></a><span id="l49.15"> public: // morkNode virtual methods</span>
<a href="#l49.16"></a><span id="l49.16" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseRowCellCursor()</span>
<a href="#l49.17"></a><span id="l49.17" class="difflineminus">-  </span>
<a href="#l49.18"></a><span id="l49.18" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseRowCellCursor()</span>
<a href="#l49.19"></a><span id="l49.19" class="difflineplus">+</span>
<a href="#l49.20"></a><span id="l49.20"> public: // morkRowCellCursor construction &amp; destruction</span>
<a href="#l49.21"></a><span id="l49.21">   morkRowCellCursor(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l49.22"></a><span id="l49.22">     nsIMdbHeap* ioHeap, morkRowObject* ioRowObject);</span>
<a href="#l49.23"></a><span id="l49.23">   void CloseRowCellCursor(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l49.24"></a><span id="l49.24"> </span>
<a href="#l49.25"></a><span id="l49.25">   // { ----- begin attribute methods -----</span>
<a href="#l49.26"></a><span id="l49.26" class="difflineminus">-  NS_IMETHOD SetRow(nsIMdbEnv* ev, nsIMdbRow* ioRow); // sets pos to -1</span>
<a href="#l49.27"></a><span id="l49.27" class="difflineminus">-  NS_IMETHOD GetRow(nsIMdbEnv* ev, nsIMdbRow** acqRow);</span>
<a href="#l49.28"></a><span id="l49.28" class="difflineplus">+  NS_IMETHOD SetRow(nsIMdbEnv* ev, nsIMdbRow* ioRow) override; // sets pos to -1</span>
<a href="#l49.29"></a><span id="l49.29" class="difflineplus">+  NS_IMETHOD GetRow(nsIMdbEnv* ev, nsIMdbRow** acqRow) override;</span>
<a href="#l49.30"></a><span id="l49.30">   // } ----- end attribute methods -----</span>
<a href="#l49.31"></a><span id="l49.31"> </span>
<a href="#l49.32"></a><span id="l49.32">   // { ----- begin cell creation methods -----</span>
<a href="#l49.33"></a><span id="l49.33">   NS_IMETHOD MakeCell( // get cell at current pos in the row</span>
<a href="#l49.34"></a><span id="l49.34">     nsIMdbEnv* ev, // context</span>
<a href="#l49.35"></a><span id="l49.35">     mdb_column* outColumn, // column for this particular cell</span>
<a href="#l49.36"></a><span id="l49.36">     mdb_pos* outPos, // position of cell in row sequence</span>
<a href="#l49.37"></a><span id="l49.37" class="difflineminus">-    nsIMdbCell** acqCell); // the cell at inPos</span>
<a href="#l49.38"></a><span id="l49.38" class="difflineplus">+    nsIMdbCell** acqCell) override; // the cell at inPos</span>
<a href="#l49.39"></a><span id="l49.39">   // } ----- end cell creation methods -----</span>
<a href="#l49.40"></a><span id="l49.40"> </span>
<a href="#l49.41"></a><span id="l49.41">   // { ----- begin cell seeking methods -----</span>
<a href="#l49.42"></a><span id="l49.42">   NS_IMETHOD SeekCell( // same as SetRow() followed by MakeCell()</span>
<a href="#l49.43"></a><span id="l49.43">     nsIMdbEnv* ev, // context</span>
<a href="#l49.44"></a><span id="l49.44">     mdb_pos inPos, // position of cell in row sequence</span>
<a href="#l49.45"></a><span id="l49.45">     mdb_column* outColumn, // column for this particular cell</span>
<a href="#l49.46"></a><span id="l49.46" class="difflineminus">-    nsIMdbCell** acqCell); // the cell at inPos</span>
<a href="#l49.47"></a><span id="l49.47" class="difflineplus">+    nsIMdbCell** acqCell) override; // the cell at inPos</span>
<a href="#l49.48"></a><span id="l49.48">   // } ----- end cell seeking methods -----</span>
<a href="#l49.49"></a><span id="l49.49"> </span>
<a href="#l49.50"></a><span id="l49.50">   // { ----- begin cell iteration methods -----</span>
<a href="#l49.51"></a><span id="l49.51">   NS_IMETHOD NextCell( // get next cell in the row</span>
<a href="#l49.52"></a><span id="l49.52">     nsIMdbEnv* ev, // context</span>
<a href="#l49.53"></a><span id="l49.53">     nsIMdbCell** acqCell, // changes to the next cell in the iteration</span>
<a href="#l49.54"></a><span id="l49.54">     mdb_column* outColumn, // column for this particular cell</span>
<a href="#l49.55"></a><span id="l49.55" class="difflineminus">-    mdb_pos* outPos); // position of cell in row sequence</span>
<a href="#l49.56"></a><span id="l49.56" class="difflineplus">+    mdb_pos* outPos) override; // position of cell in row sequence</span>
<a href="#l49.57"></a><span id="l49.57">     </span>
<a href="#l49.58"></a><span id="l49.58">   NS_IMETHOD PickNextCell( // get next cell in row within filter set</span>
<a href="#l49.59"></a><span id="l49.59">     nsIMdbEnv* ev, // context</span>
<a href="#l49.60"></a><span id="l49.60">     nsIMdbCell* ioCell, // changes to the next cell in the iteration</span>
<a href="#l49.61"></a><span id="l49.61">     const mdbColumnSet* inFilterSet, // col set of actual caller interest</span>
<a href="#l49.62"></a><span id="l49.62">     mdb_column* outColumn, // column for this particular cell</span>
<a href="#l49.63"></a><span id="l49.63" class="difflineminus">-    mdb_pos* outPos); // position of cell in row sequence</span>
<a href="#l49.64"></a><span id="l49.64" class="difflineplus">+    mdb_pos* outPos) override; // position of cell in row sequence</span>
<a href="#l49.65"></a><span id="l49.65"> </span>
<a href="#l49.66"></a><span id="l49.66">   // Note that inFilterSet should not have too many (many more than 10?)</span>
<a href="#l49.67"></a><span id="l49.67">   // cols, since this might imply a potential excessive consumption of time</span>
<a href="#l49.68"></a><span id="l49.68">   // over many cursor calls when looking for column and filter intersection.</span>
<a href="#l49.69"></a><span id="l49.69">   // } ----- end cell iteration methods -----</span>
<a href="#l49.70"></a><span id="l49.70"> </span>
<a href="#l49.71"></a><span id="l49.71"> </span>
<a href="#l49.72"></a><span id="l49.72"> private: // copying is not allowed</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l50.1"></a><span id="l50.1" class="difflineminus">--- a/db/mork/src/morkRowMap.cpp</span>
<a href="#l50.2"></a><span id="l50.2" class="difflineplus">+++ b/db/mork/src/morkRowMap.cpp</span>
<a href="#l50.3"></a><span id="l50.3" class="difflineat">@@ -62,28 +62,23 @@ morkRowMap::morkRowMap(morkEnv* ev, cons</span>
<a href="#l50.4"></a><span id="l50.4"> {</span>
<a href="#l50.5"></a><span id="l50.5">   if ( ev-&gt;Good() )</span>
<a href="#l50.6"></a><span id="l50.6">     mNode_Derived = morkDerived_kRowMap;</span>
<a href="#l50.7"></a><span id="l50.7"> }</span>
<a href="#l50.8"></a><span id="l50.8"> </span>
<a href="#l50.9"></a><span id="l50.9"> /*public non-poly*/ void</span>
<a href="#l50.10"></a><span id="l50.10"> morkRowMap::CloseRowMap(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l50.11"></a><span id="l50.11"> {</span>
<a href="#l50.12"></a><span id="l50.12" class="difflineminus">-  if ( this )</span>
<a href="#l50.13"></a><span id="l50.13" class="difflineminus">-  {</span>
<a href="#l50.14"></a><span id="l50.14">     if ( this-&gt;IsNode() )</span>
<a href="#l50.15"></a><span id="l50.15">     {</span>
<a href="#l50.16"></a><span id="l50.16">       this-&gt;CloseMap(ev);</span>
<a href="#l50.17"></a><span id="l50.17">       this-&gt;MarkShut();</span>
<a href="#l50.18"></a><span id="l50.18">     }</span>
<a href="#l50.19"></a><span id="l50.19">     else</span>
<a href="#l50.20"></a><span id="l50.20">       this-&gt;NonNodeError(ev);</span>
<a href="#l50.21"></a><span id="l50.21" class="difflineminus">-  }</span>
<a href="#l50.22"></a><span id="l50.22" class="difflineminus">-  else</span>
<a href="#l50.23"></a><span id="l50.23" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l50.24"></a><span id="l50.24"> }</span>
<a href="#l50.25"></a><span id="l50.25"> </span>
<a href="#l50.26"></a><span id="l50.26"> // } ===== end morkNode methods =====</span>
<a href="#l50.27"></a><span id="l50.27"> // ````` ````` ````` ````` ````` </span>
<a href="#l50.28"></a><span id="l50.28"> </span>
<a href="#l50.29"></a><span id="l50.29"> </span>
<a href="#l50.30"></a><span id="l50.30"> // { ===== begin morkMap poly interface =====</span>
<a href="#l50.31"></a><span id="l50.31"> /*virtual*/ mork_bool // </span>
<a href="#l50.32"></a><span id="l50.32" class="difflineat">@@ -190,28 +185,23 @@ morkRowProbeMap::morkRowProbeMap(morkEnv</span>
<a href="#l50.33"></a><span id="l50.33"> {</span>
<a href="#l50.34"></a><span id="l50.34">   if ( ev-&gt;Good() )</span>
<a href="#l50.35"></a><span id="l50.35">     mNode_Derived = morkDerived_kRowProbeMap;</span>
<a href="#l50.36"></a><span id="l50.36"> }</span>
<a href="#l50.37"></a><span id="l50.37"> </span>
<a href="#l50.38"></a><span id="l50.38"> /*public non-poly*/ void</span>
<a href="#l50.39"></a><span id="l50.39"> morkRowProbeMap::CloseRowProbeMap(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l50.40"></a><span id="l50.40"> {</span>
<a href="#l50.41"></a><span id="l50.41" class="difflineminus">-  if ( this )</span>
<a href="#l50.42"></a><span id="l50.42" class="difflineminus">-  {</span>
<a href="#l50.43"></a><span id="l50.43">     if ( this-&gt;IsNode() )</span>
<a href="#l50.44"></a><span id="l50.44">     {</span>
<a href="#l50.45"></a><span id="l50.45">       this-&gt;CloseProbeMap(ev);</span>
<a href="#l50.46"></a><span id="l50.46">       this-&gt;MarkShut();</span>
<a href="#l50.47"></a><span id="l50.47">     }</span>
<a href="#l50.48"></a><span id="l50.48">     else</span>
<a href="#l50.49"></a><span id="l50.49">       this-&gt;NonNodeError(ev);</span>
<a href="#l50.50"></a><span id="l50.50" class="difflineminus">-  }</span>
<a href="#l50.51"></a><span id="l50.51" class="difflineminus">-  else</span>
<a href="#l50.52"></a><span id="l50.52" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l50.53"></a><span id="l50.53"> }</span>
<a href="#l50.54"></a><span id="l50.54"> </span>
<a href="#l50.55"></a><span id="l50.55"> // } ===== end morkNode methods =====</span>
<a href="#l50.56"></a><span id="l50.56"> // ````` ````` ````` ````` ````` </span>
<a href="#l50.57"></a><span id="l50.57"> </span>
<a href="#l50.58"></a><span id="l50.58"> /*virtual*/ mork_test // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l50.59"></a><span id="l50.59"> morkRowProbeMap::MapTest(morkEnv* ev, const void* inMapKey,</span>
<a href="#l50.60"></a><span id="l50.60">   const void* inAppKey) const</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l51.1"></a><span id="l51.1" class="difflineminus">--- a/db/mork/src/morkRowMap.h</span>
<a href="#l51.2"></a><span id="l51.2" class="difflineplus">+++ b/db/mork/src/morkRowMap.h</span>
<a href="#l51.3"></a><span id="l51.3" class="difflineat">@@ -27,36 +27,36 @@</span>
<a href="#l51.4"></a><span id="l51.4"> #define morkDerived_kRowMap  /*i*/ 0x724D /* ascii 'rM' */</span>
<a href="#l51.5"></a><span id="l51.5"> </span>
<a href="#l51.6"></a><span id="l51.6"> /*| morkRowMap: maps a set of morkRow by contained Oid</span>
<a href="#l51.7"></a><span id="l51.7"> |*/</span>
<a href="#l51.8"></a><span id="l51.8"> class morkRowMap : public morkMap { // for mapping row IDs to rows</span>
<a href="#l51.9"></a><span id="l51.9"> </span>
<a href="#l51.10"></a><span id="l51.10"> // { ===== begin morkNode interface =====</span>
<a href="#l51.11"></a><span id="l51.11"> public: // morkNode virtual methods</span>
<a href="#l51.12"></a><span id="l51.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseRowMap() only if open</span>
<a href="#l51.13"></a><span id="l51.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseRowMap() only if open</span>
<a href="#l51.14"></a><span id="l51.14">   virtual ~morkRowMap(); // assert that CloseRowMap() executed earlier</span>
<a href="#l51.15"></a><span id="l51.15">   </span>
<a href="#l51.16"></a><span id="l51.16"> public: // morkMap construction &amp; destruction</span>
<a href="#l51.17"></a><span id="l51.17">   morkRowMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l51.18"></a><span id="l51.18">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap, mork_size inSlots);</span>
<a href="#l51.19"></a><span id="l51.19">   void CloseRowMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l51.20"></a><span id="l51.20"> </span>
<a href="#l51.21"></a><span id="l51.21"> public: // dynamic type identification</span>
<a href="#l51.22"></a><span id="l51.22">   mork_bool IsRowMap() const</span>
<a href="#l51.23"></a><span id="l51.23">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kRowMap; }</span>
<a href="#l51.24"></a><span id="l51.24"> // } ===== end morkNode methods =====</span>
<a href="#l51.25"></a><span id="l51.25"> </span>
<a href="#l51.26"></a><span id="l51.26"> // { ===== begin morkMap poly interface =====</span>
<a href="#l51.27"></a><span id="l51.27">   virtual mork_bool // note: equal(a,b) implies hash(a) == hash(b)</span>
<a href="#l51.28"></a><span id="l51.28" class="difflineminus">-  Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const;</span>
<a href="#l51.29"></a><span id="l51.29" class="difflineplus">+  Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const override;</span>
<a href="#l51.30"></a><span id="l51.30">   // implemented using morkRow::EqualRow()</span>
<a href="#l51.31"></a><span id="l51.31"> </span>
<a href="#l51.32"></a><span id="l51.32">   virtual mork_u4 // note: equal(a,b) implies hash(a) == hash(b)</span>
<a href="#l51.33"></a><span id="l51.33" class="difflineminus">-  Hash(morkEnv* ev, const void* inKey) const;</span>
<a href="#l51.34"></a><span id="l51.34" class="difflineplus">+  Hash(morkEnv* ev, const void* inKey) const override;</span>
<a href="#l51.35"></a><span id="l51.35">   // implemented using morkRow::HashRow()</span>
<a href="#l51.36"></a><span id="l51.36"> // } ===== end morkMap poly interface =====</span>
<a href="#l51.37"></a><span id="l51.37"> </span>
<a href="#l51.38"></a><span id="l51.38"> public: // other map methods</span>
<a href="#l51.39"></a><span id="l51.39"> </span>
<a href="#l51.40"></a><span id="l51.40">   mork_bool AddRow(morkEnv* ev, morkRow* ioRow);</span>
<a href="#l51.41"></a><span id="l51.41">   // AddRow() returns ev-&gt;Good()</span>
<a href="#l51.42"></a><span id="l51.42"> </span>
<a href="#l51.43"></a><span id="l51.43" class="difflineat">@@ -113,37 +113,37 @@ public:</span>
<a href="#l51.44"></a><span id="l51.44"> #define morkDerived_kRowProbeMap  /*i*/ 0x726D /* ascii 'rm' */</span>
<a href="#l51.45"></a><span id="l51.45"> </span>
<a href="#l51.46"></a><span id="l51.46"> /*| morkRowProbeMap: maps a set of morkRow by contained Oid</span>
<a href="#l51.47"></a><span id="l51.47"> |*/</span>
<a href="#l51.48"></a><span id="l51.48"> class morkRowProbeMap : public morkProbeMap { // for mapping row IDs to rows</span>
<a href="#l51.49"></a><span id="l51.49"> </span>
<a href="#l51.50"></a><span id="l51.50"> // { ===== begin morkNode interface =====</span>
<a href="#l51.51"></a><span id="l51.51"> public: // morkNode virtual methods</span>
<a href="#l51.52"></a><span id="l51.52" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseRowProbeMap() only if open</span>
<a href="#l51.53"></a><span id="l51.53" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseRowProbeMap() only if open</span>
<a href="#l51.54"></a><span id="l51.54">   virtual ~morkRowProbeMap(); // assert CloseRowProbeMap() executed earlier</span>
<a href="#l51.55"></a><span id="l51.55">   </span>
<a href="#l51.56"></a><span id="l51.56"> public: // morkMap construction &amp; destruction</span>
<a href="#l51.57"></a><span id="l51.57">   morkRowProbeMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l51.58"></a><span id="l51.58">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap, mork_size inSlots);</span>
<a href="#l51.59"></a><span id="l51.59">   void CloseRowProbeMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l51.60"></a><span id="l51.60"> </span>
<a href="#l51.61"></a><span id="l51.61"> public: // dynamic type identification</span>
<a href="#l51.62"></a><span id="l51.62">   mork_bool IsRowMap() const</span>
<a href="#l51.63"></a><span id="l51.63">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kRowMap; }</span>
<a href="#l51.64"></a><span id="l51.64"> // } ===== end morkNode methods =====</span>
<a href="#l51.65"></a><span id="l51.65"> </span>
<a href="#l51.66"></a><span id="l51.66">   // { ===== begin morkProbeMap methods =====</span>
<a href="#l51.67"></a><span id="l51.67">   virtual mork_test // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l51.68"></a><span id="l51.68" class="difflineminus">-  MapTest(morkEnv* ev, const void* inMapKey, const void* inAppKey) const;</span>
<a href="#l51.69"></a><span id="l51.69" class="difflineplus">+  MapTest(morkEnv* ev, const void* inMapKey, const void* inAppKey) const override;</span>
<a href="#l51.70"></a><span id="l51.70"> </span>
<a href="#l51.71"></a><span id="l51.71">   virtual mork_u4 // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l51.72"></a><span id="l51.72" class="difflineminus">-  MapHash(morkEnv* ev, const void* inAppKey) const;</span>
<a href="#l51.73"></a><span id="l51.73" class="difflineplus">+  MapHash(morkEnv* ev, const void* inAppKey) const override;</span>
<a href="#l51.74"></a><span id="l51.74"> </span>
<a href="#l51.75"></a><span id="l51.75" class="difflineminus">-  virtual mork_u4 ProbeMapHashMapKey(morkEnv* ev, const void* inMapKey) const;</span>
<a href="#l51.76"></a><span id="l51.76" class="difflineplus">+  virtual mork_u4 ProbeMapHashMapKey(morkEnv* ev, const void* inMapKey) const override;</span>
<a href="#l51.77"></a><span id="l51.77"> </span>
<a href="#l51.78"></a><span id="l51.78">   // virtual mork_bool ProbeMapIsKeyNil(morkEnv* ev, void* ioMapKey);</span>
<a href="#l51.79"></a><span id="l51.79"> </span>
<a href="#l51.80"></a><span id="l51.80">   // virtual void ProbeMapClearKey(morkEnv* ev, // put 'nil' alls keys inside map</span>
<a href="#l51.81"></a><span id="l51.81">   //   void* ioMapKey, mork_count inKeyCount); // array of keys inside map</span>
<a href="#l51.82"></a><span id="l51.82"> </span>
<a href="#l51.83"></a><span id="l51.83">   // virtual void ProbeMapPushIn(morkEnv* ev, // move (key,val) into the map</span>
<a href="#l51.84"></a><span id="l51.84">   //   const void* inAppKey, const void* inAppVal, // (key,val) outside map</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l52.1"></a><span id="l52.1" class="difflineminus">--- a/db/mork/src/morkRowObject.cpp</span>
<a href="#l52.2"></a><span id="l52.2" class="difflineplus">+++ b/db/mork/src/morkRowObject.cpp</span>
<a href="#l52.3"></a><span id="l52.3" class="difflineat">@@ -555,18 +555,16 @@ morkRowObject::SeekCellYarn( // resemble</span>
<a href="#l52.4"></a><span id="l52.4"> </span>
<a href="#l52.5"></a><span id="l52.5"> // } ===== end nsIMdbRow methods =====</span>
<a href="#l52.6"></a><span id="l52.6"> </span>
<a href="#l52.7"></a><span id="l52.7"> </span>
<a href="#l52.8"></a><span id="l52.8"> </span>
<a href="#l52.9"></a><span id="l52.9"> /*public non-poly*/ void</span>
<a href="#l52.10"></a><span id="l52.10"> morkRowObject::CloseRowObject(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l52.11"></a><span id="l52.11"> {</span>
<a href="#l52.12"></a><span id="l52.12" class="difflineminus">-  if ( this )</span>
<a href="#l52.13"></a><span id="l52.13" class="difflineminus">-  {</span>
<a href="#l52.14"></a><span id="l52.14">     if ( this-&gt;IsNode() )</span>
<a href="#l52.15"></a><span id="l52.15">     {</span>
<a href="#l52.16"></a><span id="l52.16">       morkRow* row = mRowObject_Row;</span>
<a href="#l52.17"></a><span id="l52.17">       mRowObject_Row = 0;</span>
<a href="#l52.18"></a><span id="l52.18">       this-&gt;CloseObject(ev);</span>
<a href="#l52.19"></a><span id="l52.19">       this-&gt;MarkShut();</span>
<a href="#l52.20"></a><span id="l52.20"> </span>
<a href="#l52.21"></a><span id="l52.21">       if ( row )</span>
<a href="#l52.22"></a><span id="l52.22" class="difflineat">@@ -579,19 +577,16 @@ morkRowObject::CloseRowObject(morkEnv* e</span>
<a href="#l52.23"></a><span id="l52.23">           mRowObject_Store = 0; // morkRowObjects don't ref-cnt the owning store.</span>
<a href="#l52.24"></a><span id="l52.24">             </span>
<a href="#l52.25"></a><span id="l52.25">           this-&gt;CutWeakRef(ev-&gt;AsMdbEnv()); // do last, because it might self destroy</span>
<a href="#l52.26"></a><span id="l52.26">         }</span>
<a href="#l52.27"></a><span id="l52.27">       }</span>
<a href="#l52.28"></a><span id="l52.28">     }</span>
<a href="#l52.29"></a><span id="l52.29">     else</span>
<a href="#l52.30"></a><span id="l52.30">       this-&gt;NonNodeError(ev);</span>
<a href="#l52.31"></a><span id="l52.31" class="difflineminus">-  }</span>
<a href="#l52.32"></a><span id="l52.32" class="difflineminus">-  else</span>
<a href="#l52.33"></a><span id="l52.33" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l52.34"></a><span id="l52.34"> }</span>
<a href="#l52.35"></a><span id="l52.35"> </span>
<a href="#l52.36"></a><span id="l52.36"> // } ===== end morkNode methods =====</span>
<a href="#l52.37"></a><span id="l52.37"> // ````` ````` ````` ````` ````` </span>
<a href="#l52.38"></a><span id="l52.38"> </span>
<a href="#l52.39"></a><span id="l52.39"> /*static*/ void</span>
<a href="#l52.40"></a><span id="l52.40"> morkRowObject::NonRowObjectTypeError(morkEnv* ev)</span>
<a href="#l52.41"></a><span id="l52.41"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l53.1"></a><span id="l53.1" class="difflineminus">--- a/db/mork/src/morkRowObject.h</span>
<a href="#l53.2"></a><span id="l53.2" class="difflineplus">+++ b/db/mork/src/morkRowObject.h</span>
<a href="#l53.3"></a><span id="l53.3" class="difflineat">@@ -24,125 +24,125 @@ class morkRowObject : public morkObject,</span>
<a href="#l53.4"></a><span id="l53.4"> public: // state is public because the entire Mork system is private</span>
<a href="#l53.5"></a><span id="l53.5">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l53.6"></a><span id="l53.6">   </span>
<a href="#l53.7"></a><span id="l53.7">   morkRow*    mRowObject_Row;     // non-refcounted alias to morkRow</span>
<a href="#l53.8"></a><span id="l53.8">   morkStore*  mRowObject_Store;   // non-refcounted ptr to store containing row</span>
<a href="#l53.9"></a><span id="l53.9">   </span>
<a href="#l53.10"></a><span id="l53.10"> // { ===== begin morkNode interface =====</span>
<a href="#l53.11"></a><span id="l53.11"> public: // morkNode virtual methods</span>
<a href="#l53.12"></a><span id="l53.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseRowObject() only if open</span>
<a href="#l53.13"></a><span id="l53.13" class="difflineminus">-  </span>
<a href="#l53.14"></a><span id="l53.14" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseRowObject() only if open</span>
<a href="#l53.15"></a><span id="l53.15" class="difflineplus">+</span>
<a href="#l53.16"></a><span id="l53.16"> public: // morkRowObject construction &amp; destruction</span>
<a href="#l53.17"></a><span id="l53.17">   morkRowObject(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l53.18"></a><span id="l53.18">     nsIMdbHeap* ioHeap, morkRow* ioRow, morkStore* ioStore);</span>
<a href="#l53.19"></a><span id="l53.19">   void CloseRowObject(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l53.20"></a><span id="l53.20"> </span>
<a href="#l53.21"></a><span id="l53.21"> // { ===== begin nsIMdbCollection methods =====</span>
<a href="#l53.22"></a><span id="l53.22"> </span>
<a href="#l53.23"></a><span id="l53.23">   // { ----- begin attribute methods -----</span>
<a href="#l53.24"></a><span id="l53.24">   NS_IMETHOD GetSeed(nsIMdbEnv* ev,</span>
<a href="#l53.25"></a><span id="l53.25" class="difflineminus">-    mdb_seed* outSeed);    // member change count</span>
<a href="#l53.26"></a><span id="l53.26" class="difflineplus">+    mdb_seed* outSeed) override;    // member change count</span>
<a href="#l53.27"></a><span id="l53.27">   NS_IMETHOD GetCount(nsIMdbEnv* ev,</span>
<a href="#l53.28"></a><span id="l53.28" class="difflineminus">-    mdb_count* outCount); // member count</span>
<a href="#l53.29"></a><span id="l53.29" class="difflineplus">+    mdb_count* outCount) override; // member count</span>
<a href="#l53.30"></a><span id="l53.30"> </span>
<a href="#l53.31"></a><span id="l53.31">   NS_IMETHOD GetPort(nsIMdbEnv* ev,</span>
<a href="#l53.32"></a><span id="l53.32" class="difflineminus">-    nsIMdbPort** acqPort); // collection container</span>
<a href="#l53.33"></a><span id="l53.33" class="difflineplus">+    nsIMdbPort** acqPort) override; // collection container</span>
<a href="#l53.34"></a><span id="l53.34">   // } ----- end attribute methods -----</span>
<a href="#l53.35"></a><span id="l53.35"> </span>
<a href="#l53.36"></a><span id="l53.36">   // { ----- begin cursor methods -----</span>
<a href="#l53.37"></a><span id="l53.37">   NS_IMETHOD GetCursor( // make a cursor starting iter at inMemberPos</span>
<a href="#l53.38"></a><span id="l53.38">     nsIMdbEnv* ev, // context</span>
<a href="#l53.39"></a><span id="l53.39">     mdb_pos inMemberPos, // zero-based ordinal pos of member in collection</span>
<a href="#l53.40"></a><span id="l53.40" class="difflineminus">-    nsIMdbCursor** acqCursor); // acquire new cursor instance</span>
<a href="#l53.41"></a><span id="l53.41" class="difflineplus">+    nsIMdbCursor** acqCursor) override; // acquire new cursor instance</span>
<a href="#l53.42"></a><span id="l53.42">   // } ----- end cursor methods -----</span>
<a href="#l53.43"></a><span id="l53.43"> </span>
<a href="#l53.44"></a><span id="l53.44">   // { ----- begin ID methods -----</span>
<a href="#l53.45"></a><span id="l53.45">   NS_IMETHOD GetOid(nsIMdbEnv* ev,</span>
<a href="#l53.46"></a><span id="l53.46" class="difflineminus">-    mdbOid* outOid); // read object identity</span>
<a href="#l53.47"></a><span id="l53.47" class="difflineplus">+    mdbOid* outOid) override; // read object identity</span>
<a href="#l53.48"></a><span id="l53.48">   NS_IMETHOD BecomeContent(nsIMdbEnv* ev,</span>
<a href="#l53.49"></a><span id="l53.49" class="difflineminus">-    const mdbOid* inOid); // exchange content</span>
<a href="#l53.50"></a><span id="l53.50" class="difflineplus">+    const mdbOid* inOid) override; // exchange content</span>
<a href="#l53.51"></a><span id="l53.51">   // } ----- end ID methods -----</span>
<a href="#l53.52"></a><span id="l53.52"> </span>
<a href="#l53.53"></a><span id="l53.53">   // { ----- begin activity dropping methods -----</span>
<a href="#l53.54"></a><span id="l53.54">   NS_IMETHOD DropActivity( // tell collection usage no longer expected</span>
<a href="#l53.55"></a><span id="l53.55" class="difflineminus">-    nsIMdbEnv* ev);</span>
<a href="#l53.56"></a><span id="l53.56" class="difflineplus">+    nsIMdbEnv* ev) override;</span>
<a href="#l53.57"></a><span id="l53.57">   // } ----- end activity dropping methods -----</span>
<a href="#l53.58"></a><span id="l53.58"> </span>
<a href="#l53.59"></a><span id="l53.59"> // } ===== end nsIMdbCollection methods =====</span>
<a href="#l53.60"></a><span id="l53.60"> // { ===== begin nsIMdbRow methods =====</span>
<a href="#l53.61"></a><span id="l53.61"> </span>
<a href="#l53.62"></a><span id="l53.62">   // { ----- begin cursor methods -----</span>
<a href="#l53.63"></a><span id="l53.63">   NS_IMETHOD GetRowCellCursor( // make a cursor starting iteration at inRowPos</span>
<a href="#l53.64"></a><span id="l53.64">     nsIMdbEnv* ev, // context</span>
<a href="#l53.65"></a><span id="l53.65">     mdb_pos inRowPos, // zero-based ordinal position of row in table</span>
<a href="#l53.66"></a><span id="l53.66" class="difflineminus">-    nsIMdbRowCellCursor** acqCursor); // acquire new cursor instance</span>
<a href="#l53.67"></a><span id="l53.67" class="difflineplus">+    nsIMdbRowCellCursor** acqCursor) override; // acquire new cursor instance</span>
<a href="#l53.68"></a><span id="l53.68">   // } ----- end cursor methods -----</span>
<a href="#l53.69"></a><span id="l53.69"> </span>
<a href="#l53.70"></a><span id="l53.70">   // { ----- begin column methods -----</span>
<a href="#l53.71"></a><span id="l53.71">   NS_IMETHOD AddColumn( // make sure a particular column is inside row</span>
<a href="#l53.72"></a><span id="l53.72">     nsIMdbEnv* ev, // context</span>
<a href="#l53.73"></a><span id="l53.73">     mdb_column inColumn, // column to add</span>
<a href="#l53.74"></a><span id="l53.74" class="difflineminus">-    const mdbYarn* inYarn); // cell value to install</span>
<a href="#l53.75"></a><span id="l53.75" class="difflineplus">+    const mdbYarn* inYarn) override; // cell value to install</span>
<a href="#l53.76"></a><span id="l53.76"> </span>
<a href="#l53.77"></a><span id="l53.77">   NS_IMETHOD CutColumn( // make sure a column is absent from the row</span>
<a href="#l53.78"></a><span id="l53.78">     nsIMdbEnv* ev, // context</span>
<a href="#l53.79"></a><span id="l53.79" class="difflineminus">-    mdb_column inColumn); // column to ensure absent from row</span>
<a href="#l53.80"></a><span id="l53.80" class="difflineplus">+    mdb_column inColumn) override; // column to ensure absent from row</span>
<a href="#l53.81"></a><span id="l53.81"> </span>
<a href="#l53.82"></a><span id="l53.82">   NS_IMETHOD CutAllColumns( // remove all columns from the row</span>
<a href="#l53.83"></a><span id="l53.83" class="difflineminus">-    nsIMdbEnv* ev); // context</span>
<a href="#l53.84"></a><span id="l53.84" class="difflineplus">+    nsIMdbEnv* ev) override; // context</span>
<a href="#l53.85"></a><span id="l53.85">   // } ----- end column methods -----</span>
<a href="#l53.86"></a><span id="l53.86"> </span>
<a href="#l53.87"></a><span id="l53.87">   // { ----- begin cell methods -----</span>
<a href="#l53.88"></a><span id="l53.88">   NS_IMETHOD NewCell( // get cell for specified column, or add new one</span>
<a href="#l53.89"></a><span id="l53.89">     nsIMdbEnv* ev, // context</span>
<a href="#l53.90"></a><span id="l53.90">     mdb_column inColumn, // column to add</span>
<a href="#l53.91"></a><span id="l53.91" class="difflineminus">-    nsIMdbCell** acqCell); // cell column and value</span>
<a href="#l53.92"></a><span id="l53.92" class="difflineminus">-    </span>
<a href="#l53.93"></a><span id="l53.93" class="difflineplus">+    nsIMdbCell** acqCell) override; // cell column and value</span>
<a href="#l53.94"></a><span id="l53.94" class="difflineplus">+</span>
<a href="#l53.95"></a><span id="l53.95">   NS_IMETHOD AddCell( // copy a cell from another row to this row</span>
<a href="#l53.96"></a><span id="l53.96">     nsIMdbEnv* ev, // context</span>
<a href="#l53.97"></a><span id="l53.97" class="difflineminus">-    const nsIMdbCell* inCell); // cell column and value</span>
<a href="#l53.98"></a><span id="l53.98" class="difflineminus">-    </span>
<a href="#l53.99"></a><span id="l53.99" class="difflineplus">+    const nsIMdbCell* inCell) override; // cell column and value</span>
<a href="#l53.100"></a><span id="l53.100" class="difflineplus">+</span>
<a href="#l53.101"></a><span id="l53.101">   NS_IMETHOD GetCell( // find a cell in this row</span>
<a href="#l53.102"></a><span id="l53.102">     nsIMdbEnv* ev, // context</span>
<a href="#l53.103"></a><span id="l53.103">     mdb_column inColumn, // column to find</span>
<a href="#l53.104"></a><span id="l53.104" class="difflineminus">-    nsIMdbCell** acqCell); // cell for specified column, or null</span>
<a href="#l53.105"></a><span id="l53.105" class="difflineminus">-    </span>
<a href="#l53.106"></a><span id="l53.106" class="difflineplus">+    nsIMdbCell** acqCell) override; // cell for specified column, or null</span>
<a href="#l53.107"></a><span id="l53.107" class="difflineplus">+</span>
<a href="#l53.108"></a><span id="l53.108">   NS_IMETHOD EmptyAllCells( // make all cells in row empty of content</span>
<a href="#l53.109"></a><span id="l53.109" class="difflineminus">-    nsIMdbEnv* ev); // context</span>
<a href="#l53.110"></a><span id="l53.110" class="difflineplus">+    nsIMdbEnv* ev) override; // context</span>
<a href="#l53.111"></a><span id="l53.111">   // } ----- end cell methods -----</span>
<a href="#l53.112"></a><span id="l53.112"> </span>
<a href="#l53.113"></a><span id="l53.113">   // { ----- begin row methods -----</span>
<a href="#l53.114"></a><span id="l53.114">   NS_IMETHOD AddRow( // add all cells in another row to this one</span>
<a href="#l53.115"></a><span id="l53.115">     nsIMdbEnv* ev, // context</span>
<a href="#l53.116"></a><span id="l53.116" class="difflineminus">-    nsIMdbRow* ioSourceRow); // row to union with</span>
<a href="#l53.117"></a><span id="l53.117" class="difflineminus">-    </span>
<a href="#l53.118"></a><span id="l53.118" class="difflineplus">+    nsIMdbRow* ioSourceRow) override; // row to union with</span>
<a href="#l53.119"></a><span id="l53.119" class="difflineplus">+</span>
<a href="#l53.120"></a><span id="l53.120">   NS_IMETHOD SetRow( // make exact duplicate of another row</span>
<a href="#l53.121"></a><span id="l53.121">     nsIMdbEnv* ev, // context</span>
<a href="#l53.122"></a><span id="l53.122" class="difflineminus">-    nsIMdbRow* ioSourceRow); // row to duplicate</span>
<a href="#l53.123"></a><span id="l53.123" class="difflineplus">+    nsIMdbRow* ioSourceRow) override; // row to duplicate</span>
<a href="#l53.124"></a><span id="l53.124">   // } ----- end row methods -----</span>
<a href="#l53.125"></a><span id="l53.125"> </span>
<a href="#l53.126"></a><span id="l53.126">   // { ----- begin blob methods -----  </span>
<a href="#l53.127"></a><span id="l53.127">   NS_IMETHOD SetCellYarn(nsIMdbEnv* ev, // synonym for AddColumn()</span>
<a href="#l53.128"></a><span id="l53.128">     mdb_column inColumn, // column to write</span>
<a href="#l53.129"></a><span id="l53.129" class="difflineminus">-    const mdbYarn* inYarn);   // reads from yarn slots</span>
<a href="#l53.130"></a><span id="l53.130" class="difflineplus">+    const mdbYarn* inYarn) override;   // reads from yarn slots</span>
<a href="#l53.131"></a><span id="l53.131">   // make this text object contain content from the yarn's buffer</span>
<a href="#l53.132"></a><span id="l53.132" class="difflineminus">-  </span>
<a href="#l53.133"></a><span id="l53.133" class="difflineplus">+</span>
<a href="#l53.134"></a><span id="l53.134">   NS_IMETHOD GetCellYarn(nsIMdbEnv* ev, </span>
<a href="#l53.135"></a><span id="l53.135">     mdb_column inColumn, // column to read </span>
<a href="#l53.136"></a><span id="l53.136" class="difflineminus">-    mdbYarn* outYarn);  // writes some yarn slots </span>
<a href="#l53.137"></a><span id="l53.137" class="difflineplus">+    mdbYarn* outYarn) override;  // writes some yarn slots </span>
<a href="#l53.138"></a><span id="l53.138">   // copy content into the yarn buffer, and update mYarn_Fill and mYarn_Form</span>
<a href="#l53.139"></a><span id="l53.139" class="difflineminus">-  </span>
<a href="#l53.140"></a><span id="l53.140" class="difflineplus">+</span>
<a href="#l53.141"></a><span id="l53.141">   NS_IMETHOD AliasCellYarn(nsIMdbEnv* ev, </span>
<a href="#l53.142"></a><span id="l53.142">     mdb_column inColumn, // column to alias</span>
<a href="#l53.143"></a><span id="l53.143" class="difflineminus">-    mdbYarn* outYarn); // writes ALL yarn slots</span>
<a href="#l53.144"></a><span id="l53.144" class="difflineminus">-  </span>
<a href="#l53.145"></a><span id="l53.145" class="difflineplus">+    mdbYarn* outYarn) override; // writes ALL yarn slots</span>
<a href="#l53.146"></a><span id="l53.146" class="difflineplus">+</span>
<a href="#l53.147"></a><span id="l53.147">   NS_IMETHOD NextCellYarn(nsIMdbEnv* ev, // iterative version of GetCellYarn()</span>
<a href="#l53.148"></a><span id="l53.148">     mdb_column* ioColumn, // next column to read</span>
<a href="#l53.149"></a><span id="l53.149" class="difflineminus">-    mdbYarn* outYarn);  // writes some yarn slots </span>
<a href="#l53.150"></a><span id="l53.150" class="difflineplus">+    mdbYarn* outYarn) override;  // writes some yarn slots </span>
<a href="#l53.151"></a><span id="l53.151">   // copy content into the yarn buffer, and update mYarn_Fill and mYarn_Form</span>
<a href="#l53.152"></a><span id="l53.152">   //</span>
<a href="#l53.153"></a><span id="l53.153">   // The ioColumn argument is an inout parameter which initially contains the</span>
<a href="#l53.154"></a><span id="l53.154">   // last column accessed and returns the next column corresponding to the</span>
<a href="#l53.155"></a><span id="l53.155">   // content read into the yarn.  Callers should start with a zero column</span>
<a href="#l53.156"></a><span id="l53.156">   // value to say 'no previous column', which causes the first column to be</span>
<a href="#l53.157"></a><span id="l53.157">   // read.  Then the value returned in ioColumn is perfect for the next call</span>
<a href="#l53.158"></a><span id="l53.158">   // to NextCellYarn(), since it will then be the previous column accessed.</span>
<a href="#l53.159"></a><span id="l53.159" class="difflineat">@@ -150,17 +150,17 @@ public: // morkRowObject construction &amp; </span>
<a href="#l53.160"></a><span id="l53.160">   // in the row is being read into the yarn.  When no more columns remain,</span>
<a href="#l53.161"></a><span id="l53.161">   // and the iteration has ended, ioColumn will return a zero token again.</span>
<a href="#l53.162"></a><span id="l53.162">   // So iterating over cells starts and ends with a zero column token.</span>
<a href="#l53.163"></a><span id="l53.163"> </span>
<a href="#l53.164"></a><span id="l53.164">   NS_IMETHOD SeekCellYarn( // resembles nsIMdbRowCellCursor::SeekCell()</span>
<a href="#l53.165"></a><span id="l53.165">     nsIMdbEnv* ev, // context</span>
<a href="#l53.166"></a><span id="l53.166">     mdb_pos inPos, // position of cell in row sequence</span>
<a href="#l53.167"></a><span id="l53.167">     mdb_column* outColumn, // column for this particular cell</span>
<a href="#l53.168"></a><span id="l53.168" class="difflineminus">-    mdbYarn* outYarn); // writes some yarn slots</span>
<a href="#l53.169"></a><span id="l53.169" class="difflineplus">+    mdbYarn* outYarn) override; // writes some yarn slots</span>
<a href="#l53.170"></a><span id="l53.170">   // copy content into the yarn buffer, and update mYarn_Fill and mYarn_Form</span>
<a href="#l53.171"></a><span id="l53.171">   // Callers can pass nil for outYarn to indicate no interest in content, so</span>
<a href="#l53.172"></a><span id="l53.172">   // only the outColumn value is returned.  NOTE to subclasses: you must be</span>
<a href="#l53.173"></a><span id="l53.173">   // able to ignore outYarn when the pointer is nil; please do not crash.</span>
<a href="#l53.174"></a><span id="l53.174"> </span>
<a href="#l53.175"></a><span id="l53.175">   // } ----- end blob methods -----</span>
<a href="#l53.176"></a><span id="l53.176"> </span>
<a href="#l53.177"></a><span id="l53.177"> // } ===== end nsIMdbRow methods =====</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l54.1"></a><span id="l54.1" class="difflineminus">--- a/db/mork/src/morkRowSpace.cpp</span>
<a href="#l54.2"></a><span id="l54.2" class="difflineplus">+++ b/db/mork/src/morkRowSpace.cpp</span>
<a href="#l54.3"></a><span id="l54.3" class="difflineat">@@ -115,18 +115,16 @@ morkRowSpace::morkRowSpace(morkEnv* ev,</span>
<a href="#l54.4"></a><span id="l54.4">     else</span>
<a href="#l54.5"></a><span id="l54.5">       ev-&gt;NilPointerError();</span>
<a href="#l54.6"></a><span id="l54.6">   }</span>
<a href="#l54.7"></a><span id="l54.7"> }</span>
<a href="#l54.8"></a><span id="l54.8"> </span>
<a href="#l54.9"></a><span id="l54.9"> /*public non-poly*/ void</span>
<a href="#l54.10"></a><span id="l54.10"> morkRowSpace::CloseRowSpace(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l54.11"></a><span id="l54.11"> {</span>
<a href="#l54.12"></a><span id="l54.12" class="difflineminus">-  if ( this )</span>
<a href="#l54.13"></a><span id="l54.13" class="difflineminus">-  {</span>
<a href="#l54.14"></a><span id="l54.14">     if ( this-&gt;IsNode() )</span>
<a href="#l54.15"></a><span id="l54.15">     {</span>
<a href="#l54.16"></a><span id="l54.16">       morkAtomRowMap** cache = mRowSpace_IndexCache;</span>
<a href="#l54.17"></a><span id="l54.17">       morkAtomRowMap** cacheEnd = cache + morkRowSpace_kPrimeCacheSize;</span>
<a href="#l54.18"></a><span id="l54.18">       --cache; // prepare for preincrement:</span>
<a href="#l54.19"></a><span id="l54.19">       while ( ++cache &lt; cacheEnd )</span>
<a href="#l54.20"></a><span id="l54.20">       {</span>
<a href="#l54.21"></a><span id="l54.21">         if ( *cache )</span>
<a href="#l54.22"></a><span id="l54.22" class="difflineat">@@ -139,19 +137,16 @@ morkRowSpace::CloseRowSpace(morkEnv* ev)</span>
<a href="#l54.23"></a><span id="l54.23">       if ( store )</span>
<a href="#l54.24"></a><span id="l54.24">         this-&gt;CutAllRows(ev, &amp;store-&gt;mStore_Pool);</span>
<a href="#l54.25"></a><span id="l54.25">       </span>
<a href="#l54.26"></a><span id="l54.26">       mRowSpace_Rows.CloseMorkNode(ev);</span>
<a href="#l54.27"></a><span id="l54.27">       this-&gt;CloseSpace(ev);</span>
<a href="#l54.28"></a><span id="l54.28">     }</span>
<a href="#l54.29"></a><span id="l54.29">     else</span>
<a href="#l54.30"></a><span id="l54.30">       this-&gt;NonNodeError(ev);</span>
<a href="#l54.31"></a><span id="l54.31" class="difflineminus">-  }</span>
<a href="#l54.32"></a><span id="l54.32" class="difflineminus">-  else</span>
<a href="#l54.33"></a><span id="l54.33" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l54.34"></a><span id="l54.34"> }</span>
<a href="#l54.35"></a><span id="l54.35"> </span>
<a href="#l54.36"></a><span id="l54.36"> // } ===== end morkNode methods =====</span>
<a href="#l54.37"></a><span id="l54.37"> // ````` ````` ````` ````` ````` </span>
<a href="#l54.38"></a><span id="l54.38"> </span>
<a href="#l54.39"></a><span id="l54.39"> /*static*/ void</span>
<a href="#l54.40"></a><span id="l54.40"> morkRowSpace::NonRowSpaceTypeError(morkEnv* ev)</span>
<a href="#l54.41"></a><span id="l54.41"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l55.1"></a><span id="l55.1" class="difflineminus">--- a/db/mork/src/morkRowSpace.h</span>
<a href="#l55.2"></a><span id="l55.2" class="difflineplus">+++ b/db/mork/src/morkRowSpace.h</span>
<a href="#l55.3"></a><span id="l55.3" class="difflineat">@@ -98,17 +98,17 @@ public: // more specific dirty methods f</span>
<a href="#l55.4"></a><span id="l55.4">   void SetRowSpaceDirty() { this-&gt;SetNodeDirty(); }</span>
<a href="#l55.5"></a><span id="l55.5">   void SetRowSpaceClean() { this-&gt;SetNodeClean(); }</span>
<a href="#l55.6"></a><span id="l55.6">   </span>
<a href="#l55.7"></a><span id="l55.7">   mork_bool IsRowSpaceClean() const { return this-&gt;IsNodeClean(); }</span>
<a href="#l55.8"></a><span id="l55.8">   mork_bool IsRowSpaceDirty() const { return this-&gt;IsNodeDirty(); }</span>
<a href="#l55.9"></a><span id="l55.9"> </span>
<a href="#l55.10"></a><span id="l55.10"> // { ===== begin morkNode interface =====</span>
<a href="#l55.11"></a><span id="l55.11"> public: // morkNode virtual methods</span>
<a href="#l55.12"></a><span id="l55.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseRowSpace() only if open</span>
<a href="#l55.13"></a><span id="l55.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseRowSpace() only if open</span>
<a href="#l55.14"></a><span id="l55.14">   virtual ~morkRowSpace(); // assert that CloseRowSpace() executed earlier</span>
<a href="#l55.15"></a><span id="l55.15">   </span>
<a href="#l55.16"></a><span id="l55.16"> public: // morkMap construction &amp; destruction</span>
<a href="#l55.17"></a><span id="l55.17">   morkRowSpace(morkEnv* ev, const morkUsage&amp; inUsage, mork_scope inScope,</span>
<a href="#l55.18"></a><span id="l55.18">     morkStore* ioStore, nsIMdbHeap* ioNodeHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l55.19"></a><span id="l55.19">   void CloseRowSpace(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l55.20"></a><span id="l55.20"> </span>
<a href="#l55.21"></a><span id="l55.21"> public: // dynamic type identification</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l56.1"></a><span id="l56.1" class="difflineminus">--- a/db/mork/src/morkSearchRowCursor.cpp</span>
<a href="#l56.2"></a><span id="l56.2" class="difflineplus">+++ b/db/mork/src/morkSearchRowCursor.cpp</span>
<a href="#l56.3"></a><span id="l56.3" class="difflineat">@@ -86,29 +86,24 @@ morkSearchRowCursor::morkSearchRowCursor</span>
<a href="#l56.4"></a><span id="l56.4">     else</span>
<a href="#l56.5"></a><span id="l56.5">       ev-&gt;NilPointerError();</span>
<a href="#l56.6"></a><span id="l56.6">   }</span>
<a href="#l56.7"></a><span id="l56.7"> }</span>
<a href="#l56.8"></a><span id="l56.8"> </span>
<a href="#l56.9"></a><span id="l56.9"> /*public non-poly*/ void</span>
<a href="#l56.10"></a><span id="l56.10"> morkSearchRowCursor::CloseSearchRowCursor(morkEnv* ev) </span>
<a href="#l56.11"></a><span id="l56.11"> {</span>
<a href="#l56.12"></a><span id="l56.12" class="difflineminus">-  if ( this )</span>
<a href="#l56.13"></a><span id="l56.13" class="difflineminus">-  {</span>
<a href="#l56.14"></a><span id="l56.14">     if ( this-&gt;IsNode() )</span>
<a href="#l56.15"></a><span id="l56.15">     {</span>
<a href="#l56.16"></a><span id="l56.16">       // morkSorting::SlotWeakSorting((morkSorting*) 0, ev, &amp;mSortingRowCursor_Sorting);</span>
<a href="#l56.17"></a><span id="l56.17">       this-&gt;CloseTableRowCursor(ev);</span>
<a href="#l56.18"></a><span id="l56.18">       this-&gt;MarkShut();</span>
<a href="#l56.19"></a><span id="l56.19">     }</span>
<a href="#l56.20"></a><span id="l56.20">     else</span>
<a href="#l56.21"></a><span id="l56.21">       this-&gt;NonNodeError(ev);</span>
<a href="#l56.22"></a><span id="l56.22" class="difflineminus">-  }</span>
<a href="#l56.23"></a><span id="l56.23" class="difflineminus">-  else</span>
<a href="#l56.24"></a><span id="l56.24" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l56.25"></a><span id="l56.25"> }</span>
<a href="#l56.26"></a><span id="l56.26"> </span>
<a href="#l56.27"></a><span id="l56.27"> // } ===== end morkNode methods =====</span>
<a href="#l56.28"></a><span id="l56.28"> // ````` ````` ````` ````` ````` </span>
<a href="#l56.29"></a><span id="l56.29"> </span>
<a href="#l56.30"></a><span id="l56.30"> /*static*/ void</span>
<a href="#l56.31"></a><span id="l56.31"> morkSearchRowCursor::NonSearchRowCursorTypeError(morkEnv* ev)</span>
<a href="#l56.32"></a><span id="l56.32"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l57.1"></a><span id="l57.1" class="difflineminus">--- a/db/mork/src/morkSpace.cpp</span>
<a href="#l57.2"></a><span id="l57.2" class="difflineplus">+++ b/db/mork/src/morkSpace.cpp</span>
<a href="#l57.3"></a><span id="l57.3" class="difflineat">@@ -95,29 +95,24 @@ morkSpace::morkSpace(morkEnv* ev,</span>
<a href="#l57.4"></a><span id="l57.4">     else</span>
<a href="#l57.5"></a><span id="l57.5">       ev-&gt;NilPointerError();</span>
<a href="#l57.6"></a><span id="l57.6">   }</span>
<a href="#l57.7"></a><span id="l57.7"> }</span>
<a href="#l57.8"></a><span id="l57.8"> </span>
<a href="#l57.9"></a><span id="l57.9"> /*public non-poly*/ void</span>
<a href="#l57.10"></a><span id="l57.10"> morkSpace::CloseSpace(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l57.11"></a><span id="l57.11"> {</span>
<a href="#l57.12"></a><span id="l57.12" class="difflineminus">-  if ( this )</span>
<a href="#l57.13"></a><span id="l57.13" class="difflineminus">-  {</span>
<a href="#l57.14"></a><span id="l57.14">     if ( this-&gt;IsNode() )</span>
<a href="#l57.15"></a><span id="l57.15">     {</span>
<a href="#l57.16"></a><span id="l57.16">       morkStore::SlotWeakStore((morkStore*) 0, ev, &amp;mSpace_Store);</span>
<a href="#l57.17"></a><span id="l57.17">       mBead_Color = 0; // this-&gt;CloseBead();</span>
<a href="#l57.18"></a><span id="l57.18">       this-&gt;MarkShut();</span>
<a href="#l57.19"></a><span id="l57.19">     }</span>
<a href="#l57.20"></a><span id="l57.20">     else</span>
<a href="#l57.21"></a><span id="l57.21">       this-&gt;NonNodeError(ev);</span>
<a href="#l57.22"></a><span id="l57.22" class="difflineminus">-  }</span>
<a href="#l57.23"></a><span id="l57.23" class="difflineminus">-  else</span>
<a href="#l57.24"></a><span id="l57.24" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l57.25"></a><span id="l57.25"> }</span>
<a href="#l57.26"></a><span id="l57.26"> </span>
<a href="#l57.27"></a><span id="l57.27"> // } ===== end morkNode methods =====</span>
<a href="#l57.28"></a><span id="l57.28"> // ````` ````` ````` ````` ````` </span>
<a href="#l57.29"></a><span id="l57.29"> </span>
<a href="#l57.30"></a><span id="l57.30"> /*static*/ void </span>
<a href="#l57.31"></a><span id="l57.31"> morkSpace::NonAsciiSpaceScopeName(morkEnv* ev)</span>
<a href="#l57.32"></a><span id="l57.32"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l58.1"></a><span id="l58.1" class="difflineminus">--- a/db/mork/src/morkStore.cpp</span>
<a href="#l58.2"></a><span id="l58.2" class="difflineplus">+++ b/db/mork/src/morkStore.cpp</span>
<a href="#l58.3"></a><span id="l58.3" class="difflineat">@@ -109,30 +109,25 @@ morkStore::CloseMorkNode(morkEnv* ev) //</span>
<a href="#l58.4"></a><span id="l58.4">     this-&gt;CloseStore(ev);</span>
<a href="#l58.5"></a><span id="l58.5">     this-&gt;MarkShut();</span>
<a href="#l58.6"></a><span id="l58.6">   }</span>
<a href="#l58.7"></a><span id="l58.7"> }</span>
<a href="#l58.8"></a><span id="l58.8"> </span>
<a href="#l58.9"></a><span id="l58.9"> /*public non-poly*/ void</span>
<a href="#l58.10"></a><span id="l58.10"> morkStore::ClosePort(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l58.11"></a><span id="l58.11"> {</span>
<a href="#l58.12"></a><span id="l58.12" class="difflineminus">-  if ( this )</span>
<a href="#l58.13"></a><span id="l58.13" class="difflineminus">-  {</span>
<a href="#l58.14"></a><span id="l58.14">     if ( this-&gt;IsNode() )</span>
<a href="#l58.15"></a><span id="l58.15">     {</span>
<a href="#l58.16"></a><span id="l58.16">       morkFactory::SlotWeakFactory((morkFactory*) 0, ev, &amp;mPort_Factory);</span>
<a href="#l58.17"></a><span id="l58.17">       nsIMdbHeap_SlotStrongHeap((nsIMdbHeap*) 0, ev, &amp;mPort_Heap);</span>
<a href="#l58.18"></a><span id="l58.18">       this-&gt;CloseObject(ev);</span>
<a href="#l58.19"></a><span id="l58.19">       this-&gt;MarkShut();</span>
<a href="#l58.20"></a><span id="l58.20">     }</span>
<a href="#l58.21"></a><span id="l58.21">     else</span>
<a href="#l58.22"></a><span id="l58.22">       this-&gt;NonNodeError(ev);</span>
<a href="#l58.23"></a><span id="l58.23" class="difflineminus">-  }</span>
<a href="#l58.24"></a><span id="l58.24" class="difflineminus">-  else</span>
<a href="#l58.25"></a><span id="l58.25" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l58.26"></a><span id="l58.26"> }</span>
<a href="#l58.27"></a><span id="l58.27"> </span>
<a href="#l58.28"></a><span id="l58.28"> /*public virtual*/</span>
<a href="#l58.29"></a><span id="l58.29"> morkStore::~morkStore() // assert CloseStore() executed earlier</span>
<a href="#l58.30"></a><span id="l58.30"> {</span>
<a href="#l58.31"></a><span id="l58.31">   MOZ_COUNT_DTOR(morkStore);</span>
<a href="#l58.32"></a><span id="l58.32">   if (IsOpenNode())</span>
<a href="#l58.33"></a><span id="l58.33">     CloseMorkNode(mMorkEnv);</span>
<a href="#l58.34"></a><span id="l58.34" class="difflineat">@@ -203,18 +198,16 @@ morkStore::morkStore(morkEnv* ev, const </span>
<a href="#l58.35"></a><span id="l58.35">   }</span>
<a href="#l58.36"></a><span id="l58.36"> }</span>
<a href="#l58.37"></a><span id="l58.37"> </span>
<a href="#l58.38"></a><span id="l58.38"> NS_IMPL_ISUPPORTS_INHERITED(morkStore, morkObject, nsIMdbStore)</span>
<a href="#l58.39"></a><span id="l58.39"> </span>
<a href="#l58.40"></a><span id="l58.40"> /*public non-poly*/ void</span>
<a href="#l58.41"></a><span id="l58.41"> morkStore::CloseStore(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l58.42"></a><span id="l58.42"> {</span>
<a href="#l58.43"></a><span id="l58.43" class="difflineminus">-  if ( this )</span>
<a href="#l58.44"></a><span id="l58.44" class="difflineminus">-  {</span>
<a href="#l58.45"></a><span id="l58.45">     if ( this-&gt;IsNode() )</span>
<a href="#l58.46"></a><span id="l58.46">     {</span>
<a href="#l58.47"></a><span id="l58.47"> </span>
<a href="#l58.48"></a><span id="l58.48">       nsIMdbFile* file = mStore_File;</span>
<a href="#l58.49"></a><span id="l58.49">       file-&gt;AddRef();</span>
<a href="#l58.50"></a><span id="l58.50"> </span>
<a href="#l58.51"></a><span id="l58.51">       morkFactory::SlotWeakFactory((morkFactory*) 0, ev, &amp;mPort_Factory);</span>
<a href="#l58.52"></a><span id="l58.52">       nsIMdbHeap_SlotStrongHeap((nsIMdbHeap*) 0, ev, &amp;mPort_Heap);</span>
<a href="#l58.53"></a><span id="l58.53" class="difflineat">@@ -238,19 +231,16 @@ morkStore::CloseStore(morkEnv* ev) // ca</span>
<a href="#l58.54"></a><span id="l58.54"> </span>
<a href="#l58.55"></a><span id="l58.55">       mStore_Pool.CloseMorkNode(ev);</span>
<a href="#l58.56"></a><span id="l58.56">       mStore_Zone.CloseMorkNode(ev);</span>
<a href="#l58.57"></a><span id="l58.57">       this-&gt;ClosePort(ev);</span>
<a href="#l58.58"></a><span id="l58.58">       this-&gt;MarkShut();</span>
<a href="#l58.59"></a><span id="l58.59">     }</span>
<a href="#l58.60"></a><span id="l58.60">     else</span>
<a href="#l58.61"></a><span id="l58.61">       this-&gt;NonNodeError(ev);</span>
<a href="#l58.62"></a><span id="l58.62" class="difflineminus">-  }</span>
<a href="#l58.63"></a><span id="l58.63" class="difflineminus">-  else</span>
<a href="#l58.64"></a><span id="l58.64" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l58.65"></a><span id="l58.65"> }</span>
<a href="#l58.66"></a><span id="l58.66"> </span>
<a href="#l58.67"></a><span id="l58.67"> // } ===== end morkNode methods =====</span>
<a href="#l58.68"></a><span id="l58.68"> // ````` ````` ````` ````` ````` </span>
<a href="#l58.69"></a><span id="l58.69"> </span>
<a href="#l58.70"></a><span id="l58.70"> </span>
<a href="#l58.71"></a><span id="l58.71"> mork_bool morkStore::DoPreferLargeOverCompressCommit(morkEnv* ev)</span>
<a href="#l58.72"></a><span id="l58.72">   // true when mStore_CanWriteIncremental &amp;&amp; store has file large enough </span>
<a href="#l58.73"></a><span id="l58.73" class="difflineat">@@ -1308,29 +1298,42 @@ morkStore::GetStrongRefCount(nsIMdbEnv* </span>
<a href="#l58.74"></a><span id="l58.74"> // ### TODO - clean up this cast, if required</span>
<a href="#l58.75"></a><span id="l58.75"> NS_IMETHODIMP</span>
<a href="#l58.76"></a><span id="l58.76"> morkStore::AddWeakRef(nsIMdbEnv* mev)</span>
<a href="#l58.77"></a><span id="l58.77"> {</span>
<a href="#l58.78"></a><span id="l58.78">   morkEnv *ev  = morkEnv::FromMdbEnv(mev);</span>
<a href="#l58.79"></a><span id="l58.79">   // XXX Casting mork_refs to nsresult</span>
<a href="#l58.80"></a><span id="l58.80">   return static_cast&lt;nsresult&gt;(morkNode::AddWeakRef(ev));</span>
<a href="#l58.81"></a><span id="l58.81"> }</span>
<a href="#l58.82"></a><span id="l58.82" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l58.83"></a><span id="l58.83" class="difflineplus">+NS_IMETHODIMP_(mork_uses)</span>
<a href="#l58.84"></a><span id="l58.84" class="difflineplus">+morkStore::AddStrongRef(morkEnv* mev)</span>
<a href="#l58.85"></a><span id="l58.85" class="difflineplus">+{</span>
<a href="#l58.86"></a><span id="l58.86" class="difflineplus">+  return AddRef();</span>
<a href="#l58.87"></a><span id="l58.87" class="difflineplus">+}</span>
<a href="#l58.88"></a><span id="l58.88" class="difflineplus">+#endif</span>
<a href="#l58.89"></a><span id="l58.89"> NS_IMETHODIMP_(mork_uses)</span>
<a href="#l58.90"></a><span id="l58.90"> morkStore::AddStrongRef(nsIMdbEnv* mev)</span>
<a href="#l58.91"></a><span id="l58.91"> {</span>
<a href="#l58.92"></a><span id="l58.92">   return AddRef();</span>
<a href="#l58.93"></a><span id="l58.93"> }</span>
<a href="#l58.94"></a><span id="l58.94" class="difflineminus">-</span>
<a href="#l58.95"></a><span id="l58.95"> NS_IMETHODIMP</span>
<a href="#l58.96"></a><span id="l58.96"> morkStore::CutWeakRef(nsIMdbEnv* mev)</span>
<a href="#l58.97"></a><span id="l58.97"> {</span>
<a href="#l58.98"></a><span id="l58.98">   morkEnv *ev  = morkEnv::FromMdbEnv(mev);</span>
<a href="#l58.99"></a><span id="l58.99">   // XXX Casting mork_refs to nsresult</span>
<a href="#l58.100"></a><span id="l58.100">   return static_cast&lt;nsresult&gt;(morkNode::CutWeakRef(ev));</span>
<a href="#l58.101"></a><span id="l58.101"> }</span>
<a href="#l58.102"></a><span id="l58.102" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l58.103"></a><span id="l58.103" class="difflineplus">+NS_IMETHODIMP_(mork_uses)</span>
<a href="#l58.104"></a><span id="l58.104" class="difflineplus">+morkStore::CutStrongRef(morkEnv* mev)</span>
<a href="#l58.105"></a><span id="l58.105" class="difflineplus">+{</span>
<a href="#l58.106"></a><span id="l58.106" class="difflineplus">+  return Release();</span>
<a href="#l58.107"></a><span id="l58.107" class="difflineplus">+}</span>
<a href="#l58.108"></a><span id="l58.108" class="difflineplus">+#endif</span>
<a href="#l58.109"></a><span id="l58.109"> NS_IMETHODIMP</span>
<a href="#l58.110"></a><span id="l58.110"> morkStore::CutStrongRef(nsIMdbEnv* mev)</span>
<a href="#l58.111"></a><span id="l58.111"> {</span>
<a href="#l58.112"></a><span id="l58.112">   // XXX Casting nsrefcnt to nsresult</span>
<a href="#l58.113"></a><span id="l58.113">   return static_cast&lt;nsresult&gt;(Release());</span>
<a href="#l58.114"></a><span id="l58.114"> }</span>
<a href="#l58.115"></a><span id="l58.115"> </span>
<a href="#l58.116"></a><span id="l58.116"> NS_IMETHODIMP</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l59.1"></a><span id="l59.1" class="difflineminus">--- a/db/mork/src/morkStore.h</span>
<a href="#l59.2"></a><span id="l59.2" class="difflineplus">+++ b/db/mork/src/morkStore.h</span>
<a href="#l59.3"></a><span id="l59.3" class="difflineat">@@ -93,143 +93,151 @@ public: // other port methods</span>
<a href="#l59.4"></a><span id="l59.4">   // } ----- end attribute methods -----</span>
<a href="#l59.5"></a><span id="l59.5"> </span>
<a href="#l59.6"></a><span id="l59.6">   // { ----- begin factory methods -----</span>
<a href="#l59.7"></a><span id="l59.7"> //  NS_IMETHOD GetMdbFactory(nsIMdbEnv* ev, nsIMdbFactory** acqFactory); </span>
<a href="#l59.8"></a><span id="l59.8">   // } ----- end factory methods -----</span>
<a href="#l59.9"></a><span id="l59.9"> </span>
<a href="#l59.10"></a><span id="l59.10">   // { ----- begin ref counting for well-behaved cyclic graphs -----</span>
<a href="#l59.11"></a><span id="l59.11">   NS_IMETHOD GetWeakRefCount(nsIMdbEnv* ev, // weak refs</span>
<a href="#l59.12"></a><span id="l59.12" class="difflineminus">-    mdb_count* outCount);  </span>
<a href="#l59.13"></a><span id="l59.13" class="difflineplus">+    mdb_count* outCount) override;</span>
<a href="#l59.14"></a><span id="l59.14">   NS_IMETHOD GetStrongRefCount(nsIMdbEnv* ev, // strong refs</span>
<a href="#l59.15"></a><span id="l59.15" class="difflineminus">-    mdb_count* outCount);</span>
<a href="#l59.16"></a><span id="l59.16" class="difflineplus">+    mdb_count* outCount) override;</span>
<a href="#l59.17"></a><span id="l59.17"> </span>
<a href="#l59.18"></a><span id="l59.18" class="difflineminus">-  NS_IMETHOD AddWeakRef(nsIMdbEnv* ev);</span>
<a href="#l59.19"></a><span id="l59.19" class="difflineminus">-  NS_IMETHOD_(mork_uses) AddStrongRef(nsIMdbEnv* ev);</span>
<a href="#l59.20"></a><span id="l59.20" class="difflineplus">+  NS_IMETHOD AddWeakRef(nsIMdbEnv* ev) override;</span>
<a href="#l59.21"></a><span id="l59.21" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l59.22"></a><span id="l59.22" class="difflineplus">+  // The first declaration of AddStrongRef is to suppress -Werror,-Woverloaded-virtual.</span>
<a href="#l59.23"></a><span id="l59.23" class="difflineplus">+  NS_IMETHOD_(mork_uses) AddStrongRef(morkEnv* ev) override;</span>
<a href="#l59.24"></a><span id="l59.24" class="difflineplus">+#endif</span>
<a href="#l59.25"></a><span id="l59.25" class="difflineplus">+  NS_IMETHOD_(mork_uses) AddStrongRef(nsIMdbEnv* ev) override;</span>
<a href="#l59.26"></a><span id="l59.26"> </span>
<a href="#l59.27"></a><span id="l59.27" class="difflineminus">-  NS_IMETHOD CutWeakRef(nsIMdbEnv* ev);</span>
<a href="#l59.28"></a><span id="l59.28" class="difflineminus">-  NS_IMETHOD CutStrongRef(nsIMdbEnv* ev);</span>
<a href="#l59.29"></a><span id="l59.29" class="difflineminus">-  </span>
<a href="#l59.30"></a><span id="l59.30" class="difflineminus">-  NS_IMETHOD CloseMdbObject(nsIMdbEnv* ev); // called at strong refs zero</span>
<a href="#l59.31"></a><span id="l59.31" class="difflineminus">-  NS_IMETHOD IsOpenMdbObject(nsIMdbEnv* ev, mdb_bool* outOpen);</span>
<a href="#l59.32"></a><span id="l59.32" class="difflineplus">+  NS_IMETHOD CutWeakRef(nsIMdbEnv* ev) override;</span>
<a href="#l59.33"></a><span id="l59.33" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l59.34"></a><span id="l59.34" class="difflineplus">+  // The first declaration of CutStrongRef is to suppress -Werror,-Woverloaded-virtual.</span>
<a href="#l59.35"></a><span id="l59.35" class="difflineplus">+  NS_IMETHOD_(mork_uses) CutStrongRef(morkEnv* ev) override;</span>
<a href="#l59.36"></a><span id="l59.36" class="difflineplus">+#endif</span>
<a href="#l59.37"></a><span id="l59.37" class="difflineplus">+  NS_IMETHOD CutStrongRef(nsIMdbEnv* ev) override;</span>
<a href="#l59.38"></a><span id="l59.38" class="difflineplus">+</span>
<a href="#l59.39"></a><span id="l59.39" class="difflineplus">+  NS_IMETHOD CloseMdbObject(nsIMdbEnv* ev) override; // called at strong refs zero</span>
<a href="#l59.40"></a><span id="l59.40" class="difflineplus">+  NS_IMETHOD IsOpenMdbObject(nsIMdbEnv* ev, mdb_bool* outOpen) override;</span>
<a href="#l59.41"></a><span id="l59.41">   // } ----- end ref counting -----</span>
<a href="#l59.42"></a><span id="l59.42">   </span>
<a href="#l59.43"></a><span id="l59.43"> // } ===== end nsIMdbObject methods =====</span>
<a href="#l59.44"></a><span id="l59.44"> </span>
<a href="#l59.45"></a><span id="l59.45"> // { ===== begin nsIMdbPort methods =====</span>
<a href="#l59.46"></a><span id="l59.46"> </span>
<a href="#l59.47"></a><span id="l59.47">   // { ----- begin attribute methods -----</span>
<a href="#l59.48"></a><span id="l59.48" class="difflineminus">-  NS_IMETHOD GetIsPortReadonly(nsIMdbEnv* ev, mdb_bool* outBool);</span>
<a href="#l59.49"></a><span id="l59.49" class="difflineminus">-  NS_IMETHOD GetIsStore(nsIMdbEnv* ev, mdb_bool* outBool);</span>
<a href="#l59.50"></a><span id="l59.50" class="difflineminus">-  NS_IMETHOD GetIsStoreAndDirty(nsIMdbEnv* ev, mdb_bool* outBool);</span>
<a href="#l59.51"></a><span id="l59.51" class="difflineplus">+  NS_IMETHOD GetIsPortReadonly(nsIMdbEnv* ev, mdb_bool* outBool) override;</span>
<a href="#l59.52"></a><span id="l59.52" class="difflineplus">+  NS_IMETHOD GetIsStore(nsIMdbEnv* ev, mdb_bool* outBool) override;</span>
<a href="#l59.53"></a><span id="l59.53" class="difflineplus">+  NS_IMETHOD GetIsStoreAndDirty(nsIMdbEnv* ev, mdb_bool* outBool) override;</span>
<a href="#l59.54"></a><span id="l59.54"> </span>
<a href="#l59.55"></a><span id="l59.55" class="difflineminus">-  NS_IMETHOD GetUsagePolicy(nsIMdbEnv* ev, </span>
<a href="#l59.56"></a><span id="l59.56" class="difflineminus">-    mdbUsagePolicy* ioUsagePolicy);</span>
<a href="#l59.57"></a><span id="l59.57" class="difflineplus">+  NS_IMETHOD GetUsagePolicy(nsIMdbEnv* ev,</span>
<a href="#l59.58"></a><span id="l59.58" class="difflineplus">+    mdbUsagePolicy* ioUsagePolicy) override;</span>
<a href="#l59.59"></a><span id="l59.59"> </span>
<a href="#l59.60"></a><span id="l59.60" class="difflineminus">-  NS_IMETHOD SetUsagePolicy(nsIMdbEnv* ev, </span>
<a href="#l59.61"></a><span id="l59.61" class="difflineminus">-    const mdbUsagePolicy* inUsagePolicy);</span>
<a href="#l59.62"></a><span id="l59.62" class="difflineplus">+  NS_IMETHOD SetUsagePolicy(nsIMdbEnv* ev,</span>
<a href="#l59.63"></a><span id="l59.63" class="difflineplus">+    const mdbUsagePolicy* inUsagePolicy) override;</span>
<a href="#l59.64"></a><span id="l59.64">   // } ----- end attribute methods -----</span>
<a href="#l59.65"></a><span id="l59.65"> </span>
<a href="#l59.66"></a><span id="l59.66">   // { ----- begin memory policy methods -----  </span>
<a href="#l59.67"></a><span id="l59.67">   NS_IMETHOD IdleMemoryPurge( // do memory management already scheduled</span>
<a href="#l59.68"></a><span id="l59.68">     nsIMdbEnv* ev, // context</span>
<a href="#l59.69"></a><span id="l59.69" class="difflineminus">-    mdb_size* outEstimatedBytesFreed); // approximate bytes actually freed</span>
<a href="#l59.70"></a><span id="l59.70" class="difflineplus">+    mdb_size* outEstimatedBytesFreed) override; // approximate bytes actually freed</span>
<a href="#l59.71"></a><span id="l59.71"> </span>
<a href="#l59.72"></a><span id="l59.72">   NS_IMETHOD SessionMemoryPurge( // request specific footprint decrease</span>
<a href="#l59.73"></a><span id="l59.73">     nsIMdbEnv* ev, // context</span>
<a href="#l59.74"></a><span id="l59.74">     mdb_size inDesiredBytesFreed, // approximate number of bytes wanted</span>
<a href="#l59.75"></a><span id="l59.75" class="difflineminus">-    mdb_size* outEstimatedBytesFreed); // approximate bytes actually freed</span>
<a href="#l59.76"></a><span id="l59.76" class="difflineplus">+    mdb_size* outEstimatedBytesFreed) override; // approximate bytes actually freed</span>
<a href="#l59.77"></a><span id="l59.77"> </span>
<a href="#l59.78"></a><span id="l59.78">   NS_IMETHOD PanicMemoryPurge( // desperately free all possible memory</span>
<a href="#l59.79"></a><span id="l59.79">     nsIMdbEnv* ev, // context</span>
<a href="#l59.80"></a><span id="l59.80" class="difflineminus">-    mdb_size* outEstimatedBytesFreed); // approximate bytes actually freed</span>
<a href="#l59.81"></a><span id="l59.81" class="difflineplus">+    mdb_size* outEstimatedBytesFreed) override; // approximate bytes actually freed</span>
<a href="#l59.82"></a><span id="l59.82">   // } ----- end memory policy methods -----</span>
<a href="#l59.83"></a><span id="l59.83"> </span>
<a href="#l59.84"></a><span id="l59.84">   // { ----- begin filepath methods -----</span>
<a href="#l59.85"></a><span id="l59.85">   NS_IMETHOD GetPortFilePath(</span>
<a href="#l59.86"></a><span id="l59.86">     nsIMdbEnv* ev, // context</span>
<a href="#l59.87"></a><span id="l59.87">     mdbYarn* outFilePath, // name of file holding port content</span>
<a href="#l59.88"></a><span id="l59.88" class="difflineminus">-    mdbYarn* outFormatVersion); // file format description</span>
<a href="#l59.89"></a><span id="l59.89" class="difflineplus">+    mdbYarn* outFormatVersion) override; // file format description</span>
<a href="#l59.90"></a><span id="l59.90"> </span>
<a href="#l59.91"></a><span id="l59.91">   NS_IMETHOD GetPortFile(</span>
<a href="#l59.92"></a><span id="l59.92">     nsIMdbEnv* ev, // context</span>
<a href="#l59.93"></a><span id="l59.93" class="difflineminus">-    nsIMdbFile** acqFile); // acquire file used by port or store</span>
<a href="#l59.94"></a><span id="l59.94" class="difflineplus">+    nsIMdbFile** acqFile) override; // acquire file used by port or store</span>
<a href="#l59.95"></a><span id="l59.95">   // } ----- end filepath methods -----</span>
<a href="#l59.96"></a><span id="l59.96"> </span>
<a href="#l59.97"></a><span id="l59.97">   // { ----- begin export methods -----</span>
<a href="#l59.98"></a><span id="l59.98">   NS_IMETHOD BestExportFormat( // determine preferred export format</span>
<a href="#l59.99"></a><span id="l59.99">     nsIMdbEnv* ev, // context</span>
<a href="#l59.100"></a><span id="l59.100" class="difflineminus">-    mdbYarn* outFormatVersion); // file format description</span>
<a href="#l59.101"></a><span id="l59.101" class="difflineplus">+    mdbYarn* outFormatVersion) override; // file format description</span>
<a href="#l59.102"></a><span id="l59.102"> </span>
<a href="#l59.103"></a><span id="l59.103">   NS_IMETHOD</span>
<a href="#l59.104"></a><span id="l59.104">   CanExportToFormat( // can export content in given specific format?</span>
<a href="#l59.105"></a><span id="l59.105">     nsIMdbEnv* ev, // context</span>
<a href="#l59.106"></a><span id="l59.106">     const char* inFormatVersion, // file format description</span>
<a href="#l59.107"></a><span id="l59.107" class="difflineminus">-    mdb_bool* outCanExport); // whether ExportSource() might succeed</span>
<a href="#l59.108"></a><span id="l59.108" class="difflineplus">+    mdb_bool* outCanExport) override; // whether ExportSource() might succeed</span>
<a href="#l59.109"></a><span id="l59.109"> </span>
<a href="#l59.110"></a><span id="l59.110">   NS_IMETHOD ExportToFormat( // export content in given specific format</span>
<a href="#l59.111"></a><span id="l59.111">     nsIMdbEnv* ev, // context</span>
<a href="#l59.112"></a><span id="l59.112">     // const char* inFilePath, // the file to receive exported content</span>
<a href="#l59.113"></a><span id="l59.113">     nsIMdbFile* ioFile, // destination abstract file interface</span>
<a href="#l59.114"></a><span id="l59.114">     const char* inFormatVersion, // file format description</span>
<a href="#l59.115"></a><span id="l59.115" class="difflineminus">-    nsIMdbThumb** acqThumb); // acquire thumb for incremental export</span>
<a href="#l59.116"></a><span id="l59.116" class="difflineplus">+    nsIMdbThumb** acqThumb) override; // acquire thumb for incremental export</span>
<a href="#l59.117"></a><span id="l59.117">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l59.118"></a><span id="l59.118">   // then the export will be finished.</span>
<a href="#l59.119"></a><span id="l59.119"> </span>
<a href="#l59.120"></a><span id="l59.120">   // } ----- end export methods -----</span>
<a href="#l59.121"></a><span id="l59.121"> </span>
<a href="#l59.122"></a><span id="l59.122">   // { ----- begin token methods -----</span>
<a href="#l59.123"></a><span id="l59.123">   NS_IMETHOD TokenToString( // return a string name for an integer token</span>
<a href="#l59.124"></a><span id="l59.124">     nsIMdbEnv* ev, // context</span>
<a href="#l59.125"></a><span id="l59.125">     mdb_token inToken, // token for inTokenName inside this port</span>
<a href="#l59.126"></a><span id="l59.126" class="difflineminus">-    mdbYarn* outTokenName); // the type of table to access</span>
<a href="#l59.127"></a><span id="l59.127" class="difflineplus">+    mdbYarn* outTokenName) override; // the type of table to access</span>
<a href="#l59.128"></a><span id="l59.128">   </span>
<a href="#l59.129"></a><span id="l59.129">   NS_IMETHOD StringToToken( // return an integer token for scope name</span>
<a href="#l59.130"></a><span id="l59.130">     nsIMdbEnv* ev, // context</span>
<a href="#l59.131"></a><span id="l59.131">     const char* inTokenName, // Latin1 string to tokenize if possible</span>
<a href="#l59.132"></a><span id="l59.132" class="difflineminus">-    mdb_token* outToken); // token for inTokenName inside this port</span>
<a href="#l59.133"></a><span id="l59.133" class="difflineplus">+    mdb_token* outToken) override; // token for inTokenName inside this port</span>
<a href="#l59.134"></a><span id="l59.134">     </span>
<a href="#l59.135"></a><span id="l59.135">   // String token zero is never used and never supported. If the port</span>
<a href="#l59.136"></a><span id="l59.136">   // is a mutable store, then StringToToken() to create a new</span>
<a href="#l59.137"></a><span id="l59.137">   // association of inTokenName with a new integer token if possible.</span>
<a href="#l59.138"></a><span id="l59.138">   // But a readonly port will return zero for an unknown scope name.</span>
<a href="#l59.139"></a><span id="l59.139"> </span>
<a href="#l59.140"></a><span id="l59.140">   NS_IMETHOD QueryToken( // like StringToToken(), but without adding</span>
<a href="#l59.141"></a><span id="l59.141">     nsIMdbEnv* ev, // context</span>
<a href="#l59.142"></a><span id="l59.142">     const char* inTokenName, // Latin1 string to tokenize if possible</span>
<a href="#l59.143"></a><span id="l59.143" class="difflineminus">-    mdb_token* outToken); // token for inTokenName inside this port</span>
<a href="#l59.144"></a><span id="l59.144" class="difflineplus">+    mdb_token* outToken) override; // token for inTokenName inside this port</span>
<a href="#l59.145"></a><span id="l59.145">   </span>
<a href="#l59.146"></a><span id="l59.146">   // QueryToken() will return a string token if one already exists,</span>
<a href="#l59.147"></a><span id="l59.147">   // but unlike StringToToken(), will not assign a new token if not</span>
<a href="#l59.148"></a><span id="l59.148">   // already in use.</span>
<a href="#l59.149"></a><span id="l59.149"> </span>
<a href="#l59.150"></a><span id="l59.150">   // } ----- end token methods -----</span>
<a href="#l59.151"></a><span id="l59.151"> </span>
<a href="#l59.152"></a><span id="l59.152">   // { ----- begin row methods -----  </span>
<a href="#l59.153"></a><span id="l59.153">   NS_IMETHOD HasRow( // contains a row with the specified oid?</span>
<a href="#l59.154"></a><span id="l59.154">     nsIMdbEnv* ev, // context</span>
<a href="#l59.155"></a><span id="l59.155">     const mdbOid* inOid,  // hypothetical row oid</span>
<a href="#l59.156"></a><span id="l59.156" class="difflineminus">-    mdb_bool* outHasRow); // whether GetRow() might succeed</span>
<a href="#l59.157"></a><span id="l59.157" class="difflineplus">+    mdb_bool* outHasRow) override; // whether GetRow() might succeed</span>
<a href="#l59.158"></a><span id="l59.158"> </span>
<a href="#l59.159"></a><span id="l59.159">   NS_IMETHOD GetRowRefCount( // get number of tables that contain a row </span>
<a href="#l59.160"></a><span id="l59.160">     nsIMdbEnv* ev, // context</span>
<a href="#l59.161"></a><span id="l59.161">     const mdbOid* inOid,  // hypothetical row oid</span>
<a href="#l59.162"></a><span id="l59.162" class="difflineminus">-    mdb_count* outRefCount); // number of tables containing inRowKey </span>
<a href="#l59.163"></a><span id="l59.163" class="difflineplus">+    mdb_count* outRefCount) override; // number of tables containing inRowKey </span>
<a href="#l59.164"></a><span id="l59.164">     </span>
<a href="#l59.165"></a><span id="l59.165">   NS_IMETHOD GetRow( // access one row with specific oid</span>
<a href="#l59.166"></a><span id="l59.166">     nsIMdbEnv* ev, // context</span>
<a href="#l59.167"></a><span id="l59.167">     const mdbOid* inOid,  // hypothetical row oid</span>
<a href="#l59.168"></a><span id="l59.168" class="difflineminus">-    nsIMdbRow** acqRow); // acquire specific row (or null)</span>
<a href="#l59.169"></a><span id="l59.169" class="difflineplus">+    nsIMdbRow** acqRow) override; // acquire specific row (or null)</span>
<a href="#l59.170"></a><span id="l59.170"> </span>
<a href="#l59.171"></a><span id="l59.171">   NS_IMETHOD FindRow(nsIMdbEnv* ev, // search for row with matching cell</span>
<a href="#l59.172"></a><span id="l59.172">     mdb_scope inRowScope,   // row scope for row ids</span>
<a href="#l59.173"></a><span id="l59.173">     mdb_column inColumn,   // the column to search (and maintain an index)</span>
<a href="#l59.174"></a><span id="l59.174">     const mdbYarn* inTargetCellValue, // cell value for which to search</span>
<a href="#l59.175"></a><span id="l59.175">     mdbOid* outRowOid, // out row oid on match (or {0,-1} for no match)</span>
<a href="#l59.176"></a><span id="l59.176" class="difflineminus">-    nsIMdbRow** acqRow); // acquire matching row (or nil for no match)</span>
<a href="#l59.177"></a><span id="l59.177" class="difflineplus">+    nsIMdbRow** acqRow) override; // acquire matching row (or nil for no match)</span>
<a href="#l59.178"></a><span id="l59.178">                          // can be null if you only want the oid</span>
<a href="#l59.179"></a><span id="l59.179">   // FindRow() searches for one row that has a cell in column inColumn with</span>
<a href="#l59.180"></a><span id="l59.180">   // a contained value with the same form (i.e. charset) and is byte-wise</span>
<a href="#l59.181"></a><span id="l59.181">   // identical to the blob described by yarn inTargetCellValue.  Both content</span>
<a href="#l59.182"></a><span id="l59.182">   // and form of the yarn must be an exact match to find a matching row.</span>
<a href="#l59.183"></a><span id="l59.183">   //</span>
<a href="#l59.184"></a><span id="l59.184">   // (In other words, both a yarn's blob bytes and form are significant.  The</span>
<a href="#l59.185"></a><span id="l59.185">   // form is not expected to vary in columns used for identity anyway.  This</span>
<a href="#l59.186"></a><span id="l59.186" class="difflineat">@@ -258,54 +266,54 @@ public: // other port methods</span>
<a href="#l59.187"></a><span id="l59.187">   // of a given key need be remembered.  Implementors are not required to sort</span>
<a href="#l59.188"></a><span id="l59.188">   // all rows by the specified column.</span>
<a href="#l59.189"></a><span id="l59.189">   // } ----- end row methods -----</span>
<a href="#l59.190"></a><span id="l59.190"> </span>
<a href="#l59.191"></a><span id="l59.191">   // { ----- begin table methods -----  </span>
<a href="#l59.192"></a><span id="l59.192">   NS_IMETHOD HasTable( // supports a table with the specified oid?</span>
<a href="#l59.193"></a><span id="l59.193">     nsIMdbEnv* ev, // context</span>
<a href="#l59.194"></a><span id="l59.194">     const mdbOid* inOid,  // hypothetical table oid</span>
<a href="#l59.195"></a><span id="l59.195" class="difflineminus">-    mdb_bool* outHasTable); // whether GetTable() might succeed</span>
<a href="#l59.196"></a><span id="l59.196" class="difflineplus">+    mdb_bool* outHasTable) override; // whether GetTable() might succeed</span>
<a href="#l59.197"></a><span id="l59.197">     </span>
<a href="#l59.198"></a><span id="l59.198">   NS_IMETHOD GetTable( // access one table with specific oid</span>
<a href="#l59.199"></a><span id="l59.199">     nsIMdbEnv* ev, // context</span>
<a href="#l59.200"></a><span id="l59.200">     const mdbOid* inOid,  // hypothetical table oid</span>
<a href="#l59.201"></a><span id="l59.201" class="difflineminus">-    nsIMdbTable** acqTable); // acquire specific table (or null)</span>
<a href="#l59.202"></a><span id="l59.202" class="difflineplus">+    nsIMdbTable** acqTable) override; // acquire specific table (or null)</span>
<a href="#l59.203"></a><span id="l59.203">   </span>
<a href="#l59.204"></a><span id="l59.204">   NS_IMETHOD HasTableKind( // supports a table of the specified type?</span>
<a href="#l59.205"></a><span id="l59.205">     nsIMdbEnv* ev, // context</span>
<a href="#l59.206"></a><span id="l59.206">     mdb_scope inRowScope, // rid scope for row ids</span>
<a href="#l59.207"></a><span id="l59.207">     mdb_kind inTableKind, // the type of table to access</span>
<a href="#l59.208"></a><span id="l59.208">     mdb_count* outTableCount, // current number of such tables</span>
<a href="#l59.209"></a><span id="l59.209" class="difflineminus">-    mdb_bool* outSupportsTable); // whether GetTableKind() might succeed</span>
<a href="#l59.210"></a><span id="l59.210" class="difflineplus">+    mdb_bool* outSupportsTable) override; // whether GetTableKind() might succeed</span>
<a href="#l59.211"></a><span id="l59.211">         </span>
<a href="#l59.212"></a><span id="l59.212">   NS_IMETHOD GetTableKind( // access one (random) table of specific type</span>
<a href="#l59.213"></a><span id="l59.213">     nsIMdbEnv* ev, // context</span>
<a href="#l59.214"></a><span id="l59.214">     mdb_scope inRowScope,      // row scope for row ids</span>
<a href="#l59.215"></a><span id="l59.215">     mdb_kind inTableKind,      // the type of table to access</span>
<a href="#l59.216"></a><span id="l59.216">     mdb_count* outTableCount, // current number of such tables</span>
<a href="#l59.217"></a><span id="l59.217">     mdb_bool* outMustBeUnique, // whether port can hold only one of these</span>
<a href="#l59.218"></a><span id="l59.218" class="difflineminus">-    nsIMdbTable** acqTable);       // acquire scoped collection of rows</span>
<a href="#l59.219"></a><span id="l59.219" class="difflineplus">+    nsIMdbTable** acqTable) override; // acquire scoped collection of rows</span>
<a href="#l59.220"></a><span id="l59.220">     </span>
<a href="#l59.221"></a><span id="l59.221">   NS_IMETHOD</span>
<a href="#l59.222"></a><span id="l59.222">   GetPortTableCursor( // get cursor for all tables of specific type</span>
<a href="#l59.223"></a><span id="l59.223">     nsIMdbEnv* ev, // context</span>
<a href="#l59.224"></a><span id="l59.224">     mdb_scope inRowScope, // row scope for row ids</span>
<a href="#l59.225"></a><span id="l59.225">     mdb_kind inTableKind, // the type of table to access</span>
<a href="#l59.226"></a><span id="l59.226" class="difflineminus">-    nsIMdbPortTableCursor** acqCursor); // all such tables in the port</span>
<a href="#l59.227"></a><span id="l59.227" class="difflineplus">+    nsIMdbPortTableCursor** acqCursor) override; // all such tables in the port</span>
<a href="#l59.228"></a><span id="l59.228">   // } ----- end table methods -----</span>
<a href="#l59.229"></a><span id="l59.229"> </span>
<a href="#l59.230"></a><span id="l59.230"> </span>
<a href="#l59.231"></a><span id="l59.231">   // { ----- begin commit methods -----</span>
<a href="#l59.232"></a><span id="l59.232"> </span>
<a href="#l59.233"></a><span id="l59.233">   NS_IMETHOD ShouldCompress( // store wastes at least inPercentWaste?</span>
<a href="#l59.234"></a><span id="l59.234">     nsIMdbEnv* ev, // context</span>
<a href="#l59.235"></a><span id="l59.235">     mdb_percent inPercentWaste, // 0..100 percent file size waste threshold</span>
<a href="#l59.236"></a><span id="l59.236">     mdb_percent* outActualWaste, // 0..100 percent of file actually wasted</span>
<a href="#l59.237"></a><span id="l59.237" class="difflineminus">-    mdb_bool* outShould); // true when about inPercentWaste% is wasted</span>
<a href="#l59.238"></a><span id="l59.238" class="difflineplus">+    mdb_bool* outShould) override; // true when about inPercentWaste% is wasted</span>
<a href="#l59.239"></a><span id="l59.239">   // ShouldCompress() returns true if the store can determine that the file</span>
<a href="#l59.240"></a><span id="l59.240">   // will shrink by an estimated percentage of inPercentWaste% (or more) if</span>
<a href="#l59.241"></a><span id="l59.241">   // CompressCommit() is called, because that percentage of the file seems</span>
<a href="#l59.242"></a><span id="l59.242">   // to be recoverable free space.  The granularity is only in terms of </span>
<a href="#l59.243"></a><span id="l59.243">   // percentage points, and any value over 100 is considered equal to 100.</span>
<a href="#l59.244"></a><span id="l59.244">   //</span>
<a href="#l59.245"></a><span id="l59.245">   // If a store only has an approximate idea how much space might be saved</span>
<a href="#l59.246"></a><span id="l59.246">   // during a compress, then a best guess should be made.  For example, the</span>
<a href="#l59.247"></a><span id="l59.247" class="difflineat">@@ -362,108 +370,108 @@ public: // other port methods</span>
<a href="#l59.248"></a><span id="l59.248"> </span>
<a href="#l59.249"></a><span id="l59.249">   // { ----- begin table methods -----</span>
<a href="#l59.250"></a><span id="l59.250">   NS_IMETHOD NewTable( // make one new table of specific type</span>
<a href="#l59.251"></a><span id="l59.251">     nsIMdbEnv* ev, // context</span>
<a href="#l59.252"></a><span id="l59.252">     mdb_scope inRowScope,    // row scope for row ids</span>
<a href="#l59.253"></a><span id="l59.253">     mdb_kind inTableKind,    // the type of table to access</span>
<a href="#l59.254"></a><span id="l59.254">     mdb_bool inMustBeUnique, // whether store can hold only one of these</span>
<a href="#l59.255"></a><span id="l59.255">     const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying</span>
<a href="#l59.256"></a><span id="l59.256" class="difflineminus">-    nsIMdbTable** acqTable);     // acquire scoped collection of rows</span>
<a href="#l59.257"></a><span id="l59.257" class="difflineplus">+    nsIMdbTable** acqTable) override; // acquire scoped collection of rows</span>
<a href="#l59.258"></a><span id="l59.258">     </span>
<a href="#l59.259"></a><span id="l59.259">   NS_IMETHOD NewTableWithOid( // make one new table of specific type</span>
<a href="#l59.260"></a><span id="l59.260">     nsIMdbEnv* ev, // context</span>
<a href="#l59.261"></a><span id="l59.261">     const mdbOid* inOid,   // caller assigned oid</span>
<a href="#l59.262"></a><span id="l59.262">     mdb_kind inTableKind,    // the type of table to access</span>
<a href="#l59.263"></a><span id="l59.263">     mdb_bool inMustBeUnique, // whether store can hold only one of these</span>
<a href="#l59.264"></a><span id="l59.264">     const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying </span>
<a href="#l59.265"></a><span id="l59.265" class="difflineminus">-    nsIMdbTable** acqTable);     // acquire scoped collection of rows</span>
<a href="#l59.266"></a><span id="l59.266" class="difflineplus">+    nsIMdbTable** acqTable) override; // acquire scoped collection of rows</span>
<a href="#l59.267"></a><span id="l59.267">   // } ----- end table methods -----</span>
<a href="#l59.268"></a><span id="l59.268"> </span>
<a href="#l59.269"></a><span id="l59.269">   // { ----- begin row scope methods -----</span>
<a href="#l59.270"></a><span id="l59.270">   NS_IMETHOD RowScopeHasAssignedIds(nsIMdbEnv* ev,</span>
<a href="#l59.271"></a><span id="l59.271">     mdb_scope inRowScope,   // row scope for row ids</span>
<a href="#l59.272"></a><span id="l59.272">     mdb_bool* outCallerAssigned, // nonzero if caller assigned specified</span>
<a href="#l59.273"></a><span id="l59.273" class="difflineminus">-    mdb_bool* outStoreAssigned); // nonzero if store db assigned specified</span>
<a href="#l59.274"></a><span id="l59.274" class="difflineplus">+    mdb_bool* outStoreAssigned) override; // nonzero if store db assigned specified</span>
<a href="#l59.275"></a><span id="l59.275"> </span>
<a href="#l59.276"></a><span id="l59.276">   NS_IMETHOD SetCallerAssignedIds(nsIMdbEnv* ev,</span>
<a href="#l59.277"></a><span id="l59.277">     mdb_scope inRowScope,   // row scope for row ids</span>
<a href="#l59.278"></a><span id="l59.278">     mdb_bool* outCallerAssigned, // nonzero if caller assigned specified</span>
<a href="#l59.279"></a><span id="l59.279" class="difflineminus">-    mdb_bool* outStoreAssigned); // nonzero if store db assigned specified</span>
<a href="#l59.280"></a><span id="l59.280" class="difflineplus">+    mdb_bool* outStoreAssigned) override; // nonzero if store db assigned specified</span>
<a href="#l59.281"></a><span id="l59.281"> </span>
<a href="#l59.282"></a><span id="l59.282">   NS_IMETHOD SetStoreAssignedIds(nsIMdbEnv* ev,</span>
<a href="#l59.283"></a><span id="l59.283">     mdb_scope inRowScope,   // row scope for row ids</span>
<a href="#l59.284"></a><span id="l59.284">     mdb_bool* outCallerAssigned, // nonzero if caller assigned specified</span>
<a href="#l59.285"></a><span id="l59.285" class="difflineminus">-    mdb_bool* outStoreAssigned); // nonzero if store db assigned specified</span>
<a href="#l59.286"></a><span id="l59.286" class="difflineplus">+    mdb_bool* outStoreAssigned) override; // nonzero if store db assigned specified</span>
<a href="#l59.287"></a><span id="l59.287">   // } ----- end row scope methods -----</span>
<a href="#l59.288"></a><span id="l59.288"> </span>
<a href="#l59.289"></a><span id="l59.289">   // { ----- begin row methods -----</span>
<a href="#l59.290"></a><span id="l59.290">   NS_IMETHOD NewRowWithOid(nsIMdbEnv* ev, // new row w/ caller assigned oid</span>
<a href="#l59.291"></a><span id="l59.291">     const mdbOid* inOid,   // caller assigned oid</span>
<a href="#l59.292"></a><span id="l59.292" class="difflineminus">-    nsIMdbRow** acqRow); // create new row</span>
<a href="#l59.293"></a><span id="l59.293" class="difflineplus">+    nsIMdbRow** acqRow) override; // create new row</span>
<a href="#l59.294"></a><span id="l59.294"> </span>
<a href="#l59.295"></a><span id="l59.295">   NS_IMETHOD NewRow(nsIMdbEnv* ev, // new row with db assigned oid</span>
<a href="#l59.296"></a><span id="l59.296">     mdb_scope inRowScope,   // row scope for row ids</span>
<a href="#l59.297"></a><span id="l59.297" class="difflineminus">-    nsIMdbRow** acqRow); // create new row</span>
<a href="#l59.298"></a><span id="l59.298" class="difflineplus">+    nsIMdbRow** acqRow) override; // create new row</span>
<a href="#l59.299"></a><span id="l59.299">   // Note this row must be added to some table or cell child before the</span>
<a href="#l59.300"></a><span id="l59.300">   // store is closed in order to make this row persist across sesssions.</span>
<a href="#l59.301"></a><span id="l59.301"> </span>
<a href="#l59.302"></a><span id="l59.302">   // } ----- end row methods -----</span>
<a href="#l59.303"></a><span id="l59.303"> </span>
<a href="#l59.304"></a><span id="l59.304">   // { ----- begin inport/export methods -----</span>
<a href="#l59.305"></a><span id="l59.305">   NS_IMETHOD ImportContent( // import content from port</span>
<a href="#l59.306"></a><span id="l59.306">     nsIMdbEnv* ev, // context</span>
<a href="#l59.307"></a><span id="l59.307">     mdb_scope inRowScope, // scope for rows (or zero for all?)</span>
<a href="#l59.308"></a><span id="l59.308">     nsIMdbPort* ioPort, // the port with content to add to store</span>
<a href="#l59.309"></a><span id="l59.309" class="difflineminus">-    nsIMdbThumb** acqThumb); // acquire thumb for incremental import</span>
<a href="#l59.310"></a><span id="l59.310" class="difflineplus">+    nsIMdbThumb** acqThumb) override; // acquire thumb for incremental import</span>
<a href="#l59.311"></a><span id="l59.311">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l59.312"></a><span id="l59.312">   // then the import will be finished.</span>
<a href="#l59.313"></a><span id="l59.313"> </span>
<a href="#l59.314"></a><span id="l59.314">   NS_IMETHOD ImportFile( // import content from port</span>
<a href="#l59.315"></a><span id="l59.315">     nsIMdbEnv* ev, // context</span>
<a href="#l59.316"></a><span id="l59.316">     nsIMdbFile* ioFile, // the file with content to add to store</span>
<a href="#l59.317"></a><span id="l59.317" class="difflineminus">-    nsIMdbThumb** acqThumb); // acquire thumb for incremental import</span>
<a href="#l59.318"></a><span id="l59.318" class="difflineplus">+    nsIMdbThumb** acqThumb) override; // acquire thumb for incremental import</span>
<a href="#l59.319"></a><span id="l59.319">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l59.320"></a><span id="l59.320">   // then the import will be finished.</span>
<a href="#l59.321"></a><span id="l59.321">   // } ----- end inport/export methods -----</span>
<a href="#l59.322"></a><span id="l59.322"> </span>
<a href="#l59.323"></a><span id="l59.323">   // { ----- begin hinting methods -----</span>
<a href="#l59.324"></a><span id="l59.324">   NS_IMETHOD</span>
<a href="#l59.325"></a><span id="l59.325">   ShareAtomColumnsHint( // advise re shared column content atomizing</span>
<a href="#l59.326"></a><span id="l59.326">     nsIMdbEnv* ev, // context</span>
<a href="#l59.327"></a><span id="l59.327">     mdb_scope inScopeHint, // zero, or suggested shared namespace</span>
<a href="#l59.328"></a><span id="l59.328" class="difflineminus">-    const mdbColumnSet* inColumnSet); // cols desired tokenized together</span>
<a href="#l59.329"></a><span id="l59.329" class="difflineplus">+    const mdbColumnSet* inColumnSet) override; // cols desired tokenized together</span>
<a href="#l59.330"></a><span id="l59.330"> </span>
<a href="#l59.331"></a><span id="l59.331">   NS_IMETHOD</span>
<a href="#l59.332"></a><span id="l59.332">   AvoidAtomColumnsHint( // advise column with poor atomizing prospects</span>
<a href="#l59.333"></a><span id="l59.333">     nsIMdbEnv* ev, // context</span>
<a href="#l59.334"></a><span id="l59.334" class="difflineminus">-    const mdbColumnSet* inColumnSet); // cols with poor atomizing prospects</span>
<a href="#l59.335"></a><span id="l59.335" class="difflineplus">+    const mdbColumnSet* inColumnSet) override; // cols with poor atomizing prospects</span>
<a href="#l59.336"></a><span id="l59.336">   // } ----- end hinting methods -----</span>
<a href="#l59.337"></a><span id="l59.337"> </span>
<a href="#l59.338"></a><span id="l59.338">   // { ----- begin commit methods -----</span>
<a href="#l59.339"></a><span id="l59.339">   NS_IMETHOD LargeCommit( // save important changes if at all possible</span>
<a href="#l59.340"></a><span id="l59.340">     nsIMdbEnv* ev, // context</span>
<a href="#l59.341"></a><span id="l59.341" class="difflineminus">-    nsIMdbThumb** acqThumb); // acquire thumb for incremental commit</span>
<a href="#l59.342"></a><span id="l59.342" class="difflineplus">+    nsIMdbThumb** acqThumb) override; // acquire thumb for incremental commit</span>
<a href="#l59.343"></a><span id="l59.343">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l59.344"></a><span id="l59.344">   // then the commit will be finished.  Note the store is effectively write</span>
<a href="#l59.345"></a><span id="l59.345">   // locked until commit is finished or canceled through the thumb instance.</span>
<a href="#l59.346"></a><span id="l59.346">   // Until the commit is done, the store will report it has readonly status.</span>
<a href="#l59.347"></a><span id="l59.347"> </span>
<a href="#l59.348"></a><span id="l59.348">   NS_IMETHOD SessionCommit( // save all changes if large commits delayed</span>
<a href="#l59.349"></a><span id="l59.349">     nsIMdbEnv* ev, // context</span>
<a href="#l59.350"></a><span id="l59.350" class="difflineminus">-    nsIMdbThumb** acqThumb); // acquire thumb for incremental commit</span>
<a href="#l59.351"></a><span id="l59.351" class="difflineplus">+    nsIMdbThumb** acqThumb) override; // acquire thumb for incremental commit</span>
<a href="#l59.352"></a><span id="l59.352">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l59.353"></a><span id="l59.353">   // then the commit will be finished.  Note the store is effectively write</span>
<a href="#l59.354"></a><span id="l59.354">   // locked until commit is finished or canceled through the thumb instance.</span>
<a href="#l59.355"></a><span id="l59.355">   // Until the commit is done, the store will report it has readonly status.</span>
<a href="#l59.356"></a><span id="l59.356"> </span>
<a href="#l59.357"></a><span id="l59.357">   NS_IMETHOD</span>
<a href="#l59.358"></a><span id="l59.358">   CompressCommit( // commit and make db physically smaller if possible</span>
<a href="#l59.359"></a><span id="l59.359">     nsIMdbEnv* ev, // context</span>
<a href="#l59.360"></a><span id="l59.360" class="difflineminus">-    nsIMdbThumb** acqThumb); // acquire thumb for incremental commit</span>
<a href="#l59.361"></a><span id="l59.361" class="difflineplus">+    nsIMdbThumb** acqThumb) override; // acquire thumb for incremental commit</span>
<a href="#l59.362"></a><span id="l59.362">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l59.363"></a><span id="l59.363">   // then the commit will be finished.  Note the store is effectively write</span>
<a href="#l59.364"></a><span id="l59.364">   // locked until commit is finished or canceled through the thumb instance.</span>
<a href="#l59.365"></a><span id="l59.365">   // Until the commit is done, the store will report it has readonly status.</span>
<a href="#l59.366"></a><span id="l59.366">   </span>
<a href="#l59.367"></a><span id="l59.367">   // } ----- end commit methods -----</span>
<a href="#l59.368"></a><span id="l59.368"> </span>
<a href="#l59.369"></a><span id="l59.369"> // } ===== end nsIMdbStore methods =====</span>
<a href="#l59.370"></a><span id="l59.370" class="difflineat">@@ -605,17 +613,17 @@ public: // lazy creation of members and </span>
<a href="#l59.371"></a><span id="l59.371"> </span>
<a href="#l59.372"></a><span id="l59.372">   morkStream*      LazyGetOutStream(morkEnv* ev);</span>
<a href="#l59.373"></a><span id="l59.373">   </span>
<a href="#l59.374"></a><span id="l59.374">   morkRowSpace*    LazyGetRowSpace(morkEnv* ev, mdb_scope inRowScope);</span>
<a href="#l59.375"></a><span id="l59.375">   morkAtomSpace*   LazyGetAtomSpace(morkEnv* ev, mdb_scope inAtomScope);</span>
<a href="#l59.376"></a><span id="l59.376">  </span>
<a href="#l59.377"></a><span id="l59.377"> // { ===== begin morkNode interface =====</span>
<a href="#l59.378"></a><span id="l59.378"> public: // morkNode virtual methods</span>
<a href="#l59.379"></a><span id="l59.379" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseStore() only if open</span>
<a href="#l59.380"></a><span id="l59.380" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseStore() only if open</span>
<a href="#l59.381"></a><span id="l59.381">   </span>
<a href="#l59.382"></a><span id="l59.382"> public: // morkStore construction &amp; destruction</span>
<a href="#l59.383"></a><span id="l59.383">   morkStore(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l59.384"></a><span id="l59.384">      nsIMdbHeap* ioNodeHeap, // the heap (if any) for this node instance</span>
<a href="#l59.385"></a><span id="l59.385">      morkFactory* inFactory, // the factory for this</span>
<a href="#l59.386"></a><span id="l59.386">      nsIMdbHeap* ioPortHeap  // the heap to hold all content in the port</span>
<a href="#l59.387"></a><span id="l59.387">      );</span>
<a href="#l59.388"></a><span id="l59.388">   void CloseStore(morkEnv* ev); // called by CloseMorkNode();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l60.1"></a><span id="l60.1" class="difflineminus">--- a/db/mork/src/morkStream.cpp</span>
<a href="#l60.2"></a><span id="l60.2" class="difflineplus">+++ b/db/mork/src/morkStream.cpp</span>
<a href="#l60.3"></a><span id="l60.3" class="difflineat">@@ -114,36 +114,31 @@ morkStream::morkStream(morkEnv* ev, cons</span>
<a href="#l60.4"></a><span id="l60.4">     }</span>
<a href="#l60.5"></a><span id="l60.5">     else ev-&gt;NilPointerError();</span>
<a href="#l60.6"></a><span id="l60.6">   }</span>
<a href="#l60.7"></a><span id="l60.7"> }</span>
<a href="#l60.8"></a><span id="l60.8"> </span>
<a href="#l60.9"></a><span id="l60.9"> /*public non-poly*/ void</span>
<a href="#l60.10"></a><span id="l60.10"> morkStream::CloseStream(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l60.11"></a><span id="l60.11"> {</span>
<a href="#l60.12"></a><span id="l60.12" class="difflineminus">-  if ( this )</span>
<a href="#l60.13"></a><span id="l60.13" class="difflineminus">-  {</span>
<a href="#l60.14"></a><span id="l60.14">     if ( this-&gt;IsNode() )</span>
<a href="#l60.15"></a><span id="l60.15">     {</span>
<a href="#l60.16"></a><span id="l60.16">       nsIMdbFile_SlotStrongFile((nsIMdbFile*) 0, ev, &amp;mStream_ContentFile);</span>
<a href="#l60.17"></a><span id="l60.17">       nsIMdbHeap* heap = mFile_SlotHeap;</span>
<a href="#l60.18"></a><span id="l60.18">       mork_u1* buf = mStream_Buf;</span>
<a href="#l60.19"></a><span id="l60.19">       mStream_Buf = 0;</span>
<a href="#l60.20"></a><span id="l60.20">       </span>
<a href="#l60.21"></a><span id="l60.21">       if ( heap &amp;&amp; buf )</span>
<a href="#l60.22"></a><span id="l60.22">         heap-&gt;Free(ev-&gt;AsMdbEnv(), buf);</span>
<a href="#l60.23"></a><span id="l60.23"> </span>
<a href="#l60.24"></a><span id="l60.24">       this-&gt;CloseFile(ev);</span>
<a href="#l60.25"></a><span id="l60.25">       this-&gt;MarkShut();</span>
<a href="#l60.26"></a><span id="l60.26">     }</span>
<a href="#l60.27"></a><span id="l60.27">     else</span>
<a href="#l60.28"></a><span id="l60.28">       this-&gt;NonNodeError(ev);</span>
<a href="#l60.29"></a><span id="l60.29" class="difflineminus">-  }</span>
<a href="#l60.30"></a><span id="l60.30" class="difflineminus">-  else</span>
<a href="#l60.31"></a><span id="l60.31" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l60.32"></a><span id="l60.32"> }</span>
<a href="#l60.33"></a><span id="l60.33"> </span>
<a href="#l60.34"></a><span id="l60.34"> // } ===== end morkNode methods =====</span>
<a href="#l60.35"></a><span id="l60.35"> // ````` ````` ````` ````` ````` </span>
<a href="#l60.36"></a><span id="l60.36">   </span>
<a href="#l60.37"></a><span id="l60.37"> #define morkStream_kSpacesPerIndent 1 /* one space per indent */</span>
<a href="#l60.38"></a><span id="l60.38"> #define morkStream_kMaxIndentDepth 70 /* max indent of 70 space bytes */</span>
<a href="#l60.39"></a><span id="l60.39"> static const char morkStream_kSpaces[] // next line to ease length perception</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l61.1"></a><span id="l61.1" class="difflineminus">--- a/db/mork/src/morkStream.h</span>
<a href="#l61.2"></a><span id="l61.2" class="difflineplus">+++ b/db/mork/src/morkStream.h</span>
<a href="#l61.3"></a><span id="l61.3" class="difflineat">@@ -107,17 +107,17 @@ protected: // protected morkStream membe</span>
<a href="#l61.4"></a><span id="l61.4">   mork_u1*    mStream_Buf;      // dynamically allocated memory to buffer io</span>
<a href="#l61.5"></a><span id="l61.5">   mork_size   mStream_BufSize;  // requested buf size (fixed by min and max)</span>
<a href="#l61.6"></a><span id="l61.6">   mork_pos    mStream_BufPos;   // logical position of byte at mStream_Buf</span>
<a href="#l61.7"></a><span id="l61.7">   mork_bool   mStream_Dirty;    // does the buffer need to be flushed?</span>
<a href="#l61.8"></a><span id="l61.8">   mork_bool   mStream_HitEof;   // has eof been reached? (only frozen streams)</span>
<a href="#l61.9"></a><span id="l61.9">   </span>
<a href="#l61.10"></a><span id="l61.10"> // { ===== begin morkNode interface =====</span>
<a href="#l61.11"></a><span id="l61.11"> public: // morkNode virtual methods</span>
<a href="#l61.12"></a><span id="l61.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseStream() only if open</span>
<a href="#l61.13"></a><span id="l61.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseStream() only if open</span>
<a href="#l61.14"></a><span id="l61.14">   virtual ~morkStream(); // assert that CloseStream() executed earlier</span>
<a href="#l61.15"></a><span id="l61.15">   </span>
<a href="#l61.16"></a><span id="l61.16"> public: // morkStream construction &amp; destruction</span>
<a href="#l61.17"></a><span id="l61.17">   morkStream(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l61.18"></a><span id="l61.18">       nsIMdbFile* ioContentFile, mork_size inBufSize, mork_bool inFrozen);</span>
<a href="#l61.19"></a><span id="l61.19">   void CloseStream(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l61.20"></a><span id="l61.20"> </span>
<a href="#l61.21"></a><span id="l61.21"> private: // copying is not allowed</span>
<a href="#l61.22"></a><span id="l61.22" class="difflineat">@@ -130,54 +130,54 @@ public: // dynamic type identification</span>
<a href="#l61.23"></a><span id="l61.23"> // } ===== end morkNode methods =====</span>
<a href="#l61.24"></a><span id="l61.24"> </span>
<a href="#l61.25"></a><span id="l61.25"> public: // typing</span>
<a href="#l61.26"></a><span id="l61.26">   void NonStreamTypeError(morkEnv* ev);</span>
<a href="#l61.27"></a><span id="l61.27"> </span>
<a href="#l61.28"></a><span id="l61.28"> // ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l61.29"></a><span id="l61.29"> public: // virtual morkFile methods</span>
<a href="#l61.30"></a><span id="l61.30"> </span>
<a href="#l61.31"></a><span id="l61.31" class="difflineminus">-  NS_IMETHOD Steal(nsIMdbEnv* ev, nsIMdbFile* ioThief);</span>
<a href="#l61.32"></a><span id="l61.32" class="difflineplus">+  NS_IMETHOD Steal(nsIMdbEnv* ev, nsIMdbFile* ioThief) override;</span>
<a href="#l61.33"></a><span id="l61.33">   // Steal: tell this file to close any associated i/o stream in the file</span>
<a href="#l61.34"></a><span id="l61.34">   // system, because the file ioThief intends to reopen the file in order</span>
<a href="#l61.35"></a><span id="l61.35">   // to provide the MDB implementation with more exotic file access than is</span>
<a href="#l61.36"></a><span id="l61.36">   // offered by the nsIMdbFile alone.  Presumably the thief knows enough</span>
<a href="#l61.37"></a><span id="l61.37">   // from Path() in order to know which file to reopen.  If Steal() is</span>
<a href="#l61.38"></a><span id="l61.38">   // successful, this file should probably delegate all future calls to</span>
<a href="#l61.39"></a><span id="l61.39">   // the nsIMdbFile interface down to the thief files, so that even after</span>
<a href="#l61.40"></a><span id="l61.40">   // the file has been stolen, it can still be read, written, or forcibly</span>
<a href="#l61.41"></a><span id="l61.41">   // closed (by a call to CloseMdbObject()).</span>
<a href="#l61.42"></a><span id="l61.42"> </span>
<a href="#l61.43"></a><span id="l61.43" class="difflineminus">-  NS_IMETHOD BecomeTrunk(nsIMdbEnv* ev);</span>
<a href="#l61.44"></a><span id="l61.44" class="difflineplus">+  NS_IMETHOD BecomeTrunk(nsIMdbEnv* ev) override;</span>
<a href="#l61.45"></a><span id="l61.45">   // If this file is a file version branch created by calling AcquireBud(),</span>
<a href="#l61.46"></a><span id="l61.46">   // BecomeTrunk() causes this file's content to replace the original</span>
<a href="#l61.47"></a><span id="l61.47">   // file's content, typically by assuming the original file's identity.</span>
<a href="#l61.48"></a><span id="l61.48"> </span>
<a href="#l61.49"></a><span id="l61.49" class="difflineminus">-  NS_IMETHOD AcquireBud(nsIMdbEnv* ev, nsIMdbHeap* ioHeap, nsIMdbFile** acqBud);</span>
<a href="#l61.50"></a><span id="l61.50" class="difflineplus">+  NS_IMETHOD AcquireBud(nsIMdbEnv* ev, nsIMdbHeap* ioHeap, nsIMdbFile** acqBud) override;</span>
<a href="#l61.51"></a><span id="l61.51">   // AcquireBud() starts a new &quot;branch&quot; version of the file, empty of content,</span>
<a href="#l61.52"></a><span id="l61.52">   // so that a new version of the file can be written.  This new file</span>
<a href="#l61.53"></a><span id="l61.53">   // can later be told to BecomeTrunk() the original file, so the branch</span>
<a href="#l61.54"></a><span id="l61.54">   // created by budding the file will replace the original file.  Some</span>
<a href="#l61.55"></a><span id="l61.55">   // file subclasses might initially take the unsafe but expedient</span>
<a href="#l61.56"></a><span id="l61.56">   // approach of simply truncating this file down to zero length, and</span>
<a href="#l61.57"></a><span id="l61.57">   // then returning the same morkFile pointer as this, with an extra</span>
<a href="#l61.58"></a><span id="l61.58">   // reference count increment.  Note that the caller of AcquireBud() is</span>
<a href="#l61.59"></a><span id="l61.59">   // expected to eventually call CutStrongRef() on the returned file</span>
<a href="#l61.60"></a><span id="l61.60">   // in order to release the strong reference.  High quality versions</span>
<a href="#l61.61"></a><span id="l61.61">   // of morkFile subclasses will create entirely new files which later</span>
<a href="#l61.62"></a><span id="l61.62">   // are renamed to become the old file, so that better transactional</span>
<a href="#l61.63"></a><span id="l61.63">   // behavior is exhibited by the file, so crashes protect old files.</span>
<a href="#l61.64"></a><span id="l61.64">   // Note that AcquireBud() is an illegal operation on readonly files.</span>
<a href="#l61.65"></a><span id="l61.65" class="difflineminus">-  </span>
<a href="#l61.66"></a><span id="l61.66" class="difflineminus">-  virtual mork_pos Length(morkEnv* ev) const; // eof</span>
<a href="#l61.67"></a><span id="l61.67" class="difflineminus">-  NS_IMETHOD  Tell(nsIMdbEnv* ev, mork_pos *aOutPos  ) const;</span>
<a href="#l61.68"></a><span id="l61.68" class="difflineminus">-  NS_IMETHOD  Read(nsIMdbEnv* ev, void* outBuf, mork_size inSize, mork_size *aOutCount);</span>
<a href="#l61.69"></a><span id="l61.69" class="difflineminus">-  NS_IMETHOD  Seek(nsIMdbEnv* ev, mork_pos inPos, mork_pos *aOutPos);</span>
<a href="#l61.70"></a><span id="l61.70" class="difflineminus">-  NS_IMETHOD  Write(nsIMdbEnv* ev, const void* inBuf, mork_size inSize, mork_size *aOutCount);</span>
<a href="#l61.71"></a><span id="l61.71" class="difflineminus">-  NS_IMETHOD  Flush(nsIMdbEnv* ev);</span>
<a href="#l61.72"></a><span id="l61.72" class="difflineplus">+</span>
<a href="#l61.73"></a><span id="l61.73" class="difflineplus">+  virtual mork_pos Length(morkEnv* ev) const override; // eof</span>
<a href="#l61.74"></a><span id="l61.74" class="difflineplus">+  NS_IMETHOD  Tell(nsIMdbEnv* ev, mork_pos *aOutPos  ) const override;</span>
<a href="#l61.75"></a><span id="l61.75" class="difflineplus">+  NS_IMETHOD  Read(nsIMdbEnv* ev, void* outBuf, mork_size inSize, mork_size *aOutCount) override;</span>
<a href="#l61.76"></a><span id="l61.76" class="difflineplus">+  NS_IMETHOD  Seek(nsIMdbEnv* ev, mork_pos inPos, mork_pos *aOutPos) override;</span>
<a href="#l61.77"></a><span id="l61.77" class="difflineplus">+  NS_IMETHOD  Write(nsIMdbEnv* ev, const void* inBuf, mork_size inSize, mork_size *aOutCount) override;</span>
<a href="#l61.78"></a><span id="l61.78" class="difflineplus">+  NS_IMETHOD  Flush(nsIMdbEnv* ev) override;</span>
<a href="#l61.79"></a><span id="l61.79">     </span>
<a href="#l61.80"></a><span id="l61.80"> // ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l61.81"></a><span id="l61.81"> protected: // protected non-poly morkStream methods (for char io)</span>
<a href="#l61.82"></a><span id="l61.82"> </span>
<a href="#l61.83"></a><span id="l61.83">   int     fill_getc(morkEnv* ev);</span>
<a href="#l61.84"></a><span id="l61.84">   void    spill_putc(morkEnv* ev, int c);</span>
<a href="#l61.85"></a><span id="l61.85">   void    spill_buf(morkEnv* ev); // spill/flush from buffer to file</span>
<a href="#l61.86"></a><span id="l61.86">       </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l62.1"></a><span id="l62.1" class="difflineminus">--- a/db/mork/src/morkTable.cpp</span>
<a href="#l62.2"></a><span id="l62.2" class="difflineplus">+++ b/db/mork/src/morkTable.cpp</span>
<a href="#l62.3"></a><span id="l62.3" class="difflineat">@@ -142,32 +142,27 @@ morkTable::morkTable(morkEnv* ev, /*i*/</span>
<a href="#l62.4"></a><span id="l62.4">   }</span>
<a href="#l62.5"></a><span id="l62.5"> }</span>
<a href="#l62.6"></a><span id="l62.6"> </span>
<a href="#l62.7"></a><span id="l62.7"> NS_IMPL_ISUPPORTS_INHERITED(morkTable, morkObject, nsIMdbTable)</span>
<a href="#l62.8"></a><span id="l62.8"> </span>
<a href="#l62.9"></a><span id="l62.9"> /*public non-poly*/ void</span>
<a href="#l62.10"></a><span id="l62.10"> morkTable::CloseTable(morkEnv* ev) /*i*/ // called by CloseMorkNode();</span>
<a href="#l62.11"></a><span id="l62.11"> {</span>
<a href="#l62.12"></a><span id="l62.12" class="difflineminus">-  if ( this )</span>
<a href="#l62.13"></a><span id="l62.13" class="difflineminus">-  {</span>
<a href="#l62.14"></a><span id="l62.14">     if ( this-&gt;IsNode() )</span>
<a href="#l62.15"></a><span id="l62.15">     {</span>
<a href="#l62.16"></a><span id="l62.16">       morkRowMap::SlotStrongRowMap((morkRowMap*) 0, ev, &amp;mTable_RowMap);</span>
<a href="#l62.17"></a><span id="l62.17">       // mTable_RowMap.CloseMorkNode(ev);</span>
<a href="#l62.18"></a><span id="l62.18">       mTable_RowArray.CloseMorkNode(ev);</span>
<a href="#l62.19"></a><span id="l62.19">       mTable_Store = 0;</span>
<a href="#l62.20"></a><span id="l62.20">       mTable_RowSpace = 0;</span>
<a href="#l62.21"></a><span id="l62.21">       this-&gt;MarkShut();</span>
<a href="#l62.22"></a><span id="l62.22">     }</span>
<a href="#l62.23"></a><span id="l62.23">     else</span>
<a href="#l62.24"></a><span id="l62.24">       this-&gt;NonNodeError(ev);</span>
<a href="#l62.25"></a><span id="l62.25" class="difflineminus">-  }</span>
<a href="#l62.26"></a><span id="l62.26" class="difflineminus">-  else</span>
<a href="#l62.27"></a><span id="l62.27" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l62.28"></a><span id="l62.28"> }</span>
<a href="#l62.29"></a><span id="l62.29"> </span>
<a href="#l62.30"></a><span id="l62.30"> </span>
<a href="#l62.31"></a><span id="l62.31"> // } ===== end morkNode methods =====</span>
<a href="#l62.32"></a><span id="l62.32"> // ````` ````` ````` ````` ````` </span>
<a href="#l62.33"></a><span id="l62.33"> </span>
<a href="#l62.34"></a><span id="l62.34"> // { ===== begin nsIMdbCollection methods =====</span>
<a href="#l62.35"></a><span id="l62.35"> </span>
<a href="#l62.36"></a><span id="l62.36" class="difflineat">@@ -944,22 +939,38 @@ morkTable::DisableIndexOnSort( // preven</span>
<a href="#l62.37"></a><span id="l62.37">   NS_ASSERTION(false, &quot;not implemented&quot;);</span>
<a href="#l62.38"></a><span id="l62.38">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l62.39"></a><span id="l62.39"> }</span>
<a href="#l62.40"></a><span id="l62.40"> // } ----- end index methods -----</span>
<a href="#l62.41"></a><span id="l62.41"> </span>
<a href="#l62.42"></a><span id="l62.42"> // } ===== end nsIMdbTable methods =====</span>
<a href="#l62.43"></a><span id="l62.43"> </span>
<a href="#l62.44"></a><span id="l62.44"> // we override these so that we'll use the xpcom add and release ref.</span>
<a href="#l62.45"></a><span id="l62.45" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l62.46"></a><span id="l62.46" class="difflineplus">+mork_refs</span>
<a href="#l62.47"></a><span id="l62.47" class="difflineplus">+morkTable::AddStrongRef(nsIMdbEnv *ev)</span>
<a href="#l62.48"></a><span id="l62.48" class="difflineplus">+{</span>
<a href="#l62.49"></a><span id="l62.49" class="difflineplus">+  return (mork_refs) AddRef();</span>
<a href="#l62.50"></a><span id="l62.50" class="difflineplus">+}</span>
<a href="#l62.51"></a><span id="l62.51" class="difflineplus">+#endif</span>
<a href="#l62.52"></a><span id="l62.52" class="difflineplus">+</span>
<a href="#l62.53"></a><span id="l62.53"> mork_refs</span>
<a href="#l62.54"></a><span id="l62.54"> morkTable::AddStrongRef(morkEnv *ev)</span>
<a href="#l62.55"></a><span id="l62.55"> {</span>
<a href="#l62.56"></a><span id="l62.56">   return (mork_refs) AddRef();</span>
<a href="#l62.57"></a><span id="l62.57"> }</span>
<a href="#l62.58"></a><span id="l62.58"> </span>
<a href="#l62.59"></a><span id="l62.59" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l62.60"></a><span id="l62.60" class="difflineplus">+nsresult</span>
<a href="#l62.61"></a><span id="l62.61" class="difflineplus">+morkTable::CutStrongRef(nsIMdbEnv *ev)</span>
<a href="#l62.62"></a><span id="l62.62" class="difflineplus">+{</span>
<a href="#l62.63"></a><span id="l62.63" class="difflineplus">+  return (nsresult) Release();</span>
<a href="#l62.64"></a><span id="l62.64" class="difflineplus">+}</span>
<a href="#l62.65"></a><span id="l62.65" class="difflineplus">+#endif</span>
<a href="#l62.66"></a><span id="l62.66" class="difflineplus">+</span>
<a href="#l62.67"></a><span id="l62.67"> mork_refs</span>
<a href="#l62.68"></a><span id="l62.68"> morkTable::CutStrongRef(morkEnv *ev)</span>
<a href="#l62.69"></a><span id="l62.69"> {</span>
<a href="#l62.70"></a><span id="l62.70">   return (mork_refs) Release();</span>
<a href="#l62.71"></a><span id="l62.71"> }</span>
<a href="#l62.72"></a><span id="l62.72"> </span>
<a href="#l62.73"></a><span id="l62.73"> mork_u2</span>
<a href="#l62.74"></a><span id="l62.74"> morkTable::AddTableGcUse(morkEnv* ev)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l63.1"></a><span id="l63.1" class="difflineminus">--- a/db/mork/src/morkTable.h</span>
<a href="#l63.2"></a><span id="l63.2" class="difflineplus">+++ b/db/mork/src/morkTable.h</span>
<a href="#l63.3"></a><span id="l63.3" class="difflineat">@@ -97,68 +97,76 @@ class morkTable : public morkObject, pub</span>
<a href="#l63.4"></a><span id="l63.4"> </span>
<a href="#l63.5"></a><span id="l63.5"> public: // bead color setter &amp; getter replace obsolete member mTable_Id:</span>
<a href="#l63.6"></a><span id="l63.6"> </span>
<a href="#l63.7"></a><span id="l63.7">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l63.8"></a><span id="l63.8">   mork_tid     TableId() const { return mBead_Color; }</span>
<a href="#l63.9"></a><span id="l63.9">   void         SetTableId(mork_tid inTid) { mBead_Color = inTid; }</span>
<a href="#l63.10"></a><span id="l63.10"> </span>
<a href="#l63.11"></a><span id="l63.11">   // we override these so we use xpcom ref-counting semantics.</span>
<a href="#l63.12"></a><span id="l63.12" class="difflineminus">-  virtual mork_refs    AddStrongRef(morkEnv* ev);</span>
<a href="#l63.13"></a><span id="l63.13" class="difflineminus">-  virtual mork_refs    CutStrongRef(morkEnv* ev);</span>
<a href="#l63.14"></a><span id="l63.14" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l63.15"></a><span id="l63.15" class="difflineplus">+  // The first declaration of AddStrongRef is to suppress -Werror,-Woverloaded-virtual.</span>
<a href="#l63.16"></a><span id="l63.16" class="difflineplus">+  virtual mork_refs    AddStrongRef(nsIMdbEnv* ev) override;</span>
<a href="#l63.17"></a><span id="l63.17" class="difflineplus">+#endif</span>
<a href="#l63.18"></a><span id="l63.18" class="difflineplus">+  virtual mork_refs    AddStrongRef(morkEnv* ev) override;</span>
<a href="#l63.19"></a><span id="l63.19" class="difflineplus">+#ifndef _MSC_VER</span>
<a href="#l63.20"></a><span id="l63.20" class="difflineplus">+  // The first declaration of CutStrongRef is to suppress -Werror,-Woverloaded-virtual.</span>
<a href="#l63.21"></a><span id="l63.21" class="difflineplus">+  virtual nsresult     CutStrongRef(nsIMdbEnv* ev) override;</span>
<a href="#l63.22"></a><span id="l63.22" class="difflineplus">+#endif</span>
<a href="#l63.23"></a><span id="l63.23" class="difflineplus">+  virtual mork_refs    CutStrongRef(morkEnv* ev) override;</span>
<a href="#l63.24"></a><span id="l63.24"> public: // state is public because the entire Mork system is private</span>
<a href="#l63.25"></a><span id="l63.25"> </span>
<a href="#l63.26"></a><span id="l63.26"> // { ===== begin nsIMdbCollection methods =====</span>
<a href="#l63.27"></a><span id="l63.27"> </span>
<a href="#l63.28"></a><span id="l63.28">   // { ----- begin attribute methods -----</span>
<a href="#l63.29"></a><span id="l63.29">   NS_IMETHOD GetSeed(nsIMdbEnv* ev,</span>
<a href="#l63.30"></a><span id="l63.30" class="difflineminus">-    mdb_seed* outSeed);    // member change count</span>
<a href="#l63.31"></a><span id="l63.31" class="difflineplus">+    mdb_seed* outSeed) override;    // member change count</span>
<a href="#l63.32"></a><span id="l63.32">   NS_IMETHOD GetCount(nsIMdbEnv* ev,</span>
<a href="#l63.33"></a><span id="l63.33" class="difflineminus">-    mdb_count* outCount); // member count</span>
<a href="#l63.34"></a><span id="l63.34" class="difflineplus">+    mdb_count* outCount) override; // member count</span>
<a href="#l63.35"></a><span id="l63.35"> </span>
<a href="#l63.36"></a><span id="l63.36">   NS_IMETHOD GetPort(nsIMdbEnv* ev,</span>
<a href="#l63.37"></a><span id="l63.37" class="difflineminus">-    nsIMdbPort** acqPort); // collection container</span>
<a href="#l63.38"></a><span id="l63.38" class="difflineplus">+    nsIMdbPort** acqPort) override; // collection container</span>
<a href="#l63.39"></a><span id="l63.39">   // } ----- end attribute methods -----</span>
<a href="#l63.40"></a><span id="l63.40"> </span>
<a href="#l63.41"></a><span id="l63.41">   // { ----- begin cursor methods -----</span>
<a href="#l63.42"></a><span id="l63.42">   NS_IMETHOD GetCursor( // make a cursor starting iter at inMemberPos</span>
<a href="#l63.43"></a><span id="l63.43">     nsIMdbEnv* ev, // context</span>
<a href="#l63.44"></a><span id="l63.44">     mdb_pos inMemberPos, // zero-based ordinal pos of member in collection</span>
<a href="#l63.45"></a><span id="l63.45" class="difflineminus">-    nsIMdbCursor** acqCursor); // acquire new cursor instance</span>
<a href="#l63.46"></a><span id="l63.46" class="difflineplus">+    nsIMdbCursor** acqCursor) override; // acquire new cursor instance</span>
<a href="#l63.47"></a><span id="l63.47">   // } ----- end cursor methods -----</span>
<a href="#l63.48"></a><span id="l63.48"> </span>
<a href="#l63.49"></a><span id="l63.49">   // { ----- begin ID methods -----</span>
<a href="#l63.50"></a><span id="l63.50">   NS_IMETHOD GetOid(nsIMdbEnv* ev,</span>
<a href="#l63.51"></a><span id="l63.51" class="difflineminus">-    mdbOid* outOid); // read object identity</span>
<a href="#l63.52"></a><span id="l63.52" class="difflineplus">+    mdbOid* outOid) override; // read object identity</span>
<a href="#l63.53"></a><span id="l63.53">   NS_IMETHOD BecomeContent(nsIMdbEnv* ev,</span>
<a href="#l63.54"></a><span id="l63.54" class="difflineminus">-    const mdbOid* inOid); // exchange content</span>
<a href="#l63.55"></a><span id="l63.55" class="difflineplus">+    const mdbOid* inOid) override; // exchange content</span>
<a href="#l63.56"></a><span id="l63.56">   // } ----- end ID methods -----</span>
<a href="#l63.57"></a><span id="l63.57"> </span>
<a href="#l63.58"></a><span id="l63.58">   // { ----- begin activity dropping methods -----</span>
<a href="#l63.59"></a><span id="l63.59">   NS_IMETHOD DropActivity( // tell collection usage no longer expected</span>
<a href="#l63.60"></a><span id="l63.60" class="difflineminus">-    nsIMdbEnv* ev);</span>
<a href="#l63.61"></a><span id="l63.61" class="difflineplus">+    nsIMdbEnv* ev) override;</span>
<a href="#l63.62"></a><span id="l63.62">   // } ----- end activity dropping methods -----</span>
<a href="#l63.63"></a><span id="l63.63"> </span>
<a href="#l63.64"></a><span id="l63.64"> // } ===== end nsIMdbCollection methods =====</span>
<a href="#l63.65"></a><span id="l63.65" class="difflineminus">-  NS_IMETHOD SetTablePriority(nsIMdbEnv* ev, mdb_priority inPrio);</span>
<a href="#l63.66"></a><span id="l63.66" class="difflineminus">-  NS_IMETHOD GetTablePriority(nsIMdbEnv* ev, mdb_priority* outPrio);</span>
<a href="#l63.67"></a><span id="l63.67" class="difflineplus">+  NS_IMETHOD SetTablePriority(nsIMdbEnv* ev, mdb_priority inPrio) override;</span>
<a href="#l63.68"></a><span id="l63.68" class="difflineplus">+  NS_IMETHOD GetTablePriority(nsIMdbEnv* ev, mdb_priority* outPrio) override;</span>
<a href="#l63.69"></a><span id="l63.69">   </span>
<a href="#l63.70"></a><span id="l63.70" class="difflineminus">-  NS_IMETHOD GetTableBeVerbose(nsIMdbEnv* ev, mdb_bool* outBeVerbose);</span>
<a href="#l63.71"></a><span id="l63.71" class="difflineminus">-  NS_IMETHOD SetTableBeVerbose(nsIMdbEnv* ev, mdb_bool inBeVerbose);</span>
<a href="#l63.72"></a><span id="l63.72" class="difflineplus">+  NS_IMETHOD GetTableBeVerbose(nsIMdbEnv* ev, mdb_bool* outBeVerbose) override;</span>
<a href="#l63.73"></a><span id="l63.73" class="difflineplus">+  NS_IMETHOD SetTableBeVerbose(nsIMdbEnv* ev, mdb_bool inBeVerbose) override;</span>
<a href="#l63.74"></a><span id="l63.74">   </span>
<a href="#l63.75"></a><span id="l63.75" class="difflineminus">-  NS_IMETHOD GetTableIsUnique(nsIMdbEnv* ev, mdb_bool* outIsUnique);</span>
<a href="#l63.76"></a><span id="l63.76" class="difflineplus">+  NS_IMETHOD GetTableIsUnique(nsIMdbEnv* ev, mdb_bool* outIsUnique) override;</span>
<a href="#l63.77"></a><span id="l63.77">   </span>
<a href="#l63.78"></a><span id="l63.78" class="difflineminus">-  NS_IMETHOD GetTableKind(nsIMdbEnv* ev, mdb_kind* outTableKind);</span>
<a href="#l63.79"></a><span id="l63.79" class="difflineminus">-  NS_IMETHOD GetRowScope(nsIMdbEnv* ev, mdb_scope* outRowScope);</span>
<a href="#l63.80"></a><span id="l63.80" class="difflineplus">+  NS_IMETHOD GetTableKind(nsIMdbEnv* ev, mdb_kind* outTableKind) override;</span>
<a href="#l63.81"></a><span id="l63.81" class="difflineplus">+  NS_IMETHOD GetRowScope(nsIMdbEnv* ev, mdb_scope* outRowScope) override;</span>
<a href="#l63.82"></a><span id="l63.82">   </span>
<a href="#l63.83"></a><span id="l63.83">   NS_IMETHOD GetMetaRow(</span>
<a href="#l63.84"></a><span id="l63.84">     nsIMdbEnv* ev, // context</span>
<a href="#l63.85"></a><span id="l63.85">     const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying </span>
<a href="#l63.86"></a><span id="l63.86">     mdbOid* outOid, // output meta row oid, can be nil to suppress output</span>
<a href="#l63.87"></a><span id="l63.87" class="difflineminus">-    nsIMdbRow** acqRow); // acquire table's unique singleton meta row</span>
<a href="#l63.88"></a><span id="l63.88" class="difflineplus">+    nsIMdbRow** acqRow) override; // acquire table's unique singleton meta row</span>
<a href="#l63.89"></a><span id="l63.89">     // The purpose of a meta row is to support the persistent recording of</span>
<a href="#l63.90"></a><span id="l63.90">     // meta info about a table as cells put into the distinguished meta row.</span>
<a href="#l63.91"></a><span id="l63.91">     // Each table has exactly one meta row, which is not considered a member</span>
<a href="#l63.92"></a><span id="l63.92">     // of the collection of rows inside the table.  The only way to tell</span>
<a href="#l63.93"></a><span id="l63.93">     // whether a row is a meta row is by the fact that it is returned by this</span>
<a href="#l63.94"></a><span id="l63.94">     // GetMetaRow() method from some table. Otherwise nothing distinguishes</span>
<a href="#l63.95"></a><span id="l63.95">     // a meta row from any other row.  A meta row can be used anyplace that</span>
<a href="#l63.96"></a><span id="l63.96">     // any other row can be used, and can even be put into other tables (or</span>
<a href="#l63.97"></a><span id="l63.97" class="difflineat">@@ -178,119 +186,119 @@ public: // state is public because the e</span>
<a href="#l63.98"></a><span id="l63.98">     // already given a different oid earlier.</span>
<a href="#l63.99"></a><span id="l63.99">   // } ----- end meta attribute methods -----</span>
<a href="#l63.100"></a><span id="l63.100"> </span>
<a href="#l63.101"></a><span id="l63.101"> </span>
<a href="#l63.102"></a><span id="l63.102">   // { ----- begin cursor methods -----</span>
<a href="#l63.103"></a><span id="l63.103">   NS_IMETHOD GetTableRowCursor( // make a cursor, starting iteration at inRowPos</span>
<a href="#l63.104"></a><span id="l63.104">     nsIMdbEnv* ev, // context</span>
<a href="#l63.105"></a><span id="l63.105">     mdb_pos inRowPos, // zero-based ordinal position of row in table</span>
<a href="#l63.106"></a><span id="l63.106" class="difflineminus">-    nsIMdbTableRowCursor** acqCursor); // acquire new cursor instance</span>
<a href="#l63.107"></a><span id="l63.107" class="difflineplus">+    nsIMdbTableRowCursor** acqCursor) override; // acquire new cursor instance</span>
<a href="#l63.108"></a><span id="l63.108">   // } ----- end row position methods -----</span>
<a href="#l63.109"></a><span id="l63.109"> </span>
<a href="#l63.110"></a><span id="l63.110">   // { ----- begin row position methods -----</span>
<a href="#l63.111"></a><span id="l63.111">   NS_IMETHOD PosToOid( // get row member for a table position</span>
<a href="#l63.112"></a><span id="l63.112">     nsIMdbEnv* ev, // context</span>
<a href="#l63.113"></a><span id="l63.113">     mdb_pos inRowPos, // zero-based ordinal position of row in table</span>
<a href="#l63.114"></a><span id="l63.114" class="difflineminus">-    mdbOid* outOid); // row oid at the specified position</span>
<a href="#l63.115"></a><span id="l63.115" class="difflineplus">+    mdbOid* outOid) override; // row oid at the specified position</span>
<a href="#l63.116"></a><span id="l63.116"> </span>
<a href="#l63.117"></a><span id="l63.117">   NS_IMETHOD OidToPos( // test for the table position of a row member</span>
<a href="#l63.118"></a><span id="l63.118">     nsIMdbEnv* ev, // context</span>
<a href="#l63.119"></a><span id="l63.119">     const mdbOid* inOid, // row to find in table</span>
<a href="#l63.120"></a><span id="l63.120" class="difflineminus">-    mdb_pos* outPos); // zero-based ordinal position of row in table</span>
<a href="#l63.121"></a><span id="l63.121" class="difflineplus">+    mdb_pos* outPos) override; // zero-based ordinal position of row in table</span>
<a href="#l63.122"></a><span id="l63.122">     </span>
<a href="#l63.123"></a><span id="l63.123">   NS_IMETHOD PosToRow( // test for the table position of a row member</span>
<a href="#l63.124"></a><span id="l63.124">     nsIMdbEnv* ev, // context</span>
<a href="#l63.125"></a><span id="l63.125">     mdb_pos inRowPos, // zero-based ordinal position of row in table</span>
<a href="#l63.126"></a><span id="l63.126" class="difflineminus">-    nsIMdbRow** acqRow); // acquire row at table position inRowPos</span>
<a href="#l63.127"></a><span id="l63.127" class="difflineplus">+    nsIMdbRow** acqRow) override; // acquire row at table position inRowPos</span>
<a href="#l63.128"></a><span id="l63.128">     </span>
<a href="#l63.129"></a><span id="l63.129">   NS_IMETHOD RowToPos( // test for the table position of a row member</span>
<a href="#l63.130"></a><span id="l63.130">     nsIMdbEnv* ev, // context</span>
<a href="#l63.131"></a><span id="l63.131">     nsIMdbRow* ioRow, // row to find in table</span>
<a href="#l63.132"></a><span id="l63.132" class="difflineminus">-    mdb_pos* outPos); // zero-based ordinal position of row in table</span>
<a href="#l63.133"></a><span id="l63.133" class="difflineplus">+    mdb_pos* outPos) override; // zero-based ordinal position of row in table</span>
<a href="#l63.134"></a><span id="l63.134">   // } ----- end row position methods -----</span>
<a href="#l63.135"></a><span id="l63.135"> </span>
<a href="#l63.136"></a><span id="l63.136">   // { ----- begin oid set methods -----</span>
<a href="#l63.137"></a><span id="l63.137">   NS_IMETHOD AddOid( // make sure the row with inOid is a table member </span>
<a href="#l63.138"></a><span id="l63.138">     nsIMdbEnv* ev, // context</span>
<a href="#l63.139"></a><span id="l63.139" class="difflineminus">-    const mdbOid* inOid); // row to ensure membership in table</span>
<a href="#l63.140"></a><span id="l63.140" class="difflineplus">+    const mdbOid* inOid) override; // row to ensure membership in table</span>
<a href="#l63.141"></a><span id="l63.141"> </span>
<a href="#l63.142"></a><span id="l63.142">   NS_IMETHOD HasOid( // test for the table position of a row member</span>
<a href="#l63.143"></a><span id="l63.143">     nsIMdbEnv* ev, // context</span>
<a href="#l63.144"></a><span id="l63.144">     const mdbOid* inOid, // row to find in table</span>
<a href="#l63.145"></a><span id="l63.145" class="difflineminus">-    mdb_bool* outHasOid); // whether inOid is a member row</span>
<a href="#l63.146"></a><span id="l63.146" class="difflineplus">+    mdb_bool* outHasOid) override; // whether inOid is a member row</span>
<a href="#l63.147"></a><span id="l63.147"> </span>
<a href="#l63.148"></a><span id="l63.148">   NS_IMETHOD CutOid( // make sure the row with inOid is not a member </span>
<a href="#l63.149"></a><span id="l63.149">     nsIMdbEnv* ev, // context</span>
<a href="#l63.150"></a><span id="l63.150" class="difflineminus">-    const mdbOid* inOid); // row to remove from table</span>
<a href="#l63.151"></a><span id="l63.151" class="difflineplus">+    const mdbOid* inOid) override; // row to remove from table</span>
<a href="#l63.152"></a><span id="l63.152">   // } ----- end oid set methods -----</span>
<a href="#l63.153"></a><span id="l63.153"> </span>
<a href="#l63.154"></a><span id="l63.154">   // { ----- begin row set methods -----</span>
<a href="#l63.155"></a><span id="l63.155">   NS_IMETHOD NewRow( // create a new row instance in table</span>
<a href="#l63.156"></a><span id="l63.156">     nsIMdbEnv* ev, // context</span>
<a href="#l63.157"></a><span id="l63.157">     mdbOid* ioOid, // please use minus one (unbound) rowId for db-assigned IDs</span>
<a href="#l63.158"></a><span id="l63.158" class="difflineminus">-    nsIMdbRow** acqRow); // create new row</span>
<a href="#l63.159"></a><span id="l63.159" class="difflineplus">+    nsIMdbRow** acqRow) override; // create new row</span>
<a href="#l63.160"></a><span id="l63.160"> </span>
<a href="#l63.161"></a><span id="l63.161">   NS_IMETHOD AddRow( // make sure the row with inOid is a table member </span>
<a href="#l63.162"></a><span id="l63.162">     nsIMdbEnv* ev, // context</span>
<a href="#l63.163"></a><span id="l63.163" class="difflineminus">-    nsIMdbRow* ioRow); // row to ensure membership in table</span>
<a href="#l63.164"></a><span id="l63.164" class="difflineplus">+    nsIMdbRow* ioRow) override; // row to ensure membership in table</span>
<a href="#l63.165"></a><span id="l63.165"> </span>
<a href="#l63.166"></a><span id="l63.166">   NS_IMETHOD HasRow( // test for the table position of a row member</span>
<a href="#l63.167"></a><span id="l63.167">     nsIMdbEnv* ev, // context</span>
<a href="#l63.168"></a><span id="l63.168">     nsIMdbRow* ioRow, // row to find in table</span>
<a href="#l63.169"></a><span id="l63.169" class="difflineminus">-    mdb_bool* outHasRow); // whether row is a table member</span>
<a href="#l63.170"></a><span id="l63.170" class="difflineplus">+    mdb_bool* outHasRow) override; // whether row is a table member</span>
<a href="#l63.171"></a><span id="l63.171"> </span>
<a href="#l63.172"></a><span id="l63.172">   NS_IMETHOD CutRow( // make sure the row with inOid is not a member </span>
<a href="#l63.173"></a><span id="l63.173">     nsIMdbEnv* ev, // context</span>
<a href="#l63.174"></a><span id="l63.174" class="difflineminus">-    nsIMdbRow* ioRow); // row to remove from table</span>
<a href="#l63.175"></a><span id="l63.175" class="difflineplus">+    nsIMdbRow* ioRow) override; // row to remove from table</span>
<a href="#l63.176"></a><span id="l63.176"> </span>
<a href="#l63.177"></a><span id="l63.177">   NS_IMETHOD CutAllRows( // remove all rows from the table</span>
<a href="#l63.178"></a><span id="l63.178" class="difflineminus">-    nsIMdbEnv* ev); // context</span>
<a href="#l63.179"></a><span id="l63.179" class="difflineplus">+    nsIMdbEnv* ev) override; // context</span>
<a href="#l63.180"></a><span id="l63.180">   // } ----- end row set methods -----</span>
<a href="#l63.181"></a><span id="l63.181"> </span>
<a href="#l63.182"></a><span id="l63.182">   // { ----- begin hinting methods -----</span>
<a href="#l63.183"></a><span id="l63.183">   NS_IMETHOD SearchColumnsHint( // advise re future expected search cols  </span>
<a href="#l63.184"></a><span id="l63.184">     nsIMdbEnv* ev, // context</span>
<a href="#l63.185"></a><span id="l63.185" class="difflineminus">-    const mdbColumnSet* inColumnSet); // columns likely to be searched</span>
<a href="#l63.186"></a><span id="l63.186" class="difflineplus">+    const mdbColumnSet* inColumnSet) override; // columns likely to be searched</span>
<a href="#l63.187"></a><span id="l63.187">     </span>
<a href="#l63.188"></a><span id="l63.188">   NS_IMETHOD SortColumnsHint( // advise re future expected sort columns  </span>
<a href="#l63.189"></a><span id="l63.189">     nsIMdbEnv* ev, // context</span>
<a href="#l63.190"></a><span id="l63.190" class="difflineminus">-    const mdbColumnSet* inColumnSet); // columns for likely sort requests</span>
<a href="#l63.191"></a><span id="l63.191" class="difflineplus">+    const mdbColumnSet* inColumnSet) override; // columns for likely sort requests</span>
<a href="#l63.192"></a><span id="l63.192">     </span>
<a href="#l63.193"></a><span id="l63.193">   NS_IMETHOD StartBatchChangeHint( // advise before many adds and cuts  </span>
<a href="#l63.194"></a><span id="l63.194">     nsIMdbEnv* ev, // context</span>
<a href="#l63.195"></a><span id="l63.195" class="difflineminus">-    const void* inLabel); // intend unique address to match end call</span>
<a href="#l63.196"></a><span id="l63.196" class="difflineplus">+    const void* inLabel) override; // intend unique address to match end call</span>
<a href="#l63.197"></a><span id="l63.197">     // If batch starts nest by virtue of nesting calls in the stack, then</span>
<a href="#l63.198"></a><span id="l63.198">     // the address of a local variable makes a good batch start label that</span>
<a href="#l63.199"></a><span id="l63.199">     // can be used at batch end time, and such addresses remain unique.</span>
<a href="#l63.200"></a><span id="l63.200">     </span>
<a href="#l63.201"></a><span id="l63.201">   NS_IMETHOD EndBatchChangeHint( // advise before many adds and cuts  </span>
<a href="#l63.202"></a><span id="l63.202">     nsIMdbEnv* ev, // context</span>
<a href="#l63.203"></a><span id="l63.203" class="difflineminus">-    const void* inLabel); // label matching start label</span>
<a href="#l63.204"></a><span id="l63.204" class="difflineplus">+    const void* inLabel) override; // label matching start label</span>
<a href="#l63.205"></a><span id="l63.205">     // Suppose a table is maintaining one or many sort orders for a table,</span>
<a href="#l63.206"></a><span id="l63.206">     // so that every row added to the table must be inserted in each sort,</span>
<a href="#l63.207"></a><span id="l63.207">     // and every row cut must be removed from each sort.  If a db client</span>
<a href="#l63.208"></a><span id="l63.208">     // intends to make many such changes before needing any information</span>
<a href="#l63.209"></a><span id="l63.209">     // about the order or positions of rows inside a table, then a client</span>
<a href="#l63.210"></a><span id="l63.210">     // might tell the table to start batch changes in order to disable</span>
<a href="#l63.211"></a><span id="l63.211">     // sorting of rows for the interim.  Presumably a table will then do</span>
<a href="#l63.212"></a><span id="l63.212">     // a full sort of all rows at need when the batch changes end, or when</span>
<a href="#l63.213"></a><span id="l63.213">     // a surprise request occurs for row position during batch changes.</span>
<a href="#l63.214"></a><span id="l63.214">   // } ----- end hinting methods -----</span>
<a href="#l63.215"></a><span id="l63.215"> </span>
<a href="#l63.216"></a><span id="l63.216">   // { ----- begin searching methods -----</span>
<a href="#l63.217"></a><span id="l63.217">   NS_IMETHOD FindRowMatches( // search variable number of sorted cols</span>
<a href="#l63.218"></a><span id="l63.218">     nsIMdbEnv* ev, // context</span>
<a href="#l63.219"></a><span id="l63.219">     const mdbYarn* inPrefix, // content to find as prefix in row's column cell</span>
<a href="#l63.220"></a><span id="l63.220" class="difflineminus">-    nsIMdbTableRowCursor** acqCursor); // set of matching rows</span>
<a href="#l63.221"></a><span id="l63.221" class="difflineminus">-    </span>
<a href="#l63.222"></a><span id="l63.222" class="difflineplus">+    nsIMdbTableRowCursor** acqCursor) override; // set of matching rows</span>
<a href="#l63.223"></a><span id="l63.223" class="difflineplus">+</span>
<a href="#l63.224"></a><span id="l63.224">   NS_IMETHOD GetSearchColumns( // query columns used by FindRowMatches()</span>
<a href="#l63.225"></a><span id="l63.225">     nsIMdbEnv* ev, // context</span>
<a href="#l63.226"></a><span id="l63.226">     mdb_count* outCount, // context</span>
<a href="#l63.227"></a><span id="l63.227" class="difflineminus">-    mdbColumnSet* outColSet); // caller supplied space to put columns</span>
<a href="#l63.228"></a><span id="l63.228" class="difflineplus">+    mdbColumnSet* outColSet) override; // caller supplied space to put columns</span>
<a href="#l63.229"></a><span id="l63.229">     // GetSearchColumns() returns the columns actually searched when the</span>
<a href="#l63.230"></a><span id="l63.230">     // FindRowMatches() method is called.  No more than mColumnSet_Count</span>
<a href="#l63.231"></a><span id="l63.231">     // slots of mColumnSet_Columns will be written, since mColumnSet_Count</span>
<a href="#l63.232"></a><span id="l63.232">     // indicates how many slots are present in the column array.  The</span>
<a href="#l63.233"></a><span id="l63.233">     // actual number of search column used by the table is returned in</span>
<a href="#l63.234"></a><span id="l63.234">     // the outCount parameter; if this number exceeds mColumnSet_Count,</span>
<a href="#l63.235"></a><span id="l63.235">     // then a caller needs a bigger array to read the entire column set.</span>
<a href="#l63.236"></a><span id="l63.236">     // The minimum of mColumnSet_Count and outCount is the number slots</span>
<a href="#l63.237"></a><span id="l63.237" class="difflineat">@@ -303,27 +311,27 @@ public: // state is public because the e</span>
<a href="#l63.238"></a><span id="l63.238">   // { ----- begin sorting methods -----</span>
<a href="#l63.239"></a><span id="l63.239">   // sorting: note all rows are assumed sorted by row ID as a secondary</span>
<a href="#l63.240"></a><span id="l63.240">   // sort following the primary column sort, when table rows are sorted.</span>
<a href="#l63.241"></a><span id="l63.241"> </span>
<a href="#l63.242"></a><span id="l63.242">   NS_IMETHOD</span>
<a href="#l63.243"></a><span id="l63.243">   CanSortColumn( // query which column is currently used for sorting</span>
<a href="#l63.244"></a><span id="l63.244">     nsIMdbEnv* ev, // context</span>
<a href="#l63.245"></a><span id="l63.245">     mdb_column inColumn, // column to query sorting potential</span>
<a href="#l63.246"></a><span id="l63.246" class="difflineminus">-    mdb_bool* outCanSort); // whether the column can be sorted</span>
<a href="#l63.247"></a><span id="l63.247" class="difflineplus">+    mdb_bool* outCanSort) override; // whether the column can be sorted</span>
<a href="#l63.248"></a><span id="l63.248">     </span>
<a href="#l63.249"></a><span id="l63.249">   NS_IMETHOD GetSorting( // view same table in particular sorting</span>
<a href="#l63.250"></a><span id="l63.250">     nsIMdbEnv* ev, // context</span>
<a href="#l63.251"></a><span id="l63.251">     mdb_column inColumn, // requested new column for sorting table</span>
<a href="#l63.252"></a><span id="l63.252" class="difflineminus">-    nsIMdbSorting** acqSorting); // acquire sorting for column</span>
<a href="#l63.253"></a><span id="l63.253" class="difflineplus">+    nsIMdbSorting** acqSorting) override; // acquire sorting for column</span>
<a href="#l63.254"></a><span id="l63.254">     </span>
<a href="#l63.255"></a><span id="l63.255">   NS_IMETHOD SetSearchSorting( // use this sorting in FindRowMatches()</span>
<a href="#l63.256"></a><span id="l63.256">     nsIMdbEnv* ev, // context</span>
<a href="#l63.257"></a><span id="l63.257">     mdb_column inColumn, // often same as nsIMdbSorting::GetSortColumn()</span>
<a href="#l63.258"></a><span id="l63.258" class="difflineminus">-    nsIMdbSorting* ioSorting); // requested sorting for some column</span>
<a href="#l63.259"></a><span id="l63.259" class="difflineplus">+    nsIMdbSorting* ioSorting) override; // requested sorting for some column</span>
<a href="#l63.260"></a><span id="l63.260">     // SetSearchSorting() attempts to inform the table that ioSorting</span>
<a href="#l63.261"></a><span id="l63.261">     // should be used during calls to FindRowMatches() for searching</span>
<a href="#l63.262"></a><span id="l63.262">     // the column which is actually sorted by ioSorting.  This method</span>
<a href="#l63.263"></a><span id="l63.263">     // is most useful in conjunction with nsIMdbSorting::SetCompare(),</span>
<a href="#l63.264"></a><span id="l63.264">     // because otherwise a caller would not be able to override the</span>
<a href="#l63.265"></a><span id="l63.265">     // comparison ordering method used during searchs.  Note that some</span>
<a href="#l63.266"></a><span id="l63.266">     // database implementations might be unable to use an arbitrarily</span>
<a href="#l63.267"></a><span id="l63.267">     // specified sort order, either due to schema or runtime interface</span>
<a href="#l63.268"></a><span id="l63.268" class="difflineat">@@ -346,59 +354,59 @@ public: // state is public because the e</span>
<a href="#l63.269"></a><span id="l63.269">   // { ----- begin moving methods -----</span>
<a href="#l63.270"></a><span id="l63.270">   // moving a row does nothing unless a table is currently unsorted</span>
<a href="#l63.271"></a><span id="l63.271">   </span>
<a href="#l63.272"></a><span id="l63.272">   NS_IMETHOD MoveOid( // change position of row in unsorted table</span>
<a href="#l63.273"></a><span id="l63.273">     nsIMdbEnv* ev, // context</span>
<a href="#l63.274"></a><span id="l63.274">     const mdbOid* inOid,  // row oid to find in table</span>
<a href="#l63.275"></a><span id="l63.275">     mdb_pos inHintFromPos, // suggested hint regarding start position</span>
<a href="#l63.276"></a><span id="l63.276">     mdb_pos inToPos,       // desired new position for row inRowId</span>
<a href="#l63.277"></a><span id="l63.277" class="difflineminus">-    mdb_pos* outActualPos); // actual new position of row in table</span>
<a href="#l63.278"></a><span id="l63.278" class="difflineplus">+    mdb_pos* outActualPos) override; // actual new position of row in table</span>
<a href="#l63.279"></a><span id="l63.279"> </span>
<a href="#l63.280"></a><span id="l63.280">   NS_IMETHOD MoveRow( // change position of row in unsorted table</span>
<a href="#l63.281"></a><span id="l63.281">     nsIMdbEnv* ev, // context</span>
<a href="#l63.282"></a><span id="l63.282">     nsIMdbRow* ioRow,  // row oid to find in table</span>
<a href="#l63.283"></a><span id="l63.283">     mdb_pos inHintFromPos, // suggested hint regarding start position</span>
<a href="#l63.284"></a><span id="l63.284">     mdb_pos inToPos,       // desired new position for row inRowId</span>
<a href="#l63.285"></a><span id="l63.285" class="difflineminus">-    mdb_pos* outActualPos); // actual new position of row in table</span>
<a href="#l63.286"></a><span id="l63.286" class="difflineplus">+    mdb_pos* outActualPos) override; // actual new position of row in table</span>
<a href="#l63.287"></a><span id="l63.287">   // } ----- end moving methods -----</span>
<a href="#l63.288"></a><span id="l63.288">   </span>
<a href="#l63.289"></a><span id="l63.289">   // { ----- begin index methods -----</span>
<a href="#l63.290"></a><span id="l63.290">   NS_IMETHOD AddIndex( // create a sorting index for column if possible</span>
<a href="#l63.291"></a><span id="l63.291">     nsIMdbEnv* ev, // context</span>
<a href="#l63.292"></a><span id="l63.292">     mdb_column inColumn, // the column to sort by index</span>
<a href="#l63.293"></a><span id="l63.293" class="difflineminus">-    nsIMdbThumb** acqThumb); // acquire thumb for incremental index building</span>
<a href="#l63.294"></a><span id="l63.294" class="difflineplus">+    nsIMdbThumb** acqThumb) override; // acquire thumb for incremental index building</span>
<a href="#l63.295"></a><span id="l63.295">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l63.296"></a><span id="l63.296">   // then the index addition will be finished.</span>
<a href="#l63.297"></a><span id="l63.297">   </span>
<a href="#l63.298"></a><span id="l63.298">   NS_IMETHOD CutIndex( // stop supporting a specific column index</span>
<a href="#l63.299"></a><span id="l63.299">     nsIMdbEnv* ev, // context</span>
<a href="#l63.300"></a><span id="l63.300">     mdb_column inColumn, // the column with index to be removed</span>
<a href="#l63.301"></a><span id="l63.301" class="difflineminus">-    nsIMdbThumb** acqThumb); // acquire thumb for incremental index destroy</span>
<a href="#l63.302"></a><span id="l63.302" class="difflineplus">+    nsIMdbThumb** acqThumb) override; // acquire thumb for incremental index destroy</span>
<a href="#l63.303"></a><span id="l63.303">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l63.304"></a><span id="l63.304">   // then the index removal will be finished.</span>
<a href="#l63.305"></a><span id="l63.305">   </span>
<a href="#l63.306"></a><span id="l63.306">   NS_IMETHOD HasIndex( // query for current presence of a column index</span>
<a href="#l63.307"></a><span id="l63.307">     nsIMdbEnv* ev, // context</span>
<a href="#l63.308"></a><span id="l63.308">     mdb_column inColumn, // the column to investigate</span>
<a href="#l63.309"></a><span id="l63.309" class="difflineminus">-    mdb_bool* outHasIndex); // whether column has index for this column</span>
<a href="#l63.310"></a><span id="l63.310" class="difflineplus">+    mdb_bool* outHasIndex) override; // whether column has index for this column</span>
<a href="#l63.311"></a><span id="l63.311"> </span>
<a href="#l63.312"></a><span id="l63.312">   </span>
<a href="#l63.313"></a><span id="l63.313">   NS_IMETHOD EnableIndexOnSort( // create an index for col on first sort</span>
<a href="#l63.314"></a><span id="l63.314">     nsIMdbEnv* ev, // context</span>
<a href="#l63.315"></a><span id="l63.315" class="difflineminus">-    mdb_column inColumn); // the column to index if ever sorted</span>
<a href="#l63.316"></a><span id="l63.316" class="difflineplus">+    mdb_column inColumn) override; // the column to index if ever sorted</span>
<a href="#l63.317"></a><span id="l63.317">   </span>
<a href="#l63.318"></a><span id="l63.318">   NS_IMETHOD QueryIndexOnSort( // check whether index on sort is enabled</span>
<a href="#l63.319"></a><span id="l63.319">     nsIMdbEnv* ev, // context</span>
<a href="#l63.320"></a><span id="l63.320">     mdb_column inColumn, // the column to investigate</span>
<a href="#l63.321"></a><span id="l63.321" class="difflineminus">-    mdb_bool* outIndexOnSort); // whether column has index-on-sort enabled</span>
<a href="#l63.322"></a><span id="l63.322" class="difflineplus">+    mdb_bool* outIndexOnSort) override; // whether column has index-on-sort enabled</span>
<a href="#l63.323"></a><span id="l63.323">   </span>
<a href="#l63.324"></a><span id="l63.324">   NS_IMETHOD DisableIndexOnSort( // prevent future index creation on sort</span>
<a href="#l63.325"></a><span id="l63.325">     nsIMdbEnv* ev, // context</span>
<a href="#l63.326"></a><span id="l63.326" class="difflineminus">-    mdb_column inColumn); // the column to index if ever sorted</span>
<a href="#l63.327"></a><span id="l63.327" class="difflineplus">+    mdb_column inColumn) override; // the column to index if ever sorted</span>
<a href="#l63.328"></a><span id="l63.328">   // } ----- end index methods -----</span>
<a href="#l63.329"></a><span id="l63.329"> </span>
<a href="#l63.330"></a><span id="l63.330">   morkStore*      mTable_Store;   // non-refcnted ptr to port</span>
<a href="#l63.331"></a><span id="l63.331"> </span>
<a href="#l63.332"></a><span id="l63.332">   // mTable_RowSpace-&gt;SpaceScope() is row scope </span>
<a href="#l63.333"></a><span id="l63.333">   morkRowSpace*   mTable_RowSpace; // non-refcnted ptr to containing space</span>
<a href="#l63.334"></a><span id="l63.334"> </span>
<a href="#l63.335"></a><span id="l63.335">   morkRow*        mTable_MetaRow; // table's actual meta row</span>
<a href="#l63.336"></a><span id="l63.336" class="difflineat">@@ -458,17 +466,17 @@ public: // table dirty handling more com</span>
<a href="#l63.337"></a><span id="l63.337"> </span>
<a href="#l63.338"></a><span id="l63.338"> public: // morkNode memory management operators</span>
<a href="#l63.339"></a><span id="l63.339">   void* operator new(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev) CPP_THROW_NEW</span>
<a href="#l63.340"></a><span id="l63.340">   { return morkNode::MakeNew(inSize, ioHeap, ev); }</span>
<a href="#l63.341"></a><span id="l63.341">   </span>
<a href="#l63.342"></a><span id="l63.342">  </span>
<a href="#l63.343"></a><span id="l63.343"> // { ===== begin morkNode interface =====</span>
<a href="#l63.344"></a><span id="l63.344"> public: // morkNode virtual methods</span>
<a href="#l63.345"></a><span id="l63.345" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseTable() if open</span>
<a href="#l63.346"></a><span id="l63.346" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseTable() if open</span>
<a href="#l63.347"></a><span id="l63.347">   </span>
<a href="#l63.348"></a><span id="l63.348"> public: // morkTable construction &amp; destruction</span>
<a href="#l63.349"></a><span id="l63.349">   morkTable(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l63.350"></a><span id="l63.350">     nsIMdbHeap* ioNodeHeap, morkStore* ioStore,</span>
<a href="#l63.351"></a><span id="l63.351">     nsIMdbHeap* ioSlotHeap, morkRowSpace* ioRowSpace,</span>
<a href="#l63.352"></a><span id="l63.352">     const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying </span>
<a href="#l63.353"></a><span id="l63.353">     mork_tid inTableId,</span>
<a href="#l63.354"></a><span id="l63.354">     mork_kind inKind, mork_bool inMustBeUnique);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l64.1"></a><span id="l64.1" class="difflineminus">--- a/db/mork/src/morkTableRowCursor.cpp</span>
<a href="#l64.2"></a><span id="l64.2" class="difflineplus">+++ b/db/mork/src/morkTableRowCursor.cpp</span>
<a href="#l64.3"></a><span id="l64.3" class="difflineat">@@ -83,31 +83,26 @@ morkTableRowCursor::morkTableRowCursor(m</span>
<a href="#l64.4"></a><span id="l64.4">       ev-&gt;NilPointerError();</span>
<a href="#l64.5"></a><span id="l64.5">   }</span>
<a href="#l64.6"></a><span id="l64.6"> }</span>
<a href="#l64.7"></a><span id="l64.7"> </span>
<a href="#l64.8"></a><span id="l64.8"> NS_IMPL_ISUPPORTS_INHERITED(morkTableRowCursor, morkCursor, nsIMdbTableRowCursor)</span>
<a href="#l64.9"></a><span id="l64.9"> /*public non-poly*/ void</span>
<a href="#l64.10"></a><span id="l64.10"> morkTableRowCursor::CloseTableRowCursor(morkEnv* ev) </span>
<a href="#l64.11"></a><span id="l64.11"> {</span>
<a href="#l64.12"></a><span id="l64.12" class="difflineminus">-  if ( this )</span>
<a href="#l64.13"></a><span id="l64.13" class="difflineminus">-  {</span>
<a href="#l64.14"></a><span id="l64.14">     if ( this-&gt;IsNode() )</span>
<a href="#l64.15"></a><span id="l64.15">     {</span>
<a href="#l64.16"></a><span id="l64.16">       mCursor_Pos = -1;</span>
<a href="#l64.17"></a><span id="l64.17">       mCursor_Seed = 0;</span>
<a href="#l64.18"></a><span id="l64.18">       morkTable::SlotWeakTable((morkTable*) 0, ev, &amp;mTableRowCursor_Table);</span>
<a href="#l64.19"></a><span id="l64.19">       this-&gt;CloseCursor(ev);</span>
<a href="#l64.20"></a><span id="l64.20">       this-&gt;MarkShut();</span>
<a href="#l64.21"></a><span id="l64.21">     }</span>
<a href="#l64.22"></a><span id="l64.22">     else</span>
<a href="#l64.23"></a><span id="l64.23">       this-&gt;NonNodeError(ev);</span>
<a href="#l64.24"></a><span id="l64.24" class="difflineminus">-  }</span>
<a href="#l64.25"></a><span id="l64.25" class="difflineminus">-  else</span>
<a href="#l64.26"></a><span id="l64.26" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l64.27"></a><span id="l64.27"> }</span>
<a href="#l64.28"></a><span id="l64.28"> </span>
<a href="#l64.29"></a><span id="l64.29"> // } ===== end morkNode methods =====</span>
<a href="#l64.30"></a><span id="l64.30"> // ````` ````` ````` ````` ````` </span>
<a href="#l64.31"></a><span id="l64.31"> // { ----- begin attribute methods -----</span>
<a href="#l64.32"></a><span id="l64.32"> /*virtual*/ nsresult</span>
<a href="#l64.33"></a><span id="l64.33"> morkTableRowCursor::GetCount(nsIMdbEnv* mev, mdb_count* outCount)</span>
<a href="#l64.34"></a><span id="l64.34"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l65.1"></a><span id="l65.1" class="difflineminus">--- a/db/mork/src/morkTableRowCursor.h</span>
<a href="#l65.2"></a><span id="l65.2" class="difflineplus">+++ b/db/mork/src/morkTableRowCursor.h</span>
<a href="#l65.3"></a><span id="l65.3" class="difflineat">@@ -43,17 +43,17 @@ class morkTableRowCursor : public morkCu</span>
<a href="#l65.4"></a><span id="l65.4">   // mork_bool  mCursor_DoFailOnSeedOutOfSync;</span>
<a href="#l65.5"></a><span id="l65.5">   // mork_u1    mCursor_Pad[ 3 ]; // explicitly pad to u4 alignment</span>
<a href="#l65.6"></a><span id="l65.6"> </span>
<a href="#l65.7"></a><span id="l65.7"> public: // state is public because the entire Mork system is private</span>
<a href="#l65.8"></a><span id="l65.8">   morkTable*  mTableRowCursor_Table; // weak ref to table</span>
<a href="#l65.9"></a><span id="l65.9">     </span>
<a href="#l65.10"></a><span id="l65.10"> // { ===== begin morkNode interface =====</span>
<a href="#l65.11"></a><span id="l65.11"> public: // morkNode virtual methods</span>
<a href="#l65.12"></a><span id="l65.12" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseTableRowCursor()</span>
<a href="#l65.13"></a><span id="l65.13" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseTableRowCursor()</span>
<a href="#l65.14"></a><span id="l65.14"> </span>
<a href="#l65.15"></a><span id="l65.15"> protected:</span>
<a href="#l65.16"></a><span id="l65.16">   virtual ~morkTableRowCursor(); // assert that close executed earlier</span>
<a href="#l65.17"></a><span id="l65.17">   </span>
<a href="#l65.18"></a><span id="l65.18"> public: // morkTableRowCursor construction &amp; destruction</span>
<a href="#l65.19"></a><span id="l65.19">   morkTableRowCursor(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l65.20"></a><span id="l65.20">     nsIMdbHeap* ioHeap, morkTable* ioTable, mork_pos inRowPos);</span>
<a href="#l65.21"></a><span id="l65.21">   void CloseTableRowCursor(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l65.22"></a><span id="l65.22" class="difflineat">@@ -61,58 +61,58 @@ public: // morkTableRowCursor constructi</span>
<a href="#l65.23"></a><span id="l65.23"> private: // copying is not allowed</span>
<a href="#l65.24"></a><span id="l65.24">   morkTableRowCursor(const morkTableRowCursor&amp; other);</span>
<a href="#l65.25"></a><span id="l65.25">   morkTableRowCursor&amp; operator=(const morkTableRowCursor&amp; other);</span>
<a href="#l65.26"></a><span id="l65.26"> </span>
<a href="#l65.27"></a><span id="l65.27"> public:</span>
<a href="#l65.28"></a><span id="l65.28">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l65.29"></a><span id="l65.29"> </span>
<a href="#l65.30"></a><span id="l65.30">   // { ----- begin attribute methods -----</span>
<a href="#l65.31"></a><span id="l65.31" class="difflineminus">-  NS_IMETHOD GetCount(nsIMdbEnv* ev, mdb_count* outCount); // readonly</span>
<a href="#l65.32"></a><span id="l65.32" class="difflineminus">-  NS_IMETHOD GetSeed(nsIMdbEnv* ev, mdb_seed* outSeed);    // readonly</span>
<a href="#l65.33"></a><span id="l65.33" class="difflineplus">+  NS_IMETHOD GetCount(nsIMdbEnv* ev, mdb_count* outCount) override; // readonly</span>
<a href="#l65.34"></a><span id="l65.34" class="difflineplus">+  NS_IMETHOD GetSeed(nsIMdbEnv* ev, mdb_seed* outSeed) override;    // readonly</span>
<a href="#l65.35"></a><span id="l65.35">   </span>
<a href="#l65.36"></a><span id="l65.36" class="difflineminus">-  NS_IMETHOD SetPos(nsIMdbEnv* ev, mdb_pos inPos);   // mutable</span>
<a href="#l65.37"></a><span id="l65.37" class="difflineminus">-  NS_IMETHOD GetPos(nsIMdbEnv* ev, mdb_pos* outPos);</span>
<a href="#l65.38"></a><span id="l65.38" class="difflineplus">+  NS_IMETHOD SetPos(nsIMdbEnv* ev, mdb_pos inPos) override;   // mutable</span>
<a href="#l65.39"></a><span id="l65.39" class="difflineplus">+  NS_IMETHOD GetPos(nsIMdbEnv* ev, mdb_pos* outPos) override;</span>
<a href="#l65.40"></a><span id="l65.40">   </span>
<a href="#l65.41"></a><span id="l65.41" class="difflineminus">-  NS_IMETHOD SetDoFailOnSeedOutOfSync(nsIMdbEnv* ev, mdb_bool inFail);</span>
<a href="#l65.42"></a><span id="l65.42" class="difflineminus">-  NS_IMETHOD GetDoFailOnSeedOutOfSync(nsIMdbEnv* ev, mdb_bool* outFail);</span>
<a href="#l65.43"></a><span id="l65.43" class="difflineplus">+  NS_IMETHOD SetDoFailOnSeedOutOfSync(nsIMdbEnv* ev, mdb_bool inFail) override;</span>
<a href="#l65.44"></a><span id="l65.44" class="difflineplus">+  NS_IMETHOD GetDoFailOnSeedOutOfSync(nsIMdbEnv* ev, mdb_bool* outFail) override;</span>
<a href="#l65.45"></a><span id="l65.45"> </span>
<a href="#l65.46"></a><span id="l65.46">   // } ----- end attribute methods -----</span>
<a href="#l65.47"></a><span id="l65.47" class="difflineminus">-    NS_IMETHOD GetTable(nsIMdbEnv* ev, nsIMdbTable** acqTable);</span>
<a href="#l65.48"></a><span id="l65.48" class="difflineplus">+    NS_IMETHOD GetTable(nsIMdbEnv* ev, nsIMdbTable** acqTable) override;</span>
<a href="#l65.49"></a><span id="l65.49">   // } ----- end attribute methods -----</span>
<a href="#l65.50"></a><span id="l65.50"> </span>
<a href="#l65.51"></a><span id="l65.51">   // { ----- begin duplicate row removal methods -----</span>
<a href="#l65.52"></a><span id="l65.52">   NS_IMETHOD CanHaveDupRowMembers(nsIMdbEnv* ev, // cursor might hold dups?</span>
<a href="#l65.53"></a><span id="l65.53" class="difflineminus">-    mdb_bool* outCanHaveDups);</span>
<a href="#l65.54"></a><span id="l65.54" class="difflineplus">+    mdb_bool* outCanHaveDups) override;</span>
<a href="#l65.55"></a><span id="l65.55">     </span>
<a href="#l65.56"></a><span id="l65.56">   NS_IMETHOD MakeUniqueCursor( // clone cursor, removing duplicate rows</span>
<a href="#l65.57"></a><span id="l65.57">     nsIMdbEnv* ev, // context</span>
<a href="#l65.58"></a><span id="l65.58" class="difflineminus">-    nsIMdbTableRowCursor** acqCursor);    // acquire clone with no dups</span>
<a href="#l65.59"></a><span id="l65.59" class="difflineplus">+    nsIMdbTableRowCursor** acqCursor) override;    // acquire clone with no dups</span>
<a href="#l65.60"></a><span id="l65.60">   // } ----- end duplicate row removal methods -----</span>
<a href="#l65.61"></a><span id="l65.61"> </span>
<a href="#l65.62"></a><span id="l65.62">   // { ----- begin oid iteration methods -----</span>
<a href="#l65.63"></a><span id="l65.63">   NS_IMETHOD NextRowOid( // get row id of next row in the table</span>
<a href="#l65.64"></a><span id="l65.64">     nsIMdbEnv* ev, // context</span>
<a href="#l65.65"></a><span id="l65.65">     mdbOid* outOid, // out row oid</span>
<a href="#l65.66"></a><span id="l65.66" class="difflineminus">-    mdb_pos* outRowPos);    // zero-based position of the row in table</span>
<a href="#l65.67"></a><span id="l65.67" class="difflineplus">+    mdb_pos* outRowPos) override; // zero-based position of the row in table</span>
<a href="#l65.68"></a><span id="l65.68">   NS_IMETHOD PrevRowOid( // get row id of previous row in the table</span>
<a href="#l65.69"></a><span id="l65.69">     nsIMdbEnv* ev, // context</span>
<a href="#l65.70"></a><span id="l65.70">     mdbOid* outOid, // out row oid</span>
<a href="#l65.71"></a><span id="l65.71" class="difflineminus">-    mdb_pos* outRowPos);    // zero-based position of the row in table</span>
<a href="#l65.72"></a><span id="l65.72" class="difflineplus">+    mdb_pos* outRowPos) override; // zero-based position of the row in table</span>
<a href="#l65.73"></a><span id="l65.73">   // } ----- end oid iteration methods -----</span>
<a href="#l65.74"></a><span id="l65.74"> </span>
<a href="#l65.75"></a><span id="l65.75">   // { ----- begin row iteration methods -----</span>
<a href="#l65.76"></a><span id="l65.76">   NS_IMETHOD NextRow( // get row cells from table for cells already in row</span>
<a href="#l65.77"></a><span id="l65.77">     nsIMdbEnv* ev, // context</span>
<a href="#l65.78"></a><span id="l65.78">     nsIMdbRow** acqRow, // acquire next row in table</span>
<a href="#l65.79"></a><span id="l65.79" class="difflineminus">-    mdb_pos* outRowPos);    // zero-based position of the row in table</span>
<a href="#l65.80"></a><span id="l65.80" class="difflineplus">+    mdb_pos* outRowPos) override; // zero-based position of the row in table</span>
<a href="#l65.81"></a><span id="l65.81">   NS_IMETHOD PrevRow( // get row cells from table for cells already in row</span>
<a href="#l65.82"></a><span id="l65.82">     nsIMdbEnv* ev, // context</span>
<a href="#l65.83"></a><span id="l65.83">     nsIMdbRow** acqRow, // acquire previous row in table</span>
<a href="#l65.84"></a><span id="l65.84" class="difflineminus">-    mdb_pos* outRowPos);    // zero-based position of the row in table</span>
<a href="#l65.85"></a><span id="l65.85" class="difflineplus">+    mdb_pos* outRowPos) override; // zero-based position of the row in table</span>
<a href="#l65.86"></a><span id="l65.86">   // } ----- end row iteration methods -----</span>
<a href="#l65.87"></a><span id="l65.87"> </span>
<a href="#l65.88"></a><span id="l65.88"> </span>
<a href="#l65.89"></a><span id="l65.89"> public: // dynamic type identification</span>
<a href="#l65.90"></a><span id="l65.90">   mork_bool IsTableRowCursor() const</span>
<a href="#l65.91"></a><span id="l65.91">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kTableRowCursor; }</span>
<a href="#l65.92"></a><span id="l65.92"> // } ===== end morkNode methods =====</span>
<a href="#l65.93"></a><span id="l65.93"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l66.1"></a><span id="l66.1" class="difflineminus">--- a/db/mork/src/morkThumb.cpp</span>
<a href="#l66.2"></a><span id="l66.2" class="difflineplus">+++ b/db/mork/src/morkThumb.cpp</span>
<a href="#l66.3"></a><span id="l66.3" class="difflineat">@@ -101,36 +101,31 @@ morkThumb::morkThumb(morkEnv* ev,</span>
<a href="#l66.4"></a><span id="l66.4">   }</span>
<a href="#l66.5"></a><span id="l66.5"> }</span>
<a href="#l66.6"></a><span id="l66.6"> </span>
<a href="#l66.7"></a><span id="l66.7"> NS_IMPL_ISUPPORTS_INHERITED(morkThumb, morkObject, nsIMdbThumb)</span>
<a href="#l66.8"></a><span id="l66.8"> </span>
<a href="#l66.9"></a><span id="l66.9"> /*public non-poly*/ void</span>
<a href="#l66.10"></a><span id="l66.10"> morkThumb::CloseThumb(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l66.11"></a><span id="l66.11"> {</span>
<a href="#l66.12"></a><span id="l66.12" class="difflineminus">-  if ( this )</span>
<a href="#l66.13"></a><span id="l66.13" class="difflineminus">-  {</span>
<a href="#l66.14"></a><span id="l66.14">     if ( this-&gt;IsNode() )</span>
<a href="#l66.15"></a><span id="l66.15">     {</span>
<a href="#l66.16"></a><span id="l66.16">       mThumb_Magic = 0;</span>
<a href="#l66.17"></a><span id="l66.17">       if ( mThumb_Builder &amp;&amp; mThumb_Store )</span>
<a href="#l66.18"></a><span id="l66.18">         mThumb_Store-&gt;ForgetBuilder(ev);</span>
<a href="#l66.19"></a><span id="l66.19">       morkBuilder::SlotStrongBuilder((morkBuilder*) 0, ev, &amp;mThumb_Builder);</span>
<a href="#l66.20"></a><span id="l66.20">       </span>
<a href="#l66.21"></a><span id="l66.21">       morkWriter::SlotStrongWriter((morkWriter*) 0, ev, &amp;mThumb_Writer);</span>
<a href="#l66.22"></a><span id="l66.22">       nsIMdbFile_SlotStrongFile((nsIMdbFile*) 0, ev, &amp;mThumb_File);</span>
<a href="#l66.23"></a><span id="l66.23">       morkStore::SlotStrongStore((morkStore*) 0, ev, &amp;mThumb_Store);</span>
<a href="#l66.24"></a><span id="l66.24">       morkStore::SlotStrongPort((morkPort*) 0, ev, &amp;mThumb_SourcePort);</span>
<a href="#l66.25"></a><span id="l66.25">       this-&gt;MarkShut();</span>
<a href="#l66.26"></a><span id="l66.26">     }</span>
<a href="#l66.27"></a><span id="l66.27">     else</span>
<a href="#l66.28"></a><span id="l66.28">       this-&gt;NonNodeError(ev);</span>
<a href="#l66.29"></a><span id="l66.29" class="difflineminus">-  }</span>
<a href="#l66.30"></a><span id="l66.30" class="difflineminus">-  else</span>
<a href="#l66.31"></a><span id="l66.31" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l66.32"></a><span id="l66.32"> }</span>
<a href="#l66.33"></a><span id="l66.33"> </span>
<a href="#l66.34"></a><span id="l66.34"> // } ===== end morkNode methods =====</span>
<a href="#l66.35"></a><span id="l66.35"> // ````` ````` ````` ````` ````` </span>
<a href="#l66.36"></a><span id="l66.36"> </span>
<a href="#l66.37"></a><span id="l66.37"> // { ===== begin nsIMdbThumb methods =====</span>
<a href="#l66.38"></a><span id="l66.38"> NS_IMETHODIMP</span>
<a href="#l66.39"></a><span id="l66.39"> morkThumb::GetProgress(nsIMdbEnv* mev, mdb_count* outTotal,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l67.1"></a><span id="l67.1" class="difflineminus">--- a/db/mork/src/morkThumb.h</span>
<a href="#l67.2"></a><span id="l67.2" class="difflineplus">+++ b/db/mork/src/morkThumb.h</span>
<a href="#l67.3"></a><span id="l67.3" class="difflineat">@@ -58,22 +58,22 @@ class morkThumb : public morkObject, pub</span>
<a href="#l67.4"></a><span id="l67.4">   // mork_color   mBead_Color;   // ID for this bead</span>
<a href="#l67.5"></a><span id="l67.5">   // morkHandle*  mObject_Handle;  // weak ref to handle for this object</span>
<a href="#l67.6"></a><span id="l67.6"> </span>
<a href="#l67.7"></a><span id="l67.7"> public: // state is public because the entire Mork system is private</span>
<a href="#l67.8"></a><span id="l67.8">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l67.9"></a><span id="l67.9"> </span>
<a href="#l67.10"></a><span id="l67.10"> // { ===== begin nsIMdbThumb methods =====</span>
<a href="#l67.11"></a><span id="l67.11">   NS_IMETHOD GetProgress(nsIMdbEnv* ev, mdb_count* outTotal,</span>
<a href="#l67.12"></a><span id="l67.12" class="difflineminus">-    mdb_count* outCurrent, mdb_bool* outDone, mdb_bool* outBroken);</span>
<a href="#l67.13"></a><span id="l67.13" class="difflineminus">-  </span>
<a href="#l67.14"></a><span id="l67.14" class="difflineplus">+    mdb_count* outCurrent, mdb_bool* outDone, mdb_bool* outBroken) override;</span>
<a href="#l67.15"></a><span id="l67.15" class="difflineplus">+</span>
<a href="#l67.16"></a><span id="l67.16">   NS_IMETHOD DoMore(nsIMdbEnv* ev, mdb_count* outTotal,</span>
<a href="#l67.17"></a><span id="l67.17" class="difflineminus">-    mdb_count* outCurrent, mdb_bool* outDone, mdb_bool* outBroken);</span>
<a href="#l67.18"></a><span id="l67.18" class="difflineminus">-  </span>
<a href="#l67.19"></a><span id="l67.19" class="difflineminus">-  NS_IMETHOD CancelAndBreakThumb(nsIMdbEnv* ev);</span>
<a href="#l67.20"></a><span id="l67.20" class="difflineplus">+    mdb_count* outCurrent, mdb_bool* outDone, mdb_bool* outBroken) override;</span>
<a href="#l67.21"></a><span id="l67.21" class="difflineplus">+</span>
<a href="#l67.22"></a><span id="l67.22" class="difflineplus">+  NS_IMETHOD CancelAndBreakThumb(nsIMdbEnv* ev) override;</span>
<a href="#l67.23"></a><span id="l67.23"> // } ===== end nsIMdbThumb methods =====</span>
<a href="#l67.24"></a><span id="l67.24"> </span>
<a href="#l67.25"></a><span id="l67.25">   // might as well include all the return values here:</span>
<a href="#l67.26"></a><span id="l67.26">   </span>
<a href="#l67.27"></a><span id="l67.27">   mork_magic   mThumb_Magic;   // magic sig different in each thumb type</span>
<a href="#l67.28"></a><span id="l67.28">   mork_count   mThumb_Total;</span>
<a href="#l67.29"></a><span id="l67.29">   mork_count   mThumb_Current;</span>
<a href="#l67.30"></a><span id="l67.30"> </span>
<a href="#l67.31"></a><span id="l67.31" class="difflineat">@@ -87,18 +87,18 @@ public: // state is public because the e</span>
<a href="#l67.32"></a><span id="l67.32">   morkBuilder* mThumb_Builder;  // strong ref to builder (for store open)</span>
<a href="#l67.33"></a><span id="l67.33">   morkPort*    mThumb_SourcePort;  // strong ref to port for import</span>
<a href="#l67.34"></a><span id="l67.34">   </span>
<a href="#l67.35"></a><span id="l67.35">   mork_bool    mThumb_DoCollect; // influence whether a collect happens</span>
<a href="#l67.36"></a><span id="l67.36">   mork_bool    mThumb_Pad[ 3 ]; // padding for u4 alignment</span>
<a href="#l67.37"></a><span id="l67.37">   </span>
<a href="#l67.38"></a><span id="l67.38"> // { ===== begin morkNode interface =====</span>
<a href="#l67.39"></a><span id="l67.39"> public: // morkNode virtual methods</span>
<a href="#l67.40"></a><span id="l67.40" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseThumb() only if open</span>
<a href="#l67.41"></a><span id="l67.41" class="difflineminus">-  </span>
<a href="#l67.42"></a><span id="l67.42" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseThumb() only if open</span>
<a href="#l67.43"></a><span id="l67.43" class="difflineplus">+</span>
<a href="#l67.44"></a><span id="l67.44"> public: // morkThumb construction &amp; destruction</span>
<a href="#l67.45"></a><span id="l67.45">   morkThumb(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l67.46"></a><span id="l67.46">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap, mork_magic inMagic);</span>
<a href="#l67.47"></a><span id="l67.47">   void CloseThumb(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l67.48"></a><span id="l67.48"> </span>
<a href="#l67.49"></a><span id="l67.49"> private: // copying is not allowed</span>
<a href="#l67.50"></a><span id="l67.50">   morkThumb(const morkThumb&amp; other);</span>
<a href="#l67.51"></a><span id="l67.51">   morkThumb&amp; operator=(const morkThumb&amp; other);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l68.1"></a><span id="l68.1" class="difflineminus">--- a/db/mork/src/morkUniqRowCursor.h</span>
<a href="#l68.2"></a><span id="l68.2" class="difflineplus">+++ b/db/mork/src/morkUniqRowCursor.h</span>
<a href="#l68.3"></a><span id="l68.3" class="difflineat">@@ -41,22 +41,22 @@ class morkUniqRowCursor : public morkTab</span>
<a href="#l68.4"></a><span id="l68.4">   // mork_seed  mCursor_Seed;</span>
<a href="#l68.5"></a><span id="l68.5">   // mork_pos   mCursor_Pos;</span>
<a href="#l68.6"></a><span id="l68.6">   // mork_bool  mCursor_DoFailOnSeedOutOfSync;</span>
<a href="#l68.7"></a><span id="l68.7">   // mork_u1    mCursor_Pad[ 3 ]; // explicitly pad to u4 alignment</span>
<a href="#l68.8"></a><span id="l68.8"> </span>
<a href="#l68.9"></a><span id="l68.9">   // morkTable*  mTableRowCursor_Table; // weak ref to table</span>
<a href="#l68.10"></a><span id="l68.10"> </span>
<a href="#l68.11"></a><span id="l68.11"> public: // state is public because the entire Mork system is private</span>
<a href="#l68.12"></a><span id="l68.12" class="difflineminus">-    </span>
<a href="#l68.13"></a><span id="l68.13" class="difflineplus">+</span>
<a href="#l68.14"></a><span id="l68.14"> // { ===== begin morkNode interface =====</span>
<a href="#l68.15"></a><span id="l68.15"> public: // morkNode virtual methods</span>
<a href="#l68.16"></a><span id="l68.16" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseUniqRowCursor()</span>
<a href="#l68.17"></a><span id="l68.17" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseUniqRowCursor()</span>
<a href="#l68.18"></a><span id="l68.18">   virtual ~morkUniqRowCursor(); // assert that close executed earlier</span>
<a href="#l68.19"></a><span id="l68.19" class="difflineminus">-  </span>
<a href="#l68.20"></a><span id="l68.20" class="difflineplus">+</span>
<a href="#l68.21"></a><span id="l68.21"> public: // morkUniqRowCursor construction &amp; destruction</span>
<a href="#l68.22"></a><span id="l68.22">   morkUniqRowCursor(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l68.23"></a><span id="l68.23">     nsIMdbHeap* ioHeap, morkTable* ioTable, mork_pos inRowPos);</span>
<a href="#l68.24"></a><span id="l68.24">   void CloseUniqRowCursor(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l68.25"></a><span id="l68.25"> </span>
<a href="#l68.26"></a><span id="l68.26"> private: // copying is not allowed</span>
<a href="#l68.27"></a><span id="l68.27">   morkUniqRowCursor(const morkUniqRowCursor&amp; other);</span>
<a href="#l68.28"></a><span id="l68.28">   morkUniqRowCursor&amp; operator=(const morkUniqRowCursor&amp; other);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l69.1"></a><span id="l69.1" class="difflineminus">--- a/db/mork/src/morkWriter.cpp</span>
<a href="#l69.2"></a><span id="l69.2" class="difflineplus">+++ b/db/mork/src/morkWriter.cpp</span>
<a href="#l69.3"></a><span id="l69.3" class="difflineat">@@ -242,32 +242,27 @@ morkWriter::MakeWriterStream(morkEnv* ev</span>
<a href="#l69.4"></a><span id="l69.4">     else</span>
<a href="#l69.5"></a><span id="l69.5">       this-&gt;NilWriterFileError(ev);</span>
<a href="#l69.6"></a><span id="l69.6">   }</span>
<a href="#l69.7"></a><span id="l69.7"> }</span>
<a href="#l69.8"></a><span id="l69.8"> </span>
<a href="#l69.9"></a><span id="l69.9"> /*public non-poly*/ void</span>
<a href="#l69.10"></a><span id="l69.10"> morkWriter::CloseWriter(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l69.11"></a><span id="l69.11"> {</span>
<a href="#l69.12"></a><span id="l69.12" class="difflineminus">-  if ( this )</span>
<a href="#l69.13"></a><span id="l69.13" class="difflineminus">-  {</span>
<a href="#l69.14"></a><span id="l69.14">     if ( this-&gt;IsNode() )</span>
<a href="#l69.15"></a><span id="l69.15">     {</span>
<a href="#l69.16"></a><span id="l69.16">       morkStore::SlotWeakStore((morkStore*) 0, ev, &amp;mWriter_Store);</span>
<a href="#l69.17"></a><span id="l69.17">       nsIMdbFile_SlotStrongFile((nsIMdbFile*) 0, ev, &amp;mWriter_File);</span>
<a href="#l69.18"></a><span id="l69.18">       nsIMdbFile_SlotStrongFile((nsIMdbFile*) 0, ev, &amp;mWriter_Bud);</span>
<a href="#l69.19"></a><span id="l69.19">       morkStream::SlotStrongStream((morkStream*) 0, ev, &amp;mWriter_Stream);</span>
<a href="#l69.20"></a><span id="l69.20">       nsIMdbHeap_SlotStrongHeap((nsIMdbHeap*) 0, ev, &amp;mWriter_SlotHeap);</span>
<a href="#l69.21"></a><span id="l69.21">       this-&gt;MarkShut();</span>
<a href="#l69.22"></a><span id="l69.22">     }</span>
<a href="#l69.23"></a><span id="l69.23">     else</span>
<a href="#l69.24"></a><span id="l69.24">       this-&gt;NonNodeError(ev);</span>
<a href="#l69.25"></a><span id="l69.25" class="difflineminus">-  }</span>
<a href="#l69.26"></a><span id="l69.26" class="difflineminus">-  else</span>
<a href="#l69.27"></a><span id="l69.27" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l69.28"></a><span id="l69.28"> }</span>
<a href="#l69.29"></a><span id="l69.29"> </span>
<a href="#l69.30"></a><span id="l69.30"> // } ===== end morkNode methods =====</span>
<a href="#l69.31"></a><span id="l69.31"> // ````` ````` ````` ````` ````` </span>
<a href="#l69.32"></a><span id="l69.32"> </span>
<a href="#l69.33"></a><span id="l69.33"> /*static*/ void</span>
<a href="#l69.34"></a><span id="l69.34"> morkWriter::NonWriterTypeError(morkEnv* ev)</span>
<a href="#l69.35"></a><span id="l69.35"> {</span>
<a href="#l69.36"></a><span id="l69.36" class="difflineat">@@ -390,17 +385,17 @@ morkWriter::WriteYarn(morkEnv* ev, const</span>
<a href="#l69.37"></a><span id="l69.37"> </span>
<a href="#l69.38"></a><span id="l69.38">   mork_size outSize = 0;</span>
<a href="#l69.39"></a><span id="l69.39">   mork_size lineSize = mWriter_LineSize;</span>
<a href="#l69.40"></a><span id="l69.40">   morkStream* stream = mWriter_Stream;</span>
<a href="#l69.41"></a><span id="l69.41"> </span>
<a href="#l69.42"></a><span id="l69.42">   const mork_u1* b = (const mork_u1*) inYarn-&gt;mYarn_Buf;</span>
<a href="#l69.43"></a><span id="l69.43">   if ( b )</span>
<a href="#l69.44"></a><span id="l69.44">   {</span>
<a href="#l69.45"></a><span id="l69.45" class="difflineminus">-    register int c;</span>
<a href="#l69.46"></a><span id="l69.46" class="difflineplus">+    int c;</span>
<a href="#l69.47"></a><span id="l69.47">     mork_fill fill = inYarn-&gt;mYarn_Fill;</span>
<a href="#l69.48"></a><span id="l69.48"> </span>
<a href="#l69.49"></a><span id="l69.49">     const mork_u1* end = b + fill;</span>
<a href="#l69.50"></a><span id="l69.50">     while ( b &lt; end &amp;&amp; ev-&gt;Good() )</span>
<a href="#l69.51"></a><span id="l69.51">     {</span>
<a href="#l69.52"></a><span id="l69.52">       if ( lineSize + outSize &gt;= mWriter_MaxLine ) // continue line?</span>
<a href="#l69.53"></a><span id="l69.53">       {</span>
<a href="#l69.54"></a><span id="l69.54">         stream-&gt;PutByteThenNewline(ev, '\\');</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l70.1"></a><span id="l70.1" class="difflineminus">--- a/db/mork/src/morkWriter.h</span>
<a href="#l70.2"></a><span id="l70.2" class="difflineplus">+++ b/db/mork/src/morkWriter.h</span>
<a href="#l70.3"></a><span id="l70.3" class="difflineat">@@ -179,22 +179,22 @@ public: // state is public because the e</span>
<a href="#l70.4"></a><span id="l70.4">   morkRowSpaceMapIter  mWriter_StoreRowSpacesIter;    // for mStore_RowSpaces</span>
<a href="#l70.5"></a><span id="l70.5">   morkTableMapIter  mWriter_RowSpaceTablesIter;    // for mRowSpace_Tables</span>
<a href="#l70.6"></a><span id="l70.6">   </span>
<a href="#l70.7"></a><span id="l70.7"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l70.8"></a><span id="l70.8">   morkRowProbeMapIter  mWriter_RowSpaceRowsIter; // for mRowSpace_Rows</span>
<a href="#l70.9"></a><span id="l70.9"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l70.10"></a><span id="l70.10">   morkRowMapIter  mWriter_RowSpaceRowsIter;      // for mRowSpace_Rows</span>
<a href="#l70.11"></a><span id="l70.11"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l70.12"></a><span id="l70.12" class="difflineminus">-   </span>
<a href="#l70.13"></a><span id="l70.13" class="difflineplus">+</span>
<a href="#l70.14"></a><span id="l70.14"> // { ===== begin morkNode interface =====</span>
<a href="#l70.15"></a><span id="l70.15"> public: // morkNode virtual methods</span>
<a href="#l70.16"></a><span id="l70.16" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseWriter()</span>
<a href="#l70.17"></a><span id="l70.17" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseWriter()</span>
<a href="#l70.18"></a><span id="l70.18">   virtual ~morkWriter(); // assert that close executed earlier</span>
<a href="#l70.19"></a><span id="l70.19" class="difflineminus">-  </span>
<a href="#l70.20"></a><span id="l70.20" class="difflineplus">+</span>
<a href="#l70.21"></a><span id="l70.21"> public: // morkWriter construction &amp; destruction</span>
<a href="#l70.22"></a><span id="l70.22">   morkWriter(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l70.23"></a><span id="l70.23">     nsIMdbHeap* ioHeap, morkStore* ioStore, nsIMdbFile* ioFile,</span>
<a href="#l70.24"></a><span id="l70.24">     nsIMdbHeap* ioSlotHeap);</span>
<a href="#l70.25"></a><span id="l70.25">   void CloseWriter(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l70.26"></a><span id="l70.26"> </span>
<a href="#l70.27"></a><span id="l70.27"> private: // copying is not allowed</span>
<a href="#l70.28"></a><span id="l70.28">   morkWriter(const morkWriter&amp; other);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l71.1"></a><span id="l71.1" class="difflineminus">--- a/db/mork/src/morkYarn.cpp</span>
<a href="#l71.2"></a><span id="l71.2" class="difflineplus">+++ b/db/mork/src/morkYarn.cpp</span>
<a href="#l71.3"></a><span id="l71.3" class="difflineat">@@ -52,25 +52,20 @@ morkYarn::morkYarn(morkEnv* ev, /*i*/</span>
<a href="#l71.4"></a><span id="l71.4"> {</span>
<a href="#l71.5"></a><span id="l71.5">   if ( ev-&gt;Good() )</span>
<a href="#l71.6"></a><span id="l71.6">     mNode_Derived = morkDerived_kYarn;</span>
<a href="#l71.7"></a><span id="l71.7"> }</span>
<a href="#l71.8"></a><span id="l71.8"> </span>
<a href="#l71.9"></a><span id="l71.9"> /*public non-poly*/ void</span>
<a href="#l71.10"></a><span id="l71.10"> morkYarn::CloseYarn(morkEnv* ev) /*i*/ // called by CloseMorkNode();</span>
<a href="#l71.11"></a><span id="l71.11"> {</span>
<a href="#l71.12"></a><span id="l71.12" class="difflineminus">-  if ( this )</span>
<a href="#l71.13"></a><span id="l71.13" class="difflineminus">-  {</span>
<a href="#l71.14"></a><span id="l71.14">     if ( this-&gt;IsNode() )</span>
<a href="#l71.15"></a><span id="l71.15">       this-&gt;MarkShut();</span>
<a href="#l71.16"></a><span id="l71.16">     else</span>
<a href="#l71.17"></a><span id="l71.17">       this-&gt;NonNodeError(ev);</span>
<a href="#l71.18"></a><span id="l71.18" class="difflineminus">-  }</span>
<a href="#l71.19"></a><span id="l71.19" class="difflineminus">-  else</span>
<a href="#l71.20"></a><span id="l71.20" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l71.21"></a><span id="l71.21"> }</span>
<a href="#l71.22"></a><span id="l71.22"> </span>
<a href="#l71.23"></a><span id="l71.23"> // } ===== end morkNode methods =====</span>
<a href="#l71.24"></a><span id="l71.24"> // ````` ````` ````` ````` ````` </span>
<a href="#l71.25"></a><span id="l71.25"> </span>
<a href="#l71.26"></a><span id="l71.26"> /*static*/ void</span>
<a href="#l71.27"></a><span id="l71.27"> morkYarn::NonYarnTypeError(morkEnv* ev)</span>
<a href="#l71.28"></a><span id="l71.28"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l72.1"></a><span id="l72.1" class="difflineminus">--- a/db/mork/src/morkYarn.h</span>
<a href="#l72.2"></a><span id="l72.2" class="difflineplus">+++ b/db/mork/src/morkYarn.h</span>
<a href="#l72.3"></a><span id="l72.3" class="difflineat">@@ -33,22 +33,22 @@ class morkYarn : public morkNode { // re</span>
<a href="#l72.4"></a><span id="l72.4">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l72.5"></a><span id="l72.5">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l72.6"></a><span id="l72.6">   </span>
<a href="#l72.7"></a><span id="l72.7">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l72.8"></a><span id="l72.8">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l72.9"></a><span id="l72.9"> </span>
<a href="#l72.10"></a><span id="l72.10"> public: // state is public because the entire Mork system is private</span>
<a href="#l72.11"></a><span id="l72.11">   mdbYarn  mYarn_Body;</span>
<a href="#l72.12"></a><span id="l72.12" class="difflineminus">-  </span>
<a href="#l72.13"></a><span id="l72.13" class="difflineplus">+</span>
<a href="#l72.14"></a><span id="l72.14"> // { ===== begin morkNode interface =====</span>
<a href="#l72.15"></a><span id="l72.15"> public: // morkNode virtual methods</span>
<a href="#l72.16"></a><span id="l72.16" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseYarn() only if open</span>
<a href="#l72.17"></a><span id="l72.17" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseYarn() only if open</span>
<a href="#l72.18"></a><span id="l72.18">   virtual ~morkYarn(); // assert that CloseYarn() executed earlier</span>
<a href="#l72.19"></a><span id="l72.19" class="difflineminus">-  </span>
<a href="#l72.20"></a><span id="l72.20" class="difflineplus">+</span>
<a href="#l72.21"></a><span id="l72.21"> public: // morkYarn construction &amp; destruction</span>
<a href="#l72.22"></a><span id="l72.22">   morkYarn(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap);</span>
<a href="#l72.23"></a><span id="l72.23">   void CloseYarn(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l72.24"></a><span id="l72.24"> </span>
<a href="#l72.25"></a><span id="l72.25"> private: // copying is not allowed</span>
<a href="#l72.26"></a><span id="l72.26">   morkYarn(const morkYarn&amp; other);</span>
<a href="#l72.27"></a><span id="l72.27">   morkYarn&amp; operator=(const morkYarn&amp; other);</span>
<a href="#l72.28"></a><span id="l72.28"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l73.1"></a><span id="l73.1" class="difflineminus">--- a/db/mork/src/morkZone.cpp</span>
<a href="#l73.2"></a><span id="l73.2" class="difflineplus">+++ b/db/mork/src/morkZone.cpp</span>
<a href="#l73.3"></a><span id="l73.3" class="difflineat">@@ -82,18 +82,16 @@ morkZone::morkZone(morkEnv* ev, const mo</span>
<a href="#l73.4"></a><span id="l73.4">     }</span>
<a href="#l73.5"></a><span id="l73.5">     else</span>
<a href="#l73.6"></a><span id="l73.6">       ev-&gt;NilPointerError();</span>
<a href="#l73.7"></a><span id="l73.7">   }</span>
<a href="#l73.8"></a><span id="l73.8"> }</span>
<a href="#l73.9"></a><span id="l73.9"> </span>
<a href="#l73.10"></a><span id="l73.10"> void morkZone::CloseZone(morkEnv* ev) // called by CloseMorkNode()</span>
<a href="#l73.11"></a><span id="l73.11"> {</span>
<a href="#l73.12"></a><span id="l73.12" class="difflineminus">-  if ( this )</span>
<a href="#l73.13"></a><span id="l73.13" class="difflineminus">-  {</span>
<a href="#l73.14"></a><span id="l73.14">     if ( this-&gt;IsNode() )</span>
<a href="#l73.15"></a><span id="l73.15">     {</span>
<a href="#l73.16"></a><span id="l73.16">       nsIMdbHeap* heap = mZone_Heap;</span>
<a href="#l73.17"></a><span id="l73.17">       if ( heap )</span>
<a href="#l73.18"></a><span id="l73.18">       {</span>
<a href="#l73.19"></a><span id="l73.19">         morkHunk* hunk = 0;</span>
<a href="#l73.20"></a><span id="l73.20">         nsIMdbEnv* mev = ev-&gt;AsMdbEnv();</span>
<a href="#l73.21"></a><span id="l73.21">         </span>
<a href="#l73.22"></a><span id="l73.22" class="difflineat">@@ -109,19 +107,16 @@ void morkZone::CloseZone(morkEnv* ev) //</span>
<a href="#l73.23"></a><span id="l73.23">           heap-&gt;Free(mev, hunk);</span>
<a href="#l73.24"></a><span id="l73.24">         }</span>
<a href="#l73.25"></a><span id="l73.25">       }</span>
<a href="#l73.26"></a><span id="l73.26">       nsIMdbHeap_SlotStrongHeap((nsIMdbHeap*) 0, ev, &amp;mZone_Heap);</span>
<a href="#l73.27"></a><span id="l73.27">       this-&gt;MarkShut();</span>
<a href="#l73.28"></a><span id="l73.28">     }</span>
<a href="#l73.29"></a><span id="l73.29">     else</span>
<a href="#l73.30"></a><span id="l73.30">       this-&gt;NonNodeError(ev);</span>
<a href="#l73.31"></a><span id="l73.31" class="difflineminus">-  }</span>
<a href="#l73.32"></a><span id="l73.32" class="difflineminus">-  else</span>
<a href="#l73.33"></a><span id="l73.33" class="difflineminus">-    ev-&gt;NilPointerError();</span>
<a href="#l73.34"></a><span id="l73.34"> }</span>
<a href="#l73.35"></a><span id="l73.35"> </span>
<a href="#l73.36"></a><span id="l73.36"> // } ===== end morkNode methods =====</span>
<a href="#l73.37"></a><span id="l73.37"> </span>
<a href="#l73.38"></a><span id="l73.38"> /*static*/ void</span>
<a href="#l73.39"></a><span id="l73.39"> morkZone::NonZoneTypeError(morkEnv* ev)</span>
<a href="#l73.40"></a><span id="l73.40"> {</span>
<a href="#l73.41"></a><span id="l73.41">   ev-&gt;NewError(&quot;non morkZone&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l74.1"></a><span id="l74.1" class="difflineminus">--- a/db/mork/src/morkZone.h</span>
<a href="#l74.2"></a><span id="l74.2" class="difflineplus">+++ b/db/mork/src/morkZone.h</span>
<a href="#l74.3"></a><span id="l74.3" class="difflineat">@@ -270,29 +270,29 @@ protected: // zone utilities</span>
<a href="#l74.4"></a><span id="l74.4"> </span>
<a href="#l74.5"></a><span id="l74.5">   void*     zone_new_chip(morkEnv* ev, mdb_size inSize); // alloc  </span>
<a href="#l74.6"></a><span id="l74.6">   morkHunk* zone_new_hunk(morkEnv* ev, mdb_size inRunSize); // alloc  </span>
<a href="#l74.7"></a><span id="l74.7"> </span>
<a href="#l74.8"></a><span id="l74.8"> // { ===== begin nsIMdbHeap methods =====</span>
<a href="#l74.9"></a><span id="l74.9"> public:</span>
<a href="#l74.10"></a><span id="l74.10">   NS_IMETHOD Alloc(nsIMdbEnv* ev, // allocate a piece of memory</span>
<a href="#l74.11"></a><span id="l74.11">     mdb_size inSize,   // requested size of new memory block </span>
<a href="#l74.12"></a><span id="l74.12" class="difflineminus">-    void** outBlock);  // memory block of inSize bytes, or nil</span>
<a href="#l74.13"></a><span id="l74.13" class="difflineplus">+    void** outBlock) override; // memory block of inSize bytes, or nil</span>
<a href="#l74.14"></a><span id="l74.14">     </span>
<a href="#l74.15"></a><span id="l74.15">   NS_IMETHOD Free(nsIMdbEnv* ev, // free block allocated earlier by Alloc()</span>
<a href="#l74.16"></a><span id="l74.16" class="difflineminus">-    void* inBlock);</span>
<a href="#l74.17"></a><span id="l74.17" class="difflineplus">+    void* inBlock) override;</span>
<a href="#l74.18"></a><span id="l74.18"> </span>
<a href="#l74.19"></a><span id="l74.19" class="difflineminus">-  virtual size_t GetUsedSize() { return mZone_Heap-&gt;GetUsedSize(); }</span>
<a href="#l74.20"></a><span id="l74.20" class="difflineplus">+  virtual size_t GetUsedSize() override { return mZone_Heap-&gt;GetUsedSize(); }</span>
<a href="#l74.21"></a><span id="l74.21"> // } ===== end nsIMdbHeap methods =====</span>
<a href="#l74.22"></a><span id="l74.22" class="difflineminus">-  </span>
<a href="#l74.23"></a><span id="l74.23" class="difflineplus">+</span>
<a href="#l74.24"></a><span id="l74.24"> // { ===== begin morkNode interface =====</span>
<a href="#l74.25"></a><span id="l74.25"> public: // morkNode virtual methods</span>
<a href="#l74.26"></a><span id="l74.26" class="difflineminus">-  virtual void CloseMorkNode(morkEnv* ev); // CloseZone() only if open</span>
<a href="#l74.27"></a><span id="l74.27" class="difflineplus">+  virtual void CloseMorkNode(morkEnv* ev) override; // CloseZone() only if open</span>
<a href="#l74.28"></a><span id="l74.28">   virtual ~morkZone(); // assert that CloseMap() executed earlier</span>
<a href="#l74.29"></a><span id="l74.29" class="difflineminus">-  </span>
<a href="#l74.30"></a><span id="l74.30" class="difflineplus">+</span>
<a href="#l74.31"></a><span id="l74.31"> public: // morkMap construction &amp; destruction</span>
<a href="#l74.32"></a><span id="l74.32">   morkZone(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioNodeHeap, </span>
<a href="#l74.33"></a><span id="l74.33">     nsIMdbHeap* ioZoneHeap);</span>
<a href="#l74.34"></a><span id="l74.34">   </span>
<a href="#l74.35"></a><span id="l74.35">   void CloseZone(morkEnv* ev); // called by CloseMorkNode()</span>
<a href="#l74.36"></a><span id="l74.36">   </span>
<a href="#l74.37"></a><span id="l74.37"> public: // dynamic type identification</span>
<a href="#l74.38"></a><span id="l74.38">   mork_bool IsZone() const</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

