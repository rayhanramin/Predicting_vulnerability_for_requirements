<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 991:11ad0ebad23c57a9dd2b33bb9510d57d60ade2be</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 11ad0ebad23c57a9dd2b33bb9510d57d60ade2be" />
<meta property="og:url" content="/comm-central/rev/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be" />
<meta property="og:description" content="fix-up autocomplete logic, also resolving some bugs in grokNounItem, plus" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 11ad0ebad23c57a9dd2b33bb9510d57d60ade2be 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be">shortlog</a> |
<a href="/comm-central/log/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be">files</a> |
changeset |
<a href="/comm-central/raw-rev/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be">raw</a>  | <a href="/comm-central/archive/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
fix-up autocomplete logic, also resolving some bugs in grokNounItem, plus
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Sun, 26 Oct 2008 05:44:48 -0700</td></tr>

<tr>
 <td>changeset 991</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be">11ad0ebad23c57a9dd2b33bb9510d57d60ade2be</a></td>
</tr>



<tr>
<td>parent 990</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/16c6a95db57ed5db0a990778ce6a93d64e7c11d9">16c6a95db57ed5db0a990778ce6a93d64e7c11d9</a>
</td>
</tr>

<tr>
<td>child 992</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/da619e0bce23fc1cac3ce56aa9dc183ae18a5df5">da619e0bce23fc1cac3ce56aa9dc183ae18a5df5</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=11ad0ebad23c57a9dd2b33bb9510d57d60ade2be">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">fix-up autocomplete logic, also resolving some bugs in grokNounItem, plus
other minor fixes.  Autocompletion of tagged contacts works again now (it was
indexing of them that was broken, though.)</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/components/glautocomp.js">components/glautocomp.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/components/glautocomp.js">file</a> |
<a href="/comm-central/annotate/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/components/glautocomp.js">annotate</a> |
<a href="/comm-central/diff/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/components/glautocomp.js">diff</a> |
<a href="/comm-central/comparison/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/components/glautocomp.js">comparison</a> |
<a href="/comm-central/log/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/components/glautocomp.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/explattr.js">modules/explattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/explattr.js">file</a> |
<a href="/comm-central/annotate/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/explattr.js">annotate</a> |
<a href="/comm-central/diff/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/explattr.js">diff</a> |
<a href="/comm-central/comparison/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/explattr.js">comparison</a> |
<a href="/comm-central/log/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/explattr.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/index_ab.js">modules/index_ab.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/index_ab.js">file</a> |
<a href="/comm-central/annotate/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/index_ab.js">annotate</a> |
<a href="/comm-central/diff/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/index_ab.js">diff</a> |
<a href="/comm-central/comparison/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/index_ab.js">comparison</a> |
<a href="/comm-central/log/11ad0ebad23c57a9dd2b33bb9510d57d60ade2be/modules/index_ab.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/components/glautocomp.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/components/glautocomp.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -67,21 +67,21 @@ function ResultRowMulti(aNounID, aCriter</span>
<a href="#l1.4"></a><span id="l1.4">   this.criteriaType = aCriteriaType;</span>
<a href="#l1.5"></a><span id="l1.5">   this.criteria = aCriteria;</span>
<a href="#l1.6"></a><span id="l1.6">   this.collection = aQuery.getCollection(this);</span>
<a href="#l1.7"></a><span id="l1.7">   this.renderer = null;</span>
<a href="#l1.8"></a><span id="l1.8"> }</span>
<a href="#l1.9"></a><span id="l1.9"> ResultRowMulti.prototype = {</span>
<a href="#l1.10"></a><span id="l1.10">   multi: true,</span>
<a href="#l1.11"></a><span id="l1.11">   onItemsAdded: function(aItems) {</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-    LOG.debug(&quot;onItemsAdded&quot;);</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+    LOG.debug(&quot;RRM onItemsAdded: &quot; + aItems.length + &quot;: &quot; + aItems);</span>
<a href="#l1.14"></a><span id="l1.14">     if (this.renderer) {</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineminus">-      LOG.debug(&quot;rendering...&quot;);</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+      LOG.debug(&quot;RRM rendering...&quot;);</span>
<a href="#l1.17"></a><span id="l1.17">       for each (let [iItem, item] in Iterator(aItems)) {</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineminus">-        LOG.debug(&quot; ...&quot; + item);</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+        LOG.debug(&quot;RRM ...&quot; + item);</span>
<a href="#l1.20"></a><span id="l1.20">         this.renderer.renderItem(item);</span>
<a href="#l1.21"></a><span id="l1.21">       }</span>
<a href="#l1.22"></a><span id="l1.22">     }</span>
<a href="#l1.23"></a><span id="l1.23">   },</span>
<a href="#l1.24"></a><span id="l1.24">   onItemsModified: function(aItems) {</span>
<a href="#l1.25"></a><span id="l1.25">   },</span>
<a href="#l1.26"></a><span id="l1.26">   onItemsRemoved: function(aItems) {</span>
<a href="#l1.27"></a><span id="l1.27">   },</span>
<a href="#l1.28"></a><span id="l1.28" class="difflineat">@@ -194,18 +194,20 @@ dump(&quot;cq.limit: &quot; + contactQuery.limit +</span>
<a href="#l1.29"></a><span id="l1.29"> }</span>
<a href="#l1.30"></a><span id="l1.30"> ContactIdentityCompleter.prototype = {</span>
<a href="#l1.31"></a><span id="l1.31">   _popularitySorter: function(a, b){ return b.popularity - a.popularity; },</span>
<a href="#l1.32"></a><span id="l1.32">   complete: function ContactIdentityCompleter_complete(aResult, aString) {</span>
<a href="#l1.33"></a><span id="l1.33">     if (aString.length &lt; 3)</span>
<a href="#l1.34"></a><span id="l1.34">       return false;</span>
<a href="#l1.35"></a><span id="l1.35"> </span>
<a href="#l1.36"></a><span id="l1.36">     let matches;</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineminus">-    if (this.suffixTree)</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineplus">+    if (this.suffixTree) {</span>
<a href="#l1.39"></a><span id="l1.39">       matches = this.suffixTree.findMatches(aString.toLowerCase());</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineplus">+      LOG.debug(&quot;CIC: Suffix Tree found &quot; + matches.length + &quot; matches.&quot;)</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineplus">+    }</span>
<a href="#l1.42"></a><span id="l1.42">     else</span>
<a href="#l1.43"></a><span id="l1.43">       matches = [];</span>
<a href="#l1.44"></a><span id="l1.44"> </span>
<a href="#l1.45"></a><span id="l1.45">     // let's filter out duplicates due to identity/contact double-hits by</span>
<a href="#l1.46"></a><span id="l1.46">     //  establishing a map based on the contact id for these guys.</span>
<a href="#l1.47"></a><span id="l1.47">     // let's also favor identities as we do it, because that gets us the</span>
<a href="#l1.48"></a><span id="l1.48">     //  most accurate gravat, potentially</span>
<a href="#l1.49"></a><span id="l1.49">     let contactToThing = {};</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineat">@@ -223,38 +225,41 @@ ContactIdentityCompleter.prototype = {</span>
<a href="#l1.51"></a><span id="l1.51"> </span>
<a href="#l1.52"></a><span id="l1.52">     let rows = [new ResultRowSingle(match, &quot;text&quot;, aResult.searchString)</span>
<a href="#l1.53"></a><span id="l1.53">                 for each ([iMatch, match] in Iterator(matches))];</span>
<a href="#l1.54"></a><span id="l1.54">     aResult.addRows(rows);</span>
<a href="#l1.55"></a><span id="l1.55"> </span>
<a href="#l1.56"></a><span id="l1.56">     // - match against database contacts / identities</span>
<a href="#l1.57"></a><span id="l1.57">     let pending = {contactToThing: contactToThing, pendingCount: 2};</span>
<a href="#l1.58"></a><span id="l1.58">     </span>
<a href="#l1.59"></a><span id="l1.59" class="difflineplus">+    LOG.debug(&quot;CIC: issuing contact LIKE query&quot;);</span>
<a href="#l1.60"></a><span id="l1.60">     let contactQuery = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l1.61"></a><span id="l1.61" class="difflineminus">-    contactQuery.nameLike([contactQuery.WILD, aString, contactQuery.WILD]);</span>
<a href="#l1.62"></a><span id="l1.62" class="difflineplus">+    contactQuery.nameLike(contactQuery.WILD, aString, contactQuery.WILD);</span>
<a href="#l1.63"></a><span id="l1.63">     pending.contactColl = contactQuery.getCollection(this, aResult);</span>
<a href="#l1.64"></a><span id="l1.64"> </span>
<a href="#l1.65"></a><span id="l1.65" class="difflineplus">+    LOG.debug(&quot;CIC: issuing identity LIKE query&quot;);</span>
<a href="#l1.66"></a><span id="l1.66">     let identityQuery = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineminus">-    identityQuery.kind(&quot;email&quot;).valueLike([identityQuery.WILD, aString,</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineminus">-        identityQuery.WILD]);</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineplus">+    identityQuery.kind(&quot;email&quot;).valueLike(identityQuery.WILD, aString,</span>
<a href="#l1.70"></a><span id="l1.70" class="difflineplus">+        identityQuery.WILD);</span>
<a href="#l1.71"></a><span id="l1.71">     pending.identityColl = identityQuery.getCollection(this, aResult);</span>
<a href="#l1.72"></a><span id="l1.72">     </span>
<a href="#l1.73"></a><span id="l1.73">     aResult._contactCompleterPending = pending;</span>
<a href="#l1.74"></a><span id="l1.74"> </span>
<a href="#l1.75"></a><span id="l1.75">     return true;</span>
<a href="#l1.76"></a><span id="l1.76">   },</span>
<a href="#l1.77"></a><span id="l1.77">   onItemsAdded: function(aItems, aCollection) {</span>
<a href="#l1.78"></a><span id="l1.78">   },</span>
<a href="#l1.79"></a><span id="l1.79">   onItemsModified: function(aItems, aCollection) {</span>
<a href="#l1.80"></a><span id="l1.80">   },</span>
<a href="#l1.81"></a><span id="l1.81">   onItemsRemoved: function(aItems, aCollection) {</span>
<a href="#l1.82"></a><span id="l1.82">   },</span>
<a href="#l1.83"></a><span id="l1.83">   onQueryCompleted: function(aCollection) {</span>
<a href="#l1.84"></a><span id="l1.84">     // handle the initial setup case...</span>
<a href="#l1.85"></a><span id="l1.85">     if (aCollection.data == null) {</span>
<a href="#l1.86"></a><span id="l1.86" class="difflineplus">+      LOG.debug(&quot;CIC: Initial query found &quot; + aCollection.items.length);</span>
<a href="#l1.87"></a><span id="l1.87">       // cheat and explicitly add our own contact...</span>
<a href="#l1.88"></a><span id="l1.88">       if (!(Gloda.myContact.id in this.contactCollection._idMap))</span>
<a href="#l1.89"></a><span id="l1.89">         this.contactCollection._onItemsAdded([Gloda.myContact]);</span>
<a href="#l1.90"></a><span id="l1.90">         </span>
<a href="#l1.91"></a><span id="l1.91">       // the set of identities owned by the contacts is automatically loaded as part</span>
<a href="#l1.92"></a><span id="l1.92">       //  of the contact loading...</span>
<a href="#l1.93"></a><span id="l1.93">       this.identityCollection =</span>
<a href="#l1.94"></a><span id="l1.94">         this.contactCollection.subCollections[Gloda.NOUN_IDENTITY];</span>
<a href="#l1.95"></a><span id="l1.95" class="difflineat">@@ -265,16 +270,18 @@ ContactIdentityCompleter.prototype = {</span>
<a href="#l1.96"></a><span id="l1.96">                            ([, i] in Iterator(this.identityCollection.items))];</span>
<a href="#l1.97"></a><span id="l1.97"> </span>
<a href="#l1.98"></a><span id="l1.98">       this.suffixTree = new MultiSuffixTree(contactNames.concat(identityMails),</span>
<a href="#l1.99"></a><span id="l1.99">         this.contactCollection.items.concat(this.identityCollection.items));</span>
<a href="#l1.100"></a><span id="l1.100">       </span>
<a href="#l1.101"></a><span id="l1.101">       return;</span>
<a href="#l1.102"></a><span id="l1.102">     }</span>
<a href="#l1.103"></a><span id="l1.103">     </span>
<a href="#l1.104"></a><span id="l1.104" class="difflineplus">+    LOG.debug(&quot;CIC: LIKE query found &quot; + aCollection.items.length);</span>
<a href="#l1.105"></a><span id="l1.105" class="difflineplus">+    </span>
<a href="#l1.106"></a><span id="l1.106">     // handle the completion case</span>
<a href="#l1.107"></a><span id="l1.107">     let result = aCollection.data;</span>
<a href="#l1.108"></a><span id="l1.108">     let pending = result._contactCompleterPending;</span>
<a href="#l1.109"></a><span id="l1.109">     </span>
<a href="#l1.110"></a><span id="l1.110">     if (--pending.pendingCount == 0) {</span>
<a href="#l1.111"></a><span id="l1.111">       let possibleDudes = [];</span>
<a href="#l1.112"></a><span id="l1.112">       </span>
<a href="#l1.113"></a><span id="l1.113">       let contactToThing = pending.contactToThing;</span>
<a href="#l1.114"></a><span id="l1.114" class="difflineat">@@ -310,16 +317,19 @@ ContactIdentityCompleter.prototype = {</span>
<a href="#l1.115"></a><span id="l1.115">       result.markCompleted(this);</span>
<a href="#l1.116"></a><span id="l1.116">       </span>
<a href="#l1.117"></a><span id="l1.117">       // the collections no longer care about the result, make it clear.</span>
<a href="#l1.118"></a><span id="l1.118">       delete pending.identityColl.data;</span>
<a href="#l1.119"></a><span id="l1.119">       delete pending.contactColl.data;</span>
<a href="#l1.120"></a><span id="l1.120">       // the result object no longer needs us or our data</span>
<a href="#l1.121"></a><span id="l1.121">       delete result._contactCompleterPending;</span>
<a href="#l1.122"></a><span id="l1.122">     }</span>
<a href="#l1.123"></a><span id="l1.123" class="difflineplus">+    else {</span>
<a href="#l1.124"></a><span id="l1.124" class="difflineplus">+      LOG.debug(&quot;ignoring... pending is still: &quot; + pending.pendingCount);</span>
<a href="#l1.125"></a><span id="l1.125" class="difflineplus">+    }</span>
<a href="#l1.126"></a><span id="l1.126">   }</span>
<a href="#l1.127"></a><span id="l1.127"> };</span>
<a href="#l1.128"></a><span id="l1.128"> </span>
<a href="#l1.129"></a><span id="l1.129"> /**</span>
<a href="#l1.130"></a><span id="l1.130">  * Complete tags that are used on contacts.</span>
<a href="#l1.131"></a><span id="l1.131">  */</span>
<a href="#l1.132"></a><span id="l1.132"> function ContactTagCompleter() {</span>
<a href="#l1.133"></a><span id="l1.133">   this._buildSuffixTree();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -139,17 +139,17 @@ let QueryFromQueryResolver = {</span>
<a href="#l2.4"></a><span id="l2.4">     }</span>
<a href="#l2.5"></a><span id="l2.5">     </span>
<a href="#l2.6"></a><span id="l2.6">     let referencesByNounID = originColl.masterCollection.referencesByNounID;</span>
<a href="#l2.7"></a><span id="l2.7">     let inverseReferencesByNounID = </span>
<a href="#l2.8"></a><span id="l2.8">       originColl.masterCollection.inverseReferencesByNounID;</span>
<a href="#l2.9"></a><span id="l2.9"> </span>
<a href="#l2.10"></a><span id="l2.10">     if (originColl.pendingItems) {</span>
<a href="#l2.11"></a><span id="l2.11">       for (let [, item] in Iterator(originColl.pendingItems)) {</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-        //QFQ_LOG.debug(&quot;QFQR: loading deferred &quot; + item.NOUN_ID + &quot;:&quot; + item.id);</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+        QFQ_LOG.debug(&quot;QFQR: loading deferred &quot; + item.NOUN_ID + &quot;:&quot; + item.id);</span>
<a href="#l2.14"></a><span id="l2.14">         GlodaDatastore.loadNounDeferredDeps(item, referencesByNounID,</span>
<a href="#l2.15"></a><span id="l2.15">             inverseReferencesByNounID);</span>
<a href="#l2.16"></a><span id="l2.16">       }</span>
<a href="#l2.17"></a><span id="l2.17">       </span>
<a href="#l2.18"></a><span id="l2.18">       // we need to consider the possibility that we are racing a collection very</span>
<a href="#l2.19"></a><span id="l2.19">       //  much like our own.  as such, this means we need to perform cache</span>
<a href="#l2.20"></a><span id="l2.20">       //  unification as our last step.</span>
<a href="#l2.21"></a><span id="l2.21">       GlodaCollectionManager.cacheLoadUnify(originColl._nounDef.id,</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineat">@@ -222,18 +222,18 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l2.23"></a><span id="l2.23">     let row;</span>
<a href="#l2.24"></a><span id="l2.24">     let nounDef = this.nounDef;</span>
<a href="#l2.25"></a><span id="l2.25">     let nounID = nounDef.id;</span>
<a href="#l2.26"></a><span id="l2.26">     while (row = aResultSet.getNextRow()) {</span>
<a href="#l2.27"></a><span id="l2.27">       let item = nounDef.objFromRow.call(nounDef.datastore, row);</span>
<a href="#l2.28"></a><span id="l2.28">       // try and replace the item with one from the cache, if we can</span>
<a href="#l2.29"></a><span id="l2.29">       let cachedItem = GlodaCollectionManager.cacheLookupOne(nounID, item.id,</span>
<a href="#l2.30"></a><span id="l2.30">                                                              false);</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineminus">-      //QFQ_LOG.debug(&quot;loading item &quot; + nounDef.id + &quot;:&quot; + item.id + &quot; existing: &quot; +</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineminus">-      //    this.selfReferences[item.id] + &quot; cached: &quot; + cachedItem);</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineplus">+      QFQ_LOG.debug(&quot;loading item &quot; + nounDef.id + &quot;:&quot; + item.id + &quot; existing: &quot; +</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+          this.selfReferences[item.id] + &quot; cached: &quot; + cachedItem);</span>
<a href="#l2.35"></a><span id="l2.35">       if (cachedItem)</span>
<a href="#l2.36"></a><span id="l2.36">         item = cachedItem;</span>
<a href="#l2.37"></a><span id="l2.37">       // we may already have been loaded by this process</span>
<a href="#l2.38"></a><span id="l2.38">       else if (this.selfReferences[item.id] != null)</span>
<a href="#l2.39"></a><span id="l2.39">         item = this.selfReferences[item.id];</span>
<a href="#l2.40"></a><span id="l2.40">       // perform loading logic which may produce reference dependencies</span>
<a href="#l2.41"></a><span id="l2.41">       else</span>
<a href="#l2.42"></a><span id="l2.42">         this.needsLoads = </span>
<a href="#l2.43"></a><span id="l2.43" class="difflineat">@@ -1748,17 +1748,17 @@ var GlodaDatastore = {</span>
<a href="#l2.44"></a><span id="l2.44">          throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l2.45"></a><span id="l2.45">                this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l2.46"></a><span id="l2.46">                this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l2.47"></a><span id="l2.47">       }</span>
<a href="#l2.48"></a><span id="l2.48">     }</span>
<a href="#l2.49"></a><span id="l2.49"> </span>
<a href="#l2.50"></a><span id="l2.50">     // In completely abstract theory, this is where we would call</span>
<a href="#l2.51"></a><span id="l2.51">     //  GlodaCollectionManager.itemsModified, except that the attributes may</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineminus">-    //  also have changed, so it's out of our hands.  (Gloda.processMessage</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineplus">+    //  also have changed, so it's out of our hands.  (Gloda.grokNoun</span>
<a href="#l2.54"></a><span id="l2.54">     //  handles it.)</span>
<a href="#l2.55"></a><span id="l2.55">   },</span>
<a href="#l2.56"></a><span id="l2.56"> </span>
<a href="#l2.57"></a><span id="l2.57">   get _updateMessageLocationStatement() {</span>
<a href="#l2.58"></a><span id="l2.58">     let statement = this._createAsyncStatement(</span>
<a href="#l2.59"></a><span id="l2.59">       &quot;UPDATE messages SET folderID = ?1, messageKey = ?2 WHERE id = ?3&quot;);</span>
<a href="#l2.60"></a><span id="l2.60">     this.__defineGetter__(&quot;_updateMessageLocationStatement&quot;,</span>
<a href="#l2.61"></a><span id="l2.61">                           function() statement);</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineat">@@ -2197,16 +2197,17 @@ var GlodaDatastore = {</span>
<a href="#l2.63"></a><span id="l2.63">         dmas.bindInt64Parameter(2, aMessage.conversationID);</span>
<a href="#l2.64"></a><span id="l2.64">         dmas.bindInt64Parameter(3, aMessage.id);</span>
<a href="#l2.65"></a><span id="l2.65">         dmas.executeAsync(this.trackAsync());</span>
<a href="#l2.66"></a><span id="l2.66">       }</span>
<a href="#l2.67"></a><span id="l2.67"> </span>
<a href="#l2.68"></a><span id="l2.68">       this._commitTransaction();</span>
<a href="#l2.69"></a><span id="l2.69">     }</span>
<a href="#l2.70"></a><span id="l2.70">     catch (ex) {</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+      this._log.error(&quot;adjustMessageAttributes:&quot; + ex.lineNumber + &quot;: &quot; + eX);</span>
<a href="#l2.72"></a><span id="l2.72">       this._rollbackTransaction();</span>
<a href="#l2.73"></a><span id="l2.73">       throw ex;</span>
<a href="#l2.74"></a><span id="l2.74">     }</span>
<a href="#l2.75"></a><span id="l2.75">   },</span>
<a href="#l2.76"></a><span id="l2.76"> </span>
<a href="#l2.77"></a><span id="l2.77">   get _deleteMessageAttributesByMessageIDStatement() {</span>
<a href="#l2.78"></a><span id="l2.78">     let statement = this._createAsyncStatement(</span>
<a href="#l2.79"></a><span id="l2.79">       &quot;DELETE FROM messageAttributes WHERE messageID = ?1&quot;);</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineat">@@ -2328,16 +2329,17 @@ var GlodaDatastore = {</span>
<a href="#l2.81"></a><span id="l2.81">           das.bindDoubleParameter(1, attribValueTuple[1]);</span>
<a href="#l2.82"></a><span id="l2.82">         das.bindInt64Parameter(2, aItem.id);</span>
<a href="#l2.83"></a><span id="l2.83">         das.executeAsync(this.trackAsync());</span>
<a href="#l2.84"></a><span id="l2.84">       }</span>
<a href="#l2.85"></a><span id="l2.85"> </span>
<a href="#l2.86"></a><span id="l2.86">       this._commitTransaction();</span>
<a href="#l2.87"></a><span id="l2.87">     }</span>
<a href="#l2.88"></a><span id="l2.88">     catch (ex) {</span>
<a href="#l2.89"></a><span id="l2.89" class="difflineplus">+      this._log.error(&quot;adjustAttributes:&quot; + ex.lineNumber + &quot;: &quot; + eX);</span>
<a href="#l2.90"></a><span id="l2.90">       this._rollbackTransaction();</span>
<a href="#l2.91"></a><span id="l2.91">       throw ex;</span>
<a href="#l2.92"></a><span id="l2.92">     }</span>
<a href="#l2.93"></a><span id="l2.93">   },</span>
<a href="#l2.94"></a><span id="l2.94"> </span>
<a href="#l2.95"></a><span id="l2.95">   clearAttributes: function gloda_ds_clearAttributes(aItem) {</span>
<a href="#l2.96"></a><span id="l2.96">     let nounDef = aItem.NOUN_DEF;</span>
<a href="#l2.97"></a><span id="l2.97">     let dbMeta = nounMeta._dbMeta;</span>
<a href="#l2.98"></a><span id="l2.98" class="difflineat">@@ -2366,39 +2368,48 @@ var GlodaDatastore = {</span>
<a href="#l2.99"></a><span id="l2.99"> </span>
<a href="#l2.100"></a><span id="l2.100">   _convertToDBValuesAndGroupByAttributeID:</span>
<a href="#l2.101"></a><span id="l2.101">     function gloda_ds__convertToDBValuesAndGroupByAttributeID(aAttrDef,</span>
<a href="#l2.102"></a><span id="l2.102">                                                               aValues) {</span>
<a href="#l2.103"></a><span id="l2.103">     let objectNounDef = aAttrDef.objectNounDef;</span>
<a href="#l2.104"></a><span id="l2.104">     if (!aAttrDef.usesParameter) {</span>
<a href="#l2.105"></a><span id="l2.105">       let dbValues = [];</span>
<a href="#l2.106"></a><span id="l2.106">       for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l2.107"></a><span id="l2.107" class="difflineminus">-        dbValues.push(objectNounDef.toParamAndValue(aValues[iValue])[1]);</span>
<a href="#l2.108"></a><span id="l2.108" class="difflineplus">+        let dbValue = objectNounDef.toParamAndValue(aValues[iValue])[1];</span>
<a href="#l2.109"></a><span id="l2.109" class="difflineplus">+        if (dbValue != null)</span>
<a href="#l2.110"></a><span id="l2.110" class="difflineplus">+          dbValues.push(dbValue);</span>
<a href="#l2.111"></a><span id="l2.111">       }</span>
<a href="#l2.112"></a><span id="l2.112">       yield [aAttrDef.special ? undefined : aAttrDef.id, dbValues];</span>
<a href="#l2.113"></a><span id="l2.113">       return;</span>
<a href="#l2.114"></a><span id="l2.114">     }</span>
<a href="#l2.115"></a><span id="l2.115">     </span>
<a href="#l2.116"></a><span id="l2.116">     let curParam, attrID, dbValues;</span>
<a href="#l2.117"></a><span id="l2.117">     let attrDBDef = aAttrDef.dbDef;</span>
<a href="#l2.118"></a><span id="l2.118">     for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l2.119"></a><span id="l2.119">       let [dbParam, dbValue] = objectNounDef.toParamAndValue(aValues[iValue]);</span>
<a href="#l2.120"></a><span id="l2.120">       if (curParam === undefined) {</span>
<a href="#l2.121"></a><span id="l2.121">         curParam = dbParam;</span>
<a href="#l2.122"></a><span id="l2.122">         attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l2.123"></a><span id="l2.123" class="difflineminus">-        dbValues = [dbValue];</span>
<a href="#l2.124"></a><span id="l2.124" class="difflineplus">+        if (dbValue != null)</span>
<a href="#l2.125"></a><span id="l2.125" class="difflineplus">+          dbValues = [dbValue];</span>
<a href="#l2.126"></a><span id="l2.126" class="difflineplus">+        else</span>
<a href="#l2.127"></a><span id="l2.127" class="difflineplus">+          dbValues = [];</span>
<a href="#l2.128"></a><span id="l2.128">       }</span>
<a href="#l2.129"></a><span id="l2.129">       else if (curParam == dbParam) {</span>
<a href="#l2.130"></a><span id="l2.130" class="difflineminus">-        dbValues.push(dbValue);</span>
<a href="#l2.131"></a><span id="l2.131" class="difflineplus">+        if (dbValue != null)</span>
<a href="#l2.132"></a><span id="l2.132" class="difflineplus">+          dbValues.push(dbValue);</span>
<a href="#l2.133"></a><span id="l2.133">       }</span>
<a href="#l2.134"></a><span id="l2.134">       else {</span>
<a href="#l2.135"></a><span id="l2.135">         yield [attrID, dbValues];</span>
<a href="#l2.136"></a><span id="l2.136">         curParam = dbParam;</span>
<a href="#l2.137"></a><span id="l2.137">         attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l2.138"></a><span id="l2.138" class="difflineminus">-        dbValues = [dbValue];</span>
<a href="#l2.139"></a><span id="l2.139" class="difflineplus">+        if (dbValue != null)</span>
<a href="#l2.140"></a><span id="l2.140" class="difflineplus">+          dbValues = [dbValue];</span>
<a href="#l2.141"></a><span id="l2.141" class="difflineplus">+        else</span>
<a href="#l2.142"></a><span id="l2.142" class="difflineplus">+          dbValues = [];</span>
<a href="#l2.143"></a><span id="l2.143">       }</span>
<a href="#l2.144"></a><span id="l2.144">     }</span>
<a href="#l2.145"></a><span id="l2.145">     if (dbValues !== undefined)</span>
<a href="#l2.146"></a><span id="l2.146">       yield [attrID, dbValues];</span>
<a href="#l2.147"></a><span id="l2.147">   },</span>
<a href="#l2.148"></a><span id="l2.148"> </span>
<a href="#l2.149"></a><span id="l2.149">   _convertRangesToDBStringsAndGroupByAttributeID:</span>
<a href="#l2.150"></a><span id="l2.150">     function gloda_ds__convertRangesToDBStringsAndGroupByAttributeID(aAttrDef,</span>
<a href="#l2.151"></a><span id="l2.151" class="difflineat">@@ -2523,23 +2534,27 @@ var GlodaDatastore = {</span>
<a href="#l2.152"></a><span id="l2.152">           //  'a' is not a select but a list of id's... tricky, no?  </span>
<a href="#l2.153"></a><span id="l2.153">           select = constraintValues.join(&quot;,&quot;);</span>
<a href="#l2.154"></a><span id="l2.154">         }</span>
<a href="#l2.155"></a><span id="l2.155">         else if (constraintType === this.kConstraintIn) {</span>
<a href="#l2.156"></a><span id="l2.156">           let clauses = [];</span>
<a href="#l2.157"></a><span id="l2.157">           for each ([attrID, values] in</span>
<a href="#l2.158"></a><span id="l2.158">               this._convertToDBValuesAndGroupByAttributeID(attrDef,</span>
<a href="#l2.159"></a><span id="l2.159">                                                            constraintValues)) {</span>
<a href="#l2.160"></a><span id="l2.160" class="difflineplus">+            let clausePart;</span>
<a href="#l2.161"></a><span id="l2.161">             if (attrID !== undefined)</span>
<a href="#l2.162"></a><span id="l2.162" class="difflineminus">-              clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l2.163"></a><span id="l2.163" class="difflineminus">-                  &quot; AND &quot; + valueColumnName + &quot; IN (&quot; +</span>
<a href="#l2.164"></a><span id="l2.164" class="difflineminus">-                  values.join(&quot;,&quot;) + &quot;))&quot;);</span>
<a href="#l2.165"></a><span id="l2.165" class="difflineplus">+              clausePart = &quot;(attributeID = &quot; + attrID +</span>
<a href="#l2.166"></a><span id="l2.166" class="difflineplus">+                (values.length ? &quot; AND &quot; : &quot;&quot;);</span>
<a href="#l2.167"></a><span id="l2.167">             else</span>
<a href="#l2.168"></a><span id="l2.168" class="difflineminus">-              clauses.push(&quot;(&quot; + valueColumnName + &quot; IN (&quot; +</span>
<a href="#l2.169"></a><span id="l2.169" class="difflineminus">-                  values.join(&quot;,&quot;) + &quot;))&quot;);</span>
<a href="#l2.170"></a><span id="l2.170" class="difflineplus">+              clausePart = &quot;(&quot;;</span>
<a href="#l2.171"></a><span id="l2.171" class="difflineplus">+            if (values.length)</span>
<a href="#l2.172"></a><span id="l2.172" class="difflineplus">+              clausePart += valueColumnName + &quot; IN (&quot; + values.join(&quot;,&quot;) + &quot;))&quot;;</span>
<a href="#l2.173"></a><span id="l2.173" class="difflineplus">+            else</span>
<a href="#l2.174"></a><span id="l2.174" class="difflineplus">+              clausePart += &quot;)&quot;;</span>
<a href="#l2.175"></a><span id="l2.175" class="difflineplus">+            clauses.push(clausePart);</span>
<a href="#l2.176"></a><span id="l2.176">           }</span>
<a href="#l2.177"></a><span id="l2.177">           test = clauses.join(&quot; OR &quot;);</span>
<a href="#l2.178"></a><span id="l2.178">         }</span>
<a href="#l2.179"></a><span id="l2.179">         else if (constraintType === this.kConstraintRanges) {</span>
<a href="#l2.180"></a><span id="l2.180">           let clauses = [];</span>
<a href="#l2.181"></a><span id="l2.181">           for each ([attrID, dbStrings] in</span>
<a href="#l2.182"></a><span id="l2.182">               this._convertRangesToDBStringsAndGroupByAttributeID(attrDef,</span>
<a href="#l2.183"></a><span id="l2.183">                               constraintValues, valueColumnName)) {</span>
<a href="#l2.184"></a><span id="l2.184" class="difflineat">@@ -2881,18 +2896,16 @@ var GlodaDatastore = {</span>
<a href="#l2.185"></a><span id="l2.185">     if (aContact._jsonText)</span>
<a href="#l2.186"></a><span id="l2.186">       ics.bindStringParameter(6, aContact._jsonText);</span>
<a href="#l2.187"></a><span id="l2.187">     else</span>
<a href="#l2.188"></a><span id="l2.188">       ics.bindNullParameter(6);</span>
<a href="#l2.189"></a><span id="l2.189"> </span>
<a href="#l2.190"></a><span id="l2.190">     ics.executeAsync(this.trackAsync());</span>
<a href="#l2.191"></a><span id="l2.191">     this._log.debug(&quot;insertContact: &quot; + aContact.id + &quot;:&quot; + aContact.name);</span>
<a href="#l2.192"></a><span id="l2.192"> </span>
<a href="#l2.193"></a><span id="l2.193" class="difflineminus">-    // XXX caching-notifications-post-refactoring</span>
<a href="#l2.194"></a><span id="l2.194" class="difflineminus">-    GlodaCollectionManager.itemsAdded(aContact.NOUN_ID, [aContact]);</span>
<a href="#l2.195"></a><span id="l2.195">     return aContact;</span>
<a href="#l2.196"></a><span id="l2.196">   },</span>
<a href="#l2.197"></a><span id="l2.197"> </span>
<a href="#l2.198"></a><span id="l2.198">   get _updateContactStatement() {</span>
<a href="#l2.199"></a><span id="l2.199">     let statement = this._createAsyncStatement(</span>
<a href="#l2.200"></a><span id="l2.200">       &quot;UPDATE contacts SET directoryUUID = ?1, \</span>
<a href="#l2.201"></a><span id="l2.201">                            contactUUID = ?2, \</span>
<a href="#l2.202"></a><span id="l2.202">                            name = ?3, \</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/modules/explattr.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/modules/explattr.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -133,17 +133,17 @@ var GlodaExplicitAttr = {</span>
<a href="#l3.4"></a><span id="l3.4">                         }); // tested-by: test_attributes_explicit</span>
<a href="#l3.5"></a><span id="l3.5">     </span>
<a href="#l3.6"></a><span id="l3.6">   },</span>
<a href="#l3.7"></a><span id="l3.7">   </span>
<a href="#l3.8"></a><span id="l3.8">   process: function Gloda_explattr_process(aGlodaMessage, aRawReps, aIsNew,</span>
<a href="#l3.9"></a><span id="l3.9">                                            aCallbackHandle) {</span>
<a href="#l3.10"></a><span id="l3.10">     let aMsgHdr = aRawReps.header;</span>
<a href="#l3.11"></a><span id="l3.11">     </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-    aGlodaMessage.flagged = aMsgHdr.isFlagged;</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+    aGlodaMessage.starred = aMsgHdr.isFlagged;</span>
<a href="#l3.14"></a><span id="l3.14">     aGlodaMessage.read = aMsgHdr.isRead;</span>
<a href="#l3.15"></a><span id="l3.15">     </span>
<a href="#l3.16"></a><span id="l3.16">     let tags = aGlodaMessage.tags = [];</span>
<a href="#l3.17"></a><span id="l3.17">     </span>
<a href="#l3.18"></a><span id="l3.18">     // -- Tag</span>
<a href="#l3.19"></a><span id="l3.19">     // build a map of the keywords</span>
<a href="#l3.20"></a><span id="l3.20">     let keywords = aMsgHdr.getStringProperty(&quot;keywords&quot;);</span>
<a href="#l3.21"></a><span id="l3.21">     let keywordList = keywords.split(' ');</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -890,17 +890,17 @@ var Gloda = {</span>
<a href="#l4.4"></a><span id="l4.4">     this.defineNoun({</span>
<a href="#l4.5"></a><span id="l4.5">       name: &quot;contact&quot;,</span>
<a href="#l4.6"></a><span id="l4.6">       class: GlodaContact,</span>
<a href="#l4.7"></a><span id="l4.7">       allowsArbitraryAttrs: true,</span>
<a href="#l4.8"></a><span id="l4.8">       cache: true, cacheCost: 128,</span>
<a href="#l4.9"></a><span id="l4.9">       tableName: &quot;contacts&quot;,</span>
<a href="#l4.10"></a><span id="l4.10">       attrTableName: &quot;contactAttributes&quot;, attrIDColumnName: &quot;contactID&quot;,</span>
<a href="#l4.11"></a><span id="l4.11">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._contactFromRow,</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-      dbAttribAdjuster: GlodaDatastore.adjustMessageAttributes,</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+      dbAttribAdjuster: GlodaDatastore.adjustAttributes,</span>
<a href="#l4.14"></a><span id="l4.14">       objInsert: GlodaDatastore.insertContact,</span>
<a href="#l4.15"></a><span id="l4.15">       objUpdate: GlodaDatastore.updateContact,</span>
<a href="#l4.16"></a><span id="l4.16">       toParamAndValue: function(aContact) {</span>
<a href="#l4.17"></a><span id="l4.17">         if (aContact instanceof GlodaContact)</span>
<a href="#l4.18"></a><span id="l4.18">           return [null, aContact.id];</span>
<a href="#l4.19"></a><span id="l4.19">         else // assume they're just passing the id directly</span>
<a href="#l4.20"></a><span id="l4.20">           return [null, aContact];</span>
<a href="#l4.21"></a><span id="l4.21">       }}, this.NOUN_CONTACT);</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineat">@@ -1071,17 +1071,17 @@ var Gloda = {</span>
<a href="#l4.23"></a><span id="l4.23">       // (it is impossible to store a string as an indexed attribute, which is</span>
<a href="#l4.24"></a><span id="l4.24">       //  why we do this for on-row only.)</span>
<a href="#l4.25"></a><span id="l4.25">       if (aAttrDef.special == this.kSpecialString) {</span>
<a href="#l4.26"></a><span id="l4.26">         let likeConstrainer = function() {</span>
<a href="#l4.27"></a><span id="l4.27">           let constraint = [GlodaDatastore.kConstraintStringLike, aAttrDef];</span>
<a href="#l4.28"></a><span id="l4.28">           for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l4.29"></a><span id="l4.29">             constraint.push(arguments[iArg]);</span>
<a href="#l4.30"></a><span id="l4.30">           }</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineminus">-          this._constraints.push(constraints);</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+          this._constraints.push(constraint);</span>
<a href="#l4.33"></a><span id="l4.33">           return this;</span>
<a href="#l4.34"></a><span id="l4.34">         }</span>
<a href="#l4.35"></a><span id="l4.35"> </span>
<a href="#l4.36"></a><span id="l4.36">         aSubjectNounDef.queryClass.prototype[aAttrDef.boundName + &quot;Like&quot;] =</span>
<a href="#l4.37"></a><span id="l4.37">           likeConstrainer;</span>
<a href="#l4.38"></a><span id="l4.38">       }</span>
<a href="#l4.39"></a><span id="l4.39">     }</span>
<a href="#l4.40"></a><span id="l4.40">   },</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineat">@@ -1342,17 +1342,17 @@ var Gloda = {</span>
<a href="#l4.42"></a><span id="l4.42">    *  representations.</span>
<a href="#l4.43"></a><span id="l4.43">    *</span>
<a href="#l4.44"></a><span id="l4.44">    * The result of the processing ends up with attributes in 3 different forms:</span>
<a href="#l4.45"></a><span id="l4.45">    * - Database attribute rows (to be added and removed).</span>
<a href="#l4.46"></a><span id="l4.46">    * - In-memory representation.</span>
<a href="#l4.47"></a><span id="l4.47">    * - JSON-able representation.</span>
<a href="#l4.48"></a><span id="l4.48">    */</span>
<a href="#l4.49"></a><span id="l4.49">   grokNounItem: function gloda_ns_grokNounItem(aItem, aRawReps, aIsNew,</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineminus">-      aCallbackHandle) {</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineplus">+      aCallbackHandle, aDoCache) {</span>
<a href="#l4.52"></a><span id="l4.52">     let itemNounDef = this._nounIDToDef[aItem.NOUN_ID];</span>
<a href="#l4.53"></a><span id="l4.53">     let attribsByBoundName = itemNounDef.attribsByBoundName;</span>
<a href="#l4.54"></a><span id="l4.54">     </span>
<a href="#l4.55"></a><span id="l4.55">     this._log.info(&quot; ** grokNounItem: &quot; + itemNounDef.name);</span>
<a href="#l4.56"></a><span id="l4.56">     </span>
<a href="#l4.57"></a><span id="l4.57">     let addDBAttribs = [];</span>
<a href="#l4.58"></a><span id="l4.58">     let removeDBAttribs = [];</span>
<a href="#l4.59"></a><span id="l4.59">     </span>
<a href="#l4.60"></a><span id="l4.60" class="difflineat">@@ -1392,18 +1392,20 @@ var Gloda = {</span>
<a href="#l4.61"></a><span id="l4.61">       // ignore keys that start with underscores, they are private and not</span>
<a href="#l4.62"></a><span id="l4.62">       //  persisted by our attribute mechanism.  (they are directly handled by</span>
<a href="#l4.63"></a><span id="l4.63">       //  the object implementation.)</span>
<a href="#l4.64"></a><span id="l4.64">       if (key[0] == &quot;_&quot;)</span>
<a href="#l4.65"></a><span id="l4.65">         continue;</span>
<a href="#l4.66"></a><span id="l4.66">       // find the attribute definition that corresponds to this key</span>
<a href="#l4.67"></a><span id="l4.67">       let attrib = attribsByBoundName[key];</span>
<a href="#l4.68"></a><span id="l4.68">       // if there's no attribute, that's not good, but not horrible.</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineminus">-      if (attrib === undefined)</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineplus">+      if (attrib === undefined) {</span>
<a href="#l4.71"></a><span id="l4.71" class="difflineplus">+        this._log.warn(&quot;new proc ignoring attrib: &quot; + key);</span>
<a href="#l4.72"></a><span id="l4.72">         continue;</span>
<a href="#l4.73"></a><span id="l4.73" class="difflineplus">+      }</span>
<a href="#l4.74"></a><span id="l4.74"> </span>
<a href="#l4.75"></a><span id="l4.75">       let attribDB = attrib.dbDef;</span>
<a href="#l4.76"></a><span id="l4.76">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l4.77"></a><span id="l4.77">       </span>
<a href="#l4.78"></a><span id="l4.78">       // - translate for our JSON rep</span>
<a href="#l4.79"></a><span id="l4.79">       if (attrib.singular) {</span>
<a href="#l4.80"></a><span id="l4.80">         if (objectNounDef.toJSON)</span>
<a href="#l4.81"></a><span id="l4.81">           jsonDict[attrib.id] = objectNounDef.toJSON(value);</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineat">@@ -1440,97 +1442,124 @@ var Gloda = {</span>
<a href="#l4.83"></a><span id="l4.83">         //  possible changes in ordering (which is insignificant from an</span>
<a href="#l4.84"></a><span id="l4.84">         //  indexing perspective)</span>
<a href="#l4.85"></a><span id="l4.85">         // some nouns may not meet === equivalence needs, so must provide a</span>
<a href="#l4.86"></a><span id="l4.86">         //  custom computeDelta method to help us out</span>
<a href="#l4.87"></a><span id="l4.87">         else if (objectNounDef.computeDelta) {</span>
<a href="#l4.88"></a><span id="l4.88">           let [valuesAdded, valuesRemoved] = </span>
<a href="#l4.89"></a><span id="l4.89">             objectNounDef.computeDelta(value, oldValue);</span>
<a href="#l4.90"></a><span id="l4.90">           // convert the values to database-style attribute rows</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineminus">-          this._log.debug(&quot;%% want to add &quot; + valuesAdded + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineminus">-          this._log.debug(&quot;%% want to rem &quot; + valuesRemoved + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineplus">+          this._log.debug(&quot;%% cdelta want to add &quot; + valuesAdded + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineplus">+          this._log.debug(&quot;%% cdelta want to rem &quot; + valuesRemoved + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l4.95"></a><span id="l4.95">           addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l4.96"></a><span id="l4.96">             attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l4.97"></a><span id="l4.97">           removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l4.98"></a><span id="l4.98">             attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l4.99"></a><span id="l4.99">         }</span>
<a href="#l4.100"></a><span id="l4.100">         else {</span>
<a href="#l4.101"></a><span id="l4.101">           // build a map of the previous values; we will delete the values as</span>
<a href="#l4.102"></a><span id="l4.102">           //  we see them so that we will know what old values are no longer</span>
<a href="#l4.103"></a><span id="l4.103">           //  present in the current set of values.</span>
<a href="#l4.104"></a><span id="l4.104">           let oldValueMap = {};</span>
<a href="#l4.105"></a><span id="l4.105" class="difflineminus">-          for each (let [iAnOldValue, anOldValue] in Iterator(oldValue)) {</span>
<a href="#l4.106"></a><span id="l4.106" class="difflineminus">-            oldValueMap[anOldValue] = true;</span>
<a href="#l4.107"></a><span id="l4.107" class="difflineplus">+          for each (let [, anOldValue] in Iterator(oldValue)) {</span>
<a href="#l4.108"></a><span id="l4.108" class="difflineplus">+this._log.debug(&quot;  old traverse: &quot; + anOldValue);</span>
<a href="#l4.109"></a><span id="l4.109" class="difflineplus">+            // remember, the key is just the toString'ed value, so we need to</span>
<a href="#l4.110"></a><span id="l4.110" class="difflineplus">+            //  store and use the actual value as the value!</span>
<a href="#l4.111"></a><span id="l4.111" class="difflineplus">+            oldValueMap[anOldValue] = anOldValue;</span>
<a href="#l4.112"></a><span id="l4.112">           }</span>
<a href="#l4.113"></a><span id="l4.113">           // traverse the current values...</span>
<a href="#l4.114"></a><span id="l4.114">           let valuesAdded = [];</span>
<a href="#l4.115"></a><span id="l4.115" class="difflineminus">-          for each (let [iCurValue, curValue] in Iterator(value)) {</span>
<a href="#l4.116"></a><span id="l4.116" class="difflineplus">+          for each (let [, curValue] in Iterator(value)) {</span>
<a href="#l4.117"></a><span id="l4.117" class="difflineplus">+this._log.debug(&quot;  new traverse: &quot; + curValue);</span>
<a href="#l4.118"></a><span id="l4.118">             if (curValue in oldValueMap)</span>
<a href="#l4.119"></a><span id="l4.119">               delete oldValueMap[curValue];</span>
<a href="#l4.120"></a><span id="l4.120">             else</span>
<a href="#l4.121"></a><span id="l4.121">               valuesAdded.push(curValue);</span>
<a href="#l4.122"></a><span id="l4.122">           }</span>
<a href="#l4.123"></a><span id="l4.123">           // anything still on oldValueMap was removed.</span>
<a href="#l4.124"></a><span id="l4.124" class="difflineminus">-          let valuesRemoved = [val for (val in Iterator(oldValueMap, true))];</span>
<a href="#l4.125"></a><span id="l4.125" class="difflineplus">+          let valuesRemoved = [val for each (val in oldValueMap)];</span>
<a href="#l4.126"></a><span id="l4.126">           // convert the values to database-style attribute rows</span>
<a href="#l4.127"></a><span id="l4.127">           this._log.debug(&quot;%% want to add &quot; + valuesAdded + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l4.128"></a><span id="l4.128">           this._log.debug(&quot;%% want to rem &quot; + valuesRemoved + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l4.129"></a><span id="l4.129">           addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l4.130"></a><span id="l4.130">             attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l4.131"></a><span id="l4.131">           removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l4.132"></a><span id="l4.132">             attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l4.133"></a><span id="l4.133">         }</span>
<a href="#l4.134"></a><span id="l4.134">       </span>
<a href="#l4.135"></a><span id="l4.135" class="difflineminus">-        // delete the old values to mark that we have processed them</span>
<a href="#l4.136"></a><span id="l4.136" class="difflineminus">-        delete aOldItem[key];</span>
<a href="#l4.137"></a><span id="l4.137" class="difflineplus">+        // replace the old value with the new values... (the 'old' item is</span>
<a href="#l4.138"></a><span id="l4.138" class="difflineplus">+        //  canonical)</span>
<a href="#l4.139"></a><span id="l4.139" class="difflineplus">+        aOldItem[key] = value; </span>
<a href="#l4.140"></a><span id="l4.140">       }</span>
<a href="#l4.141"></a><span id="l4.141" class="difflineminus">-      // no old value, all attributes are new</span>
<a href="#l4.142"></a><span id="l4.142" class="difflineplus">+      // no old value, all values are new</span>
<a href="#l4.143"></a><span id="l4.143">       else {</span>
<a href="#l4.144"></a><span id="l4.144" class="difflineplus">+        // the 'old' item is still the canonical one; update it</span>
<a href="#l4.145"></a><span id="l4.145" class="difflineplus">+        if (!aIsNew)</span>
<a href="#l4.146"></a><span id="l4.146" class="difflineplus">+          aOldItem[key] = value;</span>
<a href="#l4.147"></a><span id="l4.147" class="difflineplus">+        // add the db reps on the new values</span>
<a href="#l4.148"></a><span id="l4.148">         if (attrib.singular)</span>
<a href="#l4.149"></a><span id="l4.149">           value = [value];</span>
<a href="#l4.150"></a><span id="l4.150" class="difflineminus">-        this._log.debug(&quot;%% want to add &quot; + value + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l4.151"></a><span id="l4.151" class="difflineplus">+        this._log.debug(&quot;%% no old, want to add &quot; + value + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l4.152"></a><span id="l4.152">         addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l4.153"></a><span id="l4.153">                                 attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l4.154"></a><span id="l4.154">       }</span>
<a href="#l4.155"></a><span id="l4.155">     }</span>
<a href="#l4.156"></a><span id="l4.156">     </span>
<a href="#l4.157"></a><span id="l4.157">     // Iterate over any remaining values in old items for purge purposes.</span>
<a href="#l4.158"></a><span id="l4.158">     for each (let [key, value] in Iterator(aOldItem)) {</span>
<a href="#l4.159"></a><span id="l4.159">       // ignore keys that start with underscores, they are private and not</span>
<a href="#l4.160"></a><span id="l4.160">       //  persisted by our attribute mechanism.  (they are directly handled by</span>
<a href="#l4.161"></a><span id="l4.161">       //  the object implementation.)</span>
<a href="#l4.162"></a><span id="l4.162">       if (key[0] == &quot;_&quot;)</span>
<a href="#l4.163"></a><span id="l4.163">         continue;</span>
<a href="#l4.164"></a><span id="l4.164" class="difflineplus">+      // ignore things we saw in the new guy</span>
<a href="#l4.165"></a><span id="l4.165" class="difflineplus">+      if (key in aItem)</span>
<a href="#l4.166"></a><span id="l4.166" class="difflineplus">+        continue;</span>
<a href="#l4.167"></a><span id="l4.167" class="difflineplus">+      </span>
<a href="#l4.168"></a><span id="l4.168">       // find the attribute definition that corresponds to this key</span>
<a href="#l4.169"></a><span id="l4.169">       let attrib = attribsByBoundName[key];</span>
<a href="#l4.170"></a><span id="l4.170" class="difflineplus">+      // if there's no attribute, that's not good, but not horrible.</span>
<a href="#l4.171"></a><span id="l4.171" class="difflineplus">+      if (attrib === undefined) {</span>
<a href="#l4.172"></a><span id="l4.172" class="difflineplus">+        this._log.warn(&quot;old proc ignoring attrib: &quot; + key);</span>
<a href="#l4.173"></a><span id="l4.173" class="difflineplus">+        continue;</span>
<a href="#l4.174"></a><span id="l4.174" class="difflineplus">+      }</span>
<a href="#l4.175"></a><span id="l4.175">       let attribDB = attrib.dbDef;</span>
<a href="#l4.176"></a><span id="l4.176" class="difflineminus">-      // if there's no attribute, that's not good, but not horrible.</span>
<a href="#l4.177"></a><span id="l4.177" class="difflineminus">-      if (attrib === undefined)</span>
<a href="#l4.178"></a><span id="l4.178" class="difflineminus">-        continue;</span>
<a href="#l4.179"></a><span id="l4.179">       this._log.debug(&quot;%% want to remove &quot; + value + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l4.180"></a><span id="l4.180">       removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l4.181"></a><span id="l4.181">                                  attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l4.182"></a><span id="l4.182" class="difflineplus">+      // delete these from the old item, as the old item is canonical, and</span>
<a href="#l4.183"></a><span id="l4.183" class="difflineplus">+      //  should no longer have these values</span>
<a href="#l4.184"></a><span id="l4.184" class="difflineplus">+      delete aOldItem[key];</span>
<a href="#l4.185"></a><span id="l4.185">     }</span>
<a href="#l4.186"></a><span id="l4.186">     </span>
<a href="#l4.187"></a><span id="l4.187">     aItem._jsonText = this._json.encode(jsonDict);</span>
<a href="#l4.188"></a><span id="l4.188">     this._log.debug(&quot;  json text: &quot; + aItem._jsonText);</span>
<a href="#l4.189"></a><span id="l4.189">     </span>
<a href="#l4.190"></a><span id="l4.190">     if (aIsNew) {</span>
<a href="#l4.191"></a><span id="l4.191">       this._log.debug(&quot; inserting item&quot;);</span>
<a href="#l4.192"></a><span id="l4.192">       itemNounDef.objInsert.call(itemNounDef.datastore, aItem);</span>
<a href="#l4.193"></a><span id="l4.193">     }</span>
<a href="#l4.194"></a><span id="l4.194">     else {</span>
<a href="#l4.195"></a><span id="l4.195">       this._log.debug(&quot; updating item&quot;);</span>
<a href="#l4.196"></a><span id="l4.196">       itemNounDef.objUpdate.call(itemNounDef.datastore, aItem);</span>
<a href="#l4.197"></a><span id="l4.197">     }</span>
<a href="#l4.198"></a><span id="l4.198">     </span>
<a href="#l4.199"></a><span id="l4.199" class="difflineminus">-    this._log.debug(&quot; adjusting attributes&quot;);</span>
<a href="#l4.200"></a><span id="l4.200" class="difflineplus">+    this._log.debug(&quot; adjusting attributes, add: &quot; + addDBAttribs + &quot; rem: &quot; +</span>
<a href="#l4.201"></a><span id="l4.201" class="difflineplus">+        removeDBAttribs);</span>
<a href="#l4.202"></a><span id="l4.202">     itemNounDef.dbAttribAdjuster.call(itemNounDef.datastore, aItem,</span>
<a href="#l4.203"></a><span id="l4.203">       addDBAttribs, removeDBAttribs);</span>
<a href="#l4.204"></a><span id="l4.204">     </span>
<a href="#l4.205"></a><span id="l4.205" class="difflineplus">+    // Cache ramifications...</span>
<a href="#l4.206"></a><span id="l4.206" class="difflineplus">+    if (aDoCache === undefined || aDoCache) {</span>
<a href="#l4.207"></a><span id="l4.207" class="difflineplus">+      if (aIsNew)</span>
<a href="#l4.208"></a><span id="l4.208" class="difflineplus">+        GlodaCollectionManager.itemsAdded(aItem.NOUN_ID, [aItem]);</span>
<a href="#l4.209"></a><span id="l4.209" class="difflineplus">+      else</span>
<a href="#l4.210"></a><span id="l4.210" class="difflineplus">+        GlodaCollectionManager.itemsModified(aOldItem.NOUN_ID, [aOldItem]);</span>
<a href="#l4.211"></a><span id="l4.211" class="difflineplus">+    }</span>
<a href="#l4.212"></a><span id="l4.212" class="difflineplus">+    </span>
<a href="#l4.213"></a><span id="l4.213">     this._log.debug(&quot; done grokking.&quot;);</span>
<a href="#l4.214"></a><span id="l4.214">     </span>
<a href="#l4.215"></a><span id="l4.215">     yield this.kWorkDone;</span>
<a href="#l4.216"></a><span id="l4.216">   },</span>
<a href="#l4.217"></a><span id="l4.217"> };</span>
<a href="#l4.218"></a><span id="l4.218"> </span>
<a href="#l4.219"></a><span id="l4.219"> /* and initialize the Gloda object/NS before we return... */</span>
<a href="#l4.220"></a><span id="l4.220"> try {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/modules/index_ab.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/modules/index_ab.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -71,24 +71,25 @@ var GlodaABIndexer = {</span>
<a href="#l5.4"></a><span id="l5.4">     abManager.removeAddressBookListener(this);</span>
<a href="#l5.5"></a><span id="l5.5">   },</span>
<a href="#l5.6"></a><span id="l5.6"> </span>
<a href="#l5.7"></a><span id="l5.7">   get workers() {</span>
<a href="#l5.8"></a><span id="l5.8">     return [[&quot;ab-card&quot;, this._worker_index_card]];</span>
<a href="#l5.9"></a><span id="l5.9">   },</span>
<a href="#l5.10"></a><span id="l5.10">   </span>
<a href="#l5.11"></a><span id="l5.11">   _worker_index_card: function(aJob, aCallbackHandle) {</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+    let card = aJob.id;</span>
<a href="#l5.13"></a><span id="l5.13">     // load the identity</span>
<a href="#l5.14"></a><span id="l5.14">     let query = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l5.15"></a><span id="l5.15">     query.kind(&quot;email&quot;);</span>
<a href="#l5.16"></a><span id="l5.16">     query.value(card.primaryEmail);</span>
<a href="#l5.17"></a><span id="l5.17">     let identityCollection = query.getCollection(aCallbackHandle);</span>
<a href="#l5.18"></a><span id="l5.18">     yield Gloda.kWorkAsync;</span>
<a href="#l5.19"></a><span id="l5.19">     </span>
<a href="#l5.20"></a><span id="l5.20" class="difflineminus">-    if (identityCollection.length) {</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+    if (identityCollection.items.length) {</span>
<a href="#l5.22"></a><span id="l5.22">       let identity = identityCollection.items[0];</span>
<a href="#l5.23"></a><span id="l5.23"> </span>
<a href="#l5.24"></a><span id="l5.24">       this._log.debug(&quot;Found identity, processing card.&quot;);</span>
<a href="#l5.25"></a><span id="l5.25">       yield aCallbackHandle.pushAndGo(</span>
<a href="#l5.26"></a><span id="l5.26">           Gloda.grokNounItem(identity.contact, card, false, aCallbackHandle));</span>
<a href="#l5.27"></a><span id="l5.27">       this._log.debug(&quot;Done processing card.&quot;);</span>
<a href="#l5.28"></a><span id="l5.28">     }</span>
<a href="#l5.29"></a><span id="l5.29">     </span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

