<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 11807:a995610170f0ff693f2e8e7bafb5506b996122c6</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ a995610170f0ff693f2e8e7bafb5506b996122c6" />
<meta property="og:url" content="/comm-central/rev/a995610170f0ff693f2e8e7bafb5506b996122c6" />
<meta property="og:description" content="Bug 746052 - Implement a JS-based MIME parser, part 1: add the parser. r=irving sr=Neil" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / a995610170f0ff693f2e8e7bafb5506b996122c6 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/a995610170f0ff693f2e8e7bafb5506b996122c6">shortlog</a> |
<a href="/comm-central/log/a995610170f0ff693f2e8e7bafb5506b996122c6">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/a995610170f0ff693f2e8e7bafb5506b996122c6">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/a995610170f0ff693f2e8e7bafb5506b996122c6">files</a> |
changeset |
<a href="/comm-central/raw-rev/a995610170f0ff693f2e8e7bafb5506b996122c6">raw</a>  | <a href="/comm-central/archive/a995610170f0ff693f2e8e7bafb5506b996122c6.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=746052">Bug 746052</a> - Implement a JS-based MIME parser, part 1: add the parser. r=irving sr=Neil
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#74;&#111;&#115;&#104;&#117;&#97;&#32;&#67;&#114;&#97;&#110;&#109;&#101;&#114;&#32;&#60;&#80;&#105;&#100;&#103;&#101;&#111;&#116;&#49;&#56;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Sun, 04 Mar 2012 13:31:57 -0600</td></tr>

<tr>
 <td>changeset 11807</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/a995610170f0ff693f2e8e7bafb5506b996122c6">a995610170f0ff693f2e8e7bafb5506b996122c6</a></td>
</tr>



<tr>
<td>parent 11806</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/a0f0716fcd300f73a86fa31012c898d68e619a22">a0f0716fcd300f73a86fa31012c898d68e619a22</a>
</td>
</tr>

<tr>
<td>child 11808</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/d5ac1b0f26d8f548b675f0831375a5edeb05652d">d5ac1b0f26d8f548b675f0831375a5edeb05652d</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=a995610170f0ff693f2e8e7bafb5506b996122c6">8796</a></td></tr>
<tr><td>push user</td><td>Pidgeot18@gmail.com</td></tr>
<tr><td>push date</td><td class="date age">Sat, 12 Jan 2013 20:17:25 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@d5ac1b0f26d8 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=d5ac1b0f26d8f548b675f0831375a5edeb05652d">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=d5ac1b0f26d8f548b675f0831375a5edeb05652d&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=d5ac1b0f26d8f548b675f0831375a5edeb05652d&newProject=comm-central&newRevision=a995610170f0ff693f2e8e7bafb5506b996122c6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=d5ac1b0f26d8f548b675f0831375a5edeb05652d&newProject=comm-central&newRevision=a995610170f0ff693f2e8e7bafb5506b996122c6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=d5ac1b0f26d8f548b675f0831375a5edeb05652d&newProject=comm-central&newRevision=a995610170f0ff693f2e8e7bafb5506b996122c6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28irving%29&revcount=50">irving</a>, <a href="/comm-central/log?rev=reviewer%28Neil%29&revcount=50">Neil</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=746052">746052</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=746052">Bug 746052</a> - Implement a JS-based MIME parser, part 1: add the parser. r=irving sr=Neil</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/Makefile.in">mailnews/mime/Makefile.in</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/Makefile.in">file</a> |
<a href="/comm-central/annotate/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/Makefile.in">annotate</a> |
<a href="/comm-central/diff/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/Makefile.in">diff</a> |
<a href="/comm-central/comparison/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/Makefile.in">comparison</a> |
<a href="/comm-central/log/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/Makefile.in">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/README">mailnews/mime/jsmime/README</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/README">file</a> |
<a href="/comm-central/annotate/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/README">annotate</a> |
<a href="/comm-central/diff/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/README">diff</a> |
<a href="/comm-central/comparison/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/README">comparison</a> |
<a href="/comm-central/log/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/README">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/mimeParser.jsm">mailnews/mime/jsmime/mimeParser.jsm</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/mimeParser.jsm">file</a> |
<a href="/comm-central/annotate/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/mimeParser.jsm">annotate</a> |
<a href="/comm-central/diff/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/mimeParser.jsm">diff</a> |
<a href="/comm-central/comparison/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/mimeParser.jsm">comparison</a> |
<a href="/comm-central/log/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/mimeParser.jsm">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/mimeParserCore.js">mailnews/mime/jsmime/mimeParserCore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/mimeParserCore.js">file</a> |
<a href="/comm-central/annotate/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/mimeParserCore.js">annotate</a> |
<a href="/comm-central/diff/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/mimeParserCore.js">diff</a> |
<a href="/comm-central/comparison/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/mimeParserCore.js">comparison</a> |
<a href="/comm-central/log/a995610170f0ff693f2e8e7bafb5506b996122c6/mailnews/mime/jsmime/mimeParserCore.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/mime/Makefile.in</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/mime/Makefile.in</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -13,10 +13,15 @@ include $(DEPTH)/config/autoconf.mk</span>
<a href="#l1.4"></a><span id="l1.4"> MODULE		= mime</span>
<a href="#l1.5"></a><span id="l1.5"> </span>
<a href="#l1.6"></a><span id="l1.6"> PARALLEL_DIRS	= public src emitters cthandlers</span>
<a href="#l1.7"></a><span id="l1.7"> </span>
<a href="#l1.8"></a><span id="l1.8"> ifdef ENABLE_TESTS</span>
<a href="#l1.9"></a><span id="l1.9"> PARALLEL_DIRS += test</span>
<a href="#l1.10"></a><span id="l1.10"> endif</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+EXTRA_JS_MODULES = \</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+  jsmime/mimeParser.jsm \</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+  jsmime/mimeParserCore.js \</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+  $(NULL)</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+</span>
<a href="#l1.17"></a><span id="l1.17"> include $(topsrcdir)/config/rules.mk</span>
<a href="#l1.18"></a><span id="l1.18"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1">new file mode 100644</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineminus">--- /dev/null</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineplus">+++ b/mailnews/mime/jsmime/README</span>
<a href="#l2.4"></a><span id="l2.4" class="difflineat">@@ -0,0 +1,89 @@</span>
<a href="#l2.5"></a><span id="l2.5" class="difflineplus">+===============</span>
<a href="#l2.6"></a><span id="l2.6" class="difflineplus">+= Code Layout =</span>
<a href="#l2.7"></a><span id="l2.7" class="difflineplus">+===============</span>
<a href="#l2.8"></a><span id="l2.8" class="difflineplus">+</span>
<a href="#l2.9"></a><span id="l2.9" class="difflineplus">+This directory consists of a MIME parser which is primarily implemented in JS</span>
<a href="#l2.10"></a><span id="l2.10" class="difflineplus">+and is designed to use either HTML 5 specifications or texts that are intendend</span>
<a href="#l2.11"></a><span id="l2.11" class="difflineplus">+to become HTML 5 specifications.</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+The MIME parser consists of three logical phases of translation:</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+1. Build the MIME (and pseudo-MIME) tree.</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+2. Convert the MIME tree into a body-and-attachments view.</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+3. Use the result to drive the message view.</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+</span>
<a href="#l2.18"></a><span id="l2.18" class="difflineplus">+The first stage is located in mimeParserCore.js. The later stages are not yet</span>
<a href="#l2.19"></a><span id="l2.19" class="difflineplus">+implemented in JS. This file should not be included directly by consumers, who</span>
<a href="#l2.20"></a><span id="l2.20" class="difflineplus">+should instead use mimeParser.jsm, which contains easier-to-use APIs and also</span>
<a href="#l2.21"></a><span id="l2.21" class="difflineplus">+necessary glue components for use in JS modules or component contexts.</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineplus">+</span>
<a href="#l2.23"></a><span id="l2.23" class="difflineplus">+=============================</span>
<a href="#l2.24"></a><span id="l2.24" class="difflineplus">+= Underlying specifications =</span>
<a href="#l2.25"></a><span id="l2.25" class="difflineplus">+=============================</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineplus">+</span>
<a href="#l2.27"></a><span id="l2.27" class="difflineplus">+The specification of MIME is complicated and is spread around a very large</span>
<a href="#l2.28"></a><span id="l2.28" class="difflineplus">+number of references. For a single guide to everywhere, what follows is a list</span>
<a href="#l2.29"></a><span id="l2.29" class="difflineplus">+of all references used in the course of this parser, structured roughly</span>
<a href="#l2.30"></a><span id="l2.30" class="difflineplus">+according to how they are used:</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+[NOTE: specifications which are marked with an X instead are not integrated</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+       in this version of the code, but will be supported in a later version]</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineplus">+Basic format of bodies:</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+* RFC 2045 -- MIME Part 1, Format of Internet Message Bodies</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+* RFC 2046 -- MIME Part 2, Media Types</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+Structured header interpretation:</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+X RFC 2047 -- MIME Part 3, Message Header Extensions for Non-ASCII Text</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineplus">+X RFC 2231 -- MIME Parameter Value and Encoded Word Extensions</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineplus">+* RFC 5322 -- Internet Message Format (see also RFC 2822, RFC 822)</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineplus">+* RFC 5536 -- Netnews Article Format (see also RFC 1036)</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineplus">+X RFC 6532 -- Internationalized Email Headers (see also RFC 5335)</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineplus">+</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineplus">+Body decoding:</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineplus">+X &lt;http://pubs.opengroup.org/onlinepubs/7908799/xcu/uuencode.html&gt; -- Uuencode</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+X &lt;http://www.yenc.org/yenc-draft.1.3.txt&gt; -- yEnc</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineplus">+X RFC 1741 -- BinHex</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineplus">+X &lt;http://msdn.microsoft.com/en-us/library/cc425498%28v=exchg.80%29.aspx&gt; --</span>
<a href="#l2.49"></a><span id="l2.49" class="difflineplus">+  TNEF</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineplus">+X RFC 3165 -- MIME security with PGP</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineplus">+X RFC 4880 -- OpenPGP (see also RFC 2440)</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineplus">+X RFC 5751 -- S/MIME (see also RFC 3851, RFC 2633)</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineplus">+</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineplus">+Other:</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+X RFC 2387 -- multipart/related</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+X RFC 2392 -- Content-ID and Message-ID  URLs</span>
<a href="#l2.57"></a><span id="l2.57" class="difflineplus">+X RFC 2557 -- MIME-encapsulated aggegrate documents</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineplus">+* RFC 3501 -- IMAPv4rev1 [partial basis for part numbering]</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineplus">+X RFC 3676 -- text/plain format (format=flowed) (see also RFC 2646)</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineplus">+X RFC 3798 -- Message delivery notification (see also RFC 5337 and RFC 6533)</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineplus">+</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineplus">+While the above is a fairly comprehensive list of specifications, it turns</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineplus">+out that a somewhat different structure can be found in practice. Following</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineplus">+the general principle of &quot;Be liberal in what you accept and conservative in</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineplus">+what you send,&quot; this parser will attempt to make some sense of anything</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineplus">+passed into it. Some pathologically bad cases that the specification gives no</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineplus">+guidance to (such as having nested multipart/* bodies with the same boundary</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineplus">+permitted) are likely to provide inconsistent results with different parsers.</span>
<a href="#l2.69"></a><span id="l2.69" class="difflineplus">+</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineplus">+However, what follows is a list of modifications to the above specifications</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+that are necessary to account for messages which have been observed to cause</span>
<a href="#l2.72"></a><span id="l2.72" class="difflineplus">+issues in the real world:</span>
<a href="#l2.73"></a><span id="l2.73" class="difflineplus">+* All three line conventions are treated as a CRLF (\r, \n, \r\n). In this</span>
<a href="#l2.74"></a><span id="l2.74" class="difflineplus">+  parser, it is possible to use a mixture of line endings in the same file,</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineplus">+  although this is highly unlikely to come up in practice.</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineplus">+* The input text need not be either ASCII or UTF-8 (permissible under the</span>
<a href="#l2.77"></a><span id="l2.77" class="difflineplus">+  newer EAI specifications). Some tools that are insufficiently aware of i18n</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineplus">+  issues with respect to MIME may end up emitting non-ASCII (or non-UTF-8)</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineplus">+  data. In this parser, all header data is passed through as-is. Header names</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineplus">+  are canonicalized to lowercase using .toLowerCase(), which causes case</span>
<a href="#l2.81"></a><span id="l2.81" class="difflineplus">+  conversion for non-ASCII charsets as well. However, even under EAI, header</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineplus">+  names are specified to be pure ASCII so this should not be an issue in</span>
<a href="#l2.83"></a><span id="l2.83" class="difflineplus">+  practice. The body is left alone unless a charset is specified and recoding</span>
<a href="#l2.84"></a><span id="l2.84" class="difflineplus">+  is explicitly requested.</span>
<a href="#l2.85"></a><span id="l2.85" class="difflineplus">+* CFWS is permitted in fewer places than the specifications require. This was</span>
<a href="#l2.86"></a><span id="l2.86" class="difflineplus">+  done to match other parsers (including the one this replaced, among others).</span>
<a href="#l2.87"></a><span id="l2.87" class="difflineplus">+  In particular, the Content-Type parameter needs to be a single run of text, so</span>
<a href="#l2.88"></a><span id="l2.88" class="difflineplus">+  &quot;multipart / mixed&quot; would be treated as an invalid type.</span>
<a href="#l2.89"></a><span id="l2.89" class="difflineplus">+* If the first line of a headers block starts with the Berkely mailbox delimiter</span>
<a href="#l2.90"></a><span id="l2.90" class="difflineplus">+  (From followed by a space), it is ignored.</span>
<a href="#l2.91"></a><span id="l2.91" class="difflineplus">+* A message/rfc822-like part may be encoded in quoted-printable or base64, while</span>
<a href="#l2.92"></a><span id="l2.92" class="difflineplus">+  RFC 6532 only permits this for message/global.</span>
<a href="#l2.93"></a><span id="l2.93" class="difflineplus">+* XXX: RFC 2047 encoded words may contain embedded spaces.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1">new file mode 100644</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineminus">--- /dev/null</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineplus">+++ b/mailnews/mime/jsmime/mimeParser.jsm</span>
<a href="#l3.4"></a><span id="l3.4" class="difflineat">@@ -0,0 +1,219 @@</span>
<a href="#l3.5"></a><span id="l3.5" class="difflineplus">+/* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l3.6"></a><span id="l3.6" class="difflineplus">+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,</span>
<a href="#l3.7"></a><span id="l3.7" class="difflineplus">+ * You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l3.8"></a><span id="l3.8" class="difflineplus">+// vim:set ts=2 sw=2 sts=2 et ft=javascript:</span>
<a href="#l3.9"></a><span id="l3.9" class="difflineplus">+</span>
<a href="#l3.10"></a><span id="l3.10" class="difflineplus">+Components.utils.import(&quot;resource:///modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l3.11"></a><span id="l3.11" class="difflineplus">+Components.utils.import(&quot;resource:///modules/Services.jsm&quot;);</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+// Load the core MIME parser. Since it doesn't define EXPORTED_SYMBOLS, we must</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+// use the subscript loader instead.</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+Services.scriptloader.loadSubScript(&quot;resource:///modules/mimeParserCore.js&quot;);</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+var EXPORTED_SYMBOLS = [&quot;MimeParser&quot;];</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+// Emitter helpers, for internal functions later on.</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+var ExtractHeadersEmitter = {</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+  startPart: function (partNum, headers) {</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineplus">+    if (partNum == '') {</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineplus">+      this.headers = headers;</span>
<a href="#l3.24"></a><span id="l3.24" class="difflineplus">+    }</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineplus">+  }</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineplus">+};</span>
<a href="#l3.27"></a><span id="l3.27" class="difflineplus">+</span>
<a href="#l3.28"></a><span id="l3.28" class="difflineplus">+var ExtractHeadersAndBodyEmitter = {</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineplus">+  body: '',</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineplus">+  startPart: ExtractHeadersEmitter.startPart,</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+  deliverPartData: function (partNum, data) {</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+    if (partNum == '')</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+      this.body += data;</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineplus">+  }</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+};</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+/// Sets appropriate default options for chrome-privileged environments</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineplus">+function setDefaultParserOptions(opts) {</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineplus">+  if (!(&quot;onerror&quot; in opts)) {</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineplus">+    opts.onerror = Components.utils.reportError;</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineplus">+  }</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineplus">+}</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineplus">+</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+var MimeParser = {</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineplus">+  /**</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineplus">+   * Triggers an asynchronous parse of the given input.</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineplus">+   *</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+   * The input is an input stream; the stream will be read until EOF and then</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+   * closed upon completion. Both blocking and nonblocking streams are</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+   * supported by this implementation, but it is still guaranteed that the first</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+   * callback will not happen before this method returns.</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+   *</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+   * @param input   An input stream of text to parse.</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+   * @param emitter The emitter to receive callbacks on.</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+   * @param opts    A set of options for the parser.</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+   */</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineplus">+  parseAsync: function MimeParser_parseAsync(input, emitter, opts) {</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineplus">+    // Normalize the input into an input stream.</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineplus">+    if (!(input instanceof Ci.nsIInputStream)) {</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineplus">+      throw new Error(&quot;input is not a recognizable type!&quot;);</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineplus">+    }</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineplus">+</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineplus">+    // We need a pump for the listener</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineplus">+    var pump = Cc[&quot;@mozilla.org/network/input-stream-pump;1&quot;]</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineplus">+                 .createInstance(Ci.nsIInputStreamPump);</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineplus">+    pump.init(input, -1, -1, 0, 0, true);</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineplus">+</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineplus">+    // Make a stream listener with the given emitter and use it to read from</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineplus">+    // the pump.</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineplus">+    var parserListener = MimeParser.makeStreamListenerParser(emitter, opts);</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineplus">+    pump.asyncRead(parserListener, null);</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineplus">+  },</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineplus">+</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineplus">+  /**</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+   * Triggers an synchronous parse of the given input.</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineplus">+   *</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineplus">+   * The input is a string that is immediately parsed, calling all functions on</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineplus">+   * the emitter before this function returns.</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineplus">+   *</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineplus">+   * @param input   A string or input stream of text to parse.</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineplus">+   * @param emitter The emitter to receive callbacks on.</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineplus">+   * @param opts    A set of options for the parser.</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineplus">+   */</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineplus">+  parseSync: function MimeParser_parseSync(input, emitter, opts) {</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineplus">+    // We only support string parsing if we are trying to do this parse</span>
<a href="#l3.89"></a><span id="l3.89" class="difflineplus">+    // synchronously.</span>
<a href="#l3.90"></a><span id="l3.90" class="difflineplus">+    if (typeof input != &quot;string&quot;) {</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+      throw new Error(&quot;input is not a recognizable type!&quot;);</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineplus">+    }</span>
<a href="#l3.93"></a><span id="l3.93" class="difflineplus">+    setDefaultParserOptions(opts);</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineplus">+    var parser = new Parser(emitter, opts);</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineplus">+    parser.deliverData(input);</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineplus">+    parser.deliverEOF();</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineplus">+    return;</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineplus">+  },</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineplus">+</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineplus">+  /**</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineplus">+   * Returns a stream listener that feeds data into a parser.</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineplus">+   *</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineplus">+   * In addition to the functions on the emitter that the parser may use, the</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineplus">+   * generated stream listener will also make calls to onStartRequest and</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineplus">+   * onStopRequest on the emitter (if they exist).</span>
<a href="#l3.106"></a><span id="l3.106" class="difflineplus">+   *</span>
<a href="#l3.107"></a><span id="l3.107" class="difflineplus">+   * @param emitter The emitter to receive callbacks on.</span>
<a href="#l3.108"></a><span id="l3.108" class="difflineplus">+   * @param opts    A set of options for the parser.</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineplus">+   */</span>
<a href="#l3.110"></a><span id="l3.110" class="difflineplus">+  makeStreamListenerParser: function MimeParser_makeSLParser(emitter, opts) {</span>
<a href="#l3.111"></a><span id="l3.111" class="difflineplus">+    var StreamListener = {</span>
<a href="#l3.112"></a><span id="l3.112" class="difflineplus">+      onStartRequest: function SLP_onStartRequest(aRequest, aContext) {</span>
<a href="#l3.113"></a><span id="l3.113" class="difflineplus">+        try {</span>
<a href="#l3.114"></a><span id="l3.114" class="difflineplus">+          if (&quot;onStartRequest&quot; in emitter)</span>
<a href="#l3.115"></a><span id="l3.115" class="difflineplus">+            emitter.onStartRequest(aRequest, aContext);</span>
<a href="#l3.116"></a><span id="l3.116" class="difflineplus">+        } finally {</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineplus">+          this._parser.resetParser();</span>
<a href="#l3.118"></a><span id="l3.118" class="difflineplus">+        }</span>
<a href="#l3.119"></a><span id="l3.119" class="difflineplus">+      },</span>
<a href="#l3.120"></a><span id="l3.120" class="difflineplus">+      onStopRequest: function SLP_onStopRequest(aRequest, aContext, aStatus) {</span>
<a href="#l3.121"></a><span id="l3.121" class="difflineplus">+        this._parser.deliverEOF();</span>
<a href="#l3.122"></a><span id="l3.122" class="difflineplus">+        if (&quot;onStopRequest&quot; in emitter)</span>
<a href="#l3.123"></a><span id="l3.123" class="difflineplus">+          emitter.onStopRequest(aRequest, aContext, aStatus);</span>
<a href="#l3.124"></a><span id="l3.124" class="difflineplus">+      },</span>
<a href="#l3.125"></a><span id="l3.125" class="difflineplus">+      onDataAvailable: function SLP_onData(aRequest, aContext, aStream,</span>
<a href="#l3.126"></a><span id="l3.126" class="difflineplus">+                                           aOffset, aCount) {</span>
<a href="#l3.127"></a><span id="l3.127" class="difflineplus">+        var scriptIn = Cc[&quot;@mozilla.org/scriptableinputstream;1&quot;]</span>
<a href="#l3.128"></a><span id="l3.128" class="difflineplus">+                         .createInstance(Ci.nsIScriptableInputStream);</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineplus">+        scriptIn.init(aStream);</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineplus">+        // Use readBytes instead of read to handle embedded NULs properly.</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineplus">+        this._parser.deliverData(scriptIn.readBytes(aCount));</span>
<a href="#l3.132"></a><span id="l3.132" class="difflineplus">+      },</span>
<a href="#l3.133"></a><span id="l3.133" class="difflineplus">+      QueryInterface: XPCOMUtils.generateQI([Ci.nsIStreamListener,</span>
<a href="#l3.134"></a><span id="l3.134" class="difflineplus">+        Ci.nsIRequestObserver])</span>
<a href="#l3.135"></a><span id="l3.135" class="difflineplus">+    };</span>
<a href="#l3.136"></a><span id="l3.136" class="difflineplus">+    setDefaultParserOptions(opts);</span>
<a href="#l3.137"></a><span id="l3.137" class="difflineplus">+    StreamListener._parser = new Parser(emitter, opts);</span>
<a href="#l3.138"></a><span id="l3.138" class="difflineplus">+    return StreamListener;</span>
<a href="#l3.139"></a><span id="l3.139" class="difflineplus">+  },</span>
<a href="#l3.140"></a><span id="l3.140" class="difflineplus">+</span>
<a href="#l3.141"></a><span id="l3.141" class="difflineplus">+  /**</span>
<a href="#l3.142"></a><span id="l3.142" class="difflineplus">+   * Returns a new raw MIME parser.</span>
<a href="#l3.143"></a><span id="l3.143" class="difflineplus">+   *</span>
<a href="#l3.144"></a><span id="l3.144" class="difflineplus">+   * Prefer one of the other methods where possible, since the input here must</span>
<a href="#l3.145"></a><span id="l3.145" class="difflineplus">+   * be driven manually.</span>
<a href="#l3.146"></a><span id="l3.146" class="difflineplus">+   *</span>
<a href="#l3.147"></a><span id="l3.147" class="difflineplus">+   * @param emitter The emitter to receive callbacks on.</span>
<a href="#l3.148"></a><span id="l3.148" class="difflineplus">+   * @param opts    A set of options for the parser.</span>
<a href="#l3.149"></a><span id="l3.149" class="difflineplus">+   */</span>
<a href="#l3.150"></a><span id="l3.150" class="difflineplus">+  makeParser: function MimeParser_makeParser(emitter, opts) {</span>
<a href="#l3.151"></a><span id="l3.151" class="difflineplus">+    setDefaultParserOptions(opts);</span>
<a href="#l3.152"></a><span id="l3.152" class="difflineplus">+    return new Parser(emitter, opts);</span>
<a href="#l3.153"></a><span id="l3.153" class="difflineplus">+  },</span>
<a href="#l3.154"></a><span id="l3.154" class="difflineplus">+</span>
<a href="#l3.155"></a><span id="l3.155" class="difflineplus">+  /**</span>
<a href="#l3.156"></a><span id="l3.156" class="difflineplus">+   * Returns a dictionary of headers for the given input.</span>
<a href="#l3.157"></a><span id="l3.157" class="difflineplus">+   *</span>
<a href="#l3.158"></a><span id="l3.158" class="difflineplus">+   * The input is any type of input that would be accepted by parseSync. What</span>
<a href="#l3.159"></a><span id="l3.159" class="difflineplus">+   * is returned is a JS object that represents the headers of the entire</span>
<a href="#l3.160"></a><span id="l3.160" class="difflineplus">+   * envelope as would be received by startPart when partNum is the empty</span>
<a href="#l3.161"></a><span id="l3.161" class="difflineplus">+   * string.</span>
<a href="#l3.162"></a><span id="l3.162" class="difflineplus">+   *</span>
<a href="#l3.163"></a><span id="l3.163" class="difflineplus">+   * @param input   A string of text to parse.</span>
<a href="#l3.164"></a><span id="l3.164" class="difflineplus">+   */</span>
<a href="#l3.165"></a><span id="l3.165" class="difflineplus">+  extractHeaders: function MimeParser_extractHeaders(input) {</span>
<a href="#l3.166"></a><span id="l3.166" class="difflineplus">+    var emitter = Object.create(ExtractHeadersEmitter);</span>
<a href="#l3.167"></a><span id="l3.167" class="difflineplus">+    MimeParser.parseSync(input, emitter, {pruneat: '', bodyformat: 'none'});</span>
<a href="#l3.168"></a><span id="l3.168" class="difflineplus">+    return emitter.headers;</span>
<a href="#l3.169"></a><span id="l3.169" class="difflineplus">+  },</span>
<a href="#l3.170"></a><span id="l3.170" class="difflineplus">+</span>
<a href="#l3.171"></a><span id="l3.171" class="difflineplus">+  /**</span>
<a href="#l3.172"></a><span id="l3.172" class="difflineplus">+   * Returns the headers and body for the given input message.</span>
<a href="#l3.173"></a><span id="l3.173" class="difflineplus">+   *</span>
<a href="#l3.174"></a><span id="l3.174" class="difflineplus">+   * The return value is an array whose first element is the dictionary of</span>
<a href="#l3.175"></a><span id="l3.175" class="difflineplus">+   * headers (as would be returned by extractHeaders) and whose second element</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineplus">+   * is a binary string of the entire body of the message.</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineplus">+   *</span>
<a href="#l3.178"></a><span id="l3.178" class="difflineplus">+   * @param input   A string of text to parse.</span>
<a href="#l3.179"></a><span id="l3.179" class="difflineplus">+   */</span>
<a href="#l3.180"></a><span id="l3.180" class="difflineplus">+  extractHeadersAndBody: function MimeParser_extractHeaders(input) {</span>
<a href="#l3.181"></a><span id="l3.181" class="difflineplus">+    var emitter = Object.create(ExtractHeadersAndBodyEmitter);</span>
<a href="#l3.182"></a><span id="l3.182" class="difflineplus">+    MimeParser.parseSync(input, emitter, {pruneat: '', bodyformat: 'raw'});</span>
<a href="#l3.183"></a><span id="l3.183" class="difflineplus">+    return [emitter.headers, emitter.body];</span>
<a href="#l3.184"></a><span id="l3.184" class="difflineplus">+  },</span>
<a href="#l3.185"></a><span id="l3.185" class="difflineplus">+</span>
<a href="#l3.186"></a><span id="l3.186" class="difflineplus">+  // Parameters for parseHeaderField</span>
<a href="#l3.187"></a><span id="l3.187" class="difflineplus">+</span>
<a href="#l3.188"></a><span id="l3.188" class="difflineplus">+  /**</span>
<a href="#l3.189"></a><span id="l3.189" class="difflineplus">+   * Parse the header as if it were in the form text; attr=val; attr=val.</span>
<a href="#l3.190"></a><span id="l3.190" class="difflineplus">+   *</span>
<a href="#l3.191"></a><span id="l3.191" class="difflineplus">+   * Such headers include Content-Type, Content-Disposition, and most other</span>
<a href="#l3.192"></a><span id="l3.192" class="difflineplus">+   * headers used by MIME as opposed to messages.</span>
<a href="#l3.193"></a><span id="l3.193" class="difflineplus">+   */</span>
<a href="#l3.194"></a><span id="l3.194" class="difflineplus">+  HEADER_PARAMETER:          0x02,</span>
<a href="#l3.195"></a><span id="l3.195" class="difflineplus">+</span>
<a href="#l3.196"></a><span id="l3.196" class="difflineplus">+  /**</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineplus">+   * Parse a header field according to the specification given by flags.</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineplus">+   *</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineplus">+   * Permissible flags begin with one of the HEADER_* flags, which may be or'd</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineplus">+   * with any of the HEADER_OPTION_* flags to modify the result appropriately.</span>
<a href="#l3.201"></a><span id="l3.201" class="difflineplus">+   *</span>
<a href="#l3.202"></a><span id="l3.202" class="difflineplus">+   * If a charset-aware option (HEADER_OPTION_DECODE_2231 or</span>
<a href="#l3.203"></a><span id="l3.203" class="difflineplus">+   * HEADER_OPTION_DECODE_2047) is used, the charset parameter, if present, is</span>
<a href="#l3.204"></a><span id="l3.204" class="difflineplus">+   * the default charset to assume if no charset is found. If this parameter is</span>
<a href="#l3.205"></a><span id="l3.205" class="difflineplus">+   * not present, UTF-8 will be assumed to be the default. Furthermore, if any</span>
<a href="#l3.206"></a><span id="l3.206" class="difflineplus">+   * of these options are used, resulting strings will be normalized to full</span>
<a href="#l3.207"></a><span id="l3.207" class="difflineplus">+   * Unicode.</span>
<a href="#l3.208"></a><span id="l3.208" class="difflineplus">+   *</span>
<a href="#l3.209"></a><span id="l3.209" class="difflineplus">+   * @param text    The value of a MIME or message header to parse.</span>
<a href="#l3.210"></a><span id="l3.210" class="difflineplus">+   * @param flags   A set of flags that controls interpretation of the header.</span>
<a href="#l3.211"></a><span id="l3.211" class="difflineplus">+   * @param charset A default charset to assume if no information may be found.</span>
<a href="#l3.212"></a><span id="l3.212" class="difflineplus">+   */</span>
<a href="#l3.213"></a><span id="l3.213" class="difflineplus">+  parseHeaderField: function MimeParser_parseHeaderField(text, flags, charset) {</span>
<a href="#l3.214"></a><span id="l3.214" class="difflineplus">+    // The low 4 bits indicate the type of the header we are parsing. All of the</span>
<a href="#l3.215"></a><span id="l3.215" class="difflineplus">+    // higher-order bits are flags.</span>
<a href="#l3.216"></a><span id="l3.216" class="difflineplus">+    switch (flags &amp; 0x0f) {</span>
<a href="#l3.217"></a><span id="l3.217" class="difflineplus">+    case MimeParser.HEADER_PARAMETER:</span>
<a href="#l3.218"></a><span id="l3.218" class="difflineplus">+      return HeaderParser.extractParameters(text);</span>
<a href="#l3.219"></a><span id="l3.219" class="difflineplus">+    default:</span>
<a href="#l3.220"></a><span id="l3.220" class="difflineplus">+      throw &quot;Illegal type of header field&quot;;</span>
<a href="#l3.221"></a><span id="l3.221" class="difflineplus">+    }</span>
<a href="#l3.222"></a><span id="l3.222" class="difflineplus">+  },</span>
<a href="#l3.223"></a><span id="l3.223" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1">new file mode 100644</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineminus">--- /dev/null</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineplus">+++ b/mailnews/mime/jsmime/mimeParserCore.js</span>
<a href="#l4.4"></a><span id="l4.4" class="difflineat">@@ -0,0 +1,769 @@</span>
<a href="#l4.5"></a><span id="l4.5" class="difflineplus">+/* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l4.6"></a><span id="l4.6" class="difflineplus">+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,</span>
<a href="#l4.7"></a><span id="l4.7" class="difflineplus">+ * You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l4.8"></a><span id="l4.8" class="difflineplus">+////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l4.9"></a><span id="l4.9" class="difflineplus">+//                        JavaScript Raw MIME Parser                          //</span>
<a href="#l4.10"></a><span id="l4.10" class="difflineplus">+////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l4.11"></a><span id="l4.11" class="difflineplus">+</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+/**</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+ * The parser implemented in this file produces a MIME part tree for a given</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+ * input message via a streaming callback interface. It does not, by itself,</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineplus">+ * understand concepts like attachments (hence the term 'Raw'); the consumer</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineplus">+ * must translate output into such a format.</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineplus">+ *</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineplus">+ * Dependencies:</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineplus">+ * This file requires some external code for processing. The following are</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineplus">+ * things that are presumed to exist in the global scope:</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineplus">+ * function atob(str): Converts a JS string to a JS binary string</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineplus">+ *</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineplus">+ * Charsets:</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineplus">+ * The MIME specifications permit a single message to contain multiple charsets</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineplus">+ * (or perhaps none) as raw octets. As JavaScript strings are implicitly</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineplus">+ * implemented in UTF-16, it is possible that some engines will attempt to</span>
<a href="#l4.27"></a><span id="l4.27" class="difflineplus">+ * convert these strings using an incorrect charset or simply fail to convert</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineplus">+ * them at all. This parser assumes that its input is in the form of a &quot;binary</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineplus">+ * string&quot;, a string that uses only the first 256 characters of Unicode to</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineplus">+ * represent the individual octets. Even if this is the case, the data in the</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+ * strings are likely to be passed through unchanged no matter their charset</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+ * unless charset conversion happens on an 8-bit or binary string.</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+ *</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+ * Part numbering:</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+ * Since the output is a streaming format, individual parts are identified by a</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+ * numbering scheme. The intent of the numbering scheme for parts is to comply</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+ * with the part numbers as dictated by RFC 3501 as much possible; however,</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+ * that scheme does have several edge cases which would, if strictly followed,</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineplus">+ * make it impossible to refer to certain parts of the message. In addition, we</span>
<a href="#l4.40"></a><span id="l4.40" class="difflineplus">+ * wish to make it possible to refer to parts which are not discoverable in the</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineplus">+ * original MIME tree but are still viewable as parts. The part numbering</span>
<a href="#l4.42"></a><span id="l4.42" class="difflineplus">+ * scheme is as follows:</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineplus">+ * - Individual sections of a multipart/* body are numbered in increasing order</span>
<a href="#l4.44"></a><span id="l4.44" class="difflineplus">+ *   sequentially, starting from 1. Note that the prologue and the epilogue of</span>
<a href="#l4.45"></a><span id="l4.45" class="difflineplus">+ *   a multipart/* body are not considered entities and are therefore not</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineplus">+ *   included in the part numbering scheme (there is no way to refer to them).</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineplus">+ * - The numbers of multipart/* parts are separated by `.' characters.</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineplus">+ * - The outermost message is referred to by use of the empty string.</span>
<a href="#l4.49"></a><span id="l4.49" class="difflineplus">+ * --&gt; The following segments are not accounted for by IMAP part numbering. &lt;--</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineplus">+ * - The body of any message/rfc822 or similar part is distinguished from the</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineplus">+ *   message part as a whole by appending a `$' character. This does not apply</span>
<a href="#l4.52"></a><span id="l4.52" class="difflineplus">+ *   to the outermost message/rfc822 envelope.</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineplus">+ */</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineplus">+</span>
<a href="#l4.55"></a><span id="l4.55" class="difflineplus">+&quot;use strict&quot;;</span>
<a href="#l4.56"></a><span id="l4.56" class="difflineplus">+</span>
<a href="#l4.57"></a><span id="l4.57" class="difflineplus">+/**</span>
<a href="#l4.58"></a><span id="l4.58" class="difflineplus">+ * A MIME parser.</span>
<a href="#l4.59"></a><span id="l4.59" class="difflineplus">+ *</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineplus">+ * The inputs to the constructor consist of a callback object which recieves</span>
<a href="#l4.61"></a><span id="l4.61" class="difflineplus">+ * information about the output data and an optional object containing the</span>
<a href="#l4.62"></a><span id="l4.62" class="difflineplus">+ * settings for the parser.</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineplus">+ *</span>
<a href="#l4.64"></a><span id="l4.64" class="difflineplus">+ * The first parameter, emitter, is an object which contains several callbacks.</span>
<a href="#l4.65"></a><span id="l4.65" class="difflineplus">+ * Note that any and all of these methods are optional; the parser will not</span>
<a href="#l4.66"></a><span id="l4.66" class="difflineplus">+ * crash if one is missing. The callbacks are as follows:</span>
<a href="#l4.67"></a><span id="l4.67" class="difflineplus">+ *   startMessage()</span>
<a href="#l4.68"></a><span id="l4.68" class="difflineplus">+ *      Called when the stream to be parsed has started delivering data. This</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineplus">+ *      will be called exactly once, before any other call.</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineplus">+ *   endMessage()</span>
<a href="#l4.71"></a><span id="l4.71" class="difflineplus">+ *      Called after all data has been delivered and the message parsing has</span>
<a href="#l4.72"></a><span id="l4.72" class="difflineplus">+ *      been completed. This will be called exactly once, after any other call.</span>
<a href="#l4.73"></a><span id="l4.73" class="difflineplus">+ *   startPart(string partNum, object headers)</span>
<a href="#l4.74"></a><span id="l4.74" class="difflineplus">+ *      Called after the headers for a body part (including the top-level</span>
<a href="#l4.75"></a><span id="l4.75" class="difflineplus">+ *      message) have been parsed. The first parameter is the part number (see</span>
<a href="#l4.76"></a><span id="l4.76" class="difflineplus">+ *      the discussion on part numbering). The second parameter is a JS Map</span>
<a href="#l4.77"></a><span id="l4.77" class="difflineplus">+ *      object where the keys are lower-case header names and the values are</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineplus">+ *      arrays of strings of the header values with newlines stripped. In</span>
<a href="#l4.79"></a><span id="l4.79" class="difflineplus">+ *      addition, the headers object also contains a property rawHeaderText</span>
<a href="#l4.80"></a><span id="l4.80" class="difflineplus">+ *      whose value is the text of all MIME headers, with whitespace and case</span>
<a href="#l4.81"></a><span id="l4.81" class="difflineplus">+ *      perfectly preserved.</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineplus">+ *   endPart(string partNum)</span>
<a href="#l4.83"></a><span id="l4.83" class="difflineplus">+ *      Called after all of the data for a body part (including sub-parts) has</span>
<a href="#l4.84"></a><span id="l4.84" class="difflineplus">+ *      been parsed. The first parameter is the part number.</span>
<a href="#l4.85"></a><span id="l4.85" class="difflineplus">+ *   deliverPartData(string partNum, {string,typedarray} data)</span>
<a href="#l4.86"></a><span id="l4.86" class="difflineplus">+ *      Called when some data for a body part has been delivered. The first</span>
<a href="#l4.87"></a><span id="l4.87" class="difflineplus">+ *      parameter is the part number. The second parameter is the data which is</span>
<a href="#l4.88"></a><span id="l4.88" class="difflineplus">+ *      being delivered; the exact type of this data depends on the options</span>
<a href="#l4.89"></a><span id="l4.89" class="difflineplus">+ *      used. Note that data is only delivered for leaf body parts.</span>
<a href="#l4.90"></a><span id="l4.90" class="difflineplus">+ *</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineplus">+ *  The second parameter, options, is an optional object containing the options</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineplus">+ *  for the parser. The following are the options that the parser may use:</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineplus">+ *    pruneat: &lt;string&gt; [default=&quot;&quot;]</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineplus">+ *      Treat the message as starting at the given part number, so that no parts</span>
<a href="#l4.95"></a><span id="l4.95" class="difflineplus">+ *      above &lt;string&gt; are returned.</span>
<a href="#l4.96"></a><span id="l4.96" class="difflineplus">+ *    bodyformat: one of {none, raw, nodecode, decode} [default=nodecode]</span>
<a href="#l4.97"></a><span id="l4.97" class="difflineplus">+ *      How to return the bodies of parts:</span>
<a href="#l4.98"></a><span id="l4.98" class="difflineplus">+ *        none: no part data is returned</span>
<a href="#l4.99"></a><span id="l4.99" class="difflineplus">+ *        raw: the body of the part is passed through raw</span>
<a href="#l4.100"></a><span id="l4.100" class="difflineplus">+ *        nodecode: the body is passed through without decoding QP/Base64</span>
<a href="#l4.101"></a><span id="l4.101" class="difflineplus">+ *        decode: quoted-printable and base64 are fully decoded</span>
<a href="#l4.102"></a><span id="l4.102" class="difflineplus">+ *    onerror: &lt;function(thrown error)&gt; [default = nop-function]</span>
<a href="#l4.103"></a><span id="l4.103" class="difflineplus">+ *      An error function that is called if an emitter callback throws an error.</span>
<a href="#l4.104"></a><span id="l4.104" class="difflineplus">+ *      By default, such errors are swallowed by the parser. If you want the</span>
<a href="#l4.105"></a><span id="l4.105" class="difflineplus">+ *      parser itself to throw an error, rethrow it via the onerror function.</span>
<a href="#l4.106"></a><span id="l4.106" class="difflineplus">+ */</span>
<a href="#l4.107"></a><span id="l4.107" class="difflineplus">+function Parser(emitter, options) {</span>
<a href="#l4.108"></a><span id="l4.108" class="difflineplus">+  /// The actual emitter</span>
<a href="#l4.109"></a><span id="l4.109" class="difflineplus">+  this._emitter = emitter;</span>
<a href="#l4.110"></a><span id="l4.110" class="difflineplus">+  /// Options for the parser (those listed here are defaults)</span>
<a href="#l4.111"></a><span id="l4.111" class="difflineplus">+  this._options = {</span>
<a href="#l4.112"></a><span id="l4.112" class="difflineplus">+    pruneat: &quot;&quot;,</span>
<a href="#l4.113"></a><span id="l4.113" class="difflineplus">+    bodyformat: &quot;nodecode&quot;,</span>
<a href="#l4.114"></a><span id="l4.114" class="difflineplus">+    onerror: function swallow(error) {}</span>
<a href="#l4.115"></a><span id="l4.115" class="difflineplus">+  };</span>
<a href="#l4.116"></a><span id="l4.116" class="difflineplus">+  // Load the options as a copy here (prevents people from changing on the fly).</span>
<a href="#l4.117"></a><span id="l4.117" class="difflineplus">+  if (options)</span>
<a href="#l4.118"></a><span id="l4.118" class="difflineplus">+    for (var opt in options) {</span>
<a href="#l4.119"></a><span id="l4.119" class="difflineplus">+      this._options[opt] = options[opt];</span>
<a href="#l4.120"></a><span id="l4.120" class="difflineplus">+    }</span>
<a href="#l4.121"></a><span id="l4.121" class="difflineplus">+</span>
<a href="#l4.122"></a><span id="l4.122" class="difflineplus">+  // Ensure that the error function is in fact a function</span>
<a href="#l4.123"></a><span id="l4.123" class="difflineplus">+  if (typeof this._options.onerror != &quot;function&quot;)</span>
<a href="#l4.124"></a><span id="l4.124" class="difflineplus">+    throw new Exception(&quot;onerror callback must be a function&quot;);</span>
<a href="#l4.125"></a><span id="l4.125" class="difflineplus">+</span>
<a href="#l4.126"></a><span id="l4.126" class="difflineplus">+  // Reset the parser</span>
<a href="#l4.127"></a><span id="l4.127" class="difflineplus">+  this.resetParser();</span>
<a href="#l4.128"></a><span id="l4.128" class="difflineplus">+}</span>
<a href="#l4.129"></a><span id="l4.129" class="difflineplus">+</span>
<a href="#l4.130"></a><span id="l4.130" class="difflineplus">+/// Resets the parser to read a new message.</span>
<a href="#l4.131"></a><span id="l4.131" class="difflineplus">+Parser.prototype.resetParser = function Parser_resetParser() {</span>
<a href="#l4.132"></a><span id="l4.132" class="difflineplus">+  /// Current parser state</span>
<a href="#l4.133"></a><span id="l4.133" class="difflineplus">+  this._state = PARSING_HEADERS;</span>
<a href="#l4.134"></a><span id="l4.134" class="difflineplus">+  /// Input data that needs to be held for buffer conditioning</span>
<a href="#l4.135"></a><span id="l4.135" class="difflineplus">+  this._holdData = '';</span>
<a href="#l4.136"></a><span id="l4.136" class="difflineplus">+  /// Complete collection of headers (also used to accumulate _headerData)</span>
<a href="#l4.137"></a><span id="l4.137" class="difflineplus">+  this._headerData = '';</span>
<a href="#l4.138"></a><span id="l4.138" class="difflineplus">+  /// Whether or not emitter.startMessage has been called</span>
<a href="#l4.139"></a><span id="l4.139" class="difflineplus">+  this._triggeredCall = false;</span>
<a href="#l4.140"></a><span id="l4.140" class="difflineplus">+</span>
<a href="#l4.141"></a><span id="l4.141" class="difflineplus">+  /// Splitting input</span>
<a href="#l4.142"></a><span id="l4.142" class="difflineplus">+  this._splitRegex = this._handleSplit = undefined;</span>
<a href="#l4.143"></a><span id="l4.143" class="difflineplus">+  /// Subparsing</span>
<a href="#l4.144"></a><span id="l4.144" class="difflineplus">+  this._subparser = this._subPartNum = undefined;</span>
<a href="#l4.145"></a><span id="l4.145" class="difflineplus">+  /// Data that has yet to be consumed by _convertData</span>
<a href="#l4.146"></a><span id="l4.146" class="difflineplus">+  this._savedBuffer = '';</span>
<a href="#l4.147"></a><span id="l4.147" class="difflineplus">+  /// Convert data</span>
<a href="#l4.148"></a><span id="l4.148" class="difflineplus">+  this._convertData = undefined;</span>
<a href="#l4.149"></a><span id="l4.149" class="difflineplus">+  /// String decoder</span>
<a href="#l4.150"></a><span id="l4.150" class="difflineplus">+  this._decoder = undefined;</span>
<a href="#l4.151"></a><span id="l4.151" class="difflineplus">+}</span>
<a href="#l4.152"></a><span id="l4.152" class="difflineplus">+</span>
<a href="#l4.153"></a><span id="l4.153" class="difflineplus">+/**</span>
<a href="#l4.154"></a><span id="l4.154" class="difflineplus">+ * Deliver a buffer of data to the parser.</span>
<a href="#l4.155"></a><span id="l4.155" class="difflineplus">+ */</span>
<a href="#l4.156"></a><span id="l4.156" class="difflineplus">+Parser.prototype.deliverData = function Parser_deliverData(buffer) {</span>
<a href="#l4.157"></a><span id="l4.157" class="difflineplus">+  // In ideal circumstances, we'd like to parse the message all at once. In</span>
<a href="#l4.158"></a><span id="l4.158" class="difflineplus">+  // reality, though, data will be coming to us in packets. To keep the amount</span>
<a href="#l4.159"></a><span id="l4.159" class="difflineplus">+  // of saved state low, we want to make basic guarantees about how packets get</span>
<a href="#l4.160"></a><span id="l4.160" class="difflineplus">+  // delivered. Our basic model is a twist on line-buffering, as the format of</span>
<a href="#l4.161"></a><span id="l4.161" class="difflineplus">+  // MIME and messages make it hard to not do so: we can handle multiple lines</span>
<a href="#l4.162"></a><span id="l4.162" class="difflineplus">+  // at once. To ensure this, we start by conditioning the packet by</span>
<a href="#l4.163"></a><span id="l4.163" class="difflineplus">+  // withholding data to make sure that the internal deliveries have the</span>
<a href="#l4.164"></a><span id="l4.164" class="difflineplus">+  // guarantees. This implies that we need to do the following steps:</span>
<a href="#l4.165"></a><span id="l4.165" class="difflineplus">+  // 1. We don't know if a `\r' comes from `\r\n' or the old mac line ending</span>
<a href="#l4.166"></a><span id="l4.166" class="difflineplus">+  // until we see the next character. So withhold the last `\r'.</span>
<a href="#l4.167"></a><span id="l4.167" class="difflineplus">+  // 2. Ensure that every packet ends on a newline. So scan for the end of the</span>
<a href="#l4.168"></a><span id="l4.168" class="difflineplus">+  // line and withhold until the \r\n comes through.</span>
<a href="#l4.169"></a><span id="l4.169" class="difflineplus">+  // [Note that this means that an input message that uses \r line endings and</span>
<a href="#l4.170"></a><span id="l4.170" class="difflineplus">+  // is being passed to us via a line-buffered input is going to have most of</span>
<a href="#l4.171"></a><span id="l4.171" class="difflineplus">+  // its data being withhold until the next buffer. Since \r is so uncommon of</span>
<a href="#l4.172"></a><span id="l4.172" class="difflineplus">+  // a line ending in modern times, this is acceptable lossage.]</span>
<a href="#l4.173"></a><span id="l4.173" class="difflineplus">+  // 3. Eliminate empty packets.</span>
<a href="#l4.174"></a><span id="l4.174" class="difflineplus">+</span>
<a href="#l4.175"></a><span id="l4.175" class="difflineplus">+  // Add in previously saved data</span>
<a href="#l4.176"></a><span id="l4.176" class="difflineplus">+  if (this._holdData) {</span>
<a href="#l4.177"></a><span id="l4.177" class="difflineplus">+    buffer = this._holdData + buffer;</span>
<a href="#l4.178"></a><span id="l4.178" class="difflineplus">+    this._holdData = '';</span>
<a href="#l4.179"></a><span id="l4.179" class="difflineplus">+  }</span>
<a href="#l4.180"></a><span id="l4.180" class="difflineplus">+</span>
<a href="#l4.181"></a><span id="l4.181" class="difflineplus">+  // Condition the input, so that we get the multiline-buffering mentioned in</span>
<a href="#l4.182"></a><span id="l4.182" class="difflineplus">+  // the above comment.</span>
<a href="#l4.183"></a><span id="l4.183" class="difflineplus">+  if (buffer.length &gt; 0) {</span>
<a href="#l4.184"></a><span id="l4.184" class="difflineplus">+    [buffer, this._holdData] = conditionToEndOnCRLF(buffer);</span>
<a href="#l4.185"></a><span id="l4.185" class="difflineplus">+  }</span>
<a href="#l4.186"></a><span id="l4.186" class="difflineplus">+</span>
<a href="#l4.187"></a><span id="l4.187" class="difflineplus">+  // Ignore 0-length buffers.</span>
<a href="#l4.188"></a><span id="l4.188" class="difflineplus">+  if (buffer.length == 0)</span>
<a href="#l4.189"></a><span id="l4.189" class="difflineplus">+    return;</span>
<a href="#l4.190"></a><span id="l4.190" class="difflineplus">+</span>
<a href="#l4.191"></a><span id="l4.191" class="difflineplus">+  // Signal the beginning, if we haven't done so.</span>
<a href="#l4.192"></a><span id="l4.192" class="difflineplus">+  if (!this._triggeredCall) {</span>
<a href="#l4.193"></a><span id="l4.193" class="difflineplus">+    this._callEmitter(&quot;startMessage&quot;);</span>
<a href="#l4.194"></a><span id="l4.194" class="difflineplus">+    this._triggeredCall = true;</span>
<a href="#l4.195"></a><span id="l4.195" class="difflineplus">+  }</span>
<a href="#l4.196"></a><span id="l4.196" class="difflineplus">+</span>
<a href="#l4.197"></a><span id="l4.197" class="difflineplus">+  // Finally, send it the internal parser.</span>
<a href="#l4.198"></a><span id="l4.198" class="difflineplus">+  this._dispatchData(&quot;&quot;, buffer, true);</span>
<a href="#l4.199"></a><span id="l4.199" class="difflineplus">+}</span>
<a href="#l4.200"></a><span id="l4.200" class="difflineplus">+</span>
<a href="#l4.201"></a><span id="l4.201" class="difflineplus">+/// This function returns [string that ends in CRLF, rest of string]</span>
<a href="#l4.202"></a><span id="l4.202" class="difflineplus">+function conditionToEndOnCRLF(buffer) {</span>
<a href="#l4.203"></a><span id="l4.203" class="difflineplus">+  // Find the last occurrence of '\r' or '\n' to split the string. However, we</span>
<a href="#l4.204"></a><span id="l4.204" class="difflineplus">+  // don't want to consider '\r' if it is the very last character, as we need</span>
<a href="#l4.205"></a><span id="l4.205" class="difflineplus">+  // the next packet to tell if the '\r' is the beginning of a CRLF or a line</span>
<a href="#l4.206"></a><span id="l4.206" class="difflineplus">+  // ending by itself.</span>
<a href="#l4.207"></a><span id="l4.207" class="difflineplus">+  let lastCR = buffer.lastIndexOf('\r', buffer.length - 2);</span>
<a href="#l4.208"></a><span id="l4.208" class="difflineplus">+  let lastLF = buffer.lastIndexOf('\n');</span>
<a href="#l4.209"></a><span id="l4.209" class="difflineplus">+  let end = lastLF &gt; lastCR ? lastLF : lastCR;</span>
<a href="#l4.210"></a><span id="l4.210" class="difflineplus">+  return [buffer.substring(0, end + 1), buffer.substring(end + 1)];</span>
<a href="#l4.211"></a><span id="l4.211" class="difflineplus">+}</span>
<a href="#l4.212"></a><span id="l4.212" class="difflineplus">+</span>
<a href="#l4.213"></a><span id="l4.213" class="difflineplus">+/**</span>
<a href="#l4.214"></a><span id="l4.214" class="difflineplus">+ * Tell the parser that all of the data has been delivered.</span>
<a href="#l4.215"></a><span id="l4.215" class="difflineplus">+ *</span>
<a href="#l4.216"></a><span id="l4.216" class="difflineplus">+ * This will flush all of the internal state of the parser.</span>
<a href="#l4.217"></a><span id="l4.217" class="difflineplus">+ */</span>
<a href="#l4.218"></a><span id="l4.218" class="difflineplus">+Parser.prototype.deliverEOF = function Parser_deliverEOF() {</span>
<a href="#l4.219"></a><span id="l4.219" class="difflineplus">+  // Start of input buffered too long? Call start message now.</span>
<a href="#l4.220"></a><span id="l4.220" class="difflineplus">+  if (!this._triggeredCall) {</span>
<a href="#l4.221"></a><span id="l4.221" class="difflineplus">+    this._triggeredCall = true;</span>
<a href="#l4.222"></a><span id="l4.222" class="difflineplus">+    this._callEmitter(&quot;startMessage&quot;);</span>
<a href="#l4.223"></a><span id="l4.223" class="difflineplus">+  }</span>
<a href="#l4.224"></a><span id="l4.224" class="difflineplus">+  // Force a flush of all of the data.</span>
<a href="#l4.225"></a><span id="l4.225" class="difflineplus">+  if (this._holdData)</span>
<a href="#l4.226"></a><span id="l4.226" class="difflineplus">+    this._dispatchData(&quot;&quot;, this._holdData, true);</span>
<a href="#l4.227"></a><span id="l4.227" class="difflineplus">+  this._dispatchEOF(&quot;&quot;);</span>
<a href="#l4.228"></a><span id="l4.228" class="difflineplus">+  // Signal to the emitter that we're done.</span>
<a href="#l4.229"></a><span id="l4.229" class="difflineplus">+  this._callEmitter(&quot;endMessage&quot;);</span>
<a href="#l4.230"></a><span id="l4.230" class="difflineplus">+}</span>
<a href="#l4.231"></a><span id="l4.231" class="difflineplus">+</span>
<a href="#l4.232"></a><span id="l4.232" class="difflineplus">+/**</span>
<a href="#l4.233"></a><span id="l4.233" class="difflineplus">+ * Calls a method on the emitter safely.</span>
<a href="#l4.234"></a><span id="l4.234" class="difflineplus">+ *</span>
<a href="#l4.235"></a><span id="l4.235" class="difflineplus">+ * This method ensures that errors in the emitter call won't cause the parser</span>
<a href="#l4.236"></a><span id="l4.236" class="difflineplus">+ * to exit with an error, unless the user wants it to.</span>
<a href="#l4.237"></a><span id="l4.237" class="difflineplus">+ */</span>
<a href="#l4.238"></a><span id="l4.238" class="difflineplus">+Parser.prototype._callEmitter = function Parser_callEmitter(funcname) {</span>
<a href="#l4.239"></a><span id="l4.239" class="difflineplus">+  if (this._emitter &amp;&amp; funcname in this._emitter) {</span>
<a href="#l4.240"></a><span id="l4.240" class="difflineplus">+    let args = Array.prototype.splice.call(arguments, 1);</span>
<a href="#l4.241"></a><span id="l4.241" class="difflineplus">+    if (args.length &gt; 0 &amp;&amp; this._willIgnorePart(args[0])) {</span>
<a href="#l4.242"></a><span id="l4.242" class="difflineplus">+      // partNum is always the first argument, so check to make sure that it</span>
<a href="#l4.243"></a><span id="l4.243" class="difflineplus">+      // satisfies our emitter's pruneat requirement.</span>
<a href="#l4.244"></a><span id="l4.244" class="difflineplus">+      return;</span>
<a href="#l4.245"></a><span id="l4.245" class="difflineplus">+    }</span>
<a href="#l4.246"></a><span id="l4.246" class="difflineplus">+    try {</span>
<a href="#l4.247"></a><span id="l4.247" class="difflineplus">+      this._emitter[funcname].apply(this._emitter, args);</span>
<a href="#l4.248"></a><span id="l4.248" class="difflineplus">+    } catch (e) {</span>
<a href="#l4.249"></a><span id="l4.249" class="difflineplus">+      // We ensure that the onerror attribute in options is a function, so this</span>
<a href="#l4.250"></a><span id="l4.250" class="difflineplus">+      // is always safe.</span>
<a href="#l4.251"></a><span id="l4.251" class="difflineplus">+      this._options.onerror(e);</span>
<a href="#l4.252"></a><span id="l4.252" class="difflineplus">+    }</span>
<a href="#l4.253"></a><span id="l4.253" class="difflineplus">+  }</span>
<a href="#l4.254"></a><span id="l4.254" class="difflineplus">+}</span>
<a href="#l4.255"></a><span id="l4.255" class="difflineplus">+</span>
<a href="#l4.256"></a><span id="l4.256" class="difflineplus">+/**</span>
<a href="#l4.257"></a><span id="l4.257" class="difflineplus">+ * Helper function to decide if a part's output will never be seen.</span>
<a href="#l4.258"></a><span id="l4.258" class="difflineplus">+ */</span>
<a href="#l4.259"></a><span id="l4.259" class="difflineplus">+Parser.prototype._willIgnorePart = function Parser_willIgnorePart(part) {</span>
<a href="#l4.260"></a><span id="l4.260" class="difflineplus">+  if (this._options[&quot;pruneat&quot;]) {</span>
<a href="#l4.261"></a><span id="l4.261" class="difflineplus">+    let match = this._options[&quot;pruneat&quot;];</span>
<a href="#l4.262"></a><span id="l4.262" class="difflineplus">+    let start = part.substr(0, match.length);</span>
<a href="#l4.263"></a><span id="l4.263" class="difflineplus">+    // It needs to start with and follow with a new part indicator</span>
<a href="#l4.264"></a><span id="l4.264" class="difflineplus">+    // (i.e., don't let 10 match with 1, but let 1.1 or 1$ do so)</span>
<a href="#l4.265"></a><span id="l4.265" class="difflineplus">+    if (start != match || (match.length &lt; part.length &amp;&amp;</span>
<a href="#l4.266"></a><span id="l4.266" class="difflineplus">+          &quot;$.&quot;.indexOf(part[match.length]) == -1))</span>
<a href="#l4.267"></a><span id="l4.267" class="difflineplus">+      return true;</span>
<a href="#l4.268"></a><span id="l4.268" class="difflineplus">+  }</span>
<a href="#l4.269"></a><span id="l4.269" class="difflineplus">+  return false;</span>
<a href="#l4.270"></a><span id="l4.270" class="difflineplus">+}</span>
<a href="#l4.271"></a><span id="l4.271" class="difflineplus">+</span>
<a href="#l4.272"></a><span id="l4.272" class="difflineplus">+//////////////////////</span>
<a href="#l4.273"></a><span id="l4.273" class="difflineplus">+// MIME parser core //</span>
<a href="#l4.274"></a><span id="l4.274" class="difflineplus">+//////////////////////</span>
<a href="#l4.275"></a><span id="l4.275" class="difflineplus">+</span>
<a href="#l4.276"></a><span id="l4.276" class="difflineplus">+// This MIME parser is a stateful parser; handling of the MIME tree is mostly</span>
<a href="#l4.277"></a><span id="l4.277" class="difflineplus">+// done by creating new parsers and feeding data to them manually. In parallel</span>
<a href="#l4.278"></a><span id="l4.278" class="difflineplus">+// to the externally-visible deliverData and deliverEOF, the two methods</span>
<a href="#l4.279"></a><span id="l4.279" class="difflineplus">+// _dispatchData and _dispatchEOF are the internal counterparts that do the</span>
<a href="#l4.280"></a><span id="l4.280" class="difflineplus">+// main work of moving data to where it needs to go; helper functions are used</span>
<a href="#l4.281"></a><span id="l4.281" class="difflineplus">+// to handle translation.</span>
<a href="#l4.282"></a><span id="l4.282" class="difflineplus">+//</span>
<a href="#l4.283"></a><span id="l4.283" class="difflineplus">+// The overall flow of the parser is this. First, it buffers all of the data</span>
<a href="#l4.284"></a><span id="l4.284" class="difflineplus">+// until the dual-CRLF pattern is noticed. Once that is found, it parses the</span>
<a href="#l4.285"></a><span id="l4.285" class="difflineplus">+// entire header chunk at once. As a result of header parsing, the parser enters</span>
<a href="#l4.286"></a><span id="l4.286" class="difflineplus">+// one of three modes for handling data, and uses a special regex to change</span>
<a href="#l4.287"></a><span id="l4.287" class="difflineplus">+// modes and handle state changes. Specific details about the states the parser</span>
<a href="#l4.288"></a><span id="l4.288" class="difflineplus">+// can be in are as follows:</span>
<a href="#l4.289"></a><span id="l4.289" class="difflineplus">+//   PARSING_HEADERS: The input buffer is concatenated to the currently-received</span>
<a href="#l4.290"></a><span id="l4.290" class="difflineplus">+//     text, which is then searched for the CRLFCRLF pattern. If found, the data</span>
<a href="#l4.291"></a><span id="l4.291" class="difflineplus">+//     is split at this boundary; the first chunk is parsed using _parseHeaders,</span>
<a href="#l4.292"></a><span id="l4.292" class="difflineplus">+//     and the second chunk will fall through to buffer processing. After</span>
<a href="#l4.293"></a><span id="l4.293" class="difflineplus">+//     splitting, the headers are deliverd via the emitter, and _startBody is</span>
<a href="#l4.294"></a><span id="l4.294" class="difflineplus">+//     called to set up state for the parser.</span>
<a href="#l4.295"></a><span id="l4.295" class="difflineplus">+//   SEND_TO_BLACK_HOLE: All data in the input is ignored.</span>
<a href="#l4.296"></a><span id="l4.296" class="difflineplus">+//   SEND_TO_EMITTER: All data is passed into the emitter, if it is desired.</span>
<a href="#l4.297"></a><span id="l4.297" class="difflineplus">+//     Data can be optionally converted with this._convertData.</span>
<a href="#l4.298"></a><span id="l4.298" class="difflineplus">+//   SEND_TO_SUBPARSER: All data is passed into the subparser's _dispatchData</span>
<a href="#l4.299"></a><span id="l4.299" class="difflineplus">+//     method, using _subPartNum as the part number and _subparser as the object</span>
<a href="#l4.300"></a><span id="l4.300" class="difflineplus">+//     to call. Data can be optionally converted first with this._convertData.</span>
<a href="#l4.301"></a><span id="l4.301" class="difflineplus">+//</span>
<a href="#l4.302"></a><span id="l4.302" class="difflineplus">+// Additional state modifications can be done using a regex in _splitRegex and</span>
<a href="#l4.303"></a><span id="l4.303" class="difflineplus">+// the callback method this._handleSplit(partNum, regexResult). The _handleSplit</span>
<a href="#l4.304"></a><span id="l4.304" class="difflineplus">+// callback is free to do any modification to the current parser, including</span>
<a href="#l4.305"></a><span id="l4.305" class="difflineplus">+// modifying the _splitRegex value. Packet conditioning guarantees that every</span>
<a href="#l4.306"></a><span id="l4.306" class="difflineplus">+// buffer string passed into _dispatchData will have started immediately after a</span>
<a href="#l4.307"></a><span id="l4.307" class="difflineplus">+// newline character in the fully assembled message.</span>
<a href="#l4.308"></a><span id="l4.308" class="difflineplus">+//</span>
<a href="#l4.309"></a><span id="l4.309" class="difflineplus">+// The this._convertData method, if present, is expected to return an array of</span>
<a href="#l4.310"></a><span id="l4.310" class="difflineplus">+// two values, [{typedarray, string} decoded_buffer, string unused_buffer], and</span>
<a href="#l4.311"></a><span id="l4.311" class="difflineplus">+// has as its arguments (string buffer, bool moreToCome).</span>
<a href="#l4.312"></a><span id="l4.312" class="difflineplus">+//</span>
<a href="#l4.313"></a><span id="l4.313" class="difflineplus">+// The header parsing by itself does very little parsing, only parsing as if all</span>
<a href="#l4.314"></a><span id="l4.314" class="difflineplus">+// headers were unstructured fields. Values are munged so that embedded newlines</span>
<a href="#l4.315"></a><span id="l4.315" class="difflineplus">+// are stripped and the result is also trimmed. Headers themselves are</span>
<a href="#l4.316"></a><span id="l4.316" class="difflineplus">+// canonicalized into lower-case.</span>
<a href="#l4.317"></a><span id="l4.317" class="difflineplus">+</span>
<a href="#l4.318"></a><span id="l4.318" class="difflineplus">+</span>
<a href="#l4.319"></a><span id="l4.319" class="difflineplus">+// Parser states. See the large comment above.</span>
<a href="#l4.320"></a><span id="l4.320" class="difflineplus">+const PARSING_HEADERS = 1;</span>
<a href="#l4.321"></a><span id="l4.321" class="difflineplus">+const SEND_TO_BLACK_HOLE = 2;</span>
<a href="#l4.322"></a><span id="l4.322" class="difflineplus">+const SEND_TO_EMITTER = 3;</span>
<a href="#l4.323"></a><span id="l4.323" class="difflineplus">+const SEND_TO_SUBPARSER = 4;</span>
<a href="#l4.324"></a><span id="l4.324" class="difflineplus">+</span>
<a href="#l4.325"></a><span id="l4.325" class="difflineplus">+/**</span>
<a href="#l4.326"></a><span id="l4.326" class="difflineplus">+ * Main dispatch for incoming packet data.</span>
<a href="#l4.327"></a><span id="l4.327" class="difflineplus">+ *</span>
<a href="#l4.328"></a><span id="l4.328" class="difflineplus">+ * The incoming data needs to have been sanitized so that each packet begins on</span>
<a href="#l4.329"></a><span id="l4.329" class="difflineplus">+ * a newline boundary. The part number for the current parser also needs to be</span>
<a href="#l4.330"></a><span id="l4.330" class="difflineplus">+ * passed in. The checkSplit parameter controls whether or not the data in</span>
<a href="#l4.331"></a><span id="l4.331" class="difflineplus">+ * buffer needs to be checked against _splitRegex; this is used internally for</span>
<a href="#l4.332"></a><span id="l4.332" class="difflineplus">+ * the mechanics of splitting and should otherwise always be true.</span>
<a href="#l4.333"></a><span id="l4.333" class="difflineplus">+ */</span>
<a href="#l4.334"></a><span id="l4.334" class="difflineplus">+Parser.prototype._dispatchData = function Parser_dispatchData(partNum, buffer,</span>
<a href="#l4.335"></a><span id="l4.335" class="difflineplus">+    checkSplit) {</span>
<a href="#l4.336"></a><span id="l4.336" class="difflineplus">+  // Are we parsing headers?</span>
<a href="#l4.337"></a><span id="l4.337" class="difflineplus">+  if (this._state == PARSING_HEADERS) {</span>
<a href="#l4.338"></a><span id="l4.338" class="difflineplus">+    this._headerData += buffer;</span>
<a href="#l4.339"></a><span id="l4.339" class="difflineplus">+    // Find the end of the headers--either it's a CRLF at the beginning (in</span>
<a href="#l4.340"></a><span id="l4.340" class="difflineplus">+    // which case we have no headers), or it's a pair of CRLFs.</span>
<a href="#l4.341"></a><span id="l4.341" class="difflineplus">+    let result = /(?:^(?:\r\n|[\r\n]))|(\r\n|[\r\n])\1/.exec(this._headerData);</span>
<a href="#l4.342"></a><span id="l4.342" class="difflineplus">+    if (result != null) {</span>
<a href="#l4.343"></a><span id="l4.343" class="difflineplus">+      // If we found the end of headers, split the data at this point and send</span>
<a href="#l4.344"></a><span id="l4.344" class="difflineplus">+      // the stuff after the double-CRLF into the later body parsing.</span>
<a href="#l4.345"></a><span id="l4.345" class="difflineplus">+      let headers = this._headerData.substr(0, result.index);</span>
<a href="#l4.346"></a><span id="l4.346" class="difflineplus">+      buffer = this._headerData.substring(result.index + result[0].length);</span>
<a href="#l4.347"></a><span id="l4.347" class="difflineplus">+      this._headerData = headers;</span>
<a href="#l4.348"></a><span id="l4.348" class="difflineplus">+      this._headers = this._parseHeaders();</span>
<a href="#l4.349"></a><span id="l4.349" class="difflineplus">+      this._callEmitter(&quot;startPart&quot;, partNum, this._headers);</span>
<a href="#l4.350"></a><span id="l4.350" class="difflineplus">+      this._startBody(partNum);</span>
<a href="#l4.351"></a><span id="l4.351" class="difflineplus">+    } else {</span>
<a href="#l4.352"></a><span id="l4.352" class="difflineplus">+      return;</span>
<a href="#l4.353"></a><span id="l4.353" class="difflineplus">+    }</span>
<a href="#l4.354"></a><span id="l4.354" class="difflineplus">+  }</span>
<a href="#l4.355"></a><span id="l4.355" class="difflineplus">+</span>
<a href="#l4.356"></a><span id="l4.356" class="difflineplus">+  // We're in the middle of the body. Start by testing the split regex, to see</span>
<a href="#l4.357"></a><span id="l4.357" class="difflineplus">+  // if there are many things that need to be done.</span>
<a href="#l4.358"></a><span id="l4.358" class="difflineplus">+  if (checkSplit &amp;&amp; this._splitRegex) {</span>
<a href="#l4.359"></a><span id="l4.359" class="difflineplus">+    let splitResult = this._splitRegex.exec(buffer);</span>
<a href="#l4.360"></a><span id="l4.360" class="difflineplus">+    if (splitResult) {</span>
<a href="#l4.361"></a><span id="l4.361" class="difflineplus">+      // Pass the text before the split through the current state.</span>
<a href="#l4.362"></a><span id="l4.362" class="difflineplus">+      let start = splitResult.index, len = splitResult[0].length;</span>
<a href="#l4.363"></a><span id="l4.363" class="difflineplus">+      if (start &gt; 0)</span>
<a href="#l4.364"></a><span id="l4.364" class="difflineplus">+        this._dispatchData(partNum, buffer.substr(0, start), false);</span>
<a href="#l4.365"></a><span id="l4.365" class="difflineplus">+</span>
<a href="#l4.366"></a><span id="l4.366" class="difflineplus">+      // Tell the handler that we've seen the split. Note that this can change</span>
<a href="#l4.367"></a><span id="l4.367" class="difflineplus">+      // any method on `this'.</span>
<a href="#l4.368"></a><span id="l4.368" class="difflineplus">+      this._handleSplit(partNum, splitResult);</span>
<a href="#l4.369"></a><span id="l4.369" class="difflineplus">+</span>
<a href="#l4.370"></a><span id="l4.370" class="difflineplus">+      // Send the rest of the data to where it needs to go. There could be more</span>
<a href="#l4.371"></a><span id="l4.371" class="difflineplus">+      // splits in the data, so watch out!</span>
<a href="#l4.372"></a><span id="l4.372" class="difflineplus">+      buffer = buffer.substring(start + len);</span>
<a href="#l4.373"></a><span id="l4.373" class="difflineplus">+      if (buffer.length &gt; 0)</span>
<a href="#l4.374"></a><span id="l4.374" class="difflineplus">+        this._dispatchData(partNum, buffer, true);</span>
<a href="#l4.375"></a><span id="l4.375" class="difflineplus">+      return;</span>
<a href="#l4.376"></a><span id="l4.376" class="difflineplus">+    }</span>
<a href="#l4.377"></a><span id="l4.377" class="difflineplus">+  }</span>
<a href="#l4.378"></a><span id="l4.378" class="difflineplus">+</span>
<a href="#l4.379"></a><span id="l4.379" class="difflineplus">+  // Where does the data go?</span>
<a href="#l4.380"></a><span id="l4.380" class="difflineplus">+  if (this._state == SEND_TO_BLACK_HOLE) {</span>
<a href="#l4.381"></a><span id="l4.381" class="difflineplus">+    // Don't send any data when going to the black hole.</span>
<a href="#l4.382"></a><span id="l4.382" class="difflineplus">+    return;</span>
<a href="#l4.383"></a><span id="l4.383" class="difflineplus">+  } else if (this._state == SEND_TO_EMITTER) {</span>
<a href="#l4.384"></a><span id="l4.384" class="difflineplus">+    // Don't pass body data if the format is to be none</span>
<a href="#l4.385"></a><span id="l4.385" class="difflineplus">+    let passData = this._options[&quot;bodyformat&quot;] != &quot;none&quot;;</span>
<a href="#l4.386"></a><span id="l4.386" class="difflineplus">+    if (!passData || this._willIgnorePart(partNum))</span>
<a href="#l4.387"></a><span id="l4.387" class="difflineplus">+      return;</span>
<a href="#l4.388"></a><span id="l4.388" class="difflineplus">+    buffer = this._applyDataConversion(buffer, this._options[&quot;strformat&quot;]);</span>
<a href="#l4.389"></a><span id="l4.389" class="difflineplus">+    if (buffer.length &gt; 0)</span>
<a href="#l4.390"></a><span id="l4.390" class="difflineplus">+      this._callEmitter(&quot;deliverPartData&quot;, partNum, buffer);</span>
<a href="#l4.391"></a><span id="l4.391" class="difflineplus">+  } else if (this._state == SEND_TO_SUBPARSER) {</span>
<a href="#l4.392"></a><span id="l4.392" class="difflineplus">+    buffer = this._applyDataConversion(buffer, &quot;binarystring&quot;);</span>
<a href="#l4.393"></a><span id="l4.393" class="difflineplus">+    if (buffer.length &gt; 0)</span>
<a href="#l4.394"></a><span id="l4.394" class="difflineplus">+      this._subparser._dispatchData(this._subPartNum, buffer, true);</span>
<a href="#l4.395"></a><span id="l4.395" class="difflineplus">+  }</span>
<a href="#l4.396"></a><span id="l4.396" class="difflineplus">+}</span>
<a href="#l4.397"></a><span id="l4.397" class="difflineplus">+</span>
<a href="#l4.398"></a><span id="l4.398" class="difflineplus">+/// Applies this._convertData(buffer, true) if necessary</span>
<a href="#l4.399"></a><span id="l4.399" class="difflineplus">+Parser.prototype._applyDataConversion = function Parser_convertData(buf, type) {</span>
<a href="#l4.400"></a><span id="l4.400" class="difflineplus">+  // If we need to convert data, do so.</span>
<a href="#l4.401"></a><span id="l4.401" class="difflineplus">+  if (this._convertData) {</span>
<a href="#l4.402"></a><span id="l4.402" class="difflineplus">+    // Prepend leftover data from the last conversion.</span>
<a href="#l4.403"></a><span id="l4.403" class="difflineplus">+    buf = this._savedBuffer + buf;</span>
<a href="#l4.404"></a><span id="l4.404" class="difflineplus">+    [buf, this._savedBuffer] = this._convertData(buf, true);</span>
<a href="#l4.405"></a><span id="l4.405" class="difflineplus">+  }</span>
<a href="#l4.406"></a><span id="l4.406" class="difflineplus">+  return this._coerceData(buf, type, true);</span>
<a href="#l4.407"></a><span id="l4.407" class="difflineplus">+}</span>
<a href="#l4.408"></a><span id="l4.408" class="difflineplus">+</span>
<a href="#l4.409"></a><span id="l4.409" class="difflineplus">+/// Coerces the buffer (a string or typedarray) into a given type</span>
<a href="#l4.410"></a><span id="l4.410" class="difflineplus">+Parser.prototype._coerceData = function Parser_coerce(buffer, type, more) {</span>
<a href="#l4.411"></a><span id="l4.411" class="difflineplus">+  // Note: This function is a placeholder for later code primarily relating to</span>
<a href="#l4.412"></a><span id="l4.412" class="difflineplus">+  // charsets and strformat options.</span>
<a href="#l4.413"></a><span id="l4.413" class="difflineplus">+  return buffer;</span>
<a href="#l4.414"></a><span id="l4.414" class="difflineplus">+}</span>
<a href="#l4.415"></a><span id="l4.415" class="difflineplus">+</span>
<a href="#l4.416"></a><span id="l4.416" class="difflineplus">+/**</span>
<a href="#l4.417"></a><span id="l4.417" class="difflineplus">+ * Signal that no more data will be dispatched to this parser.</span>
<a href="#l4.418"></a><span id="l4.418" class="difflineplus">+ */</span>
<a href="#l4.419"></a><span id="l4.419" class="difflineplus">+Parser.prototype._dispatchEOF = function Parser_dispatchEOF(partNum) {</span>
<a href="#l4.420"></a><span id="l4.420" class="difflineplus">+  if (this._state == PARSING_HEADERS) {</span>
<a href="#l4.421"></a><span id="l4.421" class="difflineplus">+    // Unexpected EOF in headers. Parse them now and call startPart/endPart</span>
<a href="#l4.422"></a><span id="l4.422" class="difflineplus">+    this._headers = this._parseHeaders();</span>
<a href="#l4.423"></a><span id="l4.423" class="difflineplus">+    this._callEmitter(&quot;startPart&quot;, partNum, this._headers);</span>
<a href="#l4.424"></a><span id="l4.424" class="difflineplus">+  } else if (this._state == SEND_TO_SUBPARSER) {</span>
<a href="#l4.425"></a><span id="l4.425" class="difflineplus">+    // Pass in any lingering data</span>
<a href="#l4.426"></a><span id="l4.426" class="difflineplus">+    if (this._convertData &amp;&amp; this._savedBuffer)</span>
<a href="#l4.427"></a><span id="l4.427" class="difflineplus">+      this._subparser._dispatchData(this._subPartNum,</span>
<a href="#l4.428"></a><span id="l4.428" class="difflineplus">+        this._convertData(this._savedBuffer, false)[0], true);</span>
<a href="#l4.429"></a><span id="l4.429" class="difflineplus">+    this._subparser._dispatchEOF(this._subPartNum);</span>
<a href="#l4.430"></a><span id="l4.430" class="difflineplus">+    // Clean up after ourselves</span>
<a href="#l4.431"></a><span id="l4.431" class="difflineplus">+    this._subparser = null;</span>
<a href="#l4.432"></a><span id="l4.432" class="difflineplus">+  } else if (this._convertData &amp;&amp; this._savedBuffer) {</span>
<a href="#l4.433"></a><span id="l4.433" class="difflineplus">+    // Convert lingering data</span>
<a href="#l4.434"></a><span id="l4.434" class="difflineplus">+    [buffer, ] = this._convertData(this._savedBuffer, false);</span>
<a href="#l4.435"></a><span id="l4.435" class="difflineplus">+    buffer = this._coerceData(buffer, this._options[&quot;strformat&quot;], false);</span>
<a href="#l4.436"></a><span id="l4.436" class="difflineplus">+    if (buffer.length &gt; 0)</span>
<a href="#l4.437"></a><span id="l4.437" class="difflineplus">+      this._callEmitter(&quot;deliverPartData&quot;, partNum, buffer);</span>
<a href="#l4.438"></a><span id="l4.438" class="difflineplus">+  }</span>
<a href="#l4.439"></a><span id="l4.439" class="difflineplus">+</span>
<a href="#l4.440"></a><span id="l4.440" class="difflineplus">+  // We've reached EOF for this part; tell the emitter</span>
<a href="#l4.441"></a><span id="l4.441" class="difflineplus">+  this._callEmitter(&quot;endPart&quot;, partNum);</span>
<a href="#l4.442"></a><span id="l4.442" class="difflineplus">+}</span>
<a href="#l4.443"></a><span id="l4.443" class="difflineplus">+</span>
<a href="#l4.444"></a><span id="l4.444" class="difflineplus">+/**</span>
<a href="#l4.445"></a><span id="l4.445" class="difflineplus">+ * Produce a dictionary of all headers as if they were unstructured fields.</span>
<a href="#l4.446"></a><span id="l4.446" class="difflineplus">+ */</span>
<a href="#l4.447"></a><span id="l4.447" class="difflineplus">+Parser.prototype._parseHeaders = function Parser_parseHeaders() {</span>
<a href="#l4.448"></a><span id="l4.448" class="difflineplus">+  // An individual header is terminated by a CRLF, except if the CRLF is</span>
<a href="#l4.449"></a><span id="l4.449" class="difflineplus">+  // followed by a SP or TAB. Use negative lookahead to capture the latter case,</span>
<a href="#l4.450"></a><span id="l4.450" class="difflineplus">+  // and don't capture the strings or else split results get nasty.</span>
<a href="#l4.451"></a><span id="l4.451" class="difflineplus">+  let values = this._headerData.split(/(?:\r\n|\n)(?![ \t])|\r(?![ \t\n])/);</span>
<a href="#l4.452"></a><span id="l4.452" class="difflineplus">+</span>
<a href="#l4.453"></a><span id="l4.453" class="difflineplus">+  // Ignore the first &quot;header&quot; if it begins with an mbox delimiter</span>
<a href="#l4.454"></a><span id="l4.454" class="difflineplus">+  if (values.length &gt; 0 &amp;&amp; values[0].substring(0, 5) == &quot;From &quot;) {</span>
<a href="#l4.455"></a><span id="l4.455" class="difflineplus">+    values.shift();</span>
<a href="#l4.456"></a><span id="l4.456" class="difflineplus">+    // Elide the mbox delimiter from this._headerData</span>
<a href="#l4.457"></a><span id="l4.457" class="difflineplus">+    if (values.length == 0)</span>
<a href="#l4.458"></a><span id="l4.458" class="difflineplus">+      this._headerData = '';</span>
<a href="#l4.459"></a><span id="l4.459" class="difflineplus">+    else</span>
<a href="#l4.460"></a><span id="l4.460" class="difflineplus">+      this._headerData = this._headerData.substring(</span>
<a href="#l4.461"></a><span id="l4.461" class="difflineplus">+        this._headerData.indexOf(values[0]));</span>
<a href="#l4.462"></a><span id="l4.462" class="difflineplus">+  }</span>
<a href="#l4.463"></a><span id="l4.463" class="difflineplus">+</span>
<a href="#l4.464"></a><span id="l4.464" class="difflineplus">+  let headers = new Map();</span>
<a href="#l4.465"></a><span id="l4.465" class="difflineplus">+  for (let i = 0; i &lt; values.length; i++) {</span>
<a href="#l4.466"></a><span id="l4.466" class="difflineplus">+    // Look for a colon. If it's not present, this header line is malformed,</span>
<a href="#l4.467"></a><span id="l4.467" class="difflineplus">+    // perhaps by premature EOF or similar. The value is null in this case.</span>
<a href="#l4.468"></a><span id="l4.468" class="difflineplus">+    let colon = values[i].indexOf(&quot;:&quot;);</span>
<a href="#l4.469"></a><span id="l4.469" class="difflineplus">+    if (colon &gt;= 0) {</span>
<a href="#l4.470"></a><span id="l4.470" class="difflineplus">+      var header = values[i].substring(0, colon);</span>
<a href="#l4.471"></a><span id="l4.471" class="difflineplus">+      var val = values[i].substring(colon + 1).trim().replace(/[\r\n]/g,'');</span>
<a href="#l4.472"></a><span id="l4.472" class="difflineplus">+    } else {</span>
<a href="#l4.473"></a><span id="l4.473" class="difflineplus">+      var header = values[i];</span>
<a href="#l4.474"></a><span id="l4.474" class="difflineplus">+      var val = null;</span>
<a href="#l4.475"></a><span id="l4.475" class="difflineplus">+    }</span>
<a href="#l4.476"></a><span id="l4.476" class="difflineplus">+</span>
<a href="#l4.477"></a><span id="l4.477" class="difflineplus">+    // Canonicalize the header in lower-case form.</span>
<a href="#l4.478"></a><span id="l4.478" class="difflineplus">+    header = header.trim().toLowerCase();</span>
<a href="#l4.479"></a><span id="l4.479" class="difflineplus">+    // Omit &quot;empty&quot; headers</span>
<a href="#l4.480"></a><span id="l4.480" class="difflineplus">+    if (header == '')</span>
<a href="#l4.481"></a><span id="l4.481" class="difflineplus">+      continue;</span>
<a href="#l4.482"></a><span id="l4.482" class="difflineplus">+</span>
<a href="#l4.483"></a><span id="l4.483" class="difflineplus">+    // We keep an array of values for each header, since a given header may be</span>
<a href="#l4.484"></a><span id="l4.484" class="difflineplus">+    // repeated multiple times.</span>
<a href="#l4.485"></a><span id="l4.485" class="difflineplus">+    if (headers.has(header)) {</span>
<a href="#l4.486"></a><span id="l4.486" class="difflineplus">+      headers.get(header).push(val);</span>
<a href="#l4.487"></a><span id="l4.487" class="difflineplus">+    } else {</span>
<a href="#l4.488"></a><span id="l4.488" class="difflineplus">+      headers.set(header, [val]);</span>
<a href="#l4.489"></a><span id="l4.489" class="difflineplus">+    }</span>
<a href="#l4.490"></a><span id="l4.490" class="difflineplus">+  }</span>
<a href="#l4.491"></a><span id="l4.491" class="difflineplus">+</span>
<a href="#l4.492"></a><span id="l4.492" class="difflineplus">+  headers.rawHeaderText = this._headerData;</span>
<a href="#l4.493"></a><span id="l4.493" class="difflineplus">+  return headers;</span>
<a href="#l4.494"></a><span id="l4.494" class="difflineplus">+}</span>
<a href="#l4.495"></a><span id="l4.495" class="difflineplus">+</span>
<a href="#l4.496"></a><span id="l4.496" class="difflineplus">+/**</span>
<a href="#l4.497"></a><span id="l4.497" class="difflineplus">+ * Initialize the parser state for the body of this message.</span>
<a href="#l4.498"></a><span id="l4.498" class="difflineplus">+ */</span>
<a href="#l4.499"></a><span id="l4.499" class="difflineplus">+Parser.prototype._startBody = function Parser_startBody(partNum) {</span>
<a href="#l4.500"></a><span id="l4.500" class="difflineplus">+  // Should the bodyformat be raw, we just want to pass through all data without</span>
<a href="#l4.501"></a><span id="l4.501" class="difflineplus">+  // trying to interpret it.</span>
<a href="#l4.502"></a><span id="l4.502" class="difflineplus">+  if (this._options[&quot;bodyformat&quot;] == &quot;raw&quot; &amp;&amp;</span>
<a href="#l4.503"></a><span id="l4.503" class="difflineplus">+      partNum == this._options[&quot;pruneat&quot;]) {</span>
<a href="#l4.504"></a><span id="l4.504" class="difflineplus">+    this._state = SEND_TO_EMITTER;</span>
<a href="#l4.505"></a><span id="l4.505" class="difflineplus">+    return;</span>
<a href="#l4.506"></a><span id="l4.506" class="difflineplus">+  }</span>
<a href="#l4.507"></a><span id="l4.507" class="difflineplus">+  // What do we assume if there's no content-type?</span>
<a href="#l4.508"></a><span id="l4.508" class="difflineplus">+  let defaultContentType = this._defaultContentType || 'text/plain';</span>
<a href="#l4.509"></a><span id="l4.509" class="difflineplus">+  let contentType = this._extractHeader('content-type', defaultContentType);</span>
<a href="#l4.510"></a><span id="l4.510" class="difflineplus">+</span>
<a href="#l4.511"></a><span id="l4.511" class="difflineplus">+  // The output depents on the content-type. Basic rule of thumb:</span>
<a href="#l4.512"></a><span id="l4.512" class="difflineplus">+  // 1. Discrete media types (text, video, audio, image, application) are passed</span>
<a href="#l4.513"></a><span id="l4.513" class="difflineplus">+  //    through with no alterations beyond Content-Transfer-Encoding unpacking.</span>
<a href="#l4.514"></a><span id="l4.514" class="difflineplus">+  // 2. Everything with a media type of multipart is treated the same.</span>
<a href="#l4.515"></a><span id="l4.515" class="difflineplus">+  // 3. Any message/* type that acts like a mail message (rfc822, news, global)</span>
<a href="#l4.516"></a><span id="l4.516" class="difflineplus">+  //    is parsed as a header/body pair again. Most of the other message/* types</span>
<a href="#l4.517"></a><span id="l4.517" class="difflineplus">+  //    have similar structures, but they don't have cascading child subparts,</span>
<a href="#l4.518"></a><span id="l4.518" class="difflineplus">+  //    so it's better to pass their entire contents to the emitter and let the</span>
<a href="#l4.519"></a><span id="l4.519" class="difflineplus">+  //    consumer deal with them.</span>
<a href="#l4.520"></a><span id="l4.520" class="difflineplus">+  // 4. For untyped data, there needs to be no Content-Type header. This helps</span>
<a href="#l4.521"></a><span id="l4.521" class="difflineplus">+  //    avoid false positives.</span>
<a href="#l4.522"></a><span id="l4.522" class="difflineplus">+  if (contentType.mediatype == 'multipart') {</span>
<a href="#l4.523"></a><span id="l4.523" class="difflineplus">+    // If there's no boundary type, everything will be part of the prologue of</span>
<a href="#l4.524"></a><span id="l4.524" class="difflineplus">+    // the multipart message, so just feed everything into a black hole.</span>
<a href="#l4.525"></a><span id="l4.525" class="difflineplus">+    if (!('param-boundary' in contentType)) {</span>
<a href="#l4.526"></a><span id="l4.526" class="difflineplus">+      this._state = SEND_TO_BLACK_HOLE;</span>
<a href="#l4.527"></a><span id="l4.527" class="difflineplus">+      return;</span>
<a href="#l4.528"></a><span id="l4.528" class="difflineplus">+    }</span>
<a href="#l4.529"></a><span id="l4.529" class="difflineplus">+    // The boundary of a multipart message needs to start with -- and be at the</span>
<a href="#l4.530"></a><span id="l4.530" class="difflineplus">+    // beginning of the line. If -- is after the boundary, it represents the</span>
<a href="#l4.531"></a><span id="l4.531" class="difflineplus">+    // terminator of the multipart. After the line, there may be only whitespace</span>
<a href="#l4.532"></a><span id="l4.532" class="difflineplus">+    // and then the CRLF at the end. Since the CRLFs in here are necessary for</span>
<a href="#l4.533"></a><span id="l4.533" class="difflineplus">+    // distinguishing the parts, they are not included in the subparts, so we</span>
<a href="#l4.534"></a><span id="l4.534" class="difflineplus">+    // need to capture them in the regex as well to prevent them leaking out.</span>
<a href="#l4.535"></a><span id="l4.535" class="difflineplus">+    this._splitRegex = new RegExp('(\r\n|[\r\n]|^)--' +</span>
<a href="#l4.536"></a><span id="l4.536" class="difflineplus">+      contentType['param-boundary'].replace(/[\\^$*+?.()|{}[\]]/g, '\\$&amp;') +</span>
<a href="#l4.537"></a><span id="l4.537" class="difflineplus">+      '(--)?[ \t]*(?:\r\n|[\r\n]|$)');</span>
<a href="#l4.538"></a><span id="l4.538" class="difflineplus">+    this._handleSplit = this._whenMultipart;</span>
<a href="#l4.539"></a><span id="l4.539" class="difflineplus">+    this._subparser = new Parser(this._emitter, this._options);</span>
<a href="#l4.540"></a><span id="l4.540" class="difflineplus">+    // multipart/digest defaults to message/rfc822 instead of text/plain</span>
<a href="#l4.541"></a><span id="l4.541" class="difflineplus">+    if (contentType.subtype == &quot;digest&quot;)</span>
<a href="#l4.542"></a><span id="l4.542" class="difflineplus">+      this._subparser._defaultContentType = &quot;message/rfc822&quot;;</span>
<a href="#l4.543"></a><span id="l4.543" class="difflineplus">+</span>
<a href="#l4.544"></a><span id="l4.544" class="difflineplus">+    // All text before the first boundary and after the closing boundary are</span>
<a href="#l4.545"></a><span id="l4.545" class="difflineplus">+    // supposed to be ignored (&quot;must be ignored&quot;, according to RFC 2046 5.1.1);</span>
<a href="#l4.546"></a><span id="l4.546" class="difflineplus">+    // in accordance with these wishes, ensure they don't get passed to any</span>
<a href="#l4.547"></a><span id="l4.547" class="difflineplus">+    // deliverPartData.</span>
<a href="#l4.548"></a><span id="l4.548" class="difflineplus">+    this._state = SEND_TO_BLACK_HOLE;</span>
<a href="#l4.549"></a><span id="l4.549" class="difflineplus">+</span>
<a href="#l4.550"></a><span id="l4.550" class="difflineplus">+    // Multipart MIME messages stipulate that the final CRLF before the boundary</span>
<a href="#l4.551"></a><span id="l4.551" class="difflineplus">+    // delimiter is not matched. When the packet ends on a CRLF, we don't know</span>
<a href="#l4.552"></a><span id="l4.552" class="difflineplus">+    // if the next text could be the boundary. Therefore, we need to withhold</span>
<a href="#l4.553"></a><span id="l4.553" class="difflineplus">+    // the last line of text to be sure of what's going on. The _convertData is</span>
<a href="#l4.554"></a><span id="l4.554" class="difflineplus">+    // how we do this, even though we're not really converting any data.</span>
<a href="#l4.555"></a><span id="l4.555" class="difflineplus">+    this._convertData = function mpart_no_leak_crlf(buffer, more) {</span>
<a href="#l4.556"></a><span id="l4.556" class="difflineplus">+      let splitPoint = buffer.length;</span>
<a href="#l4.557"></a><span id="l4.557" class="difflineplus">+      if (more) {</span>
<a href="#l4.558"></a><span id="l4.558" class="difflineplus">+        if (buffer.charAt(splitPoint - 1) == '\n')</span>
<a href="#l4.559"></a><span id="l4.559" class="difflineplus">+          splitPoint--;</span>
<a href="#l4.560"></a><span id="l4.560" class="difflineplus">+        if (splitPoint &gt;= 0 &amp;&amp; buffer.charAt(splitPoint - 1) == '\r')</span>
<a href="#l4.561"></a><span id="l4.561" class="difflineplus">+          splitPoint--;</span>
<a href="#l4.562"></a><span id="l4.562" class="difflineplus">+      }</span>
<a href="#l4.563"></a><span id="l4.563" class="difflineplus">+      let [preLF, rest] = conditionToEndOnCRLF(buffer.substring(0, splitPoint));</span>
<a href="#l4.564"></a><span id="l4.564" class="difflineplus">+      return [preLF, rest + buffer.substring(splitPoint)];</span>
<a href="#l4.565"></a><span id="l4.565" class="difflineplus">+    }</span>
<a href="#l4.566"></a><span id="l4.566" class="difflineplus">+  } else if (contentType.type == 'message/rfc822' ||</span>
<a href="#l4.567"></a><span id="l4.567" class="difflineplus">+      contentType.type == 'message/global' ||</span>
<a href="#l4.568"></a><span id="l4.568" class="difflineplus">+      contentType.type == 'message/news') {</span>
<a href="#l4.569"></a><span id="l4.569" class="difflineplus">+    // The subpart is just another header/body pair that goes to EOF, so just</span>
<a href="#l4.570"></a><span id="l4.570" class="difflineplus">+    // return the parse from that blob</span>
<a href="#l4.571"></a><span id="l4.571" class="difflineplus">+    this._state = SEND_TO_SUBPARSER;</span>
<a href="#l4.572"></a><span id="l4.572" class="difflineplus">+    this._subPartNum = partNum + &quot;$&quot;;</span>
<a href="#l4.573"></a><span id="l4.573" class="difflineplus">+    this._subparser = new Parser(this._emitter, this._options);</span>
<a href="#l4.574"></a><span id="l4.574" class="difflineplus">+</span>
<a href="#l4.575"></a><span id="l4.575" class="difflineplus">+    // So, RFC 6532 happily allows message/global types to have CTE applied.</span>
<a href="#l4.576"></a><span id="l4.576" class="difflineplus">+    // This means that subparts would need to be decoded to determine their</span>
<a href="#l4.577"></a><span id="l4.577" class="difflineplus">+    // contents properly. There seems to be some evidence that message/rfc822</span>
<a href="#l4.578"></a><span id="l4.578" class="difflineplus">+    // that is illegally-encoded exists in the wild, so be lenient and decode</span>
<a href="#l4.579"></a><span id="l4.579" class="difflineplus">+    // for any message/* type that gets here.</span>
<a href="#l4.580"></a><span id="l4.580" class="difflineplus">+    let cte = this._extractHeader('content-transfer-encoding', '');</span>
<a href="#l4.581"></a><span id="l4.581" class="difflineplus">+    if (cte in ContentDecoders)</span>
<a href="#l4.582"></a><span id="l4.582" class="difflineplus">+      this._convertData = ContentDecoders[cte];</span>
<a href="#l4.583"></a><span id="l4.583" class="difflineplus">+  } else {</span>
<a href="#l4.584"></a><span id="l4.584" class="difflineplus">+    // Okay, we just have to feed the data into the output</span>
<a href="#l4.585"></a><span id="l4.585" class="difflineplus">+    this._state = SEND_TO_EMITTER;</span>
<a href="#l4.586"></a><span id="l4.586" class="difflineplus">+    if (this._options[&quot;bodyformat&quot;] == &quot;decode&quot;) {</span>
<a href="#l4.587"></a><span id="l4.587" class="difflineplus">+      // If we wish to decode, look it up in one of our decoders.</span>
<a href="#l4.588"></a><span id="l4.588" class="difflineplus">+      let cte = this._extractHeader('content-transfer-encoding', '');</span>
<a href="#l4.589"></a><span id="l4.589" class="difflineplus">+      if (cte in ContentDecoders)</span>
<a href="#l4.590"></a><span id="l4.590" class="difflineplus">+        this._convertData = ContentDecoders[cte];</span>
<a href="#l4.591"></a><span id="l4.591" class="difflineplus">+    }</span>
<a href="#l4.592"></a><span id="l4.592" class="difflineplus">+  }</span>
<a href="#l4.593"></a><span id="l4.593" class="difflineplus">+}</span>
<a href="#l4.594"></a><span id="l4.594" class="difflineplus">+</span>
<a href="#l4.595"></a><span id="l4.595" class="difflineplus">+// Internal split handling for multipart messages.</span>
<a href="#l4.596"></a><span id="l4.596" class="difflineplus">+Parser.prototype._whenMultipart = function Parser_mpart(partNum, lastResult) {</span>
<a href="#l4.597"></a><span id="l4.597" class="difflineplus">+  // Fix up the part number (don't do '' -&gt; '.4' and don't do '1' -&gt; '14')</span>
<a href="#l4.598"></a><span id="l4.598" class="difflineplus">+  if (partNum != &quot;&quot;) partNum += &quot;.&quot;;</span>
<a href="#l4.599"></a><span id="l4.599" class="difflineplus">+  if (!this._subPartNum) {</span>
<a href="#l4.600"></a><span id="l4.600" class="difflineplus">+    // No count? This means that this is the first time we've seen the boundary,</span>
<a href="#l4.601"></a><span id="l4.601" class="difflineplus">+    // so do some initialization for later here.</span>
<a href="#l4.602"></a><span id="l4.602" class="difflineplus">+    this._count = 1;</span>
<a href="#l4.603"></a><span id="l4.603" class="difflineplus">+  } else {</span>
<a href="#l4.604"></a><span id="l4.604" class="difflineplus">+    // If we did not match a CRLF at the beginning of the line, strip CRLF from</span>
<a href="#l4.605"></a><span id="l4.605" class="difflineplus">+    // the saved buffer. We do this in the else block because it is not</span>
<a href="#l4.606"></a><span id="l4.606" class="difflineplus">+    // necessary for the prologue, since that gets ignored anyways.</span>
<a href="#l4.607"></a><span id="l4.607" class="difflineplus">+    if (this._savedBuffer != '' &amp;&amp; lastResult[1] === '') {</span>
<a href="#l4.608"></a><span id="l4.608" class="difflineplus">+      let useEnd = this._savedBuffer.length - 1;</span>
<a href="#l4.609"></a><span id="l4.609" class="difflineplus">+      if (this._savedBuffer[useEnd] == '\n')</span>
<a href="#l4.610"></a><span id="l4.610" class="difflineplus">+        useEnd--;</span>
<a href="#l4.611"></a><span id="l4.611" class="difflineplus">+      if (useEnd &gt;= 0 &amp;&amp; this._savedBuffer[useEnd] == '\r')</span>
<a href="#l4.612"></a><span id="l4.612" class="difflineplus">+        useEnd--;</span>
<a href="#l4.613"></a><span id="l4.613" class="difflineplus">+      this._savedBuffer = this._savedBuffer.substring(0, useEnd + 1);</span>
<a href="#l4.614"></a><span id="l4.614" class="difflineplus">+    }</span>
<a href="#l4.615"></a><span id="l4.615" class="difflineplus">+    // If we have saved data and we matched a CRLF, pass the saved data in.</span>
<a href="#l4.616"></a><span id="l4.616" class="difflineplus">+    if (this._savedBuffer != '')</span>
<a href="#l4.617"></a><span id="l4.617" class="difflineplus">+      this._subparser._dispatchData(this._subPartNum, this._savedBuffer, true);</span>
<a href="#l4.618"></a><span id="l4.618" class="difflineplus">+    // We've seen the boundary at least once before, so this must end a subpart.</span>
<a href="#l4.619"></a><span id="l4.619" class="difflineplus">+    // Tell that subpart that it has reached EOF.</span>
<a href="#l4.620"></a><span id="l4.620" class="difflineplus">+    this._subparser._dispatchEOF(this._subPartNum);</span>
<a href="#l4.621"></a><span id="l4.621" class="difflineplus">+  }</span>
<a href="#l4.622"></a><span id="l4.622" class="difflineplus">+  this._savedBuffer = '';</span>
<a href="#l4.623"></a><span id="l4.623" class="difflineplus">+</span>
<a href="#l4.624"></a><span id="l4.624" class="difflineplus">+  // The regex feeder has a capture on the (--)?, so if its result is present,</span>
<a href="#l4.625"></a><span id="l4.625" class="difflineplus">+  // then we have seen the terminator. Alternatively, the message may have been</span>
<a href="#l4.626"></a><span id="l4.626" class="difflineplus">+  // mangled to exclude the terminator, so also check if EOF has occurred.</span>
<a href="#l4.627"></a><span id="l4.627" class="difflineplus">+  if (lastResult[2] == undefined) {</span>
<a href="#l4.628"></a><span id="l4.628" class="difflineplus">+    this._subparser.resetParser();</span>
<a href="#l4.629"></a><span id="l4.629" class="difflineplus">+    this._state = SEND_TO_SUBPARSER;</span>
<a href="#l4.630"></a><span id="l4.630" class="difflineplus">+    this._subPartNum = partNum + this._count;</span>
<a href="#l4.631"></a><span id="l4.631" class="difflineplus">+    this._count += 1;</span>
<a href="#l4.632"></a><span id="l4.632" class="difflineplus">+  } else {</span>
<a href="#l4.633"></a><span id="l4.633" class="difflineplus">+    // Ignore the epilogue</span>
<a href="#l4.634"></a><span id="l4.634" class="difflineplus">+    this._splitRegex = null;</span>
<a href="#l4.635"></a><span id="l4.635" class="difflineplus">+    this._state = SEND_TO_BLACK_HOLE;</span>
<a href="#l4.636"></a><span id="l4.636" class="difflineplus">+  }</span>
<a href="#l4.637"></a><span id="l4.637" class="difflineplus">+}</span>
<a href="#l4.638"></a><span id="l4.638" class="difflineplus">+</span>
<a href="#l4.639"></a><span id="l4.639" class="difflineplus">+// Extract a header. This is for internal purposes.</span>
<a href="#l4.640"></a><span id="l4.640" class="difflineplus">+// This calls the structured decoder if it exists. If it does not, it just trims</span>
<a href="#l4.641"></a><span id="l4.641" class="difflineplus">+// the value and makes it lower case.</span>
<a href="#l4.642"></a><span id="l4.642" class="difflineplus">+Parser.prototype._extractHeader = function extractHeader(name, dflt) {</span>
<a href="#l4.643"></a><span id="l4.643" class="difflineplus">+  let value = this._headers.has(name) ? this._headers.get(name)[0] : dflt;</span>
<a href="#l4.644"></a><span id="l4.644" class="difflineplus">+  if (name in StructuredDecoders)</span>
<a href="#l4.645"></a><span id="l4.645" class="difflineplus">+    return StructuredDecoders[name](value);</span>
<a href="#l4.646"></a><span id="l4.646" class="difflineplus">+  // In lieu of anything else, just return lower-case version</span>
<a href="#l4.647"></a><span id="l4.647" class="difflineplus">+  return value.trim().toLowerCase();</span>
<a href="#l4.648"></a><span id="l4.648" class="difflineplus">+}</span>
<a href="#l4.649"></a><span id="l4.649" class="difflineplus">+</span>
<a href="#l4.650"></a><span id="l4.650" class="difflineplus">+// Content transfer decoders</span>
<a href="#l4.651"></a><span id="l4.651" class="difflineplus">+var ContentDecoders = {};</span>
<a href="#l4.652"></a><span id="l4.652" class="difflineplus">+ContentDecoders['quoted-printable'] = function decode_qp(buffer, more) {</span>
<a href="#l4.653"></a><span id="l4.653" class="difflineplus">+  // Unlike base64, quoted-printable isn't stateful across multiple lines, so</span>
<a href="#l4.654"></a><span id="l4.654" class="difflineplus">+  // there is no need to buffer input, so we can always ignore more.</span>
<a href="#l4.655"></a><span id="l4.655" class="difflineplus">+  let decoded = buffer.replace(</span>
<a href="#l4.656"></a><span id="l4.656" class="difflineplus">+    // Replace either =&lt;hex&gt;&lt;hex&gt; or =&lt;wsp&gt;CRLF</span>
<a href="#l4.657"></a><span id="l4.657" class="difflineplus">+    /=([0-9A-F][0-9A-F]|[ \t]*(\r\n|[\r\n]|$))/gi,</span>
<a href="#l4.658"></a><span id="l4.658" class="difflineplus">+    function replace_chars(match, param) {</span>
<a href="#l4.659"></a><span id="l4.659" class="difflineplus">+      // If trailing text matches [ \t]*CRLF, drop everything, since it's a</span>
<a href="#l4.660"></a><span id="l4.660" class="difflineplus">+      // soft line break.</span>
<a href="#l4.661"></a><span id="l4.661" class="difflineplus">+      if (param.trim().length == 0)</span>
<a href="#l4.662"></a><span id="l4.662" class="difflineplus">+        return '';</span>
<a href="#l4.663"></a><span id="l4.663" class="difflineplus">+      return String.fromCharCode(parseInt(param, 16));</span>
<a href="#l4.664"></a><span id="l4.664" class="difflineplus">+    });</span>
<a href="#l4.665"></a><span id="l4.665" class="difflineplus">+  return [decoded, ''];</span>
<a href="#l4.666"></a><span id="l4.666" class="difflineplus">+}</span>
<a href="#l4.667"></a><span id="l4.667" class="difflineplus">+ContentDecoders['base64'] = function decode_base64(buffer, more) {</span>
<a href="#l4.668"></a><span id="l4.668" class="difflineplus">+  // Drop all non-base64 characters</span>
<a href="#l4.669"></a><span id="l4.669" class="difflineplus">+  let sanitize = buffer.replace(/[^A-Za-z0-9+\/=]/g,'');</span>
<a href="#l4.670"></a><span id="l4.670" class="difflineplus">+  // We need to encode in groups of 4 chars. If we don't have enough, leave the</span>
<a href="#l4.671"></a><span id="l4.671" class="difflineplus">+  // excess for later. If there aren't any more, drop enough to make it 4.</span>
<a href="#l4.672"></a><span id="l4.672" class="difflineplus">+  let excess = sanitize.length % 4;</span>
<a href="#l4.673"></a><span id="l4.673" class="difflineplus">+  if (excess != 0 &amp;&amp; more)</span>
<a href="#l4.674"></a><span id="l4.674" class="difflineplus">+    buffer = sanitize.slice(-excess);</span>
<a href="#l4.675"></a><span id="l4.675" class="difflineplus">+  else</span>
<a href="#l4.676"></a><span id="l4.676" class="difflineplus">+    buffer = '';</span>
<a href="#l4.677"></a><span id="l4.677" class="difflineplus">+  sanitize = sanitize.substring(0, sanitize.length - excess);</span>
<a href="#l4.678"></a><span id="l4.678" class="difflineplus">+  // Use the atob function we (ought to) have in global scope.</span>
<a href="#l4.679"></a><span id="l4.679" class="difflineplus">+  return [atob(sanitize), buffer];</span>
<a href="#l4.680"></a><span id="l4.680" class="difflineplus">+}</span>
<a href="#l4.681"></a><span id="l4.681" class="difflineplus">+</span>
<a href="#l4.682"></a><span id="l4.682" class="difflineplus">+///////////////////////////////</span>
<a href="#l4.683"></a><span id="l4.683" class="difflineplus">+// Structured field decoders //</span>
<a href="#l4.684"></a><span id="l4.684" class="difflineplus">+///////////////////////////////</span>
<a href="#l4.685"></a><span id="l4.685" class="difflineplus">+</span>
<a href="#l4.686"></a><span id="l4.686" class="difflineplus">+// Structured decoders exist in two pieces. There are the basic methods, for</span>
<a href="#l4.687"></a><span id="l4.687" class="difflineplus">+// decoding headers based on their type rather than full semantic decomposition.</span>
<a href="#l4.688"></a><span id="l4.688" class="difflineplus">+// All of these methods take as their first parameter the string to be parsed.</span>
<a href="#l4.689"></a><span id="l4.689" class="difflineplus">+// In addition to these, we have specific structurers for individual headers</span>
<a href="#l4.690"></a><span id="l4.690" class="difflineplus">+// that are useful for the parser (e.g., Content-Type).</span>
<a href="#l4.691"></a><span id="l4.691" class="difflineplus">+</span>
<a href="#l4.692"></a><span id="l4.692" class="difflineplus">+function extractParameters(headerValue) {</span>
<a href="#l4.693"></a><span id="l4.693" class="difflineplus">+  // The basic syntax of headerValue is token [; token = token-or-qstring]*</span>
<a href="#l4.694"></a><span id="l4.694" class="difflineplus">+  // Copying more or less liberally from nsMIMEHeaderParamImpl:</span>
<a href="#l4.695"></a><span id="l4.695" class="difflineplus">+  // The first token is the text to the first whitespace or semicolon.</span>
<a href="#l4.696"></a><span id="l4.696" class="difflineplus">+  var semi = headerValue.indexOf(&quot;;&quot;);</span>
<a href="#l4.697"></a><span id="l4.697" class="difflineplus">+  if (semi &lt; 0) {</span>
<a href="#l4.698"></a><span id="l4.698" class="difflineplus">+    var start = headerValue;</span>
<a href="#l4.699"></a><span id="l4.699" class="difflineplus">+    var rest = '';</span>
<a href="#l4.700"></a><span id="l4.700" class="difflineplus">+  } else {</span>
<a href="#l4.701"></a><span id="l4.701" class="difflineplus">+    var start = headerValue.substring(0, semi);</span>
<a href="#l4.702"></a><span id="l4.702" class="difflineplus">+    var rest = headerValue.substring(semi); // Include the semicolon</span>
<a href="#l4.703"></a><span id="l4.703" class="difflineplus">+  }</span>
<a href="#l4.704"></a><span id="l4.704" class="difflineplus">+  // Strip start to be &lt;WSP&gt;&lt;nowsp&gt;&lt;WSP&gt;</span>
<a href="#l4.705"></a><span id="l4.705" class="difflineplus">+  start = start.trim().split(/[ \t\r\n]/)[0];</span>
<a href="#l4.706"></a><span id="l4.706" class="difflineplus">+</span>
<a href="#l4.707"></a><span id="l4.707" class="difflineplus">+  // Now, match parameters. The RFC 2231 processing comes later, just yank out</span>
<a href="#l4.708"></a><span id="l4.708" class="difflineplus">+  // all of the parameters for now. This is doing via a regex which is</span>
<a href="#l4.709"></a><span id="l4.709" class="difflineplus">+  // continually executed to find each pair. The match to try to find is this:</span>
<a href="#l4.710"></a><span id="l4.710" class="difflineplus">+  // ;&lt;WSP&gt;&lt;token&gt;&lt;WSP&gt;=&lt;WSP&gt;&lt;token&gt; or ;&lt;WSP&gt;&lt;token&gt;&lt;WSP&gt;=&lt;WSP&gt;&lt;quote string&gt;</span>
<a href="#l4.711"></a><span id="l4.711" class="difflineplus">+  // where the first token is any string that isn't whitespace and doesn't</span>
<a href="#l4.712"></a><span id="l4.712" class="difflineplus">+  // contain an = or ; and the second token merely doesn't contain ;.</span>
<a href="#l4.713"></a><span id="l4.713" class="difflineplus">+  var wsp = &quot;[ \t\r\n]*&quot;;</span>
<a href="#l4.714"></a><span id="l4.714" class="difflineplus">+  var token = &quot;[^ \t\r\n=;]*&quot;;</span>
<a href="#l4.715"></a><span id="l4.715" class="difflineplus">+  var qstring = '&quot;(?:[^\\\\&quot;]|\\\\.)*&quot;?';</span>
<a href="#l4.716"></a><span id="l4.716" class="difflineplus">+  var qstring_or_tok = qstring + &quot;|[^ \t\r\n;]*&quot;;</span>
<a href="#l4.717"></a><span id="l4.717" class="difflineplus">+  var regex = new RegExp(&quot;;&quot; + wsp + &quot;(&quot; + token + &quot;)&quot; + wsp + &quot;=&quot; + wsp +</span>
<a href="#l4.718"></a><span id="l4.718" class="difflineplus">+    &quot;(&quot; + qstring_or_tok + &quot;)&quot;, &quot;g&quot;);</span>
<a href="#l4.719"></a><span id="l4.719" class="difflineplus">+</span>
<a href="#l4.720"></a><span id="l4.720" class="difflineplus">+  // Actually do the matching</span>
<a href="#l4.721"></a><span id="l4.721" class="difflineplus">+  var matches = [], match;</span>
<a href="#l4.722"></a><span id="l4.722" class="difflineplus">+  while ((match = regex.exec(rest)) != null) {</span>
<a href="#l4.723"></a><span id="l4.723" class="difflineplus">+    var name = match[1];</span>
<a href="#l4.724"></a><span id="l4.724" class="difflineplus">+    var value = match[2];</span>
<a href="#l4.725"></a><span id="l4.725" class="difflineplus">+    if (value.length &gt; 0 &amp;&amp; value[0] == '&quot;') {</span>
<a href="#l4.726"></a><span id="l4.726" class="difflineplus">+      let end = value.length &gt; 1 &amp;&amp; value[value.length - 1] == '&quot;' ?</span>
<a href="#l4.727"></a><span id="l4.727" class="difflineplus">+        value.length - 1 : value.length;</span>
<a href="#l4.728"></a><span id="l4.728" class="difflineplus">+      value = value.substring(1, end).replace(/\\(.)/g, &quot;$1&quot;);</span>
<a href="#l4.729"></a><span id="l4.729" class="difflineplus">+    }</span>
<a href="#l4.730"></a><span id="l4.730" class="difflineplus">+    matches.push([name, value]);</span>
<a href="#l4.731"></a><span id="l4.731" class="difflineplus">+  }</span>
<a href="#l4.732"></a><span id="l4.732" class="difflineplus">+</span>
<a href="#l4.733"></a><span id="l4.733" class="difflineplus">+  // Now matches holds the parameters. Clean up for RFC 2231. There are four</span>
<a href="#l4.734"></a><span id="l4.734" class="difflineplus">+  // cases: param=val, param*=us-ascii'en-US'blah, and param*n= variants. The</span>
<a href="#l4.735"></a><span id="l4.735" class="difflineplus">+  // order of preference is to pick the middle, then the last, then the first.</span>
<a href="#l4.736"></a><span id="l4.736" class="difflineplus">+  // TODO: RFC 2231 is yet to be implemented</span>
<a href="#l4.737"></a><span id="l4.737" class="difflineplus">+  var simpleValues = {};</span>
<a href="#l4.738"></a><span id="l4.738" class="difflineplus">+  for (let [name, value] of matches) {</span>
<a href="#l4.739"></a><span id="l4.739" class="difflineplus">+    // The first match of simple param=val wins.</span>
<a href="#l4.740"></a><span id="l4.740" class="difflineplus">+    if (!(name in simpleValues))</span>
<a href="#l4.741"></a><span id="l4.741" class="difflineplus">+      simpleValues[name] = value;</span>
<a href="#l4.742"></a><span id="l4.742" class="difflineplus">+  }</span>
<a href="#l4.743"></a><span id="l4.743" class="difflineplus">+  return [start, simpleValues];</span>
<a href="#l4.744"></a><span id="l4.744" class="difflineplus">+}</span>
<a href="#l4.745"></a><span id="l4.745" class="difflineplus">+</span>
<a href="#l4.746"></a><span id="l4.746" class="difflineplus">+var StructuredDecoders = {};</span>
<a href="#l4.747"></a><span id="l4.747" class="difflineplus">+StructuredDecoders['content-type'] = function structure_content_type(value) {</span>
<a href="#l4.748"></a><span id="l4.748" class="difflineplus">+  let [type, params] = extractParameters(value);</span>
<a href="#l4.749"></a><span id="l4.749" class="difflineplus">+  let parts = type.split('/');</span>
<a href="#l4.750"></a><span id="l4.750" class="difflineplus">+  if (parts.length != 2) {</span>
<a href="#l4.751"></a><span id="l4.751" class="difflineplus">+    // Malformed. Return to text/plain. Evil, ain't it?</span>
<a href="#l4.752"></a><span id="l4.752" class="difflineplus">+    params = {};</span>
<a href="#l4.753"></a><span id="l4.753" class="difflineplus">+    parts = [&quot;text&quot;, &quot;plain&quot;];</span>
<a href="#l4.754"></a><span id="l4.754" class="difflineplus">+  }</span>
<a href="#l4.755"></a><span id="l4.755" class="difflineplus">+  let mediatype = parts[0].toLowerCase();</span>
<a href="#l4.756"></a><span id="l4.756" class="difflineplus">+  let subtype = parts[1].toLowerCase();</span>
<a href="#l4.757"></a><span id="l4.757" class="difflineplus">+  let type = mediatype + '/' + subtype;</span>
<a href="#l4.758"></a><span id="l4.758" class="difflineplus">+  let structure = {</span>
<a href="#l4.759"></a><span id="l4.759" class="difflineplus">+    'mediatype': mediatype,</span>
<a href="#l4.760"></a><span id="l4.760" class="difflineplus">+    'subtype': subtype,</span>
<a href="#l4.761"></a><span id="l4.761" class="difflineplus">+    'type': type,</span>
<a href="#l4.762"></a><span id="l4.762" class="difflineplus">+  };</span>
<a href="#l4.763"></a><span id="l4.763" class="difflineplus">+  for (let name in params) {</span>
<a href="#l4.764"></a><span id="l4.764" class="difflineplus">+    structure['param-' + name.toLowerCase()] = params[name];</span>
<a href="#l4.765"></a><span id="l4.765" class="difflineplus">+  }</span>
<a href="#l4.766"></a><span id="l4.766" class="difflineplus">+  return structure;</span>
<a href="#l4.767"></a><span id="l4.767" class="difflineplus">+};</span>
<a href="#l4.768"></a><span id="l4.768" class="difflineplus">+</span>
<a href="#l4.769"></a><span id="l4.769" class="difflineplus">+</span>
<a href="#l4.770"></a><span id="l4.770" class="difflineplus">+// Gather up the header parsing things for easier export as symbols.</span>
<a href="#l4.771"></a><span id="l4.771" class="difflineplus">+var HeaderParser = Object.freeze({</span>
<a href="#l4.772"></a><span id="l4.772" class="difflineplus">+  extractParameters: extractParameters</span>
<a href="#l4.773"></a><span id="l4.773" class="difflineplus">+});</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

