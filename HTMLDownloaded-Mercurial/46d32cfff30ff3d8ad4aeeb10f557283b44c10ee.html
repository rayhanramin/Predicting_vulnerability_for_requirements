<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/4b0de666d1a4/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/4b0de666d1a4/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/4b0de666d1a4/mercurial.js"></script>

<meta property="og:image" content="/static/4b0de666d1a4/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 29295:46d32cfff30ff3d8ad4aeeb10f557283b44c10ee</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 46d32cfff30ff3d8ad4aeeb10f557283b44c10ee" />
<meta property="og:url" content="/comm-central/rev/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee" />
<meta property="og:description" content="Bug 1621782 - Import zlib sources into comm-central. r=kaie" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/4b0de666d1a4/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 46d32cfff30ff3d8ad4aeeb10f557283b44c10ee 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee">shortlog</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee">files</a> |
changeset |
<a href="/comm-central/raw-rev/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee">raw</a>  | <a href="/comm-central/archive/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1621782">Bug 1621782</a> - Import zlib sources into comm-central. r=kaie
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#82;&#111;&#98;&#32;&#76;&#101;&#109;&#108;&#101;&#121;&#32;&#60;&#114;&#111;&#98;&#64;&#116;&#104;&#117;&#110;&#100;&#101;&#114;&#98;&#105;&#114;&#100;&#46;&#110;&#101;&#116;&#62;</td></tr>
<tr><td></td><td class="date age">Tue, 14 Apr 2020 22:24:32 +0000</td></tr>

<tr>
 <td>changeset 29295</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee">46d32cfff30ff3d8ad4aeeb10f557283b44c10ee</a></td>
</tr>



<tr>
<td>parent 29294</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/107ee9bfae2229dc132b65b14383bee3ecddfc4f">107ee9bfae2229dc132b65b14383bee3ecddfc4f</a>
</td>
</tr>

<tr>
<td>child 29296</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/fec353984d2545227f0e160e8c1fa89c00f4fa65">fec353984d2545227f0e160e8c1fa89c00f4fa65</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=46d32cfff30ff3d8ad4aeeb10f557283b44c10ee">17301</a></td></tr>
<tr><td>push user</td><td>thunderbird@calypsoblue.org</td></tr>
<tr><td>push date</td><td class="date age">Wed, 15 Apr 2020 18:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@7c06681d8e9a [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=7c06681d8e9a22d9226498c34b620cd4d3cf8ea3">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=7c06681d8e9a22d9226498c34b620cd4d3cf8ea3&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=7c06681d8e9a22d9226498c34b620cd4d3cf8ea3&newProject=comm-central&newRevision=46d32cfff30ff3d8ad4aeeb10f557283b44c10ee&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=7c06681d8e9a22d9226498c34b620cd4d3cf8ea3&newProject=comm-central&newRevision=46d32cfff30ff3d8ad4aeeb10f557283b44c10ee&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=7c06681d8e9a22d9226498c34b620cd4d3cf8ea3&newProject=comm-central&newRevision=46d32cfff30ff3d8ad4aeeb10f557283b44c10ee&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28kaie%29&revcount=50">kaie</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1621782">1621782</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1621782">Bug 1621782</a> - Import zlib sources into comm-central. r=kaie

Zlib is a required dependency for RNP which will not be present
on all operating systems that we support.

Differential Revision: <a href="https://phabricator.services.mozilla.com/D70734">https://phabricator.services.mozilla.com/D70734</a></div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/README.zlib">third_party/README.zlib</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/README.zlib">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/README.zlib">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/README.zlib">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/README.zlib">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/README.zlib">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/ChangeLog">third_party/zlib/ChangeLog</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/ChangeLog">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/ChangeLog">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/ChangeLog">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/ChangeLog">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/ChangeLog">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/Changelog.mzla">third_party/zlib/Changelog.mzla</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/Changelog.mzla">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/Changelog.mzla">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/Changelog.mzla">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/Changelog.mzla">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/Changelog.mzla">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/FAQ">third_party/zlib/FAQ</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/FAQ">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/FAQ">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/FAQ">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/FAQ">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/FAQ">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/INDEX">third_party/zlib/INDEX</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/INDEX">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/INDEX">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/INDEX">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/INDEX">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/INDEX">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/README">third_party/zlib/README</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/README">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/README">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/README">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/README">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/README">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/adler32.c">third_party/zlib/adler32.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/adler32.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/adler32.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/adler32.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/adler32.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/adler32.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/compress.c">third_party/zlib/compress.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/compress.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/compress.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/compress.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/compress.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/compress.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/crc32.c">third_party/zlib/crc32.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/crc32.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/crc32.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/crc32.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/crc32.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/crc32.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/crc32.h">third_party/zlib/crc32.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/crc32.h">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/crc32.h">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/crc32.h">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/crc32.h">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/crc32.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/deflate.c">third_party/zlib/deflate.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/deflate.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/deflate.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/deflate.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/deflate.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/deflate.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/deflate.h">third_party/zlib/deflate.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/deflate.h">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/deflate.h">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/deflate.h">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/deflate.h">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/deflate.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzclose.c">third_party/zlib/gzclose.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzclose.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzclose.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzclose.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzclose.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzclose.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzguts.h">third_party/zlib/gzguts.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzguts.h">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzguts.h">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzguts.h">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzguts.h">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzguts.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzlib.c">third_party/zlib/gzlib.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzlib.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzlib.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzlib.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzlib.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzlib.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzread.c">third_party/zlib/gzread.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzread.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzread.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzread.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzread.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzread.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzwrite.c">third_party/zlib/gzwrite.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzwrite.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzwrite.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzwrite.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzwrite.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/gzwrite.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/infback.c">third_party/zlib/infback.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/infback.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/infback.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/infback.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/infback.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/infback.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffast.c">third_party/zlib/inffast.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffast.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffast.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffast.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffast.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffast.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffast.h">third_party/zlib/inffast.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffast.h">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffast.h">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffast.h">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffast.h">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffast.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffixed.h">third_party/zlib/inffixed.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffixed.h">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffixed.h">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffixed.h">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffixed.h">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inffixed.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inflate.c">third_party/zlib/inflate.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inflate.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inflate.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inflate.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inflate.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inflate.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inflate.h">third_party/zlib/inflate.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inflate.h">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inflate.h">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inflate.h">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inflate.h">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inflate.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inftrees.c">third_party/zlib/inftrees.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inftrees.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inftrees.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inftrees.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inftrees.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inftrees.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inftrees.h">third_party/zlib/inftrees.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inftrees.h">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inftrees.h">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inftrees.h">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inftrees.h">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/inftrees.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/trees.c">third_party/zlib/trees.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/trees.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/trees.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/trees.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/trees.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/trees.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/trees.h">third_party/zlib/trees.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/trees.h">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/trees.h">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/trees.h">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/trees.h">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/trees.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/uncompr.c">third_party/zlib/uncompr.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/uncompr.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/uncompr.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/uncompr.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/uncompr.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/uncompr.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zconf.h">third_party/zlib/zconf.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zconf.h">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zconf.h">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zconf.h">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zconf.h">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zconf.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zlib.def">third_party/zlib/zlib.def</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zlib.def">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zlib.def">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zlib.def">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zlib.def">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zlib.def">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zlib.h">third_party/zlib/zlib.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zlib.h">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zlib.h">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zlib.h">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zlib.h">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zlib.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zutil.c">third_party/zlib/zutil.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zutil.c">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zutil.c">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zutil.c">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zutil.c">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zutil.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zutil.h">third_party/zlib/zutil.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zutil.h">file</a> |
<a href="/comm-central/annotate/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zutil.h">annotate</a> |
<a href="/comm-central/diff/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zutil.h">diff</a> |
<a href="/comm-central/comparison/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zutil.h">comparison</a> |
<a href="/comm-central/log/46d32cfff30ff3d8ad4aeeb10f557283b44c10ee/third_party/zlib/zutil.h">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1">new file mode 100644</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineminus">--- /dev/null</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineplus">+++ b/third_party/README.zlib</span>
<a href="#l1.4"></a><span id="l1.4" class="difflineat">@@ -0,0 +1,45 @@</span>
<a href="#l1.5"></a><span id="l1.5" class="difflineplus">+Directory ./zlib contains a copy of version 1.2.11 of the Zlib library,</span>
<a href="#l1.6"></a><span id="l1.6" class="difflineplus">+which has been obtained from http://zlib.net/zlib-1.2.11.tar.gz .</span>
<a href="#l1.7"></a><span id="l1.7" class="difflineplus">+</span>
<a href="#l1.8"></a><span id="l1.8" class="difflineplus">+For licensing information, please refer to the included documentation.</span>
<a href="#l1.9"></a><span id="l1.9" class="difflineplus">+</span>
<a href="#l1.10"></a><span id="l1.10" class="difflineplus">+The SHA256SUM of the imported file is:</span>
<a href="#l1.11"></a><span id="l1.11" class="difflineplus">+c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1  zlib-1.2.11.tar.gz</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+The following files and directories were removed from the source distribution's root:</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+amiga</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+contrib</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+doc</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+examples</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineplus">+msdos</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+nintendods</span>
<a href="#l1.20"></a><span id="l1.20" class="difflineplus">+old</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineplus">+os400</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineplus">+qnx</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineplus">+test</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineplus">+watcom</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineplus">+win32</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineplus">+CMakeLists.txt</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineplus">+Makefile</span>
<a href="#l1.28"></a><span id="l1.28" class="difflineplus">+Makefile.in</span>
<a href="#l1.29"></a><span id="l1.29" class="difflineplus">+configure</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineplus">+make_vms.com</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineplus">+treebuild.xml</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+zconf.h.cmakein</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineplus">+zconf.h.in</span>
<a href="#l1.34"></a><span id="l1.34" class="difflineplus">+zlib.3</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineplus">+zlib.3.pdf</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineplus">+zlib.map</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineplus">+zlib.pc.cmakein</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineplus">+zlib.pc.in</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineplus">+zlib2ansi</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineplus">+</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineplus">+</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+The following files were added to the source's root by MZLA Technologies:</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+Changelog.mzla</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+moz.build</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+zlib.def (copied from above removed zlib/win32 directory)</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineplus">+</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineplus">+Use of this distribution is not required to build Thunderbird's OpenPGP support.</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineplus">+You may set --enable-system-zlib at build time to dynamically link to another zlib.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1">new file mode 100644</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineminus">--- /dev/null</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineplus">+++ b/third_party/zlib/ChangeLog</span>
<a href="#l2.4"></a><span id="l2.4" class="difflineat">@@ -0,0 +1,1515 @@</span>
<a href="#l2.5"></a><span id="l2.5" class="difflineplus">+</span>
<a href="#l2.6"></a><span id="l2.6" class="difflineplus">+                ChangeLog file for zlib</span>
<a href="#l2.7"></a><span id="l2.7" class="difflineplus">+</span>
<a href="#l2.8"></a><span id="l2.8" class="difflineplus">+Changes in 1.2.11 (15 Jan 2017)</span>
<a href="#l2.9"></a><span id="l2.9" class="difflineplus">+- Fix deflate stored bug when pulling last block from window</span>
<a href="#l2.10"></a><span id="l2.10" class="difflineplus">+- Permit immediate deflateParams changes before any deflate input</span>
<a href="#l2.11"></a><span id="l2.11" class="difflineplus">+</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+Changes in 1.2.10 (2 Jan 2017)</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+- Avoid warnings on snprintf() return value</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+- Fix bug in deflate_stored() for zero-length input</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+- Fix bug in gzwrite.c that produced corrupt gzip files</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+- Remove files to be installed before copying them in Makefile.in</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+- Add warnings when compiling with assembler code</span>
<a href="#l2.18"></a><span id="l2.18" class="difflineplus">+</span>
<a href="#l2.19"></a><span id="l2.19" class="difflineplus">+Changes in 1.2.9 (31 Dec 2016)</span>
<a href="#l2.20"></a><span id="l2.20" class="difflineplus">+- Fix contrib/minizip to permit unzipping with desktop API [Zouzou]</span>
<a href="#l2.21"></a><span id="l2.21" class="difflineplus">+- Improve contrib/blast to return unused bytes</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineplus">+- Assure that gzoffset() is correct when appending</span>
<a href="#l2.23"></a><span id="l2.23" class="difflineplus">+- Improve compress() and uncompress() to support large lengths</span>
<a href="#l2.24"></a><span id="l2.24" class="difflineplus">+- Fix bug in test/example.c where error code not saved</span>
<a href="#l2.25"></a><span id="l2.25" class="difflineplus">+- Remedy Coverity warning [Randers-Pehrson]</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineplus">+- Improve speed of gzprintf() in transparent mode</span>
<a href="#l2.27"></a><span id="l2.27" class="difflineplus">+- Fix inflateInit2() bug when windowBits is 16 or 32</span>
<a href="#l2.28"></a><span id="l2.28" class="difflineplus">+- Change DEBUG macro to ZLIB_DEBUG</span>
<a href="#l2.29"></a><span id="l2.29" class="difflineplus">+- Avoid uninitialized access by gzclose_w()</span>
<a href="#l2.30"></a><span id="l2.30" class="difflineplus">+- Allow building zlib outside of the source directory</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+- Fix bug that accepted invalid zlib header when windowBits is zero</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+- Fix gzseek() problem on MinGW due to buggy _lseeki64 there</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineplus">+- Loop on write() calls in gzwrite.c in case of non-blocking I/O</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+- Add --warn (-w) option to ./configure for more compiler warnings</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+- Reject a window size of 256 bytes if not using the zlib wrapper</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+- Fix bug when level 0 used with Z_HUFFMAN or Z_RLE</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+- Add --debug (-d) option to ./configure to define ZLIB_DEBUG</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+- Fix bugs in creating a very large gzip header</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineplus">+- Add uncompress2() function, which returns the input size used</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineplus">+- Assure that deflateParams() will not switch functions mid-block</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineplus">+- Dramatically speed up deflation for level 0 (storing)</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineplus">+- Add gzfread(), duplicating the interface of fread()</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineplus">+- Add gzfwrite(), duplicating the interface of fwrite()</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineplus">+- Add deflateGetDictionary() function</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineplus">+- Use snprintf() for later versions of Microsoft C</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+- Fix *Init macros to use z_ prefix when requested</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineplus">+- Replace as400 with os400 for OS/400 support [Monnerat]</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineplus">+- Add crc32_z() and adler32_z() functions with size_t lengths</span>
<a href="#l2.49"></a><span id="l2.49" class="difflineplus">+- Update Visual Studio project files [AraHaan]</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineplus">+</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineplus">+Changes in 1.2.8 (28 Apr 2013)</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineplus">+- Update contrib/minizip/iowin32.c for Windows RT [Vollant]</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineplus">+- Do not force Z_CONST for C++</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineplus">+- Clean up contrib/vstudio [Roß]</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+- Correct spelling error in zlib.h</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+- Fix mixed line endings in contrib/vstudio</span>
<a href="#l2.57"></a><span id="l2.57" class="difflineplus">+</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineplus">+Changes in 1.2.7.3 (13 Apr 2013)</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineplus">+- Fix version numbers and DLL names in contrib/vstudio/*/zlib.rc</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineplus">+</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineplus">+Changes in 1.2.7.2 (13 Apr 2013)</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineplus">+- Change check for a four-byte type back to hexadecimal</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineplus">+- Fix typo in win32/Makefile.msc</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineplus">+- Add casts in gzwrite.c for pointer differences</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineplus">+</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineplus">+Changes in 1.2.7.1 (24 Mar 2013)</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineplus">+- Replace use of unsafe string functions with snprintf if available</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineplus">+- Avoid including stddef.h on Windows for Z_SOLO compile [Niessink]</span>
<a href="#l2.69"></a><span id="l2.69" class="difflineplus">+- Fix gzgetc undefine when Z_PREFIX set [Turk]</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineplus">+- Eliminate use of mktemp in Makefile (not always available)</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+- Fix bug in 'F' mode for gzopen()</span>
<a href="#l2.72"></a><span id="l2.72" class="difflineplus">+- Add inflateGetDictionary() function</span>
<a href="#l2.73"></a><span id="l2.73" class="difflineplus">+- Correct comment in deflate.h</span>
<a href="#l2.74"></a><span id="l2.74" class="difflineplus">+- Use _snprintf for snprintf in Microsoft C</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineplus">+- On Darwin, only use /usr/bin/libtool if libtool is not Apple</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineplus">+- Delete &quot;--version&quot; file if created by &quot;ar --version&quot; [Richard G.]</span>
<a href="#l2.77"></a><span id="l2.77" class="difflineplus">+- Fix configure check for veracity of compiler error return codes</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineplus">+- Fix CMake compilation of static lib for MSVC2010 x64</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineplus">+- Remove unused variable in infback9.c</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineplus">+- Fix argument checks in gzlog_compress() and gzlog_write()</span>
<a href="#l2.81"></a><span id="l2.81" class="difflineplus">+- Clean up the usage of z_const and respect const usage within zlib</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineplus">+- Clean up examples/gzlog.[ch] comparisons of different types</span>
<a href="#l2.83"></a><span id="l2.83" class="difflineplus">+- Avoid shift equal to bits in type (caused endless loop)</span>
<a href="#l2.84"></a><span id="l2.84" class="difflineplus">+- Fix uninitialized value bug in gzputc() introduced by const patches</span>
<a href="#l2.85"></a><span id="l2.85" class="difflineplus">+- Fix memory allocation error in examples/zran.c [Nor]</span>
<a href="#l2.86"></a><span id="l2.86" class="difflineplus">+- Fix bug where gzopen(), gzclose() would write an empty file</span>
<a href="#l2.87"></a><span id="l2.87" class="difflineplus">+- Fix bug in gzclose() when gzwrite() runs out of memory</span>
<a href="#l2.88"></a><span id="l2.88" class="difflineplus">+- Check for input buffer malloc failure in examples/gzappend.c</span>
<a href="#l2.89"></a><span id="l2.89" class="difflineplus">+- Add note to contrib/blast to use binary mode in stdio</span>
<a href="#l2.90"></a><span id="l2.90" class="difflineplus">+- Fix comparisons of differently signed integers in contrib/blast</span>
<a href="#l2.91"></a><span id="l2.91" class="difflineplus">+- Check for invalid code length codes in contrib/puff</span>
<a href="#l2.92"></a><span id="l2.92" class="difflineplus">+- Fix serious but very rare decompression bug in inftrees.c</span>
<a href="#l2.93"></a><span id="l2.93" class="difflineplus">+- Update inflateBack() comments, since inflate() can be faster</span>
<a href="#l2.94"></a><span id="l2.94" class="difflineplus">+- Use underscored I/O function names for WINAPI_FAMILY</span>
<a href="#l2.95"></a><span id="l2.95" class="difflineplus">+- Add _tr_flush_bits to the external symbols prefixed by --zprefix</span>
<a href="#l2.96"></a><span id="l2.96" class="difflineplus">+- Add contrib/vstudio/vc10 pre-build step for static only</span>
<a href="#l2.97"></a><span id="l2.97" class="difflineplus">+- Quote --version-script argument in CMakeLists.txt</span>
<a href="#l2.98"></a><span id="l2.98" class="difflineplus">+- Don't specify --version-script on Apple platforms in CMakeLists.txt</span>
<a href="#l2.99"></a><span id="l2.99" class="difflineplus">+- Fix casting error in contrib/testzlib/testzlib.c</span>
<a href="#l2.100"></a><span id="l2.100" class="difflineplus">+- Fix types in contrib/minizip to match result of get_crc_table()</span>
<a href="#l2.101"></a><span id="l2.101" class="difflineplus">+- Simplify contrib/vstudio/vc10 with 'd' suffix</span>
<a href="#l2.102"></a><span id="l2.102" class="difflineplus">+- Add TOP support to win32/Makefile.msc</span>
<a href="#l2.103"></a><span id="l2.103" class="difflineplus">+- Suport i686 and amd64 assembler builds in CMakeLists.txt</span>
<a href="#l2.104"></a><span id="l2.104" class="difflineplus">+- Fix typos in the use of _LARGEFILE64_SOURCE in zconf.h</span>
<a href="#l2.105"></a><span id="l2.105" class="difflineplus">+- Add vc11 and vc12 build files to contrib/vstudio</span>
<a href="#l2.106"></a><span id="l2.106" class="difflineplus">+- Add gzvprintf() as an undocumented function in zlib</span>
<a href="#l2.107"></a><span id="l2.107" class="difflineplus">+- Fix configure for Sun shell</span>
<a href="#l2.108"></a><span id="l2.108" class="difflineplus">+- Remove runtime check in configure for four-byte integer type</span>
<a href="#l2.109"></a><span id="l2.109" class="difflineplus">+- Add casts and consts to ease user conversion to C++</span>
<a href="#l2.110"></a><span id="l2.110" class="difflineplus">+- Add man pages for minizip and miniunzip</span>
<a href="#l2.111"></a><span id="l2.111" class="difflineplus">+- In Makefile uninstall, don't rm if preceding cd fails</span>
<a href="#l2.112"></a><span id="l2.112" class="difflineplus">+- Do not return Z_BUF_ERROR if deflateParam() has nothing to write</span>
<a href="#l2.113"></a><span id="l2.113" class="difflineplus">+</span>
<a href="#l2.114"></a><span id="l2.114" class="difflineplus">+Changes in 1.2.7 (2 May 2012)</span>
<a href="#l2.115"></a><span id="l2.115" class="difflineplus">+- Replace use of memmove() with a simple copy for portability</span>
<a href="#l2.116"></a><span id="l2.116" class="difflineplus">+- Test for existence of strerror</span>
<a href="#l2.117"></a><span id="l2.117" class="difflineplus">+- Restore gzgetc_ for backward compatibility with 1.2.6</span>
<a href="#l2.118"></a><span id="l2.118" class="difflineplus">+- Fix build with non-GNU make on Solaris</span>
<a href="#l2.119"></a><span id="l2.119" class="difflineplus">+- Require gcc 4.0 or later on Mac OS X to use the hidden attribute</span>
<a href="#l2.120"></a><span id="l2.120" class="difflineplus">+- Include unistd.h for Watcom C</span>
<a href="#l2.121"></a><span id="l2.121" class="difflineplus">+- Use __WATCOMC__ instead of __WATCOM__</span>
<a href="#l2.122"></a><span id="l2.122" class="difflineplus">+- Do not use the visibility attribute if NO_VIZ defined</span>
<a href="#l2.123"></a><span id="l2.123" class="difflineplus">+- Improve the detection of no hidden visibility attribute</span>
<a href="#l2.124"></a><span id="l2.124" class="difflineplus">+- Avoid using __int64 for gcc or solo compilation</span>
<a href="#l2.125"></a><span id="l2.125" class="difflineplus">+- Cast to char * in gzprintf to avoid warnings [Zinser]</span>
<a href="#l2.126"></a><span id="l2.126" class="difflineplus">+- Fix make_vms.com for VAX [Zinser]</span>
<a href="#l2.127"></a><span id="l2.127" class="difflineplus">+- Don't use library or built-in byte swaps</span>
<a href="#l2.128"></a><span id="l2.128" class="difflineplus">+- Simplify test and use of gcc hidden attribute</span>
<a href="#l2.129"></a><span id="l2.129" class="difflineplus">+- Fix bug in gzclose_w() when gzwrite() fails to allocate memory</span>
<a href="#l2.130"></a><span id="l2.130" class="difflineplus">+- Add &quot;x&quot; (O_EXCL) and &quot;e&quot; (O_CLOEXEC) modes support to gzopen()</span>
<a href="#l2.131"></a><span id="l2.131" class="difflineplus">+- Fix bug in test/minigzip.c for configure --solo</span>
<a href="#l2.132"></a><span id="l2.132" class="difflineplus">+- Fix contrib/vstudio project link errors [Mohanathas]</span>
<a href="#l2.133"></a><span id="l2.133" class="difflineplus">+- Add ability to choose the builder in make_vms.com [Schweda]</span>
<a href="#l2.134"></a><span id="l2.134" class="difflineplus">+- Add DESTDIR support to mingw32 win32/Makefile.gcc</span>
<a href="#l2.135"></a><span id="l2.135" class="difflineplus">+- Fix comments in win32/Makefile.gcc for proper usage</span>
<a href="#l2.136"></a><span id="l2.136" class="difflineplus">+- Allow overriding the default install locations for cmake</span>
<a href="#l2.137"></a><span id="l2.137" class="difflineplus">+- Generate and install the pkg-config file with cmake</span>
<a href="#l2.138"></a><span id="l2.138" class="difflineplus">+- Build both a static and a shared version of zlib with cmake</span>
<a href="#l2.139"></a><span id="l2.139" class="difflineplus">+- Include version symbols for cmake builds</span>
<a href="#l2.140"></a><span id="l2.140" class="difflineplus">+- If using cmake with MSVC, add the source directory to the includes</span>
<a href="#l2.141"></a><span id="l2.141" class="difflineplus">+- Remove unneeded EXTRA_CFLAGS from win32/Makefile.gcc [Truta]</span>
<a href="#l2.142"></a><span id="l2.142" class="difflineplus">+- Move obsolete emx makefile to old [Truta]</span>
<a href="#l2.143"></a><span id="l2.143" class="difflineplus">+- Allow the use of -Wundef when compiling or using zlib</span>
<a href="#l2.144"></a><span id="l2.144" class="difflineplus">+- Avoid the use of the -u option with mktemp</span>
<a href="#l2.145"></a><span id="l2.145" class="difflineplus">+- Improve inflate() documentation on the use of Z_FINISH</span>
<a href="#l2.146"></a><span id="l2.146" class="difflineplus">+- Recognize clang as gcc</span>
<a href="#l2.147"></a><span id="l2.147" class="difflineplus">+- Add gzopen_w() in Windows for wide character path names</span>
<a href="#l2.148"></a><span id="l2.148" class="difflineplus">+- Rename zconf.h in CMakeLists.txt to move it out of the way</span>
<a href="#l2.149"></a><span id="l2.149" class="difflineplus">+- Add source directory in CMakeLists.txt for building examples</span>
<a href="#l2.150"></a><span id="l2.150" class="difflineplus">+- Look in build directory for zlib.pc in CMakeLists.txt</span>
<a href="#l2.151"></a><span id="l2.151" class="difflineplus">+- Remove gzflags from zlibvc.def in vc9 and vc10</span>
<a href="#l2.152"></a><span id="l2.152" class="difflineplus">+- Fix contrib/minizip compilation in the MinGW environment</span>
<a href="#l2.153"></a><span id="l2.153" class="difflineplus">+- Update ./configure for Solaris, support --64 [Mooney]</span>
<a href="#l2.154"></a><span id="l2.154" class="difflineplus">+- Remove -R. from Solaris shared build (possible security issue)</span>
<a href="#l2.155"></a><span id="l2.155" class="difflineplus">+- Avoid race condition for parallel make (-j) running example</span>
<a href="#l2.156"></a><span id="l2.156" class="difflineplus">+- Fix type mismatch between get_crc_table() and crc_table</span>
<a href="#l2.157"></a><span id="l2.157" class="difflineplus">+- Fix parsing of version with &quot;-&quot; in CMakeLists.txt [Snider, Ziegler]</span>
<a href="#l2.158"></a><span id="l2.158" class="difflineplus">+- Fix the path to zlib.map in CMakeLists.txt</span>
<a href="#l2.159"></a><span id="l2.159" class="difflineplus">+- Force the native libtool in Mac OS X to avoid GNU libtool [Beebe]</span>
<a href="#l2.160"></a><span id="l2.160" class="difflineplus">+- Add instructions to win32/Makefile.gcc for shared install [Torri]</span>
<a href="#l2.161"></a><span id="l2.161" class="difflineplus">+</span>
<a href="#l2.162"></a><span id="l2.162" class="difflineplus">+Changes in 1.2.6.1 (12 Feb 2012)</span>
<a href="#l2.163"></a><span id="l2.163" class="difflineplus">+- Avoid the use of the Objective-C reserved name &quot;id&quot;</span>
<a href="#l2.164"></a><span id="l2.164" class="difflineplus">+- Include io.h in gzguts.h for Microsoft compilers</span>
<a href="#l2.165"></a><span id="l2.165" class="difflineplus">+- Fix problem with ./configure --prefix and gzgetc macro</span>
<a href="#l2.166"></a><span id="l2.166" class="difflineplus">+- Include gz_header definition when compiling zlib solo</span>
<a href="#l2.167"></a><span id="l2.167" class="difflineplus">+- Put gzflags() functionality back in zutil.c</span>
<a href="#l2.168"></a><span id="l2.168" class="difflineplus">+- Avoid library header include in crc32.c for Z_SOLO</span>
<a href="#l2.169"></a><span id="l2.169" class="difflineplus">+- Use name in GCC_CLASSIC as C compiler for coverage testing, if set</span>
<a href="#l2.170"></a><span id="l2.170" class="difflineplus">+- Minor cleanup in contrib/minizip/zip.c [Vollant]</span>
<a href="#l2.171"></a><span id="l2.171" class="difflineplus">+- Update make_vms.com [Zinser]</span>
<a href="#l2.172"></a><span id="l2.172" class="difflineplus">+- Remove unnecessary gzgetc_ function</span>
<a href="#l2.173"></a><span id="l2.173" class="difflineplus">+- Use optimized byte swap operations for Microsoft and GNU [Snyder]</span>
<a href="#l2.174"></a><span id="l2.174" class="difflineplus">+- Fix minor typo in zlib.h comments [Rzesniowiecki]</span>
<a href="#l2.175"></a><span id="l2.175" class="difflineplus">+</span>
<a href="#l2.176"></a><span id="l2.176" class="difflineplus">+Changes in 1.2.6 (29 Jan 2012)</span>
<a href="#l2.177"></a><span id="l2.177" class="difflineplus">+- Update the Pascal interface in contrib/pascal</span>
<a href="#l2.178"></a><span id="l2.178" class="difflineplus">+- Fix function numbers for gzgetc_ in zlibvc.def files</span>
<a href="#l2.179"></a><span id="l2.179" class="difflineplus">+- Fix configure.ac for contrib/minizip [Schiffer]</span>
<a href="#l2.180"></a><span id="l2.180" class="difflineplus">+- Fix large-entry detection in minizip on 64-bit systems [Schiffer]</span>
<a href="#l2.181"></a><span id="l2.181" class="difflineplus">+- Have ./configure use the compiler return code for error indication</span>
<a href="#l2.182"></a><span id="l2.182" class="difflineplus">+- Fix CMakeLists.txt for cross compilation [McClure]</span>
<a href="#l2.183"></a><span id="l2.183" class="difflineplus">+- Fix contrib/minizip/zip.c for 64-bit architectures [Dalsnes]</span>
<a href="#l2.184"></a><span id="l2.184" class="difflineplus">+- Fix compilation of contrib/minizip on FreeBSD [Marquez]</span>
<a href="#l2.185"></a><span id="l2.185" class="difflineplus">+- Correct suggested usages in win32/Makefile.msc [Shachar, Horvath]</span>
<a href="#l2.186"></a><span id="l2.186" class="difflineplus">+- Include io.h for Turbo C / Borland C on all platforms [Truta]</span>
<a href="#l2.187"></a><span id="l2.187" class="difflineplus">+- Make version explicit in contrib/minizip/configure.ac [Bosmans]</span>
<a href="#l2.188"></a><span id="l2.188" class="difflineplus">+- Avoid warning for no encryption in contrib/minizip/zip.c [Vollant]</span>
<a href="#l2.189"></a><span id="l2.189" class="difflineplus">+- Minor cleanup up contrib/minizip/unzip.c [Vollant]</span>
<a href="#l2.190"></a><span id="l2.190" class="difflineplus">+- Fix bug when compiling minizip with C++ [Vollant]</span>
<a href="#l2.191"></a><span id="l2.191" class="difflineplus">+- Protect for long name and extra fields in contrib/minizip [Vollant]</span>
<a href="#l2.192"></a><span id="l2.192" class="difflineplus">+- Avoid some warnings in contrib/minizip [Vollant]</span>
<a href="#l2.193"></a><span id="l2.193" class="difflineplus">+- Add -I../.. -L../.. to CFLAGS for minizip and miniunzip</span>
<a href="#l2.194"></a><span id="l2.194" class="difflineplus">+- Add missing libs to minizip linker command</span>
<a href="#l2.195"></a><span id="l2.195" class="difflineplus">+- Add support for VPATH builds in contrib/minizip</span>
<a href="#l2.196"></a><span id="l2.196" class="difflineplus">+- Add an --enable-demos option to contrib/minizip/configure</span>
<a href="#l2.197"></a><span id="l2.197" class="difflineplus">+- Add the generation of configure.log by ./configure</span>
<a href="#l2.198"></a><span id="l2.198" class="difflineplus">+- Exit when required parameters not provided to win32/Makefile.gcc</span>
<a href="#l2.199"></a><span id="l2.199" class="difflineplus">+- Have gzputc return the character written instead of the argument</span>
<a href="#l2.200"></a><span id="l2.200" class="difflineplus">+- Use the -m option on ldconfig for BSD systems [Tobias]</span>
<a href="#l2.201"></a><span id="l2.201" class="difflineplus">+- Correct in zlib.map when deflateResetKeep was added</span>
<a href="#l2.202"></a><span id="l2.202" class="difflineplus">+</span>
<a href="#l2.203"></a><span id="l2.203" class="difflineplus">+Changes in 1.2.5.3 (15 Jan 2012)</span>
<a href="#l2.204"></a><span id="l2.204" class="difflineplus">+- Restore gzgetc function for binary compatibility</span>
<a href="#l2.205"></a><span id="l2.205" class="difflineplus">+- Do not use _lseeki64 under Borland C++ [Truta]</span>
<a href="#l2.206"></a><span id="l2.206" class="difflineplus">+- Update win32/Makefile.msc to build test/*.c [Truta]</span>
<a href="#l2.207"></a><span id="l2.207" class="difflineplus">+- Remove old/visualc6 given CMakefile and other alternatives</span>
<a href="#l2.208"></a><span id="l2.208" class="difflineplus">+- Update AS400 build files and documentation [Monnerat]</span>
<a href="#l2.209"></a><span id="l2.209" class="difflineplus">+- Update win32/Makefile.gcc to build test/*.c [Truta]</span>
<a href="#l2.210"></a><span id="l2.210" class="difflineplus">+- Permit stronger flushes after Z_BLOCK flushes</span>
<a href="#l2.211"></a><span id="l2.211" class="difflineplus">+- Avoid extraneous empty blocks when doing empty flushes</span>
<a href="#l2.212"></a><span id="l2.212" class="difflineplus">+- Permit Z_NULL arguments to deflatePending</span>
<a href="#l2.213"></a><span id="l2.213" class="difflineplus">+- Allow deflatePrime() to insert bits in the middle of a stream</span>
<a href="#l2.214"></a><span id="l2.214" class="difflineplus">+- Remove second empty static block for Z_PARTIAL_FLUSH</span>
<a href="#l2.215"></a><span id="l2.215" class="difflineplus">+- Write out all of the available bits when using Z_BLOCK</span>
<a href="#l2.216"></a><span id="l2.216" class="difflineplus">+- Insert the first two strings in the hash table after a flush</span>
<a href="#l2.217"></a><span id="l2.217" class="difflineplus">+</span>
<a href="#l2.218"></a><span id="l2.218" class="difflineplus">+Changes in 1.2.5.2 (17 Dec 2011)</span>
<a href="#l2.219"></a><span id="l2.219" class="difflineplus">+- fix ld error: unable to find version dependency 'ZLIB_1.2.5'</span>
<a href="#l2.220"></a><span id="l2.220" class="difflineplus">+- use relative symlinks for shared libs</span>
<a href="#l2.221"></a><span id="l2.221" class="difflineplus">+- Avoid searching past window for Z_RLE strategy</span>
<a href="#l2.222"></a><span id="l2.222" class="difflineplus">+- Assure that high-water mark initialization is always applied in deflate</span>
<a href="#l2.223"></a><span id="l2.223" class="difflineplus">+- Add assertions to fill_window() in deflate.c to match comments</span>
<a href="#l2.224"></a><span id="l2.224" class="difflineplus">+- Update python link in README</span>
<a href="#l2.225"></a><span id="l2.225" class="difflineplus">+- Correct spelling error in gzread.c</span>
<a href="#l2.226"></a><span id="l2.226" class="difflineplus">+- Fix bug in gzgets() for a concatenated empty gzip stream</span>
<a href="#l2.227"></a><span id="l2.227" class="difflineplus">+- Correct error in comment for gz_make()</span>
<a href="#l2.228"></a><span id="l2.228" class="difflineplus">+- Change gzread() and related to ignore junk after gzip streams</span>
<a href="#l2.229"></a><span id="l2.229" class="difflineplus">+- Allow gzread() and related to continue after gzclearerr()</span>
<a href="#l2.230"></a><span id="l2.230" class="difflineplus">+- Allow gzrewind() and gzseek() after a premature end-of-file</span>
<a href="#l2.231"></a><span id="l2.231" class="difflineplus">+- Simplify gzseek() now that raw after gzip is ignored</span>
<a href="#l2.232"></a><span id="l2.232" class="difflineplus">+- Change gzgetc() to a macro for speed (~40% speedup in testing)</span>
<a href="#l2.233"></a><span id="l2.233" class="difflineplus">+- Fix gzclose() to return the actual error last encountered</span>
<a href="#l2.234"></a><span id="l2.234" class="difflineplus">+- Always add large file support for windows</span>
<a href="#l2.235"></a><span id="l2.235" class="difflineplus">+- Include zconf.h for windows large file support</span>
<a href="#l2.236"></a><span id="l2.236" class="difflineplus">+- Include zconf.h.cmakein for windows large file support</span>
<a href="#l2.237"></a><span id="l2.237" class="difflineplus">+- Update zconf.h.cmakein on make distclean</span>
<a href="#l2.238"></a><span id="l2.238" class="difflineplus">+- Merge vestigial vsnprintf determination from zutil.h to gzguts.h</span>
<a href="#l2.239"></a><span id="l2.239" class="difflineplus">+- Clarify how gzopen() appends in zlib.h comments</span>
<a href="#l2.240"></a><span id="l2.240" class="difflineplus">+- Correct documentation of gzdirect() since junk at end now ignored</span>
<a href="#l2.241"></a><span id="l2.241" class="difflineplus">+- Add a transparent write mode to gzopen() when 'T' is in the mode</span>
<a href="#l2.242"></a><span id="l2.242" class="difflineplus">+- Update python link in zlib man page</span>
<a href="#l2.243"></a><span id="l2.243" class="difflineplus">+- Get inffixed.h and MAKEFIXED result to match</span>
<a href="#l2.244"></a><span id="l2.244" class="difflineplus">+- Add a ./config --solo option to make zlib subset with no library use</span>
<a href="#l2.245"></a><span id="l2.245" class="difflineplus">+- Add undocumented inflateResetKeep() function for CAB file decoding</span>
<a href="#l2.246"></a><span id="l2.246" class="difflineplus">+- Add --cover option to ./configure for gcc coverage testing</span>
<a href="#l2.247"></a><span id="l2.247" class="difflineplus">+- Add #define ZLIB_CONST option to use const in the z_stream interface</span>
<a href="#l2.248"></a><span id="l2.248" class="difflineplus">+- Add comment to gzdopen() in zlib.h to use dup() when using fileno()</span>
<a href="#l2.249"></a><span id="l2.249" class="difflineplus">+- Note behavior of uncompress() to provide as much data as it can</span>
<a href="#l2.250"></a><span id="l2.250" class="difflineplus">+- Add files in contrib/minizip to aid in building libminizip</span>
<a href="#l2.251"></a><span id="l2.251" class="difflineplus">+- Split off AR options in Makefile.in and configure</span>
<a href="#l2.252"></a><span id="l2.252" class="difflineplus">+- Change ON macro to Z_ARG to avoid application conflicts</span>
<a href="#l2.253"></a><span id="l2.253" class="difflineplus">+- Facilitate compilation with Borland C++ for pragmas and vsnprintf</span>
<a href="#l2.254"></a><span id="l2.254" class="difflineplus">+- Include io.h for Turbo C / Borland C++</span>
<a href="#l2.255"></a><span id="l2.255" class="difflineplus">+- Move example.c and minigzip.c to test/</span>
<a href="#l2.256"></a><span id="l2.256" class="difflineplus">+- Simplify incomplete code table filling in inflate_table()</span>
<a href="#l2.257"></a><span id="l2.257" class="difflineplus">+- Remove code from inflate.c and infback.c that is impossible to execute</span>
<a href="#l2.258"></a><span id="l2.258" class="difflineplus">+- Test the inflate code with full coverage</span>
<a href="#l2.259"></a><span id="l2.259" class="difflineplus">+- Allow deflateSetDictionary, inflateSetDictionary at any time (in raw)</span>
<a href="#l2.260"></a><span id="l2.260" class="difflineplus">+- Add deflateResetKeep and fix inflateResetKeep to retain dictionary</span>
<a href="#l2.261"></a><span id="l2.261" class="difflineplus">+- Fix gzwrite.c to accommodate reduced memory zlib compilation</span>
<a href="#l2.262"></a><span id="l2.262" class="difflineplus">+- Have inflate() with Z_FINISH avoid the allocation of a window</span>
<a href="#l2.263"></a><span id="l2.263" class="difflineplus">+- Do not set strm-&gt;adler when doing raw inflate</span>
<a href="#l2.264"></a><span id="l2.264" class="difflineplus">+- Fix gzeof() to behave just like feof() when read is not past end of file</span>
<a href="#l2.265"></a><span id="l2.265" class="difflineplus">+- Fix bug in gzread.c when end-of-file is reached</span>
<a href="#l2.266"></a><span id="l2.266" class="difflineplus">+- Avoid use of Z_BUF_ERROR in gz* functions except for premature EOF</span>
<a href="#l2.267"></a><span id="l2.267" class="difflineplus">+- Document gzread() capability to read concurrently written files</span>
<a href="#l2.268"></a><span id="l2.268" class="difflineplus">+- Remove hard-coding of resource compiler in CMakeLists.txt [Blammo]</span>
<a href="#l2.269"></a><span id="l2.269" class="difflineplus">+</span>
<a href="#l2.270"></a><span id="l2.270" class="difflineplus">+Changes in 1.2.5.1 (10 Sep 2011)</span>
<a href="#l2.271"></a><span id="l2.271" class="difflineplus">+- Update FAQ entry on shared builds (#13)</span>
<a href="#l2.272"></a><span id="l2.272" class="difflineplus">+- Avoid symbolic argument to chmod in Makefile.in</span>
<a href="#l2.273"></a><span id="l2.273" class="difflineplus">+- Fix bug and add consts in contrib/puff [Oberhumer]</span>
<a href="#l2.274"></a><span id="l2.274" class="difflineplus">+- Update contrib/puff/zeros.raw test file to have all block types</span>
<a href="#l2.275"></a><span id="l2.275" class="difflineplus">+- Add full coverage test for puff in contrib/puff/Makefile</span>
<a href="#l2.276"></a><span id="l2.276" class="difflineplus">+- Fix static-only-build install in Makefile.in</span>
<a href="#l2.277"></a><span id="l2.277" class="difflineplus">+- Fix bug in unzGetCurrentFileInfo() in contrib/minizip [Kuno]</span>
<a href="#l2.278"></a><span id="l2.278" class="difflineplus">+- Add libz.a dependency to shared in Makefile.in for parallel builds</span>
<a href="#l2.279"></a><span id="l2.279" class="difflineplus">+- Spell out &quot;number&quot; (instead of &quot;nb&quot;) in zlib.h for total_in, total_out</span>
<a href="#l2.280"></a><span id="l2.280" class="difflineplus">+- Replace $(...) with `...` in configure for non-bash sh [Bowler]</span>
<a href="#l2.281"></a><span id="l2.281" class="difflineplus">+- Add darwin* to Darwin* and solaris* to SunOS\ 5* in configure [Groffen]</span>
<a href="#l2.282"></a><span id="l2.282" class="difflineplus">+- Add solaris* to Linux* in configure to allow gcc use [Groffen]</span>
<a href="#l2.283"></a><span id="l2.283" class="difflineplus">+- Add *bsd* to Linux* case in configure [Bar-Lev]</span>
<a href="#l2.284"></a><span id="l2.284" class="difflineplus">+- Add inffast.obj to dependencies in win32/Makefile.msc</span>
<a href="#l2.285"></a><span id="l2.285" class="difflineplus">+- Correct spelling error in deflate.h [Kohler]</span>
<a href="#l2.286"></a><span id="l2.286" class="difflineplus">+- Change libzdll.a again to libz.dll.a (!) in win32/Makefile.gcc</span>
<a href="#l2.287"></a><span id="l2.287" class="difflineplus">+- Add test to configure for GNU C looking for gcc in output of $cc -v</span>
<a href="#l2.288"></a><span id="l2.288" class="difflineplus">+- Add zlib.pc generation to win32/Makefile.gcc [Weigelt]</span>
<a href="#l2.289"></a><span id="l2.289" class="difflineplus">+- Fix bug in zlib.h for _FILE_OFFSET_BITS set and _LARGEFILE64_SOURCE not</span>
<a href="#l2.290"></a><span id="l2.290" class="difflineplus">+- Add comment in zlib.h that adler32_combine with len2 &lt; 0 makes no sense</span>
<a href="#l2.291"></a><span id="l2.291" class="difflineplus">+- Make NO_DIVIDE option in adler32.c much faster (thanks to John Reiser)</span>
<a href="#l2.292"></a><span id="l2.292" class="difflineplus">+- Make stronger test in zconf.h to include unistd.h for LFS</span>
<a href="#l2.293"></a><span id="l2.293" class="difflineplus">+- Apply Darwin patches for 64-bit file offsets to contrib/minizip [Slack]</span>
<a href="#l2.294"></a><span id="l2.294" class="difflineplus">+- Fix zlib.h LFS support when Z_PREFIX used</span>
<a href="#l2.295"></a><span id="l2.295" class="difflineplus">+- Add updated as400 support (removed from old) [Monnerat]</span>
<a href="#l2.296"></a><span id="l2.296" class="difflineplus">+- Avoid deflate sensitivity to volatile input data</span>
<a href="#l2.297"></a><span id="l2.297" class="difflineplus">+- Avoid division in adler32_combine for NO_DIVIDE</span>
<a href="#l2.298"></a><span id="l2.298" class="difflineplus">+- Clarify the use of Z_FINISH with deflateBound() amount of space</span>
<a href="#l2.299"></a><span id="l2.299" class="difflineplus">+- Set binary for output file in puff.c</span>
<a href="#l2.300"></a><span id="l2.300" class="difflineplus">+- Use u4 type for crc_table to avoid conversion warnings</span>
<a href="#l2.301"></a><span id="l2.301" class="difflineplus">+- Apply casts in zlib.h to avoid conversion warnings</span>
<a href="#l2.302"></a><span id="l2.302" class="difflineplus">+- Add OF to prototypes for adler32_combine_ and crc32_combine_ [Miller]</span>
<a href="#l2.303"></a><span id="l2.303" class="difflineplus">+- Improve inflateSync() documentation to note indeterminancy</span>
<a href="#l2.304"></a><span id="l2.304" class="difflineplus">+- Add deflatePending() function to return the amount of pending output</span>
<a href="#l2.305"></a><span id="l2.305" class="difflineplus">+- Correct the spelling of &quot;specification&quot; in FAQ [Randers-Pehrson]</span>
<a href="#l2.306"></a><span id="l2.306" class="difflineplus">+- Add a check in configure for stdarg.h, use for gzprintf()</span>
<a href="#l2.307"></a><span id="l2.307" class="difflineplus">+- Check that pointers fit in ints when gzprint() compiled old style</span>
<a href="#l2.308"></a><span id="l2.308" class="difflineplus">+- Add dummy name before $(SHAREDLIBV) in Makefile [Bar-Lev, Bowler]</span>
<a href="#l2.309"></a><span id="l2.309" class="difflineplus">+- Delete line in configure that adds -L. libz.a to LDFLAGS [Weigelt]</span>
<a href="#l2.310"></a><span id="l2.310" class="difflineplus">+- Add debug records in assmebler code [Londer]</span>
<a href="#l2.311"></a><span id="l2.311" class="difflineplus">+- Update RFC references to use http://tools.ietf.org/html/... [Li]</span>
<a href="#l2.312"></a><span id="l2.312" class="difflineplus">+- Add --archs option, use of libtool to configure for Mac OS X [Borstel]</span>
<a href="#l2.313"></a><span id="l2.313" class="difflineplus">+</span>
<a href="#l2.314"></a><span id="l2.314" class="difflineplus">+Changes in 1.2.5 (19 Apr 2010)</span>
<a href="#l2.315"></a><span id="l2.315" class="difflineplus">+- Disable visibility attribute in win32/Makefile.gcc [Bar-Lev]</span>
<a href="#l2.316"></a><span id="l2.316" class="difflineplus">+- Default to libdir as sharedlibdir in configure [Nieder]</span>
<a href="#l2.317"></a><span id="l2.317" class="difflineplus">+- Update copyright dates on modified source files</span>
<a href="#l2.318"></a><span id="l2.318" class="difflineplus">+- Update trees.c to be able to generate modified trees.h</span>
<a href="#l2.319"></a><span id="l2.319" class="difflineplus">+- Exit configure for MinGW, suggesting win32/Makefile.gcc</span>
<a href="#l2.320"></a><span id="l2.320" class="difflineplus">+- Check for NULL path in gz_open [Homurlu]</span>
<a href="#l2.321"></a><span id="l2.321" class="difflineplus">+</span>
<a href="#l2.322"></a><span id="l2.322" class="difflineplus">+Changes in 1.2.4.5 (18 Apr 2010)</span>
<a href="#l2.323"></a><span id="l2.323" class="difflineplus">+- Set sharedlibdir in configure [Torok]</span>
<a href="#l2.324"></a><span id="l2.324" class="difflineplus">+- Set LDFLAGS in Makefile.in [Bar-Lev]</span>
<a href="#l2.325"></a><span id="l2.325" class="difflineplus">+- Avoid mkdir objs race condition in Makefile.in [Bowler]</span>
<a href="#l2.326"></a><span id="l2.326" class="difflineplus">+- Add ZLIB_INTERNAL in front of internal inter-module functions and arrays</span>
<a href="#l2.327"></a><span id="l2.327" class="difflineplus">+- Define ZLIB_INTERNAL to hide internal functions and arrays for GNU C</span>
<a href="#l2.328"></a><span id="l2.328" class="difflineplus">+- Don't use hidden attribute when it is a warning generator (e.g. Solaris)</span>
<a href="#l2.329"></a><span id="l2.329" class="difflineplus">+</span>
<a href="#l2.330"></a><span id="l2.330" class="difflineplus">+Changes in 1.2.4.4 (18 Apr 2010)</span>
<a href="#l2.331"></a><span id="l2.331" class="difflineplus">+- Fix CROSS_PREFIX executable testing, CHOST extract, mingw* [Torok]</span>
<a href="#l2.332"></a><span id="l2.332" class="difflineplus">+- Undefine _LARGEFILE64_SOURCE in zconf.h if it is zero, but not if empty</span>
<a href="#l2.333"></a><span id="l2.333" class="difflineplus">+- Try to use bash or ksh regardless of functionality of /bin/sh</span>
<a href="#l2.334"></a><span id="l2.334" class="difflineplus">+- Fix configure incompatibility with NetBSD sh</span>
<a href="#l2.335"></a><span id="l2.335" class="difflineplus">+- Remove attempt to run under bash or ksh since have better NetBSD fix</span>
<a href="#l2.336"></a><span id="l2.336" class="difflineplus">+- Fix win32/Makefile.gcc for MinGW [Bar-Lev]</span>
<a href="#l2.337"></a><span id="l2.337" class="difflineplus">+- Add diagnostic messages when using CROSS_PREFIX in configure</span>
<a href="#l2.338"></a><span id="l2.338" class="difflineplus">+- Added --sharedlibdir option to configure [Weigelt]</span>
<a href="#l2.339"></a><span id="l2.339" class="difflineplus">+- Use hidden visibility attribute when available [Frysinger]</span>
<a href="#l2.340"></a><span id="l2.340" class="difflineplus">+</span>
<a href="#l2.341"></a><span id="l2.341" class="difflineplus">+Changes in 1.2.4.3 (10 Apr 2010)</span>
<a href="#l2.342"></a><span id="l2.342" class="difflineplus">+- Only use CROSS_PREFIX in configure for ar and ranlib if they exist</span>
<a href="#l2.343"></a><span id="l2.343" class="difflineplus">+- Use CROSS_PREFIX for nm [Bar-Lev]</span>
<a href="#l2.344"></a><span id="l2.344" class="difflineplus">+- Assume _LARGEFILE64_SOURCE defined is equivalent to true</span>
<a href="#l2.345"></a><span id="l2.345" class="difflineplus">+- Avoid use of undefined symbols in #if with &amp;&amp; and ||</span>
<a href="#l2.346"></a><span id="l2.346" class="difflineplus">+- Make *64 prototypes in gzguts.h consistent with functions</span>
<a href="#l2.347"></a><span id="l2.347" class="difflineplus">+- Add -shared load option for MinGW in configure [Bowler]</span>
<a href="#l2.348"></a><span id="l2.348" class="difflineplus">+- Move z_off64_t to public interface, use instead of off64_t</span>
<a href="#l2.349"></a><span id="l2.349" class="difflineplus">+- Remove ! from shell test in configure (not portable to Solaris)</span>
<a href="#l2.350"></a><span id="l2.350" class="difflineplus">+- Change +0 macro tests to -0 for possibly increased portability</span>
<a href="#l2.351"></a><span id="l2.351" class="difflineplus">+</span>
<a href="#l2.352"></a><span id="l2.352" class="difflineplus">+Changes in 1.2.4.2 (9 Apr 2010)</span>
<a href="#l2.353"></a><span id="l2.353" class="difflineplus">+- Add consistent carriage returns to readme.txt's in masmx86 and masmx64</span>
<a href="#l2.354"></a><span id="l2.354" class="difflineplus">+- Really provide prototypes for *64 functions when building without LFS</span>
<a href="#l2.355"></a><span id="l2.355" class="difflineplus">+- Only define unlink() in minigzip.c if unistd.h not included</span>
<a href="#l2.356"></a><span id="l2.356" class="difflineplus">+- Update README to point to contrib/vstudio project files</span>
<a href="#l2.357"></a><span id="l2.357" class="difflineplus">+- Move projects/vc6 to old/ and remove projects/</span>
<a href="#l2.358"></a><span id="l2.358" class="difflineplus">+- Include stdlib.h in minigzip.c for setmode() definition under WinCE</span>
<a href="#l2.359"></a><span id="l2.359" class="difflineplus">+- Clean up assembler builds in win32/Makefile.msc [Rowe]</span>
<a href="#l2.360"></a><span id="l2.360" class="difflineplus">+- Include sys/types.h for Microsoft for off_t definition</span>
<a href="#l2.361"></a><span id="l2.361" class="difflineplus">+- Fix memory leak on error in gz_open()</span>
<a href="#l2.362"></a><span id="l2.362" class="difflineplus">+- Symbolize nm as $NM in configure [Weigelt]</span>
<a href="#l2.363"></a><span id="l2.363" class="difflineplus">+- Use TEST_LDSHARED instead of LDSHARED to link test programs [Weigelt]</span>
<a href="#l2.364"></a><span id="l2.364" class="difflineplus">+- Add +0 to _FILE_OFFSET_BITS and _LFS64_LARGEFILE in case not defined</span>
<a href="#l2.365"></a><span id="l2.365" class="difflineplus">+- Fix bug in gzeof() to take into account unused input data</span>
<a href="#l2.366"></a><span id="l2.366" class="difflineplus">+- Avoid initialization of structures with variables in puff.c</span>
<a href="#l2.367"></a><span id="l2.367" class="difflineplus">+- Updated win32/README-WIN32.txt [Rowe]</span>
<a href="#l2.368"></a><span id="l2.368" class="difflineplus">+</span>
<a href="#l2.369"></a><span id="l2.369" class="difflineplus">+Changes in 1.2.4.1 (28 Mar 2010)</span>
<a href="#l2.370"></a><span id="l2.370" class="difflineplus">+- Remove the use of [a-z] constructs for sed in configure [gentoo 310225]</span>
<a href="#l2.371"></a><span id="l2.371" class="difflineplus">+- Remove $(SHAREDLIB) from LIBS in Makefile.in [Creech]</span>
<a href="#l2.372"></a><span id="l2.372" class="difflineplus">+- Restore &quot;for debugging&quot; comment on sprintf() in gzlib.c</span>
<a href="#l2.373"></a><span id="l2.373" class="difflineplus">+- Remove fdopen for MVS from gzguts.h</span>
<a href="#l2.374"></a><span id="l2.374" class="difflineplus">+- Put new README-WIN32.txt in win32 [Rowe]</span>
<a href="#l2.375"></a><span id="l2.375" class="difflineplus">+- Add check for shell to configure and invoke another shell if needed</span>
<a href="#l2.376"></a><span id="l2.376" class="difflineplus">+- Fix big fat stinking bug in gzseek() on uncompressed files</span>
<a href="#l2.377"></a><span id="l2.377" class="difflineplus">+- Remove vestigial F_OPEN64 define in zutil.h</span>
<a href="#l2.378"></a><span id="l2.378" class="difflineplus">+- Set and check the value of _LARGEFILE_SOURCE and _LARGEFILE64_SOURCE</span>
<a href="#l2.379"></a><span id="l2.379" class="difflineplus">+- Avoid errors on non-LFS systems when applications define LFS macros</span>
<a href="#l2.380"></a><span id="l2.380" class="difflineplus">+- Set EXE to &quot;.exe&quot; in configure for MINGW [Kahle]</span>
<a href="#l2.381"></a><span id="l2.381" class="difflineplus">+- Match crc32() in crc32.c exactly to the prototype in zlib.h [Sherrill]</span>
<a href="#l2.382"></a><span id="l2.382" class="difflineplus">+- Add prefix for cross-compilation in win32/makefile.gcc [Bar-Lev]</span>
<a href="#l2.383"></a><span id="l2.383" class="difflineplus">+- Add DLL install in win32/makefile.gcc [Bar-Lev]</span>
<a href="#l2.384"></a><span id="l2.384" class="difflineplus">+- Allow Linux* or linux* from uname in configure [Bar-Lev]</span>
<a href="#l2.385"></a><span id="l2.385" class="difflineplus">+- Allow ldconfig to be redefined in configure and Makefile.in [Bar-Lev]</span>
<a href="#l2.386"></a><span id="l2.386" class="difflineplus">+- Add cross-compilation prefixes to configure [Bar-Lev]</span>
<a href="#l2.387"></a><span id="l2.387" class="difflineplus">+- Match type exactly in gz_load() invocation in gzread.c</span>
<a href="#l2.388"></a><span id="l2.388" class="difflineplus">+- Match type exactly of zcalloc() in zutil.c to zlib.h alloc_func</span>
<a href="#l2.389"></a><span id="l2.389" class="difflineplus">+- Provide prototypes for *64 functions when building zlib without LFS</span>
<a href="#l2.390"></a><span id="l2.390" class="difflineplus">+- Don't use -lc when linking shared library on MinGW</span>
<a href="#l2.391"></a><span id="l2.391" class="difflineplus">+- Remove errno.h check in configure and vestigial errno code in zutil.h</span>
<a href="#l2.392"></a><span id="l2.392" class="difflineplus">+</span>
<a href="#l2.393"></a><span id="l2.393" class="difflineplus">+Changes in 1.2.4 (14 Mar 2010)</span>
<a href="#l2.394"></a><span id="l2.394" class="difflineplus">+- Fix VER3 extraction in configure for no fourth subversion</span>
<a href="#l2.395"></a><span id="l2.395" class="difflineplus">+- Update zlib.3, add docs to Makefile.in to make .pdf out of it</span>
<a href="#l2.396"></a><span id="l2.396" class="difflineplus">+- Add zlib.3.pdf to distribution</span>
<a href="#l2.397"></a><span id="l2.397" class="difflineplus">+- Don't set error code in gzerror() if passed pointer is NULL</span>
<a href="#l2.398"></a><span id="l2.398" class="difflineplus">+- Apply destination directory fixes to CMakeLists.txt [Lowman]</span>
<a href="#l2.399"></a><span id="l2.399" class="difflineplus">+- Move #cmakedefine's to a new zconf.in.cmakein</span>
<a href="#l2.400"></a><span id="l2.400" class="difflineplus">+- Restore zconf.h for builds that don't use configure or cmake</span>
<a href="#l2.401"></a><span id="l2.401" class="difflineplus">+- Add distclean to dummy Makefile for convenience</span>
<a href="#l2.402"></a><span id="l2.402" class="difflineplus">+- Update and improve INDEX, README, and FAQ</span>
<a href="#l2.403"></a><span id="l2.403" class="difflineplus">+- Update CMakeLists.txt for the return of zconf.h [Lowman]</span>
<a href="#l2.404"></a><span id="l2.404" class="difflineplus">+- Update contrib/vstudio/vc9 and vc10 [Vollant]</span>
<a href="#l2.405"></a><span id="l2.405" class="difflineplus">+- Change libz.dll.a back to libzdll.a in win32/Makefile.gcc</span>
<a href="#l2.406"></a><span id="l2.406" class="difflineplus">+- Apply license and readme changes to contrib/asm686 [Raiter]</span>
<a href="#l2.407"></a><span id="l2.407" class="difflineplus">+- Check file name lengths and add -c option in minigzip.c [Li]</span>
<a href="#l2.408"></a><span id="l2.408" class="difflineplus">+- Update contrib/amd64 and contrib/masmx86/ [Vollant]</span>
<a href="#l2.409"></a><span id="l2.409" class="difflineplus">+- Avoid use of &quot;eof&quot; parameter in trees.c to not shadow library variable</span>
<a href="#l2.410"></a><span id="l2.410" class="difflineplus">+- Update make_vms.com for removal of zlibdefs.h [Zinser]</span>
<a href="#l2.411"></a><span id="l2.411" class="difflineplus">+- Update assembler code and vstudio projects in contrib [Vollant]</span>
<a href="#l2.412"></a><span id="l2.412" class="difflineplus">+- Remove outdated assembler code contrib/masm686 and contrib/asm586</span>
<a href="#l2.413"></a><span id="l2.413" class="difflineplus">+- Remove old vc7 and vc8 from contrib/vstudio</span>
<a href="#l2.414"></a><span id="l2.414" class="difflineplus">+- Update win32/Makefile.msc, add ZLIB_VER_SUBREVISION [Rowe]</span>
<a href="#l2.415"></a><span id="l2.415" class="difflineplus">+- Fix memory leaks in gzclose_r() and gzclose_w(), file leak in gz_open()</span>
<a href="#l2.416"></a><span id="l2.416" class="difflineplus">+- Add contrib/gcc_gvmat64 for longest_match and inflate_fast [Vollant]</span>
<a href="#l2.417"></a><span id="l2.417" class="difflineplus">+- Remove *64 functions from win32/zlib.def (they're not 64-bit yet)</span>
<a href="#l2.418"></a><span id="l2.418" class="difflineplus">+- Fix bug in void-returning vsprintf() case in gzwrite.c</span>
<a href="#l2.419"></a><span id="l2.419" class="difflineplus">+- Fix name change from inflate.h in contrib/inflate86/inffas86.c</span>
<a href="#l2.420"></a><span id="l2.420" class="difflineplus">+- Check if temporary file exists before removing in make_vms.com [Zinser]</span>
<a href="#l2.421"></a><span id="l2.421" class="difflineplus">+- Fix make install and uninstall for --static option</span>
<a href="#l2.422"></a><span id="l2.422" class="difflineplus">+- Fix usage of _MSC_VER in gzguts.h and zutil.h [Truta]</span>
<a href="#l2.423"></a><span id="l2.423" class="difflineplus">+- Update readme.txt in contrib/masmx64 and masmx86 to assemble</span>
<a href="#l2.424"></a><span id="l2.424" class="difflineplus">+</span>
<a href="#l2.425"></a><span id="l2.425" class="difflineplus">+Changes in 1.2.3.9 (21 Feb 2010)</span>
<a href="#l2.426"></a><span id="l2.426" class="difflineplus">+- Expunge gzio.c</span>
<a href="#l2.427"></a><span id="l2.427" class="difflineplus">+- Move as400 build information to old</span>
<a href="#l2.428"></a><span id="l2.428" class="difflineplus">+- Fix updates in contrib/minizip and contrib/vstudio</span>
<a href="#l2.429"></a><span id="l2.429" class="difflineplus">+- Add const to vsnprintf test in configure to avoid warnings [Weigelt]</span>
<a href="#l2.430"></a><span id="l2.430" class="difflineplus">+- Delete zconf.h (made by configure) [Weigelt]</span>
<a href="#l2.431"></a><span id="l2.431" class="difflineplus">+- Change zconf.in.h to zconf.h.in per convention [Weigelt]</span>
<a href="#l2.432"></a><span id="l2.432" class="difflineplus">+- Check for NULL buf in gzgets()</span>
<a href="#l2.433"></a><span id="l2.433" class="difflineplus">+- Return empty string for gzgets() with len == 1 (like fgets())</span>
<a href="#l2.434"></a><span id="l2.434" class="difflineplus">+- Fix description of gzgets() in zlib.h for end-of-file, NULL return</span>
<a href="#l2.435"></a><span id="l2.435" class="difflineplus">+- Update minizip to 1.1 [Vollant]</span>
<a href="#l2.436"></a><span id="l2.436" class="difflineplus">+- Avoid MSVC loss of data warnings in gzread.c, gzwrite.c</span>
<a href="#l2.437"></a><span id="l2.437" class="difflineplus">+- Note in zlib.h that gzerror() should be used to distinguish from EOF</span>
<a href="#l2.438"></a><span id="l2.438" class="difflineplus">+- Remove use of snprintf() from gzlib.c</span>
<a href="#l2.439"></a><span id="l2.439" class="difflineplus">+- Fix bug in gzseek()</span>
<a href="#l2.440"></a><span id="l2.440" class="difflineplus">+- Update contrib/vstudio, adding vc9 and vc10 [Kuno, Vollant]</span>
<a href="#l2.441"></a><span id="l2.441" class="difflineplus">+- Fix zconf.h generation in CMakeLists.txt [Lowman]</span>
<a href="#l2.442"></a><span id="l2.442" class="difflineplus">+- Improve comments in zconf.h where modified by configure</span>
<a href="#l2.443"></a><span id="l2.443" class="difflineplus">+</span>
<a href="#l2.444"></a><span id="l2.444" class="difflineplus">+Changes in 1.2.3.8 (13 Feb 2010)</span>
<a href="#l2.445"></a><span id="l2.445" class="difflineplus">+- Clean up text files (tabs, trailing whitespace, etc.) [Oberhumer]</span>
<a href="#l2.446"></a><span id="l2.446" class="difflineplus">+- Use z_off64_t in gz_zero() and gz_skip() to match state-&gt;skip</span>
<a href="#l2.447"></a><span id="l2.447" class="difflineplus">+- Avoid comparison problem when sizeof(int) == sizeof(z_off64_t)</span>
<a href="#l2.448"></a><span id="l2.448" class="difflineplus">+- Revert to Makefile.in from 1.2.3.6 (live with the clutter)</span>
<a href="#l2.449"></a><span id="l2.449" class="difflineplus">+- Fix missing error return in gzflush(), add zlib.h note</span>
<a href="#l2.450"></a><span id="l2.450" class="difflineplus">+- Add *64 functions to zlib.map [Levin]</span>
<a href="#l2.451"></a><span id="l2.451" class="difflineplus">+- Fix signed/unsigned comparison in gz_comp()</span>
<a href="#l2.452"></a><span id="l2.452" class="difflineplus">+- Use SFLAGS when testing shared linking in configure</span>
<a href="#l2.453"></a><span id="l2.453" class="difflineplus">+- Add --64 option to ./configure to use -m64 with gcc</span>
<a href="#l2.454"></a><span id="l2.454" class="difflineplus">+- Fix ./configure --help to correctly name options</span>
<a href="#l2.455"></a><span id="l2.455" class="difflineplus">+- Have make fail if a test fails [Levin]</span>
<a href="#l2.456"></a><span id="l2.456" class="difflineplus">+- Avoid buffer overrun in contrib/masmx64/gvmat64.asm [Simpson]</span>
<a href="#l2.457"></a><span id="l2.457" class="difflineplus">+- Remove assembler object files from contrib</span>
<a href="#l2.458"></a><span id="l2.458" class="difflineplus">+</span>
<a href="#l2.459"></a><span id="l2.459" class="difflineplus">+Changes in 1.2.3.7 (24 Jan 2010)</span>
<a href="#l2.460"></a><span id="l2.460" class="difflineplus">+- Always gzopen() with O_LARGEFILE if available</span>
<a href="#l2.461"></a><span id="l2.461" class="difflineplus">+- Fix gzdirect() to work immediately after gzopen() or gzdopen()</span>
<a href="#l2.462"></a><span id="l2.462" class="difflineplus">+- Make gzdirect() more precise when the state changes while reading</span>
<a href="#l2.463"></a><span id="l2.463" class="difflineplus">+- Improve zlib.h documentation in many places</span>
<a href="#l2.464"></a><span id="l2.464" class="difflineplus">+- Catch memory allocation failure in gz_open()</span>
<a href="#l2.465"></a><span id="l2.465" class="difflineplus">+- Complete close operation if seek forward in gzclose_w() fails</span>
<a href="#l2.466"></a><span id="l2.466" class="difflineplus">+- Return Z_ERRNO from gzclose_r() if close() fails</span>
<a href="#l2.467"></a><span id="l2.467" class="difflineplus">+- Return Z_STREAM_ERROR instead of EOF for gzclose() being passed NULL</span>
<a href="#l2.468"></a><span id="l2.468" class="difflineplus">+- Return zero for gzwrite() errors to match zlib.h description</span>
<a href="#l2.469"></a><span id="l2.469" class="difflineplus">+- Return -1 on gzputs() error to match zlib.h description</span>
<a href="#l2.470"></a><span id="l2.470" class="difflineplus">+- Add zconf.in.h to allow recovery from configure modification [Weigelt]</span>
<a href="#l2.471"></a><span id="l2.471" class="difflineplus">+- Fix static library permissions in Makefile.in [Weigelt]</span>
<a href="#l2.472"></a><span id="l2.472" class="difflineplus">+- Avoid warnings in configure tests that hide functionality [Weigelt]</span>
<a href="#l2.473"></a><span id="l2.473" class="difflineplus">+- Add *BSD and DragonFly to Linux case in configure [gentoo 123571]</span>
<a href="#l2.474"></a><span id="l2.474" class="difflineplus">+- Change libzdll.a to libz.dll.a in win32/Makefile.gcc [gentoo 288212]</span>
<a href="#l2.475"></a><span id="l2.475" class="difflineplus">+- Avoid access of uninitialized data for first inflateReset2 call [Gomes]</span>
<a href="#l2.476"></a><span id="l2.476" class="difflineplus">+- Keep object files in subdirectories to reduce the clutter somewhat</span>
<a href="#l2.477"></a><span id="l2.477" class="difflineplus">+- Remove default Makefile and zlibdefs.h, add dummy Makefile</span>
<a href="#l2.478"></a><span id="l2.478" class="difflineplus">+- Add new external functions to Z_PREFIX, remove duplicates, z_z_ -&gt; z_</span>
<a href="#l2.479"></a><span id="l2.479" class="difflineplus">+- Remove zlibdefs.h completely -- modify zconf.h instead</span>
<a href="#l2.480"></a><span id="l2.480" class="difflineplus">+</span>
<a href="#l2.481"></a><span id="l2.481" class="difflineplus">+Changes in 1.2.3.6 (17 Jan 2010)</span>
<a href="#l2.482"></a><span id="l2.482" class="difflineplus">+- Avoid void * arithmetic in gzread.c and gzwrite.c</span>
<a href="#l2.483"></a><span id="l2.483" class="difflineplus">+- Make compilers happier with const char * for gz_error message</span>
<a href="#l2.484"></a><span id="l2.484" class="difflineplus">+- Avoid unused parameter warning in inflate.c</span>
<a href="#l2.485"></a><span id="l2.485" class="difflineplus">+- Avoid signed-unsigned comparison warning in inflate.c</span>
<a href="#l2.486"></a><span id="l2.486" class="difflineplus">+- Indent #pragma's for traditional C</span>
<a href="#l2.487"></a><span id="l2.487" class="difflineplus">+- Fix usage of strwinerror() in glib.c, change to gz_strwinerror()</span>
<a href="#l2.488"></a><span id="l2.488" class="difflineplus">+- Correct email address in configure for system options</span>
<a href="#l2.489"></a><span id="l2.489" class="difflineplus">+- Update make_vms.com and add make_vms.com to contrib/minizip [Zinser]</span>
<a href="#l2.490"></a><span id="l2.490" class="difflineplus">+- Update zlib.map [Brown]</span>
<a href="#l2.491"></a><span id="l2.491" class="difflineplus">+- Fix Makefile.in for Solaris 10 make of example64 and minizip64 [Torok]</span>
<a href="#l2.492"></a><span id="l2.492" class="difflineplus">+- Apply various fixes to CMakeLists.txt [Lowman]</span>
<a href="#l2.493"></a><span id="l2.493" class="difflineplus">+- Add checks on len in gzread() and gzwrite()</span>
<a href="#l2.494"></a><span id="l2.494" class="difflineplus">+- Add error message for no more room for gzungetc()</span>
<a href="#l2.495"></a><span id="l2.495" class="difflineplus">+- Remove zlib version check in gzwrite()</span>
<a href="#l2.496"></a><span id="l2.496" class="difflineplus">+- Defer compression of gzprintf() result until need to</span>
<a href="#l2.497"></a><span id="l2.497" class="difflineplus">+- Use snprintf() in gzdopen() if available</span>
<a href="#l2.498"></a><span id="l2.498" class="difflineplus">+- Remove USE_MMAP configuration determination (only used by minigzip)</span>
<a href="#l2.499"></a><span id="l2.499" class="difflineplus">+- Remove examples/pigz.c (available separately)</span>
<a href="#l2.500"></a><span id="l2.500" class="difflineplus">+- Update examples/gun.c to 1.6</span>
<a href="#l2.501"></a><span id="l2.501" class="difflineplus">+</span>
<a href="#l2.502"></a><span id="l2.502" class="difflineplus">+Changes in 1.2.3.5 (8 Jan 2010)</span>
<a href="#l2.503"></a><span id="l2.503" class="difflineplus">+- Add space after #if in zutil.h for some compilers</span>
<a href="#l2.504"></a><span id="l2.504" class="difflineplus">+- Fix relatively harmless bug in deflate_fast() [Exarevsky]</span>
<a href="#l2.505"></a><span id="l2.505" class="difflineplus">+- Fix same problem in deflate_slow()</span>
<a href="#l2.506"></a><span id="l2.506" class="difflineplus">+- Add $(SHAREDLIBV) to LIBS in Makefile.in [Brown]</span>
<a href="#l2.507"></a><span id="l2.507" class="difflineplus">+- Add deflate_rle() for faster Z_RLE strategy run-length encoding</span>
<a href="#l2.508"></a><span id="l2.508" class="difflineplus">+- Add deflate_huff() for faster Z_HUFFMAN_ONLY encoding</span>
<a href="#l2.509"></a><span id="l2.509" class="difflineplus">+- Change name of &quot;write&quot; variable in inffast.c to avoid library collisions</span>
<a href="#l2.510"></a><span id="l2.510" class="difflineplus">+- Fix premature EOF from gzread() in gzio.c [Brown]</span>
<a href="#l2.511"></a><span id="l2.511" class="difflineplus">+- Use zlib header window size if windowBits is 0 in inflateInit2()</span>
<a href="#l2.512"></a><span id="l2.512" class="difflineplus">+- Remove compressBound() call in deflate.c to avoid linking compress.o</span>
<a href="#l2.513"></a><span id="l2.513" class="difflineplus">+- Replace use of errno in gz* with functions, support WinCE [Alves]</span>
<a href="#l2.514"></a><span id="l2.514" class="difflineplus">+- Provide alternative to perror() in minigzip.c for WinCE [Alves]</span>
<a href="#l2.515"></a><span id="l2.515" class="difflineplus">+- Don't use _vsnprintf on later versions of MSVC [Lowman]</span>
<a href="#l2.516"></a><span id="l2.516" class="difflineplus">+- Add CMake build script and input file [Lowman]</span>
<a href="#l2.517"></a><span id="l2.517" class="difflineplus">+- Update contrib/minizip to 1.1 [Svensson, Vollant]</span>
<a href="#l2.518"></a><span id="l2.518" class="difflineplus">+- Moved nintendods directory from contrib to .</span>
<a href="#l2.519"></a><span id="l2.519" class="difflineplus">+- Replace gzio.c with a new set of routines with the same functionality</span>
<a href="#l2.520"></a><span id="l2.520" class="difflineplus">+- Add gzbuffer(), gzoffset(), gzclose_r(), gzclose_w() as part of above</span>
<a href="#l2.521"></a><span id="l2.521" class="difflineplus">+- Update contrib/minizip to 1.1b</span>
<a href="#l2.522"></a><span id="l2.522" class="difflineplus">+- Change gzeof() to return 0 on error instead of -1 to agree with zlib.h</span>
<a href="#l2.523"></a><span id="l2.523" class="difflineplus">+</span>
<a href="#l2.524"></a><span id="l2.524" class="difflineplus">+Changes in 1.2.3.4 (21 Dec 2009)</span>
<a href="#l2.525"></a><span id="l2.525" class="difflineplus">+- Use old school .SUFFIXES in Makefile.in for FreeBSD compatibility</span>
<a href="#l2.526"></a><span id="l2.526" class="difflineplus">+- Update comments in configure and Makefile.in for default --shared</span>
<a href="#l2.527"></a><span id="l2.527" class="difflineplus">+- Fix test -z's in configure [Marquess]</span>
<a href="#l2.528"></a><span id="l2.528" class="difflineplus">+- Build examplesh and minigzipsh when not testing</span>
<a href="#l2.529"></a><span id="l2.529" class="difflineplus">+- Change NULL's to Z_NULL's in deflate.c and in comments in zlib.h</span>
<a href="#l2.530"></a><span id="l2.530" class="difflineplus">+- Import LDFLAGS from the environment in configure</span>
<a href="#l2.531"></a><span id="l2.531" class="difflineplus">+- Fix configure to populate SFLAGS with discovered CFLAGS options</span>
<a href="#l2.532"></a><span id="l2.532" class="difflineplus">+- Adapt make_vms.com to the new Makefile.in [Zinser]</span>
<a href="#l2.533"></a><span id="l2.533" class="difflineplus">+- Add zlib2ansi script for C++ compilation [Marquess]</span>
<a href="#l2.534"></a><span id="l2.534" class="difflineplus">+- Add _FILE_OFFSET_BITS=64 test to make test (when applicable)</span>
<a href="#l2.535"></a><span id="l2.535" class="difflineplus">+- Add AMD64 assembler code for longest match to contrib [Teterin]</span>
<a href="#l2.536"></a><span id="l2.536" class="difflineplus">+- Include options from $SFLAGS when doing $LDSHARED</span>
<a href="#l2.537"></a><span id="l2.537" class="difflineplus">+- Simplify 64-bit file support by introducing z_off64_t type</span>
<a href="#l2.538"></a><span id="l2.538" class="difflineplus">+- Make shared object files in objs directory to work around old Sun cc</span>
<a href="#l2.539"></a><span id="l2.539" class="difflineplus">+- Use only three-part version number for Darwin shared compiles</span>
<a href="#l2.540"></a><span id="l2.540" class="difflineplus">+- Add rc option to ar in Makefile.in for when ./configure not run</span>
<a href="#l2.541"></a><span id="l2.541" class="difflineplus">+- Add -WI,-rpath,. to LDFLAGS for OSF 1 V4*</span>
<a href="#l2.542"></a><span id="l2.542" class="difflineplus">+- Set LD_LIBRARYN32_PATH for SGI IRIX shared compile</span>
<a href="#l2.543"></a><span id="l2.543" class="difflineplus">+- Protect against _FILE_OFFSET_BITS being defined when compiling zlib</span>
<a href="#l2.544"></a><span id="l2.544" class="difflineplus">+- Rename Makefile.in targets allstatic to static and allshared to shared</span>
<a href="#l2.545"></a><span id="l2.545" class="difflineplus">+- Fix static and shared Makefile.in targets to be independent</span>
<a href="#l2.546"></a><span id="l2.546" class="difflineplus">+- Correct error return bug in gz_open() by setting state [Brown]</span>
<a href="#l2.547"></a><span id="l2.547" class="difflineplus">+- Put spaces before ;;'s in configure for better sh compatibility</span>
<a href="#l2.548"></a><span id="l2.548" class="difflineplus">+- Add pigz.c (parallel implementation of gzip) to examples/</span>
<a href="#l2.549"></a><span id="l2.549" class="difflineplus">+- Correct constant in crc32.c to UL [Leventhal]</span>
<a href="#l2.550"></a><span id="l2.550" class="difflineplus">+- Reject negative lengths in crc32_combine()</span>
<a href="#l2.551"></a><span id="l2.551" class="difflineplus">+- Add inflateReset2() function to work like inflateEnd()/inflateInit2()</span>
<a href="#l2.552"></a><span id="l2.552" class="difflineplus">+- Include sys/types.h for _LARGEFILE64_SOURCE [Brown]</span>
<a href="#l2.553"></a><span id="l2.553" class="difflineplus">+- Correct typo in doc/algorithm.txt [Janik]</span>
<a href="#l2.554"></a><span id="l2.554" class="difflineplus">+- Fix bug in adler32_combine() [Zhu]</span>
<a href="#l2.555"></a><span id="l2.555" class="difflineplus">+- Catch missing-end-of-block-code error in all inflates and in puff</span>
<a href="#l2.556"></a><span id="l2.556" class="difflineplus">+    Assures that random input to inflate eventually results in an error</span>
<a href="#l2.557"></a><span id="l2.557" class="difflineplus">+- Added enough.c (calculation of ENOUGH for inftrees.h) to examples/</span>
<a href="#l2.558"></a><span id="l2.558" class="difflineplus">+- Update ENOUGH and its usage to reflect discovered bounds</span>
<a href="#l2.559"></a><span id="l2.559" class="difflineplus">+- Fix gzerror() error report on empty input file [Brown]</span>
<a href="#l2.560"></a><span id="l2.560" class="difflineplus">+- Add ush casts in trees.c to avoid pedantic runtime errors</span>
<a href="#l2.561"></a><span id="l2.561" class="difflineplus">+- Fix typo in zlib.h uncompress() description [Reiss]</span>
<a href="#l2.562"></a><span id="l2.562" class="difflineplus">+- Correct inflate() comments with regard to automatic header detection</span>
<a href="#l2.563"></a><span id="l2.563" class="difflineplus">+- Remove deprecation comment on Z_PARTIAL_FLUSH (it stays)</span>
<a href="#l2.564"></a><span id="l2.564" class="difflineplus">+- Put new version of gzlog (2.0) in examples with interruption recovery</span>
<a href="#l2.565"></a><span id="l2.565" class="difflineplus">+- Add puff compile option to permit invalid distance-too-far streams</span>
<a href="#l2.566"></a><span id="l2.566" class="difflineplus">+- Add puff TEST command options, ability to read piped input</span>
<a href="#l2.567"></a><span id="l2.567" class="difflineplus">+- Prototype the *64 functions in zlib.h when _FILE_OFFSET_BITS == 64, but</span>
<a href="#l2.568"></a><span id="l2.568" class="difflineplus">+  _LARGEFILE64_SOURCE not defined</span>
<a href="#l2.569"></a><span id="l2.569" class="difflineplus">+- Fix Z_FULL_FLUSH to truly erase the past by resetting s-&gt;strstart</span>
<a href="#l2.570"></a><span id="l2.570" class="difflineplus">+- Fix deflateSetDictionary() to use all 32K for output consistency</span>
<a href="#l2.571"></a><span id="l2.571" class="difflineplus">+- Remove extraneous #define MIN_LOOKAHEAD in deflate.c (in deflate.h)</span>
<a href="#l2.572"></a><span id="l2.572" class="difflineplus">+- Clear bytes after deflate lookahead to avoid use of uninitialized data</span>
<a href="#l2.573"></a><span id="l2.573" class="difflineplus">+- Change a limit in inftrees.c to be more transparent to Coverity Prevent</span>
<a href="#l2.574"></a><span id="l2.574" class="difflineplus">+- Update win32/zlib.def with exported symbols from zlib.h</span>
<a href="#l2.575"></a><span id="l2.575" class="difflineplus">+- Correct spelling errors in zlib.h [Willem, Sobrado]</span>
<a href="#l2.576"></a><span id="l2.576" class="difflineplus">+- Allow Z_BLOCK for deflate() to force a new block</span>
<a href="#l2.577"></a><span id="l2.577" class="difflineplus">+- Allow negative bits in inflatePrime() to delete existing bit buffer</span>
<a href="#l2.578"></a><span id="l2.578" class="difflineplus">+- Add Z_TREES flush option to inflate() to return at end of trees</span>
<a href="#l2.579"></a><span id="l2.579" class="difflineplus">+- Add inflateMark() to return current state information for random access</span>
<a href="#l2.580"></a><span id="l2.580" class="difflineplus">+- Add Makefile for NintendoDS to contrib [Costa]</span>
<a href="#l2.581"></a><span id="l2.581" class="difflineplus">+- Add -w in configure compile tests to avoid spurious warnings [Beucler]</span>
<a href="#l2.582"></a><span id="l2.582" class="difflineplus">+- Fix typos in zlib.h comments for deflateSetDictionary()</span>
<a href="#l2.583"></a><span id="l2.583" class="difflineplus">+- Fix EOF detection in transparent gzread() [Maier]</span>
<a href="#l2.584"></a><span id="l2.584" class="difflineplus">+</span>
<a href="#l2.585"></a><span id="l2.585" class="difflineplus">+Changes in 1.2.3.3 (2 October 2006)</span>
<a href="#l2.586"></a><span id="l2.586" class="difflineplus">+- Make --shared the default for configure, add a --static option</span>
<a href="#l2.587"></a><span id="l2.587" class="difflineplus">+- Add compile option to permit invalid distance-too-far streams</span>
<a href="#l2.588"></a><span id="l2.588" class="difflineplus">+- Add inflateUndermine() function which is required to enable above</span>
<a href="#l2.589"></a><span id="l2.589" class="difflineplus">+- Remove use of &quot;this&quot; variable name for C++ compatibility [Marquess]</span>
<a href="#l2.590"></a><span id="l2.590" class="difflineplus">+- Add testing of shared library in make test, if shared library built</span>
<a href="#l2.591"></a><span id="l2.591" class="difflineplus">+- Use ftello() and fseeko() if available instead of ftell() and fseek()</span>
<a href="#l2.592"></a><span id="l2.592" class="difflineplus">+- Provide two versions of all functions that use the z_off_t type for</span>
<a href="#l2.593"></a><span id="l2.593" class="difflineplus">+  binary compatibility -- a normal version and a 64-bit offset version,</span>
<a href="#l2.594"></a><span id="l2.594" class="difflineplus">+  per the Large File Support Extension when _LARGEFILE64_SOURCE is</span>
<a href="#l2.595"></a><span id="l2.595" class="difflineplus">+  defined; use the 64-bit versions by default when _FILE_OFFSET_BITS</span>
<a href="#l2.596"></a><span id="l2.596" class="difflineplus">+  is defined to be 64</span>
<a href="#l2.597"></a><span id="l2.597" class="difflineplus">+- Add a --uname= option to configure to perhaps help with cross-compiling</span>
<a href="#l2.598"></a><span id="l2.598" class="difflineplus">+</span>
<a href="#l2.599"></a><span id="l2.599" class="difflineplus">+Changes in 1.2.3.2 (3 September 2006)</span>
<a href="#l2.600"></a><span id="l2.600" class="difflineplus">+- Turn off silly Borland warnings [Hay]</span>
<a href="#l2.601"></a><span id="l2.601" class="difflineplus">+- Use off64_t and define _LARGEFILE64_SOURCE when present</span>
<a href="#l2.602"></a><span id="l2.602" class="difflineplus">+- Fix missing dependency on inffixed.h in Makefile.in</span>
<a href="#l2.603"></a><span id="l2.603" class="difflineplus">+- Rig configure --shared to build both shared and static [Teredesai, Truta]</span>
<a href="#l2.604"></a><span id="l2.604" class="difflineplus">+- Remove zconf.in.h and instead create a new zlibdefs.h file</span>
<a href="#l2.605"></a><span id="l2.605" class="difflineplus">+- Fix contrib/minizip/unzip.c non-encrypted after encrypted [Vollant]</span>
<a href="#l2.606"></a><span id="l2.606" class="difflineplus">+- Add treebuild.xml (see http://treebuild.metux.de/) [Weigelt]</span>
<a href="#l2.607"></a><span id="l2.607" class="difflineplus">+</span>
<a href="#l2.608"></a><span id="l2.608" class="difflineplus">+Changes in 1.2.3.1 (16 August 2006)</span>
<a href="#l2.609"></a><span id="l2.609" class="difflineplus">+- Add watcom directory with OpenWatcom make files [Daniel]</span>
<a href="#l2.610"></a><span id="l2.610" class="difflineplus">+- Remove #undef of FAR in zconf.in.h for MVS [Fedtke]</span>
<a href="#l2.611"></a><span id="l2.611" class="difflineplus">+- Update make_vms.com [Zinser]</span>
<a href="#l2.612"></a><span id="l2.612" class="difflineplus">+- Use -fPIC for shared build in configure [Teredesai, Nicholson]</span>
<a href="#l2.613"></a><span id="l2.613" class="difflineplus">+- Use only major version number for libz.so on IRIX and OSF1 [Reinholdtsen]</span>
<a href="#l2.614"></a><span id="l2.614" class="difflineplus">+- Use fdopen() (not _fdopen()) for Interix in zutil.h [Bäck]</span>
<a href="#l2.615"></a><span id="l2.615" class="difflineplus">+- Add some FAQ entries about the contrib directory</span>
<a href="#l2.616"></a><span id="l2.616" class="difflineplus">+- Update the MVS question in the FAQ</span>
<a href="#l2.617"></a><span id="l2.617" class="difflineplus">+- Avoid extraneous reads after EOF in gzio.c [Brown]</span>
<a href="#l2.618"></a><span id="l2.618" class="difflineplus">+- Correct spelling of &quot;successfully&quot; in gzio.c [Randers-Pehrson]</span>
<a href="#l2.619"></a><span id="l2.619" class="difflineplus">+- Add comments to zlib.h about gzerror() usage [Brown]</span>
<a href="#l2.620"></a><span id="l2.620" class="difflineplus">+- Set extra flags in gzip header in gzopen() like deflate() does</span>
<a href="#l2.621"></a><span id="l2.621" class="difflineplus">+- Make configure options more compatible with double-dash conventions</span>
<a href="#l2.622"></a><span id="l2.622" class="difflineplus">+  [Weigelt]</span>
<a href="#l2.623"></a><span id="l2.623" class="difflineplus">+- Clean up compilation under Solaris SunStudio cc [Rowe, Reinholdtsen]</span>
<a href="#l2.624"></a><span id="l2.624" class="difflineplus">+- Fix uninstall target in Makefile.in [Truta]</span>
<a href="#l2.625"></a><span id="l2.625" class="difflineplus">+- Add pkgconfig support [Weigelt]</span>
<a href="#l2.626"></a><span id="l2.626" class="difflineplus">+- Use $(DESTDIR) macro in Makefile.in [Reinholdtsen, Weigelt]</span>
<a href="#l2.627"></a><span id="l2.627" class="difflineplus">+- Replace set_data_type() with a more accurate detect_data_type() in</span>
<a href="#l2.628"></a><span id="l2.628" class="difflineplus">+  trees.c, according to the txtvsbin.txt document [Truta]</span>
<a href="#l2.629"></a><span id="l2.629" class="difflineplus">+- Swap the order of #include &lt;stdio.h&gt; and #include &quot;zlib.h&quot; in</span>
<a href="#l2.630"></a><span id="l2.630" class="difflineplus">+  gzio.c, example.c and minigzip.c [Truta]</span>
<a href="#l2.631"></a><span id="l2.631" class="difflineplus">+- Shut up annoying VS2005 warnings about standard C deprecation [Rowe,</span>
<a href="#l2.632"></a><span id="l2.632" class="difflineplus">+  Truta] (where?)</span>
<a href="#l2.633"></a><span id="l2.633" class="difflineplus">+- Fix target &quot;clean&quot; from win32/Makefile.bor [Truta]</span>
<a href="#l2.634"></a><span id="l2.634" class="difflineplus">+- Create .pdb and .manifest files in win32/makefile.msc [Ziegler, Rowe]</span>
<a href="#l2.635"></a><span id="l2.635" class="difflineplus">+- Update zlib www home address in win32/DLL_FAQ.txt [Truta]</span>
<a href="#l2.636"></a><span id="l2.636" class="difflineplus">+- Update contrib/masmx86/inffas32.asm for VS2005 [Vollant, Van Wassenhove]</span>
<a href="#l2.637"></a><span id="l2.637" class="difflineplus">+- Enable browse info in the &quot;Debug&quot; and &quot;ASM Debug&quot; configurations in</span>
<a href="#l2.638"></a><span id="l2.638" class="difflineplus">+  the Visual C++ 6 project, and set (non-ASM) &quot;Debug&quot; as default [Truta]</span>
<a href="#l2.639"></a><span id="l2.639" class="difflineplus">+- Add pkgconfig support [Weigelt]</span>
<a href="#l2.640"></a><span id="l2.640" class="difflineplus">+- Add ZLIB_VER_MAJOR, ZLIB_VER_MINOR and ZLIB_VER_REVISION in zlib.h,</span>
<a href="#l2.641"></a><span id="l2.641" class="difflineplus">+  for use in win32/zlib1.rc [Polushin, Rowe, Truta]</span>
<a href="#l2.642"></a><span id="l2.642" class="difflineplus">+- Add a document that explains the new text detection scheme to</span>
<a href="#l2.643"></a><span id="l2.643" class="difflineplus">+  doc/txtvsbin.txt [Truta]</span>
<a href="#l2.644"></a><span id="l2.644" class="difflineplus">+- Add rfc1950.txt, rfc1951.txt and rfc1952.txt to doc/ [Truta]</span>
<a href="#l2.645"></a><span id="l2.645" class="difflineplus">+- Move algorithm.txt into doc/ [Truta]</span>
<a href="#l2.646"></a><span id="l2.646" class="difflineplus">+- Synchronize FAQ with website</span>
<a href="#l2.647"></a><span id="l2.647" class="difflineplus">+- Fix compressBound(), was low for some pathological cases [Fearnley]</span>
<a href="#l2.648"></a><span id="l2.648" class="difflineplus">+- Take into account wrapper variations in deflateBound()</span>
<a href="#l2.649"></a><span id="l2.649" class="difflineplus">+- Set examples/zpipe.c input and output to binary mode for Windows</span>
<a href="#l2.650"></a><span id="l2.650" class="difflineplus">+- Update examples/zlib_how.html with new zpipe.c (also web site)</span>
<a href="#l2.651"></a><span id="l2.651" class="difflineplus">+- Fix some warnings in examples/gzlog.c and examples/zran.c (it seems</span>
<a href="#l2.652"></a><span id="l2.652" class="difflineplus">+  that gcc became pickier in 4.0)</span>
<a href="#l2.653"></a><span id="l2.653" class="difflineplus">+- Add zlib.map for Linux: &quot;All symbols from zlib-1.1.4 remain</span>
<a href="#l2.654"></a><span id="l2.654" class="difflineplus">+  un-versioned, the patch adds versioning only for symbols introduced in</span>
<a href="#l2.655"></a><span id="l2.655" class="difflineplus">+  zlib-1.2.0 or later.  It also declares as local those symbols which are</span>
<a href="#l2.656"></a><span id="l2.656" class="difflineplus">+  not designed to be exported.&quot; [Levin]</span>
<a href="#l2.657"></a><span id="l2.657" class="difflineplus">+- Update Z_PREFIX list in zconf.in.h, add --zprefix option to configure</span>
<a href="#l2.658"></a><span id="l2.658" class="difflineplus">+- Do not initialize global static by default in trees.c, add a response</span>
<a href="#l2.659"></a><span id="l2.659" class="difflineplus">+  NO_INIT_GLOBAL_POINTERS to initialize them if needed [Marquess]</span>
<a href="#l2.660"></a><span id="l2.660" class="difflineplus">+- Don't use strerror() in gzio.c under WinCE [Yakimov]</span>
<a href="#l2.661"></a><span id="l2.661" class="difflineplus">+- Don't use errno.h in zutil.h under WinCE [Yakimov]</span>
<a href="#l2.662"></a><span id="l2.662" class="difflineplus">+- Move arguments for AR to its usage to allow replacing ar [Marot]</span>
<a href="#l2.663"></a><span id="l2.663" class="difflineplus">+- Add HAVE_VISIBILITY_PRAGMA in zconf.in.h for Mozilla [Randers-Pehrson]</span>
<a href="#l2.664"></a><span id="l2.664" class="difflineplus">+- Improve inflateInit() and inflateInit2() documentation</span>
<a href="#l2.665"></a><span id="l2.665" class="difflineplus">+- Fix structure size comment in inflate.h</span>
<a href="#l2.666"></a><span id="l2.666" class="difflineplus">+- Change configure help option from --h* to --help [Santos]</span>
<a href="#l2.667"></a><span id="l2.667" class="difflineplus">+</span>
<a href="#l2.668"></a><span id="l2.668" class="difflineplus">+Changes in 1.2.3 (18 July 2005)</span>
<a href="#l2.669"></a><span id="l2.669" class="difflineplus">+- Apply security vulnerability fixes to contrib/infback9 as well</span>
<a href="#l2.670"></a><span id="l2.670" class="difflineplus">+- Clean up some text files (carriage returns, trailing space)</span>
<a href="#l2.671"></a><span id="l2.671" class="difflineplus">+- Update testzlib, vstudio, masmx64, and masmx86 in contrib [Vollant]</span>
<a href="#l2.672"></a><span id="l2.672" class="difflineplus">+</span>
<a href="#l2.673"></a><span id="l2.673" class="difflineplus">+Changes in 1.2.2.4 (11 July 2005)</span>
<a href="#l2.674"></a><span id="l2.674" class="difflineplus">+- Add inflatePrime() function for starting inflation at bit boundary</span>
<a href="#l2.675"></a><span id="l2.675" class="difflineplus">+- Avoid some Visual C warnings in deflate.c</span>
<a href="#l2.676"></a><span id="l2.676" class="difflineplus">+- Avoid more silly Visual C warnings in inflate.c and inftrees.c for 64-bit</span>
<a href="#l2.677"></a><span id="l2.677" class="difflineplus">+  compile</span>
<a href="#l2.678"></a><span id="l2.678" class="difflineplus">+- Fix some spelling errors in comments [Betts]</span>
<a href="#l2.679"></a><span id="l2.679" class="difflineplus">+- Correct inflateInit2() error return documentation in zlib.h</span>
<a href="#l2.680"></a><span id="l2.680" class="difflineplus">+- Add zran.c example of compressed data random access to examples</span>
<a href="#l2.681"></a><span id="l2.681" class="difflineplus">+  directory, shows use of inflatePrime()</span>
<a href="#l2.682"></a><span id="l2.682" class="difflineplus">+- Fix cast for assignments to strm-&gt;state in inflate.c and infback.c</span>
<a href="#l2.683"></a><span id="l2.683" class="difflineplus">+- Fix zlibCompileFlags() in zutil.c to use 1L for long shifts [Oberhumer]</span>
<a href="#l2.684"></a><span id="l2.684" class="difflineplus">+- Move declarations of gf2 functions to right place in crc32.c [Oberhumer]</span>
<a href="#l2.685"></a><span id="l2.685" class="difflineplus">+- Add cast in trees.c t avoid a warning [Oberhumer]</span>
<a href="#l2.686"></a><span id="l2.686" class="difflineplus">+- Avoid some warnings in fitblk.c, gun.c, gzjoin.c in examples [Oberhumer]</span>
<a href="#l2.687"></a><span id="l2.687" class="difflineplus">+- Update make_vms.com [Zinser]</span>
<a href="#l2.688"></a><span id="l2.688" class="difflineplus">+- Initialize state-&gt;write in inflateReset() since copied in inflate_fast()</span>
<a href="#l2.689"></a><span id="l2.689" class="difflineplus">+- Be more strict on incomplete code sets in inflate_table() and increase</span>
<a href="#l2.690"></a><span id="l2.690" class="difflineplus">+  ENOUGH and MAXD -- this repairs a possible security vulnerability for</span>
<a href="#l2.691"></a><span id="l2.691" class="difflineplus">+  invalid inflate input.  Thanks to Tavis Ormandy and Markus Oberhumer for</span>
<a href="#l2.692"></a><span id="l2.692" class="difflineplus">+  discovering the vulnerability and providing test cases.</span>
<a href="#l2.693"></a><span id="l2.693" class="difflineplus">+- Add ia64 support to configure for HP-UX [Smith]</span>
<a href="#l2.694"></a><span id="l2.694" class="difflineplus">+- Add error return to gzread() for format or i/o error [Levin]</span>
<a href="#l2.695"></a><span id="l2.695" class="difflineplus">+- Use malloc.h for OS/2 [Necasek]</span>
<a href="#l2.696"></a><span id="l2.696" class="difflineplus">+</span>
<a href="#l2.697"></a><span id="l2.697" class="difflineplus">+Changes in 1.2.2.3 (27 May 2005)</span>
<a href="#l2.698"></a><span id="l2.698" class="difflineplus">+- Replace 1U constants in inflate.c and inftrees.c for 64-bit compile</span>
<a href="#l2.699"></a><span id="l2.699" class="difflineplus">+- Typecast fread() return values in gzio.c [Vollant]</span>
<a href="#l2.700"></a><span id="l2.700" class="difflineplus">+- Remove trailing space in minigzip.c outmode (VC++ can't deal with it)</span>
<a href="#l2.701"></a><span id="l2.701" class="difflineplus">+- Fix crc check bug in gzread() after gzungetc() [Heiner]</span>
<a href="#l2.702"></a><span id="l2.702" class="difflineplus">+- Add the deflateTune() function to adjust internal compression parameters</span>
<a href="#l2.703"></a><span id="l2.703" class="difflineplus">+- Add a fast gzip decompressor, gun.c, to examples (use of inflateBack)</span>
<a href="#l2.704"></a><span id="l2.704" class="difflineplus">+- Remove an incorrect assertion in examples/zpipe.c</span>
<a href="#l2.705"></a><span id="l2.705" class="difflineplus">+- Add C++ wrapper in infback9.h [Donais]</span>
<a href="#l2.706"></a><span id="l2.706" class="difflineplus">+- Fix bug in inflateCopy() when decoding fixed codes</span>
<a href="#l2.707"></a><span id="l2.707" class="difflineplus">+- Note in zlib.h how much deflateSetDictionary() actually uses</span>
<a href="#l2.708"></a><span id="l2.708" class="difflineplus">+- Remove USE_DICT_HEAD in deflate.c (would mess up inflate if used)</span>
<a href="#l2.709"></a><span id="l2.709" class="difflineplus">+- Add _WIN32_WCE to define WIN32 in zconf.in.h [Spencer]</span>
<a href="#l2.710"></a><span id="l2.710" class="difflineplus">+- Don't include stderr.h or errno.h for _WIN32_WCE in zutil.h [Spencer]</span>
<a href="#l2.711"></a><span id="l2.711" class="difflineplus">+- Add gzdirect() function to indicate transparent reads</span>
<a href="#l2.712"></a><span id="l2.712" class="difflineplus">+- Update contrib/minizip [Vollant]</span>
<a href="#l2.713"></a><span id="l2.713" class="difflineplus">+- Fix compilation of deflate.c when both ASMV and FASTEST [Oberhumer]</span>
<a href="#l2.714"></a><span id="l2.714" class="difflineplus">+- Add casts in crc32.c to avoid warnings [Oberhumer]</span>
<a href="#l2.715"></a><span id="l2.715" class="difflineplus">+- Add contrib/masmx64 [Vollant]</span>
<a href="#l2.716"></a><span id="l2.716" class="difflineplus">+- Update contrib/asm586, asm686, masmx86, testzlib, vstudio [Vollant]</span>
<a href="#l2.717"></a><span id="l2.717" class="difflineplus">+</span>
<a href="#l2.718"></a><span id="l2.718" class="difflineplus">+Changes in 1.2.2.2 (30 December 2004)</span>
<a href="#l2.719"></a><span id="l2.719" class="difflineplus">+- Replace structure assignments in deflate.c and inflate.c with zmemcpy to</span>
<a href="#l2.720"></a><span id="l2.720" class="difflineplus">+  avoid implicit memcpy calls (portability for no-library compilation)</span>
<a href="#l2.721"></a><span id="l2.721" class="difflineplus">+- Increase sprintf() buffer size in gzdopen() to allow for large numbers</span>
<a href="#l2.722"></a><span id="l2.722" class="difflineplus">+- Add INFLATE_STRICT to check distances against zlib header</span>
<a href="#l2.723"></a><span id="l2.723" class="difflineplus">+- Improve WinCE errno handling and comments [Chang]</span>
<a href="#l2.724"></a><span id="l2.724" class="difflineplus">+- Remove comment about no gzip header processing in FAQ</span>
<a href="#l2.725"></a><span id="l2.725" class="difflineplus">+- Add Z_FIXED strategy option to deflateInit2() to force fixed trees</span>
<a href="#l2.726"></a><span id="l2.726" class="difflineplus">+- Add updated make_vms.com [Coghlan], update README</span>
<a href="#l2.727"></a><span id="l2.727" class="difflineplus">+- Create a new &quot;examples&quot; directory, move gzappend.c there, add zpipe.c,</span>
<a href="#l2.728"></a><span id="l2.728" class="difflineplus">+  fitblk.c, gzlog.[ch], gzjoin.c, and zlib_how.html.</span>
<a href="#l2.729"></a><span id="l2.729" class="difflineplus">+- Add FAQ entry and comments in deflate.c on uninitialized memory access</span>
<a href="#l2.730"></a><span id="l2.730" class="difflineplus">+- Add Solaris 9 make options in configure [Gilbert]</span>
<a href="#l2.731"></a><span id="l2.731" class="difflineplus">+- Allow strerror() usage in gzio.c for STDC</span>
<a href="#l2.732"></a><span id="l2.732" class="difflineplus">+- Fix DecompressBuf in contrib/delphi/ZLib.pas [ManChesTer]</span>
<a href="#l2.733"></a><span id="l2.733" class="difflineplus">+- Update contrib/masmx86/inffas32.asm and gvmat32.asm [Vollant]</span>
<a href="#l2.734"></a><span id="l2.734" class="difflineplus">+- Use z_off_t for adler32_combine() and crc32_combine() lengths</span>
<a href="#l2.735"></a><span id="l2.735" class="difflineplus">+- Make adler32() much faster for small len</span>
<a href="#l2.736"></a><span id="l2.736" class="difflineplus">+- Use OS_CODE in deflate() default gzip header</span>
<a href="#l2.737"></a><span id="l2.737" class="difflineplus">+</span>
<a href="#l2.738"></a><span id="l2.738" class="difflineplus">+Changes in 1.2.2.1 (31 October 2004)</span>
<a href="#l2.739"></a><span id="l2.739" class="difflineplus">+- Allow inflateSetDictionary() call for raw inflate</span>
<a href="#l2.740"></a><span id="l2.740" class="difflineplus">+- Fix inflate header crc check bug for file names and comments</span>
<a href="#l2.741"></a><span id="l2.741" class="difflineplus">+- Add deflateSetHeader() and gz_header structure for custom gzip headers</span>
<a href="#l2.742"></a><span id="l2.742" class="difflineplus">+- Add inflateGetheader() to retrieve gzip headers</span>
<a href="#l2.743"></a><span id="l2.743" class="difflineplus">+- Add crc32_combine() and adler32_combine() functions</span>
<a href="#l2.744"></a><span id="l2.744" class="difflineplus">+- Add alloc_func, free_func, in_func, out_func to Z_PREFIX list</span>
<a href="#l2.745"></a><span id="l2.745" class="difflineplus">+- Use zstreamp consistently in zlib.h (inflate_back functions)</span>
<a href="#l2.746"></a><span id="l2.746" class="difflineplus">+- Remove GUNZIP condition from definition of inflate_mode in inflate.h</span>
<a href="#l2.747"></a><span id="l2.747" class="difflineplus">+  and in contrib/inflate86/inffast.S [Truta, Anderson]</span>
<a href="#l2.748"></a><span id="l2.748" class="difflineplus">+- Add support for AMD64 in contrib/inflate86/inffas86.c [Anderson]</span>
<a href="#l2.749"></a><span id="l2.749" class="difflineplus">+- Update projects/README.projects and projects/visualc6 [Truta]</span>
<a href="#l2.750"></a><span id="l2.750" class="difflineplus">+- Update win32/DLL_FAQ.txt [Truta]</span>
<a href="#l2.751"></a><span id="l2.751" class="difflineplus">+- Avoid warning under NO_GZCOMPRESS in gzio.c; fix typo [Truta]</span>
<a href="#l2.752"></a><span id="l2.752" class="difflineplus">+- Deprecate Z_ASCII; use Z_TEXT instead [Truta]</span>
<a href="#l2.753"></a><span id="l2.753" class="difflineplus">+- Use a new algorithm for setting strm-&gt;data_type in trees.c [Truta]</span>
<a href="#l2.754"></a><span id="l2.754" class="difflineplus">+- Do not define an exit() prototype in zutil.c unless DEBUG defined</span>
<a href="#l2.755"></a><span id="l2.755" class="difflineplus">+- Remove prototype of exit() from zutil.c, example.c, minigzip.c [Truta]</span>
<a href="#l2.756"></a><span id="l2.756" class="difflineplus">+- Add comment in zlib.h for Z_NO_FLUSH parameter to deflate()</span>
<a href="#l2.757"></a><span id="l2.757" class="difflineplus">+- Fix Darwin build version identification [Peterson]</span>
<a href="#l2.758"></a><span id="l2.758" class="difflineplus">+</span>
<a href="#l2.759"></a><span id="l2.759" class="difflineplus">+Changes in 1.2.2 (3 October 2004)</span>
<a href="#l2.760"></a><span id="l2.760" class="difflineplus">+- Update zlib.h comments on gzip in-memory processing</span>
<a href="#l2.761"></a><span id="l2.761" class="difflineplus">+- Set adler to 1 in inflateReset() to support Java test suite [Walles]</span>
<a href="#l2.762"></a><span id="l2.762" class="difflineplus">+- Add contrib/dotzlib [Ravn]</span>
<a href="#l2.763"></a><span id="l2.763" class="difflineplus">+- Update win32/DLL_FAQ.txt [Truta]</span>
<a href="#l2.764"></a><span id="l2.764" class="difflineplus">+- Update contrib/minizip [Vollant]</span>
<a href="#l2.765"></a><span id="l2.765" class="difflineplus">+- Move contrib/visual-basic.txt to old/ [Truta]</span>
<a href="#l2.766"></a><span id="l2.766" class="difflineplus">+- Fix assembler builds in projects/visualc6/ [Truta]</span>
<a href="#l2.767"></a><span id="l2.767" class="difflineplus">+</span>
<a href="#l2.768"></a><span id="l2.768" class="difflineplus">+Changes in 1.2.1.2 (9 September 2004)</span>
<a href="#l2.769"></a><span id="l2.769" class="difflineplus">+- Update INDEX file</span>
<a href="#l2.770"></a><span id="l2.770" class="difflineplus">+- Fix trees.c to update strm-&gt;data_type (no one ever noticed!)</span>
<a href="#l2.771"></a><span id="l2.771" class="difflineplus">+- Fix bug in error case in inflate.c, infback.c, and infback9.c [Brown]</span>
<a href="#l2.772"></a><span id="l2.772" class="difflineplus">+- Add &quot;volatile&quot; to crc table flag declaration (for DYNAMIC_CRC_TABLE)</span>
<a href="#l2.773"></a><span id="l2.773" class="difflineplus">+- Add limited multitasking protection to DYNAMIC_CRC_TABLE</span>
<a href="#l2.774"></a><span id="l2.774" class="difflineplus">+- Add NO_vsnprintf for VMS in zutil.h [Mozilla]</span>
<a href="#l2.775"></a><span id="l2.775" class="difflineplus">+- Don't declare strerror() under VMS [Mozilla]</span>
<a href="#l2.776"></a><span id="l2.776" class="difflineplus">+- Add comment to DYNAMIC_CRC_TABLE to use get_crc_table() to initialize</span>
<a href="#l2.777"></a><span id="l2.777" class="difflineplus">+- Update contrib/ada [Anisimkov]</span>
<a href="#l2.778"></a><span id="l2.778" class="difflineplus">+- Update contrib/minizip [Vollant]</span>
<a href="#l2.779"></a><span id="l2.779" class="difflineplus">+- Fix configure to not hardcode directories for Darwin [Peterson]</span>
<a href="#l2.780"></a><span id="l2.780" class="difflineplus">+- Fix gzio.c to not return error on empty files [Brown]</span>
<a href="#l2.781"></a><span id="l2.781" class="difflineplus">+- Fix indentation; update version in contrib/delphi/ZLib.pas and</span>
<a href="#l2.782"></a><span id="l2.782" class="difflineplus">+  contrib/pascal/zlibpas.pas [Truta]</span>
<a href="#l2.783"></a><span id="l2.783" class="difflineplus">+- Update mkasm.bat in contrib/masmx86 [Truta]</span>
<a href="#l2.784"></a><span id="l2.784" class="difflineplus">+- Update contrib/untgz [Truta]</span>
<a href="#l2.785"></a><span id="l2.785" class="difflineplus">+- Add projects/README.projects [Truta]</span>
<a href="#l2.786"></a><span id="l2.786" class="difflineplus">+- Add project for MS Visual C++ 6.0 in projects/visualc6 [Cadieux, Truta]</span>
<a href="#l2.787"></a><span id="l2.787" class="difflineplus">+- Update win32/DLL_FAQ.txt [Truta]</span>
<a href="#l2.788"></a><span id="l2.788" class="difflineplus">+- Update list of Z_PREFIX symbols in zconf.h [Randers-Pehrson, Truta]</span>
<a href="#l2.789"></a><span id="l2.789" class="difflineplus">+- Remove an unnecessary assignment to curr in inftrees.c [Truta]</span>
<a href="#l2.790"></a><span id="l2.790" class="difflineplus">+- Add OS/2 to exe builds in configure [Poltorak]</span>
<a href="#l2.791"></a><span id="l2.791" class="difflineplus">+- Remove err dummy parameter in zlib.h [Kientzle]</span>
<a href="#l2.792"></a><span id="l2.792" class="difflineplus">+</span>
<a href="#l2.793"></a><span id="l2.793" class="difflineplus">+Changes in 1.2.1.1 (9 January 2004)</span>
<a href="#l2.794"></a><span id="l2.794" class="difflineplus">+- Update email address in README</span>
<a href="#l2.795"></a><span id="l2.795" class="difflineplus">+- Several FAQ updates</span>
<a href="#l2.796"></a><span id="l2.796" class="difflineplus">+- Fix a big fat bug in inftrees.c that prevented decoding valid</span>
<a href="#l2.797"></a><span id="l2.797" class="difflineplus">+  dynamic blocks with only literals and no distance codes --</span>
<a href="#l2.798"></a><span id="l2.798" class="difflineplus">+  Thanks to &quot;Hot Emu&quot; for the bug report and sample file</span>
<a href="#l2.799"></a><span id="l2.799" class="difflineplus">+- Add a note to puff.c on no distance codes case.</span>
<a href="#l2.800"></a><span id="l2.800" class="difflineplus">+</span>
<a href="#l2.801"></a><span id="l2.801" class="difflineplus">+Changes in 1.2.1 (17 November 2003)</span>
<a href="#l2.802"></a><span id="l2.802" class="difflineplus">+- Remove a tab in contrib/gzappend/gzappend.c</span>
<a href="#l2.803"></a><span id="l2.803" class="difflineplus">+- Update some interfaces in contrib for new zlib functions</span>
<a href="#l2.804"></a><span id="l2.804" class="difflineplus">+- Update zlib version number in some contrib entries</span>
<a href="#l2.805"></a><span id="l2.805" class="difflineplus">+- Add Windows CE definition for ptrdiff_t in zutil.h [Mai, Truta]</span>
<a href="#l2.806"></a><span id="l2.806" class="difflineplus">+- Support shared libraries on Hurd and KFreeBSD [Brown]</span>
<a href="#l2.807"></a><span id="l2.807" class="difflineplus">+- Fix error in NO_DIVIDE option of adler32.c</span>
<a href="#l2.808"></a><span id="l2.808" class="difflineplus">+</span>
<a href="#l2.809"></a><span id="l2.809" class="difflineplus">+Changes in 1.2.0.8 (4 November 2003)</span>
<a href="#l2.810"></a><span id="l2.810" class="difflineplus">+- Update version in contrib/delphi/ZLib.pas and contrib/pascal/zlibpas.pas</span>
<a href="#l2.811"></a><span id="l2.811" class="difflineplus">+- Add experimental NO_DIVIDE #define in adler32.c</span>
<a href="#l2.812"></a><span id="l2.812" class="difflineplus">+    - Possibly faster on some processors (let me know if it is)</span>
<a href="#l2.813"></a><span id="l2.813" class="difflineplus">+- Correct Z_BLOCK to not return on first inflate call if no wrap</span>
<a href="#l2.814"></a><span id="l2.814" class="difflineplus">+- Fix strm-&gt;data_type on inflate() return to correctly indicate EOB</span>
<a href="#l2.815"></a><span id="l2.815" class="difflineplus">+- Add deflatePrime() function for appending in the middle of a byte</span>
<a href="#l2.816"></a><span id="l2.816" class="difflineplus">+- Add contrib/gzappend for an example of appending to a stream</span>
<a href="#l2.817"></a><span id="l2.817" class="difflineplus">+- Update win32/DLL_FAQ.txt [Truta]</span>
<a href="#l2.818"></a><span id="l2.818" class="difflineplus">+- Delete Turbo C comment in README [Truta]</span>
<a href="#l2.819"></a><span id="l2.819" class="difflineplus">+- Improve some indentation in zconf.h [Truta]</span>
<a href="#l2.820"></a><span id="l2.820" class="difflineplus">+- Fix infinite loop on bad input in configure script [Church]</span>
<a href="#l2.821"></a><span id="l2.821" class="difflineplus">+- Fix gzeof() for concatenated gzip files [Johnson]</span>
<a href="#l2.822"></a><span id="l2.822" class="difflineplus">+- Add example to contrib/visual-basic.txt [Michael B.]</span>
<a href="#l2.823"></a><span id="l2.823" class="difflineplus">+- Add -p to mkdir's in Makefile.in [vda]</span>
<a href="#l2.824"></a><span id="l2.824" class="difflineplus">+- Fix configure to properly detect presence or lack of printf functions</span>
<a href="#l2.825"></a><span id="l2.825" class="difflineplus">+- Add AS400 support [Monnerat]</span>
<a href="#l2.826"></a><span id="l2.826" class="difflineplus">+- Add a little Cygwin support [Wilson]</span>
<a href="#l2.827"></a><span id="l2.827" class="difflineplus">+</span>
<a href="#l2.828"></a><span id="l2.828" class="difflineplus">+Changes in 1.2.0.7 (21 September 2003)</span>
<a href="#l2.829"></a><span id="l2.829" class="difflineplus">+- Correct some debug formats in contrib/infback9</span>
<a href="#l2.830"></a><span id="l2.830" class="difflineplus">+- Cast a type in a debug statement in trees.c</span>
<a href="#l2.831"></a><span id="l2.831" class="difflineplus">+- Change search and replace delimiter in configure from % to # [Beebe]</span>
<a href="#l2.832"></a><span id="l2.832" class="difflineplus">+- Update contrib/untgz to 0.2 with various fixes [Truta]</span>
<a href="#l2.833"></a><span id="l2.833" class="difflineplus">+- Add build support for Amiga [Nikl]</span>
<a href="#l2.834"></a><span id="l2.834" class="difflineplus">+- Remove some directories in old that have been updated to 1.2</span>
<a href="#l2.835"></a><span id="l2.835" class="difflineplus">+- Add dylib building for Mac OS X in configure and Makefile.in</span>
<a href="#l2.836"></a><span id="l2.836" class="difflineplus">+- Remove old distribution stuff from Makefile</span>
<a href="#l2.837"></a><span id="l2.837" class="difflineplus">+- Update README to point to DLL_FAQ.txt, and add comment on Mac OS X</span>
<a href="#l2.838"></a><span id="l2.838" class="difflineplus">+- Update links in README</span>
<a href="#l2.839"></a><span id="l2.839" class="difflineplus">+</span>
<a href="#l2.840"></a><span id="l2.840" class="difflineplus">+Changes in 1.2.0.6 (13 September 2003)</span>
<a href="#l2.841"></a><span id="l2.841" class="difflineplus">+- Minor FAQ updates</span>
<a href="#l2.842"></a><span id="l2.842" class="difflineplus">+- Update contrib/minizip to 1.00 [Vollant]</span>
<a href="#l2.843"></a><span id="l2.843" class="difflineplus">+- Remove test of gz functions in example.c when GZ_COMPRESS defined [Truta]</span>
<a href="#l2.844"></a><span id="l2.844" class="difflineplus">+- Update POSTINC comment for 68060 [Nikl]</span>
<a href="#l2.845"></a><span id="l2.845" class="difflineplus">+- Add contrib/infback9 with deflate64 decoding (unsupported)</span>
<a href="#l2.846"></a><span id="l2.846" class="difflineplus">+- For MVS define NO_vsnprintf and undefine FAR [van Burik]</span>
<a href="#l2.847"></a><span id="l2.847" class="difflineplus">+- Add pragma for fdopen on MVS [van Burik]</span>
<a href="#l2.848"></a><span id="l2.848" class="difflineplus">+</span>
<a href="#l2.849"></a><span id="l2.849" class="difflineplus">+Changes in 1.2.0.5 (8 September 2003)</span>
<a href="#l2.850"></a><span id="l2.850" class="difflineplus">+- Add OF to inflateBackEnd() declaration in zlib.h</span>
<a href="#l2.851"></a><span id="l2.851" class="difflineplus">+- Remember start when using gzdopen in the middle of a file</span>
<a href="#l2.852"></a><span id="l2.852" class="difflineplus">+- Use internal off_t counters in gz* functions to properly handle seeks</span>
<a href="#l2.853"></a><span id="l2.853" class="difflineplus">+- Perform more rigorous check for distance-too-far in inffast.c</span>
<a href="#l2.854"></a><span id="l2.854" class="difflineplus">+- Add Z_BLOCK flush option to return from inflate at block boundary</span>
<a href="#l2.855"></a><span id="l2.855" class="difflineplus">+- Set strm-&gt;data_type on return from inflate</span>
<a href="#l2.856"></a><span id="l2.856" class="difflineplus">+    - Indicate bits unused, if at block boundary, and if in last block</span>
<a href="#l2.857"></a><span id="l2.857" class="difflineplus">+- Replace size_t with ptrdiff_t in crc32.c, and check for correct size</span>
<a href="#l2.858"></a><span id="l2.858" class="difflineplus">+- Add condition so old NO_DEFLATE define still works for compatibility</span>
<a href="#l2.859"></a><span id="l2.859" class="difflineplus">+- FAQ update regarding the Windows DLL [Truta]</span>
<a href="#l2.860"></a><span id="l2.860" class="difflineplus">+- INDEX update: add qnx entry, remove aix entry [Truta]</span>
<a href="#l2.861"></a><span id="l2.861" class="difflineplus">+- Install zlib.3 into mandir [Wilson]</span>
<a href="#l2.862"></a><span id="l2.862" class="difflineplus">+- Move contrib/zlib_dll_FAQ.txt to win32/DLL_FAQ.txt; update [Truta]</span>
<a href="#l2.863"></a><span id="l2.863" class="difflineplus">+- Adapt the zlib interface to the new DLL convention guidelines [Truta]</span>
<a href="#l2.864"></a><span id="l2.864" class="difflineplus">+- Introduce ZLIB_WINAPI macro to allow the export of functions using</span>
<a href="#l2.865"></a><span id="l2.865" class="difflineplus">+  the WINAPI calling convention, for Visual Basic [Vollant, Truta]</span>
<a href="#l2.866"></a><span id="l2.866" class="difflineplus">+- Update msdos and win32 scripts and makefiles [Truta]</span>
<a href="#l2.867"></a><span id="l2.867" class="difflineplus">+- Export symbols by name, not by ordinal, in win32/zlib.def [Truta]</span>
<a href="#l2.868"></a><span id="l2.868" class="difflineplus">+- Add contrib/ada [Anisimkov]</span>
<a href="#l2.869"></a><span id="l2.869" class="difflineplus">+- Move asm files from contrib/vstudio/vc70_32 to contrib/asm386 [Truta]</span>
<a href="#l2.870"></a><span id="l2.870" class="difflineplus">+- Rename contrib/asm386 to contrib/masmx86 [Truta, Vollant]</span>
<a href="#l2.871"></a><span id="l2.871" class="difflineplus">+- Add contrib/masm686 [Truta]</span>
<a href="#l2.872"></a><span id="l2.872" class="difflineplus">+- Fix offsets in contrib/inflate86 and contrib/masmx86/inffas32.asm</span>
<a href="#l2.873"></a><span id="l2.873" class="difflineplus">+  [Truta, Vollant]</span>
<a href="#l2.874"></a><span id="l2.874" class="difflineplus">+- Update contrib/delphi; rename to contrib/pascal; add example [Truta]</span>
<a href="#l2.875"></a><span id="l2.875" class="difflineplus">+- Remove contrib/delphi2; add a new contrib/delphi [Truta]</span>
<a href="#l2.876"></a><span id="l2.876" class="difflineplus">+- Avoid inclusion of the nonstandard &lt;memory.h&gt; in contrib/iostream,</span>
<a href="#l2.877"></a><span id="l2.877" class="difflineplus">+  and fix some method prototypes [Truta]</span>
<a href="#l2.878"></a><span id="l2.878" class="difflineplus">+- Fix the ZCR_SEED2 constant to avoid warnings in contrib/minizip</span>
<a href="#l2.879"></a><span id="l2.879" class="difflineplus">+  [Truta]</span>
<a href="#l2.880"></a><span id="l2.880" class="difflineplus">+- Avoid the use of backslash (\) in contrib/minizip [Vollant]</span>
<a href="#l2.881"></a><span id="l2.881" class="difflineplus">+- Fix file time handling in contrib/untgz; update makefiles [Truta]</span>
<a href="#l2.882"></a><span id="l2.882" class="difflineplus">+- Update contrib/vstudio/vc70_32 to comply with the new DLL guidelines</span>
<a href="#l2.883"></a><span id="l2.883" class="difflineplus">+  [Vollant]</span>
<a href="#l2.884"></a><span id="l2.884" class="difflineplus">+- Remove contrib/vstudio/vc15_16 [Vollant]</span>
<a href="#l2.885"></a><span id="l2.885" class="difflineplus">+- Rename contrib/vstudio/vc70_32 to contrib/vstudio/vc7 [Truta]</span>
<a href="#l2.886"></a><span id="l2.886" class="difflineplus">+- Update README.contrib [Truta]</span>
<a href="#l2.887"></a><span id="l2.887" class="difflineplus">+- Invert the assignment order of match_head and s-&gt;prev[...] in</span>
<a href="#l2.888"></a><span id="l2.888" class="difflineplus">+  INSERT_STRING [Truta]</span>
<a href="#l2.889"></a><span id="l2.889" class="difflineplus">+- Compare TOO_FAR with 32767 instead of 32768, to avoid 16-bit warnings</span>
<a href="#l2.890"></a><span id="l2.890" class="difflineplus">+  [Truta]</span>
<a href="#l2.891"></a><span id="l2.891" class="difflineplus">+- Compare function pointers with 0, not with NULL or Z_NULL [Truta]</span>
<a href="#l2.892"></a><span id="l2.892" class="difflineplus">+- Fix prototype of syncsearch in inflate.c [Truta]</span>
<a href="#l2.893"></a><span id="l2.893" class="difflineplus">+- Introduce ASMINF macro to be enabled when using an ASM implementation</span>
<a href="#l2.894"></a><span id="l2.894" class="difflineplus">+  of inflate_fast [Truta]</span>
<a href="#l2.895"></a><span id="l2.895" class="difflineplus">+- Change NO_DEFLATE to NO_GZCOMPRESS [Truta]</span>
<a href="#l2.896"></a><span id="l2.896" class="difflineplus">+- Modify test_gzio in example.c to take a single file name as a</span>
<a href="#l2.897"></a><span id="l2.897" class="difflineplus">+  parameter [Truta]</span>
<a href="#l2.898"></a><span id="l2.898" class="difflineplus">+- Exit the example.c program if gzopen fails [Truta]</span>
<a href="#l2.899"></a><span id="l2.899" class="difflineplus">+- Add type casts around strlen in example.c [Truta]</span>
<a href="#l2.900"></a><span id="l2.900" class="difflineplus">+- Remove casting to sizeof in minigzip.c; give a proper type</span>
<a href="#l2.901"></a><span id="l2.901" class="difflineplus">+  to the variable compared with SUFFIX_LEN [Truta]</span>
<a href="#l2.902"></a><span id="l2.902" class="difflineplus">+- Update definitions of STDC and STDC99 in zconf.h [Truta]</span>
<a href="#l2.903"></a><span id="l2.903" class="difflineplus">+- Synchronize zconf.h with the new Windows DLL interface [Truta]</span>
<a href="#l2.904"></a><span id="l2.904" class="difflineplus">+- Use SYS16BIT instead of __32BIT__ to distinguish between</span>
<a href="#l2.905"></a><span id="l2.905" class="difflineplus">+  16- and 32-bit platforms [Truta]</span>
<a href="#l2.906"></a><span id="l2.906" class="difflineplus">+- Use far memory allocators in small 16-bit memory models for</span>
<a href="#l2.907"></a><span id="l2.907" class="difflineplus">+  Turbo C [Truta]</span>
<a href="#l2.908"></a><span id="l2.908" class="difflineplus">+- Add info about the use of ASMV, ASMINF and ZLIB_WINAPI in</span>
<a href="#l2.909"></a><span id="l2.909" class="difflineplus">+  zlibCompileFlags [Truta]</span>
<a href="#l2.910"></a><span id="l2.910" class="difflineplus">+- Cygwin has vsnprintf [Wilson]</span>
<a href="#l2.911"></a><span id="l2.911" class="difflineplus">+- In Windows16, OS_CODE is 0, as in MSDOS [Truta]</span>
<a href="#l2.912"></a><span id="l2.912" class="difflineplus">+- In Cygwin, OS_CODE is 3 (Unix), not 11 (Windows32) [Wilson]</span>
<a href="#l2.913"></a><span id="l2.913" class="difflineplus">+</span>
<a href="#l2.914"></a><span id="l2.914" class="difflineplus">+Changes in 1.2.0.4 (10 August 2003)</span>
<a href="#l2.915"></a><span id="l2.915" class="difflineplus">+- Minor FAQ updates</span>
<a href="#l2.916"></a><span id="l2.916" class="difflineplus">+- Be more strict when checking inflateInit2's windowBits parameter</span>
<a href="#l2.917"></a><span id="l2.917" class="difflineplus">+- Change NO_GUNZIP compile option to NO_GZIP to cover deflate as well</span>
<a href="#l2.918"></a><span id="l2.918" class="difflineplus">+- Add gzip wrapper option to deflateInit2 using windowBits</span>
<a href="#l2.919"></a><span id="l2.919" class="difflineplus">+- Add updated QNX rule in configure and qnx directory [Bonnefoy]</span>
<a href="#l2.920"></a><span id="l2.920" class="difflineplus">+- Make inflate distance-too-far checks more rigorous</span>
<a href="#l2.921"></a><span id="l2.921" class="difflineplus">+- Clean up FAR usage in inflate</span>
<a href="#l2.922"></a><span id="l2.922" class="difflineplus">+- Add casting to sizeof() in gzio.c and minigzip.c</span>
<a href="#l2.923"></a><span id="l2.923" class="difflineplus">+</span>
<a href="#l2.924"></a><span id="l2.924" class="difflineplus">+Changes in 1.2.0.3 (19 July 2003)</span>
<a href="#l2.925"></a><span id="l2.925" class="difflineplus">+- Fix silly error in gzungetc() implementation [Vollant]</span>
<a href="#l2.926"></a><span id="l2.926" class="difflineplus">+- Update contrib/minizip and contrib/vstudio [Vollant]</span>
<a href="#l2.927"></a><span id="l2.927" class="difflineplus">+- Fix printf format in example.c</span>
<a href="#l2.928"></a><span id="l2.928" class="difflineplus">+- Correct cdecl support in zconf.in.h [Anisimkov]</span>
<a href="#l2.929"></a><span id="l2.929" class="difflineplus">+- Minor FAQ updates</span>
<a href="#l2.930"></a><span id="l2.930" class="difflineplus">+</span>
<a href="#l2.931"></a><span id="l2.931" class="difflineplus">+Changes in 1.2.0.2 (13 July 2003)</span>
<a href="#l2.932"></a><span id="l2.932" class="difflineplus">+- Add ZLIB_VERNUM in zlib.h for numerical preprocessor comparisons</span>
<a href="#l2.933"></a><span id="l2.933" class="difflineplus">+- Attempt to avoid warnings in crc32.c for pointer-int conversion</span>
<a href="#l2.934"></a><span id="l2.934" class="difflineplus">+- Add AIX to configure, remove aix directory [Bakker]</span>
<a href="#l2.935"></a><span id="l2.935" class="difflineplus">+- Add some casts to minigzip.c</span>
<a href="#l2.936"></a><span id="l2.936" class="difflineplus">+- Improve checking after insecure sprintf() or vsprintf() calls</span>
<a href="#l2.937"></a><span id="l2.937" class="difflineplus">+- Remove #elif's from crc32.c</span>
<a href="#l2.938"></a><span id="l2.938" class="difflineplus">+- Change leave label to inf_leave in inflate.c and infback.c to avoid</span>
<a href="#l2.939"></a><span id="l2.939" class="difflineplus">+  library conflicts</span>
<a href="#l2.940"></a><span id="l2.940" class="difflineplus">+- Remove inflate gzip decoding by default--only enable gzip decoding by</span>
<a href="#l2.941"></a><span id="l2.941" class="difflineplus">+  special request for stricter backward compatibility</span>
<a href="#l2.942"></a><span id="l2.942" class="difflineplus">+- Add zlibCompileFlags() function to return compilation information</span>
<a href="#l2.943"></a><span id="l2.943" class="difflineplus">+- More typecasting in deflate.c to avoid warnings</span>
<a href="#l2.944"></a><span id="l2.944" class="difflineplus">+- Remove leading underscore from _Capital #defines [Truta]</span>
<a href="#l2.945"></a><span id="l2.945" class="difflineplus">+- Fix configure to link shared library when testing</span>
<a href="#l2.946"></a><span id="l2.946" class="difflineplus">+- Add some Windows CE target adjustments [Mai]</span>
<a href="#l2.947"></a><span id="l2.947" class="difflineplus">+- Remove #define ZLIB_DLL in zconf.h [Vollant]</span>
<a href="#l2.948"></a><span id="l2.948" class="difflineplus">+- Add zlib.3 [Rodgers]</span>
<a href="#l2.949"></a><span id="l2.949" class="difflineplus">+- Update RFC URL in deflate.c and algorithm.txt [Mai]</span>
<a href="#l2.950"></a><span id="l2.950" class="difflineplus">+- Add zlib_dll_FAQ.txt to contrib [Truta]</span>
<a href="#l2.951"></a><span id="l2.951" class="difflineplus">+- Add UL to some constants [Truta]</span>
<a href="#l2.952"></a><span id="l2.952" class="difflineplus">+- Update minizip and vstudio [Vollant]</span>
<a href="#l2.953"></a><span id="l2.953" class="difflineplus">+- Remove vestigial NEED_DUMMY_RETURN from zconf.in.h</span>
<a href="#l2.954"></a><span id="l2.954" class="difflineplus">+- Expand use of NO_DUMMY_DECL to avoid all dummy structures</span>
<a href="#l2.955"></a><span id="l2.955" class="difflineplus">+- Added iostream3 to contrib [Schwardt]</span>
<a href="#l2.956"></a><span id="l2.956" class="difflineplus">+- Replace rewind() with fseek() for WinCE [Truta]</span>
<a href="#l2.957"></a><span id="l2.957" class="difflineplus">+- Improve setting of zlib format compression level flags</span>
<a href="#l2.958"></a><span id="l2.958" class="difflineplus">+    - Report 0 for huffman and rle strategies and for level == 0 or 1</span>
<a href="#l2.959"></a><span id="l2.959" class="difflineplus">+    - Report 2 only for level == 6</span>
<a href="#l2.960"></a><span id="l2.960" class="difflineplus">+- Only deal with 64K limit when necessary at compile time [Truta]</span>
<a href="#l2.961"></a><span id="l2.961" class="difflineplus">+- Allow TOO_FAR check to be turned off at compile time [Truta]</span>
<a href="#l2.962"></a><span id="l2.962" class="difflineplus">+- Add gzclearerr() function [Souza]</span>
<a href="#l2.963"></a><span id="l2.963" class="difflineplus">+- Add gzungetc() function</span>
<a href="#l2.964"></a><span id="l2.964" class="difflineplus">+</span>
<a href="#l2.965"></a><span id="l2.965" class="difflineplus">+Changes in 1.2.0.1 (17 March 2003)</span>
<a href="#l2.966"></a><span id="l2.966" class="difflineplus">+- Add Z_RLE strategy for run-length encoding [Truta]</span>
<a href="#l2.967"></a><span id="l2.967" class="difflineplus">+    - When Z_RLE requested, restrict matches to distance one</span>
<a href="#l2.968"></a><span id="l2.968" class="difflineplus">+    - Update zlib.h, minigzip.c, gzopen(), gzdopen() for Z_RLE</span>
<a href="#l2.969"></a><span id="l2.969" class="difflineplus">+- Correct FASTEST compilation to allow level == 0</span>
<a href="#l2.970"></a><span id="l2.970" class="difflineplus">+- Clean up what gets compiled for FASTEST</span>
<a href="#l2.971"></a><span id="l2.971" class="difflineplus">+- Incorporate changes to zconf.in.h [Vollant]</span>
<a href="#l2.972"></a><span id="l2.972" class="difflineplus">+    - Refine detection of Turbo C need for dummy returns</span>
<a href="#l2.973"></a><span id="l2.973" class="difflineplus">+    - Refine ZLIB_DLL compilation</span>
<a href="#l2.974"></a><span id="l2.974" class="difflineplus">+    - Include additional header file on VMS for off_t typedef</span>
<a href="#l2.975"></a><span id="l2.975" class="difflineplus">+- Try to use _vsnprintf where it supplants vsprintf [Vollant]</span>
<a href="#l2.976"></a><span id="l2.976" class="difflineplus">+- Add some casts in inffast.c</span>
<a href="#l2.977"></a><span id="l2.977" class="difflineplus">+- Enchance comments in zlib.h on what happens if gzprintf() tries to</span>
<a href="#l2.978"></a><span id="l2.978" class="difflineplus">+  write more than 4095 bytes before compression</span>
<a href="#l2.979"></a><span id="l2.979" class="difflineplus">+- Remove unused state from inflateBackEnd()</span>
<a href="#l2.980"></a><span id="l2.980" class="difflineplus">+- Remove exit(0) from minigzip.c, example.c</span>
<a href="#l2.981"></a><span id="l2.981" class="difflineplus">+- Get rid of all those darn tabs</span>
<a href="#l2.982"></a><span id="l2.982" class="difflineplus">+- Add &quot;check&quot; target to Makefile.in that does the same thing as &quot;test&quot;</span>
<a href="#l2.983"></a><span id="l2.983" class="difflineplus">+- Add &quot;mostlyclean&quot; and &quot;maintainer-clean&quot; targets to Makefile.in</span>
<a href="#l2.984"></a><span id="l2.984" class="difflineplus">+- Update contrib/inflate86 [Anderson]</span>
<a href="#l2.985"></a><span id="l2.985" class="difflineplus">+- Update contrib/testzlib, contrib/vstudio, contrib/minizip [Vollant]</span>
<a href="#l2.986"></a><span id="l2.986" class="difflineplus">+- Add msdos and win32 directories with makefiles [Truta]</span>
<a href="#l2.987"></a><span id="l2.987" class="difflineplus">+- More additions and improvements to the FAQ</span>
<a href="#l2.988"></a><span id="l2.988" class="difflineplus">+</span>
<a href="#l2.989"></a><span id="l2.989" class="difflineplus">+Changes in 1.2.0 (9 March 2003)</span>
<a href="#l2.990"></a><span id="l2.990" class="difflineplus">+- New and improved inflate code</span>
<a href="#l2.991"></a><span id="l2.991" class="difflineplus">+    - About 20% faster</span>
<a href="#l2.992"></a><span id="l2.992" class="difflineplus">+    - Does not allocate 32K window unless and until needed</span>
<a href="#l2.993"></a><span id="l2.993" class="difflineplus">+    - Automatically detects and decompresses gzip streams</span>
<a href="#l2.994"></a><span id="l2.994" class="difflineplus">+    - Raw inflate no longer needs an extra dummy byte at end</span>
<a href="#l2.995"></a><span id="l2.995" class="difflineplus">+    - Added inflateBack functions using a callback interface--even faster</span>
<a href="#l2.996"></a><span id="l2.996" class="difflineplus">+      than inflate, useful for file utilities (gzip, zip)</span>
<a href="#l2.997"></a><span id="l2.997" class="difflineplus">+    - Added inflateCopy() function to record state for random access on</span>
<a href="#l2.998"></a><span id="l2.998" class="difflineplus">+      externally generated deflate streams (e.g. in gzip files)</span>
<a href="#l2.999"></a><span id="l2.999" class="difflineplus">+    - More readable code (I hope)</span>
<a href="#l2.1000"></a><span id="l2.1000" class="difflineplus">+- New and improved crc32()</span>
<a href="#l2.1001"></a><span id="l2.1001" class="difflineplus">+    - About 50% faster, thanks to suggestions from Rodney Brown</span>
<a href="#l2.1002"></a><span id="l2.1002" class="difflineplus">+- Add deflateBound() and compressBound() functions</span>
<a href="#l2.1003"></a><span id="l2.1003" class="difflineplus">+- Fix memory leak in deflateInit2()</span>
<a href="#l2.1004"></a><span id="l2.1004" class="difflineplus">+- Permit setting dictionary for raw deflate (for parallel deflate)</span>
<a href="#l2.1005"></a><span id="l2.1005" class="difflineplus">+- Fix const declaration for gzwrite()</span>
<a href="#l2.1006"></a><span id="l2.1006" class="difflineplus">+- Check for some malloc() failures in gzio.c</span>
<a href="#l2.1007"></a><span id="l2.1007" class="difflineplus">+- Fix bug in gzopen() on single-byte file 0x1f</span>
<a href="#l2.1008"></a><span id="l2.1008" class="difflineplus">+- Fix bug in gzread() on concatenated file with 0x1f at end of buffer</span>
<a href="#l2.1009"></a><span id="l2.1009" class="difflineplus">+  and next buffer doesn't start with 0x8b</span>
<a href="#l2.1010"></a><span id="l2.1010" class="difflineplus">+- Fix uncompress() to return Z_DATA_ERROR on truncated input</span>
<a href="#l2.1011"></a><span id="l2.1011" class="difflineplus">+- Free memory at end of example.c</span>
<a href="#l2.1012"></a><span id="l2.1012" class="difflineplus">+- Remove MAX #define in trees.c (conflicted with some libraries)</span>
<a href="#l2.1013"></a><span id="l2.1013" class="difflineplus">+- Fix static const's in deflate.c, gzio.c, and zutil.[ch]</span>
<a href="#l2.1014"></a><span id="l2.1014" class="difflineplus">+- Declare malloc() and free() in gzio.c if STDC not defined</span>
<a href="#l2.1015"></a><span id="l2.1015" class="difflineplus">+- Use malloc() instead of calloc() in zutil.c if int big enough</span>
<a href="#l2.1016"></a><span id="l2.1016" class="difflineplus">+- Define STDC for AIX</span>
<a href="#l2.1017"></a><span id="l2.1017" class="difflineplus">+- Add aix/ with approach for compiling shared library on AIX</span>
<a href="#l2.1018"></a><span id="l2.1018" class="difflineplus">+- Add HP-UX support for shared libraries in configure</span>
<a href="#l2.1019"></a><span id="l2.1019" class="difflineplus">+- Add OpenUNIX support for shared libraries in configure</span>
<a href="#l2.1020"></a><span id="l2.1020" class="difflineplus">+- Use $cc instead of gcc to build shared library</span>
<a href="#l2.1021"></a><span id="l2.1021" class="difflineplus">+- Make prefix directory if needed when installing</span>
<a href="#l2.1022"></a><span id="l2.1022" class="difflineplus">+- Correct Macintosh avoidance of typedef Byte in zconf.h</span>
<a href="#l2.1023"></a><span id="l2.1023" class="difflineplus">+- Correct Turbo C memory allocation when under Linux</span>
<a href="#l2.1024"></a><span id="l2.1024" class="difflineplus">+- Use libz.a instead of -lz in Makefile (assure use of compiled library)</span>
<a href="#l2.1025"></a><span id="l2.1025" class="difflineplus">+- Update configure to check for snprintf or vsnprintf functions and their</span>
<a href="#l2.1026"></a><span id="l2.1026" class="difflineplus">+  return value, warn during make if using an insecure function</span>
<a href="#l2.1027"></a><span id="l2.1027" class="difflineplus">+- Fix configure problem with compile-time knowledge of HAVE_UNISTD_H that</span>
<a href="#l2.1028"></a><span id="l2.1028" class="difflineplus">+  is lost when library is used--resolution is to build new zconf.h</span>
<a href="#l2.1029"></a><span id="l2.1029" class="difflineplus">+- Documentation improvements (in zlib.h):</span>
<a href="#l2.1030"></a><span id="l2.1030" class="difflineplus">+    - Document raw deflate and inflate</span>
<a href="#l2.1031"></a><span id="l2.1031" class="difflineplus">+    - Update RFCs URL</span>
<a href="#l2.1032"></a><span id="l2.1032" class="difflineplus">+    - Point out that zlib and gzip formats are different</span>
<a href="#l2.1033"></a><span id="l2.1033" class="difflineplus">+    - Note that Z_BUF_ERROR is not fatal</span>
<a href="#l2.1034"></a><span id="l2.1034" class="difflineplus">+    - Document string limit for gzprintf() and possible buffer overflow</span>
<a href="#l2.1035"></a><span id="l2.1035" class="difflineplus">+    - Note requirement on avail_out when flushing</span>
<a href="#l2.1036"></a><span id="l2.1036" class="difflineplus">+    - Note permitted values of flush parameter of inflate()</span>
<a href="#l2.1037"></a><span id="l2.1037" class="difflineplus">+- Add some FAQs (and even answers) to the FAQ</span>
<a href="#l2.1038"></a><span id="l2.1038" class="difflineplus">+- Add contrib/inflate86/ for x86 faster inflate</span>
<a href="#l2.1039"></a><span id="l2.1039" class="difflineplus">+- Add contrib/blast/ for PKWare Data Compression Library decompression</span>
<a href="#l2.1040"></a><span id="l2.1040" class="difflineplus">+- Add contrib/puff/ simple inflate for deflate format description</span>
<a href="#l2.1041"></a><span id="l2.1041" class="difflineplus">+</span>
<a href="#l2.1042"></a><span id="l2.1042" class="difflineplus">+Changes in 1.1.4 (11 March 2002)</span>
<a href="#l2.1043"></a><span id="l2.1043" class="difflineplus">+- ZFREE was repeated on same allocation on some error conditions.</span>
<a href="#l2.1044"></a><span id="l2.1044" class="difflineplus">+  This creates a security problem described in</span>
<a href="#l2.1045"></a><span id="l2.1045" class="difflineplus">+  http://www.zlib.org/advisory-2002-03-11.txt</span>
<a href="#l2.1046"></a><span id="l2.1046" class="difflineplus">+- Returned incorrect error (Z_MEM_ERROR) on some invalid data</span>
<a href="#l2.1047"></a><span id="l2.1047" class="difflineplus">+- Avoid accesses before window for invalid distances with inflate window</span>
<a href="#l2.1048"></a><span id="l2.1048" class="difflineplus">+  less than 32K.</span>
<a href="#l2.1049"></a><span id="l2.1049" class="difflineplus">+- force windowBits &gt; 8 to avoid a bug in the encoder for a window size</span>
<a href="#l2.1050"></a><span id="l2.1050" class="difflineplus">+  of 256 bytes. (A complete fix will be available in 1.1.5).</span>
<a href="#l2.1051"></a><span id="l2.1051" class="difflineplus">+</span>
<a href="#l2.1052"></a><span id="l2.1052" class="difflineplus">+Changes in 1.1.3 (9 July 1998)</span>
<a href="#l2.1053"></a><span id="l2.1053" class="difflineplus">+- fix &quot;an inflate input buffer bug that shows up on rare but persistent</span>
<a href="#l2.1054"></a><span id="l2.1054" class="difflineplus">+  occasions&quot; (Mark)</span>
<a href="#l2.1055"></a><span id="l2.1055" class="difflineplus">+- fix gzread and gztell for concatenated .gz files (Didier Le Botlan)</span>
<a href="#l2.1056"></a><span id="l2.1056" class="difflineplus">+- fix gzseek(..., SEEK_SET) in write mode</span>
<a href="#l2.1057"></a><span id="l2.1057" class="difflineplus">+- fix crc check after a gzeek (Frank Faubert)</span>
<a href="#l2.1058"></a><span id="l2.1058" class="difflineplus">+- fix miniunzip when the last entry in a zip file is itself a zip file</span>
<a href="#l2.1059"></a><span id="l2.1059" class="difflineplus">+  (J Lillge)</span>
<a href="#l2.1060"></a><span id="l2.1060" class="difflineplus">+- add contrib/asm586 and contrib/asm686 (Brian Raiter)</span>
<a href="#l2.1061"></a><span id="l2.1061" class="difflineplus">+  See http://www.muppetlabs.com/~breadbox/software/assembly.html</span>
<a href="#l2.1062"></a><span id="l2.1062" class="difflineplus">+- add support for Delphi 3 in contrib/delphi (Bob Dellaca)</span>
<a href="#l2.1063"></a><span id="l2.1063" class="difflineplus">+- add support for C++Builder 3 and Delphi 3 in contrib/delphi2 (Davide Moretti)</span>
<a href="#l2.1064"></a><span id="l2.1064" class="difflineplus">+- do not exit prematurely in untgz if 0 at start of block (Magnus Holmgren)</span>
<a href="#l2.1065"></a><span id="l2.1065" class="difflineplus">+- use macro EXTERN instead of extern to support DLL for BeOS (Sander Stoks)</span>
<a href="#l2.1066"></a><span id="l2.1066" class="difflineplus">+- added a FAQ file</span>
<a href="#l2.1067"></a><span id="l2.1067" class="difflineplus">+</span>
<a href="#l2.1068"></a><span id="l2.1068" class="difflineplus">+- Support gzdopen on Mac with Metrowerks (Jason Linhart)</span>
<a href="#l2.1069"></a><span id="l2.1069" class="difflineplus">+- Do not redefine Byte on Mac (Brad Pettit &amp; Jason Linhart)</span>
<a href="#l2.1070"></a><span id="l2.1070" class="difflineplus">+- define SEEK_END too if SEEK_SET is not defined (Albert Chin-A-Young)</span>
<a href="#l2.1071"></a><span id="l2.1071" class="difflineplus">+- avoid some warnings with Borland C (Tom Tanner)</span>
<a href="#l2.1072"></a><span id="l2.1072" class="difflineplus">+- fix a problem in contrib/minizip/zip.c for 16-bit MSDOS (Gilles Vollant)</span>
<a href="#l2.1073"></a><span id="l2.1073" class="difflineplus">+- emulate utime() for WIN32 in contrib/untgz  (Gilles Vollant)</span>
<a href="#l2.1074"></a><span id="l2.1074" class="difflineplus">+- allow several arguments to configure (Tim Mooney, Frodo Looijaard)</span>
<a href="#l2.1075"></a><span id="l2.1075" class="difflineplus">+- use libdir and includedir in Makefile.in (Tim Mooney)</span>
<a href="#l2.1076"></a><span id="l2.1076" class="difflineplus">+- support shared libraries on OSF1 V4 (Tim Mooney)</span>
<a href="#l2.1077"></a><span id="l2.1077" class="difflineplus">+- remove so_locations in &quot;make clean&quot;  (Tim Mooney)</span>
<a href="#l2.1078"></a><span id="l2.1078" class="difflineplus">+- fix maketree.c compilation error (Glenn, Mark)</span>
<a href="#l2.1079"></a><span id="l2.1079" class="difflineplus">+- Python interface to zlib now in Python 1.5 (Jeremy Hylton)</span>
<a href="#l2.1080"></a><span id="l2.1080" class="difflineplus">+- new Makefile.riscos (Rich Walker)</span>
<a href="#l2.1081"></a><span id="l2.1081" class="difflineplus">+- initialize static descriptors in trees.c for embedded targets (Nick Smith)</span>
<a href="#l2.1082"></a><span id="l2.1082" class="difflineplus">+- use &quot;foo-gz&quot; in example.c for RISCOS and VMS (Nick Smith)</span>
<a href="#l2.1083"></a><span id="l2.1083" class="difflineplus">+- add the OS/2 files in Makefile.in too (Andrew Zabolotny)</span>
<a href="#l2.1084"></a><span id="l2.1084" class="difflineplus">+- fix fdopen and halloc macros for Microsoft C 6.0 (Tom Lane)</span>
<a href="#l2.1085"></a><span id="l2.1085" class="difflineplus">+- fix maketree.c to allow clean compilation of inffixed.h (Mark)</span>
<a href="#l2.1086"></a><span id="l2.1086" class="difflineplus">+- fix parameter check in deflateCopy (Gunther Nikl)</span>
<a href="#l2.1087"></a><span id="l2.1087" class="difflineplus">+- cleanup trees.c, use compressed_len only in debug mode (Christian Spieler)</span>
<a href="#l2.1088"></a><span id="l2.1088" class="difflineplus">+- Many portability patches by Christian Spieler:</span>
<a href="#l2.1089"></a><span id="l2.1089" class="difflineplus">+  . zutil.c, zutil.h: added &quot;const&quot; for zmem*</span>
<a href="#l2.1090"></a><span id="l2.1090" class="difflineplus">+  . Make_vms.com: fixed some typos</span>
<a href="#l2.1091"></a><span id="l2.1091" class="difflineplus">+  . Make_vms.com: msdos/Makefile.*: removed zutil.h from some dependency lists</span>
<a href="#l2.1092"></a><span id="l2.1092" class="difflineplus">+  . msdos/Makefile.msc: remove &quot;default rtl link library&quot; info from obj files</span>
<a href="#l2.1093"></a><span id="l2.1093" class="difflineplus">+  . msdos/Makefile.*: use model-dependent name for the built zlib library</span>
<a href="#l2.1094"></a><span id="l2.1094" class="difflineplus">+  . msdos/Makefile.emx, nt/Makefile.emx, nt/Makefile.gcc:</span>
<a href="#l2.1095"></a><span id="l2.1095" class="difflineplus">+     new makefiles, for emx (DOS/OS2), emx&amp;rsxnt and mingw32 (Windows 9x / NT)</span>
<a href="#l2.1096"></a><span id="l2.1096" class="difflineplus">+- use define instead of typedef for Bytef also for MSC small/medium (Tom Lane)</span>
<a href="#l2.1097"></a><span id="l2.1097" class="difflineplus">+- replace __far with _far for better portability (Christian Spieler, Tom Lane)</span>
<a href="#l2.1098"></a><span id="l2.1098" class="difflineplus">+- fix test for errno.h in configure (Tim Newsham)</span>
<a href="#l2.1099"></a><span id="l2.1099" class="difflineplus">+</span>
<a href="#l2.1100"></a><span id="l2.1100" class="difflineplus">+Changes in 1.1.2 (19 March 98)</span>
<a href="#l2.1101"></a><span id="l2.1101" class="difflineplus">+- added contrib/minzip, mini zip and unzip based on zlib (Gilles Vollant)</span>
<a href="#l2.1102"></a><span id="l2.1102" class="difflineplus">+  See http://www.winimage.com/zLibDll/unzip.html</span>
<a href="#l2.1103"></a><span id="l2.1103" class="difflineplus">+- preinitialize the inflate tables for fixed codes, to make the code</span>
<a href="#l2.1104"></a><span id="l2.1104" class="difflineplus">+  completely thread safe (Mark)</span>
<a href="#l2.1105"></a><span id="l2.1105" class="difflineplus">+- some simplifications and slight speed-up to the inflate code (Mark)</span>
<a href="#l2.1106"></a><span id="l2.1106" class="difflineplus">+- fix gzeof on non-compressed files (Allan Schrum)</span>
<a href="#l2.1107"></a><span id="l2.1107" class="difflineplus">+- add -std1 option in configure for OSF1 to fix gzprintf (Martin Mokrejs)</span>
<a href="#l2.1108"></a><span id="l2.1108" class="difflineplus">+- use default value of 4K for Z_BUFSIZE for 16-bit MSDOS (Tim Wegner + Glenn)</span>
<a href="#l2.1109"></a><span id="l2.1109" class="difflineplus">+- added os2/Makefile.def and os2/zlib.def (Andrew Zabolotny)</span>
<a href="#l2.1110"></a><span id="l2.1110" class="difflineplus">+- add shared lib support for UNIX_SV4.2MP (MATSUURA Takanori)</span>
<a href="#l2.1111"></a><span id="l2.1111" class="difflineplus">+- do not wrap extern &quot;C&quot; around system includes (Tom Lane)</span>
<a href="#l2.1112"></a><span id="l2.1112" class="difflineplus">+- mention zlib binding for TCL in README (Andreas Kupries)</span>
<a href="#l2.1113"></a><span id="l2.1113" class="difflineplus">+- added amiga/Makefile.pup for Amiga powerUP SAS/C PPC (Andreas Kleinert)</span>
<a href="#l2.1114"></a><span id="l2.1114" class="difflineplus">+- allow &quot;make install prefix=...&quot; even after configure (Glenn Randers-Pehrson)</span>
<a href="#l2.1115"></a><span id="l2.1115" class="difflineplus">+- allow &quot;configure --prefix $HOME&quot; (Tim Mooney)</span>
<a href="#l2.1116"></a><span id="l2.1116" class="difflineplus">+- remove warnings in example.c and gzio.c (Glenn Randers-Pehrson)</span>
<a href="#l2.1117"></a><span id="l2.1117" class="difflineplus">+- move Makefile.sas to amiga/Makefile.sas</span>
<a href="#l2.1118"></a><span id="l2.1118" class="difflineplus">+</span>
<a href="#l2.1119"></a><span id="l2.1119" class="difflineplus">+Changes in 1.1.1 (27 Feb 98)</span>
<a href="#l2.1120"></a><span id="l2.1120" class="difflineplus">+- fix macros _tr_tally_* in deflate.h for debug mode  (Glenn Randers-Pehrson)</span>
<a href="#l2.1121"></a><span id="l2.1121" class="difflineplus">+- remove block truncation heuristic which had very marginal effect for zlib</span>
<a href="#l2.1122"></a><span id="l2.1122" class="difflineplus">+  (smaller lit_bufsize than in gzip 1.2.4) and degraded a little the</span>
<a href="#l2.1123"></a><span id="l2.1123" class="difflineplus">+  compression ratio on some files. This also allows inlining _tr_tally for</span>
<a href="#l2.1124"></a><span id="l2.1124" class="difflineplus">+  matches in deflate_slow.</span>
<a href="#l2.1125"></a><span id="l2.1125" class="difflineplus">+- added msdos/Makefile.w32 for WIN32 Microsoft Visual C++ (Bob Frazier)</span>
<a href="#l2.1126"></a><span id="l2.1126" class="difflineplus">+</span>
<a href="#l2.1127"></a><span id="l2.1127" class="difflineplus">+Changes in 1.1.0 (24 Feb 98)</span>
<a href="#l2.1128"></a><span id="l2.1128" class="difflineplus">+- do not return STREAM_END prematurely in inflate (John Bowler)</span>
<a href="#l2.1129"></a><span id="l2.1129" class="difflineplus">+- revert to the zlib 1.0.8 inflate to avoid the gcc 2.8.0 bug (Jeremy Buhler)</span>
<a href="#l2.1130"></a><span id="l2.1130" class="difflineplus">+- compile with -DFASTEST to get compression code optimized for speed only</span>
<a href="#l2.1131"></a><span id="l2.1131" class="difflineplus">+- in minigzip, try mmap'ing the input file first (Miguel Albrecht)</span>
<a href="#l2.1132"></a><span id="l2.1132" class="difflineplus">+- increase size of I/O buffers in minigzip.c and gzio.c (not a big gain</span>
<a href="#l2.1133"></a><span id="l2.1133" class="difflineplus">+  on Sun but significant on HP)</span>
<a href="#l2.1134"></a><span id="l2.1134" class="difflineplus">+</span>
<a href="#l2.1135"></a><span id="l2.1135" class="difflineplus">+- add a pointer to experimental unzip library in README (Gilles Vollant)</span>
<a href="#l2.1136"></a><span id="l2.1136" class="difflineplus">+- initialize variable gcc in configure (Chris Herborth)</span>
<a href="#l2.1137"></a><span id="l2.1137" class="difflineplus">+</span>
<a href="#l2.1138"></a><span id="l2.1138" class="difflineplus">+Changes in 1.0.9 (17 Feb 1998)</span>
<a href="#l2.1139"></a><span id="l2.1139" class="difflineplus">+- added gzputs and gzgets functions</span>
<a href="#l2.1140"></a><span id="l2.1140" class="difflineplus">+- do not clear eof flag in gzseek (Mark Diekhans)</span>
<a href="#l2.1141"></a><span id="l2.1141" class="difflineplus">+- fix gzseek for files in transparent mode (Mark Diekhans)</span>
<a href="#l2.1142"></a><span id="l2.1142" class="difflineplus">+- do not assume that vsprintf returns the number of bytes written (Jens Krinke)</span>
<a href="#l2.1143"></a><span id="l2.1143" class="difflineplus">+- replace EXPORT with ZEXPORT to avoid conflict with other programs</span>
<a href="#l2.1144"></a><span id="l2.1144" class="difflineplus">+- added compress2 in zconf.h, zlib.def, zlib.dnt</span>
<a href="#l2.1145"></a><span id="l2.1145" class="difflineplus">+- new asm code from Gilles Vollant in contrib/asm386</span>
<a href="#l2.1146"></a><span id="l2.1146" class="difflineplus">+- simplify the inflate code (Mark):</span>
<a href="#l2.1147"></a><span id="l2.1147" class="difflineplus">+ . Replace ZALLOC's in huft_build() with single ZALLOC in inflate_blocks_new()</span>
<a href="#l2.1148"></a><span id="l2.1148" class="difflineplus">+ . ZALLOC the length list in inflate_trees_fixed() instead of using stack</span>
<a href="#l2.1149"></a><span id="l2.1149" class="difflineplus">+ . ZALLOC the value area for huft_build() instead of using stack</span>
<a href="#l2.1150"></a><span id="l2.1150" class="difflineplus">+ . Simplify Z_FINISH check in inflate()</span>
<a href="#l2.1151"></a><span id="l2.1151" class="difflineplus">+</span>
<a href="#l2.1152"></a><span id="l2.1152" class="difflineplus">+- Avoid gcc 2.8.0 comparison bug a little differently than zlib 1.0.8</span>
<a href="#l2.1153"></a><span id="l2.1153" class="difflineplus">+- in inftrees.c, avoid cc -O bug on HP (Farshid Elahi)</span>
<a href="#l2.1154"></a><span id="l2.1154" class="difflineplus">+- in zconf.h move the ZLIB_DLL stuff earlier to avoid problems with</span>
<a href="#l2.1155"></a><span id="l2.1155" class="difflineplus">+  the declaration of FAR (Gilles VOllant)</span>
<a href="#l2.1156"></a><span id="l2.1156" class="difflineplus">+- install libz.so* with mode 755 (executable) instead of 644 (Marc Lehmann)</span>
<a href="#l2.1157"></a><span id="l2.1157" class="difflineplus">+- read_buf buf parameter of type Bytef* instead of charf*</span>
<a href="#l2.1158"></a><span id="l2.1158" class="difflineplus">+- zmemcpy parameters are of type Bytef*, not charf* (Joseph Strout)</span>
<a href="#l2.1159"></a><span id="l2.1159" class="difflineplus">+- do not redeclare unlink in minigzip.c for WIN32 (John Bowler)</span>
<a href="#l2.1160"></a><span id="l2.1160" class="difflineplus">+- fix check for presence of directories in &quot;make install&quot; (Ian Willis)</span>
<a href="#l2.1161"></a><span id="l2.1161" class="difflineplus">+</span>
<a href="#l2.1162"></a><span id="l2.1162" class="difflineplus">+Changes in 1.0.8 (27 Jan 1998)</span>
<a href="#l2.1163"></a><span id="l2.1163" class="difflineplus">+- fixed offsets in contrib/asm386/gvmat32.asm (Gilles Vollant)</span>
<a href="#l2.1164"></a><span id="l2.1164" class="difflineplus">+- fix gzgetc and gzputc for big endian systems (Markus Oberhumer)</span>
<a href="#l2.1165"></a><span id="l2.1165" class="difflineplus">+- added compress2() to allow setting the compression level</span>
<a href="#l2.1166"></a><span id="l2.1166" class="difflineplus">+- include sys/types.h to get off_t on some systems (Marc Lehmann &amp; QingLong)</span>
<a href="#l2.1167"></a><span id="l2.1167" class="difflineplus">+- use constant arrays for the static trees in trees.c instead of computing</span>
<a href="#l2.1168"></a><span id="l2.1168" class="difflineplus">+  them at run time (thanks to Ken Raeburn for this suggestion). To create</span>
<a href="#l2.1169"></a><span id="l2.1169" class="difflineplus">+  trees.h, compile with GEN_TREES_H and run &quot;make test&quot;.</span>
<a href="#l2.1170"></a><span id="l2.1170" class="difflineplus">+- check return code of example in &quot;make test&quot; and display result</span>
<a href="#l2.1171"></a><span id="l2.1171" class="difflineplus">+- pass minigzip command line options to file_compress</span>
<a href="#l2.1172"></a><span id="l2.1172" class="difflineplus">+- simplifying code of inflateSync to avoid gcc 2.8 bug</span>
<a href="#l2.1173"></a><span id="l2.1173" class="difflineplus">+</span>
<a href="#l2.1174"></a><span id="l2.1174" class="difflineplus">+- support CC=&quot;gcc -Wall&quot; in configure -s (QingLong)</span>
<a href="#l2.1175"></a><span id="l2.1175" class="difflineplus">+- avoid a flush caused by ftell in gzopen for write mode (Ken Raeburn)</span>
<a href="#l2.1176"></a><span id="l2.1176" class="difflineplus">+- fix test for shared library support to avoid compiler warnings</span>
<a href="#l2.1177"></a><span id="l2.1177" class="difflineplus">+- zlib.lib -&gt; zlib.dll in msdos/zlib.rc (Gilles Vollant)</span>
<a href="#l2.1178"></a><span id="l2.1178" class="difflineplus">+- check for TARGET_OS_MAC in addition to MACOS (Brad Pettit)</span>
<a href="#l2.1179"></a><span id="l2.1179" class="difflineplus">+- do not use fdopen for Metrowerks on Mac (Brad Pettit))</span>
<a href="#l2.1180"></a><span id="l2.1180" class="difflineplus">+- add checks for gzputc and gzputc in example.c</span>
<a href="#l2.1181"></a><span id="l2.1181" class="difflineplus">+- avoid warnings in gzio.c and deflate.c (Andreas Kleinert)</span>
<a href="#l2.1182"></a><span id="l2.1182" class="difflineplus">+- use const for the CRC table (Ken Raeburn)</span>
<a href="#l2.1183"></a><span id="l2.1183" class="difflineplus">+- fixed &quot;make uninstall&quot; for shared libraries</span>
<a href="#l2.1184"></a><span id="l2.1184" class="difflineplus">+- use Tracev instead of Trace in infblock.c</span>
<a href="#l2.1185"></a><span id="l2.1185" class="difflineplus">+- in example.c use correct compressed length for test_sync</span>
<a href="#l2.1186"></a><span id="l2.1186" class="difflineplus">+- suppress +vnocompatwarnings in configure for HPUX (not always supported)</span>
<a href="#l2.1187"></a><span id="l2.1187" class="difflineplus">+</span>
<a href="#l2.1188"></a><span id="l2.1188" class="difflineplus">+Changes in 1.0.7 (20 Jan 1998)</span>
<a href="#l2.1189"></a><span id="l2.1189" class="difflineplus">+- fix gzseek which was broken in write mode</span>
<a href="#l2.1190"></a><span id="l2.1190" class="difflineplus">+- return error for gzseek to negative absolute position</span>
<a href="#l2.1191"></a><span id="l2.1191" class="difflineplus">+- fix configure for Linux (Chun-Chung Chen)</span>
<a href="#l2.1192"></a><span id="l2.1192" class="difflineplus">+- increase stack space for MSC (Tim Wegner)</span>
<a href="#l2.1193"></a><span id="l2.1193" class="difflineplus">+- get_crc_table and inflateSyncPoint are EXPORTed (Gilles Vollant)</span>
<a href="#l2.1194"></a><span id="l2.1194" class="difflineplus">+- define EXPORTVA for gzprintf (Gilles Vollant)</span>
<a href="#l2.1195"></a><span id="l2.1195" class="difflineplus">+- added man page zlib.3 (Rick Rodgers)</span>
<a href="#l2.1196"></a><span id="l2.1196" class="difflineplus">+- for contrib/untgz, fix makedir() and improve Makefile</span>
<a href="#l2.1197"></a><span id="l2.1197" class="difflineplus">+</span>
<a href="#l2.1198"></a><span id="l2.1198" class="difflineplus">+- check gzseek in write mode in example.c</span>
<a href="#l2.1199"></a><span id="l2.1199" class="difflineplus">+- allocate extra buffer for seeks only if gzseek is actually called</span>
<a href="#l2.1200"></a><span id="l2.1200" class="difflineplus">+- avoid signed/unsigned comparisons (Tim Wegner, Gilles Vollant)</span>
<a href="#l2.1201"></a><span id="l2.1201" class="difflineplus">+- add inflateSyncPoint in zconf.h</span>
<a href="#l2.1202"></a><span id="l2.1202" class="difflineplus">+- fix list of exported functions in nt/zlib.dnt and mdsos/zlib.def</span>
<a href="#l2.1203"></a><span id="l2.1203" class="difflineplus">+</span>
<a href="#l2.1204"></a><span id="l2.1204" class="difflineplus">+Changes in 1.0.6 (19 Jan 1998)</span>
<a href="#l2.1205"></a><span id="l2.1205" class="difflineplus">+- add functions gzprintf, gzputc, gzgetc, gztell, gzeof, gzseek, gzrewind and</span>
<a href="#l2.1206"></a><span id="l2.1206" class="difflineplus">+  gzsetparams (thanks to Roland Giersig and Kevin Ruland for some of this code)</span>
<a href="#l2.1207"></a><span id="l2.1207" class="difflineplus">+- Fix a deflate bug occurring only with compression level 0 (thanks to</span>
<a href="#l2.1208"></a><span id="l2.1208" class="difflineplus">+  Andy Buckler for finding this one).</span>
<a href="#l2.1209"></a><span id="l2.1209" class="difflineplus">+- In minigzip, pass transparently also the first byte for .Z files.</span>
<a href="#l2.1210"></a><span id="l2.1210" class="difflineplus">+- return Z_BUF_ERROR instead of Z_OK if output buffer full in uncompress()</span>
<a href="#l2.1211"></a><span id="l2.1211" class="difflineplus">+- check Z_FINISH in inflate (thanks to Marc Schluper)</span>
<a href="#l2.1212"></a><span id="l2.1212" class="difflineplus">+- Implement deflateCopy (thanks to Adam Costello)</span>
<a href="#l2.1213"></a><span id="l2.1213" class="difflineplus">+- make static libraries by default in configure, add --shared option.</span>
<a href="#l2.1214"></a><span id="l2.1214" class="difflineplus">+- move MSDOS or Windows specific files to directory msdos</span>
<a href="#l2.1215"></a><span id="l2.1215" class="difflineplus">+- suppress the notion of partial flush to simplify the interface</span>
<a href="#l2.1216"></a><span id="l2.1216" class="difflineplus">+  (but the symbol Z_PARTIAL_FLUSH is kept for compatibility with 1.0.4)</span>
<a href="#l2.1217"></a><span id="l2.1217" class="difflineplus">+- suppress history buffer provided by application to simplify the interface</span>
<a href="#l2.1218"></a><span id="l2.1218" class="difflineplus">+  (this feature was not implemented anyway in 1.0.4)</span>
<a href="#l2.1219"></a><span id="l2.1219" class="difflineplus">+- next_in and avail_in must be initialized before calling inflateInit or</span>
<a href="#l2.1220"></a><span id="l2.1220" class="difflineplus">+  inflateInit2</span>
<a href="#l2.1221"></a><span id="l2.1221" class="difflineplus">+- add EXPORT in all exported functions (for Windows DLL)</span>
<a href="#l2.1222"></a><span id="l2.1222" class="difflineplus">+- added Makefile.nt (thanks to Stephen Williams)</span>
<a href="#l2.1223"></a><span id="l2.1223" class="difflineplus">+- added the unsupported &quot;contrib&quot; directory:</span>
<a href="#l2.1224"></a><span id="l2.1224" class="difflineplus">+   contrib/asm386/ by Gilles Vollant &lt;info@winimage.com&gt;</span>
<a href="#l2.1225"></a><span id="l2.1225" class="difflineplus">+        386 asm code replacing longest_match().</span>
<a href="#l2.1226"></a><span id="l2.1226" class="difflineplus">+   contrib/iostream/ by Kevin Ruland &lt;kevin@rodin.wustl.edu&gt;</span>
<a href="#l2.1227"></a><span id="l2.1227" class="difflineplus">+        A C++ I/O streams interface to the zlib gz* functions</span>
<a href="#l2.1228"></a><span id="l2.1228" class="difflineplus">+   contrib/iostream2/  by Tyge Løvset &lt;Tyge.Lovset@cmr.no&gt;</span>
<a href="#l2.1229"></a><span id="l2.1229" class="difflineplus">+        Another C++ I/O streams interface</span>
<a href="#l2.1230"></a><span id="l2.1230" class="difflineplus">+   contrib/untgz/  by &quot;Pedro A. Aranda Guti\irrez&quot; &lt;paag@tid.es&gt;</span>
<a href="#l2.1231"></a><span id="l2.1231" class="difflineplus">+        A very simple tar.gz file extractor using zlib</span>
<a href="#l2.1232"></a><span id="l2.1232" class="difflineplus">+   contrib/visual-basic.txt by Carlos Rios &lt;c_rios@sonda.cl&gt;</span>
<a href="#l2.1233"></a><span id="l2.1233" class="difflineplus">+        How to use compress(), uncompress() and the gz* functions from VB.</span>
<a href="#l2.1234"></a><span id="l2.1234" class="difflineplus">+- pass params -f (filtered data), -h (huffman only), -1 to -9 (compression</span>
<a href="#l2.1235"></a><span id="l2.1235" class="difflineplus">+  level) in minigzip (thanks to Tom Lane)</span>
<a href="#l2.1236"></a><span id="l2.1236" class="difflineplus">+</span>
<a href="#l2.1237"></a><span id="l2.1237" class="difflineplus">+- use const for rommable constants in deflate</span>
<a href="#l2.1238"></a><span id="l2.1238" class="difflineplus">+- added test for gzseek and gztell in example.c</span>
<a href="#l2.1239"></a><span id="l2.1239" class="difflineplus">+- add undocumented function inflateSyncPoint() (hack for Paul Mackerras)</span>
<a href="#l2.1240"></a><span id="l2.1240" class="difflineplus">+- add undocumented function zError to convert error code to string</span>
<a href="#l2.1241"></a><span id="l2.1241" class="difflineplus">+  (for Tim Smithers)</span>
<a href="#l2.1242"></a><span id="l2.1242" class="difflineplus">+- Allow compilation of gzio with -DNO_DEFLATE to avoid the compression code.</span>
<a href="#l2.1243"></a><span id="l2.1243" class="difflineplus">+- Use default memcpy for Symantec MSDOS compiler.</span>
<a href="#l2.1244"></a><span id="l2.1244" class="difflineplus">+- Add EXPORT keyword for check_func (needed for Windows DLL)</span>
<a href="#l2.1245"></a><span id="l2.1245" class="difflineplus">+- add current directory to LD_LIBRARY_PATH for &quot;make test&quot;</span>
<a href="#l2.1246"></a><span id="l2.1246" class="difflineplus">+- create also a link for libz.so.1</span>
<a href="#l2.1247"></a><span id="l2.1247" class="difflineplus">+- added support for FUJITSU UXP/DS (thanks to Toshiaki Nomura)</span>
<a href="#l2.1248"></a><span id="l2.1248" class="difflineplus">+- use $(SHAREDLIB) instead of libz.so in Makefile.in (for HPUX)</span>
<a href="#l2.1249"></a><span id="l2.1249" class="difflineplus">+- added -soname for Linux in configure (Chun-Chung Chen,</span>
<a href="#l2.1250"></a><span id="l2.1250" class="difflineplus">+- assign numbers to the exported functions in zlib.def (for Windows DLL)</span>
<a href="#l2.1251"></a><span id="l2.1251" class="difflineplus">+- add advice in zlib.h for best usage of deflateSetDictionary</span>
<a href="#l2.1252"></a><span id="l2.1252" class="difflineplus">+- work around compiler bug on Atari (cast Z_NULL in call of s-&gt;checkfn)</span>
<a href="#l2.1253"></a><span id="l2.1253" class="difflineplus">+- allow compilation with ANSI keywords only enabled for TurboC in large model</span>
<a href="#l2.1254"></a><span id="l2.1254" class="difflineplus">+- avoid &quot;versionString&quot;[0] (Borland bug)</span>
<a href="#l2.1255"></a><span id="l2.1255" class="difflineplus">+- add NEED_DUMMY_RETURN for Borland</span>
<a href="#l2.1256"></a><span id="l2.1256" class="difflineplus">+- use variable z_verbose for tracing in debug mode (L. Peter Deutsch).</span>
<a href="#l2.1257"></a><span id="l2.1257" class="difflineplus">+- allow compilation with CC</span>
<a href="#l2.1258"></a><span id="l2.1258" class="difflineplus">+- defined STDC for OS/2 (David Charlap)</span>
<a href="#l2.1259"></a><span id="l2.1259" class="difflineplus">+- limit external names to 8 chars for MVS (Thomas Lund)</span>
<a href="#l2.1260"></a><span id="l2.1260" class="difflineplus">+- in minigzip.c, use static buffers only for 16-bit systems</span>
<a href="#l2.1261"></a><span id="l2.1261" class="difflineplus">+- fix suffix check for &quot;minigzip -d foo.gz&quot;</span>
<a href="#l2.1262"></a><span id="l2.1262" class="difflineplus">+- do not return an error for the 2nd of two consecutive gzflush() (Felix Lee)</span>
<a href="#l2.1263"></a><span id="l2.1263" class="difflineplus">+- use _fdopen instead of fdopen for MSC &gt;= 6.0 (Thomas Fanslau)</span>
<a href="#l2.1264"></a><span id="l2.1264" class="difflineplus">+- added makelcc.bat for lcc-win32 (Tom St Denis)</span>
<a href="#l2.1265"></a><span id="l2.1265" class="difflineplus">+- in Makefile.dj2, use copy and del instead of install and rm (Frank Donahoe)</span>
<a href="#l2.1266"></a><span id="l2.1266" class="difflineplus">+- Avoid expanded $Id$. Use &quot;rcs -kb&quot; or &quot;cvs admin -kb&quot; to avoid Id expansion.</span>
<a href="#l2.1267"></a><span id="l2.1267" class="difflineplus">+- check for unistd.h in configure (for off_t)</span>
<a href="#l2.1268"></a><span id="l2.1268" class="difflineplus">+- remove useless check parameter in inflate_blocks_free</span>
<a href="#l2.1269"></a><span id="l2.1269" class="difflineplus">+- avoid useless assignment of s-&gt;check to itself in inflate_blocks_new</span>
<a href="#l2.1270"></a><span id="l2.1270" class="difflineplus">+- do not flush twice in gzclose (thanks to Ken Raeburn)</span>
<a href="#l2.1271"></a><span id="l2.1271" class="difflineplus">+- rename FOPEN as F_OPEN to avoid clash with /usr/include/sys/file.h</span>
<a href="#l2.1272"></a><span id="l2.1272" class="difflineplus">+- use NO_ERRNO_H instead of enumeration of operating systems with errno.h</span>
<a href="#l2.1273"></a><span id="l2.1273" class="difflineplus">+- work around buggy fclose on pipes for HP/UX</span>
<a href="#l2.1274"></a><span id="l2.1274" class="difflineplus">+- support zlib DLL with BORLAND C++ 5.0 (thanks to Glenn Randers-Pehrson)</span>
<a href="#l2.1275"></a><span id="l2.1275" class="difflineplus">+- fix configure if CC is already equal to gcc</span>
<a href="#l2.1276"></a><span id="l2.1276" class="difflineplus">+</span>
<a href="#l2.1277"></a><span id="l2.1277" class="difflineplus">+Changes in 1.0.5 (3 Jan 98)</span>
<a href="#l2.1278"></a><span id="l2.1278" class="difflineplus">+- Fix inflate to terminate gracefully when fed corrupted or invalid data</span>
<a href="#l2.1279"></a><span id="l2.1279" class="difflineplus">+- Use const for rommable constants in inflate</span>
<a href="#l2.1280"></a><span id="l2.1280" class="difflineplus">+- Eliminate memory leaks on error conditions in inflate</span>
<a href="#l2.1281"></a><span id="l2.1281" class="difflineplus">+- Removed some vestigial code in inflate</span>
<a href="#l2.1282"></a><span id="l2.1282" class="difflineplus">+- Update web address in README</span>
<a href="#l2.1283"></a><span id="l2.1283" class="difflineplus">+</span>
<a href="#l2.1284"></a><span id="l2.1284" class="difflineplus">+Changes in 1.0.4 (24 Jul 96)</span>
<a href="#l2.1285"></a><span id="l2.1285" class="difflineplus">+- In very rare conditions, deflate(s, Z_FINISH) could fail to produce an EOF</span>
<a href="#l2.1286"></a><span id="l2.1286" class="difflineplus">+  bit, so the decompressor could decompress all the correct data but went</span>
<a href="#l2.1287"></a><span id="l2.1287" class="difflineplus">+  on to attempt decompressing extra garbage data. This affected minigzip too.</span>
<a href="#l2.1288"></a><span id="l2.1288" class="difflineplus">+- zlibVersion and gzerror return const char* (needed for DLL)</span>
<a href="#l2.1289"></a><span id="l2.1289" class="difflineplus">+- port to RISCOS (no fdopen, no multiple dots, no unlink, no fileno)</span>
<a href="#l2.1290"></a><span id="l2.1290" class="difflineplus">+- use z_error only for DEBUG (avoid problem with DLLs)</span>
<a href="#l2.1291"></a><span id="l2.1291" class="difflineplus">+</span>
<a href="#l2.1292"></a><span id="l2.1292" class="difflineplus">+Changes in 1.0.3 (2 Jul 96)</span>
<a href="#l2.1293"></a><span id="l2.1293" class="difflineplus">+- use z_streamp instead of z_stream *, which is now a far pointer in MSDOS</span>
<a href="#l2.1294"></a><span id="l2.1294" class="difflineplus">+  small and medium models; this makes the library incompatible with previous</span>
<a href="#l2.1295"></a><span id="l2.1295" class="difflineplus">+  versions for these models. (No effect in large model or on other systems.)</span>
<a href="#l2.1296"></a><span id="l2.1296" class="difflineplus">+- return OK instead of BUF_ERROR if previous deflate call returned with</span>
<a href="#l2.1297"></a><span id="l2.1297" class="difflineplus">+  avail_out as zero but there is nothing to do</span>
<a href="#l2.1298"></a><span id="l2.1298" class="difflineplus">+- added memcmp for non STDC compilers</span>
<a href="#l2.1299"></a><span id="l2.1299" class="difflineplus">+- define NO_DUMMY_DECL for more Mac compilers (.h files merged incorrectly)</span>
<a href="#l2.1300"></a><span id="l2.1300" class="difflineplus">+- define __32BIT__ if __386__ or i386 is defined (pb. with Watcom and SCO)</span>
<a href="#l2.1301"></a><span id="l2.1301" class="difflineplus">+- better check for 16-bit mode MSC (avoids problem with Symantec)</span>
<a href="#l2.1302"></a><span id="l2.1302" class="difflineplus">+</span>
<a href="#l2.1303"></a><span id="l2.1303" class="difflineplus">+Changes in 1.0.2 (23 May 96)</span>
<a href="#l2.1304"></a><span id="l2.1304" class="difflineplus">+- added Windows DLL support</span>
<a href="#l2.1305"></a><span id="l2.1305" class="difflineplus">+- added a function zlibVersion (for the DLL support)</span>
<a href="#l2.1306"></a><span id="l2.1306" class="difflineplus">+- fixed declarations using Bytef in infutil.c (pb with MSDOS medium model)</span>
<a href="#l2.1307"></a><span id="l2.1307" class="difflineplus">+- Bytef is define's instead of typedef'd only for Borland C</span>
<a href="#l2.1308"></a><span id="l2.1308" class="difflineplus">+- avoid reading uninitialized memory in example.c</span>
<a href="#l2.1309"></a><span id="l2.1309" class="difflineplus">+- mention in README that the zlib format is now RFC1950</span>
<a href="#l2.1310"></a><span id="l2.1310" class="difflineplus">+- updated Makefile.dj2</span>
<a href="#l2.1311"></a><span id="l2.1311" class="difflineplus">+- added algorithm.doc</span>
<a href="#l2.1312"></a><span id="l2.1312" class="difflineplus">+</span>
<a href="#l2.1313"></a><span id="l2.1313" class="difflineplus">+Changes in 1.0.1 (20 May 96) [1.0 skipped to avoid confusion]</span>
<a href="#l2.1314"></a><span id="l2.1314" class="difflineplus">+- fix array overlay in deflate.c which sometimes caused bad compressed data</span>
<a href="#l2.1315"></a><span id="l2.1315" class="difflineplus">+- fix inflate bug with empty stored block</span>
<a href="#l2.1316"></a><span id="l2.1316" class="difflineplus">+- fix MSDOS medium model which was broken in 0.99</span>
<a href="#l2.1317"></a><span id="l2.1317" class="difflineplus">+- fix deflateParams() which could generate bad compressed data.</span>
<a href="#l2.1318"></a><span id="l2.1318" class="difflineplus">+- Bytef is define'd instead of typedef'ed (work around Borland bug)</span>
<a href="#l2.1319"></a><span id="l2.1319" class="difflineplus">+- added an INDEX file</span>
<a href="#l2.1320"></a><span id="l2.1320" class="difflineplus">+- new makefiles for DJGPP (Makefile.dj2), 32-bit Borland (Makefile.b32),</span>
<a href="#l2.1321"></a><span id="l2.1321" class="difflineplus">+  Watcom (Makefile.wat), Amiga SAS/C (Makefile.sas)</span>
<a href="#l2.1322"></a><span id="l2.1322" class="difflineplus">+- speed up adler32 for modern machines without auto-increment</span>
<a href="#l2.1323"></a><span id="l2.1323" class="difflineplus">+- added -ansi for IRIX in configure</span>
<a href="#l2.1324"></a><span id="l2.1324" class="difflineplus">+- static_init_done in trees.c is an int</span>
<a href="#l2.1325"></a><span id="l2.1325" class="difflineplus">+- define unlink as delete for VMS</span>
<a href="#l2.1326"></a><span id="l2.1326" class="difflineplus">+- fix configure for QNX</span>
<a href="#l2.1327"></a><span id="l2.1327" class="difflineplus">+- add configure branch for SCO and HPUX</span>
<a href="#l2.1328"></a><span id="l2.1328" class="difflineplus">+- avoid many warnings (unused variables, dead assignments, etc...)</span>
<a href="#l2.1329"></a><span id="l2.1329" class="difflineplus">+- no fdopen for BeOS</span>
<a href="#l2.1330"></a><span id="l2.1330" class="difflineplus">+- fix the Watcom fix for 32 bit mode (define FAR as empty)</span>
<a href="#l2.1331"></a><span id="l2.1331" class="difflineplus">+- removed redefinition of Byte for MKWERKS</span>
<a href="#l2.1332"></a><span id="l2.1332" class="difflineplus">+- work around an MWKERKS bug (incorrect merge of all .h files)</span>
<a href="#l2.1333"></a><span id="l2.1333" class="difflineplus">+</span>
<a href="#l2.1334"></a><span id="l2.1334" class="difflineplus">+Changes in 0.99 (27 Jan 96)</span>
<a href="#l2.1335"></a><span id="l2.1335" class="difflineplus">+- allow preset dictionary shared between compressor and decompressor</span>
<a href="#l2.1336"></a><span id="l2.1336" class="difflineplus">+- allow compression level 0 (no compression)</span>
<a href="#l2.1337"></a><span id="l2.1337" class="difflineplus">+- add deflateParams in zlib.h: allow dynamic change of compression level</span>
<a href="#l2.1338"></a><span id="l2.1338" class="difflineplus">+  and compression strategy.</span>
<a href="#l2.1339"></a><span id="l2.1339" class="difflineplus">+- test large buffers and deflateParams in example.c</span>
<a href="#l2.1340"></a><span id="l2.1340" class="difflineplus">+- add optional &quot;configure&quot; to build zlib as a shared library</span>
<a href="#l2.1341"></a><span id="l2.1341" class="difflineplus">+- suppress Makefile.qnx, use configure instead</span>
<a href="#l2.1342"></a><span id="l2.1342" class="difflineplus">+- fixed deflate for 64-bit systems (detected on Cray)</span>
<a href="#l2.1343"></a><span id="l2.1343" class="difflineplus">+- fixed inflate_blocks for 64-bit systems (detected on Alpha)</span>
<a href="#l2.1344"></a><span id="l2.1344" class="difflineplus">+- declare Z_DEFLATED in zlib.h (possible parameter for deflateInit2)</span>
<a href="#l2.1345"></a><span id="l2.1345" class="difflineplus">+- always return Z_BUF_ERROR when deflate() has nothing to do</span>
<a href="#l2.1346"></a><span id="l2.1346" class="difflineplus">+- deflateInit and inflateInit are now macros to allow version checking</span>
<a href="#l2.1347"></a><span id="l2.1347" class="difflineplus">+- prefix all global functions and types with z_ with -DZ_PREFIX</span>
<a href="#l2.1348"></a><span id="l2.1348" class="difflineplus">+- make falloc completely reentrant (inftrees.c)</span>
<a href="#l2.1349"></a><span id="l2.1349" class="difflineplus">+- fixed very unlikely race condition in ct_static_init</span>
<a href="#l2.1350"></a><span id="l2.1350" class="difflineplus">+- free in reverse order of allocation to help memory manager</span>
<a href="#l2.1351"></a><span id="l2.1351" class="difflineplus">+- use zlib-1.0/* instead of zlib/* inside the tar.gz</span>
<a href="#l2.1352"></a><span id="l2.1352" class="difflineplus">+- make zlib warning-free with &quot;gcc -O3 -Wall -Wwrite-strings -Wpointer-arith</span>
<a href="#l2.1353"></a><span id="l2.1353" class="difflineplus">+  -Wconversion -Wstrict-prototypes -Wmissing-prototypes&quot;</span>
<a href="#l2.1354"></a><span id="l2.1354" class="difflineplus">+- allow gzread on concatenated .gz files</span>
<a href="#l2.1355"></a><span id="l2.1355" class="difflineplus">+- deflateEnd now returns Z_DATA_ERROR if it was premature</span>
<a href="#l2.1356"></a><span id="l2.1356" class="difflineplus">+- deflate is finally (?) fully deterministic (no matches beyond end of input)</span>
<a href="#l2.1357"></a><span id="l2.1357" class="difflineplus">+- Document Z_SYNC_FLUSH</span>
<a href="#l2.1358"></a><span id="l2.1358" class="difflineplus">+- add uninstall in Makefile</span>
<a href="#l2.1359"></a><span id="l2.1359" class="difflineplus">+- Check for __cpluplus in zlib.h</span>
<a href="#l2.1360"></a><span id="l2.1360" class="difflineplus">+- Better test in ct_align for partial flush</span>
<a href="#l2.1361"></a><span id="l2.1361" class="difflineplus">+- avoid harmless warnings for Borland C++</span>
<a href="#l2.1362"></a><span id="l2.1362" class="difflineplus">+- initialize hash_head in deflate.c</span>
<a href="#l2.1363"></a><span id="l2.1363" class="difflineplus">+- avoid warning on fdopen (gzio.c) for HP cc -Aa</span>
<a href="#l2.1364"></a><span id="l2.1364" class="difflineplus">+- include stdlib.h for STDC compilers</span>
<a href="#l2.1365"></a><span id="l2.1365" class="difflineplus">+- include errno.h for Cray</span>
<a href="#l2.1366"></a><span id="l2.1366" class="difflineplus">+- ignore error if ranlib doesn't exist</span>
<a href="#l2.1367"></a><span id="l2.1367" class="difflineplus">+- call ranlib twice for NeXTSTEP</span>
<a href="#l2.1368"></a><span id="l2.1368" class="difflineplus">+- use exec_prefix instead of prefix for libz.a</span>
<a href="#l2.1369"></a><span id="l2.1369" class="difflineplus">+- renamed ct_* as _tr_* to avoid conflict with applications</span>
<a href="#l2.1370"></a><span id="l2.1370" class="difflineplus">+- clear z-&gt;msg in inflateInit2 before any error return</span>
<a href="#l2.1371"></a><span id="l2.1371" class="difflineplus">+- initialize opaque in example.c, gzio.c, deflate.c and inflate.c</span>
<a href="#l2.1372"></a><span id="l2.1372" class="difflineplus">+- fixed typo in zconf.h (_GNUC__ =&gt; __GNUC__)</span>
<a href="#l2.1373"></a><span id="l2.1373" class="difflineplus">+- check for WIN32 in zconf.h and zutil.c (avoid farmalloc in 32-bit mode)</span>
<a href="#l2.1374"></a><span id="l2.1374" class="difflineplus">+- fix typo in Make_vms.com (f$trnlnm -&gt; f$getsyi)</span>
<a href="#l2.1375"></a><span id="l2.1375" class="difflineplus">+- in fcalloc, normalize pointer if size &gt; 65520 bytes</span>
<a href="#l2.1376"></a><span id="l2.1376" class="difflineplus">+- don't use special fcalloc for 32 bit Borland C++</span>
<a href="#l2.1377"></a><span id="l2.1377" class="difflineplus">+- use STDC instead of __GO32__ to avoid redeclaring exit, calloc, etc...</span>
<a href="#l2.1378"></a><span id="l2.1378" class="difflineplus">+- use Z_BINARY instead of BINARY</span>
<a href="#l2.1379"></a><span id="l2.1379" class="difflineplus">+- document that gzclose after gzdopen will close the file</span>
<a href="#l2.1380"></a><span id="l2.1380" class="difflineplus">+- allow &quot;a&quot; as mode in gzopen.</span>
<a href="#l2.1381"></a><span id="l2.1381" class="difflineplus">+- fix error checking in gzread</span>
<a href="#l2.1382"></a><span id="l2.1382" class="difflineplus">+- allow skipping .gz extra-field on pipes</span>
<a href="#l2.1383"></a><span id="l2.1383" class="difflineplus">+- added reference to Perl interface in README</span>
<a href="#l2.1384"></a><span id="l2.1384" class="difflineplus">+- put the crc table in FAR data (I dislike more and more the medium model :)</span>
<a href="#l2.1385"></a><span id="l2.1385" class="difflineplus">+- added get_crc_table</span>
<a href="#l2.1386"></a><span id="l2.1386" class="difflineplus">+- added a dimension to all arrays (Borland C can't count).</span>
<a href="#l2.1387"></a><span id="l2.1387" class="difflineplus">+- workaround Borland C bug in declaration of inflate_codes_new &amp; inflate_fast</span>
<a href="#l2.1388"></a><span id="l2.1388" class="difflineplus">+- guard against multiple inclusion of *.h (for precompiled header on Mac)</span>
<a href="#l2.1389"></a><span id="l2.1389" class="difflineplus">+- Watcom C pretends to be Microsoft C small model even in 32 bit mode.</span>
<a href="#l2.1390"></a><span id="l2.1390" class="difflineplus">+- don't use unsized arrays to avoid silly warnings by Visual C++:</span>
<a href="#l2.1391"></a><span id="l2.1391" class="difflineplus">+     warning C4746: 'inflate_mask' : unsized array treated as  '__far'</span>
<a href="#l2.1392"></a><span id="l2.1392" class="difflineplus">+     (what's wrong with far data in far model?).</span>
<a href="#l2.1393"></a><span id="l2.1393" class="difflineplus">+- define enum out of inflate_blocks_state to allow compilation with C++</span>
<a href="#l2.1394"></a><span id="l2.1394" class="difflineplus">+</span>
<a href="#l2.1395"></a><span id="l2.1395" class="difflineplus">+Changes in 0.95 (16 Aug 95)</span>
<a href="#l2.1396"></a><span id="l2.1396" class="difflineplus">+- fix MSDOS small and medium model (now easier to adapt to any compiler)</span>
<a href="#l2.1397"></a><span id="l2.1397" class="difflineplus">+- inlined send_bits</span>
<a href="#l2.1398"></a><span id="l2.1398" class="difflineplus">+- fix the final (:-) bug for deflate with flush (output was correct but</span>
<a href="#l2.1399"></a><span id="l2.1399" class="difflineplus">+  not completely flushed in rare occasions).</span>
<a href="#l2.1400"></a><span id="l2.1400" class="difflineplus">+- default window size is same for compression and decompression</span>
<a href="#l2.1401"></a><span id="l2.1401" class="difflineplus">+  (it's now sufficient to set MAX_WBITS in zconf.h).</span>
<a href="#l2.1402"></a><span id="l2.1402" class="difflineplus">+- voidp -&gt; voidpf and voidnp -&gt; voidp (for consistency with other</span>
<a href="#l2.1403"></a><span id="l2.1403" class="difflineplus">+  typedefs and because voidnp was not near in large model).</span>
<a href="#l2.1404"></a><span id="l2.1404" class="difflineplus">+</span>
<a href="#l2.1405"></a><span id="l2.1405" class="difflineplus">+Changes in 0.94 (13 Aug 95)</span>
<a href="#l2.1406"></a><span id="l2.1406" class="difflineplus">+- support MSDOS medium model</span>
<a href="#l2.1407"></a><span id="l2.1407" class="difflineplus">+- fix deflate with flush (could sometimes generate bad output)</span>
<a href="#l2.1408"></a><span id="l2.1408" class="difflineplus">+- fix deflateReset (zlib header was incorrectly suppressed)</span>
<a href="#l2.1409"></a><span id="l2.1409" class="difflineplus">+- added support for VMS</span>
<a href="#l2.1410"></a><span id="l2.1410" class="difflineplus">+- allow a compression level in gzopen()</span>
<a href="#l2.1411"></a><span id="l2.1411" class="difflineplus">+- gzflush now calls fflush</span>
<a href="#l2.1412"></a><span id="l2.1412" class="difflineplus">+- For deflate with flush, flush even if no more input is provided.</span>
<a href="#l2.1413"></a><span id="l2.1413" class="difflineplus">+- rename libgz.a as libz.a</span>
<a href="#l2.1414"></a><span id="l2.1414" class="difflineplus">+- avoid complex expression in infcodes.c triggering Turbo C bug</span>
<a href="#l2.1415"></a><span id="l2.1415" class="difflineplus">+- work around a problem with gcc on Alpha (in INSERT_STRING)</span>
<a href="#l2.1416"></a><span id="l2.1416" class="difflineplus">+- don't use inline functions (problem with some gcc versions)</span>
<a href="#l2.1417"></a><span id="l2.1417" class="difflineplus">+- allow renaming of Byte, uInt, etc... with #define.</span>
<a href="#l2.1418"></a><span id="l2.1418" class="difflineplus">+- avoid warning about (unused) pointer before start of array in deflate.c</span>
<a href="#l2.1419"></a><span id="l2.1419" class="difflineplus">+- avoid various warnings in gzio.c, example.c, infblock.c, adler32.c, zutil.c</span>
<a href="#l2.1420"></a><span id="l2.1420" class="difflineplus">+- avoid reserved word 'new' in trees.c</span>
<a href="#l2.1421"></a><span id="l2.1421" class="difflineplus">+</span>
<a href="#l2.1422"></a><span id="l2.1422" class="difflineplus">+Changes in 0.93 (25 June 95)</span>
<a href="#l2.1423"></a><span id="l2.1423" class="difflineplus">+- temporarily disable inline functions</span>
<a href="#l2.1424"></a><span id="l2.1424" class="difflineplus">+- make deflate deterministic</span>
<a href="#l2.1425"></a><span id="l2.1425" class="difflineplus">+- give enough lookahead for PARTIAL_FLUSH</span>
<a href="#l2.1426"></a><span id="l2.1426" class="difflineplus">+- Set binary mode for stdin/stdout in minigzip.c for OS/2</span>
<a href="#l2.1427"></a><span id="l2.1427" class="difflineplus">+- don't even use signed char in inflate (not portable enough)</span>
<a href="#l2.1428"></a><span id="l2.1428" class="difflineplus">+- fix inflate memory leak for segmented architectures</span>
<a href="#l2.1429"></a><span id="l2.1429" class="difflineplus">+</span>
<a href="#l2.1430"></a><span id="l2.1430" class="difflineplus">+Changes in 0.92 (3 May 95)</span>
<a href="#l2.1431"></a><span id="l2.1431" class="difflineplus">+- don't assume that char is signed (problem on SGI)</span>
<a href="#l2.1432"></a><span id="l2.1432" class="difflineplus">+- Clear bit buffer when starting a stored block</span>
<a href="#l2.1433"></a><span id="l2.1433" class="difflineplus">+- no memcpy on Pyramid</span>
<a href="#l2.1434"></a><span id="l2.1434" class="difflineplus">+- suppressed inftest.c</span>
<a href="#l2.1435"></a><span id="l2.1435" class="difflineplus">+- optimized fill_window, put longest_match inline for gcc</span>
<a href="#l2.1436"></a><span id="l2.1436" class="difflineplus">+- optimized inflate on stored blocks.</span>
<a href="#l2.1437"></a><span id="l2.1437" class="difflineplus">+- untabify all sources to simplify patches</span>
<a href="#l2.1438"></a><span id="l2.1438" class="difflineplus">+</span>
<a href="#l2.1439"></a><span id="l2.1439" class="difflineplus">+Changes in 0.91 (2 May 95)</span>
<a href="#l2.1440"></a><span id="l2.1440" class="difflineplus">+- Default MEM_LEVEL is 8 (not 9 for Unix) as documented in zlib.h</span>
<a href="#l2.1441"></a><span id="l2.1441" class="difflineplus">+- Document the memory requirements in zconf.h</span>
<a href="#l2.1442"></a><span id="l2.1442" class="difflineplus">+- added &quot;make install&quot;</span>
<a href="#l2.1443"></a><span id="l2.1443" class="difflineplus">+- fix sync search logic in inflateSync</span>
<a href="#l2.1444"></a><span id="l2.1444" class="difflineplus">+- deflate(Z_FULL_FLUSH) now works even if output buffer too short</span>
<a href="#l2.1445"></a><span id="l2.1445" class="difflineplus">+- after inflateSync, don't scare people with just &quot;lo world&quot;</span>
<a href="#l2.1446"></a><span id="l2.1446" class="difflineplus">+- added support for DJGPP</span>
<a href="#l2.1447"></a><span id="l2.1447" class="difflineplus">+</span>
<a href="#l2.1448"></a><span id="l2.1448" class="difflineplus">+Changes in 0.9 (1 May 95)</span>
<a href="#l2.1449"></a><span id="l2.1449" class="difflineplus">+- don't assume that zalloc clears the allocated memory (the TurboC bug</span>
<a href="#l2.1450"></a><span id="l2.1450" class="difflineplus">+  was Mark's bug after all :)</span>
<a href="#l2.1451"></a><span id="l2.1451" class="difflineplus">+- let again gzread copy uncompressed data unchanged (was working in 0.71)</span>
<a href="#l2.1452"></a><span id="l2.1452" class="difflineplus">+- deflate(Z_FULL_FLUSH), inflateReset and inflateSync are now fully implemented</span>
<a href="#l2.1453"></a><span id="l2.1453" class="difflineplus">+- added a test of inflateSync in example.c</span>
<a href="#l2.1454"></a><span id="l2.1454" class="difflineplus">+- moved MAX_WBITS to zconf.h because users might want to change that.</span>
<a href="#l2.1455"></a><span id="l2.1455" class="difflineplus">+- document explicitly that zalloc(64K) on MSDOS must return a normalized</span>
<a href="#l2.1456"></a><span id="l2.1456" class="difflineplus">+  pointer (zero offset)</span>
<a href="#l2.1457"></a><span id="l2.1457" class="difflineplus">+- added Makefiles for Microsoft C, Turbo C, Borland C++</span>
<a href="#l2.1458"></a><span id="l2.1458" class="difflineplus">+- faster crc32()</span>
<a href="#l2.1459"></a><span id="l2.1459" class="difflineplus">+</span>
<a href="#l2.1460"></a><span id="l2.1460" class="difflineplus">+Changes in 0.8 (29 April 95)</span>
<a href="#l2.1461"></a><span id="l2.1461" class="difflineplus">+- added fast inflate (inffast.c)</span>
<a href="#l2.1462"></a><span id="l2.1462" class="difflineplus">+- deflate(Z_FINISH) now returns Z_STREAM_END when done. Warning: this</span>
<a href="#l2.1463"></a><span id="l2.1463" class="difflineplus">+  is incompatible with previous versions of zlib which returned Z_OK.</span>
<a href="#l2.1464"></a><span id="l2.1464" class="difflineplus">+- work around a TurboC compiler bug (bad code for b &lt;&lt; 0, see infutil.h)</span>
<a href="#l2.1465"></a><span id="l2.1465" class="difflineplus">+  (actually that was not a compiler bug, see 0.81 above)</span>
<a href="#l2.1466"></a><span id="l2.1466" class="difflineplus">+- gzread no longer reads one extra byte in certain cases</span>
<a href="#l2.1467"></a><span id="l2.1467" class="difflineplus">+- In gzio destroy(), don't reference a freed structure</span>
<a href="#l2.1468"></a><span id="l2.1468" class="difflineplus">+- avoid many warnings for MSDOS</span>
<a href="#l2.1469"></a><span id="l2.1469" class="difflineplus">+- avoid the ERROR symbol which is used by MS Windows</span>
<a href="#l2.1470"></a><span id="l2.1470" class="difflineplus">+</span>
<a href="#l2.1471"></a><span id="l2.1471" class="difflineplus">+Changes in 0.71 (14 April 95)</span>
<a href="#l2.1472"></a><span id="l2.1472" class="difflineplus">+- Fixed more MSDOS compilation problems :( There is still a bug with</span>
<a href="#l2.1473"></a><span id="l2.1473" class="difflineplus">+  TurboC large model.</span>
<a href="#l2.1474"></a><span id="l2.1474" class="difflineplus">+</span>
<a href="#l2.1475"></a><span id="l2.1475" class="difflineplus">+Changes in 0.7 (14 April 95)</span>
<a href="#l2.1476"></a><span id="l2.1476" class="difflineplus">+- Added full inflate support.</span>
<a href="#l2.1477"></a><span id="l2.1477" class="difflineplus">+- Simplified the crc32() interface. The pre- and post-conditioning</span>
<a href="#l2.1478"></a><span id="l2.1478" class="difflineplus">+  (one's complement) is now done inside crc32(). WARNING: this is</span>
<a href="#l2.1479"></a><span id="l2.1479" class="difflineplus">+  incompatible with previous versions; see zlib.h for the new usage.</span>
<a href="#l2.1480"></a><span id="l2.1480" class="difflineplus">+</span>
<a href="#l2.1481"></a><span id="l2.1481" class="difflineplus">+Changes in 0.61 (12 April 95)</span>
<a href="#l2.1482"></a><span id="l2.1482" class="difflineplus">+- workaround for a bug in TurboC. example and minigzip now work on MSDOS.</span>
<a href="#l2.1483"></a><span id="l2.1483" class="difflineplus">+</span>
<a href="#l2.1484"></a><span id="l2.1484" class="difflineplus">+Changes in 0.6 (11 April 95)</span>
<a href="#l2.1485"></a><span id="l2.1485" class="difflineplus">+- added minigzip.c</span>
<a href="#l2.1486"></a><span id="l2.1486" class="difflineplus">+- added gzdopen to reopen a file descriptor as gzFile</span>
<a href="#l2.1487"></a><span id="l2.1487" class="difflineplus">+- added transparent reading of non-gziped files in gzread.</span>
<a href="#l2.1488"></a><span id="l2.1488" class="difflineplus">+- fixed bug in gzread (don't read crc as data)</span>
<a href="#l2.1489"></a><span id="l2.1489" class="difflineplus">+- fixed bug in destroy (gzio.c) (don't return Z_STREAM_END for gzclose).</span>
<a href="#l2.1490"></a><span id="l2.1490" class="difflineplus">+- don't allocate big arrays in the stack (for MSDOS)</span>
<a href="#l2.1491"></a><span id="l2.1491" class="difflineplus">+- fix some MSDOS compilation problems</span>
<a href="#l2.1492"></a><span id="l2.1492" class="difflineplus">+</span>
<a href="#l2.1493"></a><span id="l2.1493" class="difflineplus">+Changes in 0.5:</span>
<a href="#l2.1494"></a><span id="l2.1494" class="difflineplus">+- do real compression in deflate.c. Z_PARTIAL_FLUSH is supported but</span>
<a href="#l2.1495"></a><span id="l2.1495" class="difflineplus">+  not yet Z_FULL_FLUSH.</span>
<a href="#l2.1496"></a><span id="l2.1496" class="difflineplus">+- support decompression but only in a single step (forced Z_FINISH)</span>
<a href="#l2.1497"></a><span id="l2.1497" class="difflineplus">+- added opaque object for zalloc and zfree.</span>
<a href="#l2.1498"></a><span id="l2.1498" class="difflineplus">+- added deflateReset and inflateReset</span>
<a href="#l2.1499"></a><span id="l2.1499" class="difflineplus">+- added a variable zlib_version for consistency checking.</span>
<a href="#l2.1500"></a><span id="l2.1500" class="difflineplus">+- renamed the 'filter' parameter of deflateInit2 as 'strategy'.</span>
<a href="#l2.1501"></a><span id="l2.1501" class="difflineplus">+  Added Z_FILTERED and Z_HUFFMAN_ONLY constants.</span>
<a href="#l2.1502"></a><span id="l2.1502" class="difflineplus">+</span>
<a href="#l2.1503"></a><span id="l2.1503" class="difflineplus">+Changes in 0.4:</span>
<a href="#l2.1504"></a><span id="l2.1504" class="difflineplus">+- avoid &quot;zip&quot; everywhere, use zlib instead of ziplib.</span>
<a href="#l2.1505"></a><span id="l2.1505" class="difflineplus">+- suppress Z_BLOCK_FLUSH, interpret Z_PARTIAL_FLUSH as block flush</span>
<a href="#l2.1506"></a><span id="l2.1506" class="difflineplus">+  if compression method == 8.</span>
<a href="#l2.1507"></a><span id="l2.1507" class="difflineplus">+- added adler32 and crc32</span>
<a href="#l2.1508"></a><span id="l2.1508" class="difflineplus">+- renamed deflateOptions as deflateInit2, call one or the other but not both</span>
<a href="#l2.1509"></a><span id="l2.1509" class="difflineplus">+- added the method parameter for deflateInit2.</span>
<a href="#l2.1510"></a><span id="l2.1510" class="difflineplus">+- added inflateInit2</span>
<a href="#l2.1511"></a><span id="l2.1511" class="difflineplus">+- simplied considerably deflateInit and inflateInit by not supporting</span>
<a href="#l2.1512"></a><span id="l2.1512" class="difflineplus">+  user-provided history buffer. This is supported only in deflateInit2</span>
<a href="#l2.1513"></a><span id="l2.1513" class="difflineplus">+  and inflateInit2.</span>
<a href="#l2.1514"></a><span id="l2.1514" class="difflineplus">+</span>
<a href="#l2.1515"></a><span id="l2.1515" class="difflineplus">+Changes in 0.3:</span>
<a href="#l2.1516"></a><span id="l2.1516" class="difflineplus">+- prefix all macro names with Z_</span>
<a href="#l2.1517"></a><span id="l2.1517" class="difflineplus">+- use Z_FINISH instead of deflateEnd to finish compression.</span>
<a href="#l2.1518"></a><span id="l2.1518" class="difflineplus">+- added Z_HUFFMAN_ONLY</span>
<a href="#l2.1519"></a><span id="l2.1519" class="difflineplus">+- added gzerror()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1">new file mode 100644</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineminus">--- /dev/null</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineplus">+++ b/third_party/zlib/Changelog.mzla</span>
<a href="#l3.4"></a><span id="l3.4" class="difflineat">@@ -0,0 +1,7 @@</span>
<a href="#l3.5"></a><span id="l3.5" class="difflineplus">+MZLA Technologies Changelog for zlib</span>
<a href="#l3.6"></a><span id="l3.6" class="difflineplus">+</span>
<a href="#l3.7"></a><span id="l3.7" class="difflineplus">+- 2020-Apr-15</span>
<a href="#l3.8"></a><span id="l3.8" class="difflineplus">+  Based on 1.2.1 release.</span>
<a href="#l3.9"></a><span id="l3.9" class="difflineplus">+  Removed unneeded files and directories.</span>
<a href="#l3.10"></a><span id="l3.10" class="difflineplus">+  bug #1621782</span>
<a href="#l3.11"></a><span id="l3.11" class="difflineplus">+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1">new file mode 100644</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineminus">--- /dev/null</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineplus">+++ b/third_party/zlib/FAQ</span>
<a href="#l4.4"></a><span id="l4.4" class="difflineat">@@ -0,0 +1,368 @@</span>
<a href="#l4.5"></a><span id="l4.5" class="difflineplus">+</span>
<a href="#l4.6"></a><span id="l4.6" class="difflineplus">+                Frequently Asked Questions about zlib</span>
<a href="#l4.7"></a><span id="l4.7" class="difflineplus">+</span>
<a href="#l4.8"></a><span id="l4.8" class="difflineplus">+</span>
<a href="#l4.9"></a><span id="l4.9" class="difflineplus">+If your question is not there, please check the zlib home page</span>
<a href="#l4.10"></a><span id="l4.10" class="difflineplus">+http://zlib.net/ which may have more recent information.</span>
<a href="#l4.11"></a><span id="l4.11" class="difflineplus">+The lastest zlib FAQ is at http://zlib.net/zlib_faq.html</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+ 1. Is zlib Y2K-compliant?</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineplus">+</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineplus">+    Yes. zlib doesn't handle dates.</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineplus">+</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineplus">+ 2. Where can I get a Windows DLL version?</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineplus">+</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineplus">+    The zlib sources can be compiled without change to produce a DLL.  See the</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineplus">+    file win32/DLL_FAQ.txt in the zlib distribution.  Pointers to the</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineplus">+    precompiled DLL are found in the zlib web site at http://zlib.net/ .</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineplus">+</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineplus">+ 3. Where can I get a Visual Basic interface to zlib?</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineplus">+</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineplus">+    See</span>
<a href="#l4.27"></a><span id="l4.27" class="difflineplus">+        * http://marknelson.us/1997/01/01/zlib-engine/</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineplus">+        * win32/DLL_FAQ.txt in the zlib distribution</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineplus">+</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineplus">+ 4. compress() returns Z_BUF_ERROR.</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+    Make sure that before the call of compress(), the length of the compressed</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+    buffer is equal to the available size of the compressed buffer and not</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+    zero.  For Visual Basic, check that this parameter is passed by reference</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+    (&quot;as any&quot;), not by value (&quot;as long&quot;).</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+ 5. deflate() or inflate() returns Z_BUF_ERROR.</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineplus">+    Before making the call, make sure that avail_in and avail_out are not zero.</span>
<a href="#l4.40"></a><span id="l4.40" class="difflineplus">+    When setting the parameter flush equal to Z_FINISH, also make sure that</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineplus">+    avail_out is big enough to allow processing all pending input.  Note that a</span>
<a href="#l4.42"></a><span id="l4.42" class="difflineplus">+    Z_BUF_ERROR is not fatal--another call to deflate() or inflate() can be</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineplus">+    made with more input or output space.  A Z_BUF_ERROR may in fact be</span>
<a href="#l4.44"></a><span id="l4.44" class="difflineplus">+    unavoidable depending on how the functions are used, since it is not</span>
<a href="#l4.45"></a><span id="l4.45" class="difflineplus">+    possible to tell whether or not there is more output pending when</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineplus">+    strm.avail_out returns with zero.  See http://zlib.net/zlib_how.html for a</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineplus">+    heavily annotated example.</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineplus">+</span>
<a href="#l4.49"></a><span id="l4.49" class="difflineplus">+ 6. Where's the zlib documentation (man pages, etc.)?</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineplus">+</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineplus">+    It's in zlib.h .  Examples of zlib usage are in the files test/example.c</span>
<a href="#l4.52"></a><span id="l4.52" class="difflineplus">+    and test/minigzip.c, with more in examples/ .</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineplus">+</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineplus">+ 7. Why don't you use GNU autoconf or libtool or ...?</span>
<a href="#l4.55"></a><span id="l4.55" class="difflineplus">+</span>
<a href="#l4.56"></a><span id="l4.56" class="difflineplus">+    Because we would like to keep zlib as a very small and simple package.</span>
<a href="#l4.57"></a><span id="l4.57" class="difflineplus">+    zlib is rather portable and doesn't need much configuration.</span>
<a href="#l4.58"></a><span id="l4.58" class="difflineplus">+</span>
<a href="#l4.59"></a><span id="l4.59" class="difflineplus">+ 8. I found a bug in zlib.</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineplus">+</span>
<a href="#l4.61"></a><span id="l4.61" class="difflineplus">+    Most of the time, such problems are due to an incorrect usage of zlib.</span>
<a href="#l4.62"></a><span id="l4.62" class="difflineplus">+    Please try to reproduce the problem with a small program and send the</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineplus">+    corresponding source to us at zlib@gzip.org .  Do not send multi-megabyte</span>
<a href="#l4.64"></a><span id="l4.64" class="difflineplus">+    data files without prior agreement.</span>
<a href="#l4.65"></a><span id="l4.65" class="difflineplus">+</span>
<a href="#l4.66"></a><span id="l4.66" class="difflineplus">+ 9. Why do I get &quot;undefined reference to gzputc&quot;?</span>
<a href="#l4.67"></a><span id="l4.67" class="difflineplus">+</span>
<a href="#l4.68"></a><span id="l4.68" class="difflineplus">+    If &quot;make test&quot; produces something like</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineplus">+</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineplus">+       example.o(.text+0x154): undefined reference to `gzputc'</span>
<a href="#l4.71"></a><span id="l4.71" class="difflineplus">+</span>
<a href="#l4.72"></a><span id="l4.72" class="difflineplus">+    check that you don't have old files libz.* in /usr/lib, /usr/local/lib or</span>
<a href="#l4.73"></a><span id="l4.73" class="difflineplus">+    /usr/X11R6/lib. Remove any old versions, then do &quot;make install&quot;.</span>
<a href="#l4.74"></a><span id="l4.74" class="difflineplus">+</span>
<a href="#l4.75"></a><span id="l4.75" class="difflineplus">+10. I need a Delphi interface to zlib.</span>
<a href="#l4.76"></a><span id="l4.76" class="difflineplus">+</span>
<a href="#l4.77"></a><span id="l4.77" class="difflineplus">+    See the contrib/delphi directory in the zlib distribution.</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineplus">+</span>
<a href="#l4.79"></a><span id="l4.79" class="difflineplus">+11. Can zlib handle .zip archives?</span>
<a href="#l4.80"></a><span id="l4.80" class="difflineplus">+</span>
<a href="#l4.81"></a><span id="l4.81" class="difflineplus">+    Not by itself, no.  See the directory contrib/minizip in the zlib</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineplus">+    distribution.</span>
<a href="#l4.83"></a><span id="l4.83" class="difflineplus">+</span>
<a href="#l4.84"></a><span id="l4.84" class="difflineplus">+12. Can zlib handle .Z files?</span>
<a href="#l4.85"></a><span id="l4.85" class="difflineplus">+</span>
<a href="#l4.86"></a><span id="l4.86" class="difflineplus">+    No, sorry.  You have to spawn an uncompress or gunzip subprocess, or adapt</span>
<a href="#l4.87"></a><span id="l4.87" class="difflineplus">+    the code of uncompress on your own.</span>
<a href="#l4.88"></a><span id="l4.88" class="difflineplus">+</span>
<a href="#l4.89"></a><span id="l4.89" class="difflineplus">+13. How can I make a Unix shared library?</span>
<a href="#l4.90"></a><span id="l4.90" class="difflineplus">+</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineplus">+    By default a shared (and a static) library is built for Unix.  So:</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineplus">+</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineplus">+    make distclean</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineplus">+    ./configure</span>
<a href="#l4.95"></a><span id="l4.95" class="difflineplus">+    make</span>
<a href="#l4.96"></a><span id="l4.96" class="difflineplus">+</span>
<a href="#l4.97"></a><span id="l4.97" class="difflineplus">+14. How do I install a shared zlib library on Unix?</span>
<a href="#l4.98"></a><span id="l4.98" class="difflineplus">+</span>
<a href="#l4.99"></a><span id="l4.99" class="difflineplus">+    After the above, then:</span>
<a href="#l4.100"></a><span id="l4.100" class="difflineplus">+</span>
<a href="#l4.101"></a><span id="l4.101" class="difflineplus">+    make install</span>
<a href="#l4.102"></a><span id="l4.102" class="difflineplus">+</span>
<a href="#l4.103"></a><span id="l4.103" class="difflineplus">+    However, many flavors of Unix come with a shared zlib already installed.</span>
<a href="#l4.104"></a><span id="l4.104" class="difflineplus">+    Before going to the trouble of compiling a shared version of zlib and</span>
<a href="#l4.105"></a><span id="l4.105" class="difflineplus">+    trying to install it, you may want to check if it's already there!  If you</span>
<a href="#l4.106"></a><span id="l4.106" class="difflineplus">+    can #include &lt;zlib.h&gt;, it's there.  The -lz option will probably link to</span>
<a href="#l4.107"></a><span id="l4.107" class="difflineplus">+    it.  You can check the version at the top of zlib.h or with the</span>
<a href="#l4.108"></a><span id="l4.108" class="difflineplus">+    ZLIB_VERSION symbol defined in zlib.h .</span>
<a href="#l4.109"></a><span id="l4.109" class="difflineplus">+</span>
<a href="#l4.110"></a><span id="l4.110" class="difflineplus">+15. I have a question about OttoPDF.</span>
<a href="#l4.111"></a><span id="l4.111" class="difflineplus">+</span>
<a href="#l4.112"></a><span id="l4.112" class="difflineplus">+    We are not the authors of OttoPDF. The real author is on the OttoPDF web</span>
<a href="#l4.113"></a><span id="l4.113" class="difflineplus">+    site: Joel Hainley, jhainley@myndkryme.com.</span>
<a href="#l4.114"></a><span id="l4.114" class="difflineplus">+</span>
<a href="#l4.115"></a><span id="l4.115" class="difflineplus">+16. Can zlib decode Flate data in an Adobe PDF file?</span>
<a href="#l4.116"></a><span id="l4.116" class="difflineplus">+</span>
<a href="#l4.117"></a><span id="l4.117" class="difflineplus">+    Yes. See http://www.pdflib.com/ . To modify PDF forms, see</span>
<a href="#l4.118"></a><span id="l4.118" class="difflineplus">+    http://sourceforge.net/projects/acroformtool/ .</span>
<a href="#l4.119"></a><span id="l4.119" class="difflineplus">+</span>
<a href="#l4.120"></a><span id="l4.120" class="difflineplus">+17. Why am I getting this &quot;register_frame_info not found&quot; error on Solaris?</span>
<a href="#l4.121"></a><span id="l4.121" class="difflineplus">+</span>
<a href="#l4.122"></a><span id="l4.122" class="difflineplus">+    After installing zlib 1.1.4 on Solaris 2.6, running applications using zlib</span>
<a href="#l4.123"></a><span id="l4.123" class="difflineplus">+    generates an error such as:</span>
<a href="#l4.124"></a><span id="l4.124" class="difflineplus">+</span>
<a href="#l4.125"></a><span id="l4.125" class="difflineplus">+        ld.so.1: rpm: fatal: relocation error: file /usr/local/lib/libz.so:</span>
<a href="#l4.126"></a><span id="l4.126" class="difflineplus">+        symbol __register_frame_info: referenced symbol not found</span>
<a href="#l4.127"></a><span id="l4.127" class="difflineplus">+</span>
<a href="#l4.128"></a><span id="l4.128" class="difflineplus">+    The symbol __register_frame_info is not part of zlib, it is generated by</span>
<a href="#l4.129"></a><span id="l4.129" class="difflineplus">+    the C compiler (cc or gcc).  You must recompile applications using zlib</span>
<a href="#l4.130"></a><span id="l4.130" class="difflineplus">+    which have this problem.  This problem is specific to Solaris.  See</span>
<a href="#l4.131"></a><span id="l4.131" class="difflineplus">+    http://www.sunfreeware.com for Solaris versions of zlib and applications</span>
<a href="#l4.132"></a><span id="l4.132" class="difflineplus">+    using zlib.</span>
<a href="#l4.133"></a><span id="l4.133" class="difflineplus">+</span>
<a href="#l4.134"></a><span id="l4.134" class="difflineplus">+18. Why does gzip give an error on a file I make with compress/deflate?</span>
<a href="#l4.135"></a><span id="l4.135" class="difflineplus">+</span>
<a href="#l4.136"></a><span id="l4.136" class="difflineplus">+    The compress and deflate functions produce data in the zlib format, which</span>
<a href="#l4.137"></a><span id="l4.137" class="difflineplus">+    is different and incompatible with the gzip format.  The gz* functions in</span>
<a href="#l4.138"></a><span id="l4.138" class="difflineplus">+    zlib on the other hand use the gzip format.  Both the zlib and gzip formats</span>
<a href="#l4.139"></a><span id="l4.139" class="difflineplus">+    use the same compressed data format internally, but have different headers</span>
<a href="#l4.140"></a><span id="l4.140" class="difflineplus">+    and trailers around the compressed data.</span>
<a href="#l4.141"></a><span id="l4.141" class="difflineplus">+</span>
<a href="#l4.142"></a><span id="l4.142" class="difflineplus">+19. Ok, so why are there two different formats?</span>
<a href="#l4.143"></a><span id="l4.143" class="difflineplus">+</span>
<a href="#l4.144"></a><span id="l4.144" class="difflineplus">+    The gzip format was designed to retain the directory information about a</span>
<a href="#l4.145"></a><span id="l4.145" class="difflineplus">+    single file, such as the name and last modification date.  The zlib format</span>
<a href="#l4.146"></a><span id="l4.146" class="difflineplus">+    on the other hand was designed for in-memory and communication channel</span>
<a href="#l4.147"></a><span id="l4.147" class="difflineplus">+    applications, and has a much more compact header and trailer and uses a</span>
<a href="#l4.148"></a><span id="l4.148" class="difflineplus">+    faster integrity check than gzip.</span>
<a href="#l4.149"></a><span id="l4.149" class="difflineplus">+</span>
<a href="#l4.150"></a><span id="l4.150" class="difflineplus">+20. Well that's nice, but how do I make a gzip file in memory?</span>
<a href="#l4.151"></a><span id="l4.151" class="difflineplus">+</span>
<a href="#l4.152"></a><span id="l4.152" class="difflineplus">+    You can request that deflate write the gzip format instead of the zlib</span>
<a href="#l4.153"></a><span id="l4.153" class="difflineplus">+    format using deflateInit2().  You can also request that inflate decode the</span>
<a href="#l4.154"></a><span id="l4.154" class="difflineplus">+    gzip format using inflateInit2().  Read zlib.h for more details.</span>
<a href="#l4.155"></a><span id="l4.155" class="difflineplus">+</span>
<a href="#l4.156"></a><span id="l4.156" class="difflineplus">+21. Is zlib thread-safe?</span>
<a href="#l4.157"></a><span id="l4.157" class="difflineplus">+</span>
<a href="#l4.158"></a><span id="l4.158" class="difflineplus">+    Yes.  However any library routines that zlib uses and any application-</span>
<a href="#l4.159"></a><span id="l4.159" class="difflineplus">+    provided memory allocation routines must also be thread-safe.  zlib's gz*</span>
<a href="#l4.160"></a><span id="l4.160" class="difflineplus">+    functions use stdio library routines, and most of zlib's functions use the</span>
<a href="#l4.161"></a><span id="l4.161" class="difflineplus">+    library memory allocation routines by default.  zlib's *Init* functions</span>
<a href="#l4.162"></a><span id="l4.162" class="difflineplus">+    allow for the application to provide custom memory allocation routines.</span>
<a href="#l4.163"></a><span id="l4.163" class="difflineplus">+</span>
<a href="#l4.164"></a><span id="l4.164" class="difflineplus">+    Of course, you should only operate on any given zlib or gzip stream from a</span>
<a href="#l4.165"></a><span id="l4.165" class="difflineplus">+    single thread at a time.</span>
<a href="#l4.166"></a><span id="l4.166" class="difflineplus">+</span>
<a href="#l4.167"></a><span id="l4.167" class="difflineplus">+22. Can I use zlib in my commercial application?</span>
<a href="#l4.168"></a><span id="l4.168" class="difflineplus">+</span>
<a href="#l4.169"></a><span id="l4.169" class="difflineplus">+    Yes.  Please read the license in zlib.h.</span>
<a href="#l4.170"></a><span id="l4.170" class="difflineplus">+</span>
<a href="#l4.171"></a><span id="l4.171" class="difflineplus">+23. Is zlib under the GNU license?</span>
<a href="#l4.172"></a><span id="l4.172" class="difflineplus">+</span>
<a href="#l4.173"></a><span id="l4.173" class="difflineplus">+    No.  Please read the license in zlib.h.</span>
<a href="#l4.174"></a><span id="l4.174" class="difflineplus">+</span>
<a href="#l4.175"></a><span id="l4.175" class="difflineplus">+24. The license says that altered source versions must be &quot;plainly marked&quot;. So</span>
<a href="#l4.176"></a><span id="l4.176" class="difflineplus">+    what exactly do I need to do to meet that requirement?</span>
<a href="#l4.177"></a><span id="l4.177" class="difflineplus">+</span>
<a href="#l4.178"></a><span id="l4.178" class="difflineplus">+    You need to change the ZLIB_VERSION and ZLIB_VERNUM #defines in zlib.h.  In</span>
<a href="#l4.179"></a><span id="l4.179" class="difflineplus">+    particular, the final version number needs to be changed to &quot;f&quot;, and an</span>
<a href="#l4.180"></a><span id="l4.180" class="difflineplus">+    identification string should be appended to ZLIB_VERSION.  Version numbers</span>
<a href="#l4.181"></a><span id="l4.181" class="difflineplus">+    x.x.x.f are reserved for modifications to zlib by others than the zlib</span>
<a href="#l4.182"></a><span id="l4.182" class="difflineplus">+    maintainers.  For example, if the version of the base zlib you are altering</span>
<a href="#l4.183"></a><span id="l4.183" class="difflineplus">+    is &quot;1.2.3.4&quot;, then in zlib.h you should change ZLIB_VERNUM to 0x123f, and</span>
<a href="#l4.184"></a><span id="l4.184" class="difflineplus">+    ZLIB_VERSION to something like &quot;1.2.3.f-zachary-mods-v3&quot;.  You can also</span>
<a href="#l4.185"></a><span id="l4.185" class="difflineplus">+    update the version strings in deflate.c and inftrees.c.</span>
<a href="#l4.186"></a><span id="l4.186" class="difflineplus">+</span>
<a href="#l4.187"></a><span id="l4.187" class="difflineplus">+    For altered source distributions, you should also note the origin and</span>
<a href="#l4.188"></a><span id="l4.188" class="difflineplus">+    nature of the changes in zlib.h, as well as in ChangeLog and README, along</span>
<a href="#l4.189"></a><span id="l4.189" class="difflineplus">+    with the dates of the alterations.  The origin should include at least your</span>
<a href="#l4.190"></a><span id="l4.190" class="difflineplus">+    name (or your company's name), and an email address to contact for help or</span>
<a href="#l4.191"></a><span id="l4.191" class="difflineplus">+    issues with the library.</span>
<a href="#l4.192"></a><span id="l4.192" class="difflineplus">+</span>
<a href="#l4.193"></a><span id="l4.193" class="difflineplus">+    Note that distributing a compiled zlib library along with zlib.h and</span>
<a href="#l4.194"></a><span id="l4.194" class="difflineplus">+    zconf.h is also a source distribution, and so you should change</span>
<a href="#l4.195"></a><span id="l4.195" class="difflineplus">+    ZLIB_VERSION and ZLIB_VERNUM and note the origin and nature of the changes</span>
<a href="#l4.196"></a><span id="l4.196" class="difflineplus">+    in zlib.h as you would for a full source distribution.</span>
<a href="#l4.197"></a><span id="l4.197" class="difflineplus">+</span>
<a href="#l4.198"></a><span id="l4.198" class="difflineplus">+25. Will zlib work on a big-endian or little-endian architecture, and can I</span>
<a href="#l4.199"></a><span id="l4.199" class="difflineplus">+    exchange compressed data between them?</span>
<a href="#l4.200"></a><span id="l4.200" class="difflineplus">+</span>
<a href="#l4.201"></a><span id="l4.201" class="difflineplus">+    Yes and yes.</span>
<a href="#l4.202"></a><span id="l4.202" class="difflineplus">+</span>
<a href="#l4.203"></a><span id="l4.203" class="difflineplus">+26. Will zlib work on a 64-bit machine?</span>
<a href="#l4.204"></a><span id="l4.204" class="difflineplus">+</span>
<a href="#l4.205"></a><span id="l4.205" class="difflineplus">+    Yes.  It has been tested on 64-bit machines, and has no dependence on any</span>
<a href="#l4.206"></a><span id="l4.206" class="difflineplus">+    data types being limited to 32-bits in length.  If you have any</span>
<a href="#l4.207"></a><span id="l4.207" class="difflineplus">+    difficulties, please provide a complete problem report to zlib@gzip.org</span>
<a href="#l4.208"></a><span id="l4.208" class="difflineplus">+</span>
<a href="#l4.209"></a><span id="l4.209" class="difflineplus">+27. Will zlib decompress data from the PKWare Data Compression Library?</span>
<a href="#l4.210"></a><span id="l4.210" class="difflineplus">+</span>
<a href="#l4.211"></a><span id="l4.211" class="difflineplus">+    No.  The PKWare DCL uses a completely different compressed data format than</span>
<a href="#l4.212"></a><span id="l4.212" class="difflineplus">+    does PKZIP and zlib.  However, you can look in zlib's contrib/blast</span>
<a href="#l4.213"></a><span id="l4.213" class="difflineplus">+    directory for a possible solution to your problem.</span>
<a href="#l4.214"></a><span id="l4.214" class="difflineplus">+</span>
<a href="#l4.215"></a><span id="l4.215" class="difflineplus">+28. Can I access data randomly in a compressed stream?</span>
<a href="#l4.216"></a><span id="l4.216" class="difflineplus">+</span>
<a href="#l4.217"></a><span id="l4.217" class="difflineplus">+    No, not without some preparation.  If when compressing you periodically use</span>
<a href="#l4.218"></a><span id="l4.218" class="difflineplus">+    Z_FULL_FLUSH, carefully write all the pending data at those points, and</span>
<a href="#l4.219"></a><span id="l4.219" class="difflineplus">+    keep an index of those locations, then you can start decompression at those</span>
<a href="#l4.220"></a><span id="l4.220" class="difflineplus">+    points.  You have to be careful to not use Z_FULL_FLUSH too often, since it</span>
<a href="#l4.221"></a><span id="l4.221" class="difflineplus">+    can significantly degrade compression.  Alternatively, you can scan a</span>
<a href="#l4.222"></a><span id="l4.222" class="difflineplus">+    deflate stream once to generate an index, and then use that index for</span>
<a href="#l4.223"></a><span id="l4.223" class="difflineplus">+    random access.  See examples/zran.c .</span>
<a href="#l4.224"></a><span id="l4.224" class="difflineplus">+</span>
<a href="#l4.225"></a><span id="l4.225" class="difflineplus">+29. Does zlib work on MVS, OS/390, CICS, etc.?</span>
<a href="#l4.226"></a><span id="l4.226" class="difflineplus">+</span>
<a href="#l4.227"></a><span id="l4.227" class="difflineplus">+    It has in the past, but we have not heard of any recent evidence.  There</span>
<a href="#l4.228"></a><span id="l4.228" class="difflineplus">+    were working ports of zlib 1.1.4 to MVS, but those links no longer work.</span>
<a href="#l4.229"></a><span id="l4.229" class="difflineplus">+    If you know of recent, successful applications of zlib on these operating</span>
<a href="#l4.230"></a><span id="l4.230" class="difflineplus">+    systems, please let us know.  Thanks.</span>
<a href="#l4.231"></a><span id="l4.231" class="difflineplus">+</span>
<a href="#l4.232"></a><span id="l4.232" class="difflineplus">+30. Is there some simpler, easier to read version of inflate I can look at to</span>
<a href="#l4.233"></a><span id="l4.233" class="difflineplus">+    understand the deflate format?</span>
<a href="#l4.234"></a><span id="l4.234" class="difflineplus">+</span>
<a href="#l4.235"></a><span id="l4.235" class="difflineplus">+    First off, you should read RFC 1951.  Second, yes.  Look in zlib's</span>
<a href="#l4.236"></a><span id="l4.236" class="difflineplus">+    contrib/puff directory.</span>
<a href="#l4.237"></a><span id="l4.237" class="difflineplus">+</span>
<a href="#l4.238"></a><span id="l4.238" class="difflineplus">+31. Does zlib infringe on any patents?</span>
<a href="#l4.239"></a><span id="l4.239" class="difflineplus">+</span>
<a href="#l4.240"></a><span id="l4.240" class="difflineplus">+    As far as we know, no.  In fact, that was originally the whole point behind</span>
<a href="#l4.241"></a><span id="l4.241" class="difflineplus">+    zlib.  Look here for some more information:</span>
<a href="#l4.242"></a><span id="l4.242" class="difflineplus">+</span>
<a href="#l4.243"></a><span id="l4.243" class="difflineplus">+    http://www.gzip.org/#faq11</span>
<a href="#l4.244"></a><span id="l4.244" class="difflineplus">+</span>
<a href="#l4.245"></a><span id="l4.245" class="difflineplus">+32. Can zlib work with greater than 4 GB of data?</span>
<a href="#l4.246"></a><span id="l4.246" class="difflineplus">+</span>
<a href="#l4.247"></a><span id="l4.247" class="difflineplus">+    Yes.  inflate() and deflate() will process any amount of data correctly.</span>
<a href="#l4.248"></a><span id="l4.248" class="difflineplus">+    Each call of inflate() or deflate() is limited to input and output chunks</span>
<a href="#l4.249"></a><span id="l4.249" class="difflineplus">+    of the maximum value that can be stored in the compiler's &quot;unsigned int&quot;</span>
<a href="#l4.250"></a><span id="l4.250" class="difflineplus">+    type, but there is no limit to the number of chunks.  Note however that the</span>
<a href="#l4.251"></a><span id="l4.251" class="difflineplus">+    strm.total_in and strm_total_out counters may be limited to 4 GB.  These</span>
<a href="#l4.252"></a><span id="l4.252" class="difflineplus">+    counters are provided as a convenience and are not used internally by</span>
<a href="#l4.253"></a><span id="l4.253" class="difflineplus">+    inflate() or deflate().  The application can easily set up its own counters</span>
<a href="#l4.254"></a><span id="l4.254" class="difflineplus">+    updated after each call of inflate() or deflate() to count beyond 4 GB.</span>
<a href="#l4.255"></a><span id="l4.255" class="difflineplus">+    compress() and uncompress() may be limited to 4 GB, since they operate in a</span>
<a href="#l4.256"></a><span id="l4.256" class="difflineplus">+    single call.  gzseek() and gztell() may be limited to 4 GB depending on how</span>
<a href="#l4.257"></a><span id="l4.257" class="difflineplus">+    zlib is compiled.  See the zlibCompileFlags() function in zlib.h.</span>
<a href="#l4.258"></a><span id="l4.258" class="difflineplus">+</span>
<a href="#l4.259"></a><span id="l4.259" class="difflineplus">+    The word &quot;may&quot; appears several times above since there is a 4 GB limit only</span>
<a href="#l4.260"></a><span id="l4.260" class="difflineplus">+    if the compiler's &quot;long&quot; type is 32 bits.  If the compiler's &quot;long&quot; type is</span>
<a href="#l4.261"></a><span id="l4.261" class="difflineplus">+    64 bits, then the limit is 16 exabytes.</span>
<a href="#l4.262"></a><span id="l4.262" class="difflineplus">+</span>
<a href="#l4.263"></a><span id="l4.263" class="difflineplus">+33. Does zlib have any security vulnerabilities?</span>
<a href="#l4.264"></a><span id="l4.264" class="difflineplus">+</span>
<a href="#l4.265"></a><span id="l4.265" class="difflineplus">+    The only one that we are aware of is potentially in gzprintf().  If zlib is</span>
<a href="#l4.266"></a><span id="l4.266" class="difflineplus">+    compiled to use sprintf() or vsprintf(), then there is no protection</span>
<a href="#l4.267"></a><span id="l4.267" class="difflineplus">+    against a buffer overflow of an 8K string space (or other value as set by</span>
<a href="#l4.268"></a><span id="l4.268" class="difflineplus">+    gzbuffer()), other than the caller of gzprintf() assuring that the output</span>
<a href="#l4.269"></a><span id="l4.269" class="difflineplus">+    will not exceed 8K.  On the other hand, if zlib is compiled to use</span>
<a href="#l4.270"></a><span id="l4.270" class="difflineplus">+    snprintf() or vsnprintf(), which should normally be the case, then there is</span>
<a href="#l4.271"></a><span id="l4.271" class="difflineplus">+    no vulnerability.  The ./configure script will display warnings if an</span>
<a href="#l4.272"></a><span id="l4.272" class="difflineplus">+    insecure variation of sprintf() will be used by gzprintf().  Also the</span>
<a href="#l4.273"></a><span id="l4.273" class="difflineplus">+    zlibCompileFlags() function will return information on what variant of</span>
<a href="#l4.274"></a><span id="l4.274" class="difflineplus">+    sprintf() is used by gzprintf().</span>
<a href="#l4.275"></a><span id="l4.275" class="difflineplus">+</span>
<a href="#l4.276"></a><span id="l4.276" class="difflineplus">+    If you don't have snprintf() or vsnprintf() and would like one, you can</span>
<a href="#l4.277"></a><span id="l4.277" class="difflineplus">+    find a portable implementation here:</span>
<a href="#l4.278"></a><span id="l4.278" class="difflineplus">+</span>
<a href="#l4.279"></a><span id="l4.279" class="difflineplus">+        http://www.ijs.si/software/snprintf/</span>
<a href="#l4.280"></a><span id="l4.280" class="difflineplus">+</span>
<a href="#l4.281"></a><span id="l4.281" class="difflineplus">+    Note that you should be using the most recent version of zlib.  Versions</span>
<a href="#l4.282"></a><span id="l4.282" class="difflineplus">+    1.1.3 and before were subject to a double-free vulnerability, and versions</span>
<a href="#l4.283"></a><span id="l4.283" class="difflineplus">+    1.2.1 and 1.2.2 were subject to an access exception when decompressing</span>
<a href="#l4.284"></a><span id="l4.284" class="difflineplus">+    invalid compressed data.</span>
<a href="#l4.285"></a><span id="l4.285" class="difflineplus">+</span>
<a href="#l4.286"></a><span id="l4.286" class="difflineplus">+34. Is there a Java version of zlib?</span>
<a href="#l4.287"></a><span id="l4.287" class="difflineplus">+</span>
<a href="#l4.288"></a><span id="l4.288" class="difflineplus">+    Probably what you want is to use zlib in Java. zlib is already included</span>
<a href="#l4.289"></a><span id="l4.289" class="difflineplus">+    as part of the Java SDK in the java.util.zip package. If you really want</span>
<a href="#l4.290"></a><span id="l4.290" class="difflineplus">+    a version of zlib written in the Java language, look on the zlib home</span>
<a href="#l4.291"></a><span id="l4.291" class="difflineplus">+    page for links: http://zlib.net/ .</span>
<a href="#l4.292"></a><span id="l4.292" class="difflineplus">+</span>
<a href="#l4.293"></a><span id="l4.293" class="difflineplus">+35. I get this or that compiler or source-code scanner warning when I crank it</span>
<a href="#l4.294"></a><span id="l4.294" class="difflineplus">+    up to maximally-pedantic. Can't you guys write proper code?</span>
<a href="#l4.295"></a><span id="l4.295" class="difflineplus">+</span>
<a href="#l4.296"></a><span id="l4.296" class="difflineplus">+    Many years ago, we gave up attempting to avoid warnings on every compiler</span>
<a href="#l4.297"></a><span id="l4.297" class="difflineplus">+    in the universe.  It just got to be a waste of time, and some compilers</span>
<a href="#l4.298"></a><span id="l4.298" class="difflineplus">+    were downright silly as well as contradicted each other.  So now, we simply</span>
<a href="#l4.299"></a><span id="l4.299" class="difflineplus">+    make sure that the code always works.</span>
<a href="#l4.300"></a><span id="l4.300" class="difflineplus">+</span>
<a href="#l4.301"></a><span id="l4.301" class="difflineplus">+36. Valgrind (or some similar memory access checker) says that deflate is</span>
<a href="#l4.302"></a><span id="l4.302" class="difflineplus">+    performing a conditional jump that depends on an uninitialized value.</span>
<a href="#l4.303"></a><span id="l4.303" class="difflineplus">+    Isn't that a bug?</span>
<a href="#l4.304"></a><span id="l4.304" class="difflineplus">+</span>
<a href="#l4.305"></a><span id="l4.305" class="difflineplus">+    No.  That is intentional for performance reasons, and the output of deflate</span>
<a href="#l4.306"></a><span id="l4.306" class="difflineplus">+    is not affected.  This only started showing up recently since zlib 1.2.x</span>
<a href="#l4.307"></a><span id="l4.307" class="difflineplus">+    uses malloc() by default for allocations, whereas earlier versions used</span>
<a href="#l4.308"></a><span id="l4.308" class="difflineplus">+    calloc(), which zeros out the allocated memory.  Even though the code was</span>
<a href="#l4.309"></a><span id="l4.309" class="difflineplus">+    correct, versions 1.2.4 and later was changed to not stimulate these</span>
<a href="#l4.310"></a><span id="l4.310" class="difflineplus">+    checkers.</span>
<a href="#l4.311"></a><span id="l4.311" class="difflineplus">+</span>
<a href="#l4.312"></a><span id="l4.312" class="difflineplus">+37. Will zlib read the (insert any ancient or arcane format here) compressed</span>
<a href="#l4.313"></a><span id="l4.313" class="difflineplus">+    data format?</span>
<a href="#l4.314"></a><span id="l4.314" class="difflineplus">+</span>
<a href="#l4.315"></a><span id="l4.315" class="difflineplus">+    Probably not. Look in the comp.compression FAQ for pointers to various</span>
<a href="#l4.316"></a><span id="l4.316" class="difflineplus">+    formats and associated software.</span>
<a href="#l4.317"></a><span id="l4.317" class="difflineplus">+</span>
<a href="#l4.318"></a><span id="l4.318" class="difflineplus">+38. How can I encrypt/decrypt zip files with zlib?</span>
<a href="#l4.319"></a><span id="l4.319" class="difflineplus">+</span>
<a href="#l4.320"></a><span id="l4.320" class="difflineplus">+    zlib doesn't support encryption.  The original PKZIP encryption is very</span>
<a href="#l4.321"></a><span id="l4.321" class="difflineplus">+    weak and can be broken with freely available programs.  To get strong</span>
<a href="#l4.322"></a><span id="l4.322" class="difflineplus">+    encryption, use GnuPG, http://www.gnupg.org/ , which already includes zlib</span>
<a href="#l4.323"></a><span id="l4.323" class="difflineplus">+    compression.  For PKZIP compatible &quot;encryption&quot;, look at</span>
<a href="#l4.324"></a><span id="l4.324" class="difflineplus">+    http://www.info-zip.org/</span>
<a href="#l4.325"></a><span id="l4.325" class="difflineplus">+</span>
<a href="#l4.326"></a><span id="l4.326" class="difflineplus">+39. What's the difference between the &quot;gzip&quot; and &quot;deflate&quot; HTTP 1.1 encodings?</span>
<a href="#l4.327"></a><span id="l4.327" class="difflineplus">+</span>
<a href="#l4.328"></a><span id="l4.328" class="difflineplus">+    &quot;gzip&quot; is the gzip format, and &quot;deflate&quot; is the zlib format.  They should</span>
<a href="#l4.329"></a><span id="l4.329" class="difflineplus">+    probably have called the second one &quot;zlib&quot; instead to avoid confusion with</span>
<a href="#l4.330"></a><span id="l4.330" class="difflineplus">+    the raw deflate compressed data format.  While the HTTP 1.1 RFC 2616</span>
<a href="#l4.331"></a><span id="l4.331" class="difflineplus">+    correctly points to the zlib specification in RFC 1950 for the &quot;deflate&quot;</span>
<a href="#l4.332"></a><span id="l4.332" class="difflineplus">+    transfer encoding, there have been reports of servers and browsers that</span>
<a href="#l4.333"></a><span id="l4.333" class="difflineplus">+    incorrectly produce or expect raw deflate data per the deflate</span>
<a href="#l4.334"></a><span id="l4.334" class="difflineplus">+    specification in RFC 1951, most notably Microsoft.  So even though the</span>
<a href="#l4.335"></a><span id="l4.335" class="difflineplus">+    &quot;deflate&quot; transfer encoding using the zlib format would be the more</span>
<a href="#l4.336"></a><span id="l4.336" class="difflineplus">+    efficient approach (and in fact exactly what the zlib format was designed</span>
<a href="#l4.337"></a><span id="l4.337" class="difflineplus">+    for), using the &quot;gzip&quot; transfer encoding is probably more reliable due to</span>
<a href="#l4.338"></a><span id="l4.338" class="difflineplus">+    an unfortunate choice of name on the part of the HTTP 1.1 authors.</span>
<a href="#l4.339"></a><span id="l4.339" class="difflineplus">+</span>
<a href="#l4.340"></a><span id="l4.340" class="difflineplus">+    Bottom line: use the gzip format for HTTP 1.1 encoding.</span>
<a href="#l4.341"></a><span id="l4.341" class="difflineplus">+</span>
<a href="#l4.342"></a><span id="l4.342" class="difflineplus">+40. Does zlib support the new &quot;Deflate64&quot; format introduced by PKWare?</span>
<a href="#l4.343"></a><span id="l4.343" class="difflineplus">+</span>
<a href="#l4.344"></a><span id="l4.344" class="difflineplus">+    No.  PKWare has apparently decided to keep that format proprietary, since</span>
<a href="#l4.345"></a><span id="l4.345" class="difflineplus">+    they have not documented it as they have previous compression formats.  In</span>
<a href="#l4.346"></a><span id="l4.346" class="difflineplus">+    any case, the compression improvements are so modest compared to other more</span>
<a href="#l4.347"></a><span id="l4.347" class="difflineplus">+    modern approaches, that it's not worth the effort to implement.</span>
<a href="#l4.348"></a><span id="l4.348" class="difflineplus">+</span>
<a href="#l4.349"></a><span id="l4.349" class="difflineplus">+41. I'm having a problem with the zip functions in zlib, can you help?</span>
<a href="#l4.350"></a><span id="l4.350" class="difflineplus">+</span>
<a href="#l4.351"></a><span id="l4.351" class="difflineplus">+    There are no zip functions in zlib.  You are probably using minizip by</span>
<a href="#l4.352"></a><span id="l4.352" class="difflineplus">+    Giles Vollant, which is found in the contrib directory of zlib.  It is not</span>
<a href="#l4.353"></a><span id="l4.353" class="difflineplus">+    part of zlib.  In fact none of the stuff in contrib is part of zlib.  The</span>
<a href="#l4.354"></a><span id="l4.354" class="difflineplus">+    files in there are not supported by the zlib authors.  You need to contact</span>
<a href="#l4.355"></a><span id="l4.355" class="difflineplus">+    the authors of the respective contribution for help.</span>
<a href="#l4.356"></a><span id="l4.356" class="difflineplus">+</span>
<a href="#l4.357"></a><span id="l4.357" class="difflineplus">+42. The match.asm code in contrib is under the GNU General Public License.</span>
<a href="#l4.358"></a><span id="l4.358" class="difflineplus">+    Since it's part of zlib, doesn't that mean that all of zlib falls under the</span>
<a href="#l4.359"></a><span id="l4.359" class="difflineplus">+    GNU GPL?</span>
<a href="#l4.360"></a><span id="l4.360" class="difflineplus">+</span>
<a href="#l4.361"></a><span id="l4.361" class="difflineplus">+    No.  The files in contrib are not part of zlib.  They were contributed by</span>
<a href="#l4.362"></a><span id="l4.362" class="difflineplus">+    other authors and are provided as a convenience to the user within the zlib</span>
<a href="#l4.363"></a><span id="l4.363" class="difflineplus">+    distribution.  Each item in contrib has its own license.</span>
<a href="#l4.364"></a><span id="l4.364" class="difflineplus">+</span>
<a href="#l4.365"></a><span id="l4.365" class="difflineplus">+43. Is zlib subject to export controls?  What is its ECCN?</span>
<a href="#l4.366"></a><span id="l4.366" class="difflineplus">+</span>
<a href="#l4.367"></a><span id="l4.367" class="difflineplus">+    zlib is not subject to export controls, and so is classified as EAR99.</span>
<a href="#l4.368"></a><span id="l4.368" class="difflineplus">+</span>
<a href="#l4.369"></a><span id="l4.369" class="difflineplus">+44. Can you please sign these lengthy legal documents and fax them back to us</span>
<a href="#l4.370"></a><span id="l4.370" class="difflineplus">+    so that we can use your software in our product?</span>
<a href="#l4.371"></a><span id="l4.371" class="difflineplus">+</span>
<a href="#l4.372"></a><span id="l4.372" class="difflineplus">+    No. Go away. Shoo.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1">new file mode 100644</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineminus">--- /dev/null</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineplus">+++ b/third_party/zlib/INDEX</span>
<a href="#l5.4"></a><span id="l5.4" class="difflineat">@@ -0,0 +1,68 @@</span>
<a href="#l5.5"></a><span id="l5.5" class="difflineplus">+CMakeLists.txt  cmake build file</span>
<a href="#l5.6"></a><span id="l5.6" class="difflineplus">+ChangeLog       history of changes</span>
<a href="#l5.7"></a><span id="l5.7" class="difflineplus">+FAQ             Frequently Asked Questions about zlib</span>
<a href="#l5.8"></a><span id="l5.8" class="difflineplus">+INDEX           this file</span>
<a href="#l5.9"></a><span id="l5.9" class="difflineplus">+Makefile        dummy Makefile that tells you to ./configure</span>
<a href="#l5.10"></a><span id="l5.10" class="difflineplus">+Makefile.in     template for Unix Makefile</span>
<a href="#l5.11"></a><span id="l5.11" class="difflineplus">+README          guess what</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+configure       configure script for Unix</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+make_vms.com    makefile for VMS</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+test/example.c  zlib usages examples for build testing</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+test/minigzip.c minimal gzip-like functionality for build testing</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineplus">+test/infcover.c inf*.c code coverage for build coverage testing</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineplus">+treebuild.xml   XML description of source file dependencies</span>
<a href="#l5.18"></a><span id="l5.18" class="difflineplus">+zconf.h.cmakein zconf.h template for cmake</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineplus">+zconf.h.in      zconf.h template for configure</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineplus">+zlib.3          Man page for zlib</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+zlib.3.pdf      Man page in PDF format</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+zlib.map        Linux symbol information</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+zlib.pc.in      Template for pkg-config descriptor</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineplus">+zlib.pc.cmakein zlib.pc template for cmake</span>
<a href="#l5.25"></a><span id="l5.25" class="difflineplus">+zlib2ansi       perl script to convert source files for C++ compilation</span>
<a href="#l5.26"></a><span id="l5.26" class="difflineplus">+</span>
<a href="#l5.27"></a><span id="l5.27" class="difflineplus">+amiga/          makefiles for Amiga SAS C</span>
<a href="#l5.28"></a><span id="l5.28" class="difflineplus">+as400/          makefiles for AS/400</span>
<a href="#l5.29"></a><span id="l5.29" class="difflineplus">+doc/            documentation for formats and algorithms</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineplus">+msdos/          makefiles for MSDOS</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineplus">+nintendods/     makefile for Nintendo DS</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+old/            makefiles for various architectures and zlib documentation</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineplus">+                files that have not yet been updated for zlib 1.2.x</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+qnx/            makefiles for QNX</span>
<a href="#l5.35"></a><span id="l5.35" class="difflineplus">+watcom/         makefiles for OpenWatcom</span>
<a href="#l5.36"></a><span id="l5.36" class="difflineplus">+win32/          makefiles for Windows</span>
<a href="#l5.37"></a><span id="l5.37" class="difflineplus">+</span>
<a href="#l5.38"></a><span id="l5.38" class="difflineplus">+                zlib public header files (required for library use):</span>
<a href="#l5.39"></a><span id="l5.39" class="difflineplus">+zconf.h</span>
<a href="#l5.40"></a><span id="l5.40" class="difflineplus">+zlib.h</span>
<a href="#l5.41"></a><span id="l5.41" class="difflineplus">+</span>
<a href="#l5.42"></a><span id="l5.42" class="difflineplus">+                private source files used to build the zlib library:</span>
<a href="#l5.43"></a><span id="l5.43" class="difflineplus">+adler32.c</span>
<a href="#l5.44"></a><span id="l5.44" class="difflineplus">+compress.c</span>
<a href="#l5.45"></a><span id="l5.45" class="difflineplus">+crc32.c</span>
<a href="#l5.46"></a><span id="l5.46" class="difflineplus">+crc32.h</span>
<a href="#l5.47"></a><span id="l5.47" class="difflineplus">+deflate.c</span>
<a href="#l5.48"></a><span id="l5.48" class="difflineplus">+deflate.h</span>
<a href="#l5.49"></a><span id="l5.49" class="difflineplus">+gzclose.c</span>
<a href="#l5.50"></a><span id="l5.50" class="difflineplus">+gzguts.h</span>
<a href="#l5.51"></a><span id="l5.51" class="difflineplus">+gzlib.c</span>
<a href="#l5.52"></a><span id="l5.52" class="difflineplus">+gzread.c</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineplus">+gzwrite.c</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineplus">+infback.c</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineplus">+inffast.c</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+inffast.h</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+inffixed.h</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineplus">+inflate.c</span>
<a href="#l5.59"></a><span id="l5.59" class="difflineplus">+inflate.h</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineplus">+inftrees.c</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineplus">+inftrees.h</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineplus">+trees.c</span>
<a href="#l5.63"></a><span id="l5.63" class="difflineplus">+trees.h</span>
<a href="#l5.64"></a><span id="l5.64" class="difflineplus">+uncompr.c</span>
<a href="#l5.65"></a><span id="l5.65" class="difflineplus">+zutil.c</span>
<a href="#l5.66"></a><span id="l5.66" class="difflineplus">+zutil.h</span>
<a href="#l5.67"></a><span id="l5.67" class="difflineplus">+</span>
<a href="#l5.68"></a><span id="l5.68" class="difflineplus">+                source files for sample programs</span>
<a href="#l5.69"></a><span id="l5.69" class="difflineplus">+See examples/README.examples</span>
<a href="#l5.70"></a><span id="l5.70" class="difflineplus">+</span>
<a href="#l5.71"></a><span id="l5.71" class="difflineplus">+                unsupported contributions by third parties</span>
<a href="#l5.72"></a><span id="l5.72" class="difflineplus">+See contrib/README.contrib</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1">new file mode 100644</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineminus">--- /dev/null</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineplus">+++ b/third_party/zlib/README</span>
<a href="#l6.4"></a><span id="l6.4" class="difflineat">@@ -0,0 +1,115 @@</span>
<a href="#l6.5"></a><span id="l6.5" class="difflineplus">+ZLIB DATA COMPRESSION LIBRARY</span>
<a href="#l6.6"></a><span id="l6.6" class="difflineplus">+</span>
<a href="#l6.7"></a><span id="l6.7" class="difflineplus">+zlib 1.2.11 is a general purpose data compression library.  All the code is</span>
<a href="#l6.8"></a><span id="l6.8" class="difflineplus">+thread safe.  The data format used by the zlib library is described by RFCs</span>
<a href="#l6.9"></a><span id="l6.9" class="difflineplus">+(Request for Comments) 1950 to 1952 in the files</span>
<a href="#l6.10"></a><span id="l6.10" class="difflineplus">+http://tools.ietf.org/html/rfc1950 (zlib format), rfc1951 (deflate format) and</span>
<a href="#l6.11"></a><span id="l6.11" class="difflineplus">+rfc1952 (gzip format).</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+All functions of the compression library are documented in the file zlib.h</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+(volunteer to write man pages welcome, contact zlib@gzip.org).  A usage example</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+of the library is given in the file test/example.c which also tests that</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+the library is working correctly.  Another example is given in the file</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineplus">+test/minigzip.c.  The compression library itself is composed of all source</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+files in the root directory.</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineplus">+To compile all files and run the test program, follow the instructions given at</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineplus">+the top of Makefile.in.  In short &quot;./configure; make test&quot;, and if that goes</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineplus">+well, &quot;make install&quot; should work for most flavors of Unix.  For Windows, use</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineplus">+one of the special makefiles in win32/ or contrib/vstudio/ .  For VMS, use</span>
<a href="#l6.24"></a><span id="l6.24" class="difflineplus">+make_vms.com.</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineplus">+</span>
<a href="#l6.26"></a><span id="l6.26" class="difflineplus">+Questions about zlib should be sent to &lt;zlib@gzip.org&gt;, or to Gilles Vollant</span>
<a href="#l6.27"></a><span id="l6.27" class="difflineplus">+&lt;info@winimage.com&gt; for the Windows DLL version.  The zlib home page is</span>
<a href="#l6.28"></a><span id="l6.28" class="difflineplus">+http://zlib.net/ .  Before reporting a problem, please check this site to</span>
<a href="#l6.29"></a><span id="l6.29" class="difflineplus">+verify that you have the latest version of zlib; otherwise get the latest</span>
<a href="#l6.30"></a><span id="l6.30" class="difflineplus">+version and check whether the problem still exists or not.</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineplus">+</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+PLEASE read the zlib FAQ http://zlib.net/zlib_faq.html before asking for help.</span>
<a href="#l6.33"></a><span id="l6.33" class="difflineplus">+</span>
<a href="#l6.34"></a><span id="l6.34" class="difflineplus">+Mark Nelson &lt;markn@ieee.org&gt; wrote an article about zlib for the Jan.  1997</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineplus">+issue of Dr.  Dobb's Journal; a copy of the article is available at</span>
<a href="#l6.36"></a><span id="l6.36" class="difflineplus">+http://marknelson.us/1997/01/01/zlib-engine/ .</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineplus">+</span>
<a href="#l6.38"></a><span id="l6.38" class="difflineplus">+The changes made in version 1.2.11 are documented in the file ChangeLog.</span>
<a href="#l6.39"></a><span id="l6.39" class="difflineplus">+</span>
<a href="#l6.40"></a><span id="l6.40" class="difflineplus">+Unsupported third party contributions are provided in directory contrib/ .</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineplus">+</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineplus">+zlib is available in Java using the java.util.zip package, documented at</span>
<a href="#l6.43"></a><span id="l6.43" class="difflineplus">+http://java.sun.com/developer/technicalArticles/Programming/compression/ .</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineplus">+</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineplus">+A Perl interface to zlib written by Paul Marquess &lt;pmqs@cpan.org&gt; is available</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineplus">+at CPAN (Comprehensive Perl Archive Network) sites, including</span>
<a href="#l6.47"></a><span id="l6.47" class="difflineplus">+http://search.cpan.org/~pmqs/IO-Compress-Zlib/ .</span>
<a href="#l6.48"></a><span id="l6.48" class="difflineplus">+</span>
<a href="#l6.49"></a><span id="l6.49" class="difflineplus">+A Python interface to zlib written by A.M. Kuchling &lt;amk@amk.ca&gt; is</span>
<a href="#l6.50"></a><span id="l6.50" class="difflineplus">+available in Python 1.5 and later versions, see</span>
<a href="#l6.51"></a><span id="l6.51" class="difflineplus">+http://docs.python.org/library/zlib.html .</span>
<a href="#l6.52"></a><span id="l6.52" class="difflineplus">+</span>
<a href="#l6.53"></a><span id="l6.53" class="difflineplus">+zlib is built into tcl: http://wiki.tcl.tk/4610 .</span>
<a href="#l6.54"></a><span id="l6.54" class="difflineplus">+</span>
<a href="#l6.55"></a><span id="l6.55" class="difflineplus">+An experimental package to read and write files in .zip format, written on top</span>
<a href="#l6.56"></a><span id="l6.56" class="difflineplus">+of zlib by Gilles Vollant &lt;info@winimage.com&gt;, is available in the</span>
<a href="#l6.57"></a><span id="l6.57" class="difflineplus">+contrib/minizip directory of zlib.</span>
<a href="#l6.58"></a><span id="l6.58" class="difflineplus">+</span>
<a href="#l6.59"></a><span id="l6.59" class="difflineplus">+</span>
<a href="#l6.60"></a><span id="l6.60" class="difflineplus">+Notes for some targets:</span>
<a href="#l6.61"></a><span id="l6.61" class="difflineplus">+</span>
<a href="#l6.62"></a><span id="l6.62" class="difflineplus">+- For Windows DLL versions, please see win32/DLL_FAQ.txt</span>
<a href="#l6.63"></a><span id="l6.63" class="difflineplus">+</span>
<a href="#l6.64"></a><span id="l6.64" class="difflineplus">+- For 64-bit Irix, deflate.c must be compiled without any optimization. With</span>
<a href="#l6.65"></a><span id="l6.65" class="difflineplus">+  -O, one libpng test fails. The test works in 32 bit mode (with the -n32</span>
<a href="#l6.66"></a><span id="l6.66" class="difflineplus">+  compiler flag). The compiler bug has been reported to SGI.</span>
<a href="#l6.67"></a><span id="l6.67" class="difflineplus">+</span>
<a href="#l6.68"></a><span id="l6.68" class="difflineplus">+- zlib doesn't work with gcc 2.6.3 on a DEC 3000/300LX under OSF/1 2.1 it works</span>
<a href="#l6.69"></a><span id="l6.69" class="difflineplus">+  when compiled with cc.</span>
<a href="#l6.70"></a><span id="l6.70" class="difflineplus">+</span>
<a href="#l6.71"></a><span id="l6.71" class="difflineplus">+- On Digital Unix 4.0D (formely OSF/1) on AlphaServer, the cc option -std1 is</span>
<a href="#l6.72"></a><span id="l6.72" class="difflineplus">+  necessary to get gzprintf working correctly. This is done by configure.</span>
<a href="#l6.73"></a><span id="l6.73" class="difflineplus">+</span>
<a href="#l6.74"></a><span id="l6.74" class="difflineplus">+- zlib doesn't work on HP-UX 9.05 with some versions of /bin/cc. It works with</span>
<a href="#l6.75"></a><span id="l6.75" class="difflineplus">+  other compilers. Use &quot;make test&quot; to check your compiler.</span>
<a href="#l6.76"></a><span id="l6.76" class="difflineplus">+</span>
<a href="#l6.77"></a><span id="l6.77" class="difflineplus">+- gzdopen is not supported on RISCOS or BEOS.</span>
<a href="#l6.78"></a><span id="l6.78" class="difflineplus">+</span>
<a href="#l6.79"></a><span id="l6.79" class="difflineplus">+- For PalmOs, see http://palmzlib.sourceforge.net/</span>
<a href="#l6.80"></a><span id="l6.80" class="difflineplus">+</span>
<a href="#l6.81"></a><span id="l6.81" class="difflineplus">+</span>
<a href="#l6.82"></a><span id="l6.82" class="difflineplus">+Acknowledgments:</span>
<a href="#l6.83"></a><span id="l6.83" class="difflineplus">+</span>
<a href="#l6.84"></a><span id="l6.84" class="difflineplus">+  The deflate format used by zlib was defined by Phil Katz.  The deflate and</span>
<a href="#l6.85"></a><span id="l6.85" class="difflineplus">+  zlib specifications were written by L.  Peter Deutsch.  Thanks to all the</span>
<a href="#l6.86"></a><span id="l6.86" class="difflineplus">+  people who reported problems and suggested various improvements in zlib; they</span>
<a href="#l6.87"></a><span id="l6.87" class="difflineplus">+  are too numerous to cite here.</span>
<a href="#l6.88"></a><span id="l6.88" class="difflineplus">+</span>
<a href="#l6.89"></a><span id="l6.89" class="difflineplus">+Copyright notice:</span>
<a href="#l6.90"></a><span id="l6.90" class="difflineplus">+</span>
<a href="#l6.91"></a><span id="l6.91" class="difflineplus">+ (C) 1995-2017 Jean-loup Gailly and Mark Adler</span>
<a href="#l6.92"></a><span id="l6.92" class="difflineplus">+</span>
<a href="#l6.93"></a><span id="l6.93" class="difflineplus">+  This software is provided 'as-is', without any express or implied</span>
<a href="#l6.94"></a><span id="l6.94" class="difflineplus">+  warranty.  In no event will the authors be held liable for any damages</span>
<a href="#l6.95"></a><span id="l6.95" class="difflineplus">+  arising from the use of this software.</span>
<a href="#l6.96"></a><span id="l6.96" class="difflineplus">+</span>
<a href="#l6.97"></a><span id="l6.97" class="difflineplus">+  Permission is granted to anyone to use this software for any purpose,</span>
<a href="#l6.98"></a><span id="l6.98" class="difflineplus">+  including commercial applications, and to alter it and redistribute it</span>
<a href="#l6.99"></a><span id="l6.99" class="difflineplus">+  freely, subject to the following restrictions:</span>
<a href="#l6.100"></a><span id="l6.100" class="difflineplus">+</span>
<a href="#l6.101"></a><span id="l6.101" class="difflineplus">+  1. The origin of this software must not be misrepresented; you must not</span>
<a href="#l6.102"></a><span id="l6.102" class="difflineplus">+     claim that you wrote the original software. If you use this software</span>
<a href="#l6.103"></a><span id="l6.103" class="difflineplus">+     in a product, an acknowledgment in the product documentation would be</span>
<a href="#l6.104"></a><span id="l6.104" class="difflineplus">+     appreciated but is not required.</span>
<a href="#l6.105"></a><span id="l6.105" class="difflineplus">+  2. Altered source versions must be plainly marked as such, and must not be</span>
<a href="#l6.106"></a><span id="l6.106" class="difflineplus">+     misrepresented as being the original software.</span>
<a href="#l6.107"></a><span id="l6.107" class="difflineplus">+  3. This notice may not be removed or altered from any source distribution.</span>
<a href="#l6.108"></a><span id="l6.108" class="difflineplus">+</span>
<a href="#l6.109"></a><span id="l6.109" class="difflineplus">+  Jean-loup Gailly        Mark Adler</span>
<a href="#l6.110"></a><span id="l6.110" class="difflineplus">+  jloup@gzip.org          madler@alumni.caltech.edu</span>
<a href="#l6.111"></a><span id="l6.111" class="difflineplus">+</span>
<a href="#l6.112"></a><span id="l6.112" class="difflineplus">+If you use the zlib library in a product, we would appreciate *not* receiving</span>
<a href="#l6.113"></a><span id="l6.113" class="difflineplus">+lengthy legal documents to sign.  The sources are provided for free but without</span>
<a href="#l6.114"></a><span id="l6.114" class="difflineplus">+warranty of any kind.  The library has been entirely written by Jean-loup</span>
<a href="#l6.115"></a><span id="l6.115" class="difflineplus">+Gailly and Mark Adler; it does not include third-party code.</span>
<a href="#l6.116"></a><span id="l6.116" class="difflineplus">+</span>
<a href="#l6.117"></a><span id="l6.117" class="difflineplus">+If you redistribute modified sources, we would appreciate that you include in</span>
<a href="#l6.118"></a><span id="l6.118" class="difflineplus">+the file ChangeLog history information documenting your changes.  Please read</span>
<a href="#l6.119"></a><span id="l6.119" class="difflineplus">+the FAQ for more information on the distribution of modified source versions.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1">new file mode 100644</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineminus">--- /dev/null</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineplus">+++ b/third_party/zlib/adler32.c</span>
<a href="#l7.4"></a><span id="l7.4" class="difflineat">@@ -0,0 +1,186 @@</span>
<a href="#l7.5"></a><span id="l7.5" class="difflineplus">+/* adler32.c -- compute the Adler-32 checksum of a data stream</span>
<a href="#l7.6"></a><span id="l7.6" class="difflineplus">+ * Copyright (C) 1995-2011, 2016 Mark Adler</span>
<a href="#l7.7"></a><span id="l7.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l7.8"></a><span id="l7.8" class="difflineplus">+ */</span>
<a href="#l7.9"></a><span id="l7.9" class="difflineplus">+</span>
<a href="#l7.10"></a><span id="l7.10" class="difflineplus">+/* @(#) $Id$ */</span>
<a href="#l7.11"></a><span id="l7.11" class="difflineplus">+</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineplus">+#include &quot;zutil.h&quot;</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+local uLong adler32_combine_ OF((uLong adler1, uLong adler2, z_off64_t len2));</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+</span>
<a href="#l7.16"></a><span id="l7.16" class="difflineplus">+#define BASE 65521U     /* largest prime smaller than 65536 */</span>
<a href="#l7.17"></a><span id="l7.17" class="difflineplus">+#define NMAX 5552</span>
<a href="#l7.18"></a><span id="l7.18" class="difflineplus">+/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) &lt;= 2^32-1 */</span>
<a href="#l7.19"></a><span id="l7.19" class="difflineplus">+</span>
<a href="#l7.20"></a><span id="l7.20" class="difflineplus">+#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}</span>
<a href="#l7.21"></a><span id="l7.21" class="difflineplus">+#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineplus">+#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);</span>
<a href="#l7.23"></a><span id="l7.23" class="difflineplus">+#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);</span>
<a href="#l7.24"></a><span id="l7.24" class="difflineplus">+#define DO16(buf)   DO8(buf,0); DO8(buf,8);</span>
<a href="#l7.25"></a><span id="l7.25" class="difflineplus">+</span>
<a href="#l7.26"></a><span id="l7.26" class="difflineplus">+/* use NO_DIVIDE if your processor does not do division in hardware --</span>
<a href="#l7.27"></a><span id="l7.27" class="difflineplus">+   try it both ways to see which is faster */</span>
<a href="#l7.28"></a><span id="l7.28" class="difflineplus">+#ifdef NO_DIVIDE</span>
<a href="#l7.29"></a><span id="l7.29" class="difflineplus">+/* note that this assumes BASE is 65521, where 65536 % 65521 == 15</span>
<a href="#l7.30"></a><span id="l7.30" class="difflineplus">+   (thank you to John Reiser for pointing this out) */</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineplus">+#  define CHOP(a) \</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+    do { \</span>
<a href="#l7.33"></a><span id="l7.33" class="difflineplus">+        unsigned long tmp = a &gt;&gt; 16; \</span>
<a href="#l7.34"></a><span id="l7.34" class="difflineplus">+        a &amp;= 0xffffUL; \</span>
<a href="#l7.35"></a><span id="l7.35" class="difflineplus">+        a += (tmp &lt;&lt; 4) - tmp; \</span>
<a href="#l7.36"></a><span id="l7.36" class="difflineplus">+    } while (0)</span>
<a href="#l7.37"></a><span id="l7.37" class="difflineplus">+#  define MOD28(a) \</span>
<a href="#l7.38"></a><span id="l7.38" class="difflineplus">+    do { \</span>
<a href="#l7.39"></a><span id="l7.39" class="difflineplus">+        CHOP(a); \</span>
<a href="#l7.40"></a><span id="l7.40" class="difflineplus">+        if (a &gt;= BASE) a -= BASE; \</span>
<a href="#l7.41"></a><span id="l7.41" class="difflineplus">+    } while (0)</span>
<a href="#l7.42"></a><span id="l7.42" class="difflineplus">+#  define MOD(a) \</span>
<a href="#l7.43"></a><span id="l7.43" class="difflineplus">+    do { \</span>
<a href="#l7.44"></a><span id="l7.44" class="difflineplus">+        CHOP(a); \</span>
<a href="#l7.45"></a><span id="l7.45" class="difflineplus">+        MOD28(a); \</span>
<a href="#l7.46"></a><span id="l7.46" class="difflineplus">+    } while (0)</span>
<a href="#l7.47"></a><span id="l7.47" class="difflineplus">+#  define MOD63(a) \</span>
<a href="#l7.48"></a><span id="l7.48" class="difflineplus">+    do { /* this assumes a is not negative */ \</span>
<a href="#l7.49"></a><span id="l7.49" class="difflineplus">+        z_off64_t tmp = a &gt;&gt; 32; \</span>
<a href="#l7.50"></a><span id="l7.50" class="difflineplus">+        a &amp;= 0xffffffffL; \</span>
<a href="#l7.51"></a><span id="l7.51" class="difflineplus">+        a += (tmp &lt;&lt; 8) - (tmp &lt;&lt; 5) + tmp; \</span>
<a href="#l7.52"></a><span id="l7.52" class="difflineplus">+        tmp = a &gt;&gt; 16; \</span>
<a href="#l7.53"></a><span id="l7.53" class="difflineplus">+        a &amp;= 0xffffL; \</span>
<a href="#l7.54"></a><span id="l7.54" class="difflineplus">+        a += (tmp &lt;&lt; 4) - tmp; \</span>
<a href="#l7.55"></a><span id="l7.55" class="difflineplus">+        tmp = a &gt;&gt; 16; \</span>
<a href="#l7.56"></a><span id="l7.56" class="difflineplus">+        a &amp;= 0xffffL; \</span>
<a href="#l7.57"></a><span id="l7.57" class="difflineplus">+        a += (tmp &lt;&lt; 4) - tmp; \</span>
<a href="#l7.58"></a><span id="l7.58" class="difflineplus">+        if (a &gt;= BASE) a -= BASE; \</span>
<a href="#l7.59"></a><span id="l7.59" class="difflineplus">+    } while (0)</span>
<a href="#l7.60"></a><span id="l7.60" class="difflineplus">+#else</span>
<a href="#l7.61"></a><span id="l7.61" class="difflineplus">+#  define MOD(a) a %= BASE</span>
<a href="#l7.62"></a><span id="l7.62" class="difflineplus">+#  define MOD28(a) a %= BASE</span>
<a href="#l7.63"></a><span id="l7.63" class="difflineplus">+#  define MOD63(a) a %= BASE</span>
<a href="#l7.64"></a><span id="l7.64" class="difflineplus">+#endif</span>
<a href="#l7.65"></a><span id="l7.65" class="difflineplus">+</span>
<a href="#l7.66"></a><span id="l7.66" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l7.67"></a><span id="l7.67" class="difflineplus">+uLong ZEXPORT adler32_z(adler, buf, len)</span>
<a href="#l7.68"></a><span id="l7.68" class="difflineplus">+    uLong adler;</span>
<a href="#l7.69"></a><span id="l7.69" class="difflineplus">+    const Bytef *buf;</span>
<a href="#l7.70"></a><span id="l7.70" class="difflineplus">+    z_size_t len;</span>
<a href="#l7.71"></a><span id="l7.71" class="difflineplus">+{</span>
<a href="#l7.72"></a><span id="l7.72" class="difflineplus">+    unsigned long sum2;</span>
<a href="#l7.73"></a><span id="l7.73" class="difflineplus">+    unsigned n;</span>
<a href="#l7.74"></a><span id="l7.74" class="difflineplus">+</span>
<a href="#l7.75"></a><span id="l7.75" class="difflineplus">+    /* split Adler-32 into component sums */</span>
<a href="#l7.76"></a><span id="l7.76" class="difflineplus">+    sum2 = (adler &gt;&gt; 16) &amp; 0xffff;</span>
<a href="#l7.77"></a><span id="l7.77" class="difflineplus">+    adler &amp;= 0xffff;</span>
<a href="#l7.78"></a><span id="l7.78" class="difflineplus">+</span>
<a href="#l7.79"></a><span id="l7.79" class="difflineplus">+    /* in case user likes doing a byte at a time, keep it fast */</span>
<a href="#l7.80"></a><span id="l7.80" class="difflineplus">+    if (len == 1) {</span>
<a href="#l7.81"></a><span id="l7.81" class="difflineplus">+        adler += buf[0];</span>
<a href="#l7.82"></a><span id="l7.82" class="difflineplus">+        if (adler &gt;= BASE)</span>
<a href="#l7.83"></a><span id="l7.83" class="difflineplus">+            adler -= BASE;</span>
<a href="#l7.84"></a><span id="l7.84" class="difflineplus">+        sum2 += adler;</span>
<a href="#l7.85"></a><span id="l7.85" class="difflineplus">+        if (sum2 &gt;= BASE)</span>
<a href="#l7.86"></a><span id="l7.86" class="difflineplus">+            sum2 -= BASE;</span>
<a href="#l7.87"></a><span id="l7.87" class="difflineplus">+        return adler | (sum2 &lt;&lt; 16);</span>
<a href="#l7.88"></a><span id="l7.88" class="difflineplus">+    }</span>
<a href="#l7.89"></a><span id="l7.89" class="difflineplus">+</span>
<a href="#l7.90"></a><span id="l7.90" class="difflineplus">+    /* initial Adler-32 value (deferred check for len == 1 speed) */</span>
<a href="#l7.91"></a><span id="l7.91" class="difflineplus">+    if (buf == Z_NULL)</span>
<a href="#l7.92"></a><span id="l7.92" class="difflineplus">+        return 1L;</span>
<a href="#l7.93"></a><span id="l7.93" class="difflineplus">+</span>
<a href="#l7.94"></a><span id="l7.94" class="difflineplus">+    /* in case short lengths are provided, keep it somewhat fast */</span>
<a href="#l7.95"></a><span id="l7.95" class="difflineplus">+    if (len &lt; 16) {</span>
<a href="#l7.96"></a><span id="l7.96" class="difflineplus">+        while (len--) {</span>
<a href="#l7.97"></a><span id="l7.97" class="difflineplus">+            adler += *buf++;</span>
<a href="#l7.98"></a><span id="l7.98" class="difflineplus">+            sum2 += adler;</span>
<a href="#l7.99"></a><span id="l7.99" class="difflineplus">+        }</span>
<a href="#l7.100"></a><span id="l7.100" class="difflineplus">+        if (adler &gt;= BASE)</span>
<a href="#l7.101"></a><span id="l7.101" class="difflineplus">+            adler -= BASE;</span>
<a href="#l7.102"></a><span id="l7.102" class="difflineplus">+        MOD28(sum2);            /* only added so many BASE's */</span>
<a href="#l7.103"></a><span id="l7.103" class="difflineplus">+        return adler | (sum2 &lt;&lt; 16);</span>
<a href="#l7.104"></a><span id="l7.104" class="difflineplus">+    }</span>
<a href="#l7.105"></a><span id="l7.105" class="difflineplus">+</span>
<a href="#l7.106"></a><span id="l7.106" class="difflineplus">+    /* do length NMAX blocks -- requires just one modulo operation */</span>
<a href="#l7.107"></a><span id="l7.107" class="difflineplus">+    while (len &gt;= NMAX) {</span>
<a href="#l7.108"></a><span id="l7.108" class="difflineplus">+        len -= NMAX;</span>
<a href="#l7.109"></a><span id="l7.109" class="difflineplus">+        n = NMAX / 16;          /* NMAX is divisible by 16 */</span>
<a href="#l7.110"></a><span id="l7.110" class="difflineplus">+        do {</span>
<a href="#l7.111"></a><span id="l7.111" class="difflineplus">+            DO16(buf);          /* 16 sums unrolled */</span>
<a href="#l7.112"></a><span id="l7.112" class="difflineplus">+            buf += 16;</span>
<a href="#l7.113"></a><span id="l7.113" class="difflineplus">+        } while (--n);</span>
<a href="#l7.114"></a><span id="l7.114" class="difflineplus">+        MOD(adler);</span>
<a href="#l7.115"></a><span id="l7.115" class="difflineplus">+        MOD(sum2);</span>
<a href="#l7.116"></a><span id="l7.116" class="difflineplus">+    }</span>
<a href="#l7.117"></a><span id="l7.117" class="difflineplus">+</span>
<a href="#l7.118"></a><span id="l7.118" class="difflineplus">+    /* do remaining bytes (less than NMAX, still just one modulo) */</span>
<a href="#l7.119"></a><span id="l7.119" class="difflineplus">+    if (len) {                  /* avoid modulos if none remaining */</span>
<a href="#l7.120"></a><span id="l7.120" class="difflineplus">+        while (len &gt;= 16) {</span>
<a href="#l7.121"></a><span id="l7.121" class="difflineplus">+            len -= 16;</span>
<a href="#l7.122"></a><span id="l7.122" class="difflineplus">+            DO16(buf);</span>
<a href="#l7.123"></a><span id="l7.123" class="difflineplus">+            buf += 16;</span>
<a href="#l7.124"></a><span id="l7.124" class="difflineplus">+        }</span>
<a href="#l7.125"></a><span id="l7.125" class="difflineplus">+        while (len--) {</span>
<a href="#l7.126"></a><span id="l7.126" class="difflineplus">+            adler += *buf++;</span>
<a href="#l7.127"></a><span id="l7.127" class="difflineplus">+            sum2 += adler;</span>
<a href="#l7.128"></a><span id="l7.128" class="difflineplus">+        }</span>
<a href="#l7.129"></a><span id="l7.129" class="difflineplus">+        MOD(adler);</span>
<a href="#l7.130"></a><span id="l7.130" class="difflineplus">+        MOD(sum2);</span>
<a href="#l7.131"></a><span id="l7.131" class="difflineplus">+    }</span>
<a href="#l7.132"></a><span id="l7.132" class="difflineplus">+</span>
<a href="#l7.133"></a><span id="l7.133" class="difflineplus">+    /* return recombined sums */</span>
<a href="#l7.134"></a><span id="l7.134" class="difflineplus">+    return adler | (sum2 &lt;&lt; 16);</span>
<a href="#l7.135"></a><span id="l7.135" class="difflineplus">+}</span>
<a href="#l7.136"></a><span id="l7.136" class="difflineplus">+</span>
<a href="#l7.137"></a><span id="l7.137" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l7.138"></a><span id="l7.138" class="difflineplus">+uLong ZEXPORT adler32(adler, buf, len)</span>
<a href="#l7.139"></a><span id="l7.139" class="difflineplus">+    uLong adler;</span>
<a href="#l7.140"></a><span id="l7.140" class="difflineplus">+    const Bytef *buf;</span>
<a href="#l7.141"></a><span id="l7.141" class="difflineplus">+    uInt len;</span>
<a href="#l7.142"></a><span id="l7.142" class="difflineplus">+{</span>
<a href="#l7.143"></a><span id="l7.143" class="difflineplus">+    return adler32_z(adler, buf, len);</span>
<a href="#l7.144"></a><span id="l7.144" class="difflineplus">+}</span>
<a href="#l7.145"></a><span id="l7.145" class="difflineplus">+</span>
<a href="#l7.146"></a><span id="l7.146" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l7.147"></a><span id="l7.147" class="difflineplus">+local uLong adler32_combine_(adler1, adler2, len2)</span>
<a href="#l7.148"></a><span id="l7.148" class="difflineplus">+    uLong adler1;</span>
<a href="#l7.149"></a><span id="l7.149" class="difflineplus">+    uLong adler2;</span>
<a href="#l7.150"></a><span id="l7.150" class="difflineplus">+    z_off64_t len2;</span>
<a href="#l7.151"></a><span id="l7.151" class="difflineplus">+{</span>
<a href="#l7.152"></a><span id="l7.152" class="difflineplus">+    unsigned long sum1;</span>
<a href="#l7.153"></a><span id="l7.153" class="difflineplus">+    unsigned long sum2;</span>
<a href="#l7.154"></a><span id="l7.154" class="difflineplus">+    unsigned rem;</span>
<a href="#l7.155"></a><span id="l7.155" class="difflineplus">+</span>
<a href="#l7.156"></a><span id="l7.156" class="difflineplus">+    /* for negative len, return invalid adler32 as a clue for debugging */</span>
<a href="#l7.157"></a><span id="l7.157" class="difflineplus">+    if (len2 &lt; 0)</span>
<a href="#l7.158"></a><span id="l7.158" class="difflineplus">+        return 0xffffffffUL;</span>
<a href="#l7.159"></a><span id="l7.159" class="difflineplus">+</span>
<a href="#l7.160"></a><span id="l7.160" class="difflineplus">+    /* the derivation of this formula is left as an exercise for the reader */</span>
<a href="#l7.161"></a><span id="l7.161" class="difflineplus">+    MOD63(len2);                /* assumes len2 &gt;= 0 */</span>
<a href="#l7.162"></a><span id="l7.162" class="difflineplus">+    rem = (unsigned)len2;</span>
<a href="#l7.163"></a><span id="l7.163" class="difflineplus">+    sum1 = adler1 &amp; 0xffff;</span>
<a href="#l7.164"></a><span id="l7.164" class="difflineplus">+    sum2 = rem * sum1;</span>
<a href="#l7.165"></a><span id="l7.165" class="difflineplus">+    MOD(sum2);</span>
<a href="#l7.166"></a><span id="l7.166" class="difflineplus">+    sum1 += (adler2 &amp; 0xffff) + BASE - 1;</span>
<a href="#l7.167"></a><span id="l7.167" class="difflineplus">+    sum2 += ((adler1 &gt;&gt; 16) &amp; 0xffff) + ((adler2 &gt;&gt; 16) &amp; 0xffff) + BASE - rem;</span>
<a href="#l7.168"></a><span id="l7.168" class="difflineplus">+    if (sum1 &gt;= BASE) sum1 -= BASE;</span>
<a href="#l7.169"></a><span id="l7.169" class="difflineplus">+    if (sum1 &gt;= BASE) sum1 -= BASE;</span>
<a href="#l7.170"></a><span id="l7.170" class="difflineplus">+    if (sum2 &gt;= ((unsigned long)BASE &lt;&lt; 1)) sum2 -= ((unsigned long)BASE &lt;&lt; 1);</span>
<a href="#l7.171"></a><span id="l7.171" class="difflineplus">+    if (sum2 &gt;= BASE) sum2 -= BASE;</span>
<a href="#l7.172"></a><span id="l7.172" class="difflineplus">+    return sum1 | (sum2 &lt;&lt; 16);</span>
<a href="#l7.173"></a><span id="l7.173" class="difflineplus">+}</span>
<a href="#l7.174"></a><span id="l7.174" class="difflineplus">+</span>
<a href="#l7.175"></a><span id="l7.175" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l7.176"></a><span id="l7.176" class="difflineplus">+uLong ZEXPORT adler32_combine(adler1, adler2, len2)</span>
<a href="#l7.177"></a><span id="l7.177" class="difflineplus">+    uLong adler1;</span>
<a href="#l7.178"></a><span id="l7.178" class="difflineplus">+    uLong adler2;</span>
<a href="#l7.179"></a><span id="l7.179" class="difflineplus">+    z_off_t len2;</span>
<a href="#l7.180"></a><span id="l7.180" class="difflineplus">+{</span>
<a href="#l7.181"></a><span id="l7.181" class="difflineplus">+    return adler32_combine_(adler1, adler2, len2);</span>
<a href="#l7.182"></a><span id="l7.182" class="difflineplus">+}</span>
<a href="#l7.183"></a><span id="l7.183" class="difflineplus">+</span>
<a href="#l7.184"></a><span id="l7.184" class="difflineplus">+uLong ZEXPORT adler32_combine64(adler1, adler2, len2)</span>
<a href="#l7.185"></a><span id="l7.185" class="difflineplus">+    uLong adler1;</span>
<a href="#l7.186"></a><span id="l7.186" class="difflineplus">+    uLong adler2;</span>
<a href="#l7.187"></a><span id="l7.187" class="difflineplus">+    z_off64_t len2;</span>
<a href="#l7.188"></a><span id="l7.188" class="difflineplus">+{</span>
<a href="#l7.189"></a><span id="l7.189" class="difflineplus">+    return adler32_combine_(adler1, adler2, len2);</span>
<a href="#l7.190"></a><span id="l7.190" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1">new file mode 100644</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineminus">--- /dev/null</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineplus">+++ b/third_party/zlib/compress.c</span>
<a href="#l8.4"></a><span id="l8.4" class="difflineat">@@ -0,0 +1,86 @@</span>
<a href="#l8.5"></a><span id="l8.5" class="difflineplus">+/* compress.c -- compress a memory buffer</span>
<a href="#l8.6"></a><span id="l8.6" class="difflineplus">+ * Copyright (C) 1995-2005, 2014, 2016 Jean-loup Gailly, Mark Adler</span>
<a href="#l8.7"></a><span id="l8.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l8.8"></a><span id="l8.8" class="difflineplus">+ */</span>
<a href="#l8.9"></a><span id="l8.9" class="difflineplus">+</span>
<a href="#l8.10"></a><span id="l8.10" class="difflineplus">+/* @(#) $Id$ */</span>
<a href="#l8.11"></a><span id="l8.11" class="difflineplus">+</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+#define ZLIB_INTERNAL</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+#include &quot;zlib.h&quot;</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+/* ===========================================================================</span>
<a href="#l8.16"></a><span id="l8.16" class="difflineplus">+     Compresses the source buffer into the destination buffer. The level</span>
<a href="#l8.17"></a><span id="l8.17" class="difflineplus">+   parameter has the same meaning as in deflateInit.  sourceLen is the byte</span>
<a href="#l8.18"></a><span id="l8.18" class="difflineplus">+   length of the source buffer. Upon entry, destLen is the total size of the</span>
<a href="#l8.19"></a><span id="l8.19" class="difflineplus">+   destination buffer, which must be at least 0.1% larger than sourceLen plus</span>
<a href="#l8.20"></a><span id="l8.20" class="difflineplus">+   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineplus">+</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineplus">+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
<a href="#l8.23"></a><span id="l8.23" class="difflineplus">+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,</span>
<a href="#l8.24"></a><span id="l8.24" class="difflineplus">+   Z_STREAM_ERROR if the level parameter is invalid.</span>
<a href="#l8.25"></a><span id="l8.25" class="difflineplus">+*/</span>
<a href="#l8.26"></a><span id="l8.26" class="difflineplus">+int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)</span>
<a href="#l8.27"></a><span id="l8.27" class="difflineplus">+    Bytef *dest;</span>
<a href="#l8.28"></a><span id="l8.28" class="difflineplus">+    uLongf *destLen;</span>
<a href="#l8.29"></a><span id="l8.29" class="difflineplus">+    const Bytef *source;</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineplus">+    uLong sourceLen;</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineplus">+    int level;</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+{</span>
<a href="#l8.33"></a><span id="l8.33" class="difflineplus">+    z_stream stream;</span>
<a href="#l8.34"></a><span id="l8.34" class="difflineplus">+    int err;</span>
<a href="#l8.35"></a><span id="l8.35" class="difflineplus">+    const uInt max = (uInt)-1;</span>
<a href="#l8.36"></a><span id="l8.36" class="difflineplus">+    uLong left;</span>
<a href="#l8.37"></a><span id="l8.37" class="difflineplus">+</span>
<a href="#l8.38"></a><span id="l8.38" class="difflineplus">+    left = *destLen;</span>
<a href="#l8.39"></a><span id="l8.39" class="difflineplus">+    *destLen = 0;</span>
<a href="#l8.40"></a><span id="l8.40" class="difflineplus">+</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineplus">+    stream.zalloc = (alloc_func)0;</span>
<a href="#l8.42"></a><span id="l8.42" class="difflineplus">+    stream.zfree = (free_func)0;</span>
<a href="#l8.43"></a><span id="l8.43" class="difflineplus">+    stream.opaque = (voidpf)0;</span>
<a href="#l8.44"></a><span id="l8.44" class="difflineplus">+</span>
<a href="#l8.45"></a><span id="l8.45" class="difflineplus">+    err = deflateInit(&amp;stream, level);</span>
<a href="#l8.46"></a><span id="l8.46" class="difflineplus">+    if (err != Z_OK) return err;</span>
<a href="#l8.47"></a><span id="l8.47" class="difflineplus">+</span>
<a href="#l8.48"></a><span id="l8.48" class="difflineplus">+    stream.next_out = dest;</span>
<a href="#l8.49"></a><span id="l8.49" class="difflineplus">+    stream.avail_out = 0;</span>
<a href="#l8.50"></a><span id="l8.50" class="difflineplus">+    stream.next_in = (z_const Bytef *)source;</span>
<a href="#l8.51"></a><span id="l8.51" class="difflineplus">+    stream.avail_in = 0;</span>
<a href="#l8.52"></a><span id="l8.52" class="difflineplus">+</span>
<a href="#l8.53"></a><span id="l8.53" class="difflineplus">+    do {</span>
<a href="#l8.54"></a><span id="l8.54" class="difflineplus">+        if (stream.avail_out == 0) {</span>
<a href="#l8.55"></a><span id="l8.55" class="difflineplus">+            stream.avail_out = left &gt; (uLong)max ? max : (uInt)left;</span>
<a href="#l8.56"></a><span id="l8.56" class="difflineplus">+            left -= stream.avail_out;</span>
<a href="#l8.57"></a><span id="l8.57" class="difflineplus">+        }</span>
<a href="#l8.58"></a><span id="l8.58" class="difflineplus">+        if (stream.avail_in == 0) {</span>
<a href="#l8.59"></a><span id="l8.59" class="difflineplus">+            stream.avail_in = sourceLen &gt; (uLong)max ? max : (uInt)sourceLen;</span>
<a href="#l8.60"></a><span id="l8.60" class="difflineplus">+            sourceLen -= stream.avail_in;</span>
<a href="#l8.61"></a><span id="l8.61" class="difflineplus">+        }</span>
<a href="#l8.62"></a><span id="l8.62" class="difflineplus">+        err = deflate(&amp;stream, sourceLen ? Z_NO_FLUSH : Z_FINISH);</span>
<a href="#l8.63"></a><span id="l8.63" class="difflineplus">+    } while (err == Z_OK);</span>
<a href="#l8.64"></a><span id="l8.64" class="difflineplus">+</span>
<a href="#l8.65"></a><span id="l8.65" class="difflineplus">+    *destLen = stream.total_out;</span>
<a href="#l8.66"></a><span id="l8.66" class="difflineplus">+    deflateEnd(&amp;stream);</span>
<a href="#l8.67"></a><span id="l8.67" class="difflineplus">+    return err == Z_STREAM_END ? Z_OK : err;</span>
<a href="#l8.68"></a><span id="l8.68" class="difflineplus">+}</span>
<a href="#l8.69"></a><span id="l8.69" class="difflineplus">+</span>
<a href="#l8.70"></a><span id="l8.70" class="difflineplus">+/* ===========================================================================</span>
<a href="#l8.71"></a><span id="l8.71" class="difflineplus">+ */</span>
<a href="#l8.72"></a><span id="l8.72" class="difflineplus">+int ZEXPORT compress (dest, destLen, source, sourceLen)</span>
<a href="#l8.73"></a><span id="l8.73" class="difflineplus">+    Bytef *dest;</span>
<a href="#l8.74"></a><span id="l8.74" class="difflineplus">+    uLongf *destLen;</span>
<a href="#l8.75"></a><span id="l8.75" class="difflineplus">+    const Bytef *source;</span>
<a href="#l8.76"></a><span id="l8.76" class="difflineplus">+    uLong sourceLen;</span>
<a href="#l8.77"></a><span id="l8.77" class="difflineplus">+{</span>
<a href="#l8.78"></a><span id="l8.78" class="difflineplus">+    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);</span>
<a href="#l8.79"></a><span id="l8.79" class="difflineplus">+}</span>
<a href="#l8.80"></a><span id="l8.80" class="difflineplus">+</span>
<a href="#l8.81"></a><span id="l8.81" class="difflineplus">+/* ===========================================================================</span>
<a href="#l8.82"></a><span id="l8.82" class="difflineplus">+     If the default memLevel or windowBits for deflateInit() is changed, then</span>
<a href="#l8.83"></a><span id="l8.83" class="difflineplus">+   this function needs to be updated.</span>
<a href="#l8.84"></a><span id="l8.84" class="difflineplus">+ */</span>
<a href="#l8.85"></a><span id="l8.85" class="difflineplus">+uLong ZEXPORT compressBound (sourceLen)</span>
<a href="#l8.86"></a><span id="l8.86" class="difflineplus">+    uLong sourceLen;</span>
<a href="#l8.87"></a><span id="l8.87" class="difflineplus">+{</span>
<a href="#l8.88"></a><span id="l8.88" class="difflineplus">+    return sourceLen + (sourceLen &gt;&gt; 12) + (sourceLen &gt;&gt; 14) +</span>
<a href="#l8.89"></a><span id="l8.89" class="difflineplus">+           (sourceLen &gt;&gt; 25) + 13;</span>
<a href="#l8.90"></a><span id="l8.90" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1">new file mode 100644</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineminus">--- /dev/null</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineplus">+++ b/third_party/zlib/crc32.c</span>
<a href="#l9.4"></a><span id="l9.4" class="difflineat">@@ -0,0 +1,442 @@</span>
<a href="#l9.5"></a><span id="l9.5" class="difflineplus">+/* crc32.c -- compute the CRC-32 of a data stream</span>
<a href="#l9.6"></a><span id="l9.6" class="difflineplus">+ * Copyright (C) 1995-2006, 2010, 2011, 2012, 2016 Mark Adler</span>
<a href="#l9.7"></a><span id="l9.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l9.8"></a><span id="l9.8" class="difflineplus">+ *</span>
<a href="#l9.9"></a><span id="l9.9" class="difflineplus">+ * Thanks to Rodney Brown &lt;rbrown64@csc.com.au&gt; for his contribution of faster</span>
<a href="#l9.10"></a><span id="l9.10" class="difflineplus">+ * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing</span>
<a href="#l9.11"></a><span id="l9.11" class="difflineplus">+ * tables for updating the shift register in one step with three exclusive-ors</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineplus">+ * instead of four steps with four exclusive-ors.  This results in about a</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+ * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.</span>
<a href="#l9.14"></a><span id="l9.14" class="difflineplus">+ */</span>
<a href="#l9.15"></a><span id="l9.15" class="difflineplus">+</span>
<a href="#l9.16"></a><span id="l9.16" class="difflineplus">+/* @(#) $Id$ */</span>
<a href="#l9.17"></a><span id="l9.17" class="difflineplus">+</span>
<a href="#l9.18"></a><span id="l9.18" class="difflineplus">+/*</span>
<a href="#l9.19"></a><span id="l9.19" class="difflineplus">+  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore</span>
<a href="#l9.20"></a><span id="l9.20" class="difflineplus">+  protection on the static variables used to control the first-use generation</span>
<a href="#l9.21"></a><span id="l9.21" class="difflineplus">+  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should</span>
<a href="#l9.22"></a><span id="l9.22" class="difflineplus">+  first call get_crc_table() to initialize the tables before allowing more than</span>
<a href="#l9.23"></a><span id="l9.23" class="difflineplus">+  one thread to use crc32().</span>
<a href="#l9.24"></a><span id="l9.24" class="difflineplus">+</span>
<a href="#l9.25"></a><span id="l9.25" class="difflineplus">+  DYNAMIC_CRC_TABLE and MAKECRCH can be #defined to write out crc32.h.</span>
<a href="#l9.26"></a><span id="l9.26" class="difflineplus">+ */</span>
<a href="#l9.27"></a><span id="l9.27" class="difflineplus">+</span>
<a href="#l9.28"></a><span id="l9.28" class="difflineplus">+#ifdef MAKECRCH</span>
<a href="#l9.29"></a><span id="l9.29" class="difflineplus">+#  include &lt;stdio.h&gt;</span>
<a href="#l9.30"></a><span id="l9.30" class="difflineplus">+#  ifndef DYNAMIC_CRC_TABLE</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineplus">+#    define DYNAMIC_CRC_TABLE</span>
<a href="#l9.32"></a><span id="l9.32" class="difflineplus">+#  endif /* !DYNAMIC_CRC_TABLE */</span>
<a href="#l9.33"></a><span id="l9.33" class="difflineplus">+#endif /* MAKECRCH */</span>
<a href="#l9.34"></a><span id="l9.34" class="difflineplus">+</span>
<a href="#l9.35"></a><span id="l9.35" class="difflineplus">+#include &quot;zutil.h&quot;      /* for STDC and FAR definitions */</span>
<a href="#l9.36"></a><span id="l9.36" class="difflineplus">+</span>
<a href="#l9.37"></a><span id="l9.37" class="difflineplus">+/* Definitions for doing the crc four data bytes at a time. */</span>
<a href="#l9.38"></a><span id="l9.38" class="difflineplus">+#if !defined(NOBYFOUR) &amp;&amp; defined(Z_U4)</span>
<a href="#l9.39"></a><span id="l9.39" class="difflineplus">+#  define BYFOUR</span>
<a href="#l9.40"></a><span id="l9.40" class="difflineplus">+#endif</span>
<a href="#l9.41"></a><span id="l9.41" class="difflineplus">+#ifdef BYFOUR</span>
<a href="#l9.42"></a><span id="l9.42" class="difflineplus">+   local unsigned long crc32_little OF((unsigned long,</span>
<a href="#l9.43"></a><span id="l9.43" class="difflineplus">+                        const unsigned char FAR *, z_size_t));</span>
<a href="#l9.44"></a><span id="l9.44" class="difflineplus">+   local unsigned long crc32_big OF((unsigned long,</span>
<a href="#l9.45"></a><span id="l9.45" class="difflineplus">+                        const unsigned char FAR *, z_size_t));</span>
<a href="#l9.46"></a><span id="l9.46" class="difflineplus">+#  define TBLS 8</span>
<a href="#l9.47"></a><span id="l9.47" class="difflineplus">+#else</span>
<a href="#l9.48"></a><span id="l9.48" class="difflineplus">+#  define TBLS 1</span>
<a href="#l9.49"></a><span id="l9.49" class="difflineplus">+#endif /* BYFOUR */</span>
<a href="#l9.50"></a><span id="l9.50" class="difflineplus">+</span>
<a href="#l9.51"></a><span id="l9.51" class="difflineplus">+/* Local functions for crc concatenation */</span>
<a href="#l9.52"></a><span id="l9.52" class="difflineplus">+local unsigned long gf2_matrix_times OF((unsigned long *mat,</span>
<a href="#l9.53"></a><span id="l9.53" class="difflineplus">+                                         unsigned long vec));</span>
<a href="#l9.54"></a><span id="l9.54" class="difflineplus">+local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));</span>
<a href="#l9.55"></a><span id="l9.55" class="difflineplus">+local uLong crc32_combine_ OF((uLong crc1, uLong crc2, z_off64_t len2));</span>
<a href="#l9.56"></a><span id="l9.56" class="difflineplus">+</span>
<a href="#l9.57"></a><span id="l9.57" class="difflineplus">+</span>
<a href="#l9.58"></a><span id="l9.58" class="difflineplus">+#ifdef DYNAMIC_CRC_TABLE</span>
<a href="#l9.59"></a><span id="l9.59" class="difflineplus">+</span>
<a href="#l9.60"></a><span id="l9.60" class="difflineplus">+local volatile int crc_table_empty = 1;</span>
<a href="#l9.61"></a><span id="l9.61" class="difflineplus">+local z_crc_t FAR crc_table[TBLS][256];</span>
<a href="#l9.62"></a><span id="l9.62" class="difflineplus">+local void make_crc_table OF((void));</span>
<a href="#l9.63"></a><span id="l9.63" class="difflineplus">+#ifdef MAKECRCH</span>
<a href="#l9.64"></a><span id="l9.64" class="difflineplus">+   local void write_table OF((FILE *, const z_crc_t FAR *));</span>
<a href="#l9.65"></a><span id="l9.65" class="difflineplus">+#endif /* MAKECRCH */</span>
<a href="#l9.66"></a><span id="l9.66" class="difflineplus">+/*</span>
<a href="#l9.67"></a><span id="l9.67" class="difflineplus">+  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:</span>
<a href="#l9.68"></a><span id="l9.68" class="difflineplus">+  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.</span>
<a href="#l9.69"></a><span id="l9.69" class="difflineplus">+</span>
<a href="#l9.70"></a><span id="l9.70" class="difflineplus">+  Polynomials over GF(2) are represented in binary, one bit per coefficient,</span>
<a href="#l9.71"></a><span id="l9.71" class="difflineplus">+  with the lowest powers in the most significant bit.  Then adding polynomials</span>
<a href="#l9.72"></a><span id="l9.72" class="difflineplus">+  is just exclusive-or, and multiplying a polynomial by x is a right shift by</span>
<a href="#l9.73"></a><span id="l9.73" class="difflineplus">+  one.  If we call the above polynomial p, and represent a byte as the</span>
<a href="#l9.74"></a><span id="l9.74" class="difflineplus">+  polynomial q, also with the lowest power in the most significant bit (so the</span>
<a href="#l9.75"></a><span id="l9.75" class="difflineplus">+  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,</span>
<a href="#l9.76"></a><span id="l9.76" class="difflineplus">+  where a mod b means the remainder after dividing a by b.</span>
<a href="#l9.77"></a><span id="l9.77" class="difflineplus">+</span>
<a href="#l9.78"></a><span id="l9.78" class="difflineplus">+  This calculation is done using the shift-register method of multiplying and</span>
<a href="#l9.79"></a><span id="l9.79" class="difflineplus">+  taking the remainder.  The register is initialized to zero, and for each</span>
<a href="#l9.80"></a><span id="l9.80" class="difflineplus">+  incoming bit, x^32 is added mod p to the register if the bit is a one (where</span>
<a href="#l9.81"></a><span id="l9.81" class="difflineplus">+  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by</span>
<a href="#l9.82"></a><span id="l9.82" class="difflineplus">+  x (which is shifting right by one and adding x^32 mod p if the bit shifted</span>
<a href="#l9.83"></a><span id="l9.83" class="difflineplus">+  out is a one).  We start with the highest power (least significant bit) of</span>
<a href="#l9.84"></a><span id="l9.84" class="difflineplus">+  q and repeat for all eight bits of q.</span>
<a href="#l9.85"></a><span id="l9.85" class="difflineplus">+</span>
<a href="#l9.86"></a><span id="l9.86" class="difflineplus">+  The first table is simply the CRC of all possible eight bit values.  This is</span>
<a href="#l9.87"></a><span id="l9.87" class="difflineplus">+  all the information needed to generate CRCs on data a byte at a time for all</span>
<a href="#l9.88"></a><span id="l9.88" class="difflineplus">+  combinations of CRC register values and incoming bytes.  The remaining tables</span>
<a href="#l9.89"></a><span id="l9.89" class="difflineplus">+  allow for word-at-a-time CRC calculation for both big-endian and little-</span>
<a href="#l9.90"></a><span id="l9.90" class="difflineplus">+  endian machines, where a word is four bytes.</span>
<a href="#l9.91"></a><span id="l9.91" class="difflineplus">+*/</span>
<a href="#l9.92"></a><span id="l9.92" class="difflineplus">+local void make_crc_table()</span>
<a href="#l9.93"></a><span id="l9.93" class="difflineplus">+{</span>
<a href="#l9.94"></a><span id="l9.94" class="difflineplus">+    z_crc_t c;</span>
<a href="#l9.95"></a><span id="l9.95" class="difflineplus">+    int n, k;</span>
<a href="#l9.96"></a><span id="l9.96" class="difflineplus">+    z_crc_t poly;                       /* polynomial exclusive-or pattern */</span>
<a href="#l9.97"></a><span id="l9.97" class="difflineplus">+    /* terms of polynomial defining this crc (except x^32): */</span>
<a href="#l9.98"></a><span id="l9.98" class="difflineplus">+    static volatile int first = 1;      /* flag to limit concurrent making */</span>
<a href="#l9.99"></a><span id="l9.99" class="difflineplus">+    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};</span>
<a href="#l9.100"></a><span id="l9.100" class="difflineplus">+</span>
<a href="#l9.101"></a><span id="l9.101" class="difflineplus">+    /* See if another task is already doing this (not thread-safe, but better</span>
<a href="#l9.102"></a><span id="l9.102" class="difflineplus">+       than nothing -- significantly reduces duration of vulnerability in</span>
<a href="#l9.103"></a><span id="l9.103" class="difflineplus">+       case the advice about DYNAMIC_CRC_TABLE is ignored) */</span>
<a href="#l9.104"></a><span id="l9.104" class="difflineplus">+    if (first) {</span>
<a href="#l9.105"></a><span id="l9.105" class="difflineplus">+        first = 0;</span>
<a href="#l9.106"></a><span id="l9.106" class="difflineplus">+</span>
<a href="#l9.107"></a><span id="l9.107" class="difflineplus">+        /* make exclusive-or pattern from polynomial (0xedb88320UL) */</span>
<a href="#l9.108"></a><span id="l9.108" class="difflineplus">+        poly = 0;</span>
<a href="#l9.109"></a><span id="l9.109" class="difflineplus">+        for (n = 0; n &lt; (int)(sizeof(p)/sizeof(unsigned char)); n++)</span>
<a href="#l9.110"></a><span id="l9.110" class="difflineplus">+            poly |= (z_crc_t)1 &lt;&lt; (31 - p[n]);</span>
<a href="#l9.111"></a><span id="l9.111" class="difflineplus">+</span>
<a href="#l9.112"></a><span id="l9.112" class="difflineplus">+        /* generate a crc for every 8-bit value */</span>
<a href="#l9.113"></a><span id="l9.113" class="difflineplus">+        for (n = 0; n &lt; 256; n++) {</span>
<a href="#l9.114"></a><span id="l9.114" class="difflineplus">+            c = (z_crc_t)n;</span>
<a href="#l9.115"></a><span id="l9.115" class="difflineplus">+            for (k = 0; k &lt; 8; k++)</span>
<a href="#l9.116"></a><span id="l9.116" class="difflineplus">+                c = c &amp; 1 ? poly ^ (c &gt;&gt; 1) : c &gt;&gt; 1;</span>
<a href="#l9.117"></a><span id="l9.117" class="difflineplus">+            crc_table[0][n] = c;</span>
<a href="#l9.118"></a><span id="l9.118" class="difflineplus">+        }</span>
<a href="#l9.119"></a><span id="l9.119" class="difflineplus">+</span>
<a href="#l9.120"></a><span id="l9.120" class="difflineplus">+#ifdef BYFOUR</span>
<a href="#l9.121"></a><span id="l9.121" class="difflineplus">+        /* generate crc for each value followed by one, two, and three zeros,</span>
<a href="#l9.122"></a><span id="l9.122" class="difflineplus">+           and then the byte reversal of those as well as the first table */</span>
<a href="#l9.123"></a><span id="l9.123" class="difflineplus">+        for (n = 0; n &lt; 256; n++) {</span>
<a href="#l9.124"></a><span id="l9.124" class="difflineplus">+            c = crc_table[0][n];</span>
<a href="#l9.125"></a><span id="l9.125" class="difflineplus">+            crc_table[4][n] = ZSWAP32(c);</span>
<a href="#l9.126"></a><span id="l9.126" class="difflineplus">+            for (k = 1; k &lt; 4; k++) {</span>
<a href="#l9.127"></a><span id="l9.127" class="difflineplus">+                c = crc_table[0][c &amp; 0xff] ^ (c &gt;&gt; 8);</span>
<a href="#l9.128"></a><span id="l9.128" class="difflineplus">+                crc_table[k][n] = c;</span>
<a href="#l9.129"></a><span id="l9.129" class="difflineplus">+                crc_table[k + 4][n] = ZSWAP32(c);</span>
<a href="#l9.130"></a><span id="l9.130" class="difflineplus">+            }</span>
<a href="#l9.131"></a><span id="l9.131" class="difflineplus">+        }</span>
<a href="#l9.132"></a><span id="l9.132" class="difflineplus">+#endif /* BYFOUR */</span>
<a href="#l9.133"></a><span id="l9.133" class="difflineplus">+</span>
<a href="#l9.134"></a><span id="l9.134" class="difflineplus">+        crc_table_empty = 0;</span>
<a href="#l9.135"></a><span id="l9.135" class="difflineplus">+    }</span>
<a href="#l9.136"></a><span id="l9.136" class="difflineplus">+    else {      /* not first */</span>
<a href="#l9.137"></a><span id="l9.137" class="difflineplus">+        /* wait for the other guy to finish (not efficient, but rare) */</span>
<a href="#l9.138"></a><span id="l9.138" class="difflineplus">+        while (crc_table_empty)</span>
<a href="#l9.139"></a><span id="l9.139" class="difflineplus">+            ;</span>
<a href="#l9.140"></a><span id="l9.140" class="difflineplus">+    }</span>
<a href="#l9.141"></a><span id="l9.141" class="difflineplus">+</span>
<a href="#l9.142"></a><span id="l9.142" class="difflineplus">+#ifdef MAKECRCH</span>
<a href="#l9.143"></a><span id="l9.143" class="difflineplus">+    /* write out CRC tables to crc32.h */</span>
<a href="#l9.144"></a><span id="l9.144" class="difflineplus">+    {</span>
<a href="#l9.145"></a><span id="l9.145" class="difflineplus">+        FILE *out;</span>
<a href="#l9.146"></a><span id="l9.146" class="difflineplus">+</span>
<a href="#l9.147"></a><span id="l9.147" class="difflineplus">+        out = fopen(&quot;crc32.h&quot;, &quot;w&quot;);</span>
<a href="#l9.148"></a><span id="l9.148" class="difflineplus">+        if (out == NULL) return;</span>
<a href="#l9.149"></a><span id="l9.149" class="difflineplus">+        fprintf(out, &quot;/* crc32.h -- tables for rapid CRC calculation\n&quot;);</span>
<a href="#l9.150"></a><span id="l9.150" class="difflineplus">+        fprintf(out, &quot; * Generated automatically by crc32.c\n */\n\n&quot;);</span>
<a href="#l9.151"></a><span id="l9.151" class="difflineplus">+        fprintf(out, &quot;local const z_crc_t FAR &quot;);</span>
<a href="#l9.152"></a><span id="l9.152" class="difflineplus">+        fprintf(out, &quot;crc_table[TBLS][256] =\n{\n  {\n&quot;);</span>
<a href="#l9.153"></a><span id="l9.153" class="difflineplus">+        write_table(out, crc_table[0]);</span>
<a href="#l9.154"></a><span id="l9.154" class="difflineplus">+#  ifdef BYFOUR</span>
<a href="#l9.155"></a><span id="l9.155" class="difflineplus">+        fprintf(out, &quot;#ifdef BYFOUR\n&quot;);</span>
<a href="#l9.156"></a><span id="l9.156" class="difflineplus">+        for (k = 1; k &lt; 8; k++) {</span>
<a href="#l9.157"></a><span id="l9.157" class="difflineplus">+            fprintf(out, &quot;  },\n  {\n&quot;);</span>
<a href="#l9.158"></a><span id="l9.158" class="difflineplus">+            write_table(out, crc_table[k]);</span>
<a href="#l9.159"></a><span id="l9.159" class="difflineplus">+        }</span>
<a href="#l9.160"></a><span id="l9.160" class="difflineplus">+        fprintf(out, &quot;#endif\n&quot;);</span>
<a href="#l9.161"></a><span id="l9.161" class="difflineplus">+#  endif /* BYFOUR */</span>
<a href="#l9.162"></a><span id="l9.162" class="difflineplus">+        fprintf(out, &quot;  }\n};\n&quot;);</span>
<a href="#l9.163"></a><span id="l9.163" class="difflineplus">+        fclose(out);</span>
<a href="#l9.164"></a><span id="l9.164" class="difflineplus">+    }</span>
<a href="#l9.165"></a><span id="l9.165" class="difflineplus">+#endif /* MAKECRCH */</span>
<a href="#l9.166"></a><span id="l9.166" class="difflineplus">+}</span>
<a href="#l9.167"></a><span id="l9.167" class="difflineplus">+</span>
<a href="#l9.168"></a><span id="l9.168" class="difflineplus">+#ifdef MAKECRCH</span>
<a href="#l9.169"></a><span id="l9.169" class="difflineplus">+local void write_table(out, table)</span>
<a href="#l9.170"></a><span id="l9.170" class="difflineplus">+    FILE *out;</span>
<a href="#l9.171"></a><span id="l9.171" class="difflineplus">+    const z_crc_t FAR *table;</span>
<a href="#l9.172"></a><span id="l9.172" class="difflineplus">+{</span>
<a href="#l9.173"></a><span id="l9.173" class="difflineplus">+    int n;</span>
<a href="#l9.174"></a><span id="l9.174" class="difflineplus">+</span>
<a href="#l9.175"></a><span id="l9.175" class="difflineplus">+    for (n = 0; n &lt; 256; n++)</span>
<a href="#l9.176"></a><span id="l9.176" class="difflineplus">+        fprintf(out, &quot;%s0x%08lxUL%s&quot;, n % 5 ? &quot;&quot; : &quot;    &quot;,</span>
<a href="#l9.177"></a><span id="l9.177" class="difflineplus">+                (unsigned long)(table[n]),</span>
<a href="#l9.178"></a><span id="l9.178" class="difflineplus">+                n == 255 ? &quot;\n&quot; : (n % 5 == 4 ? &quot;,\n&quot; : &quot;, &quot;));</span>
<a href="#l9.179"></a><span id="l9.179" class="difflineplus">+}</span>
<a href="#l9.180"></a><span id="l9.180" class="difflineplus">+#endif /* MAKECRCH */</span>
<a href="#l9.181"></a><span id="l9.181" class="difflineplus">+</span>
<a href="#l9.182"></a><span id="l9.182" class="difflineplus">+#else /* !DYNAMIC_CRC_TABLE */</span>
<a href="#l9.183"></a><span id="l9.183" class="difflineplus">+/* ========================================================================</span>
<a href="#l9.184"></a><span id="l9.184" class="difflineplus">+ * Tables of CRC-32s of all single-byte values, made by make_crc_table().</span>
<a href="#l9.185"></a><span id="l9.185" class="difflineplus">+ */</span>
<a href="#l9.186"></a><span id="l9.186" class="difflineplus">+#include &quot;crc32.h&quot;</span>
<a href="#l9.187"></a><span id="l9.187" class="difflineplus">+#endif /* DYNAMIC_CRC_TABLE */</span>
<a href="#l9.188"></a><span id="l9.188" class="difflineplus">+</span>
<a href="#l9.189"></a><span id="l9.189" class="difflineplus">+/* =========================================================================</span>
<a href="#l9.190"></a><span id="l9.190" class="difflineplus">+ * This function can be used by asm versions of crc32()</span>
<a href="#l9.191"></a><span id="l9.191" class="difflineplus">+ */</span>
<a href="#l9.192"></a><span id="l9.192" class="difflineplus">+const z_crc_t FAR * ZEXPORT get_crc_table()</span>
<a href="#l9.193"></a><span id="l9.193" class="difflineplus">+{</span>
<a href="#l9.194"></a><span id="l9.194" class="difflineplus">+#ifdef DYNAMIC_CRC_TABLE</span>
<a href="#l9.195"></a><span id="l9.195" class="difflineplus">+    if (crc_table_empty)</span>
<a href="#l9.196"></a><span id="l9.196" class="difflineplus">+        make_crc_table();</span>
<a href="#l9.197"></a><span id="l9.197" class="difflineplus">+#endif /* DYNAMIC_CRC_TABLE */</span>
<a href="#l9.198"></a><span id="l9.198" class="difflineplus">+    return (const z_crc_t FAR *)crc_table;</span>
<a href="#l9.199"></a><span id="l9.199" class="difflineplus">+}</span>
<a href="#l9.200"></a><span id="l9.200" class="difflineplus">+</span>
<a href="#l9.201"></a><span id="l9.201" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l9.202"></a><span id="l9.202" class="difflineplus">+#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) &amp; 0xff] ^ (crc &gt;&gt; 8)</span>
<a href="#l9.203"></a><span id="l9.203" class="difflineplus">+#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1</span>
<a href="#l9.204"></a><span id="l9.204" class="difflineplus">+</span>
<a href="#l9.205"></a><span id="l9.205" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l9.206"></a><span id="l9.206" class="difflineplus">+unsigned long ZEXPORT crc32_z(crc, buf, len)</span>
<a href="#l9.207"></a><span id="l9.207" class="difflineplus">+    unsigned long crc;</span>
<a href="#l9.208"></a><span id="l9.208" class="difflineplus">+    const unsigned char FAR *buf;</span>
<a href="#l9.209"></a><span id="l9.209" class="difflineplus">+    z_size_t len;</span>
<a href="#l9.210"></a><span id="l9.210" class="difflineplus">+{</span>
<a href="#l9.211"></a><span id="l9.211" class="difflineplus">+    if (buf == Z_NULL) return 0UL;</span>
<a href="#l9.212"></a><span id="l9.212" class="difflineplus">+</span>
<a href="#l9.213"></a><span id="l9.213" class="difflineplus">+#ifdef DYNAMIC_CRC_TABLE</span>
<a href="#l9.214"></a><span id="l9.214" class="difflineplus">+    if (crc_table_empty)</span>
<a href="#l9.215"></a><span id="l9.215" class="difflineplus">+        make_crc_table();</span>
<a href="#l9.216"></a><span id="l9.216" class="difflineplus">+#endif /* DYNAMIC_CRC_TABLE */</span>
<a href="#l9.217"></a><span id="l9.217" class="difflineplus">+</span>
<a href="#l9.218"></a><span id="l9.218" class="difflineplus">+#ifdef BYFOUR</span>
<a href="#l9.219"></a><span id="l9.219" class="difflineplus">+    if (sizeof(void *) == sizeof(ptrdiff_t)) {</span>
<a href="#l9.220"></a><span id="l9.220" class="difflineplus">+        z_crc_t endian;</span>
<a href="#l9.221"></a><span id="l9.221" class="difflineplus">+</span>
<a href="#l9.222"></a><span id="l9.222" class="difflineplus">+        endian = 1;</span>
<a href="#l9.223"></a><span id="l9.223" class="difflineplus">+        if (*((unsigned char *)(&amp;endian)))</span>
<a href="#l9.224"></a><span id="l9.224" class="difflineplus">+            return crc32_little(crc, buf, len);</span>
<a href="#l9.225"></a><span id="l9.225" class="difflineplus">+        else</span>
<a href="#l9.226"></a><span id="l9.226" class="difflineplus">+            return crc32_big(crc, buf, len);</span>
<a href="#l9.227"></a><span id="l9.227" class="difflineplus">+    }</span>
<a href="#l9.228"></a><span id="l9.228" class="difflineplus">+#endif /* BYFOUR */</span>
<a href="#l9.229"></a><span id="l9.229" class="difflineplus">+    crc = crc ^ 0xffffffffUL;</span>
<a href="#l9.230"></a><span id="l9.230" class="difflineplus">+    while (len &gt;= 8) {</span>
<a href="#l9.231"></a><span id="l9.231" class="difflineplus">+        DO8;</span>
<a href="#l9.232"></a><span id="l9.232" class="difflineplus">+        len -= 8;</span>
<a href="#l9.233"></a><span id="l9.233" class="difflineplus">+    }</span>
<a href="#l9.234"></a><span id="l9.234" class="difflineplus">+    if (len) do {</span>
<a href="#l9.235"></a><span id="l9.235" class="difflineplus">+        DO1;</span>
<a href="#l9.236"></a><span id="l9.236" class="difflineplus">+    } while (--len);</span>
<a href="#l9.237"></a><span id="l9.237" class="difflineplus">+    return crc ^ 0xffffffffUL;</span>
<a href="#l9.238"></a><span id="l9.238" class="difflineplus">+}</span>
<a href="#l9.239"></a><span id="l9.239" class="difflineplus">+</span>
<a href="#l9.240"></a><span id="l9.240" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l9.241"></a><span id="l9.241" class="difflineplus">+unsigned long ZEXPORT crc32(crc, buf, len)</span>
<a href="#l9.242"></a><span id="l9.242" class="difflineplus">+    unsigned long crc;</span>
<a href="#l9.243"></a><span id="l9.243" class="difflineplus">+    const unsigned char FAR *buf;</span>
<a href="#l9.244"></a><span id="l9.244" class="difflineplus">+    uInt len;</span>
<a href="#l9.245"></a><span id="l9.245" class="difflineplus">+{</span>
<a href="#l9.246"></a><span id="l9.246" class="difflineplus">+    return crc32_z(crc, buf, len);</span>
<a href="#l9.247"></a><span id="l9.247" class="difflineplus">+}</span>
<a href="#l9.248"></a><span id="l9.248" class="difflineplus">+</span>
<a href="#l9.249"></a><span id="l9.249" class="difflineplus">+#ifdef BYFOUR</span>
<a href="#l9.250"></a><span id="l9.250" class="difflineplus">+</span>
<a href="#l9.251"></a><span id="l9.251" class="difflineplus">+/*</span>
<a href="#l9.252"></a><span id="l9.252" class="difflineplus">+   This BYFOUR code accesses the passed unsigned char * buffer with a 32-bit</span>
<a href="#l9.253"></a><span id="l9.253" class="difflineplus">+   integer pointer type. This violates the strict aliasing rule, where a</span>
<a href="#l9.254"></a><span id="l9.254" class="difflineplus">+   compiler can assume, for optimization purposes, that two pointers to</span>
<a href="#l9.255"></a><span id="l9.255" class="difflineplus">+   fundamentally different types won't ever point to the same memory. This can</span>
<a href="#l9.256"></a><span id="l9.256" class="difflineplus">+   manifest as a problem only if one of the pointers is written to. This code</span>
<a href="#l9.257"></a><span id="l9.257" class="difflineplus">+   only reads from those pointers. So long as this code remains isolated in</span>
<a href="#l9.258"></a><span id="l9.258" class="difflineplus">+   this compilation unit, there won't be a problem. For this reason, this code</span>
<a href="#l9.259"></a><span id="l9.259" class="difflineplus">+   should not be copied and pasted into a compilation unit in which other code</span>
<a href="#l9.260"></a><span id="l9.260" class="difflineplus">+   writes to the buffer that is passed to these routines.</span>
<a href="#l9.261"></a><span id="l9.261" class="difflineplus">+ */</span>
<a href="#l9.262"></a><span id="l9.262" class="difflineplus">+</span>
<a href="#l9.263"></a><span id="l9.263" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l9.264"></a><span id="l9.264" class="difflineplus">+#define DOLIT4 c ^= *buf4++; \</span>
<a href="#l9.265"></a><span id="l9.265" class="difflineplus">+        c = crc_table[3][c &amp; 0xff] ^ crc_table[2][(c &gt;&gt; 8) &amp; 0xff] ^ \</span>
<a href="#l9.266"></a><span id="l9.266" class="difflineplus">+            crc_table[1][(c &gt;&gt; 16) &amp; 0xff] ^ crc_table[0][c &gt;&gt; 24]</span>
<a href="#l9.267"></a><span id="l9.267" class="difflineplus">+#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4</span>
<a href="#l9.268"></a><span id="l9.268" class="difflineplus">+</span>
<a href="#l9.269"></a><span id="l9.269" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l9.270"></a><span id="l9.270" class="difflineplus">+local unsigned long crc32_little(crc, buf, len)</span>
<a href="#l9.271"></a><span id="l9.271" class="difflineplus">+    unsigned long crc;</span>
<a href="#l9.272"></a><span id="l9.272" class="difflineplus">+    const unsigned char FAR *buf;</span>
<a href="#l9.273"></a><span id="l9.273" class="difflineplus">+    z_size_t len;</span>
<a href="#l9.274"></a><span id="l9.274" class="difflineplus">+{</span>
<a href="#l9.275"></a><span id="l9.275" class="difflineplus">+    register z_crc_t c;</span>
<a href="#l9.276"></a><span id="l9.276" class="difflineplus">+    register const z_crc_t FAR *buf4;</span>
<a href="#l9.277"></a><span id="l9.277" class="difflineplus">+</span>
<a href="#l9.278"></a><span id="l9.278" class="difflineplus">+    c = (z_crc_t)crc;</span>
<a href="#l9.279"></a><span id="l9.279" class="difflineplus">+    c = ~c;</span>
<a href="#l9.280"></a><span id="l9.280" class="difflineplus">+    while (len &amp;&amp; ((ptrdiff_t)buf &amp; 3)) {</span>
<a href="#l9.281"></a><span id="l9.281" class="difflineplus">+        c = crc_table[0][(c ^ *buf++) &amp; 0xff] ^ (c &gt;&gt; 8);</span>
<a href="#l9.282"></a><span id="l9.282" class="difflineplus">+        len--;</span>
<a href="#l9.283"></a><span id="l9.283" class="difflineplus">+    }</span>
<a href="#l9.284"></a><span id="l9.284" class="difflineplus">+</span>
<a href="#l9.285"></a><span id="l9.285" class="difflineplus">+    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;</span>
<a href="#l9.286"></a><span id="l9.286" class="difflineplus">+    while (len &gt;= 32) {</span>
<a href="#l9.287"></a><span id="l9.287" class="difflineplus">+        DOLIT32;</span>
<a href="#l9.288"></a><span id="l9.288" class="difflineplus">+        len -= 32;</span>
<a href="#l9.289"></a><span id="l9.289" class="difflineplus">+    }</span>
<a href="#l9.290"></a><span id="l9.290" class="difflineplus">+    while (len &gt;= 4) {</span>
<a href="#l9.291"></a><span id="l9.291" class="difflineplus">+        DOLIT4;</span>
<a href="#l9.292"></a><span id="l9.292" class="difflineplus">+        len -= 4;</span>
<a href="#l9.293"></a><span id="l9.293" class="difflineplus">+    }</span>
<a href="#l9.294"></a><span id="l9.294" class="difflineplus">+    buf = (const unsigned char FAR *)buf4;</span>
<a href="#l9.295"></a><span id="l9.295" class="difflineplus">+</span>
<a href="#l9.296"></a><span id="l9.296" class="difflineplus">+    if (len) do {</span>
<a href="#l9.297"></a><span id="l9.297" class="difflineplus">+        c = crc_table[0][(c ^ *buf++) &amp; 0xff] ^ (c &gt;&gt; 8);</span>
<a href="#l9.298"></a><span id="l9.298" class="difflineplus">+    } while (--len);</span>
<a href="#l9.299"></a><span id="l9.299" class="difflineplus">+    c = ~c;</span>
<a href="#l9.300"></a><span id="l9.300" class="difflineplus">+    return (unsigned long)c;</span>
<a href="#l9.301"></a><span id="l9.301" class="difflineplus">+}</span>
<a href="#l9.302"></a><span id="l9.302" class="difflineplus">+</span>
<a href="#l9.303"></a><span id="l9.303" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l9.304"></a><span id="l9.304" class="difflineplus">+#define DOBIG4 c ^= *buf4++; \</span>
<a href="#l9.305"></a><span id="l9.305" class="difflineplus">+        c = crc_table[4][c &amp; 0xff] ^ crc_table[5][(c &gt;&gt; 8) &amp; 0xff] ^ \</span>
<a href="#l9.306"></a><span id="l9.306" class="difflineplus">+            crc_table[6][(c &gt;&gt; 16) &amp; 0xff] ^ crc_table[7][c &gt;&gt; 24]</span>
<a href="#l9.307"></a><span id="l9.307" class="difflineplus">+#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4</span>
<a href="#l9.308"></a><span id="l9.308" class="difflineplus">+</span>
<a href="#l9.309"></a><span id="l9.309" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l9.310"></a><span id="l9.310" class="difflineplus">+local unsigned long crc32_big(crc, buf, len)</span>
<a href="#l9.311"></a><span id="l9.311" class="difflineplus">+    unsigned long crc;</span>
<a href="#l9.312"></a><span id="l9.312" class="difflineplus">+    const unsigned char FAR *buf;</span>
<a href="#l9.313"></a><span id="l9.313" class="difflineplus">+    z_size_t len;</span>
<a href="#l9.314"></a><span id="l9.314" class="difflineplus">+{</span>
<a href="#l9.315"></a><span id="l9.315" class="difflineplus">+    register z_crc_t c;</span>
<a href="#l9.316"></a><span id="l9.316" class="difflineplus">+    register const z_crc_t FAR *buf4;</span>
<a href="#l9.317"></a><span id="l9.317" class="difflineplus">+</span>
<a href="#l9.318"></a><span id="l9.318" class="difflineplus">+    c = ZSWAP32((z_crc_t)crc);</span>
<a href="#l9.319"></a><span id="l9.319" class="difflineplus">+    c = ~c;</span>
<a href="#l9.320"></a><span id="l9.320" class="difflineplus">+    while (len &amp;&amp; ((ptrdiff_t)buf &amp; 3)) {</span>
<a href="#l9.321"></a><span id="l9.321" class="difflineplus">+        c = crc_table[4][(c &gt;&gt; 24) ^ *buf++] ^ (c &lt;&lt; 8);</span>
<a href="#l9.322"></a><span id="l9.322" class="difflineplus">+        len--;</span>
<a href="#l9.323"></a><span id="l9.323" class="difflineplus">+    }</span>
<a href="#l9.324"></a><span id="l9.324" class="difflineplus">+</span>
<a href="#l9.325"></a><span id="l9.325" class="difflineplus">+    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;</span>
<a href="#l9.326"></a><span id="l9.326" class="difflineplus">+    while (len &gt;= 32) {</span>
<a href="#l9.327"></a><span id="l9.327" class="difflineplus">+        DOBIG32;</span>
<a href="#l9.328"></a><span id="l9.328" class="difflineplus">+        len -= 32;</span>
<a href="#l9.329"></a><span id="l9.329" class="difflineplus">+    }</span>
<a href="#l9.330"></a><span id="l9.330" class="difflineplus">+    while (len &gt;= 4) {</span>
<a href="#l9.331"></a><span id="l9.331" class="difflineplus">+        DOBIG4;</span>
<a href="#l9.332"></a><span id="l9.332" class="difflineplus">+        len -= 4;</span>
<a href="#l9.333"></a><span id="l9.333" class="difflineplus">+    }</span>
<a href="#l9.334"></a><span id="l9.334" class="difflineplus">+    buf = (const unsigned char FAR *)buf4;</span>
<a href="#l9.335"></a><span id="l9.335" class="difflineplus">+</span>
<a href="#l9.336"></a><span id="l9.336" class="difflineplus">+    if (len) do {</span>
<a href="#l9.337"></a><span id="l9.337" class="difflineplus">+        c = crc_table[4][(c &gt;&gt; 24) ^ *buf++] ^ (c &lt;&lt; 8);</span>
<a href="#l9.338"></a><span id="l9.338" class="difflineplus">+    } while (--len);</span>
<a href="#l9.339"></a><span id="l9.339" class="difflineplus">+    c = ~c;</span>
<a href="#l9.340"></a><span id="l9.340" class="difflineplus">+    return (unsigned long)(ZSWAP32(c));</span>
<a href="#l9.341"></a><span id="l9.341" class="difflineplus">+}</span>
<a href="#l9.342"></a><span id="l9.342" class="difflineplus">+</span>
<a href="#l9.343"></a><span id="l9.343" class="difflineplus">+#endif /* BYFOUR */</span>
<a href="#l9.344"></a><span id="l9.344" class="difflineplus">+</span>
<a href="#l9.345"></a><span id="l9.345" class="difflineplus">+#define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */</span>
<a href="#l9.346"></a><span id="l9.346" class="difflineplus">+</span>
<a href="#l9.347"></a><span id="l9.347" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l9.348"></a><span id="l9.348" class="difflineplus">+local unsigned long gf2_matrix_times(mat, vec)</span>
<a href="#l9.349"></a><span id="l9.349" class="difflineplus">+    unsigned long *mat;</span>
<a href="#l9.350"></a><span id="l9.350" class="difflineplus">+    unsigned long vec;</span>
<a href="#l9.351"></a><span id="l9.351" class="difflineplus">+{</span>
<a href="#l9.352"></a><span id="l9.352" class="difflineplus">+    unsigned long sum;</span>
<a href="#l9.353"></a><span id="l9.353" class="difflineplus">+</span>
<a href="#l9.354"></a><span id="l9.354" class="difflineplus">+    sum = 0;</span>
<a href="#l9.355"></a><span id="l9.355" class="difflineplus">+    while (vec) {</span>
<a href="#l9.356"></a><span id="l9.356" class="difflineplus">+        if (vec &amp; 1)</span>
<a href="#l9.357"></a><span id="l9.357" class="difflineplus">+            sum ^= *mat;</span>
<a href="#l9.358"></a><span id="l9.358" class="difflineplus">+        vec &gt;&gt;= 1;</span>
<a href="#l9.359"></a><span id="l9.359" class="difflineplus">+        mat++;</span>
<a href="#l9.360"></a><span id="l9.360" class="difflineplus">+    }</span>
<a href="#l9.361"></a><span id="l9.361" class="difflineplus">+    return sum;</span>
<a href="#l9.362"></a><span id="l9.362" class="difflineplus">+}</span>
<a href="#l9.363"></a><span id="l9.363" class="difflineplus">+</span>
<a href="#l9.364"></a><span id="l9.364" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l9.365"></a><span id="l9.365" class="difflineplus">+local void gf2_matrix_square(square, mat)</span>
<a href="#l9.366"></a><span id="l9.366" class="difflineplus">+    unsigned long *square;</span>
<a href="#l9.367"></a><span id="l9.367" class="difflineplus">+    unsigned long *mat;</span>
<a href="#l9.368"></a><span id="l9.368" class="difflineplus">+{</span>
<a href="#l9.369"></a><span id="l9.369" class="difflineplus">+    int n;</span>
<a href="#l9.370"></a><span id="l9.370" class="difflineplus">+</span>
<a href="#l9.371"></a><span id="l9.371" class="difflineplus">+    for (n = 0; n &lt; GF2_DIM; n++)</span>
<a href="#l9.372"></a><span id="l9.372" class="difflineplus">+        square[n] = gf2_matrix_times(mat, mat[n]);</span>
<a href="#l9.373"></a><span id="l9.373" class="difflineplus">+}</span>
<a href="#l9.374"></a><span id="l9.374" class="difflineplus">+</span>
<a href="#l9.375"></a><span id="l9.375" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l9.376"></a><span id="l9.376" class="difflineplus">+local uLong crc32_combine_(crc1, crc2, len2)</span>
<a href="#l9.377"></a><span id="l9.377" class="difflineplus">+    uLong crc1;</span>
<a href="#l9.378"></a><span id="l9.378" class="difflineplus">+    uLong crc2;</span>
<a href="#l9.379"></a><span id="l9.379" class="difflineplus">+    z_off64_t len2;</span>
<a href="#l9.380"></a><span id="l9.380" class="difflineplus">+{</span>
<a href="#l9.381"></a><span id="l9.381" class="difflineplus">+    int n;</span>
<a href="#l9.382"></a><span id="l9.382" class="difflineplus">+    unsigned long row;</span>
<a href="#l9.383"></a><span id="l9.383" class="difflineplus">+    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */</span>
<a href="#l9.384"></a><span id="l9.384" class="difflineplus">+    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */</span>
<a href="#l9.385"></a><span id="l9.385" class="difflineplus">+</span>
<a href="#l9.386"></a><span id="l9.386" class="difflineplus">+    /* degenerate case (also disallow negative lengths) */</span>
<a href="#l9.387"></a><span id="l9.387" class="difflineplus">+    if (len2 &lt;= 0)</span>
<a href="#l9.388"></a><span id="l9.388" class="difflineplus">+        return crc1;</span>
<a href="#l9.389"></a><span id="l9.389" class="difflineplus">+</span>
<a href="#l9.390"></a><span id="l9.390" class="difflineplus">+    /* put operator for one zero bit in odd */</span>
<a href="#l9.391"></a><span id="l9.391" class="difflineplus">+    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */</span>
<a href="#l9.392"></a><span id="l9.392" class="difflineplus">+    row = 1;</span>
<a href="#l9.393"></a><span id="l9.393" class="difflineplus">+    for (n = 1; n &lt; GF2_DIM; n++) {</span>
<a href="#l9.394"></a><span id="l9.394" class="difflineplus">+        odd[n] = row;</span>
<a href="#l9.395"></a><span id="l9.395" class="difflineplus">+        row &lt;&lt;= 1;</span>
<a href="#l9.396"></a><span id="l9.396" class="difflineplus">+    }</span>
<a href="#l9.397"></a><span id="l9.397" class="difflineplus">+</span>
<a href="#l9.398"></a><span id="l9.398" class="difflineplus">+    /* put operator for two zero bits in even */</span>
<a href="#l9.399"></a><span id="l9.399" class="difflineplus">+    gf2_matrix_square(even, odd);</span>
<a href="#l9.400"></a><span id="l9.400" class="difflineplus">+</span>
<a href="#l9.401"></a><span id="l9.401" class="difflineplus">+    /* put operator for four zero bits in odd */</span>
<a href="#l9.402"></a><span id="l9.402" class="difflineplus">+    gf2_matrix_square(odd, even);</span>
<a href="#l9.403"></a><span id="l9.403" class="difflineplus">+</span>
<a href="#l9.404"></a><span id="l9.404" class="difflineplus">+    /* apply len2 zeros to crc1 (first square will put the operator for one</span>
<a href="#l9.405"></a><span id="l9.405" class="difflineplus">+       zero byte, eight zero bits, in even) */</span>
<a href="#l9.406"></a><span id="l9.406" class="difflineplus">+    do {</span>
<a href="#l9.407"></a><span id="l9.407" class="difflineplus">+        /* apply zeros operator for this bit of len2 */</span>
<a href="#l9.408"></a><span id="l9.408" class="difflineplus">+        gf2_matrix_square(even, odd);</span>
<a href="#l9.409"></a><span id="l9.409" class="difflineplus">+        if (len2 &amp; 1)</span>
<a href="#l9.410"></a><span id="l9.410" class="difflineplus">+            crc1 = gf2_matrix_times(even, crc1);</span>
<a href="#l9.411"></a><span id="l9.411" class="difflineplus">+        len2 &gt;&gt;= 1;</span>
<a href="#l9.412"></a><span id="l9.412" class="difflineplus">+</span>
<a href="#l9.413"></a><span id="l9.413" class="difflineplus">+        /* if no more bits set, then done */</span>
<a href="#l9.414"></a><span id="l9.414" class="difflineplus">+        if (len2 == 0)</span>
<a href="#l9.415"></a><span id="l9.415" class="difflineplus">+            break;</span>
<a href="#l9.416"></a><span id="l9.416" class="difflineplus">+</span>
<a href="#l9.417"></a><span id="l9.417" class="difflineplus">+        /* another iteration of the loop with odd and even swapped */</span>
<a href="#l9.418"></a><span id="l9.418" class="difflineplus">+        gf2_matrix_square(odd, even);</span>
<a href="#l9.419"></a><span id="l9.419" class="difflineplus">+        if (len2 &amp; 1)</span>
<a href="#l9.420"></a><span id="l9.420" class="difflineplus">+            crc1 = gf2_matrix_times(odd, crc1);</span>
<a href="#l9.421"></a><span id="l9.421" class="difflineplus">+        len2 &gt;&gt;= 1;</span>
<a href="#l9.422"></a><span id="l9.422" class="difflineplus">+</span>
<a href="#l9.423"></a><span id="l9.423" class="difflineplus">+        /* if no more bits set, then done */</span>
<a href="#l9.424"></a><span id="l9.424" class="difflineplus">+    } while (len2 != 0);</span>
<a href="#l9.425"></a><span id="l9.425" class="difflineplus">+</span>
<a href="#l9.426"></a><span id="l9.426" class="difflineplus">+    /* return combined crc */</span>
<a href="#l9.427"></a><span id="l9.427" class="difflineplus">+    crc1 ^= crc2;</span>
<a href="#l9.428"></a><span id="l9.428" class="difflineplus">+    return crc1;</span>
<a href="#l9.429"></a><span id="l9.429" class="difflineplus">+}</span>
<a href="#l9.430"></a><span id="l9.430" class="difflineplus">+</span>
<a href="#l9.431"></a><span id="l9.431" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l9.432"></a><span id="l9.432" class="difflineplus">+uLong ZEXPORT crc32_combine(crc1, crc2, len2)</span>
<a href="#l9.433"></a><span id="l9.433" class="difflineplus">+    uLong crc1;</span>
<a href="#l9.434"></a><span id="l9.434" class="difflineplus">+    uLong crc2;</span>
<a href="#l9.435"></a><span id="l9.435" class="difflineplus">+    z_off_t len2;</span>
<a href="#l9.436"></a><span id="l9.436" class="difflineplus">+{</span>
<a href="#l9.437"></a><span id="l9.437" class="difflineplus">+    return crc32_combine_(crc1, crc2, len2);</span>
<a href="#l9.438"></a><span id="l9.438" class="difflineplus">+}</span>
<a href="#l9.439"></a><span id="l9.439" class="difflineplus">+</span>
<a href="#l9.440"></a><span id="l9.440" class="difflineplus">+uLong ZEXPORT crc32_combine64(crc1, crc2, len2)</span>
<a href="#l9.441"></a><span id="l9.441" class="difflineplus">+    uLong crc1;</span>
<a href="#l9.442"></a><span id="l9.442" class="difflineplus">+    uLong crc2;</span>
<a href="#l9.443"></a><span id="l9.443" class="difflineplus">+    z_off64_t len2;</span>
<a href="#l9.444"></a><span id="l9.444" class="difflineplus">+{</span>
<a href="#l9.445"></a><span id="l9.445" class="difflineplus">+    return crc32_combine_(crc1, crc2, len2);</span>
<a href="#l9.446"></a><span id="l9.446" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1">new file mode 100644</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineminus">--- /dev/null</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineplus">+++ b/third_party/zlib/crc32.h</span>
<a href="#l10.4"></a><span id="l10.4" class="difflineat">@@ -0,0 +1,441 @@</span>
<a href="#l10.5"></a><span id="l10.5" class="difflineplus">+/* crc32.h -- tables for rapid CRC calculation</span>
<a href="#l10.6"></a><span id="l10.6" class="difflineplus">+ * Generated automatically by crc32.c</span>
<a href="#l10.7"></a><span id="l10.7" class="difflineplus">+ */</span>
<a href="#l10.8"></a><span id="l10.8" class="difflineplus">+</span>
<a href="#l10.9"></a><span id="l10.9" class="difflineplus">+local const z_crc_t FAR crc_table[TBLS][256] =</span>
<a href="#l10.10"></a><span id="l10.10" class="difflineplus">+{</span>
<a href="#l10.11"></a><span id="l10.11" class="difflineplus">+  {</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,</span>
<a href="#l10.14"></a><span id="l10.14" class="difflineplus">+    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,</span>
<a href="#l10.15"></a><span id="l10.15" class="difflineplus">+    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,</span>
<a href="#l10.16"></a><span id="l10.16" class="difflineplus">+    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,</span>
<a href="#l10.17"></a><span id="l10.17" class="difflineplus">+    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,</span>
<a href="#l10.18"></a><span id="l10.18" class="difflineplus">+    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,</span>
<a href="#l10.19"></a><span id="l10.19" class="difflineplus">+    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,</span>
<a href="#l10.20"></a><span id="l10.20" class="difflineplus">+    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,</span>
<a href="#l10.21"></a><span id="l10.21" class="difflineplus">+    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineplus">+    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,</span>
<a href="#l10.23"></a><span id="l10.23" class="difflineplus">+    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,</span>
<a href="#l10.24"></a><span id="l10.24" class="difflineplus">+    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,</span>
<a href="#l10.25"></a><span id="l10.25" class="difflineplus">+    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,</span>
<a href="#l10.26"></a><span id="l10.26" class="difflineplus">+    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,</span>
<a href="#l10.27"></a><span id="l10.27" class="difflineplus">+    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,</span>
<a href="#l10.28"></a><span id="l10.28" class="difflineplus">+    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,</span>
<a href="#l10.29"></a><span id="l10.29" class="difflineplus">+    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,</span>
<a href="#l10.30"></a><span id="l10.30" class="difflineplus">+    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,</span>
<a href="#l10.31"></a><span id="l10.31" class="difflineplus">+    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,</span>
<a href="#l10.32"></a><span id="l10.32" class="difflineplus">+    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,</span>
<a href="#l10.33"></a><span id="l10.33" class="difflineplus">+    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,</span>
<a href="#l10.34"></a><span id="l10.34" class="difflineplus">+    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,</span>
<a href="#l10.35"></a><span id="l10.35" class="difflineplus">+    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,</span>
<a href="#l10.36"></a><span id="l10.36" class="difflineplus">+    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,</span>
<a href="#l10.37"></a><span id="l10.37" class="difflineplus">+    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,</span>
<a href="#l10.38"></a><span id="l10.38" class="difflineplus">+    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,</span>
<a href="#l10.39"></a><span id="l10.39" class="difflineplus">+    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,</span>
<a href="#l10.40"></a><span id="l10.40" class="difflineplus">+    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,</span>
<a href="#l10.41"></a><span id="l10.41" class="difflineplus">+    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,</span>
<a href="#l10.42"></a><span id="l10.42" class="difflineplus">+    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,</span>
<a href="#l10.43"></a><span id="l10.43" class="difflineplus">+    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,</span>
<a href="#l10.44"></a><span id="l10.44" class="difflineplus">+    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,</span>
<a href="#l10.45"></a><span id="l10.45" class="difflineplus">+    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,</span>
<a href="#l10.46"></a><span id="l10.46" class="difflineplus">+    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,</span>
<a href="#l10.47"></a><span id="l10.47" class="difflineplus">+    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,</span>
<a href="#l10.48"></a><span id="l10.48" class="difflineplus">+    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,</span>
<a href="#l10.49"></a><span id="l10.49" class="difflineplus">+    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,</span>
<a href="#l10.50"></a><span id="l10.50" class="difflineplus">+    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,</span>
<a href="#l10.51"></a><span id="l10.51" class="difflineplus">+    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,</span>
<a href="#l10.52"></a><span id="l10.52" class="difflineplus">+    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,</span>
<a href="#l10.53"></a><span id="l10.53" class="difflineplus">+    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,</span>
<a href="#l10.54"></a><span id="l10.54" class="difflineplus">+    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,</span>
<a href="#l10.55"></a><span id="l10.55" class="difflineplus">+    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,</span>
<a href="#l10.56"></a><span id="l10.56" class="difflineplus">+    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,</span>
<a href="#l10.57"></a><span id="l10.57" class="difflineplus">+    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,</span>
<a href="#l10.58"></a><span id="l10.58" class="difflineplus">+    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,</span>
<a href="#l10.59"></a><span id="l10.59" class="difflineplus">+    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,</span>
<a href="#l10.60"></a><span id="l10.60" class="difflineplus">+    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,</span>
<a href="#l10.61"></a><span id="l10.61" class="difflineplus">+    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,</span>
<a href="#l10.62"></a><span id="l10.62" class="difflineplus">+    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,</span>
<a href="#l10.63"></a><span id="l10.63" class="difflineplus">+    0x2d02ef8dUL</span>
<a href="#l10.64"></a><span id="l10.64" class="difflineplus">+#ifdef BYFOUR</span>
<a href="#l10.65"></a><span id="l10.65" class="difflineplus">+  },</span>
<a href="#l10.66"></a><span id="l10.66" class="difflineplus">+  {</span>
<a href="#l10.67"></a><span id="l10.67" class="difflineplus">+    0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,</span>
<a href="#l10.68"></a><span id="l10.68" class="difflineplus">+    0x7d77f445UL, 0x565aa786UL, 0x4f4196c7UL, 0xc8d98a08UL, 0xd1c2bb49UL,</span>
<a href="#l10.69"></a><span id="l10.69" class="difflineplus">+    0xfaefe88aUL, 0xe3f4d9cbUL, 0xacb54f0cUL, 0xb5ae7e4dUL, 0x9e832d8eUL,</span>
<a href="#l10.70"></a><span id="l10.70" class="difflineplus">+    0x87981ccfUL, 0x4ac21251UL, 0x53d92310UL, 0x78f470d3UL, 0x61ef4192UL,</span>
<a href="#l10.71"></a><span id="l10.71" class="difflineplus">+    0x2eaed755UL, 0x37b5e614UL, 0x1c98b5d7UL, 0x05838496UL, 0x821b9859UL,</span>
<a href="#l10.72"></a><span id="l10.72" class="difflineplus">+    0x9b00a918UL, 0xb02dfadbUL, 0xa936cb9aUL, 0xe6775d5dUL, 0xff6c6c1cUL,</span>
<a href="#l10.73"></a><span id="l10.73" class="difflineplus">+    0xd4413fdfUL, 0xcd5a0e9eUL, 0x958424a2UL, 0x8c9f15e3UL, 0xa7b24620UL,</span>
<a href="#l10.74"></a><span id="l10.74" class="difflineplus">+    0xbea97761UL, 0xf1e8e1a6UL, 0xe8f3d0e7UL, 0xc3de8324UL, 0xdac5b265UL,</span>
<a href="#l10.75"></a><span id="l10.75" class="difflineplus">+    0x5d5daeaaUL, 0x44469febUL, 0x6f6bcc28UL, 0x7670fd69UL, 0x39316baeUL,</span>
<a href="#l10.76"></a><span id="l10.76" class="difflineplus">+    0x202a5aefUL, 0x0b07092cUL, 0x121c386dUL, 0xdf4636f3UL, 0xc65d07b2UL,</span>
<a href="#l10.77"></a><span id="l10.77" class="difflineplus">+    0xed705471UL, 0xf46b6530UL, 0xbb2af3f7UL, 0xa231c2b6UL, 0x891c9175UL,</span>
<a href="#l10.78"></a><span id="l10.78" class="difflineplus">+    0x9007a034UL, 0x179fbcfbUL, 0x0e848dbaUL, 0x25a9de79UL, 0x3cb2ef38UL,</span>
<a href="#l10.79"></a><span id="l10.79" class="difflineplus">+    0x73f379ffUL, 0x6ae848beUL, 0x41c51b7dUL, 0x58de2a3cUL, 0xf0794f05UL,</span>
<a href="#l10.80"></a><span id="l10.80" class="difflineplus">+    0xe9627e44UL, 0xc24f2d87UL, 0xdb541cc6UL, 0x94158a01UL, 0x8d0ebb40UL,</span>
<a href="#l10.81"></a><span id="l10.81" class="difflineplus">+    0xa623e883UL, 0xbf38d9c2UL, 0x38a0c50dUL, 0x21bbf44cUL, 0x0a96a78fUL,</span>
<a href="#l10.82"></a><span id="l10.82" class="difflineplus">+    0x138d96ceUL, 0x5ccc0009UL, 0x45d73148UL, 0x6efa628bUL, 0x77e153caUL,</span>
<a href="#l10.83"></a><span id="l10.83" class="difflineplus">+    0xbabb5d54UL, 0xa3a06c15UL, 0x888d3fd6UL, 0x91960e97UL, 0xded79850UL,</span>
<a href="#l10.84"></a><span id="l10.84" class="difflineplus">+    0xc7cca911UL, 0xece1fad2UL, 0xf5facb93UL, 0x7262d75cUL, 0x6b79e61dUL,</span>
<a href="#l10.85"></a><span id="l10.85" class="difflineplus">+    0x4054b5deUL, 0x594f849fUL, 0x160e1258UL, 0x0f152319UL, 0x243870daUL,</span>
<a href="#l10.86"></a><span id="l10.86" class="difflineplus">+    0x3d23419bUL, 0x65fd6ba7UL, 0x7ce65ae6UL, 0x57cb0925UL, 0x4ed03864UL,</span>
<a href="#l10.87"></a><span id="l10.87" class="difflineplus">+    0x0191aea3UL, 0x188a9fe2UL, 0x33a7cc21UL, 0x2abcfd60UL, 0xad24e1afUL,</span>
<a href="#l10.88"></a><span id="l10.88" class="difflineplus">+    0xb43fd0eeUL, 0x9f12832dUL, 0x8609b26cUL, 0xc94824abUL, 0xd05315eaUL,</span>
<a href="#l10.89"></a><span id="l10.89" class="difflineplus">+    0xfb7e4629UL, 0xe2657768UL, 0x2f3f79f6UL, 0x362448b7UL, 0x1d091b74UL,</span>
<a href="#l10.90"></a><span id="l10.90" class="difflineplus">+    0x04122a35UL, 0x4b53bcf2UL, 0x52488db3UL, 0x7965de70UL, 0x607eef31UL,</span>
<a href="#l10.91"></a><span id="l10.91" class="difflineplus">+    0xe7e6f3feUL, 0xfefdc2bfUL, 0xd5d0917cUL, 0xcccba03dUL, 0x838a36faUL,</span>
<a href="#l10.92"></a><span id="l10.92" class="difflineplus">+    0x9a9107bbUL, 0xb1bc5478UL, 0xa8a76539UL, 0x3b83984bUL, 0x2298a90aUL,</span>
<a href="#l10.93"></a><span id="l10.93" class="difflineplus">+    0x09b5fac9UL, 0x10aecb88UL, 0x5fef5d4fUL, 0x46f46c0eUL, 0x6dd93fcdUL,</span>
<a href="#l10.94"></a><span id="l10.94" class="difflineplus">+    0x74c20e8cUL, 0xf35a1243UL, 0xea412302UL, 0xc16c70c1UL, 0xd8774180UL,</span>
<a href="#l10.95"></a><span id="l10.95" class="difflineplus">+    0x9736d747UL, 0x8e2de606UL, 0xa500b5c5UL, 0xbc1b8484UL, 0x71418a1aUL,</span>
<a href="#l10.96"></a><span id="l10.96" class="difflineplus">+    0x685abb5bUL, 0x4377e898UL, 0x5a6cd9d9UL, 0x152d4f1eUL, 0x0c367e5fUL,</span>
<a href="#l10.97"></a><span id="l10.97" class="difflineplus">+    0x271b2d9cUL, 0x3e001cddUL, 0xb9980012UL, 0xa0833153UL, 0x8bae6290UL,</span>
<a href="#l10.98"></a><span id="l10.98" class="difflineplus">+    0x92b553d1UL, 0xddf4c516UL, 0xc4eff457UL, 0xefc2a794UL, 0xf6d996d5UL,</span>
<a href="#l10.99"></a><span id="l10.99" class="difflineplus">+    0xae07bce9UL, 0xb71c8da8UL, 0x9c31de6bUL, 0x852aef2aUL, 0xca6b79edUL,</span>
<a href="#l10.100"></a><span id="l10.100" class="difflineplus">+    0xd37048acUL, 0xf85d1b6fUL, 0xe1462a2eUL, 0x66de36e1UL, 0x7fc507a0UL,</span>
<a href="#l10.101"></a><span id="l10.101" class="difflineplus">+    0x54e85463UL, 0x4df36522UL, 0x02b2f3e5UL, 0x1ba9c2a4UL, 0x30849167UL,</span>
<a href="#l10.102"></a><span id="l10.102" class="difflineplus">+    0x299fa026UL, 0xe4c5aeb8UL, 0xfdde9ff9UL, 0xd6f3cc3aUL, 0xcfe8fd7bUL,</span>
<a href="#l10.103"></a><span id="l10.103" class="difflineplus">+    0x80a96bbcUL, 0x99b25afdUL, 0xb29f093eUL, 0xab84387fUL, 0x2c1c24b0UL,</span>
<a href="#l10.104"></a><span id="l10.104" class="difflineplus">+    0x350715f1UL, 0x1e2a4632UL, 0x07317773UL, 0x4870e1b4UL, 0x516bd0f5UL,</span>
<a href="#l10.105"></a><span id="l10.105" class="difflineplus">+    0x7a468336UL, 0x635db277UL, 0xcbfad74eUL, 0xd2e1e60fUL, 0xf9ccb5ccUL,</span>
<a href="#l10.106"></a><span id="l10.106" class="difflineplus">+    0xe0d7848dUL, 0xaf96124aUL, 0xb68d230bUL, 0x9da070c8UL, 0x84bb4189UL,</span>
<a href="#l10.107"></a><span id="l10.107" class="difflineplus">+    0x03235d46UL, 0x1a386c07UL, 0x31153fc4UL, 0x280e0e85UL, 0x674f9842UL,</span>
<a href="#l10.108"></a><span id="l10.108" class="difflineplus">+    0x7e54a903UL, 0x5579fac0UL, 0x4c62cb81UL, 0x8138c51fUL, 0x9823f45eUL,</span>
<a href="#l10.109"></a><span id="l10.109" class="difflineplus">+    0xb30ea79dUL, 0xaa1596dcUL, 0xe554001bUL, 0xfc4f315aUL, 0xd7626299UL,</span>
<a href="#l10.110"></a><span id="l10.110" class="difflineplus">+    0xce7953d8UL, 0x49e14f17UL, 0x50fa7e56UL, 0x7bd72d95UL, 0x62cc1cd4UL,</span>
<a href="#l10.111"></a><span id="l10.111" class="difflineplus">+    0x2d8d8a13UL, 0x3496bb52UL, 0x1fbbe891UL, 0x06a0d9d0UL, 0x5e7ef3ecUL,</span>
<a href="#l10.112"></a><span id="l10.112" class="difflineplus">+    0x4765c2adUL, 0x6c48916eUL, 0x7553a02fUL, 0x3a1236e8UL, 0x230907a9UL,</span>
<a href="#l10.113"></a><span id="l10.113" class="difflineplus">+    0x0824546aUL, 0x113f652bUL, 0x96a779e4UL, 0x8fbc48a5UL, 0xa4911b66UL,</span>
<a href="#l10.114"></a><span id="l10.114" class="difflineplus">+    0xbd8a2a27UL, 0xf2cbbce0UL, 0xebd08da1UL, 0xc0fdde62UL, 0xd9e6ef23UL,</span>
<a href="#l10.115"></a><span id="l10.115" class="difflineplus">+    0x14bce1bdUL, 0x0da7d0fcUL, 0x268a833fUL, 0x3f91b27eUL, 0x70d024b9UL,</span>
<a href="#l10.116"></a><span id="l10.116" class="difflineplus">+    0x69cb15f8UL, 0x42e6463bUL, 0x5bfd777aUL, 0xdc656bb5UL, 0xc57e5af4UL,</span>
<a href="#l10.117"></a><span id="l10.117" class="difflineplus">+    0xee530937UL, 0xf7483876UL, 0xb809aeb1UL, 0xa1129ff0UL, 0x8a3fcc33UL,</span>
<a href="#l10.118"></a><span id="l10.118" class="difflineplus">+    0x9324fd72UL</span>
<a href="#l10.119"></a><span id="l10.119" class="difflineplus">+  },</span>
<a href="#l10.120"></a><span id="l10.120" class="difflineplus">+  {</span>
<a href="#l10.121"></a><span id="l10.121" class="difflineplus">+    0x00000000UL, 0x01c26a37UL, 0x0384d46eUL, 0x0246be59UL, 0x0709a8dcUL,</span>
<a href="#l10.122"></a><span id="l10.122" class="difflineplus">+    0x06cbc2ebUL, 0x048d7cb2UL, 0x054f1685UL, 0x0e1351b8UL, 0x0fd13b8fUL,</span>
<a href="#l10.123"></a><span id="l10.123" class="difflineplus">+    0x0d9785d6UL, 0x0c55efe1UL, 0x091af964UL, 0x08d89353UL, 0x0a9e2d0aUL,</span>
<a href="#l10.124"></a><span id="l10.124" class="difflineplus">+    0x0b5c473dUL, 0x1c26a370UL, 0x1de4c947UL, 0x1fa2771eUL, 0x1e601d29UL,</span>
<a href="#l10.125"></a><span id="l10.125" class="difflineplus">+    0x1b2f0bacUL, 0x1aed619bUL, 0x18abdfc2UL, 0x1969b5f5UL, 0x1235f2c8UL,</span>
<a href="#l10.126"></a><span id="l10.126" class="difflineplus">+    0x13f798ffUL, 0x11b126a6UL, 0x10734c91UL, 0x153c5a14UL, 0x14fe3023UL,</span>
<a href="#l10.127"></a><span id="l10.127" class="difflineplus">+    0x16b88e7aUL, 0x177ae44dUL, 0x384d46e0UL, 0x398f2cd7UL, 0x3bc9928eUL,</span>
<a href="#l10.128"></a><span id="l10.128" class="difflineplus">+    0x3a0bf8b9UL, 0x3f44ee3cUL, 0x3e86840bUL, 0x3cc03a52UL, 0x3d025065UL,</span>
<a href="#l10.129"></a><span id="l10.129" class="difflineplus">+    0x365e1758UL, 0x379c7d6fUL, 0x35dac336UL, 0x3418a901UL, 0x3157bf84UL,</span>
<a href="#l10.130"></a><span id="l10.130" class="difflineplus">+    0x3095d5b3UL, 0x32d36beaUL, 0x331101ddUL, 0x246be590UL, 0x25a98fa7UL,</span>
<a href="#l10.131"></a><span id="l10.131" class="difflineplus">+    0x27ef31feUL, 0x262d5bc9UL, 0x23624d4cUL, 0x22a0277bUL, 0x20e69922UL,</span>
<a href="#l10.132"></a><span id="l10.132" class="difflineplus">+    0x2124f315UL, 0x2a78b428UL, 0x2bbade1fUL, 0x29fc6046UL, 0x283e0a71UL,</span>
<a href="#l10.133"></a><span id="l10.133" class="difflineplus">+    0x2d711cf4UL, 0x2cb376c3UL, 0x2ef5c89aUL, 0x2f37a2adUL, 0x709a8dc0UL,</span>
<a href="#l10.134"></a><span id="l10.134" class="difflineplus">+    0x7158e7f7UL, 0x731e59aeUL, 0x72dc3399UL, 0x7793251cUL, 0x76514f2bUL,</span>
<a href="#l10.135"></a><span id="l10.135" class="difflineplus">+    0x7417f172UL, 0x75d59b45UL, 0x7e89dc78UL, 0x7f4bb64fUL, 0x7d0d0816UL,</span>
<a href="#l10.136"></a><span id="l10.136" class="difflineplus">+    0x7ccf6221UL, 0x798074a4UL, 0x78421e93UL, 0x7a04a0caUL, 0x7bc6cafdUL,</span>
<a href="#l10.137"></a><span id="l10.137" class="difflineplus">+    0x6cbc2eb0UL, 0x6d7e4487UL, 0x6f38fadeUL, 0x6efa90e9UL, 0x6bb5866cUL,</span>
<a href="#l10.138"></a><span id="l10.138" class="difflineplus">+    0x6a77ec5bUL, 0x68315202UL, 0x69f33835UL, 0x62af7f08UL, 0x636d153fUL,</span>
<a href="#l10.139"></a><span id="l10.139" class="difflineplus">+    0x612bab66UL, 0x60e9c151UL, 0x65a6d7d4UL, 0x6464bde3UL, 0x662203baUL,</span>
<a href="#l10.140"></a><span id="l10.140" class="difflineplus">+    0x67e0698dUL, 0x48d7cb20UL, 0x4915a117UL, 0x4b531f4eUL, 0x4a917579UL,</span>
<a href="#l10.141"></a><span id="l10.141" class="difflineplus">+    0x4fde63fcUL, 0x4e1c09cbUL, 0x4c5ab792UL, 0x4d98dda5UL, 0x46c49a98UL,</span>
<a href="#l10.142"></a><span id="l10.142" class="difflineplus">+    0x4706f0afUL, 0x45404ef6UL, 0x448224c1UL, 0x41cd3244UL, 0x400f5873UL,</span>
<a href="#l10.143"></a><span id="l10.143" class="difflineplus">+    0x4249e62aUL, 0x438b8c1dUL, 0x54f16850UL, 0x55330267UL, 0x5775bc3eUL,</span>
<a href="#l10.144"></a><span id="l10.144" class="difflineplus">+    0x56b7d609UL, 0x53f8c08cUL, 0x523aaabbUL, 0x507c14e2UL, 0x51be7ed5UL,</span>
<a href="#l10.145"></a><span id="l10.145" class="difflineplus">+    0x5ae239e8UL, 0x5b2053dfUL, 0x5966ed86UL, 0x58a487b1UL, 0x5deb9134UL,</span>
<a href="#l10.146"></a><span id="l10.146" class="difflineplus">+    0x5c29fb03UL, 0x5e6f455aUL, 0x5fad2f6dUL, 0xe1351b80UL, 0xe0f771b7UL,</span>
<a href="#l10.147"></a><span id="l10.147" class="difflineplus">+    0xe2b1cfeeUL, 0xe373a5d9UL, 0xe63cb35cUL, 0xe7fed96bUL, 0xe5b86732UL,</span>
<a href="#l10.148"></a><span id="l10.148" class="difflineplus">+    0xe47a0d05UL, 0xef264a38UL, 0xeee4200fUL, 0xeca29e56UL, 0xed60f461UL,</span>
<a href="#l10.149"></a><span id="l10.149" class="difflineplus">+    0xe82fe2e4UL, 0xe9ed88d3UL, 0xebab368aUL, 0xea695cbdUL, 0xfd13b8f0UL,</span>
<a href="#l10.150"></a><span id="l10.150" class="difflineplus">+    0xfcd1d2c7UL, 0xfe976c9eUL, 0xff5506a9UL, 0xfa1a102cUL, 0xfbd87a1bUL,</span>
<a href="#l10.151"></a><span id="l10.151" class="difflineplus">+    0xf99ec442UL, 0xf85cae75UL, 0xf300e948UL, 0xf2c2837fUL, 0xf0843d26UL,</span>
<a href="#l10.152"></a><span id="l10.152" class="difflineplus">+    0xf1465711UL, 0xf4094194UL, 0xf5cb2ba3UL, 0xf78d95faUL, 0xf64fffcdUL,</span>
<a href="#l10.153"></a><span id="l10.153" class="difflineplus">+    0xd9785d60UL, 0xd8ba3757UL, 0xdafc890eUL, 0xdb3ee339UL, 0xde71f5bcUL,</span>
<a href="#l10.154"></a><span id="l10.154" class="difflineplus">+    0xdfb39f8bUL, 0xddf521d2UL, 0xdc374be5UL, 0xd76b0cd8UL, 0xd6a966efUL,</span>
<a href="#l10.155"></a><span id="l10.155" class="difflineplus">+    0xd4efd8b6UL, 0xd52db281UL, 0xd062a404UL, 0xd1a0ce33UL, 0xd3e6706aUL,</span>
<a href="#l10.156"></a><span id="l10.156" class="difflineplus">+    0xd2241a5dUL, 0xc55efe10UL, 0xc49c9427UL, 0xc6da2a7eUL, 0xc7184049UL,</span>
<a href="#l10.157"></a><span id="l10.157" class="difflineplus">+    0xc25756ccUL, 0xc3953cfbUL, 0xc1d382a2UL, 0xc011e895UL, 0xcb4dafa8UL,</span>
<a href="#l10.158"></a><span id="l10.158" class="difflineplus">+    0xca8fc59fUL, 0xc8c97bc6UL, 0xc90b11f1UL, 0xcc440774UL, 0xcd866d43UL,</span>
<a href="#l10.159"></a><span id="l10.159" class="difflineplus">+    0xcfc0d31aUL, 0xce02b92dUL, 0x91af9640UL, 0x906dfc77UL, 0x922b422eUL,</span>
<a href="#l10.160"></a><span id="l10.160" class="difflineplus">+    0x93e92819UL, 0x96a63e9cUL, 0x976454abUL, 0x9522eaf2UL, 0x94e080c5UL,</span>
<a href="#l10.161"></a><span id="l10.161" class="difflineplus">+    0x9fbcc7f8UL, 0x9e7eadcfUL, 0x9c381396UL, 0x9dfa79a1UL, 0x98b56f24UL,</span>
<a href="#l10.162"></a><span id="l10.162" class="difflineplus">+    0x99770513UL, 0x9b31bb4aUL, 0x9af3d17dUL, 0x8d893530UL, 0x8c4b5f07UL,</span>
<a href="#l10.163"></a><span id="l10.163" class="difflineplus">+    0x8e0de15eUL, 0x8fcf8b69UL, 0x8a809decUL, 0x8b42f7dbUL, 0x89044982UL,</span>
<a href="#l10.164"></a><span id="l10.164" class="difflineplus">+    0x88c623b5UL, 0x839a6488UL, 0x82580ebfUL, 0x801eb0e6UL, 0x81dcdad1UL,</span>
<a href="#l10.165"></a><span id="l10.165" class="difflineplus">+    0x8493cc54UL, 0x8551a663UL, 0x8717183aUL, 0x86d5720dUL, 0xa9e2d0a0UL,</span>
<a href="#l10.166"></a><span id="l10.166" class="difflineplus">+    0xa820ba97UL, 0xaa6604ceUL, 0xaba46ef9UL, 0xaeeb787cUL, 0xaf29124bUL,</span>
<a href="#l10.167"></a><span id="l10.167" class="difflineplus">+    0xad6fac12UL, 0xacadc625UL, 0xa7f18118UL, 0xa633eb2fUL, 0xa4755576UL,</span>
<a href="#l10.168"></a><span id="l10.168" class="difflineplus">+    0xa5b73f41UL, 0xa0f829c4UL, 0xa13a43f3UL, 0xa37cfdaaUL, 0xa2be979dUL,</span>
<a href="#l10.169"></a><span id="l10.169" class="difflineplus">+    0xb5c473d0UL, 0xb40619e7UL, 0xb640a7beUL, 0xb782cd89UL, 0xb2cddb0cUL,</span>
<a href="#l10.170"></a><span id="l10.170" class="difflineplus">+    0xb30fb13bUL, 0xb1490f62UL, 0xb08b6555UL, 0xbbd72268UL, 0xba15485fUL,</span>
<a href="#l10.171"></a><span id="l10.171" class="difflineplus">+    0xb853f606UL, 0xb9919c31UL, 0xbcde8ab4UL, 0xbd1ce083UL, 0xbf5a5edaUL,</span>
<a href="#l10.172"></a><span id="l10.172" class="difflineplus">+    0xbe9834edUL</span>
<a href="#l10.173"></a><span id="l10.173" class="difflineplus">+  },</span>
<a href="#l10.174"></a><span id="l10.174" class="difflineplus">+  {</span>
<a href="#l10.175"></a><span id="l10.175" class="difflineplus">+    0x00000000UL, 0xb8bc6765UL, 0xaa09c88bUL, 0x12b5afeeUL, 0x8f629757UL,</span>
<a href="#l10.176"></a><span id="l10.176" class="difflineplus">+    0x37def032UL, 0x256b5fdcUL, 0x9dd738b9UL, 0xc5b428efUL, 0x7d084f8aUL,</span>
<a href="#l10.177"></a><span id="l10.177" class="difflineplus">+    0x6fbde064UL, 0xd7018701UL, 0x4ad6bfb8UL, 0xf26ad8ddUL, 0xe0df7733UL,</span>
<a href="#l10.178"></a><span id="l10.178" class="difflineplus">+    0x58631056UL, 0x5019579fUL, 0xe8a530faUL, 0xfa109f14UL, 0x42acf871UL,</span>
<a href="#l10.179"></a><span id="l10.179" class="difflineplus">+    0xdf7bc0c8UL, 0x67c7a7adUL, 0x75720843UL, 0xcdce6f26UL, 0x95ad7f70UL,</span>
<a href="#l10.180"></a><span id="l10.180" class="difflineplus">+    0x2d111815UL, 0x3fa4b7fbUL, 0x8718d09eUL, 0x1acfe827UL, 0xa2738f42UL,</span>
<a href="#l10.181"></a><span id="l10.181" class="difflineplus">+    0xb0c620acUL, 0x087a47c9UL, 0xa032af3eUL, 0x188ec85bUL, 0x0a3b67b5UL,</span>
<a href="#l10.182"></a><span id="l10.182" class="difflineplus">+    0xb28700d0UL, 0x2f503869UL, 0x97ec5f0cUL, 0x8559f0e2UL, 0x3de59787UL,</span>
<a href="#l10.183"></a><span id="l10.183" class="difflineplus">+    0x658687d1UL, 0xdd3ae0b4UL, 0xcf8f4f5aUL, 0x7733283fUL, 0xeae41086UL,</span>
<a href="#l10.184"></a><span id="l10.184" class="difflineplus">+    0x525877e3UL, 0x40edd80dUL, 0xf851bf68UL, 0xf02bf8a1UL, 0x48979fc4UL,</span>
<a href="#l10.185"></a><span id="l10.185" class="difflineplus">+    0x5a22302aUL, 0xe29e574fUL, 0x7f496ff6UL, 0xc7f50893UL, 0xd540a77dUL,</span>
<a href="#l10.186"></a><span id="l10.186" class="difflineplus">+    0x6dfcc018UL, 0x359fd04eUL, 0x8d23b72bUL, 0x9f9618c5UL, 0x272a7fa0UL,</span>
<a href="#l10.187"></a><span id="l10.187" class="difflineplus">+    0xbafd4719UL, 0x0241207cUL, 0x10f48f92UL, 0xa848e8f7UL, 0x9b14583dUL,</span>
<a href="#l10.188"></a><span id="l10.188" class="difflineplus">+    0x23a83f58UL, 0x311d90b6UL, 0x89a1f7d3UL, 0x1476cf6aUL, 0xaccaa80fUL,</span>
<a href="#l10.189"></a><span id="l10.189" class="difflineplus">+    0xbe7f07e1UL, 0x06c36084UL, 0x5ea070d2UL, 0xe61c17b7UL, 0xf4a9b859UL,</span>
<a href="#l10.190"></a><span id="l10.190" class="difflineplus">+    0x4c15df3cUL, 0xd1c2e785UL, 0x697e80e0UL, 0x7bcb2f0eUL, 0xc377486bUL,</span>
<a href="#l10.191"></a><span id="l10.191" class="difflineplus">+    0xcb0d0fa2UL, 0x73b168c7UL, 0x6104c729UL, 0xd9b8a04cUL, 0x446f98f5UL,</span>
<a href="#l10.192"></a><span id="l10.192" class="difflineplus">+    0xfcd3ff90UL, 0xee66507eUL, 0x56da371bUL, 0x0eb9274dUL, 0xb6054028UL,</span>
<a href="#l10.193"></a><span id="l10.193" class="difflineplus">+    0xa4b0efc6UL, 0x1c0c88a3UL, 0x81dbb01aUL, 0x3967d77fUL, 0x2bd27891UL,</span>
<a href="#l10.194"></a><span id="l10.194" class="difflineplus">+    0x936e1ff4UL, 0x3b26f703UL, 0x839a9066UL, 0x912f3f88UL, 0x299358edUL,</span>
<a href="#l10.195"></a><span id="l10.195" class="difflineplus">+    0xb4446054UL, 0x0cf80731UL, 0x1e4da8dfUL, 0xa6f1cfbaUL, 0xfe92dfecUL,</span>
<a href="#l10.196"></a><span id="l10.196" class="difflineplus">+    0x462eb889UL, 0x549b1767UL, 0xec277002UL, 0x71f048bbUL, 0xc94c2fdeUL,</span>
<a href="#l10.197"></a><span id="l10.197" class="difflineplus">+    0xdbf98030UL, 0x6345e755UL, 0x6b3fa09cUL, 0xd383c7f9UL, 0xc1366817UL,</span>
<a href="#l10.198"></a><span id="l10.198" class="difflineplus">+    0x798a0f72UL, 0xe45d37cbUL, 0x5ce150aeUL, 0x4e54ff40UL, 0xf6e89825UL,</span>
<a href="#l10.199"></a><span id="l10.199" class="difflineplus">+    0xae8b8873UL, 0x1637ef16UL, 0x048240f8UL, 0xbc3e279dUL, 0x21e91f24UL,</span>
<a href="#l10.200"></a><span id="l10.200" class="difflineplus">+    0x99557841UL, 0x8be0d7afUL, 0x335cb0caUL, 0xed59b63bUL, 0x55e5d15eUL,</span>
<a href="#l10.201"></a><span id="l10.201" class="difflineplus">+    0x47507eb0UL, 0xffec19d5UL, 0x623b216cUL, 0xda874609UL, 0xc832e9e7UL,</span>
<a href="#l10.202"></a><span id="l10.202" class="difflineplus">+    0x708e8e82UL, 0x28ed9ed4UL, 0x9051f9b1UL, 0x82e4565fUL, 0x3a58313aUL,</span>
<a href="#l10.203"></a><span id="l10.203" class="difflineplus">+    0xa78f0983UL, 0x1f336ee6UL, 0x0d86c108UL, 0xb53aa66dUL, 0xbd40e1a4UL,</span>
<a href="#l10.204"></a><span id="l10.204" class="difflineplus">+    0x05fc86c1UL, 0x1749292fUL, 0xaff54e4aUL, 0x322276f3UL, 0x8a9e1196UL,</span>
<a href="#l10.205"></a><span id="l10.205" class="difflineplus">+    0x982bbe78UL, 0x2097d91dUL, 0x78f4c94bUL, 0xc048ae2eUL, 0xd2fd01c0UL,</span>
<a href="#l10.206"></a><span id="l10.206" class="difflineplus">+    0x6a4166a5UL, 0xf7965e1cUL, 0x4f2a3979UL, 0x5d9f9697UL, 0xe523f1f2UL,</span>
<a href="#l10.207"></a><span id="l10.207" class="difflineplus">+    0x4d6b1905UL, 0xf5d77e60UL, 0xe762d18eUL, 0x5fdeb6ebUL, 0xc2098e52UL,</span>
<a href="#l10.208"></a><span id="l10.208" class="difflineplus">+    0x7ab5e937UL, 0x680046d9UL, 0xd0bc21bcUL, 0x88df31eaUL, 0x3063568fUL,</span>
<a href="#l10.209"></a><span id="l10.209" class="difflineplus">+    0x22d6f961UL, 0x9a6a9e04UL, 0x07bda6bdUL, 0xbf01c1d8UL, 0xadb46e36UL,</span>
<a href="#l10.210"></a><span id="l10.210" class="difflineplus">+    0x15080953UL, 0x1d724e9aUL, 0xa5ce29ffUL, 0xb77b8611UL, 0x0fc7e174UL,</span>
<a href="#l10.211"></a><span id="l10.211" class="difflineplus">+    0x9210d9cdUL, 0x2aacbea8UL, 0x38191146UL, 0x80a57623UL, 0xd8c66675UL,</span>
<a href="#l10.212"></a><span id="l10.212" class="difflineplus">+    0x607a0110UL, 0x72cfaefeUL, 0xca73c99bUL, 0x57a4f122UL, 0xef189647UL,</span>
<a href="#l10.213"></a><span id="l10.213" class="difflineplus">+    0xfdad39a9UL, 0x45115eccUL, 0x764dee06UL, 0xcef18963UL, 0xdc44268dUL,</span>
<a href="#l10.214"></a><span id="l10.214" class="difflineplus">+    0x64f841e8UL, 0xf92f7951UL, 0x41931e34UL, 0x5326b1daUL, 0xeb9ad6bfUL,</span>
<a href="#l10.215"></a><span id="l10.215" class="difflineplus">+    0xb3f9c6e9UL, 0x0b45a18cUL, 0x19f00e62UL, 0xa14c6907UL, 0x3c9b51beUL,</span>
<a href="#l10.216"></a><span id="l10.216" class="difflineplus">+    0x842736dbUL, 0x96929935UL, 0x2e2efe50UL, 0x2654b999UL, 0x9ee8defcUL,</span>
<a href="#l10.217"></a><span id="l10.217" class="difflineplus">+    0x8c5d7112UL, 0x34e11677UL, 0xa9362eceUL, 0x118a49abUL, 0x033fe645UL,</span>
<a href="#l10.218"></a><span id="l10.218" class="difflineplus">+    0xbb838120UL, 0xe3e09176UL, 0x5b5cf613UL, 0x49e959fdUL, 0xf1553e98UL,</span>
<a href="#l10.219"></a><span id="l10.219" class="difflineplus">+    0x6c820621UL, 0xd43e6144UL, 0xc68bceaaUL, 0x7e37a9cfUL, 0xd67f4138UL,</span>
<a href="#l10.220"></a><span id="l10.220" class="difflineplus">+    0x6ec3265dUL, 0x7c7689b3UL, 0xc4caeed6UL, 0x591dd66fUL, 0xe1a1b10aUL,</span>
<a href="#l10.221"></a><span id="l10.221" class="difflineplus">+    0xf3141ee4UL, 0x4ba87981UL, 0x13cb69d7UL, 0xab770eb2UL, 0xb9c2a15cUL,</span>
<a href="#l10.222"></a><span id="l10.222" class="difflineplus">+    0x017ec639UL, 0x9ca9fe80UL, 0x241599e5UL, 0x36a0360bUL, 0x8e1c516eUL,</span>
<a href="#l10.223"></a><span id="l10.223" class="difflineplus">+    0x866616a7UL, 0x3eda71c2UL, 0x2c6fde2cUL, 0x94d3b949UL, 0x090481f0UL,</span>
<a href="#l10.224"></a><span id="l10.224" class="difflineplus">+    0xb1b8e695UL, 0xa30d497bUL, 0x1bb12e1eUL, 0x43d23e48UL, 0xfb6e592dUL,</span>
<a href="#l10.225"></a><span id="l10.225" class="difflineplus">+    0xe9dbf6c3UL, 0x516791a6UL, 0xccb0a91fUL, 0x740cce7aUL, 0x66b96194UL,</span>
<a href="#l10.226"></a><span id="l10.226" class="difflineplus">+    0xde0506f1UL</span>
<a href="#l10.227"></a><span id="l10.227" class="difflineplus">+  },</span>
<a href="#l10.228"></a><span id="l10.228" class="difflineplus">+  {</span>
<a href="#l10.229"></a><span id="l10.229" class="difflineplus">+    0x00000000UL, 0x96300777UL, 0x2c610eeeUL, 0xba510999UL, 0x19c46d07UL,</span>
<a href="#l10.230"></a><span id="l10.230" class="difflineplus">+    0x8ff46a70UL, 0x35a563e9UL, 0xa395649eUL, 0x3288db0eUL, 0xa4b8dc79UL,</span>
<a href="#l10.231"></a><span id="l10.231" class="difflineplus">+    0x1ee9d5e0UL, 0x88d9d297UL, 0x2b4cb609UL, 0xbd7cb17eUL, 0x072db8e7UL,</span>
<a href="#l10.232"></a><span id="l10.232" class="difflineplus">+    0x911dbf90UL, 0x6410b71dUL, 0xf220b06aUL, 0x4871b9f3UL, 0xde41be84UL,</span>
<a href="#l10.233"></a><span id="l10.233" class="difflineplus">+    0x7dd4da1aUL, 0xebe4dd6dUL, 0x51b5d4f4UL, 0xc785d383UL, 0x56986c13UL,</span>
<a href="#l10.234"></a><span id="l10.234" class="difflineplus">+    0xc0a86b64UL, 0x7af962fdUL, 0xecc9658aUL, 0x4f5c0114UL, 0xd96c0663UL,</span>
<a href="#l10.235"></a><span id="l10.235" class="difflineplus">+    0x633d0ffaUL, 0xf50d088dUL, 0xc8206e3bUL, 0x5e10694cUL, 0xe44160d5UL,</span>
<a href="#l10.236"></a><span id="l10.236" class="difflineplus">+    0x727167a2UL, 0xd1e4033cUL, 0x47d4044bUL, 0xfd850dd2UL, 0x6bb50aa5UL,</span>
<a href="#l10.237"></a><span id="l10.237" class="difflineplus">+    0xfaa8b535UL, 0x6c98b242UL, 0xd6c9bbdbUL, 0x40f9bcacUL, 0xe36cd832UL,</span>
<a href="#l10.238"></a><span id="l10.238" class="difflineplus">+    0x755cdf45UL, 0xcf0dd6dcUL, 0x593dd1abUL, 0xac30d926UL, 0x3a00de51UL,</span>
<a href="#l10.239"></a><span id="l10.239" class="difflineplus">+    0x8051d7c8UL, 0x1661d0bfUL, 0xb5f4b421UL, 0x23c4b356UL, 0x9995bacfUL,</span>
<a href="#l10.240"></a><span id="l10.240" class="difflineplus">+    0x0fa5bdb8UL, 0x9eb80228UL, 0x0888055fUL, 0xb2d90cc6UL, 0x24e90bb1UL,</span>
<a href="#l10.241"></a><span id="l10.241" class="difflineplus">+    0x877c6f2fUL, 0x114c6858UL, 0xab1d61c1UL, 0x3d2d66b6UL, 0x9041dc76UL,</span>
<a href="#l10.242"></a><span id="l10.242" class="difflineplus">+    0x0671db01UL, 0xbc20d298UL, 0x2a10d5efUL, 0x8985b171UL, 0x1fb5b606UL,</span>
<a href="#l10.243"></a><span id="l10.243" class="difflineplus">+    0xa5e4bf9fUL, 0x33d4b8e8UL, 0xa2c90778UL, 0x34f9000fUL, 0x8ea80996UL,</span>
<a href="#l10.244"></a><span id="l10.244" class="difflineplus">+    0x18980ee1UL, 0xbb0d6a7fUL, 0x2d3d6d08UL, 0x976c6491UL, 0x015c63e6UL,</span>
<a href="#l10.245"></a><span id="l10.245" class="difflineplus">+    0xf4516b6bUL, 0x62616c1cUL, 0xd8306585UL, 0x4e0062f2UL, 0xed95066cUL,</span>
<a href="#l10.246"></a><span id="l10.246" class="difflineplus">+    0x7ba5011bUL, 0xc1f40882UL, 0x57c40ff5UL, 0xc6d9b065UL, 0x50e9b712UL,</span>
<a href="#l10.247"></a><span id="l10.247" class="difflineplus">+    0xeab8be8bUL, 0x7c88b9fcUL, 0xdf1ddd62UL, 0x492dda15UL, 0xf37cd38cUL,</span>
<a href="#l10.248"></a><span id="l10.248" class="difflineplus">+    0x654cd4fbUL, 0x5861b24dUL, 0xce51b53aUL, 0x7400bca3UL, 0xe230bbd4UL,</span>
<a href="#l10.249"></a><span id="l10.249" class="difflineplus">+    0x41a5df4aUL, 0xd795d83dUL, 0x6dc4d1a4UL, 0xfbf4d6d3UL, 0x6ae96943UL,</span>
<a href="#l10.250"></a><span id="l10.250" class="difflineplus">+    0xfcd96e34UL, 0x468867adUL, 0xd0b860daUL, 0x732d0444UL, 0xe51d0333UL,</span>
<a href="#l10.251"></a><span id="l10.251" class="difflineplus">+    0x5f4c0aaaUL, 0xc97c0dddUL, 0x3c710550UL, 0xaa410227UL, 0x10100bbeUL,</span>
<a href="#l10.252"></a><span id="l10.252" class="difflineplus">+    0x86200cc9UL, 0x25b56857UL, 0xb3856f20UL, 0x09d466b9UL, 0x9fe461ceUL,</span>
<a href="#l10.253"></a><span id="l10.253" class="difflineplus">+    0x0ef9de5eUL, 0x98c9d929UL, 0x2298d0b0UL, 0xb4a8d7c7UL, 0x173db359UL,</span>
<a href="#l10.254"></a><span id="l10.254" class="difflineplus">+    0x810db42eUL, 0x3b5cbdb7UL, 0xad6cbac0UL, 0x2083b8edUL, 0xb6b3bf9aUL,</span>
<a href="#l10.255"></a><span id="l10.255" class="difflineplus">+    0x0ce2b603UL, 0x9ad2b174UL, 0x3947d5eaUL, 0xaf77d29dUL, 0x1526db04UL,</span>
<a href="#l10.256"></a><span id="l10.256" class="difflineplus">+    0x8316dc73UL, 0x120b63e3UL, 0x843b6494UL, 0x3e6a6d0dUL, 0xa85a6a7aUL,</span>
<a href="#l10.257"></a><span id="l10.257" class="difflineplus">+    0x0bcf0ee4UL, 0x9dff0993UL, 0x27ae000aUL, 0xb19e077dUL, 0x44930ff0UL,</span>
<a href="#l10.258"></a><span id="l10.258" class="difflineplus">+    0xd2a30887UL, 0x68f2011eUL, 0xfec20669UL, 0x5d5762f7UL, 0xcb676580UL,</span>
<a href="#l10.259"></a><span id="l10.259" class="difflineplus">+    0x71366c19UL, 0xe7066b6eUL, 0x761bd4feUL, 0xe02bd389UL, 0x5a7ada10UL,</span>
<a href="#l10.260"></a><span id="l10.260" class="difflineplus">+    0xcc4add67UL, 0x6fdfb9f9UL, 0xf9efbe8eUL, 0x43beb717UL, 0xd58eb060UL,</span>
<a href="#l10.261"></a><span id="l10.261" class="difflineplus">+    0xe8a3d6d6UL, 0x7e93d1a1UL, 0xc4c2d838UL, 0x52f2df4fUL, 0xf167bbd1UL,</span>
<a href="#l10.262"></a><span id="l10.262" class="difflineplus">+    0x6757bca6UL, 0xdd06b53fUL, 0x4b36b248UL, 0xda2b0dd8UL, 0x4c1b0aafUL,</span>
<a href="#l10.263"></a><span id="l10.263" class="difflineplus">+    0xf64a0336UL, 0x607a0441UL, 0xc3ef60dfUL, 0x55df67a8UL, 0xef8e6e31UL,</span>
<a href="#l10.264"></a><span id="l10.264" class="difflineplus">+    0x79be6946UL, 0x8cb361cbUL, 0x1a8366bcUL, 0xa0d26f25UL, 0x36e26852UL,</span>
<a href="#l10.265"></a><span id="l10.265" class="difflineplus">+    0x95770cccUL, 0x03470bbbUL, 0xb9160222UL, 0x2f260555UL, 0xbe3bbac5UL,</span>
<a href="#l10.266"></a><span id="l10.266" class="difflineplus">+    0x280bbdb2UL, 0x925ab42bUL, 0x046ab35cUL, 0xa7ffd7c2UL, 0x31cfd0b5UL,</span>
<a href="#l10.267"></a><span id="l10.267" class="difflineplus">+    0x8b9ed92cUL, 0x1daede5bUL, 0xb0c2649bUL, 0x26f263ecUL, 0x9ca36a75UL,</span>
<a href="#l10.268"></a><span id="l10.268" class="difflineplus">+    0x0a936d02UL, 0xa906099cUL, 0x3f360eebUL, 0x85670772UL, 0x13570005UL,</span>
<a href="#l10.269"></a><span id="l10.269" class="difflineplus">+    0x824abf95UL, 0x147ab8e2UL, 0xae2bb17bUL, 0x381bb60cUL, 0x9b8ed292UL,</span>
<a href="#l10.270"></a><span id="l10.270" class="difflineplus">+    0x0dbed5e5UL, 0xb7efdc7cUL, 0x21dfdb0bUL, 0xd4d2d386UL, 0x42e2d4f1UL,</span>
<a href="#l10.271"></a><span id="l10.271" class="difflineplus">+    0xf8b3dd68UL, 0x6e83da1fUL, 0xcd16be81UL, 0x5b26b9f6UL, 0xe177b06fUL,</span>
<a href="#l10.272"></a><span id="l10.272" class="difflineplus">+    0x7747b718UL, 0xe65a0888UL, 0x706a0fffUL, 0xca3b0666UL, 0x5c0b0111UL,</span>
<a href="#l10.273"></a><span id="l10.273" class="difflineplus">+    0xff9e658fUL, 0x69ae62f8UL, 0xd3ff6b61UL, 0x45cf6c16UL, 0x78e20aa0UL,</span>
<a href="#l10.274"></a><span id="l10.274" class="difflineplus">+    0xeed20dd7UL, 0x5483044eUL, 0xc2b30339UL, 0x612667a7UL, 0xf71660d0UL,</span>
<a href="#l10.275"></a><span id="l10.275" class="difflineplus">+    0x4d476949UL, 0xdb776e3eUL, 0x4a6ad1aeUL, 0xdc5ad6d9UL, 0x660bdf40UL,</span>
<a href="#l10.276"></a><span id="l10.276" class="difflineplus">+    0xf03bd837UL, 0x53aebca9UL, 0xc59ebbdeUL, 0x7fcfb247UL, 0xe9ffb530UL,</span>
<a href="#l10.277"></a><span id="l10.277" class="difflineplus">+    0x1cf2bdbdUL, 0x8ac2bacaUL, 0x3093b353UL, 0xa6a3b424UL, 0x0536d0baUL,</span>
<a href="#l10.278"></a><span id="l10.278" class="difflineplus">+    0x9306d7cdUL, 0x2957de54UL, 0xbf67d923UL, 0x2e7a66b3UL, 0xb84a61c4UL,</span>
<a href="#l10.279"></a><span id="l10.279" class="difflineplus">+    0x021b685dUL, 0x942b6f2aUL, 0x37be0bb4UL, 0xa18e0cc3UL, 0x1bdf055aUL,</span>
<a href="#l10.280"></a><span id="l10.280" class="difflineplus">+    0x8def022dUL</span>
<a href="#l10.281"></a><span id="l10.281" class="difflineplus">+  },</span>
<a href="#l10.282"></a><span id="l10.282" class="difflineplus">+  {</span>
<a href="#l10.283"></a><span id="l10.283" class="difflineplus">+    0x00000000UL, 0x41311b19UL, 0x82623632UL, 0xc3532d2bUL, 0x04c56c64UL,</span>
<a href="#l10.284"></a><span id="l10.284" class="difflineplus">+    0x45f4777dUL, 0x86a75a56UL, 0xc796414fUL, 0x088ad9c8UL, 0x49bbc2d1UL,</span>
<a href="#l10.285"></a><span id="l10.285" class="difflineplus">+    0x8ae8effaUL, 0xcbd9f4e3UL, 0x0c4fb5acUL, 0x4d7eaeb5UL, 0x8e2d839eUL,</span>
<a href="#l10.286"></a><span id="l10.286" class="difflineplus">+    0xcf1c9887UL, 0x5112c24aUL, 0x1023d953UL, 0xd370f478UL, 0x9241ef61UL,</span>
<a href="#l10.287"></a><span id="l10.287" class="difflineplus">+    0x55d7ae2eUL, 0x14e6b537UL, 0xd7b5981cUL, 0x96848305UL, 0x59981b82UL,</span>
<a href="#l10.288"></a><span id="l10.288" class="difflineplus">+    0x18a9009bUL, 0xdbfa2db0UL, 0x9acb36a9UL, 0x5d5d77e6UL, 0x1c6c6cffUL,</span>
<a href="#l10.289"></a><span id="l10.289" class="difflineplus">+    0xdf3f41d4UL, 0x9e0e5acdUL, 0xa2248495UL, 0xe3159f8cUL, 0x2046b2a7UL,</span>
<a href="#l10.290"></a><span id="l10.290" class="difflineplus">+    0x6177a9beUL, 0xa6e1e8f1UL, 0xe7d0f3e8UL, 0x2483dec3UL, 0x65b2c5daUL,</span>
<a href="#l10.291"></a><span id="l10.291" class="difflineplus">+    0xaaae5d5dUL, 0xeb9f4644UL, 0x28cc6b6fUL, 0x69fd7076UL, 0xae6b3139UL,</span>
<a href="#l10.292"></a><span id="l10.292" class="difflineplus">+    0xef5a2a20UL, 0x2c09070bUL, 0x6d381c12UL, 0xf33646dfUL, 0xb2075dc6UL,</span>
<a href="#l10.293"></a><span id="l10.293" class="difflineplus">+    0x715470edUL, 0x30656bf4UL, 0xf7f32abbUL, 0xb6c231a2UL, 0x75911c89UL,</span>
<a href="#l10.294"></a><span id="l10.294" class="difflineplus">+    0x34a00790UL, 0xfbbc9f17UL, 0xba8d840eUL, 0x79dea925UL, 0x38efb23cUL,</span>
<a href="#l10.295"></a><span id="l10.295" class="difflineplus">+    0xff79f373UL, 0xbe48e86aUL, 0x7d1bc541UL, 0x3c2ade58UL, 0x054f79f0UL,</span>
<a href="#l10.296"></a><span id="l10.296" class="difflineplus">+    0x447e62e9UL, 0x872d4fc2UL, 0xc61c54dbUL, 0x018a1594UL, 0x40bb0e8dUL,</span>
<a href="#l10.297"></a><span id="l10.297" class="difflineplus">+    0x83e823a6UL, 0xc2d938bfUL, 0x0dc5a038UL, 0x4cf4bb21UL, 0x8fa7960aUL,</span>
<a href="#l10.298"></a><span id="l10.298" class="difflineplus">+    0xce968d13UL, 0x0900cc5cUL, 0x4831d745UL, 0x8b62fa6eUL, 0xca53e177UL,</span>
<a href="#l10.299"></a><span id="l10.299" class="difflineplus">+    0x545dbbbaUL, 0x156ca0a3UL, 0xd63f8d88UL, 0x970e9691UL, 0x5098d7deUL,</span>
<a href="#l10.300"></a><span id="l10.300" class="difflineplus">+    0x11a9ccc7UL, 0xd2fae1ecUL, 0x93cbfaf5UL, 0x5cd76272UL, 0x1de6796bUL,</span>
<a href="#l10.301"></a><span id="l10.301" class="difflineplus">+    0xdeb55440UL, 0x9f844f59UL, 0x58120e16UL, 0x1923150fUL, 0xda703824UL,</span>
<a href="#l10.302"></a><span id="l10.302" class="difflineplus">+    0x9b41233dUL, 0xa76bfd65UL, 0xe65ae67cUL, 0x2509cb57UL, 0x6438d04eUL,</span>
<a href="#l10.303"></a><span id="l10.303" class="difflineplus">+    0xa3ae9101UL, 0xe29f8a18UL, 0x21cca733UL, 0x60fdbc2aUL, 0xafe124adUL,</span>
<a href="#l10.304"></a><span id="l10.304" class="difflineplus">+    0xeed03fb4UL, 0x2d83129fUL, 0x6cb20986UL, 0xab2448c9UL, 0xea1553d0UL,</span>
<a href="#l10.305"></a><span id="l10.305" class="difflineplus">+    0x29467efbUL, 0x687765e2UL, 0xf6793f2fUL, 0xb7482436UL, 0x741b091dUL,</span>
<a href="#l10.306"></a><span id="l10.306" class="difflineplus">+    0x352a1204UL, 0xf2bc534bUL, 0xb38d4852UL, 0x70de6579UL, 0x31ef7e60UL,</span>
<a href="#l10.307"></a><span id="l10.307" class="difflineplus">+    0xfef3e6e7UL, 0xbfc2fdfeUL, 0x7c91d0d5UL, 0x3da0cbccUL, 0xfa368a83UL,</span>
<a href="#l10.308"></a><span id="l10.308" class="difflineplus">+    0xbb07919aUL, 0x7854bcb1UL, 0x3965a7a8UL, 0x4b98833bUL, 0x0aa99822UL,</span>
<a href="#l10.309"></a><span id="l10.309" class="difflineplus">+    0xc9fab509UL, 0x88cbae10UL, 0x4f5def5fUL, 0x0e6cf446UL, 0xcd3fd96dUL,</span>
<a href="#l10.310"></a><span id="l10.310" class="difflineplus">+    0x8c0ec274UL, 0x43125af3UL, 0x022341eaUL, 0xc1706cc1UL, 0x804177d8UL,</span>
<a href="#l10.311"></a><span id="l10.311" class="difflineplus">+    0x47d73697UL, 0x06e62d8eUL, 0xc5b500a5UL, 0x84841bbcUL, 0x1a8a4171UL,</span>
<a href="#l10.312"></a><span id="l10.312" class="difflineplus">+    0x5bbb5a68UL, 0x98e87743UL, 0xd9d96c5aUL, 0x1e4f2d15UL, 0x5f7e360cUL,</span>
<a href="#l10.313"></a><span id="l10.313" class="difflineplus">+    0x9c2d1b27UL, 0xdd1c003eUL, 0x120098b9UL, 0x533183a0UL, 0x9062ae8bUL,</span>
<a href="#l10.314"></a><span id="l10.314" class="difflineplus">+    0xd153b592UL, 0x16c5f4ddUL, 0x57f4efc4UL, 0x94a7c2efUL, 0xd596d9f6UL,</span>
<a href="#l10.315"></a><span id="l10.315" class="difflineplus">+    0xe9bc07aeUL, 0xa88d1cb7UL, 0x6bde319cUL, 0x2aef2a85UL, 0xed796bcaUL,</span>
<a href="#l10.316"></a><span id="l10.316" class="difflineplus">+    0xac4870d3UL, 0x6f1b5df8UL, 0x2e2a46e1UL, 0xe136de66UL, 0xa007c57fUL,</span>
<a href="#l10.317"></a><span id="l10.317" class="difflineplus">+    0x6354e854UL, 0x2265f34dUL, 0xe5f3b202UL, 0xa4c2a91bUL, 0x67918430UL,</span>
<a href="#l10.318"></a><span id="l10.318" class="difflineplus">+    0x26a09f29UL, 0xb8aec5e4UL, 0xf99fdefdUL, 0x3accf3d6UL, 0x7bfde8cfUL,</span>
<a href="#l10.319"></a><span id="l10.319" class="difflineplus">+    0xbc6ba980UL, 0xfd5ab299UL, 0x3e099fb2UL, 0x7f3884abUL, 0xb0241c2cUL,</span>
<a href="#l10.320"></a><span id="l10.320" class="difflineplus">+    0xf1150735UL, 0x32462a1eUL, 0x73773107UL, 0xb4e17048UL, 0xf5d06b51UL,</span>
<a href="#l10.321"></a><span id="l10.321" class="difflineplus">+    0x3683467aUL, 0x77b25d63UL, 0x4ed7facbUL, 0x0fe6e1d2UL, 0xccb5ccf9UL,</span>
<a href="#l10.322"></a><span id="l10.322" class="difflineplus">+    0x8d84d7e0UL, 0x4a1296afUL, 0x0b238db6UL, 0xc870a09dUL, 0x8941bb84UL,</span>
<a href="#l10.323"></a><span id="l10.323" class="difflineplus">+    0x465d2303UL, 0x076c381aUL, 0xc43f1531UL, 0x850e0e28UL, 0x42984f67UL,</span>
<a href="#l10.324"></a><span id="l10.324" class="difflineplus">+    0x03a9547eUL, 0xc0fa7955UL, 0x81cb624cUL, 0x1fc53881UL, 0x5ef42398UL,</span>
<a href="#l10.325"></a><span id="l10.325" class="difflineplus">+    0x9da70eb3UL, 0xdc9615aaUL, 0x1b0054e5UL, 0x5a314ffcUL, 0x996262d7UL,</span>
<a href="#l10.326"></a><span id="l10.326" class="difflineplus">+    0xd85379ceUL, 0x174fe149UL, 0x567efa50UL, 0x952dd77bUL, 0xd41ccc62UL,</span>
<a href="#l10.327"></a><span id="l10.327" class="difflineplus">+    0x138a8d2dUL, 0x52bb9634UL, 0x91e8bb1fUL, 0xd0d9a006UL, 0xecf37e5eUL,</span>
<a href="#l10.328"></a><span id="l10.328" class="difflineplus">+    0xadc26547UL, 0x6e91486cUL, 0x2fa05375UL, 0xe836123aUL, 0xa9070923UL,</span>
<a href="#l10.329"></a><span id="l10.329" class="difflineplus">+    0x6a542408UL, 0x2b653f11UL, 0xe479a796UL, 0xa548bc8fUL, 0x661b91a4UL,</span>
<a href="#l10.330"></a><span id="l10.330" class="difflineplus">+    0x272a8abdUL, 0xe0bccbf2UL, 0xa18dd0ebUL, 0x62defdc0UL, 0x23efe6d9UL,</span>
<a href="#l10.331"></a><span id="l10.331" class="difflineplus">+    0xbde1bc14UL, 0xfcd0a70dUL, 0x3f838a26UL, 0x7eb2913fUL, 0xb924d070UL,</span>
<a href="#l10.332"></a><span id="l10.332" class="difflineplus">+    0xf815cb69UL, 0x3b46e642UL, 0x7a77fd5bUL, 0xb56b65dcUL, 0xf45a7ec5UL,</span>
<a href="#l10.333"></a><span id="l10.333" class="difflineplus">+    0x370953eeUL, 0x763848f7UL, 0xb1ae09b8UL, 0xf09f12a1UL, 0x33cc3f8aUL,</span>
<a href="#l10.334"></a><span id="l10.334" class="difflineplus">+    0x72fd2493UL</span>
<a href="#l10.335"></a><span id="l10.335" class="difflineplus">+  },</span>
<a href="#l10.336"></a><span id="l10.336" class="difflineplus">+  {</span>
<a href="#l10.337"></a><span id="l10.337" class="difflineplus">+    0x00000000UL, 0x376ac201UL, 0x6ed48403UL, 0x59be4602UL, 0xdca80907UL,</span>
<a href="#l10.338"></a><span id="l10.338" class="difflineplus">+    0xebc2cb06UL, 0xb27c8d04UL, 0x85164f05UL, 0xb851130eUL, 0x8f3bd10fUL,</span>
<a href="#l10.339"></a><span id="l10.339" class="difflineplus">+    0xd685970dUL, 0xe1ef550cUL, 0x64f91a09UL, 0x5393d808UL, 0x0a2d9e0aUL,</span>
<a href="#l10.340"></a><span id="l10.340" class="difflineplus">+    0x3d475c0bUL, 0x70a3261cUL, 0x47c9e41dUL, 0x1e77a21fUL, 0x291d601eUL,</span>
<a href="#l10.341"></a><span id="l10.341" class="difflineplus">+    0xac0b2f1bUL, 0x9b61ed1aUL, 0xc2dfab18UL, 0xf5b56919UL, 0xc8f23512UL,</span>
<a href="#l10.342"></a><span id="l10.342" class="difflineplus">+    0xff98f713UL, 0xa626b111UL, 0x914c7310UL, 0x145a3c15UL, 0x2330fe14UL,</span>
<a href="#l10.343"></a><span id="l10.343" class="difflineplus">+    0x7a8eb816UL, 0x4de47a17UL, 0xe0464d38UL, 0xd72c8f39UL, 0x8e92c93bUL,</span>
<a href="#l10.344"></a><span id="l10.344" class="difflineplus">+    0xb9f80b3aUL, 0x3cee443fUL, 0x0b84863eUL, 0x523ac03cUL, 0x6550023dUL,</span>
<a href="#l10.345"></a><span id="l10.345" class="difflineplus">+    0x58175e36UL, 0x6f7d9c37UL, 0x36c3da35UL, 0x01a91834UL, 0x84bf5731UL,</span>
<a href="#l10.346"></a><span id="l10.346" class="difflineplus">+    0xb3d59530UL, 0xea6bd332UL, 0xdd011133UL, 0x90e56b24UL, 0xa78fa925UL,</span>
<a href="#l10.347"></a><span id="l10.347" class="difflineplus">+    0xfe31ef27UL, 0xc95b2d26UL, 0x4c4d6223UL, 0x7b27a022UL, 0x2299e620UL,</span>
<a href="#l10.348"></a><span id="l10.348" class="difflineplus">+    0x15f32421UL, 0x28b4782aUL, 0x1fdeba2bUL, 0x4660fc29UL, 0x710a3e28UL,</span>
<a href="#l10.349"></a><span id="l10.349" class="difflineplus">+    0xf41c712dUL, 0xc376b32cUL, 0x9ac8f52eUL, 0xada2372fUL, 0xc08d9a70UL,</span>
<a href="#l10.350"></a><span id="l10.350" class="difflineplus">+    0xf7e75871UL, 0xae591e73UL, 0x9933dc72UL, 0x1c259377UL, 0x2b4f5176UL,</span>
<a href="#l10.351"></a><span id="l10.351" class="difflineplus">+    0x72f11774UL, 0x459bd575UL, 0x78dc897eUL, 0x4fb64b7fUL, 0x16080d7dUL,</span>
<a href="#l10.352"></a><span id="l10.352" class="difflineplus">+    0x2162cf7cUL, 0xa4748079UL, 0x931e4278UL, 0xcaa0047aUL, 0xfdcac67bUL,</span>
<a href="#l10.353"></a><span id="l10.353" class="difflineplus">+    0xb02ebc6cUL, 0x87447e6dUL, 0xdefa386fUL, 0xe990fa6eUL, 0x6c86b56bUL,</span>
<a href="#l10.354"></a><span id="l10.354" class="difflineplus">+    0x5bec776aUL, 0x02523168UL, 0x3538f369UL, 0x087faf62UL, 0x3f156d63UL,</span>
<a href="#l10.355"></a><span id="l10.355" class="difflineplus">+    0x66ab2b61UL, 0x51c1e960UL, 0xd4d7a665UL, 0xe3bd6464UL, 0xba032266UL,</span>
<a href="#l10.356"></a><span id="l10.356" class="difflineplus">+    0x8d69e067UL, 0x20cbd748UL, 0x17a11549UL, 0x4e1f534bUL, 0x7975914aUL,</span>
<a href="#l10.357"></a><span id="l10.357" class="difflineplus">+    0xfc63de4fUL, 0xcb091c4eUL, 0x92b75a4cUL, 0xa5dd984dUL, 0x989ac446UL,</span>
<a href="#l10.358"></a><span id="l10.358" class="difflineplus">+    0xaff00647UL, 0xf64e4045UL, 0xc1248244UL, 0x4432cd41UL, 0x73580f40UL,</span>
<a href="#l10.359"></a><span id="l10.359" class="difflineplus">+    0x2ae64942UL, 0x1d8c8b43UL, 0x5068f154UL, 0x67023355UL, 0x3ebc7557UL,</span>
<a href="#l10.360"></a><span id="l10.360" class="difflineplus">+    0x09d6b756UL, 0x8cc0f853UL, 0xbbaa3a52UL, 0xe2147c50UL, 0xd57ebe51UL,</span>
<a href="#l10.361"></a><span id="l10.361" class="difflineplus">+    0xe839e25aUL, 0xdf53205bUL, 0x86ed6659UL, 0xb187a458UL, 0x3491eb5dUL,</span>
<a href="#l10.362"></a><span id="l10.362" class="difflineplus">+    0x03fb295cUL, 0x5a456f5eUL, 0x6d2fad5fUL, 0x801b35e1UL, 0xb771f7e0UL,</span>
<a href="#l10.363"></a><span id="l10.363" class="difflineplus">+    0xeecfb1e2UL, 0xd9a573e3UL, 0x5cb33ce6UL, 0x6bd9fee7UL, 0x3267b8e5UL,</span>
<a href="#l10.364"></a><span id="l10.364" class="difflineplus">+    0x050d7ae4UL, 0x384a26efUL, 0x0f20e4eeUL, 0x569ea2ecUL, 0x61f460edUL,</span>
<a href="#l10.365"></a><span id="l10.365" class="difflineplus">+    0xe4e22fe8UL, 0xd388ede9UL, 0x8a36abebUL, 0xbd5c69eaUL, 0xf0b813fdUL,</span>
<a href="#l10.366"></a><span id="l10.366" class="difflineplus">+    0xc7d2d1fcUL, 0x9e6c97feUL, 0xa90655ffUL, 0x2c101afaUL, 0x1b7ad8fbUL,</span>
<a href="#l10.367"></a><span id="l10.367" class="difflineplus">+    0x42c49ef9UL, 0x75ae5cf8UL, 0x48e900f3UL, 0x7f83c2f2UL, 0x263d84f0UL,</span>
<a href="#l10.368"></a><span id="l10.368" class="difflineplus">+    0x115746f1UL, 0x944109f4UL, 0xa32bcbf5UL, 0xfa958df7UL, 0xcdff4ff6UL,</span>
<a href="#l10.369"></a><span id="l10.369" class="difflineplus">+    0x605d78d9UL, 0x5737bad8UL, 0x0e89fcdaUL, 0x39e33edbUL, 0xbcf571deUL,</span>
<a href="#l10.370"></a><span id="l10.370" class="difflineplus">+    0x8b9fb3dfUL, 0xd221f5ddUL, 0xe54b37dcUL, 0xd80c6bd7UL, 0xef66a9d6UL,</span>
<a href="#l10.371"></a><span id="l10.371" class="difflineplus">+    0xb6d8efd4UL, 0x81b22dd5UL, 0x04a462d0UL, 0x33cea0d1UL, 0x6a70e6d3UL,</span>
<a href="#l10.372"></a><span id="l10.372" class="difflineplus">+    0x5d1a24d2UL, 0x10fe5ec5UL, 0x27949cc4UL, 0x7e2adac6UL, 0x494018c7UL,</span>
<a href="#l10.373"></a><span id="l10.373" class="difflineplus">+    0xcc5657c2UL, 0xfb3c95c3UL, 0xa282d3c1UL, 0x95e811c0UL, 0xa8af4dcbUL,</span>
<a href="#l10.374"></a><span id="l10.374" class="difflineplus">+    0x9fc58fcaUL, 0xc67bc9c8UL, 0xf1110bc9UL, 0x740744ccUL, 0x436d86cdUL,</span>
<a href="#l10.375"></a><span id="l10.375" class="difflineplus">+    0x1ad3c0cfUL, 0x2db902ceUL, 0x4096af91UL, 0x77fc6d90UL, 0x2e422b92UL,</span>
<a href="#l10.376"></a><span id="l10.376" class="difflineplus">+    0x1928e993UL, 0x9c3ea696UL, 0xab546497UL, 0xf2ea2295UL, 0xc580e094UL,</span>
<a href="#l10.377"></a><span id="l10.377" class="difflineplus">+    0xf8c7bc9fUL, 0xcfad7e9eUL, 0x9613389cUL, 0xa179fa9dUL, 0x246fb598UL,</span>
<a href="#l10.378"></a><span id="l10.378" class="difflineplus">+    0x13057799UL, 0x4abb319bUL, 0x7dd1f39aUL, 0x3035898dUL, 0x075f4b8cUL,</span>
<a href="#l10.379"></a><span id="l10.379" class="difflineplus">+    0x5ee10d8eUL, 0x698bcf8fUL, 0xec9d808aUL, 0xdbf7428bUL, 0x82490489UL,</span>
<a href="#l10.380"></a><span id="l10.380" class="difflineplus">+    0xb523c688UL, 0x88649a83UL, 0xbf0e5882UL, 0xe6b01e80UL, 0xd1dadc81UL,</span>
<a href="#l10.381"></a><span id="l10.381" class="difflineplus">+    0x54cc9384UL, 0x63a65185UL, 0x3a181787UL, 0x0d72d586UL, 0xa0d0e2a9UL,</span>
<a href="#l10.382"></a><span id="l10.382" class="difflineplus">+    0x97ba20a8UL, 0xce0466aaUL, 0xf96ea4abUL, 0x7c78ebaeUL, 0x4b1229afUL,</span>
<a href="#l10.383"></a><span id="l10.383" class="difflineplus">+    0x12ac6fadUL, 0x25c6adacUL, 0x1881f1a7UL, 0x2feb33a6UL, 0x765575a4UL,</span>
<a href="#l10.384"></a><span id="l10.384" class="difflineplus">+    0x413fb7a5UL, 0xc429f8a0UL, 0xf3433aa1UL, 0xaafd7ca3UL, 0x9d97bea2UL,</span>
<a href="#l10.385"></a><span id="l10.385" class="difflineplus">+    0xd073c4b5UL, 0xe71906b4UL, 0xbea740b6UL, 0x89cd82b7UL, 0x0cdbcdb2UL,</span>
<a href="#l10.386"></a><span id="l10.386" class="difflineplus">+    0x3bb10fb3UL, 0x620f49b1UL, 0x55658bb0UL, 0x6822d7bbUL, 0x5f4815baUL,</span>
<a href="#l10.387"></a><span id="l10.387" class="difflineplus">+    0x06f653b8UL, 0x319c91b9UL, 0xb48adebcUL, 0x83e01cbdUL, 0xda5e5abfUL,</span>
<a href="#l10.388"></a><span id="l10.388" class="difflineplus">+    0xed3498beUL</span>
<a href="#l10.389"></a><span id="l10.389" class="difflineplus">+  },</span>
<a href="#l10.390"></a><span id="l10.390" class="difflineplus">+  {</span>
<a href="#l10.391"></a><span id="l10.391" class="difflineplus">+    0x00000000UL, 0x6567bcb8UL, 0x8bc809aaUL, 0xeeafb512UL, 0x5797628fUL,</span>
<a href="#l10.392"></a><span id="l10.392" class="difflineplus">+    0x32f0de37UL, 0xdc5f6b25UL, 0xb938d79dUL, 0xef28b4c5UL, 0x8a4f087dUL,</span>
<a href="#l10.393"></a><span id="l10.393" class="difflineplus">+    0x64e0bd6fUL, 0x018701d7UL, 0xb8bfd64aUL, 0xddd86af2UL, 0x3377dfe0UL,</span>
<a href="#l10.394"></a><span id="l10.394" class="difflineplus">+    0x56106358UL, 0x9f571950UL, 0xfa30a5e8UL, 0x149f10faUL, 0x71f8ac42UL,</span>
<a href="#l10.395"></a><span id="l10.395" class="difflineplus">+    0xc8c07bdfUL, 0xada7c767UL, 0x43087275UL, 0x266fcecdUL, 0x707fad95UL,</span>
<a href="#l10.396"></a><span id="l10.396" class="difflineplus">+    0x1518112dUL, 0xfbb7a43fUL, 0x9ed01887UL, 0x27e8cf1aUL, 0x428f73a2UL,</span>
<a href="#l10.397"></a><span id="l10.397" class="difflineplus">+    0xac20c6b0UL, 0xc9477a08UL, 0x3eaf32a0UL, 0x5bc88e18UL, 0xb5673b0aUL,</span>
<a href="#l10.398"></a><span id="l10.398" class="difflineplus">+    0xd00087b2UL, 0x6938502fUL, 0x0c5fec97UL, 0xe2f05985UL, 0x8797e53dUL,</span>
<a href="#l10.399"></a><span id="l10.399" class="difflineplus">+    0xd1878665UL, 0xb4e03addUL, 0x5a4f8fcfUL, 0x3f283377UL, 0x8610e4eaUL,</span>
<a href="#l10.400"></a><span id="l10.400" class="difflineplus">+    0xe3775852UL, 0x0dd8ed40UL, 0x68bf51f8UL, 0xa1f82bf0UL, 0xc49f9748UL,</span>
<a href="#l10.401"></a><span id="l10.401" class="difflineplus">+    0x2a30225aUL, 0x4f579ee2UL, 0xf66f497fUL, 0x9308f5c7UL, 0x7da740d5UL,</span>
<a href="#l10.402"></a><span id="l10.402" class="difflineplus">+    0x18c0fc6dUL, 0x4ed09f35UL, 0x2bb7238dUL, 0xc518969fUL, 0xa07f2a27UL,</span>
<a href="#l10.403"></a><span id="l10.403" class="difflineplus">+    0x1947fdbaUL, 0x7c204102UL, 0x928ff410UL, 0xf7e848a8UL, 0x3d58149bUL,</span>
<a href="#l10.404"></a><span id="l10.404" class="difflineplus">+    0x583fa823UL, 0xb6901d31UL, 0xd3f7a189UL, 0x6acf7614UL, 0x0fa8caacUL,</span>
<a href="#l10.405"></a><span id="l10.405" class="difflineplus">+    0xe1077fbeUL, 0x8460c306UL, 0xd270a05eUL, 0xb7171ce6UL, 0x59b8a9f4UL,</span>
<a href="#l10.406"></a><span id="l10.406" class="difflineplus">+    0x3cdf154cUL, 0x85e7c2d1UL, 0xe0807e69UL, 0x0e2fcb7bUL, 0x6b4877c3UL,</span>
<a href="#l10.407"></a><span id="l10.407" class="difflineplus">+    0xa20f0dcbUL, 0xc768b173UL, 0x29c70461UL, 0x4ca0b8d9UL, 0xf5986f44UL,</span>
<a href="#l10.408"></a><span id="l10.408" class="difflineplus">+    0x90ffd3fcUL, 0x7e5066eeUL, 0x1b37da56UL, 0x4d27b90eUL, 0x284005b6UL,</span>
<a href="#l10.409"></a><span id="l10.409" class="difflineplus">+    0xc6efb0a4UL, 0xa3880c1cUL, 0x1ab0db81UL, 0x7fd76739UL, 0x9178d22bUL,</span>
<a href="#l10.410"></a><span id="l10.410" class="difflineplus">+    0xf41f6e93UL, 0x03f7263bUL, 0x66909a83UL, 0x883f2f91UL, 0xed589329UL,</span>
<a href="#l10.411"></a><span id="l10.411" class="difflineplus">+    0x546044b4UL, 0x3107f80cUL, 0xdfa84d1eUL, 0xbacff1a6UL, 0xecdf92feUL,</span>
<a href="#l10.412"></a><span id="l10.412" class="difflineplus">+    0x89b82e46UL, 0x67179b54UL, 0x027027ecUL, 0xbb48f071UL, 0xde2f4cc9UL,</span>
<a href="#l10.413"></a><span id="l10.413" class="difflineplus">+    0x3080f9dbUL, 0x55e74563UL, 0x9ca03f6bUL, 0xf9c783d3UL, 0x176836c1UL,</span>
<a href="#l10.414"></a><span id="l10.414" class="difflineplus">+    0x720f8a79UL, 0xcb375de4UL, 0xae50e15cUL, 0x40ff544eUL, 0x2598e8f6UL,</span>
<a href="#l10.415"></a><span id="l10.415" class="difflineplus">+    0x73888baeUL, 0x16ef3716UL, 0xf8408204UL, 0x9d273ebcUL, 0x241fe921UL,</span>
<a href="#l10.416"></a><span id="l10.416" class="difflineplus">+    0x41785599UL, 0xafd7e08bUL, 0xcab05c33UL, 0x3bb659edUL, 0x5ed1e555UL,</span>
<a href="#l10.417"></a><span id="l10.417" class="difflineplus">+    0xb07e5047UL, 0xd519ecffUL, 0x6c213b62UL, 0x094687daUL, 0xe7e932c8UL,</span>
<a href="#l10.418"></a><span id="l10.418" class="difflineplus">+    0x828e8e70UL, 0xd49eed28UL, 0xb1f95190UL, 0x5f56e482UL, 0x3a31583aUL,</span>
<a href="#l10.419"></a><span id="l10.419" class="difflineplus">+    0x83098fa7UL, 0xe66e331fUL, 0x08c1860dUL, 0x6da63ab5UL, 0xa4e140bdUL,</span>
<a href="#l10.420"></a><span id="l10.420" class="difflineplus">+    0xc186fc05UL, 0x2f294917UL, 0x4a4ef5afUL, 0xf3762232UL, 0x96119e8aUL,</span>
<a href="#l10.421"></a><span id="l10.421" class="difflineplus">+    0x78be2b98UL, 0x1dd99720UL, 0x4bc9f478UL, 0x2eae48c0UL, 0xc001fdd2UL,</span>
<a href="#l10.422"></a><span id="l10.422" class="difflineplus">+    0xa566416aUL, 0x1c5e96f7UL, 0x79392a4fUL, 0x97969f5dUL, 0xf2f123e5UL,</span>
<a href="#l10.423"></a><span id="l10.423" class="difflineplus">+    0x05196b4dUL, 0x607ed7f5UL, 0x8ed162e7UL, 0xebb6de5fUL, 0x528e09c2UL,</span>
<a href="#l10.424"></a><span id="l10.424" class="difflineplus">+    0x37e9b57aUL, 0xd9460068UL, 0xbc21bcd0UL, 0xea31df88UL, 0x8f566330UL,</span>
<a href="#l10.425"></a><span id="l10.425" class="difflineplus">+    0x61f9d622UL, 0x049e6a9aUL, 0xbda6bd07UL, 0xd8c101bfUL, 0x366eb4adUL,</span>
<a href="#l10.426"></a><span id="l10.426" class="difflineplus">+    0x53090815UL, 0x9a4e721dUL, 0xff29cea5UL, 0x11867bb7UL, 0x74e1c70fUL,</span>
<a href="#l10.427"></a><span id="l10.427" class="difflineplus">+    0xcdd91092UL, 0xa8beac2aUL, 0x46111938UL, 0x2376a580UL, 0x7566c6d8UL,</span>
<a href="#l10.428"></a><span id="l10.428" class="difflineplus">+    0x10017a60UL, 0xfeaecf72UL, 0x9bc973caUL, 0x22f1a457UL, 0x479618efUL,</span>
<a href="#l10.429"></a><span id="l10.429" class="difflineplus">+    0xa939adfdUL, 0xcc5e1145UL, 0x06ee4d76UL, 0x6389f1ceUL, 0x8d2644dcUL,</span>
<a href="#l10.430"></a><span id="l10.430" class="difflineplus">+    0xe841f864UL, 0x51792ff9UL, 0x341e9341UL, 0xdab12653UL, 0xbfd69aebUL,</span>
<a href="#l10.431"></a><span id="l10.431" class="difflineplus">+    0xe9c6f9b3UL, 0x8ca1450bUL, 0x620ef019UL, 0x07694ca1UL, 0xbe519b3cUL,</span>
<a href="#l10.432"></a><span id="l10.432" class="difflineplus">+    0xdb362784UL, 0x35999296UL, 0x50fe2e2eUL, 0x99b95426UL, 0xfcdee89eUL,</span>
<a href="#l10.433"></a><span id="l10.433" class="difflineplus">+    0x12715d8cUL, 0x7716e134UL, 0xce2e36a9UL, 0xab498a11UL, 0x45e63f03UL,</span>
<a href="#l10.434"></a><span id="l10.434" class="difflineplus">+    0x208183bbUL, 0x7691e0e3UL, 0x13f65c5bUL, 0xfd59e949UL, 0x983e55f1UL,</span>
<a href="#l10.435"></a><span id="l10.435" class="difflineplus">+    0x2106826cUL, 0x44613ed4UL, 0xaace8bc6UL, 0xcfa9377eUL, 0x38417fd6UL,</span>
<a href="#l10.436"></a><span id="l10.436" class="difflineplus">+    0x5d26c36eUL, 0xb389767cUL, 0xd6eecac4UL, 0x6fd61d59UL, 0x0ab1a1e1UL,</span>
<a href="#l10.437"></a><span id="l10.437" class="difflineplus">+    0xe41e14f3UL, 0x8179a84bUL, 0xd769cb13UL, 0xb20e77abUL, 0x5ca1c2b9UL,</span>
<a href="#l10.438"></a><span id="l10.438" class="difflineplus">+    0x39c67e01UL, 0x80fea99cUL, 0xe5991524UL, 0x0b36a036UL, 0x6e511c8eUL,</span>
<a href="#l10.439"></a><span id="l10.439" class="difflineplus">+    0xa7166686UL, 0xc271da3eUL, 0x2cde6f2cUL, 0x49b9d394UL, 0xf0810409UL,</span>
<a href="#l10.440"></a><span id="l10.440" class="difflineplus">+    0x95e6b8b1UL, 0x7b490da3UL, 0x1e2eb11bUL, 0x483ed243UL, 0x2d596efbUL,</span>
<a href="#l10.441"></a><span id="l10.441" class="difflineplus">+    0xc3f6dbe9UL, 0xa6916751UL, 0x1fa9b0ccUL, 0x7ace0c74UL, 0x9461b966UL,</span>
<a href="#l10.442"></a><span id="l10.442" class="difflineplus">+    0xf10605deUL</span>
<a href="#l10.443"></a><span id="l10.443" class="difflineplus">+#endif</span>
<a href="#l10.444"></a><span id="l10.444" class="difflineplus">+  }</span>
<a href="#l10.445"></a><span id="l10.445" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1">new file mode 100644</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineminus">--- /dev/null</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineplus">+++ b/third_party/zlib/deflate.c</span>
<a href="#l11.4"></a><span id="l11.4" class="difflineat">@@ -0,0 +1,2163 @@</span>
<a href="#l11.5"></a><span id="l11.5" class="difflineplus">+/* deflate.c -- compress data using the deflation algorithm</span>
<a href="#l11.6"></a><span id="l11.6" class="difflineplus">+ * Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler</span>
<a href="#l11.7"></a><span id="l11.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l11.8"></a><span id="l11.8" class="difflineplus">+ */</span>
<a href="#l11.9"></a><span id="l11.9" class="difflineplus">+</span>
<a href="#l11.10"></a><span id="l11.10" class="difflineplus">+/*</span>
<a href="#l11.11"></a><span id="l11.11" class="difflineplus">+ *  ALGORITHM</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineplus">+ *</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+ *      The &quot;deflation&quot; process depends on being able to identify portions</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineplus">+ *      of the input text which are identical to earlier input (within a</span>
<a href="#l11.15"></a><span id="l11.15" class="difflineplus">+ *      sliding window trailing behind the input currently being processed).</span>
<a href="#l11.16"></a><span id="l11.16" class="difflineplus">+ *</span>
<a href="#l11.17"></a><span id="l11.17" class="difflineplus">+ *      The most straightforward technique turns out to be the fastest for</span>
<a href="#l11.18"></a><span id="l11.18" class="difflineplus">+ *      most input files: try all possible matches and select the longest.</span>
<a href="#l11.19"></a><span id="l11.19" class="difflineplus">+ *      The key feature of this algorithm is that insertions into the string</span>
<a href="#l11.20"></a><span id="l11.20" class="difflineplus">+ *      dictionary are very simple and thus fast, and deletions are avoided</span>
<a href="#l11.21"></a><span id="l11.21" class="difflineplus">+ *      completely. Insertions are performed at each input character, whereas</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineplus">+ *      string matches are performed only when the previous match ends. So it</span>
<a href="#l11.23"></a><span id="l11.23" class="difflineplus">+ *      is preferable to spend more time in matches to allow very fast string</span>
<a href="#l11.24"></a><span id="l11.24" class="difflineplus">+ *      insertions and avoid deletions. The matching algorithm for small</span>
<a href="#l11.25"></a><span id="l11.25" class="difflineplus">+ *      strings is inspired from that of Rabin &amp; Karp. A brute force approach</span>
<a href="#l11.26"></a><span id="l11.26" class="difflineplus">+ *      is used to find longer strings when a small match has been found.</span>
<a href="#l11.27"></a><span id="l11.27" class="difflineplus">+ *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze</span>
<a href="#l11.28"></a><span id="l11.28" class="difflineplus">+ *      (by Leonid Broukhis).</span>
<a href="#l11.29"></a><span id="l11.29" class="difflineplus">+ *         A previous version of this file used a more sophisticated algorithm</span>
<a href="#l11.30"></a><span id="l11.30" class="difflineplus">+ *      (by Fiala and Greene) which is guaranteed to run in linear amortized</span>
<a href="#l11.31"></a><span id="l11.31" class="difflineplus">+ *      time, but has a larger average cost, uses more memory and is patented.</span>
<a href="#l11.32"></a><span id="l11.32" class="difflineplus">+ *      However the F&amp;G algorithm may be faster for some highly redundant</span>
<a href="#l11.33"></a><span id="l11.33" class="difflineplus">+ *      files if the parameter max_chain_length (described below) is too large.</span>
<a href="#l11.34"></a><span id="l11.34" class="difflineplus">+ *</span>
<a href="#l11.35"></a><span id="l11.35" class="difflineplus">+ *  ACKNOWLEDGEMENTS</span>
<a href="#l11.36"></a><span id="l11.36" class="difflineplus">+ *</span>
<a href="#l11.37"></a><span id="l11.37" class="difflineplus">+ *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and</span>
<a href="#l11.38"></a><span id="l11.38" class="difflineplus">+ *      I found it in 'freeze' written by Leonid Broukhis.</span>
<a href="#l11.39"></a><span id="l11.39" class="difflineplus">+ *      Thanks to many people for bug reports and testing.</span>
<a href="#l11.40"></a><span id="l11.40" class="difflineplus">+ *</span>
<a href="#l11.41"></a><span id="l11.41" class="difflineplus">+ *  REFERENCES</span>
<a href="#l11.42"></a><span id="l11.42" class="difflineplus">+ *</span>
<a href="#l11.43"></a><span id="l11.43" class="difflineplus">+ *      Deutsch, L.P.,&quot;DEFLATE Compressed Data Format Specification&quot;.</span>
<a href="#l11.44"></a><span id="l11.44" class="difflineplus">+ *      Available in http://tools.ietf.org/html/rfc1951</span>
<a href="#l11.45"></a><span id="l11.45" class="difflineplus">+ *</span>
<a href="#l11.46"></a><span id="l11.46" class="difflineplus">+ *      A description of the Rabin and Karp algorithm is given in the book</span>
<a href="#l11.47"></a><span id="l11.47" class="difflineplus">+ *         &quot;Algorithms&quot; by R. Sedgewick, Addison-Wesley, p252.</span>
<a href="#l11.48"></a><span id="l11.48" class="difflineplus">+ *</span>
<a href="#l11.49"></a><span id="l11.49" class="difflineplus">+ *      Fiala,E.R., and Greene,D.H.</span>
<a href="#l11.50"></a><span id="l11.50" class="difflineplus">+ *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595</span>
<a href="#l11.51"></a><span id="l11.51" class="difflineplus">+ *</span>
<a href="#l11.52"></a><span id="l11.52" class="difflineplus">+ */</span>
<a href="#l11.53"></a><span id="l11.53" class="difflineplus">+</span>
<a href="#l11.54"></a><span id="l11.54" class="difflineplus">+/* @(#) $Id$ */</span>
<a href="#l11.55"></a><span id="l11.55" class="difflineplus">+</span>
<a href="#l11.56"></a><span id="l11.56" class="difflineplus">+#include &quot;deflate.h&quot;</span>
<a href="#l11.57"></a><span id="l11.57" class="difflineplus">+</span>
<a href="#l11.58"></a><span id="l11.58" class="difflineplus">+const char deflate_copyright[] =</span>
<a href="#l11.59"></a><span id="l11.59" class="difflineplus">+   &quot; deflate 1.2.11 Copyright 1995-2017 Jean-loup Gailly and Mark Adler &quot;;</span>
<a href="#l11.60"></a><span id="l11.60" class="difflineplus">+/*</span>
<a href="#l11.61"></a><span id="l11.61" class="difflineplus">+  If you use the zlib library in a product, an acknowledgment is welcome</span>
<a href="#l11.62"></a><span id="l11.62" class="difflineplus">+  in the documentation of your product. If for some reason you cannot</span>
<a href="#l11.63"></a><span id="l11.63" class="difflineplus">+  include such an acknowledgment, I would appreciate that you keep this</span>
<a href="#l11.64"></a><span id="l11.64" class="difflineplus">+  copyright string in the executable of your product.</span>
<a href="#l11.65"></a><span id="l11.65" class="difflineplus">+ */</span>
<a href="#l11.66"></a><span id="l11.66" class="difflineplus">+</span>
<a href="#l11.67"></a><span id="l11.67" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.68"></a><span id="l11.68" class="difflineplus">+ *  Function prototypes.</span>
<a href="#l11.69"></a><span id="l11.69" class="difflineplus">+ */</span>
<a href="#l11.70"></a><span id="l11.70" class="difflineplus">+typedef enum {</span>
<a href="#l11.71"></a><span id="l11.71" class="difflineplus">+    need_more,      /* block not completed, need more input or more output */</span>
<a href="#l11.72"></a><span id="l11.72" class="difflineplus">+    block_done,     /* block flush performed */</span>
<a href="#l11.73"></a><span id="l11.73" class="difflineplus">+    finish_started, /* finish started, need only more output at next deflate */</span>
<a href="#l11.74"></a><span id="l11.74" class="difflineplus">+    finish_done     /* finish done, accept no more input or output */</span>
<a href="#l11.75"></a><span id="l11.75" class="difflineplus">+} block_state;</span>
<a href="#l11.76"></a><span id="l11.76" class="difflineplus">+</span>
<a href="#l11.77"></a><span id="l11.77" class="difflineplus">+typedef block_state (*compress_func) OF((deflate_state *s, int flush));</span>
<a href="#l11.78"></a><span id="l11.78" class="difflineplus">+/* Compression function. Returns the block state after the call. */</span>
<a href="#l11.79"></a><span id="l11.79" class="difflineplus">+</span>
<a href="#l11.80"></a><span id="l11.80" class="difflineplus">+local int deflateStateCheck      OF((z_streamp strm));</span>
<a href="#l11.81"></a><span id="l11.81" class="difflineplus">+local void slide_hash     OF((deflate_state *s));</span>
<a href="#l11.82"></a><span id="l11.82" class="difflineplus">+local void fill_window    OF((deflate_state *s));</span>
<a href="#l11.83"></a><span id="l11.83" class="difflineplus">+local block_state deflate_stored OF((deflate_state *s, int flush));</span>
<a href="#l11.84"></a><span id="l11.84" class="difflineplus">+local block_state deflate_fast   OF((deflate_state *s, int flush));</span>
<a href="#l11.85"></a><span id="l11.85" class="difflineplus">+#ifndef FASTEST</span>
<a href="#l11.86"></a><span id="l11.86" class="difflineplus">+local block_state deflate_slow   OF((deflate_state *s, int flush));</span>
<a href="#l11.87"></a><span id="l11.87" class="difflineplus">+#endif</span>
<a href="#l11.88"></a><span id="l11.88" class="difflineplus">+local block_state deflate_rle    OF((deflate_state *s, int flush));</span>
<a href="#l11.89"></a><span id="l11.89" class="difflineplus">+local block_state deflate_huff   OF((deflate_state *s, int flush));</span>
<a href="#l11.90"></a><span id="l11.90" class="difflineplus">+local void lm_init        OF((deflate_state *s));</span>
<a href="#l11.91"></a><span id="l11.91" class="difflineplus">+local void putShortMSB    OF((deflate_state *s, uInt b));</span>
<a href="#l11.92"></a><span id="l11.92" class="difflineplus">+local void flush_pending  OF((z_streamp strm));</span>
<a href="#l11.93"></a><span id="l11.93" class="difflineplus">+local unsigned read_buf   OF((z_streamp strm, Bytef *buf, unsigned size));</span>
<a href="#l11.94"></a><span id="l11.94" class="difflineplus">+#ifdef ASMV</span>
<a href="#l11.95"></a><span id="l11.95" class="difflineplus">+#  pragma message(&quot;Assembler code may have bugs -- use at your own risk&quot;)</span>
<a href="#l11.96"></a><span id="l11.96" class="difflineplus">+      void match_init OF((void)); /* asm code initialization */</span>
<a href="#l11.97"></a><span id="l11.97" class="difflineplus">+      uInt longest_match  OF((deflate_state *s, IPos cur_match));</span>
<a href="#l11.98"></a><span id="l11.98" class="difflineplus">+#else</span>
<a href="#l11.99"></a><span id="l11.99" class="difflineplus">+local uInt longest_match  OF((deflate_state *s, IPos cur_match));</span>
<a href="#l11.100"></a><span id="l11.100" class="difflineplus">+#endif</span>
<a href="#l11.101"></a><span id="l11.101" class="difflineplus">+</span>
<a href="#l11.102"></a><span id="l11.102" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l11.103"></a><span id="l11.103" class="difflineplus">+local  void check_match OF((deflate_state *s, IPos start, IPos match,</span>
<a href="#l11.104"></a><span id="l11.104" class="difflineplus">+                            int length));</span>
<a href="#l11.105"></a><span id="l11.105" class="difflineplus">+#endif</span>
<a href="#l11.106"></a><span id="l11.106" class="difflineplus">+</span>
<a href="#l11.107"></a><span id="l11.107" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.108"></a><span id="l11.108" class="difflineplus">+ * Local data</span>
<a href="#l11.109"></a><span id="l11.109" class="difflineplus">+ */</span>
<a href="#l11.110"></a><span id="l11.110" class="difflineplus">+</span>
<a href="#l11.111"></a><span id="l11.111" class="difflineplus">+#define NIL 0</span>
<a href="#l11.112"></a><span id="l11.112" class="difflineplus">+/* Tail of hash chains */</span>
<a href="#l11.113"></a><span id="l11.113" class="difflineplus">+</span>
<a href="#l11.114"></a><span id="l11.114" class="difflineplus">+#ifndef TOO_FAR</span>
<a href="#l11.115"></a><span id="l11.115" class="difflineplus">+#  define TOO_FAR 4096</span>
<a href="#l11.116"></a><span id="l11.116" class="difflineplus">+#endif</span>
<a href="#l11.117"></a><span id="l11.117" class="difflineplus">+/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */</span>
<a href="#l11.118"></a><span id="l11.118" class="difflineplus">+</span>
<a href="#l11.119"></a><span id="l11.119" class="difflineplus">+/* Values for max_lazy_match, good_match and max_chain_length, depending on</span>
<a href="#l11.120"></a><span id="l11.120" class="difflineplus">+ * the desired pack level (0..9). The values given below have been tuned to</span>
<a href="#l11.121"></a><span id="l11.121" class="difflineplus">+ * exclude worst case performance for pathological files. Better values may be</span>
<a href="#l11.122"></a><span id="l11.122" class="difflineplus">+ * found for specific files.</span>
<a href="#l11.123"></a><span id="l11.123" class="difflineplus">+ */</span>
<a href="#l11.124"></a><span id="l11.124" class="difflineplus">+typedef struct config_s {</span>
<a href="#l11.125"></a><span id="l11.125" class="difflineplus">+   ush good_length; /* reduce lazy search above this match length */</span>
<a href="#l11.126"></a><span id="l11.126" class="difflineplus">+   ush max_lazy;    /* do not perform lazy search above this match length */</span>
<a href="#l11.127"></a><span id="l11.127" class="difflineplus">+   ush nice_length; /* quit search above this match length */</span>
<a href="#l11.128"></a><span id="l11.128" class="difflineplus">+   ush max_chain;</span>
<a href="#l11.129"></a><span id="l11.129" class="difflineplus">+   compress_func func;</span>
<a href="#l11.130"></a><span id="l11.130" class="difflineplus">+} config;</span>
<a href="#l11.131"></a><span id="l11.131" class="difflineplus">+</span>
<a href="#l11.132"></a><span id="l11.132" class="difflineplus">+#ifdef FASTEST</span>
<a href="#l11.133"></a><span id="l11.133" class="difflineplus">+local const config configuration_table[2] = {</span>
<a href="#l11.134"></a><span id="l11.134" class="difflineplus">+/*      good lazy nice chain */</span>
<a href="#l11.135"></a><span id="l11.135" class="difflineplus">+/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */</span>
<a href="#l11.136"></a><span id="l11.136" class="difflineplus">+/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */</span>
<a href="#l11.137"></a><span id="l11.137" class="difflineplus">+#else</span>
<a href="#l11.138"></a><span id="l11.138" class="difflineplus">+local const config configuration_table[10] = {</span>
<a href="#l11.139"></a><span id="l11.139" class="difflineplus">+/*      good lazy nice chain */</span>
<a href="#l11.140"></a><span id="l11.140" class="difflineplus">+/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */</span>
<a href="#l11.141"></a><span id="l11.141" class="difflineplus">+/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */</span>
<a href="#l11.142"></a><span id="l11.142" class="difflineplus">+/* 2 */ {4,    5, 16,    8, deflate_fast},</span>
<a href="#l11.143"></a><span id="l11.143" class="difflineplus">+/* 3 */ {4,    6, 32,   32, deflate_fast},</span>
<a href="#l11.144"></a><span id="l11.144" class="difflineplus">+</span>
<a href="#l11.145"></a><span id="l11.145" class="difflineplus">+/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */</span>
<a href="#l11.146"></a><span id="l11.146" class="difflineplus">+/* 5 */ {8,   16, 32,   32, deflate_slow},</span>
<a href="#l11.147"></a><span id="l11.147" class="difflineplus">+/* 6 */ {8,   16, 128, 128, deflate_slow},</span>
<a href="#l11.148"></a><span id="l11.148" class="difflineplus">+/* 7 */ {8,   32, 128, 256, deflate_slow},</span>
<a href="#l11.149"></a><span id="l11.149" class="difflineplus">+/* 8 */ {32, 128, 258, 1024, deflate_slow},</span>
<a href="#l11.150"></a><span id="l11.150" class="difflineplus">+/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */</span>
<a href="#l11.151"></a><span id="l11.151" class="difflineplus">+#endif</span>
<a href="#l11.152"></a><span id="l11.152" class="difflineplus">+</span>
<a href="#l11.153"></a><span id="l11.153" class="difflineplus">+/* Note: the deflate() code requires max_lazy &gt;= MIN_MATCH and max_chain &gt;= 4</span>
<a href="#l11.154"></a><span id="l11.154" class="difflineplus">+ * For deflate_fast() (levels &lt;= 3) good is ignored and lazy has a different</span>
<a href="#l11.155"></a><span id="l11.155" class="difflineplus">+ * meaning.</span>
<a href="#l11.156"></a><span id="l11.156" class="difflineplus">+ */</span>
<a href="#l11.157"></a><span id="l11.157" class="difflineplus">+</span>
<a href="#l11.158"></a><span id="l11.158" class="difflineplus">+/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */</span>
<a href="#l11.159"></a><span id="l11.159" class="difflineplus">+#define RANK(f) (((f) * 2) - ((f) &gt; 4 ? 9 : 0))</span>
<a href="#l11.160"></a><span id="l11.160" class="difflineplus">+</span>
<a href="#l11.161"></a><span id="l11.161" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.162"></a><span id="l11.162" class="difflineplus">+ * Update a hash value with the given input byte</span>
<a href="#l11.163"></a><span id="l11.163" class="difflineplus">+ * IN  assertion: all calls to UPDATE_HASH are made with consecutive input</span>
<a href="#l11.164"></a><span id="l11.164" class="difflineplus">+ *    characters, so that a running hash key can be computed from the previous</span>
<a href="#l11.165"></a><span id="l11.165" class="difflineplus">+ *    key instead of complete recalculation each time.</span>
<a href="#l11.166"></a><span id="l11.166" class="difflineplus">+ */</span>
<a href="#l11.167"></a><span id="l11.167" class="difflineplus">+#define UPDATE_HASH(s,h,c) (h = (((h)&lt;&lt;s-&gt;hash_shift) ^ (c)) &amp; s-&gt;hash_mask)</span>
<a href="#l11.168"></a><span id="l11.168" class="difflineplus">+</span>
<a href="#l11.169"></a><span id="l11.169" class="difflineplus">+</span>
<a href="#l11.170"></a><span id="l11.170" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.171"></a><span id="l11.171" class="difflineplus">+ * Insert string str in the dictionary and set match_head to the previous head</span>
<a href="#l11.172"></a><span id="l11.172" class="difflineplus">+ * of the hash chain (the most recent string with same hash key). Return</span>
<a href="#l11.173"></a><span id="l11.173" class="difflineplus">+ * the previous length of the hash chain.</span>
<a href="#l11.174"></a><span id="l11.174" class="difflineplus">+ * If this file is compiled with -DFASTEST, the compression level is forced</span>
<a href="#l11.175"></a><span id="l11.175" class="difflineplus">+ * to 1, and no hash chains are maintained.</span>
<a href="#l11.176"></a><span id="l11.176" class="difflineplus">+ * IN  assertion: all calls to INSERT_STRING are made with consecutive input</span>
<a href="#l11.177"></a><span id="l11.177" class="difflineplus">+ *    characters and the first MIN_MATCH bytes of str are valid (except for</span>
<a href="#l11.178"></a><span id="l11.178" class="difflineplus">+ *    the last MIN_MATCH-1 bytes of the input file).</span>
<a href="#l11.179"></a><span id="l11.179" class="difflineplus">+ */</span>
<a href="#l11.180"></a><span id="l11.180" class="difflineplus">+#ifdef FASTEST</span>
<a href="#l11.181"></a><span id="l11.181" class="difflineplus">+#define INSERT_STRING(s, str, match_head) \</span>
<a href="#l11.182"></a><span id="l11.182" class="difflineplus">+   (UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), \</span>
<a href="#l11.183"></a><span id="l11.183" class="difflineplus">+    match_head = s-&gt;head[s-&gt;ins_h], \</span>
<a href="#l11.184"></a><span id="l11.184" class="difflineplus">+    s-&gt;head[s-&gt;ins_h] = (Pos)(str))</span>
<a href="#l11.185"></a><span id="l11.185" class="difflineplus">+#else</span>
<a href="#l11.186"></a><span id="l11.186" class="difflineplus">+#define INSERT_STRING(s, str, match_head) \</span>
<a href="#l11.187"></a><span id="l11.187" class="difflineplus">+   (UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), \</span>
<a href="#l11.188"></a><span id="l11.188" class="difflineplus">+    match_head = s-&gt;prev[(str) &amp; s-&gt;w_mask] = s-&gt;head[s-&gt;ins_h], \</span>
<a href="#l11.189"></a><span id="l11.189" class="difflineplus">+    s-&gt;head[s-&gt;ins_h] = (Pos)(str))</span>
<a href="#l11.190"></a><span id="l11.190" class="difflineplus">+#endif</span>
<a href="#l11.191"></a><span id="l11.191" class="difflineplus">+</span>
<a href="#l11.192"></a><span id="l11.192" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.193"></a><span id="l11.193" class="difflineplus">+ * Initialize the hash table (avoiding 64K overflow for 16 bit systems).</span>
<a href="#l11.194"></a><span id="l11.194" class="difflineplus">+ * prev[] will be initialized on the fly.</span>
<a href="#l11.195"></a><span id="l11.195" class="difflineplus">+ */</span>
<a href="#l11.196"></a><span id="l11.196" class="difflineplus">+#define CLEAR_HASH(s) \</span>
<a href="#l11.197"></a><span id="l11.197" class="difflineplus">+    s-&gt;head[s-&gt;hash_size-1] = NIL; \</span>
<a href="#l11.198"></a><span id="l11.198" class="difflineplus">+    zmemzero((Bytef *)s-&gt;head, (unsigned)(s-&gt;hash_size-1)*sizeof(*s-&gt;head));</span>
<a href="#l11.199"></a><span id="l11.199" class="difflineplus">+</span>
<a href="#l11.200"></a><span id="l11.200" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.201"></a><span id="l11.201" class="difflineplus">+ * Slide the hash table when sliding the window down (could be avoided with 32</span>
<a href="#l11.202"></a><span id="l11.202" class="difflineplus">+ * bit values at the expense of memory usage). We slide even when level == 0 to</span>
<a href="#l11.203"></a><span id="l11.203" class="difflineplus">+ * keep the hash table consistent if we switch back to level &gt; 0 later.</span>
<a href="#l11.204"></a><span id="l11.204" class="difflineplus">+ */</span>
<a href="#l11.205"></a><span id="l11.205" class="difflineplus">+local void slide_hash(s)</span>
<a href="#l11.206"></a><span id="l11.206" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.207"></a><span id="l11.207" class="difflineplus">+{</span>
<a href="#l11.208"></a><span id="l11.208" class="difflineplus">+    unsigned n, m;</span>
<a href="#l11.209"></a><span id="l11.209" class="difflineplus">+    Posf *p;</span>
<a href="#l11.210"></a><span id="l11.210" class="difflineplus">+    uInt wsize = s-&gt;w_size;</span>
<a href="#l11.211"></a><span id="l11.211" class="difflineplus">+</span>
<a href="#l11.212"></a><span id="l11.212" class="difflineplus">+    n = s-&gt;hash_size;</span>
<a href="#l11.213"></a><span id="l11.213" class="difflineplus">+    p = &amp;s-&gt;head[n];</span>
<a href="#l11.214"></a><span id="l11.214" class="difflineplus">+    do {</span>
<a href="#l11.215"></a><span id="l11.215" class="difflineplus">+        m = *--p;</span>
<a href="#l11.216"></a><span id="l11.216" class="difflineplus">+        *p = (Pos)(m &gt;= wsize ? m - wsize : NIL);</span>
<a href="#l11.217"></a><span id="l11.217" class="difflineplus">+    } while (--n);</span>
<a href="#l11.218"></a><span id="l11.218" class="difflineplus">+    n = wsize;</span>
<a href="#l11.219"></a><span id="l11.219" class="difflineplus">+#ifndef FASTEST</span>
<a href="#l11.220"></a><span id="l11.220" class="difflineplus">+    p = &amp;s-&gt;prev[n];</span>
<a href="#l11.221"></a><span id="l11.221" class="difflineplus">+    do {</span>
<a href="#l11.222"></a><span id="l11.222" class="difflineplus">+        m = *--p;</span>
<a href="#l11.223"></a><span id="l11.223" class="difflineplus">+        *p = (Pos)(m &gt;= wsize ? m - wsize : NIL);</span>
<a href="#l11.224"></a><span id="l11.224" class="difflineplus">+        /* If n is not on any hash chain, prev[n] is garbage but</span>
<a href="#l11.225"></a><span id="l11.225" class="difflineplus">+         * its value will never be used.</span>
<a href="#l11.226"></a><span id="l11.226" class="difflineplus">+         */</span>
<a href="#l11.227"></a><span id="l11.227" class="difflineplus">+    } while (--n);</span>
<a href="#l11.228"></a><span id="l11.228" class="difflineplus">+#endif</span>
<a href="#l11.229"></a><span id="l11.229" class="difflineplus">+}</span>
<a href="#l11.230"></a><span id="l11.230" class="difflineplus">+</span>
<a href="#l11.231"></a><span id="l11.231" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l11.232"></a><span id="l11.232" class="difflineplus">+int ZEXPORT deflateInit_(strm, level, version, stream_size)</span>
<a href="#l11.233"></a><span id="l11.233" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.234"></a><span id="l11.234" class="difflineplus">+    int level;</span>
<a href="#l11.235"></a><span id="l11.235" class="difflineplus">+    const char *version;</span>
<a href="#l11.236"></a><span id="l11.236" class="difflineplus">+    int stream_size;</span>
<a href="#l11.237"></a><span id="l11.237" class="difflineplus">+{</span>
<a href="#l11.238"></a><span id="l11.238" class="difflineplus">+    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,</span>
<a href="#l11.239"></a><span id="l11.239" class="difflineplus">+                         Z_DEFAULT_STRATEGY, version, stream_size);</span>
<a href="#l11.240"></a><span id="l11.240" class="difflineplus">+    /* To do: ignore strm-&gt;next_in if we use it as window */</span>
<a href="#l11.241"></a><span id="l11.241" class="difflineplus">+}</span>
<a href="#l11.242"></a><span id="l11.242" class="difflineplus">+</span>
<a href="#l11.243"></a><span id="l11.243" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l11.244"></a><span id="l11.244" class="difflineplus">+int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,</span>
<a href="#l11.245"></a><span id="l11.245" class="difflineplus">+                  version, stream_size)</span>
<a href="#l11.246"></a><span id="l11.246" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.247"></a><span id="l11.247" class="difflineplus">+    int  level;</span>
<a href="#l11.248"></a><span id="l11.248" class="difflineplus">+    int  method;</span>
<a href="#l11.249"></a><span id="l11.249" class="difflineplus">+    int  windowBits;</span>
<a href="#l11.250"></a><span id="l11.250" class="difflineplus">+    int  memLevel;</span>
<a href="#l11.251"></a><span id="l11.251" class="difflineplus">+    int  strategy;</span>
<a href="#l11.252"></a><span id="l11.252" class="difflineplus">+    const char *version;</span>
<a href="#l11.253"></a><span id="l11.253" class="difflineplus">+    int stream_size;</span>
<a href="#l11.254"></a><span id="l11.254" class="difflineplus">+{</span>
<a href="#l11.255"></a><span id="l11.255" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.256"></a><span id="l11.256" class="difflineplus">+    int wrap = 1;</span>
<a href="#l11.257"></a><span id="l11.257" class="difflineplus">+    static const char my_version[] = ZLIB_VERSION;</span>
<a href="#l11.258"></a><span id="l11.258" class="difflineplus">+</span>
<a href="#l11.259"></a><span id="l11.259" class="difflineplus">+    ushf *overlay;</span>
<a href="#l11.260"></a><span id="l11.260" class="difflineplus">+    /* We overlay pending_buf and d_buf+l_buf. This works since the average</span>
<a href="#l11.261"></a><span id="l11.261" class="difflineplus">+     * output size for (length,distance) codes is &lt;= 24 bits.</span>
<a href="#l11.262"></a><span id="l11.262" class="difflineplus">+     */</span>
<a href="#l11.263"></a><span id="l11.263" class="difflineplus">+</span>
<a href="#l11.264"></a><span id="l11.264" class="difflineplus">+    if (version == Z_NULL || version[0] != my_version[0] ||</span>
<a href="#l11.265"></a><span id="l11.265" class="difflineplus">+        stream_size != sizeof(z_stream)) {</span>
<a href="#l11.266"></a><span id="l11.266" class="difflineplus">+        return Z_VERSION_ERROR;</span>
<a href="#l11.267"></a><span id="l11.267" class="difflineplus">+    }</span>
<a href="#l11.268"></a><span id="l11.268" class="difflineplus">+    if (strm == Z_NULL) return Z_STREAM_ERROR;</span>
<a href="#l11.269"></a><span id="l11.269" class="difflineplus">+</span>
<a href="#l11.270"></a><span id="l11.270" class="difflineplus">+    strm-&gt;msg = Z_NULL;</span>
<a href="#l11.271"></a><span id="l11.271" class="difflineplus">+    if (strm-&gt;zalloc == (alloc_func)0) {</span>
<a href="#l11.272"></a><span id="l11.272" class="difflineplus">+#ifdef Z_SOLO</span>
<a href="#l11.273"></a><span id="l11.273" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l11.274"></a><span id="l11.274" class="difflineplus">+#else</span>
<a href="#l11.275"></a><span id="l11.275" class="difflineplus">+        strm-&gt;zalloc = zcalloc;</span>
<a href="#l11.276"></a><span id="l11.276" class="difflineplus">+        strm-&gt;opaque = (voidpf)0;</span>
<a href="#l11.277"></a><span id="l11.277" class="difflineplus">+#endif</span>
<a href="#l11.278"></a><span id="l11.278" class="difflineplus">+    }</span>
<a href="#l11.279"></a><span id="l11.279" class="difflineplus">+    if (strm-&gt;zfree == (free_func)0)</span>
<a href="#l11.280"></a><span id="l11.280" class="difflineplus">+#ifdef Z_SOLO</span>
<a href="#l11.281"></a><span id="l11.281" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l11.282"></a><span id="l11.282" class="difflineplus">+#else</span>
<a href="#l11.283"></a><span id="l11.283" class="difflineplus">+        strm-&gt;zfree = zcfree;</span>
<a href="#l11.284"></a><span id="l11.284" class="difflineplus">+#endif</span>
<a href="#l11.285"></a><span id="l11.285" class="difflineplus">+</span>
<a href="#l11.286"></a><span id="l11.286" class="difflineplus">+#ifdef FASTEST</span>
<a href="#l11.287"></a><span id="l11.287" class="difflineplus">+    if (level != 0) level = 1;</span>
<a href="#l11.288"></a><span id="l11.288" class="difflineplus">+#else</span>
<a href="#l11.289"></a><span id="l11.289" class="difflineplus">+    if (level == Z_DEFAULT_COMPRESSION) level = 6;</span>
<a href="#l11.290"></a><span id="l11.290" class="difflineplus">+#endif</span>
<a href="#l11.291"></a><span id="l11.291" class="difflineplus">+</span>
<a href="#l11.292"></a><span id="l11.292" class="difflineplus">+    if (windowBits &lt; 0) { /* suppress zlib wrapper */</span>
<a href="#l11.293"></a><span id="l11.293" class="difflineplus">+        wrap = 0;</span>
<a href="#l11.294"></a><span id="l11.294" class="difflineplus">+        windowBits = -windowBits;</span>
<a href="#l11.295"></a><span id="l11.295" class="difflineplus">+    }</span>
<a href="#l11.296"></a><span id="l11.296" class="difflineplus">+#ifdef GZIP</span>
<a href="#l11.297"></a><span id="l11.297" class="difflineplus">+    else if (windowBits &gt; 15) {</span>
<a href="#l11.298"></a><span id="l11.298" class="difflineplus">+        wrap = 2;       /* write gzip wrapper instead */</span>
<a href="#l11.299"></a><span id="l11.299" class="difflineplus">+        windowBits -= 16;</span>
<a href="#l11.300"></a><span id="l11.300" class="difflineplus">+    }</span>
<a href="#l11.301"></a><span id="l11.301" class="difflineplus">+#endif</span>
<a href="#l11.302"></a><span id="l11.302" class="difflineplus">+    if (memLevel &lt; 1 || memLevel &gt; MAX_MEM_LEVEL || method != Z_DEFLATED ||</span>
<a href="#l11.303"></a><span id="l11.303" class="difflineplus">+        windowBits &lt; 8 || windowBits &gt; 15 || level &lt; 0 || level &gt; 9 ||</span>
<a href="#l11.304"></a><span id="l11.304" class="difflineplus">+        strategy &lt; 0 || strategy &gt; Z_FIXED || (windowBits == 8 &amp;&amp; wrap != 1)) {</span>
<a href="#l11.305"></a><span id="l11.305" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l11.306"></a><span id="l11.306" class="difflineplus">+    }</span>
<a href="#l11.307"></a><span id="l11.307" class="difflineplus">+    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */</span>
<a href="#l11.308"></a><span id="l11.308" class="difflineplus">+    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));</span>
<a href="#l11.309"></a><span id="l11.309" class="difflineplus">+    if (s == Z_NULL) return Z_MEM_ERROR;</span>
<a href="#l11.310"></a><span id="l11.310" class="difflineplus">+    strm-&gt;state = (struct internal_state FAR *)s;</span>
<a href="#l11.311"></a><span id="l11.311" class="difflineplus">+    s-&gt;strm = strm;</span>
<a href="#l11.312"></a><span id="l11.312" class="difflineplus">+    s-&gt;status = INIT_STATE;     /* to pass state test in deflateReset() */</span>
<a href="#l11.313"></a><span id="l11.313" class="difflineplus">+</span>
<a href="#l11.314"></a><span id="l11.314" class="difflineplus">+    s-&gt;wrap = wrap;</span>
<a href="#l11.315"></a><span id="l11.315" class="difflineplus">+    s-&gt;gzhead = Z_NULL;</span>
<a href="#l11.316"></a><span id="l11.316" class="difflineplus">+    s-&gt;w_bits = (uInt)windowBits;</span>
<a href="#l11.317"></a><span id="l11.317" class="difflineplus">+    s-&gt;w_size = 1 &lt;&lt; s-&gt;w_bits;</span>
<a href="#l11.318"></a><span id="l11.318" class="difflineplus">+    s-&gt;w_mask = s-&gt;w_size - 1;</span>
<a href="#l11.319"></a><span id="l11.319" class="difflineplus">+</span>
<a href="#l11.320"></a><span id="l11.320" class="difflineplus">+    s-&gt;hash_bits = (uInt)memLevel + 7;</span>
<a href="#l11.321"></a><span id="l11.321" class="difflineplus">+    s-&gt;hash_size = 1 &lt;&lt; s-&gt;hash_bits;</span>
<a href="#l11.322"></a><span id="l11.322" class="difflineplus">+    s-&gt;hash_mask = s-&gt;hash_size - 1;</span>
<a href="#l11.323"></a><span id="l11.323" class="difflineplus">+    s-&gt;hash_shift =  ((s-&gt;hash_bits+MIN_MATCH-1)/MIN_MATCH);</span>
<a href="#l11.324"></a><span id="l11.324" class="difflineplus">+</span>
<a href="#l11.325"></a><span id="l11.325" class="difflineplus">+    s-&gt;window = (Bytef *) ZALLOC(strm, s-&gt;w_size, 2*sizeof(Byte));</span>
<a href="#l11.326"></a><span id="l11.326" class="difflineplus">+    s-&gt;prev   = (Posf *)  ZALLOC(strm, s-&gt;w_size, sizeof(Pos));</span>
<a href="#l11.327"></a><span id="l11.327" class="difflineplus">+    s-&gt;head   = (Posf *)  ZALLOC(strm, s-&gt;hash_size, sizeof(Pos));</span>
<a href="#l11.328"></a><span id="l11.328" class="difflineplus">+</span>
<a href="#l11.329"></a><span id="l11.329" class="difflineplus">+    s-&gt;high_water = 0;      /* nothing written to s-&gt;window yet */</span>
<a href="#l11.330"></a><span id="l11.330" class="difflineplus">+</span>
<a href="#l11.331"></a><span id="l11.331" class="difflineplus">+    s-&gt;lit_bufsize = 1 &lt;&lt; (memLevel + 6); /* 16K elements by default */</span>
<a href="#l11.332"></a><span id="l11.332" class="difflineplus">+</span>
<a href="#l11.333"></a><span id="l11.333" class="difflineplus">+    overlay = (ushf *) ZALLOC(strm, s-&gt;lit_bufsize, sizeof(ush)+2);</span>
<a href="#l11.334"></a><span id="l11.334" class="difflineplus">+    s-&gt;pending_buf = (uchf *) overlay;</span>
<a href="#l11.335"></a><span id="l11.335" class="difflineplus">+    s-&gt;pending_buf_size = (ulg)s-&gt;lit_bufsize * (sizeof(ush)+2L);</span>
<a href="#l11.336"></a><span id="l11.336" class="difflineplus">+</span>
<a href="#l11.337"></a><span id="l11.337" class="difflineplus">+    if (s-&gt;window == Z_NULL || s-&gt;prev == Z_NULL || s-&gt;head == Z_NULL ||</span>
<a href="#l11.338"></a><span id="l11.338" class="difflineplus">+        s-&gt;pending_buf == Z_NULL) {</span>
<a href="#l11.339"></a><span id="l11.339" class="difflineplus">+        s-&gt;status = FINISH_STATE;</span>
<a href="#l11.340"></a><span id="l11.340" class="difflineplus">+        strm-&gt;msg = ERR_MSG(Z_MEM_ERROR);</span>
<a href="#l11.341"></a><span id="l11.341" class="difflineplus">+        deflateEnd (strm);</span>
<a href="#l11.342"></a><span id="l11.342" class="difflineplus">+        return Z_MEM_ERROR;</span>
<a href="#l11.343"></a><span id="l11.343" class="difflineplus">+    }</span>
<a href="#l11.344"></a><span id="l11.344" class="difflineplus">+    s-&gt;d_buf = overlay + s-&gt;lit_bufsize/sizeof(ush);</span>
<a href="#l11.345"></a><span id="l11.345" class="difflineplus">+    s-&gt;l_buf = s-&gt;pending_buf + (1+sizeof(ush))*s-&gt;lit_bufsize;</span>
<a href="#l11.346"></a><span id="l11.346" class="difflineplus">+</span>
<a href="#l11.347"></a><span id="l11.347" class="difflineplus">+    s-&gt;level = level;</span>
<a href="#l11.348"></a><span id="l11.348" class="difflineplus">+    s-&gt;strategy = strategy;</span>
<a href="#l11.349"></a><span id="l11.349" class="difflineplus">+    s-&gt;method = (Byte)method;</span>
<a href="#l11.350"></a><span id="l11.350" class="difflineplus">+</span>
<a href="#l11.351"></a><span id="l11.351" class="difflineplus">+    return deflateReset(strm);</span>
<a href="#l11.352"></a><span id="l11.352" class="difflineplus">+}</span>
<a href="#l11.353"></a><span id="l11.353" class="difflineplus">+</span>
<a href="#l11.354"></a><span id="l11.354" class="difflineplus">+/* =========================================================================</span>
<a href="#l11.355"></a><span id="l11.355" class="difflineplus">+ * Check for a valid deflate stream state. Return 0 if ok, 1 if not.</span>
<a href="#l11.356"></a><span id="l11.356" class="difflineplus">+ */</span>
<a href="#l11.357"></a><span id="l11.357" class="difflineplus">+local int deflateStateCheck (strm)</span>
<a href="#l11.358"></a><span id="l11.358" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.359"></a><span id="l11.359" class="difflineplus">+{</span>
<a href="#l11.360"></a><span id="l11.360" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.361"></a><span id="l11.361" class="difflineplus">+    if (strm == Z_NULL ||</span>
<a href="#l11.362"></a><span id="l11.362" class="difflineplus">+        strm-&gt;zalloc == (alloc_func)0 || strm-&gt;zfree == (free_func)0)</span>
<a href="#l11.363"></a><span id="l11.363" class="difflineplus">+        return 1;</span>
<a href="#l11.364"></a><span id="l11.364" class="difflineplus">+    s = strm-&gt;state;</span>
<a href="#l11.365"></a><span id="l11.365" class="difflineplus">+    if (s == Z_NULL || s-&gt;strm != strm || (s-&gt;status != INIT_STATE &amp;&amp;</span>
<a href="#l11.366"></a><span id="l11.366" class="difflineplus">+#ifdef GZIP</span>
<a href="#l11.367"></a><span id="l11.367" class="difflineplus">+                                           s-&gt;status != GZIP_STATE &amp;&amp;</span>
<a href="#l11.368"></a><span id="l11.368" class="difflineplus">+#endif</span>
<a href="#l11.369"></a><span id="l11.369" class="difflineplus">+                                           s-&gt;status != EXTRA_STATE &amp;&amp;</span>
<a href="#l11.370"></a><span id="l11.370" class="difflineplus">+                                           s-&gt;status != NAME_STATE &amp;&amp;</span>
<a href="#l11.371"></a><span id="l11.371" class="difflineplus">+                                           s-&gt;status != COMMENT_STATE &amp;&amp;</span>
<a href="#l11.372"></a><span id="l11.372" class="difflineplus">+                                           s-&gt;status != HCRC_STATE &amp;&amp;</span>
<a href="#l11.373"></a><span id="l11.373" class="difflineplus">+                                           s-&gt;status != BUSY_STATE &amp;&amp;</span>
<a href="#l11.374"></a><span id="l11.374" class="difflineplus">+                                           s-&gt;status != FINISH_STATE))</span>
<a href="#l11.375"></a><span id="l11.375" class="difflineplus">+        return 1;</span>
<a href="#l11.376"></a><span id="l11.376" class="difflineplus">+    return 0;</span>
<a href="#l11.377"></a><span id="l11.377" class="difflineplus">+}</span>
<a href="#l11.378"></a><span id="l11.378" class="difflineplus">+</span>
<a href="#l11.379"></a><span id="l11.379" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l11.380"></a><span id="l11.380" class="difflineplus">+int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)</span>
<a href="#l11.381"></a><span id="l11.381" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.382"></a><span id="l11.382" class="difflineplus">+    const Bytef *dictionary;</span>
<a href="#l11.383"></a><span id="l11.383" class="difflineplus">+    uInt  dictLength;</span>
<a href="#l11.384"></a><span id="l11.384" class="difflineplus">+{</span>
<a href="#l11.385"></a><span id="l11.385" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.386"></a><span id="l11.386" class="difflineplus">+    uInt str, n;</span>
<a href="#l11.387"></a><span id="l11.387" class="difflineplus">+    int wrap;</span>
<a href="#l11.388"></a><span id="l11.388" class="difflineplus">+    unsigned avail;</span>
<a href="#l11.389"></a><span id="l11.389" class="difflineplus">+    z_const unsigned char *next;</span>
<a href="#l11.390"></a><span id="l11.390" class="difflineplus">+</span>
<a href="#l11.391"></a><span id="l11.391" class="difflineplus">+    if (deflateStateCheck(strm) || dictionary == Z_NULL)</span>
<a href="#l11.392"></a><span id="l11.392" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l11.393"></a><span id="l11.393" class="difflineplus">+    s = strm-&gt;state;</span>
<a href="#l11.394"></a><span id="l11.394" class="difflineplus">+    wrap = s-&gt;wrap;</span>
<a href="#l11.395"></a><span id="l11.395" class="difflineplus">+    if (wrap == 2 || (wrap == 1 &amp;&amp; s-&gt;status != INIT_STATE) || s-&gt;lookahead)</span>
<a href="#l11.396"></a><span id="l11.396" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l11.397"></a><span id="l11.397" class="difflineplus">+</span>
<a href="#l11.398"></a><span id="l11.398" class="difflineplus">+    /* when using zlib wrappers, compute Adler-32 for provided dictionary */</span>
<a href="#l11.399"></a><span id="l11.399" class="difflineplus">+    if (wrap == 1)</span>
<a href="#l11.400"></a><span id="l11.400" class="difflineplus">+        strm-&gt;adler = adler32(strm-&gt;adler, dictionary, dictLength);</span>
<a href="#l11.401"></a><span id="l11.401" class="difflineplus">+    s-&gt;wrap = 0;                    /* avoid computing Adler-32 in read_buf */</span>
<a href="#l11.402"></a><span id="l11.402" class="difflineplus">+</span>
<a href="#l11.403"></a><span id="l11.403" class="difflineplus">+    /* if dictionary would fill window, just replace the history */</span>
<a href="#l11.404"></a><span id="l11.404" class="difflineplus">+    if (dictLength &gt;= s-&gt;w_size) {</span>
<a href="#l11.405"></a><span id="l11.405" class="difflineplus">+        if (wrap == 0) {            /* already empty otherwise */</span>
<a href="#l11.406"></a><span id="l11.406" class="difflineplus">+            CLEAR_HASH(s);</span>
<a href="#l11.407"></a><span id="l11.407" class="difflineplus">+            s-&gt;strstart = 0;</span>
<a href="#l11.408"></a><span id="l11.408" class="difflineplus">+            s-&gt;block_start = 0L;</span>
<a href="#l11.409"></a><span id="l11.409" class="difflineplus">+            s-&gt;insert = 0;</span>
<a href="#l11.410"></a><span id="l11.410" class="difflineplus">+        }</span>
<a href="#l11.411"></a><span id="l11.411" class="difflineplus">+        dictionary += dictLength - s-&gt;w_size;  /* use the tail */</span>
<a href="#l11.412"></a><span id="l11.412" class="difflineplus">+        dictLength = s-&gt;w_size;</span>
<a href="#l11.413"></a><span id="l11.413" class="difflineplus">+    }</span>
<a href="#l11.414"></a><span id="l11.414" class="difflineplus">+</span>
<a href="#l11.415"></a><span id="l11.415" class="difflineplus">+    /* insert dictionary into window and hash */</span>
<a href="#l11.416"></a><span id="l11.416" class="difflineplus">+    avail = strm-&gt;avail_in;</span>
<a href="#l11.417"></a><span id="l11.417" class="difflineplus">+    next = strm-&gt;next_in;</span>
<a href="#l11.418"></a><span id="l11.418" class="difflineplus">+    strm-&gt;avail_in = dictLength;</span>
<a href="#l11.419"></a><span id="l11.419" class="difflineplus">+    strm-&gt;next_in = (z_const Bytef *)dictionary;</span>
<a href="#l11.420"></a><span id="l11.420" class="difflineplus">+    fill_window(s);</span>
<a href="#l11.421"></a><span id="l11.421" class="difflineplus">+    while (s-&gt;lookahead &gt;= MIN_MATCH) {</span>
<a href="#l11.422"></a><span id="l11.422" class="difflineplus">+        str = s-&gt;strstart;</span>
<a href="#l11.423"></a><span id="l11.423" class="difflineplus">+        n = s-&gt;lookahead - (MIN_MATCH-1);</span>
<a href="#l11.424"></a><span id="l11.424" class="difflineplus">+        do {</span>
<a href="#l11.425"></a><span id="l11.425" class="difflineplus">+            UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[str + MIN_MATCH-1]);</span>
<a href="#l11.426"></a><span id="l11.426" class="difflineplus">+#ifndef FASTEST</span>
<a href="#l11.427"></a><span id="l11.427" class="difflineplus">+            s-&gt;prev[str &amp; s-&gt;w_mask] = s-&gt;head[s-&gt;ins_h];</span>
<a href="#l11.428"></a><span id="l11.428" class="difflineplus">+#endif</span>
<a href="#l11.429"></a><span id="l11.429" class="difflineplus">+            s-&gt;head[s-&gt;ins_h] = (Pos)str;</span>
<a href="#l11.430"></a><span id="l11.430" class="difflineplus">+            str++;</span>
<a href="#l11.431"></a><span id="l11.431" class="difflineplus">+        } while (--n);</span>
<a href="#l11.432"></a><span id="l11.432" class="difflineplus">+        s-&gt;strstart = str;</span>
<a href="#l11.433"></a><span id="l11.433" class="difflineplus">+        s-&gt;lookahead = MIN_MATCH-1;</span>
<a href="#l11.434"></a><span id="l11.434" class="difflineplus">+        fill_window(s);</span>
<a href="#l11.435"></a><span id="l11.435" class="difflineplus">+    }</span>
<a href="#l11.436"></a><span id="l11.436" class="difflineplus">+    s-&gt;strstart += s-&gt;lookahead;</span>
<a href="#l11.437"></a><span id="l11.437" class="difflineplus">+    s-&gt;block_start = (long)s-&gt;strstart;</span>
<a href="#l11.438"></a><span id="l11.438" class="difflineplus">+    s-&gt;insert = s-&gt;lookahead;</span>
<a href="#l11.439"></a><span id="l11.439" class="difflineplus">+    s-&gt;lookahead = 0;</span>
<a href="#l11.440"></a><span id="l11.440" class="difflineplus">+    s-&gt;match_length = s-&gt;prev_length = MIN_MATCH-1;</span>
<a href="#l11.441"></a><span id="l11.441" class="difflineplus">+    s-&gt;match_available = 0;</span>
<a href="#l11.442"></a><span id="l11.442" class="difflineplus">+    strm-&gt;next_in = next;</span>
<a href="#l11.443"></a><span id="l11.443" class="difflineplus">+    strm-&gt;avail_in = avail;</span>
<a href="#l11.444"></a><span id="l11.444" class="difflineplus">+    s-&gt;wrap = wrap;</span>
<a href="#l11.445"></a><span id="l11.445" class="difflineplus">+    return Z_OK;</span>
<a href="#l11.446"></a><span id="l11.446" class="difflineplus">+}</span>
<a href="#l11.447"></a><span id="l11.447" class="difflineplus">+</span>
<a href="#l11.448"></a><span id="l11.448" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l11.449"></a><span id="l11.449" class="difflineplus">+int ZEXPORT deflateGetDictionary (strm, dictionary, dictLength)</span>
<a href="#l11.450"></a><span id="l11.450" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.451"></a><span id="l11.451" class="difflineplus">+    Bytef *dictionary;</span>
<a href="#l11.452"></a><span id="l11.452" class="difflineplus">+    uInt  *dictLength;</span>
<a href="#l11.453"></a><span id="l11.453" class="difflineplus">+{</span>
<a href="#l11.454"></a><span id="l11.454" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.455"></a><span id="l11.455" class="difflineplus">+    uInt len;</span>
<a href="#l11.456"></a><span id="l11.456" class="difflineplus">+</span>
<a href="#l11.457"></a><span id="l11.457" class="difflineplus">+    if (deflateStateCheck(strm))</span>
<a href="#l11.458"></a><span id="l11.458" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l11.459"></a><span id="l11.459" class="difflineplus">+    s = strm-&gt;state;</span>
<a href="#l11.460"></a><span id="l11.460" class="difflineplus">+    len = s-&gt;strstart + s-&gt;lookahead;</span>
<a href="#l11.461"></a><span id="l11.461" class="difflineplus">+    if (len &gt; s-&gt;w_size)</span>
<a href="#l11.462"></a><span id="l11.462" class="difflineplus">+        len = s-&gt;w_size;</span>
<a href="#l11.463"></a><span id="l11.463" class="difflineplus">+    if (dictionary != Z_NULL &amp;&amp; len)</span>
<a href="#l11.464"></a><span id="l11.464" class="difflineplus">+        zmemcpy(dictionary, s-&gt;window + s-&gt;strstart + s-&gt;lookahead - len, len);</span>
<a href="#l11.465"></a><span id="l11.465" class="difflineplus">+    if (dictLength != Z_NULL)</span>
<a href="#l11.466"></a><span id="l11.466" class="difflineplus">+        *dictLength = len;</span>
<a href="#l11.467"></a><span id="l11.467" class="difflineplus">+    return Z_OK;</span>
<a href="#l11.468"></a><span id="l11.468" class="difflineplus">+}</span>
<a href="#l11.469"></a><span id="l11.469" class="difflineplus">+</span>
<a href="#l11.470"></a><span id="l11.470" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l11.471"></a><span id="l11.471" class="difflineplus">+int ZEXPORT deflateResetKeep (strm)</span>
<a href="#l11.472"></a><span id="l11.472" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.473"></a><span id="l11.473" class="difflineplus">+{</span>
<a href="#l11.474"></a><span id="l11.474" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.475"></a><span id="l11.475" class="difflineplus">+</span>
<a href="#l11.476"></a><span id="l11.476" class="difflineplus">+    if (deflateStateCheck(strm)) {</span>
<a href="#l11.477"></a><span id="l11.477" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l11.478"></a><span id="l11.478" class="difflineplus">+    }</span>
<a href="#l11.479"></a><span id="l11.479" class="difflineplus">+</span>
<a href="#l11.480"></a><span id="l11.480" class="difflineplus">+    strm-&gt;total_in = strm-&gt;total_out = 0;</span>
<a href="#l11.481"></a><span id="l11.481" class="difflineplus">+    strm-&gt;msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */</span>
<a href="#l11.482"></a><span id="l11.482" class="difflineplus">+    strm-&gt;data_type = Z_UNKNOWN;</span>
<a href="#l11.483"></a><span id="l11.483" class="difflineplus">+</span>
<a href="#l11.484"></a><span id="l11.484" class="difflineplus">+    s = (deflate_state *)strm-&gt;state;</span>
<a href="#l11.485"></a><span id="l11.485" class="difflineplus">+    s-&gt;pending = 0;</span>
<a href="#l11.486"></a><span id="l11.486" class="difflineplus">+    s-&gt;pending_out = s-&gt;pending_buf;</span>
<a href="#l11.487"></a><span id="l11.487" class="difflineplus">+</span>
<a href="#l11.488"></a><span id="l11.488" class="difflineplus">+    if (s-&gt;wrap &lt; 0) {</span>
<a href="#l11.489"></a><span id="l11.489" class="difflineplus">+        s-&gt;wrap = -s-&gt;wrap; /* was made negative by deflate(..., Z_FINISH); */</span>
<a href="#l11.490"></a><span id="l11.490" class="difflineplus">+    }</span>
<a href="#l11.491"></a><span id="l11.491" class="difflineplus">+    s-&gt;status =</span>
<a href="#l11.492"></a><span id="l11.492" class="difflineplus">+#ifdef GZIP</span>
<a href="#l11.493"></a><span id="l11.493" class="difflineplus">+        s-&gt;wrap == 2 ? GZIP_STATE :</span>
<a href="#l11.494"></a><span id="l11.494" class="difflineplus">+#endif</span>
<a href="#l11.495"></a><span id="l11.495" class="difflineplus">+        s-&gt;wrap ? INIT_STATE : BUSY_STATE;</span>
<a href="#l11.496"></a><span id="l11.496" class="difflineplus">+    strm-&gt;adler =</span>
<a href="#l11.497"></a><span id="l11.497" class="difflineplus">+#ifdef GZIP</span>
<a href="#l11.498"></a><span id="l11.498" class="difflineplus">+        s-&gt;wrap == 2 ? crc32(0L, Z_NULL, 0) :</span>
<a href="#l11.499"></a><span id="l11.499" class="difflineplus">+#endif</span>
<a href="#l11.500"></a><span id="l11.500" class="difflineplus">+        adler32(0L, Z_NULL, 0);</span>
<a href="#l11.501"></a><span id="l11.501" class="difflineplus">+    s-&gt;last_flush = Z_NO_FLUSH;</span>
<a href="#l11.502"></a><span id="l11.502" class="difflineplus">+</span>
<a href="#l11.503"></a><span id="l11.503" class="difflineplus">+    _tr_init(s);</span>
<a href="#l11.504"></a><span id="l11.504" class="difflineplus">+</span>
<a href="#l11.505"></a><span id="l11.505" class="difflineplus">+    return Z_OK;</span>
<a href="#l11.506"></a><span id="l11.506" class="difflineplus">+}</span>
<a href="#l11.507"></a><span id="l11.507" class="difflineplus">+</span>
<a href="#l11.508"></a><span id="l11.508" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l11.509"></a><span id="l11.509" class="difflineplus">+int ZEXPORT deflateReset (strm)</span>
<a href="#l11.510"></a><span id="l11.510" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.511"></a><span id="l11.511" class="difflineplus">+{</span>
<a href="#l11.512"></a><span id="l11.512" class="difflineplus">+    int ret;</span>
<a href="#l11.513"></a><span id="l11.513" class="difflineplus">+</span>
<a href="#l11.514"></a><span id="l11.514" class="difflineplus">+    ret = deflateResetKeep(strm);</span>
<a href="#l11.515"></a><span id="l11.515" class="difflineplus">+    if (ret == Z_OK)</span>
<a href="#l11.516"></a><span id="l11.516" class="difflineplus">+        lm_init(strm-&gt;state);</span>
<a href="#l11.517"></a><span id="l11.517" class="difflineplus">+    return ret;</span>
<a href="#l11.518"></a><span id="l11.518" class="difflineplus">+}</span>
<a href="#l11.519"></a><span id="l11.519" class="difflineplus">+</span>
<a href="#l11.520"></a><span id="l11.520" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l11.521"></a><span id="l11.521" class="difflineplus">+int ZEXPORT deflateSetHeader (strm, head)</span>
<a href="#l11.522"></a><span id="l11.522" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.523"></a><span id="l11.523" class="difflineplus">+    gz_headerp head;</span>
<a href="#l11.524"></a><span id="l11.524" class="difflineplus">+{</span>
<a href="#l11.525"></a><span id="l11.525" class="difflineplus">+    if (deflateStateCheck(strm) || strm-&gt;state-&gt;wrap != 2)</span>
<a href="#l11.526"></a><span id="l11.526" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l11.527"></a><span id="l11.527" class="difflineplus">+    strm-&gt;state-&gt;gzhead = head;</span>
<a href="#l11.528"></a><span id="l11.528" class="difflineplus">+    return Z_OK;</span>
<a href="#l11.529"></a><span id="l11.529" class="difflineplus">+}</span>
<a href="#l11.530"></a><span id="l11.530" class="difflineplus">+</span>
<a href="#l11.531"></a><span id="l11.531" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l11.532"></a><span id="l11.532" class="difflineplus">+int ZEXPORT deflatePending (strm, pending, bits)</span>
<a href="#l11.533"></a><span id="l11.533" class="difflineplus">+    unsigned *pending;</span>
<a href="#l11.534"></a><span id="l11.534" class="difflineplus">+    int *bits;</span>
<a href="#l11.535"></a><span id="l11.535" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.536"></a><span id="l11.536" class="difflineplus">+{</span>
<a href="#l11.537"></a><span id="l11.537" class="difflineplus">+    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l11.538"></a><span id="l11.538" class="difflineplus">+    if (pending != Z_NULL)</span>
<a href="#l11.539"></a><span id="l11.539" class="difflineplus">+        *pending = strm-&gt;state-&gt;pending;</span>
<a href="#l11.540"></a><span id="l11.540" class="difflineplus">+    if (bits != Z_NULL)</span>
<a href="#l11.541"></a><span id="l11.541" class="difflineplus">+        *bits = strm-&gt;state-&gt;bi_valid;</span>
<a href="#l11.542"></a><span id="l11.542" class="difflineplus">+    return Z_OK;</span>
<a href="#l11.543"></a><span id="l11.543" class="difflineplus">+}</span>
<a href="#l11.544"></a><span id="l11.544" class="difflineplus">+</span>
<a href="#l11.545"></a><span id="l11.545" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l11.546"></a><span id="l11.546" class="difflineplus">+int ZEXPORT deflatePrime (strm, bits, value)</span>
<a href="#l11.547"></a><span id="l11.547" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.548"></a><span id="l11.548" class="difflineplus">+    int bits;</span>
<a href="#l11.549"></a><span id="l11.549" class="difflineplus">+    int value;</span>
<a href="#l11.550"></a><span id="l11.550" class="difflineplus">+{</span>
<a href="#l11.551"></a><span id="l11.551" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.552"></a><span id="l11.552" class="difflineplus">+    int put;</span>
<a href="#l11.553"></a><span id="l11.553" class="difflineplus">+</span>
<a href="#l11.554"></a><span id="l11.554" class="difflineplus">+    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l11.555"></a><span id="l11.555" class="difflineplus">+    s = strm-&gt;state;</span>
<a href="#l11.556"></a><span id="l11.556" class="difflineplus">+    if ((Bytef *)(s-&gt;d_buf) &lt; s-&gt;pending_out + ((Buf_size + 7) &gt;&gt; 3))</span>
<a href="#l11.557"></a><span id="l11.557" class="difflineplus">+        return Z_BUF_ERROR;</span>
<a href="#l11.558"></a><span id="l11.558" class="difflineplus">+    do {</span>
<a href="#l11.559"></a><span id="l11.559" class="difflineplus">+        put = Buf_size - s-&gt;bi_valid;</span>
<a href="#l11.560"></a><span id="l11.560" class="difflineplus">+        if (put &gt; bits)</span>
<a href="#l11.561"></a><span id="l11.561" class="difflineplus">+            put = bits;</span>
<a href="#l11.562"></a><span id="l11.562" class="difflineplus">+        s-&gt;bi_buf |= (ush)((value &amp; ((1 &lt;&lt; put) - 1)) &lt;&lt; s-&gt;bi_valid);</span>
<a href="#l11.563"></a><span id="l11.563" class="difflineplus">+        s-&gt;bi_valid += put;</span>
<a href="#l11.564"></a><span id="l11.564" class="difflineplus">+        _tr_flush_bits(s);</span>
<a href="#l11.565"></a><span id="l11.565" class="difflineplus">+        value &gt;&gt;= put;</span>
<a href="#l11.566"></a><span id="l11.566" class="difflineplus">+        bits -= put;</span>
<a href="#l11.567"></a><span id="l11.567" class="difflineplus">+    } while (bits);</span>
<a href="#l11.568"></a><span id="l11.568" class="difflineplus">+    return Z_OK;</span>
<a href="#l11.569"></a><span id="l11.569" class="difflineplus">+}</span>
<a href="#l11.570"></a><span id="l11.570" class="difflineplus">+</span>
<a href="#l11.571"></a><span id="l11.571" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l11.572"></a><span id="l11.572" class="difflineplus">+int ZEXPORT deflateParams(strm, level, strategy)</span>
<a href="#l11.573"></a><span id="l11.573" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.574"></a><span id="l11.574" class="difflineplus">+    int level;</span>
<a href="#l11.575"></a><span id="l11.575" class="difflineplus">+    int strategy;</span>
<a href="#l11.576"></a><span id="l11.576" class="difflineplus">+{</span>
<a href="#l11.577"></a><span id="l11.577" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.578"></a><span id="l11.578" class="difflineplus">+    compress_func func;</span>
<a href="#l11.579"></a><span id="l11.579" class="difflineplus">+</span>
<a href="#l11.580"></a><span id="l11.580" class="difflineplus">+    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l11.581"></a><span id="l11.581" class="difflineplus">+    s = strm-&gt;state;</span>
<a href="#l11.582"></a><span id="l11.582" class="difflineplus">+</span>
<a href="#l11.583"></a><span id="l11.583" class="difflineplus">+#ifdef FASTEST</span>
<a href="#l11.584"></a><span id="l11.584" class="difflineplus">+    if (level != 0) level = 1;</span>
<a href="#l11.585"></a><span id="l11.585" class="difflineplus">+#else</span>
<a href="#l11.586"></a><span id="l11.586" class="difflineplus">+    if (level == Z_DEFAULT_COMPRESSION) level = 6;</span>
<a href="#l11.587"></a><span id="l11.587" class="difflineplus">+#endif</span>
<a href="#l11.588"></a><span id="l11.588" class="difflineplus">+    if (level &lt; 0 || level &gt; 9 || strategy &lt; 0 || strategy &gt; Z_FIXED) {</span>
<a href="#l11.589"></a><span id="l11.589" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l11.590"></a><span id="l11.590" class="difflineplus">+    }</span>
<a href="#l11.591"></a><span id="l11.591" class="difflineplus">+    func = configuration_table[s-&gt;level].func;</span>
<a href="#l11.592"></a><span id="l11.592" class="difflineplus">+</span>
<a href="#l11.593"></a><span id="l11.593" class="difflineplus">+    if ((strategy != s-&gt;strategy || func != configuration_table[level].func) &amp;&amp;</span>
<a href="#l11.594"></a><span id="l11.594" class="difflineplus">+        s-&gt;high_water) {</span>
<a href="#l11.595"></a><span id="l11.595" class="difflineplus">+        /* Flush the last buffer: */</span>
<a href="#l11.596"></a><span id="l11.596" class="difflineplus">+        int err = deflate(strm, Z_BLOCK);</span>
<a href="#l11.597"></a><span id="l11.597" class="difflineplus">+        if (err == Z_STREAM_ERROR)</span>
<a href="#l11.598"></a><span id="l11.598" class="difflineplus">+            return err;</span>
<a href="#l11.599"></a><span id="l11.599" class="difflineplus">+        if (strm-&gt;avail_out == 0)</span>
<a href="#l11.600"></a><span id="l11.600" class="difflineplus">+            return Z_BUF_ERROR;</span>
<a href="#l11.601"></a><span id="l11.601" class="difflineplus">+    }</span>
<a href="#l11.602"></a><span id="l11.602" class="difflineplus">+    if (s-&gt;level != level) {</span>
<a href="#l11.603"></a><span id="l11.603" class="difflineplus">+        if (s-&gt;level == 0 &amp;&amp; s-&gt;matches != 0) {</span>
<a href="#l11.604"></a><span id="l11.604" class="difflineplus">+            if (s-&gt;matches == 1)</span>
<a href="#l11.605"></a><span id="l11.605" class="difflineplus">+                slide_hash(s);</span>
<a href="#l11.606"></a><span id="l11.606" class="difflineplus">+            else</span>
<a href="#l11.607"></a><span id="l11.607" class="difflineplus">+                CLEAR_HASH(s);</span>
<a href="#l11.608"></a><span id="l11.608" class="difflineplus">+            s-&gt;matches = 0;</span>
<a href="#l11.609"></a><span id="l11.609" class="difflineplus">+        }</span>
<a href="#l11.610"></a><span id="l11.610" class="difflineplus">+        s-&gt;level = level;</span>
<a href="#l11.611"></a><span id="l11.611" class="difflineplus">+        s-&gt;max_lazy_match   = configuration_table[level].max_lazy;</span>
<a href="#l11.612"></a><span id="l11.612" class="difflineplus">+        s-&gt;good_match       = configuration_table[level].good_length;</span>
<a href="#l11.613"></a><span id="l11.613" class="difflineplus">+        s-&gt;nice_match       = configuration_table[level].nice_length;</span>
<a href="#l11.614"></a><span id="l11.614" class="difflineplus">+        s-&gt;max_chain_length = configuration_table[level].max_chain;</span>
<a href="#l11.615"></a><span id="l11.615" class="difflineplus">+    }</span>
<a href="#l11.616"></a><span id="l11.616" class="difflineplus">+    s-&gt;strategy = strategy;</span>
<a href="#l11.617"></a><span id="l11.617" class="difflineplus">+    return Z_OK;</span>
<a href="#l11.618"></a><span id="l11.618" class="difflineplus">+}</span>
<a href="#l11.619"></a><span id="l11.619" class="difflineplus">+</span>
<a href="#l11.620"></a><span id="l11.620" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l11.621"></a><span id="l11.621" class="difflineplus">+int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)</span>
<a href="#l11.622"></a><span id="l11.622" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.623"></a><span id="l11.623" class="difflineplus">+    int good_length;</span>
<a href="#l11.624"></a><span id="l11.624" class="difflineplus">+    int max_lazy;</span>
<a href="#l11.625"></a><span id="l11.625" class="difflineplus">+    int nice_length;</span>
<a href="#l11.626"></a><span id="l11.626" class="difflineplus">+    int max_chain;</span>
<a href="#l11.627"></a><span id="l11.627" class="difflineplus">+{</span>
<a href="#l11.628"></a><span id="l11.628" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.629"></a><span id="l11.629" class="difflineplus">+</span>
<a href="#l11.630"></a><span id="l11.630" class="difflineplus">+    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l11.631"></a><span id="l11.631" class="difflineplus">+    s = strm-&gt;state;</span>
<a href="#l11.632"></a><span id="l11.632" class="difflineplus">+    s-&gt;good_match = (uInt)good_length;</span>
<a href="#l11.633"></a><span id="l11.633" class="difflineplus">+    s-&gt;max_lazy_match = (uInt)max_lazy;</span>
<a href="#l11.634"></a><span id="l11.634" class="difflineplus">+    s-&gt;nice_match = nice_length;</span>
<a href="#l11.635"></a><span id="l11.635" class="difflineplus">+    s-&gt;max_chain_length = (uInt)max_chain;</span>
<a href="#l11.636"></a><span id="l11.636" class="difflineplus">+    return Z_OK;</span>
<a href="#l11.637"></a><span id="l11.637" class="difflineplus">+}</span>
<a href="#l11.638"></a><span id="l11.638" class="difflineplus">+</span>
<a href="#l11.639"></a><span id="l11.639" class="difflineplus">+/* =========================================================================</span>
<a href="#l11.640"></a><span id="l11.640" class="difflineplus">+ * For the default windowBits of 15 and memLevel of 8, this function returns</span>
<a href="#l11.641"></a><span id="l11.641" class="difflineplus">+ * a close to exact, as well as small, upper bound on the compressed size.</span>
<a href="#l11.642"></a><span id="l11.642" class="difflineplus">+ * They are coded as constants here for a reason--if the #define's are</span>
<a href="#l11.643"></a><span id="l11.643" class="difflineplus">+ * changed, then this function needs to be changed as well.  The return</span>
<a href="#l11.644"></a><span id="l11.644" class="difflineplus">+ * value for 15 and 8 only works for those exact settings.</span>
<a href="#l11.645"></a><span id="l11.645" class="difflineplus">+ *</span>
<a href="#l11.646"></a><span id="l11.646" class="difflineplus">+ * For any setting other than those defaults for windowBits and memLevel,</span>
<a href="#l11.647"></a><span id="l11.647" class="difflineplus">+ * the value returned is a conservative worst case for the maximum expansion</span>
<a href="#l11.648"></a><span id="l11.648" class="difflineplus">+ * resulting from using fixed blocks instead of stored blocks, which deflate</span>
<a href="#l11.649"></a><span id="l11.649" class="difflineplus">+ * can emit on compressed data for some combinations of the parameters.</span>
<a href="#l11.650"></a><span id="l11.650" class="difflineplus">+ *</span>
<a href="#l11.651"></a><span id="l11.651" class="difflineplus">+ * This function could be more sophisticated to provide closer upper bounds for</span>
<a href="#l11.652"></a><span id="l11.652" class="difflineplus">+ * every combination of windowBits and memLevel.  But even the conservative</span>
<a href="#l11.653"></a><span id="l11.653" class="difflineplus">+ * upper bound of about 14% expansion does not seem onerous for output buffer</span>
<a href="#l11.654"></a><span id="l11.654" class="difflineplus">+ * allocation.</span>
<a href="#l11.655"></a><span id="l11.655" class="difflineplus">+ */</span>
<a href="#l11.656"></a><span id="l11.656" class="difflineplus">+uLong ZEXPORT deflateBound(strm, sourceLen)</span>
<a href="#l11.657"></a><span id="l11.657" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.658"></a><span id="l11.658" class="difflineplus">+    uLong sourceLen;</span>
<a href="#l11.659"></a><span id="l11.659" class="difflineplus">+{</span>
<a href="#l11.660"></a><span id="l11.660" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.661"></a><span id="l11.661" class="difflineplus">+    uLong complen, wraplen;</span>
<a href="#l11.662"></a><span id="l11.662" class="difflineplus">+</span>
<a href="#l11.663"></a><span id="l11.663" class="difflineplus">+    /* conservative upper bound for compressed data */</span>
<a href="#l11.664"></a><span id="l11.664" class="difflineplus">+    complen = sourceLen +</span>
<a href="#l11.665"></a><span id="l11.665" class="difflineplus">+              ((sourceLen + 7) &gt;&gt; 3) + ((sourceLen + 63) &gt;&gt; 6) + 5;</span>
<a href="#l11.666"></a><span id="l11.666" class="difflineplus">+</span>
<a href="#l11.667"></a><span id="l11.667" class="difflineplus">+    /* if can't get parameters, return conservative bound plus zlib wrapper */</span>
<a href="#l11.668"></a><span id="l11.668" class="difflineplus">+    if (deflateStateCheck(strm))</span>
<a href="#l11.669"></a><span id="l11.669" class="difflineplus">+        return complen + 6;</span>
<a href="#l11.670"></a><span id="l11.670" class="difflineplus">+</span>
<a href="#l11.671"></a><span id="l11.671" class="difflineplus">+    /* compute wrapper length */</span>
<a href="#l11.672"></a><span id="l11.672" class="difflineplus">+    s = strm-&gt;state;</span>
<a href="#l11.673"></a><span id="l11.673" class="difflineplus">+    switch (s-&gt;wrap) {</span>
<a href="#l11.674"></a><span id="l11.674" class="difflineplus">+    case 0:                                 /* raw deflate */</span>
<a href="#l11.675"></a><span id="l11.675" class="difflineplus">+        wraplen = 0;</span>
<a href="#l11.676"></a><span id="l11.676" class="difflineplus">+        break;</span>
<a href="#l11.677"></a><span id="l11.677" class="difflineplus">+    case 1:                                 /* zlib wrapper */</span>
<a href="#l11.678"></a><span id="l11.678" class="difflineplus">+        wraplen = 6 + (s-&gt;strstart ? 4 : 0);</span>
<a href="#l11.679"></a><span id="l11.679" class="difflineplus">+        break;</span>
<a href="#l11.680"></a><span id="l11.680" class="difflineplus">+#ifdef GZIP</span>
<a href="#l11.681"></a><span id="l11.681" class="difflineplus">+    case 2:                                 /* gzip wrapper */</span>
<a href="#l11.682"></a><span id="l11.682" class="difflineplus">+        wraplen = 18;</span>
<a href="#l11.683"></a><span id="l11.683" class="difflineplus">+        if (s-&gt;gzhead != Z_NULL) {          /* user-supplied gzip header */</span>
<a href="#l11.684"></a><span id="l11.684" class="difflineplus">+            Bytef *str;</span>
<a href="#l11.685"></a><span id="l11.685" class="difflineplus">+            if (s-&gt;gzhead-&gt;extra != Z_NULL)</span>
<a href="#l11.686"></a><span id="l11.686" class="difflineplus">+                wraplen += 2 + s-&gt;gzhead-&gt;extra_len;</span>
<a href="#l11.687"></a><span id="l11.687" class="difflineplus">+            str = s-&gt;gzhead-&gt;name;</span>
<a href="#l11.688"></a><span id="l11.688" class="difflineplus">+            if (str != Z_NULL)</span>
<a href="#l11.689"></a><span id="l11.689" class="difflineplus">+                do {</span>
<a href="#l11.690"></a><span id="l11.690" class="difflineplus">+                    wraplen++;</span>
<a href="#l11.691"></a><span id="l11.691" class="difflineplus">+                } while (*str++);</span>
<a href="#l11.692"></a><span id="l11.692" class="difflineplus">+            str = s-&gt;gzhead-&gt;comment;</span>
<a href="#l11.693"></a><span id="l11.693" class="difflineplus">+            if (str != Z_NULL)</span>
<a href="#l11.694"></a><span id="l11.694" class="difflineplus">+                do {</span>
<a href="#l11.695"></a><span id="l11.695" class="difflineplus">+                    wraplen++;</span>
<a href="#l11.696"></a><span id="l11.696" class="difflineplus">+                } while (*str++);</span>
<a href="#l11.697"></a><span id="l11.697" class="difflineplus">+            if (s-&gt;gzhead-&gt;hcrc)</span>
<a href="#l11.698"></a><span id="l11.698" class="difflineplus">+                wraplen += 2;</span>
<a href="#l11.699"></a><span id="l11.699" class="difflineplus">+        }</span>
<a href="#l11.700"></a><span id="l11.700" class="difflineplus">+        break;</span>
<a href="#l11.701"></a><span id="l11.701" class="difflineplus">+#endif</span>
<a href="#l11.702"></a><span id="l11.702" class="difflineplus">+    default:                                /* for compiler happiness */</span>
<a href="#l11.703"></a><span id="l11.703" class="difflineplus">+        wraplen = 6;</span>
<a href="#l11.704"></a><span id="l11.704" class="difflineplus">+    }</span>
<a href="#l11.705"></a><span id="l11.705" class="difflineplus">+</span>
<a href="#l11.706"></a><span id="l11.706" class="difflineplus">+    /* if not default parameters, return conservative bound */</span>
<a href="#l11.707"></a><span id="l11.707" class="difflineplus">+    if (s-&gt;w_bits != 15 || s-&gt;hash_bits != 8 + 7)</span>
<a href="#l11.708"></a><span id="l11.708" class="difflineplus">+        return complen + wraplen;</span>
<a href="#l11.709"></a><span id="l11.709" class="difflineplus">+</span>
<a href="#l11.710"></a><span id="l11.710" class="difflineplus">+    /* default settings: return tight bound for that case */</span>
<a href="#l11.711"></a><span id="l11.711" class="difflineplus">+    return sourceLen + (sourceLen &gt;&gt; 12) + (sourceLen &gt;&gt; 14) +</span>
<a href="#l11.712"></a><span id="l11.712" class="difflineplus">+           (sourceLen &gt;&gt; 25) + 13 - 6 + wraplen;</span>
<a href="#l11.713"></a><span id="l11.713" class="difflineplus">+}</span>
<a href="#l11.714"></a><span id="l11.714" class="difflineplus">+</span>
<a href="#l11.715"></a><span id="l11.715" class="difflineplus">+/* =========================================================================</span>
<a href="#l11.716"></a><span id="l11.716" class="difflineplus">+ * Put a short in the pending buffer. The 16-bit value is put in MSB order.</span>
<a href="#l11.717"></a><span id="l11.717" class="difflineplus">+ * IN assertion: the stream state is correct and there is enough room in</span>
<a href="#l11.718"></a><span id="l11.718" class="difflineplus">+ * pending_buf.</span>
<a href="#l11.719"></a><span id="l11.719" class="difflineplus">+ */</span>
<a href="#l11.720"></a><span id="l11.720" class="difflineplus">+local void putShortMSB (s, b)</span>
<a href="#l11.721"></a><span id="l11.721" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.722"></a><span id="l11.722" class="difflineplus">+    uInt b;</span>
<a href="#l11.723"></a><span id="l11.723" class="difflineplus">+{</span>
<a href="#l11.724"></a><span id="l11.724" class="difflineplus">+    put_byte(s, (Byte)(b &gt;&gt; 8));</span>
<a href="#l11.725"></a><span id="l11.725" class="difflineplus">+    put_byte(s, (Byte)(b &amp; 0xff));</span>
<a href="#l11.726"></a><span id="l11.726" class="difflineplus">+}</span>
<a href="#l11.727"></a><span id="l11.727" class="difflineplus">+</span>
<a href="#l11.728"></a><span id="l11.728" class="difflineplus">+/* =========================================================================</span>
<a href="#l11.729"></a><span id="l11.729" class="difflineplus">+ * Flush as much pending output as possible. All deflate() output, except for</span>
<a href="#l11.730"></a><span id="l11.730" class="difflineplus">+ * some deflate_stored() output, goes through this function so some</span>
<a href="#l11.731"></a><span id="l11.731" class="difflineplus">+ * applications may wish to modify it to avoid allocating a large</span>
<a href="#l11.732"></a><span id="l11.732" class="difflineplus">+ * strm-&gt;next_out buffer and copying into it. (See also read_buf()).</span>
<a href="#l11.733"></a><span id="l11.733" class="difflineplus">+ */</span>
<a href="#l11.734"></a><span id="l11.734" class="difflineplus">+local void flush_pending(strm)</span>
<a href="#l11.735"></a><span id="l11.735" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.736"></a><span id="l11.736" class="difflineplus">+{</span>
<a href="#l11.737"></a><span id="l11.737" class="difflineplus">+    unsigned len;</span>
<a href="#l11.738"></a><span id="l11.738" class="difflineplus">+    deflate_state *s = strm-&gt;state;</span>
<a href="#l11.739"></a><span id="l11.739" class="difflineplus">+</span>
<a href="#l11.740"></a><span id="l11.740" class="difflineplus">+    _tr_flush_bits(s);</span>
<a href="#l11.741"></a><span id="l11.741" class="difflineplus">+    len = s-&gt;pending;</span>
<a href="#l11.742"></a><span id="l11.742" class="difflineplus">+    if (len &gt; strm-&gt;avail_out) len = strm-&gt;avail_out;</span>
<a href="#l11.743"></a><span id="l11.743" class="difflineplus">+    if (len == 0) return;</span>
<a href="#l11.744"></a><span id="l11.744" class="difflineplus">+</span>
<a href="#l11.745"></a><span id="l11.745" class="difflineplus">+    zmemcpy(strm-&gt;next_out, s-&gt;pending_out, len);</span>
<a href="#l11.746"></a><span id="l11.746" class="difflineplus">+    strm-&gt;next_out  += len;</span>
<a href="#l11.747"></a><span id="l11.747" class="difflineplus">+    s-&gt;pending_out  += len;</span>
<a href="#l11.748"></a><span id="l11.748" class="difflineplus">+    strm-&gt;total_out += len;</span>
<a href="#l11.749"></a><span id="l11.749" class="difflineplus">+    strm-&gt;avail_out -= len;</span>
<a href="#l11.750"></a><span id="l11.750" class="difflineplus">+    s-&gt;pending      -= len;</span>
<a href="#l11.751"></a><span id="l11.751" class="difflineplus">+    if (s-&gt;pending == 0) {</span>
<a href="#l11.752"></a><span id="l11.752" class="difflineplus">+        s-&gt;pending_out = s-&gt;pending_buf;</span>
<a href="#l11.753"></a><span id="l11.753" class="difflineplus">+    }</span>
<a href="#l11.754"></a><span id="l11.754" class="difflineplus">+}</span>
<a href="#l11.755"></a><span id="l11.755" class="difflineplus">+</span>
<a href="#l11.756"></a><span id="l11.756" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.757"></a><span id="l11.757" class="difflineplus">+ * Update the header CRC with the bytes s-&gt;pending_buf[beg..s-&gt;pending - 1].</span>
<a href="#l11.758"></a><span id="l11.758" class="difflineplus">+ */</span>
<a href="#l11.759"></a><span id="l11.759" class="difflineplus">+#define HCRC_UPDATE(beg) \</span>
<a href="#l11.760"></a><span id="l11.760" class="difflineplus">+    do { \</span>
<a href="#l11.761"></a><span id="l11.761" class="difflineplus">+        if (s-&gt;gzhead-&gt;hcrc &amp;&amp; s-&gt;pending &gt; (beg)) \</span>
<a href="#l11.762"></a><span id="l11.762" class="difflineplus">+            strm-&gt;adler = crc32(strm-&gt;adler, s-&gt;pending_buf + (beg), \</span>
<a href="#l11.763"></a><span id="l11.763" class="difflineplus">+                                s-&gt;pending - (beg)); \</span>
<a href="#l11.764"></a><span id="l11.764" class="difflineplus">+    } while (0)</span>
<a href="#l11.765"></a><span id="l11.765" class="difflineplus">+</span>
<a href="#l11.766"></a><span id="l11.766" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l11.767"></a><span id="l11.767" class="difflineplus">+int ZEXPORT deflate (strm, flush)</span>
<a href="#l11.768"></a><span id="l11.768" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.769"></a><span id="l11.769" class="difflineplus">+    int flush;</span>
<a href="#l11.770"></a><span id="l11.770" class="difflineplus">+{</span>
<a href="#l11.771"></a><span id="l11.771" class="difflineplus">+    int old_flush; /* value of flush param for previous deflate call */</span>
<a href="#l11.772"></a><span id="l11.772" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.773"></a><span id="l11.773" class="difflineplus">+</span>
<a href="#l11.774"></a><span id="l11.774" class="difflineplus">+    if (deflateStateCheck(strm) || flush &gt; Z_BLOCK || flush &lt; 0) {</span>
<a href="#l11.775"></a><span id="l11.775" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l11.776"></a><span id="l11.776" class="difflineplus">+    }</span>
<a href="#l11.777"></a><span id="l11.777" class="difflineplus">+    s = strm-&gt;state;</span>
<a href="#l11.778"></a><span id="l11.778" class="difflineplus">+</span>
<a href="#l11.779"></a><span id="l11.779" class="difflineplus">+    if (strm-&gt;next_out == Z_NULL ||</span>
<a href="#l11.780"></a><span id="l11.780" class="difflineplus">+        (strm-&gt;avail_in != 0 &amp;&amp; strm-&gt;next_in == Z_NULL) ||</span>
<a href="#l11.781"></a><span id="l11.781" class="difflineplus">+        (s-&gt;status == FINISH_STATE &amp;&amp; flush != Z_FINISH)) {</span>
<a href="#l11.782"></a><span id="l11.782" class="difflineplus">+        ERR_RETURN(strm, Z_STREAM_ERROR);</span>
<a href="#l11.783"></a><span id="l11.783" class="difflineplus">+    }</span>
<a href="#l11.784"></a><span id="l11.784" class="difflineplus">+    if (strm-&gt;avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);</span>
<a href="#l11.785"></a><span id="l11.785" class="difflineplus">+</span>
<a href="#l11.786"></a><span id="l11.786" class="difflineplus">+    old_flush = s-&gt;last_flush;</span>
<a href="#l11.787"></a><span id="l11.787" class="difflineplus">+    s-&gt;last_flush = flush;</span>
<a href="#l11.788"></a><span id="l11.788" class="difflineplus">+</span>
<a href="#l11.789"></a><span id="l11.789" class="difflineplus">+    /* Flush as much pending output as possible */</span>
<a href="#l11.790"></a><span id="l11.790" class="difflineplus">+    if (s-&gt;pending != 0) {</span>
<a href="#l11.791"></a><span id="l11.791" class="difflineplus">+        flush_pending(strm);</span>
<a href="#l11.792"></a><span id="l11.792" class="difflineplus">+        if (strm-&gt;avail_out == 0) {</span>
<a href="#l11.793"></a><span id="l11.793" class="difflineplus">+            /* Since avail_out is 0, deflate will be called again with</span>
<a href="#l11.794"></a><span id="l11.794" class="difflineplus">+             * more output space, but possibly with both pending and</span>
<a href="#l11.795"></a><span id="l11.795" class="difflineplus">+             * avail_in equal to zero. There won't be anything to do,</span>
<a href="#l11.796"></a><span id="l11.796" class="difflineplus">+             * but this is not an error situation so make sure we</span>
<a href="#l11.797"></a><span id="l11.797" class="difflineplus">+             * return OK instead of BUF_ERROR at next call of deflate:</span>
<a href="#l11.798"></a><span id="l11.798" class="difflineplus">+             */</span>
<a href="#l11.799"></a><span id="l11.799" class="difflineplus">+            s-&gt;last_flush = -1;</span>
<a href="#l11.800"></a><span id="l11.800" class="difflineplus">+            return Z_OK;</span>
<a href="#l11.801"></a><span id="l11.801" class="difflineplus">+        }</span>
<a href="#l11.802"></a><span id="l11.802" class="difflineplus">+</span>
<a href="#l11.803"></a><span id="l11.803" class="difflineplus">+    /* Make sure there is something to do and avoid duplicate consecutive</span>
<a href="#l11.804"></a><span id="l11.804" class="difflineplus">+     * flushes. For repeated and useless calls with Z_FINISH, we keep</span>
<a href="#l11.805"></a><span id="l11.805" class="difflineplus">+     * returning Z_STREAM_END instead of Z_BUF_ERROR.</span>
<a href="#l11.806"></a><span id="l11.806" class="difflineplus">+     */</span>
<a href="#l11.807"></a><span id="l11.807" class="difflineplus">+    } else if (strm-&gt;avail_in == 0 &amp;&amp; RANK(flush) &lt;= RANK(old_flush) &amp;&amp;</span>
<a href="#l11.808"></a><span id="l11.808" class="difflineplus">+               flush != Z_FINISH) {</span>
<a href="#l11.809"></a><span id="l11.809" class="difflineplus">+        ERR_RETURN(strm, Z_BUF_ERROR);</span>
<a href="#l11.810"></a><span id="l11.810" class="difflineplus">+    }</span>
<a href="#l11.811"></a><span id="l11.811" class="difflineplus">+</span>
<a href="#l11.812"></a><span id="l11.812" class="difflineplus">+    /* User must not provide more input after the first FINISH: */</span>
<a href="#l11.813"></a><span id="l11.813" class="difflineplus">+    if (s-&gt;status == FINISH_STATE &amp;&amp; strm-&gt;avail_in != 0) {</span>
<a href="#l11.814"></a><span id="l11.814" class="difflineplus">+        ERR_RETURN(strm, Z_BUF_ERROR);</span>
<a href="#l11.815"></a><span id="l11.815" class="difflineplus">+    }</span>
<a href="#l11.816"></a><span id="l11.816" class="difflineplus">+</span>
<a href="#l11.817"></a><span id="l11.817" class="difflineplus">+    /* Write the header */</span>
<a href="#l11.818"></a><span id="l11.818" class="difflineplus">+    if (s-&gt;status == INIT_STATE) {</span>
<a href="#l11.819"></a><span id="l11.819" class="difflineplus">+        /* zlib header */</span>
<a href="#l11.820"></a><span id="l11.820" class="difflineplus">+        uInt header = (Z_DEFLATED + ((s-&gt;w_bits-8)&lt;&lt;4)) &lt;&lt; 8;</span>
<a href="#l11.821"></a><span id="l11.821" class="difflineplus">+        uInt level_flags;</span>
<a href="#l11.822"></a><span id="l11.822" class="difflineplus">+</span>
<a href="#l11.823"></a><span id="l11.823" class="difflineplus">+        if (s-&gt;strategy &gt;= Z_HUFFMAN_ONLY || s-&gt;level &lt; 2)</span>
<a href="#l11.824"></a><span id="l11.824" class="difflineplus">+            level_flags = 0;</span>
<a href="#l11.825"></a><span id="l11.825" class="difflineplus">+        else if (s-&gt;level &lt; 6)</span>
<a href="#l11.826"></a><span id="l11.826" class="difflineplus">+            level_flags = 1;</span>
<a href="#l11.827"></a><span id="l11.827" class="difflineplus">+        else if (s-&gt;level == 6)</span>
<a href="#l11.828"></a><span id="l11.828" class="difflineplus">+            level_flags = 2;</span>
<a href="#l11.829"></a><span id="l11.829" class="difflineplus">+        else</span>
<a href="#l11.830"></a><span id="l11.830" class="difflineplus">+            level_flags = 3;</span>
<a href="#l11.831"></a><span id="l11.831" class="difflineplus">+        header |= (level_flags &lt;&lt; 6);</span>
<a href="#l11.832"></a><span id="l11.832" class="difflineplus">+        if (s-&gt;strstart != 0) header |= PRESET_DICT;</span>
<a href="#l11.833"></a><span id="l11.833" class="difflineplus">+        header += 31 - (header % 31);</span>
<a href="#l11.834"></a><span id="l11.834" class="difflineplus">+</span>
<a href="#l11.835"></a><span id="l11.835" class="difflineplus">+        putShortMSB(s, header);</span>
<a href="#l11.836"></a><span id="l11.836" class="difflineplus">+</span>
<a href="#l11.837"></a><span id="l11.837" class="difflineplus">+        /* Save the adler32 of the preset dictionary: */</span>
<a href="#l11.838"></a><span id="l11.838" class="difflineplus">+        if (s-&gt;strstart != 0) {</span>
<a href="#l11.839"></a><span id="l11.839" class="difflineplus">+            putShortMSB(s, (uInt)(strm-&gt;adler &gt;&gt; 16));</span>
<a href="#l11.840"></a><span id="l11.840" class="difflineplus">+            putShortMSB(s, (uInt)(strm-&gt;adler &amp; 0xffff));</span>
<a href="#l11.841"></a><span id="l11.841" class="difflineplus">+        }</span>
<a href="#l11.842"></a><span id="l11.842" class="difflineplus">+        strm-&gt;adler = adler32(0L, Z_NULL, 0);</span>
<a href="#l11.843"></a><span id="l11.843" class="difflineplus">+        s-&gt;status = BUSY_STATE;</span>
<a href="#l11.844"></a><span id="l11.844" class="difflineplus">+</span>
<a href="#l11.845"></a><span id="l11.845" class="difflineplus">+        /* Compression must start with an empty pending buffer */</span>
<a href="#l11.846"></a><span id="l11.846" class="difflineplus">+        flush_pending(strm);</span>
<a href="#l11.847"></a><span id="l11.847" class="difflineplus">+        if (s-&gt;pending != 0) {</span>
<a href="#l11.848"></a><span id="l11.848" class="difflineplus">+            s-&gt;last_flush = -1;</span>
<a href="#l11.849"></a><span id="l11.849" class="difflineplus">+            return Z_OK;</span>
<a href="#l11.850"></a><span id="l11.850" class="difflineplus">+        }</span>
<a href="#l11.851"></a><span id="l11.851" class="difflineplus">+    }</span>
<a href="#l11.852"></a><span id="l11.852" class="difflineplus">+#ifdef GZIP</span>
<a href="#l11.853"></a><span id="l11.853" class="difflineplus">+    if (s-&gt;status == GZIP_STATE) {</span>
<a href="#l11.854"></a><span id="l11.854" class="difflineplus">+        /* gzip header */</span>
<a href="#l11.855"></a><span id="l11.855" class="difflineplus">+        strm-&gt;adler = crc32(0L, Z_NULL, 0);</span>
<a href="#l11.856"></a><span id="l11.856" class="difflineplus">+        put_byte(s, 31);</span>
<a href="#l11.857"></a><span id="l11.857" class="difflineplus">+        put_byte(s, 139);</span>
<a href="#l11.858"></a><span id="l11.858" class="difflineplus">+        put_byte(s, 8);</span>
<a href="#l11.859"></a><span id="l11.859" class="difflineplus">+        if (s-&gt;gzhead == Z_NULL) {</span>
<a href="#l11.860"></a><span id="l11.860" class="difflineplus">+            put_byte(s, 0);</span>
<a href="#l11.861"></a><span id="l11.861" class="difflineplus">+            put_byte(s, 0);</span>
<a href="#l11.862"></a><span id="l11.862" class="difflineplus">+            put_byte(s, 0);</span>
<a href="#l11.863"></a><span id="l11.863" class="difflineplus">+            put_byte(s, 0);</span>
<a href="#l11.864"></a><span id="l11.864" class="difflineplus">+            put_byte(s, 0);</span>
<a href="#l11.865"></a><span id="l11.865" class="difflineplus">+            put_byte(s, s-&gt;level == 9 ? 2 :</span>
<a href="#l11.866"></a><span id="l11.866" class="difflineplus">+                     (s-&gt;strategy &gt;= Z_HUFFMAN_ONLY || s-&gt;level &lt; 2 ?</span>
<a href="#l11.867"></a><span id="l11.867" class="difflineplus">+                      4 : 0));</span>
<a href="#l11.868"></a><span id="l11.868" class="difflineplus">+            put_byte(s, OS_CODE);</span>
<a href="#l11.869"></a><span id="l11.869" class="difflineplus">+            s-&gt;status = BUSY_STATE;</span>
<a href="#l11.870"></a><span id="l11.870" class="difflineplus">+</span>
<a href="#l11.871"></a><span id="l11.871" class="difflineplus">+            /* Compression must start with an empty pending buffer */</span>
<a href="#l11.872"></a><span id="l11.872" class="difflineplus">+            flush_pending(strm);</span>
<a href="#l11.873"></a><span id="l11.873" class="difflineplus">+            if (s-&gt;pending != 0) {</span>
<a href="#l11.874"></a><span id="l11.874" class="difflineplus">+                s-&gt;last_flush = -1;</span>
<a href="#l11.875"></a><span id="l11.875" class="difflineplus">+                return Z_OK;</span>
<a href="#l11.876"></a><span id="l11.876" class="difflineplus">+            }</span>
<a href="#l11.877"></a><span id="l11.877" class="difflineplus">+        }</span>
<a href="#l11.878"></a><span id="l11.878" class="difflineplus">+        else {</span>
<a href="#l11.879"></a><span id="l11.879" class="difflineplus">+            put_byte(s, (s-&gt;gzhead-&gt;text ? 1 : 0) +</span>
<a href="#l11.880"></a><span id="l11.880" class="difflineplus">+                     (s-&gt;gzhead-&gt;hcrc ? 2 : 0) +</span>
<a href="#l11.881"></a><span id="l11.881" class="difflineplus">+                     (s-&gt;gzhead-&gt;extra == Z_NULL ? 0 : 4) +</span>
<a href="#l11.882"></a><span id="l11.882" class="difflineplus">+                     (s-&gt;gzhead-&gt;name == Z_NULL ? 0 : 8) +</span>
<a href="#l11.883"></a><span id="l11.883" class="difflineplus">+                     (s-&gt;gzhead-&gt;comment == Z_NULL ? 0 : 16)</span>
<a href="#l11.884"></a><span id="l11.884" class="difflineplus">+                     );</span>
<a href="#l11.885"></a><span id="l11.885" class="difflineplus">+            put_byte(s, (Byte)(s-&gt;gzhead-&gt;time &amp; 0xff));</span>
<a href="#l11.886"></a><span id="l11.886" class="difflineplus">+            put_byte(s, (Byte)((s-&gt;gzhead-&gt;time &gt;&gt; 8) &amp; 0xff));</span>
<a href="#l11.887"></a><span id="l11.887" class="difflineplus">+            put_byte(s, (Byte)((s-&gt;gzhead-&gt;time &gt;&gt; 16) &amp; 0xff));</span>
<a href="#l11.888"></a><span id="l11.888" class="difflineplus">+            put_byte(s, (Byte)((s-&gt;gzhead-&gt;time &gt;&gt; 24) &amp; 0xff));</span>
<a href="#l11.889"></a><span id="l11.889" class="difflineplus">+            put_byte(s, s-&gt;level == 9 ? 2 :</span>
<a href="#l11.890"></a><span id="l11.890" class="difflineplus">+                     (s-&gt;strategy &gt;= Z_HUFFMAN_ONLY || s-&gt;level &lt; 2 ?</span>
<a href="#l11.891"></a><span id="l11.891" class="difflineplus">+                      4 : 0));</span>
<a href="#l11.892"></a><span id="l11.892" class="difflineplus">+            put_byte(s, s-&gt;gzhead-&gt;os &amp; 0xff);</span>
<a href="#l11.893"></a><span id="l11.893" class="difflineplus">+            if (s-&gt;gzhead-&gt;extra != Z_NULL) {</span>
<a href="#l11.894"></a><span id="l11.894" class="difflineplus">+                put_byte(s, s-&gt;gzhead-&gt;extra_len &amp; 0xff);</span>
<a href="#l11.895"></a><span id="l11.895" class="difflineplus">+                put_byte(s, (s-&gt;gzhead-&gt;extra_len &gt;&gt; 8) &amp; 0xff);</span>
<a href="#l11.896"></a><span id="l11.896" class="difflineplus">+            }</span>
<a href="#l11.897"></a><span id="l11.897" class="difflineplus">+            if (s-&gt;gzhead-&gt;hcrc)</span>
<a href="#l11.898"></a><span id="l11.898" class="difflineplus">+                strm-&gt;adler = crc32(strm-&gt;adler, s-&gt;pending_buf,</span>
<a href="#l11.899"></a><span id="l11.899" class="difflineplus">+                                    s-&gt;pending);</span>
<a href="#l11.900"></a><span id="l11.900" class="difflineplus">+            s-&gt;gzindex = 0;</span>
<a href="#l11.901"></a><span id="l11.901" class="difflineplus">+            s-&gt;status = EXTRA_STATE;</span>
<a href="#l11.902"></a><span id="l11.902" class="difflineplus">+        }</span>
<a href="#l11.903"></a><span id="l11.903" class="difflineplus">+    }</span>
<a href="#l11.904"></a><span id="l11.904" class="difflineplus">+    if (s-&gt;status == EXTRA_STATE) {</span>
<a href="#l11.905"></a><span id="l11.905" class="difflineplus">+        if (s-&gt;gzhead-&gt;extra != Z_NULL) {</span>
<a href="#l11.906"></a><span id="l11.906" class="difflineplus">+            ulg beg = s-&gt;pending;   /* start of bytes to update crc */</span>
<a href="#l11.907"></a><span id="l11.907" class="difflineplus">+            uInt left = (s-&gt;gzhead-&gt;extra_len &amp; 0xffff) - s-&gt;gzindex;</span>
<a href="#l11.908"></a><span id="l11.908" class="difflineplus">+            while (s-&gt;pending + left &gt; s-&gt;pending_buf_size) {</span>
<a href="#l11.909"></a><span id="l11.909" class="difflineplus">+                uInt copy = s-&gt;pending_buf_size - s-&gt;pending;</span>
<a href="#l11.910"></a><span id="l11.910" class="difflineplus">+                zmemcpy(s-&gt;pending_buf + s-&gt;pending,</span>
<a href="#l11.911"></a><span id="l11.911" class="difflineplus">+                        s-&gt;gzhead-&gt;extra + s-&gt;gzindex, copy);</span>
<a href="#l11.912"></a><span id="l11.912" class="difflineplus">+                s-&gt;pending = s-&gt;pending_buf_size;</span>
<a href="#l11.913"></a><span id="l11.913" class="difflineplus">+                HCRC_UPDATE(beg);</span>
<a href="#l11.914"></a><span id="l11.914" class="difflineplus">+                s-&gt;gzindex += copy;</span>
<a href="#l11.915"></a><span id="l11.915" class="difflineplus">+                flush_pending(strm);</span>
<a href="#l11.916"></a><span id="l11.916" class="difflineplus">+                if (s-&gt;pending != 0) {</span>
<a href="#l11.917"></a><span id="l11.917" class="difflineplus">+                    s-&gt;last_flush = -1;</span>
<a href="#l11.918"></a><span id="l11.918" class="difflineplus">+                    return Z_OK;</span>
<a href="#l11.919"></a><span id="l11.919" class="difflineplus">+                }</span>
<a href="#l11.920"></a><span id="l11.920" class="difflineplus">+                beg = 0;</span>
<a href="#l11.921"></a><span id="l11.921" class="difflineplus">+                left -= copy;</span>
<a href="#l11.922"></a><span id="l11.922" class="difflineplus">+            }</span>
<a href="#l11.923"></a><span id="l11.923" class="difflineplus">+            zmemcpy(s-&gt;pending_buf + s-&gt;pending,</span>
<a href="#l11.924"></a><span id="l11.924" class="difflineplus">+                    s-&gt;gzhead-&gt;extra + s-&gt;gzindex, left);</span>
<a href="#l11.925"></a><span id="l11.925" class="difflineplus">+            s-&gt;pending += left;</span>
<a href="#l11.926"></a><span id="l11.926" class="difflineplus">+            HCRC_UPDATE(beg);</span>
<a href="#l11.927"></a><span id="l11.927" class="difflineplus">+            s-&gt;gzindex = 0;</span>
<a href="#l11.928"></a><span id="l11.928" class="difflineplus">+        }</span>
<a href="#l11.929"></a><span id="l11.929" class="difflineplus">+        s-&gt;status = NAME_STATE;</span>
<a href="#l11.930"></a><span id="l11.930" class="difflineplus">+    }</span>
<a href="#l11.931"></a><span id="l11.931" class="difflineplus">+    if (s-&gt;status == NAME_STATE) {</span>
<a href="#l11.932"></a><span id="l11.932" class="difflineplus">+        if (s-&gt;gzhead-&gt;name != Z_NULL) {</span>
<a href="#l11.933"></a><span id="l11.933" class="difflineplus">+            ulg beg = s-&gt;pending;   /* start of bytes to update crc */</span>
<a href="#l11.934"></a><span id="l11.934" class="difflineplus">+            int val;</span>
<a href="#l11.935"></a><span id="l11.935" class="difflineplus">+            do {</span>
<a href="#l11.936"></a><span id="l11.936" class="difflineplus">+                if (s-&gt;pending == s-&gt;pending_buf_size) {</span>
<a href="#l11.937"></a><span id="l11.937" class="difflineplus">+                    HCRC_UPDATE(beg);</span>
<a href="#l11.938"></a><span id="l11.938" class="difflineplus">+                    flush_pending(strm);</span>
<a href="#l11.939"></a><span id="l11.939" class="difflineplus">+                    if (s-&gt;pending != 0) {</span>
<a href="#l11.940"></a><span id="l11.940" class="difflineplus">+                        s-&gt;last_flush = -1;</span>
<a href="#l11.941"></a><span id="l11.941" class="difflineplus">+                        return Z_OK;</span>
<a href="#l11.942"></a><span id="l11.942" class="difflineplus">+                    }</span>
<a href="#l11.943"></a><span id="l11.943" class="difflineplus">+                    beg = 0;</span>
<a href="#l11.944"></a><span id="l11.944" class="difflineplus">+                }</span>
<a href="#l11.945"></a><span id="l11.945" class="difflineplus">+                val = s-&gt;gzhead-&gt;name[s-&gt;gzindex++];</span>
<a href="#l11.946"></a><span id="l11.946" class="difflineplus">+                put_byte(s, val);</span>
<a href="#l11.947"></a><span id="l11.947" class="difflineplus">+            } while (val != 0);</span>
<a href="#l11.948"></a><span id="l11.948" class="difflineplus">+            HCRC_UPDATE(beg);</span>
<a href="#l11.949"></a><span id="l11.949" class="difflineplus">+            s-&gt;gzindex = 0;</span>
<a href="#l11.950"></a><span id="l11.950" class="difflineplus">+        }</span>
<a href="#l11.951"></a><span id="l11.951" class="difflineplus">+        s-&gt;status = COMMENT_STATE;</span>
<a href="#l11.952"></a><span id="l11.952" class="difflineplus">+    }</span>
<a href="#l11.953"></a><span id="l11.953" class="difflineplus">+    if (s-&gt;status == COMMENT_STATE) {</span>
<a href="#l11.954"></a><span id="l11.954" class="difflineplus">+        if (s-&gt;gzhead-&gt;comment != Z_NULL) {</span>
<a href="#l11.955"></a><span id="l11.955" class="difflineplus">+            ulg beg = s-&gt;pending;   /* start of bytes to update crc */</span>
<a href="#l11.956"></a><span id="l11.956" class="difflineplus">+            int val;</span>
<a href="#l11.957"></a><span id="l11.957" class="difflineplus">+            do {</span>
<a href="#l11.958"></a><span id="l11.958" class="difflineplus">+                if (s-&gt;pending == s-&gt;pending_buf_size) {</span>
<a href="#l11.959"></a><span id="l11.959" class="difflineplus">+                    HCRC_UPDATE(beg);</span>
<a href="#l11.960"></a><span id="l11.960" class="difflineplus">+                    flush_pending(strm);</span>
<a href="#l11.961"></a><span id="l11.961" class="difflineplus">+                    if (s-&gt;pending != 0) {</span>
<a href="#l11.962"></a><span id="l11.962" class="difflineplus">+                        s-&gt;last_flush = -1;</span>
<a href="#l11.963"></a><span id="l11.963" class="difflineplus">+                        return Z_OK;</span>
<a href="#l11.964"></a><span id="l11.964" class="difflineplus">+                    }</span>
<a href="#l11.965"></a><span id="l11.965" class="difflineplus">+                    beg = 0;</span>
<a href="#l11.966"></a><span id="l11.966" class="difflineplus">+                }</span>
<a href="#l11.967"></a><span id="l11.967" class="difflineplus">+                val = s-&gt;gzhead-&gt;comment[s-&gt;gzindex++];</span>
<a href="#l11.968"></a><span id="l11.968" class="difflineplus">+                put_byte(s, val);</span>
<a href="#l11.969"></a><span id="l11.969" class="difflineplus">+            } while (val != 0);</span>
<a href="#l11.970"></a><span id="l11.970" class="difflineplus">+            HCRC_UPDATE(beg);</span>
<a href="#l11.971"></a><span id="l11.971" class="difflineplus">+        }</span>
<a href="#l11.972"></a><span id="l11.972" class="difflineplus">+        s-&gt;status = HCRC_STATE;</span>
<a href="#l11.973"></a><span id="l11.973" class="difflineplus">+    }</span>
<a href="#l11.974"></a><span id="l11.974" class="difflineplus">+    if (s-&gt;status == HCRC_STATE) {</span>
<a href="#l11.975"></a><span id="l11.975" class="difflineplus">+        if (s-&gt;gzhead-&gt;hcrc) {</span>
<a href="#l11.976"></a><span id="l11.976" class="difflineplus">+            if (s-&gt;pending + 2 &gt; s-&gt;pending_buf_size) {</span>
<a href="#l11.977"></a><span id="l11.977" class="difflineplus">+                flush_pending(strm);</span>
<a href="#l11.978"></a><span id="l11.978" class="difflineplus">+                if (s-&gt;pending != 0) {</span>
<a href="#l11.979"></a><span id="l11.979" class="difflineplus">+                    s-&gt;last_flush = -1;</span>
<a href="#l11.980"></a><span id="l11.980" class="difflineplus">+                    return Z_OK;</span>
<a href="#l11.981"></a><span id="l11.981" class="difflineplus">+                }</span>
<a href="#l11.982"></a><span id="l11.982" class="difflineplus">+            }</span>
<a href="#l11.983"></a><span id="l11.983" class="difflineplus">+            put_byte(s, (Byte)(strm-&gt;adler &amp; 0xff));</span>
<a href="#l11.984"></a><span id="l11.984" class="difflineplus">+            put_byte(s, (Byte)((strm-&gt;adler &gt;&gt; 8) &amp; 0xff));</span>
<a href="#l11.985"></a><span id="l11.985" class="difflineplus">+            strm-&gt;adler = crc32(0L, Z_NULL, 0);</span>
<a href="#l11.986"></a><span id="l11.986" class="difflineplus">+        }</span>
<a href="#l11.987"></a><span id="l11.987" class="difflineplus">+        s-&gt;status = BUSY_STATE;</span>
<a href="#l11.988"></a><span id="l11.988" class="difflineplus">+</span>
<a href="#l11.989"></a><span id="l11.989" class="difflineplus">+        /* Compression must start with an empty pending buffer */</span>
<a href="#l11.990"></a><span id="l11.990" class="difflineplus">+        flush_pending(strm);</span>
<a href="#l11.991"></a><span id="l11.991" class="difflineplus">+        if (s-&gt;pending != 0) {</span>
<a href="#l11.992"></a><span id="l11.992" class="difflineplus">+            s-&gt;last_flush = -1;</span>
<a href="#l11.993"></a><span id="l11.993" class="difflineplus">+            return Z_OK;</span>
<a href="#l11.994"></a><span id="l11.994" class="difflineplus">+        }</span>
<a href="#l11.995"></a><span id="l11.995" class="difflineplus">+    }</span>
<a href="#l11.996"></a><span id="l11.996" class="difflineplus">+#endif</span>
<a href="#l11.997"></a><span id="l11.997" class="difflineplus">+</span>
<a href="#l11.998"></a><span id="l11.998" class="difflineplus">+    /* Start a new block or continue the current one.</span>
<a href="#l11.999"></a><span id="l11.999" class="difflineplus">+     */</span>
<a href="#l11.1000"></a><span id="l11.1000" class="difflineplus">+    if (strm-&gt;avail_in != 0 || s-&gt;lookahead != 0 ||</span>
<a href="#l11.1001"></a><span id="l11.1001" class="difflineplus">+        (flush != Z_NO_FLUSH &amp;&amp; s-&gt;status != FINISH_STATE)) {</span>
<a href="#l11.1002"></a><span id="l11.1002" class="difflineplus">+        block_state bstate;</span>
<a href="#l11.1003"></a><span id="l11.1003" class="difflineplus">+</span>
<a href="#l11.1004"></a><span id="l11.1004" class="difflineplus">+        bstate = s-&gt;level == 0 ? deflate_stored(s, flush) :</span>
<a href="#l11.1005"></a><span id="l11.1005" class="difflineplus">+                 s-&gt;strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :</span>
<a href="#l11.1006"></a><span id="l11.1006" class="difflineplus">+                 s-&gt;strategy == Z_RLE ? deflate_rle(s, flush) :</span>
<a href="#l11.1007"></a><span id="l11.1007" class="difflineplus">+                 (*(configuration_table[s-&gt;level].func))(s, flush);</span>
<a href="#l11.1008"></a><span id="l11.1008" class="difflineplus">+</span>
<a href="#l11.1009"></a><span id="l11.1009" class="difflineplus">+        if (bstate == finish_started || bstate == finish_done) {</span>
<a href="#l11.1010"></a><span id="l11.1010" class="difflineplus">+            s-&gt;status = FINISH_STATE;</span>
<a href="#l11.1011"></a><span id="l11.1011" class="difflineplus">+        }</span>
<a href="#l11.1012"></a><span id="l11.1012" class="difflineplus">+        if (bstate == need_more || bstate == finish_started) {</span>
<a href="#l11.1013"></a><span id="l11.1013" class="difflineplus">+            if (strm-&gt;avail_out == 0) {</span>
<a href="#l11.1014"></a><span id="l11.1014" class="difflineplus">+                s-&gt;last_flush = -1; /* avoid BUF_ERROR next call, see above */</span>
<a href="#l11.1015"></a><span id="l11.1015" class="difflineplus">+            }</span>
<a href="#l11.1016"></a><span id="l11.1016" class="difflineplus">+            return Z_OK;</span>
<a href="#l11.1017"></a><span id="l11.1017" class="difflineplus">+            /* If flush != Z_NO_FLUSH &amp;&amp; avail_out == 0, the next call</span>
<a href="#l11.1018"></a><span id="l11.1018" class="difflineplus">+             * of deflate should use the same flush parameter to make sure</span>
<a href="#l11.1019"></a><span id="l11.1019" class="difflineplus">+             * that the flush is complete. So we don't have to output an</span>
<a href="#l11.1020"></a><span id="l11.1020" class="difflineplus">+             * empty block here, this will be done at next call. This also</span>
<a href="#l11.1021"></a><span id="l11.1021" class="difflineplus">+             * ensures that for a very small output buffer, we emit at most</span>
<a href="#l11.1022"></a><span id="l11.1022" class="difflineplus">+             * one empty block.</span>
<a href="#l11.1023"></a><span id="l11.1023" class="difflineplus">+             */</span>
<a href="#l11.1024"></a><span id="l11.1024" class="difflineplus">+        }</span>
<a href="#l11.1025"></a><span id="l11.1025" class="difflineplus">+        if (bstate == block_done) {</span>
<a href="#l11.1026"></a><span id="l11.1026" class="difflineplus">+            if (flush == Z_PARTIAL_FLUSH) {</span>
<a href="#l11.1027"></a><span id="l11.1027" class="difflineplus">+                _tr_align(s);</span>
<a href="#l11.1028"></a><span id="l11.1028" class="difflineplus">+            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */</span>
<a href="#l11.1029"></a><span id="l11.1029" class="difflineplus">+                _tr_stored_block(s, (char*)0, 0L, 0);</span>
<a href="#l11.1030"></a><span id="l11.1030" class="difflineplus">+                /* For a full flush, this empty block will be recognized</span>
<a href="#l11.1031"></a><span id="l11.1031" class="difflineplus">+                 * as a special marker by inflate_sync().</span>
<a href="#l11.1032"></a><span id="l11.1032" class="difflineplus">+                 */</span>
<a href="#l11.1033"></a><span id="l11.1033" class="difflineplus">+                if (flush == Z_FULL_FLUSH) {</span>
<a href="#l11.1034"></a><span id="l11.1034" class="difflineplus">+                    CLEAR_HASH(s);             /* forget history */</span>
<a href="#l11.1035"></a><span id="l11.1035" class="difflineplus">+                    if (s-&gt;lookahead == 0) {</span>
<a href="#l11.1036"></a><span id="l11.1036" class="difflineplus">+                        s-&gt;strstart = 0;</span>
<a href="#l11.1037"></a><span id="l11.1037" class="difflineplus">+                        s-&gt;block_start = 0L;</span>
<a href="#l11.1038"></a><span id="l11.1038" class="difflineplus">+                        s-&gt;insert = 0;</span>
<a href="#l11.1039"></a><span id="l11.1039" class="difflineplus">+                    }</span>
<a href="#l11.1040"></a><span id="l11.1040" class="difflineplus">+                }</span>
<a href="#l11.1041"></a><span id="l11.1041" class="difflineplus">+            }</span>
<a href="#l11.1042"></a><span id="l11.1042" class="difflineplus">+            flush_pending(strm);</span>
<a href="#l11.1043"></a><span id="l11.1043" class="difflineplus">+            if (strm-&gt;avail_out == 0) {</span>
<a href="#l11.1044"></a><span id="l11.1044" class="difflineplus">+              s-&gt;last_flush = -1; /* avoid BUF_ERROR at next call, see above */</span>
<a href="#l11.1045"></a><span id="l11.1045" class="difflineplus">+              return Z_OK;</span>
<a href="#l11.1046"></a><span id="l11.1046" class="difflineplus">+            }</span>
<a href="#l11.1047"></a><span id="l11.1047" class="difflineplus">+        }</span>
<a href="#l11.1048"></a><span id="l11.1048" class="difflineplus">+    }</span>
<a href="#l11.1049"></a><span id="l11.1049" class="difflineplus">+</span>
<a href="#l11.1050"></a><span id="l11.1050" class="difflineplus">+    if (flush != Z_FINISH) return Z_OK;</span>
<a href="#l11.1051"></a><span id="l11.1051" class="difflineplus">+    if (s-&gt;wrap &lt;= 0) return Z_STREAM_END;</span>
<a href="#l11.1052"></a><span id="l11.1052" class="difflineplus">+</span>
<a href="#l11.1053"></a><span id="l11.1053" class="difflineplus">+    /* Write the trailer */</span>
<a href="#l11.1054"></a><span id="l11.1054" class="difflineplus">+#ifdef GZIP</span>
<a href="#l11.1055"></a><span id="l11.1055" class="difflineplus">+    if (s-&gt;wrap == 2) {</span>
<a href="#l11.1056"></a><span id="l11.1056" class="difflineplus">+        put_byte(s, (Byte)(strm-&gt;adler &amp; 0xff));</span>
<a href="#l11.1057"></a><span id="l11.1057" class="difflineplus">+        put_byte(s, (Byte)((strm-&gt;adler &gt;&gt; 8) &amp; 0xff));</span>
<a href="#l11.1058"></a><span id="l11.1058" class="difflineplus">+        put_byte(s, (Byte)((strm-&gt;adler &gt;&gt; 16) &amp; 0xff));</span>
<a href="#l11.1059"></a><span id="l11.1059" class="difflineplus">+        put_byte(s, (Byte)((strm-&gt;adler &gt;&gt; 24) &amp; 0xff));</span>
<a href="#l11.1060"></a><span id="l11.1060" class="difflineplus">+        put_byte(s, (Byte)(strm-&gt;total_in &amp; 0xff));</span>
<a href="#l11.1061"></a><span id="l11.1061" class="difflineplus">+        put_byte(s, (Byte)((strm-&gt;total_in &gt;&gt; 8) &amp; 0xff));</span>
<a href="#l11.1062"></a><span id="l11.1062" class="difflineplus">+        put_byte(s, (Byte)((strm-&gt;total_in &gt;&gt; 16) &amp; 0xff));</span>
<a href="#l11.1063"></a><span id="l11.1063" class="difflineplus">+        put_byte(s, (Byte)((strm-&gt;total_in &gt;&gt; 24) &amp; 0xff));</span>
<a href="#l11.1064"></a><span id="l11.1064" class="difflineplus">+    }</span>
<a href="#l11.1065"></a><span id="l11.1065" class="difflineplus">+    else</span>
<a href="#l11.1066"></a><span id="l11.1066" class="difflineplus">+#endif</span>
<a href="#l11.1067"></a><span id="l11.1067" class="difflineplus">+    {</span>
<a href="#l11.1068"></a><span id="l11.1068" class="difflineplus">+        putShortMSB(s, (uInt)(strm-&gt;adler &gt;&gt; 16));</span>
<a href="#l11.1069"></a><span id="l11.1069" class="difflineplus">+        putShortMSB(s, (uInt)(strm-&gt;adler &amp; 0xffff));</span>
<a href="#l11.1070"></a><span id="l11.1070" class="difflineplus">+    }</span>
<a href="#l11.1071"></a><span id="l11.1071" class="difflineplus">+    flush_pending(strm);</span>
<a href="#l11.1072"></a><span id="l11.1072" class="difflineplus">+    /* If avail_out is zero, the application will call deflate again</span>
<a href="#l11.1073"></a><span id="l11.1073" class="difflineplus">+     * to flush the rest.</span>
<a href="#l11.1074"></a><span id="l11.1074" class="difflineplus">+     */</span>
<a href="#l11.1075"></a><span id="l11.1075" class="difflineplus">+    if (s-&gt;wrap &gt; 0) s-&gt;wrap = -s-&gt;wrap; /* write the trailer only once! */</span>
<a href="#l11.1076"></a><span id="l11.1076" class="difflineplus">+    return s-&gt;pending != 0 ? Z_OK : Z_STREAM_END;</span>
<a href="#l11.1077"></a><span id="l11.1077" class="difflineplus">+}</span>
<a href="#l11.1078"></a><span id="l11.1078" class="difflineplus">+</span>
<a href="#l11.1079"></a><span id="l11.1079" class="difflineplus">+/* ========================================================================= */</span>
<a href="#l11.1080"></a><span id="l11.1080" class="difflineplus">+int ZEXPORT deflateEnd (strm)</span>
<a href="#l11.1081"></a><span id="l11.1081" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.1082"></a><span id="l11.1082" class="difflineplus">+{</span>
<a href="#l11.1083"></a><span id="l11.1083" class="difflineplus">+    int status;</span>
<a href="#l11.1084"></a><span id="l11.1084" class="difflineplus">+</span>
<a href="#l11.1085"></a><span id="l11.1085" class="difflineplus">+    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l11.1086"></a><span id="l11.1086" class="difflineplus">+</span>
<a href="#l11.1087"></a><span id="l11.1087" class="difflineplus">+    status = strm-&gt;state-&gt;status;</span>
<a href="#l11.1088"></a><span id="l11.1088" class="difflineplus">+</span>
<a href="#l11.1089"></a><span id="l11.1089" class="difflineplus">+    /* Deallocate in reverse order of allocations: */</span>
<a href="#l11.1090"></a><span id="l11.1090" class="difflineplus">+    TRY_FREE(strm, strm-&gt;state-&gt;pending_buf);</span>
<a href="#l11.1091"></a><span id="l11.1091" class="difflineplus">+    TRY_FREE(strm, strm-&gt;state-&gt;head);</span>
<a href="#l11.1092"></a><span id="l11.1092" class="difflineplus">+    TRY_FREE(strm, strm-&gt;state-&gt;prev);</span>
<a href="#l11.1093"></a><span id="l11.1093" class="difflineplus">+    TRY_FREE(strm, strm-&gt;state-&gt;window);</span>
<a href="#l11.1094"></a><span id="l11.1094" class="difflineplus">+</span>
<a href="#l11.1095"></a><span id="l11.1095" class="difflineplus">+    ZFREE(strm, strm-&gt;state);</span>
<a href="#l11.1096"></a><span id="l11.1096" class="difflineplus">+    strm-&gt;state = Z_NULL;</span>
<a href="#l11.1097"></a><span id="l11.1097" class="difflineplus">+</span>
<a href="#l11.1098"></a><span id="l11.1098" class="difflineplus">+    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;</span>
<a href="#l11.1099"></a><span id="l11.1099" class="difflineplus">+}</span>
<a href="#l11.1100"></a><span id="l11.1100" class="difflineplus">+</span>
<a href="#l11.1101"></a><span id="l11.1101" class="difflineplus">+/* =========================================================================</span>
<a href="#l11.1102"></a><span id="l11.1102" class="difflineplus">+ * Copy the source state to the destination state.</span>
<a href="#l11.1103"></a><span id="l11.1103" class="difflineplus">+ * To simplify the source, this is not supported for 16-bit MSDOS (which</span>
<a href="#l11.1104"></a><span id="l11.1104" class="difflineplus">+ * doesn't have enough memory anyway to duplicate compression states).</span>
<a href="#l11.1105"></a><span id="l11.1105" class="difflineplus">+ */</span>
<a href="#l11.1106"></a><span id="l11.1106" class="difflineplus">+int ZEXPORT deflateCopy (dest, source)</span>
<a href="#l11.1107"></a><span id="l11.1107" class="difflineplus">+    z_streamp dest;</span>
<a href="#l11.1108"></a><span id="l11.1108" class="difflineplus">+    z_streamp source;</span>
<a href="#l11.1109"></a><span id="l11.1109" class="difflineplus">+{</span>
<a href="#l11.1110"></a><span id="l11.1110" class="difflineplus">+#ifdef MAXSEG_64K</span>
<a href="#l11.1111"></a><span id="l11.1111" class="difflineplus">+    return Z_STREAM_ERROR;</span>
<a href="#l11.1112"></a><span id="l11.1112" class="difflineplus">+#else</span>
<a href="#l11.1113"></a><span id="l11.1113" class="difflineplus">+    deflate_state *ds;</span>
<a href="#l11.1114"></a><span id="l11.1114" class="difflineplus">+    deflate_state *ss;</span>
<a href="#l11.1115"></a><span id="l11.1115" class="difflineplus">+    ushf *overlay;</span>
<a href="#l11.1116"></a><span id="l11.1116" class="difflineplus">+</span>
<a href="#l11.1117"></a><span id="l11.1117" class="difflineplus">+</span>
<a href="#l11.1118"></a><span id="l11.1118" class="difflineplus">+    if (deflateStateCheck(source) || dest == Z_NULL) {</span>
<a href="#l11.1119"></a><span id="l11.1119" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l11.1120"></a><span id="l11.1120" class="difflineplus">+    }</span>
<a href="#l11.1121"></a><span id="l11.1121" class="difflineplus">+</span>
<a href="#l11.1122"></a><span id="l11.1122" class="difflineplus">+    ss = source-&gt;state;</span>
<a href="#l11.1123"></a><span id="l11.1123" class="difflineplus">+</span>
<a href="#l11.1124"></a><span id="l11.1124" class="difflineplus">+    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));</span>
<a href="#l11.1125"></a><span id="l11.1125" class="difflineplus">+</span>
<a href="#l11.1126"></a><span id="l11.1126" class="difflineplus">+    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));</span>
<a href="#l11.1127"></a><span id="l11.1127" class="difflineplus">+    if (ds == Z_NULL) return Z_MEM_ERROR;</span>
<a href="#l11.1128"></a><span id="l11.1128" class="difflineplus">+    dest-&gt;state = (struct internal_state FAR *) ds;</span>
<a href="#l11.1129"></a><span id="l11.1129" class="difflineplus">+    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));</span>
<a href="#l11.1130"></a><span id="l11.1130" class="difflineplus">+    ds-&gt;strm = dest;</span>
<a href="#l11.1131"></a><span id="l11.1131" class="difflineplus">+</span>
<a href="#l11.1132"></a><span id="l11.1132" class="difflineplus">+    ds-&gt;window = (Bytef *) ZALLOC(dest, ds-&gt;w_size, 2*sizeof(Byte));</span>
<a href="#l11.1133"></a><span id="l11.1133" class="difflineplus">+    ds-&gt;prev   = (Posf *)  ZALLOC(dest, ds-&gt;w_size, sizeof(Pos));</span>
<a href="#l11.1134"></a><span id="l11.1134" class="difflineplus">+    ds-&gt;head   = (Posf *)  ZALLOC(dest, ds-&gt;hash_size, sizeof(Pos));</span>
<a href="#l11.1135"></a><span id="l11.1135" class="difflineplus">+    overlay = (ushf *) ZALLOC(dest, ds-&gt;lit_bufsize, sizeof(ush)+2);</span>
<a href="#l11.1136"></a><span id="l11.1136" class="difflineplus">+    ds-&gt;pending_buf = (uchf *) overlay;</span>
<a href="#l11.1137"></a><span id="l11.1137" class="difflineplus">+</span>
<a href="#l11.1138"></a><span id="l11.1138" class="difflineplus">+    if (ds-&gt;window == Z_NULL || ds-&gt;prev == Z_NULL || ds-&gt;head == Z_NULL ||</span>
<a href="#l11.1139"></a><span id="l11.1139" class="difflineplus">+        ds-&gt;pending_buf == Z_NULL) {</span>
<a href="#l11.1140"></a><span id="l11.1140" class="difflineplus">+        deflateEnd (dest);</span>
<a href="#l11.1141"></a><span id="l11.1141" class="difflineplus">+        return Z_MEM_ERROR;</span>
<a href="#l11.1142"></a><span id="l11.1142" class="difflineplus">+    }</span>
<a href="#l11.1143"></a><span id="l11.1143" class="difflineplus">+    /* following zmemcpy do not work for 16-bit MSDOS */</span>
<a href="#l11.1144"></a><span id="l11.1144" class="difflineplus">+    zmemcpy(ds-&gt;window, ss-&gt;window, ds-&gt;w_size * 2 * sizeof(Byte));</span>
<a href="#l11.1145"></a><span id="l11.1145" class="difflineplus">+    zmemcpy((voidpf)ds-&gt;prev, (voidpf)ss-&gt;prev, ds-&gt;w_size * sizeof(Pos));</span>
<a href="#l11.1146"></a><span id="l11.1146" class="difflineplus">+    zmemcpy((voidpf)ds-&gt;head, (voidpf)ss-&gt;head, ds-&gt;hash_size * sizeof(Pos));</span>
<a href="#l11.1147"></a><span id="l11.1147" class="difflineplus">+    zmemcpy(ds-&gt;pending_buf, ss-&gt;pending_buf, (uInt)ds-&gt;pending_buf_size);</span>
<a href="#l11.1148"></a><span id="l11.1148" class="difflineplus">+</span>
<a href="#l11.1149"></a><span id="l11.1149" class="difflineplus">+    ds-&gt;pending_out = ds-&gt;pending_buf + (ss-&gt;pending_out - ss-&gt;pending_buf);</span>
<a href="#l11.1150"></a><span id="l11.1150" class="difflineplus">+    ds-&gt;d_buf = overlay + ds-&gt;lit_bufsize/sizeof(ush);</span>
<a href="#l11.1151"></a><span id="l11.1151" class="difflineplus">+    ds-&gt;l_buf = ds-&gt;pending_buf + (1+sizeof(ush))*ds-&gt;lit_bufsize;</span>
<a href="#l11.1152"></a><span id="l11.1152" class="difflineplus">+</span>
<a href="#l11.1153"></a><span id="l11.1153" class="difflineplus">+    ds-&gt;l_desc.dyn_tree = ds-&gt;dyn_ltree;</span>
<a href="#l11.1154"></a><span id="l11.1154" class="difflineplus">+    ds-&gt;d_desc.dyn_tree = ds-&gt;dyn_dtree;</span>
<a href="#l11.1155"></a><span id="l11.1155" class="difflineplus">+    ds-&gt;bl_desc.dyn_tree = ds-&gt;bl_tree;</span>
<a href="#l11.1156"></a><span id="l11.1156" class="difflineplus">+</span>
<a href="#l11.1157"></a><span id="l11.1157" class="difflineplus">+    return Z_OK;</span>
<a href="#l11.1158"></a><span id="l11.1158" class="difflineplus">+#endif /* MAXSEG_64K */</span>
<a href="#l11.1159"></a><span id="l11.1159" class="difflineplus">+}</span>
<a href="#l11.1160"></a><span id="l11.1160" class="difflineplus">+</span>
<a href="#l11.1161"></a><span id="l11.1161" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.1162"></a><span id="l11.1162" class="difflineplus">+ * Read a new buffer from the current input stream, update the adler32</span>
<a href="#l11.1163"></a><span id="l11.1163" class="difflineplus">+ * and total number of bytes read.  All deflate() input goes through</span>
<a href="#l11.1164"></a><span id="l11.1164" class="difflineplus">+ * this function so some applications may wish to modify it to avoid</span>
<a href="#l11.1165"></a><span id="l11.1165" class="difflineplus">+ * allocating a large strm-&gt;next_in buffer and copying from it.</span>
<a href="#l11.1166"></a><span id="l11.1166" class="difflineplus">+ * (See also flush_pending()).</span>
<a href="#l11.1167"></a><span id="l11.1167" class="difflineplus">+ */</span>
<a href="#l11.1168"></a><span id="l11.1168" class="difflineplus">+local unsigned read_buf(strm, buf, size)</span>
<a href="#l11.1169"></a><span id="l11.1169" class="difflineplus">+    z_streamp strm;</span>
<a href="#l11.1170"></a><span id="l11.1170" class="difflineplus">+    Bytef *buf;</span>
<a href="#l11.1171"></a><span id="l11.1171" class="difflineplus">+    unsigned size;</span>
<a href="#l11.1172"></a><span id="l11.1172" class="difflineplus">+{</span>
<a href="#l11.1173"></a><span id="l11.1173" class="difflineplus">+    unsigned len = strm-&gt;avail_in;</span>
<a href="#l11.1174"></a><span id="l11.1174" class="difflineplus">+</span>
<a href="#l11.1175"></a><span id="l11.1175" class="difflineplus">+    if (len &gt; size) len = size;</span>
<a href="#l11.1176"></a><span id="l11.1176" class="difflineplus">+    if (len == 0) return 0;</span>
<a href="#l11.1177"></a><span id="l11.1177" class="difflineplus">+</span>
<a href="#l11.1178"></a><span id="l11.1178" class="difflineplus">+    strm-&gt;avail_in  -= len;</span>
<a href="#l11.1179"></a><span id="l11.1179" class="difflineplus">+</span>
<a href="#l11.1180"></a><span id="l11.1180" class="difflineplus">+    zmemcpy(buf, strm-&gt;next_in, len);</span>
<a href="#l11.1181"></a><span id="l11.1181" class="difflineplus">+    if (strm-&gt;state-&gt;wrap == 1) {</span>
<a href="#l11.1182"></a><span id="l11.1182" class="difflineplus">+        strm-&gt;adler = adler32(strm-&gt;adler, buf, len);</span>
<a href="#l11.1183"></a><span id="l11.1183" class="difflineplus">+    }</span>
<a href="#l11.1184"></a><span id="l11.1184" class="difflineplus">+#ifdef GZIP</span>
<a href="#l11.1185"></a><span id="l11.1185" class="difflineplus">+    else if (strm-&gt;state-&gt;wrap == 2) {</span>
<a href="#l11.1186"></a><span id="l11.1186" class="difflineplus">+        strm-&gt;adler = crc32(strm-&gt;adler, buf, len);</span>
<a href="#l11.1187"></a><span id="l11.1187" class="difflineplus">+    }</span>
<a href="#l11.1188"></a><span id="l11.1188" class="difflineplus">+#endif</span>
<a href="#l11.1189"></a><span id="l11.1189" class="difflineplus">+    strm-&gt;next_in  += len;</span>
<a href="#l11.1190"></a><span id="l11.1190" class="difflineplus">+    strm-&gt;total_in += len;</span>
<a href="#l11.1191"></a><span id="l11.1191" class="difflineplus">+</span>
<a href="#l11.1192"></a><span id="l11.1192" class="difflineplus">+    return len;</span>
<a href="#l11.1193"></a><span id="l11.1193" class="difflineplus">+}</span>
<a href="#l11.1194"></a><span id="l11.1194" class="difflineplus">+</span>
<a href="#l11.1195"></a><span id="l11.1195" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.1196"></a><span id="l11.1196" class="difflineplus">+ * Initialize the &quot;longest match&quot; routines for a new zlib stream</span>
<a href="#l11.1197"></a><span id="l11.1197" class="difflineplus">+ */</span>
<a href="#l11.1198"></a><span id="l11.1198" class="difflineplus">+local void lm_init (s)</span>
<a href="#l11.1199"></a><span id="l11.1199" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.1200"></a><span id="l11.1200" class="difflineplus">+{</span>
<a href="#l11.1201"></a><span id="l11.1201" class="difflineplus">+    s-&gt;window_size = (ulg)2L*s-&gt;w_size;</span>
<a href="#l11.1202"></a><span id="l11.1202" class="difflineplus">+</span>
<a href="#l11.1203"></a><span id="l11.1203" class="difflineplus">+    CLEAR_HASH(s);</span>
<a href="#l11.1204"></a><span id="l11.1204" class="difflineplus">+</span>
<a href="#l11.1205"></a><span id="l11.1205" class="difflineplus">+    /* Set the default configuration parameters:</span>
<a href="#l11.1206"></a><span id="l11.1206" class="difflineplus">+     */</span>
<a href="#l11.1207"></a><span id="l11.1207" class="difflineplus">+    s-&gt;max_lazy_match   = configuration_table[s-&gt;level].max_lazy;</span>
<a href="#l11.1208"></a><span id="l11.1208" class="difflineplus">+    s-&gt;good_match       = configuration_table[s-&gt;level].good_length;</span>
<a href="#l11.1209"></a><span id="l11.1209" class="difflineplus">+    s-&gt;nice_match       = configuration_table[s-&gt;level].nice_length;</span>
<a href="#l11.1210"></a><span id="l11.1210" class="difflineplus">+    s-&gt;max_chain_length = configuration_table[s-&gt;level].max_chain;</span>
<a href="#l11.1211"></a><span id="l11.1211" class="difflineplus">+</span>
<a href="#l11.1212"></a><span id="l11.1212" class="difflineplus">+    s-&gt;strstart = 0;</span>
<a href="#l11.1213"></a><span id="l11.1213" class="difflineplus">+    s-&gt;block_start = 0L;</span>
<a href="#l11.1214"></a><span id="l11.1214" class="difflineplus">+    s-&gt;lookahead = 0;</span>
<a href="#l11.1215"></a><span id="l11.1215" class="difflineplus">+    s-&gt;insert = 0;</span>
<a href="#l11.1216"></a><span id="l11.1216" class="difflineplus">+    s-&gt;match_length = s-&gt;prev_length = MIN_MATCH-1;</span>
<a href="#l11.1217"></a><span id="l11.1217" class="difflineplus">+    s-&gt;match_available = 0;</span>
<a href="#l11.1218"></a><span id="l11.1218" class="difflineplus">+    s-&gt;ins_h = 0;</span>
<a href="#l11.1219"></a><span id="l11.1219" class="difflineplus">+#ifndef FASTEST</span>
<a href="#l11.1220"></a><span id="l11.1220" class="difflineplus">+#ifdef ASMV</span>
<a href="#l11.1221"></a><span id="l11.1221" class="difflineplus">+    match_init(); /* initialize the asm code */</span>
<a href="#l11.1222"></a><span id="l11.1222" class="difflineplus">+#endif</span>
<a href="#l11.1223"></a><span id="l11.1223" class="difflineplus">+#endif</span>
<a href="#l11.1224"></a><span id="l11.1224" class="difflineplus">+}</span>
<a href="#l11.1225"></a><span id="l11.1225" class="difflineplus">+</span>
<a href="#l11.1226"></a><span id="l11.1226" class="difflineplus">+#ifndef FASTEST</span>
<a href="#l11.1227"></a><span id="l11.1227" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.1228"></a><span id="l11.1228" class="difflineplus">+ * Set match_start to the longest match starting at the given string and</span>
<a href="#l11.1229"></a><span id="l11.1229" class="difflineplus">+ * return its length. Matches shorter or equal to prev_length are discarded,</span>
<a href="#l11.1230"></a><span id="l11.1230" class="difflineplus">+ * in which case the result is equal to prev_length and match_start is</span>
<a href="#l11.1231"></a><span id="l11.1231" class="difflineplus">+ * garbage.</span>
<a href="#l11.1232"></a><span id="l11.1232" class="difflineplus">+ * IN assertions: cur_match is the head of the hash chain for the current</span>
<a href="#l11.1233"></a><span id="l11.1233" class="difflineplus">+ *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length &gt;= 1</span>
<a href="#l11.1234"></a><span id="l11.1234" class="difflineplus">+ * OUT assertion: the match length is not greater than s-&gt;lookahead.</span>
<a href="#l11.1235"></a><span id="l11.1235" class="difflineplus">+ */</span>
<a href="#l11.1236"></a><span id="l11.1236" class="difflineplus">+#ifndef ASMV</span>
<a href="#l11.1237"></a><span id="l11.1237" class="difflineplus">+/* For 80x86 and 680x0, an optimized version will be provided in match.asm or</span>
<a href="#l11.1238"></a><span id="l11.1238" class="difflineplus">+ * match.S. The code will be functionally equivalent.</span>
<a href="#l11.1239"></a><span id="l11.1239" class="difflineplus">+ */</span>
<a href="#l11.1240"></a><span id="l11.1240" class="difflineplus">+local uInt longest_match(s, cur_match)</span>
<a href="#l11.1241"></a><span id="l11.1241" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.1242"></a><span id="l11.1242" class="difflineplus">+    IPos cur_match;                             /* current match */</span>
<a href="#l11.1243"></a><span id="l11.1243" class="difflineplus">+{</span>
<a href="#l11.1244"></a><span id="l11.1244" class="difflineplus">+    unsigned chain_length = s-&gt;max_chain_length;/* max hash chain length */</span>
<a href="#l11.1245"></a><span id="l11.1245" class="difflineplus">+    register Bytef *scan = s-&gt;window + s-&gt;strstart; /* current string */</span>
<a href="#l11.1246"></a><span id="l11.1246" class="difflineplus">+    register Bytef *match;                      /* matched string */</span>
<a href="#l11.1247"></a><span id="l11.1247" class="difflineplus">+    register int len;                           /* length of current match */</span>
<a href="#l11.1248"></a><span id="l11.1248" class="difflineplus">+    int best_len = (int)s-&gt;prev_length;         /* best match length so far */</span>
<a href="#l11.1249"></a><span id="l11.1249" class="difflineplus">+    int nice_match = s-&gt;nice_match;             /* stop if match long enough */</span>
<a href="#l11.1250"></a><span id="l11.1250" class="difflineplus">+    IPos limit = s-&gt;strstart &gt; (IPos)MAX_DIST(s) ?</span>
<a href="#l11.1251"></a><span id="l11.1251" class="difflineplus">+        s-&gt;strstart - (IPos)MAX_DIST(s) : NIL;</span>
<a href="#l11.1252"></a><span id="l11.1252" class="difflineplus">+    /* Stop when cur_match becomes &lt;= limit. To simplify the code,</span>
<a href="#l11.1253"></a><span id="l11.1253" class="difflineplus">+     * we prevent matches with the string of window index 0.</span>
<a href="#l11.1254"></a><span id="l11.1254" class="difflineplus">+     */</span>
<a href="#l11.1255"></a><span id="l11.1255" class="difflineplus">+    Posf *prev = s-&gt;prev;</span>
<a href="#l11.1256"></a><span id="l11.1256" class="difflineplus">+    uInt wmask = s-&gt;w_mask;</span>
<a href="#l11.1257"></a><span id="l11.1257" class="difflineplus">+</span>
<a href="#l11.1258"></a><span id="l11.1258" class="difflineplus">+#ifdef UNALIGNED_OK</span>
<a href="#l11.1259"></a><span id="l11.1259" class="difflineplus">+    /* Compare two bytes at a time. Note: this is not always beneficial.</span>
<a href="#l11.1260"></a><span id="l11.1260" class="difflineplus">+     * Try with and without -DUNALIGNED_OK to check.</span>
<a href="#l11.1261"></a><span id="l11.1261" class="difflineplus">+     */</span>
<a href="#l11.1262"></a><span id="l11.1262" class="difflineplus">+    register Bytef *strend = s-&gt;window + s-&gt;strstart + MAX_MATCH - 1;</span>
<a href="#l11.1263"></a><span id="l11.1263" class="difflineplus">+    register ush scan_start = *(ushf*)scan;</span>
<a href="#l11.1264"></a><span id="l11.1264" class="difflineplus">+    register ush scan_end   = *(ushf*)(scan+best_len-1);</span>
<a href="#l11.1265"></a><span id="l11.1265" class="difflineplus">+#else</span>
<a href="#l11.1266"></a><span id="l11.1266" class="difflineplus">+    register Bytef *strend = s-&gt;window + s-&gt;strstart + MAX_MATCH;</span>
<a href="#l11.1267"></a><span id="l11.1267" class="difflineplus">+    register Byte scan_end1  = scan[best_len-1];</span>
<a href="#l11.1268"></a><span id="l11.1268" class="difflineplus">+    register Byte scan_end   = scan[best_len];</span>
<a href="#l11.1269"></a><span id="l11.1269" class="difflineplus">+#endif</span>
<a href="#l11.1270"></a><span id="l11.1270" class="difflineplus">+</span>
<a href="#l11.1271"></a><span id="l11.1271" class="difflineplus">+    /* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.</span>
<a href="#l11.1272"></a><span id="l11.1272" class="difflineplus">+     * It is easy to get rid of this optimization if necessary.</span>
<a href="#l11.1273"></a><span id="l11.1273" class="difflineplus">+     */</span>
<a href="#l11.1274"></a><span id="l11.1274" class="difflineplus">+    Assert(s-&gt;hash_bits &gt;= 8 &amp;&amp; MAX_MATCH == 258, &quot;Code too clever&quot;);</span>
<a href="#l11.1275"></a><span id="l11.1275" class="difflineplus">+</span>
<a href="#l11.1276"></a><span id="l11.1276" class="difflineplus">+    /* Do not waste too much time if we already have a good match: */</span>
<a href="#l11.1277"></a><span id="l11.1277" class="difflineplus">+    if (s-&gt;prev_length &gt;= s-&gt;good_match) {</span>
<a href="#l11.1278"></a><span id="l11.1278" class="difflineplus">+        chain_length &gt;&gt;= 2;</span>
<a href="#l11.1279"></a><span id="l11.1279" class="difflineplus">+    }</span>
<a href="#l11.1280"></a><span id="l11.1280" class="difflineplus">+    /* Do not look for matches beyond the end of the input. This is necessary</span>
<a href="#l11.1281"></a><span id="l11.1281" class="difflineplus">+     * to make deflate deterministic.</span>
<a href="#l11.1282"></a><span id="l11.1282" class="difflineplus">+     */</span>
<a href="#l11.1283"></a><span id="l11.1283" class="difflineplus">+    if ((uInt)nice_match &gt; s-&gt;lookahead) nice_match = (int)s-&gt;lookahead;</span>
<a href="#l11.1284"></a><span id="l11.1284" class="difflineplus">+</span>
<a href="#l11.1285"></a><span id="l11.1285" class="difflineplus">+    Assert((ulg)s-&gt;strstart &lt;= s-&gt;window_size-MIN_LOOKAHEAD, &quot;need lookahead&quot;);</span>
<a href="#l11.1286"></a><span id="l11.1286" class="difflineplus">+</span>
<a href="#l11.1287"></a><span id="l11.1287" class="difflineplus">+    do {</span>
<a href="#l11.1288"></a><span id="l11.1288" class="difflineplus">+        Assert(cur_match &lt; s-&gt;strstart, &quot;no future&quot;);</span>
<a href="#l11.1289"></a><span id="l11.1289" class="difflineplus">+        match = s-&gt;window + cur_match;</span>
<a href="#l11.1290"></a><span id="l11.1290" class="difflineplus">+</span>
<a href="#l11.1291"></a><span id="l11.1291" class="difflineplus">+        /* Skip to next match if the match length cannot increase</span>
<a href="#l11.1292"></a><span id="l11.1292" class="difflineplus">+         * or if the match length is less than 2.  Note that the checks below</span>
<a href="#l11.1293"></a><span id="l11.1293" class="difflineplus">+         * for insufficient lookahead only occur occasionally for performance</span>
<a href="#l11.1294"></a><span id="l11.1294" class="difflineplus">+         * reasons.  Therefore uninitialized memory will be accessed, and</span>
<a href="#l11.1295"></a><span id="l11.1295" class="difflineplus">+         * conditional jumps will be made that depend on those values.</span>
<a href="#l11.1296"></a><span id="l11.1296" class="difflineplus">+         * However the length of the match is limited to the lookahead, so</span>
<a href="#l11.1297"></a><span id="l11.1297" class="difflineplus">+         * the output of deflate is not affected by the uninitialized values.</span>
<a href="#l11.1298"></a><span id="l11.1298" class="difflineplus">+         */</span>
<a href="#l11.1299"></a><span id="l11.1299" class="difflineplus">+#if (defined(UNALIGNED_OK) &amp;&amp; MAX_MATCH == 258)</span>
<a href="#l11.1300"></a><span id="l11.1300" class="difflineplus">+        /* This code assumes sizeof(unsigned short) == 2. Do not use</span>
<a href="#l11.1301"></a><span id="l11.1301" class="difflineplus">+         * UNALIGNED_OK if your compiler uses a different size.</span>
<a href="#l11.1302"></a><span id="l11.1302" class="difflineplus">+         */</span>
<a href="#l11.1303"></a><span id="l11.1303" class="difflineplus">+        if (*(ushf*)(match+best_len-1) != scan_end ||</span>
<a href="#l11.1304"></a><span id="l11.1304" class="difflineplus">+            *(ushf*)match != scan_start) continue;</span>
<a href="#l11.1305"></a><span id="l11.1305" class="difflineplus">+</span>
<a href="#l11.1306"></a><span id="l11.1306" class="difflineplus">+        /* It is not necessary to compare scan[2] and match[2] since they are</span>
<a href="#l11.1307"></a><span id="l11.1307" class="difflineplus">+         * always equal when the other bytes match, given that the hash keys</span>
<a href="#l11.1308"></a><span id="l11.1308" class="difflineplus">+         * are equal and that HASH_BITS &gt;= 8. Compare 2 bytes at a time at</span>
<a href="#l11.1309"></a><span id="l11.1309" class="difflineplus">+         * strstart+3, +5, ... up to strstart+257. We check for insufficient</span>
<a href="#l11.1310"></a><span id="l11.1310" class="difflineplus">+         * lookahead only every 4th comparison; the 128th check will be made</span>
<a href="#l11.1311"></a><span id="l11.1311" class="difflineplus">+         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is</span>
<a href="#l11.1312"></a><span id="l11.1312" class="difflineplus">+         * necessary to put more guard bytes at the end of the window, or</span>
<a href="#l11.1313"></a><span id="l11.1313" class="difflineplus">+         * to check more often for insufficient lookahead.</span>
<a href="#l11.1314"></a><span id="l11.1314" class="difflineplus">+         */</span>
<a href="#l11.1315"></a><span id="l11.1315" class="difflineplus">+        Assert(scan[2] == match[2], &quot;scan[2]?&quot;);</span>
<a href="#l11.1316"></a><span id="l11.1316" class="difflineplus">+        scan++, match++;</span>
<a href="#l11.1317"></a><span id="l11.1317" class="difflineplus">+        do {</span>
<a href="#l11.1318"></a><span id="l11.1318" class="difflineplus">+        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &amp;&amp;</span>
<a href="#l11.1319"></a><span id="l11.1319" class="difflineplus">+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &amp;&amp;</span>
<a href="#l11.1320"></a><span id="l11.1320" class="difflineplus">+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &amp;&amp;</span>
<a href="#l11.1321"></a><span id="l11.1321" class="difflineplus">+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &amp;&amp;</span>
<a href="#l11.1322"></a><span id="l11.1322" class="difflineplus">+                 scan &lt; strend);</span>
<a href="#l11.1323"></a><span id="l11.1323" class="difflineplus">+        /* The funny &quot;do {}&quot; generates better code on most compilers */</span>
<a href="#l11.1324"></a><span id="l11.1324" class="difflineplus">+</span>
<a href="#l11.1325"></a><span id="l11.1325" class="difflineplus">+        /* Here, scan &lt;= window+strstart+257 */</span>
<a href="#l11.1326"></a><span id="l11.1326" class="difflineplus">+        Assert(scan &lt;= s-&gt;window+(unsigned)(s-&gt;window_size-1), &quot;wild scan&quot;);</span>
<a href="#l11.1327"></a><span id="l11.1327" class="difflineplus">+        if (*scan == *match) scan++;</span>
<a href="#l11.1328"></a><span id="l11.1328" class="difflineplus">+</span>
<a href="#l11.1329"></a><span id="l11.1329" class="difflineplus">+        len = (MAX_MATCH - 1) - (int)(strend-scan);</span>
<a href="#l11.1330"></a><span id="l11.1330" class="difflineplus">+        scan = strend - (MAX_MATCH-1);</span>
<a href="#l11.1331"></a><span id="l11.1331" class="difflineplus">+</span>
<a href="#l11.1332"></a><span id="l11.1332" class="difflineplus">+#else /* UNALIGNED_OK */</span>
<a href="#l11.1333"></a><span id="l11.1333" class="difflineplus">+</span>
<a href="#l11.1334"></a><span id="l11.1334" class="difflineplus">+        if (match[best_len]   != scan_end  ||</span>
<a href="#l11.1335"></a><span id="l11.1335" class="difflineplus">+            match[best_len-1] != scan_end1 ||</span>
<a href="#l11.1336"></a><span id="l11.1336" class="difflineplus">+            *match            != *scan     ||</span>
<a href="#l11.1337"></a><span id="l11.1337" class="difflineplus">+            *++match          != scan[1])      continue;</span>
<a href="#l11.1338"></a><span id="l11.1338" class="difflineplus">+</span>
<a href="#l11.1339"></a><span id="l11.1339" class="difflineplus">+        /* The check at best_len-1 can be removed because it will be made</span>
<a href="#l11.1340"></a><span id="l11.1340" class="difflineplus">+         * again later. (This heuristic is not always a win.)</span>
<a href="#l11.1341"></a><span id="l11.1341" class="difflineplus">+         * It is not necessary to compare scan[2] and match[2] since they</span>
<a href="#l11.1342"></a><span id="l11.1342" class="difflineplus">+         * are always equal when the other bytes match, given that</span>
<a href="#l11.1343"></a><span id="l11.1343" class="difflineplus">+         * the hash keys are equal and that HASH_BITS &gt;= 8.</span>
<a href="#l11.1344"></a><span id="l11.1344" class="difflineplus">+         */</span>
<a href="#l11.1345"></a><span id="l11.1345" class="difflineplus">+        scan += 2, match++;</span>
<a href="#l11.1346"></a><span id="l11.1346" class="difflineplus">+        Assert(*scan == *match, &quot;match[2]?&quot;);</span>
<a href="#l11.1347"></a><span id="l11.1347" class="difflineplus">+</span>
<a href="#l11.1348"></a><span id="l11.1348" class="difflineplus">+        /* We check for insufficient lookahead only every 8th comparison;</span>
<a href="#l11.1349"></a><span id="l11.1349" class="difflineplus">+         * the 256th check will be made at strstart+258.</span>
<a href="#l11.1350"></a><span id="l11.1350" class="difflineplus">+         */</span>
<a href="#l11.1351"></a><span id="l11.1351" class="difflineplus">+        do {</span>
<a href="#l11.1352"></a><span id="l11.1352" class="difflineplus">+        } while (*++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;</span>
<a href="#l11.1353"></a><span id="l11.1353" class="difflineplus">+                 *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;</span>
<a href="#l11.1354"></a><span id="l11.1354" class="difflineplus">+                 *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;</span>
<a href="#l11.1355"></a><span id="l11.1355" class="difflineplus">+                 *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;</span>
<a href="#l11.1356"></a><span id="l11.1356" class="difflineplus">+                 scan &lt; strend);</span>
<a href="#l11.1357"></a><span id="l11.1357" class="difflineplus">+</span>
<a href="#l11.1358"></a><span id="l11.1358" class="difflineplus">+        Assert(scan &lt;= s-&gt;window+(unsigned)(s-&gt;window_size-1), &quot;wild scan&quot;);</span>
<a href="#l11.1359"></a><span id="l11.1359" class="difflineplus">+</span>
<a href="#l11.1360"></a><span id="l11.1360" class="difflineplus">+        len = MAX_MATCH - (int)(strend - scan);</span>
<a href="#l11.1361"></a><span id="l11.1361" class="difflineplus">+        scan = strend - MAX_MATCH;</span>
<a href="#l11.1362"></a><span id="l11.1362" class="difflineplus">+</span>
<a href="#l11.1363"></a><span id="l11.1363" class="difflineplus">+#endif /* UNALIGNED_OK */</span>
<a href="#l11.1364"></a><span id="l11.1364" class="difflineplus">+</span>
<a href="#l11.1365"></a><span id="l11.1365" class="difflineplus">+        if (len &gt; best_len) {</span>
<a href="#l11.1366"></a><span id="l11.1366" class="difflineplus">+            s-&gt;match_start = cur_match;</span>
<a href="#l11.1367"></a><span id="l11.1367" class="difflineplus">+            best_len = len;</span>
<a href="#l11.1368"></a><span id="l11.1368" class="difflineplus">+            if (len &gt;= nice_match) break;</span>
<a href="#l11.1369"></a><span id="l11.1369" class="difflineplus">+#ifdef UNALIGNED_OK</span>
<a href="#l11.1370"></a><span id="l11.1370" class="difflineplus">+            scan_end = *(ushf*)(scan+best_len-1);</span>
<a href="#l11.1371"></a><span id="l11.1371" class="difflineplus">+#else</span>
<a href="#l11.1372"></a><span id="l11.1372" class="difflineplus">+            scan_end1  = scan[best_len-1];</span>
<a href="#l11.1373"></a><span id="l11.1373" class="difflineplus">+            scan_end   = scan[best_len];</span>
<a href="#l11.1374"></a><span id="l11.1374" class="difflineplus">+#endif</span>
<a href="#l11.1375"></a><span id="l11.1375" class="difflineplus">+        }</span>
<a href="#l11.1376"></a><span id="l11.1376" class="difflineplus">+    } while ((cur_match = prev[cur_match &amp; wmask]) &gt; limit</span>
<a href="#l11.1377"></a><span id="l11.1377" class="difflineplus">+             &amp;&amp; --chain_length != 0);</span>
<a href="#l11.1378"></a><span id="l11.1378" class="difflineplus">+</span>
<a href="#l11.1379"></a><span id="l11.1379" class="difflineplus">+    if ((uInt)best_len &lt;= s-&gt;lookahead) return (uInt)best_len;</span>
<a href="#l11.1380"></a><span id="l11.1380" class="difflineplus">+    return s-&gt;lookahead;</span>
<a href="#l11.1381"></a><span id="l11.1381" class="difflineplus">+}</span>
<a href="#l11.1382"></a><span id="l11.1382" class="difflineplus">+#endif /* ASMV */</span>
<a href="#l11.1383"></a><span id="l11.1383" class="difflineplus">+</span>
<a href="#l11.1384"></a><span id="l11.1384" class="difflineplus">+#else /* FASTEST */</span>
<a href="#l11.1385"></a><span id="l11.1385" class="difflineplus">+</span>
<a href="#l11.1386"></a><span id="l11.1386" class="difflineplus">+/* ---------------------------------------------------------------------------</span>
<a href="#l11.1387"></a><span id="l11.1387" class="difflineplus">+ * Optimized version for FASTEST only</span>
<a href="#l11.1388"></a><span id="l11.1388" class="difflineplus">+ */</span>
<a href="#l11.1389"></a><span id="l11.1389" class="difflineplus">+local uInt longest_match(s, cur_match)</span>
<a href="#l11.1390"></a><span id="l11.1390" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.1391"></a><span id="l11.1391" class="difflineplus">+    IPos cur_match;                             /* current match */</span>
<a href="#l11.1392"></a><span id="l11.1392" class="difflineplus">+{</span>
<a href="#l11.1393"></a><span id="l11.1393" class="difflineplus">+    register Bytef *scan = s-&gt;window + s-&gt;strstart; /* current string */</span>
<a href="#l11.1394"></a><span id="l11.1394" class="difflineplus">+    register Bytef *match;                       /* matched string */</span>
<a href="#l11.1395"></a><span id="l11.1395" class="difflineplus">+    register int len;                           /* length of current match */</span>
<a href="#l11.1396"></a><span id="l11.1396" class="difflineplus">+    register Bytef *strend = s-&gt;window + s-&gt;strstart + MAX_MATCH;</span>
<a href="#l11.1397"></a><span id="l11.1397" class="difflineplus">+</span>
<a href="#l11.1398"></a><span id="l11.1398" class="difflineplus">+    /* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.</span>
<a href="#l11.1399"></a><span id="l11.1399" class="difflineplus">+     * It is easy to get rid of this optimization if necessary.</span>
<a href="#l11.1400"></a><span id="l11.1400" class="difflineplus">+     */</span>
<a href="#l11.1401"></a><span id="l11.1401" class="difflineplus">+    Assert(s-&gt;hash_bits &gt;= 8 &amp;&amp; MAX_MATCH == 258, &quot;Code too clever&quot;);</span>
<a href="#l11.1402"></a><span id="l11.1402" class="difflineplus">+</span>
<a href="#l11.1403"></a><span id="l11.1403" class="difflineplus">+    Assert((ulg)s-&gt;strstart &lt;= s-&gt;window_size-MIN_LOOKAHEAD, &quot;need lookahead&quot;);</span>
<a href="#l11.1404"></a><span id="l11.1404" class="difflineplus">+</span>
<a href="#l11.1405"></a><span id="l11.1405" class="difflineplus">+    Assert(cur_match &lt; s-&gt;strstart, &quot;no future&quot;);</span>
<a href="#l11.1406"></a><span id="l11.1406" class="difflineplus">+</span>
<a href="#l11.1407"></a><span id="l11.1407" class="difflineplus">+    match = s-&gt;window + cur_match;</span>
<a href="#l11.1408"></a><span id="l11.1408" class="difflineplus">+</span>
<a href="#l11.1409"></a><span id="l11.1409" class="difflineplus">+    /* Return failure if the match length is less than 2:</span>
<a href="#l11.1410"></a><span id="l11.1410" class="difflineplus">+     */</span>
<a href="#l11.1411"></a><span id="l11.1411" class="difflineplus">+    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;</span>
<a href="#l11.1412"></a><span id="l11.1412" class="difflineplus">+</span>
<a href="#l11.1413"></a><span id="l11.1413" class="difflineplus">+    /* The check at best_len-1 can be removed because it will be made</span>
<a href="#l11.1414"></a><span id="l11.1414" class="difflineplus">+     * again later. (This heuristic is not always a win.)</span>
<a href="#l11.1415"></a><span id="l11.1415" class="difflineplus">+     * It is not necessary to compare scan[2] and match[2] since they</span>
<a href="#l11.1416"></a><span id="l11.1416" class="difflineplus">+     * are always equal when the other bytes match, given that</span>
<a href="#l11.1417"></a><span id="l11.1417" class="difflineplus">+     * the hash keys are equal and that HASH_BITS &gt;= 8.</span>
<a href="#l11.1418"></a><span id="l11.1418" class="difflineplus">+     */</span>
<a href="#l11.1419"></a><span id="l11.1419" class="difflineplus">+    scan += 2, match += 2;</span>
<a href="#l11.1420"></a><span id="l11.1420" class="difflineplus">+    Assert(*scan == *match, &quot;match[2]?&quot;);</span>
<a href="#l11.1421"></a><span id="l11.1421" class="difflineplus">+</span>
<a href="#l11.1422"></a><span id="l11.1422" class="difflineplus">+    /* We check for insufficient lookahead only every 8th comparison;</span>
<a href="#l11.1423"></a><span id="l11.1423" class="difflineplus">+     * the 256th check will be made at strstart+258.</span>
<a href="#l11.1424"></a><span id="l11.1424" class="difflineplus">+     */</span>
<a href="#l11.1425"></a><span id="l11.1425" class="difflineplus">+    do {</span>
<a href="#l11.1426"></a><span id="l11.1426" class="difflineplus">+    } while (*++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;</span>
<a href="#l11.1427"></a><span id="l11.1427" class="difflineplus">+             *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;</span>
<a href="#l11.1428"></a><span id="l11.1428" class="difflineplus">+             *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;</span>
<a href="#l11.1429"></a><span id="l11.1429" class="difflineplus">+             *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;</span>
<a href="#l11.1430"></a><span id="l11.1430" class="difflineplus">+             scan &lt; strend);</span>
<a href="#l11.1431"></a><span id="l11.1431" class="difflineplus">+</span>
<a href="#l11.1432"></a><span id="l11.1432" class="difflineplus">+    Assert(scan &lt;= s-&gt;window+(unsigned)(s-&gt;window_size-1), &quot;wild scan&quot;);</span>
<a href="#l11.1433"></a><span id="l11.1433" class="difflineplus">+</span>
<a href="#l11.1434"></a><span id="l11.1434" class="difflineplus">+    len = MAX_MATCH - (int)(strend - scan);</span>
<a href="#l11.1435"></a><span id="l11.1435" class="difflineplus">+</span>
<a href="#l11.1436"></a><span id="l11.1436" class="difflineplus">+    if (len &lt; MIN_MATCH) return MIN_MATCH - 1;</span>
<a href="#l11.1437"></a><span id="l11.1437" class="difflineplus">+</span>
<a href="#l11.1438"></a><span id="l11.1438" class="difflineplus">+    s-&gt;match_start = cur_match;</span>
<a href="#l11.1439"></a><span id="l11.1439" class="difflineplus">+    return (uInt)len &lt;= s-&gt;lookahead ? (uInt)len : s-&gt;lookahead;</span>
<a href="#l11.1440"></a><span id="l11.1440" class="difflineplus">+}</span>
<a href="#l11.1441"></a><span id="l11.1441" class="difflineplus">+</span>
<a href="#l11.1442"></a><span id="l11.1442" class="difflineplus">+#endif /* FASTEST */</span>
<a href="#l11.1443"></a><span id="l11.1443" class="difflineplus">+</span>
<a href="#l11.1444"></a><span id="l11.1444" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l11.1445"></a><span id="l11.1445" class="difflineplus">+</span>
<a href="#l11.1446"></a><span id="l11.1446" class="difflineplus">+#define EQUAL 0</span>
<a href="#l11.1447"></a><span id="l11.1447" class="difflineplus">+/* result of memcmp for equal strings */</span>
<a href="#l11.1448"></a><span id="l11.1448" class="difflineplus">+</span>
<a href="#l11.1449"></a><span id="l11.1449" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.1450"></a><span id="l11.1450" class="difflineplus">+ * Check that the match at match_start is indeed a match.</span>
<a href="#l11.1451"></a><span id="l11.1451" class="difflineplus">+ */</span>
<a href="#l11.1452"></a><span id="l11.1452" class="difflineplus">+local void check_match(s, start, match, length)</span>
<a href="#l11.1453"></a><span id="l11.1453" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.1454"></a><span id="l11.1454" class="difflineplus">+    IPos start, match;</span>
<a href="#l11.1455"></a><span id="l11.1455" class="difflineplus">+    int length;</span>
<a href="#l11.1456"></a><span id="l11.1456" class="difflineplus">+{</span>
<a href="#l11.1457"></a><span id="l11.1457" class="difflineplus">+    /* check that the match is indeed a match */</span>
<a href="#l11.1458"></a><span id="l11.1458" class="difflineplus">+    if (zmemcmp(s-&gt;window + match,</span>
<a href="#l11.1459"></a><span id="l11.1459" class="difflineplus">+                s-&gt;window + start, length) != EQUAL) {</span>
<a href="#l11.1460"></a><span id="l11.1460" class="difflineplus">+        fprintf(stderr, &quot; start %u, match %u, length %d\n&quot;,</span>
<a href="#l11.1461"></a><span id="l11.1461" class="difflineplus">+                start, match, length);</span>
<a href="#l11.1462"></a><span id="l11.1462" class="difflineplus">+        do {</span>
<a href="#l11.1463"></a><span id="l11.1463" class="difflineplus">+            fprintf(stderr, &quot;%c%c&quot;, s-&gt;window[match++], s-&gt;window[start++]);</span>
<a href="#l11.1464"></a><span id="l11.1464" class="difflineplus">+        } while (--length != 0);</span>
<a href="#l11.1465"></a><span id="l11.1465" class="difflineplus">+        z_error(&quot;invalid match&quot;);</span>
<a href="#l11.1466"></a><span id="l11.1466" class="difflineplus">+    }</span>
<a href="#l11.1467"></a><span id="l11.1467" class="difflineplus">+    if (z_verbose &gt; 1) {</span>
<a href="#l11.1468"></a><span id="l11.1468" class="difflineplus">+        fprintf(stderr,&quot;\\[%d,%d]&quot;, start-match, length);</span>
<a href="#l11.1469"></a><span id="l11.1469" class="difflineplus">+        do { putc(s-&gt;window[start++], stderr); } while (--length != 0);</span>
<a href="#l11.1470"></a><span id="l11.1470" class="difflineplus">+    }</span>
<a href="#l11.1471"></a><span id="l11.1471" class="difflineplus">+}</span>
<a href="#l11.1472"></a><span id="l11.1472" class="difflineplus">+#else</span>
<a href="#l11.1473"></a><span id="l11.1473" class="difflineplus">+#  define check_match(s, start, match, length)</span>
<a href="#l11.1474"></a><span id="l11.1474" class="difflineplus">+#endif /* ZLIB_DEBUG */</span>
<a href="#l11.1475"></a><span id="l11.1475" class="difflineplus">+</span>
<a href="#l11.1476"></a><span id="l11.1476" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.1477"></a><span id="l11.1477" class="difflineplus">+ * Fill the window when the lookahead becomes insufficient.</span>
<a href="#l11.1478"></a><span id="l11.1478" class="difflineplus">+ * Updates strstart and lookahead.</span>
<a href="#l11.1479"></a><span id="l11.1479" class="difflineplus">+ *</span>
<a href="#l11.1480"></a><span id="l11.1480" class="difflineplus">+ * IN assertion: lookahead &lt; MIN_LOOKAHEAD</span>
<a href="#l11.1481"></a><span id="l11.1481" class="difflineplus">+ * OUT assertions: strstart &lt;= window_size-MIN_LOOKAHEAD</span>
<a href="#l11.1482"></a><span id="l11.1482" class="difflineplus">+ *    At least one byte has been read, or avail_in == 0; reads are</span>
<a href="#l11.1483"></a><span id="l11.1483" class="difflineplus">+ *    performed for at least two bytes (required for the zip translate_eol</span>
<a href="#l11.1484"></a><span id="l11.1484" class="difflineplus">+ *    option -- not supported here).</span>
<a href="#l11.1485"></a><span id="l11.1485" class="difflineplus">+ */</span>
<a href="#l11.1486"></a><span id="l11.1486" class="difflineplus">+local void fill_window(s)</span>
<a href="#l11.1487"></a><span id="l11.1487" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.1488"></a><span id="l11.1488" class="difflineplus">+{</span>
<a href="#l11.1489"></a><span id="l11.1489" class="difflineplus">+    unsigned n;</span>
<a href="#l11.1490"></a><span id="l11.1490" class="difflineplus">+    unsigned more;    /* Amount of free space at the end of the window. */</span>
<a href="#l11.1491"></a><span id="l11.1491" class="difflineplus">+    uInt wsize = s-&gt;w_size;</span>
<a href="#l11.1492"></a><span id="l11.1492" class="difflineplus">+</span>
<a href="#l11.1493"></a><span id="l11.1493" class="difflineplus">+    Assert(s-&gt;lookahead &lt; MIN_LOOKAHEAD, &quot;already enough lookahead&quot;);</span>
<a href="#l11.1494"></a><span id="l11.1494" class="difflineplus">+</span>
<a href="#l11.1495"></a><span id="l11.1495" class="difflineplus">+    do {</span>
<a href="#l11.1496"></a><span id="l11.1496" class="difflineplus">+        more = (unsigned)(s-&gt;window_size -(ulg)s-&gt;lookahead -(ulg)s-&gt;strstart);</span>
<a href="#l11.1497"></a><span id="l11.1497" class="difflineplus">+</span>
<a href="#l11.1498"></a><span id="l11.1498" class="difflineplus">+        /* Deal with !@#$% 64K limit: */</span>
<a href="#l11.1499"></a><span id="l11.1499" class="difflineplus">+        if (sizeof(int) &lt;= 2) {</span>
<a href="#l11.1500"></a><span id="l11.1500" class="difflineplus">+            if (more == 0 &amp;&amp; s-&gt;strstart == 0 &amp;&amp; s-&gt;lookahead == 0) {</span>
<a href="#l11.1501"></a><span id="l11.1501" class="difflineplus">+                more = wsize;</span>
<a href="#l11.1502"></a><span id="l11.1502" class="difflineplus">+</span>
<a href="#l11.1503"></a><span id="l11.1503" class="difflineplus">+            } else if (more == (unsigned)(-1)) {</span>
<a href="#l11.1504"></a><span id="l11.1504" class="difflineplus">+                /* Very unlikely, but possible on 16 bit machine if</span>
<a href="#l11.1505"></a><span id="l11.1505" class="difflineplus">+                 * strstart == 0 &amp;&amp; lookahead == 1 (input done a byte at time)</span>
<a href="#l11.1506"></a><span id="l11.1506" class="difflineplus">+                 */</span>
<a href="#l11.1507"></a><span id="l11.1507" class="difflineplus">+                more--;</span>
<a href="#l11.1508"></a><span id="l11.1508" class="difflineplus">+            }</span>
<a href="#l11.1509"></a><span id="l11.1509" class="difflineplus">+        }</span>
<a href="#l11.1510"></a><span id="l11.1510" class="difflineplus">+</span>
<a href="#l11.1511"></a><span id="l11.1511" class="difflineplus">+        /* If the window is almost full and there is insufficient lookahead,</span>
<a href="#l11.1512"></a><span id="l11.1512" class="difflineplus">+         * move the upper half to the lower one to make room in the upper half.</span>
<a href="#l11.1513"></a><span id="l11.1513" class="difflineplus">+         */</span>
<a href="#l11.1514"></a><span id="l11.1514" class="difflineplus">+        if (s-&gt;strstart &gt;= wsize+MAX_DIST(s)) {</span>
<a href="#l11.1515"></a><span id="l11.1515" class="difflineplus">+</span>
<a href="#l11.1516"></a><span id="l11.1516" class="difflineplus">+            zmemcpy(s-&gt;window, s-&gt;window+wsize, (unsigned)wsize - more);</span>
<a href="#l11.1517"></a><span id="l11.1517" class="difflineplus">+            s-&gt;match_start -= wsize;</span>
<a href="#l11.1518"></a><span id="l11.1518" class="difflineplus">+            s-&gt;strstart    -= wsize; /* we now have strstart &gt;= MAX_DIST */</span>
<a href="#l11.1519"></a><span id="l11.1519" class="difflineplus">+            s-&gt;block_start -= (long) wsize;</span>
<a href="#l11.1520"></a><span id="l11.1520" class="difflineplus">+            slide_hash(s);</span>
<a href="#l11.1521"></a><span id="l11.1521" class="difflineplus">+            more += wsize;</span>
<a href="#l11.1522"></a><span id="l11.1522" class="difflineplus">+        }</span>
<a href="#l11.1523"></a><span id="l11.1523" class="difflineplus">+        if (s-&gt;strm-&gt;avail_in == 0) break;</span>
<a href="#l11.1524"></a><span id="l11.1524" class="difflineplus">+</span>
<a href="#l11.1525"></a><span id="l11.1525" class="difflineplus">+        /* If there was no sliding:</span>
<a href="#l11.1526"></a><span id="l11.1526" class="difflineplus">+         *    strstart &lt;= WSIZE+MAX_DIST-1 &amp;&amp; lookahead &lt;= MIN_LOOKAHEAD - 1 &amp;&amp;</span>
<a href="#l11.1527"></a><span id="l11.1527" class="difflineplus">+         *    more == window_size - lookahead - strstart</span>
<a href="#l11.1528"></a><span id="l11.1528" class="difflineplus">+         * =&gt; more &gt;= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)</span>
<a href="#l11.1529"></a><span id="l11.1529" class="difflineplus">+         * =&gt; more &gt;= window_size - 2*WSIZE + 2</span>
<a href="#l11.1530"></a><span id="l11.1530" class="difflineplus">+         * In the BIG_MEM or MMAP case (not yet supported),</span>
<a href="#l11.1531"></a><span id="l11.1531" class="difflineplus">+         *   window_size == input_size + MIN_LOOKAHEAD  &amp;&amp;</span>
<a href="#l11.1532"></a><span id="l11.1532" class="difflineplus">+         *   strstart + s-&gt;lookahead &lt;= input_size =&gt; more &gt;= MIN_LOOKAHEAD.</span>
<a href="#l11.1533"></a><span id="l11.1533" class="difflineplus">+         * Otherwise, window_size == 2*WSIZE so more &gt;= 2.</span>
<a href="#l11.1534"></a><span id="l11.1534" class="difflineplus">+         * If there was sliding, more &gt;= WSIZE. So in all cases, more &gt;= 2.</span>
<a href="#l11.1535"></a><span id="l11.1535" class="difflineplus">+         */</span>
<a href="#l11.1536"></a><span id="l11.1536" class="difflineplus">+        Assert(more &gt;= 2, &quot;more &lt; 2&quot;);</span>
<a href="#l11.1537"></a><span id="l11.1537" class="difflineplus">+</span>
<a href="#l11.1538"></a><span id="l11.1538" class="difflineplus">+        n = read_buf(s-&gt;strm, s-&gt;window + s-&gt;strstart + s-&gt;lookahead, more);</span>
<a href="#l11.1539"></a><span id="l11.1539" class="difflineplus">+        s-&gt;lookahead += n;</span>
<a href="#l11.1540"></a><span id="l11.1540" class="difflineplus">+</span>
<a href="#l11.1541"></a><span id="l11.1541" class="difflineplus">+        /* Initialize the hash value now that we have some input: */</span>
<a href="#l11.1542"></a><span id="l11.1542" class="difflineplus">+        if (s-&gt;lookahead + s-&gt;insert &gt;= MIN_MATCH) {</span>
<a href="#l11.1543"></a><span id="l11.1543" class="difflineplus">+            uInt str = s-&gt;strstart - s-&gt;insert;</span>
<a href="#l11.1544"></a><span id="l11.1544" class="difflineplus">+            s-&gt;ins_h = s-&gt;window[str];</span>
<a href="#l11.1545"></a><span id="l11.1545" class="difflineplus">+            UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[str + 1]);</span>
<a href="#l11.1546"></a><span id="l11.1546" class="difflineplus">+#if MIN_MATCH != 3</span>
<a href="#l11.1547"></a><span id="l11.1547" class="difflineplus">+            Call UPDATE_HASH() MIN_MATCH-3 more times</span>
<a href="#l11.1548"></a><span id="l11.1548" class="difflineplus">+#endif</span>
<a href="#l11.1549"></a><span id="l11.1549" class="difflineplus">+            while (s-&gt;insert) {</span>
<a href="#l11.1550"></a><span id="l11.1550" class="difflineplus">+                UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[str + MIN_MATCH-1]);</span>
<a href="#l11.1551"></a><span id="l11.1551" class="difflineplus">+#ifndef FASTEST</span>
<a href="#l11.1552"></a><span id="l11.1552" class="difflineplus">+                s-&gt;prev[str &amp; s-&gt;w_mask] = s-&gt;head[s-&gt;ins_h];</span>
<a href="#l11.1553"></a><span id="l11.1553" class="difflineplus">+#endif</span>
<a href="#l11.1554"></a><span id="l11.1554" class="difflineplus">+                s-&gt;head[s-&gt;ins_h] = (Pos)str;</span>
<a href="#l11.1555"></a><span id="l11.1555" class="difflineplus">+                str++;</span>
<a href="#l11.1556"></a><span id="l11.1556" class="difflineplus">+                s-&gt;insert--;</span>
<a href="#l11.1557"></a><span id="l11.1557" class="difflineplus">+                if (s-&gt;lookahead + s-&gt;insert &lt; MIN_MATCH)</span>
<a href="#l11.1558"></a><span id="l11.1558" class="difflineplus">+                    break;</span>
<a href="#l11.1559"></a><span id="l11.1559" class="difflineplus">+            }</span>
<a href="#l11.1560"></a><span id="l11.1560" class="difflineplus">+        }</span>
<a href="#l11.1561"></a><span id="l11.1561" class="difflineplus">+        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,</span>
<a href="#l11.1562"></a><span id="l11.1562" class="difflineplus">+         * but this is not important since only literal bytes will be emitted.</span>
<a href="#l11.1563"></a><span id="l11.1563" class="difflineplus">+         */</span>
<a href="#l11.1564"></a><span id="l11.1564" class="difflineplus">+</span>
<a href="#l11.1565"></a><span id="l11.1565" class="difflineplus">+    } while (s-&gt;lookahead &lt; MIN_LOOKAHEAD &amp;&amp; s-&gt;strm-&gt;avail_in != 0);</span>
<a href="#l11.1566"></a><span id="l11.1566" class="difflineplus">+</span>
<a href="#l11.1567"></a><span id="l11.1567" class="difflineplus">+    /* If the WIN_INIT bytes after the end of the current data have never been</span>
<a href="#l11.1568"></a><span id="l11.1568" class="difflineplus">+     * written, then zero those bytes in order to avoid memory check reports of</span>
<a href="#l11.1569"></a><span id="l11.1569" class="difflineplus">+     * the use of uninitialized (or uninitialised as Julian writes) bytes by</span>
<a href="#l11.1570"></a><span id="l11.1570" class="difflineplus">+     * the longest match routines.  Update the high water mark for the next</span>
<a href="#l11.1571"></a><span id="l11.1571" class="difflineplus">+     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match</span>
<a href="#l11.1572"></a><span id="l11.1572" class="difflineplus">+     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.</span>
<a href="#l11.1573"></a><span id="l11.1573" class="difflineplus">+     */</span>
<a href="#l11.1574"></a><span id="l11.1574" class="difflineplus">+    if (s-&gt;high_water &lt; s-&gt;window_size) {</span>
<a href="#l11.1575"></a><span id="l11.1575" class="difflineplus">+        ulg curr = s-&gt;strstart + (ulg)(s-&gt;lookahead);</span>
<a href="#l11.1576"></a><span id="l11.1576" class="difflineplus">+        ulg init;</span>
<a href="#l11.1577"></a><span id="l11.1577" class="difflineplus">+</span>
<a href="#l11.1578"></a><span id="l11.1578" class="difflineplus">+        if (s-&gt;high_water &lt; curr) {</span>
<a href="#l11.1579"></a><span id="l11.1579" class="difflineplus">+            /* Previous high water mark below current data -- zero WIN_INIT</span>
<a href="#l11.1580"></a><span id="l11.1580" class="difflineplus">+             * bytes or up to end of window, whichever is less.</span>
<a href="#l11.1581"></a><span id="l11.1581" class="difflineplus">+             */</span>
<a href="#l11.1582"></a><span id="l11.1582" class="difflineplus">+            init = s-&gt;window_size - curr;</span>
<a href="#l11.1583"></a><span id="l11.1583" class="difflineplus">+            if (init &gt; WIN_INIT)</span>
<a href="#l11.1584"></a><span id="l11.1584" class="difflineplus">+                init = WIN_INIT;</span>
<a href="#l11.1585"></a><span id="l11.1585" class="difflineplus">+            zmemzero(s-&gt;window + curr, (unsigned)init);</span>
<a href="#l11.1586"></a><span id="l11.1586" class="difflineplus">+            s-&gt;high_water = curr + init;</span>
<a href="#l11.1587"></a><span id="l11.1587" class="difflineplus">+        }</span>
<a href="#l11.1588"></a><span id="l11.1588" class="difflineplus">+        else if (s-&gt;high_water &lt; (ulg)curr + WIN_INIT) {</span>
<a href="#l11.1589"></a><span id="l11.1589" class="difflineplus">+            /* High water mark at or above current data, but below current data</span>
<a href="#l11.1590"></a><span id="l11.1590" class="difflineplus">+             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up</span>
<a href="#l11.1591"></a><span id="l11.1591" class="difflineplus">+             * to end of window, whichever is less.</span>
<a href="#l11.1592"></a><span id="l11.1592" class="difflineplus">+             */</span>
<a href="#l11.1593"></a><span id="l11.1593" class="difflineplus">+            init = (ulg)curr + WIN_INIT - s-&gt;high_water;</span>
<a href="#l11.1594"></a><span id="l11.1594" class="difflineplus">+            if (init &gt; s-&gt;window_size - s-&gt;high_water)</span>
<a href="#l11.1595"></a><span id="l11.1595" class="difflineplus">+                init = s-&gt;window_size - s-&gt;high_water;</span>
<a href="#l11.1596"></a><span id="l11.1596" class="difflineplus">+            zmemzero(s-&gt;window + s-&gt;high_water, (unsigned)init);</span>
<a href="#l11.1597"></a><span id="l11.1597" class="difflineplus">+            s-&gt;high_water += init;</span>
<a href="#l11.1598"></a><span id="l11.1598" class="difflineplus">+        }</span>
<a href="#l11.1599"></a><span id="l11.1599" class="difflineplus">+    }</span>
<a href="#l11.1600"></a><span id="l11.1600" class="difflineplus">+</span>
<a href="#l11.1601"></a><span id="l11.1601" class="difflineplus">+    Assert((ulg)s-&gt;strstart &lt;= s-&gt;window_size - MIN_LOOKAHEAD,</span>
<a href="#l11.1602"></a><span id="l11.1602" class="difflineplus">+           &quot;not enough room for search&quot;);</span>
<a href="#l11.1603"></a><span id="l11.1603" class="difflineplus">+}</span>
<a href="#l11.1604"></a><span id="l11.1604" class="difflineplus">+</span>
<a href="#l11.1605"></a><span id="l11.1605" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.1606"></a><span id="l11.1606" class="difflineplus">+ * Flush the current block, with given end-of-file flag.</span>
<a href="#l11.1607"></a><span id="l11.1607" class="difflineplus">+ * IN assertion: strstart is set to the end of the current match.</span>
<a href="#l11.1608"></a><span id="l11.1608" class="difflineplus">+ */</span>
<a href="#l11.1609"></a><span id="l11.1609" class="difflineplus">+#define FLUSH_BLOCK_ONLY(s, last) { \</span>
<a href="#l11.1610"></a><span id="l11.1610" class="difflineplus">+   _tr_flush_block(s, (s-&gt;block_start &gt;= 0L ? \</span>
<a href="#l11.1611"></a><span id="l11.1611" class="difflineplus">+                   (charf *)&amp;s-&gt;window[(unsigned)s-&gt;block_start] : \</span>
<a href="#l11.1612"></a><span id="l11.1612" class="difflineplus">+                   (charf *)Z_NULL), \</span>
<a href="#l11.1613"></a><span id="l11.1613" class="difflineplus">+                (ulg)((long)s-&gt;strstart - s-&gt;block_start), \</span>
<a href="#l11.1614"></a><span id="l11.1614" class="difflineplus">+                (last)); \</span>
<a href="#l11.1615"></a><span id="l11.1615" class="difflineplus">+   s-&gt;block_start = s-&gt;strstart; \</span>
<a href="#l11.1616"></a><span id="l11.1616" class="difflineplus">+   flush_pending(s-&gt;strm); \</span>
<a href="#l11.1617"></a><span id="l11.1617" class="difflineplus">+   Tracev((stderr,&quot;[FLUSH]&quot;)); \</span>
<a href="#l11.1618"></a><span id="l11.1618" class="difflineplus">+}</span>
<a href="#l11.1619"></a><span id="l11.1619" class="difflineplus">+</span>
<a href="#l11.1620"></a><span id="l11.1620" class="difflineplus">+/* Same but force premature exit if necessary. */</span>
<a href="#l11.1621"></a><span id="l11.1621" class="difflineplus">+#define FLUSH_BLOCK(s, last) { \</span>
<a href="#l11.1622"></a><span id="l11.1622" class="difflineplus">+   FLUSH_BLOCK_ONLY(s, last); \</span>
<a href="#l11.1623"></a><span id="l11.1623" class="difflineplus">+   if (s-&gt;strm-&gt;avail_out == 0) return (last) ? finish_started : need_more; \</span>
<a href="#l11.1624"></a><span id="l11.1624" class="difflineplus">+}</span>
<a href="#l11.1625"></a><span id="l11.1625" class="difflineplus">+</span>
<a href="#l11.1626"></a><span id="l11.1626" class="difflineplus">+/* Maximum stored block length in deflate format (not including header). */</span>
<a href="#l11.1627"></a><span id="l11.1627" class="difflineplus">+#define MAX_STORED 65535</span>
<a href="#l11.1628"></a><span id="l11.1628" class="difflineplus">+</span>
<a href="#l11.1629"></a><span id="l11.1629" class="difflineplus">+/* Minimum of a and b. */</span>
<a href="#l11.1630"></a><span id="l11.1630" class="difflineplus">+#define MIN(a, b) ((a) &gt; (b) ? (b) : (a))</span>
<a href="#l11.1631"></a><span id="l11.1631" class="difflineplus">+</span>
<a href="#l11.1632"></a><span id="l11.1632" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.1633"></a><span id="l11.1633" class="difflineplus">+ * Copy without compression as much as possible from the input stream, return</span>
<a href="#l11.1634"></a><span id="l11.1634" class="difflineplus">+ * the current block state.</span>
<a href="#l11.1635"></a><span id="l11.1635" class="difflineplus">+ *</span>
<a href="#l11.1636"></a><span id="l11.1636" class="difflineplus">+ * In case deflateParams() is used to later switch to a non-zero compression</span>
<a href="#l11.1637"></a><span id="l11.1637" class="difflineplus">+ * level, s-&gt;matches (otherwise unused when storing) keeps track of the number</span>
<a href="#l11.1638"></a><span id="l11.1638" class="difflineplus">+ * of hash table slides to perform. If s-&gt;matches is 1, then one hash table</span>
<a href="#l11.1639"></a><span id="l11.1639" class="difflineplus">+ * slide will be done when switching. If s-&gt;matches is 2, the maximum value</span>
<a href="#l11.1640"></a><span id="l11.1640" class="difflineplus">+ * allowed here, then the hash table will be cleared, since two or more slides</span>
<a href="#l11.1641"></a><span id="l11.1641" class="difflineplus">+ * is the same as a clear.</span>
<a href="#l11.1642"></a><span id="l11.1642" class="difflineplus">+ *</span>
<a href="#l11.1643"></a><span id="l11.1643" class="difflineplus">+ * deflate_stored() is written to minimize the number of times an input byte is</span>
<a href="#l11.1644"></a><span id="l11.1644" class="difflineplus">+ * copied. It is most efficient with large input and output buffers, which</span>
<a href="#l11.1645"></a><span id="l11.1645" class="difflineplus">+ * maximizes the opportunites to have a single copy from next_in to next_out.</span>
<a href="#l11.1646"></a><span id="l11.1646" class="difflineplus">+ */</span>
<a href="#l11.1647"></a><span id="l11.1647" class="difflineplus">+local block_state deflate_stored(s, flush)</span>
<a href="#l11.1648"></a><span id="l11.1648" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.1649"></a><span id="l11.1649" class="difflineplus">+    int flush;</span>
<a href="#l11.1650"></a><span id="l11.1650" class="difflineplus">+{</span>
<a href="#l11.1651"></a><span id="l11.1651" class="difflineplus">+    /* Smallest worthy block size when not flushing or finishing. By default</span>
<a href="#l11.1652"></a><span id="l11.1652" class="difflineplus">+     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For</span>
<a href="#l11.1653"></a><span id="l11.1653" class="difflineplus">+     * large input and output buffers, the stored block size will be larger.</span>
<a href="#l11.1654"></a><span id="l11.1654" class="difflineplus">+     */</span>
<a href="#l11.1655"></a><span id="l11.1655" class="difflineplus">+    unsigned min_block = MIN(s-&gt;pending_buf_size - 5, s-&gt;w_size);</span>
<a href="#l11.1656"></a><span id="l11.1656" class="difflineplus">+</span>
<a href="#l11.1657"></a><span id="l11.1657" class="difflineplus">+    /* Copy as many min_block or larger stored blocks directly to next_out as</span>
<a href="#l11.1658"></a><span id="l11.1658" class="difflineplus">+     * possible. If flushing, copy the remaining available input to next_out as</span>
<a href="#l11.1659"></a><span id="l11.1659" class="difflineplus">+     * stored blocks, if there is enough space.</span>
<a href="#l11.1660"></a><span id="l11.1660" class="difflineplus">+     */</span>
<a href="#l11.1661"></a><span id="l11.1661" class="difflineplus">+    unsigned len, left, have, last = 0;</span>
<a href="#l11.1662"></a><span id="l11.1662" class="difflineplus">+    unsigned used = s-&gt;strm-&gt;avail_in;</span>
<a href="#l11.1663"></a><span id="l11.1663" class="difflineplus">+    do {</span>
<a href="#l11.1664"></a><span id="l11.1664" class="difflineplus">+        /* Set len to the maximum size block that we can copy directly with the</span>
<a href="#l11.1665"></a><span id="l11.1665" class="difflineplus">+         * available input data and output space. Set left to how much of that</span>
<a href="#l11.1666"></a><span id="l11.1666" class="difflineplus">+         * would be copied from what's left in the window.</span>
<a href="#l11.1667"></a><span id="l11.1667" class="difflineplus">+         */</span>
<a href="#l11.1668"></a><span id="l11.1668" class="difflineplus">+        len = MAX_STORED;       /* maximum deflate stored block length */</span>
<a href="#l11.1669"></a><span id="l11.1669" class="difflineplus">+        have = (s-&gt;bi_valid + 42) &gt;&gt; 3;         /* number of header bytes */</span>
<a href="#l11.1670"></a><span id="l11.1670" class="difflineplus">+        if (s-&gt;strm-&gt;avail_out &lt; have)          /* need room for header */</span>
<a href="#l11.1671"></a><span id="l11.1671" class="difflineplus">+            break;</span>
<a href="#l11.1672"></a><span id="l11.1672" class="difflineplus">+            /* maximum stored block length that will fit in avail_out: */</span>
<a href="#l11.1673"></a><span id="l11.1673" class="difflineplus">+        have = s-&gt;strm-&gt;avail_out - have;</span>
<a href="#l11.1674"></a><span id="l11.1674" class="difflineplus">+        left = s-&gt;strstart - s-&gt;block_start;    /* bytes left in window */</span>
<a href="#l11.1675"></a><span id="l11.1675" class="difflineplus">+        if (len &gt; (ulg)left + s-&gt;strm-&gt;avail_in)</span>
<a href="#l11.1676"></a><span id="l11.1676" class="difflineplus">+            len = left + s-&gt;strm-&gt;avail_in;     /* limit len to the input */</span>
<a href="#l11.1677"></a><span id="l11.1677" class="difflineplus">+        if (len &gt; have)</span>
<a href="#l11.1678"></a><span id="l11.1678" class="difflineplus">+            len = have;                         /* limit len to the output */</span>
<a href="#l11.1679"></a><span id="l11.1679" class="difflineplus">+</span>
<a href="#l11.1680"></a><span id="l11.1680" class="difflineplus">+        /* If the stored block would be less than min_block in length, or if</span>
<a href="#l11.1681"></a><span id="l11.1681" class="difflineplus">+         * unable to copy all of the available input when flushing, then try</span>
<a href="#l11.1682"></a><span id="l11.1682" class="difflineplus">+         * copying to the window and the pending buffer instead. Also don't</span>
<a href="#l11.1683"></a><span id="l11.1683" class="difflineplus">+         * write an empty block when flushing -- deflate() does that.</span>
<a href="#l11.1684"></a><span id="l11.1684" class="difflineplus">+         */</span>
<a href="#l11.1685"></a><span id="l11.1685" class="difflineplus">+        if (len &lt; min_block &amp;&amp; ((len == 0 &amp;&amp; flush != Z_FINISH) ||</span>
<a href="#l11.1686"></a><span id="l11.1686" class="difflineplus">+                                flush == Z_NO_FLUSH ||</span>
<a href="#l11.1687"></a><span id="l11.1687" class="difflineplus">+                                len != left + s-&gt;strm-&gt;avail_in))</span>
<a href="#l11.1688"></a><span id="l11.1688" class="difflineplus">+            break;</span>
<a href="#l11.1689"></a><span id="l11.1689" class="difflineplus">+</span>
<a href="#l11.1690"></a><span id="l11.1690" class="difflineplus">+        /* Make a dummy stored block in pending to get the header bytes,</span>
<a href="#l11.1691"></a><span id="l11.1691" class="difflineplus">+         * including any pending bits. This also updates the debugging counts.</span>
<a href="#l11.1692"></a><span id="l11.1692" class="difflineplus">+         */</span>
<a href="#l11.1693"></a><span id="l11.1693" class="difflineplus">+        last = flush == Z_FINISH &amp;&amp; len == left + s-&gt;strm-&gt;avail_in ? 1 : 0;</span>
<a href="#l11.1694"></a><span id="l11.1694" class="difflineplus">+        _tr_stored_block(s, (char *)0, 0L, last);</span>
<a href="#l11.1695"></a><span id="l11.1695" class="difflineplus">+</span>
<a href="#l11.1696"></a><span id="l11.1696" class="difflineplus">+        /* Replace the lengths in the dummy stored block with len. */</span>
<a href="#l11.1697"></a><span id="l11.1697" class="difflineplus">+        s-&gt;pending_buf[s-&gt;pending - 4] = len;</span>
<a href="#l11.1698"></a><span id="l11.1698" class="difflineplus">+        s-&gt;pending_buf[s-&gt;pending - 3] = len &gt;&gt; 8;</span>
<a href="#l11.1699"></a><span id="l11.1699" class="difflineplus">+        s-&gt;pending_buf[s-&gt;pending - 2] = ~len;</span>
<a href="#l11.1700"></a><span id="l11.1700" class="difflineplus">+        s-&gt;pending_buf[s-&gt;pending - 1] = ~len &gt;&gt; 8;</span>
<a href="#l11.1701"></a><span id="l11.1701" class="difflineplus">+</span>
<a href="#l11.1702"></a><span id="l11.1702" class="difflineplus">+        /* Write the stored block header bytes. */</span>
<a href="#l11.1703"></a><span id="l11.1703" class="difflineplus">+        flush_pending(s-&gt;strm);</span>
<a href="#l11.1704"></a><span id="l11.1704" class="difflineplus">+</span>
<a href="#l11.1705"></a><span id="l11.1705" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l11.1706"></a><span id="l11.1706" class="difflineplus">+        /* Update debugging counts for the data about to be copied. */</span>
<a href="#l11.1707"></a><span id="l11.1707" class="difflineplus">+        s-&gt;compressed_len += len &lt;&lt; 3;</span>
<a href="#l11.1708"></a><span id="l11.1708" class="difflineplus">+        s-&gt;bits_sent += len &lt;&lt; 3;</span>
<a href="#l11.1709"></a><span id="l11.1709" class="difflineplus">+#endif</span>
<a href="#l11.1710"></a><span id="l11.1710" class="difflineplus">+</span>
<a href="#l11.1711"></a><span id="l11.1711" class="difflineplus">+        /* Copy uncompressed bytes from the window to next_out. */</span>
<a href="#l11.1712"></a><span id="l11.1712" class="difflineplus">+        if (left) {</span>
<a href="#l11.1713"></a><span id="l11.1713" class="difflineplus">+            if (left &gt; len)</span>
<a href="#l11.1714"></a><span id="l11.1714" class="difflineplus">+                left = len;</span>
<a href="#l11.1715"></a><span id="l11.1715" class="difflineplus">+            zmemcpy(s-&gt;strm-&gt;next_out, s-&gt;window + s-&gt;block_start, left);</span>
<a href="#l11.1716"></a><span id="l11.1716" class="difflineplus">+            s-&gt;strm-&gt;next_out += left;</span>
<a href="#l11.1717"></a><span id="l11.1717" class="difflineplus">+            s-&gt;strm-&gt;avail_out -= left;</span>
<a href="#l11.1718"></a><span id="l11.1718" class="difflineplus">+            s-&gt;strm-&gt;total_out += left;</span>
<a href="#l11.1719"></a><span id="l11.1719" class="difflineplus">+            s-&gt;block_start += left;</span>
<a href="#l11.1720"></a><span id="l11.1720" class="difflineplus">+            len -= left;</span>
<a href="#l11.1721"></a><span id="l11.1721" class="difflineplus">+        }</span>
<a href="#l11.1722"></a><span id="l11.1722" class="difflineplus">+</span>
<a href="#l11.1723"></a><span id="l11.1723" class="difflineplus">+        /* Copy uncompressed bytes directly from next_in to next_out, updating</span>
<a href="#l11.1724"></a><span id="l11.1724" class="difflineplus">+         * the check value.</span>
<a href="#l11.1725"></a><span id="l11.1725" class="difflineplus">+         */</span>
<a href="#l11.1726"></a><span id="l11.1726" class="difflineplus">+        if (len) {</span>
<a href="#l11.1727"></a><span id="l11.1727" class="difflineplus">+            read_buf(s-&gt;strm, s-&gt;strm-&gt;next_out, len);</span>
<a href="#l11.1728"></a><span id="l11.1728" class="difflineplus">+            s-&gt;strm-&gt;next_out += len;</span>
<a href="#l11.1729"></a><span id="l11.1729" class="difflineplus">+            s-&gt;strm-&gt;avail_out -= len;</span>
<a href="#l11.1730"></a><span id="l11.1730" class="difflineplus">+            s-&gt;strm-&gt;total_out += len;</span>
<a href="#l11.1731"></a><span id="l11.1731" class="difflineplus">+        }</span>
<a href="#l11.1732"></a><span id="l11.1732" class="difflineplus">+    } while (last == 0);</span>
<a href="#l11.1733"></a><span id="l11.1733" class="difflineplus">+</span>
<a href="#l11.1734"></a><span id="l11.1734" class="difflineplus">+    /* Update the sliding window with the last s-&gt;w_size bytes of the copied</span>
<a href="#l11.1735"></a><span id="l11.1735" class="difflineplus">+     * data, or append all of the copied data to the existing window if less</span>
<a href="#l11.1736"></a><span id="l11.1736" class="difflineplus">+     * than s-&gt;w_size bytes were copied. Also update the number of bytes to</span>
<a href="#l11.1737"></a><span id="l11.1737" class="difflineplus">+     * insert in the hash tables, in the event that deflateParams() switches to</span>
<a href="#l11.1738"></a><span id="l11.1738" class="difflineplus">+     * a non-zero compression level.</span>
<a href="#l11.1739"></a><span id="l11.1739" class="difflineplus">+     */</span>
<a href="#l11.1740"></a><span id="l11.1740" class="difflineplus">+    used -= s-&gt;strm-&gt;avail_in;      /* number of input bytes directly copied */</span>
<a href="#l11.1741"></a><span id="l11.1741" class="difflineplus">+    if (used) {</span>
<a href="#l11.1742"></a><span id="l11.1742" class="difflineplus">+        /* If any input was used, then no unused input remains in the window,</span>
<a href="#l11.1743"></a><span id="l11.1743" class="difflineplus">+         * therefore s-&gt;block_start == s-&gt;strstart.</span>
<a href="#l11.1744"></a><span id="l11.1744" class="difflineplus">+         */</span>
<a href="#l11.1745"></a><span id="l11.1745" class="difflineplus">+        if (used &gt;= s-&gt;w_size) {    /* supplant the previous history */</span>
<a href="#l11.1746"></a><span id="l11.1746" class="difflineplus">+            s-&gt;matches = 2;         /* clear hash */</span>
<a href="#l11.1747"></a><span id="l11.1747" class="difflineplus">+            zmemcpy(s-&gt;window, s-&gt;strm-&gt;next_in - s-&gt;w_size, s-&gt;w_size);</span>
<a href="#l11.1748"></a><span id="l11.1748" class="difflineplus">+            s-&gt;strstart = s-&gt;w_size;</span>
<a href="#l11.1749"></a><span id="l11.1749" class="difflineplus">+        }</span>
<a href="#l11.1750"></a><span id="l11.1750" class="difflineplus">+        else {</span>
<a href="#l11.1751"></a><span id="l11.1751" class="difflineplus">+            if (s-&gt;window_size - s-&gt;strstart &lt;= used) {</span>
<a href="#l11.1752"></a><span id="l11.1752" class="difflineplus">+                /* Slide the window down. */</span>
<a href="#l11.1753"></a><span id="l11.1753" class="difflineplus">+                s-&gt;strstart -= s-&gt;w_size;</span>
<a href="#l11.1754"></a><span id="l11.1754" class="difflineplus">+                zmemcpy(s-&gt;window, s-&gt;window + s-&gt;w_size, s-&gt;strstart);</span>
<a href="#l11.1755"></a><span id="l11.1755" class="difflineplus">+                if (s-&gt;matches &lt; 2)</span>
<a href="#l11.1756"></a><span id="l11.1756" class="difflineplus">+                    s-&gt;matches++;   /* add a pending slide_hash() */</span>
<a href="#l11.1757"></a><span id="l11.1757" class="difflineplus">+            }</span>
<a href="#l11.1758"></a><span id="l11.1758" class="difflineplus">+            zmemcpy(s-&gt;window + s-&gt;strstart, s-&gt;strm-&gt;next_in - used, used);</span>
<a href="#l11.1759"></a><span id="l11.1759" class="difflineplus">+            s-&gt;strstart += used;</span>
<a href="#l11.1760"></a><span id="l11.1760" class="difflineplus">+        }</span>
<a href="#l11.1761"></a><span id="l11.1761" class="difflineplus">+        s-&gt;block_start = s-&gt;strstart;</span>
<a href="#l11.1762"></a><span id="l11.1762" class="difflineplus">+        s-&gt;insert += MIN(used, s-&gt;w_size - s-&gt;insert);</span>
<a href="#l11.1763"></a><span id="l11.1763" class="difflineplus">+    }</span>
<a href="#l11.1764"></a><span id="l11.1764" class="difflineplus">+    if (s-&gt;high_water &lt; s-&gt;strstart)</span>
<a href="#l11.1765"></a><span id="l11.1765" class="difflineplus">+        s-&gt;high_water = s-&gt;strstart;</span>
<a href="#l11.1766"></a><span id="l11.1766" class="difflineplus">+</span>
<a href="#l11.1767"></a><span id="l11.1767" class="difflineplus">+    /* If the last block was written to next_out, then done. */</span>
<a href="#l11.1768"></a><span id="l11.1768" class="difflineplus">+    if (last)</span>
<a href="#l11.1769"></a><span id="l11.1769" class="difflineplus">+        return finish_done;</span>
<a href="#l11.1770"></a><span id="l11.1770" class="difflineplus">+</span>
<a href="#l11.1771"></a><span id="l11.1771" class="difflineplus">+    /* If flushing and all input has been consumed, then done. */</span>
<a href="#l11.1772"></a><span id="l11.1772" class="difflineplus">+    if (flush != Z_NO_FLUSH &amp;&amp; flush != Z_FINISH &amp;&amp;</span>
<a href="#l11.1773"></a><span id="l11.1773" class="difflineplus">+        s-&gt;strm-&gt;avail_in == 0 &amp;&amp; (long)s-&gt;strstart == s-&gt;block_start)</span>
<a href="#l11.1774"></a><span id="l11.1774" class="difflineplus">+        return block_done;</span>
<a href="#l11.1775"></a><span id="l11.1775" class="difflineplus">+</span>
<a href="#l11.1776"></a><span id="l11.1776" class="difflineplus">+    /* Fill the window with any remaining input. */</span>
<a href="#l11.1777"></a><span id="l11.1777" class="difflineplus">+    have = s-&gt;window_size - s-&gt;strstart - 1;</span>
<a href="#l11.1778"></a><span id="l11.1778" class="difflineplus">+    if (s-&gt;strm-&gt;avail_in &gt; have &amp;&amp; s-&gt;block_start &gt;= (long)s-&gt;w_size) {</span>
<a href="#l11.1779"></a><span id="l11.1779" class="difflineplus">+        /* Slide the window down. */</span>
<a href="#l11.1780"></a><span id="l11.1780" class="difflineplus">+        s-&gt;block_start -= s-&gt;w_size;</span>
<a href="#l11.1781"></a><span id="l11.1781" class="difflineplus">+        s-&gt;strstart -= s-&gt;w_size;</span>
<a href="#l11.1782"></a><span id="l11.1782" class="difflineplus">+        zmemcpy(s-&gt;window, s-&gt;window + s-&gt;w_size, s-&gt;strstart);</span>
<a href="#l11.1783"></a><span id="l11.1783" class="difflineplus">+        if (s-&gt;matches &lt; 2)</span>
<a href="#l11.1784"></a><span id="l11.1784" class="difflineplus">+            s-&gt;matches++;           /* add a pending slide_hash() */</span>
<a href="#l11.1785"></a><span id="l11.1785" class="difflineplus">+        have += s-&gt;w_size;          /* more space now */</span>
<a href="#l11.1786"></a><span id="l11.1786" class="difflineplus">+    }</span>
<a href="#l11.1787"></a><span id="l11.1787" class="difflineplus">+    if (have &gt; s-&gt;strm-&gt;avail_in)</span>
<a href="#l11.1788"></a><span id="l11.1788" class="difflineplus">+        have = s-&gt;strm-&gt;avail_in;</span>
<a href="#l11.1789"></a><span id="l11.1789" class="difflineplus">+    if (have) {</span>
<a href="#l11.1790"></a><span id="l11.1790" class="difflineplus">+        read_buf(s-&gt;strm, s-&gt;window + s-&gt;strstart, have);</span>
<a href="#l11.1791"></a><span id="l11.1791" class="difflineplus">+        s-&gt;strstart += have;</span>
<a href="#l11.1792"></a><span id="l11.1792" class="difflineplus">+    }</span>
<a href="#l11.1793"></a><span id="l11.1793" class="difflineplus">+    if (s-&gt;high_water &lt; s-&gt;strstart)</span>
<a href="#l11.1794"></a><span id="l11.1794" class="difflineplus">+        s-&gt;high_water = s-&gt;strstart;</span>
<a href="#l11.1795"></a><span id="l11.1795" class="difflineplus">+</span>
<a href="#l11.1796"></a><span id="l11.1796" class="difflineplus">+    /* There was not enough avail_out to write a complete worthy or flushed</span>
<a href="#l11.1797"></a><span id="l11.1797" class="difflineplus">+     * stored block to next_out. Write a stored block to pending instead, if we</span>
<a href="#l11.1798"></a><span id="l11.1798" class="difflineplus">+     * have enough input for a worthy block, or if flushing and there is enough</span>
<a href="#l11.1799"></a><span id="l11.1799" class="difflineplus">+     * room for the remaining input as a stored block in the pending buffer.</span>
<a href="#l11.1800"></a><span id="l11.1800" class="difflineplus">+     */</span>
<a href="#l11.1801"></a><span id="l11.1801" class="difflineplus">+    have = (s-&gt;bi_valid + 42) &gt;&gt; 3;         /* number of header bytes */</span>
<a href="#l11.1802"></a><span id="l11.1802" class="difflineplus">+        /* maximum stored block length that will fit in pending: */</span>
<a href="#l11.1803"></a><span id="l11.1803" class="difflineplus">+    have = MIN(s-&gt;pending_buf_size - have, MAX_STORED);</span>
<a href="#l11.1804"></a><span id="l11.1804" class="difflineplus">+    min_block = MIN(have, s-&gt;w_size);</span>
<a href="#l11.1805"></a><span id="l11.1805" class="difflineplus">+    left = s-&gt;strstart - s-&gt;block_start;</span>
<a href="#l11.1806"></a><span id="l11.1806" class="difflineplus">+    if (left &gt;= min_block ||</span>
<a href="#l11.1807"></a><span id="l11.1807" class="difflineplus">+        ((left || flush == Z_FINISH) &amp;&amp; flush != Z_NO_FLUSH &amp;&amp;</span>
<a href="#l11.1808"></a><span id="l11.1808" class="difflineplus">+         s-&gt;strm-&gt;avail_in == 0 &amp;&amp; left &lt;= have)) {</span>
<a href="#l11.1809"></a><span id="l11.1809" class="difflineplus">+        len = MIN(left, have);</span>
<a href="#l11.1810"></a><span id="l11.1810" class="difflineplus">+        last = flush == Z_FINISH &amp;&amp; s-&gt;strm-&gt;avail_in == 0 &amp;&amp;</span>
<a href="#l11.1811"></a><span id="l11.1811" class="difflineplus">+               len == left ? 1 : 0;</span>
<a href="#l11.1812"></a><span id="l11.1812" class="difflineplus">+        _tr_stored_block(s, (charf *)s-&gt;window + s-&gt;block_start, len, last);</span>
<a href="#l11.1813"></a><span id="l11.1813" class="difflineplus">+        s-&gt;block_start += len;</span>
<a href="#l11.1814"></a><span id="l11.1814" class="difflineplus">+        flush_pending(s-&gt;strm);</span>
<a href="#l11.1815"></a><span id="l11.1815" class="difflineplus">+    }</span>
<a href="#l11.1816"></a><span id="l11.1816" class="difflineplus">+</span>
<a href="#l11.1817"></a><span id="l11.1817" class="difflineplus">+    /* We've done all we can with the available input and output. */</span>
<a href="#l11.1818"></a><span id="l11.1818" class="difflineplus">+    return last ? finish_started : need_more;</span>
<a href="#l11.1819"></a><span id="l11.1819" class="difflineplus">+}</span>
<a href="#l11.1820"></a><span id="l11.1820" class="difflineplus">+</span>
<a href="#l11.1821"></a><span id="l11.1821" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.1822"></a><span id="l11.1822" class="difflineplus">+ * Compress as much as possible from the input stream, return the current</span>
<a href="#l11.1823"></a><span id="l11.1823" class="difflineplus">+ * block state.</span>
<a href="#l11.1824"></a><span id="l11.1824" class="difflineplus">+ * This function does not perform lazy evaluation of matches and inserts</span>
<a href="#l11.1825"></a><span id="l11.1825" class="difflineplus">+ * new strings in the dictionary only for unmatched strings or for short</span>
<a href="#l11.1826"></a><span id="l11.1826" class="difflineplus">+ * matches. It is used only for the fast compression options.</span>
<a href="#l11.1827"></a><span id="l11.1827" class="difflineplus">+ */</span>
<a href="#l11.1828"></a><span id="l11.1828" class="difflineplus">+local block_state deflate_fast(s, flush)</span>
<a href="#l11.1829"></a><span id="l11.1829" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.1830"></a><span id="l11.1830" class="difflineplus">+    int flush;</span>
<a href="#l11.1831"></a><span id="l11.1831" class="difflineplus">+{</span>
<a href="#l11.1832"></a><span id="l11.1832" class="difflineplus">+    IPos hash_head;       /* head of the hash chain */</span>
<a href="#l11.1833"></a><span id="l11.1833" class="difflineplus">+    int bflush;           /* set if current block must be flushed */</span>
<a href="#l11.1834"></a><span id="l11.1834" class="difflineplus">+</span>
<a href="#l11.1835"></a><span id="l11.1835" class="difflineplus">+    for (;;) {</span>
<a href="#l11.1836"></a><span id="l11.1836" class="difflineplus">+        /* Make sure that we always have enough lookahead, except</span>
<a href="#l11.1837"></a><span id="l11.1837" class="difflineplus">+         * at the end of the input file. We need MAX_MATCH bytes</span>
<a href="#l11.1838"></a><span id="l11.1838" class="difflineplus">+         * for the next match, plus MIN_MATCH bytes to insert the</span>
<a href="#l11.1839"></a><span id="l11.1839" class="difflineplus">+         * string following the next match.</span>
<a href="#l11.1840"></a><span id="l11.1840" class="difflineplus">+         */</span>
<a href="#l11.1841"></a><span id="l11.1841" class="difflineplus">+        if (s-&gt;lookahead &lt; MIN_LOOKAHEAD) {</span>
<a href="#l11.1842"></a><span id="l11.1842" class="difflineplus">+            fill_window(s);</span>
<a href="#l11.1843"></a><span id="l11.1843" class="difflineplus">+            if (s-&gt;lookahead &lt; MIN_LOOKAHEAD &amp;&amp; flush == Z_NO_FLUSH) {</span>
<a href="#l11.1844"></a><span id="l11.1844" class="difflineplus">+                return need_more;</span>
<a href="#l11.1845"></a><span id="l11.1845" class="difflineplus">+            }</span>
<a href="#l11.1846"></a><span id="l11.1846" class="difflineplus">+            if (s-&gt;lookahead == 0) break; /* flush the current block */</span>
<a href="#l11.1847"></a><span id="l11.1847" class="difflineplus">+        }</span>
<a href="#l11.1848"></a><span id="l11.1848" class="difflineplus">+</span>
<a href="#l11.1849"></a><span id="l11.1849" class="difflineplus">+        /* Insert the string window[strstart .. strstart+2] in the</span>
<a href="#l11.1850"></a><span id="l11.1850" class="difflineplus">+         * dictionary, and set hash_head to the head of the hash chain:</span>
<a href="#l11.1851"></a><span id="l11.1851" class="difflineplus">+         */</span>
<a href="#l11.1852"></a><span id="l11.1852" class="difflineplus">+        hash_head = NIL;</span>
<a href="#l11.1853"></a><span id="l11.1853" class="difflineplus">+        if (s-&gt;lookahead &gt;= MIN_MATCH) {</span>
<a href="#l11.1854"></a><span id="l11.1854" class="difflineplus">+            INSERT_STRING(s, s-&gt;strstart, hash_head);</span>
<a href="#l11.1855"></a><span id="l11.1855" class="difflineplus">+        }</span>
<a href="#l11.1856"></a><span id="l11.1856" class="difflineplus">+</span>
<a href="#l11.1857"></a><span id="l11.1857" class="difflineplus">+        /* Find the longest match, discarding those &lt;= prev_length.</span>
<a href="#l11.1858"></a><span id="l11.1858" class="difflineplus">+         * At this point we have always match_length &lt; MIN_MATCH</span>
<a href="#l11.1859"></a><span id="l11.1859" class="difflineplus">+         */</span>
<a href="#l11.1860"></a><span id="l11.1860" class="difflineplus">+        if (hash_head != NIL &amp;&amp; s-&gt;strstart - hash_head &lt;= MAX_DIST(s)) {</span>
<a href="#l11.1861"></a><span id="l11.1861" class="difflineplus">+            /* To simplify the code, we prevent matches with the string</span>
<a href="#l11.1862"></a><span id="l11.1862" class="difflineplus">+             * of window index 0 (in particular we have to avoid a match</span>
<a href="#l11.1863"></a><span id="l11.1863" class="difflineplus">+             * of the string with itself at the start of the input file).</span>
<a href="#l11.1864"></a><span id="l11.1864" class="difflineplus">+             */</span>
<a href="#l11.1865"></a><span id="l11.1865" class="difflineplus">+            s-&gt;match_length = longest_match (s, hash_head);</span>
<a href="#l11.1866"></a><span id="l11.1866" class="difflineplus">+            /* longest_match() sets match_start */</span>
<a href="#l11.1867"></a><span id="l11.1867" class="difflineplus">+        }</span>
<a href="#l11.1868"></a><span id="l11.1868" class="difflineplus">+        if (s-&gt;match_length &gt;= MIN_MATCH) {</span>
<a href="#l11.1869"></a><span id="l11.1869" class="difflineplus">+            check_match(s, s-&gt;strstart, s-&gt;match_start, s-&gt;match_length);</span>
<a href="#l11.1870"></a><span id="l11.1870" class="difflineplus">+</span>
<a href="#l11.1871"></a><span id="l11.1871" class="difflineplus">+            _tr_tally_dist(s, s-&gt;strstart - s-&gt;match_start,</span>
<a href="#l11.1872"></a><span id="l11.1872" class="difflineplus">+                           s-&gt;match_length - MIN_MATCH, bflush);</span>
<a href="#l11.1873"></a><span id="l11.1873" class="difflineplus">+</span>
<a href="#l11.1874"></a><span id="l11.1874" class="difflineplus">+            s-&gt;lookahead -= s-&gt;match_length;</span>
<a href="#l11.1875"></a><span id="l11.1875" class="difflineplus">+</span>
<a href="#l11.1876"></a><span id="l11.1876" class="difflineplus">+            /* Insert new strings in the hash table only if the match length</span>
<a href="#l11.1877"></a><span id="l11.1877" class="difflineplus">+             * is not too large. This saves time but degrades compression.</span>
<a href="#l11.1878"></a><span id="l11.1878" class="difflineplus">+             */</span>
<a href="#l11.1879"></a><span id="l11.1879" class="difflineplus">+#ifndef FASTEST</span>
<a href="#l11.1880"></a><span id="l11.1880" class="difflineplus">+            if (s-&gt;match_length &lt;= s-&gt;max_insert_length &amp;&amp;</span>
<a href="#l11.1881"></a><span id="l11.1881" class="difflineplus">+                s-&gt;lookahead &gt;= MIN_MATCH) {</span>
<a href="#l11.1882"></a><span id="l11.1882" class="difflineplus">+                s-&gt;match_length--; /* string at strstart already in table */</span>
<a href="#l11.1883"></a><span id="l11.1883" class="difflineplus">+                do {</span>
<a href="#l11.1884"></a><span id="l11.1884" class="difflineplus">+                    s-&gt;strstart++;</span>
<a href="#l11.1885"></a><span id="l11.1885" class="difflineplus">+                    INSERT_STRING(s, s-&gt;strstart, hash_head);</span>
<a href="#l11.1886"></a><span id="l11.1886" class="difflineplus">+                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are</span>
<a href="#l11.1887"></a><span id="l11.1887" class="difflineplus">+                     * always MIN_MATCH bytes ahead.</span>
<a href="#l11.1888"></a><span id="l11.1888" class="difflineplus">+                     */</span>
<a href="#l11.1889"></a><span id="l11.1889" class="difflineplus">+                } while (--s-&gt;match_length != 0);</span>
<a href="#l11.1890"></a><span id="l11.1890" class="difflineplus">+                s-&gt;strstart++;</span>
<a href="#l11.1891"></a><span id="l11.1891" class="difflineplus">+            } else</span>
<a href="#l11.1892"></a><span id="l11.1892" class="difflineplus">+#endif</span>
<a href="#l11.1893"></a><span id="l11.1893" class="difflineplus">+            {</span>
<a href="#l11.1894"></a><span id="l11.1894" class="difflineplus">+                s-&gt;strstart += s-&gt;match_length;</span>
<a href="#l11.1895"></a><span id="l11.1895" class="difflineplus">+                s-&gt;match_length = 0;</span>
<a href="#l11.1896"></a><span id="l11.1896" class="difflineplus">+                s-&gt;ins_h = s-&gt;window[s-&gt;strstart];</span>
<a href="#l11.1897"></a><span id="l11.1897" class="difflineplus">+                UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[s-&gt;strstart+1]);</span>
<a href="#l11.1898"></a><span id="l11.1898" class="difflineplus">+#if MIN_MATCH != 3</span>
<a href="#l11.1899"></a><span id="l11.1899" class="difflineplus">+                Call UPDATE_HASH() MIN_MATCH-3 more times</span>
<a href="#l11.1900"></a><span id="l11.1900" class="difflineplus">+#endif</span>
<a href="#l11.1901"></a><span id="l11.1901" class="difflineplus">+                /* If lookahead &lt; MIN_MATCH, ins_h is garbage, but it does not</span>
<a href="#l11.1902"></a><span id="l11.1902" class="difflineplus">+                 * matter since it will be recomputed at next deflate call.</span>
<a href="#l11.1903"></a><span id="l11.1903" class="difflineplus">+                 */</span>
<a href="#l11.1904"></a><span id="l11.1904" class="difflineplus">+            }</span>
<a href="#l11.1905"></a><span id="l11.1905" class="difflineplus">+        } else {</span>
<a href="#l11.1906"></a><span id="l11.1906" class="difflineplus">+            /* No match, output a literal byte */</span>
<a href="#l11.1907"></a><span id="l11.1907" class="difflineplus">+            Tracevv((stderr,&quot;%c&quot;, s-&gt;window[s-&gt;strstart]));</span>
<a href="#l11.1908"></a><span id="l11.1908" class="difflineplus">+            _tr_tally_lit (s, s-&gt;window[s-&gt;strstart], bflush);</span>
<a href="#l11.1909"></a><span id="l11.1909" class="difflineplus">+            s-&gt;lookahead--;</span>
<a href="#l11.1910"></a><span id="l11.1910" class="difflineplus">+            s-&gt;strstart++;</span>
<a href="#l11.1911"></a><span id="l11.1911" class="difflineplus">+        }</span>
<a href="#l11.1912"></a><span id="l11.1912" class="difflineplus">+        if (bflush) FLUSH_BLOCK(s, 0);</span>
<a href="#l11.1913"></a><span id="l11.1913" class="difflineplus">+    }</span>
<a href="#l11.1914"></a><span id="l11.1914" class="difflineplus">+    s-&gt;insert = s-&gt;strstart &lt; MIN_MATCH-1 ? s-&gt;strstart : MIN_MATCH-1;</span>
<a href="#l11.1915"></a><span id="l11.1915" class="difflineplus">+    if (flush == Z_FINISH) {</span>
<a href="#l11.1916"></a><span id="l11.1916" class="difflineplus">+        FLUSH_BLOCK(s, 1);</span>
<a href="#l11.1917"></a><span id="l11.1917" class="difflineplus">+        return finish_done;</span>
<a href="#l11.1918"></a><span id="l11.1918" class="difflineplus">+    }</span>
<a href="#l11.1919"></a><span id="l11.1919" class="difflineplus">+    if (s-&gt;last_lit)</span>
<a href="#l11.1920"></a><span id="l11.1920" class="difflineplus">+        FLUSH_BLOCK(s, 0);</span>
<a href="#l11.1921"></a><span id="l11.1921" class="difflineplus">+    return block_done;</span>
<a href="#l11.1922"></a><span id="l11.1922" class="difflineplus">+}</span>
<a href="#l11.1923"></a><span id="l11.1923" class="difflineplus">+</span>
<a href="#l11.1924"></a><span id="l11.1924" class="difflineplus">+#ifndef FASTEST</span>
<a href="#l11.1925"></a><span id="l11.1925" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.1926"></a><span id="l11.1926" class="difflineplus">+ * Same as above, but achieves better compression. We use a lazy</span>
<a href="#l11.1927"></a><span id="l11.1927" class="difflineplus">+ * evaluation for matches: a match is finally adopted only if there is</span>
<a href="#l11.1928"></a><span id="l11.1928" class="difflineplus">+ * no better match at the next window position.</span>
<a href="#l11.1929"></a><span id="l11.1929" class="difflineplus">+ */</span>
<a href="#l11.1930"></a><span id="l11.1930" class="difflineplus">+local block_state deflate_slow(s, flush)</span>
<a href="#l11.1931"></a><span id="l11.1931" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.1932"></a><span id="l11.1932" class="difflineplus">+    int flush;</span>
<a href="#l11.1933"></a><span id="l11.1933" class="difflineplus">+{</span>
<a href="#l11.1934"></a><span id="l11.1934" class="difflineplus">+    IPos hash_head;          /* head of hash chain */</span>
<a href="#l11.1935"></a><span id="l11.1935" class="difflineplus">+    int bflush;              /* set if current block must be flushed */</span>
<a href="#l11.1936"></a><span id="l11.1936" class="difflineplus">+</span>
<a href="#l11.1937"></a><span id="l11.1937" class="difflineplus">+    /* Process the input block. */</span>
<a href="#l11.1938"></a><span id="l11.1938" class="difflineplus">+    for (;;) {</span>
<a href="#l11.1939"></a><span id="l11.1939" class="difflineplus">+        /* Make sure that we always have enough lookahead, except</span>
<a href="#l11.1940"></a><span id="l11.1940" class="difflineplus">+         * at the end of the input file. We need MAX_MATCH bytes</span>
<a href="#l11.1941"></a><span id="l11.1941" class="difflineplus">+         * for the next match, plus MIN_MATCH bytes to insert the</span>
<a href="#l11.1942"></a><span id="l11.1942" class="difflineplus">+         * string following the next match.</span>
<a href="#l11.1943"></a><span id="l11.1943" class="difflineplus">+         */</span>
<a href="#l11.1944"></a><span id="l11.1944" class="difflineplus">+        if (s-&gt;lookahead &lt; MIN_LOOKAHEAD) {</span>
<a href="#l11.1945"></a><span id="l11.1945" class="difflineplus">+            fill_window(s);</span>
<a href="#l11.1946"></a><span id="l11.1946" class="difflineplus">+            if (s-&gt;lookahead &lt; MIN_LOOKAHEAD &amp;&amp; flush == Z_NO_FLUSH) {</span>
<a href="#l11.1947"></a><span id="l11.1947" class="difflineplus">+                return need_more;</span>
<a href="#l11.1948"></a><span id="l11.1948" class="difflineplus">+            }</span>
<a href="#l11.1949"></a><span id="l11.1949" class="difflineplus">+            if (s-&gt;lookahead == 0) break; /* flush the current block */</span>
<a href="#l11.1950"></a><span id="l11.1950" class="difflineplus">+        }</span>
<a href="#l11.1951"></a><span id="l11.1951" class="difflineplus">+</span>
<a href="#l11.1952"></a><span id="l11.1952" class="difflineplus">+        /* Insert the string window[strstart .. strstart+2] in the</span>
<a href="#l11.1953"></a><span id="l11.1953" class="difflineplus">+         * dictionary, and set hash_head to the head of the hash chain:</span>
<a href="#l11.1954"></a><span id="l11.1954" class="difflineplus">+         */</span>
<a href="#l11.1955"></a><span id="l11.1955" class="difflineplus">+        hash_head = NIL;</span>
<a href="#l11.1956"></a><span id="l11.1956" class="difflineplus">+        if (s-&gt;lookahead &gt;= MIN_MATCH) {</span>
<a href="#l11.1957"></a><span id="l11.1957" class="difflineplus">+            INSERT_STRING(s, s-&gt;strstart, hash_head);</span>
<a href="#l11.1958"></a><span id="l11.1958" class="difflineplus">+        }</span>
<a href="#l11.1959"></a><span id="l11.1959" class="difflineplus">+</span>
<a href="#l11.1960"></a><span id="l11.1960" class="difflineplus">+        /* Find the longest match, discarding those &lt;= prev_length.</span>
<a href="#l11.1961"></a><span id="l11.1961" class="difflineplus">+         */</span>
<a href="#l11.1962"></a><span id="l11.1962" class="difflineplus">+        s-&gt;prev_length = s-&gt;match_length, s-&gt;prev_match = s-&gt;match_start;</span>
<a href="#l11.1963"></a><span id="l11.1963" class="difflineplus">+        s-&gt;match_length = MIN_MATCH-1;</span>
<a href="#l11.1964"></a><span id="l11.1964" class="difflineplus">+</span>
<a href="#l11.1965"></a><span id="l11.1965" class="difflineplus">+        if (hash_head != NIL &amp;&amp; s-&gt;prev_length &lt; s-&gt;max_lazy_match &amp;&amp;</span>
<a href="#l11.1966"></a><span id="l11.1966" class="difflineplus">+            s-&gt;strstart - hash_head &lt;= MAX_DIST(s)) {</span>
<a href="#l11.1967"></a><span id="l11.1967" class="difflineplus">+            /* To simplify the code, we prevent matches with the string</span>
<a href="#l11.1968"></a><span id="l11.1968" class="difflineplus">+             * of window index 0 (in particular we have to avoid a match</span>
<a href="#l11.1969"></a><span id="l11.1969" class="difflineplus">+             * of the string with itself at the start of the input file).</span>
<a href="#l11.1970"></a><span id="l11.1970" class="difflineplus">+             */</span>
<a href="#l11.1971"></a><span id="l11.1971" class="difflineplus">+            s-&gt;match_length = longest_match (s, hash_head);</span>
<a href="#l11.1972"></a><span id="l11.1972" class="difflineplus">+            /* longest_match() sets match_start */</span>
<a href="#l11.1973"></a><span id="l11.1973" class="difflineplus">+</span>
<a href="#l11.1974"></a><span id="l11.1974" class="difflineplus">+            if (s-&gt;match_length &lt;= 5 &amp;&amp; (s-&gt;strategy == Z_FILTERED</span>
<a href="#l11.1975"></a><span id="l11.1975" class="difflineplus">+#if TOO_FAR &lt;= 32767</span>
<a href="#l11.1976"></a><span id="l11.1976" class="difflineplus">+                || (s-&gt;match_length == MIN_MATCH &amp;&amp;</span>
<a href="#l11.1977"></a><span id="l11.1977" class="difflineplus">+                    s-&gt;strstart - s-&gt;match_start &gt; TOO_FAR)</span>
<a href="#l11.1978"></a><span id="l11.1978" class="difflineplus">+#endif</span>
<a href="#l11.1979"></a><span id="l11.1979" class="difflineplus">+                )) {</span>
<a href="#l11.1980"></a><span id="l11.1980" class="difflineplus">+</span>
<a href="#l11.1981"></a><span id="l11.1981" class="difflineplus">+                /* If prev_match is also MIN_MATCH, match_start is garbage</span>
<a href="#l11.1982"></a><span id="l11.1982" class="difflineplus">+                 * but we will ignore the current match anyway.</span>
<a href="#l11.1983"></a><span id="l11.1983" class="difflineplus">+                 */</span>
<a href="#l11.1984"></a><span id="l11.1984" class="difflineplus">+                s-&gt;match_length = MIN_MATCH-1;</span>
<a href="#l11.1985"></a><span id="l11.1985" class="difflineplus">+            }</span>
<a href="#l11.1986"></a><span id="l11.1986" class="difflineplus">+        }</span>
<a href="#l11.1987"></a><span id="l11.1987" class="difflineplus">+        /* If there was a match at the previous step and the current</span>
<a href="#l11.1988"></a><span id="l11.1988" class="difflineplus">+         * match is not better, output the previous match:</span>
<a href="#l11.1989"></a><span id="l11.1989" class="difflineplus">+         */</span>
<a href="#l11.1990"></a><span id="l11.1990" class="difflineplus">+        if (s-&gt;prev_length &gt;= MIN_MATCH &amp;&amp; s-&gt;match_length &lt;= s-&gt;prev_length) {</span>
<a href="#l11.1991"></a><span id="l11.1991" class="difflineplus">+            uInt max_insert = s-&gt;strstart + s-&gt;lookahead - MIN_MATCH;</span>
<a href="#l11.1992"></a><span id="l11.1992" class="difflineplus">+            /* Do not insert strings in hash table beyond this. */</span>
<a href="#l11.1993"></a><span id="l11.1993" class="difflineplus">+</span>
<a href="#l11.1994"></a><span id="l11.1994" class="difflineplus">+            check_match(s, s-&gt;strstart-1, s-&gt;prev_match, s-&gt;prev_length);</span>
<a href="#l11.1995"></a><span id="l11.1995" class="difflineplus">+</span>
<a href="#l11.1996"></a><span id="l11.1996" class="difflineplus">+            _tr_tally_dist(s, s-&gt;strstart -1 - s-&gt;prev_match,</span>
<a href="#l11.1997"></a><span id="l11.1997" class="difflineplus">+                           s-&gt;prev_length - MIN_MATCH, bflush);</span>
<a href="#l11.1998"></a><span id="l11.1998" class="difflineplus">+</span>
<a href="#l11.1999"></a><span id="l11.1999" class="difflineplus">+            /* Insert in hash table all strings up to the end of the match.</span>
<a href="#l11.2000"></a><span id="l11.2000" class="difflineplus">+             * strstart-1 and strstart are already inserted. If there is not</span>
<a href="#l11.2001"></a><span id="l11.2001" class="difflineplus">+             * enough lookahead, the last two strings are not inserted in</span>
<a href="#l11.2002"></a><span id="l11.2002" class="difflineplus">+             * the hash table.</span>
<a href="#l11.2003"></a><span id="l11.2003" class="difflineplus">+             */</span>
<a href="#l11.2004"></a><span id="l11.2004" class="difflineplus">+            s-&gt;lookahead -= s-&gt;prev_length-1;</span>
<a href="#l11.2005"></a><span id="l11.2005" class="difflineplus">+            s-&gt;prev_length -= 2;</span>
<a href="#l11.2006"></a><span id="l11.2006" class="difflineplus">+            do {</span>
<a href="#l11.2007"></a><span id="l11.2007" class="difflineplus">+                if (++s-&gt;strstart &lt;= max_insert) {</span>
<a href="#l11.2008"></a><span id="l11.2008" class="difflineplus">+                    INSERT_STRING(s, s-&gt;strstart, hash_head);</span>
<a href="#l11.2009"></a><span id="l11.2009" class="difflineplus">+                }</span>
<a href="#l11.2010"></a><span id="l11.2010" class="difflineplus">+            } while (--s-&gt;prev_length != 0);</span>
<a href="#l11.2011"></a><span id="l11.2011" class="difflineplus">+            s-&gt;match_available = 0;</span>
<a href="#l11.2012"></a><span id="l11.2012" class="difflineplus">+            s-&gt;match_length = MIN_MATCH-1;</span>
<a href="#l11.2013"></a><span id="l11.2013" class="difflineplus">+            s-&gt;strstart++;</span>
<a href="#l11.2014"></a><span id="l11.2014" class="difflineplus">+</span>
<a href="#l11.2015"></a><span id="l11.2015" class="difflineplus">+            if (bflush) FLUSH_BLOCK(s, 0);</span>
<a href="#l11.2016"></a><span id="l11.2016" class="difflineplus">+</span>
<a href="#l11.2017"></a><span id="l11.2017" class="difflineplus">+        } else if (s-&gt;match_available) {</span>
<a href="#l11.2018"></a><span id="l11.2018" class="difflineplus">+            /* If there was no match at the previous position, output a</span>
<a href="#l11.2019"></a><span id="l11.2019" class="difflineplus">+             * single literal. If there was a match but the current match</span>
<a href="#l11.2020"></a><span id="l11.2020" class="difflineplus">+             * is longer, truncate the previous match to a single literal.</span>
<a href="#l11.2021"></a><span id="l11.2021" class="difflineplus">+             */</span>
<a href="#l11.2022"></a><span id="l11.2022" class="difflineplus">+            Tracevv((stderr,&quot;%c&quot;, s-&gt;window[s-&gt;strstart-1]));</span>
<a href="#l11.2023"></a><span id="l11.2023" class="difflineplus">+            _tr_tally_lit(s, s-&gt;window[s-&gt;strstart-1], bflush);</span>
<a href="#l11.2024"></a><span id="l11.2024" class="difflineplus">+            if (bflush) {</span>
<a href="#l11.2025"></a><span id="l11.2025" class="difflineplus">+                FLUSH_BLOCK_ONLY(s, 0);</span>
<a href="#l11.2026"></a><span id="l11.2026" class="difflineplus">+            }</span>
<a href="#l11.2027"></a><span id="l11.2027" class="difflineplus">+            s-&gt;strstart++;</span>
<a href="#l11.2028"></a><span id="l11.2028" class="difflineplus">+            s-&gt;lookahead--;</span>
<a href="#l11.2029"></a><span id="l11.2029" class="difflineplus">+            if (s-&gt;strm-&gt;avail_out == 0) return need_more;</span>
<a href="#l11.2030"></a><span id="l11.2030" class="difflineplus">+        } else {</span>
<a href="#l11.2031"></a><span id="l11.2031" class="difflineplus">+            /* There is no previous match to compare with, wait for</span>
<a href="#l11.2032"></a><span id="l11.2032" class="difflineplus">+             * the next step to decide.</span>
<a href="#l11.2033"></a><span id="l11.2033" class="difflineplus">+             */</span>
<a href="#l11.2034"></a><span id="l11.2034" class="difflineplus">+            s-&gt;match_available = 1;</span>
<a href="#l11.2035"></a><span id="l11.2035" class="difflineplus">+            s-&gt;strstart++;</span>
<a href="#l11.2036"></a><span id="l11.2036" class="difflineplus">+            s-&gt;lookahead--;</span>
<a href="#l11.2037"></a><span id="l11.2037" class="difflineplus">+        }</span>
<a href="#l11.2038"></a><span id="l11.2038" class="difflineplus">+    }</span>
<a href="#l11.2039"></a><span id="l11.2039" class="difflineplus">+    Assert (flush != Z_NO_FLUSH, &quot;no flush?&quot;);</span>
<a href="#l11.2040"></a><span id="l11.2040" class="difflineplus">+    if (s-&gt;match_available) {</span>
<a href="#l11.2041"></a><span id="l11.2041" class="difflineplus">+        Tracevv((stderr,&quot;%c&quot;, s-&gt;window[s-&gt;strstart-1]));</span>
<a href="#l11.2042"></a><span id="l11.2042" class="difflineplus">+        _tr_tally_lit(s, s-&gt;window[s-&gt;strstart-1], bflush);</span>
<a href="#l11.2043"></a><span id="l11.2043" class="difflineplus">+        s-&gt;match_available = 0;</span>
<a href="#l11.2044"></a><span id="l11.2044" class="difflineplus">+    }</span>
<a href="#l11.2045"></a><span id="l11.2045" class="difflineplus">+    s-&gt;insert = s-&gt;strstart &lt; MIN_MATCH-1 ? s-&gt;strstart : MIN_MATCH-1;</span>
<a href="#l11.2046"></a><span id="l11.2046" class="difflineplus">+    if (flush == Z_FINISH) {</span>
<a href="#l11.2047"></a><span id="l11.2047" class="difflineplus">+        FLUSH_BLOCK(s, 1);</span>
<a href="#l11.2048"></a><span id="l11.2048" class="difflineplus">+        return finish_done;</span>
<a href="#l11.2049"></a><span id="l11.2049" class="difflineplus">+    }</span>
<a href="#l11.2050"></a><span id="l11.2050" class="difflineplus">+    if (s-&gt;last_lit)</span>
<a href="#l11.2051"></a><span id="l11.2051" class="difflineplus">+        FLUSH_BLOCK(s, 0);</span>
<a href="#l11.2052"></a><span id="l11.2052" class="difflineplus">+    return block_done;</span>
<a href="#l11.2053"></a><span id="l11.2053" class="difflineplus">+}</span>
<a href="#l11.2054"></a><span id="l11.2054" class="difflineplus">+#endif /* FASTEST */</span>
<a href="#l11.2055"></a><span id="l11.2055" class="difflineplus">+</span>
<a href="#l11.2056"></a><span id="l11.2056" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.2057"></a><span id="l11.2057" class="difflineplus">+ * For Z_RLE, simply look for runs of bytes, generate matches only of distance</span>
<a href="#l11.2058"></a><span id="l11.2058" class="difflineplus">+ * one.  Do not maintain a hash table.  (It will be regenerated if this run of</span>
<a href="#l11.2059"></a><span id="l11.2059" class="difflineplus">+ * deflate switches away from Z_RLE.)</span>
<a href="#l11.2060"></a><span id="l11.2060" class="difflineplus">+ */</span>
<a href="#l11.2061"></a><span id="l11.2061" class="difflineplus">+local block_state deflate_rle(s, flush)</span>
<a href="#l11.2062"></a><span id="l11.2062" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.2063"></a><span id="l11.2063" class="difflineplus">+    int flush;</span>
<a href="#l11.2064"></a><span id="l11.2064" class="difflineplus">+{</span>
<a href="#l11.2065"></a><span id="l11.2065" class="difflineplus">+    int bflush;             /* set if current block must be flushed */</span>
<a href="#l11.2066"></a><span id="l11.2066" class="difflineplus">+    uInt prev;              /* byte at distance one to match */</span>
<a href="#l11.2067"></a><span id="l11.2067" class="difflineplus">+    Bytef *scan, *strend;   /* scan goes up to strend for length of run */</span>
<a href="#l11.2068"></a><span id="l11.2068" class="difflineplus">+</span>
<a href="#l11.2069"></a><span id="l11.2069" class="difflineplus">+    for (;;) {</span>
<a href="#l11.2070"></a><span id="l11.2070" class="difflineplus">+        /* Make sure that we always have enough lookahead, except</span>
<a href="#l11.2071"></a><span id="l11.2071" class="difflineplus">+         * at the end of the input file. We need MAX_MATCH bytes</span>
<a href="#l11.2072"></a><span id="l11.2072" class="difflineplus">+         * for the longest run, plus one for the unrolled loop.</span>
<a href="#l11.2073"></a><span id="l11.2073" class="difflineplus">+         */</span>
<a href="#l11.2074"></a><span id="l11.2074" class="difflineplus">+        if (s-&gt;lookahead &lt;= MAX_MATCH) {</span>
<a href="#l11.2075"></a><span id="l11.2075" class="difflineplus">+            fill_window(s);</span>
<a href="#l11.2076"></a><span id="l11.2076" class="difflineplus">+            if (s-&gt;lookahead &lt;= MAX_MATCH &amp;&amp; flush == Z_NO_FLUSH) {</span>
<a href="#l11.2077"></a><span id="l11.2077" class="difflineplus">+                return need_more;</span>
<a href="#l11.2078"></a><span id="l11.2078" class="difflineplus">+            }</span>
<a href="#l11.2079"></a><span id="l11.2079" class="difflineplus">+            if (s-&gt;lookahead == 0) break; /* flush the current block */</span>
<a href="#l11.2080"></a><span id="l11.2080" class="difflineplus">+        }</span>
<a href="#l11.2081"></a><span id="l11.2081" class="difflineplus">+</span>
<a href="#l11.2082"></a><span id="l11.2082" class="difflineplus">+        /* See how many times the previous byte repeats */</span>
<a href="#l11.2083"></a><span id="l11.2083" class="difflineplus">+        s-&gt;match_length = 0;</span>
<a href="#l11.2084"></a><span id="l11.2084" class="difflineplus">+        if (s-&gt;lookahead &gt;= MIN_MATCH &amp;&amp; s-&gt;strstart &gt; 0) {</span>
<a href="#l11.2085"></a><span id="l11.2085" class="difflineplus">+            scan = s-&gt;window + s-&gt;strstart - 1;</span>
<a href="#l11.2086"></a><span id="l11.2086" class="difflineplus">+            prev = *scan;</span>
<a href="#l11.2087"></a><span id="l11.2087" class="difflineplus">+            if (prev == *++scan &amp;&amp; prev == *++scan &amp;&amp; prev == *++scan) {</span>
<a href="#l11.2088"></a><span id="l11.2088" class="difflineplus">+                strend = s-&gt;window + s-&gt;strstart + MAX_MATCH;</span>
<a href="#l11.2089"></a><span id="l11.2089" class="difflineplus">+                do {</span>
<a href="#l11.2090"></a><span id="l11.2090" class="difflineplus">+                } while (prev == *++scan &amp;&amp; prev == *++scan &amp;&amp;</span>
<a href="#l11.2091"></a><span id="l11.2091" class="difflineplus">+                         prev == *++scan &amp;&amp; prev == *++scan &amp;&amp;</span>
<a href="#l11.2092"></a><span id="l11.2092" class="difflineplus">+                         prev == *++scan &amp;&amp; prev == *++scan &amp;&amp;</span>
<a href="#l11.2093"></a><span id="l11.2093" class="difflineplus">+                         prev == *++scan &amp;&amp; prev == *++scan &amp;&amp;</span>
<a href="#l11.2094"></a><span id="l11.2094" class="difflineplus">+                         scan &lt; strend);</span>
<a href="#l11.2095"></a><span id="l11.2095" class="difflineplus">+                s-&gt;match_length = MAX_MATCH - (uInt)(strend - scan);</span>
<a href="#l11.2096"></a><span id="l11.2096" class="difflineplus">+                if (s-&gt;match_length &gt; s-&gt;lookahead)</span>
<a href="#l11.2097"></a><span id="l11.2097" class="difflineplus">+                    s-&gt;match_length = s-&gt;lookahead;</span>
<a href="#l11.2098"></a><span id="l11.2098" class="difflineplus">+            }</span>
<a href="#l11.2099"></a><span id="l11.2099" class="difflineplus">+            Assert(scan &lt;= s-&gt;window+(uInt)(s-&gt;window_size-1), &quot;wild scan&quot;);</span>
<a href="#l11.2100"></a><span id="l11.2100" class="difflineplus">+        }</span>
<a href="#l11.2101"></a><span id="l11.2101" class="difflineplus">+</span>
<a href="#l11.2102"></a><span id="l11.2102" class="difflineplus">+        /* Emit match if have run of MIN_MATCH or longer, else emit literal */</span>
<a href="#l11.2103"></a><span id="l11.2103" class="difflineplus">+        if (s-&gt;match_length &gt;= MIN_MATCH) {</span>
<a href="#l11.2104"></a><span id="l11.2104" class="difflineplus">+            check_match(s, s-&gt;strstart, s-&gt;strstart - 1, s-&gt;match_length);</span>
<a href="#l11.2105"></a><span id="l11.2105" class="difflineplus">+</span>
<a href="#l11.2106"></a><span id="l11.2106" class="difflineplus">+            _tr_tally_dist(s, 1, s-&gt;match_length - MIN_MATCH, bflush);</span>
<a href="#l11.2107"></a><span id="l11.2107" class="difflineplus">+</span>
<a href="#l11.2108"></a><span id="l11.2108" class="difflineplus">+            s-&gt;lookahead -= s-&gt;match_length;</span>
<a href="#l11.2109"></a><span id="l11.2109" class="difflineplus">+            s-&gt;strstart += s-&gt;match_length;</span>
<a href="#l11.2110"></a><span id="l11.2110" class="difflineplus">+            s-&gt;match_length = 0;</span>
<a href="#l11.2111"></a><span id="l11.2111" class="difflineplus">+        } else {</span>
<a href="#l11.2112"></a><span id="l11.2112" class="difflineplus">+            /* No match, output a literal byte */</span>
<a href="#l11.2113"></a><span id="l11.2113" class="difflineplus">+            Tracevv((stderr,&quot;%c&quot;, s-&gt;window[s-&gt;strstart]));</span>
<a href="#l11.2114"></a><span id="l11.2114" class="difflineplus">+            _tr_tally_lit (s, s-&gt;window[s-&gt;strstart], bflush);</span>
<a href="#l11.2115"></a><span id="l11.2115" class="difflineplus">+            s-&gt;lookahead--;</span>
<a href="#l11.2116"></a><span id="l11.2116" class="difflineplus">+            s-&gt;strstart++;</span>
<a href="#l11.2117"></a><span id="l11.2117" class="difflineplus">+        }</span>
<a href="#l11.2118"></a><span id="l11.2118" class="difflineplus">+        if (bflush) FLUSH_BLOCK(s, 0);</span>
<a href="#l11.2119"></a><span id="l11.2119" class="difflineplus">+    }</span>
<a href="#l11.2120"></a><span id="l11.2120" class="difflineplus">+    s-&gt;insert = 0;</span>
<a href="#l11.2121"></a><span id="l11.2121" class="difflineplus">+    if (flush == Z_FINISH) {</span>
<a href="#l11.2122"></a><span id="l11.2122" class="difflineplus">+        FLUSH_BLOCK(s, 1);</span>
<a href="#l11.2123"></a><span id="l11.2123" class="difflineplus">+        return finish_done;</span>
<a href="#l11.2124"></a><span id="l11.2124" class="difflineplus">+    }</span>
<a href="#l11.2125"></a><span id="l11.2125" class="difflineplus">+    if (s-&gt;last_lit)</span>
<a href="#l11.2126"></a><span id="l11.2126" class="difflineplus">+        FLUSH_BLOCK(s, 0);</span>
<a href="#l11.2127"></a><span id="l11.2127" class="difflineplus">+    return block_done;</span>
<a href="#l11.2128"></a><span id="l11.2128" class="difflineplus">+}</span>
<a href="#l11.2129"></a><span id="l11.2129" class="difflineplus">+</span>
<a href="#l11.2130"></a><span id="l11.2130" class="difflineplus">+/* ===========================================================================</span>
<a href="#l11.2131"></a><span id="l11.2131" class="difflineplus">+ * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.</span>
<a href="#l11.2132"></a><span id="l11.2132" class="difflineplus">+ * (It will be regenerated if this run of deflate switches away from Huffman.)</span>
<a href="#l11.2133"></a><span id="l11.2133" class="difflineplus">+ */</span>
<a href="#l11.2134"></a><span id="l11.2134" class="difflineplus">+local block_state deflate_huff(s, flush)</span>
<a href="#l11.2135"></a><span id="l11.2135" class="difflineplus">+    deflate_state *s;</span>
<a href="#l11.2136"></a><span id="l11.2136" class="difflineplus">+    int flush;</span>
<a href="#l11.2137"></a><span id="l11.2137" class="difflineplus">+{</span>
<a href="#l11.2138"></a><span id="l11.2138" class="difflineplus">+    int bflush;             /* set if current block must be flushed */</span>
<a href="#l11.2139"></a><span id="l11.2139" class="difflineplus">+</span>
<a href="#l11.2140"></a><span id="l11.2140" class="difflineplus">+    for (;;) {</span>
<a href="#l11.2141"></a><span id="l11.2141" class="difflineplus">+        /* Make sure that we have a literal to write. */</span>
<a href="#l11.2142"></a><span id="l11.2142" class="difflineplus">+        if (s-&gt;lookahead == 0) {</span>
<a href="#l11.2143"></a><span id="l11.2143" class="difflineplus">+            fill_window(s);</span>
<a href="#l11.2144"></a><span id="l11.2144" class="difflineplus">+            if (s-&gt;lookahead == 0) {</span>
<a href="#l11.2145"></a><span id="l11.2145" class="difflineplus">+                if (flush == Z_NO_FLUSH)</span>
<a href="#l11.2146"></a><span id="l11.2146" class="difflineplus">+                    return need_more;</span>
<a href="#l11.2147"></a><span id="l11.2147" class="difflineplus">+                break;      /* flush the current block */</span>
<a href="#l11.2148"></a><span id="l11.2148" class="difflineplus">+            }</span>
<a href="#l11.2149"></a><span id="l11.2149" class="difflineplus">+        }</span>
<a href="#l11.2150"></a><span id="l11.2150" class="difflineplus">+</span>
<a href="#l11.2151"></a><span id="l11.2151" class="difflineplus">+        /* Output a literal byte */</span>
<a href="#l11.2152"></a><span id="l11.2152" class="difflineplus">+        s-&gt;match_length = 0;</span>
<a href="#l11.2153"></a><span id="l11.2153" class="difflineplus">+        Tracevv((stderr,&quot;%c&quot;, s-&gt;window[s-&gt;strstart]));</span>
<a href="#l11.2154"></a><span id="l11.2154" class="difflineplus">+        _tr_tally_lit (s, s-&gt;window[s-&gt;strstart], bflush);</span>
<a href="#l11.2155"></a><span id="l11.2155" class="difflineplus">+        s-&gt;lookahead--;</span>
<a href="#l11.2156"></a><span id="l11.2156" class="difflineplus">+        s-&gt;strstart++;</span>
<a href="#l11.2157"></a><span id="l11.2157" class="difflineplus">+        if (bflush) FLUSH_BLOCK(s, 0);</span>
<a href="#l11.2158"></a><span id="l11.2158" class="difflineplus">+    }</span>
<a href="#l11.2159"></a><span id="l11.2159" class="difflineplus">+    s-&gt;insert = 0;</span>
<a href="#l11.2160"></a><span id="l11.2160" class="difflineplus">+    if (flush == Z_FINISH) {</span>
<a href="#l11.2161"></a><span id="l11.2161" class="difflineplus">+        FLUSH_BLOCK(s, 1);</span>
<a href="#l11.2162"></a><span id="l11.2162" class="difflineplus">+        return finish_done;</span>
<a href="#l11.2163"></a><span id="l11.2163" class="difflineplus">+    }</span>
<a href="#l11.2164"></a><span id="l11.2164" class="difflineplus">+    if (s-&gt;last_lit)</span>
<a href="#l11.2165"></a><span id="l11.2165" class="difflineplus">+        FLUSH_BLOCK(s, 0);</span>
<a href="#l11.2166"></a><span id="l11.2166" class="difflineplus">+    return block_done;</span>
<a href="#l11.2167"></a><span id="l11.2167" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1">new file mode 100644</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineminus">--- /dev/null</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineplus">+++ b/third_party/zlib/deflate.h</span>
<a href="#l12.4"></a><span id="l12.4" class="difflineat">@@ -0,0 +1,349 @@</span>
<a href="#l12.5"></a><span id="l12.5" class="difflineplus">+/* deflate.h -- internal compression state</span>
<a href="#l12.6"></a><span id="l12.6" class="difflineplus">+ * Copyright (C) 1995-2016 Jean-loup Gailly</span>
<a href="#l12.7"></a><span id="l12.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l12.8"></a><span id="l12.8" class="difflineplus">+ */</span>
<a href="#l12.9"></a><span id="l12.9" class="difflineplus">+</span>
<a href="#l12.10"></a><span id="l12.10" class="difflineplus">+/* WARNING: this file should *not* be used by applications. It is</span>
<a href="#l12.11"></a><span id="l12.11" class="difflineplus">+   part of the implementation of the compression library and is</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineplus">+   subject to change. Applications should only use zlib.h.</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineplus">+ */</span>
<a href="#l12.14"></a><span id="l12.14" class="difflineplus">+</span>
<a href="#l12.15"></a><span id="l12.15" class="difflineplus">+/* @(#) $Id$ */</span>
<a href="#l12.16"></a><span id="l12.16" class="difflineplus">+</span>
<a href="#l12.17"></a><span id="l12.17" class="difflineplus">+#ifndef DEFLATE_H</span>
<a href="#l12.18"></a><span id="l12.18" class="difflineplus">+#define DEFLATE_H</span>
<a href="#l12.19"></a><span id="l12.19" class="difflineplus">+</span>
<a href="#l12.20"></a><span id="l12.20" class="difflineplus">+#include &quot;zutil.h&quot;</span>
<a href="#l12.21"></a><span id="l12.21" class="difflineplus">+</span>
<a href="#l12.22"></a><span id="l12.22" class="difflineplus">+/* define NO_GZIP when compiling if you want to disable gzip header and</span>
<a href="#l12.23"></a><span id="l12.23" class="difflineplus">+   trailer creation by deflate().  NO_GZIP would be used to avoid linking in</span>
<a href="#l12.24"></a><span id="l12.24" class="difflineplus">+   the crc code when it is not needed.  For shared libraries, gzip encoding</span>
<a href="#l12.25"></a><span id="l12.25" class="difflineplus">+   should be left enabled. */</span>
<a href="#l12.26"></a><span id="l12.26" class="difflineplus">+#ifndef NO_GZIP</span>
<a href="#l12.27"></a><span id="l12.27" class="difflineplus">+#  define GZIP</span>
<a href="#l12.28"></a><span id="l12.28" class="difflineplus">+#endif</span>
<a href="#l12.29"></a><span id="l12.29" class="difflineplus">+</span>
<a href="#l12.30"></a><span id="l12.30" class="difflineplus">+/* ===========================================================================</span>
<a href="#l12.31"></a><span id="l12.31" class="difflineplus">+ * Internal compression state.</span>
<a href="#l12.32"></a><span id="l12.32" class="difflineplus">+ */</span>
<a href="#l12.33"></a><span id="l12.33" class="difflineplus">+</span>
<a href="#l12.34"></a><span id="l12.34" class="difflineplus">+#define LENGTH_CODES 29</span>
<a href="#l12.35"></a><span id="l12.35" class="difflineplus">+/* number of length codes, not counting the special END_BLOCK code */</span>
<a href="#l12.36"></a><span id="l12.36" class="difflineplus">+</span>
<a href="#l12.37"></a><span id="l12.37" class="difflineplus">+#define LITERALS  256</span>
<a href="#l12.38"></a><span id="l12.38" class="difflineplus">+/* number of literal bytes 0..255 */</span>
<a href="#l12.39"></a><span id="l12.39" class="difflineplus">+</span>
<a href="#l12.40"></a><span id="l12.40" class="difflineplus">+#define L_CODES (LITERALS+1+LENGTH_CODES)</span>
<a href="#l12.41"></a><span id="l12.41" class="difflineplus">+/* number of Literal or Length codes, including the END_BLOCK code */</span>
<a href="#l12.42"></a><span id="l12.42" class="difflineplus">+</span>
<a href="#l12.43"></a><span id="l12.43" class="difflineplus">+#define D_CODES   30</span>
<a href="#l12.44"></a><span id="l12.44" class="difflineplus">+/* number of distance codes */</span>
<a href="#l12.45"></a><span id="l12.45" class="difflineplus">+</span>
<a href="#l12.46"></a><span id="l12.46" class="difflineplus">+#define BL_CODES  19</span>
<a href="#l12.47"></a><span id="l12.47" class="difflineplus">+/* number of codes used to transfer the bit lengths */</span>
<a href="#l12.48"></a><span id="l12.48" class="difflineplus">+</span>
<a href="#l12.49"></a><span id="l12.49" class="difflineplus">+#define HEAP_SIZE (2*L_CODES+1)</span>
<a href="#l12.50"></a><span id="l12.50" class="difflineplus">+/* maximum heap size */</span>
<a href="#l12.51"></a><span id="l12.51" class="difflineplus">+</span>
<a href="#l12.52"></a><span id="l12.52" class="difflineplus">+#define MAX_BITS 15</span>
<a href="#l12.53"></a><span id="l12.53" class="difflineplus">+/* All codes must not exceed MAX_BITS bits */</span>
<a href="#l12.54"></a><span id="l12.54" class="difflineplus">+</span>
<a href="#l12.55"></a><span id="l12.55" class="difflineplus">+#define Buf_size 16</span>
<a href="#l12.56"></a><span id="l12.56" class="difflineplus">+/* size of bit buffer in bi_buf */</span>
<a href="#l12.57"></a><span id="l12.57" class="difflineplus">+</span>
<a href="#l12.58"></a><span id="l12.58" class="difflineplus">+#define INIT_STATE    42    /* zlib header -&gt; BUSY_STATE */</span>
<a href="#l12.59"></a><span id="l12.59" class="difflineplus">+#ifdef GZIP</span>
<a href="#l12.60"></a><span id="l12.60" class="difflineplus">+#  define GZIP_STATE  57    /* gzip header -&gt; BUSY_STATE | EXTRA_STATE */</span>
<a href="#l12.61"></a><span id="l12.61" class="difflineplus">+#endif</span>
<a href="#l12.62"></a><span id="l12.62" class="difflineplus">+#define EXTRA_STATE   69    /* gzip extra block -&gt; NAME_STATE */</span>
<a href="#l12.63"></a><span id="l12.63" class="difflineplus">+#define NAME_STATE    73    /* gzip file name -&gt; COMMENT_STATE */</span>
<a href="#l12.64"></a><span id="l12.64" class="difflineplus">+#define COMMENT_STATE 91    /* gzip comment -&gt; HCRC_STATE */</span>
<a href="#l12.65"></a><span id="l12.65" class="difflineplus">+#define HCRC_STATE   103    /* gzip header CRC -&gt; BUSY_STATE */</span>
<a href="#l12.66"></a><span id="l12.66" class="difflineplus">+#define BUSY_STATE   113    /* deflate -&gt; FINISH_STATE */</span>
<a href="#l12.67"></a><span id="l12.67" class="difflineplus">+#define FINISH_STATE 666    /* stream complete */</span>
<a href="#l12.68"></a><span id="l12.68" class="difflineplus">+/* Stream status */</span>
<a href="#l12.69"></a><span id="l12.69" class="difflineplus">+</span>
<a href="#l12.70"></a><span id="l12.70" class="difflineplus">+</span>
<a href="#l12.71"></a><span id="l12.71" class="difflineplus">+/* Data structure describing a single value and its code string. */</span>
<a href="#l12.72"></a><span id="l12.72" class="difflineplus">+typedef struct ct_data_s {</span>
<a href="#l12.73"></a><span id="l12.73" class="difflineplus">+    union {</span>
<a href="#l12.74"></a><span id="l12.74" class="difflineplus">+        ush  freq;       /* frequency count */</span>
<a href="#l12.75"></a><span id="l12.75" class="difflineplus">+        ush  code;       /* bit string */</span>
<a href="#l12.76"></a><span id="l12.76" class="difflineplus">+    } fc;</span>
<a href="#l12.77"></a><span id="l12.77" class="difflineplus">+    union {</span>
<a href="#l12.78"></a><span id="l12.78" class="difflineplus">+        ush  dad;        /* father node in Huffman tree */</span>
<a href="#l12.79"></a><span id="l12.79" class="difflineplus">+        ush  len;        /* length of bit string */</span>
<a href="#l12.80"></a><span id="l12.80" class="difflineplus">+    } dl;</span>
<a href="#l12.81"></a><span id="l12.81" class="difflineplus">+} FAR ct_data;</span>
<a href="#l12.82"></a><span id="l12.82" class="difflineplus">+</span>
<a href="#l12.83"></a><span id="l12.83" class="difflineplus">+#define Freq fc.freq</span>
<a href="#l12.84"></a><span id="l12.84" class="difflineplus">+#define Code fc.code</span>
<a href="#l12.85"></a><span id="l12.85" class="difflineplus">+#define Dad  dl.dad</span>
<a href="#l12.86"></a><span id="l12.86" class="difflineplus">+#define Len  dl.len</span>
<a href="#l12.87"></a><span id="l12.87" class="difflineplus">+</span>
<a href="#l12.88"></a><span id="l12.88" class="difflineplus">+typedef struct static_tree_desc_s  static_tree_desc;</span>
<a href="#l12.89"></a><span id="l12.89" class="difflineplus">+</span>
<a href="#l12.90"></a><span id="l12.90" class="difflineplus">+typedef struct tree_desc_s {</span>
<a href="#l12.91"></a><span id="l12.91" class="difflineplus">+    ct_data *dyn_tree;           /* the dynamic tree */</span>
<a href="#l12.92"></a><span id="l12.92" class="difflineplus">+    int     max_code;            /* largest code with non zero frequency */</span>
<a href="#l12.93"></a><span id="l12.93" class="difflineplus">+    const static_tree_desc *stat_desc;  /* the corresponding static tree */</span>
<a href="#l12.94"></a><span id="l12.94" class="difflineplus">+} FAR tree_desc;</span>
<a href="#l12.95"></a><span id="l12.95" class="difflineplus">+</span>
<a href="#l12.96"></a><span id="l12.96" class="difflineplus">+typedef ush Pos;</span>
<a href="#l12.97"></a><span id="l12.97" class="difflineplus">+typedef Pos FAR Posf;</span>
<a href="#l12.98"></a><span id="l12.98" class="difflineplus">+typedef unsigned IPos;</span>
<a href="#l12.99"></a><span id="l12.99" class="difflineplus">+</span>
<a href="#l12.100"></a><span id="l12.100" class="difflineplus">+/* A Pos is an index in the character window. We use short instead of int to</span>
<a href="#l12.101"></a><span id="l12.101" class="difflineplus">+ * save space in the various tables. IPos is used only for parameter passing.</span>
<a href="#l12.102"></a><span id="l12.102" class="difflineplus">+ */</span>
<a href="#l12.103"></a><span id="l12.103" class="difflineplus">+</span>
<a href="#l12.104"></a><span id="l12.104" class="difflineplus">+typedef struct internal_state {</span>
<a href="#l12.105"></a><span id="l12.105" class="difflineplus">+    z_streamp strm;      /* pointer back to this zlib stream */</span>
<a href="#l12.106"></a><span id="l12.106" class="difflineplus">+    int   status;        /* as the name implies */</span>
<a href="#l12.107"></a><span id="l12.107" class="difflineplus">+    Bytef *pending_buf;  /* output still pending */</span>
<a href="#l12.108"></a><span id="l12.108" class="difflineplus">+    ulg   pending_buf_size; /* size of pending_buf */</span>
<a href="#l12.109"></a><span id="l12.109" class="difflineplus">+    Bytef *pending_out;  /* next pending byte to output to the stream */</span>
<a href="#l12.110"></a><span id="l12.110" class="difflineplus">+    ulg   pending;       /* nb of bytes in the pending buffer */</span>
<a href="#l12.111"></a><span id="l12.111" class="difflineplus">+    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */</span>
<a href="#l12.112"></a><span id="l12.112" class="difflineplus">+    gz_headerp  gzhead;  /* gzip header information to write */</span>
<a href="#l12.113"></a><span id="l12.113" class="difflineplus">+    ulg   gzindex;       /* where in extra, name, or comment */</span>
<a href="#l12.114"></a><span id="l12.114" class="difflineplus">+    Byte  method;        /* can only be DEFLATED */</span>
<a href="#l12.115"></a><span id="l12.115" class="difflineplus">+    int   last_flush;    /* value of flush param for previous deflate call */</span>
<a href="#l12.116"></a><span id="l12.116" class="difflineplus">+</span>
<a href="#l12.117"></a><span id="l12.117" class="difflineplus">+                /* used by deflate.c: */</span>
<a href="#l12.118"></a><span id="l12.118" class="difflineplus">+</span>
<a href="#l12.119"></a><span id="l12.119" class="difflineplus">+    uInt  w_size;        /* LZ77 window size (32K by default) */</span>
<a href="#l12.120"></a><span id="l12.120" class="difflineplus">+    uInt  w_bits;        /* log2(w_size)  (8..16) */</span>
<a href="#l12.121"></a><span id="l12.121" class="difflineplus">+    uInt  w_mask;        /* w_size - 1 */</span>
<a href="#l12.122"></a><span id="l12.122" class="difflineplus">+</span>
<a href="#l12.123"></a><span id="l12.123" class="difflineplus">+    Bytef *window;</span>
<a href="#l12.124"></a><span id="l12.124" class="difflineplus">+    /* Sliding window. Input bytes are read into the second half of the window,</span>
<a href="#l12.125"></a><span id="l12.125" class="difflineplus">+     * and move to the first half later to keep a dictionary of at least wSize</span>
<a href="#l12.126"></a><span id="l12.126" class="difflineplus">+     * bytes. With this organization, matches are limited to a distance of</span>
<a href="#l12.127"></a><span id="l12.127" class="difflineplus">+     * wSize-MAX_MATCH bytes, but this ensures that IO is always</span>
<a href="#l12.128"></a><span id="l12.128" class="difflineplus">+     * performed with a length multiple of the block size. Also, it limits</span>
<a href="#l12.129"></a><span id="l12.129" class="difflineplus">+     * the window size to 64K, which is quite useful on MSDOS.</span>
<a href="#l12.130"></a><span id="l12.130" class="difflineplus">+     * To do: use the user input buffer as sliding window.</span>
<a href="#l12.131"></a><span id="l12.131" class="difflineplus">+     */</span>
<a href="#l12.132"></a><span id="l12.132" class="difflineplus">+</span>
<a href="#l12.133"></a><span id="l12.133" class="difflineplus">+    ulg window_size;</span>
<a href="#l12.134"></a><span id="l12.134" class="difflineplus">+    /* Actual size of window: 2*wSize, except when the user input buffer</span>
<a href="#l12.135"></a><span id="l12.135" class="difflineplus">+     * is directly used as sliding window.</span>
<a href="#l12.136"></a><span id="l12.136" class="difflineplus">+     */</span>
<a href="#l12.137"></a><span id="l12.137" class="difflineplus">+</span>
<a href="#l12.138"></a><span id="l12.138" class="difflineplus">+    Posf *prev;</span>
<a href="#l12.139"></a><span id="l12.139" class="difflineplus">+    /* Link to older string with same hash index. To limit the size of this</span>
<a href="#l12.140"></a><span id="l12.140" class="difflineplus">+     * array to 64K, this link is maintained only for the last 32K strings.</span>
<a href="#l12.141"></a><span id="l12.141" class="difflineplus">+     * An index in this array is thus a window index modulo 32K.</span>
<a href="#l12.142"></a><span id="l12.142" class="difflineplus">+     */</span>
<a href="#l12.143"></a><span id="l12.143" class="difflineplus">+</span>
<a href="#l12.144"></a><span id="l12.144" class="difflineplus">+    Posf *head; /* Heads of the hash chains or NIL. */</span>
<a href="#l12.145"></a><span id="l12.145" class="difflineplus">+</span>
<a href="#l12.146"></a><span id="l12.146" class="difflineplus">+    uInt  ins_h;          /* hash index of string to be inserted */</span>
<a href="#l12.147"></a><span id="l12.147" class="difflineplus">+    uInt  hash_size;      /* number of elements in hash table */</span>
<a href="#l12.148"></a><span id="l12.148" class="difflineplus">+    uInt  hash_bits;      /* log2(hash_size) */</span>
<a href="#l12.149"></a><span id="l12.149" class="difflineplus">+    uInt  hash_mask;      /* hash_size-1 */</span>
<a href="#l12.150"></a><span id="l12.150" class="difflineplus">+</span>
<a href="#l12.151"></a><span id="l12.151" class="difflineplus">+    uInt  hash_shift;</span>
<a href="#l12.152"></a><span id="l12.152" class="difflineplus">+    /* Number of bits by which ins_h must be shifted at each input</span>
<a href="#l12.153"></a><span id="l12.153" class="difflineplus">+     * step. It must be such that after MIN_MATCH steps, the oldest</span>
<a href="#l12.154"></a><span id="l12.154" class="difflineplus">+     * byte no longer takes part in the hash key, that is:</span>
<a href="#l12.155"></a><span id="l12.155" class="difflineplus">+     *   hash_shift * MIN_MATCH &gt;= hash_bits</span>
<a href="#l12.156"></a><span id="l12.156" class="difflineplus">+     */</span>
<a href="#l12.157"></a><span id="l12.157" class="difflineplus">+</span>
<a href="#l12.158"></a><span id="l12.158" class="difflineplus">+    long block_start;</span>
<a href="#l12.159"></a><span id="l12.159" class="difflineplus">+    /* Window position at the beginning of the current output block. Gets</span>
<a href="#l12.160"></a><span id="l12.160" class="difflineplus">+     * negative when the window is moved backwards.</span>
<a href="#l12.161"></a><span id="l12.161" class="difflineplus">+     */</span>
<a href="#l12.162"></a><span id="l12.162" class="difflineplus">+</span>
<a href="#l12.163"></a><span id="l12.163" class="difflineplus">+    uInt match_length;           /* length of best match */</span>
<a href="#l12.164"></a><span id="l12.164" class="difflineplus">+    IPos prev_match;             /* previous match */</span>
<a href="#l12.165"></a><span id="l12.165" class="difflineplus">+    int match_available;         /* set if previous match exists */</span>
<a href="#l12.166"></a><span id="l12.166" class="difflineplus">+    uInt strstart;               /* start of string to insert */</span>
<a href="#l12.167"></a><span id="l12.167" class="difflineplus">+    uInt match_start;            /* start of matching string */</span>
<a href="#l12.168"></a><span id="l12.168" class="difflineplus">+    uInt lookahead;              /* number of valid bytes ahead in window */</span>
<a href="#l12.169"></a><span id="l12.169" class="difflineplus">+</span>
<a href="#l12.170"></a><span id="l12.170" class="difflineplus">+    uInt prev_length;</span>
<a href="#l12.171"></a><span id="l12.171" class="difflineplus">+    /* Length of the best match at previous step. Matches not greater than this</span>
<a href="#l12.172"></a><span id="l12.172" class="difflineplus">+     * are discarded. This is used in the lazy match evaluation.</span>
<a href="#l12.173"></a><span id="l12.173" class="difflineplus">+     */</span>
<a href="#l12.174"></a><span id="l12.174" class="difflineplus">+</span>
<a href="#l12.175"></a><span id="l12.175" class="difflineplus">+    uInt max_chain_length;</span>
<a href="#l12.176"></a><span id="l12.176" class="difflineplus">+    /* To speed up deflation, hash chains are never searched beyond this</span>
<a href="#l12.177"></a><span id="l12.177" class="difflineplus">+     * length.  A higher limit improves compression ratio but degrades the</span>
<a href="#l12.178"></a><span id="l12.178" class="difflineplus">+     * speed.</span>
<a href="#l12.179"></a><span id="l12.179" class="difflineplus">+     */</span>
<a href="#l12.180"></a><span id="l12.180" class="difflineplus">+</span>
<a href="#l12.181"></a><span id="l12.181" class="difflineplus">+    uInt max_lazy_match;</span>
<a href="#l12.182"></a><span id="l12.182" class="difflineplus">+    /* Attempt to find a better match only when the current match is strictly</span>
<a href="#l12.183"></a><span id="l12.183" class="difflineplus">+     * smaller than this value. This mechanism is used only for compression</span>
<a href="#l12.184"></a><span id="l12.184" class="difflineplus">+     * levels &gt;= 4.</span>
<a href="#l12.185"></a><span id="l12.185" class="difflineplus">+     */</span>
<a href="#l12.186"></a><span id="l12.186" class="difflineplus">+#   define max_insert_length  max_lazy_match</span>
<a href="#l12.187"></a><span id="l12.187" class="difflineplus">+    /* Insert new strings in the hash table only if the match length is not</span>
<a href="#l12.188"></a><span id="l12.188" class="difflineplus">+     * greater than this length. This saves time but degrades compression.</span>
<a href="#l12.189"></a><span id="l12.189" class="difflineplus">+     * max_insert_length is used only for compression levels &lt;= 3.</span>
<a href="#l12.190"></a><span id="l12.190" class="difflineplus">+     */</span>
<a href="#l12.191"></a><span id="l12.191" class="difflineplus">+</span>
<a href="#l12.192"></a><span id="l12.192" class="difflineplus">+    int level;    /* compression level (1..9) */</span>
<a href="#l12.193"></a><span id="l12.193" class="difflineplus">+    int strategy; /* favor or force Huffman coding*/</span>
<a href="#l12.194"></a><span id="l12.194" class="difflineplus">+</span>
<a href="#l12.195"></a><span id="l12.195" class="difflineplus">+    uInt good_match;</span>
<a href="#l12.196"></a><span id="l12.196" class="difflineplus">+    /* Use a faster search when the previous match is longer than this */</span>
<a href="#l12.197"></a><span id="l12.197" class="difflineplus">+</span>
<a href="#l12.198"></a><span id="l12.198" class="difflineplus">+    int nice_match; /* Stop searching when current match exceeds this */</span>
<a href="#l12.199"></a><span id="l12.199" class="difflineplus">+</span>
<a href="#l12.200"></a><span id="l12.200" class="difflineplus">+                /* used by trees.c: */</span>
<a href="#l12.201"></a><span id="l12.201" class="difflineplus">+    /* Didn't use ct_data typedef below to suppress compiler warning */</span>
<a href="#l12.202"></a><span id="l12.202" class="difflineplus">+    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */</span>
<a href="#l12.203"></a><span id="l12.203" class="difflineplus">+    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */</span>
<a href="#l12.204"></a><span id="l12.204" class="difflineplus">+    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */</span>
<a href="#l12.205"></a><span id="l12.205" class="difflineplus">+</span>
<a href="#l12.206"></a><span id="l12.206" class="difflineplus">+    struct tree_desc_s l_desc;               /* desc. for literal tree */</span>
<a href="#l12.207"></a><span id="l12.207" class="difflineplus">+    struct tree_desc_s d_desc;               /* desc. for distance tree */</span>
<a href="#l12.208"></a><span id="l12.208" class="difflineplus">+    struct tree_desc_s bl_desc;              /* desc. for bit length tree */</span>
<a href="#l12.209"></a><span id="l12.209" class="difflineplus">+</span>
<a href="#l12.210"></a><span id="l12.210" class="difflineplus">+    ush bl_count[MAX_BITS+1];</span>
<a href="#l12.211"></a><span id="l12.211" class="difflineplus">+    /* number of codes at each bit length for an optimal tree */</span>
<a href="#l12.212"></a><span id="l12.212" class="difflineplus">+</span>
<a href="#l12.213"></a><span id="l12.213" class="difflineplus">+    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */</span>
<a href="#l12.214"></a><span id="l12.214" class="difflineplus">+    int heap_len;               /* number of elements in the heap */</span>
<a href="#l12.215"></a><span id="l12.215" class="difflineplus">+    int heap_max;               /* element of largest frequency */</span>
<a href="#l12.216"></a><span id="l12.216" class="difflineplus">+    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.</span>
<a href="#l12.217"></a><span id="l12.217" class="difflineplus">+     * The same heap array is used to build all trees.</span>
<a href="#l12.218"></a><span id="l12.218" class="difflineplus">+     */</span>
<a href="#l12.219"></a><span id="l12.219" class="difflineplus">+</span>
<a href="#l12.220"></a><span id="l12.220" class="difflineplus">+    uch depth[2*L_CODES+1];</span>
<a href="#l12.221"></a><span id="l12.221" class="difflineplus">+    /* Depth of each subtree used as tie breaker for trees of equal frequency</span>
<a href="#l12.222"></a><span id="l12.222" class="difflineplus">+     */</span>
<a href="#l12.223"></a><span id="l12.223" class="difflineplus">+</span>
<a href="#l12.224"></a><span id="l12.224" class="difflineplus">+    uchf *l_buf;          /* buffer for literals or lengths */</span>
<a href="#l12.225"></a><span id="l12.225" class="difflineplus">+</span>
<a href="#l12.226"></a><span id="l12.226" class="difflineplus">+    uInt  lit_bufsize;</span>
<a href="#l12.227"></a><span id="l12.227" class="difflineplus">+    /* Size of match buffer for literals/lengths.  There are 4 reasons for</span>
<a href="#l12.228"></a><span id="l12.228" class="difflineplus">+     * limiting lit_bufsize to 64K:</span>
<a href="#l12.229"></a><span id="l12.229" class="difflineplus">+     *   - frequencies can be kept in 16 bit counters</span>
<a href="#l12.230"></a><span id="l12.230" class="difflineplus">+     *   - if compression is not successful for the first block, all input</span>
<a href="#l12.231"></a><span id="l12.231" class="difflineplus">+     *     data is still in the window so we can still emit a stored block even</span>
<a href="#l12.232"></a><span id="l12.232" class="difflineplus">+     *     when input comes from standard input.  (This can also be done for</span>
<a href="#l12.233"></a><span id="l12.233" class="difflineplus">+     *     all blocks if lit_bufsize is not greater than 32K.)</span>
<a href="#l12.234"></a><span id="l12.234" class="difflineplus">+     *   - if compression is not successful for a file smaller than 64K, we can</span>
<a href="#l12.235"></a><span id="l12.235" class="difflineplus">+     *     even emit a stored file instead of a stored block (saving 5 bytes).</span>
<a href="#l12.236"></a><span id="l12.236" class="difflineplus">+     *     This is applicable only for zip (not gzip or zlib).</span>
<a href="#l12.237"></a><span id="l12.237" class="difflineplus">+     *   - creating new Huffman trees less frequently may not provide fast</span>
<a href="#l12.238"></a><span id="l12.238" class="difflineplus">+     *     adaptation to changes in the input data statistics. (Take for</span>
<a href="#l12.239"></a><span id="l12.239" class="difflineplus">+     *     example a binary file with poorly compressible code followed by</span>
<a href="#l12.240"></a><span id="l12.240" class="difflineplus">+     *     a highly compressible string table.) Smaller buffer sizes give</span>
<a href="#l12.241"></a><span id="l12.241" class="difflineplus">+     *     fast adaptation but have of course the overhead of transmitting</span>
<a href="#l12.242"></a><span id="l12.242" class="difflineplus">+     *     trees more frequently.</span>
<a href="#l12.243"></a><span id="l12.243" class="difflineplus">+     *   - I can't count above 4</span>
<a href="#l12.244"></a><span id="l12.244" class="difflineplus">+     */</span>
<a href="#l12.245"></a><span id="l12.245" class="difflineplus">+</span>
<a href="#l12.246"></a><span id="l12.246" class="difflineplus">+    uInt last_lit;      /* running index in l_buf */</span>
<a href="#l12.247"></a><span id="l12.247" class="difflineplus">+</span>
<a href="#l12.248"></a><span id="l12.248" class="difflineplus">+    ushf *d_buf;</span>
<a href="#l12.249"></a><span id="l12.249" class="difflineplus">+    /* Buffer for distances. To simplify the code, d_buf and l_buf have</span>
<a href="#l12.250"></a><span id="l12.250" class="difflineplus">+     * the same number of elements. To use different lengths, an extra flag</span>
<a href="#l12.251"></a><span id="l12.251" class="difflineplus">+     * array would be necessary.</span>
<a href="#l12.252"></a><span id="l12.252" class="difflineplus">+     */</span>
<a href="#l12.253"></a><span id="l12.253" class="difflineplus">+</span>
<a href="#l12.254"></a><span id="l12.254" class="difflineplus">+    ulg opt_len;        /* bit length of current block with optimal trees */</span>
<a href="#l12.255"></a><span id="l12.255" class="difflineplus">+    ulg static_len;     /* bit length of current block with static trees */</span>
<a href="#l12.256"></a><span id="l12.256" class="difflineplus">+    uInt matches;       /* number of string matches in current block */</span>
<a href="#l12.257"></a><span id="l12.257" class="difflineplus">+    uInt insert;        /* bytes at end of window left to insert */</span>
<a href="#l12.258"></a><span id="l12.258" class="difflineplus">+</span>
<a href="#l12.259"></a><span id="l12.259" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l12.260"></a><span id="l12.260" class="difflineplus">+    ulg compressed_len; /* total bit length of compressed file mod 2^32 */</span>
<a href="#l12.261"></a><span id="l12.261" class="difflineplus">+    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */</span>
<a href="#l12.262"></a><span id="l12.262" class="difflineplus">+#endif</span>
<a href="#l12.263"></a><span id="l12.263" class="difflineplus">+</span>
<a href="#l12.264"></a><span id="l12.264" class="difflineplus">+    ush bi_buf;</span>
<a href="#l12.265"></a><span id="l12.265" class="difflineplus">+    /* Output buffer. bits are inserted starting at the bottom (least</span>
<a href="#l12.266"></a><span id="l12.266" class="difflineplus">+     * significant bits).</span>
<a href="#l12.267"></a><span id="l12.267" class="difflineplus">+     */</span>
<a href="#l12.268"></a><span id="l12.268" class="difflineplus">+    int bi_valid;</span>
<a href="#l12.269"></a><span id="l12.269" class="difflineplus">+    /* Number of valid bits in bi_buf.  All bits above the last valid bit</span>
<a href="#l12.270"></a><span id="l12.270" class="difflineplus">+     * are always zero.</span>
<a href="#l12.271"></a><span id="l12.271" class="difflineplus">+     */</span>
<a href="#l12.272"></a><span id="l12.272" class="difflineplus">+</span>
<a href="#l12.273"></a><span id="l12.273" class="difflineplus">+    ulg high_water;</span>
<a href="#l12.274"></a><span id="l12.274" class="difflineplus">+    /* High water mark offset in window for initialized bytes -- bytes above</span>
<a href="#l12.275"></a><span id="l12.275" class="difflineplus">+     * this are set to zero in order to avoid memory check warnings when</span>
<a href="#l12.276"></a><span id="l12.276" class="difflineplus">+     * longest match routines access bytes past the input.  This is then</span>
<a href="#l12.277"></a><span id="l12.277" class="difflineplus">+     * updated to the new high water mark.</span>
<a href="#l12.278"></a><span id="l12.278" class="difflineplus">+     */</span>
<a href="#l12.279"></a><span id="l12.279" class="difflineplus">+</span>
<a href="#l12.280"></a><span id="l12.280" class="difflineplus">+} FAR deflate_state;</span>
<a href="#l12.281"></a><span id="l12.281" class="difflineplus">+</span>
<a href="#l12.282"></a><span id="l12.282" class="difflineplus">+/* Output a byte on the stream.</span>
<a href="#l12.283"></a><span id="l12.283" class="difflineplus">+ * IN assertion: there is enough room in pending_buf.</span>
<a href="#l12.284"></a><span id="l12.284" class="difflineplus">+ */</span>
<a href="#l12.285"></a><span id="l12.285" class="difflineplus">+#define put_byte(s, c) {s-&gt;pending_buf[s-&gt;pending++] = (Bytef)(c);}</span>
<a href="#l12.286"></a><span id="l12.286" class="difflineplus">+</span>
<a href="#l12.287"></a><span id="l12.287" class="difflineplus">+</span>
<a href="#l12.288"></a><span id="l12.288" class="difflineplus">+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)</span>
<a href="#l12.289"></a><span id="l12.289" class="difflineplus">+/* Minimum amount of lookahead, except at the end of the input file.</span>
<a href="#l12.290"></a><span id="l12.290" class="difflineplus">+ * See deflate.c for comments about the MIN_MATCH+1.</span>
<a href="#l12.291"></a><span id="l12.291" class="difflineplus">+ */</span>
<a href="#l12.292"></a><span id="l12.292" class="difflineplus">+</span>
<a href="#l12.293"></a><span id="l12.293" class="difflineplus">+#define MAX_DIST(s)  ((s)-&gt;w_size-MIN_LOOKAHEAD)</span>
<a href="#l12.294"></a><span id="l12.294" class="difflineplus">+/* In order to simplify the code, particularly on 16 bit machines, match</span>
<a href="#l12.295"></a><span id="l12.295" class="difflineplus">+ * distances are limited to MAX_DIST instead of WSIZE.</span>
<a href="#l12.296"></a><span id="l12.296" class="difflineplus">+ */</span>
<a href="#l12.297"></a><span id="l12.297" class="difflineplus">+</span>
<a href="#l12.298"></a><span id="l12.298" class="difflineplus">+#define WIN_INIT MAX_MATCH</span>
<a href="#l12.299"></a><span id="l12.299" class="difflineplus">+/* Number of bytes after end of data in window to initialize in order to avoid</span>
<a href="#l12.300"></a><span id="l12.300" class="difflineplus">+   memory checker errors from longest match routines */</span>
<a href="#l12.301"></a><span id="l12.301" class="difflineplus">+</span>
<a href="#l12.302"></a><span id="l12.302" class="difflineplus">+        /* in trees.c */</span>
<a href="#l12.303"></a><span id="l12.303" class="difflineplus">+void ZLIB_INTERNAL _tr_init OF((deflate_state *s));</span>
<a href="#l12.304"></a><span id="l12.304" class="difflineplus">+int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));</span>
<a href="#l12.305"></a><span id="l12.305" class="difflineplus">+void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,</span>
<a href="#l12.306"></a><span id="l12.306" class="difflineplus">+                        ulg stored_len, int last));</span>
<a href="#l12.307"></a><span id="l12.307" class="difflineplus">+void ZLIB_INTERNAL _tr_flush_bits OF((deflate_state *s));</span>
<a href="#l12.308"></a><span id="l12.308" class="difflineplus">+void ZLIB_INTERNAL _tr_align OF((deflate_state *s));</span>
<a href="#l12.309"></a><span id="l12.309" class="difflineplus">+void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,</span>
<a href="#l12.310"></a><span id="l12.310" class="difflineplus">+                        ulg stored_len, int last));</span>
<a href="#l12.311"></a><span id="l12.311" class="difflineplus">+</span>
<a href="#l12.312"></a><span id="l12.312" class="difflineplus">+#define d_code(dist) \</span>
<a href="#l12.313"></a><span id="l12.313" class="difflineplus">+   ((dist) &lt; 256 ? _dist_code[dist] : _dist_code[256+((dist)&gt;&gt;7)])</span>
<a href="#l12.314"></a><span id="l12.314" class="difflineplus">+/* Mapping from a distance to a distance code. dist is the distance - 1 and</span>
<a href="#l12.315"></a><span id="l12.315" class="difflineplus">+ * must not have side effects. _dist_code[256] and _dist_code[257] are never</span>
<a href="#l12.316"></a><span id="l12.316" class="difflineplus">+ * used.</span>
<a href="#l12.317"></a><span id="l12.317" class="difflineplus">+ */</span>
<a href="#l12.318"></a><span id="l12.318" class="difflineplus">+</span>
<a href="#l12.319"></a><span id="l12.319" class="difflineplus">+#ifndef ZLIB_DEBUG</span>
<a href="#l12.320"></a><span id="l12.320" class="difflineplus">+/* Inline versions of _tr_tally for speed: */</span>
<a href="#l12.321"></a><span id="l12.321" class="difflineplus">+</span>
<a href="#l12.322"></a><span id="l12.322" class="difflineplus">+#if defined(GEN_TREES_H) || !defined(STDC)</span>
<a href="#l12.323"></a><span id="l12.323" class="difflineplus">+  extern uch ZLIB_INTERNAL _length_code[];</span>
<a href="#l12.324"></a><span id="l12.324" class="difflineplus">+  extern uch ZLIB_INTERNAL _dist_code[];</span>
<a href="#l12.325"></a><span id="l12.325" class="difflineplus">+#else</span>
<a href="#l12.326"></a><span id="l12.326" class="difflineplus">+  extern const uch ZLIB_INTERNAL _length_code[];</span>
<a href="#l12.327"></a><span id="l12.327" class="difflineplus">+  extern const uch ZLIB_INTERNAL _dist_code[];</span>
<a href="#l12.328"></a><span id="l12.328" class="difflineplus">+#endif</span>
<a href="#l12.329"></a><span id="l12.329" class="difflineplus">+</span>
<a href="#l12.330"></a><span id="l12.330" class="difflineplus">+# define _tr_tally_lit(s, c, flush) \</span>
<a href="#l12.331"></a><span id="l12.331" class="difflineplus">+  { uch cc = (c); \</span>
<a href="#l12.332"></a><span id="l12.332" class="difflineplus">+    s-&gt;d_buf[s-&gt;last_lit] = 0; \</span>
<a href="#l12.333"></a><span id="l12.333" class="difflineplus">+    s-&gt;l_buf[s-&gt;last_lit++] = cc; \</span>
<a href="#l12.334"></a><span id="l12.334" class="difflineplus">+    s-&gt;dyn_ltree[cc].Freq++; \</span>
<a href="#l12.335"></a><span id="l12.335" class="difflineplus">+    flush = (s-&gt;last_lit == s-&gt;lit_bufsize-1); \</span>
<a href="#l12.336"></a><span id="l12.336" class="difflineplus">+   }</span>
<a href="#l12.337"></a><span id="l12.337" class="difflineplus">+# define _tr_tally_dist(s, distance, length, flush) \</span>
<a href="#l12.338"></a><span id="l12.338" class="difflineplus">+  { uch len = (uch)(length); \</span>
<a href="#l12.339"></a><span id="l12.339" class="difflineplus">+    ush dist = (ush)(distance); \</span>
<a href="#l12.340"></a><span id="l12.340" class="difflineplus">+    s-&gt;d_buf[s-&gt;last_lit] = dist; \</span>
<a href="#l12.341"></a><span id="l12.341" class="difflineplus">+    s-&gt;l_buf[s-&gt;last_lit++] = len; \</span>
<a href="#l12.342"></a><span id="l12.342" class="difflineplus">+    dist--; \</span>
<a href="#l12.343"></a><span id="l12.343" class="difflineplus">+    s-&gt;dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \</span>
<a href="#l12.344"></a><span id="l12.344" class="difflineplus">+    s-&gt;dyn_dtree[d_code(dist)].Freq++; \</span>
<a href="#l12.345"></a><span id="l12.345" class="difflineplus">+    flush = (s-&gt;last_lit == s-&gt;lit_bufsize-1); \</span>
<a href="#l12.346"></a><span id="l12.346" class="difflineplus">+  }</span>
<a href="#l12.347"></a><span id="l12.347" class="difflineplus">+#else</span>
<a href="#l12.348"></a><span id="l12.348" class="difflineplus">+# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)</span>
<a href="#l12.349"></a><span id="l12.349" class="difflineplus">+# define _tr_tally_dist(s, distance, length, flush) \</span>
<a href="#l12.350"></a><span id="l12.350" class="difflineplus">+              flush = _tr_tally(s, distance, length)</span>
<a href="#l12.351"></a><span id="l12.351" class="difflineplus">+#endif</span>
<a href="#l12.352"></a><span id="l12.352" class="difflineplus">+</span>
<a href="#l12.353"></a><span id="l12.353" class="difflineplus">+#endif /* DEFLATE_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1">new file mode 100644</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineminus">--- /dev/null</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineplus">+++ b/third_party/zlib/gzclose.c</span>
<a href="#l13.4"></a><span id="l13.4" class="difflineat">@@ -0,0 +1,25 @@</span>
<a href="#l13.5"></a><span id="l13.5" class="difflineplus">+/* gzclose.c -- zlib gzclose() function</span>
<a href="#l13.6"></a><span id="l13.6" class="difflineplus">+ * Copyright (C) 2004, 2010 Mark Adler</span>
<a href="#l13.7"></a><span id="l13.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l13.8"></a><span id="l13.8" class="difflineplus">+ */</span>
<a href="#l13.9"></a><span id="l13.9" class="difflineplus">+</span>
<a href="#l13.10"></a><span id="l13.10" class="difflineplus">+#include &quot;gzguts.h&quot;</span>
<a href="#l13.11"></a><span id="l13.11" class="difflineplus">+</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineplus">+/* gzclose() is in a separate file so that it is linked in only if it is used.</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+   That way the other gzclose functions can be used instead to avoid linking in</span>
<a href="#l13.14"></a><span id="l13.14" class="difflineplus">+   unneeded compression or decompression routines. */</span>
<a href="#l13.15"></a><span id="l13.15" class="difflineplus">+int ZEXPORT gzclose(file)</span>
<a href="#l13.16"></a><span id="l13.16" class="difflineplus">+    gzFile file;</span>
<a href="#l13.17"></a><span id="l13.17" class="difflineplus">+{</span>
<a href="#l13.18"></a><span id="l13.18" class="difflineplus">+#ifndef NO_GZCOMPRESS</span>
<a href="#l13.19"></a><span id="l13.19" class="difflineplus">+    gz_statep state;</span>
<a href="#l13.20"></a><span id="l13.20" class="difflineplus">+</span>
<a href="#l13.21"></a><span id="l13.21" class="difflineplus">+    if (file == NULL)</span>
<a href="#l13.22"></a><span id="l13.22" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l13.23"></a><span id="l13.23" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l13.24"></a><span id="l13.24" class="difflineplus">+</span>
<a href="#l13.25"></a><span id="l13.25" class="difflineplus">+    return state-&gt;mode == GZ_READ ? gzclose_r(file) : gzclose_w(file);</span>
<a href="#l13.26"></a><span id="l13.26" class="difflineplus">+#else</span>
<a href="#l13.27"></a><span id="l13.27" class="difflineplus">+    return gzclose_r(file);</span>
<a href="#l13.28"></a><span id="l13.28" class="difflineplus">+#endif</span>
<a href="#l13.29"></a><span id="l13.29" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1">new file mode 100644</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineminus">--- /dev/null</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineplus">+++ b/third_party/zlib/gzguts.h</span>
<a href="#l14.4"></a><span id="l14.4" class="difflineat">@@ -0,0 +1,218 @@</span>
<a href="#l14.5"></a><span id="l14.5" class="difflineplus">+/* gzguts.h -- zlib internal header definitions for gz* operations</span>
<a href="#l14.6"></a><span id="l14.6" class="difflineplus">+ * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler</span>
<a href="#l14.7"></a><span id="l14.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l14.8"></a><span id="l14.8" class="difflineplus">+ */</span>
<a href="#l14.9"></a><span id="l14.9" class="difflineplus">+</span>
<a href="#l14.10"></a><span id="l14.10" class="difflineplus">+#ifdef _LARGEFILE64_SOURCE</span>
<a href="#l14.11"></a><span id="l14.11" class="difflineplus">+#  ifndef _LARGEFILE_SOURCE</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineplus">+#    define _LARGEFILE_SOURCE 1</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+#  endif</span>
<a href="#l14.14"></a><span id="l14.14" class="difflineplus">+#  ifdef _FILE_OFFSET_BITS</span>
<a href="#l14.15"></a><span id="l14.15" class="difflineplus">+#    undef _FILE_OFFSET_BITS</span>
<a href="#l14.16"></a><span id="l14.16" class="difflineplus">+#  endif</span>
<a href="#l14.17"></a><span id="l14.17" class="difflineplus">+#endif</span>
<a href="#l14.18"></a><span id="l14.18" class="difflineplus">+</span>
<a href="#l14.19"></a><span id="l14.19" class="difflineplus">+#ifdef HAVE_HIDDEN</span>
<a href="#l14.20"></a><span id="l14.20" class="difflineplus">+#  define ZLIB_INTERNAL __attribute__((visibility (&quot;hidden&quot;)))</span>
<a href="#l14.21"></a><span id="l14.21" class="difflineplus">+#else</span>
<a href="#l14.22"></a><span id="l14.22" class="difflineplus">+#  define ZLIB_INTERNAL</span>
<a href="#l14.23"></a><span id="l14.23" class="difflineplus">+#endif</span>
<a href="#l14.24"></a><span id="l14.24" class="difflineplus">+</span>
<a href="#l14.25"></a><span id="l14.25" class="difflineplus">+#include &lt;stdio.h&gt;</span>
<a href="#l14.26"></a><span id="l14.26" class="difflineplus">+#include &quot;zlib.h&quot;</span>
<a href="#l14.27"></a><span id="l14.27" class="difflineplus">+#ifdef STDC</span>
<a href="#l14.28"></a><span id="l14.28" class="difflineplus">+#  include &lt;string.h&gt;</span>
<a href="#l14.29"></a><span id="l14.29" class="difflineplus">+#  include &lt;stdlib.h&gt;</span>
<a href="#l14.30"></a><span id="l14.30" class="difflineplus">+#  include &lt;limits.h&gt;</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineplus">+#endif</span>
<a href="#l14.32"></a><span id="l14.32" class="difflineplus">+</span>
<a href="#l14.33"></a><span id="l14.33" class="difflineplus">+#ifndef _POSIX_SOURCE</span>
<a href="#l14.34"></a><span id="l14.34" class="difflineplus">+#  define _POSIX_SOURCE</span>
<a href="#l14.35"></a><span id="l14.35" class="difflineplus">+#endif</span>
<a href="#l14.36"></a><span id="l14.36" class="difflineplus">+#include &lt;fcntl.h&gt;</span>
<a href="#l14.37"></a><span id="l14.37" class="difflineplus">+</span>
<a href="#l14.38"></a><span id="l14.38" class="difflineplus">+#ifdef _WIN32</span>
<a href="#l14.39"></a><span id="l14.39" class="difflineplus">+#  include &lt;stddef.h&gt;</span>
<a href="#l14.40"></a><span id="l14.40" class="difflineplus">+#endif</span>
<a href="#l14.41"></a><span id="l14.41" class="difflineplus">+</span>
<a href="#l14.42"></a><span id="l14.42" class="difflineplus">+#if defined(__TURBOC__) || defined(_MSC_VER) || defined(_WIN32)</span>
<a href="#l14.43"></a><span id="l14.43" class="difflineplus">+#  include &lt;io.h&gt;</span>
<a href="#l14.44"></a><span id="l14.44" class="difflineplus">+#endif</span>
<a href="#l14.45"></a><span id="l14.45" class="difflineplus">+</span>
<a href="#l14.46"></a><span id="l14.46" class="difflineplus">+#if defined(_WIN32) || defined(__CYGWIN__)</span>
<a href="#l14.47"></a><span id="l14.47" class="difflineplus">+#  define WIDECHAR</span>
<a href="#l14.48"></a><span id="l14.48" class="difflineplus">+#endif</span>
<a href="#l14.49"></a><span id="l14.49" class="difflineplus">+</span>
<a href="#l14.50"></a><span id="l14.50" class="difflineplus">+#ifdef WINAPI_FAMILY</span>
<a href="#l14.51"></a><span id="l14.51" class="difflineplus">+#  define open _open</span>
<a href="#l14.52"></a><span id="l14.52" class="difflineplus">+#  define read _read</span>
<a href="#l14.53"></a><span id="l14.53" class="difflineplus">+#  define write _write</span>
<a href="#l14.54"></a><span id="l14.54" class="difflineplus">+#  define close _close</span>
<a href="#l14.55"></a><span id="l14.55" class="difflineplus">+#endif</span>
<a href="#l14.56"></a><span id="l14.56" class="difflineplus">+</span>
<a href="#l14.57"></a><span id="l14.57" class="difflineplus">+#ifdef NO_DEFLATE       /* for compatibility with old definition */</span>
<a href="#l14.58"></a><span id="l14.58" class="difflineplus">+#  define NO_GZCOMPRESS</span>
<a href="#l14.59"></a><span id="l14.59" class="difflineplus">+#endif</span>
<a href="#l14.60"></a><span id="l14.60" class="difflineplus">+</span>
<a href="#l14.61"></a><span id="l14.61" class="difflineplus">+#if defined(STDC99) || (defined(__TURBOC__) &amp;&amp; __TURBOC__ &gt;= 0x550)</span>
<a href="#l14.62"></a><span id="l14.62" class="difflineplus">+#  ifndef HAVE_VSNPRINTF</span>
<a href="#l14.63"></a><span id="l14.63" class="difflineplus">+#    define HAVE_VSNPRINTF</span>
<a href="#l14.64"></a><span id="l14.64" class="difflineplus">+#  endif</span>
<a href="#l14.65"></a><span id="l14.65" class="difflineplus">+#endif</span>
<a href="#l14.66"></a><span id="l14.66" class="difflineplus">+</span>
<a href="#l14.67"></a><span id="l14.67" class="difflineplus">+#if defined(__CYGWIN__)</span>
<a href="#l14.68"></a><span id="l14.68" class="difflineplus">+#  ifndef HAVE_VSNPRINTF</span>
<a href="#l14.69"></a><span id="l14.69" class="difflineplus">+#    define HAVE_VSNPRINTF</span>
<a href="#l14.70"></a><span id="l14.70" class="difflineplus">+#  endif</span>
<a href="#l14.71"></a><span id="l14.71" class="difflineplus">+#endif</span>
<a href="#l14.72"></a><span id="l14.72" class="difflineplus">+</span>
<a href="#l14.73"></a><span id="l14.73" class="difflineplus">+#if defined(MSDOS) &amp;&amp; defined(__BORLANDC__) &amp;&amp; (BORLANDC &gt; 0x410)</span>
<a href="#l14.74"></a><span id="l14.74" class="difflineplus">+#  ifndef HAVE_VSNPRINTF</span>
<a href="#l14.75"></a><span id="l14.75" class="difflineplus">+#    define HAVE_VSNPRINTF</span>
<a href="#l14.76"></a><span id="l14.76" class="difflineplus">+#  endif</span>
<a href="#l14.77"></a><span id="l14.77" class="difflineplus">+#endif</span>
<a href="#l14.78"></a><span id="l14.78" class="difflineplus">+</span>
<a href="#l14.79"></a><span id="l14.79" class="difflineplus">+#ifndef HAVE_VSNPRINTF</span>
<a href="#l14.80"></a><span id="l14.80" class="difflineplus">+#  ifdef MSDOS</span>
<a href="#l14.81"></a><span id="l14.81" class="difflineplus">+/* vsnprintf may exist on some MS-DOS compilers (DJGPP?),</span>
<a href="#l14.82"></a><span id="l14.82" class="difflineplus">+   but for now we just assume it doesn't. */</span>
<a href="#l14.83"></a><span id="l14.83" class="difflineplus">+#    define NO_vsnprintf</span>
<a href="#l14.84"></a><span id="l14.84" class="difflineplus">+#  endif</span>
<a href="#l14.85"></a><span id="l14.85" class="difflineplus">+#  ifdef __TURBOC__</span>
<a href="#l14.86"></a><span id="l14.86" class="difflineplus">+#    define NO_vsnprintf</span>
<a href="#l14.87"></a><span id="l14.87" class="difflineplus">+#  endif</span>
<a href="#l14.88"></a><span id="l14.88" class="difflineplus">+#  ifdef WIN32</span>
<a href="#l14.89"></a><span id="l14.89" class="difflineplus">+/* In Win32, vsnprintf is available as the &quot;non-ANSI&quot; _vsnprintf. */</span>
<a href="#l14.90"></a><span id="l14.90" class="difflineplus">+#    if !defined(vsnprintf) &amp;&amp; !defined(NO_vsnprintf)</span>
<a href="#l14.91"></a><span id="l14.91" class="difflineplus">+#      if !defined(_MSC_VER) || ( defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1500 )</span>
<a href="#l14.92"></a><span id="l14.92" class="difflineplus">+#         define vsnprintf _vsnprintf</span>
<a href="#l14.93"></a><span id="l14.93" class="difflineplus">+#      endif</span>
<a href="#l14.94"></a><span id="l14.94" class="difflineplus">+#    endif</span>
<a href="#l14.95"></a><span id="l14.95" class="difflineplus">+#  endif</span>
<a href="#l14.96"></a><span id="l14.96" class="difflineplus">+#  ifdef __SASC</span>
<a href="#l14.97"></a><span id="l14.97" class="difflineplus">+#    define NO_vsnprintf</span>
<a href="#l14.98"></a><span id="l14.98" class="difflineplus">+#  endif</span>
<a href="#l14.99"></a><span id="l14.99" class="difflineplus">+#  ifdef VMS</span>
<a href="#l14.100"></a><span id="l14.100" class="difflineplus">+#    define NO_vsnprintf</span>
<a href="#l14.101"></a><span id="l14.101" class="difflineplus">+#  endif</span>
<a href="#l14.102"></a><span id="l14.102" class="difflineplus">+#  ifdef __OS400__</span>
<a href="#l14.103"></a><span id="l14.103" class="difflineplus">+#    define NO_vsnprintf</span>
<a href="#l14.104"></a><span id="l14.104" class="difflineplus">+#  endif</span>
<a href="#l14.105"></a><span id="l14.105" class="difflineplus">+#  ifdef __MVS__</span>
<a href="#l14.106"></a><span id="l14.106" class="difflineplus">+#    define NO_vsnprintf</span>
<a href="#l14.107"></a><span id="l14.107" class="difflineplus">+#  endif</span>
<a href="#l14.108"></a><span id="l14.108" class="difflineplus">+#endif</span>
<a href="#l14.109"></a><span id="l14.109" class="difflineplus">+</span>
<a href="#l14.110"></a><span id="l14.110" class="difflineplus">+/* unlike snprintf (which is required in C99), _snprintf does not guarantee</span>
<a href="#l14.111"></a><span id="l14.111" class="difflineplus">+   null termination of the result -- however this is only used in gzlib.c where</span>
<a href="#l14.112"></a><span id="l14.112" class="difflineplus">+   the result is assured to fit in the space provided */</span>
<a href="#l14.113"></a><span id="l14.113" class="difflineplus">+#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1900</span>
<a href="#l14.114"></a><span id="l14.114" class="difflineplus">+#  define snprintf _snprintf</span>
<a href="#l14.115"></a><span id="l14.115" class="difflineplus">+#endif</span>
<a href="#l14.116"></a><span id="l14.116" class="difflineplus">+</span>
<a href="#l14.117"></a><span id="l14.117" class="difflineplus">+#ifndef local</span>
<a href="#l14.118"></a><span id="l14.118" class="difflineplus">+#  define local static</span>
<a href="#l14.119"></a><span id="l14.119" class="difflineplus">+#endif</span>
<a href="#l14.120"></a><span id="l14.120" class="difflineplus">+/* since &quot;static&quot; is used to mean two completely different things in C, we</span>
<a href="#l14.121"></a><span id="l14.121" class="difflineplus">+   define &quot;local&quot; for the non-static meaning of &quot;static&quot;, for readability</span>
<a href="#l14.122"></a><span id="l14.122" class="difflineplus">+   (compile with -Dlocal if your debugger can't find static symbols) */</span>
<a href="#l14.123"></a><span id="l14.123" class="difflineplus">+</span>
<a href="#l14.124"></a><span id="l14.124" class="difflineplus">+/* gz* functions always use library allocation functions */</span>
<a href="#l14.125"></a><span id="l14.125" class="difflineplus">+#ifndef STDC</span>
<a href="#l14.126"></a><span id="l14.126" class="difflineplus">+  extern voidp  malloc OF((uInt size));</span>
<a href="#l14.127"></a><span id="l14.127" class="difflineplus">+  extern void   free   OF((voidpf ptr));</span>
<a href="#l14.128"></a><span id="l14.128" class="difflineplus">+#endif</span>
<a href="#l14.129"></a><span id="l14.129" class="difflineplus">+</span>
<a href="#l14.130"></a><span id="l14.130" class="difflineplus">+/* get errno and strerror definition */</span>
<a href="#l14.131"></a><span id="l14.131" class="difflineplus">+#if defined UNDER_CE</span>
<a href="#l14.132"></a><span id="l14.132" class="difflineplus">+#  include &lt;windows.h&gt;</span>
<a href="#l14.133"></a><span id="l14.133" class="difflineplus">+#  define zstrerror() gz_strwinerror((DWORD)GetLastError())</span>
<a href="#l14.134"></a><span id="l14.134" class="difflineplus">+#else</span>
<a href="#l14.135"></a><span id="l14.135" class="difflineplus">+#  ifndef NO_STRERROR</span>
<a href="#l14.136"></a><span id="l14.136" class="difflineplus">+#    include &lt;errno.h&gt;</span>
<a href="#l14.137"></a><span id="l14.137" class="difflineplus">+#    define zstrerror() strerror(errno)</span>
<a href="#l14.138"></a><span id="l14.138" class="difflineplus">+#  else</span>
<a href="#l14.139"></a><span id="l14.139" class="difflineplus">+#    define zstrerror() &quot;stdio error (consult errno)&quot;</span>
<a href="#l14.140"></a><span id="l14.140" class="difflineplus">+#  endif</span>
<a href="#l14.141"></a><span id="l14.141" class="difflineplus">+#endif</span>
<a href="#l14.142"></a><span id="l14.142" class="difflineplus">+</span>
<a href="#l14.143"></a><span id="l14.143" class="difflineplus">+/* provide prototypes for these when building zlib without LFS */</span>
<a href="#l14.144"></a><span id="l14.144" class="difflineplus">+#if !defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0</span>
<a href="#l14.145"></a><span id="l14.145" class="difflineplus">+    ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));</span>
<a href="#l14.146"></a><span id="l14.146" class="difflineplus">+    ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));</span>
<a href="#l14.147"></a><span id="l14.147" class="difflineplus">+    ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));</span>
<a href="#l14.148"></a><span id="l14.148" class="difflineplus">+    ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));</span>
<a href="#l14.149"></a><span id="l14.149" class="difflineplus">+#endif</span>
<a href="#l14.150"></a><span id="l14.150" class="difflineplus">+</span>
<a href="#l14.151"></a><span id="l14.151" class="difflineplus">+/* default memLevel */</span>
<a href="#l14.152"></a><span id="l14.152" class="difflineplus">+#if MAX_MEM_LEVEL &gt;= 8</span>
<a href="#l14.153"></a><span id="l14.153" class="difflineplus">+#  define DEF_MEM_LEVEL 8</span>
<a href="#l14.154"></a><span id="l14.154" class="difflineplus">+#else</span>
<a href="#l14.155"></a><span id="l14.155" class="difflineplus">+#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL</span>
<a href="#l14.156"></a><span id="l14.156" class="difflineplus">+#endif</span>
<a href="#l14.157"></a><span id="l14.157" class="difflineplus">+</span>
<a href="#l14.158"></a><span id="l14.158" class="difflineplus">+/* default i/o buffer size -- double this for output when reading (this and</span>
<a href="#l14.159"></a><span id="l14.159" class="difflineplus">+   twice this must be able to fit in an unsigned type) */</span>
<a href="#l14.160"></a><span id="l14.160" class="difflineplus">+#define GZBUFSIZE 8192</span>
<a href="#l14.161"></a><span id="l14.161" class="difflineplus">+</span>
<a href="#l14.162"></a><span id="l14.162" class="difflineplus">+/* gzip modes, also provide a little integrity check on the passed structure */</span>
<a href="#l14.163"></a><span id="l14.163" class="difflineplus">+#define GZ_NONE 0</span>
<a href="#l14.164"></a><span id="l14.164" class="difflineplus">+#define GZ_READ 7247</span>
<a href="#l14.165"></a><span id="l14.165" class="difflineplus">+#define GZ_WRITE 31153</span>
<a href="#l14.166"></a><span id="l14.166" class="difflineplus">+#define GZ_APPEND 1     /* mode set to GZ_WRITE after the file is opened */</span>
<a href="#l14.167"></a><span id="l14.167" class="difflineplus">+</span>
<a href="#l14.168"></a><span id="l14.168" class="difflineplus">+/* values for gz_state how */</span>
<a href="#l14.169"></a><span id="l14.169" class="difflineplus">+#define LOOK 0      /* look for a gzip header */</span>
<a href="#l14.170"></a><span id="l14.170" class="difflineplus">+#define COPY 1      /* copy input directly */</span>
<a href="#l14.171"></a><span id="l14.171" class="difflineplus">+#define GZIP 2      /* decompress a gzip stream */</span>
<a href="#l14.172"></a><span id="l14.172" class="difflineplus">+</span>
<a href="#l14.173"></a><span id="l14.173" class="difflineplus">+/* internal gzip file state data structure */</span>
<a href="#l14.174"></a><span id="l14.174" class="difflineplus">+typedef struct {</span>
<a href="#l14.175"></a><span id="l14.175" class="difflineplus">+        /* exposed contents for gzgetc() macro */</span>
<a href="#l14.176"></a><span id="l14.176" class="difflineplus">+    struct gzFile_s x;      /* &quot;x&quot; for exposed */</span>
<a href="#l14.177"></a><span id="l14.177" class="difflineplus">+                            /* x.have: number of bytes available at x.next */</span>
<a href="#l14.178"></a><span id="l14.178" class="difflineplus">+                            /* x.next: next output data to deliver or write */</span>
<a href="#l14.179"></a><span id="l14.179" class="difflineplus">+                            /* x.pos: current position in uncompressed data */</span>
<a href="#l14.180"></a><span id="l14.180" class="difflineplus">+        /* used for both reading and writing */</span>
<a href="#l14.181"></a><span id="l14.181" class="difflineplus">+    int mode;               /* see gzip modes above */</span>
<a href="#l14.182"></a><span id="l14.182" class="difflineplus">+    int fd;                 /* file descriptor */</span>
<a href="#l14.183"></a><span id="l14.183" class="difflineplus">+    char *path;             /* path or fd for error messages */</span>
<a href="#l14.184"></a><span id="l14.184" class="difflineplus">+    unsigned size;          /* buffer size, zero if not allocated yet */</span>
<a href="#l14.185"></a><span id="l14.185" class="difflineplus">+    unsigned want;          /* requested buffer size, default is GZBUFSIZE */</span>
<a href="#l14.186"></a><span id="l14.186" class="difflineplus">+    unsigned char *in;      /* input buffer (double-sized when writing) */</span>
<a href="#l14.187"></a><span id="l14.187" class="difflineplus">+    unsigned char *out;     /* output buffer (double-sized when reading) */</span>
<a href="#l14.188"></a><span id="l14.188" class="difflineplus">+    int direct;             /* 0 if processing gzip, 1 if transparent */</span>
<a href="#l14.189"></a><span id="l14.189" class="difflineplus">+        /* just for reading */</span>
<a href="#l14.190"></a><span id="l14.190" class="difflineplus">+    int how;                /* 0: get header, 1: copy, 2: decompress */</span>
<a href="#l14.191"></a><span id="l14.191" class="difflineplus">+    z_off64_t start;        /* where the gzip data started, for rewinding */</span>
<a href="#l14.192"></a><span id="l14.192" class="difflineplus">+    int eof;                /* true if end of input file reached */</span>
<a href="#l14.193"></a><span id="l14.193" class="difflineplus">+    int past;               /* true if read requested past end */</span>
<a href="#l14.194"></a><span id="l14.194" class="difflineplus">+        /* just for writing */</span>
<a href="#l14.195"></a><span id="l14.195" class="difflineplus">+    int level;              /* compression level */</span>
<a href="#l14.196"></a><span id="l14.196" class="difflineplus">+    int strategy;           /* compression strategy */</span>
<a href="#l14.197"></a><span id="l14.197" class="difflineplus">+        /* seek request */</span>
<a href="#l14.198"></a><span id="l14.198" class="difflineplus">+    z_off64_t skip;         /* amount to skip (already rewound if backwards) */</span>
<a href="#l14.199"></a><span id="l14.199" class="difflineplus">+    int seek;               /* true if seek request pending */</span>
<a href="#l14.200"></a><span id="l14.200" class="difflineplus">+        /* error information */</span>
<a href="#l14.201"></a><span id="l14.201" class="difflineplus">+    int err;                /* error code */</span>
<a href="#l14.202"></a><span id="l14.202" class="difflineplus">+    char *msg;              /* error message */</span>
<a href="#l14.203"></a><span id="l14.203" class="difflineplus">+        /* zlib inflate or deflate stream */</span>
<a href="#l14.204"></a><span id="l14.204" class="difflineplus">+    z_stream strm;          /* stream structure in-place (not a pointer) */</span>
<a href="#l14.205"></a><span id="l14.205" class="difflineplus">+} gz_state;</span>
<a href="#l14.206"></a><span id="l14.206" class="difflineplus">+typedef gz_state FAR *gz_statep;</span>
<a href="#l14.207"></a><span id="l14.207" class="difflineplus">+</span>
<a href="#l14.208"></a><span id="l14.208" class="difflineplus">+/* shared functions */</span>
<a href="#l14.209"></a><span id="l14.209" class="difflineplus">+void ZLIB_INTERNAL gz_error OF((gz_statep, int, const char *));</span>
<a href="#l14.210"></a><span id="l14.210" class="difflineplus">+#if defined UNDER_CE</span>
<a href="#l14.211"></a><span id="l14.211" class="difflineplus">+char ZLIB_INTERNAL *gz_strwinerror OF((DWORD error));</span>
<a href="#l14.212"></a><span id="l14.212" class="difflineplus">+#endif</span>
<a href="#l14.213"></a><span id="l14.213" class="difflineplus">+</span>
<a href="#l14.214"></a><span id="l14.214" class="difflineplus">+/* GT_OFF(x), where x is an unsigned value, is true if x &gt; maximum z_off64_t</span>
<a href="#l14.215"></a><span id="l14.215" class="difflineplus">+   value -- needed when comparing unsigned to z_off64_t, which is signed</span>
<a href="#l14.216"></a><span id="l14.216" class="difflineplus">+   (possible z_off64_t types off_t, off64_t, and long are all signed) */</span>
<a href="#l14.217"></a><span id="l14.217" class="difflineplus">+#ifdef INT_MAX</span>
<a href="#l14.218"></a><span id="l14.218" class="difflineplus">+#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) &amp;&amp; (x) &gt; INT_MAX)</span>
<a href="#l14.219"></a><span id="l14.219" class="difflineplus">+#else</span>
<a href="#l14.220"></a><span id="l14.220" class="difflineplus">+unsigned ZLIB_INTERNAL gz_intmax OF((void));</span>
<a href="#l14.221"></a><span id="l14.221" class="difflineplus">+#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) &amp;&amp; (x) &gt; gz_intmax())</span>
<a href="#l14.222"></a><span id="l14.222" class="difflineplus">+#endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1">new file mode 100644</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineminus">--- /dev/null</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineplus">+++ b/third_party/zlib/gzlib.c</span>
<a href="#l15.4"></a><span id="l15.4" class="difflineat">@@ -0,0 +1,637 @@</span>
<a href="#l15.5"></a><span id="l15.5" class="difflineplus">+/* gzlib.c -- zlib functions common to reading and writing gzip files</span>
<a href="#l15.6"></a><span id="l15.6" class="difflineplus">+ * Copyright (C) 2004-2017 Mark Adler</span>
<a href="#l15.7"></a><span id="l15.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l15.8"></a><span id="l15.8" class="difflineplus">+ */</span>
<a href="#l15.9"></a><span id="l15.9" class="difflineplus">+</span>
<a href="#l15.10"></a><span id="l15.10" class="difflineplus">+#include &quot;gzguts.h&quot;</span>
<a href="#l15.11"></a><span id="l15.11" class="difflineplus">+</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineplus">+#if defined(_WIN32) &amp;&amp; !defined(__BORLANDC__) &amp;&amp; !defined(__MINGW32__)</span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+#  define LSEEK _lseeki64</span>
<a href="#l15.14"></a><span id="l15.14" class="difflineplus">+#else</span>
<a href="#l15.15"></a><span id="l15.15" class="difflineplus">+#if defined(_LARGEFILE64_SOURCE) &amp;&amp; _LFS64_LARGEFILE-0</span>
<a href="#l15.16"></a><span id="l15.16" class="difflineplus">+#  define LSEEK lseek64</span>
<a href="#l15.17"></a><span id="l15.17" class="difflineplus">+#else</span>
<a href="#l15.18"></a><span id="l15.18" class="difflineplus">+#  define LSEEK lseek</span>
<a href="#l15.19"></a><span id="l15.19" class="difflineplus">+#endif</span>
<a href="#l15.20"></a><span id="l15.20" class="difflineplus">+#endif</span>
<a href="#l15.21"></a><span id="l15.21" class="difflineplus">+</span>
<a href="#l15.22"></a><span id="l15.22" class="difflineplus">+/* Local functions */</span>
<a href="#l15.23"></a><span id="l15.23" class="difflineplus">+local void gz_reset OF((gz_statep));</span>
<a href="#l15.24"></a><span id="l15.24" class="difflineplus">+local gzFile gz_open OF((const void *, int, const char *));</span>
<a href="#l15.25"></a><span id="l15.25" class="difflineplus">+</span>
<a href="#l15.26"></a><span id="l15.26" class="difflineplus">+#if defined UNDER_CE</span>
<a href="#l15.27"></a><span id="l15.27" class="difflineplus">+</span>
<a href="#l15.28"></a><span id="l15.28" class="difflineplus">+/* Map the Windows error number in ERROR to a locale-dependent error message</span>
<a href="#l15.29"></a><span id="l15.29" class="difflineplus">+   string and return a pointer to it.  Typically, the values for ERROR come</span>
<a href="#l15.30"></a><span id="l15.30" class="difflineplus">+   from GetLastError.</span>
<a href="#l15.31"></a><span id="l15.31" class="difflineplus">+</span>
<a href="#l15.32"></a><span id="l15.32" class="difflineplus">+   The string pointed to shall not be modified by the application, but may be</span>
<a href="#l15.33"></a><span id="l15.33" class="difflineplus">+   overwritten by a subsequent call to gz_strwinerror</span>
<a href="#l15.34"></a><span id="l15.34" class="difflineplus">+</span>
<a href="#l15.35"></a><span id="l15.35" class="difflineplus">+   The gz_strwinerror function does not change the current setting of</span>
<a href="#l15.36"></a><span id="l15.36" class="difflineplus">+   GetLastError. */</span>
<a href="#l15.37"></a><span id="l15.37" class="difflineplus">+char ZLIB_INTERNAL *gz_strwinerror (error)</span>
<a href="#l15.38"></a><span id="l15.38" class="difflineplus">+     DWORD error;</span>
<a href="#l15.39"></a><span id="l15.39" class="difflineplus">+{</span>
<a href="#l15.40"></a><span id="l15.40" class="difflineplus">+    static char buf[1024];</span>
<a href="#l15.41"></a><span id="l15.41" class="difflineplus">+</span>
<a href="#l15.42"></a><span id="l15.42" class="difflineplus">+    wchar_t *msgbuf;</span>
<a href="#l15.43"></a><span id="l15.43" class="difflineplus">+    DWORD lasterr = GetLastError();</span>
<a href="#l15.44"></a><span id="l15.44" class="difflineplus">+    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM</span>
<a href="#l15.45"></a><span id="l15.45" class="difflineplus">+        | FORMAT_MESSAGE_ALLOCATE_BUFFER,</span>
<a href="#l15.46"></a><span id="l15.46" class="difflineplus">+        NULL,</span>
<a href="#l15.47"></a><span id="l15.47" class="difflineplus">+        error,</span>
<a href="#l15.48"></a><span id="l15.48" class="difflineplus">+        0, /* Default language */</span>
<a href="#l15.49"></a><span id="l15.49" class="difflineplus">+        (LPVOID)&amp;msgbuf,</span>
<a href="#l15.50"></a><span id="l15.50" class="difflineplus">+        0,</span>
<a href="#l15.51"></a><span id="l15.51" class="difflineplus">+        NULL);</span>
<a href="#l15.52"></a><span id="l15.52" class="difflineplus">+    if (chars != 0) {</span>
<a href="#l15.53"></a><span id="l15.53" class="difflineplus">+        /* If there is an \r\n appended, zap it.  */</span>
<a href="#l15.54"></a><span id="l15.54" class="difflineplus">+        if (chars &gt;= 2</span>
<a href="#l15.55"></a><span id="l15.55" class="difflineplus">+            &amp;&amp; msgbuf[chars - 2] == '\r' &amp;&amp; msgbuf[chars - 1] == '\n') {</span>
<a href="#l15.56"></a><span id="l15.56" class="difflineplus">+            chars -= 2;</span>
<a href="#l15.57"></a><span id="l15.57" class="difflineplus">+            msgbuf[chars] = 0;</span>
<a href="#l15.58"></a><span id="l15.58" class="difflineplus">+        }</span>
<a href="#l15.59"></a><span id="l15.59" class="difflineplus">+</span>
<a href="#l15.60"></a><span id="l15.60" class="difflineplus">+        if (chars &gt; sizeof (buf) - 1) {</span>
<a href="#l15.61"></a><span id="l15.61" class="difflineplus">+            chars = sizeof (buf) - 1;</span>
<a href="#l15.62"></a><span id="l15.62" class="difflineplus">+            msgbuf[chars] = 0;</span>
<a href="#l15.63"></a><span id="l15.63" class="difflineplus">+        }</span>
<a href="#l15.64"></a><span id="l15.64" class="difflineplus">+</span>
<a href="#l15.65"></a><span id="l15.65" class="difflineplus">+        wcstombs(buf, msgbuf, chars + 1);</span>
<a href="#l15.66"></a><span id="l15.66" class="difflineplus">+        LocalFree(msgbuf);</span>
<a href="#l15.67"></a><span id="l15.67" class="difflineplus">+    }</span>
<a href="#l15.68"></a><span id="l15.68" class="difflineplus">+    else {</span>
<a href="#l15.69"></a><span id="l15.69" class="difflineplus">+        sprintf(buf, &quot;unknown win32 error (%ld)&quot;, error);</span>
<a href="#l15.70"></a><span id="l15.70" class="difflineplus">+    }</span>
<a href="#l15.71"></a><span id="l15.71" class="difflineplus">+</span>
<a href="#l15.72"></a><span id="l15.72" class="difflineplus">+    SetLastError(lasterr);</span>
<a href="#l15.73"></a><span id="l15.73" class="difflineplus">+    return buf;</span>
<a href="#l15.74"></a><span id="l15.74" class="difflineplus">+}</span>
<a href="#l15.75"></a><span id="l15.75" class="difflineplus">+</span>
<a href="#l15.76"></a><span id="l15.76" class="difflineplus">+#endif /* UNDER_CE */</span>
<a href="#l15.77"></a><span id="l15.77" class="difflineplus">+</span>
<a href="#l15.78"></a><span id="l15.78" class="difflineplus">+/* Reset gzip file state */</span>
<a href="#l15.79"></a><span id="l15.79" class="difflineplus">+local void gz_reset(state)</span>
<a href="#l15.80"></a><span id="l15.80" class="difflineplus">+    gz_statep state;</span>
<a href="#l15.81"></a><span id="l15.81" class="difflineplus">+{</span>
<a href="#l15.82"></a><span id="l15.82" class="difflineplus">+    state-&gt;x.have = 0;              /* no output data available */</span>
<a href="#l15.83"></a><span id="l15.83" class="difflineplus">+    if (state-&gt;mode == GZ_READ) {   /* for reading ... */</span>
<a href="#l15.84"></a><span id="l15.84" class="difflineplus">+        state-&gt;eof = 0;             /* not at end of file */</span>
<a href="#l15.85"></a><span id="l15.85" class="difflineplus">+        state-&gt;past = 0;            /* have not read past end yet */</span>
<a href="#l15.86"></a><span id="l15.86" class="difflineplus">+        state-&gt;how = LOOK;          /* look for gzip header */</span>
<a href="#l15.87"></a><span id="l15.87" class="difflineplus">+    }</span>
<a href="#l15.88"></a><span id="l15.88" class="difflineplus">+    state-&gt;seek = 0;                /* no seek request pending */</span>
<a href="#l15.89"></a><span id="l15.89" class="difflineplus">+    gz_error(state, Z_OK, NULL);    /* clear error */</span>
<a href="#l15.90"></a><span id="l15.90" class="difflineplus">+    state-&gt;x.pos = 0;               /* no uncompressed data yet */</span>
<a href="#l15.91"></a><span id="l15.91" class="difflineplus">+    state-&gt;strm.avail_in = 0;       /* no input data yet */</span>
<a href="#l15.92"></a><span id="l15.92" class="difflineplus">+}</span>
<a href="#l15.93"></a><span id="l15.93" class="difflineplus">+</span>
<a href="#l15.94"></a><span id="l15.94" class="difflineplus">+/* Open a gzip file either by name or file descriptor. */</span>
<a href="#l15.95"></a><span id="l15.95" class="difflineplus">+local gzFile gz_open(path, fd, mode)</span>
<a href="#l15.96"></a><span id="l15.96" class="difflineplus">+    const void *path;</span>
<a href="#l15.97"></a><span id="l15.97" class="difflineplus">+    int fd;</span>
<a href="#l15.98"></a><span id="l15.98" class="difflineplus">+    const char *mode;</span>
<a href="#l15.99"></a><span id="l15.99" class="difflineplus">+{</span>
<a href="#l15.100"></a><span id="l15.100" class="difflineplus">+    gz_statep state;</span>
<a href="#l15.101"></a><span id="l15.101" class="difflineplus">+    z_size_t len;</span>
<a href="#l15.102"></a><span id="l15.102" class="difflineplus">+    int oflag;</span>
<a href="#l15.103"></a><span id="l15.103" class="difflineplus">+#ifdef O_CLOEXEC</span>
<a href="#l15.104"></a><span id="l15.104" class="difflineplus">+    int cloexec = 0;</span>
<a href="#l15.105"></a><span id="l15.105" class="difflineplus">+#endif</span>
<a href="#l15.106"></a><span id="l15.106" class="difflineplus">+#ifdef O_EXCL</span>
<a href="#l15.107"></a><span id="l15.107" class="difflineplus">+    int exclusive = 0;</span>
<a href="#l15.108"></a><span id="l15.108" class="difflineplus">+#endif</span>
<a href="#l15.109"></a><span id="l15.109" class="difflineplus">+</span>
<a href="#l15.110"></a><span id="l15.110" class="difflineplus">+    /* check input */</span>
<a href="#l15.111"></a><span id="l15.111" class="difflineplus">+    if (path == NULL)</span>
<a href="#l15.112"></a><span id="l15.112" class="difflineplus">+        return NULL;</span>
<a href="#l15.113"></a><span id="l15.113" class="difflineplus">+</span>
<a href="#l15.114"></a><span id="l15.114" class="difflineplus">+    /* allocate gzFile structure to return */</span>
<a href="#l15.115"></a><span id="l15.115" class="difflineplus">+    state = (gz_statep)malloc(sizeof(gz_state));</span>
<a href="#l15.116"></a><span id="l15.116" class="difflineplus">+    if (state == NULL)</span>
<a href="#l15.117"></a><span id="l15.117" class="difflineplus">+        return NULL;</span>
<a href="#l15.118"></a><span id="l15.118" class="difflineplus">+    state-&gt;size = 0;            /* no buffers allocated yet */</span>
<a href="#l15.119"></a><span id="l15.119" class="difflineplus">+    state-&gt;want = GZBUFSIZE;    /* requested buffer size */</span>
<a href="#l15.120"></a><span id="l15.120" class="difflineplus">+    state-&gt;msg = NULL;          /* no error message yet */</span>
<a href="#l15.121"></a><span id="l15.121" class="difflineplus">+</span>
<a href="#l15.122"></a><span id="l15.122" class="difflineplus">+    /* interpret mode */</span>
<a href="#l15.123"></a><span id="l15.123" class="difflineplus">+    state-&gt;mode = GZ_NONE;</span>
<a href="#l15.124"></a><span id="l15.124" class="difflineplus">+    state-&gt;level = Z_DEFAULT_COMPRESSION;</span>
<a href="#l15.125"></a><span id="l15.125" class="difflineplus">+    state-&gt;strategy = Z_DEFAULT_STRATEGY;</span>
<a href="#l15.126"></a><span id="l15.126" class="difflineplus">+    state-&gt;direct = 0;</span>
<a href="#l15.127"></a><span id="l15.127" class="difflineplus">+    while (*mode) {</span>
<a href="#l15.128"></a><span id="l15.128" class="difflineplus">+        if (*mode &gt;= '0' &amp;&amp; *mode &lt;= '9')</span>
<a href="#l15.129"></a><span id="l15.129" class="difflineplus">+            state-&gt;level = *mode - '0';</span>
<a href="#l15.130"></a><span id="l15.130" class="difflineplus">+        else</span>
<a href="#l15.131"></a><span id="l15.131" class="difflineplus">+            switch (*mode) {</span>
<a href="#l15.132"></a><span id="l15.132" class="difflineplus">+            case 'r':</span>
<a href="#l15.133"></a><span id="l15.133" class="difflineplus">+                state-&gt;mode = GZ_READ;</span>
<a href="#l15.134"></a><span id="l15.134" class="difflineplus">+                break;</span>
<a href="#l15.135"></a><span id="l15.135" class="difflineplus">+#ifndef NO_GZCOMPRESS</span>
<a href="#l15.136"></a><span id="l15.136" class="difflineplus">+            case 'w':</span>
<a href="#l15.137"></a><span id="l15.137" class="difflineplus">+                state-&gt;mode = GZ_WRITE;</span>
<a href="#l15.138"></a><span id="l15.138" class="difflineplus">+                break;</span>
<a href="#l15.139"></a><span id="l15.139" class="difflineplus">+            case 'a':</span>
<a href="#l15.140"></a><span id="l15.140" class="difflineplus">+                state-&gt;mode = GZ_APPEND;</span>
<a href="#l15.141"></a><span id="l15.141" class="difflineplus">+                break;</span>
<a href="#l15.142"></a><span id="l15.142" class="difflineplus">+#endif</span>
<a href="#l15.143"></a><span id="l15.143" class="difflineplus">+            case '+':       /* can't read and write at the same time */</span>
<a href="#l15.144"></a><span id="l15.144" class="difflineplus">+                free(state);</span>
<a href="#l15.145"></a><span id="l15.145" class="difflineplus">+                return NULL;</span>
<a href="#l15.146"></a><span id="l15.146" class="difflineplus">+            case 'b':       /* ignore -- will request binary anyway */</span>
<a href="#l15.147"></a><span id="l15.147" class="difflineplus">+                break;</span>
<a href="#l15.148"></a><span id="l15.148" class="difflineplus">+#ifdef O_CLOEXEC</span>
<a href="#l15.149"></a><span id="l15.149" class="difflineplus">+            case 'e':</span>
<a href="#l15.150"></a><span id="l15.150" class="difflineplus">+                cloexec = 1;</span>
<a href="#l15.151"></a><span id="l15.151" class="difflineplus">+                break;</span>
<a href="#l15.152"></a><span id="l15.152" class="difflineplus">+#endif</span>
<a href="#l15.153"></a><span id="l15.153" class="difflineplus">+#ifdef O_EXCL</span>
<a href="#l15.154"></a><span id="l15.154" class="difflineplus">+            case 'x':</span>
<a href="#l15.155"></a><span id="l15.155" class="difflineplus">+                exclusive = 1;</span>
<a href="#l15.156"></a><span id="l15.156" class="difflineplus">+                break;</span>
<a href="#l15.157"></a><span id="l15.157" class="difflineplus">+#endif</span>
<a href="#l15.158"></a><span id="l15.158" class="difflineplus">+            case 'f':</span>
<a href="#l15.159"></a><span id="l15.159" class="difflineplus">+                state-&gt;strategy = Z_FILTERED;</span>
<a href="#l15.160"></a><span id="l15.160" class="difflineplus">+                break;</span>
<a href="#l15.161"></a><span id="l15.161" class="difflineplus">+            case 'h':</span>
<a href="#l15.162"></a><span id="l15.162" class="difflineplus">+                state-&gt;strategy = Z_HUFFMAN_ONLY;</span>
<a href="#l15.163"></a><span id="l15.163" class="difflineplus">+                break;</span>
<a href="#l15.164"></a><span id="l15.164" class="difflineplus">+            case 'R':</span>
<a href="#l15.165"></a><span id="l15.165" class="difflineplus">+                state-&gt;strategy = Z_RLE;</span>
<a href="#l15.166"></a><span id="l15.166" class="difflineplus">+                break;</span>
<a href="#l15.167"></a><span id="l15.167" class="difflineplus">+            case 'F':</span>
<a href="#l15.168"></a><span id="l15.168" class="difflineplus">+                state-&gt;strategy = Z_FIXED;</span>
<a href="#l15.169"></a><span id="l15.169" class="difflineplus">+                break;</span>
<a href="#l15.170"></a><span id="l15.170" class="difflineplus">+            case 'T':</span>
<a href="#l15.171"></a><span id="l15.171" class="difflineplus">+                state-&gt;direct = 1;</span>
<a href="#l15.172"></a><span id="l15.172" class="difflineplus">+                break;</span>
<a href="#l15.173"></a><span id="l15.173" class="difflineplus">+            default:        /* could consider as an error, but just ignore */</span>
<a href="#l15.174"></a><span id="l15.174" class="difflineplus">+                ;</span>
<a href="#l15.175"></a><span id="l15.175" class="difflineplus">+            }</span>
<a href="#l15.176"></a><span id="l15.176" class="difflineplus">+        mode++;</span>
<a href="#l15.177"></a><span id="l15.177" class="difflineplus">+    }</span>
<a href="#l15.178"></a><span id="l15.178" class="difflineplus">+</span>
<a href="#l15.179"></a><span id="l15.179" class="difflineplus">+    /* must provide an &quot;r&quot;, &quot;w&quot;, or &quot;a&quot; */</span>
<a href="#l15.180"></a><span id="l15.180" class="difflineplus">+    if (state-&gt;mode == GZ_NONE) {</span>
<a href="#l15.181"></a><span id="l15.181" class="difflineplus">+        free(state);</span>
<a href="#l15.182"></a><span id="l15.182" class="difflineplus">+        return NULL;</span>
<a href="#l15.183"></a><span id="l15.183" class="difflineplus">+    }</span>
<a href="#l15.184"></a><span id="l15.184" class="difflineplus">+</span>
<a href="#l15.185"></a><span id="l15.185" class="difflineplus">+    /* can't force transparent read */</span>
<a href="#l15.186"></a><span id="l15.186" class="difflineplus">+    if (state-&gt;mode == GZ_READ) {</span>
<a href="#l15.187"></a><span id="l15.187" class="difflineplus">+        if (state-&gt;direct) {</span>
<a href="#l15.188"></a><span id="l15.188" class="difflineplus">+            free(state);</span>
<a href="#l15.189"></a><span id="l15.189" class="difflineplus">+            return NULL;</span>
<a href="#l15.190"></a><span id="l15.190" class="difflineplus">+        }</span>
<a href="#l15.191"></a><span id="l15.191" class="difflineplus">+        state-&gt;direct = 1;      /* for empty file */</span>
<a href="#l15.192"></a><span id="l15.192" class="difflineplus">+    }</span>
<a href="#l15.193"></a><span id="l15.193" class="difflineplus">+</span>
<a href="#l15.194"></a><span id="l15.194" class="difflineplus">+    /* save the path name for error messages */</span>
<a href="#l15.195"></a><span id="l15.195" class="difflineplus">+#ifdef WIDECHAR</span>
<a href="#l15.196"></a><span id="l15.196" class="difflineplus">+    if (fd == -2) {</span>
<a href="#l15.197"></a><span id="l15.197" class="difflineplus">+        len = wcstombs(NULL, path, 0);</span>
<a href="#l15.198"></a><span id="l15.198" class="difflineplus">+        if (len == (z_size_t)-1)</span>
<a href="#l15.199"></a><span id="l15.199" class="difflineplus">+            len = 0;</span>
<a href="#l15.200"></a><span id="l15.200" class="difflineplus">+    }</span>
<a href="#l15.201"></a><span id="l15.201" class="difflineplus">+    else</span>
<a href="#l15.202"></a><span id="l15.202" class="difflineplus">+#endif</span>
<a href="#l15.203"></a><span id="l15.203" class="difflineplus">+        len = strlen((const char *)path);</span>
<a href="#l15.204"></a><span id="l15.204" class="difflineplus">+    state-&gt;path = (char *)malloc(len + 1);</span>
<a href="#l15.205"></a><span id="l15.205" class="difflineplus">+    if (state-&gt;path == NULL) {</span>
<a href="#l15.206"></a><span id="l15.206" class="difflineplus">+        free(state);</span>
<a href="#l15.207"></a><span id="l15.207" class="difflineplus">+        return NULL;</span>
<a href="#l15.208"></a><span id="l15.208" class="difflineplus">+    }</span>
<a href="#l15.209"></a><span id="l15.209" class="difflineplus">+#ifdef WIDECHAR</span>
<a href="#l15.210"></a><span id="l15.210" class="difflineplus">+    if (fd == -2)</span>
<a href="#l15.211"></a><span id="l15.211" class="difflineplus">+        if (len)</span>
<a href="#l15.212"></a><span id="l15.212" class="difflineplus">+            wcstombs(state-&gt;path, path, len + 1);</span>
<a href="#l15.213"></a><span id="l15.213" class="difflineplus">+        else</span>
<a href="#l15.214"></a><span id="l15.214" class="difflineplus">+            *(state-&gt;path) = 0;</span>
<a href="#l15.215"></a><span id="l15.215" class="difflineplus">+    else</span>
<a href="#l15.216"></a><span id="l15.216" class="difflineplus">+#endif</span>
<a href="#l15.217"></a><span id="l15.217" class="difflineplus">+#if !defined(NO_snprintf) &amp;&amp; !defined(NO_vsnprintf)</span>
<a href="#l15.218"></a><span id="l15.218" class="difflineplus">+        (void)snprintf(state-&gt;path, len + 1, &quot;%s&quot;, (const char *)path);</span>
<a href="#l15.219"></a><span id="l15.219" class="difflineplus">+#else</span>
<a href="#l15.220"></a><span id="l15.220" class="difflineplus">+        strcpy(state-&gt;path, path);</span>
<a href="#l15.221"></a><span id="l15.221" class="difflineplus">+#endif</span>
<a href="#l15.222"></a><span id="l15.222" class="difflineplus">+</span>
<a href="#l15.223"></a><span id="l15.223" class="difflineplus">+    /* compute the flags for open() */</span>
<a href="#l15.224"></a><span id="l15.224" class="difflineplus">+    oflag =</span>
<a href="#l15.225"></a><span id="l15.225" class="difflineplus">+#ifdef O_LARGEFILE</span>
<a href="#l15.226"></a><span id="l15.226" class="difflineplus">+        O_LARGEFILE |</span>
<a href="#l15.227"></a><span id="l15.227" class="difflineplus">+#endif</span>
<a href="#l15.228"></a><span id="l15.228" class="difflineplus">+#ifdef O_BINARY</span>
<a href="#l15.229"></a><span id="l15.229" class="difflineplus">+        O_BINARY |</span>
<a href="#l15.230"></a><span id="l15.230" class="difflineplus">+#endif</span>
<a href="#l15.231"></a><span id="l15.231" class="difflineplus">+#ifdef O_CLOEXEC</span>
<a href="#l15.232"></a><span id="l15.232" class="difflineplus">+        (cloexec ? O_CLOEXEC : 0) |</span>
<a href="#l15.233"></a><span id="l15.233" class="difflineplus">+#endif</span>
<a href="#l15.234"></a><span id="l15.234" class="difflineplus">+        (state-&gt;mode == GZ_READ ?</span>
<a href="#l15.235"></a><span id="l15.235" class="difflineplus">+         O_RDONLY :</span>
<a href="#l15.236"></a><span id="l15.236" class="difflineplus">+         (O_WRONLY | O_CREAT |</span>
<a href="#l15.237"></a><span id="l15.237" class="difflineplus">+#ifdef O_EXCL</span>
<a href="#l15.238"></a><span id="l15.238" class="difflineplus">+          (exclusive ? O_EXCL : 0) |</span>
<a href="#l15.239"></a><span id="l15.239" class="difflineplus">+#endif</span>
<a href="#l15.240"></a><span id="l15.240" class="difflineplus">+          (state-&gt;mode == GZ_WRITE ?</span>
<a href="#l15.241"></a><span id="l15.241" class="difflineplus">+           O_TRUNC :</span>
<a href="#l15.242"></a><span id="l15.242" class="difflineplus">+           O_APPEND)));</span>
<a href="#l15.243"></a><span id="l15.243" class="difflineplus">+</span>
<a href="#l15.244"></a><span id="l15.244" class="difflineplus">+    /* open the file with the appropriate flags (or just use fd) */</span>
<a href="#l15.245"></a><span id="l15.245" class="difflineplus">+    state-&gt;fd = fd &gt; -1 ? fd : (</span>
<a href="#l15.246"></a><span id="l15.246" class="difflineplus">+#ifdef WIDECHAR</span>
<a href="#l15.247"></a><span id="l15.247" class="difflineplus">+        fd == -2 ? _wopen(path, oflag, 0666) :</span>
<a href="#l15.248"></a><span id="l15.248" class="difflineplus">+#endif</span>
<a href="#l15.249"></a><span id="l15.249" class="difflineplus">+        open((const char *)path, oflag, 0666));</span>
<a href="#l15.250"></a><span id="l15.250" class="difflineplus">+    if (state-&gt;fd == -1) {</span>
<a href="#l15.251"></a><span id="l15.251" class="difflineplus">+        free(state-&gt;path);</span>
<a href="#l15.252"></a><span id="l15.252" class="difflineplus">+        free(state);</span>
<a href="#l15.253"></a><span id="l15.253" class="difflineplus">+        return NULL;</span>
<a href="#l15.254"></a><span id="l15.254" class="difflineplus">+    }</span>
<a href="#l15.255"></a><span id="l15.255" class="difflineplus">+    if (state-&gt;mode == GZ_APPEND) {</span>
<a href="#l15.256"></a><span id="l15.256" class="difflineplus">+        LSEEK(state-&gt;fd, 0, SEEK_END);  /* so gzoffset() is correct */</span>
<a href="#l15.257"></a><span id="l15.257" class="difflineplus">+        state-&gt;mode = GZ_WRITE;         /* simplify later checks */</span>
<a href="#l15.258"></a><span id="l15.258" class="difflineplus">+    }</span>
<a href="#l15.259"></a><span id="l15.259" class="difflineplus">+</span>
<a href="#l15.260"></a><span id="l15.260" class="difflineplus">+    /* save the current position for rewinding (only if reading) */</span>
<a href="#l15.261"></a><span id="l15.261" class="difflineplus">+    if (state-&gt;mode == GZ_READ) {</span>
<a href="#l15.262"></a><span id="l15.262" class="difflineplus">+        state-&gt;start = LSEEK(state-&gt;fd, 0, SEEK_CUR);</span>
<a href="#l15.263"></a><span id="l15.263" class="difflineplus">+        if (state-&gt;start == -1) state-&gt;start = 0;</span>
<a href="#l15.264"></a><span id="l15.264" class="difflineplus">+    }</span>
<a href="#l15.265"></a><span id="l15.265" class="difflineplus">+</span>
<a href="#l15.266"></a><span id="l15.266" class="difflineplus">+    /* initialize stream */</span>
<a href="#l15.267"></a><span id="l15.267" class="difflineplus">+    gz_reset(state);</span>
<a href="#l15.268"></a><span id="l15.268" class="difflineplus">+</span>
<a href="#l15.269"></a><span id="l15.269" class="difflineplus">+    /* return stream */</span>
<a href="#l15.270"></a><span id="l15.270" class="difflineplus">+    return (gzFile)state;</span>
<a href="#l15.271"></a><span id="l15.271" class="difflineplus">+}</span>
<a href="#l15.272"></a><span id="l15.272" class="difflineplus">+</span>
<a href="#l15.273"></a><span id="l15.273" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.274"></a><span id="l15.274" class="difflineplus">+gzFile ZEXPORT gzopen(path, mode)</span>
<a href="#l15.275"></a><span id="l15.275" class="difflineplus">+    const char *path;</span>
<a href="#l15.276"></a><span id="l15.276" class="difflineplus">+    const char *mode;</span>
<a href="#l15.277"></a><span id="l15.277" class="difflineplus">+{</span>
<a href="#l15.278"></a><span id="l15.278" class="difflineplus">+    return gz_open(path, -1, mode);</span>
<a href="#l15.279"></a><span id="l15.279" class="difflineplus">+}</span>
<a href="#l15.280"></a><span id="l15.280" class="difflineplus">+</span>
<a href="#l15.281"></a><span id="l15.281" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.282"></a><span id="l15.282" class="difflineplus">+gzFile ZEXPORT gzopen64(path, mode)</span>
<a href="#l15.283"></a><span id="l15.283" class="difflineplus">+    const char *path;</span>
<a href="#l15.284"></a><span id="l15.284" class="difflineplus">+    const char *mode;</span>
<a href="#l15.285"></a><span id="l15.285" class="difflineplus">+{</span>
<a href="#l15.286"></a><span id="l15.286" class="difflineplus">+    return gz_open(path, -1, mode);</span>
<a href="#l15.287"></a><span id="l15.287" class="difflineplus">+}</span>
<a href="#l15.288"></a><span id="l15.288" class="difflineplus">+</span>
<a href="#l15.289"></a><span id="l15.289" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.290"></a><span id="l15.290" class="difflineplus">+gzFile ZEXPORT gzdopen(fd, mode)</span>
<a href="#l15.291"></a><span id="l15.291" class="difflineplus">+    int fd;</span>
<a href="#l15.292"></a><span id="l15.292" class="difflineplus">+    const char *mode;</span>
<a href="#l15.293"></a><span id="l15.293" class="difflineplus">+{</span>
<a href="#l15.294"></a><span id="l15.294" class="difflineplus">+    char *path;         /* identifier for error messages */</span>
<a href="#l15.295"></a><span id="l15.295" class="difflineplus">+    gzFile gz;</span>
<a href="#l15.296"></a><span id="l15.296" class="difflineplus">+</span>
<a href="#l15.297"></a><span id="l15.297" class="difflineplus">+    if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)</span>
<a href="#l15.298"></a><span id="l15.298" class="difflineplus">+        return NULL;</span>
<a href="#l15.299"></a><span id="l15.299" class="difflineplus">+#if !defined(NO_snprintf) &amp;&amp; !defined(NO_vsnprintf)</span>
<a href="#l15.300"></a><span id="l15.300" class="difflineplus">+    (void)snprintf(path, 7 + 3 * sizeof(int), &quot;&lt;fd:%d&gt;&quot;, fd);</span>
<a href="#l15.301"></a><span id="l15.301" class="difflineplus">+#else</span>
<a href="#l15.302"></a><span id="l15.302" class="difflineplus">+    sprintf(path, &quot;&lt;fd:%d&gt;&quot;, fd);   /* for debugging */</span>
<a href="#l15.303"></a><span id="l15.303" class="difflineplus">+#endif</span>
<a href="#l15.304"></a><span id="l15.304" class="difflineplus">+    gz = gz_open(path, fd, mode);</span>
<a href="#l15.305"></a><span id="l15.305" class="difflineplus">+    free(path);</span>
<a href="#l15.306"></a><span id="l15.306" class="difflineplus">+    return gz;</span>
<a href="#l15.307"></a><span id="l15.307" class="difflineplus">+}</span>
<a href="#l15.308"></a><span id="l15.308" class="difflineplus">+</span>
<a href="#l15.309"></a><span id="l15.309" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.310"></a><span id="l15.310" class="difflineplus">+#ifdef WIDECHAR</span>
<a href="#l15.311"></a><span id="l15.311" class="difflineplus">+gzFile ZEXPORT gzopen_w(path, mode)</span>
<a href="#l15.312"></a><span id="l15.312" class="difflineplus">+    const wchar_t *path;</span>
<a href="#l15.313"></a><span id="l15.313" class="difflineplus">+    const char *mode;</span>
<a href="#l15.314"></a><span id="l15.314" class="difflineplus">+{</span>
<a href="#l15.315"></a><span id="l15.315" class="difflineplus">+    return gz_open(path, -2, mode);</span>
<a href="#l15.316"></a><span id="l15.316" class="difflineplus">+}</span>
<a href="#l15.317"></a><span id="l15.317" class="difflineplus">+#endif</span>
<a href="#l15.318"></a><span id="l15.318" class="difflineplus">+</span>
<a href="#l15.319"></a><span id="l15.319" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.320"></a><span id="l15.320" class="difflineplus">+int ZEXPORT gzbuffer(file, size)</span>
<a href="#l15.321"></a><span id="l15.321" class="difflineplus">+    gzFile file;</span>
<a href="#l15.322"></a><span id="l15.322" class="difflineplus">+    unsigned size;</span>
<a href="#l15.323"></a><span id="l15.323" class="difflineplus">+{</span>
<a href="#l15.324"></a><span id="l15.324" class="difflineplus">+    gz_statep state;</span>
<a href="#l15.325"></a><span id="l15.325" class="difflineplus">+</span>
<a href="#l15.326"></a><span id="l15.326" class="difflineplus">+    /* get internal structure and check integrity */</span>
<a href="#l15.327"></a><span id="l15.327" class="difflineplus">+    if (file == NULL)</span>
<a href="#l15.328"></a><span id="l15.328" class="difflineplus">+        return -1;</span>
<a href="#l15.329"></a><span id="l15.329" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l15.330"></a><span id="l15.330" class="difflineplus">+    if (state-&gt;mode != GZ_READ &amp;&amp; state-&gt;mode != GZ_WRITE)</span>
<a href="#l15.331"></a><span id="l15.331" class="difflineplus">+        return -1;</span>
<a href="#l15.332"></a><span id="l15.332" class="difflineplus">+</span>
<a href="#l15.333"></a><span id="l15.333" class="difflineplus">+    /* make sure we haven't already allocated memory */</span>
<a href="#l15.334"></a><span id="l15.334" class="difflineplus">+    if (state-&gt;size != 0)</span>
<a href="#l15.335"></a><span id="l15.335" class="difflineplus">+        return -1;</span>
<a href="#l15.336"></a><span id="l15.336" class="difflineplus">+</span>
<a href="#l15.337"></a><span id="l15.337" class="difflineplus">+    /* check and set requested size */</span>
<a href="#l15.338"></a><span id="l15.338" class="difflineplus">+    if ((size &lt;&lt; 1) &lt; size)</span>
<a href="#l15.339"></a><span id="l15.339" class="difflineplus">+        return -1;              /* need to be able to double it */</span>
<a href="#l15.340"></a><span id="l15.340" class="difflineplus">+    if (size &lt; 2)</span>
<a href="#l15.341"></a><span id="l15.341" class="difflineplus">+        size = 2;               /* need two bytes to check magic header */</span>
<a href="#l15.342"></a><span id="l15.342" class="difflineplus">+    state-&gt;want = size;</span>
<a href="#l15.343"></a><span id="l15.343" class="difflineplus">+    return 0;</span>
<a href="#l15.344"></a><span id="l15.344" class="difflineplus">+}</span>
<a href="#l15.345"></a><span id="l15.345" class="difflineplus">+</span>
<a href="#l15.346"></a><span id="l15.346" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.347"></a><span id="l15.347" class="difflineplus">+int ZEXPORT gzrewind(file)</span>
<a href="#l15.348"></a><span id="l15.348" class="difflineplus">+    gzFile file;</span>
<a href="#l15.349"></a><span id="l15.349" class="difflineplus">+{</span>
<a href="#l15.350"></a><span id="l15.350" class="difflineplus">+    gz_statep state;</span>
<a href="#l15.351"></a><span id="l15.351" class="difflineplus">+</span>
<a href="#l15.352"></a><span id="l15.352" class="difflineplus">+    /* get internal structure */</span>
<a href="#l15.353"></a><span id="l15.353" class="difflineplus">+    if (file == NULL)</span>
<a href="#l15.354"></a><span id="l15.354" class="difflineplus">+        return -1;</span>
<a href="#l15.355"></a><span id="l15.355" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l15.356"></a><span id="l15.356" class="difflineplus">+</span>
<a href="#l15.357"></a><span id="l15.357" class="difflineplus">+    /* check that we're reading and that there's no error */</span>
<a href="#l15.358"></a><span id="l15.358" class="difflineplus">+    if (state-&gt;mode != GZ_READ ||</span>
<a href="#l15.359"></a><span id="l15.359" class="difflineplus">+            (state-&gt;err != Z_OK &amp;&amp; state-&gt;err != Z_BUF_ERROR))</span>
<a href="#l15.360"></a><span id="l15.360" class="difflineplus">+        return -1;</span>
<a href="#l15.361"></a><span id="l15.361" class="difflineplus">+</span>
<a href="#l15.362"></a><span id="l15.362" class="difflineplus">+    /* back up and start over */</span>
<a href="#l15.363"></a><span id="l15.363" class="difflineplus">+    if (LSEEK(state-&gt;fd, state-&gt;start, SEEK_SET) == -1)</span>
<a href="#l15.364"></a><span id="l15.364" class="difflineplus">+        return -1;</span>
<a href="#l15.365"></a><span id="l15.365" class="difflineplus">+    gz_reset(state);</span>
<a href="#l15.366"></a><span id="l15.366" class="difflineplus">+    return 0;</span>
<a href="#l15.367"></a><span id="l15.367" class="difflineplus">+}</span>
<a href="#l15.368"></a><span id="l15.368" class="difflineplus">+</span>
<a href="#l15.369"></a><span id="l15.369" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.370"></a><span id="l15.370" class="difflineplus">+z_off64_t ZEXPORT gzseek64(file, offset, whence)</span>
<a href="#l15.371"></a><span id="l15.371" class="difflineplus">+    gzFile file;</span>
<a href="#l15.372"></a><span id="l15.372" class="difflineplus">+    z_off64_t offset;</span>
<a href="#l15.373"></a><span id="l15.373" class="difflineplus">+    int whence;</span>
<a href="#l15.374"></a><span id="l15.374" class="difflineplus">+{</span>
<a href="#l15.375"></a><span id="l15.375" class="difflineplus">+    unsigned n;</span>
<a href="#l15.376"></a><span id="l15.376" class="difflineplus">+    z_off64_t ret;</span>
<a href="#l15.377"></a><span id="l15.377" class="difflineplus">+    gz_statep state;</span>
<a href="#l15.378"></a><span id="l15.378" class="difflineplus">+</span>
<a href="#l15.379"></a><span id="l15.379" class="difflineplus">+    /* get internal structure and check integrity */</span>
<a href="#l15.380"></a><span id="l15.380" class="difflineplus">+    if (file == NULL)</span>
<a href="#l15.381"></a><span id="l15.381" class="difflineplus">+        return -1;</span>
<a href="#l15.382"></a><span id="l15.382" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l15.383"></a><span id="l15.383" class="difflineplus">+    if (state-&gt;mode != GZ_READ &amp;&amp; state-&gt;mode != GZ_WRITE)</span>
<a href="#l15.384"></a><span id="l15.384" class="difflineplus">+        return -1;</span>
<a href="#l15.385"></a><span id="l15.385" class="difflineplus">+</span>
<a href="#l15.386"></a><span id="l15.386" class="difflineplus">+    /* check that there's no error */</span>
<a href="#l15.387"></a><span id="l15.387" class="difflineplus">+    if (state-&gt;err != Z_OK &amp;&amp; state-&gt;err != Z_BUF_ERROR)</span>
<a href="#l15.388"></a><span id="l15.388" class="difflineplus">+        return -1;</span>
<a href="#l15.389"></a><span id="l15.389" class="difflineplus">+</span>
<a href="#l15.390"></a><span id="l15.390" class="difflineplus">+    /* can only seek from start or relative to current position */</span>
<a href="#l15.391"></a><span id="l15.391" class="difflineplus">+    if (whence != SEEK_SET &amp;&amp; whence != SEEK_CUR)</span>
<a href="#l15.392"></a><span id="l15.392" class="difflineplus">+        return -1;</span>
<a href="#l15.393"></a><span id="l15.393" class="difflineplus">+</span>
<a href="#l15.394"></a><span id="l15.394" class="difflineplus">+    /* normalize offset to a SEEK_CUR specification */</span>
<a href="#l15.395"></a><span id="l15.395" class="difflineplus">+    if (whence == SEEK_SET)</span>
<a href="#l15.396"></a><span id="l15.396" class="difflineplus">+        offset -= state-&gt;x.pos;</span>
<a href="#l15.397"></a><span id="l15.397" class="difflineplus">+    else if (state-&gt;seek)</span>
<a href="#l15.398"></a><span id="l15.398" class="difflineplus">+        offset += state-&gt;skip;</span>
<a href="#l15.399"></a><span id="l15.399" class="difflineplus">+    state-&gt;seek = 0;</span>
<a href="#l15.400"></a><span id="l15.400" class="difflineplus">+</span>
<a href="#l15.401"></a><span id="l15.401" class="difflineplus">+    /* if within raw area while reading, just go there */</span>
<a href="#l15.402"></a><span id="l15.402" class="difflineplus">+    if (state-&gt;mode == GZ_READ &amp;&amp; state-&gt;how == COPY &amp;&amp;</span>
<a href="#l15.403"></a><span id="l15.403" class="difflineplus">+            state-&gt;x.pos + offset &gt;= 0) {</span>
<a href="#l15.404"></a><span id="l15.404" class="difflineplus">+        ret = LSEEK(state-&gt;fd, offset - state-&gt;x.have, SEEK_CUR);</span>
<a href="#l15.405"></a><span id="l15.405" class="difflineplus">+        if (ret == -1)</span>
<a href="#l15.406"></a><span id="l15.406" class="difflineplus">+            return -1;</span>
<a href="#l15.407"></a><span id="l15.407" class="difflineplus">+        state-&gt;x.have = 0;</span>
<a href="#l15.408"></a><span id="l15.408" class="difflineplus">+        state-&gt;eof = 0;</span>
<a href="#l15.409"></a><span id="l15.409" class="difflineplus">+        state-&gt;past = 0;</span>
<a href="#l15.410"></a><span id="l15.410" class="difflineplus">+        state-&gt;seek = 0;</span>
<a href="#l15.411"></a><span id="l15.411" class="difflineplus">+        gz_error(state, Z_OK, NULL);</span>
<a href="#l15.412"></a><span id="l15.412" class="difflineplus">+        state-&gt;strm.avail_in = 0;</span>
<a href="#l15.413"></a><span id="l15.413" class="difflineplus">+        state-&gt;x.pos += offset;</span>
<a href="#l15.414"></a><span id="l15.414" class="difflineplus">+        return state-&gt;x.pos;</span>
<a href="#l15.415"></a><span id="l15.415" class="difflineplus">+    }</span>
<a href="#l15.416"></a><span id="l15.416" class="difflineplus">+</span>
<a href="#l15.417"></a><span id="l15.417" class="difflineplus">+    /* calculate skip amount, rewinding if needed for back seek when reading */</span>
<a href="#l15.418"></a><span id="l15.418" class="difflineplus">+    if (offset &lt; 0) {</span>
<a href="#l15.419"></a><span id="l15.419" class="difflineplus">+        if (state-&gt;mode != GZ_READ)         /* writing -- can't go backwards */</span>
<a href="#l15.420"></a><span id="l15.420" class="difflineplus">+            return -1;</span>
<a href="#l15.421"></a><span id="l15.421" class="difflineplus">+        offset += state-&gt;x.pos;</span>
<a href="#l15.422"></a><span id="l15.422" class="difflineplus">+        if (offset &lt; 0)                     /* before start of file! */</span>
<a href="#l15.423"></a><span id="l15.423" class="difflineplus">+            return -1;</span>
<a href="#l15.424"></a><span id="l15.424" class="difflineplus">+        if (gzrewind(file) == -1)           /* rewind, then skip to offset */</span>
<a href="#l15.425"></a><span id="l15.425" class="difflineplus">+            return -1;</span>
<a href="#l15.426"></a><span id="l15.426" class="difflineplus">+    }</span>
<a href="#l15.427"></a><span id="l15.427" class="difflineplus">+</span>
<a href="#l15.428"></a><span id="l15.428" class="difflineplus">+    /* if reading, skip what's in output buffer (one less gzgetc() check) */</span>
<a href="#l15.429"></a><span id="l15.429" class="difflineplus">+    if (state-&gt;mode == GZ_READ) {</span>
<a href="#l15.430"></a><span id="l15.430" class="difflineplus">+        n = GT_OFF(state-&gt;x.have) || (z_off64_t)state-&gt;x.have &gt; offset ?</span>
<a href="#l15.431"></a><span id="l15.431" class="difflineplus">+            (unsigned)offset : state-&gt;x.have;</span>
<a href="#l15.432"></a><span id="l15.432" class="difflineplus">+        state-&gt;x.have -= n;</span>
<a href="#l15.433"></a><span id="l15.433" class="difflineplus">+        state-&gt;x.next += n;</span>
<a href="#l15.434"></a><span id="l15.434" class="difflineplus">+        state-&gt;x.pos += n;</span>
<a href="#l15.435"></a><span id="l15.435" class="difflineplus">+        offset -= n;</span>
<a href="#l15.436"></a><span id="l15.436" class="difflineplus">+    }</span>
<a href="#l15.437"></a><span id="l15.437" class="difflineplus">+</span>
<a href="#l15.438"></a><span id="l15.438" class="difflineplus">+    /* request skip (if not zero) */</span>
<a href="#l15.439"></a><span id="l15.439" class="difflineplus">+    if (offset) {</span>
<a href="#l15.440"></a><span id="l15.440" class="difflineplus">+        state-&gt;seek = 1;</span>
<a href="#l15.441"></a><span id="l15.441" class="difflineplus">+        state-&gt;skip = offset;</span>
<a href="#l15.442"></a><span id="l15.442" class="difflineplus">+    }</span>
<a href="#l15.443"></a><span id="l15.443" class="difflineplus">+    return state-&gt;x.pos + offset;</span>
<a href="#l15.444"></a><span id="l15.444" class="difflineplus">+}</span>
<a href="#l15.445"></a><span id="l15.445" class="difflineplus">+</span>
<a href="#l15.446"></a><span id="l15.446" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.447"></a><span id="l15.447" class="difflineplus">+z_off_t ZEXPORT gzseek(file, offset, whence)</span>
<a href="#l15.448"></a><span id="l15.448" class="difflineplus">+    gzFile file;</span>
<a href="#l15.449"></a><span id="l15.449" class="difflineplus">+    z_off_t offset;</span>
<a href="#l15.450"></a><span id="l15.450" class="difflineplus">+    int whence;</span>
<a href="#l15.451"></a><span id="l15.451" class="difflineplus">+{</span>
<a href="#l15.452"></a><span id="l15.452" class="difflineplus">+    z_off64_t ret;</span>
<a href="#l15.453"></a><span id="l15.453" class="difflineplus">+</span>
<a href="#l15.454"></a><span id="l15.454" class="difflineplus">+    ret = gzseek64(file, (z_off64_t)offset, whence);</span>
<a href="#l15.455"></a><span id="l15.455" class="difflineplus">+    return ret == (z_off_t)ret ? (z_off_t)ret : -1;</span>
<a href="#l15.456"></a><span id="l15.456" class="difflineplus">+}</span>
<a href="#l15.457"></a><span id="l15.457" class="difflineplus">+</span>
<a href="#l15.458"></a><span id="l15.458" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.459"></a><span id="l15.459" class="difflineplus">+z_off64_t ZEXPORT gztell64(file)</span>
<a href="#l15.460"></a><span id="l15.460" class="difflineplus">+    gzFile file;</span>
<a href="#l15.461"></a><span id="l15.461" class="difflineplus">+{</span>
<a href="#l15.462"></a><span id="l15.462" class="difflineplus">+    gz_statep state;</span>
<a href="#l15.463"></a><span id="l15.463" class="difflineplus">+</span>
<a href="#l15.464"></a><span id="l15.464" class="difflineplus">+    /* get internal structure and check integrity */</span>
<a href="#l15.465"></a><span id="l15.465" class="difflineplus">+    if (file == NULL)</span>
<a href="#l15.466"></a><span id="l15.466" class="difflineplus">+        return -1;</span>
<a href="#l15.467"></a><span id="l15.467" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l15.468"></a><span id="l15.468" class="difflineplus">+    if (state-&gt;mode != GZ_READ &amp;&amp; state-&gt;mode != GZ_WRITE)</span>
<a href="#l15.469"></a><span id="l15.469" class="difflineplus">+        return -1;</span>
<a href="#l15.470"></a><span id="l15.470" class="difflineplus">+</span>
<a href="#l15.471"></a><span id="l15.471" class="difflineplus">+    /* return position */</span>
<a href="#l15.472"></a><span id="l15.472" class="difflineplus">+    return state-&gt;x.pos + (state-&gt;seek ? state-&gt;skip : 0);</span>
<a href="#l15.473"></a><span id="l15.473" class="difflineplus">+}</span>
<a href="#l15.474"></a><span id="l15.474" class="difflineplus">+</span>
<a href="#l15.475"></a><span id="l15.475" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.476"></a><span id="l15.476" class="difflineplus">+z_off_t ZEXPORT gztell(file)</span>
<a href="#l15.477"></a><span id="l15.477" class="difflineplus">+    gzFile file;</span>
<a href="#l15.478"></a><span id="l15.478" class="difflineplus">+{</span>
<a href="#l15.479"></a><span id="l15.479" class="difflineplus">+    z_off64_t ret;</span>
<a href="#l15.480"></a><span id="l15.480" class="difflineplus">+</span>
<a href="#l15.481"></a><span id="l15.481" class="difflineplus">+    ret = gztell64(file);</span>
<a href="#l15.482"></a><span id="l15.482" class="difflineplus">+    return ret == (z_off_t)ret ? (z_off_t)ret : -1;</span>
<a href="#l15.483"></a><span id="l15.483" class="difflineplus">+}</span>
<a href="#l15.484"></a><span id="l15.484" class="difflineplus">+</span>
<a href="#l15.485"></a><span id="l15.485" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.486"></a><span id="l15.486" class="difflineplus">+z_off64_t ZEXPORT gzoffset64(file)</span>
<a href="#l15.487"></a><span id="l15.487" class="difflineplus">+    gzFile file;</span>
<a href="#l15.488"></a><span id="l15.488" class="difflineplus">+{</span>
<a href="#l15.489"></a><span id="l15.489" class="difflineplus">+    z_off64_t offset;</span>
<a href="#l15.490"></a><span id="l15.490" class="difflineplus">+    gz_statep state;</span>
<a href="#l15.491"></a><span id="l15.491" class="difflineplus">+</span>
<a href="#l15.492"></a><span id="l15.492" class="difflineplus">+    /* get internal structure and check integrity */</span>
<a href="#l15.493"></a><span id="l15.493" class="difflineplus">+    if (file == NULL)</span>
<a href="#l15.494"></a><span id="l15.494" class="difflineplus">+        return -1;</span>
<a href="#l15.495"></a><span id="l15.495" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l15.496"></a><span id="l15.496" class="difflineplus">+    if (state-&gt;mode != GZ_READ &amp;&amp; state-&gt;mode != GZ_WRITE)</span>
<a href="#l15.497"></a><span id="l15.497" class="difflineplus">+        return -1;</span>
<a href="#l15.498"></a><span id="l15.498" class="difflineplus">+</span>
<a href="#l15.499"></a><span id="l15.499" class="difflineplus">+    /* compute and return effective offset in file */</span>
<a href="#l15.500"></a><span id="l15.500" class="difflineplus">+    offset = LSEEK(state-&gt;fd, 0, SEEK_CUR);</span>
<a href="#l15.501"></a><span id="l15.501" class="difflineplus">+    if (offset == -1)</span>
<a href="#l15.502"></a><span id="l15.502" class="difflineplus">+        return -1;</span>
<a href="#l15.503"></a><span id="l15.503" class="difflineplus">+    if (state-&gt;mode == GZ_READ)             /* reading */</span>
<a href="#l15.504"></a><span id="l15.504" class="difflineplus">+        offset -= state-&gt;strm.avail_in;     /* don't count buffered input */</span>
<a href="#l15.505"></a><span id="l15.505" class="difflineplus">+    return offset;</span>
<a href="#l15.506"></a><span id="l15.506" class="difflineplus">+}</span>
<a href="#l15.507"></a><span id="l15.507" class="difflineplus">+</span>
<a href="#l15.508"></a><span id="l15.508" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.509"></a><span id="l15.509" class="difflineplus">+z_off_t ZEXPORT gzoffset(file)</span>
<a href="#l15.510"></a><span id="l15.510" class="difflineplus">+    gzFile file;</span>
<a href="#l15.511"></a><span id="l15.511" class="difflineplus">+{</span>
<a href="#l15.512"></a><span id="l15.512" class="difflineplus">+    z_off64_t ret;</span>
<a href="#l15.513"></a><span id="l15.513" class="difflineplus">+</span>
<a href="#l15.514"></a><span id="l15.514" class="difflineplus">+    ret = gzoffset64(file);</span>
<a href="#l15.515"></a><span id="l15.515" class="difflineplus">+    return ret == (z_off_t)ret ? (z_off_t)ret : -1;</span>
<a href="#l15.516"></a><span id="l15.516" class="difflineplus">+}</span>
<a href="#l15.517"></a><span id="l15.517" class="difflineplus">+</span>
<a href="#l15.518"></a><span id="l15.518" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.519"></a><span id="l15.519" class="difflineplus">+int ZEXPORT gzeof(file)</span>
<a href="#l15.520"></a><span id="l15.520" class="difflineplus">+    gzFile file;</span>
<a href="#l15.521"></a><span id="l15.521" class="difflineplus">+{</span>
<a href="#l15.522"></a><span id="l15.522" class="difflineplus">+    gz_statep state;</span>
<a href="#l15.523"></a><span id="l15.523" class="difflineplus">+</span>
<a href="#l15.524"></a><span id="l15.524" class="difflineplus">+    /* get internal structure and check integrity */</span>
<a href="#l15.525"></a><span id="l15.525" class="difflineplus">+    if (file == NULL)</span>
<a href="#l15.526"></a><span id="l15.526" class="difflineplus">+        return 0;</span>
<a href="#l15.527"></a><span id="l15.527" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l15.528"></a><span id="l15.528" class="difflineplus">+    if (state-&gt;mode != GZ_READ &amp;&amp; state-&gt;mode != GZ_WRITE)</span>
<a href="#l15.529"></a><span id="l15.529" class="difflineplus">+        return 0;</span>
<a href="#l15.530"></a><span id="l15.530" class="difflineplus">+</span>
<a href="#l15.531"></a><span id="l15.531" class="difflineplus">+    /* return end-of-file state */</span>
<a href="#l15.532"></a><span id="l15.532" class="difflineplus">+    return state-&gt;mode == GZ_READ ? state-&gt;past : 0;</span>
<a href="#l15.533"></a><span id="l15.533" class="difflineplus">+}</span>
<a href="#l15.534"></a><span id="l15.534" class="difflineplus">+</span>
<a href="#l15.535"></a><span id="l15.535" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.536"></a><span id="l15.536" class="difflineplus">+const char * ZEXPORT gzerror(file, errnum)</span>
<a href="#l15.537"></a><span id="l15.537" class="difflineplus">+    gzFile file;</span>
<a href="#l15.538"></a><span id="l15.538" class="difflineplus">+    int *errnum;</span>
<a href="#l15.539"></a><span id="l15.539" class="difflineplus">+{</span>
<a href="#l15.540"></a><span id="l15.540" class="difflineplus">+    gz_statep state;</span>
<a href="#l15.541"></a><span id="l15.541" class="difflineplus">+</span>
<a href="#l15.542"></a><span id="l15.542" class="difflineplus">+    /* get internal structure and check integrity */</span>
<a href="#l15.543"></a><span id="l15.543" class="difflineplus">+    if (file == NULL)</span>
<a href="#l15.544"></a><span id="l15.544" class="difflineplus">+        return NULL;</span>
<a href="#l15.545"></a><span id="l15.545" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l15.546"></a><span id="l15.546" class="difflineplus">+    if (state-&gt;mode != GZ_READ &amp;&amp; state-&gt;mode != GZ_WRITE)</span>
<a href="#l15.547"></a><span id="l15.547" class="difflineplus">+        return NULL;</span>
<a href="#l15.548"></a><span id="l15.548" class="difflineplus">+</span>
<a href="#l15.549"></a><span id="l15.549" class="difflineplus">+    /* return error information */</span>
<a href="#l15.550"></a><span id="l15.550" class="difflineplus">+    if (errnum != NULL)</span>
<a href="#l15.551"></a><span id="l15.551" class="difflineplus">+        *errnum = state-&gt;err;</span>
<a href="#l15.552"></a><span id="l15.552" class="difflineplus">+    return state-&gt;err == Z_MEM_ERROR ? &quot;out of memory&quot; :</span>
<a href="#l15.553"></a><span id="l15.553" class="difflineplus">+                                       (state-&gt;msg == NULL ? &quot;&quot; : state-&gt;msg);</span>
<a href="#l15.554"></a><span id="l15.554" class="difflineplus">+}</span>
<a href="#l15.555"></a><span id="l15.555" class="difflineplus">+</span>
<a href="#l15.556"></a><span id="l15.556" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l15.557"></a><span id="l15.557" class="difflineplus">+void ZEXPORT gzclearerr(file)</span>
<a href="#l15.558"></a><span id="l15.558" class="difflineplus">+    gzFile file;</span>
<a href="#l15.559"></a><span id="l15.559" class="difflineplus">+{</span>
<a href="#l15.560"></a><span id="l15.560" class="difflineplus">+    gz_statep state;</span>
<a href="#l15.561"></a><span id="l15.561" class="difflineplus">+</span>
<a href="#l15.562"></a><span id="l15.562" class="difflineplus">+    /* get internal structure and check integrity */</span>
<a href="#l15.563"></a><span id="l15.563" class="difflineplus">+    if (file == NULL)</span>
<a href="#l15.564"></a><span id="l15.564" class="difflineplus">+        return;</span>
<a href="#l15.565"></a><span id="l15.565" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l15.566"></a><span id="l15.566" class="difflineplus">+    if (state-&gt;mode != GZ_READ &amp;&amp; state-&gt;mode != GZ_WRITE)</span>
<a href="#l15.567"></a><span id="l15.567" class="difflineplus">+        return;</span>
<a href="#l15.568"></a><span id="l15.568" class="difflineplus">+</span>
<a href="#l15.569"></a><span id="l15.569" class="difflineplus">+    /* clear error and end-of-file */</span>
<a href="#l15.570"></a><span id="l15.570" class="difflineplus">+    if (state-&gt;mode == GZ_READ) {</span>
<a href="#l15.571"></a><span id="l15.571" class="difflineplus">+        state-&gt;eof = 0;</span>
<a href="#l15.572"></a><span id="l15.572" class="difflineplus">+        state-&gt;past = 0;</span>
<a href="#l15.573"></a><span id="l15.573" class="difflineplus">+    }</span>
<a href="#l15.574"></a><span id="l15.574" class="difflineplus">+    gz_error(state, Z_OK, NULL);</span>
<a href="#l15.575"></a><span id="l15.575" class="difflineplus">+}</span>
<a href="#l15.576"></a><span id="l15.576" class="difflineplus">+</span>
<a href="#l15.577"></a><span id="l15.577" class="difflineplus">+/* Create an error message in allocated memory and set state-&gt;err and</span>
<a href="#l15.578"></a><span id="l15.578" class="difflineplus">+   state-&gt;msg accordingly.  Free any previous error message already there.  Do</span>
<a href="#l15.579"></a><span id="l15.579" class="difflineplus">+   not try to free or allocate space if the error is Z_MEM_ERROR (out of</span>
<a href="#l15.580"></a><span id="l15.580" class="difflineplus">+   memory).  Simply save the error message as a static string.  If there is an</span>
<a href="#l15.581"></a><span id="l15.581" class="difflineplus">+   allocation failure constructing the error message, then convert the error to</span>
<a href="#l15.582"></a><span id="l15.582" class="difflineplus">+   out of memory. */</span>
<a href="#l15.583"></a><span id="l15.583" class="difflineplus">+void ZLIB_INTERNAL gz_error(state, err, msg)</span>
<a href="#l15.584"></a><span id="l15.584" class="difflineplus">+    gz_statep state;</span>
<a href="#l15.585"></a><span id="l15.585" class="difflineplus">+    int err;</span>
<a href="#l15.586"></a><span id="l15.586" class="difflineplus">+    const char *msg;</span>
<a href="#l15.587"></a><span id="l15.587" class="difflineplus">+{</span>
<a href="#l15.588"></a><span id="l15.588" class="difflineplus">+    /* free previously allocated message and clear */</span>
<a href="#l15.589"></a><span id="l15.589" class="difflineplus">+    if (state-&gt;msg != NULL) {</span>
<a href="#l15.590"></a><span id="l15.590" class="difflineplus">+        if (state-&gt;err != Z_MEM_ERROR)</span>
<a href="#l15.591"></a><span id="l15.591" class="difflineplus">+            free(state-&gt;msg);</span>
<a href="#l15.592"></a><span id="l15.592" class="difflineplus">+        state-&gt;msg = NULL;</span>
<a href="#l15.593"></a><span id="l15.593" class="difflineplus">+    }</span>
<a href="#l15.594"></a><span id="l15.594" class="difflineplus">+</span>
<a href="#l15.595"></a><span id="l15.595" class="difflineplus">+    /* if fatal, set state-&gt;x.have to 0 so that the gzgetc() macro fails */</span>
<a href="#l15.596"></a><span id="l15.596" class="difflineplus">+    if (err != Z_OK &amp;&amp; err != Z_BUF_ERROR)</span>
<a href="#l15.597"></a><span id="l15.597" class="difflineplus">+        state-&gt;x.have = 0;</span>
<a href="#l15.598"></a><span id="l15.598" class="difflineplus">+</span>
<a href="#l15.599"></a><span id="l15.599" class="difflineplus">+    /* set error code, and if no message, then done */</span>
<a href="#l15.600"></a><span id="l15.600" class="difflineplus">+    state-&gt;err = err;</span>
<a href="#l15.601"></a><span id="l15.601" class="difflineplus">+    if (msg == NULL)</span>
<a href="#l15.602"></a><span id="l15.602" class="difflineplus">+        return;</span>
<a href="#l15.603"></a><span id="l15.603" class="difflineplus">+</span>
<a href="#l15.604"></a><span id="l15.604" class="difflineplus">+    /* for an out of memory error, return literal string when requested */</span>
<a href="#l15.605"></a><span id="l15.605" class="difflineplus">+    if (err == Z_MEM_ERROR)</span>
<a href="#l15.606"></a><span id="l15.606" class="difflineplus">+        return;</span>
<a href="#l15.607"></a><span id="l15.607" class="difflineplus">+</span>
<a href="#l15.608"></a><span id="l15.608" class="difflineplus">+    /* construct error message with path */</span>
<a href="#l15.609"></a><span id="l15.609" class="difflineplus">+    if ((state-&gt;msg = (char *)malloc(strlen(state-&gt;path) + strlen(msg) + 3)) ==</span>
<a href="#l15.610"></a><span id="l15.610" class="difflineplus">+            NULL) {</span>
<a href="#l15.611"></a><span id="l15.611" class="difflineplus">+        state-&gt;err = Z_MEM_ERROR;</span>
<a href="#l15.612"></a><span id="l15.612" class="difflineplus">+        return;</span>
<a href="#l15.613"></a><span id="l15.613" class="difflineplus">+    }</span>
<a href="#l15.614"></a><span id="l15.614" class="difflineplus">+#if !defined(NO_snprintf) &amp;&amp; !defined(NO_vsnprintf)</span>
<a href="#l15.615"></a><span id="l15.615" class="difflineplus">+    (void)snprintf(state-&gt;msg, strlen(state-&gt;path) + strlen(msg) + 3,</span>
<a href="#l15.616"></a><span id="l15.616" class="difflineplus">+                   &quot;%s%s%s&quot;, state-&gt;path, &quot;: &quot;, msg);</span>
<a href="#l15.617"></a><span id="l15.617" class="difflineplus">+#else</span>
<a href="#l15.618"></a><span id="l15.618" class="difflineplus">+    strcpy(state-&gt;msg, state-&gt;path);</span>
<a href="#l15.619"></a><span id="l15.619" class="difflineplus">+    strcat(state-&gt;msg, &quot;: &quot;);</span>
<a href="#l15.620"></a><span id="l15.620" class="difflineplus">+    strcat(state-&gt;msg, msg);</span>
<a href="#l15.621"></a><span id="l15.621" class="difflineplus">+#endif</span>
<a href="#l15.622"></a><span id="l15.622" class="difflineplus">+}</span>
<a href="#l15.623"></a><span id="l15.623" class="difflineplus">+</span>
<a href="#l15.624"></a><span id="l15.624" class="difflineplus">+#ifndef INT_MAX</span>
<a href="#l15.625"></a><span id="l15.625" class="difflineplus">+/* portably return maximum value for an int (when limits.h presumed not</span>
<a href="#l15.626"></a><span id="l15.626" class="difflineplus">+   available) -- we need to do this to cover cases where 2's complement not</span>
<a href="#l15.627"></a><span id="l15.627" class="difflineplus">+   used, since C standard permits 1's complement and sign-bit representations,</span>
<a href="#l15.628"></a><span id="l15.628" class="difflineplus">+   otherwise we could just use ((unsigned)-1) &gt;&gt; 1 */</span>
<a href="#l15.629"></a><span id="l15.629" class="difflineplus">+unsigned ZLIB_INTERNAL gz_intmax()</span>
<a href="#l15.630"></a><span id="l15.630" class="difflineplus">+{</span>
<a href="#l15.631"></a><span id="l15.631" class="difflineplus">+    unsigned p, q;</span>
<a href="#l15.632"></a><span id="l15.632" class="difflineplus">+</span>
<a href="#l15.633"></a><span id="l15.633" class="difflineplus">+    p = 1;</span>
<a href="#l15.634"></a><span id="l15.634" class="difflineplus">+    do {</span>
<a href="#l15.635"></a><span id="l15.635" class="difflineplus">+        q = p;</span>
<a href="#l15.636"></a><span id="l15.636" class="difflineplus">+        p &lt;&lt;= 1;</span>
<a href="#l15.637"></a><span id="l15.637" class="difflineplus">+        p++;</span>
<a href="#l15.638"></a><span id="l15.638" class="difflineplus">+    } while (p &gt; q);</span>
<a href="#l15.639"></a><span id="l15.639" class="difflineplus">+    return q &gt;&gt; 1;</span>
<a href="#l15.640"></a><span id="l15.640" class="difflineplus">+}</span>
<a href="#l15.641"></a><span id="l15.641" class="difflineplus">+#endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1">new file mode 100644</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineminus">--- /dev/null</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineplus">+++ b/third_party/zlib/gzread.c</span>
<a href="#l16.4"></a><span id="l16.4" class="difflineat">@@ -0,0 +1,654 @@</span>
<a href="#l16.5"></a><span id="l16.5" class="difflineplus">+/* gzread.c -- zlib functions for reading gzip files</span>
<a href="#l16.6"></a><span id="l16.6" class="difflineplus">+ * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler</span>
<a href="#l16.7"></a><span id="l16.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l16.8"></a><span id="l16.8" class="difflineplus">+ */</span>
<a href="#l16.9"></a><span id="l16.9" class="difflineplus">+</span>
<a href="#l16.10"></a><span id="l16.10" class="difflineplus">+#include &quot;gzguts.h&quot;</span>
<a href="#l16.11"></a><span id="l16.11" class="difflineplus">+</span>
<a href="#l16.12"></a><span id="l16.12" class="difflineplus">+/* Local functions */</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+local int gz_load OF((gz_statep, unsigned char *, unsigned, unsigned *));</span>
<a href="#l16.14"></a><span id="l16.14" class="difflineplus">+local int gz_avail OF((gz_statep));</span>
<a href="#l16.15"></a><span id="l16.15" class="difflineplus">+local int gz_look OF((gz_statep));</span>
<a href="#l16.16"></a><span id="l16.16" class="difflineplus">+local int gz_decomp OF((gz_statep));</span>
<a href="#l16.17"></a><span id="l16.17" class="difflineplus">+local int gz_fetch OF((gz_statep));</span>
<a href="#l16.18"></a><span id="l16.18" class="difflineplus">+local int gz_skip OF((gz_statep, z_off64_t));</span>
<a href="#l16.19"></a><span id="l16.19" class="difflineplus">+local z_size_t gz_read OF((gz_statep, voidp, z_size_t));</span>
<a href="#l16.20"></a><span id="l16.20" class="difflineplus">+</span>
<a href="#l16.21"></a><span id="l16.21" class="difflineplus">+/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from</span>
<a href="#l16.22"></a><span id="l16.22" class="difflineplus">+   state-&gt;fd, and update state-&gt;eof, state-&gt;err, and state-&gt;msg as appropriate.</span>
<a href="#l16.23"></a><span id="l16.23" class="difflineplus">+   This function needs to loop on read(), since read() is not guaranteed to</span>
<a href="#l16.24"></a><span id="l16.24" class="difflineplus">+   read the number of bytes requested, depending on the type of descriptor. */</span>
<a href="#l16.25"></a><span id="l16.25" class="difflineplus">+local int gz_load(state, buf, len, have)</span>
<a href="#l16.26"></a><span id="l16.26" class="difflineplus">+    gz_statep state;</span>
<a href="#l16.27"></a><span id="l16.27" class="difflineplus">+    unsigned char *buf;</span>
<a href="#l16.28"></a><span id="l16.28" class="difflineplus">+    unsigned len;</span>
<a href="#l16.29"></a><span id="l16.29" class="difflineplus">+    unsigned *have;</span>
<a href="#l16.30"></a><span id="l16.30" class="difflineplus">+{</span>
<a href="#l16.31"></a><span id="l16.31" class="difflineplus">+    int ret;</span>
<a href="#l16.32"></a><span id="l16.32" class="difflineplus">+    unsigned get, max = ((unsigned)-1 &gt;&gt; 2) + 1;</span>
<a href="#l16.33"></a><span id="l16.33" class="difflineplus">+</span>
<a href="#l16.34"></a><span id="l16.34" class="difflineplus">+    *have = 0;</span>
<a href="#l16.35"></a><span id="l16.35" class="difflineplus">+    do {</span>
<a href="#l16.36"></a><span id="l16.36" class="difflineplus">+        get = len - *have;</span>
<a href="#l16.37"></a><span id="l16.37" class="difflineplus">+        if (get &gt; max)</span>
<a href="#l16.38"></a><span id="l16.38" class="difflineplus">+            get = max;</span>
<a href="#l16.39"></a><span id="l16.39" class="difflineplus">+        ret = read(state-&gt;fd, buf + *have, get);</span>
<a href="#l16.40"></a><span id="l16.40" class="difflineplus">+        if (ret &lt;= 0)</span>
<a href="#l16.41"></a><span id="l16.41" class="difflineplus">+            break;</span>
<a href="#l16.42"></a><span id="l16.42" class="difflineplus">+        *have += (unsigned)ret;</span>
<a href="#l16.43"></a><span id="l16.43" class="difflineplus">+    } while (*have &lt; len);</span>
<a href="#l16.44"></a><span id="l16.44" class="difflineplus">+    if (ret &lt; 0) {</span>
<a href="#l16.45"></a><span id="l16.45" class="difflineplus">+        gz_error(state, Z_ERRNO, zstrerror());</span>
<a href="#l16.46"></a><span id="l16.46" class="difflineplus">+        return -1;</span>
<a href="#l16.47"></a><span id="l16.47" class="difflineplus">+    }</span>
<a href="#l16.48"></a><span id="l16.48" class="difflineplus">+    if (ret == 0)</span>
<a href="#l16.49"></a><span id="l16.49" class="difflineplus">+        state-&gt;eof = 1;</span>
<a href="#l16.50"></a><span id="l16.50" class="difflineplus">+    return 0;</span>
<a href="#l16.51"></a><span id="l16.51" class="difflineplus">+}</span>
<a href="#l16.52"></a><span id="l16.52" class="difflineplus">+</span>
<a href="#l16.53"></a><span id="l16.53" class="difflineplus">+/* Load up input buffer and set eof flag if last data loaded -- return -1 on</span>
<a href="#l16.54"></a><span id="l16.54" class="difflineplus">+   error, 0 otherwise.  Note that the eof flag is set when the end of the input</span>
<a href="#l16.55"></a><span id="l16.55" class="difflineplus">+   file is reached, even though there may be unused data in the buffer.  Once</span>
<a href="#l16.56"></a><span id="l16.56" class="difflineplus">+   that data has been used, no more attempts will be made to read the file.</span>
<a href="#l16.57"></a><span id="l16.57" class="difflineplus">+   If strm-&gt;avail_in != 0, then the current data is moved to the beginning of</span>
<a href="#l16.58"></a><span id="l16.58" class="difflineplus">+   the input buffer, and then the remainder of the buffer is loaded with the</span>
<a href="#l16.59"></a><span id="l16.59" class="difflineplus">+   available data from the input file. */</span>
<a href="#l16.60"></a><span id="l16.60" class="difflineplus">+local int gz_avail(state)</span>
<a href="#l16.61"></a><span id="l16.61" class="difflineplus">+    gz_statep state;</span>
<a href="#l16.62"></a><span id="l16.62" class="difflineplus">+{</span>
<a href="#l16.63"></a><span id="l16.63" class="difflineplus">+    unsigned got;</span>
<a href="#l16.64"></a><span id="l16.64" class="difflineplus">+    z_streamp strm = &amp;(state-&gt;strm);</span>
<a href="#l16.65"></a><span id="l16.65" class="difflineplus">+</span>
<a href="#l16.66"></a><span id="l16.66" class="difflineplus">+    if (state-&gt;err != Z_OK &amp;&amp; state-&gt;err != Z_BUF_ERROR)</span>
<a href="#l16.67"></a><span id="l16.67" class="difflineplus">+        return -1;</span>
<a href="#l16.68"></a><span id="l16.68" class="difflineplus">+    if (state-&gt;eof == 0) {</span>
<a href="#l16.69"></a><span id="l16.69" class="difflineplus">+        if (strm-&gt;avail_in) {       /* copy what's there to the start */</span>
<a href="#l16.70"></a><span id="l16.70" class="difflineplus">+            unsigned char *p = state-&gt;in;</span>
<a href="#l16.71"></a><span id="l16.71" class="difflineplus">+            unsigned const char *q = strm-&gt;next_in;</span>
<a href="#l16.72"></a><span id="l16.72" class="difflineplus">+            unsigned n = strm-&gt;avail_in;</span>
<a href="#l16.73"></a><span id="l16.73" class="difflineplus">+            do {</span>
<a href="#l16.74"></a><span id="l16.74" class="difflineplus">+                *p++ = *q++;</span>
<a href="#l16.75"></a><span id="l16.75" class="difflineplus">+            } while (--n);</span>
<a href="#l16.76"></a><span id="l16.76" class="difflineplus">+        }</span>
<a href="#l16.77"></a><span id="l16.77" class="difflineplus">+        if (gz_load(state, state-&gt;in + strm-&gt;avail_in,</span>
<a href="#l16.78"></a><span id="l16.78" class="difflineplus">+                    state-&gt;size - strm-&gt;avail_in, &amp;got) == -1)</span>
<a href="#l16.79"></a><span id="l16.79" class="difflineplus">+            return -1;</span>
<a href="#l16.80"></a><span id="l16.80" class="difflineplus">+        strm-&gt;avail_in += got;</span>
<a href="#l16.81"></a><span id="l16.81" class="difflineplus">+        strm-&gt;next_in = state-&gt;in;</span>
<a href="#l16.82"></a><span id="l16.82" class="difflineplus">+    }</span>
<a href="#l16.83"></a><span id="l16.83" class="difflineplus">+    return 0;</span>
<a href="#l16.84"></a><span id="l16.84" class="difflineplus">+}</span>
<a href="#l16.85"></a><span id="l16.85" class="difflineplus">+</span>
<a href="#l16.86"></a><span id="l16.86" class="difflineplus">+/* Look for gzip header, set up for inflate or copy.  state-&gt;x.have must be 0.</span>
<a href="#l16.87"></a><span id="l16.87" class="difflineplus">+   If this is the first time in, allocate required memory.  state-&gt;how will be</span>
<a href="#l16.88"></a><span id="l16.88" class="difflineplus">+   left unchanged if there is no more input data available, will be set to COPY</span>
<a href="#l16.89"></a><span id="l16.89" class="difflineplus">+   if there is no gzip header and direct copying will be performed, or it will</span>
<a href="#l16.90"></a><span id="l16.90" class="difflineplus">+   be set to GZIP for decompression.  If direct copying, then leftover input</span>
<a href="#l16.91"></a><span id="l16.91" class="difflineplus">+   data from the input buffer will be copied to the output buffer.  In that</span>
<a href="#l16.92"></a><span id="l16.92" class="difflineplus">+   case, all further file reads will be directly to either the output buffer or</span>
<a href="#l16.93"></a><span id="l16.93" class="difflineplus">+   a user buffer.  If decompressing, the inflate state will be initialized.</span>
<a href="#l16.94"></a><span id="l16.94" class="difflineplus">+   gz_look() will return 0 on success or -1 on failure. */</span>
<a href="#l16.95"></a><span id="l16.95" class="difflineplus">+local int gz_look(state)</span>
<a href="#l16.96"></a><span id="l16.96" class="difflineplus">+    gz_statep state;</span>
<a href="#l16.97"></a><span id="l16.97" class="difflineplus">+{</span>
<a href="#l16.98"></a><span id="l16.98" class="difflineplus">+    z_streamp strm = &amp;(state-&gt;strm);</span>
<a href="#l16.99"></a><span id="l16.99" class="difflineplus">+</span>
<a href="#l16.100"></a><span id="l16.100" class="difflineplus">+    /* allocate read buffers and inflate memory */</span>
<a href="#l16.101"></a><span id="l16.101" class="difflineplus">+    if (state-&gt;size == 0) {</span>
<a href="#l16.102"></a><span id="l16.102" class="difflineplus">+        /* allocate buffers */</span>
<a href="#l16.103"></a><span id="l16.103" class="difflineplus">+        state-&gt;in = (unsigned char *)malloc(state-&gt;want);</span>
<a href="#l16.104"></a><span id="l16.104" class="difflineplus">+        state-&gt;out = (unsigned char *)malloc(state-&gt;want &lt;&lt; 1);</span>
<a href="#l16.105"></a><span id="l16.105" class="difflineplus">+        if (state-&gt;in == NULL || state-&gt;out == NULL) {</span>
<a href="#l16.106"></a><span id="l16.106" class="difflineplus">+            free(state-&gt;out);</span>
<a href="#l16.107"></a><span id="l16.107" class="difflineplus">+            free(state-&gt;in);</span>
<a href="#l16.108"></a><span id="l16.108" class="difflineplus">+            gz_error(state, Z_MEM_ERROR, &quot;out of memory&quot;);</span>
<a href="#l16.109"></a><span id="l16.109" class="difflineplus">+            return -1;</span>
<a href="#l16.110"></a><span id="l16.110" class="difflineplus">+        }</span>
<a href="#l16.111"></a><span id="l16.111" class="difflineplus">+        state-&gt;size = state-&gt;want;</span>
<a href="#l16.112"></a><span id="l16.112" class="difflineplus">+</span>
<a href="#l16.113"></a><span id="l16.113" class="difflineplus">+        /* allocate inflate memory */</span>
<a href="#l16.114"></a><span id="l16.114" class="difflineplus">+        state-&gt;strm.zalloc = Z_NULL;</span>
<a href="#l16.115"></a><span id="l16.115" class="difflineplus">+        state-&gt;strm.zfree = Z_NULL;</span>
<a href="#l16.116"></a><span id="l16.116" class="difflineplus">+        state-&gt;strm.opaque = Z_NULL;</span>
<a href="#l16.117"></a><span id="l16.117" class="difflineplus">+        state-&gt;strm.avail_in = 0;</span>
<a href="#l16.118"></a><span id="l16.118" class="difflineplus">+        state-&gt;strm.next_in = Z_NULL;</span>
<a href="#l16.119"></a><span id="l16.119" class="difflineplus">+        if (inflateInit2(&amp;(state-&gt;strm), 15 + 16) != Z_OK) {    /* gunzip */</span>
<a href="#l16.120"></a><span id="l16.120" class="difflineplus">+            free(state-&gt;out);</span>
<a href="#l16.121"></a><span id="l16.121" class="difflineplus">+            free(state-&gt;in);</span>
<a href="#l16.122"></a><span id="l16.122" class="difflineplus">+            state-&gt;size = 0;</span>
<a href="#l16.123"></a><span id="l16.123" class="difflineplus">+            gz_error(state, Z_MEM_ERROR, &quot;out of memory&quot;);</span>
<a href="#l16.124"></a><span id="l16.124" class="difflineplus">+            return -1;</span>
<a href="#l16.125"></a><span id="l16.125" class="difflineplus">+        }</span>
<a href="#l16.126"></a><span id="l16.126" class="difflineplus">+    }</span>
<a href="#l16.127"></a><span id="l16.127" class="difflineplus">+</span>
<a href="#l16.128"></a><span id="l16.128" class="difflineplus">+    /* get at least the magic bytes in the input buffer */</span>
<a href="#l16.129"></a><span id="l16.129" class="difflineplus">+    if (strm-&gt;avail_in &lt; 2) {</span>
<a href="#l16.130"></a><span id="l16.130" class="difflineplus">+        if (gz_avail(state) == -1)</span>
<a href="#l16.131"></a><span id="l16.131" class="difflineplus">+            return -1;</span>
<a href="#l16.132"></a><span id="l16.132" class="difflineplus">+        if (strm-&gt;avail_in == 0)</span>
<a href="#l16.133"></a><span id="l16.133" class="difflineplus">+            return 0;</span>
<a href="#l16.134"></a><span id="l16.134" class="difflineplus">+    }</span>
<a href="#l16.135"></a><span id="l16.135" class="difflineplus">+</span>
<a href="#l16.136"></a><span id="l16.136" class="difflineplus">+    /* look for gzip magic bytes -- if there, do gzip decoding (note: there is</span>
<a href="#l16.137"></a><span id="l16.137" class="difflineplus">+       a logical dilemma here when considering the case of a partially written</span>
<a href="#l16.138"></a><span id="l16.138" class="difflineplus">+       gzip file, to wit, if a single 31 byte is written, then we cannot tell</span>
<a href="#l16.139"></a><span id="l16.139" class="difflineplus">+       whether this is a single-byte file, or just a partially written gzip</span>
<a href="#l16.140"></a><span id="l16.140" class="difflineplus">+       file -- for here we assume that if a gzip file is being written, then</span>
<a href="#l16.141"></a><span id="l16.141" class="difflineplus">+       the header will be written in a single operation, so that reading a</span>
<a href="#l16.142"></a><span id="l16.142" class="difflineplus">+       single byte is sufficient indication that it is not a gzip file) */</span>
<a href="#l16.143"></a><span id="l16.143" class="difflineplus">+    if (strm-&gt;avail_in &gt; 1 &amp;&amp;</span>
<a href="#l16.144"></a><span id="l16.144" class="difflineplus">+            strm-&gt;next_in[0] == 31 &amp;&amp; strm-&gt;next_in[1] == 139) {</span>
<a href="#l16.145"></a><span id="l16.145" class="difflineplus">+        inflateReset(strm);</span>
<a href="#l16.146"></a><span id="l16.146" class="difflineplus">+        state-&gt;how = GZIP;</span>
<a href="#l16.147"></a><span id="l16.147" class="difflineplus">+        state-&gt;direct = 0;</span>
<a href="#l16.148"></a><span id="l16.148" class="difflineplus">+        return 0;</span>
<a href="#l16.149"></a><span id="l16.149" class="difflineplus">+    }</span>
<a href="#l16.150"></a><span id="l16.150" class="difflineplus">+</span>
<a href="#l16.151"></a><span id="l16.151" class="difflineplus">+    /* no gzip header -- if we were decoding gzip before, then this is trailing</span>
<a href="#l16.152"></a><span id="l16.152" class="difflineplus">+       garbage.  Ignore the trailing garbage and finish. */</span>
<a href="#l16.153"></a><span id="l16.153" class="difflineplus">+    if (state-&gt;direct == 0) {</span>
<a href="#l16.154"></a><span id="l16.154" class="difflineplus">+        strm-&gt;avail_in = 0;</span>
<a href="#l16.155"></a><span id="l16.155" class="difflineplus">+        state-&gt;eof = 1;</span>
<a href="#l16.156"></a><span id="l16.156" class="difflineplus">+        state-&gt;x.have = 0;</span>
<a href="#l16.157"></a><span id="l16.157" class="difflineplus">+        return 0;</span>
<a href="#l16.158"></a><span id="l16.158" class="difflineplus">+    }</span>
<a href="#l16.159"></a><span id="l16.159" class="difflineplus">+</span>
<a href="#l16.160"></a><span id="l16.160" class="difflineplus">+    /* doing raw i/o, copy any leftover input to output -- this assumes that</span>
<a href="#l16.161"></a><span id="l16.161" class="difflineplus">+       the output buffer is larger than the input buffer, which also assures</span>
<a href="#l16.162"></a><span id="l16.162" class="difflineplus">+       space for gzungetc() */</span>
<a href="#l16.163"></a><span id="l16.163" class="difflineplus">+    state-&gt;x.next = state-&gt;out;</span>
<a href="#l16.164"></a><span id="l16.164" class="difflineplus">+    if (strm-&gt;avail_in) {</span>
<a href="#l16.165"></a><span id="l16.165" class="difflineplus">+        memcpy(state-&gt;x.next, strm-&gt;next_in, strm-&gt;avail_in);</span>
<a href="#l16.166"></a><span id="l16.166" class="difflineplus">+        state-&gt;x.have = strm-&gt;avail_in;</span>
<a href="#l16.167"></a><span id="l16.167" class="difflineplus">+        strm-&gt;avail_in = 0;</span>
<a href="#l16.168"></a><span id="l16.168" class="difflineplus">+    }</span>
<a href="#l16.169"></a><span id="l16.169" class="difflineplus">+    state-&gt;how = COPY;</span>
<a href="#l16.170"></a><span id="l16.170" class="difflineplus">+    state-&gt;direct = 1;</span>
<a href="#l16.171"></a><span id="l16.171" class="difflineplus">+    return 0;</span>
<a href="#l16.172"></a><span id="l16.172" class="difflineplus">+}</span>
<a href="#l16.173"></a><span id="l16.173" class="difflineplus">+</span>
<a href="#l16.174"></a><span id="l16.174" class="difflineplus">+/* Decompress from input to the provided next_out and avail_out in the state.</span>
<a href="#l16.175"></a><span id="l16.175" class="difflineplus">+   On return, state-&gt;x.have and state-&gt;x.next point to the just decompressed</span>
<a href="#l16.176"></a><span id="l16.176" class="difflineplus">+   data.  If the gzip stream completes, state-&gt;how is reset to LOOK to look for</span>
<a href="#l16.177"></a><span id="l16.177" class="difflineplus">+   the next gzip stream or raw data, once state-&gt;x.have is depleted.  Returns 0</span>
<a href="#l16.178"></a><span id="l16.178" class="difflineplus">+   on success, -1 on failure. */</span>
<a href="#l16.179"></a><span id="l16.179" class="difflineplus">+local int gz_decomp(state)</span>
<a href="#l16.180"></a><span id="l16.180" class="difflineplus">+    gz_statep state;</span>
<a href="#l16.181"></a><span id="l16.181" class="difflineplus">+{</span>
<a href="#l16.182"></a><span id="l16.182" class="difflineplus">+    int ret = Z_OK;</span>
<a href="#l16.183"></a><span id="l16.183" class="difflineplus">+    unsigned had;</span>
<a href="#l16.184"></a><span id="l16.184" class="difflineplus">+    z_streamp strm = &amp;(state-&gt;strm);</span>
<a href="#l16.185"></a><span id="l16.185" class="difflineplus">+</span>
<a href="#l16.186"></a><span id="l16.186" class="difflineplus">+    /* fill output buffer up to end of deflate stream */</span>
<a href="#l16.187"></a><span id="l16.187" class="difflineplus">+    had = strm-&gt;avail_out;</span>
<a href="#l16.188"></a><span id="l16.188" class="difflineplus">+    do {</span>
<a href="#l16.189"></a><span id="l16.189" class="difflineplus">+        /* get more input for inflate() */</span>
<a href="#l16.190"></a><span id="l16.190" class="difflineplus">+        if (strm-&gt;avail_in == 0 &amp;&amp; gz_avail(state) == -1)</span>
<a href="#l16.191"></a><span id="l16.191" class="difflineplus">+            return -1;</span>
<a href="#l16.192"></a><span id="l16.192" class="difflineplus">+        if (strm-&gt;avail_in == 0) {</span>
<a href="#l16.193"></a><span id="l16.193" class="difflineplus">+            gz_error(state, Z_BUF_ERROR, &quot;unexpected end of file&quot;);</span>
<a href="#l16.194"></a><span id="l16.194" class="difflineplus">+            break;</span>
<a href="#l16.195"></a><span id="l16.195" class="difflineplus">+        }</span>
<a href="#l16.196"></a><span id="l16.196" class="difflineplus">+</span>
<a href="#l16.197"></a><span id="l16.197" class="difflineplus">+        /* decompress and handle errors */</span>
<a href="#l16.198"></a><span id="l16.198" class="difflineplus">+        ret = inflate(strm, Z_NO_FLUSH);</span>
<a href="#l16.199"></a><span id="l16.199" class="difflineplus">+        if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {</span>
<a href="#l16.200"></a><span id="l16.200" class="difflineplus">+            gz_error(state, Z_STREAM_ERROR,</span>
<a href="#l16.201"></a><span id="l16.201" class="difflineplus">+                     &quot;internal error: inflate stream corrupt&quot;);</span>
<a href="#l16.202"></a><span id="l16.202" class="difflineplus">+            return -1;</span>
<a href="#l16.203"></a><span id="l16.203" class="difflineplus">+        }</span>
<a href="#l16.204"></a><span id="l16.204" class="difflineplus">+        if (ret == Z_MEM_ERROR) {</span>
<a href="#l16.205"></a><span id="l16.205" class="difflineplus">+            gz_error(state, Z_MEM_ERROR, &quot;out of memory&quot;);</span>
<a href="#l16.206"></a><span id="l16.206" class="difflineplus">+            return -1;</span>
<a href="#l16.207"></a><span id="l16.207" class="difflineplus">+        }</span>
<a href="#l16.208"></a><span id="l16.208" class="difflineplus">+        if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */</span>
<a href="#l16.209"></a><span id="l16.209" class="difflineplus">+            gz_error(state, Z_DATA_ERROR,</span>
<a href="#l16.210"></a><span id="l16.210" class="difflineplus">+                     strm-&gt;msg == NULL ? &quot;compressed data error&quot; : strm-&gt;msg);</span>
<a href="#l16.211"></a><span id="l16.211" class="difflineplus">+            return -1;</span>
<a href="#l16.212"></a><span id="l16.212" class="difflineplus">+        }</span>
<a href="#l16.213"></a><span id="l16.213" class="difflineplus">+    } while (strm-&gt;avail_out &amp;&amp; ret != Z_STREAM_END);</span>
<a href="#l16.214"></a><span id="l16.214" class="difflineplus">+</span>
<a href="#l16.215"></a><span id="l16.215" class="difflineplus">+    /* update available output */</span>
<a href="#l16.216"></a><span id="l16.216" class="difflineplus">+    state-&gt;x.have = had - strm-&gt;avail_out;</span>
<a href="#l16.217"></a><span id="l16.217" class="difflineplus">+    state-&gt;x.next = strm-&gt;next_out - state-&gt;x.have;</span>
<a href="#l16.218"></a><span id="l16.218" class="difflineplus">+</span>
<a href="#l16.219"></a><span id="l16.219" class="difflineplus">+    /* if the gzip stream completed successfully, look for another */</span>
<a href="#l16.220"></a><span id="l16.220" class="difflineplus">+    if (ret == Z_STREAM_END)</span>
<a href="#l16.221"></a><span id="l16.221" class="difflineplus">+        state-&gt;how = LOOK;</span>
<a href="#l16.222"></a><span id="l16.222" class="difflineplus">+</span>
<a href="#l16.223"></a><span id="l16.223" class="difflineplus">+    /* good decompression */</span>
<a href="#l16.224"></a><span id="l16.224" class="difflineplus">+    return 0;</span>
<a href="#l16.225"></a><span id="l16.225" class="difflineplus">+}</span>
<a href="#l16.226"></a><span id="l16.226" class="difflineplus">+</span>
<a href="#l16.227"></a><span id="l16.227" class="difflineplus">+/* Fetch data and put it in the output buffer.  Assumes state-&gt;x.have is 0.</span>
<a href="#l16.228"></a><span id="l16.228" class="difflineplus">+   Data is either copied from the input file or decompressed from the input</span>
<a href="#l16.229"></a><span id="l16.229" class="difflineplus">+   file depending on state-&gt;how.  If state-&gt;how is LOOK, then a gzip header is</span>
<a href="#l16.230"></a><span id="l16.230" class="difflineplus">+   looked for to determine whether to copy or decompress.  Returns -1 on error,</span>
<a href="#l16.231"></a><span id="l16.231" class="difflineplus">+   otherwise 0.  gz_fetch() will leave state-&gt;how as COPY or GZIP unless the</span>
<a href="#l16.232"></a><span id="l16.232" class="difflineplus">+   end of the input file has been reached and all data has been processed.  */</span>
<a href="#l16.233"></a><span id="l16.233" class="difflineplus">+local int gz_fetch(state)</span>
<a href="#l16.234"></a><span id="l16.234" class="difflineplus">+    gz_statep state;</span>
<a href="#l16.235"></a><span id="l16.235" class="difflineplus">+{</span>
<a href="#l16.236"></a><span id="l16.236" class="difflineplus">+    z_streamp strm = &amp;(state-&gt;strm);</span>
<a href="#l16.237"></a><span id="l16.237" class="difflineplus">+</span>
<a href="#l16.238"></a><span id="l16.238" class="difflineplus">+    do {</span>
<a href="#l16.239"></a><span id="l16.239" class="difflineplus">+        switch(state-&gt;how) {</span>
<a href="#l16.240"></a><span id="l16.240" class="difflineplus">+        case LOOK:      /* -&gt; LOOK, COPY (only if never GZIP), or GZIP */</span>
<a href="#l16.241"></a><span id="l16.241" class="difflineplus">+            if (gz_look(state) == -1)</span>
<a href="#l16.242"></a><span id="l16.242" class="difflineplus">+                return -1;</span>
<a href="#l16.243"></a><span id="l16.243" class="difflineplus">+            if (state-&gt;how == LOOK)</span>
<a href="#l16.244"></a><span id="l16.244" class="difflineplus">+                return 0;</span>
<a href="#l16.245"></a><span id="l16.245" class="difflineplus">+            break;</span>
<a href="#l16.246"></a><span id="l16.246" class="difflineplus">+        case COPY:      /* -&gt; COPY */</span>
<a href="#l16.247"></a><span id="l16.247" class="difflineplus">+            if (gz_load(state, state-&gt;out, state-&gt;size &lt;&lt; 1, &amp;(state-&gt;x.have))</span>
<a href="#l16.248"></a><span id="l16.248" class="difflineplus">+                    == -1)</span>
<a href="#l16.249"></a><span id="l16.249" class="difflineplus">+                return -1;</span>
<a href="#l16.250"></a><span id="l16.250" class="difflineplus">+            state-&gt;x.next = state-&gt;out;</span>
<a href="#l16.251"></a><span id="l16.251" class="difflineplus">+            return 0;</span>
<a href="#l16.252"></a><span id="l16.252" class="difflineplus">+        case GZIP:      /* -&gt; GZIP or LOOK (if end of gzip stream) */</span>
<a href="#l16.253"></a><span id="l16.253" class="difflineplus">+            strm-&gt;avail_out = state-&gt;size &lt;&lt; 1;</span>
<a href="#l16.254"></a><span id="l16.254" class="difflineplus">+            strm-&gt;next_out = state-&gt;out;</span>
<a href="#l16.255"></a><span id="l16.255" class="difflineplus">+            if (gz_decomp(state) == -1)</span>
<a href="#l16.256"></a><span id="l16.256" class="difflineplus">+                return -1;</span>
<a href="#l16.257"></a><span id="l16.257" class="difflineplus">+        }</span>
<a href="#l16.258"></a><span id="l16.258" class="difflineplus">+    } while (state-&gt;x.have == 0 &amp;&amp; (!state-&gt;eof || strm-&gt;avail_in));</span>
<a href="#l16.259"></a><span id="l16.259" class="difflineplus">+    return 0;</span>
<a href="#l16.260"></a><span id="l16.260" class="difflineplus">+}</span>
<a href="#l16.261"></a><span id="l16.261" class="difflineplus">+</span>
<a href="#l16.262"></a><span id="l16.262" class="difflineplus">+/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */</span>
<a href="#l16.263"></a><span id="l16.263" class="difflineplus">+local int gz_skip(state, len)</span>
<a href="#l16.264"></a><span id="l16.264" class="difflineplus">+    gz_statep state;</span>
<a href="#l16.265"></a><span id="l16.265" class="difflineplus">+    z_off64_t len;</span>
<a href="#l16.266"></a><span id="l16.266" class="difflineplus">+{</span>
<a href="#l16.267"></a><span id="l16.267" class="difflineplus">+    unsigned n;</span>
<a href="#l16.268"></a><span id="l16.268" class="difflineplus">+</span>
<a href="#l16.269"></a><span id="l16.269" class="difflineplus">+    /* skip over len bytes or reach end-of-file, whichever comes first */</span>
<a href="#l16.270"></a><span id="l16.270" class="difflineplus">+    while (len)</span>
<a href="#l16.271"></a><span id="l16.271" class="difflineplus">+        /* skip over whatever is in output buffer */</span>
<a href="#l16.272"></a><span id="l16.272" class="difflineplus">+        if (state-&gt;x.have) {</span>
<a href="#l16.273"></a><span id="l16.273" class="difflineplus">+            n = GT_OFF(state-&gt;x.have) || (z_off64_t)state-&gt;x.have &gt; len ?</span>
<a href="#l16.274"></a><span id="l16.274" class="difflineplus">+                (unsigned)len : state-&gt;x.have;</span>
<a href="#l16.275"></a><span id="l16.275" class="difflineplus">+            state-&gt;x.have -= n;</span>
<a href="#l16.276"></a><span id="l16.276" class="difflineplus">+            state-&gt;x.next += n;</span>
<a href="#l16.277"></a><span id="l16.277" class="difflineplus">+            state-&gt;x.pos += n;</span>
<a href="#l16.278"></a><span id="l16.278" class="difflineplus">+            len -= n;</span>
<a href="#l16.279"></a><span id="l16.279" class="difflineplus">+        }</span>
<a href="#l16.280"></a><span id="l16.280" class="difflineplus">+</span>
<a href="#l16.281"></a><span id="l16.281" class="difflineplus">+        /* output buffer empty -- return if we're at the end of the input */</span>
<a href="#l16.282"></a><span id="l16.282" class="difflineplus">+        else if (state-&gt;eof &amp;&amp; state-&gt;strm.avail_in == 0)</span>
<a href="#l16.283"></a><span id="l16.283" class="difflineplus">+            break;</span>
<a href="#l16.284"></a><span id="l16.284" class="difflineplus">+</span>
<a href="#l16.285"></a><span id="l16.285" class="difflineplus">+        /* need more data to skip -- load up output buffer */</span>
<a href="#l16.286"></a><span id="l16.286" class="difflineplus">+        else {</span>
<a href="#l16.287"></a><span id="l16.287" class="difflineplus">+            /* get more output, looking for header if required */</span>
<a href="#l16.288"></a><span id="l16.288" class="difflineplus">+            if (gz_fetch(state) == -1)</span>
<a href="#l16.289"></a><span id="l16.289" class="difflineplus">+                return -1;</span>
<a href="#l16.290"></a><span id="l16.290" class="difflineplus">+        }</span>
<a href="#l16.291"></a><span id="l16.291" class="difflineplus">+    return 0;</span>
<a href="#l16.292"></a><span id="l16.292" class="difflineplus">+}</span>
<a href="#l16.293"></a><span id="l16.293" class="difflineplus">+</span>
<a href="#l16.294"></a><span id="l16.294" class="difflineplus">+/* Read len bytes into buf from file, or less than len up to the end of the</span>
<a href="#l16.295"></a><span id="l16.295" class="difflineplus">+   input.  Return the number of bytes read.  If zero is returned, either the</span>
<a href="#l16.296"></a><span id="l16.296" class="difflineplus">+   end of file was reached, or there was an error.  state-&gt;err must be</span>
<a href="#l16.297"></a><span id="l16.297" class="difflineplus">+   consulted in that case to determine which. */</span>
<a href="#l16.298"></a><span id="l16.298" class="difflineplus">+local z_size_t gz_read(state, buf, len)</span>
<a href="#l16.299"></a><span id="l16.299" class="difflineplus">+    gz_statep state;</span>
<a href="#l16.300"></a><span id="l16.300" class="difflineplus">+    voidp buf;</span>
<a href="#l16.301"></a><span id="l16.301" class="difflineplus">+    z_size_t len;</span>
<a href="#l16.302"></a><span id="l16.302" class="difflineplus">+{</span>
<a href="#l16.303"></a><span id="l16.303" class="difflineplus">+    z_size_t got;</span>
<a href="#l16.304"></a><span id="l16.304" class="difflineplus">+    unsigned n;</span>
<a href="#l16.305"></a><span id="l16.305" class="difflineplus">+</span>
<a href="#l16.306"></a><span id="l16.306" class="difflineplus">+    /* if len is zero, avoid unnecessary operations */</span>
<a href="#l16.307"></a><span id="l16.307" class="difflineplus">+    if (len == 0)</span>
<a href="#l16.308"></a><span id="l16.308" class="difflineplus">+        return 0;</span>
<a href="#l16.309"></a><span id="l16.309" class="difflineplus">+</span>
<a href="#l16.310"></a><span id="l16.310" class="difflineplus">+    /* process a skip request */</span>
<a href="#l16.311"></a><span id="l16.311" class="difflineplus">+    if (state-&gt;seek) {</span>
<a href="#l16.312"></a><span id="l16.312" class="difflineplus">+        state-&gt;seek = 0;</span>
<a href="#l16.313"></a><span id="l16.313" class="difflineplus">+        if (gz_skip(state, state-&gt;skip) == -1)</span>
<a href="#l16.314"></a><span id="l16.314" class="difflineplus">+            return 0;</span>
<a href="#l16.315"></a><span id="l16.315" class="difflineplus">+    }</span>
<a href="#l16.316"></a><span id="l16.316" class="difflineplus">+</span>
<a href="#l16.317"></a><span id="l16.317" class="difflineplus">+    /* get len bytes to buf, or less than len if at the end */</span>
<a href="#l16.318"></a><span id="l16.318" class="difflineplus">+    got = 0;</span>
<a href="#l16.319"></a><span id="l16.319" class="difflineplus">+    do {</span>
<a href="#l16.320"></a><span id="l16.320" class="difflineplus">+        /* set n to the maximum amount of len that fits in an unsigned int */</span>
<a href="#l16.321"></a><span id="l16.321" class="difflineplus">+        n = -1;</span>
<a href="#l16.322"></a><span id="l16.322" class="difflineplus">+        if (n &gt; len)</span>
<a href="#l16.323"></a><span id="l16.323" class="difflineplus">+            n = len;</span>
<a href="#l16.324"></a><span id="l16.324" class="difflineplus">+</span>
<a href="#l16.325"></a><span id="l16.325" class="difflineplus">+        /* first just try copying data from the output buffer */</span>
<a href="#l16.326"></a><span id="l16.326" class="difflineplus">+        if (state-&gt;x.have) {</span>
<a href="#l16.327"></a><span id="l16.327" class="difflineplus">+            if (state-&gt;x.have &lt; n)</span>
<a href="#l16.328"></a><span id="l16.328" class="difflineplus">+                n = state-&gt;x.have;</span>
<a href="#l16.329"></a><span id="l16.329" class="difflineplus">+            memcpy(buf, state-&gt;x.next, n);</span>
<a href="#l16.330"></a><span id="l16.330" class="difflineplus">+            state-&gt;x.next += n;</span>
<a href="#l16.331"></a><span id="l16.331" class="difflineplus">+            state-&gt;x.have -= n;</span>
<a href="#l16.332"></a><span id="l16.332" class="difflineplus">+        }</span>
<a href="#l16.333"></a><span id="l16.333" class="difflineplus">+</span>
<a href="#l16.334"></a><span id="l16.334" class="difflineplus">+        /* output buffer empty -- return if we're at the end of the input */</span>
<a href="#l16.335"></a><span id="l16.335" class="difflineplus">+        else if (state-&gt;eof &amp;&amp; state-&gt;strm.avail_in == 0) {</span>
<a href="#l16.336"></a><span id="l16.336" class="difflineplus">+            state-&gt;past = 1;        /* tried to read past end */</span>
<a href="#l16.337"></a><span id="l16.337" class="difflineplus">+            break;</span>
<a href="#l16.338"></a><span id="l16.338" class="difflineplus">+        }</span>
<a href="#l16.339"></a><span id="l16.339" class="difflineplus">+</span>
<a href="#l16.340"></a><span id="l16.340" class="difflineplus">+        /* need output data -- for small len or new stream load up our output</span>
<a href="#l16.341"></a><span id="l16.341" class="difflineplus">+           buffer */</span>
<a href="#l16.342"></a><span id="l16.342" class="difflineplus">+        else if (state-&gt;how == LOOK || n &lt; (state-&gt;size &lt;&lt; 1)) {</span>
<a href="#l16.343"></a><span id="l16.343" class="difflineplus">+            /* get more output, looking for header if required */</span>
<a href="#l16.344"></a><span id="l16.344" class="difflineplus">+            if (gz_fetch(state) == -1)</span>
<a href="#l16.345"></a><span id="l16.345" class="difflineplus">+                return 0;</span>
<a href="#l16.346"></a><span id="l16.346" class="difflineplus">+            continue;       /* no progress yet -- go back to copy above */</span>
<a href="#l16.347"></a><span id="l16.347" class="difflineplus">+            /* the copy above assures that we will leave with space in the</span>
<a href="#l16.348"></a><span id="l16.348" class="difflineplus">+               output buffer, allowing at least one gzungetc() to succeed */</span>
<a href="#l16.349"></a><span id="l16.349" class="difflineplus">+        }</span>
<a href="#l16.350"></a><span id="l16.350" class="difflineplus">+</span>
<a href="#l16.351"></a><span id="l16.351" class="difflineplus">+        /* large len -- read directly into user buffer */</span>
<a href="#l16.352"></a><span id="l16.352" class="difflineplus">+        else if (state-&gt;how == COPY) {      /* read directly */</span>
<a href="#l16.353"></a><span id="l16.353" class="difflineplus">+            if (gz_load(state, (unsigned char *)buf, n, &amp;n) == -1)</span>
<a href="#l16.354"></a><span id="l16.354" class="difflineplus">+                return 0;</span>
<a href="#l16.355"></a><span id="l16.355" class="difflineplus">+        }</span>
<a href="#l16.356"></a><span id="l16.356" class="difflineplus">+</span>
<a href="#l16.357"></a><span id="l16.357" class="difflineplus">+        /* large len -- decompress directly into user buffer */</span>
<a href="#l16.358"></a><span id="l16.358" class="difflineplus">+        else {  /* state-&gt;how == GZIP */</span>
<a href="#l16.359"></a><span id="l16.359" class="difflineplus">+            state-&gt;strm.avail_out = n;</span>
<a href="#l16.360"></a><span id="l16.360" class="difflineplus">+            state-&gt;strm.next_out = (unsigned char *)buf;</span>
<a href="#l16.361"></a><span id="l16.361" class="difflineplus">+            if (gz_decomp(state) == -1)</span>
<a href="#l16.362"></a><span id="l16.362" class="difflineplus">+                return 0;</span>
<a href="#l16.363"></a><span id="l16.363" class="difflineplus">+            n = state-&gt;x.have;</span>
<a href="#l16.364"></a><span id="l16.364" class="difflineplus">+            state-&gt;x.have = 0;</span>
<a href="#l16.365"></a><span id="l16.365" class="difflineplus">+        }</span>
<a href="#l16.366"></a><span id="l16.366" class="difflineplus">+</span>
<a href="#l16.367"></a><span id="l16.367" class="difflineplus">+        /* update progress */</span>
<a href="#l16.368"></a><span id="l16.368" class="difflineplus">+        len -= n;</span>
<a href="#l16.369"></a><span id="l16.369" class="difflineplus">+        buf = (char *)buf + n;</span>
<a href="#l16.370"></a><span id="l16.370" class="difflineplus">+        got += n;</span>
<a href="#l16.371"></a><span id="l16.371" class="difflineplus">+        state-&gt;x.pos += n;</span>
<a href="#l16.372"></a><span id="l16.372" class="difflineplus">+    } while (len);</span>
<a href="#l16.373"></a><span id="l16.373" class="difflineplus">+</span>
<a href="#l16.374"></a><span id="l16.374" class="difflineplus">+    /* return number of bytes read into user buffer */</span>
<a href="#l16.375"></a><span id="l16.375" class="difflineplus">+    return got;</span>
<a href="#l16.376"></a><span id="l16.376" class="difflineplus">+}</span>
<a href="#l16.377"></a><span id="l16.377" class="difflineplus">+</span>
<a href="#l16.378"></a><span id="l16.378" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l16.379"></a><span id="l16.379" class="difflineplus">+int ZEXPORT gzread(file, buf, len)</span>
<a href="#l16.380"></a><span id="l16.380" class="difflineplus">+    gzFile file;</span>
<a href="#l16.381"></a><span id="l16.381" class="difflineplus">+    voidp buf;</span>
<a href="#l16.382"></a><span id="l16.382" class="difflineplus">+    unsigned len;</span>
<a href="#l16.383"></a><span id="l16.383" class="difflineplus">+{</span>
<a href="#l16.384"></a><span id="l16.384" class="difflineplus">+    gz_statep state;</span>
<a href="#l16.385"></a><span id="l16.385" class="difflineplus">+</span>
<a href="#l16.386"></a><span id="l16.386" class="difflineplus">+    /* get internal structure */</span>
<a href="#l16.387"></a><span id="l16.387" class="difflineplus">+    if (file == NULL)</span>
<a href="#l16.388"></a><span id="l16.388" class="difflineplus">+        return -1;</span>
<a href="#l16.389"></a><span id="l16.389" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l16.390"></a><span id="l16.390" class="difflineplus">+</span>
<a href="#l16.391"></a><span id="l16.391" class="difflineplus">+    /* check that we're reading and that there's no (serious) error */</span>
<a href="#l16.392"></a><span id="l16.392" class="difflineplus">+    if (state-&gt;mode != GZ_READ ||</span>
<a href="#l16.393"></a><span id="l16.393" class="difflineplus">+            (state-&gt;err != Z_OK &amp;&amp; state-&gt;err != Z_BUF_ERROR))</span>
<a href="#l16.394"></a><span id="l16.394" class="difflineplus">+        return -1;</span>
<a href="#l16.395"></a><span id="l16.395" class="difflineplus">+</span>
<a href="#l16.396"></a><span id="l16.396" class="difflineplus">+    /* since an int is returned, make sure len fits in one, otherwise return</span>
<a href="#l16.397"></a><span id="l16.397" class="difflineplus">+       with an error (this avoids a flaw in the interface) */</span>
<a href="#l16.398"></a><span id="l16.398" class="difflineplus">+    if ((int)len &lt; 0) {</span>
<a href="#l16.399"></a><span id="l16.399" class="difflineplus">+        gz_error(state, Z_STREAM_ERROR, &quot;request does not fit in an int&quot;);</span>
<a href="#l16.400"></a><span id="l16.400" class="difflineplus">+        return -1;</span>
<a href="#l16.401"></a><span id="l16.401" class="difflineplus">+    }</span>
<a href="#l16.402"></a><span id="l16.402" class="difflineplus">+</span>
<a href="#l16.403"></a><span id="l16.403" class="difflineplus">+    /* read len or fewer bytes to buf */</span>
<a href="#l16.404"></a><span id="l16.404" class="difflineplus">+    len = gz_read(state, buf, len);</span>
<a href="#l16.405"></a><span id="l16.405" class="difflineplus">+</span>
<a href="#l16.406"></a><span id="l16.406" class="difflineplus">+    /* check for an error */</span>
<a href="#l16.407"></a><span id="l16.407" class="difflineplus">+    if (len == 0 &amp;&amp; state-&gt;err != Z_OK &amp;&amp; state-&gt;err != Z_BUF_ERROR)</span>
<a href="#l16.408"></a><span id="l16.408" class="difflineplus">+        return -1;</span>
<a href="#l16.409"></a><span id="l16.409" class="difflineplus">+</span>
<a href="#l16.410"></a><span id="l16.410" class="difflineplus">+    /* return the number of bytes read (this is assured to fit in an int) */</span>
<a href="#l16.411"></a><span id="l16.411" class="difflineplus">+    return (int)len;</span>
<a href="#l16.412"></a><span id="l16.412" class="difflineplus">+}</span>
<a href="#l16.413"></a><span id="l16.413" class="difflineplus">+</span>
<a href="#l16.414"></a><span id="l16.414" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l16.415"></a><span id="l16.415" class="difflineplus">+z_size_t ZEXPORT gzfread(buf, size, nitems, file)</span>
<a href="#l16.416"></a><span id="l16.416" class="difflineplus">+    voidp buf;</span>
<a href="#l16.417"></a><span id="l16.417" class="difflineplus">+    z_size_t size;</span>
<a href="#l16.418"></a><span id="l16.418" class="difflineplus">+    z_size_t nitems;</span>
<a href="#l16.419"></a><span id="l16.419" class="difflineplus">+    gzFile file;</span>
<a href="#l16.420"></a><span id="l16.420" class="difflineplus">+{</span>
<a href="#l16.421"></a><span id="l16.421" class="difflineplus">+    z_size_t len;</span>
<a href="#l16.422"></a><span id="l16.422" class="difflineplus">+    gz_statep state;</span>
<a href="#l16.423"></a><span id="l16.423" class="difflineplus">+</span>
<a href="#l16.424"></a><span id="l16.424" class="difflineplus">+    /* get internal structure */</span>
<a href="#l16.425"></a><span id="l16.425" class="difflineplus">+    if (file == NULL)</span>
<a href="#l16.426"></a><span id="l16.426" class="difflineplus">+        return 0;</span>
<a href="#l16.427"></a><span id="l16.427" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l16.428"></a><span id="l16.428" class="difflineplus">+</span>
<a href="#l16.429"></a><span id="l16.429" class="difflineplus">+    /* check that we're reading and that there's no (serious) error */</span>
<a href="#l16.430"></a><span id="l16.430" class="difflineplus">+    if (state-&gt;mode != GZ_READ ||</span>
<a href="#l16.431"></a><span id="l16.431" class="difflineplus">+            (state-&gt;err != Z_OK &amp;&amp; state-&gt;err != Z_BUF_ERROR))</span>
<a href="#l16.432"></a><span id="l16.432" class="difflineplus">+        return 0;</span>
<a href="#l16.433"></a><span id="l16.433" class="difflineplus">+</span>
<a href="#l16.434"></a><span id="l16.434" class="difflineplus">+    /* compute bytes to read -- error on overflow */</span>
<a href="#l16.435"></a><span id="l16.435" class="difflineplus">+    len = nitems * size;</span>
<a href="#l16.436"></a><span id="l16.436" class="difflineplus">+    if (size &amp;&amp; len / size != nitems) {</span>
<a href="#l16.437"></a><span id="l16.437" class="difflineplus">+        gz_error(state, Z_STREAM_ERROR, &quot;request does not fit in a size_t&quot;);</span>
<a href="#l16.438"></a><span id="l16.438" class="difflineplus">+        return 0;</span>
<a href="#l16.439"></a><span id="l16.439" class="difflineplus">+    }</span>
<a href="#l16.440"></a><span id="l16.440" class="difflineplus">+</span>
<a href="#l16.441"></a><span id="l16.441" class="difflineplus">+    /* read len or fewer bytes to buf, return the number of full items read */</span>
<a href="#l16.442"></a><span id="l16.442" class="difflineplus">+    return len ? gz_read(state, buf, len) / size : 0;</span>
<a href="#l16.443"></a><span id="l16.443" class="difflineplus">+}</span>
<a href="#l16.444"></a><span id="l16.444" class="difflineplus">+</span>
<a href="#l16.445"></a><span id="l16.445" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l16.446"></a><span id="l16.446" class="difflineplus">+#ifdef Z_PREFIX_SET</span>
<a href="#l16.447"></a><span id="l16.447" class="difflineplus">+#  undef z_gzgetc</span>
<a href="#l16.448"></a><span id="l16.448" class="difflineplus">+#else</span>
<a href="#l16.449"></a><span id="l16.449" class="difflineplus">+#  undef gzgetc</span>
<a href="#l16.450"></a><span id="l16.450" class="difflineplus">+#endif</span>
<a href="#l16.451"></a><span id="l16.451" class="difflineplus">+int ZEXPORT gzgetc(file)</span>
<a href="#l16.452"></a><span id="l16.452" class="difflineplus">+    gzFile file;</span>
<a href="#l16.453"></a><span id="l16.453" class="difflineplus">+{</span>
<a href="#l16.454"></a><span id="l16.454" class="difflineplus">+    int ret;</span>
<a href="#l16.455"></a><span id="l16.455" class="difflineplus">+    unsigned char buf[1];</span>
<a href="#l16.456"></a><span id="l16.456" class="difflineplus">+    gz_statep state;</span>
<a href="#l16.457"></a><span id="l16.457" class="difflineplus">+</span>
<a href="#l16.458"></a><span id="l16.458" class="difflineplus">+    /* get internal structure */</span>
<a href="#l16.459"></a><span id="l16.459" class="difflineplus">+    if (file == NULL)</span>
<a href="#l16.460"></a><span id="l16.460" class="difflineplus">+        return -1;</span>
<a href="#l16.461"></a><span id="l16.461" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l16.462"></a><span id="l16.462" class="difflineplus">+</span>
<a href="#l16.463"></a><span id="l16.463" class="difflineplus">+    /* check that we're reading and that there's no (serious) error */</span>
<a href="#l16.464"></a><span id="l16.464" class="difflineplus">+    if (state-&gt;mode != GZ_READ ||</span>
<a href="#l16.465"></a><span id="l16.465" class="difflineplus">+        (state-&gt;err != Z_OK &amp;&amp; state-&gt;err != Z_BUF_ERROR))</span>
<a href="#l16.466"></a><span id="l16.466" class="difflineplus">+        return -1;</span>
<a href="#l16.467"></a><span id="l16.467" class="difflineplus">+</span>
<a href="#l16.468"></a><span id="l16.468" class="difflineplus">+    /* try output buffer (no need to check for skip request) */</span>
<a href="#l16.469"></a><span id="l16.469" class="difflineplus">+    if (state-&gt;x.have) {</span>
<a href="#l16.470"></a><span id="l16.470" class="difflineplus">+        state-&gt;x.have--;</span>
<a href="#l16.471"></a><span id="l16.471" class="difflineplus">+        state-&gt;x.pos++;</span>
<a href="#l16.472"></a><span id="l16.472" class="difflineplus">+        return *(state-&gt;x.next)++;</span>
<a href="#l16.473"></a><span id="l16.473" class="difflineplus">+    }</span>
<a href="#l16.474"></a><span id="l16.474" class="difflineplus">+</span>
<a href="#l16.475"></a><span id="l16.475" class="difflineplus">+    /* nothing there -- try gz_read() */</span>
<a href="#l16.476"></a><span id="l16.476" class="difflineplus">+    ret = gz_read(state, buf, 1);</span>
<a href="#l16.477"></a><span id="l16.477" class="difflineplus">+    return ret &lt; 1 ? -1 : buf[0];</span>
<a href="#l16.478"></a><span id="l16.478" class="difflineplus">+}</span>
<a href="#l16.479"></a><span id="l16.479" class="difflineplus">+</span>
<a href="#l16.480"></a><span id="l16.480" class="difflineplus">+int ZEXPORT gzgetc_(file)</span>
<a href="#l16.481"></a><span id="l16.481" class="difflineplus">+gzFile file;</span>
<a href="#l16.482"></a><span id="l16.482" class="difflineplus">+{</span>
<a href="#l16.483"></a><span id="l16.483" class="difflineplus">+    return gzgetc(file);</span>
<a href="#l16.484"></a><span id="l16.484" class="difflineplus">+}</span>
<a href="#l16.485"></a><span id="l16.485" class="difflineplus">+</span>
<a href="#l16.486"></a><span id="l16.486" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l16.487"></a><span id="l16.487" class="difflineplus">+int ZEXPORT gzungetc(c, file)</span>
<a href="#l16.488"></a><span id="l16.488" class="difflineplus">+    int c;</span>
<a href="#l16.489"></a><span id="l16.489" class="difflineplus">+    gzFile file;</span>
<a href="#l16.490"></a><span id="l16.490" class="difflineplus">+{</span>
<a href="#l16.491"></a><span id="l16.491" class="difflineplus">+    gz_statep state;</span>
<a href="#l16.492"></a><span id="l16.492" class="difflineplus">+</span>
<a href="#l16.493"></a><span id="l16.493" class="difflineplus">+    /* get internal structure */</span>
<a href="#l16.494"></a><span id="l16.494" class="difflineplus">+    if (file == NULL)</span>
<a href="#l16.495"></a><span id="l16.495" class="difflineplus">+        return -1;</span>
<a href="#l16.496"></a><span id="l16.496" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l16.497"></a><span id="l16.497" class="difflineplus">+</span>
<a href="#l16.498"></a><span id="l16.498" class="difflineplus">+    /* check that we're reading and that there's no (serious) error */</span>
<a href="#l16.499"></a><span id="l16.499" class="difflineplus">+    if (state-&gt;mode != GZ_READ ||</span>
<a href="#l16.500"></a><span id="l16.500" class="difflineplus">+        (state-&gt;err != Z_OK &amp;&amp; state-&gt;err != Z_BUF_ERROR))</span>
<a href="#l16.501"></a><span id="l16.501" class="difflineplus">+        return -1;</span>
<a href="#l16.502"></a><span id="l16.502" class="difflineplus">+</span>
<a href="#l16.503"></a><span id="l16.503" class="difflineplus">+    /* process a skip request */</span>
<a href="#l16.504"></a><span id="l16.504" class="difflineplus">+    if (state-&gt;seek) {</span>
<a href="#l16.505"></a><span id="l16.505" class="difflineplus">+        state-&gt;seek = 0;</span>
<a href="#l16.506"></a><span id="l16.506" class="difflineplus">+        if (gz_skip(state, state-&gt;skip) == -1)</span>
<a href="#l16.507"></a><span id="l16.507" class="difflineplus">+            return -1;</span>
<a href="#l16.508"></a><span id="l16.508" class="difflineplus">+    }</span>
<a href="#l16.509"></a><span id="l16.509" class="difflineplus">+</span>
<a href="#l16.510"></a><span id="l16.510" class="difflineplus">+    /* can't push EOF */</span>
<a href="#l16.511"></a><span id="l16.511" class="difflineplus">+    if (c &lt; 0)</span>
<a href="#l16.512"></a><span id="l16.512" class="difflineplus">+        return -1;</span>
<a href="#l16.513"></a><span id="l16.513" class="difflineplus">+</span>
<a href="#l16.514"></a><span id="l16.514" class="difflineplus">+    /* if output buffer empty, put byte at end (allows more pushing) */</span>
<a href="#l16.515"></a><span id="l16.515" class="difflineplus">+    if (state-&gt;x.have == 0) {</span>
<a href="#l16.516"></a><span id="l16.516" class="difflineplus">+        state-&gt;x.have = 1;</span>
<a href="#l16.517"></a><span id="l16.517" class="difflineplus">+        state-&gt;x.next = state-&gt;out + (state-&gt;size &lt;&lt; 1) - 1;</span>
<a href="#l16.518"></a><span id="l16.518" class="difflineplus">+        state-&gt;x.next[0] = (unsigned char)c;</span>
<a href="#l16.519"></a><span id="l16.519" class="difflineplus">+        state-&gt;x.pos--;</span>
<a href="#l16.520"></a><span id="l16.520" class="difflineplus">+        state-&gt;past = 0;</span>
<a href="#l16.521"></a><span id="l16.521" class="difflineplus">+        return c;</span>
<a href="#l16.522"></a><span id="l16.522" class="difflineplus">+    }</span>
<a href="#l16.523"></a><span id="l16.523" class="difflineplus">+</span>
<a href="#l16.524"></a><span id="l16.524" class="difflineplus">+    /* if no room, give up (must have already done a gzungetc()) */</span>
<a href="#l16.525"></a><span id="l16.525" class="difflineplus">+    if (state-&gt;x.have == (state-&gt;size &lt;&lt; 1)) {</span>
<a href="#l16.526"></a><span id="l16.526" class="difflineplus">+        gz_error(state, Z_DATA_ERROR, &quot;out of room to push characters&quot;);</span>
<a href="#l16.527"></a><span id="l16.527" class="difflineplus">+        return -1;</span>
<a href="#l16.528"></a><span id="l16.528" class="difflineplus">+    }</span>
<a href="#l16.529"></a><span id="l16.529" class="difflineplus">+</span>
<a href="#l16.530"></a><span id="l16.530" class="difflineplus">+    /* slide output data if needed and insert byte before existing data */</span>
<a href="#l16.531"></a><span id="l16.531" class="difflineplus">+    if (state-&gt;x.next == state-&gt;out) {</span>
<a href="#l16.532"></a><span id="l16.532" class="difflineplus">+        unsigned char *src = state-&gt;out + state-&gt;x.have;</span>
<a href="#l16.533"></a><span id="l16.533" class="difflineplus">+        unsigned char *dest = state-&gt;out + (state-&gt;size &lt;&lt; 1);</span>
<a href="#l16.534"></a><span id="l16.534" class="difflineplus">+        while (src &gt; state-&gt;out)</span>
<a href="#l16.535"></a><span id="l16.535" class="difflineplus">+            *--dest = *--src;</span>
<a href="#l16.536"></a><span id="l16.536" class="difflineplus">+        state-&gt;x.next = dest;</span>
<a href="#l16.537"></a><span id="l16.537" class="difflineplus">+    }</span>
<a href="#l16.538"></a><span id="l16.538" class="difflineplus">+    state-&gt;x.have++;</span>
<a href="#l16.539"></a><span id="l16.539" class="difflineplus">+    state-&gt;x.next--;</span>
<a href="#l16.540"></a><span id="l16.540" class="difflineplus">+    state-&gt;x.next[0] = (unsigned char)c;</span>
<a href="#l16.541"></a><span id="l16.541" class="difflineplus">+    state-&gt;x.pos--;</span>
<a href="#l16.542"></a><span id="l16.542" class="difflineplus">+    state-&gt;past = 0;</span>
<a href="#l16.543"></a><span id="l16.543" class="difflineplus">+    return c;</span>
<a href="#l16.544"></a><span id="l16.544" class="difflineplus">+}</span>
<a href="#l16.545"></a><span id="l16.545" class="difflineplus">+</span>
<a href="#l16.546"></a><span id="l16.546" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l16.547"></a><span id="l16.547" class="difflineplus">+char * ZEXPORT gzgets(file, buf, len)</span>
<a href="#l16.548"></a><span id="l16.548" class="difflineplus">+    gzFile file;</span>
<a href="#l16.549"></a><span id="l16.549" class="difflineplus">+    char *buf;</span>
<a href="#l16.550"></a><span id="l16.550" class="difflineplus">+    int len;</span>
<a href="#l16.551"></a><span id="l16.551" class="difflineplus">+{</span>
<a href="#l16.552"></a><span id="l16.552" class="difflineplus">+    unsigned left, n;</span>
<a href="#l16.553"></a><span id="l16.553" class="difflineplus">+    char *str;</span>
<a href="#l16.554"></a><span id="l16.554" class="difflineplus">+    unsigned char *eol;</span>
<a href="#l16.555"></a><span id="l16.555" class="difflineplus">+    gz_statep state;</span>
<a href="#l16.556"></a><span id="l16.556" class="difflineplus">+</span>
<a href="#l16.557"></a><span id="l16.557" class="difflineplus">+    /* check parameters and get internal structure */</span>
<a href="#l16.558"></a><span id="l16.558" class="difflineplus">+    if (file == NULL || buf == NULL || len &lt; 1)</span>
<a href="#l16.559"></a><span id="l16.559" class="difflineplus">+        return NULL;</span>
<a href="#l16.560"></a><span id="l16.560" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l16.561"></a><span id="l16.561" class="difflineplus">+</span>
<a href="#l16.562"></a><span id="l16.562" class="difflineplus">+    /* check that we're reading and that there's no (serious) error */</span>
<a href="#l16.563"></a><span id="l16.563" class="difflineplus">+    if (state-&gt;mode != GZ_READ ||</span>
<a href="#l16.564"></a><span id="l16.564" class="difflineplus">+        (state-&gt;err != Z_OK &amp;&amp; state-&gt;err != Z_BUF_ERROR))</span>
<a href="#l16.565"></a><span id="l16.565" class="difflineplus">+        return NULL;</span>
<a href="#l16.566"></a><span id="l16.566" class="difflineplus">+</span>
<a href="#l16.567"></a><span id="l16.567" class="difflineplus">+    /* process a skip request */</span>
<a href="#l16.568"></a><span id="l16.568" class="difflineplus">+    if (state-&gt;seek) {</span>
<a href="#l16.569"></a><span id="l16.569" class="difflineplus">+        state-&gt;seek = 0;</span>
<a href="#l16.570"></a><span id="l16.570" class="difflineplus">+        if (gz_skip(state, state-&gt;skip) == -1)</span>
<a href="#l16.571"></a><span id="l16.571" class="difflineplus">+            return NULL;</span>
<a href="#l16.572"></a><span id="l16.572" class="difflineplus">+    }</span>
<a href="#l16.573"></a><span id="l16.573" class="difflineplus">+</span>
<a href="#l16.574"></a><span id="l16.574" class="difflineplus">+    /* copy output bytes up to new line or len - 1, whichever comes first --</span>
<a href="#l16.575"></a><span id="l16.575" class="difflineplus">+       append a terminating zero to the string (we don't check for a zero in</span>
<a href="#l16.576"></a><span id="l16.576" class="difflineplus">+       the contents, let the user worry about that) */</span>
<a href="#l16.577"></a><span id="l16.577" class="difflineplus">+    str = buf;</span>
<a href="#l16.578"></a><span id="l16.578" class="difflineplus">+    left = (unsigned)len - 1;</span>
<a href="#l16.579"></a><span id="l16.579" class="difflineplus">+    if (left) do {</span>
<a href="#l16.580"></a><span id="l16.580" class="difflineplus">+        /* assure that something is in the output buffer */</span>
<a href="#l16.581"></a><span id="l16.581" class="difflineplus">+        if (state-&gt;x.have == 0 &amp;&amp; gz_fetch(state) == -1)</span>
<a href="#l16.582"></a><span id="l16.582" class="difflineplus">+            return NULL;                /* error */</span>
<a href="#l16.583"></a><span id="l16.583" class="difflineplus">+        if (state-&gt;x.have == 0) {       /* end of file */</span>
<a href="#l16.584"></a><span id="l16.584" class="difflineplus">+            state-&gt;past = 1;            /* read past end */</span>
<a href="#l16.585"></a><span id="l16.585" class="difflineplus">+            break;                      /* return what we have */</span>
<a href="#l16.586"></a><span id="l16.586" class="difflineplus">+        }</span>
<a href="#l16.587"></a><span id="l16.587" class="difflineplus">+</span>
<a href="#l16.588"></a><span id="l16.588" class="difflineplus">+        /* look for end-of-line in current output buffer */</span>
<a href="#l16.589"></a><span id="l16.589" class="difflineplus">+        n = state-&gt;x.have &gt; left ? left : state-&gt;x.have;</span>
<a href="#l16.590"></a><span id="l16.590" class="difflineplus">+        eol = (unsigned char *)memchr(state-&gt;x.next, '\n', n);</span>
<a href="#l16.591"></a><span id="l16.591" class="difflineplus">+        if (eol != NULL)</span>
<a href="#l16.592"></a><span id="l16.592" class="difflineplus">+            n = (unsigned)(eol - state-&gt;x.next) + 1;</span>
<a href="#l16.593"></a><span id="l16.593" class="difflineplus">+</span>
<a href="#l16.594"></a><span id="l16.594" class="difflineplus">+        /* copy through end-of-line, or remainder if not found */</span>
<a href="#l16.595"></a><span id="l16.595" class="difflineplus">+        memcpy(buf, state-&gt;x.next, n);</span>
<a href="#l16.596"></a><span id="l16.596" class="difflineplus">+        state-&gt;x.have -= n;</span>
<a href="#l16.597"></a><span id="l16.597" class="difflineplus">+        state-&gt;x.next += n;</span>
<a href="#l16.598"></a><span id="l16.598" class="difflineplus">+        state-&gt;x.pos += n;</span>
<a href="#l16.599"></a><span id="l16.599" class="difflineplus">+        left -= n;</span>
<a href="#l16.600"></a><span id="l16.600" class="difflineplus">+        buf += n;</span>
<a href="#l16.601"></a><span id="l16.601" class="difflineplus">+    } while (left &amp;&amp; eol == NULL);</span>
<a href="#l16.602"></a><span id="l16.602" class="difflineplus">+</span>
<a href="#l16.603"></a><span id="l16.603" class="difflineplus">+    /* return terminated string, or if nothing, end of file */</span>
<a href="#l16.604"></a><span id="l16.604" class="difflineplus">+    if (buf == str)</span>
<a href="#l16.605"></a><span id="l16.605" class="difflineplus">+        return NULL;</span>
<a href="#l16.606"></a><span id="l16.606" class="difflineplus">+    buf[0] = 0;</span>
<a href="#l16.607"></a><span id="l16.607" class="difflineplus">+    return str;</span>
<a href="#l16.608"></a><span id="l16.608" class="difflineplus">+}</span>
<a href="#l16.609"></a><span id="l16.609" class="difflineplus">+</span>
<a href="#l16.610"></a><span id="l16.610" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l16.611"></a><span id="l16.611" class="difflineplus">+int ZEXPORT gzdirect(file)</span>
<a href="#l16.612"></a><span id="l16.612" class="difflineplus">+    gzFile file;</span>
<a href="#l16.613"></a><span id="l16.613" class="difflineplus">+{</span>
<a href="#l16.614"></a><span id="l16.614" class="difflineplus">+    gz_statep state;</span>
<a href="#l16.615"></a><span id="l16.615" class="difflineplus">+</span>
<a href="#l16.616"></a><span id="l16.616" class="difflineplus">+    /* get internal structure */</span>
<a href="#l16.617"></a><span id="l16.617" class="difflineplus">+    if (file == NULL)</span>
<a href="#l16.618"></a><span id="l16.618" class="difflineplus">+        return 0;</span>
<a href="#l16.619"></a><span id="l16.619" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l16.620"></a><span id="l16.620" class="difflineplus">+</span>
<a href="#l16.621"></a><span id="l16.621" class="difflineplus">+    /* if the state is not known, but we can find out, then do so (this is</span>
<a href="#l16.622"></a><span id="l16.622" class="difflineplus">+       mainly for right after a gzopen() or gzdopen()) */</span>
<a href="#l16.623"></a><span id="l16.623" class="difflineplus">+    if (state-&gt;mode == GZ_READ &amp;&amp; state-&gt;how == LOOK &amp;&amp; state-&gt;x.have == 0)</span>
<a href="#l16.624"></a><span id="l16.624" class="difflineplus">+        (void)gz_look(state);</span>
<a href="#l16.625"></a><span id="l16.625" class="difflineplus">+</span>
<a href="#l16.626"></a><span id="l16.626" class="difflineplus">+    /* return 1 if transparent, 0 if processing a gzip stream */</span>
<a href="#l16.627"></a><span id="l16.627" class="difflineplus">+    return state-&gt;direct;</span>
<a href="#l16.628"></a><span id="l16.628" class="difflineplus">+}</span>
<a href="#l16.629"></a><span id="l16.629" class="difflineplus">+</span>
<a href="#l16.630"></a><span id="l16.630" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l16.631"></a><span id="l16.631" class="difflineplus">+int ZEXPORT gzclose_r(file)</span>
<a href="#l16.632"></a><span id="l16.632" class="difflineplus">+    gzFile file;</span>
<a href="#l16.633"></a><span id="l16.633" class="difflineplus">+{</span>
<a href="#l16.634"></a><span id="l16.634" class="difflineplus">+    int ret, err;</span>
<a href="#l16.635"></a><span id="l16.635" class="difflineplus">+    gz_statep state;</span>
<a href="#l16.636"></a><span id="l16.636" class="difflineplus">+</span>
<a href="#l16.637"></a><span id="l16.637" class="difflineplus">+    /* get internal structure */</span>
<a href="#l16.638"></a><span id="l16.638" class="difflineplus">+    if (file == NULL)</span>
<a href="#l16.639"></a><span id="l16.639" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l16.640"></a><span id="l16.640" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l16.641"></a><span id="l16.641" class="difflineplus">+</span>
<a href="#l16.642"></a><span id="l16.642" class="difflineplus">+    /* check that we're reading */</span>
<a href="#l16.643"></a><span id="l16.643" class="difflineplus">+    if (state-&gt;mode != GZ_READ)</span>
<a href="#l16.644"></a><span id="l16.644" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l16.645"></a><span id="l16.645" class="difflineplus">+</span>
<a href="#l16.646"></a><span id="l16.646" class="difflineplus">+    /* free memory and close file */</span>
<a href="#l16.647"></a><span id="l16.647" class="difflineplus">+    if (state-&gt;size) {</span>
<a href="#l16.648"></a><span id="l16.648" class="difflineplus">+        inflateEnd(&amp;(state-&gt;strm));</span>
<a href="#l16.649"></a><span id="l16.649" class="difflineplus">+        free(state-&gt;out);</span>
<a href="#l16.650"></a><span id="l16.650" class="difflineplus">+        free(state-&gt;in);</span>
<a href="#l16.651"></a><span id="l16.651" class="difflineplus">+    }</span>
<a href="#l16.652"></a><span id="l16.652" class="difflineplus">+    err = state-&gt;err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;</span>
<a href="#l16.653"></a><span id="l16.653" class="difflineplus">+    gz_error(state, Z_OK, NULL);</span>
<a href="#l16.654"></a><span id="l16.654" class="difflineplus">+    free(state-&gt;path);</span>
<a href="#l16.655"></a><span id="l16.655" class="difflineplus">+    ret = close(state-&gt;fd);</span>
<a href="#l16.656"></a><span id="l16.656" class="difflineplus">+    free(state);</span>
<a href="#l16.657"></a><span id="l16.657" class="difflineplus">+    return ret ? Z_ERRNO : err;</span>
<a href="#l16.658"></a><span id="l16.658" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1">new file mode 100644</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineminus">--- /dev/null</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineplus">+++ b/third_party/zlib/gzwrite.c</span>
<a href="#l17.4"></a><span id="l17.4" class="difflineat">@@ -0,0 +1,665 @@</span>
<a href="#l17.5"></a><span id="l17.5" class="difflineplus">+/* gzwrite.c -- zlib functions for writing gzip files</span>
<a href="#l17.6"></a><span id="l17.6" class="difflineplus">+ * Copyright (C) 2004-2017 Mark Adler</span>
<a href="#l17.7"></a><span id="l17.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l17.8"></a><span id="l17.8" class="difflineplus">+ */</span>
<a href="#l17.9"></a><span id="l17.9" class="difflineplus">+</span>
<a href="#l17.10"></a><span id="l17.10" class="difflineplus">+#include &quot;gzguts.h&quot;</span>
<a href="#l17.11"></a><span id="l17.11" class="difflineplus">+</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineplus">+/* Local functions */</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+local int gz_init OF((gz_statep));</span>
<a href="#l17.14"></a><span id="l17.14" class="difflineplus">+local int gz_comp OF((gz_statep, int));</span>
<a href="#l17.15"></a><span id="l17.15" class="difflineplus">+local int gz_zero OF((gz_statep, z_off64_t));</span>
<a href="#l17.16"></a><span id="l17.16" class="difflineplus">+local z_size_t gz_write OF((gz_statep, voidpc, z_size_t));</span>
<a href="#l17.17"></a><span id="l17.17" class="difflineplus">+</span>
<a href="#l17.18"></a><span id="l17.18" class="difflineplus">+/* Initialize state for writing a gzip file.  Mark initialization by setting</span>
<a href="#l17.19"></a><span id="l17.19" class="difflineplus">+   state-&gt;size to non-zero.  Return -1 on a memory allocation failure, or 0 on</span>
<a href="#l17.20"></a><span id="l17.20" class="difflineplus">+   success. */</span>
<a href="#l17.21"></a><span id="l17.21" class="difflineplus">+local int gz_init(state)</span>
<a href="#l17.22"></a><span id="l17.22" class="difflineplus">+    gz_statep state;</span>
<a href="#l17.23"></a><span id="l17.23" class="difflineplus">+{</span>
<a href="#l17.24"></a><span id="l17.24" class="difflineplus">+    int ret;</span>
<a href="#l17.25"></a><span id="l17.25" class="difflineplus">+    z_streamp strm = &amp;(state-&gt;strm);</span>
<a href="#l17.26"></a><span id="l17.26" class="difflineplus">+</span>
<a href="#l17.27"></a><span id="l17.27" class="difflineplus">+    /* allocate input buffer (double size for gzprintf) */</span>
<a href="#l17.28"></a><span id="l17.28" class="difflineplus">+    state-&gt;in = (unsigned char *)malloc(state-&gt;want &lt;&lt; 1);</span>
<a href="#l17.29"></a><span id="l17.29" class="difflineplus">+    if (state-&gt;in == NULL) {</span>
<a href="#l17.30"></a><span id="l17.30" class="difflineplus">+        gz_error(state, Z_MEM_ERROR, &quot;out of memory&quot;);</span>
<a href="#l17.31"></a><span id="l17.31" class="difflineplus">+        return -1;</span>
<a href="#l17.32"></a><span id="l17.32" class="difflineplus">+    }</span>
<a href="#l17.33"></a><span id="l17.33" class="difflineplus">+</span>
<a href="#l17.34"></a><span id="l17.34" class="difflineplus">+    /* only need output buffer and deflate state if compressing */</span>
<a href="#l17.35"></a><span id="l17.35" class="difflineplus">+    if (!state-&gt;direct) {</span>
<a href="#l17.36"></a><span id="l17.36" class="difflineplus">+        /* allocate output buffer */</span>
<a href="#l17.37"></a><span id="l17.37" class="difflineplus">+        state-&gt;out = (unsigned char *)malloc(state-&gt;want);</span>
<a href="#l17.38"></a><span id="l17.38" class="difflineplus">+        if (state-&gt;out == NULL) {</span>
<a href="#l17.39"></a><span id="l17.39" class="difflineplus">+            free(state-&gt;in);</span>
<a href="#l17.40"></a><span id="l17.40" class="difflineplus">+            gz_error(state, Z_MEM_ERROR, &quot;out of memory&quot;);</span>
<a href="#l17.41"></a><span id="l17.41" class="difflineplus">+            return -1;</span>
<a href="#l17.42"></a><span id="l17.42" class="difflineplus">+        }</span>
<a href="#l17.43"></a><span id="l17.43" class="difflineplus">+</span>
<a href="#l17.44"></a><span id="l17.44" class="difflineplus">+        /* allocate deflate memory, set up for gzip compression */</span>
<a href="#l17.45"></a><span id="l17.45" class="difflineplus">+        strm-&gt;zalloc = Z_NULL;</span>
<a href="#l17.46"></a><span id="l17.46" class="difflineplus">+        strm-&gt;zfree = Z_NULL;</span>
<a href="#l17.47"></a><span id="l17.47" class="difflineplus">+        strm-&gt;opaque = Z_NULL;</span>
<a href="#l17.48"></a><span id="l17.48" class="difflineplus">+        ret = deflateInit2(strm, state-&gt;level, Z_DEFLATED,</span>
<a href="#l17.49"></a><span id="l17.49" class="difflineplus">+                           MAX_WBITS + 16, DEF_MEM_LEVEL, state-&gt;strategy);</span>
<a href="#l17.50"></a><span id="l17.50" class="difflineplus">+        if (ret != Z_OK) {</span>
<a href="#l17.51"></a><span id="l17.51" class="difflineplus">+            free(state-&gt;out);</span>
<a href="#l17.52"></a><span id="l17.52" class="difflineplus">+            free(state-&gt;in);</span>
<a href="#l17.53"></a><span id="l17.53" class="difflineplus">+            gz_error(state, Z_MEM_ERROR, &quot;out of memory&quot;);</span>
<a href="#l17.54"></a><span id="l17.54" class="difflineplus">+            return -1;</span>
<a href="#l17.55"></a><span id="l17.55" class="difflineplus">+        }</span>
<a href="#l17.56"></a><span id="l17.56" class="difflineplus">+        strm-&gt;next_in = NULL;</span>
<a href="#l17.57"></a><span id="l17.57" class="difflineplus">+    }</span>
<a href="#l17.58"></a><span id="l17.58" class="difflineplus">+</span>
<a href="#l17.59"></a><span id="l17.59" class="difflineplus">+    /* mark state as initialized */</span>
<a href="#l17.60"></a><span id="l17.60" class="difflineplus">+    state-&gt;size = state-&gt;want;</span>
<a href="#l17.61"></a><span id="l17.61" class="difflineplus">+</span>
<a href="#l17.62"></a><span id="l17.62" class="difflineplus">+    /* initialize write buffer if compressing */</span>
<a href="#l17.63"></a><span id="l17.63" class="difflineplus">+    if (!state-&gt;direct) {</span>
<a href="#l17.64"></a><span id="l17.64" class="difflineplus">+        strm-&gt;avail_out = state-&gt;size;</span>
<a href="#l17.65"></a><span id="l17.65" class="difflineplus">+        strm-&gt;next_out = state-&gt;out;</span>
<a href="#l17.66"></a><span id="l17.66" class="difflineplus">+        state-&gt;x.next = strm-&gt;next_out;</span>
<a href="#l17.67"></a><span id="l17.67" class="difflineplus">+    }</span>
<a href="#l17.68"></a><span id="l17.68" class="difflineplus">+    return 0;</span>
<a href="#l17.69"></a><span id="l17.69" class="difflineplus">+}</span>
<a href="#l17.70"></a><span id="l17.70" class="difflineplus">+</span>
<a href="#l17.71"></a><span id="l17.71" class="difflineplus">+/* Compress whatever is at avail_in and next_in and write to the output file.</span>
<a href="#l17.72"></a><span id="l17.72" class="difflineplus">+   Return -1 if there is an error writing to the output file or if gz_init()</span>
<a href="#l17.73"></a><span id="l17.73" class="difflineplus">+   fails to allocate memory, otherwise 0.  flush is assumed to be a valid</span>
<a href="#l17.74"></a><span id="l17.74" class="difflineplus">+   deflate() flush value.  If flush is Z_FINISH, then the deflate() state is</span>
<a href="#l17.75"></a><span id="l17.75" class="difflineplus">+   reset to start a new gzip stream.  If gz-&gt;direct is true, then simply write</span>
<a href="#l17.76"></a><span id="l17.76" class="difflineplus">+   to the output file without compressing, and ignore flush. */</span>
<a href="#l17.77"></a><span id="l17.77" class="difflineplus">+local int gz_comp(state, flush)</span>
<a href="#l17.78"></a><span id="l17.78" class="difflineplus">+    gz_statep state;</span>
<a href="#l17.79"></a><span id="l17.79" class="difflineplus">+    int flush;</span>
<a href="#l17.80"></a><span id="l17.80" class="difflineplus">+{</span>
<a href="#l17.81"></a><span id="l17.81" class="difflineplus">+    int ret, writ;</span>
<a href="#l17.82"></a><span id="l17.82" class="difflineplus">+    unsigned have, put, max = ((unsigned)-1 &gt;&gt; 2) + 1;</span>
<a href="#l17.83"></a><span id="l17.83" class="difflineplus">+    z_streamp strm = &amp;(state-&gt;strm);</span>
<a href="#l17.84"></a><span id="l17.84" class="difflineplus">+</span>
<a href="#l17.85"></a><span id="l17.85" class="difflineplus">+    /* allocate memory if this is the first time through */</span>
<a href="#l17.86"></a><span id="l17.86" class="difflineplus">+    if (state-&gt;size == 0 &amp;&amp; gz_init(state) == -1)</span>
<a href="#l17.87"></a><span id="l17.87" class="difflineplus">+        return -1;</span>
<a href="#l17.88"></a><span id="l17.88" class="difflineplus">+</span>
<a href="#l17.89"></a><span id="l17.89" class="difflineplus">+    /* write directly if requested */</span>
<a href="#l17.90"></a><span id="l17.90" class="difflineplus">+    if (state-&gt;direct) {</span>
<a href="#l17.91"></a><span id="l17.91" class="difflineplus">+        while (strm-&gt;avail_in) {</span>
<a href="#l17.92"></a><span id="l17.92" class="difflineplus">+            put = strm-&gt;avail_in &gt; max ? max : strm-&gt;avail_in;</span>
<a href="#l17.93"></a><span id="l17.93" class="difflineplus">+            writ = write(state-&gt;fd, strm-&gt;next_in, put);</span>
<a href="#l17.94"></a><span id="l17.94" class="difflineplus">+            if (writ &lt; 0) {</span>
<a href="#l17.95"></a><span id="l17.95" class="difflineplus">+                gz_error(state, Z_ERRNO, zstrerror());</span>
<a href="#l17.96"></a><span id="l17.96" class="difflineplus">+                return -1;</span>
<a href="#l17.97"></a><span id="l17.97" class="difflineplus">+            }</span>
<a href="#l17.98"></a><span id="l17.98" class="difflineplus">+            strm-&gt;avail_in -= (unsigned)writ;</span>
<a href="#l17.99"></a><span id="l17.99" class="difflineplus">+            strm-&gt;next_in += writ;</span>
<a href="#l17.100"></a><span id="l17.100" class="difflineplus">+        }</span>
<a href="#l17.101"></a><span id="l17.101" class="difflineplus">+        return 0;</span>
<a href="#l17.102"></a><span id="l17.102" class="difflineplus">+    }</span>
<a href="#l17.103"></a><span id="l17.103" class="difflineplus">+</span>
<a href="#l17.104"></a><span id="l17.104" class="difflineplus">+    /* run deflate() on provided input until it produces no more output */</span>
<a href="#l17.105"></a><span id="l17.105" class="difflineplus">+    ret = Z_OK;</span>
<a href="#l17.106"></a><span id="l17.106" class="difflineplus">+    do {</span>
<a href="#l17.107"></a><span id="l17.107" class="difflineplus">+        /* write out current buffer contents if full, or if flushing, but if</span>
<a href="#l17.108"></a><span id="l17.108" class="difflineplus">+           doing Z_FINISH then don't write until we get to Z_STREAM_END */</span>
<a href="#l17.109"></a><span id="l17.109" class="difflineplus">+        if (strm-&gt;avail_out == 0 || (flush != Z_NO_FLUSH &amp;&amp;</span>
<a href="#l17.110"></a><span id="l17.110" class="difflineplus">+            (flush != Z_FINISH || ret == Z_STREAM_END))) {</span>
<a href="#l17.111"></a><span id="l17.111" class="difflineplus">+            while (strm-&gt;next_out &gt; state-&gt;x.next) {</span>
<a href="#l17.112"></a><span id="l17.112" class="difflineplus">+                put = strm-&gt;next_out - state-&gt;x.next &gt; (int)max ? max :</span>
<a href="#l17.113"></a><span id="l17.113" class="difflineplus">+                      (unsigned)(strm-&gt;next_out - state-&gt;x.next);</span>
<a href="#l17.114"></a><span id="l17.114" class="difflineplus">+                writ = write(state-&gt;fd, state-&gt;x.next, put);</span>
<a href="#l17.115"></a><span id="l17.115" class="difflineplus">+                if (writ &lt; 0) {</span>
<a href="#l17.116"></a><span id="l17.116" class="difflineplus">+                    gz_error(state, Z_ERRNO, zstrerror());</span>
<a href="#l17.117"></a><span id="l17.117" class="difflineplus">+                    return -1;</span>
<a href="#l17.118"></a><span id="l17.118" class="difflineplus">+                }</span>
<a href="#l17.119"></a><span id="l17.119" class="difflineplus">+                state-&gt;x.next += writ;</span>
<a href="#l17.120"></a><span id="l17.120" class="difflineplus">+            }</span>
<a href="#l17.121"></a><span id="l17.121" class="difflineplus">+            if (strm-&gt;avail_out == 0) {</span>
<a href="#l17.122"></a><span id="l17.122" class="difflineplus">+                strm-&gt;avail_out = state-&gt;size;</span>
<a href="#l17.123"></a><span id="l17.123" class="difflineplus">+                strm-&gt;next_out = state-&gt;out;</span>
<a href="#l17.124"></a><span id="l17.124" class="difflineplus">+                state-&gt;x.next = state-&gt;out;</span>
<a href="#l17.125"></a><span id="l17.125" class="difflineplus">+            }</span>
<a href="#l17.126"></a><span id="l17.126" class="difflineplus">+        }</span>
<a href="#l17.127"></a><span id="l17.127" class="difflineplus">+</span>
<a href="#l17.128"></a><span id="l17.128" class="difflineplus">+        /* compress */</span>
<a href="#l17.129"></a><span id="l17.129" class="difflineplus">+        have = strm-&gt;avail_out;</span>
<a href="#l17.130"></a><span id="l17.130" class="difflineplus">+        ret = deflate(strm, flush);</span>
<a href="#l17.131"></a><span id="l17.131" class="difflineplus">+        if (ret == Z_STREAM_ERROR) {</span>
<a href="#l17.132"></a><span id="l17.132" class="difflineplus">+            gz_error(state, Z_STREAM_ERROR,</span>
<a href="#l17.133"></a><span id="l17.133" class="difflineplus">+                      &quot;internal error: deflate stream corrupt&quot;);</span>
<a href="#l17.134"></a><span id="l17.134" class="difflineplus">+            return -1;</span>
<a href="#l17.135"></a><span id="l17.135" class="difflineplus">+        }</span>
<a href="#l17.136"></a><span id="l17.136" class="difflineplus">+        have -= strm-&gt;avail_out;</span>
<a href="#l17.137"></a><span id="l17.137" class="difflineplus">+    } while (have);</span>
<a href="#l17.138"></a><span id="l17.138" class="difflineplus">+</span>
<a href="#l17.139"></a><span id="l17.139" class="difflineplus">+    /* if that completed a deflate stream, allow another to start */</span>
<a href="#l17.140"></a><span id="l17.140" class="difflineplus">+    if (flush == Z_FINISH)</span>
<a href="#l17.141"></a><span id="l17.141" class="difflineplus">+        deflateReset(strm);</span>
<a href="#l17.142"></a><span id="l17.142" class="difflineplus">+</span>
<a href="#l17.143"></a><span id="l17.143" class="difflineplus">+    /* all done, no errors */</span>
<a href="#l17.144"></a><span id="l17.144" class="difflineplus">+    return 0;</span>
<a href="#l17.145"></a><span id="l17.145" class="difflineplus">+}</span>
<a href="#l17.146"></a><span id="l17.146" class="difflineplus">+</span>
<a href="#l17.147"></a><span id="l17.147" class="difflineplus">+/* Compress len zeros to output.  Return -1 on a write error or memory</span>
<a href="#l17.148"></a><span id="l17.148" class="difflineplus">+   allocation failure by gz_comp(), or 0 on success. */</span>
<a href="#l17.149"></a><span id="l17.149" class="difflineplus">+local int gz_zero(state, len)</span>
<a href="#l17.150"></a><span id="l17.150" class="difflineplus">+    gz_statep state;</span>
<a href="#l17.151"></a><span id="l17.151" class="difflineplus">+    z_off64_t len;</span>
<a href="#l17.152"></a><span id="l17.152" class="difflineplus">+{</span>
<a href="#l17.153"></a><span id="l17.153" class="difflineplus">+    int first;</span>
<a href="#l17.154"></a><span id="l17.154" class="difflineplus">+    unsigned n;</span>
<a href="#l17.155"></a><span id="l17.155" class="difflineplus">+    z_streamp strm = &amp;(state-&gt;strm);</span>
<a href="#l17.156"></a><span id="l17.156" class="difflineplus">+</span>
<a href="#l17.157"></a><span id="l17.157" class="difflineplus">+    /* consume whatever's left in the input buffer */</span>
<a href="#l17.158"></a><span id="l17.158" class="difflineplus">+    if (strm-&gt;avail_in &amp;&amp; gz_comp(state, Z_NO_FLUSH) == -1)</span>
<a href="#l17.159"></a><span id="l17.159" class="difflineplus">+        return -1;</span>
<a href="#l17.160"></a><span id="l17.160" class="difflineplus">+</span>
<a href="#l17.161"></a><span id="l17.161" class="difflineplus">+    /* compress len zeros (len guaranteed &gt; 0) */</span>
<a href="#l17.162"></a><span id="l17.162" class="difflineplus">+    first = 1;</span>
<a href="#l17.163"></a><span id="l17.163" class="difflineplus">+    while (len) {</span>
<a href="#l17.164"></a><span id="l17.164" class="difflineplus">+        n = GT_OFF(state-&gt;size) || (z_off64_t)state-&gt;size &gt; len ?</span>
<a href="#l17.165"></a><span id="l17.165" class="difflineplus">+            (unsigned)len : state-&gt;size;</span>
<a href="#l17.166"></a><span id="l17.166" class="difflineplus">+        if (first) {</span>
<a href="#l17.167"></a><span id="l17.167" class="difflineplus">+            memset(state-&gt;in, 0, n);</span>
<a href="#l17.168"></a><span id="l17.168" class="difflineplus">+            first = 0;</span>
<a href="#l17.169"></a><span id="l17.169" class="difflineplus">+        }</span>
<a href="#l17.170"></a><span id="l17.170" class="difflineplus">+        strm-&gt;avail_in = n;</span>
<a href="#l17.171"></a><span id="l17.171" class="difflineplus">+        strm-&gt;next_in = state-&gt;in;</span>
<a href="#l17.172"></a><span id="l17.172" class="difflineplus">+        state-&gt;x.pos += n;</span>
<a href="#l17.173"></a><span id="l17.173" class="difflineplus">+        if (gz_comp(state, Z_NO_FLUSH) == -1)</span>
<a href="#l17.174"></a><span id="l17.174" class="difflineplus">+            return -1;</span>
<a href="#l17.175"></a><span id="l17.175" class="difflineplus">+        len -= n;</span>
<a href="#l17.176"></a><span id="l17.176" class="difflineplus">+    }</span>
<a href="#l17.177"></a><span id="l17.177" class="difflineplus">+    return 0;</span>
<a href="#l17.178"></a><span id="l17.178" class="difflineplus">+}</span>
<a href="#l17.179"></a><span id="l17.179" class="difflineplus">+</span>
<a href="#l17.180"></a><span id="l17.180" class="difflineplus">+/* Write len bytes from buf to file.  Return the number of bytes written.  If</span>
<a href="#l17.181"></a><span id="l17.181" class="difflineplus">+   the returned value is less than len, then there was an error. */</span>
<a href="#l17.182"></a><span id="l17.182" class="difflineplus">+local z_size_t gz_write(state, buf, len)</span>
<a href="#l17.183"></a><span id="l17.183" class="difflineplus">+    gz_statep state;</span>
<a href="#l17.184"></a><span id="l17.184" class="difflineplus">+    voidpc buf;</span>
<a href="#l17.185"></a><span id="l17.185" class="difflineplus">+    z_size_t len;</span>
<a href="#l17.186"></a><span id="l17.186" class="difflineplus">+{</span>
<a href="#l17.187"></a><span id="l17.187" class="difflineplus">+    z_size_t put = len;</span>
<a href="#l17.188"></a><span id="l17.188" class="difflineplus">+</span>
<a href="#l17.189"></a><span id="l17.189" class="difflineplus">+    /* if len is zero, avoid unnecessary operations */</span>
<a href="#l17.190"></a><span id="l17.190" class="difflineplus">+    if (len == 0)</span>
<a href="#l17.191"></a><span id="l17.191" class="difflineplus">+        return 0;</span>
<a href="#l17.192"></a><span id="l17.192" class="difflineplus">+</span>
<a href="#l17.193"></a><span id="l17.193" class="difflineplus">+    /* allocate memory if this is the first time through */</span>
<a href="#l17.194"></a><span id="l17.194" class="difflineplus">+    if (state-&gt;size == 0 &amp;&amp; gz_init(state) == -1)</span>
<a href="#l17.195"></a><span id="l17.195" class="difflineplus">+        return 0;</span>
<a href="#l17.196"></a><span id="l17.196" class="difflineplus">+</span>
<a href="#l17.197"></a><span id="l17.197" class="difflineplus">+    /* check for seek request */</span>
<a href="#l17.198"></a><span id="l17.198" class="difflineplus">+    if (state-&gt;seek) {</span>
<a href="#l17.199"></a><span id="l17.199" class="difflineplus">+        state-&gt;seek = 0;</span>
<a href="#l17.200"></a><span id="l17.200" class="difflineplus">+        if (gz_zero(state, state-&gt;skip) == -1)</span>
<a href="#l17.201"></a><span id="l17.201" class="difflineplus">+            return 0;</span>
<a href="#l17.202"></a><span id="l17.202" class="difflineplus">+    }</span>
<a href="#l17.203"></a><span id="l17.203" class="difflineplus">+</span>
<a href="#l17.204"></a><span id="l17.204" class="difflineplus">+    /* for small len, copy to input buffer, otherwise compress directly */</span>
<a href="#l17.205"></a><span id="l17.205" class="difflineplus">+    if (len &lt; state-&gt;size) {</span>
<a href="#l17.206"></a><span id="l17.206" class="difflineplus">+        /* copy to input buffer, compress when full */</span>
<a href="#l17.207"></a><span id="l17.207" class="difflineplus">+        do {</span>
<a href="#l17.208"></a><span id="l17.208" class="difflineplus">+            unsigned have, copy;</span>
<a href="#l17.209"></a><span id="l17.209" class="difflineplus">+</span>
<a href="#l17.210"></a><span id="l17.210" class="difflineplus">+            if (state-&gt;strm.avail_in == 0)</span>
<a href="#l17.211"></a><span id="l17.211" class="difflineplus">+                state-&gt;strm.next_in = state-&gt;in;</span>
<a href="#l17.212"></a><span id="l17.212" class="difflineplus">+            have = (unsigned)((state-&gt;strm.next_in + state-&gt;strm.avail_in) -</span>
<a href="#l17.213"></a><span id="l17.213" class="difflineplus">+                              state-&gt;in);</span>
<a href="#l17.214"></a><span id="l17.214" class="difflineplus">+            copy = state-&gt;size - have;</span>
<a href="#l17.215"></a><span id="l17.215" class="difflineplus">+            if (copy &gt; len)</span>
<a href="#l17.216"></a><span id="l17.216" class="difflineplus">+                copy = len;</span>
<a href="#l17.217"></a><span id="l17.217" class="difflineplus">+            memcpy(state-&gt;in + have, buf, copy);</span>
<a href="#l17.218"></a><span id="l17.218" class="difflineplus">+            state-&gt;strm.avail_in += copy;</span>
<a href="#l17.219"></a><span id="l17.219" class="difflineplus">+            state-&gt;x.pos += copy;</span>
<a href="#l17.220"></a><span id="l17.220" class="difflineplus">+            buf = (const char *)buf + copy;</span>
<a href="#l17.221"></a><span id="l17.221" class="difflineplus">+            len -= copy;</span>
<a href="#l17.222"></a><span id="l17.222" class="difflineplus">+            if (len &amp;&amp; gz_comp(state, Z_NO_FLUSH) == -1)</span>
<a href="#l17.223"></a><span id="l17.223" class="difflineplus">+                return 0;</span>
<a href="#l17.224"></a><span id="l17.224" class="difflineplus">+        } while (len);</span>
<a href="#l17.225"></a><span id="l17.225" class="difflineplus">+    }</span>
<a href="#l17.226"></a><span id="l17.226" class="difflineplus">+    else {</span>
<a href="#l17.227"></a><span id="l17.227" class="difflineplus">+        /* consume whatever's left in the input buffer */</span>
<a href="#l17.228"></a><span id="l17.228" class="difflineplus">+        if (state-&gt;strm.avail_in &amp;&amp; gz_comp(state, Z_NO_FLUSH) == -1)</span>
<a href="#l17.229"></a><span id="l17.229" class="difflineplus">+            return 0;</span>
<a href="#l17.230"></a><span id="l17.230" class="difflineplus">+</span>
<a href="#l17.231"></a><span id="l17.231" class="difflineplus">+        /* directly compress user buffer to file */</span>
<a href="#l17.232"></a><span id="l17.232" class="difflineplus">+        state-&gt;strm.next_in = (z_const Bytef *)buf;</span>
<a href="#l17.233"></a><span id="l17.233" class="difflineplus">+        do {</span>
<a href="#l17.234"></a><span id="l17.234" class="difflineplus">+            unsigned n = (unsigned)-1;</span>
<a href="#l17.235"></a><span id="l17.235" class="difflineplus">+            if (n &gt; len)</span>
<a href="#l17.236"></a><span id="l17.236" class="difflineplus">+                n = len;</span>
<a href="#l17.237"></a><span id="l17.237" class="difflineplus">+            state-&gt;strm.avail_in = n;</span>
<a href="#l17.238"></a><span id="l17.238" class="difflineplus">+            state-&gt;x.pos += n;</span>
<a href="#l17.239"></a><span id="l17.239" class="difflineplus">+            if (gz_comp(state, Z_NO_FLUSH) == -1)</span>
<a href="#l17.240"></a><span id="l17.240" class="difflineplus">+                return 0;</span>
<a href="#l17.241"></a><span id="l17.241" class="difflineplus">+            len -= n;</span>
<a href="#l17.242"></a><span id="l17.242" class="difflineplus">+        } while (len);</span>
<a href="#l17.243"></a><span id="l17.243" class="difflineplus">+    }</span>
<a href="#l17.244"></a><span id="l17.244" class="difflineplus">+</span>
<a href="#l17.245"></a><span id="l17.245" class="difflineplus">+    /* input was all buffered or compressed */</span>
<a href="#l17.246"></a><span id="l17.246" class="difflineplus">+    return put;</span>
<a href="#l17.247"></a><span id="l17.247" class="difflineplus">+}</span>
<a href="#l17.248"></a><span id="l17.248" class="difflineplus">+</span>
<a href="#l17.249"></a><span id="l17.249" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l17.250"></a><span id="l17.250" class="difflineplus">+int ZEXPORT gzwrite(file, buf, len)</span>
<a href="#l17.251"></a><span id="l17.251" class="difflineplus">+    gzFile file;</span>
<a href="#l17.252"></a><span id="l17.252" class="difflineplus">+    voidpc buf;</span>
<a href="#l17.253"></a><span id="l17.253" class="difflineplus">+    unsigned len;</span>
<a href="#l17.254"></a><span id="l17.254" class="difflineplus">+{</span>
<a href="#l17.255"></a><span id="l17.255" class="difflineplus">+    gz_statep state;</span>
<a href="#l17.256"></a><span id="l17.256" class="difflineplus">+</span>
<a href="#l17.257"></a><span id="l17.257" class="difflineplus">+    /* get internal structure */</span>
<a href="#l17.258"></a><span id="l17.258" class="difflineplus">+    if (file == NULL)</span>
<a href="#l17.259"></a><span id="l17.259" class="difflineplus">+        return 0;</span>
<a href="#l17.260"></a><span id="l17.260" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l17.261"></a><span id="l17.261" class="difflineplus">+</span>
<a href="#l17.262"></a><span id="l17.262" class="difflineplus">+    /* check that we're writing and that there's no error */</span>
<a href="#l17.263"></a><span id="l17.263" class="difflineplus">+    if (state-&gt;mode != GZ_WRITE || state-&gt;err != Z_OK)</span>
<a href="#l17.264"></a><span id="l17.264" class="difflineplus">+        return 0;</span>
<a href="#l17.265"></a><span id="l17.265" class="difflineplus">+</span>
<a href="#l17.266"></a><span id="l17.266" class="difflineplus">+    /* since an int is returned, make sure len fits in one, otherwise return</span>
<a href="#l17.267"></a><span id="l17.267" class="difflineplus">+       with an error (this avoids a flaw in the interface) */</span>
<a href="#l17.268"></a><span id="l17.268" class="difflineplus">+    if ((int)len &lt; 0) {</span>
<a href="#l17.269"></a><span id="l17.269" class="difflineplus">+        gz_error(state, Z_DATA_ERROR, &quot;requested length does not fit in int&quot;);</span>
<a href="#l17.270"></a><span id="l17.270" class="difflineplus">+        return 0;</span>
<a href="#l17.271"></a><span id="l17.271" class="difflineplus">+    }</span>
<a href="#l17.272"></a><span id="l17.272" class="difflineplus">+</span>
<a href="#l17.273"></a><span id="l17.273" class="difflineplus">+    /* write len bytes from buf (the return value will fit in an int) */</span>
<a href="#l17.274"></a><span id="l17.274" class="difflineplus">+    return (int)gz_write(state, buf, len);</span>
<a href="#l17.275"></a><span id="l17.275" class="difflineplus">+}</span>
<a href="#l17.276"></a><span id="l17.276" class="difflineplus">+</span>
<a href="#l17.277"></a><span id="l17.277" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l17.278"></a><span id="l17.278" class="difflineplus">+z_size_t ZEXPORT gzfwrite(buf, size, nitems, file)</span>
<a href="#l17.279"></a><span id="l17.279" class="difflineplus">+    voidpc buf;</span>
<a href="#l17.280"></a><span id="l17.280" class="difflineplus">+    z_size_t size;</span>
<a href="#l17.281"></a><span id="l17.281" class="difflineplus">+    z_size_t nitems;</span>
<a href="#l17.282"></a><span id="l17.282" class="difflineplus">+    gzFile file;</span>
<a href="#l17.283"></a><span id="l17.283" class="difflineplus">+{</span>
<a href="#l17.284"></a><span id="l17.284" class="difflineplus">+    z_size_t len;</span>
<a href="#l17.285"></a><span id="l17.285" class="difflineplus">+    gz_statep state;</span>
<a href="#l17.286"></a><span id="l17.286" class="difflineplus">+</span>
<a href="#l17.287"></a><span id="l17.287" class="difflineplus">+    /* get internal structure */</span>
<a href="#l17.288"></a><span id="l17.288" class="difflineplus">+    if (file == NULL)</span>
<a href="#l17.289"></a><span id="l17.289" class="difflineplus">+        return 0;</span>
<a href="#l17.290"></a><span id="l17.290" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l17.291"></a><span id="l17.291" class="difflineplus">+</span>
<a href="#l17.292"></a><span id="l17.292" class="difflineplus">+    /* check that we're writing and that there's no error */</span>
<a href="#l17.293"></a><span id="l17.293" class="difflineplus">+    if (state-&gt;mode != GZ_WRITE || state-&gt;err != Z_OK)</span>
<a href="#l17.294"></a><span id="l17.294" class="difflineplus">+        return 0;</span>
<a href="#l17.295"></a><span id="l17.295" class="difflineplus">+</span>
<a href="#l17.296"></a><span id="l17.296" class="difflineplus">+    /* compute bytes to read -- error on overflow */</span>
<a href="#l17.297"></a><span id="l17.297" class="difflineplus">+    len = nitems * size;</span>
<a href="#l17.298"></a><span id="l17.298" class="difflineplus">+    if (size &amp;&amp; len / size != nitems) {</span>
<a href="#l17.299"></a><span id="l17.299" class="difflineplus">+        gz_error(state, Z_STREAM_ERROR, &quot;request does not fit in a size_t&quot;);</span>
<a href="#l17.300"></a><span id="l17.300" class="difflineplus">+        return 0;</span>
<a href="#l17.301"></a><span id="l17.301" class="difflineplus">+    }</span>
<a href="#l17.302"></a><span id="l17.302" class="difflineplus">+</span>
<a href="#l17.303"></a><span id="l17.303" class="difflineplus">+    /* write len bytes to buf, return the number of full items written */</span>
<a href="#l17.304"></a><span id="l17.304" class="difflineplus">+    return len ? gz_write(state, buf, len) / size : 0;</span>
<a href="#l17.305"></a><span id="l17.305" class="difflineplus">+}</span>
<a href="#l17.306"></a><span id="l17.306" class="difflineplus">+</span>
<a href="#l17.307"></a><span id="l17.307" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l17.308"></a><span id="l17.308" class="difflineplus">+int ZEXPORT gzputc(file, c)</span>
<a href="#l17.309"></a><span id="l17.309" class="difflineplus">+    gzFile file;</span>
<a href="#l17.310"></a><span id="l17.310" class="difflineplus">+    int c;</span>
<a href="#l17.311"></a><span id="l17.311" class="difflineplus">+{</span>
<a href="#l17.312"></a><span id="l17.312" class="difflineplus">+    unsigned have;</span>
<a href="#l17.313"></a><span id="l17.313" class="difflineplus">+    unsigned char buf[1];</span>
<a href="#l17.314"></a><span id="l17.314" class="difflineplus">+    gz_statep state;</span>
<a href="#l17.315"></a><span id="l17.315" class="difflineplus">+    z_streamp strm;</span>
<a href="#l17.316"></a><span id="l17.316" class="difflineplus">+</span>
<a href="#l17.317"></a><span id="l17.317" class="difflineplus">+    /* get internal structure */</span>
<a href="#l17.318"></a><span id="l17.318" class="difflineplus">+    if (file == NULL)</span>
<a href="#l17.319"></a><span id="l17.319" class="difflineplus">+        return -1;</span>
<a href="#l17.320"></a><span id="l17.320" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l17.321"></a><span id="l17.321" class="difflineplus">+    strm = &amp;(state-&gt;strm);</span>
<a href="#l17.322"></a><span id="l17.322" class="difflineplus">+</span>
<a href="#l17.323"></a><span id="l17.323" class="difflineplus">+    /* check that we're writing and that there's no error */</span>
<a href="#l17.324"></a><span id="l17.324" class="difflineplus">+    if (state-&gt;mode != GZ_WRITE || state-&gt;err != Z_OK)</span>
<a href="#l17.325"></a><span id="l17.325" class="difflineplus">+        return -1;</span>
<a href="#l17.326"></a><span id="l17.326" class="difflineplus">+</span>
<a href="#l17.327"></a><span id="l17.327" class="difflineplus">+    /* check for seek request */</span>
<a href="#l17.328"></a><span id="l17.328" class="difflineplus">+    if (state-&gt;seek) {</span>
<a href="#l17.329"></a><span id="l17.329" class="difflineplus">+        state-&gt;seek = 0;</span>
<a href="#l17.330"></a><span id="l17.330" class="difflineplus">+        if (gz_zero(state, state-&gt;skip) == -1)</span>
<a href="#l17.331"></a><span id="l17.331" class="difflineplus">+            return -1;</span>
<a href="#l17.332"></a><span id="l17.332" class="difflineplus">+    }</span>
<a href="#l17.333"></a><span id="l17.333" class="difflineplus">+</span>
<a href="#l17.334"></a><span id="l17.334" class="difflineplus">+    /* try writing to input buffer for speed (state-&gt;size == 0 if buffer not</span>
<a href="#l17.335"></a><span id="l17.335" class="difflineplus">+       initialized) */</span>
<a href="#l17.336"></a><span id="l17.336" class="difflineplus">+    if (state-&gt;size) {</span>
<a href="#l17.337"></a><span id="l17.337" class="difflineplus">+        if (strm-&gt;avail_in == 0)</span>
<a href="#l17.338"></a><span id="l17.338" class="difflineplus">+            strm-&gt;next_in = state-&gt;in;</span>
<a href="#l17.339"></a><span id="l17.339" class="difflineplus">+        have = (unsigned)((strm-&gt;next_in + strm-&gt;avail_in) - state-&gt;in);</span>
<a href="#l17.340"></a><span id="l17.340" class="difflineplus">+        if (have &lt; state-&gt;size) {</span>
<a href="#l17.341"></a><span id="l17.341" class="difflineplus">+            state-&gt;in[have] = (unsigned char)c;</span>
<a href="#l17.342"></a><span id="l17.342" class="difflineplus">+            strm-&gt;avail_in++;</span>
<a href="#l17.343"></a><span id="l17.343" class="difflineplus">+            state-&gt;x.pos++;</span>
<a href="#l17.344"></a><span id="l17.344" class="difflineplus">+            return c &amp; 0xff;</span>
<a href="#l17.345"></a><span id="l17.345" class="difflineplus">+        }</span>
<a href="#l17.346"></a><span id="l17.346" class="difflineplus">+    }</span>
<a href="#l17.347"></a><span id="l17.347" class="difflineplus">+</span>
<a href="#l17.348"></a><span id="l17.348" class="difflineplus">+    /* no room in buffer or not initialized, use gz_write() */</span>
<a href="#l17.349"></a><span id="l17.349" class="difflineplus">+    buf[0] = (unsigned char)c;</span>
<a href="#l17.350"></a><span id="l17.350" class="difflineplus">+    if (gz_write(state, buf, 1) != 1)</span>
<a href="#l17.351"></a><span id="l17.351" class="difflineplus">+        return -1;</span>
<a href="#l17.352"></a><span id="l17.352" class="difflineplus">+    return c &amp; 0xff;</span>
<a href="#l17.353"></a><span id="l17.353" class="difflineplus">+}</span>
<a href="#l17.354"></a><span id="l17.354" class="difflineplus">+</span>
<a href="#l17.355"></a><span id="l17.355" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l17.356"></a><span id="l17.356" class="difflineplus">+int ZEXPORT gzputs(file, str)</span>
<a href="#l17.357"></a><span id="l17.357" class="difflineplus">+    gzFile file;</span>
<a href="#l17.358"></a><span id="l17.358" class="difflineplus">+    const char *str;</span>
<a href="#l17.359"></a><span id="l17.359" class="difflineplus">+{</span>
<a href="#l17.360"></a><span id="l17.360" class="difflineplus">+    int ret;</span>
<a href="#l17.361"></a><span id="l17.361" class="difflineplus">+    z_size_t len;</span>
<a href="#l17.362"></a><span id="l17.362" class="difflineplus">+    gz_statep state;</span>
<a href="#l17.363"></a><span id="l17.363" class="difflineplus">+</span>
<a href="#l17.364"></a><span id="l17.364" class="difflineplus">+    /* get internal structure */</span>
<a href="#l17.365"></a><span id="l17.365" class="difflineplus">+    if (file == NULL)</span>
<a href="#l17.366"></a><span id="l17.366" class="difflineplus">+        return -1;</span>
<a href="#l17.367"></a><span id="l17.367" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l17.368"></a><span id="l17.368" class="difflineplus">+</span>
<a href="#l17.369"></a><span id="l17.369" class="difflineplus">+    /* check that we're writing and that there's no error */</span>
<a href="#l17.370"></a><span id="l17.370" class="difflineplus">+    if (state-&gt;mode != GZ_WRITE || state-&gt;err != Z_OK)</span>
<a href="#l17.371"></a><span id="l17.371" class="difflineplus">+        return -1;</span>
<a href="#l17.372"></a><span id="l17.372" class="difflineplus">+</span>
<a href="#l17.373"></a><span id="l17.373" class="difflineplus">+    /* write string */</span>
<a href="#l17.374"></a><span id="l17.374" class="difflineplus">+    len = strlen(str);</span>
<a href="#l17.375"></a><span id="l17.375" class="difflineplus">+    ret = gz_write(state, str, len);</span>
<a href="#l17.376"></a><span id="l17.376" class="difflineplus">+    return ret == 0 &amp;&amp; len != 0 ? -1 : ret;</span>
<a href="#l17.377"></a><span id="l17.377" class="difflineplus">+}</span>
<a href="#l17.378"></a><span id="l17.378" class="difflineplus">+</span>
<a href="#l17.379"></a><span id="l17.379" class="difflineplus">+#if defined(STDC) || defined(Z_HAVE_STDARG_H)</span>
<a href="#l17.380"></a><span id="l17.380" class="difflineplus">+#include &lt;stdarg.h&gt;</span>
<a href="#l17.381"></a><span id="l17.381" class="difflineplus">+</span>
<a href="#l17.382"></a><span id="l17.382" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l17.383"></a><span id="l17.383" class="difflineplus">+int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)</span>
<a href="#l17.384"></a><span id="l17.384" class="difflineplus">+{</span>
<a href="#l17.385"></a><span id="l17.385" class="difflineplus">+    int len;</span>
<a href="#l17.386"></a><span id="l17.386" class="difflineplus">+    unsigned left;</span>
<a href="#l17.387"></a><span id="l17.387" class="difflineplus">+    char *next;</span>
<a href="#l17.388"></a><span id="l17.388" class="difflineplus">+    gz_statep state;</span>
<a href="#l17.389"></a><span id="l17.389" class="difflineplus">+    z_streamp strm;</span>
<a href="#l17.390"></a><span id="l17.390" class="difflineplus">+</span>
<a href="#l17.391"></a><span id="l17.391" class="difflineplus">+    /* get internal structure */</span>
<a href="#l17.392"></a><span id="l17.392" class="difflineplus">+    if (file == NULL)</span>
<a href="#l17.393"></a><span id="l17.393" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l17.394"></a><span id="l17.394" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l17.395"></a><span id="l17.395" class="difflineplus">+    strm = &amp;(state-&gt;strm);</span>
<a href="#l17.396"></a><span id="l17.396" class="difflineplus">+</span>
<a href="#l17.397"></a><span id="l17.397" class="difflineplus">+    /* check that we're writing and that there's no error */</span>
<a href="#l17.398"></a><span id="l17.398" class="difflineplus">+    if (state-&gt;mode != GZ_WRITE || state-&gt;err != Z_OK)</span>
<a href="#l17.399"></a><span id="l17.399" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l17.400"></a><span id="l17.400" class="difflineplus">+</span>
<a href="#l17.401"></a><span id="l17.401" class="difflineplus">+    /* make sure we have some buffer space */</span>
<a href="#l17.402"></a><span id="l17.402" class="difflineplus">+    if (state-&gt;size == 0 &amp;&amp; gz_init(state) == -1)</span>
<a href="#l17.403"></a><span id="l17.403" class="difflineplus">+        return state-&gt;err;</span>
<a href="#l17.404"></a><span id="l17.404" class="difflineplus">+</span>
<a href="#l17.405"></a><span id="l17.405" class="difflineplus">+    /* check for seek request */</span>
<a href="#l17.406"></a><span id="l17.406" class="difflineplus">+    if (state-&gt;seek) {</span>
<a href="#l17.407"></a><span id="l17.407" class="difflineplus">+        state-&gt;seek = 0;</span>
<a href="#l17.408"></a><span id="l17.408" class="difflineplus">+        if (gz_zero(state, state-&gt;skip) == -1)</span>
<a href="#l17.409"></a><span id="l17.409" class="difflineplus">+            return state-&gt;err;</span>
<a href="#l17.410"></a><span id="l17.410" class="difflineplus">+    }</span>
<a href="#l17.411"></a><span id="l17.411" class="difflineplus">+</span>
<a href="#l17.412"></a><span id="l17.412" class="difflineplus">+    /* do the printf() into the input buffer, put length in len -- the input</span>
<a href="#l17.413"></a><span id="l17.413" class="difflineplus">+       buffer is double-sized just for this function, so there is guaranteed to</span>
<a href="#l17.414"></a><span id="l17.414" class="difflineplus">+       be state-&gt;size bytes available after the current contents */</span>
<a href="#l17.415"></a><span id="l17.415" class="difflineplus">+    if (strm-&gt;avail_in == 0)</span>
<a href="#l17.416"></a><span id="l17.416" class="difflineplus">+        strm-&gt;next_in = state-&gt;in;</span>
<a href="#l17.417"></a><span id="l17.417" class="difflineplus">+    next = (char *)(state-&gt;in + (strm-&gt;next_in - state-&gt;in) + strm-&gt;avail_in);</span>
<a href="#l17.418"></a><span id="l17.418" class="difflineplus">+    next[state-&gt;size - 1] = 0;</span>
<a href="#l17.419"></a><span id="l17.419" class="difflineplus">+#ifdef NO_vsnprintf</span>
<a href="#l17.420"></a><span id="l17.420" class="difflineplus">+#  ifdef HAS_vsprintf_void</span>
<a href="#l17.421"></a><span id="l17.421" class="difflineplus">+    (void)vsprintf(next, format, va);</span>
<a href="#l17.422"></a><span id="l17.422" class="difflineplus">+    for (len = 0; len &lt; state-&gt;size; len++)</span>
<a href="#l17.423"></a><span id="l17.423" class="difflineplus">+        if (next[len] == 0) break;</span>
<a href="#l17.424"></a><span id="l17.424" class="difflineplus">+#  else</span>
<a href="#l17.425"></a><span id="l17.425" class="difflineplus">+    len = vsprintf(next, format, va);</span>
<a href="#l17.426"></a><span id="l17.426" class="difflineplus">+#  endif</span>
<a href="#l17.427"></a><span id="l17.427" class="difflineplus">+#else</span>
<a href="#l17.428"></a><span id="l17.428" class="difflineplus">+#  ifdef HAS_vsnprintf_void</span>
<a href="#l17.429"></a><span id="l17.429" class="difflineplus">+    (void)vsnprintf(next, state-&gt;size, format, va);</span>
<a href="#l17.430"></a><span id="l17.430" class="difflineplus">+    len = strlen(next);</span>
<a href="#l17.431"></a><span id="l17.431" class="difflineplus">+#  else</span>
<a href="#l17.432"></a><span id="l17.432" class="difflineplus">+    len = vsnprintf(next, state-&gt;size, format, va);</span>
<a href="#l17.433"></a><span id="l17.433" class="difflineplus">+#  endif</span>
<a href="#l17.434"></a><span id="l17.434" class="difflineplus">+#endif</span>
<a href="#l17.435"></a><span id="l17.435" class="difflineplus">+</span>
<a href="#l17.436"></a><span id="l17.436" class="difflineplus">+    /* check that printf() results fit in buffer */</span>
<a href="#l17.437"></a><span id="l17.437" class="difflineplus">+    if (len == 0 || (unsigned)len &gt;= state-&gt;size || next[state-&gt;size - 1] != 0)</span>
<a href="#l17.438"></a><span id="l17.438" class="difflineplus">+        return 0;</span>
<a href="#l17.439"></a><span id="l17.439" class="difflineplus">+</span>
<a href="#l17.440"></a><span id="l17.440" class="difflineplus">+    /* update buffer and position, compress first half if past that */</span>
<a href="#l17.441"></a><span id="l17.441" class="difflineplus">+    strm-&gt;avail_in += (unsigned)len;</span>
<a href="#l17.442"></a><span id="l17.442" class="difflineplus">+    state-&gt;x.pos += len;</span>
<a href="#l17.443"></a><span id="l17.443" class="difflineplus">+    if (strm-&gt;avail_in &gt;= state-&gt;size) {</span>
<a href="#l17.444"></a><span id="l17.444" class="difflineplus">+        left = strm-&gt;avail_in - state-&gt;size;</span>
<a href="#l17.445"></a><span id="l17.445" class="difflineplus">+        strm-&gt;avail_in = state-&gt;size;</span>
<a href="#l17.446"></a><span id="l17.446" class="difflineplus">+        if (gz_comp(state, Z_NO_FLUSH) == -1)</span>
<a href="#l17.447"></a><span id="l17.447" class="difflineplus">+            return state-&gt;err;</span>
<a href="#l17.448"></a><span id="l17.448" class="difflineplus">+        memcpy(state-&gt;in, state-&gt;in + state-&gt;size, left);</span>
<a href="#l17.449"></a><span id="l17.449" class="difflineplus">+        strm-&gt;next_in = state-&gt;in;</span>
<a href="#l17.450"></a><span id="l17.450" class="difflineplus">+        strm-&gt;avail_in = left;</span>
<a href="#l17.451"></a><span id="l17.451" class="difflineplus">+    }</span>
<a href="#l17.452"></a><span id="l17.452" class="difflineplus">+    return len;</span>
<a href="#l17.453"></a><span id="l17.453" class="difflineplus">+}</span>
<a href="#l17.454"></a><span id="l17.454" class="difflineplus">+</span>
<a href="#l17.455"></a><span id="l17.455" class="difflineplus">+int ZEXPORTVA gzprintf(gzFile file, const char *format, ...)</span>
<a href="#l17.456"></a><span id="l17.456" class="difflineplus">+{</span>
<a href="#l17.457"></a><span id="l17.457" class="difflineplus">+    va_list va;</span>
<a href="#l17.458"></a><span id="l17.458" class="difflineplus">+    int ret;</span>
<a href="#l17.459"></a><span id="l17.459" class="difflineplus">+</span>
<a href="#l17.460"></a><span id="l17.460" class="difflineplus">+    va_start(va, format);</span>
<a href="#l17.461"></a><span id="l17.461" class="difflineplus">+    ret = gzvprintf(file, format, va);</span>
<a href="#l17.462"></a><span id="l17.462" class="difflineplus">+    va_end(va);</span>
<a href="#l17.463"></a><span id="l17.463" class="difflineplus">+    return ret;</span>
<a href="#l17.464"></a><span id="l17.464" class="difflineplus">+}</span>
<a href="#l17.465"></a><span id="l17.465" class="difflineplus">+</span>
<a href="#l17.466"></a><span id="l17.466" class="difflineplus">+#else /* !STDC &amp;&amp; !Z_HAVE_STDARG_H */</span>
<a href="#l17.467"></a><span id="l17.467" class="difflineplus">+</span>
<a href="#l17.468"></a><span id="l17.468" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l17.469"></a><span id="l17.469" class="difflineplus">+int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,</span>
<a href="#l17.470"></a><span id="l17.470" class="difflineplus">+                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)</span>
<a href="#l17.471"></a><span id="l17.471" class="difflineplus">+    gzFile file;</span>
<a href="#l17.472"></a><span id="l17.472" class="difflineplus">+    const char *format;</span>
<a href="#l17.473"></a><span id="l17.473" class="difflineplus">+    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,</span>
<a href="#l17.474"></a><span id="l17.474" class="difflineplus">+        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;</span>
<a href="#l17.475"></a><span id="l17.475" class="difflineplus">+{</span>
<a href="#l17.476"></a><span id="l17.476" class="difflineplus">+    unsigned len, left;</span>
<a href="#l17.477"></a><span id="l17.477" class="difflineplus">+    char *next;</span>
<a href="#l17.478"></a><span id="l17.478" class="difflineplus">+    gz_statep state;</span>
<a href="#l17.479"></a><span id="l17.479" class="difflineplus">+    z_streamp strm;</span>
<a href="#l17.480"></a><span id="l17.480" class="difflineplus">+</span>
<a href="#l17.481"></a><span id="l17.481" class="difflineplus">+    /* get internal structure */</span>
<a href="#l17.482"></a><span id="l17.482" class="difflineplus">+    if (file == NULL)</span>
<a href="#l17.483"></a><span id="l17.483" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l17.484"></a><span id="l17.484" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l17.485"></a><span id="l17.485" class="difflineplus">+    strm = &amp;(state-&gt;strm);</span>
<a href="#l17.486"></a><span id="l17.486" class="difflineplus">+</span>
<a href="#l17.487"></a><span id="l17.487" class="difflineplus">+    /* check that can really pass pointer in ints */</span>
<a href="#l17.488"></a><span id="l17.488" class="difflineplus">+    if (sizeof(int) != sizeof(void *))</span>
<a href="#l17.489"></a><span id="l17.489" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l17.490"></a><span id="l17.490" class="difflineplus">+</span>
<a href="#l17.491"></a><span id="l17.491" class="difflineplus">+    /* check that we're writing and that there's no error */</span>
<a href="#l17.492"></a><span id="l17.492" class="difflineplus">+    if (state-&gt;mode != GZ_WRITE || state-&gt;err != Z_OK)</span>
<a href="#l17.493"></a><span id="l17.493" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l17.494"></a><span id="l17.494" class="difflineplus">+</span>
<a href="#l17.495"></a><span id="l17.495" class="difflineplus">+    /* make sure we have some buffer space */</span>
<a href="#l17.496"></a><span id="l17.496" class="difflineplus">+    if (state-&gt;size == 0 &amp;&amp; gz_init(state) == -1)</span>
<a href="#l17.497"></a><span id="l17.497" class="difflineplus">+        return state-&gt;error;</span>
<a href="#l17.498"></a><span id="l17.498" class="difflineplus">+</span>
<a href="#l17.499"></a><span id="l17.499" class="difflineplus">+    /* check for seek request */</span>
<a href="#l17.500"></a><span id="l17.500" class="difflineplus">+    if (state-&gt;seek) {</span>
<a href="#l17.501"></a><span id="l17.501" class="difflineplus">+        state-&gt;seek = 0;</span>
<a href="#l17.502"></a><span id="l17.502" class="difflineplus">+        if (gz_zero(state, state-&gt;skip) == -1)</span>
<a href="#l17.503"></a><span id="l17.503" class="difflineplus">+            return state-&gt;error;</span>
<a href="#l17.504"></a><span id="l17.504" class="difflineplus">+    }</span>
<a href="#l17.505"></a><span id="l17.505" class="difflineplus">+</span>
<a href="#l17.506"></a><span id="l17.506" class="difflineplus">+    /* do the printf() into the input buffer, put length in len -- the input</span>
<a href="#l17.507"></a><span id="l17.507" class="difflineplus">+       buffer is double-sized just for this function, so there is guaranteed to</span>
<a href="#l17.508"></a><span id="l17.508" class="difflineplus">+       be state-&gt;size bytes available after the current contents */</span>
<a href="#l17.509"></a><span id="l17.509" class="difflineplus">+    if (strm-&gt;avail_in == 0)</span>
<a href="#l17.510"></a><span id="l17.510" class="difflineplus">+        strm-&gt;next_in = state-&gt;in;</span>
<a href="#l17.511"></a><span id="l17.511" class="difflineplus">+    next = (char *)(strm-&gt;next_in + strm-&gt;avail_in);</span>
<a href="#l17.512"></a><span id="l17.512" class="difflineplus">+    next[state-&gt;size - 1] = 0;</span>
<a href="#l17.513"></a><span id="l17.513" class="difflineplus">+#ifdef NO_snprintf</span>
<a href="#l17.514"></a><span id="l17.514" class="difflineplus">+#  ifdef HAS_sprintf_void</span>
<a href="#l17.515"></a><span id="l17.515" class="difflineplus">+    sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12,</span>
<a href="#l17.516"></a><span id="l17.516" class="difflineplus">+            a13, a14, a15, a16, a17, a18, a19, a20);</span>
<a href="#l17.517"></a><span id="l17.517" class="difflineplus">+    for (len = 0; len &lt; size; len++)</span>
<a href="#l17.518"></a><span id="l17.518" class="difflineplus">+        if (next[len] == 0)</span>
<a href="#l17.519"></a><span id="l17.519" class="difflineplus">+            break;</span>
<a href="#l17.520"></a><span id="l17.520" class="difflineplus">+#  else</span>
<a href="#l17.521"></a><span id="l17.521" class="difflineplus">+    len = sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11,</span>
<a href="#l17.522"></a><span id="l17.522" class="difflineplus">+                  a12, a13, a14, a15, a16, a17, a18, a19, a20);</span>
<a href="#l17.523"></a><span id="l17.523" class="difflineplus">+#  endif</span>
<a href="#l17.524"></a><span id="l17.524" class="difflineplus">+#else</span>
<a href="#l17.525"></a><span id="l17.525" class="difflineplus">+#  ifdef HAS_snprintf_void</span>
<a href="#l17.526"></a><span id="l17.526" class="difflineplus">+    snprintf(next, state-&gt;size, format, a1, a2, a3, a4, a5, a6, a7, a8, a9,</span>
<a href="#l17.527"></a><span id="l17.527" class="difflineplus">+             a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);</span>
<a href="#l17.528"></a><span id="l17.528" class="difflineplus">+    len = strlen(next);</span>
<a href="#l17.529"></a><span id="l17.529" class="difflineplus">+#  else</span>
<a href="#l17.530"></a><span id="l17.530" class="difflineplus">+    len = snprintf(next, state-&gt;size, format, a1, a2, a3, a4, a5, a6, a7, a8,</span>
<a href="#l17.531"></a><span id="l17.531" class="difflineplus">+                   a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);</span>
<a href="#l17.532"></a><span id="l17.532" class="difflineplus">+#  endif</span>
<a href="#l17.533"></a><span id="l17.533" class="difflineplus">+#endif</span>
<a href="#l17.534"></a><span id="l17.534" class="difflineplus">+</span>
<a href="#l17.535"></a><span id="l17.535" class="difflineplus">+    /* check that printf() results fit in buffer */</span>
<a href="#l17.536"></a><span id="l17.536" class="difflineplus">+    if (len == 0 || len &gt;= state-&gt;size || next[state-&gt;size - 1] != 0)</span>
<a href="#l17.537"></a><span id="l17.537" class="difflineplus">+        return 0;</span>
<a href="#l17.538"></a><span id="l17.538" class="difflineplus">+</span>
<a href="#l17.539"></a><span id="l17.539" class="difflineplus">+    /* update buffer and position, compress first half if past that */</span>
<a href="#l17.540"></a><span id="l17.540" class="difflineplus">+    strm-&gt;avail_in += len;</span>
<a href="#l17.541"></a><span id="l17.541" class="difflineplus">+    state-&gt;x.pos += len;</span>
<a href="#l17.542"></a><span id="l17.542" class="difflineplus">+    if (strm-&gt;avail_in &gt;= state-&gt;size) {</span>
<a href="#l17.543"></a><span id="l17.543" class="difflineplus">+        left = strm-&gt;avail_in - state-&gt;size;</span>
<a href="#l17.544"></a><span id="l17.544" class="difflineplus">+        strm-&gt;avail_in = state-&gt;size;</span>
<a href="#l17.545"></a><span id="l17.545" class="difflineplus">+        if (gz_comp(state, Z_NO_FLUSH) == -1)</span>
<a href="#l17.546"></a><span id="l17.546" class="difflineplus">+            return state-&gt;err;</span>
<a href="#l17.547"></a><span id="l17.547" class="difflineplus">+        memcpy(state-&gt;in, state-&gt;in + state-&gt;size, left);</span>
<a href="#l17.548"></a><span id="l17.548" class="difflineplus">+        strm-&gt;next_in = state-&gt;in;</span>
<a href="#l17.549"></a><span id="l17.549" class="difflineplus">+        strm-&gt;avail_in = left;</span>
<a href="#l17.550"></a><span id="l17.550" class="difflineplus">+    }</span>
<a href="#l17.551"></a><span id="l17.551" class="difflineplus">+    return (int)len;</span>
<a href="#l17.552"></a><span id="l17.552" class="difflineplus">+}</span>
<a href="#l17.553"></a><span id="l17.553" class="difflineplus">+</span>
<a href="#l17.554"></a><span id="l17.554" class="difflineplus">+#endif</span>
<a href="#l17.555"></a><span id="l17.555" class="difflineplus">+</span>
<a href="#l17.556"></a><span id="l17.556" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l17.557"></a><span id="l17.557" class="difflineplus">+int ZEXPORT gzflush(file, flush)</span>
<a href="#l17.558"></a><span id="l17.558" class="difflineplus">+    gzFile file;</span>
<a href="#l17.559"></a><span id="l17.559" class="difflineplus">+    int flush;</span>
<a href="#l17.560"></a><span id="l17.560" class="difflineplus">+{</span>
<a href="#l17.561"></a><span id="l17.561" class="difflineplus">+    gz_statep state;</span>
<a href="#l17.562"></a><span id="l17.562" class="difflineplus">+</span>
<a href="#l17.563"></a><span id="l17.563" class="difflineplus">+    /* get internal structure */</span>
<a href="#l17.564"></a><span id="l17.564" class="difflineplus">+    if (file == NULL)</span>
<a href="#l17.565"></a><span id="l17.565" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l17.566"></a><span id="l17.566" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l17.567"></a><span id="l17.567" class="difflineplus">+</span>
<a href="#l17.568"></a><span id="l17.568" class="difflineplus">+    /* check that we're writing and that there's no error */</span>
<a href="#l17.569"></a><span id="l17.569" class="difflineplus">+    if (state-&gt;mode != GZ_WRITE || state-&gt;err != Z_OK)</span>
<a href="#l17.570"></a><span id="l17.570" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l17.571"></a><span id="l17.571" class="difflineplus">+</span>
<a href="#l17.572"></a><span id="l17.572" class="difflineplus">+    /* check flush parameter */</span>
<a href="#l17.573"></a><span id="l17.573" class="difflineplus">+    if (flush &lt; 0 || flush &gt; Z_FINISH)</span>
<a href="#l17.574"></a><span id="l17.574" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l17.575"></a><span id="l17.575" class="difflineplus">+</span>
<a href="#l17.576"></a><span id="l17.576" class="difflineplus">+    /* check for seek request */</span>
<a href="#l17.577"></a><span id="l17.577" class="difflineplus">+    if (state-&gt;seek) {</span>
<a href="#l17.578"></a><span id="l17.578" class="difflineplus">+        state-&gt;seek = 0;</span>
<a href="#l17.579"></a><span id="l17.579" class="difflineplus">+        if (gz_zero(state, state-&gt;skip) == -1)</span>
<a href="#l17.580"></a><span id="l17.580" class="difflineplus">+            return state-&gt;err;</span>
<a href="#l17.581"></a><span id="l17.581" class="difflineplus">+    }</span>
<a href="#l17.582"></a><span id="l17.582" class="difflineplus">+</span>
<a href="#l17.583"></a><span id="l17.583" class="difflineplus">+    /* compress remaining data with requested flush */</span>
<a href="#l17.584"></a><span id="l17.584" class="difflineplus">+    (void)gz_comp(state, flush);</span>
<a href="#l17.585"></a><span id="l17.585" class="difflineplus">+    return state-&gt;err;</span>
<a href="#l17.586"></a><span id="l17.586" class="difflineplus">+}</span>
<a href="#l17.587"></a><span id="l17.587" class="difflineplus">+</span>
<a href="#l17.588"></a><span id="l17.588" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l17.589"></a><span id="l17.589" class="difflineplus">+int ZEXPORT gzsetparams(file, level, strategy)</span>
<a href="#l17.590"></a><span id="l17.590" class="difflineplus">+    gzFile file;</span>
<a href="#l17.591"></a><span id="l17.591" class="difflineplus">+    int level;</span>
<a href="#l17.592"></a><span id="l17.592" class="difflineplus">+    int strategy;</span>
<a href="#l17.593"></a><span id="l17.593" class="difflineplus">+{</span>
<a href="#l17.594"></a><span id="l17.594" class="difflineplus">+    gz_statep state;</span>
<a href="#l17.595"></a><span id="l17.595" class="difflineplus">+    z_streamp strm;</span>
<a href="#l17.596"></a><span id="l17.596" class="difflineplus">+</span>
<a href="#l17.597"></a><span id="l17.597" class="difflineplus">+    /* get internal structure */</span>
<a href="#l17.598"></a><span id="l17.598" class="difflineplus">+    if (file == NULL)</span>
<a href="#l17.599"></a><span id="l17.599" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l17.600"></a><span id="l17.600" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l17.601"></a><span id="l17.601" class="difflineplus">+    strm = &amp;(state-&gt;strm);</span>
<a href="#l17.602"></a><span id="l17.602" class="difflineplus">+</span>
<a href="#l17.603"></a><span id="l17.603" class="difflineplus">+    /* check that we're writing and that there's no error */</span>
<a href="#l17.604"></a><span id="l17.604" class="difflineplus">+    if (state-&gt;mode != GZ_WRITE || state-&gt;err != Z_OK)</span>
<a href="#l17.605"></a><span id="l17.605" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l17.606"></a><span id="l17.606" class="difflineplus">+</span>
<a href="#l17.607"></a><span id="l17.607" class="difflineplus">+    /* if no change is requested, then do nothing */</span>
<a href="#l17.608"></a><span id="l17.608" class="difflineplus">+    if (level == state-&gt;level &amp;&amp; strategy == state-&gt;strategy)</span>
<a href="#l17.609"></a><span id="l17.609" class="difflineplus">+        return Z_OK;</span>
<a href="#l17.610"></a><span id="l17.610" class="difflineplus">+</span>
<a href="#l17.611"></a><span id="l17.611" class="difflineplus">+    /* check for seek request */</span>
<a href="#l17.612"></a><span id="l17.612" class="difflineplus">+    if (state-&gt;seek) {</span>
<a href="#l17.613"></a><span id="l17.613" class="difflineplus">+        state-&gt;seek = 0;</span>
<a href="#l17.614"></a><span id="l17.614" class="difflineplus">+        if (gz_zero(state, state-&gt;skip) == -1)</span>
<a href="#l17.615"></a><span id="l17.615" class="difflineplus">+            return state-&gt;err;</span>
<a href="#l17.616"></a><span id="l17.616" class="difflineplus">+    }</span>
<a href="#l17.617"></a><span id="l17.617" class="difflineplus">+</span>
<a href="#l17.618"></a><span id="l17.618" class="difflineplus">+    /* change compression parameters for subsequent input */</span>
<a href="#l17.619"></a><span id="l17.619" class="difflineplus">+    if (state-&gt;size) {</span>
<a href="#l17.620"></a><span id="l17.620" class="difflineplus">+        /* flush previous input with previous parameters before changing */</span>
<a href="#l17.621"></a><span id="l17.621" class="difflineplus">+        if (strm-&gt;avail_in &amp;&amp; gz_comp(state, Z_BLOCK) == -1)</span>
<a href="#l17.622"></a><span id="l17.622" class="difflineplus">+            return state-&gt;err;</span>
<a href="#l17.623"></a><span id="l17.623" class="difflineplus">+        deflateParams(strm, level, strategy);</span>
<a href="#l17.624"></a><span id="l17.624" class="difflineplus">+    }</span>
<a href="#l17.625"></a><span id="l17.625" class="difflineplus">+    state-&gt;level = level;</span>
<a href="#l17.626"></a><span id="l17.626" class="difflineplus">+    state-&gt;strategy = strategy;</span>
<a href="#l17.627"></a><span id="l17.627" class="difflineplus">+    return Z_OK;</span>
<a href="#l17.628"></a><span id="l17.628" class="difflineplus">+}</span>
<a href="#l17.629"></a><span id="l17.629" class="difflineplus">+</span>
<a href="#l17.630"></a><span id="l17.630" class="difflineplus">+/* -- see zlib.h -- */</span>
<a href="#l17.631"></a><span id="l17.631" class="difflineplus">+int ZEXPORT gzclose_w(file)</span>
<a href="#l17.632"></a><span id="l17.632" class="difflineplus">+    gzFile file;</span>
<a href="#l17.633"></a><span id="l17.633" class="difflineplus">+{</span>
<a href="#l17.634"></a><span id="l17.634" class="difflineplus">+    int ret = Z_OK;</span>
<a href="#l17.635"></a><span id="l17.635" class="difflineplus">+    gz_statep state;</span>
<a href="#l17.636"></a><span id="l17.636" class="difflineplus">+</span>
<a href="#l17.637"></a><span id="l17.637" class="difflineplus">+    /* get internal structure */</span>
<a href="#l17.638"></a><span id="l17.638" class="difflineplus">+    if (file == NULL)</span>
<a href="#l17.639"></a><span id="l17.639" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l17.640"></a><span id="l17.640" class="difflineplus">+    state = (gz_statep)file;</span>
<a href="#l17.641"></a><span id="l17.641" class="difflineplus">+</span>
<a href="#l17.642"></a><span id="l17.642" class="difflineplus">+    /* check that we're writing */</span>
<a href="#l17.643"></a><span id="l17.643" class="difflineplus">+    if (state-&gt;mode != GZ_WRITE)</span>
<a href="#l17.644"></a><span id="l17.644" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l17.645"></a><span id="l17.645" class="difflineplus">+</span>
<a href="#l17.646"></a><span id="l17.646" class="difflineplus">+    /* check for seek request */</span>
<a href="#l17.647"></a><span id="l17.647" class="difflineplus">+    if (state-&gt;seek) {</span>
<a href="#l17.648"></a><span id="l17.648" class="difflineplus">+        state-&gt;seek = 0;</span>
<a href="#l17.649"></a><span id="l17.649" class="difflineplus">+        if (gz_zero(state, state-&gt;skip) == -1)</span>
<a href="#l17.650"></a><span id="l17.650" class="difflineplus">+            ret = state-&gt;err;</span>
<a href="#l17.651"></a><span id="l17.651" class="difflineplus">+    }</span>
<a href="#l17.652"></a><span id="l17.652" class="difflineplus">+</span>
<a href="#l17.653"></a><span id="l17.653" class="difflineplus">+    /* flush, free memory, and close file */</span>
<a href="#l17.654"></a><span id="l17.654" class="difflineplus">+    if (gz_comp(state, Z_FINISH) == -1)</span>
<a href="#l17.655"></a><span id="l17.655" class="difflineplus">+        ret = state-&gt;err;</span>
<a href="#l17.656"></a><span id="l17.656" class="difflineplus">+    if (state-&gt;size) {</span>
<a href="#l17.657"></a><span id="l17.657" class="difflineplus">+        if (!state-&gt;direct) {</span>
<a href="#l17.658"></a><span id="l17.658" class="difflineplus">+            (void)deflateEnd(&amp;(state-&gt;strm));</span>
<a href="#l17.659"></a><span id="l17.659" class="difflineplus">+            free(state-&gt;out);</span>
<a href="#l17.660"></a><span id="l17.660" class="difflineplus">+        }</span>
<a href="#l17.661"></a><span id="l17.661" class="difflineplus">+        free(state-&gt;in);</span>
<a href="#l17.662"></a><span id="l17.662" class="difflineplus">+    }</span>
<a href="#l17.663"></a><span id="l17.663" class="difflineplus">+    gz_error(state, Z_OK, NULL);</span>
<a href="#l17.664"></a><span id="l17.664" class="difflineplus">+    free(state-&gt;path);</span>
<a href="#l17.665"></a><span id="l17.665" class="difflineplus">+    if (close(state-&gt;fd) == -1)</span>
<a href="#l17.666"></a><span id="l17.666" class="difflineplus">+        ret = Z_ERRNO;</span>
<a href="#l17.667"></a><span id="l17.667" class="difflineplus">+    free(state);</span>
<a href="#l17.668"></a><span id="l17.668" class="difflineplus">+    return ret;</span>
<a href="#l17.669"></a><span id="l17.669" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1">new file mode 100644</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineminus">--- /dev/null</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineplus">+++ b/third_party/zlib/infback.c</span>
<a href="#l18.4"></a><span id="l18.4" class="difflineat">@@ -0,0 +1,640 @@</span>
<a href="#l18.5"></a><span id="l18.5" class="difflineplus">+/* infback.c -- inflate using a call-back interface</span>
<a href="#l18.6"></a><span id="l18.6" class="difflineplus">+ * Copyright (C) 1995-2016 Mark Adler</span>
<a href="#l18.7"></a><span id="l18.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l18.8"></a><span id="l18.8" class="difflineplus">+ */</span>
<a href="#l18.9"></a><span id="l18.9" class="difflineplus">+</span>
<a href="#l18.10"></a><span id="l18.10" class="difflineplus">+/*</span>
<a href="#l18.11"></a><span id="l18.11" class="difflineplus">+   This code is largely copied from inflate.c.  Normally either infback.o or</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineplus">+   inflate.o would be linked into an application--not both.  The interface</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+   with inffast.c is retained so that optimized assembler-coded versions of</span>
<a href="#l18.14"></a><span id="l18.14" class="difflineplus">+   inflate_fast() can be used with either inflate.c or infback.c.</span>
<a href="#l18.15"></a><span id="l18.15" class="difflineplus">+ */</span>
<a href="#l18.16"></a><span id="l18.16" class="difflineplus">+</span>
<a href="#l18.17"></a><span id="l18.17" class="difflineplus">+#include &quot;zutil.h&quot;</span>
<a href="#l18.18"></a><span id="l18.18" class="difflineplus">+#include &quot;inftrees.h&quot;</span>
<a href="#l18.19"></a><span id="l18.19" class="difflineplus">+#include &quot;inflate.h&quot;</span>
<a href="#l18.20"></a><span id="l18.20" class="difflineplus">+#include &quot;inffast.h&quot;</span>
<a href="#l18.21"></a><span id="l18.21" class="difflineplus">+</span>
<a href="#l18.22"></a><span id="l18.22" class="difflineplus">+/* function prototypes */</span>
<a href="#l18.23"></a><span id="l18.23" class="difflineplus">+local void fixedtables OF((struct inflate_state FAR *state));</span>
<a href="#l18.24"></a><span id="l18.24" class="difflineplus">+</span>
<a href="#l18.25"></a><span id="l18.25" class="difflineplus">+/*</span>
<a href="#l18.26"></a><span id="l18.26" class="difflineplus">+   strm provides memory allocation functions in zalloc and zfree, or</span>
<a href="#l18.27"></a><span id="l18.27" class="difflineplus">+   Z_NULL to use the library memory allocation functions.</span>
<a href="#l18.28"></a><span id="l18.28" class="difflineplus">+</span>
<a href="#l18.29"></a><span id="l18.29" class="difflineplus">+   windowBits is in the range 8..15, and window is a user-supplied</span>
<a href="#l18.30"></a><span id="l18.30" class="difflineplus">+   window and output buffer that is 2**windowBits bytes.</span>
<a href="#l18.31"></a><span id="l18.31" class="difflineplus">+ */</span>
<a href="#l18.32"></a><span id="l18.32" class="difflineplus">+int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)</span>
<a href="#l18.33"></a><span id="l18.33" class="difflineplus">+z_streamp strm;</span>
<a href="#l18.34"></a><span id="l18.34" class="difflineplus">+int windowBits;</span>
<a href="#l18.35"></a><span id="l18.35" class="difflineplus">+unsigned char FAR *window;</span>
<a href="#l18.36"></a><span id="l18.36" class="difflineplus">+const char *version;</span>
<a href="#l18.37"></a><span id="l18.37" class="difflineplus">+int stream_size;</span>
<a href="#l18.38"></a><span id="l18.38" class="difflineplus">+{</span>
<a href="#l18.39"></a><span id="l18.39" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l18.40"></a><span id="l18.40" class="difflineplus">+</span>
<a href="#l18.41"></a><span id="l18.41" class="difflineplus">+    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||</span>
<a href="#l18.42"></a><span id="l18.42" class="difflineplus">+        stream_size != (int)(sizeof(z_stream)))</span>
<a href="#l18.43"></a><span id="l18.43" class="difflineplus">+        return Z_VERSION_ERROR;</span>
<a href="#l18.44"></a><span id="l18.44" class="difflineplus">+    if (strm == Z_NULL || window == Z_NULL ||</span>
<a href="#l18.45"></a><span id="l18.45" class="difflineplus">+        windowBits &lt; 8 || windowBits &gt; 15)</span>
<a href="#l18.46"></a><span id="l18.46" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l18.47"></a><span id="l18.47" class="difflineplus">+    strm-&gt;msg = Z_NULL;                 /* in case we return an error */</span>
<a href="#l18.48"></a><span id="l18.48" class="difflineplus">+    if (strm-&gt;zalloc == (alloc_func)0) {</span>
<a href="#l18.49"></a><span id="l18.49" class="difflineplus">+#ifdef Z_SOLO</span>
<a href="#l18.50"></a><span id="l18.50" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l18.51"></a><span id="l18.51" class="difflineplus">+#else</span>
<a href="#l18.52"></a><span id="l18.52" class="difflineplus">+        strm-&gt;zalloc = zcalloc;</span>
<a href="#l18.53"></a><span id="l18.53" class="difflineplus">+        strm-&gt;opaque = (voidpf)0;</span>
<a href="#l18.54"></a><span id="l18.54" class="difflineplus">+#endif</span>
<a href="#l18.55"></a><span id="l18.55" class="difflineplus">+    }</span>
<a href="#l18.56"></a><span id="l18.56" class="difflineplus">+    if (strm-&gt;zfree == (free_func)0)</span>
<a href="#l18.57"></a><span id="l18.57" class="difflineplus">+#ifdef Z_SOLO</span>
<a href="#l18.58"></a><span id="l18.58" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l18.59"></a><span id="l18.59" class="difflineplus">+#else</span>
<a href="#l18.60"></a><span id="l18.60" class="difflineplus">+    strm-&gt;zfree = zcfree;</span>
<a href="#l18.61"></a><span id="l18.61" class="difflineplus">+#endif</span>
<a href="#l18.62"></a><span id="l18.62" class="difflineplus">+    state = (struct inflate_state FAR *)ZALLOC(strm, 1,</span>
<a href="#l18.63"></a><span id="l18.63" class="difflineplus">+                                               sizeof(struct inflate_state));</span>
<a href="#l18.64"></a><span id="l18.64" class="difflineplus">+    if (state == Z_NULL) return Z_MEM_ERROR;</span>
<a href="#l18.65"></a><span id="l18.65" class="difflineplus">+    Tracev((stderr, &quot;inflate: allocated\n&quot;));</span>
<a href="#l18.66"></a><span id="l18.66" class="difflineplus">+    strm-&gt;state = (struct internal_state FAR *)state;</span>
<a href="#l18.67"></a><span id="l18.67" class="difflineplus">+    state-&gt;dmax = 32768U;</span>
<a href="#l18.68"></a><span id="l18.68" class="difflineplus">+    state-&gt;wbits = (uInt)windowBits;</span>
<a href="#l18.69"></a><span id="l18.69" class="difflineplus">+    state-&gt;wsize = 1U &lt;&lt; windowBits;</span>
<a href="#l18.70"></a><span id="l18.70" class="difflineplus">+    state-&gt;window = window;</span>
<a href="#l18.71"></a><span id="l18.71" class="difflineplus">+    state-&gt;wnext = 0;</span>
<a href="#l18.72"></a><span id="l18.72" class="difflineplus">+    state-&gt;whave = 0;</span>
<a href="#l18.73"></a><span id="l18.73" class="difflineplus">+    return Z_OK;</span>
<a href="#l18.74"></a><span id="l18.74" class="difflineplus">+}</span>
<a href="#l18.75"></a><span id="l18.75" class="difflineplus">+</span>
<a href="#l18.76"></a><span id="l18.76" class="difflineplus">+/*</span>
<a href="#l18.77"></a><span id="l18.77" class="difflineplus">+   Return state with length and distance decoding tables and index sizes set to</span>
<a href="#l18.78"></a><span id="l18.78" class="difflineplus">+   fixed code decoding.  Normally this returns fixed tables from inffixed.h.</span>
<a href="#l18.79"></a><span id="l18.79" class="difflineplus">+   If BUILDFIXED is defined, then instead this routine builds the tables the</span>
<a href="#l18.80"></a><span id="l18.80" class="difflineplus">+   first time it's called, and returns those tables the first time and</span>
<a href="#l18.81"></a><span id="l18.81" class="difflineplus">+   thereafter.  This reduces the size of the code by about 2K bytes, in</span>
<a href="#l18.82"></a><span id="l18.82" class="difflineplus">+   exchange for a little execution time.  However, BUILDFIXED should not be</span>
<a href="#l18.83"></a><span id="l18.83" class="difflineplus">+   used for threaded applications, since the rewriting of the tables and virgin</span>
<a href="#l18.84"></a><span id="l18.84" class="difflineplus">+   may not be thread-safe.</span>
<a href="#l18.85"></a><span id="l18.85" class="difflineplus">+ */</span>
<a href="#l18.86"></a><span id="l18.86" class="difflineplus">+local void fixedtables(state)</span>
<a href="#l18.87"></a><span id="l18.87" class="difflineplus">+struct inflate_state FAR *state;</span>
<a href="#l18.88"></a><span id="l18.88" class="difflineplus">+{</span>
<a href="#l18.89"></a><span id="l18.89" class="difflineplus">+#ifdef BUILDFIXED</span>
<a href="#l18.90"></a><span id="l18.90" class="difflineplus">+    static int virgin = 1;</span>
<a href="#l18.91"></a><span id="l18.91" class="difflineplus">+    static code *lenfix, *distfix;</span>
<a href="#l18.92"></a><span id="l18.92" class="difflineplus">+    static code fixed[544];</span>
<a href="#l18.93"></a><span id="l18.93" class="difflineplus">+</span>
<a href="#l18.94"></a><span id="l18.94" class="difflineplus">+    /* build fixed huffman tables if first call (may not be thread safe) */</span>
<a href="#l18.95"></a><span id="l18.95" class="difflineplus">+    if (virgin) {</span>
<a href="#l18.96"></a><span id="l18.96" class="difflineplus">+        unsigned sym, bits;</span>
<a href="#l18.97"></a><span id="l18.97" class="difflineplus">+        static code *next;</span>
<a href="#l18.98"></a><span id="l18.98" class="difflineplus">+</span>
<a href="#l18.99"></a><span id="l18.99" class="difflineplus">+        /* literal/length table */</span>
<a href="#l18.100"></a><span id="l18.100" class="difflineplus">+        sym = 0;</span>
<a href="#l18.101"></a><span id="l18.101" class="difflineplus">+        while (sym &lt; 144) state-&gt;lens[sym++] = 8;</span>
<a href="#l18.102"></a><span id="l18.102" class="difflineplus">+        while (sym &lt; 256) state-&gt;lens[sym++] = 9;</span>
<a href="#l18.103"></a><span id="l18.103" class="difflineplus">+        while (sym &lt; 280) state-&gt;lens[sym++] = 7;</span>
<a href="#l18.104"></a><span id="l18.104" class="difflineplus">+        while (sym &lt; 288) state-&gt;lens[sym++] = 8;</span>
<a href="#l18.105"></a><span id="l18.105" class="difflineplus">+        next = fixed;</span>
<a href="#l18.106"></a><span id="l18.106" class="difflineplus">+        lenfix = next;</span>
<a href="#l18.107"></a><span id="l18.107" class="difflineplus">+        bits = 9;</span>
<a href="#l18.108"></a><span id="l18.108" class="difflineplus">+        inflate_table(LENS, state-&gt;lens, 288, &amp;(next), &amp;(bits), state-&gt;work);</span>
<a href="#l18.109"></a><span id="l18.109" class="difflineplus">+</span>
<a href="#l18.110"></a><span id="l18.110" class="difflineplus">+        /* distance table */</span>
<a href="#l18.111"></a><span id="l18.111" class="difflineplus">+        sym = 0;</span>
<a href="#l18.112"></a><span id="l18.112" class="difflineplus">+        while (sym &lt; 32) state-&gt;lens[sym++] = 5;</span>
<a href="#l18.113"></a><span id="l18.113" class="difflineplus">+        distfix = next;</span>
<a href="#l18.114"></a><span id="l18.114" class="difflineplus">+        bits = 5;</span>
<a href="#l18.115"></a><span id="l18.115" class="difflineplus">+        inflate_table(DISTS, state-&gt;lens, 32, &amp;(next), &amp;(bits), state-&gt;work);</span>
<a href="#l18.116"></a><span id="l18.116" class="difflineplus">+</span>
<a href="#l18.117"></a><span id="l18.117" class="difflineplus">+        /* do this just once */</span>
<a href="#l18.118"></a><span id="l18.118" class="difflineplus">+        virgin = 0;</span>
<a href="#l18.119"></a><span id="l18.119" class="difflineplus">+    }</span>
<a href="#l18.120"></a><span id="l18.120" class="difflineplus">+#else /* !BUILDFIXED */</span>
<a href="#l18.121"></a><span id="l18.121" class="difflineplus">+#   include &quot;inffixed.h&quot;</span>
<a href="#l18.122"></a><span id="l18.122" class="difflineplus">+#endif /* BUILDFIXED */</span>
<a href="#l18.123"></a><span id="l18.123" class="difflineplus">+    state-&gt;lencode = lenfix;</span>
<a href="#l18.124"></a><span id="l18.124" class="difflineplus">+    state-&gt;lenbits = 9;</span>
<a href="#l18.125"></a><span id="l18.125" class="difflineplus">+    state-&gt;distcode = distfix;</span>
<a href="#l18.126"></a><span id="l18.126" class="difflineplus">+    state-&gt;distbits = 5;</span>
<a href="#l18.127"></a><span id="l18.127" class="difflineplus">+}</span>
<a href="#l18.128"></a><span id="l18.128" class="difflineplus">+</span>
<a href="#l18.129"></a><span id="l18.129" class="difflineplus">+/* Macros for inflateBack(): */</span>
<a href="#l18.130"></a><span id="l18.130" class="difflineplus">+</span>
<a href="#l18.131"></a><span id="l18.131" class="difflineplus">+/* Load returned state from inflate_fast() */</span>
<a href="#l18.132"></a><span id="l18.132" class="difflineplus">+#define LOAD() \</span>
<a href="#l18.133"></a><span id="l18.133" class="difflineplus">+    do { \</span>
<a href="#l18.134"></a><span id="l18.134" class="difflineplus">+        put = strm-&gt;next_out; \</span>
<a href="#l18.135"></a><span id="l18.135" class="difflineplus">+        left = strm-&gt;avail_out; \</span>
<a href="#l18.136"></a><span id="l18.136" class="difflineplus">+        next = strm-&gt;next_in; \</span>
<a href="#l18.137"></a><span id="l18.137" class="difflineplus">+        have = strm-&gt;avail_in; \</span>
<a href="#l18.138"></a><span id="l18.138" class="difflineplus">+        hold = state-&gt;hold; \</span>
<a href="#l18.139"></a><span id="l18.139" class="difflineplus">+        bits = state-&gt;bits; \</span>
<a href="#l18.140"></a><span id="l18.140" class="difflineplus">+    } while (0)</span>
<a href="#l18.141"></a><span id="l18.141" class="difflineplus">+</span>
<a href="#l18.142"></a><span id="l18.142" class="difflineplus">+/* Set state from registers for inflate_fast() */</span>
<a href="#l18.143"></a><span id="l18.143" class="difflineplus">+#define RESTORE() \</span>
<a href="#l18.144"></a><span id="l18.144" class="difflineplus">+    do { \</span>
<a href="#l18.145"></a><span id="l18.145" class="difflineplus">+        strm-&gt;next_out = put; \</span>
<a href="#l18.146"></a><span id="l18.146" class="difflineplus">+        strm-&gt;avail_out = left; \</span>
<a href="#l18.147"></a><span id="l18.147" class="difflineplus">+        strm-&gt;next_in = next; \</span>
<a href="#l18.148"></a><span id="l18.148" class="difflineplus">+        strm-&gt;avail_in = have; \</span>
<a href="#l18.149"></a><span id="l18.149" class="difflineplus">+        state-&gt;hold = hold; \</span>
<a href="#l18.150"></a><span id="l18.150" class="difflineplus">+        state-&gt;bits = bits; \</span>
<a href="#l18.151"></a><span id="l18.151" class="difflineplus">+    } while (0)</span>
<a href="#l18.152"></a><span id="l18.152" class="difflineplus">+</span>
<a href="#l18.153"></a><span id="l18.153" class="difflineplus">+/* Clear the input bit accumulator */</span>
<a href="#l18.154"></a><span id="l18.154" class="difflineplus">+#define INITBITS() \</span>
<a href="#l18.155"></a><span id="l18.155" class="difflineplus">+    do { \</span>
<a href="#l18.156"></a><span id="l18.156" class="difflineplus">+        hold = 0; \</span>
<a href="#l18.157"></a><span id="l18.157" class="difflineplus">+        bits = 0; \</span>
<a href="#l18.158"></a><span id="l18.158" class="difflineplus">+    } while (0)</span>
<a href="#l18.159"></a><span id="l18.159" class="difflineplus">+</span>
<a href="#l18.160"></a><span id="l18.160" class="difflineplus">+/* Assure that some input is available.  If input is requested, but denied,</span>
<a href="#l18.161"></a><span id="l18.161" class="difflineplus">+   then return a Z_BUF_ERROR from inflateBack(). */</span>
<a href="#l18.162"></a><span id="l18.162" class="difflineplus">+#define PULL() \</span>
<a href="#l18.163"></a><span id="l18.163" class="difflineplus">+    do { \</span>
<a href="#l18.164"></a><span id="l18.164" class="difflineplus">+        if (have == 0) { \</span>
<a href="#l18.165"></a><span id="l18.165" class="difflineplus">+            have = in(in_desc, &amp;next); \</span>
<a href="#l18.166"></a><span id="l18.166" class="difflineplus">+            if (have == 0) { \</span>
<a href="#l18.167"></a><span id="l18.167" class="difflineplus">+                next = Z_NULL; \</span>
<a href="#l18.168"></a><span id="l18.168" class="difflineplus">+                ret = Z_BUF_ERROR; \</span>
<a href="#l18.169"></a><span id="l18.169" class="difflineplus">+                goto inf_leave; \</span>
<a href="#l18.170"></a><span id="l18.170" class="difflineplus">+            } \</span>
<a href="#l18.171"></a><span id="l18.171" class="difflineplus">+        } \</span>
<a href="#l18.172"></a><span id="l18.172" class="difflineplus">+    } while (0)</span>
<a href="#l18.173"></a><span id="l18.173" class="difflineplus">+</span>
<a href="#l18.174"></a><span id="l18.174" class="difflineplus">+/* Get a byte of input into the bit accumulator, or return from inflateBack()</span>
<a href="#l18.175"></a><span id="l18.175" class="difflineplus">+   with an error if there is no input available. */</span>
<a href="#l18.176"></a><span id="l18.176" class="difflineplus">+#define PULLBYTE() \</span>
<a href="#l18.177"></a><span id="l18.177" class="difflineplus">+    do { \</span>
<a href="#l18.178"></a><span id="l18.178" class="difflineplus">+        PULL(); \</span>
<a href="#l18.179"></a><span id="l18.179" class="difflineplus">+        have--; \</span>
<a href="#l18.180"></a><span id="l18.180" class="difflineplus">+        hold += (unsigned long)(*next++) &lt;&lt; bits; \</span>
<a href="#l18.181"></a><span id="l18.181" class="difflineplus">+        bits += 8; \</span>
<a href="#l18.182"></a><span id="l18.182" class="difflineplus">+    } while (0)</span>
<a href="#l18.183"></a><span id="l18.183" class="difflineplus">+</span>
<a href="#l18.184"></a><span id="l18.184" class="difflineplus">+/* Assure that there are at least n bits in the bit accumulator.  If there is</span>
<a href="#l18.185"></a><span id="l18.185" class="difflineplus">+   not enough available input to do that, then return from inflateBack() with</span>
<a href="#l18.186"></a><span id="l18.186" class="difflineplus">+   an error. */</span>
<a href="#l18.187"></a><span id="l18.187" class="difflineplus">+#define NEEDBITS(n) \</span>
<a href="#l18.188"></a><span id="l18.188" class="difflineplus">+    do { \</span>
<a href="#l18.189"></a><span id="l18.189" class="difflineplus">+        while (bits &lt; (unsigned)(n)) \</span>
<a href="#l18.190"></a><span id="l18.190" class="difflineplus">+            PULLBYTE(); \</span>
<a href="#l18.191"></a><span id="l18.191" class="difflineplus">+    } while (0)</span>
<a href="#l18.192"></a><span id="l18.192" class="difflineplus">+</span>
<a href="#l18.193"></a><span id="l18.193" class="difflineplus">+/* Return the low n bits of the bit accumulator (n &lt; 16) */</span>
<a href="#l18.194"></a><span id="l18.194" class="difflineplus">+#define BITS(n) \</span>
<a href="#l18.195"></a><span id="l18.195" class="difflineplus">+    ((unsigned)hold &amp; ((1U &lt;&lt; (n)) - 1))</span>
<a href="#l18.196"></a><span id="l18.196" class="difflineplus">+</span>
<a href="#l18.197"></a><span id="l18.197" class="difflineplus">+/* Remove n bits from the bit accumulator */</span>
<a href="#l18.198"></a><span id="l18.198" class="difflineplus">+#define DROPBITS(n) \</span>
<a href="#l18.199"></a><span id="l18.199" class="difflineplus">+    do { \</span>
<a href="#l18.200"></a><span id="l18.200" class="difflineplus">+        hold &gt;&gt;= (n); \</span>
<a href="#l18.201"></a><span id="l18.201" class="difflineplus">+        bits -= (unsigned)(n); \</span>
<a href="#l18.202"></a><span id="l18.202" class="difflineplus">+    } while (0)</span>
<a href="#l18.203"></a><span id="l18.203" class="difflineplus">+</span>
<a href="#l18.204"></a><span id="l18.204" class="difflineplus">+/* Remove zero to seven bits as needed to go to a byte boundary */</span>
<a href="#l18.205"></a><span id="l18.205" class="difflineplus">+#define BYTEBITS() \</span>
<a href="#l18.206"></a><span id="l18.206" class="difflineplus">+    do { \</span>
<a href="#l18.207"></a><span id="l18.207" class="difflineplus">+        hold &gt;&gt;= bits &amp; 7; \</span>
<a href="#l18.208"></a><span id="l18.208" class="difflineplus">+        bits -= bits &amp; 7; \</span>
<a href="#l18.209"></a><span id="l18.209" class="difflineplus">+    } while (0)</span>
<a href="#l18.210"></a><span id="l18.210" class="difflineplus">+</span>
<a href="#l18.211"></a><span id="l18.211" class="difflineplus">+/* Assure that some output space is available, by writing out the window</span>
<a href="#l18.212"></a><span id="l18.212" class="difflineplus">+   if it's full.  If the write fails, return from inflateBack() with a</span>
<a href="#l18.213"></a><span id="l18.213" class="difflineplus">+   Z_BUF_ERROR. */</span>
<a href="#l18.214"></a><span id="l18.214" class="difflineplus">+#define ROOM() \</span>
<a href="#l18.215"></a><span id="l18.215" class="difflineplus">+    do { \</span>
<a href="#l18.216"></a><span id="l18.216" class="difflineplus">+        if (left == 0) { \</span>
<a href="#l18.217"></a><span id="l18.217" class="difflineplus">+            put = state-&gt;window; \</span>
<a href="#l18.218"></a><span id="l18.218" class="difflineplus">+            left = state-&gt;wsize; \</span>
<a href="#l18.219"></a><span id="l18.219" class="difflineplus">+            state-&gt;whave = left; \</span>
<a href="#l18.220"></a><span id="l18.220" class="difflineplus">+            if (out(out_desc, put, left)) { \</span>
<a href="#l18.221"></a><span id="l18.221" class="difflineplus">+                ret = Z_BUF_ERROR; \</span>
<a href="#l18.222"></a><span id="l18.222" class="difflineplus">+                goto inf_leave; \</span>
<a href="#l18.223"></a><span id="l18.223" class="difflineplus">+            } \</span>
<a href="#l18.224"></a><span id="l18.224" class="difflineplus">+        } \</span>
<a href="#l18.225"></a><span id="l18.225" class="difflineplus">+    } while (0)</span>
<a href="#l18.226"></a><span id="l18.226" class="difflineplus">+</span>
<a href="#l18.227"></a><span id="l18.227" class="difflineplus">+/*</span>
<a href="#l18.228"></a><span id="l18.228" class="difflineplus">+   strm provides the memory allocation functions and window buffer on input,</span>
<a href="#l18.229"></a><span id="l18.229" class="difflineplus">+   and provides information on the unused input on return.  For Z_DATA_ERROR</span>
<a href="#l18.230"></a><span id="l18.230" class="difflineplus">+   returns, strm will also provide an error message.</span>
<a href="#l18.231"></a><span id="l18.231" class="difflineplus">+</span>
<a href="#l18.232"></a><span id="l18.232" class="difflineplus">+   in() and out() are the call-back input and output functions.  When</span>
<a href="#l18.233"></a><span id="l18.233" class="difflineplus">+   inflateBack() needs more input, it calls in().  When inflateBack() has</span>
<a href="#l18.234"></a><span id="l18.234" class="difflineplus">+   filled the window with output, or when it completes with data in the</span>
<a href="#l18.235"></a><span id="l18.235" class="difflineplus">+   window, it calls out() to write out the data.  The application must not</span>
<a href="#l18.236"></a><span id="l18.236" class="difflineplus">+   change the provided input until in() is called again or inflateBack()</span>
<a href="#l18.237"></a><span id="l18.237" class="difflineplus">+   returns.  The application must not change the window/output buffer until</span>
<a href="#l18.238"></a><span id="l18.238" class="difflineplus">+   inflateBack() returns.</span>
<a href="#l18.239"></a><span id="l18.239" class="difflineplus">+</span>
<a href="#l18.240"></a><span id="l18.240" class="difflineplus">+   in() and out() are called with a descriptor parameter provided in the</span>
<a href="#l18.241"></a><span id="l18.241" class="difflineplus">+   inflateBack() call.  This parameter can be a structure that provides the</span>
<a href="#l18.242"></a><span id="l18.242" class="difflineplus">+   information required to do the read or write, as well as accumulated</span>
<a href="#l18.243"></a><span id="l18.243" class="difflineplus">+   information on the input and output such as totals and check values.</span>
<a href="#l18.244"></a><span id="l18.244" class="difflineplus">+</span>
<a href="#l18.245"></a><span id="l18.245" class="difflineplus">+   in() should return zero on failure.  out() should return non-zero on</span>
<a href="#l18.246"></a><span id="l18.246" class="difflineplus">+   failure.  If either in() or out() fails, than inflateBack() returns a</span>
<a href="#l18.247"></a><span id="l18.247" class="difflineplus">+   Z_BUF_ERROR.  strm-&gt;next_in can be checked for Z_NULL to see whether it</span>
<a href="#l18.248"></a><span id="l18.248" class="difflineplus">+   was in() or out() that caused in the error.  Otherwise,  inflateBack()</span>
<a href="#l18.249"></a><span id="l18.249" class="difflineplus">+   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format</span>
<a href="#l18.250"></a><span id="l18.250" class="difflineplus">+   error, or Z_MEM_ERROR if it could not allocate memory for the state.</span>
<a href="#l18.251"></a><span id="l18.251" class="difflineplus">+   inflateBack() can also return Z_STREAM_ERROR if the input parameters</span>
<a href="#l18.252"></a><span id="l18.252" class="difflineplus">+   are not correct, i.e. strm is Z_NULL or the state was not initialized.</span>
<a href="#l18.253"></a><span id="l18.253" class="difflineplus">+ */</span>
<a href="#l18.254"></a><span id="l18.254" class="difflineplus">+int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)</span>
<a href="#l18.255"></a><span id="l18.255" class="difflineplus">+z_streamp strm;</span>
<a href="#l18.256"></a><span id="l18.256" class="difflineplus">+in_func in;</span>
<a href="#l18.257"></a><span id="l18.257" class="difflineplus">+void FAR *in_desc;</span>
<a href="#l18.258"></a><span id="l18.258" class="difflineplus">+out_func out;</span>
<a href="#l18.259"></a><span id="l18.259" class="difflineplus">+void FAR *out_desc;</span>
<a href="#l18.260"></a><span id="l18.260" class="difflineplus">+{</span>
<a href="#l18.261"></a><span id="l18.261" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l18.262"></a><span id="l18.262" class="difflineplus">+    z_const unsigned char FAR *next;    /* next input */</span>
<a href="#l18.263"></a><span id="l18.263" class="difflineplus">+    unsigned char FAR *put;     /* next output */</span>
<a href="#l18.264"></a><span id="l18.264" class="difflineplus">+    unsigned have, left;        /* available input and output */</span>
<a href="#l18.265"></a><span id="l18.265" class="difflineplus">+    unsigned long hold;         /* bit buffer */</span>
<a href="#l18.266"></a><span id="l18.266" class="difflineplus">+    unsigned bits;              /* bits in bit buffer */</span>
<a href="#l18.267"></a><span id="l18.267" class="difflineplus">+    unsigned copy;              /* number of stored or match bytes to copy */</span>
<a href="#l18.268"></a><span id="l18.268" class="difflineplus">+    unsigned char FAR *from;    /* where to copy match bytes from */</span>
<a href="#l18.269"></a><span id="l18.269" class="difflineplus">+    code here;                  /* current decoding table entry */</span>
<a href="#l18.270"></a><span id="l18.270" class="difflineplus">+    code last;                  /* parent table entry */</span>
<a href="#l18.271"></a><span id="l18.271" class="difflineplus">+    unsigned len;               /* length to copy for repeats, bits to drop */</span>
<a href="#l18.272"></a><span id="l18.272" class="difflineplus">+    int ret;                    /* return code */</span>
<a href="#l18.273"></a><span id="l18.273" class="difflineplus">+    static const unsigned short order[19] = /* permutation of code lengths */</span>
<a href="#l18.274"></a><span id="l18.274" class="difflineplus">+        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};</span>
<a href="#l18.275"></a><span id="l18.275" class="difflineplus">+</span>
<a href="#l18.276"></a><span id="l18.276" class="difflineplus">+    /* Check that the strm exists and that the state was initialized */</span>
<a href="#l18.277"></a><span id="l18.277" class="difflineplus">+    if (strm == Z_NULL || strm-&gt;state == Z_NULL)</span>
<a href="#l18.278"></a><span id="l18.278" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l18.279"></a><span id="l18.279" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l18.280"></a><span id="l18.280" class="difflineplus">+</span>
<a href="#l18.281"></a><span id="l18.281" class="difflineplus">+    /* Reset the state */</span>
<a href="#l18.282"></a><span id="l18.282" class="difflineplus">+    strm-&gt;msg = Z_NULL;</span>
<a href="#l18.283"></a><span id="l18.283" class="difflineplus">+    state-&gt;mode = TYPE;</span>
<a href="#l18.284"></a><span id="l18.284" class="difflineplus">+    state-&gt;last = 0;</span>
<a href="#l18.285"></a><span id="l18.285" class="difflineplus">+    state-&gt;whave = 0;</span>
<a href="#l18.286"></a><span id="l18.286" class="difflineplus">+    next = strm-&gt;next_in;</span>
<a href="#l18.287"></a><span id="l18.287" class="difflineplus">+    have = next != Z_NULL ? strm-&gt;avail_in : 0;</span>
<a href="#l18.288"></a><span id="l18.288" class="difflineplus">+    hold = 0;</span>
<a href="#l18.289"></a><span id="l18.289" class="difflineplus">+    bits = 0;</span>
<a href="#l18.290"></a><span id="l18.290" class="difflineplus">+    put = state-&gt;window;</span>
<a href="#l18.291"></a><span id="l18.291" class="difflineplus">+    left = state-&gt;wsize;</span>
<a href="#l18.292"></a><span id="l18.292" class="difflineplus">+</span>
<a href="#l18.293"></a><span id="l18.293" class="difflineplus">+    /* Inflate until end of block marked as last */</span>
<a href="#l18.294"></a><span id="l18.294" class="difflineplus">+    for (;;)</span>
<a href="#l18.295"></a><span id="l18.295" class="difflineplus">+        switch (state-&gt;mode) {</span>
<a href="#l18.296"></a><span id="l18.296" class="difflineplus">+        case TYPE:</span>
<a href="#l18.297"></a><span id="l18.297" class="difflineplus">+            /* determine and dispatch block type */</span>
<a href="#l18.298"></a><span id="l18.298" class="difflineplus">+            if (state-&gt;last) {</span>
<a href="#l18.299"></a><span id="l18.299" class="difflineplus">+                BYTEBITS();</span>
<a href="#l18.300"></a><span id="l18.300" class="difflineplus">+                state-&gt;mode = DONE;</span>
<a href="#l18.301"></a><span id="l18.301" class="difflineplus">+                break;</span>
<a href="#l18.302"></a><span id="l18.302" class="difflineplus">+            }</span>
<a href="#l18.303"></a><span id="l18.303" class="difflineplus">+            NEEDBITS(3);</span>
<a href="#l18.304"></a><span id="l18.304" class="difflineplus">+            state-&gt;last = BITS(1);</span>
<a href="#l18.305"></a><span id="l18.305" class="difflineplus">+            DROPBITS(1);</span>
<a href="#l18.306"></a><span id="l18.306" class="difflineplus">+            switch (BITS(2)) {</span>
<a href="#l18.307"></a><span id="l18.307" class="difflineplus">+            case 0:                             /* stored block */</span>
<a href="#l18.308"></a><span id="l18.308" class="difflineplus">+                Tracev((stderr, &quot;inflate:     stored block%s\n&quot;,</span>
<a href="#l18.309"></a><span id="l18.309" class="difflineplus">+                        state-&gt;last ? &quot; (last)&quot; : &quot;&quot;));</span>
<a href="#l18.310"></a><span id="l18.310" class="difflineplus">+                state-&gt;mode = STORED;</span>
<a href="#l18.311"></a><span id="l18.311" class="difflineplus">+                break;</span>
<a href="#l18.312"></a><span id="l18.312" class="difflineplus">+            case 1:                             /* fixed block */</span>
<a href="#l18.313"></a><span id="l18.313" class="difflineplus">+                fixedtables(state);</span>
<a href="#l18.314"></a><span id="l18.314" class="difflineplus">+                Tracev((stderr, &quot;inflate:     fixed codes block%s\n&quot;,</span>
<a href="#l18.315"></a><span id="l18.315" class="difflineplus">+                        state-&gt;last ? &quot; (last)&quot; : &quot;&quot;));</span>
<a href="#l18.316"></a><span id="l18.316" class="difflineplus">+                state-&gt;mode = LEN;              /* decode codes */</span>
<a href="#l18.317"></a><span id="l18.317" class="difflineplus">+                break;</span>
<a href="#l18.318"></a><span id="l18.318" class="difflineplus">+            case 2:                             /* dynamic block */</span>
<a href="#l18.319"></a><span id="l18.319" class="difflineplus">+                Tracev((stderr, &quot;inflate:     dynamic codes block%s\n&quot;,</span>
<a href="#l18.320"></a><span id="l18.320" class="difflineplus">+                        state-&gt;last ? &quot; (last)&quot; : &quot;&quot;));</span>
<a href="#l18.321"></a><span id="l18.321" class="difflineplus">+                state-&gt;mode = TABLE;</span>
<a href="#l18.322"></a><span id="l18.322" class="difflineplus">+                break;</span>
<a href="#l18.323"></a><span id="l18.323" class="difflineplus">+            case 3:</span>
<a href="#l18.324"></a><span id="l18.324" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid block type&quot;;</span>
<a href="#l18.325"></a><span id="l18.325" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l18.326"></a><span id="l18.326" class="difflineplus">+            }</span>
<a href="#l18.327"></a><span id="l18.327" class="difflineplus">+            DROPBITS(2);</span>
<a href="#l18.328"></a><span id="l18.328" class="difflineplus">+            break;</span>
<a href="#l18.329"></a><span id="l18.329" class="difflineplus">+</span>
<a href="#l18.330"></a><span id="l18.330" class="difflineplus">+        case STORED:</span>
<a href="#l18.331"></a><span id="l18.331" class="difflineplus">+            /* get and verify stored block length */</span>
<a href="#l18.332"></a><span id="l18.332" class="difflineplus">+            BYTEBITS();                         /* go to byte boundary */</span>
<a href="#l18.333"></a><span id="l18.333" class="difflineplus">+            NEEDBITS(32);</span>
<a href="#l18.334"></a><span id="l18.334" class="difflineplus">+            if ((hold &amp; 0xffff) != ((hold &gt;&gt; 16) ^ 0xffff)) {</span>
<a href="#l18.335"></a><span id="l18.335" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid stored block lengths&quot;;</span>
<a href="#l18.336"></a><span id="l18.336" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l18.337"></a><span id="l18.337" class="difflineplus">+                break;</span>
<a href="#l18.338"></a><span id="l18.338" class="difflineplus">+            }</span>
<a href="#l18.339"></a><span id="l18.339" class="difflineplus">+            state-&gt;length = (unsigned)hold &amp; 0xffff;</span>
<a href="#l18.340"></a><span id="l18.340" class="difflineplus">+            Tracev((stderr, &quot;inflate:       stored length %u\n&quot;,</span>
<a href="#l18.341"></a><span id="l18.341" class="difflineplus">+                    state-&gt;length));</span>
<a href="#l18.342"></a><span id="l18.342" class="difflineplus">+            INITBITS();</span>
<a href="#l18.343"></a><span id="l18.343" class="difflineplus">+</span>
<a href="#l18.344"></a><span id="l18.344" class="difflineplus">+            /* copy stored block from input to output */</span>
<a href="#l18.345"></a><span id="l18.345" class="difflineplus">+            while (state-&gt;length != 0) {</span>
<a href="#l18.346"></a><span id="l18.346" class="difflineplus">+                copy = state-&gt;length;</span>
<a href="#l18.347"></a><span id="l18.347" class="difflineplus">+                PULL();</span>
<a href="#l18.348"></a><span id="l18.348" class="difflineplus">+                ROOM();</span>
<a href="#l18.349"></a><span id="l18.349" class="difflineplus">+                if (copy &gt; have) copy = have;</span>
<a href="#l18.350"></a><span id="l18.350" class="difflineplus">+                if (copy &gt; left) copy = left;</span>
<a href="#l18.351"></a><span id="l18.351" class="difflineplus">+                zmemcpy(put, next, copy);</span>
<a href="#l18.352"></a><span id="l18.352" class="difflineplus">+                have -= copy;</span>
<a href="#l18.353"></a><span id="l18.353" class="difflineplus">+                next += copy;</span>
<a href="#l18.354"></a><span id="l18.354" class="difflineplus">+                left -= copy;</span>
<a href="#l18.355"></a><span id="l18.355" class="difflineplus">+                put += copy;</span>
<a href="#l18.356"></a><span id="l18.356" class="difflineplus">+                state-&gt;length -= copy;</span>
<a href="#l18.357"></a><span id="l18.357" class="difflineplus">+            }</span>
<a href="#l18.358"></a><span id="l18.358" class="difflineplus">+            Tracev((stderr, &quot;inflate:       stored end\n&quot;));</span>
<a href="#l18.359"></a><span id="l18.359" class="difflineplus">+            state-&gt;mode = TYPE;</span>
<a href="#l18.360"></a><span id="l18.360" class="difflineplus">+            break;</span>
<a href="#l18.361"></a><span id="l18.361" class="difflineplus">+</span>
<a href="#l18.362"></a><span id="l18.362" class="difflineplus">+        case TABLE:</span>
<a href="#l18.363"></a><span id="l18.363" class="difflineplus">+            /* get dynamic table entries descriptor */</span>
<a href="#l18.364"></a><span id="l18.364" class="difflineplus">+            NEEDBITS(14);</span>
<a href="#l18.365"></a><span id="l18.365" class="difflineplus">+            state-&gt;nlen = BITS(5) + 257;</span>
<a href="#l18.366"></a><span id="l18.366" class="difflineplus">+            DROPBITS(5);</span>
<a href="#l18.367"></a><span id="l18.367" class="difflineplus">+            state-&gt;ndist = BITS(5) + 1;</span>
<a href="#l18.368"></a><span id="l18.368" class="difflineplus">+            DROPBITS(5);</span>
<a href="#l18.369"></a><span id="l18.369" class="difflineplus">+            state-&gt;ncode = BITS(4) + 4;</span>
<a href="#l18.370"></a><span id="l18.370" class="difflineplus">+            DROPBITS(4);</span>
<a href="#l18.371"></a><span id="l18.371" class="difflineplus">+#ifndef PKZIP_BUG_WORKAROUND</span>
<a href="#l18.372"></a><span id="l18.372" class="difflineplus">+            if (state-&gt;nlen &gt; 286 || state-&gt;ndist &gt; 30) {</span>
<a href="#l18.373"></a><span id="l18.373" class="difflineplus">+                strm-&gt;msg = (char *)&quot;too many length or distance symbols&quot;;</span>
<a href="#l18.374"></a><span id="l18.374" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l18.375"></a><span id="l18.375" class="difflineplus">+                break;</span>
<a href="#l18.376"></a><span id="l18.376" class="difflineplus">+            }</span>
<a href="#l18.377"></a><span id="l18.377" class="difflineplus">+#endif</span>
<a href="#l18.378"></a><span id="l18.378" class="difflineplus">+            Tracev((stderr, &quot;inflate:       table sizes ok\n&quot;));</span>
<a href="#l18.379"></a><span id="l18.379" class="difflineplus">+</span>
<a href="#l18.380"></a><span id="l18.380" class="difflineplus">+            /* get code length code lengths (not a typo) */</span>
<a href="#l18.381"></a><span id="l18.381" class="difflineplus">+            state-&gt;have = 0;</span>
<a href="#l18.382"></a><span id="l18.382" class="difflineplus">+            while (state-&gt;have &lt; state-&gt;ncode) {</span>
<a href="#l18.383"></a><span id="l18.383" class="difflineplus">+                NEEDBITS(3);</span>
<a href="#l18.384"></a><span id="l18.384" class="difflineplus">+                state-&gt;lens[order[state-&gt;have++]] = (unsigned short)BITS(3);</span>
<a href="#l18.385"></a><span id="l18.385" class="difflineplus">+                DROPBITS(3);</span>
<a href="#l18.386"></a><span id="l18.386" class="difflineplus">+            }</span>
<a href="#l18.387"></a><span id="l18.387" class="difflineplus">+            while (state-&gt;have &lt; 19)</span>
<a href="#l18.388"></a><span id="l18.388" class="difflineplus">+                state-&gt;lens[order[state-&gt;have++]] = 0;</span>
<a href="#l18.389"></a><span id="l18.389" class="difflineplus">+            state-&gt;next = state-&gt;codes;</span>
<a href="#l18.390"></a><span id="l18.390" class="difflineplus">+            state-&gt;lencode = (code const FAR *)(state-&gt;next);</span>
<a href="#l18.391"></a><span id="l18.391" class="difflineplus">+            state-&gt;lenbits = 7;</span>
<a href="#l18.392"></a><span id="l18.392" class="difflineplus">+            ret = inflate_table(CODES, state-&gt;lens, 19, &amp;(state-&gt;next),</span>
<a href="#l18.393"></a><span id="l18.393" class="difflineplus">+                                &amp;(state-&gt;lenbits), state-&gt;work);</span>
<a href="#l18.394"></a><span id="l18.394" class="difflineplus">+            if (ret) {</span>
<a href="#l18.395"></a><span id="l18.395" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid code lengths set&quot;;</span>
<a href="#l18.396"></a><span id="l18.396" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l18.397"></a><span id="l18.397" class="difflineplus">+                break;</span>
<a href="#l18.398"></a><span id="l18.398" class="difflineplus">+            }</span>
<a href="#l18.399"></a><span id="l18.399" class="difflineplus">+            Tracev((stderr, &quot;inflate:       code lengths ok\n&quot;));</span>
<a href="#l18.400"></a><span id="l18.400" class="difflineplus">+</span>
<a href="#l18.401"></a><span id="l18.401" class="difflineplus">+            /* get length and distance code code lengths */</span>
<a href="#l18.402"></a><span id="l18.402" class="difflineplus">+            state-&gt;have = 0;</span>
<a href="#l18.403"></a><span id="l18.403" class="difflineplus">+            while (state-&gt;have &lt; state-&gt;nlen + state-&gt;ndist) {</span>
<a href="#l18.404"></a><span id="l18.404" class="difflineplus">+                for (;;) {</span>
<a href="#l18.405"></a><span id="l18.405" class="difflineplus">+                    here = state-&gt;lencode[BITS(state-&gt;lenbits)];</span>
<a href="#l18.406"></a><span id="l18.406" class="difflineplus">+                    if ((unsigned)(here.bits) &lt;= bits) break;</span>
<a href="#l18.407"></a><span id="l18.407" class="difflineplus">+                    PULLBYTE();</span>
<a href="#l18.408"></a><span id="l18.408" class="difflineplus">+                }</span>
<a href="#l18.409"></a><span id="l18.409" class="difflineplus">+                if (here.val &lt; 16) {</span>
<a href="#l18.410"></a><span id="l18.410" class="difflineplus">+                    DROPBITS(here.bits);</span>
<a href="#l18.411"></a><span id="l18.411" class="difflineplus">+                    state-&gt;lens[state-&gt;have++] = here.val;</span>
<a href="#l18.412"></a><span id="l18.412" class="difflineplus">+                }</span>
<a href="#l18.413"></a><span id="l18.413" class="difflineplus">+                else {</span>
<a href="#l18.414"></a><span id="l18.414" class="difflineplus">+                    if (here.val == 16) {</span>
<a href="#l18.415"></a><span id="l18.415" class="difflineplus">+                        NEEDBITS(here.bits + 2);</span>
<a href="#l18.416"></a><span id="l18.416" class="difflineplus">+                        DROPBITS(here.bits);</span>
<a href="#l18.417"></a><span id="l18.417" class="difflineplus">+                        if (state-&gt;have == 0) {</span>
<a href="#l18.418"></a><span id="l18.418" class="difflineplus">+                            strm-&gt;msg = (char *)&quot;invalid bit length repeat&quot;;</span>
<a href="#l18.419"></a><span id="l18.419" class="difflineplus">+                            state-&gt;mode = BAD;</span>
<a href="#l18.420"></a><span id="l18.420" class="difflineplus">+                            break;</span>
<a href="#l18.421"></a><span id="l18.421" class="difflineplus">+                        }</span>
<a href="#l18.422"></a><span id="l18.422" class="difflineplus">+                        len = (unsigned)(state-&gt;lens[state-&gt;have - 1]);</span>
<a href="#l18.423"></a><span id="l18.423" class="difflineplus">+                        copy = 3 + BITS(2);</span>
<a href="#l18.424"></a><span id="l18.424" class="difflineplus">+                        DROPBITS(2);</span>
<a href="#l18.425"></a><span id="l18.425" class="difflineplus">+                    }</span>
<a href="#l18.426"></a><span id="l18.426" class="difflineplus">+                    else if (here.val == 17) {</span>
<a href="#l18.427"></a><span id="l18.427" class="difflineplus">+                        NEEDBITS(here.bits + 3);</span>
<a href="#l18.428"></a><span id="l18.428" class="difflineplus">+                        DROPBITS(here.bits);</span>
<a href="#l18.429"></a><span id="l18.429" class="difflineplus">+                        len = 0;</span>
<a href="#l18.430"></a><span id="l18.430" class="difflineplus">+                        copy = 3 + BITS(3);</span>
<a href="#l18.431"></a><span id="l18.431" class="difflineplus">+                        DROPBITS(3);</span>
<a href="#l18.432"></a><span id="l18.432" class="difflineplus">+                    }</span>
<a href="#l18.433"></a><span id="l18.433" class="difflineplus">+                    else {</span>
<a href="#l18.434"></a><span id="l18.434" class="difflineplus">+                        NEEDBITS(here.bits + 7);</span>
<a href="#l18.435"></a><span id="l18.435" class="difflineplus">+                        DROPBITS(here.bits);</span>
<a href="#l18.436"></a><span id="l18.436" class="difflineplus">+                        len = 0;</span>
<a href="#l18.437"></a><span id="l18.437" class="difflineplus">+                        copy = 11 + BITS(7);</span>
<a href="#l18.438"></a><span id="l18.438" class="difflineplus">+                        DROPBITS(7);</span>
<a href="#l18.439"></a><span id="l18.439" class="difflineplus">+                    }</span>
<a href="#l18.440"></a><span id="l18.440" class="difflineplus">+                    if (state-&gt;have + copy &gt; state-&gt;nlen + state-&gt;ndist) {</span>
<a href="#l18.441"></a><span id="l18.441" class="difflineplus">+                        strm-&gt;msg = (char *)&quot;invalid bit length repeat&quot;;</span>
<a href="#l18.442"></a><span id="l18.442" class="difflineplus">+                        state-&gt;mode = BAD;</span>
<a href="#l18.443"></a><span id="l18.443" class="difflineplus">+                        break;</span>
<a href="#l18.444"></a><span id="l18.444" class="difflineplus">+                    }</span>
<a href="#l18.445"></a><span id="l18.445" class="difflineplus">+                    while (copy--)</span>
<a href="#l18.446"></a><span id="l18.446" class="difflineplus">+                        state-&gt;lens[state-&gt;have++] = (unsigned short)len;</span>
<a href="#l18.447"></a><span id="l18.447" class="difflineplus">+                }</span>
<a href="#l18.448"></a><span id="l18.448" class="difflineplus">+            }</span>
<a href="#l18.449"></a><span id="l18.449" class="difflineplus">+</span>
<a href="#l18.450"></a><span id="l18.450" class="difflineplus">+            /* handle error breaks in while */</span>
<a href="#l18.451"></a><span id="l18.451" class="difflineplus">+            if (state-&gt;mode == BAD) break;</span>
<a href="#l18.452"></a><span id="l18.452" class="difflineplus">+</span>
<a href="#l18.453"></a><span id="l18.453" class="difflineplus">+            /* check for end-of-block code (better have one) */</span>
<a href="#l18.454"></a><span id="l18.454" class="difflineplus">+            if (state-&gt;lens[256] == 0) {</span>
<a href="#l18.455"></a><span id="l18.455" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid code -- missing end-of-block&quot;;</span>
<a href="#l18.456"></a><span id="l18.456" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l18.457"></a><span id="l18.457" class="difflineplus">+                break;</span>
<a href="#l18.458"></a><span id="l18.458" class="difflineplus">+            }</span>
<a href="#l18.459"></a><span id="l18.459" class="difflineplus">+</span>
<a href="#l18.460"></a><span id="l18.460" class="difflineplus">+            /* build code tables -- note: do not change the lenbits or distbits</span>
<a href="#l18.461"></a><span id="l18.461" class="difflineplus">+               values here (9 and 6) without reading the comments in inftrees.h</span>
<a href="#l18.462"></a><span id="l18.462" class="difflineplus">+               concerning the ENOUGH constants, which depend on those values */</span>
<a href="#l18.463"></a><span id="l18.463" class="difflineplus">+            state-&gt;next = state-&gt;codes;</span>
<a href="#l18.464"></a><span id="l18.464" class="difflineplus">+            state-&gt;lencode = (code const FAR *)(state-&gt;next);</span>
<a href="#l18.465"></a><span id="l18.465" class="difflineplus">+            state-&gt;lenbits = 9;</span>
<a href="#l18.466"></a><span id="l18.466" class="difflineplus">+            ret = inflate_table(LENS, state-&gt;lens, state-&gt;nlen, &amp;(state-&gt;next),</span>
<a href="#l18.467"></a><span id="l18.467" class="difflineplus">+                                &amp;(state-&gt;lenbits), state-&gt;work);</span>
<a href="#l18.468"></a><span id="l18.468" class="difflineplus">+            if (ret) {</span>
<a href="#l18.469"></a><span id="l18.469" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid literal/lengths set&quot;;</span>
<a href="#l18.470"></a><span id="l18.470" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l18.471"></a><span id="l18.471" class="difflineplus">+                break;</span>
<a href="#l18.472"></a><span id="l18.472" class="difflineplus">+            }</span>
<a href="#l18.473"></a><span id="l18.473" class="difflineplus">+            state-&gt;distcode = (code const FAR *)(state-&gt;next);</span>
<a href="#l18.474"></a><span id="l18.474" class="difflineplus">+            state-&gt;distbits = 6;</span>
<a href="#l18.475"></a><span id="l18.475" class="difflineplus">+            ret = inflate_table(DISTS, state-&gt;lens + state-&gt;nlen, state-&gt;ndist,</span>
<a href="#l18.476"></a><span id="l18.476" class="difflineplus">+                            &amp;(state-&gt;next), &amp;(state-&gt;distbits), state-&gt;work);</span>
<a href="#l18.477"></a><span id="l18.477" class="difflineplus">+            if (ret) {</span>
<a href="#l18.478"></a><span id="l18.478" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid distances set&quot;;</span>
<a href="#l18.479"></a><span id="l18.479" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l18.480"></a><span id="l18.480" class="difflineplus">+                break;</span>
<a href="#l18.481"></a><span id="l18.481" class="difflineplus">+            }</span>
<a href="#l18.482"></a><span id="l18.482" class="difflineplus">+            Tracev((stderr, &quot;inflate:       codes ok\n&quot;));</span>
<a href="#l18.483"></a><span id="l18.483" class="difflineplus">+            state-&gt;mode = LEN;</span>
<a href="#l18.484"></a><span id="l18.484" class="difflineplus">+</span>
<a href="#l18.485"></a><span id="l18.485" class="difflineplus">+        case LEN:</span>
<a href="#l18.486"></a><span id="l18.486" class="difflineplus">+            /* use inflate_fast() if we have enough input and output */</span>
<a href="#l18.487"></a><span id="l18.487" class="difflineplus">+            if (have &gt;= 6 &amp;&amp; left &gt;= 258) {</span>
<a href="#l18.488"></a><span id="l18.488" class="difflineplus">+                RESTORE();</span>
<a href="#l18.489"></a><span id="l18.489" class="difflineplus">+                if (state-&gt;whave &lt; state-&gt;wsize)</span>
<a href="#l18.490"></a><span id="l18.490" class="difflineplus">+                    state-&gt;whave = state-&gt;wsize - left;</span>
<a href="#l18.491"></a><span id="l18.491" class="difflineplus">+                inflate_fast(strm, state-&gt;wsize);</span>
<a href="#l18.492"></a><span id="l18.492" class="difflineplus">+                LOAD();</span>
<a href="#l18.493"></a><span id="l18.493" class="difflineplus">+                break;</span>
<a href="#l18.494"></a><span id="l18.494" class="difflineplus">+            }</span>
<a href="#l18.495"></a><span id="l18.495" class="difflineplus">+</span>
<a href="#l18.496"></a><span id="l18.496" class="difflineplus">+            /* get a literal, length, or end-of-block code */</span>
<a href="#l18.497"></a><span id="l18.497" class="difflineplus">+            for (;;) {</span>
<a href="#l18.498"></a><span id="l18.498" class="difflineplus">+                here = state-&gt;lencode[BITS(state-&gt;lenbits)];</span>
<a href="#l18.499"></a><span id="l18.499" class="difflineplus">+                if ((unsigned)(here.bits) &lt;= bits) break;</span>
<a href="#l18.500"></a><span id="l18.500" class="difflineplus">+                PULLBYTE();</span>
<a href="#l18.501"></a><span id="l18.501" class="difflineplus">+            }</span>
<a href="#l18.502"></a><span id="l18.502" class="difflineplus">+            if (here.op &amp;&amp; (here.op &amp; 0xf0) == 0) {</span>
<a href="#l18.503"></a><span id="l18.503" class="difflineplus">+                last = here;</span>
<a href="#l18.504"></a><span id="l18.504" class="difflineplus">+                for (;;) {</span>
<a href="#l18.505"></a><span id="l18.505" class="difflineplus">+                    here = state-&gt;lencode[last.val +</span>
<a href="#l18.506"></a><span id="l18.506" class="difflineplus">+                            (BITS(last.bits + last.op) &gt;&gt; last.bits)];</span>
<a href="#l18.507"></a><span id="l18.507" class="difflineplus">+                    if ((unsigned)(last.bits + here.bits) &lt;= bits) break;</span>
<a href="#l18.508"></a><span id="l18.508" class="difflineplus">+                    PULLBYTE();</span>
<a href="#l18.509"></a><span id="l18.509" class="difflineplus">+                }</span>
<a href="#l18.510"></a><span id="l18.510" class="difflineplus">+                DROPBITS(last.bits);</span>
<a href="#l18.511"></a><span id="l18.511" class="difflineplus">+            }</span>
<a href="#l18.512"></a><span id="l18.512" class="difflineplus">+            DROPBITS(here.bits);</span>
<a href="#l18.513"></a><span id="l18.513" class="difflineplus">+            state-&gt;length = (unsigned)here.val;</span>
<a href="#l18.514"></a><span id="l18.514" class="difflineplus">+</span>
<a href="#l18.515"></a><span id="l18.515" class="difflineplus">+            /* process literal */</span>
<a href="#l18.516"></a><span id="l18.516" class="difflineplus">+            if (here.op == 0) {</span>
<a href="#l18.517"></a><span id="l18.517" class="difflineplus">+                Tracevv((stderr, here.val &gt;= 0x20 &amp;&amp; here.val &lt; 0x7f ?</span>
<a href="#l18.518"></a><span id="l18.518" class="difflineplus">+                        &quot;inflate:         literal '%c'\n&quot; :</span>
<a href="#l18.519"></a><span id="l18.519" class="difflineplus">+                        &quot;inflate:         literal 0x%02x\n&quot;, here.val));</span>
<a href="#l18.520"></a><span id="l18.520" class="difflineplus">+                ROOM();</span>
<a href="#l18.521"></a><span id="l18.521" class="difflineplus">+                *put++ = (unsigned char)(state-&gt;length);</span>
<a href="#l18.522"></a><span id="l18.522" class="difflineplus">+                left--;</span>
<a href="#l18.523"></a><span id="l18.523" class="difflineplus">+                state-&gt;mode = LEN;</span>
<a href="#l18.524"></a><span id="l18.524" class="difflineplus">+                break;</span>
<a href="#l18.525"></a><span id="l18.525" class="difflineplus">+            }</span>
<a href="#l18.526"></a><span id="l18.526" class="difflineplus">+</span>
<a href="#l18.527"></a><span id="l18.527" class="difflineplus">+            /* process end of block */</span>
<a href="#l18.528"></a><span id="l18.528" class="difflineplus">+            if (here.op &amp; 32) {</span>
<a href="#l18.529"></a><span id="l18.529" class="difflineplus">+                Tracevv((stderr, &quot;inflate:         end of block\n&quot;));</span>
<a href="#l18.530"></a><span id="l18.530" class="difflineplus">+                state-&gt;mode = TYPE;</span>
<a href="#l18.531"></a><span id="l18.531" class="difflineplus">+                break;</span>
<a href="#l18.532"></a><span id="l18.532" class="difflineplus">+            }</span>
<a href="#l18.533"></a><span id="l18.533" class="difflineplus">+</span>
<a href="#l18.534"></a><span id="l18.534" class="difflineplus">+            /* invalid code */</span>
<a href="#l18.535"></a><span id="l18.535" class="difflineplus">+            if (here.op &amp; 64) {</span>
<a href="#l18.536"></a><span id="l18.536" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid literal/length code&quot;;</span>
<a href="#l18.537"></a><span id="l18.537" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l18.538"></a><span id="l18.538" class="difflineplus">+                break;</span>
<a href="#l18.539"></a><span id="l18.539" class="difflineplus">+            }</span>
<a href="#l18.540"></a><span id="l18.540" class="difflineplus">+</span>
<a href="#l18.541"></a><span id="l18.541" class="difflineplus">+            /* length code -- get extra bits, if any */</span>
<a href="#l18.542"></a><span id="l18.542" class="difflineplus">+            state-&gt;extra = (unsigned)(here.op) &amp; 15;</span>
<a href="#l18.543"></a><span id="l18.543" class="difflineplus">+            if (state-&gt;extra != 0) {</span>
<a href="#l18.544"></a><span id="l18.544" class="difflineplus">+                NEEDBITS(state-&gt;extra);</span>
<a href="#l18.545"></a><span id="l18.545" class="difflineplus">+                state-&gt;length += BITS(state-&gt;extra);</span>
<a href="#l18.546"></a><span id="l18.546" class="difflineplus">+                DROPBITS(state-&gt;extra);</span>
<a href="#l18.547"></a><span id="l18.547" class="difflineplus">+            }</span>
<a href="#l18.548"></a><span id="l18.548" class="difflineplus">+            Tracevv((stderr, &quot;inflate:         length %u\n&quot;, state-&gt;length));</span>
<a href="#l18.549"></a><span id="l18.549" class="difflineplus">+</span>
<a href="#l18.550"></a><span id="l18.550" class="difflineplus">+            /* get distance code */</span>
<a href="#l18.551"></a><span id="l18.551" class="difflineplus">+            for (;;) {</span>
<a href="#l18.552"></a><span id="l18.552" class="difflineplus">+                here = state-&gt;distcode[BITS(state-&gt;distbits)];</span>
<a href="#l18.553"></a><span id="l18.553" class="difflineplus">+                if ((unsigned)(here.bits) &lt;= bits) break;</span>
<a href="#l18.554"></a><span id="l18.554" class="difflineplus">+                PULLBYTE();</span>
<a href="#l18.555"></a><span id="l18.555" class="difflineplus">+            }</span>
<a href="#l18.556"></a><span id="l18.556" class="difflineplus">+            if ((here.op &amp; 0xf0) == 0) {</span>
<a href="#l18.557"></a><span id="l18.557" class="difflineplus">+                last = here;</span>
<a href="#l18.558"></a><span id="l18.558" class="difflineplus">+                for (;;) {</span>
<a href="#l18.559"></a><span id="l18.559" class="difflineplus">+                    here = state-&gt;distcode[last.val +</span>
<a href="#l18.560"></a><span id="l18.560" class="difflineplus">+                            (BITS(last.bits + last.op) &gt;&gt; last.bits)];</span>
<a href="#l18.561"></a><span id="l18.561" class="difflineplus">+                    if ((unsigned)(last.bits + here.bits) &lt;= bits) break;</span>
<a href="#l18.562"></a><span id="l18.562" class="difflineplus">+                    PULLBYTE();</span>
<a href="#l18.563"></a><span id="l18.563" class="difflineplus">+                }</span>
<a href="#l18.564"></a><span id="l18.564" class="difflineplus">+                DROPBITS(last.bits);</span>
<a href="#l18.565"></a><span id="l18.565" class="difflineplus">+            }</span>
<a href="#l18.566"></a><span id="l18.566" class="difflineplus">+            DROPBITS(here.bits);</span>
<a href="#l18.567"></a><span id="l18.567" class="difflineplus">+            if (here.op &amp; 64) {</span>
<a href="#l18.568"></a><span id="l18.568" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid distance code&quot;;</span>
<a href="#l18.569"></a><span id="l18.569" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l18.570"></a><span id="l18.570" class="difflineplus">+                break;</span>
<a href="#l18.571"></a><span id="l18.571" class="difflineplus">+            }</span>
<a href="#l18.572"></a><span id="l18.572" class="difflineplus">+            state-&gt;offset = (unsigned)here.val;</span>
<a href="#l18.573"></a><span id="l18.573" class="difflineplus">+</span>
<a href="#l18.574"></a><span id="l18.574" class="difflineplus">+            /* get distance extra bits, if any */</span>
<a href="#l18.575"></a><span id="l18.575" class="difflineplus">+            state-&gt;extra = (unsigned)(here.op) &amp; 15;</span>
<a href="#l18.576"></a><span id="l18.576" class="difflineplus">+            if (state-&gt;extra != 0) {</span>
<a href="#l18.577"></a><span id="l18.577" class="difflineplus">+                NEEDBITS(state-&gt;extra);</span>
<a href="#l18.578"></a><span id="l18.578" class="difflineplus">+                state-&gt;offset += BITS(state-&gt;extra);</span>
<a href="#l18.579"></a><span id="l18.579" class="difflineplus">+                DROPBITS(state-&gt;extra);</span>
<a href="#l18.580"></a><span id="l18.580" class="difflineplus">+            }</span>
<a href="#l18.581"></a><span id="l18.581" class="difflineplus">+            if (state-&gt;offset &gt; state-&gt;wsize - (state-&gt;whave &lt; state-&gt;wsize ?</span>
<a href="#l18.582"></a><span id="l18.582" class="difflineplus">+                                                left : 0)) {</span>
<a href="#l18.583"></a><span id="l18.583" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid distance too far back&quot;;</span>
<a href="#l18.584"></a><span id="l18.584" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l18.585"></a><span id="l18.585" class="difflineplus">+                break;</span>
<a href="#l18.586"></a><span id="l18.586" class="difflineplus">+            }</span>
<a href="#l18.587"></a><span id="l18.587" class="difflineplus">+            Tracevv((stderr, &quot;inflate:         distance %u\n&quot;, state-&gt;offset));</span>
<a href="#l18.588"></a><span id="l18.588" class="difflineplus">+</span>
<a href="#l18.589"></a><span id="l18.589" class="difflineplus">+            /* copy match from window to output */</span>
<a href="#l18.590"></a><span id="l18.590" class="difflineplus">+            do {</span>
<a href="#l18.591"></a><span id="l18.591" class="difflineplus">+                ROOM();</span>
<a href="#l18.592"></a><span id="l18.592" class="difflineplus">+                copy = state-&gt;wsize - state-&gt;offset;</span>
<a href="#l18.593"></a><span id="l18.593" class="difflineplus">+                if (copy &lt; left) {</span>
<a href="#l18.594"></a><span id="l18.594" class="difflineplus">+                    from = put + copy;</span>
<a href="#l18.595"></a><span id="l18.595" class="difflineplus">+                    copy = left - copy;</span>
<a href="#l18.596"></a><span id="l18.596" class="difflineplus">+                }</span>
<a href="#l18.597"></a><span id="l18.597" class="difflineplus">+                else {</span>
<a href="#l18.598"></a><span id="l18.598" class="difflineplus">+                    from = put - state-&gt;offset;</span>
<a href="#l18.599"></a><span id="l18.599" class="difflineplus">+                    copy = left;</span>
<a href="#l18.600"></a><span id="l18.600" class="difflineplus">+                }</span>
<a href="#l18.601"></a><span id="l18.601" class="difflineplus">+                if (copy &gt; state-&gt;length) copy = state-&gt;length;</span>
<a href="#l18.602"></a><span id="l18.602" class="difflineplus">+                state-&gt;length -= copy;</span>
<a href="#l18.603"></a><span id="l18.603" class="difflineplus">+                left -= copy;</span>
<a href="#l18.604"></a><span id="l18.604" class="difflineplus">+                do {</span>
<a href="#l18.605"></a><span id="l18.605" class="difflineplus">+                    *put++ = *from++;</span>
<a href="#l18.606"></a><span id="l18.606" class="difflineplus">+                } while (--copy);</span>
<a href="#l18.607"></a><span id="l18.607" class="difflineplus">+            } while (state-&gt;length != 0);</span>
<a href="#l18.608"></a><span id="l18.608" class="difflineplus">+            break;</span>
<a href="#l18.609"></a><span id="l18.609" class="difflineplus">+</span>
<a href="#l18.610"></a><span id="l18.610" class="difflineplus">+        case DONE:</span>
<a href="#l18.611"></a><span id="l18.611" class="difflineplus">+            /* inflate stream terminated properly -- write leftover output */</span>
<a href="#l18.612"></a><span id="l18.612" class="difflineplus">+            ret = Z_STREAM_END;</span>
<a href="#l18.613"></a><span id="l18.613" class="difflineplus">+            if (left &lt; state-&gt;wsize) {</span>
<a href="#l18.614"></a><span id="l18.614" class="difflineplus">+                if (out(out_desc, state-&gt;window, state-&gt;wsize - left))</span>
<a href="#l18.615"></a><span id="l18.615" class="difflineplus">+                    ret = Z_BUF_ERROR;</span>
<a href="#l18.616"></a><span id="l18.616" class="difflineplus">+            }</span>
<a href="#l18.617"></a><span id="l18.617" class="difflineplus">+            goto inf_leave;</span>
<a href="#l18.618"></a><span id="l18.618" class="difflineplus">+</span>
<a href="#l18.619"></a><span id="l18.619" class="difflineplus">+        case BAD:</span>
<a href="#l18.620"></a><span id="l18.620" class="difflineplus">+            ret = Z_DATA_ERROR;</span>
<a href="#l18.621"></a><span id="l18.621" class="difflineplus">+            goto inf_leave;</span>
<a href="#l18.622"></a><span id="l18.622" class="difflineplus">+</span>
<a href="#l18.623"></a><span id="l18.623" class="difflineplus">+        default:                /* can't happen, but makes compilers happy */</span>
<a href="#l18.624"></a><span id="l18.624" class="difflineplus">+            ret = Z_STREAM_ERROR;</span>
<a href="#l18.625"></a><span id="l18.625" class="difflineplus">+            goto inf_leave;</span>
<a href="#l18.626"></a><span id="l18.626" class="difflineplus">+        }</span>
<a href="#l18.627"></a><span id="l18.627" class="difflineplus">+</span>
<a href="#l18.628"></a><span id="l18.628" class="difflineplus">+    /* Return unused input */</span>
<a href="#l18.629"></a><span id="l18.629" class="difflineplus">+  inf_leave:</span>
<a href="#l18.630"></a><span id="l18.630" class="difflineplus">+    strm-&gt;next_in = next;</span>
<a href="#l18.631"></a><span id="l18.631" class="difflineplus">+    strm-&gt;avail_in = have;</span>
<a href="#l18.632"></a><span id="l18.632" class="difflineplus">+    return ret;</span>
<a href="#l18.633"></a><span id="l18.633" class="difflineplus">+}</span>
<a href="#l18.634"></a><span id="l18.634" class="difflineplus">+</span>
<a href="#l18.635"></a><span id="l18.635" class="difflineplus">+int ZEXPORT inflateBackEnd(strm)</span>
<a href="#l18.636"></a><span id="l18.636" class="difflineplus">+z_streamp strm;</span>
<a href="#l18.637"></a><span id="l18.637" class="difflineplus">+{</span>
<a href="#l18.638"></a><span id="l18.638" class="difflineplus">+    if (strm == Z_NULL || strm-&gt;state == Z_NULL || strm-&gt;zfree == (free_func)0)</span>
<a href="#l18.639"></a><span id="l18.639" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l18.640"></a><span id="l18.640" class="difflineplus">+    ZFREE(strm, strm-&gt;state);</span>
<a href="#l18.641"></a><span id="l18.641" class="difflineplus">+    strm-&gt;state = Z_NULL;</span>
<a href="#l18.642"></a><span id="l18.642" class="difflineplus">+    Tracev((stderr, &quot;inflate: end\n&quot;));</span>
<a href="#l18.643"></a><span id="l18.643" class="difflineplus">+    return Z_OK;</span>
<a href="#l18.644"></a><span id="l18.644" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1">new file mode 100644</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineminus">--- /dev/null</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineplus">+++ b/third_party/zlib/inffast.c</span>
<a href="#l19.4"></a><span id="l19.4" class="difflineat">@@ -0,0 +1,323 @@</span>
<a href="#l19.5"></a><span id="l19.5" class="difflineplus">+/* inffast.c -- fast decoding</span>
<a href="#l19.6"></a><span id="l19.6" class="difflineplus">+ * Copyright (C) 1995-2017 Mark Adler</span>
<a href="#l19.7"></a><span id="l19.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l19.8"></a><span id="l19.8" class="difflineplus">+ */</span>
<a href="#l19.9"></a><span id="l19.9" class="difflineplus">+</span>
<a href="#l19.10"></a><span id="l19.10" class="difflineplus">+#include &quot;zutil.h&quot;</span>
<a href="#l19.11"></a><span id="l19.11" class="difflineplus">+#include &quot;inftrees.h&quot;</span>
<a href="#l19.12"></a><span id="l19.12" class="difflineplus">+#include &quot;inflate.h&quot;</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+#include &quot;inffast.h&quot;</span>
<a href="#l19.14"></a><span id="l19.14" class="difflineplus">+</span>
<a href="#l19.15"></a><span id="l19.15" class="difflineplus">+#ifdef ASMINF</span>
<a href="#l19.16"></a><span id="l19.16" class="difflineplus">+#  pragma message(&quot;Assembler code may have bugs -- use at your own risk&quot;)</span>
<a href="#l19.17"></a><span id="l19.17" class="difflineplus">+#else</span>
<a href="#l19.18"></a><span id="l19.18" class="difflineplus">+</span>
<a href="#l19.19"></a><span id="l19.19" class="difflineplus">+/*</span>
<a href="#l19.20"></a><span id="l19.20" class="difflineplus">+   Decode literal, length, and distance codes and write out the resulting</span>
<a href="#l19.21"></a><span id="l19.21" class="difflineplus">+   literal and match bytes until either not enough input or output is</span>
<a href="#l19.22"></a><span id="l19.22" class="difflineplus">+   available, an end-of-block is encountered, or a data error is encountered.</span>
<a href="#l19.23"></a><span id="l19.23" class="difflineplus">+   When large enough input and output buffers are supplied to inflate(), for</span>
<a href="#l19.24"></a><span id="l19.24" class="difflineplus">+   example, a 16K input buffer and a 64K output buffer, more than 95% of the</span>
<a href="#l19.25"></a><span id="l19.25" class="difflineplus">+   inflate execution time is spent in this routine.</span>
<a href="#l19.26"></a><span id="l19.26" class="difflineplus">+</span>
<a href="#l19.27"></a><span id="l19.27" class="difflineplus">+   Entry assumptions:</span>
<a href="#l19.28"></a><span id="l19.28" class="difflineplus">+</span>
<a href="#l19.29"></a><span id="l19.29" class="difflineplus">+        state-&gt;mode == LEN</span>
<a href="#l19.30"></a><span id="l19.30" class="difflineplus">+        strm-&gt;avail_in &gt;= 6</span>
<a href="#l19.31"></a><span id="l19.31" class="difflineplus">+        strm-&gt;avail_out &gt;= 258</span>
<a href="#l19.32"></a><span id="l19.32" class="difflineplus">+        start &gt;= strm-&gt;avail_out</span>
<a href="#l19.33"></a><span id="l19.33" class="difflineplus">+        state-&gt;bits &lt; 8</span>
<a href="#l19.34"></a><span id="l19.34" class="difflineplus">+</span>
<a href="#l19.35"></a><span id="l19.35" class="difflineplus">+   On return, state-&gt;mode is one of:</span>
<a href="#l19.36"></a><span id="l19.36" class="difflineplus">+</span>
<a href="#l19.37"></a><span id="l19.37" class="difflineplus">+        LEN -- ran out of enough output space or enough available input</span>
<a href="#l19.38"></a><span id="l19.38" class="difflineplus">+        TYPE -- reached end of block code, inflate() to interpret next block</span>
<a href="#l19.39"></a><span id="l19.39" class="difflineplus">+        BAD -- error in block data</span>
<a href="#l19.40"></a><span id="l19.40" class="difflineplus">+</span>
<a href="#l19.41"></a><span id="l19.41" class="difflineplus">+   Notes:</span>
<a href="#l19.42"></a><span id="l19.42" class="difflineplus">+</span>
<a href="#l19.43"></a><span id="l19.43" class="difflineplus">+    - The maximum input bits used by a length/distance pair is 15 bits for the</span>
<a href="#l19.44"></a><span id="l19.44" class="difflineplus">+      length code, 5 bits for the length extra, 15 bits for the distance code,</span>
<a href="#l19.45"></a><span id="l19.45" class="difflineplus">+      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.</span>
<a href="#l19.46"></a><span id="l19.46" class="difflineplus">+      Therefore if strm-&gt;avail_in &gt;= 6, then there is enough input to avoid</span>
<a href="#l19.47"></a><span id="l19.47" class="difflineplus">+      checking for available input while decoding.</span>
<a href="#l19.48"></a><span id="l19.48" class="difflineplus">+</span>
<a href="#l19.49"></a><span id="l19.49" class="difflineplus">+    - The maximum bytes that a single length/distance pair can output is 258</span>
<a href="#l19.50"></a><span id="l19.50" class="difflineplus">+      bytes, which is the maximum length that can be coded.  inflate_fast()</span>
<a href="#l19.51"></a><span id="l19.51" class="difflineplus">+      requires strm-&gt;avail_out &gt;= 258 for each loop to avoid checking for</span>
<a href="#l19.52"></a><span id="l19.52" class="difflineplus">+      output space.</span>
<a href="#l19.53"></a><span id="l19.53" class="difflineplus">+ */</span>
<a href="#l19.54"></a><span id="l19.54" class="difflineplus">+void ZLIB_INTERNAL inflate_fast(strm, start)</span>
<a href="#l19.55"></a><span id="l19.55" class="difflineplus">+z_streamp strm;</span>
<a href="#l19.56"></a><span id="l19.56" class="difflineplus">+unsigned start;         /* inflate()'s starting value for strm-&gt;avail_out */</span>
<a href="#l19.57"></a><span id="l19.57" class="difflineplus">+{</span>
<a href="#l19.58"></a><span id="l19.58" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l19.59"></a><span id="l19.59" class="difflineplus">+    z_const unsigned char FAR *in;      /* local strm-&gt;next_in */</span>
<a href="#l19.60"></a><span id="l19.60" class="difflineplus">+    z_const unsigned char FAR *last;    /* have enough input while in &lt; last */</span>
<a href="#l19.61"></a><span id="l19.61" class="difflineplus">+    unsigned char FAR *out;     /* local strm-&gt;next_out */</span>
<a href="#l19.62"></a><span id="l19.62" class="difflineplus">+    unsigned char FAR *beg;     /* inflate()'s initial strm-&gt;next_out */</span>
<a href="#l19.63"></a><span id="l19.63" class="difflineplus">+    unsigned char FAR *end;     /* while out &lt; end, enough space available */</span>
<a href="#l19.64"></a><span id="l19.64" class="difflineplus">+#ifdef INFLATE_STRICT</span>
<a href="#l19.65"></a><span id="l19.65" class="difflineplus">+    unsigned dmax;              /* maximum distance from zlib header */</span>
<a href="#l19.66"></a><span id="l19.66" class="difflineplus">+#endif</span>
<a href="#l19.67"></a><span id="l19.67" class="difflineplus">+    unsigned wsize;             /* window size or zero if not using window */</span>
<a href="#l19.68"></a><span id="l19.68" class="difflineplus">+    unsigned whave;             /* valid bytes in the window */</span>
<a href="#l19.69"></a><span id="l19.69" class="difflineplus">+    unsigned wnext;             /* window write index */</span>
<a href="#l19.70"></a><span id="l19.70" class="difflineplus">+    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */</span>
<a href="#l19.71"></a><span id="l19.71" class="difflineplus">+    unsigned long hold;         /* local strm-&gt;hold */</span>
<a href="#l19.72"></a><span id="l19.72" class="difflineplus">+    unsigned bits;              /* local strm-&gt;bits */</span>
<a href="#l19.73"></a><span id="l19.73" class="difflineplus">+    code const FAR *lcode;      /* local strm-&gt;lencode */</span>
<a href="#l19.74"></a><span id="l19.74" class="difflineplus">+    code const FAR *dcode;      /* local strm-&gt;distcode */</span>
<a href="#l19.75"></a><span id="l19.75" class="difflineplus">+    unsigned lmask;             /* mask for first level of length codes */</span>
<a href="#l19.76"></a><span id="l19.76" class="difflineplus">+    unsigned dmask;             /* mask for first level of distance codes */</span>
<a href="#l19.77"></a><span id="l19.77" class="difflineplus">+    code here;                  /* retrieved table entry */</span>
<a href="#l19.78"></a><span id="l19.78" class="difflineplus">+    unsigned op;                /* code bits, operation, extra bits, or */</span>
<a href="#l19.79"></a><span id="l19.79" class="difflineplus">+                                /*  window position, window bytes to copy */</span>
<a href="#l19.80"></a><span id="l19.80" class="difflineplus">+    unsigned len;               /* match length, unused bytes */</span>
<a href="#l19.81"></a><span id="l19.81" class="difflineplus">+    unsigned dist;              /* match distance */</span>
<a href="#l19.82"></a><span id="l19.82" class="difflineplus">+    unsigned char FAR *from;    /* where to copy match from */</span>
<a href="#l19.83"></a><span id="l19.83" class="difflineplus">+</span>
<a href="#l19.84"></a><span id="l19.84" class="difflineplus">+    /* copy state to local variables */</span>
<a href="#l19.85"></a><span id="l19.85" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l19.86"></a><span id="l19.86" class="difflineplus">+    in = strm-&gt;next_in;</span>
<a href="#l19.87"></a><span id="l19.87" class="difflineplus">+    last = in + (strm-&gt;avail_in - 5);</span>
<a href="#l19.88"></a><span id="l19.88" class="difflineplus">+    out = strm-&gt;next_out;</span>
<a href="#l19.89"></a><span id="l19.89" class="difflineplus">+    beg = out - (start - strm-&gt;avail_out);</span>
<a href="#l19.90"></a><span id="l19.90" class="difflineplus">+    end = out + (strm-&gt;avail_out - 257);</span>
<a href="#l19.91"></a><span id="l19.91" class="difflineplus">+#ifdef INFLATE_STRICT</span>
<a href="#l19.92"></a><span id="l19.92" class="difflineplus">+    dmax = state-&gt;dmax;</span>
<a href="#l19.93"></a><span id="l19.93" class="difflineplus">+#endif</span>
<a href="#l19.94"></a><span id="l19.94" class="difflineplus">+    wsize = state-&gt;wsize;</span>
<a href="#l19.95"></a><span id="l19.95" class="difflineplus">+    whave = state-&gt;whave;</span>
<a href="#l19.96"></a><span id="l19.96" class="difflineplus">+    wnext = state-&gt;wnext;</span>
<a href="#l19.97"></a><span id="l19.97" class="difflineplus">+    window = state-&gt;window;</span>
<a href="#l19.98"></a><span id="l19.98" class="difflineplus">+    hold = state-&gt;hold;</span>
<a href="#l19.99"></a><span id="l19.99" class="difflineplus">+    bits = state-&gt;bits;</span>
<a href="#l19.100"></a><span id="l19.100" class="difflineplus">+    lcode = state-&gt;lencode;</span>
<a href="#l19.101"></a><span id="l19.101" class="difflineplus">+    dcode = state-&gt;distcode;</span>
<a href="#l19.102"></a><span id="l19.102" class="difflineplus">+    lmask = (1U &lt;&lt; state-&gt;lenbits) - 1;</span>
<a href="#l19.103"></a><span id="l19.103" class="difflineplus">+    dmask = (1U &lt;&lt; state-&gt;distbits) - 1;</span>
<a href="#l19.104"></a><span id="l19.104" class="difflineplus">+</span>
<a href="#l19.105"></a><span id="l19.105" class="difflineplus">+    /* decode literals and length/distances until end-of-block or not enough</span>
<a href="#l19.106"></a><span id="l19.106" class="difflineplus">+       input data or output space */</span>
<a href="#l19.107"></a><span id="l19.107" class="difflineplus">+    do {</span>
<a href="#l19.108"></a><span id="l19.108" class="difflineplus">+        if (bits &lt; 15) {</span>
<a href="#l19.109"></a><span id="l19.109" class="difflineplus">+            hold += (unsigned long)(*in++) &lt;&lt; bits;</span>
<a href="#l19.110"></a><span id="l19.110" class="difflineplus">+            bits += 8;</span>
<a href="#l19.111"></a><span id="l19.111" class="difflineplus">+            hold += (unsigned long)(*in++) &lt;&lt; bits;</span>
<a href="#l19.112"></a><span id="l19.112" class="difflineplus">+            bits += 8;</span>
<a href="#l19.113"></a><span id="l19.113" class="difflineplus">+        }</span>
<a href="#l19.114"></a><span id="l19.114" class="difflineplus">+        here = lcode[hold &amp; lmask];</span>
<a href="#l19.115"></a><span id="l19.115" class="difflineplus">+      dolen:</span>
<a href="#l19.116"></a><span id="l19.116" class="difflineplus">+        op = (unsigned)(here.bits);</span>
<a href="#l19.117"></a><span id="l19.117" class="difflineplus">+        hold &gt;&gt;= op;</span>
<a href="#l19.118"></a><span id="l19.118" class="difflineplus">+        bits -= op;</span>
<a href="#l19.119"></a><span id="l19.119" class="difflineplus">+        op = (unsigned)(here.op);</span>
<a href="#l19.120"></a><span id="l19.120" class="difflineplus">+        if (op == 0) {                          /* literal */</span>
<a href="#l19.121"></a><span id="l19.121" class="difflineplus">+            Tracevv((stderr, here.val &gt;= 0x20 &amp;&amp; here.val &lt; 0x7f ?</span>
<a href="#l19.122"></a><span id="l19.122" class="difflineplus">+                    &quot;inflate:         literal '%c'\n&quot; :</span>
<a href="#l19.123"></a><span id="l19.123" class="difflineplus">+                    &quot;inflate:         literal 0x%02x\n&quot;, here.val));</span>
<a href="#l19.124"></a><span id="l19.124" class="difflineplus">+            *out++ = (unsigned char)(here.val);</span>
<a href="#l19.125"></a><span id="l19.125" class="difflineplus">+        }</span>
<a href="#l19.126"></a><span id="l19.126" class="difflineplus">+        else if (op &amp; 16) {                     /* length base */</span>
<a href="#l19.127"></a><span id="l19.127" class="difflineplus">+            len = (unsigned)(here.val);</span>
<a href="#l19.128"></a><span id="l19.128" class="difflineplus">+            op &amp;= 15;                           /* number of extra bits */</span>
<a href="#l19.129"></a><span id="l19.129" class="difflineplus">+            if (op) {</span>
<a href="#l19.130"></a><span id="l19.130" class="difflineplus">+                if (bits &lt; op) {</span>
<a href="#l19.131"></a><span id="l19.131" class="difflineplus">+                    hold += (unsigned long)(*in++) &lt;&lt; bits;</span>
<a href="#l19.132"></a><span id="l19.132" class="difflineplus">+                    bits += 8;</span>
<a href="#l19.133"></a><span id="l19.133" class="difflineplus">+                }</span>
<a href="#l19.134"></a><span id="l19.134" class="difflineplus">+                len += (unsigned)hold &amp; ((1U &lt;&lt; op) - 1);</span>
<a href="#l19.135"></a><span id="l19.135" class="difflineplus">+                hold &gt;&gt;= op;</span>
<a href="#l19.136"></a><span id="l19.136" class="difflineplus">+                bits -= op;</span>
<a href="#l19.137"></a><span id="l19.137" class="difflineplus">+            }</span>
<a href="#l19.138"></a><span id="l19.138" class="difflineplus">+            Tracevv((stderr, &quot;inflate:         length %u\n&quot;, len));</span>
<a href="#l19.139"></a><span id="l19.139" class="difflineplus">+            if (bits &lt; 15) {</span>
<a href="#l19.140"></a><span id="l19.140" class="difflineplus">+                hold += (unsigned long)(*in++) &lt;&lt; bits;</span>
<a href="#l19.141"></a><span id="l19.141" class="difflineplus">+                bits += 8;</span>
<a href="#l19.142"></a><span id="l19.142" class="difflineplus">+                hold += (unsigned long)(*in++) &lt;&lt; bits;</span>
<a href="#l19.143"></a><span id="l19.143" class="difflineplus">+                bits += 8;</span>
<a href="#l19.144"></a><span id="l19.144" class="difflineplus">+            }</span>
<a href="#l19.145"></a><span id="l19.145" class="difflineplus">+            here = dcode[hold &amp; dmask];</span>
<a href="#l19.146"></a><span id="l19.146" class="difflineplus">+          dodist:</span>
<a href="#l19.147"></a><span id="l19.147" class="difflineplus">+            op = (unsigned)(here.bits);</span>
<a href="#l19.148"></a><span id="l19.148" class="difflineplus">+            hold &gt;&gt;= op;</span>
<a href="#l19.149"></a><span id="l19.149" class="difflineplus">+            bits -= op;</span>
<a href="#l19.150"></a><span id="l19.150" class="difflineplus">+            op = (unsigned)(here.op);</span>
<a href="#l19.151"></a><span id="l19.151" class="difflineplus">+            if (op &amp; 16) {                      /* distance base */</span>
<a href="#l19.152"></a><span id="l19.152" class="difflineplus">+                dist = (unsigned)(here.val);</span>
<a href="#l19.153"></a><span id="l19.153" class="difflineplus">+                op &amp;= 15;                       /* number of extra bits */</span>
<a href="#l19.154"></a><span id="l19.154" class="difflineplus">+                if (bits &lt; op) {</span>
<a href="#l19.155"></a><span id="l19.155" class="difflineplus">+                    hold += (unsigned long)(*in++) &lt;&lt; bits;</span>
<a href="#l19.156"></a><span id="l19.156" class="difflineplus">+                    bits += 8;</span>
<a href="#l19.157"></a><span id="l19.157" class="difflineplus">+                    if (bits &lt; op) {</span>
<a href="#l19.158"></a><span id="l19.158" class="difflineplus">+                        hold += (unsigned long)(*in++) &lt;&lt; bits;</span>
<a href="#l19.159"></a><span id="l19.159" class="difflineplus">+                        bits += 8;</span>
<a href="#l19.160"></a><span id="l19.160" class="difflineplus">+                    }</span>
<a href="#l19.161"></a><span id="l19.161" class="difflineplus">+                }</span>
<a href="#l19.162"></a><span id="l19.162" class="difflineplus">+                dist += (unsigned)hold &amp; ((1U &lt;&lt; op) - 1);</span>
<a href="#l19.163"></a><span id="l19.163" class="difflineplus">+#ifdef INFLATE_STRICT</span>
<a href="#l19.164"></a><span id="l19.164" class="difflineplus">+                if (dist &gt; dmax) {</span>
<a href="#l19.165"></a><span id="l19.165" class="difflineplus">+                    strm-&gt;msg = (char *)&quot;invalid distance too far back&quot;;</span>
<a href="#l19.166"></a><span id="l19.166" class="difflineplus">+                    state-&gt;mode = BAD;</span>
<a href="#l19.167"></a><span id="l19.167" class="difflineplus">+                    break;</span>
<a href="#l19.168"></a><span id="l19.168" class="difflineplus">+                }</span>
<a href="#l19.169"></a><span id="l19.169" class="difflineplus">+#endif</span>
<a href="#l19.170"></a><span id="l19.170" class="difflineplus">+                hold &gt;&gt;= op;</span>
<a href="#l19.171"></a><span id="l19.171" class="difflineplus">+                bits -= op;</span>
<a href="#l19.172"></a><span id="l19.172" class="difflineplus">+                Tracevv((stderr, &quot;inflate:         distance %u\n&quot;, dist));</span>
<a href="#l19.173"></a><span id="l19.173" class="difflineplus">+                op = (unsigned)(out - beg);     /* max distance in output */</span>
<a href="#l19.174"></a><span id="l19.174" class="difflineplus">+                if (dist &gt; op) {                /* see if copy from window */</span>
<a href="#l19.175"></a><span id="l19.175" class="difflineplus">+                    op = dist - op;             /* distance back in window */</span>
<a href="#l19.176"></a><span id="l19.176" class="difflineplus">+                    if (op &gt; whave) {</span>
<a href="#l19.177"></a><span id="l19.177" class="difflineplus">+                        if (state-&gt;sane) {</span>
<a href="#l19.178"></a><span id="l19.178" class="difflineplus">+                            strm-&gt;msg =</span>
<a href="#l19.179"></a><span id="l19.179" class="difflineplus">+                                (char *)&quot;invalid distance too far back&quot;;</span>
<a href="#l19.180"></a><span id="l19.180" class="difflineplus">+                            state-&gt;mode = BAD;</span>
<a href="#l19.181"></a><span id="l19.181" class="difflineplus">+                            break;</span>
<a href="#l19.182"></a><span id="l19.182" class="difflineplus">+                        }</span>
<a href="#l19.183"></a><span id="l19.183" class="difflineplus">+#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR</span>
<a href="#l19.184"></a><span id="l19.184" class="difflineplus">+                        if (len &lt;= op - whave) {</span>
<a href="#l19.185"></a><span id="l19.185" class="difflineplus">+                            do {</span>
<a href="#l19.186"></a><span id="l19.186" class="difflineplus">+                                *out++ = 0;</span>
<a href="#l19.187"></a><span id="l19.187" class="difflineplus">+                            } while (--len);</span>
<a href="#l19.188"></a><span id="l19.188" class="difflineplus">+                            continue;</span>
<a href="#l19.189"></a><span id="l19.189" class="difflineplus">+                        }</span>
<a href="#l19.190"></a><span id="l19.190" class="difflineplus">+                        len -= op - whave;</span>
<a href="#l19.191"></a><span id="l19.191" class="difflineplus">+                        do {</span>
<a href="#l19.192"></a><span id="l19.192" class="difflineplus">+                            *out++ = 0;</span>
<a href="#l19.193"></a><span id="l19.193" class="difflineplus">+                        } while (--op &gt; whave);</span>
<a href="#l19.194"></a><span id="l19.194" class="difflineplus">+                        if (op == 0) {</span>
<a href="#l19.195"></a><span id="l19.195" class="difflineplus">+                            from = out - dist;</span>
<a href="#l19.196"></a><span id="l19.196" class="difflineplus">+                            do {</span>
<a href="#l19.197"></a><span id="l19.197" class="difflineplus">+                                *out++ = *from++;</span>
<a href="#l19.198"></a><span id="l19.198" class="difflineplus">+                            } while (--len);</span>
<a href="#l19.199"></a><span id="l19.199" class="difflineplus">+                            continue;</span>
<a href="#l19.200"></a><span id="l19.200" class="difflineplus">+                        }</span>
<a href="#l19.201"></a><span id="l19.201" class="difflineplus">+#endif</span>
<a href="#l19.202"></a><span id="l19.202" class="difflineplus">+                    }</span>
<a href="#l19.203"></a><span id="l19.203" class="difflineplus">+                    from = window;</span>
<a href="#l19.204"></a><span id="l19.204" class="difflineplus">+                    if (wnext == 0) {           /* very common case */</span>
<a href="#l19.205"></a><span id="l19.205" class="difflineplus">+                        from += wsize - op;</span>
<a href="#l19.206"></a><span id="l19.206" class="difflineplus">+                        if (op &lt; len) {         /* some from window */</span>
<a href="#l19.207"></a><span id="l19.207" class="difflineplus">+                            len -= op;</span>
<a href="#l19.208"></a><span id="l19.208" class="difflineplus">+                            do {</span>
<a href="#l19.209"></a><span id="l19.209" class="difflineplus">+                                *out++ = *from++;</span>
<a href="#l19.210"></a><span id="l19.210" class="difflineplus">+                            } while (--op);</span>
<a href="#l19.211"></a><span id="l19.211" class="difflineplus">+                            from = out - dist;  /* rest from output */</span>
<a href="#l19.212"></a><span id="l19.212" class="difflineplus">+                        }</span>
<a href="#l19.213"></a><span id="l19.213" class="difflineplus">+                    }</span>
<a href="#l19.214"></a><span id="l19.214" class="difflineplus">+                    else if (wnext &lt; op) {      /* wrap around window */</span>
<a href="#l19.215"></a><span id="l19.215" class="difflineplus">+                        from += wsize + wnext - op;</span>
<a href="#l19.216"></a><span id="l19.216" class="difflineplus">+                        op -= wnext;</span>
<a href="#l19.217"></a><span id="l19.217" class="difflineplus">+                        if (op &lt; len) {         /* some from end of window */</span>
<a href="#l19.218"></a><span id="l19.218" class="difflineplus">+                            len -= op;</span>
<a href="#l19.219"></a><span id="l19.219" class="difflineplus">+                            do {</span>
<a href="#l19.220"></a><span id="l19.220" class="difflineplus">+                                *out++ = *from++;</span>
<a href="#l19.221"></a><span id="l19.221" class="difflineplus">+                            } while (--op);</span>
<a href="#l19.222"></a><span id="l19.222" class="difflineplus">+                            from = window;</span>
<a href="#l19.223"></a><span id="l19.223" class="difflineplus">+                            if (wnext &lt; len) {  /* some from start of window */</span>
<a href="#l19.224"></a><span id="l19.224" class="difflineplus">+                                op = wnext;</span>
<a href="#l19.225"></a><span id="l19.225" class="difflineplus">+                                len -= op;</span>
<a href="#l19.226"></a><span id="l19.226" class="difflineplus">+                                do {</span>
<a href="#l19.227"></a><span id="l19.227" class="difflineplus">+                                    *out++ = *from++;</span>
<a href="#l19.228"></a><span id="l19.228" class="difflineplus">+                                } while (--op);</span>
<a href="#l19.229"></a><span id="l19.229" class="difflineplus">+                                from = out - dist;      /* rest from output */</span>
<a href="#l19.230"></a><span id="l19.230" class="difflineplus">+                            }</span>
<a href="#l19.231"></a><span id="l19.231" class="difflineplus">+                        }</span>
<a href="#l19.232"></a><span id="l19.232" class="difflineplus">+                    }</span>
<a href="#l19.233"></a><span id="l19.233" class="difflineplus">+                    else {                      /* contiguous in window */</span>
<a href="#l19.234"></a><span id="l19.234" class="difflineplus">+                        from += wnext - op;</span>
<a href="#l19.235"></a><span id="l19.235" class="difflineplus">+                        if (op &lt; len) {         /* some from window */</span>
<a href="#l19.236"></a><span id="l19.236" class="difflineplus">+                            len -= op;</span>
<a href="#l19.237"></a><span id="l19.237" class="difflineplus">+                            do {</span>
<a href="#l19.238"></a><span id="l19.238" class="difflineplus">+                                *out++ = *from++;</span>
<a href="#l19.239"></a><span id="l19.239" class="difflineplus">+                            } while (--op);</span>
<a href="#l19.240"></a><span id="l19.240" class="difflineplus">+                            from = out - dist;  /* rest from output */</span>
<a href="#l19.241"></a><span id="l19.241" class="difflineplus">+                        }</span>
<a href="#l19.242"></a><span id="l19.242" class="difflineplus">+                    }</span>
<a href="#l19.243"></a><span id="l19.243" class="difflineplus">+                    while (len &gt; 2) {</span>
<a href="#l19.244"></a><span id="l19.244" class="difflineplus">+                        *out++ = *from++;</span>
<a href="#l19.245"></a><span id="l19.245" class="difflineplus">+                        *out++ = *from++;</span>
<a href="#l19.246"></a><span id="l19.246" class="difflineplus">+                        *out++ = *from++;</span>
<a href="#l19.247"></a><span id="l19.247" class="difflineplus">+                        len -= 3;</span>
<a href="#l19.248"></a><span id="l19.248" class="difflineplus">+                    }</span>
<a href="#l19.249"></a><span id="l19.249" class="difflineplus">+                    if (len) {</span>
<a href="#l19.250"></a><span id="l19.250" class="difflineplus">+                        *out++ = *from++;</span>
<a href="#l19.251"></a><span id="l19.251" class="difflineplus">+                        if (len &gt; 1)</span>
<a href="#l19.252"></a><span id="l19.252" class="difflineplus">+                            *out++ = *from++;</span>
<a href="#l19.253"></a><span id="l19.253" class="difflineplus">+                    }</span>
<a href="#l19.254"></a><span id="l19.254" class="difflineplus">+                }</span>
<a href="#l19.255"></a><span id="l19.255" class="difflineplus">+                else {</span>
<a href="#l19.256"></a><span id="l19.256" class="difflineplus">+                    from = out - dist;          /* copy direct from output */</span>
<a href="#l19.257"></a><span id="l19.257" class="difflineplus">+                    do {                        /* minimum length is three */</span>
<a href="#l19.258"></a><span id="l19.258" class="difflineplus">+                        *out++ = *from++;</span>
<a href="#l19.259"></a><span id="l19.259" class="difflineplus">+                        *out++ = *from++;</span>
<a href="#l19.260"></a><span id="l19.260" class="difflineplus">+                        *out++ = *from++;</span>
<a href="#l19.261"></a><span id="l19.261" class="difflineplus">+                        len -= 3;</span>
<a href="#l19.262"></a><span id="l19.262" class="difflineplus">+                    } while (len &gt; 2);</span>
<a href="#l19.263"></a><span id="l19.263" class="difflineplus">+                    if (len) {</span>
<a href="#l19.264"></a><span id="l19.264" class="difflineplus">+                        *out++ = *from++;</span>
<a href="#l19.265"></a><span id="l19.265" class="difflineplus">+                        if (len &gt; 1)</span>
<a href="#l19.266"></a><span id="l19.266" class="difflineplus">+                            *out++ = *from++;</span>
<a href="#l19.267"></a><span id="l19.267" class="difflineplus">+                    }</span>
<a href="#l19.268"></a><span id="l19.268" class="difflineplus">+                }</span>
<a href="#l19.269"></a><span id="l19.269" class="difflineplus">+            }</span>
<a href="#l19.270"></a><span id="l19.270" class="difflineplus">+            else if ((op &amp; 64) == 0) {          /* 2nd level distance code */</span>
<a href="#l19.271"></a><span id="l19.271" class="difflineplus">+                here = dcode[here.val + (hold &amp; ((1U &lt;&lt; op) - 1))];</span>
<a href="#l19.272"></a><span id="l19.272" class="difflineplus">+                goto dodist;</span>
<a href="#l19.273"></a><span id="l19.273" class="difflineplus">+            }</span>
<a href="#l19.274"></a><span id="l19.274" class="difflineplus">+            else {</span>
<a href="#l19.275"></a><span id="l19.275" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid distance code&quot;;</span>
<a href="#l19.276"></a><span id="l19.276" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l19.277"></a><span id="l19.277" class="difflineplus">+                break;</span>
<a href="#l19.278"></a><span id="l19.278" class="difflineplus">+            }</span>
<a href="#l19.279"></a><span id="l19.279" class="difflineplus">+        }</span>
<a href="#l19.280"></a><span id="l19.280" class="difflineplus">+        else if ((op &amp; 64) == 0) {              /* 2nd level length code */</span>
<a href="#l19.281"></a><span id="l19.281" class="difflineplus">+            here = lcode[here.val + (hold &amp; ((1U &lt;&lt; op) - 1))];</span>
<a href="#l19.282"></a><span id="l19.282" class="difflineplus">+            goto dolen;</span>
<a href="#l19.283"></a><span id="l19.283" class="difflineplus">+        }</span>
<a href="#l19.284"></a><span id="l19.284" class="difflineplus">+        else if (op &amp; 32) {                     /* end-of-block */</span>
<a href="#l19.285"></a><span id="l19.285" class="difflineplus">+            Tracevv((stderr, &quot;inflate:         end of block\n&quot;));</span>
<a href="#l19.286"></a><span id="l19.286" class="difflineplus">+            state-&gt;mode = TYPE;</span>
<a href="#l19.287"></a><span id="l19.287" class="difflineplus">+            break;</span>
<a href="#l19.288"></a><span id="l19.288" class="difflineplus">+        }</span>
<a href="#l19.289"></a><span id="l19.289" class="difflineplus">+        else {</span>
<a href="#l19.290"></a><span id="l19.290" class="difflineplus">+            strm-&gt;msg = (char *)&quot;invalid literal/length code&quot;;</span>
<a href="#l19.291"></a><span id="l19.291" class="difflineplus">+            state-&gt;mode = BAD;</span>
<a href="#l19.292"></a><span id="l19.292" class="difflineplus">+            break;</span>
<a href="#l19.293"></a><span id="l19.293" class="difflineplus">+        }</span>
<a href="#l19.294"></a><span id="l19.294" class="difflineplus">+    } while (in &lt; last &amp;&amp; out &lt; end);</span>
<a href="#l19.295"></a><span id="l19.295" class="difflineplus">+</span>
<a href="#l19.296"></a><span id="l19.296" class="difflineplus">+    /* return unused bytes (on entry, bits &lt; 8, so in won't go too far back) */</span>
<a href="#l19.297"></a><span id="l19.297" class="difflineplus">+    len = bits &gt;&gt; 3;</span>
<a href="#l19.298"></a><span id="l19.298" class="difflineplus">+    in -= len;</span>
<a href="#l19.299"></a><span id="l19.299" class="difflineplus">+    bits -= len &lt;&lt; 3;</span>
<a href="#l19.300"></a><span id="l19.300" class="difflineplus">+    hold &amp;= (1U &lt;&lt; bits) - 1;</span>
<a href="#l19.301"></a><span id="l19.301" class="difflineplus">+</span>
<a href="#l19.302"></a><span id="l19.302" class="difflineplus">+    /* update state and return */</span>
<a href="#l19.303"></a><span id="l19.303" class="difflineplus">+    strm-&gt;next_in = in;</span>
<a href="#l19.304"></a><span id="l19.304" class="difflineplus">+    strm-&gt;next_out = out;</span>
<a href="#l19.305"></a><span id="l19.305" class="difflineplus">+    strm-&gt;avail_in = (unsigned)(in &lt; last ? 5 + (last - in) : 5 - (in - last));</span>
<a href="#l19.306"></a><span id="l19.306" class="difflineplus">+    strm-&gt;avail_out = (unsigned)(out &lt; end ?</span>
<a href="#l19.307"></a><span id="l19.307" class="difflineplus">+                                 257 + (end - out) : 257 - (out - end));</span>
<a href="#l19.308"></a><span id="l19.308" class="difflineplus">+    state-&gt;hold = hold;</span>
<a href="#l19.309"></a><span id="l19.309" class="difflineplus">+    state-&gt;bits = bits;</span>
<a href="#l19.310"></a><span id="l19.310" class="difflineplus">+    return;</span>
<a href="#l19.311"></a><span id="l19.311" class="difflineplus">+}</span>
<a href="#l19.312"></a><span id="l19.312" class="difflineplus">+</span>
<a href="#l19.313"></a><span id="l19.313" class="difflineplus">+/*</span>
<a href="#l19.314"></a><span id="l19.314" class="difflineplus">+   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):</span>
<a href="#l19.315"></a><span id="l19.315" class="difflineplus">+   - Using bit fields for code structure</span>
<a href="#l19.316"></a><span id="l19.316" class="difflineplus">+   - Different op definition to avoid &amp; for extra bits (do &amp; for table bits)</span>
<a href="#l19.317"></a><span id="l19.317" class="difflineplus">+   - Three separate decoding do-loops for direct, window, and wnext == 0</span>
<a href="#l19.318"></a><span id="l19.318" class="difflineplus">+   - Special case for distance &gt; 1 copies to do overlapped load and store copy</span>
<a href="#l19.319"></a><span id="l19.319" class="difflineplus">+   - Explicit branch predictions (based on measured branch probabilities)</span>
<a href="#l19.320"></a><span id="l19.320" class="difflineplus">+   - Deferring match copy and interspersed it with decoding subsequent codes</span>
<a href="#l19.321"></a><span id="l19.321" class="difflineplus">+   - Swapping literal/length else</span>
<a href="#l19.322"></a><span id="l19.322" class="difflineplus">+   - Swapping window/direct else</span>
<a href="#l19.323"></a><span id="l19.323" class="difflineplus">+   - Larger unrolled copy loops (three is about right)</span>
<a href="#l19.324"></a><span id="l19.324" class="difflineplus">+   - Moving len -= 3 statement into middle of loop</span>
<a href="#l19.325"></a><span id="l19.325" class="difflineplus">+ */</span>
<a href="#l19.326"></a><span id="l19.326" class="difflineplus">+</span>
<a href="#l19.327"></a><span id="l19.327" class="difflineplus">+#endif /* !ASMINF */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1">new file mode 100644</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineminus">--- /dev/null</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineplus">+++ b/third_party/zlib/inffast.h</span>
<a href="#l20.4"></a><span id="l20.4" class="difflineat">@@ -0,0 +1,11 @@</span>
<a href="#l20.5"></a><span id="l20.5" class="difflineplus">+/* inffast.h -- header to use inffast.c</span>
<a href="#l20.6"></a><span id="l20.6" class="difflineplus">+ * Copyright (C) 1995-2003, 2010 Mark Adler</span>
<a href="#l20.7"></a><span id="l20.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l20.8"></a><span id="l20.8" class="difflineplus">+ */</span>
<a href="#l20.9"></a><span id="l20.9" class="difflineplus">+</span>
<a href="#l20.10"></a><span id="l20.10" class="difflineplus">+/* WARNING: this file should *not* be used by applications. It is</span>
<a href="#l20.11"></a><span id="l20.11" class="difflineplus">+   part of the implementation of the compression library and is</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineplus">+   subject to change. Applications should only use zlib.h.</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+ */</span>
<a href="#l20.14"></a><span id="l20.14" class="difflineplus">+</span>
<a href="#l20.15"></a><span id="l20.15" class="difflineplus">+void ZLIB_INTERNAL inflate_fast OF((z_streamp strm, unsigned start));</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1">new file mode 100644</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineminus">--- /dev/null</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineplus">+++ b/third_party/zlib/inffixed.h</span>
<a href="#l21.4"></a><span id="l21.4" class="difflineat">@@ -0,0 +1,94 @@</span>
<a href="#l21.5"></a><span id="l21.5" class="difflineplus">+    /* inffixed.h -- table for decoding fixed codes</span>
<a href="#l21.6"></a><span id="l21.6" class="difflineplus">+     * Generated automatically by makefixed().</span>
<a href="#l21.7"></a><span id="l21.7" class="difflineplus">+     */</span>
<a href="#l21.8"></a><span id="l21.8" class="difflineplus">+</span>
<a href="#l21.9"></a><span id="l21.9" class="difflineplus">+    /* WARNING: this file should *not* be used by applications.</span>
<a href="#l21.10"></a><span id="l21.10" class="difflineplus">+       It is part of the implementation of this library and is</span>
<a href="#l21.11"></a><span id="l21.11" class="difflineplus">+       subject to change. Applications should only use zlib.h.</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineplus">+     */</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+</span>
<a href="#l21.14"></a><span id="l21.14" class="difflineplus">+    static const code lenfix[512] = {</span>
<a href="#l21.15"></a><span id="l21.15" class="difflineplus">+        {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},</span>
<a href="#l21.16"></a><span id="l21.16" class="difflineplus">+        {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},</span>
<a href="#l21.17"></a><span id="l21.17" class="difflineplus">+        {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},</span>
<a href="#l21.18"></a><span id="l21.18" class="difflineplus">+        {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},</span>
<a href="#l21.19"></a><span id="l21.19" class="difflineplus">+        {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},</span>
<a href="#l21.20"></a><span id="l21.20" class="difflineplus">+        {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},</span>
<a href="#l21.21"></a><span id="l21.21" class="difflineplus">+        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},</span>
<a href="#l21.22"></a><span id="l21.22" class="difflineplus">+        {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},</span>
<a href="#l21.23"></a><span id="l21.23" class="difflineplus">+        {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},</span>
<a href="#l21.24"></a><span id="l21.24" class="difflineplus">+        {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},</span>
<a href="#l21.25"></a><span id="l21.25" class="difflineplus">+        {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},</span>
<a href="#l21.26"></a><span id="l21.26" class="difflineplus">+        {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},</span>
<a href="#l21.27"></a><span id="l21.27" class="difflineplus">+        {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},</span>
<a href="#l21.28"></a><span id="l21.28" class="difflineplus">+        {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},</span>
<a href="#l21.29"></a><span id="l21.29" class="difflineplus">+        {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},</span>
<a href="#l21.30"></a><span id="l21.30" class="difflineplus">+        {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},</span>
<a href="#l21.31"></a><span id="l21.31" class="difflineplus">+        {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},</span>
<a href="#l21.32"></a><span id="l21.32" class="difflineplus">+        {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},</span>
<a href="#l21.33"></a><span id="l21.33" class="difflineplus">+        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},</span>
<a href="#l21.34"></a><span id="l21.34" class="difflineplus">+        {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},</span>
<a href="#l21.35"></a><span id="l21.35" class="difflineplus">+        {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},</span>
<a href="#l21.36"></a><span id="l21.36" class="difflineplus">+        {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},</span>
<a href="#l21.37"></a><span id="l21.37" class="difflineplus">+        {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},</span>
<a href="#l21.38"></a><span id="l21.38" class="difflineplus">+        {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},</span>
<a href="#l21.39"></a><span id="l21.39" class="difflineplus">+        {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},</span>
<a href="#l21.40"></a><span id="l21.40" class="difflineplus">+        {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},</span>
<a href="#l21.41"></a><span id="l21.41" class="difflineplus">+        {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},</span>
<a href="#l21.42"></a><span id="l21.42" class="difflineplus">+        {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},</span>
<a href="#l21.43"></a><span id="l21.43" class="difflineplus">+        {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},</span>
<a href="#l21.44"></a><span id="l21.44" class="difflineplus">+        {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},</span>
<a href="#l21.45"></a><span id="l21.45" class="difflineplus">+        {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},</span>
<a href="#l21.46"></a><span id="l21.46" class="difflineplus">+        {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},</span>
<a href="#l21.47"></a><span id="l21.47" class="difflineplus">+        {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},</span>
<a href="#l21.48"></a><span id="l21.48" class="difflineplus">+        {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},</span>
<a href="#l21.49"></a><span id="l21.49" class="difflineplus">+        {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},</span>
<a href="#l21.50"></a><span id="l21.50" class="difflineplus">+        {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},</span>
<a href="#l21.51"></a><span id="l21.51" class="difflineplus">+        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},</span>
<a href="#l21.52"></a><span id="l21.52" class="difflineplus">+        {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},</span>
<a href="#l21.53"></a><span id="l21.53" class="difflineplus">+        {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},</span>
<a href="#l21.54"></a><span id="l21.54" class="difflineplus">+        {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},</span>
<a href="#l21.55"></a><span id="l21.55" class="difflineplus">+        {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},</span>
<a href="#l21.56"></a><span id="l21.56" class="difflineplus">+        {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},</span>
<a href="#l21.57"></a><span id="l21.57" class="difflineplus">+        {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},</span>
<a href="#l21.58"></a><span id="l21.58" class="difflineplus">+        {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},</span>
<a href="#l21.59"></a><span id="l21.59" class="difflineplus">+        {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},</span>
<a href="#l21.60"></a><span id="l21.60" class="difflineplus">+        {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},</span>
<a href="#l21.61"></a><span id="l21.61" class="difflineplus">+        {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},</span>
<a href="#l21.62"></a><span id="l21.62" class="difflineplus">+        {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},</span>
<a href="#l21.63"></a><span id="l21.63" class="difflineplus">+        {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},</span>
<a href="#l21.64"></a><span id="l21.64" class="difflineplus">+        {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},</span>
<a href="#l21.65"></a><span id="l21.65" class="difflineplus">+        {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},</span>
<a href="#l21.66"></a><span id="l21.66" class="difflineplus">+        {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},</span>
<a href="#l21.67"></a><span id="l21.67" class="difflineplus">+        {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},</span>
<a href="#l21.68"></a><span id="l21.68" class="difflineplus">+        {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},</span>
<a href="#l21.69"></a><span id="l21.69" class="difflineplus">+        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},</span>
<a href="#l21.70"></a><span id="l21.70" class="difflineplus">+        {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},</span>
<a href="#l21.71"></a><span id="l21.71" class="difflineplus">+        {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},</span>
<a href="#l21.72"></a><span id="l21.72" class="difflineplus">+        {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},</span>
<a href="#l21.73"></a><span id="l21.73" class="difflineplus">+        {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},</span>
<a href="#l21.74"></a><span id="l21.74" class="difflineplus">+        {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},</span>
<a href="#l21.75"></a><span id="l21.75" class="difflineplus">+        {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},</span>
<a href="#l21.76"></a><span id="l21.76" class="difflineplus">+        {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},</span>
<a href="#l21.77"></a><span id="l21.77" class="difflineplus">+        {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},</span>
<a href="#l21.78"></a><span id="l21.78" class="difflineplus">+        {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},</span>
<a href="#l21.79"></a><span id="l21.79" class="difflineplus">+        {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},</span>
<a href="#l21.80"></a><span id="l21.80" class="difflineplus">+        {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},</span>
<a href="#l21.81"></a><span id="l21.81" class="difflineplus">+        {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},</span>
<a href="#l21.82"></a><span id="l21.82" class="difflineplus">+        {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},</span>
<a href="#l21.83"></a><span id="l21.83" class="difflineplus">+        {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},</span>
<a href="#l21.84"></a><span id="l21.84" class="difflineplus">+        {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},</span>
<a href="#l21.85"></a><span id="l21.85" class="difflineplus">+        {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},</span>
<a href="#l21.86"></a><span id="l21.86" class="difflineplus">+        {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},</span>
<a href="#l21.87"></a><span id="l21.87" class="difflineplus">+        {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},</span>
<a href="#l21.88"></a><span id="l21.88" class="difflineplus">+        {0,9,255}</span>
<a href="#l21.89"></a><span id="l21.89" class="difflineplus">+    };</span>
<a href="#l21.90"></a><span id="l21.90" class="difflineplus">+</span>
<a href="#l21.91"></a><span id="l21.91" class="difflineplus">+    static const code distfix[32] = {</span>
<a href="#l21.92"></a><span id="l21.92" class="difflineplus">+        {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},</span>
<a href="#l21.93"></a><span id="l21.93" class="difflineplus">+        {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},</span>
<a href="#l21.94"></a><span id="l21.94" class="difflineplus">+        {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},</span>
<a href="#l21.95"></a><span id="l21.95" class="difflineplus">+        {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},</span>
<a href="#l21.96"></a><span id="l21.96" class="difflineplus">+        {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},</span>
<a href="#l21.97"></a><span id="l21.97" class="difflineplus">+        {22,5,193},{64,5,0}</span>
<a href="#l21.98"></a><span id="l21.98" class="difflineplus">+    };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1">new file mode 100644</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineminus">--- /dev/null</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineplus">+++ b/third_party/zlib/inflate.c</span>
<a href="#l22.4"></a><span id="l22.4" class="difflineat">@@ -0,0 +1,1561 @@</span>
<a href="#l22.5"></a><span id="l22.5" class="difflineplus">+/* inflate.c -- zlib decompression</span>
<a href="#l22.6"></a><span id="l22.6" class="difflineplus">+ * Copyright (C) 1995-2016 Mark Adler</span>
<a href="#l22.7"></a><span id="l22.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l22.8"></a><span id="l22.8" class="difflineplus">+ */</span>
<a href="#l22.9"></a><span id="l22.9" class="difflineplus">+</span>
<a href="#l22.10"></a><span id="l22.10" class="difflineplus">+/*</span>
<a href="#l22.11"></a><span id="l22.11" class="difflineplus">+ * Change history:</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineplus">+ *</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+ * 1.2.beta0    24 Nov 2002</span>
<a href="#l22.14"></a><span id="l22.14" class="difflineplus">+ * - First version -- complete rewrite of inflate to simplify code, avoid</span>
<a href="#l22.15"></a><span id="l22.15" class="difflineplus">+ *   creation of window when not needed, minimize use of window when it is</span>
<a href="#l22.16"></a><span id="l22.16" class="difflineplus">+ *   needed, make inffast.c even faster, implement gzip decoding, and to</span>
<a href="#l22.17"></a><span id="l22.17" class="difflineplus">+ *   improve code readability and style over the previous zlib inflate code</span>
<a href="#l22.18"></a><span id="l22.18" class="difflineplus">+ *</span>
<a href="#l22.19"></a><span id="l22.19" class="difflineplus">+ * 1.2.beta1    25 Nov 2002</span>
<a href="#l22.20"></a><span id="l22.20" class="difflineplus">+ * - Use pointers for available input and output checking in inffast.c</span>
<a href="#l22.21"></a><span id="l22.21" class="difflineplus">+ * - Remove input and output counters in inffast.c</span>
<a href="#l22.22"></a><span id="l22.22" class="difflineplus">+ * - Change inffast.c entry and loop from avail_in &gt;= 7 to &gt;= 6</span>
<a href="#l22.23"></a><span id="l22.23" class="difflineplus">+ * - Remove unnecessary second byte pull from length extra in inffast.c</span>
<a href="#l22.24"></a><span id="l22.24" class="difflineplus">+ * - Unroll direct copy to three copies per loop in inffast.c</span>
<a href="#l22.25"></a><span id="l22.25" class="difflineplus">+ *</span>
<a href="#l22.26"></a><span id="l22.26" class="difflineplus">+ * 1.2.beta2    4 Dec 2002</span>
<a href="#l22.27"></a><span id="l22.27" class="difflineplus">+ * - Change external routine names to reduce potential conflicts</span>
<a href="#l22.28"></a><span id="l22.28" class="difflineplus">+ * - Correct filename to inffixed.h for fixed tables in inflate.c</span>
<a href="#l22.29"></a><span id="l22.29" class="difflineplus">+ * - Make hbuf[] unsigned char to match parameter type in inflate.c</span>
<a href="#l22.30"></a><span id="l22.30" class="difflineplus">+ * - Change strm-&gt;next_out[-state-&gt;offset] to *(strm-&gt;next_out - state-&gt;offset)</span>
<a href="#l22.31"></a><span id="l22.31" class="difflineplus">+ *   to avoid negation problem on Alphas (64 bit) in inflate.c</span>
<a href="#l22.32"></a><span id="l22.32" class="difflineplus">+ *</span>
<a href="#l22.33"></a><span id="l22.33" class="difflineplus">+ * 1.2.beta3    22 Dec 2002</span>
<a href="#l22.34"></a><span id="l22.34" class="difflineplus">+ * - Add comments on state-&gt;bits assertion in inffast.c</span>
<a href="#l22.35"></a><span id="l22.35" class="difflineplus">+ * - Add comments on op field in inftrees.h</span>
<a href="#l22.36"></a><span id="l22.36" class="difflineplus">+ * - Fix bug in reuse of allocated window after inflateReset()</span>
<a href="#l22.37"></a><span id="l22.37" class="difflineplus">+ * - Remove bit fields--back to byte structure for speed</span>
<a href="#l22.38"></a><span id="l22.38" class="difflineplus">+ * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths</span>
<a href="#l22.39"></a><span id="l22.39" class="difflineplus">+ * - Change post-increments to pre-increments in inflate_fast(), PPC biased?</span>
<a href="#l22.40"></a><span id="l22.40" class="difflineplus">+ * - Add compile time option, POSTINC, to use post-increments instead (Intel?)</span>
<a href="#l22.41"></a><span id="l22.41" class="difflineplus">+ * - Make MATCH copy in inflate() much faster for when inflate_fast() not used</span>
<a href="#l22.42"></a><span id="l22.42" class="difflineplus">+ * - Use local copies of stream next and avail values, as well as local bit</span>
<a href="#l22.43"></a><span id="l22.43" class="difflineplus">+ *   buffer and bit count in inflate()--for speed when inflate_fast() not used</span>
<a href="#l22.44"></a><span id="l22.44" class="difflineplus">+ *</span>
<a href="#l22.45"></a><span id="l22.45" class="difflineplus">+ * 1.2.beta4    1 Jan 2003</span>
<a href="#l22.46"></a><span id="l22.46" class="difflineplus">+ * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings</span>
<a href="#l22.47"></a><span id="l22.47" class="difflineplus">+ * - Move a comment on output buffer sizes from inffast.c to inflate.c</span>
<a href="#l22.48"></a><span id="l22.48" class="difflineplus">+ * - Add comments in inffast.c to introduce the inflate_fast() routine</span>
<a href="#l22.49"></a><span id="l22.49" class="difflineplus">+ * - Rearrange window copies in inflate_fast() for speed and simplification</span>
<a href="#l22.50"></a><span id="l22.50" class="difflineplus">+ * - Unroll last copy for window match in inflate_fast()</span>
<a href="#l22.51"></a><span id="l22.51" class="difflineplus">+ * - Use local copies of window variables in inflate_fast() for speed</span>
<a href="#l22.52"></a><span id="l22.52" class="difflineplus">+ * - Pull out common wnext == 0 case for speed in inflate_fast()</span>
<a href="#l22.53"></a><span id="l22.53" class="difflineplus">+ * - Make op and len in inflate_fast() unsigned for consistency</span>
<a href="#l22.54"></a><span id="l22.54" class="difflineplus">+ * - Add FAR to lcode and dcode declarations in inflate_fast()</span>
<a href="#l22.55"></a><span id="l22.55" class="difflineplus">+ * - Simplified bad distance check in inflate_fast()</span>
<a href="#l22.56"></a><span id="l22.56" class="difflineplus">+ * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new</span>
<a href="#l22.57"></a><span id="l22.57" class="difflineplus">+ *   source file infback.c to provide a call-back interface to inflate for</span>
<a href="#l22.58"></a><span id="l22.58" class="difflineplus">+ *   programs like gzip and unzip -- uses window as output buffer to avoid</span>
<a href="#l22.59"></a><span id="l22.59" class="difflineplus">+ *   window copying</span>
<a href="#l22.60"></a><span id="l22.60" class="difflineplus">+ *</span>
<a href="#l22.61"></a><span id="l22.61" class="difflineplus">+ * 1.2.beta5    1 Jan 2003</span>
<a href="#l22.62"></a><span id="l22.62" class="difflineplus">+ * - Improved inflateBack() interface to allow the caller to provide initial</span>
<a href="#l22.63"></a><span id="l22.63" class="difflineplus">+ *   input in strm.</span>
<a href="#l22.64"></a><span id="l22.64" class="difflineplus">+ * - Fixed stored blocks bug in inflateBack()</span>
<a href="#l22.65"></a><span id="l22.65" class="difflineplus">+ *</span>
<a href="#l22.66"></a><span id="l22.66" class="difflineplus">+ * 1.2.beta6    4 Jan 2003</span>
<a href="#l22.67"></a><span id="l22.67" class="difflineplus">+ * - Added comments in inffast.c on effectiveness of POSTINC</span>
<a href="#l22.68"></a><span id="l22.68" class="difflineplus">+ * - Typecasting all around to reduce compiler warnings</span>
<a href="#l22.69"></a><span id="l22.69" class="difflineplus">+ * - Changed loops from while (1) or do {} while (1) to for (;;), again to</span>
<a href="#l22.70"></a><span id="l22.70" class="difflineplus">+ *   make compilers happy</span>
<a href="#l22.71"></a><span id="l22.71" class="difflineplus">+ * - Changed type of window in inflateBackInit() to unsigned char *</span>
<a href="#l22.72"></a><span id="l22.72" class="difflineplus">+ *</span>
<a href="#l22.73"></a><span id="l22.73" class="difflineplus">+ * 1.2.beta7    27 Jan 2003</span>
<a href="#l22.74"></a><span id="l22.74" class="difflineplus">+ * - Changed many types to unsigned or unsigned short to avoid warnings</span>
<a href="#l22.75"></a><span id="l22.75" class="difflineplus">+ * - Added inflateCopy() function</span>
<a href="#l22.76"></a><span id="l22.76" class="difflineplus">+ *</span>
<a href="#l22.77"></a><span id="l22.77" class="difflineplus">+ * 1.2.0        9 Mar 2003</span>
<a href="#l22.78"></a><span id="l22.78" class="difflineplus">+ * - Changed inflateBack() interface to provide separate opaque descriptors</span>
<a href="#l22.79"></a><span id="l22.79" class="difflineplus">+ *   for the in() and out() functions</span>
<a href="#l22.80"></a><span id="l22.80" class="difflineplus">+ * - Changed inflateBack() argument and in_func typedef to swap the length</span>
<a href="#l22.81"></a><span id="l22.81" class="difflineplus">+ *   and buffer address return values for the input function</span>
<a href="#l22.82"></a><span id="l22.82" class="difflineplus">+ * - Check next_in and next_out for Z_NULL on entry to inflate()</span>
<a href="#l22.83"></a><span id="l22.83" class="difflineplus">+ *</span>
<a href="#l22.84"></a><span id="l22.84" class="difflineplus">+ * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.</span>
<a href="#l22.85"></a><span id="l22.85" class="difflineplus">+ */</span>
<a href="#l22.86"></a><span id="l22.86" class="difflineplus">+</span>
<a href="#l22.87"></a><span id="l22.87" class="difflineplus">+#include &quot;zutil.h&quot;</span>
<a href="#l22.88"></a><span id="l22.88" class="difflineplus">+#include &quot;inftrees.h&quot;</span>
<a href="#l22.89"></a><span id="l22.89" class="difflineplus">+#include &quot;inflate.h&quot;</span>
<a href="#l22.90"></a><span id="l22.90" class="difflineplus">+#include &quot;inffast.h&quot;</span>
<a href="#l22.91"></a><span id="l22.91" class="difflineplus">+</span>
<a href="#l22.92"></a><span id="l22.92" class="difflineplus">+#ifdef MAKEFIXED</span>
<a href="#l22.93"></a><span id="l22.93" class="difflineplus">+#  ifndef BUILDFIXED</span>
<a href="#l22.94"></a><span id="l22.94" class="difflineplus">+#    define BUILDFIXED</span>
<a href="#l22.95"></a><span id="l22.95" class="difflineplus">+#  endif</span>
<a href="#l22.96"></a><span id="l22.96" class="difflineplus">+#endif</span>
<a href="#l22.97"></a><span id="l22.97" class="difflineplus">+</span>
<a href="#l22.98"></a><span id="l22.98" class="difflineplus">+/* function prototypes */</span>
<a href="#l22.99"></a><span id="l22.99" class="difflineplus">+local int inflateStateCheck OF((z_streamp strm));</span>
<a href="#l22.100"></a><span id="l22.100" class="difflineplus">+local void fixedtables OF((struct inflate_state FAR *state));</span>
<a href="#l22.101"></a><span id="l22.101" class="difflineplus">+local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,</span>
<a href="#l22.102"></a><span id="l22.102" class="difflineplus">+                           unsigned copy));</span>
<a href="#l22.103"></a><span id="l22.103" class="difflineplus">+#ifdef BUILDFIXED</span>
<a href="#l22.104"></a><span id="l22.104" class="difflineplus">+   void makefixed OF((void));</span>
<a href="#l22.105"></a><span id="l22.105" class="difflineplus">+#endif</span>
<a href="#l22.106"></a><span id="l22.106" class="difflineplus">+local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,</span>
<a href="#l22.107"></a><span id="l22.107" class="difflineplus">+                              unsigned len));</span>
<a href="#l22.108"></a><span id="l22.108" class="difflineplus">+</span>
<a href="#l22.109"></a><span id="l22.109" class="difflineplus">+local int inflateStateCheck(strm)</span>
<a href="#l22.110"></a><span id="l22.110" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.111"></a><span id="l22.111" class="difflineplus">+{</span>
<a href="#l22.112"></a><span id="l22.112" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.113"></a><span id="l22.113" class="difflineplus">+    if (strm == Z_NULL ||</span>
<a href="#l22.114"></a><span id="l22.114" class="difflineplus">+        strm-&gt;zalloc == (alloc_func)0 || strm-&gt;zfree == (free_func)0)</span>
<a href="#l22.115"></a><span id="l22.115" class="difflineplus">+        return 1;</span>
<a href="#l22.116"></a><span id="l22.116" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.117"></a><span id="l22.117" class="difflineplus">+    if (state == Z_NULL || state-&gt;strm != strm ||</span>
<a href="#l22.118"></a><span id="l22.118" class="difflineplus">+        state-&gt;mode &lt; HEAD || state-&gt;mode &gt; SYNC)</span>
<a href="#l22.119"></a><span id="l22.119" class="difflineplus">+        return 1;</span>
<a href="#l22.120"></a><span id="l22.120" class="difflineplus">+    return 0;</span>
<a href="#l22.121"></a><span id="l22.121" class="difflineplus">+}</span>
<a href="#l22.122"></a><span id="l22.122" class="difflineplus">+</span>
<a href="#l22.123"></a><span id="l22.123" class="difflineplus">+int ZEXPORT inflateResetKeep(strm)</span>
<a href="#l22.124"></a><span id="l22.124" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.125"></a><span id="l22.125" class="difflineplus">+{</span>
<a href="#l22.126"></a><span id="l22.126" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.127"></a><span id="l22.127" class="difflineplus">+</span>
<a href="#l22.128"></a><span id="l22.128" class="difflineplus">+    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l22.129"></a><span id="l22.129" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.130"></a><span id="l22.130" class="difflineplus">+    strm-&gt;total_in = strm-&gt;total_out = state-&gt;total = 0;</span>
<a href="#l22.131"></a><span id="l22.131" class="difflineplus">+    strm-&gt;msg = Z_NULL;</span>
<a href="#l22.132"></a><span id="l22.132" class="difflineplus">+    if (state-&gt;wrap)        /* to support ill-conceived Java test suite */</span>
<a href="#l22.133"></a><span id="l22.133" class="difflineplus">+        strm-&gt;adler = state-&gt;wrap &amp; 1;</span>
<a href="#l22.134"></a><span id="l22.134" class="difflineplus">+    state-&gt;mode = HEAD;</span>
<a href="#l22.135"></a><span id="l22.135" class="difflineplus">+    state-&gt;last = 0;</span>
<a href="#l22.136"></a><span id="l22.136" class="difflineplus">+    state-&gt;havedict = 0;</span>
<a href="#l22.137"></a><span id="l22.137" class="difflineplus">+    state-&gt;dmax = 32768U;</span>
<a href="#l22.138"></a><span id="l22.138" class="difflineplus">+    state-&gt;head = Z_NULL;</span>
<a href="#l22.139"></a><span id="l22.139" class="difflineplus">+    state-&gt;hold = 0;</span>
<a href="#l22.140"></a><span id="l22.140" class="difflineplus">+    state-&gt;bits = 0;</span>
<a href="#l22.141"></a><span id="l22.141" class="difflineplus">+    state-&gt;lencode = state-&gt;distcode = state-&gt;next = state-&gt;codes;</span>
<a href="#l22.142"></a><span id="l22.142" class="difflineplus">+    state-&gt;sane = 1;</span>
<a href="#l22.143"></a><span id="l22.143" class="difflineplus">+    state-&gt;back = -1;</span>
<a href="#l22.144"></a><span id="l22.144" class="difflineplus">+    Tracev((stderr, &quot;inflate: reset\n&quot;));</span>
<a href="#l22.145"></a><span id="l22.145" class="difflineplus">+    return Z_OK;</span>
<a href="#l22.146"></a><span id="l22.146" class="difflineplus">+}</span>
<a href="#l22.147"></a><span id="l22.147" class="difflineplus">+</span>
<a href="#l22.148"></a><span id="l22.148" class="difflineplus">+int ZEXPORT inflateReset(strm)</span>
<a href="#l22.149"></a><span id="l22.149" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.150"></a><span id="l22.150" class="difflineplus">+{</span>
<a href="#l22.151"></a><span id="l22.151" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.152"></a><span id="l22.152" class="difflineplus">+</span>
<a href="#l22.153"></a><span id="l22.153" class="difflineplus">+    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l22.154"></a><span id="l22.154" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.155"></a><span id="l22.155" class="difflineplus">+    state-&gt;wsize = 0;</span>
<a href="#l22.156"></a><span id="l22.156" class="difflineplus">+    state-&gt;whave = 0;</span>
<a href="#l22.157"></a><span id="l22.157" class="difflineplus">+    state-&gt;wnext = 0;</span>
<a href="#l22.158"></a><span id="l22.158" class="difflineplus">+    return inflateResetKeep(strm);</span>
<a href="#l22.159"></a><span id="l22.159" class="difflineplus">+}</span>
<a href="#l22.160"></a><span id="l22.160" class="difflineplus">+</span>
<a href="#l22.161"></a><span id="l22.161" class="difflineplus">+int ZEXPORT inflateReset2(strm, windowBits)</span>
<a href="#l22.162"></a><span id="l22.162" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.163"></a><span id="l22.163" class="difflineplus">+int windowBits;</span>
<a href="#l22.164"></a><span id="l22.164" class="difflineplus">+{</span>
<a href="#l22.165"></a><span id="l22.165" class="difflineplus">+    int wrap;</span>
<a href="#l22.166"></a><span id="l22.166" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.167"></a><span id="l22.167" class="difflineplus">+</span>
<a href="#l22.168"></a><span id="l22.168" class="difflineplus">+    /* get the state */</span>
<a href="#l22.169"></a><span id="l22.169" class="difflineplus">+    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l22.170"></a><span id="l22.170" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.171"></a><span id="l22.171" class="difflineplus">+</span>
<a href="#l22.172"></a><span id="l22.172" class="difflineplus">+    /* extract wrap request from windowBits parameter */</span>
<a href="#l22.173"></a><span id="l22.173" class="difflineplus">+    if (windowBits &lt; 0) {</span>
<a href="#l22.174"></a><span id="l22.174" class="difflineplus">+        wrap = 0;</span>
<a href="#l22.175"></a><span id="l22.175" class="difflineplus">+        windowBits = -windowBits;</span>
<a href="#l22.176"></a><span id="l22.176" class="difflineplus">+    }</span>
<a href="#l22.177"></a><span id="l22.177" class="difflineplus">+    else {</span>
<a href="#l22.178"></a><span id="l22.178" class="difflineplus">+        wrap = (windowBits &gt;&gt; 4) + 5;</span>
<a href="#l22.179"></a><span id="l22.179" class="difflineplus">+#ifdef GUNZIP</span>
<a href="#l22.180"></a><span id="l22.180" class="difflineplus">+        if (windowBits &lt; 48)</span>
<a href="#l22.181"></a><span id="l22.181" class="difflineplus">+            windowBits &amp;= 15;</span>
<a href="#l22.182"></a><span id="l22.182" class="difflineplus">+#endif</span>
<a href="#l22.183"></a><span id="l22.183" class="difflineplus">+    }</span>
<a href="#l22.184"></a><span id="l22.184" class="difflineplus">+</span>
<a href="#l22.185"></a><span id="l22.185" class="difflineplus">+    /* set number of window bits, free window if different */</span>
<a href="#l22.186"></a><span id="l22.186" class="difflineplus">+    if (windowBits &amp;&amp; (windowBits &lt; 8 || windowBits &gt; 15))</span>
<a href="#l22.187"></a><span id="l22.187" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l22.188"></a><span id="l22.188" class="difflineplus">+    if (state-&gt;window != Z_NULL &amp;&amp; state-&gt;wbits != (unsigned)windowBits) {</span>
<a href="#l22.189"></a><span id="l22.189" class="difflineplus">+        ZFREE(strm, state-&gt;window);</span>
<a href="#l22.190"></a><span id="l22.190" class="difflineplus">+        state-&gt;window = Z_NULL;</span>
<a href="#l22.191"></a><span id="l22.191" class="difflineplus">+    }</span>
<a href="#l22.192"></a><span id="l22.192" class="difflineplus">+</span>
<a href="#l22.193"></a><span id="l22.193" class="difflineplus">+    /* update state and reset the rest of it */</span>
<a href="#l22.194"></a><span id="l22.194" class="difflineplus">+    state-&gt;wrap = wrap;</span>
<a href="#l22.195"></a><span id="l22.195" class="difflineplus">+    state-&gt;wbits = (unsigned)windowBits;</span>
<a href="#l22.196"></a><span id="l22.196" class="difflineplus">+    return inflateReset(strm);</span>
<a href="#l22.197"></a><span id="l22.197" class="difflineplus">+}</span>
<a href="#l22.198"></a><span id="l22.198" class="difflineplus">+</span>
<a href="#l22.199"></a><span id="l22.199" class="difflineplus">+int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)</span>
<a href="#l22.200"></a><span id="l22.200" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.201"></a><span id="l22.201" class="difflineplus">+int windowBits;</span>
<a href="#l22.202"></a><span id="l22.202" class="difflineplus">+const char *version;</span>
<a href="#l22.203"></a><span id="l22.203" class="difflineplus">+int stream_size;</span>
<a href="#l22.204"></a><span id="l22.204" class="difflineplus">+{</span>
<a href="#l22.205"></a><span id="l22.205" class="difflineplus">+    int ret;</span>
<a href="#l22.206"></a><span id="l22.206" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.207"></a><span id="l22.207" class="difflineplus">+</span>
<a href="#l22.208"></a><span id="l22.208" class="difflineplus">+    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||</span>
<a href="#l22.209"></a><span id="l22.209" class="difflineplus">+        stream_size != (int)(sizeof(z_stream)))</span>
<a href="#l22.210"></a><span id="l22.210" class="difflineplus">+        return Z_VERSION_ERROR;</span>
<a href="#l22.211"></a><span id="l22.211" class="difflineplus">+    if (strm == Z_NULL) return Z_STREAM_ERROR;</span>
<a href="#l22.212"></a><span id="l22.212" class="difflineplus">+    strm-&gt;msg = Z_NULL;                 /* in case we return an error */</span>
<a href="#l22.213"></a><span id="l22.213" class="difflineplus">+    if (strm-&gt;zalloc == (alloc_func)0) {</span>
<a href="#l22.214"></a><span id="l22.214" class="difflineplus">+#ifdef Z_SOLO</span>
<a href="#l22.215"></a><span id="l22.215" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l22.216"></a><span id="l22.216" class="difflineplus">+#else</span>
<a href="#l22.217"></a><span id="l22.217" class="difflineplus">+        strm-&gt;zalloc = zcalloc;</span>
<a href="#l22.218"></a><span id="l22.218" class="difflineplus">+        strm-&gt;opaque = (voidpf)0;</span>
<a href="#l22.219"></a><span id="l22.219" class="difflineplus">+#endif</span>
<a href="#l22.220"></a><span id="l22.220" class="difflineplus">+    }</span>
<a href="#l22.221"></a><span id="l22.221" class="difflineplus">+    if (strm-&gt;zfree == (free_func)0)</span>
<a href="#l22.222"></a><span id="l22.222" class="difflineplus">+#ifdef Z_SOLO</span>
<a href="#l22.223"></a><span id="l22.223" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l22.224"></a><span id="l22.224" class="difflineplus">+#else</span>
<a href="#l22.225"></a><span id="l22.225" class="difflineplus">+        strm-&gt;zfree = zcfree;</span>
<a href="#l22.226"></a><span id="l22.226" class="difflineplus">+#endif</span>
<a href="#l22.227"></a><span id="l22.227" class="difflineplus">+    state = (struct inflate_state FAR *)</span>
<a href="#l22.228"></a><span id="l22.228" class="difflineplus">+            ZALLOC(strm, 1, sizeof(struct inflate_state));</span>
<a href="#l22.229"></a><span id="l22.229" class="difflineplus">+    if (state == Z_NULL) return Z_MEM_ERROR;</span>
<a href="#l22.230"></a><span id="l22.230" class="difflineplus">+    Tracev((stderr, &quot;inflate: allocated\n&quot;));</span>
<a href="#l22.231"></a><span id="l22.231" class="difflineplus">+    strm-&gt;state = (struct internal_state FAR *)state;</span>
<a href="#l22.232"></a><span id="l22.232" class="difflineplus">+    state-&gt;strm = strm;</span>
<a href="#l22.233"></a><span id="l22.233" class="difflineplus">+    state-&gt;window = Z_NULL;</span>
<a href="#l22.234"></a><span id="l22.234" class="difflineplus">+    state-&gt;mode = HEAD;     /* to pass state test in inflateReset2() */</span>
<a href="#l22.235"></a><span id="l22.235" class="difflineplus">+    ret = inflateReset2(strm, windowBits);</span>
<a href="#l22.236"></a><span id="l22.236" class="difflineplus">+    if (ret != Z_OK) {</span>
<a href="#l22.237"></a><span id="l22.237" class="difflineplus">+        ZFREE(strm, state);</span>
<a href="#l22.238"></a><span id="l22.238" class="difflineplus">+        strm-&gt;state = Z_NULL;</span>
<a href="#l22.239"></a><span id="l22.239" class="difflineplus">+    }</span>
<a href="#l22.240"></a><span id="l22.240" class="difflineplus">+    return ret;</span>
<a href="#l22.241"></a><span id="l22.241" class="difflineplus">+}</span>
<a href="#l22.242"></a><span id="l22.242" class="difflineplus">+</span>
<a href="#l22.243"></a><span id="l22.243" class="difflineplus">+int ZEXPORT inflateInit_(strm, version, stream_size)</span>
<a href="#l22.244"></a><span id="l22.244" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.245"></a><span id="l22.245" class="difflineplus">+const char *version;</span>
<a href="#l22.246"></a><span id="l22.246" class="difflineplus">+int stream_size;</span>
<a href="#l22.247"></a><span id="l22.247" class="difflineplus">+{</span>
<a href="#l22.248"></a><span id="l22.248" class="difflineplus">+    return inflateInit2_(strm, DEF_WBITS, version, stream_size);</span>
<a href="#l22.249"></a><span id="l22.249" class="difflineplus">+}</span>
<a href="#l22.250"></a><span id="l22.250" class="difflineplus">+</span>
<a href="#l22.251"></a><span id="l22.251" class="difflineplus">+int ZEXPORT inflatePrime(strm, bits, value)</span>
<a href="#l22.252"></a><span id="l22.252" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.253"></a><span id="l22.253" class="difflineplus">+int bits;</span>
<a href="#l22.254"></a><span id="l22.254" class="difflineplus">+int value;</span>
<a href="#l22.255"></a><span id="l22.255" class="difflineplus">+{</span>
<a href="#l22.256"></a><span id="l22.256" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.257"></a><span id="l22.257" class="difflineplus">+</span>
<a href="#l22.258"></a><span id="l22.258" class="difflineplus">+    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l22.259"></a><span id="l22.259" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.260"></a><span id="l22.260" class="difflineplus">+    if (bits &lt; 0) {</span>
<a href="#l22.261"></a><span id="l22.261" class="difflineplus">+        state-&gt;hold = 0;</span>
<a href="#l22.262"></a><span id="l22.262" class="difflineplus">+        state-&gt;bits = 0;</span>
<a href="#l22.263"></a><span id="l22.263" class="difflineplus">+        return Z_OK;</span>
<a href="#l22.264"></a><span id="l22.264" class="difflineplus">+    }</span>
<a href="#l22.265"></a><span id="l22.265" class="difflineplus">+    if (bits &gt; 16 || state-&gt;bits + (uInt)bits &gt; 32) return Z_STREAM_ERROR;</span>
<a href="#l22.266"></a><span id="l22.266" class="difflineplus">+    value &amp;= (1L &lt;&lt; bits) - 1;</span>
<a href="#l22.267"></a><span id="l22.267" class="difflineplus">+    state-&gt;hold += (unsigned)value &lt;&lt; state-&gt;bits;</span>
<a href="#l22.268"></a><span id="l22.268" class="difflineplus">+    state-&gt;bits += (uInt)bits;</span>
<a href="#l22.269"></a><span id="l22.269" class="difflineplus">+    return Z_OK;</span>
<a href="#l22.270"></a><span id="l22.270" class="difflineplus">+}</span>
<a href="#l22.271"></a><span id="l22.271" class="difflineplus">+</span>
<a href="#l22.272"></a><span id="l22.272" class="difflineplus">+/*</span>
<a href="#l22.273"></a><span id="l22.273" class="difflineplus">+   Return state with length and distance decoding tables and index sizes set to</span>
<a href="#l22.274"></a><span id="l22.274" class="difflineplus">+   fixed code decoding.  Normally this returns fixed tables from inffixed.h.</span>
<a href="#l22.275"></a><span id="l22.275" class="difflineplus">+   If BUILDFIXED is defined, then instead this routine builds the tables the</span>
<a href="#l22.276"></a><span id="l22.276" class="difflineplus">+   first time it's called, and returns those tables the first time and</span>
<a href="#l22.277"></a><span id="l22.277" class="difflineplus">+   thereafter.  This reduces the size of the code by about 2K bytes, in</span>
<a href="#l22.278"></a><span id="l22.278" class="difflineplus">+   exchange for a little execution time.  However, BUILDFIXED should not be</span>
<a href="#l22.279"></a><span id="l22.279" class="difflineplus">+   used for threaded applications, since the rewriting of the tables and virgin</span>
<a href="#l22.280"></a><span id="l22.280" class="difflineplus">+   may not be thread-safe.</span>
<a href="#l22.281"></a><span id="l22.281" class="difflineplus">+ */</span>
<a href="#l22.282"></a><span id="l22.282" class="difflineplus">+local void fixedtables(state)</span>
<a href="#l22.283"></a><span id="l22.283" class="difflineplus">+struct inflate_state FAR *state;</span>
<a href="#l22.284"></a><span id="l22.284" class="difflineplus">+{</span>
<a href="#l22.285"></a><span id="l22.285" class="difflineplus">+#ifdef BUILDFIXED</span>
<a href="#l22.286"></a><span id="l22.286" class="difflineplus">+    static int virgin = 1;</span>
<a href="#l22.287"></a><span id="l22.287" class="difflineplus">+    static code *lenfix, *distfix;</span>
<a href="#l22.288"></a><span id="l22.288" class="difflineplus">+    static code fixed[544];</span>
<a href="#l22.289"></a><span id="l22.289" class="difflineplus">+</span>
<a href="#l22.290"></a><span id="l22.290" class="difflineplus">+    /* build fixed huffman tables if first call (may not be thread safe) */</span>
<a href="#l22.291"></a><span id="l22.291" class="difflineplus">+    if (virgin) {</span>
<a href="#l22.292"></a><span id="l22.292" class="difflineplus">+        unsigned sym, bits;</span>
<a href="#l22.293"></a><span id="l22.293" class="difflineplus">+        static code *next;</span>
<a href="#l22.294"></a><span id="l22.294" class="difflineplus">+</span>
<a href="#l22.295"></a><span id="l22.295" class="difflineplus">+        /* literal/length table */</span>
<a href="#l22.296"></a><span id="l22.296" class="difflineplus">+        sym = 0;</span>
<a href="#l22.297"></a><span id="l22.297" class="difflineplus">+        while (sym &lt; 144) state-&gt;lens[sym++] = 8;</span>
<a href="#l22.298"></a><span id="l22.298" class="difflineplus">+        while (sym &lt; 256) state-&gt;lens[sym++] = 9;</span>
<a href="#l22.299"></a><span id="l22.299" class="difflineplus">+        while (sym &lt; 280) state-&gt;lens[sym++] = 7;</span>
<a href="#l22.300"></a><span id="l22.300" class="difflineplus">+        while (sym &lt; 288) state-&gt;lens[sym++] = 8;</span>
<a href="#l22.301"></a><span id="l22.301" class="difflineplus">+        next = fixed;</span>
<a href="#l22.302"></a><span id="l22.302" class="difflineplus">+        lenfix = next;</span>
<a href="#l22.303"></a><span id="l22.303" class="difflineplus">+        bits = 9;</span>
<a href="#l22.304"></a><span id="l22.304" class="difflineplus">+        inflate_table(LENS, state-&gt;lens, 288, &amp;(next), &amp;(bits), state-&gt;work);</span>
<a href="#l22.305"></a><span id="l22.305" class="difflineplus">+</span>
<a href="#l22.306"></a><span id="l22.306" class="difflineplus">+        /* distance table */</span>
<a href="#l22.307"></a><span id="l22.307" class="difflineplus">+        sym = 0;</span>
<a href="#l22.308"></a><span id="l22.308" class="difflineplus">+        while (sym &lt; 32) state-&gt;lens[sym++] = 5;</span>
<a href="#l22.309"></a><span id="l22.309" class="difflineplus">+        distfix = next;</span>
<a href="#l22.310"></a><span id="l22.310" class="difflineplus">+        bits = 5;</span>
<a href="#l22.311"></a><span id="l22.311" class="difflineplus">+        inflate_table(DISTS, state-&gt;lens, 32, &amp;(next), &amp;(bits), state-&gt;work);</span>
<a href="#l22.312"></a><span id="l22.312" class="difflineplus">+</span>
<a href="#l22.313"></a><span id="l22.313" class="difflineplus">+        /* do this just once */</span>
<a href="#l22.314"></a><span id="l22.314" class="difflineplus">+        virgin = 0;</span>
<a href="#l22.315"></a><span id="l22.315" class="difflineplus">+    }</span>
<a href="#l22.316"></a><span id="l22.316" class="difflineplus">+#else /* !BUILDFIXED */</span>
<a href="#l22.317"></a><span id="l22.317" class="difflineplus">+#   include &quot;inffixed.h&quot;</span>
<a href="#l22.318"></a><span id="l22.318" class="difflineplus">+#endif /* BUILDFIXED */</span>
<a href="#l22.319"></a><span id="l22.319" class="difflineplus">+    state-&gt;lencode = lenfix;</span>
<a href="#l22.320"></a><span id="l22.320" class="difflineplus">+    state-&gt;lenbits = 9;</span>
<a href="#l22.321"></a><span id="l22.321" class="difflineplus">+    state-&gt;distcode = distfix;</span>
<a href="#l22.322"></a><span id="l22.322" class="difflineplus">+    state-&gt;distbits = 5;</span>
<a href="#l22.323"></a><span id="l22.323" class="difflineplus">+}</span>
<a href="#l22.324"></a><span id="l22.324" class="difflineplus">+</span>
<a href="#l22.325"></a><span id="l22.325" class="difflineplus">+#ifdef MAKEFIXED</span>
<a href="#l22.326"></a><span id="l22.326" class="difflineplus">+#include &lt;stdio.h&gt;</span>
<a href="#l22.327"></a><span id="l22.327" class="difflineplus">+</span>
<a href="#l22.328"></a><span id="l22.328" class="difflineplus">+/*</span>
<a href="#l22.329"></a><span id="l22.329" class="difflineplus">+   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also</span>
<a href="#l22.330"></a><span id="l22.330" class="difflineplus">+   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes</span>
<a href="#l22.331"></a><span id="l22.331" class="difflineplus">+   those tables to stdout, which would be piped to inffixed.h.  A small program</span>
<a href="#l22.332"></a><span id="l22.332" class="difflineplus">+   can simply call makefixed to do this:</span>
<a href="#l22.333"></a><span id="l22.333" class="difflineplus">+</span>
<a href="#l22.334"></a><span id="l22.334" class="difflineplus">+    void makefixed(void);</span>
<a href="#l22.335"></a><span id="l22.335" class="difflineplus">+</span>
<a href="#l22.336"></a><span id="l22.336" class="difflineplus">+    int main(void)</span>
<a href="#l22.337"></a><span id="l22.337" class="difflineplus">+    {</span>
<a href="#l22.338"></a><span id="l22.338" class="difflineplus">+        makefixed();</span>
<a href="#l22.339"></a><span id="l22.339" class="difflineplus">+        return 0;</span>
<a href="#l22.340"></a><span id="l22.340" class="difflineplus">+    }</span>
<a href="#l22.341"></a><span id="l22.341" class="difflineplus">+</span>
<a href="#l22.342"></a><span id="l22.342" class="difflineplus">+   Then that can be linked with zlib built with MAKEFIXED defined and run:</span>
<a href="#l22.343"></a><span id="l22.343" class="difflineplus">+</span>
<a href="#l22.344"></a><span id="l22.344" class="difflineplus">+    a.out &gt; inffixed.h</span>
<a href="#l22.345"></a><span id="l22.345" class="difflineplus">+ */</span>
<a href="#l22.346"></a><span id="l22.346" class="difflineplus">+void makefixed()</span>
<a href="#l22.347"></a><span id="l22.347" class="difflineplus">+{</span>
<a href="#l22.348"></a><span id="l22.348" class="difflineplus">+    unsigned low, size;</span>
<a href="#l22.349"></a><span id="l22.349" class="difflineplus">+    struct inflate_state state;</span>
<a href="#l22.350"></a><span id="l22.350" class="difflineplus">+</span>
<a href="#l22.351"></a><span id="l22.351" class="difflineplus">+    fixedtables(&amp;state);</span>
<a href="#l22.352"></a><span id="l22.352" class="difflineplus">+    puts(&quot;    /* inffixed.h -- table for decoding fixed codes&quot;);</span>
<a href="#l22.353"></a><span id="l22.353" class="difflineplus">+    puts(&quot;     * Generated automatically by makefixed().&quot;);</span>
<a href="#l22.354"></a><span id="l22.354" class="difflineplus">+    puts(&quot;     */&quot;);</span>
<a href="#l22.355"></a><span id="l22.355" class="difflineplus">+    puts(&quot;&quot;);</span>
<a href="#l22.356"></a><span id="l22.356" class="difflineplus">+    puts(&quot;    /* WARNING: this file should *not* be used by applications.&quot;);</span>
<a href="#l22.357"></a><span id="l22.357" class="difflineplus">+    puts(&quot;       It is part of the implementation of this library and is&quot;);</span>
<a href="#l22.358"></a><span id="l22.358" class="difflineplus">+    puts(&quot;       subject to change. Applications should only use zlib.h.&quot;);</span>
<a href="#l22.359"></a><span id="l22.359" class="difflineplus">+    puts(&quot;     */&quot;);</span>
<a href="#l22.360"></a><span id="l22.360" class="difflineplus">+    puts(&quot;&quot;);</span>
<a href="#l22.361"></a><span id="l22.361" class="difflineplus">+    size = 1U &lt;&lt; 9;</span>
<a href="#l22.362"></a><span id="l22.362" class="difflineplus">+    printf(&quot;    static const code lenfix[%u] = {&quot;, size);</span>
<a href="#l22.363"></a><span id="l22.363" class="difflineplus">+    low = 0;</span>
<a href="#l22.364"></a><span id="l22.364" class="difflineplus">+    for (;;) {</span>
<a href="#l22.365"></a><span id="l22.365" class="difflineplus">+        if ((low % 7) == 0) printf(&quot;\n        &quot;);</span>
<a href="#l22.366"></a><span id="l22.366" class="difflineplus">+        printf(&quot;{%u,%u,%d}&quot;, (low &amp; 127) == 99 ? 64 : state.lencode[low].op,</span>
<a href="#l22.367"></a><span id="l22.367" class="difflineplus">+               state.lencode[low].bits, state.lencode[low].val);</span>
<a href="#l22.368"></a><span id="l22.368" class="difflineplus">+        if (++low == size) break;</span>
<a href="#l22.369"></a><span id="l22.369" class="difflineplus">+        putchar(',');</span>
<a href="#l22.370"></a><span id="l22.370" class="difflineplus">+    }</span>
<a href="#l22.371"></a><span id="l22.371" class="difflineplus">+    puts(&quot;\n    };&quot;);</span>
<a href="#l22.372"></a><span id="l22.372" class="difflineplus">+    size = 1U &lt;&lt; 5;</span>
<a href="#l22.373"></a><span id="l22.373" class="difflineplus">+    printf(&quot;\n    static const code distfix[%u] = {&quot;, size);</span>
<a href="#l22.374"></a><span id="l22.374" class="difflineplus">+    low = 0;</span>
<a href="#l22.375"></a><span id="l22.375" class="difflineplus">+    for (;;) {</span>
<a href="#l22.376"></a><span id="l22.376" class="difflineplus">+        if ((low % 6) == 0) printf(&quot;\n        &quot;);</span>
<a href="#l22.377"></a><span id="l22.377" class="difflineplus">+        printf(&quot;{%u,%u,%d}&quot;, state.distcode[low].op, state.distcode[low].bits,</span>
<a href="#l22.378"></a><span id="l22.378" class="difflineplus">+               state.distcode[low].val);</span>
<a href="#l22.379"></a><span id="l22.379" class="difflineplus">+        if (++low == size) break;</span>
<a href="#l22.380"></a><span id="l22.380" class="difflineplus">+        putchar(',');</span>
<a href="#l22.381"></a><span id="l22.381" class="difflineplus">+    }</span>
<a href="#l22.382"></a><span id="l22.382" class="difflineplus">+    puts(&quot;\n    };&quot;);</span>
<a href="#l22.383"></a><span id="l22.383" class="difflineplus">+}</span>
<a href="#l22.384"></a><span id="l22.384" class="difflineplus">+#endif /* MAKEFIXED */</span>
<a href="#l22.385"></a><span id="l22.385" class="difflineplus">+</span>
<a href="#l22.386"></a><span id="l22.386" class="difflineplus">+/*</span>
<a href="#l22.387"></a><span id="l22.387" class="difflineplus">+   Update the window with the last wsize (normally 32K) bytes written before</span>
<a href="#l22.388"></a><span id="l22.388" class="difflineplus">+   returning.  If window does not exist yet, create it.  This is only called</span>
<a href="#l22.389"></a><span id="l22.389" class="difflineplus">+   when a window is already in use, or when output has been written during this</span>
<a href="#l22.390"></a><span id="l22.390" class="difflineplus">+   inflate call, but the end of the deflate stream has not been reached yet.</span>
<a href="#l22.391"></a><span id="l22.391" class="difflineplus">+   It is also called to create a window for dictionary data when a dictionary</span>
<a href="#l22.392"></a><span id="l22.392" class="difflineplus">+   is loaded.</span>
<a href="#l22.393"></a><span id="l22.393" class="difflineplus">+</span>
<a href="#l22.394"></a><span id="l22.394" class="difflineplus">+   Providing output buffers larger than 32K to inflate() should provide a speed</span>
<a href="#l22.395"></a><span id="l22.395" class="difflineplus">+   advantage, since only the last 32K of output is copied to the sliding window</span>
<a href="#l22.396"></a><span id="l22.396" class="difflineplus">+   upon return from inflate(), and since all distances after the first 32K of</span>
<a href="#l22.397"></a><span id="l22.397" class="difflineplus">+   output will fall in the output data, making match copies simpler and faster.</span>
<a href="#l22.398"></a><span id="l22.398" class="difflineplus">+   The advantage may be dependent on the size of the processor's data caches.</span>
<a href="#l22.399"></a><span id="l22.399" class="difflineplus">+ */</span>
<a href="#l22.400"></a><span id="l22.400" class="difflineplus">+local int updatewindow(strm, end, copy)</span>
<a href="#l22.401"></a><span id="l22.401" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.402"></a><span id="l22.402" class="difflineplus">+const Bytef *end;</span>
<a href="#l22.403"></a><span id="l22.403" class="difflineplus">+unsigned copy;</span>
<a href="#l22.404"></a><span id="l22.404" class="difflineplus">+{</span>
<a href="#l22.405"></a><span id="l22.405" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.406"></a><span id="l22.406" class="difflineplus">+    unsigned dist;</span>
<a href="#l22.407"></a><span id="l22.407" class="difflineplus">+</span>
<a href="#l22.408"></a><span id="l22.408" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.409"></a><span id="l22.409" class="difflineplus">+</span>
<a href="#l22.410"></a><span id="l22.410" class="difflineplus">+    /* if it hasn't been done already, allocate space for the window */</span>
<a href="#l22.411"></a><span id="l22.411" class="difflineplus">+    if (state-&gt;window == Z_NULL) {</span>
<a href="#l22.412"></a><span id="l22.412" class="difflineplus">+        state-&gt;window = (unsigned char FAR *)</span>
<a href="#l22.413"></a><span id="l22.413" class="difflineplus">+                        ZALLOC(strm, 1U &lt;&lt; state-&gt;wbits,</span>
<a href="#l22.414"></a><span id="l22.414" class="difflineplus">+                               sizeof(unsigned char));</span>
<a href="#l22.415"></a><span id="l22.415" class="difflineplus">+        if (state-&gt;window == Z_NULL) return 1;</span>
<a href="#l22.416"></a><span id="l22.416" class="difflineplus">+    }</span>
<a href="#l22.417"></a><span id="l22.417" class="difflineplus">+</span>
<a href="#l22.418"></a><span id="l22.418" class="difflineplus">+    /* if window not in use yet, initialize */</span>
<a href="#l22.419"></a><span id="l22.419" class="difflineplus">+    if (state-&gt;wsize == 0) {</span>
<a href="#l22.420"></a><span id="l22.420" class="difflineplus">+        state-&gt;wsize = 1U &lt;&lt; state-&gt;wbits;</span>
<a href="#l22.421"></a><span id="l22.421" class="difflineplus">+        state-&gt;wnext = 0;</span>
<a href="#l22.422"></a><span id="l22.422" class="difflineplus">+        state-&gt;whave = 0;</span>
<a href="#l22.423"></a><span id="l22.423" class="difflineplus">+    }</span>
<a href="#l22.424"></a><span id="l22.424" class="difflineplus">+</span>
<a href="#l22.425"></a><span id="l22.425" class="difflineplus">+    /* copy state-&gt;wsize or less output bytes into the circular window */</span>
<a href="#l22.426"></a><span id="l22.426" class="difflineplus">+    if (copy &gt;= state-&gt;wsize) {</span>
<a href="#l22.427"></a><span id="l22.427" class="difflineplus">+        zmemcpy(state-&gt;window, end - state-&gt;wsize, state-&gt;wsize);</span>
<a href="#l22.428"></a><span id="l22.428" class="difflineplus">+        state-&gt;wnext = 0;</span>
<a href="#l22.429"></a><span id="l22.429" class="difflineplus">+        state-&gt;whave = state-&gt;wsize;</span>
<a href="#l22.430"></a><span id="l22.430" class="difflineplus">+    }</span>
<a href="#l22.431"></a><span id="l22.431" class="difflineplus">+    else {</span>
<a href="#l22.432"></a><span id="l22.432" class="difflineplus">+        dist = state-&gt;wsize - state-&gt;wnext;</span>
<a href="#l22.433"></a><span id="l22.433" class="difflineplus">+        if (dist &gt; copy) dist = copy;</span>
<a href="#l22.434"></a><span id="l22.434" class="difflineplus">+        zmemcpy(state-&gt;window + state-&gt;wnext, end - copy, dist);</span>
<a href="#l22.435"></a><span id="l22.435" class="difflineplus">+        copy -= dist;</span>
<a href="#l22.436"></a><span id="l22.436" class="difflineplus">+        if (copy) {</span>
<a href="#l22.437"></a><span id="l22.437" class="difflineplus">+            zmemcpy(state-&gt;window, end - copy, copy);</span>
<a href="#l22.438"></a><span id="l22.438" class="difflineplus">+            state-&gt;wnext = copy;</span>
<a href="#l22.439"></a><span id="l22.439" class="difflineplus">+            state-&gt;whave = state-&gt;wsize;</span>
<a href="#l22.440"></a><span id="l22.440" class="difflineplus">+        }</span>
<a href="#l22.441"></a><span id="l22.441" class="difflineplus">+        else {</span>
<a href="#l22.442"></a><span id="l22.442" class="difflineplus">+            state-&gt;wnext += dist;</span>
<a href="#l22.443"></a><span id="l22.443" class="difflineplus">+            if (state-&gt;wnext == state-&gt;wsize) state-&gt;wnext = 0;</span>
<a href="#l22.444"></a><span id="l22.444" class="difflineplus">+            if (state-&gt;whave &lt; state-&gt;wsize) state-&gt;whave += dist;</span>
<a href="#l22.445"></a><span id="l22.445" class="difflineplus">+        }</span>
<a href="#l22.446"></a><span id="l22.446" class="difflineplus">+    }</span>
<a href="#l22.447"></a><span id="l22.447" class="difflineplus">+    return 0;</span>
<a href="#l22.448"></a><span id="l22.448" class="difflineplus">+}</span>
<a href="#l22.449"></a><span id="l22.449" class="difflineplus">+</span>
<a href="#l22.450"></a><span id="l22.450" class="difflineplus">+/* Macros for inflate(): */</span>
<a href="#l22.451"></a><span id="l22.451" class="difflineplus">+</span>
<a href="#l22.452"></a><span id="l22.452" class="difflineplus">+/* check function to use adler32() for zlib or crc32() for gzip */</span>
<a href="#l22.453"></a><span id="l22.453" class="difflineplus">+#ifdef GUNZIP</span>
<a href="#l22.454"></a><span id="l22.454" class="difflineplus">+#  define UPDATE(check, buf, len) \</span>
<a href="#l22.455"></a><span id="l22.455" class="difflineplus">+    (state-&gt;flags ? crc32(check, buf, len) : adler32(check, buf, len))</span>
<a href="#l22.456"></a><span id="l22.456" class="difflineplus">+#else</span>
<a href="#l22.457"></a><span id="l22.457" class="difflineplus">+#  define UPDATE(check, buf, len) adler32(check, buf, len)</span>
<a href="#l22.458"></a><span id="l22.458" class="difflineplus">+#endif</span>
<a href="#l22.459"></a><span id="l22.459" class="difflineplus">+</span>
<a href="#l22.460"></a><span id="l22.460" class="difflineplus">+/* check macros for header crc */</span>
<a href="#l22.461"></a><span id="l22.461" class="difflineplus">+#ifdef GUNZIP</span>
<a href="#l22.462"></a><span id="l22.462" class="difflineplus">+#  define CRC2(check, word) \</span>
<a href="#l22.463"></a><span id="l22.463" class="difflineplus">+    do { \</span>
<a href="#l22.464"></a><span id="l22.464" class="difflineplus">+        hbuf[0] = (unsigned char)(word); \</span>
<a href="#l22.465"></a><span id="l22.465" class="difflineplus">+        hbuf[1] = (unsigned char)((word) &gt;&gt; 8); \</span>
<a href="#l22.466"></a><span id="l22.466" class="difflineplus">+        check = crc32(check, hbuf, 2); \</span>
<a href="#l22.467"></a><span id="l22.467" class="difflineplus">+    } while (0)</span>
<a href="#l22.468"></a><span id="l22.468" class="difflineplus">+</span>
<a href="#l22.469"></a><span id="l22.469" class="difflineplus">+#  define CRC4(check, word) \</span>
<a href="#l22.470"></a><span id="l22.470" class="difflineplus">+    do { \</span>
<a href="#l22.471"></a><span id="l22.471" class="difflineplus">+        hbuf[0] = (unsigned char)(word); \</span>
<a href="#l22.472"></a><span id="l22.472" class="difflineplus">+        hbuf[1] = (unsigned char)((word) &gt;&gt; 8); \</span>
<a href="#l22.473"></a><span id="l22.473" class="difflineplus">+        hbuf[2] = (unsigned char)((word) &gt;&gt; 16); \</span>
<a href="#l22.474"></a><span id="l22.474" class="difflineplus">+        hbuf[3] = (unsigned char)((word) &gt;&gt; 24); \</span>
<a href="#l22.475"></a><span id="l22.475" class="difflineplus">+        check = crc32(check, hbuf, 4); \</span>
<a href="#l22.476"></a><span id="l22.476" class="difflineplus">+    } while (0)</span>
<a href="#l22.477"></a><span id="l22.477" class="difflineplus">+#endif</span>
<a href="#l22.478"></a><span id="l22.478" class="difflineplus">+</span>
<a href="#l22.479"></a><span id="l22.479" class="difflineplus">+/* Load registers with state in inflate() for speed */</span>
<a href="#l22.480"></a><span id="l22.480" class="difflineplus">+#define LOAD() \</span>
<a href="#l22.481"></a><span id="l22.481" class="difflineplus">+    do { \</span>
<a href="#l22.482"></a><span id="l22.482" class="difflineplus">+        put = strm-&gt;next_out; \</span>
<a href="#l22.483"></a><span id="l22.483" class="difflineplus">+        left = strm-&gt;avail_out; \</span>
<a href="#l22.484"></a><span id="l22.484" class="difflineplus">+        next = strm-&gt;next_in; \</span>
<a href="#l22.485"></a><span id="l22.485" class="difflineplus">+        have = strm-&gt;avail_in; \</span>
<a href="#l22.486"></a><span id="l22.486" class="difflineplus">+        hold = state-&gt;hold; \</span>
<a href="#l22.487"></a><span id="l22.487" class="difflineplus">+        bits = state-&gt;bits; \</span>
<a href="#l22.488"></a><span id="l22.488" class="difflineplus">+    } while (0)</span>
<a href="#l22.489"></a><span id="l22.489" class="difflineplus">+</span>
<a href="#l22.490"></a><span id="l22.490" class="difflineplus">+/* Restore state from registers in inflate() */</span>
<a href="#l22.491"></a><span id="l22.491" class="difflineplus">+#define RESTORE() \</span>
<a href="#l22.492"></a><span id="l22.492" class="difflineplus">+    do { \</span>
<a href="#l22.493"></a><span id="l22.493" class="difflineplus">+        strm-&gt;next_out = put; \</span>
<a href="#l22.494"></a><span id="l22.494" class="difflineplus">+        strm-&gt;avail_out = left; \</span>
<a href="#l22.495"></a><span id="l22.495" class="difflineplus">+        strm-&gt;next_in = next; \</span>
<a href="#l22.496"></a><span id="l22.496" class="difflineplus">+        strm-&gt;avail_in = have; \</span>
<a href="#l22.497"></a><span id="l22.497" class="difflineplus">+        state-&gt;hold = hold; \</span>
<a href="#l22.498"></a><span id="l22.498" class="difflineplus">+        state-&gt;bits = bits; \</span>
<a href="#l22.499"></a><span id="l22.499" class="difflineplus">+    } while (0)</span>
<a href="#l22.500"></a><span id="l22.500" class="difflineplus">+</span>
<a href="#l22.501"></a><span id="l22.501" class="difflineplus">+/* Clear the input bit accumulator */</span>
<a href="#l22.502"></a><span id="l22.502" class="difflineplus">+#define INITBITS() \</span>
<a href="#l22.503"></a><span id="l22.503" class="difflineplus">+    do { \</span>
<a href="#l22.504"></a><span id="l22.504" class="difflineplus">+        hold = 0; \</span>
<a href="#l22.505"></a><span id="l22.505" class="difflineplus">+        bits = 0; \</span>
<a href="#l22.506"></a><span id="l22.506" class="difflineplus">+    } while (0)</span>
<a href="#l22.507"></a><span id="l22.507" class="difflineplus">+</span>
<a href="#l22.508"></a><span id="l22.508" class="difflineplus">+/* Get a byte of input into the bit accumulator, or return from inflate()</span>
<a href="#l22.509"></a><span id="l22.509" class="difflineplus">+   if there is no input available. */</span>
<a href="#l22.510"></a><span id="l22.510" class="difflineplus">+#define PULLBYTE() \</span>
<a href="#l22.511"></a><span id="l22.511" class="difflineplus">+    do { \</span>
<a href="#l22.512"></a><span id="l22.512" class="difflineplus">+        if (have == 0) goto inf_leave; \</span>
<a href="#l22.513"></a><span id="l22.513" class="difflineplus">+        have--; \</span>
<a href="#l22.514"></a><span id="l22.514" class="difflineplus">+        hold += (unsigned long)(*next++) &lt;&lt; bits; \</span>
<a href="#l22.515"></a><span id="l22.515" class="difflineplus">+        bits += 8; \</span>
<a href="#l22.516"></a><span id="l22.516" class="difflineplus">+    } while (0)</span>
<a href="#l22.517"></a><span id="l22.517" class="difflineplus">+</span>
<a href="#l22.518"></a><span id="l22.518" class="difflineplus">+/* Assure that there are at least n bits in the bit accumulator.  If there is</span>
<a href="#l22.519"></a><span id="l22.519" class="difflineplus">+   not enough available input to do that, then return from inflate(). */</span>
<a href="#l22.520"></a><span id="l22.520" class="difflineplus">+#define NEEDBITS(n) \</span>
<a href="#l22.521"></a><span id="l22.521" class="difflineplus">+    do { \</span>
<a href="#l22.522"></a><span id="l22.522" class="difflineplus">+        while (bits &lt; (unsigned)(n)) \</span>
<a href="#l22.523"></a><span id="l22.523" class="difflineplus">+            PULLBYTE(); \</span>
<a href="#l22.524"></a><span id="l22.524" class="difflineplus">+    } while (0)</span>
<a href="#l22.525"></a><span id="l22.525" class="difflineplus">+</span>
<a href="#l22.526"></a><span id="l22.526" class="difflineplus">+/* Return the low n bits of the bit accumulator (n &lt; 16) */</span>
<a href="#l22.527"></a><span id="l22.527" class="difflineplus">+#define BITS(n) \</span>
<a href="#l22.528"></a><span id="l22.528" class="difflineplus">+    ((unsigned)hold &amp; ((1U &lt;&lt; (n)) - 1))</span>
<a href="#l22.529"></a><span id="l22.529" class="difflineplus">+</span>
<a href="#l22.530"></a><span id="l22.530" class="difflineplus">+/* Remove n bits from the bit accumulator */</span>
<a href="#l22.531"></a><span id="l22.531" class="difflineplus">+#define DROPBITS(n) \</span>
<a href="#l22.532"></a><span id="l22.532" class="difflineplus">+    do { \</span>
<a href="#l22.533"></a><span id="l22.533" class="difflineplus">+        hold &gt;&gt;= (n); \</span>
<a href="#l22.534"></a><span id="l22.534" class="difflineplus">+        bits -= (unsigned)(n); \</span>
<a href="#l22.535"></a><span id="l22.535" class="difflineplus">+    } while (0)</span>
<a href="#l22.536"></a><span id="l22.536" class="difflineplus">+</span>
<a href="#l22.537"></a><span id="l22.537" class="difflineplus">+/* Remove zero to seven bits as needed to go to a byte boundary */</span>
<a href="#l22.538"></a><span id="l22.538" class="difflineplus">+#define BYTEBITS() \</span>
<a href="#l22.539"></a><span id="l22.539" class="difflineplus">+    do { \</span>
<a href="#l22.540"></a><span id="l22.540" class="difflineplus">+        hold &gt;&gt;= bits &amp; 7; \</span>
<a href="#l22.541"></a><span id="l22.541" class="difflineplus">+        bits -= bits &amp; 7; \</span>
<a href="#l22.542"></a><span id="l22.542" class="difflineplus">+    } while (0)</span>
<a href="#l22.543"></a><span id="l22.543" class="difflineplus">+</span>
<a href="#l22.544"></a><span id="l22.544" class="difflineplus">+/*</span>
<a href="#l22.545"></a><span id="l22.545" class="difflineplus">+   inflate() uses a state machine to process as much input data and generate as</span>
<a href="#l22.546"></a><span id="l22.546" class="difflineplus">+   much output data as possible before returning.  The state machine is</span>
<a href="#l22.547"></a><span id="l22.547" class="difflineplus">+   structured roughly as follows:</span>
<a href="#l22.548"></a><span id="l22.548" class="difflineplus">+</span>
<a href="#l22.549"></a><span id="l22.549" class="difflineplus">+    for (;;) switch (state) {</span>
<a href="#l22.550"></a><span id="l22.550" class="difflineplus">+    ...</span>
<a href="#l22.551"></a><span id="l22.551" class="difflineplus">+    case STATEn:</span>
<a href="#l22.552"></a><span id="l22.552" class="difflineplus">+        if (not enough input data or output space to make progress)</span>
<a href="#l22.553"></a><span id="l22.553" class="difflineplus">+            return;</span>
<a href="#l22.554"></a><span id="l22.554" class="difflineplus">+        ... make progress ...</span>
<a href="#l22.555"></a><span id="l22.555" class="difflineplus">+        state = STATEm;</span>
<a href="#l22.556"></a><span id="l22.556" class="difflineplus">+        break;</span>
<a href="#l22.557"></a><span id="l22.557" class="difflineplus">+    ...</span>
<a href="#l22.558"></a><span id="l22.558" class="difflineplus">+    }</span>
<a href="#l22.559"></a><span id="l22.559" class="difflineplus">+</span>
<a href="#l22.560"></a><span id="l22.560" class="difflineplus">+   so when inflate() is called again, the same case is attempted again, and</span>
<a href="#l22.561"></a><span id="l22.561" class="difflineplus">+   if the appropriate resources are provided, the machine proceeds to the</span>
<a href="#l22.562"></a><span id="l22.562" class="difflineplus">+   next state.  The NEEDBITS() macro is usually the way the state evaluates</span>
<a href="#l22.563"></a><span id="l22.563" class="difflineplus">+   whether it can proceed or should return.  NEEDBITS() does the return if</span>
<a href="#l22.564"></a><span id="l22.564" class="difflineplus">+   the requested bits are not available.  The typical use of the BITS macros</span>
<a href="#l22.565"></a><span id="l22.565" class="difflineplus">+   is:</span>
<a href="#l22.566"></a><span id="l22.566" class="difflineplus">+</span>
<a href="#l22.567"></a><span id="l22.567" class="difflineplus">+        NEEDBITS(n);</span>
<a href="#l22.568"></a><span id="l22.568" class="difflineplus">+        ... do something with BITS(n) ...</span>
<a href="#l22.569"></a><span id="l22.569" class="difflineplus">+        DROPBITS(n);</span>
<a href="#l22.570"></a><span id="l22.570" class="difflineplus">+</span>
<a href="#l22.571"></a><span id="l22.571" class="difflineplus">+   where NEEDBITS(n) either returns from inflate() if there isn't enough</span>
<a href="#l22.572"></a><span id="l22.572" class="difflineplus">+   input left to load n bits into the accumulator, or it continues.  BITS(n)</span>
<a href="#l22.573"></a><span id="l22.573" class="difflineplus">+   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops</span>
<a href="#l22.574"></a><span id="l22.574" class="difflineplus">+   the low n bits off the accumulator.  INITBITS() clears the accumulator</span>
<a href="#l22.575"></a><span id="l22.575" class="difflineplus">+   and sets the number of available bits to zero.  BYTEBITS() discards just</span>
<a href="#l22.576"></a><span id="l22.576" class="difflineplus">+   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()</span>
<a href="#l22.577"></a><span id="l22.577" class="difflineplus">+   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.</span>
<a href="#l22.578"></a><span id="l22.578" class="difflineplus">+</span>
<a href="#l22.579"></a><span id="l22.579" class="difflineplus">+   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return</span>
<a href="#l22.580"></a><span id="l22.580" class="difflineplus">+   if there is no input available.  The decoding of variable length codes uses</span>
<a href="#l22.581"></a><span id="l22.581" class="difflineplus">+   PULLBYTE() directly in order to pull just enough bytes to decode the next</span>
<a href="#l22.582"></a><span id="l22.582" class="difflineplus">+   code, and no more.</span>
<a href="#l22.583"></a><span id="l22.583" class="difflineplus">+</span>
<a href="#l22.584"></a><span id="l22.584" class="difflineplus">+   Some states loop until they get enough input, making sure that enough</span>
<a href="#l22.585"></a><span id="l22.585" class="difflineplus">+   state information is maintained to continue the loop where it left off</span>
<a href="#l22.586"></a><span id="l22.586" class="difflineplus">+   if NEEDBITS() returns in the loop.  For example, want, need, and keep</span>
<a href="#l22.587"></a><span id="l22.587" class="difflineplus">+   would all have to actually be part of the saved state in case NEEDBITS()</span>
<a href="#l22.588"></a><span id="l22.588" class="difflineplus">+   returns:</span>
<a href="#l22.589"></a><span id="l22.589" class="difflineplus">+</span>
<a href="#l22.590"></a><span id="l22.590" class="difflineplus">+    case STATEw:</span>
<a href="#l22.591"></a><span id="l22.591" class="difflineplus">+        while (want &lt; need) {</span>
<a href="#l22.592"></a><span id="l22.592" class="difflineplus">+            NEEDBITS(n);</span>
<a href="#l22.593"></a><span id="l22.593" class="difflineplus">+            keep[want++] = BITS(n);</span>
<a href="#l22.594"></a><span id="l22.594" class="difflineplus">+            DROPBITS(n);</span>
<a href="#l22.595"></a><span id="l22.595" class="difflineplus">+        }</span>
<a href="#l22.596"></a><span id="l22.596" class="difflineplus">+        state = STATEx;</span>
<a href="#l22.597"></a><span id="l22.597" class="difflineplus">+    case STATEx:</span>
<a href="#l22.598"></a><span id="l22.598" class="difflineplus">+</span>
<a href="#l22.599"></a><span id="l22.599" class="difflineplus">+   As shown above, if the next state is also the next case, then the break</span>
<a href="#l22.600"></a><span id="l22.600" class="difflineplus">+   is omitted.</span>
<a href="#l22.601"></a><span id="l22.601" class="difflineplus">+</span>
<a href="#l22.602"></a><span id="l22.602" class="difflineplus">+   A state may also return if there is not enough output space available to</span>
<a href="#l22.603"></a><span id="l22.603" class="difflineplus">+   complete that state.  Those states are copying stored data, writing a</span>
<a href="#l22.604"></a><span id="l22.604" class="difflineplus">+   literal byte, and copying a matching string.</span>
<a href="#l22.605"></a><span id="l22.605" class="difflineplus">+</span>
<a href="#l22.606"></a><span id="l22.606" class="difflineplus">+   When returning, a &quot;goto inf_leave&quot; is used to update the total counters,</span>
<a href="#l22.607"></a><span id="l22.607" class="difflineplus">+   update the check value, and determine whether any progress has been made</span>
<a href="#l22.608"></a><span id="l22.608" class="difflineplus">+   during that inflate() call in order to return the proper return code.</span>
<a href="#l22.609"></a><span id="l22.609" class="difflineplus">+   Progress is defined as a change in either strm-&gt;avail_in or strm-&gt;avail_out.</span>
<a href="#l22.610"></a><span id="l22.610" class="difflineplus">+   When there is a window, goto inf_leave will update the window with the last</span>
<a href="#l22.611"></a><span id="l22.611" class="difflineplus">+   output written.  If a goto inf_leave occurs in the middle of decompression</span>
<a href="#l22.612"></a><span id="l22.612" class="difflineplus">+   and there is no window currently, goto inf_leave will create one and copy</span>
<a href="#l22.613"></a><span id="l22.613" class="difflineplus">+   output to the window for the next call of inflate().</span>
<a href="#l22.614"></a><span id="l22.614" class="difflineplus">+</span>
<a href="#l22.615"></a><span id="l22.615" class="difflineplus">+   In this implementation, the flush parameter of inflate() only affects the</span>
<a href="#l22.616"></a><span id="l22.616" class="difflineplus">+   return code (per zlib.h).  inflate() always writes as much as possible to</span>
<a href="#l22.617"></a><span id="l22.617" class="difflineplus">+   strm-&gt;next_out, given the space available and the provided input--the effect</span>
<a href="#l22.618"></a><span id="l22.618" class="difflineplus">+   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers</span>
<a href="#l22.619"></a><span id="l22.619" class="difflineplus">+   the allocation of and copying into a sliding window until necessary, which</span>
<a href="#l22.620"></a><span id="l22.620" class="difflineplus">+   provides the effect documented in zlib.h for Z_FINISH when the entire input</span>
<a href="#l22.621"></a><span id="l22.621" class="difflineplus">+   stream available.  So the only thing the flush parameter actually does is:</span>
<a href="#l22.622"></a><span id="l22.622" class="difflineplus">+   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it</span>
<a href="#l22.623"></a><span id="l22.623" class="difflineplus">+   will return Z_BUF_ERROR if it has not reached the end of the stream.</span>
<a href="#l22.624"></a><span id="l22.624" class="difflineplus">+ */</span>
<a href="#l22.625"></a><span id="l22.625" class="difflineplus">+</span>
<a href="#l22.626"></a><span id="l22.626" class="difflineplus">+int ZEXPORT inflate(strm, flush)</span>
<a href="#l22.627"></a><span id="l22.627" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.628"></a><span id="l22.628" class="difflineplus">+int flush;</span>
<a href="#l22.629"></a><span id="l22.629" class="difflineplus">+{</span>
<a href="#l22.630"></a><span id="l22.630" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.631"></a><span id="l22.631" class="difflineplus">+    z_const unsigned char FAR *next;    /* next input */</span>
<a href="#l22.632"></a><span id="l22.632" class="difflineplus">+    unsigned char FAR *put;     /* next output */</span>
<a href="#l22.633"></a><span id="l22.633" class="difflineplus">+    unsigned have, left;        /* available input and output */</span>
<a href="#l22.634"></a><span id="l22.634" class="difflineplus">+    unsigned long hold;         /* bit buffer */</span>
<a href="#l22.635"></a><span id="l22.635" class="difflineplus">+    unsigned bits;              /* bits in bit buffer */</span>
<a href="#l22.636"></a><span id="l22.636" class="difflineplus">+    unsigned in, out;           /* save starting available input and output */</span>
<a href="#l22.637"></a><span id="l22.637" class="difflineplus">+    unsigned copy;              /* number of stored or match bytes to copy */</span>
<a href="#l22.638"></a><span id="l22.638" class="difflineplus">+    unsigned char FAR *from;    /* where to copy match bytes from */</span>
<a href="#l22.639"></a><span id="l22.639" class="difflineplus">+    code here;                  /* current decoding table entry */</span>
<a href="#l22.640"></a><span id="l22.640" class="difflineplus">+    code last;                  /* parent table entry */</span>
<a href="#l22.641"></a><span id="l22.641" class="difflineplus">+    unsigned len;               /* length to copy for repeats, bits to drop */</span>
<a href="#l22.642"></a><span id="l22.642" class="difflineplus">+    int ret;                    /* return code */</span>
<a href="#l22.643"></a><span id="l22.643" class="difflineplus">+#ifdef GUNZIP</span>
<a href="#l22.644"></a><span id="l22.644" class="difflineplus">+    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */</span>
<a href="#l22.645"></a><span id="l22.645" class="difflineplus">+#endif</span>
<a href="#l22.646"></a><span id="l22.646" class="difflineplus">+    static const unsigned short order[19] = /* permutation of code lengths */</span>
<a href="#l22.647"></a><span id="l22.647" class="difflineplus">+        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};</span>
<a href="#l22.648"></a><span id="l22.648" class="difflineplus">+</span>
<a href="#l22.649"></a><span id="l22.649" class="difflineplus">+    if (inflateStateCheck(strm) || strm-&gt;next_out == Z_NULL ||</span>
<a href="#l22.650"></a><span id="l22.650" class="difflineplus">+        (strm-&gt;next_in == Z_NULL &amp;&amp; strm-&gt;avail_in != 0))</span>
<a href="#l22.651"></a><span id="l22.651" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l22.652"></a><span id="l22.652" class="difflineplus">+</span>
<a href="#l22.653"></a><span id="l22.653" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.654"></a><span id="l22.654" class="difflineplus">+    if (state-&gt;mode == TYPE) state-&gt;mode = TYPEDO;      /* skip check */</span>
<a href="#l22.655"></a><span id="l22.655" class="difflineplus">+    LOAD();</span>
<a href="#l22.656"></a><span id="l22.656" class="difflineplus">+    in = have;</span>
<a href="#l22.657"></a><span id="l22.657" class="difflineplus">+    out = left;</span>
<a href="#l22.658"></a><span id="l22.658" class="difflineplus">+    ret = Z_OK;</span>
<a href="#l22.659"></a><span id="l22.659" class="difflineplus">+    for (;;)</span>
<a href="#l22.660"></a><span id="l22.660" class="difflineplus">+        switch (state-&gt;mode) {</span>
<a href="#l22.661"></a><span id="l22.661" class="difflineplus">+        case HEAD:</span>
<a href="#l22.662"></a><span id="l22.662" class="difflineplus">+            if (state-&gt;wrap == 0) {</span>
<a href="#l22.663"></a><span id="l22.663" class="difflineplus">+                state-&gt;mode = TYPEDO;</span>
<a href="#l22.664"></a><span id="l22.664" class="difflineplus">+                break;</span>
<a href="#l22.665"></a><span id="l22.665" class="difflineplus">+            }</span>
<a href="#l22.666"></a><span id="l22.666" class="difflineplus">+            NEEDBITS(16);</span>
<a href="#l22.667"></a><span id="l22.667" class="difflineplus">+#ifdef GUNZIP</span>
<a href="#l22.668"></a><span id="l22.668" class="difflineplus">+            if ((state-&gt;wrap &amp; 2) &amp;&amp; hold == 0x8b1f) {  /* gzip header */</span>
<a href="#l22.669"></a><span id="l22.669" class="difflineplus">+                if (state-&gt;wbits == 0)</span>
<a href="#l22.670"></a><span id="l22.670" class="difflineplus">+                    state-&gt;wbits = 15;</span>
<a href="#l22.671"></a><span id="l22.671" class="difflineplus">+                state-&gt;check = crc32(0L, Z_NULL, 0);</span>
<a href="#l22.672"></a><span id="l22.672" class="difflineplus">+                CRC2(state-&gt;check, hold);</span>
<a href="#l22.673"></a><span id="l22.673" class="difflineplus">+                INITBITS();</span>
<a href="#l22.674"></a><span id="l22.674" class="difflineplus">+                state-&gt;mode = FLAGS;</span>
<a href="#l22.675"></a><span id="l22.675" class="difflineplus">+                break;</span>
<a href="#l22.676"></a><span id="l22.676" class="difflineplus">+            }</span>
<a href="#l22.677"></a><span id="l22.677" class="difflineplus">+            state-&gt;flags = 0;           /* expect zlib header */</span>
<a href="#l22.678"></a><span id="l22.678" class="difflineplus">+            if (state-&gt;head != Z_NULL)</span>
<a href="#l22.679"></a><span id="l22.679" class="difflineplus">+                state-&gt;head-&gt;done = -1;</span>
<a href="#l22.680"></a><span id="l22.680" class="difflineplus">+            if (!(state-&gt;wrap &amp; 1) ||   /* check if zlib header allowed */</span>
<a href="#l22.681"></a><span id="l22.681" class="difflineplus">+#else</span>
<a href="#l22.682"></a><span id="l22.682" class="difflineplus">+            if (</span>
<a href="#l22.683"></a><span id="l22.683" class="difflineplus">+#endif</span>
<a href="#l22.684"></a><span id="l22.684" class="difflineplus">+                ((BITS(8) &lt;&lt; 8) + (hold &gt;&gt; 8)) % 31) {</span>
<a href="#l22.685"></a><span id="l22.685" class="difflineplus">+                strm-&gt;msg = (char *)&quot;incorrect header check&quot;;</span>
<a href="#l22.686"></a><span id="l22.686" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.687"></a><span id="l22.687" class="difflineplus">+                break;</span>
<a href="#l22.688"></a><span id="l22.688" class="difflineplus">+            }</span>
<a href="#l22.689"></a><span id="l22.689" class="difflineplus">+            if (BITS(4) != Z_DEFLATED) {</span>
<a href="#l22.690"></a><span id="l22.690" class="difflineplus">+                strm-&gt;msg = (char *)&quot;unknown compression method&quot;;</span>
<a href="#l22.691"></a><span id="l22.691" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.692"></a><span id="l22.692" class="difflineplus">+                break;</span>
<a href="#l22.693"></a><span id="l22.693" class="difflineplus">+            }</span>
<a href="#l22.694"></a><span id="l22.694" class="difflineplus">+            DROPBITS(4);</span>
<a href="#l22.695"></a><span id="l22.695" class="difflineplus">+            len = BITS(4) + 8;</span>
<a href="#l22.696"></a><span id="l22.696" class="difflineplus">+            if (state-&gt;wbits == 0)</span>
<a href="#l22.697"></a><span id="l22.697" class="difflineplus">+                state-&gt;wbits = len;</span>
<a href="#l22.698"></a><span id="l22.698" class="difflineplus">+            if (len &gt; 15 || len &gt; state-&gt;wbits) {</span>
<a href="#l22.699"></a><span id="l22.699" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid window size&quot;;</span>
<a href="#l22.700"></a><span id="l22.700" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.701"></a><span id="l22.701" class="difflineplus">+                break;</span>
<a href="#l22.702"></a><span id="l22.702" class="difflineplus">+            }</span>
<a href="#l22.703"></a><span id="l22.703" class="difflineplus">+            state-&gt;dmax = 1U &lt;&lt; len;</span>
<a href="#l22.704"></a><span id="l22.704" class="difflineplus">+            Tracev((stderr, &quot;inflate:   zlib header ok\n&quot;));</span>
<a href="#l22.705"></a><span id="l22.705" class="difflineplus">+            strm-&gt;adler = state-&gt;check = adler32(0L, Z_NULL, 0);</span>
<a href="#l22.706"></a><span id="l22.706" class="difflineplus">+            state-&gt;mode = hold &amp; 0x200 ? DICTID : TYPE;</span>
<a href="#l22.707"></a><span id="l22.707" class="difflineplus">+            INITBITS();</span>
<a href="#l22.708"></a><span id="l22.708" class="difflineplus">+            break;</span>
<a href="#l22.709"></a><span id="l22.709" class="difflineplus">+#ifdef GUNZIP</span>
<a href="#l22.710"></a><span id="l22.710" class="difflineplus">+        case FLAGS:</span>
<a href="#l22.711"></a><span id="l22.711" class="difflineplus">+            NEEDBITS(16);</span>
<a href="#l22.712"></a><span id="l22.712" class="difflineplus">+            state-&gt;flags = (int)(hold);</span>
<a href="#l22.713"></a><span id="l22.713" class="difflineplus">+            if ((state-&gt;flags &amp; 0xff) != Z_DEFLATED) {</span>
<a href="#l22.714"></a><span id="l22.714" class="difflineplus">+                strm-&gt;msg = (char *)&quot;unknown compression method&quot;;</span>
<a href="#l22.715"></a><span id="l22.715" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.716"></a><span id="l22.716" class="difflineplus">+                break;</span>
<a href="#l22.717"></a><span id="l22.717" class="difflineplus">+            }</span>
<a href="#l22.718"></a><span id="l22.718" class="difflineplus">+            if (state-&gt;flags &amp; 0xe000) {</span>
<a href="#l22.719"></a><span id="l22.719" class="difflineplus">+                strm-&gt;msg = (char *)&quot;unknown header flags set&quot;;</span>
<a href="#l22.720"></a><span id="l22.720" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.721"></a><span id="l22.721" class="difflineplus">+                break;</span>
<a href="#l22.722"></a><span id="l22.722" class="difflineplus">+            }</span>
<a href="#l22.723"></a><span id="l22.723" class="difflineplus">+            if (state-&gt;head != Z_NULL)</span>
<a href="#l22.724"></a><span id="l22.724" class="difflineplus">+                state-&gt;head-&gt;text = (int)((hold &gt;&gt; 8) &amp; 1);</span>
<a href="#l22.725"></a><span id="l22.725" class="difflineplus">+            if ((state-&gt;flags &amp; 0x0200) &amp;&amp; (state-&gt;wrap &amp; 4))</span>
<a href="#l22.726"></a><span id="l22.726" class="difflineplus">+                CRC2(state-&gt;check, hold);</span>
<a href="#l22.727"></a><span id="l22.727" class="difflineplus">+            INITBITS();</span>
<a href="#l22.728"></a><span id="l22.728" class="difflineplus">+            state-&gt;mode = TIME;</span>
<a href="#l22.729"></a><span id="l22.729" class="difflineplus">+        case TIME:</span>
<a href="#l22.730"></a><span id="l22.730" class="difflineplus">+            NEEDBITS(32);</span>
<a href="#l22.731"></a><span id="l22.731" class="difflineplus">+            if (state-&gt;head != Z_NULL)</span>
<a href="#l22.732"></a><span id="l22.732" class="difflineplus">+                state-&gt;head-&gt;time = hold;</span>
<a href="#l22.733"></a><span id="l22.733" class="difflineplus">+            if ((state-&gt;flags &amp; 0x0200) &amp;&amp; (state-&gt;wrap &amp; 4))</span>
<a href="#l22.734"></a><span id="l22.734" class="difflineplus">+                CRC4(state-&gt;check, hold);</span>
<a href="#l22.735"></a><span id="l22.735" class="difflineplus">+            INITBITS();</span>
<a href="#l22.736"></a><span id="l22.736" class="difflineplus">+            state-&gt;mode = OS;</span>
<a href="#l22.737"></a><span id="l22.737" class="difflineplus">+        case OS:</span>
<a href="#l22.738"></a><span id="l22.738" class="difflineplus">+            NEEDBITS(16);</span>
<a href="#l22.739"></a><span id="l22.739" class="difflineplus">+            if (state-&gt;head != Z_NULL) {</span>
<a href="#l22.740"></a><span id="l22.740" class="difflineplus">+                state-&gt;head-&gt;xflags = (int)(hold &amp; 0xff);</span>
<a href="#l22.741"></a><span id="l22.741" class="difflineplus">+                state-&gt;head-&gt;os = (int)(hold &gt;&gt; 8);</span>
<a href="#l22.742"></a><span id="l22.742" class="difflineplus">+            }</span>
<a href="#l22.743"></a><span id="l22.743" class="difflineplus">+            if ((state-&gt;flags &amp; 0x0200) &amp;&amp; (state-&gt;wrap &amp; 4))</span>
<a href="#l22.744"></a><span id="l22.744" class="difflineplus">+                CRC2(state-&gt;check, hold);</span>
<a href="#l22.745"></a><span id="l22.745" class="difflineplus">+            INITBITS();</span>
<a href="#l22.746"></a><span id="l22.746" class="difflineplus">+            state-&gt;mode = EXLEN;</span>
<a href="#l22.747"></a><span id="l22.747" class="difflineplus">+        case EXLEN:</span>
<a href="#l22.748"></a><span id="l22.748" class="difflineplus">+            if (state-&gt;flags &amp; 0x0400) {</span>
<a href="#l22.749"></a><span id="l22.749" class="difflineplus">+                NEEDBITS(16);</span>
<a href="#l22.750"></a><span id="l22.750" class="difflineplus">+                state-&gt;length = (unsigned)(hold);</span>
<a href="#l22.751"></a><span id="l22.751" class="difflineplus">+                if (state-&gt;head != Z_NULL)</span>
<a href="#l22.752"></a><span id="l22.752" class="difflineplus">+                    state-&gt;head-&gt;extra_len = (unsigned)hold;</span>
<a href="#l22.753"></a><span id="l22.753" class="difflineplus">+                if ((state-&gt;flags &amp; 0x0200) &amp;&amp; (state-&gt;wrap &amp; 4))</span>
<a href="#l22.754"></a><span id="l22.754" class="difflineplus">+                    CRC2(state-&gt;check, hold);</span>
<a href="#l22.755"></a><span id="l22.755" class="difflineplus">+                INITBITS();</span>
<a href="#l22.756"></a><span id="l22.756" class="difflineplus">+            }</span>
<a href="#l22.757"></a><span id="l22.757" class="difflineplus">+            else if (state-&gt;head != Z_NULL)</span>
<a href="#l22.758"></a><span id="l22.758" class="difflineplus">+                state-&gt;head-&gt;extra = Z_NULL;</span>
<a href="#l22.759"></a><span id="l22.759" class="difflineplus">+            state-&gt;mode = EXTRA;</span>
<a href="#l22.760"></a><span id="l22.760" class="difflineplus">+        case EXTRA:</span>
<a href="#l22.761"></a><span id="l22.761" class="difflineplus">+            if (state-&gt;flags &amp; 0x0400) {</span>
<a href="#l22.762"></a><span id="l22.762" class="difflineplus">+                copy = state-&gt;length;</span>
<a href="#l22.763"></a><span id="l22.763" class="difflineplus">+                if (copy &gt; have) copy = have;</span>
<a href="#l22.764"></a><span id="l22.764" class="difflineplus">+                if (copy) {</span>
<a href="#l22.765"></a><span id="l22.765" class="difflineplus">+                    if (state-&gt;head != Z_NULL &amp;&amp;</span>
<a href="#l22.766"></a><span id="l22.766" class="difflineplus">+                        state-&gt;head-&gt;extra != Z_NULL) {</span>
<a href="#l22.767"></a><span id="l22.767" class="difflineplus">+                        len = state-&gt;head-&gt;extra_len - state-&gt;length;</span>
<a href="#l22.768"></a><span id="l22.768" class="difflineplus">+                        zmemcpy(state-&gt;head-&gt;extra + len, next,</span>
<a href="#l22.769"></a><span id="l22.769" class="difflineplus">+                                len + copy &gt; state-&gt;head-&gt;extra_max ?</span>
<a href="#l22.770"></a><span id="l22.770" class="difflineplus">+                                state-&gt;head-&gt;extra_max - len : copy);</span>
<a href="#l22.771"></a><span id="l22.771" class="difflineplus">+                    }</span>
<a href="#l22.772"></a><span id="l22.772" class="difflineplus">+                    if ((state-&gt;flags &amp; 0x0200) &amp;&amp; (state-&gt;wrap &amp; 4))</span>
<a href="#l22.773"></a><span id="l22.773" class="difflineplus">+                        state-&gt;check = crc32(state-&gt;check, next, copy);</span>
<a href="#l22.774"></a><span id="l22.774" class="difflineplus">+                    have -= copy;</span>
<a href="#l22.775"></a><span id="l22.775" class="difflineplus">+                    next += copy;</span>
<a href="#l22.776"></a><span id="l22.776" class="difflineplus">+                    state-&gt;length -= copy;</span>
<a href="#l22.777"></a><span id="l22.777" class="difflineplus">+                }</span>
<a href="#l22.778"></a><span id="l22.778" class="difflineplus">+                if (state-&gt;length) goto inf_leave;</span>
<a href="#l22.779"></a><span id="l22.779" class="difflineplus">+            }</span>
<a href="#l22.780"></a><span id="l22.780" class="difflineplus">+            state-&gt;length = 0;</span>
<a href="#l22.781"></a><span id="l22.781" class="difflineplus">+            state-&gt;mode = NAME;</span>
<a href="#l22.782"></a><span id="l22.782" class="difflineplus">+        case NAME:</span>
<a href="#l22.783"></a><span id="l22.783" class="difflineplus">+            if (state-&gt;flags &amp; 0x0800) {</span>
<a href="#l22.784"></a><span id="l22.784" class="difflineplus">+                if (have == 0) goto inf_leave;</span>
<a href="#l22.785"></a><span id="l22.785" class="difflineplus">+                copy = 0;</span>
<a href="#l22.786"></a><span id="l22.786" class="difflineplus">+                do {</span>
<a href="#l22.787"></a><span id="l22.787" class="difflineplus">+                    len = (unsigned)(next[copy++]);</span>
<a href="#l22.788"></a><span id="l22.788" class="difflineplus">+                    if (state-&gt;head != Z_NULL &amp;&amp;</span>
<a href="#l22.789"></a><span id="l22.789" class="difflineplus">+                            state-&gt;head-&gt;name != Z_NULL &amp;&amp;</span>
<a href="#l22.790"></a><span id="l22.790" class="difflineplus">+                            state-&gt;length &lt; state-&gt;head-&gt;name_max)</span>
<a href="#l22.791"></a><span id="l22.791" class="difflineplus">+                        state-&gt;head-&gt;name[state-&gt;length++] = (Bytef)len;</span>
<a href="#l22.792"></a><span id="l22.792" class="difflineplus">+                } while (len &amp;&amp; copy &lt; have);</span>
<a href="#l22.793"></a><span id="l22.793" class="difflineplus">+                if ((state-&gt;flags &amp; 0x0200) &amp;&amp; (state-&gt;wrap &amp; 4))</span>
<a href="#l22.794"></a><span id="l22.794" class="difflineplus">+                    state-&gt;check = crc32(state-&gt;check, next, copy);</span>
<a href="#l22.795"></a><span id="l22.795" class="difflineplus">+                have -= copy;</span>
<a href="#l22.796"></a><span id="l22.796" class="difflineplus">+                next += copy;</span>
<a href="#l22.797"></a><span id="l22.797" class="difflineplus">+                if (len) goto inf_leave;</span>
<a href="#l22.798"></a><span id="l22.798" class="difflineplus">+            }</span>
<a href="#l22.799"></a><span id="l22.799" class="difflineplus">+            else if (state-&gt;head != Z_NULL)</span>
<a href="#l22.800"></a><span id="l22.800" class="difflineplus">+                state-&gt;head-&gt;name = Z_NULL;</span>
<a href="#l22.801"></a><span id="l22.801" class="difflineplus">+            state-&gt;length = 0;</span>
<a href="#l22.802"></a><span id="l22.802" class="difflineplus">+            state-&gt;mode = COMMENT;</span>
<a href="#l22.803"></a><span id="l22.803" class="difflineplus">+        case COMMENT:</span>
<a href="#l22.804"></a><span id="l22.804" class="difflineplus">+            if (state-&gt;flags &amp; 0x1000) {</span>
<a href="#l22.805"></a><span id="l22.805" class="difflineplus">+                if (have == 0) goto inf_leave;</span>
<a href="#l22.806"></a><span id="l22.806" class="difflineplus">+                copy = 0;</span>
<a href="#l22.807"></a><span id="l22.807" class="difflineplus">+                do {</span>
<a href="#l22.808"></a><span id="l22.808" class="difflineplus">+                    len = (unsigned)(next[copy++]);</span>
<a href="#l22.809"></a><span id="l22.809" class="difflineplus">+                    if (state-&gt;head != Z_NULL &amp;&amp;</span>
<a href="#l22.810"></a><span id="l22.810" class="difflineplus">+                            state-&gt;head-&gt;comment != Z_NULL &amp;&amp;</span>
<a href="#l22.811"></a><span id="l22.811" class="difflineplus">+                            state-&gt;length &lt; state-&gt;head-&gt;comm_max)</span>
<a href="#l22.812"></a><span id="l22.812" class="difflineplus">+                        state-&gt;head-&gt;comment[state-&gt;length++] = (Bytef)len;</span>
<a href="#l22.813"></a><span id="l22.813" class="difflineplus">+                } while (len &amp;&amp; copy &lt; have);</span>
<a href="#l22.814"></a><span id="l22.814" class="difflineplus">+                if ((state-&gt;flags &amp; 0x0200) &amp;&amp; (state-&gt;wrap &amp; 4))</span>
<a href="#l22.815"></a><span id="l22.815" class="difflineplus">+                    state-&gt;check = crc32(state-&gt;check, next, copy);</span>
<a href="#l22.816"></a><span id="l22.816" class="difflineplus">+                have -= copy;</span>
<a href="#l22.817"></a><span id="l22.817" class="difflineplus">+                next += copy;</span>
<a href="#l22.818"></a><span id="l22.818" class="difflineplus">+                if (len) goto inf_leave;</span>
<a href="#l22.819"></a><span id="l22.819" class="difflineplus">+            }</span>
<a href="#l22.820"></a><span id="l22.820" class="difflineplus">+            else if (state-&gt;head != Z_NULL)</span>
<a href="#l22.821"></a><span id="l22.821" class="difflineplus">+                state-&gt;head-&gt;comment = Z_NULL;</span>
<a href="#l22.822"></a><span id="l22.822" class="difflineplus">+            state-&gt;mode = HCRC;</span>
<a href="#l22.823"></a><span id="l22.823" class="difflineplus">+        case HCRC:</span>
<a href="#l22.824"></a><span id="l22.824" class="difflineplus">+            if (state-&gt;flags &amp; 0x0200) {</span>
<a href="#l22.825"></a><span id="l22.825" class="difflineplus">+                NEEDBITS(16);</span>
<a href="#l22.826"></a><span id="l22.826" class="difflineplus">+                if ((state-&gt;wrap &amp; 4) &amp;&amp; hold != (state-&gt;check &amp; 0xffff)) {</span>
<a href="#l22.827"></a><span id="l22.827" class="difflineplus">+                    strm-&gt;msg = (char *)&quot;header crc mismatch&quot;;</span>
<a href="#l22.828"></a><span id="l22.828" class="difflineplus">+                    state-&gt;mode = BAD;</span>
<a href="#l22.829"></a><span id="l22.829" class="difflineplus">+                    break;</span>
<a href="#l22.830"></a><span id="l22.830" class="difflineplus">+                }</span>
<a href="#l22.831"></a><span id="l22.831" class="difflineplus">+                INITBITS();</span>
<a href="#l22.832"></a><span id="l22.832" class="difflineplus">+            }</span>
<a href="#l22.833"></a><span id="l22.833" class="difflineplus">+            if (state-&gt;head != Z_NULL) {</span>
<a href="#l22.834"></a><span id="l22.834" class="difflineplus">+                state-&gt;head-&gt;hcrc = (int)((state-&gt;flags &gt;&gt; 9) &amp; 1);</span>
<a href="#l22.835"></a><span id="l22.835" class="difflineplus">+                state-&gt;head-&gt;done = 1;</span>
<a href="#l22.836"></a><span id="l22.836" class="difflineplus">+            }</span>
<a href="#l22.837"></a><span id="l22.837" class="difflineplus">+            strm-&gt;adler = state-&gt;check = crc32(0L, Z_NULL, 0);</span>
<a href="#l22.838"></a><span id="l22.838" class="difflineplus">+            state-&gt;mode = TYPE;</span>
<a href="#l22.839"></a><span id="l22.839" class="difflineplus">+            break;</span>
<a href="#l22.840"></a><span id="l22.840" class="difflineplus">+#endif</span>
<a href="#l22.841"></a><span id="l22.841" class="difflineplus">+        case DICTID:</span>
<a href="#l22.842"></a><span id="l22.842" class="difflineplus">+            NEEDBITS(32);</span>
<a href="#l22.843"></a><span id="l22.843" class="difflineplus">+            strm-&gt;adler = state-&gt;check = ZSWAP32(hold);</span>
<a href="#l22.844"></a><span id="l22.844" class="difflineplus">+            INITBITS();</span>
<a href="#l22.845"></a><span id="l22.845" class="difflineplus">+            state-&gt;mode = DICT;</span>
<a href="#l22.846"></a><span id="l22.846" class="difflineplus">+        case DICT:</span>
<a href="#l22.847"></a><span id="l22.847" class="difflineplus">+            if (state-&gt;havedict == 0) {</span>
<a href="#l22.848"></a><span id="l22.848" class="difflineplus">+                RESTORE();</span>
<a href="#l22.849"></a><span id="l22.849" class="difflineplus">+                return Z_NEED_DICT;</span>
<a href="#l22.850"></a><span id="l22.850" class="difflineplus">+            }</span>
<a href="#l22.851"></a><span id="l22.851" class="difflineplus">+            strm-&gt;adler = state-&gt;check = adler32(0L, Z_NULL, 0);</span>
<a href="#l22.852"></a><span id="l22.852" class="difflineplus">+            state-&gt;mode = TYPE;</span>
<a href="#l22.853"></a><span id="l22.853" class="difflineplus">+        case TYPE:</span>
<a href="#l22.854"></a><span id="l22.854" class="difflineplus">+            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;</span>
<a href="#l22.855"></a><span id="l22.855" class="difflineplus">+        case TYPEDO:</span>
<a href="#l22.856"></a><span id="l22.856" class="difflineplus">+            if (state-&gt;last) {</span>
<a href="#l22.857"></a><span id="l22.857" class="difflineplus">+                BYTEBITS();</span>
<a href="#l22.858"></a><span id="l22.858" class="difflineplus">+                state-&gt;mode = CHECK;</span>
<a href="#l22.859"></a><span id="l22.859" class="difflineplus">+                break;</span>
<a href="#l22.860"></a><span id="l22.860" class="difflineplus">+            }</span>
<a href="#l22.861"></a><span id="l22.861" class="difflineplus">+            NEEDBITS(3);</span>
<a href="#l22.862"></a><span id="l22.862" class="difflineplus">+            state-&gt;last = BITS(1);</span>
<a href="#l22.863"></a><span id="l22.863" class="difflineplus">+            DROPBITS(1);</span>
<a href="#l22.864"></a><span id="l22.864" class="difflineplus">+            switch (BITS(2)) {</span>
<a href="#l22.865"></a><span id="l22.865" class="difflineplus">+            case 0:                             /* stored block */</span>
<a href="#l22.866"></a><span id="l22.866" class="difflineplus">+                Tracev((stderr, &quot;inflate:     stored block%s\n&quot;,</span>
<a href="#l22.867"></a><span id="l22.867" class="difflineplus">+                        state-&gt;last ? &quot; (last)&quot; : &quot;&quot;));</span>
<a href="#l22.868"></a><span id="l22.868" class="difflineplus">+                state-&gt;mode = STORED;</span>
<a href="#l22.869"></a><span id="l22.869" class="difflineplus">+                break;</span>
<a href="#l22.870"></a><span id="l22.870" class="difflineplus">+            case 1:                             /* fixed block */</span>
<a href="#l22.871"></a><span id="l22.871" class="difflineplus">+                fixedtables(state);</span>
<a href="#l22.872"></a><span id="l22.872" class="difflineplus">+                Tracev((stderr, &quot;inflate:     fixed codes block%s\n&quot;,</span>
<a href="#l22.873"></a><span id="l22.873" class="difflineplus">+                        state-&gt;last ? &quot; (last)&quot; : &quot;&quot;));</span>
<a href="#l22.874"></a><span id="l22.874" class="difflineplus">+                state-&gt;mode = LEN_;             /* decode codes */</span>
<a href="#l22.875"></a><span id="l22.875" class="difflineplus">+                if (flush == Z_TREES) {</span>
<a href="#l22.876"></a><span id="l22.876" class="difflineplus">+                    DROPBITS(2);</span>
<a href="#l22.877"></a><span id="l22.877" class="difflineplus">+                    goto inf_leave;</span>
<a href="#l22.878"></a><span id="l22.878" class="difflineplus">+                }</span>
<a href="#l22.879"></a><span id="l22.879" class="difflineplus">+                break;</span>
<a href="#l22.880"></a><span id="l22.880" class="difflineplus">+            case 2:                             /* dynamic block */</span>
<a href="#l22.881"></a><span id="l22.881" class="difflineplus">+                Tracev((stderr, &quot;inflate:     dynamic codes block%s\n&quot;,</span>
<a href="#l22.882"></a><span id="l22.882" class="difflineplus">+                        state-&gt;last ? &quot; (last)&quot; : &quot;&quot;));</span>
<a href="#l22.883"></a><span id="l22.883" class="difflineplus">+                state-&gt;mode = TABLE;</span>
<a href="#l22.884"></a><span id="l22.884" class="difflineplus">+                break;</span>
<a href="#l22.885"></a><span id="l22.885" class="difflineplus">+            case 3:</span>
<a href="#l22.886"></a><span id="l22.886" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid block type&quot;;</span>
<a href="#l22.887"></a><span id="l22.887" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.888"></a><span id="l22.888" class="difflineplus">+            }</span>
<a href="#l22.889"></a><span id="l22.889" class="difflineplus">+            DROPBITS(2);</span>
<a href="#l22.890"></a><span id="l22.890" class="difflineplus">+            break;</span>
<a href="#l22.891"></a><span id="l22.891" class="difflineplus">+        case STORED:</span>
<a href="#l22.892"></a><span id="l22.892" class="difflineplus">+            BYTEBITS();                         /* go to byte boundary */</span>
<a href="#l22.893"></a><span id="l22.893" class="difflineplus">+            NEEDBITS(32);</span>
<a href="#l22.894"></a><span id="l22.894" class="difflineplus">+            if ((hold &amp; 0xffff) != ((hold &gt;&gt; 16) ^ 0xffff)) {</span>
<a href="#l22.895"></a><span id="l22.895" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid stored block lengths&quot;;</span>
<a href="#l22.896"></a><span id="l22.896" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.897"></a><span id="l22.897" class="difflineplus">+                break;</span>
<a href="#l22.898"></a><span id="l22.898" class="difflineplus">+            }</span>
<a href="#l22.899"></a><span id="l22.899" class="difflineplus">+            state-&gt;length = (unsigned)hold &amp; 0xffff;</span>
<a href="#l22.900"></a><span id="l22.900" class="difflineplus">+            Tracev((stderr, &quot;inflate:       stored length %u\n&quot;,</span>
<a href="#l22.901"></a><span id="l22.901" class="difflineplus">+                    state-&gt;length));</span>
<a href="#l22.902"></a><span id="l22.902" class="difflineplus">+            INITBITS();</span>
<a href="#l22.903"></a><span id="l22.903" class="difflineplus">+            state-&gt;mode = COPY_;</span>
<a href="#l22.904"></a><span id="l22.904" class="difflineplus">+            if (flush == Z_TREES) goto inf_leave;</span>
<a href="#l22.905"></a><span id="l22.905" class="difflineplus">+        case COPY_:</span>
<a href="#l22.906"></a><span id="l22.906" class="difflineplus">+            state-&gt;mode = COPY;</span>
<a href="#l22.907"></a><span id="l22.907" class="difflineplus">+        case COPY:</span>
<a href="#l22.908"></a><span id="l22.908" class="difflineplus">+            copy = state-&gt;length;</span>
<a href="#l22.909"></a><span id="l22.909" class="difflineplus">+            if (copy) {</span>
<a href="#l22.910"></a><span id="l22.910" class="difflineplus">+                if (copy &gt; have) copy = have;</span>
<a href="#l22.911"></a><span id="l22.911" class="difflineplus">+                if (copy &gt; left) copy = left;</span>
<a href="#l22.912"></a><span id="l22.912" class="difflineplus">+                if (copy == 0) goto inf_leave;</span>
<a href="#l22.913"></a><span id="l22.913" class="difflineplus">+                zmemcpy(put, next, copy);</span>
<a href="#l22.914"></a><span id="l22.914" class="difflineplus">+                have -= copy;</span>
<a href="#l22.915"></a><span id="l22.915" class="difflineplus">+                next += copy;</span>
<a href="#l22.916"></a><span id="l22.916" class="difflineplus">+                left -= copy;</span>
<a href="#l22.917"></a><span id="l22.917" class="difflineplus">+                put += copy;</span>
<a href="#l22.918"></a><span id="l22.918" class="difflineplus">+                state-&gt;length -= copy;</span>
<a href="#l22.919"></a><span id="l22.919" class="difflineplus">+                break;</span>
<a href="#l22.920"></a><span id="l22.920" class="difflineplus">+            }</span>
<a href="#l22.921"></a><span id="l22.921" class="difflineplus">+            Tracev((stderr, &quot;inflate:       stored end\n&quot;));</span>
<a href="#l22.922"></a><span id="l22.922" class="difflineplus">+            state-&gt;mode = TYPE;</span>
<a href="#l22.923"></a><span id="l22.923" class="difflineplus">+            break;</span>
<a href="#l22.924"></a><span id="l22.924" class="difflineplus">+        case TABLE:</span>
<a href="#l22.925"></a><span id="l22.925" class="difflineplus">+            NEEDBITS(14);</span>
<a href="#l22.926"></a><span id="l22.926" class="difflineplus">+            state-&gt;nlen = BITS(5) + 257;</span>
<a href="#l22.927"></a><span id="l22.927" class="difflineplus">+            DROPBITS(5);</span>
<a href="#l22.928"></a><span id="l22.928" class="difflineplus">+            state-&gt;ndist = BITS(5) + 1;</span>
<a href="#l22.929"></a><span id="l22.929" class="difflineplus">+            DROPBITS(5);</span>
<a href="#l22.930"></a><span id="l22.930" class="difflineplus">+            state-&gt;ncode = BITS(4) + 4;</span>
<a href="#l22.931"></a><span id="l22.931" class="difflineplus">+            DROPBITS(4);</span>
<a href="#l22.932"></a><span id="l22.932" class="difflineplus">+#ifndef PKZIP_BUG_WORKAROUND</span>
<a href="#l22.933"></a><span id="l22.933" class="difflineplus">+            if (state-&gt;nlen &gt; 286 || state-&gt;ndist &gt; 30) {</span>
<a href="#l22.934"></a><span id="l22.934" class="difflineplus">+                strm-&gt;msg = (char *)&quot;too many length or distance symbols&quot;;</span>
<a href="#l22.935"></a><span id="l22.935" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.936"></a><span id="l22.936" class="difflineplus">+                break;</span>
<a href="#l22.937"></a><span id="l22.937" class="difflineplus">+            }</span>
<a href="#l22.938"></a><span id="l22.938" class="difflineplus">+#endif</span>
<a href="#l22.939"></a><span id="l22.939" class="difflineplus">+            Tracev((stderr, &quot;inflate:       table sizes ok\n&quot;));</span>
<a href="#l22.940"></a><span id="l22.940" class="difflineplus">+            state-&gt;have = 0;</span>
<a href="#l22.941"></a><span id="l22.941" class="difflineplus">+            state-&gt;mode = LENLENS;</span>
<a href="#l22.942"></a><span id="l22.942" class="difflineplus">+        case LENLENS:</span>
<a href="#l22.943"></a><span id="l22.943" class="difflineplus">+            while (state-&gt;have &lt; state-&gt;ncode) {</span>
<a href="#l22.944"></a><span id="l22.944" class="difflineplus">+                NEEDBITS(3);</span>
<a href="#l22.945"></a><span id="l22.945" class="difflineplus">+                state-&gt;lens[order[state-&gt;have++]] = (unsigned short)BITS(3);</span>
<a href="#l22.946"></a><span id="l22.946" class="difflineplus">+                DROPBITS(3);</span>
<a href="#l22.947"></a><span id="l22.947" class="difflineplus">+            }</span>
<a href="#l22.948"></a><span id="l22.948" class="difflineplus">+            while (state-&gt;have &lt; 19)</span>
<a href="#l22.949"></a><span id="l22.949" class="difflineplus">+                state-&gt;lens[order[state-&gt;have++]] = 0;</span>
<a href="#l22.950"></a><span id="l22.950" class="difflineplus">+            state-&gt;next = state-&gt;codes;</span>
<a href="#l22.951"></a><span id="l22.951" class="difflineplus">+            state-&gt;lencode = (const code FAR *)(state-&gt;next);</span>
<a href="#l22.952"></a><span id="l22.952" class="difflineplus">+            state-&gt;lenbits = 7;</span>
<a href="#l22.953"></a><span id="l22.953" class="difflineplus">+            ret = inflate_table(CODES, state-&gt;lens, 19, &amp;(state-&gt;next),</span>
<a href="#l22.954"></a><span id="l22.954" class="difflineplus">+                                &amp;(state-&gt;lenbits), state-&gt;work);</span>
<a href="#l22.955"></a><span id="l22.955" class="difflineplus">+            if (ret) {</span>
<a href="#l22.956"></a><span id="l22.956" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid code lengths set&quot;;</span>
<a href="#l22.957"></a><span id="l22.957" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.958"></a><span id="l22.958" class="difflineplus">+                break;</span>
<a href="#l22.959"></a><span id="l22.959" class="difflineplus">+            }</span>
<a href="#l22.960"></a><span id="l22.960" class="difflineplus">+            Tracev((stderr, &quot;inflate:       code lengths ok\n&quot;));</span>
<a href="#l22.961"></a><span id="l22.961" class="difflineplus">+            state-&gt;have = 0;</span>
<a href="#l22.962"></a><span id="l22.962" class="difflineplus">+            state-&gt;mode = CODELENS;</span>
<a href="#l22.963"></a><span id="l22.963" class="difflineplus">+        case CODELENS:</span>
<a href="#l22.964"></a><span id="l22.964" class="difflineplus">+            while (state-&gt;have &lt; state-&gt;nlen + state-&gt;ndist) {</span>
<a href="#l22.965"></a><span id="l22.965" class="difflineplus">+                for (;;) {</span>
<a href="#l22.966"></a><span id="l22.966" class="difflineplus">+                    here = state-&gt;lencode[BITS(state-&gt;lenbits)];</span>
<a href="#l22.967"></a><span id="l22.967" class="difflineplus">+                    if ((unsigned)(here.bits) &lt;= bits) break;</span>
<a href="#l22.968"></a><span id="l22.968" class="difflineplus">+                    PULLBYTE();</span>
<a href="#l22.969"></a><span id="l22.969" class="difflineplus">+                }</span>
<a href="#l22.970"></a><span id="l22.970" class="difflineplus">+                if (here.val &lt; 16) {</span>
<a href="#l22.971"></a><span id="l22.971" class="difflineplus">+                    DROPBITS(here.bits);</span>
<a href="#l22.972"></a><span id="l22.972" class="difflineplus">+                    state-&gt;lens[state-&gt;have++] = here.val;</span>
<a href="#l22.973"></a><span id="l22.973" class="difflineplus">+                }</span>
<a href="#l22.974"></a><span id="l22.974" class="difflineplus">+                else {</span>
<a href="#l22.975"></a><span id="l22.975" class="difflineplus">+                    if (here.val == 16) {</span>
<a href="#l22.976"></a><span id="l22.976" class="difflineplus">+                        NEEDBITS(here.bits + 2);</span>
<a href="#l22.977"></a><span id="l22.977" class="difflineplus">+                        DROPBITS(here.bits);</span>
<a href="#l22.978"></a><span id="l22.978" class="difflineplus">+                        if (state-&gt;have == 0) {</span>
<a href="#l22.979"></a><span id="l22.979" class="difflineplus">+                            strm-&gt;msg = (char *)&quot;invalid bit length repeat&quot;;</span>
<a href="#l22.980"></a><span id="l22.980" class="difflineplus">+                            state-&gt;mode = BAD;</span>
<a href="#l22.981"></a><span id="l22.981" class="difflineplus">+                            break;</span>
<a href="#l22.982"></a><span id="l22.982" class="difflineplus">+                        }</span>
<a href="#l22.983"></a><span id="l22.983" class="difflineplus">+                        len = state-&gt;lens[state-&gt;have - 1];</span>
<a href="#l22.984"></a><span id="l22.984" class="difflineplus">+                        copy = 3 + BITS(2);</span>
<a href="#l22.985"></a><span id="l22.985" class="difflineplus">+                        DROPBITS(2);</span>
<a href="#l22.986"></a><span id="l22.986" class="difflineplus">+                    }</span>
<a href="#l22.987"></a><span id="l22.987" class="difflineplus">+                    else if (here.val == 17) {</span>
<a href="#l22.988"></a><span id="l22.988" class="difflineplus">+                        NEEDBITS(here.bits + 3);</span>
<a href="#l22.989"></a><span id="l22.989" class="difflineplus">+                        DROPBITS(here.bits);</span>
<a href="#l22.990"></a><span id="l22.990" class="difflineplus">+                        len = 0;</span>
<a href="#l22.991"></a><span id="l22.991" class="difflineplus">+                        copy = 3 + BITS(3);</span>
<a href="#l22.992"></a><span id="l22.992" class="difflineplus">+                        DROPBITS(3);</span>
<a href="#l22.993"></a><span id="l22.993" class="difflineplus">+                    }</span>
<a href="#l22.994"></a><span id="l22.994" class="difflineplus">+                    else {</span>
<a href="#l22.995"></a><span id="l22.995" class="difflineplus">+                        NEEDBITS(here.bits + 7);</span>
<a href="#l22.996"></a><span id="l22.996" class="difflineplus">+                        DROPBITS(here.bits);</span>
<a href="#l22.997"></a><span id="l22.997" class="difflineplus">+                        len = 0;</span>
<a href="#l22.998"></a><span id="l22.998" class="difflineplus">+                        copy = 11 + BITS(7);</span>
<a href="#l22.999"></a><span id="l22.999" class="difflineplus">+                        DROPBITS(7);</span>
<a href="#l22.1000"></a><span id="l22.1000" class="difflineplus">+                    }</span>
<a href="#l22.1001"></a><span id="l22.1001" class="difflineplus">+                    if (state-&gt;have + copy &gt; state-&gt;nlen + state-&gt;ndist) {</span>
<a href="#l22.1002"></a><span id="l22.1002" class="difflineplus">+                        strm-&gt;msg = (char *)&quot;invalid bit length repeat&quot;;</span>
<a href="#l22.1003"></a><span id="l22.1003" class="difflineplus">+                        state-&gt;mode = BAD;</span>
<a href="#l22.1004"></a><span id="l22.1004" class="difflineplus">+                        break;</span>
<a href="#l22.1005"></a><span id="l22.1005" class="difflineplus">+                    }</span>
<a href="#l22.1006"></a><span id="l22.1006" class="difflineplus">+                    while (copy--)</span>
<a href="#l22.1007"></a><span id="l22.1007" class="difflineplus">+                        state-&gt;lens[state-&gt;have++] = (unsigned short)len;</span>
<a href="#l22.1008"></a><span id="l22.1008" class="difflineplus">+                }</span>
<a href="#l22.1009"></a><span id="l22.1009" class="difflineplus">+            }</span>
<a href="#l22.1010"></a><span id="l22.1010" class="difflineplus">+</span>
<a href="#l22.1011"></a><span id="l22.1011" class="difflineplus">+            /* handle error breaks in while */</span>
<a href="#l22.1012"></a><span id="l22.1012" class="difflineplus">+            if (state-&gt;mode == BAD) break;</span>
<a href="#l22.1013"></a><span id="l22.1013" class="difflineplus">+</span>
<a href="#l22.1014"></a><span id="l22.1014" class="difflineplus">+            /* check for end-of-block code (better have one) */</span>
<a href="#l22.1015"></a><span id="l22.1015" class="difflineplus">+            if (state-&gt;lens[256] == 0) {</span>
<a href="#l22.1016"></a><span id="l22.1016" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid code -- missing end-of-block&quot;;</span>
<a href="#l22.1017"></a><span id="l22.1017" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.1018"></a><span id="l22.1018" class="difflineplus">+                break;</span>
<a href="#l22.1019"></a><span id="l22.1019" class="difflineplus">+            }</span>
<a href="#l22.1020"></a><span id="l22.1020" class="difflineplus">+</span>
<a href="#l22.1021"></a><span id="l22.1021" class="difflineplus">+            /* build code tables -- note: do not change the lenbits or distbits</span>
<a href="#l22.1022"></a><span id="l22.1022" class="difflineplus">+               values here (9 and 6) without reading the comments in inftrees.h</span>
<a href="#l22.1023"></a><span id="l22.1023" class="difflineplus">+               concerning the ENOUGH constants, which depend on those values */</span>
<a href="#l22.1024"></a><span id="l22.1024" class="difflineplus">+            state-&gt;next = state-&gt;codes;</span>
<a href="#l22.1025"></a><span id="l22.1025" class="difflineplus">+            state-&gt;lencode = (const code FAR *)(state-&gt;next);</span>
<a href="#l22.1026"></a><span id="l22.1026" class="difflineplus">+            state-&gt;lenbits = 9;</span>
<a href="#l22.1027"></a><span id="l22.1027" class="difflineplus">+            ret = inflate_table(LENS, state-&gt;lens, state-&gt;nlen, &amp;(state-&gt;next),</span>
<a href="#l22.1028"></a><span id="l22.1028" class="difflineplus">+                                &amp;(state-&gt;lenbits), state-&gt;work);</span>
<a href="#l22.1029"></a><span id="l22.1029" class="difflineplus">+            if (ret) {</span>
<a href="#l22.1030"></a><span id="l22.1030" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid literal/lengths set&quot;;</span>
<a href="#l22.1031"></a><span id="l22.1031" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.1032"></a><span id="l22.1032" class="difflineplus">+                break;</span>
<a href="#l22.1033"></a><span id="l22.1033" class="difflineplus">+            }</span>
<a href="#l22.1034"></a><span id="l22.1034" class="difflineplus">+            state-&gt;distcode = (const code FAR *)(state-&gt;next);</span>
<a href="#l22.1035"></a><span id="l22.1035" class="difflineplus">+            state-&gt;distbits = 6;</span>
<a href="#l22.1036"></a><span id="l22.1036" class="difflineplus">+            ret = inflate_table(DISTS, state-&gt;lens + state-&gt;nlen, state-&gt;ndist,</span>
<a href="#l22.1037"></a><span id="l22.1037" class="difflineplus">+                            &amp;(state-&gt;next), &amp;(state-&gt;distbits), state-&gt;work);</span>
<a href="#l22.1038"></a><span id="l22.1038" class="difflineplus">+            if (ret) {</span>
<a href="#l22.1039"></a><span id="l22.1039" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid distances set&quot;;</span>
<a href="#l22.1040"></a><span id="l22.1040" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.1041"></a><span id="l22.1041" class="difflineplus">+                break;</span>
<a href="#l22.1042"></a><span id="l22.1042" class="difflineplus">+            }</span>
<a href="#l22.1043"></a><span id="l22.1043" class="difflineplus">+            Tracev((stderr, &quot;inflate:       codes ok\n&quot;));</span>
<a href="#l22.1044"></a><span id="l22.1044" class="difflineplus">+            state-&gt;mode = LEN_;</span>
<a href="#l22.1045"></a><span id="l22.1045" class="difflineplus">+            if (flush == Z_TREES) goto inf_leave;</span>
<a href="#l22.1046"></a><span id="l22.1046" class="difflineplus">+        case LEN_:</span>
<a href="#l22.1047"></a><span id="l22.1047" class="difflineplus">+            state-&gt;mode = LEN;</span>
<a href="#l22.1048"></a><span id="l22.1048" class="difflineplus">+        case LEN:</span>
<a href="#l22.1049"></a><span id="l22.1049" class="difflineplus">+            if (have &gt;= 6 &amp;&amp; left &gt;= 258) {</span>
<a href="#l22.1050"></a><span id="l22.1050" class="difflineplus">+                RESTORE();</span>
<a href="#l22.1051"></a><span id="l22.1051" class="difflineplus">+                inflate_fast(strm, out);</span>
<a href="#l22.1052"></a><span id="l22.1052" class="difflineplus">+                LOAD();</span>
<a href="#l22.1053"></a><span id="l22.1053" class="difflineplus">+                if (state-&gt;mode == TYPE)</span>
<a href="#l22.1054"></a><span id="l22.1054" class="difflineplus">+                    state-&gt;back = -1;</span>
<a href="#l22.1055"></a><span id="l22.1055" class="difflineplus">+                break;</span>
<a href="#l22.1056"></a><span id="l22.1056" class="difflineplus">+            }</span>
<a href="#l22.1057"></a><span id="l22.1057" class="difflineplus">+            state-&gt;back = 0;</span>
<a href="#l22.1058"></a><span id="l22.1058" class="difflineplus">+            for (;;) {</span>
<a href="#l22.1059"></a><span id="l22.1059" class="difflineplus">+                here = state-&gt;lencode[BITS(state-&gt;lenbits)];</span>
<a href="#l22.1060"></a><span id="l22.1060" class="difflineplus">+                if ((unsigned)(here.bits) &lt;= bits) break;</span>
<a href="#l22.1061"></a><span id="l22.1061" class="difflineplus">+                PULLBYTE();</span>
<a href="#l22.1062"></a><span id="l22.1062" class="difflineplus">+            }</span>
<a href="#l22.1063"></a><span id="l22.1063" class="difflineplus">+            if (here.op &amp;&amp; (here.op &amp; 0xf0) == 0) {</span>
<a href="#l22.1064"></a><span id="l22.1064" class="difflineplus">+                last = here;</span>
<a href="#l22.1065"></a><span id="l22.1065" class="difflineplus">+                for (;;) {</span>
<a href="#l22.1066"></a><span id="l22.1066" class="difflineplus">+                    here = state-&gt;lencode[last.val +</span>
<a href="#l22.1067"></a><span id="l22.1067" class="difflineplus">+                            (BITS(last.bits + last.op) &gt;&gt; last.bits)];</span>
<a href="#l22.1068"></a><span id="l22.1068" class="difflineplus">+                    if ((unsigned)(last.bits + here.bits) &lt;= bits) break;</span>
<a href="#l22.1069"></a><span id="l22.1069" class="difflineplus">+                    PULLBYTE();</span>
<a href="#l22.1070"></a><span id="l22.1070" class="difflineplus">+                }</span>
<a href="#l22.1071"></a><span id="l22.1071" class="difflineplus">+                DROPBITS(last.bits);</span>
<a href="#l22.1072"></a><span id="l22.1072" class="difflineplus">+                state-&gt;back += last.bits;</span>
<a href="#l22.1073"></a><span id="l22.1073" class="difflineplus">+            }</span>
<a href="#l22.1074"></a><span id="l22.1074" class="difflineplus">+            DROPBITS(here.bits);</span>
<a href="#l22.1075"></a><span id="l22.1075" class="difflineplus">+            state-&gt;back += here.bits;</span>
<a href="#l22.1076"></a><span id="l22.1076" class="difflineplus">+            state-&gt;length = (unsigned)here.val;</span>
<a href="#l22.1077"></a><span id="l22.1077" class="difflineplus">+            if ((int)(here.op) == 0) {</span>
<a href="#l22.1078"></a><span id="l22.1078" class="difflineplus">+                Tracevv((stderr, here.val &gt;= 0x20 &amp;&amp; here.val &lt; 0x7f ?</span>
<a href="#l22.1079"></a><span id="l22.1079" class="difflineplus">+                        &quot;inflate:         literal '%c'\n&quot; :</span>
<a href="#l22.1080"></a><span id="l22.1080" class="difflineplus">+                        &quot;inflate:         literal 0x%02x\n&quot;, here.val));</span>
<a href="#l22.1081"></a><span id="l22.1081" class="difflineplus">+                state-&gt;mode = LIT;</span>
<a href="#l22.1082"></a><span id="l22.1082" class="difflineplus">+                break;</span>
<a href="#l22.1083"></a><span id="l22.1083" class="difflineplus">+            }</span>
<a href="#l22.1084"></a><span id="l22.1084" class="difflineplus">+            if (here.op &amp; 32) {</span>
<a href="#l22.1085"></a><span id="l22.1085" class="difflineplus">+                Tracevv((stderr, &quot;inflate:         end of block\n&quot;));</span>
<a href="#l22.1086"></a><span id="l22.1086" class="difflineplus">+                state-&gt;back = -1;</span>
<a href="#l22.1087"></a><span id="l22.1087" class="difflineplus">+                state-&gt;mode = TYPE;</span>
<a href="#l22.1088"></a><span id="l22.1088" class="difflineplus">+                break;</span>
<a href="#l22.1089"></a><span id="l22.1089" class="difflineplus">+            }</span>
<a href="#l22.1090"></a><span id="l22.1090" class="difflineplus">+            if (here.op &amp; 64) {</span>
<a href="#l22.1091"></a><span id="l22.1091" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid literal/length code&quot;;</span>
<a href="#l22.1092"></a><span id="l22.1092" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.1093"></a><span id="l22.1093" class="difflineplus">+                break;</span>
<a href="#l22.1094"></a><span id="l22.1094" class="difflineplus">+            }</span>
<a href="#l22.1095"></a><span id="l22.1095" class="difflineplus">+            state-&gt;extra = (unsigned)(here.op) &amp; 15;</span>
<a href="#l22.1096"></a><span id="l22.1096" class="difflineplus">+            state-&gt;mode = LENEXT;</span>
<a href="#l22.1097"></a><span id="l22.1097" class="difflineplus">+        case LENEXT:</span>
<a href="#l22.1098"></a><span id="l22.1098" class="difflineplus">+            if (state-&gt;extra) {</span>
<a href="#l22.1099"></a><span id="l22.1099" class="difflineplus">+                NEEDBITS(state-&gt;extra);</span>
<a href="#l22.1100"></a><span id="l22.1100" class="difflineplus">+                state-&gt;length += BITS(state-&gt;extra);</span>
<a href="#l22.1101"></a><span id="l22.1101" class="difflineplus">+                DROPBITS(state-&gt;extra);</span>
<a href="#l22.1102"></a><span id="l22.1102" class="difflineplus">+                state-&gt;back += state-&gt;extra;</span>
<a href="#l22.1103"></a><span id="l22.1103" class="difflineplus">+            }</span>
<a href="#l22.1104"></a><span id="l22.1104" class="difflineplus">+            Tracevv((stderr, &quot;inflate:         length %u\n&quot;, state-&gt;length));</span>
<a href="#l22.1105"></a><span id="l22.1105" class="difflineplus">+            state-&gt;was = state-&gt;length;</span>
<a href="#l22.1106"></a><span id="l22.1106" class="difflineplus">+            state-&gt;mode = DIST;</span>
<a href="#l22.1107"></a><span id="l22.1107" class="difflineplus">+        case DIST:</span>
<a href="#l22.1108"></a><span id="l22.1108" class="difflineplus">+            for (;;) {</span>
<a href="#l22.1109"></a><span id="l22.1109" class="difflineplus">+                here = state-&gt;distcode[BITS(state-&gt;distbits)];</span>
<a href="#l22.1110"></a><span id="l22.1110" class="difflineplus">+                if ((unsigned)(here.bits) &lt;= bits) break;</span>
<a href="#l22.1111"></a><span id="l22.1111" class="difflineplus">+                PULLBYTE();</span>
<a href="#l22.1112"></a><span id="l22.1112" class="difflineplus">+            }</span>
<a href="#l22.1113"></a><span id="l22.1113" class="difflineplus">+            if ((here.op &amp; 0xf0) == 0) {</span>
<a href="#l22.1114"></a><span id="l22.1114" class="difflineplus">+                last = here;</span>
<a href="#l22.1115"></a><span id="l22.1115" class="difflineplus">+                for (;;) {</span>
<a href="#l22.1116"></a><span id="l22.1116" class="difflineplus">+                    here = state-&gt;distcode[last.val +</span>
<a href="#l22.1117"></a><span id="l22.1117" class="difflineplus">+                            (BITS(last.bits + last.op) &gt;&gt; last.bits)];</span>
<a href="#l22.1118"></a><span id="l22.1118" class="difflineplus">+                    if ((unsigned)(last.bits + here.bits) &lt;= bits) break;</span>
<a href="#l22.1119"></a><span id="l22.1119" class="difflineplus">+                    PULLBYTE();</span>
<a href="#l22.1120"></a><span id="l22.1120" class="difflineplus">+                }</span>
<a href="#l22.1121"></a><span id="l22.1121" class="difflineplus">+                DROPBITS(last.bits);</span>
<a href="#l22.1122"></a><span id="l22.1122" class="difflineplus">+                state-&gt;back += last.bits;</span>
<a href="#l22.1123"></a><span id="l22.1123" class="difflineplus">+            }</span>
<a href="#l22.1124"></a><span id="l22.1124" class="difflineplus">+            DROPBITS(here.bits);</span>
<a href="#l22.1125"></a><span id="l22.1125" class="difflineplus">+            state-&gt;back += here.bits;</span>
<a href="#l22.1126"></a><span id="l22.1126" class="difflineplus">+            if (here.op &amp; 64) {</span>
<a href="#l22.1127"></a><span id="l22.1127" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid distance code&quot;;</span>
<a href="#l22.1128"></a><span id="l22.1128" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.1129"></a><span id="l22.1129" class="difflineplus">+                break;</span>
<a href="#l22.1130"></a><span id="l22.1130" class="difflineplus">+            }</span>
<a href="#l22.1131"></a><span id="l22.1131" class="difflineplus">+            state-&gt;offset = (unsigned)here.val;</span>
<a href="#l22.1132"></a><span id="l22.1132" class="difflineplus">+            state-&gt;extra = (unsigned)(here.op) &amp; 15;</span>
<a href="#l22.1133"></a><span id="l22.1133" class="difflineplus">+            state-&gt;mode = DISTEXT;</span>
<a href="#l22.1134"></a><span id="l22.1134" class="difflineplus">+        case DISTEXT:</span>
<a href="#l22.1135"></a><span id="l22.1135" class="difflineplus">+            if (state-&gt;extra) {</span>
<a href="#l22.1136"></a><span id="l22.1136" class="difflineplus">+                NEEDBITS(state-&gt;extra);</span>
<a href="#l22.1137"></a><span id="l22.1137" class="difflineplus">+                state-&gt;offset += BITS(state-&gt;extra);</span>
<a href="#l22.1138"></a><span id="l22.1138" class="difflineplus">+                DROPBITS(state-&gt;extra);</span>
<a href="#l22.1139"></a><span id="l22.1139" class="difflineplus">+                state-&gt;back += state-&gt;extra;</span>
<a href="#l22.1140"></a><span id="l22.1140" class="difflineplus">+            }</span>
<a href="#l22.1141"></a><span id="l22.1141" class="difflineplus">+#ifdef INFLATE_STRICT</span>
<a href="#l22.1142"></a><span id="l22.1142" class="difflineplus">+            if (state-&gt;offset &gt; state-&gt;dmax) {</span>
<a href="#l22.1143"></a><span id="l22.1143" class="difflineplus">+                strm-&gt;msg = (char *)&quot;invalid distance too far back&quot;;</span>
<a href="#l22.1144"></a><span id="l22.1144" class="difflineplus">+                state-&gt;mode = BAD;</span>
<a href="#l22.1145"></a><span id="l22.1145" class="difflineplus">+                break;</span>
<a href="#l22.1146"></a><span id="l22.1146" class="difflineplus">+            }</span>
<a href="#l22.1147"></a><span id="l22.1147" class="difflineplus">+#endif</span>
<a href="#l22.1148"></a><span id="l22.1148" class="difflineplus">+            Tracevv((stderr, &quot;inflate:         distance %u\n&quot;, state-&gt;offset));</span>
<a href="#l22.1149"></a><span id="l22.1149" class="difflineplus">+            state-&gt;mode = MATCH;</span>
<a href="#l22.1150"></a><span id="l22.1150" class="difflineplus">+        case MATCH:</span>
<a href="#l22.1151"></a><span id="l22.1151" class="difflineplus">+            if (left == 0) goto inf_leave;</span>
<a href="#l22.1152"></a><span id="l22.1152" class="difflineplus">+            copy = out - left;</span>
<a href="#l22.1153"></a><span id="l22.1153" class="difflineplus">+            if (state-&gt;offset &gt; copy) {         /* copy from window */</span>
<a href="#l22.1154"></a><span id="l22.1154" class="difflineplus">+                copy = state-&gt;offset - copy;</span>
<a href="#l22.1155"></a><span id="l22.1155" class="difflineplus">+                if (copy &gt; state-&gt;whave) {</span>
<a href="#l22.1156"></a><span id="l22.1156" class="difflineplus">+                    if (state-&gt;sane) {</span>
<a href="#l22.1157"></a><span id="l22.1157" class="difflineplus">+                        strm-&gt;msg = (char *)&quot;invalid distance too far back&quot;;</span>
<a href="#l22.1158"></a><span id="l22.1158" class="difflineplus">+                        state-&gt;mode = BAD;</span>
<a href="#l22.1159"></a><span id="l22.1159" class="difflineplus">+                        break;</span>
<a href="#l22.1160"></a><span id="l22.1160" class="difflineplus">+                    }</span>
<a href="#l22.1161"></a><span id="l22.1161" class="difflineplus">+#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR</span>
<a href="#l22.1162"></a><span id="l22.1162" class="difflineplus">+                    Trace((stderr, &quot;inflate.c too far\n&quot;));</span>
<a href="#l22.1163"></a><span id="l22.1163" class="difflineplus">+                    copy -= state-&gt;whave;</span>
<a href="#l22.1164"></a><span id="l22.1164" class="difflineplus">+                    if (copy &gt; state-&gt;length) copy = state-&gt;length;</span>
<a href="#l22.1165"></a><span id="l22.1165" class="difflineplus">+                    if (copy &gt; left) copy = left;</span>
<a href="#l22.1166"></a><span id="l22.1166" class="difflineplus">+                    left -= copy;</span>
<a href="#l22.1167"></a><span id="l22.1167" class="difflineplus">+                    state-&gt;length -= copy;</span>
<a href="#l22.1168"></a><span id="l22.1168" class="difflineplus">+                    do {</span>
<a href="#l22.1169"></a><span id="l22.1169" class="difflineplus">+                        *put++ = 0;</span>
<a href="#l22.1170"></a><span id="l22.1170" class="difflineplus">+                    } while (--copy);</span>
<a href="#l22.1171"></a><span id="l22.1171" class="difflineplus">+                    if (state-&gt;length == 0) state-&gt;mode = LEN;</span>
<a href="#l22.1172"></a><span id="l22.1172" class="difflineplus">+                    break;</span>
<a href="#l22.1173"></a><span id="l22.1173" class="difflineplus">+#endif</span>
<a href="#l22.1174"></a><span id="l22.1174" class="difflineplus">+                }</span>
<a href="#l22.1175"></a><span id="l22.1175" class="difflineplus">+                if (copy &gt; state-&gt;wnext) {</span>
<a href="#l22.1176"></a><span id="l22.1176" class="difflineplus">+                    copy -= state-&gt;wnext;</span>
<a href="#l22.1177"></a><span id="l22.1177" class="difflineplus">+                    from = state-&gt;window + (state-&gt;wsize - copy);</span>
<a href="#l22.1178"></a><span id="l22.1178" class="difflineplus">+                }</span>
<a href="#l22.1179"></a><span id="l22.1179" class="difflineplus">+                else</span>
<a href="#l22.1180"></a><span id="l22.1180" class="difflineplus">+                    from = state-&gt;window + (state-&gt;wnext - copy);</span>
<a href="#l22.1181"></a><span id="l22.1181" class="difflineplus">+                if (copy &gt; state-&gt;length) copy = state-&gt;length;</span>
<a href="#l22.1182"></a><span id="l22.1182" class="difflineplus">+            }</span>
<a href="#l22.1183"></a><span id="l22.1183" class="difflineplus">+            else {                              /* copy from output */</span>
<a href="#l22.1184"></a><span id="l22.1184" class="difflineplus">+                from = put - state-&gt;offset;</span>
<a href="#l22.1185"></a><span id="l22.1185" class="difflineplus">+                copy = state-&gt;length;</span>
<a href="#l22.1186"></a><span id="l22.1186" class="difflineplus">+            }</span>
<a href="#l22.1187"></a><span id="l22.1187" class="difflineplus">+            if (copy &gt; left) copy = left;</span>
<a href="#l22.1188"></a><span id="l22.1188" class="difflineplus">+            left -= copy;</span>
<a href="#l22.1189"></a><span id="l22.1189" class="difflineplus">+            state-&gt;length -= copy;</span>
<a href="#l22.1190"></a><span id="l22.1190" class="difflineplus">+            do {</span>
<a href="#l22.1191"></a><span id="l22.1191" class="difflineplus">+                *put++ = *from++;</span>
<a href="#l22.1192"></a><span id="l22.1192" class="difflineplus">+            } while (--copy);</span>
<a href="#l22.1193"></a><span id="l22.1193" class="difflineplus">+            if (state-&gt;length == 0) state-&gt;mode = LEN;</span>
<a href="#l22.1194"></a><span id="l22.1194" class="difflineplus">+            break;</span>
<a href="#l22.1195"></a><span id="l22.1195" class="difflineplus">+        case LIT:</span>
<a href="#l22.1196"></a><span id="l22.1196" class="difflineplus">+            if (left == 0) goto inf_leave;</span>
<a href="#l22.1197"></a><span id="l22.1197" class="difflineplus">+            *put++ = (unsigned char)(state-&gt;length);</span>
<a href="#l22.1198"></a><span id="l22.1198" class="difflineplus">+            left--;</span>
<a href="#l22.1199"></a><span id="l22.1199" class="difflineplus">+            state-&gt;mode = LEN;</span>
<a href="#l22.1200"></a><span id="l22.1200" class="difflineplus">+            break;</span>
<a href="#l22.1201"></a><span id="l22.1201" class="difflineplus">+        case CHECK:</span>
<a href="#l22.1202"></a><span id="l22.1202" class="difflineplus">+            if (state-&gt;wrap) {</span>
<a href="#l22.1203"></a><span id="l22.1203" class="difflineplus">+                NEEDBITS(32);</span>
<a href="#l22.1204"></a><span id="l22.1204" class="difflineplus">+                out -= left;</span>
<a href="#l22.1205"></a><span id="l22.1205" class="difflineplus">+                strm-&gt;total_out += out;</span>
<a href="#l22.1206"></a><span id="l22.1206" class="difflineplus">+                state-&gt;total += out;</span>
<a href="#l22.1207"></a><span id="l22.1207" class="difflineplus">+                if ((state-&gt;wrap &amp; 4) &amp;&amp; out)</span>
<a href="#l22.1208"></a><span id="l22.1208" class="difflineplus">+                    strm-&gt;adler = state-&gt;check =</span>
<a href="#l22.1209"></a><span id="l22.1209" class="difflineplus">+                        UPDATE(state-&gt;check, put - out, out);</span>
<a href="#l22.1210"></a><span id="l22.1210" class="difflineplus">+                out = left;</span>
<a href="#l22.1211"></a><span id="l22.1211" class="difflineplus">+                if ((state-&gt;wrap &amp; 4) &amp;&amp; (</span>
<a href="#l22.1212"></a><span id="l22.1212" class="difflineplus">+#ifdef GUNZIP</span>
<a href="#l22.1213"></a><span id="l22.1213" class="difflineplus">+                     state-&gt;flags ? hold :</span>
<a href="#l22.1214"></a><span id="l22.1214" class="difflineplus">+#endif</span>
<a href="#l22.1215"></a><span id="l22.1215" class="difflineplus">+                     ZSWAP32(hold)) != state-&gt;check) {</span>
<a href="#l22.1216"></a><span id="l22.1216" class="difflineplus">+                    strm-&gt;msg = (char *)&quot;incorrect data check&quot;;</span>
<a href="#l22.1217"></a><span id="l22.1217" class="difflineplus">+                    state-&gt;mode = BAD;</span>
<a href="#l22.1218"></a><span id="l22.1218" class="difflineplus">+                    break;</span>
<a href="#l22.1219"></a><span id="l22.1219" class="difflineplus">+                }</span>
<a href="#l22.1220"></a><span id="l22.1220" class="difflineplus">+                INITBITS();</span>
<a href="#l22.1221"></a><span id="l22.1221" class="difflineplus">+                Tracev((stderr, &quot;inflate:   check matches trailer\n&quot;));</span>
<a href="#l22.1222"></a><span id="l22.1222" class="difflineplus">+            }</span>
<a href="#l22.1223"></a><span id="l22.1223" class="difflineplus">+#ifdef GUNZIP</span>
<a href="#l22.1224"></a><span id="l22.1224" class="difflineplus">+            state-&gt;mode = LENGTH;</span>
<a href="#l22.1225"></a><span id="l22.1225" class="difflineplus">+        case LENGTH:</span>
<a href="#l22.1226"></a><span id="l22.1226" class="difflineplus">+            if (state-&gt;wrap &amp;&amp; state-&gt;flags) {</span>
<a href="#l22.1227"></a><span id="l22.1227" class="difflineplus">+                NEEDBITS(32);</span>
<a href="#l22.1228"></a><span id="l22.1228" class="difflineplus">+                if (hold != (state-&gt;total &amp; 0xffffffffUL)) {</span>
<a href="#l22.1229"></a><span id="l22.1229" class="difflineplus">+                    strm-&gt;msg = (char *)&quot;incorrect length check&quot;;</span>
<a href="#l22.1230"></a><span id="l22.1230" class="difflineplus">+                    state-&gt;mode = BAD;</span>
<a href="#l22.1231"></a><span id="l22.1231" class="difflineplus">+                    break;</span>
<a href="#l22.1232"></a><span id="l22.1232" class="difflineplus">+                }</span>
<a href="#l22.1233"></a><span id="l22.1233" class="difflineplus">+                INITBITS();</span>
<a href="#l22.1234"></a><span id="l22.1234" class="difflineplus">+                Tracev((stderr, &quot;inflate:   length matches trailer\n&quot;));</span>
<a href="#l22.1235"></a><span id="l22.1235" class="difflineplus">+            }</span>
<a href="#l22.1236"></a><span id="l22.1236" class="difflineplus">+#endif</span>
<a href="#l22.1237"></a><span id="l22.1237" class="difflineplus">+            state-&gt;mode = DONE;</span>
<a href="#l22.1238"></a><span id="l22.1238" class="difflineplus">+        case DONE:</span>
<a href="#l22.1239"></a><span id="l22.1239" class="difflineplus">+            ret = Z_STREAM_END;</span>
<a href="#l22.1240"></a><span id="l22.1240" class="difflineplus">+            goto inf_leave;</span>
<a href="#l22.1241"></a><span id="l22.1241" class="difflineplus">+        case BAD:</span>
<a href="#l22.1242"></a><span id="l22.1242" class="difflineplus">+            ret = Z_DATA_ERROR;</span>
<a href="#l22.1243"></a><span id="l22.1243" class="difflineplus">+            goto inf_leave;</span>
<a href="#l22.1244"></a><span id="l22.1244" class="difflineplus">+        case MEM:</span>
<a href="#l22.1245"></a><span id="l22.1245" class="difflineplus">+            return Z_MEM_ERROR;</span>
<a href="#l22.1246"></a><span id="l22.1246" class="difflineplus">+        case SYNC:</span>
<a href="#l22.1247"></a><span id="l22.1247" class="difflineplus">+        default:</span>
<a href="#l22.1248"></a><span id="l22.1248" class="difflineplus">+            return Z_STREAM_ERROR;</span>
<a href="#l22.1249"></a><span id="l22.1249" class="difflineplus">+        }</span>
<a href="#l22.1250"></a><span id="l22.1250" class="difflineplus">+</span>
<a href="#l22.1251"></a><span id="l22.1251" class="difflineplus">+    /*</span>
<a href="#l22.1252"></a><span id="l22.1252" class="difflineplus">+       Return from inflate(), updating the total counts and the check value.</span>
<a href="#l22.1253"></a><span id="l22.1253" class="difflineplus">+       If there was no progress during the inflate() call, return a buffer</span>
<a href="#l22.1254"></a><span id="l22.1254" class="difflineplus">+       error.  Call updatewindow() to create and/or update the window state.</span>
<a href="#l22.1255"></a><span id="l22.1255" class="difflineplus">+       Note: a memory error from inflate() is non-recoverable.</span>
<a href="#l22.1256"></a><span id="l22.1256" class="difflineplus">+     */</span>
<a href="#l22.1257"></a><span id="l22.1257" class="difflineplus">+  inf_leave:</span>
<a href="#l22.1258"></a><span id="l22.1258" class="difflineplus">+    RESTORE();</span>
<a href="#l22.1259"></a><span id="l22.1259" class="difflineplus">+    if (state-&gt;wsize || (out != strm-&gt;avail_out &amp;&amp; state-&gt;mode &lt; BAD &amp;&amp;</span>
<a href="#l22.1260"></a><span id="l22.1260" class="difflineplus">+            (state-&gt;mode &lt; CHECK || flush != Z_FINISH)))</span>
<a href="#l22.1261"></a><span id="l22.1261" class="difflineplus">+        if (updatewindow(strm, strm-&gt;next_out, out - strm-&gt;avail_out)) {</span>
<a href="#l22.1262"></a><span id="l22.1262" class="difflineplus">+            state-&gt;mode = MEM;</span>
<a href="#l22.1263"></a><span id="l22.1263" class="difflineplus">+            return Z_MEM_ERROR;</span>
<a href="#l22.1264"></a><span id="l22.1264" class="difflineplus">+        }</span>
<a href="#l22.1265"></a><span id="l22.1265" class="difflineplus">+    in -= strm-&gt;avail_in;</span>
<a href="#l22.1266"></a><span id="l22.1266" class="difflineplus">+    out -= strm-&gt;avail_out;</span>
<a href="#l22.1267"></a><span id="l22.1267" class="difflineplus">+    strm-&gt;total_in += in;</span>
<a href="#l22.1268"></a><span id="l22.1268" class="difflineplus">+    strm-&gt;total_out += out;</span>
<a href="#l22.1269"></a><span id="l22.1269" class="difflineplus">+    state-&gt;total += out;</span>
<a href="#l22.1270"></a><span id="l22.1270" class="difflineplus">+    if ((state-&gt;wrap &amp; 4) &amp;&amp; out)</span>
<a href="#l22.1271"></a><span id="l22.1271" class="difflineplus">+        strm-&gt;adler = state-&gt;check =</span>
<a href="#l22.1272"></a><span id="l22.1272" class="difflineplus">+            UPDATE(state-&gt;check, strm-&gt;next_out - out, out);</span>
<a href="#l22.1273"></a><span id="l22.1273" class="difflineplus">+    strm-&gt;data_type = (int)state-&gt;bits + (state-&gt;last ? 64 : 0) +</span>
<a href="#l22.1274"></a><span id="l22.1274" class="difflineplus">+                      (state-&gt;mode == TYPE ? 128 : 0) +</span>
<a href="#l22.1275"></a><span id="l22.1275" class="difflineplus">+                      (state-&gt;mode == LEN_ || state-&gt;mode == COPY_ ? 256 : 0);</span>
<a href="#l22.1276"></a><span id="l22.1276" class="difflineplus">+    if (((in == 0 &amp;&amp; out == 0) || flush == Z_FINISH) &amp;&amp; ret == Z_OK)</span>
<a href="#l22.1277"></a><span id="l22.1277" class="difflineplus">+        ret = Z_BUF_ERROR;</span>
<a href="#l22.1278"></a><span id="l22.1278" class="difflineplus">+    return ret;</span>
<a href="#l22.1279"></a><span id="l22.1279" class="difflineplus">+}</span>
<a href="#l22.1280"></a><span id="l22.1280" class="difflineplus">+</span>
<a href="#l22.1281"></a><span id="l22.1281" class="difflineplus">+int ZEXPORT inflateEnd(strm)</span>
<a href="#l22.1282"></a><span id="l22.1282" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.1283"></a><span id="l22.1283" class="difflineplus">+{</span>
<a href="#l22.1284"></a><span id="l22.1284" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.1285"></a><span id="l22.1285" class="difflineplus">+    if (inflateStateCheck(strm))</span>
<a href="#l22.1286"></a><span id="l22.1286" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l22.1287"></a><span id="l22.1287" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.1288"></a><span id="l22.1288" class="difflineplus">+    if (state-&gt;window != Z_NULL) ZFREE(strm, state-&gt;window);</span>
<a href="#l22.1289"></a><span id="l22.1289" class="difflineplus">+    ZFREE(strm, strm-&gt;state);</span>
<a href="#l22.1290"></a><span id="l22.1290" class="difflineplus">+    strm-&gt;state = Z_NULL;</span>
<a href="#l22.1291"></a><span id="l22.1291" class="difflineplus">+    Tracev((stderr, &quot;inflate: end\n&quot;));</span>
<a href="#l22.1292"></a><span id="l22.1292" class="difflineplus">+    return Z_OK;</span>
<a href="#l22.1293"></a><span id="l22.1293" class="difflineplus">+}</span>
<a href="#l22.1294"></a><span id="l22.1294" class="difflineplus">+</span>
<a href="#l22.1295"></a><span id="l22.1295" class="difflineplus">+int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)</span>
<a href="#l22.1296"></a><span id="l22.1296" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.1297"></a><span id="l22.1297" class="difflineplus">+Bytef *dictionary;</span>
<a href="#l22.1298"></a><span id="l22.1298" class="difflineplus">+uInt *dictLength;</span>
<a href="#l22.1299"></a><span id="l22.1299" class="difflineplus">+{</span>
<a href="#l22.1300"></a><span id="l22.1300" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.1301"></a><span id="l22.1301" class="difflineplus">+</span>
<a href="#l22.1302"></a><span id="l22.1302" class="difflineplus">+    /* check state */</span>
<a href="#l22.1303"></a><span id="l22.1303" class="difflineplus">+    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l22.1304"></a><span id="l22.1304" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.1305"></a><span id="l22.1305" class="difflineplus">+</span>
<a href="#l22.1306"></a><span id="l22.1306" class="difflineplus">+    /* copy dictionary */</span>
<a href="#l22.1307"></a><span id="l22.1307" class="difflineplus">+    if (state-&gt;whave &amp;&amp; dictionary != Z_NULL) {</span>
<a href="#l22.1308"></a><span id="l22.1308" class="difflineplus">+        zmemcpy(dictionary, state-&gt;window + state-&gt;wnext,</span>
<a href="#l22.1309"></a><span id="l22.1309" class="difflineplus">+                state-&gt;whave - state-&gt;wnext);</span>
<a href="#l22.1310"></a><span id="l22.1310" class="difflineplus">+        zmemcpy(dictionary + state-&gt;whave - state-&gt;wnext,</span>
<a href="#l22.1311"></a><span id="l22.1311" class="difflineplus">+                state-&gt;window, state-&gt;wnext);</span>
<a href="#l22.1312"></a><span id="l22.1312" class="difflineplus">+    }</span>
<a href="#l22.1313"></a><span id="l22.1313" class="difflineplus">+    if (dictLength != Z_NULL)</span>
<a href="#l22.1314"></a><span id="l22.1314" class="difflineplus">+        *dictLength = state-&gt;whave;</span>
<a href="#l22.1315"></a><span id="l22.1315" class="difflineplus">+    return Z_OK;</span>
<a href="#l22.1316"></a><span id="l22.1316" class="difflineplus">+}</span>
<a href="#l22.1317"></a><span id="l22.1317" class="difflineplus">+</span>
<a href="#l22.1318"></a><span id="l22.1318" class="difflineplus">+int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)</span>
<a href="#l22.1319"></a><span id="l22.1319" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.1320"></a><span id="l22.1320" class="difflineplus">+const Bytef *dictionary;</span>
<a href="#l22.1321"></a><span id="l22.1321" class="difflineplus">+uInt dictLength;</span>
<a href="#l22.1322"></a><span id="l22.1322" class="difflineplus">+{</span>
<a href="#l22.1323"></a><span id="l22.1323" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.1324"></a><span id="l22.1324" class="difflineplus">+    unsigned long dictid;</span>
<a href="#l22.1325"></a><span id="l22.1325" class="difflineplus">+    int ret;</span>
<a href="#l22.1326"></a><span id="l22.1326" class="difflineplus">+</span>
<a href="#l22.1327"></a><span id="l22.1327" class="difflineplus">+    /* check state */</span>
<a href="#l22.1328"></a><span id="l22.1328" class="difflineplus">+    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l22.1329"></a><span id="l22.1329" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.1330"></a><span id="l22.1330" class="difflineplus">+    if (state-&gt;wrap != 0 &amp;&amp; state-&gt;mode != DICT)</span>
<a href="#l22.1331"></a><span id="l22.1331" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l22.1332"></a><span id="l22.1332" class="difflineplus">+</span>
<a href="#l22.1333"></a><span id="l22.1333" class="difflineplus">+    /* check for correct dictionary identifier */</span>
<a href="#l22.1334"></a><span id="l22.1334" class="difflineplus">+    if (state-&gt;mode == DICT) {</span>
<a href="#l22.1335"></a><span id="l22.1335" class="difflineplus">+        dictid = adler32(0L, Z_NULL, 0);</span>
<a href="#l22.1336"></a><span id="l22.1336" class="difflineplus">+        dictid = adler32(dictid, dictionary, dictLength);</span>
<a href="#l22.1337"></a><span id="l22.1337" class="difflineplus">+        if (dictid != state-&gt;check)</span>
<a href="#l22.1338"></a><span id="l22.1338" class="difflineplus">+            return Z_DATA_ERROR;</span>
<a href="#l22.1339"></a><span id="l22.1339" class="difflineplus">+    }</span>
<a href="#l22.1340"></a><span id="l22.1340" class="difflineplus">+</span>
<a href="#l22.1341"></a><span id="l22.1341" class="difflineplus">+    /* copy dictionary to window using updatewindow(), which will amend the</span>
<a href="#l22.1342"></a><span id="l22.1342" class="difflineplus">+       existing dictionary if appropriate */</span>
<a href="#l22.1343"></a><span id="l22.1343" class="difflineplus">+    ret = updatewindow(strm, dictionary + dictLength, dictLength);</span>
<a href="#l22.1344"></a><span id="l22.1344" class="difflineplus">+    if (ret) {</span>
<a href="#l22.1345"></a><span id="l22.1345" class="difflineplus">+        state-&gt;mode = MEM;</span>
<a href="#l22.1346"></a><span id="l22.1346" class="difflineplus">+        return Z_MEM_ERROR;</span>
<a href="#l22.1347"></a><span id="l22.1347" class="difflineplus">+    }</span>
<a href="#l22.1348"></a><span id="l22.1348" class="difflineplus">+    state-&gt;havedict = 1;</span>
<a href="#l22.1349"></a><span id="l22.1349" class="difflineplus">+    Tracev((stderr, &quot;inflate:   dictionary set\n&quot;));</span>
<a href="#l22.1350"></a><span id="l22.1350" class="difflineplus">+    return Z_OK;</span>
<a href="#l22.1351"></a><span id="l22.1351" class="difflineplus">+}</span>
<a href="#l22.1352"></a><span id="l22.1352" class="difflineplus">+</span>
<a href="#l22.1353"></a><span id="l22.1353" class="difflineplus">+int ZEXPORT inflateGetHeader(strm, head)</span>
<a href="#l22.1354"></a><span id="l22.1354" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.1355"></a><span id="l22.1355" class="difflineplus">+gz_headerp head;</span>
<a href="#l22.1356"></a><span id="l22.1356" class="difflineplus">+{</span>
<a href="#l22.1357"></a><span id="l22.1357" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.1358"></a><span id="l22.1358" class="difflineplus">+</span>
<a href="#l22.1359"></a><span id="l22.1359" class="difflineplus">+    /* check state */</span>
<a href="#l22.1360"></a><span id="l22.1360" class="difflineplus">+    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l22.1361"></a><span id="l22.1361" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.1362"></a><span id="l22.1362" class="difflineplus">+    if ((state-&gt;wrap &amp; 2) == 0) return Z_STREAM_ERROR;</span>
<a href="#l22.1363"></a><span id="l22.1363" class="difflineplus">+</span>
<a href="#l22.1364"></a><span id="l22.1364" class="difflineplus">+    /* save header structure */</span>
<a href="#l22.1365"></a><span id="l22.1365" class="difflineplus">+    state-&gt;head = head;</span>
<a href="#l22.1366"></a><span id="l22.1366" class="difflineplus">+    head-&gt;done = 0;</span>
<a href="#l22.1367"></a><span id="l22.1367" class="difflineplus">+    return Z_OK;</span>
<a href="#l22.1368"></a><span id="l22.1368" class="difflineplus">+}</span>
<a href="#l22.1369"></a><span id="l22.1369" class="difflineplus">+</span>
<a href="#l22.1370"></a><span id="l22.1370" class="difflineplus">+/*</span>
<a href="#l22.1371"></a><span id="l22.1371" class="difflineplus">+   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found</span>
<a href="#l22.1372"></a><span id="l22.1372" class="difflineplus">+   or when out of input.  When called, *have is the number of pattern bytes</span>
<a href="#l22.1373"></a><span id="l22.1373" class="difflineplus">+   found in order so far, in 0..3.  On return *have is updated to the new</span>
<a href="#l22.1374"></a><span id="l22.1374" class="difflineplus">+   state.  If on return *have equals four, then the pattern was found and the</span>
<a href="#l22.1375"></a><span id="l22.1375" class="difflineplus">+   return value is how many bytes were read including the last byte of the</span>
<a href="#l22.1376"></a><span id="l22.1376" class="difflineplus">+   pattern.  If *have is less than four, then the pattern has not been found</span>
<a href="#l22.1377"></a><span id="l22.1377" class="difflineplus">+   yet and the return value is len.  In the latter case, syncsearch() can be</span>
<a href="#l22.1378"></a><span id="l22.1378" class="difflineplus">+   called again with more data and the *have state.  *have is initialized to</span>
<a href="#l22.1379"></a><span id="l22.1379" class="difflineplus">+   zero for the first call.</span>
<a href="#l22.1380"></a><span id="l22.1380" class="difflineplus">+ */</span>
<a href="#l22.1381"></a><span id="l22.1381" class="difflineplus">+local unsigned syncsearch(have, buf, len)</span>
<a href="#l22.1382"></a><span id="l22.1382" class="difflineplus">+unsigned FAR *have;</span>
<a href="#l22.1383"></a><span id="l22.1383" class="difflineplus">+const unsigned char FAR *buf;</span>
<a href="#l22.1384"></a><span id="l22.1384" class="difflineplus">+unsigned len;</span>
<a href="#l22.1385"></a><span id="l22.1385" class="difflineplus">+{</span>
<a href="#l22.1386"></a><span id="l22.1386" class="difflineplus">+    unsigned got;</span>
<a href="#l22.1387"></a><span id="l22.1387" class="difflineplus">+    unsigned next;</span>
<a href="#l22.1388"></a><span id="l22.1388" class="difflineplus">+</span>
<a href="#l22.1389"></a><span id="l22.1389" class="difflineplus">+    got = *have;</span>
<a href="#l22.1390"></a><span id="l22.1390" class="difflineplus">+    next = 0;</span>
<a href="#l22.1391"></a><span id="l22.1391" class="difflineplus">+    while (next &lt; len &amp;&amp; got &lt; 4) {</span>
<a href="#l22.1392"></a><span id="l22.1392" class="difflineplus">+        if ((int)(buf[next]) == (got &lt; 2 ? 0 : 0xff))</span>
<a href="#l22.1393"></a><span id="l22.1393" class="difflineplus">+            got++;</span>
<a href="#l22.1394"></a><span id="l22.1394" class="difflineplus">+        else if (buf[next])</span>
<a href="#l22.1395"></a><span id="l22.1395" class="difflineplus">+            got = 0;</span>
<a href="#l22.1396"></a><span id="l22.1396" class="difflineplus">+        else</span>
<a href="#l22.1397"></a><span id="l22.1397" class="difflineplus">+            got = 4 - got;</span>
<a href="#l22.1398"></a><span id="l22.1398" class="difflineplus">+        next++;</span>
<a href="#l22.1399"></a><span id="l22.1399" class="difflineplus">+    }</span>
<a href="#l22.1400"></a><span id="l22.1400" class="difflineplus">+    *have = got;</span>
<a href="#l22.1401"></a><span id="l22.1401" class="difflineplus">+    return next;</span>
<a href="#l22.1402"></a><span id="l22.1402" class="difflineplus">+}</span>
<a href="#l22.1403"></a><span id="l22.1403" class="difflineplus">+</span>
<a href="#l22.1404"></a><span id="l22.1404" class="difflineplus">+int ZEXPORT inflateSync(strm)</span>
<a href="#l22.1405"></a><span id="l22.1405" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.1406"></a><span id="l22.1406" class="difflineplus">+{</span>
<a href="#l22.1407"></a><span id="l22.1407" class="difflineplus">+    unsigned len;               /* number of bytes to look at or looked at */</span>
<a href="#l22.1408"></a><span id="l22.1408" class="difflineplus">+    unsigned long in, out;      /* temporary to save total_in and total_out */</span>
<a href="#l22.1409"></a><span id="l22.1409" class="difflineplus">+    unsigned char buf[4];       /* to restore bit buffer to byte string */</span>
<a href="#l22.1410"></a><span id="l22.1410" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.1411"></a><span id="l22.1411" class="difflineplus">+</span>
<a href="#l22.1412"></a><span id="l22.1412" class="difflineplus">+    /* check parameters */</span>
<a href="#l22.1413"></a><span id="l22.1413" class="difflineplus">+    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l22.1414"></a><span id="l22.1414" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.1415"></a><span id="l22.1415" class="difflineplus">+    if (strm-&gt;avail_in == 0 &amp;&amp; state-&gt;bits &lt; 8) return Z_BUF_ERROR;</span>
<a href="#l22.1416"></a><span id="l22.1416" class="difflineplus">+</span>
<a href="#l22.1417"></a><span id="l22.1417" class="difflineplus">+    /* if first time, start search in bit buffer */</span>
<a href="#l22.1418"></a><span id="l22.1418" class="difflineplus">+    if (state-&gt;mode != SYNC) {</span>
<a href="#l22.1419"></a><span id="l22.1419" class="difflineplus">+        state-&gt;mode = SYNC;</span>
<a href="#l22.1420"></a><span id="l22.1420" class="difflineplus">+        state-&gt;hold &lt;&lt;= state-&gt;bits &amp; 7;</span>
<a href="#l22.1421"></a><span id="l22.1421" class="difflineplus">+        state-&gt;bits -= state-&gt;bits &amp; 7;</span>
<a href="#l22.1422"></a><span id="l22.1422" class="difflineplus">+        len = 0;</span>
<a href="#l22.1423"></a><span id="l22.1423" class="difflineplus">+        while (state-&gt;bits &gt;= 8) {</span>
<a href="#l22.1424"></a><span id="l22.1424" class="difflineplus">+            buf[len++] = (unsigned char)(state-&gt;hold);</span>
<a href="#l22.1425"></a><span id="l22.1425" class="difflineplus">+            state-&gt;hold &gt;&gt;= 8;</span>
<a href="#l22.1426"></a><span id="l22.1426" class="difflineplus">+            state-&gt;bits -= 8;</span>
<a href="#l22.1427"></a><span id="l22.1427" class="difflineplus">+        }</span>
<a href="#l22.1428"></a><span id="l22.1428" class="difflineplus">+        state-&gt;have = 0;</span>
<a href="#l22.1429"></a><span id="l22.1429" class="difflineplus">+        syncsearch(&amp;(state-&gt;have), buf, len);</span>
<a href="#l22.1430"></a><span id="l22.1430" class="difflineplus">+    }</span>
<a href="#l22.1431"></a><span id="l22.1431" class="difflineplus">+</span>
<a href="#l22.1432"></a><span id="l22.1432" class="difflineplus">+    /* search available input */</span>
<a href="#l22.1433"></a><span id="l22.1433" class="difflineplus">+    len = syncsearch(&amp;(state-&gt;have), strm-&gt;next_in, strm-&gt;avail_in);</span>
<a href="#l22.1434"></a><span id="l22.1434" class="difflineplus">+    strm-&gt;avail_in -= len;</span>
<a href="#l22.1435"></a><span id="l22.1435" class="difflineplus">+    strm-&gt;next_in += len;</span>
<a href="#l22.1436"></a><span id="l22.1436" class="difflineplus">+    strm-&gt;total_in += len;</span>
<a href="#l22.1437"></a><span id="l22.1437" class="difflineplus">+</span>
<a href="#l22.1438"></a><span id="l22.1438" class="difflineplus">+    /* return no joy or set up to restart inflate() on a new block */</span>
<a href="#l22.1439"></a><span id="l22.1439" class="difflineplus">+    if (state-&gt;have != 4) return Z_DATA_ERROR;</span>
<a href="#l22.1440"></a><span id="l22.1440" class="difflineplus">+    in = strm-&gt;total_in;  out = strm-&gt;total_out;</span>
<a href="#l22.1441"></a><span id="l22.1441" class="difflineplus">+    inflateReset(strm);</span>
<a href="#l22.1442"></a><span id="l22.1442" class="difflineplus">+    strm-&gt;total_in = in;  strm-&gt;total_out = out;</span>
<a href="#l22.1443"></a><span id="l22.1443" class="difflineplus">+    state-&gt;mode = TYPE;</span>
<a href="#l22.1444"></a><span id="l22.1444" class="difflineplus">+    return Z_OK;</span>
<a href="#l22.1445"></a><span id="l22.1445" class="difflineplus">+}</span>
<a href="#l22.1446"></a><span id="l22.1446" class="difflineplus">+</span>
<a href="#l22.1447"></a><span id="l22.1447" class="difflineplus">+/*</span>
<a href="#l22.1448"></a><span id="l22.1448" class="difflineplus">+   Returns true if inflate is currently at the end of a block generated by</span>
<a href="#l22.1449"></a><span id="l22.1449" class="difflineplus">+   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP</span>
<a href="#l22.1450"></a><span id="l22.1450" class="difflineplus">+   implementation to provide an additional safety check. PPP uses</span>
<a href="#l22.1451"></a><span id="l22.1451" class="difflineplus">+   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored</span>
<a href="#l22.1452"></a><span id="l22.1452" class="difflineplus">+   block. When decompressing, PPP checks that at the end of input packet,</span>
<a href="#l22.1453"></a><span id="l22.1453" class="difflineplus">+   inflate is waiting for these length bytes.</span>
<a href="#l22.1454"></a><span id="l22.1454" class="difflineplus">+ */</span>
<a href="#l22.1455"></a><span id="l22.1455" class="difflineplus">+int ZEXPORT inflateSyncPoint(strm)</span>
<a href="#l22.1456"></a><span id="l22.1456" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.1457"></a><span id="l22.1457" class="difflineplus">+{</span>
<a href="#l22.1458"></a><span id="l22.1458" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.1459"></a><span id="l22.1459" class="difflineplus">+</span>
<a href="#l22.1460"></a><span id="l22.1460" class="difflineplus">+    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l22.1461"></a><span id="l22.1461" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.1462"></a><span id="l22.1462" class="difflineplus">+    return state-&gt;mode == STORED &amp;&amp; state-&gt;bits == 0;</span>
<a href="#l22.1463"></a><span id="l22.1463" class="difflineplus">+}</span>
<a href="#l22.1464"></a><span id="l22.1464" class="difflineplus">+</span>
<a href="#l22.1465"></a><span id="l22.1465" class="difflineplus">+int ZEXPORT inflateCopy(dest, source)</span>
<a href="#l22.1466"></a><span id="l22.1466" class="difflineplus">+z_streamp dest;</span>
<a href="#l22.1467"></a><span id="l22.1467" class="difflineplus">+z_streamp source;</span>
<a href="#l22.1468"></a><span id="l22.1468" class="difflineplus">+{</span>
<a href="#l22.1469"></a><span id="l22.1469" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.1470"></a><span id="l22.1470" class="difflineplus">+    struct inflate_state FAR *copy;</span>
<a href="#l22.1471"></a><span id="l22.1471" class="difflineplus">+    unsigned char FAR *window;</span>
<a href="#l22.1472"></a><span id="l22.1472" class="difflineplus">+    unsigned wsize;</span>
<a href="#l22.1473"></a><span id="l22.1473" class="difflineplus">+</span>
<a href="#l22.1474"></a><span id="l22.1474" class="difflineplus">+    /* check input */</span>
<a href="#l22.1475"></a><span id="l22.1475" class="difflineplus">+    if (inflateStateCheck(source) || dest == Z_NULL)</span>
<a href="#l22.1476"></a><span id="l22.1476" class="difflineplus">+        return Z_STREAM_ERROR;</span>
<a href="#l22.1477"></a><span id="l22.1477" class="difflineplus">+    state = (struct inflate_state FAR *)source-&gt;state;</span>
<a href="#l22.1478"></a><span id="l22.1478" class="difflineplus">+</span>
<a href="#l22.1479"></a><span id="l22.1479" class="difflineplus">+    /* allocate space */</span>
<a href="#l22.1480"></a><span id="l22.1480" class="difflineplus">+    copy = (struct inflate_state FAR *)</span>
<a href="#l22.1481"></a><span id="l22.1481" class="difflineplus">+           ZALLOC(source, 1, sizeof(struct inflate_state));</span>
<a href="#l22.1482"></a><span id="l22.1482" class="difflineplus">+    if (copy == Z_NULL) return Z_MEM_ERROR;</span>
<a href="#l22.1483"></a><span id="l22.1483" class="difflineplus">+    window = Z_NULL;</span>
<a href="#l22.1484"></a><span id="l22.1484" class="difflineplus">+    if (state-&gt;window != Z_NULL) {</span>
<a href="#l22.1485"></a><span id="l22.1485" class="difflineplus">+        window = (unsigned char FAR *)</span>
<a href="#l22.1486"></a><span id="l22.1486" class="difflineplus">+                 ZALLOC(source, 1U &lt;&lt; state-&gt;wbits, sizeof(unsigned char));</span>
<a href="#l22.1487"></a><span id="l22.1487" class="difflineplus">+        if (window == Z_NULL) {</span>
<a href="#l22.1488"></a><span id="l22.1488" class="difflineplus">+            ZFREE(source, copy);</span>
<a href="#l22.1489"></a><span id="l22.1489" class="difflineplus">+            return Z_MEM_ERROR;</span>
<a href="#l22.1490"></a><span id="l22.1490" class="difflineplus">+        }</span>
<a href="#l22.1491"></a><span id="l22.1491" class="difflineplus">+    }</span>
<a href="#l22.1492"></a><span id="l22.1492" class="difflineplus">+</span>
<a href="#l22.1493"></a><span id="l22.1493" class="difflineplus">+    /* copy state */</span>
<a href="#l22.1494"></a><span id="l22.1494" class="difflineplus">+    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));</span>
<a href="#l22.1495"></a><span id="l22.1495" class="difflineplus">+    zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));</span>
<a href="#l22.1496"></a><span id="l22.1496" class="difflineplus">+    copy-&gt;strm = dest;</span>
<a href="#l22.1497"></a><span id="l22.1497" class="difflineplus">+    if (state-&gt;lencode &gt;= state-&gt;codes &amp;&amp;</span>
<a href="#l22.1498"></a><span id="l22.1498" class="difflineplus">+        state-&gt;lencode &lt;= state-&gt;codes + ENOUGH - 1) {</span>
<a href="#l22.1499"></a><span id="l22.1499" class="difflineplus">+        copy-&gt;lencode = copy-&gt;codes + (state-&gt;lencode - state-&gt;codes);</span>
<a href="#l22.1500"></a><span id="l22.1500" class="difflineplus">+        copy-&gt;distcode = copy-&gt;codes + (state-&gt;distcode - state-&gt;codes);</span>
<a href="#l22.1501"></a><span id="l22.1501" class="difflineplus">+    }</span>
<a href="#l22.1502"></a><span id="l22.1502" class="difflineplus">+    copy-&gt;next = copy-&gt;codes + (state-&gt;next - state-&gt;codes);</span>
<a href="#l22.1503"></a><span id="l22.1503" class="difflineplus">+    if (window != Z_NULL) {</span>
<a href="#l22.1504"></a><span id="l22.1504" class="difflineplus">+        wsize = 1U &lt;&lt; state-&gt;wbits;</span>
<a href="#l22.1505"></a><span id="l22.1505" class="difflineplus">+        zmemcpy(window, state-&gt;window, wsize);</span>
<a href="#l22.1506"></a><span id="l22.1506" class="difflineplus">+    }</span>
<a href="#l22.1507"></a><span id="l22.1507" class="difflineplus">+    copy-&gt;window = window;</span>
<a href="#l22.1508"></a><span id="l22.1508" class="difflineplus">+    dest-&gt;state = (struct internal_state FAR *)copy;</span>
<a href="#l22.1509"></a><span id="l22.1509" class="difflineplus">+    return Z_OK;</span>
<a href="#l22.1510"></a><span id="l22.1510" class="difflineplus">+}</span>
<a href="#l22.1511"></a><span id="l22.1511" class="difflineplus">+</span>
<a href="#l22.1512"></a><span id="l22.1512" class="difflineplus">+int ZEXPORT inflateUndermine(strm, subvert)</span>
<a href="#l22.1513"></a><span id="l22.1513" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.1514"></a><span id="l22.1514" class="difflineplus">+int subvert;</span>
<a href="#l22.1515"></a><span id="l22.1515" class="difflineplus">+{</span>
<a href="#l22.1516"></a><span id="l22.1516" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.1517"></a><span id="l22.1517" class="difflineplus">+</span>
<a href="#l22.1518"></a><span id="l22.1518" class="difflineplus">+    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l22.1519"></a><span id="l22.1519" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.1520"></a><span id="l22.1520" class="difflineplus">+#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR</span>
<a href="#l22.1521"></a><span id="l22.1521" class="difflineplus">+    state-&gt;sane = !subvert;</span>
<a href="#l22.1522"></a><span id="l22.1522" class="difflineplus">+    return Z_OK;</span>
<a href="#l22.1523"></a><span id="l22.1523" class="difflineplus">+#else</span>
<a href="#l22.1524"></a><span id="l22.1524" class="difflineplus">+    (void)subvert;</span>
<a href="#l22.1525"></a><span id="l22.1525" class="difflineplus">+    state-&gt;sane = 1;</span>
<a href="#l22.1526"></a><span id="l22.1526" class="difflineplus">+    return Z_DATA_ERROR;</span>
<a href="#l22.1527"></a><span id="l22.1527" class="difflineplus">+#endif</span>
<a href="#l22.1528"></a><span id="l22.1528" class="difflineplus">+}</span>
<a href="#l22.1529"></a><span id="l22.1529" class="difflineplus">+</span>
<a href="#l22.1530"></a><span id="l22.1530" class="difflineplus">+int ZEXPORT inflateValidate(strm, check)</span>
<a href="#l22.1531"></a><span id="l22.1531" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.1532"></a><span id="l22.1532" class="difflineplus">+int check;</span>
<a href="#l22.1533"></a><span id="l22.1533" class="difflineplus">+{</span>
<a href="#l22.1534"></a><span id="l22.1534" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.1535"></a><span id="l22.1535" class="difflineplus">+</span>
<a href="#l22.1536"></a><span id="l22.1536" class="difflineplus">+    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;</span>
<a href="#l22.1537"></a><span id="l22.1537" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.1538"></a><span id="l22.1538" class="difflineplus">+    if (check)</span>
<a href="#l22.1539"></a><span id="l22.1539" class="difflineplus">+        state-&gt;wrap |= 4;</span>
<a href="#l22.1540"></a><span id="l22.1540" class="difflineplus">+    else</span>
<a href="#l22.1541"></a><span id="l22.1541" class="difflineplus">+        state-&gt;wrap &amp;= ~4;</span>
<a href="#l22.1542"></a><span id="l22.1542" class="difflineplus">+    return Z_OK;</span>
<a href="#l22.1543"></a><span id="l22.1543" class="difflineplus">+}</span>
<a href="#l22.1544"></a><span id="l22.1544" class="difflineplus">+</span>
<a href="#l22.1545"></a><span id="l22.1545" class="difflineplus">+long ZEXPORT inflateMark(strm)</span>
<a href="#l22.1546"></a><span id="l22.1546" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.1547"></a><span id="l22.1547" class="difflineplus">+{</span>
<a href="#l22.1548"></a><span id="l22.1548" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.1549"></a><span id="l22.1549" class="difflineplus">+</span>
<a href="#l22.1550"></a><span id="l22.1550" class="difflineplus">+    if (inflateStateCheck(strm))</span>
<a href="#l22.1551"></a><span id="l22.1551" class="difflineplus">+        return -(1L &lt;&lt; 16);</span>
<a href="#l22.1552"></a><span id="l22.1552" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.1553"></a><span id="l22.1553" class="difflineplus">+    return (long)(((unsigned long)((long)state-&gt;back)) &lt;&lt; 16) +</span>
<a href="#l22.1554"></a><span id="l22.1554" class="difflineplus">+        (state-&gt;mode == COPY ? state-&gt;length :</span>
<a href="#l22.1555"></a><span id="l22.1555" class="difflineplus">+            (state-&gt;mode == MATCH ? state-&gt;was - state-&gt;length : 0));</span>
<a href="#l22.1556"></a><span id="l22.1556" class="difflineplus">+}</span>
<a href="#l22.1557"></a><span id="l22.1557" class="difflineplus">+</span>
<a href="#l22.1558"></a><span id="l22.1558" class="difflineplus">+unsigned long ZEXPORT inflateCodesUsed(strm)</span>
<a href="#l22.1559"></a><span id="l22.1559" class="difflineplus">+z_streamp strm;</span>
<a href="#l22.1560"></a><span id="l22.1560" class="difflineplus">+{</span>
<a href="#l22.1561"></a><span id="l22.1561" class="difflineplus">+    struct inflate_state FAR *state;</span>
<a href="#l22.1562"></a><span id="l22.1562" class="difflineplus">+    if (inflateStateCheck(strm)) return (unsigned long)-1;</span>
<a href="#l22.1563"></a><span id="l22.1563" class="difflineplus">+    state = (struct inflate_state FAR *)strm-&gt;state;</span>
<a href="#l22.1564"></a><span id="l22.1564" class="difflineplus">+    return (unsigned long)(state-&gt;next - state-&gt;codes);</span>
<a href="#l22.1565"></a><span id="l22.1565" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1">new file mode 100644</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineminus">--- /dev/null</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineplus">+++ b/third_party/zlib/inflate.h</span>
<a href="#l23.4"></a><span id="l23.4" class="difflineat">@@ -0,0 +1,125 @@</span>
<a href="#l23.5"></a><span id="l23.5" class="difflineplus">+/* inflate.h -- internal inflate state definition</span>
<a href="#l23.6"></a><span id="l23.6" class="difflineplus">+ * Copyright (C) 1995-2016 Mark Adler</span>
<a href="#l23.7"></a><span id="l23.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l23.8"></a><span id="l23.8" class="difflineplus">+ */</span>
<a href="#l23.9"></a><span id="l23.9" class="difflineplus">+</span>
<a href="#l23.10"></a><span id="l23.10" class="difflineplus">+/* WARNING: this file should *not* be used by applications. It is</span>
<a href="#l23.11"></a><span id="l23.11" class="difflineplus">+   part of the implementation of the compression library and is</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineplus">+   subject to change. Applications should only use zlib.h.</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+ */</span>
<a href="#l23.14"></a><span id="l23.14" class="difflineplus">+</span>
<a href="#l23.15"></a><span id="l23.15" class="difflineplus">+/* define NO_GZIP when compiling if you want to disable gzip header and</span>
<a href="#l23.16"></a><span id="l23.16" class="difflineplus">+   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in</span>
<a href="#l23.17"></a><span id="l23.17" class="difflineplus">+   the crc code when it is not needed.  For shared libraries, gzip decoding</span>
<a href="#l23.18"></a><span id="l23.18" class="difflineplus">+   should be left enabled. */</span>
<a href="#l23.19"></a><span id="l23.19" class="difflineplus">+#ifndef NO_GZIP</span>
<a href="#l23.20"></a><span id="l23.20" class="difflineplus">+#  define GUNZIP</span>
<a href="#l23.21"></a><span id="l23.21" class="difflineplus">+#endif</span>
<a href="#l23.22"></a><span id="l23.22" class="difflineplus">+</span>
<a href="#l23.23"></a><span id="l23.23" class="difflineplus">+/* Possible inflate modes between inflate() calls */</span>
<a href="#l23.24"></a><span id="l23.24" class="difflineplus">+typedef enum {</span>
<a href="#l23.25"></a><span id="l23.25" class="difflineplus">+    HEAD = 16180,   /* i: waiting for magic header */</span>
<a href="#l23.26"></a><span id="l23.26" class="difflineplus">+    FLAGS,      /* i: waiting for method and flags (gzip) */</span>
<a href="#l23.27"></a><span id="l23.27" class="difflineplus">+    TIME,       /* i: waiting for modification time (gzip) */</span>
<a href="#l23.28"></a><span id="l23.28" class="difflineplus">+    OS,         /* i: waiting for extra flags and operating system (gzip) */</span>
<a href="#l23.29"></a><span id="l23.29" class="difflineplus">+    EXLEN,      /* i: waiting for extra length (gzip) */</span>
<a href="#l23.30"></a><span id="l23.30" class="difflineplus">+    EXTRA,      /* i: waiting for extra bytes (gzip) */</span>
<a href="#l23.31"></a><span id="l23.31" class="difflineplus">+    NAME,       /* i: waiting for end of file name (gzip) */</span>
<a href="#l23.32"></a><span id="l23.32" class="difflineplus">+    COMMENT,    /* i: waiting for end of comment (gzip) */</span>
<a href="#l23.33"></a><span id="l23.33" class="difflineplus">+    HCRC,       /* i: waiting for header crc (gzip) */</span>
<a href="#l23.34"></a><span id="l23.34" class="difflineplus">+    DICTID,     /* i: waiting for dictionary check value */</span>
<a href="#l23.35"></a><span id="l23.35" class="difflineplus">+    DICT,       /* waiting for inflateSetDictionary() call */</span>
<a href="#l23.36"></a><span id="l23.36" class="difflineplus">+        TYPE,       /* i: waiting for type bits, including last-flag bit */</span>
<a href="#l23.37"></a><span id="l23.37" class="difflineplus">+        TYPEDO,     /* i: same, but skip check to exit inflate on new block */</span>
<a href="#l23.38"></a><span id="l23.38" class="difflineplus">+        STORED,     /* i: waiting for stored size (length and complement) */</span>
<a href="#l23.39"></a><span id="l23.39" class="difflineplus">+        COPY_,      /* i/o: same as COPY below, but only first time in */</span>
<a href="#l23.40"></a><span id="l23.40" class="difflineplus">+        COPY,       /* i/o: waiting for input or output to copy stored block */</span>
<a href="#l23.41"></a><span id="l23.41" class="difflineplus">+        TABLE,      /* i: waiting for dynamic block table lengths */</span>
<a href="#l23.42"></a><span id="l23.42" class="difflineplus">+        LENLENS,    /* i: waiting for code length code lengths */</span>
<a href="#l23.43"></a><span id="l23.43" class="difflineplus">+        CODELENS,   /* i: waiting for length/lit and distance code lengths */</span>
<a href="#l23.44"></a><span id="l23.44" class="difflineplus">+            LEN_,       /* i: same as LEN below, but only first time in */</span>
<a href="#l23.45"></a><span id="l23.45" class="difflineplus">+            LEN,        /* i: waiting for length/lit/eob code */</span>
<a href="#l23.46"></a><span id="l23.46" class="difflineplus">+            LENEXT,     /* i: waiting for length extra bits */</span>
<a href="#l23.47"></a><span id="l23.47" class="difflineplus">+            DIST,       /* i: waiting for distance code */</span>
<a href="#l23.48"></a><span id="l23.48" class="difflineplus">+            DISTEXT,    /* i: waiting for distance extra bits */</span>
<a href="#l23.49"></a><span id="l23.49" class="difflineplus">+            MATCH,      /* o: waiting for output space to copy string */</span>
<a href="#l23.50"></a><span id="l23.50" class="difflineplus">+            LIT,        /* o: waiting for output space to write literal */</span>
<a href="#l23.51"></a><span id="l23.51" class="difflineplus">+    CHECK,      /* i: waiting for 32-bit check value */</span>
<a href="#l23.52"></a><span id="l23.52" class="difflineplus">+    LENGTH,     /* i: waiting for 32-bit length (gzip) */</span>
<a href="#l23.53"></a><span id="l23.53" class="difflineplus">+    DONE,       /* finished check, done -- remain here until reset */</span>
<a href="#l23.54"></a><span id="l23.54" class="difflineplus">+    BAD,        /* got a data error -- remain here until reset */</span>
<a href="#l23.55"></a><span id="l23.55" class="difflineplus">+    MEM,        /* got an inflate() memory error -- remain here until reset */</span>
<a href="#l23.56"></a><span id="l23.56" class="difflineplus">+    SYNC        /* looking for synchronization bytes to restart inflate() */</span>
<a href="#l23.57"></a><span id="l23.57" class="difflineplus">+} inflate_mode;</span>
<a href="#l23.58"></a><span id="l23.58" class="difflineplus">+</span>
<a href="#l23.59"></a><span id="l23.59" class="difflineplus">+/*</span>
<a href="#l23.60"></a><span id="l23.60" class="difflineplus">+    State transitions between above modes -</span>
<a href="#l23.61"></a><span id="l23.61" class="difflineplus">+</span>
<a href="#l23.62"></a><span id="l23.62" class="difflineplus">+    (most modes can go to BAD or MEM on error -- not shown for clarity)</span>
<a href="#l23.63"></a><span id="l23.63" class="difflineplus">+</span>
<a href="#l23.64"></a><span id="l23.64" class="difflineplus">+    Process header:</span>
<a href="#l23.65"></a><span id="l23.65" class="difflineplus">+        HEAD -&gt; (gzip) or (zlib) or (raw)</span>
<a href="#l23.66"></a><span id="l23.66" class="difflineplus">+        (gzip) -&gt; FLAGS -&gt; TIME -&gt; OS -&gt; EXLEN -&gt; EXTRA -&gt; NAME -&gt; COMMENT -&gt;</span>
<a href="#l23.67"></a><span id="l23.67" class="difflineplus">+                  HCRC -&gt; TYPE</span>
<a href="#l23.68"></a><span id="l23.68" class="difflineplus">+        (zlib) -&gt; DICTID or TYPE</span>
<a href="#l23.69"></a><span id="l23.69" class="difflineplus">+        DICTID -&gt; DICT -&gt; TYPE</span>
<a href="#l23.70"></a><span id="l23.70" class="difflineplus">+        (raw) -&gt; TYPEDO</span>
<a href="#l23.71"></a><span id="l23.71" class="difflineplus">+    Read deflate blocks:</span>
<a href="#l23.72"></a><span id="l23.72" class="difflineplus">+            TYPE -&gt; TYPEDO -&gt; STORED or TABLE or LEN_ or CHECK</span>
<a href="#l23.73"></a><span id="l23.73" class="difflineplus">+            STORED -&gt; COPY_ -&gt; COPY -&gt; TYPE</span>
<a href="#l23.74"></a><span id="l23.74" class="difflineplus">+            TABLE -&gt; LENLENS -&gt; CODELENS -&gt; LEN_</span>
<a href="#l23.75"></a><span id="l23.75" class="difflineplus">+            LEN_ -&gt; LEN</span>
<a href="#l23.76"></a><span id="l23.76" class="difflineplus">+    Read deflate codes in fixed or dynamic block:</span>
<a href="#l23.77"></a><span id="l23.77" class="difflineplus">+                LEN -&gt; LENEXT or LIT or TYPE</span>
<a href="#l23.78"></a><span id="l23.78" class="difflineplus">+                LENEXT -&gt; DIST -&gt; DISTEXT -&gt; MATCH -&gt; LEN</span>
<a href="#l23.79"></a><span id="l23.79" class="difflineplus">+                LIT -&gt; LEN</span>
<a href="#l23.80"></a><span id="l23.80" class="difflineplus">+    Process trailer:</span>
<a href="#l23.81"></a><span id="l23.81" class="difflineplus">+        CHECK -&gt; LENGTH -&gt; DONE</span>
<a href="#l23.82"></a><span id="l23.82" class="difflineplus">+ */</span>
<a href="#l23.83"></a><span id="l23.83" class="difflineplus">+</span>
<a href="#l23.84"></a><span id="l23.84" class="difflineplus">+/* State maintained between inflate() calls -- approximately 7K bytes, not</span>
<a href="#l23.85"></a><span id="l23.85" class="difflineplus">+   including the allocated sliding window, which is up to 32K bytes. */</span>
<a href="#l23.86"></a><span id="l23.86" class="difflineplus">+struct inflate_state {</span>
<a href="#l23.87"></a><span id="l23.87" class="difflineplus">+    z_streamp strm;             /* pointer back to this zlib stream */</span>
<a href="#l23.88"></a><span id="l23.88" class="difflineplus">+    inflate_mode mode;          /* current inflate mode */</span>
<a href="#l23.89"></a><span id="l23.89" class="difflineplus">+    int last;                   /* true if processing last block */</span>
<a href="#l23.90"></a><span id="l23.90" class="difflineplus">+    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip,</span>
<a href="#l23.91"></a><span id="l23.91" class="difflineplus">+                                   bit 2 true to validate check value */</span>
<a href="#l23.92"></a><span id="l23.92" class="difflineplus">+    int havedict;               /* true if dictionary provided */</span>
<a href="#l23.93"></a><span id="l23.93" class="difflineplus">+    int flags;                  /* gzip header method and flags (0 if zlib) */</span>
<a href="#l23.94"></a><span id="l23.94" class="difflineplus">+    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */</span>
<a href="#l23.95"></a><span id="l23.95" class="difflineplus">+    unsigned long check;        /* protected copy of check value */</span>
<a href="#l23.96"></a><span id="l23.96" class="difflineplus">+    unsigned long total;        /* protected copy of output count */</span>
<a href="#l23.97"></a><span id="l23.97" class="difflineplus">+    gz_headerp head;            /* where to save gzip header information */</span>
<a href="#l23.98"></a><span id="l23.98" class="difflineplus">+        /* sliding window */</span>
<a href="#l23.99"></a><span id="l23.99" class="difflineplus">+    unsigned wbits;             /* log base 2 of requested window size */</span>
<a href="#l23.100"></a><span id="l23.100" class="difflineplus">+    unsigned wsize;             /* window size or zero if not using window */</span>
<a href="#l23.101"></a><span id="l23.101" class="difflineplus">+    unsigned whave;             /* valid bytes in the window */</span>
<a href="#l23.102"></a><span id="l23.102" class="difflineplus">+    unsigned wnext;             /* window write index */</span>
<a href="#l23.103"></a><span id="l23.103" class="difflineplus">+    unsigned char FAR *window;  /* allocated sliding window, if needed */</span>
<a href="#l23.104"></a><span id="l23.104" class="difflineplus">+        /* bit accumulator */</span>
<a href="#l23.105"></a><span id="l23.105" class="difflineplus">+    unsigned long hold;         /* input bit accumulator */</span>
<a href="#l23.106"></a><span id="l23.106" class="difflineplus">+    unsigned bits;              /* number of bits in &quot;in&quot; */</span>
<a href="#l23.107"></a><span id="l23.107" class="difflineplus">+        /* for string and stored block copying */</span>
<a href="#l23.108"></a><span id="l23.108" class="difflineplus">+    unsigned length;            /* literal or length of data to copy */</span>
<a href="#l23.109"></a><span id="l23.109" class="difflineplus">+    unsigned offset;            /* distance back to copy string from */</span>
<a href="#l23.110"></a><span id="l23.110" class="difflineplus">+        /* for table and code decoding */</span>
<a href="#l23.111"></a><span id="l23.111" class="difflineplus">+    unsigned extra;             /* extra bits needed */</span>
<a href="#l23.112"></a><span id="l23.112" class="difflineplus">+        /* fixed and dynamic code tables */</span>
<a href="#l23.113"></a><span id="l23.113" class="difflineplus">+    code const FAR *lencode;    /* starting table for length/literal codes */</span>
<a href="#l23.114"></a><span id="l23.114" class="difflineplus">+    code const FAR *distcode;   /* starting table for distance codes */</span>
<a href="#l23.115"></a><span id="l23.115" class="difflineplus">+    unsigned lenbits;           /* index bits for lencode */</span>
<a href="#l23.116"></a><span id="l23.116" class="difflineplus">+    unsigned distbits;          /* index bits for distcode */</span>
<a href="#l23.117"></a><span id="l23.117" class="difflineplus">+        /* dynamic table building */</span>
<a href="#l23.118"></a><span id="l23.118" class="difflineplus">+    unsigned ncode;             /* number of code length code lengths */</span>
<a href="#l23.119"></a><span id="l23.119" class="difflineplus">+    unsigned nlen;              /* number of length code lengths */</span>
<a href="#l23.120"></a><span id="l23.120" class="difflineplus">+    unsigned ndist;             /* number of distance code lengths */</span>
<a href="#l23.121"></a><span id="l23.121" class="difflineplus">+    unsigned have;              /* number of code lengths in lens[] */</span>
<a href="#l23.122"></a><span id="l23.122" class="difflineplus">+    code FAR *next;             /* next available space in codes[] */</span>
<a href="#l23.123"></a><span id="l23.123" class="difflineplus">+    unsigned short lens[320];   /* temporary storage for code lengths */</span>
<a href="#l23.124"></a><span id="l23.124" class="difflineplus">+    unsigned short work[288];   /* work area for code table building */</span>
<a href="#l23.125"></a><span id="l23.125" class="difflineplus">+    code codes[ENOUGH];         /* space for code tables */</span>
<a href="#l23.126"></a><span id="l23.126" class="difflineplus">+    int sane;                   /* if false, allow invalid distance too far */</span>
<a href="#l23.127"></a><span id="l23.127" class="difflineplus">+    int back;                   /* bits back of last unprocessed length/lit */</span>
<a href="#l23.128"></a><span id="l23.128" class="difflineplus">+    unsigned was;               /* initial length of match */</span>
<a href="#l23.129"></a><span id="l23.129" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1">new file mode 100644</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineminus">--- /dev/null</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineplus">+++ b/third_party/zlib/inftrees.c</span>
<a href="#l24.4"></a><span id="l24.4" class="difflineat">@@ -0,0 +1,304 @@</span>
<a href="#l24.5"></a><span id="l24.5" class="difflineplus">+/* inftrees.c -- generate Huffman trees for efficient decoding</span>
<a href="#l24.6"></a><span id="l24.6" class="difflineplus">+ * Copyright (C) 1995-2017 Mark Adler</span>
<a href="#l24.7"></a><span id="l24.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l24.8"></a><span id="l24.8" class="difflineplus">+ */</span>
<a href="#l24.9"></a><span id="l24.9" class="difflineplus">+</span>
<a href="#l24.10"></a><span id="l24.10" class="difflineplus">+#include &quot;zutil.h&quot;</span>
<a href="#l24.11"></a><span id="l24.11" class="difflineplus">+#include &quot;inftrees.h&quot;</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineplus">+</span>
<a href="#l24.13"></a><span id="l24.13" class="difflineplus">+#define MAXBITS 15</span>
<a href="#l24.14"></a><span id="l24.14" class="difflineplus">+</span>
<a href="#l24.15"></a><span id="l24.15" class="difflineplus">+const char inflate_copyright[] =</span>
<a href="#l24.16"></a><span id="l24.16" class="difflineplus">+   &quot; inflate 1.2.11 Copyright 1995-2017 Mark Adler &quot;;</span>
<a href="#l24.17"></a><span id="l24.17" class="difflineplus">+/*</span>
<a href="#l24.18"></a><span id="l24.18" class="difflineplus">+  If you use the zlib library in a product, an acknowledgment is welcome</span>
<a href="#l24.19"></a><span id="l24.19" class="difflineplus">+  in the documentation of your product. If for some reason you cannot</span>
<a href="#l24.20"></a><span id="l24.20" class="difflineplus">+  include such an acknowledgment, I would appreciate that you keep this</span>
<a href="#l24.21"></a><span id="l24.21" class="difflineplus">+  copyright string in the executable of your product.</span>
<a href="#l24.22"></a><span id="l24.22" class="difflineplus">+ */</span>
<a href="#l24.23"></a><span id="l24.23" class="difflineplus">+</span>
<a href="#l24.24"></a><span id="l24.24" class="difflineplus">+/*</span>
<a href="#l24.25"></a><span id="l24.25" class="difflineplus">+   Build a set of tables to decode the provided canonical Huffman code.</span>
<a href="#l24.26"></a><span id="l24.26" class="difflineplus">+   The code lengths are lens[0..codes-1].  The result starts at *table,</span>
<a href="#l24.27"></a><span id="l24.27" class="difflineplus">+   whose indices are 0..2^bits-1.  work is a writable array of at least</span>
<a href="#l24.28"></a><span id="l24.28" class="difflineplus">+   lens shorts, which is used as a work area.  type is the type of code</span>
<a href="#l24.29"></a><span id="l24.29" class="difflineplus">+   to be generated, CODES, LENS, or DISTS.  On return, zero is success,</span>
<a href="#l24.30"></a><span id="l24.30" class="difflineplus">+   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table</span>
<a href="#l24.31"></a><span id="l24.31" class="difflineplus">+   on return points to the next available entry's address.  bits is the</span>
<a href="#l24.32"></a><span id="l24.32" class="difflineplus">+   requested root table index bits, and on return it is the actual root</span>
<a href="#l24.33"></a><span id="l24.33" class="difflineplus">+   table index bits.  It will differ if the request is greater than the</span>
<a href="#l24.34"></a><span id="l24.34" class="difflineplus">+   longest code or if it is less than the shortest code.</span>
<a href="#l24.35"></a><span id="l24.35" class="difflineplus">+ */</span>
<a href="#l24.36"></a><span id="l24.36" class="difflineplus">+int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)</span>
<a href="#l24.37"></a><span id="l24.37" class="difflineplus">+codetype type;</span>
<a href="#l24.38"></a><span id="l24.38" class="difflineplus">+unsigned short FAR *lens;</span>
<a href="#l24.39"></a><span id="l24.39" class="difflineplus">+unsigned codes;</span>
<a href="#l24.40"></a><span id="l24.40" class="difflineplus">+code FAR * FAR *table;</span>
<a href="#l24.41"></a><span id="l24.41" class="difflineplus">+unsigned FAR *bits;</span>
<a href="#l24.42"></a><span id="l24.42" class="difflineplus">+unsigned short FAR *work;</span>
<a href="#l24.43"></a><span id="l24.43" class="difflineplus">+{</span>
<a href="#l24.44"></a><span id="l24.44" class="difflineplus">+    unsigned len;               /* a code's length in bits */</span>
<a href="#l24.45"></a><span id="l24.45" class="difflineplus">+    unsigned sym;               /* index of code symbols */</span>
<a href="#l24.46"></a><span id="l24.46" class="difflineplus">+    unsigned min, max;          /* minimum and maximum code lengths */</span>
<a href="#l24.47"></a><span id="l24.47" class="difflineplus">+    unsigned root;              /* number of index bits for root table */</span>
<a href="#l24.48"></a><span id="l24.48" class="difflineplus">+    unsigned curr;              /* number of index bits for current table */</span>
<a href="#l24.49"></a><span id="l24.49" class="difflineplus">+    unsigned drop;              /* code bits to drop for sub-table */</span>
<a href="#l24.50"></a><span id="l24.50" class="difflineplus">+    int left;                   /* number of prefix codes available */</span>
<a href="#l24.51"></a><span id="l24.51" class="difflineplus">+    unsigned used;              /* code entries in table used */</span>
<a href="#l24.52"></a><span id="l24.52" class="difflineplus">+    unsigned huff;              /* Huffman code */</span>
<a href="#l24.53"></a><span id="l24.53" class="difflineplus">+    unsigned incr;              /* for incrementing code, index */</span>
<a href="#l24.54"></a><span id="l24.54" class="difflineplus">+    unsigned fill;              /* index for replicating entries */</span>
<a href="#l24.55"></a><span id="l24.55" class="difflineplus">+    unsigned low;               /* low bits for current root entry */</span>
<a href="#l24.56"></a><span id="l24.56" class="difflineplus">+    unsigned mask;              /* mask for low root bits */</span>
<a href="#l24.57"></a><span id="l24.57" class="difflineplus">+    code here;                  /* table entry for duplication */</span>
<a href="#l24.58"></a><span id="l24.58" class="difflineplus">+    code FAR *next;             /* next available space in table */</span>
<a href="#l24.59"></a><span id="l24.59" class="difflineplus">+    const unsigned short FAR *base;     /* base value table to use */</span>
<a href="#l24.60"></a><span id="l24.60" class="difflineplus">+    const unsigned short FAR *extra;    /* extra bits table to use */</span>
<a href="#l24.61"></a><span id="l24.61" class="difflineplus">+    unsigned match;             /* use base and extra for symbol &gt;= match */</span>
<a href="#l24.62"></a><span id="l24.62" class="difflineplus">+    unsigned short count[MAXBITS+1];    /* number of codes of each length */</span>
<a href="#l24.63"></a><span id="l24.63" class="difflineplus">+    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */</span>
<a href="#l24.64"></a><span id="l24.64" class="difflineplus">+    static const unsigned short lbase[31] = { /* Length codes 257..285 base */</span>
<a href="#l24.65"></a><span id="l24.65" class="difflineplus">+        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,</span>
<a href="#l24.66"></a><span id="l24.66" class="difflineplus">+        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};</span>
<a href="#l24.67"></a><span id="l24.67" class="difflineplus">+    static const unsigned short lext[31] = { /* Length codes 257..285 extra */</span>
<a href="#l24.68"></a><span id="l24.68" class="difflineplus">+        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,</span>
<a href="#l24.69"></a><span id="l24.69" class="difflineplus">+        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 77, 202};</span>
<a href="#l24.70"></a><span id="l24.70" class="difflineplus">+    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */</span>
<a href="#l24.71"></a><span id="l24.71" class="difflineplus">+        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,</span>
<a href="#l24.72"></a><span id="l24.72" class="difflineplus">+        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,</span>
<a href="#l24.73"></a><span id="l24.73" class="difflineplus">+        8193, 12289, 16385, 24577, 0, 0};</span>
<a href="#l24.74"></a><span id="l24.74" class="difflineplus">+    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */</span>
<a href="#l24.75"></a><span id="l24.75" class="difflineplus">+        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,</span>
<a href="#l24.76"></a><span id="l24.76" class="difflineplus">+        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,</span>
<a href="#l24.77"></a><span id="l24.77" class="difflineplus">+        28, 28, 29, 29, 64, 64};</span>
<a href="#l24.78"></a><span id="l24.78" class="difflineplus">+</span>
<a href="#l24.79"></a><span id="l24.79" class="difflineplus">+    /*</span>
<a href="#l24.80"></a><span id="l24.80" class="difflineplus">+       Process a set of code lengths to create a canonical Huffman code.  The</span>
<a href="#l24.81"></a><span id="l24.81" class="difflineplus">+       code lengths are lens[0..codes-1].  Each length corresponds to the</span>
<a href="#l24.82"></a><span id="l24.82" class="difflineplus">+       symbols 0..codes-1.  The Huffman code is generated by first sorting the</span>
<a href="#l24.83"></a><span id="l24.83" class="difflineplus">+       symbols by length from short to long, and retaining the symbol order</span>
<a href="#l24.84"></a><span id="l24.84" class="difflineplus">+       for codes with equal lengths.  Then the code starts with all zero bits</span>
<a href="#l24.85"></a><span id="l24.85" class="difflineplus">+       for the first code of the shortest length, and the codes are integer</span>
<a href="#l24.86"></a><span id="l24.86" class="difflineplus">+       increments for the same length, and zeros are appended as the length</span>
<a href="#l24.87"></a><span id="l24.87" class="difflineplus">+       increases.  For the deflate format, these bits are stored backwards</span>
<a href="#l24.88"></a><span id="l24.88" class="difflineplus">+       from their more natural integer increment ordering, and so when the</span>
<a href="#l24.89"></a><span id="l24.89" class="difflineplus">+       decoding tables are built in the large loop below, the integer codes</span>
<a href="#l24.90"></a><span id="l24.90" class="difflineplus">+       are incremented backwards.</span>
<a href="#l24.91"></a><span id="l24.91" class="difflineplus">+</span>
<a href="#l24.92"></a><span id="l24.92" class="difflineplus">+       This routine assumes, but does not check, that all of the entries in</span>
<a href="#l24.93"></a><span id="l24.93" class="difflineplus">+       lens[] are in the range 0..MAXBITS.  The caller must assure this.</span>
<a href="#l24.94"></a><span id="l24.94" class="difflineplus">+       1..MAXBITS is interpreted as that code length.  zero means that that</span>
<a href="#l24.95"></a><span id="l24.95" class="difflineplus">+       symbol does not occur in this code.</span>
<a href="#l24.96"></a><span id="l24.96" class="difflineplus">+</span>
<a href="#l24.97"></a><span id="l24.97" class="difflineplus">+       The codes are sorted by computing a count of codes for each length,</span>
<a href="#l24.98"></a><span id="l24.98" class="difflineplus">+       creating from that a table of starting indices for each length in the</span>
<a href="#l24.99"></a><span id="l24.99" class="difflineplus">+       sorted table, and then entering the symbols in order in the sorted</span>
<a href="#l24.100"></a><span id="l24.100" class="difflineplus">+       table.  The sorted table is work[], with that space being provided by</span>
<a href="#l24.101"></a><span id="l24.101" class="difflineplus">+       the caller.</span>
<a href="#l24.102"></a><span id="l24.102" class="difflineplus">+</span>
<a href="#l24.103"></a><span id="l24.103" class="difflineplus">+       The length counts are used for other purposes as well, i.e. finding</span>
<a href="#l24.104"></a><span id="l24.104" class="difflineplus">+       the minimum and maximum length codes, determining if there are any</span>
<a href="#l24.105"></a><span id="l24.105" class="difflineplus">+       codes at all, checking for a valid set of lengths, and looking ahead</span>
<a href="#l24.106"></a><span id="l24.106" class="difflineplus">+       at length counts to determine sub-table sizes when building the</span>
<a href="#l24.107"></a><span id="l24.107" class="difflineplus">+       decoding tables.</span>
<a href="#l24.108"></a><span id="l24.108" class="difflineplus">+     */</span>
<a href="#l24.109"></a><span id="l24.109" class="difflineplus">+</span>
<a href="#l24.110"></a><span id="l24.110" class="difflineplus">+    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */</span>
<a href="#l24.111"></a><span id="l24.111" class="difflineplus">+    for (len = 0; len &lt;= MAXBITS; len++)</span>
<a href="#l24.112"></a><span id="l24.112" class="difflineplus">+        count[len] = 0;</span>
<a href="#l24.113"></a><span id="l24.113" class="difflineplus">+    for (sym = 0; sym &lt; codes; sym++)</span>
<a href="#l24.114"></a><span id="l24.114" class="difflineplus">+        count[lens[sym]]++;</span>
<a href="#l24.115"></a><span id="l24.115" class="difflineplus">+</span>
<a href="#l24.116"></a><span id="l24.116" class="difflineplus">+    /* bound code lengths, force root to be within code lengths */</span>
<a href="#l24.117"></a><span id="l24.117" class="difflineplus">+    root = *bits;</span>
<a href="#l24.118"></a><span id="l24.118" class="difflineplus">+    for (max = MAXBITS; max &gt;= 1; max--)</span>
<a href="#l24.119"></a><span id="l24.119" class="difflineplus">+        if (count[max] != 0) break;</span>
<a href="#l24.120"></a><span id="l24.120" class="difflineplus">+    if (root &gt; max) root = max;</span>
<a href="#l24.121"></a><span id="l24.121" class="difflineplus">+    if (max == 0) {                     /* no symbols to code at all */</span>
<a href="#l24.122"></a><span id="l24.122" class="difflineplus">+        here.op = (unsigned char)64;    /* invalid code marker */</span>
<a href="#l24.123"></a><span id="l24.123" class="difflineplus">+        here.bits = (unsigned char)1;</span>
<a href="#l24.124"></a><span id="l24.124" class="difflineplus">+        here.val = (unsigned short)0;</span>
<a href="#l24.125"></a><span id="l24.125" class="difflineplus">+        *(*table)++ = here;             /* make a table to force an error */</span>
<a href="#l24.126"></a><span id="l24.126" class="difflineplus">+        *(*table)++ = here;</span>
<a href="#l24.127"></a><span id="l24.127" class="difflineplus">+        *bits = 1;</span>
<a href="#l24.128"></a><span id="l24.128" class="difflineplus">+        return 0;     /* no symbols, but wait for decoding to report error */</span>
<a href="#l24.129"></a><span id="l24.129" class="difflineplus">+    }</span>
<a href="#l24.130"></a><span id="l24.130" class="difflineplus">+    for (min = 1; min &lt; max; min++)</span>
<a href="#l24.131"></a><span id="l24.131" class="difflineplus">+        if (count[min] != 0) break;</span>
<a href="#l24.132"></a><span id="l24.132" class="difflineplus">+    if (root &lt; min) root = min;</span>
<a href="#l24.133"></a><span id="l24.133" class="difflineplus">+</span>
<a href="#l24.134"></a><span id="l24.134" class="difflineplus">+    /* check for an over-subscribed or incomplete set of lengths */</span>
<a href="#l24.135"></a><span id="l24.135" class="difflineplus">+    left = 1;</span>
<a href="#l24.136"></a><span id="l24.136" class="difflineplus">+    for (len = 1; len &lt;= MAXBITS; len++) {</span>
<a href="#l24.137"></a><span id="l24.137" class="difflineplus">+        left &lt;&lt;= 1;</span>
<a href="#l24.138"></a><span id="l24.138" class="difflineplus">+        left -= count[len];</span>
<a href="#l24.139"></a><span id="l24.139" class="difflineplus">+        if (left &lt; 0) return -1;        /* over-subscribed */</span>
<a href="#l24.140"></a><span id="l24.140" class="difflineplus">+    }</span>
<a href="#l24.141"></a><span id="l24.141" class="difflineplus">+    if (left &gt; 0 &amp;&amp; (type == CODES || max != 1))</span>
<a href="#l24.142"></a><span id="l24.142" class="difflineplus">+        return -1;                      /* incomplete set */</span>
<a href="#l24.143"></a><span id="l24.143" class="difflineplus">+</span>
<a href="#l24.144"></a><span id="l24.144" class="difflineplus">+    /* generate offsets into symbol table for each length for sorting */</span>
<a href="#l24.145"></a><span id="l24.145" class="difflineplus">+    offs[1] = 0;</span>
<a href="#l24.146"></a><span id="l24.146" class="difflineplus">+    for (len = 1; len &lt; MAXBITS; len++)</span>
<a href="#l24.147"></a><span id="l24.147" class="difflineplus">+        offs[len + 1] = offs[len] + count[len];</span>
<a href="#l24.148"></a><span id="l24.148" class="difflineplus">+</span>
<a href="#l24.149"></a><span id="l24.149" class="difflineplus">+    /* sort symbols by length, by symbol order within each length */</span>
<a href="#l24.150"></a><span id="l24.150" class="difflineplus">+    for (sym = 0; sym &lt; codes; sym++)</span>
<a href="#l24.151"></a><span id="l24.151" class="difflineplus">+        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;</span>
<a href="#l24.152"></a><span id="l24.152" class="difflineplus">+</span>
<a href="#l24.153"></a><span id="l24.153" class="difflineplus">+    /*</span>
<a href="#l24.154"></a><span id="l24.154" class="difflineplus">+       Create and fill in decoding tables.  In this loop, the table being</span>
<a href="#l24.155"></a><span id="l24.155" class="difflineplus">+       filled is at next and has curr index bits.  The code being used is huff</span>
<a href="#l24.156"></a><span id="l24.156" class="difflineplus">+       with length len.  That code is converted to an index by dropping drop</span>
<a href="#l24.157"></a><span id="l24.157" class="difflineplus">+       bits off of the bottom.  For codes where len is less than drop + curr,</span>
<a href="#l24.158"></a><span id="l24.158" class="difflineplus">+       those top drop + curr - len bits are incremented through all values to</span>
<a href="#l24.159"></a><span id="l24.159" class="difflineplus">+       fill the table with replicated entries.</span>
<a href="#l24.160"></a><span id="l24.160" class="difflineplus">+</span>
<a href="#l24.161"></a><span id="l24.161" class="difflineplus">+       root is the number of index bits for the root table.  When len exceeds</span>
<a href="#l24.162"></a><span id="l24.162" class="difflineplus">+       root, sub-tables are created pointed to by the root entry with an index</span>
<a href="#l24.163"></a><span id="l24.163" class="difflineplus">+       of the low root bits of huff.  This is saved in low to check for when a</span>
<a href="#l24.164"></a><span id="l24.164" class="difflineplus">+       new sub-table should be started.  drop is zero when the root table is</span>
<a href="#l24.165"></a><span id="l24.165" class="difflineplus">+       being filled, and drop is root when sub-tables are being filled.</span>
<a href="#l24.166"></a><span id="l24.166" class="difflineplus">+</span>
<a href="#l24.167"></a><span id="l24.167" class="difflineplus">+       When a new sub-table is needed, it is necessary to look ahead in the</span>
<a href="#l24.168"></a><span id="l24.168" class="difflineplus">+       code lengths to determine what size sub-table is needed.  The length</span>
<a href="#l24.169"></a><span id="l24.169" class="difflineplus">+       counts are used for this, and so count[] is decremented as codes are</span>
<a href="#l24.170"></a><span id="l24.170" class="difflineplus">+       entered in the tables.</span>
<a href="#l24.171"></a><span id="l24.171" class="difflineplus">+</span>
<a href="#l24.172"></a><span id="l24.172" class="difflineplus">+       used keeps track of how many table entries have been allocated from the</span>
<a href="#l24.173"></a><span id="l24.173" class="difflineplus">+       provided *table space.  It is checked for LENS and DIST tables against</span>
<a href="#l24.174"></a><span id="l24.174" class="difflineplus">+       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in</span>
<a href="#l24.175"></a><span id="l24.175" class="difflineplus">+       the initial root table size constants.  See the comments in inftrees.h</span>
<a href="#l24.176"></a><span id="l24.176" class="difflineplus">+       for more information.</span>
<a href="#l24.177"></a><span id="l24.177" class="difflineplus">+</span>
<a href="#l24.178"></a><span id="l24.178" class="difflineplus">+       sym increments through all symbols, and the loop terminates when</span>
<a href="#l24.179"></a><span id="l24.179" class="difflineplus">+       all codes of length max, i.e. all codes, have been processed.  This</span>
<a href="#l24.180"></a><span id="l24.180" class="difflineplus">+       routine permits incomplete codes, so another loop after this one fills</span>
<a href="#l24.181"></a><span id="l24.181" class="difflineplus">+       in the rest of the decoding tables with invalid code markers.</span>
<a href="#l24.182"></a><span id="l24.182" class="difflineplus">+     */</span>
<a href="#l24.183"></a><span id="l24.183" class="difflineplus">+</span>
<a href="#l24.184"></a><span id="l24.184" class="difflineplus">+    /* set up for code type */</span>
<a href="#l24.185"></a><span id="l24.185" class="difflineplus">+    switch (type) {</span>
<a href="#l24.186"></a><span id="l24.186" class="difflineplus">+    case CODES:</span>
<a href="#l24.187"></a><span id="l24.187" class="difflineplus">+        base = extra = work;    /* dummy value--not used */</span>
<a href="#l24.188"></a><span id="l24.188" class="difflineplus">+        match = 20;</span>
<a href="#l24.189"></a><span id="l24.189" class="difflineplus">+        break;</span>
<a href="#l24.190"></a><span id="l24.190" class="difflineplus">+    case LENS:</span>
<a href="#l24.191"></a><span id="l24.191" class="difflineplus">+        base = lbase;</span>
<a href="#l24.192"></a><span id="l24.192" class="difflineplus">+        extra = lext;</span>
<a href="#l24.193"></a><span id="l24.193" class="difflineplus">+        match = 257;</span>
<a href="#l24.194"></a><span id="l24.194" class="difflineplus">+        break;</span>
<a href="#l24.195"></a><span id="l24.195" class="difflineplus">+    default:    /* DISTS */</span>
<a href="#l24.196"></a><span id="l24.196" class="difflineplus">+        base = dbase;</span>
<a href="#l24.197"></a><span id="l24.197" class="difflineplus">+        extra = dext;</span>
<a href="#l24.198"></a><span id="l24.198" class="difflineplus">+        match = 0;</span>
<a href="#l24.199"></a><span id="l24.199" class="difflineplus">+    }</span>
<a href="#l24.200"></a><span id="l24.200" class="difflineplus">+</span>
<a href="#l24.201"></a><span id="l24.201" class="difflineplus">+    /* initialize state for loop */</span>
<a href="#l24.202"></a><span id="l24.202" class="difflineplus">+    huff = 0;                   /* starting code */</span>
<a href="#l24.203"></a><span id="l24.203" class="difflineplus">+    sym = 0;                    /* starting code symbol */</span>
<a href="#l24.204"></a><span id="l24.204" class="difflineplus">+    len = min;                  /* starting code length */</span>
<a href="#l24.205"></a><span id="l24.205" class="difflineplus">+    next = *table;              /* current table to fill in */</span>
<a href="#l24.206"></a><span id="l24.206" class="difflineplus">+    curr = root;                /* current table index bits */</span>
<a href="#l24.207"></a><span id="l24.207" class="difflineplus">+    drop = 0;                   /* current bits to drop from code for index */</span>
<a href="#l24.208"></a><span id="l24.208" class="difflineplus">+    low = (unsigned)(-1);       /* trigger new sub-table when len &gt; root */</span>
<a href="#l24.209"></a><span id="l24.209" class="difflineplus">+    used = 1U &lt;&lt; root;          /* use root table entries */</span>
<a href="#l24.210"></a><span id="l24.210" class="difflineplus">+    mask = used - 1;            /* mask for comparing low */</span>
<a href="#l24.211"></a><span id="l24.211" class="difflineplus">+</span>
<a href="#l24.212"></a><span id="l24.212" class="difflineplus">+    /* check available table space */</span>
<a href="#l24.213"></a><span id="l24.213" class="difflineplus">+    if ((type == LENS &amp;&amp; used &gt; ENOUGH_LENS) ||</span>
<a href="#l24.214"></a><span id="l24.214" class="difflineplus">+        (type == DISTS &amp;&amp; used &gt; ENOUGH_DISTS))</span>
<a href="#l24.215"></a><span id="l24.215" class="difflineplus">+        return 1;</span>
<a href="#l24.216"></a><span id="l24.216" class="difflineplus">+</span>
<a href="#l24.217"></a><span id="l24.217" class="difflineplus">+    /* process all codes and make table entries */</span>
<a href="#l24.218"></a><span id="l24.218" class="difflineplus">+    for (;;) {</span>
<a href="#l24.219"></a><span id="l24.219" class="difflineplus">+        /* create table entry */</span>
<a href="#l24.220"></a><span id="l24.220" class="difflineplus">+        here.bits = (unsigned char)(len - drop);</span>
<a href="#l24.221"></a><span id="l24.221" class="difflineplus">+        if (work[sym] + 1U &lt; match) {</span>
<a href="#l24.222"></a><span id="l24.222" class="difflineplus">+            here.op = (unsigned char)0;</span>
<a href="#l24.223"></a><span id="l24.223" class="difflineplus">+            here.val = work[sym];</span>
<a href="#l24.224"></a><span id="l24.224" class="difflineplus">+        }</span>
<a href="#l24.225"></a><span id="l24.225" class="difflineplus">+        else if (work[sym] &gt;= match) {</span>
<a href="#l24.226"></a><span id="l24.226" class="difflineplus">+            here.op = (unsigned char)(extra[work[sym] - match]);</span>
<a href="#l24.227"></a><span id="l24.227" class="difflineplus">+            here.val = base[work[sym] - match];</span>
<a href="#l24.228"></a><span id="l24.228" class="difflineplus">+        }</span>
<a href="#l24.229"></a><span id="l24.229" class="difflineplus">+        else {</span>
<a href="#l24.230"></a><span id="l24.230" class="difflineplus">+            here.op = (unsigned char)(32 + 64);         /* end of block */</span>
<a href="#l24.231"></a><span id="l24.231" class="difflineplus">+            here.val = 0;</span>
<a href="#l24.232"></a><span id="l24.232" class="difflineplus">+        }</span>
<a href="#l24.233"></a><span id="l24.233" class="difflineplus">+</span>
<a href="#l24.234"></a><span id="l24.234" class="difflineplus">+        /* replicate for those indices with low len bits equal to huff */</span>
<a href="#l24.235"></a><span id="l24.235" class="difflineplus">+        incr = 1U &lt;&lt; (len - drop);</span>
<a href="#l24.236"></a><span id="l24.236" class="difflineplus">+        fill = 1U &lt;&lt; curr;</span>
<a href="#l24.237"></a><span id="l24.237" class="difflineplus">+        min = fill;                 /* save offset to next table */</span>
<a href="#l24.238"></a><span id="l24.238" class="difflineplus">+        do {</span>
<a href="#l24.239"></a><span id="l24.239" class="difflineplus">+            fill -= incr;</span>
<a href="#l24.240"></a><span id="l24.240" class="difflineplus">+            next[(huff &gt;&gt; drop) + fill] = here;</span>
<a href="#l24.241"></a><span id="l24.241" class="difflineplus">+        } while (fill != 0);</span>
<a href="#l24.242"></a><span id="l24.242" class="difflineplus">+</span>
<a href="#l24.243"></a><span id="l24.243" class="difflineplus">+        /* backwards increment the len-bit code huff */</span>
<a href="#l24.244"></a><span id="l24.244" class="difflineplus">+        incr = 1U &lt;&lt; (len - 1);</span>
<a href="#l24.245"></a><span id="l24.245" class="difflineplus">+        while (huff &amp; incr)</span>
<a href="#l24.246"></a><span id="l24.246" class="difflineplus">+            incr &gt;&gt;= 1;</span>
<a href="#l24.247"></a><span id="l24.247" class="difflineplus">+        if (incr != 0) {</span>
<a href="#l24.248"></a><span id="l24.248" class="difflineplus">+            huff &amp;= incr - 1;</span>
<a href="#l24.249"></a><span id="l24.249" class="difflineplus">+            huff += incr;</span>
<a href="#l24.250"></a><span id="l24.250" class="difflineplus">+        }</span>
<a href="#l24.251"></a><span id="l24.251" class="difflineplus">+        else</span>
<a href="#l24.252"></a><span id="l24.252" class="difflineplus">+            huff = 0;</span>
<a href="#l24.253"></a><span id="l24.253" class="difflineplus">+</span>
<a href="#l24.254"></a><span id="l24.254" class="difflineplus">+        /* go to next symbol, update count, len */</span>
<a href="#l24.255"></a><span id="l24.255" class="difflineplus">+        sym++;</span>
<a href="#l24.256"></a><span id="l24.256" class="difflineplus">+        if (--(count[len]) == 0) {</span>
<a href="#l24.257"></a><span id="l24.257" class="difflineplus">+            if (len == max) break;</span>
<a href="#l24.258"></a><span id="l24.258" class="difflineplus">+            len = lens[work[sym]];</span>
<a href="#l24.259"></a><span id="l24.259" class="difflineplus">+        }</span>
<a href="#l24.260"></a><span id="l24.260" class="difflineplus">+</span>
<a href="#l24.261"></a><span id="l24.261" class="difflineplus">+        /* create new sub-table if needed */</span>
<a href="#l24.262"></a><span id="l24.262" class="difflineplus">+        if (len &gt; root &amp;&amp; (huff &amp; mask) != low) {</span>
<a href="#l24.263"></a><span id="l24.263" class="difflineplus">+            /* if first time, transition to sub-tables */</span>
<a href="#l24.264"></a><span id="l24.264" class="difflineplus">+            if (drop == 0)</span>
<a href="#l24.265"></a><span id="l24.265" class="difflineplus">+                drop = root;</span>
<a href="#l24.266"></a><span id="l24.266" class="difflineplus">+</span>
<a href="#l24.267"></a><span id="l24.267" class="difflineplus">+            /* increment past last table */</span>
<a href="#l24.268"></a><span id="l24.268" class="difflineplus">+            next += min;            /* here min is 1 &lt;&lt; curr */</span>
<a href="#l24.269"></a><span id="l24.269" class="difflineplus">+</span>
<a href="#l24.270"></a><span id="l24.270" class="difflineplus">+            /* determine length of next table */</span>
<a href="#l24.271"></a><span id="l24.271" class="difflineplus">+            curr = len - drop;</span>
<a href="#l24.272"></a><span id="l24.272" class="difflineplus">+            left = (int)(1 &lt;&lt; curr);</span>
<a href="#l24.273"></a><span id="l24.273" class="difflineplus">+            while (curr + drop &lt; max) {</span>
<a href="#l24.274"></a><span id="l24.274" class="difflineplus">+                left -= count[curr + drop];</span>
<a href="#l24.275"></a><span id="l24.275" class="difflineplus">+                if (left &lt;= 0) break;</span>
<a href="#l24.276"></a><span id="l24.276" class="difflineplus">+                curr++;</span>
<a href="#l24.277"></a><span id="l24.277" class="difflineplus">+                left &lt;&lt;= 1;</span>
<a href="#l24.278"></a><span id="l24.278" class="difflineplus">+            }</span>
<a href="#l24.279"></a><span id="l24.279" class="difflineplus">+</span>
<a href="#l24.280"></a><span id="l24.280" class="difflineplus">+            /* check for enough space */</span>
<a href="#l24.281"></a><span id="l24.281" class="difflineplus">+            used += 1U &lt;&lt; curr;</span>
<a href="#l24.282"></a><span id="l24.282" class="difflineplus">+            if ((type == LENS &amp;&amp; used &gt; ENOUGH_LENS) ||</span>
<a href="#l24.283"></a><span id="l24.283" class="difflineplus">+                (type == DISTS &amp;&amp; used &gt; ENOUGH_DISTS))</span>
<a href="#l24.284"></a><span id="l24.284" class="difflineplus">+                return 1;</span>
<a href="#l24.285"></a><span id="l24.285" class="difflineplus">+</span>
<a href="#l24.286"></a><span id="l24.286" class="difflineplus">+            /* point entry in root table to sub-table */</span>
<a href="#l24.287"></a><span id="l24.287" class="difflineplus">+            low = huff &amp; mask;</span>
<a href="#l24.288"></a><span id="l24.288" class="difflineplus">+            (*table)[low].op = (unsigned char)curr;</span>
<a href="#l24.289"></a><span id="l24.289" class="difflineplus">+            (*table)[low].bits = (unsigned char)root;</span>
<a href="#l24.290"></a><span id="l24.290" class="difflineplus">+            (*table)[low].val = (unsigned short)(next - *table);</span>
<a href="#l24.291"></a><span id="l24.291" class="difflineplus">+        }</span>
<a href="#l24.292"></a><span id="l24.292" class="difflineplus">+    }</span>
<a href="#l24.293"></a><span id="l24.293" class="difflineplus">+</span>
<a href="#l24.294"></a><span id="l24.294" class="difflineplus">+    /* fill in remaining table entry if code is incomplete (guaranteed to have</span>
<a href="#l24.295"></a><span id="l24.295" class="difflineplus">+       at most one remaining entry, since if the code is incomplete, the</span>
<a href="#l24.296"></a><span id="l24.296" class="difflineplus">+       maximum code length that was allowed to get this far is one bit) */</span>
<a href="#l24.297"></a><span id="l24.297" class="difflineplus">+    if (huff != 0) {</span>
<a href="#l24.298"></a><span id="l24.298" class="difflineplus">+        here.op = (unsigned char)64;            /* invalid code marker */</span>
<a href="#l24.299"></a><span id="l24.299" class="difflineplus">+        here.bits = (unsigned char)(len - drop);</span>
<a href="#l24.300"></a><span id="l24.300" class="difflineplus">+        here.val = (unsigned short)0;</span>
<a href="#l24.301"></a><span id="l24.301" class="difflineplus">+        next[huff] = here;</span>
<a href="#l24.302"></a><span id="l24.302" class="difflineplus">+    }</span>
<a href="#l24.303"></a><span id="l24.303" class="difflineplus">+</span>
<a href="#l24.304"></a><span id="l24.304" class="difflineplus">+    /* set return parameters */</span>
<a href="#l24.305"></a><span id="l24.305" class="difflineplus">+    *table += used;</span>
<a href="#l24.306"></a><span id="l24.306" class="difflineplus">+    *bits = root;</span>
<a href="#l24.307"></a><span id="l24.307" class="difflineplus">+    return 0;</span>
<a href="#l24.308"></a><span id="l24.308" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1">new file mode 100644</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineminus">--- /dev/null</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineplus">+++ b/third_party/zlib/inftrees.h</span>
<a href="#l25.4"></a><span id="l25.4" class="difflineat">@@ -0,0 +1,62 @@</span>
<a href="#l25.5"></a><span id="l25.5" class="difflineplus">+/* inftrees.h -- header to use inftrees.c</span>
<a href="#l25.6"></a><span id="l25.6" class="difflineplus">+ * Copyright (C) 1995-2005, 2010 Mark Adler</span>
<a href="#l25.7"></a><span id="l25.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l25.8"></a><span id="l25.8" class="difflineplus">+ */</span>
<a href="#l25.9"></a><span id="l25.9" class="difflineplus">+</span>
<a href="#l25.10"></a><span id="l25.10" class="difflineplus">+/* WARNING: this file should *not* be used by applications. It is</span>
<a href="#l25.11"></a><span id="l25.11" class="difflineplus">+   part of the implementation of the compression library and is</span>
<a href="#l25.12"></a><span id="l25.12" class="difflineplus">+   subject to change. Applications should only use zlib.h.</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineplus">+ */</span>
<a href="#l25.14"></a><span id="l25.14" class="difflineplus">+</span>
<a href="#l25.15"></a><span id="l25.15" class="difflineplus">+/* Structure for decoding tables.  Each entry provides either the</span>
<a href="#l25.16"></a><span id="l25.16" class="difflineplus">+   information needed to do the operation requested by the code that</span>
<a href="#l25.17"></a><span id="l25.17" class="difflineplus">+   indexed that table entry, or it provides a pointer to another</span>
<a href="#l25.18"></a><span id="l25.18" class="difflineplus">+   table that indexes more bits of the code.  op indicates whether</span>
<a href="#l25.19"></a><span id="l25.19" class="difflineplus">+   the entry is a pointer to another table, a literal, a length or</span>
<a href="#l25.20"></a><span id="l25.20" class="difflineplus">+   distance, an end-of-block, or an invalid code.  For a table</span>
<a href="#l25.21"></a><span id="l25.21" class="difflineplus">+   pointer, the low four bits of op is the number of index bits of</span>
<a href="#l25.22"></a><span id="l25.22" class="difflineplus">+   that table.  For a length or distance, the low four bits of op</span>
<a href="#l25.23"></a><span id="l25.23" class="difflineplus">+   is the number of extra bits to get after the code.  bits is</span>
<a href="#l25.24"></a><span id="l25.24" class="difflineplus">+   the number of bits in this code or part of the code to drop off</span>
<a href="#l25.25"></a><span id="l25.25" class="difflineplus">+   of the bit buffer.  val is the actual byte to output in the case</span>
<a href="#l25.26"></a><span id="l25.26" class="difflineplus">+   of a literal, the base length or distance, or the offset from</span>
<a href="#l25.27"></a><span id="l25.27" class="difflineplus">+   the current table to the next table.  Each entry is four bytes. */</span>
<a href="#l25.28"></a><span id="l25.28" class="difflineplus">+typedef struct {</span>
<a href="#l25.29"></a><span id="l25.29" class="difflineplus">+    unsigned char op;           /* operation, extra bits, table bits */</span>
<a href="#l25.30"></a><span id="l25.30" class="difflineplus">+    unsigned char bits;         /* bits in this part of the code */</span>
<a href="#l25.31"></a><span id="l25.31" class="difflineplus">+    unsigned short val;         /* offset in table or code value */</span>
<a href="#l25.32"></a><span id="l25.32" class="difflineplus">+} code;</span>
<a href="#l25.33"></a><span id="l25.33" class="difflineplus">+</span>
<a href="#l25.34"></a><span id="l25.34" class="difflineplus">+/* op values as set by inflate_table():</span>
<a href="#l25.35"></a><span id="l25.35" class="difflineplus">+    00000000 - literal</span>
<a href="#l25.36"></a><span id="l25.36" class="difflineplus">+    0000tttt - table link, tttt != 0 is the number of table index bits</span>
<a href="#l25.37"></a><span id="l25.37" class="difflineplus">+    0001eeee - length or distance, eeee is the number of extra bits</span>
<a href="#l25.38"></a><span id="l25.38" class="difflineplus">+    01100000 - end of block</span>
<a href="#l25.39"></a><span id="l25.39" class="difflineplus">+    01000000 - invalid code</span>
<a href="#l25.40"></a><span id="l25.40" class="difflineplus">+ */</span>
<a href="#l25.41"></a><span id="l25.41" class="difflineplus">+</span>
<a href="#l25.42"></a><span id="l25.42" class="difflineplus">+/* Maximum size of the dynamic table.  The maximum number of code structures is</span>
<a href="#l25.43"></a><span id="l25.43" class="difflineplus">+   1444, which is the sum of 852 for literal/length codes and 592 for distance</span>
<a href="#l25.44"></a><span id="l25.44" class="difflineplus">+   codes.  These values were found by exhaustive searches using the program</span>
<a href="#l25.45"></a><span id="l25.45" class="difflineplus">+   examples/enough.c found in the zlib distribtution.  The arguments to that</span>
<a href="#l25.46"></a><span id="l25.46" class="difflineplus">+   program are the number of symbols, the initial root table size, and the</span>
<a href="#l25.47"></a><span id="l25.47" class="difflineplus">+   maximum bit length of a code.  &quot;enough 286 9 15&quot; for literal/length codes</span>
<a href="#l25.48"></a><span id="l25.48" class="difflineplus">+   returns returns 852, and &quot;enough 30 6 15&quot; for distance codes returns 592.</span>
<a href="#l25.49"></a><span id="l25.49" class="difflineplus">+   The initial root table size (9 or 6) is found in the fifth argument of the</span>
<a href="#l25.50"></a><span id="l25.50" class="difflineplus">+   inflate_table() calls in inflate.c and infback.c.  If the root table size is</span>
<a href="#l25.51"></a><span id="l25.51" class="difflineplus">+   changed, then these maximum sizes would be need to be recalculated and</span>
<a href="#l25.52"></a><span id="l25.52" class="difflineplus">+   updated. */</span>
<a href="#l25.53"></a><span id="l25.53" class="difflineplus">+#define ENOUGH_LENS 852</span>
<a href="#l25.54"></a><span id="l25.54" class="difflineplus">+#define ENOUGH_DISTS 592</span>
<a href="#l25.55"></a><span id="l25.55" class="difflineplus">+#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)</span>
<a href="#l25.56"></a><span id="l25.56" class="difflineplus">+</span>
<a href="#l25.57"></a><span id="l25.57" class="difflineplus">+/* Type of code to build for inflate_table() */</span>
<a href="#l25.58"></a><span id="l25.58" class="difflineplus">+typedef enum {</span>
<a href="#l25.59"></a><span id="l25.59" class="difflineplus">+    CODES,</span>
<a href="#l25.60"></a><span id="l25.60" class="difflineplus">+    LENS,</span>
<a href="#l25.61"></a><span id="l25.61" class="difflineplus">+    DISTS</span>
<a href="#l25.62"></a><span id="l25.62" class="difflineplus">+} codetype;</span>
<a href="#l25.63"></a><span id="l25.63" class="difflineplus">+</span>
<a href="#l25.64"></a><span id="l25.64" class="difflineplus">+int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,</span>
<a href="#l25.65"></a><span id="l25.65" class="difflineplus">+                             unsigned codes, code FAR * FAR *table,</span>
<a href="#l25.66"></a><span id="l25.66" class="difflineplus">+                             unsigned FAR *bits, unsigned short FAR *work));</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1">new file mode 100644</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineminus">--- /dev/null</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineplus">+++ b/third_party/zlib/trees.c</span>
<a href="#l26.4"></a><span id="l26.4" class="difflineat">@@ -0,0 +1,1203 @@</span>
<a href="#l26.5"></a><span id="l26.5" class="difflineplus">+/* trees.c -- output deflated data using Huffman coding</span>
<a href="#l26.6"></a><span id="l26.6" class="difflineplus">+ * Copyright (C) 1995-2017 Jean-loup Gailly</span>
<a href="#l26.7"></a><span id="l26.7" class="difflineplus">+ * detect_data_type() function provided freely by Cosmin Truta, 2006</span>
<a href="#l26.8"></a><span id="l26.8" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l26.9"></a><span id="l26.9" class="difflineplus">+ */</span>
<a href="#l26.10"></a><span id="l26.10" class="difflineplus">+</span>
<a href="#l26.11"></a><span id="l26.11" class="difflineplus">+/*</span>
<a href="#l26.12"></a><span id="l26.12" class="difflineplus">+ *  ALGORITHM</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineplus">+ *</span>
<a href="#l26.14"></a><span id="l26.14" class="difflineplus">+ *      The &quot;deflation&quot; process uses several Huffman trees. The more</span>
<a href="#l26.15"></a><span id="l26.15" class="difflineplus">+ *      common source values are represented by shorter bit sequences.</span>
<a href="#l26.16"></a><span id="l26.16" class="difflineplus">+ *</span>
<a href="#l26.17"></a><span id="l26.17" class="difflineplus">+ *      Each code tree is stored in a compressed form which is itself</span>
<a href="#l26.18"></a><span id="l26.18" class="difflineplus">+ * a Huffman encoding of the lengths of all the code strings (in</span>
<a href="#l26.19"></a><span id="l26.19" class="difflineplus">+ * ascending order by source values).  The actual code strings are</span>
<a href="#l26.20"></a><span id="l26.20" class="difflineplus">+ * reconstructed from the lengths in the inflate process, as described</span>
<a href="#l26.21"></a><span id="l26.21" class="difflineplus">+ * in the deflate specification.</span>
<a href="#l26.22"></a><span id="l26.22" class="difflineplus">+ *</span>
<a href="#l26.23"></a><span id="l26.23" class="difflineplus">+ *  REFERENCES</span>
<a href="#l26.24"></a><span id="l26.24" class="difflineplus">+ *</span>
<a href="#l26.25"></a><span id="l26.25" class="difflineplus">+ *      Deutsch, L.P.,&quot;'Deflate' Compressed Data Format Specification&quot;.</span>
<a href="#l26.26"></a><span id="l26.26" class="difflineplus">+ *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc</span>
<a href="#l26.27"></a><span id="l26.27" class="difflineplus">+ *</span>
<a href="#l26.28"></a><span id="l26.28" class="difflineplus">+ *      Storer, James A.</span>
<a href="#l26.29"></a><span id="l26.29" class="difflineplus">+ *          Data Compression:  Methods and Theory, pp. 49-50.</span>
<a href="#l26.30"></a><span id="l26.30" class="difflineplus">+ *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.</span>
<a href="#l26.31"></a><span id="l26.31" class="difflineplus">+ *</span>
<a href="#l26.32"></a><span id="l26.32" class="difflineplus">+ *      Sedgewick, R.</span>
<a href="#l26.33"></a><span id="l26.33" class="difflineplus">+ *          Algorithms, p290.</span>
<a href="#l26.34"></a><span id="l26.34" class="difflineplus">+ *          Addison-Wesley, 1983. ISBN 0-201-06672-6.</span>
<a href="#l26.35"></a><span id="l26.35" class="difflineplus">+ */</span>
<a href="#l26.36"></a><span id="l26.36" class="difflineplus">+</span>
<a href="#l26.37"></a><span id="l26.37" class="difflineplus">+/* @(#) $Id$ */</span>
<a href="#l26.38"></a><span id="l26.38" class="difflineplus">+</span>
<a href="#l26.39"></a><span id="l26.39" class="difflineplus">+/* #define GEN_TREES_H */</span>
<a href="#l26.40"></a><span id="l26.40" class="difflineplus">+</span>
<a href="#l26.41"></a><span id="l26.41" class="difflineplus">+#include &quot;deflate.h&quot;</span>
<a href="#l26.42"></a><span id="l26.42" class="difflineplus">+</span>
<a href="#l26.43"></a><span id="l26.43" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l26.44"></a><span id="l26.44" class="difflineplus">+#  include &lt;ctype.h&gt;</span>
<a href="#l26.45"></a><span id="l26.45" class="difflineplus">+#endif</span>
<a href="#l26.46"></a><span id="l26.46" class="difflineplus">+</span>
<a href="#l26.47"></a><span id="l26.47" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.48"></a><span id="l26.48" class="difflineplus">+ * Constants</span>
<a href="#l26.49"></a><span id="l26.49" class="difflineplus">+ */</span>
<a href="#l26.50"></a><span id="l26.50" class="difflineplus">+</span>
<a href="#l26.51"></a><span id="l26.51" class="difflineplus">+#define MAX_BL_BITS 7</span>
<a href="#l26.52"></a><span id="l26.52" class="difflineplus">+/* Bit length codes must not exceed MAX_BL_BITS bits */</span>
<a href="#l26.53"></a><span id="l26.53" class="difflineplus">+</span>
<a href="#l26.54"></a><span id="l26.54" class="difflineplus">+#define END_BLOCK 256</span>
<a href="#l26.55"></a><span id="l26.55" class="difflineplus">+/* end of block literal code */</span>
<a href="#l26.56"></a><span id="l26.56" class="difflineplus">+</span>
<a href="#l26.57"></a><span id="l26.57" class="difflineplus">+#define REP_3_6      16</span>
<a href="#l26.58"></a><span id="l26.58" class="difflineplus">+/* repeat previous bit length 3-6 times (2 bits of repeat count) */</span>
<a href="#l26.59"></a><span id="l26.59" class="difflineplus">+</span>
<a href="#l26.60"></a><span id="l26.60" class="difflineplus">+#define REPZ_3_10    17</span>
<a href="#l26.61"></a><span id="l26.61" class="difflineplus">+/* repeat a zero length 3-10 times  (3 bits of repeat count) */</span>
<a href="#l26.62"></a><span id="l26.62" class="difflineplus">+</span>
<a href="#l26.63"></a><span id="l26.63" class="difflineplus">+#define REPZ_11_138  18</span>
<a href="#l26.64"></a><span id="l26.64" class="difflineplus">+/* repeat a zero length 11-138 times  (7 bits of repeat count) */</span>
<a href="#l26.65"></a><span id="l26.65" class="difflineplus">+</span>
<a href="#l26.66"></a><span id="l26.66" class="difflineplus">+local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */</span>
<a href="#l26.67"></a><span id="l26.67" class="difflineplus">+   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};</span>
<a href="#l26.68"></a><span id="l26.68" class="difflineplus">+</span>
<a href="#l26.69"></a><span id="l26.69" class="difflineplus">+local const int extra_dbits[D_CODES] /* extra bits for each distance code */</span>
<a href="#l26.70"></a><span id="l26.70" class="difflineplus">+   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};</span>
<a href="#l26.71"></a><span id="l26.71" class="difflineplus">+</span>
<a href="#l26.72"></a><span id="l26.72" class="difflineplus">+local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */</span>
<a href="#l26.73"></a><span id="l26.73" class="difflineplus">+   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};</span>
<a href="#l26.74"></a><span id="l26.74" class="difflineplus">+</span>
<a href="#l26.75"></a><span id="l26.75" class="difflineplus">+local const uch bl_order[BL_CODES]</span>
<a href="#l26.76"></a><span id="l26.76" class="difflineplus">+   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};</span>
<a href="#l26.77"></a><span id="l26.77" class="difflineplus">+/* The lengths of the bit length codes are sent in order of decreasing</span>
<a href="#l26.78"></a><span id="l26.78" class="difflineplus">+ * probability, to avoid transmitting the lengths for unused bit length codes.</span>
<a href="#l26.79"></a><span id="l26.79" class="difflineplus">+ */</span>
<a href="#l26.80"></a><span id="l26.80" class="difflineplus">+</span>
<a href="#l26.81"></a><span id="l26.81" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.82"></a><span id="l26.82" class="difflineplus">+ * Local data. These are initialized only once.</span>
<a href="#l26.83"></a><span id="l26.83" class="difflineplus">+ */</span>
<a href="#l26.84"></a><span id="l26.84" class="difflineplus">+</span>
<a href="#l26.85"></a><span id="l26.85" class="difflineplus">+#define DIST_CODE_LEN  512 /* see definition of array dist_code below */</span>
<a href="#l26.86"></a><span id="l26.86" class="difflineplus">+</span>
<a href="#l26.87"></a><span id="l26.87" class="difflineplus">+#if defined(GEN_TREES_H) || !defined(STDC)</span>
<a href="#l26.88"></a><span id="l26.88" class="difflineplus">+/* non ANSI compilers may not accept trees.h */</span>
<a href="#l26.89"></a><span id="l26.89" class="difflineplus">+</span>
<a href="#l26.90"></a><span id="l26.90" class="difflineplus">+local ct_data static_ltree[L_CODES+2];</span>
<a href="#l26.91"></a><span id="l26.91" class="difflineplus">+/* The static literal tree. Since the bit lengths are imposed, there is no</span>
<a href="#l26.92"></a><span id="l26.92" class="difflineplus">+ * need for the L_CODES extra codes used during heap construction. However</span>
<a href="#l26.93"></a><span id="l26.93" class="difflineplus">+ * The codes 286 and 287 are needed to build a canonical tree (see _tr_init</span>
<a href="#l26.94"></a><span id="l26.94" class="difflineplus">+ * below).</span>
<a href="#l26.95"></a><span id="l26.95" class="difflineplus">+ */</span>
<a href="#l26.96"></a><span id="l26.96" class="difflineplus">+</span>
<a href="#l26.97"></a><span id="l26.97" class="difflineplus">+local ct_data static_dtree[D_CODES];</span>
<a href="#l26.98"></a><span id="l26.98" class="difflineplus">+/* The static distance tree. (Actually a trivial tree since all codes use</span>
<a href="#l26.99"></a><span id="l26.99" class="difflineplus">+ * 5 bits.)</span>
<a href="#l26.100"></a><span id="l26.100" class="difflineplus">+ */</span>
<a href="#l26.101"></a><span id="l26.101" class="difflineplus">+</span>
<a href="#l26.102"></a><span id="l26.102" class="difflineplus">+uch _dist_code[DIST_CODE_LEN];</span>
<a href="#l26.103"></a><span id="l26.103" class="difflineplus">+/* Distance codes. The first 256 values correspond to the distances</span>
<a href="#l26.104"></a><span id="l26.104" class="difflineplus">+ * 3 .. 258, the last 256 values correspond to the top 8 bits of</span>
<a href="#l26.105"></a><span id="l26.105" class="difflineplus">+ * the 15 bit distances.</span>
<a href="#l26.106"></a><span id="l26.106" class="difflineplus">+ */</span>
<a href="#l26.107"></a><span id="l26.107" class="difflineplus">+</span>
<a href="#l26.108"></a><span id="l26.108" class="difflineplus">+uch _length_code[MAX_MATCH-MIN_MATCH+1];</span>
<a href="#l26.109"></a><span id="l26.109" class="difflineplus">+/* length code for each normalized match length (0 == MIN_MATCH) */</span>
<a href="#l26.110"></a><span id="l26.110" class="difflineplus">+</span>
<a href="#l26.111"></a><span id="l26.111" class="difflineplus">+local int base_length[LENGTH_CODES];</span>
<a href="#l26.112"></a><span id="l26.112" class="difflineplus">+/* First normalized length for each code (0 = MIN_MATCH) */</span>
<a href="#l26.113"></a><span id="l26.113" class="difflineplus">+</span>
<a href="#l26.114"></a><span id="l26.114" class="difflineplus">+local int base_dist[D_CODES];</span>
<a href="#l26.115"></a><span id="l26.115" class="difflineplus">+/* First normalized distance for each code (0 = distance of 1) */</span>
<a href="#l26.116"></a><span id="l26.116" class="difflineplus">+</span>
<a href="#l26.117"></a><span id="l26.117" class="difflineplus">+#else</span>
<a href="#l26.118"></a><span id="l26.118" class="difflineplus">+#  include &quot;trees.h&quot;</span>
<a href="#l26.119"></a><span id="l26.119" class="difflineplus">+#endif /* GEN_TREES_H */</span>
<a href="#l26.120"></a><span id="l26.120" class="difflineplus">+</span>
<a href="#l26.121"></a><span id="l26.121" class="difflineplus">+struct static_tree_desc_s {</span>
<a href="#l26.122"></a><span id="l26.122" class="difflineplus">+    const ct_data *static_tree;  /* static tree or NULL */</span>
<a href="#l26.123"></a><span id="l26.123" class="difflineplus">+    const intf *extra_bits;      /* extra bits for each code or NULL */</span>
<a href="#l26.124"></a><span id="l26.124" class="difflineplus">+    int     extra_base;          /* base index for extra_bits */</span>
<a href="#l26.125"></a><span id="l26.125" class="difflineplus">+    int     elems;               /* max number of elements in the tree */</span>
<a href="#l26.126"></a><span id="l26.126" class="difflineplus">+    int     max_length;          /* max bit length for the codes */</span>
<a href="#l26.127"></a><span id="l26.127" class="difflineplus">+};</span>
<a href="#l26.128"></a><span id="l26.128" class="difflineplus">+</span>
<a href="#l26.129"></a><span id="l26.129" class="difflineplus">+local const static_tree_desc  static_l_desc =</span>
<a href="#l26.130"></a><span id="l26.130" class="difflineplus">+{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};</span>
<a href="#l26.131"></a><span id="l26.131" class="difflineplus">+</span>
<a href="#l26.132"></a><span id="l26.132" class="difflineplus">+local const static_tree_desc  static_d_desc =</span>
<a href="#l26.133"></a><span id="l26.133" class="difflineplus">+{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};</span>
<a href="#l26.134"></a><span id="l26.134" class="difflineplus">+</span>
<a href="#l26.135"></a><span id="l26.135" class="difflineplus">+local const static_tree_desc  static_bl_desc =</span>
<a href="#l26.136"></a><span id="l26.136" class="difflineplus">+{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};</span>
<a href="#l26.137"></a><span id="l26.137" class="difflineplus">+</span>
<a href="#l26.138"></a><span id="l26.138" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.139"></a><span id="l26.139" class="difflineplus">+ * Local (static) routines in this file.</span>
<a href="#l26.140"></a><span id="l26.140" class="difflineplus">+ */</span>
<a href="#l26.141"></a><span id="l26.141" class="difflineplus">+</span>
<a href="#l26.142"></a><span id="l26.142" class="difflineplus">+local void tr_static_init OF((void));</span>
<a href="#l26.143"></a><span id="l26.143" class="difflineplus">+local void init_block     OF((deflate_state *s));</span>
<a href="#l26.144"></a><span id="l26.144" class="difflineplus">+local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));</span>
<a href="#l26.145"></a><span id="l26.145" class="difflineplus">+local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));</span>
<a href="#l26.146"></a><span id="l26.146" class="difflineplus">+local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));</span>
<a href="#l26.147"></a><span id="l26.147" class="difflineplus">+local void build_tree     OF((deflate_state *s, tree_desc *desc));</span>
<a href="#l26.148"></a><span id="l26.148" class="difflineplus">+local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));</span>
<a href="#l26.149"></a><span id="l26.149" class="difflineplus">+local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));</span>
<a href="#l26.150"></a><span id="l26.150" class="difflineplus">+local int  build_bl_tree  OF((deflate_state *s));</span>
<a href="#l26.151"></a><span id="l26.151" class="difflineplus">+local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,</span>
<a href="#l26.152"></a><span id="l26.152" class="difflineplus">+                              int blcodes));</span>
<a href="#l26.153"></a><span id="l26.153" class="difflineplus">+local void compress_block OF((deflate_state *s, const ct_data *ltree,</span>
<a href="#l26.154"></a><span id="l26.154" class="difflineplus">+                              const ct_data *dtree));</span>
<a href="#l26.155"></a><span id="l26.155" class="difflineplus">+local int  detect_data_type OF((deflate_state *s));</span>
<a href="#l26.156"></a><span id="l26.156" class="difflineplus">+local unsigned bi_reverse OF((unsigned value, int length));</span>
<a href="#l26.157"></a><span id="l26.157" class="difflineplus">+local void bi_windup      OF((deflate_state *s));</span>
<a href="#l26.158"></a><span id="l26.158" class="difflineplus">+local void bi_flush       OF((deflate_state *s));</span>
<a href="#l26.159"></a><span id="l26.159" class="difflineplus">+</span>
<a href="#l26.160"></a><span id="l26.160" class="difflineplus">+#ifdef GEN_TREES_H</span>
<a href="#l26.161"></a><span id="l26.161" class="difflineplus">+local void gen_trees_header OF((void));</span>
<a href="#l26.162"></a><span id="l26.162" class="difflineplus">+#endif</span>
<a href="#l26.163"></a><span id="l26.163" class="difflineplus">+</span>
<a href="#l26.164"></a><span id="l26.164" class="difflineplus">+#ifndef ZLIB_DEBUG</span>
<a href="#l26.165"></a><span id="l26.165" class="difflineplus">+#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)</span>
<a href="#l26.166"></a><span id="l26.166" class="difflineplus">+   /* Send a code of the given tree. c and tree must not have side effects */</span>
<a href="#l26.167"></a><span id="l26.167" class="difflineplus">+</span>
<a href="#l26.168"></a><span id="l26.168" class="difflineplus">+#else /* !ZLIB_DEBUG */</span>
<a href="#l26.169"></a><span id="l26.169" class="difflineplus">+#  define send_code(s, c, tree) \</span>
<a href="#l26.170"></a><span id="l26.170" class="difflineplus">+     { if (z_verbose&gt;2) fprintf(stderr,&quot;\ncd %3d &quot;,(c)); \</span>
<a href="#l26.171"></a><span id="l26.171" class="difflineplus">+       send_bits(s, tree[c].Code, tree[c].Len); }</span>
<a href="#l26.172"></a><span id="l26.172" class="difflineplus">+#endif</span>
<a href="#l26.173"></a><span id="l26.173" class="difflineplus">+</span>
<a href="#l26.174"></a><span id="l26.174" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.175"></a><span id="l26.175" class="difflineplus">+ * Output a short LSB first on the stream.</span>
<a href="#l26.176"></a><span id="l26.176" class="difflineplus">+ * IN assertion: there is enough room in pendingBuf.</span>
<a href="#l26.177"></a><span id="l26.177" class="difflineplus">+ */</span>
<a href="#l26.178"></a><span id="l26.178" class="difflineplus">+#define put_short(s, w) { \</span>
<a href="#l26.179"></a><span id="l26.179" class="difflineplus">+    put_byte(s, (uch)((w) &amp; 0xff)); \</span>
<a href="#l26.180"></a><span id="l26.180" class="difflineplus">+    put_byte(s, (uch)((ush)(w) &gt;&gt; 8)); \</span>
<a href="#l26.181"></a><span id="l26.181" class="difflineplus">+}</span>
<a href="#l26.182"></a><span id="l26.182" class="difflineplus">+</span>
<a href="#l26.183"></a><span id="l26.183" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.184"></a><span id="l26.184" class="difflineplus">+ * Send a value on a given number of bits.</span>
<a href="#l26.185"></a><span id="l26.185" class="difflineplus">+ * IN assertion: length &lt;= 16 and value fits in length bits.</span>
<a href="#l26.186"></a><span id="l26.186" class="difflineplus">+ */</span>
<a href="#l26.187"></a><span id="l26.187" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l26.188"></a><span id="l26.188" class="difflineplus">+local void send_bits      OF((deflate_state *s, int value, int length));</span>
<a href="#l26.189"></a><span id="l26.189" class="difflineplus">+</span>
<a href="#l26.190"></a><span id="l26.190" class="difflineplus">+local void send_bits(s, value, length)</span>
<a href="#l26.191"></a><span id="l26.191" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.192"></a><span id="l26.192" class="difflineplus">+    int value;  /* value to send */</span>
<a href="#l26.193"></a><span id="l26.193" class="difflineplus">+    int length; /* number of bits */</span>
<a href="#l26.194"></a><span id="l26.194" class="difflineplus">+{</span>
<a href="#l26.195"></a><span id="l26.195" class="difflineplus">+    Tracevv((stderr,&quot; l %2d v %4x &quot;, length, value));</span>
<a href="#l26.196"></a><span id="l26.196" class="difflineplus">+    Assert(length &gt; 0 &amp;&amp; length &lt;= 15, &quot;invalid length&quot;);</span>
<a href="#l26.197"></a><span id="l26.197" class="difflineplus">+    s-&gt;bits_sent += (ulg)length;</span>
<a href="#l26.198"></a><span id="l26.198" class="difflineplus">+</span>
<a href="#l26.199"></a><span id="l26.199" class="difflineplus">+    /* If not enough room in bi_buf, use (valid) bits from bi_buf and</span>
<a href="#l26.200"></a><span id="l26.200" class="difflineplus">+     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))</span>
<a href="#l26.201"></a><span id="l26.201" class="difflineplus">+     * unused bits in value.</span>
<a href="#l26.202"></a><span id="l26.202" class="difflineplus">+     */</span>
<a href="#l26.203"></a><span id="l26.203" class="difflineplus">+    if (s-&gt;bi_valid &gt; (int)Buf_size - length) {</span>
<a href="#l26.204"></a><span id="l26.204" class="difflineplus">+        s-&gt;bi_buf |= (ush)value &lt;&lt; s-&gt;bi_valid;</span>
<a href="#l26.205"></a><span id="l26.205" class="difflineplus">+        put_short(s, s-&gt;bi_buf);</span>
<a href="#l26.206"></a><span id="l26.206" class="difflineplus">+        s-&gt;bi_buf = (ush)value &gt;&gt; (Buf_size - s-&gt;bi_valid);</span>
<a href="#l26.207"></a><span id="l26.207" class="difflineplus">+        s-&gt;bi_valid += length - Buf_size;</span>
<a href="#l26.208"></a><span id="l26.208" class="difflineplus">+    } else {</span>
<a href="#l26.209"></a><span id="l26.209" class="difflineplus">+        s-&gt;bi_buf |= (ush)value &lt;&lt; s-&gt;bi_valid;</span>
<a href="#l26.210"></a><span id="l26.210" class="difflineplus">+        s-&gt;bi_valid += length;</span>
<a href="#l26.211"></a><span id="l26.211" class="difflineplus">+    }</span>
<a href="#l26.212"></a><span id="l26.212" class="difflineplus">+}</span>
<a href="#l26.213"></a><span id="l26.213" class="difflineplus">+#else /* !ZLIB_DEBUG */</span>
<a href="#l26.214"></a><span id="l26.214" class="difflineplus">+</span>
<a href="#l26.215"></a><span id="l26.215" class="difflineplus">+#define send_bits(s, value, length) \</span>
<a href="#l26.216"></a><span id="l26.216" class="difflineplus">+{ int len = length;\</span>
<a href="#l26.217"></a><span id="l26.217" class="difflineplus">+  if (s-&gt;bi_valid &gt; (int)Buf_size - len) {\</span>
<a href="#l26.218"></a><span id="l26.218" class="difflineplus">+    int val = (int)value;\</span>
<a href="#l26.219"></a><span id="l26.219" class="difflineplus">+    s-&gt;bi_buf |= (ush)val &lt;&lt; s-&gt;bi_valid;\</span>
<a href="#l26.220"></a><span id="l26.220" class="difflineplus">+    put_short(s, s-&gt;bi_buf);\</span>
<a href="#l26.221"></a><span id="l26.221" class="difflineplus">+    s-&gt;bi_buf = (ush)val &gt;&gt; (Buf_size - s-&gt;bi_valid);\</span>
<a href="#l26.222"></a><span id="l26.222" class="difflineplus">+    s-&gt;bi_valid += len - Buf_size;\</span>
<a href="#l26.223"></a><span id="l26.223" class="difflineplus">+  } else {\</span>
<a href="#l26.224"></a><span id="l26.224" class="difflineplus">+    s-&gt;bi_buf |= (ush)(value) &lt;&lt; s-&gt;bi_valid;\</span>
<a href="#l26.225"></a><span id="l26.225" class="difflineplus">+    s-&gt;bi_valid += len;\</span>
<a href="#l26.226"></a><span id="l26.226" class="difflineplus">+  }\</span>
<a href="#l26.227"></a><span id="l26.227" class="difflineplus">+}</span>
<a href="#l26.228"></a><span id="l26.228" class="difflineplus">+#endif /* ZLIB_DEBUG */</span>
<a href="#l26.229"></a><span id="l26.229" class="difflineplus">+</span>
<a href="#l26.230"></a><span id="l26.230" class="difflineplus">+</span>
<a href="#l26.231"></a><span id="l26.231" class="difflineplus">+/* the arguments must not have side effects */</span>
<a href="#l26.232"></a><span id="l26.232" class="difflineplus">+</span>
<a href="#l26.233"></a><span id="l26.233" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.234"></a><span id="l26.234" class="difflineplus">+ * Initialize the various 'constant' tables.</span>
<a href="#l26.235"></a><span id="l26.235" class="difflineplus">+ */</span>
<a href="#l26.236"></a><span id="l26.236" class="difflineplus">+local void tr_static_init()</span>
<a href="#l26.237"></a><span id="l26.237" class="difflineplus">+{</span>
<a href="#l26.238"></a><span id="l26.238" class="difflineplus">+#if defined(GEN_TREES_H) || !defined(STDC)</span>
<a href="#l26.239"></a><span id="l26.239" class="difflineplus">+    static int static_init_done = 0;</span>
<a href="#l26.240"></a><span id="l26.240" class="difflineplus">+    int n;        /* iterates over tree elements */</span>
<a href="#l26.241"></a><span id="l26.241" class="difflineplus">+    int bits;     /* bit counter */</span>
<a href="#l26.242"></a><span id="l26.242" class="difflineplus">+    int length;   /* length value */</span>
<a href="#l26.243"></a><span id="l26.243" class="difflineplus">+    int code;     /* code value */</span>
<a href="#l26.244"></a><span id="l26.244" class="difflineplus">+    int dist;     /* distance index */</span>
<a href="#l26.245"></a><span id="l26.245" class="difflineplus">+    ush bl_count[MAX_BITS+1];</span>
<a href="#l26.246"></a><span id="l26.246" class="difflineplus">+    /* number of codes at each bit length for an optimal tree */</span>
<a href="#l26.247"></a><span id="l26.247" class="difflineplus">+</span>
<a href="#l26.248"></a><span id="l26.248" class="difflineplus">+    if (static_init_done) return;</span>
<a href="#l26.249"></a><span id="l26.249" class="difflineplus">+</span>
<a href="#l26.250"></a><span id="l26.250" class="difflineplus">+    /* For some embedded targets, global variables are not initialized: */</span>
<a href="#l26.251"></a><span id="l26.251" class="difflineplus">+#ifdef NO_INIT_GLOBAL_POINTERS</span>
<a href="#l26.252"></a><span id="l26.252" class="difflineplus">+    static_l_desc.static_tree = static_ltree;</span>
<a href="#l26.253"></a><span id="l26.253" class="difflineplus">+    static_l_desc.extra_bits = extra_lbits;</span>
<a href="#l26.254"></a><span id="l26.254" class="difflineplus">+    static_d_desc.static_tree = static_dtree;</span>
<a href="#l26.255"></a><span id="l26.255" class="difflineplus">+    static_d_desc.extra_bits = extra_dbits;</span>
<a href="#l26.256"></a><span id="l26.256" class="difflineplus">+    static_bl_desc.extra_bits = extra_blbits;</span>
<a href="#l26.257"></a><span id="l26.257" class="difflineplus">+#endif</span>
<a href="#l26.258"></a><span id="l26.258" class="difflineplus">+</span>
<a href="#l26.259"></a><span id="l26.259" class="difflineplus">+    /* Initialize the mapping length (0..255) -&gt; length code (0..28) */</span>
<a href="#l26.260"></a><span id="l26.260" class="difflineplus">+    length = 0;</span>
<a href="#l26.261"></a><span id="l26.261" class="difflineplus">+    for (code = 0; code &lt; LENGTH_CODES-1; code++) {</span>
<a href="#l26.262"></a><span id="l26.262" class="difflineplus">+        base_length[code] = length;</span>
<a href="#l26.263"></a><span id="l26.263" class="difflineplus">+        for (n = 0; n &lt; (1&lt;&lt;extra_lbits[code]); n++) {</span>
<a href="#l26.264"></a><span id="l26.264" class="difflineplus">+            _length_code[length++] = (uch)code;</span>
<a href="#l26.265"></a><span id="l26.265" class="difflineplus">+        }</span>
<a href="#l26.266"></a><span id="l26.266" class="difflineplus">+    }</span>
<a href="#l26.267"></a><span id="l26.267" class="difflineplus">+    Assert (length == 256, &quot;tr_static_init: length != 256&quot;);</span>
<a href="#l26.268"></a><span id="l26.268" class="difflineplus">+    /* Note that the length 255 (match length 258) can be represented</span>
<a href="#l26.269"></a><span id="l26.269" class="difflineplus">+     * in two different ways: code 284 + 5 bits or code 285, so we</span>
<a href="#l26.270"></a><span id="l26.270" class="difflineplus">+     * overwrite length_code[255] to use the best encoding:</span>
<a href="#l26.271"></a><span id="l26.271" class="difflineplus">+     */</span>
<a href="#l26.272"></a><span id="l26.272" class="difflineplus">+    _length_code[length-1] = (uch)code;</span>
<a href="#l26.273"></a><span id="l26.273" class="difflineplus">+</span>
<a href="#l26.274"></a><span id="l26.274" class="difflineplus">+    /* Initialize the mapping dist (0..32K) -&gt; dist code (0..29) */</span>
<a href="#l26.275"></a><span id="l26.275" class="difflineplus">+    dist = 0;</span>
<a href="#l26.276"></a><span id="l26.276" class="difflineplus">+    for (code = 0 ; code &lt; 16; code++) {</span>
<a href="#l26.277"></a><span id="l26.277" class="difflineplus">+        base_dist[code] = dist;</span>
<a href="#l26.278"></a><span id="l26.278" class="difflineplus">+        for (n = 0; n &lt; (1&lt;&lt;extra_dbits[code]); n++) {</span>
<a href="#l26.279"></a><span id="l26.279" class="difflineplus">+            _dist_code[dist++] = (uch)code;</span>
<a href="#l26.280"></a><span id="l26.280" class="difflineplus">+        }</span>
<a href="#l26.281"></a><span id="l26.281" class="difflineplus">+    }</span>
<a href="#l26.282"></a><span id="l26.282" class="difflineplus">+    Assert (dist == 256, &quot;tr_static_init: dist != 256&quot;);</span>
<a href="#l26.283"></a><span id="l26.283" class="difflineplus">+    dist &gt;&gt;= 7; /* from now on, all distances are divided by 128 */</span>
<a href="#l26.284"></a><span id="l26.284" class="difflineplus">+    for ( ; code &lt; D_CODES; code++) {</span>
<a href="#l26.285"></a><span id="l26.285" class="difflineplus">+        base_dist[code] = dist &lt;&lt; 7;</span>
<a href="#l26.286"></a><span id="l26.286" class="difflineplus">+        for (n = 0; n &lt; (1&lt;&lt;(extra_dbits[code]-7)); n++) {</span>
<a href="#l26.287"></a><span id="l26.287" class="difflineplus">+            _dist_code[256 + dist++] = (uch)code;</span>
<a href="#l26.288"></a><span id="l26.288" class="difflineplus">+        }</span>
<a href="#l26.289"></a><span id="l26.289" class="difflineplus">+    }</span>
<a href="#l26.290"></a><span id="l26.290" class="difflineplus">+    Assert (dist == 256, &quot;tr_static_init: 256+dist != 512&quot;);</span>
<a href="#l26.291"></a><span id="l26.291" class="difflineplus">+</span>
<a href="#l26.292"></a><span id="l26.292" class="difflineplus">+    /* Construct the codes of the static literal tree */</span>
<a href="#l26.293"></a><span id="l26.293" class="difflineplus">+    for (bits = 0; bits &lt;= MAX_BITS; bits++) bl_count[bits] = 0;</span>
<a href="#l26.294"></a><span id="l26.294" class="difflineplus">+    n = 0;</span>
<a href="#l26.295"></a><span id="l26.295" class="difflineplus">+    while (n &lt;= 143) static_ltree[n++].Len = 8, bl_count[8]++;</span>
<a href="#l26.296"></a><span id="l26.296" class="difflineplus">+    while (n &lt;= 255) static_ltree[n++].Len = 9, bl_count[9]++;</span>
<a href="#l26.297"></a><span id="l26.297" class="difflineplus">+    while (n &lt;= 279) static_ltree[n++].Len = 7, bl_count[7]++;</span>
<a href="#l26.298"></a><span id="l26.298" class="difflineplus">+    while (n &lt;= 287) static_ltree[n++].Len = 8, bl_count[8]++;</span>
<a href="#l26.299"></a><span id="l26.299" class="difflineplus">+    /* Codes 286 and 287 do not exist, but we must include them in the</span>
<a href="#l26.300"></a><span id="l26.300" class="difflineplus">+     * tree construction to get a canonical Huffman tree (longest code</span>
<a href="#l26.301"></a><span id="l26.301" class="difflineplus">+     * all ones)</span>
<a href="#l26.302"></a><span id="l26.302" class="difflineplus">+     */</span>
<a href="#l26.303"></a><span id="l26.303" class="difflineplus">+    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);</span>
<a href="#l26.304"></a><span id="l26.304" class="difflineplus">+</span>
<a href="#l26.305"></a><span id="l26.305" class="difflineplus">+    /* The static distance tree is trivial: */</span>
<a href="#l26.306"></a><span id="l26.306" class="difflineplus">+    for (n = 0; n &lt; D_CODES; n++) {</span>
<a href="#l26.307"></a><span id="l26.307" class="difflineplus">+        static_dtree[n].Len = 5;</span>
<a href="#l26.308"></a><span id="l26.308" class="difflineplus">+        static_dtree[n].Code = bi_reverse((unsigned)n, 5);</span>
<a href="#l26.309"></a><span id="l26.309" class="difflineplus">+    }</span>
<a href="#l26.310"></a><span id="l26.310" class="difflineplus">+    static_init_done = 1;</span>
<a href="#l26.311"></a><span id="l26.311" class="difflineplus">+</span>
<a href="#l26.312"></a><span id="l26.312" class="difflineplus">+#  ifdef GEN_TREES_H</span>
<a href="#l26.313"></a><span id="l26.313" class="difflineplus">+    gen_trees_header();</span>
<a href="#l26.314"></a><span id="l26.314" class="difflineplus">+#  endif</span>
<a href="#l26.315"></a><span id="l26.315" class="difflineplus">+#endif /* defined(GEN_TREES_H) || !defined(STDC) */</span>
<a href="#l26.316"></a><span id="l26.316" class="difflineplus">+}</span>
<a href="#l26.317"></a><span id="l26.317" class="difflineplus">+</span>
<a href="#l26.318"></a><span id="l26.318" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.319"></a><span id="l26.319" class="difflineplus">+ * Genererate the file trees.h describing the static trees.</span>
<a href="#l26.320"></a><span id="l26.320" class="difflineplus">+ */</span>
<a href="#l26.321"></a><span id="l26.321" class="difflineplus">+#ifdef GEN_TREES_H</span>
<a href="#l26.322"></a><span id="l26.322" class="difflineplus">+#  ifndef ZLIB_DEBUG</span>
<a href="#l26.323"></a><span id="l26.323" class="difflineplus">+#    include &lt;stdio.h&gt;</span>
<a href="#l26.324"></a><span id="l26.324" class="difflineplus">+#  endif</span>
<a href="#l26.325"></a><span id="l26.325" class="difflineplus">+</span>
<a href="#l26.326"></a><span id="l26.326" class="difflineplus">+#  define SEPARATOR(i, last, width) \</span>
<a href="#l26.327"></a><span id="l26.327" class="difflineplus">+      ((i) == (last)? &quot;\n};\n\n&quot; :    \</span>
<a href="#l26.328"></a><span id="l26.328" class="difflineplus">+       ((i) % (width) == (width)-1 ? &quot;,\n&quot; : &quot;, &quot;))</span>
<a href="#l26.329"></a><span id="l26.329" class="difflineplus">+</span>
<a href="#l26.330"></a><span id="l26.330" class="difflineplus">+void gen_trees_header()</span>
<a href="#l26.331"></a><span id="l26.331" class="difflineplus">+{</span>
<a href="#l26.332"></a><span id="l26.332" class="difflineplus">+    FILE *header = fopen(&quot;trees.h&quot;, &quot;w&quot;);</span>
<a href="#l26.333"></a><span id="l26.333" class="difflineplus">+    int i;</span>
<a href="#l26.334"></a><span id="l26.334" class="difflineplus">+</span>
<a href="#l26.335"></a><span id="l26.335" class="difflineplus">+    Assert (header != NULL, &quot;Can't open trees.h&quot;);</span>
<a href="#l26.336"></a><span id="l26.336" class="difflineplus">+    fprintf(header,</span>
<a href="#l26.337"></a><span id="l26.337" class="difflineplus">+            &quot;/* header created automatically with -DGEN_TREES_H */\n\n&quot;);</span>
<a href="#l26.338"></a><span id="l26.338" class="difflineplus">+</span>
<a href="#l26.339"></a><span id="l26.339" class="difflineplus">+    fprintf(header, &quot;local const ct_data static_ltree[L_CODES+2] = {\n&quot;);</span>
<a href="#l26.340"></a><span id="l26.340" class="difflineplus">+    for (i = 0; i &lt; L_CODES+2; i++) {</span>
<a href="#l26.341"></a><span id="l26.341" class="difflineplus">+        fprintf(header, &quot;{{%3u},{%3u}}%s&quot;, static_ltree[i].Code,</span>
<a href="#l26.342"></a><span id="l26.342" class="difflineplus">+                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));</span>
<a href="#l26.343"></a><span id="l26.343" class="difflineplus">+    }</span>
<a href="#l26.344"></a><span id="l26.344" class="difflineplus">+</span>
<a href="#l26.345"></a><span id="l26.345" class="difflineplus">+    fprintf(header, &quot;local const ct_data static_dtree[D_CODES] = {\n&quot;);</span>
<a href="#l26.346"></a><span id="l26.346" class="difflineplus">+    for (i = 0; i &lt; D_CODES; i++) {</span>
<a href="#l26.347"></a><span id="l26.347" class="difflineplus">+        fprintf(header, &quot;{{%2u},{%2u}}%s&quot;, static_dtree[i].Code,</span>
<a href="#l26.348"></a><span id="l26.348" class="difflineplus">+                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));</span>
<a href="#l26.349"></a><span id="l26.349" class="difflineplus">+    }</span>
<a href="#l26.350"></a><span id="l26.350" class="difflineplus">+</span>
<a href="#l26.351"></a><span id="l26.351" class="difflineplus">+    fprintf(header, &quot;const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n&quot;);</span>
<a href="#l26.352"></a><span id="l26.352" class="difflineplus">+    for (i = 0; i &lt; DIST_CODE_LEN; i++) {</span>
<a href="#l26.353"></a><span id="l26.353" class="difflineplus">+        fprintf(header, &quot;%2u%s&quot;, _dist_code[i],</span>
<a href="#l26.354"></a><span id="l26.354" class="difflineplus">+                SEPARATOR(i, DIST_CODE_LEN-1, 20));</span>
<a href="#l26.355"></a><span id="l26.355" class="difflineplus">+    }</span>
<a href="#l26.356"></a><span id="l26.356" class="difflineplus">+</span>
<a href="#l26.357"></a><span id="l26.357" class="difflineplus">+    fprintf(header,</span>
<a href="#l26.358"></a><span id="l26.358" class="difflineplus">+        &quot;const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n&quot;);</span>
<a href="#l26.359"></a><span id="l26.359" class="difflineplus">+    for (i = 0; i &lt; MAX_MATCH-MIN_MATCH+1; i++) {</span>
<a href="#l26.360"></a><span id="l26.360" class="difflineplus">+        fprintf(header, &quot;%2u%s&quot;, _length_code[i],</span>
<a href="#l26.361"></a><span id="l26.361" class="difflineplus">+                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));</span>
<a href="#l26.362"></a><span id="l26.362" class="difflineplus">+    }</span>
<a href="#l26.363"></a><span id="l26.363" class="difflineplus">+</span>
<a href="#l26.364"></a><span id="l26.364" class="difflineplus">+    fprintf(header, &quot;local const int base_length[LENGTH_CODES] = {\n&quot;);</span>
<a href="#l26.365"></a><span id="l26.365" class="difflineplus">+    for (i = 0; i &lt; LENGTH_CODES; i++) {</span>
<a href="#l26.366"></a><span id="l26.366" class="difflineplus">+        fprintf(header, &quot;%1u%s&quot;, base_length[i],</span>
<a href="#l26.367"></a><span id="l26.367" class="difflineplus">+                SEPARATOR(i, LENGTH_CODES-1, 20));</span>
<a href="#l26.368"></a><span id="l26.368" class="difflineplus">+    }</span>
<a href="#l26.369"></a><span id="l26.369" class="difflineplus">+</span>
<a href="#l26.370"></a><span id="l26.370" class="difflineplus">+    fprintf(header, &quot;local const int base_dist[D_CODES] = {\n&quot;);</span>
<a href="#l26.371"></a><span id="l26.371" class="difflineplus">+    for (i = 0; i &lt; D_CODES; i++) {</span>
<a href="#l26.372"></a><span id="l26.372" class="difflineplus">+        fprintf(header, &quot;%5u%s&quot;, base_dist[i],</span>
<a href="#l26.373"></a><span id="l26.373" class="difflineplus">+                SEPARATOR(i, D_CODES-1, 10));</span>
<a href="#l26.374"></a><span id="l26.374" class="difflineplus">+    }</span>
<a href="#l26.375"></a><span id="l26.375" class="difflineplus">+</span>
<a href="#l26.376"></a><span id="l26.376" class="difflineplus">+    fclose(header);</span>
<a href="#l26.377"></a><span id="l26.377" class="difflineplus">+}</span>
<a href="#l26.378"></a><span id="l26.378" class="difflineplus">+#endif /* GEN_TREES_H */</span>
<a href="#l26.379"></a><span id="l26.379" class="difflineplus">+</span>
<a href="#l26.380"></a><span id="l26.380" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.381"></a><span id="l26.381" class="difflineplus">+ * Initialize the tree data structures for a new zlib stream.</span>
<a href="#l26.382"></a><span id="l26.382" class="difflineplus">+ */</span>
<a href="#l26.383"></a><span id="l26.383" class="difflineplus">+void ZLIB_INTERNAL _tr_init(s)</span>
<a href="#l26.384"></a><span id="l26.384" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.385"></a><span id="l26.385" class="difflineplus">+{</span>
<a href="#l26.386"></a><span id="l26.386" class="difflineplus">+    tr_static_init();</span>
<a href="#l26.387"></a><span id="l26.387" class="difflineplus">+</span>
<a href="#l26.388"></a><span id="l26.388" class="difflineplus">+    s-&gt;l_desc.dyn_tree = s-&gt;dyn_ltree;</span>
<a href="#l26.389"></a><span id="l26.389" class="difflineplus">+    s-&gt;l_desc.stat_desc = &amp;static_l_desc;</span>
<a href="#l26.390"></a><span id="l26.390" class="difflineplus">+</span>
<a href="#l26.391"></a><span id="l26.391" class="difflineplus">+    s-&gt;d_desc.dyn_tree = s-&gt;dyn_dtree;</span>
<a href="#l26.392"></a><span id="l26.392" class="difflineplus">+    s-&gt;d_desc.stat_desc = &amp;static_d_desc;</span>
<a href="#l26.393"></a><span id="l26.393" class="difflineplus">+</span>
<a href="#l26.394"></a><span id="l26.394" class="difflineplus">+    s-&gt;bl_desc.dyn_tree = s-&gt;bl_tree;</span>
<a href="#l26.395"></a><span id="l26.395" class="difflineplus">+    s-&gt;bl_desc.stat_desc = &amp;static_bl_desc;</span>
<a href="#l26.396"></a><span id="l26.396" class="difflineplus">+</span>
<a href="#l26.397"></a><span id="l26.397" class="difflineplus">+    s-&gt;bi_buf = 0;</span>
<a href="#l26.398"></a><span id="l26.398" class="difflineplus">+    s-&gt;bi_valid = 0;</span>
<a href="#l26.399"></a><span id="l26.399" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l26.400"></a><span id="l26.400" class="difflineplus">+    s-&gt;compressed_len = 0L;</span>
<a href="#l26.401"></a><span id="l26.401" class="difflineplus">+    s-&gt;bits_sent = 0L;</span>
<a href="#l26.402"></a><span id="l26.402" class="difflineplus">+#endif</span>
<a href="#l26.403"></a><span id="l26.403" class="difflineplus">+</span>
<a href="#l26.404"></a><span id="l26.404" class="difflineplus">+    /* Initialize the first block of the first file: */</span>
<a href="#l26.405"></a><span id="l26.405" class="difflineplus">+    init_block(s);</span>
<a href="#l26.406"></a><span id="l26.406" class="difflineplus">+}</span>
<a href="#l26.407"></a><span id="l26.407" class="difflineplus">+</span>
<a href="#l26.408"></a><span id="l26.408" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.409"></a><span id="l26.409" class="difflineplus">+ * Initialize a new block.</span>
<a href="#l26.410"></a><span id="l26.410" class="difflineplus">+ */</span>
<a href="#l26.411"></a><span id="l26.411" class="difflineplus">+local void init_block(s)</span>
<a href="#l26.412"></a><span id="l26.412" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.413"></a><span id="l26.413" class="difflineplus">+{</span>
<a href="#l26.414"></a><span id="l26.414" class="difflineplus">+    int n; /* iterates over tree elements */</span>
<a href="#l26.415"></a><span id="l26.415" class="difflineplus">+</span>
<a href="#l26.416"></a><span id="l26.416" class="difflineplus">+    /* Initialize the trees. */</span>
<a href="#l26.417"></a><span id="l26.417" class="difflineplus">+    for (n = 0; n &lt; L_CODES;  n++) s-&gt;dyn_ltree[n].Freq = 0;</span>
<a href="#l26.418"></a><span id="l26.418" class="difflineplus">+    for (n = 0; n &lt; D_CODES;  n++) s-&gt;dyn_dtree[n].Freq = 0;</span>
<a href="#l26.419"></a><span id="l26.419" class="difflineplus">+    for (n = 0; n &lt; BL_CODES; n++) s-&gt;bl_tree[n].Freq = 0;</span>
<a href="#l26.420"></a><span id="l26.420" class="difflineplus">+</span>
<a href="#l26.421"></a><span id="l26.421" class="difflineplus">+    s-&gt;dyn_ltree[END_BLOCK].Freq = 1;</span>
<a href="#l26.422"></a><span id="l26.422" class="difflineplus">+    s-&gt;opt_len = s-&gt;static_len = 0L;</span>
<a href="#l26.423"></a><span id="l26.423" class="difflineplus">+    s-&gt;last_lit = s-&gt;matches = 0;</span>
<a href="#l26.424"></a><span id="l26.424" class="difflineplus">+}</span>
<a href="#l26.425"></a><span id="l26.425" class="difflineplus">+</span>
<a href="#l26.426"></a><span id="l26.426" class="difflineplus">+#define SMALLEST 1</span>
<a href="#l26.427"></a><span id="l26.427" class="difflineplus">+/* Index within the heap array of least frequent node in the Huffman tree */</span>
<a href="#l26.428"></a><span id="l26.428" class="difflineplus">+</span>
<a href="#l26.429"></a><span id="l26.429" class="difflineplus">+</span>
<a href="#l26.430"></a><span id="l26.430" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.431"></a><span id="l26.431" class="difflineplus">+ * Remove the smallest element from the heap and recreate the heap with</span>
<a href="#l26.432"></a><span id="l26.432" class="difflineplus">+ * one less element. Updates heap and heap_len.</span>
<a href="#l26.433"></a><span id="l26.433" class="difflineplus">+ */</span>
<a href="#l26.434"></a><span id="l26.434" class="difflineplus">+#define pqremove(s, tree, top) \</span>
<a href="#l26.435"></a><span id="l26.435" class="difflineplus">+{\</span>
<a href="#l26.436"></a><span id="l26.436" class="difflineplus">+    top = s-&gt;heap[SMALLEST]; \</span>
<a href="#l26.437"></a><span id="l26.437" class="difflineplus">+    s-&gt;heap[SMALLEST] = s-&gt;heap[s-&gt;heap_len--]; \</span>
<a href="#l26.438"></a><span id="l26.438" class="difflineplus">+    pqdownheap(s, tree, SMALLEST); \</span>
<a href="#l26.439"></a><span id="l26.439" class="difflineplus">+}</span>
<a href="#l26.440"></a><span id="l26.440" class="difflineplus">+</span>
<a href="#l26.441"></a><span id="l26.441" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.442"></a><span id="l26.442" class="difflineplus">+ * Compares to subtrees, using the tree depth as tie breaker when</span>
<a href="#l26.443"></a><span id="l26.443" class="difflineplus">+ * the subtrees have equal frequency. This minimizes the worst case length.</span>
<a href="#l26.444"></a><span id="l26.444" class="difflineplus">+ */</span>
<a href="#l26.445"></a><span id="l26.445" class="difflineplus">+#define smaller(tree, n, m, depth) \</span>
<a href="#l26.446"></a><span id="l26.446" class="difflineplus">+   (tree[n].Freq &lt; tree[m].Freq || \</span>
<a href="#l26.447"></a><span id="l26.447" class="difflineplus">+   (tree[n].Freq == tree[m].Freq &amp;&amp; depth[n] &lt;= depth[m]))</span>
<a href="#l26.448"></a><span id="l26.448" class="difflineplus">+</span>
<a href="#l26.449"></a><span id="l26.449" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.450"></a><span id="l26.450" class="difflineplus">+ * Restore the heap property by moving down the tree starting at node k,</span>
<a href="#l26.451"></a><span id="l26.451" class="difflineplus">+ * exchanging a node with the smallest of its two sons if necessary, stopping</span>
<a href="#l26.452"></a><span id="l26.452" class="difflineplus">+ * when the heap property is re-established (each father smaller than its</span>
<a href="#l26.453"></a><span id="l26.453" class="difflineplus">+ * two sons).</span>
<a href="#l26.454"></a><span id="l26.454" class="difflineplus">+ */</span>
<a href="#l26.455"></a><span id="l26.455" class="difflineplus">+local void pqdownheap(s, tree, k)</span>
<a href="#l26.456"></a><span id="l26.456" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.457"></a><span id="l26.457" class="difflineplus">+    ct_data *tree;  /* the tree to restore */</span>
<a href="#l26.458"></a><span id="l26.458" class="difflineplus">+    int k;               /* node to move down */</span>
<a href="#l26.459"></a><span id="l26.459" class="difflineplus">+{</span>
<a href="#l26.460"></a><span id="l26.460" class="difflineplus">+    int v = s-&gt;heap[k];</span>
<a href="#l26.461"></a><span id="l26.461" class="difflineplus">+    int j = k &lt;&lt; 1;  /* left son of k */</span>
<a href="#l26.462"></a><span id="l26.462" class="difflineplus">+    while (j &lt;= s-&gt;heap_len) {</span>
<a href="#l26.463"></a><span id="l26.463" class="difflineplus">+        /* Set j to the smallest of the two sons: */</span>
<a href="#l26.464"></a><span id="l26.464" class="difflineplus">+        if (j &lt; s-&gt;heap_len &amp;&amp;</span>
<a href="#l26.465"></a><span id="l26.465" class="difflineplus">+            smaller(tree, s-&gt;heap[j+1], s-&gt;heap[j], s-&gt;depth)) {</span>
<a href="#l26.466"></a><span id="l26.466" class="difflineplus">+            j++;</span>
<a href="#l26.467"></a><span id="l26.467" class="difflineplus">+        }</span>
<a href="#l26.468"></a><span id="l26.468" class="difflineplus">+        /* Exit if v is smaller than both sons */</span>
<a href="#l26.469"></a><span id="l26.469" class="difflineplus">+        if (smaller(tree, v, s-&gt;heap[j], s-&gt;depth)) break;</span>
<a href="#l26.470"></a><span id="l26.470" class="difflineplus">+</span>
<a href="#l26.471"></a><span id="l26.471" class="difflineplus">+        /* Exchange v with the smallest son */</span>
<a href="#l26.472"></a><span id="l26.472" class="difflineplus">+        s-&gt;heap[k] = s-&gt;heap[j];  k = j;</span>
<a href="#l26.473"></a><span id="l26.473" class="difflineplus">+</span>
<a href="#l26.474"></a><span id="l26.474" class="difflineplus">+        /* And continue down the tree, setting j to the left son of k */</span>
<a href="#l26.475"></a><span id="l26.475" class="difflineplus">+        j &lt;&lt;= 1;</span>
<a href="#l26.476"></a><span id="l26.476" class="difflineplus">+    }</span>
<a href="#l26.477"></a><span id="l26.477" class="difflineplus">+    s-&gt;heap[k] = v;</span>
<a href="#l26.478"></a><span id="l26.478" class="difflineplus">+}</span>
<a href="#l26.479"></a><span id="l26.479" class="difflineplus">+</span>
<a href="#l26.480"></a><span id="l26.480" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.481"></a><span id="l26.481" class="difflineplus">+ * Compute the optimal bit lengths for a tree and update the total bit length</span>
<a href="#l26.482"></a><span id="l26.482" class="difflineplus">+ * for the current block.</span>
<a href="#l26.483"></a><span id="l26.483" class="difflineplus">+ * IN assertion: the fields freq and dad are set, heap[heap_max] and</span>
<a href="#l26.484"></a><span id="l26.484" class="difflineplus">+ *    above are the tree nodes sorted by increasing frequency.</span>
<a href="#l26.485"></a><span id="l26.485" class="difflineplus">+ * OUT assertions: the field len is set to the optimal bit length, the</span>
<a href="#l26.486"></a><span id="l26.486" class="difflineplus">+ *     array bl_count contains the frequencies for each bit length.</span>
<a href="#l26.487"></a><span id="l26.487" class="difflineplus">+ *     The length opt_len is updated; static_len is also updated if stree is</span>
<a href="#l26.488"></a><span id="l26.488" class="difflineplus">+ *     not null.</span>
<a href="#l26.489"></a><span id="l26.489" class="difflineplus">+ */</span>
<a href="#l26.490"></a><span id="l26.490" class="difflineplus">+local void gen_bitlen(s, desc)</span>
<a href="#l26.491"></a><span id="l26.491" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.492"></a><span id="l26.492" class="difflineplus">+    tree_desc *desc;    /* the tree descriptor */</span>
<a href="#l26.493"></a><span id="l26.493" class="difflineplus">+{</span>
<a href="#l26.494"></a><span id="l26.494" class="difflineplus">+    ct_data *tree        = desc-&gt;dyn_tree;</span>
<a href="#l26.495"></a><span id="l26.495" class="difflineplus">+    int max_code         = desc-&gt;max_code;</span>
<a href="#l26.496"></a><span id="l26.496" class="difflineplus">+    const ct_data *stree = desc-&gt;stat_desc-&gt;static_tree;</span>
<a href="#l26.497"></a><span id="l26.497" class="difflineplus">+    const intf *extra    = desc-&gt;stat_desc-&gt;extra_bits;</span>
<a href="#l26.498"></a><span id="l26.498" class="difflineplus">+    int base             = desc-&gt;stat_desc-&gt;extra_base;</span>
<a href="#l26.499"></a><span id="l26.499" class="difflineplus">+    int max_length       = desc-&gt;stat_desc-&gt;max_length;</span>
<a href="#l26.500"></a><span id="l26.500" class="difflineplus">+    int h;              /* heap index */</span>
<a href="#l26.501"></a><span id="l26.501" class="difflineplus">+    int n, m;           /* iterate over the tree elements */</span>
<a href="#l26.502"></a><span id="l26.502" class="difflineplus">+    int bits;           /* bit length */</span>
<a href="#l26.503"></a><span id="l26.503" class="difflineplus">+    int xbits;          /* extra bits */</span>
<a href="#l26.504"></a><span id="l26.504" class="difflineplus">+    ush f;              /* frequency */</span>
<a href="#l26.505"></a><span id="l26.505" class="difflineplus">+    int overflow = 0;   /* number of elements with bit length too large */</span>
<a href="#l26.506"></a><span id="l26.506" class="difflineplus">+</span>
<a href="#l26.507"></a><span id="l26.507" class="difflineplus">+    for (bits = 0; bits &lt;= MAX_BITS; bits++) s-&gt;bl_count[bits] = 0;</span>
<a href="#l26.508"></a><span id="l26.508" class="difflineplus">+</span>
<a href="#l26.509"></a><span id="l26.509" class="difflineplus">+    /* In a first pass, compute the optimal bit lengths (which may</span>
<a href="#l26.510"></a><span id="l26.510" class="difflineplus">+     * overflow in the case of the bit length tree).</span>
<a href="#l26.511"></a><span id="l26.511" class="difflineplus">+     */</span>
<a href="#l26.512"></a><span id="l26.512" class="difflineplus">+    tree[s-&gt;heap[s-&gt;heap_max]].Len = 0; /* root of the heap */</span>
<a href="#l26.513"></a><span id="l26.513" class="difflineplus">+</span>
<a href="#l26.514"></a><span id="l26.514" class="difflineplus">+    for (h = s-&gt;heap_max+1; h &lt; HEAP_SIZE; h++) {</span>
<a href="#l26.515"></a><span id="l26.515" class="difflineplus">+        n = s-&gt;heap[h];</span>
<a href="#l26.516"></a><span id="l26.516" class="difflineplus">+        bits = tree[tree[n].Dad].Len + 1;</span>
<a href="#l26.517"></a><span id="l26.517" class="difflineplus">+        if (bits &gt; max_length) bits = max_length, overflow++;</span>
<a href="#l26.518"></a><span id="l26.518" class="difflineplus">+        tree[n].Len = (ush)bits;</span>
<a href="#l26.519"></a><span id="l26.519" class="difflineplus">+        /* We overwrite tree[n].Dad which is no longer needed */</span>
<a href="#l26.520"></a><span id="l26.520" class="difflineplus">+</span>
<a href="#l26.521"></a><span id="l26.521" class="difflineplus">+        if (n &gt; max_code) continue; /* not a leaf node */</span>
<a href="#l26.522"></a><span id="l26.522" class="difflineplus">+</span>
<a href="#l26.523"></a><span id="l26.523" class="difflineplus">+        s-&gt;bl_count[bits]++;</span>
<a href="#l26.524"></a><span id="l26.524" class="difflineplus">+        xbits = 0;</span>
<a href="#l26.525"></a><span id="l26.525" class="difflineplus">+        if (n &gt;= base) xbits = extra[n-base];</span>
<a href="#l26.526"></a><span id="l26.526" class="difflineplus">+        f = tree[n].Freq;</span>
<a href="#l26.527"></a><span id="l26.527" class="difflineplus">+        s-&gt;opt_len += (ulg)f * (unsigned)(bits + xbits);</span>
<a href="#l26.528"></a><span id="l26.528" class="difflineplus">+        if (stree) s-&gt;static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);</span>
<a href="#l26.529"></a><span id="l26.529" class="difflineplus">+    }</span>
<a href="#l26.530"></a><span id="l26.530" class="difflineplus">+    if (overflow == 0) return;</span>
<a href="#l26.531"></a><span id="l26.531" class="difflineplus">+</span>
<a href="#l26.532"></a><span id="l26.532" class="difflineplus">+    Tracev((stderr,&quot;\nbit length overflow\n&quot;));</span>
<a href="#l26.533"></a><span id="l26.533" class="difflineplus">+    /* This happens for example on obj2 and pic of the Calgary corpus */</span>
<a href="#l26.534"></a><span id="l26.534" class="difflineplus">+</span>
<a href="#l26.535"></a><span id="l26.535" class="difflineplus">+    /* Find the first bit length which could increase: */</span>
<a href="#l26.536"></a><span id="l26.536" class="difflineplus">+    do {</span>
<a href="#l26.537"></a><span id="l26.537" class="difflineplus">+        bits = max_length-1;</span>
<a href="#l26.538"></a><span id="l26.538" class="difflineplus">+        while (s-&gt;bl_count[bits] == 0) bits--;</span>
<a href="#l26.539"></a><span id="l26.539" class="difflineplus">+        s-&gt;bl_count[bits]--;      /* move one leaf down the tree */</span>
<a href="#l26.540"></a><span id="l26.540" class="difflineplus">+        s-&gt;bl_count[bits+1] += 2; /* move one overflow item as its brother */</span>
<a href="#l26.541"></a><span id="l26.541" class="difflineplus">+        s-&gt;bl_count[max_length]--;</span>
<a href="#l26.542"></a><span id="l26.542" class="difflineplus">+        /* The brother of the overflow item also moves one step up,</span>
<a href="#l26.543"></a><span id="l26.543" class="difflineplus">+         * but this does not affect bl_count[max_length]</span>
<a href="#l26.544"></a><span id="l26.544" class="difflineplus">+         */</span>
<a href="#l26.545"></a><span id="l26.545" class="difflineplus">+        overflow -= 2;</span>
<a href="#l26.546"></a><span id="l26.546" class="difflineplus">+    } while (overflow &gt; 0);</span>
<a href="#l26.547"></a><span id="l26.547" class="difflineplus">+</span>
<a href="#l26.548"></a><span id="l26.548" class="difflineplus">+    /* Now recompute all bit lengths, scanning in increasing frequency.</span>
<a href="#l26.549"></a><span id="l26.549" class="difflineplus">+     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all</span>
<a href="#l26.550"></a><span id="l26.550" class="difflineplus">+     * lengths instead of fixing only the wrong ones. This idea is taken</span>
<a href="#l26.551"></a><span id="l26.551" class="difflineplus">+     * from 'ar' written by Haruhiko Okumura.)</span>
<a href="#l26.552"></a><span id="l26.552" class="difflineplus">+     */</span>
<a href="#l26.553"></a><span id="l26.553" class="difflineplus">+    for (bits = max_length; bits != 0; bits--) {</span>
<a href="#l26.554"></a><span id="l26.554" class="difflineplus">+        n = s-&gt;bl_count[bits];</span>
<a href="#l26.555"></a><span id="l26.555" class="difflineplus">+        while (n != 0) {</span>
<a href="#l26.556"></a><span id="l26.556" class="difflineplus">+            m = s-&gt;heap[--h];</span>
<a href="#l26.557"></a><span id="l26.557" class="difflineplus">+            if (m &gt; max_code) continue;</span>
<a href="#l26.558"></a><span id="l26.558" class="difflineplus">+            if ((unsigned) tree[m].Len != (unsigned) bits) {</span>
<a href="#l26.559"></a><span id="l26.559" class="difflineplus">+                Tracev((stderr,&quot;code %d bits %d-&gt;%d\n&quot;, m, tree[m].Len, bits));</span>
<a href="#l26.560"></a><span id="l26.560" class="difflineplus">+                s-&gt;opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;</span>
<a href="#l26.561"></a><span id="l26.561" class="difflineplus">+                tree[m].Len = (ush)bits;</span>
<a href="#l26.562"></a><span id="l26.562" class="difflineplus">+            }</span>
<a href="#l26.563"></a><span id="l26.563" class="difflineplus">+            n--;</span>
<a href="#l26.564"></a><span id="l26.564" class="difflineplus">+        }</span>
<a href="#l26.565"></a><span id="l26.565" class="difflineplus">+    }</span>
<a href="#l26.566"></a><span id="l26.566" class="difflineplus">+}</span>
<a href="#l26.567"></a><span id="l26.567" class="difflineplus">+</span>
<a href="#l26.568"></a><span id="l26.568" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.569"></a><span id="l26.569" class="difflineplus">+ * Generate the codes for a given tree and bit counts (which need not be</span>
<a href="#l26.570"></a><span id="l26.570" class="difflineplus">+ * optimal).</span>
<a href="#l26.571"></a><span id="l26.571" class="difflineplus">+ * IN assertion: the array bl_count contains the bit length statistics for</span>
<a href="#l26.572"></a><span id="l26.572" class="difflineplus">+ * the given tree and the field len is set for all tree elements.</span>
<a href="#l26.573"></a><span id="l26.573" class="difflineplus">+ * OUT assertion: the field code is set for all tree elements of non</span>
<a href="#l26.574"></a><span id="l26.574" class="difflineplus">+ *     zero code length.</span>
<a href="#l26.575"></a><span id="l26.575" class="difflineplus">+ */</span>
<a href="#l26.576"></a><span id="l26.576" class="difflineplus">+local void gen_codes (tree, max_code, bl_count)</span>
<a href="#l26.577"></a><span id="l26.577" class="difflineplus">+    ct_data *tree;             /* the tree to decorate */</span>
<a href="#l26.578"></a><span id="l26.578" class="difflineplus">+    int max_code;              /* largest code with non zero frequency */</span>
<a href="#l26.579"></a><span id="l26.579" class="difflineplus">+    ushf *bl_count;            /* number of codes at each bit length */</span>
<a href="#l26.580"></a><span id="l26.580" class="difflineplus">+{</span>
<a href="#l26.581"></a><span id="l26.581" class="difflineplus">+    ush next_code[MAX_BITS+1]; /* next code value for each bit length */</span>
<a href="#l26.582"></a><span id="l26.582" class="difflineplus">+    unsigned code = 0;         /* running code value */</span>
<a href="#l26.583"></a><span id="l26.583" class="difflineplus">+    int bits;                  /* bit index */</span>
<a href="#l26.584"></a><span id="l26.584" class="difflineplus">+    int n;                     /* code index */</span>
<a href="#l26.585"></a><span id="l26.585" class="difflineplus">+</span>
<a href="#l26.586"></a><span id="l26.586" class="difflineplus">+    /* The distribution counts are first used to generate the code values</span>
<a href="#l26.587"></a><span id="l26.587" class="difflineplus">+     * without bit reversal.</span>
<a href="#l26.588"></a><span id="l26.588" class="difflineplus">+     */</span>
<a href="#l26.589"></a><span id="l26.589" class="difflineplus">+    for (bits = 1; bits &lt;= MAX_BITS; bits++) {</span>
<a href="#l26.590"></a><span id="l26.590" class="difflineplus">+        code = (code + bl_count[bits-1]) &lt;&lt; 1;</span>
<a href="#l26.591"></a><span id="l26.591" class="difflineplus">+        next_code[bits] = (ush)code;</span>
<a href="#l26.592"></a><span id="l26.592" class="difflineplus">+    }</span>
<a href="#l26.593"></a><span id="l26.593" class="difflineplus">+    /* Check that the bit counts in bl_count are consistent. The last code</span>
<a href="#l26.594"></a><span id="l26.594" class="difflineplus">+     * must be all ones.</span>
<a href="#l26.595"></a><span id="l26.595" class="difflineplus">+     */</span>
<a href="#l26.596"></a><span id="l26.596" class="difflineplus">+    Assert (code + bl_count[MAX_BITS]-1 == (1&lt;&lt;MAX_BITS)-1,</span>
<a href="#l26.597"></a><span id="l26.597" class="difflineplus">+            &quot;inconsistent bit counts&quot;);</span>
<a href="#l26.598"></a><span id="l26.598" class="difflineplus">+    Tracev((stderr,&quot;\ngen_codes: max_code %d &quot;, max_code));</span>
<a href="#l26.599"></a><span id="l26.599" class="difflineplus">+</span>
<a href="#l26.600"></a><span id="l26.600" class="difflineplus">+    for (n = 0;  n &lt;= max_code; n++) {</span>
<a href="#l26.601"></a><span id="l26.601" class="difflineplus">+        int len = tree[n].Len;</span>
<a href="#l26.602"></a><span id="l26.602" class="difflineplus">+        if (len == 0) continue;</span>
<a href="#l26.603"></a><span id="l26.603" class="difflineplus">+        /* Now reverse the bits */</span>
<a href="#l26.604"></a><span id="l26.604" class="difflineplus">+        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);</span>
<a href="#l26.605"></a><span id="l26.605" class="difflineplus">+</span>
<a href="#l26.606"></a><span id="l26.606" class="difflineplus">+        Tracecv(tree != static_ltree, (stderr,&quot;\nn %3d %c l %2d c %4x (%x) &quot;,</span>
<a href="#l26.607"></a><span id="l26.607" class="difflineplus">+             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));</span>
<a href="#l26.608"></a><span id="l26.608" class="difflineplus">+    }</span>
<a href="#l26.609"></a><span id="l26.609" class="difflineplus">+}</span>
<a href="#l26.610"></a><span id="l26.610" class="difflineplus">+</span>
<a href="#l26.611"></a><span id="l26.611" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.612"></a><span id="l26.612" class="difflineplus">+ * Construct one Huffman tree and assigns the code bit strings and lengths.</span>
<a href="#l26.613"></a><span id="l26.613" class="difflineplus">+ * Update the total bit length for the current block.</span>
<a href="#l26.614"></a><span id="l26.614" class="difflineplus">+ * IN assertion: the field freq is set for all tree elements.</span>
<a href="#l26.615"></a><span id="l26.615" class="difflineplus">+ * OUT assertions: the fields len and code are set to the optimal bit length</span>
<a href="#l26.616"></a><span id="l26.616" class="difflineplus">+ *     and corresponding code. The length opt_len is updated; static_len is</span>
<a href="#l26.617"></a><span id="l26.617" class="difflineplus">+ *     also updated if stree is not null. The field max_code is set.</span>
<a href="#l26.618"></a><span id="l26.618" class="difflineplus">+ */</span>
<a href="#l26.619"></a><span id="l26.619" class="difflineplus">+local void build_tree(s, desc)</span>
<a href="#l26.620"></a><span id="l26.620" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.621"></a><span id="l26.621" class="difflineplus">+    tree_desc *desc; /* the tree descriptor */</span>
<a href="#l26.622"></a><span id="l26.622" class="difflineplus">+{</span>
<a href="#l26.623"></a><span id="l26.623" class="difflineplus">+    ct_data *tree         = desc-&gt;dyn_tree;</span>
<a href="#l26.624"></a><span id="l26.624" class="difflineplus">+    const ct_data *stree  = desc-&gt;stat_desc-&gt;static_tree;</span>
<a href="#l26.625"></a><span id="l26.625" class="difflineplus">+    int elems             = desc-&gt;stat_desc-&gt;elems;</span>
<a href="#l26.626"></a><span id="l26.626" class="difflineplus">+    int n, m;          /* iterate over heap elements */</span>
<a href="#l26.627"></a><span id="l26.627" class="difflineplus">+    int max_code = -1; /* largest code with non zero frequency */</span>
<a href="#l26.628"></a><span id="l26.628" class="difflineplus">+    int node;          /* new node being created */</span>
<a href="#l26.629"></a><span id="l26.629" class="difflineplus">+</span>
<a href="#l26.630"></a><span id="l26.630" class="difflineplus">+    /* Construct the initial heap, with least frequent element in</span>
<a href="#l26.631"></a><span id="l26.631" class="difflineplus">+     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].</span>
<a href="#l26.632"></a><span id="l26.632" class="difflineplus">+     * heap[0] is not used.</span>
<a href="#l26.633"></a><span id="l26.633" class="difflineplus">+     */</span>
<a href="#l26.634"></a><span id="l26.634" class="difflineplus">+    s-&gt;heap_len = 0, s-&gt;heap_max = HEAP_SIZE;</span>
<a href="#l26.635"></a><span id="l26.635" class="difflineplus">+</span>
<a href="#l26.636"></a><span id="l26.636" class="difflineplus">+    for (n = 0; n &lt; elems; n++) {</span>
<a href="#l26.637"></a><span id="l26.637" class="difflineplus">+        if (tree[n].Freq != 0) {</span>
<a href="#l26.638"></a><span id="l26.638" class="difflineplus">+            s-&gt;heap[++(s-&gt;heap_len)] = max_code = n;</span>
<a href="#l26.639"></a><span id="l26.639" class="difflineplus">+            s-&gt;depth[n] = 0;</span>
<a href="#l26.640"></a><span id="l26.640" class="difflineplus">+        } else {</span>
<a href="#l26.641"></a><span id="l26.641" class="difflineplus">+            tree[n].Len = 0;</span>
<a href="#l26.642"></a><span id="l26.642" class="difflineplus">+        }</span>
<a href="#l26.643"></a><span id="l26.643" class="difflineplus">+    }</span>
<a href="#l26.644"></a><span id="l26.644" class="difflineplus">+</span>
<a href="#l26.645"></a><span id="l26.645" class="difflineplus">+    /* The pkzip format requires that at least one distance code exists,</span>
<a href="#l26.646"></a><span id="l26.646" class="difflineplus">+     * and that at least one bit should be sent even if there is only one</span>
<a href="#l26.647"></a><span id="l26.647" class="difflineplus">+     * possible code. So to avoid special checks later on we force at least</span>
<a href="#l26.648"></a><span id="l26.648" class="difflineplus">+     * two codes of non zero frequency.</span>
<a href="#l26.649"></a><span id="l26.649" class="difflineplus">+     */</span>
<a href="#l26.650"></a><span id="l26.650" class="difflineplus">+    while (s-&gt;heap_len &lt; 2) {</span>
<a href="#l26.651"></a><span id="l26.651" class="difflineplus">+        node = s-&gt;heap[++(s-&gt;heap_len)] = (max_code &lt; 2 ? ++max_code : 0);</span>
<a href="#l26.652"></a><span id="l26.652" class="difflineplus">+        tree[node].Freq = 1;</span>
<a href="#l26.653"></a><span id="l26.653" class="difflineplus">+        s-&gt;depth[node] = 0;</span>
<a href="#l26.654"></a><span id="l26.654" class="difflineplus">+        s-&gt;opt_len--; if (stree) s-&gt;static_len -= stree[node].Len;</span>
<a href="#l26.655"></a><span id="l26.655" class="difflineplus">+        /* node is 0 or 1 so it does not have extra bits */</span>
<a href="#l26.656"></a><span id="l26.656" class="difflineplus">+    }</span>
<a href="#l26.657"></a><span id="l26.657" class="difflineplus">+    desc-&gt;max_code = max_code;</span>
<a href="#l26.658"></a><span id="l26.658" class="difflineplus">+</span>
<a href="#l26.659"></a><span id="l26.659" class="difflineplus">+    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,</span>
<a href="#l26.660"></a><span id="l26.660" class="difflineplus">+     * establish sub-heaps of increasing lengths:</span>
<a href="#l26.661"></a><span id="l26.661" class="difflineplus">+     */</span>
<a href="#l26.662"></a><span id="l26.662" class="difflineplus">+    for (n = s-&gt;heap_len/2; n &gt;= 1; n--) pqdownheap(s, tree, n);</span>
<a href="#l26.663"></a><span id="l26.663" class="difflineplus">+</span>
<a href="#l26.664"></a><span id="l26.664" class="difflineplus">+    /* Construct the Huffman tree by repeatedly combining the least two</span>
<a href="#l26.665"></a><span id="l26.665" class="difflineplus">+     * frequent nodes.</span>
<a href="#l26.666"></a><span id="l26.666" class="difflineplus">+     */</span>
<a href="#l26.667"></a><span id="l26.667" class="difflineplus">+    node = elems;              /* next internal node of the tree */</span>
<a href="#l26.668"></a><span id="l26.668" class="difflineplus">+    do {</span>
<a href="#l26.669"></a><span id="l26.669" class="difflineplus">+        pqremove(s, tree, n);  /* n = node of least frequency */</span>
<a href="#l26.670"></a><span id="l26.670" class="difflineplus">+        m = s-&gt;heap[SMALLEST]; /* m = node of next least frequency */</span>
<a href="#l26.671"></a><span id="l26.671" class="difflineplus">+</span>
<a href="#l26.672"></a><span id="l26.672" class="difflineplus">+        s-&gt;heap[--(s-&gt;heap_max)] = n; /* keep the nodes sorted by frequency */</span>
<a href="#l26.673"></a><span id="l26.673" class="difflineplus">+        s-&gt;heap[--(s-&gt;heap_max)] = m;</span>
<a href="#l26.674"></a><span id="l26.674" class="difflineplus">+</span>
<a href="#l26.675"></a><span id="l26.675" class="difflineplus">+        /* Create a new node father of n and m */</span>
<a href="#l26.676"></a><span id="l26.676" class="difflineplus">+        tree[node].Freq = tree[n].Freq + tree[m].Freq;</span>
<a href="#l26.677"></a><span id="l26.677" class="difflineplus">+        s-&gt;depth[node] = (uch)((s-&gt;depth[n] &gt;= s-&gt;depth[m] ?</span>
<a href="#l26.678"></a><span id="l26.678" class="difflineplus">+                                s-&gt;depth[n] : s-&gt;depth[m]) + 1);</span>
<a href="#l26.679"></a><span id="l26.679" class="difflineplus">+        tree[n].Dad = tree[m].Dad = (ush)node;</span>
<a href="#l26.680"></a><span id="l26.680" class="difflineplus">+#ifdef DUMP_BL_TREE</span>
<a href="#l26.681"></a><span id="l26.681" class="difflineplus">+        if (tree == s-&gt;bl_tree) {</span>
<a href="#l26.682"></a><span id="l26.682" class="difflineplus">+            fprintf(stderr,&quot;\nnode %d(%d), sons %d(%d) %d(%d)&quot;,</span>
<a href="#l26.683"></a><span id="l26.683" class="difflineplus">+                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);</span>
<a href="#l26.684"></a><span id="l26.684" class="difflineplus">+        }</span>
<a href="#l26.685"></a><span id="l26.685" class="difflineplus">+#endif</span>
<a href="#l26.686"></a><span id="l26.686" class="difflineplus">+        /* and insert the new node in the heap */</span>
<a href="#l26.687"></a><span id="l26.687" class="difflineplus">+        s-&gt;heap[SMALLEST] = node++;</span>
<a href="#l26.688"></a><span id="l26.688" class="difflineplus">+        pqdownheap(s, tree, SMALLEST);</span>
<a href="#l26.689"></a><span id="l26.689" class="difflineplus">+</span>
<a href="#l26.690"></a><span id="l26.690" class="difflineplus">+    } while (s-&gt;heap_len &gt;= 2);</span>
<a href="#l26.691"></a><span id="l26.691" class="difflineplus">+</span>
<a href="#l26.692"></a><span id="l26.692" class="difflineplus">+    s-&gt;heap[--(s-&gt;heap_max)] = s-&gt;heap[SMALLEST];</span>
<a href="#l26.693"></a><span id="l26.693" class="difflineplus">+</span>
<a href="#l26.694"></a><span id="l26.694" class="difflineplus">+    /* At this point, the fields freq and dad are set. We can now</span>
<a href="#l26.695"></a><span id="l26.695" class="difflineplus">+     * generate the bit lengths.</span>
<a href="#l26.696"></a><span id="l26.696" class="difflineplus">+     */</span>
<a href="#l26.697"></a><span id="l26.697" class="difflineplus">+    gen_bitlen(s, (tree_desc *)desc);</span>
<a href="#l26.698"></a><span id="l26.698" class="difflineplus">+</span>
<a href="#l26.699"></a><span id="l26.699" class="difflineplus">+    /* The field len is now set, we can generate the bit codes */</span>
<a href="#l26.700"></a><span id="l26.700" class="difflineplus">+    gen_codes ((ct_data *)tree, max_code, s-&gt;bl_count);</span>
<a href="#l26.701"></a><span id="l26.701" class="difflineplus">+}</span>
<a href="#l26.702"></a><span id="l26.702" class="difflineplus">+</span>
<a href="#l26.703"></a><span id="l26.703" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.704"></a><span id="l26.704" class="difflineplus">+ * Scan a literal or distance tree to determine the frequencies of the codes</span>
<a href="#l26.705"></a><span id="l26.705" class="difflineplus">+ * in the bit length tree.</span>
<a href="#l26.706"></a><span id="l26.706" class="difflineplus">+ */</span>
<a href="#l26.707"></a><span id="l26.707" class="difflineplus">+local void scan_tree (s, tree, max_code)</span>
<a href="#l26.708"></a><span id="l26.708" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.709"></a><span id="l26.709" class="difflineplus">+    ct_data *tree;   /* the tree to be scanned */</span>
<a href="#l26.710"></a><span id="l26.710" class="difflineplus">+    int max_code;    /* and its largest code of non zero frequency */</span>
<a href="#l26.711"></a><span id="l26.711" class="difflineplus">+{</span>
<a href="#l26.712"></a><span id="l26.712" class="difflineplus">+    int n;                     /* iterates over all tree elements */</span>
<a href="#l26.713"></a><span id="l26.713" class="difflineplus">+    int prevlen = -1;          /* last emitted length */</span>
<a href="#l26.714"></a><span id="l26.714" class="difflineplus">+    int curlen;                /* length of current code */</span>
<a href="#l26.715"></a><span id="l26.715" class="difflineplus">+    int nextlen = tree[0].Len; /* length of next code */</span>
<a href="#l26.716"></a><span id="l26.716" class="difflineplus">+    int count = 0;             /* repeat count of the current code */</span>
<a href="#l26.717"></a><span id="l26.717" class="difflineplus">+    int max_count = 7;         /* max repeat count */</span>
<a href="#l26.718"></a><span id="l26.718" class="difflineplus">+    int min_count = 4;         /* min repeat count */</span>
<a href="#l26.719"></a><span id="l26.719" class="difflineplus">+</span>
<a href="#l26.720"></a><span id="l26.720" class="difflineplus">+    if (nextlen == 0) max_count = 138, min_count = 3;</span>
<a href="#l26.721"></a><span id="l26.721" class="difflineplus">+    tree[max_code+1].Len = (ush)0xffff; /* guard */</span>
<a href="#l26.722"></a><span id="l26.722" class="difflineplus">+</span>
<a href="#l26.723"></a><span id="l26.723" class="difflineplus">+    for (n = 0; n &lt;= max_code; n++) {</span>
<a href="#l26.724"></a><span id="l26.724" class="difflineplus">+        curlen = nextlen; nextlen = tree[n+1].Len;</span>
<a href="#l26.725"></a><span id="l26.725" class="difflineplus">+        if (++count &lt; max_count &amp;&amp; curlen == nextlen) {</span>
<a href="#l26.726"></a><span id="l26.726" class="difflineplus">+            continue;</span>
<a href="#l26.727"></a><span id="l26.727" class="difflineplus">+        } else if (count &lt; min_count) {</span>
<a href="#l26.728"></a><span id="l26.728" class="difflineplus">+            s-&gt;bl_tree[curlen].Freq += count;</span>
<a href="#l26.729"></a><span id="l26.729" class="difflineplus">+        } else if (curlen != 0) {</span>
<a href="#l26.730"></a><span id="l26.730" class="difflineplus">+            if (curlen != prevlen) s-&gt;bl_tree[curlen].Freq++;</span>
<a href="#l26.731"></a><span id="l26.731" class="difflineplus">+            s-&gt;bl_tree[REP_3_6].Freq++;</span>
<a href="#l26.732"></a><span id="l26.732" class="difflineplus">+        } else if (count &lt;= 10) {</span>
<a href="#l26.733"></a><span id="l26.733" class="difflineplus">+            s-&gt;bl_tree[REPZ_3_10].Freq++;</span>
<a href="#l26.734"></a><span id="l26.734" class="difflineplus">+        } else {</span>
<a href="#l26.735"></a><span id="l26.735" class="difflineplus">+            s-&gt;bl_tree[REPZ_11_138].Freq++;</span>
<a href="#l26.736"></a><span id="l26.736" class="difflineplus">+        }</span>
<a href="#l26.737"></a><span id="l26.737" class="difflineplus">+        count = 0; prevlen = curlen;</span>
<a href="#l26.738"></a><span id="l26.738" class="difflineplus">+        if (nextlen == 0) {</span>
<a href="#l26.739"></a><span id="l26.739" class="difflineplus">+            max_count = 138, min_count = 3;</span>
<a href="#l26.740"></a><span id="l26.740" class="difflineplus">+        } else if (curlen == nextlen) {</span>
<a href="#l26.741"></a><span id="l26.741" class="difflineplus">+            max_count = 6, min_count = 3;</span>
<a href="#l26.742"></a><span id="l26.742" class="difflineplus">+        } else {</span>
<a href="#l26.743"></a><span id="l26.743" class="difflineplus">+            max_count = 7, min_count = 4;</span>
<a href="#l26.744"></a><span id="l26.744" class="difflineplus">+        }</span>
<a href="#l26.745"></a><span id="l26.745" class="difflineplus">+    }</span>
<a href="#l26.746"></a><span id="l26.746" class="difflineplus">+}</span>
<a href="#l26.747"></a><span id="l26.747" class="difflineplus">+</span>
<a href="#l26.748"></a><span id="l26.748" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.749"></a><span id="l26.749" class="difflineplus">+ * Send a literal or distance tree in compressed form, using the codes in</span>
<a href="#l26.750"></a><span id="l26.750" class="difflineplus">+ * bl_tree.</span>
<a href="#l26.751"></a><span id="l26.751" class="difflineplus">+ */</span>
<a href="#l26.752"></a><span id="l26.752" class="difflineplus">+local void send_tree (s, tree, max_code)</span>
<a href="#l26.753"></a><span id="l26.753" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.754"></a><span id="l26.754" class="difflineplus">+    ct_data *tree; /* the tree to be scanned */</span>
<a href="#l26.755"></a><span id="l26.755" class="difflineplus">+    int max_code;       /* and its largest code of non zero frequency */</span>
<a href="#l26.756"></a><span id="l26.756" class="difflineplus">+{</span>
<a href="#l26.757"></a><span id="l26.757" class="difflineplus">+    int n;                     /* iterates over all tree elements */</span>
<a href="#l26.758"></a><span id="l26.758" class="difflineplus">+    int prevlen = -1;          /* last emitted length */</span>
<a href="#l26.759"></a><span id="l26.759" class="difflineplus">+    int curlen;                /* length of current code */</span>
<a href="#l26.760"></a><span id="l26.760" class="difflineplus">+    int nextlen = tree[0].Len; /* length of next code */</span>
<a href="#l26.761"></a><span id="l26.761" class="difflineplus">+    int count = 0;             /* repeat count of the current code */</span>
<a href="#l26.762"></a><span id="l26.762" class="difflineplus">+    int max_count = 7;         /* max repeat count */</span>
<a href="#l26.763"></a><span id="l26.763" class="difflineplus">+    int min_count = 4;         /* min repeat count */</span>
<a href="#l26.764"></a><span id="l26.764" class="difflineplus">+</span>
<a href="#l26.765"></a><span id="l26.765" class="difflineplus">+    /* tree[max_code+1].Len = -1; */  /* guard already set */</span>
<a href="#l26.766"></a><span id="l26.766" class="difflineplus">+    if (nextlen == 0) max_count = 138, min_count = 3;</span>
<a href="#l26.767"></a><span id="l26.767" class="difflineplus">+</span>
<a href="#l26.768"></a><span id="l26.768" class="difflineplus">+    for (n = 0; n &lt;= max_code; n++) {</span>
<a href="#l26.769"></a><span id="l26.769" class="difflineplus">+        curlen = nextlen; nextlen = tree[n+1].Len;</span>
<a href="#l26.770"></a><span id="l26.770" class="difflineplus">+        if (++count &lt; max_count &amp;&amp; curlen == nextlen) {</span>
<a href="#l26.771"></a><span id="l26.771" class="difflineplus">+            continue;</span>
<a href="#l26.772"></a><span id="l26.772" class="difflineplus">+        } else if (count &lt; min_count) {</span>
<a href="#l26.773"></a><span id="l26.773" class="difflineplus">+            do { send_code(s, curlen, s-&gt;bl_tree); } while (--count != 0);</span>
<a href="#l26.774"></a><span id="l26.774" class="difflineplus">+</span>
<a href="#l26.775"></a><span id="l26.775" class="difflineplus">+        } else if (curlen != 0) {</span>
<a href="#l26.776"></a><span id="l26.776" class="difflineplus">+            if (curlen != prevlen) {</span>
<a href="#l26.777"></a><span id="l26.777" class="difflineplus">+                send_code(s, curlen, s-&gt;bl_tree); count--;</span>
<a href="#l26.778"></a><span id="l26.778" class="difflineplus">+            }</span>
<a href="#l26.779"></a><span id="l26.779" class="difflineplus">+            Assert(count &gt;= 3 &amp;&amp; count &lt;= 6, &quot; 3_6?&quot;);</span>
<a href="#l26.780"></a><span id="l26.780" class="difflineplus">+            send_code(s, REP_3_6, s-&gt;bl_tree); send_bits(s, count-3, 2);</span>
<a href="#l26.781"></a><span id="l26.781" class="difflineplus">+</span>
<a href="#l26.782"></a><span id="l26.782" class="difflineplus">+        } else if (count &lt;= 10) {</span>
<a href="#l26.783"></a><span id="l26.783" class="difflineplus">+            send_code(s, REPZ_3_10, s-&gt;bl_tree); send_bits(s, count-3, 3);</span>
<a href="#l26.784"></a><span id="l26.784" class="difflineplus">+</span>
<a href="#l26.785"></a><span id="l26.785" class="difflineplus">+        } else {</span>
<a href="#l26.786"></a><span id="l26.786" class="difflineplus">+            send_code(s, REPZ_11_138, s-&gt;bl_tree); send_bits(s, count-11, 7);</span>
<a href="#l26.787"></a><span id="l26.787" class="difflineplus">+        }</span>
<a href="#l26.788"></a><span id="l26.788" class="difflineplus">+        count = 0; prevlen = curlen;</span>
<a href="#l26.789"></a><span id="l26.789" class="difflineplus">+        if (nextlen == 0) {</span>
<a href="#l26.790"></a><span id="l26.790" class="difflineplus">+            max_count = 138, min_count = 3;</span>
<a href="#l26.791"></a><span id="l26.791" class="difflineplus">+        } else if (curlen == nextlen) {</span>
<a href="#l26.792"></a><span id="l26.792" class="difflineplus">+            max_count = 6, min_count = 3;</span>
<a href="#l26.793"></a><span id="l26.793" class="difflineplus">+        } else {</span>
<a href="#l26.794"></a><span id="l26.794" class="difflineplus">+            max_count = 7, min_count = 4;</span>
<a href="#l26.795"></a><span id="l26.795" class="difflineplus">+        }</span>
<a href="#l26.796"></a><span id="l26.796" class="difflineplus">+    }</span>
<a href="#l26.797"></a><span id="l26.797" class="difflineplus">+}</span>
<a href="#l26.798"></a><span id="l26.798" class="difflineplus">+</span>
<a href="#l26.799"></a><span id="l26.799" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.800"></a><span id="l26.800" class="difflineplus">+ * Construct the Huffman tree for the bit lengths and return the index in</span>
<a href="#l26.801"></a><span id="l26.801" class="difflineplus">+ * bl_order of the last bit length code to send.</span>
<a href="#l26.802"></a><span id="l26.802" class="difflineplus">+ */</span>
<a href="#l26.803"></a><span id="l26.803" class="difflineplus">+local int build_bl_tree(s)</span>
<a href="#l26.804"></a><span id="l26.804" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.805"></a><span id="l26.805" class="difflineplus">+{</span>
<a href="#l26.806"></a><span id="l26.806" class="difflineplus">+    int max_blindex;  /* index of last bit length code of non zero freq */</span>
<a href="#l26.807"></a><span id="l26.807" class="difflineplus">+</span>
<a href="#l26.808"></a><span id="l26.808" class="difflineplus">+    /* Determine the bit length frequencies for literal and distance trees */</span>
<a href="#l26.809"></a><span id="l26.809" class="difflineplus">+    scan_tree(s, (ct_data *)s-&gt;dyn_ltree, s-&gt;l_desc.max_code);</span>
<a href="#l26.810"></a><span id="l26.810" class="difflineplus">+    scan_tree(s, (ct_data *)s-&gt;dyn_dtree, s-&gt;d_desc.max_code);</span>
<a href="#l26.811"></a><span id="l26.811" class="difflineplus">+</span>
<a href="#l26.812"></a><span id="l26.812" class="difflineplus">+    /* Build the bit length tree: */</span>
<a href="#l26.813"></a><span id="l26.813" class="difflineplus">+    build_tree(s, (tree_desc *)(&amp;(s-&gt;bl_desc)));</span>
<a href="#l26.814"></a><span id="l26.814" class="difflineplus">+    /* opt_len now includes the length of the tree representations, except</span>
<a href="#l26.815"></a><span id="l26.815" class="difflineplus">+     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.</span>
<a href="#l26.816"></a><span id="l26.816" class="difflineplus">+     */</span>
<a href="#l26.817"></a><span id="l26.817" class="difflineplus">+</span>
<a href="#l26.818"></a><span id="l26.818" class="difflineplus">+    /* Determine the number of bit length codes to send. The pkzip format</span>
<a href="#l26.819"></a><span id="l26.819" class="difflineplus">+     * requires that at least 4 bit length codes be sent. (appnote.txt says</span>
<a href="#l26.820"></a><span id="l26.820" class="difflineplus">+     * 3 but the actual value used is 4.)</span>
<a href="#l26.821"></a><span id="l26.821" class="difflineplus">+     */</span>
<a href="#l26.822"></a><span id="l26.822" class="difflineplus">+    for (max_blindex = BL_CODES-1; max_blindex &gt;= 3; max_blindex--) {</span>
<a href="#l26.823"></a><span id="l26.823" class="difflineplus">+        if (s-&gt;bl_tree[bl_order[max_blindex]].Len != 0) break;</span>
<a href="#l26.824"></a><span id="l26.824" class="difflineplus">+    }</span>
<a href="#l26.825"></a><span id="l26.825" class="difflineplus">+    /* Update opt_len to include the bit length tree and counts */</span>
<a href="#l26.826"></a><span id="l26.826" class="difflineplus">+    s-&gt;opt_len += 3*((ulg)max_blindex+1) + 5+5+4;</span>
<a href="#l26.827"></a><span id="l26.827" class="difflineplus">+    Tracev((stderr, &quot;\ndyn trees: dyn %ld, stat %ld&quot;,</span>
<a href="#l26.828"></a><span id="l26.828" class="difflineplus">+            s-&gt;opt_len, s-&gt;static_len));</span>
<a href="#l26.829"></a><span id="l26.829" class="difflineplus">+</span>
<a href="#l26.830"></a><span id="l26.830" class="difflineplus">+    return max_blindex;</span>
<a href="#l26.831"></a><span id="l26.831" class="difflineplus">+}</span>
<a href="#l26.832"></a><span id="l26.832" class="difflineplus">+</span>
<a href="#l26.833"></a><span id="l26.833" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.834"></a><span id="l26.834" class="difflineplus">+ * Send the header for a block using dynamic Huffman trees: the counts, the</span>
<a href="#l26.835"></a><span id="l26.835" class="difflineplus">+ * lengths of the bit length codes, the literal tree and the distance tree.</span>
<a href="#l26.836"></a><span id="l26.836" class="difflineplus">+ * IN assertion: lcodes &gt;= 257, dcodes &gt;= 1, blcodes &gt;= 4.</span>
<a href="#l26.837"></a><span id="l26.837" class="difflineplus">+ */</span>
<a href="#l26.838"></a><span id="l26.838" class="difflineplus">+local void send_all_trees(s, lcodes, dcodes, blcodes)</span>
<a href="#l26.839"></a><span id="l26.839" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.840"></a><span id="l26.840" class="difflineplus">+    int lcodes, dcodes, blcodes; /* number of codes for each tree */</span>
<a href="#l26.841"></a><span id="l26.841" class="difflineplus">+{</span>
<a href="#l26.842"></a><span id="l26.842" class="difflineplus">+    int rank;                    /* index in bl_order */</span>
<a href="#l26.843"></a><span id="l26.843" class="difflineplus">+</span>
<a href="#l26.844"></a><span id="l26.844" class="difflineplus">+    Assert (lcodes &gt;= 257 &amp;&amp; dcodes &gt;= 1 &amp;&amp; blcodes &gt;= 4, &quot;not enough codes&quot;);</span>
<a href="#l26.845"></a><span id="l26.845" class="difflineplus">+    Assert (lcodes &lt;= L_CODES &amp;&amp; dcodes &lt;= D_CODES &amp;&amp; blcodes &lt;= BL_CODES,</span>
<a href="#l26.846"></a><span id="l26.846" class="difflineplus">+            &quot;too many codes&quot;);</span>
<a href="#l26.847"></a><span id="l26.847" class="difflineplus">+    Tracev((stderr, &quot;\nbl counts: &quot;));</span>
<a href="#l26.848"></a><span id="l26.848" class="difflineplus">+    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */</span>
<a href="#l26.849"></a><span id="l26.849" class="difflineplus">+    send_bits(s, dcodes-1,   5);</span>
<a href="#l26.850"></a><span id="l26.850" class="difflineplus">+    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */</span>
<a href="#l26.851"></a><span id="l26.851" class="difflineplus">+    for (rank = 0; rank &lt; blcodes; rank++) {</span>
<a href="#l26.852"></a><span id="l26.852" class="difflineplus">+        Tracev((stderr, &quot;\nbl code %2d &quot;, bl_order[rank]));</span>
<a href="#l26.853"></a><span id="l26.853" class="difflineplus">+        send_bits(s, s-&gt;bl_tree[bl_order[rank]].Len, 3);</span>
<a href="#l26.854"></a><span id="l26.854" class="difflineplus">+    }</span>
<a href="#l26.855"></a><span id="l26.855" class="difflineplus">+    Tracev((stderr, &quot;\nbl tree: sent %ld&quot;, s-&gt;bits_sent));</span>
<a href="#l26.856"></a><span id="l26.856" class="difflineplus">+</span>
<a href="#l26.857"></a><span id="l26.857" class="difflineplus">+    send_tree(s, (ct_data *)s-&gt;dyn_ltree, lcodes-1); /* literal tree */</span>
<a href="#l26.858"></a><span id="l26.858" class="difflineplus">+    Tracev((stderr, &quot;\nlit tree: sent %ld&quot;, s-&gt;bits_sent));</span>
<a href="#l26.859"></a><span id="l26.859" class="difflineplus">+</span>
<a href="#l26.860"></a><span id="l26.860" class="difflineplus">+    send_tree(s, (ct_data *)s-&gt;dyn_dtree, dcodes-1); /* distance tree */</span>
<a href="#l26.861"></a><span id="l26.861" class="difflineplus">+    Tracev((stderr, &quot;\ndist tree: sent %ld&quot;, s-&gt;bits_sent));</span>
<a href="#l26.862"></a><span id="l26.862" class="difflineplus">+}</span>
<a href="#l26.863"></a><span id="l26.863" class="difflineplus">+</span>
<a href="#l26.864"></a><span id="l26.864" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.865"></a><span id="l26.865" class="difflineplus">+ * Send a stored block</span>
<a href="#l26.866"></a><span id="l26.866" class="difflineplus">+ */</span>
<a href="#l26.867"></a><span id="l26.867" class="difflineplus">+void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)</span>
<a href="#l26.868"></a><span id="l26.868" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.869"></a><span id="l26.869" class="difflineplus">+    charf *buf;       /* input block */</span>
<a href="#l26.870"></a><span id="l26.870" class="difflineplus">+    ulg stored_len;   /* length of input block */</span>
<a href="#l26.871"></a><span id="l26.871" class="difflineplus">+    int last;         /* one if this is the last block for a file */</span>
<a href="#l26.872"></a><span id="l26.872" class="difflineplus">+{</span>
<a href="#l26.873"></a><span id="l26.873" class="difflineplus">+    send_bits(s, (STORED_BLOCK&lt;&lt;1)+last, 3);    /* send block type */</span>
<a href="#l26.874"></a><span id="l26.874" class="difflineplus">+    bi_windup(s);        /* align on byte boundary */</span>
<a href="#l26.875"></a><span id="l26.875" class="difflineplus">+    put_short(s, (ush)stored_len);</span>
<a href="#l26.876"></a><span id="l26.876" class="difflineplus">+    put_short(s, (ush)~stored_len);</span>
<a href="#l26.877"></a><span id="l26.877" class="difflineplus">+    zmemcpy(s-&gt;pending_buf + s-&gt;pending, (Bytef *)buf, stored_len);</span>
<a href="#l26.878"></a><span id="l26.878" class="difflineplus">+    s-&gt;pending += stored_len;</span>
<a href="#l26.879"></a><span id="l26.879" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l26.880"></a><span id="l26.880" class="difflineplus">+    s-&gt;compressed_len = (s-&gt;compressed_len + 3 + 7) &amp; (ulg)~7L;</span>
<a href="#l26.881"></a><span id="l26.881" class="difflineplus">+    s-&gt;compressed_len += (stored_len + 4) &lt;&lt; 3;</span>
<a href="#l26.882"></a><span id="l26.882" class="difflineplus">+    s-&gt;bits_sent += 2*16;</span>
<a href="#l26.883"></a><span id="l26.883" class="difflineplus">+    s-&gt;bits_sent += stored_len&lt;&lt;3;</span>
<a href="#l26.884"></a><span id="l26.884" class="difflineplus">+#endif</span>
<a href="#l26.885"></a><span id="l26.885" class="difflineplus">+}</span>
<a href="#l26.886"></a><span id="l26.886" class="difflineplus">+</span>
<a href="#l26.887"></a><span id="l26.887" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.888"></a><span id="l26.888" class="difflineplus">+ * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)</span>
<a href="#l26.889"></a><span id="l26.889" class="difflineplus">+ */</span>
<a href="#l26.890"></a><span id="l26.890" class="difflineplus">+void ZLIB_INTERNAL _tr_flush_bits(s)</span>
<a href="#l26.891"></a><span id="l26.891" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.892"></a><span id="l26.892" class="difflineplus">+{</span>
<a href="#l26.893"></a><span id="l26.893" class="difflineplus">+    bi_flush(s);</span>
<a href="#l26.894"></a><span id="l26.894" class="difflineplus">+}</span>
<a href="#l26.895"></a><span id="l26.895" class="difflineplus">+</span>
<a href="#l26.896"></a><span id="l26.896" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.897"></a><span id="l26.897" class="difflineplus">+ * Send one empty static block to give enough lookahead for inflate.</span>
<a href="#l26.898"></a><span id="l26.898" class="difflineplus">+ * This takes 10 bits, of which 7 may remain in the bit buffer.</span>
<a href="#l26.899"></a><span id="l26.899" class="difflineplus">+ */</span>
<a href="#l26.900"></a><span id="l26.900" class="difflineplus">+void ZLIB_INTERNAL _tr_align(s)</span>
<a href="#l26.901"></a><span id="l26.901" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.902"></a><span id="l26.902" class="difflineplus">+{</span>
<a href="#l26.903"></a><span id="l26.903" class="difflineplus">+    send_bits(s, STATIC_TREES&lt;&lt;1, 3);</span>
<a href="#l26.904"></a><span id="l26.904" class="difflineplus">+    send_code(s, END_BLOCK, static_ltree);</span>
<a href="#l26.905"></a><span id="l26.905" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l26.906"></a><span id="l26.906" class="difflineplus">+    s-&gt;compressed_len += 10L; /* 3 for block type, 7 for EOB */</span>
<a href="#l26.907"></a><span id="l26.907" class="difflineplus">+#endif</span>
<a href="#l26.908"></a><span id="l26.908" class="difflineplus">+    bi_flush(s);</span>
<a href="#l26.909"></a><span id="l26.909" class="difflineplus">+}</span>
<a href="#l26.910"></a><span id="l26.910" class="difflineplus">+</span>
<a href="#l26.911"></a><span id="l26.911" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.912"></a><span id="l26.912" class="difflineplus">+ * Determine the best encoding for the current block: dynamic trees, static</span>
<a href="#l26.913"></a><span id="l26.913" class="difflineplus">+ * trees or store, and write out the encoded block.</span>
<a href="#l26.914"></a><span id="l26.914" class="difflineplus">+ */</span>
<a href="#l26.915"></a><span id="l26.915" class="difflineplus">+void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)</span>
<a href="#l26.916"></a><span id="l26.916" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.917"></a><span id="l26.917" class="difflineplus">+    charf *buf;       /* input block, or NULL if too old */</span>
<a href="#l26.918"></a><span id="l26.918" class="difflineplus">+    ulg stored_len;   /* length of input block */</span>
<a href="#l26.919"></a><span id="l26.919" class="difflineplus">+    int last;         /* one if this is the last block for a file */</span>
<a href="#l26.920"></a><span id="l26.920" class="difflineplus">+{</span>
<a href="#l26.921"></a><span id="l26.921" class="difflineplus">+    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */</span>
<a href="#l26.922"></a><span id="l26.922" class="difflineplus">+    int max_blindex = 0;  /* index of last bit length code of non zero freq */</span>
<a href="#l26.923"></a><span id="l26.923" class="difflineplus">+</span>
<a href="#l26.924"></a><span id="l26.924" class="difflineplus">+    /* Build the Huffman trees unless a stored block is forced */</span>
<a href="#l26.925"></a><span id="l26.925" class="difflineplus">+    if (s-&gt;level &gt; 0) {</span>
<a href="#l26.926"></a><span id="l26.926" class="difflineplus">+</span>
<a href="#l26.927"></a><span id="l26.927" class="difflineplus">+        /* Check if the file is binary or text */</span>
<a href="#l26.928"></a><span id="l26.928" class="difflineplus">+        if (s-&gt;strm-&gt;data_type == Z_UNKNOWN)</span>
<a href="#l26.929"></a><span id="l26.929" class="difflineplus">+            s-&gt;strm-&gt;data_type = detect_data_type(s);</span>
<a href="#l26.930"></a><span id="l26.930" class="difflineplus">+</span>
<a href="#l26.931"></a><span id="l26.931" class="difflineplus">+        /* Construct the literal and distance trees */</span>
<a href="#l26.932"></a><span id="l26.932" class="difflineplus">+        build_tree(s, (tree_desc *)(&amp;(s-&gt;l_desc)));</span>
<a href="#l26.933"></a><span id="l26.933" class="difflineplus">+        Tracev((stderr, &quot;\nlit data: dyn %ld, stat %ld&quot;, s-&gt;opt_len,</span>
<a href="#l26.934"></a><span id="l26.934" class="difflineplus">+                s-&gt;static_len));</span>
<a href="#l26.935"></a><span id="l26.935" class="difflineplus">+</span>
<a href="#l26.936"></a><span id="l26.936" class="difflineplus">+        build_tree(s, (tree_desc *)(&amp;(s-&gt;d_desc)));</span>
<a href="#l26.937"></a><span id="l26.937" class="difflineplus">+        Tracev((stderr, &quot;\ndist data: dyn %ld, stat %ld&quot;, s-&gt;opt_len,</span>
<a href="#l26.938"></a><span id="l26.938" class="difflineplus">+                s-&gt;static_len));</span>
<a href="#l26.939"></a><span id="l26.939" class="difflineplus">+        /* At this point, opt_len and static_len are the total bit lengths of</span>
<a href="#l26.940"></a><span id="l26.940" class="difflineplus">+         * the compressed block data, excluding the tree representations.</span>
<a href="#l26.941"></a><span id="l26.941" class="difflineplus">+         */</span>
<a href="#l26.942"></a><span id="l26.942" class="difflineplus">+</span>
<a href="#l26.943"></a><span id="l26.943" class="difflineplus">+        /* Build the bit length tree for the above two trees, and get the index</span>
<a href="#l26.944"></a><span id="l26.944" class="difflineplus">+         * in bl_order of the last bit length code to send.</span>
<a href="#l26.945"></a><span id="l26.945" class="difflineplus">+         */</span>
<a href="#l26.946"></a><span id="l26.946" class="difflineplus">+        max_blindex = build_bl_tree(s);</span>
<a href="#l26.947"></a><span id="l26.947" class="difflineplus">+</span>
<a href="#l26.948"></a><span id="l26.948" class="difflineplus">+        /* Determine the best encoding. Compute the block lengths in bytes. */</span>
<a href="#l26.949"></a><span id="l26.949" class="difflineplus">+        opt_lenb = (s-&gt;opt_len+3+7)&gt;&gt;3;</span>
<a href="#l26.950"></a><span id="l26.950" class="difflineplus">+        static_lenb = (s-&gt;static_len+3+7)&gt;&gt;3;</span>
<a href="#l26.951"></a><span id="l26.951" class="difflineplus">+</span>
<a href="#l26.952"></a><span id="l26.952" class="difflineplus">+        Tracev((stderr, &quot;\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u &quot;,</span>
<a href="#l26.953"></a><span id="l26.953" class="difflineplus">+                opt_lenb, s-&gt;opt_len, static_lenb, s-&gt;static_len, stored_len,</span>
<a href="#l26.954"></a><span id="l26.954" class="difflineplus">+                s-&gt;last_lit));</span>
<a href="#l26.955"></a><span id="l26.955" class="difflineplus">+</span>
<a href="#l26.956"></a><span id="l26.956" class="difflineplus">+        if (static_lenb &lt;= opt_lenb) opt_lenb = static_lenb;</span>
<a href="#l26.957"></a><span id="l26.957" class="difflineplus">+</span>
<a href="#l26.958"></a><span id="l26.958" class="difflineplus">+    } else {</span>
<a href="#l26.959"></a><span id="l26.959" class="difflineplus">+        Assert(buf != (char*)0, &quot;lost buf&quot;);</span>
<a href="#l26.960"></a><span id="l26.960" class="difflineplus">+        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */</span>
<a href="#l26.961"></a><span id="l26.961" class="difflineplus">+    }</span>
<a href="#l26.962"></a><span id="l26.962" class="difflineplus">+</span>
<a href="#l26.963"></a><span id="l26.963" class="difflineplus">+#ifdef FORCE_STORED</span>
<a href="#l26.964"></a><span id="l26.964" class="difflineplus">+    if (buf != (char*)0) { /* force stored block */</span>
<a href="#l26.965"></a><span id="l26.965" class="difflineplus">+#else</span>
<a href="#l26.966"></a><span id="l26.966" class="difflineplus">+    if (stored_len+4 &lt;= opt_lenb &amp;&amp; buf != (char*)0) {</span>
<a href="#l26.967"></a><span id="l26.967" class="difflineplus">+                       /* 4: two words for the lengths */</span>
<a href="#l26.968"></a><span id="l26.968" class="difflineplus">+#endif</span>
<a href="#l26.969"></a><span id="l26.969" class="difflineplus">+        /* The test buf != NULL is only necessary if LIT_BUFSIZE &gt; WSIZE.</span>
<a href="#l26.970"></a><span id="l26.970" class="difflineplus">+         * Otherwise we can't have processed more than WSIZE input bytes since</span>
<a href="#l26.971"></a><span id="l26.971" class="difflineplus">+         * the last block flush, because compression would have been</span>
<a href="#l26.972"></a><span id="l26.972" class="difflineplus">+         * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to</span>
<a href="#l26.973"></a><span id="l26.973" class="difflineplus">+         * transform a block into a stored block.</span>
<a href="#l26.974"></a><span id="l26.974" class="difflineplus">+         */</span>
<a href="#l26.975"></a><span id="l26.975" class="difflineplus">+        _tr_stored_block(s, buf, stored_len, last);</span>
<a href="#l26.976"></a><span id="l26.976" class="difflineplus">+</span>
<a href="#l26.977"></a><span id="l26.977" class="difflineplus">+#ifdef FORCE_STATIC</span>
<a href="#l26.978"></a><span id="l26.978" class="difflineplus">+    } else if (static_lenb &gt;= 0) { /* force static trees */</span>
<a href="#l26.979"></a><span id="l26.979" class="difflineplus">+#else</span>
<a href="#l26.980"></a><span id="l26.980" class="difflineplus">+    } else if (s-&gt;strategy == Z_FIXED || static_lenb == opt_lenb) {</span>
<a href="#l26.981"></a><span id="l26.981" class="difflineplus">+#endif</span>
<a href="#l26.982"></a><span id="l26.982" class="difflineplus">+        send_bits(s, (STATIC_TREES&lt;&lt;1)+last, 3);</span>
<a href="#l26.983"></a><span id="l26.983" class="difflineplus">+        compress_block(s, (const ct_data *)static_ltree,</span>
<a href="#l26.984"></a><span id="l26.984" class="difflineplus">+                       (const ct_data *)static_dtree);</span>
<a href="#l26.985"></a><span id="l26.985" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l26.986"></a><span id="l26.986" class="difflineplus">+        s-&gt;compressed_len += 3 + s-&gt;static_len;</span>
<a href="#l26.987"></a><span id="l26.987" class="difflineplus">+#endif</span>
<a href="#l26.988"></a><span id="l26.988" class="difflineplus">+    } else {</span>
<a href="#l26.989"></a><span id="l26.989" class="difflineplus">+        send_bits(s, (DYN_TREES&lt;&lt;1)+last, 3);</span>
<a href="#l26.990"></a><span id="l26.990" class="difflineplus">+        send_all_trees(s, s-&gt;l_desc.max_code+1, s-&gt;d_desc.max_code+1,</span>
<a href="#l26.991"></a><span id="l26.991" class="difflineplus">+                       max_blindex+1);</span>
<a href="#l26.992"></a><span id="l26.992" class="difflineplus">+        compress_block(s, (const ct_data *)s-&gt;dyn_ltree,</span>
<a href="#l26.993"></a><span id="l26.993" class="difflineplus">+                       (const ct_data *)s-&gt;dyn_dtree);</span>
<a href="#l26.994"></a><span id="l26.994" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l26.995"></a><span id="l26.995" class="difflineplus">+        s-&gt;compressed_len += 3 + s-&gt;opt_len;</span>
<a href="#l26.996"></a><span id="l26.996" class="difflineplus">+#endif</span>
<a href="#l26.997"></a><span id="l26.997" class="difflineplus">+    }</span>
<a href="#l26.998"></a><span id="l26.998" class="difflineplus">+    Assert (s-&gt;compressed_len == s-&gt;bits_sent, &quot;bad compressed size&quot;);</span>
<a href="#l26.999"></a><span id="l26.999" class="difflineplus">+    /* The above check is made mod 2^32, for files larger than 512 MB</span>
<a href="#l26.1000"></a><span id="l26.1000" class="difflineplus">+     * and uLong implemented on 32 bits.</span>
<a href="#l26.1001"></a><span id="l26.1001" class="difflineplus">+     */</span>
<a href="#l26.1002"></a><span id="l26.1002" class="difflineplus">+    init_block(s);</span>
<a href="#l26.1003"></a><span id="l26.1003" class="difflineplus">+</span>
<a href="#l26.1004"></a><span id="l26.1004" class="difflineplus">+    if (last) {</span>
<a href="#l26.1005"></a><span id="l26.1005" class="difflineplus">+        bi_windup(s);</span>
<a href="#l26.1006"></a><span id="l26.1006" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l26.1007"></a><span id="l26.1007" class="difflineplus">+        s-&gt;compressed_len += 7;  /* align on byte boundary */</span>
<a href="#l26.1008"></a><span id="l26.1008" class="difflineplus">+#endif</span>
<a href="#l26.1009"></a><span id="l26.1009" class="difflineplus">+    }</span>
<a href="#l26.1010"></a><span id="l26.1010" class="difflineplus">+    Tracev((stderr,&quot;\ncomprlen %lu(%lu) &quot;, s-&gt;compressed_len&gt;&gt;3,</span>
<a href="#l26.1011"></a><span id="l26.1011" class="difflineplus">+           s-&gt;compressed_len-7*last));</span>
<a href="#l26.1012"></a><span id="l26.1012" class="difflineplus">+}</span>
<a href="#l26.1013"></a><span id="l26.1013" class="difflineplus">+</span>
<a href="#l26.1014"></a><span id="l26.1014" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.1015"></a><span id="l26.1015" class="difflineplus">+ * Save the match info and tally the frequency counts. Return true if</span>
<a href="#l26.1016"></a><span id="l26.1016" class="difflineplus">+ * the current block must be flushed.</span>
<a href="#l26.1017"></a><span id="l26.1017" class="difflineplus">+ */</span>
<a href="#l26.1018"></a><span id="l26.1018" class="difflineplus">+int ZLIB_INTERNAL _tr_tally (s, dist, lc)</span>
<a href="#l26.1019"></a><span id="l26.1019" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.1020"></a><span id="l26.1020" class="difflineplus">+    unsigned dist;  /* distance of matched string */</span>
<a href="#l26.1021"></a><span id="l26.1021" class="difflineplus">+    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */</span>
<a href="#l26.1022"></a><span id="l26.1022" class="difflineplus">+{</span>
<a href="#l26.1023"></a><span id="l26.1023" class="difflineplus">+    s-&gt;d_buf[s-&gt;last_lit] = (ush)dist;</span>
<a href="#l26.1024"></a><span id="l26.1024" class="difflineplus">+    s-&gt;l_buf[s-&gt;last_lit++] = (uch)lc;</span>
<a href="#l26.1025"></a><span id="l26.1025" class="difflineplus">+    if (dist == 0) {</span>
<a href="#l26.1026"></a><span id="l26.1026" class="difflineplus">+        /* lc is the unmatched char */</span>
<a href="#l26.1027"></a><span id="l26.1027" class="difflineplus">+        s-&gt;dyn_ltree[lc].Freq++;</span>
<a href="#l26.1028"></a><span id="l26.1028" class="difflineplus">+    } else {</span>
<a href="#l26.1029"></a><span id="l26.1029" class="difflineplus">+        s-&gt;matches++;</span>
<a href="#l26.1030"></a><span id="l26.1030" class="difflineplus">+        /* Here, lc is the match length - MIN_MATCH */</span>
<a href="#l26.1031"></a><span id="l26.1031" class="difflineplus">+        dist--;             /* dist = match distance - 1 */</span>
<a href="#l26.1032"></a><span id="l26.1032" class="difflineplus">+        Assert((ush)dist &lt; (ush)MAX_DIST(s) &amp;&amp;</span>
<a href="#l26.1033"></a><span id="l26.1033" class="difflineplus">+               (ush)lc &lt;= (ush)(MAX_MATCH-MIN_MATCH) &amp;&amp;</span>
<a href="#l26.1034"></a><span id="l26.1034" class="difflineplus">+               (ush)d_code(dist) &lt; (ush)D_CODES,  &quot;_tr_tally: bad match&quot;);</span>
<a href="#l26.1035"></a><span id="l26.1035" class="difflineplus">+</span>
<a href="#l26.1036"></a><span id="l26.1036" class="difflineplus">+        s-&gt;dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;</span>
<a href="#l26.1037"></a><span id="l26.1037" class="difflineplus">+        s-&gt;dyn_dtree[d_code(dist)].Freq++;</span>
<a href="#l26.1038"></a><span id="l26.1038" class="difflineplus">+    }</span>
<a href="#l26.1039"></a><span id="l26.1039" class="difflineplus">+</span>
<a href="#l26.1040"></a><span id="l26.1040" class="difflineplus">+#ifdef TRUNCATE_BLOCK</span>
<a href="#l26.1041"></a><span id="l26.1041" class="difflineplus">+    /* Try to guess if it is profitable to stop the current block here */</span>
<a href="#l26.1042"></a><span id="l26.1042" class="difflineplus">+    if ((s-&gt;last_lit &amp; 0x1fff) == 0 &amp;&amp; s-&gt;level &gt; 2) {</span>
<a href="#l26.1043"></a><span id="l26.1043" class="difflineplus">+        /* Compute an upper bound for the compressed length */</span>
<a href="#l26.1044"></a><span id="l26.1044" class="difflineplus">+        ulg out_length = (ulg)s-&gt;last_lit*8L;</span>
<a href="#l26.1045"></a><span id="l26.1045" class="difflineplus">+        ulg in_length = (ulg)((long)s-&gt;strstart - s-&gt;block_start);</span>
<a href="#l26.1046"></a><span id="l26.1046" class="difflineplus">+        int dcode;</span>
<a href="#l26.1047"></a><span id="l26.1047" class="difflineplus">+        for (dcode = 0; dcode &lt; D_CODES; dcode++) {</span>
<a href="#l26.1048"></a><span id="l26.1048" class="difflineplus">+            out_length += (ulg)s-&gt;dyn_dtree[dcode].Freq *</span>
<a href="#l26.1049"></a><span id="l26.1049" class="difflineplus">+                (5L+extra_dbits[dcode]);</span>
<a href="#l26.1050"></a><span id="l26.1050" class="difflineplus">+        }</span>
<a href="#l26.1051"></a><span id="l26.1051" class="difflineplus">+        out_length &gt;&gt;= 3;</span>
<a href="#l26.1052"></a><span id="l26.1052" class="difflineplus">+        Tracev((stderr,&quot;\nlast_lit %u, in %ld, out ~%ld(%ld%%) &quot;,</span>
<a href="#l26.1053"></a><span id="l26.1053" class="difflineplus">+               s-&gt;last_lit, in_length, out_length,</span>
<a href="#l26.1054"></a><span id="l26.1054" class="difflineplus">+               100L - out_length*100L/in_length));</span>
<a href="#l26.1055"></a><span id="l26.1055" class="difflineplus">+        if (s-&gt;matches &lt; s-&gt;last_lit/2 &amp;&amp; out_length &lt; in_length/2) return 1;</span>
<a href="#l26.1056"></a><span id="l26.1056" class="difflineplus">+    }</span>
<a href="#l26.1057"></a><span id="l26.1057" class="difflineplus">+#endif</span>
<a href="#l26.1058"></a><span id="l26.1058" class="difflineplus">+    return (s-&gt;last_lit == s-&gt;lit_bufsize-1);</span>
<a href="#l26.1059"></a><span id="l26.1059" class="difflineplus">+    /* We avoid equality with lit_bufsize because of wraparound at 64K</span>
<a href="#l26.1060"></a><span id="l26.1060" class="difflineplus">+     * on 16 bit machines and because stored blocks are restricted to</span>
<a href="#l26.1061"></a><span id="l26.1061" class="difflineplus">+     * 64K-1 bytes.</span>
<a href="#l26.1062"></a><span id="l26.1062" class="difflineplus">+     */</span>
<a href="#l26.1063"></a><span id="l26.1063" class="difflineplus">+}</span>
<a href="#l26.1064"></a><span id="l26.1064" class="difflineplus">+</span>
<a href="#l26.1065"></a><span id="l26.1065" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.1066"></a><span id="l26.1066" class="difflineplus">+ * Send the block data compressed using the given Huffman trees</span>
<a href="#l26.1067"></a><span id="l26.1067" class="difflineplus">+ */</span>
<a href="#l26.1068"></a><span id="l26.1068" class="difflineplus">+local void compress_block(s, ltree, dtree)</span>
<a href="#l26.1069"></a><span id="l26.1069" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.1070"></a><span id="l26.1070" class="difflineplus">+    const ct_data *ltree; /* literal tree */</span>
<a href="#l26.1071"></a><span id="l26.1071" class="difflineplus">+    const ct_data *dtree; /* distance tree */</span>
<a href="#l26.1072"></a><span id="l26.1072" class="difflineplus">+{</span>
<a href="#l26.1073"></a><span id="l26.1073" class="difflineplus">+    unsigned dist;      /* distance of matched string */</span>
<a href="#l26.1074"></a><span id="l26.1074" class="difflineplus">+    int lc;             /* match length or unmatched char (if dist == 0) */</span>
<a href="#l26.1075"></a><span id="l26.1075" class="difflineplus">+    unsigned lx = 0;    /* running index in l_buf */</span>
<a href="#l26.1076"></a><span id="l26.1076" class="difflineplus">+    unsigned code;      /* the code to send */</span>
<a href="#l26.1077"></a><span id="l26.1077" class="difflineplus">+    int extra;          /* number of extra bits to send */</span>
<a href="#l26.1078"></a><span id="l26.1078" class="difflineplus">+</span>
<a href="#l26.1079"></a><span id="l26.1079" class="difflineplus">+    if (s-&gt;last_lit != 0) do {</span>
<a href="#l26.1080"></a><span id="l26.1080" class="difflineplus">+        dist = s-&gt;d_buf[lx];</span>
<a href="#l26.1081"></a><span id="l26.1081" class="difflineplus">+        lc = s-&gt;l_buf[lx++];</span>
<a href="#l26.1082"></a><span id="l26.1082" class="difflineplus">+        if (dist == 0) {</span>
<a href="#l26.1083"></a><span id="l26.1083" class="difflineplus">+            send_code(s, lc, ltree); /* send a literal byte */</span>
<a href="#l26.1084"></a><span id="l26.1084" class="difflineplus">+            Tracecv(isgraph(lc), (stderr,&quot; '%c' &quot;, lc));</span>
<a href="#l26.1085"></a><span id="l26.1085" class="difflineplus">+        } else {</span>
<a href="#l26.1086"></a><span id="l26.1086" class="difflineplus">+            /* Here, lc is the match length - MIN_MATCH */</span>
<a href="#l26.1087"></a><span id="l26.1087" class="difflineplus">+            code = _length_code[lc];</span>
<a href="#l26.1088"></a><span id="l26.1088" class="difflineplus">+            send_code(s, code+LITERALS+1, ltree); /* send the length code */</span>
<a href="#l26.1089"></a><span id="l26.1089" class="difflineplus">+            extra = extra_lbits[code];</span>
<a href="#l26.1090"></a><span id="l26.1090" class="difflineplus">+            if (extra != 0) {</span>
<a href="#l26.1091"></a><span id="l26.1091" class="difflineplus">+                lc -= base_length[code];</span>
<a href="#l26.1092"></a><span id="l26.1092" class="difflineplus">+                send_bits(s, lc, extra);       /* send the extra length bits */</span>
<a href="#l26.1093"></a><span id="l26.1093" class="difflineplus">+            }</span>
<a href="#l26.1094"></a><span id="l26.1094" class="difflineplus">+            dist--; /* dist is now the match distance - 1 */</span>
<a href="#l26.1095"></a><span id="l26.1095" class="difflineplus">+            code = d_code(dist);</span>
<a href="#l26.1096"></a><span id="l26.1096" class="difflineplus">+            Assert (code &lt; D_CODES, &quot;bad d_code&quot;);</span>
<a href="#l26.1097"></a><span id="l26.1097" class="difflineplus">+</span>
<a href="#l26.1098"></a><span id="l26.1098" class="difflineplus">+            send_code(s, code, dtree);       /* send the distance code */</span>
<a href="#l26.1099"></a><span id="l26.1099" class="difflineplus">+            extra = extra_dbits[code];</span>
<a href="#l26.1100"></a><span id="l26.1100" class="difflineplus">+            if (extra != 0) {</span>
<a href="#l26.1101"></a><span id="l26.1101" class="difflineplus">+                dist -= (unsigned)base_dist[code];</span>
<a href="#l26.1102"></a><span id="l26.1102" class="difflineplus">+                send_bits(s, dist, extra);   /* send the extra distance bits */</span>
<a href="#l26.1103"></a><span id="l26.1103" class="difflineplus">+            }</span>
<a href="#l26.1104"></a><span id="l26.1104" class="difflineplus">+        } /* literal or match pair ? */</span>
<a href="#l26.1105"></a><span id="l26.1105" class="difflineplus">+</span>
<a href="#l26.1106"></a><span id="l26.1106" class="difflineplus">+        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */</span>
<a href="#l26.1107"></a><span id="l26.1107" class="difflineplus">+        Assert((uInt)(s-&gt;pending) &lt; s-&gt;lit_bufsize + 2*lx,</span>
<a href="#l26.1108"></a><span id="l26.1108" class="difflineplus">+               &quot;pendingBuf overflow&quot;);</span>
<a href="#l26.1109"></a><span id="l26.1109" class="difflineplus">+</span>
<a href="#l26.1110"></a><span id="l26.1110" class="difflineplus">+    } while (lx &lt; s-&gt;last_lit);</span>
<a href="#l26.1111"></a><span id="l26.1111" class="difflineplus">+</span>
<a href="#l26.1112"></a><span id="l26.1112" class="difflineplus">+    send_code(s, END_BLOCK, ltree);</span>
<a href="#l26.1113"></a><span id="l26.1113" class="difflineplus">+}</span>
<a href="#l26.1114"></a><span id="l26.1114" class="difflineplus">+</span>
<a href="#l26.1115"></a><span id="l26.1115" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.1116"></a><span id="l26.1116" class="difflineplus">+ * Check if the data type is TEXT or BINARY, using the following algorithm:</span>
<a href="#l26.1117"></a><span id="l26.1117" class="difflineplus">+ * - TEXT if the two conditions below are satisfied:</span>
<a href="#l26.1118"></a><span id="l26.1118" class="difflineplus">+ *    a) There are no non-portable control characters belonging to the</span>
<a href="#l26.1119"></a><span id="l26.1119" class="difflineplus">+ *       &quot;black list&quot; (0..6, 14..25, 28..31).</span>
<a href="#l26.1120"></a><span id="l26.1120" class="difflineplus">+ *    b) There is at least one printable character belonging to the</span>
<a href="#l26.1121"></a><span id="l26.1121" class="difflineplus">+ *       &quot;white list&quot; (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).</span>
<a href="#l26.1122"></a><span id="l26.1122" class="difflineplus">+ * - BINARY otherwise.</span>
<a href="#l26.1123"></a><span id="l26.1123" class="difflineplus">+ * - The following partially-portable control characters form a</span>
<a href="#l26.1124"></a><span id="l26.1124" class="difflineplus">+ *   &quot;gray list&quot; that is ignored in this detection algorithm:</span>
<a href="#l26.1125"></a><span id="l26.1125" class="difflineplus">+ *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).</span>
<a href="#l26.1126"></a><span id="l26.1126" class="difflineplus">+ * IN assertion: the fields Freq of dyn_ltree are set.</span>
<a href="#l26.1127"></a><span id="l26.1127" class="difflineplus">+ */</span>
<a href="#l26.1128"></a><span id="l26.1128" class="difflineplus">+local int detect_data_type(s)</span>
<a href="#l26.1129"></a><span id="l26.1129" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.1130"></a><span id="l26.1130" class="difflineplus">+{</span>
<a href="#l26.1131"></a><span id="l26.1131" class="difflineplus">+    /* black_mask is the bit mask of black-listed bytes</span>
<a href="#l26.1132"></a><span id="l26.1132" class="difflineplus">+     * set bits 0..6, 14..25, and 28..31</span>
<a href="#l26.1133"></a><span id="l26.1133" class="difflineplus">+     * 0xf3ffc07f = binary 11110011111111111100000001111111</span>
<a href="#l26.1134"></a><span id="l26.1134" class="difflineplus">+     */</span>
<a href="#l26.1135"></a><span id="l26.1135" class="difflineplus">+    unsigned long black_mask = 0xf3ffc07fUL;</span>
<a href="#l26.1136"></a><span id="l26.1136" class="difflineplus">+    int n;</span>
<a href="#l26.1137"></a><span id="l26.1137" class="difflineplus">+</span>
<a href="#l26.1138"></a><span id="l26.1138" class="difflineplus">+    /* Check for non-textual (&quot;black-listed&quot;) bytes. */</span>
<a href="#l26.1139"></a><span id="l26.1139" class="difflineplus">+    for (n = 0; n &lt;= 31; n++, black_mask &gt;&gt;= 1)</span>
<a href="#l26.1140"></a><span id="l26.1140" class="difflineplus">+        if ((black_mask &amp; 1) &amp;&amp; (s-&gt;dyn_ltree[n].Freq != 0))</span>
<a href="#l26.1141"></a><span id="l26.1141" class="difflineplus">+            return Z_BINARY;</span>
<a href="#l26.1142"></a><span id="l26.1142" class="difflineplus">+</span>
<a href="#l26.1143"></a><span id="l26.1143" class="difflineplus">+    /* Check for textual (&quot;white-listed&quot;) bytes. */</span>
<a href="#l26.1144"></a><span id="l26.1144" class="difflineplus">+    if (s-&gt;dyn_ltree[9].Freq != 0 || s-&gt;dyn_ltree[10].Freq != 0</span>
<a href="#l26.1145"></a><span id="l26.1145" class="difflineplus">+            || s-&gt;dyn_ltree[13].Freq != 0)</span>
<a href="#l26.1146"></a><span id="l26.1146" class="difflineplus">+        return Z_TEXT;</span>
<a href="#l26.1147"></a><span id="l26.1147" class="difflineplus">+    for (n = 32; n &lt; LITERALS; n++)</span>
<a href="#l26.1148"></a><span id="l26.1148" class="difflineplus">+        if (s-&gt;dyn_ltree[n].Freq != 0)</span>
<a href="#l26.1149"></a><span id="l26.1149" class="difflineplus">+            return Z_TEXT;</span>
<a href="#l26.1150"></a><span id="l26.1150" class="difflineplus">+</span>
<a href="#l26.1151"></a><span id="l26.1151" class="difflineplus">+    /* There are no &quot;black-listed&quot; or &quot;white-listed&quot; bytes:</span>
<a href="#l26.1152"></a><span id="l26.1152" class="difflineplus">+     * this stream either is empty or has tolerated (&quot;gray-listed&quot;) bytes only.</span>
<a href="#l26.1153"></a><span id="l26.1153" class="difflineplus">+     */</span>
<a href="#l26.1154"></a><span id="l26.1154" class="difflineplus">+    return Z_BINARY;</span>
<a href="#l26.1155"></a><span id="l26.1155" class="difflineplus">+}</span>
<a href="#l26.1156"></a><span id="l26.1156" class="difflineplus">+</span>
<a href="#l26.1157"></a><span id="l26.1157" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.1158"></a><span id="l26.1158" class="difflineplus">+ * Reverse the first len bits of a code, using straightforward code (a faster</span>
<a href="#l26.1159"></a><span id="l26.1159" class="difflineplus">+ * method would use a table)</span>
<a href="#l26.1160"></a><span id="l26.1160" class="difflineplus">+ * IN assertion: 1 &lt;= len &lt;= 15</span>
<a href="#l26.1161"></a><span id="l26.1161" class="difflineplus">+ */</span>
<a href="#l26.1162"></a><span id="l26.1162" class="difflineplus">+local unsigned bi_reverse(code, len)</span>
<a href="#l26.1163"></a><span id="l26.1163" class="difflineplus">+    unsigned code; /* the value to invert */</span>
<a href="#l26.1164"></a><span id="l26.1164" class="difflineplus">+    int len;       /* its bit length */</span>
<a href="#l26.1165"></a><span id="l26.1165" class="difflineplus">+{</span>
<a href="#l26.1166"></a><span id="l26.1166" class="difflineplus">+    register unsigned res = 0;</span>
<a href="#l26.1167"></a><span id="l26.1167" class="difflineplus">+    do {</span>
<a href="#l26.1168"></a><span id="l26.1168" class="difflineplus">+        res |= code &amp; 1;</span>
<a href="#l26.1169"></a><span id="l26.1169" class="difflineplus">+        code &gt;&gt;= 1, res &lt;&lt;= 1;</span>
<a href="#l26.1170"></a><span id="l26.1170" class="difflineplus">+    } while (--len &gt; 0);</span>
<a href="#l26.1171"></a><span id="l26.1171" class="difflineplus">+    return res &gt;&gt; 1;</span>
<a href="#l26.1172"></a><span id="l26.1172" class="difflineplus">+}</span>
<a href="#l26.1173"></a><span id="l26.1173" class="difflineplus">+</span>
<a href="#l26.1174"></a><span id="l26.1174" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.1175"></a><span id="l26.1175" class="difflineplus">+ * Flush the bit buffer, keeping at most 7 bits in it.</span>
<a href="#l26.1176"></a><span id="l26.1176" class="difflineplus">+ */</span>
<a href="#l26.1177"></a><span id="l26.1177" class="difflineplus">+local void bi_flush(s)</span>
<a href="#l26.1178"></a><span id="l26.1178" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.1179"></a><span id="l26.1179" class="difflineplus">+{</span>
<a href="#l26.1180"></a><span id="l26.1180" class="difflineplus">+    if (s-&gt;bi_valid == 16) {</span>
<a href="#l26.1181"></a><span id="l26.1181" class="difflineplus">+        put_short(s, s-&gt;bi_buf);</span>
<a href="#l26.1182"></a><span id="l26.1182" class="difflineplus">+        s-&gt;bi_buf = 0;</span>
<a href="#l26.1183"></a><span id="l26.1183" class="difflineplus">+        s-&gt;bi_valid = 0;</span>
<a href="#l26.1184"></a><span id="l26.1184" class="difflineplus">+    } else if (s-&gt;bi_valid &gt;= 8) {</span>
<a href="#l26.1185"></a><span id="l26.1185" class="difflineplus">+        put_byte(s, (Byte)s-&gt;bi_buf);</span>
<a href="#l26.1186"></a><span id="l26.1186" class="difflineplus">+        s-&gt;bi_buf &gt;&gt;= 8;</span>
<a href="#l26.1187"></a><span id="l26.1187" class="difflineplus">+        s-&gt;bi_valid -= 8;</span>
<a href="#l26.1188"></a><span id="l26.1188" class="difflineplus">+    }</span>
<a href="#l26.1189"></a><span id="l26.1189" class="difflineplus">+}</span>
<a href="#l26.1190"></a><span id="l26.1190" class="difflineplus">+</span>
<a href="#l26.1191"></a><span id="l26.1191" class="difflineplus">+/* ===========================================================================</span>
<a href="#l26.1192"></a><span id="l26.1192" class="difflineplus">+ * Flush the bit buffer and align the output on a byte boundary</span>
<a href="#l26.1193"></a><span id="l26.1193" class="difflineplus">+ */</span>
<a href="#l26.1194"></a><span id="l26.1194" class="difflineplus">+local void bi_windup(s)</span>
<a href="#l26.1195"></a><span id="l26.1195" class="difflineplus">+    deflate_state *s;</span>
<a href="#l26.1196"></a><span id="l26.1196" class="difflineplus">+{</span>
<a href="#l26.1197"></a><span id="l26.1197" class="difflineplus">+    if (s-&gt;bi_valid &gt; 8) {</span>
<a href="#l26.1198"></a><span id="l26.1198" class="difflineplus">+        put_short(s, s-&gt;bi_buf);</span>
<a href="#l26.1199"></a><span id="l26.1199" class="difflineplus">+    } else if (s-&gt;bi_valid &gt; 0) {</span>
<a href="#l26.1200"></a><span id="l26.1200" class="difflineplus">+        put_byte(s, (Byte)s-&gt;bi_buf);</span>
<a href="#l26.1201"></a><span id="l26.1201" class="difflineplus">+    }</span>
<a href="#l26.1202"></a><span id="l26.1202" class="difflineplus">+    s-&gt;bi_buf = 0;</span>
<a href="#l26.1203"></a><span id="l26.1203" class="difflineplus">+    s-&gt;bi_valid = 0;</span>
<a href="#l26.1204"></a><span id="l26.1204" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l26.1205"></a><span id="l26.1205" class="difflineplus">+    s-&gt;bits_sent = (s-&gt;bits_sent+7) &amp; ~7;</span>
<a href="#l26.1206"></a><span id="l26.1206" class="difflineplus">+#endif</span>
<a href="#l26.1207"></a><span id="l26.1207" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1">new file mode 100644</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineminus">--- /dev/null</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineplus">+++ b/third_party/zlib/trees.h</span>
<a href="#l27.4"></a><span id="l27.4" class="difflineat">@@ -0,0 +1,128 @@</span>
<a href="#l27.5"></a><span id="l27.5" class="difflineplus">+/* header created automatically with -DGEN_TREES_H */</span>
<a href="#l27.6"></a><span id="l27.6" class="difflineplus">+</span>
<a href="#l27.7"></a><span id="l27.7" class="difflineplus">+local const ct_data static_ltree[L_CODES+2] = {</span>
<a href="#l27.8"></a><span id="l27.8" class="difflineplus">+{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},</span>
<a href="#l27.9"></a><span id="l27.9" class="difflineplus">+{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},</span>
<a href="#l27.10"></a><span id="l27.10" class="difflineplus">+{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},</span>
<a href="#l27.11"></a><span id="l27.11" class="difflineplus">+{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},</span>
<a href="#l27.12"></a><span id="l27.12" class="difflineplus">+{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineplus">+{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},</span>
<a href="#l27.14"></a><span id="l27.14" class="difflineplus">+{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},</span>
<a href="#l27.15"></a><span id="l27.15" class="difflineplus">+{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},</span>
<a href="#l27.16"></a><span id="l27.16" class="difflineplus">+{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},</span>
<a href="#l27.17"></a><span id="l27.17" class="difflineplus">+{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},</span>
<a href="#l27.18"></a><span id="l27.18" class="difflineplus">+{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},</span>
<a href="#l27.19"></a><span id="l27.19" class="difflineplus">+{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},</span>
<a href="#l27.20"></a><span id="l27.20" class="difflineplus">+{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},</span>
<a href="#l27.21"></a><span id="l27.21" class="difflineplus">+{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},</span>
<a href="#l27.22"></a><span id="l27.22" class="difflineplus">+{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},</span>
<a href="#l27.23"></a><span id="l27.23" class="difflineplus">+{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},</span>
<a href="#l27.24"></a><span id="l27.24" class="difflineplus">+{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},</span>
<a href="#l27.25"></a><span id="l27.25" class="difflineplus">+{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},</span>
<a href="#l27.26"></a><span id="l27.26" class="difflineplus">+{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},</span>
<a href="#l27.27"></a><span id="l27.27" class="difflineplus">+{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},</span>
<a href="#l27.28"></a><span id="l27.28" class="difflineplus">+{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},</span>
<a href="#l27.29"></a><span id="l27.29" class="difflineplus">+{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},</span>
<a href="#l27.30"></a><span id="l27.30" class="difflineplus">+{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},</span>
<a href="#l27.31"></a><span id="l27.31" class="difflineplus">+{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},</span>
<a href="#l27.32"></a><span id="l27.32" class="difflineplus">+{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},</span>
<a href="#l27.33"></a><span id="l27.33" class="difflineplus">+{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},</span>
<a href="#l27.34"></a><span id="l27.34" class="difflineplus">+{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},</span>
<a href="#l27.35"></a><span id="l27.35" class="difflineplus">+{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},</span>
<a href="#l27.36"></a><span id="l27.36" class="difflineplus">+{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},</span>
<a href="#l27.37"></a><span id="l27.37" class="difflineplus">+{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},</span>
<a href="#l27.38"></a><span id="l27.38" class="difflineplus">+{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},</span>
<a href="#l27.39"></a><span id="l27.39" class="difflineplus">+{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},</span>
<a href="#l27.40"></a><span id="l27.40" class="difflineplus">+{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},</span>
<a href="#l27.41"></a><span id="l27.41" class="difflineplus">+{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},</span>
<a href="#l27.42"></a><span id="l27.42" class="difflineplus">+{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},</span>
<a href="#l27.43"></a><span id="l27.43" class="difflineplus">+{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},</span>
<a href="#l27.44"></a><span id="l27.44" class="difflineplus">+{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},</span>
<a href="#l27.45"></a><span id="l27.45" class="difflineplus">+{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},</span>
<a href="#l27.46"></a><span id="l27.46" class="difflineplus">+{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},</span>
<a href="#l27.47"></a><span id="l27.47" class="difflineplus">+{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},</span>
<a href="#l27.48"></a><span id="l27.48" class="difflineplus">+{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},</span>
<a href="#l27.49"></a><span id="l27.49" class="difflineplus">+{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},</span>
<a href="#l27.50"></a><span id="l27.50" class="difflineplus">+{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},</span>
<a href="#l27.51"></a><span id="l27.51" class="difflineplus">+{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},</span>
<a href="#l27.52"></a><span id="l27.52" class="difflineplus">+{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},</span>
<a href="#l27.53"></a><span id="l27.53" class="difflineplus">+{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},</span>
<a href="#l27.54"></a><span id="l27.54" class="difflineplus">+{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},</span>
<a href="#l27.55"></a><span id="l27.55" class="difflineplus">+{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},</span>
<a href="#l27.56"></a><span id="l27.56" class="difflineplus">+{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},</span>
<a href="#l27.57"></a><span id="l27.57" class="difflineplus">+{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},</span>
<a href="#l27.58"></a><span id="l27.58" class="difflineplus">+{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},</span>
<a href="#l27.59"></a><span id="l27.59" class="difflineplus">+{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},</span>
<a href="#l27.60"></a><span id="l27.60" class="difflineplus">+{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},</span>
<a href="#l27.61"></a><span id="l27.61" class="difflineplus">+{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},</span>
<a href="#l27.62"></a><span id="l27.62" class="difflineplus">+{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},</span>
<a href="#l27.63"></a><span id="l27.63" class="difflineplus">+{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},</span>
<a href="#l27.64"></a><span id="l27.64" class="difflineplus">+{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},</span>
<a href="#l27.65"></a><span id="l27.65" class="difflineplus">+{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}</span>
<a href="#l27.66"></a><span id="l27.66" class="difflineplus">+};</span>
<a href="#l27.67"></a><span id="l27.67" class="difflineplus">+</span>
<a href="#l27.68"></a><span id="l27.68" class="difflineplus">+local const ct_data static_dtree[D_CODES] = {</span>
<a href="#l27.69"></a><span id="l27.69" class="difflineplus">+{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},</span>
<a href="#l27.70"></a><span id="l27.70" class="difflineplus">+{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},</span>
<a href="#l27.71"></a><span id="l27.71" class="difflineplus">+{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},</span>
<a href="#l27.72"></a><span id="l27.72" class="difflineplus">+{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},</span>
<a href="#l27.73"></a><span id="l27.73" class="difflineplus">+{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},</span>
<a href="#l27.74"></a><span id="l27.74" class="difflineplus">+{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}</span>
<a href="#l27.75"></a><span id="l27.75" class="difflineplus">+};</span>
<a href="#l27.76"></a><span id="l27.76" class="difflineplus">+</span>
<a href="#l27.77"></a><span id="l27.77" class="difflineplus">+const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {</span>
<a href="#l27.78"></a><span id="l27.78" class="difflineplus">+ 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,</span>
<a href="#l27.79"></a><span id="l27.79" class="difflineplus">+ 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,</span>
<a href="#l27.80"></a><span id="l27.80" class="difflineplus">+10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,</span>
<a href="#l27.81"></a><span id="l27.81" class="difflineplus">+11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,</span>
<a href="#l27.82"></a><span id="l27.82" class="difflineplus">+12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,</span>
<a href="#l27.83"></a><span id="l27.83" class="difflineplus">+13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,</span>
<a href="#l27.84"></a><span id="l27.84" class="difflineplus">+13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,</span>
<a href="#l27.85"></a><span id="l27.85" class="difflineplus">+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,</span>
<a href="#l27.86"></a><span id="l27.86" class="difflineplus">+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,</span>
<a href="#l27.87"></a><span id="l27.87" class="difflineplus">+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,</span>
<a href="#l27.88"></a><span id="l27.88" class="difflineplus">+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,</span>
<a href="#l27.89"></a><span id="l27.89" class="difflineplus">+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,</span>
<a href="#l27.90"></a><span id="l27.90" class="difflineplus">+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,</span>
<a href="#l27.91"></a><span id="l27.91" class="difflineplus">+18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,</span>
<a href="#l27.92"></a><span id="l27.92" class="difflineplus">+23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,</span>
<a href="#l27.93"></a><span id="l27.93" class="difflineplus">+24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,</span>
<a href="#l27.94"></a><span id="l27.94" class="difflineplus">+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,</span>
<a href="#l27.95"></a><span id="l27.95" class="difflineplus">+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,</span>
<a href="#l27.96"></a><span id="l27.96" class="difflineplus">+27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,</span>
<a href="#l27.97"></a><span id="l27.97" class="difflineplus">+27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,</span>
<a href="#l27.98"></a><span id="l27.98" class="difflineplus">+28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,</span>
<a href="#l27.99"></a><span id="l27.99" class="difflineplus">+28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,</span>
<a href="#l27.100"></a><span id="l27.100" class="difflineplus">+28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,</span>
<a href="#l27.101"></a><span id="l27.101" class="difflineplus">+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,</span>
<a href="#l27.102"></a><span id="l27.102" class="difflineplus">+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,</span>
<a href="#l27.103"></a><span id="l27.103" class="difflineplus">+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29</span>
<a href="#l27.104"></a><span id="l27.104" class="difflineplus">+};</span>
<a href="#l27.105"></a><span id="l27.105" class="difflineplus">+</span>
<a href="#l27.106"></a><span id="l27.106" class="difflineplus">+const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {</span>
<a href="#l27.107"></a><span id="l27.107" class="difflineplus">+ 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,</span>
<a href="#l27.108"></a><span id="l27.108" class="difflineplus">+13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,</span>
<a href="#l27.109"></a><span id="l27.109" class="difflineplus">+17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,</span>
<a href="#l27.110"></a><span id="l27.110" class="difflineplus">+19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,</span>
<a href="#l27.111"></a><span id="l27.111" class="difflineplus">+21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,</span>
<a href="#l27.112"></a><span id="l27.112" class="difflineplus">+22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,</span>
<a href="#l27.113"></a><span id="l27.113" class="difflineplus">+23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,</span>
<a href="#l27.114"></a><span id="l27.114" class="difflineplus">+24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,</span>
<a href="#l27.115"></a><span id="l27.115" class="difflineplus">+25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,</span>
<a href="#l27.116"></a><span id="l27.116" class="difflineplus">+25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,</span>
<a href="#l27.117"></a><span id="l27.117" class="difflineplus">+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,</span>
<a href="#l27.118"></a><span id="l27.118" class="difflineplus">+26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,</span>
<a href="#l27.119"></a><span id="l27.119" class="difflineplus">+27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28</span>
<a href="#l27.120"></a><span id="l27.120" class="difflineplus">+};</span>
<a href="#l27.121"></a><span id="l27.121" class="difflineplus">+</span>
<a href="#l27.122"></a><span id="l27.122" class="difflineplus">+local const int base_length[LENGTH_CODES] = {</span>
<a href="#l27.123"></a><span id="l27.123" class="difflineplus">+0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,</span>
<a href="#l27.124"></a><span id="l27.124" class="difflineplus">+64, 80, 96, 112, 128, 160, 192, 224, 0</span>
<a href="#l27.125"></a><span id="l27.125" class="difflineplus">+};</span>
<a href="#l27.126"></a><span id="l27.126" class="difflineplus">+</span>
<a href="#l27.127"></a><span id="l27.127" class="difflineplus">+local const int base_dist[D_CODES] = {</span>
<a href="#l27.128"></a><span id="l27.128" class="difflineplus">+    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,</span>
<a href="#l27.129"></a><span id="l27.129" class="difflineplus">+   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,</span>
<a href="#l27.130"></a><span id="l27.130" class="difflineplus">+ 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576</span>
<a href="#l27.131"></a><span id="l27.131" class="difflineplus">+};</span>
<a href="#l27.132"></a><span id="l27.132" class="difflineplus">+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1">new file mode 100644</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineminus">--- /dev/null</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineplus">+++ b/third_party/zlib/uncompr.c</span>
<a href="#l28.4"></a><span id="l28.4" class="difflineat">@@ -0,0 +1,93 @@</span>
<a href="#l28.5"></a><span id="l28.5" class="difflineplus">+/* uncompr.c -- decompress a memory buffer</span>
<a href="#l28.6"></a><span id="l28.6" class="difflineplus">+ * Copyright (C) 1995-2003, 2010, 2014, 2016 Jean-loup Gailly, Mark Adler</span>
<a href="#l28.7"></a><span id="l28.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l28.8"></a><span id="l28.8" class="difflineplus">+ */</span>
<a href="#l28.9"></a><span id="l28.9" class="difflineplus">+</span>
<a href="#l28.10"></a><span id="l28.10" class="difflineplus">+/* @(#) $Id$ */</span>
<a href="#l28.11"></a><span id="l28.11" class="difflineplus">+</span>
<a href="#l28.12"></a><span id="l28.12" class="difflineplus">+#define ZLIB_INTERNAL</span>
<a href="#l28.13"></a><span id="l28.13" class="difflineplus">+#include &quot;zlib.h&quot;</span>
<a href="#l28.14"></a><span id="l28.14" class="difflineplus">+</span>
<a href="#l28.15"></a><span id="l28.15" class="difflineplus">+/* ===========================================================================</span>
<a href="#l28.16"></a><span id="l28.16" class="difflineplus">+     Decompresses the source buffer into the destination buffer.  *sourceLen is</span>
<a href="#l28.17"></a><span id="l28.17" class="difflineplus">+   the byte length of the source buffer. Upon entry, *destLen is the total size</span>
<a href="#l28.18"></a><span id="l28.18" class="difflineplus">+   of the destination buffer, which must be large enough to hold the entire</span>
<a href="#l28.19"></a><span id="l28.19" class="difflineplus">+   uncompressed data. (The size of the uncompressed data must have been saved</span>
<a href="#l28.20"></a><span id="l28.20" class="difflineplus">+   previously by the compressor and transmitted to the decompressor by some</span>
<a href="#l28.21"></a><span id="l28.21" class="difflineplus">+   mechanism outside the scope of this compression library.) Upon exit,</span>
<a href="#l28.22"></a><span id="l28.22" class="difflineplus">+   *destLen is the size of the decompressed data and *sourceLen is the number</span>
<a href="#l28.23"></a><span id="l28.23" class="difflineplus">+   of source bytes consumed. Upon return, source + *sourceLen points to the</span>
<a href="#l28.24"></a><span id="l28.24" class="difflineplus">+   first unused input byte.</span>
<a href="#l28.25"></a><span id="l28.25" class="difflineplus">+</span>
<a href="#l28.26"></a><span id="l28.26" class="difflineplus">+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
<a href="#l28.27"></a><span id="l28.27" class="difflineplus">+   memory, Z_BUF_ERROR if there was not enough room in the output buffer, or</span>
<a href="#l28.28"></a><span id="l28.28" class="difflineplus">+   Z_DATA_ERROR if the input data was corrupted, including if the input data is</span>
<a href="#l28.29"></a><span id="l28.29" class="difflineplus">+   an incomplete zlib stream.</span>
<a href="#l28.30"></a><span id="l28.30" class="difflineplus">+*/</span>
<a href="#l28.31"></a><span id="l28.31" class="difflineplus">+int ZEXPORT uncompress2 (dest, destLen, source, sourceLen)</span>
<a href="#l28.32"></a><span id="l28.32" class="difflineplus">+    Bytef *dest;</span>
<a href="#l28.33"></a><span id="l28.33" class="difflineplus">+    uLongf *destLen;</span>
<a href="#l28.34"></a><span id="l28.34" class="difflineplus">+    const Bytef *source;</span>
<a href="#l28.35"></a><span id="l28.35" class="difflineplus">+    uLong *sourceLen;</span>
<a href="#l28.36"></a><span id="l28.36" class="difflineplus">+{</span>
<a href="#l28.37"></a><span id="l28.37" class="difflineplus">+    z_stream stream;</span>
<a href="#l28.38"></a><span id="l28.38" class="difflineplus">+    int err;</span>
<a href="#l28.39"></a><span id="l28.39" class="difflineplus">+    const uInt max = (uInt)-1;</span>
<a href="#l28.40"></a><span id="l28.40" class="difflineplus">+    uLong len, left;</span>
<a href="#l28.41"></a><span id="l28.41" class="difflineplus">+    Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */</span>
<a href="#l28.42"></a><span id="l28.42" class="difflineplus">+</span>
<a href="#l28.43"></a><span id="l28.43" class="difflineplus">+    len = *sourceLen;</span>
<a href="#l28.44"></a><span id="l28.44" class="difflineplus">+    if (*destLen) {</span>
<a href="#l28.45"></a><span id="l28.45" class="difflineplus">+        left = *destLen;</span>
<a href="#l28.46"></a><span id="l28.46" class="difflineplus">+        *destLen = 0;</span>
<a href="#l28.47"></a><span id="l28.47" class="difflineplus">+    }</span>
<a href="#l28.48"></a><span id="l28.48" class="difflineplus">+    else {</span>
<a href="#l28.49"></a><span id="l28.49" class="difflineplus">+        left = 1;</span>
<a href="#l28.50"></a><span id="l28.50" class="difflineplus">+        dest = buf;</span>
<a href="#l28.51"></a><span id="l28.51" class="difflineplus">+    }</span>
<a href="#l28.52"></a><span id="l28.52" class="difflineplus">+</span>
<a href="#l28.53"></a><span id="l28.53" class="difflineplus">+    stream.next_in = (z_const Bytef *)source;</span>
<a href="#l28.54"></a><span id="l28.54" class="difflineplus">+    stream.avail_in = 0;</span>
<a href="#l28.55"></a><span id="l28.55" class="difflineplus">+    stream.zalloc = (alloc_func)0;</span>
<a href="#l28.56"></a><span id="l28.56" class="difflineplus">+    stream.zfree = (free_func)0;</span>
<a href="#l28.57"></a><span id="l28.57" class="difflineplus">+    stream.opaque = (voidpf)0;</span>
<a href="#l28.58"></a><span id="l28.58" class="difflineplus">+</span>
<a href="#l28.59"></a><span id="l28.59" class="difflineplus">+    err = inflateInit(&amp;stream);</span>
<a href="#l28.60"></a><span id="l28.60" class="difflineplus">+    if (err != Z_OK) return err;</span>
<a href="#l28.61"></a><span id="l28.61" class="difflineplus">+</span>
<a href="#l28.62"></a><span id="l28.62" class="difflineplus">+    stream.next_out = dest;</span>
<a href="#l28.63"></a><span id="l28.63" class="difflineplus">+    stream.avail_out = 0;</span>
<a href="#l28.64"></a><span id="l28.64" class="difflineplus">+</span>
<a href="#l28.65"></a><span id="l28.65" class="difflineplus">+    do {</span>
<a href="#l28.66"></a><span id="l28.66" class="difflineplus">+        if (stream.avail_out == 0) {</span>
<a href="#l28.67"></a><span id="l28.67" class="difflineplus">+            stream.avail_out = left &gt; (uLong)max ? max : (uInt)left;</span>
<a href="#l28.68"></a><span id="l28.68" class="difflineplus">+            left -= stream.avail_out;</span>
<a href="#l28.69"></a><span id="l28.69" class="difflineplus">+        }</span>
<a href="#l28.70"></a><span id="l28.70" class="difflineplus">+        if (stream.avail_in == 0) {</span>
<a href="#l28.71"></a><span id="l28.71" class="difflineplus">+            stream.avail_in = len &gt; (uLong)max ? max : (uInt)len;</span>
<a href="#l28.72"></a><span id="l28.72" class="difflineplus">+            len -= stream.avail_in;</span>
<a href="#l28.73"></a><span id="l28.73" class="difflineplus">+        }</span>
<a href="#l28.74"></a><span id="l28.74" class="difflineplus">+        err = inflate(&amp;stream, Z_NO_FLUSH);</span>
<a href="#l28.75"></a><span id="l28.75" class="difflineplus">+    } while (err == Z_OK);</span>
<a href="#l28.76"></a><span id="l28.76" class="difflineplus">+</span>
<a href="#l28.77"></a><span id="l28.77" class="difflineplus">+    *sourceLen -= len + stream.avail_in;</span>
<a href="#l28.78"></a><span id="l28.78" class="difflineplus">+    if (dest != buf)</span>
<a href="#l28.79"></a><span id="l28.79" class="difflineplus">+        *destLen = stream.total_out;</span>
<a href="#l28.80"></a><span id="l28.80" class="difflineplus">+    else if (stream.total_out &amp;&amp; err == Z_BUF_ERROR)</span>
<a href="#l28.81"></a><span id="l28.81" class="difflineplus">+        left = 1;</span>
<a href="#l28.82"></a><span id="l28.82" class="difflineplus">+</span>
<a href="#l28.83"></a><span id="l28.83" class="difflineplus">+    inflateEnd(&amp;stream);</span>
<a href="#l28.84"></a><span id="l28.84" class="difflineplus">+    return err == Z_STREAM_END ? Z_OK :</span>
<a href="#l28.85"></a><span id="l28.85" class="difflineplus">+           err == Z_NEED_DICT ? Z_DATA_ERROR  :</span>
<a href="#l28.86"></a><span id="l28.86" class="difflineplus">+           err == Z_BUF_ERROR &amp;&amp; left + stream.avail_out ? Z_DATA_ERROR :</span>
<a href="#l28.87"></a><span id="l28.87" class="difflineplus">+           err;</span>
<a href="#l28.88"></a><span id="l28.88" class="difflineplus">+}</span>
<a href="#l28.89"></a><span id="l28.89" class="difflineplus">+</span>
<a href="#l28.90"></a><span id="l28.90" class="difflineplus">+int ZEXPORT uncompress (dest, destLen, source, sourceLen)</span>
<a href="#l28.91"></a><span id="l28.91" class="difflineplus">+    Bytef *dest;</span>
<a href="#l28.92"></a><span id="l28.92" class="difflineplus">+    uLongf *destLen;</span>
<a href="#l28.93"></a><span id="l28.93" class="difflineplus">+    const Bytef *source;</span>
<a href="#l28.94"></a><span id="l28.94" class="difflineplus">+    uLong sourceLen;</span>
<a href="#l28.95"></a><span id="l28.95" class="difflineplus">+{</span>
<a href="#l28.96"></a><span id="l28.96" class="difflineplus">+    return uncompress2(dest, destLen, source, &amp;sourceLen);</span>
<a href="#l28.97"></a><span id="l28.97" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1">new file mode 100644</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineminus">--- /dev/null</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineplus">+++ b/third_party/zlib/zconf.h</span>
<a href="#l29.4"></a><span id="l29.4" class="difflineat">@@ -0,0 +1,534 @@</span>
<a href="#l29.5"></a><span id="l29.5" class="difflineplus">+/* zconf.h -- configuration of the zlib compression library</span>
<a href="#l29.6"></a><span id="l29.6" class="difflineplus">+ * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler</span>
<a href="#l29.7"></a><span id="l29.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l29.8"></a><span id="l29.8" class="difflineplus">+ */</span>
<a href="#l29.9"></a><span id="l29.9" class="difflineplus">+</span>
<a href="#l29.10"></a><span id="l29.10" class="difflineplus">+/* @(#) $Id$ */</span>
<a href="#l29.11"></a><span id="l29.11" class="difflineplus">+</span>
<a href="#l29.12"></a><span id="l29.12" class="difflineplus">+#ifndef ZCONF_H</span>
<a href="#l29.13"></a><span id="l29.13" class="difflineplus">+#define ZCONF_H</span>
<a href="#l29.14"></a><span id="l29.14" class="difflineplus">+</span>
<a href="#l29.15"></a><span id="l29.15" class="difflineplus">+/*</span>
<a href="#l29.16"></a><span id="l29.16" class="difflineplus">+ * If you *really* need a unique prefix for all types and library functions,</span>
<a href="#l29.17"></a><span id="l29.17" class="difflineplus">+ * compile with -DZ_PREFIX. The &quot;standard&quot; zlib should be compiled without it.</span>
<a href="#l29.18"></a><span id="l29.18" class="difflineplus">+ * Even better than compiling with -DZ_PREFIX would be to use configure to set</span>
<a href="#l29.19"></a><span id="l29.19" class="difflineplus">+ * this permanently in zconf.h using &quot;./configure --zprefix&quot;.</span>
<a href="#l29.20"></a><span id="l29.20" class="difflineplus">+ */</span>
<a href="#l29.21"></a><span id="l29.21" class="difflineplus">+#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */</span>
<a href="#l29.22"></a><span id="l29.22" class="difflineplus">+#  define Z_PREFIX_SET</span>
<a href="#l29.23"></a><span id="l29.23" class="difflineplus">+</span>
<a href="#l29.24"></a><span id="l29.24" class="difflineplus">+/* all linked symbols and init macros */</span>
<a href="#l29.25"></a><span id="l29.25" class="difflineplus">+#  define _dist_code            z__dist_code</span>
<a href="#l29.26"></a><span id="l29.26" class="difflineplus">+#  define _length_code          z__length_code</span>
<a href="#l29.27"></a><span id="l29.27" class="difflineplus">+#  define _tr_align             z__tr_align</span>
<a href="#l29.28"></a><span id="l29.28" class="difflineplus">+#  define _tr_flush_bits        z__tr_flush_bits</span>
<a href="#l29.29"></a><span id="l29.29" class="difflineplus">+#  define _tr_flush_block       z__tr_flush_block</span>
<a href="#l29.30"></a><span id="l29.30" class="difflineplus">+#  define _tr_init              z__tr_init</span>
<a href="#l29.31"></a><span id="l29.31" class="difflineplus">+#  define _tr_stored_block      z__tr_stored_block</span>
<a href="#l29.32"></a><span id="l29.32" class="difflineplus">+#  define _tr_tally             z__tr_tally</span>
<a href="#l29.33"></a><span id="l29.33" class="difflineplus">+#  define adler32               z_adler32</span>
<a href="#l29.34"></a><span id="l29.34" class="difflineplus">+#  define adler32_combine       z_adler32_combine</span>
<a href="#l29.35"></a><span id="l29.35" class="difflineplus">+#  define adler32_combine64     z_adler32_combine64</span>
<a href="#l29.36"></a><span id="l29.36" class="difflineplus">+#  define adler32_z             z_adler32_z</span>
<a href="#l29.37"></a><span id="l29.37" class="difflineplus">+#  ifndef Z_SOLO</span>
<a href="#l29.38"></a><span id="l29.38" class="difflineplus">+#    define compress              z_compress</span>
<a href="#l29.39"></a><span id="l29.39" class="difflineplus">+#    define compress2             z_compress2</span>
<a href="#l29.40"></a><span id="l29.40" class="difflineplus">+#    define compressBound         z_compressBound</span>
<a href="#l29.41"></a><span id="l29.41" class="difflineplus">+#  endif</span>
<a href="#l29.42"></a><span id="l29.42" class="difflineplus">+#  define crc32                 z_crc32</span>
<a href="#l29.43"></a><span id="l29.43" class="difflineplus">+#  define crc32_combine         z_crc32_combine</span>
<a href="#l29.44"></a><span id="l29.44" class="difflineplus">+#  define crc32_combine64       z_crc32_combine64</span>
<a href="#l29.45"></a><span id="l29.45" class="difflineplus">+#  define crc32_z               z_crc32_z</span>
<a href="#l29.46"></a><span id="l29.46" class="difflineplus">+#  define deflate               z_deflate</span>
<a href="#l29.47"></a><span id="l29.47" class="difflineplus">+#  define deflateBound          z_deflateBound</span>
<a href="#l29.48"></a><span id="l29.48" class="difflineplus">+#  define deflateCopy           z_deflateCopy</span>
<a href="#l29.49"></a><span id="l29.49" class="difflineplus">+#  define deflateEnd            z_deflateEnd</span>
<a href="#l29.50"></a><span id="l29.50" class="difflineplus">+#  define deflateGetDictionary  z_deflateGetDictionary</span>
<a href="#l29.51"></a><span id="l29.51" class="difflineplus">+#  define deflateInit           z_deflateInit</span>
<a href="#l29.52"></a><span id="l29.52" class="difflineplus">+#  define deflateInit2          z_deflateInit2</span>
<a href="#l29.53"></a><span id="l29.53" class="difflineplus">+#  define deflateInit2_         z_deflateInit2_</span>
<a href="#l29.54"></a><span id="l29.54" class="difflineplus">+#  define deflateInit_          z_deflateInit_</span>
<a href="#l29.55"></a><span id="l29.55" class="difflineplus">+#  define deflateParams         z_deflateParams</span>
<a href="#l29.56"></a><span id="l29.56" class="difflineplus">+#  define deflatePending        z_deflatePending</span>
<a href="#l29.57"></a><span id="l29.57" class="difflineplus">+#  define deflatePrime          z_deflatePrime</span>
<a href="#l29.58"></a><span id="l29.58" class="difflineplus">+#  define deflateReset          z_deflateReset</span>
<a href="#l29.59"></a><span id="l29.59" class="difflineplus">+#  define deflateResetKeep      z_deflateResetKeep</span>
<a href="#l29.60"></a><span id="l29.60" class="difflineplus">+#  define deflateSetDictionary  z_deflateSetDictionary</span>
<a href="#l29.61"></a><span id="l29.61" class="difflineplus">+#  define deflateSetHeader      z_deflateSetHeader</span>
<a href="#l29.62"></a><span id="l29.62" class="difflineplus">+#  define deflateTune           z_deflateTune</span>
<a href="#l29.63"></a><span id="l29.63" class="difflineplus">+#  define deflate_copyright     z_deflate_copyright</span>
<a href="#l29.64"></a><span id="l29.64" class="difflineplus">+#  define get_crc_table         z_get_crc_table</span>
<a href="#l29.65"></a><span id="l29.65" class="difflineplus">+#  ifndef Z_SOLO</span>
<a href="#l29.66"></a><span id="l29.66" class="difflineplus">+#    define gz_error              z_gz_error</span>
<a href="#l29.67"></a><span id="l29.67" class="difflineplus">+#    define gz_intmax             z_gz_intmax</span>
<a href="#l29.68"></a><span id="l29.68" class="difflineplus">+#    define gz_strwinerror        z_gz_strwinerror</span>
<a href="#l29.69"></a><span id="l29.69" class="difflineplus">+#    define gzbuffer              z_gzbuffer</span>
<a href="#l29.70"></a><span id="l29.70" class="difflineplus">+#    define gzclearerr            z_gzclearerr</span>
<a href="#l29.71"></a><span id="l29.71" class="difflineplus">+#    define gzclose               z_gzclose</span>
<a href="#l29.72"></a><span id="l29.72" class="difflineplus">+#    define gzclose_r             z_gzclose_r</span>
<a href="#l29.73"></a><span id="l29.73" class="difflineplus">+#    define gzclose_w             z_gzclose_w</span>
<a href="#l29.74"></a><span id="l29.74" class="difflineplus">+#    define gzdirect              z_gzdirect</span>
<a href="#l29.75"></a><span id="l29.75" class="difflineplus">+#    define gzdopen               z_gzdopen</span>
<a href="#l29.76"></a><span id="l29.76" class="difflineplus">+#    define gzeof                 z_gzeof</span>
<a href="#l29.77"></a><span id="l29.77" class="difflineplus">+#    define gzerror               z_gzerror</span>
<a href="#l29.78"></a><span id="l29.78" class="difflineplus">+#    define gzflush               z_gzflush</span>
<a href="#l29.79"></a><span id="l29.79" class="difflineplus">+#    define gzfread               z_gzfread</span>
<a href="#l29.80"></a><span id="l29.80" class="difflineplus">+#    define gzfwrite              z_gzfwrite</span>
<a href="#l29.81"></a><span id="l29.81" class="difflineplus">+#    define gzgetc                z_gzgetc</span>
<a href="#l29.82"></a><span id="l29.82" class="difflineplus">+#    define gzgetc_               z_gzgetc_</span>
<a href="#l29.83"></a><span id="l29.83" class="difflineplus">+#    define gzgets                z_gzgets</span>
<a href="#l29.84"></a><span id="l29.84" class="difflineplus">+#    define gzoffset              z_gzoffset</span>
<a href="#l29.85"></a><span id="l29.85" class="difflineplus">+#    define gzoffset64            z_gzoffset64</span>
<a href="#l29.86"></a><span id="l29.86" class="difflineplus">+#    define gzopen                z_gzopen</span>
<a href="#l29.87"></a><span id="l29.87" class="difflineplus">+#    define gzopen64              z_gzopen64</span>
<a href="#l29.88"></a><span id="l29.88" class="difflineplus">+#    ifdef _WIN32</span>
<a href="#l29.89"></a><span id="l29.89" class="difflineplus">+#      define gzopen_w              z_gzopen_w</span>
<a href="#l29.90"></a><span id="l29.90" class="difflineplus">+#    endif</span>
<a href="#l29.91"></a><span id="l29.91" class="difflineplus">+#    define gzprintf              z_gzprintf</span>
<a href="#l29.92"></a><span id="l29.92" class="difflineplus">+#    define gzputc                z_gzputc</span>
<a href="#l29.93"></a><span id="l29.93" class="difflineplus">+#    define gzputs                z_gzputs</span>
<a href="#l29.94"></a><span id="l29.94" class="difflineplus">+#    define gzread                z_gzread</span>
<a href="#l29.95"></a><span id="l29.95" class="difflineplus">+#    define gzrewind              z_gzrewind</span>
<a href="#l29.96"></a><span id="l29.96" class="difflineplus">+#    define gzseek                z_gzseek</span>
<a href="#l29.97"></a><span id="l29.97" class="difflineplus">+#    define gzseek64              z_gzseek64</span>
<a href="#l29.98"></a><span id="l29.98" class="difflineplus">+#    define gzsetparams           z_gzsetparams</span>
<a href="#l29.99"></a><span id="l29.99" class="difflineplus">+#    define gztell                z_gztell</span>
<a href="#l29.100"></a><span id="l29.100" class="difflineplus">+#    define gztell64              z_gztell64</span>
<a href="#l29.101"></a><span id="l29.101" class="difflineplus">+#    define gzungetc              z_gzungetc</span>
<a href="#l29.102"></a><span id="l29.102" class="difflineplus">+#    define gzvprintf             z_gzvprintf</span>
<a href="#l29.103"></a><span id="l29.103" class="difflineplus">+#    define gzwrite               z_gzwrite</span>
<a href="#l29.104"></a><span id="l29.104" class="difflineplus">+#  endif</span>
<a href="#l29.105"></a><span id="l29.105" class="difflineplus">+#  define inflate               z_inflate</span>
<a href="#l29.106"></a><span id="l29.106" class="difflineplus">+#  define inflateBack           z_inflateBack</span>
<a href="#l29.107"></a><span id="l29.107" class="difflineplus">+#  define inflateBackEnd        z_inflateBackEnd</span>
<a href="#l29.108"></a><span id="l29.108" class="difflineplus">+#  define inflateBackInit       z_inflateBackInit</span>
<a href="#l29.109"></a><span id="l29.109" class="difflineplus">+#  define inflateBackInit_      z_inflateBackInit_</span>
<a href="#l29.110"></a><span id="l29.110" class="difflineplus">+#  define inflateCodesUsed      z_inflateCodesUsed</span>
<a href="#l29.111"></a><span id="l29.111" class="difflineplus">+#  define inflateCopy           z_inflateCopy</span>
<a href="#l29.112"></a><span id="l29.112" class="difflineplus">+#  define inflateEnd            z_inflateEnd</span>
<a href="#l29.113"></a><span id="l29.113" class="difflineplus">+#  define inflateGetDictionary  z_inflateGetDictionary</span>
<a href="#l29.114"></a><span id="l29.114" class="difflineplus">+#  define inflateGetHeader      z_inflateGetHeader</span>
<a href="#l29.115"></a><span id="l29.115" class="difflineplus">+#  define inflateInit           z_inflateInit</span>
<a href="#l29.116"></a><span id="l29.116" class="difflineplus">+#  define inflateInit2          z_inflateInit2</span>
<a href="#l29.117"></a><span id="l29.117" class="difflineplus">+#  define inflateInit2_         z_inflateInit2_</span>
<a href="#l29.118"></a><span id="l29.118" class="difflineplus">+#  define inflateInit_          z_inflateInit_</span>
<a href="#l29.119"></a><span id="l29.119" class="difflineplus">+#  define inflateMark           z_inflateMark</span>
<a href="#l29.120"></a><span id="l29.120" class="difflineplus">+#  define inflatePrime          z_inflatePrime</span>
<a href="#l29.121"></a><span id="l29.121" class="difflineplus">+#  define inflateReset          z_inflateReset</span>
<a href="#l29.122"></a><span id="l29.122" class="difflineplus">+#  define inflateReset2         z_inflateReset2</span>
<a href="#l29.123"></a><span id="l29.123" class="difflineplus">+#  define inflateResetKeep      z_inflateResetKeep</span>
<a href="#l29.124"></a><span id="l29.124" class="difflineplus">+#  define inflateSetDictionary  z_inflateSetDictionary</span>
<a href="#l29.125"></a><span id="l29.125" class="difflineplus">+#  define inflateSync           z_inflateSync</span>
<a href="#l29.126"></a><span id="l29.126" class="difflineplus">+#  define inflateSyncPoint      z_inflateSyncPoint</span>
<a href="#l29.127"></a><span id="l29.127" class="difflineplus">+#  define inflateUndermine      z_inflateUndermine</span>
<a href="#l29.128"></a><span id="l29.128" class="difflineplus">+#  define inflateValidate       z_inflateValidate</span>
<a href="#l29.129"></a><span id="l29.129" class="difflineplus">+#  define inflate_copyright     z_inflate_copyright</span>
<a href="#l29.130"></a><span id="l29.130" class="difflineplus">+#  define inflate_fast          z_inflate_fast</span>
<a href="#l29.131"></a><span id="l29.131" class="difflineplus">+#  define inflate_table         z_inflate_table</span>
<a href="#l29.132"></a><span id="l29.132" class="difflineplus">+#  ifndef Z_SOLO</span>
<a href="#l29.133"></a><span id="l29.133" class="difflineplus">+#    define uncompress            z_uncompress</span>
<a href="#l29.134"></a><span id="l29.134" class="difflineplus">+#    define uncompress2           z_uncompress2</span>
<a href="#l29.135"></a><span id="l29.135" class="difflineplus">+#  endif</span>
<a href="#l29.136"></a><span id="l29.136" class="difflineplus">+#  define zError                z_zError</span>
<a href="#l29.137"></a><span id="l29.137" class="difflineplus">+#  ifndef Z_SOLO</span>
<a href="#l29.138"></a><span id="l29.138" class="difflineplus">+#    define zcalloc               z_zcalloc</span>
<a href="#l29.139"></a><span id="l29.139" class="difflineplus">+#    define zcfree                z_zcfree</span>
<a href="#l29.140"></a><span id="l29.140" class="difflineplus">+#  endif</span>
<a href="#l29.141"></a><span id="l29.141" class="difflineplus">+#  define zlibCompileFlags      z_zlibCompileFlags</span>
<a href="#l29.142"></a><span id="l29.142" class="difflineplus">+#  define zlibVersion           z_zlibVersion</span>
<a href="#l29.143"></a><span id="l29.143" class="difflineplus">+</span>
<a href="#l29.144"></a><span id="l29.144" class="difflineplus">+/* all zlib typedefs in zlib.h and zconf.h */</span>
<a href="#l29.145"></a><span id="l29.145" class="difflineplus">+#  define Byte                  z_Byte</span>
<a href="#l29.146"></a><span id="l29.146" class="difflineplus">+#  define Bytef                 z_Bytef</span>
<a href="#l29.147"></a><span id="l29.147" class="difflineplus">+#  define alloc_func            z_alloc_func</span>
<a href="#l29.148"></a><span id="l29.148" class="difflineplus">+#  define charf                 z_charf</span>
<a href="#l29.149"></a><span id="l29.149" class="difflineplus">+#  define free_func             z_free_func</span>
<a href="#l29.150"></a><span id="l29.150" class="difflineplus">+#  ifndef Z_SOLO</span>
<a href="#l29.151"></a><span id="l29.151" class="difflineplus">+#    define gzFile                z_gzFile</span>
<a href="#l29.152"></a><span id="l29.152" class="difflineplus">+#  endif</span>
<a href="#l29.153"></a><span id="l29.153" class="difflineplus">+#  define gz_header             z_gz_header</span>
<a href="#l29.154"></a><span id="l29.154" class="difflineplus">+#  define gz_headerp            z_gz_headerp</span>
<a href="#l29.155"></a><span id="l29.155" class="difflineplus">+#  define in_func               z_in_func</span>
<a href="#l29.156"></a><span id="l29.156" class="difflineplus">+#  define intf                  z_intf</span>
<a href="#l29.157"></a><span id="l29.157" class="difflineplus">+#  define out_func              z_out_func</span>
<a href="#l29.158"></a><span id="l29.158" class="difflineplus">+#  define uInt                  z_uInt</span>
<a href="#l29.159"></a><span id="l29.159" class="difflineplus">+#  define uIntf                 z_uIntf</span>
<a href="#l29.160"></a><span id="l29.160" class="difflineplus">+#  define uLong                 z_uLong</span>
<a href="#l29.161"></a><span id="l29.161" class="difflineplus">+#  define uLongf                z_uLongf</span>
<a href="#l29.162"></a><span id="l29.162" class="difflineplus">+#  define voidp                 z_voidp</span>
<a href="#l29.163"></a><span id="l29.163" class="difflineplus">+#  define voidpc                z_voidpc</span>
<a href="#l29.164"></a><span id="l29.164" class="difflineplus">+#  define voidpf                z_voidpf</span>
<a href="#l29.165"></a><span id="l29.165" class="difflineplus">+</span>
<a href="#l29.166"></a><span id="l29.166" class="difflineplus">+/* all zlib structs in zlib.h and zconf.h */</span>
<a href="#l29.167"></a><span id="l29.167" class="difflineplus">+#  define gz_header_s           z_gz_header_s</span>
<a href="#l29.168"></a><span id="l29.168" class="difflineplus">+#  define internal_state        z_internal_state</span>
<a href="#l29.169"></a><span id="l29.169" class="difflineplus">+</span>
<a href="#l29.170"></a><span id="l29.170" class="difflineplus">+#endif</span>
<a href="#l29.171"></a><span id="l29.171" class="difflineplus">+</span>
<a href="#l29.172"></a><span id="l29.172" class="difflineplus">+#if defined(__MSDOS__) &amp;&amp; !defined(MSDOS)</span>
<a href="#l29.173"></a><span id="l29.173" class="difflineplus">+#  define MSDOS</span>
<a href="#l29.174"></a><span id="l29.174" class="difflineplus">+#endif</span>
<a href="#l29.175"></a><span id="l29.175" class="difflineplus">+#if (defined(OS_2) || defined(__OS2__)) &amp;&amp; !defined(OS2)</span>
<a href="#l29.176"></a><span id="l29.176" class="difflineplus">+#  define OS2</span>
<a href="#l29.177"></a><span id="l29.177" class="difflineplus">+#endif</span>
<a href="#l29.178"></a><span id="l29.178" class="difflineplus">+#if defined(_WINDOWS) &amp;&amp; !defined(WINDOWS)</span>
<a href="#l29.179"></a><span id="l29.179" class="difflineplus">+#  define WINDOWS</span>
<a href="#l29.180"></a><span id="l29.180" class="difflineplus">+#endif</span>
<a href="#l29.181"></a><span id="l29.181" class="difflineplus">+#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)</span>
<a href="#l29.182"></a><span id="l29.182" class="difflineplus">+#  ifndef WIN32</span>
<a href="#l29.183"></a><span id="l29.183" class="difflineplus">+#    define WIN32</span>
<a href="#l29.184"></a><span id="l29.184" class="difflineplus">+#  endif</span>
<a href="#l29.185"></a><span id="l29.185" class="difflineplus">+#endif</span>
<a href="#l29.186"></a><span id="l29.186" class="difflineplus">+#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) &amp;&amp; !defined(WIN32)</span>
<a href="#l29.187"></a><span id="l29.187" class="difflineplus">+#  if !defined(__GNUC__) &amp;&amp; !defined(__FLAT__) &amp;&amp; !defined(__386__)</span>
<a href="#l29.188"></a><span id="l29.188" class="difflineplus">+#    ifndef SYS16BIT</span>
<a href="#l29.189"></a><span id="l29.189" class="difflineplus">+#      define SYS16BIT</span>
<a href="#l29.190"></a><span id="l29.190" class="difflineplus">+#    endif</span>
<a href="#l29.191"></a><span id="l29.191" class="difflineplus">+#  endif</span>
<a href="#l29.192"></a><span id="l29.192" class="difflineplus">+#endif</span>
<a href="#l29.193"></a><span id="l29.193" class="difflineplus">+</span>
<a href="#l29.194"></a><span id="l29.194" class="difflineplus">+/*</span>
<a href="#l29.195"></a><span id="l29.195" class="difflineplus">+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more</span>
<a href="#l29.196"></a><span id="l29.196" class="difflineplus">+ * than 64k bytes at a time (needed on systems with 16-bit int).</span>
<a href="#l29.197"></a><span id="l29.197" class="difflineplus">+ */</span>
<a href="#l29.198"></a><span id="l29.198" class="difflineplus">+#ifdef SYS16BIT</span>
<a href="#l29.199"></a><span id="l29.199" class="difflineplus">+#  define MAXSEG_64K</span>
<a href="#l29.200"></a><span id="l29.200" class="difflineplus">+#endif</span>
<a href="#l29.201"></a><span id="l29.201" class="difflineplus">+#ifdef MSDOS</span>
<a href="#l29.202"></a><span id="l29.202" class="difflineplus">+#  define UNALIGNED_OK</span>
<a href="#l29.203"></a><span id="l29.203" class="difflineplus">+#endif</span>
<a href="#l29.204"></a><span id="l29.204" class="difflineplus">+</span>
<a href="#l29.205"></a><span id="l29.205" class="difflineplus">+#ifdef __STDC_VERSION__</span>
<a href="#l29.206"></a><span id="l29.206" class="difflineplus">+#  ifndef STDC</span>
<a href="#l29.207"></a><span id="l29.207" class="difflineplus">+#    define STDC</span>
<a href="#l29.208"></a><span id="l29.208" class="difflineplus">+#  endif</span>
<a href="#l29.209"></a><span id="l29.209" class="difflineplus">+#  if __STDC_VERSION__ &gt;= 199901L</span>
<a href="#l29.210"></a><span id="l29.210" class="difflineplus">+#    ifndef STDC99</span>
<a href="#l29.211"></a><span id="l29.211" class="difflineplus">+#      define STDC99</span>
<a href="#l29.212"></a><span id="l29.212" class="difflineplus">+#    endif</span>
<a href="#l29.213"></a><span id="l29.213" class="difflineplus">+#  endif</span>
<a href="#l29.214"></a><span id="l29.214" class="difflineplus">+#endif</span>
<a href="#l29.215"></a><span id="l29.215" class="difflineplus">+#if !defined(STDC) &amp;&amp; (defined(__STDC__) || defined(__cplusplus))</span>
<a href="#l29.216"></a><span id="l29.216" class="difflineplus">+#  define STDC</span>
<a href="#l29.217"></a><span id="l29.217" class="difflineplus">+#endif</span>
<a href="#l29.218"></a><span id="l29.218" class="difflineplus">+#if !defined(STDC) &amp;&amp; (defined(__GNUC__) || defined(__BORLANDC__))</span>
<a href="#l29.219"></a><span id="l29.219" class="difflineplus">+#  define STDC</span>
<a href="#l29.220"></a><span id="l29.220" class="difflineplus">+#endif</span>
<a href="#l29.221"></a><span id="l29.221" class="difflineplus">+#if !defined(STDC) &amp;&amp; (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))</span>
<a href="#l29.222"></a><span id="l29.222" class="difflineplus">+#  define STDC</span>
<a href="#l29.223"></a><span id="l29.223" class="difflineplus">+#endif</span>
<a href="#l29.224"></a><span id="l29.224" class="difflineplus">+#if !defined(STDC) &amp;&amp; (defined(OS2) || defined(__HOS_AIX__))</span>
<a href="#l29.225"></a><span id="l29.225" class="difflineplus">+#  define STDC</span>
<a href="#l29.226"></a><span id="l29.226" class="difflineplus">+#endif</span>
<a href="#l29.227"></a><span id="l29.227" class="difflineplus">+</span>
<a href="#l29.228"></a><span id="l29.228" class="difflineplus">+#if defined(__OS400__) &amp;&amp; !defined(STDC)    /* iSeries (formerly AS/400). */</span>
<a href="#l29.229"></a><span id="l29.229" class="difflineplus">+#  define STDC</span>
<a href="#l29.230"></a><span id="l29.230" class="difflineplus">+#endif</span>
<a href="#l29.231"></a><span id="l29.231" class="difflineplus">+</span>
<a href="#l29.232"></a><span id="l29.232" class="difflineplus">+#ifndef STDC</span>
<a href="#l29.233"></a><span id="l29.233" class="difflineplus">+#  ifndef const /* cannot use !defined(STDC) &amp;&amp; !defined(const) on Mac */</span>
<a href="#l29.234"></a><span id="l29.234" class="difflineplus">+#    define const       /* note: need a more gentle solution here */</span>
<a href="#l29.235"></a><span id="l29.235" class="difflineplus">+#  endif</span>
<a href="#l29.236"></a><span id="l29.236" class="difflineplus">+#endif</span>
<a href="#l29.237"></a><span id="l29.237" class="difflineplus">+</span>
<a href="#l29.238"></a><span id="l29.238" class="difflineplus">+#if defined(ZLIB_CONST) &amp;&amp; !defined(z_const)</span>
<a href="#l29.239"></a><span id="l29.239" class="difflineplus">+#  define z_const const</span>
<a href="#l29.240"></a><span id="l29.240" class="difflineplus">+#else</span>
<a href="#l29.241"></a><span id="l29.241" class="difflineplus">+#  define z_const</span>
<a href="#l29.242"></a><span id="l29.242" class="difflineplus">+#endif</span>
<a href="#l29.243"></a><span id="l29.243" class="difflineplus">+</span>
<a href="#l29.244"></a><span id="l29.244" class="difflineplus">+#ifdef Z_SOLO</span>
<a href="#l29.245"></a><span id="l29.245" class="difflineplus">+   typedef unsigned long z_size_t;</span>
<a href="#l29.246"></a><span id="l29.246" class="difflineplus">+#else</span>
<a href="#l29.247"></a><span id="l29.247" class="difflineplus">+#  define z_longlong long long</span>
<a href="#l29.248"></a><span id="l29.248" class="difflineplus">+#  if defined(NO_SIZE_T)</span>
<a href="#l29.249"></a><span id="l29.249" class="difflineplus">+     typedef unsigned NO_SIZE_T z_size_t;</span>
<a href="#l29.250"></a><span id="l29.250" class="difflineplus">+#  elif defined(STDC)</span>
<a href="#l29.251"></a><span id="l29.251" class="difflineplus">+#    include &lt;stddef.h&gt;</span>
<a href="#l29.252"></a><span id="l29.252" class="difflineplus">+     typedef size_t z_size_t;</span>
<a href="#l29.253"></a><span id="l29.253" class="difflineplus">+#  else</span>
<a href="#l29.254"></a><span id="l29.254" class="difflineplus">+     typedef unsigned long z_size_t;</span>
<a href="#l29.255"></a><span id="l29.255" class="difflineplus">+#  endif</span>
<a href="#l29.256"></a><span id="l29.256" class="difflineplus">+#  undef z_longlong</span>
<a href="#l29.257"></a><span id="l29.257" class="difflineplus">+#endif</span>
<a href="#l29.258"></a><span id="l29.258" class="difflineplus">+</span>
<a href="#l29.259"></a><span id="l29.259" class="difflineplus">+/* Maximum value for memLevel in deflateInit2 */</span>
<a href="#l29.260"></a><span id="l29.260" class="difflineplus">+#ifndef MAX_MEM_LEVEL</span>
<a href="#l29.261"></a><span id="l29.261" class="difflineplus">+#  ifdef MAXSEG_64K</span>
<a href="#l29.262"></a><span id="l29.262" class="difflineplus">+#    define MAX_MEM_LEVEL 8</span>
<a href="#l29.263"></a><span id="l29.263" class="difflineplus">+#  else</span>
<a href="#l29.264"></a><span id="l29.264" class="difflineplus">+#    define MAX_MEM_LEVEL 9</span>
<a href="#l29.265"></a><span id="l29.265" class="difflineplus">+#  endif</span>
<a href="#l29.266"></a><span id="l29.266" class="difflineplus">+#endif</span>
<a href="#l29.267"></a><span id="l29.267" class="difflineplus">+</span>
<a href="#l29.268"></a><span id="l29.268" class="difflineplus">+/* Maximum value for windowBits in deflateInit2 and inflateInit2.</span>
<a href="#l29.269"></a><span id="l29.269" class="difflineplus">+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files</span>
<a href="#l29.270"></a><span id="l29.270" class="difflineplus">+ * created by gzip. (Files created by minigzip can still be extracted by</span>
<a href="#l29.271"></a><span id="l29.271" class="difflineplus">+ * gzip.)</span>
<a href="#l29.272"></a><span id="l29.272" class="difflineplus">+ */</span>
<a href="#l29.273"></a><span id="l29.273" class="difflineplus">+#ifndef MAX_WBITS</span>
<a href="#l29.274"></a><span id="l29.274" class="difflineplus">+#  define MAX_WBITS   15 /* 32K LZ77 window */</span>
<a href="#l29.275"></a><span id="l29.275" class="difflineplus">+#endif</span>
<a href="#l29.276"></a><span id="l29.276" class="difflineplus">+</span>
<a href="#l29.277"></a><span id="l29.277" class="difflineplus">+/* The memory requirements for deflate are (in bytes):</span>
<a href="#l29.278"></a><span id="l29.278" class="difflineplus">+            (1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))</span>
<a href="#l29.279"></a><span id="l29.279" class="difflineplus">+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)</span>
<a href="#l29.280"></a><span id="l29.280" class="difflineplus">+ plus a few kilobytes for small objects. For example, if you want to reduce</span>
<a href="#l29.281"></a><span id="l29.281" class="difflineplus">+ the default memory requirements from 256K to 128K, compile with</span>
<a href="#l29.282"></a><span id="l29.282" class="difflineplus">+     make CFLAGS=&quot;-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7&quot;</span>
<a href="#l29.283"></a><span id="l29.283" class="difflineplus">+ Of course this will generally degrade compression (there's no free lunch).</span>
<a href="#l29.284"></a><span id="l29.284" class="difflineplus">+</span>
<a href="#l29.285"></a><span id="l29.285" class="difflineplus">+   The memory requirements for inflate are (in bytes) 1 &lt;&lt; windowBits</span>
<a href="#l29.286"></a><span id="l29.286" class="difflineplus">+ that is, 32K for windowBits=15 (default value) plus about 7 kilobytes</span>
<a href="#l29.287"></a><span id="l29.287" class="difflineplus">+ for small objects.</span>
<a href="#l29.288"></a><span id="l29.288" class="difflineplus">+*/</span>
<a href="#l29.289"></a><span id="l29.289" class="difflineplus">+</span>
<a href="#l29.290"></a><span id="l29.290" class="difflineplus">+                        /* Type declarations */</span>
<a href="#l29.291"></a><span id="l29.291" class="difflineplus">+</span>
<a href="#l29.292"></a><span id="l29.292" class="difflineplus">+#ifndef OF /* function prototypes */</span>
<a href="#l29.293"></a><span id="l29.293" class="difflineplus">+#  ifdef STDC</span>
<a href="#l29.294"></a><span id="l29.294" class="difflineplus">+#    define OF(args)  args</span>
<a href="#l29.295"></a><span id="l29.295" class="difflineplus">+#  else</span>
<a href="#l29.296"></a><span id="l29.296" class="difflineplus">+#    define OF(args)  ()</span>
<a href="#l29.297"></a><span id="l29.297" class="difflineplus">+#  endif</span>
<a href="#l29.298"></a><span id="l29.298" class="difflineplus">+#endif</span>
<a href="#l29.299"></a><span id="l29.299" class="difflineplus">+</span>
<a href="#l29.300"></a><span id="l29.300" class="difflineplus">+#ifndef Z_ARG /* function prototypes for stdarg */</span>
<a href="#l29.301"></a><span id="l29.301" class="difflineplus">+#  if defined(STDC) || defined(Z_HAVE_STDARG_H)</span>
<a href="#l29.302"></a><span id="l29.302" class="difflineplus">+#    define Z_ARG(args)  args</span>
<a href="#l29.303"></a><span id="l29.303" class="difflineplus">+#  else</span>
<a href="#l29.304"></a><span id="l29.304" class="difflineplus">+#    define Z_ARG(args)  ()</span>
<a href="#l29.305"></a><span id="l29.305" class="difflineplus">+#  endif</span>
<a href="#l29.306"></a><span id="l29.306" class="difflineplus">+#endif</span>
<a href="#l29.307"></a><span id="l29.307" class="difflineplus">+</span>
<a href="#l29.308"></a><span id="l29.308" class="difflineplus">+/* The following definitions for FAR are needed only for MSDOS mixed</span>
<a href="#l29.309"></a><span id="l29.309" class="difflineplus">+ * model programming (small or medium model with some far allocations).</span>
<a href="#l29.310"></a><span id="l29.310" class="difflineplus">+ * This was tested only with MSC; for other MSDOS compilers you may have</span>
<a href="#l29.311"></a><span id="l29.311" class="difflineplus">+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,</span>
<a href="#l29.312"></a><span id="l29.312" class="difflineplus">+ * just define FAR to be empty.</span>
<a href="#l29.313"></a><span id="l29.313" class="difflineplus">+ */</span>
<a href="#l29.314"></a><span id="l29.314" class="difflineplus">+#ifdef SYS16BIT</span>
<a href="#l29.315"></a><span id="l29.315" class="difflineplus">+#  if defined(M_I86SM) || defined(M_I86MM)</span>
<a href="#l29.316"></a><span id="l29.316" class="difflineplus">+     /* MSC small or medium model */</span>
<a href="#l29.317"></a><span id="l29.317" class="difflineplus">+#    define SMALL_MEDIUM</span>
<a href="#l29.318"></a><span id="l29.318" class="difflineplus">+#    ifdef _MSC_VER</span>
<a href="#l29.319"></a><span id="l29.319" class="difflineplus">+#      define FAR _far</span>
<a href="#l29.320"></a><span id="l29.320" class="difflineplus">+#    else</span>
<a href="#l29.321"></a><span id="l29.321" class="difflineplus">+#      define FAR far</span>
<a href="#l29.322"></a><span id="l29.322" class="difflineplus">+#    endif</span>
<a href="#l29.323"></a><span id="l29.323" class="difflineplus">+#  endif</span>
<a href="#l29.324"></a><span id="l29.324" class="difflineplus">+#  if (defined(__SMALL__) || defined(__MEDIUM__))</span>
<a href="#l29.325"></a><span id="l29.325" class="difflineplus">+     /* Turbo C small or medium model */</span>
<a href="#l29.326"></a><span id="l29.326" class="difflineplus">+#    define SMALL_MEDIUM</span>
<a href="#l29.327"></a><span id="l29.327" class="difflineplus">+#    ifdef __BORLANDC__</span>
<a href="#l29.328"></a><span id="l29.328" class="difflineplus">+#      define FAR _far</span>
<a href="#l29.329"></a><span id="l29.329" class="difflineplus">+#    else</span>
<a href="#l29.330"></a><span id="l29.330" class="difflineplus">+#      define FAR far</span>
<a href="#l29.331"></a><span id="l29.331" class="difflineplus">+#    endif</span>
<a href="#l29.332"></a><span id="l29.332" class="difflineplus">+#  endif</span>
<a href="#l29.333"></a><span id="l29.333" class="difflineplus">+#endif</span>
<a href="#l29.334"></a><span id="l29.334" class="difflineplus">+</span>
<a href="#l29.335"></a><span id="l29.335" class="difflineplus">+#if defined(WINDOWS) || defined(WIN32)</span>
<a href="#l29.336"></a><span id="l29.336" class="difflineplus">+   /* If building or using zlib as a DLL, define ZLIB_DLL.</span>
<a href="#l29.337"></a><span id="l29.337" class="difflineplus">+    * This is not mandatory, but it offers a little performance increase.</span>
<a href="#l29.338"></a><span id="l29.338" class="difflineplus">+    */</span>
<a href="#l29.339"></a><span id="l29.339" class="difflineplus">+#  ifdef ZLIB_DLL</span>
<a href="#l29.340"></a><span id="l29.340" class="difflineplus">+#    if defined(WIN32) &amp;&amp; (!defined(__BORLANDC__) || (__BORLANDC__ &gt;= 0x500))</span>
<a href="#l29.341"></a><span id="l29.341" class="difflineplus">+#      ifdef ZLIB_INTERNAL</span>
<a href="#l29.342"></a><span id="l29.342" class="difflineplus">+#        define ZEXTERN extern __declspec(dllexport)</span>
<a href="#l29.343"></a><span id="l29.343" class="difflineplus">+#      else</span>
<a href="#l29.344"></a><span id="l29.344" class="difflineplus">+#        define ZEXTERN extern __declspec(dllimport)</span>
<a href="#l29.345"></a><span id="l29.345" class="difflineplus">+#      endif</span>
<a href="#l29.346"></a><span id="l29.346" class="difflineplus">+#    endif</span>
<a href="#l29.347"></a><span id="l29.347" class="difflineplus">+#  endif  /* ZLIB_DLL */</span>
<a href="#l29.348"></a><span id="l29.348" class="difflineplus">+   /* If building or using zlib with the WINAPI/WINAPIV calling convention,</span>
<a href="#l29.349"></a><span id="l29.349" class="difflineplus">+    * define ZLIB_WINAPI.</span>
<a href="#l29.350"></a><span id="l29.350" class="difflineplus">+    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.</span>
<a href="#l29.351"></a><span id="l29.351" class="difflineplus">+    */</span>
<a href="#l29.352"></a><span id="l29.352" class="difflineplus">+#  ifdef ZLIB_WINAPI</span>
<a href="#l29.353"></a><span id="l29.353" class="difflineplus">+#    ifdef FAR</span>
<a href="#l29.354"></a><span id="l29.354" class="difflineplus">+#      undef FAR</span>
<a href="#l29.355"></a><span id="l29.355" class="difflineplus">+#    endif</span>
<a href="#l29.356"></a><span id="l29.356" class="difflineplus">+#    include &lt;windows.h&gt;</span>
<a href="#l29.357"></a><span id="l29.357" class="difflineplus">+     /* No need for _export, use ZLIB.DEF instead. */</span>
<a href="#l29.358"></a><span id="l29.358" class="difflineplus">+     /* For complete Windows compatibility, use WINAPI, not __stdcall. */</span>
<a href="#l29.359"></a><span id="l29.359" class="difflineplus">+#    define ZEXPORT WINAPI</span>
<a href="#l29.360"></a><span id="l29.360" class="difflineplus">+#    ifdef WIN32</span>
<a href="#l29.361"></a><span id="l29.361" class="difflineplus">+#      define ZEXPORTVA WINAPIV</span>
<a href="#l29.362"></a><span id="l29.362" class="difflineplus">+#    else</span>
<a href="#l29.363"></a><span id="l29.363" class="difflineplus">+#      define ZEXPORTVA FAR CDECL</span>
<a href="#l29.364"></a><span id="l29.364" class="difflineplus">+#    endif</span>
<a href="#l29.365"></a><span id="l29.365" class="difflineplus">+#  endif</span>
<a href="#l29.366"></a><span id="l29.366" class="difflineplus">+#endif</span>
<a href="#l29.367"></a><span id="l29.367" class="difflineplus">+</span>
<a href="#l29.368"></a><span id="l29.368" class="difflineplus">+#if defined (__BEOS__)</span>
<a href="#l29.369"></a><span id="l29.369" class="difflineplus">+#  ifdef ZLIB_DLL</span>
<a href="#l29.370"></a><span id="l29.370" class="difflineplus">+#    ifdef ZLIB_INTERNAL</span>
<a href="#l29.371"></a><span id="l29.371" class="difflineplus">+#      define ZEXPORT   __declspec(dllexport)</span>
<a href="#l29.372"></a><span id="l29.372" class="difflineplus">+#      define ZEXPORTVA __declspec(dllexport)</span>
<a href="#l29.373"></a><span id="l29.373" class="difflineplus">+#    else</span>
<a href="#l29.374"></a><span id="l29.374" class="difflineplus">+#      define ZEXPORT   __declspec(dllimport)</span>
<a href="#l29.375"></a><span id="l29.375" class="difflineplus">+#      define ZEXPORTVA __declspec(dllimport)</span>
<a href="#l29.376"></a><span id="l29.376" class="difflineplus">+#    endif</span>
<a href="#l29.377"></a><span id="l29.377" class="difflineplus">+#  endif</span>
<a href="#l29.378"></a><span id="l29.378" class="difflineplus">+#endif</span>
<a href="#l29.379"></a><span id="l29.379" class="difflineplus">+</span>
<a href="#l29.380"></a><span id="l29.380" class="difflineplus">+#ifndef ZEXTERN</span>
<a href="#l29.381"></a><span id="l29.381" class="difflineplus">+#  define ZEXTERN extern</span>
<a href="#l29.382"></a><span id="l29.382" class="difflineplus">+#endif</span>
<a href="#l29.383"></a><span id="l29.383" class="difflineplus">+#ifndef ZEXPORT</span>
<a href="#l29.384"></a><span id="l29.384" class="difflineplus">+#  define ZEXPORT</span>
<a href="#l29.385"></a><span id="l29.385" class="difflineplus">+#endif</span>
<a href="#l29.386"></a><span id="l29.386" class="difflineplus">+#ifndef ZEXPORTVA</span>
<a href="#l29.387"></a><span id="l29.387" class="difflineplus">+#  define ZEXPORTVA</span>
<a href="#l29.388"></a><span id="l29.388" class="difflineplus">+#endif</span>
<a href="#l29.389"></a><span id="l29.389" class="difflineplus">+</span>
<a href="#l29.390"></a><span id="l29.390" class="difflineplus">+#ifndef FAR</span>
<a href="#l29.391"></a><span id="l29.391" class="difflineplus">+#  define FAR</span>
<a href="#l29.392"></a><span id="l29.392" class="difflineplus">+#endif</span>
<a href="#l29.393"></a><span id="l29.393" class="difflineplus">+</span>
<a href="#l29.394"></a><span id="l29.394" class="difflineplus">+#if !defined(__MACTYPES__)</span>
<a href="#l29.395"></a><span id="l29.395" class="difflineplus">+typedef unsigned char  Byte;  /* 8 bits */</span>
<a href="#l29.396"></a><span id="l29.396" class="difflineplus">+#endif</span>
<a href="#l29.397"></a><span id="l29.397" class="difflineplus">+typedef unsigned int   uInt;  /* 16 bits or more */</span>
<a href="#l29.398"></a><span id="l29.398" class="difflineplus">+typedef unsigned long  uLong; /* 32 bits or more */</span>
<a href="#l29.399"></a><span id="l29.399" class="difflineplus">+</span>
<a href="#l29.400"></a><span id="l29.400" class="difflineplus">+#ifdef SMALL_MEDIUM</span>
<a href="#l29.401"></a><span id="l29.401" class="difflineplus">+   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */</span>
<a href="#l29.402"></a><span id="l29.402" class="difflineplus">+#  define Bytef Byte FAR</span>
<a href="#l29.403"></a><span id="l29.403" class="difflineplus">+#else</span>
<a href="#l29.404"></a><span id="l29.404" class="difflineplus">+   typedef Byte  FAR Bytef;</span>
<a href="#l29.405"></a><span id="l29.405" class="difflineplus">+#endif</span>
<a href="#l29.406"></a><span id="l29.406" class="difflineplus">+typedef char  FAR charf;</span>
<a href="#l29.407"></a><span id="l29.407" class="difflineplus">+typedef int   FAR intf;</span>
<a href="#l29.408"></a><span id="l29.408" class="difflineplus">+typedef uInt  FAR uIntf;</span>
<a href="#l29.409"></a><span id="l29.409" class="difflineplus">+typedef uLong FAR uLongf;</span>
<a href="#l29.410"></a><span id="l29.410" class="difflineplus">+</span>
<a href="#l29.411"></a><span id="l29.411" class="difflineplus">+#ifdef STDC</span>
<a href="#l29.412"></a><span id="l29.412" class="difflineplus">+   typedef void const *voidpc;</span>
<a href="#l29.413"></a><span id="l29.413" class="difflineplus">+   typedef void FAR   *voidpf;</span>
<a href="#l29.414"></a><span id="l29.414" class="difflineplus">+   typedef void       *voidp;</span>
<a href="#l29.415"></a><span id="l29.415" class="difflineplus">+#else</span>
<a href="#l29.416"></a><span id="l29.416" class="difflineplus">+   typedef Byte const *voidpc;</span>
<a href="#l29.417"></a><span id="l29.417" class="difflineplus">+   typedef Byte FAR   *voidpf;</span>
<a href="#l29.418"></a><span id="l29.418" class="difflineplus">+   typedef Byte       *voidp;</span>
<a href="#l29.419"></a><span id="l29.419" class="difflineplus">+#endif</span>
<a href="#l29.420"></a><span id="l29.420" class="difflineplus">+</span>
<a href="#l29.421"></a><span id="l29.421" class="difflineplus">+#if !defined(Z_U4) &amp;&amp; !defined(Z_SOLO) &amp;&amp; defined(STDC)</span>
<a href="#l29.422"></a><span id="l29.422" class="difflineplus">+#  include &lt;limits.h&gt;</span>
<a href="#l29.423"></a><span id="l29.423" class="difflineplus">+#  if (UINT_MAX == 0xffffffffUL)</span>
<a href="#l29.424"></a><span id="l29.424" class="difflineplus">+#    define Z_U4 unsigned</span>
<a href="#l29.425"></a><span id="l29.425" class="difflineplus">+#  elif (ULONG_MAX == 0xffffffffUL)</span>
<a href="#l29.426"></a><span id="l29.426" class="difflineplus">+#    define Z_U4 unsigned long</span>
<a href="#l29.427"></a><span id="l29.427" class="difflineplus">+#  elif (USHRT_MAX == 0xffffffffUL)</span>
<a href="#l29.428"></a><span id="l29.428" class="difflineplus">+#    define Z_U4 unsigned short</span>
<a href="#l29.429"></a><span id="l29.429" class="difflineplus">+#  endif</span>
<a href="#l29.430"></a><span id="l29.430" class="difflineplus">+#endif</span>
<a href="#l29.431"></a><span id="l29.431" class="difflineplus">+</span>
<a href="#l29.432"></a><span id="l29.432" class="difflineplus">+#ifdef Z_U4</span>
<a href="#l29.433"></a><span id="l29.433" class="difflineplus">+   typedef Z_U4 z_crc_t;</span>
<a href="#l29.434"></a><span id="l29.434" class="difflineplus">+#else</span>
<a href="#l29.435"></a><span id="l29.435" class="difflineplus">+   typedef unsigned long z_crc_t;</span>
<a href="#l29.436"></a><span id="l29.436" class="difflineplus">+#endif</span>
<a href="#l29.437"></a><span id="l29.437" class="difflineplus">+</span>
<a href="#l29.438"></a><span id="l29.438" class="difflineplus">+#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */</span>
<a href="#l29.439"></a><span id="l29.439" class="difflineplus">+#  define Z_HAVE_UNISTD_H</span>
<a href="#l29.440"></a><span id="l29.440" class="difflineplus">+#endif</span>
<a href="#l29.441"></a><span id="l29.441" class="difflineplus">+</span>
<a href="#l29.442"></a><span id="l29.442" class="difflineplus">+#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */</span>
<a href="#l29.443"></a><span id="l29.443" class="difflineplus">+#  define Z_HAVE_STDARG_H</span>
<a href="#l29.444"></a><span id="l29.444" class="difflineplus">+#endif</span>
<a href="#l29.445"></a><span id="l29.445" class="difflineplus">+</span>
<a href="#l29.446"></a><span id="l29.446" class="difflineplus">+#ifdef STDC</span>
<a href="#l29.447"></a><span id="l29.447" class="difflineplus">+#  ifndef Z_SOLO</span>
<a href="#l29.448"></a><span id="l29.448" class="difflineplus">+#    include &lt;sys/types.h&gt;      /* for off_t */</span>
<a href="#l29.449"></a><span id="l29.449" class="difflineplus">+#  endif</span>
<a href="#l29.450"></a><span id="l29.450" class="difflineplus">+#endif</span>
<a href="#l29.451"></a><span id="l29.451" class="difflineplus">+</span>
<a href="#l29.452"></a><span id="l29.452" class="difflineplus">+#if defined(STDC) || defined(Z_HAVE_STDARG_H)</span>
<a href="#l29.453"></a><span id="l29.453" class="difflineplus">+#  ifndef Z_SOLO</span>
<a href="#l29.454"></a><span id="l29.454" class="difflineplus">+#    include &lt;stdarg.h&gt;         /* for va_list */</span>
<a href="#l29.455"></a><span id="l29.455" class="difflineplus">+#  endif</span>
<a href="#l29.456"></a><span id="l29.456" class="difflineplus">+#endif</span>
<a href="#l29.457"></a><span id="l29.457" class="difflineplus">+</span>
<a href="#l29.458"></a><span id="l29.458" class="difflineplus">+#ifdef _WIN32</span>
<a href="#l29.459"></a><span id="l29.459" class="difflineplus">+#  ifndef Z_SOLO</span>
<a href="#l29.460"></a><span id="l29.460" class="difflineplus">+#    include &lt;stddef.h&gt;         /* for wchar_t */</span>
<a href="#l29.461"></a><span id="l29.461" class="difflineplus">+#  endif</span>
<a href="#l29.462"></a><span id="l29.462" class="difflineplus">+#endif</span>
<a href="#l29.463"></a><span id="l29.463" class="difflineplus">+</span>
<a href="#l29.464"></a><span id="l29.464" class="difflineplus">+/* a little trick to accommodate both &quot;#define _LARGEFILE64_SOURCE&quot; and</span>
<a href="#l29.465"></a><span id="l29.465" class="difflineplus">+ * &quot;#define _LARGEFILE64_SOURCE 1&quot; as requesting 64-bit operations, (even</span>
<a href="#l29.466"></a><span id="l29.466" class="difflineplus">+ * though the former does not conform to the LFS document), but considering</span>
<a href="#l29.467"></a><span id="l29.467" class="difflineplus">+ * both &quot;#undef _LARGEFILE64_SOURCE&quot; and &quot;#define _LARGEFILE64_SOURCE 0&quot; as</span>
<a href="#l29.468"></a><span id="l29.468" class="difflineplus">+ * equivalently requesting no 64-bit operations</span>
<a href="#l29.469"></a><span id="l29.469" class="difflineplus">+ */</span>
<a href="#l29.470"></a><span id="l29.470" class="difflineplus">+#if defined(_LARGEFILE64_SOURCE) &amp;&amp; -_LARGEFILE64_SOURCE - -1 == 1</span>
<a href="#l29.471"></a><span id="l29.471" class="difflineplus">+#  undef _LARGEFILE64_SOURCE</span>
<a href="#l29.472"></a><span id="l29.472" class="difflineplus">+#endif</span>
<a href="#l29.473"></a><span id="l29.473" class="difflineplus">+</span>
<a href="#l29.474"></a><span id="l29.474" class="difflineplus">+#if defined(__WATCOMC__) &amp;&amp; !defined(Z_HAVE_UNISTD_H)</span>
<a href="#l29.475"></a><span id="l29.475" class="difflineplus">+#  define Z_HAVE_UNISTD_H</span>
<a href="#l29.476"></a><span id="l29.476" class="difflineplus">+#endif</span>
<a href="#l29.477"></a><span id="l29.477" class="difflineplus">+#ifndef Z_SOLO</span>
<a href="#l29.478"></a><span id="l29.478" class="difflineplus">+#  if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)</span>
<a href="#l29.479"></a><span id="l29.479" class="difflineplus">+#    include &lt;unistd.h&gt;         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */</span>
<a href="#l29.480"></a><span id="l29.480" class="difflineplus">+#    ifdef VMS</span>
<a href="#l29.481"></a><span id="l29.481" class="difflineplus">+#      include &lt;unixio.h&gt;       /* for off_t */</span>
<a href="#l29.482"></a><span id="l29.482" class="difflineplus">+#    endif</span>
<a href="#l29.483"></a><span id="l29.483" class="difflineplus">+#    ifndef z_off_t</span>
<a href="#l29.484"></a><span id="l29.484" class="difflineplus">+#      define z_off_t off_t</span>
<a href="#l29.485"></a><span id="l29.485" class="difflineplus">+#    endif</span>
<a href="#l29.486"></a><span id="l29.486" class="difflineplus">+#  endif</span>
<a href="#l29.487"></a><span id="l29.487" class="difflineplus">+#endif</span>
<a href="#l29.488"></a><span id="l29.488" class="difflineplus">+</span>
<a href="#l29.489"></a><span id="l29.489" class="difflineplus">+#if defined(_LFS64_LARGEFILE) &amp;&amp; _LFS64_LARGEFILE-0</span>
<a href="#l29.490"></a><span id="l29.490" class="difflineplus">+#  define Z_LFS64</span>
<a href="#l29.491"></a><span id="l29.491" class="difflineplus">+#endif</span>
<a href="#l29.492"></a><span id="l29.492" class="difflineplus">+</span>
<a href="#l29.493"></a><span id="l29.493" class="difflineplus">+#if defined(_LARGEFILE64_SOURCE) &amp;&amp; defined(Z_LFS64)</span>
<a href="#l29.494"></a><span id="l29.494" class="difflineplus">+#  define Z_LARGE64</span>
<a href="#l29.495"></a><span id="l29.495" class="difflineplus">+#endif</span>
<a href="#l29.496"></a><span id="l29.496" class="difflineplus">+</span>
<a href="#l29.497"></a><span id="l29.497" class="difflineplus">+#if defined(_FILE_OFFSET_BITS) &amp;&amp; _FILE_OFFSET_BITS-0 == 64 &amp;&amp; defined(Z_LFS64)</span>
<a href="#l29.498"></a><span id="l29.498" class="difflineplus">+#  define Z_WANT64</span>
<a href="#l29.499"></a><span id="l29.499" class="difflineplus">+#endif</span>
<a href="#l29.500"></a><span id="l29.500" class="difflineplus">+</span>
<a href="#l29.501"></a><span id="l29.501" class="difflineplus">+#if !defined(SEEK_SET) &amp;&amp; !defined(Z_SOLO)</span>
<a href="#l29.502"></a><span id="l29.502" class="difflineplus">+#  define SEEK_SET        0       /* Seek from beginning of file.  */</span>
<a href="#l29.503"></a><span id="l29.503" class="difflineplus">+#  define SEEK_CUR        1       /* Seek from current position.  */</span>
<a href="#l29.504"></a><span id="l29.504" class="difflineplus">+#  define SEEK_END        2       /* Set file pointer to EOF plus &quot;offset&quot; */</span>
<a href="#l29.505"></a><span id="l29.505" class="difflineplus">+#endif</span>
<a href="#l29.506"></a><span id="l29.506" class="difflineplus">+</span>
<a href="#l29.507"></a><span id="l29.507" class="difflineplus">+#ifndef z_off_t</span>
<a href="#l29.508"></a><span id="l29.508" class="difflineplus">+#  define z_off_t long</span>
<a href="#l29.509"></a><span id="l29.509" class="difflineplus">+#endif</span>
<a href="#l29.510"></a><span id="l29.510" class="difflineplus">+</span>
<a href="#l29.511"></a><span id="l29.511" class="difflineplus">+#if !defined(_WIN32) &amp;&amp; defined(Z_LARGE64)</span>
<a href="#l29.512"></a><span id="l29.512" class="difflineplus">+#  define z_off64_t off64_t</span>
<a href="#l29.513"></a><span id="l29.513" class="difflineplus">+#else</span>
<a href="#l29.514"></a><span id="l29.514" class="difflineplus">+#  if defined(_WIN32) &amp;&amp; !defined(__GNUC__) &amp;&amp; !defined(Z_SOLO)</span>
<a href="#l29.515"></a><span id="l29.515" class="difflineplus">+#    define z_off64_t __int64</span>
<a href="#l29.516"></a><span id="l29.516" class="difflineplus">+#  else</span>
<a href="#l29.517"></a><span id="l29.517" class="difflineplus">+#    define z_off64_t z_off_t</span>
<a href="#l29.518"></a><span id="l29.518" class="difflineplus">+#  endif</span>
<a href="#l29.519"></a><span id="l29.519" class="difflineplus">+#endif</span>
<a href="#l29.520"></a><span id="l29.520" class="difflineplus">+</span>
<a href="#l29.521"></a><span id="l29.521" class="difflineplus">+/* MVS linker does not support external names larger than 8 bytes */</span>
<a href="#l29.522"></a><span id="l29.522" class="difflineplus">+#if defined(__MVS__)</span>
<a href="#l29.523"></a><span id="l29.523" class="difflineplus">+  #pragma map(deflateInit_,&quot;DEIN&quot;)</span>
<a href="#l29.524"></a><span id="l29.524" class="difflineplus">+  #pragma map(deflateInit2_,&quot;DEIN2&quot;)</span>
<a href="#l29.525"></a><span id="l29.525" class="difflineplus">+  #pragma map(deflateEnd,&quot;DEEND&quot;)</span>
<a href="#l29.526"></a><span id="l29.526" class="difflineplus">+  #pragma map(deflateBound,&quot;DEBND&quot;)</span>
<a href="#l29.527"></a><span id="l29.527" class="difflineplus">+  #pragma map(inflateInit_,&quot;ININ&quot;)</span>
<a href="#l29.528"></a><span id="l29.528" class="difflineplus">+  #pragma map(inflateInit2_,&quot;ININ2&quot;)</span>
<a href="#l29.529"></a><span id="l29.529" class="difflineplus">+  #pragma map(inflateEnd,&quot;INEND&quot;)</span>
<a href="#l29.530"></a><span id="l29.530" class="difflineplus">+  #pragma map(inflateSync,&quot;INSY&quot;)</span>
<a href="#l29.531"></a><span id="l29.531" class="difflineplus">+  #pragma map(inflateSetDictionary,&quot;INSEDI&quot;)</span>
<a href="#l29.532"></a><span id="l29.532" class="difflineplus">+  #pragma map(compressBound,&quot;CMBND&quot;)</span>
<a href="#l29.533"></a><span id="l29.533" class="difflineplus">+  #pragma map(inflate_table,&quot;INTABL&quot;)</span>
<a href="#l29.534"></a><span id="l29.534" class="difflineplus">+  #pragma map(inflate_fast,&quot;INFA&quot;)</span>
<a href="#l29.535"></a><span id="l29.535" class="difflineplus">+  #pragma map(inflate_copyright,&quot;INCOPY&quot;)</span>
<a href="#l29.536"></a><span id="l29.536" class="difflineplus">+#endif</span>
<a href="#l29.537"></a><span id="l29.537" class="difflineplus">+</span>
<a href="#l29.538"></a><span id="l29.538" class="difflineplus">+#endif /* ZCONF_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l30.1"></a><span id="l30.1">new file mode 100644</span>
<a href="#l30.2"></a><span id="l30.2" class="difflineminus">--- /dev/null</span>
<a href="#l30.3"></a><span id="l30.3" class="difflineplus">+++ b/third_party/zlib/zlib.def</span>
<a href="#l30.4"></a><span id="l30.4" class="difflineat">@@ -0,0 +1,94 @@</span>
<a href="#l30.5"></a><span id="l30.5" class="difflineplus">+; zlib data compression library</span>
<a href="#l30.6"></a><span id="l30.6" class="difflineplus">+EXPORTS</span>
<a href="#l30.7"></a><span id="l30.7" class="difflineplus">+; basic functions</span>
<a href="#l30.8"></a><span id="l30.8" class="difflineplus">+    zlibVersion</span>
<a href="#l30.9"></a><span id="l30.9" class="difflineplus">+    deflate</span>
<a href="#l30.10"></a><span id="l30.10" class="difflineplus">+    deflateEnd</span>
<a href="#l30.11"></a><span id="l30.11" class="difflineplus">+    inflate</span>
<a href="#l30.12"></a><span id="l30.12" class="difflineplus">+    inflateEnd</span>
<a href="#l30.13"></a><span id="l30.13" class="difflineplus">+; advanced functions</span>
<a href="#l30.14"></a><span id="l30.14" class="difflineplus">+    deflateSetDictionary</span>
<a href="#l30.15"></a><span id="l30.15" class="difflineplus">+    deflateGetDictionary</span>
<a href="#l30.16"></a><span id="l30.16" class="difflineplus">+    deflateCopy</span>
<a href="#l30.17"></a><span id="l30.17" class="difflineplus">+    deflateReset</span>
<a href="#l30.18"></a><span id="l30.18" class="difflineplus">+    deflateParams</span>
<a href="#l30.19"></a><span id="l30.19" class="difflineplus">+    deflateTune</span>
<a href="#l30.20"></a><span id="l30.20" class="difflineplus">+    deflateBound</span>
<a href="#l30.21"></a><span id="l30.21" class="difflineplus">+    deflatePending</span>
<a href="#l30.22"></a><span id="l30.22" class="difflineplus">+    deflatePrime</span>
<a href="#l30.23"></a><span id="l30.23" class="difflineplus">+    deflateSetHeader</span>
<a href="#l30.24"></a><span id="l30.24" class="difflineplus">+    inflateSetDictionary</span>
<a href="#l30.25"></a><span id="l30.25" class="difflineplus">+    inflateGetDictionary</span>
<a href="#l30.26"></a><span id="l30.26" class="difflineplus">+    inflateSync</span>
<a href="#l30.27"></a><span id="l30.27" class="difflineplus">+    inflateCopy</span>
<a href="#l30.28"></a><span id="l30.28" class="difflineplus">+    inflateReset</span>
<a href="#l30.29"></a><span id="l30.29" class="difflineplus">+    inflateReset2</span>
<a href="#l30.30"></a><span id="l30.30" class="difflineplus">+    inflatePrime</span>
<a href="#l30.31"></a><span id="l30.31" class="difflineplus">+    inflateMark</span>
<a href="#l30.32"></a><span id="l30.32" class="difflineplus">+    inflateGetHeader</span>
<a href="#l30.33"></a><span id="l30.33" class="difflineplus">+    inflateBack</span>
<a href="#l30.34"></a><span id="l30.34" class="difflineplus">+    inflateBackEnd</span>
<a href="#l30.35"></a><span id="l30.35" class="difflineplus">+    zlibCompileFlags</span>
<a href="#l30.36"></a><span id="l30.36" class="difflineplus">+; utility functions</span>
<a href="#l30.37"></a><span id="l30.37" class="difflineplus">+    compress</span>
<a href="#l30.38"></a><span id="l30.38" class="difflineplus">+    compress2</span>
<a href="#l30.39"></a><span id="l30.39" class="difflineplus">+    compressBound</span>
<a href="#l30.40"></a><span id="l30.40" class="difflineplus">+    uncompress</span>
<a href="#l30.41"></a><span id="l30.41" class="difflineplus">+    uncompress2</span>
<a href="#l30.42"></a><span id="l30.42" class="difflineplus">+    gzopen</span>
<a href="#l30.43"></a><span id="l30.43" class="difflineplus">+    gzdopen</span>
<a href="#l30.44"></a><span id="l30.44" class="difflineplus">+    gzbuffer</span>
<a href="#l30.45"></a><span id="l30.45" class="difflineplus">+    gzsetparams</span>
<a href="#l30.46"></a><span id="l30.46" class="difflineplus">+    gzread</span>
<a href="#l30.47"></a><span id="l30.47" class="difflineplus">+    gzfread</span>
<a href="#l30.48"></a><span id="l30.48" class="difflineplus">+    gzwrite</span>
<a href="#l30.49"></a><span id="l30.49" class="difflineplus">+    gzfwrite</span>
<a href="#l30.50"></a><span id="l30.50" class="difflineplus">+    gzprintf</span>
<a href="#l30.51"></a><span id="l30.51" class="difflineplus">+    gzvprintf</span>
<a href="#l30.52"></a><span id="l30.52" class="difflineplus">+    gzputs</span>
<a href="#l30.53"></a><span id="l30.53" class="difflineplus">+    gzgets</span>
<a href="#l30.54"></a><span id="l30.54" class="difflineplus">+    gzputc</span>
<a href="#l30.55"></a><span id="l30.55" class="difflineplus">+    gzgetc</span>
<a href="#l30.56"></a><span id="l30.56" class="difflineplus">+    gzungetc</span>
<a href="#l30.57"></a><span id="l30.57" class="difflineplus">+    gzflush</span>
<a href="#l30.58"></a><span id="l30.58" class="difflineplus">+    gzseek</span>
<a href="#l30.59"></a><span id="l30.59" class="difflineplus">+    gzrewind</span>
<a href="#l30.60"></a><span id="l30.60" class="difflineplus">+    gztell</span>
<a href="#l30.61"></a><span id="l30.61" class="difflineplus">+    gzoffset</span>
<a href="#l30.62"></a><span id="l30.62" class="difflineplus">+    gzeof</span>
<a href="#l30.63"></a><span id="l30.63" class="difflineplus">+    gzdirect</span>
<a href="#l30.64"></a><span id="l30.64" class="difflineplus">+    gzclose</span>
<a href="#l30.65"></a><span id="l30.65" class="difflineplus">+    gzclose_r</span>
<a href="#l30.66"></a><span id="l30.66" class="difflineplus">+    gzclose_w</span>
<a href="#l30.67"></a><span id="l30.67" class="difflineplus">+    gzerror</span>
<a href="#l30.68"></a><span id="l30.68" class="difflineplus">+    gzclearerr</span>
<a href="#l30.69"></a><span id="l30.69" class="difflineplus">+; large file functions</span>
<a href="#l30.70"></a><span id="l30.70" class="difflineplus">+    gzopen64</span>
<a href="#l30.71"></a><span id="l30.71" class="difflineplus">+    gzseek64</span>
<a href="#l30.72"></a><span id="l30.72" class="difflineplus">+    gztell64</span>
<a href="#l30.73"></a><span id="l30.73" class="difflineplus">+    gzoffset64</span>
<a href="#l30.74"></a><span id="l30.74" class="difflineplus">+    adler32_combine64</span>
<a href="#l30.75"></a><span id="l30.75" class="difflineplus">+    crc32_combine64</span>
<a href="#l30.76"></a><span id="l30.76" class="difflineplus">+; checksum functions</span>
<a href="#l30.77"></a><span id="l30.77" class="difflineplus">+    adler32</span>
<a href="#l30.78"></a><span id="l30.78" class="difflineplus">+    adler32_z</span>
<a href="#l30.79"></a><span id="l30.79" class="difflineplus">+    crc32</span>
<a href="#l30.80"></a><span id="l30.80" class="difflineplus">+    crc32_z</span>
<a href="#l30.81"></a><span id="l30.81" class="difflineplus">+    adler32_combine</span>
<a href="#l30.82"></a><span id="l30.82" class="difflineplus">+    crc32_combine</span>
<a href="#l30.83"></a><span id="l30.83" class="difflineplus">+; various hacks, don't look :)</span>
<a href="#l30.84"></a><span id="l30.84" class="difflineplus">+    deflateInit_</span>
<a href="#l30.85"></a><span id="l30.85" class="difflineplus">+    deflateInit2_</span>
<a href="#l30.86"></a><span id="l30.86" class="difflineplus">+    inflateInit_</span>
<a href="#l30.87"></a><span id="l30.87" class="difflineplus">+    inflateInit2_</span>
<a href="#l30.88"></a><span id="l30.88" class="difflineplus">+    inflateBackInit_</span>
<a href="#l30.89"></a><span id="l30.89" class="difflineplus">+    gzgetc_</span>
<a href="#l30.90"></a><span id="l30.90" class="difflineplus">+    zError</span>
<a href="#l30.91"></a><span id="l30.91" class="difflineplus">+    inflateSyncPoint</span>
<a href="#l30.92"></a><span id="l30.92" class="difflineplus">+    get_crc_table</span>
<a href="#l30.93"></a><span id="l30.93" class="difflineplus">+    inflateUndermine</span>
<a href="#l30.94"></a><span id="l30.94" class="difflineplus">+    inflateValidate</span>
<a href="#l30.95"></a><span id="l30.95" class="difflineplus">+    inflateCodesUsed</span>
<a href="#l30.96"></a><span id="l30.96" class="difflineplus">+    inflateResetKeep</span>
<a href="#l30.97"></a><span id="l30.97" class="difflineplus">+    deflateResetKeep</span>
<a href="#l30.98"></a><span id="l30.98" class="difflineplus">+    gzopen_w</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l31.1"></a><span id="l31.1">new file mode 100644</span>
<a href="#l31.2"></a><span id="l31.2" class="difflineminus">--- /dev/null</span>
<a href="#l31.3"></a><span id="l31.3" class="difflineplus">+++ b/third_party/zlib/zlib.h</span>
<a href="#l31.4"></a><span id="l31.4" class="difflineat">@@ -0,0 +1,1912 @@</span>
<a href="#l31.5"></a><span id="l31.5" class="difflineplus">+/* zlib.h -- interface of the 'zlib' general purpose compression library</span>
<a href="#l31.6"></a><span id="l31.6" class="difflineplus">+  version 1.2.11, January 15th, 2017</span>
<a href="#l31.7"></a><span id="l31.7" class="difflineplus">+</span>
<a href="#l31.8"></a><span id="l31.8" class="difflineplus">+  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler</span>
<a href="#l31.9"></a><span id="l31.9" class="difflineplus">+</span>
<a href="#l31.10"></a><span id="l31.10" class="difflineplus">+  This software is provided 'as-is', without any express or implied</span>
<a href="#l31.11"></a><span id="l31.11" class="difflineplus">+  warranty.  In no event will the authors be held liable for any damages</span>
<a href="#l31.12"></a><span id="l31.12" class="difflineplus">+  arising from the use of this software.</span>
<a href="#l31.13"></a><span id="l31.13" class="difflineplus">+</span>
<a href="#l31.14"></a><span id="l31.14" class="difflineplus">+  Permission is granted to anyone to use this software for any purpose,</span>
<a href="#l31.15"></a><span id="l31.15" class="difflineplus">+  including commercial applications, and to alter it and redistribute it</span>
<a href="#l31.16"></a><span id="l31.16" class="difflineplus">+  freely, subject to the following restrictions:</span>
<a href="#l31.17"></a><span id="l31.17" class="difflineplus">+</span>
<a href="#l31.18"></a><span id="l31.18" class="difflineplus">+  1. The origin of this software must not be misrepresented; you must not</span>
<a href="#l31.19"></a><span id="l31.19" class="difflineplus">+     claim that you wrote the original software. If you use this software</span>
<a href="#l31.20"></a><span id="l31.20" class="difflineplus">+     in a product, an acknowledgment in the product documentation would be</span>
<a href="#l31.21"></a><span id="l31.21" class="difflineplus">+     appreciated but is not required.</span>
<a href="#l31.22"></a><span id="l31.22" class="difflineplus">+  2. Altered source versions must be plainly marked as such, and must not be</span>
<a href="#l31.23"></a><span id="l31.23" class="difflineplus">+     misrepresented as being the original software.</span>
<a href="#l31.24"></a><span id="l31.24" class="difflineplus">+  3. This notice may not be removed or altered from any source distribution.</span>
<a href="#l31.25"></a><span id="l31.25" class="difflineplus">+</span>
<a href="#l31.26"></a><span id="l31.26" class="difflineplus">+  Jean-loup Gailly        Mark Adler</span>
<a href="#l31.27"></a><span id="l31.27" class="difflineplus">+  jloup@gzip.org          madler@alumni.caltech.edu</span>
<a href="#l31.28"></a><span id="l31.28" class="difflineplus">+</span>
<a href="#l31.29"></a><span id="l31.29" class="difflineplus">+</span>
<a href="#l31.30"></a><span id="l31.30" class="difflineplus">+  The data format used by the zlib library is described by RFCs (Request for</span>
<a href="#l31.31"></a><span id="l31.31" class="difflineplus">+  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950</span>
<a href="#l31.32"></a><span id="l31.32" class="difflineplus">+  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).</span>
<a href="#l31.33"></a><span id="l31.33" class="difflineplus">+*/</span>
<a href="#l31.34"></a><span id="l31.34" class="difflineplus">+</span>
<a href="#l31.35"></a><span id="l31.35" class="difflineplus">+#ifndef ZLIB_H</span>
<a href="#l31.36"></a><span id="l31.36" class="difflineplus">+#define ZLIB_H</span>
<a href="#l31.37"></a><span id="l31.37" class="difflineplus">+</span>
<a href="#l31.38"></a><span id="l31.38" class="difflineplus">+#include &quot;zconf.h&quot;</span>
<a href="#l31.39"></a><span id="l31.39" class="difflineplus">+</span>
<a href="#l31.40"></a><span id="l31.40" class="difflineplus">+#ifdef __cplusplus</span>
<a href="#l31.41"></a><span id="l31.41" class="difflineplus">+extern &quot;C&quot; {</span>
<a href="#l31.42"></a><span id="l31.42" class="difflineplus">+#endif</span>
<a href="#l31.43"></a><span id="l31.43" class="difflineplus">+</span>
<a href="#l31.44"></a><span id="l31.44" class="difflineplus">+#define ZLIB_VERSION &quot;1.2.11&quot;</span>
<a href="#l31.45"></a><span id="l31.45" class="difflineplus">+#define ZLIB_VERNUM 0x12b0</span>
<a href="#l31.46"></a><span id="l31.46" class="difflineplus">+#define ZLIB_VER_MAJOR 1</span>
<a href="#l31.47"></a><span id="l31.47" class="difflineplus">+#define ZLIB_VER_MINOR 2</span>
<a href="#l31.48"></a><span id="l31.48" class="difflineplus">+#define ZLIB_VER_REVISION 11</span>
<a href="#l31.49"></a><span id="l31.49" class="difflineplus">+#define ZLIB_VER_SUBREVISION 0</span>
<a href="#l31.50"></a><span id="l31.50" class="difflineplus">+</span>
<a href="#l31.51"></a><span id="l31.51" class="difflineplus">+/*</span>
<a href="#l31.52"></a><span id="l31.52" class="difflineplus">+    The 'zlib' compression library provides in-memory compression and</span>
<a href="#l31.53"></a><span id="l31.53" class="difflineplus">+  decompression functions, including integrity checks of the uncompressed data.</span>
<a href="#l31.54"></a><span id="l31.54" class="difflineplus">+  This version of the library supports only one compression method (deflation)</span>
<a href="#l31.55"></a><span id="l31.55" class="difflineplus">+  but other algorithms will be added later and will have the same stream</span>
<a href="#l31.56"></a><span id="l31.56" class="difflineplus">+  interface.</span>
<a href="#l31.57"></a><span id="l31.57" class="difflineplus">+</span>
<a href="#l31.58"></a><span id="l31.58" class="difflineplus">+    Compression can be done in a single step if the buffers are large enough,</span>
<a href="#l31.59"></a><span id="l31.59" class="difflineplus">+  or can be done by repeated calls of the compression function.  In the latter</span>
<a href="#l31.60"></a><span id="l31.60" class="difflineplus">+  case, the application must provide more input and/or consume the output</span>
<a href="#l31.61"></a><span id="l31.61" class="difflineplus">+  (providing more output space) before each call.</span>
<a href="#l31.62"></a><span id="l31.62" class="difflineplus">+</span>
<a href="#l31.63"></a><span id="l31.63" class="difflineplus">+    The compressed data format used by default by the in-memory functions is</span>
<a href="#l31.64"></a><span id="l31.64" class="difflineplus">+  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped</span>
<a href="#l31.65"></a><span id="l31.65" class="difflineplus">+  around a deflate stream, which is itself documented in RFC 1951.</span>
<a href="#l31.66"></a><span id="l31.66" class="difflineplus">+</span>
<a href="#l31.67"></a><span id="l31.67" class="difflineplus">+    The library also supports reading and writing files in gzip (.gz) format</span>
<a href="#l31.68"></a><span id="l31.68" class="difflineplus">+  with an interface similar to that of stdio using the functions that start</span>
<a href="#l31.69"></a><span id="l31.69" class="difflineplus">+  with &quot;gz&quot;.  The gzip format is different from the zlib format.  gzip is a</span>
<a href="#l31.70"></a><span id="l31.70" class="difflineplus">+  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.</span>
<a href="#l31.71"></a><span id="l31.71" class="difflineplus">+</span>
<a href="#l31.72"></a><span id="l31.72" class="difflineplus">+    This library can optionally read and write gzip and raw deflate streams in</span>
<a href="#l31.73"></a><span id="l31.73" class="difflineplus">+  memory as well.</span>
<a href="#l31.74"></a><span id="l31.74" class="difflineplus">+</span>
<a href="#l31.75"></a><span id="l31.75" class="difflineplus">+    The zlib format was designed to be compact and fast for use in memory</span>
<a href="#l31.76"></a><span id="l31.76" class="difflineplus">+  and on communications channels.  The gzip format was designed for single-</span>
<a href="#l31.77"></a><span id="l31.77" class="difflineplus">+  file compression on file systems, has a larger header than zlib to maintain</span>
<a href="#l31.78"></a><span id="l31.78" class="difflineplus">+  directory information, and uses a different, slower check method than zlib.</span>
<a href="#l31.79"></a><span id="l31.79" class="difflineplus">+</span>
<a href="#l31.80"></a><span id="l31.80" class="difflineplus">+    The library does not install any signal handler.  The decoder checks</span>
<a href="#l31.81"></a><span id="l31.81" class="difflineplus">+  the consistency of the compressed data, so the library should never crash</span>
<a href="#l31.82"></a><span id="l31.82" class="difflineplus">+  even in the case of corrupted input.</span>
<a href="#l31.83"></a><span id="l31.83" class="difflineplus">+*/</span>
<a href="#l31.84"></a><span id="l31.84" class="difflineplus">+</span>
<a href="#l31.85"></a><span id="l31.85" class="difflineplus">+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));</span>
<a href="#l31.86"></a><span id="l31.86" class="difflineplus">+typedef void   (*free_func)  OF((voidpf opaque, voidpf address));</span>
<a href="#l31.87"></a><span id="l31.87" class="difflineplus">+</span>
<a href="#l31.88"></a><span id="l31.88" class="difflineplus">+struct internal_state;</span>
<a href="#l31.89"></a><span id="l31.89" class="difflineplus">+</span>
<a href="#l31.90"></a><span id="l31.90" class="difflineplus">+typedef struct z_stream_s {</span>
<a href="#l31.91"></a><span id="l31.91" class="difflineplus">+    z_const Bytef *next_in;     /* next input byte */</span>
<a href="#l31.92"></a><span id="l31.92" class="difflineplus">+    uInt     avail_in;  /* number of bytes available at next_in */</span>
<a href="#l31.93"></a><span id="l31.93" class="difflineplus">+    uLong    total_in;  /* total number of input bytes read so far */</span>
<a href="#l31.94"></a><span id="l31.94" class="difflineplus">+</span>
<a href="#l31.95"></a><span id="l31.95" class="difflineplus">+    Bytef    *next_out; /* next output byte will go here */</span>
<a href="#l31.96"></a><span id="l31.96" class="difflineplus">+    uInt     avail_out; /* remaining free space at next_out */</span>
<a href="#l31.97"></a><span id="l31.97" class="difflineplus">+    uLong    total_out; /* total number of bytes output so far */</span>
<a href="#l31.98"></a><span id="l31.98" class="difflineplus">+</span>
<a href="#l31.99"></a><span id="l31.99" class="difflineplus">+    z_const char *msg;  /* last error message, NULL if no error */</span>
<a href="#l31.100"></a><span id="l31.100" class="difflineplus">+    struct internal_state FAR *state; /* not visible by applications */</span>
<a href="#l31.101"></a><span id="l31.101" class="difflineplus">+</span>
<a href="#l31.102"></a><span id="l31.102" class="difflineplus">+    alloc_func zalloc;  /* used to allocate the internal state */</span>
<a href="#l31.103"></a><span id="l31.103" class="difflineplus">+    free_func  zfree;   /* used to free the internal state */</span>
<a href="#l31.104"></a><span id="l31.104" class="difflineplus">+    voidpf     opaque;  /* private data object passed to zalloc and zfree */</span>
<a href="#l31.105"></a><span id="l31.105" class="difflineplus">+</span>
<a href="#l31.106"></a><span id="l31.106" class="difflineplus">+    int     data_type;  /* best guess about the data type: binary or text</span>
<a href="#l31.107"></a><span id="l31.107" class="difflineplus">+                           for deflate, or the decoding state for inflate */</span>
<a href="#l31.108"></a><span id="l31.108" class="difflineplus">+    uLong   adler;      /* Adler-32 or CRC-32 value of the uncompressed data */</span>
<a href="#l31.109"></a><span id="l31.109" class="difflineplus">+    uLong   reserved;   /* reserved for future use */</span>
<a href="#l31.110"></a><span id="l31.110" class="difflineplus">+} z_stream;</span>
<a href="#l31.111"></a><span id="l31.111" class="difflineplus">+</span>
<a href="#l31.112"></a><span id="l31.112" class="difflineplus">+typedef z_stream FAR *z_streamp;</span>
<a href="#l31.113"></a><span id="l31.113" class="difflineplus">+</span>
<a href="#l31.114"></a><span id="l31.114" class="difflineplus">+/*</span>
<a href="#l31.115"></a><span id="l31.115" class="difflineplus">+     gzip header information passed to and from zlib routines.  See RFC 1952</span>
<a href="#l31.116"></a><span id="l31.116" class="difflineplus">+  for more details on the meanings of these fields.</span>
<a href="#l31.117"></a><span id="l31.117" class="difflineplus">+*/</span>
<a href="#l31.118"></a><span id="l31.118" class="difflineplus">+typedef struct gz_header_s {</span>
<a href="#l31.119"></a><span id="l31.119" class="difflineplus">+    int     text;       /* true if compressed data believed to be text */</span>
<a href="#l31.120"></a><span id="l31.120" class="difflineplus">+    uLong   time;       /* modification time */</span>
<a href="#l31.121"></a><span id="l31.121" class="difflineplus">+    int     xflags;     /* extra flags (not used when writing a gzip file) */</span>
<a href="#l31.122"></a><span id="l31.122" class="difflineplus">+    int     os;         /* operating system */</span>
<a href="#l31.123"></a><span id="l31.123" class="difflineplus">+    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */</span>
<a href="#l31.124"></a><span id="l31.124" class="difflineplus">+    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */</span>
<a href="#l31.125"></a><span id="l31.125" class="difflineplus">+    uInt    extra_max;  /* space at extra (only when reading header) */</span>
<a href="#l31.126"></a><span id="l31.126" class="difflineplus">+    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */</span>
<a href="#l31.127"></a><span id="l31.127" class="difflineplus">+    uInt    name_max;   /* space at name (only when reading header) */</span>
<a href="#l31.128"></a><span id="l31.128" class="difflineplus">+    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */</span>
<a href="#l31.129"></a><span id="l31.129" class="difflineplus">+    uInt    comm_max;   /* space at comment (only when reading header) */</span>
<a href="#l31.130"></a><span id="l31.130" class="difflineplus">+    int     hcrc;       /* true if there was or will be a header crc */</span>
<a href="#l31.131"></a><span id="l31.131" class="difflineplus">+    int     done;       /* true when done reading gzip header (not used</span>
<a href="#l31.132"></a><span id="l31.132" class="difflineplus">+                           when writing a gzip file) */</span>
<a href="#l31.133"></a><span id="l31.133" class="difflineplus">+} gz_header;</span>
<a href="#l31.134"></a><span id="l31.134" class="difflineplus">+</span>
<a href="#l31.135"></a><span id="l31.135" class="difflineplus">+typedef gz_header FAR *gz_headerp;</span>
<a href="#l31.136"></a><span id="l31.136" class="difflineplus">+</span>
<a href="#l31.137"></a><span id="l31.137" class="difflineplus">+/*</span>
<a href="#l31.138"></a><span id="l31.138" class="difflineplus">+     The application must update next_in and avail_in when avail_in has dropped</span>
<a href="#l31.139"></a><span id="l31.139" class="difflineplus">+   to zero.  It must update next_out and avail_out when avail_out has dropped</span>
<a href="#l31.140"></a><span id="l31.140" class="difflineplus">+   to zero.  The application must initialize zalloc, zfree and opaque before</span>
<a href="#l31.141"></a><span id="l31.141" class="difflineplus">+   calling the init function.  All other fields are set by the compression</span>
<a href="#l31.142"></a><span id="l31.142" class="difflineplus">+   library and must not be updated by the application.</span>
<a href="#l31.143"></a><span id="l31.143" class="difflineplus">+</span>
<a href="#l31.144"></a><span id="l31.144" class="difflineplus">+     The opaque value provided by the application will be passed as the first</span>
<a href="#l31.145"></a><span id="l31.145" class="difflineplus">+   parameter for calls of zalloc and zfree.  This can be useful for custom</span>
<a href="#l31.146"></a><span id="l31.146" class="difflineplus">+   memory management.  The compression library attaches no meaning to the</span>
<a href="#l31.147"></a><span id="l31.147" class="difflineplus">+   opaque value.</span>
<a href="#l31.148"></a><span id="l31.148" class="difflineplus">+</span>
<a href="#l31.149"></a><span id="l31.149" class="difflineplus">+     zalloc must return Z_NULL if there is not enough memory for the object.</span>
<a href="#l31.150"></a><span id="l31.150" class="difflineplus">+   If zlib is used in a multi-threaded application, zalloc and zfree must be</span>
<a href="#l31.151"></a><span id="l31.151" class="difflineplus">+   thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are</span>
<a href="#l31.152"></a><span id="l31.152" class="difflineplus">+   Z_NULL on entry to the initialization function, they are set to internal</span>
<a href="#l31.153"></a><span id="l31.153" class="difflineplus">+   routines that use the standard library functions malloc() and free().</span>
<a href="#l31.154"></a><span id="l31.154" class="difflineplus">+</span>
<a href="#l31.155"></a><span id="l31.155" class="difflineplus">+     On 16-bit systems, the functions zalloc and zfree must be able to allocate</span>
<a href="#l31.156"></a><span id="l31.156" class="difflineplus">+   exactly 65536 bytes, but will not be required to allocate more than this if</span>
<a href="#l31.157"></a><span id="l31.157" class="difflineplus">+   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers</span>
<a href="#l31.158"></a><span id="l31.158" class="difflineplus">+   returned by zalloc for objects of exactly 65536 bytes *must* have their</span>
<a href="#l31.159"></a><span id="l31.159" class="difflineplus">+   offset normalized to zero.  The default allocation function provided by this</span>
<a href="#l31.160"></a><span id="l31.160" class="difflineplus">+   library ensures this (see zutil.c).  To reduce memory requirements and avoid</span>
<a href="#l31.161"></a><span id="l31.161" class="difflineplus">+   any allocation of 64K objects, at the expense of compression ratio, compile</span>
<a href="#l31.162"></a><span id="l31.162" class="difflineplus">+   the library with -DMAX_WBITS=14 (see zconf.h).</span>
<a href="#l31.163"></a><span id="l31.163" class="difflineplus">+</span>
<a href="#l31.164"></a><span id="l31.164" class="difflineplus">+     The fields total_in and total_out can be used for statistics or progress</span>
<a href="#l31.165"></a><span id="l31.165" class="difflineplus">+   reports.  After compression, total_in holds the total size of the</span>
<a href="#l31.166"></a><span id="l31.166" class="difflineplus">+   uncompressed data and may be saved for use by the decompressor (particularly</span>
<a href="#l31.167"></a><span id="l31.167" class="difflineplus">+   if the decompressor wants to decompress everything in a single step).</span>
<a href="#l31.168"></a><span id="l31.168" class="difflineplus">+*/</span>
<a href="#l31.169"></a><span id="l31.169" class="difflineplus">+</span>
<a href="#l31.170"></a><span id="l31.170" class="difflineplus">+                        /* constants */</span>
<a href="#l31.171"></a><span id="l31.171" class="difflineplus">+</span>
<a href="#l31.172"></a><span id="l31.172" class="difflineplus">+#define Z_NO_FLUSH      0</span>
<a href="#l31.173"></a><span id="l31.173" class="difflineplus">+#define Z_PARTIAL_FLUSH 1</span>
<a href="#l31.174"></a><span id="l31.174" class="difflineplus">+#define Z_SYNC_FLUSH    2</span>
<a href="#l31.175"></a><span id="l31.175" class="difflineplus">+#define Z_FULL_FLUSH    3</span>
<a href="#l31.176"></a><span id="l31.176" class="difflineplus">+#define Z_FINISH        4</span>
<a href="#l31.177"></a><span id="l31.177" class="difflineplus">+#define Z_BLOCK         5</span>
<a href="#l31.178"></a><span id="l31.178" class="difflineplus">+#define Z_TREES         6</span>
<a href="#l31.179"></a><span id="l31.179" class="difflineplus">+/* Allowed flush values; see deflate() and inflate() below for details */</span>
<a href="#l31.180"></a><span id="l31.180" class="difflineplus">+</span>
<a href="#l31.181"></a><span id="l31.181" class="difflineplus">+#define Z_OK            0</span>
<a href="#l31.182"></a><span id="l31.182" class="difflineplus">+#define Z_STREAM_END    1</span>
<a href="#l31.183"></a><span id="l31.183" class="difflineplus">+#define Z_NEED_DICT     2</span>
<a href="#l31.184"></a><span id="l31.184" class="difflineplus">+#define Z_ERRNO        (-1)</span>
<a href="#l31.185"></a><span id="l31.185" class="difflineplus">+#define Z_STREAM_ERROR (-2)</span>
<a href="#l31.186"></a><span id="l31.186" class="difflineplus">+#define Z_DATA_ERROR   (-3)</span>
<a href="#l31.187"></a><span id="l31.187" class="difflineplus">+#define Z_MEM_ERROR    (-4)</span>
<a href="#l31.188"></a><span id="l31.188" class="difflineplus">+#define Z_BUF_ERROR    (-5)</span>
<a href="#l31.189"></a><span id="l31.189" class="difflineplus">+#define Z_VERSION_ERROR (-6)</span>
<a href="#l31.190"></a><span id="l31.190" class="difflineplus">+/* Return codes for the compression/decompression functions. Negative values</span>
<a href="#l31.191"></a><span id="l31.191" class="difflineplus">+ * are errors, positive values are used for special but normal events.</span>
<a href="#l31.192"></a><span id="l31.192" class="difflineplus">+ */</span>
<a href="#l31.193"></a><span id="l31.193" class="difflineplus">+</span>
<a href="#l31.194"></a><span id="l31.194" class="difflineplus">+#define Z_NO_COMPRESSION         0</span>
<a href="#l31.195"></a><span id="l31.195" class="difflineplus">+#define Z_BEST_SPEED             1</span>
<a href="#l31.196"></a><span id="l31.196" class="difflineplus">+#define Z_BEST_COMPRESSION       9</span>
<a href="#l31.197"></a><span id="l31.197" class="difflineplus">+#define Z_DEFAULT_COMPRESSION  (-1)</span>
<a href="#l31.198"></a><span id="l31.198" class="difflineplus">+/* compression levels */</span>
<a href="#l31.199"></a><span id="l31.199" class="difflineplus">+</span>
<a href="#l31.200"></a><span id="l31.200" class="difflineplus">+#define Z_FILTERED            1</span>
<a href="#l31.201"></a><span id="l31.201" class="difflineplus">+#define Z_HUFFMAN_ONLY        2</span>
<a href="#l31.202"></a><span id="l31.202" class="difflineplus">+#define Z_RLE                 3</span>
<a href="#l31.203"></a><span id="l31.203" class="difflineplus">+#define Z_FIXED               4</span>
<a href="#l31.204"></a><span id="l31.204" class="difflineplus">+#define Z_DEFAULT_STRATEGY    0</span>
<a href="#l31.205"></a><span id="l31.205" class="difflineplus">+/* compression strategy; see deflateInit2() below for details */</span>
<a href="#l31.206"></a><span id="l31.206" class="difflineplus">+</span>
<a href="#l31.207"></a><span id="l31.207" class="difflineplus">+#define Z_BINARY   0</span>
<a href="#l31.208"></a><span id="l31.208" class="difflineplus">+#define Z_TEXT     1</span>
<a href="#l31.209"></a><span id="l31.209" class="difflineplus">+#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */</span>
<a href="#l31.210"></a><span id="l31.210" class="difflineplus">+#define Z_UNKNOWN  2</span>
<a href="#l31.211"></a><span id="l31.211" class="difflineplus">+/* Possible values of the data_type field for deflate() */</span>
<a href="#l31.212"></a><span id="l31.212" class="difflineplus">+</span>
<a href="#l31.213"></a><span id="l31.213" class="difflineplus">+#define Z_DEFLATED   8</span>
<a href="#l31.214"></a><span id="l31.214" class="difflineplus">+/* The deflate compression method (the only one supported in this version) */</span>
<a href="#l31.215"></a><span id="l31.215" class="difflineplus">+</span>
<a href="#l31.216"></a><span id="l31.216" class="difflineplus">+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */</span>
<a href="#l31.217"></a><span id="l31.217" class="difflineplus">+</span>
<a href="#l31.218"></a><span id="l31.218" class="difflineplus">+#define zlib_version zlibVersion()</span>
<a href="#l31.219"></a><span id="l31.219" class="difflineplus">+/* for compatibility with versions &lt; 1.0.2 */</span>
<a href="#l31.220"></a><span id="l31.220" class="difflineplus">+</span>
<a href="#l31.221"></a><span id="l31.221" class="difflineplus">+</span>
<a href="#l31.222"></a><span id="l31.222" class="difflineplus">+                        /* basic functions */</span>
<a href="#l31.223"></a><span id="l31.223" class="difflineplus">+</span>
<a href="#l31.224"></a><span id="l31.224" class="difflineplus">+ZEXTERN const char * ZEXPORT zlibVersion OF((void));</span>
<a href="#l31.225"></a><span id="l31.225" class="difflineplus">+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.</span>
<a href="#l31.226"></a><span id="l31.226" class="difflineplus">+   If the first character differs, the library code actually used is not</span>
<a href="#l31.227"></a><span id="l31.227" class="difflineplus">+   compatible with the zlib.h header file used by the application.  This check</span>
<a href="#l31.228"></a><span id="l31.228" class="difflineplus">+   is automatically made by deflateInit and inflateInit.</span>
<a href="#l31.229"></a><span id="l31.229" class="difflineplus">+ */</span>
<a href="#l31.230"></a><span id="l31.230" class="difflineplus">+</span>
<a href="#l31.231"></a><span id="l31.231" class="difflineplus">+/*</span>
<a href="#l31.232"></a><span id="l31.232" class="difflineplus">+ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));</span>
<a href="#l31.233"></a><span id="l31.233" class="difflineplus">+</span>
<a href="#l31.234"></a><span id="l31.234" class="difflineplus">+     Initializes the internal stream state for compression.  The fields</span>
<a href="#l31.235"></a><span id="l31.235" class="difflineplus">+   zalloc, zfree and opaque must be initialized before by the caller.  If</span>
<a href="#l31.236"></a><span id="l31.236" class="difflineplus">+   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default</span>
<a href="#l31.237"></a><span id="l31.237" class="difflineplus">+   allocation functions.</span>
<a href="#l31.238"></a><span id="l31.238" class="difflineplus">+</span>
<a href="#l31.239"></a><span id="l31.239" class="difflineplus">+     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:</span>
<a href="#l31.240"></a><span id="l31.240" class="difflineplus">+   1 gives best speed, 9 gives best compression, 0 gives no compression at all</span>
<a href="#l31.241"></a><span id="l31.241" class="difflineplus">+   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION</span>
<a href="#l31.242"></a><span id="l31.242" class="difflineplus">+   requests a default compromise between speed and compression (currently</span>
<a href="#l31.243"></a><span id="l31.243" class="difflineplus">+   equivalent to level 6).</span>
<a href="#l31.244"></a><span id="l31.244" class="difflineplus">+</span>
<a href="#l31.245"></a><span id="l31.245" class="difflineplus">+     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
<a href="#l31.246"></a><span id="l31.246" class="difflineplus">+   memory, Z_STREAM_ERROR if level is not a valid compression level, or</span>
<a href="#l31.247"></a><span id="l31.247" class="difflineplus">+   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible</span>
<a href="#l31.248"></a><span id="l31.248" class="difflineplus">+   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null</span>
<a href="#l31.249"></a><span id="l31.249" class="difflineplus">+   if there is no error message.  deflateInit does not perform any compression:</span>
<a href="#l31.250"></a><span id="l31.250" class="difflineplus">+   this will be done by deflate().</span>
<a href="#l31.251"></a><span id="l31.251" class="difflineplus">+*/</span>
<a href="#l31.252"></a><span id="l31.252" class="difflineplus">+</span>
<a href="#l31.253"></a><span id="l31.253" class="difflineplus">+</span>
<a href="#l31.254"></a><span id="l31.254" class="difflineplus">+ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));</span>
<a href="#l31.255"></a><span id="l31.255" class="difflineplus">+/*</span>
<a href="#l31.256"></a><span id="l31.256" class="difflineplus">+    deflate compresses as much data as possible, and stops when the input</span>
<a href="#l31.257"></a><span id="l31.257" class="difflineplus">+  buffer becomes empty or the output buffer becomes full.  It may introduce</span>
<a href="#l31.258"></a><span id="l31.258" class="difflineplus">+  some output latency (reading input without producing any output) except when</span>
<a href="#l31.259"></a><span id="l31.259" class="difflineplus">+  forced to flush.</span>
<a href="#l31.260"></a><span id="l31.260" class="difflineplus">+</span>
<a href="#l31.261"></a><span id="l31.261" class="difflineplus">+    The detailed semantics are as follows.  deflate performs one or both of the</span>
<a href="#l31.262"></a><span id="l31.262" class="difflineplus">+  following actions:</span>
<a href="#l31.263"></a><span id="l31.263" class="difflineplus">+</span>
<a href="#l31.264"></a><span id="l31.264" class="difflineplus">+  - Compress more input starting at next_in and update next_in and avail_in</span>
<a href="#l31.265"></a><span id="l31.265" class="difflineplus">+    accordingly.  If not all input can be processed (because there is not</span>
<a href="#l31.266"></a><span id="l31.266" class="difflineplus">+    enough room in the output buffer), next_in and avail_in are updated and</span>
<a href="#l31.267"></a><span id="l31.267" class="difflineplus">+    processing will resume at this point for the next call of deflate().</span>
<a href="#l31.268"></a><span id="l31.268" class="difflineplus">+</span>
<a href="#l31.269"></a><span id="l31.269" class="difflineplus">+  - Generate more output starting at next_out and update next_out and avail_out</span>
<a href="#l31.270"></a><span id="l31.270" class="difflineplus">+    accordingly.  This action is forced if the parameter flush is non zero.</span>
<a href="#l31.271"></a><span id="l31.271" class="difflineplus">+    Forcing flush frequently degrades the compression ratio, so this parameter</span>
<a href="#l31.272"></a><span id="l31.272" class="difflineplus">+    should be set only when necessary.  Some output may be provided even if</span>
<a href="#l31.273"></a><span id="l31.273" class="difflineplus">+    flush is zero.</span>
<a href="#l31.274"></a><span id="l31.274" class="difflineplus">+</span>
<a href="#l31.275"></a><span id="l31.275" class="difflineplus">+    Before the call of deflate(), the application should ensure that at least</span>
<a href="#l31.276"></a><span id="l31.276" class="difflineplus">+  one of the actions is possible, by providing more input and/or consuming more</span>
<a href="#l31.277"></a><span id="l31.277" class="difflineplus">+  output, and updating avail_in or avail_out accordingly; avail_out should</span>
<a href="#l31.278"></a><span id="l31.278" class="difflineplus">+  never be zero before the call.  The application can consume the compressed</span>
<a href="#l31.279"></a><span id="l31.279" class="difflineplus">+  output when it wants, for example when the output buffer is full (avail_out</span>
<a href="#l31.280"></a><span id="l31.280" class="difflineplus">+  == 0), or after each call of deflate().  If deflate returns Z_OK and with</span>
<a href="#l31.281"></a><span id="l31.281" class="difflineplus">+  zero avail_out, it must be called again after making room in the output</span>
<a href="#l31.282"></a><span id="l31.282" class="difflineplus">+  buffer because there might be more output pending. See deflatePending(),</span>
<a href="#l31.283"></a><span id="l31.283" class="difflineplus">+  which can be used if desired to determine whether or not there is more ouput</span>
<a href="#l31.284"></a><span id="l31.284" class="difflineplus">+  in that case.</span>
<a href="#l31.285"></a><span id="l31.285" class="difflineplus">+</span>
<a href="#l31.286"></a><span id="l31.286" class="difflineplus">+    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to</span>
<a href="#l31.287"></a><span id="l31.287" class="difflineplus">+  decide how much data to accumulate before producing output, in order to</span>
<a href="#l31.288"></a><span id="l31.288" class="difflineplus">+  maximize compression.</span>
<a href="#l31.289"></a><span id="l31.289" class="difflineplus">+</span>
<a href="#l31.290"></a><span id="l31.290" class="difflineplus">+    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is</span>
<a href="#l31.291"></a><span id="l31.291" class="difflineplus">+  flushed to the output buffer and the output is aligned on a byte boundary, so</span>
<a href="#l31.292"></a><span id="l31.292" class="difflineplus">+  that the decompressor can get all input data available so far.  (In</span>
<a href="#l31.293"></a><span id="l31.293" class="difflineplus">+  particular avail_in is zero after the call if enough output space has been</span>
<a href="#l31.294"></a><span id="l31.294" class="difflineplus">+  provided before the call.) Flushing may degrade compression for some</span>
<a href="#l31.295"></a><span id="l31.295" class="difflineplus">+  compression algorithms and so it should be used only when necessary.  This</span>
<a href="#l31.296"></a><span id="l31.296" class="difflineplus">+  completes the current deflate block and follows it with an empty stored block</span>
<a href="#l31.297"></a><span id="l31.297" class="difflineplus">+  that is three bits plus filler bits to the next byte, followed by four bytes</span>
<a href="#l31.298"></a><span id="l31.298" class="difflineplus">+  (00 00 ff ff).</span>
<a href="#l31.299"></a><span id="l31.299" class="difflineplus">+</span>
<a href="#l31.300"></a><span id="l31.300" class="difflineplus">+    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the</span>
<a href="#l31.301"></a><span id="l31.301" class="difflineplus">+  output buffer, but the output is not aligned to a byte boundary.  All of the</span>
<a href="#l31.302"></a><span id="l31.302" class="difflineplus">+  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.</span>
<a href="#l31.303"></a><span id="l31.303" class="difflineplus">+  This completes the current deflate block and follows it with an empty fixed</span>
<a href="#l31.304"></a><span id="l31.304" class="difflineplus">+  codes block that is 10 bits long.  This assures that enough bytes are output</span>
<a href="#l31.305"></a><span id="l31.305" class="difflineplus">+  in order for the decompressor to finish the block before the empty fixed</span>
<a href="#l31.306"></a><span id="l31.306" class="difflineplus">+  codes block.</span>
<a href="#l31.307"></a><span id="l31.307" class="difflineplus">+</span>
<a href="#l31.308"></a><span id="l31.308" class="difflineplus">+    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as</span>
<a href="#l31.309"></a><span id="l31.309" class="difflineplus">+  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to</span>
<a href="#l31.310"></a><span id="l31.310" class="difflineplus">+  seven bits of the current block are held to be written as the next byte after</span>
<a href="#l31.311"></a><span id="l31.311" class="difflineplus">+  the next deflate block is completed.  In this case, the decompressor may not</span>
<a href="#l31.312"></a><span id="l31.312" class="difflineplus">+  be provided enough bits at this point in order to complete decompression of</span>
<a href="#l31.313"></a><span id="l31.313" class="difflineplus">+  the data provided so far to the compressor.  It may need to wait for the next</span>
<a href="#l31.314"></a><span id="l31.314" class="difflineplus">+  block to be emitted.  This is for advanced applications that need to control</span>
<a href="#l31.315"></a><span id="l31.315" class="difflineplus">+  the emission of deflate blocks.</span>
<a href="#l31.316"></a><span id="l31.316" class="difflineplus">+</span>
<a href="#l31.317"></a><span id="l31.317" class="difflineplus">+    If flush is set to Z_FULL_FLUSH, all output is flushed as with</span>
<a href="#l31.318"></a><span id="l31.318" class="difflineplus">+  Z_SYNC_FLUSH, and the compression state is reset so that decompression can</span>
<a href="#l31.319"></a><span id="l31.319" class="difflineplus">+  restart from this point if previous compressed data has been damaged or if</span>
<a href="#l31.320"></a><span id="l31.320" class="difflineplus">+  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade</span>
<a href="#l31.321"></a><span id="l31.321" class="difflineplus">+  compression.</span>
<a href="#l31.322"></a><span id="l31.322" class="difflineplus">+</span>
<a href="#l31.323"></a><span id="l31.323" class="difflineplus">+    If deflate returns with avail_out == 0, this function must be called again</span>
<a href="#l31.324"></a><span id="l31.324" class="difflineplus">+  with the same value of the flush parameter and more output space (updated</span>
<a href="#l31.325"></a><span id="l31.325" class="difflineplus">+  avail_out), until the flush is complete (deflate returns with non-zero</span>
<a href="#l31.326"></a><span id="l31.326" class="difflineplus">+  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that</span>
<a href="#l31.327"></a><span id="l31.327" class="difflineplus">+  avail_out is greater than six to avoid repeated flush markers due to</span>
<a href="#l31.328"></a><span id="l31.328" class="difflineplus">+  avail_out == 0 on return.</span>
<a href="#l31.329"></a><span id="l31.329" class="difflineplus">+</span>
<a href="#l31.330"></a><span id="l31.330" class="difflineplus">+    If the parameter flush is set to Z_FINISH, pending input is processed,</span>
<a href="#l31.331"></a><span id="l31.331" class="difflineplus">+  pending output is flushed and deflate returns with Z_STREAM_END if there was</span>
<a href="#l31.332"></a><span id="l31.332" class="difflineplus">+  enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this</span>
<a href="#l31.333"></a><span id="l31.333" class="difflineplus">+  function must be called again with Z_FINISH and more output space (updated</span>
<a href="#l31.334"></a><span id="l31.334" class="difflineplus">+  avail_out) but no more input data, until it returns with Z_STREAM_END or an</span>
<a href="#l31.335"></a><span id="l31.335" class="difflineplus">+  error.  After deflate has returned Z_STREAM_END, the only possible operations</span>
<a href="#l31.336"></a><span id="l31.336" class="difflineplus">+  on the stream are deflateReset or deflateEnd.</span>
<a href="#l31.337"></a><span id="l31.337" class="difflineplus">+</span>
<a href="#l31.338"></a><span id="l31.338" class="difflineplus">+    Z_FINISH can be used in the first deflate call after deflateInit if all the</span>
<a href="#l31.339"></a><span id="l31.339" class="difflineplus">+  compression is to be done in a single step.  In order to complete in one</span>
<a href="#l31.340"></a><span id="l31.340" class="difflineplus">+  call, avail_out must be at least the value returned by deflateBound (see</span>
<a href="#l31.341"></a><span id="l31.341" class="difflineplus">+  below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough</span>
<a href="#l31.342"></a><span id="l31.342" class="difflineplus">+  output space is provided, deflate will not return Z_STREAM_END, and it must</span>
<a href="#l31.343"></a><span id="l31.343" class="difflineplus">+  be called again as described above.</span>
<a href="#l31.344"></a><span id="l31.344" class="difflineplus">+</span>
<a href="#l31.345"></a><span id="l31.345" class="difflineplus">+    deflate() sets strm-&gt;adler to the Adler-32 checksum of all input read</span>
<a href="#l31.346"></a><span id="l31.346" class="difflineplus">+  so far (that is, total_in bytes).  If a gzip stream is being generated, then</span>
<a href="#l31.347"></a><span id="l31.347" class="difflineplus">+  strm-&gt;adler will be the CRC-32 checksum of the input read so far.  (See</span>
<a href="#l31.348"></a><span id="l31.348" class="difflineplus">+  deflateInit2 below.)</span>
<a href="#l31.349"></a><span id="l31.349" class="difflineplus">+</span>
<a href="#l31.350"></a><span id="l31.350" class="difflineplus">+    deflate() may update strm-&gt;data_type if it can make a good guess about</span>
<a href="#l31.351"></a><span id="l31.351" class="difflineplus">+  the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is</span>
<a href="#l31.352"></a><span id="l31.352" class="difflineplus">+  considered binary.  This field is only for information purposes and does not</span>
<a href="#l31.353"></a><span id="l31.353" class="difflineplus">+  affect the compression algorithm in any manner.</span>
<a href="#l31.354"></a><span id="l31.354" class="difflineplus">+</span>
<a href="#l31.355"></a><span id="l31.355" class="difflineplus">+    deflate() returns Z_OK if some progress has been made (more input</span>
<a href="#l31.356"></a><span id="l31.356" class="difflineplus">+  processed or more output produced), Z_STREAM_END if all input has been</span>
<a href="#l31.357"></a><span id="l31.357" class="difflineplus">+  consumed and all output has been produced (only when flush is set to</span>
<a href="#l31.358"></a><span id="l31.358" class="difflineplus">+  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example</span>
<a href="#l31.359"></a><span id="l31.359" class="difflineplus">+  if next_in or next_out was Z_NULL or the state was inadvertently written over</span>
<a href="#l31.360"></a><span id="l31.360" class="difflineplus">+  by the application), or Z_BUF_ERROR if no progress is possible (for example</span>
<a href="#l31.361"></a><span id="l31.361" class="difflineplus">+  avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and</span>
<a href="#l31.362"></a><span id="l31.362" class="difflineplus">+  deflate() can be called again with more input and more output space to</span>
<a href="#l31.363"></a><span id="l31.363" class="difflineplus">+  continue compressing.</span>
<a href="#l31.364"></a><span id="l31.364" class="difflineplus">+*/</span>
<a href="#l31.365"></a><span id="l31.365" class="difflineplus">+</span>
<a href="#l31.366"></a><span id="l31.366" class="difflineplus">+</span>
<a href="#l31.367"></a><span id="l31.367" class="difflineplus">+ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));</span>
<a href="#l31.368"></a><span id="l31.368" class="difflineplus">+/*</span>
<a href="#l31.369"></a><span id="l31.369" class="difflineplus">+     All dynamically allocated data structures for this stream are freed.</span>
<a href="#l31.370"></a><span id="l31.370" class="difflineplus">+   This function discards any unprocessed input and does not flush any pending</span>
<a href="#l31.371"></a><span id="l31.371" class="difflineplus">+   output.</span>
<a href="#l31.372"></a><span id="l31.372" class="difflineplus">+</span>
<a href="#l31.373"></a><span id="l31.373" class="difflineplus">+     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the</span>
<a href="#l31.374"></a><span id="l31.374" class="difflineplus">+   stream state was inconsistent, Z_DATA_ERROR if the stream was freed</span>
<a href="#l31.375"></a><span id="l31.375" class="difflineplus">+   prematurely (some input or output was discarded).  In the error case, msg</span>
<a href="#l31.376"></a><span id="l31.376" class="difflineplus">+   may be set but then points to a static string (which must not be</span>
<a href="#l31.377"></a><span id="l31.377" class="difflineplus">+   deallocated).</span>
<a href="#l31.378"></a><span id="l31.378" class="difflineplus">+*/</span>
<a href="#l31.379"></a><span id="l31.379" class="difflineplus">+</span>
<a href="#l31.380"></a><span id="l31.380" class="difflineplus">+</span>
<a href="#l31.381"></a><span id="l31.381" class="difflineplus">+/*</span>
<a href="#l31.382"></a><span id="l31.382" class="difflineplus">+ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));</span>
<a href="#l31.383"></a><span id="l31.383" class="difflineplus">+</span>
<a href="#l31.384"></a><span id="l31.384" class="difflineplus">+     Initializes the internal stream state for decompression.  The fields</span>
<a href="#l31.385"></a><span id="l31.385" class="difflineplus">+   next_in, avail_in, zalloc, zfree and opaque must be initialized before by</span>
<a href="#l31.386"></a><span id="l31.386" class="difflineplus">+   the caller.  In the current version of inflate, the provided input is not</span>
<a href="#l31.387"></a><span id="l31.387" class="difflineplus">+   read or consumed.  The allocation of a sliding window will be deferred to</span>
<a href="#l31.388"></a><span id="l31.388" class="difflineplus">+   the first call of inflate (if the decompression does not complete on the</span>
<a href="#l31.389"></a><span id="l31.389" class="difflineplus">+   first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates</span>
<a href="#l31.390"></a><span id="l31.390" class="difflineplus">+   them to use default allocation functions.</span>
<a href="#l31.391"></a><span id="l31.391" class="difflineplus">+</span>
<a href="#l31.392"></a><span id="l31.392" class="difflineplus">+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
<a href="#l31.393"></a><span id="l31.393" class="difflineplus">+   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the</span>
<a href="#l31.394"></a><span id="l31.394" class="difflineplus">+   version assumed by the caller, or Z_STREAM_ERROR if the parameters are</span>
<a href="#l31.395"></a><span id="l31.395" class="difflineplus">+   invalid, such as a null pointer to the structure.  msg is set to null if</span>
<a href="#l31.396"></a><span id="l31.396" class="difflineplus">+   there is no error message.  inflateInit does not perform any decompression.</span>
<a href="#l31.397"></a><span id="l31.397" class="difflineplus">+   Actual decompression will be done by inflate().  So next_in, and avail_in,</span>
<a href="#l31.398"></a><span id="l31.398" class="difflineplus">+   next_out, and avail_out are unused and unchanged.  The current</span>
<a href="#l31.399"></a><span id="l31.399" class="difflineplus">+   implementation of inflateInit() does not process any header information --</span>
<a href="#l31.400"></a><span id="l31.400" class="difflineplus">+   that is deferred until inflate() is called.</span>
<a href="#l31.401"></a><span id="l31.401" class="difflineplus">+*/</span>
<a href="#l31.402"></a><span id="l31.402" class="difflineplus">+</span>
<a href="#l31.403"></a><span id="l31.403" class="difflineplus">+</span>
<a href="#l31.404"></a><span id="l31.404" class="difflineplus">+ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));</span>
<a href="#l31.405"></a><span id="l31.405" class="difflineplus">+/*</span>
<a href="#l31.406"></a><span id="l31.406" class="difflineplus">+    inflate decompresses as much data as possible, and stops when the input</span>
<a href="#l31.407"></a><span id="l31.407" class="difflineplus">+  buffer becomes empty or the output buffer becomes full.  It may introduce</span>
<a href="#l31.408"></a><span id="l31.408" class="difflineplus">+  some output latency (reading input without producing any output) except when</span>
<a href="#l31.409"></a><span id="l31.409" class="difflineplus">+  forced to flush.</span>
<a href="#l31.410"></a><span id="l31.410" class="difflineplus">+</span>
<a href="#l31.411"></a><span id="l31.411" class="difflineplus">+  The detailed semantics are as follows.  inflate performs one or both of the</span>
<a href="#l31.412"></a><span id="l31.412" class="difflineplus">+  following actions:</span>
<a href="#l31.413"></a><span id="l31.413" class="difflineplus">+</span>
<a href="#l31.414"></a><span id="l31.414" class="difflineplus">+  - Decompress more input starting at next_in and update next_in and avail_in</span>
<a href="#l31.415"></a><span id="l31.415" class="difflineplus">+    accordingly.  If not all input can be processed (because there is not</span>
<a href="#l31.416"></a><span id="l31.416" class="difflineplus">+    enough room in the output buffer), then next_in and avail_in are updated</span>
<a href="#l31.417"></a><span id="l31.417" class="difflineplus">+    accordingly, and processing will resume at this point for the next call of</span>
<a href="#l31.418"></a><span id="l31.418" class="difflineplus">+    inflate().</span>
<a href="#l31.419"></a><span id="l31.419" class="difflineplus">+</span>
<a href="#l31.420"></a><span id="l31.420" class="difflineplus">+  - Generate more output starting at next_out and update next_out and avail_out</span>
<a href="#l31.421"></a><span id="l31.421" class="difflineplus">+    accordingly.  inflate() provides as much output as possible, until there is</span>
<a href="#l31.422"></a><span id="l31.422" class="difflineplus">+    no more input data or no more space in the output buffer (see below about</span>
<a href="#l31.423"></a><span id="l31.423" class="difflineplus">+    the flush parameter).</span>
<a href="#l31.424"></a><span id="l31.424" class="difflineplus">+</span>
<a href="#l31.425"></a><span id="l31.425" class="difflineplus">+    Before the call of inflate(), the application should ensure that at least</span>
<a href="#l31.426"></a><span id="l31.426" class="difflineplus">+  one of the actions is possible, by providing more input and/or consuming more</span>
<a href="#l31.427"></a><span id="l31.427" class="difflineplus">+  output, and updating the next_* and avail_* values accordingly.  If the</span>
<a href="#l31.428"></a><span id="l31.428" class="difflineplus">+  caller of inflate() does not provide both available input and available</span>
<a href="#l31.429"></a><span id="l31.429" class="difflineplus">+  output space, it is possible that there will be no progress made.  The</span>
<a href="#l31.430"></a><span id="l31.430" class="difflineplus">+  application can consume the uncompressed output when it wants, for example</span>
<a href="#l31.431"></a><span id="l31.431" class="difflineplus">+  when the output buffer is full (avail_out == 0), or after each call of</span>
<a href="#l31.432"></a><span id="l31.432" class="difflineplus">+  inflate().  If inflate returns Z_OK and with zero avail_out, it must be</span>
<a href="#l31.433"></a><span id="l31.433" class="difflineplus">+  called again after making room in the output buffer because there might be</span>
<a href="#l31.434"></a><span id="l31.434" class="difflineplus">+  more output pending.</span>
<a href="#l31.435"></a><span id="l31.435" class="difflineplus">+</span>
<a href="#l31.436"></a><span id="l31.436" class="difflineplus">+    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,</span>
<a href="#l31.437"></a><span id="l31.437" class="difflineplus">+  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much</span>
<a href="#l31.438"></a><span id="l31.438" class="difflineplus">+  output as possible to the output buffer.  Z_BLOCK requests that inflate()</span>
<a href="#l31.439"></a><span id="l31.439" class="difflineplus">+  stop if and when it gets to the next deflate block boundary.  When decoding</span>
<a href="#l31.440"></a><span id="l31.440" class="difflineplus">+  the zlib or gzip format, this will cause inflate() to return immediately</span>
<a href="#l31.441"></a><span id="l31.441" class="difflineplus">+  after the header and before the first block.  When doing a raw inflate,</span>
<a href="#l31.442"></a><span id="l31.442" class="difflineplus">+  inflate() will go ahead and process the first block, and will return when it</span>
<a href="#l31.443"></a><span id="l31.443" class="difflineplus">+  gets to the end of that block, or when it runs out of data.</span>
<a href="#l31.444"></a><span id="l31.444" class="difflineplus">+</span>
<a href="#l31.445"></a><span id="l31.445" class="difflineplus">+    The Z_BLOCK option assists in appending to or combining deflate streams.</span>
<a href="#l31.446"></a><span id="l31.446" class="difflineplus">+  To assist in this, on return inflate() always sets strm-&gt;data_type to the</span>
<a href="#l31.447"></a><span id="l31.447" class="difflineplus">+  number of unused bits in the last byte taken from strm-&gt;next_in, plus 64 if</span>
<a href="#l31.448"></a><span id="l31.448" class="difflineplus">+  inflate() is currently decoding the last block in the deflate stream, plus</span>
<a href="#l31.449"></a><span id="l31.449" class="difflineplus">+  128 if inflate() returned immediately after decoding an end-of-block code or</span>
<a href="#l31.450"></a><span id="l31.450" class="difflineplus">+  decoding the complete header up to just before the first byte of the deflate</span>
<a href="#l31.451"></a><span id="l31.451" class="difflineplus">+  stream.  The end-of-block will not be indicated until all of the uncompressed</span>
<a href="#l31.452"></a><span id="l31.452" class="difflineplus">+  data from that block has been written to strm-&gt;next_out.  The number of</span>
<a href="#l31.453"></a><span id="l31.453" class="difflineplus">+  unused bits may in general be greater than seven, except when bit 7 of</span>
<a href="#l31.454"></a><span id="l31.454" class="difflineplus">+  data_type is set, in which case the number of unused bits will be less than</span>
<a href="#l31.455"></a><span id="l31.455" class="difflineplus">+  eight.  data_type is set as noted here every time inflate() returns for all</span>
<a href="#l31.456"></a><span id="l31.456" class="difflineplus">+  flush options, and so can be used to determine the amount of currently</span>
<a href="#l31.457"></a><span id="l31.457" class="difflineplus">+  consumed input in bits.</span>
<a href="#l31.458"></a><span id="l31.458" class="difflineplus">+</span>
<a href="#l31.459"></a><span id="l31.459" class="difflineplus">+    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the</span>
<a href="#l31.460"></a><span id="l31.460" class="difflineplus">+  end of each deflate block header is reached, before any actual data in that</span>
<a href="#l31.461"></a><span id="l31.461" class="difflineplus">+  block is decoded.  This allows the caller to determine the length of the</span>
<a href="#l31.462"></a><span id="l31.462" class="difflineplus">+  deflate block header for later use in random access within a deflate block.</span>
<a href="#l31.463"></a><span id="l31.463" class="difflineplus">+  256 is added to the value of strm-&gt;data_type when inflate() returns</span>
<a href="#l31.464"></a><span id="l31.464" class="difflineplus">+  immediately after reaching the end of the deflate block header.</span>
<a href="#l31.465"></a><span id="l31.465" class="difflineplus">+</span>
<a href="#l31.466"></a><span id="l31.466" class="difflineplus">+    inflate() should normally be called until it returns Z_STREAM_END or an</span>
<a href="#l31.467"></a><span id="l31.467" class="difflineplus">+  error.  However if all decompression is to be performed in a single step (a</span>
<a href="#l31.468"></a><span id="l31.468" class="difflineplus">+  single call of inflate), the parameter flush should be set to Z_FINISH.  In</span>
<a href="#l31.469"></a><span id="l31.469" class="difflineplus">+  this case all pending input is processed and all pending output is flushed;</span>
<a href="#l31.470"></a><span id="l31.470" class="difflineplus">+  avail_out must be large enough to hold all of the uncompressed data for the</span>
<a href="#l31.471"></a><span id="l31.471" class="difflineplus">+  operation to complete.  (The size of the uncompressed data may have been</span>
<a href="#l31.472"></a><span id="l31.472" class="difflineplus">+  saved by the compressor for this purpose.)  The use of Z_FINISH is not</span>
<a href="#l31.473"></a><span id="l31.473" class="difflineplus">+  required to perform an inflation in one step.  However it may be used to</span>
<a href="#l31.474"></a><span id="l31.474" class="difflineplus">+  inform inflate that a faster approach can be used for the single inflate()</span>
<a href="#l31.475"></a><span id="l31.475" class="difflineplus">+  call.  Z_FINISH also informs inflate to not maintain a sliding window if the</span>
<a href="#l31.476"></a><span id="l31.476" class="difflineplus">+  stream completes, which reduces inflate's memory footprint.  If the stream</span>
<a href="#l31.477"></a><span id="l31.477" class="difflineplus">+  does not complete, either because not all of the stream is provided or not</span>
<a href="#l31.478"></a><span id="l31.478" class="difflineplus">+  enough output space is provided, then a sliding window will be allocated and</span>
<a href="#l31.479"></a><span id="l31.479" class="difflineplus">+  inflate() can be called again to continue the operation as if Z_NO_FLUSH had</span>
<a href="#l31.480"></a><span id="l31.480" class="difflineplus">+  been used.</span>
<a href="#l31.481"></a><span id="l31.481" class="difflineplus">+</span>
<a href="#l31.482"></a><span id="l31.482" class="difflineplus">+     In this implementation, inflate() always flushes as much output as</span>
<a href="#l31.483"></a><span id="l31.483" class="difflineplus">+  possible to the output buffer, and always uses the faster approach on the</span>
<a href="#l31.484"></a><span id="l31.484" class="difflineplus">+  first call.  So the effects of the flush parameter in this implementation are</span>
<a href="#l31.485"></a><span id="l31.485" class="difflineplus">+  on the return value of inflate() as noted below, when inflate() returns early</span>
<a href="#l31.486"></a><span id="l31.486" class="difflineplus">+  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of</span>
<a href="#l31.487"></a><span id="l31.487" class="difflineplus">+  memory for a sliding window when Z_FINISH is used.</span>
<a href="#l31.488"></a><span id="l31.488" class="difflineplus">+</span>
<a href="#l31.489"></a><span id="l31.489" class="difflineplus">+     If a preset dictionary is needed after this call (see inflateSetDictionary</span>
<a href="#l31.490"></a><span id="l31.490" class="difflineplus">+  below), inflate sets strm-&gt;adler to the Adler-32 checksum of the dictionary</span>
<a href="#l31.491"></a><span id="l31.491" class="difflineplus">+  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets</span>
<a href="#l31.492"></a><span id="l31.492" class="difflineplus">+  strm-&gt;adler to the Adler-32 checksum of all output produced so far (that is,</span>
<a href="#l31.493"></a><span id="l31.493" class="difflineplus">+  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described</span>
<a href="#l31.494"></a><span id="l31.494" class="difflineplus">+  below.  At the end of the stream, inflate() checks that its computed Adler-32</span>
<a href="#l31.495"></a><span id="l31.495" class="difflineplus">+  checksum is equal to that saved by the compressor and returns Z_STREAM_END</span>
<a href="#l31.496"></a><span id="l31.496" class="difflineplus">+  only if the checksum is correct.</span>
<a href="#l31.497"></a><span id="l31.497" class="difflineplus">+</span>
<a href="#l31.498"></a><span id="l31.498" class="difflineplus">+    inflate() can decompress and check either zlib-wrapped or gzip-wrapped</span>
<a href="#l31.499"></a><span id="l31.499" class="difflineplus">+  deflate data.  The header type is detected automatically, if requested when</span>
<a href="#l31.500"></a><span id="l31.500" class="difflineplus">+  initializing with inflateInit2().  Any information contained in the gzip</span>
<a href="#l31.501"></a><span id="l31.501" class="difflineplus">+  header is not retained unless inflateGetHeader() is used.  When processing</span>
<a href="#l31.502"></a><span id="l31.502" class="difflineplus">+  gzip-wrapped deflate data, strm-&gt;adler32 is set to the CRC-32 of the output</span>
<a href="#l31.503"></a><span id="l31.503" class="difflineplus">+  produced so far.  The CRC-32 is checked against the gzip trailer, as is the</span>
<a href="#l31.504"></a><span id="l31.504" class="difflineplus">+  uncompressed length, modulo 2^32.</span>
<a href="#l31.505"></a><span id="l31.505" class="difflineplus">+</span>
<a href="#l31.506"></a><span id="l31.506" class="difflineplus">+    inflate() returns Z_OK if some progress has been made (more input processed</span>
<a href="#l31.507"></a><span id="l31.507" class="difflineplus">+  or more output produced), Z_STREAM_END if the end of the compressed data has</span>
<a href="#l31.508"></a><span id="l31.508" class="difflineplus">+  been reached and all uncompressed output has been produced, Z_NEED_DICT if a</span>
<a href="#l31.509"></a><span id="l31.509" class="difflineplus">+  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was</span>
<a href="#l31.510"></a><span id="l31.510" class="difflineplus">+  corrupted (input stream not conforming to the zlib format or incorrect check</span>
<a href="#l31.511"></a><span id="l31.511" class="difflineplus">+  value, in which case strm-&gt;msg points to a string with a more specific</span>
<a href="#l31.512"></a><span id="l31.512" class="difflineplus">+  error), Z_STREAM_ERROR if the stream structure was inconsistent (for example</span>
<a href="#l31.513"></a><span id="l31.513" class="difflineplus">+  next_in or next_out was Z_NULL, or the state was inadvertently written over</span>
<a href="#l31.514"></a><span id="l31.514" class="difflineplus">+  by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR</span>
<a href="#l31.515"></a><span id="l31.515" class="difflineplus">+  if no progress was possible or if there was not enough room in the output</span>
<a href="#l31.516"></a><span id="l31.516" class="difflineplus">+  buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and</span>
<a href="#l31.517"></a><span id="l31.517" class="difflineplus">+  inflate() can be called again with more input and more output space to</span>
<a href="#l31.518"></a><span id="l31.518" class="difflineplus">+  continue decompressing.  If Z_DATA_ERROR is returned, the application may</span>
<a href="#l31.519"></a><span id="l31.519" class="difflineplus">+  then call inflateSync() to look for a good compression block if a partial</span>
<a href="#l31.520"></a><span id="l31.520" class="difflineplus">+  recovery of the data is to be attempted.</span>
<a href="#l31.521"></a><span id="l31.521" class="difflineplus">+*/</span>
<a href="#l31.522"></a><span id="l31.522" class="difflineplus">+</span>
<a href="#l31.523"></a><span id="l31.523" class="difflineplus">+</span>
<a href="#l31.524"></a><span id="l31.524" class="difflineplus">+ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));</span>
<a href="#l31.525"></a><span id="l31.525" class="difflineplus">+/*</span>
<a href="#l31.526"></a><span id="l31.526" class="difflineplus">+     All dynamically allocated data structures for this stream are freed.</span>
<a href="#l31.527"></a><span id="l31.527" class="difflineplus">+   This function discards any unprocessed input and does not flush any pending</span>
<a href="#l31.528"></a><span id="l31.528" class="difflineplus">+   output.</span>
<a href="#l31.529"></a><span id="l31.529" class="difflineplus">+</span>
<a href="#l31.530"></a><span id="l31.530" class="difflineplus">+     inflateEnd returns Z_OK if success, or Z_STREAM_ERROR if the stream state</span>
<a href="#l31.531"></a><span id="l31.531" class="difflineplus">+   was inconsistent.</span>
<a href="#l31.532"></a><span id="l31.532" class="difflineplus">+*/</span>
<a href="#l31.533"></a><span id="l31.533" class="difflineplus">+</span>
<a href="#l31.534"></a><span id="l31.534" class="difflineplus">+</span>
<a href="#l31.535"></a><span id="l31.535" class="difflineplus">+                        /* Advanced functions */</span>
<a href="#l31.536"></a><span id="l31.536" class="difflineplus">+</span>
<a href="#l31.537"></a><span id="l31.537" class="difflineplus">+/*</span>
<a href="#l31.538"></a><span id="l31.538" class="difflineplus">+    The following functions are needed only in some special applications.</span>
<a href="#l31.539"></a><span id="l31.539" class="difflineplus">+*/</span>
<a href="#l31.540"></a><span id="l31.540" class="difflineplus">+</span>
<a href="#l31.541"></a><span id="l31.541" class="difflineplus">+/*</span>
<a href="#l31.542"></a><span id="l31.542" class="difflineplus">+ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,</span>
<a href="#l31.543"></a><span id="l31.543" class="difflineplus">+                                     int  level,</span>
<a href="#l31.544"></a><span id="l31.544" class="difflineplus">+                                     int  method,</span>
<a href="#l31.545"></a><span id="l31.545" class="difflineplus">+                                     int  windowBits,</span>
<a href="#l31.546"></a><span id="l31.546" class="difflineplus">+                                     int  memLevel,</span>
<a href="#l31.547"></a><span id="l31.547" class="difflineplus">+                                     int  strategy));</span>
<a href="#l31.548"></a><span id="l31.548" class="difflineplus">+</span>
<a href="#l31.549"></a><span id="l31.549" class="difflineplus">+     This is another version of deflateInit with more compression options.  The</span>
<a href="#l31.550"></a><span id="l31.550" class="difflineplus">+   fields next_in, zalloc, zfree and opaque must be initialized before by the</span>
<a href="#l31.551"></a><span id="l31.551" class="difflineplus">+   caller.</span>
<a href="#l31.552"></a><span id="l31.552" class="difflineplus">+</span>
<a href="#l31.553"></a><span id="l31.553" class="difflineplus">+     The method parameter is the compression method.  It must be Z_DEFLATED in</span>
<a href="#l31.554"></a><span id="l31.554" class="difflineplus">+   this version of the library.</span>
<a href="#l31.555"></a><span id="l31.555" class="difflineplus">+</span>
<a href="#l31.556"></a><span id="l31.556" class="difflineplus">+     The windowBits parameter is the base two logarithm of the window size</span>
<a href="#l31.557"></a><span id="l31.557" class="difflineplus">+   (the size of the history buffer).  It should be in the range 8..15 for this</span>
<a href="#l31.558"></a><span id="l31.558" class="difflineplus">+   version of the library.  Larger values of this parameter result in better</span>
<a href="#l31.559"></a><span id="l31.559" class="difflineplus">+   compression at the expense of memory usage.  The default value is 15 if</span>
<a href="#l31.560"></a><span id="l31.560" class="difflineplus">+   deflateInit is used instead.</span>
<a href="#l31.561"></a><span id="l31.561" class="difflineplus">+</span>
<a href="#l31.562"></a><span id="l31.562" class="difflineplus">+     For the current implementation of deflate(), a windowBits value of 8 (a</span>
<a href="#l31.563"></a><span id="l31.563" class="difflineplus">+   window size of 256 bytes) is not supported.  As a result, a request for 8</span>
<a href="#l31.564"></a><span id="l31.564" class="difflineplus">+   will result in 9 (a 512-byte window).  In that case, providing 8 to</span>
<a href="#l31.565"></a><span id="l31.565" class="difflineplus">+   inflateInit2() will result in an error when the zlib header with 9 is</span>
<a href="#l31.566"></a><span id="l31.566" class="difflineplus">+   checked against the initialization of inflate().  The remedy is to not use 8</span>
<a href="#l31.567"></a><span id="l31.567" class="difflineplus">+   with deflateInit2() with this initialization, or at least in that case use 9</span>
<a href="#l31.568"></a><span id="l31.568" class="difflineplus">+   with inflateInit2().</span>
<a href="#l31.569"></a><span id="l31.569" class="difflineplus">+</span>
<a href="#l31.570"></a><span id="l31.570" class="difflineplus">+     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits</span>
<a href="#l31.571"></a><span id="l31.571" class="difflineplus">+   determines the window size.  deflate() will then generate raw deflate data</span>
<a href="#l31.572"></a><span id="l31.572" class="difflineplus">+   with no zlib header or trailer, and will not compute a check value.</span>
<a href="#l31.573"></a><span id="l31.573" class="difflineplus">+</span>
<a href="#l31.574"></a><span id="l31.574" class="difflineplus">+     windowBits can also be greater than 15 for optional gzip encoding.  Add</span>
<a href="#l31.575"></a><span id="l31.575" class="difflineplus">+   16 to windowBits to write a simple gzip header and trailer around the</span>
<a href="#l31.576"></a><span id="l31.576" class="difflineplus">+   compressed data instead of a zlib wrapper.  The gzip header will have no</span>
<a href="#l31.577"></a><span id="l31.577" class="difflineplus">+   file name, no extra data, no comment, no modification time (set to zero), no</span>
<a href="#l31.578"></a><span id="l31.578" class="difflineplus">+   header crc, and the operating system will be set to the appropriate value,</span>
<a href="#l31.579"></a><span id="l31.579" class="difflineplus">+   if the operating system was determined at compile time.  If a gzip stream is</span>
<a href="#l31.580"></a><span id="l31.580" class="difflineplus">+   being written, strm-&gt;adler is a CRC-32 instead of an Adler-32.</span>
<a href="#l31.581"></a><span id="l31.581" class="difflineplus">+</span>
<a href="#l31.582"></a><span id="l31.582" class="difflineplus">+     For raw deflate or gzip encoding, a request for a 256-byte window is</span>
<a href="#l31.583"></a><span id="l31.583" class="difflineplus">+   rejected as invalid, since only the zlib header provides a means of</span>
<a href="#l31.584"></a><span id="l31.584" class="difflineplus">+   transmitting the window size to the decompressor.</span>
<a href="#l31.585"></a><span id="l31.585" class="difflineplus">+</span>
<a href="#l31.586"></a><span id="l31.586" class="difflineplus">+     The memLevel parameter specifies how much memory should be allocated</span>
<a href="#l31.587"></a><span id="l31.587" class="difflineplus">+   for the internal compression state.  memLevel=1 uses minimum memory but is</span>
<a href="#l31.588"></a><span id="l31.588" class="difflineplus">+   slow and reduces compression ratio; memLevel=9 uses maximum memory for</span>
<a href="#l31.589"></a><span id="l31.589" class="difflineplus">+   optimal speed.  The default value is 8.  See zconf.h for total memory usage</span>
<a href="#l31.590"></a><span id="l31.590" class="difflineplus">+   as a function of windowBits and memLevel.</span>
<a href="#l31.591"></a><span id="l31.591" class="difflineplus">+</span>
<a href="#l31.592"></a><span id="l31.592" class="difflineplus">+     The strategy parameter is used to tune the compression algorithm.  Use the</span>
<a href="#l31.593"></a><span id="l31.593" class="difflineplus">+   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a</span>
<a href="#l31.594"></a><span id="l31.594" class="difflineplus">+   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no</span>
<a href="#l31.595"></a><span id="l31.595" class="difflineplus">+   string match), or Z_RLE to limit match distances to one (run-length</span>
<a href="#l31.596"></a><span id="l31.596" class="difflineplus">+   encoding).  Filtered data consists mostly of small values with a somewhat</span>
<a href="#l31.597"></a><span id="l31.597" class="difflineplus">+   random distribution.  In this case, the compression algorithm is tuned to</span>
<a href="#l31.598"></a><span id="l31.598" class="difflineplus">+   compress them better.  The effect of Z_FILTERED is to force more Huffman</span>
<a href="#l31.599"></a><span id="l31.599" class="difflineplus">+   coding and less string matching; it is somewhat intermediate between</span>
<a href="#l31.600"></a><span id="l31.600" class="difflineplus">+   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as</span>
<a href="#l31.601"></a><span id="l31.601" class="difflineplus">+   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The</span>
<a href="#l31.602"></a><span id="l31.602" class="difflineplus">+   strategy parameter only affects the compression ratio but not the</span>
<a href="#l31.603"></a><span id="l31.603" class="difflineplus">+   correctness of the compressed output even if it is not set appropriately.</span>
<a href="#l31.604"></a><span id="l31.604" class="difflineplus">+   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler</span>
<a href="#l31.605"></a><span id="l31.605" class="difflineplus">+   decoder for special applications.</span>
<a href="#l31.606"></a><span id="l31.606" class="difflineplus">+</span>
<a href="#l31.607"></a><span id="l31.607" class="difflineplus">+     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
<a href="#l31.608"></a><span id="l31.608" class="difflineplus">+   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid</span>
<a href="#l31.609"></a><span id="l31.609" class="difflineplus">+   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is</span>
<a href="#l31.610"></a><span id="l31.610" class="difflineplus">+   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is</span>
<a href="#l31.611"></a><span id="l31.611" class="difflineplus">+   set to null if there is no error message.  deflateInit2 does not perform any</span>
<a href="#l31.612"></a><span id="l31.612" class="difflineplus">+   compression: this will be done by deflate().</span>
<a href="#l31.613"></a><span id="l31.613" class="difflineplus">+*/</span>
<a href="#l31.614"></a><span id="l31.614" class="difflineplus">+</span>
<a href="#l31.615"></a><span id="l31.615" class="difflineplus">+ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,</span>
<a href="#l31.616"></a><span id="l31.616" class="difflineplus">+                                             const Bytef *dictionary,</span>
<a href="#l31.617"></a><span id="l31.617" class="difflineplus">+                                             uInt  dictLength));</span>
<a href="#l31.618"></a><span id="l31.618" class="difflineplus">+/*</span>
<a href="#l31.619"></a><span id="l31.619" class="difflineplus">+     Initializes the compression dictionary from the given byte sequence</span>
<a href="#l31.620"></a><span id="l31.620" class="difflineplus">+   without producing any compressed output.  When using the zlib format, this</span>
<a href="#l31.621"></a><span id="l31.621" class="difflineplus">+   function must be called immediately after deflateInit, deflateInit2 or</span>
<a href="#l31.622"></a><span id="l31.622" class="difflineplus">+   deflateReset, and before any call of deflate.  When doing raw deflate, this</span>
<a href="#l31.623"></a><span id="l31.623" class="difflineplus">+   function must be called either before any call of deflate, or immediately</span>
<a href="#l31.624"></a><span id="l31.624" class="difflineplus">+   after the completion of a deflate block, i.e. after all input has been</span>
<a href="#l31.625"></a><span id="l31.625" class="difflineplus">+   consumed and all output has been delivered when using any of the flush</span>
<a href="#l31.626"></a><span id="l31.626" class="difflineplus">+   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The</span>
<a href="#l31.627"></a><span id="l31.627" class="difflineplus">+   compressor and decompressor must use exactly the same dictionary (see</span>
<a href="#l31.628"></a><span id="l31.628" class="difflineplus">+   inflateSetDictionary).</span>
<a href="#l31.629"></a><span id="l31.629" class="difflineplus">+</span>
<a href="#l31.630"></a><span id="l31.630" class="difflineplus">+     The dictionary should consist of strings (byte sequences) that are likely</span>
<a href="#l31.631"></a><span id="l31.631" class="difflineplus">+   to be encountered later in the data to be compressed, with the most commonly</span>
<a href="#l31.632"></a><span id="l31.632" class="difflineplus">+   used strings preferably put towards the end of the dictionary.  Using a</span>
<a href="#l31.633"></a><span id="l31.633" class="difflineplus">+   dictionary is most useful when the data to be compressed is short and can be</span>
<a href="#l31.634"></a><span id="l31.634" class="difflineplus">+   predicted with good accuracy; the data can then be compressed better than</span>
<a href="#l31.635"></a><span id="l31.635" class="difflineplus">+   with the default empty dictionary.</span>
<a href="#l31.636"></a><span id="l31.636" class="difflineplus">+</span>
<a href="#l31.637"></a><span id="l31.637" class="difflineplus">+     Depending on the size of the compression data structures selected by</span>
<a href="#l31.638"></a><span id="l31.638" class="difflineplus">+   deflateInit or deflateInit2, a part of the dictionary may in effect be</span>
<a href="#l31.639"></a><span id="l31.639" class="difflineplus">+   discarded, for example if the dictionary is larger than the window size</span>
<a href="#l31.640"></a><span id="l31.640" class="difflineplus">+   provided in deflateInit or deflateInit2.  Thus the strings most likely to be</span>
<a href="#l31.641"></a><span id="l31.641" class="difflineplus">+   useful should be put at the end of the dictionary, not at the front.  In</span>
<a href="#l31.642"></a><span id="l31.642" class="difflineplus">+   addition, the current implementation of deflate will use at most the window</span>
<a href="#l31.643"></a><span id="l31.643" class="difflineplus">+   size minus 262 bytes of the provided dictionary.</span>
<a href="#l31.644"></a><span id="l31.644" class="difflineplus">+</span>
<a href="#l31.645"></a><span id="l31.645" class="difflineplus">+     Upon return of this function, strm-&gt;adler is set to the Adler-32 value</span>
<a href="#l31.646"></a><span id="l31.646" class="difflineplus">+   of the dictionary; the decompressor may later use this value to determine</span>
<a href="#l31.647"></a><span id="l31.647" class="difflineplus">+   which dictionary has been used by the compressor.  (The Adler-32 value</span>
<a href="#l31.648"></a><span id="l31.648" class="difflineplus">+   applies to the whole dictionary even if only a subset of the dictionary is</span>
<a href="#l31.649"></a><span id="l31.649" class="difflineplus">+   actually used by the compressor.) If a raw deflate was requested, then the</span>
<a href="#l31.650"></a><span id="l31.650" class="difflineplus">+   Adler-32 value is not computed and strm-&gt;adler is not set.</span>
<a href="#l31.651"></a><span id="l31.651" class="difflineplus">+</span>
<a href="#l31.652"></a><span id="l31.652" class="difflineplus">+     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a</span>
<a href="#l31.653"></a><span id="l31.653" class="difflineplus">+   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is</span>
<a href="#l31.654"></a><span id="l31.654" class="difflineplus">+   inconsistent (for example if deflate has already been called for this stream</span>
<a href="#l31.655"></a><span id="l31.655" class="difflineplus">+   or if not at a block boundary for raw deflate).  deflateSetDictionary does</span>
<a href="#l31.656"></a><span id="l31.656" class="difflineplus">+   not perform any compression: this will be done by deflate().</span>
<a href="#l31.657"></a><span id="l31.657" class="difflineplus">+*/</span>
<a href="#l31.658"></a><span id="l31.658" class="difflineplus">+</span>
<a href="#l31.659"></a><span id="l31.659" class="difflineplus">+ZEXTERN int ZEXPORT deflateGetDictionary OF((z_streamp strm,</span>
<a href="#l31.660"></a><span id="l31.660" class="difflineplus">+                                             Bytef *dictionary,</span>
<a href="#l31.661"></a><span id="l31.661" class="difflineplus">+                                             uInt  *dictLength));</span>
<a href="#l31.662"></a><span id="l31.662" class="difflineplus">+/*</span>
<a href="#l31.663"></a><span id="l31.663" class="difflineplus">+     Returns the sliding dictionary being maintained by deflate.  dictLength is</span>
<a href="#l31.664"></a><span id="l31.664" class="difflineplus">+   set to the number of bytes in the dictionary, and that many bytes are copied</span>
<a href="#l31.665"></a><span id="l31.665" class="difflineplus">+   to dictionary.  dictionary must have enough space, where 32768 bytes is</span>
<a href="#l31.666"></a><span id="l31.666" class="difflineplus">+   always enough.  If deflateGetDictionary() is called with dictionary equal to</span>
<a href="#l31.667"></a><span id="l31.667" class="difflineplus">+   Z_NULL, then only the dictionary length is returned, and nothing is copied.</span>
<a href="#l31.668"></a><span id="l31.668" class="difflineplus">+   Similary, if dictLength is Z_NULL, then it is not set.</span>
<a href="#l31.669"></a><span id="l31.669" class="difflineplus">+</span>
<a href="#l31.670"></a><span id="l31.670" class="difflineplus">+     deflateGetDictionary() may return a length less than the window size, even</span>
<a href="#l31.671"></a><span id="l31.671" class="difflineplus">+   when more than the window size in input has been provided. It may return up</span>
<a href="#l31.672"></a><span id="l31.672" class="difflineplus">+   to 258 bytes less in that case, due to how zlib's implementation of deflate</span>
<a href="#l31.673"></a><span id="l31.673" class="difflineplus">+   manages the sliding window and lookahead for matches, where matches can be</span>
<a href="#l31.674"></a><span id="l31.674" class="difflineplus">+   up to 258 bytes long. If the application needs the last window-size bytes of</span>
<a href="#l31.675"></a><span id="l31.675" class="difflineplus">+   input, then that would need to be saved by the application outside of zlib.</span>
<a href="#l31.676"></a><span id="l31.676" class="difflineplus">+</span>
<a href="#l31.677"></a><span id="l31.677" class="difflineplus">+     deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the</span>
<a href="#l31.678"></a><span id="l31.678" class="difflineplus">+   stream state is inconsistent.</span>
<a href="#l31.679"></a><span id="l31.679" class="difflineplus">+*/</span>
<a href="#l31.680"></a><span id="l31.680" class="difflineplus">+</span>
<a href="#l31.681"></a><span id="l31.681" class="difflineplus">+ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,</span>
<a href="#l31.682"></a><span id="l31.682" class="difflineplus">+                                    z_streamp source));</span>
<a href="#l31.683"></a><span id="l31.683" class="difflineplus">+/*</span>
<a href="#l31.684"></a><span id="l31.684" class="difflineplus">+     Sets the destination stream as a complete copy of the source stream.</span>
<a href="#l31.685"></a><span id="l31.685" class="difflineplus">+</span>
<a href="#l31.686"></a><span id="l31.686" class="difflineplus">+     This function can be useful when several compression strategies will be</span>
<a href="#l31.687"></a><span id="l31.687" class="difflineplus">+   tried, for example when there are several ways of pre-processing the input</span>
<a href="#l31.688"></a><span id="l31.688" class="difflineplus">+   data with a filter.  The streams that will be discarded should then be freed</span>
<a href="#l31.689"></a><span id="l31.689" class="difflineplus">+   by calling deflateEnd.  Note that deflateCopy duplicates the internal</span>
<a href="#l31.690"></a><span id="l31.690" class="difflineplus">+   compression state which can be quite large, so this strategy is slow and can</span>
<a href="#l31.691"></a><span id="l31.691" class="difflineplus">+   consume lots of memory.</span>
<a href="#l31.692"></a><span id="l31.692" class="difflineplus">+</span>
<a href="#l31.693"></a><span id="l31.693" class="difflineplus">+     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not</span>
<a href="#l31.694"></a><span id="l31.694" class="difflineplus">+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent</span>
<a href="#l31.695"></a><span id="l31.695" class="difflineplus">+   (such as zalloc being Z_NULL).  msg is left unchanged in both source and</span>
<a href="#l31.696"></a><span id="l31.696" class="difflineplus">+   destination.</span>
<a href="#l31.697"></a><span id="l31.697" class="difflineplus">+*/</span>
<a href="#l31.698"></a><span id="l31.698" class="difflineplus">+</span>
<a href="#l31.699"></a><span id="l31.699" class="difflineplus">+ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));</span>
<a href="#l31.700"></a><span id="l31.700" class="difflineplus">+/*</span>
<a href="#l31.701"></a><span id="l31.701" class="difflineplus">+     This function is equivalent to deflateEnd followed by deflateInit, but</span>
<a href="#l31.702"></a><span id="l31.702" class="difflineplus">+   does not free and reallocate the internal compression state.  The stream</span>
<a href="#l31.703"></a><span id="l31.703" class="difflineplus">+   will leave the compression level and any other attributes that may have been</span>
<a href="#l31.704"></a><span id="l31.704" class="difflineplus">+   set unchanged.</span>
<a href="#l31.705"></a><span id="l31.705" class="difflineplus">+</span>
<a href="#l31.706"></a><span id="l31.706" class="difflineplus">+     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source</span>
<a href="#l31.707"></a><span id="l31.707" class="difflineplus">+   stream state was inconsistent (such as zalloc or state being Z_NULL).</span>
<a href="#l31.708"></a><span id="l31.708" class="difflineplus">+*/</span>
<a href="#l31.709"></a><span id="l31.709" class="difflineplus">+</span>
<a href="#l31.710"></a><span id="l31.710" class="difflineplus">+ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,</span>
<a href="#l31.711"></a><span id="l31.711" class="difflineplus">+                                      int level,</span>
<a href="#l31.712"></a><span id="l31.712" class="difflineplus">+                                      int strategy));</span>
<a href="#l31.713"></a><span id="l31.713" class="difflineplus">+/*</span>
<a href="#l31.714"></a><span id="l31.714" class="difflineplus">+     Dynamically update the compression level and compression strategy.  The</span>
<a href="#l31.715"></a><span id="l31.715" class="difflineplus">+   interpretation of level and strategy is as in deflateInit2().  This can be</span>
<a href="#l31.716"></a><span id="l31.716" class="difflineplus">+   used to switch between compression and straight copy of the input data, or</span>
<a href="#l31.717"></a><span id="l31.717" class="difflineplus">+   to switch to a different kind of input data requiring a different strategy.</span>
<a href="#l31.718"></a><span id="l31.718" class="difflineplus">+   If the compression approach (which is a function of the level) or the</span>
<a href="#l31.719"></a><span id="l31.719" class="difflineplus">+   strategy is changed, and if any input has been consumed in a previous</span>
<a href="#l31.720"></a><span id="l31.720" class="difflineplus">+   deflate() call, then the input available so far is compressed with the old</span>
<a href="#l31.721"></a><span id="l31.721" class="difflineplus">+   level and strategy using deflate(strm, Z_BLOCK).  There are three approaches</span>
<a href="#l31.722"></a><span id="l31.722" class="difflineplus">+   for the compression levels 0, 1..3, and 4..9 respectively.  The new level</span>
<a href="#l31.723"></a><span id="l31.723" class="difflineplus">+   and strategy will take effect at the next call of deflate().</span>
<a href="#l31.724"></a><span id="l31.724" class="difflineplus">+</span>
<a href="#l31.725"></a><span id="l31.725" class="difflineplus">+     If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does</span>
<a href="#l31.726"></a><span id="l31.726" class="difflineplus">+   not have enough output space to complete, then the parameter change will not</span>
<a href="#l31.727"></a><span id="l31.727" class="difflineplus">+   take effect.  In this case, deflateParams() can be called again with the</span>
<a href="#l31.728"></a><span id="l31.728" class="difflineplus">+   same parameters and more output space to try again.</span>
<a href="#l31.729"></a><span id="l31.729" class="difflineplus">+</span>
<a href="#l31.730"></a><span id="l31.730" class="difflineplus">+     In order to assure a change in the parameters on the first try, the</span>
<a href="#l31.731"></a><span id="l31.731" class="difflineplus">+   deflate stream should be flushed using deflate() with Z_BLOCK or other flush</span>
<a href="#l31.732"></a><span id="l31.732" class="difflineplus">+   request until strm.avail_out is not zero, before calling deflateParams().</span>
<a href="#l31.733"></a><span id="l31.733" class="difflineplus">+   Then no more input data should be provided before the deflateParams() call.</span>
<a href="#l31.734"></a><span id="l31.734" class="difflineplus">+   If this is done, the old level and strategy will be applied to the data</span>
<a href="#l31.735"></a><span id="l31.735" class="difflineplus">+   compressed before deflateParams(), and the new level and strategy will be</span>
<a href="#l31.736"></a><span id="l31.736" class="difflineplus">+   applied to the the data compressed after deflateParams().</span>
<a href="#l31.737"></a><span id="l31.737" class="difflineplus">+</span>
<a href="#l31.738"></a><span id="l31.738" class="difflineplus">+     deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream</span>
<a href="#l31.739"></a><span id="l31.739" class="difflineplus">+   state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if</span>
<a href="#l31.740"></a><span id="l31.740" class="difflineplus">+   there was not enough output space to complete the compression of the</span>
<a href="#l31.741"></a><span id="l31.741" class="difflineplus">+   available input data before a change in the strategy or approach.  Note that</span>
<a href="#l31.742"></a><span id="l31.742" class="difflineplus">+   in the case of a Z_BUF_ERROR, the parameters are not changed.  A return</span>
<a href="#l31.743"></a><span id="l31.743" class="difflineplus">+   value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be</span>
<a href="#l31.744"></a><span id="l31.744" class="difflineplus">+   retried with more output space.</span>
<a href="#l31.745"></a><span id="l31.745" class="difflineplus">+*/</span>
<a href="#l31.746"></a><span id="l31.746" class="difflineplus">+</span>
<a href="#l31.747"></a><span id="l31.747" class="difflineplus">+ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,</span>
<a href="#l31.748"></a><span id="l31.748" class="difflineplus">+                                    int good_length,</span>
<a href="#l31.749"></a><span id="l31.749" class="difflineplus">+                                    int max_lazy,</span>
<a href="#l31.750"></a><span id="l31.750" class="difflineplus">+                                    int nice_length,</span>
<a href="#l31.751"></a><span id="l31.751" class="difflineplus">+                                    int max_chain));</span>
<a href="#l31.752"></a><span id="l31.752" class="difflineplus">+/*</span>
<a href="#l31.753"></a><span id="l31.753" class="difflineplus">+     Fine tune deflate's internal compression parameters.  This should only be</span>
<a href="#l31.754"></a><span id="l31.754" class="difflineplus">+   used by someone who understands the algorithm used by zlib's deflate for</span>
<a href="#l31.755"></a><span id="l31.755" class="difflineplus">+   searching for the best matching string, and even then only by the most</span>
<a href="#l31.756"></a><span id="l31.756" class="difflineplus">+   fanatic optimizer trying to squeeze out the last compressed bit for their</span>
<a href="#l31.757"></a><span id="l31.757" class="difflineplus">+   specific input data.  Read the deflate.c source code for the meaning of the</span>
<a href="#l31.758"></a><span id="l31.758" class="difflineplus">+   max_lazy, good_length, nice_length, and max_chain parameters.</span>
<a href="#l31.759"></a><span id="l31.759" class="difflineplus">+</span>
<a href="#l31.760"></a><span id="l31.760" class="difflineplus">+     deflateTune() can be called after deflateInit() or deflateInit2(), and</span>
<a href="#l31.761"></a><span id="l31.761" class="difflineplus">+   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.</span>
<a href="#l31.762"></a><span id="l31.762" class="difflineplus">+ */</span>
<a href="#l31.763"></a><span id="l31.763" class="difflineplus">+</span>
<a href="#l31.764"></a><span id="l31.764" class="difflineplus">+ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,</span>
<a href="#l31.765"></a><span id="l31.765" class="difflineplus">+                                       uLong sourceLen));</span>
<a href="#l31.766"></a><span id="l31.766" class="difflineplus">+/*</span>
<a href="#l31.767"></a><span id="l31.767" class="difflineplus">+     deflateBound() returns an upper bound on the compressed size after</span>
<a href="#l31.768"></a><span id="l31.768" class="difflineplus">+   deflation of sourceLen bytes.  It must be called after deflateInit() or</span>
<a href="#l31.769"></a><span id="l31.769" class="difflineplus">+   deflateInit2(), and after deflateSetHeader(), if used.  This would be used</span>
<a href="#l31.770"></a><span id="l31.770" class="difflineplus">+   to allocate an output buffer for deflation in a single pass, and so would be</span>
<a href="#l31.771"></a><span id="l31.771" class="difflineplus">+   called before deflate().  If that first deflate() call is provided the</span>
<a href="#l31.772"></a><span id="l31.772" class="difflineplus">+   sourceLen input bytes, an output buffer allocated to the size returned by</span>
<a href="#l31.773"></a><span id="l31.773" class="difflineplus">+   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed</span>
<a href="#l31.774"></a><span id="l31.774" class="difflineplus">+   to return Z_STREAM_END.  Note that it is possible for the compressed size to</span>
<a href="#l31.775"></a><span id="l31.775" class="difflineplus">+   be larger than the value returned by deflateBound() if flush options other</span>
<a href="#l31.776"></a><span id="l31.776" class="difflineplus">+   than Z_FINISH or Z_NO_FLUSH are used.</span>
<a href="#l31.777"></a><span id="l31.777" class="difflineplus">+*/</span>
<a href="#l31.778"></a><span id="l31.778" class="difflineplus">+</span>
<a href="#l31.779"></a><span id="l31.779" class="difflineplus">+ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,</span>
<a href="#l31.780"></a><span id="l31.780" class="difflineplus">+                                       unsigned *pending,</span>
<a href="#l31.781"></a><span id="l31.781" class="difflineplus">+                                       int *bits));</span>
<a href="#l31.782"></a><span id="l31.782" class="difflineplus">+/*</span>
<a href="#l31.783"></a><span id="l31.783" class="difflineplus">+     deflatePending() returns the number of bytes and bits of output that have</span>
<a href="#l31.784"></a><span id="l31.784" class="difflineplus">+   been generated, but not yet provided in the available output.  The bytes not</span>
<a href="#l31.785"></a><span id="l31.785" class="difflineplus">+   provided would be due to the available output space having being consumed.</span>
<a href="#l31.786"></a><span id="l31.786" class="difflineplus">+   The number of bits of output not provided are between 0 and 7, where they</span>
<a href="#l31.787"></a><span id="l31.787" class="difflineplus">+   await more bits to join them in order to fill out a full byte.  If pending</span>
<a href="#l31.788"></a><span id="l31.788" class="difflineplus">+   or bits are Z_NULL, then those values are not set.</span>
<a href="#l31.789"></a><span id="l31.789" class="difflineplus">+</span>
<a href="#l31.790"></a><span id="l31.790" class="difflineplus">+     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source</span>
<a href="#l31.791"></a><span id="l31.791" class="difflineplus">+   stream state was inconsistent.</span>
<a href="#l31.792"></a><span id="l31.792" class="difflineplus">+ */</span>
<a href="#l31.793"></a><span id="l31.793" class="difflineplus">+</span>
<a href="#l31.794"></a><span id="l31.794" class="difflineplus">+ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,</span>
<a href="#l31.795"></a><span id="l31.795" class="difflineplus">+                                     int bits,</span>
<a href="#l31.796"></a><span id="l31.796" class="difflineplus">+                                     int value));</span>
<a href="#l31.797"></a><span id="l31.797" class="difflineplus">+/*</span>
<a href="#l31.798"></a><span id="l31.798" class="difflineplus">+     deflatePrime() inserts bits in the deflate output stream.  The intent</span>
<a href="#l31.799"></a><span id="l31.799" class="difflineplus">+   is that this function is used to start off the deflate output with the bits</span>
<a href="#l31.800"></a><span id="l31.800" class="difflineplus">+   leftover from a previous deflate stream when appending to it.  As such, this</span>
<a href="#l31.801"></a><span id="l31.801" class="difflineplus">+   function can only be used for raw deflate, and must be used before the first</span>
<a href="#l31.802"></a><span id="l31.802" class="difflineplus">+   deflate() call after a deflateInit2() or deflateReset().  bits must be less</span>
<a href="#l31.803"></a><span id="l31.803" class="difflineplus">+   than or equal to 16, and that many of the least significant bits of value</span>
<a href="#l31.804"></a><span id="l31.804" class="difflineplus">+   will be inserted in the output.</span>
<a href="#l31.805"></a><span id="l31.805" class="difflineplus">+</span>
<a href="#l31.806"></a><span id="l31.806" class="difflineplus">+     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough</span>
<a href="#l31.807"></a><span id="l31.807" class="difflineplus">+   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the</span>
<a href="#l31.808"></a><span id="l31.808" class="difflineplus">+   source stream state was inconsistent.</span>
<a href="#l31.809"></a><span id="l31.809" class="difflineplus">+*/</span>
<a href="#l31.810"></a><span id="l31.810" class="difflineplus">+</span>
<a href="#l31.811"></a><span id="l31.811" class="difflineplus">+ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,</span>
<a href="#l31.812"></a><span id="l31.812" class="difflineplus">+                                         gz_headerp head));</span>
<a href="#l31.813"></a><span id="l31.813" class="difflineplus">+/*</span>
<a href="#l31.814"></a><span id="l31.814" class="difflineplus">+     deflateSetHeader() provides gzip header information for when a gzip</span>
<a href="#l31.815"></a><span id="l31.815" class="difflineplus">+   stream is requested by deflateInit2().  deflateSetHeader() may be called</span>
<a href="#l31.816"></a><span id="l31.816" class="difflineplus">+   after deflateInit2() or deflateReset() and before the first call of</span>
<a href="#l31.817"></a><span id="l31.817" class="difflineplus">+   deflate().  The text, time, os, extra field, name, and comment information</span>
<a href="#l31.818"></a><span id="l31.818" class="difflineplus">+   in the provided gz_header structure are written to the gzip header (xflag is</span>
<a href="#l31.819"></a><span id="l31.819" class="difflineplus">+   ignored -- the extra flags are set according to the compression level).  The</span>
<a href="#l31.820"></a><span id="l31.820" class="difflineplus">+   caller must assure that, if not Z_NULL, name and comment are terminated with</span>
<a href="#l31.821"></a><span id="l31.821" class="difflineplus">+   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are</span>
<a href="#l31.822"></a><span id="l31.822" class="difflineplus">+   available there.  If hcrc is true, a gzip header crc is included.  Note that</span>
<a href="#l31.823"></a><span id="l31.823" class="difflineplus">+   the current versions of the command-line version of gzip (up through version</span>
<a href="#l31.824"></a><span id="l31.824" class="difflineplus">+   1.3.x) do not support header crc's, and will report that it is a &quot;multi-part</span>
<a href="#l31.825"></a><span id="l31.825" class="difflineplus">+   gzip file&quot; and give up.</span>
<a href="#l31.826"></a><span id="l31.826" class="difflineplus">+</span>
<a href="#l31.827"></a><span id="l31.827" class="difflineplus">+     If deflateSetHeader is not used, the default gzip header has text false,</span>
<a href="#l31.828"></a><span id="l31.828" class="difflineplus">+   the time set to zero, and os set to 255, with no extra, name, or comment</span>
<a href="#l31.829"></a><span id="l31.829" class="difflineplus">+   fields.  The gzip header is returned to the default state by deflateReset().</span>
<a href="#l31.830"></a><span id="l31.830" class="difflineplus">+</span>
<a href="#l31.831"></a><span id="l31.831" class="difflineplus">+     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source</span>
<a href="#l31.832"></a><span id="l31.832" class="difflineplus">+   stream state was inconsistent.</span>
<a href="#l31.833"></a><span id="l31.833" class="difflineplus">+*/</span>
<a href="#l31.834"></a><span id="l31.834" class="difflineplus">+</span>
<a href="#l31.835"></a><span id="l31.835" class="difflineplus">+/*</span>
<a href="#l31.836"></a><span id="l31.836" class="difflineplus">+ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,</span>
<a href="#l31.837"></a><span id="l31.837" class="difflineplus">+                                     int  windowBits));</span>
<a href="#l31.838"></a><span id="l31.838" class="difflineplus">+</span>
<a href="#l31.839"></a><span id="l31.839" class="difflineplus">+     This is another version of inflateInit with an extra parameter.  The</span>
<a href="#l31.840"></a><span id="l31.840" class="difflineplus">+   fields next_in, avail_in, zalloc, zfree and opaque must be initialized</span>
<a href="#l31.841"></a><span id="l31.841" class="difflineplus">+   before by the caller.</span>
<a href="#l31.842"></a><span id="l31.842" class="difflineplus">+</span>
<a href="#l31.843"></a><span id="l31.843" class="difflineplus">+     The windowBits parameter is the base two logarithm of the maximum window</span>
<a href="#l31.844"></a><span id="l31.844" class="difflineplus">+   size (the size of the history buffer).  It should be in the range 8..15 for</span>
<a href="#l31.845"></a><span id="l31.845" class="difflineplus">+   this version of the library.  The default value is 15 if inflateInit is used</span>
<a href="#l31.846"></a><span id="l31.846" class="difflineplus">+   instead.  windowBits must be greater than or equal to the windowBits value</span>
<a href="#l31.847"></a><span id="l31.847" class="difflineplus">+   provided to deflateInit2() while compressing, or it must be equal to 15 if</span>
<a href="#l31.848"></a><span id="l31.848" class="difflineplus">+   deflateInit2() was not used.  If a compressed stream with a larger window</span>
<a href="#l31.849"></a><span id="l31.849" class="difflineplus">+   size is given as input, inflate() will return with the error code</span>
<a href="#l31.850"></a><span id="l31.850" class="difflineplus">+   Z_DATA_ERROR instead of trying to allocate a larger window.</span>
<a href="#l31.851"></a><span id="l31.851" class="difflineplus">+</span>
<a href="#l31.852"></a><span id="l31.852" class="difflineplus">+     windowBits can also be zero to request that inflate use the window size in</span>
<a href="#l31.853"></a><span id="l31.853" class="difflineplus">+   the zlib header of the compressed stream.</span>
<a href="#l31.854"></a><span id="l31.854" class="difflineplus">+</span>
<a href="#l31.855"></a><span id="l31.855" class="difflineplus">+     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits</span>
<a href="#l31.856"></a><span id="l31.856" class="difflineplus">+   determines the window size.  inflate() will then process raw deflate data,</span>
<a href="#l31.857"></a><span id="l31.857" class="difflineplus">+   not looking for a zlib or gzip header, not generating a check value, and not</span>
<a href="#l31.858"></a><span id="l31.858" class="difflineplus">+   looking for any check values for comparison at the end of the stream.  This</span>
<a href="#l31.859"></a><span id="l31.859" class="difflineplus">+   is for use with other formats that use the deflate compressed data format</span>
<a href="#l31.860"></a><span id="l31.860" class="difflineplus">+   such as zip.  Those formats provide their own check values.  If a custom</span>
<a href="#l31.861"></a><span id="l31.861" class="difflineplus">+   format is developed using the raw deflate format for compressed data, it is</span>
<a href="#l31.862"></a><span id="l31.862" class="difflineplus">+   recommended that a check value such as an Adler-32 or a CRC-32 be applied to</span>
<a href="#l31.863"></a><span id="l31.863" class="difflineplus">+   the uncompressed data as is done in the zlib, gzip, and zip formats.  For</span>
<a href="#l31.864"></a><span id="l31.864" class="difflineplus">+   most applications, the zlib format should be used as is.  Note that comments</span>
<a href="#l31.865"></a><span id="l31.865" class="difflineplus">+   above on the use in deflateInit2() applies to the magnitude of windowBits.</span>
<a href="#l31.866"></a><span id="l31.866" class="difflineplus">+</span>
<a href="#l31.867"></a><span id="l31.867" class="difflineplus">+     windowBits can also be greater than 15 for optional gzip decoding.  Add</span>
<a href="#l31.868"></a><span id="l31.868" class="difflineplus">+   32 to windowBits to enable zlib and gzip decoding with automatic header</span>
<a href="#l31.869"></a><span id="l31.869" class="difflineplus">+   detection, or add 16 to decode only the gzip format (the zlib format will</span>
<a href="#l31.870"></a><span id="l31.870" class="difflineplus">+   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm-&gt;adler is a</span>
<a href="#l31.871"></a><span id="l31.871" class="difflineplus">+   CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see</span>
<a href="#l31.872"></a><span id="l31.872" class="difflineplus">+   below), inflate() will not automatically decode concatenated gzip streams.</span>
<a href="#l31.873"></a><span id="l31.873" class="difflineplus">+   inflate() will return Z_STREAM_END at the end of the gzip stream.  The state</span>
<a href="#l31.874"></a><span id="l31.874" class="difflineplus">+   would need to be reset to continue decoding a subsequent gzip stream.</span>
<a href="#l31.875"></a><span id="l31.875" class="difflineplus">+</span>
<a href="#l31.876"></a><span id="l31.876" class="difflineplus">+     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
<a href="#l31.877"></a><span id="l31.877" class="difflineplus">+   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the</span>
<a href="#l31.878"></a><span id="l31.878" class="difflineplus">+   version assumed by the caller, or Z_STREAM_ERROR if the parameters are</span>
<a href="#l31.879"></a><span id="l31.879" class="difflineplus">+   invalid, such as a null pointer to the structure.  msg is set to null if</span>
<a href="#l31.880"></a><span id="l31.880" class="difflineplus">+   there is no error message.  inflateInit2 does not perform any decompression</span>
<a href="#l31.881"></a><span id="l31.881" class="difflineplus">+   apart from possibly reading the zlib header if present: actual decompression</span>
<a href="#l31.882"></a><span id="l31.882" class="difflineplus">+   will be done by inflate().  (So next_in and avail_in may be modified, but</span>
<a href="#l31.883"></a><span id="l31.883" class="difflineplus">+   next_out and avail_out are unused and unchanged.) The current implementation</span>
<a href="#l31.884"></a><span id="l31.884" class="difflineplus">+   of inflateInit2() does not process any header information -- that is</span>
<a href="#l31.885"></a><span id="l31.885" class="difflineplus">+   deferred until inflate() is called.</span>
<a href="#l31.886"></a><span id="l31.886" class="difflineplus">+*/</span>
<a href="#l31.887"></a><span id="l31.887" class="difflineplus">+</span>
<a href="#l31.888"></a><span id="l31.888" class="difflineplus">+ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,</span>
<a href="#l31.889"></a><span id="l31.889" class="difflineplus">+                                             const Bytef *dictionary,</span>
<a href="#l31.890"></a><span id="l31.890" class="difflineplus">+                                             uInt  dictLength));</span>
<a href="#l31.891"></a><span id="l31.891" class="difflineplus">+/*</span>
<a href="#l31.892"></a><span id="l31.892" class="difflineplus">+     Initializes the decompression dictionary from the given uncompressed byte</span>
<a href="#l31.893"></a><span id="l31.893" class="difflineplus">+   sequence.  This function must be called immediately after a call of inflate,</span>
<a href="#l31.894"></a><span id="l31.894" class="difflineplus">+   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor</span>
<a href="#l31.895"></a><span id="l31.895" class="difflineplus">+   can be determined from the Adler-32 value returned by that call of inflate.</span>
<a href="#l31.896"></a><span id="l31.896" class="difflineplus">+   The compressor and decompressor must use exactly the same dictionary (see</span>
<a href="#l31.897"></a><span id="l31.897" class="difflineplus">+   deflateSetDictionary).  For raw inflate, this function can be called at any</span>
<a href="#l31.898"></a><span id="l31.898" class="difflineplus">+   time to set the dictionary.  If the provided dictionary is smaller than the</span>
<a href="#l31.899"></a><span id="l31.899" class="difflineplus">+   window and there is already data in the window, then the provided dictionary</span>
<a href="#l31.900"></a><span id="l31.900" class="difflineplus">+   will amend what's there.  The application must insure that the dictionary</span>
<a href="#l31.901"></a><span id="l31.901" class="difflineplus">+   that was used for compression is provided.</span>
<a href="#l31.902"></a><span id="l31.902" class="difflineplus">+</span>
<a href="#l31.903"></a><span id="l31.903" class="difflineplus">+     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a</span>
<a href="#l31.904"></a><span id="l31.904" class="difflineplus">+   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is</span>
<a href="#l31.905"></a><span id="l31.905" class="difflineplus">+   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the</span>
<a href="#l31.906"></a><span id="l31.906" class="difflineplus">+   expected one (incorrect Adler-32 value).  inflateSetDictionary does not</span>
<a href="#l31.907"></a><span id="l31.907" class="difflineplus">+   perform any decompression: this will be done by subsequent calls of</span>
<a href="#l31.908"></a><span id="l31.908" class="difflineplus">+   inflate().</span>
<a href="#l31.909"></a><span id="l31.909" class="difflineplus">+*/</span>
<a href="#l31.910"></a><span id="l31.910" class="difflineplus">+</span>
<a href="#l31.911"></a><span id="l31.911" class="difflineplus">+ZEXTERN int ZEXPORT inflateGetDictionary OF((z_streamp strm,</span>
<a href="#l31.912"></a><span id="l31.912" class="difflineplus">+                                             Bytef *dictionary,</span>
<a href="#l31.913"></a><span id="l31.913" class="difflineplus">+                                             uInt  *dictLength));</span>
<a href="#l31.914"></a><span id="l31.914" class="difflineplus">+/*</span>
<a href="#l31.915"></a><span id="l31.915" class="difflineplus">+     Returns the sliding dictionary being maintained by inflate.  dictLength is</span>
<a href="#l31.916"></a><span id="l31.916" class="difflineplus">+   set to the number of bytes in the dictionary, and that many bytes are copied</span>
<a href="#l31.917"></a><span id="l31.917" class="difflineplus">+   to dictionary.  dictionary must have enough space, where 32768 bytes is</span>
<a href="#l31.918"></a><span id="l31.918" class="difflineplus">+   always enough.  If inflateGetDictionary() is called with dictionary equal to</span>
<a href="#l31.919"></a><span id="l31.919" class="difflineplus">+   Z_NULL, then only the dictionary length is returned, and nothing is copied.</span>
<a href="#l31.920"></a><span id="l31.920" class="difflineplus">+   Similary, if dictLength is Z_NULL, then it is not set.</span>
<a href="#l31.921"></a><span id="l31.921" class="difflineplus">+</span>
<a href="#l31.922"></a><span id="l31.922" class="difflineplus">+     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the</span>
<a href="#l31.923"></a><span id="l31.923" class="difflineplus">+   stream state is inconsistent.</span>
<a href="#l31.924"></a><span id="l31.924" class="difflineplus">+*/</span>
<a href="#l31.925"></a><span id="l31.925" class="difflineplus">+</span>
<a href="#l31.926"></a><span id="l31.926" class="difflineplus">+ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));</span>
<a href="#l31.927"></a><span id="l31.927" class="difflineplus">+/*</span>
<a href="#l31.928"></a><span id="l31.928" class="difflineplus">+     Skips invalid compressed data until a possible full flush point (see above</span>
<a href="#l31.929"></a><span id="l31.929" class="difflineplus">+   for the description of deflate with Z_FULL_FLUSH) can be found, or until all</span>
<a href="#l31.930"></a><span id="l31.930" class="difflineplus">+   available input is skipped.  No output is provided.</span>
<a href="#l31.931"></a><span id="l31.931" class="difflineplus">+</span>
<a href="#l31.932"></a><span id="l31.932" class="difflineplus">+     inflateSync searches for a 00 00 FF FF pattern in the compressed data.</span>
<a href="#l31.933"></a><span id="l31.933" class="difflineplus">+   All full flush points have this pattern, but not all occurrences of this</span>
<a href="#l31.934"></a><span id="l31.934" class="difflineplus">+   pattern are full flush points.</span>
<a href="#l31.935"></a><span id="l31.935" class="difflineplus">+</span>
<a href="#l31.936"></a><span id="l31.936" class="difflineplus">+     inflateSync returns Z_OK if a possible full flush point has been found,</span>
<a href="#l31.937"></a><span id="l31.937" class="difflineplus">+   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point</span>
<a href="#l31.938"></a><span id="l31.938" class="difflineplus">+   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.</span>
<a href="#l31.939"></a><span id="l31.939" class="difflineplus">+   In the success case, the application may save the current current value of</span>
<a href="#l31.940"></a><span id="l31.940" class="difflineplus">+   total_in which indicates where valid compressed data was found.  In the</span>
<a href="#l31.941"></a><span id="l31.941" class="difflineplus">+   error case, the application may repeatedly call inflateSync, providing more</span>
<a href="#l31.942"></a><span id="l31.942" class="difflineplus">+   input each time, until success or end of the input data.</span>
<a href="#l31.943"></a><span id="l31.943" class="difflineplus">+*/</span>
<a href="#l31.944"></a><span id="l31.944" class="difflineplus">+</span>
<a href="#l31.945"></a><span id="l31.945" class="difflineplus">+ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,</span>
<a href="#l31.946"></a><span id="l31.946" class="difflineplus">+                                    z_streamp source));</span>
<a href="#l31.947"></a><span id="l31.947" class="difflineplus">+/*</span>
<a href="#l31.948"></a><span id="l31.948" class="difflineplus">+     Sets the destination stream as a complete copy of the source stream.</span>
<a href="#l31.949"></a><span id="l31.949" class="difflineplus">+</span>
<a href="#l31.950"></a><span id="l31.950" class="difflineplus">+     This function can be useful when randomly accessing a large stream.  The</span>
<a href="#l31.951"></a><span id="l31.951" class="difflineplus">+   first pass through the stream can periodically record the inflate state,</span>
<a href="#l31.952"></a><span id="l31.952" class="difflineplus">+   allowing restarting inflate at those points when randomly accessing the</span>
<a href="#l31.953"></a><span id="l31.953" class="difflineplus">+   stream.</span>
<a href="#l31.954"></a><span id="l31.954" class="difflineplus">+</span>
<a href="#l31.955"></a><span id="l31.955" class="difflineplus">+     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not</span>
<a href="#l31.956"></a><span id="l31.956" class="difflineplus">+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent</span>
<a href="#l31.957"></a><span id="l31.957" class="difflineplus">+   (such as zalloc being Z_NULL).  msg is left unchanged in both source and</span>
<a href="#l31.958"></a><span id="l31.958" class="difflineplus">+   destination.</span>
<a href="#l31.959"></a><span id="l31.959" class="difflineplus">+*/</span>
<a href="#l31.960"></a><span id="l31.960" class="difflineplus">+</span>
<a href="#l31.961"></a><span id="l31.961" class="difflineplus">+ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));</span>
<a href="#l31.962"></a><span id="l31.962" class="difflineplus">+/*</span>
<a href="#l31.963"></a><span id="l31.963" class="difflineplus">+     This function is equivalent to inflateEnd followed by inflateInit,</span>
<a href="#l31.964"></a><span id="l31.964" class="difflineplus">+   but does not free and reallocate the internal decompression state.  The</span>
<a href="#l31.965"></a><span id="l31.965" class="difflineplus">+   stream will keep attributes that may have been set by inflateInit2.</span>
<a href="#l31.966"></a><span id="l31.966" class="difflineplus">+</span>
<a href="#l31.967"></a><span id="l31.967" class="difflineplus">+     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source</span>
<a href="#l31.968"></a><span id="l31.968" class="difflineplus">+   stream state was inconsistent (such as zalloc or state being Z_NULL).</span>
<a href="#l31.969"></a><span id="l31.969" class="difflineplus">+*/</span>
<a href="#l31.970"></a><span id="l31.970" class="difflineplus">+</span>
<a href="#l31.971"></a><span id="l31.971" class="difflineplus">+ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,</span>
<a href="#l31.972"></a><span id="l31.972" class="difflineplus">+                                      int windowBits));</span>
<a href="#l31.973"></a><span id="l31.973" class="difflineplus">+/*</span>
<a href="#l31.974"></a><span id="l31.974" class="difflineplus">+     This function is the same as inflateReset, but it also permits changing</span>
<a href="#l31.975"></a><span id="l31.975" class="difflineplus">+   the wrap and window size requests.  The windowBits parameter is interpreted</span>
<a href="#l31.976"></a><span id="l31.976" class="difflineplus">+   the same as it is for inflateInit2.  If the window size is changed, then the</span>
<a href="#l31.977"></a><span id="l31.977" class="difflineplus">+   memory allocated for the window is freed, and the window will be reallocated</span>
<a href="#l31.978"></a><span id="l31.978" class="difflineplus">+   by inflate() if needed.</span>
<a href="#l31.979"></a><span id="l31.979" class="difflineplus">+</span>
<a href="#l31.980"></a><span id="l31.980" class="difflineplus">+     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source</span>
<a href="#l31.981"></a><span id="l31.981" class="difflineplus">+   stream state was inconsistent (such as zalloc or state being Z_NULL), or if</span>
<a href="#l31.982"></a><span id="l31.982" class="difflineplus">+   the windowBits parameter is invalid.</span>
<a href="#l31.983"></a><span id="l31.983" class="difflineplus">+*/</span>
<a href="#l31.984"></a><span id="l31.984" class="difflineplus">+</span>
<a href="#l31.985"></a><span id="l31.985" class="difflineplus">+ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,</span>
<a href="#l31.986"></a><span id="l31.986" class="difflineplus">+                                     int bits,</span>
<a href="#l31.987"></a><span id="l31.987" class="difflineplus">+                                     int value));</span>
<a href="#l31.988"></a><span id="l31.988" class="difflineplus">+/*</span>
<a href="#l31.989"></a><span id="l31.989" class="difflineplus">+     This function inserts bits in the inflate input stream.  The intent is</span>
<a href="#l31.990"></a><span id="l31.990" class="difflineplus">+   that this function is used to start inflating at a bit position in the</span>
<a href="#l31.991"></a><span id="l31.991" class="difflineplus">+   middle of a byte.  The provided bits will be used before any bytes are used</span>
<a href="#l31.992"></a><span id="l31.992" class="difflineplus">+   from next_in.  This function should only be used with raw inflate, and</span>
<a href="#l31.993"></a><span id="l31.993" class="difflineplus">+   should be used before the first inflate() call after inflateInit2() or</span>
<a href="#l31.994"></a><span id="l31.994" class="difflineplus">+   inflateReset().  bits must be less than or equal to 16, and that many of the</span>
<a href="#l31.995"></a><span id="l31.995" class="difflineplus">+   least significant bits of value will be inserted in the input.</span>
<a href="#l31.996"></a><span id="l31.996" class="difflineplus">+</span>
<a href="#l31.997"></a><span id="l31.997" class="difflineplus">+     If bits is negative, then the input stream bit buffer is emptied.  Then</span>
<a href="#l31.998"></a><span id="l31.998" class="difflineplus">+   inflatePrime() can be called again to put bits in the buffer.  This is used</span>
<a href="#l31.999"></a><span id="l31.999" class="difflineplus">+   to clear out bits leftover after feeding inflate a block description prior</span>
<a href="#l31.1000"></a><span id="l31.1000" class="difflineplus">+   to feeding inflate codes.</span>
<a href="#l31.1001"></a><span id="l31.1001" class="difflineplus">+</span>
<a href="#l31.1002"></a><span id="l31.1002" class="difflineplus">+     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source</span>
<a href="#l31.1003"></a><span id="l31.1003" class="difflineplus">+   stream state was inconsistent.</span>
<a href="#l31.1004"></a><span id="l31.1004" class="difflineplus">+*/</span>
<a href="#l31.1005"></a><span id="l31.1005" class="difflineplus">+</span>
<a href="#l31.1006"></a><span id="l31.1006" class="difflineplus">+ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));</span>
<a href="#l31.1007"></a><span id="l31.1007" class="difflineplus">+/*</span>
<a href="#l31.1008"></a><span id="l31.1008" class="difflineplus">+     This function returns two values, one in the lower 16 bits of the return</span>
<a href="#l31.1009"></a><span id="l31.1009" class="difflineplus">+   value, and the other in the remaining upper bits, obtained by shifting the</span>
<a href="#l31.1010"></a><span id="l31.1010" class="difflineplus">+   return value down 16 bits.  If the upper value is -1 and the lower value is</span>
<a href="#l31.1011"></a><span id="l31.1011" class="difflineplus">+   zero, then inflate() is currently decoding information outside of a block.</span>
<a href="#l31.1012"></a><span id="l31.1012" class="difflineplus">+   If the upper value is -1 and the lower value is non-zero, then inflate is in</span>
<a href="#l31.1013"></a><span id="l31.1013" class="difflineplus">+   the middle of a stored block, with the lower value equaling the number of</span>
<a href="#l31.1014"></a><span id="l31.1014" class="difflineplus">+   bytes from the input remaining to copy.  If the upper value is not -1, then</span>
<a href="#l31.1015"></a><span id="l31.1015" class="difflineplus">+   it is the number of bits back from the current bit position in the input of</span>
<a href="#l31.1016"></a><span id="l31.1016" class="difflineplus">+   the code (literal or length/distance pair) currently being processed.  In</span>
<a href="#l31.1017"></a><span id="l31.1017" class="difflineplus">+   that case the lower value is the number of bytes already emitted for that</span>
<a href="#l31.1018"></a><span id="l31.1018" class="difflineplus">+   code.</span>
<a href="#l31.1019"></a><span id="l31.1019" class="difflineplus">+</span>
<a href="#l31.1020"></a><span id="l31.1020" class="difflineplus">+     A code is being processed if inflate is waiting for more input to complete</span>
<a href="#l31.1021"></a><span id="l31.1021" class="difflineplus">+   decoding of the code, or if it has completed decoding but is waiting for</span>
<a href="#l31.1022"></a><span id="l31.1022" class="difflineplus">+   more output space to write the literal or match data.</span>
<a href="#l31.1023"></a><span id="l31.1023" class="difflineplus">+</span>
<a href="#l31.1024"></a><span id="l31.1024" class="difflineplus">+     inflateMark() is used to mark locations in the input data for random</span>
<a href="#l31.1025"></a><span id="l31.1025" class="difflineplus">+   access, which may be at bit positions, and to note those cases where the</span>
<a href="#l31.1026"></a><span id="l31.1026" class="difflineplus">+   output of a code may span boundaries of random access blocks.  The current</span>
<a href="#l31.1027"></a><span id="l31.1027" class="difflineplus">+   location in the input stream can be determined from avail_in and data_type</span>
<a href="#l31.1028"></a><span id="l31.1028" class="difflineplus">+   as noted in the description for the Z_BLOCK flush parameter for inflate.</span>
<a href="#l31.1029"></a><span id="l31.1029" class="difflineplus">+</span>
<a href="#l31.1030"></a><span id="l31.1030" class="difflineplus">+     inflateMark returns the value noted above, or -65536 if the provided</span>
<a href="#l31.1031"></a><span id="l31.1031" class="difflineplus">+   source stream state was inconsistent.</span>
<a href="#l31.1032"></a><span id="l31.1032" class="difflineplus">+*/</span>
<a href="#l31.1033"></a><span id="l31.1033" class="difflineplus">+</span>
<a href="#l31.1034"></a><span id="l31.1034" class="difflineplus">+ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,</span>
<a href="#l31.1035"></a><span id="l31.1035" class="difflineplus">+                                         gz_headerp head));</span>
<a href="#l31.1036"></a><span id="l31.1036" class="difflineplus">+/*</span>
<a href="#l31.1037"></a><span id="l31.1037" class="difflineplus">+     inflateGetHeader() requests that gzip header information be stored in the</span>
<a href="#l31.1038"></a><span id="l31.1038" class="difflineplus">+   provided gz_header structure.  inflateGetHeader() may be called after</span>
<a href="#l31.1039"></a><span id="l31.1039" class="difflineplus">+   inflateInit2() or inflateReset(), and before the first call of inflate().</span>
<a href="#l31.1040"></a><span id="l31.1040" class="difflineplus">+   As inflate() processes the gzip stream, head-&gt;done is zero until the header</span>
<a href="#l31.1041"></a><span id="l31.1041" class="difflineplus">+   is completed, at which time head-&gt;done is set to one.  If a zlib stream is</span>
<a href="#l31.1042"></a><span id="l31.1042" class="difflineplus">+   being decoded, then head-&gt;done is set to -1 to indicate that there will be</span>
<a href="#l31.1043"></a><span id="l31.1043" class="difflineplus">+   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be</span>
<a href="#l31.1044"></a><span id="l31.1044" class="difflineplus">+   used to force inflate() to return immediately after header processing is</span>
<a href="#l31.1045"></a><span id="l31.1045" class="difflineplus">+   complete and before any actual data is decompressed.</span>
<a href="#l31.1046"></a><span id="l31.1046" class="difflineplus">+</span>
<a href="#l31.1047"></a><span id="l31.1047" class="difflineplus">+     The text, time, xflags, and os fields are filled in with the gzip header</span>
<a href="#l31.1048"></a><span id="l31.1048" class="difflineplus">+   contents.  hcrc is set to true if there is a header CRC.  (The header CRC</span>
<a href="#l31.1049"></a><span id="l31.1049" class="difflineplus">+   was valid if done is set to one.) If extra is not Z_NULL, then extra_max</span>
<a href="#l31.1050"></a><span id="l31.1050" class="difflineplus">+   contains the maximum number of bytes to write to extra.  Once done is true,</span>
<a href="#l31.1051"></a><span id="l31.1051" class="difflineplus">+   extra_len contains the actual extra field length, and extra contains the</span>
<a href="#l31.1052"></a><span id="l31.1052" class="difflineplus">+   extra field, or that field truncated if extra_max is less than extra_len.</span>
<a href="#l31.1053"></a><span id="l31.1053" class="difflineplus">+   If name is not Z_NULL, then up to name_max characters are written there,</span>
<a href="#l31.1054"></a><span id="l31.1054" class="difflineplus">+   terminated with a zero unless the length is greater than name_max.  If</span>
<a href="#l31.1055"></a><span id="l31.1055" class="difflineplus">+   comment is not Z_NULL, then up to comm_max characters are written there,</span>
<a href="#l31.1056"></a><span id="l31.1056" class="difflineplus">+   terminated with a zero unless the length is greater than comm_max.  When any</span>
<a href="#l31.1057"></a><span id="l31.1057" class="difflineplus">+   of extra, name, or comment are not Z_NULL and the respective field is not</span>
<a href="#l31.1058"></a><span id="l31.1058" class="difflineplus">+   present in the header, then that field is set to Z_NULL to signal its</span>
<a href="#l31.1059"></a><span id="l31.1059" class="difflineplus">+   absence.  This allows the use of deflateSetHeader() with the returned</span>
<a href="#l31.1060"></a><span id="l31.1060" class="difflineplus">+   structure to duplicate the header.  However if those fields are set to</span>
<a href="#l31.1061"></a><span id="l31.1061" class="difflineplus">+   allocated memory, then the application will need to save those pointers</span>
<a href="#l31.1062"></a><span id="l31.1062" class="difflineplus">+   elsewhere so that they can be eventually freed.</span>
<a href="#l31.1063"></a><span id="l31.1063" class="difflineplus">+</span>
<a href="#l31.1064"></a><span id="l31.1064" class="difflineplus">+     If inflateGetHeader is not used, then the header information is simply</span>
<a href="#l31.1065"></a><span id="l31.1065" class="difflineplus">+   discarded.  The header is always checked for validity, including the header</span>
<a href="#l31.1066"></a><span id="l31.1066" class="difflineplus">+   CRC if present.  inflateReset() will reset the process to discard the header</span>
<a href="#l31.1067"></a><span id="l31.1067" class="difflineplus">+   information.  The application would need to call inflateGetHeader() again to</span>
<a href="#l31.1068"></a><span id="l31.1068" class="difflineplus">+   retrieve the header from the next gzip stream.</span>
<a href="#l31.1069"></a><span id="l31.1069" class="difflineplus">+</span>
<a href="#l31.1070"></a><span id="l31.1070" class="difflineplus">+     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source</span>
<a href="#l31.1071"></a><span id="l31.1071" class="difflineplus">+   stream state was inconsistent.</span>
<a href="#l31.1072"></a><span id="l31.1072" class="difflineplus">+*/</span>
<a href="#l31.1073"></a><span id="l31.1073" class="difflineplus">+</span>
<a href="#l31.1074"></a><span id="l31.1074" class="difflineplus">+/*</span>
<a href="#l31.1075"></a><span id="l31.1075" class="difflineplus">+ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,</span>
<a href="#l31.1076"></a><span id="l31.1076" class="difflineplus">+                                        unsigned char FAR *window));</span>
<a href="#l31.1077"></a><span id="l31.1077" class="difflineplus">+</span>
<a href="#l31.1078"></a><span id="l31.1078" class="difflineplus">+     Initialize the internal stream state for decompression using inflateBack()</span>
<a href="#l31.1079"></a><span id="l31.1079" class="difflineplus">+   calls.  The fields zalloc, zfree and opaque in strm must be initialized</span>
<a href="#l31.1080"></a><span id="l31.1080" class="difflineplus">+   before the call.  If zalloc and zfree are Z_NULL, then the default library-</span>
<a href="#l31.1081"></a><span id="l31.1081" class="difflineplus">+   derived memory allocation routines are used.  windowBits is the base two</span>
<a href="#l31.1082"></a><span id="l31.1082" class="difflineplus">+   logarithm of the window size, in the range 8..15.  window is a caller</span>
<a href="#l31.1083"></a><span id="l31.1083" class="difflineplus">+   supplied buffer of that size.  Except for special applications where it is</span>
<a href="#l31.1084"></a><span id="l31.1084" class="difflineplus">+   assured that deflate was used with small window sizes, windowBits must be 15</span>
<a href="#l31.1085"></a><span id="l31.1085" class="difflineplus">+   and a 32K byte window must be supplied to be able to decompress general</span>
<a href="#l31.1086"></a><span id="l31.1086" class="difflineplus">+   deflate streams.</span>
<a href="#l31.1087"></a><span id="l31.1087" class="difflineplus">+</span>
<a href="#l31.1088"></a><span id="l31.1088" class="difflineplus">+     See inflateBack() for the usage of these routines.</span>
<a href="#l31.1089"></a><span id="l31.1089" class="difflineplus">+</span>
<a href="#l31.1090"></a><span id="l31.1090" class="difflineplus">+     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of</span>
<a href="#l31.1091"></a><span id="l31.1091" class="difflineplus">+   the parameters are invalid, Z_MEM_ERROR if the internal state could not be</span>
<a href="#l31.1092"></a><span id="l31.1092" class="difflineplus">+   allocated, or Z_VERSION_ERROR if the version of the library does not match</span>
<a href="#l31.1093"></a><span id="l31.1093" class="difflineplus">+   the version of the header file.</span>
<a href="#l31.1094"></a><span id="l31.1094" class="difflineplus">+*/</span>
<a href="#l31.1095"></a><span id="l31.1095" class="difflineplus">+</span>
<a href="#l31.1096"></a><span id="l31.1096" class="difflineplus">+typedef unsigned (*in_func) OF((void FAR *,</span>
<a href="#l31.1097"></a><span id="l31.1097" class="difflineplus">+                                z_const unsigned char FAR * FAR *));</span>
<a href="#l31.1098"></a><span id="l31.1098" class="difflineplus">+typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));</span>
<a href="#l31.1099"></a><span id="l31.1099" class="difflineplus">+</span>
<a href="#l31.1100"></a><span id="l31.1100" class="difflineplus">+ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,</span>
<a href="#l31.1101"></a><span id="l31.1101" class="difflineplus">+                                    in_func in, void FAR *in_desc,</span>
<a href="#l31.1102"></a><span id="l31.1102" class="difflineplus">+                                    out_func out, void FAR *out_desc));</span>
<a href="#l31.1103"></a><span id="l31.1103" class="difflineplus">+/*</span>
<a href="#l31.1104"></a><span id="l31.1104" class="difflineplus">+     inflateBack() does a raw inflate with a single call using a call-back</span>
<a href="#l31.1105"></a><span id="l31.1105" class="difflineplus">+   interface for input and output.  This is potentially more efficient than</span>
<a href="#l31.1106"></a><span id="l31.1106" class="difflineplus">+   inflate() for file i/o applications, in that it avoids copying between the</span>
<a href="#l31.1107"></a><span id="l31.1107" class="difflineplus">+   output and the sliding window by simply making the window itself the output</span>
<a href="#l31.1108"></a><span id="l31.1108" class="difflineplus">+   buffer.  inflate() can be faster on modern CPUs when used with large</span>
<a href="#l31.1109"></a><span id="l31.1109" class="difflineplus">+   buffers.  inflateBack() trusts the application to not change the output</span>
<a href="#l31.1110"></a><span id="l31.1110" class="difflineplus">+   buffer passed by the output function, at least until inflateBack() returns.</span>
<a href="#l31.1111"></a><span id="l31.1111" class="difflineplus">+</span>
<a href="#l31.1112"></a><span id="l31.1112" class="difflineplus">+     inflateBackInit() must be called first to allocate the internal state</span>
<a href="#l31.1113"></a><span id="l31.1113" class="difflineplus">+   and to initialize the state with the user-provided window buffer.</span>
<a href="#l31.1114"></a><span id="l31.1114" class="difflineplus">+   inflateBack() may then be used multiple times to inflate a complete, raw</span>
<a href="#l31.1115"></a><span id="l31.1115" class="difflineplus">+   deflate stream with each call.  inflateBackEnd() is then called to free the</span>
<a href="#l31.1116"></a><span id="l31.1116" class="difflineplus">+   allocated state.</span>
<a href="#l31.1117"></a><span id="l31.1117" class="difflineplus">+</span>
<a href="#l31.1118"></a><span id="l31.1118" class="difflineplus">+     A raw deflate stream is one with no zlib or gzip header or trailer.</span>
<a href="#l31.1119"></a><span id="l31.1119" class="difflineplus">+   This routine would normally be used in a utility that reads zip or gzip</span>
<a href="#l31.1120"></a><span id="l31.1120" class="difflineplus">+   files and writes out uncompressed files.  The utility would decode the</span>
<a href="#l31.1121"></a><span id="l31.1121" class="difflineplus">+   header and process the trailer on its own, hence this routine expects only</span>
<a href="#l31.1122"></a><span id="l31.1122" class="difflineplus">+   the raw deflate stream to decompress.  This is different from the default</span>
<a href="#l31.1123"></a><span id="l31.1123" class="difflineplus">+   behavior of inflate(), which expects a zlib header and trailer around the</span>
<a href="#l31.1124"></a><span id="l31.1124" class="difflineplus">+   deflate stream.</span>
<a href="#l31.1125"></a><span id="l31.1125" class="difflineplus">+</span>
<a href="#l31.1126"></a><span id="l31.1126" class="difflineplus">+     inflateBack() uses two subroutines supplied by the caller that are then</span>
<a href="#l31.1127"></a><span id="l31.1127" class="difflineplus">+   called by inflateBack() for input and output.  inflateBack() calls those</span>
<a href="#l31.1128"></a><span id="l31.1128" class="difflineplus">+   routines until it reads a complete deflate stream and writes out all of the</span>
<a href="#l31.1129"></a><span id="l31.1129" class="difflineplus">+   uncompressed data, or until it encounters an error.  The function's</span>
<a href="#l31.1130"></a><span id="l31.1130" class="difflineplus">+   parameters and return types are defined above in the in_func and out_func</span>
<a href="#l31.1131"></a><span id="l31.1131" class="difflineplus">+   typedefs.  inflateBack() will call in(in_desc, &amp;buf) which should return the</span>
<a href="#l31.1132"></a><span id="l31.1132" class="difflineplus">+   number of bytes of provided input, and a pointer to that input in buf.  If</span>
<a href="#l31.1133"></a><span id="l31.1133" class="difflineplus">+   there is no input available, in() must return zero -- buf is ignored in that</span>
<a href="#l31.1134"></a><span id="l31.1134" class="difflineplus">+   case -- and inflateBack() will return a buffer error.  inflateBack() will</span>
<a href="#l31.1135"></a><span id="l31.1135" class="difflineplus">+   call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].</span>
<a href="#l31.1136"></a><span id="l31.1136" class="difflineplus">+   out() should return zero on success, or non-zero on failure.  If out()</span>
<a href="#l31.1137"></a><span id="l31.1137" class="difflineplus">+   returns non-zero, inflateBack() will return with an error.  Neither in() nor</span>
<a href="#l31.1138"></a><span id="l31.1138" class="difflineplus">+   out() are permitted to change the contents of the window provided to</span>
<a href="#l31.1139"></a><span id="l31.1139" class="difflineplus">+   inflateBackInit(), which is also the buffer that out() uses to write from.</span>
<a href="#l31.1140"></a><span id="l31.1140" class="difflineplus">+   The length written by out() will be at most the window size.  Any non-zero</span>
<a href="#l31.1141"></a><span id="l31.1141" class="difflineplus">+   amount of input may be provided by in().</span>
<a href="#l31.1142"></a><span id="l31.1142" class="difflineplus">+</span>
<a href="#l31.1143"></a><span id="l31.1143" class="difflineplus">+     For convenience, inflateBack() can be provided input on the first call by</span>
<a href="#l31.1144"></a><span id="l31.1144" class="difflineplus">+   setting strm-&gt;next_in and strm-&gt;avail_in.  If that input is exhausted, then</span>
<a href="#l31.1145"></a><span id="l31.1145" class="difflineplus">+   in() will be called.  Therefore strm-&gt;next_in must be initialized before</span>
<a href="#l31.1146"></a><span id="l31.1146" class="difflineplus">+   calling inflateBack().  If strm-&gt;next_in is Z_NULL, then in() will be called</span>
<a href="#l31.1147"></a><span id="l31.1147" class="difflineplus">+   immediately for input.  If strm-&gt;next_in is not Z_NULL, then strm-&gt;avail_in</span>
<a href="#l31.1148"></a><span id="l31.1148" class="difflineplus">+   must also be initialized, and then if strm-&gt;avail_in is not zero, input will</span>
<a href="#l31.1149"></a><span id="l31.1149" class="difflineplus">+   initially be taken from strm-&gt;next_in[0 ..  strm-&gt;avail_in - 1].</span>
<a href="#l31.1150"></a><span id="l31.1150" class="difflineplus">+</span>
<a href="#l31.1151"></a><span id="l31.1151" class="difflineplus">+     The in_desc and out_desc parameters of inflateBack() is passed as the</span>
<a href="#l31.1152"></a><span id="l31.1152" class="difflineplus">+   first parameter of in() and out() respectively when they are called.  These</span>
<a href="#l31.1153"></a><span id="l31.1153" class="difflineplus">+   descriptors can be optionally used to pass any information that the caller-</span>
<a href="#l31.1154"></a><span id="l31.1154" class="difflineplus">+   supplied in() and out() functions need to do their job.</span>
<a href="#l31.1155"></a><span id="l31.1155" class="difflineplus">+</span>
<a href="#l31.1156"></a><span id="l31.1156" class="difflineplus">+     On return, inflateBack() will set strm-&gt;next_in and strm-&gt;avail_in to</span>
<a href="#l31.1157"></a><span id="l31.1157" class="difflineplus">+   pass back any unused input that was provided by the last in() call.  The</span>
<a href="#l31.1158"></a><span id="l31.1158" class="difflineplus">+   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR</span>
<a href="#l31.1159"></a><span id="l31.1159" class="difflineplus">+   if in() or out() returned an error, Z_DATA_ERROR if there was a format error</span>
<a href="#l31.1160"></a><span id="l31.1160" class="difflineplus">+   in the deflate stream (in which case strm-&gt;msg is set to indicate the nature</span>
<a href="#l31.1161"></a><span id="l31.1161" class="difflineplus">+   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.</span>
<a href="#l31.1162"></a><span id="l31.1162" class="difflineplus">+   In the case of Z_BUF_ERROR, an input or output error can be distinguished</span>
<a href="#l31.1163"></a><span id="l31.1163" class="difflineplus">+   using strm-&gt;next_in which will be Z_NULL only if in() returned an error.  If</span>
<a href="#l31.1164"></a><span id="l31.1164" class="difflineplus">+   strm-&gt;next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning</span>
<a href="#l31.1165"></a><span id="l31.1165" class="difflineplus">+   non-zero.  (in() will always be called before out(), so strm-&gt;next_in is</span>
<a href="#l31.1166"></a><span id="l31.1166" class="difflineplus">+   assured to be defined if out() returns non-zero.)  Note that inflateBack()</span>
<a href="#l31.1167"></a><span id="l31.1167" class="difflineplus">+   cannot return Z_OK.</span>
<a href="#l31.1168"></a><span id="l31.1168" class="difflineplus">+*/</span>
<a href="#l31.1169"></a><span id="l31.1169" class="difflineplus">+</span>
<a href="#l31.1170"></a><span id="l31.1170" class="difflineplus">+ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));</span>
<a href="#l31.1171"></a><span id="l31.1171" class="difflineplus">+/*</span>
<a href="#l31.1172"></a><span id="l31.1172" class="difflineplus">+     All memory allocated by inflateBackInit() is freed.</span>
<a href="#l31.1173"></a><span id="l31.1173" class="difflineplus">+</span>
<a href="#l31.1174"></a><span id="l31.1174" class="difflineplus">+     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream</span>
<a href="#l31.1175"></a><span id="l31.1175" class="difflineplus">+   state was inconsistent.</span>
<a href="#l31.1176"></a><span id="l31.1176" class="difflineplus">+*/</span>
<a href="#l31.1177"></a><span id="l31.1177" class="difflineplus">+</span>
<a href="#l31.1178"></a><span id="l31.1178" class="difflineplus">+ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));</span>
<a href="#l31.1179"></a><span id="l31.1179" class="difflineplus">+/* Return flags indicating compile-time options.</span>
<a href="#l31.1180"></a><span id="l31.1180" class="difflineplus">+</span>
<a href="#l31.1181"></a><span id="l31.1181" class="difflineplus">+    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:</span>
<a href="#l31.1182"></a><span id="l31.1182" class="difflineplus">+     1.0: size of uInt</span>
<a href="#l31.1183"></a><span id="l31.1183" class="difflineplus">+     3.2: size of uLong</span>
<a href="#l31.1184"></a><span id="l31.1184" class="difflineplus">+     5.4: size of voidpf (pointer)</span>
<a href="#l31.1185"></a><span id="l31.1185" class="difflineplus">+     7.6: size of z_off_t</span>
<a href="#l31.1186"></a><span id="l31.1186" class="difflineplus">+</span>
<a href="#l31.1187"></a><span id="l31.1187" class="difflineplus">+    Compiler, assembler, and debug options:</span>
<a href="#l31.1188"></a><span id="l31.1188" class="difflineplus">+     8: ZLIB_DEBUG</span>
<a href="#l31.1189"></a><span id="l31.1189" class="difflineplus">+     9: ASMV or ASMINF -- use ASM code</span>
<a href="#l31.1190"></a><span id="l31.1190" class="difflineplus">+     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention</span>
<a href="#l31.1191"></a><span id="l31.1191" class="difflineplus">+     11: 0 (reserved)</span>
<a href="#l31.1192"></a><span id="l31.1192" class="difflineplus">+</span>
<a href="#l31.1193"></a><span id="l31.1193" class="difflineplus">+    One-time table building (smaller code, but not thread-safe if true):</span>
<a href="#l31.1194"></a><span id="l31.1194" class="difflineplus">+     12: BUILDFIXED -- build static block decoding tables when needed</span>
<a href="#l31.1195"></a><span id="l31.1195" class="difflineplus">+     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed</span>
<a href="#l31.1196"></a><span id="l31.1196" class="difflineplus">+     14,15: 0 (reserved)</span>
<a href="#l31.1197"></a><span id="l31.1197" class="difflineplus">+</span>
<a href="#l31.1198"></a><span id="l31.1198" class="difflineplus">+    Library content (indicates missing functionality):</span>
<a href="#l31.1199"></a><span id="l31.1199" class="difflineplus">+     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking</span>
<a href="#l31.1200"></a><span id="l31.1200" class="difflineplus">+                          deflate code when not needed)</span>
<a href="#l31.1201"></a><span id="l31.1201" class="difflineplus">+     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect</span>
<a href="#l31.1202"></a><span id="l31.1202" class="difflineplus">+                    and decode gzip streams (to avoid linking crc code)</span>
<a href="#l31.1203"></a><span id="l31.1203" class="difflineplus">+     18-19: 0 (reserved)</span>
<a href="#l31.1204"></a><span id="l31.1204" class="difflineplus">+</span>
<a href="#l31.1205"></a><span id="l31.1205" class="difflineplus">+    Operation variations (changes in library functionality):</span>
<a href="#l31.1206"></a><span id="l31.1206" class="difflineplus">+     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate</span>
<a href="#l31.1207"></a><span id="l31.1207" class="difflineplus">+     21: FASTEST -- deflate algorithm with only one, lowest compression level</span>
<a href="#l31.1208"></a><span id="l31.1208" class="difflineplus">+     22,23: 0 (reserved)</span>
<a href="#l31.1209"></a><span id="l31.1209" class="difflineplus">+</span>
<a href="#l31.1210"></a><span id="l31.1210" class="difflineplus">+    The sprintf variant used by gzprintf (zero is best):</span>
<a href="#l31.1211"></a><span id="l31.1211" class="difflineplus">+     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format</span>
<a href="#l31.1212"></a><span id="l31.1212" class="difflineplus">+     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!</span>
<a href="#l31.1213"></a><span id="l31.1213" class="difflineplus">+     26: 0 = returns value, 1 = void -- 1 means inferred string length returned</span>
<a href="#l31.1214"></a><span id="l31.1214" class="difflineplus">+</span>
<a href="#l31.1215"></a><span id="l31.1215" class="difflineplus">+    Remainder:</span>
<a href="#l31.1216"></a><span id="l31.1216" class="difflineplus">+     27-31: 0 (reserved)</span>
<a href="#l31.1217"></a><span id="l31.1217" class="difflineplus">+ */</span>
<a href="#l31.1218"></a><span id="l31.1218" class="difflineplus">+</span>
<a href="#l31.1219"></a><span id="l31.1219" class="difflineplus">+#ifndef Z_SOLO</span>
<a href="#l31.1220"></a><span id="l31.1220" class="difflineplus">+</span>
<a href="#l31.1221"></a><span id="l31.1221" class="difflineplus">+                        /* utility functions */</span>
<a href="#l31.1222"></a><span id="l31.1222" class="difflineplus">+</span>
<a href="#l31.1223"></a><span id="l31.1223" class="difflineplus">+/*</span>
<a href="#l31.1224"></a><span id="l31.1224" class="difflineplus">+     The following utility functions are implemented on top of the basic</span>
<a href="#l31.1225"></a><span id="l31.1225" class="difflineplus">+   stream-oriented functions.  To simplify the interface, some default options</span>
<a href="#l31.1226"></a><span id="l31.1226" class="difflineplus">+   are assumed (compression level and memory usage, standard memory allocation</span>
<a href="#l31.1227"></a><span id="l31.1227" class="difflineplus">+   functions).  The source code of these utility functions can be modified if</span>
<a href="#l31.1228"></a><span id="l31.1228" class="difflineplus">+   you need special options.</span>
<a href="#l31.1229"></a><span id="l31.1229" class="difflineplus">+*/</span>
<a href="#l31.1230"></a><span id="l31.1230" class="difflineplus">+</span>
<a href="#l31.1231"></a><span id="l31.1231" class="difflineplus">+ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,</span>
<a href="#l31.1232"></a><span id="l31.1232" class="difflineplus">+                                 const Bytef *source, uLong sourceLen));</span>
<a href="#l31.1233"></a><span id="l31.1233" class="difflineplus">+/*</span>
<a href="#l31.1234"></a><span id="l31.1234" class="difflineplus">+     Compresses the source buffer into the destination buffer.  sourceLen is</span>
<a href="#l31.1235"></a><span id="l31.1235" class="difflineplus">+   the byte length of the source buffer.  Upon entry, destLen is the total size</span>
<a href="#l31.1236"></a><span id="l31.1236" class="difflineplus">+   of the destination buffer, which must be at least the value returned by</span>
<a href="#l31.1237"></a><span id="l31.1237" class="difflineplus">+   compressBound(sourceLen).  Upon exit, destLen is the actual size of the</span>
<a href="#l31.1238"></a><span id="l31.1238" class="difflineplus">+   compressed data.  compress() is equivalent to compress2() with a level</span>
<a href="#l31.1239"></a><span id="l31.1239" class="difflineplus">+   parameter of Z_DEFAULT_COMPRESSION.</span>
<a href="#l31.1240"></a><span id="l31.1240" class="difflineplus">+</span>
<a href="#l31.1241"></a><span id="l31.1241" class="difflineplus">+     compress returns Z_OK if success, Z_MEM_ERROR if there was not</span>
<a href="#l31.1242"></a><span id="l31.1242" class="difflineplus">+   enough memory, Z_BUF_ERROR if there was not enough room in the output</span>
<a href="#l31.1243"></a><span id="l31.1243" class="difflineplus">+   buffer.</span>
<a href="#l31.1244"></a><span id="l31.1244" class="difflineplus">+*/</span>
<a href="#l31.1245"></a><span id="l31.1245" class="difflineplus">+</span>
<a href="#l31.1246"></a><span id="l31.1246" class="difflineplus">+ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,</span>
<a href="#l31.1247"></a><span id="l31.1247" class="difflineplus">+                                  const Bytef *source, uLong sourceLen,</span>
<a href="#l31.1248"></a><span id="l31.1248" class="difflineplus">+                                  int level));</span>
<a href="#l31.1249"></a><span id="l31.1249" class="difflineplus">+/*</span>
<a href="#l31.1250"></a><span id="l31.1250" class="difflineplus">+     Compresses the source buffer into the destination buffer.  The level</span>
<a href="#l31.1251"></a><span id="l31.1251" class="difflineplus">+   parameter has the same meaning as in deflateInit.  sourceLen is the byte</span>
<a href="#l31.1252"></a><span id="l31.1252" class="difflineplus">+   length of the source buffer.  Upon entry, destLen is the total size of the</span>
<a href="#l31.1253"></a><span id="l31.1253" class="difflineplus">+   destination buffer, which must be at least the value returned by</span>
<a href="#l31.1254"></a><span id="l31.1254" class="difflineplus">+   compressBound(sourceLen).  Upon exit, destLen is the actual size of the</span>
<a href="#l31.1255"></a><span id="l31.1255" class="difflineplus">+   compressed data.</span>
<a href="#l31.1256"></a><span id="l31.1256" class="difflineplus">+</span>
<a href="#l31.1257"></a><span id="l31.1257" class="difflineplus">+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
<a href="#l31.1258"></a><span id="l31.1258" class="difflineplus">+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,</span>
<a href="#l31.1259"></a><span id="l31.1259" class="difflineplus">+   Z_STREAM_ERROR if the level parameter is invalid.</span>
<a href="#l31.1260"></a><span id="l31.1260" class="difflineplus">+*/</span>
<a href="#l31.1261"></a><span id="l31.1261" class="difflineplus">+</span>
<a href="#l31.1262"></a><span id="l31.1262" class="difflineplus">+ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));</span>
<a href="#l31.1263"></a><span id="l31.1263" class="difflineplus">+/*</span>
<a href="#l31.1264"></a><span id="l31.1264" class="difflineplus">+     compressBound() returns an upper bound on the compressed size after</span>
<a href="#l31.1265"></a><span id="l31.1265" class="difflineplus">+   compress() or compress2() on sourceLen bytes.  It would be used before a</span>
<a href="#l31.1266"></a><span id="l31.1266" class="difflineplus">+   compress() or compress2() call to allocate the destination buffer.</span>
<a href="#l31.1267"></a><span id="l31.1267" class="difflineplus">+*/</span>
<a href="#l31.1268"></a><span id="l31.1268" class="difflineplus">+</span>
<a href="#l31.1269"></a><span id="l31.1269" class="difflineplus">+ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,</span>
<a href="#l31.1270"></a><span id="l31.1270" class="difflineplus">+                                   const Bytef *source, uLong sourceLen));</span>
<a href="#l31.1271"></a><span id="l31.1271" class="difflineplus">+/*</span>
<a href="#l31.1272"></a><span id="l31.1272" class="difflineplus">+     Decompresses the source buffer into the destination buffer.  sourceLen is</span>
<a href="#l31.1273"></a><span id="l31.1273" class="difflineplus">+   the byte length of the source buffer.  Upon entry, destLen is the total size</span>
<a href="#l31.1274"></a><span id="l31.1274" class="difflineplus">+   of the destination buffer, which must be large enough to hold the entire</span>
<a href="#l31.1275"></a><span id="l31.1275" class="difflineplus">+   uncompressed data.  (The size of the uncompressed data must have been saved</span>
<a href="#l31.1276"></a><span id="l31.1276" class="difflineplus">+   previously by the compressor and transmitted to the decompressor by some</span>
<a href="#l31.1277"></a><span id="l31.1277" class="difflineplus">+   mechanism outside the scope of this compression library.) Upon exit, destLen</span>
<a href="#l31.1278"></a><span id="l31.1278" class="difflineplus">+   is the actual size of the uncompressed data.</span>
<a href="#l31.1279"></a><span id="l31.1279" class="difflineplus">+</span>
<a href="#l31.1280"></a><span id="l31.1280" class="difflineplus">+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not</span>
<a href="#l31.1281"></a><span id="l31.1281" class="difflineplus">+   enough memory, Z_BUF_ERROR if there was not enough room in the output</span>
<a href="#l31.1282"></a><span id="l31.1282" class="difflineplus">+   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In</span>
<a href="#l31.1283"></a><span id="l31.1283" class="difflineplus">+   the case where there is not enough room, uncompress() will fill the output</span>
<a href="#l31.1284"></a><span id="l31.1284" class="difflineplus">+   buffer with the uncompressed data up to that point.</span>
<a href="#l31.1285"></a><span id="l31.1285" class="difflineplus">+*/</span>
<a href="#l31.1286"></a><span id="l31.1286" class="difflineplus">+</span>
<a href="#l31.1287"></a><span id="l31.1287" class="difflineplus">+ZEXTERN int ZEXPORT uncompress2 OF((Bytef *dest,   uLongf *destLen,</span>
<a href="#l31.1288"></a><span id="l31.1288" class="difflineplus">+                                    const Bytef *source, uLong *sourceLen));</span>
<a href="#l31.1289"></a><span id="l31.1289" class="difflineplus">+/*</span>
<a href="#l31.1290"></a><span id="l31.1290" class="difflineplus">+     Same as uncompress, except that sourceLen is a pointer, where the</span>
<a href="#l31.1291"></a><span id="l31.1291" class="difflineplus">+   length of the source is *sourceLen.  On return, *sourceLen is the number of</span>
<a href="#l31.1292"></a><span id="l31.1292" class="difflineplus">+   source bytes consumed.</span>
<a href="#l31.1293"></a><span id="l31.1293" class="difflineplus">+*/</span>
<a href="#l31.1294"></a><span id="l31.1294" class="difflineplus">+</span>
<a href="#l31.1295"></a><span id="l31.1295" class="difflineplus">+                        /* gzip file access functions */</span>
<a href="#l31.1296"></a><span id="l31.1296" class="difflineplus">+</span>
<a href="#l31.1297"></a><span id="l31.1297" class="difflineplus">+/*</span>
<a href="#l31.1298"></a><span id="l31.1298" class="difflineplus">+     This library supports reading and writing files in gzip (.gz) format with</span>
<a href="#l31.1299"></a><span id="l31.1299" class="difflineplus">+   an interface similar to that of stdio, using the functions that start with</span>
<a href="#l31.1300"></a><span id="l31.1300" class="difflineplus">+   &quot;gz&quot;.  The gzip format is different from the zlib format.  gzip is a gzip</span>
<a href="#l31.1301"></a><span id="l31.1301" class="difflineplus">+   wrapper, documented in RFC 1952, wrapped around a deflate stream.</span>
<a href="#l31.1302"></a><span id="l31.1302" class="difflineplus">+*/</span>
<a href="#l31.1303"></a><span id="l31.1303" class="difflineplus">+</span>
<a href="#l31.1304"></a><span id="l31.1304" class="difflineplus">+typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */</span>
<a href="#l31.1305"></a><span id="l31.1305" class="difflineplus">+</span>
<a href="#l31.1306"></a><span id="l31.1306" class="difflineplus">+/*</span>
<a href="#l31.1307"></a><span id="l31.1307" class="difflineplus">+ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));</span>
<a href="#l31.1308"></a><span id="l31.1308" class="difflineplus">+</span>
<a href="#l31.1309"></a><span id="l31.1309" class="difflineplus">+     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as</span>
<a href="#l31.1310"></a><span id="l31.1310" class="difflineplus">+   in fopen (&quot;rb&quot; or &quot;wb&quot;) but can also include a compression level (&quot;wb9&quot;) or</span>
<a href="#l31.1311"></a><span id="l31.1311" class="difflineplus">+   a strategy: 'f' for filtered data as in &quot;wb6f&quot;, 'h' for Huffman-only</span>
<a href="#l31.1312"></a><span id="l31.1312" class="difflineplus">+   compression as in &quot;wb1h&quot;, 'R' for run-length encoding as in &quot;wb1R&quot;, or 'F'</span>
<a href="#l31.1313"></a><span id="l31.1313" class="difflineplus">+   for fixed code compression as in &quot;wb9F&quot;.  (See the description of</span>
<a href="#l31.1314"></a><span id="l31.1314" class="difflineplus">+   deflateInit2 for more information about the strategy parameter.)  'T' will</span>
<a href="#l31.1315"></a><span id="l31.1315" class="difflineplus">+   request transparent writing or appending with no compression and not using</span>
<a href="#l31.1316"></a><span id="l31.1316" class="difflineplus">+   the gzip format.</span>
<a href="#l31.1317"></a><span id="l31.1317" class="difflineplus">+</span>
<a href="#l31.1318"></a><span id="l31.1318" class="difflineplus">+     &quot;a&quot; can be used instead of &quot;w&quot; to request that the gzip stream that will</span>
<a href="#l31.1319"></a><span id="l31.1319" class="difflineplus">+   be written be appended to the file.  &quot;+&quot; will result in an error, since</span>
<a href="#l31.1320"></a><span id="l31.1320" class="difflineplus">+   reading and writing to the same gzip file is not supported.  The addition of</span>
<a href="#l31.1321"></a><span id="l31.1321" class="difflineplus">+   &quot;x&quot; when writing will create the file exclusively, which fails if the file</span>
<a href="#l31.1322"></a><span id="l31.1322" class="difflineplus">+   already exists.  On systems that support it, the addition of &quot;e&quot; when</span>
<a href="#l31.1323"></a><span id="l31.1323" class="difflineplus">+   reading or writing will set the flag to close the file on an execve() call.</span>
<a href="#l31.1324"></a><span id="l31.1324" class="difflineplus">+</span>
<a href="#l31.1325"></a><span id="l31.1325" class="difflineplus">+     These functions, as well as gzip, will read and decode a sequence of gzip</span>
<a href="#l31.1326"></a><span id="l31.1326" class="difflineplus">+   streams in a file.  The append function of gzopen() can be used to create</span>
<a href="#l31.1327"></a><span id="l31.1327" class="difflineplus">+   such a file.  (Also see gzflush() for another way to do this.)  When</span>
<a href="#l31.1328"></a><span id="l31.1328" class="difflineplus">+   appending, gzopen does not test whether the file begins with a gzip stream,</span>
<a href="#l31.1329"></a><span id="l31.1329" class="difflineplus">+   nor does it look for the end of the gzip streams to begin appending.  gzopen</span>
<a href="#l31.1330"></a><span id="l31.1330" class="difflineplus">+   will simply append a gzip stream to the existing file.</span>
<a href="#l31.1331"></a><span id="l31.1331" class="difflineplus">+</span>
<a href="#l31.1332"></a><span id="l31.1332" class="difflineplus">+     gzopen can be used to read a file which is not in gzip format; in this</span>
<a href="#l31.1333"></a><span id="l31.1333" class="difflineplus">+   case gzread will directly read from the file without decompression.  When</span>
<a href="#l31.1334"></a><span id="l31.1334" class="difflineplus">+   reading, this will be detected automatically by looking for the magic two-</span>
<a href="#l31.1335"></a><span id="l31.1335" class="difflineplus">+   byte gzip header.</span>
<a href="#l31.1336"></a><span id="l31.1336" class="difflineplus">+</span>
<a href="#l31.1337"></a><span id="l31.1337" class="difflineplus">+     gzopen returns NULL if the file could not be opened, if there was</span>
<a href="#l31.1338"></a><span id="l31.1338" class="difflineplus">+   insufficient memory to allocate the gzFile state, or if an invalid mode was</span>
<a href="#l31.1339"></a><span id="l31.1339" class="difflineplus">+   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).</span>
<a href="#l31.1340"></a><span id="l31.1340" class="difflineplus">+   errno can be checked to determine if the reason gzopen failed was that the</span>
<a href="#l31.1341"></a><span id="l31.1341" class="difflineplus">+   file could not be opened.</span>
<a href="#l31.1342"></a><span id="l31.1342" class="difflineplus">+*/</span>
<a href="#l31.1343"></a><span id="l31.1343" class="difflineplus">+</span>
<a href="#l31.1344"></a><span id="l31.1344" class="difflineplus">+ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));</span>
<a href="#l31.1345"></a><span id="l31.1345" class="difflineplus">+/*</span>
<a href="#l31.1346"></a><span id="l31.1346" class="difflineplus">+     gzdopen associates a gzFile with the file descriptor fd.  File descriptors</span>
<a href="#l31.1347"></a><span id="l31.1347" class="difflineplus">+   are obtained from calls like open, dup, creat, pipe or fileno (if the file</span>
<a href="#l31.1348"></a><span id="l31.1348" class="difflineplus">+   has been previously opened with fopen).  The mode parameter is as in gzopen.</span>
<a href="#l31.1349"></a><span id="l31.1349" class="difflineplus">+</span>
<a href="#l31.1350"></a><span id="l31.1350" class="difflineplus">+     The next call of gzclose on the returned gzFile will also close the file</span>
<a href="#l31.1351"></a><span id="l31.1351" class="difflineplus">+   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor</span>
<a href="#l31.1352"></a><span id="l31.1352" class="difflineplus">+   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,</span>
<a href="#l31.1353"></a><span id="l31.1353" class="difflineplus">+   mode);.  The duplicated descriptor should be saved to avoid a leak, since</span>
<a href="#l31.1354"></a><span id="l31.1354" class="difflineplus">+   gzdopen does not close fd if it fails.  If you are using fileno() to get the</span>
<a href="#l31.1355"></a><span id="l31.1355" class="difflineplus">+   file descriptor from a FILE *, then you will have to use dup() to avoid</span>
<a href="#l31.1356"></a><span id="l31.1356" class="difflineplus">+   double-close()ing the file descriptor.  Both gzclose() and fclose() will</span>
<a href="#l31.1357"></a><span id="l31.1357" class="difflineplus">+   close the associated file descriptor, so they need to have different file</span>
<a href="#l31.1358"></a><span id="l31.1358" class="difflineplus">+   descriptors.</span>
<a href="#l31.1359"></a><span id="l31.1359" class="difflineplus">+</span>
<a href="#l31.1360"></a><span id="l31.1360" class="difflineplus">+     gzdopen returns NULL if there was insufficient memory to allocate the</span>
<a href="#l31.1361"></a><span id="l31.1361" class="difflineplus">+   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not</span>
<a href="#l31.1362"></a><span id="l31.1362" class="difflineplus">+   provided, or '+' was provided), or if fd is -1.  The file descriptor is not</span>
<a href="#l31.1363"></a><span id="l31.1363" class="difflineplus">+   used until the next gz* read, write, seek, or close operation, so gzdopen</span>
<a href="#l31.1364"></a><span id="l31.1364" class="difflineplus">+   will not detect if fd is invalid (unless fd is -1).</span>
<a href="#l31.1365"></a><span id="l31.1365" class="difflineplus">+*/</span>
<a href="#l31.1366"></a><span id="l31.1366" class="difflineplus">+</span>
<a href="#l31.1367"></a><span id="l31.1367" class="difflineplus">+ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));</span>
<a href="#l31.1368"></a><span id="l31.1368" class="difflineplus">+/*</span>
<a href="#l31.1369"></a><span id="l31.1369" class="difflineplus">+     Set the internal buffer size used by this library's functions.  The</span>
<a href="#l31.1370"></a><span id="l31.1370" class="difflineplus">+   default buffer size is 8192 bytes.  This function must be called after</span>
<a href="#l31.1371"></a><span id="l31.1371" class="difflineplus">+   gzopen() or gzdopen(), and before any other calls that read or write the</span>
<a href="#l31.1372"></a><span id="l31.1372" class="difflineplus">+   file.  The buffer memory allocation is always deferred to the first read or</span>
<a href="#l31.1373"></a><span id="l31.1373" class="difflineplus">+   write.  Three times that size in buffer space is allocated.  A larger buffer</span>
<a href="#l31.1374"></a><span id="l31.1374" class="difflineplus">+   size of, for example, 64K or 128K bytes will noticeably increase the speed</span>
<a href="#l31.1375"></a><span id="l31.1375" class="difflineplus">+   of decompression (reading).</span>
<a href="#l31.1376"></a><span id="l31.1376" class="difflineplus">+</span>
<a href="#l31.1377"></a><span id="l31.1377" class="difflineplus">+     The new buffer size also affects the maximum length for gzprintf().</span>
<a href="#l31.1378"></a><span id="l31.1378" class="difflineplus">+</span>
<a href="#l31.1379"></a><span id="l31.1379" class="difflineplus">+     gzbuffer() returns 0 on success, or -1 on failure, such as being called</span>
<a href="#l31.1380"></a><span id="l31.1380" class="difflineplus">+   too late.</span>
<a href="#l31.1381"></a><span id="l31.1381" class="difflineplus">+*/</span>
<a href="#l31.1382"></a><span id="l31.1382" class="difflineplus">+</span>
<a href="#l31.1383"></a><span id="l31.1383" class="difflineplus">+ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));</span>
<a href="#l31.1384"></a><span id="l31.1384" class="difflineplus">+/*</span>
<a href="#l31.1385"></a><span id="l31.1385" class="difflineplus">+     Dynamically update the compression level or strategy.  See the description</span>
<a href="#l31.1386"></a><span id="l31.1386" class="difflineplus">+   of deflateInit2 for the meaning of these parameters.  Previously provided</span>
<a href="#l31.1387"></a><span id="l31.1387" class="difflineplus">+   data is flushed before the parameter change.</span>
<a href="#l31.1388"></a><span id="l31.1388" class="difflineplus">+</span>
<a href="#l31.1389"></a><span id="l31.1389" class="difflineplus">+     gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not</span>
<a href="#l31.1390"></a><span id="l31.1390" class="difflineplus">+   opened for writing, Z_ERRNO if there is an error writing the flushed data,</span>
<a href="#l31.1391"></a><span id="l31.1391" class="difflineplus">+   or Z_MEM_ERROR if there is a memory allocation error.</span>
<a href="#l31.1392"></a><span id="l31.1392" class="difflineplus">+*/</span>
<a href="#l31.1393"></a><span id="l31.1393" class="difflineplus">+</span>
<a href="#l31.1394"></a><span id="l31.1394" class="difflineplus">+ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));</span>
<a href="#l31.1395"></a><span id="l31.1395" class="difflineplus">+/*</span>
<a href="#l31.1396"></a><span id="l31.1396" class="difflineplus">+     Reads the given number of uncompressed bytes from the compressed file.  If</span>
<a href="#l31.1397"></a><span id="l31.1397" class="difflineplus">+   the input file is not in gzip format, gzread copies the given number of</span>
<a href="#l31.1398"></a><span id="l31.1398" class="difflineplus">+   bytes into the buffer directly from the file.</span>
<a href="#l31.1399"></a><span id="l31.1399" class="difflineplus">+</span>
<a href="#l31.1400"></a><span id="l31.1400" class="difflineplus">+     After reaching the end of a gzip stream in the input, gzread will continue</span>
<a href="#l31.1401"></a><span id="l31.1401" class="difflineplus">+   to read, looking for another gzip stream.  Any number of gzip streams may be</span>
<a href="#l31.1402"></a><span id="l31.1402" class="difflineplus">+   concatenated in the input file, and will all be decompressed by gzread().</span>
<a href="#l31.1403"></a><span id="l31.1403" class="difflineplus">+   If something other than a gzip stream is encountered after a gzip stream,</span>
<a href="#l31.1404"></a><span id="l31.1404" class="difflineplus">+   that remaining trailing garbage is ignored (and no error is returned).</span>
<a href="#l31.1405"></a><span id="l31.1405" class="difflineplus">+</span>
<a href="#l31.1406"></a><span id="l31.1406" class="difflineplus">+     gzread can be used to read a gzip file that is being concurrently written.</span>
<a href="#l31.1407"></a><span id="l31.1407" class="difflineplus">+   Upon reaching the end of the input, gzread will return with the available</span>
<a href="#l31.1408"></a><span id="l31.1408" class="difflineplus">+   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then</span>
<a href="#l31.1409"></a><span id="l31.1409" class="difflineplus">+   gzclearerr can be used to clear the end of file indicator in order to permit</span>
<a href="#l31.1410"></a><span id="l31.1410" class="difflineplus">+   gzread to be tried again.  Z_OK indicates that a gzip stream was completed</span>
<a href="#l31.1411"></a><span id="l31.1411" class="difflineplus">+   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the</span>
<a href="#l31.1412"></a><span id="l31.1412" class="difflineplus">+   middle of a gzip stream.  Note that gzread does not return -1 in the event</span>
<a href="#l31.1413"></a><span id="l31.1413" class="difflineplus">+   of an incomplete gzip stream.  This error is deferred until gzclose(), which</span>
<a href="#l31.1414"></a><span id="l31.1414" class="difflineplus">+   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip</span>
<a href="#l31.1415"></a><span id="l31.1415" class="difflineplus">+   stream.  Alternatively, gzerror can be used before gzclose to detect this</span>
<a href="#l31.1416"></a><span id="l31.1416" class="difflineplus">+   case.</span>
<a href="#l31.1417"></a><span id="l31.1417" class="difflineplus">+</span>
<a href="#l31.1418"></a><span id="l31.1418" class="difflineplus">+     gzread returns the number of uncompressed bytes actually read, less than</span>
<a href="#l31.1419"></a><span id="l31.1419" class="difflineplus">+   len for end of file, or -1 for error.  If len is too large to fit in an int,</span>
<a href="#l31.1420"></a><span id="l31.1420" class="difflineplus">+   then nothing is read, -1 is returned, and the error state is set to</span>
<a href="#l31.1421"></a><span id="l31.1421" class="difflineplus">+   Z_STREAM_ERROR.</span>
<a href="#l31.1422"></a><span id="l31.1422" class="difflineplus">+*/</span>
<a href="#l31.1423"></a><span id="l31.1423" class="difflineplus">+</span>
<a href="#l31.1424"></a><span id="l31.1424" class="difflineplus">+ZEXTERN z_size_t ZEXPORT gzfread OF((voidp buf, z_size_t size, z_size_t nitems,</span>
<a href="#l31.1425"></a><span id="l31.1425" class="difflineplus">+                                     gzFile file));</span>
<a href="#l31.1426"></a><span id="l31.1426" class="difflineplus">+/*</span>
<a href="#l31.1427"></a><span id="l31.1427" class="difflineplus">+     Read up to nitems items of size size from file to buf, otherwise operating</span>
<a href="#l31.1428"></a><span id="l31.1428" class="difflineplus">+   as gzread() does.  This duplicates the interface of stdio's fread(), with</span>
<a href="#l31.1429"></a><span id="l31.1429" class="difflineplus">+   size_t request and return types.  If the library defines size_t, then</span>
<a href="#l31.1430"></a><span id="l31.1430" class="difflineplus">+   z_size_t is identical to size_t.  If not, then z_size_t is an unsigned</span>
<a href="#l31.1431"></a><span id="l31.1431" class="difflineplus">+   integer type that can contain a pointer.</span>
<a href="#l31.1432"></a><span id="l31.1432" class="difflineplus">+</span>
<a href="#l31.1433"></a><span id="l31.1433" class="difflineplus">+     gzfread() returns the number of full items read of size size, or zero if</span>
<a href="#l31.1434"></a><span id="l31.1434" class="difflineplus">+   the end of the file was reached and a full item could not be read, or if</span>
<a href="#l31.1435"></a><span id="l31.1435" class="difflineplus">+   there was an error.  gzerror() must be consulted if zero is returned in</span>
<a href="#l31.1436"></a><span id="l31.1436" class="difflineplus">+   order to determine if there was an error.  If the multiplication of size and</span>
<a href="#l31.1437"></a><span id="l31.1437" class="difflineplus">+   nitems overflows, i.e. the product does not fit in a z_size_t, then nothing</span>
<a href="#l31.1438"></a><span id="l31.1438" class="difflineplus">+   is read, zero is returned, and the error state is set to Z_STREAM_ERROR.</span>
<a href="#l31.1439"></a><span id="l31.1439" class="difflineplus">+</span>
<a href="#l31.1440"></a><span id="l31.1440" class="difflineplus">+     In the event that the end of file is reached and only a partial item is</span>
<a href="#l31.1441"></a><span id="l31.1441" class="difflineplus">+   available at the end, i.e. the remaining uncompressed data length is not a</span>
<a href="#l31.1442"></a><span id="l31.1442" class="difflineplus">+   multiple of size, then the final partial item is nevetheless read into buf</span>
<a href="#l31.1443"></a><span id="l31.1443" class="difflineplus">+   and the end-of-file flag is set.  The length of the partial item read is not</span>
<a href="#l31.1444"></a><span id="l31.1444" class="difflineplus">+   provided, but could be inferred from the result of gztell().  This behavior</span>
<a href="#l31.1445"></a><span id="l31.1445" class="difflineplus">+   is the same as the behavior of fread() implementations in common libraries,</span>
<a href="#l31.1446"></a><span id="l31.1446" class="difflineplus">+   but it prevents the direct use of gzfread() to read a concurrently written</span>
<a href="#l31.1447"></a><span id="l31.1447" class="difflineplus">+   file, reseting and retrying on end-of-file, when size is not 1.</span>
<a href="#l31.1448"></a><span id="l31.1448" class="difflineplus">+*/</span>
<a href="#l31.1449"></a><span id="l31.1449" class="difflineplus">+</span>
<a href="#l31.1450"></a><span id="l31.1450" class="difflineplus">+ZEXTERN int ZEXPORT gzwrite OF((gzFile file,</span>
<a href="#l31.1451"></a><span id="l31.1451" class="difflineplus">+                                voidpc buf, unsigned len));</span>
<a href="#l31.1452"></a><span id="l31.1452" class="difflineplus">+/*</span>
<a href="#l31.1453"></a><span id="l31.1453" class="difflineplus">+     Writes the given number of uncompressed bytes into the compressed file.</span>
<a href="#l31.1454"></a><span id="l31.1454" class="difflineplus">+   gzwrite returns the number of uncompressed bytes written or 0 in case of</span>
<a href="#l31.1455"></a><span id="l31.1455" class="difflineplus">+   error.</span>
<a href="#l31.1456"></a><span id="l31.1456" class="difflineplus">+*/</span>
<a href="#l31.1457"></a><span id="l31.1457" class="difflineplus">+</span>
<a href="#l31.1458"></a><span id="l31.1458" class="difflineplus">+ZEXTERN z_size_t ZEXPORT gzfwrite OF((voidpc buf, z_size_t size,</span>
<a href="#l31.1459"></a><span id="l31.1459" class="difflineplus">+                                      z_size_t nitems, gzFile file));</span>
<a href="#l31.1460"></a><span id="l31.1460" class="difflineplus">+/*</span>
<a href="#l31.1461"></a><span id="l31.1461" class="difflineplus">+     gzfwrite() writes nitems items of size size from buf to file, duplicating</span>
<a href="#l31.1462"></a><span id="l31.1462" class="difflineplus">+   the interface of stdio's fwrite(), with size_t request and return types.  If</span>
<a href="#l31.1463"></a><span id="l31.1463" class="difflineplus">+   the library defines size_t, then z_size_t is identical to size_t.  If not,</span>
<a href="#l31.1464"></a><span id="l31.1464" class="difflineplus">+   then z_size_t is an unsigned integer type that can contain a pointer.</span>
<a href="#l31.1465"></a><span id="l31.1465" class="difflineplus">+</span>
<a href="#l31.1466"></a><span id="l31.1466" class="difflineplus">+     gzfwrite() returns the number of full items written of size size, or zero</span>
<a href="#l31.1467"></a><span id="l31.1467" class="difflineplus">+   if there was an error.  If the multiplication of size and nitems overflows,</span>
<a href="#l31.1468"></a><span id="l31.1468" class="difflineplus">+   i.e. the product does not fit in a z_size_t, then nothing is written, zero</span>
<a href="#l31.1469"></a><span id="l31.1469" class="difflineplus">+   is returned, and the error state is set to Z_STREAM_ERROR.</span>
<a href="#l31.1470"></a><span id="l31.1470" class="difflineplus">+*/</span>
<a href="#l31.1471"></a><span id="l31.1471" class="difflineplus">+</span>
<a href="#l31.1472"></a><span id="l31.1472" class="difflineplus">+ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));</span>
<a href="#l31.1473"></a><span id="l31.1473" class="difflineplus">+/*</span>
<a href="#l31.1474"></a><span id="l31.1474" class="difflineplus">+     Converts, formats, and writes the arguments to the compressed file under</span>
<a href="#l31.1475"></a><span id="l31.1475" class="difflineplus">+   control of the format string, as in fprintf.  gzprintf returns the number of</span>
<a href="#l31.1476"></a><span id="l31.1476" class="difflineplus">+   uncompressed bytes actually written, or a negative zlib error code in case</span>
<a href="#l31.1477"></a><span id="l31.1477" class="difflineplus">+   of error.  The number of uncompressed bytes written is limited to 8191, or</span>
<a href="#l31.1478"></a><span id="l31.1478" class="difflineplus">+   one less than the buffer size given to gzbuffer().  The caller should assure</span>
<a href="#l31.1479"></a><span id="l31.1479" class="difflineplus">+   that this limit is not exceeded.  If it is exceeded, then gzprintf() will</span>
<a href="#l31.1480"></a><span id="l31.1480" class="difflineplus">+   return an error (0) with nothing written.  In this case, there may also be a</span>
<a href="#l31.1481"></a><span id="l31.1481" class="difflineplus">+   buffer overflow with unpredictable consequences, which is possible only if</span>
<a href="#l31.1482"></a><span id="l31.1482" class="difflineplus">+   zlib was compiled with the insecure functions sprintf() or vsprintf()</span>
<a href="#l31.1483"></a><span id="l31.1483" class="difflineplus">+   because the secure snprintf() or vsnprintf() functions were not available.</span>
<a href="#l31.1484"></a><span id="l31.1484" class="difflineplus">+   This can be determined using zlibCompileFlags().</span>
<a href="#l31.1485"></a><span id="l31.1485" class="difflineplus">+*/</span>
<a href="#l31.1486"></a><span id="l31.1486" class="difflineplus">+</span>
<a href="#l31.1487"></a><span id="l31.1487" class="difflineplus">+ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));</span>
<a href="#l31.1488"></a><span id="l31.1488" class="difflineplus">+/*</span>
<a href="#l31.1489"></a><span id="l31.1489" class="difflineplus">+     Writes the given null-terminated string to the compressed file, excluding</span>
<a href="#l31.1490"></a><span id="l31.1490" class="difflineplus">+   the terminating null character.</span>
<a href="#l31.1491"></a><span id="l31.1491" class="difflineplus">+</span>
<a href="#l31.1492"></a><span id="l31.1492" class="difflineplus">+     gzputs returns the number of characters written, or -1 in case of error.</span>
<a href="#l31.1493"></a><span id="l31.1493" class="difflineplus">+*/</span>
<a href="#l31.1494"></a><span id="l31.1494" class="difflineplus">+</span>
<a href="#l31.1495"></a><span id="l31.1495" class="difflineplus">+ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));</span>
<a href="#l31.1496"></a><span id="l31.1496" class="difflineplus">+/*</span>
<a href="#l31.1497"></a><span id="l31.1497" class="difflineplus">+     Reads bytes from the compressed file until len-1 characters are read, or a</span>
<a href="#l31.1498"></a><span id="l31.1498" class="difflineplus">+   newline character is read and transferred to buf, or an end-of-file</span>
<a href="#l31.1499"></a><span id="l31.1499" class="difflineplus">+   condition is encountered.  If any characters are read or if len == 1, the</span>
<a href="#l31.1500"></a><span id="l31.1500" class="difflineplus">+   string is terminated with a null character.  If no characters are read due</span>
<a href="#l31.1501"></a><span id="l31.1501" class="difflineplus">+   to an end-of-file or len &lt; 1, then the buffer is left untouched.</span>
<a href="#l31.1502"></a><span id="l31.1502" class="difflineplus">+</span>
<a href="#l31.1503"></a><span id="l31.1503" class="difflineplus">+     gzgets returns buf which is a null-terminated string, or it returns NULL</span>
<a href="#l31.1504"></a><span id="l31.1504" class="difflineplus">+   for end-of-file or in case of error.  If there was an error, the contents at</span>
<a href="#l31.1505"></a><span id="l31.1505" class="difflineplus">+   buf are indeterminate.</span>
<a href="#l31.1506"></a><span id="l31.1506" class="difflineplus">+*/</span>
<a href="#l31.1507"></a><span id="l31.1507" class="difflineplus">+</span>
<a href="#l31.1508"></a><span id="l31.1508" class="difflineplus">+ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));</span>
<a href="#l31.1509"></a><span id="l31.1509" class="difflineplus">+/*</span>
<a href="#l31.1510"></a><span id="l31.1510" class="difflineplus">+     Writes c, converted to an unsigned char, into the compressed file.  gzputc</span>
<a href="#l31.1511"></a><span id="l31.1511" class="difflineplus">+   returns the value that was written, or -1 in case of error.</span>
<a href="#l31.1512"></a><span id="l31.1512" class="difflineplus">+*/</span>
<a href="#l31.1513"></a><span id="l31.1513" class="difflineplus">+</span>
<a href="#l31.1514"></a><span id="l31.1514" class="difflineplus">+ZEXTERN int ZEXPORT gzgetc OF((gzFile file));</span>
<a href="#l31.1515"></a><span id="l31.1515" class="difflineplus">+/*</span>
<a href="#l31.1516"></a><span id="l31.1516" class="difflineplus">+     Reads one byte from the compressed file.  gzgetc returns this byte or -1</span>
<a href="#l31.1517"></a><span id="l31.1517" class="difflineplus">+   in case of end of file or error.  This is implemented as a macro for speed.</span>
<a href="#l31.1518"></a><span id="l31.1518" class="difflineplus">+   As such, it does not do all of the checking the other functions do.  I.e.</span>
<a href="#l31.1519"></a><span id="l31.1519" class="difflineplus">+   it does not check to see if file is NULL, nor whether the structure file</span>
<a href="#l31.1520"></a><span id="l31.1520" class="difflineplus">+   points to has been clobbered or not.</span>
<a href="#l31.1521"></a><span id="l31.1521" class="difflineplus">+*/</span>
<a href="#l31.1522"></a><span id="l31.1522" class="difflineplus">+</span>
<a href="#l31.1523"></a><span id="l31.1523" class="difflineplus">+ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));</span>
<a href="#l31.1524"></a><span id="l31.1524" class="difflineplus">+/*</span>
<a href="#l31.1525"></a><span id="l31.1525" class="difflineplus">+     Push one character back onto the stream to be read as the first character</span>
<a href="#l31.1526"></a><span id="l31.1526" class="difflineplus">+   on the next read.  At least one character of push-back is allowed.</span>
<a href="#l31.1527"></a><span id="l31.1527" class="difflineplus">+   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will</span>
<a href="#l31.1528"></a><span id="l31.1528" class="difflineplus">+   fail if c is -1, and may fail if a character has been pushed but not read</span>
<a href="#l31.1529"></a><span id="l31.1529" class="difflineplus">+   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the</span>
<a href="#l31.1530"></a><span id="l31.1530" class="difflineplus">+   output buffer size of pushed characters is allowed.  (See gzbuffer above.)</span>
<a href="#l31.1531"></a><span id="l31.1531" class="difflineplus">+   The pushed character will be discarded if the stream is repositioned with</span>
<a href="#l31.1532"></a><span id="l31.1532" class="difflineplus">+   gzseek() or gzrewind().</span>
<a href="#l31.1533"></a><span id="l31.1533" class="difflineplus">+*/</span>
<a href="#l31.1534"></a><span id="l31.1534" class="difflineplus">+</span>
<a href="#l31.1535"></a><span id="l31.1535" class="difflineplus">+ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));</span>
<a href="#l31.1536"></a><span id="l31.1536" class="difflineplus">+/*</span>
<a href="#l31.1537"></a><span id="l31.1537" class="difflineplus">+     Flushes all pending output into the compressed file.  The parameter flush</span>
<a href="#l31.1538"></a><span id="l31.1538" class="difflineplus">+   is as in the deflate() function.  The return value is the zlib error number</span>
<a href="#l31.1539"></a><span id="l31.1539" class="difflineplus">+   (see function gzerror below).  gzflush is only permitted when writing.</span>
<a href="#l31.1540"></a><span id="l31.1540" class="difflineplus">+</span>
<a href="#l31.1541"></a><span id="l31.1541" class="difflineplus">+     If the flush parameter is Z_FINISH, the remaining data is written and the</span>
<a href="#l31.1542"></a><span id="l31.1542" class="difflineplus">+   gzip stream is completed in the output.  If gzwrite() is called again, a new</span>
<a href="#l31.1543"></a><span id="l31.1543" class="difflineplus">+   gzip stream will be started in the output.  gzread() is able to read such</span>
<a href="#l31.1544"></a><span id="l31.1544" class="difflineplus">+   concatenated gzip streams.</span>
<a href="#l31.1545"></a><span id="l31.1545" class="difflineplus">+</span>
<a href="#l31.1546"></a><span id="l31.1546" class="difflineplus">+     gzflush should be called only when strictly necessary because it will</span>
<a href="#l31.1547"></a><span id="l31.1547" class="difflineplus">+   degrade compression if called too often.</span>
<a href="#l31.1548"></a><span id="l31.1548" class="difflineplus">+*/</span>
<a href="#l31.1549"></a><span id="l31.1549" class="difflineplus">+</span>
<a href="#l31.1550"></a><span id="l31.1550" class="difflineplus">+/*</span>
<a href="#l31.1551"></a><span id="l31.1551" class="difflineplus">+ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,</span>
<a href="#l31.1552"></a><span id="l31.1552" class="difflineplus">+                                   z_off_t offset, int whence));</span>
<a href="#l31.1553"></a><span id="l31.1553" class="difflineplus">+</span>
<a href="#l31.1554"></a><span id="l31.1554" class="difflineplus">+     Sets the starting position for the next gzread or gzwrite on the given</span>
<a href="#l31.1555"></a><span id="l31.1555" class="difflineplus">+   compressed file.  The offset represents a number of bytes in the</span>
<a href="#l31.1556"></a><span id="l31.1556" class="difflineplus">+   uncompressed data stream.  The whence parameter is defined as in lseek(2);</span>
<a href="#l31.1557"></a><span id="l31.1557" class="difflineplus">+   the value SEEK_END is not supported.</span>
<a href="#l31.1558"></a><span id="l31.1558" class="difflineplus">+</span>
<a href="#l31.1559"></a><span id="l31.1559" class="difflineplus">+     If the file is opened for reading, this function is emulated but can be</span>
<a href="#l31.1560"></a><span id="l31.1560" class="difflineplus">+   extremely slow.  If the file is opened for writing, only forward seeks are</span>
<a href="#l31.1561"></a><span id="l31.1561" class="difflineplus">+   supported; gzseek then compresses a sequence of zeroes up to the new</span>
<a href="#l31.1562"></a><span id="l31.1562" class="difflineplus">+   starting position.</span>
<a href="#l31.1563"></a><span id="l31.1563" class="difflineplus">+</span>
<a href="#l31.1564"></a><span id="l31.1564" class="difflineplus">+     gzseek returns the resulting offset location as measured in bytes from</span>
<a href="#l31.1565"></a><span id="l31.1565" class="difflineplus">+   the beginning of the uncompressed stream, or -1 in case of error, in</span>
<a href="#l31.1566"></a><span id="l31.1566" class="difflineplus">+   particular if the file is opened for writing and the new starting position</span>
<a href="#l31.1567"></a><span id="l31.1567" class="difflineplus">+   would be before the current position.</span>
<a href="#l31.1568"></a><span id="l31.1568" class="difflineplus">+*/</span>
<a href="#l31.1569"></a><span id="l31.1569" class="difflineplus">+</span>
<a href="#l31.1570"></a><span id="l31.1570" class="difflineplus">+ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));</span>
<a href="#l31.1571"></a><span id="l31.1571" class="difflineplus">+/*</span>
<a href="#l31.1572"></a><span id="l31.1572" class="difflineplus">+     Rewinds the given file. This function is supported only for reading.</span>
<a href="#l31.1573"></a><span id="l31.1573" class="difflineplus">+</span>
<a href="#l31.1574"></a><span id="l31.1574" class="difflineplus">+     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)</span>
<a href="#l31.1575"></a><span id="l31.1575" class="difflineplus">+*/</span>
<a href="#l31.1576"></a><span id="l31.1576" class="difflineplus">+</span>
<a href="#l31.1577"></a><span id="l31.1577" class="difflineplus">+/*</span>
<a href="#l31.1578"></a><span id="l31.1578" class="difflineplus">+ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));</span>
<a href="#l31.1579"></a><span id="l31.1579" class="difflineplus">+</span>
<a href="#l31.1580"></a><span id="l31.1580" class="difflineplus">+     Returns the starting position for the next gzread or gzwrite on the given</span>
<a href="#l31.1581"></a><span id="l31.1581" class="difflineplus">+   compressed file.  This position represents a number of bytes in the</span>
<a href="#l31.1582"></a><span id="l31.1582" class="difflineplus">+   uncompressed data stream, and is zero when starting, even if appending or</span>
<a href="#l31.1583"></a><span id="l31.1583" class="difflineplus">+   reading a gzip stream from the middle of a file using gzdopen().</span>
<a href="#l31.1584"></a><span id="l31.1584" class="difflineplus">+</span>
<a href="#l31.1585"></a><span id="l31.1585" class="difflineplus">+     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)</span>
<a href="#l31.1586"></a><span id="l31.1586" class="difflineplus">+*/</span>
<a href="#l31.1587"></a><span id="l31.1587" class="difflineplus">+</span>
<a href="#l31.1588"></a><span id="l31.1588" class="difflineplus">+/*</span>
<a href="#l31.1589"></a><span id="l31.1589" class="difflineplus">+ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));</span>
<a href="#l31.1590"></a><span id="l31.1590" class="difflineplus">+</span>
<a href="#l31.1591"></a><span id="l31.1591" class="difflineplus">+     Returns the current offset in the file being read or written.  This offset</span>
<a href="#l31.1592"></a><span id="l31.1592" class="difflineplus">+   includes the count of bytes that precede the gzip stream, for example when</span>
<a href="#l31.1593"></a><span id="l31.1593" class="difflineplus">+   appending or when using gzdopen() for reading.  When reading, the offset</span>
<a href="#l31.1594"></a><span id="l31.1594" class="difflineplus">+   does not include as yet unused buffered input.  This information can be used</span>
<a href="#l31.1595"></a><span id="l31.1595" class="difflineplus">+   for a progress indicator.  On error, gzoffset() returns -1.</span>
<a href="#l31.1596"></a><span id="l31.1596" class="difflineplus">+*/</span>
<a href="#l31.1597"></a><span id="l31.1597" class="difflineplus">+</span>
<a href="#l31.1598"></a><span id="l31.1598" class="difflineplus">+ZEXTERN int ZEXPORT gzeof OF((gzFile file));</span>
<a href="#l31.1599"></a><span id="l31.1599" class="difflineplus">+/*</span>
<a href="#l31.1600"></a><span id="l31.1600" class="difflineplus">+     Returns true (1) if the end-of-file indicator has been set while reading,</span>
<a href="#l31.1601"></a><span id="l31.1601" class="difflineplus">+   false (0) otherwise.  Note that the end-of-file indicator is set only if the</span>
<a href="#l31.1602"></a><span id="l31.1602" class="difflineplus">+   read tried to go past the end of the input, but came up short.  Therefore,</span>
<a href="#l31.1603"></a><span id="l31.1603" class="difflineplus">+   just like feof(), gzeof() may return false even if there is no more data to</span>
<a href="#l31.1604"></a><span id="l31.1604" class="difflineplus">+   read, in the event that the last read request was for the exact number of</span>
<a href="#l31.1605"></a><span id="l31.1605" class="difflineplus">+   bytes remaining in the input file.  This will happen if the input file size</span>
<a href="#l31.1606"></a><span id="l31.1606" class="difflineplus">+   is an exact multiple of the buffer size.</span>
<a href="#l31.1607"></a><span id="l31.1607" class="difflineplus">+</span>
<a href="#l31.1608"></a><span id="l31.1608" class="difflineplus">+     If gzeof() returns true, then the read functions will return no more data,</span>
<a href="#l31.1609"></a><span id="l31.1609" class="difflineplus">+   unless the end-of-file indicator is reset by gzclearerr() and the input file</span>
<a href="#l31.1610"></a><span id="l31.1610" class="difflineplus">+   has grown since the previous end of file was detected.</span>
<a href="#l31.1611"></a><span id="l31.1611" class="difflineplus">+*/</span>
<a href="#l31.1612"></a><span id="l31.1612" class="difflineplus">+</span>
<a href="#l31.1613"></a><span id="l31.1613" class="difflineplus">+ZEXTERN int ZEXPORT gzdirect OF((gzFile file));</span>
<a href="#l31.1614"></a><span id="l31.1614" class="difflineplus">+/*</span>
<a href="#l31.1615"></a><span id="l31.1615" class="difflineplus">+     Returns true (1) if file is being copied directly while reading, or false</span>
<a href="#l31.1616"></a><span id="l31.1616" class="difflineplus">+   (0) if file is a gzip stream being decompressed.</span>
<a href="#l31.1617"></a><span id="l31.1617" class="difflineplus">+</span>
<a href="#l31.1618"></a><span id="l31.1618" class="difflineplus">+     If the input file is empty, gzdirect() will return true, since the input</span>
<a href="#l31.1619"></a><span id="l31.1619" class="difflineplus">+   does not contain a gzip stream.</span>
<a href="#l31.1620"></a><span id="l31.1620" class="difflineplus">+</span>
<a href="#l31.1621"></a><span id="l31.1621" class="difflineplus">+     If gzdirect() is used immediately after gzopen() or gzdopen() it will</span>
<a href="#l31.1622"></a><span id="l31.1622" class="difflineplus">+   cause buffers to be allocated to allow reading the file to determine if it</span>
<a href="#l31.1623"></a><span id="l31.1623" class="difflineplus">+   is a gzip file.  Therefore if gzbuffer() is used, it should be called before</span>
<a href="#l31.1624"></a><span id="l31.1624" class="difflineplus">+   gzdirect().</span>
<a href="#l31.1625"></a><span id="l31.1625" class="difflineplus">+</span>
<a href="#l31.1626"></a><span id="l31.1626" class="difflineplus">+     When writing, gzdirect() returns true (1) if transparent writing was</span>
<a href="#l31.1627"></a><span id="l31.1627" class="difflineplus">+   requested (&quot;wT&quot; for the gzopen() mode), or false (0) otherwise.  (Note:</span>
<a href="#l31.1628"></a><span id="l31.1628" class="difflineplus">+   gzdirect() is not needed when writing.  Transparent writing must be</span>
<a href="#l31.1629"></a><span id="l31.1629" class="difflineplus">+   explicitly requested, so the application already knows the answer.  When</span>
<a href="#l31.1630"></a><span id="l31.1630" class="difflineplus">+   linking statically, using gzdirect() will include all of the zlib code for</span>
<a href="#l31.1631"></a><span id="l31.1631" class="difflineplus">+   gzip file reading and decompression, which may not be desired.)</span>
<a href="#l31.1632"></a><span id="l31.1632" class="difflineplus">+*/</span>
<a href="#l31.1633"></a><span id="l31.1633" class="difflineplus">+</span>
<a href="#l31.1634"></a><span id="l31.1634" class="difflineplus">+ZEXTERN int ZEXPORT    gzclose OF((gzFile file));</span>
<a href="#l31.1635"></a><span id="l31.1635" class="difflineplus">+/*</span>
<a href="#l31.1636"></a><span id="l31.1636" class="difflineplus">+     Flushes all pending output if necessary, closes the compressed file and</span>
<a href="#l31.1637"></a><span id="l31.1637" class="difflineplus">+   deallocates the (de)compression state.  Note that once file is closed, you</span>
<a href="#l31.1638"></a><span id="l31.1638" class="difflineplus">+   cannot call gzerror with file, since its structures have been deallocated.</span>
<a href="#l31.1639"></a><span id="l31.1639" class="difflineplus">+   gzclose must not be called more than once on the same file, just as free</span>
<a href="#l31.1640"></a><span id="l31.1640" class="difflineplus">+   must not be called more than once on the same allocation.</span>
<a href="#l31.1641"></a><span id="l31.1641" class="difflineplus">+</span>
<a href="#l31.1642"></a><span id="l31.1642" class="difflineplus">+     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a</span>
<a href="#l31.1643"></a><span id="l31.1643" class="difflineplus">+   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the</span>
<a href="#l31.1644"></a><span id="l31.1644" class="difflineplus">+   last read ended in the middle of a gzip stream, or Z_OK on success.</span>
<a href="#l31.1645"></a><span id="l31.1645" class="difflineplus">+*/</span>
<a href="#l31.1646"></a><span id="l31.1646" class="difflineplus">+</span>
<a href="#l31.1647"></a><span id="l31.1647" class="difflineplus">+ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));</span>
<a href="#l31.1648"></a><span id="l31.1648" class="difflineplus">+ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));</span>
<a href="#l31.1649"></a><span id="l31.1649" class="difflineplus">+/*</span>
<a href="#l31.1650"></a><span id="l31.1650" class="difflineplus">+     Same as gzclose(), but gzclose_r() is only for use when reading, and</span>
<a href="#l31.1651"></a><span id="l31.1651" class="difflineplus">+   gzclose_w() is only for use when writing or appending.  The advantage to</span>
<a href="#l31.1652"></a><span id="l31.1652" class="difflineplus">+   using these instead of gzclose() is that they avoid linking in zlib</span>
<a href="#l31.1653"></a><span id="l31.1653" class="difflineplus">+   compression or decompression code that is not used when only reading or only</span>
<a href="#l31.1654"></a><span id="l31.1654" class="difflineplus">+   writing respectively.  If gzclose() is used, then both compression and</span>
<a href="#l31.1655"></a><span id="l31.1655" class="difflineplus">+   decompression code will be included the application when linking to a static</span>
<a href="#l31.1656"></a><span id="l31.1656" class="difflineplus">+   zlib library.</span>
<a href="#l31.1657"></a><span id="l31.1657" class="difflineplus">+*/</span>
<a href="#l31.1658"></a><span id="l31.1658" class="difflineplus">+</span>
<a href="#l31.1659"></a><span id="l31.1659" class="difflineplus">+ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));</span>
<a href="#l31.1660"></a><span id="l31.1660" class="difflineplus">+/*</span>
<a href="#l31.1661"></a><span id="l31.1661" class="difflineplus">+     Returns the error message for the last error which occurred on the given</span>
<a href="#l31.1662"></a><span id="l31.1662" class="difflineplus">+   compressed file.  errnum is set to zlib error number.  If an error occurred</span>
<a href="#l31.1663"></a><span id="l31.1663" class="difflineplus">+   in the file system and not in the compression library, errnum is set to</span>
<a href="#l31.1664"></a><span id="l31.1664" class="difflineplus">+   Z_ERRNO and the application may consult errno to get the exact error code.</span>
<a href="#l31.1665"></a><span id="l31.1665" class="difflineplus">+</span>
<a href="#l31.1666"></a><span id="l31.1666" class="difflineplus">+     The application must not modify the returned string.  Future calls to</span>
<a href="#l31.1667"></a><span id="l31.1667" class="difflineplus">+   this function may invalidate the previously returned string.  If file is</span>
<a href="#l31.1668"></a><span id="l31.1668" class="difflineplus">+   closed, then the string previously returned by gzerror will no longer be</span>
<a href="#l31.1669"></a><span id="l31.1669" class="difflineplus">+   available.</span>
<a href="#l31.1670"></a><span id="l31.1670" class="difflineplus">+</span>
<a href="#l31.1671"></a><span id="l31.1671" class="difflineplus">+     gzerror() should be used to distinguish errors from end-of-file for those</span>
<a href="#l31.1672"></a><span id="l31.1672" class="difflineplus">+   functions above that do not distinguish those cases in their return values.</span>
<a href="#l31.1673"></a><span id="l31.1673" class="difflineplus">+*/</span>
<a href="#l31.1674"></a><span id="l31.1674" class="difflineplus">+</span>
<a href="#l31.1675"></a><span id="l31.1675" class="difflineplus">+ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));</span>
<a href="#l31.1676"></a><span id="l31.1676" class="difflineplus">+/*</span>
<a href="#l31.1677"></a><span id="l31.1677" class="difflineplus">+     Clears the error and end-of-file flags for file.  This is analogous to the</span>
<a href="#l31.1678"></a><span id="l31.1678" class="difflineplus">+   clearerr() function in stdio.  This is useful for continuing to read a gzip</span>
<a href="#l31.1679"></a><span id="l31.1679" class="difflineplus">+   file that is being written concurrently.</span>
<a href="#l31.1680"></a><span id="l31.1680" class="difflineplus">+*/</span>
<a href="#l31.1681"></a><span id="l31.1681" class="difflineplus">+</span>
<a href="#l31.1682"></a><span id="l31.1682" class="difflineplus">+#endif /* !Z_SOLO */</span>
<a href="#l31.1683"></a><span id="l31.1683" class="difflineplus">+</span>
<a href="#l31.1684"></a><span id="l31.1684" class="difflineplus">+                        /* checksum functions */</span>
<a href="#l31.1685"></a><span id="l31.1685" class="difflineplus">+</span>
<a href="#l31.1686"></a><span id="l31.1686" class="difflineplus">+/*</span>
<a href="#l31.1687"></a><span id="l31.1687" class="difflineplus">+     These functions are not related to compression but are exported</span>
<a href="#l31.1688"></a><span id="l31.1688" class="difflineplus">+   anyway because they might be useful in applications using the compression</span>
<a href="#l31.1689"></a><span id="l31.1689" class="difflineplus">+   library.</span>
<a href="#l31.1690"></a><span id="l31.1690" class="difflineplus">+*/</span>
<a href="#l31.1691"></a><span id="l31.1691" class="difflineplus">+</span>
<a href="#l31.1692"></a><span id="l31.1692" class="difflineplus">+ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));</span>
<a href="#l31.1693"></a><span id="l31.1693" class="difflineplus">+/*</span>
<a href="#l31.1694"></a><span id="l31.1694" class="difflineplus">+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and</span>
<a href="#l31.1695"></a><span id="l31.1695" class="difflineplus">+   return the updated checksum.  If buf is Z_NULL, this function returns the</span>
<a href="#l31.1696"></a><span id="l31.1696" class="difflineplus">+   required initial value for the checksum.</span>
<a href="#l31.1697"></a><span id="l31.1697" class="difflineplus">+</span>
<a href="#l31.1698"></a><span id="l31.1698" class="difflineplus">+     An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed</span>
<a href="#l31.1699"></a><span id="l31.1699" class="difflineplus">+   much faster.</span>
<a href="#l31.1700"></a><span id="l31.1700" class="difflineplus">+</span>
<a href="#l31.1701"></a><span id="l31.1701" class="difflineplus">+   Usage example:</span>
<a href="#l31.1702"></a><span id="l31.1702" class="difflineplus">+</span>
<a href="#l31.1703"></a><span id="l31.1703" class="difflineplus">+     uLong adler = adler32(0L, Z_NULL, 0);</span>
<a href="#l31.1704"></a><span id="l31.1704" class="difflineplus">+</span>
<a href="#l31.1705"></a><span id="l31.1705" class="difflineplus">+     while (read_buffer(buffer, length) != EOF) {</span>
<a href="#l31.1706"></a><span id="l31.1706" class="difflineplus">+       adler = adler32(adler, buffer, length);</span>
<a href="#l31.1707"></a><span id="l31.1707" class="difflineplus">+     }</span>
<a href="#l31.1708"></a><span id="l31.1708" class="difflineplus">+     if (adler != original_adler) error();</span>
<a href="#l31.1709"></a><span id="l31.1709" class="difflineplus">+*/</span>
<a href="#l31.1710"></a><span id="l31.1710" class="difflineplus">+</span>
<a href="#l31.1711"></a><span id="l31.1711" class="difflineplus">+ZEXTERN uLong ZEXPORT adler32_z OF((uLong adler, const Bytef *buf,</span>
<a href="#l31.1712"></a><span id="l31.1712" class="difflineplus">+                                    z_size_t len));</span>
<a href="#l31.1713"></a><span id="l31.1713" class="difflineplus">+/*</span>
<a href="#l31.1714"></a><span id="l31.1714" class="difflineplus">+     Same as adler32(), but with a size_t length.</span>
<a href="#l31.1715"></a><span id="l31.1715" class="difflineplus">+*/</span>
<a href="#l31.1716"></a><span id="l31.1716" class="difflineplus">+</span>
<a href="#l31.1717"></a><span id="l31.1717" class="difflineplus">+/*</span>
<a href="#l31.1718"></a><span id="l31.1718" class="difflineplus">+ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,</span>
<a href="#l31.1719"></a><span id="l31.1719" class="difflineplus">+                                          z_off_t len2));</span>
<a href="#l31.1720"></a><span id="l31.1720" class="difflineplus">+</span>
<a href="#l31.1721"></a><span id="l31.1721" class="difflineplus">+     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1</span>
<a href="#l31.1722"></a><span id="l31.1722" class="difflineplus">+   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for</span>
<a href="#l31.1723"></a><span id="l31.1723" class="difflineplus">+   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of</span>
<a href="#l31.1724"></a><span id="l31.1724" class="difflineplus">+   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note</span>
<a href="#l31.1725"></a><span id="l31.1725" class="difflineplus">+   that the z_off_t type (like off_t) is a signed integer.  If len2 is</span>
<a href="#l31.1726"></a><span id="l31.1726" class="difflineplus">+   negative, the result has no meaning or utility.</span>
<a href="#l31.1727"></a><span id="l31.1727" class="difflineplus">+*/</span>
<a href="#l31.1728"></a><span id="l31.1728" class="difflineplus">+</span>
<a href="#l31.1729"></a><span id="l31.1729" class="difflineplus">+ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));</span>
<a href="#l31.1730"></a><span id="l31.1730" class="difflineplus">+/*</span>
<a href="#l31.1731"></a><span id="l31.1731" class="difflineplus">+     Update a running CRC-32 with the bytes buf[0..len-1] and return the</span>
<a href="#l31.1732"></a><span id="l31.1732" class="difflineplus">+   updated CRC-32.  If buf is Z_NULL, this function returns the required</span>
<a href="#l31.1733"></a><span id="l31.1733" class="difflineplus">+   initial value for the crc.  Pre- and post-conditioning (one's complement) is</span>
<a href="#l31.1734"></a><span id="l31.1734" class="difflineplus">+   performed within this function so it shouldn't be done by the application.</span>
<a href="#l31.1735"></a><span id="l31.1735" class="difflineplus">+</span>
<a href="#l31.1736"></a><span id="l31.1736" class="difflineplus">+   Usage example:</span>
<a href="#l31.1737"></a><span id="l31.1737" class="difflineplus">+</span>
<a href="#l31.1738"></a><span id="l31.1738" class="difflineplus">+     uLong crc = crc32(0L, Z_NULL, 0);</span>
<a href="#l31.1739"></a><span id="l31.1739" class="difflineplus">+</span>
<a href="#l31.1740"></a><span id="l31.1740" class="difflineplus">+     while (read_buffer(buffer, length) != EOF) {</span>
<a href="#l31.1741"></a><span id="l31.1741" class="difflineplus">+       crc = crc32(crc, buffer, length);</span>
<a href="#l31.1742"></a><span id="l31.1742" class="difflineplus">+     }</span>
<a href="#l31.1743"></a><span id="l31.1743" class="difflineplus">+     if (crc != original_crc) error();</span>
<a href="#l31.1744"></a><span id="l31.1744" class="difflineplus">+*/</span>
<a href="#l31.1745"></a><span id="l31.1745" class="difflineplus">+</span>
<a href="#l31.1746"></a><span id="l31.1746" class="difflineplus">+ZEXTERN uLong ZEXPORT crc32_z OF((uLong adler, const Bytef *buf,</span>
<a href="#l31.1747"></a><span id="l31.1747" class="difflineplus">+                                  z_size_t len));</span>
<a href="#l31.1748"></a><span id="l31.1748" class="difflineplus">+/*</span>
<a href="#l31.1749"></a><span id="l31.1749" class="difflineplus">+     Same as crc32(), but with a size_t length.</span>
<a href="#l31.1750"></a><span id="l31.1750" class="difflineplus">+*/</span>
<a href="#l31.1751"></a><span id="l31.1751" class="difflineplus">+</span>
<a href="#l31.1752"></a><span id="l31.1752" class="difflineplus">+/*</span>
<a href="#l31.1753"></a><span id="l31.1753" class="difflineplus">+ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));</span>
<a href="#l31.1754"></a><span id="l31.1754" class="difflineplus">+</span>
<a href="#l31.1755"></a><span id="l31.1755" class="difflineplus">+     Combine two CRC-32 check values into one.  For two sequences of bytes,</span>
<a href="#l31.1756"></a><span id="l31.1756" class="difflineplus">+   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were</span>
<a href="#l31.1757"></a><span id="l31.1757" class="difflineplus">+   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32</span>
<a href="#l31.1758"></a><span id="l31.1758" class="difflineplus">+   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and</span>
<a href="#l31.1759"></a><span id="l31.1759" class="difflineplus">+   len2.</span>
<a href="#l31.1760"></a><span id="l31.1760" class="difflineplus">+*/</span>
<a href="#l31.1761"></a><span id="l31.1761" class="difflineplus">+</span>
<a href="#l31.1762"></a><span id="l31.1762" class="difflineplus">+</span>
<a href="#l31.1763"></a><span id="l31.1763" class="difflineplus">+                        /* various hacks, don't look :) */</span>
<a href="#l31.1764"></a><span id="l31.1764" class="difflineplus">+</span>
<a href="#l31.1765"></a><span id="l31.1765" class="difflineplus">+/* deflateInit and inflateInit are macros to allow checking the zlib version</span>
<a href="#l31.1766"></a><span id="l31.1766" class="difflineplus">+ * and the compiler's view of z_stream:</span>
<a href="#l31.1767"></a><span id="l31.1767" class="difflineplus">+ */</span>
<a href="#l31.1768"></a><span id="l31.1768" class="difflineplus">+ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,</span>
<a href="#l31.1769"></a><span id="l31.1769" class="difflineplus">+                                     const char *version, int stream_size));</span>
<a href="#l31.1770"></a><span id="l31.1770" class="difflineplus">+ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,</span>
<a href="#l31.1771"></a><span id="l31.1771" class="difflineplus">+                                     const char *version, int stream_size));</span>
<a href="#l31.1772"></a><span id="l31.1772" class="difflineplus">+ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,</span>
<a href="#l31.1773"></a><span id="l31.1773" class="difflineplus">+                                      int windowBits, int memLevel,</span>
<a href="#l31.1774"></a><span id="l31.1774" class="difflineplus">+                                      int strategy, const char *version,</span>
<a href="#l31.1775"></a><span id="l31.1775" class="difflineplus">+                                      int stream_size));</span>
<a href="#l31.1776"></a><span id="l31.1776" class="difflineplus">+ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,</span>
<a href="#l31.1777"></a><span id="l31.1777" class="difflineplus">+                                      const char *version, int stream_size));</span>
<a href="#l31.1778"></a><span id="l31.1778" class="difflineplus">+ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,</span>
<a href="#l31.1779"></a><span id="l31.1779" class="difflineplus">+                                         unsigned char FAR *window,</span>
<a href="#l31.1780"></a><span id="l31.1780" class="difflineplus">+                                         const char *version,</span>
<a href="#l31.1781"></a><span id="l31.1781" class="difflineplus">+                                         int stream_size));</span>
<a href="#l31.1782"></a><span id="l31.1782" class="difflineplus">+#ifdef Z_PREFIX_SET</span>
<a href="#l31.1783"></a><span id="l31.1783" class="difflineplus">+#  define z_deflateInit(strm, level) \</span>
<a href="#l31.1784"></a><span id="l31.1784" class="difflineplus">+          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))</span>
<a href="#l31.1785"></a><span id="l31.1785" class="difflineplus">+#  define z_inflateInit(strm) \</span>
<a href="#l31.1786"></a><span id="l31.1786" class="difflineplus">+          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))</span>
<a href="#l31.1787"></a><span id="l31.1787" class="difflineplus">+#  define z_deflateInit2(strm, level, method, windowBits, memLevel, strategy) \</span>
<a href="#l31.1788"></a><span id="l31.1788" class="difflineplus">+          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\</span>
<a href="#l31.1789"></a><span id="l31.1789" class="difflineplus">+                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))</span>
<a href="#l31.1790"></a><span id="l31.1790" class="difflineplus">+#  define z_inflateInit2(strm, windowBits) \</span>
<a href="#l31.1791"></a><span id="l31.1791" class="difflineplus">+          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \</span>
<a href="#l31.1792"></a><span id="l31.1792" class="difflineplus">+                        (int)sizeof(z_stream))</span>
<a href="#l31.1793"></a><span id="l31.1793" class="difflineplus">+#  define z_inflateBackInit(strm, windowBits, window) \</span>
<a href="#l31.1794"></a><span id="l31.1794" class="difflineplus">+          inflateBackInit_((strm), (windowBits), (window), \</span>
<a href="#l31.1795"></a><span id="l31.1795" class="difflineplus">+                           ZLIB_VERSION, (int)sizeof(z_stream))</span>
<a href="#l31.1796"></a><span id="l31.1796" class="difflineplus">+#else</span>
<a href="#l31.1797"></a><span id="l31.1797" class="difflineplus">+#  define deflateInit(strm, level) \</span>
<a href="#l31.1798"></a><span id="l31.1798" class="difflineplus">+          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))</span>
<a href="#l31.1799"></a><span id="l31.1799" class="difflineplus">+#  define inflateInit(strm) \</span>
<a href="#l31.1800"></a><span id="l31.1800" class="difflineplus">+          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))</span>
<a href="#l31.1801"></a><span id="l31.1801" class="difflineplus">+#  define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \</span>
<a href="#l31.1802"></a><span id="l31.1802" class="difflineplus">+          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\</span>
<a href="#l31.1803"></a><span id="l31.1803" class="difflineplus">+                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))</span>
<a href="#l31.1804"></a><span id="l31.1804" class="difflineplus">+#  define inflateInit2(strm, windowBits) \</span>
<a href="#l31.1805"></a><span id="l31.1805" class="difflineplus">+          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \</span>
<a href="#l31.1806"></a><span id="l31.1806" class="difflineplus">+                        (int)sizeof(z_stream))</span>
<a href="#l31.1807"></a><span id="l31.1807" class="difflineplus">+#  define inflateBackInit(strm, windowBits, window) \</span>
<a href="#l31.1808"></a><span id="l31.1808" class="difflineplus">+          inflateBackInit_((strm), (windowBits), (window), \</span>
<a href="#l31.1809"></a><span id="l31.1809" class="difflineplus">+                           ZLIB_VERSION, (int)sizeof(z_stream))</span>
<a href="#l31.1810"></a><span id="l31.1810" class="difflineplus">+#endif</span>
<a href="#l31.1811"></a><span id="l31.1811" class="difflineplus">+</span>
<a href="#l31.1812"></a><span id="l31.1812" class="difflineplus">+#ifndef Z_SOLO</span>
<a href="#l31.1813"></a><span id="l31.1813" class="difflineplus">+</span>
<a href="#l31.1814"></a><span id="l31.1814" class="difflineplus">+/* gzgetc() macro and its supporting function and exposed data structure.  Note</span>
<a href="#l31.1815"></a><span id="l31.1815" class="difflineplus">+ * that the real internal state is much larger than the exposed structure.</span>
<a href="#l31.1816"></a><span id="l31.1816" class="difflineplus">+ * This abbreviated structure exposes just enough for the gzgetc() macro.  The</span>
<a href="#l31.1817"></a><span id="l31.1817" class="difflineplus">+ * user should not mess with these exposed elements, since their names or</span>
<a href="#l31.1818"></a><span id="l31.1818" class="difflineplus">+ * behavior could change in the future, perhaps even capriciously.  They can</span>
<a href="#l31.1819"></a><span id="l31.1819" class="difflineplus">+ * only be used by the gzgetc() macro.  You have been warned.</span>
<a href="#l31.1820"></a><span id="l31.1820" class="difflineplus">+ */</span>
<a href="#l31.1821"></a><span id="l31.1821" class="difflineplus">+struct gzFile_s {</span>
<a href="#l31.1822"></a><span id="l31.1822" class="difflineplus">+    unsigned have;</span>
<a href="#l31.1823"></a><span id="l31.1823" class="difflineplus">+    unsigned char *next;</span>
<a href="#l31.1824"></a><span id="l31.1824" class="difflineplus">+    z_off64_t pos;</span>
<a href="#l31.1825"></a><span id="l31.1825" class="difflineplus">+};</span>
<a href="#l31.1826"></a><span id="l31.1826" class="difflineplus">+ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */</span>
<a href="#l31.1827"></a><span id="l31.1827" class="difflineplus">+#ifdef Z_PREFIX_SET</span>
<a href="#l31.1828"></a><span id="l31.1828" class="difflineplus">+#  undef z_gzgetc</span>
<a href="#l31.1829"></a><span id="l31.1829" class="difflineplus">+#  define z_gzgetc(g) \</span>
<a href="#l31.1830"></a><span id="l31.1830" class="difflineplus">+          ((g)-&gt;have ? ((g)-&gt;have--, (g)-&gt;pos++, *((g)-&gt;next)++) : (gzgetc)(g))</span>
<a href="#l31.1831"></a><span id="l31.1831" class="difflineplus">+#else</span>
<a href="#l31.1832"></a><span id="l31.1832" class="difflineplus">+#  define gzgetc(g) \</span>
<a href="#l31.1833"></a><span id="l31.1833" class="difflineplus">+          ((g)-&gt;have ? ((g)-&gt;have--, (g)-&gt;pos++, *((g)-&gt;next)++) : (gzgetc)(g))</span>
<a href="#l31.1834"></a><span id="l31.1834" class="difflineplus">+#endif</span>
<a href="#l31.1835"></a><span id="l31.1835" class="difflineplus">+</span>
<a href="#l31.1836"></a><span id="l31.1836" class="difflineplus">+/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or</span>
<a href="#l31.1837"></a><span id="l31.1837" class="difflineplus">+ * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if</span>
<a href="#l31.1838"></a><span id="l31.1838" class="difflineplus">+ * both are true, the application gets the *64 functions, and the regular</span>
<a href="#l31.1839"></a><span id="l31.1839" class="difflineplus">+ * functions are changed to 64 bits) -- in case these are set on systems</span>
<a href="#l31.1840"></a><span id="l31.1840" class="difflineplus">+ * without large file support, _LFS64_LARGEFILE must also be true</span>
<a href="#l31.1841"></a><span id="l31.1841" class="difflineplus">+ */</span>
<a href="#l31.1842"></a><span id="l31.1842" class="difflineplus">+#ifdef Z_LARGE64</span>
<a href="#l31.1843"></a><span id="l31.1843" class="difflineplus">+   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));</span>
<a href="#l31.1844"></a><span id="l31.1844" class="difflineplus">+   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));</span>
<a href="#l31.1845"></a><span id="l31.1845" class="difflineplus">+   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));</span>
<a href="#l31.1846"></a><span id="l31.1846" class="difflineplus">+   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));</span>
<a href="#l31.1847"></a><span id="l31.1847" class="difflineplus">+   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));</span>
<a href="#l31.1848"></a><span id="l31.1848" class="difflineplus">+   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));</span>
<a href="#l31.1849"></a><span id="l31.1849" class="difflineplus">+#endif</span>
<a href="#l31.1850"></a><span id="l31.1850" class="difflineplus">+</span>
<a href="#l31.1851"></a><span id="l31.1851" class="difflineplus">+#if !defined(ZLIB_INTERNAL) &amp;&amp; defined(Z_WANT64)</span>
<a href="#l31.1852"></a><span id="l31.1852" class="difflineplus">+#  ifdef Z_PREFIX_SET</span>
<a href="#l31.1853"></a><span id="l31.1853" class="difflineplus">+#    define z_gzopen z_gzopen64</span>
<a href="#l31.1854"></a><span id="l31.1854" class="difflineplus">+#    define z_gzseek z_gzseek64</span>
<a href="#l31.1855"></a><span id="l31.1855" class="difflineplus">+#    define z_gztell z_gztell64</span>
<a href="#l31.1856"></a><span id="l31.1856" class="difflineplus">+#    define z_gzoffset z_gzoffset64</span>
<a href="#l31.1857"></a><span id="l31.1857" class="difflineplus">+#    define z_adler32_combine z_adler32_combine64</span>
<a href="#l31.1858"></a><span id="l31.1858" class="difflineplus">+#    define z_crc32_combine z_crc32_combine64</span>
<a href="#l31.1859"></a><span id="l31.1859" class="difflineplus">+#  else</span>
<a href="#l31.1860"></a><span id="l31.1860" class="difflineplus">+#    define gzopen gzopen64</span>
<a href="#l31.1861"></a><span id="l31.1861" class="difflineplus">+#    define gzseek gzseek64</span>
<a href="#l31.1862"></a><span id="l31.1862" class="difflineplus">+#    define gztell gztell64</span>
<a href="#l31.1863"></a><span id="l31.1863" class="difflineplus">+#    define gzoffset gzoffset64</span>
<a href="#l31.1864"></a><span id="l31.1864" class="difflineplus">+#    define adler32_combine adler32_combine64</span>
<a href="#l31.1865"></a><span id="l31.1865" class="difflineplus">+#    define crc32_combine crc32_combine64</span>
<a href="#l31.1866"></a><span id="l31.1866" class="difflineplus">+#  endif</span>
<a href="#l31.1867"></a><span id="l31.1867" class="difflineplus">+#  ifndef Z_LARGE64</span>
<a href="#l31.1868"></a><span id="l31.1868" class="difflineplus">+     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));</span>
<a href="#l31.1869"></a><span id="l31.1869" class="difflineplus">+     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));</span>
<a href="#l31.1870"></a><span id="l31.1870" class="difflineplus">+     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));</span>
<a href="#l31.1871"></a><span id="l31.1871" class="difflineplus">+     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));</span>
<a href="#l31.1872"></a><span id="l31.1872" class="difflineplus">+     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));</span>
<a href="#l31.1873"></a><span id="l31.1873" class="difflineplus">+     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));</span>
<a href="#l31.1874"></a><span id="l31.1874" class="difflineplus">+#  endif</span>
<a href="#l31.1875"></a><span id="l31.1875" class="difflineplus">+#else</span>
<a href="#l31.1876"></a><span id="l31.1876" class="difflineplus">+   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));</span>
<a href="#l31.1877"></a><span id="l31.1877" class="difflineplus">+   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));</span>
<a href="#l31.1878"></a><span id="l31.1878" class="difflineplus">+   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));</span>
<a href="#l31.1879"></a><span id="l31.1879" class="difflineplus">+   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));</span>
<a href="#l31.1880"></a><span id="l31.1880" class="difflineplus">+   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));</span>
<a href="#l31.1881"></a><span id="l31.1881" class="difflineplus">+   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));</span>
<a href="#l31.1882"></a><span id="l31.1882" class="difflineplus">+#endif</span>
<a href="#l31.1883"></a><span id="l31.1883" class="difflineplus">+</span>
<a href="#l31.1884"></a><span id="l31.1884" class="difflineplus">+#else /* Z_SOLO */</span>
<a href="#l31.1885"></a><span id="l31.1885" class="difflineplus">+</span>
<a href="#l31.1886"></a><span id="l31.1886" class="difflineplus">+   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));</span>
<a href="#l31.1887"></a><span id="l31.1887" class="difflineplus">+   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));</span>
<a href="#l31.1888"></a><span id="l31.1888" class="difflineplus">+</span>
<a href="#l31.1889"></a><span id="l31.1889" class="difflineplus">+#endif /* !Z_SOLO */</span>
<a href="#l31.1890"></a><span id="l31.1890" class="difflineplus">+</span>
<a href="#l31.1891"></a><span id="l31.1891" class="difflineplus">+/* undocumented functions */</span>
<a href="#l31.1892"></a><span id="l31.1892" class="difflineplus">+ZEXTERN const char   * ZEXPORT zError           OF((int));</span>
<a href="#l31.1893"></a><span id="l31.1893" class="difflineplus">+ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));</span>
<a href="#l31.1894"></a><span id="l31.1894" class="difflineplus">+ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));</span>
<a href="#l31.1895"></a><span id="l31.1895" class="difflineplus">+ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));</span>
<a href="#l31.1896"></a><span id="l31.1896" class="difflineplus">+ZEXTERN int            ZEXPORT inflateValidate OF((z_streamp, int));</span>
<a href="#l31.1897"></a><span id="l31.1897" class="difflineplus">+ZEXTERN unsigned long  ZEXPORT inflateCodesUsed OF ((z_streamp));</span>
<a href="#l31.1898"></a><span id="l31.1898" class="difflineplus">+ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));</span>
<a href="#l31.1899"></a><span id="l31.1899" class="difflineplus">+ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));</span>
<a href="#l31.1900"></a><span id="l31.1900" class="difflineplus">+#if (defined(_WIN32) || defined(__CYGWIN__)) &amp;&amp; !defined(Z_SOLO)</span>
<a href="#l31.1901"></a><span id="l31.1901" class="difflineplus">+ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,</span>
<a href="#l31.1902"></a><span id="l31.1902" class="difflineplus">+                                            const char *mode));</span>
<a href="#l31.1903"></a><span id="l31.1903" class="difflineplus">+#endif</span>
<a href="#l31.1904"></a><span id="l31.1904" class="difflineplus">+#if defined(STDC) || defined(Z_HAVE_STDARG_H)</span>
<a href="#l31.1905"></a><span id="l31.1905" class="difflineplus">+#  ifndef Z_SOLO</span>
<a href="#l31.1906"></a><span id="l31.1906" class="difflineplus">+ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,</span>
<a href="#l31.1907"></a><span id="l31.1907" class="difflineplus">+                                                  const char *format,</span>
<a href="#l31.1908"></a><span id="l31.1908" class="difflineplus">+                                                  va_list va));</span>
<a href="#l31.1909"></a><span id="l31.1909" class="difflineplus">+#  endif</span>
<a href="#l31.1910"></a><span id="l31.1910" class="difflineplus">+#endif</span>
<a href="#l31.1911"></a><span id="l31.1911" class="difflineplus">+</span>
<a href="#l31.1912"></a><span id="l31.1912" class="difflineplus">+#ifdef __cplusplus</span>
<a href="#l31.1913"></a><span id="l31.1913" class="difflineplus">+}</span>
<a href="#l31.1914"></a><span id="l31.1914" class="difflineplus">+#endif</span>
<a href="#l31.1915"></a><span id="l31.1915" class="difflineplus">+</span>
<a href="#l31.1916"></a><span id="l31.1916" class="difflineplus">+#endif /* ZLIB_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l32.1"></a><span id="l32.1">new file mode 100644</span>
<a href="#l32.2"></a><span id="l32.2" class="difflineminus">--- /dev/null</span>
<a href="#l32.3"></a><span id="l32.3" class="difflineplus">+++ b/third_party/zlib/zutil.c</span>
<a href="#l32.4"></a><span id="l32.4" class="difflineat">@@ -0,0 +1,325 @@</span>
<a href="#l32.5"></a><span id="l32.5" class="difflineplus">+/* zutil.c -- target dependent utility functions for the compression library</span>
<a href="#l32.6"></a><span id="l32.6" class="difflineplus">+ * Copyright (C) 1995-2017 Jean-loup Gailly</span>
<a href="#l32.7"></a><span id="l32.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l32.8"></a><span id="l32.8" class="difflineplus">+ */</span>
<a href="#l32.9"></a><span id="l32.9" class="difflineplus">+</span>
<a href="#l32.10"></a><span id="l32.10" class="difflineplus">+/* @(#) $Id$ */</span>
<a href="#l32.11"></a><span id="l32.11" class="difflineplus">+</span>
<a href="#l32.12"></a><span id="l32.12" class="difflineplus">+#include &quot;zutil.h&quot;</span>
<a href="#l32.13"></a><span id="l32.13" class="difflineplus">+#ifndef Z_SOLO</span>
<a href="#l32.14"></a><span id="l32.14" class="difflineplus">+#  include &quot;gzguts.h&quot;</span>
<a href="#l32.15"></a><span id="l32.15" class="difflineplus">+#endif</span>
<a href="#l32.16"></a><span id="l32.16" class="difflineplus">+</span>
<a href="#l32.17"></a><span id="l32.17" class="difflineplus">+z_const char * const z_errmsg[10] = {</span>
<a href="#l32.18"></a><span id="l32.18" class="difflineplus">+    (z_const char *)&quot;need dictionary&quot;,     /* Z_NEED_DICT       2  */</span>
<a href="#l32.19"></a><span id="l32.19" class="difflineplus">+    (z_const char *)&quot;stream end&quot;,          /* Z_STREAM_END      1  */</span>
<a href="#l32.20"></a><span id="l32.20" class="difflineplus">+    (z_const char *)&quot;&quot;,                    /* Z_OK              0  */</span>
<a href="#l32.21"></a><span id="l32.21" class="difflineplus">+    (z_const char *)&quot;file error&quot;,          /* Z_ERRNO         (-1) */</span>
<a href="#l32.22"></a><span id="l32.22" class="difflineplus">+    (z_const char *)&quot;stream error&quot;,        /* Z_STREAM_ERROR  (-2) */</span>
<a href="#l32.23"></a><span id="l32.23" class="difflineplus">+    (z_const char *)&quot;data error&quot;,          /* Z_DATA_ERROR    (-3) */</span>
<a href="#l32.24"></a><span id="l32.24" class="difflineplus">+    (z_const char *)&quot;insufficient memory&quot;, /* Z_MEM_ERROR     (-4) */</span>
<a href="#l32.25"></a><span id="l32.25" class="difflineplus">+    (z_const char *)&quot;buffer error&quot;,        /* Z_BUF_ERROR     (-5) */</span>
<a href="#l32.26"></a><span id="l32.26" class="difflineplus">+    (z_const char *)&quot;incompatible version&quot;,/* Z_VERSION_ERROR (-6) */</span>
<a href="#l32.27"></a><span id="l32.27" class="difflineplus">+    (z_const char *)&quot;&quot;</span>
<a href="#l32.28"></a><span id="l32.28" class="difflineplus">+};</span>
<a href="#l32.29"></a><span id="l32.29" class="difflineplus">+</span>
<a href="#l32.30"></a><span id="l32.30" class="difflineplus">+</span>
<a href="#l32.31"></a><span id="l32.31" class="difflineplus">+const char * ZEXPORT zlibVersion()</span>
<a href="#l32.32"></a><span id="l32.32" class="difflineplus">+{</span>
<a href="#l32.33"></a><span id="l32.33" class="difflineplus">+    return ZLIB_VERSION;</span>
<a href="#l32.34"></a><span id="l32.34" class="difflineplus">+}</span>
<a href="#l32.35"></a><span id="l32.35" class="difflineplus">+</span>
<a href="#l32.36"></a><span id="l32.36" class="difflineplus">+uLong ZEXPORT zlibCompileFlags()</span>
<a href="#l32.37"></a><span id="l32.37" class="difflineplus">+{</span>
<a href="#l32.38"></a><span id="l32.38" class="difflineplus">+    uLong flags;</span>
<a href="#l32.39"></a><span id="l32.39" class="difflineplus">+</span>
<a href="#l32.40"></a><span id="l32.40" class="difflineplus">+    flags = 0;</span>
<a href="#l32.41"></a><span id="l32.41" class="difflineplus">+    switch ((int)(sizeof(uInt))) {</span>
<a href="#l32.42"></a><span id="l32.42" class="difflineplus">+    case 2:     break;</span>
<a href="#l32.43"></a><span id="l32.43" class="difflineplus">+    case 4:     flags += 1;     break;</span>
<a href="#l32.44"></a><span id="l32.44" class="difflineplus">+    case 8:     flags += 2;     break;</span>
<a href="#l32.45"></a><span id="l32.45" class="difflineplus">+    default:    flags += 3;</span>
<a href="#l32.46"></a><span id="l32.46" class="difflineplus">+    }</span>
<a href="#l32.47"></a><span id="l32.47" class="difflineplus">+    switch ((int)(sizeof(uLong))) {</span>
<a href="#l32.48"></a><span id="l32.48" class="difflineplus">+    case 2:     break;</span>
<a href="#l32.49"></a><span id="l32.49" class="difflineplus">+    case 4:     flags += 1 &lt;&lt; 2;        break;</span>
<a href="#l32.50"></a><span id="l32.50" class="difflineplus">+    case 8:     flags += 2 &lt;&lt; 2;        break;</span>
<a href="#l32.51"></a><span id="l32.51" class="difflineplus">+    default:    flags += 3 &lt;&lt; 2;</span>
<a href="#l32.52"></a><span id="l32.52" class="difflineplus">+    }</span>
<a href="#l32.53"></a><span id="l32.53" class="difflineplus">+    switch ((int)(sizeof(voidpf))) {</span>
<a href="#l32.54"></a><span id="l32.54" class="difflineplus">+    case 2:     break;</span>
<a href="#l32.55"></a><span id="l32.55" class="difflineplus">+    case 4:     flags += 1 &lt;&lt; 4;        break;</span>
<a href="#l32.56"></a><span id="l32.56" class="difflineplus">+    case 8:     flags += 2 &lt;&lt; 4;        break;</span>
<a href="#l32.57"></a><span id="l32.57" class="difflineplus">+    default:    flags += 3 &lt;&lt; 4;</span>
<a href="#l32.58"></a><span id="l32.58" class="difflineplus">+    }</span>
<a href="#l32.59"></a><span id="l32.59" class="difflineplus">+    switch ((int)(sizeof(z_off_t))) {</span>
<a href="#l32.60"></a><span id="l32.60" class="difflineplus">+    case 2:     break;</span>
<a href="#l32.61"></a><span id="l32.61" class="difflineplus">+    case 4:     flags += 1 &lt;&lt; 6;        break;</span>
<a href="#l32.62"></a><span id="l32.62" class="difflineplus">+    case 8:     flags += 2 &lt;&lt; 6;        break;</span>
<a href="#l32.63"></a><span id="l32.63" class="difflineplus">+    default:    flags += 3 &lt;&lt; 6;</span>
<a href="#l32.64"></a><span id="l32.64" class="difflineplus">+    }</span>
<a href="#l32.65"></a><span id="l32.65" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l32.66"></a><span id="l32.66" class="difflineplus">+    flags += 1 &lt;&lt; 8;</span>
<a href="#l32.67"></a><span id="l32.67" class="difflineplus">+#endif</span>
<a href="#l32.68"></a><span id="l32.68" class="difflineplus">+#if defined(ASMV) || defined(ASMINF)</span>
<a href="#l32.69"></a><span id="l32.69" class="difflineplus">+    flags += 1 &lt;&lt; 9;</span>
<a href="#l32.70"></a><span id="l32.70" class="difflineplus">+#endif</span>
<a href="#l32.71"></a><span id="l32.71" class="difflineplus">+#ifdef ZLIB_WINAPI</span>
<a href="#l32.72"></a><span id="l32.72" class="difflineplus">+    flags += 1 &lt;&lt; 10;</span>
<a href="#l32.73"></a><span id="l32.73" class="difflineplus">+#endif</span>
<a href="#l32.74"></a><span id="l32.74" class="difflineplus">+#ifdef BUILDFIXED</span>
<a href="#l32.75"></a><span id="l32.75" class="difflineplus">+    flags += 1 &lt;&lt; 12;</span>
<a href="#l32.76"></a><span id="l32.76" class="difflineplus">+#endif</span>
<a href="#l32.77"></a><span id="l32.77" class="difflineplus">+#ifdef DYNAMIC_CRC_TABLE</span>
<a href="#l32.78"></a><span id="l32.78" class="difflineplus">+    flags += 1 &lt;&lt; 13;</span>
<a href="#l32.79"></a><span id="l32.79" class="difflineplus">+#endif</span>
<a href="#l32.80"></a><span id="l32.80" class="difflineplus">+#ifdef NO_GZCOMPRESS</span>
<a href="#l32.81"></a><span id="l32.81" class="difflineplus">+    flags += 1L &lt;&lt; 16;</span>
<a href="#l32.82"></a><span id="l32.82" class="difflineplus">+#endif</span>
<a href="#l32.83"></a><span id="l32.83" class="difflineplus">+#ifdef NO_GZIP</span>
<a href="#l32.84"></a><span id="l32.84" class="difflineplus">+    flags += 1L &lt;&lt; 17;</span>
<a href="#l32.85"></a><span id="l32.85" class="difflineplus">+#endif</span>
<a href="#l32.86"></a><span id="l32.86" class="difflineplus">+#ifdef PKZIP_BUG_WORKAROUND</span>
<a href="#l32.87"></a><span id="l32.87" class="difflineplus">+    flags += 1L &lt;&lt; 20;</span>
<a href="#l32.88"></a><span id="l32.88" class="difflineplus">+#endif</span>
<a href="#l32.89"></a><span id="l32.89" class="difflineplus">+#ifdef FASTEST</span>
<a href="#l32.90"></a><span id="l32.90" class="difflineplus">+    flags += 1L &lt;&lt; 21;</span>
<a href="#l32.91"></a><span id="l32.91" class="difflineplus">+#endif</span>
<a href="#l32.92"></a><span id="l32.92" class="difflineplus">+#if defined(STDC) || defined(Z_HAVE_STDARG_H)</span>
<a href="#l32.93"></a><span id="l32.93" class="difflineplus">+#  ifdef NO_vsnprintf</span>
<a href="#l32.94"></a><span id="l32.94" class="difflineplus">+    flags += 1L &lt;&lt; 25;</span>
<a href="#l32.95"></a><span id="l32.95" class="difflineplus">+#    ifdef HAS_vsprintf_void</span>
<a href="#l32.96"></a><span id="l32.96" class="difflineplus">+    flags += 1L &lt;&lt; 26;</span>
<a href="#l32.97"></a><span id="l32.97" class="difflineplus">+#    endif</span>
<a href="#l32.98"></a><span id="l32.98" class="difflineplus">+#  else</span>
<a href="#l32.99"></a><span id="l32.99" class="difflineplus">+#    ifdef HAS_vsnprintf_void</span>
<a href="#l32.100"></a><span id="l32.100" class="difflineplus">+    flags += 1L &lt;&lt; 26;</span>
<a href="#l32.101"></a><span id="l32.101" class="difflineplus">+#    endif</span>
<a href="#l32.102"></a><span id="l32.102" class="difflineplus">+#  endif</span>
<a href="#l32.103"></a><span id="l32.103" class="difflineplus">+#else</span>
<a href="#l32.104"></a><span id="l32.104" class="difflineplus">+    flags += 1L &lt;&lt; 24;</span>
<a href="#l32.105"></a><span id="l32.105" class="difflineplus">+#  ifdef NO_snprintf</span>
<a href="#l32.106"></a><span id="l32.106" class="difflineplus">+    flags += 1L &lt;&lt; 25;</span>
<a href="#l32.107"></a><span id="l32.107" class="difflineplus">+#    ifdef HAS_sprintf_void</span>
<a href="#l32.108"></a><span id="l32.108" class="difflineplus">+    flags += 1L &lt;&lt; 26;</span>
<a href="#l32.109"></a><span id="l32.109" class="difflineplus">+#    endif</span>
<a href="#l32.110"></a><span id="l32.110" class="difflineplus">+#  else</span>
<a href="#l32.111"></a><span id="l32.111" class="difflineplus">+#    ifdef HAS_snprintf_void</span>
<a href="#l32.112"></a><span id="l32.112" class="difflineplus">+    flags += 1L &lt;&lt; 26;</span>
<a href="#l32.113"></a><span id="l32.113" class="difflineplus">+#    endif</span>
<a href="#l32.114"></a><span id="l32.114" class="difflineplus">+#  endif</span>
<a href="#l32.115"></a><span id="l32.115" class="difflineplus">+#endif</span>
<a href="#l32.116"></a><span id="l32.116" class="difflineplus">+    return flags;</span>
<a href="#l32.117"></a><span id="l32.117" class="difflineplus">+}</span>
<a href="#l32.118"></a><span id="l32.118" class="difflineplus">+</span>
<a href="#l32.119"></a><span id="l32.119" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l32.120"></a><span id="l32.120" class="difflineplus">+#include &lt;stdlib.h&gt;</span>
<a href="#l32.121"></a><span id="l32.121" class="difflineplus">+#  ifndef verbose</span>
<a href="#l32.122"></a><span id="l32.122" class="difflineplus">+#    define verbose 0</span>
<a href="#l32.123"></a><span id="l32.123" class="difflineplus">+#  endif</span>
<a href="#l32.124"></a><span id="l32.124" class="difflineplus">+int ZLIB_INTERNAL z_verbose = verbose;</span>
<a href="#l32.125"></a><span id="l32.125" class="difflineplus">+</span>
<a href="#l32.126"></a><span id="l32.126" class="difflineplus">+void ZLIB_INTERNAL z_error (m)</span>
<a href="#l32.127"></a><span id="l32.127" class="difflineplus">+    char *m;</span>
<a href="#l32.128"></a><span id="l32.128" class="difflineplus">+{</span>
<a href="#l32.129"></a><span id="l32.129" class="difflineplus">+    fprintf(stderr, &quot;%s\n&quot;, m);</span>
<a href="#l32.130"></a><span id="l32.130" class="difflineplus">+    exit(1);</span>
<a href="#l32.131"></a><span id="l32.131" class="difflineplus">+}</span>
<a href="#l32.132"></a><span id="l32.132" class="difflineplus">+#endif</span>
<a href="#l32.133"></a><span id="l32.133" class="difflineplus">+</span>
<a href="#l32.134"></a><span id="l32.134" class="difflineplus">+/* exported to allow conversion of error code to string for compress() and</span>
<a href="#l32.135"></a><span id="l32.135" class="difflineplus">+ * uncompress()</span>
<a href="#l32.136"></a><span id="l32.136" class="difflineplus">+ */</span>
<a href="#l32.137"></a><span id="l32.137" class="difflineplus">+const char * ZEXPORT zError(err)</span>
<a href="#l32.138"></a><span id="l32.138" class="difflineplus">+    int err;</span>
<a href="#l32.139"></a><span id="l32.139" class="difflineplus">+{</span>
<a href="#l32.140"></a><span id="l32.140" class="difflineplus">+    return ERR_MSG(err);</span>
<a href="#l32.141"></a><span id="l32.141" class="difflineplus">+}</span>
<a href="#l32.142"></a><span id="l32.142" class="difflineplus">+</span>
<a href="#l32.143"></a><span id="l32.143" class="difflineplus">+#if defined(_WIN32_WCE)</span>
<a href="#l32.144"></a><span id="l32.144" class="difflineplus">+    /* The Microsoft C Run-Time Library for Windows CE doesn't have</span>
<a href="#l32.145"></a><span id="l32.145" class="difflineplus">+     * errno.  We define it as a global variable to simplify porting.</span>
<a href="#l32.146"></a><span id="l32.146" class="difflineplus">+     * Its value is always 0 and should not be used.</span>
<a href="#l32.147"></a><span id="l32.147" class="difflineplus">+     */</span>
<a href="#l32.148"></a><span id="l32.148" class="difflineplus">+    int errno = 0;</span>
<a href="#l32.149"></a><span id="l32.149" class="difflineplus">+#endif</span>
<a href="#l32.150"></a><span id="l32.150" class="difflineplus">+</span>
<a href="#l32.151"></a><span id="l32.151" class="difflineplus">+#ifndef HAVE_MEMCPY</span>
<a href="#l32.152"></a><span id="l32.152" class="difflineplus">+</span>
<a href="#l32.153"></a><span id="l32.153" class="difflineplus">+void ZLIB_INTERNAL zmemcpy(dest, source, len)</span>
<a href="#l32.154"></a><span id="l32.154" class="difflineplus">+    Bytef* dest;</span>
<a href="#l32.155"></a><span id="l32.155" class="difflineplus">+    const Bytef* source;</span>
<a href="#l32.156"></a><span id="l32.156" class="difflineplus">+    uInt  len;</span>
<a href="#l32.157"></a><span id="l32.157" class="difflineplus">+{</span>
<a href="#l32.158"></a><span id="l32.158" class="difflineplus">+    if (len == 0) return;</span>
<a href="#l32.159"></a><span id="l32.159" class="difflineplus">+    do {</span>
<a href="#l32.160"></a><span id="l32.160" class="difflineplus">+        *dest++ = *source++; /* ??? to be unrolled */</span>
<a href="#l32.161"></a><span id="l32.161" class="difflineplus">+    } while (--len != 0);</span>
<a href="#l32.162"></a><span id="l32.162" class="difflineplus">+}</span>
<a href="#l32.163"></a><span id="l32.163" class="difflineplus">+</span>
<a href="#l32.164"></a><span id="l32.164" class="difflineplus">+int ZLIB_INTERNAL zmemcmp(s1, s2, len)</span>
<a href="#l32.165"></a><span id="l32.165" class="difflineplus">+    const Bytef* s1;</span>
<a href="#l32.166"></a><span id="l32.166" class="difflineplus">+    const Bytef* s2;</span>
<a href="#l32.167"></a><span id="l32.167" class="difflineplus">+    uInt  len;</span>
<a href="#l32.168"></a><span id="l32.168" class="difflineplus">+{</span>
<a href="#l32.169"></a><span id="l32.169" class="difflineplus">+    uInt j;</span>
<a href="#l32.170"></a><span id="l32.170" class="difflineplus">+</span>
<a href="#l32.171"></a><span id="l32.171" class="difflineplus">+    for (j = 0; j &lt; len; j++) {</span>
<a href="#l32.172"></a><span id="l32.172" class="difflineplus">+        if (s1[j] != s2[j]) return 2*(s1[j] &gt; s2[j])-1;</span>
<a href="#l32.173"></a><span id="l32.173" class="difflineplus">+    }</span>
<a href="#l32.174"></a><span id="l32.174" class="difflineplus">+    return 0;</span>
<a href="#l32.175"></a><span id="l32.175" class="difflineplus">+}</span>
<a href="#l32.176"></a><span id="l32.176" class="difflineplus">+</span>
<a href="#l32.177"></a><span id="l32.177" class="difflineplus">+void ZLIB_INTERNAL zmemzero(dest, len)</span>
<a href="#l32.178"></a><span id="l32.178" class="difflineplus">+    Bytef* dest;</span>
<a href="#l32.179"></a><span id="l32.179" class="difflineplus">+    uInt  len;</span>
<a href="#l32.180"></a><span id="l32.180" class="difflineplus">+{</span>
<a href="#l32.181"></a><span id="l32.181" class="difflineplus">+    if (len == 0) return;</span>
<a href="#l32.182"></a><span id="l32.182" class="difflineplus">+    do {</span>
<a href="#l32.183"></a><span id="l32.183" class="difflineplus">+        *dest++ = 0;  /* ??? to be unrolled */</span>
<a href="#l32.184"></a><span id="l32.184" class="difflineplus">+    } while (--len != 0);</span>
<a href="#l32.185"></a><span id="l32.185" class="difflineplus">+}</span>
<a href="#l32.186"></a><span id="l32.186" class="difflineplus">+#endif</span>
<a href="#l32.187"></a><span id="l32.187" class="difflineplus">+</span>
<a href="#l32.188"></a><span id="l32.188" class="difflineplus">+#ifndef Z_SOLO</span>
<a href="#l32.189"></a><span id="l32.189" class="difflineplus">+</span>
<a href="#l32.190"></a><span id="l32.190" class="difflineplus">+#ifdef SYS16BIT</span>
<a href="#l32.191"></a><span id="l32.191" class="difflineplus">+</span>
<a href="#l32.192"></a><span id="l32.192" class="difflineplus">+#ifdef __TURBOC__</span>
<a href="#l32.193"></a><span id="l32.193" class="difflineplus">+/* Turbo C in 16-bit mode */</span>
<a href="#l32.194"></a><span id="l32.194" class="difflineplus">+</span>
<a href="#l32.195"></a><span id="l32.195" class="difflineplus">+#  define MY_ZCALLOC</span>
<a href="#l32.196"></a><span id="l32.196" class="difflineplus">+</span>
<a href="#l32.197"></a><span id="l32.197" class="difflineplus">+/* Turbo C malloc() does not allow dynamic allocation of 64K bytes</span>
<a href="#l32.198"></a><span id="l32.198" class="difflineplus">+ * and farmalloc(64K) returns a pointer with an offset of 8, so we</span>
<a href="#l32.199"></a><span id="l32.199" class="difflineplus">+ * must fix the pointer. Warning: the pointer must be put back to its</span>
<a href="#l32.200"></a><span id="l32.200" class="difflineplus">+ * original form in order to free it, use zcfree().</span>
<a href="#l32.201"></a><span id="l32.201" class="difflineplus">+ */</span>
<a href="#l32.202"></a><span id="l32.202" class="difflineplus">+</span>
<a href="#l32.203"></a><span id="l32.203" class="difflineplus">+#define MAX_PTR 10</span>
<a href="#l32.204"></a><span id="l32.204" class="difflineplus">+/* 10*64K = 640K */</span>
<a href="#l32.205"></a><span id="l32.205" class="difflineplus">+</span>
<a href="#l32.206"></a><span id="l32.206" class="difflineplus">+local int next_ptr = 0;</span>
<a href="#l32.207"></a><span id="l32.207" class="difflineplus">+</span>
<a href="#l32.208"></a><span id="l32.208" class="difflineplus">+typedef struct ptr_table_s {</span>
<a href="#l32.209"></a><span id="l32.209" class="difflineplus">+    voidpf org_ptr;</span>
<a href="#l32.210"></a><span id="l32.210" class="difflineplus">+    voidpf new_ptr;</span>
<a href="#l32.211"></a><span id="l32.211" class="difflineplus">+} ptr_table;</span>
<a href="#l32.212"></a><span id="l32.212" class="difflineplus">+</span>
<a href="#l32.213"></a><span id="l32.213" class="difflineplus">+local ptr_table table[MAX_PTR];</span>
<a href="#l32.214"></a><span id="l32.214" class="difflineplus">+/* This table is used to remember the original form of pointers</span>
<a href="#l32.215"></a><span id="l32.215" class="difflineplus">+ * to large buffers (64K). Such pointers are normalized with a zero offset.</span>
<a href="#l32.216"></a><span id="l32.216" class="difflineplus">+ * Since MSDOS is not a preemptive multitasking OS, this table is not</span>
<a href="#l32.217"></a><span id="l32.217" class="difflineplus">+ * protected from concurrent access. This hack doesn't work anyway on</span>
<a href="#l32.218"></a><span id="l32.218" class="difflineplus">+ * a protected system like OS/2. Use Microsoft C instead.</span>
<a href="#l32.219"></a><span id="l32.219" class="difflineplus">+ */</span>
<a href="#l32.220"></a><span id="l32.220" class="difflineplus">+</span>
<a href="#l32.221"></a><span id="l32.221" class="difflineplus">+voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)</span>
<a href="#l32.222"></a><span id="l32.222" class="difflineplus">+{</span>
<a href="#l32.223"></a><span id="l32.223" class="difflineplus">+    voidpf buf;</span>
<a href="#l32.224"></a><span id="l32.224" class="difflineplus">+    ulg bsize = (ulg)items*size;</span>
<a href="#l32.225"></a><span id="l32.225" class="difflineplus">+</span>
<a href="#l32.226"></a><span id="l32.226" class="difflineplus">+    (void)opaque;</span>
<a href="#l32.227"></a><span id="l32.227" class="difflineplus">+</span>
<a href="#l32.228"></a><span id="l32.228" class="difflineplus">+    /* If we allocate less than 65520 bytes, we assume that farmalloc</span>
<a href="#l32.229"></a><span id="l32.229" class="difflineplus">+     * will return a usable pointer which doesn't have to be normalized.</span>
<a href="#l32.230"></a><span id="l32.230" class="difflineplus">+     */</span>
<a href="#l32.231"></a><span id="l32.231" class="difflineplus">+    if (bsize &lt; 65520L) {</span>
<a href="#l32.232"></a><span id="l32.232" class="difflineplus">+        buf = farmalloc(bsize);</span>
<a href="#l32.233"></a><span id="l32.233" class="difflineplus">+        if (*(ush*)&amp;buf != 0) return buf;</span>
<a href="#l32.234"></a><span id="l32.234" class="difflineplus">+    } else {</span>
<a href="#l32.235"></a><span id="l32.235" class="difflineplus">+        buf = farmalloc(bsize + 16L);</span>
<a href="#l32.236"></a><span id="l32.236" class="difflineplus">+    }</span>
<a href="#l32.237"></a><span id="l32.237" class="difflineplus">+    if (buf == NULL || next_ptr &gt;= MAX_PTR) return NULL;</span>
<a href="#l32.238"></a><span id="l32.238" class="difflineplus">+    table[next_ptr].org_ptr = buf;</span>
<a href="#l32.239"></a><span id="l32.239" class="difflineplus">+</span>
<a href="#l32.240"></a><span id="l32.240" class="difflineplus">+    /* Normalize the pointer to seg:0 */</span>
<a href="#l32.241"></a><span id="l32.241" class="difflineplus">+    *((ush*)&amp;buf+1) += ((ush)((uch*)buf-0) + 15) &gt;&gt; 4;</span>
<a href="#l32.242"></a><span id="l32.242" class="difflineplus">+    *(ush*)&amp;buf = 0;</span>
<a href="#l32.243"></a><span id="l32.243" class="difflineplus">+    table[next_ptr++].new_ptr = buf;</span>
<a href="#l32.244"></a><span id="l32.244" class="difflineplus">+    return buf;</span>
<a href="#l32.245"></a><span id="l32.245" class="difflineplus">+}</span>
<a href="#l32.246"></a><span id="l32.246" class="difflineplus">+</span>
<a href="#l32.247"></a><span id="l32.247" class="difflineplus">+void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)</span>
<a href="#l32.248"></a><span id="l32.248" class="difflineplus">+{</span>
<a href="#l32.249"></a><span id="l32.249" class="difflineplus">+    int n;</span>
<a href="#l32.250"></a><span id="l32.250" class="difflineplus">+</span>
<a href="#l32.251"></a><span id="l32.251" class="difflineplus">+    (void)opaque;</span>
<a href="#l32.252"></a><span id="l32.252" class="difflineplus">+</span>
<a href="#l32.253"></a><span id="l32.253" class="difflineplus">+    if (*(ush*)&amp;ptr != 0) { /* object &lt; 64K */</span>
<a href="#l32.254"></a><span id="l32.254" class="difflineplus">+        farfree(ptr);</span>
<a href="#l32.255"></a><span id="l32.255" class="difflineplus">+        return;</span>
<a href="#l32.256"></a><span id="l32.256" class="difflineplus">+    }</span>
<a href="#l32.257"></a><span id="l32.257" class="difflineplus">+    /* Find the original pointer */</span>
<a href="#l32.258"></a><span id="l32.258" class="difflineplus">+    for (n = 0; n &lt; next_ptr; n++) {</span>
<a href="#l32.259"></a><span id="l32.259" class="difflineplus">+        if (ptr != table[n].new_ptr) continue;</span>
<a href="#l32.260"></a><span id="l32.260" class="difflineplus">+</span>
<a href="#l32.261"></a><span id="l32.261" class="difflineplus">+        farfree(table[n].org_ptr);</span>
<a href="#l32.262"></a><span id="l32.262" class="difflineplus">+        while (++n &lt; next_ptr) {</span>
<a href="#l32.263"></a><span id="l32.263" class="difflineplus">+            table[n-1] = table[n];</span>
<a href="#l32.264"></a><span id="l32.264" class="difflineplus">+        }</span>
<a href="#l32.265"></a><span id="l32.265" class="difflineplus">+        next_ptr--;</span>
<a href="#l32.266"></a><span id="l32.266" class="difflineplus">+        return;</span>
<a href="#l32.267"></a><span id="l32.267" class="difflineplus">+    }</span>
<a href="#l32.268"></a><span id="l32.268" class="difflineplus">+    Assert(0, &quot;zcfree: ptr not found&quot;);</span>
<a href="#l32.269"></a><span id="l32.269" class="difflineplus">+}</span>
<a href="#l32.270"></a><span id="l32.270" class="difflineplus">+</span>
<a href="#l32.271"></a><span id="l32.271" class="difflineplus">+#endif /* __TURBOC__ */</span>
<a href="#l32.272"></a><span id="l32.272" class="difflineplus">+</span>
<a href="#l32.273"></a><span id="l32.273" class="difflineplus">+</span>
<a href="#l32.274"></a><span id="l32.274" class="difflineplus">+#ifdef M_I86</span>
<a href="#l32.275"></a><span id="l32.275" class="difflineplus">+/* Microsoft C in 16-bit mode */</span>
<a href="#l32.276"></a><span id="l32.276" class="difflineplus">+</span>
<a href="#l32.277"></a><span id="l32.277" class="difflineplus">+#  define MY_ZCALLOC</span>
<a href="#l32.278"></a><span id="l32.278" class="difflineplus">+</span>
<a href="#l32.279"></a><span id="l32.279" class="difflineplus">+#if (!defined(_MSC_VER) || (_MSC_VER &lt;= 600))</span>
<a href="#l32.280"></a><span id="l32.280" class="difflineplus">+#  define _halloc  halloc</span>
<a href="#l32.281"></a><span id="l32.281" class="difflineplus">+#  define _hfree   hfree</span>
<a href="#l32.282"></a><span id="l32.282" class="difflineplus">+#endif</span>
<a href="#l32.283"></a><span id="l32.283" class="difflineplus">+</span>
<a href="#l32.284"></a><span id="l32.284" class="difflineplus">+voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)</span>
<a href="#l32.285"></a><span id="l32.285" class="difflineplus">+{</span>
<a href="#l32.286"></a><span id="l32.286" class="difflineplus">+    (void)opaque;</span>
<a href="#l32.287"></a><span id="l32.287" class="difflineplus">+    return _halloc((long)items, size);</span>
<a href="#l32.288"></a><span id="l32.288" class="difflineplus">+}</span>
<a href="#l32.289"></a><span id="l32.289" class="difflineplus">+</span>
<a href="#l32.290"></a><span id="l32.290" class="difflineplus">+void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)</span>
<a href="#l32.291"></a><span id="l32.291" class="difflineplus">+{</span>
<a href="#l32.292"></a><span id="l32.292" class="difflineplus">+    (void)opaque;</span>
<a href="#l32.293"></a><span id="l32.293" class="difflineplus">+    _hfree(ptr);</span>
<a href="#l32.294"></a><span id="l32.294" class="difflineplus">+}</span>
<a href="#l32.295"></a><span id="l32.295" class="difflineplus">+</span>
<a href="#l32.296"></a><span id="l32.296" class="difflineplus">+#endif /* M_I86 */</span>
<a href="#l32.297"></a><span id="l32.297" class="difflineplus">+</span>
<a href="#l32.298"></a><span id="l32.298" class="difflineplus">+#endif /* SYS16BIT */</span>
<a href="#l32.299"></a><span id="l32.299" class="difflineplus">+</span>
<a href="#l32.300"></a><span id="l32.300" class="difflineplus">+</span>
<a href="#l32.301"></a><span id="l32.301" class="difflineplus">+#ifndef MY_ZCALLOC /* Any system without a special alloc function */</span>
<a href="#l32.302"></a><span id="l32.302" class="difflineplus">+</span>
<a href="#l32.303"></a><span id="l32.303" class="difflineplus">+#ifndef STDC</span>
<a href="#l32.304"></a><span id="l32.304" class="difflineplus">+extern voidp  malloc OF((uInt size));</span>
<a href="#l32.305"></a><span id="l32.305" class="difflineplus">+extern voidp  calloc OF((uInt items, uInt size));</span>
<a href="#l32.306"></a><span id="l32.306" class="difflineplus">+extern void   free   OF((voidpf ptr));</span>
<a href="#l32.307"></a><span id="l32.307" class="difflineplus">+#endif</span>
<a href="#l32.308"></a><span id="l32.308" class="difflineplus">+</span>
<a href="#l32.309"></a><span id="l32.309" class="difflineplus">+voidpf ZLIB_INTERNAL zcalloc (opaque, items, size)</span>
<a href="#l32.310"></a><span id="l32.310" class="difflineplus">+    voidpf opaque;</span>
<a href="#l32.311"></a><span id="l32.311" class="difflineplus">+    unsigned items;</span>
<a href="#l32.312"></a><span id="l32.312" class="difflineplus">+    unsigned size;</span>
<a href="#l32.313"></a><span id="l32.313" class="difflineplus">+{</span>
<a href="#l32.314"></a><span id="l32.314" class="difflineplus">+    (void)opaque;</span>
<a href="#l32.315"></a><span id="l32.315" class="difflineplus">+    return sizeof(uInt) &gt; 2 ? (voidpf)malloc(items * size) :</span>
<a href="#l32.316"></a><span id="l32.316" class="difflineplus">+                              (voidpf)calloc(items, size);</span>
<a href="#l32.317"></a><span id="l32.317" class="difflineplus">+}</span>
<a href="#l32.318"></a><span id="l32.318" class="difflineplus">+</span>
<a href="#l32.319"></a><span id="l32.319" class="difflineplus">+void ZLIB_INTERNAL zcfree (opaque, ptr)</span>
<a href="#l32.320"></a><span id="l32.320" class="difflineplus">+    voidpf opaque;</span>
<a href="#l32.321"></a><span id="l32.321" class="difflineplus">+    voidpf ptr;</span>
<a href="#l32.322"></a><span id="l32.322" class="difflineplus">+{</span>
<a href="#l32.323"></a><span id="l32.323" class="difflineplus">+    (void)opaque;</span>
<a href="#l32.324"></a><span id="l32.324" class="difflineplus">+    free(ptr);</span>
<a href="#l32.325"></a><span id="l32.325" class="difflineplus">+}</span>
<a href="#l32.326"></a><span id="l32.326" class="difflineplus">+</span>
<a href="#l32.327"></a><span id="l32.327" class="difflineplus">+#endif /* MY_ZCALLOC */</span>
<a href="#l32.328"></a><span id="l32.328" class="difflineplus">+</span>
<a href="#l32.329"></a><span id="l32.329" class="difflineplus">+#endif /* !Z_SOLO */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l33.1"></a><span id="l33.1">new file mode 100644</span>
<a href="#l33.2"></a><span id="l33.2" class="difflineminus">--- /dev/null</span>
<a href="#l33.3"></a><span id="l33.3" class="difflineplus">+++ b/third_party/zlib/zutil.h</span>
<a href="#l33.4"></a><span id="l33.4" class="difflineat">@@ -0,0 +1,271 @@</span>
<a href="#l33.5"></a><span id="l33.5" class="difflineplus">+/* zutil.h -- internal interface and configuration of the compression library</span>
<a href="#l33.6"></a><span id="l33.6" class="difflineplus">+ * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler</span>
<a href="#l33.7"></a><span id="l33.7" class="difflineplus">+ * For conditions of distribution and use, see copyright notice in zlib.h</span>
<a href="#l33.8"></a><span id="l33.8" class="difflineplus">+ */</span>
<a href="#l33.9"></a><span id="l33.9" class="difflineplus">+</span>
<a href="#l33.10"></a><span id="l33.10" class="difflineplus">+/* WARNING: this file should *not* be used by applications. It is</span>
<a href="#l33.11"></a><span id="l33.11" class="difflineplus">+   part of the implementation of the compression library and is</span>
<a href="#l33.12"></a><span id="l33.12" class="difflineplus">+   subject to change. Applications should only use zlib.h.</span>
<a href="#l33.13"></a><span id="l33.13" class="difflineplus">+ */</span>
<a href="#l33.14"></a><span id="l33.14" class="difflineplus">+</span>
<a href="#l33.15"></a><span id="l33.15" class="difflineplus">+/* @(#) $Id$ */</span>
<a href="#l33.16"></a><span id="l33.16" class="difflineplus">+</span>
<a href="#l33.17"></a><span id="l33.17" class="difflineplus">+#ifndef ZUTIL_H</span>
<a href="#l33.18"></a><span id="l33.18" class="difflineplus">+#define ZUTIL_H</span>
<a href="#l33.19"></a><span id="l33.19" class="difflineplus">+</span>
<a href="#l33.20"></a><span id="l33.20" class="difflineplus">+#ifdef HAVE_HIDDEN</span>
<a href="#l33.21"></a><span id="l33.21" class="difflineplus">+#  define ZLIB_INTERNAL __attribute__((visibility (&quot;hidden&quot;)))</span>
<a href="#l33.22"></a><span id="l33.22" class="difflineplus">+#else</span>
<a href="#l33.23"></a><span id="l33.23" class="difflineplus">+#  define ZLIB_INTERNAL</span>
<a href="#l33.24"></a><span id="l33.24" class="difflineplus">+#endif</span>
<a href="#l33.25"></a><span id="l33.25" class="difflineplus">+</span>
<a href="#l33.26"></a><span id="l33.26" class="difflineplus">+#include &quot;zlib.h&quot;</span>
<a href="#l33.27"></a><span id="l33.27" class="difflineplus">+</span>
<a href="#l33.28"></a><span id="l33.28" class="difflineplus">+#if defined(STDC) &amp;&amp; !defined(Z_SOLO)</span>
<a href="#l33.29"></a><span id="l33.29" class="difflineplus">+#  if !(defined(_WIN32_WCE) &amp;&amp; defined(_MSC_VER))</span>
<a href="#l33.30"></a><span id="l33.30" class="difflineplus">+#    include &lt;stddef.h&gt;</span>
<a href="#l33.31"></a><span id="l33.31" class="difflineplus">+#  endif</span>
<a href="#l33.32"></a><span id="l33.32" class="difflineplus">+#  include &lt;string.h&gt;</span>
<a href="#l33.33"></a><span id="l33.33" class="difflineplus">+#  include &lt;stdlib.h&gt;</span>
<a href="#l33.34"></a><span id="l33.34" class="difflineplus">+#endif</span>
<a href="#l33.35"></a><span id="l33.35" class="difflineplus">+</span>
<a href="#l33.36"></a><span id="l33.36" class="difflineplus">+#ifdef Z_SOLO</span>
<a href="#l33.37"></a><span id="l33.37" class="difflineplus">+   typedef long ptrdiff_t;  /* guess -- will be caught if guess is wrong */</span>
<a href="#l33.38"></a><span id="l33.38" class="difflineplus">+#endif</span>
<a href="#l33.39"></a><span id="l33.39" class="difflineplus">+</span>
<a href="#l33.40"></a><span id="l33.40" class="difflineplus">+#ifndef local</span>
<a href="#l33.41"></a><span id="l33.41" class="difflineplus">+#  define local static</span>
<a href="#l33.42"></a><span id="l33.42" class="difflineplus">+#endif</span>
<a href="#l33.43"></a><span id="l33.43" class="difflineplus">+/* since &quot;static&quot; is used to mean two completely different things in C, we</span>
<a href="#l33.44"></a><span id="l33.44" class="difflineplus">+   define &quot;local&quot; for the non-static meaning of &quot;static&quot;, for readability</span>
<a href="#l33.45"></a><span id="l33.45" class="difflineplus">+   (compile with -Dlocal if your debugger can't find static symbols) */</span>
<a href="#l33.46"></a><span id="l33.46" class="difflineplus">+</span>
<a href="#l33.47"></a><span id="l33.47" class="difflineplus">+typedef unsigned char  uch;</span>
<a href="#l33.48"></a><span id="l33.48" class="difflineplus">+typedef uch FAR uchf;</span>
<a href="#l33.49"></a><span id="l33.49" class="difflineplus">+typedef unsigned short ush;</span>
<a href="#l33.50"></a><span id="l33.50" class="difflineplus">+typedef ush FAR ushf;</span>
<a href="#l33.51"></a><span id="l33.51" class="difflineplus">+typedef unsigned long  ulg;</span>
<a href="#l33.52"></a><span id="l33.52" class="difflineplus">+</span>
<a href="#l33.53"></a><span id="l33.53" class="difflineplus">+extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */</span>
<a href="#l33.54"></a><span id="l33.54" class="difflineplus">+/* (size given to avoid silly warnings with Visual C++) */</span>
<a href="#l33.55"></a><span id="l33.55" class="difflineplus">+</span>
<a href="#l33.56"></a><span id="l33.56" class="difflineplus">+#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]</span>
<a href="#l33.57"></a><span id="l33.57" class="difflineplus">+</span>
<a href="#l33.58"></a><span id="l33.58" class="difflineplus">+#define ERR_RETURN(strm,err) \</span>
<a href="#l33.59"></a><span id="l33.59" class="difflineplus">+  return (strm-&gt;msg = ERR_MSG(err), (err))</span>
<a href="#l33.60"></a><span id="l33.60" class="difflineplus">+/* To be used only when the state is known to be valid */</span>
<a href="#l33.61"></a><span id="l33.61" class="difflineplus">+</span>
<a href="#l33.62"></a><span id="l33.62" class="difflineplus">+        /* common constants */</span>
<a href="#l33.63"></a><span id="l33.63" class="difflineplus">+</span>
<a href="#l33.64"></a><span id="l33.64" class="difflineplus">+#ifndef DEF_WBITS</span>
<a href="#l33.65"></a><span id="l33.65" class="difflineplus">+#  define DEF_WBITS MAX_WBITS</span>
<a href="#l33.66"></a><span id="l33.66" class="difflineplus">+#endif</span>
<a href="#l33.67"></a><span id="l33.67" class="difflineplus">+/* default windowBits for decompression. MAX_WBITS is for compression only */</span>
<a href="#l33.68"></a><span id="l33.68" class="difflineplus">+</span>
<a href="#l33.69"></a><span id="l33.69" class="difflineplus">+#if MAX_MEM_LEVEL &gt;= 8</span>
<a href="#l33.70"></a><span id="l33.70" class="difflineplus">+#  define DEF_MEM_LEVEL 8</span>
<a href="#l33.71"></a><span id="l33.71" class="difflineplus">+#else</span>
<a href="#l33.72"></a><span id="l33.72" class="difflineplus">+#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL</span>
<a href="#l33.73"></a><span id="l33.73" class="difflineplus">+#endif</span>
<a href="#l33.74"></a><span id="l33.74" class="difflineplus">+/* default memLevel */</span>
<a href="#l33.75"></a><span id="l33.75" class="difflineplus">+</span>
<a href="#l33.76"></a><span id="l33.76" class="difflineplus">+#define STORED_BLOCK 0</span>
<a href="#l33.77"></a><span id="l33.77" class="difflineplus">+#define STATIC_TREES 1</span>
<a href="#l33.78"></a><span id="l33.78" class="difflineplus">+#define DYN_TREES    2</span>
<a href="#l33.79"></a><span id="l33.79" class="difflineplus">+/* The three kinds of block type */</span>
<a href="#l33.80"></a><span id="l33.80" class="difflineplus">+</span>
<a href="#l33.81"></a><span id="l33.81" class="difflineplus">+#define MIN_MATCH  3</span>
<a href="#l33.82"></a><span id="l33.82" class="difflineplus">+#define MAX_MATCH  258</span>
<a href="#l33.83"></a><span id="l33.83" class="difflineplus">+/* The minimum and maximum match lengths */</span>
<a href="#l33.84"></a><span id="l33.84" class="difflineplus">+</span>
<a href="#l33.85"></a><span id="l33.85" class="difflineplus">+#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */</span>
<a href="#l33.86"></a><span id="l33.86" class="difflineplus">+</span>
<a href="#l33.87"></a><span id="l33.87" class="difflineplus">+        /* target dependencies */</span>
<a href="#l33.88"></a><span id="l33.88" class="difflineplus">+</span>
<a href="#l33.89"></a><span id="l33.89" class="difflineplus">+#if defined(MSDOS) || (defined(WINDOWS) &amp;&amp; !defined(WIN32))</span>
<a href="#l33.90"></a><span id="l33.90" class="difflineplus">+#  define OS_CODE  0x00</span>
<a href="#l33.91"></a><span id="l33.91" class="difflineplus">+#  ifndef Z_SOLO</span>
<a href="#l33.92"></a><span id="l33.92" class="difflineplus">+#    if defined(__TURBOC__) || defined(__BORLANDC__)</span>
<a href="#l33.93"></a><span id="l33.93" class="difflineplus">+#      if (__STDC__ == 1) &amp;&amp; (defined(__LARGE__) || defined(__COMPACT__))</span>
<a href="#l33.94"></a><span id="l33.94" class="difflineplus">+         /* Allow compilation with ANSI keywords only enabled */</span>
<a href="#l33.95"></a><span id="l33.95" class="difflineplus">+         void _Cdecl farfree( void *block );</span>
<a href="#l33.96"></a><span id="l33.96" class="difflineplus">+         void *_Cdecl farmalloc( unsigned long nbytes );</span>
<a href="#l33.97"></a><span id="l33.97" class="difflineplus">+#      else</span>
<a href="#l33.98"></a><span id="l33.98" class="difflineplus">+#        include &lt;alloc.h&gt;</span>
<a href="#l33.99"></a><span id="l33.99" class="difflineplus">+#      endif</span>
<a href="#l33.100"></a><span id="l33.100" class="difflineplus">+#    else /* MSC or DJGPP */</span>
<a href="#l33.101"></a><span id="l33.101" class="difflineplus">+#      include &lt;malloc.h&gt;</span>
<a href="#l33.102"></a><span id="l33.102" class="difflineplus">+#    endif</span>
<a href="#l33.103"></a><span id="l33.103" class="difflineplus">+#  endif</span>
<a href="#l33.104"></a><span id="l33.104" class="difflineplus">+#endif</span>
<a href="#l33.105"></a><span id="l33.105" class="difflineplus">+</span>
<a href="#l33.106"></a><span id="l33.106" class="difflineplus">+#ifdef AMIGA</span>
<a href="#l33.107"></a><span id="l33.107" class="difflineplus">+#  define OS_CODE  1</span>
<a href="#l33.108"></a><span id="l33.108" class="difflineplus">+#endif</span>
<a href="#l33.109"></a><span id="l33.109" class="difflineplus">+</span>
<a href="#l33.110"></a><span id="l33.110" class="difflineplus">+#if defined(VAXC) || defined(VMS)</span>
<a href="#l33.111"></a><span id="l33.111" class="difflineplus">+#  define OS_CODE  2</span>
<a href="#l33.112"></a><span id="l33.112" class="difflineplus">+#  define F_OPEN(name, mode) \</span>
<a href="#l33.113"></a><span id="l33.113" class="difflineplus">+     fopen((name), (mode), &quot;mbc=60&quot;, &quot;ctx=stm&quot;, &quot;rfm=fix&quot;, &quot;mrs=512&quot;)</span>
<a href="#l33.114"></a><span id="l33.114" class="difflineplus">+#endif</span>
<a href="#l33.115"></a><span id="l33.115" class="difflineplus">+</span>
<a href="#l33.116"></a><span id="l33.116" class="difflineplus">+#ifdef __370__</span>
<a href="#l33.117"></a><span id="l33.117" class="difflineplus">+#  if __TARGET_LIB__ &lt; 0x20000000</span>
<a href="#l33.118"></a><span id="l33.118" class="difflineplus">+#    define OS_CODE 4</span>
<a href="#l33.119"></a><span id="l33.119" class="difflineplus">+#  elif __TARGET_LIB__ &lt; 0x40000000</span>
<a href="#l33.120"></a><span id="l33.120" class="difflineplus">+#    define OS_CODE 11</span>
<a href="#l33.121"></a><span id="l33.121" class="difflineplus">+#  else</span>
<a href="#l33.122"></a><span id="l33.122" class="difflineplus">+#    define OS_CODE 8</span>
<a href="#l33.123"></a><span id="l33.123" class="difflineplus">+#  endif</span>
<a href="#l33.124"></a><span id="l33.124" class="difflineplus">+#endif</span>
<a href="#l33.125"></a><span id="l33.125" class="difflineplus">+</span>
<a href="#l33.126"></a><span id="l33.126" class="difflineplus">+#if defined(ATARI) || defined(atarist)</span>
<a href="#l33.127"></a><span id="l33.127" class="difflineplus">+#  define OS_CODE  5</span>
<a href="#l33.128"></a><span id="l33.128" class="difflineplus">+#endif</span>
<a href="#l33.129"></a><span id="l33.129" class="difflineplus">+</span>
<a href="#l33.130"></a><span id="l33.130" class="difflineplus">+#ifdef OS2</span>
<a href="#l33.131"></a><span id="l33.131" class="difflineplus">+#  define OS_CODE  6</span>
<a href="#l33.132"></a><span id="l33.132" class="difflineplus">+#  if defined(M_I86) &amp;&amp; !defined(Z_SOLO)</span>
<a href="#l33.133"></a><span id="l33.133" class="difflineplus">+#    include &lt;malloc.h&gt;</span>
<a href="#l33.134"></a><span id="l33.134" class="difflineplus">+#  endif</span>
<a href="#l33.135"></a><span id="l33.135" class="difflineplus">+#endif</span>
<a href="#l33.136"></a><span id="l33.136" class="difflineplus">+</span>
<a href="#l33.137"></a><span id="l33.137" class="difflineplus">+#if defined(MACOS) || defined(TARGET_OS_MAC)</span>
<a href="#l33.138"></a><span id="l33.138" class="difflineplus">+#  define OS_CODE  7</span>
<a href="#l33.139"></a><span id="l33.139" class="difflineplus">+#  ifndef Z_SOLO</span>
<a href="#l33.140"></a><span id="l33.140" class="difflineplus">+#    if defined(__MWERKS__) &amp;&amp; __dest_os != __be_os &amp;&amp; __dest_os != __win32_os</span>
<a href="#l33.141"></a><span id="l33.141" class="difflineplus">+#      include &lt;unix.h&gt; /* for fdopen */</span>
<a href="#l33.142"></a><span id="l33.142" class="difflineplus">+#    else</span>
<a href="#l33.143"></a><span id="l33.143" class="difflineplus">+#      ifndef fdopen</span>
<a href="#l33.144"></a><span id="l33.144" class="difflineplus">+#        define fdopen(fd,mode) NULL /* No fdopen() */</span>
<a href="#l33.145"></a><span id="l33.145" class="difflineplus">+#      endif</span>
<a href="#l33.146"></a><span id="l33.146" class="difflineplus">+#    endif</span>
<a href="#l33.147"></a><span id="l33.147" class="difflineplus">+#  endif</span>
<a href="#l33.148"></a><span id="l33.148" class="difflineplus">+#endif</span>
<a href="#l33.149"></a><span id="l33.149" class="difflineplus">+</span>
<a href="#l33.150"></a><span id="l33.150" class="difflineplus">+#ifdef __acorn</span>
<a href="#l33.151"></a><span id="l33.151" class="difflineplus">+#  define OS_CODE 13</span>
<a href="#l33.152"></a><span id="l33.152" class="difflineplus">+#endif</span>
<a href="#l33.153"></a><span id="l33.153" class="difflineplus">+</span>
<a href="#l33.154"></a><span id="l33.154" class="difflineplus">+#if defined(WIN32) &amp;&amp; !defined(__CYGWIN__)</span>
<a href="#l33.155"></a><span id="l33.155" class="difflineplus">+#  define OS_CODE  10</span>
<a href="#l33.156"></a><span id="l33.156" class="difflineplus">+#endif</span>
<a href="#l33.157"></a><span id="l33.157" class="difflineplus">+</span>
<a href="#l33.158"></a><span id="l33.158" class="difflineplus">+#ifdef _BEOS_</span>
<a href="#l33.159"></a><span id="l33.159" class="difflineplus">+#  define OS_CODE  16</span>
<a href="#l33.160"></a><span id="l33.160" class="difflineplus">+#endif</span>
<a href="#l33.161"></a><span id="l33.161" class="difflineplus">+</span>
<a href="#l33.162"></a><span id="l33.162" class="difflineplus">+#ifdef __TOS_OS400__</span>
<a href="#l33.163"></a><span id="l33.163" class="difflineplus">+#  define OS_CODE 18</span>
<a href="#l33.164"></a><span id="l33.164" class="difflineplus">+#endif</span>
<a href="#l33.165"></a><span id="l33.165" class="difflineplus">+</span>
<a href="#l33.166"></a><span id="l33.166" class="difflineplus">+#ifdef __APPLE__</span>
<a href="#l33.167"></a><span id="l33.167" class="difflineplus">+#  define OS_CODE 19</span>
<a href="#l33.168"></a><span id="l33.168" class="difflineplus">+#endif</span>
<a href="#l33.169"></a><span id="l33.169" class="difflineplus">+</span>
<a href="#l33.170"></a><span id="l33.170" class="difflineplus">+#if defined(_BEOS_) || defined(RISCOS)</span>
<a href="#l33.171"></a><span id="l33.171" class="difflineplus">+#  define fdopen(fd,mode) NULL /* No fdopen() */</span>
<a href="#l33.172"></a><span id="l33.172" class="difflineplus">+#endif</span>
<a href="#l33.173"></a><span id="l33.173" class="difflineplus">+</span>
<a href="#l33.174"></a><span id="l33.174" class="difflineplus">+#if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt; 600)) &amp;&amp; !defined __INTERIX</span>
<a href="#l33.175"></a><span id="l33.175" class="difflineplus">+#  if defined(_WIN32_WCE)</span>
<a href="#l33.176"></a><span id="l33.176" class="difflineplus">+#    define fdopen(fd,mode) NULL /* No fdopen() */</span>
<a href="#l33.177"></a><span id="l33.177" class="difflineplus">+#    ifndef _PTRDIFF_T_DEFINED</span>
<a href="#l33.178"></a><span id="l33.178" class="difflineplus">+       typedef int ptrdiff_t;</span>
<a href="#l33.179"></a><span id="l33.179" class="difflineplus">+#      define _PTRDIFF_T_DEFINED</span>
<a href="#l33.180"></a><span id="l33.180" class="difflineplus">+#    endif</span>
<a href="#l33.181"></a><span id="l33.181" class="difflineplus">+#  else</span>
<a href="#l33.182"></a><span id="l33.182" class="difflineplus">+#    define fdopen(fd,type)  _fdopen(fd,type)</span>
<a href="#l33.183"></a><span id="l33.183" class="difflineplus">+#  endif</span>
<a href="#l33.184"></a><span id="l33.184" class="difflineplus">+#endif</span>
<a href="#l33.185"></a><span id="l33.185" class="difflineplus">+</span>
<a href="#l33.186"></a><span id="l33.186" class="difflineplus">+#if defined(__BORLANDC__) &amp;&amp; !defined(MSDOS)</span>
<a href="#l33.187"></a><span id="l33.187" class="difflineplus">+  #pragma warn -8004</span>
<a href="#l33.188"></a><span id="l33.188" class="difflineplus">+  #pragma warn -8008</span>
<a href="#l33.189"></a><span id="l33.189" class="difflineplus">+  #pragma warn -8066</span>
<a href="#l33.190"></a><span id="l33.190" class="difflineplus">+#endif</span>
<a href="#l33.191"></a><span id="l33.191" class="difflineplus">+</span>
<a href="#l33.192"></a><span id="l33.192" class="difflineplus">+/* provide prototypes for these when building zlib without LFS */</span>
<a href="#l33.193"></a><span id="l33.193" class="difflineplus">+#if !defined(_WIN32) &amp;&amp; \</span>
<a href="#l33.194"></a><span id="l33.194" class="difflineplus">+    (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)</span>
<a href="#l33.195"></a><span id="l33.195" class="difflineplus">+    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));</span>
<a href="#l33.196"></a><span id="l33.196" class="difflineplus">+    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));</span>
<a href="#l33.197"></a><span id="l33.197" class="difflineplus">+#endif</span>
<a href="#l33.198"></a><span id="l33.198" class="difflineplus">+</span>
<a href="#l33.199"></a><span id="l33.199" class="difflineplus">+        /* common defaults */</span>
<a href="#l33.200"></a><span id="l33.200" class="difflineplus">+</span>
<a href="#l33.201"></a><span id="l33.201" class="difflineplus">+#ifndef OS_CODE</span>
<a href="#l33.202"></a><span id="l33.202" class="difflineplus">+#  define OS_CODE  3     /* assume Unix */</span>
<a href="#l33.203"></a><span id="l33.203" class="difflineplus">+#endif</span>
<a href="#l33.204"></a><span id="l33.204" class="difflineplus">+</span>
<a href="#l33.205"></a><span id="l33.205" class="difflineplus">+#ifndef F_OPEN</span>
<a href="#l33.206"></a><span id="l33.206" class="difflineplus">+#  define F_OPEN(name, mode) fopen((name), (mode))</span>
<a href="#l33.207"></a><span id="l33.207" class="difflineplus">+#endif</span>
<a href="#l33.208"></a><span id="l33.208" class="difflineplus">+</span>
<a href="#l33.209"></a><span id="l33.209" class="difflineplus">+         /* functions */</span>
<a href="#l33.210"></a><span id="l33.210" class="difflineplus">+</span>
<a href="#l33.211"></a><span id="l33.211" class="difflineplus">+#if defined(pyr) || defined(Z_SOLO)</span>
<a href="#l33.212"></a><span id="l33.212" class="difflineplus">+#  define NO_MEMCPY</span>
<a href="#l33.213"></a><span id="l33.213" class="difflineplus">+#endif</span>
<a href="#l33.214"></a><span id="l33.214" class="difflineplus">+#if defined(SMALL_MEDIUM) &amp;&amp; !defined(_MSC_VER) &amp;&amp; !defined(__SC__)</span>
<a href="#l33.215"></a><span id="l33.215" class="difflineplus">+ /* Use our own functions for small and medium model with MSC &lt;= 5.0.</span>
<a href="#l33.216"></a><span id="l33.216" class="difflineplus">+  * You may have to use the same strategy for Borland C (untested).</span>
<a href="#l33.217"></a><span id="l33.217" class="difflineplus">+  * The __SC__ check is for Symantec.</span>
<a href="#l33.218"></a><span id="l33.218" class="difflineplus">+  */</span>
<a href="#l33.219"></a><span id="l33.219" class="difflineplus">+#  define NO_MEMCPY</span>
<a href="#l33.220"></a><span id="l33.220" class="difflineplus">+#endif</span>
<a href="#l33.221"></a><span id="l33.221" class="difflineplus">+#if defined(STDC) &amp;&amp; !defined(HAVE_MEMCPY) &amp;&amp; !defined(NO_MEMCPY)</span>
<a href="#l33.222"></a><span id="l33.222" class="difflineplus">+#  define HAVE_MEMCPY</span>
<a href="#l33.223"></a><span id="l33.223" class="difflineplus">+#endif</span>
<a href="#l33.224"></a><span id="l33.224" class="difflineplus">+#ifdef HAVE_MEMCPY</span>
<a href="#l33.225"></a><span id="l33.225" class="difflineplus">+#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */</span>
<a href="#l33.226"></a><span id="l33.226" class="difflineplus">+#    define zmemcpy _fmemcpy</span>
<a href="#l33.227"></a><span id="l33.227" class="difflineplus">+#    define zmemcmp _fmemcmp</span>
<a href="#l33.228"></a><span id="l33.228" class="difflineplus">+#    define zmemzero(dest, len) _fmemset(dest, 0, len)</span>
<a href="#l33.229"></a><span id="l33.229" class="difflineplus">+#  else</span>
<a href="#l33.230"></a><span id="l33.230" class="difflineplus">+#    define zmemcpy memcpy</span>
<a href="#l33.231"></a><span id="l33.231" class="difflineplus">+#    define zmemcmp memcmp</span>
<a href="#l33.232"></a><span id="l33.232" class="difflineplus">+#    define zmemzero(dest, len) memset(dest, 0, len)</span>
<a href="#l33.233"></a><span id="l33.233" class="difflineplus">+#  endif</span>
<a href="#l33.234"></a><span id="l33.234" class="difflineplus">+#else</span>
<a href="#l33.235"></a><span id="l33.235" class="difflineplus">+   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));</span>
<a href="#l33.236"></a><span id="l33.236" class="difflineplus">+   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));</span>
<a href="#l33.237"></a><span id="l33.237" class="difflineplus">+   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));</span>
<a href="#l33.238"></a><span id="l33.238" class="difflineplus">+#endif</span>
<a href="#l33.239"></a><span id="l33.239" class="difflineplus">+</span>
<a href="#l33.240"></a><span id="l33.240" class="difflineplus">+/* Diagnostic functions */</span>
<a href="#l33.241"></a><span id="l33.241" class="difflineplus">+#ifdef ZLIB_DEBUG</span>
<a href="#l33.242"></a><span id="l33.242" class="difflineplus">+#  include &lt;stdio.h&gt;</span>
<a href="#l33.243"></a><span id="l33.243" class="difflineplus">+   extern int ZLIB_INTERNAL z_verbose;</span>
<a href="#l33.244"></a><span id="l33.244" class="difflineplus">+   extern void ZLIB_INTERNAL z_error OF((char *m));</span>
<a href="#l33.245"></a><span id="l33.245" class="difflineplus">+#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}</span>
<a href="#l33.246"></a><span id="l33.246" class="difflineplus">+#  define Trace(x) {if (z_verbose&gt;=0) fprintf x ;}</span>
<a href="#l33.247"></a><span id="l33.247" class="difflineplus">+#  define Tracev(x) {if (z_verbose&gt;0) fprintf x ;}</span>
<a href="#l33.248"></a><span id="l33.248" class="difflineplus">+#  define Tracevv(x) {if (z_verbose&gt;1) fprintf x ;}</span>
<a href="#l33.249"></a><span id="l33.249" class="difflineplus">+#  define Tracec(c,x) {if (z_verbose&gt;0 &amp;&amp; (c)) fprintf x ;}</span>
<a href="#l33.250"></a><span id="l33.250" class="difflineplus">+#  define Tracecv(c,x) {if (z_verbose&gt;1 &amp;&amp; (c)) fprintf x ;}</span>
<a href="#l33.251"></a><span id="l33.251" class="difflineplus">+#else</span>
<a href="#l33.252"></a><span id="l33.252" class="difflineplus">+#  define Assert(cond,msg)</span>
<a href="#l33.253"></a><span id="l33.253" class="difflineplus">+#  define Trace(x)</span>
<a href="#l33.254"></a><span id="l33.254" class="difflineplus">+#  define Tracev(x)</span>
<a href="#l33.255"></a><span id="l33.255" class="difflineplus">+#  define Tracevv(x)</span>
<a href="#l33.256"></a><span id="l33.256" class="difflineplus">+#  define Tracec(c,x)</span>
<a href="#l33.257"></a><span id="l33.257" class="difflineplus">+#  define Tracecv(c,x)</span>
<a href="#l33.258"></a><span id="l33.258" class="difflineplus">+#endif</span>
<a href="#l33.259"></a><span id="l33.259" class="difflineplus">+</span>
<a href="#l33.260"></a><span id="l33.260" class="difflineplus">+#ifndef Z_SOLO</span>
<a href="#l33.261"></a><span id="l33.261" class="difflineplus">+   voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,</span>
<a href="#l33.262"></a><span id="l33.262" class="difflineplus">+                                    unsigned size));</span>
<a href="#l33.263"></a><span id="l33.263" class="difflineplus">+   void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));</span>
<a href="#l33.264"></a><span id="l33.264" class="difflineplus">+#endif</span>
<a href="#l33.265"></a><span id="l33.265" class="difflineplus">+</span>
<a href="#l33.266"></a><span id="l33.266" class="difflineplus">+#define ZALLOC(strm, items, size) \</span>
<a href="#l33.267"></a><span id="l33.267" class="difflineplus">+           (*((strm)-&gt;zalloc))((strm)-&gt;opaque, (items), (size))</span>
<a href="#l33.268"></a><span id="l33.268" class="difflineplus">+#define ZFREE(strm, addr)  (*((strm)-&gt;zfree))((strm)-&gt;opaque, (voidpf)(addr))</span>
<a href="#l33.269"></a><span id="l33.269" class="difflineplus">+#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}</span>
<a href="#l33.270"></a><span id="l33.270" class="difflineplus">+</span>
<a href="#l33.271"></a><span id="l33.271" class="difflineplus">+/* Reverse the bytes in a 32-bit value */</span>
<a href="#l33.272"></a><span id="l33.272" class="difflineplus">+#define ZSWAP32(q) ((((q) &gt;&gt; 24) &amp; 0xff) + (((q) &gt;&gt; 8) &amp; 0xff00) + \</span>
<a href="#l33.273"></a><span id="l33.273" class="difflineplus">+                    (((q) &amp; 0xff00) &lt;&lt; 8) + (((q) &amp; 0xff) &lt;&lt; 24))</span>
<a href="#l33.274"></a><span id="l33.274" class="difflineplus">+</span>
<a href="#l33.275"></a><span id="l33.275" class="difflineplus">+#endif /* ZUTIL_H */</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/4b0de666d1a4">4b0de666d1a4</a> at 2020-07-30T19:32:32Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

