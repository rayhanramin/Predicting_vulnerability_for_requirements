<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 1864:584801e70d4d1f9316e63c6eb3fefac001e58a3b</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 584801e70d4d1f9316e63c6eb3fefac001e58a3b" />
<meta property="og:url" content="/comm-central/rev/584801e70d4d1f9316e63c6eb3fefac001e58a3b" />
<meta property="og:description" content="fix 208197 and 359339, maintain imap keywords when copying messages between folders on servers that don't support keywords, and move messages back to inbox when marking messages in junk folder as non junk, r/sr=standard8" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 584801e70d4d1f9316e63c6eb3fefac001e58a3b 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/584801e70d4d1f9316e63c6eb3fefac001e58a3b">shortlog</a> |
<a href="/comm-central/log/584801e70d4d1f9316e63c6eb3fefac001e58a3b">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/584801e70d4d1f9316e63c6eb3fefac001e58a3b">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/584801e70d4d1f9316e63c6eb3fefac001e58a3b">files</a> |
changeset |
<a href="/comm-central/raw-rev/584801e70d4d1f9316e63c6eb3fefac001e58a3b">raw</a>  | <a href="/comm-central/archive/584801e70d4d1f9316e63c6eb3fefac001e58a3b.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
fix 208197 and 359339, maintain imap keywords when copying messages between folders on servers that don't support keywords, and move messages back to inbox when marking messages in junk folder as non junk, r/sr=standard8
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#68;&#97;&#118;&#105;&#100;&#32;&#66;&#105;&#101;&#110;&#118;&#101;&#110;&#117;&#32;&#60;&#98;&#105;&#101;&#110;&#118;&#101;&#110;&#117;&#64;&#110;&#118;&#101;&#110;&#116;&#117;&#114;&#101;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Thu, 05 Feb 2009 14:36:26 -0800</td></tr>

<tr>
 <td>changeset 1864</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/584801e70d4d1f9316e63c6eb3fefac001e58a3b">584801e70d4d1f9316e63c6eb3fefac001e58a3b</a></td>
</tr>



<tr>
<td>parent 1863</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/36f9aa09374b0e6685a5d3f4f0f70fd5503cb8f4">36f9aa09374b0e6685a5d3f4f0f70fd5503cb8f4</a>
</td>
</tr>

<tr>
<td>child 1865</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/78c44ffbd48a625176f47560b357e7a86de64fad">78c44ffbd48a625176f47560b357e7a86de64fad</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=584801e70d4d1f9316e63c6eb3fefac001e58a3b">1504</a></td></tr>
<tr><td>push user</td><td>bienvenu@nventure.com</td></tr>
<tr><td>push date</td><td class="date age">Thu, 05 Feb 2009 22:36:33 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@584801e70d4d [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=584801e70d4d1f9316e63c6eb3fefac001e58a3b">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=584801e70d4d1f9316e63c6eb3fefac001e58a3b&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=584801e70d4d1f9316e63c6eb3fefac001e58a3b&newProject=comm-central&newRevision=584801e70d4d1f9316e63c6eb3fefac001e58a3b&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=584801e70d4d1f9316e63c6eb3fefac001e58a3b&newProject=comm-central&newRevision=584801e70d4d1f9316e63c6eb3fefac001e58a3b&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=584801e70d4d1f9316e63c6eb3fefac001e58a3b&newProject=comm-central&newRevision=584801e70d4d1f9316e63c6eb3fefac001e58a3b&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>

<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=208197">208197</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=359339">359339</a></td></tr>




</table></div>

<div class="page_body description">fix 208197 and 359339, maintain imap keywords when copying messages between folders on servers that don't support keywords, and move messages back to inbox when marking messages in junk folder as non junk, r/sr=standard8</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/base/src/nsMsgDBView.cpp">mailnews/base/src/nsMsgDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/base/src/nsMsgDBView.cpp">file</a> |
<a href="/comm-central/annotate/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/base/src/nsMsgDBView.cpp">annotate</a> |
<a href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/base/src/nsMsgDBView.cpp">diff</a> |
<a href="/comm-central/comparison/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/base/src/nsMsgDBView.cpp">comparison</a> |
<a href="/comm-central/log/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/base/src/nsMsgDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/base/src/nsMsgDBView.h">mailnews/base/src/nsMsgDBView.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/base/src/nsMsgDBView.h">file</a> |
<a href="/comm-central/annotate/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/base/src/nsMsgDBView.h">annotate</a> |
<a href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/base/src/nsMsgDBView.h">diff</a> |
<a href="/comm-central/comparison/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/base/src/nsMsgDBView.h">comparison</a> |
<a href="/comm-central/log/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/base/src/nsMsgDBView.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/public/nsIMsgOfflineImapOperation.idl">mailnews/db/msgdb/public/nsIMsgOfflineImapOperation.idl</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/public/nsIMsgOfflineImapOperation.idl">file</a> |
<a href="/comm-central/annotate/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/public/nsIMsgOfflineImapOperation.idl">annotate</a> |
<a href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/public/nsIMsgOfflineImapOperation.idl">diff</a> |
<a href="/comm-central/comparison/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/public/nsIMsgOfflineImapOperation.idl">comparison</a> |
<a href="/comm-central/log/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/public/nsIMsgOfflineImapOperation.idl">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/public/nsMsgDatabase.h">mailnews/db/msgdb/public/nsMsgDatabase.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/public/nsMsgDatabase.h">file</a> |
<a href="/comm-central/annotate/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/public/nsMsgDatabase.h">annotate</a> |
<a href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/public/nsMsgDatabase.h">diff</a> |
<a href="/comm-central/comparison/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/public/nsMsgDatabase.h">comparison</a> |
<a href="/comm-central/log/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/public/nsMsgDatabase.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/src/nsMsgOfflineImapOperation.cpp">mailnews/db/msgdb/src/nsMsgOfflineImapOperation.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/src/nsMsgOfflineImapOperation.cpp">file</a> |
<a href="/comm-central/annotate/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/src/nsMsgOfflineImapOperation.cpp">annotate</a> |
<a href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/src/nsMsgOfflineImapOperation.cpp">diff</a> |
<a href="/comm-central/comparison/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/src/nsMsgOfflineImapOperation.cpp">comparison</a> |
<a href="/comm-central/log/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/db/msgdb/src/nsMsgOfflineImapOperation.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/imap/src/nsImapMailFolder.cpp">mailnews/imap/src/nsImapMailFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/imap/src/nsImapMailFolder.cpp">file</a> |
<a href="/comm-central/annotate/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/imap/src/nsImapMailFolder.cpp">annotate</a> |
<a href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/imap/src/nsImapMailFolder.cpp">diff</a> |
<a href="/comm-central/comparison/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/imap/src/nsImapMailFolder.cpp">comparison</a> |
<a href="/comm-central/log/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/imap/src/nsImapMailFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/imap/src/nsImapMailFolder.h">mailnews/imap/src/nsImapMailFolder.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/imap/src/nsImapMailFolder.h">file</a> |
<a href="/comm-central/annotate/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/imap/src/nsImapMailFolder.h">annotate</a> |
<a href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/imap/src/nsImapMailFolder.h">diff</a> |
<a href="/comm-central/comparison/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/imap/src/nsImapMailFolder.h">comparison</a> |
<a href="/comm-central/log/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/imap/src/nsImapMailFolder.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/mailnews.js">mailnews/mailnews.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/mailnews.js">file</a> |
<a href="/comm-central/annotate/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/mailnews.js">annotate</a> |
<a href="/comm-central/diff/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/mailnews.js">diff</a> |
<a href="/comm-central/comparison/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/mailnews.js">comparison</a> |
<a href="/comm-central/log/584801e70d4d1f9316e63c6eb3fefac001e58a3b/mailnews/mailnews.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/base/src/nsMsgDBView.cpp</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgDBView.cpp</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -2527,31 +2527,32 @@ nsMsgDBView::ApplyCommandToIndices(nsMsg</span>
<a href="#l1.4"></a><span id="l1.4"> </span>
<a href="#l1.5"></a><span id="l1.5">   nsTArray&lt;nsMsgKey&gt; imapUids;</span>
<a href="#l1.6"></a><span id="l1.6">   nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(folder);</span>
<a href="#l1.7"></a><span id="l1.7">   PRBool thisIsImapFolder = (imapFolder != nsnull);</span>
<a href="#l1.8"></a><span id="l1.8">   nsCOMPtr&lt;nsIJunkMailPlugin&gt; junkPlugin;</span>
<a href="#l1.9"></a><span id="l1.9"> </span>
<a href="#l1.10"></a><span id="l1.10">   // if this is a junk command, start a batch or add to an existing one.</span>
<a href="#l1.11"></a><span id="l1.11">   //</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-  if (    command == nsMsgViewCommandType::junk</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineminus">-       || command == nsMsgViewCommandType::unjunk )</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+  if (command == nsMsgViewCommandType::junk ||</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+      command == nsMsgViewCommandType::unjunk)</span>
<a href="#l1.16"></a><span id="l1.16">   {</span>
<a href="#l1.17"></a><span id="l1.17">     // get the folder from the first item; we assume that</span>
<a href="#l1.18"></a><span id="l1.18">     // all messages in the view are from the same folder (no</span>
<a href="#l1.19"></a><span id="l1.19">     // more junk status column in the 'search messages' dialog</span>
<a href="#l1.20"></a><span id="l1.20">     // like in earlier versions...)</span>
<a href="#l1.21"></a><span id="l1.21">      //</span>
<a href="#l1.22"></a><span id="l1.22">      NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.23"></a><span id="l1.23"> </span>
<a href="#l1.24"></a><span id="l1.24">      nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l1.25"></a><span id="l1.25">      rv = folder-&gt;GetServer(getter_AddRefs(server));</span>
<a href="#l1.26"></a><span id="l1.26">      NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.27"></a><span id="l1.27"> </span>
<a href="#l1.28"></a><span id="l1.28" class="difflineminus">-    if (command == nsMsgViewCommandType::junk)</span>
<a href="#l1.29"></a><span id="l1.29" class="difflineplus">+    if (command == nsMsgViewCommandType::junk ||</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineplus">+        command == nsMsgViewCommandType::unjunk)</span>
<a href="#l1.31"></a><span id="l1.31">     {</span>
<a href="#l1.32"></a><span id="l1.32">       // append this batch of junk message indices to the</span>
<a href="#l1.33"></a><span id="l1.33">       // array of junk message indices to be acted upon</span>
<a href="#l1.34"></a><span id="l1.34">       // once OnMessageClassified() is run for the last message</span>
<a href="#l1.35"></a><span id="l1.35">       //</span>
<a href="#l1.36"></a><span id="l1.36">       // note: although message classification is done</span>
<a href="#l1.37"></a><span id="l1.37">       // asynchronously, it is not done in a different thread,</span>
<a href="#l1.38"></a><span id="l1.38">       // so the manipulations of mJunkIndices here and in</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineat">@@ -2968,203 +2969,233 @@ nsMsgDBView::OnMessageClassified(const c</span>
<a href="#l1.40"></a><span id="l1.40">   // mark some of the messages in the view as junk, or as not</span>
<a href="#l1.41"></a><span id="l1.41">   // junk - so the classification is dictated to the filter,</span>
<a href="#l1.42"></a><span id="l1.42">   // not suggested by it.</span>
<a href="#l1.43"></a><span id="l1.43">   //</span>
<a href="#l1.44"></a><span id="l1.44">   // for this reason the only thing we (may) have to do is</span>
<a href="#l1.45"></a><span id="l1.45">   // perform the action on all of the junk messages</span>
<a href="#l1.46"></a><span id="l1.46">   //</span>
<a href="#l1.47"></a><span id="l1.47"> </span>
<a href="#l1.48"></a><span id="l1.48" class="difflineminus">-  NS_ASSERTION( (aClassification == nsIJunkMailPlugin::GOOD) || (mJunkIndices != nsnull), &quot;the classification of a manually-marked junk message has been classified as junk, yet there seem to be no such outstanding messages&quot;);</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineplus">+  NS_ASSERTION((aClassification == nsIJunkMailPlugin::GOOD) ||</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineplus">+                (mJunkIndices != nsnull),</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+                &quot;the classification of a manually-marked junk message has&quot;</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineplus">+                &quot;been classified as junk, yet there seem to be no such outstanding messages&quot;);</span>
<a href="#l1.53"></a><span id="l1.53"> </span>
<a href="#l1.54"></a><span id="l1.54">   // is this the last message in the batch?</span>
<a href="#l1.55"></a><span id="l1.55"> </span>
<a href="#l1.56"></a><span id="l1.56">   if (--mNumMessagesRemainingInBatch == 0)</span>
<a href="#l1.57"></a><span id="l1.57">   {</span>
<a href="#l1.58"></a><span id="l1.58">     if ( mNumJunkIndices &gt; 0 )</span>
<a href="#l1.59"></a><span id="l1.59">     {</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineminus">-      PerformActionsOnJunkMsgs();</span>
<a href="#l1.61"></a><span id="l1.61" class="difflineplus">+      PerformActionsOnJunkMsgs(aClassification == nsIJunkMailPlugin::JUNK);</span>
<a href="#l1.62"></a><span id="l1.62">       nsMemory::Free(mJunkIndices);</span>
<a href="#l1.63"></a><span id="l1.63">       mJunkIndices = nsnull;</span>
<a href="#l1.64"></a><span id="l1.64">       mNumJunkIndices = 0;</span>
<a href="#l1.65"></a><span id="l1.65">     }</span>
<a href="#l1.66"></a><span id="l1.66">   }</span>
<a href="#l1.67"></a><span id="l1.67">   return NS_OK;</span>
<a href="#l1.68"></a><span id="l1.68"> }</span>
<a href="#l1.69"></a><span id="l1.69"> </span>
<a href="#l1.70"></a><span id="l1.70"> nsresult</span>
<a href="#l1.71"></a><span id="l1.71" class="difflineminus">-nsMsgDBView::PerformActionsOnJunkMsgs()</span>
<a href="#l1.72"></a><span id="l1.72" class="difflineminus">-{</span>
<a href="#l1.73"></a><span id="l1.73" class="difflineminus">-  PRBool movingJunkMessages,markingJunkMessagesRead;</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; junkTargetFolder;</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineplus">+nsMsgDBView::PerformActionsOnJunkMsgs(PRBool msgsAreJunk)</span>
<a href="#l1.76"></a><span id="l1.76" class="difflineplus">+{</span>
<a href="#l1.77"></a><span id="l1.77" class="difflineplus">+  PRBool moveMessages,changeReadState;</span>
<a href="#l1.78"></a><span id="l1.78" class="difflineplus">+  nsCOMPtr &lt;nsIMsgFolder&gt; targetFolder;</span>
<a href="#l1.79"></a><span id="l1.79"> </span>
<a href="#l1.80"></a><span id="l1.80">   // question: is it possible for the junk mail move/mark as read</span>
<a href="#l1.81"></a><span id="l1.81">   // options to change after we've handled some of the batches but</span>
<a href="#l1.82"></a><span id="l1.82">   // before we've handled the last one? if so, we can decide when</span>
<a href="#l1.83"></a><span id="l1.83">   // handling each batch whether to save its indices or forget</span>
<a href="#l1.84"></a><span id="l1.84">   // them, and then perform the known action when handling the</span>
<a href="#l1.85"></a><span id="l1.85">   // last batch; however if the options can change between batches</span>
<a href="#l1.86"></a><span id="l1.86">   // we may have to remember in separate arrays the indices to</span>
<a href="#l1.87"></a><span id="l1.87">   // mark as read and the indices to move</span>
<a href="#l1.88"></a><span id="l1.88">   //</span>
<a href="#l1.89"></a><span id="l1.89">   // for now, we assume the options do not change between batches</span>
<a href="#l1.90"></a><span id="l1.90">   //</span>
<a href="#l1.91"></a><span id="l1.91"> </span>
<a href="#l1.92"></a><span id="l1.92" class="difflineminus">-  nsresult rv = DetermineActionsForJunkMsgs(&amp;movingJunkMessages, &amp;markingJunkMessagesRead, getter_AddRefs(junkTargetFolder));</span>
<a href="#l1.93"></a><span id="l1.93" class="difflineplus">+  nsresult rv = DetermineActionsForJunkChange(msgsAreJunk, moveMessages,</span>
<a href="#l1.94"></a><span id="l1.94" class="difflineplus">+                                              changeReadState,</span>
<a href="#l1.95"></a><span id="l1.95" class="difflineplus">+                                              getter_AddRefs(targetFolder));</span>
<a href="#l1.96"></a><span id="l1.96">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l1.97"></a><span id="l1.97"> </span>
<a href="#l1.98"></a><span id="l1.98">   // nothing to do, bail out</span>
<a href="#l1.99"></a><span id="l1.99" class="difflineminus">-  if (!(movingJunkMessages || markingJunkMessagesRead))</span>
<a href="#l1.100"></a><span id="l1.100" class="difflineplus">+  if (!(moveMessages || changeReadState))</span>
<a href="#l1.101"></a><span id="l1.101">     return NS_OK;</span>
<a href="#l1.102"></a><span id="l1.102"> </span>
<a href="#l1.103"></a><span id="l1.103">   NS_ASSERTION( (mNumJunkIndices &gt; 0), &quot;no indices of marked-as-junk messages to act on&quot;);</span>
<a href="#l1.104"></a><span id="l1.104"> </span>
<a href="#l1.105"></a><span id="l1.105">   if (mNumJunkIndices &gt; 1)</span>
<a href="#l1.106"></a><span id="l1.106">     NS_QuickSort(mJunkIndices, mNumJunkIndices, sizeof(nsMsgViewIndex), CompareViewIndices, nsnull);</span>
<a href="#l1.107"></a><span id="l1.107"> </span>
<a href="#l1.108"></a><span id="l1.108" class="difflineminus">-  if (markingJunkMessagesRead)</span>
<a href="#l1.109"></a><span id="l1.109" class="difflineplus">+  if (changeReadState)</span>
<a href="#l1.110"></a><span id="l1.110">   {</span>
<a href="#l1.111"></a><span id="l1.111">     // notes on marking junk as read:</span>
<a href="#l1.112"></a><span id="l1.112">     // 1. there are 2 occasions on which junk messages are marked as</span>
<a href="#l1.113"></a><span id="l1.113">     //    read: after a manual marking (here and in the front end) and after</span>
<a href="#l1.114"></a><span id="l1.114">     //    automatic classification by the bayesian filter (see code for local</span>
<a href="#l1.115"></a><span id="l1.115">     //    mail folders and for imap mail folders). The server-specific</span>
<a href="#l1.116"></a><span id="l1.116">     //    markAsReadOnSpam pref only applies to the latter, the former is</span>
<a href="#l1.117"></a><span id="l1.117">     //    controlled by &quot;mailnews.ui.junk.manualMarkAsJunkMarksRead&quot;.</span>
<a href="#l1.118"></a><span id="l1.118">     // 2. even though move/delete on manual mark may be</span>
<a href="#l1.119"></a><span id="l1.119">     //    turned off, we might still need to mark as read</span>
<a href="#l1.120"></a><span id="l1.120"> </span>
<a href="#l1.121"></a><span id="l1.121">     NoteStartChange(nsMsgViewNotificationCode::none, 0, 0);</span>
<a href="#l1.122"></a><span id="l1.122" class="difflineminus">-    rv = ApplyCommandToIndices(nsMsgViewCommandType::markMessagesRead, mJunkIndices, mNumJunkIndices);</span>
<a href="#l1.123"></a><span id="l1.123" class="difflineplus">+    rv = ApplyCommandToIndices(msgsAreJunk ? nsMsgViewCommandType::markMessagesRead :</span>
<a href="#l1.124"></a><span id="l1.124" class="difflineplus">+                                             nsMsgViewCommandType::markMessagesUnread,</span>
<a href="#l1.125"></a><span id="l1.125" class="difflineplus">+                                             mJunkIndices, mNumJunkIndices);</span>
<a href="#l1.126"></a><span id="l1.126">     NoteEndChange(nsMsgViewNotificationCode::none, 0, 0);</span>
<a href="#l1.127"></a><span id="l1.127">     NS_ASSERTION(NS_SUCCEEDED(rv), &quot;marking marked-as-junk messages as read failed&quot;);</span>
<a href="#l1.128"></a><span id="l1.128">   }</span>
<a href="#l1.129"></a><span id="l1.129" class="difflineminus">-  if (movingJunkMessages)</span>
<a href="#l1.130"></a><span id="l1.130" class="difflineplus">+  if (moveMessages)</span>
<a href="#l1.131"></a><span id="l1.131">   {</span>
<a href="#l1.132"></a><span id="l1.132">     // check if one of the messages to be junked is actually selected</span>
<a href="#l1.133"></a><span id="l1.133">     // if more than one message being junked, one must be selected.</span>
<a href="#l1.134"></a><span id="l1.134">     // if no tree selection at all, must be in stand-alone message window.</span>
<a href="#l1.135"></a><span id="l1.135">     PRBool junkedMsgSelected = mNumJunkIndices &gt; 1 || !mTreeSelection;</span>
<a href="#l1.136"></a><span id="l1.136">     for (nsMsgViewIndex junkIndex = 0; !junkedMsgSelected &amp;&amp; junkIndex &lt; mNumJunkIndices; junkIndex++)</span>
<a href="#l1.137"></a><span id="l1.137">       mTreeSelection-&gt;IsSelected(mJunkIndices[junkIndex], &amp;junkedMsgSelected);</span>
<a href="#l1.138"></a><span id="l1.138"> </span>
<a href="#l1.139"></a><span id="l1.139">     // if a junked msg is selected, tell the FE to call SetNextMessageAfterDelete() because a delete is coming</span>
<a href="#l1.140"></a><span id="l1.140">     if (junkedMsgSelected &amp;&amp; mCommandUpdater)</span>
<a href="#l1.141"></a><span id="l1.141">     {</span>
<a href="#l1.142"></a><span id="l1.142">       rv = mCommandUpdater-&gt;UpdateNextMessageAfterDelete();</span>
<a href="#l1.143"></a><span id="l1.143">       NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l1.144"></a><span id="l1.144">     }</span>
<a href="#l1.145"></a><span id="l1.145"> </span>
<a href="#l1.146"></a><span id="l1.146">     NoteStartChange(nsMsgViewNotificationCode::none, 0, 0);</span>
<a href="#l1.147"></a><span id="l1.147" class="difflineminus">-    if (junkTargetFolder)</span>
<a href="#l1.148"></a><span id="l1.148" class="difflineminus">-      rv = ApplyCommandToIndicesWithFolder(nsMsgViewCommandType::moveMessages, mJunkIndices, mNumJunkIndices, junkTargetFolder);</span>
<a href="#l1.149"></a><span id="l1.149" class="difflineminus">-    else</span>
<a href="#l1.150"></a><span id="l1.150" class="difflineplus">+    if (targetFolder)</span>
<a href="#l1.151"></a><span id="l1.151" class="difflineplus">+      rv = ApplyCommandToIndicesWithFolder(nsMsgViewCommandType::moveMessages, mJunkIndices, mNumJunkIndices, targetFolder);</span>
<a href="#l1.152"></a><span id="l1.152" class="difflineplus">+    else if (msgsAreJunk)</span>
<a href="#l1.153"></a><span id="l1.153">       rv = ApplyCommandToIndices(nsMsgViewCommandType::deleteMsg, mJunkIndices, mNumJunkIndices);</span>
<a href="#l1.154"></a><span id="l1.154" class="difflineplus">+    else if (mDeleteModel == nsMsgImapDeleteModels::IMAPDelete)</span>
<a href="#l1.155"></a><span id="l1.155" class="difflineplus">+      rv = ApplyCommandToIndices(nsMsgViewCommandType::undeleteMsg, mJunkIndices, mNumJunkIndices);</span>
<a href="#l1.156"></a><span id="l1.156">     NoteEndChange(nsMsgViewNotificationCode::none, 0, 0);</span>
<a href="#l1.157"></a><span id="l1.157"> </span>
<a href="#l1.158"></a><span id="l1.158" class="difflineminus">-    NS_ASSERTION(NS_SUCCEEDED(rv), &quot;move or deletion of marked-as-junk messages failed&quot;);</span>
<a href="#l1.159"></a><span id="l1.159" class="difflineplus">+    NS_ASSERTION(NS_SUCCEEDED(rv), &quot;move or deletion of message marked-as-junk/non junk failed&quot;);</span>
<a href="#l1.160"></a><span id="l1.160">   }</span>
<a href="#l1.161"></a><span id="l1.161">   return rv;</span>
<a href="#l1.162"></a><span id="l1.162"> }</span>
<a href="#l1.163"></a><span id="l1.163"> </span>
<a href="#l1.164"></a><span id="l1.164"> nsresult</span>
<a href="#l1.165"></a><span id="l1.165" class="difflineminus">-nsMsgDBView::DetermineActionsForJunkMsgs(PRBool* movingJunkMessages, PRBool* markingJunkMessagesRead, nsIMsgFolder** junkTargetFolder)</span>
<a href="#l1.166"></a><span id="l1.166" class="difflineplus">+nsMsgDBView::DetermineActionsForJunkChange(PRBool msgsAreJunk,</span>
<a href="#l1.167"></a><span id="l1.167" class="difflineplus">+                                           PRBool &amp;moveMessages,</span>
<a href="#l1.168"></a><span id="l1.168" class="difflineplus">+                                           PRBool &amp;changeReadState,</span>
<a href="#l1.169"></a><span id="l1.169" class="difflineplus">+                                           nsIMsgFolder** targetFolder)</span>
<a href="#l1.170"></a><span id="l1.170"> {</span>
<a href="#l1.171"></a><span id="l1.171">   // there are two possible actions which may be performed</span>
<a href="#l1.172"></a><span id="l1.172">   // on messages marked as spam: marking as read and moving</span>
<a href="#l1.173"></a><span id="l1.173" class="difflineminus">-  // somewhere...</span>
<a href="#l1.174"></a><span id="l1.174" class="difflineminus">-</span>
<a href="#l1.175"></a><span id="l1.175" class="difflineminus">-  *movingJunkMessages = false;</span>
<a href="#l1.176"></a><span id="l1.176" class="difflineminus">-  *markingJunkMessagesRead = false;</span>
<a href="#l1.177"></a><span id="l1.177" class="difflineplus">+  // somewhere...When a message is marked as non junk,</span>
<a href="#l1.178"></a><span id="l1.178" class="difflineplus">+  // it may be moved to the inbox, and marked unread.</span>
<a href="#l1.179"></a><span id="l1.179" class="difflineplus">+</span>
<a href="#l1.180"></a><span id="l1.180" class="difflineplus">+  moveMessages = false;</span>
<a href="#l1.181"></a><span id="l1.181" class="difflineplus">+  changeReadState = false;</span>
<a href="#l1.182"></a><span id="l1.182"> </span>
<a href="#l1.183"></a><span id="l1.183">   // ... the 'somewhere', junkTargetFolder, can be a folder,</span>
<a href="#l1.184"></a><span id="l1.184">   // but if it remains null we'll delete the messages</span>
<a href="#l1.185"></a><span id="l1.185"> </span>
<a href="#l1.186"></a><span id="l1.186" class="difflineminus">-  *junkTargetFolder = nsnull;</span>
<a href="#l1.187"></a><span id="l1.187" class="difflineplus">+  *targetFolder = nsnull;</span>
<a href="#l1.188"></a><span id="l1.188"> </span>
<a href="#l1.189"></a><span id="l1.189">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l1.190"></a><span id="l1.190">   nsresult rv = GetFolderForViewIndex(mJunkIndices[0], getter_AddRefs(folder));</span>
<a href="#l1.191"></a><span id="l1.191">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.192"></a><span id="l1.192"> </span>
<a href="#l1.193"></a><span id="l1.193" class="difflineplus">+  PRUint32 folderFlags;</span>
<a href="#l1.194"></a><span id="l1.194" class="difflineplus">+  folder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l1.195"></a><span id="l1.195" class="difflineplus">+</span>
<a href="#l1.196"></a><span id="l1.196">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l1.197"></a><span id="l1.197">   rv = folder-&gt;GetServer(getter_AddRefs(server));</span>
<a href="#l1.198"></a><span id="l1.198">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.199"></a><span id="l1.199"> </span>
<a href="#l1.200"></a><span id="l1.200" class="difflineplus">+  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l1.201"></a><span id="l1.201" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.202"></a><span id="l1.202" class="difflineplus">+</span>
<a href="#l1.203"></a><span id="l1.203" class="difflineplus">+  // handle the easy case of marking a junk message as good first...</span>
<a href="#l1.204"></a><span id="l1.204" class="difflineplus">+  // set the move target folder to the inbox, if any.</span>
<a href="#l1.205"></a><span id="l1.205" class="difflineplus">+  if (!msgsAreJunk)</span>
<a href="#l1.206"></a><span id="l1.206" class="difflineplus">+  {</span>
<a href="#l1.207"></a><span id="l1.207" class="difflineplus">+    prefBranch-&gt;GetBoolPref(&quot;mail.spam.markAsNotJunkMarksUnRead&quot;,</span>
<a href="#l1.208"></a><span id="l1.208" class="difflineplus">+                            &amp;changeReadState);</span>
<a href="#l1.209"></a><span id="l1.209" class="difflineplus">+    if (folderFlags &amp; nsMsgFolderFlags::Junk)</span>
<a href="#l1.210"></a><span id="l1.210" class="difflineplus">+    {</span>
<a href="#l1.211"></a><span id="l1.211" class="difflineplus">+      nsCOMPtr&lt;nsIMsgFolder&gt; rootMsgFolder;</span>
<a href="#l1.212"></a><span id="l1.212" class="difflineplus">+      rv = server-&gt;GetRootMsgFolder(getter_AddRefs(rootMsgFolder));</span>
<a href="#l1.213"></a><span id="l1.213" class="difflineplus">+      NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l1.214"></a><span id="l1.214" class="difflineplus">+      rootMsgFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Inbox, targetFolder);</span>
<a href="#l1.215"></a><span id="l1.215" class="difflineplus">+      moveMessages = targetFolder != nsnull;</span>
<a href="#l1.216"></a><span id="l1.216" class="difflineplus">+    }</span>
<a href="#l1.217"></a><span id="l1.217" class="difflineplus">+    return NS_OK;</span>
<a href="#l1.218"></a><span id="l1.218" class="difflineplus">+  }</span>
<a href="#l1.219"></a><span id="l1.219" class="difflineplus">+</span>
<a href="#l1.220"></a><span id="l1.220">   nsCOMPtr &lt;nsISpamSettings&gt; spamSettings;</span>
<a href="#l1.221"></a><span id="l1.221">   rv = server-&gt;GetSpamSettings(getter_AddRefs(spamSettings));</span>
<a href="#l1.222"></a><span id="l1.222">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.223"></a><span id="l1.223"> </span>
<a href="#l1.224"></a><span id="l1.224">   // if the spam system is completely disabled we won't do anything</span>
<a href="#l1.225"></a><span id="l1.225">   // question: is this a valid choice?</span>
<a href="#l1.226"></a><span id="l1.226">   PRInt32 spamLevel;</span>
<a href="#l1.227"></a><span id="l1.227">   (void)spamSettings-&gt;GetLevel(&amp;spamLevel);</span>
<a href="#l1.228"></a><span id="l1.228">   if (!spamLevel)</span>
<a href="#l1.229"></a><span id="l1.229">     return NS_OK;</span>
<a href="#l1.230"></a><span id="l1.230"> </span>
<a href="#l1.231"></a><span id="l1.231">   // When the user explicitly marks a message as junk, we can mark it as read,</span>
<a href="#l1.232"></a><span id="l1.232">   // too. This is independent of the &quot;markAsReadOnSpam&quot; pref, which applies</span>
<a href="#l1.233"></a><span id="l1.233">   // only to automatically-classified messages.</span>
<a href="#l1.234"></a><span id="l1.234">   // Note that this behaviour should match the one in the front end for marking</span>
<a href="#l1.235"></a><span id="l1.235">   // as junk via toolbar/context menu.</span>
<a href="#l1.236"></a><span id="l1.236" class="difflineminus">-  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l1.237"></a><span id="l1.237">   if (NS_SUCCEEDED(rv))</span>
<a href="#l1.238"></a><span id="l1.238">   {</span>
<a href="#l1.239"></a><span id="l1.239">     prefBranch-&gt;GetBoolPref(&quot;mailnews.ui.junk.manualMarkAsJunkMarksRead&quot;,</span>
<a href="#l1.240"></a><span id="l1.240" class="difflineminus">-                            markingJunkMessagesRead);</span>
<a href="#l1.241"></a><span id="l1.241" class="difflineplus">+                            &amp;changeReadState);</span>
<a href="#l1.242"></a><span id="l1.242">   }</span>
<a href="#l1.243"></a><span id="l1.243"> </span>
<a href="#l1.244"></a><span id="l1.244">   // now let's determine whether we'll be taking the second action,</span>
<a href="#l1.245"></a><span id="l1.245">   // the move / deletion (and also determine which of these two)</span>
<a href="#l1.246"></a><span id="l1.246"> </span>
<a href="#l1.247"></a><span id="l1.247">   PRBool manualMark;</span>
<a href="#l1.248"></a><span id="l1.248">   (void)spamSettings-&gt;GetManualMark(&amp;manualMark);</span>
<a href="#l1.249"></a><span id="l1.249">   if (!manualMark)</span>
<a href="#l1.250"></a><span id="l1.250">     return NS_OK;</span>
<a href="#l1.251"></a><span id="l1.251"> </span>
<a href="#l1.252"></a><span id="l1.252">   PRInt32 manualMarkMode;</span>
<a href="#l1.253"></a><span id="l1.253">   (void)spamSettings-&gt;GetManualMarkMode(&amp;manualMarkMode);</span>
<a href="#l1.254"></a><span id="l1.254">   NS_ASSERTION(manualMarkMode == nsISpamSettings::MANUAL_MARK_MODE_MOVE</span>
<a href="#l1.255"></a><span id="l1.255">             || manualMarkMode == nsISpamSettings::MANUAL_MARK_MODE_DELETE,</span>
<a href="#l1.256"></a><span id="l1.256">             &quot;bad manual mark mode&quot;);</span>
<a href="#l1.257"></a><span id="l1.257"> </span>
<a href="#l1.258"></a><span id="l1.258" class="difflineminus">-  // the folder must allow us to execute the move (or the deletion)</span>
<a href="#l1.259"></a><span id="l1.259" class="difflineminus">-  PRUint32 folderFlags;</span>
<a href="#l1.260"></a><span id="l1.260" class="difflineminus">-  folder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l1.261"></a><span id="l1.261" class="difflineminus">-</span>
<a href="#l1.262"></a><span id="l1.262">   if (manualMarkMode == nsISpamSettings::MANUAL_MARK_MODE_MOVE)</span>
<a href="#l1.263"></a><span id="l1.263">   {</span>
<a href="#l1.264"></a><span id="l1.264">     // if this is a junk folder</span>
<a href="#l1.265"></a><span id="l1.265">     // (not only &quot;the&quot; junk folder for this account)</span>
<a href="#l1.266"></a><span id="l1.266">     // don't do the move</span>
<a href="#l1.267"></a><span id="l1.267">     if (folderFlags &amp; nsMsgFolderFlags::Junk)</span>
<a href="#l1.268"></a><span id="l1.268">       return NS_OK;</span>
<a href="#l1.269"></a><span id="l1.269"> </span>
<a href="#l1.270"></a><span id="l1.270">     nsCString spamFolderURI;</span>
<a href="#l1.271"></a><span id="l1.271">     rv = spamSettings-&gt;GetSpamFolderURI(getter_Copies(spamFolderURI));</span>
<a href="#l1.272"></a><span id="l1.272">     NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l1.273"></a><span id="l1.273"> </span>
<a href="#l1.274"></a><span id="l1.274">     NS_ASSERTION(!spamFolderURI.IsEmpty(), &quot;spam folder URI is empty, can't move&quot;);</span>
<a href="#l1.275"></a><span id="l1.275">     if (!spamFolderURI.IsEmpty())</span>
<a href="#l1.276"></a><span id="l1.276">     {</span>
<a href="#l1.277"></a><span id="l1.277" class="difflineminus">-      //nsCOMPtr&lt;nsIMsgFolder&gt; destFolder;</span>
<a href="#l1.278"></a><span id="l1.278" class="difflineminus">-      rv = GetExistingFolder(spamFolderURI, junkTargetFolder);</span>
<a href="#l1.279"></a><span id="l1.279" class="difflineplus">+      rv = GetExistingFolder(spamFolderURI, targetFolder);</span>
<a href="#l1.280"></a><span id="l1.280">       NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l1.281"></a><span id="l1.281"> </span>
<a href="#l1.282"></a><span id="l1.282" class="difflineminus">-      *movingJunkMessages = true;</span>
<a href="#l1.283"></a><span id="l1.283" class="difflineplus">+      moveMessages = true;</span>
<a href="#l1.284"></a><span id="l1.284">     }</span>
<a href="#l1.285"></a><span id="l1.285">     return NS_OK;</span>
<a href="#l1.286"></a><span id="l1.286">   }</span>
<a href="#l1.287"></a><span id="l1.287"> </span>
<a href="#l1.288"></a><span id="l1.288">   // at this point manualMarkMode == nsISpamSettings::MANUAL_MARK_MODE_DELETE)</span>
<a href="#l1.289"></a><span id="l1.289"> </span>
<a href="#l1.290"></a><span id="l1.290">   // if this is in the trash, let's not delete</span>
<a href="#l1.291"></a><span id="l1.291">   if (folderFlags &amp; nsMsgFolderFlags::Trash)</span>
<a href="#l1.292"></a><span id="l1.292">     return NS_OK;</span>
<a href="#l1.293"></a><span id="l1.293"> </span>
<a href="#l1.294"></a><span id="l1.294" class="difflineminus">-  return folder-&gt;GetCanDeleteMessages(movingJunkMessages);</span>
<a href="#l1.295"></a><span id="l1.295" class="difflineplus">+  return folder-&gt;GetCanDeleteMessages(&amp;moveMessages);</span>
<a href="#l1.296"></a><span id="l1.296"> }</span>
<a href="#l1.297"></a><span id="l1.297"> </span>
<a href="#l1.298"></a><span id="l1.298"> // reversing threads involves reversing the threads but leaving the</span>
<a href="#l1.299"></a><span id="l1.299"> // expanded messages ordered relative to the thread, so we</span>
<a href="#l1.300"></a><span id="l1.300"> // make a copy of each array and copy them over.</span>
<a href="#l1.301"></a><span id="l1.301"> void nsMsgDBView::ReverseThreads()</span>
<a href="#l1.302"></a><span id="l1.302"> {</span>
<a href="#l1.303"></a><span id="l1.303">     nsTArray&lt;PRUint32&gt; newFlagArray;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/base/src/nsMsgDBView.h</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgDBView.h</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -483,18 +483,21 @@ protected:</span>
<a href="#l2.4"></a><span id="l2.4">   static nsresult   InitDisplayFormats();</span>
<a href="#l2.5"></a><span id="l2.5"> </span>
<a href="#l2.6"></a><span id="l2.6"> private:</span>
<a href="#l2.7"></a><span id="l2.7">   static nsDateFormatSelector  m_dateFormatDefault;</span>
<a href="#l2.8"></a><span id="l2.8">   static nsDateFormatSelector  m_dateFormatThisWeek;</span>
<a href="#l2.9"></a><span id="l2.9">   static nsDateFormatSelector  m_dateFormatToday;</span>
<a href="#l2.10"></a><span id="l2.10">   PRBool ServerSupportsFilterAfterTheFact();</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-  nsresult PerformActionsOnJunkMsgs();</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineminus">-  nsresult DetermineActionsForJunkMsgs(PRBool* movingJunkMessages, PRBool* markingJunkMessagesRead, nsIMsgFolder** junkTargetFolder);</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+  nsresult PerformActionsOnJunkMsgs(PRBool msgsAreJunk);</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+  nsresult DetermineActionsForJunkChange(PRBool msgsAreJunk,</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+                                         PRBool &amp;moveMessages,</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+                                         PRBool &amp;changeReadState,</span>
<a href="#l2.18"></a><span id="l2.18" class="difflineplus">+                                         nsIMsgFolder** targetFolder);</span>
<a href="#l2.19"></a><span id="l2.19"> </span>
<a href="#l2.20"></a><span id="l2.20">   class nsMsgViewHdrEnumerator : public nsISimpleEnumerator </span>
<a href="#l2.21"></a><span id="l2.21">   {</span>
<a href="#l2.22"></a><span id="l2.22">   public:</span>
<a href="#l2.23"></a><span id="l2.23">     NS_DECL_ISUPPORTS</span>
<a href="#l2.24"></a><span id="l2.24"> </span>
<a href="#l2.25"></a><span id="l2.25">     // nsISimpleEnumerator methods:</span>
<a href="#l2.26"></a><span id="l2.26">     NS_DECL_NSISIMPLEENUMERATOR</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/db/msgdb/public/nsIMsgOfflineImapOperation.idl</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/db/msgdb/public/nsIMsgOfflineImapOperation.idl</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -38,17 +38,17 @@</span>
<a href="#l3.4"></a><span id="l3.4"> #include &quot;nsISupports.idl&quot;</span>
<a href="#l3.5"></a><span id="l3.5"> #include &quot;MailNewsTypes2.idl&quot;</span>
<a href="#l3.6"></a><span id="l3.6"> // #include &quot;nsIImapUrl.idl&quot; // for imapMessageFlagsType</span>
<a href="#l3.7"></a><span id="l3.7"> </span>
<a href="#l3.8"></a><span id="l3.8"> typedef unsigned short imapMessageFlagsType;</span>
<a href="#l3.9"></a><span id="l3.9"> </span>
<a href="#l3.10"></a><span id="l3.10"> typedef long nsOfflineImapOperationType;</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-[scriptable, uuid(628a51dd-fd3c-4d2a-9441-e4f4d287b1bf)]</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+[scriptable, uuid(b5229a55-22bb-444b-be92-13d719353828)]</span>
<a href="#l3.14"></a><span id="l3.14"> </span>
<a href="#l3.15"></a><span id="l3.15"> interface nsIMsgOfflineImapOperation : nsISupports</span>
<a href="#l3.16"></a><span id="l3.16"> {</span>
<a href="#l3.17"></a><span id="l3.17"> // type of stored imap operations</span>
<a href="#l3.18"></a><span id="l3.18">   const long kFlagsChanged      = 0x1;</span>
<a href="#l3.19"></a><span id="l3.19">   const long kMsgMoved          = 0x2;</span>
<a href="#l3.20"></a><span id="l3.20">   const long kMsgCopy           = 0x4;</span>
<a href="#l3.21"></a><span id="l3.21">   const long kMoveResult        = 0x8;</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineat">@@ -59,16 +59,20 @@ interface nsIMsgOfflineImapOperation : n</span>
<a href="#l3.23"></a><span id="l3.23">   const long kAppendTemplate    = 0x100;</span>
<a href="#l3.24"></a><span id="l3.24">   const long kDeleteAllMsgs     = 0x200;</span>
<a href="#l3.25"></a><span id="l3.25">   const long kAddKeywords       = 0x400;</span>
<a href="#l3.26"></a><span id="l3.26">   const long kRemoveKeywords    = 0x800;</span>
<a href="#l3.27"></a><span id="l3.27"> </span>
<a href="#l3.28"></a><span id="l3.28">   attribute nsOfflineImapOperationType operation;</span>
<a href="#l3.29"></a><span id="l3.29">   void clearOperation(in nsOfflineImapOperationType operation);</span>
<a href="#l3.30"></a><span id="l3.30">   attribute nsMsgKey messageKey;</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+  // for move/copy operations, the msg key of the source msg.</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+  attribute nsMsgKey srcMessageKey;</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineplus">+</span>
<a href="#l3.35"></a><span id="l3.35">   attribute imapMessageFlagsType flagOperation;</span>
<a href="#l3.36"></a><span id="l3.36">   attribute imapMessageFlagsType newFlags; // for kFlagsChanged</span>
<a href="#l3.37"></a><span id="l3.37">   attribute string destinationFolderURI; // for move or copy</span>
<a href="#l3.38"></a><span id="l3.38">   attribute string sourceFolderURI;</span>
<a href="#l3.39"></a><span id="l3.39">   void addKeywordToAdd(in string aKeyword);</span>
<a href="#l3.40"></a><span id="l3.40">   void addKeywordToRemove(in string aKeyword);</span>
<a href="#l3.41"></a><span id="l3.41">   readonly attribute string keywordsToAdd; </span>
<a href="#l3.42"></a><span id="l3.42">   readonly attribute string keywordsToRemove;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/db/msgdb/public/nsMsgDatabase.h</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/db/msgdb/public/nsMsgDatabase.h</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -188,17 +188,17 @@ protected:</span>
<a href="#l4.4"></a><span id="l4.4">   virtual nsresult AddNewThread(nsMsgHdr *msgHdr);</span>
<a href="#l4.5"></a><span id="l4.5">   virtual nsresult AddToThread(nsMsgHdr *newHdr, nsIMsgThread *thread, nsIMsgDBHdr *pMsgHdr, PRBool threadInThread);</span>
<a href="#l4.6"></a><span id="l4.6">   </span>
<a href="#l4.7"></a><span id="l4.7">   </span>
<a href="#l4.8"></a><span id="l4.8">   // open db cache</span>
<a href="#l4.9"></a><span id="l4.9">   static void    AddToCache(nsMsgDatabase* pMessageDB) </span>
<a href="#l4.10"></a><span id="l4.10">   {</span>
<a href="#l4.11"></a><span id="l4.11"> #ifdef DEBUG_David_Bienvenu</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-//    NS_ASSERTION(GetNumInCache() &lt; 40, &quot;40 or more open db's&quot;);</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+//    NS_ASSERTION(GetNumInCache() &lt; 50, &quot;50 or more open db's&quot;);</span>
<a href="#l4.14"></a><span id="l4.14"> #endif</span>
<a href="#l4.15"></a><span id="l4.15">     GetDBCache()-&gt;AppendElement(pMessageDB);}</span>
<a href="#l4.16"></a><span id="l4.16">   static void    RemoveFromCache(nsMsgDatabase* pMessageDB);</span>
<a href="#l4.17"></a><span id="l4.17">   static int    FindInCache(nsMsgDatabase* pMessageDB);</span>
<a href="#l4.18"></a><span id="l4.18">   PRBool  MatchDbName(nsILocalFile *dbName);  // returns TRUE if they match</span>
<a href="#l4.19"></a><span id="l4.19">   </span>
<a href="#l4.20"></a><span id="l4.20">   // Flag handling routines</span>
<a href="#l4.21"></a><span id="l4.21">   virtual nsresult SetKeyFlag(nsMsgKey key, PRBool set, PRUint32 flag,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/db/msgdb/src/nsMsgOfflineImapOperation.cpp</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/db/msgdb/src/nsMsgOfflineImapOperation.cpp</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -135,16 +135,28 @@ NS_IMETHODIMP nsMsgOfflineImapOperation:</span>
<a href="#l5.4"></a><span id="l5.4"> }</span>
<a href="#l5.5"></a><span id="l5.5"> </span>
<a href="#l5.6"></a><span id="l5.6"> NS_IMETHODIMP nsMsgOfflineImapOperation::SetMessageKey(nsMsgKey aMessageKey)</span>
<a href="#l5.7"></a><span id="l5.7"> {</span>
<a href="#l5.8"></a><span id="l5.8">   m_messageKey = aMessageKey;</span>
<a href="#l5.9"></a><span id="l5.9">   return m_mdb-&gt;SetUint32Property(m_mdbRow, PROP_MESSAGE_KEY, m_messageKey);</span>
<a href="#l5.10"></a><span id="l5.10"> }</span>
<a href="#l5.11"></a><span id="l5.11"> </span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+/* attribute nsMsgKey srcMessageKey; */</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+NS_IMETHODIMP nsMsgOfflineImapOperation::GetSrcMessageKey(nsMsgKey *aMessageKey)</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+{</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+  NS_ENSURE_ARG(aMessageKey);</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineplus">+  return m_mdb-&gt;GetUint32Property(m_mdbRow, PROP_SRC_MESSAGE_KEY, aMessageKey, nsMsgKey_None);</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineplus">+}</span>
<a href="#l5.18"></a><span id="l5.18" class="difflineplus">+</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineplus">+NS_IMETHODIMP nsMsgOfflineImapOperation::SetSrcMessageKey(nsMsgKey aMessageKey)</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineplus">+{</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+  m_messageKey = aMessageKey;</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+  return m_mdb-&gt;SetUint32Property(m_mdbRow, PROP_SRC_MESSAGE_KEY, m_messageKey);</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+}</span>
<a href="#l5.24"></a><span id="l5.24"> </span>
<a href="#l5.25"></a><span id="l5.25"> /* attribute imapMessageFlagsType flagOperation; */</span>
<a href="#l5.26"></a><span id="l5.26"> NS_IMETHODIMP nsMsgOfflineImapOperation::GetFlagOperation(imapMessageFlagsType *aFlagOperation)</span>
<a href="#l5.27"></a><span id="l5.27"> {</span>
<a href="#l5.28"></a><span id="l5.28">   NS_ENSURE_ARG(aFlagOperation);</span>
<a href="#l5.29"></a><span id="l5.29">   *aFlagOperation = m_operationFlags;</span>
<a href="#l5.30"></a><span id="l5.30">   return NS_OK;</span>
<a href="#l5.31"></a><span id="l5.31"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -3416,33 +3416,87 @@ NS_IMETHODIMP nsImapMailFolder::SetImapF</span>
<a href="#l6.4"></a><span id="l6.4"> NS_IMETHODIMP nsImapMailFolder::PlaybackOfflineFolderCreate(const nsAString&amp; aFolderName, nsIMsgWindow *aWindow, nsIURI **url)</span>
<a href="#l6.5"></a><span id="l6.5"> {</span>
<a href="#l6.6"></a><span id="l6.6">   nsresult rv;</span>
<a href="#l6.7"></a><span id="l6.7">   nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l6.8"></a><span id="l6.8">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l6.9"></a><span id="l6.9">   return imapService-&gt;CreateFolder(m_thread, this, aFolderName, this, url);</span>
<a href="#l6.10"></a><span id="l6.10"> }</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-NS_IMETHODIMP nsImapMailFolder::ReplayOfflineMoveCopy(nsMsgKey *msgKeys, PRUint32 numKeys, PRBool isMove, nsIMsgFolder *aDstFolder,</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineminus">-                                                      nsIUrlListener *aUrlListener, nsIMsgWindow *aWindow)</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+NS_IMETHODIMP </span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+nsImapMailFolder::ReplayOfflineMoveCopy(nsMsgKey *aMsgKeys, PRUint32 aNumKeys,</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+                                        PRBool isMove, nsIMsgFolder *aDstFolder,</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineplus">+                                        nsIUrlListener *aUrlListener, nsIMsgWindow *aWindow)</span>
<a href="#l6.18"></a><span id="l6.18"> {</span>
<a href="#l6.19"></a><span id="l6.19">   nsresult rv;</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineplus">+</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineplus">+  nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(aDstFolder);</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineplus">+  if (imapFolder)</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineplus">+  {</span>
<a href="#l6.24"></a><span id="l6.24" class="difflineplus">+    nsImapMailFolder *destImapFolder = static_cast&lt;nsImapMailFolder*&gt;(aDstFolder);</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineplus">+    nsCOMPtr&lt;nsIMutableArray&gt; messages(do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l6.26"></a><span id="l6.26" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDatabase&gt; dstFolderDB;</span>
<a href="#l6.27"></a><span id="l6.27" class="difflineplus">+    aDstFolder-&gt;GetMsgDatabase(getter_AddRefs(dstFolderDB));</span>
<a href="#l6.28"></a><span id="l6.28" class="difflineplus">+    if (dstFolderDB)</span>
<a href="#l6.29"></a><span id="l6.29" class="difflineplus">+    {</span>
<a href="#l6.30"></a><span id="l6.30" class="difflineplus">+      // find the fake header in the destination db, and use that to</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineplus">+      // set the pending attributes on the real headers. To do this,</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+      // we need to iterate over the offline ops in the destination db,</span>
<a href="#l6.33"></a><span id="l6.33" class="difflineplus">+      // looking for ones with matching keys and source folder uri. </span>
<a href="#l6.34"></a><span id="l6.34" class="difflineplus">+      // If we find that offline op, its &quot;key&quot; will be the key of the fake</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineplus">+      // header, so we just need to get the header for that key </span>
<a href="#l6.36"></a><span id="l6.36" class="difflineplus">+      // from the dest db.</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineplus">+      nsTArray&lt;nsMsgKey&gt; offlineOps;</span>
<a href="#l6.38"></a><span id="l6.38" class="difflineplus">+      if (NS_SUCCEEDED(dstFolderDB-&gt;ListAllOfflineOpIds(&amp;offlineOps)))</span>
<a href="#l6.39"></a><span id="l6.39" class="difflineplus">+      {</span>
<a href="#l6.40"></a><span id="l6.40" class="difflineplus">+        nsCString srcFolderUri;</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineplus">+        GetURI(srcFolderUri);</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineplus">+        for (PRUint32 msgIndex = 0; msgIndex &lt; aNumKeys; msgIndex++)</span>
<a href="#l6.43"></a><span id="l6.43" class="difflineplus">+        {</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineplus">+          nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; currentOp;</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineplus">+          for (PRUint32 opIndex = 0; opIndex &lt; offlineOps.Length(); opIndex++)</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineplus">+          {</span>
<a href="#l6.47"></a><span id="l6.47" class="difflineplus">+            dstFolderDB-&gt;GetOfflineOpForKey(offlineOps[opIndex], PR_FALSE,</span>
<a href="#l6.48"></a><span id="l6.48" class="difflineplus">+                                            getter_AddRefs(currentOp));</span>
<a href="#l6.49"></a><span id="l6.49" class="difflineplus">+            if (currentOp)</span>
<a href="#l6.50"></a><span id="l6.50" class="difflineplus">+            {</span>
<a href="#l6.51"></a><span id="l6.51" class="difflineplus">+              nsMsgKey srcMessageKey;</span>
<a href="#l6.52"></a><span id="l6.52" class="difflineplus">+              currentOp-&gt;GetSrcMessageKey(&amp;srcMessageKey);</span>
<a href="#l6.53"></a><span id="l6.53" class="difflineplus">+              if (srcMessageKey == aMsgKeys[msgIndex])</span>
<a href="#l6.54"></a><span id="l6.54" class="difflineplus">+              {</span>
<a href="#l6.55"></a><span id="l6.55" class="difflineplus">+                nsCString opSrcUri;</span>
<a href="#l6.56"></a><span id="l6.56" class="difflineplus">+                currentOp-&gt;GetSourceFolderURI(getter_Copies(opSrcUri));</span>
<a href="#l6.57"></a><span id="l6.57" class="difflineplus">+                if (opSrcUri.Equals(srcFolderUri))</span>
<a href="#l6.58"></a><span id="l6.58" class="difflineplus">+                {</span>
<a href="#l6.59"></a><span id="l6.59" class="difflineplus">+                  nsCOMPtr&lt;nsIMsgDBHdr&gt; fakeDestHdr;</span>
<a href="#l6.60"></a><span id="l6.60" class="difflineplus">+                  dstFolderDB-&gt;GetMsgHdrForKey(offlineOps[opIndex],</span>
<a href="#l6.61"></a><span id="l6.61" class="difflineplus">+                    getter_AddRefs(fakeDestHdr));</span>
<a href="#l6.62"></a><span id="l6.62" class="difflineplus">+                  if (fakeDestHdr)</span>
<a href="#l6.63"></a><span id="l6.63" class="difflineplus">+                    messages-&gt;AppendElement(fakeDestHdr, PR_FALSE);</span>
<a href="#l6.64"></a><span id="l6.64" class="difflineplus">+                  break;</span>
<a href="#l6.65"></a><span id="l6.65" class="difflineplus">+                }</span>
<a href="#l6.66"></a><span id="l6.66" class="difflineplus">+              }</span>
<a href="#l6.67"></a><span id="l6.67" class="difflineplus">+            }</span>
<a href="#l6.68"></a><span id="l6.68" class="difflineplus">+          }</span>
<a href="#l6.69"></a><span id="l6.69" class="difflineplus">+        }</span>
<a href="#l6.70"></a><span id="l6.70" class="difflineplus">+        destImapFolder-&gt;SetPendingAttributes(messages);</span>
<a href="#l6.71"></a><span id="l6.71" class="difflineplus">+      }</span>
<a href="#l6.72"></a><span id="l6.72" class="difflineplus">+    }</span>
<a href="#l6.73"></a><span id="l6.73" class="difflineplus">+    // if we can't get the dst folder db, we should still try to playback</span>
<a href="#l6.74"></a><span id="l6.74" class="difflineplus">+    // the offline move/copy.</span>
<a href="#l6.75"></a><span id="l6.75" class="difflineplus">+  }</span>
<a href="#l6.76"></a><span id="l6.76" class="difflineplus">+</span>
<a href="#l6.77"></a><span id="l6.77">   nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l6.78"></a><span id="l6.78">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l6.79"></a><span id="l6.79">   nsCOMPtr &lt;nsIURI&gt; resultUrl;</span>
<a href="#l6.80"></a><span id="l6.80">   nsCAutoString uids;</span>
<a href="#l6.81"></a><span id="l6.81" class="difflineminus">-  AllocateUidStringFromKeys(msgKeys, numKeys, uids);</span>
<a href="#l6.82"></a><span id="l6.82" class="difflineminus">-  rv = imapService-&gt;OnlineMessageCopy(m_thread,</span>
<a href="#l6.83"></a><span id="l6.83" class="difflineminus">-                       this,</span>
<a href="#l6.84"></a><span id="l6.84" class="difflineminus">-                                      uids,</span>
<a href="#l6.85"></a><span id="l6.85" class="difflineminus">-                       aDstFolder,</span>
<a href="#l6.86"></a><span id="l6.86" class="difflineminus">-                       PR_TRUE,</span>
<a href="#l6.87"></a><span id="l6.87" class="difflineminus">-                       isMove,</span>
<a href="#l6.88"></a><span id="l6.88" class="difflineminus">-                       aUrlListener,</span>
<a href="#l6.89"></a><span id="l6.89" class="difflineminus">-                       getter_AddRefs(resultUrl), nsnull, aWindow);</span>
<a href="#l6.90"></a><span id="l6.90" class="difflineplus">+  AllocateUidStringFromKeys(aMsgKeys, aNumKeys, uids);</span>
<a href="#l6.91"></a><span id="l6.91" class="difflineplus">+  rv = imapService-&gt;OnlineMessageCopy(m_thread, this, uids, aDstFolder,</span>
<a href="#l6.92"></a><span id="l6.92" class="difflineplus">+                                      PR_TRUE, isMove, aUrlListener,</span>
<a href="#l6.93"></a><span id="l6.93" class="difflineplus">+                                      getter_AddRefs(resultUrl), nsnull, aWindow);</span>
<a href="#l6.94"></a><span id="l6.94">   if (resultUrl)</span>
<a href="#l6.95"></a><span id="l6.95">   {</span>
<a href="#l6.96"></a><span id="l6.96">     nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(resultUrl, &amp;rv);</span>
<a href="#l6.97"></a><span id="l6.97">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l6.98"></a><span id="l6.98">     nsCOMPtr &lt;nsIUrlListener&gt; folderListener = do_QueryInterface(aDstFolder);</span>
<a href="#l6.99"></a><span id="l6.99">     if (folderListener)</span>
<a href="#l6.100"></a><span id="l6.100">       mailnewsUrl-&gt;RegisterListener(folderListener);</span>
<a href="#l6.101"></a><span id="l6.101">   }</span>
<a href="#l6.102"></a><span id="l6.102" class="difflineat">@@ -6427,17 +6481,17 @@ nsresult nsImapMailFolder::CopyMessagesO</span>
<a href="#l6.103"></a><span id="l6.103">               // check if this is a move back to the original mailbox, in which case</span>
<a href="#l6.104"></a><span id="l6.104">               // we just delete the offline operation.</span>
<a href="#l6.105"></a><span id="l6.105">               if (messageReturningHome)</span>
<a href="#l6.106"></a><span id="l6.106">                 mDatabase-&gt;RemoveOfflineOp(destOp);</span>
<a href="#l6.107"></a><span id="l6.107">               else</span>
<a href="#l6.108"></a><span id="l6.108">               {</span>
<a href="#l6.109"></a><span id="l6.109">                 SetFlag(nsMsgFolderFlags::OfflineEvents);</span>
<a href="#l6.110"></a><span id="l6.110">                 destOp-&gt;SetSourceFolderURI(originalSrcFolderURI.get());</span>
<a href="#l6.111"></a><span id="l6.111" class="difflineminus">-                destOp-&gt;SetMessageKey(originalKey);</span>
<a href="#l6.112"></a><span id="l6.112" class="difflineplus">+                destOp-&gt;SetSrcMessageKey(originalKey);</span>
<a href="#l6.113"></a><span id="l6.113">                 {</span>
<a href="#l6.114"></a><span id="l6.114">                   nsCOMPtr&lt;nsIUrlListener&gt; urlListener;</span>
<a href="#l6.115"></a><span id="l6.115">                   QueryInterface(NS_GET_IID(nsIUrlListener), getter_AddRefs(urlListener));</span>
<a href="#l6.116"></a><span id="l6.116">                   nsTArray&lt;nsMsgKey&gt; keyArray;</span>
<a href="#l6.117"></a><span id="l6.117">                   keyArray.AppendElement(fakeBase + sourceKeyIndex);</span>
<a href="#l6.118"></a><span id="l6.118">                   nsImapOfflineTxn *undoMsgTxn = new</span>
<a href="#l6.119"></a><span id="l6.119">                     nsImapOfflineTxn(this, &amp;keyArray, nsnull, this, isMove, nsIMsgOfflineImapOperation::kAddedHeader,</span>
<a href="#l6.120"></a><span id="l6.120">                       newMailHdr, m_thread, urlListener);</span>
<a href="#l6.121"></a><span id="l6.121" class="difflineat">@@ -6516,16 +6570,80 @@ nsresult nsImapMailFolder::CopyMessagesO</span>
<a href="#l6.122"></a><span id="l6.122">   nsCOMPtr&lt;nsISupports&gt; srcSupport = do_QueryInterface(srcFolder);</span>
<a href="#l6.123"></a><span id="l6.123">   OnCopyCompleted(srcSupport, rv);</span>
<a href="#l6.124"></a><span id="l6.124"> </span>
<a href="#l6.125"></a><span id="l6.125">   if (NS_SUCCEEDED(rv) &amp;&amp; isMove)</span>
<a href="#l6.126"></a><span id="l6.126">     srcFolder-&gt;NotifyFolderEvent(mDeleteOrMoveMsgCompletedAtom);</span>
<a href="#l6.127"></a><span id="l6.127">   return rv;</span>
<a href="#l6.128"></a><span id="l6.128"> }</span>
<a href="#l6.129"></a><span id="l6.129"> </span>
<a href="#l6.130"></a><span id="l6.130" class="difflineplus">+void nsImapMailFolder::SetPendingAttributes(nsIArray* messages)</span>
<a href="#l6.131"></a><span id="l6.131" class="difflineplus">+{</span>
<a href="#l6.132"></a><span id="l6.132" class="difflineplus">+</span>
<a href="#l6.133"></a><span id="l6.133" class="difflineplus">+  GetDatabase();</span>
<a href="#l6.134"></a><span id="l6.134" class="difflineplus">+  if (!mDatabase)</span>
<a href="#l6.135"></a><span id="l6.135" class="difflineplus">+    return;</span>
<a href="#l6.136"></a><span id="l6.136" class="difflineplus">+</span>
<a href="#l6.137"></a><span id="l6.137" class="difflineplus">+  PRUint32 supportedUserFlags;</span>
<a href="#l6.138"></a><span id="l6.138" class="difflineplus">+  GetSupportedUserFlags(&amp;supportedUserFlags);</span>
<a href="#l6.139"></a><span id="l6.139" class="difflineplus">+</span>
<a href="#l6.140"></a><span id="l6.140" class="difflineplus">+  PRUint32 i, count;</span>
<a href="#l6.141"></a><span id="l6.141" class="difflineplus">+</span>
<a href="#l6.142"></a><span id="l6.142" class="difflineplus">+  nsresult rv = messages-&gt;GetLength(&amp;count);</span>
<a href="#l6.143"></a><span id="l6.143" class="difflineplus">+  if (NS_FAILED(rv)) </span>
<a href="#l6.144"></a><span id="l6.144" class="difflineplus">+    return;</span>
<a href="#l6.145"></a><span id="l6.145" class="difflineplus">+</span>
<a href="#l6.146"></a><span id="l6.146" class="difflineplus">+  // check if any msg hdr has special flags or properties set</span>
<a href="#l6.147"></a><span id="l6.147" class="difflineplus">+  // that we need to set on the dest hdr</span>
<a href="#l6.148"></a><span id="l6.148" class="difflineplus">+  for (i = 0; i &lt; count; i++)</span>
<a href="#l6.149"></a><span id="l6.149" class="difflineplus">+  {</span>
<a href="#l6.150"></a><span id="l6.150" class="difflineplus">+    nsCOMPtr &lt;nsIMsgDBHdr&gt; msgDBHdr = do_QueryElementAt(messages, i, &amp;rv);</span>
<a href="#l6.151"></a><span id="l6.151" class="difflineplus">+    if (mDatabase &amp;&amp; msgDBHdr)</span>
<a href="#l6.152"></a><span id="l6.152" class="difflineplus">+    {</span>
<a href="#l6.153"></a><span id="l6.153" class="difflineplus">+      if (!(supportedUserFlags &amp; kImapMsgSupportUserFlag))</span>
<a href="#l6.154"></a><span id="l6.154" class="difflineplus">+      {</span>
<a href="#l6.155"></a><span id="l6.155" class="difflineplus">+        nsMsgLabelValue label;</span>
<a href="#l6.156"></a><span id="l6.156" class="difflineplus">+        nsCString junkScore;</span>
<a href="#l6.157"></a><span id="l6.157" class="difflineplus">+        msgDBHdr-&gt;GetStringProperty(&quot;junkscore&quot;, getter_Copies(junkScore));</span>
<a href="#l6.158"></a><span id="l6.158" class="difflineplus">+        if (!junkScore.IsEmpty()) // ignore already scored messages.</span>
<a href="#l6.159"></a><span id="l6.159" class="difflineplus">+          mDatabase-&gt;SetAttributesOnPendingHdr(msgDBHdr, &quot;junkscore&quot;, junkScore.get(), 0);</span>
<a href="#l6.160"></a><span id="l6.160" class="difflineplus">+        msgDBHdr-&gt;GetLabel(&amp;label);</span>
<a href="#l6.161"></a><span id="l6.161" class="difflineplus">+        if (label != 0)</span>
<a href="#l6.162"></a><span id="l6.162" class="difflineplus">+        {</span>
<a href="#l6.163"></a><span id="l6.163" class="difflineplus">+          nsCAutoString labelStr;</span>
<a href="#l6.164"></a><span id="l6.164" class="difflineplus">+          labelStr.AppendInt(label);</span>
<a href="#l6.165"></a><span id="l6.165" class="difflineplus">+          mDatabase-&gt;SetAttributesOnPendingHdr(msgDBHdr, &quot;label&quot;, labelStr.get(), 0);</span>
<a href="#l6.166"></a><span id="l6.166" class="difflineplus">+        }</span>
<a href="#l6.167"></a><span id="l6.167" class="difflineplus">+        nsCString keywords;</span>
<a href="#l6.168"></a><span id="l6.168" class="difflineplus">+        msgDBHdr-&gt;GetStringProperty(&quot;keywords&quot;, getter_Copies(keywords));</span>
<a href="#l6.169"></a><span id="l6.169" class="difflineplus">+        if (!keywords.IsEmpty())</span>
<a href="#l6.170"></a><span id="l6.170" class="difflineplus">+          mDatabase-&gt;SetAttributesOnPendingHdr(msgDBHdr, &quot;keywords&quot;, keywords.get(), 0);</span>
<a href="#l6.171"></a><span id="l6.171" class="difflineplus">+      } </span>
<a href="#l6.172"></a><span id="l6.172" class="difflineplus">+      // do this even if the server supports user-defined flags.</span>
<a href="#l6.173"></a><span id="l6.173" class="difflineplus">+      </span>
<a href="#l6.174"></a><span id="l6.174" class="difflineplus">+      nsCString junkScoreOrigin, junkPercent;</span>
<a href="#l6.175"></a><span id="l6.175" class="difflineplus">+      msgDBHdr-&gt;GetStringProperty(&quot;junkscoreorigin&quot;, getter_Copies(junkScoreOrigin));</span>
<a href="#l6.176"></a><span id="l6.176" class="difflineplus">+      msgDBHdr-&gt;GetStringProperty(&quot;junkpercent&quot;, getter_Copies(junkPercent));</span>
<a href="#l6.177"></a><span id="l6.177" class="difflineplus">+      if (!junkScoreOrigin.IsEmpty())</span>
<a href="#l6.178"></a><span id="l6.178" class="difflineplus">+        mDatabase-&gt;SetAttributesOnPendingHdr(msgDBHdr, &quot;junkscoreorigin&quot;, junkScoreOrigin.get(), 0);</span>
<a href="#l6.179"></a><span id="l6.179" class="difflineplus">+      if (!junkPercent.IsEmpty())</span>
<a href="#l6.180"></a><span id="l6.180" class="difflineplus">+        mDatabase-&gt;SetAttributesOnPendingHdr(msgDBHdr, &quot;junkpercent&quot;, junkPercent.get(), 0);             </span>
<a href="#l6.181"></a><span id="l6.181" class="difflineplus">+      </span>
<a href="#l6.182"></a><span id="l6.182" class="difflineplus">+      nsMsgPriorityValue priority;</span>
<a href="#l6.183"></a><span id="l6.183" class="difflineplus">+      msgDBHdr-&gt;GetPriority(&amp;priority);</span>
<a href="#l6.184"></a><span id="l6.184" class="difflineplus">+      if(priority != 0)</span>
<a href="#l6.185"></a><span id="l6.185" class="difflineplus">+      {</span>
<a href="#l6.186"></a><span id="l6.186" class="difflineplus">+        nsCAutoString priorityStr;</span>
<a href="#l6.187"></a><span id="l6.187" class="difflineplus">+        priorityStr.AppendInt(priority);</span>
<a href="#l6.188"></a><span id="l6.188" class="difflineplus">+        mDatabase-&gt;SetAttributesOnPendingHdr(msgDBHdr, &quot;priority&quot;, priorityStr.get(), 0);</span>
<a href="#l6.189"></a><span id="l6.189" class="difflineplus">+      }</span>
<a href="#l6.190"></a><span id="l6.190" class="difflineplus">+    }</span>
<a href="#l6.191"></a><span id="l6.191" class="difflineplus">+  }</span>
<a href="#l6.192"></a><span id="l6.192" class="difflineplus">+}</span>
<a href="#l6.193"></a><span id="l6.193" class="difflineplus">+</span>
<a href="#l6.194"></a><span id="l6.194"> NS_IMETHODIMP</span>
<a href="#l6.195"></a><span id="l6.195"> nsImapMailFolder::CopyMessages(nsIMsgFolder* srcFolder,</span>
<a href="#l6.196"></a><span id="l6.196">                                nsIArray* messages,</span>
<a href="#l6.197"></a><span id="l6.197">                                PRBool isMove,</span>
<a href="#l6.198"></a><span id="l6.198">                                nsIMsgWindow *msgWindow,</span>
<a href="#l6.199"></a><span id="l6.199">                                nsIMsgCopyServiceListener* listener,</span>
<a href="#l6.200"></a><span id="l6.200">                                PRBool isFolder, //isFolder for future use when we do cross-server folder move/copy</span>
<a href="#l6.201"></a><span id="l6.201">                                PRBool allowUndo)</span>
<a href="#l6.202"></a><span id="l6.202" class="difflineat">@@ -6602,122 +6720,64 @@ nsImapMailFolder::CopyMessages(nsIMsgFol</span>
<a href="#l6.203"></a><span id="l6.203">     PRUint32 count = 0; // needs to be inited before goto</span>
<a href="#l6.204"></a><span id="l6.204">     </span>
<a href="#l6.205"></a><span id="l6.205">     if (WeAreOffline())</span>
<a href="#l6.206"></a><span id="l6.206">       return CopyMessagesOffline(srcFolder, messages, isMove, msgWindow, listener);</span>
<a href="#l6.207"></a><span id="l6.207">     </span>
<a href="#l6.208"></a><span id="l6.208">     nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l6.209"></a><span id="l6.209">     NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l6.210"></a><span id="l6.210">     </span>
<a href="#l6.211"></a><span id="l6.211" class="difflineminus">-  PRUint32 supportedUserFlags;</span>
<a href="#l6.212"></a><span id="l6.212" class="difflineminus">-  GetSupportedUserFlags(&amp;supportedUserFlags);</span>
<a href="#l6.213"></a><span id="l6.213" class="difflineminus">-</span>
<a href="#l6.214"></a><span id="l6.214" class="difflineminus">-  PRUint32 i;</span>
<a href="#l6.215"></a><span id="l6.215" class="difflineminus">-</span>
<a href="#l6.216"></a><span id="l6.216" class="difflineminus">-  rv = messages-&gt;GetLength(&amp;count);</span>
<a href="#l6.217"></a><span id="l6.217" class="difflineminus">-  if (NS_FAILED(rv)) return rv;</span>
<a href="#l6.218"></a><span id="l6.218" class="difflineminus">-</span>
<a href="#l6.219"></a><span id="l6.219" class="difflineminus">-  // make sure database is open to set special flags below</span>
<a href="#l6.220"></a><span id="l6.220" class="difflineminus">-  if (!mDatabase)</span>
<a href="#l6.221"></a><span id="l6.221" class="difflineminus">-    GetDatabase();</span>
<a href="#l6.222"></a><span id="l6.222" class="difflineminus">-</span>
<a href="#l6.223"></a><span id="l6.223" class="difflineminus">-  // check if any msg hdr has special flags or properties set</span>
<a href="#l6.224"></a><span id="l6.224" class="difflineminus">-  // that we need to set on the dest hdr</span>
<a href="#l6.225"></a><span id="l6.225" class="difflineminus">-  for (i = 0; i &lt; count; i++)</span>
<a href="#l6.226"></a><span id="l6.226" class="difflineminus">-  {</span>
<a href="#l6.227"></a><span id="l6.227" class="difflineminus">-    nsCOMPtr &lt;nsIMsgDBHdr&gt; msgDBHdr = do_QueryElementAt(messages, i, &amp;rv);</span>
<a href="#l6.228"></a><span id="l6.228" class="difflineminus">-    if (mDatabase &amp;&amp; msgDBHdr)</span>
<a href="#l6.229"></a><span id="l6.229" class="difflineminus">-    {</span>
<a href="#l6.230"></a><span id="l6.230" class="difflineminus">-      if (!(supportedUserFlags &amp; kImapMsgSupportUserFlag))</span>
<a href="#l6.231"></a><span id="l6.231" class="difflineminus">-      {</span>
<a href="#l6.232"></a><span id="l6.232" class="difflineminus">-        nsMsgLabelValue label;</span>
<a href="#l6.233"></a><span id="l6.233" class="difflineminus">-        nsCString junkScore;</span>
<a href="#l6.234"></a><span id="l6.234" class="difflineminus">-        msgDBHdr-&gt;GetStringProperty(&quot;junkscore&quot;, getter_Copies(junkScore));</span>
<a href="#l6.235"></a><span id="l6.235" class="difflineminus">-        if (!junkScore.IsEmpty()) // ignore already scored messages.</span>
<a href="#l6.236"></a><span id="l6.236" class="difflineminus">-          mDatabase-&gt;SetAttributesOnPendingHdr(msgDBHdr, &quot;junkscore&quot;, junkScore.get(), 0);</span>
<a href="#l6.237"></a><span id="l6.237" class="difflineminus">-        msgDBHdr-&gt;GetLabel(&amp;label);</span>
<a href="#l6.238"></a><span id="l6.238" class="difflineminus">-        if (label != 0)</span>
<a href="#l6.239"></a><span id="l6.239" class="difflineminus">-        {</span>
<a href="#l6.240"></a><span id="l6.240" class="difflineminus">-          nsCAutoString labelStr;</span>
<a href="#l6.241"></a><span id="l6.241" class="difflineminus">-          labelStr.AppendInt(label);</span>
<a href="#l6.242"></a><span id="l6.242" class="difflineminus">-          mDatabase-&gt;SetAttributesOnPendingHdr(msgDBHdr, &quot;label&quot;, labelStr.get(), 0);</span>
<a href="#l6.243"></a><span id="l6.243" class="difflineminus">-        }</span>
<a href="#l6.244"></a><span id="l6.244" class="difflineminus">-        nsCString keywords;</span>
<a href="#l6.245"></a><span id="l6.245" class="difflineminus">-        msgDBHdr-&gt;GetStringProperty(&quot;keywords&quot;, getter_Copies(keywords));</span>
<a href="#l6.246"></a><span id="l6.246" class="difflineminus">-        if (!keywords.IsEmpty())</span>
<a href="#l6.247"></a><span id="l6.247" class="difflineminus">-          mDatabase-&gt;SetAttributesOnPendingHdr(msgDBHdr, &quot;keywords&quot;, keywords.get(), 0);</span>
<a href="#l6.248"></a><span id="l6.248" class="difflineminus">-      } </span>
<a href="#l6.249"></a><span id="l6.249" class="difflineminus">-      // do this even if the server supports user-defined flags.</span>
<a href="#l6.250"></a><span id="l6.250" class="difflineminus">-      </span>
<a href="#l6.251"></a><span id="l6.251" class="difflineminus">-      nsCString junkScoreOrigin, junkPercent;</span>
<a href="#l6.252"></a><span id="l6.252" class="difflineminus">-      msgDBHdr-&gt;GetStringProperty(&quot;junkscoreorigin&quot;, getter_Copies(junkScoreOrigin));</span>
<a href="#l6.253"></a><span id="l6.253" class="difflineminus">-      msgDBHdr-&gt;GetStringProperty(&quot;junkpercent&quot;, getter_Copies(junkPercent));</span>
<a href="#l6.254"></a><span id="l6.254" class="difflineminus">-      if (!junkScoreOrigin.IsEmpty())</span>
<a href="#l6.255"></a><span id="l6.255" class="difflineminus">-        mDatabase-&gt;SetAttributesOnPendingHdr(msgDBHdr, &quot;junkscoreorigin&quot;, junkScoreOrigin.get(), 0);</span>
<a href="#l6.256"></a><span id="l6.256" class="difflineminus">-      if (!junkPercent.IsEmpty())</span>
<a href="#l6.257"></a><span id="l6.257" class="difflineminus">-        mDatabase-&gt;SetAttributesOnPendingHdr(msgDBHdr, &quot;junkpercent&quot;, junkPercent.get(), 0);             </span>
<a href="#l6.258"></a><span id="l6.258" class="difflineminus">-      </span>
<a href="#l6.259"></a><span id="l6.259" class="difflineminus">-      nsMsgPriorityValue priority;</span>
<a href="#l6.260"></a><span id="l6.260" class="difflineminus">-      msgDBHdr-&gt;GetPriority(&amp;priority);</span>
<a href="#l6.261"></a><span id="l6.261" class="difflineminus">-      if(priority != 0)</span>
<a href="#l6.262"></a><span id="l6.262" class="difflineplus">+    SetPendingAttributes(messages);</span>
<a href="#l6.263"></a><span id="l6.263" class="difflineplus">+    // if the folders aren't on the same server, do a stream base copy</span>
<a href="#l6.264"></a><span id="l6.264" class="difflineplus">+    if (!sameServer)</span>
<a href="#l6.265"></a><span id="l6.265" class="difflineplus">+    {</span>
<a href="#l6.266"></a><span id="l6.266" class="difflineplus">+      rv = CopyMessagesWithStream(srcFolder, messages, isMove, PR_TRUE, msgWindow, listener, allowUndo);</span>
<a href="#l6.267"></a><span id="l6.267" class="difflineplus">+      goto done;</span>
<a href="#l6.268"></a><span id="l6.268" class="difflineplus">+    }</span>
<a href="#l6.269"></a><span id="l6.269" class="difflineplus">+</span>
<a href="#l6.270"></a><span id="l6.270" class="difflineplus">+    rv = BuildIdsAndKeyArray(messages, messageIds, srcKeyArray);</span>
<a href="#l6.271"></a><span id="l6.271" class="difflineplus">+    if(NS_FAILED(rv)) goto done;</span>
<a href="#l6.272"></a><span id="l6.272" class="difflineplus">+</span>
<a href="#l6.273"></a><span id="l6.273" class="difflineplus">+    rv = QueryInterface(NS_GET_IID(nsIUrlListener), getter_AddRefs(urlListener));</span>
<a href="#l6.274"></a><span id="l6.274" class="difflineplus">+    rv = InitCopyState(srcSupport, messages, isMove, PR_TRUE, PR_FALSE,</span>
<a href="#l6.275"></a><span id="l6.275" class="difflineplus">+                       0, EmptyCString(), listener, msgWindow, allowUndo);</span>
<a href="#l6.276"></a><span id="l6.276" class="difflineplus">+    if (NS_FAILED(rv)) goto done;</span>
<a href="#l6.277"></a><span id="l6.277" class="difflineplus">+</span>
<a href="#l6.278"></a><span id="l6.278" class="difflineplus">+    m_copyState-&gt;m_curIndex = m_copyState-&gt;m_totalCount;</span>
<a href="#l6.279"></a><span id="l6.279" class="difflineplus">+</span>
<a href="#l6.280"></a><span id="l6.280" class="difflineplus">+    if (isMove)</span>
<a href="#l6.281"></a><span id="l6.281" class="difflineplus">+      srcFolder-&gt;EnableNotifications(allMessageCountNotifications, PR_FALSE, PR_TRUE/* dbBatching*/);  //disable message count notification</span>
<a href="#l6.282"></a><span id="l6.282" class="difflineplus">+</span>
<a href="#l6.283"></a><span id="l6.283" class="difflineplus">+    copySupport = do_QueryInterface(m_copyState);</span>
<a href="#l6.284"></a><span id="l6.284" class="difflineplus">+    rv = imapService-&gt;OnlineMessageCopy(m_thread,</span>
<a href="#l6.285"></a><span id="l6.285" class="difflineplus">+                                        srcFolder, messageIds,</span>
<a href="#l6.286"></a><span id="l6.286" class="difflineplus">+                                        this, PR_TRUE, isMove,</span>
<a href="#l6.287"></a><span id="l6.287" class="difflineplus">+                                        urlListener, nsnull,</span>
<a href="#l6.288"></a><span id="l6.288" class="difflineplus">+                                        copySupport, msgWindow);</span>
<a href="#l6.289"></a><span id="l6.289" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; m_copyState-&gt;m_allowUndo)</span>
<a href="#l6.290"></a><span id="l6.290" class="difflineplus">+    {</span>
<a href="#l6.291"></a><span id="l6.291" class="difflineplus">+      nsImapMoveCopyMsgTxn* undoMsgTxn = new nsImapMoveCopyMsgTxn;</span>
<a href="#l6.292"></a><span id="l6.292" class="difflineplus">+      if (!undoMsgTxn || NS_FAILED(undoMsgTxn-&gt;Init(srcFolder, &amp;srcKeyArray,</span>
<a href="#l6.293"></a><span id="l6.293" class="difflineplus">+                                   messageIds.get(), this,</span>
<a href="#l6.294"></a><span id="l6.294" class="difflineplus">+                                   PR_TRUE, isMove, m_thread, urlListener)))</span>
<a href="#l6.295"></a><span id="l6.295">       {</span>
<a href="#l6.296"></a><span id="l6.296" class="difflineminus">-        nsCAutoString priorityStr;</span>
<a href="#l6.297"></a><span id="l6.297" class="difflineminus">-        priorityStr.AppendInt(priority);</span>
<a href="#l6.298"></a><span id="l6.298" class="difflineminus">-        mDatabase-&gt;SetAttributesOnPendingHdr(msgDBHdr, &quot;priority&quot;, priorityStr.get(), 0);</span>
<a href="#l6.299"></a><span id="l6.299" class="difflineplus">+        delete undoMsgTxn;</span>
<a href="#l6.300"></a><span id="l6.300" class="difflineplus">+        return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l6.301"></a><span id="l6.301">       }</span>
<a href="#l6.302"></a><span id="l6.302" class="difflineminus">-    }</span>
<a href="#l6.303"></a><span id="l6.303" class="difflineminus">-  }</span>
<a href="#l6.304"></a><span id="l6.304" class="difflineminus">-</span>
<a href="#l6.305"></a><span id="l6.305" class="difflineminus">-  // if the folders aren't on the same server, do a stream base copy</span>
<a href="#l6.306"></a><span id="l6.306" class="difflineminus">-  if (!sameServer)</span>
<a href="#l6.307"></a><span id="l6.307" class="difflineminus">-  {</span>
<a href="#l6.308"></a><span id="l6.308" class="difflineminus">-    rv = CopyMessagesWithStream(srcFolder, messages, isMove, PR_TRUE, msgWindow, listener, allowUndo);</span>
<a href="#l6.309"></a><span id="l6.309" class="difflineminus">-    goto done;</span>
<a href="#l6.310"></a><span id="l6.310" class="difflineminus">-  }</span>
<a href="#l6.311"></a><span id="l6.311" class="difflineminus">-</span>
<a href="#l6.312"></a><span id="l6.312" class="difflineminus">-  rv = BuildIdsAndKeyArray(messages, messageIds, srcKeyArray);</span>
<a href="#l6.313"></a><span id="l6.313" class="difflineminus">-  if(NS_FAILED(rv)) goto done;</span>
<a href="#l6.314"></a><span id="l6.314" class="difflineminus">-</span>
<a href="#l6.315"></a><span id="l6.315" class="difflineminus">-  rv = QueryInterface(NS_GET_IID(nsIUrlListener), getter_AddRefs(urlListener));</span>
<a href="#l6.316"></a><span id="l6.316" class="difflineminus">-  rv = InitCopyState(srcSupport, messages, isMove, PR_TRUE, PR_FALSE,</span>
<a href="#l6.317"></a><span id="l6.317" class="difflineminus">-                     0, EmptyCString(), listener, msgWindow, allowUndo);</span>
<a href="#l6.318"></a><span id="l6.318" class="difflineminus">-  if (NS_FAILED(rv)) goto done;</span>
<a href="#l6.319"></a><span id="l6.319" class="difflineminus">-</span>
<a href="#l6.320"></a><span id="l6.320" class="difflineminus">-  m_copyState-&gt;m_curIndex = m_copyState-&gt;m_totalCount;</span>
<a href="#l6.321"></a><span id="l6.321" class="difflineminus">-</span>
<a href="#l6.322"></a><span id="l6.322" class="difflineminus">-  if (isMove)</span>
<a href="#l6.323"></a><span id="l6.323" class="difflineminus">-    srcFolder-&gt;EnableNotifications(allMessageCountNotifications, PR_FALSE, PR_TRUE/* dbBatching*/);  //disable message count notification</span>
<a href="#l6.324"></a><span id="l6.324" class="difflineminus">-</span>
<a href="#l6.325"></a><span id="l6.325" class="difflineminus">-  copySupport = do_QueryInterface(m_copyState);</span>
<a href="#l6.326"></a><span id="l6.326" class="difflineminus">-  rv = imapService-&gt;OnlineMessageCopy(m_thread,</span>
<a href="#l6.327"></a><span id="l6.327" class="difflineminus">-                                      srcFolder, messageIds,</span>
<a href="#l6.328"></a><span id="l6.328" class="difflineminus">-                                      this, PR_TRUE, isMove,</span>
<a href="#l6.329"></a><span id="l6.329" class="difflineminus">-                                      urlListener, nsnull,</span>
<a href="#l6.330"></a><span id="l6.330" class="difflineminus">-                                      copySupport, msgWindow);</span>
<a href="#l6.331"></a><span id="l6.331" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; m_copyState-&gt;m_allowUndo)</span>
<a href="#l6.332"></a><span id="l6.332" class="difflineminus">-  {</span>
<a href="#l6.333"></a><span id="l6.333" class="difflineminus">-    nsImapMoveCopyMsgTxn* undoMsgTxn = new nsImapMoveCopyMsgTxn;</span>
<a href="#l6.334"></a><span id="l6.334" class="difflineminus">-    if (!undoMsgTxn || NS_FAILED(undoMsgTxn-&gt;Init(srcFolder, &amp;srcKeyArray,</span>
<a href="#l6.335"></a><span id="l6.335" class="difflineminus">-                                 messageIds.get(), this,</span>
<a href="#l6.336"></a><span id="l6.336" class="difflineminus">-                                 PR_TRUE, isMove, m_thread, urlListener)))</span>
<a href="#l6.337"></a><span id="l6.337" class="difflineminus">-    {</span>
<a href="#l6.338"></a><span id="l6.338" class="difflineminus">-      delete undoMsgTxn;</span>
<a href="#l6.339"></a><span id="l6.339" class="difflineminus">-      return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l6.340"></a><span id="l6.340" class="difflineminus">-    }</span>
<a href="#l6.341"></a><span id="l6.341" class="difflineminus">-    if (isMove)</span>
<a href="#l6.342"></a><span id="l6.342" class="difflineminus">-    {</span>
<a href="#l6.343"></a><span id="l6.343" class="difflineminus">-      if (mFlags &amp; nsMsgFolderFlags::Trash)</span>
<a href="#l6.344"></a><span id="l6.344" class="difflineminus">-        undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eDeleteMsg);</span>
<a href="#l6.345"></a><span id="l6.345" class="difflineplus">+      if (isMove)</span>
<a href="#l6.346"></a><span id="l6.346" class="difflineplus">+      {</span>
<a href="#l6.347"></a><span id="l6.347" class="difflineplus">+        if (mFlags &amp; nsMsgFolderFlags::Trash)</span>
<a href="#l6.348"></a><span id="l6.348" class="difflineplus">+          undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eDeleteMsg);</span>
<a href="#l6.349"></a><span id="l6.349" class="difflineplus">+        else</span>
<a href="#l6.350"></a><span id="l6.350" class="difflineplus">+          undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eMoveMsg);</span>
<a href="#l6.351"></a><span id="l6.351" class="difflineplus">+      }</span>
<a href="#l6.352"></a><span id="l6.352">       else</span>
<a href="#l6.353"></a><span id="l6.353" class="difflineminus">-        undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eMoveMsg);</span>
<a href="#l6.354"></a><span id="l6.354" class="difflineminus">-    }</span>
<a href="#l6.355"></a><span id="l6.355" class="difflineminus">-    else</span>
<a href="#l6.356"></a><span id="l6.356" class="difflineminus">-      undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eCopyMsg);</span>
<a href="#l6.357"></a><span id="l6.357" class="difflineminus">-    rv = undoMsgTxn-&gt;QueryInterface(NS_GET_IID(nsImapMoveCopyMsgTxn), getter_AddRefs(m_copyState-&gt;m_undoMsgTxn) );</span>
<a href="#l6.358"></a><span id="l6.358" class="difflineminus">-  }</span>
<a href="#l6.359"></a><span id="l6.359" class="difflineplus">+        undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eCopyMsg);</span>
<a href="#l6.360"></a><span id="l6.360" class="difflineplus">+      rv = undoMsgTxn-&gt;QueryInterface(NS_GET_IID(nsImapMoveCopyMsgTxn), getter_AddRefs(m_copyState-&gt;m_undoMsgTxn) );</span>
<a href="#l6.361"></a><span id="l6.361" class="difflineplus">+    }</span>
<a href="#l6.362"></a><span id="l6.362"> </span>
<a href="#l6.363"></a><span id="l6.363">   }//endif</span>
<a href="#l6.364"></a><span id="l6.364">   </span>
<a href="#l6.365"></a><span id="l6.365"> done:</span>
<a href="#l6.366"></a><span id="l6.366">   if (NS_FAILED(rv))</span>
<a href="#l6.367"></a><span id="l6.367">   {</span>
<a href="#l6.368"></a><span id="l6.368">     (void) OnCopyCompleted(srcSupport, PR_FALSE);</span>
<a href="#l6.369"></a><span id="l6.369">     if (isMove)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/imap/src/nsImapMailFolder.h</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapMailFolder.h</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -424,16 +424,17 @@ protected:</span>
<a href="#l7.4"></a><span id="l7.4">   // offline-ish methods</span>
<a href="#l7.5"></a><span id="l7.5">   nsresult GetClearedOriginalOp(nsIMsgOfflineImapOperation *op, nsIMsgOfflineImapOperation **originalOp, nsIMsgDatabase **originalDB);</span>
<a href="#l7.6"></a><span id="l7.6">   nsresult GetOriginalOp(nsIMsgOfflineImapOperation *op, nsIMsgOfflineImapOperation **originalOp, nsIMsgDatabase **originalDB);</span>
<a href="#l7.7"></a><span id="l7.7">   nsresult CopyMessagesOffline(nsIMsgFolder* srcFolder,</span>
<a href="#l7.8"></a><span id="l7.8">                                 nsIArray* messages,</span>
<a href="#l7.9"></a><span id="l7.9">                                 PRBool isMove,</span>
<a href="#l7.10"></a><span id="l7.10">                                 nsIMsgWindow *msgWindow,</span>
<a href="#l7.11"></a><span id="l7.11">                                 nsIMsgCopyServiceListener* listener);</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineplus">+  void SetPendingAttributes(nsIArray* messages);</span>
<a href="#l7.13"></a><span id="l7.13"> </span>
<a href="#l7.14"></a><span id="l7.14">   nsresult CopyOfflineMsgBody(nsIMsgFolder *srcFolder, nsIMsgDBHdr *destHdr, nsIMsgDBHdr *origHdr);</span>
<a href="#l7.15"></a><span id="l7.15"> </span>
<a href="#l7.16"></a><span id="l7.16">   void GetTrashFolderName(nsAString &amp;aFolderName);</span>
<a href="#l7.17"></a><span id="l7.17">   PRBool ShowPreviewText();</span>
<a href="#l7.18"></a><span id="l7.18"> </span>
<a href="#l7.19"></a><span id="l7.19">   // Pseudo-Offline operation playback timer</span>
<a href="#l7.20"></a><span id="l7.20">   static </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/mailnews.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/mailnews.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -529,16 +529,17 @@ pref(&quot;mail.server.default.offline_downlo</span>
<a href="#l8.4"></a><span id="l8.4"> // this number is divided by 100 before it is used. The classifier can be fine tuned</span>
<a href="#l8.5"></a><span id="l8.5"> // by changing this pref. Typical values are .99, .95, .90, .5, etc.</span>
<a href="#l8.6"></a><span id="l8.6"> pref(&quot;mail.adaptivefilters.junk_threshold&quot;, 90);</span>
<a href="#l8.7"></a><span id="l8.7"> pref(&quot;mail.spam.version&quot;, 0); // used to determine when to migrate global spam settings</span>
<a href="#l8.8"></a><span id="l8.8"> pref(&quot;mail.spam.logging.enabled&quot;, false);</span>
<a href="#l8.9"></a><span id="l8.9"> pref(&quot;mail.spam.manualMark&quot;, false);</span>
<a href="#l8.10"></a><span id="l8.10"> pref(&quot;mail.spam.markAsReadOnSpam&quot;, false);</span>
<a href="#l8.11"></a><span id="l8.11"> pref(&quot;mail.spam.manualMarkMode&quot;, 0); // 0 == &quot;move to junk folder&quot;, 1 == &quot;delete&quot;</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+pref(&quot;mail.spam.markAsNotJunkMarksUnRead&quot;, true);</span>
<a href="#l8.13"></a><span id="l8.13"> // the number of allowed bayes tokens before the database is shrunk</span>
<a href="#l8.14"></a><span id="l8.14"> pref(&quot;mailnews.bayesian_spam_filter.junk_maxtokens&quot;, 100000);</span>
<a href="#l8.15"></a><span id="l8.15"> </span>
<a href="#l8.16"></a><span id="l8.16"> // set default traits for junk and good. Index should match the values in nsIJunkMailPlugin</span>
<a href="#l8.17"></a><span id="l8.17"> pref(&quot;mailnews.traits.id.1&quot;, &quot;mailnews@mozilla.org#good&quot;);</span>
<a href="#l8.18"></a><span id="l8.18"> pref(&quot;mailnews.traits.name.1&quot;, &quot;Good&quot;);</span>
<a href="#l8.19"></a><span id="l8.19"> pref(&quot;mailnews.traits.enabled.1&quot;, false);</span>
<a href="#l8.20"></a><span id="l8.20"> pref(&quot;mailnews.traits.id.2&quot;, &quot;mailnews@mozilla.org#junk&quot;);</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

