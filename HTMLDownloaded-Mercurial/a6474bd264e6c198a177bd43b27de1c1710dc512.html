<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 24013:a6474bd264e6c198a177bd43b27de1c1710dc512</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ a6474bd264e6c198a177bd43b27de1c1710dc512" />
<meta property="og:url" content="/comm-central/rev/a6474bd264e6c198a177bd43b27de1c1710dc512" />
<meta property="og:description" content="Bug 1463266 - replace tabs with spaces in mailnews/imap. rs=white-space-only" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / a6474bd264e6c198a177bd43b27de1c1710dc512 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/a6474bd264e6c198a177bd43b27de1c1710dc512">shortlog</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/a6474bd264e6c198a177bd43b27de1c1710dc512">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512">files</a> |
changeset |
<a href="/comm-central/raw-rev/a6474bd264e6c198a177bd43b27de1c1710dc512">raw</a>  | <a href="/comm-central/archive/a6474bd264e6c198a177bd43b27de1c1710dc512.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1463266">Bug 1463266</a> - replace tabs with spaces in mailnews/imap. rs=white-space-only
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#74;&#111;&#114;&#103;&#32;&#75;&#32;&#60;&#106;&#111;&#114;&#103;&#107;&#64;&#106;&#111;&#114;&#103;&#107;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Sat, 02 Jun 2018 12:59:36 +0200</td></tr>

<tr>
 <td>changeset 24013</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/a6474bd264e6c198a177bd43b27de1c1710dc512">a6474bd264e6c198a177bd43b27de1c1710dc512</a></td>
</tr>



<tr>
<td>parent 24012</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/75e562d68429216fc9346eeabc356be62b4341be">75e562d68429216fc9346eeabc356be62b4341be</a>
</td>
</tr>

<tr>
<td>child 24014</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/af42c1a9e157a71e3337b8ca91e086fa69e40e6f">af42c1a9e157a71e3337b8ca91e086fa69e40e6f</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=a6474bd264e6c198a177bd43b27de1c1710dc512">14484</a></td></tr>
<tr><td>push user</td><td>mozilla@jorgk.com</td></tr>
<tr><td>push date</td><td class="date age">Sat, 02 Jun 2018 23:23:42 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@af42c1a9e157 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=af42c1a9e157a71e3337b8ca91e086fa69e40e6f">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=af42c1a9e157a71e3337b8ca91e086fa69e40e6f&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=af42c1a9e157a71e3337b8ca91e086fa69e40e6f&newProject=comm-central&newRevision=a6474bd264e6c198a177bd43b27de1c1710dc512&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=af42c1a9e157a71e3337b8ca91e086fa69e40e6f&newProject=comm-central&newRevision=a6474bd264e6c198a177bd43b27de1c1710dc512&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=af42c1a9e157a71e3337b8ca91e086fa69e40e6f&newProject=comm-central&newRevision=a6474bd264e6c198a177bd43b27de1c1710dc512&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28white-space-only%29&revcount=50">white-space-only</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1463266">1463266</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1463266">Bug 1463266</a> - replace tabs with spaces in mailnews/imap. rs=white-space-only
[skip-blame]</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/public/nsMsgImapCID.h">mailnews/imap/public/nsMsgImapCID.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/public/nsMsgImapCID.h">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/public/nsMsgImapCID.h">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/public/nsMsgImapCID.h">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/public/nsMsgImapCID.h">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/public/nsMsgImapCID.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPBodyShell.cpp">mailnews/imap/src/nsIMAPBodyShell.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPBodyShell.cpp">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPBodyShell.cpp">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPBodyShell.cpp">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPBodyShell.cpp">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPBodyShell.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPBodyShell.h">mailnews/imap/src/nsIMAPBodyShell.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPBodyShell.h">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPBodyShell.h">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPBodyShell.h">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPBodyShell.h">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPBodyShell.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPGenericParser.cpp">mailnews/imap/src/nsIMAPGenericParser.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPGenericParser.cpp">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPGenericParser.cpp">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPGenericParser.cpp">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPGenericParser.cpp">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPGenericParser.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPGenericParser.h">mailnews/imap/src/nsIMAPGenericParser.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPGenericParser.h">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPGenericParser.h">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPGenericParser.h">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPGenericParser.h">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPGenericParser.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPHostSessionList.cpp">mailnews/imap/src/nsIMAPHostSessionList.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPHostSessionList.cpp">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPHostSessionList.cpp">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPHostSessionList.cpp">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPHostSessionList.cpp">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPHostSessionList.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPNamespace.cpp">mailnews/imap/src/nsIMAPNamespace.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPNamespace.cpp">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPNamespace.cpp">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPNamespace.cpp">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPNamespace.cpp">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPNamespace.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPNamespace.h">mailnews/imap/src/nsIMAPNamespace.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPNamespace.h">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPNamespace.h">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPNamespace.h">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPNamespace.h">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsIMAPNamespace.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapCore.h">mailnews/imap/src/nsImapCore.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapCore.h">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapCore.h">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapCore.h">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapCore.h">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapCore.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapFlagAndUidState.cpp">mailnews/imap/src/nsImapFlagAndUidState.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapFlagAndUidState.cpp">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapFlagAndUidState.cpp">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapFlagAndUidState.cpp">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapFlagAndUidState.cpp">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapFlagAndUidState.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapIncomingServer.cpp">mailnews/imap/src/nsImapIncomingServer.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapIncomingServer.cpp">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapIncomingServer.cpp">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapIncomingServer.cpp">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapIncomingServer.cpp">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapIncomingServer.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapIncomingServer.h">mailnews/imap/src/nsImapIncomingServer.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapIncomingServer.h">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapIncomingServer.h">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapIncomingServer.h">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapIncomingServer.h">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapIncomingServer.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapOfflineSync.cpp">mailnews/imap/src/nsImapOfflineSync.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapOfflineSync.cpp">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapOfflineSync.cpp">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapOfflineSync.cpp">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapOfflineSync.cpp">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapOfflineSync.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapOfflineSync.h">mailnews/imap/src/nsImapOfflineSync.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapOfflineSync.h">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapOfflineSync.h">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapOfflineSync.h">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapOfflineSync.h">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapOfflineSync.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapProtocol.cpp">mailnews/imap/src/nsImapProtocol.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapProtocol.cpp">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapProtocol.cpp">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapProtocol.cpp">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapProtocol.cpp">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapProtocol.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapSearchResults.cpp">mailnews/imap/src/nsImapSearchResults.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapSearchResults.cpp">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapSearchResults.cpp">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapSearchResults.cpp">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapSearchResults.cpp">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapSearchResults.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapServerResponseParser.cpp">mailnews/imap/src/nsImapServerResponseParser.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapServerResponseParser.cpp">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapServerResponseParser.cpp">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapServerResponseParser.cpp">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapServerResponseParser.cpp">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapServerResponseParser.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapServerResponseParser.h">mailnews/imap/src/nsImapServerResponseParser.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapServerResponseParser.h">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapServerResponseParser.h">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapServerResponseParser.h">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapServerResponseParser.h">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapServerResponseParser.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapUtils.h">mailnews/imap/src/nsImapUtils.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapUtils.h">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapUtils.h">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapUtils.h">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapUtils.h">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/src/nsImapUtils.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/head_server.js">mailnews/imap/test/unit/head_server.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/head_server.js">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/head_server.js">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/head_server.js">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/head_server.js">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/head_server.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/test_bug460636.js">mailnews/imap/test/unit/test_bug460636.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/test_bug460636.js">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/test_bug460636.js">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/test_bug460636.js">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/test_bug460636.js">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/test_bug460636.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/test_imapChunks.js">mailnews/imap/test/unit/test_imapChunks.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/test_imapChunks.js">file</a> |
<a href="/comm-central/annotate/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/test_imapChunks.js">annotate</a> |
<a href="/comm-central/diff/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/test_imapChunks.js">diff</a> |
<a href="/comm-central/comparison/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/test_imapChunks.js">comparison</a> |
<a href="/comm-central/log/a6474bd264e6c198a177bd43b27de1c1710dc512/mailnews/imap/test/unit/test_imapChunks.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/imap/public/nsMsgImapCID.h</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/imap/public/nsMsgImapCID.h</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -3,54 +3,46 @@</span>
<a href="#l1.4"></a><span id="l1.4">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l1.5"></a><span id="l1.5">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l1.6"></a><span id="l1.6"> </span>
<a href="#l1.7"></a><span id="l1.7"> #ifndef nsMsgImapCID_h__</span>
<a href="#l1.8"></a><span id="l1.8"> #define nsMsgImapCID_h__</span>
<a href="#l1.9"></a><span id="l1.9"> </span>
<a href="#l1.10"></a><span id="l1.10"> #include &quot;nsMsgBaseCID.h&quot;</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-#define NS_IMAPURL_CID							\</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineminus">-{ /* 21A89611-DC0D-11d2-806C-006008128C4E */	\</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineminus">-  0x21a89611, 0xdc0d, 0x11d2,					\</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineminus">-   { 0x80, 0x6c, 0x0, 0x60, 0x8, 0x12, 0x8c, 0x4e }}</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+#define NS_IMAPURL_CID        \</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+{ 0x21a89611, 0xdc0d, 0x11d2, \</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineplus">+{ 0x80, 0x6c, 0x0, 0x60, 0x8, 0x12, 0x8c, 0x4e }}</span>
<a href="#l1.19"></a><span id="l1.19"> </span>
<a href="#l1.20"></a><span id="l1.20"> #define NS_IMAPPROTOCOLINFO_CONTRACTID \</span>
<a href="#l1.21"></a><span id="l1.21">   NS_MSGPROTOCOLINFO_CONTRACTID_PREFIX &quot;imap&quot;</span>
<a href="#l1.22"></a><span id="l1.22"> </span>
<a href="#l1.23"></a><span id="l1.23"> #define NS_IMAPINCOMINGSERVER_CONTRACTID  \</span>
<a href="#l1.24"></a><span id="l1.24">   NS_MSGINCOMINGSERVER_CONTRACTID_PREFIX &quot;imap&quot;</span>
<a href="#l1.25"></a><span id="l1.25"> </span>
<a href="#l1.26"></a><span id="l1.26"> #define NS_IMAPSERVICE_CONTRACTID \</span>
<a href="#l1.27"></a><span id="l1.27">   &quot;@mozilla.org/messenger/imapservice;1&quot;</span>
<a href="#l1.28"></a><span id="l1.28"> </span>
<a href="#l1.29"></a><span id="l1.29" class="difflineminus">-#define NS_IMAPSERVICE_CID						  \</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineminus">-{ /* C5852B22-EBE2-11d2-95AD-000064657374 */      \</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineminus">- 0xc5852b22, 0xebe2, 0x11d2,                      \</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineminus">- {0x95, 0xad, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74}}</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineplus">+#define NS_IMAPSERVICE_CID    \</span>
<a href="#l1.34"></a><span id="l1.34" class="difflineplus">+{ 0xc5852b22, 0xebe2, 0x11d2, \</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineplus">+{ 0x95, 0xad, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74 }}</span>
<a href="#l1.36"></a><span id="l1.36"> </span>
<a href="#l1.37"></a><span id="l1.37" class="difflineminus">-#define NS_IMAPPROTOCOL_CID							\</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineminus">-{ /* 8C0C40D1-E173-11d2-806E-006008128C4E */		\</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineminus">-  0x8c0c40d1, 0xe173, 0x11d2,						\</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineminus">-    { 0x80, 0x6e, 0x0, 0x60, 0x8, 0x12, 0x8c, 0x4e }}</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineplus">+#define NS_IMAPPROTOCOL_CID   \</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+{ 0x8c0c40d1, 0xe173, 0x11d2, \</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+{ 0x80, 0x6e, 0x0, 0x60, 0x8, 0x12, 0x8c, 0x4e }}</span>
<a href="#l1.44"></a><span id="l1.44"> </span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+#define NS_IIMAPHOSTSESSIONLIST_CID \</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineplus">+{ 0x479ce8fc, 0xe725, 0x11d2,       \</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+{ 0xa5, 0x05, 0x00, 0x60, 0xb0, 0xfc, 0x04, 0xb7 }}</span>
<a href="#l1.48"></a><span id="l1.48"> </span>
<a href="#l1.49"></a><span id="l1.49" class="difflineminus">-#define NS_IIMAPHOSTSESSIONLIST_CID					\</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineminus">-{ /* 479ce8fc-e725-11d2-a505-0060b0fc04b7 */		\</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineminus">-  0x479ce8fc, 0xe725, 0x11d2,						\</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineminus">-	{0xa5, 0x05, 0x00, 0x60, 0xb0, 0xfc, 0x04, 0xb7 }}</span>
<a href="#l1.53"></a><span id="l1.53" class="difflineminus">-</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineminus">-#define NS_IMAPINCOMINGSERVER_CID				  \</span>
<a href="#l1.55"></a><span id="l1.55" class="difflineminus">-{ /* 8D3675E0-ED46-11d2-8077-006008128C4E */      \</span>
<a href="#l1.56"></a><span id="l1.56" class="difflineminus">- 0x8d3675e0, 0xed46, 0x11d2,	                  \</span>
<a href="#l1.57"></a><span id="l1.57" class="difflineminus">- {0x80, 0x77, 0x0, 0x60, 0x8, 0x12, 0x8c, 0x4e}}</span>
<a href="#l1.58"></a><span id="l1.58" class="difflineplus">+#define NS_IMAPINCOMINGSERVER_CID \</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineplus">+{ 0x8d3675e0, 0xed46, 0x11d2,     \</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineplus">+{ 0x80, 0x77, 0x0, 0x60, 0x8, 0x12, 0x8c, 0x4e}}</span>
<a href="#l1.61"></a><span id="l1.61"> </span>
<a href="#l1.62"></a><span id="l1.62" class="difflineminus">-#define NS_IMAPRESOURCE_CID						\</span>
<a href="#l1.63"></a><span id="l1.63" class="difflineminus">-{ /* fa32d000-f6a0-11d2-af8d-001083002da8 */	\</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineminus">-  0xfa32d000, 0xf6a0, 0x11d2,					\</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineminus">-  { 0xaf, 0x8d, 0x00, 0x10, 0x83, 0x00, 0x2d, 0xa8 }}</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineplus">+#define NS_IMAPRESOURCE_CID   \</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineplus">+{ 0xfa32d000, 0xf6a0, 0x11d2, \</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineplus">+{ 0xaf, 0x8d, 0x00, 0x10, 0x83, 0x00, 0x2d, 0xa8 }}</span>
<a href="#l1.69"></a><span id="l1.69"> </span>
<a href="#l1.70"></a><span id="l1.70" class="difflineminus">-// 4ECA51DF-6734-11d3-989A-001083010E9B</span>
<a href="#l1.71"></a><span id="l1.71"> #define NS_IMAPMOCKCHANNEL_CID \</span>
<a href="#l1.72"></a><span id="l1.72" class="difflineminus">-	{0x4eca51df, 0x6734, 0x11d3, \</span>
<a href="#l1.73"></a><span id="l1.73" class="difflineminus">-	{0x98, 0x9a, 0x0, 0x10, 0x83, 0x1, 0xe, 0x9b}}</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineplus">+{ 0x4eca51df, 0x6734, 0x11d3,  \</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineplus">+{ 0x98, 0x9a, 0x0, 0x10, 0x83, 0x1, 0xe, 0x9b}}</span>
<a href="#l1.76"></a><span id="l1.76"> </span>
<a href="#l1.77"></a><span id="l1.77"> #endif // nsMsgImapCID_h__</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPBodyShell.cpp</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPBodyShell.cpp</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -173,18 +173,18 @@ void nsIMAPBodyShell::FlushPrefetchQueue</span>
<a href="#l2.4"></a><span id="l2.4"> }</span>
<a href="#l2.5"></a><span id="l2.5"> </span>
<a href="#l2.6"></a><span id="l2.6"> // Requires that the shell is valid when called</span>
<a href="#l2.7"></a><span id="l2.7"> // Performs a preflight check on all message parts to see if they are all</span>
<a href="#l2.8"></a><span id="l2.8"> // inline.  Returns true if all parts are inline, false otherwise.</span>
<a href="#l2.9"></a><span id="l2.9"> bool nsIMAPBodyShell::PreflightCheckAllInline()</span>
<a href="#l2.10"></a><span id="l2.10"> {</span>
<a href="#l2.11"></a><span id="l2.11">   bool rv = m_message-&gt;PreflightCheckAllInline(this);</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-  //	if (rv)</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineminus">-  //		MOZ_LOG(IMAP, out, (&quot;BODYSHELL: All parts inline.  Reverting to whole message download.&quot;));</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+  //  if (rv)</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+  //    MOZ_LOG(IMAP, out, (&quot;BODYSHELL: All parts inline.  Reverting to whole message download.&quot;));</span>
<a href="#l2.16"></a><span id="l2.16">   return rv;</span>
<a href="#l2.17"></a><span id="l2.17"> }</span>
<a href="#l2.18"></a><span id="l2.18"> </span>
<a href="#l2.19"></a><span id="l2.19"> // When partNum is NULL, Generates a whole message and intelligently</span>
<a href="#l2.20"></a><span id="l2.20"> // leaves out parts that are not inline.</span>
<a href="#l2.21"></a><span id="l2.21"> </span>
<a href="#l2.22"></a><span id="l2.22"> // When partNum is not NULL, Generates a MIME part that hasn't been downloaded yet</span>
<a href="#l2.23"></a><span id="l2.23"> // Ok, here's how we're going to do this.  Essentially, this</span>
<a href="#l2.24"></a><span id="l2.24" class="difflineat">@@ -209,20 +209,20 @@ int32_t nsIMAPBodyShell::Generate(char *</span>
<a href="#l2.25"></a><span id="l2.25">   if (!GetIsValid() || PreflightCheckAllInline())</span>
<a href="#l2.26"></a><span id="l2.26">   {</span>
<a href="#l2.27"></a><span id="l2.27">     // We don't have a valid shell, or all parts are going to be inline anyway.  Fall back to fetching the whole message.</span>
<a href="#l2.28"></a><span id="l2.28"> #ifdef DEBUG_chrisf</span>
<a href="#l2.29"></a><span id="l2.29">     NS_ASSERTION(GetIsValid());</span>
<a href="#l2.30"></a><span id="l2.30"> #endif</span>
<a href="#l2.31"></a><span id="l2.31">     m_generatingWholeMessage = true;</span>
<a href="#l2.32"></a><span id="l2.32">     uint32_t messageSize = m_protocolConnection-&gt;GetMessageSize(GetUID().get(), true);</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineminus">-    m_protocolConnection-&gt;SetContentModified(IMAP_CONTENT_NOT_MODIFIED);	// So that when we cache it, we know we have the whole message</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+    m_protocolConnection-&gt;SetContentModified(IMAP_CONTENT_NOT_MODIFIED);  // So that when we cache it, we know we have the whole message</span>
<a href="#l2.35"></a><span id="l2.35">     if (!DeathSignalReceived())</span>
<a href="#l2.36"></a><span id="l2.36">       m_protocolConnection-&gt;FallbackToFetchWholeMsg(GetUID(), messageSize);</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineminus">-    contentLength = (int32_t) messageSize;	// ugh</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+    contentLength = (int32_t) messageSize;  // ugh</span>
<a href="#l2.39"></a><span id="l2.39">   }</span>
<a href="#l2.40"></a><span id="l2.40">   else</span>
<a href="#l2.41"></a><span id="l2.41">   {</span>
<a href="#l2.42"></a><span id="l2.42">     // We have a valid shell.</span>
<a href="#l2.43"></a><span id="l2.43">     bool streamCreated = false;</span>
<a href="#l2.44"></a><span id="l2.44">     m_generatingWholeMessage = false;</span>
<a href="#l2.45"></a><span id="l2.45"> </span>
<a href="#l2.46"></a><span id="l2.46">     ////// PASS 1 : PREFETCH ///////</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineat">@@ -284,20 +284,20 @@ bool nsIMAPBodyShell::DeathSignalReceive</span>
<a href="#l2.48"></a><span id="l2.48"> </span>
<a href="#l2.49"></a><span id="l2.49"> </span>
<a href="#l2.50"></a><span id="l2.50"> ///////////// nsIMAPBodypart ////////////////////////////////////</span>
<a href="#l2.51"></a><span id="l2.51"> </span>
<a href="#l2.52"></a><span id="l2.52"> nsIMAPBodypart::nsIMAPBodypart(char *partNumber, nsIMAPBodypart *parentPart)</span>
<a href="#l2.53"></a><span id="l2.53"> {</span>
<a href="#l2.54"></a><span id="l2.54">   SetIsValid(true);</span>
<a href="#l2.55"></a><span id="l2.55">   m_parentPart = parentPart;</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineminus">-  m_partNumberString = partNumber;	// storage adopted</span>
<a href="#l2.57"></a><span id="l2.57" class="difflineplus">+  m_partNumberString = partNumber;  // storage adopted</span>
<a href="#l2.58"></a><span id="l2.58">   m_partData = NULL;</span>
<a href="#l2.59"></a><span id="l2.59">   m_headerData = NULL;</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineminus">-  m_boundaryData = NULL;	// initialize from parsed BODYSTRUCTURE</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineplus">+  m_boundaryData = NULL;  // initialize from parsed BODYSTRUCTURE</span>
<a href="#l2.62"></a><span id="l2.62">   m_contentLength = 0;</span>
<a href="#l2.63"></a><span id="l2.63">   m_partLength = 0;</span>
<a href="#l2.64"></a><span id="l2.64"> </span>
<a href="#l2.65"></a><span id="l2.65">   m_contentType = NULL;</span>
<a href="#l2.66"></a><span id="l2.66">   m_bodyType = NULL;</span>
<a href="#l2.67"></a><span id="l2.67">   m_bodySubType = NULL;</span>
<a href="#l2.68"></a><span id="l2.68">   m_bodyID = NULL;</span>
<a href="#l2.69"></a><span id="l2.69">   m_bodyDescription = NULL;</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineat">@@ -353,18 +353,18 @@ void nsIMAPBodypart::AdoptHeaderDataBuff</span>
<a href="#l2.71"></a><span id="l2.71"> nsIMAPBodypart *nsIMAPBodypart::FindPartWithNumber(const char *partNum)</span>
<a href="#l2.72"></a><span id="l2.72"> {</span>
<a href="#l2.73"></a><span id="l2.73">   // either brute force, or do it the smart way - look at the number.</span>
<a href="#l2.74"></a><span id="l2.74">   // (the parts should be ordered, and hopefully indexed by their number)</span>
<a href="#l2.75"></a><span id="l2.75"> </span>
<a href="#l2.76"></a><span id="l2.76">   if (m_partNumberString &amp;&amp; !PL_strcasecmp(partNum, m_partNumberString))</span>
<a href="#l2.77"></a><span id="l2.77">     return this;</span>
<a href="#l2.78"></a><span id="l2.78"> </span>
<a href="#l2.79"></a><span id="l2.79" class="difflineminus">-  //if (!m_partNumberString &amp;&amp; !PL_strcasecmp(partNum, &quot;1&quot;))</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineminus">-  //	return this;</span>
<a href="#l2.81"></a><span id="l2.81" class="difflineplus">+  // if (!m_partNumberString &amp;&amp; !PL_strcasecmp(partNum, &quot;1&quot;))</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineplus">+  //   return this;</span>
<a href="#l2.83"></a><span id="l2.83"> </span>
<a href="#l2.84"></a><span id="l2.84">   return NULL;</span>
<a href="#l2.85"></a><span id="l2.85"> }</span>
<a href="#l2.86"></a><span id="l2.86"> </span>
<a href="#l2.87"></a><span id="l2.87"> /*</span>
<a href="#l2.88"></a><span id="l2.88"> void nsIMAPBodypart::PrefetchMIMEHeader()</span>
<a href="#l2.89"></a><span id="l2.89"> {</span>
<a href="#l2.90"></a><span id="l2.90"> if (!m_headerData &amp;&amp; !m_shell-&gt;DeathSignalReceived())</span>
<a href="#l2.91"></a><span id="l2.91" class="difflineat">@@ -416,26 +416,26 @@ int32_t nsIMAPBodypart::GenerateMIMEHead</span>
<a href="#l2.92"></a><span id="l2.92">     {</span>
<a href="#l2.93"></a><span id="l2.93">       aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-MIMEHeader&quot;,m_partNumberString);</span>
<a href="#l2.94"></a><span id="l2.94">       aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(m_headerData, false);  // all one line?  Can we do that?</span>
<a href="#l2.95"></a><span id="l2.95">     }</span>
<a href="#l2.96"></a><span id="l2.96"> </span>
<a href="#l2.97"></a><span id="l2.97">     return mimeHeaderLength;</span>
<a href="#l2.98"></a><span id="l2.98">   }</span>
<a href="#l2.99"></a><span id="l2.99"> </span>
<a href="#l2.100"></a><span id="l2.100" class="difflineminus">-  SetIsValid(false);	// prefetch didn't adopt a MIME header</span>
<a href="#l2.101"></a><span id="l2.101" class="difflineplus">+  SetIsValid(false);  // prefetch didn't adopt a MIME header</span>
<a href="#l2.102"></a><span id="l2.102">   return 0;</span>
<a href="#l2.103"></a><span id="l2.103"> }</span>
<a href="#l2.104"></a><span id="l2.104"> </span>
<a href="#l2.105"></a><span id="l2.105"> int32_t nsIMAPBodypart::GeneratePart(nsIMAPBodyShell *aShell, bool stream, bool prefetch)</span>
<a href="#l2.106"></a><span id="l2.106"> {</span>
<a href="#l2.107"></a><span id="l2.107">   if (prefetch)</span>
<a href="#l2.108"></a><span id="l2.108" class="difflineminus">-    return 0;	// don't need to prefetch anything</span>
<a href="#l2.109"></a><span id="l2.109" class="difflineplus">+    return 0;  // don't need to prefetch anything</span>
<a href="#l2.110"></a><span id="l2.110"> </span>
<a href="#l2.111"></a><span id="l2.111" class="difflineminus">-  if (m_partData)	// we have prefetched the part data</span>
<a href="#l2.112"></a><span id="l2.112" class="difflineplus">+  if (m_partData)  // we have prefetched the part data</span>
<a href="#l2.113"></a><span id="l2.113">   {</span>
<a href="#l2.114"></a><span id="l2.114">     if (stream)</span>
<a href="#l2.115"></a><span id="l2.115">     {</span>
<a href="#l2.116"></a><span id="l2.116">       aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-Part-Prefetched&quot;,m_partNumberString);</span>
<a href="#l2.117"></a><span id="l2.117">       aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(m_partData, false);</span>
<a href="#l2.118"></a><span id="l2.118">     }</span>
<a href="#l2.119"></a><span id="l2.119">     return PL_strlen(m_partData);</span>
<a href="#l2.120"></a><span id="l2.120">   }</span>
<a href="#l2.121"></a><span id="l2.121" class="difflineat">@@ -444,23 +444,23 @@ int32_t nsIMAPBodypart::GeneratePart(nsI</span>
<a href="#l2.122"></a><span id="l2.122">   if (stream &amp;&amp; !aShell-&gt;DeathSignalReceived())</span>
<a href="#l2.123"></a><span id="l2.123">   {</span>
<a href="#l2.124"></a><span id="l2.124">     char *generatingPart = aShell-&gt;GetGeneratingPart();</span>
<a href="#l2.125"></a><span id="l2.125">     bool fetchingSpecificPart = (generatingPart &amp;&amp; !PL_strcmp(generatingPart, m_partNumberString));</span>
<a href="#l2.126"></a><span id="l2.126"> </span>
<a href="#l2.127"></a><span id="l2.127">     aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-Part-Inline&quot;,m_partNumberString);</span>
<a href="#l2.128"></a><span id="l2.128">     aShell-&gt;GetConnection()-&gt;FetchTryChunking(aShell-&gt;GetUID(), kMIMEPart, true, m_partNumberString, m_partLength, !fetchingSpecificPart);</span>
<a href="#l2.129"></a><span id="l2.129">   }</span>
<a href="#l2.130"></a><span id="l2.130" class="difflineminus">-  return m_partLength;	// the part length has been filled in from the BODYSTRUCTURE response</span>
<a href="#l2.131"></a><span id="l2.131" class="difflineplus">+  return m_partLength;  // the part length has been filled in from the BODYSTRUCTURE response</span>
<a href="#l2.132"></a><span id="l2.132"> }</span>
<a href="#l2.133"></a><span id="l2.133"> </span>
<a href="#l2.134"></a><span id="l2.134"> int32_t nsIMAPBodypart::GenerateBoundary(nsIMAPBodyShell *aShell, bool stream, bool prefetch, bool lastBoundary)</span>
<a href="#l2.135"></a><span id="l2.135"> {</span>
<a href="#l2.136"></a><span id="l2.136">   if (prefetch)</span>
<a href="#l2.137"></a><span id="l2.137" class="difflineminus">-    return 0;	// don't need to prefetch anything</span>
<a href="#l2.138"></a><span id="l2.138" class="difflineplus">+    return 0;  // don't need to prefetch anything</span>
<a href="#l2.139"></a><span id="l2.139"> </span>
<a href="#l2.140"></a><span id="l2.140">   if (m_boundaryData)</span>
<a href="#l2.141"></a><span id="l2.141">   {</span>
<a href="#l2.142"></a><span id="l2.142">     if (!lastBoundary)</span>
<a href="#l2.143"></a><span id="l2.143">     {</span>
<a href="#l2.144"></a><span id="l2.144">       if (stream)</span>
<a href="#l2.145"></a><span id="l2.145">       {</span>
<a href="#l2.146"></a><span id="l2.146">         aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-Boundary&quot;,m_partNumberString);</span>
<a href="#l2.147"></a><span id="l2.147" class="difflineat">@@ -508,17 +508,17 @@ int32_t nsIMAPBodypart::GenerateEmptyFil</span>
<a href="#l2.148"></a><span id="l2.148">   }</span>
<a href="#l2.149"></a><span id="l2.149">   return 0;</span>
<a href="#l2.150"></a><span id="l2.150"> }</span>
<a href="#l2.151"></a><span id="l2.151"> </span>
<a href="#l2.152"></a><span id="l2.152"> // Returns true if the prefs say that this content type should</span>
<a href="#l2.153"></a><span id="l2.153"> // explicitly be kept in when filling in the shell</span>
<a href="#l2.154"></a><span id="l2.154"> bool nsIMAPBodypart::ShouldExplicitlyFetchInline()</span>
<a href="#l2.155"></a><span id="l2.155"> {</span>
<a href="#l2.156"></a><span id="l2.156" class="difflineminus">-	 return false;</span>
<a href="#l2.157"></a><span id="l2.157" class="difflineplus">+  return false;</span>
<a href="#l2.158"></a><span id="l2.158"> }</span>
<a href="#l2.159"></a><span id="l2.159"> </span>
<a href="#l2.160"></a><span id="l2.160"> // Returns true if the prefs say that this content type should</span>
<a href="#l2.161"></a><span id="l2.161"> // explicitly be left out when filling in the shell</span>
<a href="#l2.162"></a><span id="l2.162"> bool nsIMAPBodypart::ShouldExplicitlyNotFetchInline()</span>
<a href="#l2.163"></a><span id="l2.163"> {</span>
<a href="#l2.164"></a><span id="l2.164">   return false;</span>
<a href="#l2.165"></a><span id="l2.165"> }</span>
<a href="#l2.166"></a><span id="l2.166" class="difflineat">@@ -620,24 +620,24 @@ bool nsIMAPBodypartLeaf::ShouldFetchInli</span>
<a href="#l2.167"></a><span id="l2.167">       nsIMAPBodypart *grandParent = m_parentPart-&gt;GetParentPart();</span>
<a href="#l2.168"></a><span id="l2.168">       // grandParent must exist, since multiparts need parents</span>
<a href="#l2.169"></a><span id="l2.169">       NS_ASSERTION(grandParent, &quot;grandparent doesn't exist for multi-part alt&quot;);</span>
<a href="#l2.170"></a><span id="l2.170">       if (grandParent &amp;&amp;</span>
<a href="#l2.171"></a><span id="l2.171">           (grandParent-&gt;GetType() == IMAP_BODY_MESSAGE_RFC822) &amp;&amp;</span>
<a href="#l2.172"></a><span id="l2.172">           (!PL_strcmp(grandParent-&gt;GetPartNumberString(), generatingPart)) &amp;&amp;</span>
<a href="#l2.173"></a><span id="l2.173">           (m_partNumberString[PL_strlen(m_partNumberString)-1] == '1') &amp;&amp;</span>
<a href="#l2.174"></a><span id="l2.174">           !PL_strcasecmp(m_bodyType, &quot;text&quot;))</span>
<a href="#l2.175"></a><span id="l2.175" class="difflineminus">-        return true;	// we're downloading it inline</span>
<a href="#l2.176"></a><span id="l2.176" class="difflineplus">+        return true;  // we're downloading it inline</span>
<a href="#l2.177"></a><span id="l2.177"> </span>
<a href="#l2.178"></a><span id="l2.178">       // This is a child of a multipart/appledouble attachment,</span>
<a href="#l2.179"></a><span id="l2.179">       // and that multipart/appledouble attachment is being generated</span>
<a href="#l2.180"></a><span id="l2.180">       if (m_parentPart &amp;&amp;</span>
<a href="#l2.181"></a><span id="l2.181">           !PL_strcasecmp(m_parentPart-&gt;GetBodySubType(), &quot;appledouble&quot;) &amp;&amp;</span>
<a href="#l2.182"></a><span id="l2.182">           !PL_strcmp(m_parentPart-&gt;GetPartNumberString(), generatingPart))</span>
<a href="#l2.183"></a><span id="l2.183" class="difflineminus">-        return true;	// we're downloading it inline</span>
<a href="#l2.184"></a><span id="l2.184" class="difflineplus">+        return true;  // we're downloading it inline</span>
<a href="#l2.185"></a><span id="l2.185">       }</span>
<a href="#l2.186"></a><span id="l2.186"> </span>
<a href="#l2.187"></a><span id="l2.187">     // Leave out all other leaves if this isn't the one</span>
<a href="#l2.188"></a><span id="l2.188">     // we're generating.</span>
<a href="#l2.189"></a><span id="l2.189">     // Maybe change later to check parents, etc.</span>
<a href="#l2.190"></a><span id="l2.190">     return false;</span>
<a href="#l2.191"></a><span id="l2.191">   }</span>
<a href="#l2.192"></a><span id="l2.192"> </span>
<a href="#l2.193"></a><span id="l2.193" class="difflineat">@@ -705,30 +705,30 @@ bool nsIMAPBodypartLeaf::ShouldFetchInli</span>
<a href="#l2.194"></a><span id="l2.194">         !PL_strcasecmp(m_parentPart-&gt;GetBodySubType(), &quot;appledouble&quot;))</span>
<a href="#l2.195"></a><span id="l2.195">     {</span>
<a href="#l2.196"></a><span id="l2.196">       // This is the resource fork of a multipart/appledouble.</span>
<a href="#l2.197"></a><span id="l2.197">       // We inherit the inline attributes of the parent,</span>
<a href="#l2.198"></a><span id="l2.198">       // which was derived from its OTHER child.  (The data fork.)</span>
<a href="#l2.199"></a><span id="l2.199">       return m_parentPart-&gt;ShouldFetchInline(aShell);</span>
<a href="#l2.200"></a><span id="l2.200">     }</span>
<a href="#l2.201"></a><span id="l2.201">     // it is applesingle</span>
<a href="#l2.202"></a><span id="l2.202" class="difflineminus">-    return false;	// we can leave it on the server</span>
<a href="#l2.203"></a><span id="l2.203" class="difflineplus">+    return false;  // we can leave it on the server</span>
<a href="#l2.204"></a><span id="l2.204">   }</span>
<a href="#l2.205"></a><span id="l2.205"> #endif // XP_MACOSX</span>
<a href="#l2.206"></a><span id="l2.206"> </span>
<a href="#l2.207"></a><span id="l2.207">   // Leave out parts with type application/*</span>
<a href="#l2.208"></a><span id="l2.208" class="difflineminus">-  if (!PL_strcasecmp(m_bodyType, &quot;APPLICATION&quot;) &amp;&amp;	// If it is of type &quot;application&quot;</span>
<a href="#l2.209"></a><span id="l2.209" class="difflineminus">-      PL_strncasecmp(m_bodySubType, &quot;x-pkcs7&quot;, 7)	// and it's not a signature (signatures are inline)</span>
<a href="#l2.210"></a><span id="l2.210" class="difflineplus">+  if (!PL_strcasecmp(m_bodyType, &quot;APPLICATION&quot;) &amp;&amp;  // If it is of type &quot;application&quot;</span>
<a href="#l2.211"></a><span id="l2.211" class="difflineplus">+      PL_strncasecmp(m_bodySubType, &quot;x-pkcs7&quot;, 7)  // and it's not a signature (signatures are inline)</span>
<a href="#l2.212"></a><span id="l2.212">     )</span>
<a href="#l2.213"></a><span id="l2.213" class="difflineminus">-    return false;	// we can leave it on the server</span>
<a href="#l2.214"></a><span id="l2.214" class="difflineplus">+    return false;  // we can leave it on the server</span>
<a href="#l2.215"></a><span id="l2.215">   if (!PL_strcasecmp(m_bodyType, &quot;AUDIO&quot;))</span>
<a href="#l2.216"></a><span id="l2.216">     return false;</span>
<a href="#l2.217"></a><span id="l2.217">   // Here's where we can add some more intelligence -- let's leave out</span>
<a href="#l2.218"></a><span id="l2.218">   // any other parts that we know we can't display inline.</span>
<a href="#l2.219"></a><span id="l2.219" class="difflineminus">-  return true;	// we're downloading it inline</span>
<a href="#l2.220"></a><span id="l2.220" class="difflineplus">+  return true;  // we're downloading it inline</span>
<a href="#l2.221"></a><span id="l2.221"> }</span>
<a href="#l2.222"></a><span id="l2.222"> </span>
<a href="#l2.223"></a><span id="l2.223"> bool nsIMAPBodypartMultipart::IsLastTextPart(const char *partNumberString)</span>
<a href="#l2.224"></a><span id="l2.224"> {</span>
<a href="#l2.225"></a><span id="l2.225">  // iterate backwards over the parent's part list and if the part is</span>
<a href="#l2.226"></a><span id="l2.226">   // text, compare it to the part number string</span>
<a href="#l2.227"></a><span id="l2.227">   for (int i = m_partList-&gt;Length() - 1; i &gt;= 0; i--)</span>
<a href="#l2.228"></a><span id="l2.228">   {</span>
<a href="#l2.229"></a><span id="l2.229" class="difflineat">@@ -836,17 +836,17 @@ int32_t nsIMAPBodypartMessage::Generate(</span>
<a href="#l2.230"></a><span id="l2.230">   if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l2.231"></a><span id="l2.231">     m_contentLength += m_body-&gt;Generate(aShell, stream, prefetch);</span>
<a href="#l2.232"></a><span id="l2.232"> </span>
<a href="#l2.233"></a><span id="l2.233">   return m_contentLength;</span>
<a href="#l2.234"></a><span id="l2.234"> }</span>
<a href="#l2.235"></a><span id="l2.235"> </span>
<a href="#l2.236"></a><span id="l2.236"> bool nsIMAPBodypartMessage::ShouldFetchInline(nsIMAPBodyShell *aShell)</span>
<a href="#l2.237"></a><span id="l2.237"> {</span>
<a href="#l2.238"></a><span id="l2.238" class="difflineminus">-  if (m_topLevelMessage)	// the main message should always be defined as &quot;inline&quot;</span>
<a href="#l2.239"></a><span id="l2.239" class="difflineplus">+  if (m_topLevelMessage)  // the main message should always be defined as &quot;inline&quot;</span>
<a href="#l2.240"></a><span id="l2.240">     return true;</span>
<a href="#l2.241"></a><span id="l2.241"> </span>
<a href="#l2.242"></a><span id="l2.242">   char *generatingPart = aShell-&gt;GetGeneratingPart();</span>
<a href="#l2.243"></a><span id="l2.243">   if (generatingPart)</span>
<a href="#l2.244"></a><span id="l2.244">   {</span>
<a href="#l2.245"></a><span id="l2.245">     // If we are generating a specific part</span>
<a href="#l2.246"></a><span id="l2.246">     // Always generate containers (just don't fill them in)</span>
<a href="#l2.247"></a><span id="l2.247">     // because it is low cost (everything is cached)</span>
<a href="#l2.248"></a><span id="l2.248" class="difflineat">@@ -1046,17 +1046,17 @@ bool nsIMAPBodypartMultipart::PreflightC</span>
<a href="#l2.249"></a><span id="l2.249">   {</span>
<a href="#l2.250"></a><span id="l2.250">     rv = m_partList-&gt;ElementAt(i)-&gt;PreflightCheckAllInline(aShell);</span>
<a href="#l2.251"></a><span id="l2.251">     i++;</span>
<a href="#l2.252"></a><span id="l2.252">   }</span>
<a href="#l2.253"></a><span id="l2.253"> </span>
<a href="#l2.254"></a><span id="l2.254">   return rv;</span>
<a href="#l2.255"></a><span id="l2.255"> }</span>
<a href="#l2.256"></a><span id="l2.256"> </span>
<a href="#l2.257"></a><span id="l2.257" class="difflineminus">-nsIMAPBodypart	*nsIMAPBodypartMultipart::FindPartWithNumber(const char *partNum)</span>
<a href="#l2.258"></a><span id="l2.258" class="difflineplus">+nsIMAPBodypart *nsIMAPBodypartMultipart::FindPartWithNumber(const char *partNum)</span>
<a href="#l2.259"></a><span id="l2.259"> {</span>
<a href="#l2.260"></a><span id="l2.260">   NS_ASSERTION(partNum, &quot;null part passed into FindPartWithNumber&quot;);</span>
<a href="#l2.261"></a><span id="l2.261"> </span>
<a href="#l2.262"></a><span id="l2.262">   // check this</span>
<a href="#l2.263"></a><span id="l2.263">   if (!PL_strcmp(partNum, m_partNumberString))</span>
<a href="#l2.264"></a><span id="l2.264">     return this;</span>
<a href="#l2.265"></a><span id="l2.265"> </span>
<a href="#l2.266"></a><span id="l2.266">   // check children</span>
<a href="#l2.267"></a><span id="l2.267" class="difflineat">@@ -1099,17 +1099,17 @@ nsIMAPBodypart(partNum, parentPart)</span>
<a href="#l2.268"></a><span id="l2.268"> nsIMAPBodypartType nsIMAPMessageHeaders::GetType()</span>
<a href="#l2.269"></a><span id="l2.269"> {</span>
<a href="#l2.270"></a><span id="l2.270">   return IMAP_BODY_MESSAGE_HEADER;</span>
<a href="#l2.271"></a><span id="l2.271"> }</span>
<a href="#l2.272"></a><span id="l2.272"> </span>
<a href="#l2.273"></a><span id="l2.273"> void nsIMAPMessageHeaders::QueuePrefetchMessageHeaders(nsIMAPBodyShell *aShell)</span>
<a href="#l2.274"></a><span id="l2.274"> {</span>
<a href="#l2.275"></a><span id="l2.275"> </span>
<a href="#l2.276"></a><span id="l2.276" class="difflineminus">-  if (!m_parentPart-&gt;GetnsIMAPBodypartMessage()-&gt;GetIsTopLevelMessage())	// not top-level headers</span>
<a href="#l2.277"></a><span id="l2.277" class="difflineplus">+  if (!m_parentPart-&gt;GetnsIMAPBodypartMessage()-&gt;GetIsTopLevelMessage())  // not top-level headers</span>
<a href="#l2.278"></a><span id="l2.278">     aShell-&gt;AddPrefetchToQueue(kRFC822HeadersOnly, m_partNumberString);</span>
<a href="#l2.279"></a><span id="l2.279">   else</span>
<a href="#l2.280"></a><span id="l2.280">     aShell-&gt;AddPrefetchToQueue(kRFC822HeadersOnly, NULL);</span>
<a href="#l2.281"></a><span id="l2.281"> }</span>
<a href="#l2.282"></a><span id="l2.282"> </span>
<a href="#l2.283"></a><span id="l2.283"> int32_t nsIMAPMessageHeaders::Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch)</span>
<a href="#l2.284"></a><span id="l2.284"> {</span>
<a href="#l2.285"></a><span id="l2.285">   // prefetch the header</span>
<a href="#l2.286"></a><span id="l2.286" class="difflineat">@@ -1124,17 +1124,17 @@ int32_t nsIMAPMessageHeaders::Generate(n</span>
<a href="#l2.287"></a><span id="l2.287">   // stream out the part data</span>
<a href="#l2.288"></a><span id="l2.288">   if (ShouldFetchInline(aShell))</span>
<a href="#l2.289"></a><span id="l2.289">   {</span>
<a href="#l2.290"></a><span id="l2.290">     if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l2.291"></a><span id="l2.291">       m_contentLength = GeneratePart(aShell, stream, prefetch);</span>
<a href="#l2.292"></a><span id="l2.292">   }</span>
<a href="#l2.293"></a><span id="l2.293">   else</span>
<a href="#l2.294"></a><span id="l2.294">   {</span>
<a href="#l2.295"></a><span id="l2.295" class="difflineminus">-    m_contentLength = 0;	// don't fill in any filling for the headers</span>
<a href="#l2.296"></a><span id="l2.296" class="difflineplus">+    m_contentLength = 0;  // don't fill in any filling for the headers</span>
<a href="#l2.297"></a><span id="l2.297">   }</span>
<a href="#l2.298"></a><span id="l2.298">   return m_contentLength;</span>
<a href="#l2.299"></a><span id="l2.299"> }</span>
<a href="#l2.300"></a><span id="l2.300"> </span>
<a href="#l2.301"></a><span id="l2.301"> bool nsIMAPMessageHeaders::ShouldFetchInline(nsIMAPBodyShell *aShell)</span>
<a href="#l2.302"></a><span id="l2.302"> {</span>
<a href="#l2.303"></a><span id="l2.303">   return m_parentPart-&gt;ShouldFetchInline(aShell);</span>
<a href="#l2.304"></a><span id="l2.304"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPBodyShell.h</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPBodyShell.h</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -14,192 +14,187 @@ nsIMAPBodyShell and associated classes</span>
<a href="#l3.4"></a><span id="l3.4"> #include &quot;nsImapCore.h&quot;</span>
<a href="#l3.5"></a><span id="l3.5"> #include &quot;nsString.h&quot;</span>
<a href="#l3.6"></a><span id="l3.6"> #include &quot;nsRefPtrHashtable.h&quot;</span>
<a href="#l3.7"></a><span id="l3.7"> #include &quot;nsTArray.h&quot;</span>
<a href="#l3.8"></a><span id="l3.8"> </span>
<a href="#l3.9"></a><span id="l3.9"> class nsImapProtocol;</span>
<a href="#l3.10"></a><span id="l3.10"> </span>
<a href="#l3.11"></a><span id="l3.11"> typedef enum _nsIMAPBodypartType {</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-	IMAP_BODY_MESSAGE_RFC822,</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">-	IMAP_BODY_MESSAGE_HEADER,</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineminus">-	IMAP_BODY_LEAF,</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineminus">-	IMAP_BODY_MULTIPART</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+  IMAP_BODY_MESSAGE_RFC822,</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+  IMAP_BODY_MESSAGE_HEADER,</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+  IMAP_BODY_LEAF,</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+  IMAP_BODY_MULTIPART</span>
<a href="#l3.20"></a><span id="l3.20"> } nsIMAPBodypartType;</span>
<a href="#l3.21"></a><span id="l3.21"> </span>
<a href="#l3.22"></a><span id="l3.22"> class nsIMAPBodyShell;</span>
<a href="#l3.23"></a><span id="l3.23"> class nsIMAPBodypartMessage;</span>
<a href="#l3.24"></a><span id="l3.24"> </span>
<a href="#l3.25"></a><span id="l3.25"> class nsIMAPBodypart</span>
<a href="#l3.26"></a><span id="l3.26"> {</span>
<a href="#l3.27"></a><span id="l3.27"> public:</span>
<a href="#l3.28"></a><span id="l3.28" class="difflineminus">-	// Construction</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineminus">-	virtual bool GetIsValid() { return m_isValid; }</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineminus">-	virtual void	SetIsValid(bool valid);</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineminus">-	virtual nsIMAPBodypartType	GetType() = 0;</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+  // Construction</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+  virtual bool GetIsValid() { return m_isValid; }</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineplus">+  virtual void SetIsValid(bool valid);</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+  virtual nsIMAPBodypartType GetType() = 0;</span>
<a href="#l3.36"></a><span id="l3.36"> </span>
<a href="#l3.37"></a><span id="l3.37" class="difflineminus">-	// Generation</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineminus">-    // Generates an HTML representation of this part.  Returns content length generated, -1 if failed.</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineminus">-    virtual int32_t Generate(nsIMAPBodyShell *aShell, bool /*stream*/, bool /* prefetch */) { return -1; }</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineminus">-    virtual void AdoptPartDataBuffer(char *buf);    // Adopts storage for part data buffer.  If NULL, sets isValid to false.</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineminus">-    virtual void AdoptHeaderDataBuffer(char *buf);  // Adopts storage for header data buffer.  If NULL, sets isValid to false.</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineminus">-    virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) { return true; }  // returns true if this part should be fetched inline for generation.</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineminus">-    virtual bool PreflightCheckAllInline(nsIMAPBodyShell *aShell) { return true; }</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineplus">+  // Generation</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineplus">+  // Generates an HTML representation of this part.  Returns content length generated, -1 if failed.</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineplus">+  virtual int32_t Generate(nsIMAPBodyShell *aShell, bool /*stream*/, bool /* prefetch */) { return -1; }</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+  virtual void AdoptPartDataBuffer(char *buf);    // Adopts storage for part data buffer.  If NULL, sets isValid to false.</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineplus">+  virtual void AdoptHeaderDataBuffer(char *buf);  // Adopts storage for header data buffer.  If NULL, sets isValid to false.</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineplus">+  virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) { return true; }  // returns true if this part should be fetched inline for generation.</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineplus">+  virtual bool PreflightCheckAllInline(nsIMAPBodyShell *aShell) { return true; }</span>
<a href="#l3.51"></a><span id="l3.51"> </span>
<a href="#l3.52"></a><span id="l3.52" class="difflineminus">-	virtual bool ShouldExplicitlyFetchInline();</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineminus">-	virtual bool ShouldExplicitlyNotFetchInline();</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineminus">-        virtual bool IsLastTextPart(const char *partNumberString) {return true;}</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+  virtual bool ShouldExplicitlyFetchInline();</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+  virtual bool ShouldExplicitlyNotFetchInline();</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+  virtual bool IsLastTextPart(const char *partNumberString) {return true;}</span>
<a href="#l3.58"></a><span id="l3.58"> </span>
<a href="#l3.59"></a><span id="l3.59"> protected:</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineminus">-    // If stream is false, simply returns the content length that will be generated</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineminus">-    // the body of the part itself</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineminus">-    virtual int32_t GeneratePart(nsIMAPBodyShell *aShell, bool stream, bool prefetch);</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineminus">-    // the MIME headers of the part</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineminus">-    virtual int32_t GenerateMIMEHeader(nsIMAPBodyShell *aShell, bool stream, bool prefetch);</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineminus">-    // Generates the MIME boundary wrapper for this part.</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineminus">-    virtual int32_t GenerateBoundary(nsIMAPBodyShell *aShell, bool stream, bool prefetch, bool lastBoundary);</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineminus">-    // lastBoundary indicates whether or not this should be the boundary for the</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineminus">-    // final MIME part of the multipart message.</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineminus">-    // Generates (possibly empty) filling for a part that won't be filled in inline.</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineminus">-    virtual int32_t GenerateEmptyFilling(nsIMAPBodyShell *aShell, bool stream, bool prefetch);</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineplus">+  // If stream is false, simply returns the content length that will be generated</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineplus">+  // the body of the part itself</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineplus">+  virtual int32_t GeneratePart(nsIMAPBodyShell *aShell, bool stream, bool prefetch);</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineplus">+  // the MIME headers of the part</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineplus">+  virtual int32_t GenerateMIMEHeader(nsIMAPBodyShell *aShell, bool stream, bool prefetch);</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineplus">+  // Generates the MIME boundary wrapper for this part.</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineplus">+  virtual int32_t GenerateBoundary(nsIMAPBodyShell *aShell, bool stream, bool prefetch, bool lastBoundary);</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+  // lastBoundary indicates whether or not this should be the boundary for the</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineplus">+  // final MIME part of the multipart message.</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineplus">+  // Generates (possibly empty) filling for a part that won't be filled in inline.</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineplus">+  virtual int32_t GenerateEmptyFilling(nsIMAPBodyShell *aShell, bool stream, bool prefetch);</span>
<a href="#l3.82"></a><span id="l3.82"> </span>
<a href="#l3.83"></a><span id="l3.83" class="difflineminus">-	// Part Numbers / Hierarchy</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineplus">+  // Part Numbers / Hierarchy</span>
<a href="#l3.85"></a><span id="l3.85"> public:</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineminus">-	virtual char	*GetPartNumberString() { return m_partNumberString; }</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineminus">-	virtual nsIMAPBodypart	*FindPartWithNumber(const char *partNum);	// Returns the part object with the given number</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineminus">-	virtual nsIMAPBodypart	*GetParentPart() { return m_parentPart; }	// Returns the parent of this part.</span>
<a href="#l3.89"></a><span id="l3.89" class="difflineminus">-																		// We will define a part of type message/rfc822 to be the</span>
<a href="#l3.90"></a><span id="l3.90" class="difflineminus">-																		// parent of its body and header.</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineminus">-																		// A multipart is a parent of its child parts.</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineminus">-																		// All other leafs do not have children.</span>
<a href="#l3.93"></a><span id="l3.93" class="difflineplus">+  virtual char *GetPartNumberString() { return m_partNumberString; }</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineplus">+  virtual nsIMAPBodypart *FindPartWithNumber(const char *partNum);  // Returns the part object with the given number</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineplus">+  virtual nsIMAPBodypart *GetParentPart() { return m_parentPart; }  // Returns the parent of this part.</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineplus">+                                                                    // We will define a part of type message/rfc822 to be the</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineplus">+                                                                    // parent of its body and header.</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineplus">+                                                                    // A multipart is a parent of its child parts.</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineplus">+                                                                    // All other leafs do not have children.</span>
<a href="#l3.100"></a><span id="l3.100"> </span>
<a href="#l3.101"></a><span id="l3.101" class="difflineminus">-	// Other / Helpers</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineplus">+  // Other / Helpers</span>
<a href="#l3.103"></a><span id="l3.103"> public:</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineminus">-	virtual ~nsIMAPBodypart();</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineminus">-	virtual nsIMAPBodypartMessage	*GetnsIMAPBodypartMessage() { return NULL; }</span>
<a href="#l3.106"></a><span id="l3.106" class="difflineplus">+  virtual ~nsIMAPBodypart();</span>
<a href="#l3.107"></a><span id="l3.107" class="difflineplus">+  virtual nsIMAPBodypartMessage  *GetnsIMAPBodypartMessage() { return NULL; }</span>
<a href="#l3.108"></a><span id="l3.108"> </span>
<a href="#l3.109"></a><span id="l3.109" class="difflineminus">-	const char	*GetBodyType() { return m_bodyType; }</span>
<a href="#l3.110"></a><span id="l3.110" class="difflineminus">-	const char	*GetBodySubType() { return m_bodySubType; }</span>
<a href="#l3.111"></a><span id="l3.111" class="difflineminus">-    void SetBoundaryData(char *boundaryData) { m_boundaryData = boundaryData; }</span>
<a href="#l3.112"></a><span id="l3.112" class="difflineplus">+  const char *GetBodyType() { return m_bodyType; }</span>
<a href="#l3.113"></a><span id="l3.113" class="difflineplus">+  const char *GetBodySubType() { return m_bodySubType; }</span>
<a href="#l3.114"></a><span id="l3.114" class="difflineplus">+  void SetBoundaryData(char *boundaryData) { m_boundaryData = boundaryData; }</span>
<a href="#l3.115"></a><span id="l3.115"> </span>
<a href="#l3.116"></a><span id="l3.116"> protected:</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineminus">-    virtual void QueuePrefetchMIMEHeader(nsIMAPBodyShell *aShell);</span>
<a href="#l3.118"></a><span id="l3.118" class="difflineminus">-	//virtual void	PrefetchMIMEHeader();			// Initiates a prefetch for the MIME header of this part.</span>
<a href="#l3.119"></a><span id="l3.119" class="difflineminus">-    nsIMAPBodypart(char *partNumber, nsIMAPBodypart *parentPart);</span>
<a href="#l3.120"></a><span id="l3.120" class="difflineplus">+  virtual void QueuePrefetchMIMEHeader(nsIMAPBodyShell *aShell);</span>
<a href="#l3.121"></a><span id="l3.121" class="difflineplus">+  //virtual void  PrefetchMIMEHeader();  // Initiates a prefetch for the MIME header of this part.</span>
<a href="#l3.122"></a><span id="l3.122" class="difflineplus">+  nsIMAPBodypart(char *partNumber, nsIMAPBodypart *parentPart);</span>
<a href="#l3.123"></a><span id="l3.123"> </span>
<a href="#l3.124"></a><span id="l3.124"> protected:</span>
<a href="#l3.125"></a><span id="l3.125" class="difflineminus">-	bool	m_isValid;				// If this part is valid.</span>
<a href="#l3.126"></a><span id="l3.126" class="difflineminus">-	char	*m_partNumberString;	// string representation of this part's full-hierarchy number.  Define 0 to be the top-level message</span>
<a href="#l3.127"></a><span id="l3.127" class="difflineminus">-	char	*m_partData;			// data for this part.  NULL if not filled in yet.</span>
<a href="#l3.128"></a><span id="l3.128" class="difflineminus">-	char	*m_headerData;			// data for this part's MIME header.  NULL if not filled in yet.</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineminus">-	char	*m_boundaryData;		// MIME boundary for this part</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineminus">-	int32_t	m_partLength;</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineminus">-	int32_t	m_contentLength;		// Total content length which will be Generate()'d.  -1 if not filled in yet.</span>
<a href="#l3.132"></a><span id="l3.132" class="difflineminus">-	nsIMAPBodypart	*m_parentPart;	// Parent of this part</span>
<a href="#l3.133"></a><span id="l3.133" class="difflineplus">+  bool m_isValid;            // If this part is valid.</span>
<a href="#l3.134"></a><span id="l3.134" class="difflineplus">+  char *m_partNumberString;  // string representation of this part's full-hierarchy number.  Define 0 to be the top-level message</span>
<a href="#l3.135"></a><span id="l3.135" class="difflineplus">+  char *m_partData;          // data for this part.  NULL if not filled in yet.</span>
<a href="#l3.136"></a><span id="l3.136" class="difflineplus">+  char *m_headerData;        // data for this part's MIME header.  NULL if not filled in yet.</span>
<a href="#l3.137"></a><span id="l3.137" class="difflineplus">+  char *m_boundaryData;      // MIME boundary for this part</span>
<a href="#l3.138"></a><span id="l3.138" class="difflineplus">+  int32_t m_partLength;</span>
<a href="#l3.139"></a><span id="l3.139" class="difflineplus">+  int32_t m_contentLength;   // Total content length which will be Generate()'d.  -1 if not filled in yet.</span>
<a href="#l3.140"></a><span id="l3.140" class="difflineplus">+  nsIMAPBodypart *m_parentPart;  // Parent of this part</span>
<a href="#l3.141"></a><span id="l3.141"> </span>
<a href="#l3.142"></a><span id="l3.142" class="difflineminus">-	// Fields	- Filled in from parsed BODYSTRUCTURE response (as well as others)</span>
<a href="#l3.143"></a><span id="l3.143" class="difflineminus">-	char	*m_contentType;			// constructed from m_bodyType and m_bodySubType</span>
<a href="#l3.144"></a><span id="l3.144" class="difflineminus">-	char	*m_bodyType;</span>
<a href="#l3.145"></a><span id="l3.145" class="difflineminus">-	char	*m_bodySubType;</span>
<a href="#l3.146"></a><span id="l3.146" class="difflineminus">-	char	*m_bodyID;</span>
<a href="#l3.147"></a><span id="l3.147" class="difflineminus">-	char	*m_bodyDescription;</span>
<a href="#l3.148"></a><span id="l3.148" class="difflineminus">-	char	*m_bodyEncoding;</span>
<a href="#l3.149"></a><span id="l3.149" class="difflineminus">-	// we ignore extension data for now</span>
<a href="#l3.150"></a><span id="l3.150" class="difflineplus">+  // Fields - Filled in from parsed BODYSTRUCTURE response (as well as others)</span>
<a href="#l3.151"></a><span id="l3.151" class="difflineplus">+  char *m_contentType;  // constructed from m_bodyType and m_bodySubType</span>
<a href="#l3.152"></a><span id="l3.152" class="difflineplus">+  char *m_bodyType;</span>
<a href="#l3.153"></a><span id="l3.153" class="difflineplus">+  char *m_bodySubType;</span>
<a href="#l3.154"></a><span id="l3.154" class="difflineplus">+  char *m_bodyID;</span>
<a href="#l3.155"></a><span id="l3.155" class="difflineplus">+  char *m_bodyDescription;</span>
<a href="#l3.156"></a><span id="l3.156" class="difflineplus">+  char *m_bodyEncoding;</span>
<a href="#l3.157"></a><span id="l3.157" class="difflineplus">+  // we ignore extension data for now</span>
<a href="#l3.158"></a><span id="l3.158"> };</span>
<a href="#l3.159"></a><span id="l3.159"> </span>
<a href="#l3.160"></a><span id="l3.160"> </span>
<a href="#l3.161"></a><span id="l3.161" class="difflineminus">-</span>
<a href="#l3.162"></a><span id="l3.162"> // Message headers</span>
<a href="#l3.163"></a><span id="l3.163"> // A special type of nsIMAPBodypart</span>
<a href="#l3.164"></a><span id="l3.164"> // These may be headers for the top-level message,</span>
<a href="#l3.165"></a><span id="l3.165"> // or any body part of type message/rfc822.</span>
<a href="#l3.166"></a><span id="l3.166"> class nsIMAPMessageHeaders : public nsIMAPBodypart</span>
<a href="#l3.167"></a><span id="l3.167"> {</span>
<a href="#l3.168"></a><span id="l3.168"> public:</span>
<a href="#l3.169"></a><span id="l3.169" class="difflineminus">-    nsIMAPMessageHeaders(char *partNum, nsIMAPBodypart *parentPart);</span>
<a href="#l3.170"></a><span id="l3.170" class="difflineminus">-    virtual nsIMAPBodypartType	GetType() override;</span>
<a href="#l3.171"></a><span id="l3.171" class="difflineminus">-    // Generates an HTML representation of this part.  Returns content length generated, -1 if failed.</span>
<a href="#l3.172"></a><span id="l3.172" class="difflineminus">-    virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l3.173"></a><span id="l3.173" class="difflineminus">-                             bool prefetch) override;</span>
<a href="#l3.174"></a><span id="l3.174" class="difflineminus">-    virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l3.175"></a><span id="l3.175" class="difflineminus">-    virtual void QueuePrefetchMessageHeaders(nsIMAPBodyShell *aShell);</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineplus">+  nsIMAPMessageHeaders(char *partNum, nsIMAPBodypart *parentPart);</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineplus">+  virtual nsIMAPBodypartType  GetType() override;</span>
<a href="#l3.178"></a><span id="l3.178" class="difflineplus">+  // Generates an HTML representation of this part.  Returns content length generated, -1 if failed.</span>
<a href="#l3.179"></a><span id="l3.179" class="difflineplus">+  virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch) override;</span>
<a href="#l3.180"></a><span id="l3.180" class="difflineplus">+  virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l3.181"></a><span id="l3.181" class="difflineplus">+  virtual void QueuePrefetchMessageHeaders(nsIMAPBodyShell *aShell);</span>
<a href="#l3.182"></a><span id="l3.182"> };</span>
<a href="#l3.183"></a><span id="l3.183"> </span>
<a href="#l3.184"></a><span id="l3.184"> </span>
<a href="#l3.185"></a><span id="l3.185"> class nsIMAPBodypartMultipart : public nsIMAPBodypart</span>
<a href="#l3.186"></a><span id="l3.186"> {</span>
<a href="#l3.187"></a><span id="l3.187"> public:</span>
<a href="#l3.188"></a><span id="l3.188" class="difflineminus">-    nsIMAPBodypartMultipart(char *partNum, nsIMAPBodypart *parentPart);</span>
<a href="#l3.189"></a><span id="l3.189" class="difflineminus">-	virtual nsIMAPBodypartType	GetType() override;</span>
<a href="#l3.190"></a><span id="l3.190" class="difflineminus">-	virtual ~nsIMAPBodypartMultipart();</span>
<a href="#l3.191"></a><span id="l3.191" class="difflineminus">-    virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l3.192"></a><span id="l3.192" class="difflineminus">-    virtual bool PreflightCheckAllInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l3.193"></a><span id="l3.193" class="difflineminus">-    // Generates an HTML representation of this part.  Returns content length generated, -1 if failed.</span>
<a href="#l3.194"></a><span id="l3.194" class="difflineminus">-    virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l3.195"></a><span id="l3.195" class="difflineminus">-                             bool prefetch) override;</span>
<a href="#l3.196"></a><span id="l3.196" class="difflineplus">+  nsIMAPBodypartMultipart(char *partNum, nsIMAPBodypart *parentPart);</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineplus">+  virtual nsIMAPBodypartType GetType() override;</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineplus">+  virtual ~nsIMAPBodypartMultipart();</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineplus">+  virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineplus">+  virtual bool PreflightCheckAllInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l3.201"></a><span id="l3.201" class="difflineplus">+  // Generates an HTML representation of this part.  Returns content length generated, -1 if failed.</span>
<a href="#l3.202"></a><span id="l3.202" class="difflineplus">+  virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch) override;</span>
<a href="#l3.203"></a><span id="l3.203">     // Returns the part object with the given number</span>
<a href="#l3.204"></a><span id="l3.204" class="difflineminus">-	virtual nsIMAPBodypart	*FindPartWithNumber(const char *partNum</span>
<a href="#l3.205"></a><span id="l3.205" class="difflineminus">-                                                ) override;</span>
<a href="#l3.206"></a><span id="l3.206" class="difflineminus">-    virtual bool IsLastTextPart(const char *partNumberString) override;</span>
<a href="#l3.207"></a><span id="l3.207" class="difflineminus">-    void AppendPart(nsIMAPBodypart *part)  { m_partList-&gt;AppendElement(part); }</span>
<a href="#l3.208"></a><span id="l3.208" class="difflineminus">-    void SetBodySubType(char *bodySubType);</span>
<a href="#l3.209"></a><span id="l3.209" class="difflineplus">+  virtual nsIMAPBodypart *FindPartWithNumber(const char *partNum) override;</span>
<a href="#l3.210"></a><span id="l3.210" class="difflineplus">+  virtual bool IsLastTextPart(const char *partNumberString) override;</span>
<a href="#l3.211"></a><span id="l3.211" class="difflineplus">+  void AppendPart(nsIMAPBodypart *part) { m_partList-&gt;AppendElement(part); }</span>
<a href="#l3.212"></a><span id="l3.212" class="difflineplus">+  void SetBodySubType(char *bodySubType);</span>
<a href="#l3.213"></a><span id="l3.213"> </span>
<a href="#l3.214"></a><span id="l3.214"> protected:</span>
<a href="#l3.215"></a><span id="l3.215">     nsTArray&lt;nsIMAPBodypart*&gt;  *m_partList;  // An ordered list of top-level body parts for this shell</span>
<a href="#l3.216"></a><span id="l3.216"> };</span>
<a href="#l3.217"></a><span id="l3.217"> </span>
<a href="#l3.218"></a><span id="l3.218"> </span>
<a href="#l3.219"></a><span id="l3.219"> // The name &quot;leaf&quot; is somewhat misleading, since a part of type message/rfc822 is technically</span>
<a href="#l3.220"></a><span id="l3.220"> // a leaf, even though it can contain other parts within it.</span>
<a href="#l3.221"></a><span id="l3.221"> class nsIMAPBodypartLeaf : public nsIMAPBodypart</span>
<a href="#l3.222"></a><span id="l3.222"> {</span>
<a href="#l3.223"></a><span id="l3.223"> public:</span>
<a href="#l3.224"></a><span id="l3.224">   nsIMAPBodypartLeaf(char *partNum, nsIMAPBodypart *parentPart, char *bodyType,</span>
<a href="#l3.225"></a><span id="l3.225">                      char *bodySubType, char *bodyID, char *bodyDescription,</span>
<a href="#l3.226"></a><span id="l3.226">                      char *bodyEncoding, int32_t partLength,</span>
<a href="#l3.227"></a><span id="l3.227">                      bool preferPlainText);</span>
<a href="#l3.228"></a><span id="l3.228" class="difflineminus">-    virtual nsIMAPBodypartType	GetType() override;</span>
<a href="#l3.229"></a><span id="l3.229" class="difflineminus">-    // Generates an HTML representation of this part.  Returns content length generated, -1 if failed.</span>
<a href="#l3.230"></a><span id="l3.230" class="difflineminus">-    virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch) override;</span>
<a href="#l3.231"></a><span id="l3.231" class="difflineminus">-    // returns true if this part should be fetched inline for generation.</span>
<a href="#l3.232"></a><span id="l3.232" class="difflineminus">-    virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l3.233"></a><span id="l3.233" class="difflineminus">-    virtual bool PreflightCheckAllInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l3.234"></a><span id="l3.234" class="difflineplus">+  virtual nsIMAPBodypartType  GetType() override;</span>
<a href="#l3.235"></a><span id="l3.235" class="difflineplus">+  // Generates an HTML representation of this part.  Returns content length generated, -1 if failed.</span>
<a href="#l3.236"></a><span id="l3.236" class="difflineplus">+  virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch) override;</span>
<a href="#l3.237"></a><span id="l3.237" class="difflineplus">+  // returns true if this part should be fetched inline for generation.</span>
<a href="#l3.238"></a><span id="l3.238" class="difflineplus">+  virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l3.239"></a><span id="l3.239" class="difflineplus">+  virtual bool PreflightCheckAllInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l3.240"></a><span id="l3.240"> private:</span>
<a href="#l3.241"></a><span id="l3.241">   bool mPreferPlainText;</span>
<a href="#l3.242"></a><span id="l3.242"> };</span>
<a href="#l3.243"></a><span id="l3.243"> </span>
<a href="#l3.244"></a><span id="l3.244"> </span>
<a href="#l3.245"></a><span id="l3.245"> class nsIMAPBodypartMessage : public nsIMAPBodypartLeaf</span>
<a href="#l3.246"></a><span id="l3.246"> {</span>
<a href="#l3.247"></a><span id="l3.247"> public:</span>
<a href="#l3.248"></a><span id="l3.248">   nsIMAPBodypartMessage(char *partNum, nsIMAPBodypart *parentPart,</span>
<a href="#l3.249"></a><span id="l3.249">                         bool topLevelMessage, char *bodyType,</span>
<a href="#l3.250"></a><span id="l3.250">                         char *bodySubType, char *bodyID,</span>
<a href="#l3.251"></a><span id="l3.251">                         char *bodyDescription, char *bodyEncoding,</span>
<a href="#l3.252"></a><span id="l3.252">                         int32_t partLength, bool preferPlainText);</span>
<a href="#l3.253"></a><span id="l3.253" class="difflineminus">-    void SetBody(nsIMAPBodypart *body);</span>
<a href="#l3.254"></a><span id="l3.254" class="difflineminus">-	virtual nsIMAPBodypartType	GetType() override;</span>
<a href="#l3.255"></a><span id="l3.255" class="difflineminus">-	virtual ~nsIMAPBodypartMessage();</span>
<a href="#l3.256"></a><span id="l3.256" class="difflineminus">-    virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l3.257"></a><span id="l3.257" class="difflineplus">+  void SetBody(nsIMAPBodypart *body);</span>
<a href="#l3.258"></a><span id="l3.258" class="difflineplus">+  virtual nsIMAPBodypartType  GetType() override;</span>
<a href="#l3.259"></a><span id="l3.259" class="difflineplus">+  virtual ~nsIMAPBodypartMessage();</span>
<a href="#l3.260"></a><span id="l3.260" class="difflineplus">+  virtual int32_t Generate(nsIMAPBodyShell *aShell, bool stream,</span>
<a href="#l3.261"></a><span id="l3.261">                              bool prefetch) override;</span>
<a href="#l3.262"></a><span id="l3.262" class="difflineminus">-    virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l3.263"></a><span id="l3.263" class="difflineminus">-    virtual bool PreflightCheckAllInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l3.264"></a><span id="l3.264" class="difflineminus">-	// Returns the part object with the given number</span>
<a href="#l3.265"></a><span id="l3.265" class="difflineminus">-	virtual nsIMAPBodypart	*FindPartWithNumber(const char *partNum</span>
<a href="#l3.266"></a><span id="l3.266" class="difflineminus">-                                                ) override;</span>
<a href="#l3.267"></a><span id="l3.267" class="difflineminus">-	void	AdoptMessageHeaders(char *headers);			// Fills in buffer (and adopts storage) for header object</span>
<a href="#l3.268"></a><span id="l3.268" class="difflineminus">-														// partNum specifies the message part number to which the</span>
<a href="#l3.269"></a><span id="l3.269" class="difflineminus">-														// headers correspond.  NULL indicates the top-level message</span>
<a href="#l3.270"></a><span id="l3.270" class="difflineminus">-	virtual nsIMAPBodypartMessage	*GetnsIMAPBodypartMessage() override { return this; }</span>
<a href="#l3.271"></a><span id="l3.271" class="difflineminus">-	virtual	bool		GetIsTopLevelMessage() { return m_topLevelMessage; }</span>
<a href="#l3.272"></a><span id="l3.272" class="difflineplus">+  virtual bool ShouldFetchInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l3.273"></a><span id="l3.273" class="difflineplus">+  virtual bool PreflightCheckAllInline(nsIMAPBodyShell *aShell) override;</span>
<a href="#l3.274"></a><span id="l3.274" class="difflineplus">+  // Returns the part object with the given number</span>
<a href="#l3.275"></a><span id="l3.275" class="difflineplus">+  virtual nsIMAPBodypart  *FindPartWithNumber(const char *partNum) override;</span>
<a href="#l3.276"></a><span id="l3.276" class="difflineplus">+  void  AdoptMessageHeaders(char *headers);  // Fills in buffer (and adopts storage) for header object</span>
<a href="#l3.277"></a><span id="l3.277" class="difflineplus">+                                             // partNum specifies the message part number to which the</span>
<a href="#l3.278"></a><span id="l3.278" class="difflineplus">+                                             // headers correspond.  NULL indicates the top-level message</span>
<a href="#l3.279"></a><span id="l3.279" class="difflineplus">+  virtual nsIMAPBodypartMessage  *GetnsIMAPBodypartMessage() override { return this; }</span>
<a href="#l3.280"></a><span id="l3.280" class="difflineplus">+  virtual bool GetIsTopLevelMessage() { return m_topLevelMessage; }</span>
<a href="#l3.281"></a><span id="l3.281"> </span>
<a href="#l3.282"></a><span id="l3.282"> protected:</span>
<a href="#l3.283"></a><span id="l3.283" class="difflineminus">-	nsIMAPMessageHeaders		*m_headers;				// Every body shell should have headers</span>
<a href="#l3.284"></a><span id="l3.284" class="difflineminus">-	nsIMAPBodypart			*m_body;	</span>
<a href="#l3.285"></a><span id="l3.285" class="difflineminus">-	bool					m_topLevelMessage;		// Whether or not this is the top-level message</span>
<a href="#l3.286"></a><span id="l3.286" class="difflineplus">+  nsIMAPMessageHeaders *m_headers;         // Every body shell should have headers</span>
<a href="#l3.287"></a><span id="l3.287" class="difflineplus">+  nsIMAPBodypart       *m_body;</span>
<a href="#l3.288"></a><span id="l3.288" class="difflineplus">+  bool                 m_topLevelMessage;  // Whether or not this is the top-level message</span>
<a href="#l3.289"></a><span id="l3.289"> </span>
<a href="#l3.290"></a><span id="l3.290"> };</span>
<a href="#l3.291"></a><span id="l3.291"> </span>
<a href="#l3.292"></a><span id="l3.292"> </span>
<a href="#l3.293"></a><span id="l3.293"> class nsIMAPMessagePartIDArray;</span>
<a href="#l3.294"></a><span id="l3.294"> </span>
<a href="#l3.295"></a><span id="l3.295"> // We will refer to a Body &quot;Shell&quot; as a hierarchical object representation of a parsed BODYSTRUCTURE</span>
<a href="#l3.296"></a><span id="l3.296"> // response.  A shell contains representations of Shell &quot;Parts.&quot;  A Body Shell can undergo essentially</span>
<a href="#l3.297"></a><span id="l3.297" class="difflineat">@@ -259,43 +254,41 @@ public:</span>
<a href="#l3.298"></a><span id="l3.298">   const char *GetFolderName() { return m_folderName; }</span>
<a href="#l3.299"></a><span id="l3.299">   char *GetGeneratingPart() { return m_generatingPart; }</span>
<a href="#l3.300"></a><span id="l3.300">   // Returns true if this is in the process of being generated,</span>
<a href="#l3.301"></a><span id="l3.301">   // so we don't re-enter</span>
<a href="#l3.302"></a><span id="l3.302">   bool IsBeingGenerated() { return m_isBeingGenerated; }</span>
<a href="#l3.303"></a><span id="l3.303">   bool IsShellCached() { return m_cached; }</span>
<a href="#l3.304"></a><span id="l3.304">   void SetIsCached(bool isCached) { m_cached = isCached; }</span>
<a href="#l3.305"></a><span id="l3.305">   bool GetGeneratingWholeMessage() { return m_generatingWholeMessage; }</span>
<a href="#l3.306"></a><span id="l3.306" class="difflineminus">-  IMAP_ContentModifiedType	GetContentModified() { return m_contentModified; }</span>
<a href="#l3.307"></a><span id="l3.307" class="difflineplus">+  IMAP_ContentModifiedType  GetContentModified() { return m_contentModified; }</span>
<a href="#l3.308"></a><span id="l3.308">   void SetContentModified(IMAP_ContentModifiedType modType) { m_contentModified = modType; }</span>
<a href="#l3.309"></a><span id="l3.309"> protected:</span>
<a href="#l3.310"></a><span id="l3.310">   virtual ~nsIMAPBodyShell();</span>
<a href="#l3.311"></a><span id="l3.311"> </span>
<a href="#l3.312"></a><span id="l3.312">   nsIMAPBodypartMessage *m_message;</span>
<a href="#l3.313"></a><span id="l3.313"> </span>
<a href="#l3.314"></a><span id="l3.314" class="difflineminus">-  nsIMAPMessagePartIDArray        *m_prefetchQueue; // array of pipelined part prefetches.  Ok, so it's not really a queue.</span>
<a href="#l3.315"></a><span id="l3.315" class="difflineplus">+  nsIMAPMessagePartIDArray  *m_prefetchQueue; // array of pipelined part prefetches.  Ok, so it's not really a queue.</span>
<a href="#l3.316"></a><span id="l3.316"> </span>
<a href="#l3.317"></a><span id="l3.317" class="difflineminus">-  bool                            m_isValid;</span>
<a href="#l3.318"></a><span id="l3.318" class="difflineminus">-  nsImapProtocol                  *m_protocolConnection;  // Connection, for filling in parts</span>
<a href="#l3.319"></a><span id="l3.319" class="difflineminus">-  nsCString                       m_UID;                  // UID of this message</span>
<a href="#l3.320"></a><span id="l3.320" class="difflineminus">-  char                            *m_folderName;          // folder that contains this message</span>
<a href="#l3.321"></a><span id="l3.321" class="difflineminus">-  char                            *m_generatingPart;      // If a specific part is being generated, this is it.  Otherwise, NULL.</span>
<a href="#l3.322"></a><span id="l3.322" class="difflineminus">-  bool                            m_isBeingGenerated;     // true if this body shell is in the process of being generated</span>
<a href="#l3.323"></a><span id="l3.323" class="difflineminus">-  bool                            m_gotAttachmentPref;    // Whether or not m_showAttachmentsInline has been initialized</span>
<a href="#l3.324"></a><span id="l3.324" class="difflineminus">-  bool                            m_showAttachmentsInline; // Whether or not we should display attachment inline</span>
<a href="#l3.325"></a><span id="l3.325" class="difflineminus">-  bool                            m_cached;                 // Whether or not this shell is cached</span>
<a href="#l3.326"></a><span id="l3.326" class="difflineminus">-  bool                            m_generatingWholeMessage; // whether or not we are generating the whole (non-MPOD) message</span>
<a href="#l3.327"></a><span id="l3.327" class="difflineplus">+  bool                      m_isValid;</span>
<a href="#l3.328"></a><span id="l3.328" class="difflineplus">+  nsImapProtocol            *m_protocolConnection;    // Connection, for filling in parts</span>
<a href="#l3.329"></a><span id="l3.329" class="difflineplus">+  nsCString                 m_UID;                    // UID of this message</span>
<a href="#l3.330"></a><span id="l3.330" class="difflineplus">+  char                      *m_folderName;            // folder that contains this message</span>
<a href="#l3.331"></a><span id="l3.331" class="difflineplus">+  char                      *m_generatingPart;        // If a specific part is being generated, this is it.  Otherwise, NULL.</span>
<a href="#l3.332"></a><span id="l3.332" class="difflineplus">+  bool                      m_isBeingGenerated;       // true if this body shell is in the process of being generated</span>
<a href="#l3.333"></a><span id="l3.333" class="difflineplus">+  bool                      m_gotAttachmentPref;      // Whether or not m_showAttachmentsInline has been initialized</span>
<a href="#l3.334"></a><span id="l3.334" class="difflineplus">+  bool                      m_showAttachmentsInline;  // Whether or not we should display attachment inline</span>
<a href="#l3.335"></a><span id="l3.335" class="difflineplus">+  bool                      m_cached;                 // Whether or not this shell is cached</span>
<a href="#l3.336"></a><span id="l3.336" class="difflineplus">+  bool                      m_generatingWholeMessage; // whether or not we are generating the whole (non-MPOD) message</span>
<a href="#l3.337"></a><span id="l3.337">                                                           // Set to false if we are generating by parts</span>
<a href="#l3.338"></a><span id="l3.338">   // under what conditions the content has been modified.</span>
<a href="#l3.339"></a><span id="l3.339">   // Either IMAP_CONTENT_MODIFIED_VIEW_INLINE or IMAP_CONTENT_MODIFIED_VIEW_AS_LINKS</span>
<a href="#l3.340"></a><span id="l3.340">   IMAP_ContentModifiedType        m_contentModified;</span>
<a href="#l3.341"></a><span id="l3.341"> };</span>
<a href="#l3.342"></a><span id="l3.342"> </span>
<a href="#l3.343"></a><span id="l3.343" class="difflineminus">-</span>
<a href="#l3.344"></a><span id="l3.344" class="difflineminus">-</span>
<a href="#l3.345"></a><span id="l3.345"> // This class caches shells, so we don't have to always go and re-fetch them.</span>
<a href="#l3.346"></a><span id="l3.346"> // This does not cache any of the filled-in inline parts;  those are cached individually</span>
<a href="#l3.347"></a><span id="l3.347"> // in the libnet memory cache.  (ugh, how will we do that?)</span>
<a href="#l3.348"></a><span id="l3.348"> // Since we'll only be retrieving shells for messages over a given size, and since the</span>
<a href="#l3.349"></a><span id="l3.349"> // shells themselves won't be very large, this cache will not grow very big (relatively)</span>
<a href="#l3.350"></a><span id="l3.350"> // and should handle most common usage scenarios.</span>
<a href="#l3.351"></a><span id="l3.351"> </span>
<a href="#l3.352"></a><span id="l3.352"> // A body cache is associated with a given host, spanning folders.</span>
<a href="#l3.353"></a><span id="l3.353" class="difflineat">@@ -351,11 +344,9 @@ public:</span>
<a href="#l3.354"></a><span id="l3.354">   void RemoveAndFreeAll();</span>
<a href="#l3.355"></a><span id="l3.355">   uint32_t GetNumParts() { return Length(); }</span>
<a href="#l3.356"></a><span id="l3.356">   nsIMAPMessagePartID *GetPart(uint32_t i)</span>
<a href="#l3.357"></a><span id="l3.357">   {</span>
<a href="#l3.358"></a><span id="l3.358">     NS_ASSERTION(i &lt; Length(), &quot;invalid message part #&quot;);</span>
<a href="#l3.359"></a><span id="l3.359">     return ElementAt(i);</span>
<a href="#l3.360"></a><span id="l3.360">   }</span>
<a href="#l3.361"></a><span id="l3.361"> };</span>
<a href="#l3.362"></a><span id="l3.362" class="difflineminus">-</span>
<a href="#l3.363"></a><span id="l3.363" class="difflineminus">-</span>
<a href="#l3.364"></a><span id="l3.364"> #endif // IMAPBODY_H</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPGenericParser.cpp</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPGenericParser.cpp</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -48,17 +48,17 @@ bool nsIMAPGenericParser::LastCommandSuc</span>
<a href="#l4.4"></a><span id="l4.4"> }</span>
<a href="#l4.5"></a><span id="l4.5"> </span>
<a href="#l4.6"></a><span id="l4.6"> void nsIMAPGenericParser::SetSyntaxError(bool error, const char *msg)</span>
<a href="#l4.7"></a><span id="l4.7"> {</span>
<a href="#l4.8"></a><span id="l4.8">   if (error)</span>
<a href="#l4.9"></a><span id="l4.9">       fParserState |= stateSyntaxErrorFlag;</span>
<a href="#l4.10"></a><span id="l4.10">   else</span>
<a href="#l4.11"></a><span id="l4.11">       fParserState &amp;= ~stateSyntaxErrorFlag;</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-  NS_ASSERTION(!error, &quot;syntax error in generic parser&quot;);	</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+  NS_ASSERTION(!error, &quot;syntax error in generic parser&quot;);</span>
<a href="#l4.14"></a><span id="l4.14"> }</span>
<a href="#l4.15"></a><span id="l4.15"> </span>
<a href="#l4.16"></a><span id="l4.16"> void nsIMAPGenericParser::SetConnected(bool connected)</span>
<a href="#l4.17"></a><span id="l4.17"> {</span>
<a href="#l4.18"></a><span id="l4.18">   if (connected)</span>
<a href="#l4.19"></a><span id="l4.19">       fParserState &amp;= ~stateDisconnectedFlag;</span>
<a href="#l4.20"></a><span id="l4.20">   else</span>
<a href="#l4.21"></a><span id="l4.21">       fParserState |= stateDisconnectedFlag;</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineat">@@ -201,19 +201,19 @@ void nsIMAPGenericParser::AdvanceTokeniz</span>
<a href="#l4.23"></a><span id="l4.23"> </span>
<a href="#l4.24"></a><span id="l4.24"> // RFC3501:  astring = 1*ASTRING-CHAR / string</span>
<a href="#l4.25"></a><span id="l4.25"> //           string  = quoted / literal</span>
<a href="#l4.26"></a><span id="l4.26"> // This function leaves us off with fCurrentTokenPlaceHolder immediately after</span>
<a href="#l4.27"></a><span id="l4.27"> // the end of the Astring.  Call AdvanceToNextToken() to get the token after it.</span>
<a href="#l4.28"></a><span id="l4.28"> char *nsIMAPGenericParser::CreateAstring()</span>
<a href="#l4.29"></a><span id="l4.29"> {</span>
<a href="#l4.30"></a><span id="l4.30">   if (*fNextToken == '{')</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineminus">-    return CreateLiteral();		// literal</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+    return CreateLiteral();  // literal</span>
<a href="#l4.33"></a><span id="l4.33">   if (*fNextToken == '&quot;')</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineminus">-    return CreateQuoted();		// quoted</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+    return CreateQuoted();  // quoted</span>
<a href="#l4.36"></a><span id="l4.36">   return CreateAtom(true); // atom</span>
<a href="#l4.37"></a><span id="l4.37"> }</span>
<a href="#l4.38"></a><span id="l4.38"> </span>
<a href="#l4.39"></a><span id="l4.39"> // Create an atom</span>
<a href="#l4.40"></a><span id="l4.40"> // This function does not advance the parser.</span>
<a href="#l4.41"></a><span id="l4.41"> // Call AdvanceToNextToken() to get the next token after the atom.</span>
<a href="#l4.42"></a><span id="l4.42"> // RFC3501:  atom            = 1*ATOM-CHAR</span>
<a href="#l4.43"></a><span id="l4.43"> //           ASTRING-CHAR    = ATOM-CHAR / resp-specials</span>
<a href="#l4.44"></a><span id="l4.44" class="difflineat">@@ -278,22 +278,22 @@ char *nsIMAPGenericParser::CreateNilStri</span>
<a href="#l4.45"></a><span id="l4.45"> // Create a string, which can either be quoted or literal,</span>
<a href="#l4.46"></a><span id="l4.46"> // but not an atom.</span>
<a href="#l4.47"></a><span id="l4.47"> // This function leaves us off with fCurrentTokenPlaceHolder immediately after</span>
<a href="#l4.48"></a><span id="l4.48"> // the end of the String.  Call AdvanceToNextToken() to get the token after it.</span>
<a href="#l4.49"></a><span id="l4.49"> char *nsIMAPGenericParser::CreateString()</span>
<a href="#l4.50"></a><span id="l4.50"> {</span>
<a href="#l4.51"></a><span id="l4.51">   if (*fNextToken == '{')</span>
<a href="#l4.52"></a><span id="l4.52">   {</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineminus">-    char *rv = CreateLiteral();		// literal</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineplus">+    char *rv = CreateLiteral();  // literal</span>
<a href="#l4.55"></a><span id="l4.55">     return (rv);</span>
<a href="#l4.56"></a><span id="l4.56">   }</span>
<a href="#l4.57"></a><span id="l4.57">   if (*fNextToken == '&quot;')</span>
<a href="#l4.58"></a><span id="l4.58">   {</span>
<a href="#l4.59"></a><span id="l4.59" class="difflineminus">-    char *rv = CreateQuoted();		// quoted</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineplus">+    char *rv = CreateQuoted();  // quoted</span>
<a href="#l4.61"></a><span id="l4.61">     return (rv);</span>
<a href="#l4.62"></a><span id="l4.62">   }</span>
<a href="#l4.63"></a><span id="l4.63">   SetSyntaxError(true, &quot;string does not start with '{' or '\&quot;'&quot;);</span>
<a href="#l4.64"></a><span id="l4.64">   return NULL;</span>
<a href="#l4.65"></a><span id="l4.65"> }</span>
<a href="#l4.66"></a><span id="l4.66"> </span>
<a href="#l4.67"></a><span id="l4.67"> // This function sets fCurrentTokenPlaceHolder immediately after the end of the</span>
<a href="#l4.68"></a><span id="l4.68"> // closing quote.  Call AdvanceToNextToken() to get the token after it.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPGenericParser.h</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPGenericParser.h</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -25,25 +25,25 @@ public:</span>
<a href="#l5.4"></a><span id="l5.4"> </span>
<a href="#l5.5"></a><span id="l5.5">   bool SyntaxError() { return (fParserState &amp; stateSyntaxErrorFlag) != 0; }</span>
<a href="#l5.6"></a><span id="l5.6">   bool ContinueParse() { return fParserState == stateOK; }</span>
<a href="#l5.7"></a><span id="l5.7">   bool Connected() { return !(fParserState &amp; stateDisconnectedFlag); }</span>
<a href="#l5.8"></a><span id="l5.8">   void SetConnected(bool error);</span>
<a href="#l5.9"></a><span id="l5.9"> </span>
<a href="#l5.10"></a><span id="l5.10"> protected:</span>
<a href="#l5.11"></a><span id="l5.11"> </span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-	// This is a pure virtual member which must be overridden in the derived class</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineminus">-	// for each different implementation of a nsIMAPGenericParser.</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineminus">-	// For instance, one implementation (the nsIMAPServerState) might get the next line</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineminus">-	// from an open socket, whereas another implementation might just get it from a buffer somewhere.</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineminus">-	// This fills in nextLine with the buffer, and returns true if everything is OK.</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineminus">-	// Returns false if there was some error encountered.  In that case, we reset the parser.</span>
<a href="#l5.18"></a><span id="l5.18" class="difflineminus">-	virtual bool	GetNextLineForParser(char **nextLine) = 0;	</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineplus">+  // This is a pure virtual member which must be overridden in the derived class</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineplus">+  // for each different implementation of a nsIMAPGenericParser.</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+  // For instance, one implementation (the nsIMAPServerState) might get the next line</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+  // from an open socket, whereas another implementation might just get it from a buffer somewhere.</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+  // This fills in nextLine with the buffer, and returns true if everything is OK.</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineplus">+  // Returns false if there was some error encountered.  In that case, we reset the parser.</span>
<a href="#l5.25"></a><span id="l5.25" class="difflineplus">+  virtual bool GetNextLineForParser(char **nextLine) = 0;</span>
<a href="#l5.26"></a><span id="l5.26"> </span>
<a href="#l5.27"></a><span id="l5.27" class="difflineminus">-  virtual void	HandleMemoryFailure();</span>
<a href="#l5.28"></a><span id="l5.28" class="difflineplus">+  virtual void HandleMemoryFailure();</span>
<a href="#l5.29"></a><span id="l5.29">   void skip_to_CRLF();</span>
<a href="#l5.30"></a><span id="l5.30">   void skip_to_close_paren();</span>
<a href="#l5.31"></a><span id="l5.31">   char *CreateString();</span>
<a href="#l5.32"></a><span id="l5.32">   char *CreateAstring();</span>
<a href="#l5.33"></a><span id="l5.33">   char *CreateNilString();</span>
<a href="#l5.34"></a><span id="l5.34">   char *CreateLiteral();</span>
<a href="#l5.35"></a><span id="l5.35">   char *CreateAtom(bool isAstring = false);</span>
<a href="#l5.36"></a><span id="l5.36">   char *CreateQuoted(bool skipToEnd = true);</span>
<a href="#l5.37"></a><span id="l5.37" class="difflineat">@@ -51,17 +51,17 @@ protected:</span>
<a href="#l5.38"></a><span id="l5.38">   virtual void SetSyntaxError(bool error, const char *msg);</span>
<a href="#l5.39"></a><span id="l5.39"> </span>
<a href="#l5.40"></a><span id="l5.40">   void AdvanceToNextToken();</span>
<a href="#l5.41"></a><span id="l5.41">   void AdvanceToNextLine();</span>
<a href="#l5.42"></a><span id="l5.42">   void AdvanceTokenizerStartingPoint(int32_t bytesToAdvance);</span>
<a href="#l5.43"></a><span id="l5.43">   void ResetLexAnalyzer();</span>
<a href="#l5.44"></a><span id="l5.44"> </span>
<a href="#l5.45"></a><span id="l5.45"> protected:</span>
<a href="#l5.46"></a><span id="l5.46" class="difflineminus">-	// use with care</span>
<a href="#l5.47"></a><span id="l5.47" class="difflineplus">+  // use with care</span>
<a href="#l5.48"></a><span id="l5.48">   const char     *fNextToken;</span>
<a href="#l5.49"></a><span id="l5.49">   char           *fCurrentLine;</span>
<a href="#l5.50"></a><span id="l5.50">   char           *fLineOfTokens;</span>
<a href="#l5.51"></a><span id="l5.51">   char           *fStartOfLineOfTokens;</span>
<a href="#l5.52"></a><span id="l5.52">   char           *fCurrentTokenPlaceHolder;</span>
<a href="#l5.53"></a><span id="l5.53">   bool            fAtEndOfLine;</span>
<a href="#l5.54"></a><span id="l5.54"> </span>
<a href="#l5.55"></a><span id="l5.55"> private:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPHostSessionList.cpp</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPHostSessionList.cpp</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -376,17 +376,17 @@ NS_IMETHODIMP nsIMAPHostSessionList::Set</span>
<a href="#l6.4"></a><span id="l6.4">       int numNamespaces = host-&gt;fNamespaceList-&gt;UnserializeNamespaces(namespacePref, nullptr, 0);</span>
<a href="#l6.5"></a><span id="l6.5">       char **prefixes = (char**) PR_CALLOC(numNamespaces * sizeof(char*));</span>
<a href="#l6.6"></a><span id="l6.6">       if (prefixes)</span>
<a href="#l6.7"></a><span id="l6.7">       {</span>
<a href="#l6.8"></a><span id="l6.8">         int len = host-&gt;fNamespaceList-&gt;UnserializeNamespaces(namespacePref, prefixes, numNamespaces);</span>
<a href="#l6.9"></a><span id="l6.9">         for (int i = 0; i &lt; len; i++)</span>
<a href="#l6.10"></a><span id="l6.10">         {</span>
<a href="#l6.11"></a><span id="l6.11">           char *thisns = prefixes[i];</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-          char delimiter = '/';	// a guess</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+          char delimiter = '/';  // a guess</span>
<a href="#l6.14"></a><span id="l6.14">           if (PL_strlen(thisns) &gt;= 1)</span>
<a href="#l6.15"></a><span id="l6.15">             delimiter = thisns[PL_strlen(thisns)-1];</span>
<a href="#l6.16"></a><span id="l6.16">           nsIMAPNamespace *ns = new nsIMAPNamespace(nstype, thisns, delimiter, true);</span>
<a href="#l6.17"></a><span id="l6.17">           if (ns)</span>
<a href="#l6.18"></a><span id="l6.18">             host-&gt;fNamespaceList-&gt;AddNewNamespace(ns);</span>
<a href="#l6.19"></a><span id="l6.19">           PR_FREEIF(thisns);</span>
<a href="#l6.20"></a><span id="l6.20">         }</span>
<a href="#l6.21"></a><span id="l6.21">         PR_Free(prefixes);</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineat">@@ -468,17 +468,17 @@ NS_IMETHODIMP nsIMAPHostSessionList::Get</span>
<a href="#l6.23"></a><span id="l6.23">   if (host)</span>
<a href="#l6.24"></a><span id="l6.24">     intResult = host-&gt;fNamespaceList-&gt;GetNumberOfNamespaces();</span>
<a href="#l6.25"></a><span id="l6.25">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.26"></a><span id="l6.26">   NS_ASSERTION(intResult &gt;= 0, &quot;negative number of namespaces&quot;);</span>
<a href="#l6.27"></a><span id="l6.27">   result = (uint32_t) intResult;</span>
<a href="#l6.28"></a><span id="l6.28">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l6.29"></a><span id="l6.29"> }</span>
<a href="#l6.30"></a><span id="l6.30"> </span>
<a href="#l6.31"></a><span id="l6.31" class="difflineminus">-NS_IMETHODIMP	nsIMAPHostSessionList::GetNamespaceNumberForHost(const char *serverKey, int32_t n, nsIMAPNamespace * &amp;result)</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+NS_IMETHODIMP nsIMAPHostSessionList::GetNamespaceNumberForHost(const char *serverKey, int32_t n, nsIMAPNamespace * &amp;result)</span>
<a href="#l6.33"></a><span id="l6.33"> {</span>
<a href="#l6.34"></a><span id="l6.34">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.35"></a><span id="l6.35">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l6.36"></a><span id="l6.36">   if (host)</span>
<a href="#l6.37"></a><span id="l6.37">     result = host-&gt;fNamespaceList-&gt;GetNamespaceNumber(n);</span>
<a href="#l6.38"></a><span id="l6.38">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.39"></a><span id="l6.39">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l6.40"></a><span id="l6.40"> }</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineat">@@ -510,17 +510,17 @@ NS_IMETHODIMP nsIMAPHostSessionList::Com</span>
<a href="#l6.42"></a><span id="l6.42"> </span>
<a href="#l6.43"></a><span id="l6.43">   nsresult rv = incomingServer-&gt;GetKey(serverKey);</span>
<a href="#l6.44"></a><span id="l6.44">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l6.45"></a><span id="l6.45"> </span>
<a href="#l6.46"></a><span id="l6.46">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.47"></a><span id="l6.47">   nsIMAPHostInfo *host = FindHost(serverKey.get());</span>
<a href="#l6.48"></a><span id="l6.48">   if (host)</span>
<a href="#l6.49"></a><span id="l6.49">   {</span>
<a href="#l6.50"></a><span id="l6.50" class="difflineminus">-    host-&gt;fGotNamespaces = true;	// so we only issue NAMESPACE once per host per session.</span>
<a href="#l6.51"></a><span id="l6.51" class="difflineplus">+    host-&gt;fGotNamespaces = true;  // so we only issue NAMESPACE once per host per session.</span>
<a href="#l6.52"></a><span id="l6.52">     EIMAPNamespaceType type = kPersonalNamespace;</span>
<a href="#l6.53"></a><span id="l6.53">     for (int i = 1; i &lt;= 3; i++)</span>
<a href="#l6.54"></a><span id="l6.54">     {</span>
<a href="#l6.55"></a><span id="l6.55">       switch(i)</span>
<a href="#l6.56"></a><span id="l6.56">       {</span>
<a href="#l6.57"></a><span id="l6.57">       case 1:</span>
<a href="#l6.58"></a><span id="l6.58">         type = kPersonalNamespace;</span>
<a href="#l6.59"></a><span id="l6.59">         break;</span>
<a href="#l6.60"></a><span id="l6.60" class="difflineat">@@ -573,22 +573,22 @@ NS_IMETHODIMP nsIMAPHostSessionList::Com</span>
<a href="#l6.61"></a><span id="l6.61">     aHost-&gt;ResetNamespaceReferences();</span>
<a href="#l6.62"></a><span id="l6.62">   }</span>
<a href="#l6.63"></a><span id="l6.63">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.64"></a><span id="l6.64">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l6.65"></a><span id="l6.65"> }</span>
<a href="#l6.66"></a><span id="l6.66"> </span>
<a href="#l6.67"></a><span id="l6.67"> NS_IMETHODIMP nsIMAPHostSessionList::FlushUncommittedNamespacesForHost(const char *serverKey, bool &amp;result)</span>
<a href="#l6.68"></a><span id="l6.68"> {</span>
<a href="#l6.69"></a><span id="l6.69" class="difflineminus">-	PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.70"></a><span id="l6.70" class="difflineminus">-	nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l6.71"></a><span id="l6.71" class="difflineminus">-	if (host)</span>
<a href="#l6.72"></a><span id="l6.72" class="difflineminus">-		host-&gt;fTempNamespaceList-&gt;ClearNamespaces(true, true, true);</span>
<a href="#l6.73"></a><span id="l6.73" class="difflineminus">-	PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.74"></a><span id="l6.74" class="difflineminus">-	return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l6.75"></a><span id="l6.75" class="difflineplus">+  PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.76"></a><span id="l6.76" class="difflineplus">+  nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l6.77"></a><span id="l6.77" class="difflineplus">+  if (host)</span>
<a href="#l6.78"></a><span id="l6.78" class="difflineplus">+    host-&gt;fTempNamespaceList-&gt;ClearNamespaces(true, true, true);</span>
<a href="#l6.79"></a><span id="l6.79" class="difflineplus">+  PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.80"></a><span id="l6.80" class="difflineplus">+  return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l6.81"></a><span id="l6.81"> }</span>
<a href="#l6.82"></a><span id="l6.82"> </span>
<a href="#l6.83"></a><span id="l6.83"> </span>
<a href="#l6.84"></a><span id="l6.84"> // Returns NULL if there is no personal namespace on the given host</span>
<a href="#l6.85"></a><span id="l6.85"> NS_IMETHODIMP nsIMAPHostSessionList::GetOnlineInboxPathForHost(const char *serverKey, nsString &amp;result)</span>
<a href="#l6.86"></a><span id="l6.86"> {</span>
<a href="#l6.87"></a><span id="l6.87">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.88"></a><span id="l6.88">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l6.89"></a><span id="l6.89" class="difflineat">@@ -605,36 +605,36 @@ NS_IMETHODIMP nsIMAPHostSessionList::Get</span>
<a href="#l6.90"></a><span id="l6.90">   else</span>
<a href="#l6.91"></a><span id="l6.91">     result.Truncate();</span>
<a href="#l6.92"></a><span id="l6.92">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.93"></a><span id="l6.93">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l6.94"></a><span id="l6.94"> }</span>
<a href="#l6.95"></a><span id="l6.95"> </span>
<a href="#l6.96"></a><span id="l6.96"> NS_IMETHODIMP nsIMAPHostSessionList::GetShouldAlwaysListInboxForHost(const char* /*serverKey*/, bool &amp;result)</span>
<a href="#l6.97"></a><span id="l6.97"> {</span>
<a href="#l6.98"></a><span id="l6.98" class="difflineminus">-	result = true;</span>
<a href="#l6.99"></a><span id="l6.99" class="difflineplus">+  result = true;</span>
<a href="#l6.100"></a><span id="l6.100"> </span>
<a href="#l6.101"></a><span id="l6.101" class="difflineminus">-	/*</span>
<a href="#l6.102"></a><span id="l6.102" class="difflineminus">-	PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.103"></a><span id="l6.103" class="difflineminus">-	nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l6.104"></a><span id="l6.104" class="difflineminus">-	if (host)</span>
<a href="#l6.105"></a><span id="l6.105" class="difflineminus">-		ret = host-&gt;fShouldAlwaysListInbox;</span>
<a href="#l6.106"></a><span id="l6.106" class="difflineminus">-	PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.107"></a><span id="l6.107" class="difflineminus">-	*/</span>
<a href="#l6.108"></a><span id="l6.108" class="difflineminus">-	return NS_OK;</span>
<a href="#l6.109"></a><span id="l6.109" class="difflineplus">+  /*</span>
<a href="#l6.110"></a><span id="l6.110" class="difflineplus">+  PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.111"></a><span id="l6.111" class="difflineplus">+  nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l6.112"></a><span id="l6.112" class="difflineplus">+  if (host)</span>
<a href="#l6.113"></a><span id="l6.113" class="difflineplus">+    ret = host-&gt;fShouldAlwaysListInbox;</span>
<a href="#l6.114"></a><span id="l6.114" class="difflineplus">+  PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.115"></a><span id="l6.115" class="difflineplus">+  */</span>
<a href="#l6.116"></a><span id="l6.116" class="difflineplus">+  return NS_OK;</span>
<a href="#l6.117"></a><span id="l6.117"> }</span>
<a href="#l6.118"></a><span id="l6.118"> </span>
<a href="#l6.119"></a><span id="l6.119"> NS_IMETHODIMP nsIMAPHostSessionList::SetShouldAlwaysListInboxForHost(const char *serverKey, bool shouldList)</span>
<a href="#l6.120"></a><span id="l6.120"> {</span>
<a href="#l6.121"></a><span id="l6.121" class="difflineminus">-	PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.122"></a><span id="l6.122" class="difflineminus">-	nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l6.123"></a><span id="l6.123" class="difflineminus">-	if (host)</span>
<a href="#l6.124"></a><span id="l6.124" class="difflineminus">-		host-&gt;fShouldAlwaysListInbox = shouldList;</span>
<a href="#l6.125"></a><span id="l6.125" class="difflineminus">-	PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.126"></a><span id="l6.126" class="difflineminus">-	return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l6.127"></a><span id="l6.127" class="difflineplus">+  PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.128"></a><span id="l6.128" class="difflineplus">+  nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l6.129"></a><span id="l6.129" class="difflineplus">+  if (host)</span>
<a href="#l6.130"></a><span id="l6.130" class="difflineplus">+    host-&gt;fShouldAlwaysListInbox = shouldList;</span>
<a href="#l6.131"></a><span id="l6.131" class="difflineplus">+  PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.132"></a><span id="l6.132" class="difflineplus">+  return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l6.133"></a><span id="l6.133"> }</span>
<a href="#l6.134"></a><span id="l6.134"> </span>
<a href="#l6.135"></a><span id="l6.135"> NS_IMETHODIMP nsIMAPHostSessionList::SetNamespaceHierarchyDelimiterFromMailboxForHost(const char *serverKey, const char *boxName, char delimiter)</span>
<a href="#l6.136"></a><span id="l6.136"> {</span>
<a href="#l6.137"></a><span id="l6.137">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.138"></a><span id="l6.138">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l6.139"></a><span id="l6.139">   if (host)</span>
<a href="#l6.140"></a><span id="l6.140">   {</span>
<a href="#l6.141"></a><span id="l6.141" class="difflineat">@@ -643,32 +643,32 @@ NS_IMETHODIMP nsIMAPHostSessionList::Set</span>
<a href="#l6.142"></a><span id="l6.142">       ns-&gt;SetDelimiter(delimiter, true);</span>
<a href="#l6.143"></a><span id="l6.143">   }</span>
<a href="#l6.144"></a><span id="l6.144">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.145"></a><span id="l6.145">   return (host) ? NS_OK : NS_ERROR_ILLEGAL_VALUE ;</span>
<a href="#l6.146"></a><span id="l6.146"> }</span>
<a href="#l6.147"></a><span id="l6.147"> </span>
<a href="#l6.148"></a><span id="l6.148"> NS_IMETHODIMP nsIMAPHostSessionList::AddShellToCacheForHost(const char *serverKey, nsIMAPBodyShell *shell)</span>
<a href="#l6.149"></a><span id="l6.149"> {</span>
<a href="#l6.150"></a><span id="l6.150" class="difflineminus">-        nsresult rv = NS_OK;</span>
<a href="#l6.151"></a><span id="l6.151" class="difflineminus">-	PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.152"></a><span id="l6.152" class="difflineminus">-	nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l6.153"></a><span id="l6.153" class="difflineminus">-	if (host)</span>
<a href="#l6.154"></a><span id="l6.154" class="difflineminus">-	{</span>
<a href="#l6.155"></a><span id="l6.155" class="difflineminus">-		if (host-&gt;fShellCache)</span>
<a href="#l6.156"></a><span id="l6.156" class="difflineminus">-		{</span>
<a href="#l6.157"></a><span id="l6.157" class="difflineminus">-			if (!host-&gt;fShellCache-&gt;AddShellToCache(shell))</span>
<a href="#l6.158"></a><span id="l6.158" class="difflineminus">-                                rv = NS_ERROR_UNEXPECTED;</span>
<a href="#l6.159"></a><span id="l6.159" class="difflineminus">-		}</span>
<a href="#l6.160"></a><span id="l6.160" class="difflineminus">-	}</span>
<a href="#l6.161"></a><span id="l6.161" class="difflineminus">-        else</span>
<a href="#l6.162"></a><span id="l6.162" class="difflineminus">-                rv = NS_ERROR_ILLEGAL_VALUE;</span>
<a href="#l6.163"></a><span id="l6.163" class="difflineplus">+  nsresult rv = NS_OK;</span>
<a href="#l6.164"></a><span id="l6.164" class="difflineplus">+  PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.165"></a><span id="l6.165" class="difflineplus">+  nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l6.166"></a><span id="l6.166" class="difflineplus">+  if (host)</span>
<a href="#l6.167"></a><span id="l6.167" class="difflineplus">+  {</span>
<a href="#l6.168"></a><span id="l6.168" class="difflineplus">+    if (host-&gt;fShellCache)</span>
<a href="#l6.169"></a><span id="l6.169" class="difflineplus">+    {</span>
<a href="#l6.170"></a><span id="l6.170" class="difflineplus">+      if (!host-&gt;fShellCache-&gt;AddShellToCache(shell))</span>
<a href="#l6.171"></a><span id="l6.171" class="difflineplus">+        rv = NS_ERROR_UNEXPECTED;</span>
<a href="#l6.172"></a><span id="l6.172" class="difflineplus">+    }</span>
<a href="#l6.173"></a><span id="l6.173" class="difflineplus">+  }</span>
<a href="#l6.174"></a><span id="l6.174" class="difflineplus">+  else</span>
<a href="#l6.175"></a><span id="l6.175" class="difflineplus">+    rv = NS_ERROR_ILLEGAL_VALUE;</span>
<a href="#l6.176"></a><span id="l6.176"> </span>
<a href="#l6.177"></a><span id="l6.177" class="difflineminus">-	PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.178"></a><span id="l6.178" class="difflineminus">-	return rv;</span>
<a href="#l6.179"></a><span id="l6.179" class="difflineplus">+  PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l6.180"></a><span id="l6.180" class="difflineplus">+  return rv;</span>
<a href="#l6.181"></a><span id="l6.181"> }</span>
<a href="#l6.182"></a><span id="l6.182"> </span>
<a href="#l6.183"></a><span id="l6.183"> NS_IMETHODIMP nsIMAPHostSessionList::FindShellInCacheForHost(const char *serverKey, const char *mailboxName, const char *UID,</span>
<a href="#l6.184"></a><span id="l6.184">                                                              IMAP_ContentModifiedType modType, nsIMAPBodyShell **shell)</span>
<a href="#l6.185"></a><span id="l6.185"> {</span>
<a href="#l6.186"></a><span id="l6.186">   nsCString uidString(UID);</span>
<a href="#l6.187"></a><span id="l6.187"> </span>
<a href="#l6.188"></a><span id="l6.188">   PR_EnterMonitor(gCachedHostInfoMonitor);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPNamespace.cpp</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPNamespace.cpp</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -14,214 +14,210 @@</span>
<a href="#l7.4"></a><span id="l7.4"> #include &quot;nsServiceManagerUtils.h&quot;</span>
<a href="#l7.5"></a><span id="l7.5"> </span>
<a href="#l7.6"></a><span id="l7.6"> //////////////////// nsIMAPNamespace  /////////////////////////////////////////////////////////////</span>
<a href="#l7.7"></a><span id="l7.7"> </span>
<a href="#l7.8"></a><span id="l7.8"> static NS_DEFINE_CID(kCImapHostSessionListCID, NS_IIMAPHOSTSESSIONLIST_CID);</span>
<a href="#l7.9"></a><span id="l7.9"> </span>
<a href="#l7.10"></a><span id="l7.10"> nsIMAPNamespace::nsIMAPNamespace(EIMAPNamespaceType type, const char *prefix, char delimiter, bool from_prefs)</span>
<a href="#l7.11"></a><span id="l7.11"> {</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-	m_namespaceType = type;</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineminus">-	m_prefix = PL_strdup(prefix);</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineminus">-	m_fromPrefs = from_prefs;</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+  m_namespaceType = type;</span>
<a href="#l7.16"></a><span id="l7.16" class="difflineplus">+  m_prefix = PL_strdup(prefix);</span>
<a href="#l7.17"></a><span id="l7.17" class="difflineplus">+  m_fromPrefs = from_prefs;</span>
<a href="#l7.18"></a><span id="l7.18"> </span>
<a href="#l7.19"></a><span id="l7.19" class="difflineminus">-	m_delimiter = delimiter;</span>
<a href="#l7.20"></a><span id="l7.20" class="difflineminus">-	m_delimiterFilledIn = !m_fromPrefs;	// if it's from the prefs, we can't be sure about the delimiter until we list it.</span>
<a href="#l7.21"></a><span id="l7.21" class="difflineplus">+  m_delimiter = delimiter;</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineplus">+  m_delimiterFilledIn = !m_fromPrefs;  // if it's from the prefs, we can't be sure about the delimiter until we list it.</span>
<a href="#l7.23"></a><span id="l7.23"> }</span>
<a href="#l7.24"></a><span id="l7.24"> </span>
<a href="#l7.25"></a><span id="l7.25"> nsIMAPNamespace::~nsIMAPNamespace()</span>
<a href="#l7.26"></a><span id="l7.26"> {</span>
<a href="#l7.27"></a><span id="l7.27" class="difflineminus">-	PR_FREEIF(m_prefix);</span>
<a href="#l7.28"></a><span id="l7.28" class="difflineplus">+  PR_FREEIF(m_prefix);</span>
<a href="#l7.29"></a><span id="l7.29"> }</span>
<a href="#l7.30"></a><span id="l7.30"> </span>
<a href="#l7.31"></a><span id="l7.31"> void nsIMAPNamespace::SetDelimiter(char delimiter, bool delimiterFilledIn)</span>
<a href="#l7.32"></a><span id="l7.32"> {</span>
<a href="#l7.33"></a><span id="l7.33">   m_delimiter = delimiter;</span>
<a href="#l7.34"></a><span id="l7.34">   m_delimiterFilledIn = delimiterFilledIn;</span>
<a href="#l7.35"></a><span id="l7.35"> }</span>
<a href="#l7.36"></a><span id="l7.36"> </span>
<a href="#l7.37"></a><span id="l7.37"> // returns -1 if this box is not part of this namespace,</span>
<a href="#l7.38"></a><span id="l7.38"> // or the length of the prefix if it is part of this namespace</span>
<a href="#l7.39"></a><span id="l7.39"> int nsIMAPNamespace::MailboxMatchesNamespace(const char *boxname)</span>
<a href="#l7.40"></a><span id="l7.40"> {</span>
<a href="#l7.41"></a><span id="l7.41" class="difflineminus">-    if (!boxname) return -1;</span>
<a href="#l7.42"></a><span id="l7.42" class="difflineplus">+  if (!boxname) return -1;</span>
<a href="#l7.43"></a><span id="l7.43"> </span>
<a href="#l7.44"></a><span id="l7.44" class="difflineminus">-    // If the namespace is part of the boxname</span>
<a href="#l7.45"></a><span id="l7.45" class="difflineminus">-    if (!m_prefix || !*m_prefix)</span>
<a href="#l7.46"></a><span id="l7.46" class="difflineminus">-        return 0;</span>
<a href="#l7.47"></a><span id="l7.47" class="difflineplus">+  // If the namespace is part of the boxname</span>
<a href="#l7.48"></a><span id="l7.48" class="difflineplus">+  if (!m_prefix || !*m_prefix)</span>
<a href="#l7.49"></a><span id="l7.49" class="difflineplus">+    return 0;</span>
<a href="#l7.50"></a><span id="l7.50"> </span>
<a href="#l7.51"></a><span id="l7.51" class="difflineminus">-    if (PL_strstr(boxname, m_prefix) == boxname)</span>
<a href="#l7.52"></a><span id="l7.52" class="difflineminus">-        return PL_strlen(m_prefix);</span>
<a href="#l7.53"></a><span id="l7.53" class="difflineplus">+  if (PL_strstr(boxname, m_prefix) == boxname)</span>
<a href="#l7.54"></a><span id="l7.54" class="difflineplus">+    return PL_strlen(m_prefix);</span>
<a href="#l7.55"></a><span id="l7.55"> </span>
<a href="#l7.56"></a><span id="l7.56" class="difflineminus">-    // If the boxname is part of the prefix</span>
<a href="#l7.57"></a><span id="l7.57" class="difflineminus">-    // (Used for matching Personal mailbox with Personal/ namespace, etc.)</span>
<a href="#l7.58"></a><span id="l7.58" class="difflineminus">-    if (PL_strstr(m_prefix, boxname) == m_prefix)</span>
<a href="#l7.59"></a><span id="l7.59" class="difflineminus">-        return PL_strlen(boxname);</span>
<a href="#l7.60"></a><span id="l7.60" class="difflineminus">-    return -1;</span>
<a href="#l7.61"></a><span id="l7.61" class="difflineplus">+  // If the boxname is part of the prefix</span>
<a href="#l7.62"></a><span id="l7.62" class="difflineplus">+  // (Used for matching Personal mailbox with Personal/ namespace, etc.)</span>
<a href="#l7.63"></a><span id="l7.63" class="difflineplus">+  if (PL_strstr(m_prefix, boxname) == m_prefix)</span>
<a href="#l7.64"></a><span id="l7.64" class="difflineplus">+    return PL_strlen(boxname);</span>
<a href="#l7.65"></a><span id="l7.65" class="difflineplus">+  return -1;</span>
<a href="#l7.66"></a><span id="l7.66"> }</span>
<a href="#l7.67"></a><span id="l7.67"> </span>
<a href="#l7.68"></a><span id="l7.68" class="difflineminus">-</span>
<a href="#l7.69"></a><span id="l7.69"> nsIMAPNamespaceList *nsIMAPNamespaceList::CreatensIMAPNamespaceList()</span>
<a href="#l7.70"></a><span id="l7.70"> {</span>
<a href="#l7.71"></a><span id="l7.71" class="difflineminus">-	nsIMAPNamespaceList *rv = new nsIMAPNamespaceList();</span>
<a href="#l7.72"></a><span id="l7.72" class="difflineminus">-	return rv;</span>
<a href="#l7.73"></a><span id="l7.73" class="difflineplus">+  nsIMAPNamespaceList *rv = new nsIMAPNamespaceList();</span>
<a href="#l7.74"></a><span id="l7.74" class="difflineplus">+  return rv;</span>
<a href="#l7.75"></a><span id="l7.75"> }</span>
<a href="#l7.76"></a><span id="l7.76"> </span>
<a href="#l7.77"></a><span id="l7.77"> nsIMAPNamespaceList::nsIMAPNamespaceList()</span>
<a href="#l7.78"></a><span id="l7.78"> {</span>
<a href="#l7.79"></a><span id="l7.79"> }</span>
<a href="#l7.80"></a><span id="l7.80"> </span>
<a href="#l7.81"></a><span id="l7.81"> int nsIMAPNamespaceList::GetNumberOfNamespaces()</span>
<a href="#l7.82"></a><span id="l7.82"> {</span>
<a href="#l7.83"></a><span id="l7.83" class="difflineminus">-	return m_NamespaceList.Length();</span>
<a href="#l7.84"></a><span id="l7.84" class="difflineplus">+  return m_NamespaceList.Length();</span>
<a href="#l7.85"></a><span id="l7.85"> }</span>
<a href="#l7.86"></a><span id="l7.86"> </span>
<a href="#l7.87"></a><span id="l7.87" class="difflineminus">-</span>
<a href="#l7.88"></a><span id="l7.88"> nsresult nsIMAPNamespaceList::InitFromString(const char *nameSpaceString, EIMAPNamespaceType nstype)</span>
<a href="#l7.89"></a><span id="l7.89"> {</span>
<a href="#l7.90"></a><span id="l7.90" class="difflineminus">-	nsresult rv = NS_OK;</span>
<a href="#l7.91"></a><span id="l7.91" class="difflineminus">-	if (nameSpaceString)</span>
<a href="#l7.92"></a><span id="l7.92" class="difflineminus">-	{</span>
<a href="#l7.93"></a><span id="l7.93" class="difflineminus">-		int numNamespaces = UnserializeNamespaces(nameSpaceString, nullptr, 0);</span>
<a href="#l7.94"></a><span id="l7.94" class="difflineminus">-		char **prefixes = (char**) PR_CALLOC(numNamespaces * sizeof(char*));</span>
<a href="#l7.95"></a><span id="l7.95" class="difflineminus">-		if (prefixes)</span>
<a href="#l7.96"></a><span id="l7.96" class="difflineminus">-		{</span>
<a href="#l7.97"></a><span id="l7.97" class="difflineminus">-			int len = UnserializeNamespaces(nameSpaceString, prefixes, numNamespaces);</span>
<a href="#l7.98"></a><span id="l7.98" class="difflineminus">-			for (int i = 0; i &lt; len; i++)</span>
<a href="#l7.99"></a><span id="l7.99" class="difflineminus">-			{</span>
<a href="#l7.100"></a><span id="l7.100" class="difflineminus">-				char *thisns = prefixes[i];</span>
<a href="#l7.101"></a><span id="l7.101" class="difflineminus">-				char delimiter = '/';	// a guess</span>
<a href="#l7.102"></a><span id="l7.102" class="difflineminus">-				if (PL_strlen(thisns) &gt;= 1)</span>
<a href="#l7.103"></a><span id="l7.103" class="difflineminus">-					delimiter = thisns[PL_strlen(thisns)-1];</span>
<a href="#l7.104"></a><span id="l7.104" class="difflineminus">-				nsIMAPNamespace *ns = new nsIMAPNamespace(nstype, thisns, delimiter, true);</span>
<a href="#l7.105"></a><span id="l7.105" class="difflineminus">-				if (ns)</span>
<a href="#l7.106"></a><span id="l7.106" class="difflineminus">-					AddNewNamespace(ns);</span>
<a href="#l7.107"></a><span id="l7.107" class="difflineminus">-				PR_FREEIF(thisns);</span>
<a href="#l7.108"></a><span id="l7.108" class="difflineminus">-			}</span>
<a href="#l7.109"></a><span id="l7.109" class="difflineminus">-			PR_Free(prefixes);</span>
<a href="#l7.110"></a><span id="l7.110" class="difflineminus">-		}</span>
<a href="#l7.111"></a><span id="l7.111" class="difflineminus">-	}</span>
<a href="#l7.112"></a><span id="l7.112" class="difflineplus">+  nsresult rv = NS_OK;</span>
<a href="#l7.113"></a><span id="l7.113" class="difflineplus">+  if (nameSpaceString)</span>
<a href="#l7.114"></a><span id="l7.114" class="difflineplus">+  {</span>
<a href="#l7.115"></a><span id="l7.115" class="difflineplus">+    int numNamespaces = UnserializeNamespaces(nameSpaceString, nullptr, 0);</span>
<a href="#l7.116"></a><span id="l7.116" class="difflineplus">+    char **prefixes = (char**) PR_CALLOC(numNamespaces * sizeof(char*));</span>
<a href="#l7.117"></a><span id="l7.117" class="difflineplus">+    if (prefixes)</span>
<a href="#l7.118"></a><span id="l7.118" class="difflineplus">+    {</span>
<a href="#l7.119"></a><span id="l7.119" class="difflineplus">+      int len = UnserializeNamespaces(nameSpaceString, prefixes, numNamespaces);</span>
<a href="#l7.120"></a><span id="l7.120" class="difflineplus">+      for (int i = 0; i &lt; len; i++)</span>
<a href="#l7.121"></a><span id="l7.121" class="difflineplus">+      {</span>
<a href="#l7.122"></a><span id="l7.122" class="difflineplus">+        char *thisns = prefixes[i];</span>
<a href="#l7.123"></a><span id="l7.123" class="difflineplus">+        char delimiter = '/';  // a guess</span>
<a href="#l7.124"></a><span id="l7.124" class="difflineplus">+        if (PL_strlen(thisns) &gt;= 1)</span>
<a href="#l7.125"></a><span id="l7.125" class="difflineplus">+          delimiter = thisns[PL_strlen(thisns)-1];</span>
<a href="#l7.126"></a><span id="l7.126" class="difflineplus">+        nsIMAPNamespace *ns = new nsIMAPNamespace(nstype, thisns, delimiter, true);</span>
<a href="#l7.127"></a><span id="l7.127" class="difflineplus">+        if (ns)</span>
<a href="#l7.128"></a><span id="l7.128" class="difflineplus">+          AddNewNamespace(ns);</span>
<a href="#l7.129"></a><span id="l7.129" class="difflineplus">+        PR_FREEIF(thisns);</span>
<a href="#l7.130"></a><span id="l7.130" class="difflineplus">+      }</span>
<a href="#l7.131"></a><span id="l7.131" class="difflineplus">+      PR_Free(prefixes);</span>
<a href="#l7.132"></a><span id="l7.132" class="difflineplus">+    }</span>
<a href="#l7.133"></a><span id="l7.133" class="difflineplus">+  }</span>
<a href="#l7.134"></a><span id="l7.134"> </span>
<a href="#l7.135"></a><span id="l7.135" class="difflineminus">-	return rv;</span>
<a href="#l7.136"></a><span id="l7.136" class="difflineplus">+  return rv;</span>
<a href="#l7.137"></a><span id="l7.137"> }</span>
<a href="#l7.138"></a><span id="l7.138"> </span>
<a href="#l7.139"></a><span id="l7.139"> nsresult nsIMAPNamespaceList::OutputToString(nsCString &amp;string)</span>
<a href="#l7.140"></a><span id="l7.140"> {</span>
<a href="#l7.141"></a><span id="l7.141" class="difflineminus">-	nsresult rv = NS_OK;</span>
<a href="#l7.142"></a><span id="l7.142" class="difflineminus">-</span>
<a href="#l7.143"></a><span id="l7.143" class="difflineminus">-	return rv;</span>
<a href="#l7.144"></a><span id="l7.144" class="difflineplus">+  nsresult rv = NS_OK;</span>
<a href="#l7.145"></a><span id="l7.145" class="difflineplus">+  return rv;</span>
<a href="#l7.146"></a><span id="l7.146"> }</span>
<a href="#l7.147"></a><span id="l7.147"> </span>
<a href="#l7.148"></a><span id="l7.148"> </span>
<a href="#l7.149"></a><span id="l7.149"> int nsIMAPNamespaceList::GetNumberOfNamespaces(EIMAPNamespaceType type)</span>
<a href="#l7.150"></a><span id="l7.150"> {</span>
<a href="#l7.151"></a><span id="l7.151" class="difflineminus">-	int nodeIndex = 0, count = 0;</span>
<a href="#l7.152"></a><span id="l7.152" class="difflineminus">-	for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l7.153"></a><span id="l7.153" class="difflineminus">-	{</span>
<a href="#l7.154"></a><span id="l7.154" class="difflineminus">-		nsIMAPNamespace *nspace = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l7.155"></a><span id="l7.155" class="difflineminus">-		if (nspace-&gt;GetType() == type)</span>
<a href="#l7.156"></a><span id="l7.156" class="difflineminus">-		{</span>
<a href="#l7.157"></a><span id="l7.157" class="difflineminus">-			count++;</span>
<a href="#l7.158"></a><span id="l7.158" class="difflineminus">-		}</span>
<a href="#l7.159"></a><span id="l7.159" class="difflineminus">-	}</span>
<a href="#l7.160"></a><span id="l7.160" class="difflineminus">-	return count;</span>
<a href="#l7.161"></a><span id="l7.161" class="difflineplus">+  int nodeIndex = 0, count = 0;</span>
<a href="#l7.162"></a><span id="l7.162" class="difflineplus">+  for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l7.163"></a><span id="l7.163" class="difflineplus">+  {</span>
<a href="#l7.164"></a><span id="l7.164" class="difflineplus">+    nsIMAPNamespace *nspace = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l7.165"></a><span id="l7.165" class="difflineplus">+    if (nspace-&gt;GetType() == type)</span>
<a href="#l7.166"></a><span id="l7.166" class="difflineplus">+    {</span>
<a href="#l7.167"></a><span id="l7.167" class="difflineplus">+      count++;</span>
<a href="#l7.168"></a><span id="l7.168" class="difflineplus">+    }</span>
<a href="#l7.169"></a><span id="l7.169" class="difflineplus">+  }</span>
<a href="#l7.170"></a><span id="l7.170" class="difflineplus">+  return count;</span>
<a href="#l7.171"></a><span id="l7.171"> }</span>
<a href="#l7.172"></a><span id="l7.172"> </span>
<a href="#l7.173"></a><span id="l7.173"> int nsIMAPNamespaceList::AddNewNamespace(nsIMAPNamespace *ns)</span>
<a href="#l7.174"></a><span id="l7.174"> {</span>
<a href="#l7.175"></a><span id="l7.175" class="difflineminus">-	// If the namespace is from the NAMESPACE response, then we should see if there</span>
<a href="#l7.176"></a><span id="l7.176" class="difflineminus">-	// are any namespaces previously set by the preferences, or the default namespace.  If so, remove these.</span>
<a href="#l7.177"></a><span id="l7.177" class="difflineplus">+  // If the namespace is from the NAMESPACE response, then we should see if there</span>
<a href="#l7.178"></a><span id="l7.178" class="difflineplus">+  // are any namespaces previously set by the preferences, or the default namespace.  If so, remove these.</span>
<a href="#l7.179"></a><span id="l7.179"> </span>
<a href="#l7.180"></a><span id="l7.180" class="difflineminus">-	if (!ns-&gt;GetIsNamespaceFromPrefs())</span>
<a href="#l7.181"></a><span id="l7.181" class="difflineminus">-	{</span>
<a href="#l7.182"></a><span id="l7.182" class="difflineminus">-		int nodeIndex;</span>
<a href="#l7.183"></a><span id="l7.183" class="difflineplus">+  if (!ns-&gt;GetIsNamespaceFromPrefs())</span>
<a href="#l7.184"></a><span id="l7.184" class="difflineplus">+  {</span>
<a href="#l7.185"></a><span id="l7.185" class="difflineplus">+    int nodeIndex;</span>
<a href="#l7.186"></a><span id="l7.186">         // iterate backwards because we delete elements</span>
<a href="#l7.187"></a><span id="l7.187" class="difflineminus">-		for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l7.188"></a><span id="l7.188" class="difflineminus">-		{</span>
<a href="#l7.189"></a><span id="l7.189" class="difflineminus">-			nsIMAPNamespace *nspace = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l7.190"></a><span id="l7.190" class="difflineminus">-			// if we find existing namespace(s) that matches the</span>
<a href="#l7.191"></a><span id="l7.191" class="difflineminus">-			// new one, we'll just remove the old ones and let the</span>
<a href="#l7.192"></a><span id="l7.192" class="difflineminus">-			// new one get added when we've finished checking for</span>
<a href="#l7.193"></a><span id="l7.193" class="difflineminus">-			// matching namespaces or namespaces that came from prefs.</span>
<a href="#l7.194"></a><span id="l7.194" class="difflineminus">-			if (nspace &amp;&amp;</span>
<a href="#l7.195"></a><span id="l7.195" class="difflineminus">-                            (nspace-&gt;GetIsNamespaceFromPrefs() ||</span>
<a href="#l7.196"></a><span id="l7.196" class="difflineminus">-                            (!PL_strcmp(ns-&gt;GetPrefix(), nspace-&gt;GetPrefix()) &amp;&amp;</span>
<a href="#l7.197"></a><span id="l7.197" class="difflineminus">-			     ns-&gt;GetType() == nspace-&gt;GetType() &amp;&amp;</span>
<a href="#l7.198"></a><span id="l7.198" class="difflineminus">-			     ns-&gt;GetDelimiter() == nspace-&gt;GetDelimiter())))</span>
<a href="#l7.199"></a><span id="l7.199" class="difflineminus">-			{</span>
<a href="#l7.200"></a><span id="l7.200" class="difflineminus">-				m_NamespaceList.RemoveElementAt(nodeIndex);</span>
<a href="#l7.201"></a><span id="l7.201" class="difflineminus">-				delete nspace;</span>
<a href="#l7.202"></a><span id="l7.202" class="difflineminus">-			}</span>
<a href="#l7.203"></a><span id="l7.203" class="difflineminus">-		}</span>
<a href="#l7.204"></a><span id="l7.204" class="difflineminus">-	}</span>
<a href="#l7.205"></a><span id="l7.205" class="difflineplus">+    for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l7.206"></a><span id="l7.206" class="difflineplus">+    {</span>
<a href="#l7.207"></a><span id="l7.207" class="difflineplus">+      nsIMAPNamespace *nspace = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l7.208"></a><span id="l7.208" class="difflineplus">+      // if we find existing namespace(s) that matches the</span>
<a href="#l7.209"></a><span id="l7.209" class="difflineplus">+      // new one, we'll just remove the old ones and let the</span>
<a href="#l7.210"></a><span id="l7.210" class="difflineplus">+      // new one get added when we've finished checking for</span>
<a href="#l7.211"></a><span id="l7.211" class="difflineplus">+      // matching namespaces or namespaces that came from prefs.</span>
<a href="#l7.212"></a><span id="l7.212" class="difflineplus">+      if (nspace &amp;&amp; (nspace-&gt;GetIsNamespaceFromPrefs() ||</span>
<a href="#l7.213"></a><span id="l7.213" class="difflineplus">+                     (!PL_strcmp(ns-&gt;GetPrefix(), nspace-&gt;GetPrefix()) &amp;&amp;</span>
<a href="#l7.214"></a><span id="l7.214" class="difflineplus">+                      ns-&gt;GetType() == nspace-&gt;GetType() &amp;&amp;</span>
<a href="#l7.215"></a><span id="l7.215" class="difflineplus">+                      ns-&gt;GetDelimiter() == nspace-&gt;GetDelimiter())))</span>
<a href="#l7.216"></a><span id="l7.216" class="difflineplus">+      {</span>
<a href="#l7.217"></a><span id="l7.217" class="difflineplus">+        m_NamespaceList.RemoveElementAt(nodeIndex);</span>
<a href="#l7.218"></a><span id="l7.218" class="difflineplus">+        delete nspace;</span>
<a href="#l7.219"></a><span id="l7.219" class="difflineplus">+      }</span>
<a href="#l7.220"></a><span id="l7.220" class="difflineplus">+    }</span>
<a href="#l7.221"></a><span id="l7.221" class="difflineplus">+  }</span>
<a href="#l7.222"></a><span id="l7.222"> </span>
<a href="#l7.223"></a><span id="l7.223" class="difflineminus">-	// Add the new namespace to the list.  This must come after the removing code,</span>
<a href="#l7.224"></a><span id="l7.224" class="difflineminus">-	// or else we could never add the initial kDefaultNamespace type to the list.</span>
<a href="#l7.225"></a><span id="l7.225" class="difflineminus">-	m_NamespaceList.AppendElement(ns);</span>
<a href="#l7.226"></a><span id="l7.226" class="difflineplus">+  // Add the new namespace to the list.  This must come after the removing code,</span>
<a href="#l7.227"></a><span id="l7.227" class="difflineplus">+  // or else we could never add the initial kDefaultNamespace type to the list.</span>
<a href="#l7.228"></a><span id="l7.228" class="difflineplus">+  m_NamespaceList.AppendElement(ns);</span>
<a href="#l7.229"></a><span id="l7.229"> </span>
<a href="#l7.230"></a><span id="l7.230" class="difflineminus">-	return 0;</span>
<a href="#l7.231"></a><span id="l7.231" class="difflineplus">+  return 0;</span>
<a href="#l7.232"></a><span id="l7.232"> }</span>
<a href="#l7.233"></a><span id="l7.233"> </span>
<a href="#l7.234"></a><span id="l7.234"> </span>
<a href="#l7.235"></a><span id="l7.235"> // chrisf - later, fix this to know the real concept of &quot;default&quot; namespace of a given type</span>
<a href="#l7.236"></a><span id="l7.236"> nsIMAPNamespace *nsIMAPNamespaceList::GetDefaultNamespaceOfType(EIMAPNamespaceType type)</span>
<a href="#l7.237"></a><span id="l7.237"> {</span>
<a href="#l7.238"></a><span id="l7.238" class="difflineminus">-	nsIMAPNamespace *rv = 0, *firstOfType = 0;</span>
<a href="#l7.239"></a><span id="l7.239" class="difflineplus">+  nsIMAPNamespace *rv = 0, *firstOfType = 0;</span>
<a href="#l7.240"></a><span id="l7.240"> </span>
<a href="#l7.241"></a><span id="l7.241" class="difflineminus">-	int nodeIndex, count = m_NamespaceList.Length();</span>
<a href="#l7.242"></a><span id="l7.242" class="difflineminus">-	for (nodeIndex= 0; nodeIndex &lt; count &amp;&amp; !rv; nodeIndex++)</span>
<a href="#l7.243"></a><span id="l7.243" class="difflineminus">-	{</span>
<a href="#l7.244"></a><span id="l7.244" class="difflineminus">-		nsIMAPNamespace *ns = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l7.245"></a><span id="l7.245" class="difflineminus">-		if (ns-&gt;GetType() == type)</span>
<a href="#l7.246"></a><span id="l7.246" class="difflineminus">-		{</span>
<a href="#l7.247"></a><span id="l7.247" class="difflineminus">-			if (!firstOfType)</span>
<a href="#l7.248"></a><span id="l7.248" class="difflineminus">-				firstOfType = ns;</span>
<a href="#l7.249"></a><span id="l7.249" class="difflineminus">-			if (!(*(ns-&gt;GetPrefix())))</span>
<a href="#l7.250"></a><span id="l7.250" class="difflineminus">-			{</span>
<a href="#l7.251"></a><span id="l7.251" class="difflineminus">-				// This namespace's prefix is &quot;&quot;</span>
<a href="#l7.252"></a><span id="l7.252" class="difflineminus">-				// Therefore it is the default</span>
<a href="#l7.253"></a><span id="l7.253" class="difflineminus">-				rv = ns;</span>
<a href="#l7.254"></a><span id="l7.254" class="difflineminus">-			}</span>
<a href="#l7.255"></a><span id="l7.255" class="difflineminus">-		}</span>
<a href="#l7.256"></a><span id="l7.256" class="difflineminus">-	}</span>
<a href="#l7.257"></a><span id="l7.257" class="difflineminus">-	if (!rv)</span>
<a href="#l7.258"></a><span id="l7.258" class="difflineminus">-		rv = firstOfType;</span>
<a href="#l7.259"></a><span id="l7.259" class="difflineminus">-	return rv;</span>
<a href="#l7.260"></a><span id="l7.260" class="difflineplus">+  int nodeIndex, count = m_NamespaceList.Length();</span>
<a href="#l7.261"></a><span id="l7.261" class="difflineplus">+  for (nodeIndex= 0; nodeIndex &lt; count &amp;&amp; !rv; nodeIndex++)</span>
<a href="#l7.262"></a><span id="l7.262" class="difflineplus">+  {</span>
<a href="#l7.263"></a><span id="l7.263" class="difflineplus">+    nsIMAPNamespace *ns = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l7.264"></a><span id="l7.264" class="difflineplus">+    if (ns-&gt;GetType() == type)</span>
<a href="#l7.265"></a><span id="l7.265" class="difflineplus">+    {</span>
<a href="#l7.266"></a><span id="l7.266" class="difflineplus">+      if (!firstOfType)</span>
<a href="#l7.267"></a><span id="l7.267" class="difflineplus">+        firstOfType = ns;</span>
<a href="#l7.268"></a><span id="l7.268" class="difflineplus">+      if (!(*(ns-&gt;GetPrefix())))</span>
<a href="#l7.269"></a><span id="l7.269" class="difflineplus">+      {</span>
<a href="#l7.270"></a><span id="l7.270" class="difflineplus">+        // This namespace's prefix is &quot;&quot;</span>
<a href="#l7.271"></a><span id="l7.271" class="difflineplus">+        // Therefore it is the default</span>
<a href="#l7.272"></a><span id="l7.272" class="difflineplus">+        rv = ns;</span>
<a href="#l7.273"></a><span id="l7.273" class="difflineplus">+      }</span>
<a href="#l7.274"></a><span id="l7.274" class="difflineplus">+    }</span>
<a href="#l7.275"></a><span id="l7.275" class="difflineplus">+  }</span>
<a href="#l7.276"></a><span id="l7.276" class="difflineplus">+  if (!rv)</span>
<a href="#l7.277"></a><span id="l7.277" class="difflineplus">+    rv = firstOfType;</span>
<a href="#l7.278"></a><span id="l7.278" class="difflineplus">+  return rv;</span>
<a href="#l7.279"></a><span id="l7.279"> }</span>
<a href="#l7.280"></a><span id="l7.280"> </span>
<a href="#l7.281"></a><span id="l7.281"> nsIMAPNamespaceList::~nsIMAPNamespaceList()</span>
<a href="#l7.282"></a><span id="l7.282"> {</span>
<a href="#l7.283"></a><span id="l7.283" class="difflineminus">-	ClearNamespaces(true, true, true);</span>
<a href="#l7.284"></a><span id="l7.284" class="difflineplus">+  ClearNamespaces(true, true, true);</span>
<a href="#l7.285"></a><span id="l7.285"> }</span>
<a href="#l7.286"></a><span id="l7.286"> </span>
<a href="#l7.287"></a><span id="l7.287"> // ClearNamespaces removes and deletes the namespaces specified, and if there are no namespaces left,</span>
<a href="#l7.288"></a><span id="l7.288"> void nsIMAPNamespaceList::ClearNamespaces(bool deleteFromPrefsNamespaces, bool deleteServerAdvertisedNamespaces, bool reallyDelete)</span>
<a href="#l7.289"></a><span id="l7.289"> {</span>
<a href="#l7.290"></a><span id="l7.290" class="difflineminus">-	int nodeIndex;</span>
<a href="#l7.291"></a><span id="l7.291" class="difflineminus">-	</span>
<a href="#l7.292"></a><span id="l7.292" class="difflineplus">+  int nodeIndex;</span>
<a href="#l7.293"></a><span id="l7.293" class="difflineplus">+</span>
<a href="#l7.294"></a><span id="l7.294">     // iterate backwards because we delete elements</span>
<a href="#l7.295"></a><span id="l7.295" class="difflineminus">-	for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l7.296"></a><span id="l7.296" class="difflineminus">-	{</span>
<a href="#l7.297"></a><span id="l7.297" class="difflineminus">-		nsIMAPNamespace *ns = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l7.298"></a><span id="l7.298" class="difflineminus">-		if (ns-&gt;GetIsNamespaceFromPrefs())</span>
<a href="#l7.299"></a><span id="l7.299" class="difflineminus">-		{</span>
<a href="#l7.300"></a><span id="l7.300" class="difflineminus">-			if (deleteFromPrefsNamespaces)</span>
<a href="#l7.301"></a><span id="l7.301" class="difflineminus">-			{</span>
<a href="#l7.302"></a><span id="l7.302" class="difflineminus">-				m_NamespaceList.RemoveElementAt(nodeIndex);</span>
<a href="#l7.303"></a><span id="l7.303" class="difflineminus">-				if (reallyDelete)</span>
<a href="#l7.304"></a><span id="l7.304" class="difflineminus">-					delete ns;</span>
<a href="#l7.305"></a><span id="l7.305" class="difflineminus">-			}</span>
<a href="#l7.306"></a><span id="l7.306" class="difflineminus">-		}</span>
<a href="#l7.307"></a><span id="l7.307" class="difflineminus">-		else if (deleteServerAdvertisedNamespaces)</span>
<a href="#l7.308"></a><span id="l7.308" class="difflineminus">-		{</span>
<a href="#l7.309"></a><span id="l7.309" class="difflineminus">-			m_NamespaceList.RemoveElementAt(nodeIndex);</span>
<a href="#l7.310"></a><span id="l7.310" class="difflineminus">-			if (reallyDelete)</span>
<a href="#l7.311"></a><span id="l7.311" class="difflineminus">-				delete ns;</span>
<a href="#l7.312"></a><span id="l7.312" class="difflineminus">-		}</span>
<a href="#l7.313"></a><span id="l7.313" class="difflineminus">-	}</span>
<a href="#l7.314"></a><span id="l7.314" class="difflineplus">+  for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l7.315"></a><span id="l7.315" class="difflineplus">+  {</span>
<a href="#l7.316"></a><span id="l7.316" class="difflineplus">+    nsIMAPNamespace *ns = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l7.317"></a><span id="l7.317" class="difflineplus">+    if (ns-&gt;GetIsNamespaceFromPrefs())</span>
<a href="#l7.318"></a><span id="l7.318" class="difflineplus">+    {</span>
<a href="#l7.319"></a><span id="l7.319" class="difflineplus">+      if (deleteFromPrefsNamespaces)</span>
<a href="#l7.320"></a><span id="l7.320" class="difflineplus">+      {</span>
<a href="#l7.321"></a><span id="l7.321" class="difflineplus">+        m_NamespaceList.RemoveElementAt(nodeIndex);</span>
<a href="#l7.322"></a><span id="l7.322" class="difflineplus">+        if (reallyDelete)</span>
<a href="#l7.323"></a><span id="l7.323" class="difflineplus">+          delete ns;</span>
<a href="#l7.324"></a><span id="l7.324" class="difflineplus">+      }</span>
<a href="#l7.325"></a><span id="l7.325" class="difflineplus">+    }</span>
<a href="#l7.326"></a><span id="l7.326" class="difflineplus">+    else if (deleteServerAdvertisedNamespaces)</span>
<a href="#l7.327"></a><span id="l7.327" class="difflineplus">+    {</span>
<a href="#l7.328"></a><span id="l7.328" class="difflineplus">+      m_NamespaceList.RemoveElementAt(nodeIndex);</span>
<a href="#l7.329"></a><span id="l7.329" class="difflineplus">+      if (reallyDelete)</span>
<a href="#l7.330"></a><span id="l7.330" class="difflineplus">+        delete ns;</span>
<a href="#l7.331"></a><span id="l7.331" class="difflineplus">+    }</span>
<a href="#l7.332"></a><span id="l7.332" class="difflineplus">+  }</span>
<a href="#l7.333"></a><span id="l7.333"> }</span>
<a href="#l7.334"></a><span id="l7.334"> </span>
<a href="#l7.335"></a><span id="l7.335"> nsIMAPNamespace *nsIMAPNamespaceList::GetNamespaceNumber(int nodeIndex)</span>
<a href="#l7.336"></a><span id="l7.336"> {</span>
<a href="#l7.337"></a><span id="l7.337">   NS_ASSERTION(nodeIndex &gt;= 0 &amp;&amp; nodeIndex &lt; GetNumberOfNamespaces(), &quot;invalid IMAP namespace node index&quot;);</span>
<a href="#l7.338"></a><span id="l7.338">   if (nodeIndex &lt; 0) nodeIndex = 0;</span>
<a href="#l7.339"></a><span id="l7.339"> </span>
<a href="#l7.340"></a><span id="l7.340">   // XXX really could be just ElementAt; that's why we have the assertion</span>
<a href="#l7.341"></a><span id="l7.341" class="difflineat">@@ -461,21 +457,21 @@ nsIMAPNamespace* nsIMAPNamespaceList::Ge</span>
<a href="#l7.342"></a><span id="l7.342"> char *nsIMAPNamespaceList::AllocateServerFolderName(const char *canonicalFolderName, char delimiter)</span>
<a href="#l7.343"></a><span id="l7.343"> {</span>
<a href="#l7.344"></a><span id="l7.344">   if (delimiter)</span>
<a href="#l7.345"></a><span id="l7.345">     return nsImapUrl::ReplaceCharsInCopiedString(canonicalFolderName, '/', delimiter);</span>
<a href="#l7.346"></a><span id="l7.346">   return NS_strdup(canonicalFolderName);</span>
<a href="#l7.347"></a><span id="l7.347"> }</span>
<a href="#l7.348"></a><span id="l7.348"> </span>
<a href="#l7.349"></a><span id="l7.349"> /*</span>
<a href="#l7.350"></a><span id="l7.350" class="difflineminus">-	GetFolderOwnerNameFromPath takes as inputs a folder name</span>
<a href="#l7.351"></a><span id="l7.351" class="difflineminus">-	in canonical form, and a namespace for that folder.</span>
<a href="#l7.352"></a><span id="l7.352" class="difflineminus">-	The namespace MUST be of type kOtherUsersNamespace, hence the folder MUST be</span>
<a href="#l7.353"></a><span id="l7.353" class="difflineminus">-	owned by another user.  This function extracts the folder owner's name from the</span>
<a href="#l7.354"></a><span id="l7.354" class="difflineminus">-	canonical name of the folder, and returns an allocated copy of that owner's name</span>
<a href="#l7.355"></a><span id="l7.355" class="difflineplus">+  GetFolderOwnerNameFromPath takes as inputs a folder name</span>
<a href="#l7.356"></a><span id="l7.356" class="difflineplus">+  in canonical form, and a namespace for that folder.</span>
<a href="#l7.357"></a><span id="l7.357" class="difflineplus">+  The namespace MUST be of type kOtherUsersNamespace, hence the folder MUST be</span>
<a href="#l7.358"></a><span id="l7.358" class="difflineplus">+  owned by another user.  This function extracts the folder owner's name from the</span>
<a href="#l7.359"></a><span id="l7.359" class="difflineplus">+  canonical name of the folder, and returns an allocated copy of that owner's name</span>
<a href="#l7.360"></a><span id="l7.360"> */</span>
<a href="#l7.361"></a><span id="l7.361"> /* static */</span>
<a href="#l7.362"></a><span id="l7.362"> char *nsIMAPNamespaceList::GetFolderOwnerNameFromPath(nsIMAPNamespace *namespaceForFolder, const char *canonicalFolderName)</span>
<a href="#l7.363"></a><span id="l7.363"> {</span>
<a href="#l7.364"></a><span id="l7.364">   if (!namespaceForFolder || !canonicalFolderName)</span>
<a href="#l7.365"></a><span id="l7.365">   {</span>
<a href="#l7.366"></a><span id="l7.366">     NS_ASSERTION(false,&quot;null namespace or canonical folder name&quot;);</span>
<a href="#l7.367"></a><span id="l7.367">     return nullptr;</span>
<a href="#l7.368"></a><span id="l7.368" class="difflineat">@@ -522,17 +518,17 @@ bool nsIMAPNamespaceList::GetFolderIsNam</span>
<a href="#l7.369"></a><span id="l7.369">                                                  char delimiter,nsIMAPNamespace *namespaceForFolder)</span>
<a href="#l7.370"></a><span id="l7.370"> {</span>
<a href="#l7.371"></a><span id="l7.371">   NS_ASSERTION(namespaceForFolder, &quot;null namespace&quot;);</span>
<a href="#l7.372"></a><span id="l7.372"> </span>
<a href="#l7.373"></a><span id="l7.373">   bool rv = false;</span>
<a href="#l7.374"></a><span id="l7.374"> </span>
<a href="#l7.375"></a><span id="l7.375">   const char *prefix = namespaceForFolder-&gt;GetPrefix();</span>
<a href="#l7.376"></a><span id="l7.376">   NS_ASSERTION(prefix, &quot;namespace has no prefix&quot;);</span>
<a href="#l7.377"></a><span id="l7.377" class="difflineminus">-  if (!prefix || !*prefix)	// empty namespace prefix</span>
<a href="#l7.378"></a><span id="l7.378" class="difflineplus">+  if (!prefix || !*prefix)  // empty namespace prefix</span>
<a href="#l7.379"></a><span id="l7.379">     return false;</span>
<a href="#l7.380"></a><span id="l7.380"> </span>
<a href="#l7.381"></a><span id="l7.381">   char *convertedFolderName = AllocateServerFolderName(canonicalFolderName, delimiter);</span>
<a href="#l7.382"></a><span id="l7.382">   if (convertedFolderName)</span>
<a href="#l7.383"></a><span id="l7.383">   {</span>
<a href="#l7.384"></a><span id="l7.384">     bool lastCharIsDelimiter = (prefix[strlen(prefix) - 1] == delimiter);</span>
<a href="#l7.385"></a><span id="l7.385"> </span>
<a href="#l7.386"></a><span id="l7.386">     if (lastCharIsDelimiter)</span>
<a href="#l7.387"></a><span id="l7.387" class="difflineat">@@ -577,20 +573,20 @@ void nsIMAPNamespaceList::SuggestHierarc</span>
<a href="#l7.388"></a><span id="l7.388">   PR_smprintf(&quot;%s%s&quot;, prefix, onlineServerName) if there is a NULL owner</span>
<a href="#l7.389"></a><span id="l7.389">   PR_smprintf(&quot;%s%s%c%s&quot;, prefix, owner, delimiter, onlineServerName) if there is an owner</span>
<a href="#l7.390"></a><span id="l7.390">   It then converts this back to canonical form and returns it (allocated) to libmsg.</span>
<a href="#l7.391"></a><span id="l7.391">   It returns NULL if there is no namespace of the given type.</span>
<a href="#l7.392"></a><span id="l7.392">   If nsUsed is not passed in as NULL, then *nsUsed is filled in and returned;  it is the</span>
<a href="#l7.393"></a><span id="l7.393">   namespace used for generating the folder name.</span>
<a href="#l7.394"></a><span id="l7.394"> */</span>
<a href="#l7.395"></a><span id="l7.395"> char *nsIMAPNamespaceList::GenerateFullFolderNameWithDefaultNamespace(const char *hostName,</span>
<a href="#l7.396"></a><span id="l7.396" class="difflineminus">-                                                                                const char *canonicalFolderName,</span>
<a href="#l7.397"></a><span id="l7.397" class="difflineminus">-                                                                                const char *owner,</span>
<a href="#l7.398"></a><span id="l7.398" class="difflineminus">-                                                                                EIMAPNamespaceType nsType,</span>
<a href="#l7.399"></a><span id="l7.399" class="difflineminus">-                                                                                nsIMAPNamespace **nsUsed)</span>
<a href="#l7.400"></a><span id="l7.400" class="difflineplus">+                                                                      const char *canonicalFolderName,</span>
<a href="#l7.401"></a><span id="l7.401" class="difflineplus">+                                                                      const char *owner,</span>
<a href="#l7.402"></a><span id="l7.402" class="difflineplus">+                                                                      EIMAPNamespaceType nsType,</span>
<a href="#l7.403"></a><span id="l7.403" class="difflineplus">+                                                                      nsIMAPNamespace **nsUsed)</span>
<a href="#l7.404"></a><span id="l7.404"> {</span>
<a href="#l7.405"></a><span id="l7.405">   nsresult rv = NS_OK;</span>
<a href="#l7.406"></a><span id="l7.406"> </span>
<a href="#l7.407"></a><span id="l7.407">   nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession =</span>
<a href="#l7.408"></a><span id="l7.408">            do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l7.409"></a><span id="l7.409">   NS_ENSURE_SUCCESS(rv, nullptr);</span>
<a href="#l7.410"></a><span id="l7.410">   nsIMAPNamespace *ns;</span>
<a href="#l7.411"></a><span id="l7.411">   char *fullFolderName = nullptr;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPNamespace.h</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPNamespace.h</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -12,33 +12,33 @@</span>
<a href="#l8.4"></a><span id="l8.4"> class nsIMAPNamespace</span>
<a href="#l8.5"></a><span id="l8.5"> {</span>
<a href="#l8.6"></a><span id="l8.6"> </span>
<a href="#l8.7"></a><span id="l8.7"> public:</span>
<a href="#l8.8"></a><span id="l8.8">   nsIMAPNamespace(EIMAPNamespaceType type, const char *prefix, char delimiter, bool from_prefs);</span>
<a href="#l8.9"></a><span id="l8.9"> </span>
<a href="#l8.10"></a><span id="l8.10">   ~nsIMAPNamespace();</span>
<a href="#l8.11"></a><span id="l8.11"> </span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-  EIMAPNamespaceType    GetType() { return m_namespaceType; }</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineminus">-  const char *          GetPrefix() { return m_prefix; }</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineminus">-  char                  GetDelimiter() { return m_delimiter; }</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineminus">-  void                  SetDelimiter(char delimiter, bool delimiterFilledIn);</span>
<a href="#l8.16"></a><span id="l8.16" class="difflineminus">-  bool                  GetIsDelimiterFilledIn() { return m_delimiterFilledIn; }</span>
<a href="#l8.17"></a><span id="l8.17" class="difflineminus">-  bool                  GetIsNamespaceFromPrefs() { return m_fromPrefs; }</span>
<a href="#l8.18"></a><span id="l8.18" class="difflineplus">+  EIMAPNamespaceType GetType() { return m_namespaceType; }</span>
<a href="#l8.19"></a><span id="l8.19" class="difflineplus">+  const char *       GetPrefix() { return m_prefix; }</span>
<a href="#l8.20"></a><span id="l8.20" class="difflineplus">+  char               GetDelimiter() { return m_delimiter; }</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineplus">+  void               SetDelimiter(char delimiter, bool delimiterFilledIn);</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineplus">+  bool               GetIsDelimiterFilledIn() { return m_delimiterFilledIn; }</span>
<a href="#l8.23"></a><span id="l8.23" class="difflineplus">+  bool               GetIsNamespaceFromPrefs() { return m_fromPrefs; }</span>
<a href="#l8.24"></a><span id="l8.24"> </span>
<a href="#l8.25"></a><span id="l8.25">   // returns -1 if this box is not part of this namespace,</span>
<a href="#l8.26"></a><span id="l8.26">   // or the length of the prefix if it is part of this namespace</span>
<a href="#l8.27"></a><span id="l8.27" class="difflineminus">-  int                   MailboxMatchesNamespace(const char *boxname);</span>
<a href="#l8.28"></a><span id="l8.28" class="difflineplus">+  int                MailboxMatchesNamespace(const char *boxname);</span>
<a href="#l8.29"></a><span id="l8.29"> </span>
<a href="#l8.30"></a><span id="l8.30"> protected:</span>
<a href="#l8.31"></a><span id="l8.31">   EIMAPNamespaceType m_namespaceType;</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineminus">-  char    *m_prefix;</span>
<a href="#l8.33"></a><span id="l8.33" class="difflineminus">-  char    m_delimiter;</span>
<a href="#l8.34"></a><span id="l8.34" class="difflineminus">-  bool    m_fromPrefs;</span>
<a href="#l8.35"></a><span id="l8.35" class="difflineminus">-  bool    m_delimiterFilledIn;</span>
<a href="#l8.36"></a><span id="l8.36" class="difflineplus">+  char *m_prefix;</span>
<a href="#l8.37"></a><span id="l8.37" class="difflineplus">+  char m_delimiter;</span>
<a href="#l8.38"></a><span id="l8.38" class="difflineplus">+  bool m_fromPrefs;</span>
<a href="#l8.39"></a><span id="l8.39" class="difflineplus">+  bool m_delimiterFilledIn;</span>
<a href="#l8.40"></a><span id="l8.40"> </span>
<a href="#l8.41"></a><span id="l8.41"> };</span>
<a href="#l8.42"></a><span id="l8.42"> </span>
<a href="#l8.43"></a><span id="l8.43"> </span>
<a href="#l8.44"></a><span id="l8.44"> // represents an array of namespaces for a given host</span>
<a href="#l8.45"></a><span id="l8.45"> class nsIMAPNamespaceList</span>
<a href="#l8.46"></a><span id="l8.46"> {</span>
<a href="#l8.47"></a><span id="l8.47"> public:</span>
<a href="#l8.48"></a><span id="l8.48" class="difflineat">@@ -47,42 +47,40 @@ public:</span>
<a href="#l8.49"></a><span id="l8.49">   static nsIMAPNamespaceList *CreatensIMAPNamespaceList();</span>
<a href="#l8.50"></a><span id="l8.50"> </span>
<a href="#l8.51"></a><span id="l8.51">   nsresult InitFromString(const char *nameSpaceString, EIMAPNamespaceType nstype);</span>
<a href="#l8.52"></a><span id="l8.52">   nsresult OutputToString(nsCString &amp;OutputString);</span>
<a href="#l8.53"></a><span id="l8.53">   int UnserializeNamespaces(const char *str, char **prefixes, int len);</span>
<a href="#l8.54"></a><span id="l8.54">   nsresult SerializeNamespaces(char **prefixes, int len, nsCString &amp;serializedNamespace);</span>
<a href="#l8.55"></a><span id="l8.55"> </span>
<a href="#l8.56"></a><span id="l8.56">   void ClearNamespaces(bool deleteFromPrefsNamespaces, bool deleteServerAdvertisedNamespaces, bool reallyDelete);</span>
<a href="#l8.57"></a><span id="l8.57" class="difflineminus">-  int	GetNumberOfNamespaces();</span>
<a href="#l8.58"></a><span id="l8.58" class="difflineminus">-  int	GetNumberOfNamespaces(EIMAPNamespaceType);</span>
<a href="#l8.59"></a><span id="l8.59" class="difflineplus">+  int GetNumberOfNamespaces();</span>
<a href="#l8.60"></a><span id="l8.60" class="difflineplus">+  int GetNumberOfNamespaces(EIMAPNamespaceType);</span>
<a href="#l8.61"></a><span id="l8.61">   nsIMAPNamespace *GetNamespaceNumber(int nodeIndex);</span>
<a href="#l8.62"></a><span id="l8.62">   nsIMAPNamespace *GetNamespaceNumber(int nodeIndex, EIMAPNamespaceType);</span>
<a href="#l8.63"></a><span id="l8.63"> </span>
<a href="#l8.64"></a><span id="l8.64">   nsIMAPNamespace *GetDefaultNamespaceOfType(EIMAPNamespaceType type);</span>
<a href="#l8.65"></a><span id="l8.65">   int AddNewNamespace(nsIMAPNamespace *ns);</span>
<a href="#l8.66"></a><span id="l8.66">   nsIMAPNamespace *GetNamespaceForMailbox(const char *boxname);</span>
<a href="#l8.67"></a><span id="l8.67">   static nsIMAPNamespace* GetNamespaceForFolder(const char *hostName,</span>
<a href="#l8.68"></a><span id="l8.68" class="difflineminus">-                                           const char *canonicalFolderName,</span>
<a href="#l8.69"></a><span id="l8.69" class="difflineminus">-                                           char delimiter);</span>
<a href="#l8.70"></a><span id="l8.70" class="difflineplus">+                                                const char *canonicalFolderName,</span>
<a href="#l8.71"></a><span id="l8.71" class="difflineplus">+                                                char delimiter);</span>
<a href="#l8.72"></a><span id="l8.72">   static bool GetFolderIsNamespace(const char *hostName,</span>
<a href="#l8.73"></a><span id="l8.73" class="difflineminus">-                              const char *canonicalFolderName,</span>
<a href="#l8.74"></a><span id="l8.74" class="difflineminus">-                              char delimiter,nsIMAPNamespace *namespaceForFolder);</span>
<a href="#l8.75"></a><span id="l8.75" class="difflineplus">+                                   const char *canonicalFolderName,</span>
<a href="#l8.76"></a><span id="l8.76" class="difflineplus">+                                   char delimiter,nsIMAPNamespace *namespaceForFolder);</span>
<a href="#l8.77"></a><span id="l8.77">   static char* GetFolderNameWithoutNamespace(nsIMAPNamespace *namespaceForFolder, const char *canonicalFolderName);</span>
<a href="#l8.78"></a><span id="l8.78">   static char *AllocateServerFolderName(const char *canonicalFolderName, char delimiter);</span>
<a href="#l8.79"></a><span id="l8.79">   static char *GetFolderOwnerNameFromPath(nsIMAPNamespace *namespaceForFolder, const char *canonicalFolderName);</span>
<a href="#l8.80"></a><span id="l8.80">   static char *AllocateCanonicalFolderName(const char *onlineFolderName, char delimiter);</span>
<a href="#l8.81"></a><span id="l8.81">   static void  SuggestHierarchySeparatorForNamespace(nsIMAPNamespace *namespaceForFolder, char delimiterFromFolder);</span>
<a href="#l8.82"></a><span id="l8.82">   static char *GenerateFullFolderNameWithDefaultNamespace(const char *hostName,</span>
<a href="#l8.83"></a><span id="l8.83" class="difflineminus">-                                                                                const char *canonicalFolderName,</span>
<a href="#l8.84"></a><span id="l8.84" class="difflineminus">-                                                                                const char *owner,</span>
<a href="#l8.85"></a><span id="l8.85" class="difflineminus">-                                                                                EIMAPNamespaceType nsType,</span>
<a href="#l8.86"></a><span id="l8.86" class="difflineminus">-                                                                                nsIMAPNamespace **nsUsed);</span>
<a href="#l8.87"></a><span id="l8.87" class="difflineplus">+                                                          const char *canonicalFolderName,</span>
<a href="#l8.88"></a><span id="l8.88" class="difflineplus">+                                                          const char *owner,</span>
<a href="#l8.89"></a><span id="l8.89" class="difflineplus">+                                                          EIMAPNamespaceType nsType,</span>
<a href="#l8.90"></a><span id="l8.90" class="difflineplus">+                                                          nsIMAPNamespace **nsUsed);</span>
<a href="#l8.91"></a><span id="l8.91"> </span>
<a href="#l8.92"></a><span id="l8.92"> protected:</span>
<a href="#l8.93"></a><span id="l8.93" class="difflineminus">-  nsIMAPNamespaceList();	// use CreatensIMAPNamespaceList to create one</span>
<a href="#l8.94"></a><span id="l8.94" class="difflineplus">+  nsIMAPNamespaceList();  // use CreatensIMAPNamespaceList to create one</span>
<a href="#l8.95"></a><span id="l8.95"> </span>
<a href="#l8.96"></a><span id="l8.96">   nsTArray&lt;nsIMAPNamespace*&gt; m_NamespaceList;</span>
<a href="#l8.97"></a><span id="l8.97"> </span>
<a href="#l8.98"></a><span id="l8.98"> };</span>
<a href="#l8.99"></a><span id="l8.99" class="difflineminus">-</span>
<a href="#l8.100"></a><span id="l8.100" class="difflineminus">-</span>
<a href="#l8.101"></a><span id="l8.101"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/imap/src/nsImapCore.h</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapCore.h</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -8,81 +8,81 @@</span>
<a href="#l9.4"></a><span id="l9.4"> </span>
<a href="#l9.5"></a><span id="l9.5"> #include &quot;MailNewsTypes.h&quot;</span>
<a href="#l9.6"></a><span id="l9.6"> #include &quot;nsString.h&quot;</span>
<a href="#l9.7"></a><span id="l9.7"> </span>
<a href="#l9.8"></a><span id="l9.8"> /* imap message flags */</span>
<a href="#l9.9"></a><span id="l9.9"> typedef uint16_t imapMessageFlagsType;</span>
<a href="#l9.10"></a><span id="l9.10"> </span>
<a href="#l9.11"></a><span id="l9.11"> /* used for communication between imap thread and event sinks */</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-#define kNoFlags     0x00 /* RFC flags */</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineminus">-#define kMarked      0x01</span>
<a href="#l9.14"></a><span id="l9.14" class="difflineminus">-#define kUnmarked    0x02</span>
<a href="#l9.15"></a><span id="l9.15" class="difflineminus">-#define kNoinferiors 0x04</span>
<a href="#l9.16"></a><span id="l9.16" class="difflineminus">-#define kNoselect    0x08</span>
<a href="#l9.17"></a><span id="l9.17" class="difflineminus">-#define kImapTrash   0x10 /* Navigator flag */</span>
<a href="#l9.18"></a><span id="l9.18" class="difflineminus">-#define kJustExpunged 0x20 /* This update is a post expunge url update. */</span>
<a href="#l9.19"></a><span id="l9.19" class="difflineminus">-#define kPersonalMailbox 0x40 /* this mailbox is in the personal namespace */</span>
<a href="#l9.20"></a><span id="l9.20" class="difflineminus">-#define kPublicMailbox 0x80 /* this mailbox is in the public namespace */</span>
<a href="#l9.21"></a><span id="l9.21" class="difflineminus">-#define kOtherUsersMailbox 0x100 /* this mailbox is in the other users' namespace */</span>
<a href="#l9.22"></a><span id="l9.22" class="difflineminus">-#define kNameSpace 0x200 /* this mailbox IS a namespace */</span>
<a href="#l9.23"></a><span id="l9.23" class="difflineminus">-#define kNewlyCreatedFolder 0x400 /* this folder was just created */</span>
<a href="#l9.24"></a><span id="l9.24" class="difflineminus">-#define kImapDrafts 0x800 /* XLIST says this is the drafts folder */</span>
<a href="#l9.25"></a><span id="l9.25" class="difflineminus">-#define kImapSpam 0x1000 /* XLIST says this is the spam folder */</span>
<a href="#l9.26"></a><span id="l9.26" class="difflineminus">-#define kImapSent 0x2000 /* XLIST says this is the sent folder */</span>
<a href="#l9.27"></a><span id="l9.27" class="difflineminus">-#define kImapInbox 0x4000 /* XLIST says this is the INBOX folder */</span>
<a href="#l9.28"></a><span id="l9.28" class="difflineminus">-#define kImapAllMail 0x8000 /* XLIST says this is AllMail (GMail) */</span>
<a href="#l9.29"></a><span id="l9.29" class="difflineminus">-#define kImapXListTrash 0x10000 /* XLIST says this is the trash */</span>
<a href="#l9.30"></a><span id="l9.30" class="difflineminus">-#define kNonExistent 0x20000 /* RFC 5258, LIST-EXTENDED */</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineminus">-#define kSubscribed 0x40000 /* RFC 5258, LIST-EXTENDED */</span>
<a href="#l9.32"></a><span id="l9.32" class="difflineminus">-#define kRemote 0x80000 /* RFC 5258, LIST-EXTENDED */</span>
<a href="#l9.33"></a><span id="l9.33" class="difflineminus">-#define kHasChildren 0x100000 /* RFC 5258, LIST-EXTENDED */</span>
<a href="#l9.34"></a><span id="l9.34" class="difflineminus">-#define kHasNoChildren 0x200000 /* RFC 5258, LIST-EXTENDED */</span>
<a href="#l9.35"></a><span id="l9.35" class="difflineminus">-#define kImapArchive 0x400000 /* RFC 5258, LIST-EXTENDED */</span>
<a href="#l9.36"></a><span id="l9.36" class="difflineplus">+#define kNoFlags            0x00 /* RFC flags */</span>
<a href="#l9.37"></a><span id="l9.37" class="difflineplus">+#define kMarked             0x01</span>
<a href="#l9.38"></a><span id="l9.38" class="difflineplus">+#define kUnmarked           0x02</span>
<a href="#l9.39"></a><span id="l9.39" class="difflineplus">+#define kNoinferiors        0x04</span>
<a href="#l9.40"></a><span id="l9.40" class="difflineplus">+#define kNoselect           0x08</span>
<a href="#l9.41"></a><span id="l9.41" class="difflineplus">+#define kImapTrash          0x10     /* Navigator flag */</span>
<a href="#l9.42"></a><span id="l9.42" class="difflineplus">+#define kJustExpunged       0x20     /* This update is a post expunge url update. */</span>
<a href="#l9.43"></a><span id="l9.43" class="difflineplus">+#define kPersonalMailbox    0x40     /* this mailbox is in the personal namespace */</span>
<a href="#l9.44"></a><span id="l9.44" class="difflineplus">+#define kPublicMailbox      0x80     /* this mailbox is in the public namespace */</span>
<a href="#l9.45"></a><span id="l9.45" class="difflineplus">+#define kOtherUsersMailbox  0x100    /* this mailbox is in the other users' namespace */</span>
<a href="#l9.46"></a><span id="l9.46" class="difflineplus">+#define kNameSpace          0x200    /* this mailbox IS a namespace */</span>
<a href="#l9.47"></a><span id="l9.47" class="difflineplus">+#define kNewlyCreatedFolder 0x400    /* this folder was just created */</span>
<a href="#l9.48"></a><span id="l9.48" class="difflineplus">+#define kImapDrafts         0x800    /* XLIST says this is the drafts folder */</span>
<a href="#l9.49"></a><span id="l9.49" class="difflineplus">+#define kImapSpam           0x1000   /* XLIST says this is the spam folder */</span>
<a href="#l9.50"></a><span id="l9.50" class="difflineplus">+#define kImapSent           0x2000   /* XLIST says this is the sent folder */</span>
<a href="#l9.51"></a><span id="l9.51" class="difflineplus">+#define kImapInbox          0x4000   /* XLIST says this is the INBOX folder */</span>
<a href="#l9.52"></a><span id="l9.52" class="difflineplus">+#define kImapAllMail        0x8000   /* XLIST says this is AllMail (GMail) */</span>
<a href="#l9.53"></a><span id="l9.53" class="difflineplus">+#define kImapXListTrash     0x10000  /* XLIST says this is the trash */</span>
<a href="#l9.54"></a><span id="l9.54" class="difflineplus">+#define kNonExistent        0x20000  /* RFC 5258, LIST-EXTENDED */</span>
<a href="#l9.55"></a><span id="l9.55" class="difflineplus">+#define kSubscribed         0x40000  /* RFC 5258, LIST-EXTENDED */</span>
<a href="#l9.56"></a><span id="l9.56" class="difflineplus">+#define kRemote             0x80000  /* RFC 5258, LIST-EXTENDED */</span>
<a href="#l9.57"></a><span id="l9.57" class="difflineplus">+#define kHasChildren        0x100000 /* RFC 5258, LIST-EXTENDED */</span>
<a href="#l9.58"></a><span id="l9.58" class="difflineplus">+#define kHasNoChildren      0x200000 /* RFC 5258, LIST-EXTENDED */</span>
<a href="#l9.59"></a><span id="l9.59" class="difflineplus">+#define kImapArchive        0x400000 /* RFC 5258, LIST-EXTENDED */</span>
<a href="#l9.60"></a><span id="l9.60"> </span>
<a href="#l9.61"></a><span id="l9.61"> /* flags for individual messages */</span>
<a href="#l9.62"></a><span id="l9.62"> /* currently the ui only offers \Seen and \Flagged */</span>
<a href="#l9.63"></a><span id="l9.63"> #define kNoImapMsgFlag                0x0000</span>
<a href="#l9.64"></a><span id="l9.64"> #define kImapMsgSeenFlag              0x0001</span>
<a href="#l9.65"></a><span id="l9.65"> #define kImapMsgAnsweredFlag          0x0002</span>
<a href="#l9.66"></a><span id="l9.66"> #define kImapMsgFlaggedFlag           0x0004</span>
<a href="#l9.67"></a><span id="l9.67"> #define kImapMsgDeletedFlag           0x0008</span>
<a href="#l9.68"></a><span id="l9.68"> #define kImapMsgDraftFlag             0x0010</span>
<a href="#l9.69"></a><span id="l9.69"> #define kImapMsgRecentFlag            0x0020</span>
<a href="#l9.70"></a><span id="l9.70" class="difflineminus">-#define kImapMsgForwardedFlag         0x0040		/* Not always supported, check mailbox folder */</span>
<a href="#l9.71"></a><span id="l9.71" class="difflineminus">-#define kImapMsgMDNSentFlag           0x0080		/* Not always supported. check mailbox folder */</span>
<a href="#l9.72"></a><span id="l9.72" class="difflineminus">-#define kImapMsgCustomKeywordFlag     0x0100            /* this msg has a custom keyword */</span>
<a href="#l9.73"></a><span id="l9.73" class="difflineminus">-#define kImapMsgLabelFlags            0x0E00            /* supports 5 labels only supported if the folder supports keywords */</span>
<a href="#l9.74"></a><span id="l9.74" class="difflineplus">+#define kImapMsgForwardedFlag         0x0040  /* Not always supported, check mailbox folder */</span>
<a href="#l9.75"></a><span id="l9.75" class="difflineplus">+#define kImapMsgMDNSentFlag           0x0080  /* Not always supported. check mailbox folder */</span>
<a href="#l9.76"></a><span id="l9.76" class="difflineplus">+#define kImapMsgCustomKeywordFlag     0x0100  /* this msg has a custom keyword */</span>
<a href="#l9.77"></a><span id="l9.77" class="difflineplus">+#define kImapMsgLabelFlags            0x0E00  /* supports 5 labels only supported if the folder supports keywords */</span>
<a href="#l9.78"></a><span id="l9.78"> #define kImapMsgSupportMDNSentFlag    0x2000</span>
<a href="#l9.79"></a><span id="l9.79"> #define kImapMsgSupportForwardedFlag  0x4000</span>
<a href="#l9.80"></a><span id="l9.80"> /**</span>
<a href="#l9.81"></a><span id="l9.81">  * We use a separate xlist trash flag so we can prefer the GMail trash</span>
<a href="#l9.82"></a><span id="l9.82">  * over an existing Trash folder we may have created.</span>
<a href="#l9.83"></a><span id="l9.83">  */</span>
<a href="#l9.84"></a><span id="l9.84" class="difflineminus">-#define kImapMsgSupportUserFlag       0x8000		</span>
<a href="#l9.85"></a><span id="l9.85" class="difflineplus">+#define kImapMsgSupportUserFlag       0x8000</span>
<a href="#l9.86"></a><span id="l9.86"> /* This seems to be the most cost effective way of</span>
<a href="#l9.87"></a><span id="l9.87"> * piggying back the server support user flag info.</span>
<a href="#l9.88"></a><span id="l9.88"> */</span>
<a href="#l9.89"></a><span id="l9.89"> </span>
<a href="#l9.90"></a><span id="l9.90"> /* if a url creator does not know the hierarchyDelimiter, use this */</span>
<a href="#l9.91"></a><span id="l9.91"> #define kOnlineHierarchySeparatorUnknown '^'</span>
<a href="#l9.92"></a><span id="l9.92"> #define kOnlineHierarchySeparatorNil '|'</span>
<a href="#l9.93"></a><span id="l9.93"> </span>
<a href="#l9.94"></a><span id="l9.94"> #define IMAP_URL_TOKEN_SEPARATOR &quot;&gt;&quot;</span>
<a href="#l9.95"></a><span id="l9.95"> #define kUidUnknown -1</span>
<a href="#l9.96"></a><span id="l9.96"> // Special initial value meaning ACLs need to be loaded from DB.</span>
<a href="#l9.97"></a><span id="l9.97"> #define kAclInvalid ((uint32_t) -1)</span>
<a href="#l9.98"></a><span id="l9.98"> </span>
<a href="#l9.99"></a><span id="l9.99"> // this has to do with Mime Parts on Demand. It used to live in net.h</span>
<a href="#l9.100"></a><span id="l9.100"> // I'm not sure where this will live, but here is OK temporarily</span>
<a href="#l9.101"></a><span id="l9.101"> typedef enum {</span>
<a href="#l9.102"></a><span id="l9.102" class="difflineminus">-	IMAP_CONTENT_NOT_MODIFIED = 0,</span>
<a href="#l9.103"></a><span id="l9.103" class="difflineminus">-	IMAP_CONTENT_MODIFIED_VIEW_INLINE,</span>
<a href="#l9.104"></a><span id="l9.104" class="difflineminus">-	IMAP_CONTENT_MODIFIED_VIEW_AS_LINKS,</span>
<a href="#l9.105"></a><span id="l9.105" class="difflineminus">-	IMAP_CONTENT_FORCE_CONTENT_NOT_MODIFIED</span>
<a href="#l9.106"></a><span id="l9.106" class="difflineplus">+  IMAP_CONTENT_NOT_MODIFIED = 0,</span>
<a href="#l9.107"></a><span id="l9.107" class="difflineplus">+  IMAP_CONTENT_MODIFIED_VIEW_INLINE,</span>
<a href="#l9.108"></a><span id="l9.108" class="difflineplus">+  IMAP_CONTENT_MODIFIED_VIEW_AS_LINKS,</span>
<a href="#l9.109"></a><span id="l9.109" class="difflineplus">+  IMAP_CONTENT_FORCE_CONTENT_NOT_MODIFIED</span>
<a href="#l9.110"></a><span id="l9.110"> } IMAP_ContentModifiedType;</span>
<a href="#l9.111"></a><span id="l9.111"> </span>
<a href="#l9.112"></a><span id="l9.112"> // I think this should really go in an imap.h equivalent file</span>
<a href="#l9.113"></a><span id="l9.113"> typedef enum {</span>
<a href="#l9.114"></a><span id="l9.114">     kPersonalNamespace = 0,</span>
<a href="#l9.115"></a><span id="l9.115">     kOtherUsersNamespace,</span>
<a href="#l9.116"></a><span id="l9.116">     kPublicNamespace,</span>
<a href="#l9.117"></a><span id="l9.117">     kDefaultNamespace,</span>
<a href="#l9.118"></a><span id="l9.118" class="difflineat">@@ -99,54 +99,54 @@ typedef uint64_t eIMAPCapabilityFlag;</span>
<a href="#l9.119"></a><span id="l9.119"> /**</span>
<a href="#l9.120"></a><span id="l9.120">  * IMAP server features, mostly CAPABILITY responses</span>
<a href="#l9.121"></a><span id="l9.121">  *</span>
<a href="#l9.122"></a><span id="l9.122">  * any set of the cap flags below, i.e.</span>
<a href="#l9.123"></a><span id="l9.123">  * i.e. 0, 1 or more |eIMAPCapabilityFlag|.</span>
<a href="#l9.124"></a><span id="l9.124">  */</span>
<a href="#l9.125"></a><span id="l9.125"> typedef uint64_t eIMAPCapabilityFlags;</span>
<a href="#l9.126"></a><span id="l9.126"> </span>
<a href="#l9.127"></a><span id="l9.127" class="difflineminus">-const eIMAPCapabilityFlag kCapabilityUndefined = 0x00000000;</span>
<a href="#l9.128"></a><span id="l9.128" class="difflineminus">-const eIMAPCapabilityFlag kCapabilityDefined = 0x00000001;</span>
<a href="#l9.129"></a><span id="l9.129" class="difflineminus">-const eIMAPCapabilityFlag kHasAuthLoginCapability = 0x00000002;  /* AUTH LOGIN (not the same as kHasAuthOldLoginCapability) */</span>
<a href="#l9.130"></a><span id="l9.130" class="difflineminus">-const eIMAPCapabilityFlag kHasAuthOldLoginCapability = 0x00000004;  /* original IMAP login method */</span>
<a href="#l9.131"></a><span id="l9.131" class="difflineminus">-const eIMAPCapabilityFlag kHasXSenderCapability = 0x00000008;</span>
<a href="#l9.132"></a><span id="l9.132" class="difflineminus">-const eIMAPCapabilityFlag kIMAP4Capability = 0x00000010;           /* RFC1734 */</span>
<a href="#l9.133"></a><span id="l9.133" class="difflineminus">-const eIMAPCapabilityFlag kIMAP4rev1Capability = 0x00000020;       /* RFC2060 */</span>
<a href="#l9.134"></a><span id="l9.134" class="difflineminus">-const eIMAPCapabilityFlag kIMAP4other = 0x00000040;                        /* future rev?? */</span>
<a href="#l9.135"></a><span id="l9.135" class="difflineminus">-const eIMAPCapabilityFlag kNoHierarchyRename = 0x00000080;                         /* no hierarchy rename */</span>
<a href="#l9.136"></a><span id="l9.136" class="difflineminus">-const eIMAPCapabilityFlag kACLCapability = 0x00000100;           /* ACL extension */</span>
<a href="#l9.137"></a><span id="l9.137" class="difflineminus">-const eIMAPCapabilityFlag kNamespaceCapability = 0x00000200;     /* IMAP4 Namespace Extension */</span>
<a href="#l9.138"></a><span id="l9.138" class="difflineminus">-const eIMAPCapabilityFlag kHasIDCapability = 0x00000400;  /* client user agent id extension */</span>
<a href="#l9.139"></a><span id="l9.139" class="difflineminus">-const eIMAPCapabilityFlag kXServerInfoCapability = 0x00000800;  /* XSERVERINFO extension for admin urls */</span>
<a href="#l9.140"></a><span id="l9.140" class="difflineminus">-const eIMAPCapabilityFlag kHasAuthPlainCapability = 0x00001000; /* new form of auth plain base64 login */</span>
<a href="#l9.141"></a><span id="l9.141" class="difflineminus">-const eIMAPCapabilityFlag kUidplusCapability = 0x00002000;   /* RFC 2359 UIDPLUS extension */</span>
<a href="#l9.142"></a><span id="l9.142" class="difflineminus">-const eIMAPCapabilityFlag kLiteralPlusCapability = 0x00004000; /* RFC 2088 LITERAL+ extension */</span>
<a href="#l9.143"></a><span id="l9.143" class="difflineminus">-const eIMAPCapabilityFlag kAOLImapCapability = 0x00008000;     /* aol imap extensions */</span>
<a href="#l9.144"></a><span id="l9.144" class="difflineminus">-const eIMAPCapabilityFlag kHasLanguageCapability = 0x00010000; /* language extensions */</span>
<a href="#l9.145"></a><span id="l9.145" class="difflineminus">-const eIMAPCapabilityFlag kHasCRAMCapability = 0x00020000; /* CRAM auth extension */</span>
<a href="#l9.146"></a><span id="l9.146" class="difflineminus">-const eIMAPCapabilityFlag kQuotaCapability = 0x00040000; /* RFC 2087 quota extension */</span>
<a href="#l9.147"></a><span id="l9.147" class="difflineminus">-const eIMAPCapabilityFlag kHasIdleCapability = 0x00080000;  /* RFC 2177 idle extension */</span>
<a href="#l9.148"></a><span id="l9.148" class="difflineminus">-const eIMAPCapabilityFlag kHasAuthNTLMCapability = 0x00100000;  /* AUTH NTLM extension */</span>
<a href="#l9.149"></a><span id="l9.149" class="difflineminus">-const eIMAPCapabilityFlag kHasAuthMSNCapability = 0x00200000;   /* AUTH MSN extension */</span>
<a href="#l9.150"></a><span id="l9.150" class="difflineminus">-const eIMAPCapabilityFlag kHasStartTLSCapability =0x00400000;   /* STARTTLS support */</span>
<a href="#l9.151"></a><span id="l9.151" class="difflineminus">-const eIMAPCapabilityFlag kHasAuthNoneCapability = 0x00800000; /* needs no login */</span>
<a href="#l9.152"></a><span id="l9.152" class="difflineminus">-const eIMAPCapabilityFlag kHasAuthGssApiCapability = 0x01000000; /* GSSAPI AUTH */</span>
<a href="#l9.153"></a><span id="l9.153" class="difflineminus">-const eIMAPCapabilityFlag kHasCondStoreCapability = 0x02000000; /* RFC 3551 CondStore extension */</span>
<a href="#l9.154"></a><span id="l9.154" class="difflineminus">-const eIMAPCapabilityFlag kHasEnableCapability = 0x04000000; /* RFC 5161 ENABLE extension */</span>
<a href="#l9.155"></a><span id="l9.155" class="difflineminus">-const eIMAPCapabilityFlag kHasXListCapability = 0x08000000;  /* XLIST extension */</span>
<a href="#l9.156"></a><span id="l9.156" class="difflineplus">+const eIMAPCapabilityFlag kCapabilityUndefined =          0x00000000;</span>
<a href="#l9.157"></a><span id="l9.157" class="difflineplus">+const eIMAPCapabilityFlag kCapabilityDefined =            0x00000001;</span>
<a href="#l9.158"></a><span id="l9.158" class="difflineplus">+const eIMAPCapabilityFlag kHasAuthLoginCapability =       0x00000002;  /* AUTH LOGIN (not the same as kHasAuthOldLoginCapability) */</span>
<a href="#l9.159"></a><span id="l9.159" class="difflineplus">+const eIMAPCapabilityFlag kHasAuthOldLoginCapability =    0x00000004;  /* original IMAP login method */</span>
<a href="#l9.160"></a><span id="l9.160" class="difflineplus">+const eIMAPCapabilityFlag kHasXSenderCapability =         0x00000008;</span>
<a href="#l9.161"></a><span id="l9.161" class="difflineplus">+const eIMAPCapabilityFlag kIMAP4Capability =              0x00000010;  /* RFC1734 */</span>
<a href="#l9.162"></a><span id="l9.162" class="difflineplus">+const eIMAPCapabilityFlag kIMAP4rev1Capability =          0x00000020;  /* RFC2060 */</span>
<a href="#l9.163"></a><span id="l9.163" class="difflineplus">+const eIMAPCapabilityFlag kIMAP4other =                   0x00000040;  /* future rev?? */</span>
<a href="#l9.164"></a><span id="l9.164" class="difflineplus">+const eIMAPCapabilityFlag kNoHierarchyRename =            0x00000080;  /* no hierarchy rename */</span>
<a href="#l9.165"></a><span id="l9.165" class="difflineplus">+const eIMAPCapabilityFlag kACLCapability =                0x00000100;  /* ACL extension */</span>
<a href="#l9.166"></a><span id="l9.166" class="difflineplus">+const eIMAPCapabilityFlag kNamespaceCapability =          0x00000200;  /* IMAP4 Namespace Extension */</span>
<a href="#l9.167"></a><span id="l9.167" class="difflineplus">+const eIMAPCapabilityFlag kHasIDCapability =              0x00000400;  /* client user agent id extension */</span>
<a href="#l9.168"></a><span id="l9.168" class="difflineplus">+const eIMAPCapabilityFlag kXServerInfoCapability =        0x00000800;  /* XSERVERINFO extension for admin urls */</span>
<a href="#l9.169"></a><span id="l9.169" class="difflineplus">+const eIMAPCapabilityFlag kHasAuthPlainCapability =       0x00001000;  /* new form of auth plain base64 login */</span>
<a href="#l9.170"></a><span id="l9.170" class="difflineplus">+const eIMAPCapabilityFlag kUidplusCapability =            0x00002000;  /* RFC 2359 UIDPLUS extension */</span>
<a href="#l9.171"></a><span id="l9.171" class="difflineplus">+const eIMAPCapabilityFlag kLiteralPlusCapability =        0x00004000;  /* RFC 2088 LITERAL+ extension */</span>
<a href="#l9.172"></a><span id="l9.172" class="difflineplus">+const eIMAPCapabilityFlag kAOLImapCapability =            0x00008000;  /* aol imap extensions */</span>
<a href="#l9.173"></a><span id="l9.173" class="difflineplus">+const eIMAPCapabilityFlag kHasLanguageCapability =        0x00010000;  /* language extensions */</span>
<a href="#l9.174"></a><span id="l9.174" class="difflineplus">+const eIMAPCapabilityFlag kHasCRAMCapability =            0x00020000;  /* CRAM auth extension */</span>
<a href="#l9.175"></a><span id="l9.175" class="difflineplus">+const eIMAPCapabilityFlag kQuotaCapability =              0x00040000;  /* RFC 2087 quota extension */</span>
<a href="#l9.176"></a><span id="l9.176" class="difflineplus">+const eIMAPCapabilityFlag kHasIdleCapability =            0x00080000;  /* RFC 2177 idle extension */</span>
<a href="#l9.177"></a><span id="l9.177" class="difflineplus">+const eIMAPCapabilityFlag kHasAuthNTLMCapability =        0x00100000;  /* AUTH NTLM extension */</span>
<a href="#l9.178"></a><span id="l9.178" class="difflineplus">+const eIMAPCapabilityFlag kHasAuthMSNCapability =         0x00200000;  /* AUTH MSN extension */</span>
<a href="#l9.179"></a><span id="l9.179" class="difflineplus">+const eIMAPCapabilityFlag kHasStartTLSCapability =        0x00400000;  /* STARTTLS support */</span>
<a href="#l9.180"></a><span id="l9.180" class="difflineplus">+const eIMAPCapabilityFlag kHasAuthNoneCapability =        0x00800000;  /* needs no login */</span>
<a href="#l9.181"></a><span id="l9.181" class="difflineplus">+const eIMAPCapabilityFlag kHasAuthGssApiCapability =      0x01000000;  /* GSSAPI AUTH */</span>
<a href="#l9.182"></a><span id="l9.182" class="difflineplus">+const eIMAPCapabilityFlag kHasCondStoreCapability =       0x02000000;  /* RFC 3551 CondStore extension */</span>
<a href="#l9.183"></a><span id="l9.183" class="difflineplus">+const eIMAPCapabilityFlag kHasEnableCapability =          0x04000000;  /* RFC 5161 ENABLE extension */</span>
<a href="#l9.184"></a><span id="l9.184" class="difflineplus">+const eIMAPCapabilityFlag kHasXListCapability =           0x08000000;  /* XLIST extension */</span>
<a href="#l9.185"></a><span id="l9.185"> const eIMAPCapabilityFlag kHasCompressDeflateCapability = 0x10000000;  /* RFC 4978 COMPRESS extension */</span>
<a href="#l9.186"></a><span id="l9.186" class="difflineminus">-const eIMAPCapabilityFlag kHasAuthExternalCapability = 0x20000000;  /* RFC 2222 SASL AUTH EXTERNAL */</span>
<a href="#l9.187"></a><span id="l9.187" class="difflineminus">-const eIMAPCapabilityFlag kHasMoveCapability = 0x40000000;  /* Proposed MOVE RFC */</span>
<a href="#l9.188"></a><span id="l9.188" class="difflineminus">-const eIMAPCapabilityFlag kHasHighestModSeqCapability = 0x80000000;  /* Subset of RFC 3551 */</span>
<a href="#l9.189"></a><span id="l9.189" class="difflineplus">+const eIMAPCapabilityFlag kHasAuthExternalCapability =    0x20000000;  /* RFC 2222 SASL AUTH EXTERNAL */</span>
<a href="#l9.190"></a><span id="l9.190" class="difflineplus">+const eIMAPCapabilityFlag kHasMoveCapability =            0x40000000;  /* Proposed MOVE RFC */</span>
<a href="#l9.191"></a><span id="l9.191" class="difflineplus">+const eIMAPCapabilityFlag kHasHighestModSeqCapability =   0x80000000;  /* Subset of RFC 3551 */</span>
<a href="#l9.192"></a><span id="l9.192"> // above are 32bit; below start the uint64_t bits 33-64</span>
<a href="#l9.193"></a><span id="l9.193" class="difflineminus">-const eIMAPCapabilityFlag kHasListExtendedCapability = 0x100000000LL;  /* RFC 5258 */</span>
<a href="#l9.194"></a><span id="l9.194" class="difflineminus">-const eIMAPCapabilityFlag kHasSpecialUseCapability = 0x200000000LL;  /* RFC 6154: Sent, Draft etc. folders */</span>
<a href="#l9.195"></a><span id="l9.195" class="difflineminus">-const eIMAPCapabilityFlag kGmailImapCapability = 0x400000000LL;  /* X-GM-EXT-1 capability extension for gmail */</span>
<a href="#l9.196"></a><span id="l9.196" class="difflineminus">-const eIMAPCapabilityFlag kHasXOAuth2Capability = 0x800000000LL;  /* AUTH XOAUTH2 extension */</span>
<a href="#l9.197"></a><span id="l9.197" class="difflineplus">+const eIMAPCapabilityFlag kHasListExtendedCapability =    0x100000000LL;  /* RFC 5258 */</span>
<a href="#l9.198"></a><span id="l9.198" class="difflineplus">+const eIMAPCapabilityFlag kHasSpecialUseCapability =      0x200000000LL;  /* RFC 6154: Sent, Draft etc. folders */</span>
<a href="#l9.199"></a><span id="l9.199" class="difflineplus">+const eIMAPCapabilityFlag kGmailImapCapability =          0x400000000LL;  /* X-GM-EXT-1 capability extension for gmail */</span>
<a href="#l9.200"></a><span id="l9.200" class="difflineplus">+const eIMAPCapabilityFlag kHasXOAuth2Capability =         0x800000000LL;  /* AUTH XOAUTH2 extension */</span>
<a href="#l9.201"></a><span id="l9.201"> </span>
<a href="#l9.202"></a><span id="l9.202"> </span>
<a href="#l9.203"></a><span id="l9.203"> // this used to be part of the connection object class - maybe we should move it into</span>
<a href="#l9.204"></a><span id="l9.204"> // something similar</span>
<a href="#l9.205"></a><span id="l9.205"> typedef enum {</span>
<a href="#l9.206"></a><span id="l9.206">     kEveryThingRFC822,</span>
<a href="#l9.207"></a><span id="l9.207">     kEveryThingRFC822Peek,</span>
<a href="#l9.208"></a><span id="l9.208">     kHeadersRFC822andUid,</span>
<a href="#l9.209"></a><span id="l9.209" class="difflineat">@@ -155,28 +155,28 @@ typedef enum {</span>
<a href="#l9.210"></a><span id="l9.210">     kRFC822Size,</span>
<a href="#l9.211"></a><span id="l9.211">     kRFC822HeadersOnly,</span>
<a href="#l9.212"></a><span id="l9.212">     kMIMEPart,</span>
<a href="#l9.213"></a><span id="l9.213">     kMIMEHeader,</span>
<a href="#l9.214"></a><span id="l9.214">     kBodyStart</span>
<a href="#l9.215"></a><span id="l9.215"> } nsIMAPeFetchFields;</span>
<a href="#l9.216"></a><span id="l9.216"> </span>
<a href="#l9.217"></a><span id="l9.217"> typedef struct _utf_name_struct {</span>
<a href="#l9.218"></a><span id="l9.218" class="difflineminus">-	bool toUtf7Imap;</span>
<a href="#l9.219"></a><span id="l9.219" class="difflineminus">-	unsigned char *sourceString;</span>
<a href="#l9.220"></a><span id="l9.220" class="difflineminus">-	unsigned char *convertedString;</span>
<a href="#l9.221"></a><span id="l9.221" class="difflineplus">+  bool toUtf7Imap;</span>
<a href="#l9.222"></a><span id="l9.222" class="difflineplus">+  unsigned char *sourceString;</span>
<a href="#l9.223"></a><span id="l9.223" class="difflineplus">+  unsigned char *convertedString;</span>
<a href="#l9.224"></a><span id="l9.224"> } utf_name_struct;</span>
<a href="#l9.225"></a><span id="l9.225"> </span>
<a href="#l9.226"></a><span id="l9.226"> typedef struct _ProgressInfo {</span>
<a href="#l9.227"></a><span id="l9.227">   char16_t *message;</span>
<a href="#l9.228"></a><span id="l9.228">   int32_t currentProgress;</span>
<a href="#l9.229"></a><span id="l9.229">   int32_t maxProgress;</span>
<a href="#l9.230"></a><span id="l9.230"> } ProgressInfo;</span>
<a href="#l9.231"></a><span id="l9.231"> </span>
<a href="#l9.232"></a><span id="l9.232"> typedef enum {</span>
<a href="#l9.233"></a><span id="l9.233" class="difflineminus">-    eContinue,</span>
<a href="#l9.234"></a><span id="l9.234" class="difflineminus">-    eContinueNew,</span>
<a href="#l9.235"></a><span id="l9.235" class="difflineminus">-    eListMyChildren,</span>
<a href="#l9.236"></a><span id="l9.236" class="difflineminus">-    eNewServerDirectory,</span>
<a href="#l9.237"></a><span id="l9.237" class="difflineminus">-    eCancelled</span>
<a href="#l9.238"></a><span id="l9.238" class="difflineplus">+  eContinue,</span>
<a href="#l9.239"></a><span id="l9.239" class="difflineplus">+  eContinueNew,</span>
<a href="#l9.240"></a><span id="l9.240" class="difflineplus">+  eListMyChildren,</span>
<a href="#l9.241"></a><span id="l9.241" class="difflineplus">+  eNewServerDirectory,</span>
<a href="#l9.242"></a><span id="l9.242" class="difflineplus">+  eCancelled</span>
<a href="#l9.243"></a><span id="l9.243"> } EMailboxDiscoverStatus;</span>
<a href="#l9.244"></a><span id="l9.244"> </span>
<a href="#l9.245"></a><span id="l9.245"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/imap/src/nsImapFlagAndUidState.cpp</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapFlagAndUidState.cpp</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -178,17 +178,17 @@ NS_IMETHODIMP nsImapFlagAndUidState::Get</span>
<a href="#l10.4"></a><span id="l10.4">   *numDeletedMessages = NumberOfDeletedMessages();</span>
<a href="#l10.5"></a><span id="l10.5">   return NS_OK;</span>
<a href="#l10.6"></a><span id="l10.6"> }</span>
<a href="#l10.7"></a><span id="l10.7"> </span>
<a href="#l10.8"></a><span id="l10.8"> int32_t nsImapFlagAndUidState::NumberOfDeletedMessages()</span>
<a href="#l10.9"></a><span id="l10.9"> {</span>
<a href="#l10.10"></a><span id="l10.10">   return fNumberDeleted;</span>
<a href="#l10.11"></a><span id="l10.11"> }</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-	</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+</span>
<a href="#l10.14"></a><span id="l10.14"> // since the uids are sorted, start from the back (rb)</span>
<a href="#l10.15"></a><span id="l10.15"> </span>
<a href="#l10.16"></a><span id="l10.16"> uint32_t  nsImapFlagAndUidState::GetHighestNonDeletedUID()</span>
<a href="#l10.17"></a><span id="l10.17"> {</span>
<a href="#l10.18"></a><span id="l10.18">   uint32_t msgIndex = fUids.Length();</span>
<a href="#l10.19"></a><span id="l10.19">   do</span>
<a href="#l10.20"></a><span id="l10.20">   {</span>
<a href="#l10.21"></a><span id="l10.21">     if (msgIndex &lt;= 0)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/imap/src/nsImapIncomingServer.cpp</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapIncomingServer.cpp</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -1135,17 +1135,17 @@ NS_IMETHODIMP nsImapIncomingServer::Poss</span>
<a href="#l11.4"></a><span id="l11.4">   nsAutoCString parentName(folderName);</span>
<a href="#l11.5"></a><span id="l11.5">   nsAutoCString parentUri(uri);</span>
<a href="#l11.6"></a><span id="l11.6"> </span>
<a href="#l11.7"></a><span id="l11.7">   if (leafPos &gt; 0)</span>
<a href="#l11.8"></a><span id="l11.8">   {</span>
<a href="#l11.9"></a><span id="l11.9">     // If there is a hierarchy, there is a parent.</span>
<a href="#l11.10"></a><span id="l11.10">     // Don't strip off slash if it's the first character</span>
<a href="#l11.11"></a><span id="l11.11">     parentName.SetLength(leafPos);</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-    folderName.Cut(0, leafPos + 1);	// get rid of the parent name</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+    folderName.Cut(0, leafPos + 1);  // get rid of the parent name</span>
<a href="#l11.14"></a><span id="l11.14">     haveParent = true;</span>
<a href="#l11.15"></a><span id="l11.15">     parentUri.Append('/');</span>
<a href="#l11.16"></a><span id="l11.16">     parentUri.Append(parentName);</span>
<a href="#l11.17"></a><span id="l11.17">   }</span>
<a href="#l11.18"></a><span id="l11.18">   if (MsgLowerCaseEqualsLiteral(folderPath, &quot;inbox&quot;) &amp;&amp;</span>
<a href="#l11.19"></a><span id="l11.19">     hierarchyDelimiter == kOnlineHierarchySeparatorNil)</span>
<a href="#l11.20"></a><span id="l11.20">   {</span>
<a href="#l11.21"></a><span id="l11.21">     hierarchyDelimiter = '/'; // set to default in this case (as in 4.x)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/mailnews/imap/src/nsImapIncomingServer.h</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapIncomingServer.h</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -24,51 +24,47 @@ class nsIRDFService;</span>
<a href="#l12.4"></a><span id="l12.4"> /* get some implementation from nsMsgIncomingServer */</span>
<a href="#l12.5"></a><span id="l12.5"> class nsImapIncomingServer : public nsMsgIncomingServer,</span>
<a href="#l12.6"></a><span id="l12.6">                              public nsIImapIncomingServer,</span>
<a href="#l12.7"></a><span id="l12.7">                              public nsIImapServerSink,</span>
<a href="#l12.8"></a><span id="l12.8">                              public nsISubscribableServer,</span>
<a href="#l12.9"></a><span id="l12.9">                              public nsIUrlListener</span>
<a href="#l12.10"></a><span id="l12.10"> {</span>
<a href="#l12.11"></a><span id="l12.11"> public:</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-    NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineplus">+  NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l12.14"></a><span id="l12.14"> </span>
<a href="#l12.15"></a><span id="l12.15" class="difflineminus">-    nsImapIncomingServer();</span>
<a href="#l12.16"></a><span id="l12.16" class="difflineplus">+  nsImapIncomingServer();</span>
<a href="#l12.17"></a><span id="l12.17"> </span>
<a href="#l12.18"></a><span id="l12.18" class="difflineminus">-    // overriding nsMsgIncomingServer methods</span>
<a href="#l12.19"></a><span id="l12.19" class="difflineplus">+  // overriding nsMsgIncomingServer methods</span>
<a href="#l12.20"></a><span id="l12.20">   NS_IMETHOD SetKey(const nsACString&amp; aKey) override;  // override nsMsgIncomingServer's implementation...</span>
<a href="#l12.21"></a><span id="l12.21">   NS_IMETHOD GetLocalStoreType(nsACString&amp; type) override;</span>
<a href="#l12.22"></a><span id="l12.22">   NS_IMETHOD GetLocalDatabaseType(nsACString&amp; type) override;</span>
<a href="#l12.23"></a><span id="l12.23"> </span>
<a href="#l12.24"></a><span id="l12.24">   NS_DECL_NSIIMAPINCOMINGSERVER</span>
<a href="#l12.25"></a><span id="l12.25">   NS_DECL_NSIIMAPSERVERSINK</span>
<a href="#l12.26"></a><span id="l12.26">   NS_DECL_NSISUBSCRIBABLESERVER</span>
<a href="#l12.27"></a><span id="l12.27">   NS_DECL_NSIURLLISTENER</span>
<a href="#l12.28"></a><span id="l12.28"> </span>
<a href="#l12.29"></a><span id="l12.29">   NS_IMETHOD PerformBiff(nsIMsgWindow *aMsgWindow) override;</span>
<a href="#l12.30"></a><span id="l12.30">   NS_IMETHOD PerformExpand(nsIMsgWindow *aMsgWindow) override;</span>
<a href="#l12.31"></a><span id="l12.31">   NS_IMETHOD CloseCachedConnections() override;</span>
<a href="#l12.32"></a><span id="l12.32">   NS_IMETHOD GetConstructedPrettyName(nsAString&amp; retval) override;</span>
<a href="#l12.33"></a><span id="l12.33">   NS_IMETHOD GetCanBeDefaultServer(bool *canBeDefaultServer) override;</span>
<a href="#l12.34"></a><span id="l12.34" class="difflineminus">-  NS_IMETHOD GetCanCompactFoldersOnServer(bool *canCompactFoldersOnServer</span>
<a href="#l12.35"></a><span id="l12.35" class="difflineminus">-                                          ) override;</span>
<a href="#l12.36"></a><span id="l12.36" class="difflineplus">+  NS_IMETHOD GetCanCompactFoldersOnServer(bool *canCompactFoldersOnServer) override;</span>
<a href="#l12.37"></a><span id="l12.37">   NS_IMETHOD GetCanUndoDeleteOnServer(bool *canUndoDeleteOnServer) override;</span>
<a href="#l12.38"></a><span id="l12.38">   NS_IMETHOD GetCanSearchMessages(bool *canSearchMessages) override;</span>
<a href="#l12.39"></a><span id="l12.39">   NS_IMETHOD GetCanEmptyTrashOnExit(bool *canEmptyTrashOnExit) override;</span>
<a href="#l12.40"></a><span id="l12.40">   NS_IMETHOD GetOfflineSupportLevel(int32_t *aSupportLevel) override;</span>
<a href="#l12.41"></a><span id="l12.41">   NS_IMETHOD GeneratePrettyNameForMigration(nsAString&amp; aPrettyName) override;</span>
<a href="#l12.42"></a><span id="l12.42">   NS_IMETHOD GetSupportsDiskSpace(bool *aSupportsDiskSpace) override;</span>
<a href="#l12.43"></a><span id="l12.43" class="difflineminus">-  NS_IMETHOD GetCanCreateFoldersOnServer(bool *aCanCreateFoldersOnServer</span>
<a href="#l12.44"></a><span id="l12.44" class="difflineminus">-                                         ) override;</span>
<a href="#l12.45"></a><span id="l12.45" class="difflineminus">-  NS_IMETHOD GetCanFileMessagesOnServer(bool *aCanFileMessagesOnServer</span>
<a href="#l12.46"></a><span id="l12.46" class="difflineminus">-                                        ) override;</span>
<a href="#l12.47"></a><span id="l12.47" class="difflineplus">+  NS_IMETHOD GetCanCreateFoldersOnServer(bool *aCanCreateFoldersOnServer) override;</span>
<a href="#l12.48"></a><span id="l12.48" class="difflineplus">+  NS_IMETHOD GetCanFileMessagesOnServer(bool *aCanFileMessagesOnServer) override;</span>
<a href="#l12.49"></a><span id="l12.49">   NS_IMETHOD GetFilterScope(nsMsgSearchScopeValue *filterScope) override;</span>
<a href="#l12.50"></a><span id="l12.50">   NS_IMETHOD GetSearchScope(nsMsgSearchScopeValue *searchScope) override;</span>
<a href="#l12.51"></a><span id="l12.51" class="difflineminus">-  NS_IMETHOD GetServerRequiresPasswordForBiff(bool *aServerRequiresPasswordForBiff</span>
<a href="#l12.52"></a><span id="l12.52" class="difflineminus">-                                              ) override;</span>
<a href="#l12.53"></a><span id="l12.53" class="difflineplus">+  NS_IMETHOD GetServerRequiresPasswordForBiff(bool *aServerRequiresPasswordForBiff) override;</span>
<a href="#l12.54"></a><span id="l12.54">   NS_IMETHOD OnUserOrHostNameChanged(const nsACString&amp; oldName,</span>
<a href="#l12.55"></a><span id="l12.55">                                      const nsACString&amp; newName,</span>
<a href="#l12.56"></a><span id="l12.56">                                      bool hostnameChanged) override;</span>
<a href="#l12.57"></a><span id="l12.57">   NS_IMETHOD GetNumIdleConnections(int32_t *aNumIdleConnections);</span>
<a href="#l12.58"></a><span id="l12.58">   NS_IMETHOD ForgetSessionPassword() override;</span>
<a href="#l12.59"></a><span id="l12.59">   NS_IMETHOD GetMsgFolderFromURI(nsIMsgFolder *aFolderResource,</span>
<a href="#l12.60"></a><span id="l12.60">                                  const nsACString&amp; aURI,</span>
<a href="#l12.61"></a><span id="l12.61">                                  nsIMsgFolder **aFolder) override;</span>
<a href="#l12.62"></a><span id="l12.62" class="difflineat">@@ -103,26 +99,26 @@ private:</span>
<a href="#l12.63"></a><span id="l12.63">   bool ConnectionTimeOut(nsIImapProtocol* aImapConnection);</span>
<a href="#l12.64"></a><span id="l12.64">   nsresult GetFormattedStringFromName(const nsAString&amp; aValue, const char* aName, nsAString&amp; aResult);</span>
<a href="#l12.65"></a><span id="l12.65">   nsresult GetPrefForServerAttribute(const char *prefSuffix, bool *prefValue);</span>
<a href="#l12.66"></a><span id="l12.66">   bool CheckSpecialFolder(nsIRDFService *rdf, nsCString &amp;folderUri,</span>
<a href="#l12.67"></a><span id="l12.67">                             uint32_t folderFlag, nsCString &amp;existingUri);</span>
<a href="#l12.68"></a><span id="l12.68"> </span>
<a href="#l12.69"></a><span id="l12.69">   nsCOMArray&lt;nsIImapProtocol&gt; m_connectionCache;</span>
<a href="#l12.70"></a><span id="l12.70">   nsCOMArray&lt;nsIImapUrl&gt; m_urlQueue;</span>
<a href="#l12.71"></a><span id="l12.71" class="difflineminus">-  nsCOMPtr&lt;nsIStringBundle&gt;	m_stringBundle;</span>
<a href="#l12.72"></a><span id="l12.72" class="difflineplus">+  nsCOMPtr&lt;nsIStringBundle&gt;m_stringBundle;</span>
<a href="#l12.73"></a><span id="l12.73">   nsCOMArray&lt;nsIMsgFolder&gt; m_subscribeFolders; // used to keep folder resources around while subscribe UI is up.</span>
<a href="#l12.74"></a><span id="l12.74">   nsCOMArray&lt;nsIMsgImapMailFolder&gt; m_foldersToStat; // folders to check for new mail with Status</span>
<a href="#l12.75"></a><span id="l12.75">   nsTArray&lt;nsISupports*&gt; m_urlConsumers;</span>
<a href="#l12.76"></a><span id="l12.76" class="difflineminus">-  eIMAPCapabilityFlags          m_capability;</span>
<a href="#l12.77"></a><span id="l12.77" class="difflineminus">-  nsCString         m_manageMailAccountUrl;</span>
<a href="#l12.78"></a><span id="l12.78" class="difflineminus">-  bool              m_userAuthenticated;</span>
<a href="#l12.79"></a><span id="l12.79" class="difflineminus">-  bool              mDoingSubscribeDialog;</span>
<a href="#l12.80"></a><span id="l12.80" class="difflineminus">-  bool              mDoingLsub;</span>
<a href="#l12.81"></a><span id="l12.81" class="difflineminus">-  bool              m_shuttingDown;</span>
<a href="#l12.82"></a><span id="l12.82" class="difflineplus">+  eIMAPCapabilityFlags m_capability;</span>
<a href="#l12.83"></a><span id="l12.83" class="difflineplus">+  nsCString m_manageMailAccountUrl;</span>
<a href="#l12.84"></a><span id="l12.84" class="difflineplus">+  bool m_userAuthenticated;</span>
<a href="#l12.85"></a><span id="l12.85" class="difflineplus">+  bool mDoingSubscribeDialog;</span>
<a href="#l12.86"></a><span id="l12.86" class="difflineplus">+  bool mDoingLsub;</span>
<a href="#l12.87"></a><span id="l12.87" class="difflineplus">+  bool m_shuttingDown;</span>
<a href="#l12.88"></a><span id="l12.88"> </span>
<a href="#l12.89"></a><span id="l12.89">   mozilla::Mutex mLock;</span>
<a href="#l12.90"></a><span id="l12.90">   // subscribe dialog stuff</span>
<a href="#l12.91"></a><span id="l12.91">   nsresult AddFolderToSubscribeDialog(const char *parentUri, const char *uri,const char *folderName);</span>
<a href="#l12.92"></a><span id="l12.92">   nsCOMPtr &lt;nsISubscribableServer&gt; mInner;</span>
<a href="#l12.93"></a><span id="l12.93">   nsresult EnsureInner();</span>
<a href="#l12.94"></a><span id="l12.94">   nsresult ClearInner();</span>
<a href="#l12.95"></a><span id="l12.95"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/mailnews/imap/src/nsImapOfflineSync.cpp</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapOfflineSync.cpp</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -520,17 +520,17 @@ void nsImapOfflineSync::ProcessMoveOpera</span>
<a href="#l13.4"></a><span id="l13.4"> {</span>
<a href="#l13.5"></a><span id="l13.5">   nsTArray&lt;nsMsgKey&gt; matchingFlagKeys;</span>
<a href="#l13.6"></a><span id="l13.6">   uint32_t currentKeyIndex = m_KeyIndex;</span>
<a href="#l13.7"></a><span id="l13.7">   nsCString moveDestination;</span>
<a href="#l13.8"></a><span id="l13.8">   op-&gt;GetDestinationFolderURI(getter_Copies(moveDestination));</span>
<a href="#l13.9"></a><span id="l13.9">   bool moveMatches = true;</span>
<a href="#l13.10"></a><span id="l13.10">   nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; currentOp = op;</span>
<a href="#l13.11"></a><span id="l13.11">   do</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">-  {	// loop for all messages with the same destination</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+  {  // loop for all messages with the same destination</span>
<a href="#l13.14"></a><span id="l13.14">     if (moveMatches)</span>
<a href="#l13.15"></a><span id="l13.15">     {</span>
<a href="#l13.16"></a><span id="l13.16">       nsMsgKey curKey;</span>
<a href="#l13.17"></a><span id="l13.17">       currentOp-&gt;GetMessageKey(&amp;curKey);</span>
<a href="#l13.18"></a><span id="l13.18">       matchingFlagKeys.AppendElement(curKey);</span>
<a href="#l13.19"></a><span id="l13.19">       currentOp-&gt;SetPlayingBack(true);</span>
<a href="#l13.20"></a><span id="l13.20">       m_currentOpsToClear.AppendObject(currentOp);</span>
<a href="#l13.21"></a><span id="l13.21">     }</span>
<a href="#l13.22"></a><span id="l13.22" class="difflineat">@@ -743,17 +743,17 @@ bool nsImapOfflineSync::CreateOfflineFol</span>
<a href="#l13.23"></a><span id="l13.23">   NS_ConvertASCIItoUTF16 folderName(onlineName);</span>
<a href="#l13.24"></a><span id="l13.24">   nsresult rv = imapFolder-&gt;PlaybackOfflineFolderCreate(folderName, nullptr,  getter_AddRefs(createFolderURI));</span>
<a href="#l13.25"></a><span id="l13.25">   if (createFolderURI &amp;&amp; NS_SUCCEEDED(rv))</span>
<a href="#l13.26"></a><span id="l13.26">   {</span>
<a href="#l13.27"></a><span id="l13.27">     nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(createFolderURI);</span>
<a href="#l13.28"></a><span id="l13.28">     if (mailnewsUrl)</span>
<a href="#l13.29"></a><span id="l13.29">       mailnewsUrl-&gt;RegisterListener(this);</span>
<a href="#l13.30"></a><span id="l13.30">   }</span>
<a href="#l13.31"></a><span id="l13.31" class="difflineminus">-  return NS_SUCCEEDED(rv) ? true : false;	// this is asynch, we have to return and be called again by the OfflineOpExitFunction</span>
<a href="#l13.32"></a><span id="l13.32" class="difflineplus">+  return NS_SUCCEEDED(rv) ? true : false;  // this is asynch, we have to return and be called again by the OfflineOpExitFunction</span>
<a href="#l13.33"></a><span id="l13.33"> }</span>
<a href="#l13.34"></a><span id="l13.34"> </span>
<a href="#l13.35"></a><span id="l13.35"> int32_t nsImapOfflineSync::GetCurrentUIDValidity()</span>
<a href="#l13.36"></a><span id="l13.36"> {</span>
<a href="#l13.37"></a><span id="l13.37">   if (m_currentFolder)</span>
<a href="#l13.38"></a><span id="l13.38">   {</span>
<a href="#l13.39"></a><span id="l13.39">     nsCOMPtr &lt;nsIImapMailFolderSink&gt; imapFolderSink = do_QueryInterface(m_currentFolder);</span>
<a href="#l13.40"></a><span id="l13.40">     if (imapFolderSink)</span>
<a href="#l13.41"></a><span id="l13.41" class="difflineat">@@ -893,17 +893,17 @@ nsresult nsImapOfflineSync::ProcessNextO</span>
<a href="#l13.42"></a><span id="l13.42">     }</span>
<a href="#l13.43"></a><span id="l13.43"> </span>
<a href="#l13.44"></a><span id="l13.44">     if (!m_currentDB)</span>
<a href="#l13.45"></a><span id="l13.45">     {</span>
<a href="#l13.46"></a><span id="l13.46">       // only advance if we are doing all folders</span>
<a href="#l13.47"></a><span id="l13.47">       if (!m_singleFolderToUpdate)</span>
<a href="#l13.48"></a><span id="l13.48">         AdvanceToNextFolder();</span>
<a href="#l13.49"></a><span id="l13.49">       else</span>
<a href="#l13.50"></a><span id="l13.50" class="difflineminus">-        m_currentFolder = nullptr;	// force update of this folder now.</span>
<a href="#l13.51"></a><span id="l13.51" class="difflineplus">+        m_currentFolder = nullptr;  // force update of this folder now.</span>
<a href="#l13.52"></a><span id="l13.52">     }</span>
<a href="#l13.53"></a><span id="l13.53"> </span>
<a href="#l13.54"></a><span id="l13.54">   }</span>
<a href="#l13.55"></a><span id="l13.55"> </span>
<a href="#l13.56"></a><span id="l13.56">   if (m_currentFolder)</span>
<a href="#l13.57"></a><span id="l13.57">     m_currentFolder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l13.58"></a><span id="l13.58">   // do the current operation</span>
<a href="#l13.59"></a><span id="l13.59">   if (m_currentDB)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/mailnews/imap/src/nsImapOfflineSync.h</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapOfflineSync.h</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -53,36 +53,36 @@ protected:</span>
<a href="#l14.4"></a><span id="l14.4">   void      ProcessFlagOperation(nsIMsgOfflineImapOperation *currentOp);</span>
<a href="#l14.5"></a><span id="l14.5">   void      ProcessKeywordOperation(nsIMsgOfflineImapOperation *op);</span>
<a href="#l14.6"></a><span id="l14.6">   void      ProcessMoveOperation(nsIMsgOfflineImapOperation *currentOp);</span>
<a href="#l14.7"></a><span id="l14.7">   void      ProcessCopyOperation(nsIMsgOfflineImapOperation *currentOp);</span>
<a href="#l14.8"></a><span id="l14.8">   void      ProcessEmptyTrash();</span>
<a href="#l14.9"></a><span id="l14.9">   void      ProcessAppendMsgOperation(nsIMsgOfflineImapOperation *currentOp,</span>
<a href="#l14.10"></a><span id="l14.10">                                       nsOfflineImapOperationType opType);</span>
<a href="#l14.11"></a><span id="l14.11"> </span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; m_currentFolder;</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; m_singleFolderToUpdate;</span>
<a href="#l14.14"></a><span id="l14.14" class="difflineminus">-  nsCOMPtr &lt;nsIMsgWindow&gt; m_window;</span>
<a href="#l14.15"></a><span id="l14.15" class="difflineminus">-  nsCOMPtr &lt;nsIArray&gt; m_allServers;</span>
<a href="#l14.16"></a><span id="l14.16" class="difflineminus">-  nsCOMPtr &lt;nsIArray&gt; m_allFolders;</span>
<a href="#l14.17"></a><span id="l14.17" class="difflineminus">-  nsCOMPtr &lt;nsIMsgIncomingServer&gt; m_currentServer;</span>
<a href="#l14.18"></a><span id="l14.18" class="difflineminus">-  nsCOMPtr &lt;nsISimpleEnumerator&gt; m_serverEnumerator;</span>
<a href="#l14.19"></a><span id="l14.19" class="difflineminus">-  nsCOMPtr &lt;nsIFile&gt; m_curTempFile;</span>
<a href="#l14.20"></a><span id="l14.20" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; m_currentFolder;</span>
<a href="#l14.21"></a><span id="l14.21" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; m_singleFolderToUpdate;</span>
<a href="#l14.22"></a><span id="l14.22" class="difflineplus">+  nsCOMPtr&lt;nsIMsgWindow&gt; m_window;</span>
<a href="#l14.23"></a><span id="l14.23" class="difflineplus">+  nsCOMPtr&lt;nsIArray&gt; m_allServers;</span>
<a href="#l14.24"></a><span id="l14.24" class="difflineplus">+  nsCOMPtr&lt;nsIArray&gt; m_allFolders;</span>
<a href="#l14.25"></a><span id="l14.25" class="difflineplus">+  nsCOMPtr&lt;nsIMsgIncomingServer&gt; m_currentServer;</span>
<a href="#l14.26"></a><span id="l14.26" class="difflineplus">+  nsCOMPtr&lt;nsISimpleEnumerator&gt; m_serverEnumerator;</span>
<a href="#l14.27"></a><span id="l14.27" class="difflineplus">+  nsCOMPtr&lt;nsIFile&gt; m_curTempFile;</span>
<a href="#l14.28"></a><span id="l14.28"> </span>
<a href="#l14.29"></a><span id="l14.29">   nsTArray&lt;nsMsgKey&gt; m_CurrentKeys;</span>
<a href="#l14.30"></a><span id="l14.30">   nsCOMArray&lt;nsIMsgOfflineImapOperation&gt; m_currentOpsToClear;</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineminus">-  uint32_t      m_KeyIndex;</span>
<a href="#l14.32"></a><span id="l14.32" class="difflineplus">+  uint32_t m_KeyIndex;</span>
<a href="#l14.33"></a><span id="l14.33">   nsCOMPtr &lt;nsIMsgDatabase&gt; m_currentDB;</span>
<a href="#l14.34"></a><span id="l14.34">   nsCOMPtr &lt;nsIUrlListener&gt; m_listener;</span>
<a href="#l14.35"></a><span id="l14.35" class="difflineminus">-  int32_t	mCurrentUIDValidity;</span>
<a href="#l14.36"></a><span id="l14.36" class="difflineminus">-  int32_t	mCurrentPlaybackOpType;	// kFlagsChanged -&gt; kMsgCopy -&gt; kMsgMoved</span>
<a href="#l14.37"></a><span id="l14.37" class="difflineminus">-  bool	m_mailboxupdatesStarted;</span>
<a href="#l14.38"></a><span id="l14.38" class="difflineminus">-  bool          m_mailboxupdatesFinished;</span>
<a href="#l14.39"></a><span id="l14.39" class="difflineminus">-  bool	m_pseudoOffline;		// for queueing online events in offline db</span>
<a href="#l14.40"></a><span id="l14.40" class="difflineminus">-  bool	m_createdOfflineFolders;</span>
<a href="#l14.41"></a><span id="l14.41" class="difflineplus">+  int32_t mCurrentUIDValidity;</span>
<a href="#l14.42"></a><span id="l14.42" class="difflineplus">+  int32_t mCurrentPlaybackOpType;  // kFlagsChanged -&gt; kMsgCopy -&gt; kMsgMoved</span>
<a href="#l14.43"></a><span id="l14.43" class="difflineplus">+  bool m_mailboxupdatesStarted;</span>
<a href="#l14.44"></a><span id="l14.44" class="difflineplus">+  bool m_mailboxupdatesFinished;</span>
<a href="#l14.45"></a><span id="l14.45" class="difflineplus">+  bool m_pseudoOffline;  // for queueing online events in offline db</span>
<a href="#l14.46"></a><span id="l14.46" class="difflineplus">+  bool m_createdOfflineFolders;</span>
<a href="#l14.47"></a><span id="l14.47"> </span>
<a href="#l14.48"></a><span id="l14.48"> };</span>
<a href="#l14.49"></a><span id="l14.49"> </span>
<a href="#l14.50"></a><span id="l14.50"> class nsImapOfflineDownloader : public nsImapOfflineSync</span>
<a href="#l14.51"></a><span id="l14.51"> {</span>
<a href="#l14.52"></a><span id="l14.52"> public:</span>
<a href="#l14.53"></a><span id="l14.53">   nsImapOfflineDownloader(nsIMsgWindow *window, nsIUrlListener *listener);</span>
<a href="#l14.54"></a><span id="l14.54">   virtual ~nsImapOfflineDownloader();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -2922,17 +2922,17 @@ void nsImapProtocol::ProcessSelectedStat</span>
<a href="#l15.4"></a><span id="l15.4">               }</span>
<a href="#l15.5"></a><span id="l15.5"> </span>
<a href="#l15.6"></a><span id="l15.6">               if (m_imapMessageSink)</span>
<a href="#l15.7"></a><span id="l15.7">                 m_imapMessageSink-&gt;NotifyMessageDeleted(canonicalName.get(), true, nullptr);</span>
<a href="#l15.8"></a><span id="l15.8">             }</span>
<a href="#l15.9"></a><span id="l15.9"> </span>
<a href="#l15.10"></a><span id="l15.10">           }</span>
<a href="#l15.11"></a><span id="l15.11">           bool deleteSelf = false;</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineminus">-          DeleteSubFolders(mailboxName.get(), deleteSelf);	// don't delete self</span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+          DeleteSubFolders(mailboxName.get(), deleteSelf);  // don't delete self</span>
<a href="#l15.14"></a><span id="l15.14">         }</span>
<a href="#l15.15"></a><span id="l15.15">         break;</span>
<a href="#l15.16"></a><span id="l15.16">       case nsIImapUrl::nsImapAppendDraftFromFile:</span>
<a href="#l15.17"></a><span id="l15.17">         {</span>
<a href="#l15.18"></a><span id="l15.18">           OnAppendMsgFromFile();</span>
<a href="#l15.19"></a><span id="l15.19">         }</span>
<a href="#l15.20"></a><span id="l15.20">         break;</span>
<a href="#l15.21"></a><span id="l15.21">       case nsIImapUrl::nsImapAddMsgFlags:</span>
<a href="#l15.22"></a><span id="l15.22" class="difflineat">@@ -4718,17 +4718,17 @@ bool nsImapProtocol::GetShowAttachmentsI</span>
<a href="#l15.23"></a><span id="l15.23"> </span>
<a href="#l15.24"></a><span id="l15.24"> void nsImapProtocol::SetContentModified(IMAP_ContentModifiedType modified)</span>
<a href="#l15.25"></a><span id="l15.25"> {</span>
<a href="#l15.26"></a><span id="l15.26">   if (m_runningUrl &amp;&amp; m_imapMessageSink)</span>
<a href="#l15.27"></a><span id="l15.27">     m_imapMessageSink-&gt;SetContentModified(m_runningUrl, modified);</span>
<a href="#l15.28"></a><span id="l15.28"> }</span>
<a href="#l15.29"></a><span id="l15.29"> </span>
<a href="#l15.30"></a><span id="l15.30"> </span>
<a href="#l15.31"></a><span id="l15.31" class="difflineminus">-bool	nsImapProtocol::GetShouldFetchAllParts()</span>
<a href="#l15.32"></a><span id="l15.32" class="difflineplus">+bool nsImapProtocol::GetShouldFetchAllParts()</span>
<a href="#l15.33"></a><span id="l15.33"> {</span>
<a href="#l15.34"></a><span id="l15.34">   if (m_runningUrl  &amp;&amp; !DeathSignalReceived())</span>
<a href="#l15.35"></a><span id="l15.35">   {</span>
<a href="#l15.36"></a><span id="l15.36">     nsImapContentModifiedType contentModified;</span>
<a href="#l15.37"></a><span id="l15.37">     if (NS_SUCCEEDED(m_runningUrl-&gt;GetContentModified(&amp;contentModified)))</span>
<a href="#l15.38"></a><span id="l15.38">       return (contentModified == IMAP_CONTENT_FORCE_CONTENT_NOT_MODIFIED);</span>
<a href="#l15.39"></a><span id="l15.39">   }</span>
<a href="#l15.40"></a><span id="l15.40">   return true;</span>
<a href="#l15.41"></a><span id="l15.41" class="difflineat">@@ -7036,33 +7036,33 @@ bool nsImapProtocol::DeleteSubFolders(co</span>
<a href="#l15.42"></a><span id="l15.42">             // empty trash)</span>
<a href="#l15.43"></a><span id="l15.43">       // The Cyrus imap server ignores the &quot;INBOX.Trash&quot; constraining</span>
<a href="#l15.44"></a><span id="l15.44">             // string passed to the list command.  Be defensive and make sure</span>
<a href="#l15.45"></a><span id="l15.45">             // we only delete children of the trash</span>
<a href="#l15.46"></a><span id="l15.46">       if (longestName &amp;&amp;</span>
<a href="#l15.47"></a><span id="l15.47">         strcmp(selectedMailbox, longestName) &amp;&amp;</span>
<a href="#l15.48"></a><span id="l15.48">         !strncmp(selectedMailbox, longestName, strlen(selectedMailbox)))</span>
<a href="#l15.49"></a><span id="l15.49">       {</span>
<a href="#l15.50"></a><span id="l15.50" class="difflineminus">-          if( selectedMailboxDir &amp;&amp; !strcmp(selectedMailboxDir, longestName) )	// just myself</span>
<a href="#l15.51"></a><span id="l15.51" class="difflineplus">+          if( selectedMailboxDir &amp;&amp; !strcmp(selectedMailboxDir, longestName) )  // just myself</span>
<a href="#l15.52"></a><span id="l15.52">           {</span>
<a href="#l15.53"></a><span id="l15.53">               if( aDeleteSelf )</span>
<a href="#l15.54"></a><span id="l15.54">               {</span>
<a href="#l15.55"></a><span id="l15.55">                   bool deleted = DeleteMailboxRespectingSubscriptions(longestName);</span>
<a href="#l15.56"></a><span id="l15.56">                   if (deleted)</span>
<a href="#l15.57"></a><span id="l15.57">                       FolderDeleted(longestName);</span>
<a href="#l15.58"></a><span id="l15.58">                   folderDeleted = deleted;</span>
<a href="#l15.59"></a><span id="l15.59">                   deleteSucceeded = deleted;</span>
<a href="#l15.60"></a><span id="l15.60">               }</span>
<a href="#l15.61"></a><span id="l15.61">           }</span>
<a href="#l15.62"></a><span id="l15.62">           else</span>
<a href="#l15.63"></a><span id="l15.63">           {</span>
<a href="#l15.64"></a><span id="l15.64">               if (m_imapServerSink)</span>
<a href="#l15.65"></a><span id="l15.65">                   m_imapServerSink-&gt;ResetServerConnection(nsDependentCString(longestName));</span>
<a href="#l15.66"></a><span id="l15.66">               bool deleted = false;</span>
<a href="#l15.67"></a><span id="l15.67" class="difflineminus">-              if( folderInSubfolderList )	// for performance</span>
<a href="#l15.68"></a><span id="l15.68" class="difflineplus">+              if( folderInSubfolderList )  // for performance</span>
<a href="#l15.69"></a><span id="l15.69">               {</span>
<a href="#l15.70"></a><span id="l15.70">                   nsTArray&lt;char*&gt; *pDeletableChildren = m_deletableChildren;</span>
<a href="#l15.71"></a><span id="l15.71">                   m_deletableChildren = nullptr;</span>
<a href="#l15.72"></a><span id="l15.72">                   bool folderDeleted = true;</span>
<a href="#l15.73"></a><span id="l15.73">                   deleted = DeleteSubFolders(longestName, folderDeleted);</span>
<a href="#l15.74"></a><span id="l15.74">                   // longestName may have subfolder list including itself</span>
<a href="#l15.75"></a><span id="l15.75">                   if( !folderDeleted )</span>
<a href="#l15.76"></a><span id="l15.76">                   {</span>
<a href="#l15.77"></a><span id="l15.77" class="difflineat">@@ -7292,30 +7292,30 @@ void nsImapProtocol::DiscoverAllAndSubsc</span>
<a href="#l15.78"></a><span id="l15.78">             boxSpec-&gt;mBoxFlags |= kPersonalMailbox;</span>
<a href="#l15.79"></a><span id="l15.79">             break;</span>
<a href="#l15.80"></a><span id="l15.80">           case kPublicNamespace:</span>
<a href="#l15.81"></a><span id="l15.81">             boxSpec-&gt;mBoxFlags |= kPublicMailbox;</span>
<a href="#l15.82"></a><span id="l15.82">             break;</span>
<a href="#l15.83"></a><span id="l15.83">           case kOtherUsersNamespace:</span>
<a href="#l15.84"></a><span id="l15.84">             boxSpec-&gt;mBoxFlags |= kOtherUsersMailbox;</span>
<a href="#l15.85"></a><span id="l15.85">             break;</span>
<a href="#l15.86"></a><span id="l15.86" class="difflineminus">-          default:	// (kUnknownNamespace)</span>
<a href="#l15.87"></a><span id="l15.87" class="difflineplus">+          default:  // (kUnknownNamespace)</span>
<a href="#l15.88"></a><span id="l15.88">             break;</span>
<a href="#l15.89"></a><span id="l15.89">           }</span>
<a href="#l15.90"></a><span id="l15.90"> </span>
<a href="#l15.91"></a><span id="l15.91">           DiscoverMailboxSpec(boxSpec);</span>
<a href="#l15.92"></a><span id="l15.92">         }</span>
<a href="#l15.93"></a><span id="l15.93"> </span>
<a href="#l15.94"></a><span id="l15.94">         nsAutoCString allPattern(prefix);</span>
<a href="#l15.95"></a><span id="l15.95">         allPattern += '*';</span>
<a href="#l15.96"></a><span id="l15.96"> </span>
<a href="#l15.97"></a><span id="l15.97">         if (!m_imapServerSink) return;</span>
<a href="#l15.98"></a><span id="l15.98"> </span>
<a href="#l15.99"></a><span id="l15.99">         m_imapServerSink-&gt;SetServerDoingLsub(true);</span>
<a href="#l15.100"></a><span id="l15.100" class="difflineminus">-        Lsub(allPattern.get(), true);	// LSUB all the subscribed</span>
<a href="#l15.101"></a><span id="l15.101" class="difflineplus">+        Lsub(allPattern.get(), true);  // LSUB all the subscribed</span>
<a href="#l15.102"></a><span id="l15.102"> </span>
<a href="#l15.103"></a><span id="l15.103">         m_imapServerSink-&gt;SetServerDoingLsub(false);</span>
<a href="#l15.104"></a><span id="l15.104">         List(allPattern.get(), true); // LIST all folders</span>
<a href="#l15.105"></a><span id="l15.105">       }</span>
<a href="#l15.106"></a><span id="l15.106">     }</span>
<a href="#l15.107"></a><span id="l15.107">   }</span>
<a href="#l15.108"></a><span id="l15.108"> }</span>
<a href="#l15.109"></a><span id="l15.109"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/mailnews/imap/src/nsImapSearchResults.cpp</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapSearchResults.cpp</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -40,17 +40,17 @@ void nsImapSearchResultSequence::ResetSe</span>
<a href="#l16.4"></a><span id="l16.4">   Clear();</span>
<a href="#l16.5"></a><span id="l16.5"> }</span>
<a href="#l16.6"></a><span id="l16.6"> </span>
<a href="#l16.7"></a><span id="l16.7"> void nsImapSearchResultSequence::AddSearchResultLine(const char *searchLine)</span>
<a href="#l16.8"></a><span id="l16.8"> {</span>
<a href="#l16.9"></a><span id="l16.9">   // The first add becomes node 2.  Fix this.</span>
<a href="#l16.10"></a><span id="l16.10">   char *copiedSequence = PL_strdup(searchLine + 9); // 9 == &quot;* SEARCH &quot;</span>
<a href="#l16.11"></a><span id="l16.11"> </span>
<a href="#l16.12"></a><span id="l16.12" class="difflineminus">-  if (copiedSequence)	// if we can't allocate this then the search won't hit</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+  if (copiedSequence)  // if we can't allocate this then the search won't hit</span>
<a href="#l16.14"></a><span id="l16.14">     AppendElement(copiedSequence);</span>
<a href="#l16.15"></a><span id="l16.15"> }</span>
<a href="#l16.16"></a><span id="l16.16"> </span>
<a href="#l16.17"></a><span id="l16.17"> </span>
<a href="#l16.18"></a><span id="l16.18"> nsImapSearchResultIterator::nsImapSearchResultIterator(nsImapSearchResultSequence &amp;sequence) :</span>
<a href="#l16.19"></a><span id="l16.19"> fSequence(sequence)</span>
<a href="#l16.20"></a><span id="l16.20"> {</span>
<a href="#l16.21"></a><span id="l16.21">   ResetIterator();</span>
<a href="#l16.22"></a><span id="l16.22" class="difflineat">@@ -66,26 +66,26 @@ void  nsImapSearchResultIterator::ResetI</span>
<a href="#l16.23"></a><span id="l16.23">   fCurrentLine = (char *) fSequence.SafeElementAt(fSequenceIndex);</span>
<a href="#l16.24"></a><span id="l16.24">   fPositionInCurrentLine = fCurrentLine;</span>
<a href="#l16.25"></a><span id="l16.25"> }</span>
<a href="#l16.26"></a><span id="l16.26"> </span>
<a href="#l16.27"></a><span id="l16.27"> int32_t nsImapSearchResultIterator::GetNextMessageNumber()</span>
<a href="#l16.28"></a><span id="l16.28"> {</span>
<a href="#l16.29"></a><span id="l16.29">   int32_t returnValue = 0;</span>
<a href="#l16.30"></a><span id="l16.30">   if (fPositionInCurrentLine)</span>
<a href="#l16.31"></a><span id="l16.31" class="difflineminus">-  {	</span>
<a href="#l16.32"></a><span id="l16.32" class="difflineplus">+  {</span>
<a href="#l16.33"></a><span id="l16.33">     returnValue = atoi(fPositionInCurrentLine);</span>
<a href="#l16.34"></a><span id="l16.34"> </span>
<a href="#l16.35"></a><span id="l16.35">     // eat the current number</span>
<a href="#l16.36"></a><span id="l16.36">     while (isdigit(*++fPositionInCurrentLine))</span>
<a href="#l16.37"></a><span id="l16.37">       ;</span>
<a href="#l16.38"></a><span id="l16.38"> </span>
<a href="#l16.39"></a><span id="l16.39" class="difflineminus">-    if (*fPositionInCurrentLine == 0xD)	// found CR, no more digits on line</span>
<a href="#l16.40"></a><span id="l16.40" class="difflineplus">+    if (*fPositionInCurrentLine == 0xD)  // found CR, no more digits on line</span>
<a href="#l16.41"></a><span id="l16.41">     {</span>
<a href="#l16.42"></a><span id="l16.42">       fCurrentLine = (char *) fSequence.SafeElementAt(++fSequenceIndex);</span>
<a href="#l16.43"></a><span id="l16.43">       fPositionInCurrentLine = fCurrentLine;</span>
<a href="#l16.44"></a><span id="l16.44">     }</span>
<a href="#l16.45"></a><span id="l16.45" class="difflineminus">-    else	// eat the space</span>
<a href="#l16.46"></a><span id="l16.46" class="difflineplus">+    else  // eat the space</span>
<a href="#l16.47"></a><span id="l16.47">       fPositionInCurrentLine++;</span>
<a href="#l16.48"></a><span id="l16.48">   }</span>
<a href="#l16.49"></a><span id="l16.49"> </span>
<a href="#l16.50"></a><span id="l16.50">   return returnValue;</span>
<a href="#l16.51"></a><span id="l16.51"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/mailnews/imap/src/nsImapServerResponseParser.cpp</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapServerResponseParser.cpp</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -206,17 +206,17 @@ void nsImapServerResponseParser::ParseIM</span>
<a href="#l17.4"></a><span id="l17.4">             if (!fAtEndOfLine)</span>
<a href="#l17.5"></a><span id="l17.5">               SetSyntaxError(true);</span>
<a href="#l17.6"></a><span id="l17.6">             else if (!inIdle &amp;&amp; !fCurrentCommandFailed &amp;&amp; !aGreetingWithCapability)</span>
<a href="#l17.7"></a><span id="l17.7">               AdvanceToNextToken();</span>
<a href="#l17.8"></a><span id="l17.8">           }</span>
<a href="#l17.9"></a><span id="l17.9">         }</span>
<a href="#l17.10"></a><span id="l17.10"> </span>
<a href="#l17.11"></a><span id="l17.11">         // command continuation request [RFC3501, Sec. 7.5]</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineminus">-        if (ContinueParse() &amp;&amp; fNextToken &amp;&amp; *fNextToken == '+')	// never pipeline APPEND or AUTHENTICATE</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+        if (ContinueParse() &amp;&amp; fNextToken &amp;&amp; *fNextToken == '+')  // never pipeline APPEND or AUTHENTICATE</span>
<a href="#l17.14"></a><span id="l17.14">         {</span>
<a href="#l17.15"></a><span id="l17.15">           NS_ASSERTION((fNumberOfTaggedResponsesExpected - numberOfTaggedResponsesReceived) == 1,</span>
<a href="#l17.16"></a><span id="l17.16">             &quot; didn't get the number of tagged responses we expected&quot;);</span>
<a href="#l17.17"></a><span id="l17.17">           numberOfTaggedResponsesReceived = fNumberOfTaggedResponsesExpected;</span>
<a href="#l17.18"></a><span id="l17.18">           if (commandToken &amp;&amp; !PL_strcasecmp(commandToken, &quot;authenticate&quot;) &amp;&amp; placeInTokenString &amp;&amp;</span>
<a href="#l17.19"></a><span id="l17.19">             (!PL_strncasecmp(placeInTokenString, &quot;CRAM-MD5&quot;, strlen(&quot;CRAM-MD5&quot;))</span>
<a href="#l17.20"></a><span id="l17.20">              || !PL_strncasecmp(placeInTokenString, &quot;NTLM&quot;, strlen(&quot;NTLM&quot;))</span>
<a href="#l17.21"></a><span id="l17.21">              || !PL_strncasecmp(placeInTokenString, &quot;GSSAPI&quot;, strlen(&quot;GSSAPI&quot;))</span>
<a href="#l17.22"></a><span id="l17.22" class="difflineat">@@ -299,36 +299,36 @@ void nsImapServerResponseParser::PreProc</span>
<a href="#l17.23"></a><span id="l17.23">     {</span>
<a href="#l17.24"></a><span id="l17.24">       // strip the escape chars and the ending quote</span>
<a href="#l17.25"></a><span id="l17.25">       char *currentChar = fSelectedMailboxName;</span>
<a href="#l17.26"></a><span id="l17.26">       while (*currentChar)</span>
<a href="#l17.27"></a><span id="l17.27">       {</span>
<a href="#l17.28"></a><span id="l17.28">         if (*currentChar == '\\')</span>
<a href="#l17.29"></a><span id="l17.29">         {</span>
<a href="#l17.30"></a><span id="l17.30">           PL_strcpy(currentChar, currentChar+1);</span>
<a href="#l17.31"></a><span id="l17.31" class="difflineminus">-          currentChar++;	// skip what we are escaping</span>
<a href="#l17.32"></a><span id="l17.32" class="difflineplus">+          currentChar++;  // skip what we are escaping</span>
<a href="#l17.33"></a><span id="l17.33">         }</span>
<a href="#l17.34"></a><span id="l17.34">         else if (*currentChar == '\&quot;')</span>
<a href="#l17.35"></a><span id="l17.35" class="difflineminus">-          *currentChar = 0;	// end quote</span>
<a href="#l17.36"></a><span id="l17.36" class="difflineplus">+          *currentChar = 0;  // end quote</span>
<a href="#l17.37"></a><span id="l17.37">         else</span>
<a href="#l17.38"></a><span id="l17.38">           currentChar++;</span>
<a href="#l17.39"></a><span id="l17.39">       }</span>
<a href="#l17.40"></a><span id="l17.40">     }</span>
<a href="#l17.41"></a><span id="l17.41">     else</span>
<a href="#l17.42"></a><span id="l17.42">       HandleMemoryFailure();</span>
<a href="#l17.43"></a><span id="l17.43"> </span>
<a href="#l17.44"></a><span id="l17.44">     // we don't want bogus info for this new box</span>
<a href="#l17.45"></a><span id="l17.45" class="difflineminus">-    //delete fFlagState;	// not our object</span>
<a href="#l17.46"></a><span id="l17.46" class="difflineplus">+    //delete fFlagState;  // not our object</span>
<a href="#l17.47"></a><span id="l17.47">     //fFlagState = nullptr;</span>
<a href="#l17.48"></a><span id="l17.48">   }</span>
<a href="#l17.49"></a><span id="l17.49">   else if (!PL_strcasecmp(commandToken, &quot;CLOSE&quot;))</span>
<a href="#l17.50"></a><span id="l17.50">   {</span>
<a href="#l17.51"></a><span id="l17.51" class="difflineminus">-    return;	// just for debugging</span>
<a href="#l17.52"></a><span id="l17.52" class="difflineplus">+    return;  // just for debugging</span>
<a href="#l17.53"></a><span id="l17.53">     // we don't want bogus info outside the selected state</span>
<a href="#l17.54"></a><span id="l17.54" class="difflineminus">-    //delete fFlagState;	// not our object</span>
<a href="#l17.55"></a><span id="l17.55" class="difflineplus">+    //delete fFlagState;  // not our object</span>
<a href="#l17.56"></a><span id="l17.56">     //fFlagState = nullptr;</span>
<a href="#l17.57"></a><span id="l17.57">   }</span>
<a href="#l17.58"></a><span id="l17.58">   else if (!PL_strcasecmp(commandToken, &quot;UID&quot;))</span>
<a href="#l17.59"></a><span id="l17.59">   {</span>
<a href="#l17.60"></a><span id="l17.60">     nsCString copyCurrentCommand(currentCommand);</span>
<a href="#l17.61"></a><span id="l17.61">     if (!fServerConnection.DeathSignalReceived())</span>
<a href="#l17.62"></a><span id="l17.62">     {</span>
<a href="#l17.63"></a><span id="l17.63">       char *placeInTokenString = copyCurrentCommand.BeginWriting();</span>
<a href="#l17.64"></a><span id="l17.64" class="difflineat">@@ -429,17 +429,17 @@ void nsImapServerResponseParser::Process</span>
<a href="#l17.65"></a><span id="l17.65">         // for the first time. Release it.</span>
<a href="#l17.66"></a><span id="l17.66">         if (!m_shell-&gt;IsShellCached())</span>
<a href="#l17.67"></a><span id="l17.67">           m_shell = nullptr;</span>
<a href="#l17.68"></a><span id="l17.68">         navCon-&gt;PseudoInterrupt(false);</span>
<a href="#l17.69"></a><span id="l17.69">       }</span>
<a href="#l17.70"></a><span id="l17.70">       else if (m_shell-&gt;GetIsValid())</span>
<a href="#l17.71"></a><span id="l17.71">       {</span>
<a href="#l17.72"></a><span id="l17.72">         // If we have a valid shell that has not already been cached, then cache it.</span>
<a href="#l17.73"></a><span id="l17.73" class="difflineminus">-        if (!m_shell-&gt;IsShellCached() &amp;&amp; fHostSessionList)	// cache is responsible for destroying it</span>
<a href="#l17.74"></a><span id="l17.74" class="difflineplus">+        if (!m_shell-&gt;IsShellCached() &amp;&amp; fHostSessionList)  // cache is responsible for destroying it</span>
<a href="#l17.75"></a><span id="l17.75">         {</span>
<a href="#l17.76"></a><span id="l17.76">           MOZ_LOG(IMAP, mozilla::LogLevel::Info,</span>
<a href="#l17.77"></a><span id="l17.77">             (&quot;BODYSHELL:  Adding shell to cache.&quot;));</span>
<a href="#l17.78"></a><span id="l17.78">           const char *serverKey = fServerConnection.GetImapServerKey();</span>
<a href="#l17.79"></a><span id="l17.79">           fHostSessionList-&gt;AddShellToCacheForHost(</span>
<a href="#l17.80"></a><span id="l17.80">             serverKey, m_shell);</span>
<a href="#l17.81"></a><span id="l17.81">         }</span>
<a href="#l17.82"></a><span id="l17.82">       }</span>
<a href="#l17.83"></a><span id="l17.83" class="difflineat">@@ -856,17 +856,17 @@ void nsImapServerResponseParser::mailbox</span>
<a href="#l17.84"></a><span id="l17.84">     if (*fNextToken == '&quot;')</span>
<a href="#l17.85"></a><span id="l17.85">     {</span>
<a href="#l17.86"></a><span id="l17.86">       fNextToken++;</span>
<a href="#l17.87"></a><span id="l17.87">       if (*fNextToken == '\\') // handle escaped char</span>
<a href="#l17.88"></a><span id="l17.88">         boxSpec-&gt;mHierarchySeparator = *(fNextToken + 1);</span>
<a href="#l17.89"></a><span id="l17.89">       else</span>
<a href="#l17.90"></a><span id="l17.90">         boxSpec-&gt;mHierarchySeparator = *fNextToken;</span>
<a href="#l17.91"></a><span id="l17.91">     }</span>
<a href="#l17.92"></a><span id="l17.92" class="difflineminus">-    else	// likely NIL.  Discovered late in 4.02 that we do not handle literals here (e.g. {10} &lt;10 chars&gt;), although this is almost impossibly unlikely</span>
<a href="#l17.93"></a><span id="l17.93" class="difflineplus">+    else  // likely NIL.  Discovered late in 4.02 that we do not handle literals here (e.g. {10} &lt;10 chars&gt;), although this is almost impossibly unlikely</span>
<a href="#l17.94"></a><span id="l17.94">       boxSpec-&gt;mHierarchySeparator = kOnlineHierarchySeparatorNil;</span>
<a href="#l17.95"></a><span id="l17.95">     AdvanceToNextToken();</span>
<a href="#l17.96"></a><span id="l17.96">     if (ContinueParse())</span>
<a href="#l17.97"></a><span id="l17.97">       mailbox(boxSpec);</span>
<a href="#l17.98"></a><span id="l17.98">   }</span>
<a href="#l17.99"></a><span id="l17.99"> }</span>
<a href="#l17.100"></a><span id="l17.100"> </span>
<a href="#l17.101"></a><span id="l17.101"> /* mailbox         ::= &quot;INBOX&quot; / astring</span>
<a href="#l17.102"></a><span id="l17.102" class="difflineat">@@ -907,28 +907,26 @@ void nsImapServerResponseParser::mailbox</span>
<a href="#l17.103"></a><span id="l17.103">         boxSpec-&gt;mBoxFlags |= kPersonalMailbox;</span>
<a href="#l17.104"></a><span id="l17.104">         break;</span>
<a href="#l17.105"></a><span id="l17.105">       case kPublicNamespace:</span>
<a href="#l17.106"></a><span id="l17.106">         boxSpec-&gt;mBoxFlags |= kPublicMailbox;</span>
<a href="#l17.107"></a><span id="l17.107">         break;</span>
<a href="#l17.108"></a><span id="l17.108">       case kOtherUsersNamespace:</span>
<a href="#l17.109"></a><span id="l17.109">         boxSpec-&gt;mBoxFlags |= kOtherUsersMailbox;</span>
<a href="#l17.110"></a><span id="l17.110">         break;</span>
<a href="#l17.111"></a><span id="l17.111" class="difflineminus">-      default:	// (kUnknownNamespace)</span>
<a href="#l17.112"></a><span id="l17.112" class="difflineplus">+      default:  // (kUnknownNamespace)</span>
<a href="#l17.113"></a><span id="l17.113">         break;</span>
<a href="#l17.114"></a><span id="l17.114">       }</span>
<a href="#l17.115"></a><span id="l17.115">       boxSpec-&gt;mNamespaceForFolder = ns;</span>
<a href="#l17.116"></a><span id="l17.116">     }</span>
<a href="#l17.117"></a><span id="l17.117"> </span>
<a href="#l17.118"></a><span id="l17.118" class="difflineminus">-    //    	char *convertedName =</span>
<a href="#l17.119"></a><span id="l17.119" class="difflineminus">-    //            fServerConnection.CreateUtf7ConvertedString(boxname, false);</span>
<a href="#l17.120"></a><span id="l17.120" class="difflineminus">-    //		char16_t *unicharName;</span>
<a href="#l17.121"></a><span id="l17.121" class="difflineminus">-    //        unicharName = fServerConnection.CreatePRUnicharStringFromUTF7(boxname);</span>
<a href="#l17.122"></a><span id="l17.122" class="difflineminus">-    //    	PL_strfree(boxname);</span>
<a href="#l17.123"></a><span id="l17.123" class="difflineminus">-    //    	boxname = convertedName;</span>
<a href="#l17.124"></a><span id="l17.124" class="difflineplus">+    // char *convertedName = fServerConnection.CreateUtf7ConvertedString(boxname, false);</span>
<a href="#l17.125"></a><span id="l17.125" class="difflineplus">+    // char16_t *unicharName = fServerConnection.CreatePRUnicharStringFromUTF7(boxname);</span>
<a href="#l17.126"></a><span id="l17.126" class="difflineplus">+    // PL_strfree(boxname);</span>
<a href="#l17.127"></a><span id="l17.127" class="difflineplus">+    // boxname = convertedName;</span>
<a href="#l17.128"></a><span id="l17.128">   }</span>
<a href="#l17.129"></a><span id="l17.129"> </span>
<a href="#l17.130"></a><span id="l17.130">   if (!boxname)</span>
<a href="#l17.131"></a><span id="l17.131">   {</span>
<a href="#l17.132"></a><span id="l17.132">     if (!fServerConnection.DeathSignalReceived())</span>
<a href="#l17.133"></a><span id="l17.133">       HandleMemoryFailure();</span>
<a href="#l17.134"></a><span id="l17.134">   }</span>
<a href="#l17.135"></a><span id="l17.135">   else if (boxSpec-&gt;mConnection &amp;&amp; boxSpec-&gt;mConnection-&gt;GetCurrentUrl())</span>
<a href="#l17.136"></a><span id="l17.136" class="difflineat">@@ -1103,23 +1101,22 @@ void nsImapServerResponseParser::msg_fet</span>
<a href="#l17.137"></a><span id="l17.137">         }</span>
<a href="#l17.138"></a><span id="l17.138">         else</span>
<a href="#l17.139"></a><span id="l17.139">         {</span>
<a href="#l17.140"></a><span id="l17.140">           SetSyntaxError(true);</span>
<a href="#l17.141"></a><span id="l17.141">         }</span>
<a href="#l17.142"></a><span id="l17.142">       }</span>
<a href="#l17.143"></a><span id="l17.143">     }</span>
<a href="#l17.144"></a><span id="l17.144">     else if (!PL_strcasecmp(fNextToken, &quot;RFC822&quot;) ||</span>
<a href="#l17.145"></a><span id="l17.145" class="difflineminus">-      !PL_strcasecmp(fNextToken, &quot;RFC822.HEADER&quot;) ||</span>
<a href="#l17.146"></a><span id="l17.146" class="difflineminus">-      !PL_strncasecmp(fNextToken, &quot;BODY[HEADER&quot;,11) ||</span>
<a href="#l17.147"></a><span id="l17.147" class="difflineminus">-      !PL_strncasecmp(fNextToken, &quot;BODY[]&quot;, 6) ||</span>
<a href="#l17.148"></a><span id="l17.148" class="difflineminus">-      !PL_strcasecmp(fNextToken, &quot;RFC822.TEXT&quot;) ||</span>
<a href="#l17.149"></a><span id="l17.149" class="difflineminus">-      (!PL_strncasecmp(fNextToken, &quot;BODY[&quot;, 5) &amp;&amp;</span>
<a href="#l17.150"></a><span id="l17.150" class="difflineminus">-				  PL_strstr(fNextToken, &quot;HEADER&quot;))</span>
<a href="#l17.151"></a><span id="l17.151" class="difflineminus">-                                  )</span>
<a href="#l17.152"></a><span id="l17.152" class="difflineplus">+             !PL_strcasecmp(fNextToken, &quot;RFC822.HEADER&quot;) ||</span>
<a href="#l17.153"></a><span id="l17.153" class="difflineplus">+             !PL_strncasecmp(fNextToken, &quot;BODY[HEADER&quot;,11) ||</span>
<a href="#l17.154"></a><span id="l17.154" class="difflineplus">+             !PL_strncasecmp(fNextToken, &quot;BODY[]&quot;, 6) ||</span>
<a href="#l17.155"></a><span id="l17.155" class="difflineplus">+             !PL_strcasecmp(fNextToken, &quot;RFC822.TEXT&quot;) ||</span>
<a href="#l17.156"></a><span id="l17.156" class="difflineplus">+             (!PL_strncasecmp(fNextToken, &quot;BODY[&quot;, 5) &amp;&amp;</span>
<a href="#l17.157"></a><span id="l17.157" class="difflineplus">+              PL_strstr(fNextToken, &quot;HEADER&quot;)))</span>
<a href="#l17.158"></a><span id="l17.158">     {</span>
<a href="#l17.159"></a><span id="l17.159">       if (fCurrentResponseUID == 0)</span>
<a href="#l17.160"></a><span id="l17.160">         fFlagState-&gt;GetUidOfMessage(fFetchResponseIndex - 1, &amp;fCurrentResponseUID);</span>
<a href="#l17.161"></a><span id="l17.161"> </span>
<a href="#l17.162"></a><span id="l17.162">       if (!PL_strcasecmp(fNextToken, &quot;RFC822.HEADER&quot;) ||</span>
<a href="#l17.163"></a><span id="l17.163">         !PL_strcasecmp(fNextToken, &quot;BODY[HEADER]&quot;))</span>
<a href="#l17.164"></a><span id="l17.164">       {</span>
<a href="#l17.165"></a><span id="l17.165">         // all of this message's headers</span>
<a href="#l17.166"></a><span id="l17.166" class="difflineat">@@ -1185,17 +1182,17 @@ void nsImapServerResponseParser::msg_fet</span>
<a href="#l17.167"></a><span id="l17.167">           bool chunk = false;</span>
<a href="#l17.168"></a><span id="l17.168">           int32_t origin = 0;</span>
<a href="#l17.169"></a><span id="l17.169">           if (!PL_strncasecmp(fNextToken, &quot;BODY[]&lt;&quot;, 7))</span>
<a href="#l17.170"></a><span id="l17.170">           {</span>
<a href="#l17.171"></a><span id="l17.171">             char *tokenCopy = 0;</span>
<a href="#l17.172"></a><span id="l17.172">             tokenCopy = PL_strdup(fNextToken);</span>
<a href="#l17.173"></a><span id="l17.173">             if (tokenCopy)</span>
<a href="#l17.174"></a><span id="l17.174">             {</span>
<a href="#l17.175"></a><span id="l17.175" class="difflineminus">-              char *originString = tokenCopy + 7;	// where the byte number starts</span>
<a href="#l17.176"></a><span id="l17.176" class="difflineplus">+              char *originString = tokenCopy + 7;  // where the byte number starts</span>
<a href="#l17.177"></a><span id="l17.177">               char *closeBracket = PL_strchr(tokenCopy,'&gt;');</span>
<a href="#l17.178"></a><span id="l17.178">               if (closeBracket &amp;&amp; originString &amp;&amp; *originString)</span>
<a href="#l17.179"></a><span id="l17.179">               {</span>
<a href="#l17.180"></a><span id="l17.180">                 *closeBracket = 0;</span>
<a href="#l17.181"></a><span id="l17.181">                 origin = atoi(originString);</span>
<a href="#l17.182"></a><span id="l17.182">                 chunk = true;</span>
<a href="#l17.183"></a><span id="l17.183">               }</span>
<a href="#l17.184"></a><span id="l17.184">               PR_Free(tokenCopy);</span>
<a href="#l17.185"></a><span id="l17.185" class="difflineat">@@ -1416,24 +1413,24 @@ void nsImapServerResponseParser::msg_fet</span>
<a href="#l17.186"></a><span id="l17.186">               fServerConnection.AbortMessageDownLoad();</span>
<a href="#l17.187"></a><span id="l17.187">           }</span>
<a href="#l17.188"></a><span id="l17.188"> </span>
<a href="#l17.189"></a><span id="l17.189">         }</span>
<a href="#l17.190"></a><span id="l17.190"> }</span>
<a href="#l17.191"></a><span id="l17.191"> </span>
<a href="#l17.192"></a><span id="l17.192"> typedef enum _envelopeItemType</span>
<a href="#l17.193"></a><span id="l17.193"> {</span>
<a href="#l17.194"></a><span id="l17.194" class="difflineminus">-	envelopeString,</span>
<a href="#l17.195"></a><span id="l17.195" class="difflineminus">-	envelopeAddress</span>
<a href="#l17.196"></a><span id="l17.196" class="difflineplus">+  envelopeString,</span>
<a href="#l17.197"></a><span id="l17.197" class="difflineplus">+  envelopeAddress</span>
<a href="#l17.198"></a><span id="l17.198"> } envelopeItemType;</span>
<a href="#l17.199"></a><span id="l17.199"> </span>
<a href="#l17.200"></a><span id="l17.200"> typedef struct</span>
<a href="#l17.201"></a><span id="l17.201"> {</span>
<a href="#l17.202"></a><span id="l17.202" class="difflineminus">-	const char * name;</span>
<a href="#l17.203"></a><span id="l17.203" class="difflineminus">-	envelopeItemType type;</span>
<a href="#l17.204"></a><span id="l17.204" class="difflineplus">+  const char * name;</span>
<a href="#l17.205"></a><span id="l17.205" class="difflineplus">+  envelopeItemType type;</span>
<a href="#l17.206"></a><span id="l17.206"> } envelopeItem;</span>
<a href="#l17.207"></a><span id="l17.207"> </span>
<a href="#l17.208"></a><span id="l17.208"> // RFC3501:  envelope  = &quot;(&quot; env-date SP env-subject SP env-from SP</span>
<a href="#l17.209"></a><span id="l17.209"> //                       env-sender SP env-reply-to SP env-to SP env-cc SP</span>
<a href="#l17.210"></a><span id="l17.210"> //                       env-bcc SP env-in-reply-to SP env-message-id &quot;)&quot;</span>
<a href="#l17.211"></a><span id="l17.211"> //           env-date    = nstring</span>
<a href="#l17.212"></a><span id="l17.212"> //           env-subject = nstring</span>
<a href="#l17.213"></a><span id="l17.213"> //           env-from    = &quot;(&quot; 1*address &quot;)&quot; / nil</span>
<a href="#l17.214"></a><span id="l17.214" class="difflineat">@@ -1538,38 +1535,38 @@ void nsImapServerResponseParser::xaolenv</span>
<a href="#l17.215"></a><span id="l17.215">         else</span>
<a href="#l17.216"></a><span id="l17.216">         {</span>
<a href="#l17.217"></a><span id="l17.217">           fromLine.AppendLiteral(&quot;From: &quot;);</span>
<a href="#l17.218"></a><span id="l17.218">         }</span>
<a href="#l17.219"></a><span id="l17.219">         parse_address(fromLine);</span>
<a href="#l17.220"></a><span id="l17.220">         fServerConnection.HandleMessageDownLoadLine(fromLine.get(), false);</span>
<a href="#l17.221"></a><span id="l17.221">         if (ContinueParse())</span>
<a href="#l17.222"></a><span id="l17.222">         {</span>
<a href="#l17.223"></a><span id="l17.223" class="difflineminus">-          AdvanceToNextToken();	// ge attachment size</span>
<a href="#l17.224"></a><span id="l17.224" class="difflineplus">+          AdvanceToNextToken();  // ge attachment size</span>
<a href="#l17.225"></a><span id="l17.225">           int32_t attachmentSize = atoi(fNextToken);</span>
<a href="#l17.226"></a><span id="l17.226">           if (attachmentSize != 0)</span>
<a href="#l17.227"></a><span id="l17.227">           {</span>
<a href="#l17.228"></a><span id="l17.228">             nsAutoCString attachmentLine(&quot;X-attachment-size: &quot;);</span>
<a href="#l17.229"></a><span id="l17.229">             attachmentLine.AppendInt(attachmentSize);</span>
<a href="#l17.230"></a><span id="l17.230">             fServerConnection.HandleMessageDownLoadLine(attachmentLine.get(), false);</span>
<a href="#l17.231"></a><span id="l17.231">           }</span>
<a href="#l17.232"></a><span id="l17.232">         }</span>
<a href="#l17.233"></a><span id="l17.233">         if (ContinueParse())</span>
<a href="#l17.234"></a><span id="l17.234">         {</span>
<a href="#l17.235"></a><span id="l17.235" class="difflineminus">-          AdvanceToNextToken();	// skip image size</span>
<a href="#l17.236"></a><span id="l17.236" class="difflineplus">+          AdvanceToNextToken();  // skip image size</span>
<a href="#l17.237"></a><span id="l17.237">           int32_t imageSize = atoi(fNextToken);</span>
<a href="#l17.238"></a><span id="l17.238">           if (imageSize != 0)</span>
<a href="#l17.239"></a><span id="l17.239">           {</span>
<a href="#l17.240"></a><span id="l17.240">             nsAutoCString imageLine(&quot;X-image-size: &quot;);</span>
<a href="#l17.241"></a><span id="l17.241">             imageLine.AppendInt(imageSize);</span>
<a href="#l17.242"></a><span id="l17.242">             fServerConnection.HandleMessageDownLoadLine(imageLine.get(), false);</span>
<a href="#l17.243"></a><span id="l17.243">           }</span>
<a href="#l17.244"></a><span id="l17.244">         }</span>
<a href="#l17.245"></a><span id="l17.245">         if (ContinueParse())</span>
<a href="#l17.246"></a><span id="l17.246" class="difflineminus">-          AdvanceToNextToken();	// skip )</span>
<a href="#l17.247"></a><span id="l17.247" class="difflineplus">+          AdvanceToNextToken();  // skip )</span>
<a href="#l17.248"></a><span id="l17.248">       }</span>
<a href="#l17.249"></a><span id="l17.249">     }</span>
<a href="#l17.250"></a><span id="l17.250">   }</span>
<a href="#l17.251"></a><span id="l17.251"> }</span>
<a href="#l17.252"></a><span id="l17.252"> </span>
<a href="#l17.253"></a><span id="l17.253"> void nsImapServerResponseParser::parse_address(nsAutoCString &amp;addressLine)</span>
<a href="#l17.254"></a><span id="l17.254"> {</span>
<a href="#l17.255"></a><span id="l17.255">   if (!strcmp(fNextToken, &quot;NIL&quot;))</span>
<a href="#l17.256"></a><span id="l17.256" class="difflineat">@@ -1623,17 +1620,17 @@ void nsImapServerResponseParser::parse_a</span>
<a href="#l17.257"></a><span id="l17.257">     // then we must have another address pair left....so get the next</span>
<a href="#l17.258"></a><span id="l17.258">     // token and continue parsing in this loop...</span>
<a href="#l17.259"></a><span id="l17.259">     if ( *fNextToken == '\0' )</span>
<a href="#l17.260"></a><span id="l17.260">       AdvanceToNextToken();</span>
<a href="#l17.261"></a><span id="l17.261"> </span>
<a href="#l17.262"></a><span id="l17.262">   }</span>
<a href="#l17.263"></a><span id="l17.263">   if (*fNextToken == ')')</span>
<a href="#l17.264"></a><span id="l17.264">     fNextToken++;</span>
<a href="#l17.265"></a><span id="l17.265" class="difflineminus">-  //	AdvanceToNextToken();	// skip &quot;))&quot;</span>
<a href="#l17.266"></a><span id="l17.266" class="difflineplus">+  // AdvanceToNextToken();  // skip &quot;))&quot;</span>
<a href="#l17.267"></a><span id="l17.267"> }</span>
<a href="#l17.268"></a><span id="l17.268"> </span>
<a href="#l17.269"></a><span id="l17.269"> void nsImapServerResponseParser::internal_date()</span>
<a href="#l17.270"></a><span id="l17.270"> {</span>
<a href="#l17.271"></a><span id="l17.271">   AdvanceToNextToken();</span>
<a href="#l17.272"></a><span id="l17.272">   if (ContinueParse())</span>
<a href="#l17.273"></a><span id="l17.273">   {</span>
<a href="#l17.274"></a><span id="l17.274">     nsAutoCString dateLine(&quot;Date: &quot;);</span>
<a href="#l17.275"></a><span id="l17.275" class="difflineat">@@ -1758,17 +1755,17 @@ void nsImapServerResponseParser::flags()</span>
<a href="#l17.276"></a><span id="l17.276">     else</span>
<a href="#l17.277"></a><span id="l17.277">       AdvanceToNextToken();</span>
<a href="#l17.278"></a><span id="l17.278">   }</span>
<a href="#l17.279"></a><span id="l17.279"> </span>
<a href="#l17.280"></a><span id="l17.280">   if (ContinueParse())</span>
<a href="#l17.281"></a><span id="l17.281">     while(*fNextToken != ')')</span>
<a href="#l17.282"></a><span id="l17.282">       fNextToken++;</span>
<a href="#l17.283"></a><span id="l17.283"> </span>
<a href="#l17.284"></a><span id="l17.284" class="difflineminus">-  fCurrentLineContainedFlagInfo = true;	// handled in PostProcessEndOfLine</span>
<a href="#l17.285"></a><span id="l17.285" class="difflineplus">+  fCurrentLineContainedFlagInfo = true;  // handled in PostProcessEndOfLine</span>
<a href="#l17.286"></a><span id="l17.286">   fSavedFlagInfo = messageFlags;</span>
<a href="#l17.287"></a><span id="l17.287"> }</span>
<a href="#l17.288"></a><span id="l17.288"> </span>
<a href="#l17.289"></a><span id="l17.289"> // RFC3501:  resp-cond-state = (&quot;OK&quot; / &quot;NO&quot; / &quot;BAD&quot;) SP resp-text</span>
<a href="#l17.290"></a><span id="l17.290"> //                             ; Status condition</span>
<a href="#l17.291"></a><span id="l17.291"> void nsImapServerResponseParser::resp_cond_state(bool isTagged)</span>
<a href="#l17.292"></a><span id="l17.292"> {</span>
<a href="#l17.293"></a><span id="l17.293">   // According to RFC3501, Sec. 7.1, the untagged NO response &quot;indicates a</span>
<a href="#l17.294"></a><span id="l17.294" class="difflineat">@@ -1895,17 +1892,17 @@ void nsImapServerResponseParser::resp_te</span>
<a href="#l17.295"></a><span id="l17.295">     fNextToken++;</span>
<a href="#l17.296"></a><span id="l17.296">   else</span>
<a href="#l17.297"></a><span id="l17.297">     AdvanceToNextToken();</span>
<a href="#l17.298"></a><span id="l17.298"> </span>
<a href="#l17.299"></a><span id="l17.299">   if (ContinueParse())</span>
<a href="#l17.300"></a><span id="l17.300">   {</span>
<a href="#l17.301"></a><span id="l17.301">     if (!PL_strcasecmp(fNextToken,&quot;ALERT]&quot;))</span>
<a href="#l17.302"></a><span id="l17.302">     {</span>
<a href="#l17.303"></a><span id="l17.303" class="difflineminus">-      char *alertMsg = fCurrentTokenPlaceHolder;	// advance past ALERT]</span>
<a href="#l17.304"></a><span id="l17.304" class="difflineplus">+      char *alertMsg = fCurrentTokenPlaceHolder;  // advance past ALERT]</span>
<a href="#l17.305"></a><span id="l17.305">       if (alertMsg &amp;&amp; *alertMsg &amp;&amp; (!fLastAlert || PL_strcmp(fNextToken, fLastAlert)))</span>
<a href="#l17.306"></a><span id="l17.306">       {</span>
<a href="#l17.307"></a><span id="l17.307">         fServerConnection.AlertUserEvent(alertMsg);</span>
<a href="#l17.308"></a><span id="l17.308">         PR_Free(fLastAlert);</span>
<a href="#l17.309"></a><span id="l17.309">         fLastAlert = PL_strdup(alertMsg);</span>
<a href="#l17.310"></a><span id="l17.310">       }</span>
<a href="#l17.311"></a><span id="l17.311">       AdvanceToNextToken();</span>
<a href="#l17.312"></a><span id="l17.312">     }</span>
<a href="#l17.313"></a><span id="l17.313" class="difflineat">@@ -1916,17 +1913,17 @@ void nsImapServerResponseParser::resp_te</span>
<a href="#l17.314"></a><span id="l17.314">     }</span>
<a href="#l17.315"></a><span id="l17.315">     else if (!PL_strcasecmp(fNextToken,&quot;NETSCAPE]&quot;))</span>
<a href="#l17.316"></a><span id="l17.316">     {</span>
<a href="#l17.317"></a><span id="l17.317">       skip_to_CRLF();</span>
<a href="#l17.318"></a><span id="l17.318">     }</span>
<a href="#l17.319"></a><span id="l17.319">     else if (!PL_strcasecmp(fNextToken,&quot;PERMANENTFLAGS&quot;))</span>
<a href="#l17.320"></a><span id="l17.320">     {</span>
<a href="#l17.321"></a><span id="l17.321">       uint32_t saveSettableFlags = fSettablePermanentFlags;</span>
<a href="#l17.322"></a><span id="l17.322" class="difflineminus">-      fSupportsUserDefinedFlags = 0;		// assume no unless told</span>
<a href="#l17.323"></a><span id="l17.323" class="difflineplus">+      fSupportsUserDefinedFlags = 0;  // assume no unless told</span>
<a href="#l17.324"></a><span id="l17.324">       fSettablePermanentFlags = 0;            // assume none, unless told otherwise.</span>
<a href="#l17.325"></a><span id="l17.325">       parse_folder_flags();</span>
<a href="#l17.326"></a><span id="l17.326">       // if the server tells us there are no permanent flags, we're</span>
<a href="#l17.327"></a><span id="l17.327">       // just going to pretend that the FLAGS response flags, if any, are</span>
<a href="#l17.328"></a><span id="l17.328">       // permanent in case the server is broken. This will allow us</span>
<a href="#l17.329"></a><span id="l17.329">       // to store delete and seen flag changes - if they're not permanent,</span>
<a href="#l17.330"></a><span id="l17.330">       // they're not permanent, but at least we'll try to set them.</span>
<a href="#l17.331"></a><span id="l17.331">       if (!fSettablePermanentFlags)</span>
<a href="#l17.332"></a><span id="l17.332" class="difflineat">@@ -2136,17 +2133,17 @@ void nsImapServerResponseParser::msg_fet</span>
<a href="#l17.333"></a><span id="l17.333">   if (PL_strcasecmp(fNextToken, &quot;NIL&quot;))</span>
<a href="#l17.334"></a><span id="l17.334">   {</span>
<a href="#l17.335"></a><span id="l17.335">     if (*fNextToken == '&quot;')</span>
<a href="#l17.336"></a><span id="l17.336">       fLastChunk = msg_fetch_quoted();</span>
<a href="#l17.337"></a><span id="l17.337">     else</span>
<a href="#l17.338"></a><span id="l17.338">       fLastChunk = msg_fetch_literal(chunk, origin);</span>
<a href="#l17.339"></a><span id="l17.339">   }</span>
<a href="#l17.340"></a><span id="l17.340">   else</span>
<a href="#l17.341"></a><span id="l17.341" class="difflineminus">-    AdvanceToNextToken();	// eat &quot;NIL&quot;</span>
<a href="#l17.342"></a><span id="l17.342" class="difflineplus">+    AdvanceToNextToken();  // eat &quot;NIL&quot;</span>
<a href="#l17.343"></a><span id="l17.343"> </span>
<a href="#l17.344"></a><span id="l17.344">   if (fLastChunk &amp;&amp; (GetFillingInShell() ? m_shell-&gt;GetGeneratingWholeMessage() : true))</span>
<a href="#l17.345"></a><span id="l17.345">   {</span>
<a href="#l17.346"></a><span id="l17.346">     // complete the message download</span>
<a href="#l17.347"></a><span id="l17.347">     if (ContinueParse())</span>
<a href="#l17.348"></a><span id="l17.348">     {</span>
<a href="#l17.349"></a><span id="l17.349">       if (fReceivedHeaderOrSizeForUID == CurrentResponseUID())</span>
<a href="#l17.350"></a><span id="l17.350">       {</span>
<a href="#l17.351"></a><span id="l17.351" class="difflineat">@@ -2288,17 +2285,17 @@ void nsImapServerResponseParser::capabil</span>
<a href="#l17.352"></a><span id="l17.352">       else if (token.Equals(&quot;MOVE&quot;, nsCaseInsensitiveCStringComparator()))</span>
<a href="#l17.353"></a><span id="l17.353">         fCapabilityFlag |= kHasMoveCapability;</span>
<a href="#l17.354"></a><span id="l17.354">       else if (token.Equals(&quot;HIGHESTMODSEQ&quot;, nsCaseInsensitiveCStringComparator()))</span>
<a href="#l17.355"></a><span id="l17.355">         fCapabilityFlag |= kHasHighestModSeqCapability;</span>
<a href="#l17.356"></a><span id="l17.356">     }</span>
<a href="#l17.357"></a><span id="l17.357">   } while (fNextToken &amp;&amp; endToken &lt; 0 &amp;&amp; !fAtEndOfLine &amp;&amp; ContinueParse());</span>
<a href="#l17.358"></a><span id="l17.358"> </span>
<a href="#l17.359"></a><span id="l17.359">   nsImapProtocol *navCon = &amp;fServerConnection;</span>
<a href="#l17.360"></a><span id="l17.360" class="difflineminus">-  NS_ASSERTION(navCon, &quot;null imap protocol connection while parsing capability response&quot;);	// we should always have this</span>
<a href="#l17.361"></a><span id="l17.361" class="difflineplus">+  NS_ASSERTION(navCon, &quot;null imap protocol connection while parsing capability response&quot;);  // we should always have this</span>
<a href="#l17.362"></a><span id="l17.362">   if (navCon)</span>
<a href="#l17.363"></a><span id="l17.363">     navCon-&gt;CommitCapability();</span>
<a href="#l17.364"></a><span id="l17.364">   skip_to_CRLF();</span>
<a href="#l17.365"></a><span id="l17.365"> }</span>
<a href="#l17.366"></a><span id="l17.366"> </span>
<a href="#l17.367"></a><span id="l17.367"> void nsImapServerResponseParser::xmailboxinfo_data()</span>
<a href="#l17.368"></a><span id="l17.368"> {</span>
<a href="#l17.369"></a><span id="l17.369">   AdvanceToNextToken();</span>
<a href="#l17.370"></a><span id="l17.370" class="difflineat">@@ -2388,123 +2385,122 @@ void nsImapServerResponseParser::authCha</span>
<a href="#l17.371"></a><span id="l17.371">   fWaitingForMoreClientInput = true;</span>
<a href="#l17.372"></a><span id="l17.372"> </span>
<a href="#l17.373"></a><span id="l17.373">   skip_to_CRLF();</span>
<a href="#l17.374"></a><span id="l17.374"> }</span>
<a href="#l17.375"></a><span id="l17.375"> </span>
<a href="#l17.376"></a><span id="l17.376"> </span>
<a href="#l17.377"></a><span id="l17.377"> void nsImapServerResponseParser::namespace_data()</span>
<a href="#l17.378"></a><span id="l17.378"> {</span>
<a href="#l17.379"></a><span id="l17.379" class="difflineminus">-	EIMAPNamespaceType namespaceType = kPersonalNamespace;</span>
<a href="#l17.380"></a><span id="l17.380" class="difflineminus">-	bool namespacesCommitted = false;</span>
<a href="#l17.381"></a><span id="l17.381" class="difflineplus">+  EIMAPNamespaceType namespaceType = kPersonalNamespace;</span>
<a href="#l17.382"></a><span id="l17.382" class="difflineplus">+  bool namespacesCommitted = false;</span>
<a href="#l17.383"></a><span id="l17.383">   const char* serverKey = fServerConnection.GetImapServerKey();</span>
<a href="#l17.384"></a><span id="l17.384" class="difflineminus">-	while ((namespaceType != kUnknownNamespace) &amp;&amp; ContinueParse())</span>
<a href="#l17.385"></a><span id="l17.385" class="difflineminus">-	{</span>
<a href="#l17.386"></a><span id="l17.386" class="difflineminus">-		AdvanceToNextToken();</span>
<a href="#l17.387"></a><span id="l17.387" class="difflineminus">-		while (fAtEndOfLine &amp;&amp; ContinueParse())</span>
<a href="#l17.388"></a><span id="l17.388" class="difflineminus">-			AdvanceToNextToken();</span>
<a href="#l17.389"></a><span id="l17.389" class="difflineminus">-		if (!PL_strcasecmp(fNextToken,&quot;NIL&quot;))</span>
<a href="#l17.390"></a><span id="l17.390" class="difflineminus">-		{</span>
<a href="#l17.391"></a><span id="l17.391" class="difflineminus">-			// No namespace for this type.</span>
<a href="#l17.392"></a><span id="l17.392" class="difflineminus">-			// Don't add anything to the Namespace object.</span>
<a href="#l17.393"></a><span id="l17.393" class="difflineminus">-		}</span>
<a href="#l17.394"></a><span id="l17.394" class="difflineminus">-		else if (fNextToken[0] == '(')</span>
<a href="#l17.395"></a><span id="l17.395" class="difflineminus">-		{</span>
<a href="#l17.396"></a><span id="l17.396" class="difflineminus">-			// There may be multiple namespaces of the same type.</span>
<a href="#l17.397"></a><span id="l17.397" class="difflineminus">-			// Go through each of them and add them to our Namespace object.</span>
<a href="#l17.398"></a><span id="l17.398" class="difflineplus">+  while ((namespaceType != kUnknownNamespace) &amp;&amp; ContinueParse())</span>
<a href="#l17.399"></a><span id="l17.399" class="difflineplus">+  {</span>
<a href="#l17.400"></a><span id="l17.400" class="difflineplus">+    AdvanceToNextToken();</span>
<a href="#l17.401"></a><span id="l17.401" class="difflineplus">+    while (fAtEndOfLine &amp;&amp; ContinueParse())</span>
<a href="#l17.402"></a><span id="l17.402" class="difflineplus">+      AdvanceToNextToken();</span>
<a href="#l17.403"></a><span id="l17.403" class="difflineplus">+    if (!PL_strcasecmp(fNextToken,&quot;NIL&quot;))</span>
<a href="#l17.404"></a><span id="l17.404" class="difflineplus">+    {</span>
<a href="#l17.405"></a><span id="l17.405" class="difflineplus">+      // No namespace for this type.</span>
<a href="#l17.406"></a><span id="l17.406" class="difflineplus">+      // Don't add anything to the Namespace object.</span>
<a href="#l17.407"></a><span id="l17.407" class="difflineplus">+    }</span>
<a href="#l17.408"></a><span id="l17.408" class="difflineplus">+    else if (fNextToken[0] == '(')</span>
<a href="#l17.409"></a><span id="l17.409" class="difflineplus">+    {</span>
<a href="#l17.410"></a><span id="l17.410" class="difflineplus">+      // There may be multiple namespaces of the same type.</span>
<a href="#l17.411"></a><span id="l17.411" class="difflineplus">+      // Go through each of them and add them to our Namespace object.</span>
<a href="#l17.412"></a><span id="l17.412"> </span>
<a href="#l17.413"></a><span id="l17.413" class="difflineminus">-			fNextToken++;</span>
<a href="#l17.414"></a><span id="l17.414" class="difflineminus">-			while (fNextToken[0] == '(' &amp;&amp; ContinueParse())</span>
<a href="#l17.415"></a><span id="l17.415" class="difflineminus">-			{</span>
<a href="#l17.416"></a><span id="l17.416" class="difflineminus">-				// we have another namespace for this namespace type</span>
<a href="#l17.417"></a><span id="l17.417" class="difflineminus">-				fNextToken++;</span>
<a href="#l17.418"></a><span id="l17.418" class="difflineminus">-				if (fNextToken[0] != '&quot;')</span>
<a href="#l17.419"></a><span id="l17.419" class="difflineminus">-				{</span>
<a href="#l17.420"></a><span id="l17.420" class="difflineminus">-					SetSyntaxError(true);</span>
<a href="#l17.421"></a><span id="l17.421" class="difflineminus">-				}</span>
<a href="#l17.422"></a><span id="l17.422" class="difflineminus">-				else</span>
<a href="#l17.423"></a><span id="l17.423" class="difflineminus">-				{</span>
<a href="#l17.424"></a><span id="l17.424" class="difflineminus">-					char *namespacePrefix = CreateQuoted(false);</span>
<a href="#l17.425"></a><span id="l17.425" class="difflineplus">+      fNextToken++;</span>
<a href="#l17.426"></a><span id="l17.426" class="difflineplus">+      while (fNextToken[0] == '(' &amp;&amp; ContinueParse())</span>
<a href="#l17.427"></a><span id="l17.427" class="difflineplus">+      {</span>
<a href="#l17.428"></a><span id="l17.428" class="difflineplus">+        // we have another namespace for this namespace type</span>
<a href="#l17.429"></a><span id="l17.429" class="difflineplus">+        fNextToken++;</span>
<a href="#l17.430"></a><span id="l17.430" class="difflineplus">+        if (fNextToken[0] != '&quot;')</span>
<a href="#l17.431"></a><span id="l17.431" class="difflineplus">+        {</span>
<a href="#l17.432"></a><span id="l17.432" class="difflineplus">+          SetSyntaxError(true);</span>
<a href="#l17.433"></a><span id="l17.433" class="difflineplus">+        }</span>
<a href="#l17.434"></a><span id="l17.434" class="difflineplus">+        else</span>
<a href="#l17.435"></a><span id="l17.435" class="difflineplus">+        {</span>
<a href="#l17.436"></a><span id="l17.436" class="difflineplus">+          char *namespacePrefix = CreateQuoted(false);</span>
<a href="#l17.437"></a><span id="l17.437"> </span>
<a href="#l17.438"></a><span id="l17.438" class="difflineminus">-					AdvanceToNextToken();</span>
<a href="#l17.439"></a><span id="l17.439" class="difflineminus">-					const char *quotedDelimiter = fNextToken;</span>
<a href="#l17.440"></a><span id="l17.440" class="difflineminus">-					char namespaceDelimiter = '\0';</span>
<a href="#l17.441"></a><span id="l17.441" class="difflineplus">+          AdvanceToNextToken();</span>
<a href="#l17.442"></a><span id="l17.442" class="difflineplus">+          const char *quotedDelimiter = fNextToken;</span>
<a href="#l17.443"></a><span id="l17.443" class="difflineplus">+          char namespaceDelimiter = '\0';</span>
<a href="#l17.444"></a><span id="l17.444"> </span>
<a href="#l17.445"></a><span id="l17.445" class="difflineminus">-					if (quotedDelimiter[0] == '&quot;')</span>
<a href="#l17.446"></a><span id="l17.446" class="difflineminus">-					{</span>
<a href="#l17.447"></a><span id="l17.447" class="difflineminus">-						quotedDelimiter++;</span>
<a href="#l17.448"></a><span id="l17.448" class="difflineminus">-						namespaceDelimiter = quotedDelimiter[0];</span>
<a href="#l17.449"></a><span id="l17.449" class="difflineminus">-					}</span>
<a href="#l17.450"></a><span id="l17.450" class="difflineminus">-					else if (!PL_strncasecmp(quotedDelimiter, &quot;NIL&quot;, 3))</span>
<a href="#l17.451"></a><span id="l17.451" class="difflineminus">-					{</span>
<a href="#l17.452"></a><span id="l17.452" class="difflineminus">-						// NIL hierarchy delimiter.  Leave namespace delimiter nullptr.</span>
<a href="#l17.453"></a><span id="l17.453" class="difflineminus">-					}</span>
<a href="#l17.454"></a><span id="l17.454" class="difflineminus">-					else</span>
<a href="#l17.455"></a><span id="l17.455" class="difflineminus">-					{</span>
<a href="#l17.456"></a><span id="l17.456" class="difflineminus">-						// not quoted or NIL.</span>
<a href="#l17.457"></a><span id="l17.457" class="difflineminus">-						SetSyntaxError(true);</span>
<a href="#l17.458"></a><span id="l17.458" class="difflineminus">-					}</span>
<a href="#l17.459"></a><span id="l17.459" class="difflineminus">-					if (ContinueParse())</span>
<a href="#l17.460"></a><span id="l17.460" class="difflineminus">-					{</span>
<a href="#l17.461"></a><span id="l17.461" class="difflineplus">+          if (quotedDelimiter[0] == '&quot;')</span>
<a href="#l17.462"></a><span id="l17.462" class="difflineplus">+          {</span>
<a href="#l17.463"></a><span id="l17.463" class="difflineplus">+            quotedDelimiter++;</span>
<a href="#l17.464"></a><span id="l17.464" class="difflineplus">+            namespaceDelimiter = quotedDelimiter[0];</span>
<a href="#l17.465"></a><span id="l17.465" class="difflineplus">+          }</span>
<a href="#l17.466"></a><span id="l17.466" class="difflineplus">+          else if (!PL_strncasecmp(quotedDelimiter, &quot;NIL&quot;, 3))</span>
<a href="#l17.467"></a><span id="l17.467" class="difflineplus">+          {</span>
<a href="#l17.468"></a><span id="l17.468" class="difflineplus">+            // NIL hierarchy delimiter.  Leave namespace delimiter nullptr.</span>
<a href="#l17.469"></a><span id="l17.469" class="difflineplus">+          }</span>
<a href="#l17.470"></a><span id="l17.470" class="difflineplus">+          else</span>
<a href="#l17.471"></a><span id="l17.471" class="difflineplus">+          {</span>
<a href="#l17.472"></a><span id="l17.472" class="difflineplus">+            // not quoted or NIL.</span>
<a href="#l17.473"></a><span id="l17.473" class="difflineplus">+            SetSyntaxError(true);</span>
<a href="#l17.474"></a><span id="l17.474" class="difflineplus">+          }</span>
<a href="#l17.475"></a><span id="l17.475" class="difflineplus">+          if (ContinueParse())</span>
<a href="#l17.476"></a><span id="l17.476" class="difflineplus">+          {</span>
<a href="#l17.477"></a><span id="l17.477">             // add code to parse the TRANSLATE attribute if it is present....</span>
<a href="#l17.478"></a><span id="l17.478">             // we'll also need to expand the name space code to take in the translated prefix name.</span>
<a href="#l17.479"></a><span id="l17.479"> </span>
<a href="#l17.480"></a><span id="l17.480" class="difflineminus">-						nsIMAPNamespace *newNamespace = new nsIMAPNamespace(namespaceType, namespacePrefix, namespaceDelimiter, false);</span>
<a href="#l17.481"></a><span id="l17.481" class="difflineminus">-						// add it to a temporary list in the host</span>
<a href="#l17.482"></a><span id="l17.482" class="difflineminus">-						if (newNamespace &amp;&amp; fHostSessionList)</span>
<a href="#l17.483"></a><span id="l17.483" class="difflineminus">-							fHostSessionList-&gt;AddNewNamespaceForHost(</span>
<a href="#l17.484"></a><span id="l17.484" class="difflineminus">-                                serverKey, newNamespace);</span>
<a href="#l17.485"></a><span id="l17.485" class="difflineplus">+            nsIMAPNamespace *newNamespace = new nsIMAPNamespace(namespaceType, namespacePrefix, namespaceDelimiter, false);</span>
<a href="#l17.486"></a><span id="l17.486" class="difflineplus">+            // add it to a temporary list in the host</span>
<a href="#l17.487"></a><span id="l17.487" class="difflineplus">+            if (newNamespace &amp;&amp; fHostSessionList)</span>
<a href="#l17.488"></a><span id="l17.488" class="difflineplus">+              fHostSessionList-&gt;AddNewNamespaceForHost(serverKey, newNamespace);</span>
<a href="#l17.489"></a><span id="l17.489"> </span>
<a href="#l17.490"></a><span id="l17.490" class="difflineminus">-						skip_to_close_paren();	// Ignore any extension data</span>
<a href="#l17.491"></a><span id="l17.491" class="difflineplus">+            skip_to_close_paren();  // Ignore any extension data</span>
<a href="#l17.492"></a><span id="l17.492"> </span>
<a href="#l17.493"></a><span id="l17.493" class="difflineminus">-						bool endOfThisNamespaceType = (fNextToken[0] == ')');</span>
<a href="#l17.494"></a><span id="l17.494" class="difflineminus">-						if (!endOfThisNamespaceType &amp;&amp; fNextToken[0] != '(')	// no space between namespaces of the same type</span>
<a href="#l17.495"></a><span id="l17.495" class="difflineminus">-						{</span>
<a href="#l17.496"></a><span id="l17.496" class="difflineminus">-							SetSyntaxError(true);</span>
<a href="#l17.497"></a><span id="l17.497" class="difflineminus">-						}</span>
<a href="#l17.498"></a><span id="l17.498" class="difflineminus">-					}</span>
<a href="#l17.499"></a><span id="l17.499" class="difflineminus">-					PR_Free(namespacePrefix);</span>
<a href="#l17.500"></a><span id="l17.500" class="difflineminus">-				}</span>
<a href="#l17.501"></a><span id="l17.501" class="difflineminus">-			}</span>
<a href="#l17.502"></a><span id="l17.502" class="difflineminus">-		}</span>
<a href="#l17.503"></a><span id="l17.503" class="difflineminus">-		else</span>
<a href="#l17.504"></a><span id="l17.504" class="difflineminus">-		{</span>
<a href="#l17.505"></a><span id="l17.505" class="difflineminus">-			SetSyntaxError(true);</span>
<a href="#l17.506"></a><span id="l17.506" class="difflineminus">-		}</span>
<a href="#l17.507"></a><span id="l17.507" class="difflineminus">-		switch (namespaceType)</span>
<a href="#l17.508"></a><span id="l17.508" class="difflineminus">-		{</span>
<a href="#l17.509"></a><span id="l17.509" class="difflineminus">-		case kPersonalNamespace:</span>
<a href="#l17.510"></a><span id="l17.510" class="difflineminus">-			namespaceType = kOtherUsersNamespace;</span>
<a href="#l17.511"></a><span id="l17.511" class="difflineminus">-			break;</span>
<a href="#l17.512"></a><span id="l17.512" class="difflineminus">-		case kOtherUsersNamespace:</span>
<a href="#l17.513"></a><span id="l17.513" class="difflineminus">-			namespaceType = kPublicNamespace;</span>
<a href="#l17.514"></a><span id="l17.514" class="difflineminus">-			break;</span>
<a href="#l17.515"></a><span id="l17.515" class="difflineminus">-		default:</span>
<a href="#l17.516"></a><span id="l17.516" class="difflineminus">-			namespaceType = kUnknownNamespace;</span>
<a href="#l17.517"></a><span id="l17.517" class="difflineminus">-			break;</span>
<a href="#l17.518"></a><span id="l17.518" class="difflineminus">-		}</span>
<a href="#l17.519"></a><span id="l17.519" class="difflineminus">-	}</span>
<a href="#l17.520"></a><span id="l17.520" class="difflineminus">-	if (ContinueParse())</span>
<a href="#l17.521"></a><span id="l17.521" class="difflineminus">-	{</span>
<a href="#l17.522"></a><span id="l17.522" class="difflineminus">-		nsImapProtocol *navCon = &amp;fServerConnection;</span>
<a href="#l17.523"></a><span id="l17.523" class="difflineminus">-		NS_ASSERTION(navCon, &quot;null protocol connection while parsing namespace&quot;);	// we should always have this</span>
<a href="#l17.524"></a><span id="l17.524" class="difflineminus">-		if (navCon)</span>
<a href="#l17.525"></a><span id="l17.525" class="difflineminus">-		{</span>
<a href="#l17.526"></a><span id="l17.526" class="difflineminus">-			navCon-&gt;CommitNamespacesForHostEvent();</span>
<a href="#l17.527"></a><span id="l17.527" class="difflineminus">-			namespacesCommitted = true;</span>
<a href="#l17.528"></a><span id="l17.528" class="difflineminus">-		}</span>
<a href="#l17.529"></a><span id="l17.529" class="difflineminus">-	}</span>
<a href="#l17.530"></a><span id="l17.530" class="difflineminus">-	skip_to_CRLF();</span>
<a href="#l17.531"></a><span id="l17.531" class="difflineplus">+            bool endOfThisNamespaceType = (fNextToken[0] == ')');</span>
<a href="#l17.532"></a><span id="l17.532" class="difflineplus">+            if (!endOfThisNamespaceType &amp;&amp; fNextToken[0] != '(')  // no space between namespaces of the same type</span>
<a href="#l17.533"></a><span id="l17.533" class="difflineplus">+            {</span>
<a href="#l17.534"></a><span id="l17.534" class="difflineplus">+              SetSyntaxError(true);</span>
<a href="#l17.535"></a><span id="l17.535" class="difflineplus">+            }</span>
<a href="#l17.536"></a><span id="l17.536" class="difflineplus">+          }</span>
<a href="#l17.537"></a><span id="l17.537" class="difflineplus">+          PR_Free(namespacePrefix);</span>
<a href="#l17.538"></a><span id="l17.538" class="difflineplus">+        }</span>
<a href="#l17.539"></a><span id="l17.539" class="difflineplus">+      }</span>
<a href="#l17.540"></a><span id="l17.540" class="difflineplus">+    }</span>
<a href="#l17.541"></a><span id="l17.541" class="difflineplus">+    else</span>
<a href="#l17.542"></a><span id="l17.542" class="difflineplus">+    {</span>
<a href="#l17.543"></a><span id="l17.543" class="difflineplus">+      SetSyntaxError(true);</span>
<a href="#l17.544"></a><span id="l17.544" class="difflineplus">+    }</span>
<a href="#l17.545"></a><span id="l17.545" class="difflineplus">+    switch (namespaceType)</span>
<a href="#l17.546"></a><span id="l17.546" class="difflineplus">+    {</span>
<a href="#l17.547"></a><span id="l17.547" class="difflineplus">+    case kPersonalNamespace:</span>
<a href="#l17.548"></a><span id="l17.548" class="difflineplus">+      namespaceType = kOtherUsersNamespace;</span>
<a href="#l17.549"></a><span id="l17.549" class="difflineplus">+      break;</span>
<a href="#l17.550"></a><span id="l17.550" class="difflineplus">+    case kOtherUsersNamespace:</span>
<a href="#l17.551"></a><span id="l17.551" class="difflineplus">+      namespaceType = kPublicNamespace;</span>
<a href="#l17.552"></a><span id="l17.552" class="difflineplus">+      break;</span>
<a href="#l17.553"></a><span id="l17.553" class="difflineplus">+    default:</span>
<a href="#l17.554"></a><span id="l17.554" class="difflineplus">+      namespaceType = kUnknownNamespace;</span>
<a href="#l17.555"></a><span id="l17.555" class="difflineplus">+      break;</span>
<a href="#l17.556"></a><span id="l17.556" class="difflineplus">+    }</span>
<a href="#l17.557"></a><span id="l17.557" class="difflineplus">+  }</span>
<a href="#l17.558"></a><span id="l17.558" class="difflineplus">+  if (ContinueParse())</span>
<a href="#l17.559"></a><span id="l17.559" class="difflineplus">+  {</span>
<a href="#l17.560"></a><span id="l17.560" class="difflineplus">+    nsImapProtocol *navCon = &amp;fServerConnection;</span>
<a href="#l17.561"></a><span id="l17.561" class="difflineplus">+    NS_ASSERTION(navCon, &quot;null protocol connection while parsing namespace&quot;);  // we should always have this</span>
<a href="#l17.562"></a><span id="l17.562" class="difflineplus">+    if (navCon)</span>
<a href="#l17.563"></a><span id="l17.563" class="difflineplus">+    {</span>
<a href="#l17.564"></a><span id="l17.564" class="difflineplus">+      navCon-&gt;CommitNamespacesForHostEvent();</span>
<a href="#l17.565"></a><span id="l17.565" class="difflineplus">+      namespacesCommitted = true;</span>
<a href="#l17.566"></a><span id="l17.566" class="difflineplus">+    }</span>
<a href="#l17.567"></a><span id="l17.567" class="difflineplus">+  }</span>
<a href="#l17.568"></a><span id="l17.568" class="difflineplus">+  skip_to_CRLF();</span>
<a href="#l17.569"></a><span id="l17.569"> </span>
<a href="#l17.570"></a><span id="l17.570" class="difflineminus">-	if (!namespacesCommitted &amp;&amp; fHostSessionList)</span>
<a href="#l17.571"></a><span id="l17.571" class="difflineminus">-	{</span>
<a href="#l17.572"></a><span id="l17.572" class="difflineminus">-		bool success;</span>
<a href="#l17.573"></a><span id="l17.573" class="difflineminus">-		fHostSessionList-&gt;FlushUncommittedNamespacesForHost(serverKey,</span>
<a href="#l17.574"></a><span id="l17.574" class="difflineplus">+  if (!namespacesCommitted &amp;&amp; fHostSessionList)</span>
<a href="#l17.575"></a><span id="l17.575" class="difflineplus">+  {</span>
<a href="#l17.576"></a><span id="l17.576" class="difflineplus">+    bool success;</span>
<a href="#l17.577"></a><span id="l17.577" class="difflineplus">+    fHostSessionList-&gt;FlushUncommittedNamespacesForHost(serverKey,</span>
<a href="#l17.578"></a><span id="l17.578">                                                             success);</span>
<a href="#l17.579"></a><span id="l17.579" class="difflineminus">-	}</span>
<a href="#l17.580"></a><span id="l17.580" class="difflineplus">+  }</span>
<a href="#l17.581"></a><span id="l17.581"> }</span>
<a href="#l17.582"></a><span id="l17.582"> </span>
<a href="#l17.583"></a><span id="l17.583"> void nsImapServerResponseParser::myrights_data(bool unsolicited)</span>
<a href="#l17.584"></a><span id="l17.584"> {</span>
<a href="#l17.585"></a><span id="l17.585">   AdvanceToNextToken();</span>
<a href="#l17.586"></a><span id="l17.586">   if (ContinueParse() &amp;&amp; !fAtEndOfLine)</span>
<a href="#l17.587"></a><span id="l17.587">   {</span>
<a href="#l17.588"></a><span id="l17.588">     char *mailboxName;</span>
<a href="#l17.589"></a><span id="l17.589" class="difflineat">@@ -2553,17 +2549,17 @@ void nsImapServerResponseParser::myright</span>
<a href="#l17.590"></a><span id="l17.590">   }</span>
<a href="#l17.591"></a><span id="l17.591"> }</span>
<a href="#l17.592"></a><span id="l17.592"> </span>
<a href="#l17.593"></a><span id="l17.593"> void nsImapServerResponseParser::acl_data()</span>
<a href="#l17.594"></a><span id="l17.594"> {</span>
<a href="#l17.595"></a><span id="l17.595">   AdvanceToNextToken();</span>
<a href="#l17.596"></a><span id="l17.596">   if (ContinueParse() &amp;&amp; !fAtEndOfLine)</span>
<a href="#l17.597"></a><span id="l17.597">   {</span>
<a href="#l17.598"></a><span id="l17.598" class="difflineminus">-    char *mailboxName = CreateAstring();	// PL_strdup(fNextToken);</span>
<a href="#l17.599"></a><span id="l17.599" class="difflineplus">+    char *mailboxName = CreateAstring();  // PL_strdup(fNextToken);</span>
<a href="#l17.600"></a><span id="l17.600">     if (mailboxName &amp;&amp; ContinueParse())</span>
<a href="#l17.601"></a><span id="l17.601">     {</span>
<a href="#l17.602"></a><span id="l17.602">       AdvanceToNextToken();</span>
<a href="#l17.603"></a><span id="l17.603">       while (ContinueParse() &amp;&amp; !fAtEndOfLine)</span>
<a href="#l17.604"></a><span id="l17.604">       {</span>
<a href="#l17.605"></a><span id="l17.605">         char *userName = CreateAstring(); // PL_strdup(fNextToken);</span>
<a href="#l17.606"></a><span id="l17.606">         if (userName &amp;&amp; ContinueParse())</span>
<a href="#l17.607"></a><span id="l17.607">         {</span>
<a href="#l17.608"></a><span id="l17.608" class="difflineat">@@ -2617,28 +2613,28 @@ void nsImapServerResponseParser::mime_he</span>
<a href="#l17.609"></a><span id="l17.609">     while (ContinueParse() &amp;&amp; end &amp;&amp; *end != 'M' &amp;&amp; *end != 'm')</span>
<a href="#l17.610"></a><span id="l17.610">     {</span>
<a href="#l17.611"></a><span id="l17.611">       end++;</span>
<a href="#l17.612"></a><span id="l17.612">     }</span>
<a href="#l17.613"></a><span id="l17.613">     if (end &amp;&amp; (*end == 'M' || *end == 'm'))</span>
<a href="#l17.614"></a><span id="l17.614">     {</span>
<a href="#l17.615"></a><span id="l17.615">       *(end-1) = 0;</span>
<a href="#l17.616"></a><span id="l17.616">       AdvanceToNextToken();</span>
<a href="#l17.617"></a><span id="l17.617" class="difflineminus">-      char *mimeHeaderData = CreateAstring();	// is it really this simple?</span>
<a href="#l17.618"></a><span id="l17.618" class="difflineplus">+      char *mimeHeaderData = CreateAstring();  // is it really this simple?</span>
<a href="#l17.619"></a><span id="l17.619">       AdvanceToNextToken();</span>
<a href="#l17.620"></a><span id="l17.620">       if (m_shell)</span>
<a href="#l17.621"></a><span id="l17.621">       {</span>
<a href="#l17.622"></a><span id="l17.622">         m_shell-&gt;AdoptMimeHeader(start, mimeHeaderData);</span>
<a href="#l17.623"></a><span id="l17.623">       }</span>
<a href="#l17.624"></a><span id="l17.624">     }</span>
<a href="#l17.625"></a><span id="l17.625">     else</span>
<a href="#l17.626"></a><span id="l17.626">     {</span>
<a href="#l17.627"></a><span id="l17.627">       SetSyntaxError(true);</span>
<a href="#l17.628"></a><span id="l17.628">     }</span>
<a href="#l17.629"></a><span id="l17.629" class="difflineminus">-    PR_Free(partNumber);	// partNumber is not adopted by the body shell.</span>
<a href="#l17.630"></a><span id="l17.630" class="difflineplus">+    PR_Free(partNumber);  // partNumber is not adopted by the body shell.</span>
<a href="#l17.631"></a><span id="l17.631">   }</span>
<a href="#l17.632"></a><span id="l17.632">   else</span>
<a href="#l17.633"></a><span id="l17.633">   {</span>
<a href="#l17.634"></a><span id="l17.634">     HandleMemoryFailure();</span>
<a href="#l17.635"></a><span id="l17.635">   }</span>
<a href="#l17.636"></a><span id="l17.636"> }</span>
<a href="#l17.637"></a><span id="l17.637"> </span>
<a href="#l17.638"></a><span id="l17.638"> // Actual mime parts are filled in on demand (either from shell generation</span>
<a href="#l17.639"></a><span id="l17.639" class="difflineat">@@ -2659,17 +2655,17 @@ void nsImapServerResponseParser::mime_pa</span>
<a href="#l17.640"></a><span id="l17.640">         *whereEnd = 0;</span>
<a href="#l17.641"></a><span id="l17.641">         whereStart++;</span>
<a href="#l17.642"></a><span id="l17.642">         origin = atoi(whereStart);</span>
<a href="#l17.643"></a><span id="l17.643">         originFound = true;</span>
<a href="#l17.644"></a><span id="l17.644">       }</span>
<a href="#l17.645"></a><span id="l17.645">     }</span>
<a href="#l17.646"></a><span id="l17.646">     PR_Free(checkOriginToken);</span>
<a href="#l17.647"></a><span id="l17.647">     AdvanceToNextToken();</span>
<a href="#l17.648"></a><span id="l17.648" class="difflineminus">-    msg_fetch_content(originFound, origin, MESSAGE_RFC822);	// keep content type as message/rfc822, even though the</span>
<a href="#l17.649"></a><span id="l17.649" class="difflineplus">+    msg_fetch_content(originFound, origin, MESSAGE_RFC822);  // keep content type as message/rfc822, even though the</span>
<a href="#l17.650"></a><span id="l17.650">     // MIME part might not be, because then libmime will</span>
<a href="#l17.651"></a><span id="l17.651">     // still handle and decode it.</span>
<a href="#l17.652"></a><span id="l17.652">   }</span>
<a href="#l17.653"></a><span id="l17.653">   else</span>
<a href="#l17.654"></a><span id="l17.654">     HandleMemoryFailure();</span>
<a href="#l17.655"></a><span id="l17.655"> }</span>
<a href="#l17.656"></a><span id="l17.656"> </span>
<a href="#l17.657"></a><span id="l17.657"> // parse FETCH BODYSTRUCTURE response, &quot;a parenthesized list that describes</span>
<a href="#l17.658"></a><span id="l17.658" class="difflineat">@@ -3047,17 +3043,17 @@ bool nsImapServerResponseParser::GetFill</span>
<a href="#l17.659"></a><span id="l17.659"> }</span>
<a href="#l17.660"></a><span id="l17.660"> </span>
<a href="#l17.661"></a><span id="l17.661"> bool nsImapServerResponseParser::GetDownloadingHeaders()</span>
<a href="#l17.662"></a><span id="l17.662"> {</span>
<a href="#l17.663"></a><span id="l17.663">   return fDownloadingHeaders;</span>
<a href="#l17.664"></a><span id="l17.664"> }</span>
<a href="#l17.665"></a><span id="l17.665"> </span>
<a href="#l17.666"></a><span id="l17.666"> // Tells the server state parser to use a previously cached shell.</span>
<a href="#l17.667"></a><span id="l17.667" class="difflineminus">-void	nsImapServerResponseParser::UseCachedShell(nsIMAPBodyShell *cachedShell)</span>
<a href="#l17.668"></a><span id="l17.668" class="difflineplus">+void nsImapServerResponseParser::UseCachedShell(nsIMAPBodyShell *cachedShell)</span>
<a href="#l17.669"></a><span id="l17.669"> {</span>
<a href="#l17.670"></a><span id="l17.670">   // We shouldn't already have another shell we're dealing with.</span>
<a href="#l17.671"></a><span id="l17.671">   if (m_shell &amp;&amp; cachedShell)</span>
<a href="#l17.672"></a><span id="l17.672">   {</span>
<a href="#l17.673"></a><span id="l17.673">     MOZ_LOG(IMAP, mozilla::LogLevel::Info, (&quot;PARSER: Shell Collision&quot;));</span>
<a href="#l17.674"></a><span id="l17.674">     NS_ASSERTION(false, &quot;shell collision&quot;);</span>
<a href="#l17.675"></a><span id="l17.675">   }</span>
<a href="#l17.676"></a><span id="l17.676">   m_shell = cachedShell;</span>
<a href="#l17.677"></a><span id="l17.677" class="difflineat">@@ -3238,17 +3234,17 @@ bool nsImapServerResponseParser::msg_fet</span>
<a href="#l17.678"></a><span id="l17.678">   return lastChunk;</span>
<a href="#l17.679"></a><span id="l17.679"> }</span>
<a href="#l17.680"></a><span id="l17.680"> </span>
<a href="#l17.681"></a><span id="l17.681"> bool nsImapServerResponseParser::CurrentFolderReadOnly()</span>
<a href="#l17.682"></a><span id="l17.682"> {</span>
<a href="#l17.683"></a><span id="l17.683">   return fCurrentFolderReadOnly;</span>
<a href="#l17.684"></a><span id="l17.684"> }</span>
<a href="#l17.685"></a><span id="l17.685"> </span>
<a href="#l17.686"></a><span id="l17.686" class="difflineminus">-int32_t	nsImapServerResponseParser::NumberOfMessages()</span>
<a href="#l17.687"></a><span id="l17.687" class="difflineplus">+int32_t nsImapServerResponseParser::NumberOfMessages()</span>
<a href="#l17.688"></a><span id="l17.688"> {</span>
<a href="#l17.689"></a><span id="l17.689">   return fNumberOfExistingMessages;</span>
<a href="#l17.690"></a><span id="l17.690"> }</span>
<a href="#l17.691"></a><span id="l17.691"> </span>
<a href="#l17.692"></a><span id="l17.692"> int32_t nsImapServerResponseParser::NumberOfRecentMessages()</span>
<a href="#l17.693"></a><span id="l17.693"> {</span>
<a href="#l17.694"></a><span id="l17.694">   return fNumberOfRecentMessages;</span>
<a href="#l17.695"></a><span id="l17.695"> }</span>
<a href="#l17.696"></a><span id="l17.696" class="difflineat">@@ -3299,34 +3295,34 @@ nsImapServerResponseParser::CreateCurren</span>
<a href="#l17.697"></a><span id="l17.697"> {</span>
<a href="#l17.698"></a><span id="l17.698">   RefPtr&lt;nsImapMailboxSpec&gt; returnSpec = new nsImapMailboxSpec;</span>
<a href="#l17.699"></a><span id="l17.699">   const char *mailboxNameToConvert = (mailboxName) ? mailboxName : fSelectedMailboxName;</span>
<a href="#l17.700"></a><span id="l17.700">   if (mailboxNameToConvert)</span>
<a href="#l17.701"></a><span id="l17.701">   {</span>
<a href="#l17.702"></a><span id="l17.702">     const char *serverKey = fServerConnection.GetImapServerKey();</span>
<a href="#l17.703"></a><span id="l17.703">     nsIMAPNamespace *ns = nullptr;</span>
<a href="#l17.704"></a><span id="l17.704">     if (serverKey &amp;&amp; fHostSessionList)</span>
<a href="#l17.705"></a><span id="l17.705" class="difflineminus">-      fHostSessionList-&gt;GetNamespaceForMailboxForHost(serverKey, mailboxNameToConvert, ns);	// for</span>
<a href="#l17.706"></a><span id="l17.706" class="difflineplus">+      fHostSessionList-&gt;GetNamespaceForMailboxForHost(serverKey, mailboxNameToConvert, ns);  // for</span>
<a href="#l17.707"></a><span id="l17.707">       // delimiter</span>
<a href="#l17.708"></a><span id="l17.708">     returnSpec-&gt;mHierarchySeparator = (ns) ? ns-&gt;GetDelimiter(): '/';</span>
<a href="#l17.709"></a><span id="l17.709"> </span>
<a href="#l17.710"></a><span id="l17.710">   }</span>
<a href="#l17.711"></a><span id="l17.711"> </span>
<a href="#l17.712"></a><span id="l17.712">   returnSpec-&gt;mFolderSelected = !mailboxName; // if mailboxName is null, we're doing a Status</span>
<a href="#l17.713"></a><span id="l17.713">   returnSpec-&gt;mFolder_UIDVALIDITY = fFolderUIDValidity;</span>
<a href="#l17.714"></a><span id="l17.714">   returnSpec-&gt;mHighestModSeq = fHighestModSeq;</span>
<a href="#l17.715"></a><span id="l17.715">   returnSpec-&gt;mNumOfMessages = (mailboxName) ? fStatusExistingMessages : fNumberOfExistingMessages;</span>
<a href="#l17.716"></a><span id="l17.716">   returnSpec-&gt;mNumOfUnseenMessages = (mailboxName) ? fStatusUnseenMessages : fNumberOfUnseenMessages;</span>
<a href="#l17.717"></a><span id="l17.717">   returnSpec-&gt;mNumOfRecentMessages = (mailboxName) ? fStatusRecentMessages : fNumberOfRecentMessages;</span>
<a href="#l17.718"></a><span id="l17.718">   returnSpec-&gt;mNextUID = fStatusNextUID;</span>
<a href="#l17.719"></a><span id="l17.719"> </span>
<a href="#l17.720"></a><span id="l17.720">   returnSpec-&gt;mSupportedUserFlags = fSupportsUserDefinedFlags;</span>
<a href="#l17.721"></a><span id="l17.721"> </span>
<a href="#l17.722"></a><span id="l17.722" class="difflineminus">-  returnSpec-&gt;mBoxFlags = kNoFlags;	// stub</span>
<a href="#l17.723"></a><span id="l17.723" class="difflineminus">-  returnSpec-&gt;mOnlineVerified = false;	// we're fabricating this.  The flags aren't verified.</span>
<a href="#l17.724"></a><span id="l17.724" class="difflineplus">+  returnSpec-&gt;mBoxFlags = kNoFlags;  // stub</span>
<a href="#l17.725"></a><span id="l17.725" class="difflineplus">+  returnSpec-&gt;mOnlineVerified = false;  // we're fabricating this.  The flags aren't verified.</span>
<a href="#l17.726"></a><span id="l17.726">   returnSpec-&gt;mAllocatedPathName.Assign(mailboxNameToConvert);</span>
<a href="#l17.727"></a><span id="l17.727">   returnSpec-&gt;mConnection = &amp;fServerConnection;</span>
<a href="#l17.728"></a><span id="l17.728">   if (returnSpec-&gt;mConnection)</span>
<a href="#l17.729"></a><span id="l17.729">   {</span>
<a href="#l17.730"></a><span id="l17.730">     nsIURI * aUrl = nullptr;</span>
<a href="#l17.731"></a><span id="l17.731">     nsresult rv = NS_OK;</span>
<a href="#l17.732"></a><span id="l17.732">     returnSpec-&gt;mConnection-&gt;GetCurrentUrl()-&gt;QueryInterface(NS_GET_IID(nsIURI), (void **) &amp;aUrl);</span>
<a href="#l17.733"></a><span id="l17.733">     if (NS_SUCCEEDED(rv) &amp;&amp; aUrl)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/mailnews/imap/src/nsImapServerResponseParser.h</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapServerResponseParser.h</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -105,17 +105,17 @@ public:</span>
<a href="#l18.4"></a><span id="l18.4">   nsCString &amp;GetServerID() {return fServerIdResponse;}</span>
<a href="#l18.5"></a><span id="l18.5"> </span>
<a href="#l18.6"></a><span id="l18.6">   // Call this when adding a pipelined command to the session</span>
<a href="#l18.7"></a><span id="l18.7">   void IncrementNumberOfTaggedResponsesExpected(const char *newExpectedTag);</span>
<a href="#l18.8"></a><span id="l18.8"> </span>
<a href="#l18.9"></a><span id="l18.9">   // Interrupt a Fetch, without really Interrupting (through netlib)</span>
<a href="#l18.10"></a><span id="l18.10">   bool GetLastFetchChunkReceived();</span>
<a href="#l18.11"></a><span id="l18.11">   void ClearLastFetchChunkReceived();</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineminus">-  virtual uint16_t	SupportsUserFlags() { return fSupportsUserDefinedFlags; }</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+  virtual uint16_t SupportsUserFlags() { return fSupportsUserDefinedFlags; }</span>
<a href="#l18.14"></a><span id="l18.14">   virtual uint16_t  SettablePermanentFlags() { return fSettablePermanentFlags;}</span>
<a href="#l18.15"></a><span id="l18.15">   void SetFlagState(nsIImapFlagAndUidState *state);</span>
<a href="#l18.16"></a><span id="l18.16">   bool GetDownloadingHeaders();</span>
<a href="#l18.17"></a><span id="l18.17">   bool GetFillingInShell();</span>
<a href="#l18.18"></a><span id="l18.18">   void UseCachedShell(nsIMAPBodyShell *cachedShell);</span>
<a href="#l18.19"></a><span id="l18.19">   void SetHostSessionList(nsIImapHostSessionList *aHostSession);</span>
<a href="#l18.20"></a><span id="l18.20">   char  *fAuthChallenge;    // the challenge returned by the server in</span>
<a href="#l18.21"></a><span id="l18.21">                             //response to authenticate using CRAM-MD5 or NTLM</span>
<a href="#l18.22"></a><span id="l18.22" class="difflineat">@@ -224,17 +224,17 @@ private:</span>
<a href="#l18.23"></a><span id="l18.23">   char              *fCurrentCommandTag;</span>
<a href="#l18.24"></a><span id="l18.24"> </span>
<a href="#l18.25"></a><span id="l18.25">   nsCString         fZeroLengthMessageUidString;</span>
<a href="#l18.26"></a><span id="l18.26"> </span>
<a href="#l18.27"></a><span id="l18.27">   char              *fSelectedMailboxName;</span>
<a href="#l18.28"></a><span id="l18.28"> </span>
<a href="#l18.29"></a><span id="l18.29">   nsImapSearchResultSequence    *fSearchResults;</span>
<a href="#l18.30"></a><span id="l18.30"> </span>
<a href="#l18.31"></a><span id="l18.31" class="difflineminus">-  nsCOMPtr &lt;nsIImapFlagAndUidState&gt; fFlagState;		// NOT owned by us, it's a copy, do not destroy</span>
<a href="#l18.32"></a><span id="l18.32" class="difflineplus">+  nsCOMPtr &lt;nsIImapFlagAndUidState&gt; fFlagState;  // NOT owned by us, it's a copy, do not destroy</span>
<a href="#l18.33"></a><span id="l18.33"> </span>
<a href="#l18.34"></a><span id="l18.34">   eIMAPstate               fIMAPstate;</span>
<a href="#l18.35"></a><span id="l18.35"> </span>
<a href="#l18.36"></a><span id="l18.36">   eIMAPCapabilityFlags      fCapabilityFlag;</span>
<a href="#l18.37"></a><span id="l18.37">   nsCString     fMailAccountUrl;</span>
<a href="#l18.38"></a><span id="l18.38">   char          *fNetscapeServerVersionString;</span>
<a href="#l18.39"></a><span id="l18.39">   char          *fXSenderInfo; /* changed per message download */</span>
<a href="#l18.40"></a><span id="l18.40">   char          *fLastAlert; /* used to avoid displaying the same alert over and over */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/mailnews/imap/src/nsImapUtils.h</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapUtils.h</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -62,15 +62,15 @@ public:</span>
<a href="#l19.4"></a><span id="l19.4">   nsCString mAllocatedPathName;</span>
<a href="#l19.5"></a><span id="l19.5">   nsCString mHostName;</span>
<a href="#l19.6"></a><span id="l19.6">   nsString  mUnicharPathName;</span>
<a href="#l19.7"></a><span id="l19.7">   char      mHierarchySeparator;</span>
<a href="#l19.8"></a><span id="l19.8">   bool      mFolderSelected;</span>
<a href="#l19.9"></a><span id="l19.9">   bool      mDiscoveredFromLsub;</span>
<a href="#l19.10"></a><span id="l19.10">   bool      mOnlineVerified;</span>
<a href="#l19.11"></a><span id="l19.11"> </span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-  nsImapProtocol *mConnection;	// do we need this? It seems evil</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+  nsImapProtocol *mConnection;  // do we need this? It seems evil</span>
<a href="#l19.14"></a><span id="l19.14"> </span>
<a href="#l19.15"></a><span id="l19.15"> private:</span>
<a href="#l19.16"></a><span id="l19.16">   virtual ~nsImapMailboxSpec();</span>
<a href="#l19.17"></a><span id="l19.17"> };</span>
<a href="#l19.18"></a><span id="l19.18"> </span>
<a href="#l19.19"></a><span id="l19.19"> #endif //NS_IMAPUTILS_H</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/mailnews/imap/test/unit/head_server.js</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/mailnews/imap/test/unit/head_server.js</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -47,17 +47,17 @@ function makeServer(daemon, infoString, </span>
<a href="#l20.4"></a><span id="l20.4">   }</span>
<a href="#l20.5"></a><span id="l20.5">   var server = new nsMailServer(createHandler, daemon);</span>
<a href="#l20.6"></a><span id="l20.6">   server.start();</span>
<a href="#l20.7"></a><span id="l20.7">   return server;</span>
<a href="#l20.8"></a><span id="l20.8"> }</span>
<a href="#l20.9"></a><span id="l20.9"> </span>
<a href="#l20.10"></a><span id="l20.10"> function createLocalIMAPServer(port, hostname=&quot;localhost&quot;) {</span>
<a href="#l20.11"></a><span id="l20.11">   let server = localAccountUtils.create_incoming_server(&quot;imap&quot;, port,</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineminus">-							&quot;user&quot;, &quot;password&quot;, hostname);</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+    &quot;user&quot;, &quot;password&quot;, hostname);</span>
<a href="#l20.14"></a><span id="l20.14">   server.QueryInterface(Ci.nsIImapIncomingServer);</span>
<a href="#l20.15"></a><span id="l20.15">   return server;</span>
<a href="#l20.16"></a><span id="l20.16"> }</span>
<a href="#l20.17"></a><span id="l20.17"> </span>
<a href="#l20.18"></a><span id="l20.18"> // &lt;copied from=&quot;head_maillocal.js&quot;&gt;</span>
<a href="#l20.19"></a><span id="l20.19"> /**</span>
<a href="#l20.20"></a><span id="l20.20">  * @param fromServer server.playTransaction</span>
<a href="#l20.21"></a><span id="l20.21">  * @param expected [&quot;command&quot;, &quot;command&quot;, ...]</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/mailnews/imap/test/unit/test_bug460636.js</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/mailnews/imap/test/unit/test_bug460636.js</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -55,17 +55,17 @@ function* setup() {</span>
<a href="#l21.4"></a><span id="l21.4">   gIMAPService.SaveMessageToDisk(&quot;imap-message://user@localhost/INBOX#&quot;</span>
<a href="#l21.5"></a><span id="l21.5">                                  + (IMAPPump.mailbox.uidnext-1), gSavedMsgFile,</span>
<a href="#l21.6"></a><span id="l21.6">                                  false, asyncUrlListener, {}, true, null);</span>
<a href="#l21.7"></a><span id="l21.7">   yield false;</span>
<a href="#l21.8"></a><span id="l21.8"> }</span>
<a href="#l21.9"></a><span id="l21.9"> </span>
<a href="#l21.10"></a><span id="l21.10"> function checkSavedMessage() {</span>
<a href="#l21.11"></a><span id="l21.11">   Assert.equal(IOUtils.loadFileToString(gMsgFile),</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-	      IOUtils.loadFileToString(gSavedMsgFile));</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+  IOUtils.loadFileToString(gSavedMsgFile));</span>
<a href="#l21.14"></a><span id="l21.14"> }</span>
<a href="#l21.15"></a><span id="l21.15"> </span>
<a href="#l21.16"></a><span id="l21.16"> function teardown() {</span>
<a href="#l21.17"></a><span id="l21.17">   try {</span>
<a href="#l21.18"></a><span id="l21.18">     gSavedMsgFile.remove(false);</span>
<a href="#l21.19"></a><span id="l21.19">   }</span>
<a href="#l21.20"></a><span id="l21.20">   catch (ex) {</span>
<a href="#l21.21"></a><span id="l21.21">     dump(ex);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/mailnews/imap/test/unit/test_imapChunks.js</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/mailnews/imap/test/unit/test_imapChunks.js</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -105,17 +105,17 @@ var UrlListener =</span>
<a href="#l22.4"></a><span id="l22.4">   OnStartRunningUrl: function(url) { },</span>
<a href="#l22.5"></a><span id="l22.5">   OnStopRunningUrl: function(url, rc)</span>
<a href="#l22.6"></a><span id="l22.6">   {</span>
<a href="#l22.7"></a><span id="l22.7">     // operation succeeded</span>
<a href="#l22.8"></a><span id="l22.8">     Assert.equal(rc, 0);</span>
<a href="#l22.9"></a><span id="l22.9"> </span>
<a href="#l22.10"></a><span id="l22.10">     // File contents were not modified</span>
<a href="#l22.11"></a><span id="l22.11">     Assert.equal(IOUtils.loadFileToString(gMsgFile),</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineminus">-		IOUtils.loadFileToString(gSavedMsgFile));</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+    IOUtils.loadFileToString(gSavedMsgFile));</span>
<a href="#l22.14"></a><span id="l22.14"> </span>
<a href="#l22.15"></a><span id="l22.15">     // The file doesn't get closed straight away, but does after a little bit.</span>
<a href="#l22.16"></a><span id="l22.16">     // So wait, and then remove it. We need to test this to ensure we don't</span>
<a href="#l22.17"></a><span id="l22.17">     // indefinitely lock the file.</span>
<a href="#l22.18"></a><span id="l22.18">     do_timeout(1000, endTest);</span>
<a href="#l22.19"></a><span id="l22.19">   }</span>
<a href="#l22.20"></a><span id="l22.20"> };</span>
<a href="#l22.21"></a><span id="l22.21"> </span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

