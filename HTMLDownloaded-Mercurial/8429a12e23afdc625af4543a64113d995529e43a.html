<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/4b0de666d1a4/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/4b0de666d1a4/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/4b0de666d1a4/mercurial.js"></script>

<meta property="og:image" content="/static/4b0de666d1a4/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 25242:8429a12e23afdc625af4543a64113d995529e43a</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 8429a12e23afdc625af4543a64113d995529e43a" />
<meta property="og:url" content="/comm-central/rev/8429a12e23afdc625af4543a64113d995529e43a" />
<meta property="og:description" content="Bug 1364645 - Replace Task.async()/Task.spawn() with async function and yield with await. r=florian" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/4b0de666d1a4/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 8429a12e23afdc625af4543a64113d995529e43a 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/8429a12e23afdc625af4543a64113d995529e43a">shortlog</a> |
<a href="/comm-central/log/8429a12e23afdc625af4543a64113d995529e43a">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/8429a12e23afdc625af4543a64113d995529e43a">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/8429a12e23afdc625af4543a64113d995529e43a">files</a> |
changeset |
<a href="/comm-central/raw-rev/8429a12e23afdc625af4543a64113d995529e43a">raw</a>  | <a href="/comm-central/archive/8429a12e23afdc625af4543a64113d995529e43a.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1364645">Bug 1364645</a> - Replace Task.async()/Task.spawn() with async function and yield with await. r=florian
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#74;&#111;&#114;&#103;&#32;&#75;&#32;&#60;&#106;&#111;&#114;&#103;&#107;&#64;&#106;&#111;&#114;&#103;&#107;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Wed, 21 Nov 2018 13:16:01 +0100</td></tr>

<tr>
 <td>changeset 25242</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/8429a12e23afdc625af4543a64113d995529e43a">8429a12e23afdc625af4543a64113d995529e43a</a></td>
</tr>



<tr>
<td>parent 25241</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/b31bf692d3a11c36a1f25bd6798f9fd6eea2b618">b31bf692d3a11c36a1f25bd6798f9fd6eea2b618</a>
</td>
</tr>

<tr>
<td>child 25243</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/aa31b79e0b50b35696312451bb25664b3e998a81">aa31b79e0b50b35696312451bb25664b3e998a81</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=8429a12e23afdc625af4543a64113d995529e43a">15149</a></td></tr>
<tr><td>push user</td><td>mozilla@jorgk.com</td></tr>
<tr><td>push date</td><td class="date age">Wed, 21 Nov 2018 16:41:27 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@8429a12e23af [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=8429a12e23afdc625af4543a64113d995529e43a">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=8429a12e23afdc625af4543a64113d995529e43a&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=8429a12e23afdc625af4543a64113d995529e43a&newProject=comm-central&newRevision=8429a12e23afdc625af4543a64113d995529e43a&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=8429a12e23afdc625af4543a64113d995529e43a&newProject=comm-central&newRevision=8429a12e23afdc625af4543a64113d995529e43a&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=8429a12e23afdc625af4543a64113d995529e43a&newProject=comm-central&newRevision=8429a12e23afdc625af4543a64113d995529e43a&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28florian%29&revcount=50">florian</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1364645">1364645</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1364645">Bug 1364645</a> - Replace Task.async()/Task.spawn() with async function and yield with await. r=florian</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/8429a12e23afdc625af4543a64113d995529e43a/chat/components/src/logger.js">chat/components/src/logger.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/8429a12e23afdc625af4543a64113d995529e43a/chat/components/src/logger.js">file</a> |
<a href="/comm-central/annotate/8429a12e23afdc625af4543a64113d995529e43a/chat/components/src/logger.js">annotate</a> |
<a href="/comm-central/diff/8429a12e23afdc625af4543a64113d995529e43a/chat/components/src/logger.js">diff</a> |
<a href="/comm-central/comparison/8429a12e23afdc625af4543a64113d995529e43a/chat/components/src/logger.js">comparison</a> |
<a href="/comm-central/log/8429a12e23afdc625af4543a64113d995529e43a/chat/components/src/logger.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/8429a12e23afdc625af4543a64113d995529e43a/chat/protocols/irc/ircCommands.jsm">chat/protocols/irc/ircCommands.jsm</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/8429a12e23afdc625af4543a64113d995529e43a/chat/protocols/irc/ircCommands.jsm">file</a> |
<a href="/comm-central/annotate/8429a12e23afdc625af4543a64113d995529e43a/chat/protocols/irc/ircCommands.jsm">annotate</a> |
<a href="/comm-central/diff/8429a12e23afdc625af4543a64113d995529e43a/chat/protocols/irc/ircCommands.jsm">diff</a> |
<a href="/comm-central/comparison/8429a12e23afdc625af4543a64113d995529e43a/chat/protocols/irc/ircCommands.jsm">comparison</a> |
<a href="/comm-central/log/8429a12e23afdc625af4543a64113d995529e43a/chat/protocols/irc/ircCommands.jsm">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/8429a12e23afdc625af4543a64113d995529e43a/mail/components/im/modules/index_im.jsm">mail/components/im/modules/index_im.jsm</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/8429a12e23afdc625af4543a64113d995529e43a/mail/components/im/modules/index_im.jsm">file</a> |
<a href="/comm-central/annotate/8429a12e23afdc625af4543a64113d995529e43a/mail/components/im/modules/index_im.jsm">annotate</a> |
<a href="/comm-central/diff/8429a12e23afdc625af4543a64113d995529e43a/mail/components/im/modules/index_im.jsm">diff</a> |
<a href="/comm-central/comparison/8429a12e23afdc625af4543a64113d995529e43a/mail/components/im/modules/index_im.jsm">comparison</a> |
<a href="/comm-central/log/8429a12e23afdc625af4543a64113d995529e43a/mail/components/im/modules/index_im.jsm">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/chat/components/src/logger.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/chat/components/src/logger.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -5,17 +5,16 @@</span>
<a href="#l1.4"></a><span id="l1.4"> var CC = Components.Constructor;</span>
<a href="#l1.5"></a><span id="l1.5"> </span>
<a href="#l1.6"></a><span id="l1.6"> ChromeUtils.import(&quot;resource:///modules/hiddenWindow.jsm&quot;);</span>
<a href="#l1.7"></a><span id="l1.7"> ChromeUtils.import(&quot;resource:///modules/imServices.jsm&quot;);</span>
<a href="#l1.8"></a><span id="l1.8"> ChromeUtils.import(&quot;resource:///modules/imXPCOMUtils.jsm&quot;);</span>
<a href="#l1.9"></a><span id="l1.9"> ChromeUtils.import(&quot;resource:///modules/jsProtoHelper.jsm&quot;);</span>
<a href="#l1.10"></a><span id="l1.10"> ChromeUtils.import(&quot;resource:///modules/ToLocaleFormat.jsm&quot;);</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-ChromeUtils.import(&quot;resource://gre/modules/Task.jsm&quot;)</span>
<a href="#l1.13"></a><span id="l1.13"> ChromeUtils.defineModuleGetter(this, &quot;OS&quot;, &quot;resource://gre/modules/osfile.jsm&quot;);</span>
<a href="#l1.14"></a><span id="l1.14"> </span>
<a href="#l1.15"></a><span id="l1.15"> XPCOMUtils.defineLazyGetter(this, &quot;_&quot;, () =&gt;</span>
<a href="#l1.16"></a><span id="l1.16">   l10nHelper(&quot;chrome://chat/locale/logger.properties&quot;)</span>
<a href="#l1.17"></a><span id="l1.17"> );</span>
<a href="#l1.18"></a><span id="l1.18"> </span>
<a href="#l1.19"></a><span id="l1.19"> var kLineBreak = &quot;@mozilla.org/windows-registry-key;1&quot; in Cc ? &quot;\r\n&quot; : &quot;\n&quot;;</span>
<a href="#l1.20"></a><span id="l1.20"> </span>
<a href="#l1.21"></a><span id="l1.21" class="difflineat">@@ -52,47 +51,47 @@ function queueFileOperation(aPath, aOper</span>
<a href="#l1.22"></a><span id="l1.22">  * the I/O operations reject, the returned promise will reject with the same reason.</span>
<a href="#l1.23"></a><span id="l1.23">  * We open the file, append, and close it immediately. The alternative is to keep</span>
<a href="#l1.24"></a><span id="l1.24">  * it open and append as required, but we want to make sure we don't open a file</span>
<a href="#l1.25"></a><span id="l1.25">  * for reading while it's already open for writing, so we close it every time</span>
<a href="#l1.26"></a><span id="l1.26">  * (opening a file multiple times concurrently may fail on Windows).</span>
<a href="#l1.27"></a><span id="l1.27">  * Note: This function creates parent directories if required.</span>
<a href="#l1.28"></a><span id="l1.28">  */</span>
<a href="#l1.29"></a><span id="l1.29"> function appendToFile(aPath, aEncodedString, aCreate) {</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineminus">-  return queueFileOperation(aPath, Task.async(function* () {</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineminus">-    yield OS.File.makeDir(OS.Path.dirname(aPath),</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+  return queueFileOperation(aPath, async function () {</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineplus">+    await OS.File.makeDir(OS.Path.dirname(aPath),</span>
<a href="#l1.34"></a><span id="l1.34">                           {ignoreExisting: true, from: OS.Constants.Path.profileDir});</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineminus">-    let file = yield OS.File.open(aPath, {write: true, create: aCreate});</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineplus">+    let file = await OS.File.open(aPath, {write: true, create: aCreate});</span>
<a href="#l1.37"></a><span id="l1.37">     try {</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineminus">-      yield file.write(aEncodedString);</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineplus">+      await file.write(aEncodedString);</span>
<a href="#l1.40"></a><span id="l1.40">     }</span>
<a href="#l1.41"></a><span id="l1.41">     finally {</span>
<a href="#l1.42"></a><span id="l1.42">       /*</span>
<a href="#l1.43"></a><span id="l1.43">        * If both the write() above and the close() below throw, and we don't</span>
<a href="#l1.44"></a><span id="l1.44">        * handle the close error here, the promise will be rejected with the close</span>
<a href="#l1.45"></a><span id="l1.45">        * error and the write error will be dropped. To avoid this, we log any</span>
<a href="#l1.46"></a><span id="l1.46">        * close error here so that any write error will be propagated.</span>
<a href="#l1.47"></a><span id="l1.47">        */</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineminus">-      yield file.close().catch(Cu.reportError);</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineplus">+      await file.close().catch(Cu.reportError);</span>
<a href="#l1.50"></a><span id="l1.50">     }</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineminus">-  }));</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineplus">+  });</span>
<a href="#l1.53"></a><span id="l1.53"> }</span>
<a href="#l1.54"></a><span id="l1.54"> </span>
<a href="#l1.55"></a><span id="l1.55"> OS.File.profileBeforeChange.addBlocker(</span>
<a href="#l1.56"></a><span id="l1.56">   &quot;Chat logger: writing all pending messages&quot;,</span>
<a href="#l1.57"></a><span id="l1.57" class="difflineminus">-  Task.async(function* () {</span>
<a href="#l1.58"></a><span id="l1.58" class="difflineplus">+  async function () {</span>
<a href="#l1.59"></a><span id="l1.59">     for (let promise of gFilePromises.values()) {</span>
<a href="#l1.60"></a><span id="l1.60">       try {</span>
<a href="#l1.61"></a><span id="l1.61" class="difflineminus">-        yield promise;</span>
<a href="#l1.62"></a><span id="l1.62" class="difflineplus">+        await promise;</span>
<a href="#l1.63"></a><span id="l1.63">       }</span>
<a href="#l1.64"></a><span id="l1.64">       catch (aError) {</span>
<a href="#l1.65"></a><span id="l1.65">         // Ignore the error, whatever queued the operation will take care of it.</span>
<a href="#l1.66"></a><span id="l1.66">       }</span>
<a href="#l1.67"></a><span id="l1.67">     }</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineminus">-  })</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineplus">+  }</span>
<a href="#l1.70"></a><span id="l1.70"> );</span>
<a href="#l1.71"></a><span id="l1.71"> </span>
<a href="#l1.72"></a><span id="l1.72"> </span>
<a href="#l1.73"></a><span id="l1.73"> // This function checks names against OS naming conventions and alters them</span>
<a href="#l1.74"></a><span id="l1.74"> // accordingly so that they can be used as file/folder names.</span>
<a href="#l1.75"></a><span id="l1.75"> function encodeName(aName) {</span>
<a href="#l1.76"></a><span id="l1.76">   // Reserved device names by Windows (prefixing &quot;%&quot;).</span>
<a href="#l1.77"></a><span id="l1.77">   let reservedNames = /^(CON|PRN|AUX|NUL|COM\d|LPT\d)$/i;</span>
<a href="#l1.78"></a><span id="l1.78" class="difflineat">@@ -525,34 +524,34 @@ function Log(aEntries) {</span>
<a href="#l1.79"></a><span id="l1.79">   // quickly determine which directory a log file is from.  We'll use</span>
<a href="#l1.80"></a><span id="l1.80">   // the first file's path.</span>
<a href="#l1.81"></a><span id="l1.81">   this.path = aEntries[0].path;</span>
<a href="#l1.82"></a><span id="l1.82"> }</span>
<a href="#l1.83"></a><span id="l1.83"> Log.prototype = {</span>
<a href="#l1.84"></a><span id="l1.84">   __proto__: ClassInfo(&quot;imILog&quot;, &quot;Log object&quot;),</span>
<a href="#l1.85"></a><span id="l1.85">   _entryPaths: null,</span>
<a href="#l1.86"></a><span id="l1.86">   format: &quot;json&quot;,</span>
<a href="#l1.87"></a><span id="l1.87" class="difflineminus">-  getConversation: Task.async(function* () {</span>
<a href="#l1.88"></a><span id="l1.88" class="difflineplus">+  async getConversation() {</span>
<a href="#l1.89"></a><span id="l1.89">     /*</span>
<a href="#l1.90"></a><span id="l1.90">      * Read the set of log files asynchronously and return a promise that</span>
<a href="#l1.91"></a><span id="l1.91">      * resolves to a LogConversation instance. Even if a file contains some</span>
<a href="#l1.92"></a><span id="l1.92">      * junk (invalid JSON), messages that are valid will be read. If the first</span>
<a href="#l1.93"></a><span id="l1.93">      * line of metadata is corrupt however, the data isn't useful and the</span>
<a href="#l1.94"></a><span id="l1.94">      * promise will resolve to null.</span>
<a href="#l1.95"></a><span id="l1.95">      */</span>
<a href="#l1.96"></a><span id="l1.96">     if (this.format != &quot;json&quot;)</span>
<a href="#l1.97"></a><span id="l1.97">       return null;</span>
<a href="#l1.98"></a><span id="l1.98">     let messages = [];</span>
<a href="#l1.99"></a><span id="l1.99">     let properties = {};</span>
<a href="#l1.100"></a><span id="l1.100">     let firstFile = true;</span>
<a href="#l1.101"></a><span id="l1.101">     let decoder = new TextDecoder();</span>
<a href="#l1.102"></a><span id="l1.102">     for (let path of this._entryPaths) {</span>
<a href="#l1.103"></a><span id="l1.103">       let lines;</span>
<a href="#l1.104"></a><span id="l1.104">       try {</span>
<a href="#l1.105"></a><span id="l1.105" class="difflineminus">-        let contents = yield queueFileOperation(path, () =&gt; OS.File.read(path));</span>
<a href="#l1.106"></a><span id="l1.106" class="difflineplus">+        let contents = await queueFileOperation(path, () =&gt; OS.File.read(path));</span>
<a href="#l1.107"></a><span id="l1.107">         lines = decoder.decode(contents).split(&quot;\n&quot;);</span>
<a href="#l1.108"></a><span id="l1.108">       } catch (aError) {</span>
<a href="#l1.109"></a><span id="l1.109">         Cu.reportError(&quot;Error reading log file \&quot;&quot; + path + &quot;\&quot;:\n&quot; + aError);</span>
<a href="#l1.110"></a><span id="l1.110">         continue;</span>
<a href="#l1.111"></a><span id="l1.111">       }</span>
<a href="#l1.112"></a><span id="l1.112">       let nextLine = lines.shift();</span>
<a href="#l1.113"></a><span id="l1.113">       let filename = OS.Path.basename(path);</span>
<a href="#l1.114"></a><span id="l1.114"> </span>
<a href="#l1.115"></a><span id="l1.115" class="difflineat">@@ -602,17 +601,17 @@ Log.prototype = {</span>
<a href="#l1.116"></a><span id="l1.116">         }</span>
<a href="#l1.117"></a><span id="l1.117">       }</span>
<a href="#l1.118"></a><span id="l1.118">     }</span>
<a href="#l1.119"></a><span id="l1.119"> </span>
<a href="#l1.120"></a><span id="l1.120">     if (firstFile) // All selected log files are invalid.</span>
<a href="#l1.121"></a><span id="l1.121">       return null;</span>
<a href="#l1.122"></a><span id="l1.122"> </span>
<a href="#l1.123"></a><span id="l1.123">     return new LogConversation(messages, properties);</span>
<a href="#l1.124"></a><span id="l1.124" class="difflineminus">-  })</span>
<a href="#l1.125"></a><span id="l1.125" class="difflineplus">+  }</span>
<a href="#l1.126"></a><span id="l1.126"> };</span>
<a href="#l1.127"></a><span id="l1.127"> </span>
<a href="#l1.128"></a><span id="l1.128"> </span>
<a href="#l1.129"></a><span id="l1.129"> /**</span>
<a href="#l1.130"></a><span id="l1.130">  * Log enumerators provide lists of log files (&quot;entries&quot;). aEntries is an array</span>
<a href="#l1.131"></a><span id="l1.131">  * of the OS.File.DirectoryIterator.Entry instances which represent the log</span>
<a href="#l1.132"></a><span id="l1.132">  * files to be parsed.</span>
<a href="#l1.133"></a><span id="l1.133">  *</span>
<a href="#l1.134"></a><span id="l1.134" class="difflineat">@@ -691,35 +690,35 @@ LogEnumerator.prototype = {</span>
<a href="#l1.135"></a><span id="l1.135">   * [Symbol.iterator]() { while (this.hasMoreElements()) yield this.getNext(); }</span>
<a href="#l1.136"></a><span id="l1.136"> };</span>
<a href="#l1.137"></a><span id="l1.137"> </span>
<a href="#l1.138"></a><span id="l1.138"> </span>
<a href="#l1.139"></a><span id="l1.139"> function Logger() { }</span>
<a href="#l1.140"></a><span id="l1.140"> Logger.prototype = {</span>
<a href="#l1.141"></a><span id="l1.141">   // Returned Promise resolves to an array of entries for the</span>
<a href="#l1.142"></a><span id="l1.142">   // log folder if it exists, otherwise null.</span>
<a href="#l1.143"></a><span id="l1.143" class="difflineminus">-  _getLogArray: Task.async(function* (aAccount, aNormalizedName) {</span>
<a href="#l1.144"></a><span id="l1.144" class="difflineplus">+  async _getLogArray(aAccount, aNormalizedName) {</span>
<a href="#l1.145"></a><span id="l1.145">     let iterator, path;</span>
<a href="#l1.146"></a><span id="l1.146">     try {</span>
<a href="#l1.147"></a><span id="l1.147">       path = OS.Path.join(getLogFolderPathForAccount(aAccount),</span>
<a href="#l1.148"></a><span id="l1.148">                           encodeName(aNormalizedName));</span>
<a href="#l1.149"></a><span id="l1.149" class="difflineminus">-      if (yield queueFileOperation(path, () =&gt; OS.File.exists(path))) {</span>
<a href="#l1.150"></a><span id="l1.150" class="difflineplus">+      if (await queueFileOperation(path, () =&gt; OS.File.exists(path))) {</span>
<a href="#l1.151"></a><span id="l1.151">         iterator = new OS.File.DirectoryIterator(path);</span>
<a href="#l1.152"></a><span id="l1.152" class="difflineminus">-        let entries = yield iterator.nextBatch();</span>
<a href="#l1.153"></a><span id="l1.153" class="difflineplus">+        let entries = await iterator.nextBatch();</span>
<a href="#l1.154"></a><span id="l1.154">         iterator.close();</span>
<a href="#l1.155"></a><span id="l1.155">         return entries;</span>
<a href="#l1.156"></a><span id="l1.156">       }</span>
<a href="#l1.157"></a><span id="l1.157">     } catch (aError) {</span>
<a href="#l1.158"></a><span id="l1.158">       if (iterator)</span>
<a href="#l1.159"></a><span id="l1.159">         iterator.close();</span>
<a href="#l1.160"></a><span id="l1.160">       Cu.reportError(&quot;Error getting directory entries for \&quot;&quot; +</span>
<a href="#l1.161"></a><span id="l1.161">                      path + &quot;\&quot;:\n&quot; + aError);</span>
<a href="#l1.162"></a><span id="l1.162">     }</span>
<a href="#l1.163"></a><span id="l1.163">     return [];</span>
<a href="#l1.164"></a><span id="l1.164" class="difflineminus">-  }),</span>
<a href="#l1.165"></a><span id="l1.165" class="difflineplus">+  },</span>
<a href="#l1.166"></a><span id="l1.166">   getLogFromFile: function logger_getLogFromFile(aFilePath, aGroupByDay) {</span>
<a href="#l1.167"></a><span id="l1.167">     if (!aGroupByDay)</span>
<a href="#l1.168"></a><span id="l1.168">       return Promise.resolve(new Log(aFilePath));</span>
<a href="#l1.169"></a><span id="l1.169">     let [targetDate] = getDateFromFilename(OS.Path.basename(aFilePath));</span>
<a href="#l1.170"></a><span id="l1.170">     if (!targetDate)</span>
<a href="#l1.171"></a><span id="l1.171">       return null;</span>
<a href="#l1.172"></a><span id="l1.172"> </span>
<a href="#l1.173"></a><span id="l1.173">     targetDate = targetDate.toDateString();</span>
<a href="#l1.174"></a><span id="l1.174" class="difflineat">@@ -749,79 +748,79 @@ Logger.prototype = {</span>
<a href="#l1.175"></a><span id="l1.175">     });</span>
<a href="#l1.176"></a><span id="l1.176">   },</span>
<a href="#l1.177"></a><span id="l1.177">   // Creates and returns the appropriate LogEnumerator for the given log array</span>
<a href="#l1.178"></a><span id="l1.178">   // depending on aGroupByDay, or an EmptyEnumerator if the input array is empty.</span>
<a href="#l1.179"></a><span id="l1.179">   _getEnumerator: function logger__getEnumerator(aLogArray, aGroupByDay) {</span>
<a href="#l1.180"></a><span id="l1.180">     let enumerator = aGroupByDay ? DailyLogEnumerator : LogEnumerator;</span>
<a href="#l1.181"></a><span id="l1.181">     return aLogArray.length ? new enumerator(aLogArray) : EmptyEnumerator;</span>
<a href="#l1.182"></a><span id="l1.182">   },</span>
<a href="#l1.183"></a><span id="l1.183" class="difflineminus">-  getLogPathsForConversation: Task.async(function* (aConversation) {</span>
<a href="#l1.184"></a><span id="l1.184" class="difflineplus">+  async getLogPathsForConversation(aConversation) {</span>
<a href="#l1.185"></a><span id="l1.185">     let writer = gLogWritersById.get(aConversation.id);</span>
<a href="#l1.186"></a><span id="l1.186">     // Resolve to null if we haven't created a LogWriter yet for this conv, or</span>
<a href="#l1.187"></a><span id="l1.187">     // if logging is disabled (paths will be null).</span>
<a href="#l1.188"></a><span id="l1.188">     if (!writer || !writer.paths)</span>
<a href="#l1.189"></a><span id="l1.189">       return null;</span>
<a href="#l1.190"></a><span id="l1.190">     let paths = writer.paths;</span>
<a href="#l1.191"></a><span id="l1.191">     // Wait for any pending file operations to finish, then resolve to the paths</span>
<a href="#l1.192"></a><span id="l1.192">     // regardless of whether these operations succeeded.</span>
<a href="#l1.193"></a><span id="l1.193">     for (let path of paths)</span>
<a href="#l1.194"></a><span id="l1.194" class="difflineminus">-      yield gFilePromises.get(path);</span>
<a href="#l1.195"></a><span id="l1.195" class="difflineplus">+      await gFilePromises.get(path);</span>
<a href="#l1.196"></a><span id="l1.196">     return paths;</span>
<a href="#l1.197"></a><span id="l1.197" class="difflineminus">-  }),</span>
<a href="#l1.198"></a><span id="l1.198" class="difflineplus">+  },</span>
<a href="#l1.199"></a><span id="l1.199">   getLogsForAccountAndName: function logger_getLogsForAccountAndName(aAccount,</span>
<a href="#l1.200"></a><span id="l1.200">                                        aNormalizedName, aGroupByDay) {</span>
<a href="#l1.201"></a><span id="l1.201">     return this._getLogArray(aAccount, aNormalizedName)</span>
<a href="#l1.202"></a><span id="l1.202">                .then(aEntries =&gt; this._getEnumerator(aEntries, aGroupByDay));</span>
<a href="#l1.203"></a><span id="l1.203">   },</span>
<a href="#l1.204"></a><span id="l1.204">   getLogsForAccountBuddy: function logger_getLogsForAccountBuddy(aAccountBuddy,</span>
<a href="#l1.205"></a><span id="l1.205">                                                                  aGroupByDay) {</span>
<a href="#l1.206"></a><span id="l1.206">     return this.getLogsForAccountAndName(aAccountBuddy.account,</span>
<a href="#l1.207"></a><span id="l1.207">                                          aAccountBuddy.normalizedName, aGroupByDay);</span>
<a href="#l1.208"></a><span id="l1.208">   },</span>
<a href="#l1.209"></a><span id="l1.209" class="difflineminus">-  getLogsForBuddy: Task.async(function* (aBuddy, aGroupByDay) {</span>
<a href="#l1.210"></a><span id="l1.210" class="difflineplus">+  async getLogsForBuddy(aBuddy, aGroupByDay) {</span>
<a href="#l1.211"></a><span id="l1.211">     let entries = [];</span>
<a href="#l1.212"></a><span id="l1.212">     for (let accountBuddy of aBuddy.getAccountBuddies()) {</span>
<a href="#l1.213"></a><span id="l1.213" class="difflineminus">-      entries = entries.concat(yield this._getLogArray(accountBuddy.account,</span>
<a href="#l1.214"></a><span id="l1.214" class="difflineplus">+      entries = entries.concat(await this._getLogArray(accountBuddy.account,</span>
<a href="#l1.215"></a><span id="l1.215">                                                        accountBuddy.normalizedName));</span>
<a href="#l1.216"></a><span id="l1.216">     }</span>
<a href="#l1.217"></a><span id="l1.217">     return this._getEnumerator(entries, aGroupByDay);</span>
<a href="#l1.218"></a><span id="l1.218" class="difflineminus">-  }),</span>
<a href="#l1.219"></a><span id="l1.219" class="difflineminus">-  getLogsForContact: Task.async(function* (aContact, aGroupByDay) {</span>
<a href="#l1.220"></a><span id="l1.220" class="difflineplus">+  },</span>
<a href="#l1.221"></a><span id="l1.221" class="difflineplus">+  async getLogsForContact(aContact, aGroupByDay) {</span>
<a href="#l1.222"></a><span id="l1.222">     let entries = [];</span>
<a href="#l1.223"></a><span id="l1.223">     for (let buddy of aContact.getBuddies()) {</span>
<a href="#l1.224"></a><span id="l1.224">       for (let accountBuddy of buddy.getAccountBuddies()) {</span>
<a href="#l1.225"></a><span id="l1.225" class="difflineminus">-        entries = entries.concat(yield this._getLogArray(accountBuddy.account,</span>
<a href="#l1.226"></a><span id="l1.226" class="difflineplus">+        entries = entries.concat(await this._getLogArray(accountBuddy.account,</span>
<a href="#l1.227"></a><span id="l1.227">                                                          accountBuddy.normalizedName));</span>
<a href="#l1.228"></a><span id="l1.228">       }</span>
<a href="#l1.229"></a><span id="l1.229">     }</span>
<a href="#l1.230"></a><span id="l1.230">     return this._getEnumerator(entries, aGroupByDay);</span>
<a href="#l1.231"></a><span id="l1.231" class="difflineminus">-  }),</span>
<a href="#l1.232"></a><span id="l1.232" class="difflineplus">+  },</span>
<a href="#l1.233"></a><span id="l1.233">   getLogsForConversation: function logger_getLogsForConversation(aConversation,</span>
<a href="#l1.234"></a><span id="l1.234">                                                                  aGroupByDay) {</span>
<a href="#l1.235"></a><span id="l1.235">     let name = aConversation.normalizedName;</span>
<a href="#l1.236"></a><span id="l1.236">     if (convIsRealMUC(aConversation))</span>
<a href="#l1.237"></a><span id="l1.237">       name += &quot;.chat&quot;;</span>
<a href="#l1.238"></a><span id="l1.238">     return this.getLogsForAccountAndName(aConversation.account, name, aGroupByDay);</span>
<a href="#l1.239"></a><span id="l1.239">   },</span>
<a href="#l1.240"></a><span id="l1.240">   getSystemLogsForAccount: function logger_getSystemLogsForAccount(aAccount) {</span>
<a href="#l1.241"></a><span id="l1.241">     return this.getLogsForAccountAndName(aAccount, &quot;.system&quot;);</span>
<a href="#l1.242"></a><span id="l1.242">   },</span>
<a href="#l1.243"></a><span id="l1.243" class="difflineminus">-  getSimilarLogs: Task.async(function* (aLog, aGroupByDay) {</span>
<a href="#l1.244"></a><span id="l1.244" class="difflineplus">+  async getSimilarLogs(aLog, aGroupByDay) {</span>
<a href="#l1.245"></a><span id="l1.245">     let iterator = new OS.File.DirectoryIterator(OS.Path.dirname(aLog.path));</span>
<a href="#l1.246"></a><span id="l1.246">     let entries;</span>
<a href="#l1.247"></a><span id="l1.247">     try {</span>
<a href="#l1.248"></a><span id="l1.248" class="difflineminus">-      entries = yield iterator.nextBatch();</span>
<a href="#l1.249"></a><span id="l1.249" class="difflineplus">+      entries = await iterator.nextBatch();</span>
<a href="#l1.250"></a><span id="l1.250">     } catch (aError) {</span>
<a href="#l1.251"></a><span id="l1.251">       Cu.reportError(&quot;Error getting similar logs for \&quot;&quot; +</span>
<a href="#l1.252"></a><span id="l1.252">                      aLog.path + &quot;\&quot;:\n&quot; + aError);</span>
<a href="#l1.253"></a><span id="l1.253">     }</span>
<a href="#l1.254"></a><span id="l1.254">     // If there was an error, this will return an EmptyEnumerator.</span>
<a href="#l1.255"></a><span id="l1.255">     return this._getEnumerator(entries, aGroupByDay);</span>
<a href="#l1.256"></a><span id="l1.256" class="difflineminus">-  }),</span>
<a href="#l1.257"></a><span id="l1.257" class="difflineplus">+  },</span>
<a href="#l1.258"></a><span id="l1.258"> </span>
<a href="#l1.259"></a><span id="l1.259">   getLogFolderPathForAccount: function(aAccount) {</span>
<a href="#l1.260"></a><span id="l1.260">     return getLogFolderPathForAccount(aAccount);</span>
<a href="#l1.261"></a><span id="l1.261">   },</span>
<a href="#l1.262"></a><span id="l1.262"> </span>
<a href="#l1.263"></a><span id="l1.263">   deleteLogFolderForAccount: function(aAccount) {</span>
<a href="#l1.264"></a><span id="l1.264">     if (!aAccount.disconnecting &amp;&amp; !aAccount.disconnected)</span>
<a href="#l1.265"></a><span id="l1.265">       throw new Error(&quot;Account must be disconnected first before deleting logs.&quot;);</span>
<a href="#l1.266"></a><span id="l1.266" class="difflineat">@@ -838,59 +837,59 @@ Logger.prototype = {</span>
<a href="#l1.267"></a><span id="l1.267">     }</span>
<a href="#l1.268"></a><span id="l1.268">     gFilePromises.forEach(checkLogFiles);</span>
<a href="#l1.269"></a><span id="l1.269">     // After all operations finish, remove the whole log folder.</span>
<a href="#l1.270"></a><span id="l1.270">     return Promise.all(pendingPromises)</span>
<a href="#l1.271"></a><span id="l1.271">                   .then(values =&gt; { OS.File.removeDir(logPath, { ignoreAbsent: true }); })</span>
<a href="#l1.272"></a><span id="l1.272">                   .catch(aError =&gt; Cu.reportError(&quot;Failed to remove log folders:\n&quot; + aError));</span>
<a href="#l1.273"></a><span id="l1.273">   },</span>
<a href="#l1.274"></a><span id="l1.274"> </span>
<a href="#l1.275"></a><span id="l1.275" class="difflineminus">-  forEach: Task.async(function* (aCallback) {</span>
<a href="#l1.276"></a><span id="l1.276" class="difflineminus">-    let getAllSubdirs = Task.async(function* (aPaths, aErrorMsg) {</span>
<a href="#l1.277"></a><span id="l1.277" class="difflineplus">+  async forEach(aCallback) {</span>
<a href="#l1.278"></a><span id="l1.278" class="difflineplus">+    let getAllSubdirs = async function (aPaths, aErrorMsg) {</span>
<a href="#l1.279"></a><span id="l1.279">       let entries = [];</span>
<a href="#l1.280"></a><span id="l1.280">       for (let path of aPaths) {</span>
<a href="#l1.281"></a><span id="l1.281">         let iterator = new OS.File.DirectoryIterator(path);</span>
<a href="#l1.282"></a><span id="l1.282">         try {</span>
<a href="#l1.283"></a><span id="l1.283" class="difflineminus">-          entries = entries.concat(yield iterator.nextBatch());</span>
<a href="#l1.284"></a><span id="l1.284" class="difflineplus">+          entries = entries.concat(await iterator.nextBatch());</span>
<a href="#l1.285"></a><span id="l1.285">         } catch (aError) {</span>
<a href="#l1.286"></a><span id="l1.286">           if (aErrorMsg)</span>
<a href="#l1.287"></a><span id="l1.287">             Cu.reportError(aErrorMsg + &quot;\n&quot; + aError);</span>
<a href="#l1.288"></a><span id="l1.288">         } finally {</span>
<a href="#l1.289"></a><span id="l1.289">           iterator.close();</span>
<a href="#l1.290"></a><span id="l1.290">         }</span>
<a href="#l1.291"></a><span id="l1.291">       }</span>
<a href="#l1.292"></a><span id="l1.292">       entries = entries.filter(aEntry =&gt; aEntry.isDir)</span>
<a href="#l1.293"></a><span id="l1.293">                        .map(aEntry =&gt; aEntry.path);</span>
<a href="#l1.294"></a><span id="l1.294">       return entries;</span>
<a href="#l1.295"></a><span id="l1.295" class="difflineminus">-    });</span>
<a href="#l1.296"></a><span id="l1.296" class="difflineplus">+    }</span>
<a href="#l1.297"></a><span id="l1.297"> </span>
<a href="#l1.298"></a><span id="l1.298">     let logsPath = OS.Path.join(OS.Constants.Path.profileDir, &quot;logs&quot;);</span>
<a href="#l1.299"></a><span id="l1.299" class="difflineminus">-    let prpls = yield getAllSubdirs([logsPath]);</span>
<a href="#l1.300"></a><span id="l1.300" class="difflineplus">+    let prpls = await getAllSubdirs([logsPath]);</span>
<a href="#l1.301"></a><span id="l1.301">     let accounts =</span>
<a href="#l1.302"></a><span id="l1.302" class="difflineminus">-      yield getAllSubdirs(prpls, &quot;Error while sweeping prpl folder:&quot;);</span>
<a href="#l1.303"></a><span id="l1.303" class="difflineplus">+      await getAllSubdirs(prpls, &quot;Error while sweeping prpl folder:&quot;);</span>
<a href="#l1.304"></a><span id="l1.304">     let logFolders =</span>
<a href="#l1.305"></a><span id="l1.305" class="difflineminus">-      yield getAllSubdirs(accounts, &quot;Error while sweeping account folder:&quot;);</span>
<a href="#l1.306"></a><span id="l1.306" class="difflineplus">+      await getAllSubdirs(accounts, &quot;Error while sweeping account folder:&quot;);</span>
<a href="#l1.307"></a><span id="l1.307">     for (let folder of logFolders) {</span>
<a href="#l1.308"></a><span id="l1.308">       let iterator = new OS.File.DirectoryIterator(folder);</span>
<a href="#l1.309"></a><span id="l1.309">       try {</span>
<a href="#l1.310"></a><span id="l1.310" class="difflineminus">-        yield iterator.forEach(aEntry =&gt; {</span>
<a href="#l1.311"></a><span id="l1.311" class="difflineplus">+        await iterator.forEach(aEntry =&gt; {</span>
<a href="#l1.312"></a><span id="l1.312">           if (aEntry.isDir || !aEntry.name.endsWith(&quot;.json&quot;))</span>
<a href="#l1.313"></a><span id="l1.313">             return null;</span>
<a href="#l1.314"></a><span id="l1.314">           return aCallback.processLog(aEntry.path);</span>
<a href="#l1.315"></a><span id="l1.315">         });</span>
<a href="#l1.316"></a><span id="l1.316">       } catch (aError) {</span>
<a href="#l1.317"></a><span id="l1.317">         // If the callback threw, reject the promise and let the caller handle it.</span>
<a href="#l1.318"></a><span id="l1.318">         if (!(aError instanceof OS.File.Error))</span>
<a href="#l1.319"></a><span id="l1.319">           throw aError;</span>
<a href="#l1.320"></a><span id="l1.320">         Cu.reportError(&quot;Error sweeping log folder:\n&quot; + aError);</span>
<a href="#l1.321"></a><span id="l1.321">       } finally {</span>
<a href="#l1.322"></a><span id="l1.322">         iterator.close();</span>
<a href="#l1.323"></a><span id="l1.323">       }</span>
<a href="#l1.324"></a><span id="l1.324">     }</span>
<a href="#l1.325"></a><span id="l1.325" class="difflineminus">-  }),</span>
<a href="#l1.326"></a><span id="l1.326" class="difflineplus">+  },</span>
<a href="#l1.327"></a><span id="l1.327"> </span>
<a href="#l1.328"></a><span id="l1.328">   observe: function logger_observe(aSubject, aTopic, aData) {</span>
<a href="#l1.329"></a><span id="l1.329">     switch (aTopic) {</span>
<a href="#l1.330"></a><span id="l1.330">     case &quot;profile-after-change&quot;:</span>
<a href="#l1.331"></a><span id="l1.331">       Services.obs.addObserver(this, &quot;final-ui-startup&quot;);</span>
<a href="#l1.332"></a><span id="l1.332">       break;</span>
<a href="#l1.333"></a><span id="l1.333">     case &quot;final-ui-startup&quot;:</span>
<a href="#l1.334"></a><span id="l1.334">       Services.obs.removeObserver(this, &quot;final-ui-startup&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/chat/protocols/irc/ircCommands.jsm</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/chat/protocols/irc/ircCommands.jsm</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -3,17 +3,16 @@</span>
<a href="#l2.4"></a><span id="l2.4">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l2.5"></a><span id="l2.5"> </span>
<a href="#l2.6"></a><span id="l2.6"> // This is to be exported directly onto the IRC prplIProtocol object, directly</span>
<a href="#l2.7"></a><span id="l2.7"> // implementing the commands field before we register them.</span>
<a href="#l2.8"></a><span id="l2.8"> this.EXPORTED_SYMBOLS = [&quot;commands&quot;];</span>
<a href="#l2.9"></a><span id="l2.9"> </span>
<a href="#l2.10"></a><span id="l2.10"> ChromeUtils.import(&quot;resource:///modules/imXPCOMUtils.jsm&quot;);</span>
<a href="#l2.11"></a><span id="l2.11"> ChromeUtils.import(&quot;resource:///modules/ircUtils.jsm&quot;);</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-ChromeUtils.defineModuleGetter(this, &quot;Task&quot;, &quot;resource://gre/modules/Task.jsm&quot;);</span>
<a href="#l2.13"></a><span id="l2.13"> </span>
<a href="#l2.14"></a><span id="l2.14"> // Shortcut to get the JavaScript conversation object.</span>
<a href="#l2.15"></a><span id="l2.15"> function getConv(aConv) { return aConv.wrappedJSObject; }</span>
<a href="#l2.16"></a><span id="l2.16"> </span>
<a href="#l2.17"></a><span id="l2.17"> // Shortcut to get the JavaScript account object.</span>
<a href="#l2.18"></a><span id="l2.18"> function getAccount(aConv) { return getConv(aConv)._account; }</span>
<a href="#l2.19"></a><span id="l2.19"> </span>
<a href="#l2.20"></a><span id="l2.20"> // Trim leading and trailing spaces and split a string by any type of space.</span>
<a href="#l2.21"></a><span id="l2.21" class="difflineat">@@ -272,32 +271,32 @@ var commands = [</span>
<a href="#l2.22"></a><span id="l2.22">     get helpString() { return _(&quot;command.list&quot;, &quot;list&quot;); },</span>
<a href="#l2.23"></a><span id="l2.23">     run: function(aMsg, aConv, aReturnedConv) {</span>
<a href="#l2.24"></a><span id="l2.24">       let account = getAccount(aConv);</span>
<a href="#l2.25"></a><span id="l2.25">       let serverName = account._currentServerName;</span>
<a href="#l2.26"></a><span id="l2.26">       let serverConv = account.getConversation(serverName);</span>
<a href="#l2.27"></a><span id="l2.27">       let pendingChats = [];</span>
<a href="#l2.28"></a><span id="l2.28">       account.requestRoomInfo({onRoomInfoAvailable: function(aRooms) {</span>
<a href="#l2.29"></a><span id="l2.29">         if (!pendingChats.length) {</span>
<a href="#l2.30"></a><span id="l2.30" class="difflineminus">-          Task.spawn(function*() {</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+          (async function () {</span>
<a href="#l2.32"></a><span id="l2.32">             // pendingChats has no rooms added yet, so ensure we wait a tick.</span>
<a href="#l2.33"></a><span id="l2.33">             let t = 0;</span>
<a href="#l2.34"></a><span id="l2.34">             const kMaxBlockTime = 10; // Unblock every 10ms.</span>
<a href="#l2.35"></a><span id="l2.35">             do {</span>
<a href="#l2.36"></a><span id="l2.36">               if (Date.now() &gt; t) {</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineminus">-                yield Promise.resolve();</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+                await new Promise(resolve =&gt; Services.tm.dispatchToMainThread(resolve));</span>
<a href="#l2.39"></a><span id="l2.39">                 t = Date.now() + kMaxBlockTime;</span>
<a href="#l2.40"></a><span id="l2.40">               }</span>
<a href="#l2.41"></a><span id="l2.41">               let name = pendingChats.pop();</span>
<a href="#l2.42"></a><span id="l2.42">               let roomInfo = account.getRoomInfo(name);</span>
<a href="#l2.43"></a><span id="l2.43">               serverConv.writeMessage(serverName,</span>
<a href="#l2.44"></a><span id="l2.44">                 name + &quot; (&quot; + roomInfo.participantCount + &quot;) &quot; + roomInfo.topic,</span>
<a href="#l2.45"></a><span id="l2.45">                 {incoming: true, noLog: true});</span>
<a href="#l2.46"></a><span id="l2.46">             } while (pendingChats.length);</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineminus">-          });</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineplus">+          })();</span>
<a href="#l2.49"></a><span id="l2.49">         }</span>
<a href="#l2.50"></a><span id="l2.50">         pendingChats = pendingChats.concat(aRooms);</span>
<a href="#l2.51"></a><span id="l2.51">       }}, true);</span>
<a href="#l2.52"></a><span id="l2.52">       if (aReturnedConv)</span>
<a href="#l2.53"></a><span id="l2.53">         aReturnedConv.value = serverConv;</span>
<a href="#l2.54"></a><span id="l2.54">       return true;</span>
<a href="#l2.55"></a><span id="l2.55">     }</span>
<a href="#l2.56"></a><span id="l2.56">   },</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mail/components/im/modules/index_im.jsm</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mail/components/im/modules/index_im.jsm</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -18,17 +18,16 @@ ChromeUtils.import(&quot;resource:///modules/</span>
<a href="#l3.4"></a><span id="l3.4"> ChromeUtils.import(&quot;resource://gre/modules/FileUtils.jsm&quot;);</span>
<a href="#l3.5"></a><span id="l3.5"> ChromeUtils.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l3.6"></a><span id="l3.6"> const {</span>
<a href="#l3.7"></a><span id="l3.7">   clearTimeout,</span>
<a href="#l3.8"></a><span id="l3.8">   setTimeout,</span>
<a href="#l3.9"></a><span id="l3.9"> } = ChromeUtils.import(&quot;resource://gre/modules/Timer.jsm&quot;, null);</span>
<a href="#l3.10"></a><span id="l3.10"> </span>
<a href="#l3.11"></a><span id="l3.11"> ChromeUtils.defineModuleGetter(this, &quot;OS&quot;, &quot;resource://gre/modules/osfile.jsm&quot;);</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-ChromeUtils.defineModuleGetter(this, &quot;Task&quot;, &quot;resource://gre/modules/Task.jsm&quot;);</span>
<a href="#l3.13"></a><span id="l3.13"> ChromeUtils.defineModuleGetter(this, &quot;AsyncShutdown&quot;,</span>
<a href="#l3.14"></a><span id="l3.14">                                &quot;resource://gre/modules/AsyncShutdown.jsm&quot;);</span>
<a href="#l3.15"></a><span id="l3.15"> ChromeUtils.defineModuleGetter(this, &quot;GlodaDatastore&quot;,</span>
<a href="#l3.16"></a><span id="l3.16">                                &quot;resource:///modules/gloda/datastore.js&quot;);</span>
<a href="#l3.17"></a><span id="l3.17"> </span>
<a href="#l3.18"></a><span id="l3.18"> var kCacheFileName = &quot;indexedFiles.json&quot;;</span>
<a href="#l3.19"></a><span id="l3.19"> </span>
<a href="#l3.20"></a><span id="l3.20"> var FileInputStream = CC(&quot;@mozilla.org/network/file-input-stream;1&quot;,</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineat">@@ -383,21 +382,21 @@ var GlodaIMIndexer = {</span>
<a href="#l3.22"></a><span id="l3.22">         id: convId,</span>
<a href="#l3.23"></a><span id="l3.23">         scheduledIndex: null,</span>
<a href="#l3.24"></a><span id="l3.24">         logFileCount: null,</span>
<a href="#l3.25"></a><span id="l3.25">         convObj: {},</span>
<a href="#l3.26"></a><span id="l3.26">       };</span>
<a href="#l3.27"></a><span id="l3.27">     }</span>
<a href="#l3.28"></a><span id="l3.28"> </span>
<a href="#l3.29"></a><span id="l3.29">     let conv = this._knownConversations[convId];</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineminus">-    Task.spawn(function* () {</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+    (async () =&gt; {</span>
<a href="#l3.32"></a><span id="l3.32">       // We need to get the log files every time, because a new log file might</span>
<a href="#l3.33"></a><span id="l3.33">       // have been started since we last got them.</span>
<a href="#l3.34"></a><span id="l3.34">       let logFiles =</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineminus">-        yield Services.logs.getLogPathsForConversation(aConversation);</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+        await Services.logs.getLogPathsForConversation(aConversation);</span>
<a href="#l3.37"></a><span id="l3.37">       if (!logFiles || !logFiles.length) {</span>
<a href="#l3.38"></a><span id="l3.38">         // No log files exist yet, nothing to do!</span>
<a href="#l3.39"></a><span id="l3.39">         return;</span>
<a href="#l3.40"></a><span id="l3.40">       }</span>
<a href="#l3.41"></a><span id="l3.41"> </span>
<a href="#l3.42"></a><span id="l3.42">       if (conv.logFileCount == undefined) {</span>
<a href="#l3.43"></a><span id="l3.43">         // We initialize the _knownFiles tree path for the current files below in</span>
<a href="#l3.44"></a><span id="l3.44">         // case it doesn't already exist.</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineat">@@ -428,37 +427,37 @@ var GlodaIMIndexer = {</span>
<a href="#l3.46"></a><span id="l3.46">       // conv.logFiles.length - 1, so we slice from there. This gives us all new</span>
<a href="#l3.47"></a><span id="l3.47">       // log files even if there are multiple new ones.</span>
<a href="#l3.48"></a><span id="l3.48">       let currentLogFiles = conv.logFileCount &gt; 1 ?</span>
<a href="#l3.49"></a><span id="l3.49">                             logFiles.slice(conv.logFileCount - 1) :</span>
<a href="#l3.50"></a><span id="l3.50">                             logFiles;</span>
<a href="#l3.51"></a><span id="l3.51">       for (let logFile of currentLogFiles) {</span>
<a href="#l3.52"></a><span id="l3.52">         let fileName = OS.Path.basename(logFile);</span>
<a href="#l3.53"></a><span id="l3.53">         let lastModifiedTime =</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineminus">-          (yield OS.File.stat(logFile)).lastModificationDate.valueOf();</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+          (await OS.File.stat(logFile)).lastModificationDate.valueOf();</span>
<a href="#l3.56"></a><span id="l3.56">         if (Object.prototype.hasOwnProperty.call(conv.convObj, fileName) &amp;&amp;</span>
<a href="#l3.57"></a><span id="l3.57">             conv.convObj[fileName] == lastModifiedTime) {</span>
<a href="#l3.58"></a><span id="l3.58">           // The file hasn't changed since we last indexed it, so we're done.</span>
<a href="#l3.59"></a><span id="l3.59">           continue;</span>
<a href="#l3.60"></a><span id="l3.60">         }</span>
<a href="#l3.61"></a><span id="l3.61"> </span>
<a href="#l3.62"></a><span id="l3.62">         if (this._indexingJobPromise)</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineminus">-          yield this._indexingJobPromise;</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineplus">+          await this._indexingJobPromise;</span>
<a href="#l3.65"></a><span id="l3.65">         this._indexingJobPromise = new Promise(aResolve =&gt; {</span>
<a href="#l3.66"></a><span id="l3.66">           this._indexingJobCallbacks.set(convId, aResolve);</span>
<a href="#l3.67"></a><span id="l3.67">         });</span>
<a href="#l3.68"></a><span id="l3.68"> </span>
<a href="#l3.69"></a><span id="l3.69">         let job = new IndexingJob(&quot;indexIMConversation&quot;, null);</span>
<a href="#l3.70"></a><span id="l3.70">         job.conversation = conv;</span>
<a href="#l3.71"></a><span id="l3.71">         job.path = logFile;</span>
<a href="#l3.72"></a><span id="l3.72">         job.lastModifiedTime = lastModifiedTime;</span>
<a href="#l3.73"></a><span id="l3.73">         GlodaIndexer.indexJob(job);</span>
<a href="#l3.74"></a><span id="l3.74">       }</span>
<a href="#l3.75"></a><span id="l3.75">       conv.logFileCount = logFiles.length;</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineminus">-    }.bind(this)).catch(Cu.reportError);</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineplus">+    })().catch(Cu.reportError);</span>
<a href="#l3.78"></a><span id="l3.78"> </span>
<a href="#l3.79"></a><span id="l3.79">     // Now clear the job, so we can index in the future.</span>
<a href="#l3.80"></a><span id="l3.80">     this._knownConversations[convId].scheduledIndex = null;</span>
<a href="#l3.81"></a><span id="l3.81">   },</span>
<a href="#l3.82"></a><span id="l3.82"> </span>
<a href="#l3.83"></a><span id="l3.83">   observe: function logger_observe(aSubject, aTopic, aData) {</span>
<a href="#l3.84"></a><span id="l3.84">     if (aTopic == &quot;new-ui-conversation&quot;) {</span>
<a href="#l3.85"></a><span id="l3.85">       // Add ourselves to the ui-conversation's list of observers for the</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineat">@@ -559,19 +558,19 @@ var GlodaIMIndexer = {</span>
<a href="#l3.87"></a><span id="l3.87">    * conversation in the database, so the caller dealing with ongoing</span>
<a href="#l3.88"></a><span id="l3.88">    * conversation has to provide the aGlodaConv parameter, while the caller</span>
<a href="#l3.89"></a><span id="l3.89">    * dealing with old conversations doesn't care.</span>
<a href="#l3.90"></a><span id="l3.90">    * The aCache parameter is an object mapping file names to their last</span>
<a href="#l3.91"></a><span id="l3.91">    * modified times at the time they were last indexed. The value for the file</span>
<a href="#l3.92"></a><span id="l3.92">    * currently being indexed is updated to the aLastModifiedTime parameter's</span>
<a href="#l3.93"></a><span id="l3.93">    * value once indexing is complete.</span>
<a href="#l3.94"></a><span id="l3.94">    * */</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineminus">-  indexIMConversation: Task.async(function* (aCallbackHandle, aLogPath, aLastModifiedTime, aCache, aGlodaConv) {</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineminus">-    let log = yield Services.logs.getLogFromFile(aLogPath);</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineminus">-    let logConv = yield log.getConversation();</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineplus">+  async indexIMConversation(aCallbackHandle, aLogPath, aLastModifiedTime, aCache, aGlodaConv) {</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineplus">+    let log = await Services.logs.getLogFromFile(aLogPath);</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineplus">+    let logConv = await log.getConversation();</span>
<a href="#l3.101"></a><span id="l3.101"> </span>
<a href="#l3.102"></a><span id="l3.102">     // Ignore corrupted log files.</span>
<a href="#l3.103"></a><span id="l3.103">     if (!logConv)</span>
<a href="#l3.104"></a><span id="l3.104">       return Gloda.kWorkDone;</span>
<a href="#l3.105"></a><span id="l3.105"> </span>
<a href="#l3.106"></a><span id="l3.106">     let fileName = OS.Path.basename(aLogPath);</span>
<a href="#l3.107"></a><span id="l3.107">     let content = logConv.getMessages()</span>
<a href="#l3.108"></a><span id="l3.108">                          // Some messages returned, e.g. sessionstart messages,</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineat">@@ -591,17 +590,17 @@ var GlodaIMIndexer = {</span>
<a href="#l3.110"></a><span id="l3.110">       glodaConv._content = content;</span>
<a href="#l3.111"></a><span id="l3.111">     } else {</span>
<a href="#l3.112"></a><span id="l3.112">       let relativePath = this._getRelativePath(aLogPath);</span>
<a href="#l3.113"></a><span id="l3.113">       glodaConv = new GlodaIMConversation(logConv.title, log.time, relativePath, content);</span>
<a href="#l3.114"></a><span id="l3.114">       // If we've indexed this file before, we need the id of the existing</span>
<a href="#l3.115"></a><span id="l3.115">       // gloda conversation so that the existing entry gets updated. This can</span>
<a href="#l3.116"></a><span id="l3.116">       // happen if the log sweep detects that the last messages in an open</span>
<a href="#l3.117"></a><span id="l3.117">       // chat were not in fact indexed before that session was shut down.</span>
<a href="#l3.118"></a><span id="l3.118" class="difflineminus">-      let id = yield this._getIdFromPath(relativePath);</span>
<a href="#l3.119"></a><span id="l3.119" class="difflineplus">+      let id = await this._getIdFromPath(relativePath);</span>
<a href="#l3.120"></a><span id="l3.120">       if (id)</span>
<a href="#l3.121"></a><span id="l3.121">         glodaConv.id = id;</span>
<a href="#l3.122"></a><span id="l3.122">       if (aGlodaConv)</span>
<a href="#l3.123"></a><span id="l3.123">         aGlodaConv.value = glodaConv;</span>
<a href="#l3.124"></a><span id="l3.124">     }</span>
<a href="#l3.125"></a><span id="l3.125"> </span>
<a href="#l3.126"></a><span id="l3.126">     if (!aCache)</span>
<a href="#l3.127"></a><span id="l3.127">       throw &quot;indexIMConversation called without aCache parameter.&quot;;</span>
<a href="#l3.128"></a><span id="l3.128" class="difflineat">@@ -610,17 +609,17 @@ var GlodaIMIndexer = {</span>
<a href="#l3.129"></a><span id="l3.129">       Gloda.grokNounItem(glodaConv, {}, true, isNew, aCallbackHandle));</span>
<a href="#l3.130"></a><span id="l3.130"> </span>
<a href="#l3.131"></a><span id="l3.131">     if (!aLastModifiedTime)</span>
<a href="#l3.132"></a><span id="l3.132">       Cu.reportError(&quot;indexIMConversation called without lastModifiedTime parameter.&quot;);</span>
<a href="#l3.133"></a><span id="l3.133">     aCache[fileName] = aLastModifiedTime || 1;</span>
<a href="#l3.134"></a><span id="l3.134">     this._scheduleCacheSave();</span>
<a href="#l3.135"></a><span id="l3.135"> </span>
<a href="#l3.136"></a><span id="l3.136">     return rv;</span>
<a href="#l3.137"></a><span id="l3.137" class="difflineminus">-  }),</span>
<a href="#l3.138"></a><span id="l3.138" class="difflineplus">+  },</span>
<a href="#l3.139"></a><span id="l3.139"> </span>
<a href="#l3.140"></a><span id="l3.140">   * _worker_indexIMConversation(aJob, aCallbackHandle) {</span>
<a href="#l3.141"></a><span id="l3.141">     let glodaConv = {};</span>
<a href="#l3.142"></a><span id="l3.142">     let existingGlodaConv = aJob.conversation.glodaConv;</span>
<a href="#l3.143"></a><span id="l3.143">     if (existingGlodaConv &amp;&amp;</span>
<a href="#l3.144"></a><span id="l3.144">         existingGlodaConv.path == this._getRelativePath(aJob.path))</span>
<a href="#l3.145"></a><span id="l3.145">       glodaConv.value = aJob.conversation.glodaConv;</span>
<a href="#l3.146"></a><span id="l3.146"> </span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/4b0de666d1a4">4b0de666d1a4</a> at 2020-07-30T19:32:31Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

