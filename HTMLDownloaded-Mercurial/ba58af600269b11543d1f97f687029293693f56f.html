<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 4376:ba58af600269b11543d1f97f687029293693f56f</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ ba58af600269b11543d1f97f687029293693f56f" />
<meta property="og:url" content="/comm-central/rev/ba58af600269b11543d1f97f687029293693f56f" />
<meta property="og:description" content="Bug 527679 - gloda indexing does not properly handle undone message deletions.  cleanup a few deletion issues v1. r=Standard8, a=blocking-thunderbird3" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / ba58af600269b11543d1f97f687029293693f56f 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/ba58af600269b11543d1f97f687029293693f56f">shortlog</a> |
<a href="/comm-central/log/ba58af600269b11543d1f97f687029293693f56f">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/ba58af600269b11543d1f97f687029293693f56f">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/ba58af600269b11543d1f97f687029293693f56f">files</a> |
changeset |
<a href="/comm-central/raw-rev/ba58af600269b11543d1f97f687029293693f56f">raw</a>  | <a href="/comm-central/archive/ba58af600269b11543d1f97f687029293693f56f.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=527679">Bug 527679</a> - gloda indexing does not properly handle undone message deletions.  cleanup a few deletion issues v1. r=Standard8, a=blocking-thunderbird3
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Thu, 12 Nov 2009 03:20:48 -0800</td></tr>

<tr>
 <td>changeset 4376</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/ba58af600269b11543d1f97f687029293693f56f">ba58af600269b11543d1f97f687029293693f56f</a></td>
</tr>



<tr>
<td>parent 4375</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/6165f866e8c0995a062a48add1ef8ab23cd67d6e">6165f866e8c0995a062a48add1ef8ab23cd67d6e</a>
</td>
</tr>

<tr>
<td>child 4377</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/97bdd32faaca211bee9324617acd96513ee98a98">97bdd32faaca211bee9324617acd96513ee98a98</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=ba58af600269b11543d1f97f687029293693f56f">3421</a></td></tr>
<tr><td>push user</td><td>bugmail@asutherland.org</td></tr>
<tr><td>push date</td><td class="date age">Thu, 12 Nov 2009 11:23:29 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@d60c6eb9a7b3 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=d60c6eb9a7b3b4fada627e0d67a65f972ea1b289">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=d60c6eb9a7b3b4fada627e0d67a65f972ea1b289&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=d60c6eb9a7b3b4fada627e0d67a65f972ea1b289&newProject=comm-central&newRevision=6165f866e8c0995a062a48add1ef8ab23cd67d6e&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=d60c6eb9a7b3b4fada627e0d67a65f972ea1b289&newProject=comm-central&newRevision=6165f866e8c0995a062a48add1ef8ab23cd67d6e&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=d60c6eb9a7b3b4fada627e0d67a65f972ea1b289&newProject=comm-central&newRevision=6165f866e8c0995a062a48add1ef8ab23cd67d6e&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28Standard8%29&revcount=50">Standard8</a>, <a href="/comm-central/log?rev=reviewer%28blocking-thunderbird3%29&revcount=50">blocking-thunderbird3</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=527679">527679</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=527679">Bug 527679</a> - gloda indexing does not properly handle undone message deletions.  cleanup a few deletion issues v1. r=Standard8, a=blocking-thunderbird3</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/datamodel.js">mailnews/db/gloda/modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/datastore.js">mailnews/db/gloda/modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/gloda.js">mailnews/db/gloda/modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/index_msg.js">mailnews/db/gloda/modules/index_msg.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/index_msg.js">file</a> |
<a href="/comm-central/annotate/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/index_msg.js">annotate</a> |
<a href="/comm-central/diff/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/index_msg.js">diff</a> |
<a href="/comm-central/comparison/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/index_msg.js">comparison</a> |
<a href="/comm-central/log/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/modules/index_msg.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/test/unit/base_index_messages.js">mailnews/db/gloda/test/unit/base_index_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/test/unit/base_index_messages.js">file</a> |
<a href="/comm-central/annotate/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/test/unit/base_index_messages.js">annotate</a> |
<a href="/comm-central/diff/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/test/unit/base_index_messages.js">diff</a> |
<a href="/comm-central/comparison/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/test/unit/base_index_messages.js">comparison</a> |
<a href="/comm-central/log/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/test/unit/base_index_messages.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">file</a> |
<a href="/comm-central/annotate/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">annotate</a> |
<a href="/comm-central/diff/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">diff</a> |
<a href="/comm-central/comparison/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">comparison</a> |
<a href="/comm-central/log/ba58af600269b11543d1f97f687029293693f56f/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -557,24 +557,61 @@ GlodaMessage.prototype = {</span>
<a href="#l1.4"></a><span id="l1.4"> </span>
<a href="#l1.5"></a><span id="l1.5">   _clone: function gloda_message_clone() {</span>
<a href="#l1.6"></a><span id="l1.6">     return new GlodaMessage(/* datastore */ null, this._id, this._folderID,</span>
<a href="#l1.7"></a><span id="l1.7">       this._messageKey, this._conversationID, this._conversation, this._date,</span>
<a href="#l1.8"></a><span id="l1.8">       this._headerMessageID, this._deleted, this._jsonText, this._notability,</span>
<a href="#l1.9"></a><span id="l1.9">       this._subject, this._indexedBodyText, this._attachmentNames);</span>
<a href="#l1.10"></a><span id="l1.10">   },</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+  /**</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+   * Mark this message as a ghost.  Ghosts are characterized by having no folder</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+   *  id and no message key.  They also are not deleted or they would be of</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+   *  absolutely no use to us.</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+   *</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+   * These changes are suitable for persistence.</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineplus">+   */</span>
<a href="#l1.19"></a><span id="l1.19">   _ghost: function gloda_message_ghost() {</span>
<a href="#l1.20"></a><span id="l1.20">     this._folderID = null;</span>
<a href="#l1.21"></a><span id="l1.21">     this._messageKey = null;</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineminus">-    // a ghost is not deleted</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineminus">-    this._deleted = false;</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineplus">+    if (&quot;_deleted&quot; in this)</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineplus">+      delete this._deleted;</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineplus">+  },</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineplus">+</span>
<a href="#l1.28"></a><span id="l1.28" class="difflineplus">+  /**</span>
<a href="#l1.29"></a><span id="l1.29" class="difflineplus">+   * Are we a ghost (which implies not deleted)?  We are not a ghost if we have</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineplus">+   *  a definite folder location (we may not know our message key in the case</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineplus">+   *  of IMAP moves not fully completed) and are not deleted.</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+   */</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineplus">+  get _isGhost() {</span>
<a href="#l1.34"></a><span id="l1.34" class="difflineplus">+    return this._folderID == null &amp;&amp; !this._isDeleted;</span>
<a href="#l1.35"></a><span id="l1.35">   },</span>
<a href="#l1.36"></a><span id="l1.36"> </span>
<a href="#l1.37"></a><span id="l1.37" class="difflineminus">-  _nuke: function gloda_message_nuke() {</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineplus">+  /**</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineplus">+   * If we were dead, un-dead us.</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineplus">+   */</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineplus">+  _ensureNotDeleted: function gloda_message__ensureNotDeleted() {</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+    if (&quot;_deleted&quot; in this)</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+      delete this._deleted;</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+  },</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineplus">+  /**</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+   * Are we deleted?  This is private because deleted gloda messages are not</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineplus">+   *  visible to non-core-gloda code.</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineplus">+   */</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineplus">+  get _isDeleted() {</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+    return (&quot;_deleted&quot; in this) &amp;&amp; this._deleted;</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineplus">+  },</span>
<a href="#l1.53"></a><span id="l1.53" class="difflineplus">+</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineplus">+  /**</span>
<a href="#l1.55"></a><span id="l1.55" class="difflineplus">+   * Trash this message's in-memory representation because it should no longer</span>
<a href="#l1.56"></a><span id="l1.56" class="difflineplus">+   *  be reachable by any code.  The database record is gone, it's not coming</span>
<a href="#l1.57"></a><span id="l1.57" class="difflineplus">+   *  back.</span>
<a href="#l1.58"></a><span id="l1.58" class="difflineplus">+   */</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineplus">+  _objectPurgedMakeYourselfUnpleasant: function gloda_message_nuke() {</span>
<a href="#l1.60"></a><span id="l1.60">     this._id = null;</span>
<a href="#l1.61"></a><span id="l1.61">     this._folderID = null;</span>
<a href="#l1.62"></a><span id="l1.62">     this._messageKey = null;</span>
<a href="#l1.63"></a><span id="l1.63">     this._conversationID = null;</span>
<a href="#l1.64"></a><span id="l1.64">     this._conversation = null;</span>
<a href="#l1.65"></a><span id="l1.65">     this.date = null;</span>
<a href="#l1.66"></a><span id="l1.66">     this._headerMessageID = null;</span>
<a href="#l1.67"></a><span id="l1.67">   },</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -558,17 +558,17 @@ var GlodaDatastore = {</span>
<a href="#l2.4"></a><span id="l2.4">   kConstraintIn: 1,</span>
<a href="#l2.5"></a><span id="l2.5">   kConstraintRanges: 2,</span>
<a href="#l2.6"></a><span id="l2.6">   kConstraintEquals: 3,</span>
<a href="#l2.7"></a><span id="l2.7">   kConstraintStringLike: 4,</span>
<a href="#l2.8"></a><span id="l2.8">   kConstraintFulltext: 5,</span>
<a href="#l2.9"></a><span id="l2.9"> </span>
<a href="#l2.10"></a><span id="l2.10">   /* ******************* SCHEMA ******************* */</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-  _schemaVersion: 18,</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+  _schemaVersion: 19,</span>
<a href="#l2.14"></a><span id="l2.14">   _schema: {</span>
<a href="#l2.15"></a><span id="l2.15">     tables: {</span>
<a href="#l2.16"></a><span id="l2.16"> </span>
<a href="#l2.17"></a><span id="l2.17">       // ----- Messages</span>
<a href="#l2.18"></a><span id="l2.18">       folderLocations: {</span>
<a href="#l2.19"></a><span id="l2.19">         columns: [</span>
<a href="#l2.20"></a><span id="l2.20">           [&quot;id&quot;, &quot;INTEGER PRIMARY KEY&quot;],</span>
<a href="#l2.21"></a><span id="l2.21">           [&quot;folderURI&quot;, &quot;TEXT NOT NULL&quot;],</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineat">@@ -1073,29 +1073,41 @@ var GlodaDatastore = {</span>
<a href="#l2.23"></a><span id="l2.23">     // - MIME type DB schema overhaul</span>
<a href="#l2.24"></a><span id="l2.24">     // version 15ish, still labeled 13:</span>
<a href="#l2.25"></a><span id="l2.25">     // - change tokenizer to mozporter to support CJK</span>
<a href="#l2.26"></a><span id="l2.26">     // (We are slip-streaming this so that only people who want to test CJK</span>
<a href="#l2.27"></a><span id="l2.27">     //  have to test it.  We will properly bump the schema revision when the</span>
<a href="#l2.28"></a><span id="l2.28">     //  gloda correctness patch lands.)</span>
<a href="#l2.29"></a><span id="l2.29">     // version 16ish, labeled 14 and now 16</span>
<a href="#l2.30"></a><span id="l2.30">     // - gloda message id's start from 32 now</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineminus">-    // - all kinds of correctness changes</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+    // - all kinds of correctness changes (blow away)</span>
<a href="#l2.33"></a><span id="l2.33">     // version 17</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineminus">-    // - more correctness fixes.</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+    // - more correctness fixes. (blow away)</span>
<a href="#l2.36"></a><span id="l2.36">     // version 18</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineminus">-    // - significant empty set support</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineminus">-</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineminus">-    aDBConnection.close();</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineminus">-    aDBFile.remove(false);</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineminus">-    this._log.warn(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineminus">-    return this._createDB(aDBService, aDBFile);</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineminus">-</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineminus">-    //aDBConnection.schemaVersion = aNewVersion;</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineminus">-    //return aDBConnection;</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+    // - significant empty set support (blow away)</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineplus">+    // version 19</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineplus">+    // - there was a typo that was resulting in deleted getting set to the</span>
<a href="#l2.49"></a><span id="l2.49" class="difflineplus">+    //  numeric value of the javascript undefined value.  (migrate-able)</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineplus">+</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineplus">+    // 1) Blow away if it's old enough that we can't patch things up below.</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineplus">+    // 2) Blow away if it's from the future.</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineplus">+    if (aCurVersion &lt; 18 || aCurVersion &gt; aNewVersion) {</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineplus">+      aDBConnection.close();</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+      aDBFile.remove(false);</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+      this._log.warn(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l2.57"></a><span id="l2.57" class="difflineplus">+      return this._createDB(aDBService, aDBFile);</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineplus">+    }</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineplus">+</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineplus">+    this._log.warn(&quot;Global database performing schema update.&quot;);</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineplus">+    // version 19</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineplus">+    aDBConnection.executeSimpleSQL(&quot;UPDATE messages set deleted = 1 WHERE &quot; +</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineplus">+                                   &quot;deleted &lt; 0 or deleted &gt; 1&quot;);</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineplus">+</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineplus">+    aDBConnection.schemaVersion = aNewVersion;</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineplus">+    return aDBConnection;</span>
<a href="#l2.67"></a><span id="l2.67">   },</span>
<a href="#l2.68"></a><span id="l2.68"> </span>
<a href="#l2.69"></a><span id="l2.69">   _outstandingAsyncStatements: [],</span>
<a href="#l2.70"></a><span id="l2.70"> </span>
<a href="#l2.71"></a><span id="l2.71">   _createAsyncStatement: function gloda_ds_createAsyncStatement(aSQLString,</span>
<a href="#l2.72"></a><span id="l2.72">                                                                 aWillFinalize) {</span>
<a href="#l2.73"></a><span id="l2.73">     let statement = null;</span>
<a href="#l2.74"></a><span id="l2.74">     try {</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineat">@@ -2051,31 +2063,26 @@ var GlodaDatastore = {</span>
<a href="#l2.76"></a><span id="l2.76">     else</span>
<a href="#l2.77"></a><span id="l2.77">       ums.bindInt64Parameter(3, aMessage.date * 1000);</span>
<a href="#l2.78"></a><span id="l2.78">     ums.bindStringParameter(4, aMessage.headerMessageID);</span>
<a href="#l2.79"></a><span id="l2.79">     if (aMessage._jsonText)</span>
<a href="#l2.80"></a><span id="l2.80">       ums.bindStringParameter(5, aMessage._jsonText);</span>
<a href="#l2.81"></a><span id="l2.81">     else</span>
<a href="#l2.82"></a><span id="l2.82">       ums.bindNullParameter(5);</span>
<a href="#l2.83"></a><span id="l2.83">     ums.bindInt64Parameter(6, aMessage.notability);</span>
<a href="#l2.84"></a><span id="l2.84" class="difflineminus">-    ums.bindInt64Parameter(7, (&quot;_deleted&quot; in aMessage) &amp;&amp; aMessage.deleted);</span>
<a href="#l2.85"></a><span id="l2.85" class="difflineplus">+    ums.bindInt64Parameter(7, aMessage._isDeleted ? 1 : 0);</span>
<a href="#l2.86"></a><span id="l2.86"> </span>
<a href="#l2.87"></a><span id="l2.87">     ums.executeAsync(this.trackAsync());</span>
<a href="#l2.88"></a><span id="l2.88"> </span>
<a href="#l2.89"></a><span id="l2.89">     if (aMessage.folderID !== null) {</span>
<a href="#l2.90"></a><span id="l2.90">       if (aMessage._isNew === true)</span>
<a href="#l2.91"></a><span id="l2.91">         this._insertMessageText(aMessage);</span>
<a href="#l2.92"></a><span id="l2.92">       else</span>
<a href="#l2.93"></a><span id="l2.93">         this._updateMessageText(aMessage);</span>
<a href="#l2.94"></a><span id="l2.94">     }</span>
<a href="#l2.95"></a><span id="l2.95" class="difflineminus">-</span>
<a href="#l2.96"></a><span id="l2.96" class="difflineminus">-    // In completely abstract theory, this is where we would call</span>
<a href="#l2.97"></a><span id="l2.97" class="difflineminus">-    //  GlodaCollectionManager.itemsModified, except that the attributes may</span>
<a href="#l2.98"></a><span id="l2.98" class="difflineminus">-    //  also have changed, so it's out of our hands.  (Gloda.grokNoun</span>
<a href="#l2.99"></a><span id="l2.99" class="difflineminus">-    //  handles it.)</span>
<a href="#l2.100"></a><span id="l2.100">   },</span>
<a href="#l2.101"></a><span id="l2.101"> </span>
<a href="#l2.102"></a><span id="l2.102">   /**</span>
<a href="#l2.103"></a><span id="l2.103">    * Updates the full-text row associated with this message. This only performs</span>
<a href="#l2.104"></a><span id="l2.104">    * the UPDATE query if the indexed body text has changed, which means that if</span>
<a href="#l2.105"></a><span id="l2.105">    * the body hasn't changed but the attachments have, we don't update.</span>
<a href="#l2.106"></a><span id="l2.106">    */</span>
<a href="#l2.107"></a><span id="l2.107">   _updateMessageText: function gloda_ds__updateMessageText(aMessage) {</span>
<a href="#l2.108"></a><span id="l2.108" class="difflineat">@@ -2237,16 +2244,18 @@ var GlodaDatastore = {</span>
<a href="#l2.109"></a><span id="l2.109">     }</span>
<a href="#l2.110"></a><span id="l2.110">     return new GlodaMessage(this, aRow.getInt64(0), folderId, messageKey,</span>
<a href="#l2.111"></a><span id="l2.111">                             aRow.getInt64(3), null, date, aRow.getString(5),</span>
<a href="#l2.112"></a><span id="l2.112">                             aRow.getInt64(6), jsonText, aRow.getInt64(8),</span>
<a href="#l2.113"></a><span id="l2.113">                             subject, indexedBodyText, attachmentNames);</span>
<a href="#l2.114"></a><span id="l2.114">   },</span>
<a href="#l2.115"></a><span id="l2.115"> </span>
<a href="#l2.116"></a><span id="l2.116">   get _updateMessagesMarkDeletedByFolderID() {</span>
<a href="#l2.117"></a><span id="l2.117" class="difflineplus">+    // When marking deleted clear the folderID and messageKey so that the</span>
<a href="#l2.118"></a><span id="l2.118" class="difflineplus">+    //  indexing process can reuse it without any location constraints.</span>
<a href="#l2.119"></a><span id="l2.119">     let statement = this._createAsyncStatement(</span>
<a href="#l2.120"></a><span id="l2.120">       &quot;UPDATE messages SET folderID = NULL, messageKey = NULL, \</span>
<a href="#l2.121"></a><span id="l2.121">               deleted = 1 WHERE folderID = ?1&quot;);</span>
<a href="#l2.122"></a><span id="l2.122">     this.__defineGetter__(&quot;_updateMessagesMarkDeletedByFolderID&quot;,</span>
<a href="#l2.123"></a><span id="l2.123">       function() statement);</span>
<a href="#l2.124"></a><span id="l2.124">     return this._updateMessagesMarkDeletedByFolderID;</span>
<a href="#l2.125"></a><span id="l2.125">   },</span>
<a href="#l2.126"></a><span id="l2.126"> </span>
<a href="#l2.127"></a><span id="l2.127" class="difflineat">@@ -2275,18 +2284,21 @@ var GlodaDatastore = {</span>
<a href="#l2.128"></a><span id="l2.128"> </span>
<a href="#l2.129"></a><span id="l2.129">   /**</span>
<a href="#l2.130"></a><span id="l2.130">    * Mark all the gloda messages as deleted blind-fire.  Check if any of the</span>
<a href="#l2.131"></a><span id="l2.131">    *  messages are known to the collection manager and update them to be deleted</span>
<a href="#l2.132"></a><span id="l2.132">    *  along with the requisite collection notifications.</span>
<a href="#l2.133"></a><span id="l2.133">    */</span>
<a href="#l2.134"></a><span id="l2.134">   markMessagesDeletedByIDs: function gloda_ds_markMessagesDeletedByIDs(</span>
<a href="#l2.135"></a><span id="l2.135">       aMessageIDs) {</span>
<a href="#l2.136"></a><span id="l2.136" class="difflineminus">-    let sqlString = &quot;UPDATE messages SET deleted = 1 WHERE id IN (&quot; +</span>
<a href="#l2.137"></a><span id="l2.137" class="difflineminus">-      aMessageIDs.join(&quot;,&quot;) + &quot;)&quot;;</span>
<a href="#l2.138"></a><span id="l2.138" class="difflineplus">+    // When marking deleted clear the folderID and messageKey so that the</span>
<a href="#l2.139"></a><span id="l2.139" class="difflineplus">+    //  indexing process can reuse it without any location constraints.</span>
<a href="#l2.140"></a><span id="l2.140" class="difflineplus">+    let sqlString = &quot;UPDATE messages SET folderID = NULL, messageKey = NULL, &quot; +</span>
<a href="#l2.141"></a><span id="l2.141" class="difflineplus">+                     &quot;deleted = 1 WHERE id IN (&quot; +</span>
<a href="#l2.142"></a><span id="l2.142" class="difflineplus">+                     aMessageIDs.join(&quot;,&quot;) + &quot;)&quot;;</span>
<a href="#l2.143"></a><span id="l2.143"> </span>
<a href="#l2.144"></a><span id="l2.144">     let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l2.145"></a><span id="l2.145">     statement.executeAsync(this.trackAsync());</span>
<a href="#l2.146"></a><span id="l2.146">     statement.finalize();</span>
<a href="#l2.147"></a><span id="l2.147"> </span>
<a href="#l2.148"></a><span id="l2.148">     GlodaCollectionManager.itemsDeleted(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l2.149"></a><span id="l2.149">                                         aMessageIDs);</span>
<a href="#l2.150"></a><span id="l2.150">   },</span>
<a href="#l2.151"></a><span id="l2.151" class="difflineat">@@ -2312,16 +2324,20 @@ var GlodaDatastore = {</span>
<a href="#l2.152"></a><span id="l2.152">    *  the message was already marked as deleted and so is not visible to the</span>
<a href="#l2.153"></a><span id="l2.153">    *  collection manager and so nothing needs to be done about that.</span>
<a href="#l2.154"></a><span id="l2.154">    */</span>
<a href="#l2.155"></a><span id="l2.155">   deleteMessageByID: function gloda_ds_deleteMessageByID(aMessageID) {</span>
<a href="#l2.156"></a><span id="l2.156">     let dmbids = this._deleteMessageByIDStatement;</span>
<a href="#l2.157"></a><span id="l2.157">     dmbids.bindInt64Parameter(0, aMessageID);</span>
<a href="#l2.158"></a><span id="l2.158">     dmbids.executeAsync(this.trackAsync());</span>
<a href="#l2.159"></a><span id="l2.159"> </span>
<a href="#l2.160"></a><span id="l2.160" class="difflineplus">+    this.deleteMessageTextByID(aMessageID);</span>
<a href="#l2.161"></a><span id="l2.161" class="difflineplus">+  },</span>
<a href="#l2.162"></a><span id="l2.162" class="difflineplus">+</span>
<a href="#l2.163"></a><span id="l2.163" class="difflineplus">+  deleteMessageTextByID: function gloda_ds_deleteMessageTextByID(aMessageID) {</span>
<a href="#l2.164"></a><span id="l2.164">     let dmt = this._deleteMessageTextByIDStatement;</span>
<a href="#l2.165"></a><span id="l2.165">     dmt.bindInt64Parameter(0, aMessageID);</span>
<a href="#l2.166"></a><span id="l2.166">     dmt.executeAsync(this.trackAsync());</span>
<a href="#l2.167"></a><span id="l2.167">   },</span>
<a href="#l2.168"></a><span id="l2.168"> </span>
<a href="#l2.169"></a><span id="l2.169">   get _folderCompactionStatement() {</span>
<a href="#l2.170"></a><span id="l2.170">     let statement = this._createAsyncStatement(</span>
<a href="#l2.171"></a><span id="l2.171">       &quot;SELECT id, messageKey, headerMessageID FROM messages \</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/db/gloda/modules/gloda.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/gloda.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -49,55 +49,16 @@ Cu.import(&quot;resource://app/modules/gloda/</span>
<a href="#l3.4"></a><span id="l3.4"> Cu.import(&quot;resource://app/modules/gloda/databind.js&quot;);</span>
<a href="#l3.5"></a><span id="l3.5"> Cu.import(&quot;resource://app/modules/gloda/collection.js&quot;);</span>
<a href="#l3.6"></a><span id="l3.6"> Cu.import(&quot;resource://app/modules/gloda/connotent.js&quot;);</span>
<a href="#l3.7"></a><span id="l3.7"> Cu.import(&quot;resource://app/modules/gloda/query.js&quot;);</span>
<a href="#l3.8"></a><span id="l3.8"> Cu.import(&quot;resource://app/modules/gloda/utils.js&quot;);</span>
<a href="#l3.9"></a><span id="l3.9"> </span>
<a href="#l3.10"></a><span id="l3.10"> Cu.import(&quot;resource://app/modules/iteratorUtils.jsm&quot;);</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-let MBM_LOG = Log4Moz.repository.getLogger(&quot;gloda.NS.mbm&quot;);</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">-</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineminus">-/**</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineminus">- * This callback handles processing the asynchronous query results of</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineminus">- *  Gloda.getMessagesByMessageID.</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineminus">- */</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineminus">-function MessagesByMessageIdCallback(aMsgIDToIndex, aResults,</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineminus">-                                     aCallback, aCallbackThis) {</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineminus">-  this.msgIDToIndex = aMsgIDToIndex;</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineminus">-  this.results = aResults;</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineminus">-  this.callback = aCallback;</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineminus">-  this.callbackThis = aCallbackThis;</span>
<a href="#l3.24"></a><span id="l3.24" class="difflineminus">-}</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineminus">-</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineminus">-MessagesByMessageIdCallback.prototype = {</span>
<a href="#l3.27"></a><span id="l3.27" class="difflineminus">-  onItemsAdded: function gloda_ds_mbmi_onItemsAdded(aItems, aCollection) {</span>
<a href="#l3.28"></a><span id="l3.28" class="difflineminus">-    // just outright bail if we are shutdown</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineminus">-    if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineminus">-      return;</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineminus">-</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineminus">-    MBM_LOG.debug(&quot;getting results...&quot;);</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineminus">-    for each (let [, message] in Iterator(aItems)) {</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineminus">-      this.results[this.msgIDToIndex[message.headerMessageID]].push(message);</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineminus">-    }</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineminus">-  },</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineminus">-  onItemsModified: function () {},</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineminus">-  onItemsRemoved: function () {},</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineminus">-  onQueryCompleted: function gloda_ds_mbmi_onQueryCompleted(aCollection) {</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineminus">-    // just outright bail if we are shutdown</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineminus">-    if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineminus">-      return;</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineminus">-</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineminus">-    if (MBM_LOG.level &lt;= Log4Moz.Level.Debug)</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineminus">-      MBM_LOG.debug(&quot;query completed, notifying... &quot; + this.results);</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineminus">-</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineminus">-    this.callback.call(this.callbackThis, this.results);</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineminus">-  }</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineminus">-};</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineminus">-</span>
<a href="#l3.51"></a><span id="l3.51"> /**</span>
<a href="#l3.52"></a><span id="l3.52">  * @see |Gloda.BadItemContentsError|</span>
<a href="#l3.53"></a><span id="l3.53">  */</span>
<a href="#l3.54"></a><span id="l3.54"> function BadItemContentsError(aMessage) {</span>
<a href="#l3.55"></a><span id="l3.55">   this.message = aMessage;</span>
<a href="#l3.56"></a><span id="l3.56"> }</span>
<a href="#l3.57"></a><span id="l3.57"> BadItemContentsError.prototype = {</span>
<a href="#l3.58"></a><span id="l3.58">   toString: function BadItemContentsError_toString() {</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineat">@@ -379,52 +340,16 @@ var Gloda = {</span>
<a href="#l3.60"></a><span id="l3.60">       let messageKeys = [hdr.messageKey for each (hdr in headersForFolder)];</span>
<a href="#l3.61"></a><span id="l3.61">       clause.messageKey.apply(clause, messageKeys);</span>
<a href="#l3.62"></a><span id="l3.62">     }</span>
<a href="#l3.63"></a><span id="l3.63"> </span>
<a href="#l3.64"></a><span id="l3.64">     return query.getCollection(aListener, aData);</span>
<a href="#l3.65"></a><span id="l3.65">   },</span>
<a href="#l3.66"></a><span id="l3.66"> </span>
<a href="#l3.67"></a><span id="l3.67">   /**</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineminus">-   * Given a list of Message-ID's, return a matching list of lists of messages</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineminus">-   *  matching those Message-ID's.  So if you pass an array with three</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineminus">-   *  Message-ID's [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], you would get back an array containing</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineminus">-   *  3 lists, where the first list contains all the messages with a message-id</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineminus">-   *  of &quot;a&quot;, and so forth.  The reason a list is returned rather than null/a</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineminus">-   *  message is that we accept the reality that we have multiple copies of</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineminus">-   *  messages with the same ID.</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineminus">-   * This call is asynchronous because it depends on previously created messages</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineminus">-   *  to be reflected in our results, which requires us to execute on the async</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineminus">-   *  thread where all our writes happen.  This also turns out to be a</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineminus">-   *  reasonable thing because we could imagine pathological cases where there</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineminus">-   *  could be a lot of message-id's and/or a lot of messages with those</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineminus">-   *  message-id's.</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineminus">-   */</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineminus">-  getMessagesByMessageID: function gloda_ns_getMessagesByMessageID(aMessageIDs,</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineminus">-      aCallback, aCallbackThis) {</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineminus">-    let msgIDToIndex = {};</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineminus">-    let results = [];</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineminus">-    for (let iID = 0; iID &lt; aMessageIDs.length; ++iID) {</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineminus">-      let msgID = aMessageIDs[iID];</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineminus">-      results.push([]);</span>
<a href="#l3.89"></a><span id="l3.89" class="difflineminus">-      msgIDToIndex[msgID] = iID;</span>
<a href="#l3.90"></a><span id="l3.90" class="difflineminus">-    }</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineminus">-</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineminus">-    let query = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l3.93"></a><span id="l3.93" class="difflineminus">-      noDbQueryValidityConstraints: true,</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineminus">-    });</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineminus">-    query.headerMessageID.apply(query, aMessageIDs);</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineminus">-    query.frozen = true;</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineminus">-</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineminus">-    let listener = new MessagesByMessageIdCallback(msgIDToIndex, results,</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineminus">-                                                   aCallback, aCallbackThis);</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineminus">-    return query.getCollection(listener, null, {becomeNull: true});</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineminus">-  },</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineminus">-</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineminus">-  /**</span>
<a href="#l3.104"></a><span id="l3.104">    * @testpoint gloda.ns.getMessageContent</span>
<a href="#l3.105"></a><span id="l3.105">    */</span>
<a href="#l3.106"></a><span id="l3.106">   getMessageContent: function gloda_ns_getMessageContent(aGlodaMessage, aMimeMsg) {</span>
<a href="#l3.107"></a><span id="l3.107">     return mimeMsgToContentAndMeta(aMimeMsg, aGlodaMessage.folderMessage.folder)[0];</span>
<a href="#l3.108"></a><span id="l3.108">   },</span>
<a href="#l3.109"></a><span id="l3.109"> </span>
<a href="#l3.110"></a><span id="l3.110">   getFolderForFolder: function gloda_ns_getFolderForFolder(aMsgFolder) {</span>
<a href="#l3.111"></a><span id="l3.111">     return GlodaDatastore._mapFolder(aMsgFolder);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/db/gloda/modules/index_msg.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/index_msg.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -329,16 +329,56 @@ var PendingCommitTracker = {</span>
<a href="#l4.4"></a><span id="l4.4">       if (key.indexOf(uri) == 0) {</span>
<a href="#l4.5"></a><span id="l4.5">         delete this._indexedMessagesPendingCommitByKey[key];</span>
<a href="#l4.6"></a><span id="l4.6">       }</span>
<a href="#l4.7"></a><span id="l4.7">     }</span>
<a href="#l4.8"></a><span id="l4.8">   },</span>
<a href="#l4.9"></a><span id="l4.9"> };</span>
<a href="#l4.10"></a><span id="l4.10"> </span>
<a href="#l4.11"></a><span id="l4.11"> /**</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+ * This callback handles processing the asynchronous query results of</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+ *  |GlodaMsgIndexer.getMessagesByMessageID|.</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+ */</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineplus">+function MessagesByMessageIdCallback(aMsgIDToIndex, aResults,</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineplus">+                                     aCallback, aCallbackThis) {</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineplus">+  this.msgIDToIndex = aMsgIDToIndex;</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineplus">+  this.results = aResults;</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineplus">+  this.callback = aCallback;</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineplus">+  this.callbackThis = aCallbackThis;</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineplus">+}</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineplus">+</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineplus">+MessagesByMessageIdCallback.prototype = {</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineplus">+  _log: Log4Moz.repository.getLogger(&quot;gloda.index_msg.mbm&quot;),</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineplus">+</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineplus">+  onItemsAdded: function gloda_ds_mbmi_onItemsAdded(aItems, aCollection) {</span>
<a href="#l4.27"></a><span id="l4.27" class="difflineplus">+    // just outright bail if we are shutdown</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineplus">+    if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineplus">+      return;</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineplus">+</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+    this._log.debug(&quot;getting results...&quot;);</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+    for each (let [, message] in Iterator(aItems)) {</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+      this.results[this.msgIDToIndex[message.headerMessageID]].push(message);</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+    }</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+  },</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+  onItemsModified: function () {},</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+  onItemsRemoved: function () {},</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+  onQueryCompleted: function gloda_ds_mbmi_onQueryCompleted(aCollection) {</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineplus">+    // just outright bail if we are shutdown</span>
<a href="#l4.40"></a><span id="l4.40" class="difflineplus">+    if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineplus">+      return;</span>
<a href="#l4.42"></a><span id="l4.42" class="difflineplus">+</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineplus">+    if (this._log.level &lt;= Log4Moz.Level.Debug)</span>
<a href="#l4.44"></a><span id="l4.44" class="difflineplus">+      this._log.debug(&quot;query completed, notifying... &quot; + this.results);</span>
<a href="#l4.45"></a><span id="l4.45" class="difflineplus">+</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineplus">+    this.callback.call(this.callbackThis, this.results);</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineplus">+  }</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineplus">+};</span>
<a href="#l4.49"></a><span id="l4.49" class="difflineplus">+</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineplus">+</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineplus">+/**</span>
<a href="#l4.52"></a><span id="l4.52">  * The message indexer!</span>
<a href="#l4.53"></a><span id="l4.53">  *</span>
<a href="#l4.54"></a><span id="l4.54">  * === Message Indexing Strategy</span>
<a href="#l4.55"></a><span id="l4.55">  * To these ends, we implement things like so:</span>
<a href="#l4.56"></a><span id="l4.56">  *</span>
<a href="#l4.57"></a><span id="l4.57">  * Mesage State Tracking</span>
<a href="#l4.58"></a><span id="l4.58">  * - We store a property on all indexed headers indicating their gloda message</span>
<a href="#l4.59"></a><span id="l4.59">  *   id.  This allows us to tell whether a message is indexed from the header,</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineat">@@ -2433,28 +2473,82 @@ var GlodaMsgIndexer = {</span>
<a href="#l4.61"></a><span id="l4.61">     onReadChanged: function(aInstigator) {},</span>
<a href="#l4.62"></a><span id="l4.62">     onJunkScoreChanged: function(aInstigator) {},</span>
<a href="#l4.63"></a><span id="l4.63">     onHdrPropertyChanged: function (aHdrToChange, aPreChange, aStatus,</span>
<a href="#l4.64"></a><span id="l4.64">                                     aInstigator) {},</span>
<a href="#l4.65"></a><span id="l4.65">     onEvent: function (aDB, aEvent) {},</span>
<a href="#l4.66"></a><span id="l4.66">   },</span>
<a href="#l4.67"></a><span id="l4.67"> </span>
<a href="#l4.68"></a><span id="l4.68">   /**</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineplus">+   * Given a list of Message-ID's, return a matching list of lists of messages</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineplus">+   *  matching those Message-ID's.  So if you pass an array with three</span>
<a href="#l4.71"></a><span id="l4.71" class="difflineplus">+   *  Message-ID's [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], you would get back an array containing</span>
<a href="#l4.72"></a><span id="l4.72" class="difflineplus">+   *  3 lists, where the first list contains all the messages with a message-id</span>
<a href="#l4.73"></a><span id="l4.73" class="difflineplus">+   *  of &quot;a&quot;, and so forth.  The reason a list is returned rather than null/a</span>
<a href="#l4.74"></a><span id="l4.74" class="difflineplus">+   *  message is that we accept the reality that we have multiple copies of</span>
<a href="#l4.75"></a><span id="l4.75" class="difflineplus">+   *  messages with the same ID.</span>
<a href="#l4.76"></a><span id="l4.76" class="difflineplus">+   * This call is asynchronous because it depends on previously created messages</span>
<a href="#l4.77"></a><span id="l4.77" class="difflineplus">+   *  to be reflected in our results, which requires us to execute on the async</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineplus">+   *  thread where all our writes happen.  This also turns out to be a</span>
<a href="#l4.79"></a><span id="l4.79" class="difflineplus">+   *  reasonable thing because we could imagine pathological cases where there</span>
<a href="#l4.80"></a><span id="l4.80" class="difflineplus">+   *  could be a lot of message-id's and/or a lot of messages with those</span>
<a href="#l4.81"></a><span id="l4.81" class="difflineplus">+   *  message-id's.</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineplus">+   *</span>
<a href="#l4.83"></a><span id="l4.83" class="difflineplus">+   * The returned collection will include both 'ghost' messages (messages</span>
<a href="#l4.84"></a><span id="l4.84" class="difflineplus">+   *  that exist for conversation-threading purposes only) as well as deleted</span>
<a href="#l4.85"></a><span id="l4.85" class="difflineplus">+   *  messages in addition to the normal 'live' messages that non-privileged</span>
<a href="#l4.86"></a><span id="l4.86" class="difflineplus">+   *  queries might return.</span>
<a href="#l4.87"></a><span id="l4.87" class="difflineplus">+   */</span>
<a href="#l4.88"></a><span id="l4.88" class="difflineplus">+  getMessagesByMessageID: function gloda_ns_getMessagesByMessageID(aMessageIDs,</span>
<a href="#l4.89"></a><span id="l4.89" class="difflineplus">+      aCallback, aCallbackThis) {</span>
<a href="#l4.90"></a><span id="l4.90" class="difflineplus">+    let msgIDToIndex = {};</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineplus">+    let results = [];</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineplus">+    for (let iID = 0; iID &lt; aMessageIDs.length; ++iID) {</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineplus">+      let msgID = aMessageIDs[iID];</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineplus">+      results.push([]);</span>
<a href="#l4.95"></a><span id="l4.95" class="difflineplus">+      msgIDToIndex[msgID] = iID;</span>
<a href="#l4.96"></a><span id="l4.96" class="difflineplus">+    }</span>
<a href="#l4.97"></a><span id="l4.97" class="difflineplus">+</span>
<a href="#l4.98"></a><span id="l4.98" class="difflineplus">+    // (Note: although we are performing a lookup with no validity constraints</span>
<a href="#l4.99"></a><span id="l4.99" class="difflineplus">+    //  and using the same object-relational-mapper-ish layer used by things</span>
<a href="#l4.100"></a><span id="l4.100" class="difflineplus">+    //  that do have constraints, we are not at risk of exposing deleted</span>
<a href="#l4.101"></a><span id="l4.101" class="difflineplus">+    //  messages to other code and getting it confused.  The only way code</span>
<a href="#l4.102"></a><span id="l4.102" class="difflineplus">+    //  can find a message is if it shows up in their queries or gets announced</span>
<a href="#l4.103"></a><span id="l4.103" class="difflineplus">+    //  via GlodaCollectionManager.itemsAdded, neither of which will happen.)</span>
<a href="#l4.104"></a><span id="l4.104" class="difflineplus">+    let query = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l4.105"></a><span id="l4.105" class="difflineplus">+      noDbQueryValidityConstraints: true,</span>
<a href="#l4.106"></a><span id="l4.106" class="difflineplus">+    });</span>
<a href="#l4.107"></a><span id="l4.107" class="difflineplus">+    query.headerMessageID.apply(query, aMessageIDs);</span>
<a href="#l4.108"></a><span id="l4.108" class="difflineplus">+    query.frozen = true;</span>
<a href="#l4.109"></a><span id="l4.109" class="difflineplus">+</span>
<a href="#l4.110"></a><span id="l4.110" class="difflineplus">+    let listener = new MessagesByMessageIdCallback(msgIDToIndex, results,</span>
<a href="#l4.111"></a><span id="l4.111" class="difflineplus">+                                                   aCallback, aCallbackThis);</span>
<a href="#l4.112"></a><span id="l4.112" class="difflineplus">+    return query.getCollection(listener, null, {becomeNull: true});</span>
<a href="#l4.113"></a><span id="l4.113" class="difflineplus">+  },</span>
<a href="#l4.114"></a><span id="l4.114" class="difflineplus">+</span>
<a href="#l4.115"></a><span id="l4.115" class="difflineplus">+  /**</span>
<a href="#l4.116"></a><span id="l4.116">    * A reference to MsgHdrToMimeMessage that unit testing can clobber when it</span>
<a href="#l4.117"></a><span id="l4.117">    *  wants to cause us to hang or inject a fault.  If you are not</span>
<a href="#l4.118"></a><span id="l4.118">    *  glodaTestHelper.js then _do not touch this_.</span>
<a href="#l4.119"></a><span id="l4.119">    */</span>
<a href="#l4.120"></a><span id="l4.120">   _MsgHdrToMimeMessageFunc: MsgHdrToMimeMessage,</span>
<a href="#l4.121"></a><span id="l4.121">   /**</span>
<a href="#l4.122"></a><span id="l4.122">    * Primary message indexing logic.  This method is mainly concerned with</span>
<a href="#l4.123"></a><span id="l4.123">    *  getting all the information about the message required for threading /</span>
<a href="#l4.124"></a><span id="l4.124">    *  conversation building and subsequent processing.  It is responsible for</span>
<a href="#l4.125"></a><span id="l4.125">    *  determining whether to reuse existing gloda messages or whether a new one</span>
<a href="#l4.126"></a><span id="l4.126">    *  should be created.  Most attribute stuff happens in fund_attr.js or</span>
<a href="#l4.127"></a><span id="l4.127">    *  expl_attr.js.</span>
<a href="#l4.128"></a><span id="l4.128" class="difflineplus">+   *</span>
<a href="#l4.129"></a><span id="l4.129" class="difflineplus">+   * Prior to calling this method, the caller must have invoked</span>
<a href="#l4.130"></a><span id="l4.130" class="difflineplus">+   *  |_indexerEnterFolder|, leaving us with the following true invariants</span>
<a href="#l4.131"></a><span id="l4.131" class="difflineplus">+   *  below.</span>
<a href="#l4.132"></a><span id="l4.132" class="difflineplus">+   *</span>
<a href="#l4.133"></a><span id="l4.133" class="difflineplus">+   * @pre aMsgHdr.folder == this._indexingFolder</span>
<a href="#l4.134"></a><span id="l4.134" class="difflineplus">+   * @pre aMsgHdr.folder.msgDatabase == this._indexingDatabase</span>
<a href="#l4.135"></a><span id="l4.135">    */</span>
<a href="#l4.136"></a><span id="l4.136">   _indexMessage: function gloda_indexMessage(aMsgHdr, aCallbackHandle) {</span>
<a href="#l4.137"></a><span id="l4.137">     let logDebug = this._log.level &lt;= Log4Moz.Level.Debug;</span>
<a href="#l4.138"></a><span id="l4.138">     if (logDebug)</span>
<a href="#l4.139"></a><span id="l4.139">       this._log.debug(&quot;*** Indexing message: &quot; + aMsgHdr.messageKey + &quot; : &quot; +</span>
<a href="#l4.140"></a><span id="l4.140">                       aMsgHdr.subject);</span>
<a href="#l4.141"></a><span id="l4.141"> </span>
<a href="#l4.142"></a><span id="l4.142">     // If the message is offline, then get the message body as well</span>
<a href="#l4.143"></a><span id="l4.143" class="difflineat">@@ -2488,18 +2582,18 @@ var GlodaMsgIndexer = {</span>
<a href="#l4.144"></a><span id="l4.144"> </span>
<a href="#l4.145"></a><span id="l4.145">     // - See if any of the ancestors exist and have a conversationID...</span>
<a href="#l4.146"></a><span id="l4.146">     // (references are ordered from old [0] to new [n-1])</span>
<a href="#l4.147"></a><span id="l4.147">     let references = [aMsgHdr.getStringReference(i) for each</span>
<a href="#l4.148"></a><span id="l4.148">                       (i in range(0, aMsgHdr.numReferences))];</span>
<a href="#l4.149"></a><span id="l4.149">     // also see if we already know about the message...</span>
<a href="#l4.150"></a><span id="l4.150">     references.push(aMsgHdr.messageId);</span>
<a href="#l4.151"></a><span id="l4.151"> </span>
<a href="#l4.152"></a><span id="l4.152" class="difflineminus">-    Gloda.getMessagesByMessageID(references, aCallbackHandle.callback,</span>
<a href="#l4.153"></a><span id="l4.153" class="difflineminus">-                                 aCallbackHandle.callbackThis);</span>
<a href="#l4.154"></a><span id="l4.154" class="difflineplus">+    this.getMessagesByMessageID(references, aCallbackHandle.callback,</span>
<a href="#l4.155"></a><span id="l4.155" class="difflineplus">+                                aCallbackHandle.callbackThis);</span>
<a href="#l4.156"></a><span id="l4.156">     // (ancestorLists has a direct correspondence to the message ids)</span>
<a href="#l4.157"></a><span id="l4.157">     let ancestorLists = yield this.kWorkAsync;</span>
<a href="#l4.158"></a><span id="l4.158"> </span>
<a href="#l4.159"></a><span id="l4.159">     if (logDebug) {</span>
<a href="#l4.160"></a><span id="l4.160">       this._log.debug(&quot;ancestors raw: &quot; + ancestorLists);</span>
<a href="#l4.161"></a><span id="l4.161">       this._log.debug(&quot;ref len: &quot; + references.length +</span>
<a href="#l4.162"></a><span id="l4.162">                       &quot; anc len: &quot; + ancestorLists.length);</span>
<a href="#l4.163"></a><span id="l4.163">       this._log.debug(&quot;references: &quot; +</span>
<a href="#l4.164"></a><span id="l4.164" class="difflineat">@@ -2588,17 +2682,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l4.165"></a><span id="l4.165">       this._log.debug(candidateCurMsgs.length + &quot; candidate messages&quot;);</span>
<a href="#l4.166"></a><span id="l4.166">     for (let iCurCand = 0; iCurCand &lt; candidateCurMsgs.length; iCurCand++) {</span>
<a href="#l4.167"></a><span id="l4.167">       let candMsg = candidateCurMsgs[iCurCand];</span>
<a href="#l4.168"></a><span id="l4.168"> </span>
<a href="#l4.169"></a><span id="l4.169">       if (logDebug)</span>
<a href="#l4.170"></a><span id="l4.170">         this._log.debug(&quot;candidate folderID: &quot; + candMsg.folderID +</span>
<a href="#l4.171"></a><span id="l4.171">                         &quot; messageKey: &quot; + candMsg.messageKey);</span>
<a href="#l4.172"></a><span id="l4.172"> </span>
<a href="#l4.173"></a><span id="l4.173" class="difflineminus">-      if (candMsg.folderURI == aMsgHdr.folder.URI) {</span>
<a href="#l4.174"></a><span id="l4.174" class="difflineplus">+      if (candMsg.folderURI == this._indexingFolder.URI) {</span>
<a href="#l4.175"></a><span id="l4.175">         // if we are in the same folder and we have the same message key, we</span>
<a href="#l4.176"></a><span id="l4.176">         //  are definitely the same, stop looking.</span>
<a href="#l4.177"></a><span id="l4.177">         if (candMsg.messageKey == aMsgHdr.messageKey) {</span>
<a href="#l4.178"></a><span id="l4.178">           curMsg = candMsg;</span>
<a href="#l4.179"></a><span id="l4.179">           break;</span>
<a href="#l4.180"></a><span id="l4.180">         }</span>
<a href="#l4.181"></a><span id="l4.181">         // if (we are in the same folder and) the candidate message has a null</span>
<a href="#l4.182"></a><span id="l4.182">         //  message key, we treat it as our best option unless we find an exact</span>
<a href="#l4.183"></a><span id="l4.183" class="difflineat">@@ -2608,68 +2702,70 @@ var GlodaMsgIndexer = {</span>
<a href="#l4.184"></a><span id="l4.184">         //  this path which mandates re-indexing of the message in its entirety)</span>
<a href="#l4.185"></a><span id="l4.185">         if (candMsg.messageKey === null)</span>
<a href="#l4.186"></a><span id="l4.186">           curMsg = candMsg;</span>
<a href="#l4.187"></a><span id="l4.187">         // if (we are in the same folder and) the candidate message's underlying</span>
<a href="#l4.188"></a><span id="l4.188">         //  message no longer exists/matches, we'll assume we are the same but</span>
<a href="#l4.189"></a><span id="l4.189">         //  were betrayed by a re-indexing or something, but we have to make</span>
<a href="#l4.190"></a><span id="l4.190">         //  sure a perfect match doesn't turn up.</span>
<a href="#l4.191"></a><span id="l4.191">         else if ((curMsg === null) &amp;&amp;</span>
<a href="#l4.192"></a><span id="l4.192" class="difflineminus">-                 (aMsgHdr.folder.GetMessageHeader(candMsg.messageKey) === null))</span>
<a href="#l4.193"></a><span id="l4.193" class="difflineplus">+                 !this._indexingDatabase.ContainsKey(candMsg.messageKey))</span>
<a href="#l4.194"></a><span id="l4.194">           curMsg = candMsg;</span>
<a href="#l4.195"></a><span id="l4.195">       }</span>
<a href="#l4.196"></a><span id="l4.196" class="difflineminus">-      // our choice of last resort, but still okay, is a ghost message</span>
<a href="#l4.197"></a><span id="l4.197" class="difflineplus">+      // a ghost/deleted message is fine</span>
<a href="#l4.198"></a><span id="l4.198">       else if ((curMsg === null) &amp;&amp; (candMsg.folderID === null)) {</span>
<a href="#l4.199"></a><span id="l4.199">         curMsg = candMsg;</span>
<a href="#l4.200"></a><span id="l4.200">       }</span>
<a href="#l4.201"></a><span id="l4.201">     }</span>
<a href="#l4.202"></a><span id="l4.202"> </span>
<a href="#l4.203"></a><span id="l4.203">     let attachmentNames = null;</span>
<a href="#l4.204"></a><span id="l4.204">     if (aMimeMsg) {</span>
<a href="#l4.205"></a><span id="l4.205">       attachmentNames = [att.name for each</span>
<a href="#l4.206"></a><span id="l4.206">                          ([i, att] in Iterator(aMimeMsg.allAttachments))</span>
<a href="#l4.207"></a><span id="l4.207">                          if (att.isRealAttachment)];</span>
<a href="#l4.208"></a><span id="l4.208">     }</span>
<a href="#l4.209"></a><span id="l4.209"> </span>
<a href="#l4.210"></a><span id="l4.210" class="difflineminus">-    let isConceptuallyNew, isRecordNew;</span>
<a href="#l4.211"></a><span id="l4.211" class="difflineplus">+    let isConceptuallyNew, isRecordNew, insertFulltext;</span>
<a href="#l4.212"></a><span id="l4.212">     if (curMsg === null) {</span>
<a href="#l4.213"></a><span id="l4.213">       curMsg = this._datastore.createMessage(aMsgHdr.folder,</span>
<a href="#l4.214"></a><span id="l4.214">                                              aMsgHdr.messageKey,</span>
<a href="#l4.215"></a><span id="l4.215">                                              conversationID,</span>
<a href="#l4.216"></a><span id="l4.216">                                              aMsgHdr.date,</span>
<a href="#l4.217"></a><span id="l4.217">                                              aMsgHdr.messageId);</span>
<a href="#l4.218"></a><span id="l4.218">       curMsg._conversation = conversation;</span>
<a href="#l4.219"></a><span id="l4.219" class="difflineminus">-      isConceptuallyNew = isRecordNew = true;</span>
<a href="#l4.220"></a><span id="l4.220" class="difflineplus">+      isConceptuallyNew = isRecordNew = insertFulltext = true;</span>
<a href="#l4.221"></a><span id="l4.221">     }</span>
<a href="#l4.222"></a><span id="l4.222">     else {</span>
<a href="#l4.223"></a><span id="l4.223">       isRecordNew = false;</span>
<a href="#l4.224"></a><span id="l4.224" class="difflineminus">-      isConceptuallyNew = (curMsg._folderID === null); // aka was-a-ghost</span>
<a href="#l4.225"></a><span id="l4.225" class="difflineminus">-      // (messageKey can be null if it's not new in the move-case)</span>
<a href="#l4.226"></a><span id="l4.226" class="difflineplus">+      // the message is conceptually new if it was a ghost or dead.</span>
<a href="#l4.227"></a><span id="l4.227" class="difflineplus">+      isConceptuallyNew = curMsg._isGhost || curMsg._isDeleted;</span>
<a href="#l4.228"></a><span id="l4.228" class="difflineplus">+      // we only insert fulltext if it was a ghost</span>
<a href="#l4.229"></a><span id="l4.229" class="difflineplus">+      insertFulltext = curMsg._isGhost;</span>
<a href="#l4.230"></a><span id="l4.230">       curMsg._folderID = this._datastore._mapFolder(aMsgHdr.folder).id;</span>
<a href="#l4.231"></a><span id="l4.231">       curMsg._messageKey = aMsgHdr.messageKey;</span>
<a href="#l4.232"></a><span id="l4.232">       curMsg.date = new Date(aMsgHdr.date / 1000);</span>
<a href="#l4.233"></a><span id="l4.233" class="difflineplus">+      // the message may have been deleted; tell it to make sure it's not.</span>
<a href="#l4.234"></a><span id="l4.234" class="difflineplus">+      curMsg._ensureNotDeleted();</span>
<a href="#l4.235"></a><span id="l4.235">       // note: we are assuming that our matching logic is flawless in that</span>
<a href="#l4.236"></a><span id="l4.236">       //  if this message was not a ghost, we are assuming the 'body'</span>
<a href="#l4.237"></a><span id="l4.237">       //  associated with the id is still exactly the same.  It is conceivable</span>
<a href="#l4.238"></a><span id="l4.238">       //  that there are cases where this is not true.</span>
<a href="#l4.239"></a><span id="l4.239">     }</span>
<a href="#l4.240"></a><span id="l4.240"> </span>
<a href="#l4.241"></a><span id="l4.241">     if (aMimeMsg) {</span>
<a href="#l4.242"></a><span id="l4.242">       let bodyPlain = aMimeMsg.coerceBodyToPlaintext(aMsgHdr.folder);</span>
<a href="#l4.243"></a><span id="l4.243">       if (bodyPlain) {</span>
<a href="#l4.244"></a><span id="l4.244">         curMsg._bodyLines = bodyPlain.split(/\r?\n/);</span>
<a href="#l4.245"></a><span id="l4.245">         // curMsg._content gets set by fundattr.js</span>
<a href="#l4.246"></a><span id="l4.246">       }</span>
<a href="#l4.247"></a><span id="l4.247">     }</span>
<a href="#l4.248"></a><span id="l4.248"> </span>
<a href="#l4.249"></a><span id="l4.249" class="difflineminus">-    if (isConceptuallyNew) {</span>
<a href="#l4.250"></a><span id="l4.250" class="difflineplus">+    // Mark the message as new (for the purposes of fulltext insertion)</span>
<a href="#l4.251"></a><span id="l4.251" class="difflineplus">+    if (insertFulltext)</span>
<a href="#l4.252"></a><span id="l4.252">       curMsg._isNew = true;</span>
<a href="#l4.253"></a><span id="l4.253" class="difflineminus">-      // curMsg._indexedBodyText is set by GlodaDatastore.insertMessage or</span>
<a href="#l4.254"></a><span id="l4.254" class="difflineminus">-      //  GlodaDatastore.updateMessage</span>
<a href="#l4.255"></a><span id="l4.255" class="difflineminus">-    }</span>
<a href="#l4.256"></a><span id="l4.256"> </span>
<a href="#l4.257"></a><span id="l4.257">     curMsg._subject = aMsgHdr.mime2DecodedSubject;</span>
<a href="#l4.258"></a><span id="l4.258">     curMsg._attachmentNames = attachmentNames;</span>
<a href="#l4.259"></a><span id="l4.259"> </span>
<a href="#l4.260"></a><span id="l4.260">     // curMsg._indexAuthor gets set by fundattr.js</span>
<a href="#l4.261"></a><span id="l4.261">     // curMsg._indexRecipients gets set by fundattr.js</span>
<a href="#l4.262"></a><span id="l4.262"> </span>
<a href="#l4.263"></a><span id="l4.263">     // zero the notability so everything in grokNounItem can just increment</span>
<a href="#l4.264"></a><span id="l4.264" class="difflineat">@@ -2711,80 +2807,93 @@ var GlodaMsgIndexer = {</span>
<a href="#l4.265"></a><span id="l4.265">    *  don't redundantly store attributes, we can deal with the problem by</span>
<a href="#l4.266"></a><span id="l4.266">    *  collecting up all the attributes that accept a message as their object</span>
<a href="#l4.267"></a><span id="l4.267">    *  type and issuing a delete against that.  For example, delete (*, [1,2,3],</span>
<a href="#l4.268"></a><span id="l4.268">    *  message id).</span>
<a href="#l4.269"></a><span id="l4.269">    * (We are punting because we haven't implemented support for generating</span>
<a href="#l4.270"></a><span id="l4.270">    *  attributes like that yet.)</span>
<a href="#l4.271"></a><span id="l4.271">    *</span>
<a href="#l4.272"></a><span id="l4.272">    * @TODO: implement deletion of attributes that reference (deleted) messages</span>
<a href="#l4.273"></a><span id="l4.273" class="difflineminus">-   *</span>
<a href="#l4.274"></a><span id="l4.274" class="difflineminus">-   * @param</span>
<a href="#l4.275"></a><span id="l4.275">    */</span>
<a href="#l4.276"></a><span id="l4.276">   _deleteMessage: function gloda_index_deleteMessage(aMessage,</span>
<a href="#l4.277"></a><span id="l4.277">                                                      aCallbackHandle) {</span>
<a href="#l4.278"></a><span id="l4.278">     let logDebug = this._log.level &lt;= Log4Moz.Level.Debug;</span>
<a href="#l4.279"></a><span id="l4.279">     if (logDebug)</span>
<a href="#l4.280"></a><span id="l4.280">       this._log.debug(&quot;*** Deleting message: &quot; + aMessage);</span>
<a href="#l4.281"></a><span id="l4.281"> </span>
<a href="#l4.282"></a><span id="l4.282">     // -- delete our attributes</span>
<a href="#l4.283"></a><span id="l4.283">     // delete the message's attributes (if we implement the cascade delete, that</span>
<a href="#l4.284"></a><span id="l4.284">     //  could do the honors for us... right now we define the trigger in our</span>
<a href="#l4.285"></a><span id="l4.285">     //  schema but the back-end ignores it)</span>
<a href="#l4.286"></a><span id="l4.286">     GlodaDatastore.clearMessageAttributes(aMessage);</span>
<a href="#l4.287"></a><span id="l4.287"> </span>
<a href="#l4.288"></a><span id="l4.288">     // -- delete our message or ghost us, and maybe nuke the whole conversation</span>
<a href="#l4.289"></a><span id="l4.289" class="difflineminus">-    // look at the other messages in the conversation.</span>
<a href="#l4.290"></a><span id="l4.290" class="difflineplus">+    // Look at the other messages in the conversation.</span>
<a href="#l4.291"></a><span id="l4.291" class="difflineplus">+    // (Note: although we are performing a lookup with no validity constraints</span>
<a href="#l4.292"></a><span id="l4.292" class="difflineplus">+    //  and using the same object-relational-mapper-ish layer used by things</span>
<a href="#l4.293"></a><span id="l4.293" class="difflineplus">+    //  that do have constraints, we are not at risk of exposing deleted</span>
<a href="#l4.294"></a><span id="l4.294" class="difflineplus">+    //  messages to other code and getting it confused.  The only way code</span>
<a href="#l4.295"></a><span id="l4.295" class="difflineplus">+    //  can find a message is if it shows up in their queries or gets announced</span>
<a href="#l4.296"></a><span id="l4.296" class="difflineplus">+    //  via GlodaCollectionManager.itemsAdded, neither of which will happen.)</span>
<a href="#l4.297"></a><span id="l4.297">     let convPrivQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l4.298"></a><span id="l4.298">                                          noDbQueryValidityConstraints: true,</span>
<a href="#l4.299"></a><span id="l4.299">                                        });</span>
<a href="#l4.300"></a><span id="l4.300">     convPrivQuery.conversation(aMessage.conversation);</span>
<a href="#l4.301"></a><span id="l4.301">     let conversationCollection = convPrivQuery.getCollection(aCallbackHandle);</span>
<a href="#l4.302"></a><span id="l4.302">     yield this.kWorkAsync;</span>
<a href="#l4.303"></a><span id="l4.303"> </span>
<a href="#l4.304"></a><span id="l4.304">     let conversationMsgs = conversationCollection.items;</span>
<a href="#l4.305"></a><span id="l4.305"> </span>
<a href="#l4.306"></a><span id="l4.306" class="difflineminus">-    let ghosts = [];</span>
<a href="#l4.307"></a><span id="l4.307" class="difflineminus">-    let twinMessage = null;</span>
<a href="#l4.308"></a><span id="l4.308" class="difflineplus">+    // Count the number of ghosts messages we see to determine if we are</span>
<a href="#l4.309"></a><span id="l4.309" class="difflineplus">+    //  the last message alive.</span>
<a href="#l4.310"></a><span id="l4.310" class="difflineplus">+    let ghostCount = 0;</span>
<a href="#l4.311"></a><span id="l4.311" class="difflineplus">+    let twinMessageExists = false;</span>
<a href="#l4.312"></a><span id="l4.312">     for each (let [, convMsg] in Iterator(conversationMsgs)) {</span>
<a href="#l4.313"></a><span id="l4.313">       // ignore our own message</span>
<a href="#l4.314"></a><span id="l4.314">       if (convMsg.id == aMessage.id)</span>
<a href="#l4.315"></a><span id="l4.315">         continue;</span>
<a href="#l4.316"></a><span id="l4.316"> </span>
<a href="#l4.317"></a><span id="l4.317" class="difflineminus">-      if (convMsg.folderID !== null) {</span>
<a href="#l4.318"></a><span id="l4.318" class="difflineminus">-        if (convMsg.headerMessageID == aMessage.headerMessageID) {</span>
<a href="#l4.319"></a><span id="l4.319" class="difflineminus">-          twinMessage = convMsg;</span>
<a href="#l4.320"></a><span id="l4.320" class="difflineminus">-        }</span>
<a href="#l4.321"></a><span id="l4.321" class="difflineminus">-      }</span>
<a href="#l4.322"></a><span id="l4.322" class="difflineminus">-      else {</span>
<a href="#l4.323"></a><span id="l4.323" class="difflineminus">-        ghosts.push(convMsg);</span>
<a href="#l4.324"></a><span id="l4.324" class="difflineminus">-      }</span>
<a href="#l4.325"></a><span id="l4.325" class="difflineplus">+      if (convMsg._isGhost)</span>
<a href="#l4.326"></a><span id="l4.326" class="difflineplus">+        ghostCount++;</span>
<a href="#l4.327"></a><span id="l4.327" class="difflineplus">+      // This message is our (living) twin if it is not a ghost, not deleted,</span>
<a href="#l4.328"></a><span id="l4.328" class="difflineplus">+      //  and has the same message-id header.</span>
<a href="#l4.329"></a><span id="l4.329" class="difflineplus">+      else if (!convMsg._isDeleted &amp;&amp;</span>
<a href="#l4.330"></a><span id="l4.330" class="difflineplus">+               convMsg.headerMessageID == aMessage.headerMessageID)</span>
<a href="#l4.331"></a><span id="l4.331" class="difflineplus">+        twinMessageExists = true;</span>
<a href="#l4.332"></a><span id="l4.332">     }</span>
<a href="#l4.333"></a><span id="l4.333"> </span>
<a href="#l4.334"></a><span id="l4.334" class="difflineminus">-    // is everyone else a ghost? (note that conversation includes us, but</span>
<a href="#l4.335"></a><span id="l4.335" class="difflineminus">-    //  ghosts cannot)</span>
<a href="#l4.336"></a><span id="l4.336" class="difflineminus">-    if ((conversationMsgs.length - 1) == ghosts.length) {</span>
<a href="#l4.337"></a><span id="l4.337" class="difflineminus">-      // obliterate the conversation including aMessage.</span>
<a href="#l4.338"></a><span id="l4.338" class="difflineminus">-      // since everyone else is a ghost they have no attributes.  however, the</span>
<a href="#l4.339"></a><span id="l4.339" class="difflineminus">-      //  conversation may some day have attributes targeted against it, so it</span>
<a href="#l4.340"></a><span id="l4.340" class="difflineminus">-      //  gets a helper.</span>
<a href="#l4.341"></a><span id="l4.341" class="difflineplus">+    // -- If everyone else is a ghost, blow away the conversation.</span>
<a href="#l4.342"></a><span id="l4.342" class="difflineplus">+    // If there are messages still alive or deleted but we have not yet gotten</span>
<a href="#l4.343"></a><span id="l4.343" class="difflineplus">+    //  to them yet _deleteMessage, then do not do this.  (We will eventually</span>
<a href="#l4.344"></a><span id="l4.344" class="difflineplus">+    //  hit this case if they are all deleted.)</span>
<a href="#l4.345"></a><span id="l4.345" class="difflineplus">+    if ((conversationMsgs.length - 1) == ghostCount) {</span>
<a href="#l4.346"></a><span id="l4.346" class="difflineplus">+      // - Obliterate each message</span>
<a href="#l4.347"></a><span id="l4.347">       for each (let [, msg] in Iterator(conversationMsgs)) {</span>
<a href="#l4.348"></a><span id="l4.348">         GlodaDatastore.deleteMessageByID(msg.id);</span>
<a href="#l4.349"></a><span id="l4.349">       }</span>
<a href="#l4.350"></a><span id="l4.350" class="difflineplus">+      // - Obliterate the conversation</span>
<a href="#l4.351"></a><span id="l4.351">       GlodaDatastore.deleteConversationByID(aMessage.conversationID);</span>
<a href="#l4.352"></a><span id="l4.352" class="difflineminus">-      aMessage._nuke();</span>
<a href="#l4.353"></a><span id="l4.353" class="difflineplus">+      // *no one* should hold a reference or use aMessage after this point,</span>
<a href="#l4.354"></a><span id="l4.354" class="difflineplus">+      //  trash it so such ne'er do'wells are made plain.</span>
<a href="#l4.355"></a><span id="l4.355" class="difflineplus">+      aMessage._objectPurgedMakeYourselfUnpleasant();</span>
<a href="#l4.356"></a><span id="l4.356">     }</span>
<a href="#l4.357"></a><span id="l4.357" class="difflineminus">-    else { // there is at least one real message out there, so the only q is...</span>
<a href="#l4.358"></a><span id="l4.358" class="difflineminus">-      // do we have a twin (so it's okay to delete us) or do we become a ghost?</span>
<a href="#l4.359"></a><span id="l4.359" class="difflineminus">-      if (twinMessage !== null) { // just delete us</span>
<a href="#l4.360"></a><span id="l4.360" class="difflineplus">+    // -- Ghost or purge us as appropriate</span>
<a href="#l4.361"></a><span id="l4.361" class="difflineplus">+    else {</span>
<a href="#l4.362"></a><span id="l4.362" class="difflineplus">+      // Purge us if we have a (living) twin; no ghost required.</span>
<a href="#l4.363"></a><span id="l4.363" class="difflineplus">+      if (twinMessageExists) {</span>
<a href="#l4.364"></a><span id="l4.364">         GlodaDatastore.deleteMessageByID(aMessage.id);</span>
<a href="#l4.365"></a><span id="l4.365" class="difflineminus">-        aMessage._nuke();</span>
<a href="#l4.366"></a><span id="l4.366" class="difflineplus">+        // *no one* should hold a reference or use aMessage after this point,</span>
<a href="#l4.367"></a><span id="l4.367" class="difflineplus">+        //  trash it so such ne'er do'wells are made plain.</span>
<a href="#l4.368"></a><span id="l4.368" class="difflineplus">+        aMessage._objectPurgedMakeYourselfUnpleasant();</span>
<a href="#l4.369"></a><span id="l4.369">       }</span>
<a href="#l4.370"></a><span id="l4.370" class="difflineminus">-      else { // ghost us</span>
<a href="#l4.371"></a><span id="l4.371" class="difflineplus">+      // No twin, a ghost is required, we become the ghost.</span>
<a href="#l4.372"></a><span id="l4.372" class="difflineplus">+      else {</span>
<a href="#l4.373"></a><span id="l4.373">         aMessage._ghost();</span>
<a href="#l4.374"></a><span id="l4.374">         GlodaDatastore.updateMessage(aMessage);</span>
<a href="#l4.375"></a><span id="l4.375" class="difflineplus">+        // ghosts don't have fulltext. purge it.</span>
<a href="#l4.376"></a><span id="l4.376" class="difflineplus">+        GlodaDatastore.deleteMessageTextByID(aMessage.id);</span>
<a href="#l4.377"></a><span id="l4.377">       }</span>
<a href="#l4.378"></a><span id="l4.378">     }</span>
<a href="#l4.379"></a><span id="l4.379"> </span>
<a href="#l4.380"></a><span id="l4.380">     yield this.kWorkDone;</span>
<a href="#l4.381"></a><span id="l4.381">   },</span>
<a href="#l4.382"></a><span id="l4.382"> };</span>
<a href="#l4.383"></a><span id="l4.383"> GlodaIndexer.registerIndexer(GlodaMsgIndexer);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/base_index_messages.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/base_index_messages.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -529,17 +529,17 @@ function test_message_deletion() {</span>
<a href="#l5.4"></a><span id="l5.4">   // make sure the conversation still exists...</span>
<a href="#l5.5"></a><span id="l5.5">   let conv = twinSet.glodaMessages[0].conversation;</span>
<a href="#l5.6"></a><span id="l5.6">   let convQuery = Gloda.newQuery(Gloda.NOUN_CONVERSATION);</span>
<a href="#l5.7"></a><span id="l5.7">   convQuery.id(conv.id);</span>
<a href="#l5.8"></a><span id="l5.8">   let convColl = queryExpect(convQuery, [conv]);</span>
<a href="#l5.9"></a><span id="l5.9">   yield false; // queryExpect is async</span>
<a href="#l5.10"></a><span id="l5.10"> </span>
<a href="#l5.11"></a><span id="l5.11"> </span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-  // -- non-last message, no longer a twin</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+  // -- non-last message, no longer a twin =&gt; ghost</span>
<a href="#l5.14"></a><span id="l5.14">   mark_sub_test_start(&quot;non-last message in conv, no longer a twin&quot;);</span>
<a href="#l5.15"></a><span id="l5.15"> </span>
<a href="#l5.16"></a><span id="l5.16">   // make sure nuking the twin didn't somehow kill them both</span>
<a href="#l5.17"></a><span id="l5.17">   let twinQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l5.18"></a><span id="l5.18">   // (let's search on the message-id now that there is no ambiguity.)</span>
<a href="#l5.19"></a><span id="l5.19">   twinQuery.headerMessageID(twinSet.synMessages[0].messageId);</span>
<a href="#l5.20"></a><span id="l5.20">   let twinColl = queryExpect(twinQuery, twinSet);</span>
<a href="#l5.21"></a><span id="l5.21">   yield false; // queryExpect is async</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineat">@@ -562,16 +562,21 @@ function test_message_deletion() {</span>
<a href="#l5.23"></a><span id="l5.23">   privQuery.headerMessageID(twinSet.synMessages[0].messageId);</span>
<a href="#l5.24"></a><span id="l5.24">   queryExpect(privQuery, twinSet);</span>
<a href="#l5.25"></a><span id="l5.25">   yield false; // queryExpect is async</span>
<a href="#l5.26"></a><span id="l5.26"> </span>
<a href="#l5.27"></a><span id="l5.27">   // force a deletion pass</span>
<a href="#l5.28"></a><span id="l5.28">   GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l5.29"></a><span id="l5.29">   yield wait_for_gloda_indexer([]);</span>
<a href="#l5.30"></a><span id="l5.30"> </span>
<a href="#l5.31"></a><span id="l5.31" class="difflineplus">+  // The message should be marked as a ghost now that the deletion pass.</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+  // Ghosts have no fulltext rows, so check for that.</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineplus">+  yield sqlExpectCount(0, &quot;SELECT COUNT(*) FROM messagesText WHERE docid = ?1&quot;,</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+                       twinSet.glodaMessages[0].id);</span>
<a href="#l5.35"></a><span id="l5.35" class="difflineplus">+</span>
<a href="#l5.36"></a><span id="l5.36">   // it still should show up in the privileged query; it's a ghost!</span>
<a href="#l5.37"></a><span id="l5.37">   let privColl = queryExpect(privQuery, twinSet);</span>
<a href="#l5.38"></a><span id="l5.38">   yield false; // queryExpect is async</span>
<a href="#l5.39"></a><span id="l5.39">   // make sure it looks like a ghost.</span>
<a href="#l5.40"></a><span id="l5.40">   let twinGhost = privColl.items[0];</span>
<a href="#l5.41"></a><span id="l5.41">   do_check_eq(twinGhost._folderID, null);</span>
<a href="#l5.42"></a><span id="l5.42">   do_check_eq(twinGhost._messageKey, null);</span>
<a href="#l5.43"></a><span id="l5.43"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -208,16 +208,42 @@ function _prepareIndexerForTesting() {</span>
<a href="#l6.4"></a><span id="l6.4">   //  tell them to.</span>
<a href="#l6.5"></a><span id="l6.5">   GlodaIndexer._MINIMUM_COMMIT_TIME = 10000000;</span>
<a href="#l6.6"></a><span id="l6.6">   GlodaIndexer._MAXIMUM_COMMIT_TIME = 10000000;</span>
<a href="#l6.7"></a><span id="l6.7"> </span>
<a href="#l6.8"></a><span id="l6.8">   GlodaIndexer._unitTestHookRecover = _indexMessageState._testHookRecover;</span>
<a href="#l6.9"></a><span id="l6.9">   GlodaIndexer._unitTestHookCleanup = _indexMessageState._testHookCleanup;</span>
<a href="#l6.10"></a><span id="l6.10"> }</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+/*</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+ * Add logsploder helpers to let us see what is being passed to the database</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+ *  manipulation functions and what is being extracted.</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+ */</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+if (logHelperHasInterestedListeners) {</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineplus">+  let msgNounDef = GlodaMessage.prototype.NOUN_DEF;</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+  let orig_insertMessage = GlodaDatastore.insertMessage;</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+  GlodaDatastore.insertMessage = msgNounDef.objInsert = function() {</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineplus">+    mark_action(&quot;glodaWrapped&quot;, &quot;insertMessage&quot;, [arguments[0]]);</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineplus">+    return orig_insertMessage.apply(GlodaDatastore, arguments);</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineplus">+  };</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineplus">+</span>
<a href="#l6.24"></a><span id="l6.24" class="difflineplus">+  let orig_updateMessage = GlodaDatastore.updateMessage;</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineplus">+  GlodaDatastore.updateMessage = msgNounDef.objUpdate = function() {</span>
<a href="#l6.26"></a><span id="l6.26" class="difflineplus">+    mark_action(&quot;glodaWrapped&quot;, &quot;updateMessage&quot;, [arguments[0]]);</span>
<a href="#l6.27"></a><span id="l6.27" class="difflineplus">+    return orig_updateMessage.apply(GlodaDatastore, arguments);</span>
<a href="#l6.28"></a><span id="l6.28" class="difflineplus">+  };</span>
<a href="#l6.29"></a><span id="l6.29" class="difflineplus">+</span>
<a href="#l6.30"></a><span id="l6.30" class="difflineplus">+  let orig__messageFromRow = GlodaDatastore._messageFromRow;</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineplus">+  GlodaDatastore._messageFromRow = msgNounDef.objFromRow = function() {</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+    let rv = orig__messageFromRow.apply(GlodaDatastore, arguments);</span>
<a href="#l6.33"></a><span id="l6.33" class="difflineplus">+    mark_action(&quot;glodaWrapped&quot;, &quot;_messageFromRow&quot;, [rv]);</span>
<a href="#l6.34"></a><span id="l6.34" class="difflineplus">+    return rv;</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineplus">+  };</span>
<a href="#l6.36"></a><span id="l6.36" class="difflineplus">+}</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineplus">+</span>
<a href="#l6.38"></a><span id="l6.38"> const _wait_for_gloda_indexer_defaults = {</span>
<a href="#l6.39"></a><span id="l6.39">   verifier: null,</span>
<a href="#l6.40"></a><span id="l6.40">   augment: false,</span>
<a href="#l6.41"></a><span id="l6.41">   deleted: null,</span>
<a href="#l6.42"></a><span id="l6.42"> </span>
<a href="#l6.43"></a><span id="l6.43">   // Things should not be recovering or failing and cleaning up unless the test</span>
<a href="#l6.44"></a><span id="l6.44">   //  is expecting it.</span>
<a href="#l6.45"></a><span id="l6.45">   recovered: 0,</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

