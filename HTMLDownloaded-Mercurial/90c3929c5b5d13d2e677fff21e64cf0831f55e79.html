<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 7784:90c3929c5b5d13d2e677fff21e64cf0831f55e79</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 90c3929c5b5d13d2e677fff21e64cf0831f55e79" />
<meta property="og:url" content="/comm-central/rev/90c3929c5b5d13d2e677fff21e64cf0831f55e79" />
<meta property="og:description" content="Mike Kaganski &lt;mikekaganski@gmail.com&gt;" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 90c3929c5b5d13d2e677fff21e64cf0831f55e79 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/90c3929c5b5d13d2e677fff21e64cf0831f55e79">shortlog</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/90c3929c5b5d13d2e677fff21e64cf0831f55e79">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79">files</a> |
changeset |
<a href="/comm-central/raw-rev/90c3929c5b5d13d2e677fff21e64cf0831f55e79">raw</a>  | <a href="/comm-central/archive/90c3929c5b5d13d2e677fff21e64cf0831f55e79.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
Mike Kaganski &lt;mikekaganski@gmail.com&gt;
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#68;&#97;&#118;&#105;&#100;&#32;&#66;&#105;&#101;&#110;&#118;&#101;&#110;&#117;&#32;&#60;&#98;&#105;&#101;&#110;&#118;&#101;&#110;&#117;&#64;&#110;&#118;&#101;&#110;&#116;&#117;&#114;&#101;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Tue, 17 May 2011 12:27:14 -0700</td></tr>

<tr>
 <td>changeset 7784</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/90c3929c5b5d13d2e677fff21e64cf0831f55e79">90c3929c5b5d13d2e677fff21e64cf0831f55e79</a></td>
</tr>



<tr>
<td>parent 7783</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/ad5f8b0ed1c3aa1114deac05081ed4fec12c199c">ad5f8b0ed1c3aa1114deac05081ed4fec12c199c</a>
</td>
</tr>

<tr>
<td>child 7785</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/e5dbe854dad7e759631216a9a1300aa493459bbf">e5dbe854dad7e759631216a9a1300aa493459bbf</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=90c3929c5b5d13d2e677fff21e64cf0831f55e79">5977</a></td></tr>
<tr><td>push user</td><td>bienvenu@nventure.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 17 May 2011 19:26:38 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@90c3929c5b5d [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=90c3929c5b5d13d2e677fff21e64cf0831f55e79">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=90c3929c5b5d13d2e677fff21e64cf0831f55e79&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=90c3929c5b5d13d2e677fff21e64cf0831f55e79&newProject=comm-central&newRevision=90c3929c5b5d13d2e677fff21e64cf0831f55e79&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=90c3929c5b5d13d2e677fff21e64cf0831f55e79&newProject=comm-central&newRevision=90c3929c5b5d13d2e677fff21e64cf0831f55e79&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=90c3929c5b5d13d2e677fff21e64cf0831f55e79&newProject=comm-central&newRevision=90c3929c5b5d13d2e677fff21e64cf0831f55e79&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">Mike Kaganski &lt;mikekaganski@gmail.com&gt;</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/Makefile.in">mailnews/import/outlook/src/Makefile.in</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/Makefile.in">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/Makefile.in">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/Makefile.in">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/Makefile.in">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/Makefile.in">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiApi.cpp">mailnews/import/outlook/src/MapiApi.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiApi.cpp">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiApi.cpp">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiApi.cpp">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiApi.cpp">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiApi.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiApi.h">mailnews/import/outlook/src/MapiApi.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiApi.h">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiApi.h">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiApi.h">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiApi.h">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiApi.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMessage.cpp">mailnews/import/outlook/src/MapiMessage.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMessage.cpp">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMessage.cpp">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMessage.cpp">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMessage.cpp">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMessage.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMessage.h">mailnews/import/outlook/src/MapiMessage.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMessage.h">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMessage.h">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMessage.h">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMessage.h">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMessage.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMimeTypes.cpp">mailnews/import/outlook/src/MapiMimeTypes.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMimeTypes.cpp">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMimeTypes.cpp">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMimeTypes.cpp">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMimeTypes.cpp">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMimeTypes.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMimeTypes.h">mailnews/import/outlook/src/MapiMimeTypes.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMimeTypes.h">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMimeTypes.h">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMimeTypes.h">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMimeTypes.h">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/MapiMimeTypes.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookCompose.cpp">mailnews/import/outlook/src/nsOutlookCompose.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookCompose.cpp">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookCompose.cpp">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookCompose.cpp">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookCompose.cpp">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookCompose.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookCompose.h">mailnews/import/outlook/src/nsOutlookCompose.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookCompose.h">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookCompose.h">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookCompose.h">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookCompose.h">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookCompose.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookEditor.cpp">mailnews/import/outlook/src/nsOutlookEditor.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookEditor.cpp">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookEditor.cpp">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookEditor.cpp">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookEditor.cpp">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookEditor.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookEditor.h">mailnews/import/outlook/src/nsOutlookEditor.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookEditor.h">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookEditor.h">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookEditor.h">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookEditor.h">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookEditor.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookMail.cpp">mailnews/import/outlook/src/nsOutlookMail.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookMail.cpp">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookMail.cpp">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookMail.cpp">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookMail.cpp">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookMail.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookMail.h">mailnews/import/outlook/src/nsOutlookMail.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookMail.h">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookMail.h">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookMail.h">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookMail.h">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/nsOutlookMail.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfDecoder.cpp">mailnews/import/outlook/src/rtfDecoder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfDecoder.cpp">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfDecoder.cpp">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfDecoder.cpp">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfDecoder.cpp">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfDecoder.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfDecoder.h">mailnews/import/outlook/src/rtfDecoder.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfDecoder.h">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfDecoder.h">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfDecoder.h">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfDecoder.h">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfDecoder.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfMailDecoder.cpp">mailnews/import/outlook/src/rtfMailDecoder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfMailDecoder.cpp">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfMailDecoder.cpp">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfMailDecoder.cpp">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfMailDecoder.cpp">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfMailDecoder.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfMailDecoder.h">mailnews/import/outlook/src/rtfMailDecoder.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfMailDecoder.h">file</a> |
<a href="/comm-central/annotate/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfMailDecoder.h">annotate</a> |
<a href="/comm-central/diff/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfMailDecoder.h">diff</a> |
<a href="/comm-central/comparison/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfMailDecoder.h">comparison</a> |
<a href="/comm-central/log/90c3929c5b5d13d2e677fff21e64cf0831f55e79/mailnews/import/outlook/src/rtfMailDecoder.h">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/import/outlook/src/Makefile.in</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/import/outlook/src/Makefile.in</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -54,14 +54,17 @@ CPPSRCS		= \</span>
<a href="#l1.4"></a><span id="l1.4"> 		nsOutlookStringBundle.cpp	\</span>
<a href="#l1.5"></a><span id="l1.5"> 		nsOutlookImport.cpp		\</span>
<a href="#l1.6"></a><span id="l1.6"> 		nsOutlookSettings.cpp		\</span>
<a href="#l1.7"></a><span id="l1.7"> 		MapiApi.cpp			\</span>
<a href="#l1.8"></a><span id="l1.8"> 		nsOutlookMail.cpp		\</span>
<a href="#l1.9"></a><span id="l1.9"> 		MapiMessage.cpp			\</span>
<a href="#l1.10"></a><span id="l1.10"> 		MapiMimeTypes.cpp		\</span>
<a href="#l1.11"></a><span id="l1.11"> 		nsOutlookCompose.cpp		\</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+		rtfDecoder.cpp		\</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+		rtfMailDecoder.cpp		\</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+		nsOutlookEditor.cpp		\</span>
<a href="#l1.15"></a><span id="l1.15"> 		$(NULL)</span>
<a href="#l1.16"></a><span id="l1.16"> </span>
<a href="#l1.17"></a><span id="l1.17"> # we don't want the shared lib, but we want to force the creation of a static lib.</span>
<a href="#l1.18"></a><span id="l1.18"> FORCE_STATIC_LIB = 1</span>
<a href="#l1.19"></a><span id="l1.19"> </span>
<a href="#l1.20"></a><span id="l1.20"> include $(topsrcdir)/config/rules.mk</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/import/outlook/src/MapiApi.cpp</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/import/outlook/src/MapiApi.cpp</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -33,16 +33,19 @@</span>
<a href="#l2.4"></a><span id="l2.4">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l2.5"></a><span id="l2.5">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l2.6"></a><span id="l2.6">  *</span>
<a href="#l2.7"></a><span id="l2.7">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l2.8"></a><span id="l2.8"> </span>
<a href="#l2.9"></a><span id="l2.9"> #include &quot;MapiDbgLog.h&quot;</span>
<a href="#l2.10"></a><span id="l2.10"> #include &quot;MapiApi.h&quot;</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+#include &lt;sstream&gt;</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+#include &quot;rtfMailDecoder.h&quot;</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+</span>
<a href="#l2.15"></a><span id="l2.15"> #include &quot;prprf.h&quot;</span>
<a href="#l2.16"></a><span id="l2.16"> #include &quot;nsReadableUtils.h&quot;</span>
<a href="#l2.17"></a><span id="l2.17"> #include &quot;nsUnicharUtils.h&quot;</span>
<a href="#l2.18"></a><span id="l2.18"> </span>
<a href="#l2.19"></a><span id="l2.19"> int      CMapiApi::m_clients = 0;</span>
<a href="#l2.20"></a><span id="l2.20"> BOOL    CMapiApi::m_initialized = PR_FALSE;</span>
<a href="#l2.21"></a><span id="l2.21"> nsVoidArray  *CMapiApi::m_pStores = NULL;</span>
<a href="#l2.22"></a><span id="l2.22"> LPMAPISESSION CMapiApi::m_lpSession = NULL;</span>
<a href="#l2.23"></a><span id="l2.23" class="difflineat">@@ -63,106 +66,220 @@ HINSTANCE  CMapiApi::m_hMapi32 = NULL;</span>
<a href="#l2.24"></a><span id="l2.24"> </span>
<a href="#l2.25"></a><span id="l2.25"> LPMAPIUNINITIALIZE    gpMapiUninitialize = NULL;</span>
<a href="#l2.26"></a><span id="l2.26"> LPMAPIINITIALIZE    gpMapiInitialize = NULL;</span>
<a href="#l2.27"></a><span id="l2.27"> LPMAPIALLOCATEBUFFER  gpMapiAllocateBuffer = NULL;</span>
<a href="#l2.28"></a><span id="l2.28"> LPMAPIFREEBUFFER    gpMapiFreeBuffer = NULL;</span>
<a href="#l2.29"></a><span id="l2.29"> LPMAPILOGONEX      gpMapiLogonEx = NULL;</span>
<a href="#l2.30"></a><span id="l2.30"> LPOPENSTREAMONFILE    gpMapiOpenStreamOnFile = NULL;</span>
<a href="#l2.31"></a><span id="l2.31"> </span>
<a href="#l2.32"></a><span id="l2.32" class="difflineminus">-BOOL CMapiApi::LoadMapiEntryPoints( void)</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineplus">+typedef HRESULT (STDMETHODCALLTYPE WRAPCOMPRESSEDRTFSTREAM) (</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+  LPSTREAM lpCompressedRTFStream, ULONG ulFlags, LPSTREAM FAR *lpUncompressedRTFStream);</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+typedef WRAPCOMPRESSEDRTFSTREAM *LPWRAPCOMPRESSEDRTFSTREAM;</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+LPWRAPCOMPRESSEDRTFSTREAM gpWrapCompressedRTFStream = NULL;</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+// WrapCompressedRTFStreamEx related stuff - see http://support.microsoft.com/kb/839560</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineplus">+typedef struct {</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineplus">+  ULONG       size;</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineplus">+  ULONG       ulFlags;</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineplus">+  ULONG       ulInCodePage;</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineplus">+  ULONG       ulOutCodePage;</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineplus">+} RTF_WCSINFO;</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineplus">+typedef struct {</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+  ULONG       size;</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineplus">+  ULONG       ulStreamFlags;</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineplus">+} RTF_WCSRETINFO;</span>
<a href="#l2.49"></a><span id="l2.49" class="difflineplus">+</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineplus">+typedef HRESULT (STDMETHODCALLTYPE WRAPCOMPRESSEDRTFSTREAMEX) (</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineplus">+  LPSTREAM lpCompressedRTFStream, CONST RTF_WCSINFO * pWCSInfo,</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineplus">+  LPSTREAM * lppUncompressedRTFStream, RTF_WCSRETINFO * pRetInfo);</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineplus">+typedef WRAPCOMPRESSEDRTFSTREAMEX *LPWRAPCOMPRESSEDRTFSTREAMEX;</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineplus">+LPWRAPCOMPRESSEDRTFSTREAMEX gpWrapCompressedRTFStreamEx = NULL;</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+BOOL CMapiApi::LoadMapiEntryPoints(void)</span>
<a href="#l2.57"></a><span id="l2.57"> {</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineminus">-  if (!(gpMapiUninitialize = (LPMAPIUNINITIALIZE) GetProcAddress( m_hMapi32, &quot;MAPIUninitialize&quot;)))</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineminus">-    return( FALSE);</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineminus">-  if (!(gpMapiInitialize = (LPMAPIINITIALIZE) GetProcAddress( m_hMapi32, &quot;MAPIInitialize&quot;)))</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineminus">-    return( FALSE);</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineminus">-  if (!(gpMapiAllocateBuffer = (LPMAPIALLOCATEBUFFER) GetProcAddress( m_hMapi32, &quot;MAPIAllocateBuffer&quot;)))</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineminus">-    return( FALSE);</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineminus">-  if (!(gpMapiFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress( m_hMapi32, &quot;MAPIFreeBuffer&quot;)))</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineminus">-    return( FALSE);</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineminus">-  if (!(gpMapiLogonEx = (LPMAPILOGONEX) GetProcAddress( m_hMapi32, &quot;MAPILogonEx&quot;)))</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineminus">-    return( FALSE);</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineminus">-  if (!(gpMapiOpenStreamOnFile = (LPOPENSTREAMONFILE) GetProcAddress( m_hMapi32, &quot;OpenStreamOnFile&quot;)))</span>
<a href="#l2.69"></a><span id="l2.69" class="difflineminus">-    return( FALSE);</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineplus">+  if (!(gpMapiUninitialize = (LPMAPIUNINITIALIZE) GetProcAddress(</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+      m_hMapi32, &quot;MAPIUninitialize&quot;)))</span>
<a href="#l2.72"></a><span id="l2.72" class="difflineplus">+    return FALSE;</span>
<a href="#l2.73"></a><span id="l2.73" class="difflineplus">+  if (!(gpMapiInitialize = (LPMAPIINITIALIZE) GetProcAddress(</span>
<a href="#l2.74"></a><span id="l2.74" class="difflineplus">+      m_hMapi32, &quot;MAPIInitialize&quot;)))</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineplus">+    return FALSE;</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineplus">+  if (!(gpMapiAllocateBuffer = (LPMAPIALLOCATEBUFFER) GetProcAddress(</span>
<a href="#l2.77"></a><span id="l2.77" class="difflineplus">+      m_hMapi32, &quot;MAPIAllocateBuffer&quot;)))</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineplus">+    return FALSE;</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineplus">+  if (!(gpMapiFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress(</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineplus">+      m_hMapi32, &quot;MAPIFreeBuffer&quot;)))</span>
<a href="#l2.81"></a><span id="l2.81" class="difflineplus">+    return FALSE;</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineplus">+  if (!(gpMapiLogonEx = (LPMAPILOGONEX) GetProcAddress(m_hMapi32,</span>
<a href="#l2.83"></a><span id="l2.83" class="difflineplus">+                                                       &quot;MAPILogonEx&quot;)))</span>
<a href="#l2.84"></a><span id="l2.84" class="difflineplus">+    return FALSE;</span>
<a href="#l2.85"></a><span id="l2.85" class="difflineplus">+  if (!(gpMapiOpenStreamOnFile = (LPOPENSTREAMONFILE) GetProcAddress(</span>
<a href="#l2.86"></a><span id="l2.86" class="difflineplus">+      m_hMapi32, &quot;OpenStreamOnFile&quot;)))</span>
<a href="#l2.87"></a><span id="l2.87" class="difflineplus">+    return FALSE;</span>
<a href="#l2.88"></a><span id="l2.88"> </span>
<a href="#l2.89"></a><span id="l2.89" class="difflineminus">-  return( TRUE);</span>
<a href="#l2.90"></a><span id="l2.90" class="difflineplus">+  // Available from the Outlook 2002 post-SP3 hotfix (http://support.microsoft.com/kb/883924/)</span>
<a href="#l2.91"></a><span id="l2.91" class="difflineplus">+  // Exported by msmapi32.dll; so it's unavailable to us using mapi32.dll</span>
<a href="#l2.92"></a><span id="l2.92" class="difflineplus">+  gpWrapCompressedRTFStreamEx = (LPWRAPCOMPRESSEDRTFSTREAMEX) GetProcAddress(</span>
<a href="#l2.93"></a><span id="l2.93" class="difflineplus">+    m_hMapi32, &quot;WrapCompressedRTFStreamEx&quot;);</span>
<a href="#l2.94"></a><span id="l2.94" class="difflineplus">+  // Available always</span>
<a href="#l2.95"></a><span id="l2.95" class="difflineplus">+  gpWrapCompressedRTFStream = (LPWRAPCOMPRESSEDRTFSTREAM) GetProcAddress(</span>
<a href="#l2.96"></a><span id="l2.96" class="difflineplus">+    m_hMapi32, &quot;WrapCompressedRTFStream&quot;);</span>
<a href="#l2.97"></a><span id="l2.97" class="difflineplus">+</span>
<a href="#l2.98"></a><span id="l2.98" class="difflineplus">+  return TRUE;</span>
<a href="#l2.99"></a><span id="l2.99"> }</span>
<a href="#l2.100"></a><span id="l2.100"> </span>
<a href="#l2.101"></a><span id="l2.101" class="difflineminus">-void CMapiApi::MAPIUninitialize( void)</span>
<a href="#l2.102"></a><span id="l2.102" class="difflineplus">+// Gets the PR_RTF_COMPRESSED tag property</span>
<a href="#l2.103"></a><span id="l2.103" class="difflineplus">+// Codepage is used only if the WrapCompressedRTFStreamEx is available</span>
<a href="#l2.104"></a><span id="l2.104" class="difflineplus">+BOOL CMapiApi::GetRTFPropertyDecodedAsUTF16( LPMAPIPROP pProp, nsString&amp; val,</span>
<a href="#l2.105"></a><span id="l2.105" class="difflineplus">+                                            unsigned long&amp; nativeBodyType,</span>
<a href="#l2.106"></a><span id="l2.106" class="difflineplus">+                                            unsigned long codepage)</span>
<a href="#l2.107"></a><span id="l2.107" class="difflineplus">+{</span>
<a href="#l2.108"></a><span id="l2.108" class="difflineplus">+  if (!m_hMapi32 || !(gpWrapCompressedRTFStreamEx || gpWrapCompressedRTFStream))</span>
<a href="#l2.109"></a><span id="l2.109" class="difflineplus">+    return FALSE; // Fallback to the default processing</span>
<a href="#l2.110"></a><span id="l2.110" class="difflineplus">+</span>
<a href="#l2.111"></a><span id="l2.111" class="difflineplus">+  LPSTREAM icstream = 0; // for the compressed stream</span>
<a href="#l2.112"></a><span id="l2.112" class="difflineplus">+  LPSTREAM iunstream = 0; // for the uncompressed stream</span>
<a href="#l2.113"></a><span id="l2.113" class="difflineplus">+  HRESULT hr = pProp-&gt;OpenProperty(PR_RTF_COMPRESSED,</span>
<a href="#l2.114"></a><span id="l2.114" class="difflineplus">+                                   &amp;IID_IStream, STGM_READ | STGM_DIRECT,</span>
<a href="#l2.115"></a><span id="l2.115" class="difflineplus">+                                   0, (LPUNKNOWN *)&amp;icstream);</span>
<a href="#l2.116"></a><span id="l2.116" class="difflineplus">+  if (HR_FAILED(hr))</span>
<a href="#l2.117"></a><span id="l2.117" class="difflineplus">+    return FALSE;</span>
<a href="#l2.118"></a><span id="l2.118" class="difflineplus">+</span>
<a href="#l2.119"></a><span id="l2.119" class="difflineplus">+  if (gpWrapCompressedRTFStreamEx) { // Impossible - we use mapi32.dll!</span>
<a href="#l2.120"></a><span id="l2.120" class="difflineplus">+    RTF_WCSINFO     wcsinfo = {0};</span>
<a href="#l2.121"></a><span id="l2.121" class="difflineplus">+    RTF_WCSRETINFO  retinfo = {0};</span>
<a href="#l2.122"></a><span id="l2.122" class="difflineplus">+</span>
<a href="#l2.123"></a><span id="l2.123" class="difflineplus">+    retinfo.size = sizeof(RTF_WCSRETINFO);</span>
<a href="#l2.124"></a><span id="l2.124" class="difflineplus">+</span>
<a href="#l2.125"></a><span id="l2.125" class="difflineplus">+    wcsinfo.size = sizeof(RTF_WCSINFO);</span>
<a href="#l2.126"></a><span id="l2.126" class="difflineplus">+    wcsinfo.ulFlags = MAPI_NATIVE_BODY;</span>
<a href="#l2.127"></a><span id="l2.127" class="difflineplus">+    wcsinfo.ulInCodePage = codepage;</span>
<a href="#l2.128"></a><span id="l2.128" class="difflineplus">+    wcsinfo.ulOutCodePage = CP_UTF8;</span>
<a href="#l2.129"></a><span id="l2.129" class="difflineplus">+</span>
<a href="#l2.130"></a><span id="l2.130" class="difflineplus">+    if(HR_SUCCEEDED(hr = gpWrapCompressedRTFStreamEx(icstream, &amp;wcsinfo,</span>
<a href="#l2.131"></a><span id="l2.131" class="difflineplus">+                                                     &amp;iunstream, &amp;retinfo)))</span>
<a href="#l2.132"></a><span id="l2.132" class="difflineplus">+      nativeBodyType = retinfo.ulStreamFlags;</span>
<a href="#l2.133"></a><span id="l2.133" class="difflineplus">+  }</span>
<a href="#l2.134"></a><span id="l2.134" class="difflineplus">+  else { // mapi32.dll</span>
<a href="#l2.135"></a><span id="l2.135" class="difflineplus">+    gpWrapCompressedRTFStream(icstream,0,&amp;iunstream);</span>
<a href="#l2.136"></a><span id="l2.136" class="difflineplus">+  }</span>
<a href="#l2.137"></a><span id="l2.137" class="difflineplus">+  icstream-&gt;Release();</span>
<a href="#l2.138"></a><span id="l2.138" class="difflineplus">+</span>
<a href="#l2.139"></a><span id="l2.139" class="difflineplus">+  if(iunstream) { // Succeeded</span>
<a href="#l2.140"></a><span id="l2.140" class="difflineplus">+    std::string streamData;</span>
<a href="#l2.141"></a><span id="l2.141" class="difflineplus">+    // Stream.Stat doesn't work for this stream!</span>
<a href="#l2.142"></a><span id="l2.142" class="difflineplus">+    bool done = false;</span>
<a href="#l2.143"></a><span id="l2.143" class="difflineplus">+    while (!done) {</span>
<a href="#l2.144"></a><span id="l2.144" class="difflineplus">+      // I think 10K is a good guess to minimize the number of reads while keeping memory usage low</span>
<a href="#l2.145"></a><span id="l2.145" class="difflineplus">+      const int bufsize = 10240; </span>
<a href="#l2.146"></a><span id="l2.146" class="difflineplus">+      char buf[bufsize];</span>
<a href="#l2.147"></a><span id="l2.147" class="difflineplus">+      ULONG read;</span>
<a href="#l2.148"></a><span id="l2.148" class="difflineplus">+      hr = iunstream-&gt;Read(buf, bufsize, &amp;read);</span>
<a href="#l2.149"></a><span id="l2.149" class="difflineplus">+      done = (read &lt; bufsize) || (hr != S_OK);</span>
<a href="#l2.150"></a><span id="l2.150" class="difflineplus">+      if (read)</span>
<a href="#l2.151"></a><span id="l2.151" class="difflineplus">+        streamData.append(buf, read);</span>
<a href="#l2.152"></a><span id="l2.152" class="difflineplus">+    }</span>
<a href="#l2.153"></a><span id="l2.153" class="difflineplus">+    iunstream-&gt;Release();</span>
<a href="#l2.154"></a><span id="l2.154" class="difflineplus">+    // if rtf -&gt; convert to plain text.</span>
<a href="#l2.155"></a><span id="l2.155" class="difflineplus">+    if (!gpWrapCompressedRTFStreamEx ||</span>
<a href="#l2.156"></a><span id="l2.156" class="difflineplus">+        (nativeBodyType==MAPI_NATIVE_BODY_TYPE_RTF)) {</span>
<a href="#l2.157"></a><span id="l2.157" class="difflineplus">+      std::stringstream s(streamData);</span>
<a href="#l2.158"></a><span id="l2.158" class="difflineplus">+      CRTFMailDecoder decoder;</span>
<a href="#l2.159"></a><span id="l2.159" class="difflineplus">+      DecodeRTF(s, decoder);</span>
<a href="#l2.160"></a><span id="l2.160" class="difflineplus">+      if (decoder.mode() == CRTFMailDecoder::mHTML)</span>
<a href="#l2.161"></a><span id="l2.161" class="difflineplus">+        nativeBodyType = MAPI_NATIVE_BODY_TYPE_HTML;</span>
<a href="#l2.162"></a><span id="l2.162" class="difflineplus">+      else if (decoder.mode() == CRTFMailDecoder::mText)</span>
<a href="#l2.163"></a><span id="l2.163" class="difflineplus">+        nativeBodyType = MAPI_NATIVE_BODY_TYPE_PLAINTEXT;</span>
<a href="#l2.164"></a><span id="l2.164" class="difflineplus">+      else</span>
<a href="#l2.165"></a><span id="l2.165" class="difflineplus">+        nativeBodyType = MAPI_NATIVE_BODY_TYPE_RTF;</span>
<a href="#l2.166"></a><span id="l2.166" class="difflineplus">+      val.Assign(decoder.text(), decoder.textSize());</span>
<a href="#l2.167"></a><span id="l2.167" class="difflineplus">+    }</span>
<a href="#l2.168"></a><span id="l2.168" class="difflineplus">+    else { // WrapCompressedRTFStreamEx available and original type is not rtf</span>
<a href="#l2.169"></a><span id="l2.169" class="difflineplus">+      CopyUTF8toUTF16(streamData.c_str(), val);</span>
<a href="#l2.170"></a><span id="l2.170" class="difflineplus">+    }</span>
<a href="#l2.171"></a><span id="l2.171" class="difflineplus">+    return TRUE;</span>
<a href="#l2.172"></a><span id="l2.172" class="difflineplus">+  }</span>
<a href="#l2.173"></a><span id="l2.173" class="difflineplus">+  return FALSE;</span>
<a href="#l2.174"></a><span id="l2.174" class="difflineplus">+}</span>
<a href="#l2.175"></a><span id="l2.175" class="difflineplus">+</span>
<a href="#l2.176"></a><span id="l2.176" class="difflineplus">+void CMapiApi::MAPIUninitialize(void)</span>
<a href="#l2.177"></a><span id="l2.177"> {</span>
<a href="#l2.178"></a><span id="l2.178">   if (m_hMapi32 &amp;&amp; gpMapiUninitialize)</span>
<a href="#l2.179"></a><span id="l2.179">     (*gpMapiUninitialize)();</span>
<a href="#l2.180"></a><span id="l2.180"> }</span>
<a href="#l2.181"></a><span id="l2.181"> </span>
<a href="#l2.182"></a><span id="l2.182" class="difflineminus">-HRESULT CMapiApi::MAPIInitialize( LPVOID lpInit)</span>
<a href="#l2.183"></a><span id="l2.183" class="difflineplus">+HRESULT CMapiApi::MAPIInitialize(LPVOID lpInit)</span>
<a href="#l2.184"></a><span id="l2.184"> {</span>
<a href="#l2.185"></a><span id="l2.185" class="difflineminus">-  if (m_hMapi32 &amp;&amp; gpMapiInitialize)</span>
<a href="#l2.186"></a><span id="l2.186" class="difflineminus">-    return( (*gpMapiInitialize)( lpInit));</span>
<a href="#l2.187"></a><span id="l2.187" class="difflineminus">-  return( MAPI_E_NOT_INITIALIZED);</span>
<a href="#l2.188"></a><span id="l2.188" class="difflineplus">+  return (m_hMapi32 &amp;&amp; gpMapiInitialize) ? (*gpMapiInitialize)( lpInit) :</span>
<a href="#l2.189"></a><span id="l2.189" class="difflineplus">+          MAPI_E_NOT_INITIALIZED;</span>
<a href="#l2.190"></a><span id="l2.190"> }</span>
<a href="#l2.191"></a><span id="l2.191"> </span>
<a href="#l2.192"></a><span id="l2.192" class="difflineminus">-SCODE CMapiApi::MAPIAllocateBuffer( ULONG cbSize, LPVOID FAR * lppBuffer)</span>
<a href="#l2.193"></a><span id="l2.193" class="difflineplus">+SCODE CMapiApi::MAPIAllocateBuffer(ULONG cbSize, LPVOID FAR * lppBuffer)</span>
<a href="#l2.194"></a><span id="l2.194"> {</span>
<a href="#l2.195"></a><span id="l2.195" class="difflineminus">-  if (m_hMapi32 &amp;&amp; gpMapiAllocateBuffer)</span>
<a href="#l2.196"></a><span id="l2.196" class="difflineminus">-    return( (*gpMapiAllocateBuffer)( cbSize, lppBuffer));</span>
<a href="#l2.197"></a><span id="l2.197" class="difflineminus">-  return( MAPI_E_NOT_INITIALIZED);</span>
<a href="#l2.198"></a><span id="l2.198" class="difflineplus">+  return (m_hMapi32 &amp;&amp; gpMapiAllocateBuffer) ?</span>
<a href="#l2.199"></a><span id="l2.199" class="difflineplus">+          (*gpMapiAllocateBuffer)(cbSize, lppBuffer) : MAPI_E_NOT_INITIALIZED;</span>
<a href="#l2.200"></a><span id="l2.200" class="difflineplus">+}</span>
<a href="#l2.201"></a><span id="l2.201" class="difflineplus">+</span>
<a href="#l2.202"></a><span id="l2.202" class="difflineplus">+ULONG CMapiApi::MAPIFreeBuffer(LPVOID lpBuff)</span>
<a href="#l2.203"></a><span id="l2.203" class="difflineplus">+{</span>
<a href="#l2.204"></a><span id="l2.204" class="difflineplus">+  return (m_hMapi32 &amp;&amp; gpMapiFreeBuffer) ? (*gpMapiFreeBuffer)(lpBuff) :</span>
<a href="#l2.205"></a><span id="l2.205" class="difflineplus">+          MAPI_E_NOT_INITIALIZED;</span>
<a href="#l2.206"></a><span id="l2.206"> }</span>
<a href="#l2.207"></a><span id="l2.207"> </span>
<a href="#l2.208"></a><span id="l2.208" class="difflineminus">-ULONG CMapiApi::MAPIFreeBuffer( LPVOID lpBuff)</span>
<a href="#l2.209"></a><span id="l2.209" class="difflineplus">+HRESULT CMapiApi::MAPILogonEx(ULONG ulUIParam, LPTSTR lpszProfileName,</span>
<a href="#l2.210"></a><span id="l2.210" class="difflineplus">+                              LPTSTR lpszPassword, FLAGS flFlags,</span>
<a href="#l2.211"></a><span id="l2.211" class="difflineplus">+                              LPMAPISESSION FAR * lppSession)</span>
<a href="#l2.212"></a><span id="l2.212"> {</span>
<a href="#l2.213"></a><span id="l2.213" class="difflineminus">-  if (m_hMapi32 &amp;&amp; gpMapiFreeBuffer)</span>
<a href="#l2.214"></a><span id="l2.214" class="difflineminus">-    return( (*gpMapiFreeBuffer)( lpBuff));</span>
<a href="#l2.215"></a><span id="l2.215" class="difflineminus">-  return( MAPI_E_NOT_INITIALIZED);</span>
<a href="#l2.216"></a><span id="l2.216" class="difflineplus">+  return (m_hMapi32 &amp;&amp; gpMapiLogonEx) ?</span>
<a href="#l2.217"></a><span id="l2.217" class="difflineplus">+    (*gpMapiLogonEx)(ulUIParam, lpszProfileName, lpszPassword, flFlags, lppSession) :</span>
<a href="#l2.218"></a><span id="l2.218" class="difflineplus">+     MAPI_E_NOT_INITIALIZED;</span>
<a href="#l2.219"></a><span id="l2.219"> }</span>
<a href="#l2.220"></a><span id="l2.220"> </span>
<a href="#l2.221"></a><span id="l2.221" class="difflineminus">-HRESULT CMapiApi::MAPILogonEx( ULONG ulUIParam, LPTSTR lpszProfileName, LPTSTR lpszPassword, FLAGS flFlags, LPMAPISESSION FAR * lppSession)</span>
<a href="#l2.222"></a><span id="l2.222" class="difflineplus">+HRESULT CMapiApi::OpenStreamOnFile(LPALLOCATEBUFFER lpAllocateBuffer,</span>
<a href="#l2.223"></a><span id="l2.223" class="difflineplus">+                                   LPFREEBUFFER lpFreeBuffer, ULONG ulFlags,</span>
<a href="#l2.224"></a><span id="l2.224" class="difflineplus">+                                   LPTSTR lpszFileName, LPTSTR lpszPrefix,</span>
<a href="#l2.225"></a><span id="l2.225" class="difflineplus">+                                   LPSTREAM FAR * lppStream)</span>
<a href="#l2.226"></a><span id="l2.226"> {</span>
<a href="#l2.227"></a><span id="l2.227" class="difflineminus">-  if (m_hMapi32 &amp;&amp; gpMapiLogonEx)</span>
<a href="#l2.228"></a><span id="l2.228" class="difflineminus">-    return( (*gpMapiLogonEx)( ulUIParam, lpszProfileName, lpszPassword, flFlags, lppSession));</span>
<a href="#l2.229"></a><span id="l2.229" class="difflineminus">-  return( MAPI_E_NOT_INITIALIZED);</span>
<a href="#l2.230"></a><span id="l2.230" class="difflineminus">-}</span>
<a href="#l2.231"></a><span id="l2.231" class="difflineminus">-</span>
<a href="#l2.232"></a><span id="l2.232" class="difflineminus">-HRESULT CMapiApi::OpenStreamOnFile( LPALLOCATEBUFFER lpAllocateBuffer, LPFREEBUFFER lpFreeBuffer, ULONG ulFlags, LPTSTR lpszFileName, LPTSTR lpszPrefix, LPSTREAM FAR * lppStream)</span>
<a href="#l2.233"></a><span id="l2.233" class="difflineminus">-{</span>
<a href="#l2.234"></a><span id="l2.234" class="difflineminus">-  if (m_hMapi32 &amp;&amp; gpMapiOpenStreamOnFile)</span>
<a href="#l2.235"></a><span id="l2.235" class="difflineminus">-    return( (*gpMapiOpenStreamOnFile)( lpAllocateBuffer, lpFreeBuffer, ulFlags, lpszFileName, lpszPrefix, lppStream));</span>
<a href="#l2.236"></a><span id="l2.236" class="difflineminus">-  return( MAPI_E_NOT_INITIALIZED);</span>
<a href="#l2.237"></a><span id="l2.237" class="difflineplus">+  return (m_hMapi32 &amp;&amp; gpMapiOpenStreamOnFile) ?</span>
<a href="#l2.238"></a><span id="l2.238" class="difflineplus">+    (*gpMapiOpenStreamOnFile)(lpAllocateBuffer, lpFreeBuffer, ulFlags,</span>
<a href="#l2.239"></a><span id="l2.239" class="difflineplus">+                              lpszFileName, lpszPrefix, lppStream) :</span>
<a href="#l2.240"></a><span id="l2.240" class="difflineplus">+    MAPI_E_NOT_INITIALIZED;</span>
<a href="#l2.241"></a><span id="l2.241"> }</span>
<a href="#l2.242"></a><span id="l2.242"> </span>
<a href="#l2.243"></a><span id="l2.243"> void CMapiApi::FreeProws( LPSRowSet prows)</span>
<a href="#l2.244"></a><span id="l2.244"> {</span>
<a href="#l2.245"></a><span id="l2.245">   ULONG    irow;</span>
<a href="#l2.246"></a><span id="l2.246">   if (!prows)</span>
<a href="#l2.247"></a><span id="l2.247">     return;</span>
<a href="#l2.248"></a><span id="l2.248">   for (irow = 0; irow &lt; prows-&gt;cRows; ++irow)</span>
<a href="#l2.249"></a><span id="l2.249" class="difflineminus">-    MAPIFreeBuffer( prows-&gt;aRow[irow].lpProps);</span>
<a href="#l2.250"></a><span id="l2.250" class="difflineminus">-  MAPIFreeBuffer( prows);</span>
<a href="#l2.251"></a><span id="l2.251" class="difflineplus">+    MAPIFreeBuffer(prows-&gt;aRow[irow].lpProps);</span>
<a href="#l2.252"></a><span id="l2.252" class="difflineplus">+  MAPIFreeBuffer(prows);</span>
<a href="#l2.253"></a><span id="l2.253"> }</span>
<a href="#l2.254"></a><span id="l2.254"> </span>
<a href="#l2.255"></a><span id="l2.255"> BOOL CMapiApi::LoadMapi( void)</span>
<a href="#l2.256"></a><span id="l2.256"> {</span>
<a href="#l2.257"></a><span id="l2.257">   if (m_hMapi32)</span>
<a href="#l2.258"></a><span id="l2.258" class="difflineminus">-    return( TRUE);</span>
<a href="#l2.259"></a><span id="l2.259" class="difflineplus">+    return TRUE;</span>
<a href="#l2.260"></a><span id="l2.260"> </span>
<a href="#l2.261"></a><span id="l2.261">   HINSTANCE  hInst = ::LoadLibrary( &quot;MAPI32.DLL&quot;);</span>
<a href="#l2.262"></a><span id="l2.262">   if (!hInst)</span>
<a href="#l2.263"></a><span id="l2.263" class="difflineminus">-    return( FALSE);</span>
<a href="#l2.264"></a><span id="l2.264" class="difflineplus">+    return FALSE;</span>
<a href="#l2.265"></a><span id="l2.265">   FARPROC pProc = GetProcAddress( hInst, &quot;MAPIGetNetscapeVersion&quot;);</span>
<a href="#l2.266"></a><span id="l2.266">   if (pProc) {</span>
<a href="#l2.267"></a><span id="l2.267">     ::FreeLibrary( hInst);</span>
<a href="#l2.268"></a><span id="l2.268">     hInst = ::LoadLibrary( &quot;MAPI32BAK.DLL&quot;);</span>
<a href="#l2.269"></a><span id="l2.269">     if (!hInst)</span>
<a href="#l2.270"></a><span id="l2.270" class="difflineminus">-      return( FALSE);</span>
<a href="#l2.271"></a><span id="l2.271" class="difflineplus">+      return FALSE;</span>
<a href="#l2.272"></a><span id="l2.272">   }</span>
<a href="#l2.273"></a><span id="l2.273"> </span>
<a href="#l2.274"></a><span id="l2.274">   m_hMapi32 = hInst;</span>
<a href="#l2.275"></a><span id="l2.275" class="difflineminus">-  return( LoadMapiEntryPoints());</span>
<a href="#l2.276"></a><span id="l2.276" class="difflineplus">+  return LoadMapiEntryPoints();</span>
<a href="#l2.277"></a><span id="l2.277"> }</span>
<a href="#l2.278"></a><span id="l2.278"> </span>
<a href="#l2.279"></a><span id="l2.279" class="difflineminus">-void CMapiApi::UnloadMapi( void)</span>
<a href="#l2.280"></a><span id="l2.280" class="difflineplus">+void CMapiApi::UnloadMapi(void)</span>
<a href="#l2.281"></a><span id="l2.281"> {</span>
<a href="#l2.282"></a><span id="l2.282">   if (m_hMapi32)</span>
<a href="#l2.283"></a><span id="l2.283">     ::FreeLibrary( m_hMapi32);</span>
<a href="#l2.284"></a><span id="l2.284">   m_hMapi32 = NULL;</span>
<a href="#l2.285"></a><span id="l2.285"> }</span>
<a href="#l2.286"></a><span id="l2.286"> </span>
<a href="#l2.287"></a><span id="l2.287"> CMapiApi::CMapiApi()</span>
<a href="#l2.288"></a><span id="l2.288"> {</span>
<a href="#l2.289"></a><span id="l2.289" class="difflineat">@@ -1103,69 +1220,85 @@ LPSPropValue CMapiApi::GetMapiProperty( </span>
<a href="#l2.290"></a><span id="l2.290"> BOOL CMapiApi::IsLargeProperty( LPSPropValue pVal)</span>
<a href="#l2.291"></a><span id="l2.291"> {</span>
<a href="#l2.292"></a><span id="l2.292">   if ((PROP_TYPE( pVal-&gt;ulPropTag) == PT_ERROR) &amp;&amp; (pVal-&gt;Value.l == E_OUTOFMEMORY)) {</span>
<a href="#l2.293"></a><span id="l2.293">     return( TRUE);</span>
<a href="#l2.294"></a><span id="l2.294">   }</span>
<a href="#l2.295"></a><span id="l2.295">   return( FALSE);</span>
<a href="#l2.296"></a><span id="l2.296"> }</span>
<a href="#l2.297"></a><span id="l2.297"> </span>
<a href="#l2.298"></a><span id="l2.298" class="difflineminus">-BOOL CMapiApi::GetLargeStringProperty( LPMAPIPROP pProp, ULONG tag, nsCString&amp; val)</span>
<a href="#l2.299"></a><span id="l2.299" class="difflineplus">+// The output buffer (result) must be freed with operator delete[]</span>
<a href="#l2.300"></a><span id="l2.300" class="difflineplus">+BOOL CMapiApi::GetLargeProperty( LPMAPIPROP pProp, ULONG tag, void** result)</span>
<a href="#l2.301"></a><span id="l2.301"> {</span>
<a href="#l2.302"></a><span id="l2.302">   LPSTREAM  lpStream;</span>
<a href="#l2.303"></a><span id="l2.303">   HRESULT    hr = pProp-&gt;OpenProperty( tag, &amp;IID_IStream, 0, 0, (LPUNKNOWN *)&amp;lpStream);</span>
<a href="#l2.304"></a><span id="l2.304">   if (HR_FAILED( hr))</span>
<a href="#l2.305"></a><span id="l2.305">     return( FALSE);</span>
<a href="#l2.306"></a><span id="l2.306">   STATSTG    st;</span>
<a href="#l2.307"></a><span id="l2.307">   BOOL bResult = TRUE;</span>
<a href="#l2.308"></a><span id="l2.308">   hr = lpStream-&gt;Stat( &amp;st, STATFLAG_NONAME);</span>
<a href="#l2.309"></a><span id="l2.309">   if (HR_FAILED( hr))</span>
<a href="#l2.310"></a><span id="l2.310">     bResult = FALSE;</span>
<a href="#l2.311"></a><span id="l2.311">   else {</span>
<a href="#l2.312"></a><span id="l2.312">     if (!st.cbSize.QuadPart)</span>
<a href="#l2.313"></a><span id="l2.313">       st.cbSize.QuadPart = 1;</span>
<a href="#l2.314"></a><span id="l2.314" class="difflineminus">-    char *pVal = new char[ (int) st.cbSize.QuadPart + 1];</span>
<a href="#l2.315"></a><span id="l2.315" class="difflineminus">-    // val.SetCapacity( (int) st.cbSize.QuadPart);</span>
<a href="#l2.316"></a><span id="l2.316" class="difflineplus">+    char *pVal = new char[ (int) st.cbSize.QuadPart + 2];</span>
<a href="#l2.317"></a><span id="l2.317">     if (pVal) {</span>
<a href="#l2.318"></a><span id="l2.318">       ULONG  sz;</span>
<a href="#l2.319"></a><span id="l2.319" class="difflineminus">-      hr = lpStream-&gt;Read( pVal, (ULONG) st.cbSize.QuadPart, &amp;sz);</span>
<a href="#l2.320"></a><span id="l2.320" class="difflineminus">-      if (HR_FAILED( hr)) {</span>
<a href="#l2.321"></a><span id="l2.321" class="difflineplus">+      hr = lpStream-&gt;Read(pVal, (ULONG) st.cbSize.QuadPart, &amp;sz);</span>
<a href="#l2.322"></a><span id="l2.322" class="difflineplus">+      if (HR_FAILED(hr)) {</span>
<a href="#l2.323"></a><span id="l2.323">         bResult = FALSE;</span>
<a href="#l2.324"></a><span id="l2.324" class="difflineminus">-        *pVal = 0;</span>
<a href="#l2.325"></a><span id="l2.325" class="difflineminus">-        sz = 0;</span>
<a href="#l2.326"></a><span id="l2.326" class="difflineplus">+        delete[] pVal;</span>
<a href="#l2.327"></a><span id="l2.327">       }</span>
<a href="#l2.328"></a><span id="l2.328" class="difflineminus">-      else</span>
<a href="#l2.329"></a><span id="l2.329" class="difflineminus">-        pVal[(int) st.cbSize.QuadPart] = 0;</span>
<a href="#l2.330"></a><span id="l2.330" class="difflineminus">-      val = pVal;</span>
<a href="#l2.331"></a><span id="l2.331" class="difflineminus">-      delete [] pVal;</span>
<a href="#l2.332"></a><span id="l2.332" class="difflineplus">+      else {</span>
<a href="#l2.333"></a><span id="l2.333" class="difflineplus">+         // Just in case it's a UTF16 string</span>
<a href="#l2.334"></a><span id="l2.334" class="difflineplus">+        pVal[(int) st.cbSize.QuadPart] = pVal[(int) st.cbSize.QuadPart+1] = 0;</span>
<a href="#l2.335"></a><span id="l2.335" class="difflineplus">+        *result = pVal;</span>
<a href="#l2.336"></a><span id="l2.336" class="difflineplus">+      }</span>
<a href="#l2.337"></a><span id="l2.337">     }</span>
<a href="#l2.338"></a><span id="l2.338">     else</span>
<a href="#l2.339"></a><span id="l2.339">       bResult = FALSE;</span>
<a href="#l2.340"></a><span id="l2.340">   }</span>
<a href="#l2.341"></a><span id="l2.341"> </span>
<a href="#l2.342"></a><span id="l2.342">   lpStream-&gt;Release();</span>
<a href="#l2.343"></a><span id="l2.343"> </span>
<a href="#l2.344"></a><span id="l2.344">   return( bResult);</span>
<a href="#l2.345"></a><span id="l2.345"> }</span>
<a href="#l2.346"></a><span id="l2.346"> </span>
<a href="#l2.347"></a><span id="l2.347" class="difflineminus">-BOOL CMapiApi::GetLargeStringProperty( LPMAPIPROP pProp, ULONG tag, nsString&amp; val)</span>
<a href="#l2.348"></a><span id="l2.348" class="difflineplus">+BOOL CMapiApi::GetLargeStringProperty( LPMAPIPROP pProp, ULONG tag, nsCString&amp; val)</span>
<a href="#l2.349"></a><span id="l2.349"> {</span>
<a href="#l2.350"></a><span id="l2.350" class="difflineminus">-  nsCString  result;</span>
<a href="#l2.351"></a><span id="l2.351" class="difflineminus">-  if (GetLargeStringProperty( pProp, tag, result)) {</span>
<a href="#l2.352"></a><span id="l2.352" class="difflineminus">-    CStrToUnicode( result.get(), val);</span>
<a href="#l2.353"></a><span id="l2.353" class="difflineminus">-    return( TRUE);</span>
<a href="#l2.354"></a><span id="l2.354" class="difflineminus">-  }</span>
<a href="#l2.355"></a><span id="l2.355" class="difflineplus">+  void* result;</span>
<a href="#l2.356"></a><span id="l2.356" class="difflineplus">+  if (!GetLargeProperty(pProp, tag, &amp;result))</span>
<a href="#l2.357"></a><span id="l2.357" class="difflineplus">+    return FALSE;</span>
<a href="#l2.358"></a><span id="l2.358" class="difflineplus">+  if (PROP_TYPE(tag) == PT_UNICODE) // unicode string</span>
<a href="#l2.359"></a><span id="l2.359" class="difflineplus">+    LossyCopyUTF16toASCII(static_cast&lt;wchar_t*&gt;(result), val);</span>
<a href="#l2.360"></a><span id="l2.360" class="difflineplus">+  else // either PT_STRING8 or some other binary - use as is</span>
<a href="#l2.361"></a><span id="l2.361" class="difflineplus">+    val.Assign(static_cast&lt;char*&gt;(result));</span>
<a href="#l2.362"></a><span id="l2.362" class="difflineplus">+  delete[] result;</span>
<a href="#l2.363"></a><span id="l2.363" class="difflineplus">+  return TRUE;</span>
<a href="#l2.364"></a><span id="l2.364" class="difflineplus">+}</span>
<a href="#l2.365"></a><span id="l2.365"> </span>
<a href="#l2.366"></a><span id="l2.366" class="difflineminus">-  return( FALSE);</span>
<a href="#l2.367"></a><span id="l2.367" class="difflineplus">+BOOL CMapiApi::GetLargeStringProperty(LPMAPIPROP pProp, ULONG tag, nsString&amp; val)</span>
<a href="#l2.368"></a><span id="l2.368" class="difflineplus">+{</span>
<a href="#l2.369"></a><span id="l2.369" class="difflineplus">+  void* result;</span>
<a href="#l2.370"></a><span id="l2.370" class="difflineplus">+  if (!GetLargeProperty(pProp, tag, &amp;result))</span>
<a href="#l2.371"></a><span id="l2.371" class="difflineplus">+    return FALSE;</span>
<a href="#l2.372"></a><span id="l2.372" class="difflineplus">+  if (PROP_TYPE(tag) == PT_UNICODE) // We already get the unicode string</span>
<a href="#l2.373"></a><span id="l2.373" class="difflineplus">+    val.Assign(static_cast&lt;wchar_t*&gt;(result));</span>
<a href="#l2.374"></a><span id="l2.374" class="difflineplus">+  else // either PT_STRING8 or some other binary</span>
<a href="#l2.375"></a><span id="l2.375" class="difflineplus">+    CStrToUnicode(static_cast&lt;char*&gt;(result), val);</span>
<a href="#l2.376"></a><span id="l2.376" class="difflineplus">+  delete[] result;</span>
<a href="#l2.377"></a><span id="l2.377" class="difflineplus">+  return TRUE;</span>
<a href="#l2.378"></a><span id="l2.378"> }</span>
<a href="#l2.379"></a><span id="l2.379"> // If the value is a string, get it...</span>
<a href="#l2.380"></a><span id="l2.380" class="difflineminus">-BOOL CMapiApi::GetEntryIdFromProp( LPSPropValue pVal, ULONG&amp; cbEntryId, LPENTRYID&amp; lpEntryId, BOOL delVal)</span>
<a href="#l2.381"></a><span id="l2.381" class="difflineplus">+BOOL CMapiApi::GetEntryIdFromProp(LPSPropValue pVal, ULONG&amp; cbEntryId,</span>
<a href="#l2.382"></a><span id="l2.382" class="difflineplus">+                                  LPENTRYID&amp; lpEntryId, BOOL delVal)</span>
<a href="#l2.383"></a><span id="l2.383"> {</span>
<a href="#l2.384"></a><span id="l2.384">   if (!pVal)</span>
<a href="#l2.385"></a><span id="l2.385" class="difflineminus">-    return( FALSE);</span>
<a href="#l2.386"></a><span id="l2.386" class="difflineplus">+    return FALSE;</span>
<a href="#l2.387"></a><span id="l2.387"> </span>
<a href="#l2.388"></a><span id="l2.388">   BOOL bResult = TRUE;</span>
<a href="#l2.389"></a><span id="l2.389">     switch( PROP_TYPE( pVal-&gt;ulPropTag)) {</span>
<a href="#l2.390"></a><span id="l2.390">     case PT_BINARY:</span>
<a href="#l2.391"></a><span id="l2.391">       cbEntryId = pVal-&gt;Value.bin.cb;</span>
<a href="#l2.392"></a><span id="l2.392">       MAPIAllocateBuffer( cbEntryId, (LPVOID *) &amp;lpEntryId);</span>
<a href="#l2.393"></a><span id="l2.393">       memcpy( lpEntryId, pVal-&gt;Value.bin.lpb, cbEntryId);</span>
<a href="#l2.394"></a><span id="l2.394">     break;</span>
<a href="#l2.395"></a><span id="l2.395" class="difflineat">@@ -1174,17 +1307,17 @@ BOOL CMapiApi::GetEntryIdFromProp( LPSPr</span>
<a href="#l2.396"></a><span id="l2.396">       MAPI_TRACE0( &quot;EntryId not in BINARY prop value\n&quot;);</span>
<a href="#l2.397"></a><span id="l2.397">       bResult = FALSE;</span>
<a href="#l2.398"></a><span id="l2.398">         break;</span>
<a href="#l2.399"></a><span id="l2.399">     }</span>
<a href="#l2.400"></a><span id="l2.400"> </span>
<a href="#l2.401"></a><span id="l2.401">   if (pVal &amp;&amp; delVal)</span>
<a href="#l2.402"></a><span id="l2.402">     MAPIFreeBuffer( pVal);</span>
<a href="#l2.403"></a><span id="l2.403"> </span>
<a href="#l2.404"></a><span id="l2.404" class="difflineminus">-  return( bResult);</span>
<a href="#l2.405"></a><span id="l2.405" class="difflineplus">+  return bResult;</span>
<a href="#l2.406"></a><span id="l2.406"> }</span>
<a href="#l2.407"></a><span id="l2.407"> </span>
<a href="#l2.408"></a><span id="l2.408"> BOOL CMapiApi::GetStringFromProp( LPSPropValue pVal, nsCString&amp; val, BOOL delVal)</span>
<a href="#l2.409"></a><span id="l2.409"> {</span>
<a href="#l2.410"></a><span id="l2.410">   BOOL bResult = TRUE;</span>
<a href="#l2.411"></a><span id="l2.411">   if ( pVal &amp;&amp; (PROP_TYPE( pVal-&gt;ulPropTag) == PT_STRING8))</span>
<a href="#l2.412"></a><span id="l2.412">     val = pVal-&gt;Value.lpszA;</span>
<a href="#l2.413"></a><span id="l2.413">   else if ( pVal &amp;&amp; (PROP_TYPE( pVal-&gt;ulPropTag) == PT_UNICODE))</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/import/outlook/src/MapiApi.h</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/import/outlook/src/MapiApi.h</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -49,16 +49,41 @@</span>
<a href="#l3.4"></a><span id="l3.4"> #include &lt;mapidefs.h&gt;</span>
<a href="#l3.5"></a><span id="l3.5"> #include &lt;mapicode.h&gt;</span>
<a href="#l3.6"></a><span id="l3.6"> #include &lt;mapitags.h&gt;</span>
<a href="#l3.7"></a><span id="l3.7"> #include &lt;mapiutil.h&gt;</span>
<a href="#l3.8"></a><span id="l3.8"> // wabutil.h expects mapiutil to define _MAPIUTIL_H but it actually</span>
<a href="#l3.9"></a><span id="l3.9"> // defines _MAPIUTIL_H_</span>
<a href="#l3.10"></a><span id="l3.10"> #define _MAPIUTIL_H</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+#ifndef PR_INTERNET_CPID</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+#define PR_INTERNET_CPID (PROP_TAG(PT_LONG,0x3FDE))</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+#endif</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+#ifndef MAPI_NATIVE_BODY</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+#define MAPI_NATIVE_BODY (0x00010000)</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+#endif</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+#ifndef MAPI_NATIVE_BODY_TYPE_RTF</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+#define MAPI_NATIVE_BODY_TYPE_RTF (0x00000001)</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+#endif</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+#ifndef MAPI_NATIVE_BODY_TYPE_HTML</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineplus">+#define MAPI_NATIVE_BODY_TYPE_HTML (0x00000002)</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineplus">+#endif</span>
<a href="#l3.24"></a><span id="l3.24" class="difflineplus">+#ifndef MAPI_NATIVE_BODY_TYPE_PLAINTEXT</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineplus">+#define MAPI_NATIVE_BODY_TYPE_PLAINTEXT (0x00000004)</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineplus">+#endif</span>
<a href="#l3.27"></a><span id="l3.27" class="difflineplus">+#ifndef PR_BODY_HTML_A</span>
<a href="#l3.28"></a><span id="l3.28" class="difflineplus">+#define PR_BODY_HTML_A (PROP_TAG(PT_STRING8,0x1013))</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineplus">+#endif</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineplus">+#ifndef PR_BODY_HTML_W</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+#define PR_BODY_HTML_W (PROP_TAG(PT_UNICODE,0x1013))</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+#endif</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+#ifndef PR_BODY_HTML</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineplus">+#define PR_BODY_HTML (PROP_TAG(PT_TSTRING,0x1013))</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+#endif</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+</span>
<a href="#l3.37"></a><span id="l3.37"> class CMapiFolderList;</span>
<a href="#l3.38"></a><span id="l3.38"> class CMsgStore;</span>
<a href="#l3.39"></a><span id="l3.39"> class CMapiFolder;</span>
<a href="#l3.40"></a><span id="l3.40"> </span>
<a href="#l3.41"></a><span id="l3.41"> class CMapiContentIter {</span>
<a href="#l3.42"></a><span id="l3.42"> public:</span>
<a href="#l3.43"></a><span id="l3.43">   virtual BOOL HandleContentItem( ULONG oType, ULONG cb, LPENTRYID pEntry) = 0;</span>
<a href="#l3.44"></a><span id="l3.44"> };</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineat">@@ -100,31 +125,37 @@ public:</span>
<a href="#l3.46"></a><span id="l3.46"> </span>
<a href="#l3.47"></a><span id="l3.47">   // Fill in the folders list with the hierarchy from the given</span>
<a href="#l3.48"></a><span id="l3.48">   // message store.</span>
<a href="#l3.49"></a><span id="l3.49">   BOOL  GetStoreFolders( ULONG cbEid, LPENTRYID lpEid, CMapiFolderList&amp; folders, int startDepth);</span>
<a href="#l3.50"></a><span id="l3.50">   BOOL  GetStoreAddressFolders( ULONG cbEid, LPENTRYID lpEid, CMapiFolderList&amp; folders);</span>
<a href="#l3.51"></a><span id="l3.51">   BOOL  OpenStore( ULONG cbEid, LPENTRYID lpEid, LPMDB *ppMdb);</span>
<a href="#l3.52"></a><span id="l3.52"> </span>
<a href="#l3.53"></a><span id="l3.53">   // Iteration</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineminus">-  BOOL  IterateStores( CMapiFolderList&amp; list);</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineminus">-  BOOL  IterateContents( CMapiContentIter *pIter, LPMAPIFOLDER pFolder, ULONG flags = 0);</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineminus">-  BOOL  IterateHierarchy( CMapiHierarchyIter *pIter, LPMAPIFOLDER pFolder, ULONG flags = 0);</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+  BOOL  IterateStores(CMapiFolderList&amp; list);</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+  BOOL  IterateContents(CMapiContentIter *pIter, LPMAPIFOLDER pFolder, ULONG flags = 0);</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+  BOOL  IterateHierarchy(CMapiHierarchyIter *pIter, LPMAPIFOLDER pFolder, ULONG flags = 0);</span>
<a href="#l3.60"></a><span id="l3.60"> </span>
<a href="#l3.61"></a><span id="l3.61">   // Properties</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineminus">-  static LPSPropValue  GetMapiProperty( LPMAPIPROP pProp, ULONG tag);</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineminus">-  static BOOL      GetEntryIdFromProp( LPSPropValue pVal, ULONG&amp; cbEntryId, LPENTRYID&amp; lpEntryId, BOOL delVal = TRUE);</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineminus">-  static BOOL      GetStringFromProp( LPSPropValue pVal, nsCString&amp; val, BOOL delVal = TRUE);</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineminus">-  static BOOL      GetStringFromProp( LPSPropValue pVal, nsString&amp; val, BOOL delVal = TRUE);</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineminus">-  static LONG      GetLongFromProp( LPSPropValue pVal, BOOL delVal = TRUE);</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineminus">-  static BOOL      GetLargeStringProperty( LPMAPIPROP pProp, ULONG tag, nsCString&amp; val);</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineminus">-  static BOOL      GetLargeStringProperty( LPMAPIPROP pProp, ULONG tag, nsString&amp; val);</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineminus">-  static BOOL      IsLargeProperty( LPSPropValue pVal);</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineplus">+  static LPSPropValue  GetMapiProperty(LPMAPIPROP pProp, ULONG tag);</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineplus">+  // If delVal is true, functions will call CMapiApi::MAPIFreeBuffer on pVal.</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineplus">+  static BOOL      GetEntryIdFromProp(LPSPropValue pVal, ULONG&amp; cbEntryId,</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineplus">+                                      LPENTRYID&amp; lpEntryId, BOOL delVal = TRUE);</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineplus">+  static BOOL      GetStringFromProp(LPSPropValue pVal, nsCString&amp; val, BOOL delVal = TRUE);</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineplus">+  static BOOL      GetStringFromProp(LPSPropValue pVal, nsString&amp; val, BOOL delVal = TRUE);</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineplus">+  static LONG      GetLongFromProp(LPSPropValue pVal, BOOL delVal = TRUE);</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineplus">+  static BOOL      GetLargeStringProperty(LPMAPIPROP pProp, ULONG tag, nsCString&amp; val);</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+  static BOOL      GetLargeStringProperty(LPMAPIPROP pProp, ULONG tag, nsString&amp; val);</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineplus">+  static BOOL      IsLargeProperty(LPSPropValue pVal);</span>
<a href="#l3.80"></a><span id="l3.80">   static ULONG    GetEmailPropertyTag(LPMAPIPROP lpProp, LONG nameID);</span>
<a href="#l3.81"></a><span id="l3.81"> </span>
<a href="#l3.82"></a><span id="l3.82" class="difflineplus">+  static BOOL GetRTFPropertyDecodedAsUTF16(LPMAPIPROP pProp, nsString&amp; val,</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineplus">+                                           unsigned long&amp; nativeBodyType,</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineplus">+                                           unsigned long codepage = 0);</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineplus">+</span>
<a href="#l3.86"></a><span id="l3.86">   // Debugging &amp; reporting stuff</span>
<a href="#l3.87"></a><span id="l3.87">   static void      ListProperties( LPMAPIPROP lpProp, BOOL getValues = TRUE);</span>
<a href="#l3.88"></a><span id="l3.88">   static void      ListPropertyValue( LPSPropValue pVal, nsCString&amp; s);</span>
<a href="#l3.89"></a><span id="l3.89"> </span>
<a href="#l3.90"></a><span id="l3.90"> protected:</span>
<a href="#l3.91"></a><span id="l3.91">   BOOL      HandleHierarchyItem( ULONG oType, ULONG cb, LPENTRYID pEntry);</span>
<a href="#l3.92"></a><span id="l3.92">   BOOL      HandleContentsItem( ULONG oType, ULONG cb, LPENTRYID pEntry);</span>
<a href="#l3.93"></a><span id="l3.93">   void      GetStoreInfo( CMapiFolder *pFolder, long *pSzContents);</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineat">@@ -148,20 +179,20 @@ private:</span>
<a href="#l3.95"></a><span id="l3.95">   static int        m_clients;</span>
<a href="#l3.96"></a><span id="l3.96">   static BOOL        m_initialized;</span>
<a href="#l3.97"></a><span id="l3.97">   static nsVoidArray *  m_pStores;</span>
<a href="#l3.98"></a><span id="l3.98">   static LPMAPISESSION  m_lpSession;</span>
<a href="#l3.99"></a><span id="l3.99">   static LPMDB      m_lpMdb;</span>
<a href="#l3.100"></a><span id="l3.100">   static HRESULT      m_lastError;</span>
<a href="#l3.101"></a><span id="l3.101">   static PRUnichar *    m_pUniBuff;</span>
<a href="#l3.102"></a><span id="l3.102">   static int        m_uniBuffLen;</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineplus">+</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineplus">+  static BOOL      GetLargeProperty(LPMAPIPROP pProp, ULONG tag, void** result);</span>
<a href="#l3.105"></a><span id="l3.105"> };</span>
<a href="#l3.106"></a><span id="l3.106"> </span>
<a href="#l3.107"></a><span id="l3.107" class="difflineminus">-</span>
<a href="#l3.108"></a><span id="l3.108" class="difflineminus">-</span>
<a href="#l3.109"></a><span id="l3.109"> class CMapiFolder {</span>
<a href="#l3.110"></a><span id="l3.110"> public:</span>
<a href="#l3.111"></a><span id="l3.111">   CMapiFolder();</span>
<a href="#l3.112"></a><span id="l3.112">   CMapiFolder( const CMapiFolder *pCopyFrom);</span>
<a href="#l3.113"></a><span id="l3.113">   CMapiFolder( const PRUnichar *pDisplayName, ULONG cbEid, LPENTRYID lpEid, int depth, LONG oType = MAPI_FOLDER);</span>
<a href="#l3.114"></a><span id="l3.114">   ~CMapiFolder();</span>
<a href="#l3.115"></a><span id="l3.115"> </span>
<a href="#l3.116"></a><span id="l3.116">   void  SetDoImport( BOOL doIt) { m_doImport = doIt;}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/import/outlook/src/MapiMessage.cpp</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/import/outlook/src/MapiMessage.cpp</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -30,761 +30,1452 @@</span>
<a href="#l4.4"></a><span id="l4.4">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l4.5"></a><span id="l4.5">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l4.6"></a><span id="l4.6">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l4.7"></a><span id="l4.7">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l4.8"></a><span id="l4.8">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l4.9"></a><span id="l4.9">  *</span>
<a href="#l4.10"></a><span id="l4.10">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+#ifndef INITGUID</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+#define INITGUID</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+#endif</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineplus">+</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineplus">+#ifndef USES_IID_IMessage</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineplus">+#define USES_IID_IMessage</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineplus">+#endif</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineplus">+</span>
<a href="#l4.20"></a><span id="l4.20"> #include &quot;nscore.h&quot;</span>
<a href="#l4.21"></a><span id="l4.21"> #include &lt;time.h&gt;</span>
<a href="#l4.22"></a><span id="l4.22"> #include &quot;nsString.h&quot;</span>
<a href="#l4.23"></a><span id="l4.23"> #include &quot;nsDirectoryServiceDefs.h&quot;</span>
<a href="#l4.24"></a><span id="l4.24"> #include &quot;nsMsgUtils.h&quot;</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineplus">+#include &quot;nsMimeTypes.h&quot;</span>
<a href="#l4.26"></a><span id="l4.26"> </span>
<a href="#l4.27"></a><span id="l4.27"> #include &quot;MapiDbgLog.h&quot;</span>
<a href="#l4.28"></a><span id="l4.28"> #include &quot;MapiApi.h&quot;</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineplus">+</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineplus">+#include &quot;MapiMimeTypes.h&quot;</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+#include &lt;algorithm&gt;</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+#include &quot;nsMsgI18N.h&quot;</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+#include &quot;nsICharsetConverterManager.h&quot;</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+#include &quot;nsNetUtil.h&quot;</span>
<a href="#l4.37"></a><span id="l4.37"> #include &quot;MapiMessage.h&quot;</span>
<a href="#l4.38"></a><span id="l4.38"> </span>
<a href="#l4.39"></a><span id="l4.39" class="difflineminus">-#include &quot;MapiMimeTypes.h&quot;</span>
<a href="#l4.40"></a><span id="l4.40" class="difflineplus">+#include &quot;nsOutlookMail.h&quot;</span>
<a href="#l4.41"></a><span id="l4.41"> </span>
<a href="#l4.42"></a><span id="l4.42"> // needed for the call the OpenStreamOnFile</span>
<a href="#l4.43"></a><span id="l4.43"> extern LPMAPIALLOCATEBUFFER gpMapiAllocateBuffer;</span>
<a href="#l4.44"></a><span id="l4.44"> extern LPMAPIFREEBUFFER gpMapiFreeBuffer;</span>
<a href="#l4.45"></a><span id="l4.45"> </span>
<a href="#l4.46"></a><span id="l4.46"> // Sample From line: From - 1 Jan 1965 00:00:00</span>
<a href="#l4.47"></a><span id="l4.47"> </span>
<a href="#l4.48"></a><span id="l4.48"> typedef const char * PC_S8;</span>
<a href="#l4.49"></a><span id="l4.49"> </span>
<a href="#l4.50"></a><span id="l4.50"> static const char * kWhitespace = &quot;\b\t\r\n &quot;;</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineminus">-static const char * sFromLine = &quot;From - &quot;;</span>
<a href="#l4.52"></a><span id="l4.52" class="difflineminus">-static const char * sFromDate = &quot;Mon Jan 1 00:00:00 1965&quot;;</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineminus">-static const char * sDaysOfWeek[7] = {</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineminus">-  &quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;</span>
<a href="#l4.55"></a><span id="l4.55" class="difflineplus">+static const wchar_t * sFromLine = L&quot;From - &quot;;</span>
<a href="#l4.56"></a><span id="l4.56" class="difflineplus">+static const wchar_t * sFromDate = L&quot;Mon Jan 1 00:00:00 1965&quot;;</span>
<a href="#l4.57"></a><span id="l4.57" class="difflineplus">+static const wchar_t * sDaysOfWeek[7] = {</span>
<a href="#l4.58"></a><span id="l4.58" class="difflineplus">+  L&quot;Sun&quot;, L&quot;Mon&quot;, L&quot;Tue&quot;, L&quot;Wed&quot;, L&quot;Thu&quot;, L&quot;Fri&quot;, L&quot;Sat&quot;</span>
<a href="#l4.59"></a><span id="l4.59"> };</span>
<a href="#l4.60"></a><span id="l4.60"> </span>
<a href="#l4.61"></a><span id="l4.61" class="difflineminus">-static const char *sMonths[12] = {</span>
<a href="#l4.62"></a><span id="l4.62" class="difflineminus">-  &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineplus">+static const wchar_t *sMonths[12] = {</span>
<a href="#l4.64"></a><span id="l4.64" class="difflineplus">+  L&quot;Jan&quot;, L&quot;Feb&quot;, L&quot;Mar&quot;, L&quot;Apr&quot;, L&quot;May&quot;, L&quot;Jun&quot;, L&quot;Jul&quot;, L&quot;Aug&quot;, L&quot;Sep&quot;, L&quot;Oct&quot;, L&quot;Nov&quot;, L&quot;Dec&quot;</span>
<a href="#l4.65"></a><span id="l4.65"> };</span>
<a href="#l4.66"></a><span id="l4.66"> </span>
<a href="#l4.67"></a><span id="l4.67" class="difflineplus">+const nsCString CMapiMessage::m_whitespace(kWhitespace);</span>
<a href="#l4.68"></a><span id="l4.68"> </span>
<a href="#l4.69"></a><span id="l4.69"> CMapiMessage::CMapiMessage( LPMESSAGE lpMsg)</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineplus">+  : m_lpMsg(lpMsg), m_pIOService(0), m_dldStateHeadersOnly(false), m_msgFlags(0)</span>
<a href="#l4.71"></a><span id="l4.71"> {</span>
<a href="#l4.72"></a><span id="l4.72" class="difflineminus">-  m_lpMsg = lpMsg;</span>
<a href="#l4.73"></a><span id="l4.73" class="difflineminus">-  m_pAttachTable = NULL;</span>
<a href="#l4.74"></a><span id="l4.74" class="difflineminus">-  m_bMimeEncoding = FALSE;</span>
<a href="#l4.75"></a><span id="l4.75" class="difflineminus">-  m_bMimeVersion = FALSE;</span>
<a href="#l4.76"></a><span id="l4.76" class="difflineminus">-  m_ownsAttachFile = FALSE;</span>
<a href="#l4.77"></a><span id="l4.77" class="difflineminus">-  m_whitespace = kWhitespace;</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineplus">+  nsresult rv;</span>
<a href="#l4.79"></a><span id="l4.79" class="difflineplus">+  NS_WITH_PROXIED_SERVICE(nsIIOService, service, NS_IOSERVICE_CONTRACTID,</span>
<a href="#l4.80"></a><span id="l4.80" class="difflineplus">+                          NS_PROXY_TO_MAIN_THREAD, &amp;rv);</span>
<a href="#l4.81"></a><span id="l4.81" class="difflineplus">+  if (NS_FAILED(rv))</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineplus">+    return;</span>
<a href="#l4.83"></a><span id="l4.83" class="difflineplus">+  NS_IF_ADDREF(m_pIOService = service);</span>
<a href="#l4.84"></a><span id="l4.84" class="difflineplus">+</span>
<a href="#l4.85"></a><span id="l4.85" class="difflineplus">+  FetchHeaders();</span>
<a href="#l4.86"></a><span id="l4.86" class="difflineplus">+  if (ValidState()) {</span>
<a href="#l4.87"></a><span id="l4.87" class="difflineplus">+    BuildFromLine();</span>
<a href="#l4.88"></a><span id="l4.88" class="difflineplus">+    FetchFlags();</span>
<a href="#l4.89"></a><span id="l4.89" class="difflineplus">+    GetDownloadState();</span>
<a href="#l4.90"></a><span id="l4.90" class="difflineplus">+    if (FullMessageDownloaded()) {</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineplus">+      FetchBody();</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineplus">+      ProcessAttachments();</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineplus">+    }</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineplus">+  }</span>
<a href="#l4.95"></a><span id="l4.95"> }</span>
<a href="#l4.96"></a><span id="l4.96"> </span>
<a href="#l4.97"></a><span id="l4.97"> CMapiMessage::~CMapiMessage()</span>
<a href="#l4.98"></a><span id="l4.98"> {</span>
<a href="#l4.99"></a><span id="l4.99" class="difflineminus">-  if (m_pAttachTable)</span>
<a href="#l4.100"></a><span id="l4.100" class="difflineminus">-    m_pAttachTable-&gt;Release();</span>
<a href="#l4.101"></a><span id="l4.101" class="difflineplus">+  ClearAttachments();</span>
<a href="#l4.102"></a><span id="l4.102">   if (m_lpMsg)</span>
<a href="#l4.103"></a><span id="l4.103">     m_lpMsg-&gt;Release();</span>
<a href="#l4.104"></a><span id="l4.104" class="difflineminus">-</span>
<a href="#l4.105"></a><span id="l4.105" class="difflineminus">-  ClearTempAttachFile();</span>
<a href="#l4.106"></a><span id="l4.106" class="difflineplus">+  NS_IF_RELEASE(m_pIOService);</span>
<a href="#l4.107"></a><span id="l4.107"> }</span>
<a href="#l4.108"></a><span id="l4.108"> </span>
<a href="#l4.109"></a><span id="l4.109"> </span>
<a href="#l4.110"></a><span id="l4.110" class="difflineminus">-void CMapiMessage::FormatDateTime( SYSTEMTIME &amp; tm, nsCString&amp; s, BOOL includeTZ)</span>
<a href="#l4.111"></a><span id="l4.111" class="difflineplus">+void CMapiMessage::FormatDateTime( SYSTEMTIME &amp; tm, nsString&amp; s, bool includeTZ)</span>
<a href="#l4.112"></a><span id="l4.112"> {</span>
<a href="#l4.113"></a><span id="l4.113">   long offset = _timezone;</span>
<a href="#l4.114"></a><span id="l4.114">   s += sDaysOfWeek[tm.wDayOfWeek];</span>
<a href="#l4.115"></a><span id="l4.115" class="difflineminus">-  s += &quot;, &quot;;</span>
<a href="#l4.116"></a><span id="l4.116" class="difflineminus">-  s.AppendInt( (PRInt32) tm.wDay);</span>
<a href="#l4.117"></a><span id="l4.117" class="difflineminus">-  s += &quot; &quot;;</span>
<a href="#l4.118"></a><span id="l4.118" class="difflineplus">+  s += L&quot;, &quot;;</span>
<a href="#l4.119"></a><span id="l4.119" class="difflineplus">+  s.AppendInt((PRInt32) tm.wDay);</span>
<a href="#l4.120"></a><span id="l4.120" class="difflineplus">+  s += L&quot; &quot;;</span>
<a href="#l4.121"></a><span id="l4.121">   s += sMonths[tm.wMonth - 1];</span>
<a href="#l4.122"></a><span id="l4.122" class="difflineminus">-  s += &quot; &quot;;</span>
<a href="#l4.123"></a><span id="l4.123" class="difflineminus">-  s.AppendInt( (PRInt32) tm.wYear);</span>
<a href="#l4.124"></a><span id="l4.124" class="difflineminus">-  s += &quot; &quot;;</span>
<a href="#l4.125"></a><span id="l4.125" class="difflineplus">+  s += L&quot; &quot;;</span>
<a href="#l4.126"></a><span id="l4.126" class="difflineplus">+  s.AppendInt((PRInt32) tm.wYear);</span>
<a href="#l4.127"></a><span id="l4.127" class="difflineplus">+  s += L&quot; &quot;;</span>
<a href="#l4.128"></a><span id="l4.128">   int val = tm.wHour;</span>
<a href="#l4.129"></a><span id="l4.129">   if (val &lt; 10)</span>
<a href="#l4.130"></a><span id="l4.130" class="difflineminus">-    s += &quot;0&quot;;</span>
<a href="#l4.131"></a><span id="l4.131" class="difflineminus">-  s.AppendInt( (PRInt32) val);</span>
<a href="#l4.132"></a><span id="l4.132" class="difflineminus">-  s += &quot;:&quot;;</span>
<a href="#l4.133"></a><span id="l4.133" class="difflineplus">+    s += L&quot;0&quot;;</span>
<a href="#l4.134"></a><span id="l4.134" class="difflineplus">+  s.AppendInt((PRInt32) val);</span>
<a href="#l4.135"></a><span id="l4.135" class="difflineplus">+  s += L&quot;:&quot;;</span>
<a href="#l4.136"></a><span id="l4.136">   val = tm.wMinute;</span>
<a href="#l4.137"></a><span id="l4.137">   if (val &lt; 10)</span>
<a href="#l4.138"></a><span id="l4.138" class="difflineminus">-    s += &quot;0&quot;;</span>
<a href="#l4.139"></a><span id="l4.139" class="difflineminus">-  s.AppendInt( (PRInt32) val);</span>
<a href="#l4.140"></a><span id="l4.140" class="difflineminus">-  s += &quot;:&quot;;</span>
<a href="#l4.141"></a><span id="l4.141" class="difflineplus">+    s += L&quot;0&quot;;</span>
<a href="#l4.142"></a><span id="l4.142" class="difflineplus">+  s.AppendInt((PRInt32) val);</span>
<a href="#l4.143"></a><span id="l4.143" class="difflineplus">+  s += L&quot;:&quot;;</span>
<a href="#l4.144"></a><span id="l4.144">   val = tm.wSecond;</span>
<a href="#l4.145"></a><span id="l4.145">   if (val &lt; 10)</span>
<a href="#l4.146"></a><span id="l4.146" class="difflineminus">-    s += &quot;0&quot;;</span>
<a href="#l4.147"></a><span id="l4.147" class="difflineminus">-  s.AppendInt( (PRInt32) val);</span>
<a href="#l4.148"></a><span id="l4.148" class="difflineplus">+    s += L&quot;0&quot;;</span>
<a href="#l4.149"></a><span id="l4.149" class="difflineplus">+  s.AppendInt((PRInt32) val);</span>
<a href="#l4.150"></a><span id="l4.150">   if (includeTZ) {</span>
<a href="#l4.151"></a><span id="l4.151" class="difflineminus">-    s += &quot; &quot;;</span>
<a href="#l4.152"></a><span id="l4.152" class="difflineplus">+    s += L&quot; &quot;;</span>
<a href="#l4.153"></a><span id="l4.153">     if (offset &lt; 0) {</span>
<a href="#l4.154"></a><span id="l4.154">       offset *= -1;</span>
<a href="#l4.155"></a><span id="l4.155" class="difflineminus">-      s += &quot;+&quot;;</span>
<a href="#l4.156"></a><span id="l4.156" class="difflineplus">+      s += L&quot;+&quot;;</span>
<a href="#l4.157"></a><span id="l4.157">     }</span>
<a href="#l4.158"></a><span id="l4.158">     else</span>
<a href="#l4.159"></a><span id="l4.159" class="difflineminus">-      s += &quot;-&quot;;</span>
<a href="#l4.160"></a><span id="l4.160" class="difflineplus">+      s += L&quot;-&quot;;</span>
<a href="#l4.161"></a><span id="l4.161">     offset /= 60;</span>
<a href="#l4.162"></a><span id="l4.162">     val = (int) (offset / 60);</span>
<a href="#l4.163"></a><span id="l4.163">     if (val &lt; 10)</span>
<a href="#l4.164"></a><span id="l4.164" class="difflineminus">-      s += &quot;0&quot;;</span>
<a href="#l4.165"></a><span id="l4.165" class="difflineminus">-    s.AppendInt( (PRInt32) val);</span>
<a href="#l4.166"></a><span id="l4.166" class="difflineplus">+      s += L&quot;0&quot;;</span>
<a href="#l4.167"></a><span id="l4.167" class="difflineplus">+    s.AppendInt((PRInt32) val);</span>
<a href="#l4.168"></a><span id="l4.168">     val = (int) (offset % 60);</span>
<a href="#l4.169"></a><span id="l4.169">     if (val &lt; 10)</span>
<a href="#l4.170"></a><span id="l4.170" class="difflineminus">-      s += &quot;0&quot;;</span>
<a href="#l4.171"></a><span id="l4.171" class="difflineminus">-    s.AppendInt( (PRInt32) val);</span>
<a href="#l4.172"></a><span id="l4.172" class="difflineplus">+      s += L&quot;0&quot;;</span>
<a href="#l4.173"></a><span id="l4.173" class="difflineplus">+    s.AppendInt((PRInt32) val);</span>
<a href="#l4.174"></a><span id="l4.174">   }</span>
<a href="#l4.175"></a><span id="l4.175"> }</span>
<a href="#l4.176"></a><span id="l4.176"> </span>
<a href="#l4.177"></a><span id="l4.177" class="difflineplus">+bool CMapiMessage::EnsureHeader(CMapiMessageHeaders::SpecialHeader special,</span>
<a href="#l4.178"></a><span id="l4.178" class="difflineplus">+                                ULONG mapiTag)</span>
<a href="#l4.179"></a><span id="l4.179" class="difflineplus">+{</span>
<a href="#l4.180"></a><span id="l4.180" class="difflineplus">+  if (m_headers.Value(special))</span>
<a href="#l4.181"></a><span id="l4.181" class="difflineplus">+    return true;</span>
<a href="#l4.182"></a><span id="l4.182" class="difflineplus">+</span>
<a href="#l4.183"></a><span id="l4.183" class="difflineplus">+  nsString value;</span>
<a href="#l4.184"></a><span id="l4.184" class="difflineplus">+  LPSPropValue pVal = CMapiApi::GetMapiProperty(m_lpMsg, mapiTag);</span>
<a href="#l4.185"></a><span id="l4.185" class="difflineplus">+  if (CMapiApi::GetStringFromProp(pVal, value) &amp;&amp; !value.IsEmpty()) {</span>
<a href="#l4.186"></a><span id="l4.186" class="difflineplus">+    m_headers.SetValue(special, value.get());</span>
<a href="#l4.187"></a><span id="l4.187" class="difflineplus">+    return true;</span>
<a href="#l4.188"></a><span id="l4.188" class="difflineplus">+  }</span>
<a href="#l4.189"></a><span id="l4.189" class="difflineplus">+</span>
<a href="#l4.190"></a><span id="l4.190" class="difflineplus">+  return false;</span>
<a href="#l4.191"></a><span id="l4.191" class="difflineplus">+}</span>
<a href="#l4.192"></a><span id="l4.192" class="difflineplus">+</span>
<a href="#l4.193"></a><span id="l4.193" class="difflineplus">+bool CMapiMessage::EnsureDate()</span>
<a href="#l4.194"></a><span id="l4.194" class="difflineplus">+{</span>
<a href="#l4.195"></a><span id="l4.195" class="difflineplus">+  if (m_headers.Value(CMapiMessageHeaders::hdrDate))</span>
<a href="#l4.196"></a><span id="l4.196" class="difflineplus">+    return true;</span>
<a href="#l4.197"></a><span id="l4.197" class="difflineplus">+</span>
<a href="#l4.198"></a><span id="l4.198" class="difflineplus">+  LPSPropValue pVal = CMapiApi::GetMapiProperty(m_lpMsg, PR_MESSAGE_DELIVERY_TIME);</span>
<a href="#l4.199"></a><span id="l4.199" class="difflineplus">+  if (!pVal)</span>
<a href="#l4.200"></a><span id="l4.200" class="difflineplus">+    pVal = CMapiApi::GetMapiProperty(m_lpMsg, PR_CREATION_TIME);</span>
<a href="#l4.201"></a><span id="l4.201" class="difflineplus">+  if (pVal) {</span>
<a href="#l4.202"></a><span id="l4.202" class="difflineplus">+    SYSTEMTIME st;</span>
<a href="#l4.203"></a><span id="l4.203" class="difflineplus">+    // the following call returns UTC</span>
<a href="#l4.204"></a><span id="l4.204" class="difflineplus">+    ::FileTimeToSystemTime(&amp;(pVal-&gt;Value.ft), &amp;st);</span>
<a href="#l4.205"></a><span id="l4.205" class="difflineplus">+    CMapiApi::MAPIFreeBuffer(pVal);</span>
<a href="#l4.206"></a><span id="l4.206" class="difflineplus">+    // FormatDateTime would append the local time zone, so don't use it.</span>
<a href="#l4.207"></a><span id="l4.207" class="difflineplus">+    // Instead, we just append +0000 for GMT/UTC here.</span>
<a href="#l4.208"></a><span id="l4.208" class="difflineplus">+    nsString str;</span>
<a href="#l4.209"></a><span id="l4.209" class="difflineplus">+    FormatDateTime( st, str, false);</span>
<a href="#l4.210"></a><span id="l4.210" class="difflineplus">+    str += L&quot; +0000&quot;;</span>
<a href="#l4.211"></a><span id="l4.211" class="difflineplus">+    m_headers.SetValue(CMapiMessageHeaders::hdrDate, str.get());</span>
<a href="#l4.212"></a><span id="l4.212" class="difflineplus">+    return true;</span>
<a href="#l4.213"></a><span id="l4.213" class="difflineplus">+  }</span>
<a href="#l4.214"></a><span id="l4.214" class="difflineplus">+</span>
<a href="#l4.215"></a><span id="l4.215" class="difflineplus">+  return false;</span>
<a href="#l4.216"></a><span id="l4.216" class="difflineplus">+}</span>
<a href="#l4.217"></a><span id="l4.217" class="difflineplus">+</span>
<a href="#l4.218"></a><span id="l4.218" class="difflineplus">+void CMapiMessage::BuildFromLine( void)</span>
<a href="#l4.219"></a><span id="l4.219" class="difflineplus">+{</span>
<a href="#l4.220"></a><span id="l4.220" class="difflineplus">+  nsString fromLine(sFromLine);</span>
<a href="#l4.221"></a><span id="l4.221" class="difflineplus">+  LPSPropValue pVal = CMapiApi::GetMapiProperty( m_lpMsg, PR_CREATION_TIME);</span>
<a href="#l4.222"></a><span id="l4.222" class="difflineplus">+  if (pVal) {</span>
<a href="#l4.223"></a><span id="l4.223" class="difflineplus">+    SYSTEMTIME st;</span>
<a href="#l4.224"></a><span id="l4.224" class="difflineplus">+    ::FileTimeToSystemTime( &amp;(pVal-&gt;Value.ft), &amp;st);</span>
<a href="#l4.225"></a><span id="l4.225" class="difflineplus">+    CMapiApi::MAPIFreeBuffer( pVal);</span>
<a href="#l4.226"></a><span id="l4.226" class="difflineplus">+    FormatDateTime( st, fromLine, FALSE);</span>
<a href="#l4.227"></a><span id="l4.227" class="difflineplus">+  }</span>
<a href="#l4.228"></a><span id="l4.228" class="difflineplus">+  else</span>
<a href="#l4.229"></a><span id="l4.229" class="difflineplus">+    fromLine += sFromDate;</span>
<a href="#l4.230"></a><span id="l4.230" class="difflineplus">+</span>
<a href="#l4.231"></a><span id="l4.231" class="difflineplus">+  fromLine += L&quot;\x0D\x0A&quot;;</span>
<a href="#l4.232"></a><span id="l4.232" class="difflineplus">+  CopyUTF16toUTF8(fromLine, m_fromLine);</span>
<a href="#l4.233"></a><span id="l4.233" class="difflineplus">+}</span>
<a href="#l4.234"></a><span id="l4.234" class="difflineplus">+</span>
<a href="#l4.235"></a><span id="l4.235" class="difflineplus">+#ifndef dispidHeaderItem</span>
<a href="#l4.236"></a><span id="l4.236" class="difflineplus">+#define dispidHeaderItem 0x8578</span>
<a href="#l4.237"></a><span id="l4.237" class="difflineplus">+#endif</span>
<a href="#l4.238"></a><span id="l4.238" class="difflineplus">+DEFINE_OLEGUID(PSETID_Common, MAKELONG(0x2000+(8),0x0006),0,0);</span>
<a href="#l4.239"></a><span id="l4.239" class="difflineplus">+</span>
<a href="#l4.240"></a><span id="l4.240" class="difflineplus">+void CMapiMessage::GetDownloadState()</span>
<a href="#l4.241"></a><span id="l4.241" class="difflineplus">+{</span>
<a href="#l4.242"></a><span id="l4.242" class="difflineplus">+  // See http://support.microsoft.com/kb/912239</span>
<a href="#l4.243"></a><span id="l4.243" class="difflineplus">+  HRESULT         hRes = S_OK;</span>
<a href="#l4.244"></a><span id="l4.244" class="difflineplus">+  ULONG           ulVal = 0;</span>
<a href="#l4.245"></a><span id="l4.245" class="difflineplus">+  LPSPropValue    lpPropVal = NULL;</span>
<a href="#l4.246"></a><span id="l4.246" class="difflineplus">+  LPSPropTagArray lpNamedPropTag = NULL;</span>
<a href="#l4.247"></a><span id="l4.247" class="difflineplus">+  MAPINAMEID      NamedID = {0};</span>
<a href="#l4.248"></a><span id="l4.248" class="difflineplus">+  LPMAPINAMEID    lpNamedID = NULL;</span>
<a href="#l4.249"></a><span id="l4.249" class="difflineplus">+</span>
<a href="#l4.250"></a><span id="l4.250" class="difflineplus">+  NamedID.lpguid = (LPGUID) &amp;PSETID_Common;</span>
<a href="#l4.251"></a><span id="l4.251" class="difflineplus">+  NamedID.ulKind = MNID_ID;</span>
<a href="#l4.252"></a><span id="l4.252" class="difflineplus">+  NamedID.Kind.lID = dispidHeaderItem;</span>
<a href="#l4.253"></a><span id="l4.253" class="difflineplus">+  lpNamedID = &amp;NamedID;</span>
<a href="#l4.254"></a><span id="l4.254" class="difflineplus">+</span>
<a href="#l4.255"></a><span id="l4.255" class="difflineplus">+  hRes = m_lpMsg-&gt;GetIDsFromNames(1, &amp;lpNamedID, NULL, &amp;lpNamedPropTag);</span>
<a href="#l4.256"></a><span id="l4.256" class="difflineplus">+</span>
<a href="#l4.257"></a><span id="l4.257" class="difflineplus">+  if (lpNamedPropTag &amp;&amp; 1 == lpNamedPropTag-&gt;cValues)</span>
<a href="#l4.258"></a><span id="l4.258" class="difflineplus">+  {</span>
<a href="#l4.259"></a><span id="l4.259" class="difflineplus">+    lpNamedPropTag-&gt;aulPropTag[0] = CHANGE_PROP_TYPE(lpNamedPropTag-&gt;aulPropTag[0], PT_LONG);</span>
<a href="#l4.260"></a><span id="l4.260" class="difflineplus">+</span>
<a href="#l4.261"></a><span id="l4.261" class="difflineplus">+    //Get the value of the property.</span>
<a href="#l4.262"></a><span id="l4.262" class="difflineplus">+    hRes = m_lpMsg-&gt;GetProps(lpNamedPropTag, 0, &amp;ulVal, &amp;lpPropVal);</span>
<a href="#l4.263"></a><span id="l4.263" class="difflineplus">+    if (lpPropVal &amp;&amp; 1 == ulVal &amp;&amp; PT_LONG == PROP_TYPE(lpPropVal-&gt;ulPropTag) &amp;&amp;</span>
<a href="#l4.264"></a><span id="l4.264" class="difflineplus">+        lpPropVal-&gt;Value.ul)</span>
<a href="#l4.265"></a><span id="l4.265" class="difflineplus">+      m_dldStateHeadersOnly = true;</span>
<a href="#l4.266"></a><span id="l4.266" class="difflineplus">+  }</span>
<a href="#l4.267"></a><span id="l4.267" class="difflineplus">+</span>
<a href="#l4.268"></a><span id="l4.268" class="difflineplus">+  CMapiApi::MAPIFreeBuffer(lpPropVal);</span>
<a href="#l4.269"></a><span id="l4.269" class="difflineplus">+  CMapiApi::MAPIFreeBuffer(lpNamedPropTag);</span>
<a href="#l4.270"></a><span id="l4.270" class="difflineplus">+}</span>
<a href="#l4.271"></a><span id="l4.271"> </span>
<a href="#l4.272"></a><span id="l4.272"> // Headers - fetch will get PR_TRANSPORT_MESSAGE_HEADERS</span>
<a href="#l4.273"></a><span id="l4.273"> // or if they do not exist will build a header from</span>
<a href="#l4.274"></a><span id="l4.274"> //  PR_DISPLAY_TO, _CC, _BCC</span>
<a href="#l4.275"></a><span id="l4.275"> //  PR_SUBJECT</span>
<a href="#l4.276"></a><span id="l4.276"> //  PR_MESSAGE_RECIPIENTS</span>
<a href="#l4.277"></a><span id="l4.277"> // and PR_CREATION_TIME if needed?</span>
<a href="#l4.278"></a><span id="l4.278" class="difflineminus">-void CMapiMessage::BuildHeaders( void)</span>
<a href="#l4.279"></a><span id="l4.279" class="difflineplus">+bool CMapiMessage::FetchHeaders( void)</span>
<a href="#l4.280"></a><span id="l4.280"> {</span>
<a href="#l4.281"></a><span id="l4.281" class="difflineminus">-  // Try to the to line.</span>
<a href="#l4.282"></a><span id="l4.282" class="difflineminus">-  m_headers.Truncate();</span>
<a href="#l4.283"></a><span id="l4.283" class="difflineminus">-  AddHeader( m_headers, PR_DISPLAY_TO, &quot;To: &quot;);</span>
<a href="#l4.284"></a><span id="l4.284" class="difflineminus">-  AddHeader( m_headers, PR_DISPLAY_CC, &quot;CC: &quot;);</span>
<a href="#l4.285"></a><span id="l4.285" class="difflineminus">-  AddHeader( m_headers, PR_DISPLAY_BCC, &quot;BCC: &quot;);</span>
<a href="#l4.286"></a><span id="l4.286" class="difflineminus">-  AddDate( m_headers);</span>
<a href="#l4.287"></a><span id="l4.287" class="difflineminus">-  AddSubject( m_headers);</span>
<a href="#l4.288"></a><span id="l4.288" class="difflineminus">-  AddFrom( m_headers);</span>
<a href="#l4.289"></a><span id="l4.289" class="difflineminus">-}</span>
<a href="#l4.290"></a><span id="l4.290" class="difflineplus">+  // Get the Unicode string right away -&gt; no need to double-convert,</span>
<a href="#l4.291"></a><span id="l4.291" class="difflineplus">+  // no possible conversion problems.</span>
<a href="#l4.292"></a><span id="l4.292" class="difflineplus">+  ULONG tag = PR_TRANSPORT_MESSAGE_HEADERS_W;</span>
<a href="#l4.293"></a><span id="l4.293" class="difflineplus">+  LPSPropValue pVal = CMapiApi::GetMapiProperty(m_lpMsg, tag);</span>
<a href="#l4.294"></a><span id="l4.294" class="difflineplus">+  if (!pVal)</span>
<a href="#l4.295"></a><span id="l4.295" class="difflineplus">+    pVal = CMapiApi::GetMapiProperty(m_lpMsg, tag = PR_TRANSPORT_MESSAGE_HEADERS_A);</span>
<a href="#l4.296"></a><span id="l4.296" class="difflineplus">+  if (pVal) {</span>
<a href="#l4.297"></a><span id="l4.297" class="difflineplus">+    if (CMapiApi::IsLargeProperty(pVal)) {</span>
<a href="#l4.298"></a><span id="l4.298" class="difflineplus">+      nsString headers;</span>
<a href="#l4.299"></a><span id="l4.299" class="difflineplus">+      CMapiApi::GetLargeStringProperty(m_lpMsg, tag, headers);</span>
<a href="#l4.300"></a><span id="l4.300" class="difflineplus">+      m_headers.Assign(headers.get());</span>
<a href="#l4.301"></a><span id="l4.301" class="difflineplus">+    }</span>
<a href="#l4.302"></a><span id="l4.302" class="difflineplus">+    else if ((PROP_TYPE(pVal-&gt;ulPropTag) == PT_UNICODE) &amp;&amp;</span>
<a href="#l4.303"></a><span id="l4.303" class="difflineplus">+             (pVal-&gt;Value.lpszW) &amp;&amp; (*(pVal-&gt;Value.lpszW)))</span>
<a href="#l4.304"></a><span id="l4.304" class="difflineplus">+      m_headers.Assign(pVal-&gt;Value.lpszW);</span>
<a href="#l4.305"></a><span id="l4.305" class="difflineplus">+    else if ((PROP_TYPE(pVal-&gt;ulPropTag) == PT_STRING8) &amp;&amp;</span>
<a href="#l4.306"></a><span id="l4.306" class="difflineplus">+             (pVal-&gt;Value.lpszA) &amp;&amp; (*(pVal-&gt;Value.lpszA)))</span>
<a href="#l4.307"></a><span id="l4.307" class="difflineplus">+      m_headers.Assign(NS_ConvertASCIItoUTF16(pVal-&gt;Value.lpszA).get());</span>
<a href="#l4.308"></a><span id="l4.308"> </span>
<a href="#l4.309"></a><span id="l4.309" class="difflineminus">-BOOL CMapiMessage::AddHeader( nsCString&amp; str, ULONG tag, const char *pPrefix)</span>
<a href="#l4.310"></a><span id="l4.310" class="difflineminus">-{</span>
<a href="#l4.311"></a><span id="l4.311" class="difflineminus">-  nsCString value;</span>
<a href="#l4.312"></a><span id="l4.312" class="difflineminus">-  LPSPropValue pVal = CMapiApi::GetMapiProperty( m_lpMsg, tag);</span>
<a href="#l4.313"></a><span id="l4.313" class="difflineminus">-  if (CMapiApi::GetStringFromProp( pVal, value) &amp;&amp; !value.IsEmpty()) {</span>
<a href="#l4.314"></a><span id="l4.314" class="difflineminus">-    str.Trim( kWhitespace, PR_FALSE, PR_TRUE);</span>
<a href="#l4.315"></a><span id="l4.315" class="difflineminus">-    if (!str.IsEmpty())</span>
<a href="#l4.316"></a><span id="l4.316" class="difflineminus">-      str += &quot;\x0D\x0A&quot;;</span>
<a href="#l4.317"></a><span id="l4.317" class="difflineminus">-    str += pPrefix;</span>
<a href="#l4.318"></a><span id="l4.318" class="difflineminus">-    str += value;</span>
<a href="#l4.319"></a><span id="l4.319" class="difflineminus">-    return( TRUE);</span>
<a href="#l4.320"></a><span id="l4.320" class="difflineplus">+    CMapiApi::MAPIFreeBuffer(pVal);</span>
<a href="#l4.321"></a><span id="l4.321">   }</span>
<a href="#l4.322"></a><span id="l4.322"> </span>
<a href="#l4.323"></a><span id="l4.323" class="difflineminus">-  return( FALSE);</span>
<a href="#l4.324"></a><span id="l4.324" class="difflineminus">-}</span>
<a href="#l4.325"></a><span id="l4.325" class="difflineminus">-</span>
<a href="#l4.326"></a><span id="l4.326" class="difflineminus">-void CMapiMessage::AddSubject( nsCString&amp; str)</span>
<a href="#l4.327"></a><span id="l4.327" class="difflineminus">-{</span>
<a href="#l4.328"></a><span id="l4.328" class="difflineminus">-  AddHeader( str, PR_SUBJECT, &quot;Subject: &quot;);</span>
<a href="#l4.329"></a><span id="l4.329" class="difflineminus">-}</span>
<a href="#l4.330"></a><span id="l4.330" class="difflineminus">-</span>
<a href="#l4.331"></a><span id="l4.331" class="difflineminus">-void CMapiMessage::AddFrom( nsCString&amp; str)</span>
<a href="#l4.332"></a><span id="l4.332" class="difflineminus">-{</span>
<a href="#l4.333"></a><span id="l4.333" class="difflineminus">-  if (!AddHeader( str, PR_SENDER_NAME, &quot;From: &quot;))</span>
<a href="#l4.334"></a><span id="l4.334" class="difflineminus">-    AddHeader( str, PR_SENDER_EMAIL_ADDRESS, &quot;From: &quot;);</span>
<a href="#l4.335"></a><span id="l4.335" class="difflineminus">-}</span>
<a href="#l4.336"></a><span id="l4.336" class="difflineminus">-</span>
<a href="#l4.337"></a><span id="l4.337" class="difflineminus">-void CMapiMessage::AddDate( nsCString&amp; str)</span>
<a href="#l4.338"></a><span id="l4.338" class="difflineminus">-{</span>
<a href="#l4.339"></a><span id="l4.339" class="difflineminus">-  LPSPropValue pVal = CMapiApi::GetMapiProperty( m_lpMsg, PR_MESSAGE_DELIVERY_TIME);</span>
<a href="#l4.340"></a><span id="l4.340" class="difflineminus">-  if (!pVal)</span>
<a href="#l4.341"></a><span id="l4.341" class="difflineminus">-    pVal = CMapiApi::GetMapiProperty( m_lpMsg, PR_CREATION_TIME);</span>
<a href="#l4.342"></a><span id="l4.342" class="difflineminus">-  if (pVal) {</span>
<a href="#l4.343"></a><span id="l4.343" class="difflineminus">-    SYSTEMTIME st;</span>
<a href="#l4.344"></a><span id="l4.344" class="difflineminus">-    // the following call returns UTC</span>
<a href="#l4.345"></a><span id="l4.345" class="difflineminus">-    ::FileTimeToSystemTime( &amp;(pVal-&gt;Value.ft), &amp;st);</span>
<a href="#l4.346"></a><span id="l4.346" class="difflineminus">-    CMapiApi::MAPIFreeBuffer( pVal);</span>
<a href="#l4.347"></a><span id="l4.347" class="difflineminus">-    str.Trim( kWhitespace, PR_FALSE, PR_TRUE);</span>
<a href="#l4.348"></a><span id="l4.348" class="difflineminus">-    if (!str.IsEmpty())</span>
<a href="#l4.349"></a><span id="l4.349" class="difflineminus">-      str += &quot;\x0D\x0A&quot;;</span>
<a href="#l4.350"></a><span id="l4.350" class="difflineminus">-    str += &quot;Date: &quot;;</span>
<a href="#l4.351"></a><span id="l4.351" class="difflineminus">-    // FormatDateTime would append the local time zone, so don't use it.</span>
<a href="#l4.352"></a><span id="l4.352" class="difflineminus">-    // Instead, we just append +0000 for GMT/UTC here.</span>
<a href="#l4.353"></a><span id="l4.353" class="difflineminus">-    FormatDateTime( st, str, FALSE);</span>
<a href="#l4.354"></a><span id="l4.354" class="difflineminus">-    str += &quot; +0000&quot;;</span>
<a href="#l4.355"></a><span id="l4.355" class="difflineminus">-  }</span>
<a href="#l4.356"></a><span id="l4.356" class="difflineminus">-}</span>
<a href="#l4.357"></a><span id="l4.357" class="difflineminus">-</span>
<a href="#l4.358"></a><span id="l4.358" class="difflineplus">+  EnsureDate();</span>
<a href="#l4.359"></a><span id="l4.359" class="difflineplus">+  if (!EnsureHeader(CMapiMessageHeaders::hdrFrom, PR_SENDER_NAME_W))</span>
<a href="#l4.360"></a><span id="l4.360" class="difflineplus">+    EnsureHeader(CMapiMessageHeaders::hdrFrom, PR_SENDER_EMAIL_ADDRESS_W);</span>
<a href="#l4.361"></a><span id="l4.361" class="difflineplus">+  EnsureHeader(CMapiMessageHeaders::hdrSubject, PR_SUBJECT_W);</span>
<a href="#l4.362"></a><span id="l4.362" class="difflineplus">+  EnsureHeader(CMapiMessageHeaders::hdrTo, PR_DISPLAY_TO_W);</span>
<a href="#l4.363"></a><span id="l4.363" class="difflineplus">+  EnsureHeader(CMapiMessageHeaders::hdrCc, PR_DISPLAY_CC_W);</span>
<a href="#l4.364"></a><span id="l4.364" class="difflineplus">+  EnsureHeader(CMapiMessageHeaders::hdrBcc, PR_DISPLAY_BCC_W);</span>
<a href="#l4.365"></a><span id="l4.365"> </span>
<a href="#l4.366"></a><span id="l4.366" class="difflineminus">-void CMapiMessage::BuildFromLine( void)</span>
<a href="#l4.367"></a><span id="l4.367" class="difflineminus">-{</span>
<a href="#l4.368"></a><span id="l4.368" class="difflineminus">-  m_fromLine = sFromLine;</span>
<a href="#l4.369"></a><span id="l4.369" class="difflineminus">-  LPSPropValue pVal = CMapiApi::GetMapiProperty( m_lpMsg, PR_CREATION_TIME);</span>
<a href="#l4.370"></a><span id="l4.370" class="difflineminus">-  if (pVal) {</span>
<a href="#l4.371"></a><span id="l4.371" class="difflineminus">-    SYSTEMTIME st;</span>
<a href="#l4.372"></a><span id="l4.372" class="difflineminus">-    ::FileTimeToSystemTime( &amp;(pVal-&gt;Value.ft), &amp;st);</span>
<a href="#l4.373"></a><span id="l4.373" class="difflineminus">-    CMapiApi::MAPIFreeBuffer( pVal);</span>
<a href="#l4.374"></a><span id="l4.374" class="difflineminus">-    FormatDateTime( st, m_fromLine, FALSE);</span>
<a href="#l4.375"></a><span id="l4.375" class="difflineminus">-  }</span>
<a href="#l4.376"></a><span id="l4.376" class="difflineminus">-  else</span>
<a href="#l4.377"></a><span id="l4.377" class="difflineminus">-    m_fromLine += sFromDate;</span>
<a href="#l4.378"></a><span id="l4.378" class="difflineminus">-  m_fromLine += &quot;\x0D\x0A&quot;;</span>
<a href="#l4.379"></a><span id="l4.379" class="difflineminus">-}</span>
<a href="#l4.380"></a><span id="l4.380" class="difflineminus">-</span>
<a href="#l4.381"></a><span id="l4.381" class="difflineminus">-BOOL CMapiMessage::FetchHeaders( void)</span>
<a href="#l4.382"></a><span id="l4.382" class="difflineminus">-{</span>
<a href="#l4.383"></a><span id="l4.383" class="difflineminus">-  LPSPropValue pVal = CMapiApi::GetMapiProperty( m_lpMsg, PR_TRANSPORT_MESSAGE_HEADERS);</span>
<a href="#l4.384"></a><span id="l4.384" class="difflineminus">-  if (pVal &amp;&amp; CMapiApi::IsLargeProperty( pVal)) {</span>
<a href="#l4.385"></a><span id="l4.385" class="difflineminus">-    m_headers.Truncate();</span>
<a href="#l4.386"></a><span id="l4.386" class="difflineminus">-    CMapiApi::GetLargeStringProperty( m_lpMsg, PR_TRANSPORT_MESSAGE_HEADERS, m_headers);</span>
<a href="#l4.387"></a><span id="l4.387" class="difflineminus">-  }</span>
<a href="#l4.388"></a><span id="l4.388" class="difflineminus">-  else if (pVal &amp;&amp; (PROP_TYPE( pVal-&gt;ulPropTag) == PT_TSTRING) &amp;&amp; (pVal-&gt;Value.LPSZ) &amp;&amp; (*(pVal-&gt;Value.LPSZ))) {</span>
<a href="#l4.389"></a><span id="l4.389" class="difflineminus">-    m_headers = pVal-&gt;Value.LPSZ;</span>
<a href="#l4.390"></a><span id="l4.390" class="difflineminus">-  }</span>
<a href="#l4.391"></a><span id="l4.391" class="difflineminus">-  else {</span>
<a href="#l4.392"></a><span id="l4.392" class="difflineminus">-    // Need to build the headers from the other stuff</span>
<a href="#l4.393"></a><span id="l4.393" class="difflineminus">-    m_headers.Truncate();</span>
<a href="#l4.394"></a><span id="l4.394" class="difflineminus">-    BuildHeaders();</span>
<a href="#l4.395"></a><span id="l4.395" class="difflineminus">-  }</span>
<a href="#l4.396"></a><span id="l4.396" class="difflineminus">-</span>
<a href="#l4.397"></a><span id="l4.397" class="difflineminus">-  if (pVal)</span>
<a href="#l4.398"></a><span id="l4.398" class="difflineminus">-    CMapiApi::MAPIFreeBuffer( pVal);</span>
<a href="#l4.399"></a><span id="l4.399" class="difflineminus">-</span>
<a href="#l4.400"></a><span id="l4.400" class="difflineminus">-  m_fromLine.Truncate();</span>
<a href="#l4.401"></a><span id="l4.401" class="difflineminus">-  if (NeedsFromLine()) {</span>
<a href="#l4.402"></a><span id="l4.402" class="difflineminus">-    BuildFromLine();</span>
<a href="#l4.403"></a><span id="l4.403" class="difflineminus">-  }</span>
<a href="#l4.404"></a><span id="l4.404" class="difflineminus">-</span>
<a href="#l4.405"></a><span id="l4.405" class="difflineminus">-  if (!m_fromLine.IsEmpty()) {</span>
<a href="#l4.406"></a><span id="l4.406" class="difflineminus">-    MAPI_DUMP_STRING(m_fromLine.get());</span>
<a href="#l4.407"></a><span id="l4.407" class="difflineminus">-  }</span>
<a href="#l4.408"></a><span id="l4.408" class="difflineminus">-  MAPI_DUMP_STRING(m_headers.get());</span>
<a href="#l4.409"></a><span id="l4.409" class="difflineminus">-  MAPI_TRACE0(&quot;\r\n&quot;);</span>
<a href="#l4.410"></a><span id="l4.410" class="difflineminus">-</span>
<a href="#l4.411"></a><span id="l4.411" class="difflineminus">-  ProcessHeaders();</span>
<a href="#l4.412"></a><span id="l4.412" class="difflineminus">-</span>
<a href="#l4.413"></a><span id="l4.413" class="difflineminus">-  if (!m_headers.IsEmpty()) {</span>
<a href="#l4.414"></a><span id="l4.414" class="difflineminus">-    if (!m_bHasSubject)</span>
<a href="#l4.415"></a><span id="l4.415" class="difflineminus">-      AddSubject( m_headers);</span>
<a href="#l4.416"></a><span id="l4.416" class="difflineminus">-    if (!m_bHasFrom)</span>
<a href="#l4.417"></a><span id="l4.417" class="difflineminus">-      AddFrom( m_headers);</span>
<a href="#l4.418"></a><span id="l4.418" class="difflineminus">-    if (!m_bHasDate)</span>
<a href="#l4.419"></a><span id="l4.419" class="difflineminus">-      AddDate( m_headers);</span>
<a href="#l4.420"></a><span id="l4.420" class="difflineminus">-    m_headers.Trim( kWhitespace, PR_FALSE, PR_TRUE);</span>
<a href="#l4.421"></a><span id="l4.421" class="difflineminus">-    m_headers += &quot;\x0D\x0A&quot;;</span>
<a href="#l4.422"></a><span id="l4.422" class="difflineminus">-  }</span>
<a href="#l4.423"></a><span id="l4.423" class="difflineplus">+  ProcessContentType();</span>
<a href="#l4.424"></a><span id="l4.424"> </span>
<a href="#l4.425"></a><span id="l4.425">   return( !m_headers.IsEmpty());</span>
<a href="#l4.426"></a><span id="l4.426"> }</span>
<a href="#l4.427"></a><span id="l4.427"> </span>
<a href="#l4.428"></a><span id="l4.428" class="difflineminus">-// TRUE if a From line needs to precede the headers, FALSE</span>
<a href="#l4.429"></a><span id="l4.429" class="difflineminus">-// if the headers already include a from line</span>
<a href="#l4.430"></a><span id="l4.430" class="difflineminus">-BOOL CMapiMessage::NeedsFromLine( void)</span>
<a href="#l4.431"></a><span id="l4.431" class="difflineminus">-{</span>
<a href="#l4.432"></a><span id="l4.432" class="difflineminus">-  nsCString l;</span>
<a href="#l4.433"></a><span id="l4.433" class="difflineminus">-  m_headers.Left( l, 5);</span>
<a href="#l4.434"></a><span id="l4.434" class="difflineminus">-  if (l.Equals(&quot;From &quot;))</span>
<a href="#l4.435"></a><span id="l4.435" class="difflineminus">-    return( FALSE);</span>
<a href="#l4.436"></a><span id="l4.436" class="difflineminus">-  else</span>
<a href="#l4.437"></a><span id="l4.437" class="difflineminus">-    return( TRUE);</span>
<a href="#l4.438"></a><span id="l4.438" class="difflineminus">-}</span>
<a href="#l4.439"></a><span id="l4.439" class="difflineminus">-</span>
<a href="#l4.440"></a><span id="l4.440" class="difflineminus">-BOOL CMapiMessage::IsMultipart( void)</span>
<a href="#l4.441"></a><span id="l4.441" class="difflineplus">+bool CMapiMessage::IsMultipart( void) const</span>
<a href="#l4.442"></a><span id="l4.442"> {</span>
<a href="#l4.443"></a><span id="l4.443">   nsCString left;</span>
<a href="#l4.444"></a><span id="l4.444">   m_mimeContentType.Left( left, 10);</span>
<a href="#l4.445"></a><span id="l4.445">   if (left.Equals(NS_LITERAL_CSTRING(&quot;multipart/&quot;), nsCaseInsensitiveCStringComparator()))</span>
<a href="#l4.446"></a><span id="l4.446" class="difflineminus">-    return( TRUE);</span>
<a href="#l4.447"></a><span id="l4.447" class="difflineminus">-  return( FALSE);</span>
<a href="#l4.448"></a><span id="l4.448" class="difflineminus">-}</span>
<a href="#l4.449"></a><span id="l4.449" class="difflineminus">-</span>
<a href="#l4.450"></a><span id="l4.450" class="difflineminus">-void CMapiMessage::GenerateBoundary( void)</span>
<a href="#l4.451"></a><span id="l4.451" class="difflineminus">-{</span>
<a href="#l4.452"></a><span id="l4.452" class="difflineminus">-  m_mimeBoundary = &quot;===============_NSImport_Boundary_&quot;;</span>
<a href="#l4.453"></a><span id="l4.453" class="difflineminus">-  PRUint32 t = ::GetTickCount();</span>
<a href="#l4.454"></a><span id="l4.454" class="difflineminus">-  nsCString hex;</span>
<a href="#l4.455"></a><span id="l4.455" class="difflineminus">-  hex.AppendInt( (PRInt32) t, 16);</span>
<a href="#l4.456"></a><span id="l4.456" class="difflineminus">-  m_mimeBoundary += hex;</span>
<a href="#l4.457"></a><span id="l4.457" class="difflineminus">-  m_mimeBoundary += &quot;====&quot;;</span>
<a href="#l4.458"></a><span id="l4.458" class="difflineminus">-}</span>
<a href="#l4.459"></a><span id="l4.459" class="difflineminus">-</span>
<a href="#l4.460"></a><span id="l4.460" class="difflineminus">-BOOL CMapiMessage::GetAttachFileLoc( nsIFile * pLoc)</span>
<a href="#l4.461"></a><span id="l4.461" class="difflineminus">-{</span>
<a href="#l4.462"></a><span id="l4.462" class="difflineminus">-  if (m_attachPath.IsEmpty())</span>
<a href="#l4.463"></a><span id="l4.463" class="difflineminus">-    return( FALSE);</span>
<a href="#l4.464"></a><span id="l4.464" class="difflineminus">-  nsCOMPtr &lt;nsILocalFile&gt; locFile = do_QueryInterface(pLoc);</span>
<a href="#l4.465"></a><span id="l4.465" class="difflineminus">-  locFile-&gt;InitWithNativePath(m_attachPath);</span>
<a href="#l4.466"></a><span id="l4.466" class="difflineminus">-  m_ownsAttachFile = FALSE;</span>
<a href="#l4.467"></a><span id="l4.467" class="difflineminus">-  return( TRUE);</span>
<a href="#l4.468"></a><span id="l4.468" class="difflineplus">+    return true;</span>
<a href="#l4.469"></a><span id="l4.469" class="difflineplus">+  return false;</span>
<a href="#l4.470"></a><span id="l4.470"> }</span>
<a href="#l4.471"></a><span id="l4.471"> </span>
<a href="#l4.472"></a><span id="l4.472"> // Mime-Version: 1.0</span>
<a href="#l4.473"></a><span id="l4.473"> // Content-Type: text/plain; charset=&quot;US-ASCII&quot;</span>
<a href="#l4.474"></a><span id="l4.474"> // Content-Type: multipart/mixed; boundary=&quot;=====================_874475278==_&quot;</span>
<a href="#l4.475"></a><span id="l4.475"> </span>
<a href="#l4.476"></a><span id="l4.476" class="difflineminus">-void CMapiMessage::ProcessHeaderLine( nsCString&amp; line)</span>
<a href="#l4.477"></a><span id="l4.477" class="difflineplus">+void CMapiMessage::ProcessContentType()</span>
<a href="#l4.478"></a><span id="l4.478"> {</span>
<a href="#l4.479"></a><span id="l4.479" class="difflineminus">-  PRUint32 len, start;</span>
<a href="#l4.480"></a><span id="l4.480" class="difflineminus">-  nsCString tStr;</span>
<a href="#l4.481"></a><span id="l4.481" class="difflineminus">-  nsCString left13;</span>
<a href="#l4.482"></a><span id="l4.482" class="difflineminus">-  nsCString left26;</span>
<a href="#l4.483"></a><span id="l4.483" class="difflineminus">-  nsCString left8;</span>
<a href="#l4.484"></a><span id="l4.484" class="difflineminus">-  nsCString left5;</span>
<a href="#l4.485"></a><span id="l4.485" class="difflineplus">+  m_mimeContentType.Truncate();</span>
<a href="#l4.486"></a><span id="l4.486" class="difflineplus">+  m_mimeBoundary.Truncate();</span>
<a href="#l4.487"></a><span id="l4.487" class="difflineplus">+  m_mimeCharset.Truncate();</span>
<a href="#l4.488"></a><span id="l4.488"> </span>
<a href="#l4.489"></a><span id="l4.489" class="difflineminus">-  line.Left( left13, 13);</span>
<a href="#l4.490"></a><span id="l4.490" class="difflineminus">-  line.Left( left26, 26);</span>
<a href="#l4.491"></a><span id="l4.491" class="difflineminus">-  line.Left( left8, 8);</span>
<a href="#l4.492"></a><span id="l4.492" class="difflineminus">-  line.Left( left5, 5);</span>
<a href="#l4.493"></a><span id="l4.493" class="difflineplus">+  const wchar_t* contentType = m_headers.Value(CMapiMessageHeaders::hdrContentType);</span>
<a href="#l4.494"></a><span id="l4.494" class="difflineplus">+  if (!contentType)</span>
<a href="#l4.495"></a><span id="l4.495" class="difflineplus">+    return;</span>
<a href="#l4.496"></a><span id="l4.496" class="difflineplus">+</span>
<a href="#l4.497"></a><span id="l4.497" class="difflineplus">+  const wchar_t *begin = contentType, *end;</span>
<a href="#l4.498"></a><span id="l4.498" class="difflineplus">+  nsString tStr;</span>
<a href="#l4.499"></a><span id="l4.499"> </span>
<a href="#l4.500"></a><span id="l4.500" class="difflineminus">-  if (left13.Equals(NS_LITERAL_CSTRING(&quot;Mime-Version:&quot;), nsCaseInsensitiveCStringComparator()))</span>
<a href="#l4.501"></a><span id="l4.501" class="difflineminus">-    m_bMimeVersion = TRUE;</span>
<a href="#l4.502"></a><span id="l4.502" class="difflineminus">-  else if (left13.Equals(NS_LITERAL_CSTRING(&quot;Content-Type:&quot;), nsCaseInsensitiveCStringComparator())) {</span>
<a href="#l4.503"></a><span id="l4.503" class="difflineminus">-    // Note: this isn't a complete parser, the content type</span>
<a href="#l4.504"></a><span id="l4.504" class="difflineminus">-    // we extract could have rfc822 comments in it</span>
<a href="#l4.505"></a><span id="l4.505" class="difflineminus">-    len = 13;</span>
<a href="#l4.506"></a><span id="l4.506" class="difflineminus">-    while ((len &lt; line.Length()) &amp;&amp; IsSpace( line.CharAt( len)))</span>
<a href="#l4.507"></a><span id="l4.507" class="difflineminus">-      len++;</span>
<a href="#l4.508"></a><span id="l4.508" class="difflineminus">-    start = len;</span>
<a href="#l4.509"></a><span id="l4.509" class="difflineminus">-    while ((len &lt; line.Length()) &amp;&amp; (line.CharAt( len) != ';'))</span>
<a href="#l4.510"></a><span id="l4.510" class="difflineminus">-      len++;</span>
<a href="#l4.511"></a><span id="l4.511" class="difflineminus">-    line.Mid( m_mimeContentType, start, len - start);</span>
<a href="#l4.512"></a><span id="l4.512" class="difflineminus">-    len++;</span>
<a href="#l4.513"></a><span id="l4.513" class="difflineminus">-    // look for &quot;boundary=&quot;</span>
<a href="#l4.514"></a><span id="l4.514" class="difflineminus">-    BOOL haveB;</span>
<a href="#l4.515"></a><span id="l4.515" class="difflineminus">-    BOOL haveC;</span>
<a href="#l4.516"></a><span id="l4.516" class="difflineminus">-    while (len &lt; line.Length()) {</span>
<a href="#l4.517"></a><span id="l4.517" class="difflineminus">-      haveB = FALSE;</span>
<a href="#l4.518"></a><span id="l4.518" class="difflineminus">-      haveC = FALSE;</span>
<a href="#l4.519"></a><span id="l4.519" class="difflineminus">-      while ((len &lt; line.Length()) &amp;&amp; IsSpace( line.CharAt( len)))</span>
<a href="#l4.520"></a><span id="l4.520" class="difflineminus">-        len++;</span>
<a href="#l4.521"></a><span id="l4.521" class="difflineminus">-      start = len;</span>
<a href="#l4.522"></a><span id="l4.522" class="difflineminus">-      while ((len &lt; line.Length()) &amp;&amp; (line.CharAt( len) != '='))</span>
<a href="#l4.523"></a><span id="l4.523" class="difflineminus">-        len++;</span>
<a href="#l4.524"></a><span id="l4.524" class="difflineminus">-      if (len - start) {</span>
<a href="#l4.525"></a><span id="l4.525" class="difflineminus">-        line.Mid( tStr, start, len - start);</span>
<a href="#l4.526"></a><span id="l4.526" class="difflineminus">-        if (tStr.Equals(NS_LITERAL_CSTRING(&quot;boundary&quot;), nsCaseInsensitiveCStringComparator()))</span>
<a href="#l4.527"></a><span id="l4.527" class="difflineminus">-          haveB = TRUE;</span>
<a href="#l4.528"></a><span id="l4.528" class="difflineminus">-        else if (tStr.Equals(NS_LITERAL_CSTRING(&quot;charset&quot;), nsCaseInsensitiveCStringComparator()))</span>
<a href="#l4.529"></a><span id="l4.529" class="difflineminus">-          haveC = TRUE;</span>
<a href="#l4.530"></a><span id="l4.530" class="difflineplus">+  // Note: this isn't a complete parser, the content type</span>
<a href="#l4.531"></a><span id="l4.531" class="difflineplus">+  // we extract could have rfc822 comments in it</span>
<a href="#l4.532"></a><span id="l4.532" class="difflineplus">+  while (*begin &amp;&amp; IsSpace(*begin))</span>
<a href="#l4.533"></a><span id="l4.533" class="difflineplus">+    begin++;</span>
<a href="#l4.534"></a><span id="l4.534" class="difflineplus">+  if (!(*begin))</span>
<a href="#l4.535"></a><span id="l4.535" class="difflineplus">+    return;</span>
<a href="#l4.536"></a><span id="l4.536" class="difflineplus">+  end = begin;</span>
<a href="#l4.537"></a><span id="l4.537" class="difflineplus">+  while (*end &amp;&amp; (*end != L';'))</span>
<a href="#l4.538"></a><span id="l4.538" class="difflineplus">+    end++;</span>
<a href="#l4.539"></a><span id="l4.539" class="difflineplus">+  tStr.Assign(begin, end-begin);</span>
<a href="#l4.540"></a><span id="l4.540" class="difflineplus">+  CopyUTF16toUTF8(tStr, m_mimeContentType);</span>
<a href="#l4.541"></a><span id="l4.541" class="difflineplus">+  if (!(*end))</span>
<a href="#l4.542"></a><span id="l4.542" class="difflineplus">+    return;</span>
<a href="#l4.543"></a><span id="l4.543" class="difflineplus">+  // look for &quot;boundary=&quot;</span>
<a href="#l4.544"></a><span id="l4.544" class="difflineplus">+  begin = end + 1;</span>
<a href="#l4.545"></a><span id="l4.545" class="difflineplus">+  bool haveB;</span>
<a href="#l4.546"></a><span id="l4.546" class="difflineplus">+  bool haveC;</span>
<a href="#l4.547"></a><span id="l4.547" class="difflineplus">+  while (*begin) {</span>
<a href="#l4.548"></a><span id="l4.548" class="difflineplus">+    haveB = false;</span>
<a href="#l4.549"></a><span id="l4.549" class="difflineplus">+    haveC = false;</span>
<a href="#l4.550"></a><span id="l4.550" class="difflineplus">+    while (*begin &amp;&amp; IsSpace(*begin))</span>
<a href="#l4.551"></a><span id="l4.551" class="difflineplus">+      begin++;</span>
<a href="#l4.552"></a><span id="l4.552" class="difflineplus">+    if (!(*begin))</span>
<a href="#l4.553"></a><span id="l4.553" class="difflineplus">+      return;</span>
<a href="#l4.554"></a><span id="l4.554" class="difflineplus">+    end = begin;</span>
<a href="#l4.555"></a><span id="l4.555" class="difflineplus">+    while (*end &amp;&amp; (*end != L'='))</span>
<a href="#l4.556"></a><span id="l4.556" class="difflineplus">+      end++;</span>
<a href="#l4.557"></a><span id="l4.557" class="difflineplus">+    if (end - begin) {</span>
<a href="#l4.558"></a><span id="l4.558" class="difflineplus">+      tStr.Assign(begin, end-begin);</span>
<a href="#l4.559"></a><span id="l4.559" class="difflineplus">+      if (tStr.Equals(NS_LITERAL_STRING(&quot;boundary&quot;),</span>
<a href="#l4.560"></a><span id="l4.560" class="difflineplus">+                      nsCaseInsensitiveStringComparator()))</span>
<a href="#l4.561"></a><span id="l4.561" class="difflineplus">+        haveB = true;</span>
<a href="#l4.562"></a><span id="l4.562" class="difflineplus">+      else if (tStr.Equals(NS_LITERAL_STRING(&quot;charset&quot;),</span>
<a href="#l4.563"></a><span id="l4.563" class="difflineplus">+                           nsCaseInsensitiveStringComparator()))</span>
<a href="#l4.564"></a><span id="l4.564" class="difflineplus">+        haveC = true;</span>
<a href="#l4.565"></a><span id="l4.565" class="difflineplus">+    }</span>
<a href="#l4.566"></a><span id="l4.566" class="difflineplus">+    if (!(*end))</span>
<a href="#l4.567"></a><span id="l4.567" class="difflineplus">+      return;</span>
<a href="#l4.568"></a><span id="l4.568" class="difflineplus">+    begin = end+1;</span>
<a href="#l4.569"></a><span id="l4.569" class="difflineplus">+    while (*begin &amp;&amp; IsSpace(*begin))</span>
<a href="#l4.570"></a><span id="l4.570" class="difflineplus">+      begin++;</span>
<a href="#l4.571"></a><span id="l4.571" class="difflineplus">+    if (*begin == L'&quot;') {</span>
<a href="#l4.572"></a><span id="l4.572" class="difflineplus">+      begin++;</span>
<a href="#l4.573"></a><span id="l4.573" class="difflineplus">+      bool slash = false;</span>
<a href="#l4.574"></a><span id="l4.574" class="difflineplus">+      tStr.Truncate();</span>
<a href="#l4.575"></a><span id="l4.575" class="difflineplus">+      while (*begin) {</span>
<a href="#l4.576"></a><span id="l4.576" class="difflineplus">+        if (slash) {</span>
<a href="#l4.577"></a><span id="l4.577" class="difflineplus">+          slash = false;</span>
<a href="#l4.578"></a><span id="l4.578" class="difflineplus">+          tStr.Append(*begin);</span>
<a href="#l4.579"></a><span id="l4.579" class="difflineplus">+        }</span>
<a href="#l4.580"></a><span id="l4.580" class="difflineplus">+        else if (*begin == L'&quot;')</span>
<a href="#l4.581"></a><span id="l4.581" class="difflineplus">+          break;</span>
<a href="#l4.582"></a><span id="l4.582" class="difflineplus">+        else if (*begin != L'\\')</span>
<a href="#l4.583"></a><span id="l4.583" class="difflineplus">+          tStr.Append(*begin);</span>
<a href="#l4.584"></a><span id="l4.584" class="difflineplus">+        else</span>
<a href="#l4.585"></a><span id="l4.585" class="difflineplus">+          slash = true;</span>
<a href="#l4.586"></a><span id="l4.586" class="difflineplus">+        begin++;</span>
<a href="#l4.587"></a><span id="l4.587">       }</span>
<a href="#l4.588"></a><span id="l4.588" class="difflineminus">-      len++;</span>
<a href="#l4.589"></a><span id="l4.589" class="difflineminus">-      while ((len &lt; line.Length()) &amp;&amp; IsSpace( line.CharAt( len)))</span>
<a href="#l4.590"></a><span id="l4.590" class="difflineminus">-        len++;</span>
<a href="#l4.591"></a><span id="l4.591" class="difflineminus">-      if ((len &lt; line.Length()) &amp;&amp; (line.CharAt( len) == '&quot;')) {</span>
<a href="#l4.592"></a><span id="l4.592" class="difflineminus">-        len++;</span>
<a href="#l4.593"></a><span id="l4.593" class="difflineminus">-        BOOL slash = FALSE;</span>
<a href="#l4.594"></a><span id="l4.594" class="difflineminus">-        tStr.Truncate();</span>
<a href="#l4.595"></a><span id="l4.595" class="difflineminus">-        while (len &lt; line.Length()) {</span>
<a href="#l4.596"></a><span id="l4.596" class="difflineminus">-          if (slash) {</span>
<a href="#l4.597"></a><span id="l4.597" class="difflineminus">-            slash = FALSE;</span>
<a href="#l4.598"></a><span id="l4.598" class="difflineminus">-            tStr.Append(line.CharAt( len));</span>
<a href="#l4.599"></a><span id="l4.599" class="difflineminus">-          }</span>
<a href="#l4.600"></a><span id="l4.600" class="difflineminus">-          else if (line.CharAt( len) == '&quot;')</span>
<a href="#l4.601"></a><span id="l4.601" class="difflineminus">-            break;</span>
<a href="#l4.602"></a><span id="l4.602" class="difflineminus">-          else if (line.CharAt( len) != '\\')</span>
<a href="#l4.603"></a><span id="l4.603" class="difflineminus">-            tStr.Append(line.CharAt( len));</span>
<a href="#l4.604"></a><span id="l4.604" class="difflineminus">-          else</span>
<a href="#l4.605"></a><span id="l4.605" class="difflineminus">-            slash = TRUE;</span>
<a href="#l4.606"></a><span id="l4.606" class="difflineminus">-          len++;</span>
<a href="#l4.607"></a><span id="l4.607" class="difflineminus">-        }</span>
<a href="#l4.608"></a><span id="l4.608" class="difflineminus">-        len++;</span>
<a href="#l4.609"></a><span id="l4.609" class="difflineminus">-        if (haveB) {</span>
<a href="#l4.610"></a><span id="l4.610" class="difflineminus">-          m_mimeBoundary = tStr;</span>
<a href="#l4.611"></a><span id="l4.611" class="difflineminus">-          haveB = FALSE;</span>
<a href="#l4.612"></a><span id="l4.612" class="difflineminus">-        }</span>
<a href="#l4.613"></a><span id="l4.613" class="difflineminus">-        if (haveC) {</span>
<a href="#l4.614"></a><span id="l4.614" class="difflineminus">-          m_mimeCharset = tStr;</span>
<a href="#l4.615"></a><span id="l4.615" class="difflineminus">-          haveC = FALSE;</span>
<a href="#l4.616"></a><span id="l4.616" class="difflineminus">-        }</span>
<a href="#l4.617"></a><span id="l4.617" class="difflineminus">-      }</span>
<a href="#l4.618"></a><span id="l4.618" class="difflineminus">-      tStr.Truncate();</span>
<a href="#l4.619"></a><span id="l4.619" class="difflineminus">-      while ((len &lt; line.Length()) &amp;&amp; (line.CharAt( len) != ';')) {</span>
<a href="#l4.620"></a><span id="l4.620" class="difflineminus">-        tStr.Append(line.CharAt( len));</span>
<a href="#l4.621"></a><span id="l4.621" class="difflineminus">-        len++;</span>
<a href="#l4.622"></a><span id="l4.622" class="difflineminus">-      }</span>
<a href="#l4.623"></a><span id="l4.623" class="difflineminus">-      len++;</span>
<a href="#l4.624"></a><span id="l4.624">       if (haveB) {</span>
<a href="#l4.625"></a><span id="l4.625" class="difflineminus">-        tStr.Trim( kWhitespace);</span>
<a href="#l4.626"></a><span id="l4.626" class="difflineminus">-        m_mimeBoundary = tStr;</span>
<a href="#l4.627"></a><span id="l4.627" class="difflineplus">+        CopyUTF16toUTF8(tStr, m_mimeBoundary);</span>
<a href="#l4.628"></a><span id="l4.628" class="difflineplus">+        haveB = false;</span>
<a href="#l4.629"></a><span id="l4.629">       }</span>
<a href="#l4.630"></a><span id="l4.630">       if (haveC) {</span>
<a href="#l4.631"></a><span id="l4.631" class="difflineminus">-        tStr.Trim( kWhitespace);</span>
<a href="#l4.632"></a><span id="l4.632" class="difflineminus">-        m_mimeCharset = tStr;</span>
<a href="#l4.633"></a><span id="l4.633" class="difflineplus">+        CopyUTF16toUTF8(tStr, m_mimeCharset);</span>
<a href="#l4.634"></a><span id="l4.634" class="difflineplus">+        haveC = false;</span>
<a href="#l4.635"></a><span id="l4.635">       }</span>
<a href="#l4.636"></a><span id="l4.636" class="difflineminus">-</span>
<a href="#l4.637"></a><span id="l4.637" class="difflineplus">+      if (!(*begin))</span>
<a href="#l4.638"></a><span id="l4.638" class="difflineplus">+        return;</span>
<a href="#l4.639"></a><span id="l4.639" class="difflineplus">+      begin++;</span>
<a href="#l4.640"></a><span id="l4.640" class="difflineplus">+    }</span>
<a href="#l4.641"></a><span id="l4.641" class="difflineplus">+    tStr.Truncate();</span>
<a href="#l4.642"></a><span id="l4.642" class="difflineplus">+    while (*begin &amp;&amp; (*begin != L';')) {</span>
<a href="#l4.643"></a><span id="l4.643" class="difflineplus">+      tStr.Append(*(begin++));</span>
<a href="#l4.644"></a><span id="l4.644">     }</span>
<a href="#l4.645"></a><span id="l4.645" class="difflineminus">-  }</span>
<a href="#l4.646"></a><span id="l4.646" class="difflineminus">-  else if (left26.Equals(NS_LITERAL_CSTRING(&quot;Content-Transfer-Encoding:&quot;), nsCaseInsensitiveCStringComparator())) {</span>
<a href="#l4.647"></a><span id="l4.647" class="difflineminus">-    m_bMimeEncoding = TRUE;</span>
<a href="#l4.648"></a><span id="l4.648" class="difflineminus">-  }</span>
<a href="#l4.649"></a><span id="l4.649" class="difflineminus">-  else if (left8.Equals(NS_LITERAL_CSTRING(&quot;Subject:&quot;), nsCaseInsensitiveCStringComparator()))</span>
<a href="#l4.650"></a><span id="l4.650" class="difflineminus">-    m_bHasSubject = TRUE;</span>
<a href="#l4.651"></a><span id="l4.651" class="difflineminus">-  else if (left5.Equals(NS_LITERAL_CSTRING(&quot;From:&quot;), nsCaseInsensitiveCStringComparator()))</span>
<a href="#l4.652"></a><span id="l4.652" class="difflineminus">-    m_bHasFrom = TRUE;</span>
<a href="#l4.653"></a><span id="l4.653" class="difflineminus">-  else if (left5.Equals(NS_LITERAL_CSTRING(&quot;Date:&quot;), nsCaseInsensitiveCStringComparator()))</span>
<a href="#l4.654"></a><span id="l4.654" class="difflineminus">-    m_bHasDate = TRUE;</span>
<a href="#l4.655"></a><span id="l4.655" class="difflineminus">-}</span>
<a href="#l4.656"></a><span id="l4.656" class="difflineminus">-</span>
<a href="#l4.657"></a><span id="l4.657" class="difflineminus">-void CMapiMessage::ProcessHeaders( void)</span>
<a href="#l4.658"></a><span id="l4.658" class="difflineminus">-{</span>
<a href="#l4.659"></a><span id="l4.659" class="difflineminus">-  m_bHasSubject = FALSE;</span>
<a href="#l4.660"></a><span id="l4.660" class="difflineminus">-  m_bHasFrom = FALSE;</span>
<a href="#l4.661"></a><span id="l4.661" class="difflineminus">-  m_bHasDate = FALSE;</span>
<a href="#l4.662"></a><span id="l4.662" class="difflineminus">-</span>
<a href="#l4.663"></a><span id="l4.663" class="difflineminus">-  PC_S8 pChar = (PC_S8) m_headers.get();</span>
<a href="#l4.664"></a><span id="l4.664" class="difflineminus">-  int start = 0;</span>
<a href="#l4.665"></a><span id="l4.665" class="difflineminus">-  int len = 0;</span>
<a href="#l4.666"></a><span id="l4.666" class="difflineminus">-  int hdrLen = strlen(pChar);</span>
<a href="#l4.667"></a><span id="l4.667" class="difflineminus">-  nsCString line;</span>
<a href="#l4.668"></a><span id="l4.668" class="difflineminus">-  nsCString mid;</span>
<a href="#l4.669"></a><span id="l4.669" class="difflineminus">-  while (*pChar) {</span>
<a href="#l4.670"></a><span id="l4.670" class="difflineminus">-    if ((*pChar == 0x0D) &amp;&amp; (*(pChar + 1) == 0x0A)) {</span>
<a href="#l4.671"></a><span id="l4.671" class="difflineminus">-      if ((*(pChar + 2) != ' ') &amp;&amp; (*(pChar + 2) != 9)) {</span>
<a href="#l4.672"></a><span id="l4.672" class="difflineminus">-        m_headers.Mid( mid, start, len);</span>
<a href="#l4.673"></a><span id="l4.673" class="difflineminus">-        line += mid;</span>
<a href="#l4.674"></a><span id="l4.674" class="difflineminus">-        ProcessHeaderLine( line);</span>
<a href="#l4.675"></a><span id="l4.675" class="difflineminus">-        line.Truncate();</span>
<a href="#l4.676"></a><span id="l4.676" class="difflineminus">-        pChar++; // subsequent increment will move pChar to the next line</span>
<a href="#l4.677"></a><span id="l4.677" class="difflineminus">-        start += len;</span>
<a href="#l4.678"></a><span id="l4.678" class="difflineminus">-        start += 2;</span>
<a href="#l4.679"></a><span id="l4.679" class="difflineminus">-        len = -1;</span>
<a href="#l4.680"></a><span id="l4.680" class="difflineminus">-      }</span>
<a href="#l4.681"></a><span id="l4.681" class="difflineplus">+    if (haveB) {</span>
<a href="#l4.682"></a><span id="l4.682" class="difflineplus">+      tStr.Trim(kWhitespace);</span>
<a href="#l4.683"></a><span id="l4.683" class="difflineplus">+      CopyUTF16toUTF8(tStr, m_mimeBoundary);</span>
<a href="#l4.684"></a><span id="l4.684">     }</span>
<a href="#l4.685"></a><span id="l4.685" class="difflineminus">-    pChar++;</span>
<a href="#l4.686"></a><span id="l4.686" class="difflineminus">-    len++;</span>
<a href="#l4.687"></a><span id="l4.687" class="difflineminus">-  }</span>
<a href="#l4.688"></a><span id="l4.688" class="difflineminus">-</span>
<a href="#l4.689"></a><span id="l4.689" class="difflineminus">-  // See if we still have data to be processed.</span>
<a href="#l4.690"></a><span id="l4.690" class="difflineminus">-  if (start &lt; hdrLen)</span>
<a href="#l4.691"></a><span id="l4.691" class="difflineminus">-  {</span>
<a href="#l4.692"></a><span id="l4.692" class="difflineminus">-    line.Assign(m_headers.get()+start);</span>
<a href="#l4.693"></a><span id="l4.693" class="difflineminus">-    ProcessHeaderLine(line);</span>
<a href="#l4.694"></a><span id="l4.694" class="difflineminus">-  }</span>
<a href="#l4.695"></a><span id="l4.695" class="difflineminus">-</span>
<a href="#l4.696"></a><span id="l4.696" class="difflineminus">-  if (!m_mimeContentType.IsEmpty() || !m_mimeBoundary.IsEmpty() || !m_mimeCharset.IsEmpty()) {</span>
<a href="#l4.697"></a><span id="l4.697" class="difflineminus">-    MAPI_TRACE1(&quot;\tDecoded mime content type: %s\r\n&quot;, m_mimeContentType.get());</span>
<a href="#l4.698"></a><span id="l4.698" class="difflineminus">-    MAPI_TRACE1(&quot;\tDecoded mime boundary: %s\r\n&quot;, m_mimeBoundary.get());</span>
<a href="#l4.699"></a><span id="l4.699" class="difflineminus">-    MAPI_TRACE1(&quot;\tDecoded mime charset: %s\r\n&quot;, m_mimeCharset.get());</span>
<a href="#l4.700"></a><span id="l4.700" class="difflineplus">+    if (haveC) {</span>
<a href="#l4.701"></a><span id="l4.701" class="difflineplus">+      tStr.Trim(kWhitespace);</span>
<a href="#l4.702"></a><span id="l4.702" class="difflineplus">+      CopyUTF16toUTF8(tStr, m_mimeCharset);</span>
<a href="#l4.703"></a><span id="l4.703" class="difflineplus">+    }</span>
<a href="#l4.704"></a><span id="l4.704" class="difflineplus">+    if (*begin)</span>
<a href="#l4.705"></a><span id="l4.705" class="difflineplus">+      begin++;</span>
<a href="#l4.706"></a><span id="l4.706">   }</span>
<a href="#l4.707"></a><span id="l4.707"> }</span>
<a href="#l4.708"></a><span id="l4.708"> </span>
<a href="#l4.709"></a><span id="l4.709" class="difflineminus">-BOOL CMapiMessage::FetchBody( void)</span>
<a href="#l4.710"></a><span id="l4.710" class="difflineplus">+const char* CpToCharset(unsigned int cp)</span>
<a href="#l4.711"></a><span id="l4.711"> {</span>
<a href="#l4.712"></a><span id="l4.712" class="difflineminus">-  m_bodyIsHtml = FALSE;</span>
<a href="#l4.713"></a><span id="l4.713" class="difflineminus">-  m_body.Truncate();</span>
<a href="#l4.714"></a><span id="l4.714" class="difflineminus">-  // Is it html?</span>
<a href="#l4.715"></a><span id="l4.715" class="difflineminus">-  LPSPropValue pVal = CMapiApi::GetMapiProperty( m_lpMsg, 0x1013001e);</span>
<a href="#l4.716"></a><span id="l4.716" class="difflineminus">-  if (pVal &amp;&amp; CMapiApi::IsLargeProperty( pVal))</span>
<a href="#l4.717"></a><span id="l4.717" class="difflineminus">-    CMapiApi::GetLargeStringProperty( m_lpMsg, 0x1013001e, m_body);</span>
<a href="#l4.718"></a><span id="l4.718" class="difflineminus">-  else if (pVal &amp;&amp; (PROP_TYPE( pVal-&gt;ulPropTag) == PT_TSTRING) &amp;&amp; (pVal-&gt;Value.LPSZ) &amp;&amp; (*(pVal-&gt;Value.LPSZ)))</span>
<a href="#l4.719"></a><span id="l4.719" class="difflineminus">-    m_body = pVal-&gt;Value.LPSZ;</span>
<a href="#l4.720"></a><span id="l4.720" class="difflineplus">+  struct CODEPAGE_TO_CHARSET {</span>
<a href="#l4.721"></a><span id="l4.721" class="difflineplus">+    unsigned long cp;</span>
<a href="#l4.722"></a><span id="l4.722" class="difflineplus">+    const char* charset;</span>
<a href="#l4.723"></a><span id="l4.723" class="difflineplus">+  };</span>
<a href="#l4.724"></a><span id="l4.724"> </span>
<a href="#l4.725"></a><span id="l4.725" class="difflineminus">-  // Kind-hearted Outlook will give us html even for a plain text message.</span>
<a href="#l4.726"></a><span id="l4.726" class="difflineminus">-  // But it will include a comment saying it did the conversion.</span>
<a href="#l4.727"></a><span id="l4.727" class="difflineminus">-  // We'll use this as a hack to really use the plain text part.</span>
<a href="#l4.728"></a><span id="l4.728" class="difflineminus">-  //</span>
<a href="#l4.729"></a><span id="l4.729" class="difflineminus">-  // Sadly there are cases where this string is returned despite the fact</span>
<a href="#l4.730"></a><span id="l4.730" class="difflineminus">-  // that the message is indeed HTML.</span>
<a href="#l4.731"></a><span id="l4.731" class="difflineminus">-  //</span>
<a href="#l4.732"></a><span id="l4.732" class="difflineminus">-  // To detect the &quot;true&quot; plain text messages, we look for our string</span>
<a href="#l4.733"></a><span id="l4.733" class="difflineminus">-  // immediately following the &lt;BODY&gt; tag.</span>
<a href="#l4.734"></a><span id="l4.734" class="difflineminus">-  if (!m_body.IsEmpty() &amp;&amp;</span>
<a href="#l4.735"></a><span id="l4.735" class="difflineminus">-      m_body.Find(&quot;&lt;BODY&gt;\r\n&lt;!-- Converted from text/plain format --&gt;&quot;) ==</span>
<a href="#l4.736"></a><span id="l4.736" class="difflineminus">-      kNotFound)</span>
<a href="#l4.737"></a><span id="l4.737" class="difflineminus">-    m_bodyIsHtml = TRUE;</span>
<a href="#l4.738"></a><span id="l4.738" class="difflineminus">-  else</span>
<a href="#l4.739"></a><span id="l4.739" class="difflineminus">-  {</span>
<a href="#l4.740"></a><span id="l4.740" class="difflineminus">-    pVal = CMapiApi::GetMapiProperty( m_lpMsg, PR_BODY);</span>
<a href="#l4.741"></a><span id="l4.741" class="difflineminus">-    if (pVal)</span>
<a href="#l4.742"></a><span id="l4.742" class="difflineplus">+  // This table is based on http://msdn.microsoft.com/en-us/library/dd317756(v=VS.85).aspx#1;</span>
<a href="#l4.743"></a><span id="l4.743" class="difflineplus">+  // Please extend as appropriate. The codepage values are sorted ascending.</span>
<a href="#l4.744"></a><span id="l4.744" class="difflineplus">+  static const CODEPAGE_TO_CHARSET cptocharset[] =</span>
<a href="#l4.745"></a><span id="l4.745">     {</span>
<a href="#l4.746"></a><span id="l4.746" class="difflineminus">-      if (pVal &amp;&amp; CMapiApi::IsLargeProperty( pVal)) {</span>
<a href="#l4.747"></a><span id="l4.747" class="difflineminus">-        CMapiApi::GetLargeStringProperty( m_lpMsg, PR_BODY, m_body);</span>
<a href="#l4.748"></a><span id="l4.748" class="difflineminus">-      }</span>
<a href="#l4.749"></a><span id="l4.749" class="difflineminus">-      else {</span>
<a href="#l4.750"></a><span id="l4.750" class="difflineminus">-        if (pVal &amp;&amp; (PROP_TYPE( pVal-&gt;ulPropTag) == PT_TSTRING) &amp;&amp; (pVal-&gt;Value.LPSZ) &amp;&amp; (*(pVal-&gt;Value.LPSZ))) {</span>
<a href="#l4.751"></a><span id="l4.751" class="difflineminus">-          m_body = pVal-&gt;Value.LPSZ;</span>
<a href="#l4.752"></a><span id="l4.752" class="difflineminus">-        }</span>
<a href="#l4.753"></a><span id="l4.753" class="difflineplus">+      {37, &quot;IBM037&quot;}, // IBM EBCDIC US-Canada</span>
<a href="#l4.754"></a><span id="l4.754" class="difflineplus">+      {437, &quot;IBM437&quot;}, //OEM United States</span>
<a href="#l4.755"></a><span id="l4.755" class="difflineplus">+      {500, &quot;IBM500&quot;}, //IBM EBCDIC International</span>
<a href="#l4.756"></a><span id="l4.756" class="difflineplus">+      {708, &quot;ASMO-708&quot;}, //Arabic (ASMO 708)</span>
<a href="#l4.757"></a><span id="l4.757" class="difflineplus">+      //709  Arabic (ASMO-449+, BCON V4)</span>
<a href="#l4.758"></a><span id="l4.758" class="difflineplus">+      //710  Arabic - Transparent Arabic</span>
<a href="#l4.759"></a><span id="l4.759" class="difflineplus">+      {720, &quot;DOS-720&quot;}, //Arabic (Transparent ASMO); Arabic (DOS)</span>
<a href="#l4.760"></a><span id="l4.760" class="difflineplus">+      {737, &quot;ibm737&quot;}, // OEM Greek (formerly 437G); Greek (DOS)</span>
<a href="#l4.761"></a><span id="l4.761" class="difflineplus">+      {775, &quot;ibm775&quot;}, // OEM Baltic; Baltic (DOS)</span>
<a href="#l4.762"></a><span id="l4.762" class="difflineplus">+      {850, &quot;ibm850&quot;}, // OEM Multilingual Latin 1; Western European (DOS)</span>
<a href="#l4.763"></a><span id="l4.763" class="difflineplus">+      {852, &quot;ibm852&quot;}, // OEM Latin 2; Central European (DOS)</span>
<a href="#l4.764"></a><span id="l4.764" class="difflineplus">+      {855, &quot;IBM855&quot;}, // OEM Cyrillic (primarily Russian)</span>
<a href="#l4.765"></a><span id="l4.765" class="difflineplus">+      {857, &quot;ibm857&quot;}, // OEM Turkish; Turkish (DOS)</span>
<a href="#l4.766"></a><span id="l4.766" class="difflineplus">+      {858, &quot;IBM00858&quot;}, // OEM Multilingual Latin 1 + Euro symbol</span>
<a href="#l4.767"></a><span id="l4.767" class="difflineplus">+      {860, &quot;IBM860&quot;}, // OEM Portuguese; Portuguese (DOS)</span>
<a href="#l4.768"></a><span id="l4.768" class="difflineplus">+      {861, &quot;ibm861&quot;}, // OEM Icelandic; Icelandic (DOS)</span>
<a href="#l4.769"></a><span id="l4.769" class="difflineplus">+      {862, &quot;DOS-862&quot;}, // OEM Hebrew; Hebrew (DOS)</span>
<a href="#l4.770"></a><span id="l4.770" class="difflineplus">+      {863, &quot;IBM863&quot;}, // OEM French Canadian; French Canadian (DOS)</span>
<a href="#l4.771"></a><span id="l4.771" class="difflineplus">+      {864, &quot;IBM864&quot;}, // OEM Arabic; Arabic (864)</span>
<a href="#l4.772"></a><span id="l4.772" class="difflineplus">+      {865, &quot;IBM865&quot;}, // OEM Nordic; Nordic (DOS)</span>
<a href="#l4.773"></a><span id="l4.773" class="difflineplus">+      {866, &quot;cp866&quot;}, // OEM Russian; Cyrillic (DOS)</span>
<a href="#l4.774"></a><span id="l4.774" class="difflineplus">+      {869, &quot;ibm869&quot;}, // OEM Modern Greek; Greek, Modern (DOS)</span>
<a href="#l4.775"></a><span id="l4.775" class="difflineplus">+      {870, &quot;IBM870&quot;}, // IBM EBCDIC Multilingual/ROECE (Latin 2); IBM EBCDIC Multilingual Latin 2</span>
<a href="#l4.776"></a><span id="l4.776" class="difflineplus">+      {874, &quot;windows-874&quot;}, // ANSI/OEM Thai (same as 28605, ISO 8859-15); Thai (Windows)</span>
<a href="#l4.777"></a><span id="l4.777" class="difflineplus">+      {875, &quot;cp875&quot;}, // IBM EBCDIC Greek Modern</span>
<a href="#l4.778"></a><span id="l4.778" class="difflineplus">+      {932, &quot;shift_jis&quot;}, // ANSI/OEM Japanese; Japanese (Shift-JIS)</span>
<a href="#l4.779"></a><span id="l4.779" class="difflineplus">+      {936, &quot;gb2312&quot;}, // ANSI/OEM Simplified Chinese (PRC, Singapore); Chinese Simplified (GB2312)</span>
<a href="#l4.780"></a><span id="l4.780" class="difflineplus">+      {949, &quot;ks_c_5601-1987&quot;}, // ANSI/OEM Korean (Unified Hangul Code)</span>
<a href="#l4.781"></a><span id="l4.781" class="difflineplus">+      {950, &quot;big5&quot;}, // ANSI/OEM Traditional Chinese (Taiwan; Hong Kong SAR, PRC); Chinese Traditional (Big5)</span>
<a href="#l4.782"></a><span id="l4.782" class="difflineplus">+      {1026, &quot;IBM1026&quot;}, // IBM EBCDIC Turkish (Latin 5)</span>
<a href="#l4.783"></a><span id="l4.783" class="difflineplus">+      {1047, &quot;IBM01047&quot;}, // IBM EBCDIC Latin 1/Open System</span>
<a href="#l4.784"></a><span id="l4.784" class="difflineplus">+      {1140, &quot;IBM01140&quot;}, // IBM EBCDIC US-Canada (037 + Euro symbol); IBM EBCDIC (US-Canada-Euro)</span>
<a href="#l4.785"></a><span id="l4.785" class="difflineplus">+      {1141, &quot;IBM01141&quot;}, // IBM EBCDIC Germany (20273 + Euro symbol); IBM EBCDIC (Germany-Euro)</span>
<a href="#l4.786"></a><span id="l4.786" class="difflineplus">+      {1142, &quot;IBM01142&quot;}, // IBM EBCDIC Denmark-Norway (20277 + Euro symbol); IBM EBCDIC (Denmark-Norway-Euro)</span>
<a href="#l4.787"></a><span id="l4.787" class="difflineplus">+      {1143, &quot;IBM01143&quot;}, // IBM EBCDIC Finland-Sweden (20278 + Euro symbol); IBM EBCDIC (Finland-Sweden-Euro)</span>
<a href="#l4.788"></a><span id="l4.788" class="difflineplus">+      {1144, &quot;IBM01144&quot;}, // IBM EBCDIC Italy (20280 + Euro symbol); IBM EBCDIC (Italy-Euro)</span>
<a href="#l4.789"></a><span id="l4.789" class="difflineplus">+      {1145, &quot;IBM01145&quot;}, // IBM EBCDIC Latin America-Spain (20284 + Euro symbol); IBM EBCDIC (Spain-Euro)</span>
<a href="#l4.790"></a><span id="l4.790" class="difflineplus">+      {1146, &quot;IBM01146&quot;}, // IBM EBCDIC United Kingdom (20285 + Euro symbol); IBM EBCDIC (UK-Euro)</span>
<a href="#l4.791"></a><span id="l4.791" class="difflineplus">+      {1147, &quot;IBM01147&quot;}, // IBM EBCDIC France (20297 + Euro symbol); IBM EBCDIC (France-Euro)</span>
<a href="#l4.792"></a><span id="l4.792" class="difflineplus">+      {1148, &quot;IBM01148&quot;}, // IBM EBCDIC International (500 + Euro symbol); IBM EBCDIC (International-Euro)</span>
<a href="#l4.793"></a><span id="l4.793" class="difflineplus">+      {1149, &quot;IBM01149&quot;}, // IBM EBCDIC Icelandic (20871 + Euro symbol); IBM EBCDIC (Icelandic-Euro)</span>
<a href="#l4.794"></a><span id="l4.794" class="difflineplus">+      {1200, &quot;utf-16&quot;}, // Unicode UTF-16, little endian byte order (BMP of ISO 10646); available only to managed applications</span>
<a href="#l4.795"></a><span id="l4.795" class="difflineplus">+      {1201, &quot;unicodeFFFE&quot;}, // Unicode UTF-16, big endian byte order; available only to managed applications</span>
<a href="#l4.796"></a><span id="l4.796" class="difflineplus">+      {1250, &quot;windows-1250&quot;}, // ANSI Central European; Central European (Windows)</span>
<a href="#l4.797"></a><span id="l4.797" class="difflineplus">+      {1251, &quot;windows-1251&quot;}, // ANSI Cyrillic; Cyrillic (Windows)</span>
<a href="#l4.798"></a><span id="l4.798" class="difflineplus">+      {1252, &quot;windows-1252&quot;}, // ANSI Latin 1; Western European (Windows)</span>
<a href="#l4.799"></a><span id="l4.799" class="difflineplus">+      {1253, &quot;windows-1253&quot;}, // ANSI Greek; Greek (Windows)</span>
<a href="#l4.800"></a><span id="l4.800" class="difflineplus">+      {1254, &quot;windows-1254&quot;}, // ANSI Turkish; Turkish (Windows)</span>
<a href="#l4.801"></a><span id="l4.801" class="difflineplus">+      {1255, &quot;windows-1255&quot;}, // ANSI Hebrew; Hebrew (Windows)</span>
<a href="#l4.802"></a><span id="l4.802" class="difflineplus">+      {1256, &quot;windows-1256&quot;}, // ANSI Arabic; Arabic (Windows)</span>
<a href="#l4.803"></a><span id="l4.803" class="difflineplus">+      {1257, &quot;windows-1257&quot;}, // ANSI Baltic; Baltic (Windows)</span>
<a href="#l4.804"></a><span id="l4.804" class="difflineplus">+      {1258, &quot;windows-1258&quot;}, // ANSI/OEM Vietnamese; Vietnamese (Windows)</span>
<a href="#l4.805"></a><span id="l4.805" class="difflineplus">+      {1361, &quot;Johab&quot;}, // Korean (Johab)</span>
<a href="#l4.806"></a><span id="l4.806" class="difflineplus">+      {10000, &quot;macintosh&quot;}, // MAC Roman; Western European (Mac)</span>
<a href="#l4.807"></a><span id="l4.807" class="difflineplus">+      {10001, &quot;x-mac-japanese&quot;}, // Japanese (Mac)</span>
<a href="#l4.808"></a><span id="l4.808" class="difflineplus">+      {10002, &quot;x-mac-chinesetrad&quot;}, // MAC Traditional Chinese (Big5); Chinese Traditional (Mac)</span>
<a href="#l4.809"></a><span id="l4.809" class="difflineplus">+      {10003, &quot;x-mac-korean&quot;}, // Korean (Mac)</span>
<a href="#l4.810"></a><span id="l4.810" class="difflineplus">+      {10004, &quot;x-mac-arabic&quot;}, // Arabic (Mac)</span>
<a href="#l4.811"></a><span id="l4.811" class="difflineplus">+      {10005, &quot;x-mac-hebrew&quot;}, // Hebrew (Mac)</span>
<a href="#l4.812"></a><span id="l4.812" class="difflineplus">+      {10006, &quot;x-mac-greek&quot;}, // Greek (Mac)</span>
<a href="#l4.813"></a><span id="l4.813" class="difflineplus">+      {10007, &quot;x-mac-cyrillic&quot;}, // Cyrillic (Mac)</span>
<a href="#l4.814"></a><span id="l4.814" class="difflineplus">+      {10008, &quot;x-mac-chinesesimp&quot;}, // MAC Simplified Chinese (GB 2312); Chinese Simplified (Mac)</span>
<a href="#l4.815"></a><span id="l4.815" class="difflineplus">+      {10010, &quot;x-mac-romanian&quot;}, // Romanian (Mac)</span>
<a href="#l4.816"></a><span id="l4.816" class="difflineplus">+      {10017, &quot;x-mac-ukrainian&quot;}, // Ukrainian (Mac)</span>
<a href="#l4.817"></a><span id="l4.817" class="difflineplus">+      {10021, &quot;x-mac-thai&quot;}, // Thai (Mac)</span>
<a href="#l4.818"></a><span id="l4.818" class="difflineplus">+      {10029, &quot;x-mac-ce&quot;}, // MAC Latin 2; Central European (Mac)</span>
<a href="#l4.819"></a><span id="l4.819" class="difflineplus">+      {10079, &quot;x-mac-icelandic&quot;}, // Icelandic (Mac)</span>
<a href="#l4.820"></a><span id="l4.820" class="difflineplus">+      {10081, &quot;x-mac-turkish&quot;}, // Turkish (Mac)</span>
<a href="#l4.821"></a><span id="l4.821" class="difflineplus">+      {10082, &quot;x-mac-croatian&quot;}, // Croatian (Mac)</span>
<a href="#l4.822"></a><span id="l4.822" class="difflineplus">+      // Unicode UTF-32, little endian byte order; available only to managed applications </span>
<a href="#l4.823"></a><span id="l4.823" class="difflineplus">+      // impossible in 8-bit mail</span>
<a href="#l4.824"></a><span id="l4.824" class="difflineplus">+      {12000, &quot;utf-32&quot;},</span>
<a href="#l4.825"></a><span id="l4.825" class="difflineplus">+       // Unicode UTF-32, big endian byte order; available only to managed applications</span>
<a href="#l4.826"></a><span id="l4.826" class="difflineplus">+       // impossible in 8-bit mail</span>
<a href="#l4.827"></a><span id="l4.827" class="difflineplus">+      {12001, &quot;utf-32BE&quot;},</span>
<a href="#l4.828"></a><span id="l4.828" class="difflineplus">+      {20000, &quot;x-Chinese_CNS&quot;}, // CNS Taiwan; Chinese Traditional (CNS)</span>
<a href="#l4.829"></a><span id="l4.829" class="difflineplus">+      {20001, &quot;x-cp20001&quot;}, // TCA Taiwan</span>
<a href="#l4.830"></a><span id="l4.830" class="difflineplus">+      {20002, &quot;x_Chinese-Eten&quot;}, // Eten Taiwan; Chinese Traditional (Eten)</span>
<a href="#l4.831"></a><span id="l4.831" class="difflineplus">+      {20003, &quot;x-cp20003&quot;}, // IBM5550 Taiwan</span>
<a href="#l4.832"></a><span id="l4.832" class="difflineplus">+      {20004, &quot;x-cp20004&quot;}, // TeleText Taiwan</span>
<a href="#l4.833"></a><span id="l4.833" class="difflineplus">+      {20005, &quot;x-cp20005&quot;}, // Wang Taiwan</span>
<a href="#l4.834"></a><span id="l4.834" class="difflineplus">+      {20105, &quot;x-IA5&quot;}, // IA5 (IRV International Alphabet No. 5, 7-bit); Western European (IA5)</span>
<a href="#l4.835"></a><span id="l4.835" class="difflineplus">+      {20106, &quot;x-IA5-German&quot;}, // IA5 German (7-bit)</span>
<a href="#l4.836"></a><span id="l4.836" class="difflineplus">+      {20107, &quot;x-IA5-Swedish&quot;}, // IA5 Swedish (7-bit)</span>
<a href="#l4.837"></a><span id="l4.837" class="difflineplus">+      {20108, &quot;x-IA5-Norwegian&quot;}, // IA5 Norwegian (7-bit)</span>
<a href="#l4.838"></a><span id="l4.838" class="difflineplus">+      {20127, &quot;us-ascii&quot;}, // US-ASCII (7-bit)</span>
<a href="#l4.839"></a><span id="l4.839" class="difflineplus">+      {20261, &quot;x-cp20261&quot;}, // T.61</span>
<a href="#l4.840"></a><span id="l4.840" class="difflineplus">+      {20269, &quot;x-cp20269&quot;}, // ISO 6937 Non-Spacing Accent</span>
<a href="#l4.841"></a><span id="l4.841" class="difflineplus">+      {20273, &quot;IBM273&quot;}, // IBM EBCDIC Germany</span>
<a href="#l4.842"></a><span id="l4.842" class="difflineplus">+      {20277, &quot;IBM277&quot;}, // IBM EBCDIC Denmark-Norway</span>
<a href="#l4.843"></a><span id="l4.843" class="difflineplus">+      {20278, &quot;IBM278&quot;}, // IBM EBCDIC Finland-Sweden</span>
<a href="#l4.844"></a><span id="l4.844" class="difflineplus">+      {20280, &quot;IBM280&quot;}, // IBM EBCDIC Italy</span>
<a href="#l4.845"></a><span id="l4.845" class="difflineplus">+      {20284, &quot;IBM284&quot;}, // IBM EBCDIC Latin America-Spain</span>
<a href="#l4.846"></a><span id="l4.846" class="difflineplus">+      {20285, &quot;IBM285&quot;}, // IBM EBCDIC United Kingdom</span>
<a href="#l4.847"></a><span id="l4.847" class="difflineplus">+      {20290, &quot;IBM290&quot;}, // IBM EBCDIC Japanese Katakana Extended</span>
<a href="#l4.848"></a><span id="l4.848" class="difflineplus">+      {20297, &quot;IBM297&quot;}, // IBM EBCDIC France</span>
<a href="#l4.849"></a><span id="l4.849" class="difflineplus">+      {20420, &quot;IBM420&quot;}, // IBM EBCDIC Arabic</span>
<a href="#l4.850"></a><span id="l4.850" class="difflineplus">+      {20423, &quot;IBM423&quot;}, // IBM EBCDIC Greek</span>
<a href="#l4.851"></a><span id="l4.851" class="difflineplus">+      {20424, &quot;IBM424&quot;}, // IBM EBCDIC Hebrew</span>
<a href="#l4.852"></a><span id="l4.852" class="difflineplus">+      {20833, &quot;x-EBCDIC-KoreanExtended&quot;}, // IBM EBCDIC Korean Extended</span>
<a href="#l4.853"></a><span id="l4.853" class="difflineplus">+      {20838, &quot;IBM-Thai&quot;}, // IBM EBCDIC Thai</span>
<a href="#l4.854"></a><span id="l4.854" class="difflineplus">+      {20866, &quot;koi8-r&quot;}, // Russian (KOI8-R); Cyrillic (KOI8-R)</span>
<a href="#l4.855"></a><span id="l4.855" class="difflineplus">+      {20871, &quot;IBM871&quot;}, // IBM EBCDIC Icelandic</span>
<a href="#l4.856"></a><span id="l4.856" class="difflineplus">+      {20880, &quot;IBM880&quot;}, // IBM EBCDIC Cyrillic Russian</span>
<a href="#l4.857"></a><span id="l4.857" class="difflineplus">+      {20905, &quot;IBM905&quot;}, // IBM EBCDIC Turkish</span>
<a href="#l4.858"></a><span id="l4.858" class="difflineplus">+      {20924, &quot;IBM00924&quot;}, // IBM EBCDIC Latin 1/Open System (1047 + Euro symbol)</span>
<a href="#l4.859"></a><span id="l4.859" class="difflineplus">+      {20932, &quot;EUC-JP&quot;}, // Japanese (JIS 0208-1990 and 0121-1990)</span>
<a href="#l4.860"></a><span id="l4.860" class="difflineplus">+      {20936, &quot;x-cp20936&quot;}, // Simplified Chinese (GB2312); Chinese Simplified (GB2312-80)</span>
<a href="#l4.861"></a><span id="l4.861" class="difflineplus">+      {20949, &quot;x-cp20949&quot;}, // Korean Wansung</span>
<a href="#l4.862"></a><span id="l4.862" class="difflineplus">+      {21025, &quot;cp1025&quot;}, // IBM EBCDIC Cyrillic Serbian-Bulgarian</span>
<a href="#l4.863"></a><span id="l4.863" class="difflineplus">+      //21027  (deprecated)</span>
<a href="#l4.864"></a><span id="l4.864" class="difflineplus">+      {21866, &quot;koi8-u&quot;}, // Ukrainian (KOI8-U); Cyrillic (KOI8-U)</span>
<a href="#l4.865"></a><span id="l4.865" class="difflineplus">+      {28591, &quot;iso-8859-1&quot;}, // ISO 8859-1 Latin 1; Western European (ISO)</span>
<a href="#l4.866"></a><span id="l4.866" class="difflineplus">+      {28592, &quot;iso-8859-2&quot;}, // ISO 8859-2 Central European; Central European (ISO)</span>
<a href="#l4.867"></a><span id="l4.867" class="difflineplus">+      {28593, &quot;iso-8859-3&quot;}, // ISO 8859-3 Latin 3</span>
<a href="#l4.868"></a><span id="l4.868" class="difflineplus">+      {28594, &quot;iso-8859-4&quot;}, // ISO 8859-4 Baltic</span>
<a href="#l4.869"></a><span id="l4.869" class="difflineplus">+      {28595, &quot;iso-8859-5&quot;}, // ISO 8859-5 Cyrillic</span>
<a href="#l4.870"></a><span id="l4.870" class="difflineplus">+      {28596, &quot;iso-8859-6&quot;}, // ISO 8859-6 Arabic</span>
<a href="#l4.871"></a><span id="l4.871" class="difflineplus">+      {28597, &quot;iso-8859-7&quot;}, // ISO 8859-7 Greek</span>
<a href="#l4.872"></a><span id="l4.872" class="difflineplus">+      {28598, &quot;iso-8859-8&quot;}, // ISO 8859-8 Hebrew; Hebrew (ISO-Visual)</span>
<a href="#l4.873"></a><span id="l4.873" class="difflineplus">+      {28599, &quot;iso-8859-9&quot;}, // ISO 8859-9 Turkish</span>
<a href="#l4.874"></a><span id="l4.874" class="difflineplus">+      {28603, &quot;iso-8859-13&quot;}, // ISO 8859-13 Estonian</span>
<a href="#l4.875"></a><span id="l4.875" class="difflineplus">+      {28605, &quot;iso-8859-15&quot;}, // ISO 8859-15 Latin 9</span>
<a href="#l4.876"></a><span id="l4.876" class="difflineplus">+      {29001, &quot;x-Europa&quot;}, // Europa 3</span>
<a href="#l4.877"></a><span id="l4.877" class="difflineplus">+      {38598, &quot;iso-8859-8-i&quot;}, // ISO 8859-8 Hebrew; Hebrew (ISO-Logical)</span>
<a href="#l4.878"></a><span id="l4.878" class="difflineplus">+      {50220, &quot;iso-2022-jp&quot;}, // ISO 2022 Japanese with no halfwidth Katakana; Japanese (JIS)</span>
<a href="#l4.879"></a><span id="l4.879" class="difflineplus">+      {50221, &quot;csISO2022JP&quot;}, // ISO 2022 Japanese with halfwidth Katakana; Japanese (JIS-Allow 1 byte Kana)</span>
<a href="#l4.880"></a><span id="l4.880" class="difflineplus">+      {50222, &quot;iso-2022-jp&quot;}, // ISO 2022 Japanese JIS X 0201-1989; Japanese (JIS-Allow 1 byte Kana - SO/SI)</span>
<a href="#l4.881"></a><span id="l4.881" class="difflineplus">+      {50225, &quot;iso-2022-kr&quot;}, // ISO 2022 Korean</span>
<a href="#l4.882"></a><span id="l4.882" class="difflineplus">+      {50227, &quot;x-cp50227&quot;}, // ISO 2022 Simplified Chinese; Chinese Simplified (ISO 2022)</span>
<a href="#l4.883"></a><span id="l4.883" class="difflineplus">+      //50229  ISO 2022 Traditional Chinese</span>
<a href="#l4.884"></a><span id="l4.884" class="difflineplus">+      //50930  EBCDIC Japanese (Katakana) Extended</span>
<a href="#l4.885"></a><span id="l4.885" class="difflineplus">+      //50931  EBCDIC US-Canada and Japanese</span>
<a href="#l4.886"></a><span id="l4.886" class="difflineplus">+      //50933  EBCDIC Korean Extended and Korean</span>
<a href="#l4.887"></a><span id="l4.887" class="difflineplus">+      //50935  EBCDIC Simplified Chinese Extended and Simplified Chinese</span>
<a href="#l4.888"></a><span id="l4.888" class="difflineplus">+      //50936  EBCDIC Simplified Chinese</span>
<a href="#l4.889"></a><span id="l4.889" class="difflineplus">+      //50937  EBCDIC US-Canada and Traditional Chinese</span>
<a href="#l4.890"></a><span id="l4.890" class="difflineplus">+      //50939  EBCDIC Japanese (Latin) Extended and Japanese</span>
<a href="#l4.891"></a><span id="l4.891" class="difflineplus">+      {51932, &quot;euc-jp&quot;}, // EUC Japanese</span>
<a href="#l4.892"></a><span id="l4.892" class="difflineplus">+      {51936, &quot;EUC-CN&quot;}, // EUC Simplified Chinese; Chinese Simplified (EUC)</span>
<a href="#l4.893"></a><span id="l4.893" class="difflineplus">+      {51949, &quot;euc-kr&quot;}, // EUC Korean</span>
<a href="#l4.894"></a><span id="l4.894" class="difflineplus">+      //51950  EUC Traditional Chinese</span>
<a href="#l4.895"></a><span id="l4.895" class="difflineplus">+      {52936, &quot;hz-gb-2312&quot;}, // HZ-GB2312 Simplified Chinese; Chinese Simplified (HZ)</span>
<a href="#l4.896"></a><span id="l4.896" class="difflineplus">+      {54936, &quot;GB18030&quot;}, // Windows XP and later: GB18030 Simplified Chinese (4 byte); Chinese Simplified (GB18030)</span>
<a href="#l4.897"></a><span id="l4.897" class="difflineplus">+      {57002, &quot;x-iscii-de&quot;}, // ISCII Devanagari</span>
<a href="#l4.898"></a><span id="l4.898" class="difflineplus">+      {57003, &quot;x-iscii-be&quot;}, // ISCII Bengali</span>
<a href="#l4.899"></a><span id="l4.899" class="difflineplus">+      {57004, &quot;x-iscii-ta&quot;}, // ISCII Tamil</span>
<a href="#l4.900"></a><span id="l4.900" class="difflineplus">+      {57005, &quot;x-iscii-te&quot;}, // ISCII Telugu</span>
<a href="#l4.901"></a><span id="l4.901" class="difflineplus">+      {57006, &quot;x-iscii-as&quot;}, // ISCII Assamese</span>
<a href="#l4.902"></a><span id="l4.902" class="difflineplus">+      {57007, &quot;x-iscii-or&quot;}, // ISCII Oriya</span>
<a href="#l4.903"></a><span id="l4.903" class="difflineplus">+      {57008, &quot;x-iscii-ka&quot;}, // ISCII Kannada</span>
<a href="#l4.904"></a><span id="l4.904" class="difflineplus">+      {57009, &quot;x-iscii-ma&quot;}, // ISCII Malayalam</span>
<a href="#l4.905"></a><span id="l4.905" class="difflineplus">+      {57010, &quot;x-iscii-gu&quot;}, // ISCII Gujarati</span>
<a href="#l4.906"></a><span id="l4.906" class="difflineplus">+      {57011, &quot;x-iscii-pa&quot;}, // ISCII Punjabi</span>
<a href="#l4.907"></a><span id="l4.907" class="difflineplus">+      {65000, &quot;utf-7&quot;}, // Unicode (UTF-7)</span>
<a href="#l4.908"></a><span id="l4.908" class="difflineplus">+      {65001, &quot;utf-8&quot;}, // Unicode (UTF-8)</span>
<a href="#l4.909"></a><span id="l4.909" class="difflineplus">+    };</span>
<a href="#l4.910"></a><span id="l4.910" class="difflineplus">+</span>
<a href="#l4.911"></a><span id="l4.911" class="difflineplus">+  // Binary search</span>
<a href="#l4.912"></a><span id="l4.912" class="difflineplus">+  int begin = 0, end = sizeof(cptocharset)/sizeof(cptocharset[0])-1;</span>
<a href="#l4.913"></a><span id="l4.913" class="difflineplus">+  while (begin &lt;= end) {</span>
<a href="#l4.914"></a><span id="l4.914" class="difflineplus">+    int mid = (begin+end)/2;</span>
<a href="#l4.915"></a><span id="l4.915" class="difflineplus">+    unsigned int mid_cp = cptocharset[mid].cp;</span>
<a href="#l4.916"></a><span id="l4.916" class="difflineplus">+    if (cp == mid_cp)</span>
<a href="#l4.917"></a><span id="l4.917" class="difflineplus">+      return cptocharset[mid].charset;</span>
<a href="#l4.918"></a><span id="l4.918" class="difflineplus">+    if (cp &lt; mid_cp)</span>
<a href="#l4.919"></a><span id="l4.919" class="difflineplus">+      end = mid - 1;</span>
<a href="#l4.920"></a><span id="l4.920" class="difflineplus">+    else // cp &gt; cptocharset[mid].cp</span>
<a href="#l4.921"></a><span id="l4.921" class="difflineplus">+      begin = mid + 1;</span>
<a href="#l4.922"></a><span id="l4.922" class="difflineplus">+  }</span>
<a href="#l4.923"></a><span id="l4.923" class="difflineplus">+  return 0; // not found</span>
<a href="#l4.924"></a><span id="l4.924" class="difflineplus">+}</span>
<a href="#l4.925"></a><span id="l4.925" class="difflineplus">+</span>
<a href="#l4.926"></a><span id="l4.926" class="difflineplus">+// We don't use nsMsgI18Ncheck_data_in_charset_range because it returns true</span>
<a href="#l4.927"></a><span id="l4.927" class="difflineplus">+// even if there's no such charset:</span>
<a href="#l4.928"></a><span id="l4.928" class="difflineplus">+// 1. result initialized by PR_TRUE and returned if, eg, GetUnicodeEncoderRaw fail</span>
<a href="#l4.929"></a><span id="l4.929" class="difflineplus">+// 2. it uses GetUnicodeEncoderRaw(), not GetUnicodeEncoder() (to normalize the</span>
<a href="#l4.930"></a><span id="l4.930" class="difflineplus">+//    charset string) (see nsMsgI18N.cpp)</span>
<a href="#l4.931"></a><span id="l4.931" class="difflineplus">+// This function returns true only if the unicode (utf-16) text can be</span>
<a href="#l4.932"></a><span id="l4.932" class="difflineplus">+// losslessly represented in specified charset</span>
<a href="#l4.933"></a><span id="l4.933" class="difflineplus">+bool CMapiMessage::CheckBodyInCharsetRange(const char* charset)</span>
<a href="#l4.934"></a><span id="l4.934" class="difflineplus">+{</span>
<a href="#l4.935"></a><span id="l4.935" class="difflineplus">+  if (m_body.IsEmpty())</span>
<a href="#l4.936"></a><span id="l4.936" class="difflineplus">+    return true;</span>
<a href="#l4.937"></a><span id="l4.937" class="difflineplus">+  if (!_stricmp(charset, &quot;utf-8&quot;))</span>
<a href="#l4.938"></a><span id="l4.938" class="difflineplus">+    return true;</span>
<a href="#l4.939"></a><span id="l4.939" class="difflineplus">+  if (!_stricmp(charset, &quot;utf-7&quot;))</span>
<a href="#l4.940"></a><span id="l4.940" class="difflineplus">+    return true;</span>
<a href="#l4.941"></a><span id="l4.941" class="difflineplus">+</span>
<a href="#l4.942"></a><span id="l4.942" class="difflineplus">+  nsresult rv;</span>
<a href="#l4.943"></a><span id="l4.943" class="difflineplus">+  static nsCOMPtr&lt;nsICharsetConverterManager&gt; ccm =</span>
<a href="#l4.944"></a><span id="l4.944" class="difflineplus">+    do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l4.945"></a><span id="l4.945" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, false);</span>
<a href="#l4.946"></a><span id="l4.946" class="difflineplus">+  nsCOMPtr&lt;nsIUnicodeEncoder&gt; encoder;</span>
<a href="#l4.947"></a><span id="l4.947" class="difflineplus">+</span>
<a href="#l4.948"></a><span id="l4.948" class="difflineplus">+  // get an unicode converter</span>
<a href="#l4.949"></a><span id="l4.949" class="difflineplus">+  rv = ccm-&gt;GetUnicodeEncoder(charset, getter_AddRefs(encoder));</span>
<a href="#l4.950"></a><span id="l4.950" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, false);</span>
<a href="#l4.951"></a><span id="l4.951" class="difflineplus">+  rv = encoder-&gt;SetOutputErrorBehavior(nsIUnicodeEncoder::kOnError_Signal, nsnull, 0);</span>
<a href="#l4.952"></a><span id="l4.952" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, false);</span>
<a href="#l4.953"></a><span id="l4.953" class="difflineplus">+</span>
<a href="#l4.954"></a><span id="l4.954" class="difflineplus">+  const wchar_t *txt = m_body.get();</span>
<a href="#l4.955"></a><span id="l4.955" class="difflineplus">+  PRInt32 txtLen = m_body.Length();</span>
<a href="#l4.956"></a><span id="l4.956" class="difflineplus">+  const wchar_t *currentSrcPtr = txt;</span>
<a href="#l4.957"></a><span id="l4.957" class="difflineplus">+  int srcLength;</span>
<a href="#l4.958"></a><span id="l4.958" class="difflineplus">+  int dstLength;</span>
<a href="#l4.959"></a><span id="l4.959" class="difflineplus">+  char localbuf[512];</span>
<a href="#l4.960"></a><span id="l4.960" class="difflineplus">+  int consumedLen = 0;</span>
<a href="#l4.961"></a><span id="l4.961" class="difflineplus">+</span>
<a href="#l4.962"></a><span id="l4.962" class="difflineplus">+  // convert</span>
<a href="#l4.963"></a><span id="l4.963" class="difflineplus">+  while (consumedLen &lt; txtLen) {</span>
<a href="#l4.964"></a><span id="l4.964" class="difflineplus">+    srcLength = txtLen - consumedLen;  </span>
<a href="#l4.965"></a><span id="l4.965" class="difflineplus">+    dstLength = sizeof(localbuf)/sizeof(localbuf[0]);</span>
<a href="#l4.966"></a><span id="l4.966" class="difflineplus">+    rv = encoder-&gt;Convert(currentSrcPtr, &amp;srcLength, localbuf, &amp;dstLength);</span>
<a href="#l4.967"></a><span id="l4.967" class="difflineplus">+    if (rv == NS_ERROR_UENC_NOMAPPING)</span>
<a href="#l4.968"></a><span id="l4.968" class="difflineplus">+      return false;</span>
<a href="#l4.969"></a><span id="l4.969" class="difflineplus">+    if (NS_FAILED(rv) || dstLength == 0)</span>
<a href="#l4.970"></a><span id="l4.970" class="difflineplus">+      break;</span>
<a href="#l4.971"></a><span id="l4.971" class="difflineplus">+</span>
<a href="#l4.972"></a><span id="l4.972" class="difflineplus">+    currentSrcPtr += srcLength;</span>
<a href="#l4.973"></a><span id="l4.973" class="difflineplus">+    consumedLen = currentSrcPtr - txt; // src length used so far</span>
<a href="#l4.974"></a><span id="l4.974" class="difflineplus">+  }</span>
<a href="#l4.975"></a><span id="l4.975" class="difflineplus">+  return true;</span>
<a href="#l4.976"></a><span id="l4.976" class="difflineplus">+}</span>
<a href="#l4.977"></a><span id="l4.977" class="difflineplus">+</span>
<a href="#l4.978"></a><span id="l4.978" class="difflineplus">+bool CaseInsensitiveComp (wchar_t elem1, wchar_t elem2 )</span>
<a href="#l4.979"></a><span id="l4.979" class="difflineplus">+{</span>
<a href="#l4.980"></a><span id="l4.980" class="difflineplus">+  return _wcsnicmp(&amp;elem1, &amp;elem2, 1) == 0;</span>
<a href="#l4.981"></a><span id="l4.981" class="difflineplus">+}</span>
<a href="#l4.982"></a><span id="l4.982" class="difflineplus">+</span>
<a href="#l4.983"></a><span id="l4.983" class="difflineplus">+void ExtractMetaCharset( const wchar_t* body, int bodySz, /*out*/nsCString&amp; charset)</span>
<a href="#l4.984"></a><span id="l4.984" class="difflineplus">+{</span>
<a href="#l4.985"></a><span id="l4.985" class="difflineplus">+  charset.Truncate();</span>
<a href="#l4.986"></a><span id="l4.986" class="difflineplus">+  const wchar_t* body_end = body+bodySz;</span>
<a href="#l4.987"></a><span id="l4.987" class="difflineplus">+  const wchar_t str_eohd[] = L&quot;/head&quot;;</span>
<a href="#l4.988"></a><span id="l4.988" class="difflineplus">+  const wchar_t *str_eohd_end = str_eohd+sizeof(str_eohd)/sizeof(str_eohd[0])-1;</span>
<a href="#l4.989"></a><span id="l4.989" class="difflineplus">+  const wchar_t* eohd_pos = std::search(body, body_end, str_eohd, str_eohd_end,</span>
<a href="#l4.990"></a><span id="l4.990" class="difflineplus">+                                        CaseInsensitiveComp);</span>
<a href="#l4.991"></a><span id="l4.991" class="difflineplus">+  if (eohd_pos == body_end) // No header!</span>
<a href="#l4.992"></a><span id="l4.992" class="difflineplus">+    return;</span>
<a href="#l4.993"></a><span id="l4.993" class="difflineplus">+  const wchar_t str_chset[] = L&quot;charset=&quot;;</span>
<a href="#l4.994"></a><span id="l4.994" class="difflineplus">+  const wchar_t *str_chset_end =</span>
<a href="#l4.995"></a><span id="l4.995" class="difflineplus">+    str_chset + sizeof(str_chset)/sizeof(str_chset[0])-1;</span>
<a href="#l4.996"></a><span id="l4.996" class="difflineplus">+  const wchar_t* chset_pos = std::search(body, eohd_pos, str_chset,</span>
<a href="#l4.997"></a><span id="l4.997" class="difflineplus">+                                         str_chset_end, CaseInsensitiveComp);</span>
<a href="#l4.998"></a><span id="l4.998" class="difflineplus">+  if (chset_pos == eohd_pos) // No charset!</span>
<a href="#l4.999"></a><span id="l4.999" class="difflineplus">+    return;</span>
<a href="#l4.1000"></a><span id="l4.1000" class="difflineplus">+  chset_pos += 8;</span>
<a href="#l4.1001"></a><span id="l4.1001" class="difflineplus">+</span>
<a href="#l4.1002"></a><span id="l4.1002" class="difflineplus">+  // remove everything from the string after the next ; or &quot; or space,</span>
<a href="#l4.1003"></a><span id="l4.1003" class="difflineplus">+  // whichever comes first.</span>
<a href="#l4.1004"></a><span id="l4.1004" class="difflineplus">+  // The inital sting looks something like</span>
<a href="#l4.1005"></a><span id="l4.1005" class="difflineplus">+  // &lt;META content=&quot;text/html; charset=utf-8&quot; http-equiv=Content-Type&gt;</span>
<a href="#l4.1006"></a><span id="l4.1006" class="difflineplus">+  // &lt;META content=&quot;text/html; charset=utf-8;&quot; http-equiv=Content-Type&gt;</span>
<a href="#l4.1007"></a><span id="l4.1007" class="difflineplus">+  // &lt;META content=&quot;text/html; charset=utf-8 ;&quot; http-equiv=Content-Type&gt;</span>
<a href="#l4.1008"></a><span id="l4.1008" class="difflineplus">+  // &lt;META content=&quot;text/html; charset=utf-8 &quot; http-equiv=Content-Type&gt;</span>
<a href="#l4.1009"></a><span id="l4.1009" class="difflineplus">+  const wchar_t term[] = L&quot;;\&quot; &quot;, *term_end= term+sizeof(term)/sizeof(term[0])-1;</span>
<a href="#l4.1010"></a><span id="l4.1010" class="difflineplus">+  const wchar_t* chset_end = std::find_first_of(chset_pos, eohd_pos, term,</span>
<a href="#l4.1011"></a><span id="l4.1011" class="difflineplus">+                                                term_end);</span>
<a href="#l4.1012"></a><span id="l4.1012" class="difflineplus">+  if (chset_end != eohd_pos)</span>
<a href="#l4.1013"></a><span id="l4.1013" class="difflineplus">+    LossyCopyUTF16toASCII(Substring(chset_pos, chset_end), charset);</span>
<a href="#l4.1014"></a><span id="l4.1014" class="difflineplus">+}</span>
<a href="#l4.1015"></a><span id="l4.1015" class="difflineplus">+</span>
<a href="#l4.1016"></a><span id="l4.1016" class="difflineplus">+bool CMapiMessage::FetchBody( void)</span>
<a href="#l4.1017"></a><span id="l4.1017" class="difflineplus">+{</span>
<a href="#l4.1018"></a><span id="l4.1018" class="difflineplus">+  m_bodyIsHtml = false;</span>
<a href="#l4.1019"></a><span id="l4.1019" class="difflineplus">+  m_body.Truncate();</span>
<a href="#l4.1020"></a><span id="l4.1020" class="difflineplus">+</span>
<a href="#l4.1021"></a><span id="l4.1021" class="difflineplus">+  // Get the Outlook codepage info; if unsuccessful then it defaults to 0 (CP_ACP) -&gt; system default</span>
<a href="#l4.1022"></a><span id="l4.1022" class="difflineplus">+  // Maybe we can use this info later?</span>
<a href="#l4.1023"></a><span id="l4.1023" class="difflineplus">+  unsigned int codepage=0;</span>
<a href="#l4.1024"></a><span id="l4.1024" class="difflineplus">+  LPSPropValue pVal = CMapiApi::GetMapiProperty( m_lpMsg, PR_INTERNET_CPID);</span>
<a href="#l4.1025"></a><span id="l4.1025" class="difflineplus">+  if (pVal) {</span>
<a href="#l4.1026"></a><span id="l4.1026" class="difflineplus">+    if (PROP_TYPE( pVal-&gt;ulPropTag) == PT_LONG)</span>
<a href="#l4.1027"></a><span id="l4.1027" class="difflineplus">+      codepage = pVal-&gt;Value.l;</span>
<a href="#l4.1028"></a><span id="l4.1028" class="difflineplus">+    CMapiApi::MAPIFreeBuffer( pVal);</span>
<a href="#l4.1029"></a><span id="l4.1029" class="difflineplus">+  }</span>
<a href="#l4.1030"></a><span id="l4.1030" class="difflineplus">+</span>
<a href="#l4.1031"></a><span id="l4.1031" class="difflineplus">+  unsigned long nativeBodyType = 0;</span>
<a href="#l4.1032"></a><span id="l4.1032" class="difflineplus">+  if (CMapiApi::GetRTFPropertyDecodedAsUTF16(m_lpMsg, m_body, nativeBodyType,</span>
<a href="#l4.1033"></a><span id="l4.1033" class="difflineplus">+                                             codepage)) {</span>
<a href="#l4.1034"></a><span id="l4.1034" class="difflineplus">+    m_bodyIsHtml = nativeBodyType == MAPI_NATIVE_BODY_TYPE_HTML;</span>
<a href="#l4.1035"></a><span id="l4.1035" class="difflineplus">+  }</span>
<a href="#l4.1036"></a><span id="l4.1036" class="difflineplus">+  else { // Cannot get RTF version</span>
<a href="#l4.1037"></a><span id="l4.1037" class="difflineplus">+    // Is it html?</span>
<a href="#l4.1038"></a><span id="l4.1038" class="difflineplus">+    pVal = CMapiApi::GetMapiProperty(m_lpMsg, PR_BODY_HTML_W);</span>
<a href="#l4.1039"></a><span id="l4.1039" class="difflineplus">+    if (pVal) {</span>
<a href="#l4.1040"></a><span id="l4.1040" class="difflineplus">+      if (CMapiApi::IsLargeProperty(pVal))</span>
<a href="#l4.1041"></a><span id="l4.1041" class="difflineplus">+        CMapiApi::GetLargeStringProperty(m_lpMsg, PR_BODY_HTML_W, m_body);</span>
<a href="#l4.1042"></a><span id="l4.1042" class="difflineplus">+      else if ((PROP_TYPE(pVal-&gt;ulPropTag) == PT_UNICODE) &amp;&amp;</span>
<a href="#l4.1043"></a><span id="l4.1043" class="difflineplus">+               (pVal-&gt;Value.lpszW) &amp;&amp; (*(pVal-&gt;Value.lpszW)))</span>
<a href="#l4.1044"></a><span id="l4.1044" class="difflineplus">+        m_body.Assign(pVal-&gt;Value.lpszW);</span>
<a href="#l4.1045"></a><span id="l4.1045" class="difflineplus">+      CMapiApi::MAPIFreeBuffer( pVal);</span>
<a href="#l4.1046"></a><span id="l4.1046" class="difflineplus">+    }</span>
<a href="#l4.1047"></a><span id="l4.1047" class="difflineplus">+</span>
<a href="#l4.1048"></a><span id="l4.1048" class="difflineplus">+    // Kind-hearted Outlook will give us html even for a plain text message.</span>
<a href="#l4.1049"></a><span id="l4.1049" class="difflineplus">+    // But it will include a comment saying it did the conversion.</span>
<a href="#l4.1050"></a><span id="l4.1050" class="difflineplus">+    // We'll use this as a hack to really use the plain text part.</span>
<a href="#l4.1051"></a><span id="l4.1051" class="difflineplus">+    //</span>
<a href="#l4.1052"></a><span id="l4.1052" class="difflineplus">+    // Sadly there are cases where this string is returned despite the fact</span>
<a href="#l4.1053"></a><span id="l4.1053" class="difflineplus">+    // that the message is indeed HTML.</span>
<a href="#l4.1054"></a><span id="l4.1054" class="difflineplus">+    //</span>
<a href="#l4.1055"></a><span id="l4.1055" class="difflineplus">+    // To detect the &quot;true&quot; plain text messages, we look for our string</span>
<a href="#l4.1056"></a><span id="l4.1056" class="difflineplus">+    // immediately following the &lt;BODY&gt; tag.</span>
<a href="#l4.1057"></a><span id="l4.1057" class="difflineplus">+    if (!m_body.IsEmpty() &amp;&amp;</span>
<a href="#l4.1058"></a><span id="l4.1058" class="difflineplus">+        m_body.Find(L&quot;&lt;BODY&gt;\r\n&lt;!-- Converted from text/plain format --&gt;&quot;) ==</span>
<a href="#l4.1059"></a><span id="l4.1059" class="difflineplus">+        kNotFound) {</span>
<a href="#l4.1060"></a><span id="l4.1060" class="difflineplus">+      m_bodyIsHtml = true;</span>
<a href="#l4.1061"></a><span id="l4.1061" class="difflineplus">+    }</span>
<a href="#l4.1062"></a><span id="l4.1062" class="difflineplus">+    else {</span>
<a href="#l4.1063"></a><span id="l4.1063" class="difflineplus">+      pVal = CMapiApi::GetMapiProperty(m_lpMsg, PR_BODY_W);</span>
<a href="#l4.1064"></a><span id="l4.1064" class="difflineplus">+      if (pVal) {</span>
<a href="#l4.1065"></a><span id="l4.1065" class="difflineplus">+        if (CMapiApi::IsLargeProperty(pVal))</span>
<a href="#l4.1066"></a><span id="l4.1066" class="difflineplus">+          CMapiApi::GetLargeStringProperty(m_lpMsg, PR_BODY_W, m_body);</span>
<a href="#l4.1067"></a><span id="l4.1067" class="difflineplus">+        else if ((PROP_TYPE(pVal-&gt;ulPropTag) == PT_UNICODE) &amp;&amp;</span>
<a href="#l4.1068"></a><span id="l4.1068" class="difflineplus">+                 (pVal-&gt;Value.lpszW) &amp;&amp; (*(pVal-&gt;Value.lpszW)))</span>
<a href="#l4.1069"></a><span id="l4.1069" class="difflineplus">+          m_body.Assign(pVal-&gt;Value.lpszW);</span>
<a href="#l4.1070"></a><span id="l4.1070" class="difflineplus">+        CMapiApi::MAPIFreeBuffer(pVal);</span>
<a href="#l4.1071"></a><span id="l4.1071">       }</span>
<a href="#l4.1072"></a><span id="l4.1072">     }</span>
<a href="#l4.1073"></a><span id="l4.1073">   }</span>
<a href="#l4.1074"></a><span id="l4.1074"> </span>
<a href="#l4.1075"></a><span id="l4.1075" class="difflineminus">-  if (pVal)</span>
<a href="#l4.1076"></a><span id="l4.1076" class="difflineminus">-    CMapiApi::MAPIFreeBuffer( pVal);</span>
<a href="#l4.1077"></a><span id="l4.1077" class="difflineplus">+  // OK, now let's restore the original encoding!</span>
<a href="#l4.1078"></a><span id="l4.1078" class="difflineplus">+  // 1. We may have a header defining the charset (we already called the FetchHeaders(), and there ProcessHeaders();</span>
<a href="#l4.1079"></a><span id="l4.1079" class="difflineplus">+  //    in this case, the m_mimeCharset is set. See nsOutlookMail::ImportMailbox())</span>
<a href="#l4.1080"></a><span id="l4.1080" class="difflineplus">+  // 2. We may have the codepage walue provided by Outlook (&quot;codepage&quot; at the very beginning of this function)</span>
<a href="#l4.1081"></a><span id="l4.1081" class="difflineplus">+  // 3. We may have an HTML charset header.</span>
<a href="#l4.1082"></a><span id="l4.1082" class="difflineplus">+</span>
<a href="#l4.1083"></a><span id="l4.1083" class="difflineplus">+  bool bFoundCharset = false;</span>
<a href="#l4.1084"></a><span id="l4.1084" class="difflineplus">+</span>
<a href="#l4.1085"></a><span id="l4.1085" class="difflineplus">+  if (!m_mimeCharset.IsEmpty()) // The top-level header data</span>
<a href="#l4.1086"></a><span id="l4.1086" class="difflineplus">+    bFoundCharset = CheckBodyInCharsetRange(m_mimeCharset.get());</span>
<a href="#l4.1087"></a><span id="l4.1087" class="difflineplus">+  // No valid charset in the message header - try the HTML header.</span>
<a href="#l4.1088"></a><span id="l4.1088" class="difflineplus">+  // arguably may be useless</span>
<a href="#l4.1089"></a><span id="l4.1089" class="difflineplus">+  if (!bFoundCharset &amp;&amp; m_bodyIsHtml) {</span>
<a href="#l4.1090"></a><span id="l4.1090" class="difflineplus">+    ExtractMetaCharset(m_body.get(), m_body.Length(), m_mimeCharset);</span>
<a href="#l4.1091"></a><span id="l4.1091" class="difflineplus">+    if (!m_mimeCharset.IsEmpty())</span>
<a href="#l4.1092"></a><span id="l4.1092" class="difflineplus">+      bFoundCharset = CheckBodyInCharsetRange(m_mimeCharset.get());</span>
<a href="#l4.1093"></a><span id="l4.1093" class="difflineplus">+  }</span>
<a href="#l4.1094"></a><span id="l4.1094" class="difflineplus">+  // Get from Outlook (seems like it keeps the MIME part header encoding info)</span>
<a href="#l4.1095"></a><span id="l4.1095" class="difflineplus">+  if (!bFoundCharset &amp;&amp; codepage) {</span>
<a href="#l4.1096"></a><span id="l4.1096" class="difflineplus">+    const char* charset = CpToCharset(codepage);</span>
<a href="#l4.1097"></a><span id="l4.1097" class="difflineplus">+    if (charset) {</span>
<a href="#l4.1098"></a><span id="l4.1098" class="difflineplus">+      bFoundCharset = CheckBodyInCharsetRange(charset);</span>
<a href="#l4.1099"></a><span id="l4.1099" class="difflineplus">+      if (bFoundCharset)</span>
<a href="#l4.1100"></a><span id="l4.1100" class="difflineplus">+        m_mimeCharset.Assign(charset);</span>
<a href="#l4.1101"></a><span id="l4.1101" class="difflineplus">+    }</span>
<a href="#l4.1102"></a><span id="l4.1102" class="difflineplus">+  }</span>
<a href="#l4.1103"></a><span id="l4.1103" class="difflineplus">+  if (!bFoundCharset) { // Use system default</span>
<a href="#l4.1104"></a><span id="l4.1104" class="difflineplus">+    const char* charset = nsMsgI18NFileSystemCharset();</span>
<a href="#l4.1105"></a><span id="l4.1105" class="difflineplus">+    if (charset) {</span>
<a href="#l4.1106"></a><span id="l4.1106" class="difflineplus">+      bFoundCharset = CheckBodyInCharsetRange(charset);</span>
<a href="#l4.1107"></a><span id="l4.1107" class="difflineplus">+      if (bFoundCharset)</span>
<a href="#l4.1108"></a><span id="l4.1108" class="difflineplus">+        m_mimeCharset.Assign(charset);</span>
<a href="#l4.1109"></a><span id="l4.1109" class="difflineplus">+    }</span>
<a href="#l4.1110"></a><span id="l4.1110" class="difflineplus">+  }</span>
<a href="#l4.1111"></a><span id="l4.1111" class="difflineplus">+  if (!bFoundCharset) // Everything else failed, let's use the lossless utf-8...</span>
<a href="#l4.1112"></a><span id="l4.1112" class="difflineplus">+    m_mimeCharset.Assign(&quot;utf-8&quot;);</span>
<a href="#l4.1113"></a><span id="l4.1113"> </span>
<a href="#l4.1114"></a><span id="l4.1114">   MAPI_DUMP_STRING(m_body.get());</span>
<a href="#l4.1115"></a><span id="l4.1115">   MAPI_TRACE0(&quot;\r\n&quot;);</span>
<a href="#l4.1116"></a><span id="l4.1116"> </span>
<a href="#l4.1117"></a><span id="l4.1117" class="difflineminus">-  return( TRUE);</span>
<a href="#l4.1118"></a><span id="l4.1118" class="difflineplus">+  return true;</span>
<a href="#l4.1119"></a><span id="l4.1119" class="difflineplus">+}</span>
<a href="#l4.1120"></a><span id="l4.1120" class="difflineplus">+</span>
<a href="#l4.1121"></a><span id="l4.1121" class="difflineplus">+void CMapiMessage::GetBody(nsCString&amp; dest) const</span>
<a href="#l4.1122"></a><span id="l4.1122" class="difflineplus">+{</span>
<a href="#l4.1123"></a><span id="l4.1123" class="difflineplus">+  nsMsgI18NConvertFromUnicode(m_mimeCharset.get(), m_body, dest);</span>
<a href="#l4.1124"></a><span id="l4.1124" class="difflineplus">+}</span>
<a href="#l4.1125"></a><span id="l4.1125" class="difflineplus">+</span>
<a href="#l4.1126"></a><span id="l4.1126" class="difflineplus">+void CMapiMessage::FetchFlags(void)</span>
<a href="#l4.1127"></a><span id="l4.1127" class="difflineplus">+{</span>
<a href="#l4.1128"></a><span id="l4.1128" class="difflineplus">+  LPSPropValue pVal = CMapiApi::GetMapiProperty(m_lpMsg, PR_MESSAGE_FLAGS);</span>
<a href="#l4.1129"></a><span id="l4.1129" class="difflineplus">+  if (pVal)</span>
<a href="#l4.1130"></a><span id="l4.1130" class="difflineplus">+    m_msgFlags = CMapiApi::GetLongFromProp(pVal);</span>
<a href="#l4.1131"></a><span id="l4.1131" class="difflineplus">+  pVal = CMapiApi::GetMapiProperty(m_lpMsg, PR_LAST_VERB_EXECUTED);</span>
<a href="#l4.1132"></a><span id="l4.1132" class="difflineplus">+  if (pVal)</span>
<a href="#l4.1133"></a><span id="l4.1133" class="difflineplus">+    m_msgLastVerb = CMapiApi::GetLongFromProp(pVal);</span>
<a href="#l4.1134"></a><span id="l4.1134"> }</span>
<a href="#l4.1135"></a><span id="l4.1135"> </span>
<a href="#l4.1136"></a><span id="l4.1136"> enum {</span>
<a href="#l4.1137"></a><span id="l4.1137">   ieidPR_ATTACH_NUM = 0,</span>
<a href="#l4.1138"></a><span id="l4.1138">   ieidAttachMax</span>
<a href="#l4.1139"></a><span id="l4.1139"> };</span>
<a href="#l4.1140"></a><span id="l4.1140"> </span>
<a href="#l4.1141"></a><span id="l4.1141"> static const SizedSPropTagArray(ieidAttachMax, ptaEid)=</span>
<a href="#l4.1142"></a><span id="l4.1142"> {</span>
<a href="#l4.1143"></a><span id="l4.1143">   ieidAttachMax,</span>
<a href="#l4.1144"></a><span id="l4.1144">   {</span>
<a href="#l4.1145"></a><span id="l4.1145">     PR_ATTACH_NUM</span>
<a href="#l4.1146"></a><span id="l4.1146">   }</span>
<a href="#l4.1147"></a><span id="l4.1147"> };</span>
<a href="#l4.1148"></a><span id="l4.1148"> </span>
<a href="#l4.1149"></a><span id="l4.1149" class="difflineminus">-int CMapiMessage::CountAttachments( void)</span>
<a href="#l4.1150"></a><span id="l4.1150" class="difflineplus">+bool CMapiMessage::IterateAttachTable(LPMAPITABLE lpTable)</span>
<a href="#l4.1151"></a><span id="l4.1151"> {</span>
<a href="#l4.1152"></a><span id="l4.1152" class="difflineminus">-  m_attachNums.Clear();</span>
<a href="#l4.1153"></a><span id="l4.1153" class="difflineminus">-</span>
<a href="#l4.1154"></a><span id="l4.1154" class="difflineminus">-  LPSPropValue pVal = CMapiApi::GetMapiProperty( m_lpMsg, PR_HASATTACH);</span>
<a href="#l4.1155"></a><span id="l4.1155" class="difflineminus">-  BOOL has = TRUE;</span>
<a href="#l4.1156"></a><span id="l4.1156" class="difflineminus">-</span>
<a href="#l4.1157"></a><span id="l4.1157" class="difflineminus">-  if (pVal &amp;&amp; (PROP_TYPE( pVal-&gt;ulPropTag) == PT_BOOLEAN)) {</span>
<a href="#l4.1158"></a><span id="l4.1158" class="difflineminus">-    has = (pVal-&gt;Value.b != 0);</span>
<a href="#l4.1159"></a><span id="l4.1159" class="difflineminus">-  }</span>
<a href="#l4.1160"></a><span id="l4.1160" class="difflineminus">-  if (pVal)</span>
<a href="#l4.1161"></a><span id="l4.1161" class="difflineminus">-    CMapiApi::MAPIFreeBuffer( pVal);</span>
<a href="#l4.1162"></a><span id="l4.1162" class="difflineminus">-</span>
<a href="#l4.1163"></a><span id="l4.1163" class="difflineminus">-  if (has) {</span>
<a href="#l4.1164"></a><span id="l4.1164" class="difflineminus">-    // Get the attachment table?</span>
<a href="#l4.1165"></a><span id="l4.1165" class="difflineminus">-    HRESULT hr;</span>
<a href="#l4.1166"></a><span id="l4.1166" class="difflineminus">-    LPMAPITABLE pTable = NULL;</span>
<a href="#l4.1167"></a><span id="l4.1167" class="difflineminus">-</span>
<a href="#l4.1168"></a><span id="l4.1168" class="difflineminus">-    hr = m_lpMsg-&gt;GetAttachmentTable( 0, &amp;pTable);</span>
<a href="#l4.1169"></a><span id="l4.1169" class="difflineminus">-    if (FAILED( hr))</span>
<a href="#l4.1170"></a><span id="l4.1170" class="difflineminus">-      return( 0);</span>
<a href="#l4.1171"></a><span id="l4.1171" class="difflineminus">-    m_pAttachTable = pTable;</span>
<a href="#l4.1172"></a><span id="l4.1172" class="difflineminus">-    IterateAttachTable();</span>
<a href="#l4.1173"></a><span id="l4.1173" class="difflineminus">-  }</span>
<a href="#l4.1174"></a><span id="l4.1174" class="difflineminus">-</span>
<a href="#l4.1175"></a><span id="l4.1175" class="difflineminus">-  return m_attachNums.Length();</span>
<a href="#l4.1176"></a><span id="l4.1176" class="difflineminus">-}</span>
<a href="#l4.1177"></a><span id="l4.1177" class="difflineminus">-</span>
<a href="#l4.1178"></a><span id="l4.1178" class="difflineminus">-</span>
<a href="#l4.1179"></a><span id="l4.1179" class="difflineminus">-BOOL CMapiMessage::IterateAttachTable( void)</span>
<a href="#l4.1180"></a><span id="l4.1180" class="difflineminus">-{</span>
<a href="#l4.1181"></a><span id="l4.1181" class="difflineminus">-  LPMAPITABLE lpTable = m_pAttachTable;</span>
<a href="#l4.1182"></a><span id="l4.1182">   ULONG rowCount;</span>
<a href="#l4.1183"></a><span id="l4.1183">   HRESULT hr = lpTable-&gt;GetRowCount( 0, &amp;rowCount);</span>
<a href="#l4.1184"></a><span id="l4.1184">   if (!rowCount) {</span>
<a href="#l4.1185"></a><span id="l4.1185" class="difflineminus">-    return( TRUE);</span>
<a href="#l4.1186"></a><span id="l4.1186" class="difflineplus">+    return true;</span>
<a href="#l4.1187"></a><span id="l4.1187">   }</span>
<a href="#l4.1188"></a><span id="l4.1188"> </span>
<a href="#l4.1189"></a><span id="l4.1189">   hr = lpTable-&gt;SetColumns( (LPSPropTagArray)&amp;ptaEid, 0);</span>
<a href="#l4.1190"></a><span id="l4.1190">   if (FAILED(hr)) {</span>
<a href="#l4.1191"></a><span id="l4.1191">     MAPI_TRACE2( &quot;SetColumns for attachment table failed: 0x%lx, %d\r\n&quot;, (long)hr, (int)hr);</span>
<a href="#l4.1192"></a><span id="l4.1192" class="difflineminus">-    return( FALSE);</span>
<a href="#l4.1193"></a><span id="l4.1193" class="difflineplus">+    return false;</span>
<a href="#l4.1194"></a><span id="l4.1194">   }</span>
<a href="#l4.1195"></a><span id="l4.1195"> </span>
<a href="#l4.1196"></a><span id="l4.1196">   hr = lpTable-&gt;SeekRow( BOOKMARK_BEGINNING, 0, NULL);</span>
<a href="#l4.1197"></a><span id="l4.1197">   if (FAILED(hr)) {</span>
<a href="#l4.1198"></a><span id="l4.1198">     MAPI_TRACE2( &quot;SeekRow for attachment table failed: 0x%lx, %d\r\n&quot;, (long)hr, (int)hr);</span>
<a href="#l4.1199"></a><span id="l4.1199" class="difflineminus">-    return( FALSE);</span>
<a href="#l4.1200"></a><span id="l4.1200" class="difflineplus">+    return false;</span>
<a href="#l4.1201"></a><span id="l4.1201">   }</span>
<a href="#l4.1202"></a><span id="l4.1202"> </span>
<a href="#l4.1203"></a><span id="l4.1203">   int cNumRows = 0;</span>
<a href="#l4.1204"></a><span id="l4.1204">   LPSRowSet lpRow;</span>
<a href="#l4.1205"></a><span id="l4.1205" class="difflineminus">-  BOOL bResult = TRUE;</span>
<a href="#l4.1206"></a><span id="l4.1206" class="difflineplus">+  bool bResult = true;</span>
<a href="#l4.1207"></a><span id="l4.1207">   do {</span>
<a href="#l4.1208"></a><span id="l4.1208"> </span>
<a href="#l4.1209"></a><span id="l4.1209">     lpRow = NULL;</span>
<a href="#l4.1210"></a><span id="l4.1210">     hr = lpTable-&gt;QueryRows( 1, 0, &amp;lpRow);</span>
<a href="#l4.1211"></a><span id="l4.1211"> </span>
<a href="#l4.1212"></a><span id="l4.1212">     if(HR_FAILED(hr)) {</span>
<a href="#l4.1213"></a><span id="l4.1213">       MAPI_TRACE2( &quot;QueryRows for attachment table failed: 0x%lx, %d\n&quot;, (long)hr, (int)hr);</span>
<a href="#l4.1214"></a><span id="l4.1214" class="difflineminus">-      bResult = FALSE;</span>
<a href="#l4.1215"></a><span id="l4.1215" class="difflineplus">+      bResult = false;</span>
<a href="#l4.1216"></a><span id="l4.1216">       break;</span>
<a href="#l4.1217"></a><span id="l4.1217">     }</span>
<a href="#l4.1218"></a><span id="l4.1218"> </span>
<a href="#l4.1219"></a><span id="l4.1219">     if (lpRow) {</span>
<a href="#l4.1220"></a><span id="l4.1220">       cNumRows = lpRow-&gt;cRows;</span>
<a href="#l4.1221"></a><span id="l4.1221"> </span>
<a href="#l4.1222"></a><span id="l4.1222">       if (cNumRows) {</span>
<a href="#l4.1223"></a><span id="l4.1223">         DWORD aNum = lpRow-&gt;aRow[0].lpProps[ieidPR_ATTACH_NUM].Value.ul;</span>
<a href="#l4.1224"></a><span id="l4.1224" class="difflineminus">-        m_attachNums.AppendElement(aNum);</span>
<a href="#l4.1225"></a><span id="l4.1225" class="difflineplus">+        AddAttachment(aNum);</span>
<a href="#l4.1226"></a><span id="l4.1226">         MAPI_TRACE1( &quot;\t\t****Attachment found - #%d\r\n&quot;, (int)aNum);</span>
<a href="#l4.1227"></a><span id="l4.1227">       }</span>
<a href="#l4.1228"></a><span id="l4.1228">       CMapiApi::FreeProws( lpRow);</span>
<a href="#l4.1229"></a><span id="l4.1229">     }</span>
<a href="#l4.1230"></a><span id="l4.1230"> </span>
<a href="#l4.1231"></a><span id="l4.1231">   } while ( SUCCEEDED(hr) &amp;&amp; cNumRows &amp;&amp; lpRow);</span>
<a href="#l4.1232"></a><span id="l4.1232"> </span>
<a href="#l4.1233"></a><span id="l4.1233">   return( bResult);</span>
<a href="#l4.1234"></a><span id="l4.1234"> }</span>
<a href="#l4.1235"></a><span id="l4.1235"> </span>
<a href="#l4.1236"></a><span id="l4.1236" class="difflineminus">-void CMapiMessage::ClearTempAttachFile( void)</span>
<a href="#l4.1237"></a><span id="l4.1237" class="difflineplus">+bool CMapiMessage::GetTmpFile(/*out*/ nsILocalFile **aResult)</span>
<a href="#l4.1238"></a><span id="l4.1238"> {</span>
<a href="#l4.1239"></a><span id="l4.1239" class="difflineminus">-  if (m_ownsAttachFile &amp;&amp; !m_attachPath.IsEmpty()) {</span>
<a href="#l4.1240"></a><span id="l4.1240" class="difflineminus">-    nsCOMPtr &lt;nsILocalFile&gt; locFile = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);</span>
<a href="#l4.1241"></a><span id="l4.1241" class="difflineminus">-    if (locFile &amp;&amp; (NS_SUCCEEDED(locFile-&gt;InitWithNativePath(m_attachPath))))</span>
<a href="#l4.1242"></a><span id="l4.1242" class="difflineminus">-      locFile-&gt;Remove(PR_FALSE);</span>
<a href="#l4.1243"></a><span id="l4.1243" class="difflineminus">-  }</span>
<a href="#l4.1244"></a><span id="l4.1244" class="difflineminus">-  m_ownsAttachFile = FALSE;</span>
<a href="#l4.1245"></a><span id="l4.1245" class="difflineminus">-  m_attachPath.Truncate();</span>
<a href="#l4.1246"></a><span id="l4.1246" class="difflineminus">-}</span>
<a href="#l4.1247"></a><span id="l4.1247" class="difflineminus">-</span>
<a href="#l4.1248"></a><span id="l4.1248" class="difflineminus">-BOOL CMapiMessage::CopyBinAttachToFile( LPATTACH lpAttach)</span>
<a href="#l4.1249"></a><span id="l4.1249" class="difflineminus">-{</span>
<a href="#l4.1250"></a><span id="l4.1250" class="difflineminus">-  LPSTREAM lpStreamFile;</span>
<a href="#l4.1251"></a><span id="l4.1251" class="difflineminus">-</span>
<a href="#l4.1252"></a><span id="l4.1252" class="difflineminus">-  m_ownsAttachFile = FALSE;</span>
<a href="#l4.1253"></a><span id="l4.1253" class="difflineminus">-  m_attachPath.Truncate();</span>
<a href="#l4.1254"></a><span id="l4.1254" class="difflineminus">-</span>
<a href="#l4.1255"></a><span id="l4.1255">   nsCOMPtr&lt;nsIFile&gt; tmpFile;</span>
<a href="#l4.1256"></a><span id="l4.1256">   nsresult rv = GetSpecialDirectoryWithFileName(NS_OS_TEMP_DIR,</span>
<a href="#l4.1257"></a><span id="l4.1257">     &quot;mapiattach.tmp&quot;,</span>
<a href="#l4.1258"></a><span id="l4.1258">     getter_AddRefs(tmpFile));</span>
<a href="#l4.1259"></a><span id="l4.1259" class="difflineminus">-  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.1260"></a><span id="l4.1260" class="difflineplus">+  if (NS_FAILED(rv))</span>
<a href="#l4.1261"></a><span id="l4.1261" class="difflineplus">+    return false;</span>
<a href="#l4.1262"></a><span id="l4.1262"> </span>
<a href="#l4.1263"></a><span id="l4.1263">   rv = tmpFile-&gt;CreateUnique(nsIFile::NORMAL_FILE_TYPE, 00600);</span>
<a href="#l4.1264"></a><span id="l4.1264" class="difflineminus">-  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.1265"></a><span id="l4.1265" class="difflineplus">+  if (NS_FAILED(rv))</span>
<a href="#l4.1266"></a><span id="l4.1266" class="difflineplus">+    return false;</span>
<a href="#l4.1267"></a><span id="l4.1267" class="difflineplus">+</span>
<a href="#l4.1268"></a><span id="l4.1268" class="difflineplus">+  return NS_SUCCEEDED(CallQueryInterface(tmpFile, aResult));</span>
<a href="#l4.1269"></a><span id="l4.1269" class="difflineplus">+}</span>
<a href="#l4.1270"></a><span id="l4.1270" class="difflineplus">+</span>
<a href="#l4.1271"></a><span id="l4.1271" class="difflineplus">+bool CMapiMessage::CopyMsgAttachToFile(LPATTACH lpAttach, /*out*/ nsILocalFile **tmp_file)</span>
<a href="#l4.1272"></a><span id="l4.1272" class="difflineplus">+{</span>
<a href="#l4.1273"></a><span id="l4.1273" class="difflineplus">+  bool bResult = true;</span>
<a href="#l4.1274"></a><span id="l4.1274" class="difflineplus">+  LPMESSAGE  lpMsg;</span>
<a href="#l4.1275"></a><span id="l4.1275" class="difflineplus">+  HRESULT hr = lpAttach-&gt;OpenProperty(PR_ATTACH_DATA_OBJ, &amp;IID_IMessage, 0, 0,</span>
<a href="#l4.1276"></a><span id="l4.1276" class="difflineplus">+                                      reinterpret_cast&lt;LPUNKNOWN *&gt;(&amp;lpMsg));</span>
<a href="#l4.1277"></a><span id="l4.1277" class="difflineplus">+  NS_ENSURE_SUCCESS(hr, false);</span>
<a href="#l4.1278"></a><span id="l4.1278" class="difflineplus">+</span>
<a href="#l4.1279"></a><span id="l4.1279" class="difflineplus">+  if (!GetTmpFile(tmp_file))</span>
<a href="#l4.1280"></a><span id="l4.1280" class="difflineplus">+    return false;</span>
<a href="#l4.1281"></a><span id="l4.1281" class="difflineplus">+</span>
<a href="#l4.1282"></a><span id="l4.1282" class="difflineplus">+  nsCOMPtr&lt;nsIOutputStream&gt; destOutputStream;</span>
<a href="#l4.1283"></a><span id="l4.1283" class="difflineplus">+  nsresult rv = MsgNewBufferedFileOutputStream(getter_AddRefs(destOutputStream), *tmp_file, -1, 0600);</span>
<a href="#l4.1284"></a><span id="l4.1284" class="difflineplus">+  if (NS_SUCCEEDED(rv))</span>
<a href="#l4.1285"></a><span id="l4.1285" class="difflineplus">+    rv = nsOutlookMail::ImportMessage(lpMsg, destOutputStream, nsIMsgSend::nsMsgSaveAsDraft);</span>
<a href="#l4.1286"></a><span id="l4.1286" class="difflineplus">+</span>
<a href="#l4.1287"></a><span id="l4.1287" class="difflineplus">+  if (NS_FAILED(rv)) {</span>
<a href="#l4.1288"></a><span id="l4.1288" class="difflineplus">+    (*tmp_file)-&gt;Remove(PR_FALSE);</span>
<a href="#l4.1289"></a><span id="l4.1289" class="difflineplus">+    (*tmp_file)-&gt;Release();</span>
<a href="#l4.1290"></a><span id="l4.1290" class="difflineplus">+    tmp_file = 0;</span>
<a href="#l4.1291"></a><span id="l4.1291" class="difflineplus">+  }</span>
<a href="#l4.1292"></a><span id="l4.1292" class="difflineplus">+</span>
<a href="#l4.1293"></a><span id="l4.1293" class="difflineplus">+  return NS_SUCCEEDED(rv);</span>
<a href="#l4.1294"></a><span id="l4.1294" class="difflineplus">+}</span>
<a href="#l4.1295"></a><span id="l4.1295" class="difflineplus">+</span>
<a href="#l4.1296"></a><span id="l4.1296" class="difflineplus">+bool CMapiMessage::CopyBinAttachToFile(LPATTACH lpAttach,</span>
<a href="#l4.1297"></a><span id="l4.1297" class="difflineplus">+                                       nsILocalFile **tmp_file)</span>
<a href="#l4.1298"></a><span id="l4.1298" class="difflineplus">+{</span>
<a href="#l4.1299"></a><span id="l4.1299" class="difflineplus">+  nsCOMPtr&lt;nsIFile&gt; _tmp_file;</span>
<a href="#l4.1300"></a><span id="l4.1300" class="difflineplus">+  nsresult rv = GetSpecialDirectoryWithFileName(NS_OS_TEMP_DIR,</span>
<a href="#l4.1301"></a><span id="l4.1301" class="difflineplus">+    &quot;mapiattach.tmp&quot;,</span>
<a href="#l4.1302"></a><span id="l4.1302" class="difflineplus">+    getter_AddRefs(_tmp_file));</span>
<a href="#l4.1303"></a><span id="l4.1303" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, false);</span>
<a href="#l4.1304"></a><span id="l4.1304" class="difflineplus">+</span>
<a href="#l4.1305"></a><span id="l4.1305" class="difflineplus">+  rv = _tmp_file-&gt;CreateUnique(nsIFile::NORMAL_FILE_TYPE, 00600);</span>
<a href="#l4.1306"></a><span id="l4.1306" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, false);</span>
<a href="#l4.1307"></a><span id="l4.1307"> </span>
<a href="#l4.1308"></a><span id="l4.1308">   nsCString tmpPath;</span>
<a href="#l4.1309"></a><span id="l4.1309" class="difflineminus">-  tmpFile-&gt;GetNativePath(tmpPath);</span>
<a href="#l4.1310"></a><span id="l4.1310" class="difflineplus">+  _tmp_file-&gt;GetNativePath(tmpPath);</span>
<a href="#l4.1311"></a><span id="l4.1311" class="difflineplus">+  LPSTREAM lpStreamFile;</span>
<a href="#l4.1312"></a><span id="l4.1312">   HRESULT hr = CMapiApi::OpenStreamOnFile( gpMapiAllocateBuffer, gpMapiFreeBuffer, STGM_READWRITE | STGM_CREATE,</span>
<a href="#l4.1313"></a><span id="l4.1313" class="difflineminus">-    (char *) tmpPath.get(), NULL, &amp;lpStreamFile);</span>
<a href="#l4.1314"></a><span id="l4.1314" class="difflineplus">+    const_cast&lt;char*&gt;(tmpPath.get()), NULL, &amp;lpStreamFile);</span>
<a href="#l4.1315"></a><span id="l4.1315">   if (HR_FAILED(hr)) {</span>
<a href="#l4.1316"></a><span id="l4.1316">     MAPI_TRACE1(&quot;~~ERROR~~ OpenStreamOnFile failed - temp path: %s\r\n&quot;,</span>
<a href="#l4.1317"></a><span id="l4.1317">                 tmpPath.get());</span>
<a href="#l4.1318"></a><span id="l4.1318" class="difflineminus">-    return( FALSE);</span>
<a href="#l4.1319"></a><span id="l4.1319" class="difflineplus">+    return false;</span>
<a href="#l4.1320"></a><span id="l4.1320">   }</span>
<a href="#l4.1321"></a><span id="l4.1321" class="difflineminus">-  MAPI_TRACE1(&quot;\t\t** Attachment extracted to temp file: %s\r\n&quot;,</span>
<a href="#l4.1322"></a><span id="l4.1322" class="difflineminus">-              m_attachPath.get());</span>
<a href="#l4.1323"></a><span id="l4.1323"> </span>
<a href="#l4.1324"></a><span id="l4.1324" class="difflineminus">-  BOOL bResult = TRUE;</span>
<a href="#l4.1325"></a><span id="l4.1325" class="difflineplus">+  bool bResult = true;</span>
<a href="#l4.1326"></a><span id="l4.1326">   LPSTREAM lpAttachStream;</span>
<a href="#l4.1327"></a><span id="l4.1327">   hr = lpAttach-&gt;OpenProperty( PR_ATTACH_DATA_BIN, &amp;IID_IStream, 0, 0, (LPUNKNOWN *)&amp;lpAttachStream);</span>
<a href="#l4.1328"></a><span id="l4.1328"> </span>
<a href="#l4.1329"></a><span id="l4.1329">   if (HR_FAILED( hr)) {</span>
<a href="#l4.1330"></a><span id="l4.1330">     MAPI_TRACE0( &quot;~~ERROR~~ OpenProperty failed for PR_ATTACH_DATA_BIN.\r\n&quot;);</span>
<a href="#l4.1331"></a><span id="l4.1331">     lpAttachStream = NULL;</span>
<a href="#l4.1332"></a><span id="l4.1332" class="difflineminus">-    bResult = FALSE;</span>
<a href="#l4.1333"></a><span id="l4.1333" class="difflineplus">+    bResult = false;</span>
<a href="#l4.1334"></a><span id="l4.1334">   }</span>
<a href="#l4.1335"></a><span id="l4.1335">   else {</span>
<a href="#l4.1336"></a><span id="l4.1336">     STATSTG st;</span>
<a href="#l4.1337"></a><span id="l4.1337">     hr = lpAttachStream-&gt;Stat( &amp;st, STATFLAG_NONAME);</span>
<a href="#l4.1338"></a><span id="l4.1338">     if (HR_FAILED( hr)) {</span>
<a href="#l4.1339"></a><span id="l4.1339">       MAPI_TRACE0( &quot;~~ERROR~~ Stat failed for attachment stream\r\n&quot;);</span>
<a href="#l4.1340"></a><span id="l4.1340" class="difflineminus">-      bResult = FALSE;</span>
<a href="#l4.1341"></a><span id="l4.1341" class="difflineplus">+      bResult = false;</span>
<a href="#l4.1342"></a><span id="l4.1342">     }</span>
<a href="#l4.1343"></a><span id="l4.1343">     else {</span>
<a href="#l4.1344"></a><span id="l4.1344">       hr = lpAttachStream-&gt;CopyTo( lpStreamFile, st.cbSize, NULL, NULL);</span>
<a href="#l4.1345"></a><span id="l4.1345">       if (HR_FAILED( hr)) {</span>
<a href="#l4.1346"></a><span id="l4.1346">         MAPI_TRACE0( &quot;~~ERROR~~ Attach Stream CopyTo temp file failed.\r\n&quot;);</span>
<a href="#l4.1347"></a><span id="l4.1347" class="difflineminus">-        bResult = FALSE;</span>
<a href="#l4.1348"></a><span id="l4.1348" class="difflineplus">+        bResult = false;</span>
<a href="#l4.1349"></a><span id="l4.1349">       }</span>
<a href="#l4.1350"></a><span id="l4.1350">     }</span>
<a href="#l4.1351"></a><span id="l4.1351">   }</span>
<a href="#l4.1352"></a><span id="l4.1352"> </span>
<a href="#l4.1353"></a><span id="l4.1353" class="difflineminus">-  m_attachPath = tmpPath;</span>
<a href="#l4.1354"></a><span id="l4.1354">   if (lpAttachStream)</span>
<a href="#l4.1355"></a><span id="l4.1355">     lpAttachStream-&gt;Release();</span>
<a href="#l4.1356"></a><span id="l4.1356">   lpStreamFile-&gt;Release();</span>
<a href="#l4.1357"></a><span id="l4.1357">   if (!bResult)</span>
<a href="#l4.1358"></a><span id="l4.1358" class="difflineminus">-    tmpFile-&gt;Remove(PR_FALSE);</span>
<a href="#l4.1359"></a><span id="l4.1359" class="difflineplus">+    _tmp_file-&gt;Remove(PR_FALSE);</span>
<a href="#l4.1360"></a><span id="l4.1360">   else</span>
<a href="#l4.1361"></a><span id="l4.1361" class="difflineminus">-    m_ownsAttachFile = TRUE;</span>
<a href="#l4.1362"></a><span id="l4.1362" class="difflineplus">+    CallQueryInterface(_tmp_file, tmp_file);</span>
<a href="#l4.1363"></a><span id="l4.1363" class="difflineplus">+</span>
<a href="#l4.1364"></a><span id="l4.1364" class="difflineplus">+  return bResult;</span>
<a href="#l4.1365"></a><span id="l4.1365" class="difflineplus">+}</span>
<a href="#l4.1366"></a><span id="l4.1366" class="difflineplus">+</span>
<a href="#l4.1367"></a><span id="l4.1367" class="difflineplus">+bool CMapiMessage::GetURL(nsIFile *aFile, nsIURI **url)</span>
<a href="#l4.1368"></a><span id="l4.1368" class="difflineplus">+{</span>
<a href="#l4.1369"></a><span id="l4.1369" class="difflineplus">+  if (!m_pIOService)</span>
<a href="#l4.1370"></a><span id="l4.1370" class="difflineplus">+    return false;</span>
<a href="#l4.1371"></a><span id="l4.1371" class="difflineplus">+</span>
<a href="#l4.1372"></a><span id="l4.1372" class="difflineplus">+  nsresult rv = m_pIOService-&gt;NewFileURI(aFile, url);</span>
<a href="#l4.1373"></a><span id="l4.1373" class="difflineplus">+  return NS_SUCCEEDED(rv);</span>
<a href="#l4.1374"></a><span id="l4.1374" class="difflineplus">+}</span>
<a href="#l4.1375"></a><span id="l4.1375" class="difflineplus">+</span>
<a href="#l4.1376"></a><span id="l4.1376" class="difflineplus">+bool CMapiMessage::AddAttachment(DWORD aNum)</span>
<a href="#l4.1377"></a><span id="l4.1377" class="difflineplus">+{</span>
<a href="#l4.1378"></a><span id="l4.1378" class="difflineplus">+  LPATTACH lpAttach = NULL;</span>
<a href="#l4.1379"></a><span id="l4.1379" class="difflineplus">+  HRESULT hr = m_lpMsg-&gt;OpenAttach(aNum, NULL, 0, &amp;lpAttach);</span>
<a href="#l4.1380"></a><span id="l4.1380" class="difflineplus">+  if (HR_FAILED(hr)) {</span>
<a href="#l4.1381"></a><span id="l4.1381" class="difflineplus">+    MAPI_TRACE2(&quot;\t\t****Attachment error, unable to open attachment: %d, 0x%lx\r\n&quot;, idx, hr);</span>
<a href="#l4.1382"></a><span id="l4.1382" class="difflineplus">+    return false;</span>
<a href="#l4.1383"></a><span id="l4.1383" class="difflineplus">+  }</span>
<a href="#l4.1384"></a><span id="l4.1384" class="difflineplus">+</span>
<a href="#l4.1385"></a><span id="l4.1385" class="difflineplus">+  bool bResult = false;</span>
<a href="#l4.1386"></a><span id="l4.1386" class="difflineplus">+  attach_data *data = new attach_data;</span>
<a href="#l4.1387"></a><span id="l4.1387" class="difflineplus">+  ULONG aMethod;</span>
<a href="#l4.1388"></a><span id="l4.1388" class="difflineplus">+  if (data) {</span>
<a href="#l4.1389"></a><span id="l4.1389" class="difflineplus">+    bResult = true;</span>
<a href="#l4.1390"></a><span id="l4.1390" class="difflineplus">+</span>
<a href="#l4.1391"></a><span id="l4.1391" class="difflineplus">+    // 1. Get the file that contains the attachment data</span>
<a href="#l4.1392"></a><span id="l4.1392" class="difflineplus">+    LPSPropValue pVal = CMapiApi::GetMapiProperty(lpAttach, PR_ATTACH_METHOD);</span>
<a href="#l4.1393"></a><span id="l4.1393" class="difflineplus">+    if (pVal) {</span>
<a href="#l4.1394"></a><span id="l4.1394" class="difflineplus">+      aMethod = CMapiApi::GetLongFromProp( pVal);</span>
<a href="#l4.1395"></a><span id="l4.1395" class="difflineplus">+      switch (aMethod) {</span>
<a href="#l4.1396"></a><span id="l4.1396" class="difflineplus">+      case ATTACH_BY_VALUE:</span>
<a href="#l4.1397"></a><span id="l4.1397" class="difflineplus">+        MAPI_TRACE1( &quot;\t\t** Attachment #%d by value.\r\n&quot;, aNum);</span>
<a href="#l4.1398"></a><span id="l4.1398" class="difflineplus">+        bResult = CopyBinAttachToFile(lpAttach, getter_AddRefs(data-&gt;tmp_file));</span>
<a href="#l4.1399"></a><span id="l4.1399" class="difflineplus">+        data-&gt;delete_file = true;</span>
<a href="#l4.1400"></a><span id="l4.1400" class="difflineplus">+        break;</span>
<a href="#l4.1401"></a><span id="l4.1401" class="difflineplus">+      case ATTACH_BY_REFERENCE:</span>
<a href="#l4.1402"></a><span id="l4.1402" class="difflineplus">+      case ATTACH_BY_REF_RESOLVE:</span>
<a href="#l4.1403"></a><span id="l4.1403" class="difflineplus">+      case ATTACH_BY_REF_ONLY:</span>
<a href="#l4.1404"></a><span id="l4.1404" class="difflineplus">+        pVal = CMapiApi::GetMapiProperty(lpAttach, PR_ATTACH_PATHNAME_W);</span>
<a href="#l4.1405"></a><span id="l4.1405" class="difflineplus">+        if (pVal) {</span>
<a href="#l4.1406"></a><span id="l4.1406" class="difflineplus">+          nsCString path;</span>
<a href="#l4.1407"></a><span id="l4.1407" class="difflineplus">+          CMapiApi::GetStringFromProp(pVal, path);</span>
<a href="#l4.1408"></a><span id="l4.1408" class="difflineplus">+          nsresult rv;</span>
<a href="#l4.1409"></a><span id="l4.1409" class="difflineplus">+          data-&gt;tmp_file = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID, &amp;rv);</span>
<a href="#l4.1410"></a><span id="l4.1410" class="difflineplus">+          if (NS_FAILED(rv) || !data-&gt;tmp_file) {</span>
<a href="#l4.1411"></a><span id="l4.1411" class="difflineplus">+            MAPI_TRACE0(&quot;*** Error creating file spec for attachment\n&quot;);</span>
<a href="#l4.1412"></a><span id="l4.1412" class="difflineplus">+            bResult = false;</span>
<a href="#l4.1413"></a><span id="l4.1413" class="difflineplus">+          }</span>
<a href="#l4.1414"></a><span id="l4.1414" class="difflineplus">+          else data-&gt;tmp_file-&gt;InitWithNativePath(path);</span>
<a href="#l4.1415"></a><span id="l4.1415" class="difflineplus">+        }</span>
<a href="#l4.1416"></a><span id="l4.1416" class="difflineplus">+        MAPI_TRACE2(&quot;\t\t** Attachment #%d by ref: %s\r\n&quot;,</span>
<a href="#l4.1417"></a><span id="l4.1417" class="difflineplus">+          aNum, m_attachPath.get());</span>
<a href="#l4.1418"></a><span id="l4.1418" class="difflineplus">+        break;</span>
<a href="#l4.1419"></a><span id="l4.1419" class="difflineplus">+      case ATTACH_EMBEDDED_MSG:</span>
<a href="#l4.1420"></a><span id="l4.1420" class="difflineplus">+        MAPI_TRACE1(&quot;\t\t** Attachment #%d by Embedded Message??\r\n&quot;, aNum);</span>
<a href="#l4.1421"></a><span id="l4.1421" class="difflineplus">+        // Convert the embedded IMessage from PR_ATTACH_DATA_OBJ to rfc822 attachment</span>
<a href="#l4.1422"></a><span id="l4.1422" class="difflineplus">+        // (see http://msdn.microsoft.com/en-us/library/cc842329.aspx)</span>
<a href="#l4.1423"></a><span id="l4.1423" class="difflineplus">+        // This is a recursive call.</span>
<a href="#l4.1424"></a><span id="l4.1424" class="difflineplus">+        bResult = CopyMsgAttachToFile(lpAttach, getter_AddRefs(data-&gt;tmp_file));</span>
<a href="#l4.1425"></a><span id="l4.1425" class="difflineplus">+        data-&gt;delete_file = true;</span>
<a href="#l4.1426"></a><span id="l4.1426" class="difflineplus">+        break;</span>
<a href="#l4.1427"></a><span id="l4.1427" class="difflineplus">+      case ATTACH_OLE:</span>
<a href="#l4.1428"></a><span id="l4.1428" class="difflineplus">+        MAPI_TRACE1(&quot;\t\t** Attachment #%d by OLE - yuck!!!\r\n&quot;, aNum);</span>
<a href="#l4.1429"></a><span id="l4.1429" class="difflineplus">+        break;</span>
<a href="#l4.1430"></a><span id="l4.1430" class="difflineplus">+      default:</span>
<a href="#l4.1431"></a><span id="l4.1431" class="difflineplus">+        MAPI_TRACE2(&quot;\t\t** Attachment #%d unknown attachment method - 0x%lx\r\n&quot;, aNum, aMethod);</span>
<a href="#l4.1432"></a><span id="l4.1432" class="difflineplus">+        bResult = false;</span>
<a href="#l4.1433"></a><span id="l4.1433" class="difflineplus">+      }</span>
<a href="#l4.1434"></a><span id="l4.1434" class="difflineplus">+    }</span>
<a href="#l4.1435"></a><span id="l4.1435" class="difflineplus">+    else</span>
<a href="#l4.1436"></a><span id="l4.1436" class="difflineplus">+      bResult = false;</span>
<a href="#l4.1437"></a><span id="l4.1437" class="difflineplus">+</span>
<a href="#l4.1438"></a><span id="l4.1438" class="difflineplus">+    if (bResult)</span>
<a href="#l4.1439"></a><span id="l4.1439" class="difflineplus">+      bResult = data-&gt;tmp_file;</span>
<a href="#l4.1440"></a><span id="l4.1440" class="difflineplus">+</span>
<a href="#l4.1441"></a><span id="l4.1441" class="difflineplus">+    if (bResult) {</span>
<a href="#l4.1442"></a><span id="l4.1442" class="difflineplus">+      PRBool isFile = PR_FALSE;</span>
<a href="#l4.1443"></a><span id="l4.1443" class="difflineplus">+      PRBool exists = PR_FALSE;</span>
<a href="#l4.1444"></a><span id="l4.1444" class="difflineplus">+      data-&gt;tmp_file-&gt;Exists(&amp;exists);</span>
<a href="#l4.1445"></a><span id="l4.1445" class="difflineplus">+      data-&gt;tmp_file-&gt;IsFile(&amp;isFile);</span>
<a href="#l4.1446"></a><span id="l4.1446" class="difflineplus">+</span>
<a href="#l4.1447"></a><span id="l4.1447" class="difflineplus">+      if (!exists || !isFile) {</span>
<a href="#l4.1448"></a><span id="l4.1448" class="difflineplus">+        bResult = false;</span>
<a href="#l4.1449"></a><span id="l4.1449" class="difflineplus">+        MAPI_TRACE0(&quot;Attachment file does not exist\n&quot;);</span>
<a href="#l4.1450"></a><span id="l4.1450" class="difflineplus">+      }</span>
<a href="#l4.1451"></a><span id="l4.1451" class="difflineplus">+    }</span>
<a href="#l4.1452"></a><span id="l4.1452" class="difflineplus">+</span>
<a href="#l4.1453"></a><span id="l4.1453" class="difflineplus">+    if (bResult)</span>
<a href="#l4.1454"></a><span id="l4.1454" class="difflineplus">+      bResult = GetURL(data-&gt;tmp_file, getter_AddRefs(data-&gt;orig_url));</span>
<a href="#l4.1455"></a><span id="l4.1455" class="difflineplus">+</span>
<a href="#l4.1456"></a><span id="l4.1456" class="difflineplus">+    if (bResult) {</span>
<a href="#l4.1457"></a><span id="l4.1457" class="difflineplus">+      // Now we have the file; proceed to the other properties</span>
<a href="#l4.1458"></a><span id="l4.1458"> </span>
<a href="#l4.1459"></a><span id="l4.1459" class="difflineplus">+      data-&gt;encoding = NS_strdup(ENCODING_BINARY);</span>
<a href="#l4.1460"></a><span id="l4.1460" class="difflineplus">+</span>
<a href="#l4.1461"></a><span id="l4.1461" class="difflineplus">+      nsString fname, fext;</span>
<a href="#l4.1462"></a><span id="l4.1462" class="difflineplus">+      pVal = CMapiApi::GetMapiProperty(lpAttach, PR_ATTACH_LONG_FILENAME_W);</span>
<a href="#l4.1463"></a><span id="l4.1463" class="difflineplus">+      if (!pVal)</span>
<a href="#l4.1464"></a><span id="l4.1464" class="difflineplus">+        pVal = CMapiApi::GetMapiProperty(lpAttach, PR_ATTACH_FILENAME_W);</span>
<a href="#l4.1465"></a><span id="l4.1465" class="difflineplus">+      CMapiApi::GetStringFromProp(pVal, fname);</span>
<a href="#l4.1466"></a><span id="l4.1466" class="difflineplus">+      pVal = CMapiApi::GetMapiProperty(lpAttach, PR_ATTACH_EXTENSION_W);</span>
<a href="#l4.1467"></a><span id="l4.1467" class="difflineplus">+      CMapiApi::GetStringFromProp(pVal, fext);</span>
<a href="#l4.1468"></a><span id="l4.1468" class="difflineplus">+      MAPI_TRACE2(&quot;\t\t\t--- File name: %s, extension: %s\r\n&quot;,</span>
<a href="#l4.1469"></a><span id="l4.1469" class="difflineplus">+        fname.get(), fext.get());</span>
<a href="#l4.1470"></a><span id="l4.1470" class="difflineplus">+</span>
<a href="#l4.1471"></a><span id="l4.1471" class="difflineplus">+      if (fext.IsEmpty()) {</span>
<a href="#l4.1472"></a><span id="l4.1472" class="difflineplus">+        int idx = fname.RFindChar(L'.');</span>
<a href="#l4.1473"></a><span id="l4.1473" class="difflineplus">+        if (idx != -1)</span>
<a href="#l4.1474"></a><span id="l4.1474" class="difflineplus">+          fname.Right(fext, fname.Length() - idx);</span>
<a href="#l4.1475"></a><span id="l4.1475" class="difflineplus">+      }</span>
<a href="#l4.1476"></a><span id="l4.1476" class="difflineplus">+      else if (fname.RFindChar(L'.') == -1) {</span>
<a href="#l4.1477"></a><span id="l4.1477" class="difflineplus">+        fname += L&quot;.&quot;;</span>
<a href="#l4.1478"></a><span id="l4.1478" class="difflineplus">+        fname += fext;</span>
<a href="#l4.1479"></a><span id="l4.1479" class="difflineplus">+      }</span>
<a href="#l4.1480"></a><span id="l4.1480" class="difflineplus">+      if (fname.IsEmpty()) {</span>
<a href="#l4.1481"></a><span id="l4.1481" class="difflineplus">+        // If no description use &quot;Attachment i&quot; format.</span>
<a href="#l4.1482"></a><span id="l4.1482" class="difflineplus">+        fname = L&quot;Attachment &quot;;</span>
<a href="#l4.1483"></a><span id="l4.1483" class="difflineplus">+        fname.AppendInt(static_cast&lt;PRUint32&gt;(aNum));</span>
<a href="#l4.1484"></a><span id="l4.1484" class="difflineplus">+      }</span>
<a href="#l4.1485"></a><span id="l4.1485" class="difflineplus">+      data-&gt;real_name = ToNewUTF8String(fname);</span>
<a href="#l4.1486"></a><span id="l4.1486" class="difflineplus">+</span>
<a href="#l4.1487"></a><span id="l4.1487" class="difflineplus">+      nsCString tmp;</span>
<a href="#l4.1488"></a><span id="l4.1488" class="difflineplus">+       // We have converted it to the rfc822 document</span>
<a href="#l4.1489"></a><span id="l4.1489" class="difflineplus">+      if (aMethod == ATTACH_EMBEDDED_MSG) {</span>
<a href="#l4.1490"></a><span id="l4.1490" class="difflineplus">+        data-&gt;type = NS_strdup(MESSAGE_RFC822);</span>
<a href="#l4.1491"></a><span id="l4.1491" class="difflineplus">+      } else {</span>
<a href="#l4.1492"></a><span id="l4.1492" class="difflineplus">+        pVal = CMapiApi::GetMapiProperty(lpAttach, PR_ATTACH_MIME_TAG_A);</span>
<a href="#l4.1493"></a><span id="l4.1493" class="difflineplus">+        CMapiApi::GetStringFromProp(pVal, tmp);</span>
<a href="#l4.1494"></a><span id="l4.1494" class="difflineplus">+        MAPI_TRACE1(&quot;\t\t\t--- Mime type: %s\r\n&quot;, tmp.get());</span>
<a href="#l4.1495"></a><span id="l4.1495" class="difflineplus">+        if (tmp.IsEmpty()) {</span>
<a href="#l4.1496"></a><span id="l4.1496" class="difflineplus">+          PRUint8 *pType = NULL;</span>
<a href="#l4.1497"></a><span id="l4.1497" class="difflineplus">+          if (!fext.IsEmpty()) {</span>
<a href="#l4.1498"></a><span id="l4.1498" class="difflineplus">+            pType = CMimeTypes::GetMimeType(fext);</span>
<a href="#l4.1499"></a><span id="l4.1499" class="difflineplus">+          }</span>
<a href="#l4.1500"></a><span id="l4.1500" class="difflineplus">+          if (pType)</span>
<a href="#l4.1501"></a><span id="l4.1501" class="difflineplus">+            data-&gt;type = NS_strdup((PC_S8)pType);</span>
<a href="#l4.1502"></a><span id="l4.1502" class="difflineplus">+          else</span>
<a href="#l4.1503"></a><span id="l4.1503" class="difflineplus">+            data-&gt;type = NS_strdup(APPLICATION_OCTET_STREAM);</span>
<a href="#l4.1504"></a><span id="l4.1504" class="difflineplus">+        }</span>
<a href="#l4.1505"></a><span id="l4.1505" class="difflineplus">+        else</span>
<a href="#l4.1506"></a><span id="l4.1506" class="difflineplus">+          data-&gt;type = ToNewCString(tmp);</span>
<a href="#l4.1507"></a><span id="l4.1507" class="difflineplus">+      }</span>
<a href="#l4.1508"></a><span id="l4.1508" class="difflineplus">+</span>
<a href="#l4.1509"></a><span id="l4.1509" class="difflineplus">+      pVal = CMapiApi::GetMapiProperty(lpAttach, PR_ATTACH_CONTENT_ID_A);</span>
<a href="#l4.1510"></a><span id="l4.1510" class="difflineplus">+      CMapiApi::GetStringFromProp(pVal, tmp);</span>
<a href="#l4.1511"></a><span id="l4.1511" class="difflineplus">+      if (!tmp.IsEmpty())</span>
<a href="#l4.1512"></a><span id="l4.1512" class="difflineplus">+        data-&gt;cid = ToNewCString(tmp);</span>
<a href="#l4.1513"></a><span id="l4.1513" class="difflineplus">+    }</span>
<a href="#l4.1514"></a><span id="l4.1514" class="difflineplus">+    if (bResult) {</span>
<a href="#l4.1515"></a><span id="l4.1515" class="difflineplus">+      // Now we need to decide if this attachment is embedded or not.</span>
<a href="#l4.1516"></a><span id="l4.1516" class="difflineplus">+      // At first, I tried to simply check for the presence of the Content-Id.</span>
<a href="#l4.1517"></a><span id="l4.1517" class="difflineplus">+      // But it turned out that this method is unreliable, since there exist cases</span>
<a href="#l4.1518"></a><span id="l4.1518" class="difflineplus">+      // when an attachment has a Content-Id while isn't embedded (even in a message</span>
<a href="#l4.1519"></a><span id="l4.1519" class="difflineplus">+      // with a plain-text body!). So next I tried to look for &lt;img&gt; tags that contain</span>
<a href="#l4.1520"></a><span id="l4.1520" class="difflineplus">+      // the found Content-Id. But this is unreliable, too, because there exist cases</span>
<a href="#l4.1521"></a><span id="l4.1521" class="difflineplus">+      // where other places of HTML reference the embedded messages (e.g. it may be</span>
<a href="#l4.1522"></a><span id="l4.1522" class="difflineplus">+      // a background of a table cell, or some CSS; further, it is possible that the</span>
<a href="#l4.1523"></a><span id="l4.1523" class="difflineplus">+      // reference to an embedded object is not in the main body, but in another</span>
<a href="#l4.1524"></a><span id="l4.1524" class="difflineplus">+      // embedded object - like body references a CSS attachment that in turn references</span>
<a href="#l4.1525"></a><span id="l4.1525" class="difflineplus">+      // a picture as a background of its element). From the other hand, it's unreliable</span>
<a href="#l4.1526"></a><span id="l4.1526" class="difflineplus">+      // to relax the search criteria to any occurence of the Content-Id string in the body -</span>
<a href="#l4.1527"></a><span id="l4.1527" class="difflineplus">+      // partly because the string may be simply in a text or other non-referencing part,</span>
<a href="#l4.1528"></a><span id="l4.1528" class="difflineplus">+      // partly because of the abovementioned possibility that the reference is outside</span>
<a href="#l4.1529"></a><span id="l4.1529" class="difflineplus">+      // the body at all.</span>
<a href="#l4.1530"></a><span id="l4.1530" class="difflineplus">+      // There exist the PR_ATTACH_FLAGS property of the attachment. The MS documentation</span>
<a href="#l4.1531"></a><span id="l4.1531" class="difflineplus">+      // tells about two possible flags in it: ATT_INVISIBLE_IN_HTML and ATT_INVISIBLE_IN_RTF.</span>
<a href="#l4.1532"></a><span id="l4.1532" class="difflineplus">+      // There is at least one more undocumented flag: ATT_MHTML_REF. Some sources in Internet</span>
<a href="#l4.1533"></a><span id="l4.1533" class="difflineplus">+      // suggest simply check for the latter flag to distinguish between the embedded</span>
<a href="#l4.1534"></a><span id="l4.1534" class="difflineplus">+      // and ordinary attachments. But my observations indicate that even if the flags</span>
<a href="#l4.1535"></a><span id="l4.1535" class="difflineplus">+      // don't include ATT_MHTML_REF, the attachment is still may be embedded.</span>
<a href="#l4.1536"></a><span id="l4.1536" class="difflineplus">+      // However, my observations always show that the message is embedded if the flags</span>
<a href="#l4.1537"></a><span id="l4.1537" class="difflineplus">+      // is not 0.</span>
<a href="#l4.1538"></a><span id="l4.1538" class="difflineplus">+      // So now I will simply test for the non-zero flags to decide whether the attachment</span>
<a href="#l4.1539"></a><span id="l4.1539" class="difflineplus">+      // is embedded or not. Possible advantage is reliability (I hope).</span>
<a href="#l4.1540"></a><span id="l4.1540" class="difflineplus">+      // Another advantage is that it's much faster than search the body for Content-Id.</span>
<a href="#l4.1541"></a><span id="l4.1541" class="difflineplus">+</span>
<a href="#l4.1542"></a><span id="l4.1542" class="difflineplus">+      DWORD flags = 0;</span>
<a href="#l4.1543"></a><span id="l4.1543" class="difflineplus">+</span>
<a href="#l4.1544"></a><span id="l4.1544" class="difflineplus">+      pVal = CMapiApi::GetMapiProperty(lpAttach, PR_ATTACH_FLAGS);</span>
<a href="#l4.1545"></a><span id="l4.1545" class="difflineplus">+      if (pVal)</span>
<a href="#l4.1546"></a><span id="l4.1546" class="difflineplus">+        flags = CMapiApi::GetLongFromProp(pVal);</span>
<a href="#l4.1547"></a><span id="l4.1547" class="difflineplus">+      if (m_bodyIsHtml &amp;&amp; data-&gt;cid &amp;&amp; (flags != 0)) // this is the embedded attachment</span>
<a href="#l4.1548"></a><span id="l4.1548" class="difflineplus">+        m_embattachments.push_back(data);</span>
<a href="#l4.1549"></a><span id="l4.1549" class="difflineplus">+      else // this is ordinary attachment</span>
<a href="#l4.1550"></a><span id="l4.1550" class="difflineplus">+        m_stdattachments.push_back(data);</span>
<a href="#l4.1551"></a><span id="l4.1551" class="difflineplus">+    }</span>
<a href="#l4.1552"></a><span id="l4.1552" class="difflineplus">+    else {</span>
<a href="#l4.1553"></a><span id="l4.1553" class="difflineplus">+      delete data;</span>
<a href="#l4.1554"></a><span id="l4.1554" class="difflineplus">+    }</span>
<a href="#l4.1555"></a><span id="l4.1555" class="difflineplus">+  }</span>
<a href="#l4.1556"></a><span id="l4.1556" class="difflineplus">+</span>
<a href="#l4.1557"></a><span id="l4.1557" class="difflineplus">+  lpAttach-&gt;Release();</span>
<a href="#l4.1558"></a><span id="l4.1558">   return( bResult);</span>
<a href="#l4.1559"></a><span id="l4.1559"> }</span>
<a href="#l4.1560"></a><span id="l4.1560"> </span>
<a href="#l4.1561"></a><span id="l4.1561" class="difflineminus">-BOOL CMapiMessage::GetAttachmentInfo( int idx)</span>
<a href="#l4.1562"></a><span id="l4.1562" class="difflineplus">+void CMapiMessage::ClearAttachment(attach_data* data)</span>
<a href="#l4.1563"></a><span id="l4.1563"> {</span>
<a href="#l4.1564"></a><span id="l4.1564" class="difflineminus">-  ClearTempAttachFile();</span>
<a href="#l4.1565"></a><span id="l4.1565" class="difflineplus">+  if (data-&gt;delete_file &amp;&amp; data-&gt;tmp_file)</span>
<a href="#l4.1566"></a><span id="l4.1566" class="difflineplus">+    data-&gt;tmp_file-&gt;Remove(PR_FALSE);</span>
<a href="#l4.1567"></a><span id="l4.1567" class="difflineplus">+</span>
<a href="#l4.1568"></a><span id="l4.1568" class="difflineplus">+  if (data-&gt;type)</span>
<a href="#l4.1569"></a><span id="l4.1569" class="difflineplus">+    NS_Free(data-&gt;type);</span>
<a href="#l4.1570"></a><span id="l4.1570" class="difflineplus">+  if (data-&gt;encoding)</span>
<a href="#l4.1571"></a><span id="l4.1571" class="difflineplus">+    NS_Free(data-&gt;encoding);</span>
<a href="#l4.1572"></a><span id="l4.1572" class="difflineplus">+  if (data-&gt;real_name)</span>
<a href="#l4.1573"></a><span id="l4.1573" class="difflineplus">+    NS_Free(data-&gt;real_name);</span>
<a href="#l4.1574"></a><span id="l4.1574" class="difflineplus">+  if (data-&gt;cid)</span>
<a href="#l4.1575"></a><span id="l4.1575" class="difflineplus">+    NS_Free(data-&gt;cid);</span>
<a href="#l4.1576"></a><span id="l4.1576" class="difflineplus">+</span>
<a href="#l4.1577"></a><span id="l4.1577" class="difflineplus">+  delete data;</span>
<a href="#l4.1578"></a><span id="l4.1578" class="difflineplus">+}</span>
<a href="#l4.1579"></a><span id="l4.1579"> </span>
<a href="#l4.1580"></a><span id="l4.1580" class="difflineminus">-  BOOL bResult = TRUE;</span>
<a href="#l4.1581"></a><span id="l4.1581" class="difflineminus">-  if ((idx &lt; 0) || (idx &gt;= (int)m_attachNums.Length())) {</span>
<a href="#l4.1582"></a><span id="l4.1582" class="difflineminus">-    return( FALSE);</span>
<a href="#l4.1583"></a><span id="l4.1583" class="difflineplus">+void CMapiMessage::ClearAttachments()</span>
<a href="#l4.1584"></a><span id="l4.1584" class="difflineplus">+{</span>
<a href="#l4.1585"></a><span id="l4.1585" class="difflineplus">+  std::for_each(m_stdattachments.begin(), m_stdattachments.end(), ClearAttachment);</span>
<a href="#l4.1586"></a><span id="l4.1586" class="difflineplus">+  m_stdattachments.clear();</span>
<a href="#l4.1587"></a><span id="l4.1587" class="difflineplus">+  std::for_each(m_embattachments.begin(), m_embattachments.end(), ClearAttachment);</span>
<a href="#l4.1588"></a><span id="l4.1588" class="difflineplus">+  m_embattachments.clear();</span>
<a href="#l4.1589"></a><span id="l4.1589" class="difflineplus">+}</span>
<a href="#l4.1590"></a><span id="l4.1590" class="difflineplus">+</span>
<a href="#l4.1591"></a><span id="l4.1591" class="difflineplus">+// This method must be called AFTER the retrieval of the body,</span>
<a href="#l4.1592"></a><span id="l4.1592" class="difflineplus">+// since the decision if an attachment is embedded or not is made</span>
<a href="#l4.1593"></a><span id="l4.1593" class="difflineplus">+// based on the body type and contents</span>
<a href="#l4.1594"></a><span id="l4.1594" class="difflineplus">+void CMapiMessage::ProcessAttachments()</span>
<a href="#l4.1595"></a><span id="l4.1595" class="difflineplus">+{</span>
<a href="#l4.1596"></a><span id="l4.1596" class="difflineplus">+  LPSPropValue pVal = CMapiApi::GetMapiProperty(m_lpMsg, PR_HASATTACH);</span>
<a href="#l4.1597"></a><span id="l4.1597" class="difflineplus">+  bool hasAttach = true;</span>
<a href="#l4.1598"></a><span id="l4.1598" class="difflineplus">+</span>
<a href="#l4.1599"></a><span id="l4.1599" class="difflineplus">+  if (pVal) {</span>
<a href="#l4.1600"></a><span id="l4.1600" class="difflineplus">+    if (PROP_TYPE( pVal-&gt;ulPropTag) == PT_BOOLEAN)</span>
<a href="#l4.1601"></a><span id="l4.1601" class="difflineplus">+      hasAttach = (pVal-&gt;Value.b != 0);</span>
<a href="#l4.1602"></a><span id="l4.1602" class="difflineplus">+    CMapiApi::MAPIFreeBuffer( pVal);</span>
<a href="#l4.1603"></a><span id="l4.1603">   }</span>
<a href="#l4.1604"></a><span id="l4.1604"> </span>
<a href="#l4.1605"></a><span id="l4.1605" class="difflineminus">-  DWORD aNum = m_attachNums[idx];</span>
<a href="#l4.1606"></a><span id="l4.1606" class="difflineminus">-  LPATTACH lpAttach = NULL;</span>
<a href="#l4.1607"></a><span id="l4.1607" class="difflineminus">-  HRESULT hr = m_lpMsg-&gt;OpenAttach( aNum, NULL, 0, &amp;lpAttach);</span>
<a href="#l4.1608"></a><span id="l4.1608" class="difflineminus">-  if (HR_FAILED( hr)) {</span>
<a href="#l4.1609"></a><span id="l4.1609" class="difflineminus">-    MAPI_TRACE2( &quot;\t\t****Attachment error, unable to open attachment: %d, 0x%lx\r\n&quot;, idx, hr);</span>
<a href="#l4.1610"></a><span id="l4.1610" class="difflineminus">-    return( FALSE);</span>
<a href="#l4.1611"></a><span id="l4.1611" class="difflineplus">+  if (!hasAttach)</span>
<a href="#l4.1612"></a><span id="l4.1612" class="difflineplus">+    return;</span>
<a href="#l4.1613"></a><span id="l4.1613" class="difflineplus">+</span>
<a href="#l4.1614"></a><span id="l4.1614" class="difflineplus">+  // Get the attachment table?</span>
<a href="#l4.1615"></a><span id="l4.1615" class="difflineplus">+  LPMAPITABLE pTable = NULL;</span>
<a href="#l4.1616"></a><span id="l4.1616" class="difflineplus">+  HRESULT hr = m_lpMsg-&gt;GetAttachmentTable( 0, &amp;pTable);</span>
<a href="#l4.1617"></a><span id="l4.1617" class="difflineplus">+  if (FAILED( hr) || !pTable)</span>
<a href="#l4.1618"></a><span id="l4.1618" class="difflineplus">+    return;</span>
<a href="#l4.1619"></a><span id="l4.1619" class="difflineplus">+  IterateAttachTable(pTable);</span>
<a href="#l4.1620"></a><span id="l4.1620" class="difflineplus">+  pTable-&gt;Release();</span>
<a href="#l4.1621"></a><span id="l4.1621" class="difflineplus">+}</span>
<a href="#l4.1622"></a><span id="l4.1622" class="difflineplus">+</span>
<a href="#l4.1623"></a><span id="l4.1623" class="difflineplus">+nsMsgAttachedFile* CMapiMessage::GetAttachments()</span>
<a href="#l4.1624"></a><span id="l4.1624" class="difflineplus">+{</span>
<a href="#l4.1625"></a><span id="l4.1625" class="difflineplus">+  nsMsgAttachedFile* result = new nsMsgAttachedFile[m_stdattachments.size()+1];</span>
<a href="#l4.1626"></a><span id="l4.1626" class="difflineplus">+  if (!result)</span>
<a href="#l4.1627"></a><span id="l4.1627" class="difflineplus">+    return 0;</span>
<a href="#l4.1628"></a><span id="l4.1628" class="difflineplus">+  memset(result, 0, sizeof(nsMsgAttachedFile)*m_stdattachments.size()+1);</span>
<a href="#l4.1629"></a><span id="l4.1629" class="difflineplus">+</span>
<a href="#l4.1630"></a><span id="l4.1630" class="difflineplus">+  nsMsgAttachedFile* pos=result;</span>
<a href="#l4.1631"></a><span id="l4.1631" class="difflineplus">+  for (std::vector&lt;attach_data*&gt;::const_iterator it = m_stdattachments.begin();</span>
<a href="#l4.1632"></a><span id="l4.1632" class="difflineplus">+       it != m_stdattachments.end(); pos++, it++) {</span>
<a href="#l4.1633"></a><span id="l4.1633" class="difflineplus">+    pos-&gt;orig_url = (*it)-&gt;orig_url;</span>
<a href="#l4.1634"></a><span id="l4.1634" class="difflineplus">+    pos-&gt;tmp_file = (*it)-&gt;tmp_file;</span>
<a href="#l4.1635"></a><span id="l4.1635" class="difflineplus">+    pos-&gt;encoding = (*it)-&gt;encoding;</span>
<a href="#l4.1636"></a><span id="l4.1636" class="difflineplus">+    pos-&gt;real_name = (*it)-&gt;real_name;</span>
<a href="#l4.1637"></a><span id="l4.1637" class="difflineplus">+    pos-&gt;type = (*it)-&gt;type;</span>
<a href="#l4.1638"></a><span id="l4.1638">   }</span>
<a href="#l4.1639"></a><span id="l4.1639"> </span>
<a href="#l4.1640"></a><span id="l4.1640" class="difflineminus">-  LPSPropValue pVal;</span>
<a href="#l4.1641"></a><span id="l4.1641" class="difflineminus">-  pVal = CMapiApi::GetMapiProperty( lpAttach, PR_ATTACH_MIME_TAG);</span>
<a href="#l4.1642"></a><span id="l4.1642" class="difflineminus">-  if (pVal)</span>
<a href="#l4.1643"></a><span id="l4.1643" class="difflineminus">-    CMapiApi::GetStringFromProp( pVal, m_attachMimeType);</span>
<a href="#l4.1644"></a><span id="l4.1644" class="difflineminus">-  else</span>
<a href="#l4.1645"></a><span id="l4.1645" class="difflineminus">-    m_attachMimeType.Truncate();</span>
<a href="#l4.1646"></a><span id="l4.1646" class="difflineplus">+  return result;</span>
<a href="#l4.1647"></a><span id="l4.1647" class="difflineplus">+}</span>
<a href="#l4.1648"></a><span id="l4.1648" class="difflineplus">+</span>
<a href="#l4.1649"></a><span id="l4.1649" class="difflineplus">+bool CMapiMessage::GetEmbeddedAttachmentInfo(unsigned int i, nsIURI **uri,</span>
<a href="#l4.1650"></a><span id="l4.1650" class="difflineplus">+                                             const char **cid,</span>
<a href="#l4.1651"></a><span id="l4.1651" class="difflineplus">+                                             const char **name) const</span>
<a href="#l4.1652"></a><span id="l4.1652" class="difflineplus">+{</span>
<a href="#l4.1653"></a><span id="l4.1653" class="difflineplus">+  if ((i &lt; 0) || ( i &gt;= m_embattachments.size()))</span>
<a href="#l4.1654"></a><span id="l4.1654" class="difflineplus">+    return false;</span>
<a href="#l4.1655"></a><span id="l4.1655" class="difflineplus">+  attach_data* data = m_embattachments[i];</span>
<a href="#l4.1656"></a><span id="l4.1656" class="difflineplus">+  if (!data)</span>
<a href="#l4.1657"></a><span id="l4.1657" class="difflineplus">+    return false;</span>
<a href="#l4.1658"></a><span id="l4.1658" class="difflineplus">+  *uri = data-&gt;orig_url;</span>
<a href="#l4.1659"></a><span id="l4.1659" class="difflineplus">+  *cid = data-&gt;cid;</span>
<a href="#l4.1660"></a><span id="l4.1660" class="difflineplus">+  *name = data-&gt;real_name;</span>
<a href="#l4.1661"></a><span id="l4.1661" class="difflineplus">+  return true;</span>
<a href="#l4.1662"></a><span id="l4.1662" class="difflineplus">+}</span>
<a href="#l4.1663"></a><span id="l4.1663" class="difflineplus">+</span>
<a href="#l4.1664"></a><span id="l4.1664" class="difflineplus">+//////////////////////////////////////////////////////</span>
<a href="#l4.1665"></a><span id="l4.1665" class="difflineplus">+</span>
<a href="#l4.1666"></a><span id="l4.1666" class="difflineplus">+// begin and end MUST point to the same string</span>
<a href="#l4.1667"></a><span id="l4.1667" class="difflineplus">+wchar_t* dup(const wchar_t* begin, const wchar_t* end)</span>
<a href="#l4.1668"></a><span id="l4.1668" class="difflineplus">+{</span>
<a href="#l4.1669"></a><span id="l4.1669" class="difflineplus">+  if (begin &gt;= end)</span>
<a href="#l4.1670"></a><span id="l4.1670" class="difflineplus">+    return 0;</span>
<a href="#l4.1671"></a><span id="l4.1671" class="difflineplus">+  wchar_t* str = new wchar_t[end-begin+1];</span>
<a href="#l4.1672"></a><span id="l4.1672" class="difflineplus">+  memcpy(str, begin, (end-begin)*sizeof(begin[0]));</span>
<a href="#l4.1673"></a><span id="l4.1673" class="difflineplus">+  str[end - begin] = 0;</span>
<a href="#l4.1674"></a><span id="l4.1674" class="difflineplus">+  return str;</span>
<a href="#l4.1675"></a><span id="l4.1675" class="difflineplus">+}</span>
<a href="#l4.1676"></a><span id="l4.1676" class="difflineplus">+</span>
<a href="#l4.1677"></a><span id="l4.1677" class="difflineplus">+// See RFC822</span>
<a href="#l4.1678"></a><span id="l4.1678" class="difflineplus">+inline bool IsPrintableASCII(wchar_t c) { return (c &gt; 32) &amp;&amp; (c &lt; 127); }</span>
<a href="#l4.1679"></a><span id="l4.1679" class="difflineplus">+inline bool IsWSP(wchar_t c) { return (c == 32) || (c == 9); }</span>
<a href="#l4.1680"></a><span id="l4.1680" class="difflineplus">+</span>
<a href="#l4.1681"></a><span id="l4.1681" class="difflineplus">+CMapiMessageHeaders::CHeaderField::CHeaderField(const wchar_t* begin, int len)</span>
<a href="#l4.1682"></a><span id="l4.1682" class="difflineplus">+  : m_fname(0), m_fbody(0)</span>
<a href="#l4.1683"></a><span id="l4.1683" class="difflineplus">+{</span>
<a href="#l4.1684"></a><span id="l4.1684" class="difflineplus">+  const wchar_t *end = begin+len, *fname_end = begin;</span>
<a href="#l4.1685"></a><span id="l4.1685" class="difflineplus">+  while ((fname_end &lt; end) &amp;&amp; IsPrintableASCII(*fname_end) &amp;&amp; (*fname_end != L':'))</span>
<a href="#l4.1686"></a><span id="l4.1686" class="difflineplus">+    ++fname_end;</span>
<a href="#l4.1687"></a><span id="l4.1687" class="difflineplus">+  if ((fname_end == end) || (*fname_end != L':'))</span>
<a href="#l4.1688"></a><span id="l4.1688" class="difflineplus">+    return; // Not a valid header!</span>
<a href="#l4.1689"></a><span id="l4.1689" class="difflineplus">+  m_fname = dup(begin, fname_end+1); // including colon</span>
<a href="#l4.1690"></a><span id="l4.1690" class="difflineplus">+  m_fbody = dup(fname_end+1, end);</span>
<a href="#l4.1691"></a><span id="l4.1691" class="difflineplus">+}</span>
<a href="#l4.1692"></a><span id="l4.1692" class="difflineplus">+</span>
<a href="#l4.1693"></a><span id="l4.1693" class="difflineplus">+CMapiMessageHeaders::CHeaderField::CHeaderField(const wchar_t* name, const wchar_t* body)</span>
<a href="#l4.1694"></a><span id="l4.1694" class="difflineplus">+  : m_fname(dup(name, name+wcslen(name))), m_fbody(dup(body, body+wcslen(body)))</span>
<a href="#l4.1695"></a><span id="l4.1695" class="difflineplus">+{</span>
<a href="#l4.1696"></a><span id="l4.1696" class="difflineplus">+}</span>
<a href="#l4.1697"></a><span id="l4.1697" class="difflineplus">+</span>
<a href="#l4.1698"></a><span id="l4.1698" class="difflineplus">+CMapiMessageHeaders::CHeaderField::~CHeaderField()</span>
<a href="#l4.1699"></a><span id="l4.1699" class="difflineplus">+{</span>
<a href="#l4.1700"></a><span id="l4.1700" class="difflineplus">+  delete[] m_fname;</span>
<a href="#l4.1701"></a><span id="l4.1701" class="difflineplus">+  delete[] m_fbody;</span>
<a href="#l4.1702"></a><span id="l4.1702" class="difflineplus">+}</span>
<a href="#l4.1703"></a><span id="l4.1703" class="difflineplus">+</span>
<a href="#l4.1704"></a><span id="l4.1704" class="difflineplus">+void CMapiMessageHeaders::CHeaderField::set_fbody(const wchar_t* txt)</span>
<a href="#l4.1705"></a><span id="l4.1705" class="difflineplus">+{</span>
<a href="#l4.1706"></a><span id="l4.1706" class="difflineplus">+  if (m_fbody == txt)</span>
<a href="#l4.1707"></a><span id="l4.1707" class="difflineplus">+    return; // to avoid assigning to self</span>
<a href="#l4.1708"></a><span id="l4.1708" class="difflineplus">+  wchar_t* oldbody = m_fbody;</span>
<a href="#l4.1709"></a><span id="l4.1709" class="difflineplus">+  m_fbody = dup(txt, txt+wcslen(txt));</span>
<a href="#l4.1710"></a><span id="l4.1710" class="difflineplus">+  delete[] oldbody;</span>
<a href="#l4.1711"></a><span id="l4.1711" class="difflineplus">+}</span>
<a href="#l4.1712"></a><span id="l4.1712" class="difflineplus">+</span>
<a href="#l4.1713"></a><span id="l4.1713" class="difflineplus">+void CMapiMessageHeaders::CHeaderField::UnfoldFoldedSpaces(const wchar_t* body,</span>
<a href="#l4.1714"></a><span id="l4.1714" class="difflineplus">+                                                           nsString&amp; dest)</span>
<a href="#l4.1715"></a><span id="l4.1715" class="difflineplus">+{</span>
<a href="#l4.1716"></a><span id="l4.1716" class="difflineplus">+  dest.Truncate();</span>
<a href="#l4.1717"></a><span id="l4.1717" class="difflineplus">+  if (!body)</span>
<a href="#l4.1718"></a><span id="l4.1718" class="difflineplus">+    return;</span>
<a href="#l4.1719"></a><span id="l4.1719" class="difflineplus">+  const wchar_t* pos = body;</span>
<a href="#l4.1720"></a><span id="l4.1720" class="difflineplus">+  while (*pos) {</span>
<a href="#l4.1721"></a><span id="l4.1721" class="difflineplus">+    if ((*pos == '\x0D') &amp;&amp; (*(pos+1) == '\x0A') &amp;&amp; *(pos+2) &amp;&amp; IsWSP(*(pos+2)))</span>
<a href="#l4.1722"></a><span id="l4.1722" class="difflineplus">+      pos += 2; // Skip CRLF if it is followed by SPACE or TAB</span>
<a href="#l4.1723"></a><span id="l4.1723" class="difflineplus">+    else</span>
<a href="#l4.1724"></a><span id="l4.1724" class="difflineplus">+      dest.Append(*(pos++));</span>
<a href="#l4.1725"></a><span id="l4.1725" class="difflineplus">+  }</span>
<a href="#l4.1726"></a><span id="l4.1726" class="difflineplus">+}</span>
<a href="#l4.1727"></a><span id="l4.1727" class="difflineplus">+</span>
<a href="#l4.1728"></a><span id="l4.1728" class="difflineplus">+////////////////////////////////////////</span>
<a href="#l4.1729"></a><span id="l4.1729" class="difflineplus">+</span>
<a href="#l4.1730"></a><span id="l4.1730" class="difflineplus">+const wchar_t* CMapiMessageHeaders::Specials[hdrMax] = {</span>
<a href="#l4.1731"></a><span id="l4.1731" class="difflineplus">+  L&quot;Date:&quot;,</span>
<a href="#l4.1732"></a><span id="l4.1732" class="difflineplus">+  L&quot;From:&quot;,</span>
<a href="#l4.1733"></a><span id="l4.1733" class="difflineplus">+  L&quot;Sender:&quot;,</span>
<a href="#l4.1734"></a><span id="l4.1734" class="difflineplus">+  L&quot;Reply-To:&quot;,</span>
<a href="#l4.1735"></a><span id="l4.1735" class="difflineplus">+  L&quot;To:&quot;,</span>
<a href="#l4.1736"></a><span id="l4.1736" class="difflineplus">+  L&quot;Cc:&quot;,</span>
<a href="#l4.1737"></a><span id="l4.1737" class="difflineplus">+  L&quot;Bcc:&quot;,</span>
<a href="#l4.1738"></a><span id="l4.1738" class="difflineplus">+  L&quot;Message-ID:&quot;,</span>
<a href="#l4.1739"></a><span id="l4.1739" class="difflineplus">+  L&quot;Subject:&quot;,</span>
<a href="#l4.1740"></a><span id="l4.1740" class="difflineplus">+  L&quot;Mime-Version:&quot;,</span>
<a href="#l4.1741"></a><span id="l4.1741" class="difflineplus">+  L&quot;Content-Type:&quot;,</span>
<a href="#l4.1742"></a><span id="l4.1742" class="difflineplus">+  L&quot;Content-Transfer-Encoding:&quot;</span>
<a href="#l4.1743"></a><span id="l4.1743" class="difflineplus">+};</span>
<a href="#l4.1744"></a><span id="l4.1744" class="difflineplus">+</span>
<a href="#l4.1745"></a><span id="l4.1745" class="difflineplus">+CMapiMessageHeaders::~CMapiMessageHeaders()</span>
<a href="#l4.1746"></a><span id="l4.1746" class="difflineplus">+{</span>
<a href="#l4.1747"></a><span id="l4.1747" class="difflineplus">+  ClearHeaderFields();</span>
<a href="#l4.1748"></a><span id="l4.1748" class="difflineplus">+}</span>
<a href="#l4.1749"></a><span id="l4.1749"> </span>
<a href="#l4.1750"></a><span id="l4.1750" class="difflineminus">-  pVal = CMapiApi::GetMapiProperty( lpAttach, PR_ATTACH_METHOD);</span>
<a href="#l4.1751"></a><span id="l4.1751" class="difflineminus">-  if (pVal) {</span>
<a href="#l4.1752"></a><span id="l4.1752" class="difflineminus">-    LONG aMethod = CMapiApi::GetLongFromProp( pVal);</span>
<a href="#l4.1753"></a><span id="l4.1753" class="difflineminus">-    if ((aMethod == ATTACH_BY_REF_ONLY) || (aMethod == ATTACH_BY_REFERENCE) || (aMethod == ATTACH_BY_REF_RESOLVE)) {</span>
<a href="#l4.1754"></a><span id="l4.1754" class="difflineminus">-      m_attachPath.Truncate();</span>
<a href="#l4.1755"></a><span id="l4.1755" class="difflineminus">-      pVal = CMapiApi::GetMapiProperty( lpAttach, PR_ATTACH_PATHNAME);</span>
<a href="#l4.1756"></a><span id="l4.1756" class="difflineminus">-      if (pVal)</span>
<a href="#l4.1757"></a><span id="l4.1757" class="difflineminus">-        CMapiApi::GetStringFromProp( pVal, m_attachPath);</span>
<a href="#l4.1758"></a><span id="l4.1758" class="difflineminus">-      MAPI_TRACE2(&quot;\t\t** Attachment #%d by ref: %s\r\n&quot;,</span>
<a href="#l4.1759"></a><span id="l4.1759" class="difflineminus">-                  idx, m_attachPath.get());</span>
<a href="#l4.1760"></a><span id="l4.1760" class="difflineminus">-      m_ownsAttachFile = FALSE;</span>
<a href="#l4.1761"></a><span id="l4.1761" class="difflineplus">+void Delete(void* p) { delete p; }</span>
<a href="#l4.1762"></a><span id="l4.1762" class="difflineplus">+</span>
<a href="#l4.1763"></a><span id="l4.1763" class="difflineplus">+void CMapiMessageHeaders::ClearHeaderFields()</span>
<a href="#l4.1764"></a><span id="l4.1764" class="difflineplus">+{</span>
<a href="#l4.1765"></a><span id="l4.1765" class="difflineplus">+  std::for_each(m_headerFields.begin(), m_headerFields.end(), Delete);</span>
<a href="#l4.1766"></a><span id="l4.1766" class="difflineplus">+  m_headerFields.clear();</span>
<a href="#l4.1767"></a><span id="l4.1767" class="difflineplus">+}</span>
<a href="#l4.1768"></a><span id="l4.1768" class="difflineplus">+</span>
<a href="#l4.1769"></a><span id="l4.1769" class="difflineplus">+void CMapiMessageHeaders::Assign(const wchar_t* headers)</span>
<a href="#l4.1770"></a><span id="l4.1770" class="difflineplus">+{</span>
<a href="#l4.1771"></a><span id="l4.1771" class="difflineplus">+  for (int i=0; i&lt;hdrMax; i++)</span>
<a href="#l4.1772"></a><span id="l4.1772" class="difflineplus">+    m_SpecialHeaders[i] = 0;</span>
<a href="#l4.1773"></a><span id="l4.1773" class="difflineplus">+  ClearHeaderFields();</span>
<a href="#l4.1774"></a><span id="l4.1774" class="difflineplus">+  if (!headers)</span>
<a href="#l4.1775"></a><span id="l4.1775" class="difflineplus">+    return;</span>
<a href="#l4.1776"></a><span id="l4.1776" class="difflineplus">+  const wchar_t *start=headers, *end=headers;</span>
<a href="#l4.1777"></a><span id="l4.1777" class="difflineplus">+  while (*end) {</span>
<a href="#l4.1778"></a><span id="l4.1778" class="difflineplus">+    if ((*end == L'\x0D') &amp;&amp; (*(end+1) == L'\x0A')) { // CRLF</span>
<a href="#l4.1779"></a><span id="l4.1779" class="difflineplus">+      if (!IsWSP(*(end+2))) { // Not SPACE nor TAB (avoid FSP) -&gt; next header or EOF</span>
<a href="#l4.1780"></a><span id="l4.1780" class="difflineplus">+        Add(new CHeaderField(start, end-start));</span>
<a href="#l4.1781"></a><span id="l4.1781" class="difflineplus">+        start = ++end + 1;</span>
<a href="#l4.1782"></a><span id="l4.1782" class="difflineplus">+      }</span>
<a href="#l4.1783"></a><span id="l4.1783" class="difflineplus">+    }</span>
<a href="#l4.1784"></a><span id="l4.1784" class="difflineplus">+    ++end;</span>
<a href="#l4.1785"></a><span id="l4.1785" class="difflineplus">+  }</span>
<a href="#l4.1786"></a><span id="l4.1786" class="difflineplus">+</span>
<a href="#l4.1787"></a><span id="l4.1787" class="difflineplus">+  if (start &lt; end) { // Last header left</span>
<a href="#l4.1788"></a><span id="l4.1788" class="difflineplus">+    Add(new CHeaderField(start, end-start));</span>
<a href="#l4.1789"></a><span id="l4.1789" class="difflineplus">+  }</span>
<a href="#l4.1790"></a><span id="l4.1790" class="difflineplus">+}</span>
<a href="#l4.1791"></a><span id="l4.1791" class="difflineplus">+</span>
<a href="#l4.1792"></a><span id="l4.1792" class="difflineplus">+void CMapiMessageHeaders::Add(CHeaderField* f)</span>
<a href="#l4.1793"></a><span id="l4.1793" class="difflineplus">+{</span>
<a href="#l4.1794"></a><span id="l4.1794" class="difflineplus">+  if (!f)</span>
<a href="#l4.1795"></a><span id="l4.1795" class="difflineplus">+    return;</span>
<a href="#l4.1796"></a><span id="l4.1796" class="difflineplus">+  if (!f-&gt;Valid()) {</span>
<a href="#l4.1797"></a><span id="l4.1797" class="difflineplus">+    delete f;</span>
<a href="#l4.1798"></a><span id="l4.1798" class="difflineplus">+    return;</span>
<a href="#l4.1799"></a><span id="l4.1799" class="difflineplus">+  }</span>
<a href="#l4.1800"></a><span id="l4.1800" class="difflineplus">+</span>
<a href="#l4.1801"></a><span id="l4.1801" class="difflineplus">+  SpecialHeader idx = CheckSpecialHeader(f-&gt;fname());</span>
<a href="#l4.1802"></a><span id="l4.1802" class="difflineplus">+  if (idx != hdrNone) {</span>
<a href="#l4.1803"></a><span id="l4.1803" class="difflineplus">+    // Now check if the special header was already inserted;</span>
<a href="#l4.1804"></a><span id="l4.1804" class="difflineplus">+    // if so, remove previous and add this new</span>
<a href="#l4.1805"></a><span id="l4.1805" class="difflineplus">+    CHeaderField* PrevSpecial = m_SpecialHeaders[idx];</span>
<a href="#l4.1806"></a><span id="l4.1806" class="difflineplus">+    if (PrevSpecial) {</span>
<a href="#l4.1807"></a><span id="l4.1807" class="difflineplus">+      std::vector&lt;CHeaderField*&gt;::iterator iter = std::find(m_headerFields.begin(), m_headerFields.end(), PrevSpecial);</span>
<a href="#l4.1808"></a><span id="l4.1808" class="difflineplus">+      if (iter != m_headerFields.end())</span>
<a href="#l4.1809"></a><span id="l4.1809" class="difflineplus">+        m_headerFields.erase(iter);</span>
<a href="#l4.1810"></a><span id="l4.1810" class="difflineplus">+      delete PrevSpecial;</span>
<a href="#l4.1811"></a><span id="l4.1811">     }</span>
<a href="#l4.1812"></a><span id="l4.1812" class="difflineminus">-    else if (aMethod == ATTACH_BY_VALUE) {</span>
<a href="#l4.1813"></a><span id="l4.1813" class="difflineminus">-      MAPI_TRACE1( &quot;\t\t** Attachment #%d by value.\r\n&quot;, idx);</span>
<a href="#l4.1814"></a><span id="l4.1814" class="difflineminus">-      bResult = CopyBinAttachToFile( lpAttach);</span>
<a href="#l4.1815"></a><span id="l4.1815" class="difflineminus">-    }</span>
<a href="#l4.1816"></a><span id="l4.1816" class="difflineminus">-    else if (aMethod == ATTACH_OLE) {</span>
<a href="#l4.1817"></a><span id="l4.1817" class="difflineminus">-      MAPI_TRACE1( &quot;\t\t** Attachment #%d by OLE - yuck!!!\r\n&quot;, idx);</span>
<a href="#l4.1818"></a><span id="l4.1818" class="difflineminus">-    }</span>
<a href="#l4.1819"></a><span id="l4.1819" class="difflineminus">-    else if (aMethod == ATTACH_EMBEDDED_MSG) {</span>
<a href="#l4.1820"></a><span id="l4.1820" class="difflineminus">-      MAPI_TRACE1( &quot;\t\t** Attachment #%d by Embedded Message??\r\n&quot;, idx);</span>
<a href="#l4.1821"></a><span id="l4.1821" class="difflineminus">-    }</span>
<a href="#l4.1822"></a><span id="l4.1822" class="difflineminus">-    else {</span>
<a href="#l4.1823"></a><span id="l4.1823" class="difflineminus">-      MAPI_TRACE2( &quot;\t\t** Attachment #%d unknown attachment method - 0x%lx\r\n&quot;, idx, aMethod);</span>
<a href="#l4.1824"></a><span id="l4.1824" class="difflineminus">-      bResult = FALSE;</span>
<a href="#l4.1825"></a><span id="l4.1825" class="difflineminus">-    }</span>
<a href="#l4.1826"></a><span id="l4.1826" class="difflineplus">+    m_SpecialHeaders[idx] = f;</span>
<a href="#l4.1827"></a><span id="l4.1827" class="difflineplus">+  }</span>
<a href="#l4.1828"></a><span id="l4.1828" class="difflineplus">+  m_headerFields.push_back(f);</span>
<a href="#l4.1829"></a><span id="l4.1829" class="difflineplus">+}</span>
<a href="#l4.1830"></a><span id="l4.1830" class="difflineplus">+</span>
<a href="#l4.1831"></a><span id="l4.1831" class="difflineplus">+CMapiMessageHeaders::SpecialHeader CMapiMessageHeaders::CheckSpecialHeader(const wchar_t* fname) const</span>
<a href="#l4.1832"></a><span id="l4.1832" class="difflineplus">+{</span>
<a href="#l4.1833"></a><span id="l4.1833" class="difflineplus">+  for (int i = hdrFirst; i &lt; hdrMax; i++)</span>
<a href="#l4.1834"></a><span id="l4.1834" class="difflineplus">+    if (!wcsicmp(fname, Specials[i]))</span>
<a href="#l4.1835"></a><span id="l4.1835" class="difflineplus">+      return static_cast&lt;SpecialHeader&gt;(i);</span>
<a href="#l4.1836"></a><span id="l4.1836" class="difflineplus">+</span>
<a href="#l4.1837"></a><span id="l4.1837" class="difflineplus">+  return hdrNone;</span>
<a href="#l4.1838"></a><span id="l4.1838" class="difflineplus">+}</span>
<a href="#l4.1839"></a><span id="l4.1839" class="difflineplus">+</span>
<a href="#l4.1840"></a><span id="l4.1840" class="difflineplus">+const CMapiMessageHeaders::CHeaderField* CMapiMessageHeaders::CFind(const wchar_t* name) const</span>
<a href="#l4.1841"></a><span id="l4.1841" class="difflineplus">+{</span>
<a href="#l4.1842"></a><span id="l4.1842" class="difflineplus">+  SpecialHeader special = CheckSpecialHeader(name);</span>
<a href="#l4.1843"></a><span id="l4.1843" class="difflineplus">+  if ((special &gt; hdrNone) &amp;&amp; (special &lt; hdrMax))</span>
<a href="#l4.1844"></a><span id="l4.1844" class="difflineplus">+    return m_SpecialHeaders[special]; // No need to search further, because it MUST be here</span>
<a href="#l4.1845"></a><span id="l4.1845" class="difflineplus">+</span>
<a href="#l4.1846"></a><span id="l4.1846" class="difflineplus">+  std::vector&lt;CHeaderField*&gt;::const_iterator iter = std::find_if(m_headerFields.begin(), m_headerFields.end(), fname_equals(name));</span>
<a href="#l4.1847"></a><span id="l4.1847" class="difflineplus">+  if (iter == m_headerFields.end())</span>
<a href="#l4.1848"></a><span id="l4.1848" class="difflineplus">+    return 0;</span>
<a href="#l4.1849"></a><span id="l4.1849" class="difflineplus">+  return *iter;</span>
<a href="#l4.1850"></a><span id="l4.1850" class="difflineplus">+}</span>
<a href="#l4.1851"></a><span id="l4.1851" class="difflineplus">+</span>
<a href="#l4.1852"></a><span id="l4.1852" class="difflineplus">+const wchar_t* CMapiMessageHeaders::Value(SpecialHeader special) const</span>
<a href="#l4.1853"></a><span id="l4.1853" class="difflineplus">+{</span>
<a href="#l4.1854"></a><span id="l4.1854" class="difflineplus">+  if ((special &lt;= hdrNone) || (special &gt;= hdrMax))</span>
<a href="#l4.1855"></a><span id="l4.1855" class="difflineplus">+    return 0;</span>
<a href="#l4.1856"></a><span id="l4.1856" class="difflineplus">+  return (m_SpecialHeaders[special]) ? m_SpecialHeaders[special]-&gt;fbody() : 0;</span>
<a href="#l4.1857"></a><span id="l4.1857" class="difflineplus">+}</span>
<a href="#l4.1858"></a><span id="l4.1858" class="difflineplus">+</span>
<a href="#l4.1859"></a><span id="l4.1859" class="difflineplus">+const wchar_t* CMapiMessageHeaders::Value(const wchar_t* name) const</span>
<a href="#l4.1860"></a><span id="l4.1860" class="difflineplus">+{</span>
<a href="#l4.1861"></a><span id="l4.1861" class="difflineplus">+  const CHeaderField* result = CFind(name);</span>
<a href="#l4.1862"></a><span id="l4.1862" class="difflineplus">+  return result ? result-&gt;fbody() : 0;</span>
<a href="#l4.1863"></a><span id="l4.1863" class="difflineplus">+}</span>
<a href="#l4.1864"></a><span id="l4.1864" class="difflineplus">+</span>
<a href="#l4.1865"></a><span id="l4.1865" class="difflineplus">+void CMapiMessageHeaders::UnfoldValue(const wchar_t* name, nsString&amp; dest) const</span>
<a href="#l4.1866"></a><span id="l4.1866" class="difflineplus">+{</span>
<a href="#l4.1867"></a><span id="l4.1867" class="difflineplus">+  CHeaderField::UnfoldFoldedSpaces(Value(name), dest);</span>
<a href="#l4.1868"></a><span id="l4.1868" class="difflineplus">+}</span>
<a href="#l4.1869"></a><span id="l4.1869" class="difflineplus">+</span>
<a href="#l4.1870"></a><span id="l4.1870" class="difflineplus">+void CMapiMessageHeaders::UnfoldValue(SpecialHeader special, nsString&amp; dest) const</span>
<a href="#l4.1871"></a><span id="l4.1871" class="difflineplus">+{</span>
<a href="#l4.1872"></a><span id="l4.1872" class="difflineplus">+  CHeaderField::UnfoldFoldedSpaces(Value(special), dest);</span>
<a href="#l4.1873"></a><span id="l4.1873" class="difflineplus">+}</span>
<a href="#l4.1874"></a><span id="l4.1874" class="difflineplus">+</span>
<a href="#l4.1875"></a><span id="l4.1875" class="difflineplus">+int CMapiMessageHeaders::SetValue(const wchar_t* name, const wchar_t* value, bool replace)</span>
<a href="#l4.1876"></a><span id="l4.1876" class="difflineplus">+{</span>
<a href="#l4.1877"></a><span id="l4.1877" class="difflineplus">+  CHeaderField* result = Find(name);</span>
<a href="#l4.1878"></a><span id="l4.1878" class="difflineplus">+  if (result) {</span>
<a href="#l4.1879"></a><span id="l4.1879" class="difflineplus">+    result-&gt;set_fbody(value);</span>
<a href="#l4.1880"></a><span id="l4.1880">   }</span>
<a href="#l4.1881"></a><span id="l4.1881">   else</span>
<a href="#l4.1882"></a><span id="l4.1882" class="difflineminus">-    bResult = FALSE;</span>
<a href="#l4.1883"></a><span id="l4.1883" class="difflineminus">-</span>
<a href="#l4.1884"></a><span id="l4.1884" class="difflineminus">-  nsCString fName, fExt;</span>
<a href="#l4.1885"></a><span id="l4.1885" class="difflineminus">-  pVal = CMapiApi::GetMapiProperty( lpAttach, PR_ATTACH_LONG_FILENAME);</span>
<a href="#l4.1886"></a><span id="l4.1886" class="difflineminus">-  if (pVal)</span>
<a href="#l4.1887"></a><span id="l4.1887" class="difflineminus">-    CMapiApi::GetStringFromProp( pVal, fName);</span>
<a href="#l4.1888"></a><span id="l4.1888" class="difflineminus">-  pVal = CMapiApi::GetMapiProperty( lpAttach, PR_ATTACH_EXTENSION);</span>
<a href="#l4.1889"></a><span id="l4.1889" class="difflineminus">-  if (pVal)</span>
<a href="#l4.1890"></a><span id="l4.1890" class="difflineminus">-    CMapiApi::GetStringFromProp( pVal, fExt);</span>
<a href="#l4.1891"></a><span id="l4.1891" class="difflineminus">-  pVal = CMapiApi::GetMapiProperty( lpAttach, PR_ATTACH_SIZE);</span>
<a href="#l4.1892"></a><span id="l4.1892" class="difflineminus">-  long sz = 0;</span>
<a href="#l4.1893"></a><span id="l4.1893" class="difflineminus">-  if (pVal)</span>
<a href="#l4.1894"></a><span id="l4.1894" class="difflineminus">-    sz = CMapiApi::GetLongFromProp( pVal);</span>
<a href="#l4.1895"></a><span id="l4.1895" class="difflineplus">+    Add(new CHeaderField(name, value));</span>
<a href="#l4.1896"></a><span id="l4.1896" class="difflineplus">+  return 0; // No sensible result is returned; maybe do something senseful later</span>
<a href="#l4.1897"></a><span id="l4.1897" class="difflineplus">+}</span>
<a href="#l4.1898"></a><span id="l4.1898"> </span>
<a href="#l4.1899"></a><span id="l4.1899" class="difflineminus">-  /*</span>
<a href="#l4.1900"></a><span id="l4.1900" class="difflineminus">-    // I have no idea how this tag is used, how to interpret it's value, etc.</span>
<a href="#l4.1901"></a><span id="l4.1901" class="difflineminus">-    // Fortunately, the Microsoft documentation is ABSOLUTELY NO HELP AT ALL.  In fact,</span>
<a href="#l4.1902"></a><span id="l4.1902" class="difflineminus">-    // if one goes by the docs and sample code, this tag is completely 100% useless.  I'm</span>
<a href="#l4.1903"></a><span id="l4.1903" class="difflineminus">-    // sure it has some important meaning which will one day be obvious, but for now,</span>
<a href="#l4.1904"></a><span id="l4.1904" class="difflineminus">-    // it is ignored.</span>
<a href="#l4.1905"></a><span id="l4.1905" class="difflineminus">-        pVal = CMapiApi::GetMapiProperty( lpAttach, PR_ATTACH_TAG);</span>
<a href="#l4.1906"></a><span id="l4.1906" class="difflineminus">-       if (pVal) {</span>
<a href="#l4.1907"></a><span id="l4.1907" class="difflineminus">-        ::MAPIFreeBuffer( pVal);</span>
<a href="#l4.1908"></a><span id="l4.1908" class="difflineminus">-      }</span>
<a href="#l4.1909"></a><span id="l4.1909" class="difflineminus">-  */</span>
<a href="#l4.1910"></a><span id="l4.1910" class="difflineplus">+int CMapiMessageHeaders::SetValue(SpecialHeader special, const wchar_t* value)</span>
<a href="#l4.1911"></a><span id="l4.1911" class="difflineplus">+{</span>
<a href="#l4.1912"></a><span id="l4.1912" class="difflineplus">+  CHeaderField* result = m_SpecialHeaders[special];</span>
<a href="#l4.1913"></a><span id="l4.1913" class="difflineplus">+  if (result)</span>
<a href="#l4.1914"></a><span id="l4.1914" class="difflineplus">+    result-&gt;set_fbody(value);</span>
<a href="#l4.1915"></a><span id="l4.1915" class="difflineplus">+  else</span>
<a href="#l4.1916"></a><span id="l4.1916" class="difflineplus">+    Add(new CHeaderField(Specials[special], value));</span>
<a href="#l4.1917"></a><span id="l4.1917" class="difflineplus">+  return 0;</span>
<a href="#l4.1918"></a><span id="l4.1918" class="difflineplus">+}</span>
<a href="#l4.1919"></a><span id="l4.1919"> </span>
<a href="#l4.1920"></a><span id="l4.1920" class="difflineminus">-  MAPI_TRACE1(&quot;\t\t\t--- Mime type: %s\r\n&quot;, m_attachMimeType.get());</span>
<a href="#l4.1921"></a><span id="l4.1921" class="difflineminus">-  MAPI_TRACE2(&quot;\t\t\t--- File name: %s, extension: %s\r\n&quot;,</span>
<a href="#l4.1922"></a><span id="l4.1922" class="difflineminus">-              fName.get(), fExt.get());</span>
<a href="#l4.1923"></a><span id="l4.1923" class="difflineminus">-  MAPI_TRACE1(&quot;\t\t\t--- Size: %ld\r\n&quot;, sz);</span>
<a href="#l4.1924"></a><span id="l4.1924" class="difflineplus">+void CMapiMessageHeaders::write_to_stream::operator () (const CHeaderField* f)</span>
<a href="#l4.1925"></a><span id="l4.1925" class="difflineplus">+{</span>
<a href="#l4.1926"></a><span id="l4.1926" class="difflineplus">+  if (!f || NS_FAILED(m_rv))</span>
<a href="#l4.1927"></a><span id="l4.1927" class="difflineplus">+    return;</span>
<a href="#l4.1928"></a><span id="l4.1928"> </span>
<a href="#l4.1929"></a><span id="l4.1929" class="difflineminus">-  if (fExt.IsEmpty()) {</span>
<a href="#l4.1930"></a><span id="l4.1930" class="difflineminus">-    int idx = fName.RFindChar( '.');</span>
<a href="#l4.1931"></a><span id="l4.1931" class="difflineminus">-    if (idx != -1)</span>
<a href="#l4.1932"></a><span id="l4.1932" class="difflineminus">-      fName.Right( fExt, fName.Length() - idx);</span>
<a href="#l4.1933"></a><span id="l4.1933" class="difflineminus">-  }</span>
<a href="#l4.1934"></a><span id="l4.1934" class="difflineminus">-</span>
<a href="#l4.1935"></a><span id="l4.1935" class="difflineminus">-  if ((fName.RFindChar( '.') == -1) &amp;&amp; !fExt.IsEmpty()) {</span>
<a href="#l4.1936"></a><span id="l4.1936" class="difflineminus">-    fName += &quot;.&quot;;</span>
<a href="#l4.1937"></a><span id="l4.1937" class="difflineminus">-    fName += fExt;</span>
<a href="#l4.1938"></a><span id="l4.1938" class="difflineminus">-  }</span>
<a href="#l4.1939"></a><span id="l4.1939" class="difflineminus">-</span>
<a href="#l4.1940"></a><span id="l4.1940" class="difflineminus">-  m_attachFileName = fName;</span>
<a href="#l4.1941"></a><span id="l4.1941" class="difflineplus">+  nsCString str;</span>
<a href="#l4.1942"></a><span id="l4.1942" class="difflineplus">+  PRUint32 written;</span>
<a href="#l4.1943"></a><span id="l4.1943" class="difflineplus">+  LossyCopyUTF16toASCII(f-&gt;fname(), str);</span>
<a href="#l4.1944"></a><span id="l4.1944" class="difflineplus">+  m_rv = m_pDst-&gt;Write( str.get(), str.Length(), &amp;written);</span>
<a href="#l4.1945"></a><span id="l4.1945" class="difflineplus">+  NS_ENSURE_SUCCESS(m_rv,);</span>
<a href="#l4.1946"></a><span id="l4.1946" class="difflineplus">+  LossyCopyUTF16toASCII(f-&gt;fbody(), str);</span>
<a href="#l4.1947"></a><span id="l4.1947" class="difflineplus">+  m_rv = m_pDst-&gt;Write(str.get(), str.Length(), &amp;written);</span>
<a href="#l4.1948"></a><span id="l4.1948" class="difflineplus">+  NS_ENSURE_SUCCESS(m_rv,);</span>
<a href="#l4.1949"></a><span id="l4.1949" class="difflineplus">+  m_rv = m_pDst-&gt;Write( &quot;\x0D\x0A&quot;, 2, &amp;written);</span>
<a href="#l4.1950"></a><span id="l4.1950" class="difflineplus">+}</span>
<a href="#l4.1951"></a><span id="l4.1951"> </span>
<a href="#l4.1952"></a><span id="l4.1952" class="difflineminus">-  if (m_attachMimeType.IsEmpty()) {</span>
<a href="#l4.1953"></a><span id="l4.1953" class="difflineminus">-    PRUint8 *pType = NULL;</span>
<a href="#l4.1954"></a><span id="l4.1954" class="difflineminus">-    if (!fExt.IsEmpty()) {</span>
<a href="#l4.1955"></a><span id="l4.1955" class="difflineminus">-      pType = CMimeTypes::GetMimeType( fExt);</span>
<a href="#l4.1956"></a><span id="l4.1956" class="difflineminus">-    }</span>
<a href="#l4.1957"></a><span id="l4.1957" class="difflineminus">-    if (pType)</span>
<a href="#l4.1958"></a><span id="l4.1958" class="difflineminus">-      m_attachMimeType = (PC_S8)pType;</span>
<a href="#l4.1959"></a><span id="l4.1959" class="difflineminus">-    else</span>
<a href="#l4.1960"></a><span id="l4.1960" class="difflineminus">-      m_attachMimeType = &quot;application/octet-stream&quot;;</span>
<a href="#l4.1961"></a><span id="l4.1961" class="difflineplus">+nsresult CMapiMessageHeaders::ToStream(nsIOutputStream *pDst) const</span>
<a href="#l4.1962"></a><span id="l4.1962" class="difflineplus">+{</span>
<a href="#l4.1963"></a><span id="l4.1963" class="difflineplus">+  nsresult rv = std::for_each(m_headerFields.begin(), m_headerFields.end(),</span>
<a href="#l4.1964"></a><span id="l4.1964" class="difflineplus">+                              write_to_stream(pDst));</span>
<a href="#l4.1965"></a><span id="l4.1965" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l4.1966"></a><span id="l4.1966" class="difflineplus">+    PRUint32 written;</span>
<a href="#l4.1967"></a><span id="l4.1967" class="difflineplus">+    rv = pDst-&gt;Write( &quot;\x0D\x0A&quot;, 2, &amp;written); // Separator line</span>
<a href="#l4.1968"></a><span id="l4.1968">   }</span>
<a href="#l4.1969"></a><span id="l4.1969" class="difflineminus">-</span>
<a href="#l4.1970"></a><span id="l4.1970" class="difflineminus">-  pVal = CMapiApi::GetMapiProperty( lpAttach, PR_ATTACH_TRANSPORT_NAME);</span>
<a href="#l4.1971"></a><span id="l4.1971" class="difflineminus">-  if (pVal) {</span>
<a href="#l4.1972"></a><span id="l4.1972" class="difflineminus">-    CMapiApi::GetStringFromProp( pVal, fName);</span>
<a href="#l4.1973"></a><span id="l4.1973" class="difflineminus">-    MAPI_TRACE1(&quot;\t\t\t--- Transport name: %s\r\n&quot;, fName.get());</span>
<a href="#l4.1974"></a><span id="l4.1974" class="difflineminus">-  }</span>
<a href="#l4.1975"></a><span id="l4.1975" class="difflineminus">-</span>
<a href="#l4.1976"></a><span id="l4.1976" class="difflineminus">-  lpAttach-&gt;Release();</span>
<a href="#l4.1977"></a><span id="l4.1977" class="difflineminus">-</span>
<a href="#l4.1978"></a><span id="l4.1978" class="difflineminus">-  return( bResult);</span>
<a href="#l4.1979"></a><span id="l4.1979" class="difflineplus">+  return rv;</span>
<a href="#l4.1980"></a><span id="l4.1980"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/import/outlook/src/MapiMessage.h</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/import/outlook/src/MapiMessage.h</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -36,103 +36,269 @@</span>
<a href="#l5.4"></a><span id="l5.4">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l5.5"></a><span id="l5.5"> #ifndef MapiMessage_h___</span>
<a href="#l5.6"></a><span id="l5.6"> #define MapiMessage_h___</span>
<a href="#l5.7"></a><span id="l5.7"> </span>
<a href="#l5.8"></a><span id="l5.8"> #include &quot;nsTArray.h&quot;</span>
<a href="#l5.9"></a><span id="l5.9"> #include &quot;nsString.h&quot;</span>
<a href="#l5.10"></a><span id="l5.10"> #include &quot;nsILocalFile.h&quot;</span>
<a href="#l5.11"></a><span id="l5.11"> #include &quot;MapiApi.h&quot;</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+#include &quot;nsIMsgSend.h&quot;</span>
<a href="#l5.13"></a><span id="l5.13"> </span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+#include &quot;nsProxiedService.h&quot;</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineplus">+#include &lt;vector&gt;</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineplus">+</span>
<a href="#l5.18"></a><span id="l5.18" class="difflineplus">+#ifndef PR_LAST_VERB_EXECUTED</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineplus">+#define PR_LAST_VERB_EXECUTED PROP_TAG( PT_LONG, 0x1081)</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineplus">+#endif</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+#define EXCHIVERB_REPLYTOSENDER (102)</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+#define EXCHIVERB_REPLYTOALL    (103)</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineplus">+#define EXCHIVERB_FORWARD       (104)</span>
<a href="#l5.25"></a><span id="l5.25" class="difflineplus">+</span>
<a href="#l5.26"></a><span id="l5.26" class="difflineplus">+#ifndef PR_ATTACH_CONTENT_ID</span>
<a href="#l5.27"></a><span id="l5.27" class="difflineplus">+#define PR_ATTACH_CONTENT_ID PROP_TAG( PT_TSTRING,	0x3712)</span>
<a href="#l5.28"></a><span id="l5.28" class="difflineplus">+#endif</span>
<a href="#l5.29"></a><span id="l5.29" class="difflineplus">+#ifndef PR_ATTACH_CONTENT_ID_W</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineplus">+#define PR_ATTACH_CONTENT_ID_W PROP_TAG( PT_UNICODE,	0x3712)</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineplus">+#endif</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+#ifndef PR_ATTACH_CONTENT_ID_A</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineplus">+#define PR_ATTACH_CONTENT_ID_A PROP_TAG( PT_STRING8,	0x3712)</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+#endif</span>
<a href="#l5.35"></a><span id="l5.35" class="difflineplus">+</span>
<a href="#l5.36"></a><span id="l5.36" class="difflineplus">+#ifndef PR_ATTACH_FLAGS</span>
<a href="#l5.37"></a><span id="l5.37" class="difflineplus">+#define PR_ATTACH_FLAGS PROP_TAG(PT_LONG,	0x3714)</span>
<a href="#l5.38"></a><span id="l5.38" class="difflineplus">+#endif</span>
<a href="#l5.39"></a><span id="l5.39" class="difflineplus">+</span>
<a href="#l5.40"></a><span id="l5.40" class="difflineplus">+#ifndef ATT_INVISIBLE_IN_HTML</span>
<a href="#l5.41"></a><span id="l5.41" class="difflineplus">+#define ATT_INVISIBLE_IN_HTML (0x1)</span>
<a href="#l5.42"></a><span id="l5.42" class="difflineplus">+#endif</span>
<a href="#l5.43"></a><span id="l5.43" class="difflineplus">+#ifndef ATT_INVISIBLE_IN_RTF</span>
<a href="#l5.44"></a><span id="l5.44" class="difflineplus">+#define ATT_INVISIBLE_IN_RTF  (0x2)</span>
<a href="#l5.45"></a><span id="l5.45" class="difflineplus">+#endif</span>
<a href="#l5.46"></a><span id="l5.46" class="difflineplus">+#ifndef ATT_MHTML_REF</span>
<a href="#l5.47"></a><span id="l5.47" class="difflineplus">+#define ATT_MHTML_REF         (0x4)</span>
<a href="#l5.48"></a><span id="l5.48" class="difflineplus">+#endif</span>
<a href="#l5.49"></a><span id="l5.49" class="difflineplus">+</span>
<a href="#l5.50"></a><span id="l5.50" class="difflineplus">+//////////////////////////////////////////////////////////////////////////////</span>
<a href="#l5.51"></a><span id="l5.51" class="difflineplus">+</span>
<a href="#l5.52"></a><span id="l5.52" class="difflineplus">+class CMapiMessageHeaders {</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineplus">+public:</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineplus">+  // Special headers that MUST appear at most once (see RFC822)</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineplus">+  enum SpecialHeader { hdrNone=-1, hdrFirst = 0, // utility values</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+                       hdrDate=hdrFirst,</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+                       hdrFrom,</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineplus">+                       hdrSender,</span>
<a href="#l5.59"></a><span id="l5.59" class="difflineplus">+                       hdrReplyTo,</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineplus">+                       hdrTo,</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineplus">+                       hdrCc,</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineplus">+                       hdrBcc,</span>
<a href="#l5.63"></a><span id="l5.63" class="difflineplus">+                       hdrMessageID,</span>
<a href="#l5.64"></a><span id="l5.64" class="difflineplus">+                       hdrSubject,</span>
<a href="#l5.65"></a><span id="l5.65" class="difflineplus">+                       hdrMimeVersion,</span>
<a href="#l5.66"></a><span id="l5.66" class="difflineplus">+                       hdrContentType,</span>
<a href="#l5.67"></a><span id="l5.67" class="difflineplus">+                       hdrContentTransferEncoding,</span>
<a href="#l5.68"></a><span id="l5.68" class="difflineplus">+                       hdrMax // utility value</span>
<a href="#l5.69"></a><span id="l5.69" class="difflineplus">+                     };</span>
<a href="#l5.70"></a><span id="l5.70" class="difflineplus">+</span>
<a href="#l5.71"></a><span id="l5.71" class="difflineplus">+  CMapiMessageHeaders(const wchar_t* headers = 0) { Assign(headers); }</span>
<a href="#l5.72"></a><span id="l5.72" class="difflineplus">+  CMapiMessageHeaders(const char* headers)</span>
<a href="#l5.73"></a><span id="l5.73" class="difflineplus">+  {</span>
<a href="#l5.74"></a><span id="l5.74" class="difflineplus">+    nsString uniHeaders;</span>
<a href="#l5.75"></a><span id="l5.75" class="difflineplus">+    CopyASCIItoUTF16(headers, uniHeaders);</span>
<a href="#l5.76"></a><span id="l5.76" class="difflineplus">+    Assign(uniHeaders.get());</span>
<a href="#l5.77"></a><span id="l5.77" class="difflineplus">+  }</span>
<a href="#l5.78"></a><span id="l5.78" class="difflineplus">+  ~CMapiMessageHeaders();</span>
<a href="#l5.79"></a><span id="l5.79" class="difflineplus">+  void Assign(const wchar_t* headers);</span>
<a href="#l5.80"></a><span id="l5.80" class="difflineplus">+</span>
<a href="#l5.81"></a><span id="l5.81" class="difflineplus">+  inline bool IsEmpty() const { return m_headerFields.empty(); }</span>
<a href="#l5.82"></a><span id="l5.82" class="difflineplus">+  // if no such header exists then 0 is returned, else the first value returned</span>
<a href="#l5.83"></a><span id="l5.83" class="difflineplus">+  const wchar_t* Value(const wchar_t* name) const;</span>
<a href="#l5.84"></a><span id="l5.84" class="difflineplus">+  // if no such header exists then 0 is returned</span>
<a href="#l5.85"></a><span id="l5.85" class="difflineplus">+  const wchar_t* Value(SpecialHeader special) const;</span>
<a href="#l5.86"></a><span id="l5.86" class="difflineplus">+</span>
<a href="#l5.87"></a><span id="l5.87" class="difflineplus">+  void UnfoldValue(const wchar_t* name, nsString&amp; dest) const;</span>
<a href="#l5.88"></a><span id="l5.88" class="difflineplus">+  void UnfoldValue(SpecialHeader special, nsString&amp; dest) const;</span>
<a href="#l5.89"></a><span id="l5.89" class="difflineplus">+</span>
<a href="#l5.90"></a><span id="l5.90" class="difflineplus">+  // TODO: if replace is set, then all headers with this name will be removed</span>
<a href="#l5.91"></a><span id="l5.91" class="difflineplus">+  //  and one with this value will be added, otherwise a new header is added</span>
<a href="#l5.92"></a><span id="l5.92" class="difflineplus">+  // (Unnecessary for now)</span>
<a href="#l5.93"></a><span id="l5.93" class="difflineplus">+  int SetValue(const wchar_t* name, const wchar_t* value, bool replace = true);</span>
<a href="#l5.94"></a><span id="l5.94" class="difflineplus">+  int SetValue(SpecialHeader special, const wchar_t* value);</span>
<a href="#l5.95"></a><span id="l5.95" class="difflineplus">+</span>
<a href="#l5.96"></a><span id="l5.96" class="difflineplus">+  nsresult ToStream(nsIOutputStream *pDst) const;</span>
<a href="#l5.97"></a><span id="l5.97" class="difflineplus">+private:</span>
<a href="#l5.98"></a><span id="l5.98" class="difflineplus">+  class CHeaderField {</span>
<a href="#l5.99"></a><span id="l5.99" class="difflineplus">+  public:</span>
<a href="#l5.100"></a><span id="l5.100" class="difflineplus">+    CHeaderField(const wchar_t* begin, int len);</span>
<a href="#l5.101"></a><span id="l5.101" class="difflineplus">+    CHeaderField(const wchar_t* name, const wchar_t* body);</span>
<a href="#l5.102"></a><span id="l5.102" class="difflineplus">+    ~CHeaderField();</span>
<a href="#l5.103"></a><span id="l5.103" class="difflineplus">+    inline bool Valid() const { return m_fname; }</span>
<a href="#l5.104"></a><span id="l5.104" class="difflineplus">+    inline const wchar_t* fname() const { return m_fname; }</span>
<a href="#l5.105"></a><span id="l5.105" class="difflineplus">+    inline const wchar_t* fbody() const { return m_fbody; }</span>
<a href="#l5.106"></a><span id="l5.106" class="difflineplus">+    void set_fbody(const wchar_t* txt);</span>
<a href="#l5.107"></a><span id="l5.107" class="difflineplus">+</span>
<a href="#l5.108"></a><span id="l5.108" class="difflineplus">+    static void UnfoldFoldedSpaces(const wchar_t* body, nsString&amp; dest);</span>
<a href="#l5.109"></a><span id="l5.109" class="difflineplus">+  private:</span>
<a href="#l5.110"></a><span id="l5.110" class="difflineplus">+    wchar_t* m_fname;</span>
<a href="#l5.111"></a><span id="l5.111" class="difflineplus">+    wchar_t* m_fbody;</span>
<a href="#l5.112"></a><span id="l5.112" class="difflineplus">+  }; //class HeaderField</span>
<a href="#l5.113"></a><span id="l5.113" class="difflineplus">+</span>
<a href="#l5.114"></a><span id="l5.114" class="difflineplus">+  class write_to_stream {</span>
<a href="#l5.115"></a><span id="l5.115" class="difflineplus">+  public:</span>
<a href="#l5.116"></a><span id="l5.116" class="difflineplus">+    write_to_stream(nsIOutputStream *pDst) : m_pDst(pDst), m_rv(NS_OK) {}</span>
<a href="#l5.117"></a><span id="l5.117" class="difflineplus">+    void operator () (const CHeaderField* f);</span>
<a href="#l5.118"></a><span id="l5.118" class="difflineplus">+    inline operator nsresult() const { return m_rv; }</span>
<a href="#l5.119"></a><span id="l5.119" class="difflineplus">+  private:</span>
<a href="#l5.120"></a><span id="l5.120" class="difflineplus">+    nsIOutputStream *m_pDst;</span>
<a href="#l5.121"></a><span id="l5.121" class="difflineplus">+    nsresult m_rv;</span>
<a href="#l5.122"></a><span id="l5.122" class="difflineplus">+  };</span>
<a href="#l5.123"></a><span id="l5.123" class="difflineplus">+</span>
<a href="#l5.124"></a><span id="l5.124" class="difflineplus">+  // Search helper</span>
<a href="#l5.125"></a><span id="l5.125" class="difflineplus">+  class fname_equals {</span>
<a href="#l5.126"></a><span id="l5.126" class="difflineplus">+  public:</span>
<a href="#l5.127"></a><span id="l5.127" class="difflineplus">+    fname_equals(const wchar_t* search) : m_search(search) {}</span>
<a href="#l5.128"></a><span id="l5.128" class="difflineplus">+    inline bool operator () (const CHeaderField* f) const { return wcsicmp(f-&gt;fname(), m_search) == 0; }</span>
<a href="#l5.129"></a><span id="l5.129" class="difflineplus">+  private:</span>
<a href="#l5.130"></a><span id="l5.130" class="difflineplus">+    const wchar_t* m_search;</span>
<a href="#l5.131"></a><span id="l5.131" class="difflineplus">+  }; // class fname_equals</span>
<a href="#l5.132"></a><span id="l5.132" class="difflineplus">+</span>
<a href="#l5.133"></a><span id="l5.133" class="difflineplus">+  // The common array of special headers' names</span>
<a href="#l5.134"></a><span id="l5.134" class="difflineplus">+  static const wchar_t* Specials[hdrMax];</span>
<a href="#l5.135"></a><span id="l5.135" class="difflineplus">+  </span>
<a href="#l5.136"></a><span id="l5.136" class="difflineplus">+  std::vector&lt;CHeaderField*&gt; m_headerFields;</span>
<a href="#l5.137"></a><span id="l5.137" class="difflineplus">+  CHeaderField* m_SpecialHeaders[hdrMax]; // Pointers into the m_headerFields</span>
<a href="#l5.138"></a><span id="l5.138" class="difflineplus">+</span>
<a href="#l5.139"></a><span id="l5.139" class="difflineplus">+  void ClearHeaderFields();</span>
<a href="#l5.140"></a><span id="l5.140" class="difflineplus">+  void Add(CHeaderField* f);</span>
<a href="#l5.141"></a><span id="l5.141" class="difflineplus">+  SpecialHeader CheckSpecialHeader(const wchar_t* fname) const;</span>
<a href="#l5.142"></a><span id="l5.142" class="difflineplus">+  const CHeaderField* CFind(const wchar_t* name) const;</span>
<a href="#l5.143"></a><span id="l5.143" class="difflineplus">+  inline CHeaderField* Find(const wchar_t* name) { return const_cast&lt;CHeaderField*&gt;(CFind(name)); }</span>
<a href="#l5.144"></a><span id="l5.144" class="difflineplus">+</span>
<a href="#l5.145"></a><span id="l5.145" class="difflineplus">+}; // class CMapiMessageHeaders</span>
<a href="#l5.146"></a><span id="l5.146" class="difflineplus">+</span>
<a href="#l5.147"></a><span id="l5.147" class="difflineplus">+//////////////////////////////////////////////////////</span>
<a href="#l5.148"></a><span id="l5.148"> </span>
<a href="#l5.149"></a><span id="l5.149"> class CMapiMessage {</span>
<a href="#l5.150"></a><span id="l5.150"> public:</span>
<a href="#l5.151"></a><span id="l5.151">   CMapiMessage( LPMESSAGE  lpMsg);</span>
<a href="#l5.152"></a><span id="l5.152">   ~CMapiMessage();</span>
<a href="#l5.153"></a><span id="l5.153"> </span>
<a href="#l5.154"></a><span id="l5.154" class="difflineplus">+  // Attachments</span>
<a href="#l5.155"></a><span id="l5.155" class="difflineplus">+  // Ordinary (not embedded) attachments; result MUST be disposed of with DisposeAttachments()</span>
<a href="#l5.156"></a><span id="l5.156" class="difflineplus">+  nsMsgAttachedFile* GetAttachments();</span>
<a href="#l5.157"></a><span id="l5.157" class="difflineplus">+  static void DisposeAttachments(nsMsgAttachedFile* att) { delete[] att; }</span>
<a href="#l5.158"></a><span id="l5.158" class="difflineplus">+  // Embedded attachments</span>
<a href="#l5.159"></a><span id="l5.159" class="difflineplus">+  size_t EmbeddedAttachmentsCount() const { return m_embattachments.size(); }</span>
<a href="#l5.160"></a><span id="l5.160" class="difflineplus">+  bool GetEmbeddedAttachmentInfo(unsigned int i, nsIURI **uri, const char **cid,</span>
<a href="#l5.161"></a><span id="l5.161" class="difflineplus">+                                 const char **name) const;</span>
<a href="#l5.162"></a><span id="l5.162" class="difflineplus">+  // We don't check MSGFLAG_HASATTACH, since it returns true even if there are</span>
<a href="#l5.163"></a><span id="l5.163" class="difflineplus">+  // only embedded attachmentsin the message. TB only counts the ordinary</span>
<a href="#l5.164"></a><span id="l5.164" class="difflineplus">+  // attachments when shows the message status, so here we check only for the</span>
<a href="#l5.165"></a><span id="l5.165" class="difflineplus">+  // ordinary attachments.</span>
<a href="#l5.166"></a><span id="l5.166" class="difflineplus">+  inline bool HasAttach() const { return !m_stdattachments.empty(); }</span>
<a href="#l5.167"></a><span id="l5.167" class="difflineplus">+</span>
<a href="#l5.168"></a><span id="l5.168" class="difflineplus">+  // Retrieve info for message</span>
<a href="#l5.169"></a><span id="l5.169" class="difflineplus">+  inline bool BodyIsHtml( void) const { return( m_bodyIsHtml);}</span>
<a href="#l5.170"></a><span id="l5.170" class="difflineplus">+  const char *GetFromLine(int&amp; len) const {</span>
<a href="#l5.171"></a><span id="l5.171" class="difflineplus">+    if (m_fromLine.IsEmpty())</span>
<a href="#l5.172"></a><span id="l5.172" class="difflineplus">+      return NULL; </span>
<a href="#l5.173"></a><span id="l5.173" class="difflineplus">+    else {</span>
<a href="#l5.174"></a><span id="l5.174" class="difflineplus">+      len = m_fromLine.Length();</span>
<a href="#l5.175"></a><span id="l5.175" class="difflineplus">+      return( m_fromLine.get());}</span>
<a href="#l5.176"></a><span id="l5.176" class="difflineplus">+  }</span>
<a href="#l5.177"></a><span id="l5.177" class="difflineplus">+  inline CMapiMessageHeaders *GetHeaders() { return &amp;m_headers; }</span>
<a href="#l5.178"></a><span id="l5.178" class="difflineplus">+  inline const wchar_t *GetBody( void) const { return( m_body.get()); }</span>
<a href="#l5.179"></a><span id="l5.179" class="difflineplus">+  inline size_t GetBodyLen( void) const { return( m_body.Length()); }</span>
<a href="#l5.180"></a><span id="l5.180" class="difflineplus">+  void GetBody(nsCString&amp; dest) const;</span>
<a href="#l5.181"></a><span id="l5.181" class="difflineplus">+  inline const char *GetBodyCharset( void) const { return( m_mimeCharset.get());}</span>
<a href="#l5.182"></a><span id="l5.182" class="difflineplus">+  inline bool IsRead() const { return m_msgFlags &amp; MSGFLAG_READ; }</span>
<a href="#l5.183"></a><span id="l5.183" class="difflineplus">+  inline bool IsReplied() const {</span>
<a href="#l5.184"></a><span id="l5.184" class="difflineplus">+    return (m_msgLastVerb == EXCHIVERB_REPLYTOSENDER) ||</span>
<a href="#l5.185"></a><span id="l5.185" class="difflineplus">+           (m_msgLastVerb == EXCHIVERB_REPLYTOALL); }</span>
<a href="#l5.186"></a><span id="l5.186" class="difflineplus">+  inline bool IsForvarded() const {</span>
<a href="#l5.187"></a><span id="l5.187" class="difflineplus">+    return m_msgLastVerb == EXCHIVERB_FORWARD; }</span>
<a href="#l5.188"></a><span id="l5.188" class="difflineplus">+</span>
<a href="#l5.189"></a><span id="l5.189" class="difflineplus">+  bool    IsMultipart( void) const;</span>
<a href="#l5.190"></a><span id="l5.190" class="difflineplus">+  bool    HasContentHeader( void) const {</span>
<a href="#l5.191"></a><span id="l5.191" class="difflineplus">+    return( !m_mimeContentType.IsEmpty());}</span>
<a href="#l5.192"></a><span id="l5.192" class="difflineplus">+  bool    HasMimeVersion( void) const {</span>
<a href="#l5.193"></a><span id="l5.193" class="difflineplus">+    return m_headers.Value(CMapiMessageHeaders::hdrMimeVersion); }</span>
<a href="#l5.194"></a><span id="l5.194" class="difflineplus">+  const char *GetMimeContent( void) const { return( m_mimeContentType.get());}</span>
<a href="#l5.195"></a><span id="l5.195" class="difflineplus">+  PRInt32     GetMimeContentLen( void) const { return( m_mimeContentType.Length());}</span>
<a href="#l5.196"></a><span id="l5.196" class="difflineplus">+  const char *GetMimeBoundary( void) const { return( m_mimeBoundary.get());}</span>
<a href="#l5.197"></a><span id="l5.197" class="difflineplus">+</span>
<a href="#l5.198"></a><span id="l5.198" class="difflineplus">+   // The only required part of a message is its header</span>
<a href="#l5.199"></a><span id="l5.199" class="difflineplus">+  inline bool ValidState() const { return !m_headers.IsEmpty(); }</span>
<a href="#l5.200"></a><span id="l5.200" class="difflineplus">+  inline bool FullMessageDownloaded() const { return !m_dldStateHeadersOnly; }</span>
<a href="#l5.201"></a><span id="l5.201" class="difflineplus">+</span>
<a href="#l5.202"></a><span id="l5.202" class="difflineplus">+private:</span>
<a href="#l5.203"></a><span id="l5.203" class="difflineplus">+  struct attach_data {</span>
<a href="#l5.204"></a><span id="l5.204" class="difflineplus">+    nsCOMPtr&lt;nsIURI&gt; orig_url;</span>
<a href="#l5.205"></a><span id="l5.205" class="difflineplus">+    nsCOMPtr&lt;nsILocalFile&gt; tmp_file;</span>
<a href="#l5.206"></a><span id="l5.206" class="difflineplus">+    char *type;</span>
<a href="#l5.207"></a><span id="l5.207" class="difflineplus">+    char *encoding;</span>
<a href="#l5.208"></a><span id="l5.208" class="difflineplus">+    char *real_name;</span>
<a href="#l5.209"></a><span id="l5.209" class="difflineplus">+    char *cid;</span>
<a href="#l5.210"></a><span id="l5.210" class="difflineplus">+    bool delete_file;</span>
<a href="#l5.211"></a><span id="l5.211" class="difflineplus">+    attach_data() : type(0), encoding(0), real_name(0), cid(0), delete_file(false) {}</span>
<a href="#l5.212"></a><span id="l5.212" class="difflineplus">+  };</span>
<a href="#l5.213"></a><span id="l5.213" class="difflineplus">+</span>
<a href="#l5.214"></a><span id="l5.214" class="difflineplus">+  static const nsCString    m_whitespace;</span>
<a href="#l5.215"></a><span id="l5.215" class="difflineplus">+</span>
<a href="#l5.216"></a><span id="l5.216" class="difflineplus">+  LPMESSAGE    m_lpMsg;</span>
<a href="#l5.217"></a><span id="l5.217" class="difflineplus">+</span>
<a href="#l5.218"></a><span id="l5.218" class="difflineplus">+  bool         m_dldStateHeadersOnly; // if the message has not been downloaded yet</span>
<a href="#l5.219"></a><span id="l5.219" class="difflineplus">+  CMapiMessageHeaders     m_headers;</span>
<a href="#l5.220"></a><span id="l5.220" class="difflineplus">+  nsCString    m_fromLine; // utf-8</span>
<a href="#l5.221"></a><span id="l5.221" class="difflineplus">+  nsCString    m_mimeContentType; // utf-8</span>
<a href="#l5.222"></a><span id="l5.222" class="difflineplus">+  nsCString    m_mimeBoundary; // utf-8</span>
<a href="#l5.223"></a><span id="l5.223" class="difflineplus">+  nsCString    m_mimeCharset; // utf-8</span>
<a href="#l5.224"></a><span id="l5.224" class="difflineplus">+</span>
<a href="#l5.225"></a><span id="l5.225" class="difflineplus">+  std::vector&lt;attach_data*&gt; m_stdattachments;</span>
<a href="#l5.226"></a><span id="l5.226" class="difflineplus">+  std::vector&lt;attach_data*&gt; m_embattachments; // Embedded</span>
<a href="#l5.227"></a><span id="l5.227" class="difflineplus">+</span>
<a href="#l5.228"></a><span id="l5.228" class="difflineplus">+  nsString     m_body; // to be converted from UTF-16 using m_mimeCharset</span>
<a href="#l5.229"></a><span id="l5.229" class="difflineplus">+  bool         m_bodyIsHtml;</span>
<a href="#l5.230"></a><span id="l5.230" class="difflineplus">+</span>
<a href="#l5.231"></a><span id="l5.231" class="difflineplus">+  PRUint32 m_msgFlags;</span>
<a href="#l5.232"></a><span id="l5.232" class="difflineplus">+  PRUint32 m_msgLastVerb;</span>
<a href="#l5.233"></a><span id="l5.233" class="difflineplus">+  </span>
<a href="#l5.234"></a><span id="l5.234" class="difflineplus">+  nsIIOService *      m_pIOService;</span>
<a href="#l5.235"></a><span id="l5.235" class="difflineplus">+</span>
<a href="#l5.236"></a><span id="l5.236" class="difflineplus">+  void    GetDownloadState();</span>
<a href="#l5.237"></a><span id="l5.237" class="difflineplus">+</span>
<a href="#l5.238"></a><span id="l5.238">   // Headers - fetch will get PR_TRANSPORT_MESSAGE_HEADERS</span>
<a href="#l5.239"></a><span id="l5.239">   // or if they do not exist will build a header from</span>
<a href="#l5.240"></a><span id="l5.240">   //  PR_DISPLAY_TO, _CC, _BCC</span>
<a href="#l5.241"></a><span id="l5.241">   //  PR_SUBJECT</span>
<a href="#l5.242"></a><span id="l5.242">   //  PR_MESSAGE_RECIPIENTS</span>
<a href="#l5.243"></a><span id="l5.243">   // and PR_CREATION_TIME if needed?</span>
<a href="#l5.244"></a><span id="l5.244" class="difflineminus">-  BOOL    FetchHeaders( void);</span>
<a href="#l5.245"></a><span id="l5.245" class="difflineminus">-</span>
<a href="#l5.246"></a><span id="l5.246" class="difflineminus">-  // Do the headers need a From separator line.</span>
<a href="#l5.247"></a><span id="l5.247" class="difflineminus">-  // TRUE if a From line needs to precede the headers, FALSE</span>
<a href="#l5.248"></a><span id="l5.248" class="difflineminus">-  // if the headers already include a from line</span>
<a href="#l5.249"></a><span id="l5.249" class="difflineminus">-  BOOL    NeedsFromLine( void);</span>
<a href="#l5.250"></a><span id="l5.250" class="difflineminus">-</span>
<a href="#l5.251"></a><span id="l5.251" class="difflineminus">-  // Fetch the</span>
<a href="#l5.252"></a><span id="l5.252" class="difflineminus">-  BOOL    FetchBody( void);</span>
<a href="#l5.253"></a><span id="l5.253" class="difflineminus">-</span>
<a href="#l5.254"></a><span id="l5.254" class="difflineminus">-  // Attachments</span>
<a href="#l5.255"></a><span id="l5.255" class="difflineminus">-  int      CountAttachments( void);</span>
<a href="#l5.256"></a><span id="l5.256" class="difflineminus">-  BOOL    GetAttachmentInfo( int idx);</span>
<a href="#l5.257"></a><span id="l5.257" class="difflineplus">+  bool    FetchHeaders( void);</span>
<a href="#l5.258"></a><span id="l5.258" class="difflineplus">+  bool    FetchBody( void);</span>
<a href="#l5.259"></a><span id="l5.259" class="difflineplus">+  void    FetchFlags( void);</span>
<a href="#l5.260"></a><span id="l5.260"> </span>
<a href="#l5.261"></a><span id="l5.261" class="difflineminus">-  // Retrieve info for message</span>
<a href="#l5.262"></a><span id="l5.262" class="difflineminus">-  BOOL    BodyIsHtml( void) { return( m_bodyIsHtml);}</span>
<a href="#l5.263"></a><span id="l5.263" class="difflineminus">-  const char *GetFromLine( int&amp; len) { if (m_fromLine.IsEmpty()) return( NULL); else { len = m_fromLine.Length(); return( m_fromLine.get());}}</span>
<a href="#l5.264"></a><span id="l5.264" class="difflineminus">-  const char *GetHeaders( int&amp; len) { if (m_headers.IsEmpty()) return( NULL); else { len = m_headers.Length(); return( m_headers.get());}}</span>
<a href="#l5.265"></a><span id="l5.265" class="difflineminus">-  const char *GetBody( int&amp; len) { if (m_body.IsEmpty()) return( NULL); else { len = m_body.Length(); return( m_body.get());}}</span>
<a href="#l5.266"></a><span id="l5.266" class="difflineminus">-  const char *GetBody( void) { return( m_body.get());}</span>
<a href="#l5.267"></a><span id="l5.267" class="difflineminus">-  const char *GetHeaders( void) { return( m_headers.get());}</span>
<a href="#l5.268"></a><span id="l5.268" class="difflineminus">-  PRInt32    GetBodyLen( void) { return( m_body.Length());}</span>
<a href="#l5.269"></a><span id="l5.269" class="difflineminus">-  PRInt32    GetHeaderLen( void) { return( m_headers.Length());}</span>
<a href="#l5.270"></a><span id="l5.270" class="difflineminus">-</span>
<a href="#l5.271"></a><span id="l5.271" class="difflineminus">-</span>
<a href="#l5.272"></a><span id="l5.272" class="difflineminus">-  BOOL    IsMultipart( void);</span>
<a href="#l5.273"></a><span id="l5.273" class="difflineminus">-  BOOL    HasContentHeader( void) { return( !m_mimeContentType.IsEmpty());}</span>
<a href="#l5.274"></a><span id="l5.274" class="difflineminus">-  BOOL    HasMimeVersion( void) { return( m_bMimeVersion);}</span>
<a href="#l5.275"></a><span id="l5.275" class="difflineminus">-  const char *GetMimeContent( void) { return( m_mimeContentType.get());}</span>
<a href="#l5.276"></a><span id="l5.276" class="difflineminus">-  PRInt32     GetMimeContentLen( void) { return( m_mimeContentType.Length());}</span>
<a href="#l5.277"></a><span id="l5.277" class="difflineminus">-  const char *GetMimeBoundary( void) { return( m_mimeBoundary.get());}</span>
<a href="#l5.278"></a><span id="l5.278" class="difflineminus">-  void    GenerateBoundary( void);</span>
<a href="#l5.279"></a><span id="l5.279" class="difflineminus">-</span>
<a href="#l5.280"></a><span id="l5.280" class="difflineminus">-  BOOL    GetAttachFileLoc( nsIFile *pLoc);</span>
<a href="#l5.281"></a><span id="l5.281" class="difflineminus">-</span>
<a href="#l5.282"></a><span id="l5.282" class="difflineminus">-  const char *GetMimeType( void) { return( m_attachMimeType.get());}</span>
<a href="#l5.283"></a><span id="l5.283" class="difflineminus">-  const char *GetFileName( void) { return( m_attachFileName.get());}</span>
<a href="#l5.284"></a><span id="l5.284" class="difflineplus">+  static bool GetTmpFile(/*out*/ nsILocalFile **aResult);</span>
<a href="#l5.285"></a><span id="l5.285" class="difflineplus">+  static bool CopyMsgAttachToFile(LPATTACH lpAttach, /*out*/ nsILocalFile **tmp_file);</span>
<a href="#l5.286"></a><span id="l5.286" class="difflineplus">+  static bool CopyBinAttachToFile( LPATTACH lpAttach, nsILocalFile **tmp_file);</span>
<a href="#l5.287"></a><span id="l5.287"> </span>
<a href="#l5.288"></a><span id="l5.288" class="difflineminus">-protected:</span>
<a href="#l5.289"></a><span id="l5.289" class="difflineminus">-  BOOL    IterateAttachTable( void);</span>
<a href="#l5.290"></a><span id="l5.290" class="difflineminus">-  void    ClearTempAttachFile( void);</span>
<a href="#l5.291"></a><span id="l5.291" class="difflineminus">-  BOOL    CopyBinAttachToFile( LPATTACH lpAttach);</span>
<a href="#l5.292"></a><span id="l5.292" class="difflineminus">-</span>
<a href="#l5.293"></a><span id="l5.293" class="difflineminus">-  void    ProcessHeaderLine( nsCString&amp; line);</span>
<a href="#l5.294"></a><span id="l5.294" class="difflineminus">-  void    ProcessHeaders( void);</span>
<a href="#l5.295"></a><span id="l5.295" class="difflineminus">-  void    FormatDateTime( SYSTEMTIME &amp; tm, nsCString&amp; s, BOOL includeTZ = TRUE);</span>
<a href="#l5.296"></a><span id="l5.296" class="difflineminus">-  void    BuildHeaders( void);</span>
<a href="#l5.297"></a><span id="l5.297" class="difflineminus">-  void    BuildFromLine( void);</span>
<a href="#l5.298"></a><span id="l5.298" class="difflineminus">-  void    AddSubject( nsCString&amp; str);</span>
<a href="#l5.299"></a><span id="l5.299" class="difflineminus">-  void    AddFrom( nsCString&amp; str);</span>
<a href="#l5.300"></a><span id="l5.300" class="difflineminus">-  BOOL    AddHeader( nsCString&amp; str, ULONG tag, const char *pPrefix);</span>
<a href="#l5.301"></a><span id="l5.301" class="difflineminus">-  void    AddDate( nsCString&amp; str);</span>
<a href="#l5.302"></a><span id="l5.302" class="difflineminus">-</span>
<a href="#l5.303"></a><span id="l5.303" class="difflineminus">-  BOOL    IsSpace( char c) { return( m_whitespace.FindChar( c) != -1);}</span>
<a href="#l5.304"></a><span id="l5.304" class="difflineplus">+  static void ClearAttachment(attach_data* data);</span>
<a href="#l5.305"></a><span id="l5.305" class="difflineplus">+  void    ClearAttachments();</span>
<a href="#l5.306"></a><span id="l5.306" class="difflineplus">+  bool    AddAttachment(DWORD aNum);</span>
<a href="#l5.307"></a><span id="l5.307" class="difflineplus">+  bool    IterateAttachTable(LPMAPITABLE tbl);</span>
<a href="#l5.308"></a><span id="l5.308" class="difflineplus">+  bool    GetURL(nsIFile *aFile, nsIURI **url);</span>
<a href="#l5.309"></a><span id="l5.309" class="difflineplus">+  void    ProcessAttachments();</span>
<a href="#l5.310"></a><span id="l5.310"> </span>
<a href="#l5.311"></a><span id="l5.311" class="difflineminus">-private:</span>
<a href="#l5.312"></a><span id="l5.312" class="difflineminus">-  LPMESSAGE    m_lpMsg;</span>
<a href="#l5.313"></a><span id="l5.313" class="difflineminus">-  LPMAPITABLE    m_pAttachTable;</span>
<a href="#l5.314"></a><span id="l5.314" class="difflineminus">-  nsCString    m_headers;</span>
<a href="#l5.315"></a><span id="l5.315" class="difflineminus">-  nsCString    m_fromLine;</span>
<a href="#l5.316"></a><span id="l5.316" class="difflineminus">-  nsCString    m_body;</span>
<a href="#l5.317"></a><span id="l5.317" class="difflineminus">-  nsCString    m_mimeContentType;</span>
<a href="#l5.318"></a><span id="l5.318" class="difflineminus">-  nsCString    m_mimeBoundary;</span>
<a href="#l5.319"></a><span id="l5.319" class="difflineminus">-  nsCString    m_mimeCharset;</span>
<a href="#l5.320"></a><span id="l5.320" class="difflineminus">-  BOOL      m_bMimeVersion;</span>
<a href="#l5.321"></a><span id="l5.321" class="difflineminus">-  BOOL      m_bMimeEncoding;</span>
<a href="#l5.322"></a><span id="l5.322" class="difflineminus">-  nsTArray&lt;DWORD&gt;  m_attachNums;</span>
<a href="#l5.323"></a><span id="l5.323" class="difflineminus">-  nsCString    m_attachMimeType;</span>
<a href="#l5.324"></a><span id="l5.324" class="difflineminus">-  nsCString    m_attachPath;</span>
<a href="#l5.325"></a><span id="l5.325" class="difflineminus">-  nsCString    m_attachFileName;</span>
<a href="#l5.326"></a><span id="l5.326" class="difflineminus">-  BOOL      m_ownsAttachFile;</span>
<a href="#l5.327"></a><span id="l5.327" class="difflineminus">-  BOOL      m_bodyIsHtml;</span>
<a href="#l5.328"></a><span id="l5.328" class="difflineminus">-  BOOL      m_bHasSubject;</span>
<a href="#l5.329"></a><span id="l5.329" class="difflineminus">-  BOOL      m_bHasFrom;</span>
<a href="#l5.330"></a><span id="l5.330" class="difflineminus">-  BOOL      m_bHasDate;</span>
<a href="#l5.331"></a><span id="l5.331" class="difflineminus">-  nsCString    m_whitespace;</span>
<a href="#l5.332"></a><span id="l5.332" class="difflineplus">+  bool    EnsureHeader(CMapiMessageHeaders::SpecialHeader special, ULONG mapiTag);</span>
<a href="#l5.333"></a><span id="l5.333" class="difflineplus">+  bool    EnsureDate();</span>
<a href="#l5.334"></a><span id="l5.334" class="difflineplus">+</span>
<a href="#l5.335"></a><span id="l5.335" class="difflineplus">+  void    ProcessContentType();</span>
<a href="#l5.336"></a><span id="l5.336" class="difflineplus">+  bool    CheckBodyInCharsetRange(const char* charset);</span>
<a href="#l5.337"></a><span id="l5.337" class="difflineplus">+  void    FormatDateTime( SYSTEMTIME &amp; tm, nsString&amp; s, bool includeTZ = true);</span>
<a href="#l5.338"></a><span id="l5.338" class="difflineplus">+  void    BuildFromLine( void);</span>
<a href="#l5.339"></a><span id="l5.339" class="difflineplus">+</span>
<a href="#l5.340"></a><span id="l5.340" class="difflineplus">+  inline static bool IsSpace( char c) { return( m_whitespace.FindChar( c) != -1);}</span>
<a href="#l5.341"></a><span id="l5.341" class="difflineplus">+  inline static bool IsSpace( wchar_t c) { </span>
<a href="#l5.342"></a><span id="l5.342" class="difflineplus">+    return ((c &amp; 0xFF) == c) &amp;&amp; IsSpace(static_cast&lt;char&gt;(c)); } // Avoid false detections</span>
<a href="#l5.343"></a><span id="l5.343"> };</span>
<a href="#l5.344"></a><span id="l5.344"> </span>
<a href="#l5.345"></a><span id="l5.345" class="difflineminus">-</span>
<a href="#l5.346"></a><span id="l5.346" class="difflineminus">-</span>
<a href="#l5.347"></a><span id="l5.347" class="difflineminus">-</span>
<a href="#l5.348"></a><span id="l5.348"> #endif /* MapiMessage_h__ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/import/outlook/src/MapiMimeTypes.cpp</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/import/outlook/src/MapiMimeTypes.cpp</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -82,17 +82,24 @@ BOOL CMimeTypes::GetMimeTypeFromReg( con</span>
<a href="#l6.4"></a><span id="l6.4">   if (GetKey( HKEY_CLASSES_ROOT, ext.get(), &amp;extensionKey)) {</span>
<a href="#l6.5"></a><span id="l6.5">     result = GetValueBytes( extensionKey, &quot;Content Type&quot;, ppBytes);</span>
<a href="#l6.6"></a><span id="l6.6">     RegCloseKey( extensionKey);</span>
<a href="#l6.7"></a><span id="l6.7">   }</span>
<a href="#l6.8"></a><span id="l6.8"> </span>
<a href="#l6.9"></a><span id="l6.9">   return( result);</span>
<a href="#l6.10"></a><span id="l6.10"> }</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-PRUint8 * CMimeTypes::GetMimeType( nsCString&amp; theExt)</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+PRUint8 * CMimeTypes::GetMimeType(const nsString&amp; theExt)</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+{</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+  nsCString ext;</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+  LossyCopyUTF16toASCII(theExt, ext);</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineplus">+  return GetMimeType(ext);</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+}</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineplus">+PRUint8 * CMimeTypes::GetMimeType(const nsCString&amp; theExt)</span>
<a href="#l6.21"></a><span id="l6.21"> {</span>
<a href="#l6.22"></a><span id="l6.22">   nsCString  ext = theExt;</span>
<a href="#l6.23"></a><span id="l6.23">   if (ext.Length()) {</span>
<a href="#l6.24"></a><span id="l6.24">     if (ext.First() != '.') {</span>
<a href="#l6.25"></a><span id="l6.25">       ext = &quot;.&quot;;</span>
<a href="#l6.26"></a><span id="l6.26">       ext += theExt;</span>
<a href="#l6.27"></a><span id="l6.27">     }</span>
<a href="#l6.28"></a><span id="l6.28">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/import/outlook/src/MapiMimeTypes.h</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/import/outlook/src/MapiMimeTypes.h</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -40,17 +40,18 @@</span>
<a href="#l7.4"></a><span id="l7.4"> </span>
<a href="#l7.5"></a><span id="l7.5"> #include &lt;windows.h&gt;</span>
<a href="#l7.6"></a><span id="l7.6"> </span>
<a href="#l7.7"></a><span id="l7.7"> #define kMaxMimeTypeSize  256</span>
<a href="#l7.8"></a><span id="l7.8"> </span>
<a href="#l7.9"></a><span id="l7.9"> class CMimeTypes {</span>
<a href="#l7.10"></a><span id="l7.10"> public:</span>
<a href="#l7.11"></a><span id="l7.11"> </span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-static PRUint8 *  GetMimeType( nsCString&amp; theExt);</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+static PRUint8 *  GetMimeType(const nsCString&amp; theExt);</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+static PRUint8 *  GetMimeType(const nsString&amp; theExt);</span>
<a href="#l7.15"></a><span id="l7.15"> </span>
<a href="#l7.16"></a><span id="l7.16"> protected:</span>
<a href="#l7.17"></a><span id="l7.17">   // Registry stuff</span>
<a href="#l7.18"></a><span id="l7.18"> static BOOL  GetKey( HKEY root, LPCTSTR pName, PHKEY pKey);</span>
<a href="#l7.19"></a><span id="l7.19"> static BOOL  GetValueBytes( HKEY rootKey, LPCTSTR pValName, LPBYTE *ppBytes);</span>
<a href="#l7.20"></a><span id="l7.20"> static void  ReleaseValueBytes( LPBYTE pBytes);</span>
<a href="#l7.21"></a><span id="l7.21"> static BOOL  GetMimeTypeFromReg( const nsCString&amp; ext, LPBYTE *ppBytes);</span>
<a href="#l7.22"></a><span id="l7.22"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/import/outlook/src/nsOutlookCompose.cpp</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/import/outlook/src/nsOutlookCompose.cpp</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -47,44 +47,49 @@</span>
<a href="#l8.4"></a><span id="l8.4"> #include &quot;nsIServiceManager.h&quot;</span>
<a href="#l8.5"></a><span id="l8.5"> #include &quot;nsIIOService.h&quot;</span>
<a href="#l8.6"></a><span id="l8.6"> #include &quot;nsIURI.h&quot;</span>
<a href="#l8.7"></a><span id="l8.7"> #include &quot;nsIProxyObjectManager.h&quot;</span>
<a href="#l8.8"></a><span id="l8.8"> #include &quot;nsProxiedService.h&quot;</span>
<a href="#l8.9"></a><span id="l8.9"> #include &quot;nsMsgI18N.h&quot;</span>
<a href="#l8.10"></a><span id="l8.10"> #include &quot;nsNativeCharsetUtils.h&quot;</span>
<a href="#l8.11"></a><span id="l8.11"> #include &quot;nsIOutputStream.h&quot;</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-#include &quot;nsNetUtil.h&quot;</span>
<a href="#l8.13"></a><span id="l8.13"> </span>
<a href="#l8.14"></a><span id="l8.14"> #include &quot;nsMsgBaseCID.h&quot;</span>
<a href="#l8.15"></a><span id="l8.15"> #include &quot;nsMsgCompCID.h&quot;</span>
<a href="#l8.16"></a><span id="l8.16"> </span>
<a href="#l8.17"></a><span id="l8.17"> #include &quot;nsIMsgCompose.h&quot;</span>
<a href="#l8.18"></a><span id="l8.18"> #include &quot;nsIMsgCompFields.h&quot;</span>
<a href="#l8.19"></a><span id="l8.19" class="difflineminus">-#include &quot;nsIMsgSend.h&quot;</span>
<a href="#l8.20"></a><span id="l8.20"> #include &quot;nsIMsgAccountManager.h&quot;</span>
<a href="#l8.21"></a><span id="l8.21"> </span>
<a href="#l8.22"></a><span id="l8.22"> #include &quot;nsNetCID.h&quot;</span>
<a href="#l8.23"></a><span id="l8.23"> </span>
<a href="#l8.24"></a><span id="l8.24"> #include &quot;nsOutlookCompose.h&quot;</span>
<a href="#l8.25"></a><span id="l8.25"> </span>
<a href="#l8.26"></a><span id="l8.26"> #include &quot;OutlookDebugLog.h&quot;</span>
<a href="#l8.27"></a><span id="l8.27"> </span>
<a href="#l8.28"></a><span id="l8.28"> #include &quot;nsMimeTypes.h&quot;</span>
<a href="#l8.29"></a><span id="l8.29"> #include &quot;nsMsgUtils.h&quot;</span>
<a href="#l8.30"></a><span id="l8.30"> </span>
<a href="#l8.31"></a><span id="l8.31" class="difflineplus">+#include &quot;nsOutlookEditor.h&quot;</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+#include &quot;nsAutoPtr.h&quot;</span>
<a href="#l8.33"></a><span id="l8.33" class="difflineplus">+</span>
<a href="#l8.34"></a><span id="l8.34" class="difflineplus">+#include &quot;nsMsgMessageFlags.h&quot;</span>
<a href="#l8.35"></a><span id="l8.35" class="difflineplus">+#include &quot;nsMsgLocalFolderHdrs.h&quot;</span>
<a href="#l8.36"></a><span id="l8.36" class="difflineplus">+</span>
<a href="#l8.37"></a><span id="l8.37" class="difflineplus">+#include &lt;algorithm&gt;</span>
<a href="#l8.38"></a><span id="l8.38" class="difflineplus">+</span>
<a href="#l8.39"></a><span id="l8.39"> static NS_DEFINE_CID( kMsgSendCID, NS_MSGSEND_CID);</span>
<a href="#l8.40"></a><span id="l8.40"> static NS_DEFINE_CID( kMsgCompFieldsCID, NS_MSGCOMPFIELDS_CID);</span>
<a href="#l8.41"></a><span id="l8.41"> </span>
<a href="#l8.42"></a><span id="l8.42"> // We need to do some calculations to set these numbers to something reasonable!</span>
<a href="#l8.43"></a><span id="l8.43"> // Unless of course, CreateAndSendMessage will NEVER EVER leave us in the lurch</span>
<a href="#l8.44"></a><span id="l8.44"> #define kHungCount 100000</span>
<a href="#l8.45"></a><span id="l8.45"> #define kHungAbortCount 1000</span>
<a href="#l8.46"></a><span id="l8.46"> </span>
<a href="#l8.47"></a><span id="l8.47" class="difflineminus">-</span>
<a href="#l8.48"></a><span id="l8.48"> #ifdef IMPORT_DEBUG</span>
<a href="#l8.49"></a><span id="l8.49"> static const char *p_test_headers =</span>
<a href="#l8.50"></a><span id="l8.50"> &quot;Received: from netppl.fi (IDENT:monitor@get.freebsd.because.microsoftsucks.net [209.3.31.115])\n\</span>
<a href="#l8.51"></a><span id="l8.51">  by mail4.sirius.com (8.9.1/8.9.1) with SMTP id PAA27232;\n\</span>
<a href="#l8.52"></a><span id="l8.52">  Mon, 17 May 1999 15:27:43 -0700 (PDT)\n\</span>
<a href="#l8.53"></a><span id="l8.53"> Message-ID: &lt;ikGD3jRTsKklU.Ggm2HmE2A1Jsqd0p@netppl.fi&gt;\n\</span>
<a href="#l8.54"></a><span id="l8.54"> From: \&quot;adsales@qualityservice.com\&quot; &lt;adsales@qualityservice.com&gt;\n\</span>
<a href="#l8.55"></a><span id="l8.55"> Subject: Re: Your College Diploma (36822)\n\</span>
<a href="#l8.56"></a><span id="l8.56" class="difflineat">@@ -98,19 +103,52 @@ Status: RO&quot;;</span>
<a href="#l8.57"></a><span id="l8.57"> static const char *p_test_body =</span>
<a href="#l8.58"></a><span id="l8.58"> &quot;Hello world?\n\</span>
<a href="#l8.59"></a><span id="l8.59"> &quot;;</span>
<a href="#l8.60"></a><span id="l8.60"> #else</span>
<a href="#l8.61"></a><span id="l8.61"> #define p_test_headers nsnull</span>
<a href="#l8.62"></a><span id="l8.62"> #define p_test_body nsnull</span>
<a href="#l8.63"></a><span id="l8.63"> #endif</span>
<a href="#l8.64"></a><span id="l8.64"> </span>
<a href="#l8.65"></a><span id="l8.65" class="difflineminus">-</span>
<a href="#l8.66"></a><span id="l8.66"> #define kWhitespace &quot;\b\t\r\n &quot;</span>
<a href="#l8.67"></a><span id="l8.67"> </span>
<a href="#l8.68"></a><span id="l8.68" class="difflineplus">+//////////////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l8.69"></a><span id="l8.69" class="difflineplus">+</span>
<a href="#l8.70"></a><span id="l8.70" class="difflineplus">+// A replacement for SimpleBufferTonyRCopiedTwice round-robin buffer and ReadFileState classes</span>
<a href="#l8.71"></a><span id="l8.71" class="difflineplus">+class CCompositionFile {</span>
<a href="#l8.72"></a><span id="l8.72" class="difflineplus">+public:</span>
<a href="#l8.73"></a><span id="l8.73" class="difflineplus">+  // fifoBuffer is used for memory allocation optimization</span>
<a href="#l8.74"></a><span id="l8.74" class="difflineplus">+  // convertCRs controls if we want to convert standalone CRs to CRLFs</span>
<a href="#l8.75"></a><span id="l8.75" class="difflineplus">+  CCompositionFile(nsIFile* aFile, void* fifoBuffer, PRUint32 fifoBufferSize, bool convertCRs=false);</span>
<a href="#l8.76"></a><span id="l8.76" class="difflineplus">+</span>
<a href="#l8.77"></a><span id="l8.77" class="difflineplus">+  operator bool() const { return m_fileSize; }</span>
<a href="#l8.78"></a><span id="l8.78" class="difflineplus">+</span>
<a href="#l8.79"></a><span id="l8.79" class="difflineplus">+  // Reads up to and including the term sequence, or entire file if term isn't found</span>
<a href="#l8.80"></a><span id="l8.80" class="difflineplus">+  // termSize may be used to include NULLs in the terminator sequences.</span>
<a href="#l8.81"></a><span id="l8.81" class="difflineplus">+  // termSize value of -1 means &quot;zero-terminated string&quot; -&gt; size is calculated with strlen</span>
<a href="#l8.82"></a><span id="l8.82" class="difflineplus">+  nsresult ToString(nsCString&amp; dest, const char* term=0, int termSize=-1);</span>
<a href="#l8.83"></a><span id="l8.83" class="difflineplus">+  nsresult ToStream(nsIOutputStream *dest, const char* term=0, int termSize=-1);</span>
<a href="#l8.84"></a><span id="l8.84" class="difflineplus">+  char LastChar() { return m_lastChar; }</span>
<a href="#l8.85"></a><span id="l8.85" class="difflineplus">+private:</span>
<a href="#l8.86"></a><span id="l8.86" class="difflineplus">+  nsCOMPtr&lt;nsIFile&gt;  m_pFile;</span>
<a href="#l8.87"></a><span id="l8.87" class="difflineplus">+  nsCOMPtr&lt;nsIInputStream&gt; m_pInputStream;</span>
<a href="#l8.88"></a><span id="l8.88" class="difflineplus">+  PRInt64 m_fileSize;</span>
<a href="#l8.89"></a><span id="l8.89" class="difflineplus">+  PRInt64 m_fileReadPos;</span>
<a href="#l8.90"></a><span id="l8.90" class="difflineplus">+  char* m_fifoBuffer;</span>
<a href="#l8.91"></a><span id="l8.91" class="difflineplus">+  PRUint32 m_fifoBufferSize;</span>
<a href="#l8.92"></a><span id="l8.92" class="difflineplus">+  char* m_fifoBufferReadPos; // next character to read</span>
<a href="#l8.93"></a><span id="l8.93" class="difflineplus">+  char* m_fifoBufferWrittenPos; // if we have read less than buffer size then this will show it</span>
<a href="#l8.94"></a><span id="l8.94" class="difflineplus">+  bool m_convertCRs;</span>
<a href="#l8.95"></a><span id="l8.95" class="difflineplus">+  char m_lastChar;</span>
<a href="#l8.96"></a><span id="l8.96" class="difflineplus">+</span>
<a href="#l8.97"></a><span id="l8.97" class="difflineplus">+  nsresult EnsureHasDataInBuffer();</span>
<a href="#l8.98"></a><span id="l8.98" class="difflineplus">+  template &lt;class _OutFn&gt; nsresult ToDest(_OutFn dest, const char* term, int termSize);</span>
<a href="#l8.99"></a><span id="l8.99" class="difflineplus">+};</span>
<a href="#l8.100"></a><span id="l8.100" class="difflineplus">+</span>
<a href="#l8.101"></a><span id="l8.101" class="difflineplus">+//////////////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l8.102"></a><span id="l8.102"> </span>
<a href="#l8.103"></a><span id="l8.103"> // First off, a listener</span>
<a href="#l8.104"></a><span id="l8.104"> class OutlookSendListener : public nsIMsgSendListener</span>
<a href="#l8.105"></a><span id="l8.105"> {</span>
<a href="#l8.106"></a><span id="l8.106"> public:</span>
<a href="#l8.107"></a><span id="l8.107">   OutlookSendListener() {</span>
<a href="#l8.108"></a><span id="l8.108">     m_done = PR_FALSE;</span>
<a href="#l8.109"></a><span id="l8.109">     m_location = nsnull;</span>
<a href="#l8.110"></a><span id="l8.110" class="difflineat">@@ -129,979 +167,759 @@ public:</span>
<a href="#l8.111"></a><span id="l8.111"> </span>
<a href="#l8.112"></a><span id="l8.112">   /* void OnStatus (in string aMsgID, in wstring aMsg); */</span>
<a href="#l8.113"></a><span id="l8.113">   NS_IMETHOD OnStatus(const char *aMsgID, const PRUnichar *aMsg) {return NS_OK;}</span>
<a href="#l8.114"></a><span id="l8.114"> </span>
<a href="#l8.115"></a><span id="l8.115">   /* void OnStopSending (in string aMsgID, in nsresult aStatus, in wstring aMsg, in nsIFile returnFile); */</span>
<a href="#l8.116"></a><span id="l8.116">   NS_IMETHOD OnStopSending(const char *aMsgID, nsresult aStatus, const PRUnichar *aMsg,</span>
<a href="#l8.117"></a><span id="l8.117">                nsIFile *returnFile) {</span>
<a href="#l8.118"></a><span id="l8.118">     m_done = PR_TRUE;</span>
<a href="#l8.119"></a><span id="l8.119" class="difflineminus">-    m_location = returnFile;</span>
<a href="#l8.120"></a><span id="l8.120" class="difflineminus">-    NS_IF_ADDREF( m_location);</span>
<a href="#l8.121"></a><span id="l8.121" class="difflineplus">+    NS_IF_ADDREF(m_location = returnFile);</span>
<a href="#l8.122"></a><span id="l8.122">     return NS_OK;</span>
<a href="#l8.123"></a><span id="l8.123">   }</span>
<a href="#l8.124"></a><span id="l8.124"> </span>
<a href="#l8.125"></a><span id="l8.125">    /* void OnSendNotPerformed */</span>
<a href="#l8.126"></a><span id="l8.126">    NS_IMETHOD OnSendNotPerformed(const char *aMsgID, nsresult aStatus) {return NS_OK;}</span>
<a href="#l8.127"></a><span id="l8.127"> </span>
<a href="#l8.128"></a><span id="l8.128">   /* void OnGetDraftFolderURI (); */</span>
<a href="#l8.129"></a><span id="l8.129">   NS_IMETHOD OnGetDraftFolderURI(const char *aFolderURI) {return NS_OK;}</span>
<a href="#l8.130"></a><span id="l8.130"> </span>
<a href="#l8.131"></a><span id="l8.131">   static nsresult CreateSendListener( nsIMsgSendListener **ppListener);</span>
<a href="#l8.132"></a><span id="l8.132" class="difflineminus">-  void Reset() { m_done = PR_FALSE; NS_IF_RELEASE( m_location); m_location = nsnull;}</span>
<a href="#l8.133"></a><span id="l8.133" class="difflineplus">+  void Reset() { m_done = PR_FALSE; NS_IF_RELEASE( m_location);}</span>
<a href="#l8.134"></a><span id="l8.134"> </span>
<a href="#l8.135"></a><span id="l8.135"> public:</span>
<a href="#l8.136"></a><span id="l8.136">   PRBool m_done;</span>
<a href="#l8.137"></a><span id="l8.137">   nsIFile * m_location;</span>
<a href="#l8.138"></a><span id="l8.138"> };</span>
<a href="#l8.139"></a><span id="l8.139"> </span>
<a href="#l8.140"></a><span id="l8.140" class="difflineminus">-</span>
<a href="#l8.141"></a><span id="l8.141" class="difflineminus">-NS_IMPL_THREADSAFE_ISUPPORTS1( OutlookSendListener, nsIMsgSendListener)</span>
<a href="#l8.142"></a><span id="l8.142" class="difflineplus">+NS_IMPL_THREADSAFE_ISUPPORTS1(OutlookSendListener, nsIMsgSendListener)</span>
<a href="#l8.143"></a><span id="l8.143"> </span>
<a href="#l8.144"></a><span id="l8.144"> nsresult OutlookSendListener::CreateSendListener( nsIMsgSendListener **ppListener)</span>
<a href="#l8.145"></a><span id="l8.145"> {</span>
<a href="#l8.146"></a><span id="l8.146" class="difflineminus">-    NS_PRECONDITION(ppListener != nsnull, &quot;null ptr&quot;);</span>
<a href="#l8.147"></a><span id="l8.147" class="difflineminus">-    if (! ppListener)</span>
<a href="#l8.148"></a><span id="l8.148" class="difflineminus">-        return NS_ERROR_NULL_POINTER;</span>
<a href="#l8.149"></a><span id="l8.149" class="difflineplus">+  NS_PRECONDITION(ppListener != nsnull, &quot;null ptr&quot;);</span>
<a href="#l8.150"></a><span id="l8.150" class="difflineplus">+  NS_ENSURE_ARG_POINTER(ppListener);</span>
<a href="#l8.151"></a><span id="l8.151"> </span>
<a href="#l8.152"></a><span id="l8.152" class="difflineminus">-    *ppListener = new OutlookSendListener();</span>
<a href="#l8.153"></a><span id="l8.153" class="difflineminus">-    if (! *ppListener)</span>
<a href="#l8.154"></a><span id="l8.154" class="difflineminus">-        return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l8.155"></a><span id="l8.155" class="difflineplus">+  *ppListener = new OutlookSendListener();</span>
<a href="#l8.156"></a><span id="l8.156" class="difflineplus">+  if (! *ppListener)</span>
<a href="#l8.157"></a><span id="l8.157" class="difflineplus">+    return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l8.158"></a><span id="l8.158"> </span>
<a href="#l8.159"></a><span id="l8.159" class="difflineminus">-    NS_ADDREF(*ppListener);</span>
<a href="#l8.160"></a><span id="l8.160" class="difflineminus">-    return NS_OK;</span>
<a href="#l8.161"></a><span id="l8.161" class="difflineplus">+  NS_ADDREF(*ppListener);</span>
<a href="#l8.162"></a><span id="l8.162" class="difflineplus">+  return NS_OK;</span>
<a href="#l8.163"></a><span id="l8.163"> }</span>
<a href="#l8.164"></a><span id="l8.164"> </span>
<a href="#l8.165"></a><span id="l8.165" class="difflineminus">-</span>
<a href="#l8.166"></a><span id="l8.166"> /////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l8.167"></a><span id="l8.167"> /////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l8.168"></a><span id="l8.168"> /////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l8.169"></a><span id="l8.169"> /////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l8.170"></a><span id="l8.170"> </span>
<a href="#l8.171"></a><span id="l8.171" class="difflineminus">-</span>
<a href="#l8.172"></a><span id="l8.172" class="difflineplus">+#define hackBeginA &quot;begin&quot;</span>
<a href="#l8.173"></a><span id="l8.173" class="difflineplus">+#define hackBeginW NS_L(hackBeginA)</span>
<a href="#l8.174"></a><span id="l8.174" class="difflineplus">+#define hackEndA &quot;\015\012end&quot;</span>
<a href="#l8.175"></a><span id="l8.175" class="difflineplus">+#define hackEndW NS_L(hackEndA)</span>
<a href="#l8.176"></a><span id="l8.176" class="difflineplus">+#define hackCRLFA &quot;crlf&quot;</span>
<a href="#l8.177"></a><span id="l8.177" class="difflineplus">+#define hackCRLFW NS_L(hackCRLFA)</span>
<a href="#l8.178"></a><span id="l8.178" class="difflineplus">+#define hackAmpersandA &quot;amp&quot;</span>
<a href="#l8.179"></a><span id="l8.179" class="difflineplus">+#define hackAmpersandW NS_L(hackAmpersandA)</span>
<a href="#l8.180"></a><span id="l8.180"> </span>
<a href="#l8.181"></a><span id="l8.181"> nsOutlookCompose::nsOutlookCompose()</span>
<a href="#l8.182"></a><span id="l8.182"> {</span>
<a href="#l8.183"></a><span id="l8.183" class="difflineminus">-  m_pIOService = nsnull;</span>
<a href="#l8.184"></a><span id="l8.184" class="difflineminus">-  m_pAttachments = nsnull;</span>
<a href="#l8.185"></a><span id="l8.185">   m_pListener = nsnull;</span>
<a href="#l8.186"></a><span id="l8.186">   m_pMsgSend = nsnull;</span>
<a href="#l8.187"></a><span id="l8.187">   m_pSendProxy = nsnull;</span>
<a href="#l8.188"></a><span id="l8.188">   m_pMsgFields = nsnull;</span>
<a href="#l8.189"></a><span id="l8.189">   m_pIdentity = nsnull;</span>
<a href="#l8.190"></a><span id="l8.190" class="difflineminus">-#ifdef IMPORT_DEBUG</span>
<a href="#l8.191"></a><span id="l8.191" class="difflineminus">-  m_Headers = p_test_headers;</span>
<a href="#l8.192"></a><span id="l8.192" class="difflineminus">-  m_Body = p_test_body;</span>
<a href="#l8.193"></a><span id="l8.193" class="difflineminus">-#endif</span>
<a href="#l8.194"></a><span id="l8.194"> </span>
<a href="#l8.195"></a><span id="l8.195" class="difflineminus">-  m_readHeaders.m_convertCRs = PR_TRUE;</span>
<a href="#l8.196"></a><span id="l8.196" class="difflineplus">+  m_optimizationBufferSize = 16*1024;</span>
<a href="#l8.197"></a><span id="l8.197" class="difflineplus">+  m_optimizationBuffer = new char[m_optimizationBufferSize];</span>
<a href="#l8.198"></a><span id="l8.198"> }</span>
<a href="#l8.199"></a><span id="l8.199"> </span>
<a href="#l8.200"></a><span id="l8.200" class="difflineminus">-</span>
<a href="#l8.201"></a><span id="l8.201"> nsOutlookCompose::~nsOutlookCompose()</span>
<a href="#l8.202"></a><span id="l8.202"> {</span>
<a href="#l8.203"></a><span id="l8.203" class="difflineminus">-  NS_IF_RELEASE( m_pSendProxy);</span>
<a href="#l8.204"></a><span id="l8.204" class="difflineminus">-  NS_IF_RELEASE( m_pIOService);</span>
<a href="#l8.205"></a><span id="l8.205" class="difflineminus">-  NS_IF_RELEASE( m_pMsgSend);</span>
<a href="#l8.206"></a><span id="l8.206" class="difflineminus">-  NS_IF_RELEASE( m_pListener);</span>
<a href="#l8.207"></a><span id="l8.207" class="difflineminus">-  NS_IF_RELEASE( m_pMsgFields);</span>
<a href="#l8.208"></a><span id="l8.208" class="difflineplus">+  NS_IF_RELEASE(m_pSendProxy);</span>
<a href="#l8.209"></a><span id="l8.209" class="difflineplus">+  NS_IF_RELEASE(m_pMsgSend);</span>
<a href="#l8.210"></a><span id="l8.210" class="difflineplus">+  NS_IF_RELEASE(m_pListener);</span>
<a href="#l8.211"></a><span id="l8.211" class="difflineplus">+  NS_IF_RELEASE(m_pMsgFields);</span>
<a href="#l8.212"></a><span id="l8.212">   if (m_pIdentity) {</span>
<a href="#l8.213"></a><span id="l8.213">     nsresult rv = m_pIdentity-&gt;ClearAllValues();</span>
<a href="#l8.214"></a><span id="l8.214">     NS_ASSERTION(NS_SUCCEEDED(rv),&quot;failed to clear values&quot;);</span>
<a href="#l8.215"></a><span id="l8.215" class="difflineminus">-    if (NS_FAILED(rv)) return;</span>
<a href="#l8.216"></a><span id="l8.216" class="difflineplus">+    if (NS_FAILED(rv))</span>
<a href="#l8.217"></a><span id="l8.217" class="difflineplus">+      return;</span>
<a href="#l8.218"></a><span id="l8.218"> </span>
<a href="#l8.219"></a><span id="l8.219">     NS_RELEASE(m_pIdentity);</span>
<a href="#l8.220"></a><span id="l8.220">   }</span>
<a href="#l8.221"></a><span id="l8.221" class="difflineplus">+  delete[] m_optimizationBuffer;</span>
<a href="#l8.222"></a><span id="l8.222" class="difflineplus">+  ClearReplaceCids();</span>
<a href="#l8.223"></a><span id="l8.223" class="difflineplus">+}</span>
<a href="#l8.224"></a><span id="l8.224" class="difflineplus">+</span>
<a href="#l8.225"></a><span id="l8.225" class="difflineplus">+void nsOutlookCompose::ClearReplaceCids()</span>
<a href="#l8.226"></a><span id="l8.226" class="difflineplus">+{</span>
<a href="#l8.227"></a><span id="l8.227" class="difflineplus">+  std::for_each(m_replacedCids.begin(), m_replacedCids.end(), ClearReplaceCid);</span>
<a href="#l8.228"></a><span id="l8.228" class="difflineplus">+  m_replacedCids.clear();</span>
<a href="#l8.229"></a><span id="l8.229"> }</span>
<a href="#l8.230"></a><span id="l8.230"> </span>
<a href="#l8.231"></a><span id="l8.231"> nsresult nsOutlookCompose::CreateIdentity( void)</span>
<a href="#l8.232"></a><span id="l8.232"> {</span>
<a href="#l8.233"></a><span id="l8.233">   if (m_pIdentity)</span>
<a href="#l8.234"></a><span id="l8.234" class="difflineminus">-    return( NS_OK);</span>
<a href="#l8.235"></a><span id="l8.235" class="difflineplus">+    return NS_OK;</span>
<a href="#l8.236"></a><span id="l8.236"> </span>
<a href="#l8.237"></a><span id="l8.237">   nsresult rv;</span>
<a href="#l8.238"></a><span id="l8.238" class="difflineminus">-  NS_WITH_PROXIED_SERVICE(nsIMsgAccountManager, accMgr, NS_MSGACCOUNTMANAGER_CONTRACTID, NS_PROXY_TO_MAIN_THREAD, &amp;rv);</span>
<a href="#l8.239"></a><span id="l8.239" class="difflineminus">-  if (NS_FAILED(rv)) return( rv);</span>
<a href="#l8.240"></a><span id="l8.240" class="difflineminus">-  rv = accMgr-&gt;CreateIdentity( &amp;m_pIdentity);</span>
<a href="#l8.241"></a><span id="l8.241" class="difflineplus">+  NS_WITH_PROXIED_SERVICE(nsIMsgAccountManager, accMgr,</span>
<a href="#l8.242"></a><span id="l8.242" class="difflineplus">+                          NS_MSGACCOUNTMANAGER_CONTRACTID,</span>
<a href="#l8.243"></a><span id="l8.243" class="difflineplus">+                          NS_PROXY_TO_MAIN_THREAD, &amp;rv);</span>
<a href="#l8.244"></a><span id="l8.244" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l8.245"></a><span id="l8.245" class="difflineplus">+  rv = accMgr-&gt;CreateIdentity(&amp;m_pIdentity);</span>
<a href="#l8.246"></a><span id="l8.246">   nsString name;</span>
<a href="#l8.247"></a><span id="l8.247">   name.AssignLiteral(&quot;Import Identity&quot;);</span>
<a href="#l8.248"></a><span id="l8.248">   if (m_pIdentity) {</span>
<a href="#l8.249"></a><span id="l8.249">     m_pIdentity-&gt;SetFullName(name);</span>
<a href="#l8.250"></a><span id="l8.250">     m_pIdentity-&gt;SetIdentityName(name);</span>
<a href="#l8.251"></a><span id="l8.251">     m_pIdentity-&gt;SetEmail(NS_LITERAL_CSTRING(&quot;import@import.service&quot;));</span>
<a href="#l8.252"></a><span id="l8.252">   }</span>
<a href="#l8.253"></a><span id="l8.253"> </span>
<a href="#l8.254"></a><span id="l8.254" class="difflineminus">-  return( rv);</span>
<a href="#l8.255"></a><span id="l8.255" class="difflineplus">+  return rv;</span>
<a href="#l8.256"></a><span id="l8.256"> }</span>
<a href="#l8.257"></a><span id="l8.257"> </span>
<a href="#l8.258"></a><span id="l8.258"> nsresult nsOutlookCompose::CreateComponents( void)</span>
<a href="#l8.259"></a><span id="l8.259"> {</span>
<a href="#l8.260"></a><span id="l8.260">   nsresult rv = NS_OK;</span>
<a href="#l8.261"></a><span id="l8.261"> </span>
<a href="#l8.262"></a><span id="l8.262" class="difflineminus">-  if (!m_pIOService) {</span>
<a href="#l8.263"></a><span id="l8.263" class="difflineminus">-    IMPORT_LOG0( &quot;Creating nsIOService\n&quot;);</span>
<a href="#l8.264"></a><span id="l8.264" class="difflineminus">-</span>
<a href="#l8.265"></a><span id="l8.265" class="difflineminus">-    NS_WITH_PROXIED_SERVICE(nsIIOService, service, NS_IOSERVICE_CONTRACTID, NS_PROXY_TO_MAIN_THREAD, &amp;rv);</span>
<a href="#l8.266"></a><span id="l8.266" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l8.267"></a><span id="l8.267" class="difflineminus">-      return( rv);</span>
<a href="#l8.268"></a><span id="l8.268" class="difflineminus">-    m_pIOService = service;</span>
<a href="#l8.269"></a><span id="l8.269" class="difflineminus">-    NS_IF_ADDREF( m_pIOService);</span>
<a href="#l8.270"></a><span id="l8.270" class="difflineminus">-  }</span>
<a href="#l8.271"></a><span id="l8.271" class="difflineminus">-</span>
<a href="#l8.272"></a><span id="l8.272" class="difflineminus">-  NS_IF_RELEASE( m_pMsgFields);</span>
<a href="#l8.273"></a><span id="l8.273" class="difflineplus">+  NS_IF_RELEASE(m_pMsgFields);</span>
<a href="#l8.274"></a><span id="l8.274">   if (!m_pMsgSend) {</span>
<a href="#l8.275"></a><span id="l8.275">     rv = CallCreateInstance( kMsgSendCID, &amp;m_pMsgSend);</span>
<a href="#l8.276"></a><span id="l8.276">     if (NS_SUCCEEDED( rv) &amp;&amp; m_pMsgSend) {</span>
<a href="#l8.277"></a><span id="l8.277">       rv = NS_GetProxyForObject( NS_PROXY_TO_MAIN_THREAD, NS_GET_IID(nsIMsgSend),</span>
<a href="#l8.278"></a><span id="l8.278">                   m_pMsgSend, NS_PROXY_SYNC, (void **)&amp;m_pSendProxy);</span>
<a href="#l8.279"></a><span id="l8.279">       if (NS_FAILED( rv)) {</span>
<a href="#l8.280"></a><span id="l8.280">         m_pSendProxy = nsnull;</span>
<a href="#l8.281"></a><span id="l8.281" class="difflineminus">-        NS_RELEASE( m_pMsgSend);</span>
<a href="#l8.282"></a><span id="l8.282" class="difflineplus">+        NS_RELEASE(m_pMsgSend);</span>
<a href="#l8.283"></a><span id="l8.283">       }</span>
<a href="#l8.284"></a><span id="l8.284">     }</span>
<a href="#l8.285"></a><span id="l8.285">   }</span>
<a href="#l8.286"></a><span id="l8.286">   if (!m_pListener &amp;&amp; NS_SUCCEEDED( rv)) {</span>
<a href="#l8.287"></a><span id="l8.287">     rv = OutlookSendListener::CreateSendListener( &amp;m_pListener);</span>
<a href="#l8.288"></a><span id="l8.288">   }</span>
<a href="#l8.289"></a><span id="l8.289"> </span>
<a href="#l8.290"></a><span id="l8.290">   if (NS_SUCCEEDED(rv) &amp;&amp; m_pMsgSend) {</span>
<a href="#l8.291"></a><span id="l8.291">       rv = CallCreateInstance( kMsgCompFieldsCID, &amp;m_pMsgFields);</span>
<a href="#l8.292"></a><span id="l8.292">     if (NS_SUCCEEDED(rv) &amp;&amp; m_pMsgFields) {</span>
<a href="#l8.293"></a><span id="l8.293">       // IMPORT_LOG0( &quot;nsOutlookCompose - CreateComponents succeeded\n&quot;);</span>
<a href="#l8.294"></a><span id="l8.294">       m_pMsgFields-&gt;SetForcePlainText( PR_FALSE);</span>
<a href="#l8.295"></a><span id="l8.295" class="difflineminus">-      return( NS_OK);</span>
<a href="#l8.296"></a><span id="l8.296" class="difflineminus">-    }</span>
<a href="#l8.297"></a><span id="l8.297" class="difflineminus">-  }</span>
<a href="#l8.298"></a><span id="l8.298" class="difflineminus">-</span>
<a href="#l8.299"></a><span id="l8.299" class="difflineminus">-  return( NS_ERROR_FAILURE);</span>
<a href="#l8.300"></a><span id="l8.300" class="difflineminus">-}</span>
<a href="#l8.301"></a><span id="l8.301" class="difflineminus">-</span>
<a href="#l8.302"></a><span id="l8.302" class="difflineminus">-void nsOutlookCompose::GetNthHeader( const char *pData, PRInt32 dataLen, PRInt32 n, nsCString&amp; header, nsCString&amp; val, PRBool unwrap)</span>
<a href="#l8.303"></a><span id="l8.303" class="difflineminus">-{</span>
<a href="#l8.304"></a><span id="l8.304" class="difflineminus">-  header.Truncate();</span>
<a href="#l8.305"></a><span id="l8.305" class="difflineminus">-  val.Truncate();</span>
<a href="#l8.306"></a><span id="l8.306" class="difflineminus">-  if (!pData)</span>
<a href="#l8.307"></a><span id="l8.307" class="difflineminus">-    return;</span>
<a href="#l8.308"></a><span id="l8.308" class="difflineminus">-</span>
<a href="#l8.309"></a><span id="l8.309" class="difflineminus">-  PRInt32  index = 0;</span>
<a href="#l8.310"></a><span id="l8.310" class="difflineminus">-  PRInt32  len;</span>
<a href="#l8.311"></a><span id="l8.311" class="difflineminus">-  PRInt32  start = 0;</span>
<a href="#l8.312"></a><span id="l8.312" class="difflineminus">-  const char *pChar = pData;</span>
<a href="#l8.313"></a><span id="l8.313" class="difflineminus">-  const char *pStart;</span>
<a href="#l8.314"></a><span id="l8.314" class="difflineminus">-  if (n == 0) {</span>
<a href="#l8.315"></a><span id="l8.315" class="difflineminus">-    pStart = pChar;</span>
<a href="#l8.316"></a><span id="l8.316" class="difflineminus">-    len = 0;</span>
<a href="#l8.317"></a><span id="l8.317" class="difflineminus">-    while ((start &lt; dataLen) &amp;&amp; (*pChar != ':')) {</span>
<a href="#l8.318"></a><span id="l8.318" class="difflineminus">-      start++;</span>
<a href="#l8.319"></a><span id="l8.319" class="difflineminus">-      len++;</span>
<a href="#l8.320"></a><span id="l8.320" class="difflineminus">-      pChar++;</span>
<a href="#l8.321"></a><span id="l8.321" class="difflineminus">-    }</span>
<a href="#l8.322"></a><span id="l8.322" class="difflineminus">-    header.Append( pStart, len);</span>
<a href="#l8.323"></a><span id="l8.323" class="difflineminus">-    header.Trim( kWhitespace);</span>
<a href="#l8.324"></a><span id="l8.324" class="difflineminus">-    start++;</span>
<a href="#l8.325"></a><span id="l8.325" class="difflineminus">-    pChar++;</span>
<a href="#l8.326"></a><span id="l8.326" class="difflineminus">-  }</span>
<a href="#l8.327"></a><span id="l8.327" class="difflineminus">-  else {</span>
<a href="#l8.328"></a><span id="l8.328" class="difflineminus">-    while (start &lt; dataLen) {</span>
<a href="#l8.329"></a><span id="l8.329" class="difflineminus">-      if ((*pChar != ' ') &amp;&amp; (*pChar != 9)) {</span>
<a href="#l8.330"></a><span id="l8.330" class="difflineminus">-        if (n == index) {</span>
<a href="#l8.331"></a><span id="l8.331" class="difflineminus">-          pStart = pChar;</span>
<a href="#l8.332"></a><span id="l8.332" class="difflineminus">-          len = 0;</span>
<a href="#l8.333"></a><span id="l8.333" class="difflineminus">-          while ((start &lt; dataLen) &amp;&amp; (*pChar != ':')) {</span>
<a href="#l8.334"></a><span id="l8.334" class="difflineminus">-            start++;</span>
<a href="#l8.335"></a><span id="l8.335" class="difflineminus">-            len++;</span>
<a href="#l8.336"></a><span id="l8.336" class="difflineminus">-            pChar++;</span>
<a href="#l8.337"></a><span id="l8.337" class="difflineminus">-          }</span>
<a href="#l8.338"></a><span id="l8.338" class="difflineminus">-          header.Append( pStart, len);</span>
<a href="#l8.339"></a><span id="l8.339" class="difflineminus">-          header.Trim( kWhitespace);</span>
<a href="#l8.340"></a><span id="l8.340" class="difflineminus">-          start++;</span>
<a href="#l8.341"></a><span id="l8.341" class="difflineminus">-          pChar++;</span>
<a href="#l8.342"></a><span id="l8.342" class="difflineminus">-          break;</span>
<a href="#l8.343"></a><span id="l8.343" class="difflineminus">-        }</span>
<a href="#l8.344"></a><span id="l8.344" class="difflineminus">-        else</span>
<a href="#l8.345"></a><span id="l8.345" class="difflineminus">-          index++;</span>
<a href="#l8.346"></a><span id="l8.346" class="difflineminus">-      }</span>
<a href="#l8.347"></a><span id="l8.347" class="difflineminus">-</span>
<a href="#l8.348"></a><span id="l8.348" class="difflineminus">-      while ((start &lt; dataLen) &amp;&amp; (*pChar != 0x0D) &amp;&amp; (*pChar != 0x0A)) {</span>
<a href="#l8.349"></a><span id="l8.349" class="difflineminus">-        start++;</span>
<a href="#l8.350"></a><span id="l8.350" class="difflineminus">-        pChar++;</span>
<a href="#l8.351"></a><span id="l8.351" class="difflineminus">-      }</span>
<a href="#l8.352"></a><span id="l8.352" class="difflineminus">-      while ((start &lt; dataLen) &amp;&amp; ((*pChar == 0x0D) || (*pChar == 0x0A))) {</span>
<a href="#l8.353"></a><span id="l8.353" class="difflineminus">-        start++;</span>
<a href="#l8.354"></a><span id="l8.354" class="difflineminus">-        pChar++;</span>
<a href="#l8.355"></a><span id="l8.355" class="difflineminus">-      }</span>
<a href="#l8.356"></a><span id="l8.356" class="difflineplus">+      return NS_OK;</span>
<a href="#l8.357"></a><span id="l8.357">     }</span>
<a href="#l8.358"></a><span id="l8.358">   }</span>
<a href="#l8.359"></a><span id="l8.359"> </span>
<a href="#l8.360"></a><span id="l8.360" class="difflineminus">-  if (start &gt;= dataLen)</span>
<a href="#l8.361"></a><span id="l8.361" class="difflineminus">-    return;</span>
<a href="#l8.362"></a><span id="l8.362" class="difflineminus">-</span>
<a href="#l8.363"></a><span id="l8.363" class="difflineminus">-  PRInt32 lineEnd;</span>
<a href="#l8.364"></a><span id="l8.364" class="difflineminus">-  PRInt32 end = start;</span>
<a href="#l8.365"></a><span id="l8.365" class="difflineminus">-  while (end &lt; dataLen) {</span>
<a href="#l8.366"></a><span id="l8.366" class="difflineminus">-    while ((end &lt; dataLen) &amp;&amp; (*pChar != 0x0D) &amp;&amp; (*pChar != 0x0A)) {</span>
<a href="#l8.367"></a><span id="l8.367" class="difflineminus">-      end++;</span>
<a href="#l8.368"></a><span id="l8.368" class="difflineminus">-      pChar++;</span>
<a href="#l8.369"></a><span id="l8.369" class="difflineminus">-    }</span>
<a href="#l8.370"></a><span id="l8.370" class="difflineminus">-    if (end &gt; start) {</span>
<a href="#l8.371"></a><span id="l8.371" class="difflineminus">-      val.Append( pData + start, end - start);</span>
<a href="#l8.372"></a><span id="l8.372" class="difflineminus">-    }</span>
<a href="#l8.373"></a><span id="l8.373" class="difflineminus">-</span>
<a href="#l8.374"></a><span id="l8.374" class="difflineminus">-    lineEnd = end;</span>
<a href="#l8.375"></a><span id="l8.375" class="difflineminus">-    pStart = pChar;</span>
<a href="#l8.376"></a><span id="l8.376" class="difflineminus">-    while ((end &lt; dataLen) &amp;&amp; ((*pChar == 0x0D) || (*pChar == 0x0A))) {</span>
<a href="#l8.377"></a><span id="l8.377" class="difflineminus">-      end++;</span>
<a href="#l8.378"></a><span id="l8.378" class="difflineminus">-      pChar++;</span>
<a href="#l8.379"></a><span id="l8.379" class="difflineminus">-    }</span>
<a href="#l8.380"></a><span id="l8.380" class="difflineminus">-</span>
<a href="#l8.381"></a><span id="l8.381" class="difflineminus">-    start = end;</span>
<a href="#l8.382"></a><span id="l8.382" class="difflineminus">-</span>
<a href="#l8.383"></a><span id="l8.383" class="difflineminus">-    while ((end &lt; dataLen) &amp;&amp; ((*pChar == ' ') || (*pChar == '\t'))) {</span>
<a href="#l8.384"></a><span id="l8.384" class="difflineminus">-      end++;</span>
<a href="#l8.385"></a><span id="l8.385" class="difflineminus">-      pChar++;</span>
<a href="#l8.386"></a><span id="l8.386" class="difflineminus">-    }</span>
<a href="#l8.387"></a><span id="l8.387" class="difflineminus">-</span>
<a href="#l8.388"></a><span id="l8.388" class="difflineminus">-    if (start == end)</span>
<a href="#l8.389"></a><span id="l8.389" class="difflineminus">-      break;</span>
<a href="#l8.390"></a><span id="l8.390" class="difflineminus">-</span>
<a href="#l8.391"></a><span id="l8.391" class="difflineminus">-    if (unwrap)</span>
<a href="#l8.392"></a><span id="l8.392" class="difflineminus">-      val.Append( ' ');</span>
<a href="#l8.393"></a><span id="l8.393" class="difflineminus">-    else {</span>
<a href="#l8.394"></a><span id="l8.394" class="difflineminus">-      val.Append( pStart, end - lineEnd);</span>
<a href="#l8.395"></a><span id="l8.395" class="difflineminus">-    }</span>
<a href="#l8.396"></a><span id="l8.396" class="difflineminus">-</span>
<a href="#l8.397"></a><span id="l8.397" class="difflineminus">-    start = end;</span>
<a href="#l8.398"></a><span id="l8.398" class="difflineminus">-  }</span>
<a href="#l8.399"></a><span id="l8.399" class="difflineminus">-</span>
<a href="#l8.400"></a><span id="l8.400" class="difflineminus">-  val.Trim( kWhitespace);</span>
<a href="#l8.401"></a><span id="l8.401" class="difflineminus">-}</span>
<a href="#l8.402"></a><span id="l8.402" class="difflineminus">-</span>
<a href="#l8.403"></a><span id="l8.403" class="difflineminus">-</span>
<a href="#l8.404"></a><span id="l8.404" class="difflineminus">-void nsOutlookCompose::GetHeaderValue( const char *pData, PRInt32 dataLen, const char *pHeader, nsCString&amp; val, PRBool unwrap)</span>
<a href="#l8.405"></a><span id="l8.405" class="difflineminus">-{</span>
<a href="#l8.406"></a><span id="l8.406" class="difflineminus">-  val.Truncate();</span>
<a href="#l8.407"></a><span id="l8.407" class="difflineminus">-  if (!pData)</span>
<a href="#l8.408"></a><span id="l8.408" class="difflineminus">-    return;</span>
<a href="#l8.409"></a><span id="l8.409" class="difflineminus">-</span>
<a href="#l8.410"></a><span id="l8.410" class="difflineminus">-  PRInt32 start = 0;</span>
<a href="#l8.411"></a><span id="l8.411" class="difflineminus">-  PRInt32 len = strlen( pHeader);</span>
<a href="#l8.412"></a><span id="l8.412" class="difflineminus">-  const char *pChar = pData;</span>
<a href="#l8.413"></a><span id="l8.413" class="difflineminus">-  if (!PL_strncasecmp( pHeader, pData, len)) {</span>
<a href="#l8.414"></a><span id="l8.414" class="difflineminus">-    start = len;</span>
<a href="#l8.415"></a><span id="l8.415" class="difflineminus">-  }</span>
<a href="#l8.416"></a><span id="l8.416" class="difflineminus">-  else {</span>
<a href="#l8.417"></a><span id="l8.417" class="difflineminus">-    while (start &lt; dataLen) {</span>
<a href="#l8.418"></a><span id="l8.418" class="difflineminus">-      while ((start &lt; dataLen) &amp;&amp; (*pChar != 0x0D) &amp;&amp; (*pChar != 0x0A)) {</span>
<a href="#l8.419"></a><span id="l8.419" class="difflineminus">-        start++;</span>
<a href="#l8.420"></a><span id="l8.420" class="difflineminus">-        pChar++;</span>
<a href="#l8.421"></a><span id="l8.421" class="difflineminus">-      }</span>
<a href="#l8.422"></a><span id="l8.422" class="difflineminus">-      while ((start &lt; dataLen) &amp;&amp; ((*pChar == 0x0D) || (*pChar == 0x0A))) {</span>
<a href="#l8.423"></a><span id="l8.423" class="difflineminus">-        start++;</span>
<a href="#l8.424"></a><span id="l8.424" class="difflineminus">-        pChar++;</span>
<a href="#l8.425"></a><span id="l8.425" class="difflineminus">-      }</span>
<a href="#l8.426"></a><span id="l8.426" class="difflineminus">-      if ((start &lt; dataLen) &amp;&amp; !PL_strncasecmp( pChar, pHeader, len))</span>
<a href="#l8.427"></a><span id="l8.427" class="difflineminus">-        break;</span>
<a href="#l8.428"></a><span id="l8.428" class="difflineminus">-    }</span>
<a href="#l8.429"></a><span id="l8.429" class="difflineminus">-    if (start &lt; dataLen)</span>
<a href="#l8.430"></a><span id="l8.430" class="difflineminus">-      start += len;</span>
<a href="#l8.431"></a><span id="l8.431" class="difflineminus">-  }</span>
<a href="#l8.432"></a><span id="l8.432" class="difflineminus">-</span>
<a href="#l8.433"></a><span id="l8.433" class="difflineminus">-  if (start &gt;= dataLen)</span>
<a href="#l8.434"></a><span id="l8.434" class="difflineminus">-    return;</span>
<a href="#l8.435"></a><span id="l8.435" class="difflineminus">-</span>
<a href="#l8.436"></a><span id="l8.436" class="difflineminus">-  PRInt32 end = start;</span>
<a href="#l8.437"></a><span id="l8.437" class="difflineminus">-  PRInt32 lineEnd;</span>
<a href="#l8.438"></a><span id="l8.438" class="difflineminus">-  const char * pStart;</span>
<a href="#l8.439"></a><span id="l8.439" class="difflineminus">-</span>
<a href="#l8.440"></a><span id="l8.440" class="difflineminus">-  pChar = pData + start;</span>
<a href="#l8.441"></a><span id="l8.441" class="difflineminus">-</span>
<a href="#l8.442"></a><span id="l8.442" class="difflineminus">-  while (end &lt; dataLen) {</span>
<a href="#l8.443"></a><span id="l8.443" class="difflineminus">-    while ((end &lt; dataLen) &amp;&amp; (*pChar != 0x0D) &amp;&amp; (*pChar != 0x0A)) {</span>
<a href="#l8.444"></a><span id="l8.444" class="difflineminus">-      end++;</span>
<a href="#l8.445"></a><span id="l8.445" class="difflineminus">-      pChar++;</span>
<a href="#l8.446"></a><span id="l8.446" class="difflineminus">-    }</span>
<a href="#l8.447"></a><span id="l8.447" class="difflineminus">-    if (end &gt; start) {</span>
<a href="#l8.448"></a><span id="l8.448" class="difflineminus">-      val.Append( pData + start, end - start);</span>
<a href="#l8.449"></a><span id="l8.449" class="difflineminus">-    }</span>
<a href="#l8.450"></a><span id="l8.450" class="difflineminus">-</span>
<a href="#l8.451"></a><span id="l8.451" class="difflineminus">-    lineEnd = end;</span>
<a href="#l8.452"></a><span id="l8.452" class="difflineminus">-    pStart = pChar;</span>
<a href="#l8.453"></a><span id="l8.453" class="difflineminus">-    while ((end &lt; dataLen) &amp;&amp; ((*pChar == 0x0D) || (*pChar == 0x0A))) {</span>
<a href="#l8.454"></a><span id="l8.454" class="difflineminus">-      end++;</span>
<a href="#l8.455"></a><span id="l8.455" class="difflineminus">-      pChar++;</span>
<a href="#l8.456"></a><span id="l8.456" class="difflineminus">-    }</span>
<a href="#l8.457"></a><span id="l8.457" class="difflineminus">-</span>
<a href="#l8.458"></a><span id="l8.458" class="difflineminus">-    start = end;</span>
<a href="#l8.459"></a><span id="l8.459" class="difflineminus">-</span>
<a href="#l8.460"></a><span id="l8.460" class="difflineminus">-    while ((end &lt; dataLen) &amp;&amp; ((*pChar == ' ') || (*pChar == '\t'))) {</span>
<a href="#l8.461"></a><span id="l8.461" class="difflineminus">-      end++;</span>
<a href="#l8.462"></a><span id="l8.462" class="difflineminus">-      pChar++;</span>
<a href="#l8.463"></a><span id="l8.463" class="difflineminus">-    }</span>
<a href="#l8.464"></a><span id="l8.464" class="difflineminus">-</span>
<a href="#l8.465"></a><span id="l8.465" class="difflineminus">-    if (start == end)</span>
<a href="#l8.466"></a><span id="l8.466" class="difflineminus">-      break;</span>
<a href="#l8.467"></a><span id="l8.467" class="difflineminus">-</span>
<a href="#l8.468"></a><span id="l8.468" class="difflineminus">-    if (unwrap)</span>
<a href="#l8.469"></a><span id="l8.469" class="difflineminus">-      val.Append( ' ');</span>
<a href="#l8.470"></a><span id="l8.470" class="difflineminus">-    else {</span>
<a href="#l8.471"></a><span id="l8.471" class="difflineminus">-      val.Append( pStart, end - lineEnd);</span>
<a href="#l8.472"></a><span id="l8.472" class="difflineminus">-    }</span>
<a href="#l8.473"></a><span id="l8.473" class="difflineminus">-</span>
<a href="#l8.474"></a><span id="l8.474" class="difflineminus">-    start = end;</span>
<a href="#l8.475"></a><span id="l8.475" class="difflineminus">-  }</span>
<a href="#l8.476"></a><span id="l8.476" class="difflineminus">-</span>
<a href="#l8.477"></a><span id="l8.477" class="difflineminus">-  val.Trim( kWhitespace);</span>
<a href="#l8.478"></a><span id="l8.478" class="difflineplus">+  return NS_ERROR_FAILURE;</span>
<a href="#l8.479"></a><span id="l8.479"> }</span>
<a href="#l8.480"></a><span id="l8.480"> </span>
<a href="#l8.481"></a><span id="l8.481" class="difflineminus">-</span>
<a href="#l8.482"></a><span id="l8.482" class="difflineminus">-void nsOutlookCompose::ExtractCharset( nsString&amp; str)</span>
<a href="#l8.483"></a><span id="l8.483" class="difflineminus">-{</span>
<a href="#l8.484"></a><span id="l8.484" class="difflineminus">-  nsString tStr;</span>
<a href="#l8.485"></a><span id="l8.485" class="difflineminus">-  PRInt32 idx = str.Find( &quot;charset=&quot;, PR_TRUE);</span>
<a href="#l8.486"></a><span id="l8.486" class="difflineminus">-  if (idx != -1) {</span>
<a href="#l8.487"></a><span id="l8.487" class="difflineminus">-    idx += 8;</span>
<a href="#l8.488"></a><span id="l8.488" class="difflineminus">-    str.Right( tStr, str.Length() - idx);</span>
<a href="#l8.489"></a><span id="l8.489" class="difflineminus">-    idx = tStr.FindChar( ';');</span>
<a href="#l8.490"></a><span id="l8.490" class="difflineminus">-    if (idx != -1)</span>
<a href="#l8.491"></a><span id="l8.491" class="difflineminus">-      tStr.Left( str, idx);</span>
<a href="#l8.492"></a><span id="l8.492" class="difflineminus">-    else</span>
<a href="#l8.493"></a><span id="l8.493" class="difflineminus">-      str = tStr;</span>
<a href="#l8.494"></a><span id="l8.494" class="difflineminus">-    str.Trim( kWhitespace);</span>
<a href="#l8.495"></a><span id="l8.495" class="difflineminus">-    if ((str.CharAt( 0) == '&quot;') &amp;&amp; (str.Length() &gt; 2)) {</span>
<a href="#l8.496"></a><span id="l8.496" class="difflineminus">-      str.Mid( tStr, 1, str.Length() - 2);</span>
<a href="#l8.497"></a><span id="l8.497" class="difflineminus">-      str = tStr;</span>
<a href="#l8.498"></a><span id="l8.498" class="difflineminus">-      str.Trim( kWhitespace);</span>
<a href="#l8.499"></a><span id="l8.499" class="difflineminus">-    }</span>
<a href="#l8.500"></a><span id="l8.500" class="difflineminus">-  }</span>
<a href="#l8.501"></a><span id="l8.501" class="difflineminus">-  else</span>
<a href="#l8.502"></a><span id="l8.502" class="difflineminus">-    str.Truncate();</span>
<a href="#l8.503"></a><span id="l8.503" class="difflineminus">-}</span>
<a href="#l8.504"></a><span id="l8.504" class="difflineminus">-</span>
<a href="#l8.505"></a><span id="l8.505" class="difflineminus">-void nsOutlookCompose::ExtractMetaCharset( nsCString str, nsString&amp; newstr)</span>
<a href="#l8.506"></a><span id="l8.506" class="difflineminus">-{</span>
<a href="#l8.507"></a><span id="l8.507" class="difflineminus">-  PRInt32 idx_endhead = str.Find( &quot;/head&quot;, CaseInsensitiveCompare);</span>
<a href="#l8.508"></a><span id="l8.508" class="difflineminus">-  PRInt32 idx_charset = str.Find( &quot;charset=&quot;, CaseInsensitiveCompare);</span>
<a href="#l8.509"></a><span id="l8.509" class="difflineminus">-  if (idx_charset == -1 || idx_endhead == -1 || idx_charset &gt; idx_endhead) {</span>
<a href="#l8.510"></a><span id="l8.510" class="difflineminus">-    newstr.Truncate();</span>
<a href="#l8.511"></a><span id="l8.511" class="difflineminus">-    return;</span>
<a href="#l8.512"></a><span id="l8.512" class="difflineminus">-  }</span>
<a href="#l8.513"></a><span id="l8.513" class="difflineminus">-</span>
<a href="#l8.514"></a><span id="l8.514" class="difflineminus">-  idx_charset += 8;</span>
<a href="#l8.515"></a><span id="l8.515" class="difflineminus">-</span>
<a href="#l8.516"></a><span id="l8.516" class="difflineminus">-  // remove everything from the string after the next ; or &quot; or space,</span>
<a href="#l8.517"></a><span id="l8.517" class="difflineminus">-  // whichever comes first.</span>
<a href="#l8.518"></a><span id="l8.518" class="difflineminus">-  // The inital sting looks something like</span>
<a href="#l8.519"></a><span id="l8.519" class="difflineminus">-  // &lt;META content=&quot;text/html; charset=utf-8&quot; http-equiv=Content-Type&gt;</span>
<a href="#l8.520"></a><span id="l8.520" class="difflineminus">-  // &lt;META content=&quot;text/html; charset=utf-8;&quot; http-equiv=Content-Type&gt;</span>
<a href="#l8.521"></a><span id="l8.521" class="difflineminus">-  // &lt;META content=&quot;text/html; charset=utf-8 ;&quot; http-equiv=Content-Type&gt;</span>
<a href="#l8.522"></a><span id="l8.522" class="difflineminus">-  // &lt;META content=&quot;text/html; charset=utf-8 &quot; http-equiv=Content-Type&gt;</span>
<a href="#l8.523"></a><span id="l8.523" class="difflineminus">-  PRInt32 idx  = str.FindCharInSet( &quot;;\&quot; &quot;, idx_charset);</span>
<a href="#l8.524"></a><span id="l8.524" class="difflineminus">-</span>
<a href="#l8.525"></a><span id="l8.525" class="difflineminus">-  if (idx == kNotFound) {</span>
<a href="#l8.526"></a><span id="l8.526" class="difflineminus">-    // what??, no ; &quot; or space, we give up</span>
<a href="#l8.527"></a><span id="l8.527" class="difflineminus">-    newstr.Truncate();</span>
<a href="#l8.528"></a><span id="l8.528" class="difflineminus">-  } else {</span>
<a href="#l8.529"></a><span id="l8.529" class="difflineminus">-    CopyASCIItoUTF16 (Substring(str, idx_charset, idx - idx_charset), newstr);</span>
<a href="#l8.530"></a><span id="l8.530" class="difflineminus">-  }</span>
<a href="#l8.531"></a><span id="l8.531" class="difflineminus">-}</span>
<a href="#l8.532"></a><span id="l8.532" class="difflineminus">-</span>
<a href="#l8.533"></a><span id="l8.533" class="difflineminus">-void nsOutlookCompose::ExtractType( nsString&amp; str)</span>
<a href="#l8.534"></a><span id="l8.534" class="difflineminus">-{</span>
<a href="#l8.535"></a><span id="l8.535" class="difflineminus">-  nsString tStr;</span>
<a href="#l8.536"></a><span id="l8.536" class="difflineminus">-  PRInt32 idx = str.FindChar( ';');</span>
<a href="#l8.537"></a><span id="l8.537" class="difflineminus">-  if (idx != -1) {</span>
<a href="#l8.538"></a><span id="l8.538" class="difflineminus">-    str.Left( tStr, idx);</span>
<a href="#l8.539"></a><span id="l8.539" class="difflineminus">-    str = tStr;</span>
<a href="#l8.540"></a><span id="l8.540" class="difflineminus">-  }</span>
<a href="#l8.541"></a><span id="l8.541" class="difflineminus">-  str.Trim( kWhitespace);</span>
<a href="#l8.542"></a><span id="l8.542" class="difflineminus">-</span>
<a href="#l8.543"></a><span id="l8.543" class="difflineminus">-  if ((str.CharAt( 0) == '&quot;') &amp;&amp; (str.Length() &gt; 2)) {</span>
<a href="#l8.544"></a><span id="l8.544" class="difflineminus">-    str.Mid( tStr, 1, str.Length() - 2);</span>
<a href="#l8.545"></a><span id="l8.545" class="difflineminus">-    str = tStr;</span>
<a href="#l8.546"></a><span id="l8.546" class="difflineminus">-    str.Trim( kWhitespace);</span>
<a href="#l8.547"></a><span id="l8.547" class="difflineminus">-  }</span>
<a href="#l8.548"></a><span id="l8.548" class="difflineminus">-</span>
<a href="#l8.549"></a><span id="l8.549" class="difflineminus">-  // if multipart then ignore it since no outlook message body is ever</span>
<a href="#l8.550"></a><span id="l8.550" class="difflineminus">-  // valid multipart!</span>
<a href="#l8.551"></a><span id="l8.551" class="difflineminus">-  if (str.Length() &gt; 10) {</span>
<a href="#l8.552"></a><span id="l8.552" class="difflineminus">-    str.Left( tStr, 10);</span>
<a href="#l8.553"></a><span id="l8.553" class="difflineminus">-    if (tStr.LowerCaseEqualsLiteral(&quot;multipart/&quot;))</span>
<a href="#l8.554"></a><span id="l8.554" class="difflineminus">-      str.Truncate();</span>
<a href="#l8.555"></a><span id="l8.555" class="difflineminus">-  }</span>
<a href="#l8.556"></a><span id="l8.556" class="difflineminus">-}</span>
<a href="#l8.557"></a><span id="l8.557" class="difflineminus">-</span>
<a href="#l8.558"></a><span id="l8.558" class="difflineminus">-void nsOutlookCompose::CleanUpAttach( nsMsgAttachedFile *a, PRInt32 count)</span>
<a href="#l8.559"></a><span id="l8.559" class="difflineminus">-{</span>
<a href="#l8.560"></a><span id="l8.560" class="difflineminus">-  for (PRInt32 i = 0; i &lt; count; i++)</span>
<a href="#l8.561"></a><span id="l8.561" class="difflineminus">-  {</span>
<a href="#l8.562"></a><span id="l8.562" class="difflineminus">-    a[i].orig_url=nsnull;</span>
<a href="#l8.563"></a><span id="l8.563" class="difflineminus">-    if (a[i].type)</span>
<a href="#l8.564"></a><span id="l8.564" class="difflineminus">-      NS_Free( a[i].type);</span>
<a href="#l8.565"></a><span id="l8.565" class="difflineminus">-    if (a[i].description)</span>
<a href="#l8.566"></a><span id="l8.566" class="difflineminus">-      NS_Free( a[i].description);</span>
<a href="#l8.567"></a><span id="l8.567" class="difflineminus">-    if (a[i].encoding)</span>
<a href="#l8.568"></a><span id="l8.568" class="difflineminus">-      NS_Free( a[i].encoding);</span>
<a href="#l8.569"></a><span id="l8.569" class="difflineminus">-  }</span>
<a href="#l8.570"></a><span id="l8.570" class="difflineminus">-  delete [] a;</span>
<a href="#l8.571"></a><span id="l8.571" class="difflineminus">-}</span>
<a href="#l8.572"></a><span id="l8.572" class="difflineminus">-</span>
<a href="#l8.573"></a><span id="l8.573" class="difflineminus">-nsMsgAttachedFile * nsOutlookCompose::GetLocalAttachments( void)</span>
<a href="#l8.574"></a><span id="l8.574" class="difflineminus">-{</span>
<a href="#l8.575"></a><span id="l8.575" class="difflineminus">-  /*</span>
<a href="#l8.576"></a><span id="l8.576" class="difflineminus">-  nsIURI      *url = nsnull;</span>
<a href="#l8.577"></a><span id="l8.577" class="difflineminus">-  */</span>
<a href="#l8.578"></a><span id="l8.578" class="difflineminus">-</span>
<a href="#l8.579"></a><span id="l8.579" class="difflineminus">-  PRInt32 count = 0;</span>
<a href="#l8.580"></a><span id="l8.580" class="difflineminus">-  if (m_pAttachments)</span>
<a href="#l8.581"></a><span id="l8.581" class="difflineminus">-    count = m_pAttachments-&gt;Count();</span>
<a href="#l8.582"></a><span id="l8.582" class="difflineminus">-  if (!count)</span>
<a href="#l8.583"></a><span id="l8.583" class="difflineminus">-    return( nsnull);</span>
<a href="#l8.584"></a><span id="l8.584" class="difflineminus">-</span>
<a href="#l8.585"></a><span id="l8.585" class="difflineminus">-  nsMsgAttachedFile *a = (nsMsgAttachedFile *) new nsMsgAttachedFile[count + 1];</span>
<a href="#l8.586"></a><span id="l8.586" class="difflineminus">-  if (!a)</span>
<a href="#l8.587"></a><span id="l8.587" class="difflineminus">-    return( nsnull);</span>
<a href="#l8.588"></a><span id="l8.588" class="difflineminus">-  memset(a, 0, sizeof(nsMsgAttachedFile) * (count + 1));</span>
<a href="#l8.589"></a><span id="l8.589" class="difflineminus">-</span>
<a href="#l8.590"></a><span id="l8.590" class="difflineminus">-  nsresult rv;</span>
<a href="#l8.591"></a><span id="l8.591" class="difflineminus">-  nsCString urlStr;</span>
<a href="#l8.592"></a><span id="l8.592" class="difflineminus">-  OutlookAttachment * pAttach;</span>
<a href="#l8.593"></a><span id="l8.593" class="difflineminus">-</span>
<a href="#l8.594"></a><span id="l8.594" class="difflineminus">-  for (PRInt32 i = 0; i &lt; count; i++) {</span>
<a href="#l8.595"></a><span id="l8.595" class="difflineminus">-    // nsMsgNewURL(&amp;url, &quot;file://C:/boxster.jpg&quot;);</span>
<a href="#l8.596"></a><span id="l8.596" class="difflineminus">-    // a[i].orig_url = url;</span>
<a href="#l8.597"></a><span id="l8.597" class="difflineminus">-</span>
<a href="#l8.598"></a><span id="l8.598" class="difflineminus">-    // NS_PRECONDITION( PR_FALSE, &quot;Forced Break&quot;);</span>
<a href="#l8.599"></a><span id="l8.599" class="difflineminus">-</span>
<a href="#l8.600"></a><span id="l8.600" class="difflineminus">-    pAttach = (OutlookAttachment *) m_pAttachments-&gt;ElementAt( i);</span>
<a href="#l8.601"></a><span id="l8.601" class="difflineminus">-                // should we clone here?</span>
<a href="#l8.602"></a><span id="l8.602" class="difflineminus">-    a[i].tmp_file = pAttach-&gt;pAttachment;</span>
<a href="#l8.603"></a><span id="l8.603" class="difflineminus">-    nsCOMPtr &lt;nsIURI&gt; uri;</span>
<a href="#l8.604"></a><span id="l8.604" class="difflineminus">-    rv = NS_NewFileURI(getter_AddRefs(uri), pAttach-&gt;pAttachment);</span>
<a href="#l8.605"></a><span id="l8.605" class="difflineminus">-    NS_ENSURE_SUCCESS(rv, nsnull);</span>
<a href="#l8.606"></a><span id="l8.606" class="difflineminus">-    uri-&gt;GetSpec(urlStr);</span>
<a href="#l8.607"></a><span id="l8.607" class="difflineminus">-    if (urlStr.IsEmpty()) {</span>
<a href="#l8.608"></a><span id="l8.608" class="difflineminus">-      CleanUpAttach( a, count);</span>
<a href="#l8.609"></a><span id="l8.609" class="difflineminus">-      return( nsnull);</span>
<a href="#l8.610"></a><span id="l8.610" class="difflineminus">-    }</span>
<a href="#l8.611"></a><span id="l8.611" class="difflineminus">-    rv = m_pIOService-&gt;NewURI( urlStr, nsnull, nsnull, getter_AddRefs(a[i].orig_url));</span>
<a href="#l8.612"></a><span id="l8.612" class="difflineminus">-    if (NS_FAILED( rv)) {</span>
<a href="#l8.613"></a><span id="l8.613" class="difflineminus">-      CleanUpAttach( a, count);</span>
<a href="#l8.614"></a><span id="l8.614" class="difflineminus">-      return( nsnull);</span>
<a href="#l8.615"></a><span id="l8.615" class="difflineminus">-    }</span>
<a href="#l8.616"></a><span id="l8.616" class="difflineminus">-</span>
<a href="#l8.617"></a><span id="l8.617" class="difflineminus">-    a[i].type = strdup( pAttach-&gt;mimeType);</span>
<a href="#l8.618"></a><span id="l8.618" class="difflineminus">-    a[i].real_name = strdup( pAttach-&gt;description);</span>
<a href="#l8.619"></a><span id="l8.619" class="difflineminus">-    a[i].encoding = strdup( ENCODING_BINARY);</span>
<a href="#l8.620"></a><span id="l8.620" class="difflineminus">-  }</span>
<a href="#l8.621"></a><span id="l8.621" class="difflineminus">-</span>
<a href="#l8.622"></a><span id="l8.622" class="difflineminus">-  return( a);</span>
<a href="#l8.623"></a><span id="l8.623" class="difflineminus">-}</span>
<a href="#l8.624"></a><span id="l8.624" class="difflineminus">-</span>
<a href="#l8.625"></a><span id="l8.625" class="difflineminus">-// Test a message send????</span>
<a href="#l8.626"></a><span id="l8.626" class="difflineminus">-nsresult nsOutlookCompose::SendTheMessage(nsMsgDeliverMode mode, nsCString &amp;useThisCType, nsIFile **pMsg)</span>
<a href="#l8.627"></a><span id="l8.627" class="difflineplus">+nsresult nsOutlookCompose::ComposeTheMessage(nsMsgDeliverMode mode, CMapiMessage &amp;msg, nsIFile **pMsg)</span>
<a href="#l8.628"></a><span id="l8.628"> {</span>
<a href="#l8.629"></a><span id="l8.629">   nsresult rv = CreateComponents();</span>
<a href="#l8.630"></a><span id="l8.630">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l8.631"></a><span id="l8.631">   rv = CreateIdentity();</span>
<a href="#l8.632"></a><span id="l8.632">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l8.633"></a><span id="l8.633"> </span>
<a href="#l8.634"></a><span id="l8.634">   // IMPORT_LOG0( &quot;Outlook Compose created necessary components\n&quot;);</span>
<a href="#l8.635"></a><span id="l8.635" class="difflineminus">-  nsAutoString bodyType;</span>
<a href="#l8.636"></a><span id="l8.636" class="difflineminus">-  nsAutoString charSet;</span>
<a href="#l8.637"></a><span id="l8.637" class="difflineminus">-  nsAutoString headerVal;</span>
<a href="#l8.638"></a><span id="l8.638" class="difflineminus">-  nsCAutoString asciiHeaderVal;</span>
<a href="#l8.639"></a><span id="l8.639" class="difflineplus">+</span>
<a href="#l8.640"></a><span id="l8.640" class="difflineplus">+  CMapiMessageHeaders* headers = msg.GetHeaders();</span>
<a href="#l8.641"></a><span id="l8.641"> </span>
<a href="#l8.642"></a><span id="l8.642" class="difflineminus">-  GetHeaderValue( m_Headers.get(), m_Headers.Length(), &quot;From:&quot;, headerVal);</span>
<a href="#l8.643"></a><span id="l8.643" class="difflineminus">-  if (!headerVal.IsEmpty())</span>
<a href="#l8.644"></a><span id="l8.644" class="difflineminus">-    m_pMsgFields-&gt;SetFrom( headerVal);</span>
<a href="#l8.645"></a><span id="l8.645" class="difflineminus">-  GetHeaderValue( m_Headers.get(), m_Headers.Length(), &quot;To:&quot;, headerVal);</span>
<a href="#l8.646"></a><span id="l8.646" class="difflineminus">-  if (!headerVal.IsEmpty())</span>
<a href="#l8.647"></a><span id="l8.647" class="difflineminus">-    m_pMsgFields-&gt;SetTo( headerVal);</span>
<a href="#l8.648"></a><span id="l8.648" class="difflineminus">-  GetHeaderValue( m_Headers.get(), m_Headers.Length(), &quot;Subject:&quot;, headerVal);</span>
<a href="#l8.649"></a><span id="l8.649" class="difflineminus">-  if (!headerVal.IsEmpty())</span>
<a href="#l8.650"></a><span id="l8.650" class="difflineminus">-    m_pMsgFields-&gt;SetSubject( headerVal);</span>
<a href="#l8.651"></a><span id="l8.651" class="difflineminus">-  GetHeaderValue( m_Headers.get(), m_Headers.Length(), &quot;Content-type:&quot;, headerVal);</span>
<a href="#l8.652"></a><span id="l8.652" class="difflineplus">+  nsString val;</span>
<a href="#l8.653"></a><span id="l8.653" class="difflineplus">+  headers-&gt;UnfoldValue(CMapiMessageHeaders::hdrFrom, val);</span>
<a href="#l8.654"></a><span id="l8.654" class="difflineplus">+  m_pMsgFields-&gt;SetFrom(val);</span>
<a href="#l8.655"></a><span id="l8.655" class="difflineplus">+  headers-&gt;UnfoldValue(CMapiMessageHeaders::hdrTo, val);</span>
<a href="#l8.656"></a><span id="l8.656" class="difflineplus">+  m_pMsgFields-&gt;SetTo(val);</span>
<a href="#l8.657"></a><span id="l8.657" class="difflineplus">+  headers-&gt;UnfoldValue(CMapiMessageHeaders::hdrSubject, val);</span>
<a href="#l8.658"></a><span id="l8.658" class="difflineplus">+  m_pMsgFields-&gt;SetSubject(val);</span>
<a href="#l8.659"></a><span id="l8.659" class="difflineplus">+  m_pMsgFields-&gt;SetCharacterSet( msg.GetBodyCharset() );</span>
<a href="#l8.660"></a><span id="l8.660" class="difflineplus">+  headers-&gt;UnfoldValue(CMapiMessageHeaders::hdrCc, val);</span>
<a href="#l8.661"></a><span id="l8.661" class="difflineplus">+  m_pMsgFields-&gt;SetCc(val);</span>
<a href="#l8.662"></a><span id="l8.662" class="difflineplus">+  headers-&gt;UnfoldValue(CMapiMessageHeaders::hdrReplyTo, val);</span>
<a href="#l8.663"></a><span id="l8.663" class="difflineplus">+  m_pMsgFields-&gt;SetReplyTo(val);</span>
<a href="#l8.664"></a><span id="l8.664"> </span>
<a href="#l8.665"></a><span id="l8.665" class="difflineminus">-  // If callers pass in a content type then use it, else get it from the header.</span>
<a href="#l8.666"></a><span id="l8.666" class="difflineminus">-  if (!useThisCType.IsEmpty())</span>
<a href="#l8.667"></a><span id="l8.667" class="difflineminus">-    CopyASCIItoUTF16(useThisCType, bodyType);</span>
<a href="#l8.668"></a><span id="l8.668" class="difflineminus">-  else</span>
<a href="#l8.669"></a><span id="l8.669" class="difflineminus">-  {</span>
<a href="#l8.670"></a><span id="l8.670" class="difflineminus">-    bodyType = headerVal;</span>
<a href="#l8.671"></a><span id="l8.671" class="difflineminus">-    ExtractType( bodyType);</span>
<a href="#l8.672"></a><span id="l8.672" class="difflineminus">-  }</span>
<a href="#l8.673"></a><span id="l8.673" class="difflineminus">-  ExtractCharset( headerVal);</span>
<a href="#l8.674"></a><span id="l8.674" class="difflineminus">-  // Use platform charset as default if the msg doesn't specify one</span>
<a href="#l8.675"></a><span id="l8.675" class="difflineminus">-  // (ie, no 'charset' param in the Content-Type: header). As the last</span>
<a href="#l8.676"></a><span id="l8.676" class="difflineminus">-  // resort we'll use the mail default charset.</span>
<a href="#l8.677"></a><span id="l8.677" class="difflineminus">-  PRBool try_to_improve_charset = PR_FALSE;</span>
<a href="#l8.678"></a><span id="l8.678" class="difflineminus">-  if (headerVal.IsEmpty())</span>
<a href="#l8.679"></a><span id="l8.679" class="difflineminus">-  {</span>
<a href="#l8.680"></a><span id="l8.680" class="difflineminus">-    try_to_improve_charset = PR_TRUE;</span>
<a href="#l8.681"></a><span id="l8.681" class="difflineminus">-    CopyASCIItoUTF16(nsMsgI18NFileSystemCharset(), headerVal);</span>
<a href="#l8.682"></a><span id="l8.682" class="difflineminus">-    if (headerVal.IsEmpty())</span>
<a href="#l8.683"></a><span id="l8.683" class="difflineminus">-    { // last resort</span>
<a href="#l8.684"></a><span id="l8.684" class="difflineminus">-      NS_GetLocalizedUnicharPreferenceWithDefault(nsnull, &quot;mailnews.view_default_charset&quot;,</span>
<a href="#l8.685"></a><span id="l8.685" class="difflineminus">-                                                  NS_LITERAL_STRING(&quot;ISO-8859-1&quot;), headerVal);</span>
<a href="#l8.686"></a><span id="l8.686" class="difflineplus">+  nsCAutoString asciiHeaderVal;</span>
<a href="#l8.687"></a><span id="l8.687" class="difflineplus">+  LossyCopyUTF16toASCII(headers-&gt;Value(CMapiMessageHeaders::hdrMessageID),</span>
<a href="#l8.688"></a><span id="l8.688" class="difflineplus">+                        asciiHeaderVal); // Message-Id cannot fold</span>
<a href="#l8.689"></a><span id="l8.689" class="difflineplus">+  m_pMsgFields-&gt;SetMessageId(asciiHeaderVal.get());</span>
<a href="#l8.690"></a><span id="l8.690" class="difflineplus">+  // We only use those headers that may need to be processed by Thunderbird</span>
<a href="#l8.691"></a><span id="l8.691" class="difflineplus">+  // to create a good rfc822 document, or need to be encoded (like To and Cc).</span>
<a href="#l8.692"></a><span id="l8.692" class="difflineplus">+  // These will replace the originals on import. All the other headers</span>
<a href="#l8.693"></a><span id="l8.693" class="difflineplus">+  // will be copied to the destination unaltered in CopyComposedMessage().</span>
<a href="#l8.694"></a><span id="l8.694" class="difflineplus">+</span>
<a href="#l8.695"></a><span id="l8.695" class="difflineplus">+  nsMsgAttachedFile *pAttach = msg.GetAttachments();</span>
<a href="#l8.696"></a><span id="l8.696" class="difflineplus">+</span>
<a href="#l8.697"></a><span id="l8.697" class="difflineplus">+  nsString bodyW;</span>
<a href="#l8.698"></a><span id="l8.698" class="difflineplus">+  // Bug 593907</span>
<a href="#l8.699"></a><span id="l8.699" class="difflineplus">+  if (GenerateHackSequence(msg.GetBody(), msg.GetBodyLen()))</span>
<a href="#l8.700"></a><span id="l8.700" class="difflineplus">+    HackBody(msg.GetBody(), msg.GetBodyLen(), bodyW);</span>
<a href="#l8.701"></a><span id="l8.701" class="difflineplus">+  // End Bug 593907</span>
<a href="#l8.702"></a><span id="l8.702" class="difflineplus">+</span>
<a href="#l8.703"></a><span id="l8.703" class="difflineplus">+  // We only get the editor interface when there's embedded content.</span>
<a href="#l8.704"></a><span id="l8.704" class="difflineplus">+  // Otherwise pEditor remains NULL. That way we only import with the pseudo</span>
<a href="#l8.705"></a><span id="l8.705" class="difflineplus">+  // editor when it helps.</span>
<a href="#l8.706"></a><span id="l8.706" class="difflineplus">+  nsRefPtr&lt;nsOutlookEditor&gt; pOutlookEditor = new nsOutlookEditor(bodyW.IsEmpty() ? msg.GetBody() : bodyW.get());</span>
<a href="#l8.707"></a><span id="l8.707" class="difflineplus">+  nsCOMPtr&lt;nsIEditor&gt; pEditor;</span>
<a href="#l8.708"></a><span id="l8.708" class="difflineplus">+</span>
<a href="#l8.709"></a><span id="l8.709" class="difflineplus">+  if (msg.BodyIsHtml()) {</span>
<a href="#l8.710"></a><span id="l8.710" class="difflineplus">+    for (unsigned int i = 0; i&lt;msg.EmbeddedAttachmentsCount(); i++) {</span>
<a href="#l8.711"></a><span id="l8.711" class="difflineplus">+      nsIURI *uri;</span>
<a href="#l8.712"></a><span id="l8.712" class="difflineplus">+      const char* cid;</span>
<a href="#l8.713"></a><span id="l8.713" class="difflineplus">+      const char* name;</span>
<a href="#l8.714"></a><span id="l8.714" class="difflineplus">+      if (msg.GetEmbeddedAttachmentInfo(i, &amp;uri, &amp;cid, &amp;name))</span>
<a href="#l8.715"></a><span id="l8.715" class="difflineplus">+        pOutlookEditor-&gt;AddEmbeddedImage(uri, NS_ConvertASCIItoUTF16(cid).get(), NS_ConvertASCIItoUTF16(name).get());</span>
<a href="#l8.716"></a><span id="l8.716">     }</span>
<a href="#l8.717"></a><span id="l8.717">   }</span>
<a href="#l8.718"></a><span id="l8.718" class="difflineminus">-  charSet = headerVal;</span>
<a href="#l8.719"></a><span id="l8.719"> </span>
<a href="#l8.720"></a><span id="l8.720" class="difflineminus">-  char *pMimeType = nsnull;</span>
<a href="#l8.721"></a><span id="l8.721" class="difflineminus">-  if (!bodyType.IsEmpty())</span>
<a href="#l8.722"></a><span id="l8.722" class="difflineminus">-    pMimeType = ToNewCString(bodyType);</span>
<a href="#l8.723"></a><span id="l8.723" class="difflineminus">-  if (!pMimeType)</span>
<a href="#l8.724"></a><span id="l8.724" class="difflineminus">-    pMimeType = NS_strdup (&quot;text/plain&quot;);</span>
<a href="#l8.725"></a><span id="l8.725" class="difflineminus">-</span>
<a href="#l8.726"></a><span id="l8.726" class="difflineminus">-  if (try_to_improve_charset &amp;&amp; strcmp (pMimeType, &quot;text/html&quot;) == 0) {</span>
<a href="#l8.727"></a><span id="l8.727" class="difflineminus">-    // get charset from HTML meta tag</span>
<a href="#l8.728"></a><span id="l8.728" class="difflineminus">-    ExtractMetaCharset (m_Body, headerVal);</span>
<a href="#l8.729"></a><span id="l8.729" class="difflineminus">-    if (headerVal.IsEmpty())</span>
<a href="#l8.730"></a><span id="l8.730" class="difflineminus">-      headerVal = charSet;</span>
<a href="#l8.731"></a><span id="l8.731" class="difflineplus">+  nsCString bodyA;</span>
<a href="#l8.732"></a><span id="l8.732" class="difflineplus">+  if (pOutlookEditor &amp;&amp; pOutlookEditor-&gt;HasEmbeddedContent()) {</span>
<a href="#l8.733"></a><span id="l8.733" class="difflineplus">+    // There's embedded content that we need to import, so query for the editor interface</span>
<a href="#l8.734"></a><span id="l8.734" class="difflineplus">+    pEditor = do_QueryObject(pOutlookEditor);</span>
<a href="#l8.735"></a><span id="l8.735">   }</span>
<a href="#l8.736"></a><span id="l8.736" class="difflineminus">-</span>
<a href="#l8.737"></a><span id="l8.737" class="difflineminus">-  m_pMsgFields-&gt;SetCharacterSet( NS_LossyConvertUTF16toASCII(headerVal).get() );</span>
<a href="#l8.738"></a><span id="l8.738" class="difflineminus">-  GetHeaderValue( m_Headers.get(), m_Headers.Length(), &quot;CC:&quot;, headerVal);</span>
<a href="#l8.739"></a><span id="l8.739" class="difflineminus">-  if (!headerVal.IsEmpty())</span>
<a href="#l8.740"></a><span id="l8.740" class="difflineminus">-    m_pMsgFields-&gt;SetCc( headerVal);</span>
<a href="#l8.741"></a><span id="l8.741" class="difflineminus">-  GetHeaderValue( m_Headers.get(), m_Headers.Length(), &quot;Message-ID:&quot;, headerVal);</span>
<a href="#l8.742"></a><span id="l8.742" class="difflineminus">-  if (!headerVal.IsEmpty()) {</span>
<a href="#l8.743"></a><span id="l8.743" class="difflineminus">-    LossyCopyUTF16toASCII(headerVal, asciiHeaderVal);</span>
<a href="#l8.744"></a><span id="l8.744" class="difflineminus">-    m_pMsgFields-&gt;SetMessageId(asciiHeaderVal.get());</span>
<a href="#l8.745"></a><span id="l8.745" class="difflineplus">+  else {</span>
<a href="#l8.746"></a><span id="l8.746" class="difflineplus">+    if (bodyW.IsEmpty())</span>
<a href="#l8.747"></a><span id="l8.747" class="difflineplus">+      msg.GetBody(bodyA);</span>
<a href="#l8.748"></a><span id="l8.748" class="difflineplus">+    else</span>
<a href="#l8.749"></a><span id="l8.749" class="difflineplus">+      nsMsgI18NConvertFromUnicode(msg.GetBodyCharset(), bodyW, bodyA);</span>
<a href="#l8.750"></a><span id="l8.750">   }</span>
<a href="#l8.751"></a><span id="l8.751" class="difflineminus">-  GetHeaderValue( m_Headers.get(), m_Headers.Length(), &quot;Reply-To:&quot;, headerVal);</span>
<a href="#l8.752"></a><span id="l8.752" class="difflineminus">-  if (!headerVal.IsEmpty())</span>
<a href="#l8.753"></a><span id="l8.753" class="difflineminus">-    m_pMsgFields-&gt;SetReplyTo( headerVal);</span>
<a href="#l8.754"></a><span id="l8.754" class="difflineminus">-</span>
<a href="#l8.755"></a><span id="l8.755" class="difflineminus">-  // what about all of the other headers?!?!?!?!?!?!</span>
<a href="#l8.756"></a><span id="l8.756" class="difflineminus">-</span>
<a href="#l8.757"></a><span id="l8.757" class="difflineminus">-  nsMsgAttachedFile *pAttach = GetLocalAttachments();</span>
<a href="#l8.758"></a><span id="l8.758" class="difflineminus">-</span>
<a href="#l8.759"></a><span id="l8.759" class="difflineminus">-  // Do body conversion here</span>
<a href="#l8.760"></a><span id="l8.760" class="difflineminus">-  nsString uniBody;</span>
<a href="#l8.761"></a><span id="l8.761" class="difflineminus">-  NS_CopyNativeToUnicode( m_Body, uniBody);</span>
<a href="#l8.762"></a><span id="l8.762" class="difflineminus">-</span>
<a href="#l8.763"></a><span id="l8.763" class="difflineminus">-  nsCString body;</span>
<a href="#l8.764"></a><span id="l8.764" class="difflineminus">-  rv = nsMsgI18NConvertFromUnicode( NS_LossyConvertUTF16toASCII(charSet).get(),</span>
<a href="#l8.765"></a><span id="l8.765" class="difflineminus">-                                    uniBody, body);</span>
<a href="#l8.766"></a><span id="l8.766" class="difflineminus">-  uniBody.Truncate();</span>
<a href="#l8.767"></a><span id="l8.767"> </span>
<a href="#l8.768"></a><span id="l8.768">   // IMPORT_LOG0( &quot;Outlook compose calling CreateAndSendMessage\n&quot;);</span>
<a href="#l8.769"></a><span id="l8.769">   rv = m_pSendProxy-&gt;CreateAndSendMessage(</span>
<a href="#l8.770"></a><span id="l8.770" class="difflineminus">-                    nsnull,                       // no editor shell</span>
<a href="#l8.771"></a><span id="l8.771" class="difflineplus">+                    pEditor,                      // editor shell</span>
<a href="#l8.772"></a><span id="l8.772">                     m_pIdentity,                  // dummy identity</span>
<a href="#l8.773"></a><span id="l8.773" class="difflineminus">-                                                                                nsnull,                         // account key</span>
<a href="#l8.774"></a><span id="l8.774" class="difflineplus">+                    nsnull,                       // account key</span>
<a href="#l8.775"></a><span id="l8.775">                     m_pMsgFields,                 // message fields</span>
<a href="#l8.776"></a><span id="l8.776">                     PR_FALSE,                     // digest = NO</span>
<a href="#l8.777"></a><span id="l8.777">                     PR_TRUE,                      // dont_deliver = YES, make a file</span>
<a href="#l8.778"></a><span id="l8.778">                     mode,                         // mode</span>
<a href="#l8.779"></a><span id="l8.779">                     nsnull,                       // no message to replace</span>
<a href="#l8.780"></a><span id="l8.780" class="difflineminus">-                    pMimeType,                    // body type</span>
<a href="#l8.781"></a><span id="l8.781" class="difflineminus">-                    NS_FAILED(rv) ? m_Body.get() : body.get(), // body pointer</span>
<a href="#l8.782"></a><span id="l8.782" class="difflineminus">-                    NS_FAILED(rv) ? m_Body.Length() : body.Length(), // body length</span>
<a href="#l8.783"></a><span id="l8.783" class="difflineplus">+                    msg.BodyIsHtml() ? &quot;text/html&quot; : &quot;text/plain&quot;,           // body type</span>
<a href="#l8.784"></a><span id="l8.784" class="difflineplus">+                    bodyA.get(),                  // body pointer</span>
<a href="#l8.785"></a><span id="l8.785" class="difflineplus">+                    bodyA.Length(),               // body length</span>
<a href="#l8.786"></a><span id="l8.786">                     nsnull,                       // remote attachment data</span>
<a href="#l8.787"></a><span id="l8.787">                     pAttach,                      // local attachments</span>
<a href="#l8.788"></a><span id="l8.788">                     nsnull,                       // related part</span>
<a href="#l8.789"></a><span id="l8.789">                     nsnull,                       // parent window</span>
<a href="#l8.790"></a><span id="l8.790">                     nsnull,                       // progress listener</span>
<a href="#l8.791"></a><span id="l8.791">                     m_pListener,                  // listener</span>
<a href="#l8.792"></a><span id="l8.792">                     nsnull,                       // password</span>
<a href="#l8.793"></a><span id="l8.793">                     EmptyCString(),               // originalMsgURI</span>
<a href="#l8.794"></a><span id="l8.794">                     nsnull);                      // message compose type</span>
<a href="#l8.795"></a><span id="l8.795">   // IMPORT_LOG0( &quot;Returned from CreateAndSendMessage\n&quot;);</span>
<a href="#l8.796"></a><span id="l8.796"> </span>
<a href="#l8.797"></a><span id="l8.797" class="difflineminus">-  if (pAttach)</span>
<a href="#l8.798"></a><span id="l8.798" class="difflineminus">-    delete [] pAttach;</span>
<a href="#l8.799"></a><span id="l8.799" class="difflineminus">-</span>
<a href="#l8.800"></a><span id="l8.800">   OutlookSendListener *pListen = (OutlookSendListener *)m_pListener;</span>
<a href="#l8.801"></a><span id="l8.801" class="difflineminus">-  if (NS_FAILED( rv)) {</span>
<a href="#l8.802"></a><span id="l8.802" class="difflineplus">+  if (NS_FAILED(rv)) {</span>
<a href="#l8.803"></a><span id="l8.803">     IMPORT_LOG1( &quot;*** Error, CreateAndSendMessage FAILED: 0x%lx\n&quot;, rv);</span>
<a href="#l8.804"></a><span id="l8.804">   }</span>
<a href="#l8.805"></a><span id="l8.805">   else {</span>
<a href="#l8.806"></a><span id="l8.806">     // wait for the listener to get done!</span>
<a href="#l8.807"></a><span id="l8.807">     PRInt32 abortCnt = 0;</span>
<a href="#l8.808"></a><span id="l8.808">     PRInt32 cnt = 0;</span>
<a href="#l8.809"></a><span id="l8.809">     PRInt32 sleepCnt = 1;</span>
<a href="#l8.810"></a><span id="l8.810">     while (!pListen-&gt;m_done &amp;&amp; (abortCnt &lt; kHungAbortCount)) {</span>
<a href="#l8.811"></a><span id="l8.811" class="difflineminus">-      PR_Sleep( sleepCnt);</span>
<a href="#l8.812"></a><span id="l8.812" class="difflineplus">+      PR_Sleep(sleepCnt);</span>
<a href="#l8.813"></a><span id="l8.813">       cnt++;</span>
<a href="#l8.814"></a><span id="l8.814">       if (cnt &gt; kHungCount) {</span>
<a href="#l8.815"></a><span id="l8.815">         abortCnt++;</span>
<a href="#l8.816"></a><span id="l8.816">         sleepCnt *= 2;</span>
<a href="#l8.817"></a><span id="l8.817">         cnt = 0;</span>
<a href="#l8.818"></a><span id="l8.818">       }</span>
<a href="#l8.819"></a><span id="l8.819">     }</span>
<a href="#l8.820"></a><span id="l8.820"> </span>
<a href="#l8.821"></a><span id="l8.821">     if (abortCnt &gt;= kHungAbortCount) {</span>
<a href="#l8.822"></a><span id="l8.822">       IMPORT_LOG0( &quot;**** Create and send message hung\n&quot;);</span>
<a href="#l8.823"></a><span id="l8.823" class="difflineminus">-      IMPORT_LOG1( &quot;Headers: %s\n&quot;, m_Headers.get());</span>
<a href="#l8.824"></a><span id="l8.824" class="difflineminus">-      IMPORT_LOG1( &quot;Body: %s\n&quot;, m_Body.get());</span>
<a href="#l8.825"></a><span id="l8.825" class="difflineplus">+//      IMPORT_LOG1( &quot;Headers: %s\n&quot;, m_Headers.get());</span>
<a href="#l8.826"></a><span id="l8.826" class="difflineplus">+//      IMPORT_LOG1( &quot;Body: %s\n&quot;, m_Body.get());</span>
<a href="#l8.827"></a><span id="l8.827">       rv = NS_ERROR_FAILURE;</span>
<a href="#l8.828"></a><span id="l8.828">     }</span>
<a href="#l8.829"></a><span id="l8.829" class="difflineminus">-</span>
<a href="#l8.830"></a><span id="l8.830">   }</span>
<a href="#l8.831"></a><span id="l8.831"> </span>
<a href="#l8.832"></a><span id="l8.832" class="difflineminus">-  if (pMimeType)</span>
<a href="#l8.833"></a><span id="l8.833" class="difflineminus">-    NS_Free( pMimeType);</span>
<a href="#l8.834"></a><span id="l8.834" class="difflineplus">+  if (pAttach)</span>
<a href="#l8.835"></a><span id="l8.835" class="difflineplus">+    msg.DisposeAttachments(pAttach);</span>
<a href="#l8.836"></a><span id="l8.836"> </span>
<a href="#l8.837"></a><span id="l8.837">   if (pListen-&gt;m_location) {</span>
<a href="#l8.838"></a><span id="l8.838">     pListen-&gt;m_location-&gt;Clone(pMsg);</span>
<a href="#l8.839"></a><span id="l8.839">     rv = NS_OK;</span>
<a href="#l8.840"></a><span id="l8.840">   }</span>
<a href="#l8.841"></a><span id="l8.841">   else {</span>
<a href="#l8.842"></a><span id="l8.842">     rv = NS_ERROR_FAILURE;</span>
<a href="#l8.843"></a><span id="l8.843">     IMPORT_LOG0( &quot;*** Error, Outlook compose unsuccessful\n&quot;);</span>
<a href="#l8.844"></a><span id="l8.844">   }</span>
<a href="#l8.845"></a><span id="l8.845"> </span>
<a href="#l8.846"></a><span id="l8.846">   pListen-&gt;Reset();</span>
<a href="#l8.847"></a><span id="l8.847"> </span>
<a href="#l8.848"></a><span id="l8.848" class="difflineminus">-  return( rv);</span>
<a href="#l8.849"></a><span id="l8.849" class="difflineminus">-}</span>
<a href="#l8.850"></a><span id="l8.850" class="difflineminus">-</span>
<a href="#l8.851"></a><span id="l8.851" class="difflineminus">-</span>
<a href="#l8.852"></a><span id="l8.852" class="difflineminus">-PRBool SimpleBufferTonyRCopiedTwice::SpecialMemCpy( PRInt32 offset, const char *pData, PRInt32 len, PRInt32 *pWritten)</span>
<a href="#l8.853"></a><span id="l8.853" class="difflineminus">-{</span>
<a href="#l8.854"></a><span id="l8.854" class="difflineminus">-  // Arg!!!!!  Mozilla can't handle plain CRs in any mail messages.  Particularly a</span>
<a href="#l8.855"></a><span id="l8.855" class="difflineminus">-  // problem with Eudora since it doesn't give a rats a**</span>
<a href="#l8.856"></a><span id="l8.856" class="difflineminus">-  *pWritten = len;</span>
<a href="#l8.857"></a><span id="l8.857" class="difflineminus">-  PRInt32  sz = offset + len;</span>
<a href="#l8.858"></a><span id="l8.858" class="difflineminus">-  if (offset) {</span>
<a href="#l8.859"></a><span id="l8.859" class="difflineminus">-    if ((m_pBuffer[offset - 1] == 0x0D) &amp;&amp; (*pData != 0x0A)) {</span>
<a href="#l8.860"></a><span id="l8.860" class="difflineminus">-      sz++;</span>
<a href="#l8.861"></a><span id="l8.861" class="difflineminus">-      if (!Grow( sz)) return( PR_FALSE);</span>
<a href="#l8.862"></a><span id="l8.862" class="difflineminus">-      m_pBuffer[offset] = 0x0A;</span>
<a href="#l8.863"></a><span id="l8.863" class="difflineminus">-      offset++;</span>
<a href="#l8.864"></a><span id="l8.864" class="difflineminus">-      (*pWritten)++;</span>
<a href="#l8.865"></a><span id="l8.865" class="difflineminus">-    }</span>
<a href="#l8.866"></a><span id="l8.866" class="difflineminus">-  }</span>
<a href="#l8.867"></a><span id="l8.867" class="difflineminus">-  while (len &gt; 0) {</span>
<a href="#l8.868"></a><span id="l8.868" class="difflineminus">-    if ((*pData == 0x0D) &amp;&amp; (*(pData + 1) != 0x0A)) {</span>
<a href="#l8.869"></a><span id="l8.869" class="difflineminus">-      sz++;</span>
<a href="#l8.870"></a><span id="l8.870" class="difflineminus">-      if (!Grow( sz)) return( PR_FALSE);</span>
<a href="#l8.871"></a><span id="l8.871" class="difflineminus">-      m_pBuffer[offset] = 0x0D;</span>
<a href="#l8.872"></a><span id="l8.872" class="difflineminus">-      offset++;</span>
<a href="#l8.873"></a><span id="l8.873" class="difflineminus">-      m_pBuffer[offset] = 0x0A;</span>
<a href="#l8.874"></a><span id="l8.874" class="difflineminus">-      (*pWritten)++;</span>
<a href="#l8.875"></a><span id="l8.875" class="difflineminus">-    }</span>
<a href="#l8.876"></a><span id="l8.876" class="difflineminus">-    else {</span>
<a href="#l8.877"></a><span id="l8.877" class="difflineminus">-      m_pBuffer[offset] = *pData;</span>
<a href="#l8.878"></a><span id="l8.878" class="difflineminus">-    }</span>
<a href="#l8.879"></a><span id="l8.879" class="difflineminus">-    offset++;</span>
<a href="#l8.880"></a><span id="l8.880" class="difflineminus">-    pData++;</span>
<a href="#l8.881"></a><span id="l8.881" class="difflineminus">-    len--;</span>
<a href="#l8.882"></a><span id="l8.882" class="difflineminus">-  }</span>
<a href="#l8.883"></a><span id="l8.883" class="difflineminus">-</span>
<a href="#l8.884"></a><span id="l8.884" class="difflineminus">-  return PR_TRUE;</span>
<a href="#l8.885"></a><span id="l8.885" class="difflineminus">-}</span>
<a href="#l8.886"></a><span id="l8.886" class="difflineminus">-</span>
<a href="#l8.887"></a><span id="l8.887" class="difflineminus">-nsresult nsOutlookCompose::ReadHeaders( ReadFileState *pState, SimpleBufferTonyRCopiedTwice&amp; copy, SimpleBufferTonyRCopiedTwice&amp; header)</span>
<a href="#l8.888"></a><span id="l8.888" class="difflineminus">-{</span>
<a href="#l8.889"></a><span id="l8.889" class="difflineminus">-  // This should be the headers...</span>
<a href="#l8.890"></a><span id="l8.890" class="difflineminus">-  header.m_writeOffset = 0;</span>
<a href="#l8.891"></a><span id="l8.891" class="difflineminus">-</span>
<a href="#l8.892"></a><span id="l8.892" class="difflineminus">-  nsresult rv;</span>
<a href="#l8.893"></a><span id="l8.893" class="difflineminus">-  PRInt32 lineLen;</span>
<a href="#l8.894"></a><span id="l8.894" class="difflineminus">-  PRInt32 endLen = -1;</span>
<a href="#l8.895"></a><span id="l8.895" class="difflineminus">-  PRInt8 endBuffer = 0;</span>
<a href="#l8.896"></a><span id="l8.896" class="difflineminus">-</span>
<a href="#l8.897"></a><span id="l8.897" class="difflineminus">-  while ((endLen = IsEndHeaders( copy)) == -1) {</span>
<a href="#l8.898"></a><span id="l8.898" class="difflineminus">-    while ((lineLen = FindNextEndLine( copy)) == -1) {</span>
<a href="#l8.899"></a><span id="l8.899" class="difflineminus">-      copy.m_writeOffset = copy.m_bytesInBuf;</span>
<a href="#l8.900"></a><span id="l8.900" class="difflineminus">-      if (!header.Write( copy.m_pBuffer, copy.m_writeOffset)) {</span>
<a href="#l8.901"></a><span id="l8.901" class="difflineminus">-        IMPORT_LOG0( &quot;*** ERROR, writing headers\n&quot;);</span>
<a href="#l8.902"></a><span id="l8.902" class="difflineminus">-        return( NS_ERROR_FAILURE);</span>
<a href="#l8.903"></a><span id="l8.903" class="difflineminus">-      }</span>
<a href="#l8.904"></a><span id="l8.904" class="difflineminus">-      if (NS_FAILED( rv = FillMailBuffer( pState, copy))) {</span>
<a href="#l8.905"></a><span id="l8.905" class="difflineminus">-        IMPORT_LOG0( &quot;*** Error reading message headers\n&quot;);</span>
<a href="#l8.906"></a><span id="l8.906" class="difflineminus">-        return( rv);</span>
<a href="#l8.907"></a><span id="l8.907" class="difflineminus">-      }</span>
<a href="#l8.908"></a><span id="l8.908" class="difflineminus">-      if (!copy.m_bytesInBuf) {</span>
<a href="#l8.909"></a><span id="l8.909" class="difflineminus">-        IMPORT_LOG0( &quot;*** Error, end of file while reading headers\n&quot;);</span>
<a href="#l8.910"></a><span id="l8.910" class="difflineminus">-        return( NS_ERROR_FAILURE);</span>
<a href="#l8.911"></a><span id="l8.911" class="difflineminus">-      }</span>
<a href="#l8.912"></a><span id="l8.912" class="difflineminus">-    }</span>
<a href="#l8.913"></a><span id="l8.913" class="difflineminus">-    copy.m_writeOffset += lineLen;</span>
<a href="#l8.914"></a><span id="l8.914" class="difflineminus">-    if ((copy.m_writeOffset + 4) &gt;= copy.m_bytesInBuf) {</span>
<a href="#l8.915"></a><span id="l8.915" class="difflineminus">-      if (!header.Write( copy.m_pBuffer, copy.m_writeOffset)) {</span>
<a href="#l8.916"></a><span id="l8.916" class="difflineminus">-        IMPORT_LOG0( &quot;*** ERROR, writing headers 2\n&quot;);</span>
<a href="#l8.917"></a><span id="l8.917" class="difflineminus">-        return( NS_ERROR_FAILURE);</span>
<a href="#l8.918"></a><span id="l8.918" class="difflineminus">-      }</span>
<a href="#l8.919"></a><span id="l8.919" class="difflineminus">-      if (NS_FAILED( rv = FillMailBuffer( pState, copy))) {</span>
<a href="#l8.920"></a><span id="l8.920" class="difflineminus">-        IMPORT_LOG0( &quot;*** Error reading message headers 2\n&quot;);</span>
<a href="#l8.921"></a><span id="l8.921" class="difflineminus">-        return( rv);</span>
<a href="#l8.922"></a><span id="l8.922" class="difflineminus">-      }</span>
<a href="#l8.923"></a><span id="l8.923" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; pEditor) {</span>
<a href="#l8.924"></a><span id="l8.924" class="difflineplus">+    PRUint32 embedCount = pOutlookEditor-&gt;EmbeddedObjectsCount();</span>
<a href="#l8.925"></a><span id="l8.925" class="difflineplus">+    for (PRUint32 i=0; i&lt;embedCount; i++) {</span>
<a href="#l8.926"></a><span id="l8.926" class="difflineplus">+      CidReplacePair *pair = new CidReplacePair;</span>
<a href="#l8.927"></a><span id="l8.927" class="difflineplus">+      if (NS_SUCCEEDED(pOutlookEditor-&gt;GetCids(i, pair-&gt;cidOrig, pair-&gt;cidNew)))</span>
<a href="#l8.928"></a><span id="l8.928" class="difflineplus">+        m_replacedCids.push_back(pair);</span>
<a href="#l8.929"></a><span id="l8.929" class="difflineplus">+      else delete pair;</span>
<a href="#l8.930"></a><span id="l8.930">     }</span>
<a href="#l8.931"></a><span id="l8.931">   }</span>
<a href="#l8.932"></a><span id="l8.932"> </span>
<a href="#l8.933"></a><span id="l8.933" class="difflineminus">-  if (!header.Write( copy.m_pBuffer, copy.m_writeOffset)) {</span>
<a href="#l8.934"></a><span id="l8.934" class="difflineminus">-    IMPORT_LOG0( &quot;*** Error writing final headers\n&quot;);</span>
<a href="#l8.935"></a><span id="l8.935" class="difflineminus">-    return( NS_ERROR_FAILURE);</span>
<a href="#l8.936"></a><span id="l8.936" class="difflineminus">-  }</span>
<a href="#l8.937"></a><span id="l8.937" class="difflineminus">-  if (!header.Write( (const char *)&amp;endBuffer, 1)) {</span>
<a href="#l8.938"></a><span id="l8.938" class="difflineminus">-    IMPORT_LOG0( &quot;*** Error writing header trailing null\n&quot;);</span>
<a href="#l8.939"></a><span id="l8.939" class="difflineminus">-    return( NS_ERROR_FAILURE);</span>
<a href="#l8.940"></a><span id="l8.940" class="difflineminus">-  }</span>
<a href="#l8.941"></a><span id="l8.941" class="difflineplus">+  return rv;</span>
<a href="#l8.942"></a><span id="l8.942" class="difflineplus">+}</span>
<a href="#l8.943"></a><span id="l8.943"> </span>
<a href="#l8.944"></a><span id="l8.944" class="difflineminus">-  copy.m_writeOffset += endLen;</span>
<a href="#l8.945"></a><span id="l8.945" class="difflineminus">-</span>
<a href="#l8.946"></a><span id="l8.946" class="difflineminus">-  return( NS_OK);</span>
<a href="#l8.947"></a><span id="l8.947" class="difflineplus">+nsOutlookCompose::ReplaceCidInLine::ReplaceCidInLine(nsCString&amp; line)</span>
<a href="#l8.948"></a><span id="l8.948" class="difflineplus">+  : m_line(line)</span>
<a href="#l8.949"></a><span id="l8.949" class="difflineplus">+{</span>
<a href="#l8.950"></a><span id="l8.950" class="difflineplus">+  // If the line begins with Content-ID: string, process it! Otherwise, no need to waste time</span>
<a href="#l8.951"></a><span id="l8.951" class="difflineplus">+  m_finishedReplacing = (line.Compare(&quot;Content-ID:&quot;, PR_TRUE, 11) != 0);</span>
<a href="#l8.952"></a><span id="l8.952"> }</span>
<a href="#l8.953"></a><span id="l8.953"> </span>
<a href="#l8.954"></a><span id="l8.954" class="difflineminus">-PRInt32 nsOutlookCompose::FindNextEndLine( SimpleBufferTonyRCopiedTwice&amp; data)</span>
<a href="#l8.955"></a><span id="l8.955" class="difflineplus">+void nsOutlookCompose::ReplaceCidInLine::operator () (const CidReplacePair* pair)</span>
<a href="#l8.956"></a><span id="l8.956"> {</span>
<a href="#l8.957"></a><span id="l8.957" class="difflineminus">-  PRInt32 len = data.m_bytesInBuf - data.m_writeOffset;</span>
<a href="#l8.958"></a><span id="l8.958" class="difflineminus">-  if (!len)</span>
<a href="#l8.959"></a><span id="l8.959" class="difflineminus">-    return( -1);</span>
<a href="#l8.960"></a><span id="l8.960" class="difflineminus">-  PRInt32  count = 0;</span>
<a href="#l8.961"></a><span id="l8.961" class="difflineminus">-  const char *pData = data.m_pBuffer + data.m_writeOffset;</span>
<a href="#l8.962"></a><span id="l8.962" class="difflineminus">-  while (((*pData == 0x0D) || (*pData == 0x0A)) &amp;&amp; (count &lt; len)) {</span>
<a href="#l8.963"></a><span id="l8.963" class="difflineminus">-    pData++;</span>
<a href="#l8.964"></a><span id="l8.964" class="difflineminus">-    count++;</span>
<a href="#l8.965"></a><span id="l8.965" class="difflineplus">+  if (m_finishedReplacing)</span>
<a href="#l8.966"></a><span id="l8.966" class="difflineplus">+    return; // Only one cid per line possible!</span>
<a href="#l8.967"></a><span id="l8.967" class="difflineplus">+  PRInt32 pos = m_line.Find(pair-&gt;cidNew, PR_FALSE, 12);</span>
<a href="#l8.968"></a><span id="l8.968" class="difflineplus">+  if (pos != kNotFound) {</span>
<a href="#l8.969"></a><span id="l8.969" class="difflineplus">+    m_finishedReplacing = true; // Stop further search</span>
<a href="#l8.970"></a><span id="l8.970" class="difflineplus">+    m_line.Replace(pos, pair-&gt;cidNew.Length(), pair-&gt;cidOrig);</span>
<a href="#l8.971"></a><span id="l8.971">   }</span>
<a href="#l8.972"></a><span id="l8.972" class="difflineminus">-  while ((*pData != 0x0D) &amp;&amp; (*pData != 0x0A) &amp;&amp; (count &lt; len)) {</span>
<a href="#l8.973"></a><span id="l8.973" class="difflineminus">-    pData++;</span>
<a href="#l8.974"></a><span id="l8.974" class="difflineminus">-    count++;</span>
<a href="#l8.975"></a><span id="l8.975" class="difflineminus">-  }</span>
<a href="#l8.976"></a><span id="l8.976" class="difflineminus">-</span>
<a href="#l8.977"></a><span id="l8.977" class="difflineminus">-  if (count &lt; len)</span>
<a href="#l8.978"></a><span id="l8.978" class="difflineminus">-    return( count);</span>
<a href="#l8.979"></a><span id="l8.979" class="difflineminus">-</span>
<a href="#l8.980"></a><span id="l8.980" class="difflineminus">-  return( -1);</span>
<a href="#l8.981"></a><span id="l8.981"> }</span>
<a href="#l8.982"></a><span id="l8.982"> </span>
<a href="#l8.983"></a><span id="l8.983" class="difflineminus">-PRInt32 nsOutlookCompose::IsEndHeaders( SimpleBufferTonyRCopiedTwice&amp; data)</span>
<a href="#l8.984"></a><span id="l8.984" class="difflineplus">+nsresult nsOutlookCompose::CopyComposedMessage(nsIFile *pSrc,</span>
<a href="#l8.985"></a><span id="l8.985" class="difflineplus">+                                               nsIOutputStream *pDst,</span>
<a href="#l8.986"></a><span id="l8.986" class="difflineplus">+                                               CMapiMessage&amp; origMsg)</span>
<a href="#l8.987"></a><span id="l8.987"> {</span>
<a href="#l8.988"></a><span id="l8.988" class="difflineminus">-  PRInt32 len = data.m_bytesInBuf - data.m_writeOffset;</span>
<a href="#l8.989"></a><span id="l8.989" class="difflineminus">-  if (len &lt; 2)</span>
<a href="#l8.990"></a><span id="l8.990" class="difflineminus">-    return( -1);</span>
<a href="#l8.991"></a><span id="l8.991" class="difflineminus">-  const char *pChar = data.m_pBuffer + data.m_writeOffset;</span>
<a href="#l8.992"></a><span id="l8.992" class="difflineminus">-  if ((*pChar == 0x0D) &amp;&amp; (*(pChar + 1) == 0x0D))</span>
<a href="#l8.993"></a><span id="l8.993" class="difflineminus">-    return( 2);</span>
<a href="#l8.994"></a><span id="l8.994" class="difflineminus">-</span>
<a href="#l8.995"></a><span id="l8.995" class="difflineminus">-  if (len &lt; 4)</span>
<a href="#l8.996"></a><span id="l8.996" class="difflineminus">-    return( -1);</span>
<a href="#l8.997"></a><span id="l8.997" class="difflineminus">-  if ((*pChar == 0x0D) &amp;&amp; (*(pChar + 1) == 0x0A) &amp;&amp;</span>
<a href="#l8.998"></a><span id="l8.998" class="difflineminus">-    (*(pChar + 2) == 0x0D) &amp;&amp; (*(pChar + 3) == 0x0A))</span>
<a href="#l8.999"></a><span id="l8.999" class="difflineminus">-    return( 4);</span>
<a href="#l8.1000"></a><span id="l8.1000" class="difflineminus">-</span>
<a href="#l8.1001"></a><span id="l8.1001" class="difflineminus">-  return( -1);</span>
<a href="#l8.1002"></a><span id="l8.1002" class="difflineminus">-}</span>
<a href="#l8.1003"></a><span id="l8.1003" class="difflineminus">-</span>
<a href="#l8.1004"></a><span id="l8.1004" class="difflineminus">-</span>
<a href="#l8.1005"></a><span id="l8.1005" class="difflineminus">-nsresult nsOutlookCompose::CopyComposedMessage( nsCString&amp; fromLine, nsIFile *pSrc, nsIOutputStream *pDst, SimpleBufferTonyRCopiedTwice&amp; copy)</span>
<a href="#l8.1006"></a><span id="l8.1006" class="difflineminus">-{</span>
<a href="#l8.1007"></a><span id="l8.1007" class="difflineminus">-  copy.m_bytesInBuf = 0;</span>
<a href="#l8.1008"></a><span id="l8.1008" class="difflineminus">-  copy.m_writeOffset = 0;</span>
<a href="#l8.1009"></a><span id="l8.1009" class="difflineminus">-  ReadFileState  state;</span>
<a href="#l8.1010"></a><span id="l8.1010" class="difflineminus">-  state.pFile = pSrc;</span>
<a href="#l8.1011"></a><span id="l8.1011" class="difflineminus">-  state.offset = 0;</span>
<a href="#l8.1012"></a><span id="l8.1012" class="difflineminus">-  state.size = 0;</span>
<a href="#l8.1013"></a><span id="l8.1013" class="difflineminus">-  pSrc-&gt;GetFileSize( &amp;state.size);</span>
<a href="#l8.1014"></a><span id="l8.1014" class="difflineminus">-  if (!state.size) {</span>
<a href="#l8.1015"></a><span id="l8.1015" class="difflineplus">+  // I'm unsure if we really need the convertCRs feature here.</span>
<a href="#l8.1016"></a><span id="l8.1016" class="difflineplus">+  // The headers in the file are generated by TB, the body was generated by rtf reader that always used CRLF,</span>
<a href="#l8.1017"></a><span id="l8.1017" class="difflineplus">+  // and the attachments were processed by TB either... However, I let it stay as it was in the original code.</span>
<a href="#l8.1018"></a><span id="l8.1018" class="difflineplus">+  CCompositionFile f(pSrc, m_optimizationBuffer, m_optimizationBufferSize, true);</span>
<a href="#l8.1019"></a><span id="l8.1019" class="difflineplus">+  if (!f) {</span>
<a href="#l8.1020"></a><span id="l8.1020">     IMPORT_LOG0( &quot;*** Error, unexpected zero file size for composed message\n&quot;);</span>
<a href="#l8.1021"></a><span id="l8.1021" class="difflineminus">-    return( NS_ERROR_FAILURE);</span>
<a href="#l8.1022"></a><span id="l8.1022" class="difflineplus">+    return NS_ERROR_FAILURE;</span>
<a href="#l8.1023"></a><span id="l8.1023">   }</span>
<a href="#l8.1024"></a><span id="l8.1024"> </span>
<a href="#l8.1025"></a><span id="l8.1025" class="difflineminus">-        nsresult rv = NS_NewLocalFileInputStream(getter_AddRefs(state.pInputStream), pSrc);</span>
<a href="#l8.1026"></a><span id="l8.1026" class="difflineminus">-  if (NS_FAILED( rv)) {</span>
<a href="#l8.1027"></a><span id="l8.1027" class="difflineminus">-    IMPORT_LOG0( &quot;*** Error, unable to open composed message file\n&quot;);</span>
<a href="#l8.1028"></a><span id="l8.1028" class="difflineminus">-    return( NS_ERROR_FAILURE);</span>
<a href="#l8.1029"></a><span id="l8.1029" class="difflineminus">-  }</span>
<a href="#l8.1030"></a><span id="l8.1030" class="difflineplus">+  // The &quot;From ...&quot; separates the messages. Without it, TB cannot see the messages in the mailbox file.</span>
<a href="#l8.1031"></a><span id="l8.1031" class="difflineplus">+  // Thus, the lines that look like &quot;From ...&quot; in the message must be escaped (see EscapeFromSpaceLine())</span>
<a href="#l8.1032"></a><span id="l8.1032" class="difflineplus">+  int fromLineLen;</span>
<a href="#l8.1033"></a><span id="l8.1033" class="difflineplus">+  const char* fromLine = origMsg.GetFromLine(fromLineLen);</span>
<a href="#l8.1034"></a><span id="l8.1034" class="difflineplus">+  PRUint32 written;</span>
<a href="#l8.1035"></a><span id="l8.1035" class="difflineplus">+  nsresult rv = pDst-&gt;Write( fromLine, fromLineLen, &amp;written);</span>
<a href="#l8.1036"></a><span id="l8.1036"> </span>
<a href="#l8.1037"></a><span id="l8.1037" class="difflineminus">-  PRUint32 written;</span>
<a href="#l8.1038"></a><span id="l8.1038" class="difflineminus">-  rv = pDst-&gt;Write( fromLine.get(), fromLine.Length(), &amp;written);</span>
<a href="#l8.1039"></a><span id="l8.1039" class="difflineplus">+  // Bug 219269</span>
<a href="#l8.1040"></a><span id="l8.1040" class="difflineplus">+  // Write out the x-mozilla-status headers.</span>
<a href="#l8.1041"></a><span id="l8.1041" class="difflineplus">+  char statusLine[50];</span>
<a href="#l8.1042"></a><span id="l8.1042" class="difflineplus">+  PRUint32 msgFlags = 0;</span>
<a href="#l8.1043"></a><span id="l8.1043" class="difflineplus">+  if (origMsg.IsRead())</span>
<a href="#l8.1044"></a><span id="l8.1044" class="difflineplus">+    msgFlags |= nsMsgMessageFlags::Read;</span>
<a href="#l8.1045"></a><span id="l8.1045" class="difflineplus">+  if (!origMsg.FullMessageDownloaded())</span>
<a href="#l8.1046"></a><span id="l8.1046" class="difflineplus">+    msgFlags |= nsMsgMessageFlags::Partial;</span>
<a href="#l8.1047"></a><span id="l8.1047" class="difflineplus">+  if (origMsg.IsForvarded())</span>
<a href="#l8.1048"></a><span id="l8.1048" class="difflineplus">+    msgFlags |= nsMsgMessageFlags::Forwarded;</span>
<a href="#l8.1049"></a><span id="l8.1049" class="difflineplus">+  if (origMsg.IsReplied())</span>
<a href="#l8.1050"></a><span id="l8.1050" class="difflineplus">+    msgFlags |= nsMsgMessageFlags::Replied;</span>
<a href="#l8.1051"></a><span id="l8.1051" class="difflineplus">+  if (origMsg.HasAttach())</span>
<a href="#l8.1052"></a><span id="l8.1052" class="difflineplus">+    msgFlags |= nsMsgMessageFlags::Attachment;</span>
<a href="#l8.1053"></a><span id="l8.1053" class="difflineplus">+  _snprintf(statusLine, sizeof(statusLine), X_MOZILLA_STATUS_FORMAT MSG_LINEBREAK, msgFlags &amp; 0xFFFF);</span>
<a href="#l8.1054"></a><span id="l8.1054" class="difflineplus">+  rv = pDst-&gt;Write(statusLine, strlen(statusLine), &amp;written);</span>
<a href="#l8.1055"></a><span id="l8.1055" class="difflineplus">+  _snprintf(statusLine, sizeof(statusLine), X_MOZILLA_STATUS2_FORMAT MSG_LINEBREAK, msgFlags &amp; 0xFFFF0000);</span>
<a href="#l8.1056"></a><span id="l8.1056" class="difflineplus">+  rv = pDst-&gt;Write(statusLine, strlen(statusLine), &amp;written);</span>
<a href="#l8.1057"></a><span id="l8.1057" class="difflineplus">+  // End Bug 219269</span>
<a href="#l8.1058"></a><span id="l8.1058"> </span>
<a href="#l8.1059"></a><span id="l8.1059">   // well, isn't this a hoot!</span>
<a href="#l8.1060"></a><span id="l8.1060">   // Read the headers from the new message, get the ones we like</span>
<a href="#l8.1061"></a><span id="l8.1061">   // and write out only the headers we want from the new message,</span>
<a href="#l8.1062"></a><span id="l8.1062">   // along with all of the other headers from the &quot;old&quot; message!</span>
<a href="#l8.1063"></a><span id="l8.1063" class="difflineminus">-  if (NS_SUCCEEDED( rv))</span>
<a href="#l8.1064"></a><span id="l8.1064" class="difflineminus">-    rv = FillMailBuffer( &amp;state, copy);</span>
<a href="#l8.1065"></a><span id="l8.1065" class="difflineminus">-  if (NS_SUCCEEDED( rv))</span>
<a href="#l8.1066"></a><span id="l8.1066" class="difflineminus">-    rv = ReadHeaders( &amp;state, copy, m_readHeaders);</span>
<a href="#l8.1067"></a><span id="l8.1067" class="difflineplus">+</span>
<a href="#l8.1068"></a><span id="l8.1068" class="difflineplus">+  nsCString newHeadersStr;</span>
<a href="#l8.1069"></a><span id="l8.1069" class="difflineplus">+  rv = f.ToString(newHeadersStr, MSG_LINEBREAK MSG_LINEBREAK); // Read all the headers</span>
<a href="#l8.1070"></a><span id="l8.1070" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l8.1071"></a><span id="l8.1071" class="difflineplus">+  UpdateHeaders(*origMsg.GetHeaders(), newHeadersStr.get());</span>
<a href="#l8.1072"></a><span id="l8.1072" class="difflineplus">+  rv = origMsg.GetHeaders()-&gt;ToStream(pDst);</span>
<a href="#l8.1073"></a><span id="l8.1073" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l8.1074"></a><span id="l8.1074"> </span>
<a href="#l8.1075"></a><span id="l8.1075" class="difflineminus">-  if (NS_SUCCEEDED( rv)) {</span>
<a href="#l8.1076"></a><span id="l8.1076" class="difflineminus">-    rv = WriteHeaders( pDst, m_readHeaders);</span>
<a href="#l8.1077"></a><span id="l8.1077" class="difflineplus">+  // Bug 593907</span>
<a href="#l8.1078"></a><span id="l8.1078" class="difflineplus">+  if (!m_hackedPostfix.IsEmpty()) {</span>
<a href="#l8.1079"></a><span id="l8.1079" class="difflineplus">+    nsCString hackedPartEnd;</span>
<a href="#l8.1080"></a><span id="l8.1080" class="difflineplus">+    LossyCopyUTF16toASCII(m_hackedPostfix, hackedPartEnd);</span>
<a href="#l8.1081"></a><span id="l8.1081" class="difflineplus">+    hackedPartEnd.Insert(hackEndA, 0);</span>
<a href="#l8.1082"></a><span id="l8.1082" class="difflineplus">+    nsCString body;</span>
<a href="#l8.1083"></a><span id="l8.1083" class="difflineplus">+    rv = f.ToString(body, hackedPartEnd.get(), hackedPartEnd.Length());</span>
<a href="#l8.1084"></a><span id="l8.1084" class="difflineplus">+    UnhackBody(body);</span>
<a href="#l8.1085"></a><span id="l8.1085" class="difflineplus">+    EscapeFromSpaceLine(pDst, const_cast&lt;char*&gt;(body.get()), body.get()+body.Length());</span>
<a href="#l8.1086"></a><span id="l8.1086" class="difflineplus">+  }</span>
<a href="#l8.1087"></a><span id="l8.1087" class="difflineplus">+  // End Bug 593907</span>
<a href="#l8.1088"></a><span id="l8.1088" class="difflineplus">+</span>
<a href="#l8.1089"></a><span id="l8.1089" class="difflineplus">+  // I use the terminating sequence here to avoid a possible situation when a &quot;From &quot; line</span>
<a href="#l8.1090"></a><span id="l8.1090" class="difflineplus">+  // gets split over two sequential reads and thus will not be escaped.</span>
<a href="#l8.1091"></a><span id="l8.1091" class="difflineplus">+  // This is done by reading up to CRLF (one line every time), though it may be slower</span>
<a href="#l8.1092"></a><span id="l8.1092" class="difflineplus">+</span>
<a href="#l8.1093"></a><span id="l8.1093" class="difflineplus">+  // Here I revert the changes that were made when the multipart/related message</span>
<a href="#l8.1094"></a><span id="l8.1094" class="difflineplus">+  // was composed in nsMsgSend::ProcessMultipartRelated() - the Content-Ids of</span>
<a href="#l8.1095"></a><span id="l8.1095" class="difflineplus">+  // attachments were replaced with new ones.</span>
<a href="#l8.1096"></a><span id="l8.1096" class="difflineplus">+  nsCString line;</span>
<a href="#l8.1097"></a><span id="l8.1097" class="difflineplus">+  while (NS_SUCCEEDED(f.ToString(line, MSG_LINEBREAK))) {</span>
<a href="#l8.1098"></a><span id="l8.1098" class="difflineplus">+    if (!m_replacedCids.empty())</span>
<a href="#l8.1099"></a><span id="l8.1099" class="difflineplus">+      std::for_each(m_replacedCids.begin(), m_replacedCids.end(), ReplaceCidInLine(line));</span>
<a href="#l8.1100"></a><span id="l8.1100" class="difflineplus">+    EscapeFromSpaceLine(pDst, const_cast&lt;char*&gt;(line.get()), line.get()+line.Length());</span>
<a href="#l8.1101"></a><span id="l8.1101">   }</span>
<a href="#l8.1102"></a><span id="l8.1102"> </span>
<a href="#l8.1103"></a><span id="l8.1103" class="difflineminus">-  // We need to go ahead and write out the rest of the copy buffer</span>
<a href="#l8.1104"></a><span id="l8.1104" class="difflineminus">-  // so that the following will properly copy the rest of the body</span>
<a href="#l8.1105"></a><span id="l8.1105" class="difflineminus">-  char lastChar = 0;</span>
<a href="#l8.1106"></a><span id="l8.1106" class="difflineminus">-</span>
<a href="#l8.1107"></a><span id="l8.1107" class="difflineminus">-    rv = EscapeFromSpaceLine(pDst, copy.m_pBuffer + copy.m_writeOffset, copy.m_pBuffer+copy.m_bytesInBuf);</span>
<a href="#l8.1108"></a><span id="l8.1108" class="difflineminus">-    if (copy.m_bytesInBuf)</span>
<a href="#l8.1109"></a><span id="l8.1109" class="difflineminus">-      lastChar = copy.m_pBuffer[copy.m_bytesInBuf - 1];</span>
<a href="#l8.1110"></a><span id="l8.1110" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l8.1111"></a><span id="l8.1111" class="difflineminus">-      copy.m_writeOffset = copy.m_bytesInBuf;</span>
<a href="#l8.1112"></a><span id="l8.1112" class="difflineminus">-</span>
<a href="#l8.1113"></a><span id="l8.1113" class="difflineminus">-  while ((state.offset &lt; state.size) &amp;&amp; NS_SUCCEEDED( rv)) {</span>
<a href="#l8.1114"></a><span id="l8.1114" class="difflineminus">-    rv = FillMailBuffer( &amp;state, copy);</span>
<a href="#l8.1115"></a><span id="l8.1115" class="difflineminus">-    if (NS_SUCCEEDED( rv)) {</span>
<a href="#l8.1116"></a><span id="l8.1116" class="difflineminus">-      rv = EscapeFromSpaceLine(pDst, copy.m_pBuffer + copy.m_writeOffset, copy.m_pBuffer+copy.m_bytesInBuf);</span>
<a href="#l8.1117"></a><span id="l8.1117" class="difflineminus">-      lastChar = copy.m_pBuffer[copy.m_bytesInBuf - 1];</span>
<a href="#l8.1118"></a><span id="l8.1118" class="difflineminus">-      if (NS_SUCCEEDED( rv))</span>
<a href="#l8.1119"></a><span id="l8.1119" class="difflineminus">-        copy.m_writeOffset = copy.m_bytesInBuf;</span>
<a href="#l8.1120"></a><span id="l8.1120" class="difflineminus">-      else</span>
<a href="#l8.1121"></a><span id="l8.1121" class="difflineminus">-        IMPORT_LOG0( &quot;*** Error writing to destination mailbox\n&quot;);</span>
<a href="#l8.1122"></a><span id="l8.1122" class="difflineminus">-    }</span>
<a href="#l8.1123"></a><span id="l8.1123" class="difflineminus">-  }</span>
<a href="#l8.1124"></a><span id="l8.1124" class="difflineminus">-</span>
<a href="#l8.1125"></a><span id="l8.1125" class="difflineminus">-</span>
<a href="#l8.1126"></a><span id="l8.1126" class="difflineminus">-  if ((lastChar != 0x0A) &amp;&amp; NS_SUCCEEDED( rv)) {</span>
<a href="#l8.1127"></a><span id="l8.1127" class="difflineminus">-    rv = pDst-&gt;Write( &quot;\x0D\x0A&quot;, 2, &amp;written);</span>
<a href="#l8.1128"></a><span id="l8.1128" class="difflineplus">+  if (f.LastChar() != 0x0A) {</span>
<a href="#l8.1129"></a><span id="l8.1129" class="difflineplus">+    rv = pDst-&gt;Write( MSG_LINEBREAK, 2, &amp;written);</span>
<a href="#l8.1130"></a><span id="l8.1130">     if (written != 2)</span>
<a href="#l8.1131"></a><span id="l8.1131">       rv = NS_ERROR_FAILURE;</span>
<a href="#l8.1132"></a><span id="l8.1132">   }</span>
<a href="#l8.1133"></a><span id="l8.1133"> </span>
<a href="#l8.1134"></a><span id="l8.1134">   return rv;</span>
<a href="#l8.1135"></a><span id="l8.1135"> }</span>
<a href="#l8.1136"></a><span id="l8.1136"> </span>
<a href="#l8.1137"></a><span id="l8.1137" class="difflineminus">-nsresult nsOutlookCompose::FillMailBuffer( ReadFileState *pState, SimpleBufferTonyRCopiedTwice&amp; read)</span>
<a href="#l8.1138"></a><span id="l8.1138" class="difflineplus">+nsresult nsOutlookCompose::ProcessMessage(nsMsgDeliverMode mode,</span>
<a href="#l8.1139"></a><span id="l8.1139" class="difflineplus">+                                          CMapiMessage &amp;msg,</span>
<a href="#l8.1140"></a><span id="l8.1140" class="difflineplus">+                                          nsIOutputStream *pDst)</span>
<a href="#l8.1141"></a><span id="l8.1141"> {</span>
<a href="#l8.1142"></a><span id="l8.1142" class="difflineminus">-  if (read.m_writeOffset &gt;= read.m_bytesInBuf) {</span>
<a href="#l8.1143"></a><span id="l8.1143" class="difflineminus">-    read.m_writeOffset = 0;</span>
<a href="#l8.1144"></a><span id="l8.1144" class="difflineminus">-    read.m_bytesInBuf = 0;</span>
<a href="#l8.1145"></a><span id="l8.1145" class="difflineminus">-  }</span>
<a href="#l8.1146"></a><span id="l8.1146" class="difflineminus">-  else if (read.m_writeOffset) {</span>
<a href="#l8.1147"></a><span id="l8.1147" class="difflineminus">-    memcpy( read.m_pBuffer, read.m_pBuffer + read.m_writeOffset, read.m_bytesInBuf - read.m_writeOffset);</span>
<a href="#l8.1148"></a><span id="l8.1148" class="difflineminus">-    read.m_bytesInBuf -= read.m_writeOffset;</span>
<a href="#l8.1149"></a><span id="l8.1149" class="difflineminus">-    read.m_writeOffset = 0;</span>
<a href="#l8.1150"></a><span id="l8.1150" class="difflineplus">+  nsCOMPtr&lt;nsIFile&gt; compositionFile;</span>
<a href="#l8.1151"></a><span id="l8.1151" class="difflineplus">+  nsresult rv = ComposeTheMessage(mode, msg, getter_AddRefs(compositionFile));</span>
<a href="#l8.1152"></a><span id="l8.1152" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l8.1153"></a><span id="l8.1153" class="difflineplus">+  rv = CopyComposedMessage(compositionFile, pDst, msg);</span>
<a href="#l8.1154"></a><span id="l8.1154" class="difflineplus">+  compositionFile-&gt;Remove(PR_FALSE);</span>
<a href="#l8.1155"></a><span id="l8.1155" class="difflineplus">+  if (NS_FAILED( rv)) {</span>
<a href="#l8.1156"></a><span id="l8.1156" class="difflineplus">+    IMPORT_LOG0( &quot;*** Error copying composed message to destination mailbox\n&quot;);</span>
<a href="#l8.1157"></a><span id="l8.1157">   }</span>
<a href="#l8.1158"></a><span id="l8.1158" class="difflineminus">-</span>
<a href="#l8.1159"></a><span id="l8.1159" class="difflineminus">-  PRInt32  count = read.m_size - read.m_bytesInBuf;</span>
<a href="#l8.1160"></a><span id="l8.1160" class="difflineminus">-  if (((PRUint32)count + pState-&gt;offset) &gt; pState-&gt;size)</span>
<a href="#l8.1161"></a><span id="l8.1161" class="difflineminus">-    count = pState-&gt;size - pState-&gt;offset;</span>
<a href="#l8.1162"></a><span id="l8.1162" class="difflineminus">-  if (count) {</span>
<a href="#l8.1163"></a><span id="l8.1163" class="difflineminus">-    PRUint32 bytesRead = 0;</span>
<a href="#l8.1164"></a><span id="l8.1164" class="difflineminus">-    char * pBuffer = read.m_pBuffer + read.m_bytesInBuf;</span>
<a href="#l8.1165"></a><span id="l8.1165" class="difflineminus">-    nsresult rv = pState-&gt;pInputStream-&gt;Read( pBuffer, count, &amp;bytesRead);</span>
<a href="#l8.1166"></a><span id="l8.1166" class="difflineminus">-    if (NS_FAILED( rv)) return( rv);</span>
<a href="#l8.1167"></a><span id="l8.1167" class="difflineminus">-    if (bytesRead != PRUint32(count)) return( NS_ERROR_FAILURE);</span>
<a href="#l8.1168"></a><span id="l8.1168" class="difflineminus">-    read.m_bytesInBuf += bytesRead;</span>
<a href="#l8.1169"></a><span id="l8.1169" class="difflineminus">-    pState-&gt;offset += bytesRead;</span>
<a href="#l8.1170"></a><span id="l8.1170" class="difflineminus">-  }</span>
<a href="#l8.1171"></a><span id="l8.1171" class="difflineminus">-</span>
<a href="#l8.1172"></a><span id="l8.1172" class="difflineminus">-  return( NS_OK);</span>
<a href="#l8.1173"></a><span id="l8.1173" class="difflineplus">+  return rv;</span>
<a href="#l8.1174"></a><span id="l8.1174"> }</span>
<a href="#l8.1175"></a><span id="l8.1175"> </span>
<a href="#l8.1176"></a><span id="l8.1176" class="difflineminus">-</span>
<a href="#l8.1177"></a><span id="l8.1177" class="difflineminus">-#define kMaxSpecialHeaders  3</span>
<a href="#l8.1178"></a><span id="l8.1178" class="difflineminus">-static const char *gSpecialHeaders[kMaxSpecialHeaders] = {</span>
<a href="#l8.1179"></a><span id="l8.1179" class="difflineminus">-  &quot;Content-type&quot;,</span>
<a href="#l8.1180"></a><span id="l8.1180" class="difflineminus">-  &quot;MIME-Version&quot;,</span>
<a href="#l8.1181"></a><span id="l8.1181" class="difflineminus">-  &quot;Content-transfer-encoding&quot;</span>
<a href="#l8.1182"></a><span id="l8.1182" class="difflineminus">-};</span>
<a href="#l8.1183"></a><span id="l8.1183" class="difflineminus">-// consider &quot;X-Accept-Language&quot;?</span>
<a href="#l8.1184"></a><span id="l8.1184" class="difflineminus">-</span>
<a href="#l8.1185"></a><span id="l8.1185" class="difflineminus">-#define kMaxReplaceHeaders  5</span>
<a href="#l8.1186"></a><span id="l8.1186" class="difflineminus">-static const char *gReplaceHeaders[kMaxReplaceHeaders] = {</span>
<a href="#l8.1187"></a><span id="l8.1187" class="difflineminus">-  &quot;From&quot;,</span>
<a href="#l8.1188"></a><span id="l8.1188" class="difflineminus">-  &quot;To&quot;,</span>
<a href="#l8.1189"></a><span id="l8.1189" class="difflineminus">-  &quot;Subject&quot;,</span>
<a href="#l8.1190"></a><span id="l8.1190" class="difflineminus">-  &quot;Reply-to&quot;,</span>
<a href="#l8.1191"></a><span id="l8.1191" class="difflineminus">-  &quot;cc&quot;</span>
<a href="#l8.1192"></a><span id="l8.1192" class="difflineminus">-};</span>
<a href="#l8.1193"></a><span id="l8.1193" class="difflineminus">-</span>
<a href="#l8.1194"></a><span id="l8.1194" class="difflineminus">-PRBool nsOutlookCompose::IsReplaceHeader( const char *pHeader)</span>
<a href="#l8.1195"></a><span id="l8.1195" class="difflineplus">+void nsOutlookCompose::UpdateHeader(CMapiMessageHeaders&amp; oldHeaders,</span>
<a href="#l8.1196"></a><span id="l8.1196" class="difflineplus">+                                    const CMapiMessageHeaders&amp; newHeaders,</span>
<a href="#l8.1197"></a><span id="l8.1197" class="difflineplus">+                                    CMapiMessageHeaders::SpecialHeader header,</span>
<a href="#l8.1198"></a><span id="l8.1198" class="difflineplus">+                                    bool addIfAbsent)</span>
<a href="#l8.1199"></a><span id="l8.1199"> {</span>
<a href="#l8.1200"></a><span id="l8.1200" class="difflineminus">-  for (int i = 0; i &lt; kMaxReplaceHeaders; i++) {</span>
<a href="#l8.1201"></a><span id="l8.1201" class="difflineminus">-    if (!PL_strcasecmp( pHeader, gReplaceHeaders[i]))</span>
<a href="#l8.1202"></a><span id="l8.1202" class="difflineminus">-      return( PR_TRUE);</span>
<a href="#l8.1203"></a><span id="l8.1203" class="difflineminus">-  }</span>
<a href="#l8.1204"></a><span id="l8.1204" class="difflineminus">-</span>
<a href="#l8.1205"></a><span id="l8.1205" class="difflineminus">-  return( PR_FALSE);</span>
<a href="#l8.1206"></a><span id="l8.1206" class="difflineplus">+  if (!addIfAbsent &amp;&amp; !oldHeaders.Value(header))</span>
<a href="#l8.1207"></a><span id="l8.1207" class="difflineplus">+    return;</span>
<a href="#l8.1208"></a><span id="l8.1208" class="difflineplus">+  const wchar_t* newVal = newHeaders.Value(header);</span>
<a href="#l8.1209"></a><span id="l8.1209" class="difflineplus">+  if (newVal) oldHeaders.SetValue(header, newVal);</span>
<a href="#l8.1210"></a><span id="l8.1210" class="difflineplus">+  // Bug 145150 - Turn &quot;Content-Type: application/ms-tnef&quot; into &quot;Content-Type: text/plain&quot;</span>
<a href="#l8.1211"></a><span id="l8.1211" class="difflineplus">+  //              so the body text can be displayed normally (instead of in an attachment).</span>
<a href="#l8.1212"></a><span id="l8.1212" class="difflineplus">+  if (header == CMapiMessageHeaders::hdrContentType)</span>
<a href="#l8.1213"></a><span id="l8.1213" class="difflineplus">+    if (!wcsicmp(oldHeaders.Value(header), L&quot;application/ms-tnef&quot;))</span>
<a href="#l8.1214"></a><span id="l8.1214" class="difflineplus">+      oldHeaders.SetValue(header, L&quot;text/plain&quot;);</span>
<a href="#l8.1215"></a><span id="l8.1215"> }</span>
<a href="#l8.1216"></a><span id="l8.1216"> </span>
<a href="#l8.1217"></a><span id="l8.1217" class="difflineminus">-PRInt32 nsOutlookCompose::IsSpecialHeader( const char *pHeader)</span>
<a href="#l8.1218"></a><span id="l8.1218" class="difflineminus">-{</span>
<a href="#l8.1219"></a><span id="l8.1219" class="difflineminus">-  for (int i = 0; i &lt; kMaxSpecialHeaders; i++) {</span>
<a href="#l8.1220"></a><span id="l8.1220" class="difflineminus">-    if (!PL_strcasecmp( pHeader, gSpecialHeaders[i]))</span>
<a href="#l8.1221"></a><span id="l8.1221" class="difflineminus">-      return( (PRInt32) i);</span>
<a href="#l8.1222"></a><span id="l8.1222" class="difflineminus">-  }</span>
<a href="#l8.1223"></a><span id="l8.1223" class="difflineminus">-</span>
<a href="#l8.1224"></a><span id="l8.1224" class="difflineminus">-  return( -1);</span>
<a href="#l8.1225"></a><span id="l8.1225" class="difflineminus">-}</span>
<a href="#l8.1226"></a><span id="l8.1226" class="difflineminus">-</span>
<a href="#l8.1227"></a><span id="l8.1227" class="difflineminus">-</span>
<a href="#l8.1228"></a><span id="l8.1228" class="difflineminus">-nsresult nsOutlookCompose::WriteHeaders( nsIOutputStream *pDst, SimpleBufferTonyRCopiedTwice&amp; newHeaders)</span>
<a href="#l8.1229"></a><span id="l8.1229" class="difflineplus">+void nsOutlookCompose::UpdateHeaders(CMapiMessageHeaders&amp; oldHeaders, const CMapiMessageHeaders&amp; newHeaders)</span>
<a href="#l8.1230"></a><span id="l8.1230"> {</span>
<a href="#l8.1231"></a><span id="l8.1231">   // Well, ain't this a peach?</span>
<a href="#l8.1232"></a><span id="l8.1232">   // This is rather disgusting but there really isn't much to be done about it....</span>
<a href="#l8.1233"></a><span id="l8.1233"> </span>
<a href="#l8.1234"></a><span id="l8.1234">   // 1. For each &quot;old&quot; header, replace it with the new one if we want,</span>
<a href="#l8.1235"></a><span id="l8.1235">   // then right it out.</span>
<a href="#l8.1236"></a><span id="l8.1236">   // 2. Then if we haven't written the &quot;important&quot; new headers, write them out</span>
<a href="#l8.1237"></a><span id="l8.1237">   // 3. Terminate the headers with an extra eol.</span>
<a href="#l8.1238"></a><span id="l8.1238"> </span>
<a href="#l8.1239"></a><span id="l8.1239" class="difflineminus">-  PRInt32 n = 0;</span>
<a href="#l8.1240"></a><span id="l8.1240" class="difflineminus">-  nsCString header;</span>
<a href="#l8.1241"></a><span id="l8.1241" class="difflineminus">-  nsCString val;</span>
<a href="#l8.1242"></a><span id="l8.1242" class="difflineminus">-  nsCString replaceVal;</span>
<a href="#l8.1243"></a><span id="l8.1243" class="difflineminus">-  PRUint32 written;</span>
<a href="#l8.1244"></a><span id="l8.1244" class="difflineminus">-  nsresult rv = NS_OK; // it's ok if we don't have the first header on the predefined lists.</span>
<a href="#l8.1245"></a><span id="l8.1245" class="difflineminus">-  PRInt32 specialHeader;</span>
<a href="#l8.1246"></a><span id="l8.1246" class="difflineminus">-  PRBool specials[kMaxSpecialHeaders];</span>
<a href="#l8.1247"></a><span id="l8.1247" class="difflineminus">-  int i;</span>
<a href="#l8.1248"></a><span id="l8.1248" class="difflineplus">+  // Important headers:</span>
<a href="#l8.1249"></a><span id="l8.1249" class="difflineplus">+  //  &quot;Content-type&quot;,</span>
<a href="#l8.1250"></a><span id="l8.1250" class="difflineplus">+  //  &quot;MIME-Version&quot;,</span>
<a href="#l8.1251"></a><span id="l8.1251" class="difflineplus">+  //  &quot;Content-transfer-encoding&quot;</span>
<a href="#l8.1252"></a><span id="l8.1252" class="difflineplus">+  // consider &quot;X-Accept-Language&quot;?</span>
<a href="#l8.1253"></a><span id="l8.1253" class="difflineplus">+</span>
<a href="#l8.1254"></a><span id="l8.1254" class="difflineplus">+  UpdateHeader(oldHeaders, newHeaders, CMapiMessageHeaders::hdrContentType);</span>
<a href="#l8.1255"></a><span id="l8.1255" class="difflineplus">+  UpdateHeader(oldHeaders, newHeaders, CMapiMessageHeaders::hdrMimeVersion);</span>
<a href="#l8.1256"></a><span id="l8.1256" class="difflineplus">+  UpdateHeader(oldHeaders, newHeaders, CMapiMessageHeaders::hdrContentTransferEncoding);</span>
<a href="#l8.1257"></a><span id="l8.1257" class="difflineplus">+</span>
<a href="#l8.1258"></a><span id="l8.1258" class="difflineplus">+  // Other replaced headers (only if they exist):</span>
<a href="#l8.1259"></a><span id="l8.1259" class="difflineplus">+  //  &quot;From&quot;,</span>
<a href="#l8.1260"></a><span id="l8.1260" class="difflineplus">+  //  &quot;To&quot;,</span>
<a href="#l8.1261"></a><span id="l8.1261" class="difflineplus">+  //  &quot;Subject&quot;,</span>
<a href="#l8.1262"></a><span id="l8.1262" class="difflineplus">+  //  &quot;Reply-to&quot;,</span>
<a href="#l8.1263"></a><span id="l8.1263" class="difflineplus">+  //  &quot;Cc&quot;</span>
<a href="#l8.1264"></a><span id="l8.1264" class="difflineplus">+</span>
<a href="#l8.1265"></a><span id="l8.1265" class="difflineplus">+  UpdateHeader(oldHeaders, newHeaders, CMapiMessageHeaders::hdrFrom, false);</span>
<a href="#l8.1266"></a><span id="l8.1266" class="difflineplus">+  UpdateHeader(oldHeaders, newHeaders, CMapiMessageHeaders::hdrTo, false);</span>
<a href="#l8.1267"></a><span id="l8.1267" class="difflineplus">+  UpdateHeader(oldHeaders, newHeaders, CMapiMessageHeaders::hdrSubject, false);</span>
<a href="#l8.1268"></a><span id="l8.1268" class="difflineplus">+  UpdateHeader(oldHeaders, newHeaders, CMapiMessageHeaders::hdrReplyTo, false);</span>
<a href="#l8.1269"></a><span id="l8.1269" class="difflineplus">+  UpdateHeader(oldHeaders, newHeaders, CMapiMessageHeaders::hdrCc, false);</span>
<a href="#l8.1270"></a><span id="l8.1270" class="difflineplus">+}</span>
<a href="#l8.1271"></a><span id="l8.1271" class="difflineplus">+</span>
<a href="#l8.1272"></a><span id="l8.1272" class="difflineplus">+// Bug 593907</span>
<a href="#l8.1273"></a><span id="l8.1273" class="difflineplus">+// This is just a workaround of the deficiency of the nsMsgComposeAndSend::EnsureLineBreaks().</span>
<a href="#l8.1274"></a><span id="l8.1274" class="difflineplus">+// The import from Outlook will stay OK (I hope), but other messages may still suffer.</span>
<a href="#l8.1275"></a><span id="l8.1275" class="difflineplus">+// However, I cannot deny the possibility that the (possible) recode of the body</span>
<a href="#l8.1276"></a><span id="l8.1276" class="difflineplus">+// may interfere with this hack. A possible scenario is if a multi-byte character will either</span>
<a href="#l8.1277"></a><span id="l8.1277" class="difflineplus">+// contain 0x0D 0x0A sequence, or end with 0x0D, after which MAC-style standalone LF will go.</span>
<a href="#l8.1278"></a><span id="l8.1278" class="difflineplus">+// I hope that this possibility is insignificant (eg, utf-8 doesn't contain such sequences).</span>
<a href="#l8.1279"></a><span id="l8.1279" class="difflineplus">+// This hack will slow down the import, but as the import is one-time procedure, I hope that</span>
<a href="#l8.1280"></a><span id="l8.1280" class="difflineplus">+// the user will agree to wait a little longer to get better results.</span>
<a href="#l8.1281"></a><span id="l8.1281" class="difflineplus">+</span>
<a href="#l8.1282"></a><span id="l8.1282" class="difflineplus">+// The process of composing the message differs depending on whether the editor is present or not.</span>
<a href="#l8.1283"></a><span id="l8.1283" class="difflineplus">+// If the editor is absent, the &quot;attachment1_body&quot; parameter of CreateAndSendMessage() is taken as is,</span>
<a href="#l8.1284"></a><span id="l8.1284" class="difflineplus">+// while in the presence o the editor, the body that is taken from it is further processed in the</span>
<a href="#l8.1285"></a><span id="l8.1285" class="difflineplus">+// nsMsgComposeAndSend::GetBodyFromEditor(). Specifically, the TXTToHTML::ScanHTML() first calls</span>
<a href="#l8.1286"></a><span id="l8.1286" class="difflineplus">+// UnescapeStr() to properly handle a limited number of HTML character entities (namely &amp;amp; &amp;lt; &amp;gt; &amp;quot;)</span>
<a href="#l8.1287"></a><span id="l8.1287" class="difflineplus">+// and then calls ScanTXT() where escapes all ampersands and quotes again. As the UnescapeStr() works so</span>
<a href="#l8.1288"></a><span id="l8.1288" class="difflineplus">+// selectively (i.e. handling only a subset of valid entities), the so often seen &quot;&amp;nbsp;&quot; becomes &quot;&amp;amp;nbsp;&quot;</span>
<a href="#l8.1289"></a><span id="l8.1289" class="difflineplus">+// in the resulting body, which leads to text &quot;&amp;nbsp;&quot; interspersed all over the imported mail. The same</span>
<a href="#l8.1290"></a><span id="l8.1290" class="difflineplus">+// applies to html &amp;#XXXX; (where XXXX is unicode codepoint).</span>
<a href="#l8.1291"></a><span id="l8.1291" class="difflineplus">+// See also Bug 503690, where the same issue in Eudora import is reported.</span>
<a href="#l8.1292"></a><span id="l8.1292" class="difflineplus">+// By the way, the root of the Bug 359303 lies in the same place - the nsMsgComposeAndSend::GetBodyFromEditor()</span>
<a href="#l8.1293"></a><span id="l8.1293" class="difflineplus">+// changes the 0xA0 codes to 0x20 when it converts the body to plain text.</span>
<a href="#l8.1294"></a><span id="l8.1294" class="difflineplus">+// We scan the body here to find all the &amp; and convert them to the safe character sequense to revert later.</span>
<a href="#l8.1295"></a><span id="l8.1295" class="difflineplus">+</span>
<a href="#l8.1296"></a><span id="l8.1296" class="difflineplus">+void nsOutlookCompose::HackBody(const wchar_t* orig, size_t origLen, nsString&amp; hack)</span>
<a href="#l8.1297"></a><span id="l8.1297" class="difflineplus">+{</span>
<a href="#l8.1298"></a><span id="l8.1298" class="difflineplus">+  hack.SetCapacity(static_cast&lt;size_t&gt;(origLen*1.4));</span>
<a href="#l8.1299"></a><span id="l8.1299" class="difflineplus">+  hack.Assign(hackBeginW);</span>
<a href="#l8.1300"></a><span id="l8.1300" class="difflineplus">+  hack.Append(m_hackedPostfix);</span>
<a href="#l8.1301"></a><span id="l8.1301"> </span>
<a href="#l8.1302"></a><span id="l8.1302" class="difflineminus">-  for (i = 0; i &lt; kMaxSpecialHeaders; i++)</span>
<a href="#l8.1303"></a><span id="l8.1303" class="difflineminus">-    specials[i] = PR_FALSE;</span>
<a href="#l8.1304"></a><span id="l8.1304" class="difflineplus">+  while (*orig) {</span>
<a href="#l8.1305"></a><span id="l8.1305" class="difflineplus">+    if (*orig == L'&amp;') {</span>
<a href="#l8.1306"></a><span id="l8.1306" class="difflineplus">+      hack.Append(hackAmpersandW);</span>
<a href="#l8.1307"></a><span id="l8.1307" class="difflineplus">+      hack.Append(m_hackedPostfix);</span>
<a href="#l8.1308"></a><span id="l8.1308" class="difflineplus">+    } else if ((*orig == L'\x0D') &amp;&amp; (*(orig+1) == L'\x0A')) {</span>
<a href="#l8.1309"></a><span id="l8.1309" class="difflineplus">+      hack.Append(hackCRLFW);</span>
<a href="#l8.1310"></a><span id="l8.1310" class="difflineplus">+      hack.Append(m_hackedPostfix);</span>
<a href="#l8.1311"></a><span id="l8.1311" class="difflineplus">+      ++orig;</span>
<a href="#l8.1312"></a><span id="l8.1312" class="difflineplus">+    } else</span>
<a href="#l8.1313"></a><span id="l8.1313" class="difflineplus">+      hack.Append(*orig);</span>
<a href="#l8.1314"></a><span id="l8.1314" class="difflineplus">+    ++orig;</span>
<a href="#l8.1315"></a><span id="l8.1315" class="difflineplus">+  }</span>
<a href="#l8.1316"></a><span id="l8.1316" class="difflineplus">+</span>
<a href="#l8.1317"></a><span id="l8.1317" class="difflineplus">+  hack.Append(hackEndW);</span>
<a href="#l8.1318"></a><span id="l8.1318" class="difflineplus">+  hack.Append(m_hackedPostfix);</span>
<a href="#l8.1319"></a><span id="l8.1319" class="difflineplus">+}</span>
<a href="#l8.1320"></a><span id="l8.1320" class="difflineplus">+</span>
<a href="#l8.1321"></a><span id="l8.1321" class="difflineplus">+void nsOutlookCompose::UnhackBody(nsCString&amp; txt)</span>
<a href="#l8.1322"></a><span id="l8.1322" class="difflineplus">+{</span>
<a href="#l8.1323"></a><span id="l8.1323" class="difflineplus">+  nsCString hackedPostfixA;</span>
<a href="#l8.1324"></a><span id="l8.1324" class="difflineplus">+  LossyCopyUTF16toASCII(m_hackedPostfix, hackedPostfixA);</span>
<a href="#l8.1325"></a><span id="l8.1325" class="difflineplus">+</span>
<a href="#l8.1326"></a><span id="l8.1326" class="difflineplus">+  nsCString hackedString(hackBeginA);</span>
<a href="#l8.1327"></a><span id="l8.1327" class="difflineplus">+  hackedString.Append(hackedPostfixA);</span>
<a href="#l8.1328"></a><span id="l8.1328" class="difflineplus">+  PRInt32 begin = txt.Find(hackedString);</span>
<a href="#l8.1329"></a><span id="l8.1329" class="difflineplus">+  if (begin == kNotFound)</span>
<a href="#l8.1330"></a><span id="l8.1330" class="difflineplus">+    return;</span>
<a href="#l8.1331"></a><span id="l8.1331" class="difflineplus">+  txt.Cut(begin, hackedString.Length());</span>
<a href="#l8.1332"></a><span id="l8.1332" class="difflineplus">+</span>
<a href="#l8.1333"></a><span id="l8.1333" class="difflineplus">+  hackedString.Assign(hackEndA);</span>
<a href="#l8.1334"></a><span id="l8.1334" class="difflineplus">+  hackedString.Append(hackedPostfixA);</span>
<a href="#l8.1335"></a><span id="l8.1335" class="difflineplus">+  PRInt32 end = txt.Find(hackedString, PR_FALSE, begin);</span>
<a href="#l8.1336"></a><span id="l8.1336" class="difflineplus">+  if (end == kNotFound)</span>
<a href="#l8.1337"></a><span id="l8.1337" class="difflineplus">+    return; // ?</span>
<a href="#l8.1338"></a><span id="l8.1338" class="difflineplus">+  txt.Cut(end, hackedString.Length());</span>
<a href="#l8.1339"></a><span id="l8.1339" class="difflineplus">+</span>
<a href="#l8.1340"></a><span id="l8.1340" class="difflineplus">+  // 1. Remove all CRLFs from the selected range</span>
<a href="#l8.1341"></a><span id="l8.1341" class="difflineplus">+  PRInt32 i = begin;</span>
<a href="#l8.1342"></a><span id="l8.1342" class="difflineplus">+  while (i &lt; end) {</span>
<a href="#l8.1343"></a><span id="l8.1343" class="difflineplus">+    PRInt32 r = txt.Find(MSG_LINEBREAK, PR_FALSE, i, end-i);</span>
<a href="#l8.1344"></a><span id="l8.1344" class="difflineplus">+    if (r == kNotFound)</span>
<a href="#l8.1345"></a><span id="l8.1345" class="difflineplus">+      break;</span>
<a href="#l8.1346"></a><span id="l8.1346" class="difflineplus">+</span>
<a href="#l8.1347"></a><span id="l8.1347" class="difflineplus">+    txt.Cut(r, 2);</span>
<a href="#l8.1348"></a><span id="l8.1348" class="difflineplus">+    end -= 2;</span>
<a href="#l8.1349"></a><span id="l8.1349" class="difflineplus">+    i = r;</span>
<a href="#l8.1350"></a><span id="l8.1350" class="difflineplus">+  }</span>
<a href="#l8.1351"></a><span id="l8.1351" class="difflineplus">+</span>
<a href="#l8.1352"></a><span id="l8.1352" class="difflineplus">+  // 2. Restore the original CRLFs</span>
<a href="#l8.1353"></a><span id="l8.1353" class="difflineplus">+  hackedString.Assign(hackCRLFA);</span>
<a href="#l8.1354"></a><span id="l8.1354" class="difflineplus">+  hackedString.Append(hackedPostfixA);</span>
<a href="#l8.1355"></a><span id="l8.1355" class="difflineplus">+  i = begin;</span>
<a href="#l8.1356"></a><span id="l8.1356" class="difflineplus">+  while (i &lt; end) {</span>
<a href="#l8.1357"></a><span id="l8.1357" class="difflineplus">+    PRInt32 r = txt.Find(hackedString, PR_FALSE, i, end-i);</span>
<a href="#l8.1358"></a><span id="l8.1358" class="difflineplus">+    if (r == kNotFound)</span>
<a href="#l8.1359"></a><span id="l8.1359" class="difflineplus">+      break;</span>
<a href="#l8.1360"></a><span id="l8.1360" class="difflineplus">+</span>
<a href="#l8.1361"></a><span id="l8.1361" class="difflineplus">+    txt.Replace(r, hackedString.Length(), MSG_LINEBREAK, 2);</span>
<a href="#l8.1362"></a><span id="l8.1362" class="difflineplus">+    end -= hackedString.Length()-2;</span>
<a href="#l8.1363"></a><span id="l8.1363" class="difflineplus">+    i = r+2;</span>
<a href="#l8.1364"></a><span id="l8.1364" class="difflineplus">+  }</span>
<a href="#l8.1365"></a><span id="l8.1365" class="difflineplus">+</span>
<a href="#l8.1366"></a><span id="l8.1366" class="difflineplus">+  // 3. Restore the original ampersands</span>
<a href="#l8.1367"></a><span id="l8.1367" class="difflineplus">+  hackedString.Assign(hackAmpersandA);</span>
<a href="#l8.1368"></a><span id="l8.1368" class="difflineplus">+  hackedString.Append(hackedPostfixA);</span>
<a href="#l8.1369"></a><span id="l8.1369" class="difflineplus">+  i = begin;</span>
<a href="#l8.1370"></a><span id="l8.1370" class="difflineplus">+  while (i &lt; end) {</span>
<a href="#l8.1371"></a><span id="l8.1371" class="difflineplus">+    PRInt32 r = txt.Find(hackedString, PR_FALSE, i, end-i);</span>
<a href="#l8.1372"></a><span id="l8.1372" class="difflineplus">+    if (r == kNotFound)</span>
<a href="#l8.1373"></a><span id="l8.1373" class="difflineplus">+      break;</span>
<a href="#l8.1374"></a><span id="l8.1374" class="difflineplus">+</span>
<a href="#l8.1375"></a><span id="l8.1375" class="difflineplus">+    txt.Replace(r, hackedString.Length(), '&amp;');</span>
<a href="#l8.1376"></a><span id="l8.1376" class="difflineplus">+    end -= hackedString.Length()-1;</span>
<a href="#l8.1377"></a><span id="l8.1377" class="difflineplus">+    i = r+1;</span>
<a href="#l8.1378"></a><span id="l8.1378" class="difflineplus">+  }</span>
<a href="#l8.1379"></a><span id="l8.1379" class="difflineplus">+}</span>
<a href="#l8.1380"></a><span id="l8.1380"> </span>
<a href="#l8.1381"></a><span id="l8.1381" class="difflineplus">+bool nsOutlookCompose::GenerateHackSequence(const wchar_t* body, size_t origLen)</span>
<a href="#l8.1382"></a><span id="l8.1382" class="difflineplus">+{</span>
<a href="#l8.1383"></a><span id="l8.1383" class="difflineplus">+  nsDependentString nsBody(body, origLen);</span>
<a href="#l8.1384"></a><span id="l8.1384" class="difflineplus">+  const wchar_t* hack_base = L&quot;hacked&quot;;</span>
<a href="#l8.1385"></a><span id="l8.1385" class="difflineplus">+  int i = 0;</span>
<a href="#l8.1386"></a><span id="l8.1386">   do {</span>
<a href="#l8.1387"></a><span id="l8.1387" class="difflineminus">-    GetNthHeader( m_Headers.get(), m_Headers.Length(), n, header, val, PR_FALSE);</span>
<a href="#l8.1388"></a><span id="l8.1388" class="difflineminus">-    // GetNthHeader( newHeaders.m_pBuffer, newHeaders.m_writeOffset, n, header.get(), val, PR_FALSE);</span>
<a href="#l8.1389"></a><span id="l8.1389" class="difflineminus">-    if (!header.IsEmpty()) {</span>
<a href="#l8.1390"></a><span id="l8.1390" class="difflineminus">-      if ((specialHeader = IsSpecialHeader( header.get())) != -1) {</span>
<a href="#l8.1391"></a><span id="l8.1391" class="difflineminus">-        header.Append( ':');</span>
<a href="#l8.1392"></a><span id="l8.1392" class="difflineminus">-        GetHeaderValue( newHeaders.m_pBuffer, newHeaders.m_writeOffset - 1, header.get(), val, PR_FALSE);</span>
<a href="#l8.1393"></a><span id="l8.1393" class="difflineminus">-        // Bug 145150 - Turn &quot;Content-Type: application/ms-tnef&quot; into &quot;Content-Type: text/plain&quot;</span>
<a href="#l8.1394"></a><span id="l8.1394" class="difflineminus">-        //              so the body text can be displayed normally (instead of in an attachment).</span>
<a href="#l8.1395"></a><span id="l8.1395" class="difflineminus">-        if (header.LowerCaseEqualsLiteral(&quot;content-type:&quot;) &amp;&amp; val.LowerCaseEqualsLiteral(&quot;application/ms-tnef&quot;))</span>
<a href="#l8.1396"></a><span id="l8.1396" class="difflineminus">-          val.Assign(&quot;text/plain&quot;);</span>
<a href="#l8.1397"></a><span id="l8.1397" class="difflineminus">-        header.SetLength( header.Length() - 1);</span>
<a href="#l8.1398"></a><span id="l8.1398" class="difflineminus">-        specials[specialHeader] = PR_TRUE;</span>
<a href="#l8.1399"></a><span id="l8.1399" class="difflineplus">+    if (++i == 0) { // Cycle complete :) - could not generate an unique string</span>
<a href="#l8.1400"></a><span id="l8.1400" class="difflineplus">+      m_hackedPostfix.Truncate();</span>
<a href="#l8.1401"></a><span id="l8.1401" class="difflineplus">+      return false;</span>
<a href="#l8.1402"></a><span id="l8.1402" class="difflineplus">+    }</span>
<a href="#l8.1403"></a><span id="l8.1403" class="difflineplus">+    m_hackedPostfix.Assign(hack_base);</span>
<a href="#l8.1404"></a><span id="l8.1404" class="difflineplus">+    m_hackedPostfix.AppendInt(i);</span>
<a href="#l8.1405"></a><span id="l8.1405" class="difflineplus">+  } while (nsBody.Find(m_hackedPostfix) != kNotFound);</span>
<a href="#l8.1406"></a><span id="l8.1406" class="difflineplus">+</span>
<a href="#l8.1407"></a><span id="l8.1407" class="difflineplus">+  return true;</span>
<a href="#l8.1408"></a><span id="l8.1408" class="difflineplus">+}</span>
<a href="#l8.1409"></a><span id="l8.1409" class="difflineplus">+// End Bug 593907</span>
<a href="#l8.1410"></a><span id="l8.1410" class="difflineplus">+</span>
<a href="#l8.1411"></a><span id="l8.1411" class="difflineplus">+//////////////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l8.1412"></a><span id="l8.1412" class="difflineplus">+</span>
<a href="#l8.1413"></a><span id="l8.1413" class="difflineplus">+CCompositionFile::CCompositionFile(nsIFile* aFile, void* fifoBuffer,</span>
<a href="#l8.1414"></a><span id="l8.1414" class="difflineplus">+                                   PRUint32 fifoBufferSize, bool convertCRs)</span>
<a href="#l8.1415"></a><span id="l8.1415" class="difflineplus">+  : m_pFile(aFile), m_fileReadPos(0),</span>
<a href="#l8.1416"></a><span id="l8.1416" class="difflineplus">+    m_fifoBuffer(static_cast&lt;char*&gt;(fifoBuffer)),</span>
<a href="#l8.1417"></a><span id="l8.1417" class="difflineplus">+    m_fifoBufferSize(fifoBufferSize),</span>
<a href="#l8.1418"></a><span id="l8.1418" class="difflineplus">+    m_fifoBufferReadPos(static_cast&lt;char*&gt;(fifoBuffer)),</span>
<a href="#l8.1419"></a><span id="l8.1419" class="difflineplus">+    m_fifoBufferWrittenPos(static_cast&lt;char*&gt;(fifoBuffer)),</span>
<a href="#l8.1420"></a><span id="l8.1420" class="difflineplus">+    m_convertCRs(convertCRs),</span>
<a href="#l8.1421"></a><span id="l8.1421" class="difflineplus">+    m_lastChar(0)</span>
<a href="#l8.1422"></a><span id="l8.1422" class="difflineplus">+{</span>
<a href="#l8.1423"></a><span id="l8.1423" class="difflineplus">+  m_pFile-&gt;GetFileSize(&amp;m_fileSize);</span>
<a href="#l8.1424"></a><span id="l8.1424" class="difflineplus">+  if (!m_fileSize) {</span>
<a href="#l8.1425"></a><span id="l8.1425" class="difflineplus">+    IMPORT_LOG0( &quot;*** Error, unexpected zero file size for composed message\n&quot;);</span>
<a href="#l8.1426"></a><span id="l8.1426" class="difflineplus">+    return;</span>
<a href="#l8.1427"></a><span id="l8.1427" class="difflineplus">+  }</span>
<a href="#l8.1428"></a><span id="l8.1428" class="difflineplus">+</span>
<a href="#l8.1429"></a><span id="l8.1429" class="difflineplus">+  nsresult rv = NS_NewLocalFileInputStream(getter_AddRefs(m_pInputStream), m_pFile);</span>
<a href="#l8.1430"></a><span id="l8.1430" class="difflineplus">+  if (NS_FAILED(rv)) {</span>
<a href="#l8.1431"></a><span id="l8.1431" class="difflineplus">+    IMPORT_LOG0( &quot;*** Error, unable to open composed message file\n&quot;);</span>
<a href="#l8.1432"></a><span id="l8.1432" class="difflineplus">+    return;</span>
<a href="#l8.1433"></a><span id="l8.1433" class="difflineplus">+  }</span>
<a href="#l8.1434"></a><span id="l8.1434" class="difflineplus">+}</span>
<a href="#l8.1435"></a><span id="l8.1435" class="difflineplus">+</span>
<a href="#l8.1436"></a><span id="l8.1436" class="difflineplus">+nsresult CCompositionFile::EnsureHasDataInBuffer()</span>
<a href="#l8.1437"></a><span id="l8.1437" class="difflineplus">+{</span>
<a href="#l8.1438"></a><span id="l8.1438" class="difflineplus">+  if (m_fifoBufferReadPos &lt; m_fifoBufferWrittenPos)</span>
<a href="#l8.1439"></a><span id="l8.1439" class="difflineplus">+    return NS_OK;</span>
<a href="#l8.1440"></a><span id="l8.1440" class="difflineplus">+  // Populate the buffer with new data!</span>
<a href="#l8.1441"></a><span id="l8.1441" class="difflineplus">+  PRUint32 count = m_fifoBufferSize;</span>
<a href="#l8.1442"></a><span id="l8.1442" class="difflineplus">+  if ((m_fileReadPos + count) &gt; m_fileSize)</span>
<a href="#l8.1443"></a><span id="l8.1443" class="difflineplus">+    count = m_fileSize - m_fileReadPos;</span>
<a href="#l8.1444"></a><span id="l8.1444" class="difflineplus">+  if (!count)</span>
<a href="#l8.1445"></a><span id="l8.1445" class="difflineplus">+    return NS_ERROR_FAILURE; // Isn't there a &quot;No more data&quot; error?</span>
<a href="#l8.1446"></a><span id="l8.1446" class="difflineplus">+</span>
<a href="#l8.1447"></a><span id="l8.1447" class="difflineplus">+  PRUint32 bytesRead = 0;</span>
<a href="#l8.1448"></a><span id="l8.1448" class="difflineplus">+  nsresult rv = m_pInputStream-&gt;Read( m_fifoBuffer, count, &amp;bytesRead);</span>
<a href="#l8.1449"></a><span id="l8.1449" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l8.1450"></a><span id="l8.1450" class="difflineplus">+  if (!bytesRead || (bytesRead &gt; count))</span>
<a href="#l8.1451"></a><span id="l8.1451" class="difflineplus">+    return( NS_ERROR_FAILURE);</span>
<a href="#l8.1452"></a><span id="l8.1452" class="difflineplus">+  m_fifoBufferWrittenPos = m_fifoBuffer+bytesRead;</span>
<a href="#l8.1453"></a><span id="l8.1453" class="difflineplus">+  m_fifoBufferReadPos = m_fifoBuffer;</span>
<a href="#l8.1454"></a><span id="l8.1454" class="difflineplus">+  m_fileReadPos += bytesRead;</span>
<a href="#l8.1455"></a><span id="l8.1455" class="difflineplus">+</span>
<a href="#l8.1456"></a><span id="l8.1456" class="difflineplus">+  return NS_OK;</span>
<a href="#l8.1457"></a><span id="l8.1457" class="difflineplus">+}</span>
<a href="#l8.1458"></a><span id="l8.1458" class="difflineplus">+</span>
<a href="#l8.1459"></a><span id="l8.1459" class="difflineplus">+const char CR = '\x0D', LF = '\x0A';</span>
<a href="#l8.1460"></a><span id="l8.1460" class="difflineplus">+</span>
<a href="#l8.1461"></a><span id="l8.1461" class="difflineplus">+class CTermGuard {</span>
<a href="#l8.1462"></a><span id="l8.1462" class="difflineplus">+public:</span>
<a href="#l8.1463"></a><span id="l8.1463" class="difflineplus">+  CTermGuard(const char* term, int termSize)</span>
<a href="#l8.1464"></a><span id="l8.1464" class="difflineplus">+    : m_term(term),</span>
<a href="#l8.1465"></a><span id="l8.1465" class="difflineplus">+    m_termSize(term ? ((termSize!=-1) ? termSize : strlen(term)) : 0),</span>
<a href="#l8.1466"></a><span id="l8.1466" class="difflineplus">+    m_matchPos(0)</span>
<a href="#l8.1467"></a><span id="l8.1467" class="difflineplus">+  {}</span>
<a href="#l8.1468"></a><span id="l8.1468" class="difflineplus">+</span>
<a href="#l8.1469"></a><span id="l8.1469" class="difflineplus">+   // if the guard triggered</span>
<a href="#l8.1470"></a><span id="l8.1470" class="difflineplus">+  inline bool IsTriggered() const {</span>
<a href="#l8.1471"></a><span id="l8.1471" class="difflineplus">+    return m_termSize &amp;&amp; (m_matchPos == m_termSize); }</span>
<a href="#l8.1472"></a><span id="l8.1472" class="difflineplus">+  // indicates if the guard has something to check</span>
<a href="#l8.1473"></a><span id="l8.1473" class="difflineplus">+  inline bool IsChecking() const { return m_termSize; } </span>
<a href="#l8.1474"></a><span id="l8.1474" class="difflineplus">+</span>
<a href="#l8.1475"></a><span id="l8.1475" class="difflineplus">+  bool Check(char c) // returns true only if the whole sequence passed</span>
<a href="#l8.1476"></a><span id="l8.1476" class="difflineplus">+  {</span>
<a href="#l8.1477"></a><span id="l8.1477" class="difflineplus">+    if (!m_termSize) // no guard</span>
<a href="#l8.1478"></a><span id="l8.1478" class="difflineplus">+      return false;</span>
<a href="#l8.1479"></a><span id="l8.1479" class="difflineplus">+    if (m_matchPos &gt;= m_termSize) // check past success!</span>
<a href="#l8.1480"></a><span id="l8.1480" class="difflineplus">+      m_matchPos = 0;</span>
<a href="#l8.1481"></a><span id="l8.1481" class="difflineplus">+    if (m_term[m_matchPos] == c) { // Sequence continues</span>
<a href="#l8.1482"></a><span id="l8.1482" class="difflineplus">+      return (++m_matchPos == m_termSize); // If equal then sequence complete!</span>
<a href="#l8.1483"></a><span id="l8.1483" class="difflineplus">+    }</span>
<a href="#l8.1484"></a><span id="l8.1484" class="difflineplus">+    // Sequence broken</span>
<a href="#l8.1485"></a><span id="l8.1485" class="difflineplus">+    m_matchPos = 0;</span>
<a href="#l8.1486"></a><span id="l8.1486" class="difflineplus">+    return false;</span>
<a href="#l8.1487"></a><span id="l8.1487" class="difflineplus">+  }</span>
<a href="#l8.1488"></a><span id="l8.1488" class="difflineplus">+private:</span>
<a href="#l8.1489"></a><span id="l8.1489" class="difflineplus">+  const char* m_term;</span>
<a href="#l8.1490"></a><span id="l8.1490" class="difflineplus">+  int m_termSize;</span>
<a href="#l8.1491"></a><span id="l8.1491" class="difflineplus">+  int m_matchPos;</span>
<a href="#l8.1492"></a><span id="l8.1492" class="difflineplus">+};</span>
<a href="#l8.1493"></a><span id="l8.1493" class="difflineplus">+</span>
<a href="#l8.1494"></a><span id="l8.1494" class="difflineplus">+template &lt;class _OutFn&gt;</span>
<a href="#l8.1495"></a><span id="l8.1495" class="difflineplus">+nsresult CCompositionFile::ToDest(_OutFn dest, const char* term, int termSize)</span>
<a href="#l8.1496"></a><span id="l8.1496" class="difflineplus">+{</span>
<a href="#l8.1497"></a><span id="l8.1497" class="difflineplus">+  CTermGuard guard(term, termSize);</span>
<a href="#l8.1498"></a><span id="l8.1498" class="difflineplus">+</span>
<a href="#l8.1499"></a><span id="l8.1499" class="difflineplus">+  // We already know the required string size, so reduce future reallocations</span>
<a href="#l8.1500"></a><span id="l8.1500" class="difflineplus">+  if (!guard.IsChecking() &amp;&amp; !m_convertCRs) </span>
<a href="#l8.1501"></a><span id="l8.1501" class="difflineplus">+    dest.SetCapacity(m_fileSize - m_fileReadPos);</span>
<a href="#l8.1502"></a><span id="l8.1502" class="difflineplus">+</span>
<a href="#l8.1503"></a><span id="l8.1503" class="difflineplus">+  bool wasCR = false;</span>
<a href="#l8.1504"></a><span id="l8.1504" class="difflineplus">+  char c = 0;</span>
<a href="#l8.1505"></a><span id="l8.1505" class="difflineplus">+  nsresult rv;</span>
<a href="#l8.1506"></a><span id="l8.1506" class="difflineplus">+  while (NS_SUCCEEDED(rv = EnsureHasDataInBuffer())) {</span>
<a href="#l8.1507"></a><span id="l8.1507" class="difflineplus">+    if (!guard.IsChecking() &amp;&amp; !m_convertCRs) { // Use efficient algorithm</span>
<a href="#l8.1508"></a><span id="l8.1508" class="difflineplus">+      dest.Append(m_fifoBufferReadPos, m_fifoBufferWrittenPos-m_fifoBufferReadPos);</span>
<a href="#l8.1509"></a><span id="l8.1509" class="difflineplus">+    }</span>
<a href="#l8.1510"></a><span id="l8.1510" class="difflineplus">+    else { // Check character by character to convert CRs and find terminating sequence</span>
<a href="#l8.1511"></a><span id="l8.1511" class="difflineplus">+      while (m_fifoBufferReadPos &lt; m_fifoBufferWrittenPos) {</span>
<a href="#l8.1512"></a><span id="l8.1512" class="difflineplus">+        c = *m_fifoBufferReadPos;</span>
<a href="#l8.1513"></a><span id="l8.1513" class="difflineplus">+        if (m_convertCRs &amp;&amp; wasCR) {</span>
<a href="#l8.1514"></a><span id="l8.1514" class="difflineplus">+          wasCR = false;</span>
<a href="#l8.1515"></a><span id="l8.1515" class="difflineplus">+          if (c != LF) {</span>
<a href="#l8.1516"></a><span id="l8.1516" class="difflineplus">+            dest.Append(&amp;LF, 1);</span>
<a href="#l8.1517"></a><span id="l8.1517" class="difflineplus">+            if (guard.Check(LF)) {</span>
<a href="#l8.1518"></a><span id="l8.1518" class="difflineplus">+              c = LF; // save last char</span>
<a href="#l8.1519"></a><span id="l8.1519" class="difflineplus">+              break;</span>
<a href="#l8.1520"></a><span id="l8.1520" class="difflineplus">+            }</span>
<a href="#l8.1521"></a><span id="l8.1521" class="difflineplus">+          }</span>
<a href="#l8.1522"></a><span id="l8.1522" class="difflineplus">+        }</span>
<a href="#l8.1523"></a><span id="l8.1523" class="difflineplus">+        dest.Append(&amp;c, 1);</span>
<a href="#l8.1524"></a><span id="l8.1524" class="difflineplus">+        m_fifoBufferReadPos++;</span>
<a href="#l8.1525"></a><span id="l8.1525" class="difflineplus">+</span>
<a href="#l8.1526"></a><span id="l8.1526" class="difflineplus">+        if (guard.Check(c))</span>
<a href="#l8.1527"></a><span id="l8.1527" class="difflineplus">+          break;</span>
<a href="#l8.1528"></a><span id="l8.1528" class="difflineplus">+</span>
<a href="#l8.1529"></a><span id="l8.1529" class="difflineplus">+        if (m_convertCRs &amp;&amp; (c == CR))</span>
<a href="#l8.1530"></a><span id="l8.1530" class="difflineplus">+          wasCR = true;</span>
<a href="#l8.1531"></a><span id="l8.1531">       }</span>
<a href="#l8.1532"></a><span id="l8.1532" class="difflineminus">-      else if (IsReplaceHeader( header.get())) {</span>
<a href="#l8.1533"></a><span id="l8.1533" class="difflineminus">-        replaceVal.Truncate();</span>
<a href="#l8.1534"></a><span id="l8.1534" class="difflineminus">-        header.Append( ':');</span>
<a href="#l8.1535"></a><span id="l8.1535" class="difflineminus">-        GetHeaderValue( newHeaders.m_pBuffer, newHeaders.m_writeOffset - 1, header.get(), replaceVal, PR_FALSE);</span>
<a href="#l8.1536"></a><span id="l8.1536" class="difflineminus">-        header.SetLength( header.Length() - 1);</span>
<a href="#l8.1537"></a><span id="l8.1537" class="difflineminus">-        if (!replaceVal.IsEmpty())</span>
<a href="#l8.1538"></a><span id="l8.1538" class="difflineminus">-          val = replaceVal;</span>
<a href="#l8.1539"></a><span id="l8.1539" class="difflineminus">-      }</span>
<a href="#l8.1540"></a><span id="l8.1540" class="difflineminus">-      if (!val.IsEmpty()) {</span>
<a href="#l8.1541"></a><span id="l8.1541" class="difflineminus">-        rv = pDst-&gt;Write( header.get(), header.Length(), &amp;written);</span>
<a href="#l8.1542"></a><span id="l8.1542" class="difflineminus">-        if (NS_SUCCEEDED( rv))</span>
<a href="#l8.1543"></a><span id="l8.1543" class="difflineminus">-          rv = pDst-&gt;Write( &quot;: &quot;, 2, &amp;written);</span>
<a href="#l8.1544"></a><span id="l8.1544" class="difflineminus">-        if (NS_SUCCEEDED( rv))</span>
<a href="#l8.1545"></a><span id="l8.1545" class="difflineminus">-          rv = pDst-&gt;Write( val.get(), val.Length(), &amp;written);</span>
<a href="#l8.1546"></a><span id="l8.1546" class="difflineminus">-        if (NS_SUCCEEDED( rv))</span>
<a href="#l8.1547"></a><span id="l8.1547" class="difflineminus">-          rv = pDst-&gt;Write( &quot;\x0D\x0A&quot;, 2, &amp;written);</span>
<a href="#l8.1548"></a><span id="l8.1548" class="difflineminus">-</span>
<a href="#l8.1549"></a><span id="l8.1549" class="difflineminus">-      }</span>
<a href="#l8.1550"></a><span id="l8.1550" class="difflineminus">-    }</span>
<a href="#l8.1551"></a><span id="l8.1551" class="difflineminus">-    n++;</span>
<a href="#l8.1552"></a><span id="l8.1552" class="difflineminus">-  } while (NS_SUCCEEDED( rv) &amp;&amp; !header.IsEmpty());</span>
<a href="#l8.1553"></a><span id="l8.1553" class="difflineminus">-</span>
<a href="#l8.1554"></a><span id="l8.1554" class="difflineminus">-  for (i = 0; (i &lt; kMaxSpecialHeaders) &amp;&amp; NS_SUCCEEDED( rv); i++) {</span>
<a href="#l8.1555"></a><span id="l8.1555" class="difflineminus">-    if (!specials[i]) {</span>
<a href="#l8.1556"></a><span id="l8.1556" class="difflineminus">-      header = gSpecialHeaders[i];</span>
<a href="#l8.1557"></a><span id="l8.1557" class="difflineminus">-      header.Append( ':');</span>
<a href="#l8.1558"></a><span id="l8.1558" class="difflineminus">-      GetHeaderValue( newHeaders.m_pBuffer, newHeaders.m_writeOffset - 1, header.get(), val, PR_FALSE);</span>
<a href="#l8.1559"></a><span id="l8.1559" class="difflineminus">-      header.SetLength( header.Length() - 1);</span>
<a href="#l8.1560"></a><span id="l8.1560" class="difflineminus">-      if (!val.IsEmpty()) {</span>
<a href="#l8.1561"></a><span id="l8.1561" class="difflineminus">-        rv = pDst-&gt;Write( header.get(), header.Length(), &amp;written);</span>
<a href="#l8.1562"></a><span id="l8.1562" class="difflineminus">-        if (NS_SUCCEEDED( rv))</span>
<a href="#l8.1563"></a><span id="l8.1563" class="difflineminus">-          rv = pDst-&gt;Write( &quot;: &quot;, 2, &amp;written);</span>
<a href="#l8.1564"></a><span id="l8.1564" class="difflineminus">-        if (NS_SUCCEEDED( rv))</span>
<a href="#l8.1565"></a><span id="l8.1565" class="difflineminus">-          rv = pDst-&gt;Write( val.get(), val.Length(), &amp;written);</span>
<a href="#l8.1566"></a><span id="l8.1566" class="difflineminus">-        if (NS_SUCCEEDED( rv))</span>
<a href="#l8.1567"></a><span id="l8.1567" class="difflineminus">-          rv = pDst-&gt;Write( &quot;\x0D\x0A&quot;, 2, &amp;written);</span>
<a href="#l8.1568"></a><span id="l8.1568" class="difflineminus">-      }</span>
<a href="#l8.1569"></a><span id="l8.1569" class="difflineplus">+      if (guard.IsTriggered())</span>
<a href="#l8.1570"></a><span id="l8.1570" class="difflineplus">+        break;</span>
<a href="#l8.1571"></a><span id="l8.1571">     }</span>
<a href="#l8.1572"></a><span id="l8.1572">   }</span>
<a href="#l8.1573"></a><span id="l8.1573"> </span>
<a href="#l8.1574"></a><span id="l8.1574" class="difflineplus">+  // check for trailing CR (only if caller didn't specify the terminating sequence that ends with CR -</span>
<a href="#l8.1575"></a><span id="l8.1575" class="difflineplus">+  // in this case he knows what he does!)</span>
<a href="#l8.1576"></a><span id="l8.1576" class="difflineplus">+  if (m_convertCRs &amp;&amp; !guard.IsTriggered() &amp;&amp; (c == CR)) {</span>
<a href="#l8.1577"></a><span id="l8.1577" class="difflineplus">+    c = LF;</span>
<a href="#l8.1578"></a><span id="l8.1578" class="difflineplus">+    dest.Append(&amp;c, 1);</span>
<a href="#l8.1579"></a><span id="l8.1579" class="difflineplus">+  }</span>
<a href="#l8.1580"></a><span id="l8.1580"> </span>
<a href="#l8.1581"></a><span id="l8.1581" class="difflineminus">-  if (NS_SUCCEEDED( rv))</span>
<a href="#l8.1582"></a><span id="l8.1582" class="difflineminus">-    rv = pDst-&gt;Write( &quot;\x0D\x0A&quot;, 2, &amp;written);</span>
<a href="#l8.1583"></a><span id="l8.1583" class="difflineminus">-  return( rv);</span>
<a href="#l8.1584"></a><span id="l8.1584" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l8.1585"></a><span id="l8.1585" class="difflineplus">+</span>
<a href="#l8.1586"></a><span id="l8.1586" class="difflineplus">+  m_lastChar = c;</span>
<a href="#l8.1587"></a><span id="l8.1587" class="difflineplus">+  return NS_OK;</span>
<a href="#l8.1588"></a><span id="l8.1588"> }</span>
<a href="#l8.1589"></a><span id="l8.1589"> </span>
<a href="#l8.1590"></a><span id="l8.1590" class="difflineplus">+class dest_nsCString {</span>
<a href="#l8.1591"></a><span id="l8.1591" class="difflineplus">+public:</span>
<a href="#l8.1592"></a><span id="l8.1592" class="difflineplus">+  dest_nsCString(nsCString&amp; str) : m_str(str) { m_str.Truncate(); }</span>
<a href="#l8.1593"></a><span id="l8.1593" class="difflineplus">+  void SetCapacity(PRInt32 sz) { m_str.SetCapacity(sz); }</span>
<a href="#l8.1594"></a><span id="l8.1594" class="difflineplus">+  nsresult Append(const char* buf, PRUint32 count) {</span>
<a href="#l8.1595"></a><span id="l8.1595" class="difflineplus">+    m_str.Append(buf, count); return NS_OK; }</span>
<a href="#l8.1596"></a><span id="l8.1596" class="difflineplus">+private:</span>
<a href="#l8.1597"></a><span id="l8.1597" class="difflineplus">+  nsCString&amp; m_str;</span>
<a href="#l8.1598"></a><span id="l8.1598" class="difflineplus">+};</span>
<a href="#l8.1599"></a><span id="l8.1599"> </span>
<a href="#l8.1600"></a><span id="l8.1600" class="difflineplus">+class dest_Stream {</span>
<a href="#l8.1601"></a><span id="l8.1601" class="difflineplus">+public:</span>
<a href="#l8.1602"></a><span id="l8.1602" class="difflineplus">+  dest_Stream(nsIOutputStream *dest) : m_stream(dest) {}</span>
<a href="#l8.1603"></a><span id="l8.1603" class="difflineplus">+  void SetCapacity(PRInt32) { /*do nothing*/ }</span>
<a href="#l8.1604"></a><span id="l8.1604" class="difflineplus">+  // const_cast here is due to the poor design of the EscapeFromSpaceLine()</span>
<a href="#l8.1605"></a><span id="l8.1605" class="difflineplus">+  // that requires a non-constant pointer while doesn't modify its data</span>
<a href="#l8.1606"></a><span id="l8.1606" class="difflineplus">+  nsresult Append(const char* buf, PRUint32 count) {</span>
<a href="#l8.1607"></a><span id="l8.1607" class="difflineplus">+    return EscapeFromSpaceLine(m_stream, const_cast&lt;char*&gt;(buf), buf+count); }</span>
<a href="#l8.1608"></a><span id="l8.1608" class="difflineplus">+private:</span>
<a href="#l8.1609"></a><span id="l8.1609" class="difflineplus">+  nsIOutputStream *m_stream;</span>
<a href="#l8.1610"></a><span id="l8.1610" class="difflineplus">+};</span>
<a href="#l8.1611"></a><span id="l8.1611" class="difflineplus">+</span>
<a href="#l8.1612"></a><span id="l8.1612" class="difflineplus">+nsresult CCompositionFile::ToString(nsCString&amp; dest, const char* term,</span>
<a href="#l8.1613"></a><span id="l8.1613" class="difflineplus">+                                    int termSize)</span>
<a href="#l8.1614"></a><span id="l8.1614" class="difflineplus">+{</span>
<a href="#l8.1615"></a><span id="l8.1615" class="difflineplus">+  return ToDest(dest_nsCString(dest), term, termSize);</span>
<a href="#l8.1616"></a><span id="l8.1616" class="difflineplus">+}</span>
<a href="#l8.1617"></a><span id="l8.1617" class="difflineplus">+</span>
<a href="#l8.1618"></a><span id="l8.1618" class="difflineplus">+nsresult CCompositionFile::ToStream(nsIOutputStream *dest, const char* term,</span>
<a href="#l8.1619"></a><span id="l8.1619" class="difflineplus">+                                    int termSize)</span>
<a href="#l8.1620"></a><span id="l8.1620" class="difflineplus">+{</span>
<a href="#l8.1621"></a><span id="l8.1621" class="difflineplus">+  return ToDest(dest_Stream(dest), term, termSize);</span>
<a href="#l8.1622"></a><span id="l8.1622" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/import/outlook/src/nsOutlookCompose.h</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/import/outlook/src/nsOutlookCompose.h</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -49,137 +49,72 @@ class nsIMsgSend;</span>
<a href="#l9.4"></a><span id="l9.4"> class nsIMsgCompFields;</span>
<a href="#l9.5"></a><span id="l9.5"> class nsIMsgIdentity;</span>
<a href="#l9.6"></a><span id="l9.6"> class nsIMsgSendListener;</span>
<a href="#l9.7"></a><span id="l9.7"> class nsIIOService;</span>
<a href="#l9.8"></a><span id="l9.8"> </span>
<a href="#l9.9"></a><span id="l9.9"> #include &quot;nsIMsgSend.h&quot;</span>
<a href="#l9.10"></a><span id="l9.10"> #include &quot;nsNetUtil.h&quot;</span>
<a href="#l9.11"></a><span id="l9.11"> </span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-typedef class {</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineminus">-public:</span>
<a href="#l9.14"></a><span id="l9.14" class="difflineminus">-  nsCOMPtr &lt;nsILocalFile&gt;  pAttachment;</span>
<a href="#l9.15"></a><span id="l9.15" class="difflineminus">-  char *      mimeType;</span>
<a href="#l9.16"></a><span id="l9.16" class="difflineminus">-  char *      description;</span>
<a href="#l9.17"></a><span id="l9.17" class="difflineminus">-} OutlookAttachment;</span>
<a href="#l9.18"></a><span id="l9.18" class="difflineminus">-</span>
<a href="#l9.19"></a><span id="l9.19" class="difflineminus">-typedef class {</span>
<a href="#l9.20"></a><span id="l9.20" class="difflineminus">-public:</span>
<a href="#l9.21"></a><span id="l9.21" class="difflineminus">-  PRUint32    offset;</span>
<a href="#l9.22"></a><span id="l9.22" class="difflineminus">-  PRInt64    size;</span>
<a href="#l9.23"></a><span id="l9.23" class="difflineminus">-  nsCOMPtr &lt;nsIFile&gt;  pFile;</span>
<a href="#l9.24"></a><span id="l9.24" class="difflineminus">-        nsCOMPtr &lt;nsIInputStream&gt; pInputStream;</span>
<a href="#l9.25"></a><span id="l9.25" class="difflineminus">-} ReadFileState;</span>
<a href="#l9.26"></a><span id="l9.26" class="difflineminus">-</span>
<a href="#l9.27"></a><span id="l9.27" class="difflineminus">-class SimpleBufferTonyRCopiedTwice {</span>
<a href="#l9.28"></a><span id="l9.28" class="difflineminus">-public:</span>
<a href="#l9.29"></a><span id="l9.29" class="difflineminus">-  SimpleBufferTonyRCopiedTwice() {m_pBuffer = nsnull; m_size = 0; m_growBy = 4096; m_writeOffset = 0;</span>
<a href="#l9.30"></a><span id="l9.30" class="difflineminus">-          m_bytesInBuf = 0; m_convertCRs = PR_FALSE;}</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineminus">-  ~SimpleBufferTonyRCopiedTwice() { if (m_pBuffer) delete [] m_pBuffer;}</span>
<a href="#l9.32"></a><span id="l9.32" class="difflineminus">-</span>
<a href="#l9.33"></a><span id="l9.33" class="difflineminus">-  PRBool Allocate( PRInt32 sz) {</span>
<a href="#l9.34"></a><span id="l9.34" class="difflineminus">-    if (m_pBuffer) delete [] m_pBuffer;</span>
<a href="#l9.35"></a><span id="l9.35" class="difflineminus">-    m_pBuffer = new char[sz];</span>
<a href="#l9.36"></a><span id="l9.36" class="difflineminus">-    if (m_pBuffer) { m_size = sz; return( PR_TRUE); }</span>
<a href="#l9.37"></a><span id="l9.37" class="difflineminus">-    else { m_size = 0; return( PR_FALSE);}</span>
<a href="#l9.38"></a><span id="l9.38" class="difflineminus">-  }</span>
<a href="#l9.39"></a><span id="l9.39" class="difflineplus">+#include &quot;MapiMessage.h&quot;</span>
<a href="#l9.40"></a><span id="l9.40"> </span>
<a href="#l9.41"></a><span id="l9.41" class="difflineminus">-  PRBool Grow( PRInt32 newSize) { if (newSize &gt; m_size) return( ReAllocate( newSize)); else return( PR_TRUE);}</span>
<a href="#l9.42"></a><span id="l9.42" class="difflineminus">-  PRBool ReAllocate( PRInt32 newSize) {</span>
<a href="#l9.43"></a><span id="l9.43" class="difflineminus">-    if (newSize &lt;= m_size) return( PR_TRUE);</span>
<a href="#l9.44"></a><span id="l9.44" class="difflineminus">-    char *pOldBuffer = m_pBuffer;</span>
<a href="#l9.45"></a><span id="l9.45" class="difflineminus">-    PRInt32  oldSize = m_size;</span>
<a href="#l9.46"></a><span id="l9.46" class="difflineminus">-    m_pBuffer = nsnull;</span>
<a href="#l9.47"></a><span id="l9.47" class="difflineminus">-    while (m_size &lt; newSize) m_size += m_growBy;</span>
<a href="#l9.48"></a><span id="l9.48" class="difflineminus">-    if (Allocate( m_size)) {</span>
<a href="#l9.49"></a><span id="l9.49" class="difflineminus">-      if (pOldBuffer) { memcpy( m_pBuffer, pOldBuffer, oldSize); delete [] pOldBuffer;}</span>
<a href="#l9.50"></a><span id="l9.50" class="difflineminus">-      return( PR_TRUE);</span>
<a href="#l9.51"></a><span id="l9.51" class="difflineminus">-    }</span>
<a href="#l9.52"></a><span id="l9.52" class="difflineminus">-    else { m_pBuffer = pOldBuffer; m_size = oldSize; return( PR_FALSE);}</span>
<a href="#l9.53"></a><span id="l9.53" class="difflineminus">-  }</span>
<a href="#l9.54"></a><span id="l9.54" class="difflineplus">+#include &lt;list&gt;</span>
<a href="#l9.55"></a><span id="l9.55"> </span>
<a href="#l9.56"></a><span id="l9.56" class="difflineminus">-  PRBool Write( PRInt32 offset, const char *pData, PRInt32 len, PRInt32 *pWritten) {</span>
<a href="#l9.57"></a><span id="l9.57" class="difflineminus">-    *pWritten = len;</span>
<a href="#l9.58"></a><span id="l9.58" class="difflineminus">-    if (!len) return( PR_TRUE);</span>
<a href="#l9.59"></a><span id="l9.59" class="difflineminus">-    if (!Grow( offset + len)) return( PR_FALSE);</span>
<a href="#l9.60"></a><span id="l9.60" class="difflineminus">-    if (m_convertCRs)</span>
<a href="#l9.61"></a><span id="l9.61" class="difflineminus">-      return( SpecialMemCpy( offset, pData, len, pWritten));</span>
<a href="#l9.62"></a><span id="l9.62" class="difflineminus">-    memcpy( m_pBuffer + offset, pData, len);</span>
<a href="#l9.63"></a><span id="l9.63" class="difflineminus">-    return( PR_TRUE);</span>
<a href="#l9.64"></a><span id="l9.64" class="difflineminus">-  }</span>
<a href="#l9.65"></a><span id="l9.65" class="difflineminus">-</span>
<a href="#l9.66"></a><span id="l9.66" class="difflineminus">-  PRBool Write( const char *pData, PRInt32 len) {</span>
<a href="#l9.67"></a><span id="l9.67" class="difflineminus">-    PRInt32 written;</span>
<a href="#l9.68"></a><span id="l9.68" class="difflineminus">-    if (Write( m_writeOffset, pData, len, &amp;written)) { m_writeOffset += written; return( PR_TRUE);}</span>
<a href="#l9.69"></a><span id="l9.69" class="difflineminus">-    else return( PR_FALSE);</span>
<a href="#l9.70"></a><span id="l9.70" class="difflineminus">-  }</span>
<a href="#l9.71"></a><span id="l9.71" class="difflineminus">-</span>
<a href="#l9.72"></a><span id="l9.72" class="difflineminus">-  PRBool  SpecialMemCpy( PRInt32 offset, const char *pData, PRInt32 len, PRInt32 *pWritten);</span>
<a href="#l9.73"></a><span id="l9.73" class="difflineminus">-</span>
<a href="#l9.74"></a><span id="l9.74" class="difflineminus">-  PRBool  m_convertCRs;</span>
<a href="#l9.75"></a><span id="l9.75" class="difflineminus">-  char *  m_pBuffer;</span>
<a href="#l9.76"></a><span id="l9.76" class="difflineminus">-  PRInt32  m_bytesInBuf;  // used when reading into this buffer</span>
<a href="#l9.77"></a><span id="l9.77" class="difflineminus">-  PRInt32  m_size;      // allocated size of buffer</span>
<a href="#l9.78"></a><span id="l9.78" class="difflineminus">-  PRInt32  m_growBy;    // duh</span>
<a href="#l9.79"></a><span id="l9.79" class="difflineminus">-  PRInt32  m_writeOffset;  // used when writing into and reading from the buffer</span>
<a href="#l9.80"></a><span id="l9.80" class="difflineminus">-};</span>
<a href="#l9.81"></a><span id="l9.81" class="difflineminus">-</span>
<a href="#l9.82"></a><span id="l9.82" class="difflineminus">-</span>
<a href="#l9.83"></a><span id="l9.83" class="difflineplus">+///////////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l9.84"></a><span id="l9.84"> </span>
<a href="#l9.85"></a><span id="l9.85"> class nsOutlookCompose {</span>
<a href="#l9.86"></a><span id="l9.86"> public:</span>
<a href="#l9.87"></a><span id="l9.87">   nsOutlookCompose();</span>
<a href="#l9.88"></a><span id="l9.88">   ~nsOutlookCompose();</span>
<a href="#l9.89"></a><span id="l9.89"> </span>
<a href="#l9.90"></a><span id="l9.90" class="difflineminus">-  nsresult  SendTheMessage(nsMsgDeliverMode mode, nsCString &amp;useThisCType, nsIFile **pMsg);</span>
<a href="#l9.91"></a><span id="l9.91" class="difflineminus">-</span>
<a href="#l9.92"></a><span id="l9.92" class="difflineminus">-  void    SetBody( const char *pBody) { m_Body = pBody;}</span>
<a href="#l9.93"></a><span id="l9.93" class="difflineminus">-  void    SetHeaders( const char *pHeaders) { m_Headers = pHeaders;}</span>
<a href="#l9.94"></a><span id="l9.94" class="difflineminus">-  void    SetAttachments( nsVoidArray *pAttachments) { m_pAttachments = pAttachments;}</span>
<a href="#l9.95"></a><span id="l9.95" class="difflineplus">+  nsresult ProcessMessage(nsMsgDeliverMode mode, CMapiMessage &amp;msg, nsIOutputStream *pDst);</span>
<a href="#l9.96"></a><span id="l9.96" class="difflineplus">+private:</span>
<a href="#l9.97"></a><span id="l9.97" class="difflineplus">+  struct CidReplacePair {</span>
<a href="#l9.98"></a><span id="l9.98" class="difflineplus">+    nsCString cidOrig;</span>
<a href="#l9.99"></a><span id="l9.99" class="difflineplus">+    nsCString cidNew;</span>
<a href="#l9.100"></a><span id="l9.100" class="difflineplus">+  };</span>
<a href="#l9.101"></a><span id="l9.101"> </span>
<a href="#l9.102"></a><span id="l9.102" class="difflineminus">-  nsresult  CopyComposedMessage( nsCString&amp; fromLine, nsIFile *pSrc, nsIOutputStream *pDst, SimpleBufferTonyRCopiedTwice&amp; copy);</span>
<a href="#l9.103"></a><span id="l9.103" class="difflineminus">-</span>
<a href="#l9.104"></a><span id="l9.104" class="difflineminus">-  static nsresult  FillMailBuffer( ReadFileState *pState, SimpleBufferTonyRCopiedTwice&amp; read);</span>
<a href="#l9.105"></a><span id="l9.105" class="difflineminus">-</span>
<a href="#l9.106"></a><span id="l9.106" class="difflineminus">-private:</span>
<a href="#l9.107"></a><span id="l9.107">   nsresult  CreateComponents( void);</span>
<a href="#l9.108"></a><span id="l9.108">   nsresult  CreateIdentity( void);</span>
<a href="#l9.109"></a><span id="l9.109"> </span>
<a href="#l9.110"></a><span id="l9.110" class="difflineminus">-  void    GetNthHeader( const char *pData, PRInt32 dataLen, PRInt32 n, nsCString&amp; header, nsCString&amp; val, PRBool unwrap);</span>
<a href="#l9.111"></a><span id="l9.111" class="difflineminus">-  void    GetHeaderValue( const char *pData, PRInt32 dataLen, const char *pHeader, nsCString&amp; val, PRBool unwrap = PR_TRUE);</span>
<a href="#l9.112"></a><span id="l9.112" class="difflineminus">-  void    GetHeaderValue( const char *pData, PRInt32 dataLen, const char *pHeader, nsString&amp; val) {</span>
<a href="#l9.113"></a><span id="l9.113" class="difflineminus">-    val.Truncate();</span>
<a href="#l9.114"></a><span id="l9.114" class="difflineminus">-    nsCString  hVal;</span>
<a href="#l9.115"></a><span id="l9.115" class="difflineminus">-    GetHeaderValue( pData, dataLen, pHeader, hVal, PR_TRUE);</span>
<a href="#l9.116"></a><span id="l9.116" class="difflineminus">-    CopyUTF8toUTF16(hVal, val);</span>
<a href="#l9.117"></a><span id="l9.117" class="difflineminus">-  }</span>
<a href="#l9.118"></a><span id="l9.118" class="difflineminus">-  void    ExtractCharset( nsString&amp; str);</span>
<a href="#l9.119"></a><span id="l9.119" class="difflineminus">-  void    ExtractMetaCharset( nsCString str, nsString&amp; newstr);</span>
<a href="#l9.120"></a><span id="l9.120" class="difflineminus">-  void    ExtractType( nsString&amp; str);</span>
<a href="#l9.121"></a><span id="l9.121" class="difflineplus">+  void      UpdateHeader(CMapiMessageHeaders&amp; oldHeaders, const CMapiMessageHeaders&amp; newHeaders, CMapiMessageHeaders::SpecialHeader header, bool addIfAbsent = true);</span>
<a href="#l9.122"></a><span id="l9.122" class="difflineplus">+  void      UpdateHeaders(CMapiMessageHeaders&amp; oldHeaders, const CMapiMessageHeaders&amp; newHeaders);</span>
<a href="#l9.123"></a><span id="l9.123" class="difflineplus">+</span>
<a href="#l9.124"></a><span id="l9.124" class="difflineplus">+  nsresult  ComposeTheMessage(nsMsgDeliverMode mode, CMapiMessage &amp;msg, nsIFile **pMsg);</span>
<a href="#l9.125"></a><span id="l9.125" class="difflineplus">+  nsresult  CopyComposedMessage( nsIFile *pSrc, nsIOutputStream *pDst, CMapiMessage&amp; origMsg);</span>
<a href="#l9.126"></a><span id="l9.126" class="difflineplus">+</span>
<a href="#l9.127"></a><span id="l9.127" class="difflineplus">+  // Bug 593907</span>
<a href="#l9.128"></a><span id="l9.128" class="difflineplus">+  void HackBody(const wchar_t* orig, size_t origLen, nsString&amp; hack);</span>
<a href="#l9.129"></a><span id="l9.129" class="difflineplus">+  void UnhackBody(nsCString&amp; body);</span>
<a href="#l9.130"></a><span id="l9.130" class="difflineplus">+  bool GenerateHackSequence(const wchar_t* body, size_t origLen);</span>
<a href="#l9.131"></a><span id="l9.131" class="difflineplus">+  // End Bug 593907</span>
<a href="#l9.132"></a><span id="l9.132"> </span>
<a href="#l9.133"></a><span id="l9.133" class="difflineminus">-  nsMsgAttachedFile * GetLocalAttachments( void);</span>
<a href="#l9.134"></a><span id="l9.134" class="difflineminus">-  void        CleanUpAttach( nsMsgAttachedFile *a, PRInt32 count);</span>
<a href="#l9.135"></a><span id="l9.135" class="difflineplus">+  static void ClearReplaceCid(CidReplacePair* pair) { delete pair; }</span>
<a href="#l9.136"></a><span id="l9.136" class="difflineplus">+  void ClearReplaceCids();</span>
<a href="#l9.137"></a><span id="l9.137" class="difflineplus">+private:</span>
<a href="#l9.138"></a><span id="l9.138" class="difflineplus">+  std::list&lt;CidReplacePair*&gt; m_replacedCids;</span>
<a href="#l9.139"></a><span id="l9.139"> </span>
<a href="#l9.140"></a><span id="l9.140" class="difflineminus">-  nsresult  ReadHeaders( ReadFileState *pState, SimpleBufferTonyRCopiedTwice&amp; copy, SimpleBufferTonyRCopiedTwice&amp; header);</span>
<a href="#l9.141"></a><span id="l9.141" class="difflineminus">-  PRInt32    FindNextEndLine( SimpleBufferTonyRCopiedTwice&amp; data);</span>
<a href="#l9.142"></a><span id="l9.142" class="difflineminus">-  PRInt32    IsEndHeaders( SimpleBufferTonyRCopiedTwice&amp; data);</span>
<a href="#l9.143"></a><span id="l9.143" class="difflineminus">-  PRInt32    IsSpecialHeader( const char *pHeader);</span>
<a href="#l9.144"></a><span id="l9.144" class="difflineminus">-  nsresult  WriteHeaders( nsIOutputStream *pDst, SimpleBufferTonyRCopiedTwice&amp; newHeaders);</span>
<a href="#l9.145"></a><span id="l9.145" class="difflineminus">-  PRBool    IsReplaceHeader( const char *pHeader);</span>
<a href="#l9.146"></a><span id="l9.146" class="difflineminus">-  void      ConvertSystemStringToUnicode( const char *pSysStr, nsString&amp; uniStr);</span>
<a href="#l9.147"></a><span id="l9.147" class="difflineplus">+  class ReplaceCidInLine {</span>
<a href="#l9.148"></a><span id="l9.148" class="difflineplus">+  public:</span>
<a href="#l9.149"></a><span id="l9.149" class="difflineplus">+    ReplaceCidInLine(nsCString&amp; line);</span>
<a href="#l9.150"></a><span id="l9.150" class="difflineplus">+    void operator () (const CidReplacePair* pair);</span>
<a href="#l9.151"></a><span id="l9.151" class="difflineplus">+  private:</span>
<a href="#l9.152"></a><span id="l9.152" class="difflineplus">+    nsCString&amp; m_line;</span>
<a href="#l9.153"></a><span id="l9.153" class="difflineplus">+    bool m_finishedReplacing;</span>
<a href="#l9.154"></a><span id="l9.154" class="difflineplus">+  };</span>
<a href="#l9.155"></a><span id="l9.155"> </span>
<a href="#l9.156"></a><span id="l9.156"> </span>
<a href="#l9.157"></a><span id="l9.157" class="difflineminus">-private:</span>
<a href="#l9.158"></a><span id="l9.158" class="difflineminus">-  nsVoidArray *      m_pAttachments;</span>
<a href="#l9.159"></a><span id="l9.159">   nsIMsgSendListener *  m_pListener;</span>
<a href="#l9.160"></a><span id="l9.160">   nsIMsgSend *      m_pMsgSend;</span>
<a href="#l9.161"></a><span id="l9.161">   nsIMsgSend *      m_pSendProxy;</span>
<a href="#l9.162"></a><span id="l9.162">   nsIMsgCompFields *    m_pMsgFields;</span>
<a href="#l9.163"></a><span id="l9.163">   nsIMsgIdentity *    m_pIdentity;</span>
<a href="#l9.164"></a><span id="l9.164" class="difflineminus">-  nsIIOService *      m_pIOService;</span>
<a href="#l9.165"></a><span id="l9.165" class="difflineminus">-  nsCString       m_Headers;</span>
<a href="#l9.166"></a><span id="l9.166" class="difflineminus">-  nsCString       m_Body;</span>
<a href="#l9.167"></a><span id="l9.167" class="difflineminus">-  SimpleBufferTonyRCopiedTwice      m_readHeaders;</span>
<a href="#l9.168"></a><span id="l9.168" class="difflineplus">+  char* m_optimizationBuffer;</span>
<a href="#l9.169"></a><span id="l9.169" class="difflineplus">+  unsigned int m_optimizationBufferSize;</span>
<a href="#l9.170"></a><span id="l9.170">   nsCOMPtr&lt;nsIImportService&gt;  m_pImportService;</span>
<a href="#l9.171"></a><span id="l9.171" class="difflineplus">+</span>
<a href="#l9.172"></a><span id="l9.172" class="difflineplus">+  // Bug 593907</span>
<a href="#l9.173"></a><span id="l9.173" class="difflineplus">+  nsString m_hackedPostfix;</span>
<a href="#l9.174"></a><span id="l9.174" class="difflineplus">+  // End Bug 593907</span>
<a href="#l9.175"></a><span id="l9.175"> };</span>
<a href="#l9.176"></a><span id="l9.176"> </span>
<a href="#l9.177"></a><span id="l9.177"> </span>
<a href="#l9.178"></a><span id="l9.178"> #endif /* nsOutlookCompose_h__ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1">new file mode 100644</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineminus">--- /dev/null</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineplus">+++ b/mailnews/import/outlook/src/nsOutlookEditor.cpp</span>
<a href="#l10.4"></a><span id="l10.4" class="difflineat">@@ -0,0 +1,1161 @@</span>
<a href="#l10.5"></a><span id="l10.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l10.6"></a><span id="l10.6" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l10.7"></a><span id="l10.7" class="difflineplus">+* Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l10.8"></a><span id="l10.8" class="difflineplus">+*</span>
<a href="#l10.9"></a><span id="l10.9" class="difflineplus">+* The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l10.10"></a><span id="l10.10" class="difflineplus">+* 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l10.11"></a><span id="l10.11" class="difflineplus">+* the License. You may obtain a copy of the License at</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+* http://www.mozilla.org/MPL/</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+*</span>
<a href="#l10.14"></a><span id="l10.14" class="difflineplus">+* Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l10.15"></a><span id="l10.15" class="difflineplus">+* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l10.16"></a><span id="l10.16" class="difflineplus">+* for the specific language governing rights and limitations under the</span>
<a href="#l10.17"></a><span id="l10.17" class="difflineplus">+* License.</span>
<a href="#l10.18"></a><span id="l10.18" class="difflineplus">+*</span>
<a href="#l10.19"></a><span id="l10.19" class="difflineplus">+* The Original Code is qualcomm.com code.</span>
<a href="#l10.20"></a><span id="l10.20" class="difflineplus">+*</span>
<a href="#l10.21"></a><span id="l10.21" class="difflineplus">+* The Initial Developer of the Original Code is</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineplus">+* QUALCOMM, Inc.</span>
<a href="#l10.23"></a><span id="l10.23" class="difflineplus">+* Portions created by the Initial Developer are Copyright (C) 2007</span>
<a href="#l10.24"></a><span id="l10.24" class="difflineplus">+* the Initial Developer. All Rights Reserved.</span>
<a href="#l10.25"></a><span id="l10.25" class="difflineplus">+*</span>
<a href="#l10.26"></a><span id="l10.26" class="difflineplus">+* Contributor(s):</span>
<a href="#l10.27"></a><span id="l10.27" class="difflineplus">+*   Author: Geoffrey C. Wenger (gwenger@qualcomm.com)</span>
<a href="#l10.28"></a><span id="l10.28" class="difflineplus">+*</span>
<a href="#l10.29"></a><span id="l10.29" class="difflineplus">+* Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l10.30"></a><span id="l10.30" class="difflineplus">+* either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l10.31"></a><span id="l10.31" class="difflineplus">+* the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l10.32"></a><span id="l10.32" class="difflineplus">+* in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l10.33"></a><span id="l10.33" class="difflineplus">+* of those above. If you wish to allow use of your version of this file only</span>
<a href="#l10.34"></a><span id="l10.34" class="difflineplus">+* under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l10.35"></a><span id="l10.35" class="difflineplus">+* use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l10.36"></a><span id="l10.36" class="difflineplus">+* decision by deleting the provisions above and replace them with the notice</span>
<a href="#l10.37"></a><span id="l10.37" class="difflineplus">+* and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l10.38"></a><span id="l10.38" class="difflineplus">+* the provisions above, a recipient may use your version of this file under</span>
<a href="#l10.39"></a><span id="l10.39" class="difflineplus">+* the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l10.40"></a><span id="l10.40" class="difflineplus">+*</span>
<a href="#l10.41"></a><span id="l10.41" class="difflineplus">+* ***** END LICENSE BLOCK ***** */</span>
<a href="#l10.42"></a><span id="l10.42" class="difflineplus">+</span>
<a href="#l10.43"></a><span id="l10.43" class="difflineplus">+</span>
<a href="#l10.44"></a><span id="l10.44" class="difflineplus">+#include &quot;nsOutlookEditor.h&quot;</span>
<a href="#l10.45"></a><span id="l10.45" class="difflineplus">+#include &quot;nsISupportsArray.h&quot;</span>
<a href="#l10.46"></a><span id="l10.46" class="difflineplus">+#include &quot;nsIDOMHTMLImageElement.h&quot;</span>
<a href="#l10.47"></a><span id="l10.47" class="difflineplus">+#include &quot;nsComponentManagerUtils.h&quot;</span>
<a href="#l10.48"></a><span id="l10.48" class="difflineplus">+#include &quot;nsString.h&quot;</span>
<a href="#l10.49"></a><span id="l10.49" class="difflineplus">+#include &quot;nsNetUtil.h&quot;</span>
<a href="#l10.50"></a><span id="l10.50" class="difflineplus">+</span>
<a href="#l10.51"></a><span id="l10.51" class="difflineplus">+NS_IMPL_ISUPPORTS2(nsOutlookEditor, nsIEditor, nsIEditorMailSupport)</span>
<a href="#l10.52"></a><span id="l10.52" class="difflineplus">+NS_IMPL_THREADSAFE_ISUPPORTS5(nsOutlookHTMLImageElement,</span>
<a href="#l10.53"></a><span id="l10.53" class="difflineplus">+                              nsOutlookHTMLImageElement,</span>
<a href="#l10.54"></a><span id="l10.54" class="difflineplus">+                              nsIDOMHTMLImageElement,</span>
<a href="#l10.55"></a><span id="l10.55" class="difflineplus">+                              nsIDOMHTMLElement,</span>
<a href="#l10.56"></a><span id="l10.56" class="difflineplus">+                              nsIDOMElement,</span>
<a href="#l10.57"></a><span id="l10.57" class="difflineplus">+                              nsIDOMNode)</span>
<a href="#l10.58"></a><span id="l10.58" class="difflineplus">+</span>
<a href="#l10.59"></a><span id="l10.59" class="difflineplus">+nsOutlookEditor::nsOutlookEditor(const wchar_t * body)</span>
<a href="#l10.60"></a><span id="l10.60" class="difflineplus">+  : m_body(body)</span>
<a href="#l10.61"></a><span id="l10.61" class="difflineplus">+{</span>
<a href="#l10.62"></a><span id="l10.62" class="difflineplus">+}</span>
<a href="#l10.63"></a><span id="l10.63" class="difflineplus">+</span>
<a href="#l10.64"></a><span id="l10.64" class="difflineplus">+nsOutlookEditor::~nsOutlookEditor()</span>
<a href="#l10.65"></a><span id="l10.65" class="difflineplus">+{</span>
<a href="#l10.66"></a><span id="l10.66" class="difflineplus">+}</span>
<a href="#l10.67"></a><span id="l10.67" class="difflineplus">+</span>
<a href="#l10.68"></a><span id="l10.68" class="difflineplus">+// readonly attribute nsISelection selection</span>
<a href="#l10.69"></a><span id="l10.69" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetSelection(nsISelection * *aSelection)</span>
<a href="#l10.70"></a><span id="l10.70" class="difflineplus">+{</span>
<a href="#l10.71"></a><span id="l10.71" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.72"></a><span id="l10.72" class="difflineplus">+}</span>
<a href="#l10.73"></a><span id="l10.73" class="difflineplus">+</span>
<a href="#l10.74"></a><span id="l10.74" class="difflineplus">+// [noscript] void init (in nsIDOMDocument doc, in nsIPresShellPtr shell, in nsIContentPtr aRoot, in nsISelectionController aSelCon, in unsigned long aFlags)</span>
<a href="#l10.75"></a><span id="l10.75" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::Init(nsIDOMDocument *doc, nsIContent * aRoot, nsISelectionController *aSelCon, PRUint32 aFlags)</span>
<a href="#l10.76"></a><span id="l10.76" class="difflineplus">+{</span>
<a href="#l10.77"></a><span id="l10.77" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.78"></a><span id="l10.78" class="difflineplus">+}</span>
<a href="#l10.79"></a><span id="l10.79" class="difflineplus">+</span>
<a href="#l10.80"></a><span id="l10.80" class="difflineplus">+// void setAttributeOrEquivalent (in nsIDOMElement element, in AString sourceAttrName, in AString sourceAttrValue, in boolean aSuppressTransaction)</span>
<a href="#l10.81"></a><span id="l10.81" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::SetAttributeOrEquivalent(nsIDOMElement *element, const nsAString &amp; sourceAttrName, const nsAString &amp; sourceAttrValue, PRBool aSuppressTransaction)</span>
<a href="#l10.82"></a><span id="l10.82" class="difflineplus">+{</span>
<a href="#l10.83"></a><span id="l10.83" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.84"></a><span id="l10.84" class="difflineplus">+}</span>
<a href="#l10.85"></a><span id="l10.85" class="difflineplus">+</span>
<a href="#l10.86"></a><span id="l10.86" class="difflineplus">+// void removeAttributeOrEquivalent (in nsIDOMElement element, in DOMString sourceAttrName, in boolean aSuppressTransaction)</span>
<a href="#l10.87"></a><span id="l10.87" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::RemoveAttributeOrEquivalent(nsIDOMElement *element, const nsAString &amp; sourceAttrName, PRBool aSuppressTransaction)</span>
<a href="#l10.88"></a><span id="l10.88" class="difflineplus">+{</span>
<a href="#l10.89"></a><span id="l10.89" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.90"></a><span id="l10.90" class="difflineplus">+}</span>
<a href="#l10.91"></a><span id="l10.91" class="difflineplus">+</span>
<a href="#l10.92"></a><span id="l10.92" class="difflineplus">+// void postCreate ()</span>
<a href="#l10.93"></a><span id="l10.93" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::PostCreate()</span>
<a href="#l10.94"></a><span id="l10.94" class="difflineplus">+{</span>
<a href="#l10.95"></a><span id="l10.95" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.96"></a><span id="l10.96" class="difflineplus">+}</span>
<a href="#l10.97"></a><span id="l10.97" class="difflineplus">+</span>
<a href="#l10.98"></a><span id="l10.98" class="difflineplus">+// void preDestroy (in boolean aDestroyingFrames)</span>
<a href="#l10.99"></a><span id="l10.99" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::PreDestroy(PRBool aDestroyingFrames)</span>
<a href="#l10.100"></a><span id="l10.100" class="difflineplus">+{</span>
<a href="#l10.101"></a><span id="l10.101" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.102"></a><span id="l10.102" class="difflineplus">+}</span>
<a href="#l10.103"></a><span id="l10.103" class="difflineplus">+</span>
<a href="#l10.104"></a><span id="l10.104" class="difflineplus">+// attribute unsigned long flags</span>
<a href="#l10.105"></a><span id="l10.105" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetFlags(PRUint32 *aFlags)</span>
<a href="#l10.106"></a><span id="l10.106" class="difflineplus">+{</span>
<a href="#l10.107"></a><span id="l10.107" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.108"></a><span id="l10.108" class="difflineplus">+}</span>
<a href="#l10.109"></a><span id="l10.109" class="difflineplus">+</span>
<a href="#l10.110"></a><span id="l10.110" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::SetFlags(PRUint32 aFlags)</span>
<a href="#l10.111"></a><span id="l10.111" class="difflineplus">+{</span>
<a href="#l10.112"></a><span id="l10.112" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.113"></a><span id="l10.113" class="difflineplus">+}</span>
<a href="#l10.114"></a><span id="l10.114" class="difflineplus">+</span>
<a href="#l10.115"></a><span id="l10.115" class="difflineplus">+// attribute string contentsMIMEType</span>
<a href="#l10.116"></a><span id="l10.116" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetContentsMIMEType(char * *aContentsMIMEType)</span>
<a href="#l10.117"></a><span id="l10.117" class="difflineplus">+{</span>
<a href="#l10.118"></a><span id="l10.118" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.119"></a><span id="l10.119" class="difflineplus">+}</span>
<a href="#l10.120"></a><span id="l10.120" class="difflineplus">+</span>
<a href="#l10.121"></a><span id="l10.121" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::SetContentsMIMEType(const char * aContentsMIMEType)</span>
<a href="#l10.122"></a><span id="l10.122" class="difflineplus">+{</span>
<a href="#l10.123"></a><span id="l10.123" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.124"></a><span id="l10.124" class="difflineplus">+}</span>
<a href="#l10.125"></a><span id="l10.125" class="difflineplus">+</span>
<a href="#l10.126"></a><span id="l10.126" class="difflineplus">+// readonly attribute boolean isDocumentEditable</span>
<a href="#l10.127"></a><span id="l10.127" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetIsDocumentEditable(PRBool *aIsDocumentEditable)</span>
<a href="#l10.128"></a><span id="l10.128" class="difflineplus">+{</span>
<a href="#l10.129"></a><span id="l10.129" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.130"></a><span id="l10.130" class="difflineplus">+}</span>
<a href="#l10.131"></a><span id="l10.131" class="difflineplus">+</span>
<a href="#l10.132"></a><span id="l10.132" class="difflineplus">+// readonly attribute nsIDOMDocument document</span>
<a href="#l10.133"></a><span id="l10.133" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetDocument(nsIDOMDocument * *aDocument)</span>
<a href="#l10.134"></a><span id="l10.134" class="difflineplus">+{</span>
<a href="#l10.135"></a><span id="l10.135" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.136"></a><span id="l10.136" class="difflineplus">+}</span>
<a href="#l10.137"></a><span id="l10.137" class="difflineplus">+</span>
<a href="#l10.138"></a><span id="l10.138" class="difflineplus">+// readonly attribute nsIDOMElement rootElement</span>
<a href="#l10.139"></a><span id="l10.139" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetRootElement(nsIDOMElement * *aRootElement)</span>
<a href="#l10.140"></a><span id="l10.140" class="difflineplus">+{</span>
<a href="#l10.141"></a><span id="l10.141" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.142"></a><span id="l10.142" class="difflineplus">+}</span>
<a href="#l10.143"></a><span id="l10.143" class="difflineplus">+</span>
<a href="#l10.144"></a><span id="l10.144" class="difflineplus">+// readonly attribute nsISelectionController selectionController</span>
<a href="#l10.145"></a><span id="l10.145" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetSelectionController(nsISelectionController * *aSelectionController)</span>
<a href="#l10.146"></a><span id="l10.146" class="difflineplus">+{</span>
<a href="#l10.147"></a><span id="l10.147" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.148"></a><span id="l10.148" class="difflineplus">+}</span>
<a href="#l10.149"></a><span id="l10.149" class="difflineplus">+</span>
<a href="#l10.150"></a><span id="l10.150" class="difflineplus">+// void deleteSelection (in short action)</span>
<a href="#l10.151"></a><span id="l10.151" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::DeleteSelection(PRInt16 action)</span>
<a href="#l10.152"></a><span id="l10.152" class="difflineplus">+{</span>
<a href="#l10.153"></a><span id="l10.153" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.154"></a><span id="l10.154" class="difflineplus">+}</span>
<a href="#l10.155"></a><span id="l10.155" class="difflineplus">+</span>
<a href="#l10.156"></a><span id="l10.156" class="difflineplus">+// readonly attribute boolean documentIsEmpty</span>
<a href="#l10.157"></a><span id="l10.157" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetDocumentIsEmpty(PRBool *aDocumentIsEmpty)</span>
<a href="#l10.158"></a><span id="l10.158" class="difflineplus">+{</span>
<a href="#l10.159"></a><span id="l10.159" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.160"></a><span id="l10.160" class="difflineplus">+}</span>
<a href="#l10.161"></a><span id="l10.161" class="difflineplus">+</span>
<a href="#l10.162"></a><span id="l10.162" class="difflineplus">+// readonly attribute boolean documentModified</span>
<a href="#l10.163"></a><span id="l10.163" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetDocumentModified(PRBool *aDocumentModified)</span>
<a href="#l10.164"></a><span id="l10.164" class="difflineplus">+{</span>
<a href="#l10.165"></a><span id="l10.165" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.166"></a><span id="l10.166" class="difflineplus">+}</span>
<a href="#l10.167"></a><span id="l10.167" class="difflineplus">+</span>
<a href="#l10.168"></a><span id="l10.168" class="difflineplus">+// attribute ACString documentCharacterSet</span>
<a href="#l10.169"></a><span id="l10.169" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetDocumentCharacterSet(nsACString &amp; aDocumentCharacterSet)</span>
<a href="#l10.170"></a><span id="l10.170" class="difflineplus">+{</span>
<a href="#l10.171"></a><span id="l10.171" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.172"></a><span id="l10.172" class="difflineplus">+}</span>
<a href="#l10.173"></a><span id="l10.173" class="difflineplus">+</span>
<a href="#l10.174"></a><span id="l10.174" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::SetDocumentCharacterSet(const nsACString &amp; aDocumentCharacterSet)</span>
<a href="#l10.175"></a><span id="l10.175" class="difflineplus">+{</span>
<a href="#l10.176"></a><span id="l10.176" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.177"></a><span id="l10.177" class="difflineplus">+}</span>
<a href="#l10.178"></a><span id="l10.178" class="difflineplus">+</span>
<a href="#l10.179"></a><span id="l10.179" class="difflineplus">+// void resetModificationCount ()</span>
<a href="#l10.180"></a><span id="l10.180" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::ResetModificationCount()</span>
<a href="#l10.181"></a><span id="l10.181" class="difflineplus">+{</span>
<a href="#l10.182"></a><span id="l10.182" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.183"></a><span id="l10.183" class="difflineplus">+}</span>
<a href="#l10.184"></a><span id="l10.184" class="difflineplus">+</span>
<a href="#l10.185"></a><span id="l10.185" class="difflineplus">+// long getModificationCount ()</span>
<a href="#l10.186"></a><span id="l10.186" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetModificationCount(PRInt32 *_retval)</span>
<a href="#l10.187"></a><span id="l10.187" class="difflineplus">+{</span>
<a href="#l10.188"></a><span id="l10.188" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.189"></a><span id="l10.189" class="difflineplus">+}</span>
<a href="#l10.190"></a><span id="l10.190" class="difflineplus">+</span>
<a href="#l10.191"></a><span id="l10.191" class="difflineplus">+// void incrementModificationCount (in long aModCount)</span>
<a href="#l10.192"></a><span id="l10.192" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::IncrementModificationCount(PRInt32 aModCount)</span>
<a href="#l10.193"></a><span id="l10.193" class="difflineplus">+{</span>
<a href="#l10.194"></a><span id="l10.194" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.195"></a><span id="l10.195" class="difflineplus">+}</span>
<a href="#l10.196"></a><span id="l10.196" class="difflineplus">+</span>
<a href="#l10.197"></a><span id="l10.197" class="difflineplus">+//  attribute nsITransactionManager transactionManager</span>
<a href="#l10.198"></a><span id="l10.198" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetTransactionManager(nsITransactionManager * *aTransactionManager)</span>
<a href="#l10.199"></a><span id="l10.199" class="difflineplus">+{</span>
<a href="#l10.200"></a><span id="l10.200" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.201"></a><span id="l10.201" class="difflineplus">+}</span>
<a href="#l10.202"></a><span id="l10.202" class="difflineplus">+</span>
<a href="#l10.203"></a><span id="l10.203" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::SetTransactionManager(nsITransactionManager *aTxnManager)</span>
<a href="#l10.204"></a><span id="l10.204" class="difflineplus">+{</span>
<a href="#l10.205"></a><span id="l10.205" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.206"></a><span id="l10.206" class="difflineplus">+}</span>
<a href="#l10.207"></a><span id="l10.207" class="difflineplus">+</span>
<a href="#l10.208"></a><span id="l10.208" class="difflineplus">+// void doTransaction (in nsITransaction txn)</span>
<a href="#l10.209"></a><span id="l10.209" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::DoTransaction(nsITransaction *txn)</span>
<a href="#l10.210"></a><span id="l10.210" class="difflineplus">+{</span>
<a href="#l10.211"></a><span id="l10.211" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.212"></a><span id="l10.212" class="difflineplus">+}</span>
<a href="#l10.213"></a><span id="l10.213" class="difflineplus">+</span>
<a href="#l10.214"></a><span id="l10.214" class="difflineplus">+// void enableUndo (in boolean enable)</span>
<a href="#l10.215"></a><span id="l10.215" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::EnableUndo(PRBool enable)</span>
<a href="#l10.216"></a><span id="l10.216" class="difflineplus">+{</span>
<a href="#l10.217"></a><span id="l10.217" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.218"></a><span id="l10.218" class="difflineplus">+}</span>
<a href="#l10.219"></a><span id="l10.219" class="difflineplus">+</span>
<a href="#l10.220"></a><span id="l10.220" class="difflineplus">+// void undo (in unsigned long count)</span>
<a href="#l10.221"></a><span id="l10.221" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::Undo(PRUint32 count)</span>
<a href="#l10.222"></a><span id="l10.222" class="difflineplus">+{</span>
<a href="#l10.223"></a><span id="l10.223" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.224"></a><span id="l10.224" class="difflineplus">+}</span>
<a href="#l10.225"></a><span id="l10.225" class="difflineplus">+</span>
<a href="#l10.226"></a><span id="l10.226" class="difflineplus">+// void canUndo (out boolean isEnabled, out boolean canUndo)</span>
<a href="#l10.227"></a><span id="l10.227" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::CanUndo(PRBool *isEnabled, PRBool *canUndo)</span>
<a href="#l10.228"></a><span id="l10.228" class="difflineplus">+{</span>
<a href="#l10.229"></a><span id="l10.229" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.230"></a><span id="l10.230" class="difflineplus">+}</span>
<a href="#l10.231"></a><span id="l10.231" class="difflineplus">+</span>
<a href="#l10.232"></a><span id="l10.232" class="difflineplus">+// void redo (in unsigned long count)</span>
<a href="#l10.233"></a><span id="l10.233" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::Redo(PRUint32 count)</span>
<a href="#l10.234"></a><span id="l10.234" class="difflineplus">+{</span>
<a href="#l10.235"></a><span id="l10.235" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.236"></a><span id="l10.236" class="difflineplus">+}</span>
<a href="#l10.237"></a><span id="l10.237" class="difflineplus">+</span>
<a href="#l10.238"></a><span id="l10.238" class="difflineplus">+// void canRedo (out boolean isEnabled, out boolean canRedo)</span>
<a href="#l10.239"></a><span id="l10.239" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::CanRedo(PRBool *isEnabled, PRBool *canRedo)</span>
<a href="#l10.240"></a><span id="l10.240" class="difflineplus">+{</span>
<a href="#l10.241"></a><span id="l10.241" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.242"></a><span id="l10.242" class="difflineplus">+}</span>
<a href="#l10.243"></a><span id="l10.243" class="difflineplus">+</span>
<a href="#l10.244"></a><span id="l10.244" class="difflineplus">+// void beginTransaction ()</span>
<a href="#l10.245"></a><span id="l10.245" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::BeginTransaction()</span>
<a href="#l10.246"></a><span id="l10.246" class="difflineplus">+{</span>
<a href="#l10.247"></a><span id="l10.247" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.248"></a><span id="l10.248" class="difflineplus">+}</span>
<a href="#l10.249"></a><span id="l10.249" class="difflineplus">+</span>
<a href="#l10.250"></a><span id="l10.250" class="difflineplus">+// void endTransaction ()</span>
<a href="#l10.251"></a><span id="l10.251" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::EndTransaction()</span>
<a href="#l10.252"></a><span id="l10.252" class="difflineplus">+{</span>
<a href="#l10.253"></a><span id="l10.253" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.254"></a><span id="l10.254" class="difflineplus">+}</span>
<a href="#l10.255"></a><span id="l10.255" class="difflineplus">+</span>
<a href="#l10.256"></a><span id="l10.256" class="difflineplus">+// void beginPlaceHolderTransaction (in nsIAtom name)</span>
<a href="#l10.257"></a><span id="l10.257" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::BeginPlaceHolderTransaction(nsIAtom *name)</span>
<a href="#l10.258"></a><span id="l10.258" class="difflineplus">+{</span>
<a href="#l10.259"></a><span id="l10.259" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.260"></a><span id="l10.260" class="difflineplus">+}</span>
<a href="#l10.261"></a><span id="l10.261" class="difflineplus">+</span>
<a href="#l10.262"></a><span id="l10.262" class="difflineplus">+// void endPlaceHolderTransaction ()</span>
<a href="#l10.263"></a><span id="l10.263" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::EndPlaceHolderTransaction()</span>
<a href="#l10.264"></a><span id="l10.264" class="difflineplus">+{</span>
<a href="#l10.265"></a><span id="l10.265" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.266"></a><span id="l10.266" class="difflineplus">+}</span>
<a href="#l10.267"></a><span id="l10.267" class="difflineplus">+</span>
<a href="#l10.268"></a><span id="l10.268" class="difflineplus">+// boolean shouldTxnSetSelection ()</span>
<a href="#l10.269"></a><span id="l10.269" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::ShouldTxnSetSelection(PRBool *_retval)</span>
<a href="#l10.270"></a><span id="l10.270" class="difflineplus">+{</span>
<a href="#l10.271"></a><span id="l10.271" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.272"></a><span id="l10.272" class="difflineplus">+}</span>
<a href="#l10.273"></a><span id="l10.273" class="difflineplus">+</span>
<a href="#l10.274"></a><span id="l10.274" class="difflineplus">+// void setShouldTxnSetSelection (in boolean should)</span>
<a href="#l10.275"></a><span id="l10.275" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::SetShouldTxnSetSelection(PRBool should)</span>
<a href="#l10.276"></a><span id="l10.276" class="difflineplus">+{</span>
<a href="#l10.277"></a><span id="l10.277" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.278"></a><span id="l10.278" class="difflineplus">+}</span>
<a href="#l10.279"></a><span id="l10.279" class="difflineplus">+</span>
<a href="#l10.280"></a><span id="l10.280" class="difflineplus">+// readonly attribute nsIInlineSpellChecker inlineSpellChecker</span>
<a href="#l10.281"></a><span id="l10.281" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetInlineSpellChecker(PRBool autoCreate, nsIInlineSpellChecker * *aInlineSpellChecker)</span>
<a href="#l10.282"></a><span id="l10.282" class="difflineplus">+{</span>
<a href="#l10.283"></a><span id="l10.283" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.284"></a><span id="l10.284" class="difflineplus">+}</span>
<a href="#l10.285"></a><span id="l10.285" class="difflineplus">+</span>
<a href="#l10.286"></a><span id="l10.286" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::SyncRealTimeSpell()</span>
<a href="#l10.287"></a><span id="l10.287" class="difflineplus">+{</span>
<a href="#l10.288"></a><span id="l10.288" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.289"></a><span id="l10.289" class="difflineplus">+}</span>
<a href="#l10.290"></a><span id="l10.290" class="difflineplus">+</span>
<a href="#l10.291"></a><span id="l10.291" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::SetSpellcheckUserOverride(PRBool enable)</span>
<a href="#l10.292"></a><span id="l10.292" class="difflineplus">+{</span>
<a href="#l10.293"></a><span id="l10.293" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.294"></a><span id="l10.294" class="difflineplus">+}</span>
<a href="#l10.295"></a><span id="l10.295" class="difflineplus">+</span>
<a href="#l10.296"></a><span id="l10.296" class="difflineplus">+PRBool</span>
<a href="#l10.297"></a><span id="l10.297" class="difflineplus">+nsOutlookEditor::IsModifiableNode(nsIDOMNode *aNode)</span>
<a href="#l10.298"></a><span id="l10.298" class="difflineplus">+{</span>
<a href="#l10.299"></a><span id="l10.299" class="difflineplus">+  return PR_TRUE;</span>
<a href="#l10.300"></a><span id="l10.300" class="difflineplus">+}</span>
<a href="#l10.301"></a><span id="l10.301" class="difflineplus">+// void cut ()</span>
<a href="#l10.302"></a><span id="l10.302" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::Cut()</span>
<a href="#l10.303"></a><span id="l10.303" class="difflineplus">+{</span>
<a href="#l10.304"></a><span id="l10.304" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.305"></a><span id="l10.305" class="difflineplus">+}</span>
<a href="#l10.306"></a><span id="l10.306" class="difflineplus">+</span>
<a href="#l10.307"></a><span id="l10.307" class="difflineplus">+// boolean canCut ()</span>
<a href="#l10.308"></a><span id="l10.308" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::CanCut(PRBool *_retval)</span>
<a href="#l10.309"></a><span id="l10.309" class="difflineplus">+{</span>
<a href="#l10.310"></a><span id="l10.310" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.311"></a><span id="l10.311" class="difflineplus">+}</span>
<a href="#l10.312"></a><span id="l10.312" class="difflineplus">+</span>
<a href="#l10.313"></a><span id="l10.313" class="difflineplus">+// void copy ()</span>
<a href="#l10.314"></a><span id="l10.314" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::Copy()</span>
<a href="#l10.315"></a><span id="l10.315" class="difflineplus">+{</span>
<a href="#l10.316"></a><span id="l10.316" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.317"></a><span id="l10.317" class="difflineplus">+}</span>
<a href="#l10.318"></a><span id="l10.318" class="difflineplus">+</span>
<a href="#l10.319"></a><span id="l10.319" class="difflineplus">+// boolean canCopy ()</span>
<a href="#l10.320"></a><span id="l10.320" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::CanCopy(PRBool *_retval)</span>
<a href="#l10.321"></a><span id="l10.321" class="difflineplus">+{</span>
<a href="#l10.322"></a><span id="l10.322" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.323"></a><span id="l10.323" class="difflineplus">+}</span>
<a href="#l10.324"></a><span id="l10.324" class="difflineplus">+</span>
<a href="#l10.325"></a><span id="l10.325" class="difflineplus">+// void paste (in long aSelectionType)</span>
<a href="#l10.326"></a><span id="l10.326" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::Paste(PRInt32 aSelectionType)</span>
<a href="#l10.327"></a><span id="l10.327" class="difflineplus">+{</span>
<a href="#l10.328"></a><span id="l10.328" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.329"></a><span id="l10.329" class="difflineplus">+}</span>
<a href="#l10.330"></a><span id="l10.330" class="difflineplus">+</span>
<a href="#l10.331"></a><span id="l10.331" class="difflineplus">+// boolean canPaste (in long aSelectionType)</span>
<a href="#l10.332"></a><span id="l10.332" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::CanPaste(PRInt32 aSelectionType, PRBool *_retval)</span>
<a href="#l10.333"></a><span id="l10.333" class="difflineplus">+{</span>
<a href="#l10.334"></a><span id="l10.334" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.335"></a><span id="l10.335" class="difflineplus">+}</span>
<a href="#l10.336"></a><span id="l10.336" class="difflineplus">+</span>
<a href="#l10.337"></a><span id="l10.337" class="difflineplus">+class nsITransferable;</span>
<a href="#l10.338"></a><span id="l10.338" class="difflineplus">+</span>
<a href="#l10.339"></a><span id="l10.339" class="difflineplus">+// void pasteTransferable(in nsITransferable aTransferable)</span>
<a href="#l10.340"></a><span id="l10.340" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::PasteTransferable(nsITransferable *aTransferable)</span>
<a href="#l10.341"></a><span id="l10.341" class="difflineplus">+{</span>
<a href="#l10.342"></a><span id="l10.342" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.343"></a><span id="l10.343" class="difflineplus">+}</span>
<a href="#l10.344"></a><span id="l10.344" class="difflineplus">+</span>
<a href="#l10.345"></a><span id="l10.345" class="difflineplus">+// boolean canPasteTransferable([optional] in nsITransferable aTransferable)</span>
<a href="#l10.346"></a><span id="l10.346" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::CanPasteTransferable(nsITransferable *aTransferable, PRBool *aCanPaste)</span>
<a href="#l10.347"></a><span id="l10.347" class="difflineplus">+{</span>
<a href="#l10.348"></a><span id="l10.348" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.349"></a><span id="l10.349" class="difflineplus">+}</span>
<a href="#l10.350"></a><span id="l10.350" class="difflineplus">+</span>
<a href="#l10.351"></a><span id="l10.351" class="difflineplus">+// void selectAll ()</span>
<a href="#l10.352"></a><span id="l10.352" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::SelectAll()</span>
<a href="#l10.353"></a><span id="l10.353" class="difflineplus">+{</span>
<a href="#l10.354"></a><span id="l10.354" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.355"></a><span id="l10.355" class="difflineplus">+}</span>
<a href="#l10.356"></a><span id="l10.356" class="difflineplus">+</span>
<a href="#l10.357"></a><span id="l10.357" class="difflineplus">+// void beginningOfDocument ()</span>
<a href="#l10.358"></a><span id="l10.358" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::BeginningOfDocument()</span>
<a href="#l10.359"></a><span id="l10.359" class="difflineplus">+{</span>
<a href="#l10.360"></a><span id="l10.360" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.361"></a><span id="l10.361" class="difflineplus">+}</span>
<a href="#l10.362"></a><span id="l10.362" class="difflineplus">+</span>
<a href="#l10.363"></a><span id="l10.363" class="difflineplus">+// void endOfDocument ()</span>
<a href="#l10.364"></a><span id="l10.364" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::EndOfDocument()</span>
<a href="#l10.365"></a><span id="l10.365" class="difflineplus">+{</span>
<a href="#l10.366"></a><span id="l10.366" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.367"></a><span id="l10.367" class="difflineplus">+}</span>
<a href="#l10.368"></a><span id="l10.368" class="difflineplus">+</span>
<a href="#l10.369"></a><span id="l10.369" class="difflineplus">+// boolean canDrag (in nsIDOMEvent aEvent)</span>
<a href="#l10.370"></a><span id="l10.370" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::CanDrag(nsIDOMEvent *aEvent, PRBool *_retval)</span>
<a href="#l10.371"></a><span id="l10.371" class="difflineplus">+{</span>
<a href="#l10.372"></a><span id="l10.372" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.373"></a><span id="l10.373" class="difflineplus">+}</span>
<a href="#l10.374"></a><span id="l10.374" class="difflineplus">+</span>
<a href="#l10.375"></a><span id="l10.375" class="difflineplus">+// void doDrag (in nsIDOMEvent aEvent)</span>
<a href="#l10.376"></a><span id="l10.376" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::DoDrag(nsIDOMEvent *aEvent)</span>
<a href="#l10.377"></a><span id="l10.377" class="difflineplus">+{</span>
<a href="#l10.378"></a><span id="l10.378" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.379"></a><span id="l10.379" class="difflineplus">+}</span>
<a href="#l10.380"></a><span id="l10.380" class="difflineplus">+</span>
<a href="#l10.381"></a><span id="l10.381" class="difflineplus">+// void insertFromDrop (in nsIDOMEvent aEvent)</span>
<a href="#l10.382"></a><span id="l10.382" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::InsertFromDrop(nsIDOMEvent *aEvent)</span>
<a href="#l10.383"></a><span id="l10.383" class="difflineplus">+{</span>
<a href="#l10.384"></a><span id="l10.384" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.385"></a><span id="l10.385" class="difflineplus">+}</span>
<a href="#l10.386"></a><span id="l10.386" class="difflineplus">+</span>
<a href="#l10.387"></a><span id="l10.387" class="difflineplus">+// void setAttribute (in nsIDOMElement aElement, in AString attributestr, in AString attvalue)</span>
<a href="#l10.388"></a><span id="l10.388" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::SetAttribute(nsIDOMElement *aElement, const nsAString &amp; attributestr, const nsAString &amp; attvalue)</span>
<a href="#l10.389"></a><span id="l10.389" class="difflineplus">+{</span>
<a href="#l10.390"></a><span id="l10.390" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.391"></a><span id="l10.391" class="difflineplus">+}</span>
<a href="#l10.392"></a><span id="l10.392" class="difflineplus">+</span>
<a href="#l10.393"></a><span id="l10.393" class="difflineplus">+/* boolean getAttributeValue (in nsIDOMElement aElement, in AString attributestr, out AString resultValue); */</span>
<a href="#l10.394"></a><span id="l10.394" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetAttributeValue(nsIDOMElement *aElement, const nsAString &amp; attributestr, nsAString &amp; resultValue, PRBool *_retval)</span>
<a href="#l10.395"></a><span id="l10.395" class="difflineplus">+{</span>
<a href="#l10.396"></a><span id="l10.396" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.397"></a><span id="l10.397" class="difflineplus">+}</span>
<a href="#l10.398"></a><span id="l10.398" class="difflineplus">+</span>
<a href="#l10.399"></a><span id="l10.399" class="difflineplus">+/* void removeAttribute (in nsIDOMElement aElement, in AString aAttribute); */</span>
<a href="#l10.400"></a><span id="l10.400" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::RemoveAttribute(nsIDOMElement *aElement, const nsAString &amp; aAttribute)</span>
<a href="#l10.401"></a><span id="l10.401" class="difflineplus">+{</span>
<a href="#l10.402"></a><span id="l10.402" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.403"></a><span id="l10.403" class="difflineplus">+}</span>
<a href="#l10.404"></a><span id="l10.404" class="difflineplus">+</span>
<a href="#l10.405"></a><span id="l10.405" class="difflineplus">+/* void cloneAttribute (in AString aAttribute, in nsIDOMNode aDestNode, in nsIDOMNode aSourceNode); */</span>
<a href="#l10.406"></a><span id="l10.406" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::CloneAttribute(const nsAString &amp; aAttribute, nsIDOMNode *aDestNode, nsIDOMNode *aSourceNode)</span>
<a href="#l10.407"></a><span id="l10.407" class="difflineplus">+{</span>
<a href="#l10.408"></a><span id="l10.408" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.409"></a><span id="l10.409" class="difflineplus">+}</span>
<a href="#l10.410"></a><span id="l10.410" class="difflineplus">+</span>
<a href="#l10.411"></a><span id="l10.411" class="difflineplus">+/* void cloneAttributes (in nsIDOMNode destNode, in nsIDOMNode sourceNode); */</span>
<a href="#l10.412"></a><span id="l10.412" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::CloneAttributes(nsIDOMNode *destNode, nsIDOMNode *sourceNode)</span>
<a href="#l10.413"></a><span id="l10.413" class="difflineplus">+{</span>
<a href="#l10.414"></a><span id="l10.414" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.415"></a><span id="l10.415" class="difflineplus">+}</span>
<a href="#l10.416"></a><span id="l10.416" class="difflineplus">+</span>
<a href="#l10.417"></a><span id="l10.417" class="difflineplus">+/* nsIDOMNode createNode (in AString tag, in nsIDOMNode parent, in long position); */</span>
<a href="#l10.418"></a><span id="l10.418" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::CreateNode(const nsAString &amp; tag, nsIDOMNode *parent, PRInt32 position, nsIDOMNode **_retval)</span>
<a href="#l10.419"></a><span id="l10.419" class="difflineplus">+{</span>
<a href="#l10.420"></a><span id="l10.420" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.421"></a><span id="l10.421" class="difflineplus">+}</span>
<a href="#l10.422"></a><span id="l10.422" class="difflineplus">+</span>
<a href="#l10.423"></a><span id="l10.423" class="difflineplus">+// void insertNode (in nsIDOMNode node, in nsIDOMNode parent, in long aPosition)</span>
<a href="#l10.424"></a><span id="l10.424" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::InsertNode(nsIDOMNode *node, nsIDOMNode *parent, PRInt32 aPosition)</span>
<a href="#l10.425"></a><span id="l10.425" class="difflineplus">+{</span>
<a href="#l10.426"></a><span id="l10.426" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.427"></a><span id="l10.427" class="difflineplus">+}</span>
<a href="#l10.428"></a><span id="l10.428" class="difflineplus">+</span>
<a href="#l10.429"></a><span id="l10.429" class="difflineplus">+// void splitNode (in nsIDOMNode existingRightNode, in long offset, out nsIDOMNode newLeftNode)</span>
<a href="#l10.430"></a><span id="l10.430" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::SplitNode(nsIDOMNode *existingRightNode, PRInt32 offset, nsIDOMNode **newLeftNode)</span>
<a href="#l10.431"></a><span id="l10.431" class="difflineplus">+{</span>
<a href="#l10.432"></a><span id="l10.432" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.433"></a><span id="l10.433" class="difflineplus">+}</span>
<a href="#l10.434"></a><span id="l10.434" class="difflineplus">+</span>
<a href="#l10.435"></a><span id="l10.435" class="difflineplus">+// void joinNodes (in nsIDOMNode leftNode, in nsIDOMNode rightNode, in nsIDOMNode parent)</span>
<a href="#l10.436"></a><span id="l10.436" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::JoinNodes(nsIDOMNode *leftNode, nsIDOMNode *rightNode, nsIDOMNode *parent)</span>
<a href="#l10.437"></a><span id="l10.437" class="difflineplus">+{</span>
<a href="#l10.438"></a><span id="l10.438" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.439"></a><span id="l10.439" class="difflineplus">+}</span>
<a href="#l10.440"></a><span id="l10.440" class="difflineplus">+</span>
<a href="#l10.441"></a><span id="l10.441" class="difflineplus">+// void deleteNode (in nsIDOMNode child)</span>
<a href="#l10.442"></a><span id="l10.442" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::DeleteNode(nsIDOMNode *child)</span>
<a href="#l10.443"></a><span id="l10.443" class="difflineplus">+{</span>
<a href="#l10.444"></a><span id="l10.444" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.445"></a><span id="l10.445" class="difflineplus">+}</span>
<a href="#l10.446"></a><span id="l10.446" class="difflineplus">+</span>
<a href="#l10.447"></a><span id="l10.447" class="difflineplus">+// void markNodeDirty (in nsIDOMNode node)</span>
<a href="#l10.448"></a><span id="l10.448" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::MarkNodeDirty(nsIDOMNode *node)</span>
<a href="#l10.449"></a><span id="l10.449" class="difflineplus">+{</span>
<a href="#l10.450"></a><span id="l10.450" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.451"></a><span id="l10.451" class="difflineplus">+}</span>
<a href="#l10.452"></a><span id="l10.452" class="difflineplus">+</span>
<a href="#l10.453"></a><span id="l10.453" class="difflineplus">+// void switchTextDirection ()</span>
<a href="#l10.454"></a><span id="l10.454" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::SwitchTextDirection()</span>
<a href="#l10.455"></a><span id="l10.455" class="difflineplus">+{</span>
<a href="#l10.456"></a><span id="l10.456" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.457"></a><span id="l10.457" class="difflineplus">+}</span>
<a href="#l10.458"></a><span id="l10.458" class="difflineplus">+</span>
<a href="#l10.459"></a><span id="l10.459" class="difflineplus">+// AString outputToString (in AString formatType, in unsigned long flags)</span>
<a href="#l10.460"></a><span id="l10.460" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l10.461"></a><span id="l10.461" class="difflineplus">+nsOutlookEditor::OutputToString(const nsAString &amp; formatType,</span>
<a href="#l10.462"></a><span id="l10.462" class="difflineplus">+                                PRUint32 flags, nsAString &amp; _retval)</span>
<a href="#l10.463"></a><span id="l10.463" class="difflineplus">+{</span>
<a href="#l10.464"></a><span id="l10.464" class="difflineplus">+  _retval.Assign(m_body);</span>
<a href="#l10.465"></a><span id="l10.465" class="difflineplus">+  return NS_OK;</span>
<a href="#l10.466"></a><span id="l10.466" class="difflineplus">+}</span>
<a href="#l10.467"></a><span id="l10.467" class="difflineplus">+</span>
<a href="#l10.468"></a><span id="l10.468" class="difflineplus">+// void outputToStream (in nsIOutputStream aStream, in AString formatType, in ACString charsetOverride, in unsigned long flags)</span>
<a href="#l10.469"></a><span id="l10.469" class="difflineplus">+</span>
<a href="#l10.470"></a><span id="l10.470" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::OutputToStream(nsIOutputStream *aStream,</span>
<a href="#l10.471"></a><span id="l10.471" class="difflineplus">+                                              const nsAString &amp;formatType,</span>
<a href="#l10.472"></a><span id="l10.472" class="difflineplus">+                                              const nsACString &amp;charsetOverride,</span>
<a href="#l10.473"></a><span id="l10.473" class="difflineplus">+                                              PRUint32 flags)</span>
<a href="#l10.474"></a><span id="l10.474" class="difflineplus">+{</span>
<a href="#l10.475"></a><span id="l10.475" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.476"></a><span id="l10.476" class="difflineplus">+}</span>
<a href="#l10.477"></a><span id="l10.477" class="difflineplus">+</span>
<a href="#l10.478"></a><span id="l10.478" class="difflineplus">+// void addEditorObserver (in nsIEditorObserver observer)</span>
<a href="#l10.479"></a><span id="l10.479" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::AddEditorObserver(nsIEditorObserver *observer)</span>
<a href="#l10.480"></a><span id="l10.480" class="difflineplus">+{</span>
<a href="#l10.481"></a><span id="l10.481" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.482"></a><span id="l10.482" class="difflineplus">+}</span>
<a href="#l10.483"></a><span id="l10.483" class="difflineplus">+</span>
<a href="#l10.484"></a><span id="l10.484" class="difflineplus">+// void removeEditorObserver (in nsIEditorObserver observer)</span>
<a href="#l10.485"></a><span id="l10.485" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::RemoveEditorObserver(nsIEditorObserver *observer)</span>
<a href="#l10.486"></a><span id="l10.486" class="difflineplus">+{</span>
<a href="#l10.487"></a><span id="l10.487" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.488"></a><span id="l10.488" class="difflineplus">+}</span>
<a href="#l10.489"></a><span id="l10.489" class="difflineplus">+</span>
<a href="#l10.490"></a><span id="l10.490" class="difflineplus">+// void addEditActionListener (in nsIEditActionListener listener)</span>
<a href="#l10.491"></a><span id="l10.491" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::AddEditActionListener(nsIEditActionListener *listener)</span>
<a href="#l10.492"></a><span id="l10.492" class="difflineplus">+{</span>
<a href="#l10.493"></a><span id="l10.493" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.494"></a><span id="l10.494" class="difflineplus">+}</span>
<a href="#l10.495"></a><span id="l10.495" class="difflineplus">+</span>
<a href="#l10.496"></a><span id="l10.496" class="difflineplus">+// void removeEditActionListener (in nsIEditActionListener listener)</span>
<a href="#l10.497"></a><span id="l10.497" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::RemoveEditActionListener(nsIEditActionListener *listener)</span>
<a href="#l10.498"></a><span id="l10.498" class="difflineplus">+{</span>
<a href="#l10.499"></a><span id="l10.499" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.500"></a><span id="l10.500" class="difflineplus">+}</span>
<a href="#l10.501"></a><span id="l10.501" class="difflineplus">+</span>
<a href="#l10.502"></a><span id="l10.502" class="difflineplus">+// void addDocumentStateListener (in nsIDocumentStateListener listener)</span>
<a href="#l10.503"></a><span id="l10.503" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l10.504"></a><span id="l10.504" class="difflineplus">+nsOutlookEditor::AddDocumentStateListener(nsIDocumentStateListener *listener)</span>
<a href="#l10.505"></a><span id="l10.505" class="difflineplus">+{</span>
<a href="#l10.506"></a><span id="l10.506" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.507"></a><span id="l10.507" class="difflineplus">+}</span>
<a href="#l10.508"></a><span id="l10.508" class="difflineplus">+</span>
<a href="#l10.509"></a><span id="l10.509" class="difflineplus">+// void removeDocumentStateListener (in nsIDocumentStateListener listener)</span>
<a href="#l10.510"></a><span id="l10.510" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l10.511"></a><span id="l10.511" class="difflineplus">+nsOutlookEditor::RemoveDocumentStateListener(nsIDocumentStateListener *listener)</span>
<a href="#l10.512"></a><span id="l10.512" class="difflineplus">+{</span>
<a href="#l10.513"></a><span id="l10.513" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.514"></a><span id="l10.514" class="difflineplus">+}</span>
<a href="#l10.515"></a><span id="l10.515" class="difflineplus">+</span>
<a href="#l10.516"></a><span id="l10.516" class="difflineplus">+// void dumpContentTree ()</span>
<a href="#l10.517"></a><span id="l10.517" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::DumpContentTree()</span>
<a href="#l10.518"></a><span id="l10.518" class="difflineplus">+{</span>
<a href="#l10.519"></a><span id="l10.519" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.520"></a><span id="l10.520" class="difflineplus">+}</span>
<a href="#l10.521"></a><span id="l10.521" class="difflineplus">+</span>
<a href="#l10.522"></a><span id="l10.522" class="difflineplus">+// void debugDumpContent ()</span>
<a href="#l10.523"></a><span id="l10.523" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::DebugDumpContent()</span>
<a href="#l10.524"></a><span id="l10.524" class="difflineplus">+{</span>
<a href="#l10.525"></a><span id="l10.525" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.526"></a><span id="l10.526" class="difflineplus">+}</span>
<a href="#l10.527"></a><span id="l10.527" class="difflineplus">+</span>
<a href="#l10.528"></a><span id="l10.528" class="difflineplus">+// void debugUnitTests (out long outNumTests, out long outNumTestsFailed)</span>
<a href="#l10.529"></a><span id="l10.529" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::DebugUnitTests(PRInt32 *outNumTests,</span>
<a href="#l10.530"></a><span id="l10.530" class="difflineplus">+                                              PRInt32 *outNumTestsFailed)</span>
<a href="#l10.531"></a><span id="l10.531" class="difflineplus">+{</span>
<a href="#l10.532"></a><span id="l10.532" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.533"></a><span id="l10.533" class="difflineplus">+}</span>
<a href="#l10.534"></a><span id="l10.534" class="difflineplus">+</span>
<a href="#l10.535"></a><span id="l10.535" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetLastKeypressEventTrusted(PRBool *aResult)</span>
<a href="#l10.536"></a><span id="l10.536" class="difflineplus">+{</span>
<a href="#l10.537"></a><span id="l10.537" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.538"></a><span id="l10.538" class="difflineplus">+}</span>
<a href="#l10.539"></a><span id="l10.539" class="difflineplus">+</span>
<a href="#l10.540"></a><span id="l10.540" class="difflineplus">+// void pasteAsQuotation (in long aSelectionType)</span>
<a href="#l10.541"></a><span id="l10.541" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::PasteAsQuotation(PRInt32 aSelectionType)</span>
<a href="#l10.542"></a><span id="l10.542" class="difflineplus">+{</span>
<a href="#l10.543"></a><span id="l10.543" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.544"></a><span id="l10.544" class="difflineplus">+}</span>
<a href="#l10.545"></a><span id="l10.545" class="difflineplus">+</span>
<a href="#l10.546"></a><span id="l10.546" class="difflineplus">+// nsIDOMNode insertAsQuotation (in AString aQuotedText)</span>
<a href="#l10.547"></a><span id="l10.547" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::InsertAsQuotation(const nsAString &amp;aQuotedText,</span>
<a href="#l10.548"></a><span id="l10.548" class="difflineplus">+                                                 nsIDOMNode **_retval)</span>
<a href="#l10.549"></a><span id="l10.549" class="difflineplus">+{</span>
<a href="#l10.550"></a><span id="l10.550" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.551"></a><span id="l10.551" class="difflineplus">+}</span>
<a href="#l10.552"></a><span id="l10.552" class="difflineplus">+</span>
<a href="#l10.553"></a><span id="l10.553" class="difflineplus">+// void insertTextWithQuotations (in DOMString aStringToInsert)</span>
<a href="#l10.554"></a><span id="l10.554" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l10.555"></a><span id="l10.555" class="difflineplus">+nsOutlookEditor::InsertTextWithQuotations(const nsAString &amp; aStringToInsert)</span>
<a href="#l10.556"></a><span id="l10.556" class="difflineplus">+{</span>
<a href="#l10.557"></a><span id="l10.557" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.558"></a><span id="l10.558" class="difflineplus">+}</span>
<a href="#l10.559"></a><span id="l10.559" class="difflineplus">+</span>
<a href="#l10.560"></a><span id="l10.560" class="difflineplus">+// void pasteAsCitedQuotation (in AString aCitation, in long aSelectionType)</span>
<a href="#l10.561"></a><span id="l10.561" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l10.562"></a><span id="l10.562" class="difflineplus">+nsOutlookEditor::PasteAsCitedQuotation(const nsAString &amp; aCitation,</span>
<a href="#l10.563"></a><span id="l10.563" class="difflineplus">+                                       PRInt32 aSelectionType)</span>
<a href="#l10.564"></a><span id="l10.564" class="difflineplus">+{</span>
<a href="#l10.565"></a><span id="l10.565" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.566"></a><span id="l10.566" class="difflineplus">+}</span>
<a href="#l10.567"></a><span id="l10.567" class="difflineplus">+</span>
<a href="#l10.568"></a><span id="l10.568" class="difflineplus">+// nsIDOMNode insertAsCitedQuotation (in AString aQuotedText, in AString aCitation, in boolean aInsertHTML)</span>
<a href="#l10.569"></a><span id="l10.569" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l10.570"></a><span id="l10.570" class="difflineplus">+nsOutlookEditor::InsertAsCitedQuotation(const nsAString &amp;aQuotedText,</span>
<a href="#l10.571"></a><span id="l10.571" class="difflineplus">+                                        const nsAString &amp; aCitation,</span>
<a href="#l10.572"></a><span id="l10.572" class="difflineplus">+                                        PRBool aInsertHTML,</span>
<a href="#l10.573"></a><span id="l10.573" class="difflineplus">+                                        nsIDOMNode **_retval)</span>
<a href="#l10.574"></a><span id="l10.574" class="difflineplus">+{</span>
<a href="#l10.575"></a><span id="l10.575" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.576"></a><span id="l10.576" class="difflineplus">+}</span>
<a href="#l10.577"></a><span id="l10.577" class="difflineplus">+</span>
<a href="#l10.578"></a><span id="l10.578" class="difflineplus">+// void rewrap (in boolean aRespectNewlines)</span>
<a href="#l10.579"></a><span id="l10.579" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::Rewrap(PRBool aRespectNewlines)</span>
<a href="#l10.580"></a><span id="l10.580" class="difflineplus">+{</span>
<a href="#l10.581"></a><span id="l10.581" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.582"></a><span id="l10.582" class="difflineplus">+}</span>
<a href="#l10.583"></a><span id="l10.583" class="difflineplus">+</span>
<a href="#l10.584"></a><span id="l10.584" class="difflineplus">+// void stripCites ()</span>
<a href="#l10.585"></a><span id="l10.585" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::StripCites()</span>
<a href="#l10.586"></a><span id="l10.586" class="difflineplus">+{</span>
<a href="#l10.587"></a><span id="l10.587" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.588"></a><span id="l10.588" class="difflineplus">+}</span>
<a href="#l10.589"></a><span id="l10.589" class="difflineplus">+</span>
<a href="#l10.590"></a><span id="l10.590" class="difflineplus">+// nsISupportsArray getEmbeddedObjects ()</span>
<a href="#l10.591"></a><span id="l10.591" class="difflineplus">+NS_IMETHODIMP nsOutlookEditor::GetEmbeddedObjects(nsISupportsArray ** aNodeList)</span>
<a href="#l10.592"></a><span id="l10.592" class="difflineplus">+{</span>
<a href="#l10.593"></a><span id="l10.593" class="difflineplus">+  NS_ENSURE_ARG_POINTER(aNodeList);</span>
<a href="#l10.594"></a><span id="l10.594" class="difflineplus">+</span>
<a href="#l10.595"></a><span id="l10.595" class="difflineplus">+  NS_IF_ADDREF(*aNodeList = m_EmbeddedObjectList);</span>
<a href="#l10.596"></a><span id="l10.596" class="difflineplus">+  return (m_EmbeddedObjectList == nsnull) ? NS_ERROR_NULL_POINTER : NS_OK;</span>
<a href="#l10.597"></a><span id="l10.597" class="difflineplus">+}</span>
<a href="#l10.598"></a><span id="l10.598" class="difflineplus">+</span>
<a href="#l10.599"></a><span id="l10.599" class="difflineplus">+nsresult nsOutlookEditor::AddEmbeddedImage(nsIURI *uri, const wchar_t* cid,</span>
<a href="#l10.600"></a><span id="l10.600" class="difflineplus">+                                           const wchar_t *name)</span>
<a href="#l10.601"></a><span id="l10.601" class="difflineplus">+{</span>
<a href="#l10.602"></a><span id="l10.602" class="difflineplus">+  // Check to see if we were already called</span>
<a href="#l10.603"></a><span id="l10.603" class="difflineplus">+  if (!m_EmbeddedObjectList) {</span>
<a href="#l10.604"></a><span id="l10.604" class="difflineplus">+    // Create array in m_EmbeddedObjectList</span>
<a href="#l10.605"></a><span id="l10.605" class="difflineplus">+    nsresult rv = NS_NewISupportsArray(getter_AddRefs(m_EmbeddedObjectList) );</span>
<a href="#l10.606"></a><span id="l10.606" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l10.607"></a><span id="l10.607" class="difflineplus">+  }</span>
<a href="#l10.608"></a><span id="l10.608" class="difflineplus">+</span>
<a href="#l10.609"></a><span id="l10.609" class="difflineplus">+  // Create the embedded image node</span>
<a href="#l10.610"></a><span id="l10.610" class="difflineplus">+  nsCOMPtr&lt;nsIDOMHTMLImageElement&gt; imageNode =</span>
<a href="#l10.611"></a><span id="l10.611" class="difflineplus">+    new nsOutlookHTMLImageElement(this, uri, cid, name);</span>
<a href="#l10.612"></a><span id="l10.612" class="difflineplus">+</span>
<a href="#l10.613"></a><span id="l10.613" class="difflineplus">+  // Append the embedded image node to the list</span>
<a href="#l10.614"></a><span id="l10.614" class="difflineplus">+  m_EmbeddedObjectList-&gt;AppendElement(imageNode);</span>
<a href="#l10.615"></a><span id="l10.615" class="difflineplus">+</span>
<a href="#l10.616"></a><span id="l10.616" class="difflineplus">+  return NS_OK;</span>
<a href="#l10.617"></a><span id="l10.617" class="difflineplus">+}</span>
<a href="#l10.618"></a><span id="l10.618" class="difflineplus">+</span>
<a href="#l10.619"></a><span id="l10.619" class="difflineplus">+PRUint32 nsOutlookEditor::EmbeddedObjectsCount() const</span>
<a href="#l10.620"></a><span id="l10.620" class="difflineplus">+{</span>
<a href="#l10.621"></a><span id="l10.621" class="difflineplus">+  if (!m_EmbeddedObjectList)</span>
<a href="#l10.622"></a><span id="l10.622" class="difflineplus">+    return 0;</span>
<a href="#l10.623"></a><span id="l10.623" class="difflineplus">+  PRUint32 res;</span>
<a href="#l10.624"></a><span id="l10.624" class="difflineplus">+  nsresult rv = m_EmbeddedObjectList-&gt;Count(&amp;res);</span>
<a href="#l10.625"></a><span id="l10.625" class="difflineplus">+  return (NS_FAILED(rv)) ? 0 : res;</span>
<a href="#l10.626"></a><span id="l10.626" class="difflineplus">+}</span>
<a href="#l10.627"></a><span id="l10.627" class="difflineplus">+</span>
<a href="#l10.628"></a><span id="l10.628" class="difflineplus">+nsresult nsOutlookEditor::GetCids(PRUint32 embedIndex, nsACString&amp; origCid,</span>
<a href="#l10.629"></a><span id="l10.629" class="difflineplus">+                                  nsACString&amp; newCid) const</span>
<a href="#l10.630"></a><span id="l10.630" class="difflineplus">+{</span>
<a href="#l10.631"></a><span id="l10.631" class="difflineplus">+  if (!m_EmbeddedObjectList)</span>
<a href="#l10.632"></a><span id="l10.632" class="difflineplus">+    return NS_ERROR_FAILURE;</span>
<a href="#l10.633"></a><span id="l10.633" class="difflineplus">+  nsCOMPtr&lt;nsOutlookHTMLImageElement&gt; node;</span>
<a href="#l10.634"></a><span id="l10.634" class="difflineplus">+  nsresult rv = m_EmbeddedObjectList-&gt;QueryElementAt(</span>
<a href="#l10.635"></a><span id="l10.635" class="difflineplus">+    embedIndex, NS_GET_IID(nsOutlookHTMLImageElement), getter_AddRefs(node));</span>
<a href="#l10.636"></a><span id="l10.636" class="difflineplus">+  if (node) {</span>
<a href="#l10.637"></a><span id="l10.637" class="difflineplus">+    if (!node-&gt;NewCid())</span>
<a href="#l10.638"></a><span id="l10.638" class="difflineplus">+      return NS_ERROR_FAILURE; // no need to replace anything!</span>
<a href="#l10.639"></a><span id="l10.639" class="difflineplus">+    LossyCopyUTF16toASCII(node-&gt;OrigCid(), origCid);</span>
<a href="#l10.640"></a><span id="l10.640" class="difflineplus">+    LossyCopyUTF16toASCII(node-&gt;NewCid(), newCid);</span>
<a href="#l10.641"></a><span id="l10.641" class="difflineplus">+  }</span>
<a href="#l10.642"></a><span id="l10.642" class="difflineplus">+  return rv;</span>
<a href="#l10.643"></a><span id="l10.643" class="difflineplus">+}</span>
<a href="#l10.644"></a><span id="l10.644" class="difflineplus">+</span>
<a href="#l10.645"></a><span id="l10.645" class="difflineplus">+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l10.646"></a><span id="l10.646" class="difflineplus">+</span>
<a href="#l10.647"></a><span id="l10.647" class="difflineplus">+nsOutlookHTMLImageElement::nsOutlookHTMLImageElement</span>
<a href="#l10.648"></a><span id="l10.648" class="difflineplus">+  (nsOutlookEditor *pEditor, nsIURI *uri, const wchar_t *cid, const wchar_t *name)</span>
<a href="#l10.649"></a><span id="l10.649" class="difflineplus">+  : m_pEditor(pEditor), m_name(name), m_cid_orig(cid)</span>
<a href="#l10.650"></a><span id="l10.650" class="difflineplus">+{</span>
<a href="#l10.651"></a><span id="l10.651" class="difflineplus">+  // Get the URL for the embedded image</span>
<a href="#l10.652"></a><span id="l10.652" class="difflineplus">+  nsCString embeddedImageURL;</span>
<a href="#l10.653"></a><span id="l10.653" class="difflineplus">+  uri-&gt;GetSpec(embeddedImageURL);</span>
<a href="#l10.654"></a><span id="l10.654" class="difflineplus">+  CopyASCIItoUTF16(embeddedImageURL, m_src);</span>
<a href="#l10.655"></a><span id="l10.655" class="difflineplus">+</span>
<a href="#l10.656"></a><span id="l10.656" class="difflineplus">+  // The cid that is passed here is not prepended with &quot;cid:&quot;, so if it</span>
<a href="#l10.657"></a><span id="l10.657" class="difflineplus">+  // becomes important that it is, we'd need to prepend it here.</span>
<a href="#l10.658"></a><span id="l10.658" class="difflineplus">+}</span>
<a href="#l10.659"></a><span id="l10.659" class="difflineplus">+</span>
<a href="#l10.660"></a><span id="l10.660" class="difflineplus">+nsOutlookHTMLImageElement::~nsOutlookHTMLImageElement()</span>
<a href="#l10.661"></a><span id="l10.661" class="difflineplus">+{</span>
<a href="#l10.662"></a><span id="l10.662" class="difflineplus">+}</span>
<a href="#l10.663"></a><span id="l10.663" class="difflineplus">+</span>
<a href="#l10.664"></a><span id="l10.664" class="difflineplus">+// readonly attribute DOMString nodeName</span>
<a href="#l10.665"></a><span id="l10.665" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetNodeName(nsAString &amp; aNodeName)</span>
<a href="#l10.666"></a><span id="l10.666" class="difflineplus">+{</span>
<a href="#l10.667"></a><span id="l10.667" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.668"></a><span id="l10.668" class="difflineplus">+}</span>
<a href="#l10.669"></a><span id="l10.669" class="difflineplus">+</span>
<a href="#l10.670"></a><span id="l10.670" class="difflineplus">+// attribute DOMString nodeValue</span>
<a href="#l10.671"></a><span id="l10.671" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetNodeValue(nsAString &amp; aNodeValue)</span>
<a href="#l10.672"></a><span id="l10.672" class="difflineplus">+{</span>
<a href="#l10.673"></a><span id="l10.673" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.674"></a><span id="l10.674" class="difflineplus">+}</span>
<a href="#l10.675"></a><span id="l10.675" class="difflineplus">+</span>
<a href="#l10.676"></a><span id="l10.676" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetNodeValue(const nsAString &amp; aNodeValue)</span>
<a href="#l10.677"></a><span id="l10.677" class="difflineplus">+{</span>
<a href="#l10.678"></a><span id="l10.678" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.679"></a><span id="l10.679" class="difflineplus">+}</span>
<a href="#l10.680"></a><span id="l10.680" class="difflineplus">+</span>
<a href="#l10.681"></a><span id="l10.681" class="difflineplus">+// readonly attribute unsigned short nodeType</span>
<a href="#l10.682"></a><span id="l10.682" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetNodeType(PRUint16 *aNodeType)</span>
<a href="#l10.683"></a><span id="l10.683" class="difflineplus">+{</span>
<a href="#l10.684"></a><span id="l10.684" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.685"></a><span id="l10.685" class="difflineplus">+}</span>
<a href="#l10.686"></a><span id="l10.686" class="difflineplus">+</span>
<a href="#l10.687"></a><span id="l10.687" class="difflineplus">+// readonly attribute nsIDOMNode parentNode</span>
<a href="#l10.688"></a><span id="l10.688" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetParentNode(nsIDOMNode * *aParentNode)</span>
<a href="#l10.689"></a><span id="l10.689" class="difflineplus">+{</span>
<a href="#l10.690"></a><span id="l10.690" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.691"></a><span id="l10.691" class="difflineplus">+}</span>
<a href="#l10.692"></a><span id="l10.692" class="difflineplus">+</span>
<a href="#l10.693"></a><span id="l10.693" class="difflineplus">+// readonly attribute nsIDOMNodeList childNodes</span>
<a href="#l10.694"></a><span id="l10.694" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetChildNodes(nsIDOMNodeList * *aChildNodes)</span>
<a href="#l10.695"></a><span id="l10.695" class="difflineplus">+{</span>
<a href="#l10.696"></a><span id="l10.696" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.697"></a><span id="l10.697" class="difflineplus">+}</span>
<a href="#l10.698"></a><span id="l10.698" class="difflineplus">+</span>
<a href="#l10.699"></a><span id="l10.699" class="difflineplus">+// readonly attribute nsIDOMNode firstChild</span>
<a href="#l10.700"></a><span id="l10.700" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetFirstChild(nsIDOMNode * *aFirstChild)</span>
<a href="#l10.701"></a><span id="l10.701" class="difflineplus">+{</span>
<a href="#l10.702"></a><span id="l10.702" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.703"></a><span id="l10.703" class="difflineplus">+}</span>
<a href="#l10.704"></a><span id="l10.704" class="difflineplus">+</span>
<a href="#l10.705"></a><span id="l10.705" class="difflineplus">+// readonly attribute nsIDOMNode lastChild</span>
<a href="#l10.706"></a><span id="l10.706" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetLastChild(nsIDOMNode * *aLastChild)</span>
<a href="#l10.707"></a><span id="l10.707" class="difflineplus">+{</span>
<a href="#l10.708"></a><span id="l10.708" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.709"></a><span id="l10.709" class="difflineplus">+}</span>
<a href="#l10.710"></a><span id="l10.710" class="difflineplus">+</span>
<a href="#l10.711"></a><span id="l10.711" class="difflineplus">+// readonly attribute nsIDOMNode previousSibling</span>
<a href="#l10.712"></a><span id="l10.712" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetPreviousSibling(nsIDOMNode * *aPreviousSibling)</span>
<a href="#l10.713"></a><span id="l10.713" class="difflineplus">+{</span>
<a href="#l10.714"></a><span id="l10.714" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.715"></a><span id="l10.715" class="difflineplus">+}</span>
<a href="#l10.716"></a><span id="l10.716" class="difflineplus">+</span>
<a href="#l10.717"></a><span id="l10.717" class="difflineplus">+// readonly attribute nsIDOMNode nextSibling</span>
<a href="#l10.718"></a><span id="l10.718" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetNextSibling(nsIDOMNode * *aNextSibling)</span>
<a href="#l10.719"></a><span id="l10.719" class="difflineplus">+{</span>
<a href="#l10.720"></a><span id="l10.720" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.721"></a><span id="l10.721" class="difflineplus">+}</span>
<a href="#l10.722"></a><span id="l10.722" class="difflineplus">+</span>
<a href="#l10.723"></a><span id="l10.723" class="difflineplus">+// readonly attribute nsIDOMNamedNodeMap attributes</span>
<a href="#l10.724"></a><span id="l10.724" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetAttributes(nsIDOMNamedNodeMap * *aAttributes)</span>
<a href="#l10.725"></a><span id="l10.725" class="difflineplus">+{</span>
<a href="#l10.726"></a><span id="l10.726" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.727"></a><span id="l10.727" class="difflineplus">+}</span>
<a href="#l10.728"></a><span id="l10.728" class="difflineplus">+</span>
<a href="#l10.729"></a><span id="l10.729" class="difflineplus">+// readonly attribute nsIDOMDocument ownerDocument</span>
<a href="#l10.730"></a><span id="l10.730" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetOwnerDocument(nsIDOMDocument * *aOwnerDocument)</span>
<a href="#l10.731"></a><span id="l10.731" class="difflineplus">+{</span>
<a href="#l10.732"></a><span id="l10.732" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.733"></a><span id="l10.733" class="difflineplus">+}</span>
<a href="#l10.734"></a><span id="l10.734" class="difflineplus">+</span>
<a href="#l10.735"></a><span id="l10.735" class="difflineplus">+// nsIDOMNode insertBefore (in nsIDOMNode newChild, in nsIDOMNode refChild)  raises (DOMException)</span>
<a href="#l10.736"></a><span id="l10.736" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::InsertBefore(nsIDOMNode *newChild, nsIDOMNode *refChild, nsIDOMNode **_retval)</span>
<a href="#l10.737"></a><span id="l10.737" class="difflineplus">+{</span>
<a href="#l10.738"></a><span id="l10.738" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.739"></a><span id="l10.739" class="difflineplus">+}</span>
<a href="#l10.740"></a><span id="l10.740" class="difflineplus">+</span>
<a href="#l10.741"></a><span id="l10.741" class="difflineplus">+// nsIDOMNode replaceChild (in nsIDOMNode newChild, in nsIDOMNode oldChild)  raises (DOMException)</span>
<a href="#l10.742"></a><span id="l10.742" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::ReplaceChild(nsIDOMNode *newChild, nsIDOMNode *oldChild, nsIDOMNode **_retval)</span>
<a href="#l10.743"></a><span id="l10.743" class="difflineplus">+{</span>
<a href="#l10.744"></a><span id="l10.744" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.745"></a><span id="l10.745" class="difflineplus">+}</span>
<a href="#l10.746"></a><span id="l10.746" class="difflineplus">+</span>
<a href="#l10.747"></a><span id="l10.747" class="difflineplus">+// nsIDOMNode removeChild (in nsIDOMNode oldChild)  raises (DOMException)</span>
<a href="#l10.748"></a><span id="l10.748" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::RemoveChild(nsIDOMNode *oldChild, nsIDOMNode **_retval)</span>
<a href="#l10.749"></a><span id="l10.749" class="difflineplus">+{</span>
<a href="#l10.750"></a><span id="l10.750" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.751"></a><span id="l10.751" class="difflineplus">+}</span>
<a href="#l10.752"></a><span id="l10.752" class="difflineplus">+</span>
<a href="#l10.753"></a><span id="l10.753" class="difflineplus">+// nsIDOMNode appendChild (in nsIDOMNode newChild)  raises (DOMException)</span>
<a href="#l10.754"></a><span id="l10.754" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::AppendChild(nsIDOMNode *newChild, nsIDOMNode **_retval)</span>
<a href="#l10.755"></a><span id="l10.755" class="difflineplus">+{</span>
<a href="#l10.756"></a><span id="l10.756" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.757"></a><span id="l10.757" class="difflineplus">+}</span>
<a href="#l10.758"></a><span id="l10.758" class="difflineplus">+</span>
<a href="#l10.759"></a><span id="l10.759" class="difflineplus">+// boolean hasChildNodes ()</span>
<a href="#l10.760"></a><span id="l10.760" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::HasChildNodes(PRBool *_retval)</span>
<a href="#l10.761"></a><span id="l10.761" class="difflineplus">+{</span>
<a href="#l10.762"></a><span id="l10.762" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.763"></a><span id="l10.763" class="difflineplus">+}</span>
<a href="#l10.764"></a><span id="l10.764" class="difflineplus">+</span>
<a href="#l10.765"></a><span id="l10.765" class="difflineplus">+// nsIDOMNode cloneNode (in boolean deep)</span>
<a href="#l10.766"></a><span id="l10.766" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::CloneNode(PRBool deep, nsIDOMNode **_retval)</span>
<a href="#l10.767"></a><span id="l10.767" class="difflineplus">+{</span>
<a href="#l10.768"></a><span id="l10.768" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.769"></a><span id="l10.769" class="difflineplus">+}</span>
<a href="#l10.770"></a><span id="l10.770" class="difflineplus">+</span>
<a href="#l10.771"></a><span id="l10.771" class="difflineplus">+// void normalize ()</span>
<a href="#l10.772"></a><span id="l10.772" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::Normalize()</span>
<a href="#l10.773"></a><span id="l10.773" class="difflineplus">+{</span>
<a href="#l10.774"></a><span id="l10.774" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.775"></a><span id="l10.775" class="difflineplus">+}</span>
<a href="#l10.776"></a><span id="l10.776" class="difflineplus">+</span>
<a href="#l10.777"></a><span id="l10.777" class="difflineplus">+// boolean isSupported (in DOMString feature, in DOMString version)</span>
<a href="#l10.778"></a><span id="l10.778" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::IsSupported(const nsAString &amp; feature, const nsAString &amp; version, PRBool *_retval)</span>
<a href="#l10.779"></a><span id="l10.779" class="difflineplus">+{</span>
<a href="#l10.780"></a><span id="l10.780" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.781"></a><span id="l10.781" class="difflineplus">+}</span>
<a href="#l10.782"></a><span id="l10.782" class="difflineplus">+</span>
<a href="#l10.783"></a><span id="l10.783" class="difflineplus">+// readonly attribute DOMString namespaceURI</span>
<a href="#l10.784"></a><span id="l10.784" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetNamespaceURI(nsAString &amp; aNamespaceURI)</span>
<a href="#l10.785"></a><span id="l10.785" class="difflineplus">+{</span>
<a href="#l10.786"></a><span id="l10.786" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.787"></a><span id="l10.787" class="difflineplus">+}</span>
<a href="#l10.788"></a><span id="l10.788" class="difflineplus">+</span>
<a href="#l10.789"></a><span id="l10.789" class="difflineplus">+// attribute DOMString prefix</span>
<a href="#l10.790"></a><span id="l10.790" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetPrefix(nsAString &amp; aPrefix)</span>
<a href="#l10.791"></a><span id="l10.791" class="difflineplus">+{</span>
<a href="#l10.792"></a><span id="l10.792" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.793"></a><span id="l10.793" class="difflineplus">+}</span>
<a href="#l10.794"></a><span id="l10.794" class="difflineplus">+</span>
<a href="#l10.795"></a><span id="l10.795" class="difflineplus">+// readonly attribute DOMString localName</span>
<a href="#l10.796"></a><span id="l10.796" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetLocalName(nsAString &amp; aLocalName)</span>
<a href="#l10.797"></a><span id="l10.797" class="difflineplus">+{</span>
<a href="#l10.798"></a><span id="l10.798" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.799"></a><span id="l10.799" class="difflineplus">+}</span>
<a href="#l10.800"></a><span id="l10.800" class="difflineplus">+</span>
<a href="#l10.801"></a><span id="l10.801" class="difflineplus">+// boolean hasAttributes ()</span>
<a href="#l10.802"></a><span id="l10.802" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::HasAttributes(PRBool *_retval)</span>
<a href="#l10.803"></a><span id="l10.803" class="difflineplus">+{</span>
<a href="#l10.804"></a><span id="l10.804" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.805"></a><span id="l10.805" class="difflineplus">+}</span>
<a href="#l10.806"></a><span id="l10.806" class="difflineplus">+</span>
<a href="#l10.807"></a><span id="l10.807" class="difflineplus">+// readonly attribute DOMString tagName</span>
<a href="#l10.808"></a><span id="l10.808" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetTagName(nsAString &amp; aTagName)</span>
<a href="#l10.809"></a><span id="l10.809" class="difflineplus">+{</span>
<a href="#l10.810"></a><span id="l10.810" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.811"></a><span id="l10.811" class="difflineplus">+}</span>
<a href="#l10.812"></a><span id="l10.812" class="difflineplus">+</span>
<a href="#l10.813"></a><span id="l10.813" class="difflineplus">+// DOMString getAttribute (in DOMString name)</span>
<a href="#l10.814"></a><span id="l10.814" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetAttribute(const nsAString &amp; name, nsAString &amp; _retval)</span>
<a href="#l10.815"></a><span id="l10.815" class="difflineplus">+{</span>
<a href="#l10.816"></a><span id="l10.816" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.817"></a><span id="l10.817" class="difflineplus">+}</span>
<a href="#l10.818"></a><span id="l10.818" class="difflineplus">+</span>
<a href="#l10.819"></a><span id="l10.819" class="difflineplus">+// void setAttribute (in DOMString name, in DOMString value)  raises (DOMException)</span>
<a href="#l10.820"></a><span id="l10.820" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetAttribute(const nsAString &amp; name, const nsAString &amp; value)</span>
<a href="#l10.821"></a><span id="l10.821" class="difflineplus">+{</span>
<a href="#l10.822"></a><span id="l10.822" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.823"></a><span id="l10.823" class="difflineplus">+}</span>
<a href="#l10.824"></a><span id="l10.824" class="difflineplus">+</span>
<a href="#l10.825"></a><span id="l10.825" class="difflineplus">+// void removeAttribute (in DOMString name)  raises (DOMException)</span>
<a href="#l10.826"></a><span id="l10.826" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::RemoveAttribute(const nsAString &amp; name)</span>
<a href="#l10.827"></a><span id="l10.827" class="difflineplus">+{</span>
<a href="#l10.828"></a><span id="l10.828" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.829"></a><span id="l10.829" class="difflineplus">+}</span>
<a href="#l10.830"></a><span id="l10.830" class="difflineplus">+</span>
<a href="#l10.831"></a><span id="l10.831" class="difflineplus">+// nsIDOMAttr getAttributeNode (in DOMString name)</span>
<a href="#l10.832"></a><span id="l10.832" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetAttributeNode(const nsAString &amp; name, nsIDOMAttr **_retval)</span>
<a href="#l10.833"></a><span id="l10.833" class="difflineplus">+{</span>
<a href="#l10.834"></a><span id="l10.834" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.835"></a><span id="l10.835" class="difflineplus">+}</span>
<a href="#l10.836"></a><span id="l10.836" class="difflineplus">+</span>
<a href="#l10.837"></a><span id="l10.837" class="difflineplus">+// nsIDOMAttr setAttributeNode (in nsIDOMAttr newAttr)  raises (DOMException)</span>
<a href="#l10.838"></a><span id="l10.838" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetAttributeNode(nsIDOMAttr *newAttr, nsIDOMAttr **_retval)</span>
<a href="#l10.839"></a><span id="l10.839" class="difflineplus">+{</span>
<a href="#l10.840"></a><span id="l10.840" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.841"></a><span id="l10.841" class="difflineplus">+}</span>
<a href="#l10.842"></a><span id="l10.842" class="difflineplus">+</span>
<a href="#l10.843"></a><span id="l10.843" class="difflineplus">+// nsIDOMAttr removeAttributeNode (in nsIDOMAttr oldAttr)  raises (DOMException)</span>
<a href="#l10.844"></a><span id="l10.844" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::RemoveAttributeNode(nsIDOMAttr *oldAttr, nsIDOMAttr **_retval)</span>
<a href="#l10.845"></a><span id="l10.845" class="difflineplus">+{</span>
<a href="#l10.846"></a><span id="l10.846" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.847"></a><span id="l10.847" class="difflineplus">+}</span>
<a href="#l10.848"></a><span id="l10.848" class="difflineplus">+</span>
<a href="#l10.849"></a><span id="l10.849" class="difflineplus">+// nsIDOMNodeList getElementsByTagName (in DOMString name)</span>
<a href="#l10.850"></a><span id="l10.850" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetElementsByTagName(const nsAString &amp; name, nsIDOMNodeList **_retval)</span>
<a href="#l10.851"></a><span id="l10.851" class="difflineplus">+{</span>
<a href="#l10.852"></a><span id="l10.852" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.853"></a><span id="l10.853" class="difflineplus">+}</span>
<a href="#l10.854"></a><span id="l10.854" class="difflineplus">+</span>
<a href="#l10.855"></a><span id="l10.855" class="difflineplus">+// DOMString getAttributeNS (in DOMString namespaceURI, in DOMString localName)</span>
<a href="#l10.856"></a><span id="l10.856" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetAttributeNS(const nsAString &amp; namespaceURI, const nsAString &amp; localName, nsAString &amp; _retval)</span>
<a href="#l10.857"></a><span id="l10.857" class="difflineplus">+{</span>
<a href="#l10.858"></a><span id="l10.858" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.859"></a><span id="l10.859" class="difflineplus">+}</span>
<a href="#l10.860"></a><span id="l10.860" class="difflineplus">+</span>
<a href="#l10.861"></a><span id="l10.861" class="difflineplus">+// void setAttributeNS (in DOMString namespaceURI, in DOMString qualifiedName, in DOMString value)  raises (DOMException)</span>
<a href="#l10.862"></a><span id="l10.862" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetAttributeNS(const nsAString &amp; namespaceURI, const nsAString &amp; qualifiedName, const nsAString &amp; value)</span>
<a href="#l10.863"></a><span id="l10.863" class="difflineplus">+{</span>
<a href="#l10.864"></a><span id="l10.864" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.865"></a><span id="l10.865" class="difflineplus">+}</span>
<a href="#l10.866"></a><span id="l10.866" class="difflineplus">+</span>
<a href="#l10.867"></a><span id="l10.867" class="difflineplus">+// void removeAttributeNS (in DOMString namespaceURI, in DOMString localName)  raises (DOMException)</span>
<a href="#l10.868"></a><span id="l10.868" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::RemoveAttributeNS(const nsAString &amp; namespaceURI, const nsAString &amp; localName)</span>
<a href="#l10.869"></a><span id="l10.869" class="difflineplus">+{</span>
<a href="#l10.870"></a><span id="l10.870" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.871"></a><span id="l10.871" class="difflineplus">+}</span>
<a href="#l10.872"></a><span id="l10.872" class="difflineplus">+</span>
<a href="#l10.873"></a><span id="l10.873" class="difflineplus">+// nsIDOMAttr getAttributeNodeNS (in DOMString namespaceURI, in DOMString localName)</span>
<a href="#l10.874"></a><span id="l10.874" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetAttributeNodeNS(const nsAString &amp; namespaceURI, const nsAString &amp; localName, nsIDOMAttr **_retval)</span>
<a href="#l10.875"></a><span id="l10.875" class="difflineplus">+{</span>
<a href="#l10.876"></a><span id="l10.876" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.877"></a><span id="l10.877" class="difflineplus">+}</span>
<a href="#l10.878"></a><span id="l10.878" class="difflineplus">+</span>
<a href="#l10.879"></a><span id="l10.879" class="difflineplus">+// nsIDOMAttr setAttributeNodeNS (in nsIDOMAttr newAttr)  raises (DOMException)</span>
<a href="#l10.880"></a><span id="l10.880" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetAttributeNodeNS(nsIDOMAttr *newAttr, nsIDOMAttr **_retval)</span>
<a href="#l10.881"></a><span id="l10.881" class="difflineplus">+{</span>
<a href="#l10.882"></a><span id="l10.882" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.883"></a><span id="l10.883" class="difflineplus">+}</span>
<a href="#l10.884"></a><span id="l10.884" class="difflineplus">+</span>
<a href="#l10.885"></a><span id="l10.885" class="difflineplus">+// nsIDOMNodeList getElementsByTagNameNS (in DOMString namespaceURI, in DOMString localName)</span>
<a href="#l10.886"></a><span id="l10.886" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetElementsByTagNameNS(const nsAString &amp; namespaceURI, const nsAString &amp; localName, nsIDOMNodeList **_retval)</span>
<a href="#l10.887"></a><span id="l10.887" class="difflineplus">+{</span>
<a href="#l10.888"></a><span id="l10.888" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.889"></a><span id="l10.889" class="difflineplus">+}</span>
<a href="#l10.890"></a><span id="l10.890" class="difflineplus">+</span>
<a href="#l10.891"></a><span id="l10.891" class="difflineplus">+// boolean hasAttribute (in DOMString name)</span>
<a href="#l10.892"></a><span id="l10.892" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::HasAttribute(const nsAString &amp; name, PRBool *_retval)</span>
<a href="#l10.893"></a><span id="l10.893" class="difflineplus">+{</span>
<a href="#l10.894"></a><span id="l10.894" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.895"></a><span id="l10.895" class="difflineplus">+}</span>
<a href="#l10.896"></a><span id="l10.896" class="difflineplus">+</span>
<a href="#l10.897"></a><span id="l10.897" class="difflineplus">+// boolean hasAttributeNS (in DOMString namespaceURI, in DOMString localName)</span>
<a href="#l10.898"></a><span id="l10.898" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::HasAttributeNS(const nsAString &amp; namespaceURI, const nsAString &amp; localName, PRBool *_retval)</span>
<a href="#l10.899"></a><span id="l10.899" class="difflineplus">+{</span>
<a href="#l10.900"></a><span id="l10.900" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.901"></a><span id="l10.901" class="difflineplus">+}</span>
<a href="#l10.902"></a><span id="l10.902" class="difflineplus">+</span>
<a href="#l10.903"></a><span id="l10.903" class="difflineplus">+// attribute DOMString id</span>
<a href="#l10.904"></a><span id="l10.904" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetId(nsAString &amp; aId)</span>
<a href="#l10.905"></a><span id="l10.905" class="difflineplus">+{</span>
<a href="#l10.906"></a><span id="l10.906" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.907"></a><span id="l10.907" class="difflineplus">+}</span>
<a href="#l10.908"></a><span id="l10.908" class="difflineplus">+</span>
<a href="#l10.909"></a><span id="l10.909" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetId(const nsAString &amp; aId)</span>
<a href="#l10.910"></a><span id="l10.910" class="difflineplus">+{</span>
<a href="#l10.911"></a><span id="l10.911" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.912"></a><span id="l10.912" class="difflineplus">+}</span>
<a href="#l10.913"></a><span id="l10.913" class="difflineplus">+</span>
<a href="#l10.914"></a><span id="l10.914" class="difflineplus">+// attribute DOMString title</span>
<a href="#l10.915"></a><span id="l10.915" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetTitle(nsAString &amp; aTitle)</span>
<a href="#l10.916"></a><span id="l10.916" class="difflineplus">+{</span>
<a href="#l10.917"></a><span id="l10.917" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.918"></a><span id="l10.918" class="difflineplus">+}</span>
<a href="#l10.919"></a><span id="l10.919" class="difflineplus">+</span>
<a href="#l10.920"></a><span id="l10.920" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetTitle(const nsAString &amp; aTitle)</span>
<a href="#l10.921"></a><span id="l10.921" class="difflineplus">+{</span>
<a href="#l10.922"></a><span id="l10.922" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.923"></a><span id="l10.923" class="difflineplus">+}</span>
<a href="#l10.924"></a><span id="l10.924" class="difflineplus">+</span>
<a href="#l10.925"></a><span id="l10.925" class="difflineplus">+// attribute DOMString lang</span>
<a href="#l10.926"></a><span id="l10.926" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetLang(nsAString &amp; aLang)</span>
<a href="#l10.927"></a><span id="l10.927" class="difflineplus">+{</span>
<a href="#l10.928"></a><span id="l10.928" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.929"></a><span id="l10.929" class="difflineplus">+}</span>
<a href="#l10.930"></a><span id="l10.930" class="difflineplus">+</span>
<a href="#l10.931"></a><span id="l10.931" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetLang(const nsAString &amp; aLang)</span>
<a href="#l10.932"></a><span id="l10.932" class="difflineplus">+{</span>
<a href="#l10.933"></a><span id="l10.933" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.934"></a><span id="l10.934" class="difflineplus">+}</span>
<a href="#l10.935"></a><span id="l10.935" class="difflineplus">+</span>
<a href="#l10.936"></a><span id="l10.936" class="difflineplus">+// attribute DOMString dir</span>
<a href="#l10.937"></a><span id="l10.937" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetDir(nsAString &amp; aDir)</span>
<a href="#l10.938"></a><span id="l10.938" class="difflineplus">+{</span>
<a href="#l10.939"></a><span id="l10.939" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.940"></a><span id="l10.940" class="difflineplus">+}</span>
<a href="#l10.941"></a><span id="l10.941" class="difflineplus">+</span>
<a href="#l10.942"></a><span id="l10.942" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetDir(const nsAString &amp; aDir)</span>
<a href="#l10.943"></a><span id="l10.943" class="difflineplus">+{</span>
<a href="#l10.944"></a><span id="l10.944" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.945"></a><span id="l10.945" class="difflineplus">+}</span>
<a href="#l10.946"></a><span id="l10.946" class="difflineplus">+</span>
<a href="#l10.947"></a><span id="l10.947" class="difflineplus">+// attribute DOMString className</span>
<a href="#l10.948"></a><span id="l10.948" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetClassName(nsAString &amp; aClassName)</span>
<a href="#l10.949"></a><span id="l10.949" class="difflineplus">+{</span>
<a href="#l10.950"></a><span id="l10.950" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.951"></a><span id="l10.951" class="difflineplus">+}</span>
<a href="#l10.952"></a><span id="l10.952" class="difflineplus">+</span>
<a href="#l10.953"></a><span id="l10.953" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetClassName(const nsAString &amp; aClassName)</span>
<a href="#l10.954"></a><span id="l10.954" class="difflineplus">+{</span>
<a href="#l10.955"></a><span id="l10.955" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.956"></a><span id="l10.956" class="difflineplus">+}</span>
<a href="#l10.957"></a><span id="l10.957" class="difflineplus">+</span>
<a href="#l10.958"></a><span id="l10.958" class="difflineplus">+// attribute DOMString name</span>
<a href="#l10.959"></a><span id="l10.959" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetName(nsAString &amp; aName)</span>
<a href="#l10.960"></a><span id="l10.960" class="difflineplus">+{</span>
<a href="#l10.961"></a><span id="l10.961" class="difflineplus">+  aName.Assign(m_name);</span>
<a href="#l10.962"></a><span id="l10.962" class="difflineplus">+  return NS_OK;</span>
<a href="#l10.963"></a><span id="l10.963" class="difflineplus">+}</span>
<a href="#l10.964"></a><span id="l10.964" class="difflineplus">+</span>
<a href="#l10.965"></a><span id="l10.965" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetName(const nsAString &amp; aName)</span>
<a href="#l10.966"></a><span id="l10.966" class="difflineplus">+{</span>
<a href="#l10.967"></a><span id="l10.967" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.968"></a><span id="l10.968" class="difflineplus">+}</span>
<a href="#l10.969"></a><span id="l10.969" class="difflineplus">+</span>
<a href="#l10.970"></a><span id="l10.970" class="difflineplus">+// attribute DOMString align</span>
<a href="#l10.971"></a><span id="l10.971" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetAlign(nsAString &amp; aAlign)</span>
<a href="#l10.972"></a><span id="l10.972" class="difflineplus">+{</span>
<a href="#l10.973"></a><span id="l10.973" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.974"></a><span id="l10.974" class="difflineplus">+}</span>
<a href="#l10.975"></a><span id="l10.975" class="difflineplus">+</span>
<a href="#l10.976"></a><span id="l10.976" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetAlign(const nsAString &amp; aAlign)</span>
<a href="#l10.977"></a><span id="l10.977" class="difflineplus">+{</span>
<a href="#l10.978"></a><span id="l10.978" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.979"></a><span id="l10.979" class="difflineplus">+}</span>
<a href="#l10.980"></a><span id="l10.980" class="difflineplus">+</span>
<a href="#l10.981"></a><span id="l10.981" class="difflineplus">+// attribute DOMString alt</span>
<a href="#l10.982"></a><span id="l10.982" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetAlt(nsAString &amp; aAlt)</span>
<a href="#l10.983"></a><span id="l10.983" class="difflineplus">+{</span>
<a href="#l10.984"></a><span id="l10.984" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.985"></a><span id="l10.985" class="difflineplus">+}</span>
<a href="#l10.986"></a><span id="l10.986" class="difflineplus">+</span>
<a href="#l10.987"></a><span id="l10.987" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetAlt(const nsAString &amp; aAlt)</span>
<a href="#l10.988"></a><span id="l10.988" class="difflineplus">+{</span>
<a href="#l10.989"></a><span id="l10.989" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.990"></a><span id="l10.990" class="difflineplus">+}</span>
<a href="#l10.991"></a><span id="l10.991" class="difflineplus">+</span>
<a href="#l10.992"></a><span id="l10.992" class="difflineplus">+// attribute DOMString lowsrc</span>
<a href="#l10.993"></a><span id="l10.993" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetLowsrc(nsAString &amp;aResult)</span>
<a href="#l10.994"></a><span id="l10.994" class="difflineplus">+{</span>
<a href="#l10.995"></a><span id="l10.995" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.996"></a><span id="l10.996" class="difflineplus">+}</span>
<a href="#l10.997"></a><span id="l10.997" class="difflineplus">+</span>
<a href="#l10.998"></a><span id="l10.998" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetLowsrc(const nsAString &amp;aResult)</span>
<a href="#l10.999"></a><span id="l10.999" class="difflineplus">+{</span>
<a href="#l10.1000"></a><span id="l10.1000" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1001"></a><span id="l10.1001" class="difflineplus">+}</span>
<a href="#l10.1002"></a><span id="l10.1002" class="difflineplus">+</span>
<a href="#l10.1003"></a><span id="l10.1003" class="difflineplus">+// readonly attribute DOMString complete</span>
<a href="#l10.1004"></a><span id="l10.1004" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetComplete(PRBool *aResult)</span>
<a href="#l10.1005"></a><span id="l10.1005" class="difflineplus">+{</span>
<a href="#l10.1006"></a><span id="l10.1006" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1007"></a><span id="l10.1007" class="difflineplus">+}</span>
<a href="#l10.1008"></a><span id="l10.1008" class="difflineplus">+</span>
<a href="#l10.1009"></a><span id="l10.1009" class="difflineplus">+// readonly attribute long naturalWidth</span>
<a href="#l10.1010"></a><span id="l10.1010" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetNaturalWidth(PRInt32 *aResult)</span>
<a href="#l10.1011"></a><span id="l10.1011" class="difflineplus">+{</span>
<a href="#l10.1012"></a><span id="l10.1012" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1013"></a><span id="l10.1013" class="difflineplus">+}</span>
<a href="#l10.1014"></a><span id="l10.1014" class="difflineplus">+</span>
<a href="#l10.1015"></a><span id="l10.1015" class="difflineplus">+// readonly attribute long naturalHeight</span>
<a href="#l10.1016"></a><span id="l10.1016" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetNaturalHeight(PRInt32 *aResult)</span>
<a href="#l10.1017"></a><span id="l10.1017" class="difflineplus">+{</span>
<a href="#l10.1018"></a><span id="l10.1018" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1019"></a><span id="l10.1019" class="difflineplus">+}</span>
<a href="#l10.1020"></a><span id="l10.1020" class="difflineplus">+</span>
<a href="#l10.1021"></a><span id="l10.1021" class="difflineplus">+// readonly attribute long x</span>
<a href="#l10.1022"></a><span id="l10.1022" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetX(PRInt32 *aResult)</span>
<a href="#l10.1023"></a><span id="l10.1023" class="difflineplus">+{</span>
<a href="#l10.1024"></a><span id="l10.1024" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1025"></a><span id="l10.1025" class="difflineplus">+}</span>
<a href="#l10.1026"></a><span id="l10.1026" class="difflineplus">+// readonly attribute long y</span>
<a href="#l10.1027"></a><span id="l10.1027" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetY(PRInt32 *aResult)</span>
<a href="#l10.1028"></a><span id="l10.1028" class="difflineplus">+{</span>
<a href="#l10.1029"></a><span id="l10.1029" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1030"></a><span id="l10.1030" class="difflineplus">+}</span>
<a href="#l10.1031"></a><span id="l10.1031" class="difflineplus">+</span>
<a href="#l10.1032"></a><span id="l10.1032" class="difflineplus">+// attribute DOMString border</span>
<a href="#l10.1033"></a><span id="l10.1033" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetBorder(nsAString &amp; aBorder)</span>
<a href="#l10.1034"></a><span id="l10.1034" class="difflineplus">+{</span>
<a href="#l10.1035"></a><span id="l10.1035" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1036"></a><span id="l10.1036" class="difflineplus">+}</span>
<a href="#l10.1037"></a><span id="l10.1037" class="difflineplus">+</span>
<a href="#l10.1038"></a><span id="l10.1038" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetBorder(const nsAString &amp; aBorder)</span>
<a href="#l10.1039"></a><span id="l10.1039" class="difflineplus">+{</span>
<a href="#l10.1040"></a><span id="l10.1040" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1041"></a><span id="l10.1041" class="difflineplus">+}</span>
<a href="#l10.1042"></a><span id="l10.1042" class="difflineplus">+</span>
<a href="#l10.1043"></a><span id="l10.1043" class="difflineplus">+// attribute long height</span>
<a href="#l10.1044"></a><span id="l10.1044" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetHeight(PRInt32 *aHeight)</span>
<a href="#l10.1045"></a><span id="l10.1045" class="difflineplus">+{</span>
<a href="#l10.1046"></a><span id="l10.1046" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1047"></a><span id="l10.1047" class="difflineplus">+}</span>
<a href="#l10.1048"></a><span id="l10.1048" class="difflineplus">+</span>
<a href="#l10.1049"></a><span id="l10.1049" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetHeight(PRInt32 aHeight)</span>
<a href="#l10.1050"></a><span id="l10.1050" class="difflineplus">+{</span>
<a href="#l10.1051"></a><span id="l10.1051" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1052"></a><span id="l10.1052" class="difflineplus">+}</span>
<a href="#l10.1053"></a><span id="l10.1053" class="difflineplus">+</span>
<a href="#l10.1054"></a><span id="l10.1054" class="difflineplus">+// attribute long hspace</span>
<a href="#l10.1055"></a><span id="l10.1055" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetHspace(PRInt32 *aHspace)</span>
<a href="#l10.1056"></a><span id="l10.1056" class="difflineplus">+{</span>
<a href="#l10.1057"></a><span id="l10.1057" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1058"></a><span id="l10.1058" class="difflineplus">+}</span>
<a href="#l10.1059"></a><span id="l10.1059" class="difflineplus">+</span>
<a href="#l10.1060"></a><span id="l10.1060" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetHspace(PRInt32 aHspace)</span>
<a href="#l10.1061"></a><span id="l10.1061" class="difflineplus">+{</span>
<a href="#l10.1062"></a><span id="l10.1062" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1063"></a><span id="l10.1063" class="difflineplus">+}</span>
<a href="#l10.1064"></a><span id="l10.1064" class="difflineplus">+</span>
<a href="#l10.1065"></a><span id="l10.1065" class="difflineplus">+// attribute boolean isMap</span>
<a href="#l10.1066"></a><span id="l10.1066" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetIsMap(PRBool *aIsMap)</span>
<a href="#l10.1067"></a><span id="l10.1067" class="difflineplus">+{</span>
<a href="#l10.1068"></a><span id="l10.1068" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1069"></a><span id="l10.1069" class="difflineplus">+}</span>
<a href="#l10.1070"></a><span id="l10.1070" class="difflineplus">+</span>
<a href="#l10.1071"></a><span id="l10.1071" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetIsMap(PRBool aIsMap)</span>
<a href="#l10.1072"></a><span id="l10.1072" class="difflineplus">+{</span>
<a href="#l10.1073"></a><span id="l10.1073" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1074"></a><span id="l10.1074" class="difflineplus">+}</span>
<a href="#l10.1075"></a><span id="l10.1075" class="difflineplus">+</span>
<a href="#l10.1076"></a><span id="l10.1076" class="difflineplus">+// attribute DOMString longDesc</span>
<a href="#l10.1077"></a><span id="l10.1077" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetLongDesc(nsAString &amp; aLongDesc)</span>
<a href="#l10.1078"></a><span id="l10.1078" class="difflineplus">+{</span>
<a href="#l10.1079"></a><span id="l10.1079" class="difflineplus">+  return NS_OK;</span>
<a href="#l10.1080"></a><span id="l10.1080" class="difflineplus">+}</span>
<a href="#l10.1081"></a><span id="l10.1081" class="difflineplus">+</span>
<a href="#l10.1082"></a><span id="l10.1082" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetLongDesc(const nsAString &amp; aLongDesc)</span>
<a href="#l10.1083"></a><span id="l10.1083" class="difflineplus">+{</span>
<a href="#l10.1084"></a><span id="l10.1084" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1085"></a><span id="l10.1085" class="difflineplus">+}</span>
<a href="#l10.1086"></a><span id="l10.1086" class="difflineplus">+</span>
<a href="#l10.1087"></a><span id="l10.1087" class="difflineplus">+</span>
<a href="#l10.1088"></a><span id="l10.1088" class="difflineplus">+// attribute DOMString src</span>
<a href="#l10.1089"></a><span id="l10.1089" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetSrc(nsAString &amp; aSrc)</span>
<a href="#l10.1090"></a><span id="l10.1090" class="difflineplus">+{</span>
<a href="#l10.1091"></a><span id="l10.1091" class="difflineplus">+  aSrc = m_src;</span>
<a href="#l10.1092"></a><span id="l10.1092" class="difflineplus">+  return NS_OK;</span>
<a href="#l10.1093"></a><span id="l10.1093" class="difflineplus">+}</span>
<a href="#l10.1094"></a><span id="l10.1094" class="difflineplus">+</span>
<a href="#l10.1095"></a><span id="l10.1095" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetSrc(const nsAString &amp; aSrc)</span>
<a href="#l10.1096"></a><span id="l10.1096" class="difflineplus">+{</span>
<a href="#l10.1097"></a><span id="l10.1097" class="difflineplus">+  // nsEudoraHTMLImageElement calls UpdateEmbeddedImageReference(m_cid, aSrc)</span>
<a href="#l10.1098"></a><span id="l10.1098" class="difflineplus">+  // on the editor here, but our editor doen't implement it.</span>
<a href="#l10.1099"></a><span id="l10.1099" class="difflineplus">+</span>
<a href="#l10.1100"></a><span id="l10.1100" class="difflineplus">+  // The nsMsgNend::ProcessMultipartRelated seems to call SetSrc twice.</span>
<a href="#l10.1101"></a><span id="l10.1101" class="difflineplus">+  // I'm not sure if I need to do it second time.</span>
<a href="#l10.1102"></a><span id="l10.1102" class="difflineplus">+  if (m_cid_new.IsEmpty()) </span>
<a href="#l10.1103"></a><span id="l10.1103" class="difflineplus">+    m_cid_new.Assign(aSrc.Data()+4, aSrc.Length()-4); // strip the &quot;cid:&quot;</span>
<a href="#l10.1104"></a><span id="l10.1104" class="difflineplus">+</span>
<a href="#l10.1105"></a><span id="l10.1105" class="difflineplus">+  return NS_OK;</span>
<a href="#l10.1106"></a><span id="l10.1106" class="difflineplus">+}</span>
<a href="#l10.1107"></a><span id="l10.1107" class="difflineplus">+</span>
<a href="#l10.1108"></a><span id="l10.1108" class="difflineplus">+// attribute DOMString useMap</span>
<a href="#l10.1109"></a><span id="l10.1109" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetUseMap(nsAString &amp; aUseMap)</span>
<a href="#l10.1110"></a><span id="l10.1110" class="difflineplus">+{</span>
<a href="#l10.1111"></a><span id="l10.1111" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1112"></a><span id="l10.1112" class="difflineplus">+}</span>
<a href="#l10.1113"></a><span id="l10.1113" class="difflineplus">+</span>
<a href="#l10.1114"></a><span id="l10.1114" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetUseMap(const nsAString &amp; aUseMap)</span>
<a href="#l10.1115"></a><span id="l10.1115" class="difflineplus">+{</span>
<a href="#l10.1116"></a><span id="l10.1116" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1117"></a><span id="l10.1117" class="difflineplus">+}</span>
<a href="#l10.1118"></a><span id="l10.1118" class="difflineplus">+</span>
<a href="#l10.1119"></a><span id="l10.1119" class="difflineplus">+// attribute long vspace</span>
<a href="#l10.1120"></a><span id="l10.1120" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetVspace(PRInt32 *aVspace)</span>
<a href="#l10.1121"></a><span id="l10.1121" class="difflineplus">+{</span>
<a href="#l10.1122"></a><span id="l10.1122" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1123"></a><span id="l10.1123" class="difflineplus">+}</span>
<a href="#l10.1124"></a><span id="l10.1124" class="difflineplus">+</span>
<a href="#l10.1125"></a><span id="l10.1125" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetVspace(PRInt32 aVspace)</span>
<a href="#l10.1126"></a><span id="l10.1126" class="difflineplus">+{</span>
<a href="#l10.1127"></a><span id="l10.1127" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1128"></a><span id="l10.1128" class="difflineplus">+}</span>
<a href="#l10.1129"></a><span id="l10.1129" class="difflineplus">+</span>
<a href="#l10.1130"></a><span id="l10.1130" class="difflineplus">+// attribute long width</span>
<a href="#l10.1131"></a><span id="l10.1131" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetWidth(PRInt32 *aWidth)</span>
<a href="#l10.1132"></a><span id="l10.1132" class="difflineplus">+{</span>
<a href="#l10.1133"></a><span id="l10.1133" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1134"></a><span id="l10.1134" class="difflineplus">+}</span>
<a href="#l10.1135"></a><span id="l10.1135" class="difflineplus">+</span>
<a href="#l10.1136"></a><span id="l10.1136" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetWidth(PRInt32 aWidth)</span>
<a href="#l10.1137"></a><span id="l10.1137" class="difflineplus">+{</span>
<a href="#l10.1138"></a><span id="l10.1138" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1139"></a><span id="l10.1139" class="difflineplus">+}</span>
<a href="#l10.1140"></a><span id="l10.1140" class="difflineplus">+</span>
<a href="#l10.1141"></a><span id="l10.1141" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::GetAccessKey(nsAString &amp;aAccessKey)</span>
<a href="#l10.1142"></a><span id="l10.1142" class="difflineplus">+{</span>
<a href="#l10.1143"></a><span id="l10.1143" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1144"></a><span id="l10.1144" class="difflineplus">+}</span>
<a href="#l10.1145"></a><span id="l10.1145" class="difflineplus">+</span>
<a href="#l10.1146"></a><span id="l10.1146" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::SetAccessKey(const nsAString &amp;aAccessKey)</span>
<a href="#l10.1147"></a><span id="l10.1147" class="difflineplus">+{</span>
<a href="#l10.1148"></a><span id="l10.1148" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1149"></a><span id="l10.1149" class="difflineplus">+}</span>
<a href="#l10.1150"></a><span id="l10.1150" class="difflineplus">+</span>
<a href="#l10.1151"></a><span id="l10.1151" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::Blur()</span>
<a href="#l10.1152"></a><span id="l10.1152" class="difflineplus">+{</span>
<a href="#l10.1153"></a><span id="l10.1153" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1154"></a><span id="l10.1154" class="difflineplus">+}</span>
<a href="#l10.1155"></a><span id="l10.1155" class="difflineplus">+</span>
<a href="#l10.1156"></a><span id="l10.1156" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::Focus()</span>
<a href="#l10.1157"></a><span id="l10.1157" class="difflineplus">+{</span>
<a href="#l10.1158"></a><span id="l10.1158" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1159"></a><span id="l10.1159" class="difflineplus">+}</span>
<a href="#l10.1160"></a><span id="l10.1160" class="difflineplus">+</span>
<a href="#l10.1161"></a><span id="l10.1161" class="difflineplus">+NS_IMETHODIMP nsOutlookHTMLImageElement::Click()</span>
<a href="#l10.1162"></a><span id="l10.1162" class="difflineplus">+{</span>
<a href="#l10.1163"></a><span id="l10.1163" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l10.1164"></a><span id="l10.1164" class="difflineplus">+}</span>
<a href="#l10.1165"></a><span id="l10.1165" class="difflineplus">+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1">new file mode 100644</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineminus">--- /dev/null</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineplus">+++ b/mailnews/import/outlook/src/nsOutlookEditor.h</span>
<a href="#l11.4"></a><span id="l11.4" class="difflineat">@@ -0,0 +1,101 @@</span>
<a href="#l11.5"></a><span id="l11.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l11.6"></a><span id="l11.6" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l11.7"></a><span id="l11.7" class="difflineplus">+* Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l11.8"></a><span id="l11.8" class="difflineplus">+*</span>
<a href="#l11.9"></a><span id="l11.9" class="difflineplus">+* The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l11.10"></a><span id="l11.10" class="difflineplus">+* 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l11.11"></a><span id="l11.11" class="difflineplus">+* the License. You may obtain a copy of the License at</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineplus">+* http://www.mozilla.org/MPL/</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+*</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineplus">+* Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l11.15"></a><span id="l11.15" class="difflineplus">+* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l11.16"></a><span id="l11.16" class="difflineplus">+* for the specific language governing rights and limitations under the</span>
<a href="#l11.17"></a><span id="l11.17" class="difflineplus">+* License.</span>
<a href="#l11.18"></a><span id="l11.18" class="difflineplus">+*</span>
<a href="#l11.19"></a><span id="l11.19" class="difflineplus">+* The Original Code is qualcomm.com code.</span>
<a href="#l11.20"></a><span id="l11.20" class="difflineplus">+*</span>
<a href="#l11.21"></a><span id="l11.21" class="difflineplus">+* The Initial Developer of the Original Code is</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineplus">+* QUALCOMM, Inc.</span>
<a href="#l11.23"></a><span id="l11.23" class="difflineplus">+* Portions created by the Initial Developer are Copyright (C) 2007</span>
<a href="#l11.24"></a><span id="l11.24" class="difflineplus">+* the Initial Developer. All Rights Reserved.</span>
<a href="#l11.25"></a><span id="l11.25" class="difflineplus">+*</span>
<a href="#l11.26"></a><span id="l11.26" class="difflineplus">+* Contributor(s):</span>
<a href="#l11.27"></a><span id="l11.27" class="difflineplus">+*   Author: Geoffrey C. Wenger (gwenger@qualcomm.com)</span>
<a href="#l11.28"></a><span id="l11.28" class="difflineplus">+*</span>
<a href="#l11.29"></a><span id="l11.29" class="difflineplus">+* Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l11.30"></a><span id="l11.30" class="difflineplus">+* either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l11.31"></a><span id="l11.31" class="difflineplus">+* the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l11.32"></a><span id="l11.32" class="difflineplus">+* in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l11.33"></a><span id="l11.33" class="difflineplus">+* of those above. If you wish to allow use of your version of this file only</span>
<a href="#l11.34"></a><span id="l11.34" class="difflineplus">+* under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l11.35"></a><span id="l11.35" class="difflineplus">+* use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l11.36"></a><span id="l11.36" class="difflineplus">+* decision by deleting the provisions above and replace them with the notice</span>
<a href="#l11.37"></a><span id="l11.37" class="difflineplus">+* and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l11.38"></a><span id="l11.38" class="difflineplus">+* the provisions above, a recipient may use your version of this file under</span>
<a href="#l11.39"></a><span id="l11.39" class="difflineplus">+* the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l11.40"></a><span id="l11.40" class="difflineplus">+*</span>
<a href="#l11.41"></a><span id="l11.41" class="difflineplus">+* ***** END LICENSE BLOCK ***** */</span>
<a href="#l11.42"></a><span id="l11.42" class="difflineplus">+</span>
<a href="#l11.43"></a><span id="l11.43" class="difflineplus">+#include &quot;nscore.h&quot;</span>
<a href="#l11.44"></a><span id="l11.44" class="difflineplus">+#include &quot;nsIEditor.h&quot;</span>
<a href="#l11.45"></a><span id="l11.45" class="difflineplus">+#include &quot;nsIEditorMailSupport.h&quot;</span>
<a href="#l11.46"></a><span id="l11.46" class="difflineplus">+#include &quot;nsIDOMHTMLImageElement.h&quot;</span>
<a href="#l11.47"></a><span id="l11.47" class="difflineplus">+#include &quot;nsCOMPtr.h&quot;</span>
<a href="#l11.48"></a><span id="l11.48" class="difflineplus">+#include &quot;nsString.h&quot;</span>
<a href="#l11.49"></a><span id="l11.49" class="difflineplus">+#include &quot;nsIFile.h&quot;</span>
<a href="#l11.50"></a><span id="l11.50" class="difflineplus">+</span>
<a href="#l11.51"></a><span id="l11.51" class="difflineplus">+class nsOutlookEditor : public nsIEditor, public nsIEditorMailSupport</span>
<a href="#l11.52"></a><span id="l11.52" class="difflineplus">+{</span>
<a href="#l11.53"></a><span id="l11.53" class="difflineplus">+  public:</span>
<a href="#l11.54"></a><span id="l11.54" class="difflineplus">+    NS_DECL_ISUPPORTS</span>
<a href="#l11.55"></a><span id="l11.55" class="difflineplus">+    NS_DECL_NSIEDITOR</span>
<a href="#l11.56"></a><span id="l11.56" class="difflineplus">+    NS_DECL_NSIEDITORMAILSUPPORT</span>
<a href="#l11.57"></a><span id="l11.57" class="difflineplus">+</span>
<a href="#l11.58"></a><span id="l11.58" class="difflineplus">+    nsOutlookEditor(const wchar_t * body);</span>
<a href="#l11.59"></a><span id="l11.59" class="difflineplus">+</span>
<a href="#l11.60"></a><span id="l11.60" class="difflineplus">+    nsresult AddEmbeddedImage(nsIURI *uri, const wchar_t *cid, const wchar_t *name);</span>
<a href="#l11.61"></a><span id="l11.61" class="difflineplus">+</span>
<a href="#l11.62"></a><span id="l11.62" class="difflineplus">+    inline PRBool HasEmbeddedContent() const { return (m_EmbeddedObjectList != nsnull); }</span>
<a href="#l11.63"></a><span id="l11.63" class="difflineplus">+    PRUint32 EmbeddedObjectsCount() const;</span>
<a href="#l11.64"></a><span id="l11.64" class="difflineplus">+    nsresult GetCids(PRUint32 embedIndex, nsACString&amp; origCid, nsACString&amp; newCid) const;</span>
<a href="#l11.65"></a><span id="l11.65" class="difflineplus">+</span>
<a href="#l11.66"></a><span id="l11.66" class="difflineplus">+    ~nsOutlookEditor();</span>
<a href="#l11.67"></a><span id="l11.67" class="difflineplus">+</span>
<a href="#l11.68"></a><span id="l11.68" class="difflineplus">+  private:</span>
<a href="#l11.69"></a><span id="l11.69" class="difflineplus">+//    nsString                    m_body;</span>
<a href="#l11.70"></a><span id="l11.70" class="difflineplus">+    const wchar_t*              m_body;</span>
<a href="#l11.71"></a><span id="l11.71" class="difflineplus">+    nsCOMPtr&lt;nsISupportsArray&gt;  m_EmbeddedObjectList; // it's initialized when AddEmbeddedImage is called</span>
<a href="#l11.72"></a><span id="l11.72" class="difflineplus">+};</span>
<a href="#l11.73"></a><span id="l11.73" class="difflineplus">+</span>
<a href="#l11.74"></a><span id="l11.74" class="difflineplus">+#define NS_OUTLOOKHTMLIMAGEELEMENT_IID_STR &quot;5fb3c060-20b5-11e0-b2ba-0002a5d5c51b&quot;</span>
<a href="#l11.75"></a><span id="l11.75" class="difflineplus">+</span>
<a href="#l11.76"></a><span id="l11.76" class="difflineplus">+#define NS_OUTLOOKHTMLIMAGEELEMENT_IID \</span>
<a href="#l11.77"></a><span id="l11.77" class="difflineplus">+  {0x5fb3c060, 0x20b5, 0x11e0, \</span>
<a href="#l11.78"></a><span id="l11.78" class="difflineplus">+    { 0xb2, 0xba, 0x00, 0x02, 0xa5, 0xd5, 0xc5, 0x1b }}</span>
<a href="#l11.79"></a><span id="l11.79" class="difflineplus">+</span>
<a href="#l11.80"></a><span id="l11.80" class="difflineplus">+class nsOutlookHTMLImageElement : public nsIDOMHTMLImageElement</span>
<a href="#l11.81"></a><span id="l11.81" class="difflineplus">+{</span>
<a href="#l11.82"></a><span id="l11.82" class="difflineplus">+  public:</span>
<a href="#l11.83"></a><span id="l11.83" class="difflineplus">+    NS_DECLARE_STATIC_IID_ACCESSOR(NS_OUTLOOKHTMLIMAGEELEMENT_IID)</span>
<a href="#l11.84"></a><span id="l11.84" class="difflineplus">+</span>
<a href="#l11.85"></a><span id="l11.85" class="difflineplus">+    NS_DECL_ISUPPORTS</span>
<a href="#l11.86"></a><span id="l11.86" class="difflineplus">+    NS_DECL_NSIDOMNODE</span>
<a href="#l11.87"></a><span id="l11.87" class="difflineplus">+    NS_DECL_NSIDOMELEMENT</span>
<a href="#l11.88"></a><span id="l11.88" class="difflineplus">+    NS_DECL_NSIDOMHTMLELEMENT</span>
<a href="#l11.89"></a><span id="l11.89" class="difflineplus">+    NS_DECL_NSIDOMHTMLIMAGEELEMENT</span>
<a href="#l11.90"></a><span id="l11.90" class="difflineplus">+</span>
<a href="#l11.91"></a><span id="l11.91" class="difflineplus">+    nsOutlookHTMLImageElement(nsOutlookEditor *pEditor, nsIURI *uri, const wchar_t *cid, const wchar_t *name);</span>
<a href="#l11.92"></a><span id="l11.92" class="difflineplus">+    inline const wchar_t* OrigCid() const { return m_cid_orig.get(); }</span>
<a href="#l11.93"></a><span id="l11.93" class="difflineplus">+    inline const wchar_t* NewCid() const { return m_cid_new.IsEmpty() ? 0 : m_cid_new.get(); }</span>
<a href="#l11.94"></a><span id="l11.94" class="difflineplus">+</span>
<a href="#l11.95"></a><span id="l11.95" class="difflineplus">+  private:</span>
<a href="#l11.96"></a><span id="l11.96" class="difflineplus">+    ~nsOutlookHTMLImageElement();</span>
<a href="#l11.97"></a><span id="l11.97" class="difflineplus">+</span>
<a href="#l11.98"></a><span id="l11.98" class="difflineplus">+    nsCOMPtr&lt;nsIEditor&gt;         m_pEditor;</span>
<a href="#l11.99"></a><span id="l11.99" class="difflineplus">+    nsString                    m_src;</span>
<a href="#l11.100"></a><span id="l11.100" class="difflineplus">+    nsString                    m_cid_orig;</span>
<a href="#l11.101"></a><span id="l11.101" class="difflineplus">+    nsString                    m_cid_new;</span>
<a href="#l11.102"></a><span id="l11.102" class="difflineplus">+    nsString                    m_name;</span>
<a href="#l11.103"></a><span id="l11.103" class="difflineplus">+};</span>
<a href="#l11.104"></a><span id="l11.104" class="difflineplus">+</span>
<a href="#l11.105"></a><span id="l11.105" class="difflineplus">+NS_DEFINE_STATIC_IID_ACCESSOR(nsOutlookHTMLImageElement, NS_OUTLOOKHTMLIMAGEELEMENT_IID)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/mailnews/import/outlook/src/nsOutlookMail.cpp</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/mailnews/import/outlook/src/nsOutlookMail.cpp</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -46,17 +46,16 @@</span>
<a href="#l12.4"></a><span id="l12.4"> #include &quot;nsIImportService.h&quot;</span>
<a href="#l12.5"></a><span id="l12.5"> #include &quot;nsIImportFieldMap.h&quot;</span>
<a href="#l12.6"></a><span id="l12.6"> #include &quot;nsIImportMailboxDescriptor.h&quot;</span>
<a href="#l12.7"></a><span id="l12.7"> #include &quot;nsIImportABDescriptor.h&quot;</span>
<a href="#l12.8"></a><span id="l12.8"> #include &quot;nsReadableUtils.h&quot;</span>
<a href="#l12.9"></a><span id="l12.9"> #include &quot;nsOutlookStringBundle.h&quot;</span>
<a href="#l12.10"></a><span id="l12.10"> #include &quot;nsABBaseCID.h&quot;</span>
<a href="#l12.11"></a><span id="l12.11"> #include &quot;nsIAbCard.h&quot;</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-#include &quot;nsIAddrDatabase.h&quot;</span>
<a href="#l12.13"></a><span id="l12.13"> #include &quot;mdb.h&quot;</span>
<a href="#l12.14"></a><span id="l12.14"> #include &quot;OutlookDebugLog.h&quot;</span>
<a href="#l12.15"></a><span id="l12.15"> #include &quot;nsOutlookMail.h&quot;</span>
<a href="#l12.16"></a><span id="l12.16"> #include &quot;nsUnicharUtils.h&quot;</span>
<a href="#l12.17"></a><span id="l12.17"> #include &quot;nsMsgUtils.h&quot;</span>
<a href="#l12.18"></a><span id="l12.18"> #include &quot;nsIOutputStream.h&quot;</span>
<a href="#l12.19"></a><span id="l12.19"> #include &quot;nsMsgI18N.h&quot;</span>
<a href="#l12.20"></a><span id="l12.20"> #include &quot;nsNetUtil.h&quot;</span>
<a href="#l12.21"></a><span id="l12.21" class="difflineat">@@ -132,17 +131,17 @@ nsOutlookMail::nsOutlookMail()</span>
<a href="#l12.22"></a><span id="l12.22">   m_gotAddresses = PR_FALSE;</span>
<a href="#l12.23"></a><span id="l12.23">   m_gotFolders = PR_FALSE;</span>
<a href="#l12.24"></a><span id="l12.24">   m_haveMapi = CMapiApi::LoadMapi();</span>
<a href="#l12.25"></a><span id="l12.25">   m_lpMdb = NULL;</span>
<a href="#l12.26"></a><span id="l12.26"> }</span>
<a href="#l12.27"></a><span id="l12.27"> </span>
<a href="#l12.28"></a><span id="l12.28"> nsOutlookMail::~nsOutlookMail()</span>
<a href="#l12.29"></a><span id="l12.29"> {</span>
<a href="#l12.30"></a><span id="l12.30" class="difflineminus">-  EmptyAttachments();</span>
<a href="#l12.31"></a><span id="l12.31" class="difflineplus">+//  EmptyAttachments();</span>
<a href="#l12.32"></a><span id="l12.32"> }</span>
<a href="#l12.33"></a><span id="l12.33"> </span>
<a href="#l12.34"></a><span id="l12.34"> nsresult nsOutlookMail::GetMailFolders( nsISupportsArray **pArray)</span>
<a href="#l12.35"></a><span id="l12.35"> {</span>
<a href="#l12.36"></a><span id="l12.36">   if (!m_haveMapi) {</span>
<a href="#l12.37"></a><span id="l12.37">     IMPORT_LOG0( &quot;GetMailFolders called before Mapi is initialized\n&quot;);</span>
<a href="#l12.38"></a><span id="l12.38">     return( NS_ERROR_FAILURE);</span>
<a href="#l12.39"></a><span id="l12.39">   }</span>
<a href="#l12.40"></a><span id="l12.40" class="difflineat">@@ -344,45 +343,34 @@ void nsOutlookMail::OpenMessageStore( CM</span>
<a href="#l12.41"></a><span id="l12.41">       }</span>
<a href="#l12.42"></a><span id="l12.42">     }</span>
<a href="#l12.43"></a><span id="l12.43">     else {</span>
<a href="#l12.44"></a><span id="l12.44">       IMPORT_LOG0( &quot;*** Error importing a folder without a valid message store\n&quot;);</span>
<a href="#l12.45"></a><span id="l12.45">     }</span>
<a href="#l12.46"></a><span id="l12.46">   }</span>
<a href="#l12.47"></a><span id="l12.47"> }</span>
<a href="#l12.48"></a><span id="l12.48"> </span>
<a href="#l12.49"></a><span id="l12.49" class="difflineminus">-void nsOutlookMail::SetDefaultContentType(CMapiMessage &amp;msg, nsCString &amp;cType)</span>
<a href="#l12.50"></a><span id="l12.50" class="difflineminus">-{</span>
<a href="#l12.51"></a><span id="l12.51" class="difflineminus">-  cType.Truncate();</span>
<a href="#l12.52"></a><span id="l12.52" class="difflineminus">-</span>
<a href="#l12.53"></a><span id="l12.53" class="difflineminus">-  // MAPI doesn't seem to return the entire body data (ie, multiple parts) for</span>
<a href="#l12.54"></a><span id="l12.54" class="difflineminus">-  // content type &quot;multipart/alternative&quot;, instead it only returns the body data</span>
<a href="#l12.55"></a><span id="l12.55" class="difflineminus">-  // for a particular part. For this reason we'll need to set the content type</span>
<a href="#l12.56"></a><span id="l12.56" class="difflineminus">-  // here. Same thing when conten type is not being set at all.</span>
<a href="#l12.57"></a><span id="l12.57" class="difflineminus">-  if (msg.GetMimeContentLen())</span>
<a href="#l12.58"></a><span id="l12.58" class="difflineminus">-  {</span>
<a href="#l12.59"></a><span id="l12.59" class="difflineminus">-    // If content type is not multipart/alternative or mixed or related, return.</span>
<a href="#l12.60"></a><span id="l12.60" class="difflineminus">-    // for a multipart alternative with attachments, we get multipart mixed!</span>
<a href="#l12.61"></a><span id="l12.61" class="difflineminus">-    if (PL_strcasecmp(msg.GetMimeContent(), &quot;multipart/alternative&quot;)</span>
<a href="#l12.62"></a><span id="l12.62" class="difflineminus">-      &amp;&amp; PL_strcasecmp(msg.GetMimeContent(), &quot;multipart/mixed&quot;)</span>
<a href="#l12.63"></a><span id="l12.63" class="difflineminus">-      &amp;&amp; PL_strcasecmp(msg.GetMimeContent(), &quot;multipart/related&quot;))</span>
<a href="#l12.64"></a><span id="l12.64" class="difflineminus">-      return;</span>
<a href="#l12.65"></a><span id="l12.65" class="difflineminus">-</span>
<a href="#l12.66"></a><span id="l12.66" class="difflineminus">-    // For multipart/alternative, if no body or boundary,</span>
<a href="#l12.67"></a><span id="l12.67" class="difflineminus">-    // or boundary is found in body then return.</span>
<a href="#l12.68"></a><span id="l12.68" class="difflineminus">-    const char *body = msg.GetBody();</span>
<a href="#l12.69"></a><span id="l12.69" class="difflineminus">-    const char *boundary = msg.GetMimeBoundary();</span>
<a href="#l12.70"></a><span id="l12.70" class="difflineminus">-    if (!body || !boundary || strstr(body, boundary))</span>
<a href="#l12.71"></a><span id="l12.71" class="difflineminus">-      return;</span>
<a href="#l12.72"></a><span id="l12.72" class="difflineminus">-  }</span>
<a href="#l12.73"></a><span id="l12.73" class="difflineminus">-</span>
<a href="#l12.74"></a><span id="l12.74" class="difflineminus">-  // Now default the content type to text/html or text/plain</span>
<a href="#l12.75"></a><span id="l12.75" class="difflineminus">-  // depending whether or not the body data is html.</span>
<a href="#l12.76"></a><span id="l12.76" class="difflineminus">-  cType = msg.BodyIsHtml() ? &quot;text/html&quot; : &quot;text/plain&quot;;</span>
<a href="#l12.77"></a><span id="l12.77" class="difflineminus">-}</span>
<a href="#l12.78"></a><span id="l12.78" class="difflineplus">+// Roles and responsibilities:</span>
<a href="#l12.79"></a><span id="l12.79" class="difflineplus">+// nsOutlookMail</span>
<a href="#l12.80"></a><span id="l12.80" class="difflineplus">+//   - Connect to Outlook</span>
<a href="#l12.81"></a><span id="l12.81" class="difflineplus">+//   - Enumerate the mailboxes</span>
<a href="#l12.82"></a><span id="l12.82" class="difflineplus">+//   - Iterate the mailboxes</span>
<a href="#l12.83"></a><span id="l12.83" class="difflineplus">+//   - For each mail, create one nsOutlookCompose object</span>
<a href="#l12.84"></a><span id="l12.84" class="difflineplus">+//   - For each mail, create one CMapiMessage object</span>
<a href="#l12.85"></a><span id="l12.85" class="difflineplus">+//</span>
<a href="#l12.86"></a><span id="l12.86" class="difflineplus">+// nsOutlookCompose</span>
<a href="#l12.87"></a><span id="l12.87" class="difflineplus">+//   - Establich a TB session</span>
<a href="#l12.88"></a><span id="l12.88" class="difflineplus">+//   - Connect to all required services</span>
<a href="#l12.89"></a><span id="l12.89" class="difflineplus">+//   - Perform the composition of the RC822 document from the data gathered by CMapiMessage</span>
<a href="#l12.90"></a><span id="l12.90" class="difflineplus">+//   - Save the composed message to the TB mailbox</span>
<a href="#l12.91"></a><span id="l12.91" class="difflineplus">+//   - Ensure the proper cleanup</span>
<a href="#l12.92"></a><span id="l12.92" class="difflineplus">+//</span>
<a href="#l12.93"></a><span id="l12.93" class="difflineplus">+// CMapiMessage</span>
<a href="#l12.94"></a><span id="l12.94" class="difflineplus">+//   - Encapsulate the MAPI message interface</span>
<a href="#l12.95"></a><span id="l12.95" class="difflineplus">+//   - Gather the information required to (re)compose the message</span>
<a href="#l12.96"></a><span id="l12.96"> </span>
<a href="#l12.97"></a><span id="l12.97"> nsresult nsOutlookMail::ImportMailbox( PRUint32 *pDoneSoFar, PRBool *pAbort, PRInt32 index, const PRUnichar *pName, nsIFile *pDest, PRInt32 *pMsgCount)</span>
<a href="#l12.98"></a><span id="l12.98"> {</span>
<a href="#l12.99"></a><span id="l12.99">   if ((index &lt; 0) || (index &gt;= m_folderList.GetSize())) {</span>
<a href="#l12.100"></a><span id="l12.100">     IMPORT_LOG0( &quot;*** Bad mailbox identifier, unable to import\n&quot;);</span>
<a href="#l12.101"></a><span id="l12.101">     *pAbort = PR_TRUE;</span>
<a href="#l12.102"></a><span id="l12.102">     return( NS_ERROR_FAILURE);</span>
<a href="#l12.103"></a><span id="l12.103">   }</span>
<a href="#l12.104"></a><span id="l12.104" class="difflineat">@@ -400,35 +388,26 @@ nsresult nsOutlookMail::ImportMailbox( P</span>
<a href="#l12.105"></a><span id="l12.105">     return( NS_ERROR_FAILURE);</span>
<a href="#l12.106"></a><span id="l12.106">   }</span>
<a href="#l12.107"></a><span id="l12.107"> </span>
<a href="#l12.108"></a><span id="l12.108">   if (pFolder-&gt;IsStore())</span>
<a href="#l12.109"></a><span id="l12.109">     return( NS_OK);</span>
<a href="#l12.110"></a><span id="l12.110"> </span>
<a href="#l12.111"></a><span id="l12.111">   nsresult  rv;</span>
<a href="#l12.112"></a><span id="l12.112"> </span>
<a href="#l12.113"></a><span id="l12.113" class="difflineminus">-  nsOutlookCompose    compose;</span>
<a href="#l12.114"></a><span id="l12.114" class="difflineminus">-  SimpleBufferTonyRCopiedTwice      copy;</span>
<a href="#l12.115"></a><span id="l12.115" class="difflineminus">-</span>
<a href="#l12.116"></a><span id="l12.116" class="difflineminus">-  copy.Allocate( kCopyBufferSize);</span>
<a href="#l12.117"></a><span id="l12.117" class="difflineminus">-</span>
<a href="#l12.118"></a><span id="l12.118">   // now what?</span>
<a href="#l12.119"></a><span id="l12.119">   CMapiFolderContents    contents( m_lpMdb, pFolder-&gt;GetCBEntryID(), pFolder-&gt;GetEntryID());</span>
<a href="#l12.120"></a><span id="l12.120"> </span>
<a href="#l12.121"></a><span id="l12.121">   BOOL    done = FALSE;</span>
<a href="#l12.122"></a><span id="l12.122">   ULONG    cbEid;</span>
<a href="#l12.123"></a><span id="l12.123">   LPENTRYID  lpEid;</span>
<a href="#l12.124"></a><span id="l12.124">   ULONG    oType;</span>
<a href="#l12.125"></a><span id="l12.125">   LPMESSAGE  lpMsg = nsnull;</span>
<a href="#l12.126"></a><span id="l12.126" class="difflineminus">-  int      attachCount;</span>
<a href="#l12.127"></a><span id="l12.127">   ULONG    totalCount;</span>
<a href="#l12.128"></a><span id="l12.128">   PRFloat64  doneCalc;</span>
<a href="#l12.129"></a><span id="l12.129" class="difflineminus">-  nsCString  fromLine;</span>
<a href="#l12.130"></a><span id="l12.130" class="difflineminus">-  int      fromLen;</span>
<a href="#l12.131"></a><span id="l12.131" class="difflineminus">-  PRBool    lostAttach = PR_FALSE;</span>
<a href="#l12.132"></a><span id="l12.132"> </span>
<a href="#l12.133"></a><span id="l12.133">   nsCOMPtr&lt;nsIOutputStream&gt; destOutputStream;</span>
<a href="#l12.134"></a><span id="l12.134">   rv = MsgNewBufferedFileOutputStream(getter_AddRefs(destOutputStream), pDest, -1, 0600);</span>
<a href="#l12.135"></a><span id="l12.135">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l12.136"></a><span id="l12.136"> </span>
<a href="#l12.137"></a><span id="l12.137">   while (!done) {</span>
<a href="#l12.138"></a><span id="l12.138">     if (!contents.GetNext( &amp;cbEid, &amp;lpEid, &amp;oType, &amp;done)) {</span>
<a href="#l12.139"></a><span id="l12.139">       IMPORT_LOG1( &quot;*** Error iterating mailbox: %S\n&quot;, pName);</span>
<a href="#l12.140"></a><span id="l12.140" class="difflineat">@@ -446,386 +425,75 @@ nsresult nsOutlookMail::ImportMailbox( P</span>
<a href="#l12.141"></a><span id="l12.141">     }</span>
<a href="#l12.142"></a><span id="l12.142"> </span>
<a href="#l12.143"></a><span id="l12.143">     if (!done &amp;&amp; (oType == MAPI_MESSAGE)) {</span>
<a href="#l12.144"></a><span id="l12.144">       if (!m_mapi.OpenMdbEntry( m_lpMdb, cbEid, lpEid, (LPUNKNOWN *) &amp;lpMsg)) {</span>
<a href="#l12.145"></a><span id="l12.145">         IMPORT_LOG1( &quot;*** Error opening messages in mailbox: %S\n&quot;, pName);</span>
<a href="#l12.146"></a><span id="l12.146">         return( NS_ERROR_FAILURE);</span>
<a href="#l12.147"></a><span id="l12.147">       }</span>
<a href="#l12.148"></a><span id="l12.148"> </span>
<a href="#l12.149"></a><span id="l12.149" class="difflineminus">-      CMapiMessage  msg( lpMsg);</span>
<a href="#l12.150"></a><span id="l12.150" class="difflineminus">-</span>
<a href="#l12.151"></a><span id="l12.151" class="difflineminus">-      BOOL bResult = msg.FetchHeaders();</span>
<a href="#l12.152"></a><span id="l12.152" class="difflineminus">-      if (bResult)</span>
<a href="#l12.153"></a><span id="l12.153" class="difflineminus">-        bResult = msg.FetchBody();</span>
<a href="#l12.154"></a><span id="l12.154" class="difflineminus">-      if (bResult)</span>
<a href="#l12.155"></a><span id="l12.155" class="difflineminus">-        fromLine = msg.GetFromLine( fromLen);</span>
<a href="#l12.156"></a><span id="l12.156" class="difflineminus">-</span>
<a href="#l12.157"></a><span id="l12.157" class="difflineminus">-      attachCount = msg.CountAttachments();</span>
<a href="#l12.158"></a><span id="l12.158" class="difflineminus">-      BuildAttachments( msg, attachCount);</span>
<a href="#l12.159"></a><span id="l12.159" class="difflineminus">-</span>
<a href="#l12.160"></a><span id="l12.160" class="difflineminus">-      if (!bResult) {</span>
<a href="#l12.161"></a><span id="l12.161" class="difflineminus">-        IMPORT_LOG1( &quot;*** Error reading message from mailbox: %S\n&quot;, pName);</span>
<a href="#l12.162"></a><span id="l12.162" class="difflineminus">-        return( NS_ERROR_FAILURE);</span>
<a href="#l12.163"></a><span id="l12.163" class="difflineminus">-      }</span>
<a href="#l12.164"></a><span id="l12.164" class="difflineminus">-</span>
<a href="#l12.165"></a><span id="l12.165" class="difflineminus">-      // --------------------------------------------------------------</span>
<a href="#l12.166"></a><span id="l12.166" class="difflineminus">-      compose.SetBody( msg.GetBody());</span>
<a href="#l12.167"></a><span id="l12.167" class="difflineminus">-</span>
<a href="#l12.168"></a><span id="l12.168" class="difflineminus">-      // Need to convert all headers to unicode (for i18n).</span>
<a href="#l12.169"></a><span id="l12.169" class="difflineminus">-      // Init header here since 'composes' is used for all msgs.</span>
<a href="#l12.170"></a><span id="l12.170" class="difflineminus">-      compose.SetHeaders(&quot;&quot;);</span>
<a href="#l12.171"></a><span id="l12.171" class="difflineminus">-</span>
<a href="#l12.172"></a><span id="l12.172" class="difflineminus">-      nsAutoString newheader;</span>
<a href="#l12.173"></a><span id="l12.173" class="difflineminus">-      nsCAutoString tempCStr(msg.GetHeaders(), msg.GetHeaderLen());</span>
<a href="#l12.174"></a><span id="l12.174" class="difflineminus">-</span>
<a href="#l12.175"></a><span id="l12.175" class="difflineminus">-      rv = nsMsgI18NConvertToUnicode(nsMsgI18NFileSystemCharset(),</span>
<a href="#l12.176"></a><span id="l12.176" class="difflineminus">-        tempCStr, newheader);</span>
<a href="#l12.177"></a><span id="l12.177" class="difflineminus">-      NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to convert headers to utf8&quot;);</span>
<a href="#l12.178"></a><span id="l12.178" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l12.179"></a><span id="l12.179" class="difflineminus">-        compose.SetHeaders(NS_ConvertUTF16toUTF8(newheader).get());</span>
<a href="#l12.180"></a><span id="l12.180" class="difflineminus">-</span>
<a href="#l12.181"></a><span id="l12.181" class="difflineminus">-      compose.SetAttachments( &amp;m_attachments);</span>
<a href="#l12.182"></a><span id="l12.182" class="difflineminus">-</span>
<a href="#l12.183"></a><span id="l12.183">       // See if it's a drafts folder. Outlook doesn't allow drafts</span>
<a href="#l12.184"></a><span id="l12.184">       // folder to be configured so it's ok to hard code it here.</span>
<a href="#l12.185"></a><span id="l12.185">       nsAutoString folderName(pName);</span>
<a href="#l12.186"></a><span id="l12.186">       nsMsgDeliverMode mode = nsIMsgSend::nsMsgDeliverNow;</span>
<a href="#l12.187"></a><span id="l12.187">       mode = nsIMsgSend::nsMsgSaveAsDraft;</span>
<a href="#l12.188"></a><span id="l12.188">       if ( folderName.LowerCaseEqualsLiteral(&quot;drafts&quot;) )</span>
<a href="#l12.189"></a><span id="l12.189">         mode = nsIMsgSend::nsMsgSaveAsDraft;</span>
<a href="#l12.190"></a><span id="l12.190"> </span>
<a href="#l12.191"></a><span id="l12.191" class="difflineminus">-      /*</span>
<a href="#l12.192"></a><span id="l12.192" class="difflineminus">-      If I can't get no headers,</span>
<a href="#l12.193"></a><span id="l12.193" class="difflineminus">-      I can't get no satisfaction</span>
<a href="#l12.194"></a><span id="l12.194" class="difflineminus">-      */</span>
<a href="#l12.195"></a><span id="l12.195" class="difflineminus">-      if (msg.GetHeaderLen()) {</span>
<a href="#l12.196"></a><span id="l12.196" class="difflineminus">-        nsCAutoString cType;</span>
<a href="#l12.197"></a><span id="l12.197" class="difflineminus">-        SetDefaultContentType(msg, cType);</span>
<a href="#l12.198"></a><span id="l12.198" class="difflineminus">-        nsCOMPtr&lt;nsIFile&gt; compositionFile;</span>
<a href="#l12.199"></a><span id="l12.199" class="difflineminus">-        rv = compose.SendTheMessage(mode, cType, getter_AddRefs(compositionFile));</span>
<a href="#l12.200"></a><span id="l12.200" class="difflineminus">-        if (NS_SUCCEEDED( rv)) {</span>
<a href="#l12.201"></a><span id="l12.201" class="difflineminus">-          rv = compose.CopyComposedMessage( fromLine, compositionFile, destOutputStream, copy);</span>
<a href="#l12.202"></a><span id="l12.202" class="difflineminus">-          DeleteFile( compositionFile);</span>
<a href="#l12.203"></a><span id="l12.203" class="difflineminus">-          if (NS_FAILED( rv)) {</span>
<a href="#l12.204"></a><span id="l12.204" class="difflineminus">-            IMPORT_LOG0( &quot;*** Error copying composed message to destination mailbox\n&quot;);</span>
<a href="#l12.205"></a><span id="l12.205" class="difflineminus">-            return( rv);</span>
<a href="#l12.206"></a><span id="l12.206" class="difflineminus">-          }</span>
<a href="#l12.207"></a><span id="l12.207" class="difflineminus">-          (*pMsgCount)++;</span>
<a href="#l12.208"></a><span id="l12.208" class="difflineminus">-        }</span>
<a href="#l12.209"></a><span id="l12.209" class="difflineplus">+      rv = ImportMessage(lpMsg, destOutputStream, mode);</span>
<a href="#l12.210"></a><span id="l12.210" class="difflineplus">+      if (NS_SUCCEEDED( rv)) // No errors &amp; really imported</span>
<a href="#l12.211"></a><span id="l12.211" class="difflineplus">+        (*pMsgCount)++;</span>
<a href="#l12.212"></a><span id="l12.212" class="difflineplus">+      else {</span>
<a href="#l12.213"></a><span id="l12.213" class="difflineplus">+        IMPORT_LOG1( &quot;*** Error reading message from mailbox: %S\n&quot;, pName);</span>
<a href="#l12.214"></a><span id="l12.214">       }</span>
<a href="#l12.215"></a><span id="l12.215" class="difflineminus">-      else</span>
<a href="#l12.216"></a><span id="l12.216" class="difflineminus">-        rv = NS_OK;</span>
<a href="#l12.217"></a><span id="l12.217" class="difflineminus">-</span>
<a href="#l12.218"></a><span id="l12.218" class="difflineminus">-      // The following code to write msg to folder when compose.SendTheMessage() fails is commented</span>
<a href="#l12.219"></a><span id="l12.219" class="difflineminus">-      // out for now because the code doesn't handle attachments and users will complain anyway so</span>
<a href="#l12.220"></a><span id="l12.220" class="difflineminus">-      // until we fix the code to handle all kinds of msgs correctly we should not even make users</span>
<a href="#l12.221"></a><span id="l12.221" class="difflineminus">-      // think that all msgs are imported ok. This will also help users to identify which msgs are</span>
<a href="#l12.222"></a><span id="l12.222" class="difflineminus">-      // not imported and help to debug the problem.</span>
<a href="#l12.223"></a><span id="l12.223" class="difflineminus">-#if 0</span>
<a href="#l12.224"></a><span id="l12.224" class="difflineminus">-      if (NS_FAILED( rv)) {</span>
<a href="#l12.225"></a><span id="l12.225" class="difflineminus">-</span>
<a href="#l12.226"></a><span id="l12.226" class="difflineminus">-        /* NS_PRECONDITION( FALSE, &quot;Manual breakpoint&quot;); */</span>
<a href="#l12.227"></a><span id="l12.227" class="difflineminus">-</span>
<a href="#l12.228"></a><span id="l12.228" class="difflineminus">-        IMPORT_LOG1( &quot;Message #%d failed.\n&quot;, (int) (*pMsgCount));</span>
<a href="#l12.229"></a><span id="l12.229" class="difflineminus">-        DumpAttachments();</span>
<a href="#l12.230"></a><span id="l12.230" class="difflineminus">-</span>
<a href="#l12.231"></a><span id="l12.231" class="difflineminus">-        // --------------------------------------------------------------</span>
<a href="#l12.232"></a><span id="l12.232" class="difflineminus">-</span>
<a href="#l12.233"></a><span id="l12.233" class="difflineminus">-        // This is the OLD way of writing out the message which uses</span>
<a href="#l12.234"></a><span id="l12.234" class="difflineminus">-        // all kinds of crufty old crap for attachments.</span>
<a href="#l12.235"></a><span id="l12.235" class="difflineminus">-        // Since we now use Compose to send attachments,</span>
<a href="#l12.236"></a><span id="l12.236" class="difflineminus">-        // this is only fallback error stuff.</span>
<a href="#l12.237"></a><span id="l12.237" class="difflineminus">-</span>
<a href="#l12.238"></a><span id="l12.238" class="difflineminus">-        // Attachments get lost.</span>
<a href="#l12.239"></a><span id="l12.239" class="difflineminus">-</span>
<a href="#l12.240"></a><span id="l12.240" class="difflineminus">-        if (attachCount) {</span>
<a href="#l12.241"></a><span id="l12.241" class="difflineminus">-          lostAttach = PR_TRUE;</span>
<a href="#l12.242"></a><span id="l12.242" class="difflineminus">-          attachCount = 0;</span>
<a href="#l12.243"></a><span id="l12.243" class="difflineminus">-        }</span>
<a href="#l12.244"></a><span id="l12.244" class="difflineminus">-</span>
<a href="#l12.245"></a><span id="l12.245" class="difflineminus">-        BOOL needsTerminate = FALSE;</span>
<a href="#l12.246"></a><span id="l12.246" class="difflineminus">-        if (!WriteMessage( destOutputStream, &amp;msg, attachCount, &amp;needsTerminate)) {</span>
<a href="#l12.247"></a><span id="l12.247" class="difflineminus">-          IMPORT_LOG0( &quot;*** Error writing message\n&quot;);</span>
<a href="#l12.248"></a><span id="l12.248" class="difflineminus">-          *pAbort = PR_TRUE;</span>
<a href="#l12.249"></a><span id="l12.249" class="difflineminus">-          return( NS_ERROR_FAILURE);</span>
<a href="#l12.250"></a><span id="l12.250" class="difflineminus">-        }</span>
<a href="#l12.251"></a><span id="l12.251" class="difflineminus">-</span>
<a href="#l12.252"></a><span id="l12.252" class="difflineminus">-        if (needsTerminate) {</span>
<a href="#l12.253"></a><span id="l12.253" class="difflineminus">-          if (!WriteMimeBoundary( destOutputStream, &amp;msg, TRUE)) {</span>
<a href="#l12.254"></a><span id="l12.254" class="difflineminus">-            IMPORT_LOG0( &quot;*** Error writing message mime boundary\n&quot;);</span>
<a href="#l12.255"></a><span id="l12.255" class="difflineminus">-            *pAbort = PR_TRUE;</span>
<a href="#l12.256"></a><span id="l12.256" class="difflineminus">-            return( NS_ERROR_FAILURE);</span>
<a href="#l12.257"></a><span id="l12.257" class="difflineminus">-          }</span>
<a href="#l12.258"></a><span id="l12.258" class="difflineminus">-        }</span>
<a href="#l12.259"></a><span id="l12.259" class="difflineminus">-      }</span>
<a href="#l12.260"></a><span id="l12.260" class="difflineminus">-#endif</span>
<a href="#l12.261"></a><span id="l12.261" class="difflineminus">-</span>
<a href="#l12.262"></a><span id="l12.262" class="difflineminus">-      // Just for YUCKS, let's try an extra endline</span>
<a href="#l12.263"></a><span id="l12.263" class="difflineminus">-      WriteData( destOutputStream, &quot;\x0D\x0A&quot;, 2);</span>
<a href="#l12.264"></a><span id="l12.264">     }</span>
<a href="#l12.265"></a><span id="l12.265">   }</span>
<a href="#l12.266"></a><span id="l12.266"> </span>
<a href="#l12.267"></a><span id="l12.267">   return( NS_OK);</span>
<a href="#l12.268"></a><span id="l12.268"> }</span>
<a href="#l12.269"></a><span id="l12.269"> </span>
<a href="#l12.270"></a><span id="l12.270" class="difflineminus">-BOOL nsOutlookMail::WriteMessage( nsIOutputStream *pDest, CMapiMessage *pMsg, int&amp; attachCount, BOOL *pTerminate)</span>
<a href="#l12.271"></a><span id="l12.271" class="difflineplus">+nsresult nsOutlookMail::ImportMessage( LPMESSAGE lpMsg, nsIOutputStream *pDest, nsMsgDeliverMode mode)</span>
<a href="#l12.272"></a><span id="l12.272"> {</span>
<a href="#l12.273"></a><span id="l12.273" class="difflineminus">-  BOOL    bResult = TRUE;</span>
<a href="#l12.274"></a><span id="l12.274" class="difflineminus">-  const char *pData;</span>
<a href="#l12.275"></a><span id="l12.275" class="difflineminus">-  int      len;</span>
<a href="#l12.276"></a><span id="l12.276" class="difflineminus">-  BOOL    checkStart = FALSE;</span>
<a href="#l12.277"></a><span id="l12.277" class="difflineminus">-</span>
<a href="#l12.278"></a><span id="l12.278" class="difflineminus">-  *pTerminate = FALSE;</span>
<a href="#l12.279"></a><span id="l12.279" class="difflineminus">-</span>
<a href="#l12.280"></a><span id="l12.280" class="difflineminus">-  pData = pMsg-&gt;GetFromLine( len);</span>
<a href="#l12.281"></a><span id="l12.281" class="difflineminus">-  if (pData) {</span>
<a href="#l12.282"></a><span id="l12.282" class="difflineminus">-    bResult = WriteData( pDest, pData, len);</span>
<a href="#l12.283"></a><span id="l12.283" class="difflineminus">-    checkStart = TRUE;</span>
<a href="#l12.284"></a><span id="l12.284" class="difflineminus">-  }</span>
<a href="#l12.285"></a><span id="l12.285" class="difflineminus">-</span>
<a href="#l12.286"></a><span id="l12.286" class="difflineminus">-  nsCOMPtr&lt;nsIOutputStream&gt; outStream = pDest;</span>
<a href="#l12.287"></a><span id="l12.287" class="difflineminus">-</span>
<a href="#l12.288"></a><span id="l12.288" class="difflineminus">-  pData = pMsg-&gt;GetHeaders( len);</span>
<a href="#l12.289"></a><span id="l12.289" class="difflineminus">-  if (pData &amp;&amp; len) {</span>
<a href="#l12.290"></a><span id="l12.290" class="difflineminus">-    if (checkStart)</span>
<a href="#l12.291"></a><span id="l12.291" class="difflineminus">-      bResult = (EscapeFromSpaceLine(outStream, (char *)pData, pData+len) == NS_OK);</span>
<a href="#l12.292"></a><span id="l12.292" class="difflineminus">-    else</span>
<a href="#l12.293"></a><span id="l12.293" class="difflineminus">-      bResult = (EscapeFromSpaceLine(outStream, (char *)(pData+1), pData+len-1) == NS_OK);</span>
<a href="#l12.294"></a><span id="l12.294" class="difflineminus">-  }</span>
<a href="#l12.295"></a><span id="l12.295" class="difflineminus">-</span>
<a href="#l12.296"></a><span id="l12.296" class="difflineminus">-  // Do we need to add any mime headers???</span>
<a href="#l12.297"></a><span id="l12.297" class="difflineminus">-  //  Is the message multipart?</span>
<a href="#l12.298"></a><span id="l12.298" class="difflineminus">-  //    If so, then we are OK, but need to make sure we add mime</span>
<a href="#l12.299"></a><span id="l12.299" class="difflineminus">-  //    header info to the body of the message</span>
<a href="#l12.300"></a><span id="l12.300" class="difflineminus">-  //  If not AND we have attachments, then we need to add mime headers.</span>
<a href="#l12.301"></a><span id="l12.301" class="difflineplus">+  CMapiMessage  msg( lpMsg);</span>
<a href="#l12.302"></a><span id="l12.302" class="difflineplus">+  // If we wanted to skip messages that were downloaded in header only mode, we</span>
<a href="#l12.303"></a><span id="l12.303" class="difflineplus">+  // would return NS_ERROR_FAILURE if !msg.FullMessageDownloaded. However, we</span>
<a href="#l12.304"></a><span id="l12.304" class="difflineplus">+  // don't do this because it may cause seemingly wrong import results.</span>
<a href="#l12.305"></a><span id="l12.305" class="difflineplus">+  // A user will get less mails in his imported folder than were in the original folder,</span>
<a href="#l12.306"></a><span id="l12.306" class="difflineplus">+  // and this may make user feel like TB import is bad.</span>
<a href="#l12.307"></a><span id="l12.307" class="difflineplus">+  // In reality, the skipped messages are those that have not been downloaded yet, because</span>
<a href="#l12.308"></a><span id="l12.308" class="difflineplus">+  // they were downloaded in the &quot;headers-only&quot; mode. This is different from the case when</span>
<a href="#l12.309"></a><span id="l12.309" class="difflineplus">+  // the message is downloaded completely, but consists only of headers - in this case</span>
<a href="#l12.310"></a><span id="l12.310" class="difflineplus">+  // the message will be imported anyway.</span>
<a href="#l12.311"></a><span id="l12.311"> </span>
<a href="#l12.312"></a><span id="l12.312" class="difflineminus">-  BOOL needsMimeHeaders = pMsg-&gt;IsMultipart();</span>
<a href="#l12.313"></a><span id="l12.313" class="difflineminus">-  if (!needsMimeHeaders &amp;&amp; attachCount) {</span>
<a href="#l12.314"></a><span id="l12.314" class="difflineminus">-    // if the message already has mime headers</span>
<a href="#l12.315"></a><span id="l12.315" class="difflineminus">-    // that aren't multipart then we are in trouble!</span>
<a href="#l12.316"></a><span id="l12.316" class="difflineminus">-    // in that case, ditch the attachments...  alternatively, we could</span>
<a href="#l12.317"></a><span id="l12.317" class="difflineminus">-    // massage the headers and replace the existing mime headers</span>
<a href="#l12.318"></a><span id="l12.318" class="difflineminus">-    // with our own but I think this case is likely not to occur.</span>
<a href="#l12.319"></a><span id="l12.319" class="difflineminus">-    if (pMsg-&gt;HasContentHeader())</span>
<a href="#l12.320"></a><span id="l12.320" class="difflineminus">-      attachCount = 0;</span>
<a href="#l12.321"></a><span id="l12.321" class="difflineminus">-    else {</span>
<a href="#l12.322"></a><span id="l12.322" class="difflineminus">-      if (bResult)</span>
<a href="#l12.323"></a><span id="l12.323" class="difflineminus">-        bResult = WriteMimeMsgHeader( pDest, pMsg);</span>
<a href="#l12.324"></a><span id="l12.324" class="difflineminus">-      needsMimeHeaders = TRUE;</span>
<a href="#l12.325"></a><span id="l12.325" class="difflineminus">-    }</span>
<a href="#l12.326"></a><span id="l12.326" class="difflineminus">-  }</span>
<a href="#l12.327"></a><span id="l12.327" class="difflineminus">-</span>
<a href="#l12.328"></a><span id="l12.328" class="difflineminus">-  if (bResult)</span>
<a href="#l12.329"></a><span id="l12.329" class="difflineminus">-    bResult = WriteStr( pDest, &quot;\x0D\x0A&quot;);</span>
<a href="#l12.330"></a><span id="l12.330" class="difflineplus">+  if (!msg.ValidState())</span>
<a href="#l12.331"></a><span id="l12.331" class="difflineplus">+    return NS_ERROR_FAILURE;</span>
<a href="#l12.332"></a><span id="l12.332"> </span>
<a href="#l12.333"></a><span id="l12.333" class="difflineminus">-  if (needsMimeHeaders) {</span>
<a href="#l12.334"></a><span id="l12.334" class="difflineminus">-    if (bResult)</span>
<a href="#l12.335"></a><span id="l12.335" class="difflineminus">-      bResult = WriteStr( pDest, &quot;This is a MIME formatted message.\x0D\x0A&quot;);</span>
<a href="#l12.336"></a><span id="l12.336" class="difflineminus">-    if (bResult)</span>
<a href="#l12.337"></a><span id="l12.337" class="difflineminus">-      bResult = WriteStr( pDest, &quot;\x0D\x0A&quot;);</span>
<a href="#l12.338"></a><span id="l12.338" class="difflineminus">-    if (bResult)</span>
<a href="#l12.339"></a><span id="l12.339" class="difflineminus">-      bResult = WriteMimeBoundary( pDest, pMsg, FALSE);</span>
<a href="#l12.340"></a><span id="l12.340" class="difflineminus">-    if (pMsg-&gt;BodyIsHtml()) {</span>
<a href="#l12.341"></a><span id="l12.341" class="difflineminus">-      if (bResult)</span>
<a href="#l12.342"></a><span id="l12.342" class="difflineminus">-        bResult = WriteStr( pDest, &quot;Content-type: text/html\x0D\x0A&quot;);</span>
<a href="#l12.343"></a><span id="l12.343" class="difflineminus">-    }</span>
<a href="#l12.344"></a><span id="l12.344" class="difflineminus">-    else {</span>
<a href="#l12.345"></a><span id="l12.345" class="difflineminus">-      if (bResult)</span>
<a href="#l12.346"></a><span id="l12.346" class="difflineminus">-        bResult = WriteStr( pDest, &quot;Content-type: text/plain\x0D\x0A&quot;);</span>
<a href="#l12.347"></a><span id="l12.347" class="difflineminus">-    }</span>
<a href="#l12.348"></a><span id="l12.348" class="difflineplus">+  // I have to create a composer for each message, since it turns out that if we create</span>
<a href="#l12.349"></a><span id="l12.349" class="difflineplus">+  // one composer for several messages, the Send Proxy object that is shared between those messages</span>
<a href="#l12.350"></a><span id="l12.350" class="difflineplus">+  // isn't reset properly (at least in the current implementation), which leads to crash.</span>
<a href="#l12.351"></a><span id="l12.351" class="difflineplus">+  // If there's a proper way to reinitialize the Send Proxy object,</span>
<a href="#l12.352"></a><span id="l12.352" class="difflineplus">+  // then we could slightly optimize the send process.</span>
<a href="#l12.353"></a><span id="l12.353" class="difflineplus">+  nsOutlookCompose compose;</span>
<a href="#l12.354"></a><span id="l12.354" class="difflineplus">+  nsresult rv = compose.ProcessMessage(mode, msg, pDest);</span>
<a href="#l12.355"></a><span id="l12.355"> </span>
<a href="#l12.356"></a><span id="l12.356" class="difflineminus">-    if (bResult)</span>
<a href="#l12.357"></a><span id="l12.357" class="difflineminus">-      bResult = WriteStr( pDest, &quot;\x0D\x0A&quot;);</span>
<a href="#l12.358"></a><span id="l12.358" class="difflineminus">-  }</span>
<a href="#l12.359"></a><span id="l12.359" class="difflineplus">+  // Just for YUCKS, let's try an extra endline</span>
<a href="#l12.360"></a><span id="l12.360" class="difflineplus">+  WriteData( pDest, &quot;\x0D\x0A&quot;, 2);</span>
<a href="#l12.361"></a><span id="l12.361"> </span>
<a href="#l12.362"></a><span id="l12.362" class="difflineminus">-  pData = pMsg-&gt;GetBody( len);</span>
<a href="#l12.363"></a><span id="l12.363" class="difflineminus">-  if (pData &amp;&amp; len) {</span>
<a href="#l12.364"></a><span id="l12.364" class="difflineminus">-    if (bResult)</span>
<a href="#l12.365"></a><span id="l12.365" class="difflineminus">-      bResult = (EscapeFromSpaceLine(outStream, (char *)pData, pData+len) == NS_OK);</span>
<a href="#l12.366"></a><span id="l12.366" class="difflineminus">-    if ((len &lt; 2) || (pData[len - 1] != 0x0A) || (pData[len - 2] != 0x0D))</span>
<a href="#l12.367"></a><span id="l12.367" class="difflineminus">-      bResult = WriteStr( pDest, &quot;\x0D\x0A&quot;);</span>
<a href="#l12.368"></a><span id="l12.368" class="difflineminus">-  }</span>
<a href="#l12.369"></a><span id="l12.369" class="difflineminus">-</span>
<a href="#l12.370"></a><span id="l12.370" class="difflineminus">-  *pTerminate = needsMimeHeaders;</span>
<a href="#l12.371"></a><span id="l12.371" class="difflineminus">-</span>
<a href="#l12.372"></a><span id="l12.372" class="difflineminus">-  return( bResult);</span>
<a href="#l12.373"></a><span id="l12.373" class="difflineplus">+  return rv;</span>
<a href="#l12.374"></a><span id="l12.374"> }</span>
<a href="#l12.375"></a><span id="l12.375"> </span>
<a href="#l12.376"></a><span id="l12.376"> BOOL nsOutlookMail::WriteData( nsIOutputStream *pDest, const char *pData, PRInt32 len)</span>
<a href="#l12.377"></a><span id="l12.377"> {</span>
<a href="#l12.378"></a><span id="l12.378">   PRUint32    written;</span>
<a href="#l12.379"></a><span id="l12.379">   nsresult rv = pDest-&gt;Write( pData, len, &amp;written);</span>
<a href="#l12.380"></a><span id="l12.380">   if (NS_FAILED( rv) || (written != len))</span>
<a href="#l12.381"></a><span id="l12.381">     return( FALSE);</span>
<a href="#l12.382"></a><span id="l12.382">   return( TRUE);</span>
<a href="#l12.383"></a><span id="l12.383"> }</span>
<a href="#l12.384"></a><span id="l12.384"> </span>
<a href="#l12.385"></a><span id="l12.385" class="difflineminus">-BOOL nsOutlookMail::WriteStr( nsIOutputStream *pDest, const char *pStr)</span>
<a href="#l12.386"></a><span id="l12.386" class="difflineminus">-{</span>
<a href="#l12.387"></a><span id="l12.387" class="difflineminus">-  PRUint32 written;</span>
<a href="#l12.388"></a><span id="l12.388" class="difflineminus">-  PRInt32    len = strlen( pStr);</span>
<a href="#l12.389"></a><span id="l12.389" class="difflineminus">-</span>
<a href="#l12.390"></a><span id="l12.390" class="difflineminus">-  nsresult rv = pDest-&gt;Write( pStr, len, &amp;written);</span>
<a href="#l12.391"></a><span id="l12.391" class="difflineminus">-  if (NS_FAILED( rv) || (written != len))</span>
<a href="#l12.392"></a><span id="l12.392" class="difflineminus">-    return( FALSE);</span>
<a href="#l12.393"></a><span id="l12.393" class="difflineminus">-  return( TRUE);</span>
<a href="#l12.394"></a><span id="l12.394" class="difflineminus">-}</span>
<a href="#l12.395"></a><span id="l12.395" class="difflineminus">-</span>
<a href="#l12.396"></a><span id="l12.396" class="difflineminus">-BOOL nsOutlookMail::WriteMimeMsgHeader( nsIOutputStream *pDest, CMapiMessage *pMsg)</span>
<a href="#l12.397"></a><span id="l12.397" class="difflineminus">-{</span>
<a href="#l12.398"></a><span id="l12.398" class="difflineminus">-  BOOL  bResult = TRUE;</span>
<a href="#l12.399"></a><span id="l12.399" class="difflineminus">-  if (!pMsg-&gt;HasMimeVersion())</span>
<a href="#l12.400"></a><span id="l12.400" class="difflineminus">-    bResult = WriteStr( pDest, &quot;MIME-Version: 1.0\x0D\x0A&quot;);</span>
<a href="#l12.401"></a><span id="l12.401" class="difflineminus">-  pMsg-&gt;GenerateBoundary();</span>
<a href="#l12.402"></a><span id="l12.402" class="difflineminus">-  if (bResult)</span>
<a href="#l12.403"></a><span id="l12.403" class="difflineminus">-    bResult = WriteStr( pDest, &quot;Content-type: multipart/mixed; boundary=\&quot;&quot;);</span>
<a href="#l12.404"></a><span id="l12.404" class="difflineminus">-  if (bResult)</span>
<a href="#l12.405"></a><span id="l12.405" class="difflineminus">-    bResult = WriteStr( pDest, pMsg-&gt;GetMimeBoundary());</span>
<a href="#l12.406"></a><span id="l12.406" class="difflineminus">-  if (bResult)</span>
<a href="#l12.407"></a><span id="l12.407" class="difflineminus">-    bResult = WriteStr( pDest, &quot;\&quot;\x0D\x0A&quot;);</span>
<a href="#l12.408"></a><span id="l12.408" class="difflineminus">-</span>
<a href="#l12.409"></a><span id="l12.409" class="difflineminus">-  return( bResult);</span>
<a href="#l12.410"></a><span id="l12.410" class="difflineminus">-}</span>
<a href="#l12.411"></a><span id="l12.411" class="difflineminus">-</span>
<a href="#l12.412"></a><span id="l12.412" class="difflineminus">-BOOL nsOutlookMail::WriteMimeBoundary( nsIOutputStream *pDest, CMapiMessage *pMsg, BOOL terminate)</span>
<a href="#l12.413"></a><span id="l12.413" class="difflineminus">-{</span>
<a href="#l12.414"></a><span id="l12.414" class="difflineminus">-  BOOL  bResult = WriteStr( pDest, &quot;--&quot;);</span>
<a href="#l12.415"></a><span id="l12.415" class="difflineminus">-  if (bResult)</span>
<a href="#l12.416"></a><span id="l12.416" class="difflineminus">-    bResult = WriteStr( pDest, pMsg-&gt;GetMimeBoundary());</span>
<a href="#l12.417"></a><span id="l12.417" class="difflineminus">-  if (terminate &amp;&amp; bResult)</span>
<a href="#l12.418"></a><span id="l12.418" class="difflineminus">-    bResult = WriteStr( pDest, &quot;--&quot;);</span>
<a href="#l12.419"></a><span id="l12.419" class="difflineminus">-  if (bResult)</span>
<a href="#l12.420"></a><span id="l12.420" class="difflineminus">-    bResult = WriteStr( pDest, &quot;\x0D\x0A&quot;);</span>
<a href="#l12.421"></a><span id="l12.421" class="difflineminus">-</span>
<a href="#l12.422"></a><span id="l12.422" class="difflineminus">-  return( bResult);</span>
<a href="#l12.423"></a><span id="l12.423" class="difflineminus">-}</span>
<a href="#l12.424"></a><span id="l12.424" class="difflineminus">-</span>
<a href="#l12.425"></a><span id="l12.425" class="difflineminus">-nsresult nsOutlookMail::DeleteFile( nsIFile *pFile)</span>
<a href="#l12.426"></a><span id="l12.426" class="difflineminus">-{</span>
<a href="#l12.427"></a><span id="l12.427" class="difflineminus">-  return pFile-&gt;Remove(PR_FALSE);</span>
<a href="#l12.428"></a><span id="l12.428" class="difflineminus">-}</span>
<a href="#l12.429"></a><span id="l12.429" class="difflineminus">-</span>
<a href="#l12.430"></a><span id="l12.430" class="difflineminus">-void nsOutlookMail::EmptyAttachments( void)</span>
<a href="#l12.431"></a><span id="l12.431" class="difflineminus">-{</span>
<a href="#l12.432"></a><span id="l12.432" class="difflineminus">-  PRBool  exists;</span>
<a href="#l12.433"></a><span id="l12.433" class="difflineminus">-  PRBool  isFile;</span>
<a href="#l12.434"></a><span id="l12.434" class="difflineminus">-  PRInt32 max = m_attachments.Count();</span>
<a href="#l12.435"></a><span id="l12.435" class="difflineminus">-  OutlookAttachment *  pAttach;</span>
<a href="#l12.436"></a><span id="l12.436" class="difflineminus">-  for (PRInt32 i = 0; i &lt; max; i++) {</span>
<a href="#l12.437"></a><span id="l12.437" class="difflineminus">-    pAttach = (OutlookAttachment *) m_attachments.ElementAt( i);</span>
<a href="#l12.438"></a><span id="l12.438" class="difflineminus">-    if (pAttach) {</span>
<a href="#l12.439"></a><span id="l12.439" class="difflineminus">-      if (pAttach-&gt;pAttachment) {</span>
<a href="#l12.440"></a><span id="l12.440" class="difflineminus">-        exists = PR_FALSE;</span>
<a href="#l12.441"></a><span id="l12.441" class="difflineminus">-        isFile = PR_FALSE;</span>
<a href="#l12.442"></a><span id="l12.442" class="difflineminus">-        pAttach-&gt;pAttachment-&gt;Exists( &amp;exists);</span>
<a href="#l12.443"></a><span id="l12.443" class="difflineminus">-        if (exists)</span>
<a href="#l12.444"></a><span id="l12.444" class="difflineminus">-          pAttach-&gt;pAttachment-&gt;IsFile( &amp;isFile);</span>
<a href="#l12.445"></a><span id="l12.445" class="difflineminus">-        if (exists &amp;&amp; isFile)</span>
<a href="#l12.446"></a><span id="l12.446" class="difflineminus">-          DeleteFile( pAttach-&gt;pAttachment);</span>
<a href="#l12.447"></a><span id="l12.447" class="difflineminus">-        pAttach-&gt;pAttachment = nsnull;</span>
<a href="#l12.448"></a><span id="l12.448" class="difflineminus">-      }</span>
<a href="#l12.449"></a><span id="l12.449" class="difflineminus">-      NS_Free( pAttach-&gt;description);</span>
<a href="#l12.450"></a><span id="l12.450" class="difflineminus">-      NS_Free( pAttach-&gt;mimeType);</span>
<a href="#l12.451"></a><span id="l12.451" class="difflineminus">-      delete pAttach;</span>
<a href="#l12.452"></a><span id="l12.452" class="difflineminus">-    }</span>
<a href="#l12.453"></a><span id="l12.453" class="difflineminus">-  }</span>
<a href="#l12.454"></a><span id="l12.454" class="difflineminus">-</span>
<a href="#l12.455"></a><span id="l12.455" class="difflineminus">-  m_attachments.Clear();</span>
<a href="#l12.456"></a><span id="l12.456" class="difflineminus">-}</span>
<a href="#l12.457"></a><span id="l12.457" class="difflineminus">-</span>
<a href="#l12.458"></a><span id="l12.458" class="difflineminus">-void nsOutlookMail::BuildAttachments( CMapiMessage&amp; msg, int count)</span>
<a href="#l12.459"></a><span id="l12.459" class="difflineminus">-{</span>
<a href="#l12.460"></a><span id="l12.460" class="difflineminus">-  EmptyAttachments();</span>
<a href="#l12.461"></a><span id="l12.461" class="difflineminus">-  if (count) {</span>
<a href="#l12.462"></a><span id="l12.462" class="difflineminus">-    nsresult rv;</span>
<a href="#l12.463"></a><span id="l12.463" class="difflineminus">-    nsCOMPtr &lt;nsILocalFile&gt;  pFile;</span>
<a href="#l12.464"></a><span id="l12.464" class="difflineminus">-    for (int i = 0; i &lt; count; i++) {</span>
<a href="#l12.465"></a><span id="l12.465" class="difflineminus">-      if (!msg.GetAttachmentInfo( i)) {</span>
<a href="#l12.466"></a><span id="l12.466" class="difflineminus">-        IMPORT_LOG1( &quot;*** Error getting attachment info for #%d\n&quot;, i);</span>
<a href="#l12.467"></a><span id="l12.467" class="difflineminus">-      }</span>
<a href="#l12.468"></a><span id="l12.468" class="difflineminus">-</span>
<a href="#l12.469"></a><span id="l12.469" class="difflineminus">-      pFile = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID, &amp;rv);</span>
<a href="#l12.470"></a><span id="l12.470" class="difflineminus">-      if (NS_FAILED( rv) || !pFile) {</span>
<a href="#l12.471"></a><span id="l12.471" class="difflineminus">-        IMPORT_LOG0( &quot;*** Error creating file spec for attachment\n&quot;);</span>
<a href="#l12.472"></a><span id="l12.472" class="difflineminus">-      }</span>
<a href="#l12.473"></a><span id="l12.473" class="difflineminus">-      else {</span>
<a href="#l12.474"></a><span id="l12.474" class="difflineminus">-        if (msg.GetAttachFileLoc( pFile)) {</span>
<a href="#l12.475"></a><span id="l12.475" class="difflineminus">-          PRBool isFile = PR_FALSE;</span>
<a href="#l12.476"></a><span id="l12.476" class="difflineminus">-          PRBool exists = PR_FALSE;</span>
<a href="#l12.477"></a><span id="l12.477" class="difflineminus">-          pFile-&gt;Exists( &amp;exists);</span>
<a href="#l12.478"></a><span id="l12.478" class="difflineminus">-          pFile-&gt;IsFile( &amp;isFile);</span>
<a href="#l12.479"></a><span id="l12.479" class="difflineminus">-</span>
<a href="#l12.480"></a><span id="l12.480" class="difflineminus">-          if (!exists || !isFile) {</span>
<a href="#l12.481"></a><span id="l12.481" class="difflineminus">-            IMPORT_LOG0( &quot;Attachment file does not exist\n&quot;);</span>
<a href="#l12.482"></a><span id="l12.482" class="difflineminus">-          }</span>
<a href="#l12.483"></a><span id="l12.483" class="difflineminus">-          else {</span>
<a href="#l12.484"></a><span id="l12.484" class="difflineminus">-            // We have a file spec, now get the other info</span>
<a href="#l12.485"></a><span id="l12.485" class="difflineminus">-            OutlookAttachment *a = new OutlookAttachment;</span>
<a href="#l12.486"></a><span id="l12.486" class="difflineminus">-            a-&gt;mimeType = strdup( msg.GetMimeType());</span>
<a href="#l12.487"></a><span id="l12.487" class="difflineminus">-            // Init description here so that we cacn tell</span>
<a href="#l12.488"></a><span id="l12.488" class="difflineminus">-            // if defaul tattacchment is needed later.</span>
<a href="#l12.489"></a><span id="l12.489" class="difflineminus">-            a-&gt;description = nsnull;</span>
<a href="#l12.490"></a><span id="l12.490" class="difflineminus">-</span>
<a href="#l12.491"></a><span id="l12.491" class="difflineminus">-            const char *fileName = msg.GetFileName();</span>
<a href="#l12.492"></a><span id="l12.492" class="difflineminus">-            if (fileName &amp;&amp; fileName[0]) {</span>
<a href="#l12.493"></a><span id="l12.493" class="difflineminus">-              // Convert description to unicode.</span>
<a href="#l12.494"></a><span id="l12.494" class="difflineminus">-              nsAutoString description;</span>
<a href="#l12.495"></a><span id="l12.495" class="difflineminus">-              rv = nsMsgI18NConvertToUnicode(nsMsgI18NFileSystemCharset(),</span>
<a href="#l12.496"></a><span id="l12.496" class="difflineminus">-                nsDependentCString(fileName), description);</span>
<a href="#l12.497"></a><span id="l12.497" class="difflineminus">-              NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to convert system string to unicode&quot;);</span>
<a href="#l12.498"></a><span id="l12.498" class="difflineminus">-              if (NS_SUCCEEDED(rv))</span>
<a href="#l12.499"></a><span id="l12.499" class="difflineminus">-                a-&gt;description = ToNewUTF8String(description);</span>
<a href="#l12.500"></a><span id="l12.500" class="difflineminus">-            }</span>
<a href="#l12.501"></a><span id="l12.501" class="difflineminus">-</span>
<a href="#l12.502"></a><span id="l12.502" class="difflineminus">-            // If no description use &quot;Attachment i&quot; format.</span>
<a href="#l12.503"></a><span id="l12.503" class="difflineminus">-            if (!a-&gt;description) {</span>
<a href="#l12.504"></a><span id="l12.504" class="difflineminus">-              nsCAutoString  str(&quot;Attachment &quot;);</span>
<a href="#l12.505"></a><span id="l12.505" class="difflineminus">-              str.AppendInt( (PRInt32) i);</span>
<a href="#l12.506"></a><span id="l12.506" class="difflineminus">-              a-&gt;description = ToNewCString( str);</span>
<a href="#l12.507"></a><span id="l12.507" class="difflineminus">-            }</span>
<a href="#l12.508"></a><span id="l12.508" class="difflineminus">-</span>
<a href="#l12.509"></a><span id="l12.509" class="difflineminus">-            a-&gt;pAttachment = pFile;</span>
<a href="#l12.510"></a><span id="l12.510" class="difflineminus">-            m_attachments.AppendElement( a);</span>
<a href="#l12.511"></a><span id="l12.511" class="difflineminus">-          }</span>
<a href="#l12.512"></a><span id="l12.512" class="difflineminus">-        }</span>
<a href="#l12.513"></a><span id="l12.513" class="difflineminus">-      }</span>
<a href="#l12.514"></a><span id="l12.514" class="difflineminus">-    }</span>
<a href="#l12.515"></a><span id="l12.515" class="difflineminus">-  }</span>
<a href="#l12.516"></a><span id="l12.516" class="difflineminus">-}</span>
<a href="#l12.517"></a><span id="l12.517" class="difflineminus">-</span>
<a href="#l12.518"></a><span id="l12.518" class="difflineminus">-void nsOutlookMail::DumpAttachments( void)</span>
<a href="#l12.519"></a><span id="l12.519" class="difflineminus">-{</span>
<a href="#l12.520"></a><span id="l12.520" class="difflineminus">-#ifdef IMPORT_DEBUG</span>
<a href="#l12.521"></a><span id="l12.521" class="difflineminus">-  PRInt32    count = 0;</span>
<a href="#l12.522"></a><span id="l12.522" class="difflineminus">-  count = m_attachments.Count();</span>
<a href="#l12.523"></a><span id="l12.523" class="difflineminus">-  if (!count) {</span>
<a href="#l12.524"></a><span id="l12.524" class="difflineminus">-    IMPORT_LOG0( &quot;*** No Attachments\n&quot;);</span>
<a href="#l12.525"></a><span id="l12.525" class="difflineminus">-    return;</span>
<a href="#l12.526"></a><span id="l12.526" class="difflineminus">-  }</span>
<a href="#l12.527"></a><span id="l12.527" class="difflineminus">-  IMPORT_LOG1( &quot;#%d attachments\n&quot;, (int) count);</span>
<a href="#l12.528"></a><span id="l12.528" class="difflineminus">-</span>
<a href="#l12.529"></a><span id="l12.529" class="difflineminus">-  OutlookAttachment *  pAttach;</span>
<a href="#l12.530"></a><span id="l12.530" class="difflineminus">-</span>
<a href="#l12.531"></a><span id="l12.531" class="difflineminus">-  for (PRInt32 i = 0; i &lt; count; i++) {</span>
<a href="#l12.532"></a><span id="l12.532" class="difflineminus">-    IMPORT_LOG1( &quot;\tAttachment #%d ---------------\n&quot;, (int) i);</span>
<a href="#l12.533"></a><span id="l12.533" class="difflineminus">-    pAttach = (OutlookAttachment *) m_attachments.ElementAt( i);</span>
<a href="#l12.534"></a><span id="l12.534" class="difflineminus">-    if (pAttach-&gt;mimeType)</span>
<a href="#l12.535"></a><span id="l12.535" class="difflineminus">-      IMPORT_LOG1( &quot;\t\tMime type: %s\n&quot;, pAttach-&gt;mimeType);</span>
<a href="#l12.536"></a><span id="l12.536" class="difflineminus">-    if (pAttach-&gt;description)</span>
<a href="#l12.537"></a><span id="l12.537" class="difflineminus">-      IMPORT_LOG1( &quot;\t\tDescription: %s\n&quot;, pAttach-&gt;description);</span>
<a href="#l12.538"></a><span id="l12.538" class="difflineminus">-    if (pAttach-&gt;pAttachment) {</span>
<a href="#l12.539"></a><span id="l12.539" class="difflineminus">-      nsCString  path;</span>
<a href="#l12.540"></a><span id="l12.540" class="difflineminus">-      pAttach-&gt;pAttachment-&gt;GetNativePath( path);</span>
<a href="#l12.541"></a><span id="l12.541" class="difflineminus">-      IMPORT_LOG1( &quot;\t\tFile: %s\n&quot;, path.get());</span>
<a href="#l12.542"></a><span id="l12.542" class="difflineminus">-    }</span>
<a href="#l12.543"></a><span id="l12.543" class="difflineminus">-  }</span>
<a href="#l12.544"></a><span id="l12.544" class="difflineminus">-#endif</span>
<a href="#l12.545"></a><span id="l12.545" class="difflineminus">-}</span>
<a href="#l12.546"></a><span id="l12.546" class="difflineminus">-</span>
<a href="#l12.547"></a><span id="l12.547"> nsresult nsOutlookMail::ImportAddresses( PRUint32 *pCount, PRUint32 *pTotal, const PRUnichar *pName, PRUint32 id, nsIAddrDatabase *pDb, nsString&amp; errors)</span>
<a href="#l12.548"></a><span id="l12.548"> {</span>
<a href="#l12.549"></a><span id="l12.549">   if (id &gt;= (PRUint32)(m_addressList.GetSize())) {</span>
<a href="#l12.550"></a><span id="l12.550">     IMPORT_LOG0( &quot;*** Bad address identifier, unable to import\n&quot;);</span>
<a href="#l12.551"></a><span id="l12.551">     return( NS_ERROR_FAILURE);</span>
<a href="#l12.552"></a><span id="l12.552">   }</span>
<a href="#l12.553"></a><span id="l12.553"> </span>
<a href="#l12.554"></a><span id="l12.554">   PRUint32  dummyCount = 0;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/mailnews/import/outlook/src/nsOutlookMail.h</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/mailnews/import/outlook/src/nsOutlookMail.h</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -40,57 +40,46 @@</span>
<a href="#l13.4"></a><span id="l13.4"> </span>
<a href="#l13.5"></a><span id="l13.5"> #include &quot;nsISupportsArray.h&quot;</span>
<a href="#l13.6"></a><span id="l13.6"> #include &quot;nsString.h&quot;</span>
<a href="#l13.7"></a><span id="l13.7"> #include &quot;nsVoidArray.h&quot;</span>
<a href="#l13.8"></a><span id="l13.8"> #include &quot;nsOutlookCompose.h&quot;</span>
<a href="#l13.9"></a><span id="l13.9"> #include &quot;nsIFile.h&quot;</span>
<a href="#l13.10"></a><span id="l13.10"> #include &quot;MapiApi.h&quot;</span>
<a href="#l13.11"></a><span id="l13.11"> #include &quot;MapiMessage.h&quot;</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineplus">+#include &quot;nsIAddrDatabase.h&quot;</span>
<a href="#l13.13"></a><span id="l13.13"> </span>
<a href="#l13.14"></a><span id="l13.14"> class nsIAddrDatabase;</span>
<a href="#l13.15"></a><span id="l13.15"> class nsIImportFieldMap;</span>
<a href="#l13.16"></a><span id="l13.16"> </span>
<a href="#l13.17"></a><span id="l13.17"> class nsOutlookMail {</span>
<a href="#l13.18"></a><span id="l13.18"> public:</span>
<a href="#l13.19"></a><span id="l13.19">   nsOutlookMail();</span>
<a href="#l13.20"></a><span id="l13.20">   ~nsOutlookMail();</span>
<a href="#l13.21"></a><span id="l13.21">   </span>
<a href="#l13.22"></a><span id="l13.22">   nsresult GetMailFolders( nsISupportsArray **pArray);</span>
<a href="#l13.23"></a><span id="l13.23">   nsresult GetAddressBooks( nsISupportsArray **pArray);</span>
<a href="#l13.24"></a><span id="l13.24">   nsresult ImportMailbox( PRUint32 *pDoneSoFar, PRBool *pAbort, PRInt32 index, const PRUnichar *pName, nsIFile *pDest, PRInt32 *pMsgCount);</span>
<a href="#l13.25"></a><span id="l13.25" class="difflineplus">+  static nsresult ImportMessage( LPMESSAGE lpMsg, nsIOutputStream *destOutputStream, nsMsgDeliverMode mode);</span>
<a href="#l13.26"></a><span id="l13.26">   nsresult ImportAddresses( PRUint32 *pCount, PRUint32 *pTotal, const PRUnichar *pName, PRUint32 id, nsIAddrDatabase *pDb, nsString&amp; errors);</span>
<a href="#l13.27"></a><span id="l13.27" class="difflineminus">-  </span>
<a href="#l13.28"></a><span id="l13.28" class="difflineminus">-  </span>
<a href="#l13.29"></a><span id="l13.29"> private:</span>
<a href="#l13.30"></a><span id="l13.30">   void  OpenMessageStore( CMapiFolder *pNextFolder);</span>
<a href="#l13.31"></a><span id="l13.31" class="difflineminus">-  BOOL  WriteData( nsIOutputStream *pDest, const char *pData, PRInt32 len);</span>
<a href="#l13.32"></a><span id="l13.32" class="difflineminus">-  BOOL  WriteMessage( nsIOutputStream *pDest, CMapiMessage *pMsg, int&amp; attachCount, BOOL *pTerminate);</span>
<a href="#l13.33"></a><span id="l13.33" class="difflineminus">-  BOOL  WriteStr( nsIOutputStream *pDest, const char *pStr);</span>
<a href="#l13.34"></a><span id="l13.34" class="difflineminus">-  BOOL  WriteMimeMsgHeader( nsIOutputStream *pDest, CMapiMessage *pMsg);</span>
<a href="#l13.35"></a><span id="l13.35" class="difflineminus">-  BOOL  WriteMimeBoundary( nsIOutputStream *pDest, CMapiMessage *pMsg, BOOL terminate);</span>
<a href="#l13.36"></a><span id="l13.36" class="difflineminus">-  </span>
<a href="#l13.37"></a><span id="l13.37" class="difflineminus">-  nsresult  DeleteFile( nsIFile *pSpec);</span>
<a href="#l13.38"></a><span id="l13.38" class="difflineminus">-  void      EmptyAttachments( void);</span>
<a href="#l13.39"></a><span id="l13.39" class="difflineminus">-  void      BuildAttachments( CMapiMessage&amp; msg, int count);</span>
<a href="#l13.40"></a><span id="l13.40" class="difflineminus">-  void      DumpAttachments( void);</span>
<a href="#l13.41"></a><span id="l13.41" class="difflineplus">+  static BOOL  WriteData( nsIOutputStream *pDest, const char *pData, PRInt32 len);</span>
<a href="#l13.42"></a><span id="l13.42">   </span>
<a href="#l13.43"></a><span id="l13.43">   PRBool    IsAddressBookNameUnique( nsString&amp; name, nsString&amp; list);</span>
<a href="#l13.44"></a><span id="l13.44">   void      MakeAddressBookNameUnique( nsString&amp; name, nsString&amp; list);</span>
<a href="#l13.45"></a><span id="l13.45">   void      SanitizeValue( nsString&amp; val);</span>
<a href="#l13.46"></a><span id="l13.46">   void      SplitString( nsString&amp; val1, nsString&amp; val2);</span>
<a href="#l13.47"></a><span id="l13.47">   PRBool    BuildCard( const PRUnichar *pName, nsIAddrDatabase *pDb, nsIMdbRow *newRow, LPMAPIPROP pUser, nsIImportFieldMap *pFieldMap);</span>
<a href="#l13.48"></a><span id="l13.48">   nsresult  CreateList( const PRUnichar * pName, nsIAddrDatabase *pDb, LPMAPIPROP pUserList, nsIImportFieldMap *pFieldMap);</span>
<a href="#l13.49"></a><span id="l13.49" class="difflineminus">-  void SetDefaultContentType(CMapiMessage &amp;msg, nsCString &amp;cType);</span>
<a href="#l13.50"></a><span id="l13.50">   </span>
<a href="#l13.51"></a><span id="l13.51"> private:</span>
<a href="#l13.52"></a><span id="l13.52">   PRBool            m_gotFolders;</span>
<a href="#l13.53"></a><span id="l13.53">   PRBool            m_gotAddresses;</span>
<a href="#l13.54"></a><span id="l13.54">   PRBool            m_haveMapi;</span>
<a href="#l13.55"></a><span id="l13.55">   CMapiApi          m_mapi;</span>
<a href="#l13.56"></a><span id="l13.56">   CMapiFolderList   m_folderList;</span>
<a href="#l13.57"></a><span id="l13.57">   CMapiFolderList   m_addressList;</span>
<a href="#l13.58"></a><span id="l13.58">   CMapiFolderList   m_storeList;</span>
<a href="#l13.59"></a><span id="l13.59">   LPMDB             m_lpMdb;</span>
<a href="#l13.60"></a><span id="l13.60" class="difflineminus">-  nsVoidArray       m_attachments;</span>
<a href="#l13.61"></a><span id="l13.61"> };</span>
<a href="#l13.62"></a><span id="l13.62"> </span>
<a href="#l13.63"></a><span id="l13.63"> #endif /* nsOutlookMail_h___ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1">new file mode 100644</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineminus">--- /dev/null</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineplus">+++ b/mailnews/import/outlook/src/rtfDecoder.cpp</span>
<a href="#l14.4"></a><span id="l14.4" class="difflineat">@@ -0,0 +1,551 @@</span>
<a href="#l14.5"></a><span id="l14.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l14.6"></a><span id="l14.6" class="difflineplus">+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l14.7"></a><span id="l14.7" class="difflineplus">+ *</span>
<a href="#l14.8"></a><span id="l14.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l14.9"></a><span id="l14.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l14.10"></a><span id="l14.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l14.11"></a><span id="l14.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineplus">+ *</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l14.14"></a><span id="l14.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l14.15"></a><span id="l14.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l14.16"></a><span id="l14.16" class="difflineplus">+ * License.</span>
<a href="#l14.17"></a><span id="l14.17" class="difflineplus">+ *</span>
<a href="#l14.18"></a><span id="l14.18" class="difflineplus">+ * The Original Code is mozilla.org code</span>
<a href="#l14.19"></a><span id="l14.19" class="difflineplus">+ *</span>
<a href="#l14.20"></a><span id="l14.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l14.21"></a><span id="l14.21" class="difflineplus">+ * Mike Kaganski &lt;mikekaganski@gmail.com&gt;.</span>
<a href="#l14.22"></a><span id="l14.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2010</span>
<a href="#l14.23"></a><span id="l14.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l14.24"></a><span id="l14.24" class="difflineplus">+ *</span>
<a href="#l14.25"></a><span id="l14.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l14.26"></a><span id="l14.26" class="difflineplus">+ *</span>
<a href="#l14.27"></a><span id="l14.27" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l14.28"></a><span id="l14.28" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l14.29"></a><span id="l14.29" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l14.30"></a><span id="l14.30" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l14.32"></a><span id="l14.32" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l14.33"></a><span id="l14.33" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l14.34"></a><span id="l14.34" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l14.35"></a><span id="l14.35" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l14.36"></a><span id="l14.36" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l14.37"></a><span id="l14.37" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l14.38"></a><span id="l14.38" class="difflineplus">+ *</span>
<a href="#l14.39"></a><span id="l14.39" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l14.40"></a><span id="l14.40" class="difflineplus">+</span>
<a href="#l14.41"></a><span id="l14.41" class="difflineplus">+#include &lt;locale&gt;</span>
<a href="#l14.42"></a><span id="l14.42" class="difflineplus">+#include &lt;stack&gt;</span>
<a href="#l14.43"></a><span id="l14.43" class="difflineplus">+#include &lt;map&gt;</span>
<a href="#l14.44"></a><span id="l14.44" class="difflineplus">+#include &lt;sstream&gt;</span>
<a href="#l14.45"></a><span id="l14.45" class="difflineplus">+#include &quot;Windows.h&quot;</span>
<a href="#l14.46"></a><span id="l14.46" class="difflineplus">+#include &quot;rtfDecoder.h&quot;</span>
<a href="#l14.47"></a><span id="l14.47" class="difflineplus">+</span>
<a href="#l14.48"></a><span id="l14.48" class="difflineplus">+#define SIZEOF(x) (sizeof(x)/sizeof((x)[0]))</span>
<a href="#l14.49"></a><span id="l14.49" class="difflineplus">+</span>
<a href="#l14.50"></a><span id="l14.50" class="difflineplus">+inline int HexToInt(char ch)</span>
<a href="#l14.51"></a><span id="l14.51" class="difflineplus">+{</span>
<a href="#l14.52"></a><span id="l14.52" class="difflineplus">+  switch (ch) {</span>
<a href="#l14.53"></a><span id="l14.53" class="difflineplus">+  case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':</span>
<a href="#l14.54"></a><span id="l14.54" class="difflineplus">+    return ch-'0';</span>
<a href="#l14.55"></a><span id="l14.55" class="difflineplus">+  case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':</span>
<a href="#l14.56"></a><span id="l14.56" class="difflineplus">+    return ch-'A'+10;</span>
<a href="#l14.57"></a><span id="l14.57" class="difflineplus">+  case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':</span>
<a href="#l14.58"></a><span id="l14.58" class="difflineplus">+    return ch-'a'+10;</span>
<a href="#l14.59"></a><span id="l14.59" class="difflineplus">+  default:</span>
<a href="#l14.60"></a><span id="l14.60" class="difflineplus">+    return 0;</span>
<a href="#l14.61"></a><span id="l14.61" class="difflineplus">+  }</span>
<a href="#l14.62"></a><span id="l14.62" class="difflineplus">+}</span>
<a href="#l14.63"></a><span id="l14.63" class="difflineplus">+</span>
<a href="#l14.64"></a><span id="l14.64" class="difflineplus">+inline int CharsetToCP(int charset)</span>
<a href="#l14.65"></a><span id="l14.65" class="difflineplus">+{</span>
<a href="#l14.66"></a><span id="l14.66" class="difflineplus">+  // We don't know the Code page for the commented out charsets.</span>
<a href="#l14.67"></a><span id="l14.67" class="difflineplus">+  switch (charset) {</span>
<a href="#l14.68"></a><span id="l14.68" class="difflineplus">+  case 0: return 1252; // ANSI</span>
<a href="#l14.69"></a><span id="l14.69" class="difflineplus">+  case 1: return 0;   // Default</span>
<a href="#l14.70"></a><span id="l14.70" class="difflineplus">+//case 2: return 42; // Symbol</span>
<a href="#l14.71"></a><span id="l14.71" class="difflineplus">+  case 2: return 1252; // Symbol</span>
<a href="#l14.72"></a><span id="l14.72" class="difflineplus">+  case 77: return 10000; // Mac Roman</span>
<a href="#l14.73"></a><span id="l14.73" class="difflineplus">+  case 78: return 10001; // Mac Shift Jis</span>
<a href="#l14.74"></a><span id="l14.74" class="difflineplus">+  case 79: return 10003; // Mac Hangul</span>
<a href="#l14.75"></a><span id="l14.75" class="difflineplus">+  case 80: return 10008; // Mac GB2312</span>
<a href="#l14.76"></a><span id="l14.76" class="difflineplus">+  case 81: return 10002; // Mac Big5</span>
<a href="#l14.77"></a><span id="l14.77" class="difflineplus">+//case 82: Mac Johab (old)</span>
<a href="#l14.78"></a><span id="l14.78" class="difflineplus">+  case 83: return 10005; // Mac Hebrew</span>
<a href="#l14.79"></a><span id="l14.79" class="difflineplus">+  case 84: return 10004; // Mac Arabic</span>
<a href="#l14.80"></a><span id="l14.80" class="difflineplus">+  case 85: return 10006; // Mac Greek</span>
<a href="#l14.81"></a><span id="l14.81" class="difflineplus">+  case 86: return 10081; // Mac Turkish</span>
<a href="#l14.82"></a><span id="l14.82" class="difflineplus">+  case 87: return 10021; // Mac Thai</span>
<a href="#l14.83"></a><span id="l14.83" class="difflineplus">+  case 88: return 10029; // Mac East Europe</span>
<a href="#l14.84"></a><span id="l14.84" class="difflineplus">+  case 89: return 10007; // Mac Russian</span>
<a href="#l14.85"></a><span id="l14.85" class="difflineplus">+  case 128: return 932; // Shift JIS</span>
<a href="#l14.86"></a><span id="l14.86" class="difflineplus">+  case 129: return 949; // Hangul</span>
<a href="#l14.87"></a><span id="l14.87" class="difflineplus">+  case 130: return 1361; // Johab</span>
<a href="#l14.88"></a><span id="l14.88" class="difflineplus">+  case 134: return 936; // GB2312</span>
<a href="#l14.89"></a><span id="l14.89" class="difflineplus">+  case 136: return 950; // Big5</span>
<a href="#l14.90"></a><span id="l14.90" class="difflineplus">+  case 161: return 1253; // Greek</span>
<a href="#l14.91"></a><span id="l14.91" class="difflineplus">+  case 162: return 1254; // Turkish</span>
<a href="#l14.92"></a><span id="l14.92" class="difflineplus">+  case 163: return 1258; // Vietnamese</span>
<a href="#l14.93"></a><span id="l14.93" class="difflineplus">+  case 177: return 1255; // Hebrew</span>
<a href="#l14.94"></a><span id="l14.94" class="difflineplus">+  case 178: return 1256; // Arabic</span>
<a href="#l14.95"></a><span id="l14.95" class="difflineplus">+//case 179: Arabic Traditional (old)</span>
<a href="#l14.96"></a><span id="l14.96" class="difflineplus">+//case 180: Arabic user (old)</span>
<a href="#l14.97"></a><span id="l14.97" class="difflineplus">+//case 181: Hebrew user (old)</span>
<a href="#l14.98"></a><span id="l14.98" class="difflineplus">+  case 186: return 1257; // Baltic</span>
<a href="#l14.99"></a><span id="l14.99" class="difflineplus">+  case 204: return 1251; // Russian</span>
<a href="#l14.100"></a><span id="l14.100" class="difflineplus">+  case 222: return 874; // Thai</span>
<a href="#l14.101"></a><span id="l14.101" class="difflineplus">+  case 238: return 1250; // Eastern European</span>
<a href="#l14.102"></a><span id="l14.102" class="difflineplus">+  case 254: return 437; // PC 437</span>
<a href="#l14.103"></a><span id="l14.103" class="difflineplus">+  case 255: return 850; // OEM</span>
<a href="#l14.104"></a><span id="l14.104" class="difflineplus">+  default: return CP_ACP;</span>
<a href="#l14.105"></a><span id="l14.105" class="difflineplus">+  }</span>
<a href="#l14.106"></a><span id="l14.106" class="difflineplus">+}</span>
<a href="#l14.107"></a><span id="l14.107" class="difflineplus">+</span>
<a href="#l14.108"></a><span id="l14.108" class="difflineplus">+struct FontInfo {</span>
<a href="#l14.109"></a><span id="l14.109" class="difflineplus">+  enum Options {has_fcharset = 0x0001,</span>
<a href="#l14.110"></a><span id="l14.110" class="difflineplus">+                has_cpg      = 0x0002};</span>
<a href="#l14.111"></a><span id="l14.111" class="difflineplus">+  unsigned int options;</span>
<a href="#l14.112"></a><span id="l14.112" class="difflineplus">+  int fcharset;</span>
<a href="#l14.113"></a><span id="l14.113" class="difflineplus">+  unsigned int cpg;</span>
<a href="#l14.114"></a><span id="l14.114" class="difflineplus">+  FontInfo() : options(0), fcharset(0), cpg(0xFFFFFFFF) {}</span>
<a href="#l14.115"></a><span id="l14.115" class="difflineplus">+  unsigned int Codepage()</span>
<a href="#l14.116"></a><span id="l14.116" class="difflineplus">+  {</span>
<a href="#l14.117"></a><span id="l14.117" class="difflineplus">+    if (options &amp; has_cpg)</span>
<a href="#l14.118"></a><span id="l14.118" class="difflineplus">+      return cpg;</span>
<a href="#l14.119"></a><span id="l14.119" class="difflineplus">+    else if (options &amp; has_fcharset)</span>
<a href="#l14.120"></a><span id="l14.120" class="difflineplus">+      return CharsetToCP(fcharset);</span>
<a href="#l14.121"></a><span id="l14.121" class="difflineplus">+    else return 0xFFFFFFFF;</span>
<a href="#l14.122"></a><span id="l14.122" class="difflineplus">+  }</span>
<a href="#l14.123"></a><span id="l14.123" class="difflineplus">+};</span>
<a href="#l14.124"></a><span id="l14.124" class="difflineplus">+typedef std::map&lt;int, FontInfo&gt; Fonttbl;</span>
<a href="#l14.125"></a><span id="l14.125" class="difflineplus">+</span>
<a href="#l14.126"></a><span id="l14.126" class="difflineplus">+struct LocalState {</span>
<a href="#l14.127"></a><span id="l14.127" class="difflineplus">+  bool fonttbl;         // When fonts are being defined</span>
<a href="#l14.128"></a><span id="l14.128" class="difflineplus">+  int f;                // Index of the font being defined/used; defines the codepage if no \cpg</span>
<a href="#l14.129"></a><span id="l14.129" class="difflineplus">+  unsigned int uc;      // ucN keyword value; its default is 1</span>
<a href="#l14.130"></a><span id="l14.130" class="difflineplus">+  unsigned int codepage;// defined by \cpg</span>
<a href="#l14.131"></a><span id="l14.131" class="difflineplus">+};</span>
<a href="#l14.132"></a><span id="l14.132" class="difflineplus">+typedef std::stack&lt;LocalState&gt; StateStack;</span>
<a href="#l14.133"></a><span id="l14.133" class="difflineplus">+</span>
<a href="#l14.134"></a><span id="l14.134" class="difflineplus">+struct GlobalState {</span>
<a href="#l14.135"></a><span id="l14.135" class="difflineplus">+  enum Pcdata_state { pcdsno, pcdsin, pcdsfinished };</span>
<a href="#l14.136"></a><span id="l14.136" class="difflineplus">+  std::istream&amp; stream;</span>
<a href="#l14.137"></a><span id="l14.137" class="difflineplus">+  Fonttbl fonttbl;</span>
<a href="#l14.138"></a><span id="l14.138" class="difflineplus">+  StateStack stack;</span>
<a href="#l14.139"></a><span id="l14.139" class="difflineplus">+  unsigned int codepage; // defined by \ansi, \mac, \pc, \pca, and \ansicpgN</span>
<a href="#l14.140"></a><span id="l14.140" class="difflineplus">+  int deff;</span>
<a href="#l14.141"></a><span id="l14.141" class="difflineplus">+  std::stringstream pcdata_a;</span>
<a href="#l14.142"></a><span id="l14.142" class="difflineplus">+  unsigned int pcdata_a_codepage;</span>
<a href="#l14.143"></a><span id="l14.143" class="difflineplus">+  Pcdata_state pcdata_a_state;</span>
<a href="#l14.144"></a><span id="l14.144" class="difflineplus">+</span>
<a href="#l14.145"></a><span id="l14.145" class="difflineplus">+  GlobalState(std::istream&amp; s)</span>
<a href="#l14.146"></a><span id="l14.146" class="difflineplus">+    : stream(s), codepage(CP_ACP), deff(-1), pcdata_a_state(pcdsno)</span>
<a href="#l14.147"></a><span id="l14.147" class="difflineplus">+  {</span>
<a href="#l14.148"></a><span id="l14.148" class="difflineplus">+    LocalState st;</span>
<a href="#l14.149"></a><span id="l14.149" class="difflineplus">+    st.fonttbl = false;</span>
<a href="#l14.150"></a><span id="l14.150" class="difflineplus">+    st.f = -1;</span>
<a href="#l14.151"></a><span id="l14.151" class="difflineplus">+    st.uc = 1;</span>
<a href="#l14.152"></a><span id="l14.152" class="difflineplus">+    st.codepage = 0xFFFFFFFF;</span>
<a href="#l14.153"></a><span id="l14.153" class="difflineplus">+    stack.push(st);</span>
<a href="#l14.154"></a><span id="l14.154" class="difflineplus">+  }</span>
<a href="#l14.155"></a><span id="l14.155" class="difflineplus">+  unsigned int GetCurrentCP()</span>
<a href="#l14.156"></a><span id="l14.156" class="difflineplus">+  {</span>
<a href="#l14.157"></a><span id="l14.157" class="difflineplus">+    if (stack.top().codepage != 0xFFFFFFFF) // \cpg in use</span>
<a href="#l14.158"></a><span id="l14.158" class="difflineplus">+      return stack.top().codepage;</span>
<a href="#l14.159"></a><span id="l14.159" class="difflineplus">+    // \cpg not used; use font settings</span>
<a href="#l14.160"></a><span id="l14.160" class="difflineplus">+    int f = (stack.top().f != -1) ? stack.top().f : deff; </span>
<a href="#l14.161"></a><span id="l14.161" class="difflineplus">+    if (f != -1) {</span>
<a href="#l14.162"></a><span id="l14.162" class="difflineplus">+      Fonttbl::iterator iter = fonttbl.find(f);</span>
<a href="#l14.163"></a><span id="l14.163" class="difflineplus">+      if (iter != fonttbl.end()) {</span>
<a href="#l14.164"></a><span id="l14.164" class="difflineplus">+        unsigned int cp = iter-&gt;second.Codepage();</span>
<a href="#l14.165"></a><span id="l14.165" class="difflineplus">+        if (cp != 0xFFFFFFFF)</span>
<a href="#l14.166"></a><span id="l14.166" class="difflineplus">+          return cp;</span>
<a href="#l14.167"></a><span id="l14.167" class="difflineplus">+      }</span>
<a href="#l14.168"></a><span id="l14.168" class="difflineplus">+    }</span>
<a href="#l14.169"></a><span id="l14.169" class="difflineplus">+    return codepage; // No overrides; use the top-level legacy setting</span>
<a href="#l14.170"></a><span id="l14.170" class="difflineplus">+  }</span>
<a href="#l14.171"></a><span id="l14.171" class="difflineplus">+};</span>
<a href="#l14.172"></a><span id="l14.172" class="difflineplus">+</span>
<a href="#l14.173"></a><span id="l14.173" class="difflineplus">+struct Keyword {</span>
<a href="#l14.174"></a><span id="l14.174" class="difflineplus">+  char name[33];</span>
<a href="#l14.175"></a><span id="l14.175" class="difflineplus">+  bool hasVal;</span>
<a href="#l14.176"></a><span id="l14.176" class="difflineplus">+  int val;</span>
<a href="#l14.177"></a><span id="l14.177" class="difflineplus">+};</span>
<a href="#l14.178"></a><span id="l14.178" class="difflineplus">+</span>
<a href="#l14.179"></a><span id="l14.179" class="difflineplus">+class Lexem {</span>
<a href="#l14.180"></a><span id="l14.180" class="difflineplus">+public:</span>
<a href="#l14.181"></a><span id="l14.181" class="difflineplus">+  enum Type {ltGroupBegin, ltGroupEnd, ltKeyword, ltPCDATA_A, ltPCDATA_W,</span>
<a href="#l14.182"></a><span id="l14.182" class="difflineplus">+             ltBDATA, ltEOF, ltError};</span>
<a href="#l14.183"></a><span id="l14.183" class="difflineplus">+  Lexem(Type t=ltError) : m_type(t) {}</span>
<a href="#l14.184"></a><span id="l14.184" class="difflineplus">+  Lexem(Lexem&amp; from) // Move pointers when copying</span>
<a href="#l14.185"></a><span id="l14.185" class="difflineplus">+  {</span>
<a href="#l14.186"></a><span id="l14.186" class="difflineplus">+    switch (m_type = from.m_type) {</span>
<a href="#l14.187"></a><span id="l14.187" class="difflineplus">+    case ltKeyword:</span>
<a href="#l14.188"></a><span id="l14.188" class="difflineplus">+      m_keyword = from.m_keyword;</span>
<a href="#l14.189"></a><span id="l14.189" class="difflineplus">+      break;</span>
<a href="#l14.190"></a><span id="l14.190" class="difflineplus">+    case ltPCDATA_A:</span>
<a href="#l14.191"></a><span id="l14.191" class="difflineplus">+      m_pcdata_a = from.m_pcdata_a;</span>
<a href="#l14.192"></a><span id="l14.192" class="difflineplus">+      break;</span>
<a href="#l14.193"></a><span id="l14.193" class="difflineplus">+    case ltPCDATA_W:</span>
<a href="#l14.194"></a><span id="l14.194" class="difflineplus">+      m_pcdata_w = from.m_pcdata_w;</span>
<a href="#l14.195"></a><span id="l14.195" class="difflineplus">+      break;</span>
<a href="#l14.196"></a><span id="l14.196" class="difflineplus">+    case ltBDATA:</span>
<a href="#l14.197"></a><span id="l14.197" class="difflineplus">+      m_bdata = from.m_bdata;</span>
<a href="#l14.198"></a><span id="l14.198" class="difflineplus">+      from.m_type = ltError;</span>
<a href="#l14.199"></a><span id="l14.199" class="difflineplus">+      break;</span>
<a href="#l14.200"></a><span id="l14.200" class="difflineplus">+    }</span>
<a href="#l14.201"></a><span id="l14.201" class="difflineplus">+  }</span>
<a href="#l14.202"></a><span id="l14.202" class="difflineplus">+  ~Lexem() { Clear(); }</span>
<a href="#l14.203"></a><span id="l14.203" class="difflineplus">+  Lexem&amp; operator = (Lexem&amp; from)</span>
<a href="#l14.204"></a><span id="l14.204" class="difflineplus">+  {</span>
<a href="#l14.205"></a><span id="l14.205" class="difflineplus">+    if (&amp;from != this) {</span>
<a href="#l14.206"></a><span id="l14.206" class="difflineplus">+      Clear();</span>
<a href="#l14.207"></a><span id="l14.207" class="difflineplus">+      switch (m_type = from.m_type) {</span>
<a href="#l14.208"></a><span id="l14.208" class="difflineplus">+      case ltKeyword:</span>
<a href="#l14.209"></a><span id="l14.209" class="difflineplus">+        m_keyword = from.m_keyword;</span>
<a href="#l14.210"></a><span id="l14.210" class="difflineplus">+        break;</span>
<a href="#l14.211"></a><span id="l14.211" class="difflineplus">+      case ltPCDATA_A:</span>
<a href="#l14.212"></a><span id="l14.212" class="difflineplus">+        m_pcdata_a = from.m_pcdata_a;</span>
<a href="#l14.213"></a><span id="l14.213" class="difflineplus">+        break;</span>
<a href="#l14.214"></a><span id="l14.214" class="difflineplus">+      case ltPCDATA_W:</span>
<a href="#l14.215"></a><span id="l14.215" class="difflineplus">+        m_pcdata_w = from.m_pcdata_w;</span>
<a href="#l14.216"></a><span id="l14.216" class="difflineplus">+        break;</span>
<a href="#l14.217"></a><span id="l14.217" class="difflineplus">+      case ltBDATA:</span>
<a href="#l14.218"></a><span id="l14.218" class="difflineplus">+        m_bdata = from.m_bdata;</span>
<a href="#l14.219"></a><span id="l14.219" class="difflineplus">+        from.m_type = ltError;</span>
<a href="#l14.220"></a><span id="l14.220" class="difflineplus">+        break;</span>
<a href="#l14.221"></a><span id="l14.221" class="difflineplus">+      }</span>
<a href="#l14.222"></a><span id="l14.222" class="difflineplus">+    }</span>
<a href="#l14.223"></a><span id="l14.223" class="difflineplus">+    return *this;</span>
<a href="#l14.224"></a><span id="l14.224" class="difflineplus">+  }</span>
<a href="#l14.225"></a><span id="l14.225" class="difflineplus">+  Type type() const { return m_type; }</span>
<a href="#l14.226"></a><span id="l14.226" class="difflineplus">+  void SetPCDATA_A(char chdata)</span>
<a href="#l14.227"></a><span id="l14.227" class="difflineplus">+  {</span>
<a href="#l14.228"></a><span id="l14.228" class="difflineplus">+    Clear();</span>
<a href="#l14.229"></a><span id="l14.229" class="difflineplus">+    m_pcdata_a = chdata;</span>
<a href="#l14.230"></a><span id="l14.230" class="difflineplus">+    m_type = ltPCDATA_A;</span>
<a href="#l14.231"></a><span id="l14.231" class="difflineplus">+  }</span>
<a href="#l14.232"></a><span id="l14.232" class="difflineplus">+  void SetPCDATA_W(wchar_t chdata)</span>
<a href="#l14.233"></a><span id="l14.233" class="difflineplus">+  {</span>
<a href="#l14.234"></a><span id="l14.234" class="difflineplus">+    Clear();</span>
<a href="#l14.235"></a><span id="l14.235" class="difflineplus">+    m_pcdata_w = chdata;</span>
<a href="#l14.236"></a><span id="l14.236" class="difflineplus">+    m_type = ltPCDATA_W;</span>
<a href="#l14.237"></a><span id="l14.237" class="difflineplus">+  }</span>
<a href="#l14.238"></a><span id="l14.238" class="difflineplus">+  void SetBDATA(const char* data, int sz)</span>
<a href="#l14.239"></a><span id="l14.239" class="difflineplus">+  {</span>
<a href="#l14.240"></a><span id="l14.240" class="difflineplus">+    char* tmp = new char[sz]; // to allow getting the data from itself</span>
<a href="#l14.241"></a><span id="l14.241" class="difflineplus">+    if (tmp) {</span>
<a href="#l14.242"></a><span id="l14.242" class="difflineplus">+      memcpy(tmp, data, sz);</span>
<a href="#l14.243"></a><span id="l14.243" class="difflineplus">+      Clear();</span>
<a href="#l14.244"></a><span id="l14.244" class="difflineplus">+      m_bdata.data = tmp;</span>
<a href="#l14.245"></a><span id="l14.245" class="difflineplus">+      m_bdata.sz = sz;</span>
<a href="#l14.246"></a><span id="l14.246" class="difflineplus">+      m_type = ltBDATA;</span>
<a href="#l14.247"></a><span id="l14.247" class="difflineplus">+    }</span>
<a href="#l14.248"></a><span id="l14.248" class="difflineplus">+    else m_type = ltError;</span>
<a href="#l14.249"></a><span id="l14.249" class="difflineplus">+  }</span>
<a href="#l14.250"></a><span id="l14.250" class="difflineplus">+  void SetKeyword(const Keyword&amp; src)</span>
<a href="#l14.251"></a><span id="l14.251" class="difflineplus">+  {</span>
<a href="#l14.252"></a><span id="l14.252" class="difflineplus">+    Clear();</span>
<a href="#l14.253"></a><span id="l14.253" class="difflineplus">+    m_type = ltKeyword;</span>
<a href="#l14.254"></a><span id="l14.254" class="difflineplus">+    m_keyword = src;</span>
<a href="#l14.255"></a><span id="l14.255" class="difflineplus">+  }</span>
<a href="#l14.256"></a><span id="l14.256" class="difflineplus">+  void SetKeyword(const char* name, bool hasVal=false, int val=0)</span>
<a href="#l14.257"></a><span id="l14.257" class="difflineplus">+  {</span>
<a href="#l14.258"></a><span id="l14.258" class="difflineplus">+    char tmp[SIZEOF(m_keyword.name)];</span>
<a href="#l14.259"></a><span id="l14.259" class="difflineplus">+    strncpy(tmp, name, SIZEOF(m_keyword.name)-1); // to allow copy drom itself</span>
<a href="#l14.260"></a><span id="l14.260" class="difflineplus">+    tmp[SIZEOF(m_keyword.name)-1]=0;</span>
<a href="#l14.261"></a><span id="l14.261" class="difflineplus">+    Clear();</span>
<a href="#l14.262"></a><span id="l14.262" class="difflineplus">+    m_type = ltKeyword;</span>
<a href="#l14.263"></a><span id="l14.263" class="difflineplus">+    memcpy(m_keyword.name, tmp, SIZEOF(m_keyword.name));</span>
<a href="#l14.264"></a><span id="l14.264" class="difflineplus">+    m_keyword.hasVal=hasVal;</span>
<a href="#l14.265"></a><span id="l14.265" class="difflineplus">+    m_keyword.val=val;</span>
<a href="#l14.266"></a><span id="l14.266" class="difflineplus">+  }</span>
<a href="#l14.267"></a><span id="l14.267" class="difflineplus">+  const char* KeywordName() const {</span>
<a href="#l14.268"></a><span id="l14.268" class="difflineplus">+    return (m_type == ltKeyword) ? m_keyword.name : 0; }</span>
<a href="#l14.269"></a><span id="l14.269" class="difflineplus">+  const int* KeywordVal() const {</span>
<a href="#l14.270"></a><span id="l14.270" class="difflineplus">+    return ((m_type == ltKeyword) &amp;&amp; m_keyword.hasVal) ? &amp;m_keyword.val : 0; }</span>
<a href="#l14.271"></a><span id="l14.271" class="difflineplus">+  char pcdata_a() const { return (m_type == ltPCDATA_A) ? m_pcdata_a : 0; }</span>
<a href="#l14.272"></a><span id="l14.272" class="difflineplus">+  wchar_t pcdata_w() const { return (m_type == ltPCDATA_W) ? m_pcdata_w : 0; }</span>
<a href="#l14.273"></a><span id="l14.273" class="difflineplus">+  const char* bdata() const { return (m_type == ltBDATA) ? m_bdata.data : 0; }</span>
<a href="#l14.274"></a><span id="l14.274" class="difflineplus">+  int bdata_sz() const { return (m_type == ltBDATA) ? m_bdata.sz : 0; }</span>
<a href="#l14.275"></a><span id="l14.275" class="difflineplus">+  static Lexem eof;</span>
<a href="#l14.276"></a><span id="l14.276" class="difflineplus">+  static Lexem groupBegin;</span>
<a href="#l14.277"></a><span id="l14.277" class="difflineplus">+  static Lexem groupEnd;</span>
<a href="#l14.278"></a><span id="l14.278" class="difflineplus">+  static Lexem error;</span>
<a href="#l14.279"></a><span id="l14.279" class="difflineplus">+private:</span>
<a href="#l14.280"></a><span id="l14.280" class="difflineplus">+  struct BDATA {</span>
<a href="#l14.281"></a><span id="l14.281" class="difflineplus">+    size_t sz;</span>
<a href="#l14.282"></a><span id="l14.282" class="difflineplus">+    char* data;</span>
<a href="#l14.283"></a><span id="l14.283" class="difflineplus">+  };</span>
<a href="#l14.284"></a><span id="l14.284" class="difflineplus">+</span>
<a href="#l14.285"></a><span id="l14.285" class="difflineplus">+  Type m_type;</span>
<a href="#l14.286"></a><span id="l14.286" class="difflineplus">+  union {</span>
<a href="#l14.287"></a><span id="l14.287" class="difflineplus">+    Keyword m_keyword;</span>
<a href="#l14.288"></a><span id="l14.288" class="difflineplus">+    char m_pcdata_a;</span>
<a href="#l14.289"></a><span id="l14.289" class="difflineplus">+    wchar_t m_pcdata_w;</span>
<a href="#l14.290"></a><span id="l14.290" class="difflineplus">+    BDATA m_bdata;</span>
<a href="#l14.291"></a><span id="l14.291" class="difflineplus">+  };</span>
<a href="#l14.292"></a><span id="l14.292" class="difflineplus">+  // This function leaves the object in the broken state. Must be followed</span>
<a href="#l14.293"></a><span id="l14.293" class="difflineplus">+  // by a correct initialization.</span>
<a href="#l14.294"></a><span id="l14.294" class="difflineplus">+  void Clear() </span>
<a href="#l14.295"></a><span id="l14.295" class="difflineplus">+  {</span>
<a href="#l14.296"></a><span id="l14.296" class="difflineplus">+    switch (m_type) {</span>
<a href="#l14.297"></a><span id="l14.297" class="difflineplus">+    case ltBDATA:</span>
<a href="#l14.298"></a><span id="l14.298" class="difflineplus">+      delete[] m_bdata.data;</span>
<a href="#l14.299"></a><span id="l14.299" class="difflineplus">+      break;</span>
<a href="#l14.300"></a><span id="l14.300" class="difflineplus">+    }</span>
<a href="#l14.301"></a><span id="l14.301" class="difflineplus">+//  m_type = ltError;</span>
<a href="#l14.302"></a><span id="l14.302" class="difflineplus">+  }</span>
<a href="#l14.303"></a><span id="l14.303" class="difflineplus">+};</span>
<a href="#l14.304"></a><span id="l14.304" class="difflineplus">+</span>
<a href="#l14.305"></a><span id="l14.305" class="difflineplus">+Lexem Lexem::eof(ltEOF);</span>
<a href="#l14.306"></a><span id="l14.306" class="difflineplus">+Lexem Lexem::groupBegin(ltGroupBegin);</span>
<a href="#l14.307"></a><span id="l14.307" class="difflineplus">+Lexem Lexem::groupEnd(ltGroupEnd);</span>
<a href="#l14.308"></a><span id="l14.308" class="difflineplus">+Lexem Lexem::error(ltError);</span>
<a href="#l14.309"></a><span id="l14.309" class="difflineplus">+</span>
<a href="#l14.310"></a><span id="l14.310" class="difflineplus">+// This function moves pos. When calling the function, pos must be next to the</span>
<a href="#l14.311"></a><span id="l14.311" class="difflineplus">+// backslash; pos must be in the same sequence and before end!</span>
<a href="#l14.312"></a><span id="l14.312" class="difflineplus">+Keyword GetKeyword(std::istream&amp; stream)</span>
<a href="#l14.313"></a><span id="l14.313" class="difflineplus">+{</span>
<a href="#l14.314"></a><span id="l14.314" class="difflineplus">+  Keyword keyword = {&quot;&quot;, false, 0};</span>
<a href="#l14.315"></a><span id="l14.315" class="difflineplus">+  char ch;</span>
<a href="#l14.316"></a><span id="l14.316" class="difflineplus">+  if (stream.get(ch).eof())</span>
<a href="#l14.317"></a><span id="l14.317" class="difflineplus">+    return keyword;</span>
<a href="#l14.318"></a><span id="l14.318" class="difflineplus">+  // Control word; maybe delimiter and value</span>
<a href="#l14.319"></a><span id="l14.319" class="difflineplus">+  if (std::isalpha(ch, std::locale::classic())) { </span>
<a href="#l14.320"></a><span id="l14.320" class="difflineplus">+    int i = 0;</span>
<a href="#l14.321"></a><span id="l14.321" class="difflineplus">+    do {</span>
<a href="#l14.322"></a><span id="l14.322" class="difflineplus">+      // We take up to 32 characters into account, skipping over extra</span>
<a href="#l14.323"></a><span id="l14.323" class="difflineplus">+      // characters (allowing for some non-conformant implementation).</span>
<a href="#l14.324"></a><span id="l14.324" class="difflineplus">+      if (i &lt; 32)</span>
<a href="#l14.325"></a><span id="l14.325" class="difflineplus">+        keyword.name[i++] = ch;</span>
<a href="#l14.326"></a><span id="l14.326" class="difflineplus">+    } while (!stream.get(ch).eof() &amp;&amp; std::isalpha(ch, std::locale::classic()));</span>
<a href="#l14.327"></a><span id="l14.327" class="difflineplus">+    keyword.name[i] = 0; // NULL-terminating</span>
<a href="#l14.328"></a><span id="l14.328" class="difflineplus">+    if (!stream.eof() &amp;&amp; (std::isdigit(ch, std::locale::classic()) || (ch == '-'))) { // Value begin</span>
<a href="#l14.329"></a><span id="l14.329" class="difflineplus">+      keyword.hasVal = true;</span>
<a href="#l14.330"></a><span id="l14.330" class="difflineplus">+      bool negative = (ch == '-');</span>
<a href="#l14.331"></a><span id="l14.331" class="difflineplus">+      if (negative) stream.get(ch);</span>
<a href="#l14.332"></a><span id="l14.332" class="difflineplus">+      i = 0;</span>
<a href="#l14.333"></a><span id="l14.333" class="difflineplus">+      while (!stream.eof() &amp;&amp; std::isdigit(ch, std::locale::classic())) {</span>
<a href="#l14.334"></a><span id="l14.334" class="difflineplus">+        // We take into account only 10 digits, skip other. Older specs stated</span>
<a href="#l14.335"></a><span id="l14.335" class="difflineplus">+        // that we must be ready for an arbitrary number of digits.</span>
<a href="#l14.336"></a><span id="l14.336" class="difflineplus">+        if (i++ &lt; 10) </span>
<a href="#l14.337"></a><span id="l14.337" class="difflineplus">+          keyword.val = keyword.val*10 + (ch - '0');</span>
<a href="#l14.338"></a><span id="l14.338" class="difflineplus">+        stream.get(ch);</span>
<a href="#l14.339"></a><span id="l14.339" class="difflineplus">+      }</span>
<a href="#l14.340"></a><span id="l14.340" class="difflineplus">+      if (negative) keyword.val = -keyword.val;</span>
<a href="#l14.341"></a><span id="l14.341" class="difflineplus">+    }</span>
<a href="#l14.342"></a><span id="l14.342" class="difflineplus">+     // End of control word; the space is just a delimiter - skip it</span>
<a href="#l14.343"></a><span id="l14.343" class="difflineplus">+    if (!stream.eof() &amp;&amp; !std::isspace(ch, std::locale::classic()))</span>
<a href="#l14.344"></a><span id="l14.344" class="difflineplus">+      stream.unget();</span>
<a href="#l14.345"></a><span id="l14.345" class="difflineplus">+  }</span>
<a href="#l14.346"></a><span id="l14.346" class="difflineplus">+  else { // Control symbol</span>
<a href="#l14.347"></a><span id="l14.347" class="difflineplus">+    keyword.name[0] = ch, keyword.name[1] = 0;</span>
<a href="#l14.348"></a><span id="l14.348" class="difflineplus">+  }</span>
<a href="#l14.349"></a><span id="l14.349" class="difflineplus">+  return keyword;</span>
<a href="#l14.350"></a><span id="l14.350" class="difflineplus">+}</span>
<a href="#l14.351"></a><span id="l14.351" class="difflineplus">+</span>
<a href="#l14.352"></a><span id="l14.352" class="difflineplus">+Lexem GetLexem(std::istream&amp; stream)</span>
<a href="#l14.353"></a><span id="l14.353" class="difflineplus">+{</span>
<a href="#l14.354"></a><span id="l14.354" class="difflineplus">+  Lexem result;</span>
<a href="#l14.355"></a><span id="l14.355" class="difflineplus">+  // We always stay at the beginning of the next lexem or a crlf</span>
<a href="#l14.356"></a><span id="l14.356" class="difflineplus">+  // If it's a brace then it's group begin/end</span>
<a href="#l14.357"></a><span id="l14.357" class="difflineplus">+  // If it's a backslash -&gt; Preprocess</span>
<a href="#l14.358"></a><span id="l14.358" class="difflineplus">+  // - if it's a \u or \' -&gt; make UTF16 character</span>
<a href="#l14.359"></a><span id="l14.359" class="difflineplus">+  // - else it's a keyword -&gt; Process (e.g., remember the codepage)</span>
<a href="#l14.360"></a><span id="l14.360" class="difflineplus">+  // - (if the keyword is \bin then the following is #BDATA)</span>
<a href="#l14.361"></a><span id="l14.361" class="difflineplus">+  // If it's some other character -&gt; Preprocess</span>
<a href="#l14.362"></a><span id="l14.362" class="difflineplus">+  // - if it's 0x09 -&gt; it's the keyword \tab</span>
<a href="#l14.363"></a><span id="l14.363" class="difflineplus">+  // - else it's a PCDATA</span>
<a href="#l14.364"></a><span id="l14.364" class="difflineplus">+  char ch;</span>
<a href="#l14.365"></a><span id="l14.365" class="difflineplus">+  while (!stream.get(ch).eof() &amp;&amp; ((ch == '\n') || (ch == '\r'))); // Skip crlf</span>
<a href="#l14.366"></a><span id="l14.366" class="difflineplus">+  if (stream.eof())</span>
<a href="#l14.367"></a><span id="l14.367" class="difflineplus">+    result = Lexem::eof;</span>
<a href="#l14.368"></a><span id="l14.368" class="difflineplus">+  else {</span>
<a href="#l14.369"></a><span id="l14.369" class="difflineplus">+    switch (ch) {</span>
<a href="#l14.370"></a><span id="l14.370" class="difflineplus">+    case '{': // Group begin</span>
<a href="#l14.371"></a><span id="l14.371" class="difflineplus">+    case '}': // Group end</span>
<a href="#l14.372"></a><span id="l14.372" class="difflineplus">+      result = (ch == '{') ? Lexem::groupBegin : Lexem::groupEnd;</span>
<a href="#l14.373"></a><span id="l14.373" class="difflineplus">+      break;</span>
<a href="#l14.374"></a><span id="l14.374" class="difflineplus">+    case '\\': // Keyword</span>
<a href="#l14.375"></a><span id="l14.375" class="difflineplus">+      result.SetKeyword(GetKeyword(stream));</span>
<a href="#l14.376"></a><span id="l14.376" class="difflineplus">+      break;</span>
<a href="#l14.377"></a><span id="l14.377" class="difflineplus">+    case '\t': // tab</span>
<a href="#l14.378"></a><span id="l14.378" class="difflineplus">+      result.SetKeyword(&quot;tab&quot;);</span>
<a href="#l14.379"></a><span id="l14.379" class="difflineplus">+      break;</span>
<a href="#l14.380"></a><span id="l14.380" class="difflineplus">+    default: // PSDATA?</span>
<a href="#l14.381"></a><span id="l14.381" class="difflineplus">+      result.SetPCDATA_A(ch);</span>
<a href="#l14.382"></a><span id="l14.382" class="difflineplus">+      break;</span>
<a href="#l14.383"></a><span id="l14.383" class="difflineplus">+    }</span>
<a href="#l14.384"></a><span id="l14.384" class="difflineplus">+  }</span>
<a href="#l14.385"></a><span id="l14.385" class="difflineplus">+  return result;</span>
<a href="#l14.386"></a><span id="l14.386" class="difflineplus">+}</span>
<a href="#l14.387"></a><span id="l14.387" class="difflineplus">+</span>
<a href="#l14.388"></a><span id="l14.388" class="difflineplus">+void PreprocessLexem(/*inout*/Lexem&amp; lexem, std::istream&amp; stream, int uc)</span>
<a href="#l14.389"></a><span id="l14.389" class="difflineplus">+{</span>
<a href="#l14.390"></a><span id="l14.390" class="difflineplus">+  if (lexem.type() == Lexem::ltKeyword) {</span>
<a href="#l14.391"></a><span id="l14.391" class="difflineplus">+    if (lexem.KeywordName()[0] == 0) // Empty keyword - maybe eof?</span>
<a href="#l14.392"></a><span id="l14.392" class="difflineplus">+      lexem = Lexem::error;</span>
<a href="#l14.393"></a><span id="l14.393" class="difflineplus">+    else if (eq(lexem.KeywordName(), &quot;u&quot;)) {</span>
<a href="#l14.394"></a><span id="l14.394" class="difflineplus">+       // Unicode character - get the UTF16 and skip the uc characters</span>
<a href="#l14.395"></a><span id="l14.395" class="difflineplus">+      if (const int* val = lexem.KeywordVal()) {</span>
<a href="#l14.396"></a><span id="l14.396" class="difflineplus">+        lexem.SetPCDATA_W(*val);</span>
<a href="#l14.397"></a><span id="l14.397" class="difflineplus">+        stream.ignore(uc);</span>
<a href="#l14.398"></a><span id="l14.398" class="difflineplus">+      }</span>
<a href="#l14.399"></a><span id="l14.399" class="difflineplus">+      else lexem = Lexem::error;</span>
<a href="#l14.400"></a><span id="l14.400" class="difflineplus">+    }</span>
<a href="#l14.401"></a><span id="l14.401" class="difflineplus">+    else if (eq(lexem.KeywordName(), &quot;'&quot;)) {</span>
<a href="#l14.402"></a><span id="l14.402" class="difflineplus">+       // 8-bit character (\'hh) -&gt; use current codepage</span>
<a href="#l14.403"></a><span id="l14.403" class="difflineplus">+      char ch, ch1;</span>
<a href="#l14.404"></a><span id="l14.404" class="difflineplus">+      if (!stream.get(ch).eof()) ch1 = HexToInt(ch);</span>
<a href="#l14.405"></a><span id="l14.405" class="difflineplus">+      if (!stream.get(ch).eof()) (ch1 &lt;&lt;= 4) += HexToInt(ch);</span>
<a href="#l14.406"></a><span id="l14.406" class="difflineplus">+      lexem.SetPCDATA_A(ch1);</span>
<a href="#l14.407"></a><span id="l14.407" class="difflineplus">+    }</span>
<a href="#l14.408"></a><span id="l14.408" class="difflineplus">+    else if (eq(lexem.KeywordName(), &quot;\\&quot;) || eq(lexem.KeywordName(), &quot;{&quot;) ||</span>
<a href="#l14.409"></a><span id="l14.409" class="difflineplus">+             eq(lexem.KeywordName(), &quot;}&quot;)) // escaped characters</span>
<a href="#l14.410"></a><span id="l14.410" class="difflineplus">+      lexem.SetPCDATA_A(lexem.KeywordName()[0]);</span>
<a href="#l14.411"></a><span id="l14.411" class="difflineplus">+    else if (eq(lexem.KeywordName(), &quot;bin&quot;)) {</span>
<a href="#l14.412"></a><span id="l14.412" class="difflineplus">+      if (const int* i = lexem.KeywordVal()) {</span>
<a href="#l14.413"></a><span id="l14.413" class="difflineplus">+        char* data = new char[*i];</span>
<a href="#l14.414"></a><span id="l14.414" class="difflineplus">+        if (data) {</span>
<a href="#l14.415"></a><span id="l14.415" class="difflineplus">+          stream.read(data, *i);</span>
<a href="#l14.416"></a><span id="l14.416" class="difflineplus">+          if (stream.fail())</span>
<a href="#l14.417"></a><span id="l14.417" class="difflineplus">+            lexem = Lexem::error;</span>
<a href="#l14.418"></a><span id="l14.418" class="difflineplus">+          else</span>
<a href="#l14.419"></a><span id="l14.419" class="difflineplus">+            lexem.SetBDATA(data, *i);</span>
<a href="#l14.420"></a><span id="l14.420" class="difflineplus">+          delete[] data;</span>
<a href="#l14.421"></a><span id="l14.421" class="difflineplus">+        }</span>
<a href="#l14.422"></a><span id="l14.422" class="difflineplus">+        else lexem = Lexem::error;</span>
<a href="#l14.423"></a><span id="l14.423" class="difflineplus">+      }</span>
<a href="#l14.424"></a><span id="l14.424" class="difflineplus">+      else lexem = Lexem::error;</span>
<a href="#l14.425"></a><span id="l14.425" class="difflineplus">+    }</span>
<a href="#l14.426"></a><span id="l14.426" class="difflineplus">+    else if (eq(lexem.KeywordName(), &quot;\n&quot;) || eq(lexem.KeywordName(), &quot;\r&quot;)) {</span>
<a href="#l14.427"></a><span id="l14.427" class="difflineplus">+      // escaped cr or lf</span>
<a href="#l14.428"></a><span id="l14.428" class="difflineplus">+      lexem.SetKeyword(&quot;par&quot;);</span>
<a href="#l14.429"></a><span id="l14.429" class="difflineplus">+    }</span>
<a href="#l14.430"></a><span id="l14.430" class="difflineplus">+  }</span>
<a href="#l14.431"></a><span id="l14.431" class="difflineplus">+}</span>
<a href="#l14.432"></a><span id="l14.432" class="difflineplus">+</span>
<a href="#l14.433"></a><span id="l14.433" class="difflineplus">+void UpdateState(const Lexem&amp; lexem, /*inout*/GlobalState&amp; globalState)</span>
<a href="#l14.434"></a><span id="l14.434" class="difflineplus">+{</span>
<a href="#l14.435"></a><span id="l14.435" class="difflineplus">+  switch (globalState.pcdata_a_state) {</span>
<a href="#l14.436"></a><span id="l14.436" class="difflineplus">+  case GlobalState::pcdsfinished: // Last time we finished the pcdata</span>
<a href="#l14.437"></a><span id="l14.437" class="difflineplus">+    globalState.pcdata_a_state = GlobalState::pcdsno;</span>
<a href="#l14.438"></a><span id="l14.438" class="difflineplus">+    break;</span>
<a href="#l14.439"></a><span id="l14.439" class="difflineplus">+  case GlobalState::pcdsin:</span>
<a href="#l14.440"></a><span id="l14.440" class="difflineplus">+     // to be reset later if still in the pcdata</span>
<a href="#l14.441"></a><span id="l14.441" class="difflineplus">+    globalState.pcdata_a_state = GlobalState::pcdsfinished;</span>
<a href="#l14.442"></a><span id="l14.442" class="difflineplus">+    break;</span>
<a href="#l14.443"></a><span id="l14.443" class="difflineplus">+  }</span>
<a href="#l14.444"></a><span id="l14.444" class="difflineplus">+</span>
<a href="#l14.445"></a><span id="l14.445" class="difflineplus">+  switch (lexem.type()) {</span>
<a href="#l14.446"></a><span id="l14.446" class="difflineplus">+  case Lexem::ltGroupBegin:</span>
<a href="#l14.447"></a><span id="l14.447" class="difflineplus">+    globalState.stack.push(globalState.stack.top());</span>
<a href="#l14.448"></a><span id="l14.448" class="difflineplus">+    break;</span>
<a href="#l14.449"></a><span id="l14.449" class="difflineplus">+  case Lexem::ltGroupEnd:</span>
<a href="#l14.450"></a><span id="l14.450" class="difflineplus">+    globalState.stack.pop();</span>
<a href="#l14.451"></a><span id="l14.451" class="difflineplus">+    break;</span>
<a href="#l14.452"></a><span id="l14.452" class="difflineplus">+  case Lexem::ltKeyword:</span>
<a href="#l14.453"></a><span id="l14.453" class="difflineplus">+    {</span>
<a href="#l14.454"></a><span id="l14.454" class="difflineplus">+      const int* val = lexem.KeywordVal();</span>
<a href="#l14.455"></a><span id="l14.455" class="difflineplus">+      if (eq(lexem.KeywordName(), &quot;ansi&quot;)) globalState.codepage = CP_ACP;</span>
<a href="#l14.456"></a><span id="l14.456" class="difflineplus">+      else if (eq(lexem.KeywordName(), &quot;mac&quot;)) globalState.codepage = CP_MACCP;</span>
<a href="#l14.457"></a><span id="l14.457" class="difflineplus">+      else if (eq(lexem.KeywordName(), &quot;pc&quot;)) globalState.codepage = 437;</span>
<a href="#l14.458"></a><span id="l14.458" class="difflineplus">+      else if (eq(lexem.KeywordName(), &quot;pca&quot;)) globalState.codepage = 850;</span>
<a href="#l14.459"></a><span id="l14.459" class="difflineplus">+      else if (eq(lexem.KeywordName(), &quot;ansicpg&quot;) &amp;&amp; val)</span>
<a href="#l14.460"></a><span id="l14.460" class="difflineplus">+        globalState.codepage = static_cast&lt;unsigned int&gt;(*val);</span>
<a href="#l14.461"></a><span id="l14.461" class="difflineplus">+      else if (eq(lexem.KeywordName(), &quot;deff&quot;) &amp;&amp; val)</span>
<a href="#l14.462"></a><span id="l14.462" class="difflineplus">+        globalState.deff = *val;</span>
<a href="#l14.463"></a><span id="l14.463" class="difflineplus">+      else if (eq(lexem.KeywordName(), &quot;fonttbl&quot;)) globalState.stack.top().fonttbl = true;</span>
<a href="#l14.464"></a><span id="l14.464" class="difflineplus">+      else if (eq(lexem.KeywordName(), &quot;f&quot;) &amp;&amp; val) {</span>
<a href="#l14.465"></a><span id="l14.465" class="difflineplus">+        globalState.stack.top().f = *val;</span>
<a href="#l14.466"></a><span id="l14.466" class="difflineplus">+      }</span>
<a href="#l14.467"></a><span id="l14.467" class="difflineplus">+      else if (eq(lexem.KeywordName(), &quot;fcharset&quot;) &amp;&amp;</span>
<a href="#l14.468"></a><span id="l14.468" class="difflineplus">+               globalState.stack.top().fonttbl &amp;&amp;</span>
<a href="#l14.469"></a><span id="l14.469" class="difflineplus">+               (globalState.stack.top().f != -1) &amp;&amp; val) {</span>
<a href="#l14.470"></a><span id="l14.470" class="difflineplus">+        FontInfo&amp; f = globalState.fonttbl[globalState.stack.top().f];</span>
<a href="#l14.471"></a><span id="l14.471" class="difflineplus">+        f.options |= FontInfo::has_fcharset;</span>
<a href="#l14.472"></a><span id="l14.472" class="difflineplus">+        f.fcharset = *val;</span>
<a href="#l14.473"></a><span id="l14.473" class="difflineplus">+      }</span>
<a href="#l14.474"></a><span id="l14.474" class="difflineplus">+      else if (eq(lexem.KeywordName(), &quot;cpg&quot;) &amp;&amp; val) {</span>
<a href="#l14.475"></a><span id="l14.475" class="difflineplus">+        if (globalState.stack.top().fonttbl &amp;&amp; (globalState.stack.top().f != -1)) { // Defining a font</span>
<a href="#l14.476"></a><span id="l14.476" class="difflineplus">+          FontInfo&amp; f = globalState.fonttbl[globalState.stack.top().f];</span>
<a href="#l14.477"></a><span id="l14.477" class="difflineplus">+          f.options |= FontInfo::has_cpg;</span>
<a href="#l14.478"></a><span id="l14.478" class="difflineplus">+          f.cpg = *val;</span>
<a href="#l14.479"></a><span id="l14.479" class="difflineplus">+        }</span>
<a href="#l14.480"></a><span id="l14.480" class="difflineplus">+        else { // Overriding the codepage for the block - may be in filenames</span>
<a href="#l14.481"></a><span id="l14.481" class="difflineplus">+          globalState.stack.top().codepage = *val;</span>
<a href="#l14.482"></a><span id="l14.482" class="difflineplus">+        }</span>
<a href="#l14.483"></a><span id="l14.483" class="difflineplus">+      }</span>
<a href="#l14.484"></a><span id="l14.484" class="difflineplus">+      else if (eq(lexem.KeywordName(), &quot;plain&quot;))</span>
<a href="#l14.485"></a><span id="l14.485" class="difflineplus">+        globalState.stack.top().f = -1;</span>
<a href="#l14.486"></a><span id="l14.486" class="difflineplus">+      else if (eq(lexem.KeywordName(), &quot;uc&quot;) &amp;&amp; val)</span>
<a href="#l14.487"></a><span id="l14.487" class="difflineplus">+        globalState.stack.top().uc = *val;</span>
<a href="#l14.488"></a><span id="l14.488" class="difflineplus">+    }</span>
<a href="#l14.489"></a><span id="l14.489" class="difflineplus">+    break;</span>
<a href="#l14.490"></a><span id="l14.490" class="difflineplus">+  case Lexem::ltPCDATA_A:</span>
<a href="#l14.491"></a><span id="l14.491" class="difflineplus">+    if (globalState.pcdata_a_state == GlobalState::pcdsno) // Beginning of the pcdata</span>
<a href="#l14.492"></a><span id="l14.492" class="difflineplus">+      globalState.pcdata_a_codepage = globalState.GetCurrentCP(); // to use later to convert to utf16</span>
<a href="#l14.493"></a><span id="l14.493" class="difflineplus">+    globalState.pcdata_a_state = GlobalState::pcdsin;</span>
<a href="#l14.494"></a><span id="l14.494" class="difflineplus">+    globalState.pcdata_a &lt;&lt; lexem.pcdata_a();</span>
<a href="#l14.495"></a><span id="l14.495" class="difflineplus">+    break;</span>
<a href="#l14.496"></a><span id="l14.496" class="difflineplus">+  }</span>
<a href="#l14.497"></a><span id="l14.497" class="difflineplus">+}</span>
<a href="#l14.498"></a><span id="l14.498" class="difflineplus">+</span>
<a href="#l14.499"></a><span id="l14.499" class="difflineplus">+void DecodeRTF(std::istream&amp; rtf, CRTFDecoder&amp; decoder)</span>
<a href="#l14.500"></a><span id="l14.500" class="difflineplus">+{</span>
<a href="#l14.501"></a><span id="l14.501" class="difflineplus">+  // Check if this is the rtf</span>
<a href="#l14.502"></a><span id="l14.502" class="difflineplus">+  Lexem lexem = GetLexem(rtf);</span>
<a href="#l14.503"></a><span id="l14.503" class="difflineplus">+  if (lexem.type() != Lexem::ltGroupBegin)</span>
<a href="#l14.504"></a><span id="l14.504" class="difflineplus">+    return;</span>
<a href="#l14.505"></a><span id="l14.505" class="difflineplus">+  decoder.BeginGroup();</span>
<a href="#l14.506"></a><span id="l14.506" class="difflineplus">+  lexem = GetLexem(rtf);</span>
<a href="#l14.507"></a><span id="l14.507" class="difflineplus">+  if ((lexem.type() != Lexem::ltKeyword) || !eq(lexem.KeywordName(), &quot;rtf&quot;) ||</span>
<a href="#l14.508"></a><span id="l14.508" class="difflineplus">+      !lexem.KeywordVal() || (*lexem.KeywordVal() != 1))</span>
<a href="#l14.509"></a><span id="l14.509" class="difflineplus">+    return;</span>
<a href="#l14.510"></a><span id="l14.510" class="difflineplus">+  decoder.Keyword(lexem.KeywordName(), lexem.KeywordVal());</span>
<a href="#l14.511"></a><span id="l14.511" class="difflineplus">+</span>
<a href="#l14.512"></a><span id="l14.512" class="difflineplus">+  GlobalState state(rtf);</span>
<a href="#l14.513"></a><span id="l14.513" class="difflineplus">+  // Level is the count of elements in the stack</span>
<a href="#l14.514"></a><span id="l14.514" class="difflineplus">+</span>
<a href="#l14.515"></a><span id="l14.515" class="difflineplus">+  while (!state.stream.eof() &amp;&amp; (state.stack.size()&gt;0)) { // Don't go past the global group</span>
<a href="#l14.516"></a><span id="l14.516" class="difflineplus">+    lexem = GetLexem(state.stream);</span>
<a href="#l14.517"></a><span id="l14.517" class="difflineplus">+    PreprocessLexem(lexem, state.stream, state.stack.top().uc);</span>
<a href="#l14.518"></a><span id="l14.518" class="difflineplus">+    UpdateState(lexem, state);</span>
<a href="#l14.519"></a><span id="l14.519" class="difflineplus">+</span>
<a href="#l14.520"></a><span id="l14.520" class="difflineplus">+    if (state.pcdata_a_state == GlobalState::pcdsfinished) {</span>
<a href="#l14.521"></a><span id="l14.521" class="difflineplus">+      std::string s = state.pcdata_a.str();</span>
<a href="#l14.522"></a><span id="l14.522" class="difflineplus">+      int sz = ::MultiByteToWideChar(state.pcdata_a_codepage, 0, s.c_str(), s.size(), 0, 0);</span>
<a href="#l14.523"></a><span id="l14.523" class="difflineplus">+      if (sz) {</span>
<a href="#l14.524"></a><span id="l14.524" class="difflineplus">+        wchar_t* data = new wchar_t[sz];</span>
<a href="#l14.525"></a><span id="l14.525" class="difflineplus">+        ::MultiByteToWideChar(state.pcdata_a_codepage, 0, s.c_str(), s.size(), data, sz);</span>
<a href="#l14.526"></a><span id="l14.526" class="difflineplus">+        decoder.PCDATA(data, sz);</span>
<a href="#l14.527"></a><span id="l14.527" class="difflineplus">+        delete[] data;</span>
<a href="#l14.528"></a><span id="l14.528" class="difflineplus">+      }</span>
<a href="#l14.529"></a><span id="l14.529" class="difflineplus">+      state.pcdata_a.str(&quot;&quot;); // reset</span>
<a href="#l14.530"></a><span id="l14.530" class="difflineplus">+    }</span>
<a href="#l14.531"></a><span id="l14.531" class="difflineplus">+</span>
<a href="#l14.532"></a><span id="l14.532" class="difflineplus">+    switch (lexem.type()) {</span>
<a href="#l14.533"></a><span id="l14.533" class="difflineplus">+    case Lexem::ltGroupBegin:</span>
<a href="#l14.534"></a><span id="l14.534" class="difflineplus">+      decoder.BeginGroup();</span>
<a href="#l14.535"></a><span id="l14.535" class="difflineplus">+      break;</span>
<a href="#l14.536"></a><span id="l14.536" class="difflineplus">+    case Lexem::ltGroupEnd:</span>
<a href="#l14.537"></a><span id="l14.537" class="difflineplus">+      decoder.EndGroup();</span>
<a href="#l14.538"></a><span id="l14.538" class="difflineplus">+      break;</span>
<a href="#l14.539"></a><span id="l14.539" class="difflineplus">+    case Lexem::ltKeyword:</span>
<a href="#l14.540"></a><span id="l14.540" class="difflineplus">+      decoder.Keyword(lexem.KeywordName(), lexem.KeywordVal());</span>
<a href="#l14.541"></a><span id="l14.541" class="difflineplus">+      break;</span>
<a href="#l14.542"></a><span id="l14.542" class="difflineplus">+    case Lexem::ltPCDATA_W:</span>
<a href="#l14.543"></a><span id="l14.543" class="difflineplus">+      {</span>
<a href="#l14.544"></a><span id="l14.544" class="difflineplus">+        wchar_t ch = lexem.pcdata_w();</span>
<a href="#l14.545"></a><span id="l14.545" class="difflineplus">+        decoder.PCDATA(&amp;ch, 1);</span>
<a href="#l14.546"></a><span id="l14.546" class="difflineplus">+      }</span>
<a href="#l14.547"></a><span id="l14.547" class="difflineplus">+      break;</span>
<a href="#l14.548"></a><span id="l14.548" class="difflineplus">+    case Lexem::ltBDATA:</span>
<a href="#l14.549"></a><span id="l14.549" class="difflineplus">+      decoder.BDATA(lexem.bdata(), lexem.bdata_sz());</span>
<a href="#l14.550"></a><span id="l14.550" class="difflineplus">+      break;</span>
<a href="#l14.551"></a><span id="l14.551" class="difflineplus">+    case Lexem::ltError:</span>
<a href="#l14.552"></a><span id="l14.552" class="difflineplus">+      break; // Just silently skip the erroneous data - basic error recovery</span>
<a href="#l14.553"></a><span id="l14.553" class="difflineplus">+    }</span>
<a href="#l14.554"></a><span id="l14.554" class="difflineplus">+  } // while</span>
<a href="#l14.555"></a><span id="l14.555" class="difflineplus">+} // DecodeRTF</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1">new file mode 100644</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineminus">--- /dev/null</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineplus">+++ b/mailnews/import/outlook/src/rtfDecoder.h</span>
<a href="#l15.4"></a><span id="l15.4" class="difflineat">@@ -0,0 +1,54 @@</span>
<a href="#l15.5"></a><span id="l15.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l15.6"></a><span id="l15.6" class="difflineplus">+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l15.7"></a><span id="l15.7" class="difflineplus">+ *</span>
<a href="#l15.8"></a><span id="l15.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l15.9"></a><span id="l15.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l15.10"></a><span id="l15.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l15.11"></a><span id="l15.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineplus">+ *</span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l15.14"></a><span id="l15.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l15.15"></a><span id="l15.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l15.16"></a><span id="l15.16" class="difflineplus">+ * License.</span>
<a href="#l15.17"></a><span id="l15.17" class="difflineplus">+ *</span>
<a href="#l15.18"></a><span id="l15.18" class="difflineplus">+ * The Original Code is mozilla.org code</span>
<a href="#l15.19"></a><span id="l15.19" class="difflineplus">+ *</span>
<a href="#l15.20"></a><span id="l15.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l15.21"></a><span id="l15.21" class="difflineplus">+ * Mike Kaganski &lt;mikekaganski@gmail.com&gt;.</span>
<a href="#l15.22"></a><span id="l15.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2010</span>
<a href="#l15.23"></a><span id="l15.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l15.24"></a><span id="l15.24" class="difflineplus">+ *</span>
<a href="#l15.25"></a><span id="l15.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l15.26"></a><span id="l15.26" class="difflineplus">+ *</span>
<a href="#l15.27"></a><span id="l15.27" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l15.28"></a><span id="l15.28" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l15.29"></a><span id="l15.29" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l15.30"></a><span id="l15.30" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l15.31"></a><span id="l15.31" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l15.32"></a><span id="l15.32" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l15.33"></a><span id="l15.33" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l15.34"></a><span id="l15.34" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l15.35"></a><span id="l15.35" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l15.36"></a><span id="l15.36" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l15.37"></a><span id="l15.37" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l15.38"></a><span id="l15.38" class="difflineplus">+ *</span>
<a href="#l15.39"></a><span id="l15.39" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l15.40"></a><span id="l15.40" class="difflineplus">+</span>
<a href="#l15.41"></a><span id="l15.41" class="difflineplus">+#include &lt;istream&gt;</span>
<a href="#l15.42"></a><span id="l15.42" class="difflineplus">+</span>
<a href="#l15.43"></a><span id="l15.43" class="difflineplus">+template &lt;size_t len&gt;</span>
<a href="#l15.44"></a><span id="l15.44" class="difflineplus">+inline bool eq(const char* str1, const char (&amp;str2)[len])</span>
<a href="#l15.45"></a><span id="l15.45" class="difflineplus">+{</span>
<a href="#l15.46"></a><span id="l15.46" class="difflineplus">+  return ::strncmp(str1, str2, len) == 0;</span>
<a href="#l15.47"></a><span id="l15.47" class="difflineplus">+};</span>
<a href="#l15.48"></a><span id="l15.48" class="difflineplus">+</span>
<a href="#l15.49"></a><span id="l15.49" class="difflineplus">+class CRTFDecoder {</span>
<a href="#l15.50"></a><span id="l15.50" class="difflineplus">+public:</span>
<a href="#l15.51"></a><span id="l15.51" class="difflineplus">+  virtual void BeginGroup() = 0;</span>
<a href="#l15.52"></a><span id="l15.52" class="difflineplus">+  virtual void EndGroup() = 0;</span>
<a href="#l15.53"></a><span id="l15.53" class="difflineplus">+  virtual void Keyword(const char* name, const int* Val) = 0;</span>
<a href="#l15.54"></a><span id="l15.54" class="difflineplus">+  virtual void PCDATA(const wchar_t* data, size_t cch) = 0;</span>
<a href="#l15.55"></a><span id="l15.55" class="difflineplus">+  virtual void BDATA(const char* data, size_t sz) = 0;</span>
<a href="#l15.56"></a><span id="l15.56" class="difflineplus">+};</span>
<a href="#l15.57"></a><span id="l15.57" class="difflineplus">+</span>
<a href="#l15.58"></a><span id="l15.58" class="difflineplus">+void DecodeRTF(std::istream&amp; rtf, CRTFDecoder&amp; decoder);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1">new file mode 100644</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineminus">--- /dev/null</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineplus">+++ b/mailnews/import/outlook/src/rtfMailDecoder.cpp</span>
<a href="#l16.4"></a><span id="l16.4" class="difflineat">@@ -0,0 +1,111 @@</span>
<a href="#l16.5"></a><span id="l16.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l16.6"></a><span id="l16.6" class="difflineplus">+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l16.7"></a><span id="l16.7" class="difflineplus">+ *</span>
<a href="#l16.8"></a><span id="l16.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l16.9"></a><span id="l16.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l16.10"></a><span id="l16.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l16.11"></a><span id="l16.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l16.12"></a><span id="l16.12" class="difflineplus">+ *</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l16.14"></a><span id="l16.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l16.15"></a><span id="l16.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l16.16"></a><span id="l16.16" class="difflineplus">+ * License.</span>
<a href="#l16.17"></a><span id="l16.17" class="difflineplus">+ *</span>
<a href="#l16.18"></a><span id="l16.18" class="difflineplus">+ * The Original Code is mozilla.org code</span>
<a href="#l16.19"></a><span id="l16.19" class="difflineplus">+ *</span>
<a href="#l16.20"></a><span id="l16.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l16.21"></a><span id="l16.21" class="difflineplus">+ * Mike Kaganski &lt;mikekaganski@gmail.com&gt;.</span>
<a href="#l16.22"></a><span id="l16.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2010</span>
<a href="#l16.23"></a><span id="l16.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l16.24"></a><span id="l16.24" class="difflineplus">+ *</span>
<a href="#l16.25"></a><span id="l16.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l16.26"></a><span id="l16.26" class="difflineplus">+ *</span>
<a href="#l16.27"></a><span id="l16.27" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l16.28"></a><span id="l16.28" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l16.29"></a><span id="l16.29" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l16.30"></a><span id="l16.30" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l16.31"></a><span id="l16.31" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l16.32"></a><span id="l16.32" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l16.33"></a><span id="l16.33" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l16.34"></a><span id="l16.34" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l16.35"></a><span id="l16.35" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l16.36"></a><span id="l16.36" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l16.37"></a><span id="l16.37" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l16.38"></a><span id="l16.38" class="difflineplus">+ *</span>
<a href="#l16.39"></a><span id="l16.39" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l16.40"></a><span id="l16.40" class="difflineplus">+</span>
<a href="#l16.41"></a><span id="l16.41" class="difflineplus">+#include &quot;rtfMailDecoder.h&quot;</span>
<a href="#l16.42"></a><span id="l16.42" class="difflineplus">+</span>
<a href="#l16.43"></a><span id="l16.43" class="difflineplus">+void CRTFMailDecoder::BeginGroup()</span>
<a href="#l16.44"></a><span id="l16.44" class="difflineplus">+{</span>
<a href="#l16.45"></a><span id="l16.45" class="difflineplus">+  ClearState(sAsterisk);</span>
<a href="#l16.46"></a><span id="l16.46" class="difflineplus">+  SetState(sBeginGroup);</span>
<a href="#l16.47"></a><span id="l16.47" class="difflineplus">+  if (m_skipLevel)</span>
<a href="#l16.48"></a><span id="l16.48" class="difflineplus">+    ++m_skipLevel;</span>
<a href="#l16.49"></a><span id="l16.49" class="difflineplus">+}</span>
<a href="#l16.50"></a><span id="l16.50" class="difflineplus">+</span>
<a href="#l16.51"></a><span id="l16.51" class="difflineplus">+void CRTFMailDecoder::EndGroup()</span>
<a href="#l16.52"></a><span id="l16.52" class="difflineplus">+{</span>
<a href="#l16.53"></a><span id="l16.53" class="difflineplus">+  ClearState(sAsterisk|sBeginGroup);</span>
<a href="#l16.54"></a><span id="l16.54" class="difflineplus">+  if (m_skipLevel)</span>
<a href="#l16.55"></a><span id="l16.55" class="difflineplus">+    --m_skipLevel;</span>
<a href="#l16.56"></a><span id="l16.56" class="difflineplus">+}</span>
<a href="#l16.57"></a><span id="l16.57" class="difflineplus">+</span>
<a href="#l16.58"></a><span id="l16.58" class="difflineplus">+void CRTFMailDecoder::AddText(const wchar_t* txt, size_t cch)</span>
<a href="#l16.59"></a><span id="l16.59" class="difflineplus">+{</span>
<a href="#l16.60"></a><span id="l16.60" class="difflineplus">+  if (!IsHtmlRtf()) {</span>
<a href="#l16.61"></a><span id="l16.61" class="difflineplus">+    if (cch == static_cast&lt;size_t&gt;(-1))</span>
<a href="#l16.62"></a><span id="l16.62" class="difflineplus">+      m_text += txt;</span>
<a href="#l16.63"></a><span id="l16.63" class="difflineplus">+    else</span>
<a href="#l16.64"></a><span id="l16.64" class="difflineplus">+      m_text.append(txt, cch);</span>
<a href="#l16.65"></a><span id="l16.65" class="difflineplus">+  }</span>
<a href="#l16.66"></a><span id="l16.66" class="difflineplus">+}</span>
<a href="#l16.67"></a><span id="l16.67" class="difflineplus">+</span>
<a href="#l16.68"></a><span id="l16.68" class="difflineplus">+void CRTFMailDecoder::Keyword(const char* name, const int* Val)</span>
<a href="#l16.69"></a><span id="l16.69" class="difflineplus">+{</span>
<a href="#l16.70"></a><span id="l16.70" class="difflineplus">+  bool asterisk = IsAsterisk(); ClearState(sAsterisk); // for inside use only</span>
<a href="#l16.71"></a><span id="l16.71" class="difflineplus">+  bool beginGroup = IsBeginGroup(); ClearState(sBeginGroup); // for inside use only</span>
<a href="#l16.72"></a><span id="l16.72" class="difflineplus">+  if (!m_skipLevel) {</span>
<a href="#l16.73"></a><span id="l16.73" class="difflineplus">+    if (eq(name, &quot;*&quot;) &amp;&amp; beginGroup) SetState(sAsterisk);</span>
<a href="#l16.74"></a><span id="l16.74" class="difflineplus">+    else if (asterisk) {</span>
<a href="#l16.75"></a><span id="l16.75" class="difflineplus">+      if (eq(name, &quot;htmltag&quot;) &amp;&amp; (m_mode == mHTML)) { // \*\htmltag -&gt; don't ignore; include the following text</span>
<a href="#l16.76"></a><span id="l16.76" class="difflineplus">+      }</span>
<a href="#l16.77"></a><span id="l16.77" class="difflineplus">+      else ++m_skipLevel;</span>
<a href="#l16.78"></a><span id="l16.78" class="difflineplus">+    }</span>
<a href="#l16.79"></a><span id="l16.79" class="difflineplus">+    else if (eq(name, &quot;htmlrtf&quot;)) {</span>
<a href="#l16.80"></a><span id="l16.80" class="difflineplus">+      if (Val &amp;&amp; (*Val==0))</span>
<a href="#l16.81"></a><span id="l16.81" class="difflineplus">+        ClearState(sHtmlRtf);</span>
<a href="#l16.82"></a><span id="l16.82" class="difflineplus">+      else</span>
<a href="#l16.83"></a><span id="l16.83" class="difflineplus">+        SetState(sHtmlRtf);</span>
<a href="#l16.84"></a><span id="l16.84" class="difflineplus">+    }</span>
<a href="#l16.85"></a><span id="l16.85" class="difflineplus">+    else if (eq(name, &quot;par&quot;) || eq(name, &quot;line&quot;)) {</span>
<a href="#l16.86"></a><span id="l16.86" class="difflineplus">+      AddText(L&quot;\r\n&quot;);</span>
<a href="#l16.87"></a><span id="l16.87" class="difflineplus">+    }</span>
<a href="#l16.88"></a><span id="l16.88" class="difflineplus">+    else if (eq(name, &quot;tab&quot;)) {</span>
<a href="#l16.89"></a><span id="l16.89" class="difflineplus">+      AddText(L&quot;\t&quot;);</span>
<a href="#l16.90"></a><span id="l16.90" class="difflineplus">+    }</span>
<a href="#l16.91"></a><span id="l16.91" class="difflineplus">+    else if (eq(name, &quot;rquote&quot;)) {</span>
<a href="#l16.92"></a><span id="l16.92" class="difflineplus">+      AddText(L&quot;\x2019&quot;); // Unicode right single quotation mark</span>
<a href="#l16.93"></a><span id="l16.93" class="difflineplus">+    }</span>
<a href="#l16.94"></a><span id="l16.94" class="difflineplus">+    else if (eq(name, &quot;fromtext&quot;) &amp;&amp; (m_mode==mNone)) { // avoid double &quot;fromX&quot;</span>
<a href="#l16.95"></a><span id="l16.95" class="difflineplus">+      m_mode = mText;</span>
<a href="#l16.96"></a><span id="l16.96" class="difflineplus">+    }</span>
<a href="#l16.97"></a><span id="l16.97" class="difflineplus">+    else if (eq(name, &quot;fromhtml&quot;) &amp;&amp; (m_mode==mNone)) { // avoid double &quot;fromX&quot;</span>
<a href="#l16.98"></a><span id="l16.98" class="difflineplus">+      m_mode = mHTML;</span>
<a href="#l16.99"></a><span id="l16.99" class="difflineplus">+    }</span>
<a href="#l16.100"></a><span id="l16.100" class="difflineplus">+    else if (eq(name, &quot;fonttbl&quot;) || eq(name, &quot;colortbl&quot;) || eq(name, &quot;stylesheet&quot;) || eq(name, &quot;pntext&quot;))</span>
<a href="#l16.101"></a><span id="l16.101" class="difflineplus">+      ++m_skipLevel;</span>
<a href="#l16.102"></a><span id="l16.102" class="difflineplus">+  }</span>
<a href="#l16.103"></a><span id="l16.103" class="difflineplus">+}</span>
<a href="#l16.104"></a><span id="l16.104" class="difflineplus">+</span>
<a href="#l16.105"></a><span id="l16.105" class="difflineplus">+void CRTFMailDecoder::PCDATA(const wchar_t* data, size_t cch)</span>
<a href="#l16.106"></a><span id="l16.106" class="difflineplus">+{</span>
<a href="#l16.107"></a><span id="l16.107" class="difflineplus">+  ClearState(sAsterisk|sBeginGroup);</span>
<a href="#l16.108"></a><span id="l16.108" class="difflineplus">+  if (!m_skipLevel)</span>
<a href="#l16.109"></a><span id="l16.109" class="difflineplus">+    AddText(data, cch);</span>
<a href="#l16.110"></a><span id="l16.110" class="difflineplus">+}</span>
<a href="#l16.111"></a><span id="l16.111" class="difflineplus">+</span>
<a href="#l16.112"></a><span id="l16.112" class="difflineplus">+void CRTFMailDecoder::BDATA(const char* data, size_t sz)</span>
<a href="#l16.113"></a><span id="l16.113" class="difflineplus">+{</span>
<a href="#l16.114"></a><span id="l16.114" class="difflineplus">+  ClearState(sAsterisk|sBeginGroup);</span>
<a href="#l16.115"></a><span id="l16.115" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1">new file mode 100644</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineminus">--- /dev/null</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineplus">+++ b/mailnews/import/outlook/src/rtfMailDecoder.h</span>
<a href="#l17.4"></a><span id="l17.4" class="difflineat">@@ -0,0 +1,72 @@</span>
<a href="#l17.5"></a><span id="l17.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l17.6"></a><span id="l17.6" class="difflineplus">+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l17.7"></a><span id="l17.7" class="difflineplus">+ *</span>
<a href="#l17.8"></a><span id="l17.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l17.9"></a><span id="l17.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l17.10"></a><span id="l17.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l17.11"></a><span id="l17.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineplus">+ *</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l17.14"></a><span id="l17.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l17.15"></a><span id="l17.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l17.16"></a><span id="l17.16" class="difflineplus">+ * License.</span>
<a href="#l17.17"></a><span id="l17.17" class="difflineplus">+ *</span>
<a href="#l17.18"></a><span id="l17.18" class="difflineplus">+ * The Original Code is mozilla.org code</span>
<a href="#l17.19"></a><span id="l17.19" class="difflineplus">+ *</span>
<a href="#l17.20"></a><span id="l17.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l17.21"></a><span id="l17.21" class="difflineplus">+ * Mike Kaganski &lt;mikekaganski@gmail.com&gt;.</span>
<a href="#l17.22"></a><span id="l17.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2010</span>
<a href="#l17.23"></a><span id="l17.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l17.24"></a><span id="l17.24" class="difflineplus">+ *</span>
<a href="#l17.25"></a><span id="l17.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l17.26"></a><span id="l17.26" class="difflineplus">+ *</span>
<a href="#l17.27"></a><span id="l17.27" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l17.28"></a><span id="l17.28" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l17.29"></a><span id="l17.29" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l17.30"></a><span id="l17.30" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l17.31"></a><span id="l17.31" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l17.32"></a><span id="l17.32" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l17.33"></a><span id="l17.33" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l17.34"></a><span id="l17.34" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l17.35"></a><span id="l17.35" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l17.36"></a><span id="l17.36" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l17.37"></a><span id="l17.37" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l17.38"></a><span id="l17.38" class="difflineplus">+ *</span>
<a href="#l17.39"></a><span id="l17.39" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l17.40"></a><span id="l17.40" class="difflineplus">+</span>
<a href="#l17.41"></a><span id="l17.41" class="difflineplus">+#include &lt;string&gt;</span>
<a href="#l17.42"></a><span id="l17.42" class="difflineplus">+#include &quot;rtfDecoder.h&quot;</span>
<a href="#l17.43"></a><span id="l17.43" class="difflineplus">+</span>
<a href="#l17.44"></a><span id="l17.44" class="difflineplus">+class CRTFMailDecoder: public CRTFDecoder {</span>
<a href="#l17.45"></a><span id="l17.45" class="difflineplus">+public:</span>
<a href="#l17.46"></a><span id="l17.46" class="difflineplus">+  enum Mode {mNone, mText, mHTML};</span>
<a href="#l17.47"></a><span id="l17.47" class="difflineplus">+  CRTFMailDecoder() : m_mode(mNone), m_state(sNormal), m_skipLevel(0) {}</span>
<a href="#l17.48"></a><span id="l17.48" class="difflineplus">+  void BeginGroup();</span>
<a href="#l17.49"></a><span id="l17.49" class="difflineplus">+  void EndGroup();</span>
<a href="#l17.50"></a><span id="l17.50" class="difflineplus">+  void Keyword(const char* name, const int* Val);</span>
<a href="#l17.51"></a><span id="l17.51" class="difflineplus">+  void PCDATA(const wchar_t* data, size_t cch);</span>
<a href="#l17.52"></a><span id="l17.52" class="difflineplus">+  void BDATA(const char* data, size_t sz);</span>
<a href="#l17.53"></a><span id="l17.53" class="difflineplus">+  const wchar_t* text() { return m_text.c_str(); }</span>
<a href="#l17.54"></a><span id="l17.54" class="difflineplus">+  std::wstring::size_type textSize() { return m_text.size(); }</span>
<a href="#l17.55"></a><span id="l17.55" class="difflineplus">+  Mode mode() { return m_mode; }</span>
<a href="#l17.56"></a><span id="l17.56" class="difflineplus">+private:</span>
<a href="#l17.57"></a><span id="l17.57" class="difflineplus">+  enum State {sNormal = 0x0000,</span>
<a href="#l17.58"></a><span id="l17.58" class="difflineplus">+              sBeginGroup = 0x0001,</span>
<a href="#l17.59"></a><span id="l17.59" class="difflineplus">+              sAsterisk = 0x0002,</span>
<a href="#l17.60"></a><span id="l17.60" class="difflineplus">+              sHtmlRtf = 0x0004};</span>
<a href="#l17.61"></a><span id="l17.61" class="difflineplus">+</span>
<a href="#l17.62"></a><span id="l17.62" class="difflineplus">+  std::wstring m_text;</span>
<a href="#l17.63"></a><span id="l17.63" class="difflineplus">+  Mode m_mode;</span>
<a href="#l17.64"></a><span id="l17.64" class="difflineplus">+  unsigned int m_state; // bitmask of State</span>
<a href="#l17.65"></a><span id="l17.65" class="difflineplus">+// bool m_beginGroup; // true just after the {</span>
<a href="#l17.66"></a><span id="l17.66" class="difflineplus">+//bool m_asterisk; // true just after the {\*</span>
<a href="#l17.67"></a><span id="l17.67" class="difflineplus">+  int m_skipLevel; // if &gt;0 then we ignore everything</span>
<a href="#l17.68"></a><span id="l17.68" class="difflineplus">+// bool m_htmlrtf;</span>
<a href="#l17.69"></a><span id="l17.69" class="difflineplus">+  inline void SetState(unsigned int s) { m_state |= s; }</span>
<a href="#l17.70"></a><span id="l17.70" class="difflineplus">+  inline void ClearState(unsigned int s) { m_state &amp;= ~s; }</span>
<a href="#l17.71"></a><span id="l17.71" class="difflineplus">+  inline bool CheckState(State s) { return (m_state &amp; s) != 0; }</span>
<a href="#l17.72"></a><span id="l17.72" class="difflineplus">+  inline bool IsAsterisk() { return CheckState(sAsterisk); }</span>
<a href="#l17.73"></a><span id="l17.73" class="difflineplus">+  inline bool IsBeginGroup() { return CheckState(sBeginGroup); }</span>
<a href="#l17.74"></a><span id="l17.74" class="difflineplus">+  inline bool IsHtmlRtf() { return CheckState(sHtmlRtf); }</span>
<a href="#l17.75"></a><span id="l17.75" class="difflineplus">+  void AddText(const wchar_t* txt, size_t cch=static_cast&lt;size_t&gt;(-1));</span>
<a href="#l17.76"></a><span id="l17.76" class="difflineplus">+};</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

