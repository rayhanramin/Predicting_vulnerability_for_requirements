<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 4375:6165f866e8c0995a062a48add1ef8ab23cd67d6e</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 6165f866e8c0995a062a48add1ef8ab23cd67d6e" />
<meta property="og:url" content="/comm-central/rev/6165f866e8c0995a062a48add1ef8ab23cd67d6e" />
<meta property="og:description" content="Bug 527679 - &quot;gloda indexing does not properly handle undone message deletions&quot;. &quot;updated bienvenu's patch, fuses test in. tests pass for me&quot; r=bienvenu,r=asuth,sr=bienvenu,a=blocking-thunderbird3" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 6165f866e8c0995a062a48add1ef8ab23cd67d6e 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/6165f866e8c0995a062a48add1ef8ab23cd67d6e">shortlog</a> |
<a href="/comm-central/log/6165f866e8c0995a062a48add1ef8ab23cd67d6e">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/6165f866e8c0995a062a48add1ef8ab23cd67d6e">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/6165f866e8c0995a062a48add1ef8ab23cd67d6e">files</a> |
changeset |
<a href="/comm-central/raw-rev/6165f866e8c0995a062a48add1ef8ab23cd67d6e">raw</a>  | <a href="/comm-central/archive/6165f866e8c0995a062a48add1ef8ab23cd67d6e.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=527679">Bug 527679</a> - &quot;gloda indexing does not properly handle undone message deletions&quot;. &quot;updated bienvenu's patch, fuses test in. tests pass for me&quot; r=bienvenu,r=asuth,sr=bienvenu,a=blocking-thunderbird3
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#68;&#97;&#118;&#105;&#100;&#32;&#66;&#105;&#101;&#110;&#118;&#101;&#110;&#117;&#32;&#60;&#98;&#105;&#101;&#110;&#118;&#101;&#110;&#117;&#64;&#110;&#118;&#101;&#110;&#116;&#117;&#114;&#101;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Thu, 12 Nov 2009 03:20:16 -0800</td></tr>

<tr>
 <td>changeset 4375</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/6165f866e8c0995a062a48add1ef8ab23cd67d6e">6165f866e8c0995a062a48add1ef8ab23cd67d6e</a></td>
</tr>



<tr>
<td>parent 4374</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/fb2a5d8cb26bbcb79977e9484c99e3daa6a07a20">fb2a5d8cb26bbcb79977e9484c99e3daa6a07a20</a>
</td>
</tr>

<tr>
<td>child 4376</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/ba58af600269b11543d1f97f687029293693f56f">ba58af600269b11543d1f97f687029293693f56f</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=6165f866e8c0995a062a48add1ef8ab23cd67d6e">3421</a></td></tr>
<tr><td>push user</td><td>bugmail@asutherland.org</td></tr>
<tr><td>push date</td><td class="date age">Thu, 12 Nov 2009 11:23:29 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@d60c6eb9a7b3 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=d60c6eb9a7b3b4fada627e0d67a65f972ea1b289">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=d60c6eb9a7b3b4fada627e0d67a65f972ea1b289&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=d60c6eb9a7b3b4fada627e0d67a65f972ea1b289&newProject=comm-central&newRevision=6165f866e8c0995a062a48add1ef8ab23cd67d6e&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=d60c6eb9a7b3b4fada627e0d67a65f972ea1b289&newProject=comm-central&newRevision=6165f866e8c0995a062a48add1ef8ab23cd67d6e&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=d60c6eb9a7b3b4fada627e0d67a65f972ea1b289&newProject=comm-central&newRevision=6165f866e8c0995a062a48add1ef8ab23cd67d6e&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28bienvenu%29&revcount=50">bienvenu</a>, <a href="/comm-central/log?rev=reviewer%28asuth%29&revcount=50">asuth</a>, <a href="/comm-central/log?rev=reviewer%28bienvenu%29&revcount=50">bienvenu</a>, <a href="/comm-central/log?rev=reviewer%28blocking-thunderbird3%29&revcount=50">blocking-thunderbird3</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=527679">527679</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=527679">Bug 527679</a> - &quot;gloda indexing does not properly handle undone message deletions&quot;. &quot;updated bienvenu's patch, fuses test in. tests pass for me&quot; r=bienvenu,r=asuth,sr=bienvenu,a=blocking-thunderbird3</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgDBFolder.cpp">mailnews/base/util/nsMsgDBFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgDBFolder.cpp">file</a> |
<a href="/comm-central/annotate/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgDBFolder.cpp">annotate</a> |
<a href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgDBFolder.cpp">diff</a> |
<a href="/comm-central/comparison/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgDBFolder.cpp">comparison</a> |
<a href="/comm-central/log/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgDBFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgDBFolder.h">mailnews/base/util/nsMsgDBFolder.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgDBFolder.h">file</a> |
<a href="/comm-central/annotate/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgDBFolder.h">annotate</a> |
<a href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgDBFolder.h">diff</a> |
<a href="/comm-central/comparison/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgDBFolder.h">comparison</a> |
<a href="/comm-central/log/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgDBFolder.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgKeySet.cpp">mailnews/base/util/nsMsgKeySet.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgKeySet.cpp">file</a> |
<a href="/comm-central/annotate/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgKeySet.cpp">annotate</a> |
<a href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgKeySet.cpp">diff</a> |
<a href="/comm-central/comparison/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgKeySet.cpp">comparison</a> |
<a href="/comm-central/log/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgKeySet.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgKeySet.h">mailnews/base/util/nsMsgKeySet.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgKeySet.h">file</a> |
<a href="/comm-central/annotate/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgKeySet.h">annotate</a> |
<a href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgKeySet.h">diff</a> |
<a href="/comm-central/comparison/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgKeySet.h">comparison</a> |
<a href="/comm-central/log/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/base/util/nsMsgKeySet.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/modules/index_msg.js">mailnews/db/gloda/modules/index_msg.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/modules/index_msg.js">file</a> |
<a href="/comm-central/annotate/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/modules/index_msg.js">annotate</a> |
<a href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/modules/index_msg.js">diff</a> |
<a href="/comm-central/comparison/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/modules/index_msg.js">comparison</a> |
<a href="/comm-central/log/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/modules/index_msg.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/test/unit/base_index_messages.js">mailnews/db/gloda/test/unit/base_index_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/test/unit/base_index_messages.js">file</a> |
<a href="/comm-central/annotate/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/test/unit/base_index_messages.js">annotate</a> |
<a href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/test/unit/base_index_messages.js">diff</a> |
<a href="/comm-central/comparison/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/test/unit/base_index_messages.js">comparison</a> |
<a href="/comm-central/log/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/test/unit/base_index_messages.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">file</a> |
<a href="/comm-central/annotate/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">annotate</a> |
<a href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">diff</a> |
<a href="/comm-central/comparison/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">comparison</a> |
<a href="/comm-central/log/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/asyncTestUtils.js">mailnews/test/resources/asyncTestUtils.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/asyncTestUtils.js">file</a> |
<a href="/comm-central/annotate/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/asyncTestUtils.js">annotate</a> |
<a href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/asyncTestUtils.js">diff</a> |
<a href="/comm-central/comparison/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/asyncTestUtils.js">comparison</a> |
<a href="/comm-central/log/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/asyncTestUtils.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/messageGenerator.js">mailnews/test/resources/messageGenerator.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/messageGenerator.js">file</a> |
<a href="/comm-central/annotate/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/messageGenerator.js">annotate</a> |
<a href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/messageGenerator.js">diff</a> |
<a href="/comm-central/comparison/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/messageGenerator.js">comparison</a> |
<a href="/comm-central/log/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/messageGenerator.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/messageInjection.js">mailnews/test/resources/messageInjection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/messageInjection.js">file</a> |
<a href="/comm-central/annotate/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/messageInjection.js">annotate</a> |
<a href="/comm-central/diff/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/messageInjection.js">diff</a> |
<a href="/comm-central/comparison/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/messageInjection.js">comparison</a> |
<a href="/comm-central/log/6165f866e8c0995a062a48add1ef8ab23cd67d6e/mailnews/test/resources/messageInjection.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/base/util/nsMsgDBFolder.cpp</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgDBFolder.cpp</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -2188,59 +2188,51 @@ nsMsgDBFolder::OnMessageClassified(const</span>
<a href="#l1.4"></a><span id="l1.4">         // want to propagate that value.)</span>
<a href="#l1.5"></a><span id="l1.5">         rv = filterService-&gt;ApplyFilters(nsMsgFilterType::PostPlugin,</span>
<a href="#l1.6"></a><span id="l1.6">                                          mPostBayesMessagesToFilter,</span>
<a href="#l1.7"></a><span id="l1.7">                                          this, nsnull /* nsIMsgWindow */);</span>
<a href="#l1.8"></a><span id="l1.8">       mPostBayesMessagesToFilter-&gt;Clear();</span>
<a href="#l1.9"></a><span id="l1.9">     }</span>
<a href="#l1.10"></a><span id="l1.10"> </span>
<a href="#l1.11"></a><span id="l1.11">     // Bail if we didn't actually classify any messages.</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-    if (mBayesMsgKeys.IsEmpty())</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+    if (mClassifiedMsgKeys.IsEmpty())</span>
<a href="#l1.14"></a><span id="l1.14">       return rv;</span>
<a href="#l1.15"></a><span id="l1.15"> </span>
<a href="#l1.16"></a><span id="l1.16">     // Notify that we classified some messages.</span>
<a href="#l1.17"></a><span id="l1.17">     nsCOMPtr&lt;nsIMsgFolderNotificationService&gt;</span>
<a href="#l1.18"></a><span id="l1.18">       notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l1.19"></a><span id="l1.19">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.20"></a><span id="l1.20"> </span>
<a href="#l1.21"></a><span id="l1.21">     nsCOMPtr &lt;nsIMutableArray&gt; classifiedMsgHdrs =</span>
<a href="#l1.22"></a><span id="l1.22">       do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv);</span>
<a href="#l1.23"></a><span id="l1.23">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.24"></a><span id="l1.24"> </span>
<a href="#l1.25"></a><span id="l1.25" class="difflineminus">-    PRUint32 numKeys = mBayesMsgKeys.Length();</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineplus">+    PRUint32 numKeys = mClassifiedMsgKeys.Length();</span>
<a href="#l1.27"></a><span id="l1.27">     for (PRUint32 i = 0 ; i &lt; numKeys ; ++i)</span>
<a href="#l1.28"></a><span id="l1.28">     {</span>
<a href="#l1.29"></a><span id="l1.29" class="difflineminus">-      nsMsgKey msgKey = mBayesMsgKeys[i];</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineplus">+      nsMsgKey msgKey = mClassifiedMsgKeys[i];</span>
<a href="#l1.31"></a><span id="l1.31">       PRBool hasKey;</span>
<a href="#l1.32"></a><span id="l1.32">       // It is very possible for a message header to no longer be around because</span>
<a href="#l1.33"></a><span id="l1.33">       // a filter moved it.</span>
<a href="#l1.34"></a><span id="l1.34">       rv = mDatabase-&gt;ContainsKey(msgKey, &amp;hasKey);</span>
<a href="#l1.35"></a><span id="l1.35">       if (!NS_SUCCEEDED(rv) || !hasKey)</span>
<a href="#l1.36"></a><span id="l1.36">         continue;</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineminus">-      // Ignore headers that have already been reported.</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineminus">-      PRUint32 processingFlags;</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineminus">-      GetProcessingFlags(msgKey, &amp;processingFlags);</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineminus">-      if (!(processingFlags &amp; nsMsgProcessingFlags::NotReportedClassified))</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineminus">-        continue;</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineminus">-      // Now the message will have been reported.  Hooray.</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineminus">-      AndProcessingFlags(msgKey, ~nsMsgProcessingFlags::NotReportedClassified);</span>
<a href="#l1.44"></a><span id="l1.44">       nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineminus">-      rv = mDatabase-&gt;GetMsgHdrForKey(mBayesMsgKeys[i],</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineminus">-                                      getter_AddRefs(msgHdr));</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+      rv = mDatabase-&gt;GetMsgHdrForKey(msgKey, getter_AddRefs(msgHdr));</span>
<a href="#l1.48"></a><span id="l1.48">       if (!NS_SUCCEEDED(rv))</span>
<a href="#l1.49"></a><span id="l1.49">         continue;</span>
<a href="#l1.50"></a><span id="l1.50">       classifiedMsgHdrs-&gt;AppendElement(msgHdr, PR_FALSE);</span>
<a href="#l1.51"></a><span id="l1.51">     }</span>
<a href="#l1.52"></a><span id="l1.52"> </span>
<a href="#l1.53"></a><span id="l1.53">     // only generate the notification if there are some classified messages</span>
<a href="#l1.54"></a><span id="l1.54">     if (NS_SUCCEEDED(classifiedMsgHdrs-&gt;GetLength(&amp;length)) &amp;&amp; length)</span>
<a href="#l1.55"></a><span id="l1.55">       notifier-&gt;NotifyMsgsClassified(classifiedMsgHdrs,</span>
<a href="#l1.56"></a><span id="l1.56">                                      mBayesJunkClassifying,</span>
<a href="#l1.57"></a><span id="l1.57">                                      mBayesTraitClassifying);</span>
<a href="#l1.58"></a><span id="l1.58" class="difflineminus">-    mBayesMsgKeys.Clear();</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineplus">+    mClassifiedMsgKeys.Clear();</span>
<a href="#l1.60"></a><span id="l1.60"> </span>
<a href="#l1.61"></a><span id="l1.61">     return rv;</span>
<a href="#l1.62"></a><span id="l1.62">   }</span>
<a href="#l1.63"></a><span id="l1.63"> </span>
<a href="#l1.64"></a><span id="l1.64">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l1.65"></a><span id="l1.65">   nsresult rv = GetServer(getter_AddRefs(server));</span>
<a href="#l1.66"></a><span id="l1.66">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.67"></a><span id="l1.67"> </span>
<a href="#l1.68"></a><span id="l1.68" class="difflineat">@@ -2257,16 +2249,17 @@ nsMsgDBFolder::OnMessageClassified(const</span>
<a href="#l1.69"></a><span id="l1.69">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.70"></a><span id="l1.70"> </span>
<a href="#l1.71"></a><span id="l1.71">   // check if this message needs junk classification</span>
<a href="#l1.72"></a><span id="l1.72">   PRUint32 processingFlags;</span>
<a href="#l1.73"></a><span id="l1.73">   GetProcessingFlags(msgKey, &amp;processingFlags);</span>
<a href="#l1.74"></a><span id="l1.74"> </span>
<a href="#l1.75"></a><span id="l1.75">   if (processingFlags &amp; nsMsgProcessingFlags::ClassifyJunk)</span>
<a href="#l1.76"></a><span id="l1.76">   {</span>
<a href="#l1.77"></a><span id="l1.77" class="difflineplus">+    mClassifiedMsgKeys.AppendElement(msgKey);</span>
<a href="#l1.78"></a><span id="l1.78">     AndProcessingFlags(msgKey, ~nsMsgProcessingFlags::ClassifyJunk);</span>
<a href="#l1.79"></a><span id="l1.79"> </span>
<a href="#l1.80"></a><span id="l1.80">     nsCAutoString msgJunkScore;</span>
<a href="#l1.81"></a><span id="l1.81">     msgJunkScore.AppendInt(aClassification == nsIJunkMailPlugin::JUNK ?</span>
<a href="#l1.82"></a><span id="l1.82">           nsIJunkMailPlugin::IS_SPAM_SCORE:</span>
<a href="#l1.83"></a><span id="l1.83">           nsIJunkMailPlugin::IS_HAM_SCORE);</span>
<a href="#l1.84"></a><span id="l1.84">     mDatabase-&gt;SetStringProperty(msgKey, &quot;junkscore&quot;, msgJunkScore.get());</span>
<a href="#l1.85"></a><span id="l1.85">     mDatabase-&gt;SetStringProperty(msgKey, &quot;junkscoreorigin&quot;, &quot;plugin&quot;);</span>
<a href="#l1.86"></a><span id="l1.86" class="difflineat">@@ -2494,16 +2487,25 @@ nsMsgDBFolder::CallFilterPlugins(nsIMsgW</span>
<a href="#l1.87"></a><span id="l1.87">       PRBool enabled = PR_FALSE;</span>
<a href="#l1.88"></a><span id="l1.88">       filter-&gt;GetEnabled(&amp;enabled);</span>
<a href="#l1.89"></a><span id="l1.89">       if (!enabled)</span>
<a href="#l1.90"></a><span id="l1.90">         continue;</span>
<a href="#l1.91"></a><span id="l1.91">       filterPostPlugin = PR_TRUE;</span>
<a href="#l1.92"></a><span id="l1.92">     }</span>
<a href="#l1.93"></a><span id="l1.93">   }</span>
<a href="#l1.94"></a><span id="l1.94"> </span>
<a href="#l1.95"></a><span id="l1.95" class="difflineplus">+  // If there is nothing to do, leave now but let NotifyHdrsNotBeingClassified</span>
<a href="#l1.96"></a><span id="l1.96" class="difflineplus">+  // generate the msgsClassified notification for all newly added messages as</span>
<a href="#l1.97"></a><span id="l1.97" class="difflineplus">+  // tracked by the NotReportedClassified processing flag.</span>
<a href="#l1.98"></a><span id="l1.98" class="difflineplus">+  if (!filterForOther &amp;&amp; !filterForJunk &amp;&amp; !filterPostPlugin)</span>
<a href="#l1.99"></a><span id="l1.99" class="difflineplus">+  {</span>
<a href="#l1.100"></a><span id="l1.100" class="difflineplus">+    NotifyHdrsNotBeingClassified();</span>
<a href="#l1.101"></a><span id="l1.101" class="difflineplus">+    return NS_OK;</span>
<a href="#l1.102"></a><span id="l1.102" class="difflineplus">+  }</span>
<a href="#l1.103"></a><span id="l1.103" class="difflineplus">+</span>
<a href="#l1.104"></a><span id="l1.104">   // get the list of new messages</span>
<a href="#l1.105"></a><span id="l1.105">   //</span>
<a href="#l1.106"></a><span id="l1.106">   PRUint32 numNewKeys;</span>
<a href="#l1.107"></a><span id="l1.107">   PRUint32 *newKeys;</span>
<a href="#l1.108"></a><span id="l1.108">   rv = mDatabase-&gt;GetNewList(&amp;numNewKeys, &amp;newKeys);</span>
<a href="#l1.109"></a><span id="l1.109">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.110"></a><span id="l1.110"> </span>
<a href="#l1.111"></a><span id="l1.111">   nsTArray&lt;nsMsgKey&gt; newMessageKeys;</span>
<a href="#l1.112"></a><span id="l1.112" class="difflineat">@@ -2511,65 +2513,19 @@ nsMsgDBFolder::CallFilterPlugins(nsIMsgW</span>
<a href="#l1.113"></a><span id="l1.113">   // where we stash the list of new messages when we are told to clear the list</span>
<a href="#l1.114"></a><span id="l1.114">   // of new messages by the UI (which purges the list from the nsMsgDatabase).</span>
<a href="#l1.115"></a><span id="l1.115">   newMessageKeys.SwapElements(m_saveNewMsgs);</span>
<a href="#l1.116"></a><span id="l1.116">   if (numNewKeys)</span>
<a href="#l1.117"></a><span id="l1.117">     newMessageKeys.AppendElements(newKeys, numNewKeys);</span>
<a href="#l1.118"></a><span id="l1.118"> </span>
<a href="#l1.119"></a><span id="l1.119">   NS_Free(newKeys);</span>
<a href="#l1.120"></a><span id="l1.120"> </span>
<a href="#l1.121"></a><span id="l1.121" class="difflineminus">-  // if there weren't any, just return</span>
<a href="#l1.122"></a><span id="l1.122" class="difflineminus">-  if (newMessageKeys.IsEmpty())</span>
<a href="#l1.123"></a><span id="l1.123" class="difflineminus">-    return NS_OK;</span>
<a href="#l1.124"></a><span id="l1.124" class="difflineminus">-</span>
<a href="#l1.125"></a><span id="l1.125" class="difflineminus">-  // If we do not need to do any work, leave.</span>
<a href="#l1.126"></a><span id="l1.126" class="difflineminus">-  // (We needed to get the list of new messages so we could get their headers so</span>
<a href="#l1.127"></a><span id="l1.127" class="difflineminus">-  // we can send notifications about them here.)</span>
<a href="#l1.128"></a><span id="l1.128" class="difflineminus">-  if (!filterForOther &amp;&amp; !filterForJunk &amp;&amp; !filterPostPlugin)</span>
<a href="#l1.129"></a><span id="l1.129" class="difflineminus">-  {</span>
<a href="#l1.130"></a><span id="l1.130" class="difflineminus">-    // notify that these messages are not being classified</span>
<a href="#l1.131"></a><span id="l1.131" class="difflineminus">-    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt;</span>
<a href="#l1.132"></a><span id="l1.132" class="difflineminus">-      notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l1.133"></a><span id="l1.133" class="difflineminus">-    if (notifier)</span>
<a href="#l1.134"></a><span id="l1.134" class="difflineminus">-    {</span>
<a href="#l1.135"></a><span id="l1.135" class="difflineminus">-      nsCOMPtr &lt;nsIMutableArray&gt; newMsgHdrs =</span>
<a href="#l1.136"></a><span id="l1.136" class="difflineminus">-        do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv);</span>
<a href="#l1.137"></a><span id="l1.137" class="difflineminus">-      NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.138"></a><span id="l1.138" class="difflineminus">-</span>
<a href="#l1.139"></a><span id="l1.139" class="difflineminus">-      PRUint32 numNewMessages = newMessageKeys.Length();</span>
<a href="#l1.140"></a><span id="l1.140" class="difflineminus">-      for (PRUint32 i = 0 ; i &lt; numNewMessages ; ++i)</span>
<a href="#l1.141"></a><span id="l1.141" class="difflineminus">-      {</span>
<a href="#l1.142"></a><span id="l1.142" class="difflineminus">-        nsMsgKey msgKey = newMessageKeys[i];</span>
<a href="#l1.143"></a><span id="l1.143" class="difflineminus">-        // Ignore headers that have already been reported.</span>
<a href="#l1.144"></a><span id="l1.144" class="difflineminus">-        PRUint32 processingFlags;</span>
<a href="#l1.145"></a><span id="l1.145" class="difflineminus">-        GetProcessingFlags(msgKey, &amp;processingFlags);</span>
<a href="#l1.146"></a><span id="l1.146" class="difflineminus">-        if (!(processingFlags &amp; nsMsgProcessingFlags::NotReportedClassified))</span>
<a href="#l1.147"></a><span id="l1.147" class="difflineminus">-          continue;</span>
<a href="#l1.148"></a><span id="l1.148" class="difflineminus">-        // Now the message will have been reported.  Hooray.</span>
<a href="#l1.149"></a><span id="l1.149" class="difflineminus">-        AndProcessingFlags(msgKey, ~nsMsgProcessingFlags::NotReportedClassified);</span>
<a href="#l1.150"></a><span id="l1.150" class="difflineminus">-</span>
<a href="#l1.151"></a><span id="l1.151" class="difflineminus">-        // We do not need to do a ContainsKey check here; nothing could have</span>
<a href="#l1.152"></a><span id="l1.152" class="difflineminus">-        // changed yet.</span>
<a href="#l1.153"></a><span id="l1.153" class="difflineminus">-        nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l1.154"></a><span id="l1.154" class="difflineminus">-        rv = mDatabase-&gt;GetMsgHdrForKey(msgKey, getter_AddRefs(msgHdr));</span>
<a href="#l1.155"></a><span id="l1.155" class="difflineminus">-        if (!NS_SUCCEEDED(rv))</span>
<a href="#l1.156"></a><span id="l1.156" class="difflineminus">-          continue;</span>
<a href="#l1.157"></a><span id="l1.157" class="difflineminus">-        newMsgHdrs-&gt;AppendElement(msgHdr, PR_FALSE);</span>
<a href="#l1.158"></a><span id="l1.158" class="difflineminus">-      }</span>
<a href="#l1.159"></a><span id="l1.159" class="difflineminus">-      PRUint32 length;</span>
<a href="#l1.160"></a><span id="l1.160" class="difflineminus">-      if (NS_SUCCEEDED(newMsgHdrs-&gt;GetLength(&amp;length)) &amp;&amp; length)</span>
<a href="#l1.161"></a><span id="l1.161" class="difflineminus">-        notifier-&gt;NotifyMsgsClassified(newMsgHdrs, filterForJunk,</span>
<a href="#l1.162"></a><span id="l1.162" class="difflineminus">-                                       filterForOther);</span>
<a href="#l1.163"></a><span id="l1.163" class="difflineminus">-    }</span>
<a href="#l1.164"></a><span id="l1.164" class="difflineminus">-    return NS_OK;</span>
<a href="#l1.165"></a><span id="l1.165" class="difflineminus">-  }</span>
<a href="#l1.166"></a><span id="l1.166" class="difflineminus">-</span>
<a href="#l1.167"></a><span id="l1.167">   // build up list of keys to classify</span>
<a href="#l1.168"></a><span id="l1.168" class="difflineplus">+  nsTArray&lt;nsMsgKey&gt; classifyMsgKeys;</span>
<a href="#l1.169"></a><span id="l1.169">   nsCString uri;</span>
<a href="#l1.170"></a><span id="l1.170" class="difflineminus">-  nsCOMPtr&lt;nsIMutableArray&gt; msgHdrsNotBeingClassified; // create on demand</span>
<a href="#l1.171"></a><span id="l1.171"> </span>
<a href="#l1.172"></a><span id="l1.172">   PRUint32 numNewMessages = newMessageKeys.Length();</span>
<a href="#l1.173"></a><span id="l1.173">   for (PRUint32 i = 0 ; i &lt; numNewMessages ; ++i)</span>
<a href="#l1.174"></a><span id="l1.174">   {</span>
<a href="#l1.175"></a><span id="l1.175">     nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l1.176"></a><span id="l1.176">     nsMsgKey msgKey = newMessageKeys[i];</span>
<a href="#l1.177"></a><span id="l1.177">     rv = mDatabase-&gt;GetMsgHdrForKey(msgKey, getter_AddRefs(msgHdr));</span>
<a href="#l1.178"></a><span id="l1.178">     if (!NS_SUCCEEDED(rv))</span>
<a href="#l1.179"></a><span id="l1.179" class="difflineat">@@ -2591,98 +2547,90 @@ nsMsgDBFolder::CallFilterPlugins(nsIMsgW</span>
<a href="#l1.180"></a><span id="l1.180"> </span>
<a href="#l1.181"></a><span id="l1.181">         nsCAutoString msgJunkScore;</span>
<a href="#l1.182"></a><span id="l1.182">         msgJunkScore.AppendInt(nsIJunkMailPlugin::IS_HAM_SCORE);</span>
<a href="#l1.183"></a><span id="l1.183">         mDatabase-&gt;SetStringProperty(msgKey, &quot;junkscore&quot;, msgJunkScore.get());</span>
<a href="#l1.184"></a><span id="l1.184">         mDatabase-&gt;SetStringProperty(msgKey, &quot;junkscoreorigin&quot;, &quot;whitelist&quot;);</span>
<a href="#l1.185"></a><span id="l1.185">         break; // skip this msg since it's in the white list</span>
<a href="#l1.186"></a><span id="l1.186">       }</span>
<a href="#l1.187"></a><span id="l1.187">       filterMessageForJunk = PR_TRUE;</span>
<a href="#l1.188"></a><span id="l1.188" class="difflineplus">+</span>
<a href="#l1.189"></a><span id="l1.189" class="difflineplus">+      OrProcessingFlags(msgKey, nsMsgProcessingFlags::ClassifyJunk);</span>
<a href="#l1.190"></a><span id="l1.190" class="difflineplus">+      // Since we are junk processing, we want to defer the msgsClassified</span>
<a href="#l1.191"></a><span id="l1.191" class="difflineplus">+      // notification until the junk classification has occurred.  The event</span>
<a href="#l1.192"></a><span id="l1.192" class="difflineplus">+      // is sufficiently reliable that we know this will be handled in</span>
<a href="#l1.193"></a><span id="l1.193" class="difflineplus">+      // OnMessageClassified at the end of the batch.  We clear the</span>
<a href="#l1.194"></a><span id="l1.194" class="difflineplus">+      // NotReportedClassified flag since we know the message is in good hands.</span>
<a href="#l1.195"></a><span id="l1.195" class="difflineplus">+      AndProcessingFlags(msgKey, ~nsMsgProcessingFlags::NotReportedClassified);</span>
<a href="#l1.196"></a><span id="l1.196">       break;</span>
<a href="#l1.197"></a><span id="l1.197">     }</span>
<a href="#l1.198"></a><span id="l1.198"> </span>
<a href="#l1.199"></a><span id="l1.199">     PRUint32 processingFlags;</span>
<a href="#l1.200"></a><span id="l1.200">     GetProcessingFlags(msgKey, &amp;processingFlags);</span>
<a href="#l1.201"></a><span id="l1.201"> </span>
<a href="#l1.202"></a><span id="l1.202" class="difflineplus">+    PRBool filterMessageForOther = PR_FALSE;</span>
<a href="#l1.203"></a><span id="l1.203">     // trait processing</span>
<a href="#l1.204"></a><span id="l1.204" class="difflineminus">-    PRBool filterMessageForOther = PR_FALSE;</span>
<a href="#l1.205"></a><span id="l1.205">     if (!(processingFlags &amp; nsMsgProcessingFlags::TraitsDone))</span>
<a href="#l1.206"></a><span id="l1.206">     {</span>
<a href="#l1.207"></a><span id="l1.207">       // don't do trait processing on this message again</span>
<a href="#l1.208"></a><span id="l1.208">       OrProcessingFlags(msgKey, nsMsgProcessingFlags::TraitsDone);</span>
<a href="#l1.209"></a><span id="l1.209">       if (filterForOther)</span>
<a href="#l1.210"></a><span id="l1.210" class="difflineplus">+      {</span>
<a href="#l1.211"></a><span id="l1.211">         filterMessageForOther = PR_TRUE;</span>
<a href="#l1.212"></a><span id="l1.212" class="difflineplus">+        OrProcessingFlags(msgKey, nsMsgProcessingFlags::ClassifyTraits);</span>
<a href="#l1.213"></a><span id="l1.213" class="difflineplus">+      }</span>
<a href="#l1.214"></a><span id="l1.214">     }</span>
<a href="#l1.215"></a><span id="l1.215"> </span>
<a href="#l1.216"></a><span id="l1.216">     if (filterMessageForJunk || filterMessageForOther)</span>
<a href="#l1.217"></a><span id="l1.217" class="difflineminus">-    {</span>
<a href="#l1.218"></a><span id="l1.218" class="difflineminus">-      mBayesMsgKeys.AppendElement(newMessageKeys[i]);</span>
<a href="#l1.219"></a><span id="l1.219" class="difflineminus">-      if (filterMessageForJunk)</span>
<a href="#l1.220"></a><span id="l1.220" class="difflineminus">-        OrProcessingFlags(msgKey, nsMsgProcessingFlags::ClassifyJunk);</span>
<a href="#l1.221"></a><span id="l1.221" class="difflineminus">-      if (filterMessageForOther)</span>
<a href="#l1.222"></a><span id="l1.222" class="difflineminus">-        OrProcessingFlags(msgKey, nsMsgProcessingFlags::ClassifyTraits);</span>
<a href="#l1.223"></a><span id="l1.223" class="difflineminus">-    }</span>
<a href="#l1.224"></a><span id="l1.224" class="difflineminus">-    // Accumulate the message header for immediate classified notification</span>
<a href="#l1.225"></a><span id="l1.225" class="difflineminus">-    // that we are not classifying it if it has not already been reported.</span>
<a href="#l1.226"></a><span id="l1.226" class="difflineminus">-    else if (processingFlags &amp; nsMsgProcessingFlags::NotReportedClassified)</span>
<a href="#l1.227"></a><span id="l1.227" class="difflineminus">-    {</span>
<a href="#l1.228"></a><span id="l1.228" class="difflineminus">-      // Now the message will have been reported.  Hooray.</span>
<a href="#l1.229"></a><span id="l1.229" class="difflineminus">-      AndProcessingFlags(msgKey, ~nsMsgProcessingFlags::NotReportedClassified);</span>
<a href="#l1.230"></a><span id="l1.230" class="difflineminus">-      if (!msgHdrsNotBeingClassified)</span>
<a href="#l1.231"></a><span id="l1.231" class="difflineminus">-        msgHdrsNotBeingClassified = do_CreateInstance(NS_ARRAY_CONTRACTID);</span>
<a href="#l1.232"></a><span id="l1.232" class="difflineminus">-      if (!msgHdrsNotBeingClassified)</span>
<a href="#l1.233"></a><span id="l1.233" class="difflineminus">-        return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l1.234"></a><span id="l1.234" class="difflineminus">-</span>
<a href="#l1.235"></a><span id="l1.235" class="difflineminus">-      msgHdrsNotBeingClassified-&gt;AppendElement(msgHdr, PR_FALSE);</span>
<a href="#l1.236"></a><span id="l1.236" class="difflineminus">-    }</span>
<a href="#l1.237"></a><span id="l1.237" class="difflineplus">+      classifyMsgKeys.AppendElement(newMessageKeys[i]);</span>
<a href="#l1.238"></a><span id="l1.238"> </span>
<a href="#l1.239"></a><span id="l1.239">     // Set messages to filter post-bayes.</span>
<a href="#l1.240"></a><span id="l1.240">     // Have we already filtered this message?</span>
<a href="#l1.241"></a><span id="l1.241">     if (!(processingFlags &amp; nsMsgProcessingFlags::FiltersDone))</span>
<a href="#l1.242"></a><span id="l1.242">     {</span>
<a href="#l1.243"></a><span id="l1.243" class="difflineminus">-      // Don't do filters on this message again.</span>
<a href="#l1.244"></a><span id="l1.244" class="difflineminus">-      OrProcessingFlags(msgKey, nsMsgProcessingFlags::FiltersDone);</span>
<a href="#l1.245"></a><span id="l1.245">       if (filterPostPlugin)</span>
<a href="#l1.246"></a><span id="l1.246">       {</span>
<a href="#l1.247"></a><span id="l1.247" class="difflineplus">+        // Don't do filters on this message again.</span>
<a href="#l1.248"></a><span id="l1.248" class="difflineplus">+        // (Only set this if we are actually filtering since this is</span>
<a href="#l1.249"></a><span id="l1.249" class="difflineplus">+        // tantamount to a memory leak.)</span>
<a href="#l1.250"></a><span id="l1.250" class="difflineplus">+        OrProcessingFlags(msgKey, nsMsgProcessingFlags::FiltersDone);</span>
<a href="#l1.251"></a><span id="l1.251">         // Lazily create the array.</span>
<a href="#l1.252"></a><span id="l1.252">         if (!mPostBayesMessagesToFilter)</span>
<a href="#l1.253"></a><span id="l1.253">           mPostBayesMessagesToFilter = do_CreateInstance(NS_ARRAY_CONTRACTID);</span>
<a href="#l1.254"></a><span id="l1.254">         mPostBayesMessagesToFilter-&gt;AppendElement(msgHdr, PR_FALSE);</span>
<a href="#l1.255"></a><span id="l1.255">       }</span>
<a href="#l1.256"></a><span id="l1.256">     }</span>
<a href="#l1.257"></a><span id="l1.257">   }</span>
<a href="#l1.258"></a><span id="l1.258"> </span>
<a href="#l1.259"></a><span id="l1.259" class="difflineminus">-  // If we have any headers not being classified, notify about them.</span>
<a href="#l1.260"></a><span id="l1.260" class="difflineminus">-  if (msgHdrsNotBeingClassified)</span>
<a href="#l1.261"></a><span id="l1.261" class="difflineminus">-  {</span>
<a href="#l1.262"></a><span id="l1.262" class="difflineminus">-    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt;</span>
<a href="#l1.263"></a><span id="l1.263" class="difflineminus">-      notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l1.264"></a><span id="l1.264" class="difflineminus">-    if (notifier)</span>
<a href="#l1.265"></a><span id="l1.265" class="difflineminus">-      notifier-&gt;NotifyMsgsClassified(msgHdrsNotBeingClassified,</span>
<a href="#l1.266"></a><span id="l1.266" class="difflineminus">-                                     // no classification is being performed</span>
<a href="#l1.267"></a><span id="l1.267" class="difflineminus">-                                     PR_FALSE, PR_FALSE);</span>
<a href="#l1.268"></a><span id="l1.268" class="difflineminus">-  }</span>
<a href="#l1.269"></a><span id="l1.269" class="difflineminus">-</span>
<a href="#l1.270"></a><span id="l1.270" class="difflineminus">-  if (!mBayesMsgKeys.IsEmpty())</span>
<a href="#l1.271"></a><span id="l1.271" class="difflineplus">+  NotifyHdrsNotBeingClassified();</span>
<a href="#l1.272"></a><span id="l1.272" class="difflineplus">+  // If there weren't any new messages, just return.</span>
<a href="#l1.273"></a><span id="l1.273" class="difflineplus">+  if (newMessageKeys.IsEmpty())</span>
<a href="#l1.274"></a><span id="l1.274" class="difflineplus">+    return NS_OK;</span>
<a href="#l1.275"></a><span id="l1.275" class="difflineplus">+</span>
<a href="#l1.276"></a><span id="l1.276" class="difflineplus">+  // If we do not need to do any work, leave.</span>
<a href="#l1.277"></a><span id="l1.277" class="difflineplus">+  // (We needed to get the list of new messages so we could get their headers so</span>
<a href="#l1.278"></a><span id="l1.278" class="difflineplus">+  // we can send notifications about them here.)</span>
<a href="#l1.279"></a><span id="l1.279" class="difflineplus">+</span>
<a href="#l1.280"></a><span id="l1.280" class="difflineplus">+  if (!classifyMsgKeys.IsEmpty())</span>
<a href="#l1.281"></a><span id="l1.281">   {</span>
<a href="#l1.282"></a><span id="l1.282">     // Remember what classifications are the source of this decision for when</span>
<a href="#l1.283"></a><span id="l1.283">     // we perform the notification in OnMessageClassified at the conclusion of</span>
<a href="#l1.284"></a><span id="l1.284">     // classification.</span>
<a href="#l1.285"></a><span id="l1.285">     mBayesJunkClassifying = filterForJunk;</span>
<a href="#l1.286"></a><span id="l1.286">     mBayesTraitClassifying = filterForOther;</span>
<a href="#l1.287"></a><span id="l1.287"> </span>
<a href="#l1.288"></a><span id="l1.288" class="difflineminus">-    PRUint32 numMessagesToClassify = mBayesMsgKeys.Length();</span>
<a href="#l1.289"></a><span id="l1.289" class="difflineplus">+    PRUint32 numMessagesToClassify = classifyMsgKeys.Length();</span>
<a href="#l1.290"></a><span id="l1.290">     char ** messageURIs = (char **) PR_MALLOC(sizeof(const char *) * numMessagesToClassify);</span>
<a href="#l1.291"></a><span id="l1.291">     if (!messageURIs)</span>
<a href="#l1.292"></a><span id="l1.292">       return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l1.293"></a><span id="l1.293"> </span>
<a href="#l1.294"></a><span id="l1.294">     for (PRUint32 msgIndex = 0; msgIndex &lt; numMessagesToClassify ; ++msgIndex )</span>
<a href="#l1.295"></a><span id="l1.295">     {</span>
<a href="#l1.296"></a><span id="l1.296">       nsCString tmpStr;</span>
<a href="#l1.297"></a><span id="l1.297" class="difflineminus">-      rv = GenerateMessageURI(mBayesMsgKeys[msgIndex], tmpStr);</span>
<a href="#l1.298"></a><span id="l1.298" class="difflineplus">+      rv = GenerateMessageURI(classifyMsgKeys[msgIndex], tmpStr);</span>
<a href="#l1.299"></a><span id="l1.299">       messageURIs[msgIndex] = ToNewCString(tmpStr);</span>
<a href="#l1.300"></a><span id="l1.300">       if (NS_FAILED(rv))</span>
<a href="#l1.301"></a><span id="l1.301">           NS_WARNING(&quot;nsMsgDBFolder::CallFilterPlugins(): could not&quot;</span>
<a href="#l1.302"></a><span id="l1.302">                      &quot; generate URI for message&quot;);</span>
<a href="#l1.303"></a><span id="l1.303">     }</span>
<a href="#l1.304"></a><span id="l1.304">     // filterMsgs</span>
<a href="#l1.305"></a><span id="l1.305">     *aFiltersRun = PR_TRUE;</span>
<a href="#l1.306"></a><span id="l1.306">     rv = SpamFilterClassifyMessages((const char **) messageURIs, numMessagesToClassify, aMsgWindow, junkMailPlugin);</span>
<a href="#l1.307"></a><span id="l1.307" class="difflineat">@@ -2697,16 +2645,51 @@ nsMsgDBFolder::CallFilterPlugins(nsIMsgW</span>
<a href="#l1.308"></a><span id="l1.308">     // disabled junk processing, which could be dynamic through whitelisting,</span>
<a href="#l1.309"></a><span id="l1.309">     // makes the bayes analysis unnecessary.</span>
<a href="#l1.310"></a><span id="l1.310">     OnMessageClassified(nsnull, nsnull, nsnull);</span>
<a href="#l1.311"></a><span id="l1.311">   }</span>
<a href="#l1.312"></a><span id="l1.312"> </span>
<a href="#l1.313"></a><span id="l1.313">   return rv;</span>
<a href="#l1.314"></a><span id="l1.314"> }</span>
<a href="#l1.315"></a><span id="l1.315"> </span>
<a href="#l1.316"></a><span id="l1.316" class="difflineplus">+/**</span>
<a href="#l1.317"></a><span id="l1.317" class="difflineplus">+ * Adds the messages in the NotReportedClassified mProcessing set to the</span>
<a href="#l1.318"></a><span id="l1.318" class="difflineplus">+ * (possibly empty) array of msgHdrsNotBeingClassified, and send the</span>
<a href="#l1.319"></a><span id="l1.319" class="difflineplus">+ * nsIMsgFolderNotificationService notification.</span>
<a href="#l1.320"></a><span id="l1.320" class="difflineplus">+ */</span>
<a href="#l1.321"></a><span id="l1.321" class="difflineplus">+nsresult nsMsgDBFolder::NotifyHdrsNotBeingClassified()</span>
<a href="#l1.322"></a><span id="l1.322" class="difflineplus">+{</span>
<a href="#l1.323"></a><span id="l1.323" class="difflineplus">+  nsCOMPtr&lt;nsIMutableArray&gt; msgHdrsNotBeingClassified;</span>
<a href="#l1.324"></a><span id="l1.324" class="difflineplus">+</span>
<a href="#l1.325"></a><span id="l1.325" class="difflineplus">+  if (mProcessingFlag[5].keys)</span>
<a href="#l1.326"></a><span id="l1.326" class="difflineplus">+  {</span>
<a href="#l1.327"></a><span id="l1.327" class="difflineplus">+    nsTArray&lt;nsMsgKey&gt; keys;</span>
<a href="#l1.328"></a><span id="l1.328" class="difflineplus">+    mProcessingFlag[5].keys-&gt;ToMsgKeyArray(keys);</span>
<a href="#l1.329"></a><span id="l1.329" class="difflineplus">+    if (keys.Length())</span>
<a href="#l1.330"></a><span id="l1.330" class="difflineplus">+    {</span>
<a href="#l1.331"></a><span id="l1.331" class="difflineplus">+      msgHdrsNotBeingClassified = do_CreateInstance(NS_ARRAY_CONTRACTID);</span>
<a href="#l1.332"></a><span id="l1.332" class="difflineplus">+      if (!msgHdrsNotBeingClassified)</span>
<a href="#l1.333"></a><span id="l1.333" class="difflineplus">+        return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l1.334"></a><span id="l1.334" class="difflineplus">+      MsgGetHeadersFromKeys(mDatabase, keys, msgHdrsNotBeingClassified);</span>
<a href="#l1.335"></a><span id="l1.335" class="difflineplus">+</span>
<a href="#l1.336"></a><span id="l1.336" class="difflineplus">+      // Since we know we've handled all the NotReportedClassified messages,</span>
<a href="#l1.337"></a><span id="l1.337" class="difflineplus">+      // we clear the set by deleting and recreating it.</span>
<a href="#l1.338"></a><span id="l1.338" class="difflineplus">+      delete mProcessingFlag[5].keys;</span>
<a href="#l1.339"></a><span id="l1.339" class="difflineplus">+      mProcessingFlag[5].keys = nsMsgKeySetU::Create();</span>
<a href="#l1.340"></a><span id="l1.340" class="difflineplus">+      nsCOMPtr&lt;nsIMsgFolderNotificationService&gt;</span>
<a href="#l1.341"></a><span id="l1.341" class="difflineplus">+        notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l1.342"></a><span id="l1.342" class="difflineplus">+      if (notifier)</span>
<a href="#l1.343"></a><span id="l1.343" class="difflineplus">+        notifier-&gt;NotifyMsgsClassified(msgHdrsNotBeingClassified,</span>
<a href="#l1.344"></a><span id="l1.344" class="difflineplus">+                                       // no classification is being performed</span>
<a href="#l1.345"></a><span id="l1.345" class="difflineplus">+                                       PR_FALSE, PR_FALSE);</span>
<a href="#l1.346"></a><span id="l1.346" class="difflineplus">+    }</span>
<a href="#l1.347"></a><span id="l1.347" class="difflineplus">+  }</span>
<a href="#l1.348"></a><span id="l1.348" class="difflineplus">+  return NS_OK;</span>
<a href="#l1.349"></a><span id="l1.349" class="difflineplus">+}</span>
<a href="#l1.350"></a><span id="l1.350" class="difflineplus">+</span>
<a href="#l1.351"></a><span id="l1.351"> NS_IMETHODIMP</span>
<a href="#l1.352"></a><span id="l1.352"> nsMsgDBFolder::GetLastMessageLoaded(nsMsgKey *aMsgKey)</span>
<a href="#l1.353"></a><span id="l1.353"> {</span>
<a href="#l1.354"></a><span id="l1.354">   NS_ENSURE_ARG_POINTER(aMsgKey);</span>
<a href="#l1.355"></a><span id="l1.355">   *aMsgKey = mLastMessageLoaded;</span>
<a href="#l1.356"></a><span id="l1.356">   return NS_OK;</span>
<a href="#l1.357"></a><span id="l1.357"> }</span>
<a href="#l1.358"></a><span id="l1.358"> </span>
<a href="#l1.359"></a><span id="l1.359" class="difflineat">@@ -5908,8 +5891,17 @@ int nsMsgKeySetU::Remove(PRUint32 aKey)</span>
<a href="#l1.360"></a><span id="l1.360"> </span>
<a href="#l1.361"></a><span id="l1.361"> PRBool nsMsgKeySetU::IsMember(PRUint32 aKey)</span>
<a href="#l1.362"></a><span id="l1.362"> {</span>
<a href="#l1.363"></a><span id="l1.363">   PRInt32 intKey = static_cast&lt;PRInt32&gt;(aKey);</span>
<a href="#l1.364"></a><span id="l1.364">   if (intKey &gt;= 0)</span>
<a href="#l1.365"></a><span id="l1.365">     return loKeySet-&gt;IsMember(intKey);</span>
<a href="#l1.366"></a><span id="l1.366">   return hiKeySet-&gt;IsMember(intKey &amp; kLowerBits);</span>
<a href="#l1.367"></a><span id="l1.367"> }</span>
<a href="#l1.368"></a><span id="l1.368" class="difflineplus">+</span>
<a href="#l1.369"></a><span id="l1.369" class="difflineplus">+nsresult nsMsgKeySetU::ToMsgKeyArray(nsTArray&lt;nsMsgKey&gt; &amp;aArray)</span>
<a href="#l1.370"></a><span id="l1.370" class="difflineplus">+{</span>
<a href="#l1.371"></a><span id="l1.371" class="difflineplus">+  nsresult rv = loKeySet-&gt;ToMsgKeyArray(aArray);</span>
<a href="#l1.372"></a><span id="l1.372" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.373"></a><span id="l1.373" class="difflineplus">+  return hiKeySet-&gt;ToMsgKeyArray(aArray);</span>
<a href="#l1.374"></a><span id="l1.374" class="difflineplus">+}</span>
<a href="#l1.375"></a><span id="l1.375" class="difflineplus">+</span>
<a href="#l1.376"></a><span id="l1.376" class="difflineplus">+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/base/util/nsMsgDBFolder.h</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgDBFolder.h</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -177,16 +177,18 @@ protected:</span>
<a href="#l2.4"></a><span id="l2.4">   void    SetMRUTime();</span>
<a href="#l2.5"></a><span id="l2.5"> </span>
<a href="#l2.6"></a><span id="l2.6">   /**</span>
<a href="#l2.7"></a><span id="l2.7">    * Clear all processing flags, presumably because message keys are no longer</span>
<a href="#l2.8"></a><span id="l2.8">    * valid.</span>
<a href="#l2.9"></a><span id="l2.9">    */</span>
<a href="#l2.10"></a><span id="l2.10">   void ClearProcessingFlags();</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+  nsresult NotifyHdrsNotBeingClassified();</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+</span>
<a href="#l2.14"></a><span id="l2.14"> protected:</span>
<a href="#l2.15"></a><span id="l2.15">   nsCOMPtr&lt;nsIMsgDatabase&gt; mDatabase;</span>
<a href="#l2.16"></a><span id="l2.16">   nsCOMPtr&lt;nsIMsgDatabase&gt; mBackupDatabase;</span>
<a href="#l2.17"></a><span id="l2.17">   nsCString mCharset;</span>
<a href="#l2.18"></a><span id="l2.18">   PRBool mCharsetOverride;</span>
<a href="#l2.19"></a><span id="l2.19">   PRBool mAddListener;</span>
<a href="#l2.20"></a><span id="l2.20">   PRBool mNewMessages;</span>
<a href="#l2.21"></a><span id="l2.21">   PRBool mGettingNewMessages;</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineat">@@ -305,23 +307,23 @@ protected:</span>
<a href="#l2.23"></a><span id="l2.23">     PRUint32 bit;</span>
<a href="#l2.24"></a><span id="l2.24">     nsMsgKeySetU* keys;</span>
<a href="#l2.25"></a><span id="l2.25">   } mProcessingFlag[nsMsgProcessingFlags::NumberOfFlags];</span>
<a href="#l2.26"></a><span id="l2.26"> </span>
<a href="#l2.27"></a><span id="l2.27">   // list of nsIMsgDBHdrs for messages to process post-bayes</span>
<a href="#l2.28"></a><span id="l2.28">   nsCOMPtr&lt;nsIMutableArray&gt; mPostBayesMessagesToFilter;</span>
<a href="#l2.29"></a><span id="l2.29"> </span>
<a href="#l2.30"></a><span id="l2.30">   /**</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineminus">-   * The list of message keys of messages being processed by Bayesian</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineminus">-   * classification.  We save the keys instead of the headers because it is</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineminus">-   * possible that post-classification filters may end up moving the messages</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineminus">-   * out of the folder (at which point the header becomes invalid).  (It also</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineminus">-   * helps keep memory usage down when there are lots of messages.)</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+   * The list of message keys that have been classified for msgsClassified</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+   * batch notification purposes.  We add to this list in OnMessageClassified</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+   * when we are told about a classified message (a URI is provided), and we</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineplus">+   * notify for the list and clear it when we are told all the messages in</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineplus">+   * the batch were classified (a URI is not provided).</span>
<a href="#l2.41"></a><span id="l2.41">    */</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineminus">-  nsTArray&lt;nsMsgKey&gt; mBayesMsgKeys;</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineplus">+  nsTArray&lt;nsMsgKey&gt; mClassifiedMsgKeys;</span>
<a href="#l2.44"></a><span id="l2.44">   // Is the current bayes filtering doing junk classification?</span>
<a href="#l2.45"></a><span id="l2.45">   PRBool mBayesJunkClassifying;</span>
<a href="#l2.46"></a><span id="l2.46">   // Is the current bayes filtering doing trait classification?</span>
<a href="#l2.47"></a><span id="l2.47">   PRBool mBayesTraitClassifying;</span>
<a href="#l2.48"></a><span id="l2.48"> };</span>
<a href="#l2.49"></a><span id="l2.49"> </span>
<a href="#l2.50"></a><span id="l2.50"> // This class is a kludge to allow nsMsgKeySet to be used with PRUint32 keys</span>
<a href="#l2.51"></a><span id="l2.51"> class nsMsgKeySetU</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineat">@@ -332,16 +334,18 @@ public:</span>
<a href="#l2.53"></a><span id="l2.53">   ~nsMsgKeySetU();</span>
<a href="#l2.54"></a><span id="l2.54">   // IsMember() returns whether the given key is a member of this set.</span>
<a href="#l2.55"></a><span id="l2.55">   PRBool IsMember(PRUint32 key);</span>
<a href="#l2.56"></a><span id="l2.56">   // Add() adds the given key to the set.  (Returns 1 if a change was</span>
<a href="#l2.57"></a><span id="l2.57">   // made, 0 if it was already there, and negative on error.)</span>
<a href="#l2.58"></a><span id="l2.58">   int Add(PRUint32 key);</span>
<a href="#l2.59"></a><span id="l2.59">   // Remove() removes the given article from the set. </span>
<a href="#l2.60"></a><span id="l2.60">   int Remove(PRUint32 key);</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineplus">+  // Add the keys in the set to aArray.</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineplus">+  nsresult ToMsgKeyArray(nsTArray&lt;nsMsgKey&gt; &amp;aArray);</span>
<a href="#l2.63"></a><span id="l2.63"> </span>
<a href="#l2.64"></a><span id="l2.64"> protected:</span>
<a href="#l2.65"></a><span id="l2.65">   nsMsgKeySetU();</span>
<a href="#l2.66"></a><span id="l2.66">   nsMsgKeySet* loKeySet;</span>
<a href="#l2.67"></a><span id="l2.67">   nsMsgKeySet* hiKeySet;</span>
<a href="#l2.68"></a><span id="l2.68"> };</span>
<a href="#l2.69"></a><span id="l2.69"> </span>
<a href="#l2.70"></a><span id="l2.70"> #undef  IMETHOD_VISIBILITY</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/base/util/nsMsgKeySet.cpp</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgKeySet.cpp</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -1170,35 +1170,27 @@ nsMsgKeySet::LastMissingRange(PRInt32 mi</span>
<a href="#l3.4"></a><span id="l3.4">   a = to + 1;</span>
<a href="#l3.5"></a><span id="l3.5">   *first = a &gt; min ? a : min;</span>
<a href="#l3.6"></a><span id="l3.6">   *last = max;</span>
<a href="#l3.7"></a><span id="l3.7">   }</span>
<a href="#l3.8"></a><span id="l3.8">   return 0;</span>
<a href="#l3.9"></a><span id="l3.9"> }</span>
<a href="#l3.10"></a><span id="l3.10"> </span>
<a href="#l3.11"></a><span id="l3.11"> /**</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">- * Return a copy of this as an nsTArray&lt;nsMsgKey&gt;, which is much easier for</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">- * callers to manipulate.  Normal XPCOM calling conventions, although the</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineminus">- * array itself isn't refcounted, so the caller should free when done</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineminus">- * using NS_DELETEXPCOM().</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+ * Fill the passed in aArray with the keys in the message key set.</span>
<a href="#l3.17"></a><span id="l3.17">  */</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineminus">-nsresult </span>
<a href="#l3.19"></a><span id="l3.19" class="difflineminus">-nsMsgKeySet::ToMsgKeyArray(nsTArray&lt;nsMsgKey&gt; **aArray)</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+nsresult</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+nsMsgKeySet::ToMsgKeyArray(nsTArray&lt;nsMsgKey&gt; &amp;aArray)</span>
<a href="#l3.22"></a><span id="l3.22"> {</span>
<a href="#l3.23"></a><span id="l3.23">     PRInt32 size;</span>
<a href="#l3.24"></a><span id="l3.24">     PRInt32 *head;</span>
<a href="#l3.25"></a><span id="l3.25">     PRInt32 *tail;</span>
<a href="#l3.26"></a><span id="l3.26">     PRInt32 *end;</span>
<a href="#l3.27"></a><span id="l3.27">     PRInt32 last_art = -1;</span>
<a href="#l3.28"></a><span id="l3.28"> </span>
<a href="#l3.29"></a><span id="l3.29" class="difflineminus">-    nsTArray&lt;nsMsgKey&gt; *array;</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineminus">-    NS_NEWXPCOM(array, nsTArray&lt;nsMsgKey&gt;);</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineminus">-    if (!array) </span>
<a href="#l3.32"></a><span id="l3.32" class="difflineminus">-        return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineminus">-</span>
<a href="#l3.34"></a><span id="l3.34">     size = m_length;</span>
<a href="#l3.35"></a><span id="l3.35">     head = m_data;</span>
<a href="#l3.36"></a><span id="l3.36">     tail = head;</span>
<a href="#l3.37"></a><span id="l3.37">     end = head + size;</span>
<a href="#l3.38"></a><span id="l3.38"> </span>
<a href="#l3.39"></a><span id="l3.39">     while (tail &lt; end) {</span>
<a href="#l3.40"></a><span id="l3.40">         PRInt32 from;</span>
<a href="#l3.41"></a><span id="l3.41">         PRInt32 to;</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineat">@@ -1210,33 +1202,32 @@ nsMsgKeySet::ToMsgKeyArray(nsTArray&lt;nsMs</span>
<a href="#l3.43"></a><span id="l3.43">             tail += 2;</span>
<a href="#l3.44"></a><span id="l3.44">         }</span>
<a href="#l3.45"></a><span id="l3.45">         else /* it's a literal */</span>
<a href="#l3.46"></a><span id="l3.46">             {</span>
<a href="#l3.47"></a><span id="l3.47">                 from = *tail;</span>
<a href="#l3.48"></a><span id="l3.48">                 to = from;</span>
<a href="#l3.49"></a><span id="l3.49">                 tail++;</span>
<a href="#l3.50"></a><span id="l3.50">             }</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineminus">-        if (from == 0) {</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineminus">-            from = 1;               /* See 'hack' comment above  ### */</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineminus">-        }</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+        // The horrible news-hack used to adjust from to 1 if it was zero right</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+        // here, but there is no longer a consumer of this method with that</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+        // broken use-case.</span>
<a href="#l3.57"></a><span id="l3.57">         if (from &lt;= last_art) from = last_art + 1;</span>
<a href="#l3.58"></a><span id="l3.58">         if (from &lt;= to) {</span>
<a href="#l3.59"></a><span id="l3.59">             if (from &lt; to) {</span>
<a href="#l3.60"></a><span id="l3.60">                 for (PRInt32 i = from; i &lt;= to ; ++i ) {</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineminus">-                    array-&gt;AppendElement(i);</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineplus">+                    aArray.AppendElement(i);</span>
<a href="#l3.63"></a><span id="l3.63">                 }</span>
<a href="#l3.64"></a><span id="l3.64">             } else {</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineminus">-                array-&gt;AppendElement(from);</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineplus">+                aArray.AppendElement(from);</span>
<a href="#l3.67"></a><span id="l3.67">             }</span>
<a href="#l3.68"></a><span id="l3.68">             last_art = to;</span>
<a href="#l3.69"></a><span id="l3.69">         }</span>
<a href="#l3.70"></a><span id="l3.70">     }</span>
<a href="#l3.71"></a><span id="l3.71"> </span>
<a href="#l3.72"></a><span id="l3.72" class="difflineminus">-    *aArray = array;</span>
<a href="#l3.73"></a><span id="l3.73">     return NS_OK;</span>
<a href="#l3.74"></a><span id="l3.74"> }</span>
<a href="#l3.75"></a><span id="l3.75"> </span>
<a href="#l3.76"></a><span id="l3.76"> </span>
<a href="#l3.77"></a><span id="l3.77"> #ifdef DEBUG /* A lot of test cases for the above */</span>
<a href="#l3.78"></a><span id="l3.78"> </span>
<a href="#l3.79"></a><span id="l3.79"> #define countof(x) (sizeof(x) / sizeof(*(x)))</span>
<a href="#l3.80"></a><span id="l3.80"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/base/util/nsMsgKeySet.h</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgKeySet.h</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -96,24 +96,21 @@ public:</span>
<a href="#l4.4"></a><span id="l4.4">   int LastMissingRange(PRInt32 min, PRInt32 max, PRInt32* first, PRInt32* last);</span>
<a href="#l4.5"></a><span id="l4.5">   </span>
<a href="#l4.6"></a><span id="l4.6">   PRInt32 GetLastMember();</span>
<a href="#l4.7"></a><span id="l4.7">   PRInt32 GetFirstMember();</span>
<a href="#l4.8"></a><span id="l4.8">   void  SetLastMember(PRInt32 highWaterMark);</span>
<a href="#l4.9"></a><span id="l4.9">   // For debugging only...</span>
<a href="#l4.10"></a><span id="l4.10">   PRInt32 getLength() {return m_length;}</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-  /**</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineminus">-   * Return a copy of this as an nsTArray&lt;nsMsgKey&gt;, which is much easier for</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineminus">-   * callers to manipulate.  Normal XPCOM calling conventions, although the</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineminus">-   * array itself isn't refcounted, so the caller should free when done</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineminus">-   * using NS_DELETEXPCOM().</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineminus">-   */</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineminus">-  nsresult ToMsgKeyArray(nsTArray&lt;nsMsgKey&gt; **aArray);</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineminus">-  </span>
<a href="#l4.20"></a><span id="l4.20" class="difflineplus">+/**</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineplus">+ * Fill the passed in aArray with the keys in the message key set.</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineplus">+ */</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineplus">+  nsresult ToMsgKeyArray(nsTArray&lt;nsMsgKey&gt; &amp;aArray);</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineplus">+</span>
<a href="#l4.25"></a><span id="l4.25"> #ifdef DEBUG</span>
<a href="#l4.26"></a><span id="l4.26">   static void RunTests();</span>
<a href="#l4.27"></a><span id="l4.27"> #endif</span>
<a href="#l4.28"></a><span id="l4.28"> </span>
<a href="#l4.29"></a><span id="l4.29"> protected:</span>
<a href="#l4.30"></a><span id="l4.30">   nsMsgKeySet(/* MSG_NewsHost* host */);</span>
<a href="#l4.31"></a><span id="l4.31">   nsMsgKeySet(const char* /* , MSG_NewsHost* host */);</span>
<a href="#l4.32"></a><span id="l4.32">   PRBool Grow();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/db/gloda/modules/index_msg.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/index_msg.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -97,16 +97,25 @@ const nsIArray = Ci.nsIArray;</span>
<a href="#l5.4"></a><span id="l5.4"> const nsIMsgFolder = Ci.nsIMsgFolder;</span>
<a href="#l5.5"></a><span id="l5.5"> const nsIMsgLocalMailFolder = Ci.nsIMsgLocalMailFolder;</span>
<a href="#l5.6"></a><span id="l5.6"> const nsIMsgImapMailFolder = Ci.nsIMsgImapMailFolder;</span>
<a href="#l5.7"></a><span id="l5.7"> const nsIMsgDBHdr = Ci.nsIMsgDBHdr;</span>
<a href="#l5.8"></a><span id="l5.8"> const nsMsgFolderFlags = Ci.nsMsgFolderFlags;</span>
<a href="#l5.9"></a><span id="l5.9"> const nsMsgMessageFlags = Ci.nsMsgMessageFlags;</span>
<a href="#l5.10"></a><span id="l5.10"> const nsMsgProcessingFlags = Ci.nsMsgProcessingFlags;</span>
<a href="#l5.11"></a><span id="l5.11"> </span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+/**</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+ * The processing flags that tell us that a message header has not yet been</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+ *  reported to us via msgsClassified.  If it has one of these flags, it is</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+ *  still being processed.</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineplus">+ */</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineplus">+const NOT_YET_REPORTED_PROCESSING_FLAGS =</span>
<a href="#l5.18"></a><span id="l5.18" class="difflineplus">+  nsMsgProcessingFlags.NotReportedClassified |</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineplus">+  nsMsgProcessingFlags.ClassifyJunk;</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineplus">+</span>
<a href="#l5.21"></a><span id="l5.21"> // for list comprehension fun</span>
<a href="#l5.22"></a><span id="l5.22"> function range(begin, end) {</span>
<a href="#l5.23"></a><span id="l5.23">   for (let i = begin; i &lt; end; ++i) {</span>
<a href="#l5.24"></a><span id="l5.24">     yield i;</span>
<a href="#l5.25"></a><span id="l5.25">   }</span>
<a href="#l5.26"></a><span id="l5.26"> }</span>
<a href="#l5.27"></a><span id="l5.27"> </span>
<a href="#l5.28"></a><span id="l5.28"> /**</span>
<a href="#l5.29"></a><span id="l5.29" class="difflineat">@@ -1365,17 +1374,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l5.30"></a><span id="l5.30"> </span>
<a href="#l5.31"></a><span id="l5.31">         // To keep our counts more accurate, increment the offset before</span>
<a href="#l5.32"></a><span id="l5.32">         //  potentially skipping any messages.</span>
<a href="#l5.33"></a><span id="l5.33">         ++aJob.offset;</span>
<a href="#l5.34"></a><span id="l5.34"> </span>
<a href="#l5.35"></a><span id="l5.35">         // Skip messages that have not yet been reported to us as existing via</span>
<a href="#l5.36"></a><span id="l5.36">         //  msgsClassified.</span>
<a href="#l5.37"></a><span id="l5.37">         if (this._indexingFolder.getProcessingFlags(msgHdr.messageKey) &amp;</span>
<a href="#l5.38"></a><span id="l5.38" class="difflineminus">-            nsMsgProcessingFlags.NotReportedClassified)</span>
<a href="#l5.39"></a><span id="l5.39" class="difflineplus">+            NOT_YET_REPORTED_PROCESSING_FLAGS)</span>
<a href="#l5.40"></a><span id="l5.40">           continue;</span>
<a href="#l5.41"></a><span id="l5.41"> </span>
<a href="#l5.42"></a><span id="l5.42">         // Because the gloda id could be in-flight, we need to double-check the</span>
<a href="#l5.43"></a><span id="l5.43">         //  enumerator here since it can't know about our in-memory stuff.</span>
<a href="#l5.44"></a><span id="l5.44">         let [glodaId, glodaDirty] = PendingCommitTracker.getGlodaState(msgHdr);</span>
<a href="#l5.45"></a><span id="l5.45">         // if the message seems valid, skip it.  (that means good gloda id</span>
<a href="#l5.46"></a><span id="l5.46">         //  and not dirty)</span>
<a href="#l5.47"></a><span id="l5.47">         if (glodaId &gt;= GLODA_FIRST_VALID_MESSAGE_ID &amp;&amp;</span>
<a href="#l5.48"></a><span id="l5.48" class="difflineat">@@ -1748,17 +1757,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l5.49"></a><span id="l5.49">           continue;</span>
<a href="#l5.50"></a><span id="l5.50">         }</span>
<a href="#l5.51"></a><span id="l5.51">       }</span>
<a href="#l5.52"></a><span id="l5.52">       // Ignore messages whose processing flags indicate it has not yet been</span>
<a href="#l5.53"></a><span id="l5.53">       //  classified.  In the IMAP case if the Offline flag is going to get set</span>
<a href="#l5.54"></a><span id="l5.54">       //  we are going to see it before the msgsClassified event so this is</span>
<a href="#l5.55"></a><span id="l5.55">       //  very important.</span>
<a href="#l5.56"></a><span id="l5.56">       if (msgFolder.getProcessingFlags(msgHdr.messageKey) &amp;</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineminus">-          nsMsgProcessingFlags.NotReportedClassified)</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineplus">+          NOT_YET_REPORTED_PROCESSING_FLAGS)</span>
<a href="#l5.59"></a><span id="l5.59">         continue;</span>
<a href="#l5.60"></a><span id="l5.60"> </span>
<a href="#l5.61"></a><span id="l5.61">       let [glodaId, glodaDirty] = PendingCommitTracker.getGlodaState(msgHdr);</span>
<a href="#l5.62"></a><span id="l5.62"> </span>
<a href="#l5.63"></a><span id="l5.63">       let isSpam = msgHdr.getStringProperty(JUNK_SCORE_PROPERTY) ==</span>
<a href="#l5.64"></a><span id="l5.64">                      JUNK_SPAM_SCORE_STR;</span>
<a href="#l5.65"></a><span id="l5.65"> </span>
<a href="#l5.66"></a><span id="l5.66">       // -- Is the message currently gloda indexed?</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/base_index_messages.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/base_index_messages.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -725,17 +725,30 @@ function test_folder_nuking_message_dele</span>
<a href="#l6.4"></a><span id="l6.4"> function test_folder_deletion_single() {</span>
<a href="#l6.5"></a><span id="l6.5"> </span>
<a href="#l6.6"></a><span id="l6.6"> }</span>
<a href="#l6.7"></a><span id="l6.7"> </span>
<a href="#l6.8"></a><span id="l6.8"> function test_folder_deletion_nested() {</span>
<a href="#l6.9"></a><span id="l6.9"> </span>
<a href="#l6.10"></a><span id="l6.10"> }</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+/* ===== IMAP Nuances ===== */</span>
<a href="#l6.13"></a><span id="l6.13"> </span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+/**</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+ * Verify that for IMAP folders we still see an index a message that is added</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+ *  as read.</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineplus">+ */</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+function test_imap_add_unread_to_folder() {</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+  if (message_injection_is_local())</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineplus">+    return;</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineplus">+</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineplus">+  let [srcFolder, msgSet] = make_folder_with_sets([{count: 1, read: true}]);</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l6.24"></a><span id="l6.24" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineplus">+}</span>
<a href="#l6.26"></a><span id="l6.26"> </span>
<a href="#l6.27"></a><span id="l6.27"> /* ===== Message Moving ===== */</span>
<a href="#l6.28"></a><span id="l6.28"> </span>
<a href="#l6.29"></a><span id="l6.29"> /**</span>
<a href="#l6.30"></a><span id="l6.30">  * Moving a message between folders should result in us knowing that the message</span>
<a href="#l6.31"></a><span id="l6.31">  *  is in the target location.  In the case of local moves, this happens</span>
<a href="#l6.32"></a><span id="l6.32">  *  automatically.  In the case of IMAP moves, we need to force the target folder</span>
<a href="#l6.33"></a><span id="l6.33">  *  to be updated.</span>
<a href="#l6.34"></a><span id="l6.34" class="difflineat">@@ -766,16 +779,19 @@ function test_message_moving() {</span>
<a href="#l6.35"></a><span id="l6.35">   //  we see it as indexing traffic even if the indexer never goes active.)</span>
<a href="#l6.36"></a><span id="l6.36">   // (In the IMAP case, the message actually gets reindexed in the target</span>
<a href="#l6.37"></a><span id="l6.37">   //  folder.)</span>
<a href="#l6.38"></a><span id="l6.38">   yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l6.39"></a><span id="l6.39"> </span>
<a href="#l6.40"></a><span id="l6.40">   do_check_eq(gmsg.folderURI,</span>
<a href="#l6.41"></a><span id="l6.41">               get_real_injection_folder(destFolder).URI);</span>
<a href="#l6.42"></a><span id="l6.42"> </span>
<a href="#l6.43"></a><span id="l6.43" class="difflineplus">+  // - make sure the message key is correct!</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineplus">+  do_check_eq(gmsg.messageKey, msgSet.getMsgHdr(0).messageKey);</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineplus">+</span>
<a href="#l6.46"></a><span id="l6.46">   // - move it back to its origin folder</span>
<a href="#l6.47"></a><span id="l6.47">   mark_sub_test_start(&quot;move it back&quot;);</span>
<a href="#l6.48"></a><span id="l6.48">   yield async_move_messages(msgSet, srcFolder);</span>
<a href="#l6.49"></a><span id="l6.49">   yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l6.50"></a><span id="l6.50">   do_check_eq(gmsg.folderURI,</span>
<a href="#l6.51"></a><span id="l6.51">               get_real_injection_folder(srcFolder).URI);</span>
<a href="#l6.52"></a><span id="l6.52"> }</span>
<a href="#l6.53"></a><span id="l6.53"> </span>
<a href="#l6.54"></a><span id="l6.54" class="difflineat">@@ -848,16 +864,17 @@ var tests = [</span>
<a href="#l6.55"></a><span id="l6.55">   test_indexing_sweep,</span>
<a href="#l6.56"></a><span id="l6.56">   test_event_driven_indexing_does_not_mess_with_filthy_folders,</span>
<a href="#l6.57"></a><span id="l6.57"> </span>
<a href="#l6.58"></a><span id="l6.58">   test_threading,</span>
<a href="#l6.59"></a><span id="l6.59">   test_attributes_fundamental,</span>
<a href="#l6.60"></a><span id="l6.60">   test_attributes_fundamental_from_disk,</span>
<a href="#l6.61"></a><span id="l6.61">   test_attributes_explicit,</span>
<a href="#l6.62"></a><span id="l6.62"> </span>
<a href="#l6.63"></a><span id="l6.63" class="difflineplus">+  test_imap_add_unread_to_folder,</span>
<a href="#l6.64"></a><span id="l6.64">   test_message_moving,</span>
<a href="#l6.65"></a><span id="l6.65"> </span>
<a href="#l6.66"></a><span id="l6.66">   test_message_deletion,</span>
<a href="#l6.67"></a><span id="l6.67">   test_moving_to_trash_marks_deletion,</span>
<a href="#l6.68"></a><span id="l6.68">   test_folder_nuking_message_deletion,</span>
<a href="#l6.69"></a><span id="l6.69"> </span>
<a href="#l6.70"></a><span id="l6.70">   test_sweep_indexing_does_not_reindex_event_indexed,</span>
<a href="#l6.71"></a><span id="l6.71"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -141,17 +141,27 @@ register_message_injection_listener({</span>
<a href="#l7.4"></a><span id="l7.4"> </span>
<a href="#l7.5"></a><span id="l7.5">   /**</span>
<a href="#l7.6"></a><span id="l7.6">    * Make wait_for_gloda_indexer know that it should wait for a msgsClassified</span>
<a href="#l7.7"></a><span id="l7.7">    *  event whenever messages have been injected, at least if event-driven</span>
<a href="#l7.8"></a><span id="l7.8">    *  indexing is enabled.</span>
<a href="#l7.9"></a><span id="l7.9">    */</span>
<a href="#l7.10"></a><span id="l7.10">   onInjectingMessages: function gth_onInjectingMessages() {</span>
<a href="#l7.11"></a><span id="l7.11">     _indexMessageState.interestingEvents.push(&quot;msgsClassified&quot;);</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-  }</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+  },</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+  /**</span>
<a href="#l7.16"></a><span id="l7.16" class="difflineplus">+   * This basically translates to &quot;we are triggering an IMAP move&quot; and has</span>
<a href="#l7.17"></a><span id="l7.17" class="difflineplus">+   *  the ramification that we should expect a msgsClassified event because</span>
<a href="#l7.18"></a><span id="l7.18" class="difflineplus">+   *  the destination will see the header get added at some point.</span>
<a href="#l7.19"></a><span id="l7.19" class="difflineplus">+   */</span>
<a href="#l7.20"></a><span id="l7.20" class="difflineplus">+  onMovingMessagesWithoutDestHeaders:</span>
<a href="#l7.21"></a><span id="l7.21" class="difflineplus">+      function gth_onMovingMessagesWithoutDestHeaders() {</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineplus">+    _indexMessageState.interestingEvents.push(&quot;msgsClassified&quot;);</span>
<a href="#l7.23"></a><span id="l7.23" class="difflineplus">+  },</span>
<a href="#l7.24"></a><span id="l7.24"> });</span>
<a href="#l7.25"></a><span id="l7.25"> </span>
<a href="#l7.26"></a><span id="l7.26"> function _prepareIndexerForTesting() {</span>
<a href="#l7.27"></a><span id="l7.27">   if (!GlodaIndexer.enabled)</span>
<a href="#l7.28"></a><span id="l7.28">     do_throw(&quot;The gloda indexer is somehow not enabled.  This is problematic.&quot;);</span>
<a href="#l7.29"></a><span id="l7.29"> </span>
<a href="#l7.30"></a><span id="l7.30">   // Make the indexer be more verbose about indexing for us...</span>
<a href="#l7.31"></a><span id="l7.31">   GlodaIndexer._unitTestSuperVerbose = true;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/test/resources/asyncTestUtils.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/test/resources/asyncTestUtils.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -76,68 +76,16 @@ var asyncCopyListener = {</span>
<a href="#l8.4"></a><span id="l8.4">   OnProgress: function(aProgress, aProgressMax) {},</span>
<a href="#l8.5"></a><span id="l8.5">   SetMessageKey: function(aMsgKey) {},</span>
<a href="#l8.6"></a><span id="l8.6">   GetMessageId: function() {},</span>
<a href="#l8.7"></a><span id="l8.7">   OnStopCopy: function(aStatus) {</span>
<a href="#l8.8"></a><span id="l8.8">     async_driver();</span>
<a href="#l8.9"></a><span id="l8.9">   }</span>
<a href="#l8.10"></a><span id="l8.10"> };</span>
<a href="#l8.11"></a><span id="l8.11"> </span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-/**</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineminus">- * Move the messages to the trash; do not use this on messages that are already</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineminus">- *  in the trash, we are not clever enough for that.</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineminus">- *</span>
<a href="#l8.16"></a><span id="l8.16" class="difflineminus">- * @param aSynMessageSet The set of messages to trash.  The messages do not all</span>
<a href="#l8.17"></a><span id="l8.17" class="difflineminus">- *     have to be in the same folder, but we have to trash them folder by</span>
<a href="#l8.18"></a><span id="l8.18" class="difflineminus">- *     folder if they are not.</span>
<a href="#l8.19"></a><span id="l8.19" class="difflineminus">- */</span>
<a href="#l8.20"></a><span id="l8.20" class="difflineminus">-function async_trash_messages(aSynMessageSet) {</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineminus">-  mark_action(&quot;messageInjection&quot;, &quot;trashing messages&quot;,</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineminus">-              aSynMessageSet.msgHdrList);</span>
<a href="#l8.23"></a><span id="l8.23" class="difflineminus">-  return async_run({func: function () {</span>
<a href="#l8.24"></a><span id="l8.24" class="difflineminus">-      for (let [folder, xpcomHdrArray] in</span>
<a href="#l8.25"></a><span id="l8.25" class="difflineminus">-           aSynMessageSet.foldersWithXpcomHdrArrays) {</span>
<a href="#l8.26"></a><span id="l8.26" class="difflineminus">-        mark_action(&quot;messageInjection&quot;, &quot;trashing messages in folder&quot;,</span>
<a href="#l8.27"></a><span id="l8.27" class="difflineminus">-                    [folder]);</span>
<a href="#l8.28"></a><span id="l8.28" class="difflineminus">-        folder.deleteMessages(xpcomHdrArray, null, false, true,</span>
<a href="#l8.29"></a><span id="l8.29" class="difflineminus">-                              asyncCopyListener,</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineminus">-                              /* do not allow undo, currently leaks */ false);</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineminus">-        yield false;</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineminus">-      }</span>
<a href="#l8.33"></a><span id="l8.33" class="difflineminus">-    },</span>
<a href="#l8.34"></a><span id="l8.34" class="difflineminus">-  });</span>
<a href="#l8.35"></a><span id="l8.35" class="difflineminus">-}</span>
<a href="#l8.36"></a><span id="l8.36" class="difflineminus">-</span>
<a href="#l8.37"></a><span id="l8.37" class="difflineminus">-/**</span>
<a href="#l8.38"></a><span id="l8.38" class="difflineminus">- * Delete all of the messages in a SyntheticMessageSet like the user performed a</span>
<a href="#l8.39"></a><span id="l8.39" class="difflineminus">- *  shift-delete (or if the messages were already in the trash).</span>
<a href="#l8.40"></a><span id="l8.40" class="difflineminus">- *</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineminus">- * This is actually a synchronous operation.  I'm surprised too.</span>
<a href="#l8.42"></a><span id="l8.42" class="difflineminus">- *</span>
<a href="#l8.43"></a><span id="l8.43" class="difflineminus">- * @param aSynMessageSet The set of messages to delete.  The messages do not all</span>
<a href="#l8.44"></a><span id="l8.44" class="difflineminus">- *     have to be in the same folder, but we have to delete them folder by</span>
<a href="#l8.45"></a><span id="l8.45" class="difflineminus">- *     folder if they are not.</span>
<a href="#l8.46"></a><span id="l8.46" class="difflineminus">- */</span>
<a href="#l8.47"></a><span id="l8.47" class="difflineminus">-function async_delete_messages(aSynMessageSet) {</span>
<a href="#l8.48"></a><span id="l8.48" class="difflineminus">-  mark_action(&quot;messageInjection&quot;, &quot;deleting messages&quot;,</span>
<a href="#l8.49"></a><span id="l8.49" class="difflineminus">-              aSynMessageSet.msgHdrList);</span>
<a href="#l8.50"></a><span id="l8.50" class="difflineminus">-  for (let [folder, xpcomHdrArray] in</span>
<a href="#l8.51"></a><span id="l8.51" class="difflineminus">-       aSynMessageSet.foldersWithXpcomHdrArrays) {</span>
<a href="#l8.52"></a><span id="l8.52" class="difflineminus">-    mark_action(&quot;messageInjection&quot;, &quot;deleting messages in folder&quot;,</span>
<a href="#l8.53"></a><span id="l8.53" class="difflineminus">-                [folder]);</span>
<a href="#l8.54"></a><span id="l8.54" class="difflineminus">-    folder.deleteMessages(xpcomHdrArray, null,</span>
<a href="#l8.55"></a><span id="l8.55" class="difflineminus">-                          /* delete storage */ true,</span>
<a href="#l8.56"></a><span id="l8.56" class="difflineminus">-                          /* is move? */ false,</span>
<a href="#l8.57"></a><span id="l8.57" class="difflineminus">-                          asyncCopyListener,</span>
<a href="#l8.58"></a><span id="l8.58" class="difflineminus">-                          /* do not allow undo, currently leaks */ false);</span>
<a href="#l8.59"></a><span id="l8.59" class="difflineminus">-  }</span>
<a href="#l8.60"></a><span id="l8.60" class="difflineminus">-  return true;</span>
<a href="#l8.61"></a><span id="l8.61" class="difflineminus">-}</span>
<a href="#l8.62"></a><span id="l8.62" class="difflineminus">-</span>
<a href="#l8.63"></a><span id="l8.63" class="difflineminus">-</span>
<a href="#l8.64"></a><span id="l8.64"> var asyncGeneratorStack = [];</span>
<a href="#l8.65"></a><span id="l8.65"> </span>
<a href="#l8.66"></a><span id="l8.66"> /**</span>
<a href="#l8.67"></a><span id="l8.67">  * Run a function that may or may not be a generator.  All functions, generator</span>
<a href="#l8.68"></a><span id="l8.68">  *  or not, must return false if they do not want the async_driver to run the</span>
<a href="#l8.69"></a><span id="l8.69">  *  next logical work step.  Returning no value (undefined) or true indicates to</span>
<a href="#l8.70"></a><span id="l8.70">  *  the async_driver that it should execute the next work step.  You would</span>
<a href="#l8.71"></a><span id="l8.71">  *  return false if your function initiates an asynchronous operation and will</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/test/resources/messageGenerator.js</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/test/resources/messageGenerator.js</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -333,16 +333,21 @@ SyntheticPartMultiSignedPGP.prototype = </span>
<a href="#l9.4"></a><span id="l9.4">   _contentType: 'multipart/signed',</span>
<a href="#l9.5"></a><span id="l9.5">   _contentTypeExtra: {</span>
<a href="#l9.6"></a><span id="l9.6">     protocol: PGP_SIGNATURE_MIME_TYPE,</span>
<a href="#l9.7"></a><span id="l9.7">     micalg: 'pgp-sha1'</span>
<a href="#l9.8"></a><span id="l9.8">   },</span>
<a href="#l9.9"></a><span id="l9.9"> };</span>
<a href="#l9.10"></a><span id="l9.10"> </span>
<a href="#l9.11"></a><span id="l9.11"> </span>
<a href="#l9.12"></a><span id="l9.12" class="difflineplus">+const _DEFAULT_META_STATES = {</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+  junk: false,</span>
<a href="#l9.14"></a><span id="l9.14" class="difflineplus">+  read: false,</span>
<a href="#l9.15"></a><span id="l9.15" class="difflineplus">+};</span>
<a href="#l9.16"></a><span id="l9.16" class="difflineplus">+</span>
<a href="#l9.17"></a><span id="l9.17"> /**</span>
<a href="#l9.18"></a><span id="l9.18">  * A synthetic message, created by the MessageGenerator.  Captures both the</span>
<a href="#l9.19"></a><span id="l9.19">  *  ingredients that went into the synthetic message as well as the rfc822 form</span>
<a href="#l9.20"></a><span id="l9.20">  *  of the message.</span>
<a href="#l9.21"></a><span id="l9.21">  *</span>
<a href="#l9.22"></a><span id="l9.22">  * @param [aHeaders] A dictionary of rfc822 header payloads.  The key should be</span>
<a href="#l9.23"></a><span id="l9.23">  *     capitalized as you want it to appear in the output.  This requires</span>
<a href="#l9.24"></a><span id="l9.24">  *     adherence to convention of this class.  You are best to just use the</span>
<a href="#l9.25"></a><span id="l9.25" class="difflineat">@@ -352,17 +357,21 @@ SyntheticPartMultiSignedPGP.prototype = </span>
<a href="#l9.26"></a><span id="l9.26">  * @param [aMetaState] A dictionary of meta-state about the message that is only</span>
<a href="#l9.27"></a><span id="l9.27">  *     relevant to the messageInjection logic and perhaps some testing logic.</span>
<a href="#l9.28"></a><span id="l9.28">  * @param [aMetaState.junk=false] Is the method junk?</span>
<a href="#l9.29"></a><span id="l9.29">  */</span>
<a href="#l9.30"></a><span id="l9.30"> function SyntheticMessage(aHeaders, aBodyPart, aMetaState) {</span>
<a href="#l9.31"></a><span id="l9.31">   // we currently do not need to call SyntheticPart's constructor...</span>
<a href="#l9.32"></a><span id="l9.32">   this.headers = aHeaders || {};</span>
<a href="#l9.33"></a><span id="l9.33">   this.bodyPart = aBodyPart || new SyntheticPartLeaf(&quot;&quot;);</span>
<a href="#l9.34"></a><span id="l9.34" class="difflineminus">-  this.metaState = aMetaState || {junk: false};</span>
<a href="#l9.35"></a><span id="l9.35" class="difflineplus">+  this.metaState = aMetaState || {};</span>
<a href="#l9.36"></a><span id="l9.36" class="difflineplus">+  for each (let [key, value] in Iterator(_DEFAULT_META_STATES)) {</span>
<a href="#l9.37"></a><span id="l9.37" class="difflineplus">+    if (!(key in this.metaState))</span>
<a href="#l9.38"></a><span id="l9.38" class="difflineplus">+      this.metaState[key] = value;</span>
<a href="#l9.39"></a><span id="l9.39" class="difflineplus">+  }</span>
<a href="#l9.40"></a><span id="l9.40"> }</span>
<a href="#l9.41"></a><span id="l9.41"> </span>
<a href="#l9.42"></a><span id="l9.42"> SyntheticMessage.prototype = {</span>
<a href="#l9.43"></a><span id="l9.43">   __proto__: SyntheticPart.prototype,</span>
<a href="#l9.44"></a><span id="l9.44">   _contentType: 'message/rfc822',</span>
<a href="#l9.45"></a><span id="l9.45">   _charset: null,</span>
<a href="#l9.46"></a><span id="l9.46">   _format: null,</span>
<a href="#l9.47"></a><span id="l9.47">   _encoding: null,</span>
<a href="#l9.48"></a><span id="l9.48" class="difflineat">@@ -815,16 +824,17 @@ MessageGenerator.prototype = {</span>
<a href="#l9.49"></a><span id="l9.49">    * @param [aArgs.clobberHeaders] An object whose contents will overwrite the</span>
<a href="#l9.50"></a><span id="l9.50">    *     contents of the headers object.  This should only be used to construct</span>
<a href="#l9.51"></a><span id="l9.51">    *     illegal header values; general usage should use another explicit</span>
<a href="#l9.52"></a><span id="l9.52">    *     mechanism.</span>
<a href="#l9.53"></a><span id="l9.53">    * @param [aArgs.junk] Should this message be flagged as junk for the benefit</span>
<a href="#l9.54"></a><span id="l9.54">    *     of the messageInjection helper so that it can know to flag the message</span>
<a href="#l9.55"></a><span id="l9.55">    *     as junk?  We have no concept of marking a message as definitely not</span>
<a href="#l9.56"></a><span id="l9.56">    *     junk at this point.</span>
<a href="#l9.57"></a><span id="l9.57" class="difflineplus">+   * @param [aArgs.read] Should this message be marked as already read?</span>
<a href="#l9.58"></a><span id="l9.58">    * @returns a SyntheticMessage fashioned just to your liking.</span>
<a href="#l9.59"></a><span id="l9.59">    */</span>
<a href="#l9.60"></a><span id="l9.60">   makeMessage: function(aArgs) {</span>
<a href="#l9.61"></a><span id="l9.61">     aArgs = aArgs || {};</span>
<a href="#l9.62"></a><span id="l9.62">     let msg = new SyntheticMessage();</span>
<a href="#l9.63"></a><span id="l9.63"> </span>
<a href="#l9.64"></a><span id="l9.64">     if (aArgs.inReplyTo) {</span>
<a href="#l9.65"></a><span id="l9.65">       // If inReplyTo is a SyntheticMessageSet, just use the first message in</span>
<a href="#l9.66"></a><span id="l9.66" class="difflineat">@@ -885,16 +895,18 @@ MessageGenerator.prototype = {</span>
<a href="#l9.67"></a><span id="l9.67">         // clobber helper...</span>
<a href="#l9.68"></a><span id="l9.68">         if (key == &quot;From&quot;)</span>
<a href="#l9.69"></a><span id="l9.69">           msg._from = [&quot;&quot;, &quot;&quot;];</span>
<a href="#l9.70"></a><span id="l9.70">       }</span>
<a href="#l9.71"></a><span id="l9.71">     }</span>
<a href="#l9.72"></a><span id="l9.72"> </span>
<a href="#l9.73"></a><span id="l9.73">     if (&quot;junk&quot; in aArgs &amp;&amp; aArgs.junk)</span>
<a href="#l9.74"></a><span id="l9.74">       msg.metaState.junk = true;</span>
<a href="#l9.75"></a><span id="l9.75" class="difflineplus">+    if (&quot;read&quot; in aArgs &amp;&amp; aArgs.read)</span>
<a href="#l9.76"></a><span id="l9.76" class="difflineplus">+      msg.metaState.read = true;</span>
<a href="#l9.77"></a><span id="l9.77"> </span>
<a href="#l9.78"></a><span id="l9.78">     let bodyPart;</span>
<a href="#l9.79"></a><span id="l9.79">     if (aArgs.bodyPart)</span>
<a href="#l9.80"></a><span id="l9.80">       bodyPart = aArgs.bodyPart;</span>
<a href="#l9.81"></a><span id="l9.81">     else if (aArgs.body)</span>
<a href="#l9.82"></a><span id="l9.82">       bodyPart = new SyntheticPartLeaf(aArgs.body.body, aArgs.body);</span>
<a href="#l9.83"></a><span id="l9.83">     else // different messages should have a chance at different bodies</span>
<a href="#l9.84"></a><span id="l9.84">       bodyPart = new SyntheticPartLeaf(&quot;Hello &quot; + msg.toName + &quot;!&quot;);</span>
<a href="#l9.85"></a><span id="l9.85" class="difflineat">@@ -914,17 +926,17 @@ MessageGenerator.prototype = {</span>
<a href="#l9.86"></a><span id="l9.86"> </span>
<a href="#l9.87"></a><span id="l9.87">     return msg;</span>
<a href="#l9.88"></a><span id="l9.88">   },</span>
<a href="#l9.89"></a><span id="l9.89"> </span>
<a href="#l9.90"></a><span id="l9.90">   MAKE_MESSAGES_DEFAULTS: {</span>
<a href="#l9.91"></a><span id="l9.91">     count: 10,</span>
<a href="#l9.92"></a><span id="l9.92">   },</span>
<a href="#l9.93"></a><span id="l9.93">   MAKE_MESSAGES_PROPAGATE: ['attachments', 'body', 'cc', 'from', 'inReplyTo',</span>
<a href="#l9.94"></a><span id="l9.94" class="difflineminus">-                            'subject', 'to', 'clobberHeaders', 'junk'],</span>
<a href="#l9.95"></a><span id="l9.95" class="difflineplus">+                            'subject', 'to', 'clobberHeaders', 'junk', 'read'],</span>
<a href="#l9.96"></a><span id="l9.96">   /**</span>
<a href="#l9.97"></a><span id="l9.97">    * Given a set definition, produce a list of synthetic messages.</span>
<a href="#l9.98"></a><span id="l9.98">    *</span>
<a href="#l9.99"></a><span id="l9.99">    * The set definition supports the following attributes:</span>
<a href="#l9.100"></a><span id="l9.100">    *  count: The number of messages to create.</span>
<a href="#l9.101"></a><span id="l9.101">    *  age: As used by makeMessage.</span>
<a href="#l9.102"></a><span id="l9.102">    *  age_incr: Similar to age, but used to increment the values in the age</span>
<a href="#l9.103"></a><span id="l9.103">    *      dictionary (assuming a value of zero if omitted).</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/test/resources/messageInjection.js</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/test/resources/messageInjection.js</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -637,16 +637,23 @@ function add_sets_to_folders(aMsgFolders</span>
<a href="#l10.4"></a><span id="l10.4">           folder.addMessage(synMsg.toMboxString());</span>
<a href="#l10.5"></a><span id="l10.5">           // if we need to mark the message as junk grab the header and do so</span>
<a href="#l10.6"></a><span id="l10.6">           // (The message set can mark the whole set as junk, but not just</span>
<a href="#l10.7"></a><span id="l10.7">           //  specific messages.)</span>
<a href="#l10.8"></a><span id="l10.8">           if (synMsg.metaState.junk) {</span>
<a href="#l10.9"></a><span id="l10.9">             let msgHdr = messageSet.getMsgHdr(iPerSet);</span>
<a href="#l10.10"></a><span id="l10.10">             msgHdr.setStringProperty(&quot;junkscore&quot;, &quot;100&quot;);</span>
<a href="#l10.11"></a><span id="l10.11">           }</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+          if (synMsg.metaState.read) {</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+            // XXX this will generate an event; I'm not sure if we should be</span>
<a href="#l10.14"></a><span id="l10.14" class="difflineplus">+            //  trying to avoid that or not.  This case is really only added</span>
<a href="#l10.15"></a><span id="l10.15" class="difflineplus">+            //  for IMAP where this makes more sense.</span>
<a href="#l10.16"></a><span id="l10.16" class="difflineplus">+            let msgHdr = messageSet.getMsgHdr(iPerSet);</span>
<a href="#l10.17"></a><span id="l10.17" class="difflineplus">+            msgHdr.markRead(true);</span>
<a href="#l10.18"></a><span id="l10.18" class="difflineplus">+          }</span>
<a href="#l10.19"></a><span id="l10.19">           folder.gettingNewMessages = false;</span>
<a href="#l10.20"></a><span id="l10.20">           folder.hasNewMessages = true;</span>
<a href="#l10.21"></a><span id="l10.21">           didSomething = true;</span>
<a href="#l10.22"></a><span id="l10.22">         }</span>
<a href="#l10.23"></a><span id="l10.23">       }</span>
<a href="#l10.24"></a><span id="l10.24">       iPerSet++;</span>
<a href="#l10.25"></a><span id="l10.25">       folder = iterFolders.next();</span>
<a href="#l10.26"></a><span id="l10.26">     } while (didSomething);</span>
<a href="#l10.27"></a><span id="l10.27" class="difflineat">@@ -682,16 +689,18 @@ function add_sets_to_folders(aMsgFolders</span>
<a href="#l10.28"></a><span id="l10.28">                                null, null);</span>
<a href="#l10.29"></a><span id="l10.29">             let imapMsg = new imapMessage(msgURI.spec, fakeFolder.uidnext++, []);</span>
<a href="#l10.30"></a><span id="l10.30">             // If the message's meta-state indicates it is junk, set that flag.</span>
<a href="#l10.31"></a><span id="l10.31">             // There is also a NotJunk flag, but we're not playing with that</span>
<a href="#l10.32"></a><span id="l10.32">             //  right now; as long as nothing is ever marked as junk, the junk</span>
<a href="#l10.33"></a><span id="l10.33">             //  classifier won't run, so it's moot for now.</span>
<a href="#l10.34"></a><span id="l10.34">             if (synMsg.metaState.junk)</span>
<a href="#l10.35"></a><span id="l10.35">               imapMsg.setFlag(&quot;Junk&quot;);</span>
<a href="#l10.36"></a><span id="l10.36" class="difflineplus">+            if (synMsg.metaState.read)</span>
<a href="#l10.37"></a><span id="l10.37" class="difflineplus">+              imapMsg.setFlag(&quot;\\Seen&quot;);</span>
<a href="#l10.38"></a><span id="l10.38">             fakeFolder.addMessage(imapMsg);</span>
<a href="#l10.39"></a><span id="l10.39">           }</span>
<a href="#l10.40"></a><span id="l10.40">         }</span>
<a href="#l10.41"></a><span id="l10.41">         iPerSet++;</span>
<a href="#l10.42"></a><span id="l10.42">         folder = iterFolders.next();</span>
<a href="#l10.43"></a><span id="l10.43">       } while (didSomething);</span>
<a href="#l10.44"></a><span id="l10.44"> </span>
<a href="#l10.45"></a><span id="l10.45">       for (let iFolder = 0; iFolder &lt; aMsgFolders.length; iFolder++) {</span>
<a href="#l10.46"></a><span id="l10.46" class="difflineat">@@ -778,16 +787,23 @@ function async_move_messages(aSynMessage</span>
<a href="#l10.47"></a><span id="l10.47"> </span>
<a href="#l10.48"></a><span id="l10.48">       let copyService = Cc[&quot;@mozilla.org/messenger/messagecopyservice;1&quot;]</span>
<a href="#l10.49"></a><span id="l10.49">                           .getService(Ci.nsIMsgCopyService);</span>
<a href="#l10.50"></a><span id="l10.50">       for (let [folder, xpcomHdrArray] in</span>
<a href="#l10.51"></a><span id="l10.51">            aSynMessageSet.foldersWithXpcomHdrArrays) {</span>
<a href="#l10.52"></a><span id="l10.52">         mark_action(&quot;messageInjection&quot;,</span>
<a href="#l10.53"></a><span id="l10.53">                     &quot;moving messages&quot;,</span>
<a href="#l10.54"></a><span id="l10.54">                     [&quot;from&quot;, folder, &quot;to&quot;, realDestFolder]);</span>
<a href="#l10.55"></a><span id="l10.55" class="difflineplus">+</span>
<a href="#l10.56"></a><span id="l10.56" class="difflineplus">+        // In the IMAP case tell listeners we are moving messages without</span>
<a href="#l10.57"></a><span id="l10.57" class="difflineplus">+        //  destination headers.</span>
<a href="#l10.58"></a><span id="l10.58" class="difflineplus">+        if (!message_injection_is_local())</span>
<a href="#l10.59"></a><span id="l10.59" class="difflineplus">+          _messageInjectionSetup.notifyListeners(</span>
<a href="#l10.60"></a><span id="l10.60" class="difflineplus">+            &quot;onMovingMessagesWithoutDestHeaders&quot;, [realDestFolder]);</span>
<a href="#l10.61"></a><span id="l10.61" class="difflineplus">+</span>
<a href="#l10.62"></a><span id="l10.62">         copyService.CopyMessages(folder, xpcomHdrArray,</span>
<a href="#l10.63"></a><span id="l10.63">                                  realDestFolder, /* move */ true,</span>
<a href="#l10.64"></a><span id="l10.64">                                  asyncCopyListener, null,</span>
<a href="#l10.65"></a><span id="l10.65">                                  /* do not allow undo, leaks */ false);</span>
<a href="#l10.66"></a><span id="l10.66">         // update the synthetic message set's folder entry...</span>
<a href="#l10.67"></a><span id="l10.67">         aSynMessageSet._folderSwap(folder, realDestFolder);</span>
<a href="#l10.68"></a><span id="l10.68">         yield false;</span>
<a href="#l10.69"></a><span id="l10.69"> </span>
<a href="#l10.70"></a><span id="l10.70" class="difflineat">@@ -816,16 +832,105 @@ function async_move_messages(aSynMessage</span>
<a href="#l10.71"></a><span id="l10.71">           }</span>
<a href="#l10.72"></a><span id="l10.72">         }</span>
<a href="#l10.73"></a><span id="l10.73">       }</span>
<a href="#l10.74"></a><span id="l10.74">     },</span>
<a href="#l10.75"></a><span id="l10.75">   });</span>
<a href="#l10.76"></a><span id="l10.76"> }</span>
<a href="#l10.77"></a><span id="l10.77"> </span>
<a href="#l10.78"></a><span id="l10.78"> /**</span>
<a href="#l10.79"></a><span id="l10.79" class="difflineplus">+ * Move the messages to the trash; do not use this on messages that are already</span>
<a href="#l10.80"></a><span id="l10.80" class="difflineplus">+ *  in the trash, we are not clever enough for that.</span>
<a href="#l10.81"></a><span id="l10.81" class="difflineplus">+ *</span>
<a href="#l10.82"></a><span id="l10.82" class="difflineplus">+ * @param aSynMessageSet The set of messages to trash.  The messages do not all</span>
<a href="#l10.83"></a><span id="l10.83" class="difflineplus">+ *     have to be in the same folder, but we have to trash them folder by</span>
<a href="#l10.84"></a><span id="l10.84" class="difflineplus">+ *     folder if they are not.</span>
<a href="#l10.85"></a><span id="l10.85" class="difflineplus">+ */</span>
<a href="#l10.86"></a><span id="l10.86" class="difflineplus">+function async_trash_messages(aSynMessageSet) {</span>
<a href="#l10.87"></a><span id="l10.87" class="difflineplus">+  mark_action(&quot;messageInjection&quot;, &quot;trashing messages&quot;,</span>
<a href="#l10.88"></a><span id="l10.88" class="difflineplus">+              aSynMessageSet.msgHdrList);</span>
<a href="#l10.89"></a><span id="l10.89" class="difflineplus">+  return async_run({func: function () {</span>
<a href="#l10.90"></a><span id="l10.90" class="difflineplus">+      for (let [folder, xpcomHdrArray] in</span>
<a href="#l10.91"></a><span id="l10.91" class="difflineplus">+           aSynMessageSet.foldersWithXpcomHdrArrays) {</span>
<a href="#l10.92"></a><span id="l10.92" class="difflineplus">+        mark_action(&quot;messageInjection&quot;, &quot;trashing messages in folder&quot;,</span>
<a href="#l10.93"></a><span id="l10.93" class="difflineplus">+                    [folder]);</span>
<a href="#l10.94"></a><span id="l10.94" class="difflineplus">+        // In the IMAP case tell listeners we are moving messages without</span>
<a href="#l10.95"></a><span id="l10.95" class="difflineplus">+        //  destination headers, since that's what trashing amounts to.</span>
<a href="#l10.96"></a><span id="l10.96" class="difflineplus">+        if (!message_injection_is_local())</span>
<a href="#l10.97"></a><span id="l10.97" class="difflineplus">+          _messageInjectionSetup.notifyListeners(</span>
<a href="#l10.98"></a><span id="l10.98" class="difflineplus">+            &quot;onMovingMessagesWithoutDestHeaders&quot;, []);</span>
<a href="#l10.99"></a><span id="l10.99" class="difflineplus">+        folder.deleteMessages(xpcomHdrArray, null, false, true,</span>
<a href="#l10.100"></a><span id="l10.100" class="difflineplus">+                              asyncCopyListener,</span>
<a href="#l10.101"></a><span id="l10.101" class="difflineplus">+                              /* do not allow undo, currently leaks */ false);</span>
<a href="#l10.102"></a><span id="l10.102" class="difflineplus">+        yield false;</span>
<a href="#l10.103"></a><span id="l10.103" class="difflineplus">+</span>
<a href="#l10.104"></a><span id="l10.104" class="difflineplus">+        // just like the move case we need to force updateFolder calls for IMAP</span>
<a href="#l10.105"></a><span id="l10.105" class="difflineplus">+        if (!message_injection_is_local()) {</span>
<a href="#l10.106"></a><span id="l10.106" class="difflineplus">+          mark_action(&quot;messageInjection&quot;,</span>
<a href="#l10.107"></a><span id="l10.107" class="difflineplus">+                      &quot;forcing update of folder so IMAP move issued&quot;,</span>
<a href="#l10.108"></a><span id="l10.108" class="difflineplus">+                      [folder]);</span>
<a href="#l10.109"></a><span id="l10.109" class="difflineplus">+          // update the source folder to force it to issue the move</span>
<a href="#l10.110"></a><span id="l10.110" class="difflineplus">+          updateFolderAndNotify(folder, async_driver);</span>
<a href="#l10.111"></a><span id="l10.111" class="difflineplus">+          yield false;</span>
<a href="#l10.112"></a><span id="l10.112" class="difflineplus">+</span>
<a href="#l10.113"></a><span id="l10.113" class="difflineplus">+          // trash folder may not have existed at startup but the deletion</span>
<a href="#l10.114"></a><span id="l10.114" class="difflineplus">+          //  will have created it.</span>
<a href="#l10.115"></a><span id="l10.115" class="difflineplus">+          if (!_messageInjectionSetup.trashFolder)</span>
<a href="#l10.116"></a><span id="l10.116" class="difflineplus">+            _messageInjectionSetup.trashFolder =</span>
<a href="#l10.117"></a><span id="l10.117" class="difflineplus">+              _messageInjectionSetup.rootFolder.getFolderWithFlags(</span>
<a href="#l10.118"></a><span id="l10.118" class="difflineplus">+                Ci.nsMsgFolderFlags.Trash);</span>
<a href="#l10.119"></a><span id="l10.119" class="difflineplus">+          let trashFolder = _messageInjectionSetup.trashFolder;</span>
<a href="#l10.120"></a><span id="l10.120" class="difflineplus">+</span>
<a href="#l10.121"></a><span id="l10.121" class="difflineplus">+          mark_action(&quot;messageInjection&quot;,</span>
<a href="#l10.122"></a><span id="l10.122" class="difflineplus">+                      &quot;forcing update of folder so IMAP moved header seen&quot;,</span>
<a href="#l10.123"></a><span id="l10.123" class="difflineplus">+                      [trashFolder]);</span>
<a href="#l10.124"></a><span id="l10.124" class="difflineplus">+          // update the dest folder to see the new header.</span>
<a href="#l10.125"></a><span id="l10.125" class="difflineplus">+          updateFolderAndNotify(trashFolder, async_driver);</span>
<a href="#l10.126"></a><span id="l10.126" class="difflineplus">+          yield false;</span>
<a href="#l10.127"></a><span id="l10.127" class="difflineplus">+</span>
<a href="#l10.128"></a><span id="l10.128" class="difflineplus">+          // compel download of messages in dest folder if appropriate</span>
<a href="#l10.129"></a><span id="l10.129" class="difflineplus">+          if (trashFolder.flags &amp; Ci.nsMsgFolderFlags.Offline) {</span>
<a href="#l10.130"></a><span id="l10.130" class="difflineplus">+            mark_action(&quot;messageInjection&quot;, &quot;offlining messages&quot;,</span>
<a href="#l10.131"></a><span id="l10.131" class="difflineplus">+                        [trashFolder]);</span>
<a href="#l10.132"></a><span id="l10.132" class="difflineplus">+            trashFolder.downloadAllForOffline(asyncUrlListener, null);</span>
<a href="#l10.133"></a><span id="l10.133" class="difflineplus">+            yield false;</span>
<a href="#l10.134"></a><span id="l10.134" class="difflineplus">+          }</span>
<a href="#l10.135"></a><span id="l10.135" class="difflineplus">+        }</span>
<a href="#l10.136"></a><span id="l10.136" class="difflineplus">+      }</span>
<a href="#l10.137"></a><span id="l10.137" class="difflineplus">+    },</span>
<a href="#l10.138"></a><span id="l10.138" class="difflineplus">+  });</span>
<a href="#l10.139"></a><span id="l10.139" class="difflineplus">+}</span>
<a href="#l10.140"></a><span id="l10.140" class="difflineplus">+</span>
<a href="#l10.141"></a><span id="l10.141" class="difflineplus">+/**</span>
<a href="#l10.142"></a><span id="l10.142" class="difflineplus">+ * Delete all of the messages in a SyntheticMessageSet like the user performed a</span>
<a href="#l10.143"></a><span id="l10.143" class="difflineplus">+ *  shift-delete (or if the messages were already in the trash).</span>
<a href="#l10.144"></a><span id="l10.144" class="difflineplus">+ *</span>
<a href="#l10.145"></a><span id="l10.145" class="difflineplus">+ * This is actually a synchronous operation.  I'm surprised too.</span>
<a href="#l10.146"></a><span id="l10.146" class="difflineplus">+ *</span>
<a href="#l10.147"></a><span id="l10.147" class="difflineplus">+ * @param aSynMessageSet The set of messages to delete.  The messages do not all</span>
<a href="#l10.148"></a><span id="l10.148" class="difflineplus">+ *     have to be in the same folder, but we have to delete them folder by</span>
<a href="#l10.149"></a><span id="l10.149" class="difflineplus">+ *     folder if they are not.</span>
<a href="#l10.150"></a><span id="l10.150" class="difflineplus">+ */</span>
<a href="#l10.151"></a><span id="l10.151" class="difflineplus">+function async_delete_messages(aSynMessageSet) {</span>
<a href="#l10.152"></a><span id="l10.152" class="difflineplus">+  mark_action(&quot;messageInjection&quot;, &quot;deleting messages&quot;,</span>
<a href="#l10.153"></a><span id="l10.153" class="difflineplus">+              aSynMessageSet.msgHdrList);</span>
<a href="#l10.154"></a><span id="l10.154" class="difflineplus">+  for (let [folder, xpcomHdrArray] in</span>
<a href="#l10.155"></a><span id="l10.155" class="difflineplus">+       aSynMessageSet.foldersWithXpcomHdrArrays) {</span>
<a href="#l10.156"></a><span id="l10.156" class="difflineplus">+    mark_action(&quot;messageInjection&quot;, &quot;deleting messages in folder&quot;,</span>
<a href="#l10.157"></a><span id="l10.157" class="difflineplus">+                [folder]);</span>
<a href="#l10.158"></a><span id="l10.158" class="difflineplus">+    folder.deleteMessages(xpcomHdrArray, null,</span>
<a href="#l10.159"></a><span id="l10.159" class="difflineplus">+                          /* delete storage */ true,</span>
<a href="#l10.160"></a><span id="l10.160" class="difflineplus">+                          /* is move? */ false,</span>
<a href="#l10.161"></a><span id="l10.161" class="difflineplus">+                          asyncCopyListener,</span>
<a href="#l10.162"></a><span id="l10.162" class="difflineplus">+                          /* do not allow undo, currently leaks */ false);</span>
<a href="#l10.163"></a><span id="l10.163" class="difflineplus">+  }</span>
<a href="#l10.164"></a><span id="l10.164" class="difflineplus">+  return true;</span>
<a href="#l10.165"></a><span id="l10.165" class="difflineplus">+}</span>
<a href="#l10.166"></a><span id="l10.166" class="difflineplus">+</span>
<a href="#l10.167"></a><span id="l10.167" class="difflineplus">+/**</span>
<a href="#l10.168"></a><span id="l10.168">  * Empty the trash.</span>
<a href="#l10.169"></a><span id="l10.169">  */</span>
<a href="#l10.170"></a><span id="l10.170"> function async_empty_trash() {</span>
<a href="#l10.171"></a><span id="l10.171">   _messageInjectionSetup.trashFolder.emptyTrash(null, asyncUrlListener);</span>
<a href="#l10.172"></a><span id="l10.172">   return false;</span>
<a href="#l10.173"></a><span id="l10.173"> }</span>
<a href="#l10.174"></a><span id="l10.174"> </span>
<a href="#l10.175"></a><span id="l10.175"> /**</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

