<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 3533:7d5450206f5b6bdccafc8e632052d8280826b049</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 7d5450206f5b6bdccafc8e632052d8280826b049" />
<meta property="og:url" content="/comm-central/rev/7d5450206f5b6bdccafc8e632052d8280826b049" />
<meta property="og:description" content="Bug 466227 - gloda should index IMAP messages that are not offline too (headers only). Implement indexing of messages in non-offline IMAP folders, and add tests for both offline and non-offline IMAP messages. r=asuth+bienvenu, sr=bienvenu." />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 7d5450206f5b6bdccafc8e632052d8280826b049 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/7d5450206f5b6bdccafc8e632052d8280826b049">shortlog</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/7d5450206f5b6bdccafc8e632052d8280826b049">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049">files</a> |
changeset |
<a href="/comm-central/raw-rev/7d5450206f5b6bdccafc8e632052d8280826b049">raw</a>  | <a href="/comm-central/archive/7d5450206f5b6bdccafc8e632052d8280826b049.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=466227">Bug 466227</a> - gloda should index IMAP messages that are not offline too (headers only). Implement indexing of messages in non-offline IMAP folders, and add tests for both offline and non-offline IMAP messages. r=asuth+bienvenu, sr=bienvenu.
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#83;&#105;&#100;&#100;&#104;&#97;&#114;&#116;&#104;&#32;&#65;&#103;&#97;&#114;&#119;&#97;&#108;&#32;&#60;&#115;&#105;&#100;&#46;&#98;&#117;&#103;&#122;&#105;&#108;&#108;&#97;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Fri, 04 Sep 2009 23:26:52 +0530</td></tr>

<tr>
 <td>changeset 3533</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/7d5450206f5b6bdccafc8e632052d8280826b049">7d5450206f5b6bdccafc8e632052d8280826b049</a></td>
</tr>



<tr>
<td>parent 3532</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/310086e2a1d1ac065a0292d6a7826f597effaec5">310086e2a1d1ac065a0292d6a7826f597effaec5</a>
</td>
</tr>

<tr>
<td>child 3534</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/8a32844b76fbefd99acfeb450b3201ca4ac76bb9">8a32844b76fbefd99acfeb450b3201ca4ac76bb9</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=7d5450206f5b6bdccafc8e632052d8280826b049">2865</a></td></tr>
<tr><td>push user</td><td>sid.bugzilla@gmail.com</td></tr>
<tr><td>push date</td><td class="date age">Fri, 04 Sep 2009 17:58:58 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@7d5450206f5b [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=7d5450206f5b6bdccafc8e632052d8280826b049">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=7d5450206f5b6bdccafc8e632052d8280826b049&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=7d5450206f5b6bdccafc8e632052d8280826b049&newProject=comm-central&newRevision=7d5450206f5b6bdccafc8e632052d8280826b049&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=7d5450206f5b6bdccafc8e632052d8280826b049&newProject=comm-central&newRevision=7d5450206f5b6bdccafc8e632052d8280826b049&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=7d5450206f5b6bdccafc8e632052d8280826b049&newProject=comm-central&newRevision=7d5450206f5b6bdccafc8e632052d8280826b049&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28asuth%29&revcount=50">asuth</a>, <a href="/comm-central/log?rev=reviewer%28bienvenu%29&revcount=50">bienvenu</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=466227">466227</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=466227">Bug 466227</a> - gloda should index IMAP messages that are not offline too (headers only). Implement indexing of messages in non-offline IMAP folders, and add tests for both offline and non-offline IMAP messages. r=asuth+bienvenu, sr=bienvenu.

This patch includes a fix for a bug in maild.js where the input stream gets GCed early, and also has asuth's &quot;v1 make test_query_core.js xpcshell test work on linux&quot; fix.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/datamodel.js">mailnews/db/gloda/modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/datastore.js">mailnews/db/gloda/modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/fundattr.js">mailnews/db/gloda/modules/fundattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/fundattr.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/fundattr.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/fundattr.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/fundattr.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/fundattr.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/gloda.js">mailnews/db/gloda/modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/indexer.js">mailnews/db/gloda/modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/query.js">mailnews/db/gloda/modules/query.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/query.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/query.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/query.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/query.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/modules/query.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content.js">mailnews/db/gloda/test/unit/test_gloda_content.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js">mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content_imap_switched_to_offline.js">mailnews/db/gloda/test/unit/test_gloda_content_imap_switched_to_offline.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content_imap_switched_to_offline.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content_imap_switched_to_offline.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content_imap_switched_to_offline.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content_imap_switched_to_offline.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_gloda_content_imap_switched_to_offline.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_messages.js">mailnews/db/gloda/test/unit/test_index_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_messages.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_messages.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_messages.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_messages.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_messages.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js">mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js">mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages_in_bulk.js">mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages_in_bulk.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages_in_bulk.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages_in_bulk.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages_in_bulk.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages_in_bulk.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages_in_bulk.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js">mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages_in_bulk.js">mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages_in_bulk.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages_in_bulk.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages_in_bulk.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages_in_bulk.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages_in_bulk.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages_in_bulk.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js">mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages_in_bulk.js">mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages_in_bulk.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages_in_bulk.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages_in_bulk.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages_in_bulk.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages_in_bulk.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages_in_bulk.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_core.js">mailnews/db/gloda/test/unit/test_query_core.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_core.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_core.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_core.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_core.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_core.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_messages.js">mailnews/db/gloda/test/unit/test_query_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_messages.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_messages.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_messages.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_messages.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_messages.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js">mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js">mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js">mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/fakeserver/maild.js">mailnews/test/fakeserver/maild.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/fakeserver/maild.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/fakeserver/maild.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/fakeserver/maild.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/fakeserver/maild.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/fakeserver/maild.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/resources/mailDirService.js">mailnews/test/resources/mailDirService.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/resources/mailDirService.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/resources/mailDirService.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/resources/mailDirService.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/resources/mailDirService.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/resources/mailDirService.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/resources/mailTestUtils.js">mailnews/test/resources/mailTestUtils.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/resources/mailTestUtils.js">file</a> |
<a href="/comm-central/annotate/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/resources/mailTestUtils.js">annotate</a> |
<a href="/comm-central/diff/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/resources/mailTestUtils.js">diff</a> |
<a href="/comm-central/comparison/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/resources/mailTestUtils.js">comparison</a> |
<a href="/comm-central/log/7d5450206f5b6bdccafc8e632052d8280826b049/mailnews/test/resources/mailTestUtils.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -444,17 +444,18 @@ GlodaMessage.prototype = {</span>
<a href="#l1.4"></a><span id="l1.4">   toString: function gloda_message_toString() {</span>
<a href="#l1.5"></a><span id="l1.5">     // uh, this is a tough one...</span>
<a href="#l1.6"></a><span id="l1.6">     return &quot;Message:&quot; + this._id;</span>
<a href="#l1.7"></a><span id="l1.7">   },</span>
<a href="#l1.8"></a><span id="l1.8"> </span>
<a href="#l1.9"></a><span id="l1.9">   _clone: function gloda_message_clone() {</span>
<a href="#l1.10"></a><span id="l1.10">     return new GlodaMessage(this._datastore, this._id, this._folderID,</span>
<a href="#l1.11"></a><span id="l1.11">       this._messageKey, this._conversationID, this._conversation, this._date,</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-      this._headerMessageID, this._deleted);</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+      this._headerMessageID, this._deleted, this._jsonText, this._notability,</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+      this._subject, this._indexedBodyText, this._attachmentNames);</span>
<a href="#l1.15"></a><span id="l1.15">   },</span>
<a href="#l1.16"></a><span id="l1.16"> </span>
<a href="#l1.17"></a><span id="l1.17">   _ghost: function gloda_message_ghost() {</span>
<a href="#l1.18"></a><span id="l1.18">     this._folderID = null;</span>
<a href="#l1.19"></a><span id="l1.19">     this._messageKey = null;</span>
<a href="#l1.20"></a><span id="l1.20">   },</span>
<a href="#l1.21"></a><span id="l1.21"> </span>
<a href="#l1.22"></a><span id="l1.22">   _nuke: function gloda_message_nuke() {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -15,16 +15,17 @@</span>
<a href="#l2.4"></a><span id="l2.4">  *</span>
<a href="#l2.5"></a><span id="l2.5">  * The Initial Developer of the Original Code is</span>
<a href="#l2.6"></a><span id="l2.6">  * Mozilla Messaging, Inc.</span>
<a href="#l2.7"></a><span id="l2.7">  * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l2.8"></a><span id="l2.8">  * the Initial Developer. All Rights Reserved.</span>
<a href="#l2.9"></a><span id="l2.9">  *</span>
<a href="#l2.10"></a><span id="l2.10">  * Contributor(s):</span>
<a href="#l2.11"></a><span id="l2.11">  *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+ *   Siddharth Agarwal &lt;sid.bugzilla@gmail.com&gt;</span>
<a href="#l2.13"></a><span id="l2.13">  *</span>
<a href="#l2.14"></a><span id="l2.14">  * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l2.15"></a><span id="l2.15">  * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l2.16"></a><span id="l2.16">  * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l2.17"></a><span id="l2.17">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l2.18"></a><span id="l2.18">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l2.19"></a><span id="l2.19">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l2.20"></a><span id="l2.20">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l2.21"></a><span id="l2.21" class="difflineat">@@ -48,62 +49,16 @@ const Cr = Components.results;</span>
<a href="#l2.22"></a><span id="l2.22"> const Cu = Components.utils;</span>
<a href="#l2.23"></a><span id="l2.23"> </span>
<a href="#l2.24"></a><span id="l2.24"> Cu.import(&quot;resource://app/modules/gloda/log4moz.js&quot;);</span>
<a href="#l2.25"></a><span id="l2.25"> </span>
<a href="#l2.26"></a><span id="l2.26"> Cu.import(&quot;resource://app/modules/gloda/datamodel.js&quot;);</span>
<a href="#l2.27"></a><span id="l2.27"> Cu.import(&quot;resource://app/modules/gloda/databind.js&quot;);</span>
<a href="#l2.28"></a><span id="l2.28"> Cu.import(&quot;resource://app/modules/gloda/collection.js&quot;);</span>
<a href="#l2.29"></a><span id="l2.29"> </span>
<a href="#l2.30"></a><span id="l2.30" class="difflineminus">-let MBM_LOG = Log4Moz.repository.getLogger(&quot;gloda.ds.mbm&quot;);</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineminus">-</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineminus">-/**</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineminus">- * @class This callback handles processing the asynchronous query results of</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineminus">- *  GlodaDatastore.getMessagesByMessageID.  Because that method is only</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineminus">- *  called as part of the indexing process, we are guaranteed that there will</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineminus">- *  be no real caching ramifications.  Accordingly, we can also defer our cache</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineminus">- *  processing (via GlodaCollectionManager) until the query completes.</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineminus">- *</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineminus">- * @param aMsgIDToIndex Map from message-id to the desired</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineminus">- *</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineminus">- * @constructor</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineminus">- */</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineminus">-function MessagesByMessageIdCallback(aMsgIDToIndex, aResults,</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineminus">-                                     aCallback, aCallbackThis) {</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineminus">-  this.msgIDToIndex = aMsgIDToIndex;</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineminus">-  this.results = aResults;</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineminus">-  this.callback = aCallback;</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineminus">-  this.callbackThis = aCallbackThis;</span>
<a href="#l2.49"></a><span id="l2.49" class="difflineminus">-}</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineminus">-</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineminus">-MessagesByMessageIdCallback.prototype = {</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineminus">-  onItemsAdded: function gloda_ds_mbmi_onItemsAdded(aItems, aCollection) {</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineminus">-    // just outright bail if we are shutdown</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineminus">-    if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineminus">-      return;</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineminus">-</span>
<a href="#l2.57"></a><span id="l2.57" class="difflineminus">-    MBM_LOG.debug(&quot;getting results...&quot;);</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineminus">-    for each (let [, message] in Iterator(aItems)) {</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineminus">-      this.results[this.msgIDToIndex[message.headerMessageID]].push(message);</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineminus">-    }</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineminus">-  },</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineminus">-  onItemsModified: function () {},</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineminus">-  onItemsRemoved: function () {},</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineminus">-  onQueryCompleted: function gloda_ds_mbmi_onQueryCompleted(aCollection) {</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineminus">-    // just outright bail if we are shutdown</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineminus">-    if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineminus">-      return;</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineminus">-</span>
<a href="#l2.69"></a><span id="l2.69" class="difflineminus">-    MBM_LOG.debug(&quot;query completed, notifying... &quot; + this.results);</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineminus">-    // we no longer need to unify; it is done for us.</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineminus">-</span>
<a href="#l2.72"></a><span id="l2.72" class="difflineminus">-    this.callback.call(this.callbackThis, this.results);</span>
<a href="#l2.73"></a><span id="l2.73" class="difflineminus">-  }</span>
<a href="#l2.74"></a><span id="l2.74" class="difflineminus">-};</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineminus">-</span>
<a href="#l2.76"></a><span id="l2.76"> let PCH_LOG = Log4Moz.repository.getLogger(&quot;gloda.ds.pch&quot;);</span>
<a href="#l2.77"></a><span id="l2.77"> </span>
<a href="#l2.78"></a><span id="l2.78"> function PostCommitHandler(aCallbacks) {</span>
<a href="#l2.79"></a><span id="l2.79">   this.callbacks = aCallbacks;</span>
<a href="#l2.80"></a><span id="l2.80">   GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l2.81"></a><span id="l2.81"> }</span>
<a href="#l2.82"></a><span id="l2.82"> </span>
<a href="#l2.83"></a><span id="l2.83"> PostCommitHandler.prototype = {</span>
<a href="#l2.84"></a><span id="l2.84" class="difflineat">@@ -1883,44 +1838,56 @@ var GlodaDatastore = {</span>
<a href="#l2.85"></a><span id="l2.85">        ims.executeAsync(this.trackAsync());</span>
<a href="#l2.86"></a><span id="l2.86">     }</span>
<a href="#l2.87"></a><span id="l2.87">     catch(ex) {</span>
<a href="#l2.88"></a><span id="l2.88">        throw(&quot;error executing statement... &quot; +</span>
<a href="#l2.89"></a><span id="l2.89">              this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l2.90"></a><span id="l2.90">              this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l2.91"></a><span id="l2.91">     }</span>
<a href="#l2.92"></a><span id="l2.92"> </span>
<a href="#l2.93"></a><span id="l2.93" class="difflineminus">-    // we only create the full-text row if the body is non-null.</span>
<a href="#l2.94"></a><span id="l2.94" class="difflineminus">-    // so, even though body might be null, we still want to create the</span>
<a href="#l2.95"></a><span id="l2.95" class="difflineminus">-    //  full-text search row</span>
<a href="#l2.96"></a><span id="l2.96" class="difflineminus">-    if (aMessage._bodyLines) {</span>
<a href="#l2.97"></a><span id="l2.97" class="difflineminus">-      if (aMessage._content &amp;&amp; aMessage._content.hasContent())</span>
<a href="#l2.98"></a><span id="l2.98" class="difflineminus">-        aMessage._indexedBodyText = aMessage._content.getContentString(true);</span>
<a href="#l2.99"></a><span id="l2.99" class="difflineminus">-      else</span>
<a href="#l2.100"></a><span id="l2.100" class="difflineminus">-        aMessage._indexedBodyText = aMessage._bodyLines.join(&quot;\n&quot;);</span>
<a href="#l2.101"></a><span id="l2.101" class="difflineminus">-</span>
<a href="#l2.102"></a><span id="l2.102" class="difflineminus">-      let imts = this._insertMessageTextStatement;</span>
<a href="#l2.103"></a><span id="l2.103" class="difflineminus">-      imts.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l2.104"></a><span id="l2.104" class="difflineminus">-      imts.bindStringParameter(1, aMessage._subject);</span>
<a href="#l2.105"></a><span id="l2.105" class="difflineplus">+    // we create the full-text row for any message that isn't a ghost,</span>
<a href="#l2.106"></a><span id="l2.106" class="difflineplus">+    // whether we have the body or not</span>
<a href="#l2.107"></a><span id="l2.107" class="difflineplus">+    if (aMessage.folderID !== null)</span>
<a href="#l2.108"></a><span id="l2.108" class="difflineplus">+      this._insertMessageText(aMessage);</span>
<a href="#l2.109"></a><span id="l2.109" class="difflineplus">+  },</span>
<a href="#l2.110"></a><span id="l2.110" class="difflineplus">+</span>
<a href="#l2.111"></a><span id="l2.111" class="difflineplus">+  /**</span>
<a href="#l2.112"></a><span id="l2.112" class="difflineplus">+   * Inserts a full-text row. This should only be called if you're sure you want</span>
<a href="#l2.113"></a><span id="l2.113" class="difflineplus">+   * to insert a row into the table.</span>
<a href="#l2.114"></a><span id="l2.114" class="difflineplus">+   */</span>
<a href="#l2.115"></a><span id="l2.115" class="difflineplus">+  _insertMessageText: function gloda_ds__insertMessageText(aMessage) {</span>
<a href="#l2.116"></a><span id="l2.116" class="difflineplus">+    if (aMessage._content &amp;&amp; aMessage._content.hasContent())</span>
<a href="#l2.117"></a><span id="l2.117" class="difflineplus">+      aMessage._indexedBodyText = aMessage._content.getContentString(true);</span>
<a href="#l2.118"></a><span id="l2.118" class="difflineplus">+    else if (aMessage._bodyLines)</span>
<a href="#l2.119"></a><span id="l2.119" class="difflineplus">+      aMessage._indexedBodyText = aMessage._bodyLines.join(&quot;\n&quot;);</span>
<a href="#l2.120"></a><span id="l2.120" class="difflineplus">+    else</span>
<a href="#l2.121"></a><span id="l2.121" class="difflineplus">+      aMessage._indexedBodyText = null;</span>
<a href="#l2.122"></a><span id="l2.122" class="difflineplus">+</span>
<a href="#l2.123"></a><span id="l2.123" class="difflineplus">+    let imts = this._insertMessageTextStatement;</span>
<a href="#l2.124"></a><span id="l2.124" class="difflineplus">+    imts.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l2.125"></a><span id="l2.125" class="difflineplus">+    imts.bindStringParameter(1, aMessage._subject);</span>
<a href="#l2.126"></a><span id="l2.126" class="difflineplus">+    if (aMessage._indexedBodyText == null)</span>
<a href="#l2.127"></a><span id="l2.127" class="difflineplus">+      imts.bindNullParameter(2);</span>
<a href="#l2.128"></a><span id="l2.128" class="difflineplus">+    else</span>
<a href="#l2.129"></a><span id="l2.129">       imts.bindStringParameter(2, aMessage._indexedBodyText);</span>
<a href="#l2.130"></a><span id="l2.130" class="difflineminus">-      if (aMessage._attachmentNames === null)</span>
<a href="#l2.131"></a><span id="l2.131" class="difflineminus">-        imts.bindNullParameter(3);</span>
<a href="#l2.132"></a><span id="l2.132" class="difflineminus">-      else</span>
<a href="#l2.133"></a><span id="l2.133" class="difflineminus">-        imts.bindStringParameter(3, aMessage._attachmentNames.join(&quot;\n&quot;));</span>
<a href="#l2.134"></a><span id="l2.134" class="difflineminus">-      imts.bindStringParameter(4, aMessage._indexAuthor);</span>
<a href="#l2.135"></a><span id="l2.135" class="difflineminus">-      imts.bindStringParameter(5, aMessage._indexRecipients);</span>
<a href="#l2.136"></a><span id="l2.136" class="difflineminus">-</span>
<a href="#l2.137"></a><span id="l2.137" class="difflineminus">-      try {</span>
<a href="#l2.138"></a><span id="l2.138" class="difflineminus">-         imts.executeAsync(this.trackAsync());</span>
<a href="#l2.139"></a><span id="l2.139" class="difflineminus">-      }</span>
<a href="#l2.140"></a><span id="l2.140" class="difflineminus">-      catch(ex) {</span>
<a href="#l2.141"></a><span id="l2.141" class="difflineminus">-         throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l2.142"></a><span id="l2.142" class="difflineminus">-               this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l2.143"></a><span id="l2.143" class="difflineminus">-               this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l2.144"></a><span id="l2.144" class="difflineminus">-      }</span>
<a href="#l2.145"></a><span id="l2.145" class="difflineplus">+    if (aMessage._attachmentNames === null)</span>
<a href="#l2.146"></a><span id="l2.146" class="difflineplus">+      imts.bindNullParameter(3);</span>
<a href="#l2.147"></a><span id="l2.147" class="difflineplus">+    else</span>
<a href="#l2.148"></a><span id="l2.148" class="difflineplus">+      imts.bindStringParameter(3, aMessage._attachmentNames.join(&quot;\n&quot;));</span>
<a href="#l2.149"></a><span id="l2.149" class="difflineplus">+</span>
<a href="#l2.150"></a><span id="l2.150" class="difflineplus">+    imts.bindStringParameter(4, aMessage._indexAuthor);</span>
<a href="#l2.151"></a><span id="l2.151" class="difflineplus">+    imts.bindStringParameter(5, aMessage._indexRecipients);</span>
<a href="#l2.152"></a><span id="l2.152" class="difflineplus">+</span>
<a href="#l2.153"></a><span id="l2.153" class="difflineplus">+    try {</span>
<a href="#l2.154"></a><span id="l2.154" class="difflineplus">+      imts.executeAsync(this.trackAsync());</span>
<a href="#l2.155"></a><span id="l2.155" class="difflineplus">+    }</span>
<a href="#l2.156"></a><span id="l2.156" class="difflineplus">+    catch(ex) {</span>
<a href="#l2.157"></a><span id="l2.157" class="difflineplus">+      throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l2.158"></a><span id="l2.158" class="difflineplus">+            this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l2.159"></a><span id="l2.159" class="difflineplus">+            this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l2.160"></a><span id="l2.160">     }</span>
<a href="#l2.161"></a><span id="l2.161">   },</span>
<a href="#l2.162"></a><span id="l2.162"> </span>
<a href="#l2.163"></a><span id="l2.163">   get _updateMessageStatement() {</span>
<a href="#l2.164"></a><span id="l2.164">     let statement = this._createAsyncStatement(</span>
<a href="#l2.165"></a><span id="l2.165">       &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l2.166"></a><span id="l2.166">                            messageKey = ?2, \</span>
<a href="#l2.167"></a><span id="l2.167">                            conversationID = ?3, \</span>
<a href="#l2.168"></a><span id="l2.168" class="difflineat">@@ -1928,20 +1895,34 @@ var GlodaDatastore = {</span>
<a href="#l2.169"></a><span id="l2.169">                            headerMessageID = ?5, \</span>
<a href="#l2.170"></a><span id="l2.170">                            jsonAttributes = ?6, \</span>
<a href="#l2.171"></a><span id="l2.171">                            notability = ?7 \</span>
<a href="#l2.172"></a><span id="l2.172">               WHERE id = ?8&quot;);</span>
<a href="#l2.173"></a><span id="l2.173">     this.__defineGetter__(&quot;_updateMessageStatement&quot;, function() statement);</span>
<a href="#l2.174"></a><span id="l2.174">     return this._updateMessageStatement;</span>
<a href="#l2.175"></a><span id="l2.175">   },</span>
<a href="#l2.176"></a><span id="l2.176"> </span>
<a href="#l2.177"></a><span id="l2.177" class="difflineplus">+  get _updateMessageTextStatement() {</span>
<a href="#l2.178"></a><span id="l2.178" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l2.179"></a><span id="l2.179" class="difflineplus">+      &quot;UPDATE messagesText SET body = ?1, \</span>
<a href="#l2.180"></a><span id="l2.180" class="difflineplus">+                               attachmentNames = ?2 \</span>
<a href="#l2.181"></a><span id="l2.181" class="difflineplus">+              WHERE docid = ?3&quot;);</span>
<a href="#l2.182"></a><span id="l2.182" class="difflineplus">+</span>
<a href="#l2.183"></a><span id="l2.183" class="difflineplus">+    this.__defineGetter__(&quot;_updateMessageTextStatement&quot;, function() statement);</span>
<a href="#l2.184"></a><span id="l2.184" class="difflineplus">+    return this._updateMessageTextStatement;</span>
<a href="#l2.185"></a><span id="l2.185" class="difflineplus">+  },</span>
<a href="#l2.186"></a><span id="l2.186" class="difflineplus">+</span>
<a href="#l2.187"></a><span id="l2.187">   /**</span>
<a href="#l2.188"></a><span id="l2.188" class="difflineminus">-   * Update the database row associated with the message.  If aBody is supplied,</span>
<a href="#l2.189"></a><span id="l2.189" class="difflineminus">-   *  the associated full-text row is created; it is assumed that it did not</span>
<a href="#l2.190"></a><span id="l2.190" class="difflineminus">-   *  previously exist.</span>
<a href="#l2.191"></a><span id="l2.191" class="difflineplus">+   * Update the database row associated with the message. If the message is</span>
<a href="#l2.192"></a><span id="l2.192" class="difflineplus">+   * not a ghost and has _isNew defined, messagesText is affected.</span>
<a href="#l2.193"></a><span id="l2.193" class="difflineplus">+   *</span>
<a href="#l2.194"></a><span id="l2.194" class="difflineplus">+   * aMessage._isNew is currently equivalent to the fact that there is no</span>
<a href="#l2.195"></a><span id="l2.195" class="difflineplus">+   * full-text row associated with this message, and we work with this</span>
<a href="#l2.196"></a><span id="l2.196" class="difflineplus">+   * assumption here. Note that if aMessage._isNew is not defined, then</span>
<a href="#l2.197"></a><span id="l2.197" class="difflineplus">+   * we don't do anything.</span>
<a href="#l2.198"></a><span id="l2.198">    */</span>
<a href="#l2.199"></a><span id="l2.199">   updateMessage: function gloda_ds_updateMessage(aMessage) {</span>
<a href="#l2.200"></a><span id="l2.200">     let ums = this._updateMessageStatement;</span>
<a href="#l2.201"></a><span id="l2.201">     ums.bindInt64Parameter(7, aMessage.id);</span>
<a href="#l2.202"></a><span id="l2.202">     if (aMessage.folderID === null)</span>
<a href="#l2.203"></a><span id="l2.203">       ums.bindNullParameter(0);</span>
<a href="#l2.204"></a><span id="l2.204">     else</span>
<a href="#l2.205"></a><span id="l2.205">       ums.bindInt64Parameter(0, aMessage.folderID);</span>
<a href="#l2.206"></a><span id="l2.206" class="difflineat">@@ -1958,49 +1939,74 @@ var GlodaDatastore = {</span>
<a href="#l2.207"></a><span id="l2.207">     if (aMessage._jsonText)</span>
<a href="#l2.208"></a><span id="l2.208">       ums.bindStringParameter(5, aMessage._jsonText);</span>
<a href="#l2.209"></a><span id="l2.209">     else</span>
<a href="#l2.210"></a><span id="l2.210">       ums.bindNullParameter(5);</span>
<a href="#l2.211"></a><span id="l2.211">     ums.bindInt64Parameter(6, aMessage.notability);</span>
<a href="#l2.212"></a><span id="l2.212"> </span>
<a href="#l2.213"></a><span id="l2.213">     ums.executeAsync(this.trackAsync());</span>
<a href="#l2.214"></a><span id="l2.214"> </span>
<a href="#l2.215"></a><span id="l2.215" class="difflineminus">-    if (aMessage._isNew &amp;&amp; aMessage._bodyLines) {</span>
<a href="#l2.216"></a><span id="l2.216" class="difflineminus">-      if (aMessage._content &amp;&amp; aMessage._content.hasContent())</span>
<a href="#l2.217"></a><span id="l2.217" class="difflineminus">-        aMessage._indexedBodyText = aMessage._content.getContentString(true);</span>
<a href="#l2.218"></a><span id="l2.218" class="difflineminus">-      else</span>
<a href="#l2.219"></a><span id="l2.219" class="difflineminus">-        aMessage._indexedBodyText = aMessage._bodyLines.join(&quot;\n&quot;);</span>
<a href="#l2.220"></a><span id="l2.220" class="difflineminus">-</span>
<a href="#l2.221"></a><span id="l2.221" class="difflineminus">-      let imts = this._insertMessageTextStatement;</span>
<a href="#l2.222"></a><span id="l2.222" class="difflineminus">-      imts.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l2.223"></a><span id="l2.223" class="difflineminus">-      imts.bindStringParameter(1, aMessage._subject);</span>
<a href="#l2.224"></a><span id="l2.224" class="difflineminus">-      imts.bindStringParameter(2, aMessage._indexedBodyText);</span>
<a href="#l2.225"></a><span id="l2.225" class="difflineminus">-      if (aMessage._attachmentNames === null)</span>
<a href="#l2.226"></a><span id="l2.226" class="difflineminus">-        imts.bindNullParameter(3);</span>
<a href="#l2.227"></a><span id="l2.227" class="difflineplus">+    if (aMessage.folderID !== null) {</span>
<a href="#l2.228"></a><span id="l2.228" class="difflineplus">+      if (aMessage._isNew === true)</span>
<a href="#l2.229"></a><span id="l2.229" class="difflineplus">+        this._insertMessageText(aMessage);</span>
<a href="#l2.230"></a><span id="l2.230">       else</span>
<a href="#l2.231"></a><span id="l2.231" class="difflineminus">-        imts.bindStringParameter(3, aMessage._attachmentNames.join(&quot;\n&quot;));</span>
<a href="#l2.232"></a><span id="l2.232" class="difflineminus">-      imts.bindStringParameter(4, aMessage._indexAuthor);</span>
<a href="#l2.233"></a><span id="l2.233" class="difflineminus">-      imts.bindStringParameter(5, aMessage._indexRecipients);</span>
<a href="#l2.234"></a><span id="l2.234" class="difflineminus">-</span>
<a href="#l2.235"></a><span id="l2.235" class="difflineminus">-      try {</span>
<a href="#l2.236"></a><span id="l2.236" class="difflineminus">-         imts.executeAsync(this.trackAsync());</span>
<a href="#l2.237"></a><span id="l2.237" class="difflineminus">-      }</span>
<a href="#l2.238"></a><span id="l2.238" class="difflineminus">-      catch(ex) {</span>
<a href="#l2.239"></a><span id="l2.239" class="difflineminus">-         throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l2.240"></a><span id="l2.240" class="difflineminus">-               this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l2.241"></a><span id="l2.241" class="difflineminus">-               this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l2.242"></a><span id="l2.242" class="difflineminus">-      }</span>
<a href="#l2.243"></a><span id="l2.243" class="difflineplus">+        this._updateMessageText(aMessage);</span>
<a href="#l2.244"></a><span id="l2.244">     }</span>
<a href="#l2.245"></a><span id="l2.245"> </span>
<a href="#l2.246"></a><span id="l2.246">     // In completely abstract theory, this is where we would call</span>
<a href="#l2.247"></a><span id="l2.247">     //  GlodaCollectionManager.itemsModified, except that the attributes may</span>
<a href="#l2.248"></a><span id="l2.248">     //  also have changed, so it's out of our hands.  (Gloda.grokNoun</span>
<a href="#l2.249"></a><span id="l2.249">     //  handles it.)</span>
<a href="#l2.250"></a><span id="l2.250">   },</span>
<a href="#l2.251"></a><span id="l2.251"> </span>
<a href="#l2.252"></a><span id="l2.252" class="difflineplus">+  /**</span>
<a href="#l2.253"></a><span id="l2.253" class="difflineplus">+   * Updates the full-text row associated with this message. This only performs</span>
<a href="#l2.254"></a><span id="l2.254" class="difflineplus">+   * the UPDATE query if the indexed body text has changed, which means that if</span>
<a href="#l2.255"></a><span id="l2.255" class="difflineplus">+   * the body hasn't changed but the attachments have, we don't update.</span>
<a href="#l2.256"></a><span id="l2.256" class="difflineplus">+   */</span>
<a href="#l2.257"></a><span id="l2.257" class="difflineplus">+  _updateMessageText: function gloda_ds__updateMessageText(aMessage) {</span>
<a href="#l2.258"></a><span id="l2.258" class="difflineplus">+    let newIndexedBodyText;</span>
<a href="#l2.259"></a><span id="l2.259" class="difflineplus">+    if (aMessage._content &amp;&amp; aMessage._content.hasContent())</span>
<a href="#l2.260"></a><span id="l2.260" class="difflineplus">+      newIndexedBodyText = aMessage._content.getContentString(true);</span>
<a href="#l2.261"></a><span id="l2.261" class="difflineplus">+    else if (aMessage._bodyLines)</span>
<a href="#l2.262"></a><span id="l2.262" class="difflineplus">+      newIndexedBodyText = aMessage._bodyLines.join(&quot;\n&quot;);</span>
<a href="#l2.263"></a><span id="l2.263" class="difflineplus">+    else</span>
<a href="#l2.264"></a><span id="l2.264" class="difflineplus">+      newIndexedBodyText = null;</span>
<a href="#l2.265"></a><span id="l2.265" class="difflineplus">+</span>
<a href="#l2.266"></a><span id="l2.266" class="difflineplus">+    // If the body text matches, don't perform an update</span>
<a href="#l2.267"></a><span id="l2.267" class="difflineplus">+    if (newIndexedBodyText == aMessage._indexedBodyText) {</span>
<a href="#l2.268"></a><span id="l2.268" class="difflineplus">+      this._log.debug(&quot;in _updateMessageText, skipping update because body matches&quot;);</span>
<a href="#l2.269"></a><span id="l2.269" class="difflineplus">+      return;</span>
<a href="#l2.270"></a><span id="l2.270" class="difflineplus">+    }</span>
<a href="#l2.271"></a><span id="l2.271" class="difflineplus">+</span>
<a href="#l2.272"></a><span id="l2.272" class="difflineplus">+    aMessage._indexedBodyText = newIndexedBodyText;</span>
<a href="#l2.273"></a><span id="l2.273" class="difflineplus">+</span>
<a href="#l2.274"></a><span id="l2.274" class="difflineplus">+    let umts = this._updateMessageTextStatement;</span>
<a href="#l2.275"></a><span id="l2.275" class="difflineplus">+    umts.bindInt64Parameter(2, aMessage.id);</span>
<a href="#l2.276"></a><span id="l2.276" class="difflineplus">+</span>
<a href="#l2.277"></a><span id="l2.277" class="difflineplus">+    if (aMessage._indexedBodyText == null)</span>
<a href="#l2.278"></a><span id="l2.278" class="difflineplus">+      umts.bindNullParameter(0);</span>
<a href="#l2.279"></a><span id="l2.279" class="difflineplus">+    else</span>
<a href="#l2.280"></a><span id="l2.280" class="difflineplus">+      umts.bindStringParameter(0, aMessage._indexedBodyText);</span>
<a href="#l2.281"></a><span id="l2.281" class="difflineplus">+</span>
<a href="#l2.282"></a><span id="l2.282" class="difflineplus">+    if (aMessage._attachmentNames == null)</span>
<a href="#l2.283"></a><span id="l2.283" class="difflineplus">+      umts.bindNullParameter(1);</span>
<a href="#l2.284"></a><span id="l2.284" class="difflineplus">+    else</span>
<a href="#l2.285"></a><span id="l2.285" class="difflineplus">+      umts.bindStringParameter(1, aMessage._attachmentNames.join(&quot;\n&quot;));</span>
<a href="#l2.286"></a><span id="l2.286" class="difflineplus">+</span>
<a href="#l2.287"></a><span id="l2.287" class="difflineplus">+    try {</span>
<a href="#l2.288"></a><span id="l2.288" class="difflineplus">+      umts.executeAsync(this.trackAsync());</span>
<a href="#l2.289"></a><span id="l2.289" class="difflineplus">+    }</span>
<a href="#l2.290"></a><span id="l2.290" class="difflineplus">+    catch(ex) {</span>
<a href="#l2.291"></a><span id="l2.291" class="difflineplus">+      throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l2.292"></a><span id="l2.292" class="difflineplus">+            this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l2.293"></a><span id="l2.293" class="difflineplus">+            this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l2.294"></a><span id="l2.294" class="difflineplus">+    }</span>
<a href="#l2.295"></a><span id="l2.295" class="difflineplus">+  },</span>
<a href="#l2.296"></a><span id="l2.296" class="difflineplus">+</span>
<a href="#l2.297"></a><span id="l2.297">   get _updateMessageLocationStatement() {</span>
<a href="#l2.298"></a><span id="l2.298">     let statement = this._createAsyncStatement(</span>
<a href="#l2.299"></a><span id="l2.299">       &quot;UPDATE messages SET folderID = ?1, messageKey = ?2 WHERE id = ?3&quot;);</span>
<a href="#l2.300"></a><span id="l2.300">     this.__defineGetter__(&quot;_updateMessageLocationStatement&quot;,</span>
<a href="#l2.301"></a><span id="l2.301">                           function() statement);</span>
<a href="#l2.302"></a><span id="l2.302">     return this._updateMessageLocationStatement;</span>
<a href="#l2.303"></a><span id="l2.303">   },</span>
<a href="#l2.304"></a><span id="l2.304"> </span>
<a href="#l2.305"></a><span id="l2.305" class="difflineat">@@ -2207,59 +2213,16 @@ var GlodaDatastore = {</span>
<a href="#l2.306"></a><span id="l2.306">     while (this._syncStep(smidbfs)) {</span>
<a href="#l2.307"></a><span id="l2.307">       messageIDs.push(smidbfs.getInt64(0));</span>
<a href="#l2.308"></a><span id="l2.308">     }</span>
<a href="#l2.309"></a><span id="l2.309">     smidbfs.reset();</span>
<a href="#l2.310"></a><span id="l2.310"> </span>
<a href="#l2.311"></a><span id="l2.311">     return messageIDs;</span>
<a href="#l2.312"></a><span id="l2.312">   },</span>
<a href="#l2.313"></a><span id="l2.313"> </span>
<a href="#l2.314"></a><span id="l2.314" class="difflineminus">-  /**</span>
<a href="#l2.315"></a><span id="l2.315" class="difflineminus">-   * Given a list of Message-ID's, return a matching list of lists of messages</span>
<a href="#l2.316"></a><span id="l2.316" class="difflineminus">-   *  matching those Message-ID's.  So if you pass an array with three</span>
<a href="#l2.317"></a><span id="l2.317" class="difflineminus">-   *  Message-ID's [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], you would get back an array containing</span>
<a href="#l2.318"></a><span id="l2.318" class="difflineminus">-   *  3 lists, where the first list contains all the messages with a message-id</span>
<a href="#l2.319"></a><span id="l2.319" class="difflineminus">-   *  of &quot;a&quot;, and so forth.  The reason a list is returned rather than null/a</span>
<a href="#l2.320"></a><span id="l2.320" class="difflineminus">-   *  message is that we accept the reality that we have multiple copies of</span>
<a href="#l2.321"></a><span id="l2.321" class="difflineminus">-   *  messages with the same ID.</span>
<a href="#l2.322"></a><span id="l2.322" class="difflineminus">-   * This call is asynchronous because it depends on previously created messages</span>
<a href="#l2.323"></a><span id="l2.323" class="difflineminus">-   *  to be reflected in our results, which requires us to execute on the async</span>
<a href="#l2.324"></a><span id="l2.324" class="difflineminus">-   *  thread where all our writes happen.  This also turns out to be a</span>
<a href="#l2.325"></a><span id="l2.325" class="difflineminus">-   *  reasonable thing because we could imagine pathological cases where there</span>
<a href="#l2.326"></a><span id="l2.326" class="difflineminus">-   *  could be a lot of message-id's and/or a lot of messages with those</span>
<a href="#l2.327"></a><span id="l2.327" class="difflineminus">-   *  message-id's.</span>
<a href="#l2.328"></a><span id="l2.328" class="difflineminus">-   */</span>
<a href="#l2.329"></a><span id="l2.329" class="difflineminus">-  getMessagesByMessageID: function gloda_ds_getMessagesByMessageID(aMessageIDs,</span>
<a href="#l2.330"></a><span id="l2.330" class="difflineminus">-      aCallback, aCallbackThis) {</span>
<a href="#l2.331"></a><span id="l2.331" class="difflineminus">-    let msgIDToIndex = {};</span>
<a href="#l2.332"></a><span id="l2.332" class="difflineminus">-    let results = [];</span>
<a href="#l2.333"></a><span id="l2.333" class="difflineminus">-    for (let iID = 0; iID &lt; aMessageIDs.length; ++iID) {</span>
<a href="#l2.334"></a><span id="l2.334" class="difflineminus">-      let msgID = aMessageIDs[iID];</span>
<a href="#l2.335"></a><span id="l2.335" class="difflineminus">-      results.push([]);</span>
<a href="#l2.336"></a><span id="l2.336" class="difflineminus">-      msgIDToIndex[msgID] = iID;</span>
<a href="#l2.337"></a><span id="l2.337" class="difflineminus">-    }</span>
<a href="#l2.338"></a><span id="l2.338" class="difflineminus">-</span>
<a href="#l2.339"></a><span id="l2.339" class="difflineminus">-    // Unfortunately, IN doesn't work with statement binding mechanisms, and</span>
<a href="#l2.340"></a><span id="l2.340" class="difflineminus">-    //  a chain of ORed tests really can't be bound unless we create one per</span>
<a href="#l2.341"></a><span id="l2.341" class="difflineminus">-    //  value of N (seems silly).</span>
<a href="#l2.342"></a><span id="l2.342" class="difflineminus">-    let quotedIDs = [&quot;'&quot; + msgID.replace(&quot;'&quot;, &quot;''&quot;, &quot;g&quot;) + &quot;'&quot; for each</span>
<a href="#l2.343"></a><span id="l2.343" class="difflineminus">-                     ([i, msgID] in Iterator(aMessageIDs))]</span>
<a href="#l2.344"></a><span id="l2.344" class="difflineminus">-    let sqlString = &quot;SELECT * FROM messages WHERE headerMessageID IN (&quot; +</span>
<a href="#l2.345"></a><span id="l2.345" class="difflineminus">-                    quotedIDs + &quot;)&quot;;</span>
<a href="#l2.346"></a><span id="l2.346" class="difflineminus">-</span>
<a href="#l2.347"></a><span id="l2.347" class="difflineminus">-    let nounDef = GlodaMessage.prototype.NOUN_DEF;</span>
<a href="#l2.348"></a><span id="l2.348" class="difflineminus">-    let listener = new MessagesByMessageIdCallback(msgIDToIndex, results,</span>
<a href="#l2.349"></a><span id="l2.349" class="difflineminus">-        aCallback, aCallbackThis);</span>
<a href="#l2.350"></a><span id="l2.350" class="difflineminus">-    // Use a null query because we don't want any update notifications about our</span>
<a href="#l2.351"></a><span id="l2.351" class="difflineminus">-    //  collection.  They would just confuse and anger the listener.</span>
<a href="#l2.352"></a><span id="l2.352" class="difflineminus">-    let query = new nounDef.nullQueryClass();</span>
<a href="#l2.353"></a><span id="l2.353" class="difflineminus">-    return this._queryFromSQLString(sqlString, [], nounDef,</span>
<a href="#l2.354"></a><span id="l2.354" class="difflineminus">-        query, listener);</span>
<a href="#l2.355"></a><span id="l2.355" class="difflineminus">-  },</span>
<a href="#l2.356"></a><span id="l2.356" class="difflineminus">-</span>
<a href="#l2.357"></a><span id="l2.357">   get _updateMessagesMarkDeletedByFolderID() {</span>
<a href="#l2.358"></a><span id="l2.358">     let statement = this._createAsyncStatement(</span>
<a href="#l2.359"></a><span id="l2.359">       &quot;UPDATE messages SET folderID = NULL, messageKey = NULL, \</span>
<a href="#l2.360"></a><span id="l2.360">               deleted = 1 WHERE folderID = ?1&quot;);</span>
<a href="#l2.361"></a><span id="l2.361">     this.__defineGetter__(&quot;_updateMessagesMarkDeletedByFolderID&quot;,</span>
<a href="#l2.362"></a><span id="l2.362">       function() statement);</span>
<a href="#l2.363"></a><span id="l2.363">     return this._updateMessagesMarkDeletedByFolderID;</span>
<a href="#l2.364"></a><span id="l2.364">   },</span>
<a href="#l2.365"></a><span id="l2.365" class="difflineat">@@ -2758,18 +2721,22 @@ var GlodaDatastore = {</span>
<a href="#l2.366"></a><span id="l2.366">     let unionQueries = [aQuery].concat(aQuery._unions);</span>
<a href="#l2.367"></a><span id="l2.367">     let boundArgs = [];</span>
<a href="#l2.368"></a><span id="l2.368"> </span>
<a href="#l2.369"></a><span id="l2.369">     // Use the dbQueryValidityConstraintSuffix to provide constraints that</span>
<a href="#l2.370"></a><span id="l2.370">     //  filter items down to those that are valid for the query mechanism to</span>
<a href="#l2.371"></a><span id="l2.371">     //  return.  For example, in the case of messages, deleted or ghost</span>
<a href="#l2.372"></a><span id="l2.372">     //  messages should not be returned by this query layer.  We require</span>
<a href="#l2.373"></a><span id="l2.373">     //  hand-rolled SQL to do that for now.</span>
<a href="#l2.374"></a><span id="l2.374" class="difflineminus">-    let validityConstraintSuffix  =</span>
<a href="#l2.375"></a><span id="l2.375" class="difflineminus">-      nounDef.dbQueryValidityConstraintSuffix || &quot;&quot;;</span>
<a href="#l2.376"></a><span id="l2.376" class="difflineplus">+    let validityConstraintSuffix;</span>
<a href="#l2.377"></a><span id="l2.377" class="difflineplus">+    if (nounDef.dbQueryValidityConstraintSuffix &amp;&amp;</span>
<a href="#l2.378"></a><span id="l2.378" class="difflineplus">+        !aQuery.options.noDbQueryValidityConstraints)</span>
<a href="#l2.379"></a><span id="l2.379" class="difflineplus">+      validityConstraintSuffix = nounDef.dbQueryValidityConstraintSuffix;</span>
<a href="#l2.380"></a><span id="l2.380" class="difflineplus">+    else</span>
<a href="#l2.381"></a><span id="l2.381" class="difflineplus">+      validityConstraintSuffix = &quot;&quot;;</span>
<a href="#l2.382"></a><span id="l2.382"> </span>
<a href="#l2.383"></a><span id="l2.383">     for (let iUnion = 0; iUnion &lt; unionQueries.length; iUnion++) {</span>
<a href="#l2.384"></a><span id="l2.384">       let curQuery = unionQueries[iUnion];</span>
<a href="#l2.385"></a><span id="l2.385">       let selects = [];</span>
<a href="#l2.386"></a><span id="l2.386"> </span>
<a href="#l2.387"></a><span id="l2.387">       let lastConstraintWasSpecial = false;</span>
<a href="#l2.388"></a><span id="l2.388">       let curConstraintIsSpecial;</span>
<a href="#l2.389"></a><span id="l2.389"> </span>
<a href="#l2.390"></a><span id="l2.390" class="difflineat">@@ -2907,18 +2874,24 @@ var GlodaDatastore = {</span>
<a href="#l2.391"></a><span id="l2.391">       }</span>
<a href="#l2.392"></a><span id="l2.392"> </span>
<a href="#l2.393"></a><span id="l2.393">       if (selects.length)</span>
<a href="#l2.394"></a><span id="l2.394">         whereClauses.push(&quot;id IN (&quot; + selects.join(&quot; INTERSECT &quot;) + &quot;)&quot; +</span>
<a href="#l2.395"></a><span id="l2.395">                           validityConstraintSuffix);</span>
<a href="#l2.396"></a><span id="l2.396">     }</span>
<a href="#l2.397"></a><span id="l2.397"> </span>
<a href="#l2.398"></a><span id="l2.398">     let sqlString = &quot;SELECT * FROM &quot; + nounDef.tableName;</span>
<a href="#l2.399"></a><span id="l2.399" class="difflineminus">-    if (nounDef.dbQueryJoinMagic &amp;&amp; !aQuery.options.noMagic)</span>
<a href="#l2.400"></a><span id="l2.400" class="difflineminus">-      sqlString += nounDef.dbQueryJoinMagic;</span>
<a href="#l2.401"></a><span id="l2.401" class="difflineplus">+    if (!aQuery.options.noMagic) {</span>
<a href="#l2.402"></a><span id="l2.402" class="difflineplus">+      if (aQuery.options.noDbQueryValidityConstraints &amp;&amp;</span>
<a href="#l2.403"></a><span id="l2.403" class="difflineplus">+          nounDef.dbQueryJoinMagicWithNoValidityConstraints)</span>
<a href="#l2.404"></a><span id="l2.404" class="difflineplus">+        sqlString += nounDef.dbQueryJoinMagicWithNoValidityConstraints;</span>
<a href="#l2.405"></a><span id="l2.405" class="difflineplus">+      else if (nounDef.dbQueryJoinMagic)</span>
<a href="#l2.406"></a><span id="l2.406" class="difflineplus">+        sqlString += nounDef.dbQueryJoinMagic;</span>
<a href="#l2.407"></a><span id="l2.407" class="difflineplus">+    }</span>
<a href="#l2.408"></a><span id="l2.408" class="difflineplus">+</span>
<a href="#l2.409"></a><span id="l2.409">     if (whereClauses.length)</span>
<a href="#l2.410"></a><span id="l2.410">       sqlString += &quot; WHERE (&quot; + whereClauses.join(&quot;) OR (&quot;) + &quot;)&quot;;</span>
<a href="#l2.411"></a><span id="l2.411"> </span>
<a href="#l2.412"></a><span id="l2.412">     if (aQuery.options.explicitSQL)</span>
<a href="#l2.413"></a><span id="l2.413">       sqlString = aQuery.options.explicitSQL;</span>
<a href="#l2.414"></a><span id="l2.414"> </span>
<a href="#l2.415"></a><span id="l2.415">     if (aQuery.options.outerWrapColumns)</span>
<a href="#l2.416"></a><span id="l2.416">       sqlString = &quot;SELECT *, &quot; + aQuery.options.outerWrapColumns.join(&quot;, &quot;) +</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/db/gloda/modules/fundattr.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/fundattr.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -44,17 +44,17 @@ const Cu = Components.utils;</span>
<a href="#l3.4"></a><span id="l3.4"> </span>
<a href="#l3.5"></a><span id="l3.5"> Cu.import(&quot;resource://app/modules/gloda/log4moz.js&quot;);</span>
<a href="#l3.6"></a><span id="l3.6"> </span>
<a href="#l3.7"></a><span id="l3.7"> Cu.import(&quot;resource://app/modules/gloda/utils.js&quot;);</span>
<a href="#l3.8"></a><span id="l3.8"> Cu.import(&quot;resource://app/modules/gloda/gloda.js&quot;);</span>
<a href="#l3.9"></a><span id="l3.9"> Cu.import(&quot;resource://app/modules/gloda/datastore.js&quot;);</span>
<a href="#l3.10"></a><span id="l3.10"> </span>
<a href="#l3.11"></a><span id="l3.11"> Cu.import(&quot;resource://app/modules/gloda/noun_mimetype.js&quot;);</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+Cu.import(&quot;resource://app/modules/gloda/connotent.js&quot;);</span>
<a href="#l3.14"></a><span id="l3.14"> </span>
<a href="#l3.15"></a><span id="l3.15"> /**</span>
<a href="#l3.16"></a><span id="l3.16">  * @namespace The Gloda Fundamental Attribute provider is a special attribute</span>
<a href="#l3.17"></a><span id="l3.17">  *  provider; it provides attributes that the rest of the providers should be</span>
<a href="#l3.18"></a><span id="l3.18">  *  able to assume exist.  Also, it may end up accessing things at a lower level</span>
<a href="#l3.19"></a><span id="l3.19">  *  than most extension providers should do.  In summary, don't mimic this code</span>
<a href="#l3.20"></a><span id="l3.20">  *  unless you won't complain when your code breaks.</span>
<a href="#l3.21"></a><span id="l3.21">  */</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineat">@@ -95,16 +95,17 @@ var GlodaFundAttr = {</span>
<a href="#l3.23"></a><span id="l3.23">   _attrBody: null,</span>
<a href="#l3.24"></a><span id="l3.24">   _attrFrom: null,</span>
<a href="#l3.25"></a><span id="l3.25">   _attrFromMe: null,</span>
<a href="#l3.26"></a><span id="l3.26">   _attrTo: null,</span>
<a href="#l3.27"></a><span id="l3.27">   _attrToMe: null,</span>
<a href="#l3.28"></a><span id="l3.28">   _attrCc: null,</span>
<a href="#l3.29"></a><span id="l3.29">   _attrCcMe: null,</span>
<a href="#l3.30"></a><span id="l3.30">   _attrDate: null,</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+  _attrHeaderMessageID: null,</span>
<a href="#l3.32"></a><span id="l3.32"> </span>
<a href="#l3.33"></a><span id="l3.33">   defineAttributes: function() {</span>
<a href="#l3.34"></a><span id="l3.34">     /* ***** Conversations ***** */</span>
<a href="#l3.35"></a><span id="l3.35">     // conversation: subjectMatches</span>
<a href="#l3.36"></a><span id="l3.36">     this._attrConvSubject = Gloda.defineAttribute({</span>
<a href="#l3.37"></a><span id="l3.37">       provider: this,</span>
<a href="#l3.38"></a><span id="l3.38">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l3.39"></a><span id="l3.39">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineat">@@ -281,16 +282,29 @@ var GlodaFundAttr = {</span>
<a href="#l3.41"></a><span id="l3.41">                         attributeName: &quot;date&quot;,</span>
<a href="#l3.42"></a><span id="l3.42">                         singular: true,</span>
<a href="#l3.43"></a><span id="l3.43">                         special: Gloda.kSpecialColumn,</span>
<a href="#l3.44"></a><span id="l3.44">                         specialColumnName: &quot;date&quot;,</span>
<a href="#l3.45"></a><span id="l3.45">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l3.46"></a><span id="l3.46">                         objectNoun: Gloda.NOUN_DATE,</span>
<a href="#l3.47"></a><span id="l3.47">                         }); // tested-by: test_attributes_fundamental</span>
<a href="#l3.48"></a><span id="l3.48"> </span>
<a href="#l3.49"></a><span id="l3.49" class="difflineplus">+    // Header message ID.</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineplus">+    this._attrHeaderMessageID = Gloda.defineAttribute({</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+                        provider: this,</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+                        extensionName: Gloda.BUILT_IN,</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+                        attributeType: Gloda.kAttrFundamental,</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+                        attributeName: &quot;headerMessageID&quot;,</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+                        singular: true,</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+                        special: Gloda.kSpecialColumn,</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+                        specialColumnName: &quot;headerMessageID&quot;,</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+                        subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+                        objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineplus">+                        }); // tested-by: test_attributes_fundamental</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineplus">+</span>
<a href="#l3.62"></a><span id="l3.62">     // Attachment MIME Types</span>
<a href="#l3.63"></a><span id="l3.63">     this._attrAttachmentTypes = Gloda.defineAttribute({</span>
<a href="#l3.64"></a><span id="l3.64">       provider: this,</span>
<a href="#l3.65"></a><span id="l3.65">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l3.66"></a><span id="l3.66">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l3.67"></a><span id="l3.67">       attributeName: &quot;attachmentTypes&quot;,</span>
<a href="#l3.68"></a><span id="l3.68">       singular: false,</span>
<a href="#l3.69"></a><span id="l3.69">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineat">@@ -427,29 +441,31 @@ var GlodaFundAttr = {</span>
<a href="#l3.71"></a><span id="l3.71">     let authorIdentity = authorIdentities[0];</span>
<a href="#l3.72"></a><span id="l3.72">     aGlodaMessage.from = authorIdentity;</span>
<a href="#l3.73"></a><span id="l3.73"> </span>
<a href="#l3.74"></a><span id="l3.74">     // -- To, Cc</span>
<a href="#l3.75"></a><span id="l3.75">     aGlodaMessage.to = toIdentities;</span>
<a href="#l3.76"></a><span id="l3.76">     aGlodaMessage.cc = ccIdentities;</span>
<a href="#l3.77"></a><span id="l3.77"> </span>
<a href="#l3.78"></a><span id="l3.78">     // -- Attachments</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineminus">-    let attachmentTypes = [];</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineminus">-    for each (let [, attachment] in Iterator(aMimeMsg.allAttachments)) {</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineminus">-      // We don't care about would-be attachments that are not user-intended</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineminus">-      //  attachments but rather artifacts of the message content.</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineminus">-      // We also want to avoid dealing with obviously bogus mime types.</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineminus">-      //  (If you don't have a &quot;/&quot;, you are probably bogus.)</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineminus">-      if (attachment.isRealAttachment &amp;&amp;</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineminus">-          (attachment.contentType.indexOf(&quot;/&quot;) != -1)) {</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineminus">-        attachmentTypes.push(MimeTypeNoun.getMimeType(attachment.contentType));</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineplus">+    if (aMimeMsg) {</span>
<a href="#l3.89"></a><span id="l3.89" class="difflineplus">+      let attachmentTypes = [];</span>
<a href="#l3.90"></a><span id="l3.90" class="difflineplus">+      for each (let [, attachment] in Iterator(aMimeMsg.allAttachments)) {</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+        // We don't care about would-be attachments that are not user-intended</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineplus">+        //  attachments but rather artifacts of the message content.</span>
<a href="#l3.93"></a><span id="l3.93" class="difflineplus">+        // We also want to avoid dealing with obviously bogus mime types.</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineplus">+        //  (If you don't have a &quot;/&quot;, you are probably bogus.)</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineplus">+        if (attachment.isRealAttachment &amp;&amp;</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineplus">+            (attachment.contentType.indexOf(&quot;/&quot;) != -1)) {</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineplus">+          attachmentTypes.push(MimeTypeNoun.getMimeType(attachment.contentType));</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineplus">+        }</span>
<a href="#l3.99"></a><span id="l3.99">       }</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineminus">-    }</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineminus">-    if (attachmentTypes.length) {</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineminus">-      aGlodaMessage.attachmentTypes = attachmentTypes;</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineplus">+      if (attachmentTypes.length) {</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineplus">+        aGlodaMessage.attachmentTypes = attachmentTypes;</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineplus">+      }</span>
<a href="#l3.106"></a><span id="l3.106">     }</span>
<a href="#l3.107"></a><span id="l3.107"> </span>
<a href="#l3.108"></a><span id="l3.108">     // TODO: deal with mailing lists, including implicit-to.  this will require</span>
<a href="#l3.109"></a><span id="l3.109">     //  convincing the indexer to pass us in the previous message if it is</span>
<a href="#l3.110"></a><span id="l3.110">     //  available.  (which we'll simply pass to everyone... it can help body</span>
<a href="#l3.111"></a><span id="l3.111">     //  logic for quoting purposes, etc. too.)</span>
<a href="#l3.112"></a><span id="l3.112"> </span>
<a href="#l3.113"></a><span id="l3.113">     yield Gloda.kWorkDone;</span>
<a href="#l3.114"></a><span id="l3.114" class="difflineat">@@ -560,19 +576,22 @@ var GlodaFundAttr = {</span>
<a href="#l3.115"></a><span id="l3.115">     }</span>
<a href="#l3.116"></a><span id="l3.116">     if (fromMeTo.length)</span>
<a href="#l3.117"></a><span id="l3.117">       aGlodaMessage.fromMeTo = fromMeTo;</span>
<a href="#l3.118"></a><span id="l3.118">     if (ccMe.length)</span>
<a href="#l3.119"></a><span id="l3.119">       aGlodaMessage.ccMe = ccMe;</span>
<a href="#l3.120"></a><span id="l3.120">     if (fromMeCc.length)</span>
<a href="#l3.121"></a><span id="l3.121">       aGlodaMessage.fromMeCc = fromMeCc;</span>
<a href="#l3.122"></a><span id="l3.122"> </span>
<a href="#l3.123"></a><span id="l3.123" class="difflineminus">-    if (aRawReps.bodyLines &amp;&amp;</span>
<a href="#l3.124"></a><span id="l3.124" class="difflineminus">-        this.contentWhittle({}, aRawReps.bodyLines, aRawReps.content)) {</span>
<a href="#l3.125"></a><span id="l3.125" class="difflineminus">-      // we were going to do something here?</span>
<a href="#l3.126"></a><span id="l3.126" class="difflineplus">+    // Content</span>
<a href="#l3.127"></a><span id="l3.127" class="difflineplus">+    if (aRawReps.bodyLines) {</span>
<a href="#l3.128"></a><span id="l3.128" class="difflineplus">+      aGlodaMessage._content = new GlodaContent();</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineplus">+      if (this.contentWhittle({}, aRawReps.bodyLines, aGlodaMessage._content)) {</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineplus">+        // we were going to do something here?</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineplus">+      }</span>
<a href="#l3.132"></a><span id="l3.132">     }</span>
<a href="#l3.133"></a><span id="l3.133"> </span>
<a href="#l3.134"></a><span id="l3.134">     yield Gloda.kWorkDone;</span>
<a href="#l3.135"></a><span id="l3.135">   },</span>
<a href="#l3.136"></a><span id="l3.136"> </span>
<a href="#l3.137"></a><span id="l3.137">   /**</span>
<a href="#l3.138"></a><span id="l3.138">    * Duplicates the notability logic from optimize().  Arguably optimize should</span>
<a href="#l3.139"></a><span id="l3.139">    *  be factored to call us, grokNounItem should be factored to call us, or we</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/db/gloda/modules/gloda.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/gloda.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -49,16 +49,59 @@ Cu.import(&quot;resource://app/modules/gloda/</span>
<a href="#l4.4"></a><span id="l4.4"> Cu.import(&quot;resource://app/modules/gloda/databind.js&quot;);</span>
<a href="#l4.5"></a><span id="l4.5"> Cu.import(&quot;resource://app/modules/gloda/collection.js&quot;);</span>
<a href="#l4.6"></a><span id="l4.6"> Cu.import(&quot;resource://app/modules/gloda/connotent.js&quot;);</span>
<a href="#l4.7"></a><span id="l4.7"> Cu.import(&quot;resource://app/modules/gloda/query.js&quot;);</span>
<a href="#l4.8"></a><span id="l4.8"> Cu.import(&quot;resource://app/modules/gloda/utils.js&quot;);</span>
<a href="#l4.9"></a><span id="l4.9"> </span>
<a href="#l4.10"></a><span id="l4.10"> Cu.import(&quot;resource://app/modules/iteratorUtils.jsm&quot;);</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+let MBM_LOG = Log4Moz.repository.getLogger(&quot;gloda.NS.mbm&quot;);</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+/**</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineplus">+ * @class This callback handles processing the asynchronous query results of</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineplus">+ *  Gloda.getMessagesByMessageID.</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineplus">+ *</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineplus">+ * @param aMsgIDToIndex Map from message-id to the desired</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineplus">+ *</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineplus">+ * @constructor</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineplus">+ */</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineplus">+function MessagesByMessageIdCallback(aMsgIDToIndex, aResults,</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineplus">+                                     aCallback, aCallbackThis) {</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineplus">+  this.msgIDToIndex = aMsgIDToIndex;</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineplus">+  this.results = aResults;</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineplus">+  this.callback = aCallback;</span>
<a href="#l4.27"></a><span id="l4.27" class="difflineplus">+  this.callbackThis = aCallbackThis;</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineplus">+}</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineplus">+</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineplus">+MessagesByMessageIdCallback.prototype = {</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+  onItemsAdded: function gloda_ds_mbmi_onItemsAdded(aItems, aCollection) {</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+    // just outright bail if we are shutdown</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+    if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+      return;</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+    MBM_LOG.debug(&quot;getting results...&quot;);</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+    for each (let [, message] in Iterator(aItems)) {</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+      this.results[this.msgIDToIndex[message.headerMessageID]].push(message);</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineplus">+    }</span>
<a href="#l4.40"></a><span id="l4.40" class="difflineplus">+  },</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineplus">+  onItemsModified: function () {},</span>
<a href="#l4.42"></a><span id="l4.42" class="difflineplus">+  onItemsRemoved: function () {},</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineplus">+  onQueryCompleted: function gloda_ds_mbmi_onQueryCompleted(aCollection) {</span>
<a href="#l4.44"></a><span id="l4.44" class="difflineplus">+    // just outright bail if we are shutdown</span>
<a href="#l4.45"></a><span id="l4.45" class="difflineplus">+    if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineplus">+      return;</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineplus">+</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineplus">+    MBM_LOG.debug(&quot;query completed, notifying... &quot; + this.results);</span>
<a href="#l4.49"></a><span id="l4.49" class="difflineplus">+    // we no longer need to unify; it is done for us.</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineplus">+</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineplus">+    this.callback.call(this.callbackThis, this.results);</span>
<a href="#l4.52"></a><span id="l4.52" class="difflineplus">+  }</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineplus">+};</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineplus">+</span>
<a href="#l4.55"></a><span id="l4.55"> /**</span>
<a href="#l4.56"></a><span id="l4.56">  * Provides the user-visible (and extension visible) global database</span>
<a href="#l4.57"></a><span id="l4.57">  *  functionality.  There is currently a dependency/ordering</span>
<a href="#l4.58"></a><span id="l4.58">  *  problem in that the concept of 'gloda' also includes some logic that is</span>
<a href="#l4.59"></a><span id="l4.59">  *  contributed by built-in extensions, if you will.  Those built-in extensions</span>
<a href="#l4.60"></a><span id="l4.60">  *  (fundattr.js, explattr.js) also import this file.  To avoid a circular</span>
<a href="#l4.61"></a><span id="l4.61">  *  dependency, those built-in extensions are loaded by everybody.js.  The</span>
<a href="#l4.62"></a><span id="l4.62">  *  simplest/best solution is probably to move everybody.js to be gloda.js and</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineat">@@ -322,16 +365,55 @@ var Gloda = {</span>
<a href="#l4.64"></a><span id="l4.64">       let messageKeys = [hdr.messageKey for each (hdr in headersForFolder)];</span>
<a href="#l4.65"></a><span id="l4.65">       clause.messageKey.apply(clause, messageKeys);</span>
<a href="#l4.66"></a><span id="l4.66">     }</span>
<a href="#l4.67"></a><span id="l4.67"> </span>
<a href="#l4.68"></a><span id="l4.68">     return query.getCollection(aListener, aData);</span>
<a href="#l4.69"></a><span id="l4.69">   },</span>
<a href="#l4.70"></a><span id="l4.70"> </span>
<a href="#l4.71"></a><span id="l4.71">   /**</span>
<a href="#l4.72"></a><span id="l4.72" class="difflineplus">+   * Given a list of Message-ID's, return a matching list of lists of messages</span>
<a href="#l4.73"></a><span id="l4.73" class="difflineplus">+   *  matching those Message-ID's.  So if you pass an array with three</span>
<a href="#l4.74"></a><span id="l4.74" class="difflineplus">+   *  Message-ID's [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], you would get back an array containing</span>
<a href="#l4.75"></a><span id="l4.75" class="difflineplus">+   *  3 lists, where the first list contains all the messages with a message-id</span>
<a href="#l4.76"></a><span id="l4.76" class="difflineplus">+   *  of &quot;a&quot;, and so forth.  The reason a list is returned rather than null/a</span>
<a href="#l4.77"></a><span id="l4.77" class="difflineplus">+   *  message is that we accept the reality that we have multiple copies of</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineplus">+   *  messages with the same ID.</span>
<a href="#l4.79"></a><span id="l4.79" class="difflineplus">+   * This call is asynchronous because it depends on previously created messages</span>
<a href="#l4.80"></a><span id="l4.80" class="difflineplus">+   *  to be reflected in our results, which requires us to execute on the async</span>
<a href="#l4.81"></a><span id="l4.81" class="difflineplus">+   *  thread where all our writes happen.  This also turns out to be a</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineplus">+   *  reasonable thing because we could imagine pathological cases where there</span>
<a href="#l4.83"></a><span id="l4.83" class="difflineplus">+   *  could be a lot of message-id's and/or a lot of messages with those</span>
<a href="#l4.84"></a><span id="l4.84" class="difflineplus">+   *  message-id's.</span>
<a href="#l4.85"></a><span id="l4.85" class="difflineplus">+   */</span>
<a href="#l4.86"></a><span id="l4.86" class="difflineplus">+  getMessagesByMessageID: function gloda_ns_getMessagesByMessageID(aMessageIDs,</span>
<a href="#l4.87"></a><span id="l4.87" class="difflineplus">+      aCallback, aCallbackThis) {</span>
<a href="#l4.88"></a><span id="l4.88" class="difflineplus">+    let msgIDToIndex = {};</span>
<a href="#l4.89"></a><span id="l4.89" class="difflineplus">+    let results = [];</span>
<a href="#l4.90"></a><span id="l4.90" class="difflineplus">+    for (let iID = 0; iID &lt; aMessageIDs.length; ++iID) {</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineplus">+      let msgID = aMessageIDs[iID];</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineplus">+      results.push([]);</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineplus">+      msgIDToIndex[msgID] = iID;</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineplus">+    }</span>
<a href="#l4.95"></a><span id="l4.95" class="difflineplus">+</span>
<a href="#l4.96"></a><span id="l4.96" class="difflineplus">+    let quotedIDs = [&quot;'&quot; + msgID.replace(&quot;'&quot;, &quot;''&quot;, &quot;g&quot;) + &quot;'&quot; for each</span>
<a href="#l4.97"></a><span id="l4.97" class="difflineplus">+                      ([i, msgID] in Iterator(aMessageIDs))];</span>
<a href="#l4.98"></a><span id="l4.98" class="difflineplus">+</span>
<a href="#l4.99"></a><span id="l4.99" class="difflineplus">+    let query = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l4.100"></a><span id="l4.100" class="difflineplus">+      noDbQueryValidityConstraints: true,</span>
<a href="#l4.101"></a><span id="l4.101" class="difflineplus">+    });</span>
<a href="#l4.102"></a><span id="l4.102" class="difflineplus">+    query.headerMessageID.apply(query, quotedIDs);</span>
<a href="#l4.103"></a><span id="l4.103" class="difflineplus">+    query.frozen = true;</span>
<a href="#l4.104"></a><span id="l4.104" class="difflineplus">+</span>
<a href="#l4.105"></a><span id="l4.105" class="difflineplus">+    let listener = new MessagesByMessageIdCallback(msgIDToIndex, results,</span>
<a href="#l4.106"></a><span id="l4.106" class="difflineplus">+                                                   aCallback, aCallbackThis);</span>
<a href="#l4.107"></a><span id="l4.107" class="difflineplus">+    return query.getCollection(listener);</span>
<a href="#l4.108"></a><span id="l4.108" class="difflineplus">+  },</span>
<a href="#l4.109"></a><span id="l4.109" class="difflineplus">+</span>
<a href="#l4.110"></a><span id="l4.110" class="difflineplus">+  /**</span>
<a href="#l4.111"></a><span id="l4.111">    * @testpoint gloda.ns.getMessageContent</span>
<a href="#l4.112"></a><span id="l4.112">    */</span>
<a href="#l4.113"></a><span id="l4.113">   getMessageContent: function gloda_ns_getMessageContent(aGlodaMessage, aMimeMsg) {</span>
<a href="#l4.114"></a><span id="l4.114">     return mimeMsgToContentAndMeta(aMimeMsg, aGlodaMessage.folderMessage.folder)[0];</span>
<a href="#l4.115"></a><span id="l4.115">   },</span>
<a href="#l4.116"></a><span id="l4.116"> </span>
<a href="#l4.117"></a><span id="l4.117">   getFolderForFolder: function gloda_ns_getFolderForFolder(aMsgFolder) {</span>
<a href="#l4.118"></a><span id="l4.118">     return GlodaDatastore._mapFolder(aMsgFolder);</span>
<a href="#l4.119"></a><span id="l4.119" class="difflineat">@@ -1072,16 +1154,20 @@ var Gloda = {</span>
<a href="#l4.120"></a><span id="l4.120">       //  have the body available.  this is because we want the subject indexed.</span>
<a href="#l4.121"></a><span id="l4.121">       dbQueryJoinMagic:</span>
<a href="#l4.122"></a><span id="l4.122">         &quot; INNER JOIN messagesText ON messages.id = messagesText.rowid&quot;,</span>
<a href="#l4.123"></a><span id="l4.123">       attrTableName: &quot;messageAttributes&quot;, attrIDColumnName: &quot;messageID&quot;,</span>
<a href="#l4.124"></a><span id="l4.124">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._messageFromRow,</span>
<a href="#l4.125"></a><span id="l4.125">       dbAttribAdjuster: GlodaDatastore.adjustMessageAttributes,</span>
<a href="#l4.126"></a><span id="l4.126">       dbQueryValidityConstraintSuffix:</span>
<a href="#l4.127"></a><span id="l4.127">         &quot; AND +deleted = 0 AND +folderID IS NOT NULL AND +messageKey IS NOT NULL&quot;,</span>
<a href="#l4.128"></a><span id="l4.128" class="difflineplus">+      // This is what's used when we have no validity constraints, i.e. we allow</span>
<a href="#l4.129"></a><span id="l4.129" class="difflineplus">+      // for ghost messages, which do not have a row in the messagesText table.</span>
<a href="#l4.130"></a><span id="l4.130" class="difflineplus">+      dbQueryJoinMagicWithNoValidityConstraints:</span>
<a href="#l4.131"></a><span id="l4.131" class="difflineplus">+        &quot; LEFT JOIN messagesText ON messages.id = messagesText.rowid&quot;,</span>
<a href="#l4.132"></a><span id="l4.132">       objInsert: GlodaDatastore.insertMessage,</span>
<a href="#l4.133"></a><span id="l4.133">       objUpdate: GlodaDatastore.updateMessage,</span>
<a href="#l4.134"></a><span id="l4.134">       toParamAndValue: function(aMessage) {</span>
<a href="#l4.135"></a><span id="l4.135">         if (aMessage instanceof GlodaMessage)</span>
<a href="#l4.136"></a><span id="l4.136">           return [null, aMessage.id];</span>
<a href="#l4.137"></a><span id="l4.137">         else // assume they're just passing the id directly</span>
<a href="#l4.138"></a><span id="l4.138">           return [null, aMessage];</span>
<a href="#l4.139"></a><span id="l4.139">       }}, this.NOUN_MESSAGE);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -16,16 +16,17 @@</span>
<a href="#l5.4"></a><span id="l5.4">  * The Initial Developer of the Original Code is</span>
<a href="#l5.5"></a><span id="l5.5">  * Mozilla Messaging, Inc.</span>
<a href="#l5.6"></a><span id="l5.6">  * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l5.7"></a><span id="l5.7">  * the Initial Developer. All Rights Reserved.</span>
<a href="#l5.8"></a><span id="l5.8">  *</span>
<a href="#l5.9"></a><span id="l5.9">  * Contributor(s):</span>
<a href="#l5.10"></a><span id="l5.10">  *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l5.11"></a><span id="l5.11">  *   Kent James &lt;kent@caspia.com&gt;</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+ *   Siddharth Agarwal &lt;sid.bugzilla@gmail.com&gt;</span>
<a href="#l5.13"></a><span id="l5.13">  *</span>
<a href="#l5.14"></a><span id="l5.14">  * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l5.15"></a><span id="l5.15">  * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l5.16"></a><span id="l5.16">  * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l5.17"></a><span id="l5.17">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l5.18"></a><span id="l5.18">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l5.19"></a><span id="l5.19">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l5.20"></a><span id="l5.20">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineat">@@ -238,17 +239,18 @@ IndexingJob.prototype = {</span>
<a href="#l5.22"></a><span id="l5.22">  *   header that indicates the message is dirty.</span>
<a href="#l5.23"></a><span id="l5.23">  * - We store a property on folders that indicate that the folder's index is</span>
<a href="#l5.24"></a><span id="l5.24">  *   up-to-date.  Absence of this property is akin to a 0=folder not up to date.</span>
<a href="#l5.25"></a><span id="l5.25">  *   There is no particular reason for the choice of using the folder's</span>
<a href="#l5.26"></a><span id="l5.26">  *   properties (via the folder cache implementation) over gloda's own folder</span>
<a href="#l5.27"></a><span id="l5.27">  *   meta-data.</span>
<a href="#l5.28"></a><span id="l5.28">  *</span>
<a href="#l5.29"></a><span id="l5.29">  * Indexing Message Control</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineminus">- * - We index IMAP messages that are offline.  We index all local messages.</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineplus">+ * - We index the headers of all IMAP messages. We index the bodies of all IMAP</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+ *   messages that are offline.  We index all local messages.</span>
<a href="#l5.33"></a><span id="l5.33">  *   We plan to avoid indexing news messages.</span>
<a href="#l5.34"></a><span id="l5.34">  * - We would like a way to express desires about indexing that either don't</span>
<a href="#l5.35"></a><span id="l5.35">  *   confound offline storage with indexing, or actually allow some choice.</span>
<a href="#l5.36"></a><span id="l5.36">  *</span>
<a href="#l5.37"></a><span id="l5.37">  * Indexing</span>
<a href="#l5.38"></a><span id="l5.38">  * - We process one folder at a time, walking the headers in the folder,</span>
<a href="#l5.39"></a><span id="l5.39">  *   indexing those which should be indexed, but which have never been indexed</span>
<a href="#l5.40"></a><span id="l5.40">  *   or are dirty.</span>
<a href="#l5.41"></a><span id="l5.41" class="difflineat">@@ -1056,18 +1058,18 @@ var GlodaIndexer = {</span>
<a href="#l5.42"></a><span id="l5.42"> </span>
<a href="#l5.43"></a><span id="l5.43">     else {</span>
<a href="#l5.44"></a><span id="l5.44">       // We need to create search terms for messages to index. Messages should</span>
<a href="#l5.45"></a><span id="l5.45">       //  be indexed if they're indexable (local or offline and not expunged)</span>
<a href="#l5.46"></a><span id="l5.46">       //  and either haven't been indexed or are dirty.</span>
<a href="#l5.47"></a><span id="l5.47">       // The basic search expression is:</span>
<a href="#l5.48"></a><span id="l5.48">       //  ((GLODA_MESSAGE_ID_PROPERTY Is 0) || (GLODA_DIRTY_PROPERTY Isnt 0))</span>
<a href="#l5.49"></a><span id="l5.49">       // If the folder !isLocal we add the terms:</span>
<a href="#l5.50"></a><span id="l5.50" class="difflineminus">-      //  &amp;&amp; (Status Is nsMsgMessageFlags.Offline)</span>
<a href="#l5.51"></a><span id="l5.51" class="difflineminus">-      //  &amp;&amp; (Status Isnt nsMsgMessageFlags.Expunged)</span>
<a href="#l5.52"></a><span id="l5.52" class="difflineplus">+      //  - if the folder is offline -- &amp;&amp; (Status Is nsMsgMessageFlags.Offline)</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineplus">+      //  - &amp;&amp; (Status Isnt nsMsgMessageFlags.Expunged)</span>
<a href="#l5.54"></a><span id="l5.54"> </span>
<a href="#l5.55"></a><span id="l5.55">       let searchSession = Cc[&quot;@mozilla.org/messenger/searchSession;1&quot;]</span>
<a href="#l5.56"></a><span id="l5.56">                             .createInstance(Ci.nsIMsgSearchSession);</span>
<a href="#l5.57"></a><span id="l5.57">       let searchTerms = Cc[&quot;@mozilla.org/array;1&quot;]</span>
<a href="#l5.58"></a><span id="l5.58">                          .createInstance(Ci.nsIMutableArray);</span>
<a href="#l5.59"></a><span id="l5.59">       let isLocal = this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l5.60"></a><span id="l5.60"> </span>
<a href="#l5.61"></a><span id="l5.61">       searchSession.addScopeTerm(Ci.nsMsgSearchScope.offlineMail,</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineat">@@ -1076,17 +1078,17 @@ var GlodaIndexer = {</span>
<a href="#l5.63"></a><span id="l5.63">       let nsMsgSearchOp = Ci.nsMsgSearchOp;</span>
<a href="#l5.64"></a><span id="l5.64"> </span>
<a href="#l5.65"></a><span id="l5.65">       // first term: (GLODA_MESSAGE_ID_PROPERTY Is 0</span>
<a href="#l5.66"></a><span id="l5.66">       let searchTerm = searchSession.createTerm();</span>
<a href="#l5.67"></a><span id="l5.67">       searchTerm.booleanAnd = false; // actually don't care here</span>
<a href="#l5.68"></a><span id="l5.68">       searchTerm.beginsGrouping = true;</span>
<a href="#l5.69"></a><span id="l5.69">       searchTerm.attrib = nsMsgSearchAttrib.Uint32HdrProperty;</span>
<a href="#l5.70"></a><span id="l5.70">       searchTerm.op = nsMsgSearchOp.Is;</span>
<a href="#l5.71"></a><span id="l5.71" class="difflineminus">-      value = searchTerm.value;</span>
<a href="#l5.72"></a><span id="l5.72" class="difflineplus">+      let value = searchTerm.value;</span>
<a href="#l5.73"></a><span id="l5.73">       value.attrib = searchTerm.attrib;</span>
<a href="#l5.74"></a><span id="l5.74">       value.status = 0;</span>
<a href="#l5.75"></a><span id="l5.75">       searchTerm.value = value;</span>
<a href="#l5.76"></a><span id="l5.76">       searchTerm.hdrProperty = GLODA_MESSAGE_ID_PROPERTY;</span>
<a href="#l5.77"></a><span id="l5.77">       searchTerms.appendElement(searchTerm, false);</span>
<a href="#l5.78"></a><span id="l5.78"> </span>
<a href="#l5.79"></a><span id="l5.79">       //  second term: || GLODA_DIRTY_PROPERTY Isnt 0 )</span>
<a href="#l5.80"></a><span id="l5.80">       searchTerm = searchSession.createTerm();</span>
<a href="#l5.81"></a><span id="l5.81" class="difflineat">@@ -1098,26 +1100,29 @@ var GlodaIndexer = {</span>
<a href="#l5.82"></a><span id="l5.82">       value.attrib = searchTerm.attrib;</span>
<a href="#l5.83"></a><span id="l5.83">       value.status = 0;</span>
<a href="#l5.84"></a><span id="l5.84">       searchTerm.value = value;</span>
<a href="#l5.85"></a><span id="l5.85">       searchTerm.hdrProperty = GLODA_DIRTY_PROPERTY;</span>
<a href="#l5.86"></a><span id="l5.86">       searchTerms.appendElement(searchTerm, false);</span>
<a href="#l5.87"></a><span id="l5.87"> </span>
<a href="#l5.88"></a><span id="l5.88">       if (!isLocal)</span>
<a href="#l5.89"></a><span id="l5.89">       {</span>
<a href="#l5.90"></a><span id="l5.90" class="difflineminus">-        //  third term: &amp;&amp; Status Is nsMsgMessageFlags.Offline</span>
<a href="#l5.91"></a><span id="l5.91" class="difflineminus">-        searchTerm = searchSession.createTerm();</span>
<a href="#l5.92"></a><span id="l5.92" class="difflineminus">-        searchTerm.booleanAnd = true;</span>
<a href="#l5.93"></a><span id="l5.93" class="difflineminus">-        searchTerm.attrib = nsMsgSearchAttrib.MsgStatus;</span>
<a href="#l5.94"></a><span id="l5.94" class="difflineminus">-        searchTerm.op = nsMsgSearchOp.Is;</span>
<a href="#l5.95"></a><span id="l5.95" class="difflineminus">-        value = searchTerm.value;</span>
<a href="#l5.96"></a><span id="l5.96" class="difflineminus">-        value.attrib = searchTerm.attrib;</span>
<a href="#l5.97"></a><span id="l5.97" class="difflineminus">-        value.status = Ci.nsMsgMessageFlags.Offline;</span>
<a href="#l5.98"></a><span id="l5.98" class="difflineminus">-        searchTerm.value = value;</span>
<a href="#l5.99"></a><span id="l5.99" class="difflineminus">-        searchTerms.appendElement(searchTerm, false);</span>
<a href="#l5.100"></a><span id="l5.100" class="difflineplus">+        // If the folder is offline, then the message should be too</span>
<a href="#l5.101"></a><span id="l5.101" class="difflineplus">+        if (this._indexingFolder.flags &amp; Ci.nsMsgFolderFlags.Offline) {</span>
<a href="#l5.102"></a><span id="l5.102" class="difflineplus">+          // third term: &amp;&amp; Status Is nsMsgMessageFlags.Offline</span>
<a href="#l5.103"></a><span id="l5.103" class="difflineplus">+          searchTerm = searchSession.createTerm();</span>
<a href="#l5.104"></a><span id="l5.104" class="difflineplus">+          searchTerm.booleanAnd = true;</span>
<a href="#l5.105"></a><span id="l5.105" class="difflineplus">+          searchTerm.attrib = nsMsgSearchAttrib.MsgStatus;</span>
<a href="#l5.106"></a><span id="l5.106" class="difflineplus">+          searchTerm.op = nsMsgSearchOp.Is;</span>
<a href="#l5.107"></a><span id="l5.107" class="difflineplus">+          value = searchTerm.value;</span>
<a href="#l5.108"></a><span id="l5.108" class="difflineplus">+          value.attrib = searchTerm.attrib;</span>
<a href="#l5.109"></a><span id="l5.109" class="difflineplus">+          value.status = Ci.nsMsgMessageFlags.Offline;</span>
<a href="#l5.110"></a><span id="l5.110" class="difflineplus">+          searchTerm.value = value;</span>
<a href="#l5.111"></a><span id="l5.111" class="difflineplus">+          searchTerms.appendElement(searchTerm, false);</span>
<a href="#l5.112"></a><span id="l5.112" class="difflineplus">+        }</span>
<a href="#l5.113"></a><span id="l5.113"> </span>
<a href="#l5.114"></a><span id="l5.114">         // fourth term: &amp;&amp; Status Isnt nsMsgMessageFlags.Expunged</span>
<a href="#l5.115"></a><span id="l5.115">         searchTerm = searchSession.createTerm();</span>
<a href="#l5.116"></a><span id="l5.116">         searchTerm.booleanAnd = true;</span>
<a href="#l5.117"></a><span id="l5.117">         searchTerm.attrib = nsMsgSearchAttrib.MsgStatus;</span>
<a href="#l5.118"></a><span id="l5.118">         searchTerm.op = nsMsgSearchOp.Isnt;</span>
<a href="#l5.119"></a><span id="l5.119">         value = searchTerm.value;</span>
<a href="#l5.120"></a><span id="l5.120">         value.attrib = searchTerm.attrib;</span>
<a href="#l5.121"></a><span id="l5.121" class="difflineat">@@ -1647,20 +1652,20 @@ var GlodaIndexer = {</span>
<a href="#l5.122"></a><span id="l5.122">           createInstance(Ci.nsISupportsArray);</span>
<a href="#l5.123"></a><span id="l5.123">         rootFolder.ListDescendents(allFolders);</span>
<a href="#l5.124"></a><span id="l5.124">         let numFolders = allFolders.Count();</span>
<a href="#l5.125"></a><span id="l5.125">         for (let folderIndex = 0; folderIndex &lt; numFolders; folderIndex++) {</span>
<a href="#l5.126"></a><span id="l5.126">           let folder = allFolders.GetElementAt(folderIndex).QueryInterface(</span>
<a href="#l5.127"></a><span id="l5.127">             Ci.nsIMsgFolder);</span>
<a href="#l5.128"></a><span id="l5.128">           if (!this.shouldIndexFolder(folder))</span>
<a href="#l5.129"></a><span id="l5.129">             continue;</span>
<a href="#l5.130"></a><span id="l5.130" class="difflineminus">-          // we could also check nsMsgFolderFlags.Mail conceivably...</span>
<a href="#l5.131"></a><span id="l5.131" class="difflineminus">-          let isLocal = folder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l5.132"></a><span id="l5.132" class="difflineminus">-          // we only index local folders or IMAP folders that are marked offline</span>
<a href="#l5.133"></a><span id="l5.133" class="difflineminus">-          if (!isLocal &amp;&amp; !(folder.flags &amp; Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l5.134"></a><span id="l5.134" class="difflineplus">+</span>
<a href="#l5.135"></a><span id="l5.135" class="difflineplus">+          // we only index local or IMAP folders</span>
<a href="#l5.136"></a><span id="l5.136" class="difflineplus">+          if (!(folder instanceof Ci.nsIMsgLocalMailFolder) &amp;&amp;</span>
<a href="#l5.137"></a><span id="l5.137" class="difflineplus">+              !(folder instanceof Ci.nsIMsgImapMailFolder))</span>
<a href="#l5.138"></a><span id="l5.138">             continue;</span>
<a href="#l5.139"></a><span id="l5.139"> </span>
<a href="#l5.140"></a><span id="l5.140">           let glodaFolder = Gloda.getFolderForFolder(folder);</span>
<a href="#l5.141"></a><span id="l5.141">           if (glodaFolder.indexingPriority !=</span>
<a href="#l5.142"></a><span id="l5.142">               glodaFolder.kIndexingNeverPriority)</span>
<a href="#l5.143"></a><span id="l5.143">             foldersToProcess.push(glodaFolder);</span>
<a href="#l5.144"></a><span id="l5.144">         }</span>
<a href="#l5.145"></a><span id="l5.145">       }</span>
<a href="#l5.146"></a><span id="l5.146" class="difflineat">@@ -1729,17 +1734,16 @@ var GlodaIndexer = {</span>
<a href="#l5.147"></a><span id="l5.147"> </span>
<a href="#l5.148"></a><span id="l5.148">     // Make sure listeners get notified about this job.</span>
<a href="#l5.149"></a><span id="l5.149">     this._notifyListeners();</span>
<a href="#l5.150"></a><span id="l5.150"> </span>
<a href="#l5.151"></a><span id="l5.151">     // there is of course a cost to all this header investigation even if we</span>
<a href="#l5.152"></a><span id="l5.152">     //  don't do something.  so we will yield with kWorkSync for every block.</span>
<a href="#l5.153"></a><span id="l5.153">     const HEADER_CHECK_BLOCK_SIZE = 25;</span>
<a href="#l5.154"></a><span id="l5.154"> </span>
<a href="#l5.155"></a><span id="l5.155" class="difflineminus">-    let isLocal = this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l5.156"></a><span id="l5.156">     // we can safely presume if we are here that this folder has been selected</span>
<a href="#l5.157"></a><span id="l5.157">     //  for offline processing...</span>
<a href="#l5.158"></a><span id="l5.158"> </span>
<a href="#l5.159"></a><span id="l5.159">     // Handle the filthy case.  A filthy folder may have misleading properties</span>
<a href="#l5.160"></a><span id="l5.160">     //  on the message that claim the message is indexed.  They are misleading</span>
<a href="#l5.161"></a><span id="l5.161">     //  because the database, for whatever reason, does not have the messages</span>
<a href="#l5.162"></a><span id="l5.162">     //  (accurately) indexed.</span>
<a href="#l5.163"></a><span id="l5.163">     // We need to walk all the messages and mark them filthy if they have a</span>
<a href="#l5.164"></a><span id="l5.164" class="difflineat">@@ -1830,50 +1834,42 @@ var GlodaIndexer = {</span>
<a href="#l5.165"></a><span id="l5.165">   /**</span>
<a href="#l5.166"></a><span id="l5.166">    * Index a specific list of messages that we know to index from</span>
<a href="#l5.167"></a><span id="l5.167">    *  event-notification hints.</span>
<a href="#l5.168"></a><span id="l5.168">    */</span>
<a href="#l5.169"></a><span id="l5.169">   _worker_messageIndex: function gloda_worker_messageAdd(aJob) {</span>
<a href="#l5.170"></a><span id="l5.170">     // if we are already in the correct folder, our &quot;get in the folder&quot; clause</span>
<a href="#l5.171"></a><span id="l5.171">     //  will not execute, so we need to make sure this value is accurate in</span>
<a href="#l5.172"></a><span id="l5.172">     //  that case.  (and we want to avoid multiple checks...)</span>
<a href="#l5.173"></a><span id="l5.173" class="difflineminus">-    let folderIsLocal =</span>
<a href="#l5.174"></a><span id="l5.174" class="difflineminus">-      this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l5.175"></a><span id="l5.175">     for (; aJob.offset &lt; aJob.items.length; aJob.offset++) {</span>
<a href="#l5.176"></a><span id="l5.176">       let item = aJob.items[aJob.offset];</span>
<a href="#l5.177"></a><span id="l5.177">       // item is either [folder ID, message key] or</span>
<a href="#l5.178"></a><span id="l5.178">       //                [folder ID, message ID]</span>
<a href="#l5.179"></a><span id="l5.179"> </span>
<a href="#l5.180"></a><span id="l5.180">       // get in the folder</span>
<a href="#l5.181"></a><span id="l5.181">       if (!this._indexingGlodaFolder ||</span>
<a href="#l5.182"></a><span id="l5.182">           this._indexingGlodaFolder.id != item[0]) {</span>
<a href="#l5.183"></a><span id="l5.183">         yield this._indexerEnterFolder(item[0]);</span>
<a href="#l5.184"></a><span id="l5.184"> </span>
<a href="#l5.185"></a><span id="l5.185">         // stay out of folders we should not be in!</span>
<a href="#l5.186"></a><span id="l5.186">         if (!this.shouldIndexFolder(this._indexingFolder))</span>
<a href="#l5.187"></a><span id="l5.187">           continue;</span>
<a href="#l5.188"></a><span id="l5.188" class="difflineminus">-</span>
<a href="#l5.189"></a><span id="l5.189" class="difflineminus">-        folderIsLocal =</span>
<a href="#l5.190"></a><span id="l5.190" class="difflineminus">-          this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l5.191"></a><span id="l5.191">       }</span>
<a href="#l5.192"></a><span id="l5.192"> </span>
<a href="#l5.193"></a><span id="l5.193">       let msgHdr;</span>
<a href="#l5.194"></a><span id="l5.194">       if (typeof item[1] == &quot;number&quot;)</span>
<a href="#l5.195"></a><span id="l5.195">         msgHdr = this._indexingFolder.GetMessageHeader(item[1]);</span>
<a href="#l5.196"></a><span id="l5.196">       else</span>
<a href="#l5.197"></a><span id="l5.197">         // same deal as in move processing.</span>
<a href="#l5.198"></a><span id="l5.198">         // TODO fixme to not assume singular message-id's.</span>
<a href="#l5.199"></a><span id="l5.199">         msgHdr = this._indexingDatabase.getMsgHdrForMessageID(item[1]);</span>
<a href="#l5.200"></a><span id="l5.200"> </span>
<a href="#l5.201"></a><span id="l5.201" class="difflineminus">-      // it needs a header, the header needs to not be expunged, plus, the</span>
<a href="#l5.202"></a><span id="l5.202" class="difflineminus">-      //  message needs to be considered offline.</span>
<a href="#l5.203"></a><span id="l5.203" class="difflineplus">+      // it needs a header, and the header needs to not be expunged.</span>
<a href="#l5.204"></a><span id="l5.204">       if (msgHdr &amp;&amp;</span>
<a href="#l5.205"></a><span id="l5.205" class="difflineminus">-          !(msgHdr.flags &amp; Components.interfaces.nsMsgMessageFlags.Expunged) &amp;&amp;</span>
<a href="#l5.206"></a><span id="l5.206" class="difflineminus">-          (folderIsLocal ||</span>
<a href="#l5.207"></a><span id="l5.207" class="difflineminus">-           (msgHdr.flags &amp; Components.interfaces.nsMsgMessageFlags.Offline)))</span>
<a href="#l5.208"></a><span id="l5.208" class="difflineplus">+          !(msgHdr.flags &amp; Components.interfaces.nsMsgMessageFlags.Expunged))</span>
<a href="#l5.209"></a><span id="l5.209">         yield this._callbackHandle.pushAndGo(this._indexMessage(msgHdr,</span>
<a href="#l5.210"></a><span id="l5.210">             this._callbackHandle));</span>
<a href="#l5.211"></a><span id="l5.211">       else</span>
<a href="#l5.212"></a><span id="l5.212">         yield this.kWorkSync;</span>
<a href="#l5.213"></a><span id="l5.213">     }</span>
<a href="#l5.214"></a><span id="l5.214">     yield this.kWorkDone;</span>
<a href="#l5.215"></a><span id="l5.215">   },</span>
<a href="#l5.216"></a><span id="l5.216"> </span>
<a href="#l5.217"></a><span id="l5.217" class="difflineat">@@ -2064,19 +2060,26 @@ var GlodaIndexer = {</span>
<a href="#l5.218"></a><span id="l5.218">      *  is conceivable we will see a number of these events in fairly rapid</span>
<a href="#l5.219"></a><span id="l5.219">      *  succession.)</span>
<a href="#l5.220"></a><span id="l5.220">      */</span>
<a href="#l5.221"></a><span id="l5.221">     msgAdded: function gloda_indexer_msgAdded(aMsgHdr) {</span>
<a href="#l5.222"></a><span id="l5.222">       // make sure the message is eligible for indexing...</span>
<a href="#l5.223"></a><span id="l5.223">       let msgFolder = aMsgHdr.folder;</span>
<a href="#l5.224"></a><span id="l5.224">       if (!this.indexer.shouldIndexFolder(msgFolder))</span>
<a href="#l5.225"></a><span id="l5.225">         return;</span>
<a href="#l5.226"></a><span id="l5.226" class="difflineplus">+</span>
<a href="#l5.227"></a><span id="l5.227" class="difflineplus">+      // Make sure the message is eligible for indexing.</span>
<a href="#l5.228"></a><span id="l5.228" class="difflineplus">+      // We index local messages, IMAP messages that are offline, and IMAP</span>
<a href="#l5.229"></a><span id="l5.229" class="difflineplus">+      // messages that aren't offline but whose folders aren't offline either</span>
<a href="#l5.230"></a><span id="l5.230">       let isFolderLocal = msgFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l5.231"></a><span id="l5.231" class="difflineminus">-      if (!isFolderLocal &amp;&amp; !(msgFolder.flags&amp;Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l5.232"></a><span id="l5.232" class="difflineminus">-        return;</span>
<a href="#l5.233"></a><span id="l5.233" class="difflineplus">+      if (!isFolderLocal) {</span>
<a href="#l5.234"></a><span id="l5.234" class="difflineplus">+        if (!(aMsgHdr.flags &amp; Ci.nsMsgMessageFlags.Offline) &amp;&amp;</span>
<a href="#l5.235"></a><span id="l5.235" class="difflineplus">+            (msgFolder.flags &amp; Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l5.236"></a><span id="l5.236" class="difflineplus">+          return;</span>
<a href="#l5.237"></a><span id="l5.237" class="difflineplus">+      }</span>
<a href="#l5.238"></a><span id="l5.238"> </span>
<a href="#l5.239"></a><span id="l5.239">       // mark the folder dirty so we know to look in it, but there is no need</span>
<a href="#l5.240"></a><span id="l5.240">       //  to mark the message because it will lack a gloda-id anyways.</span>
<a href="#l5.241"></a><span id="l5.241">       let glodaFolder = GlodaDatastore._mapFolder(msgFolder);</span>
<a href="#l5.242"></a><span id="l5.242">       glodaFolder.dirtyStatus = true;</span>
<a href="#l5.243"></a><span id="l5.243"> </span>
<a href="#l5.244"></a><span id="l5.244">       if (this.indexer._pendingAddJob === null) {</span>
<a href="#l5.245"></a><span id="l5.245">         this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l5.246"></a><span id="l5.246" class="difflineat">@@ -2374,19 +2377,26 @@ var GlodaIndexer = {</span>
<a href="#l5.247"></a><span id="l5.247">      *  the indexer will cleanly map this to the existing gloda message.</span>
<a href="#l5.248"></a><span id="l5.248">      */</span>
<a href="#l5.249"></a><span id="l5.249">     _reindexChangedMessage: function gloda_indexer_reindexChangedMessage(</span>
<a href="#l5.250"></a><span id="l5.250">         aMsgHdr) {</span>
<a href="#l5.251"></a><span id="l5.251">       // make sure the message is eligible for indexing...</span>
<a href="#l5.252"></a><span id="l5.252">       let msgFolder = aMsgHdr.folder;</span>
<a href="#l5.253"></a><span id="l5.253">       if (!this.indexer.shouldIndexFolder(msgFolder))</span>
<a href="#l5.254"></a><span id="l5.254">         return;</span>
<a href="#l5.255"></a><span id="l5.255" class="difflineplus">+</span>
<a href="#l5.256"></a><span id="l5.256" class="difflineplus">+      // Make sure the message is eligible for indexing.</span>
<a href="#l5.257"></a><span id="l5.257" class="difflineplus">+      // We index local messages, IMAP messages that are offline, and IMAP</span>
<a href="#l5.258"></a><span id="l5.258" class="difflineplus">+      // messages that aren't offline but whose folders aren't offline either</span>
<a href="#l5.259"></a><span id="l5.259">       let isFolderLocal = msgFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l5.260"></a><span id="l5.260" class="difflineminus">-      if (!isFolderLocal &amp;&amp; !(msgFolder.flags&amp;Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l5.261"></a><span id="l5.261" class="difflineminus">-        return;</span>
<a href="#l5.262"></a><span id="l5.262" class="difflineplus">+      if (!isFolderLocal) {</span>
<a href="#l5.263"></a><span id="l5.263" class="difflineplus">+        if (!(aMsgHdr.flags &amp; Ci.nsMsgMessageFlags.Offline) &amp;&amp;</span>
<a href="#l5.264"></a><span id="l5.264" class="difflineplus">+            (msgFolder.flags &amp; Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l5.265"></a><span id="l5.265" class="difflineplus">+          return;</span>
<a href="#l5.266"></a><span id="l5.266" class="difflineplus">+      }</span>
<a href="#l5.267"></a><span id="l5.267"> </span>
<a href="#l5.268"></a><span id="l5.268">       // mark the message as dirty</span>
<a href="#l5.269"></a><span id="l5.269">       // (We could check for the presence of the gloda message id property</span>
<a href="#l5.270"></a><span id="l5.270">       //  first to know whether we technically need the dirty property.  I'm</span>
<a href="#l5.271"></a><span id="l5.271">       //  not sure whether it is worth the high-probability exception cost.)</span>
<a href="#l5.272"></a><span id="l5.272">       aMsgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, 1);</span>
<a href="#l5.273"></a><span id="l5.273">       // mark the folder dirty too, so we know to look inside</span>
<a href="#l5.274"></a><span id="l5.274">       let glodaFolder = GlodaDatastore._mapFolder(msgFolder);</span>
<a href="#l5.275"></a><span id="l5.275" class="difflineat">@@ -2394,23 +2404,25 @@ var GlodaIndexer = {</span>
<a href="#l5.276"></a><span id="l5.276"> </span>
<a href="#l5.277"></a><span id="l5.277">       if (this.indexer._pendingAddJob === null) {</span>
<a href="#l5.278"></a><span id="l5.278">         this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l5.279"></a><span id="l5.279">         this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l5.280"></a><span id="l5.280">         this.indexer._indexingJobGoal++;</span>
<a href="#l5.281"></a><span id="l5.281">       }</span>
<a href="#l5.282"></a><span id="l5.282">       // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l5.283"></a><span id="l5.283">       if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l5.284"></a><span id="l5.284" class="difflineminus">-          this.indexer._indexMaxEventQueueMessages)</span>
<a href="#l5.285"></a><span id="l5.285" class="difflineplus">+          this.indexer._indexMaxEventQueueMessages) {</span>
<a href="#l5.286"></a><span id="l5.286">         this.indexer._pendingAddJob.items.push(</span>
<a href="#l5.287"></a><span id="l5.287">           [GlodaDatastore._mapFolder(msgFolder).id,</span>
<a href="#l5.288"></a><span id="l5.288">            aMsgHdr.messageKey]);</span>
<a href="#l5.289"></a><span id="l5.289" class="difflineminus">-      else</span>
<a href="#l5.290"></a><span id="l5.290" class="difflineplus">+        this.indexer.indexing = true;</span>
<a href="#l5.291"></a><span id="l5.291" class="difflineplus">+      }</span>
<a href="#l5.292"></a><span id="l5.292" class="difflineplus">+      else {</span>
<a href="#l5.293"></a><span id="l5.293">         this.indexer.indexingSweepNeeded = true;</span>
<a href="#l5.294"></a><span id="l5.294" class="difflineminus">-      this.indexer.indexing = true;</span>
<a href="#l5.295"></a><span id="l5.295" class="difflineplus">+      }</span>
<a href="#l5.296"></a><span id="l5.296">     },</span>
<a href="#l5.297"></a><span id="l5.297"> </span>
<a href="#l5.298"></a><span id="l5.298">     OnItemAdded: function gloda_indexer_OnItemAdded(aParentItem, aItem) {</span>
<a href="#l5.299"></a><span id="l5.299">     },</span>
<a href="#l5.300"></a><span id="l5.300">     OnItemRemoved: function gloda_indexer_OnItemRemoved(aParentItem, aItem) {</span>
<a href="#l5.301"></a><span id="l5.301">     },</span>
<a href="#l5.302"></a><span id="l5.302">     OnItemPropertyChanged: function gloda_indexer_OnItemPropertyChanged(</span>
<a href="#l5.303"></a><span id="l5.303">                              aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l5.304"></a><span id="l5.304" class="difflineat">@@ -2480,23 +2492,37 @@ var GlodaIndexer = {</span>
<a href="#l5.305"></a><span id="l5.305">     onJunkScoreChanged: function(aInstigator) {},</span>
<a href="#l5.306"></a><span id="l5.306">     onHdrPropertyChanged: function (aHdrToChange, aPreChange, aStatus,</span>
<a href="#l5.307"></a><span id="l5.307">                                     aInstigator) {},</span>
<a href="#l5.308"></a><span id="l5.308">     onEvent: function (aDB, aEvent) {},</span>
<a href="#l5.309"></a><span id="l5.309">   },</span>
<a href="#l5.310"></a><span id="l5.310"> </span>
<a href="#l5.311"></a><span id="l5.311">   _indexMessage: function gloda_indexMessage(aMsgHdr, aCallbackHandle) {</span>
<a href="#l5.312"></a><span id="l5.312">     let logDebug = this._log.level &lt;= Log4Moz.Level.Debug;</span>
<a href="#l5.313"></a><span id="l5.313" class="difflineminus">-</span>
<a href="#l5.314"></a><span id="l5.314">     if (logDebug)</span>
<a href="#l5.315"></a><span id="l5.315">       this._log.debug(&quot;*** Indexing message: &quot; + aMsgHdr.messageKey + &quot; : &quot; +</span>
<a href="#l5.316"></a><span id="l5.316">                       aMsgHdr.subject);</span>
<a href="#l5.317"></a><span id="l5.317" class="difflineminus">-    MsgHdrToMimeMessage(aMsgHdr, aCallbackHandle.callbackThis,</span>
<a href="#l5.318"></a><span id="l5.318" class="difflineminus">-        aCallbackHandle.callback);</span>
<a href="#l5.319"></a><span id="l5.319" class="difflineminus">-    let [,aMimeMsg] = yield this.kWorkAsync;</span>
<a href="#l5.320"></a><span id="l5.320" class="difflineplus">+</span>
<a href="#l5.321"></a><span id="l5.321" class="difflineplus">+    // If the message is offline, then get the message body as well</span>
<a href="#l5.322"></a><span id="l5.322" class="difflineplus">+    let isMsgOffline = false;</span>
<a href="#l5.323"></a><span id="l5.323" class="difflineplus">+    let aMimeMsg;</span>
<a href="#l5.324"></a><span id="l5.324" class="difflineplus">+    if ((aMsgHdr.flags &amp; Ci.nsMsgMessageFlags.Offline) ||</span>
<a href="#l5.325"></a><span id="l5.325" class="difflineplus">+        (aMsgHdr.folder instanceof Ci.nsIMsgLocalMailFolder)) {</span>
<a href="#l5.326"></a><span id="l5.326" class="difflineplus">+      isMsgOffline = true;</span>
<a href="#l5.327"></a><span id="l5.327" class="difflineplus">+      MsgHdrToMimeMessage(aMsgHdr, aCallbackHandle.callbackThis,</span>
<a href="#l5.328"></a><span id="l5.328" class="difflineplus">+          aCallbackHandle.callback);</span>
<a href="#l5.329"></a><span id="l5.329" class="difflineplus">+      [,aMimeMsg] = yield this.kWorkAsync;</span>
<a href="#l5.330"></a><span id="l5.330" class="difflineplus">+    }</span>
<a href="#l5.331"></a><span id="l5.331" class="difflineplus">+    else {</span>
<a href="#l5.332"></a><span id="l5.332" class="difflineplus">+      if (logDebug)</span>
<a href="#l5.333"></a><span id="l5.333" class="difflineplus">+        this._log.debug(&quot;  * Message is not offline -- only headers indexed&quot;);</span>
<a href="#l5.334"></a><span id="l5.334" class="difflineplus">+    }</span>
<a href="#l5.335"></a><span id="l5.335" class="difflineplus">+</span>
<a href="#l5.336"></a><span id="l5.336" class="difflineplus">+    if (logDebug)</span>
<a href="#l5.337"></a><span id="l5.337" class="difflineplus">+      this._log.debug(&quot;  * Got message, subject &quot; + aMsgHdr.subject);</span>
<a href="#l5.338"></a><span id="l5.338"> </span>
<a href="#l5.339"></a><span id="l5.339">     if (this._unitTestSuperVerbose) {</span>
<a href="#l5.340"></a><span id="l5.340">       if (aMimeMsg)</span>
<a href="#l5.341"></a><span id="l5.341">         this._log.debug(&quot;  * Got Mime &quot; + aMimeMsg.prettyString());</span>
<a href="#l5.342"></a><span id="l5.342">       else</span>
<a href="#l5.343"></a><span id="l5.343">         this._log.debug(&quot;  * NO MIME MESSAGE!!!\n&quot;);</span>
<a href="#l5.344"></a><span id="l5.344">     }</span>
<a href="#l5.345"></a><span id="l5.345"> </span>
<a href="#l5.346"></a><span id="l5.346" class="difflineat">@@ -2506,18 +2532,18 @@ var GlodaIndexer = {</span>
<a href="#l5.347"></a><span id="l5.347"> </span>
<a href="#l5.348"></a><span id="l5.348">     // - See if any of the ancestors exist and have a conversationID...</span>
<a href="#l5.349"></a><span id="l5.349">     // (references are ordered from old [0] to new [n-1])</span>
<a href="#l5.350"></a><span id="l5.350">     let references = [aMsgHdr.getStringReference(i) for each</span>
<a href="#l5.351"></a><span id="l5.351">                       (i in range(0, aMsgHdr.numReferences))];</span>
<a href="#l5.352"></a><span id="l5.352">     // also see if we already know about the message...</span>
<a href="#l5.353"></a><span id="l5.353">     references.push(aMsgHdr.messageId);</span>
<a href="#l5.354"></a><span id="l5.354"> </span>
<a href="#l5.355"></a><span id="l5.355" class="difflineminus">-    this._datastore.getMessagesByMessageID(references, aCallbackHandle.callback,</span>
<a href="#l5.356"></a><span id="l5.356" class="difflineminus">-      aCallbackHandle.callbackThis);</span>
<a href="#l5.357"></a><span id="l5.357" class="difflineplus">+    Gloda.getMessagesByMessageID(references, aCallbackHandle.callback,</span>
<a href="#l5.358"></a><span id="l5.358" class="difflineplus">+                                 aCallbackHandle.callbackThis);</span>
<a href="#l5.359"></a><span id="l5.359">     // (ancestorLists has a direct correspondence to the message ids)</span>
<a href="#l5.360"></a><span id="l5.360">     let ancestorLists = yield this.kWorkAsync;</span>
<a href="#l5.361"></a><span id="l5.361"> </span>
<a href="#l5.362"></a><span id="l5.362">     if (logDebug) {</span>
<a href="#l5.363"></a><span id="l5.363">       this._log.debug(&quot;ancestors raw: &quot; + ancestorLists);</span>
<a href="#l5.364"></a><span id="l5.364">       this._log.debug(&quot;ref len: &quot; + references.length + &quot; anc len: &quot; + ancestorLists.length);</span>
<a href="#l5.365"></a><span id="l5.365">       this._log.debug(&quot;references: &quot; + Log4Moz.enumerateProperties(references).join(&quot;,&quot;));</span>
<a href="#l5.366"></a><span id="l5.366">       this._log.debug(&quot;ancestors: &quot; + Log4Moz.enumerateProperties(ancestorLists).join(&quot;,&quot;));</span>
<a href="#l5.367"></a><span id="l5.367" class="difflineat">@@ -2663,38 +2689,38 @@ var GlodaIndexer = {</span>
<a href="#l5.368"></a><span id="l5.368">       //  associated with the id is still exactly the same.  It is conceivable</span>
<a href="#l5.369"></a><span id="l5.369">       //  that there are cases where this is not true.</span>
<a href="#l5.370"></a><span id="l5.370">     }</span>
<a href="#l5.371"></a><span id="l5.371"> </span>
<a href="#l5.372"></a><span id="l5.372">     if (aMimeMsg) {</span>
<a href="#l5.373"></a><span id="l5.373">       let bodyPlain = aMimeMsg.coerceBodyToPlaintext(aMsgHdr.folder);</span>
<a href="#l5.374"></a><span id="l5.374">       if (bodyPlain) {</span>
<a href="#l5.375"></a><span id="l5.375">         curMsg._bodyLines = bodyPlain.split(/\r?\n/);</span>
<a href="#l5.376"></a><span id="l5.376" class="difflineminus">-        curMsg._content = new GlodaContent();</span>
<a href="#l5.377"></a><span id="l5.377" class="difflineplus">+        // curMsg._content gets set by fundattr.js</span>
<a href="#l5.378"></a><span id="l5.378">       }</span>
<a href="#l5.379"></a><span id="l5.379">     }</span>
<a href="#l5.380"></a><span id="l5.380"> </span>
<a href="#l5.381"></a><span id="l5.381">     if (isConceptuallyNew) {</span>
<a href="#l5.382"></a><span id="l5.382">       curMsg._isNew = true;</span>
<a href="#l5.383"></a><span id="l5.383">       // curMsg._indexedBodyText is set by GlodaDatastore.insertMessage or</span>
<a href="#l5.384"></a><span id="l5.384">       //  GlodaDatastore.updateMessage</span>
<a href="#l5.385"></a><span id="l5.385" class="difflineminus">-      curMsg._subject = aMsgHdr.mime2DecodedSubject;</span>
<a href="#l5.386"></a><span id="l5.386" class="difflineminus">-      curMsg._attachmentNames = attachmentNames;</span>
<a href="#l5.387"></a><span id="l5.387" class="difflineplus">+    }</span>
<a href="#l5.388"></a><span id="l5.388"> </span>
<a href="#l5.389"></a><span id="l5.389" class="difflineminus">-      // curMsg._indexAuthor gets set by fundattr.js</span>
<a href="#l5.390"></a><span id="l5.390" class="difflineminus">-      // curMsg._indexRecipients gets set by fundattr.js</span>
<a href="#l5.391"></a><span id="l5.391" class="difflineminus">-    }</span>
<a href="#l5.392"></a><span id="l5.392" class="difflineplus">+    curMsg._subject = aMsgHdr.mime2DecodedSubject;</span>
<a href="#l5.393"></a><span id="l5.393" class="difflineplus">+    curMsg._attachmentNames = attachmentNames;</span>
<a href="#l5.394"></a><span id="l5.394" class="difflineplus">+</span>
<a href="#l5.395"></a><span id="l5.395" class="difflineplus">+    // curMsg._indexAuthor gets set by fundattr.js</span>
<a href="#l5.396"></a><span id="l5.396" class="difflineplus">+    // curMsg._indexRecipients gets set by fundattr.js</span>
<a href="#l5.397"></a><span id="l5.397"> </span>
<a href="#l5.398"></a><span id="l5.398">     // zero the notability so everything in grokNounItem can just increment</span>
<a href="#l5.399"></a><span id="l5.399">     curMsg.notability = 0;</span>
<a href="#l5.400"></a><span id="l5.400"> </span>
<a href="#l5.401"></a><span id="l5.401">     yield aCallbackHandle.pushAndGo(</span>
<a href="#l5.402"></a><span id="l5.402">         Gloda.grokNounItem(curMsg,</span>
<a href="#l5.403"></a><span id="l5.403" class="difflineminus">-            {header: aMsgHdr, mime: aMimeMsg,</span>
<a href="#l5.404"></a><span id="l5.404" class="difflineminus">-             bodyLines: curMsg._bodyLines, content: curMsg._content},</span>
<a href="#l5.405"></a><span id="l5.405" class="difflineplus">+            {header: aMsgHdr, mime: aMimeMsg, bodyLines: curMsg._bodyLines},</span>
<a href="#l5.406"></a><span id="l5.406">             isConceptuallyNew, isRecordNew,</span>
<a href="#l5.407"></a><span id="l5.407">             aCallbackHandle));</span>
<a href="#l5.408"></a><span id="l5.408"> </span>
<a href="#l5.409"></a><span id="l5.409">     delete curMsg._bodyLines;</span>
<a href="#l5.410"></a><span id="l5.410">     delete curMsg._content;</span>
<a href="#l5.411"></a><span id="l5.411">     delete curMsg._isNew;</span>
<a href="#l5.412"></a><span id="l5.412">     delete curMsg._indexAuthor;</span>
<a href="#l5.413"></a><span id="l5.413">     delete curMsg._indexRecipients;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/db/gloda/modules/query.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/query.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -68,16 +68,19 @@ Cu.import(&quot;resource://app/modules/gloda/</span>
<a href="#l6.4"></a><span id="l6.4">  *     - outerWrapColumns: If provided, wraps the query in a &quot;SELECT *,blah</span>
<a href="#l6.5"></a><span id="l6.5">  *           FROM (actual query)&quot; where blah is your list of outerWrapColumns</span>
<a href="#l6.6"></a><span id="l6.6">  *           made comma-delimited.  The idea is that this allows you to</span>
<a href="#l6.7"></a><span id="l6.7">  *           reference the result of expressions inside the query using their</span>
<a href="#l6.8"></a><span id="l6.8">  *           names rather than having to duplicate the logic.  In practice,</span>
<a href="#l6.9"></a><span id="l6.9">  *           this makes things more readable but is unlikely to improve</span>
<a href="#l6.10"></a><span id="l6.10">  *           performance.  (Namely, my use of 'offsets' for full-text stuff</span>
<a href="#l6.11"></a><span id="l6.11">  *           ends up in the EXPLAIN plan twice despite this.)</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+ *     - noDbQueryValidityConstraints: Indicates that any validity constraints</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+ *           should be ignored. This should be used when you need to get every</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+ *           match regardless of whether it's valid.</span>
<a href="#l6.15"></a><span id="l6.15">  *</span>
<a href="#l6.16"></a><span id="l6.16">  * @property _owner The query instance that holds the list of unions...</span>
<a href="#l6.17"></a><span id="l6.17">  * @property _constraints A list of (lists of OR constraints) that are ANDed</span>
<a href="#l6.18"></a><span id="l6.18">  *     together.  For example [[FROM bob, FROM jim], [DATE last week]] would</span>
<a href="#l6.19"></a><span id="l6.19">  *     be requesting us to find all the messages from either bob or jim, and</span>
<a href="#l6.20"></a><span id="l6.20">  *     sent in the last week.</span>
<a href="#l6.21"></a><span id="l6.21">  * @property _unions A list of other queries whose results are unioned with our</span>
<a href="#l6.22"></a><span id="l6.22">  *     own.  There is no concept of nesting or sub-queries apart from this</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -15,33 +15,35 @@</span>
<a href="#l7.4"></a><span id="l7.4">  *</span>
<a href="#l7.5"></a><span id="l7.5">  * The Initial Developer of the Original Code is</span>
<a href="#l7.6"></a><span id="l7.6">  * Mozilla Messaging, Inc.</span>
<a href="#l7.7"></a><span id="l7.7">  * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l7.8"></a><span id="l7.8">  * the Initial Developer. All Rights Reserved.</span>
<a href="#l7.9"></a><span id="l7.9">  *</span>
<a href="#l7.10"></a><span id="l7.10">  * Contributor(s):</span>
<a href="#l7.11"></a><span id="l7.11">  *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineplus">+ *   Siddharth Agarwal &lt;sid.bugzilla@gmail.com&gt;</span>
<a href="#l7.13"></a><span id="l7.13">  *</span>
<a href="#l7.14"></a><span id="l7.14">  * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l7.15"></a><span id="l7.15">  * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l7.16"></a><span id="l7.16">  * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l7.17"></a><span id="l7.17">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l7.18"></a><span id="l7.18">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l7.19"></a><span id="l7.19">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l7.20"></a><span id="l7.20">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l7.21"></a><span id="l7.21">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l7.22"></a><span id="l7.22">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l7.23"></a><span id="l7.23">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l7.24"></a><span id="l7.24">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l7.25"></a><span id="l7.25">  *</span>
<a href="#l7.26"></a><span id="l7.26">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l7.27"></a><span id="l7.27"> </span>
<a href="#l7.28"></a><span id="l7.28" class="difflineminus">-// -- Pull in the POP3 fake-server / local account helper code</span>
<a href="#l7.29"></a><span id="l7.29" class="difflineminus">-load(&quot;../../test_mailnewslocal/unit/head_maillocal.js&quot;);</span>
<a href="#l7.30"></a><span id="l7.30" class="difflineplus">+// Import the main scripts that mailnews tests need to set up and tear down</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineplus">+load(&quot;../../mailnews/resources/mailDirService.js&quot;);</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+load(&quot;../../mailnews/resources/mailTestUtils.js&quot;);</span>
<a href="#l7.33"></a><span id="l7.33"> </span>
<a href="#l7.34"></a><span id="l7.34"> /**</span>
<a href="#l7.35"></a><span id="l7.35">  * Create a 'me' identity of &quot;me@localhost&quot; for the benefit of Gloda.  At the</span>
<a href="#l7.36"></a><span id="l7.36">  *  time of this writing, Gloda only initializes Gloda.myIdentities and</span>
<a href="#l7.37"></a><span id="l7.37">  *  Gloda.myContact at startup with no event-driven updates.  As such, this</span>
<a href="#l7.38"></a><span id="l7.38">  *  function needs to be called prior to gloda startup.</span>
<a href="#l7.39"></a><span id="l7.39">  */</span>
<a href="#l7.40"></a><span id="l7.40"> function createMeIdentity() {</span>
<a href="#l7.41"></a><span id="l7.41" class="difflineat">@@ -212,27 +214,54 @@ function getObjectTree(o, recurse, compr</span>
<a href="#l7.42"></a><span id="l7.42">  *     never really needed it anyways.  I just didn't know about the local</span>
<a href="#l7.43"></a><span id="l7.43">  *     folder addMessage method.  (so sad!)</span>
<a href="#l7.44"></a><span id="l7.44">  */</span>
<a href="#l7.45"></a><span id="l7.45"> const INJECT_FAKE_SERVER = 1;</span>
<a href="#l7.46"></a><span id="l7.46"> /** Inject messages using freshly created mboxes. */</span>
<a href="#l7.47"></a><span id="l7.47"> const INJECT_MBOX = 2;</span>
<a href="#l7.48"></a><span id="l7.48"> /** Inject messages using addMessage. */</span>
<a href="#l7.49"></a><span id="l7.49"> const INJECT_ADDMESSAGE = 3;</span>
<a href="#l7.50"></a><span id="l7.50" class="difflineplus">+/** Inject messages using the IMAP fakeserver. */</span>
<a href="#l7.51"></a><span id="l7.51" class="difflineplus">+const INJECT_IMAP_FAKE_SERVER = 4;</span>
<a href="#l7.52"></a><span id="l7.52"> </span>
<a href="#l7.53"></a><span id="l7.53"> /**</span>
<a href="#l7.54"></a><span id="l7.54">  * Convert a list of synthetic messages to a form appropriate to feed to the</span>
<a href="#l7.55"></a><span id="l7.55">  *  POP3 fakeserver.</span>
<a href="#l7.56"></a><span id="l7.56">  */</span>
<a href="#l7.57"></a><span id="l7.57"> function _synthMessagesToFakeRep(aSynthMessages) {</span>
<a href="#l7.58"></a><span id="l7.58">   return [{fileData: msg.toMessageString(), size: -1} for each</span>
<a href="#l7.59"></a><span id="l7.59">           (msg in aSynthMessages)];</span>
<a href="#l7.60"></a><span id="l7.60"> }</span>
<a href="#l7.61"></a><span id="l7.61"> </span>
<a href="#l7.62"></a><span id="l7.62" class="difflineplus">+function lobotomizeAdaptiveIndexer() {</span>
<a href="#l7.63"></a><span id="l7.63" class="difflineplus">+  // The indexer doesn't need to worry about load; zero his rescheduling time.</span>
<a href="#l7.64"></a><span id="l7.64" class="difflineplus">+  GlodaIndexer._INDEX_INTERVAL = 0;</span>
<a href="#l7.65"></a><span id="l7.65" class="difflineplus">+</span>
<a href="#l7.66"></a><span id="l7.66" class="difflineplus">+  let realIdleService = GlodaIndexer._idleService;</span>
<a href="#l7.67"></a><span id="l7.67" class="difflineplus">+  // pretend we are always idle</span>
<a href="#l7.68"></a><span id="l7.68" class="difflineplus">+  GlodaIndexer._idleService = {</span>
<a href="#l7.69"></a><span id="l7.69" class="difflineplus">+    idleTime: 1000,</span>
<a href="#l7.70"></a><span id="l7.70" class="difflineplus">+    addIdleObserver: function() {</span>
<a href="#l7.71"></a><span id="l7.71" class="difflineplus">+      realIdleService.addIdleObserver.apply(realIdleService, arguments);</span>
<a href="#l7.72"></a><span id="l7.72" class="difflineplus">+    },</span>
<a href="#l7.73"></a><span id="l7.73" class="difflineplus">+    removeIdleObserver: function() {</span>
<a href="#l7.74"></a><span id="l7.74" class="difflineplus">+      realIdleService.removeIdleObserver.apply(realIdleService, arguments);</span>
<a href="#l7.75"></a><span id="l7.75" class="difflineplus">+    }</span>
<a href="#l7.76"></a><span id="l7.76" class="difflineplus">+  };</span>
<a href="#l7.77"></a><span id="l7.77" class="difflineplus">+</span>
<a href="#l7.78"></a><span id="l7.78" class="difflineplus">+  // Lobotomize the adaptive indexer</span>
<a href="#l7.79"></a><span id="l7.79" class="difflineplus">+  GlodaIndexer._cpuTargetIndexTime = 10000;</span>
<a href="#l7.80"></a><span id="l7.80" class="difflineplus">+  GlodaIndexer._CPU_TARGET_INDEX_TIME_ACTIVE = 10000;</span>
<a href="#l7.81"></a><span id="l7.81" class="difflineplus">+  GlodaIndexer._CPU_TARGET_INDEX_TIME_IDLE = 10000;</span>
<a href="#l7.82"></a><span id="l7.82" class="difflineplus">+  GlodaIndexer._CPU_IS_BUSY_TIME = 10000;</span>
<a href="#l7.83"></a><span id="l7.83" class="difflineplus">+  GlodaIndexer._PAUSE_LATE_IS_BUSY_TIME = 10000;</span>
<a href="#l7.84"></a><span id="l7.84" class="difflineplus">+}</span>
<a href="#l7.85"></a><span id="l7.85" class="difflineplus">+</span>
<a href="#l7.86"></a><span id="l7.86"> function imsInit() {</span>
<a href="#l7.87"></a><span id="l7.87" class="difflineplus">+  dump(&quot;Initializing index message state\n&quot;);</span>
<a href="#l7.88"></a><span id="l7.88">   let ims = indexMessageState;</span>
<a href="#l7.89"></a><span id="l7.89"> </span>
<a href="#l7.90"></a><span id="l7.90">   if (!ims.inited) {</span>
<a href="#l7.91"></a><span id="l7.91">     // Disable new mail notifications</span>
<a href="#l7.92"></a><span id="l7.92">     var prefSvc = Components.classes[&quot;@mozilla.org/preferences-service;1&quot;]</span>
<a href="#l7.93"></a><span id="l7.93">       .getService(Components.interfaces.nsIPrefBranch);</span>
<a href="#l7.94"></a><span id="l7.94"> </span>
<a href="#l7.95"></a><span id="l7.95">     prefSvc.setBoolPref(&quot;mail.biff.play_sound&quot;, false);</span>
<a href="#l7.96"></a><span id="l7.96" class="difflineat">@@ -241,55 +270,74 @@ function imsInit() {</span>
<a href="#l7.97"></a><span id="l7.97">     prefSvc.setBoolPref(&quot;mail.biff.animate_dock_icon&quot;, false);</span>
<a href="#l7.98"></a><span id="l7.98"> </span>
<a href="#l7.99"></a><span id="l7.99">     Gloda.addIndexerListener(messageIndexerListener.onIndexNotification);</span>
<a href="#l7.100"></a><span id="l7.100">     ims.catchAllCollection = Gloda._wildcardCollection(Gloda.NOUN_MESSAGE);</span>
<a href="#l7.101"></a><span id="l7.101">     ims.catchAllCollection.listener = messageCollectionListener;</span>
<a href="#l7.102"></a><span id="l7.102"> </span>
<a href="#l7.103"></a><span id="l7.103">     // Make the indexer be more verbose about indexing for us...</span>
<a href="#l7.104"></a><span id="l7.104">     GlodaIndexer._unitTestSuperVerbose = true;</span>
<a href="#l7.105"></a><span id="l7.105" class="difflineminus">-    // The indexer doesn't need to worry about load; zero his rescheduling time.</span>
<a href="#l7.106"></a><span id="l7.106" class="difflineminus">-    GlodaIndexer._INDEX_INTERVAL = 0;</span>
<a href="#l7.107"></a><span id="l7.107"> </span>
<a href="#l7.108"></a><span id="l7.108" class="difflineminus">-    let realIdleService = GlodaIndexer._idleService;</span>
<a href="#l7.109"></a><span id="l7.109" class="difflineminus">-    // pretend we are always idle</span>
<a href="#l7.110"></a><span id="l7.110" class="difflineminus">-    GlodaIndexer._idleService = {</span>
<a href="#l7.111"></a><span id="l7.111" class="difflineminus">-      idleTime: 1000,</span>
<a href="#l7.112"></a><span id="l7.112" class="difflineminus">-      addIdleObserver: function() {</span>
<a href="#l7.113"></a><span id="l7.113" class="difflineminus">-        realIdleService.addIdleObserver.apply(realIdleService, arguments);</span>
<a href="#l7.114"></a><span id="l7.114" class="difflineminus">-      },</span>
<a href="#l7.115"></a><span id="l7.115" class="difflineminus">-      removeIdleObserver: function() {</span>
<a href="#l7.116"></a><span id="l7.116" class="difflineminus">-        realIdleService.removeIdleObserver.apply(realIdleService, arguments);</span>
<a href="#l7.117"></a><span id="l7.117" class="difflineminus">-      }</span>
<a href="#l7.118"></a><span id="l7.118" class="difflineminus">-    };</span>
<a href="#l7.119"></a><span id="l7.119" class="difflineminus">-</span>
<a href="#l7.120"></a><span id="l7.120" class="difflineminus">-    // Lobotomize the adaptive indexer</span>
<a href="#l7.121"></a><span id="l7.121" class="difflineminus">-    GlodaIndexer._cpuTargetIndexTime = 10000;</span>
<a href="#l7.122"></a><span id="l7.122" class="difflineminus">-    GlodaIndexer._CPU_TARGET_INDEX_TIME_ACTIVE = 10000;</span>
<a href="#l7.123"></a><span id="l7.123" class="difflineminus">-    GlodaIndexer._CPU_TARGET_INDEX_TIME_IDLE = 10000;</span>
<a href="#l7.124"></a><span id="l7.124" class="difflineminus">-    GlodaIndexer._CPU_IS_BUSY_TIME = 10000;</span>
<a href="#l7.125"></a><span id="l7.125" class="difflineminus">-    GlodaIndexer._PAUSE_LATE_IS_BUSY_TIME = 10000;</span>
<a href="#l7.126"></a><span id="l7.126" class="difflineplus">+    lobotomizeAdaptiveIndexer();</span>
<a href="#l7.127"></a><span id="l7.127"> </span>
<a href="#l7.128"></a><span id="l7.128">     if (ims.injectMechanism == INJECT_FAKE_SERVER) {</span>
<a href="#l7.129"></a><span id="l7.129" class="difflineplus">+      // -- Pull in the POP3 fake-server / local account helper code</span>
<a href="#l7.130"></a><span id="l7.130" class="difflineplus">+      load(&quot;../../test_mailnewslocal/unit/head_maillocal.js&quot;);</span>
<a href="#l7.131"></a><span id="l7.131">       // set up POP3 fakeserver to feed things in...</span>
<a href="#l7.132"></a><span id="l7.132">       [ims.daemon, ims.server] = setupServerDaemon();</span>
<a href="#l7.133"></a><span id="l7.133">       // (this will call loadLocalMailAccount())</span>
<a href="#l7.134"></a><span id="l7.134">       ims.incomingServer = createPop3ServerAndLocalFolders();</span>
<a href="#l7.135"></a><span id="l7.135"> </span>
<a href="#l7.136"></a><span id="l7.136">       ims.pop3Service = Cc[&quot;@mozilla.org/messenger/popservice;1&quot;]</span>
<a href="#l7.137"></a><span id="l7.137">                           .getService(Ci.nsIPop3Service);</span>
<a href="#l7.138"></a><span id="l7.138">     }</span>
<a href="#l7.139"></a><span id="l7.139">     else if (ims.injectMechanism == INJECT_MBOX) {</span>
<a href="#l7.140"></a><span id="l7.140">       // we need a local account to stash the mboxes under.</span>
<a href="#l7.141"></a><span id="l7.141">       loadLocalMailAccount();</span>
<a href="#l7.142"></a><span id="l7.142">     }</span>
<a href="#l7.143"></a><span id="l7.143">     else if (ims.injectMechanism == INJECT_ADDMESSAGE) {</span>
<a href="#l7.144"></a><span id="l7.144">       // we need an inbox</span>
<a href="#l7.145"></a><span id="l7.145">       loadLocalMailAccount();</span>
<a href="#l7.146"></a><span id="l7.146">     }</span>
<a href="#l7.147"></a><span id="l7.147" class="difflineplus">+    else if (ims.injectMechanism == INJECT_IMAP_FAKE_SERVER) {</span>
<a href="#l7.148"></a><span id="l7.148" class="difflineplus">+      // Pull in the IMAP fake server code</span>
<a href="#l7.149"></a><span id="l7.149" class="difflineplus">+      load(&quot;../../test_imap/unit/head_server.js&quot;);</span>
<a href="#l7.150"></a><span id="l7.150" class="difflineplus">+</span>
<a href="#l7.151"></a><span id="l7.151" class="difflineplus">+      // set up IMAP fakeserver and incoming server</span>
<a href="#l7.152"></a><span id="l7.152" class="difflineplus">+      ims.daemon = new imapDaemon();</span>
<a href="#l7.153"></a><span id="l7.153" class="difflineplus">+      ims.server = makeServer(ims.daemon, &quot;&quot;);</span>
<a href="#l7.154"></a><span id="l7.154" class="difflineplus">+      ims.incomingServer = createLocalIMAPServer();</span>
<a href="#l7.155"></a><span id="l7.155" class="difflineplus">+      // we need a local account for the IMAP server to have its sent messages in</span>
<a href="#l7.156"></a><span id="l7.156" class="difflineplus">+      loadLocalMailAccount();</span>
<a href="#l7.157"></a><span id="l7.157" class="difflineplus">+</span>
<a href="#l7.158"></a><span id="l7.158" class="difflineplus">+      // We need an identity so that updateFolder doesn't fail</span>
<a href="#l7.159"></a><span id="l7.159" class="difflineplus">+      let acctMgr = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;]</span>
<a href="#l7.160"></a><span id="l7.160" class="difflineplus">+                      .getService(Ci.nsIMsgAccountManager);</span>
<a href="#l7.161"></a><span id="l7.161" class="difflineplus">+      let localAccount = acctMgr.createAccount();</span>
<a href="#l7.162"></a><span id="l7.162" class="difflineplus">+      let identity = acctMgr.createIdentity();</span>
<a href="#l7.163"></a><span id="l7.163" class="difflineplus">+      localAccount.addIdentity(identity);</span>
<a href="#l7.164"></a><span id="l7.164" class="difflineplus">+      localAccount.defaultIdentity = identity;</span>
<a href="#l7.165"></a><span id="l7.165" class="difflineplus">+      localAccount.incomingServer = gLocalIncomingServer;</span>
<a href="#l7.166"></a><span id="l7.166" class="difflineplus">+      acctMgr.defaultAccount = localAccount;</span>
<a href="#l7.167"></a><span id="l7.167" class="difflineplus">+</span>
<a href="#l7.168"></a><span id="l7.168" class="difflineplus">+      // Let's also have another account, using the same identity</span>
<a href="#l7.169"></a><span id="l7.169" class="difflineplus">+      let imapAccount = acctMgr.createAccount();</span>
<a href="#l7.170"></a><span id="l7.170" class="difflineplus">+      imapAccount.addIdentity(identity);</span>
<a href="#l7.171"></a><span id="l7.171" class="difflineplus">+      imapAccount.defaultIdentity = identity;</span>
<a href="#l7.172"></a><span id="l7.172" class="difflineplus">+      imapAccount.incomingServer = ims.incomingServer;</span>
<a href="#l7.173"></a><span id="l7.173" class="difflineplus">+</span>
<a href="#l7.174"></a><span id="l7.174" class="difflineplus">+      // The server doesn't support more than one connection</span>
<a href="#l7.175"></a><span id="l7.175" class="difflineplus">+      prefSvc.setIntPref(&quot;mail.server.server1.max_cached_connections&quot;, 1);</span>
<a href="#l7.176"></a><span id="l7.176" class="difflineplus">+      // We aren't interested in downloading messages automatically</span>
<a href="#l7.177"></a><span id="l7.177" class="difflineplus">+      prefSvc.setBoolPref(&quot;mail.server.server1.download_on_biff&quot;, false);</span>
<a href="#l7.178"></a><span id="l7.178" class="difflineplus">+</span>
<a href="#l7.179"></a><span id="l7.179" class="difflineplus">+      // Set the inbox to not be offline</span>
<a href="#l7.180"></a><span id="l7.180" class="difflineplus">+      ims.imapInbox = ims.incomingServer.rootFolder.getChildNamed(&quot;Inbox&quot;);</span>
<a href="#l7.181"></a><span id="l7.181" class="difflineplus">+      ims.imapInbox.flags &amp;= ~Ci.nsMsgFolderFlags.Offline;</span>
<a href="#l7.182"></a><span id="l7.182" class="difflineplus">+    }</span>
<a href="#l7.183"></a><span id="l7.183"> </span>
<a href="#l7.184"></a><span id="l7.184">     ims.inited = true;</span>
<a href="#l7.185"></a><span id="l7.185">   }</span>
<a href="#l7.186"></a><span id="l7.186"> }</span>
<a href="#l7.187"></a><span id="l7.187"> </span>
<a href="#l7.188"></a><span id="l7.188"> /**</span>
<a href="#l7.189"></a><span id="l7.189">  * Have gloda index the given synthetic messages, calling the verifier function</span>
<a href="#l7.190"></a><span id="l7.190">  *  (with accumulator field) once the message has been succesfully indexed.</span>
<a href="#l7.191"></a><span id="l7.191" class="difflineat">@@ -307,26 +355,21 @@ function imsInit() {</span>
<a href="#l7.192"></a><span id="l7.192">  *     indexed message), and aPreviousResult (the value last returned by the</span>
<a href="#l7.193"></a><span id="l7.193">  *     verifier function for this given set of messages, or undefined if it is</span>
<a href="#l7.194"></a><span id="l7.194">  *     the first message.)</span>
<a href="#l7.195"></a><span id="l7.195">  * @param aOnDone The function to call when we complete processing this set of</span>
<a href="#l7.196"></a><span id="l7.196">  *     messages.</span>
<a href="#l7.197"></a><span id="l7.197">  */</span>
<a href="#l7.198"></a><span id="l7.198"> function indexMessages(aSynthMessages, aVerifier, aOnDone) {</span>
<a href="#l7.199"></a><span id="l7.199">   let ims = indexMessageState;</span>
<a href="#l7.200"></a><span id="l7.200" class="difflineminus">-</span>
<a href="#l7.201"></a><span id="l7.201" class="difflineminus">-  ims.inputMessages = aSynthMessages;</span>
<a href="#l7.202"></a><span id="l7.202" class="difflineminus">-  ims.glodaMessages = [];</span>
<a href="#l7.203"></a><span id="l7.203" class="difflineminus">-  ims.verifier = aVerifier;</span>
<a href="#l7.204"></a><span id="l7.204" class="difflineminus">-  ims.previousValue = undefined;</span>
<a href="#l7.205"></a><span id="l7.205" class="difflineminus">-  ims.onDone = aOnDone;</span>
<a href="#l7.206"></a><span id="l7.206" class="difflineplus">+  ims.expectMessages(aSynthMessages, aVerifier, aOnDone);</span>
<a href="#l7.207"></a><span id="l7.207"> </span>
<a href="#l7.208"></a><span id="l7.208">   if (ims.injectMechanism == INJECT_FAKE_SERVER) {</span>
<a href="#l7.209"></a><span id="l7.209">     ims.daemon.setMessages(_synthMessagesToFakeRep(aSynthMessages));</span>
<a href="#l7.210"></a><span id="l7.210" class="difflineminus">-    do_timeout(0, &quot;driveFakeServer();&quot;);</span>
<a href="#l7.211"></a><span id="l7.211" class="difflineplus">+    do_timeout(0, &quot;drivePOP3FakeServer();&quot;);</span>
<a href="#l7.212"></a><span id="l7.212">   }</span>
<a href="#l7.213"></a><span id="l7.213">   else if (ims.injectMechanism == INJECT_MBOX) {</span>
<a href="#l7.214"></a><span id="l7.214">     ims.mboxName = &quot;injecty&quot; + ims.nextMboxNumber++;</span>
<a href="#l7.215"></a><span id="l7.215">     writeMessagesToMbox(aSynthMessages, gProfileDir,</span>
<a href="#l7.216"></a><span id="l7.216">                         &quot;Mail&quot;, &quot;Local Folders&quot;, ims.mboxName);</span>
<a href="#l7.217"></a><span id="l7.217"> </span>
<a href="#l7.218"></a><span id="l7.218">     let rootFolder = gLocalIncomingServer.rootMsgFolder;</span>
<a href="#l7.219"></a><span id="l7.219">     let subFolder = rootFolder.addSubfolder(ims.mboxName);</span>
<a href="#l7.220"></a><span id="l7.220" class="difflineat">@@ -339,57 +382,101 @@ function indexMessages(aSynthMessages, a</span>
<a href="#l7.221"></a><span id="l7.221">     });</span>
<a href="#l7.222"></a><span id="l7.222">   }</span>
<a href="#l7.223"></a><span id="l7.223">   else if (ims.injectMechanism == INJECT_ADDMESSAGE) {</span>
<a href="#l7.224"></a><span id="l7.224">     let localFolder = gLocalInboxFolder.QueryInterface(Ci.nsIMsgLocalMailFolder);</span>
<a href="#l7.225"></a><span id="l7.225">     for (let [, msg] in Iterator(aSynthMessages)) {</span>
<a href="#l7.226"></a><span id="l7.226">       localFolder.addMessage(msg.toMboxString());</span>
<a href="#l7.227"></a><span id="l7.227">     }</span>
<a href="#l7.228"></a><span id="l7.228">   }</span>
<a href="#l7.229"></a><span id="l7.229" class="difflineplus">+  else if (ims.injectMechanism == INJECT_IMAP_FAKE_SERVER) {</span>
<a href="#l7.230"></a><span id="l7.230" class="difflineplus">+    let ioService = Cc[&quot;@mozilla.org/network/io-service;1&quot;]</span>
<a href="#l7.231"></a><span id="l7.231" class="difflineplus">+                      .getService(Ci.nsIIOService);</span>
<a href="#l7.232"></a><span id="l7.232" class="difflineplus">+    let serverInbox = ims.daemon.getMailbox(&quot;INBOX&quot;);</span>
<a href="#l7.233"></a><span id="l7.233"> </span>
<a href="#l7.234"></a><span id="l7.234" class="difflineplus">+    for (let [, msg] in Iterator(aSynthMessages)) {</span>
<a href="#l7.235"></a><span id="l7.235" class="difflineplus">+      // Generate a URI out of the message</span>
<a href="#l7.236"></a><span id="l7.236" class="difflineplus">+      let URI = ioService.newURI(&quot;data:text/plain;base64,&quot; + btoa(msg.toMessageString()), null, null);</span>
<a href="#l7.237"></a><span id="l7.237" class="difflineplus">+      // Add it to the server</span>
<a href="#l7.238"></a><span id="l7.238" class="difflineplus">+      serverInbox.addMessage(new imapMessage(URI.spec, serverInbox.uidnext++, []));</span>
<a href="#l7.239"></a><span id="l7.239" class="difflineplus">+    }</span>
<a href="#l7.240"></a><span id="l7.240" class="difflineplus">+    // Time to do stuff with the fakeserver</span>
<a href="#l7.241"></a><span id="l7.241" class="difflineplus">+    driveIMAPFakeServer();</span>
<a href="#l7.242"></a><span id="l7.242" class="difflineplus">+  }</span>
<a href="#l7.243"></a><span id="l7.243"> }</span>
<a href="#l7.244"></a><span id="l7.244"> </span>
<a href="#l7.245"></a><span id="l7.245"> function injectMessagesUsing(aInjectMechanism) {</span>
<a href="#l7.246"></a><span id="l7.246">   indexMessageState.injectMechanism = aInjectMechanism;</span>
<a href="#l7.247"></a><span id="l7.247"> }</span>
<a href="#l7.248"></a><span id="l7.248"> </span>
<a href="#l7.249"></a><span id="l7.249"> var indexMessageState = {</span>
<a href="#l7.250"></a><span id="l7.250">   /** have we been initialized (hooked listeners, etc.) */</span>
<a href="#l7.251"></a><span id="l7.251">   inited: false,</span>
<a href="#l7.252"></a><span id="l7.252" class="difflineplus">+  /** whether we're due for any index notifications */</span>
<a href="#l7.253"></a><span id="l7.253" class="difflineplus">+  expectingIndexNotifications: false,</span>
<a href="#l7.254"></a><span id="l7.254">   /** our catch-all message collection that nets us all messages passing by */</span>
<a href="#l7.255"></a><span id="l7.255">   catchAllCollection: null,</span>
<a href="#l7.256"></a><span id="l7.256">   /** the set of synthetic messages passed in to indexMessages */</span>
<a href="#l7.257"></a><span id="l7.257">   inputMessages: null,</span>
<a href="#l7.258"></a><span id="l7.258">   /** the gloda messages resulting from indexing corresponding to input ones */</span>
<a href="#l7.259"></a><span id="l7.259">   glodaMessages: null,</span>
<a href="#l7.260"></a><span id="l7.260">   /** the user-specified accumulate-style verification func */</span>
<a href="#l7.261"></a><span id="l7.261">   verifier: null,</span>
<a href="#l7.262"></a><span id="l7.262">   /** the result of the last call to the verification function */</span>
<a href="#l7.263"></a><span id="l7.263">   previousValue: undefined,</span>
<a href="#l7.264"></a><span id="l7.264">   /** the function to call once we have indexed all the messages */</span>
<a href="#l7.265"></a><span id="l7.265">   onDone: null,</span>
<a href="#l7.266"></a><span id="l7.266"> </span>
<a href="#l7.267"></a><span id="l7.267">   injectMechanism: INJECT_ADDMESSAGE,</span>
<a href="#l7.268"></a><span id="l7.268"> </span>
<a href="#l7.269"></a><span id="l7.269">   /* === Fake Server State === */</span>
<a href="#l7.270"></a><span id="l7.270" class="difflineminus">-  /** nsMailServer instance with POP3_RFC1939 handler */</span>
<a href="#l7.271"></a><span id="l7.271" class="difflineplus">+  /** nsMailServer instance (if POP3, with POP3_RFC1939 handler) */</span>
<a href="#l7.272"></a><span id="l7.272">   server: null,</span>
<a href="#l7.273"></a><span id="l7.273">   serverStarted: false,</span>
<a href="#l7.274"></a><span id="l7.274" class="difflineminus">-  /** pop3Daemon instance */</span>
<a href="#l7.275"></a><span id="l7.275" class="difflineplus">+  /** pop3Daemon/imapDaemon instance */</span>
<a href="#l7.276"></a><span id="l7.276">   daemon: null,</span>
<a href="#l7.277"></a><span id="l7.277" class="difflineminus">-  /** incoming pop3 server */</span>
<a href="#l7.278"></a><span id="l7.278" class="difflineplus">+  /** incoming pop3/imap server */</span>
<a href="#l7.279"></a><span id="l7.279">   incomingServer: null,</span>
<a href="#l7.280"></a><span id="l7.280" class="difflineminus">-  /** pop3 service */</span>
<a href="#l7.281"></a><span id="l7.281" class="difflineplus">+  /** pop3 service (not used for imap) */</span>
<a href="#l7.282"></a><span id="l7.282">   pop3Service: null,</span>
<a href="#l7.283"></a><span id="l7.283" class="difflineplus">+  /** IMAP inbox */</span>
<a href="#l7.284"></a><span id="l7.284" class="difflineplus">+  imapInbox: null,</span>
<a href="#l7.285"></a><span id="l7.285"> </span>
<a href="#l7.286"></a><span id="l7.286">   /* === MBox Injection State === */</span>
<a href="#l7.287"></a><span id="l7.287">   nextMboxNumber: 0,</span>
<a href="#l7.288"></a><span id="l7.288">   mboxName: null,</span>
<a href="#l7.289"></a><span id="l7.289"> </span>
<a href="#l7.290"></a><span id="l7.290">   /**</span>
<a href="#l7.291"></a><span id="l7.291" class="difflineplus">+   * Sets up messages to expect index notifications for.</span>
<a href="#l7.292"></a><span id="l7.292" class="difflineplus">+   *</span>
<a href="#l7.293"></a><span id="l7.293" class="difflineplus">+   * @param aSynthMessages The synthetic messages to expect notifications</span>
<a href="#l7.294"></a><span id="l7.294" class="difflineplus">+   *     for. We currently don't do anything with these other than count them,</span>
<a href="#l7.295"></a><span id="l7.295" class="difflineplus">+   *     so pass whatever you want and it will be the 'source message' (1st</span>
<a href="#l7.296"></a><span id="l7.296" class="difflineplus">+   *     argument) to your verifier function.</span>
<a href="#l7.297"></a><span id="l7.297" class="difflineplus">+   * @param aVerifier The function to call to verify that the indexing had the</span>
<a href="#l7.298"></a><span id="l7.298" class="difflineplus">+   *     desired result.  Takes arguments aSynthMessage (the synthetic message</span>
<a href="#l7.299"></a><span id="l7.299" class="difflineplus">+   *     just indexed), aGlodaMessage (the gloda message representation of the</span>
<a href="#l7.300"></a><span id="l7.300" class="difflineplus">+   *     indexed message), and aPreviousResult (the value last returned by the</span>
<a href="#l7.301"></a><span id="l7.301" class="difflineplus">+   *     verifier function for this given set of messages, or undefined if it is</span>
<a href="#l7.302"></a><span id="l7.302" class="difflineplus">+   *     the first message.)</span>
<a href="#l7.303"></a><span id="l7.303" class="difflineplus">+   * @param aOnDone The function to call when we complete processing this set of</span>
<a href="#l7.304"></a><span id="l7.304" class="difflineplus">+   *     messages.</span>
<a href="#l7.305"></a><span id="l7.305" class="difflineplus">+   */</span>
<a href="#l7.306"></a><span id="l7.306" class="difflineplus">+  expectMessages: function indexMessageState_expectMessages(aSynthMessages, aVerifier,</span>
<a href="#l7.307"></a><span id="l7.307" class="difflineplus">+                                                            aOnDone) {</span>
<a href="#l7.308"></a><span id="l7.308" class="difflineplus">+    dump(&quot;^^^ setting up &quot; + aSynthMessages.length + &quot; message(s) to expect\n&quot;);</span>
<a href="#l7.309"></a><span id="l7.309" class="difflineplus">+    this.inputMessages = aSynthMessages;</span>
<a href="#l7.310"></a><span id="l7.310" class="difflineplus">+    this.expectingIndexNotifications = true;</span>
<a href="#l7.311"></a><span id="l7.311" class="difflineplus">+    this.glodaMessages = [];</span>
<a href="#l7.312"></a><span id="l7.312" class="difflineplus">+    this.verifier = aVerifier;</span>
<a href="#l7.313"></a><span id="l7.313" class="difflineplus">+    this.previousValue = undefined;</span>
<a href="#l7.314"></a><span id="l7.314" class="difflineplus">+    this.onDone = aOnDone;</span>
<a href="#l7.315"></a><span id="l7.315" class="difflineplus">+  },</span>
<a href="#l7.316"></a><span id="l7.316" class="difflineplus">+</span>
<a href="#l7.317"></a><span id="l7.317" class="difflineplus">+  /**</span>
<a href="#l7.318"></a><span id="l7.318">    * Listener to handle the completion of the POP3 message retrieval (one way or</span>
<a href="#l7.319"></a><span id="l7.319">    *  the other.)</span>
<a href="#l7.320"></a><span id="l7.320">    */</span>
<a href="#l7.321"></a><span id="l7.321">   urlListener: {</span>
<a href="#l7.322"></a><span id="l7.322">     OnStartRunningUrl: function (url) {</span>
<a href="#l7.323"></a><span id="l7.323">     },</span>
<a href="#l7.324"></a><span id="l7.324">     OnStopRunningUrl: function (url, result) {</span>
<a href="#l7.325"></a><span id="l7.325">       let ims = indexMessageState;</span>
<a href="#l7.326"></a><span id="l7.326" class="difflineat">@@ -413,48 +500,22 @@ var indexMessageState = {</span>
<a href="#l7.327"></a><span id="l7.327"> </span>
<a href="#l7.328"></a><span id="l7.328">       // we are expecting the gloda indexer to receive some notification as the</span>
<a href="#l7.329"></a><span id="l7.329">       //  result of the new messages showing up, so we don't actually need to</span>
<a href="#l7.330"></a><span id="l7.330">       //  do anything here.</span>
<a href="#l7.331"></a><span id="l7.331">     }</span>
<a href="#l7.332"></a><span id="l7.332">   }</span>
<a href="#l7.333"></a><span id="l7.333"> };</span>
<a href="#l7.334"></a><span id="l7.334"> </span>
<a href="#l7.335"></a><span id="l7.335" class="difflineminus">-</span>
<a href="#l7.336"></a><span id="l7.336"> /**</span>
<a href="#l7.337"></a><span id="l7.337" class="difflineminus">- * Indicate that we should expect some modified messages to be indexed.</span>
<a href="#l7.338"></a><span id="l7.338" class="difflineminus">- *</span>
<a href="#l7.339"></a><span id="l7.339" class="difflineminus">- * @param aMessages The messages that will be modified and we should expect</span>
<a href="#l7.340"></a><span id="l7.340" class="difflineminus">- *   notifications about.  We currently don't do anything with these other than</span>
<a href="#l7.341"></a><span id="l7.341" class="difflineminus">- *   count them, so pass whatever you want and it will be the 'source message'</span>
<a href="#l7.342"></a><span id="l7.342" class="difflineminus">- *   (1st argument) to your verifier function.</span>
<a href="#l7.343"></a><span id="l7.343" class="difflineminus">- * @param aVerifier See indexMessage's aVerifier argument.</span>
<a href="#l7.344"></a><span id="l7.344" class="difflineminus">- * @param aDone The (optional) callback to call on completion.</span>
<a href="#l7.345"></a><span id="l7.345" class="difflineplus">+ * Perform POP3 mail fetching, seeing it through to completion.</span>
<a href="#l7.346"></a><span id="l7.346">  */</span>
<a href="#l7.347"></a><span id="l7.347" class="difflineminus">-function expectModifiedMessages(aMessages, aVerifier, aOnDone) {</span>
<a href="#l7.348"></a><span id="l7.348" class="difflineplus">+function drivePOP3FakeServer() {</span>
<a href="#l7.349"></a><span id="l7.349">   let ims = indexMessageState;</span>
<a href="#l7.350"></a><span id="l7.350" class="difflineminus">-</span>
<a href="#l7.351"></a><span id="l7.351" class="difflineminus">-  ims.inputMessages = aMessages;</span>
<a href="#l7.352"></a><span id="l7.352" class="difflineminus">-  ims.glodaMessages = [];</span>
<a href="#l7.353"></a><span id="l7.353" class="difflineminus">-  ims.verifier = aVerifier;</span>
<a href="#l7.354"></a><span id="l7.354" class="difflineminus">-  ims.previousValue = undefined;</span>
<a href="#l7.355"></a><span id="l7.355" class="difflineminus">-  ims.onDone = aOnDone;</span>
<a href="#l7.356"></a><span id="l7.356" class="difflineminus">-</span>
<a href="#l7.357"></a><span id="l7.357" class="difflineminus">-  // we don't actually need to do anything.  the caller is going to be</span>
<a href="#l7.358"></a><span id="l7.358" class="difflineminus">-  //  triggering a notification which will spur the indexer into action.  the</span>
<a href="#l7.359"></a><span id="l7.359" class="difflineminus">-  //  indexer uses its own scheduling mechanism to drive itself, so as long</span>
<a href="#l7.360"></a><span id="l7.360" class="difflineminus">-  //  as an event loop is active, we're good.</span>
<a href="#l7.361"></a><span id="l7.361" class="difflineminus">-}</span>
<a href="#l7.362"></a><span id="l7.362" class="difflineminus">-</span>
<a href="#l7.363"></a><span id="l7.363" class="difflineminus">-/**</span>
<a href="#l7.364"></a><span id="l7.364" class="difflineminus">- * Perform the mail fetching, seeing it through to completion.</span>
<a href="#l7.365"></a><span id="l7.365" class="difflineminus">- */</span>
<a href="#l7.366"></a><span id="l7.366" class="difflineminus">-function driveFakeServer() {</span>
<a href="#l7.367"></a><span id="l7.367" class="difflineminus">-  let ims = indexMessageState;</span>
<a href="#l7.368"></a><span id="l7.368" class="difflineminus">-dump(&quot;&gt;&gt;&gt; enter driveFakeServer\n&quot;);</span>
<a href="#l7.369"></a><span id="l7.369" class="difflineplus">+dump(&quot;&gt;&gt;&gt; enter drivePOP3FakeServer\n&quot;);</span>
<a href="#l7.370"></a><span id="l7.370">   // Handle the server in a try/catch/finally loop so that we always will stop</span>
<a href="#l7.371"></a><span id="l7.371">   // the server if something fails.</span>
<a href="#l7.372"></a><span id="l7.372">   try {</span>
<a href="#l7.373"></a><span id="l7.373">     if (!(ims.serverStarted)) {</span>
<a href="#l7.374"></a><span id="l7.374">       dump(&quot;  starting fake server\n&quot;);</span>
<a href="#l7.375"></a><span id="l7.375">       ims.server.start(POP3_PORT);</span>
<a href="#l7.376"></a><span id="l7.376">       ims.serverStarted = true;</span>
<a href="#l7.377"></a><span id="l7.377">     }</span>
<a href="#l7.378"></a><span id="l7.378" class="difflineat">@@ -475,35 +536,70 @@ dump(&quot;&gt;&gt;&gt; enter driveFakeServer\n&quot;);</span>
<a href="#l7.379"></a><span id="l7.379">     do_throw(e);</span>
<a href="#l7.380"></a><span id="l7.380">   }</span>
<a href="#l7.381"></a><span id="l7.381">   finally {</span>
<a href="#l7.382"></a><span id="l7.382">     dump(&quot;  draining events\n&quot;);</span>
<a href="#l7.383"></a><span id="l7.383">     var thread = gThreadManager.currentThread;</span>
<a href="#l7.384"></a><span id="l7.384">     while (thread.hasPendingEvents())</span>
<a href="#l7.385"></a><span id="l7.385">       thread.processNextEvent(true);</span>
<a href="#l7.386"></a><span id="l7.386">   }</span>
<a href="#l7.387"></a><span id="l7.387" class="difflineminus">-dump(&quot;&lt;&lt;&lt; exit driveFakeServer\n&quot;);</span>
<a href="#l7.388"></a><span id="l7.388" class="difflineplus">+dump(&quot;&lt;&lt;&lt; exit drivePOP3FakeServer\n&quot;);</span>
<a href="#l7.389"></a><span id="l7.389"> }</span>
<a href="#l7.390"></a><span id="l7.390"> </span>
<a href="#l7.391"></a><span id="l7.391"> /**</span>
<a href="#l7.392"></a><span id="l7.392" class="difflineplus">+ * Perform an IMAP mail fetch, seeing it through to completion</span>
<a href="#l7.393"></a><span id="l7.393" class="difflineplus">+ */</span>
<a href="#l7.394"></a><span id="l7.394" class="difflineplus">+function driveIMAPFakeServer() {</span>
<a href="#l7.395"></a><span id="l7.395" class="difflineplus">+  dump(&quot;&gt;&gt;&gt; enter driveIMAPFakeServer\n&quot;);</span>
<a href="#l7.396"></a><span id="l7.396" class="difflineplus">+  let ims = indexMessageState;</span>
<a href="#l7.397"></a><span id="l7.397" class="difflineplus">+  // Handle the server in a try/catch/finally loop so that we always will stop</span>
<a href="#l7.398"></a><span id="l7.398" class="difflineplus">+  // the server if something fails.</span>
<a href="#l7.399"></a><span id="l7.399" class="difflineplus">+  try {</span>
<a href="#l7.400"></a><span id="l7.400" class="difflineplus">+    dump(&quot;  resetting fake server\n&quot;);</span>
<a href="#l7.401"></a><span id="l7.401" class="difflineplus">+    ims.server.resetTest();</span>
<a href="#l7.402"></a><span id="l7.402" class="difflineplus">+</span>
<a href="#l7.403"></a><span id="l7.403" class="difflineplus">+    // Update the inbox</span>
<a href="#l7.404"></a><span id="l7.404" class="difflineplus">+    dump(&quot;  issuing updateFolder\n&quot;);</span>
<a href="#l7.405"></a><span id="l7.405" class="difflineplus">+    ims.imapInbox.updateFolder(null);</span>
<a href="#l7.406"></a><span id="l7.406" class="difflineplus">+    // performTest won't work here because that seemingly blocks until the</span>
<a href="#l7.407"></a><span id="l7.407" class="difflineplus">+    // socket is closed, which is something undesirable here</span>
<a href="#l7.408"></a><span id="l7.408" class="difflineplus">+  }</span>
<a href="#l7.409"></a><span id="l7.409" class="difflineplus">+  catch (e) {</span>
<a href="#l7.410"></a><span id="l7.410" class="difflineplus">+    ims.server.stop();</span>
<a href="#l7.411"></a><span id="l7.411" class="difflineplus">+    do_throw(e);</span>
<a href="#l7.412"></a><span id="l7.412" class="difflineplus">+  }</span>
<a href="#l7.413"></a><span id="l7.413" class="difflineplus">+  finally {</span>
<a href="#l7.414"></a><span id="l7.414" class="difflineplus">+    dump(&quot;  draining events\n&quot;);</span>
<a href="#l7.415"></a><span id="l7.415" class="difflineplus">+    let thread = gThreadManager.currentThread;</span>
<a href="#l7.416"></a><span id="l7.416" class="difflineplus">+    while (thread.hasPendingEvents())</span>
<a href="#l7.417"></a><span id="l7.417" class="difflineplus">+      thread.processNextEvent(true);</span>
<a href="#l7.418"></a><span id="l7.418" class="difflineplus">+  }</span>
<a href="#l7.419"></a><span id="l7.419" class="difflineplus">+  dump(&quot;&lt;&lt;&lt; exit driveIMAPFakeServer\n&quot;);</span>
<a href="#l7.420"></a><span id="l7.420" class="difflineplus">+}</span>
<a href="#l7.421"></a><span id="l7.421" class="difflineplus">+</span>
<a href="#l7.422"></a><span id="l7.422" class="difflineplus">+</span>
<a href="#l7.423"></a><span id="l7.423" class="difflineplus">+/**</span>
<a href="#l7.424"></a><span id="l7.424">  * Tear down the fake server.  This is very important to avoid things getting</span>
<a href="#l7.425"></a><span id="l7.425">  *  upset during shutdown.  (Namely, XPConnect will get mad about running in</span>
<a href="#l7.426"></a><span id="l7.426">  *  a context without &quot;Components&quot; defined.)</span>
<a href="#l7.427"></a><span id="l7.427">  */</span>
<a href="#l7.428"></a><span id="l7.428"> function killFakeServer() {</span>
<a href="#l7.429"></a><span id="l7.429" class="difflineplus">+  dump(&quot;Killing fake server\n&quot;);</span>
<a href="#l7.430"></a><span id="l7.430">   let ims = indexMessageState;</span>
<a href="#l7.431"></a><span id="l7.431"> </span>
<a href="#l7.432"></a><span id="l7.432">   ims.incomingServer.closeCachedConnections();</span>
<a href="#l7.433"></a><span id="l7.433"> </span>
<a href="#l7.434"></a><span id="l7.434">   // No more tests, let everything finish</span>
<a href="#l7.435"></a><span id="l7.435">   ims.server.stop();</span>
<a href="#l7.436"></a><span id="l7.436"> </span>
<a href="#l7.437"></a><span id="l7.437">   var thread = gThreadManager.currentThread;</span>
<a href="#l7.438"></a><span id="l7.438">   while (thread.hasPendingEvents())</span>
<a href="#l7.439"></a><span id="l7.439">     thread.processNextEvent(true);</span>
<a href="#l7.440"></a><span id="l7.440" class="difflineplus">+</span>
<a href="#l7.441"></a><span id="l7.441" class="difflineplus">+  do_test_finished();</span>
<a href="#l7.442"></a><span id="l7.442"> }</span>
<a href="#l7.443"></a><span id="l7.443"> </span>
<a href="#l7.444"></a><span id="l7.444"> /**</span>
<a href="#l7.445"></a><span id="l7.445">  * Our catch-all collection listener.  Any time a new message gets indexed,</span>
<a href="#l7.446"></a><span id="l7.446">  *  we should receive an onItemsAdded call.  Any time an existing message</span>
<a href="#l7.447"></a><span id="l7.447">  *  gets reindexed, we should receive an onItemsModified call.  Any time an</span>
<a href="#l7.448"></a><span id="l7.448">  *  existing message actually gets purged from the system, we should receive</span>
<a href="#l7.449"></a><span id="l7.449">  *  an onItemsRemoved call.</span>
<a href="#l7.450"></a><span id="l7.450" class="difflineat">@@ -544,47 +640,65 @@ function runOnIndexingComplete(aCallback</span>
<a href="#l7.451"></a><span id="l7.451">  * Gloda indexer listener, used to know when all active indexing jobs have</span>
<a href="#l7.452"></a><span id="l7.452">  *  completed so that we can try and process all the things that should have</span>
<a href="#l7.453"></a><span id="l7.453">  *  been processed.</span>
<a href="#l7.454"></a><span id="l7.454">  */</span>
<a href="#l7.455"></a><span id="l7.455"> var messageIndexerListener = {</span>
<a href="#l7.456"></a><span id="l7.456">   callbackOnDone: null,</span>
<a href="#l7.457"></a><span id="l7.457">   onIndexNotification: function(aStatus, aPrettyName, aJobIndex, aJobTotal,</span>
<a href="#l7.458"></a><span id="l7.458">                                 aJobItemIndex, aJobItemGoal) {</span>
<a href="#l7.459"></a><span id="l7.459" class="difflineplus">+    dump(&quot;((( Index listener notified! aStatus = &quot; + aStatus + &quot;\n&quot;);</span>
<a href="#l7.460"></a><span id="l7.460" class="difflineplus">+    // Ignore moving/removing notifications</span>
<a href="#l7.461"></a><span id="l7.461" class="difflineplus">+    if (aStatus == Gloda.kIndexerMoving || aStatus == Gloda.kIndexerRemoving)</span>
<a href="#l7.462"></a><span id="l7.462" class="difflineplus">+      return;</span>
<a href="#l7.463"></a><span id="l7.463" class="difflineplus">+</span>
<a href="#l7.464"></a><span id="l7.464" class="difflineplus">+    let ims = indexMessageState;</span>
<a href="#l7.465"></a><span id="l7.465" class="difflineplus">+    // If we shouldn't be receiving notifications and we receive one with aStatus</span>
<a href="#l7.466"></a><span id="l7.466" class="difflineplus">+    // != kIndexerIdle. throw.</span>
<a href="#l7.467"></a><span id="l7.467" class="difflineplus">+    if (!ims.expectingIndexNotifications) {</span>
<a href="#l7.468"></a><span id="l7.468" class="difflineplus">+      if (aStatus == Gloda.kIndexerIdle) {</span>
<a href="#l7.469"></a><span id="l7.469" class="difflineplus">+        dump(&quot;((( Ignoring indexing notification since it's just kIndexerIdle.\n&quot;);</span>
<a href="#l7.470"></a><span id="l7.470" class="difflineplus">+        return;</span>
<a href="#l7.471"></a><span id="l7.471" class="difflineplus">+      }</span>
<a href="#l7.472"></a><span id="l7.472" class="difflineplus">+      else {</span>
<a href="#l7.473"></a><span id="l7.473" class="difflineplus">+        do_throw(&quot;Exception during index notification -- we weren't &quot; +</span>
<a href="#l7.474"></a><span id="l7.474" class="difflineplus">+                 &quot;expecting one.&quot;);</span>
<a href="#l7.475"></a><span id="l7.475" class="difflineplus">+      }</span>
<a href="#l7.476"></a><span id="l7.476" class="difflineplus">+    }</span>
<a href="#l7.477"></a><span id="l7.477" class="difflineplus">+</span>
<a href="#l7.478"></a><span id="l7.478">     // we only care if indexing has just completed...</span>
<a href="#l7.479"></a><span id="l7.479" class="difflineminus">-    if (!GlodaIndexer.indexing) {</span>
<a href="#l7.480"></a><span id="l7.480" class="difflineplus">+    if (aStatus == Gloda.kIndexerIdle) {</span>
<a href="#l7.481"></a><span id="l7.481">       if (messageIndexerListener.callbackOnDone) {</span>
<a href="#l7.482"></a><span id="l7.482">         let callback = messageIndexerListener.callbackOnDone;</span>
<a href="#l7.483"></a><span id="l7.483">         messageIndexerListener.callbackOnDone = null;</span>
<a href="#l7.484"></a><span id="l7.484">         callback();</span>
<a href="#l7.485"></a><span id="l7.485">       }</span>
<a href="#l7.486"></a><span id="l7.486"> </span>
<a href="#l7.487"></a><span id="l7.487" class="difflineminus">-      let ims = indexMessageState;</span>
<a href="#l7.488"></a><span id="l7.488" class="difflineminus">-</span>
<a href="#l7.489"></a><span id="l7.489" class="difflineminus">-      // this is just the synthetic notification if inputMessages is null</span>
<a href="#l7.490"></a><span id="l7.490" class="difflineminus">-      if (ims.inputMessages === null) {</span>
<a href="#l7.491"></a><span id="l7.491" class="difflineminus">-        dump(&quot;((( ignoring indexing notification, assuming synthetic &quot; +</span>
<a href="#l7.492"></a><span id="l7.492" class="difflineminus">-             &quot;notification.\n&quot;);</span>
<a href="#l7.493"></a><span id="l7.493" class="difflineminus">-        return;</span>
<a href="#l7.494"></a><span id="l7.494" class="difflineminus">-      }</span>
<a href="#l7.495"></a><span id="l7.495" class="difflineminus">-</span>
<a href="#l7.496"></a><span id="l7.496">       // if we haven't seen all the messages we should see, assume that the</span>
<a href="#l7.497"></a><span id="l7.497">       //  rest are on their way, and are just coming in a subsequent job...</span>
<a href="#l7.498"></a><span id="l7.498">       // (Also, the first time we register our listener, we will get a synthetic</span>
<a href="#l7.499"></a><span id="l7.499">       //  idle status; at least if the indexer is idle.)</span>
<a href="#l7.500"></a><span id="l7.500" class="difflineminus">-      if (ims.glodaMessages.length &lt; ims.inputMessages.length) {</span>
<a href="#l7.501"></a><span id="l7.501" class="difflineplus">+      let glodaLen = ims.glodaMessages.length, inputLen =</span>
<a href="#l7.502"></a><span id="l7.502" class="difflineplus">+        ims.inputMessages.length;</span>
<a href="#l7.503"></a><span id="l7.503" class="difflineplus">+      if (glodaLen &lt; inputLen) {</span>
<a href="#l7.504"></a><span id="l7.504">         dump(&quot;((( indexing is no longer indexing, but we're still expecting &quot; +</span>
<a href="#l7.505"></a><span id="l7.505" class="difflineminus">-             &quot;more results, ignoring.\n&quot;);</span>
<a href="#l7.506"></a><span id="l7.506" class="difflineplus">+             inputLen + &quot; - &quot; + glodaLen + &quot; = &quot; + (inputLen - glodaLen) +</span>
<a href="#l7.507"></a><span id="l7.507" class="difflineplus">+             &quot; more results, ignoring.\n&quot;);</span>
<a href="#l7.508"></a><span id="l7.508" class="difflineplus">+        // If we're running IMAP, then update the folder once more</span>
<a href="#l7.509"></a><span id="l7.509" class="difflineplus">+        if (ims.imapInbox)</span>
<a href="#l7.510"></a><span id="l7.510" class="difflineplus">+          ims.imapInbox.updateFolder(null);</span>
<a href="#l7.511"></a><span id="l7.511">         return;</span>
<a href="#l7.512"></a><span id="l7.512">       }</span>
<a href="#l7.513"></a><span id="l7.513"> </span>
<a href="#l7.514"></a><span id="l7.514">       dump(&quot;((( indexer notification (&quot; + ims.glodaMessages.length +</span>
<a href="#l7.515"></a><span id="l7.515">            &quot; messages) about to verify: &quot; +</span>
<a href="#l7.516"></a><span id="l7.516">            (ims.verifier ? ims.verifier.name : &quot;none&quot;) + &quot; and complete: &quot; +</span>
<a href="#l7.517"></a><span id="l7.517">            (ims.onDone ? ims.onDone.name : &quot;none&quot;) + &quot;\n&quot;);</span>
<a href="#l7.518"></a><span id="l7.518" class="difflineplus">+      // If we're verifying messages, we shouldn't be expecting them</span>
<a href="#l7.519"></a><span id="l7.519" class="difflineplus">+      ims.expectingIndexNotifications = false;</span>
<a href="#l7.520"></a><span id="l7.520"> </span>
<a href="#l7.521"></a><span id="l7.521">       // call the verifier.  (we expect them to generate an exception if the</span>
<a href="#l7.522"></a><span id="l7.522">       //  verification fails, using do_check_*/do_throw; we don't care about</span>
<a href="#l7.523"></a><span id="l7.523">       //  the return value except to propagate forward to subsequent calls.)</span>
<a href="#l7.524"></a><span id="l7.524">       for (let iMessage=0; iMessage &lt; ims.inputMessages.length; iMessage++) {</span>
<a href="#l7.525"></a><span id="l7.525">         if (ims.verifier) {</span>
<a href="#l7.526"></a><span id="l7.526">           try {</span>
<a href="#l7.527"></a><span id="l7.527">             ims.previousValue = ims.verifier(ims.inputMessages[iMessage],</span>
<a href="#l7.528"></a><span id="l7.528" class="difflineat">@@ -595,16 +709,17 @@ var messageIndexerListener = {</span>
<a href="#l7.529"></a><span id="l7.529">             do_throw(&quot;Exception during verification via &quot; + ims.verifier.name +</span>
<a href="#l7.530"></a><span id="l7.530">                 &quot; on message index: &quot; + iMessage + &quot; previous value: &quot; +</span>
<a href="#l7.531"></a><span id="l7.531">                 ims.previousValue + &quot; gloda message: &quot; +</span>
<a href="#l7.532"></a><span id="l7.532">                 ims.glodaMessages[iMessage] + &quot;\nexception: &quot; + ex);</span>
<a href="#l7.533"></a><span id="l7.533">           }</span>
<a href="#l7.534"></a><span id="l7.534">         }</span>
<a href="#l7.535"></a><span id="l7.535">       }</span>
<a href="#l7.536"></a><span id="l7.536"> </span>
<a href="#l7.537"></a><span id="l7.537" class="difflineplus">+      dump(&quot;((( Verification complete\n&quot;);</span>
<a href="#l7.538"></a><span id="l7.538">       if (ims.onDone) {</span>
<a href="#l7.539"></a><span id="l7.539">         try {</span>
<a href="#l7.540"></a><span id="l7.540">           ims.onDone();</span>
<a href="#l7.541"></a><span id="l7.541">         }</span>
<a href="#l7.542"></a><span id="l7.542">         catch (ex) {</span>
<a href="#l7.543"></a><span id="l7.543">           do_throw(&quot;Exception calling ims.onDone (&quot; + ims.onDone.name + &quot;): &quot; +</span>
<a href="#l7.544"></a><span id="l7.544">               ex);</span>
<a href="#l7.545"></a><span id="l7.545">         }</span>
<a href="#l7.546"></a><span id="l7.546" class="difflineat">@@ -765,19 +880,18 @@ function twiddleAndTest(aSynthMsg, aActi</span>
<a href="#l7.547"></a><span id="l7.547">   function twiddle_next_attr(smsg, gmsg) {</span>
<a href="#l7.548"></a><span id="l7.548">     let curTwiddling = aActionsAndTests[iTwiddling];</span>
<a href="#l7.549"></a><span id="l7.549">     let twiddleFunc = curTwiddling[0];</span>
<a href="#l7.550"></a><span id="l7.550">     let desiredState = curTwiddling[2];</span>
<a href="#l7.551"></a><span id="l7.551"> </span>
<a href="#l7.552"></a><span id="l7.552">     // the underlying nsIMsgDBHdr should exist at this point...</span>
<a href="#l7.553"></a><span id="l7.553">     do_check_neq(gmsg.folderMessage, null);</span>
<a href="#l7.554"></a><span id="l7.554">     // prepare</span>
<a href="#l7.555"></a><span id="l7.555" class="difflineminus">-    expectModifiedMessages([gmsg.folderMessage], verify_next_attr);</span>
<a href="#l7.556"></a><span id="l7.556" class="difflineplus">+    indexMessageState.expectMessages([gmsg.folderMessage], verify_next_attr);</span>
<a href="#l7.557"></a><span id="l7.557">     // tell the function to perform its mutation to the desired state</span>
<a href="#l7.558"></a><span id="l7.558" class="difflineminus">-    dump(&quot;twiddling: &quot; + twiddleFunc.name + &quot;: &quot; + desiredState + &quot;\n&quot;);</span>
<a href="#l7.559"></a><span id="l7.559">     twiddleFunc(gmsg.folderMessage, desiredState);</span>
<a href="#l7.560"></a><span id="l7.560">   }</span>
<a href="#l7.561"></a><span id="l7.561">   function verify_next_attr(smsg, gmsg) {</span>
<a href="#l7.562"></a><span id="l7.562">     let curTwiddling = aActionsAndTests[iTwiddling];</span>
<a href="#l7.563"></a><span id="l7.563">     let verifyFunc = curTwiddling[1];</span>
<a href="#l7.564"></a><span id="l7.564">     let expectedVal = curTwiddling[curTwiddling.length == 3 ? 2 : 3];</span>
<a href="#l7.565"></a><span id="l7.565">     dump(&quot;verifying: &quot; + verifyFunc.name + &quot;: &quot; + expectedVal + &quot;\n&quot;);</span>
<a href="#l7.566"></a><span id="l7.566">     verifyFunc(smsg, gmsg, expectedVal);</span>
<a href="#l7.567"></a><span id="l7.567" class="difflineat">@@ -1016,18 +1130,21 @@ function _gh_test_iterator() {</span>
<a href="#l7.568"></a><span id="l7.568">       }</span>
<a href="#l7.569"></a><span id="l7.569">     }</span>
<a href="#l7.570"></a><span id="l7.570">     else {</span>
<a href="#l7.571"></a><span id="l7.571">       dump(&quot;====== Test function: &quot; + test.name + &quot;\n&quot;);</span>
<a href="#l7.572"></a><span id="l7.572">       yield test();</span>
<a href="#l7.573"></a><span id="l7.573">     }</span>
<a href="#l7.574"></a><span id="l7.574">   }</span>
<a href="#l7.575"></a><span id="l7.575"> </span>
<a href="#l7.576"></a><span id="l7.576" class="difflineminus">-  if (indexMessageState.injectMechanism == INJECT_FAKE_SERVER) {</span>
<a href="#l7.577"></a><span id="l7.577" class="difflineminus">-    killFakeServer();</span>
<a href="#l7.578"></a><span id="l7.578" class="difflineplus">+  if (indexMessageState.injectMechanism == INJECT_FAKE_SERVER ||</span>
<a href="#l7.579"></a><span id="l7.579" class="difflineplus">+      indexMessageState.injectMechanism == INJECT_IMAP_FAKE_SERVER) {</span>
<a href="#l7.580"></a><span id="l7.580" class="difflineplus">+    do_test_pending();</span>
<a href="#l7.581"></a><span id="l7.581" class="difflineplus">+    // Give a bit of time for any remaining notifications to go through.</span>
<a href="#l7.582"></a><span id="l7.582" class="difflineplus">+    do_timeout(500, &quot;killFakeServer()&quot;);</span>
<a href="#l7.583"></a><span id="l7.583">   }</span>
<a href="#l7.584"></a><span id="l7.584"> </span>
<a href="#l7.585"></a><span id="l7.585">   do_test_finished();</span>
<a href="#l7.586"></a><span id="l7.586"> </span>
<a href="#l7.587"></a><span id="l7.587">   // once the control flow hits the root after do_test_finished, we're done,</span>
<a href="#l7.588"></a><span id="l7.588">   //  so let's just yield something to avoid callers having to deal with an</span>
<a href="#l7.589"></a><span id="l7.589">   //  exception indicating completion.</span>
<a href="#l7.590"></a><span id="l7.590">   yield null;</span>
<a href="#l7.591"></a><span id="l7.591" class="difflineat">@@ -1067,25 +1184,33 @@ function parameterizeTest(aTestFunc, aPa</span>
<a href="#l7.592"></a><span id="l7.592"> }</span>
<a href="#l7.593"></a><span id="l7.593"> </span>
<a href="#l7.594"></a><span id="l7.594"> /**</span>
<a href="#l7.595"></a><span id="l7.595">  * Test driving logic that takes a list of tests to run.  Every completed test</span>
<a href="#l7.596"></a><span id="l7.596">  *  needs to call (or cause to be called) next_test.</span>
<a href="#l7.597"></a><span id="l7.597">  *</span>
<a href="#l7.598"></a><span id="l7.598">  * @param aTests A list of test functions to call.</span>
<a href="#l7.599"></a><span id="l7.599">  * @param aLongestTestRunTimeConceivableInSecs Optional parameter</span>
<a href="#l7.600"></a><span id="l7.600" class="difflineplus">+ * @param aDontInitIMS Optional parameter. If this is specified then the index</span>
<a href="#l7.601"></a><span id="l7.601" class="difflineplus">+ *                     message state is not initialized</span>
<a href="#l7.602"></a><span id="l7.602">  */</span>
<a href="#l7.603"></a><span id="l7.603" class="difflineminus">-function glodaHelperRunTests(aTests, aLongestTestRunTimeConceivableInSecs) {</span>
<a href="#l7.604"></a><span id="l7.604" class="difflineplus">+function glodaHelperRunTests(aTests, aLongestTestRunTimeConceivableInSecs,</span>
<a href="#l7.605"></a><span id="l7.605" class="difflineplus">+                             aDontInitIMS) {</span>
<a href="#l7.606"></a><span id="l7.606">   if (aLongestTestRunTimeConceivableInSecs == null)</span>
<a href="#l7.607"></a><span id="l7.607">     aLongestTestRunTimeConceivableInSecs =</span>
<a href="#l7.608"></a><span id="l7.608">         DEFAULT_LONGEST_TEST_RUN_CONCEIVABLE_SECS;</span>
<a href="#l7.609"></a><span id="l7.609">   do_timeout(aLongestTestRunTimeConceivableInSecs * 1000,</span>
<a href="#l7.610"></a><span id="l7.610">       &quot;do_throw('Timeout running test, and we want you to have the log.');&quot;);</span>
<a href="#l7.611"></a><span id="l7.611"> </span>
<a href="#l7.612"></a><span id="l7.612" class="difflineminus">-  imsInit();</span>
<a href="#l7.613"></a><span id="l7.613" class="difflineplus">+  if (!aDontInitIMS)</span>
<a href="#l7.614"></a><span id="l7.614" class="difflineplus">+    imsInit();</span>
<a href="#l7.615"></a><span id="l7.615" class="difflineplus">+  // even if we don't want to init IMS, we want to avoid anything adaptive</span>
<a href="#l7.616"></a><span id="l7.616" class="difflineplus">+  //  happening.</span>
<a href="#l7.617"></a><span id="l7.617" class="difflineplus">+  else</span>
<a href="#l7.618"></a><span id="l7.618" class="difflineplus">+    lobotomizeAdaptiveIndexer();</span>
<a href="#l7.619"></a><span id="l7.619">   glodaHelperTests = aTests;</span>
<a href="#l7.620"></a><span id="l7.620">   glodaHelperIterator = _gh_test_iterator();</span>
<a href="#l7.621"></a><span id="l7.621">   next_test();</span>
<a href="#l7.622"></a><span id="l7.622"> }</span>
<a href="#l7.623"></a><span id="l7.623"> </span>
<a href="#l7.624"></a><span id="l7.624"> /**</span>
<a href="#l7.625"></a><span id="l7.625">  * Wipe out almost everything from the clutches of the GlodaCollectionManager.</span>
<a href="#l7.626"></a><span id="l7.626">  * By default, it is caching things and knows about all the non-GC'ed</span>
<a href="#l7.627"></a><span id="l7.627" class="difflineat">@@ -1130,8 +1255,24 @@ function nukeGlodaCachesAndCollections()</span>
<a href="#l7.628"></a><span id="l7.628">   // caches aren't intended to be cleared, but we also don't want to lose our</span>
<a href="#l7.629"></a><span id="l7.629">   //  caches, so we need to create new ones from the ashes of the old ones.</span>
<a href="#l7.630"></a><span id="l7.630">   let oldCaches = GlodaCollectionManager._cachesByNoun;</span>
<a href="#l7.631"></a><span id="l7.631">   GlodaCollectionManager._cachesByNoun = {};</span>
<a href="#l7.632"></a><span id="l7.632">   for each (let cache in oldCaches) {</span>
<a href="#l7.633"></a><span id="l7.633">     GlodaCollectionManager.defineCache(cache._nounDef, cache._maxCacheSize);</span>
<a href="#l7.634"></a><span id="l7.634">   }</span>
<a href="#l7.635"></a><span id="l7.635"> }</span>
<a href="#l7.636"></a><span id="l7.636" class="difflineplus">+</span>
<a href="#l7.637"></a><span id="l7.637" class="difflineplus">+/**</span>
<a href="#l7.638"></a><span id="l7.638" class="difflineplus">+ * Given an IMAP folder, marks it offline and downloads its messages.</span>
<a href="#l7.639"></a><span id="l7.639" class="difflineplus">+ *</span>
<a href="#l7.640"></a><span id="l7.640" class="difflineplus">+ * @param aFolder an IMAP message folder</span>
<a href="#l7.641"></a><span id="l7.641" class="difflineplus">+ * @param aSynthMessages see indexMessageState.expectMessages</span>
<a href="#l7.642"></a><span id="l7.642" class="difflineplus">+ * @param aVerifier see indexMessageState.expectMessages</span>
<a href="#l7.643"></a><span id="l7.643" class="difflineplus">+ * @param aDone see indexMessageState.expectMessages</span>
<a href="#l7.644"></a><span id="l7.644" class="difflineplus">+ */</span>
<a href="#l7.645"></a><span id="l7.645" class="difflineplus">+function imapDownloadAllMessages(aFolder, aSynthMessages, aVerifier, aDone) {</span>
<a href="#l7.646"></a><span id="l7.646" class="difflineplus">+  // Let the message state know that we're expecting messages</span>
<a href="#l7.647"></a><span id="l7.647" class="difflineplus">+  indexMessageState.expectMessages(aSynthMessages, aVerifier, aDone);</span>
<a href="#l7.648"></a><span id="l7.648" class="difflineplus">+  aFolder.setFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l7.649"></a><span id="l7.649" class="difflineplus">+  aFolder.downloadAllForOffline(null, null);</span>
<a href="#l7.650"></a><span id="l7.650" class="difflineplus">+  // The indexer listener is going to call aDone, so our job is done here</span>
<a href="#l7.651"></a><span id="l7.651" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_gloda_content.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_gloda_content.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -92,16 +92,27 @@ var messageInfos = [</span>
<a href="#l8.4"></a><span id="l8.4">            [false, &quot;&gt; wrote&quot;],</span>
<a href="#l8.5"></a><span id="l8.5">            [true, &quot;cheese&quot;],</span>
<a href="#l8.6"></a><span id="l8.6">            [false, &quot;&quot;]]</span>
<a href="#l8.7"></a><span id="l8.7">   }</span>
<a href="#l8.8"></a><span id="l8.8"> ];</span>
<a href="#l8.9"></a><span id="l8.9"> </span>
<a href="#l8.10"></a><span id="l8.10"> /* ===== Tests ===== */</span>
<a href="#l8.11"></a><span id="l8.11"> </span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+/**</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+ * Hooks for pre/post setup message, used for the IMAP tests.</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+ */</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+var pre_inject_message_hook = function default_pre_inject_message_hook() {</span>
<a href="#l8.16"></a><span id="l8.16" class="difflineplus">+  next_test();</span>
<a href="#l8.17"></a><span id="l8.17" class="difflineplus">+};</span>
<a href="#l8.18"></a><span id="l8.18" class="difflineplus">+</span>
<a href="#l8.19"></a><span id="l8.19" class="difflineplus">+var post_inject_message_hook = function default_post_inject_message_hook() {</span>
<a href="#l8.20"></a><span id="l8.20" class="difflineplus">+  next_test();</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineplus">+};</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineplus">+</span>
<a href="#l8.23"></a><span id="l8.23"> function setup_create_message(info) {</span>
<a href="#l8.24"></a><span id="l8.24">   info.body = {body: [tupe[1] for each</span>
<a href="#l8.25"></a><span id="l8.25">                       ([, tupe] in Iterator(info.bode))].join(&quot;\r\n&quot;)};</span>
<a href="#l8.26"></a><span id="l8.26">   info.expected = [tupe[1] for each</span>
<a href="#l8.27"></a><span id="l8.27">                    ([, tupe] in Iterator(info.bode)) if</span>
<a href="#l8.28"></a><span id="l8.28">                    (tupe[0])].join(&quot;\n&quot;);</span>
<a href="#l8.29"></a><span id="l8.29"> </span>
<a href="#l8.30"></a><span id="l8.30">   info._synMsg = msgGen.makeMessage(info);</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineat">@@ -120,20 +131,22 @@ function glodaInfoStasher(aSynthMessage,</span>
<a href="#l8.32"></a><span id="l8.32">       messageInfos[iMsg]._glodaMsg = aGlodaMessage;</span>
<a href="#l8.33"></a><span id="l8.33">     }</span>
<a href="#l8.34"></a><span id="l8.34">   }</span>
<a href="#l8.35"></a><span id="l8.35"> }</span>
<a href="#l8.36"></a><span id="l8.36"> </span>
<a href="#l8.37"></a><span id="l8.37"> /**</span>
<a href="#l8.38"></a><span id="l8.38">  * Actually inject all the messages we created above.</span>
<a href="#l8.39"></a><span id="l8.39">  */</span>
<a href="#l8.40"></a><span id="l8.40" class="difflineplus">+var gSynMessages;</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineplus">+</span>
<a href="#l8.42"></a><span id="l8.42"> function setup_inject_messages() {</span>
<a href="#l8.43"></a><span id="l8.43" class="difflineminus">-  let synMessages = [info._synMsg for each</span>
<a href="#l8.44"></a><span id="l8.44" class="difflineminus">-                      ([, info] in Iterator(messageInfos))];</span>
<a href="#l8.45"></a><span id="l8.45" class="difflineminus">-  indexMessages(synMessages, glodaInfoStasher, next_test);</span>
<a href="#l8.46"></a><span id="l8.46" class="difflineplus">+  gSynMessages = [info._synMsg for each</span>
<a href="#l8.47"></a><span id="l8.47" class="difflineplus">+                  ([, info] in Iterator(messageInfos))];</span>
<a href="#l8.48"></a><span id="l8.48" class="difflineplus">+  indexMessages(gSynMessages, glodaInfoStasher, next_test);</span>
<a href="#l8.49"></a><span id="l8.49"> }</span>
<a href="#l8.50"></a><span id="l8.50"> </span>
<a href="#l8.51"></a><span id="l8.51"> function test_stream_message(info) {</span>
<a href="#l8.52"></a><span id="l8.52">   let msgHdr = info._glodaMsg.folderMessage;</span>
<a href="#l8.53"></a><span id="l8.53"> </span>
<a href="#l8.54"></a><span id="l8.54">   MsgHdrToMimeMessage(msgHdr, null, function(aMsgHdr, aMimeMsg) {</span>
<a href="#l8.55"></a><span id="l8.55">     verify_message_content(info, info._synMsg, info._glodaMsg, aMsgHdr,</span>
<a href="#l8.56"></a><span id="l8.56">                            aMimeMsg);</span>
<a href="#l8.57"></a><span id="l8.57" class="difflineat">@@ -161,16 +174,20 @@ function verify_message_content(aInfo, a</span>
<a href="#l8.58"></a><span id="l8.58"> </span>
<a href="#l8.59"></a><span id="l8.59">   next_test();</span>
<a href="#l8.60"></a><span id="l8.60"> }</span>
<a href="#l8.61"></a><span id="l8.61"> </span>
<a href="#l8.62"></a><span id="l8.62"> /* ===== Driver ===== */</span>
<a href="#l8.63"></a><span id="l8.63"> </span>
<a href="#l8.64"></a><span id="l8.64"> var tests = [</span>
<a href="#l8.65"></a><span id="l8.65">   parameterizeTest(setup_create_message, messageInfos),</span>
<a href="#l8.66"></a><span id="l8.66" class="difflineplus">+  function pre_inject_message() { pre_inject_message_hook(); },</span>
<a href="#l8.67"></a><span id="l8.67">   setup_inject_messages,</span>
<a href="#l8.68"></a><span id="l8.68" class="difflineplus">+  function post_inject_message() { post_inject_message_hook(); },</span>
<a href="#l8.69"></a><span id="l8.69" class="difflineplus">+ // disable_index_notifications,</span>
<a href="#l8.70"></a><span id="l8.70">   parameterizeTest(test_stream_message, messageInfos),</span>
<a href="#l8.71"></a><span id="l8.71"> ];</span>
<a href="#l8.72"></a><span id="l8.72"> </span>
<a href="#l8.73"></a><span id="l8.73"> function run_test() {</span>
<a href="#l8.74"></a><span id="l8.74" class="difflineminus">-  injectMessagesUsing(INJECT_MBOX);</span>
<a href="#l8.75"></a><span id="l8.75">   glodaHelperRunTests(tests);</span>
<a href="#l8.76"></a><span id="l8.76"> }</span>
<a href="#l8.77"></a><span id="l8.77" class="difflineplus">+</span>
<a href="#l8.78"></a><span id="l8.78" class="difflineplus">+injectMessagesUsing(INJECT_MBOX);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1">new file mode 100644</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineminus">--- /dev/null</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js</span>
<a href="#l9.4"></a><span id="l9.4" class="difflineat">@@ -0,0 +1,17 @@</span>
<a href="#l9.5"></a><span id="l9.5" class="difflineplus">+/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l9.6"></a><span id="l9.6" class="difflineplus">+/**</span>
<a href="#l9.7"></a><span id="l9.7" class="difflineplus">+ * Tests the operation of the GlodaContent (in connotent.js) and its exposure</span>
<a href="#l9.8"></a><span id="l9.8" class="difflineplus">+ * via Gloda.getMessageContent for IMAP messages that are originally offline.</span>
<a href="#l9.9"></a><span id="l9.9" class="difflineplus">+ */</span>
<a href="#l9.10"></a><span id="l9.10" class="difflineplus">+</span>
<a href="#l9.11"></a><span id="l9.11" class="difflineplus">+load(&quot;test_gloda_content.js&quot;);</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineplus">+</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+/**</span>
<a href="#l9.14"></a><span id="l9.14" class="difflineplus">+ * Set the imap folder to offline before adding the messages.</span>
<a href="#l9.15"></a><span id="l9.15" class="difflineplus">+ */</span>
<a href="#l9.16"></a><span id="l9.16" class="difflineplus">+var pre_inject_message_hook = function imap_pre_inject_message_hook() {</span>
<a href="#l9.17"></a><span id="l9.17" class="difflineplus">+  indexMessageState.imapInbox.setFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l9.18"></a><span id="l9.18" class="difflineplus">+  next_test();</span>
<a href="#l9.19"></a><span id="l9.19" class="difflineplus">+};</span>
<a href="#l9.20"></a><span id="l9.20" class="difflineplus">+</span>
<a href="#l9.21"></a><span id="l9.21" class="difflineplus">+injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1">new file mode 100644</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineminus">--- /dev/null</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_gloda_content_imap_switched_to_offline.js</span>
<a href="#l10.4"></a><span id="l10.4" class="difflineat">@@ -0,0 +1,19 @@</span>
<a href="#l10.5"></a><span id="l10.5" class="difflineplus">+/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l10.6"></a><span id="l10.6" class="difflineplus">+/**</span>
<a href="#l10.7"></a><span id="l10.7" class="difflineplus">+ * Tests the operation of the GlodaContent (in connotent.js) and its exposure</span>
<a href="#l10.8"></a><span id="l10.8" class="difflineplus">+ * via Gloda.getMessageContent for IMAP messages that were not originally</span>
<a href="#l10.9"></a><span id="l10.9" class="difflineplus">+ * offline, but were later made offline.</span>
<a href="#l10.10"></a><span id="l10.10" class="difflineplus">+ */</span>
<a href="#l10.11"></a><span id="l10.11" class="difflineplus">+</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+load(&quot;test_gloda_content.js&quot;);</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+</span>
<a href="#l10.14"></a><span id="l10.14" class="difflineplus">+/**</span>
<a href="#l10.15"></a><span id="l10.15" class="difflineplus">+ * Set the imap folder to offline after adding the messages, then force a</span>
<a href="#l10.16"></a><span id="l10.16" class="difflineplus">+ * download of all messages.</span>
<a href="#l10.17"></a><span id="l10.17" class="difflineplus">+ */</span>
<a href="#l10.18"></a><span id="l10.18" class="difflineplus">+var post_inject_message_hook = function imap_post_inject_message_hook() {</span>
<a href="#l10.19"></a><span id="l10.19" class="difflineplus">+  imapDownloadAllMessages(indexMessageState.imapInbox, gSynMessages,</span>
<a href="#l10.20"></a><span id="l10.20" class="difflineplus">+                          glodaInfoStasher, next_test);</span>
<a href="#l10.21"></a><span id="l10.21" class="difflineplus">+};</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineplus">+</span>
<a href="#l10.23"></a><span id="l10.23" class="difflineplus">+injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_messages.js</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_messages.js</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -5,30 +5,45 @@</span>
<a href="#l11.4"></a><span id="l11.4">  *</span>
<a href="#l11.5"></a><span id="l11.5">  * Things we don't test that you think we might test:</span>
<a href="#l11.6"></a><span id="l11.6">  * - Full-text search.  Happens in query testing.</span>
<a href="#l11.7"></a><span id="l11.7">  */</span>
<a href="#l11.8"></a><span id="l11.8"> </span>
<a href="#l11.9"></a><span id="l11.9"> load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l11.10"></a><span id="l11.10"> load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l11.11"></a><span id="l11.11"> </span>
<a href="#l11.12"></a><span id="l11.12" class="difflineplus">+// Whether we can expect fulltext results</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+var expectFulltextResults = true;</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineplus">+</span>
<a href="#l11.15"></a><span id="l11.15"> // Create a message generator</span>
<a href="#l11.16"></a><span id="l11.16"> var msgGen = new MessageGenerator();</span>
<a href="#l11.17"></a><span id="l11.17"> // Create a message scenario generator using that message generator</span>
<a href="#l11.18"></a><span id="l11.18"> var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l11.19"></a><span id="l11.19"> </span>
<a href="#l11.20"></a><span id="l11.20"> /* ===== Threading / Conversation Grouping ===== */</span>
<a href="#l11.21"></a><span id="l11.21"> </span>
<a href="#l11.22"></a><span id="l11.22" class="difflineplus">+var gSynMessages = [];</span>
<a href="#l11.23"></a><span id="l11.23"> function allMessageInSameConversation(aSynthMessage, aGlodaMessage, aConvID) {</span>
<a href="#l11.24"></a><span id="l11.24">   if (aConvID === undefined)</span>
<a href="#l11.25"></a><span id="l11.25">     return aGlodaMessage.conversationID;</span>
<a href="#l11.26"></a><span id="l11.26">   do_check_eq(aConvID, aGlodaMessage.conversationID);</span>
<a href="#l11.27"></a><span id="l11.27" class="difflineplus">+  // Cheat and stash the synthetic message (we need them for one of the IMAP</span>
<a href="#l11.28"></a><span id="l11.28" class="difflineplus">+  // tests)</span>
<a href="#l11.29"></a><span id="l11.29" class="difflineplus">+  gSynMessages.push(aSynthMessage);</span>
<a href="#l11.30"></a><span id="l11.30">   return aConvID;</span>
<a href="#l11.31"></a><span id="l11.31"> }</span>
<a href="#l11.32"></a><span id="l11.32"> </span>
<a href="#l11.33"></a><span id="l11.33" class="difflineplus">+// These are overridden by the IMAP tests as needed</span>
<a href="#l11.34"></a><span id="l11.34" class="difflineplus">+var pre_test_threading_hook = function default_pre_test_threading_hook() {</span>
<a href="#l11.35"></a><span id="l11.35" class="difflineplus">+  next_test();</span>
<a href="#l11.36"></a><span id="l11.36" class="difflineplus">+};</span>
<a href="#l11.37"></a><span id="l11.37" class="difflineplus">+var post_test_threading_hook = function default_post_test_threading_hook() {</span>
<a href="#l11.38"></a><span id="l11.38" class="difflineplus">+  next_test();</span>
<a href="#l11.39"></a><span id="l11.39" class="difflineplus">+};</span>
<a href="#l11.40"></a><span id="l11.40" class="difflineplus">+</span>
<a href="#l11.41"></a><span id="l11.41"> /**</span>
<a href="#l11.42"></a><span id="l11.42">  * Test our conversation/threading logic in the straight-forward direct</span>
<a href="#l11.43"></a><span id="l11.43">  *  reply case, the missing intermediary case, and the siblings with missing</span>
<a href="#l11.44"></a><span id="l11.44">  *  parent case.  We also test all permutations of receipt of those messages.</span>
<a href="#l11.45"></a><span id="l11.45">  * (Also tests that we index new messages.)</span>
<a href="#l11.46"></a><span id="l11.46">  */</span>
<a href="#l11.47"></a><span id="l11.47"> function test_threading() {</span>
<a href="#l11.48"></a><span id="l11.48">   indexAndPermuteMessages(scenarios.directReply,</span>
<a href="#l11.49"></a><span id="l11.49" class="difflineat">@@ -67,22 +82,27 @@ function test_attributes_fundamental() {</span>
<a href="#l11.50"></a><span id="l11.50">     ],</span>
<a href="#l11.51"></a><span id="l11.51">   });</span>
<a href="#l11.52"></a><span id="l11.52">   // save it off for test_attributes_fundamental_from_disk</span>
<a href="#l11.53"></a><span id="l11.53">   fundamentalSyntheticMessage = smsg;</span>
<a href="#l11.54"></a><span id="l11.54"> </span>
<a href="#l11.55"></a><span id="l11.55">   indexMessages([smsg], verify_attributes_fundamental, next_test);</span>
<a href="#l11.56"></a><span id="l11.56"> }</span>
<a href="#l11.57"></a><span id="l11.57"> </span>
<a href="#l11.58"></a><span id="l11.58" class="difflineplus">+// Overridden by test_index_imap_mesasges</span>
<a href="#l11.59"></a><span id="l11.59" class="difflineplus">+var get_expected_folder_URI = function local_get_expected_folder_URI() {</span>
<a href="#l11.60"></a><span id="l11.60" class="difflineplus">+  return gLocalInboxFolder.URI;</span>
<a href="#l11.61"></a><span id="l11.61" class="difflineplus">+};</span>
<a href="#l11.62"></a><span id="l11.62" class="difflineplus">+</span>
<a href="#l11.63"></a><span id="l11.63"> function verify_attributes_fundamental(smsg, gmsg) {</span>
<a href="#l11.64"></a><span id="l11.64">   try {</span>
<a href="#l11.65"></a><span id="l11.65">     // save off the message id for test_attributes_fundamental_from_disk</span>
<a href="#l11.66"></a><span id="l11.66">     fundamentalGlodaMessageId = gmsg.id;</span>
<a href="#l11.67"></a><span id="l11.67"> </span>
<a href="#l11.68"></a><span id="l11.68" class="difflineminus">-    do_check_eq(gmsg.folderURI, gLocalInboxFolder.URI);</span>
<a href="#l11.69"></a><span id="l11.69" class="difflineplus">+    do_check_eq(gmsg.folderURI, get_expected_folder_URI());</span>
<a href="#l11.70"></a><span id="l11.70"> </span>
<a href="#l11.71"></a><span id="l11.71">     // -- subject</span>
<a href="#l11.72"></a><span id="l11.72">     do_check_eq(smsg.subject, gmsg.conversation.subject);</span>
<a href="#l11.73"></a><span id="l11.73">     do_check_eq(smsg.subject, gmsg.subject);</span>
<a href="#l11.74"></a><span id="l11.74"> </span>
<a href="#l11.75"></a><span id="l11.75">     // -- contact/identity information</span>
<a href="#l11.76"></a><span id="l11.76">     // - from</span>
<a href="#l11.77"></a><span id="l11.77">     // check the e-mail address</span>
<a href="#l11.78"></a><span id="l11.78" class="difflineat">@@ -92,22 +112,32 @@ function verify_attributes_fundamental(s</span>
<a href="#l11.79"></a><span id="l11.79">     do_check_eq(smsg.fromName, gmsg.from.contact.name);</span>
<a href="#l11.80"></a><span id="l11.80"> </span>
<a href="#l11.81"></a><span id="l11.81">     // - to</span>
<a href="#l11.82"></a><span id="l11.82">     do_check_eq(smsg.toAddress, gmsg.to[0].value);</span>
<a href="#l11.83"></a><span id="l11.83">     do_check_eq(smsg.toName, gmsg.to[0].contact.name);</span>
<a href="#l11.84"></a><span id="l11.84"> </span>
<a href="#l11.85"></a><span id="l11.85">     // date</span>
<a href="#l11.86"></a><span id="l11.86">     do_check_eq(smsg.date.valueOf(), gmsg.date.valueOf());</span>
<a href="#l11.87"></a><span id="l11.87" class="difflineplus">+    </span>
<a href="#l11.88"></a><span id="l11.88" class="difflineplus">+    // -- message ID</span>
<a href="#l11.89"></a><span id="l11.89" class="difflineplus">+    do_check_eq(smsg.messageId, gmsg.headerMessageID);</span>
<a href="#l11.90"></a><span id="l11.90"> </span>
<a href="#l11.91"></a><span id="l11.91" class="difflineminus">-    // -- attachments</span>
<a href="#l11.92"></a><span id="l11.92" class="difflineminus">-    do_check_eq(gmsg.attachmentTypes.length, 1);</span>
<a href="#l11.93"></a><span id="l11.93" class="difflineminus">-    do_check_eq(gmsg.attachmentTypes[0], &quot;text/plain&quot;);</span>
<a href="#l11.94"></a><span id="l11.94" class="difflineminus">-    do_check_eq(gmsg.attachmentNames.length, 1);</span>
<a href="#l11.95"></a><span id="l11.95" class="difflineminus">-    do_check_eq(gmsg.attachmentNames[0], &quot;bob.txt&quot;);</span>
<a href="#l11.96"></a><span id="l11.96" class="difflineplus">+    // -- attachments. We won't have these if we don't have fulltext results</span>
<a href="#l11.97"></a><span id="l11.97" class="difflineplus">+    if (expectFulltextResults) {</span>
<a href="#l11.98"></a><span id="l11.98" class="difflineplus">+      do_check_eq(gmsg.attachmentTypes.length, 1);</span>
<a href="#l11.99"></a><span id="l11.99" class="difflineplus">+      do_check_eq(gmsg.attachmentTypes[0], &quot;text/plain&quot;);</span>
<a href="#l11.100"></a><span id="l11.100" class="difflineplus">+      do_check_eq(gmsg.attachmentNames.length, 1);</span>
<a href="#l11.101"></a><span id="l11.101" class="difflineplus">+      do_check_eq(gmsg.attachmentNames[0], &quot;bob.txt&quot;);</span>
<a href="#l11.102"></a><span id="l11.102" class="difflineplus">+    }</span>
<a href="#l11.103"></a><span id="l11.103" class="difflineplus">+    else {</span>
<a href="#l11.104"></a><span id="l11.104" class="difflineplus">+      // Make sure we don't actually get attachments!</span>
<a href="#l11.105"></a><span id="l11.105" class="difflineplus">+      do_check_eq(gmsg.attachmentTypes, null);</span>
<a href="#l11.106"></a><span id="l11.106" class="difflineplus">+      do_check_eq(gmsg.attachmentNames, null);</span>
<a href="#l11.107"></a><span id="l11.107" class="difflineplus">+    }</span>
<a href="#l11.108"></a><span id="l11.108">   }</span>
<a href="#l11.109"></a><span id="l11.109">   catch (ex) {</span>
<a href="#l11.110"></a><span id="l11.110">     // print out some info on the various states of the messages...</span>
<a href="#l11.111"></a><span id="l11.111">     dump(&quot;***** FUNDAMENTAL ATTRIBUTE NON-MATCH\n&quot;);</span>
<a href="#l11.112"></a><span id="l11.112">     ddumpObject(smsg, &quot;smsg&quot;, 0);</span>
<a href="#l11.113"></a><span id="l11.113">     ddumpObject(gmsg, &quot;gmsg&quot;, 0);</span>
<a href="#l11.114"></a><span id="l11.114">     throw ex;</span>
<a href="#l11.115"></a><span id="l11.115">   }</span>
<a href="#l11.116"></a><span id="l11.116" class="difflineat">@@ -224,17 +254,19 @@ function test_message_moving() {</span>
<a href="#l11.117"></a><span id="l11.117"> /* ===== Message Deletion ===== */</span>
<a href="#l11.118"></a><span id="l11.118"> function test_message_deletion() {</span>
<a href="#l11.119"></a><span id="l11.119"> }</span>
<a href="#l11.120"></a><span id="l11.120"> </span>
<a href="#l11.121"></a><span id="l11.121"> /* ===== Folder Move/Rename/Copy (Single and Nested) ===== */</span>
<a href="#l11.122"></a><span id="l11.122"> </span>
<a href="#l11.123"></a><span id="l11.123"> </span>
<a href="#l11.124"></a><span id="l11.124"> var tests = [</span>
<a href="#l11.125"></a><span id="l11.125" class="difflineplus">+  function pre_test_threading() { pre_test_threading_hook(); },</span>
<a href="#l11.126"></a><span id="l11.126">   test_threading,</span>
<a href="#l11.127"></a><span id="l11.127" class="difflineplus">+  function post_test_threading() { post_test_threading_hook(); },</span>
<a href="#l11.128"></a><span id="l11.128">   test_attributes_fundamental,</span>
<a href="#l11.129"></a><span id="l11.129">   test_attributes_fundamental_from_disk,</span>
<a href="#l11.130"></a><span id="l11.130">   test_attributes_explicit,</span>
<a href="#l11.131"></a><span id="l11.131"> ];</span>
<a href="#l11.132"></a><span id="l11.132"> </span>
<a href="#l11.133"></a><span id="l11.133"> function run_test() {</span>
<a href="#l11.134"></a><span id="l11.134">   glodaHelperRunTests(tests);</span>
<a href="#l11.135"></a><span id="l11.135"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -9,27 +9,40 @@ load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l12.4"></a><span id="l12.4"> // Create a message generator</span>
<a href="#l12.5"></a><span id="l12.5"> var msgGen = new MessageGenerator();</span>
<a href="#l12.6"></a><span id="l12.6"> // Create a message scenario generator using that message generator</span>
<a href="#l12.7"></a><span id="l12.7"> var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l12.8"></a><span id="l12.8"> </span>
<a href="#l12.9"></a><span id="l12.9"> /**</span>
<a href="#l12.10"></a><span id="l12.10">  * Provide a bunch of messages to be indexed.</span>
<a href="#l12.11"></a><span id="l12.11">  */</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineplus">+var gSynMessages;</span>
<a href="#l12.13"></a><span id="l12.13"> function test_index_a_bunch() {</span>
<a href="#l12.14"></a><span id="l12.14">   // 4-children-per, 3-deep = 21</span>
<a href="#l12.15"></a><span id="l12.15" class="difflineplus">+  // 6-children-per, 3 deep = 43</span>
<a href="#l12.16"></a><span id="l12.16" class="difflineplus">+  // 7-children-per, 3-deep = 57</span>
<a href="#l12.17"></a><span id="l12.17">   // 4-children-per, 4-deep = 85</span>
<a href="#l12.18"></a><span id="l12.18">   // 4-children-per, 5-deep pyramid = 341</span>
<a href="#l12.19"></a><span id="l12.19">   // 5-children-per, 5-deep pyramid = 781</span>
<a href="#l12.20"></a><span id="l12.20">   // 4-children-per, 6-deep pyramid = 1365 messages</span>
<a href="#l12.21"></a><span id="l12.21" class="difflineminus">-  let messages = scenarios.fullPyramid(4, 3);</span>
<a href="#l12.22"></a><span id="l12.22" class="difflineplus">+  gSynMessages = scenarios.fullPyramid(6, 3);</span>
<a href="#l12.23"></a><span id="l12.23">   // we have no need to verify.</span>
<a href="#l12.24"></a><span id="l12.24" class="difflineminus">-  indexMessages(messages, null, next_test);</span>
<a href="#l12.25"></a><span id="l12.25" class="difflineplus">+  indexMessages(gSynMessages, null, next_test);</span>
<a href="#l12.26"></a><span id="l12.26"> }</span>
<a href="#l12.27"></a><span id="l12.27"> </span>
<a href="#l12.28"></a><span id="l12.28" class="difflineplus">+var pre_test_hook = function default_pre_test_hook() {</span>
<a href="#l12.29"></a><span id="l12.29" class="difflineplus">+  next_test();</span>
<a href="#l12.30"></a><span id="l12.30" class="difflineplus">+};</span>
<a href="#l12.31"></a><span id="l12.31" class="difflineplus">+var post_test_hook = function default_post_test_hook() {</span>
<a href="#l12.32"></a><span id="l12.32" class="difflineplus">+  next_test();</span>
<a href="#l12.33"></a><span id="l12.33" class="difflineplus">+};</span>
<a href="#l12.34"></a><span id="l12.34" class="difflineplus">+</span>
<a href="#l12.35"></a><span id="l12.35"> var tests = [</span>
<a href="#l12.36"></a><span id="l12.36" class="difflineplus">+  function pre_test() { pre_test_hook(); },</span>
<a href="#l12.37"></a><span id="l12.37">   test_index_a_bunch,</span>
<a href="#l12.38"></a><span id="l12.38" class="difflineplus">+  function post_test() { post_test_hook(); },</span>
<a href="#l12.39"></a><span id="l12.39"> ];</span>
<a href="#l12.40"></a><span id="l12.40"> </span>
<a href="#l12.41"></a><span id="l12.41"> function run_test() {</span>
<a href="#l12.42"></a><span id="l12.42" class="difflineminus">-  injectMessagesUsing(INJECT_MBOX);</span>
<a href="#l12.43"></a><span id="l12.43">   glodaHelperRunTests(tests);</span>
<a href="#l12.44"></a><span id="l12.44"> }</span>
<a href="#l12.45"></a><span id="l12.45" class="difflineplus">+</span>
<a href="#l12.46"></a><span id="l12.46" class="difflineplus">+injectMessagesUsing(INJECT_MBOX);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1">new file mode 100644</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineminus">--- /dev/null</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js</span>
<a href="#l13.4"></a><span id="l13.4" class="difflineat">@@ -0,0 +1,16 @@</span>
<a href="#l13.5"></a><span id="l13.5" class="difflineplus">+/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l13.6"></a><span id="l13.6" class="difflineplus">+/**</span>
<a href="#l13.7"></a><span id="l13.7" class="difflineplus">+ * Tests how well gloda indexes IMAP messages that aren't offline.</span>
<a href="#l13.8"></a><span id="l13.8" class="difflineplus">+ */</span>
<a href="#l13.9"></a><span id="l13.9" class="difflineplus">+</span>
<a href="#l13.10"></a><span id="l13.10" class="difflineplus">+// Most of the definitions are common, so just re-use those</span>
<a href="#l13.11"></a><span id="l13.11" class="difflineplus">+load(&quot;test_index_messages.js&quot;);</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineplus">+</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+var get_expected_folder_URI = function imap_get_expected_folder_URI() {</span>
<a href="#l13.14"></a><span id="l13.14" class="difflineplus">+  return indexMessageState.imapInbox.URI;</span>
<a href="#l13.15"></a><span id="l13.15" class="difflineplus">+};</span>
<a href="#l13.16"></a><span id="l13.16" class="difflineplus">+</span>
<a href="#l13.17"></a><span id="l13.17" class="difflineplus">+var expectFulltextResults = false;</span>
<a href="#l13.18"></a><span id="l13.18" class="difflineplus">+</span>
<a href="#l13.19"></a><span id="l13.19" class="difflineplus">+// Switch to the IMAP fake server</span>
<a href="#l13.20"></a><span id="l13.20" class="difflineplus">+injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1">new file mode 100644</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineminus">--- /dev/null</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages_in_bulk.js</span>
<a href="#l14.4"></a><span id="l14.4" class="difflineat">@@ -0,0 +1,10 @@</span>
<a href="#l14.5"></a><span id="l14.5" class="difflineplus">+/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l14.6"></a><span id="l14.6" class="difflineplus">+/**</span>
<a href="#l14.7"></a><span id="l14.7" class="difflineplus">+ * Tests how well gloda indexes IMAP messages that aren't offline in bulk.</span>
<a href="#l14.8"></a><span id="l14.8" class="difflineplus">+ */</span>
<a href="#l14.9"></a><span id="l14.9" class="difflineplus">+</span>
<a href="#l14.10"></a><span id="l14.10" class="difflineplus">+// The definitions are common, so just re-use those</span>
<a href="#l14.11"></a><span id="l14.11" class="difflineplus">+load(&quot;test_index_messages_in_bulk.js&quot;);</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineplus">+</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+// Switch to the IMAP fake server</span>
<a href="#l14.14"></a><span id="l14.14" class="difflineplus">+injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1">new file mode 100644</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineminus">--- /dev/null</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js</span>
<a href="#l15.4"></a><span id="l15.4" class="difflineat">@@ -0,0 +1,19 @@</span>
<a href="#l15.5"></a><span id="l15.5" class="difflineplus">+/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l15.6"></a><span id="l15.6" class="difflineplus">+/**</span>
<a href="#l15.7"></a><span id="l15.7" class="difflineplus">+ * Tests how well gloda indexes IMAP messages that are offline from the start.</span>
<a href="#l15.8"></a><span id="l15.8" class="difflineplus">+ */</span>
<a href="#l15.9"></a><span id="l15.9" class="difflineplus">+</span>
<a href="#l15.10"></a><span id="l15.10" class="difflineplus">+// Most of the definitions are common, so just re-use those</span>
<a href="#l15.11"></a><span id="l15.11" class="difflineplus">+load(&quot;test_index_messages.js&quot;);</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineplus">+</span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+var get_expected_folder_URI = function imap_get_expected_folder_URI() {</span>
<a href="#l15.14"></a><span id="l15.14" class="difflineplus">+  return indexMessageState.imapInbox.URI;</span>
<a href="#l15.15"></a><span id="l15.15" class="difflineplus">+};</span>
<a href="#l15.16"></a><span id="l15.16" class="difflineplus">+</span>
<a href="#l15.17"></a><span id="l15.17" class="difflineplus">+var pre_test_threading_hook = function imap_pre_test_threading_hook() {</span>
<a href="#l15.18"></a><span id="l15.18" class="difflineplus">+  indexMessageState.imapInbox.setFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l15.19"></a><span id="l15.19" class="difflineplus">+  next_test();</span>
<a href="#l15.20"></a><span id="l15.20" class="difflineplus">+};</span>
<a href="#l15.21"></a><span id="l15.21" class="difflineplus">+</span>
<a href="#l15.22"></a><span id="l15.22" class="difflineplus">+// Switch to the IMAP fake server</span>
<a href="#l15.23"></a><span id="l15.23" class="difflineplus">+injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1">new file mode 100644</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineminus">--- /dev/null</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages_in_bulk.js</span>
<a href="#l16.4"></a><span id="l16.4" class="difflineat">@@ -0,0 +1,15 @@</span>
<a href="#l16.5"></a><span id="l16.5" class="difflineplus">+/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l16.6"></a><span id="l16.6" class="difflineplus">+/**</span>
<a href="#l16.7"></a><span id="l16.7" class="difflineplus">+ * Tests how well gloda indexes IMAP messages that aren't offline in bulk.</span>
<a href="#l16.8"></a><span id="l16.8" class="difflineplus">+ */</span>
<a href="#l16.9"></a><span id="l16.9" class="difflineplus">+</span>
<a href="#l16.10"></a><span id="l16.10" class="difflineplus">+// The definitions are common, so just re-use those</span>
<a href="#l16.11"></a><span id="l16.11" class="difflineplus">+load(&quot;test_index_messages_in_bulk.js&quot;);</span>
<a href="#l16.12"></a><span id="l16.12" class="difflineplus">+</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+var pre_test_hook = function imap_pre_test_hook() {</span>
<a href="#l16.14"></a><span id="l16.14" class="difflineplus">+  indexMessageState.imapInbox.setFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l16.15"></a><span id="l16.15" class="difflineplus">+  next_test();</span>
<a href="#l16.16"></a><span id="l16.16" class="difflineplus">+};</span>
<a href="#l16.17"></a><span id="l16.17" class="difflineplus">+</span>
<a href="#l16.18"></a><span id="l16.18" class="difflineplus">+// Switch to the IMAP fake server</span>
<a href="#l16.19"></a><span id="l16.19" class="difflineplus">+injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1">new file mode 100644</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineminus">--- /dev/null</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js</span>
<a href="#l17.4"></a><span id="l17.4" class="difflineat">@@ -0,0 +1,21 @@</span>
<a href="#l17.5"></a><span id="l17.5" class="difflineplus">+/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l17.6"></a><span id="l17.6" class="difflineplus">+/**</span>
<a href="#l17.7"></a><span id="l17.7" class="difflineplus">+ * Tests how well gloda indexes IMAP messages that are not offline at first, but</span>
<a href="#l17.8"></a><span id="l17.8" class="difflineplus">+ * are made offline later.</span>
<a href="#l17.9"></a><span id="l17.9" class="difflineplus">+ */</span>
<a href="#l17.10"></a><span id="l17.10" class="difflineplus">+</span>
<a href="#l17.11"></a><span id="l17.11" class="difflineplus">+// Most of the definitions are common, so just re-use those</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineplus">+load(&quot;test_index_messages.js&quot;);</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+</span>
<a href="#l17.14"></a><span id="l17.14" class="difflineplus">+var get_expected_folder_URI = function imap_get_expected_folder_URI() {</span>
<a href="#l17.15"></a><span id="l17.15" class="difflineplus">+  return indexMessageState.imapInbox.URI;</span>
<a href="#l17.16"></a><span id="l17.16" class="difflineplus">+};</span>
<a href="#l17.17"></a><span id="l17.17" class="difflineplus">+</span>
<a href="#l17.18"></a><span id="l17.18" class="difflineplus">+var post_test_threading_hook = function imap_post_test_threading_hook() {</span>
<a href="#l17.19"></a><span id="l17.19" class="difflineplus">+  // We aren't concerned about verification here, so just pass in null</span>
<a href="#l17.20"></a><span id="l17.20" class="difflineplus">+  imapDownloadAllMessages(indexMessageState.imapInbox, gSynMessages, null,</span>
<a href="#l17.21"></a><span id="l17.21" class="difflineplus">+                          next_test);</span>
<a href="#l17.22"></a><span id="l17.22" class="difflineplus">+};</span>
<a href="#l17.23"></a><span id="l17.23" class="difflineplus">+</span>
<a href="#l17.24"></a><span id="l17.24" class="difflineplus">+// Switch to the IMAP fake server</span>
<a href="#l17.25"></a><span id="l17.25" class="difflineplus">+injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1">new file mode 100644</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineminus">--- /dev/null</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages_in_bulk.js</span>
<a href="#l18.4"></a><span id="l18.4" class="difflineat">@@ -0,0 +1,16 @@</span>
<a href="#l18.5"></a><span id="l18.5" class="difflineplus">+/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l18.6"></a><span id="l18.6" class="difflineplus">+/**</span>
<a href="#l18.7"></a><span id="l18.7" class="difflineplus">+ * Tests how well gloda indexes IMAP messages that aren't offline in bulk.</span>
<a href="#l18.8"></a><span id="l18.8" class="difflineplus">+ */</span>
<a href="#l18.9"></a><span id="l18.9" class="difflineplus">+</span>
<a href="#l18.10"></a><span id="l18.10" class="difflineplus">+// The definitions are common, so just re-use those</span>
<a href="#l18.11"></a><span id="l18.11" class="difflineplus">+load(&quot;test_index_messages_in_bulk.js&quot;);</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineplus">+</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+var post_test_hook = function imap_post_test_hook() {</span>
<a href="#l18.14"></a><span id="l18.14" class="difflineplus">+  // We're not verifying anything</span>
<a href="#l18.15"></a><span id="l18.15" class="difflineplus">+  imapDownloadAllMessages(indexMessageState.imapInbox, gSynMessages,</span>
<a href="#l18.16"></a><span id="l18.16" class="difflineplus">+                          null, next_test);</span>
<a href="#l18.17"></a><span id="l18.17" class="difflineplus">+};</span>
<a href="#l18.18"></a><span id="l18.18" class="difflineplus">+</span>
<a href="#l18.19"></a><span id="l18.19" class="difflineplus">+// Switch to the IMAP fake server</span>
<a href="#l18.20"></a><span id="l18.20" class="difflineplus">+injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_query_core.js</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_query_core.js</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -236,17 +236,32 @@ function setup_search_ranking_idiom() {</span>
<a href="#l19.4"></a><span id="l19.4">     new Widget(6, daymore, &quot;&quot;, 0, &quot;&quot;, &quot;bar&quot;), // 1 + 0+</span>
<a href="#l19.5"></a><span id="l19.5">     new Widget(5, origin, &quot;&quot;, 1, &quot;&quot;, &quot;bar&quot;), // 2 + 0</span>
<a href="#l19.6"></a><span id="l19.6">     new Widget(4, daymore, &quot;&quot;, 0, &quot;bar&quot;, &quot;bar&quot;), // 2 + 0+</span>
<a href="#l19.7"></a><span id="l19.7">     new Widget(3, origin, &quot;&quot;, 1, &quot;bar&quot;, &quot;baz&quot;), // 3 + 0</span>
<a href="#l19.8"></a><span id="l19.8">     new Widget(2, monthmore, &quot;&quot;, 0, &quot;&quot;, &quot;bar&quot;), // 1 + 4</span>
<a href="#l19.9"></a><span id="l19.9">     new Widget(1, origin, &quot;&quot;, 0, &quot;bar baz&quot;, &quot;bar baz bar bar&quot;), // 6 + 0</span>
<a href="#l19.10"></a><span id="l19.10">     new Widget(0, origin, &quot;&quot;, 1, &quot;bar baz&quot;, &quot;bar baz bar bar&quot;) // 7 + 0</span>
<a href="#l19.11"></a><span id="l19.11">   ];</span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-  runOnIndexingComplete(next_test);</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+</span>
<a href="#l19.14"></a><span id="l19.14" class="difflineplus">+  let indexingInProgress = false;</span>
<a href="#l19.15"></a><span id="l19.15" class="difflineplus">+</span>
<a href="#l19.16"></a><span id="l19.16" class="difflineplus">+  // Since we don't use the message indexer listener any more in this test, we</span>
<a href="#l19.17"></a><span id="l19.17" class="difflineplus">+  // need to add our own listener.</span>
<a href="#l19.18"></a><span id="l19.18" class="difflineplus">+  function genericIndexerCallback(aStatus) {</span>
<a href="#l19.19"></a><span id="l19.19" class="difflineplus">+    // If indexingInProgress is false, we've received the synthetic</span>
<a href="#l19.20"></a><span id="l19.20" class="difflineplus">+    // notification, so ignore it</span>
<a href="#l19.21"></a><span id="l19.21" class="difflineplus">+    if (indexingInProgress &amp;&amp; aStatus == Gloda.kIndexerIdle) {</span>
<a href="#l19.22"></a><span id="l19.22" class="difflineplus">+      // We're done, so remove ourselves and move to the next test</span>
<a href="#l19.23"></a><span id="l19.23" class="difflineplus">+      Gloda.removeIndexerListener(genericIndexerCallback);</span>
<a href="#l19.24"></a><span id="l19.24" class="difflineplus">+      next_test();</span>
<a href="#l19.25"></a><span id="l19.25" class="difflineplus">+    }</span>
<a href="#l19.26"></a><span id="l19.26" class="difflineplus">+  }</span>
<a href="#l19.27"></a><span id="l19.27" class="difflineplus">+  Gloda.addIndexerListener(genericIndexerCallback);</span>
<a href="#l19.28"></a><span id="l19.28" class="difflineplus">+  indexingInProgress = true;</span>
<a href="#l19.29"></a><span id="l19.29">   GenericIndexer.indexNewObjects(fooWidgets.concat(barBazWidgets));</span>
<a href="#l19.30"></a><span id="l19.30"> }</span>
<a href="#l19.31"></a><span id="l19.31"> </span>
<a href="#l19.32"></a><span id="l19.32"> // add one because the last snippet shouldn't have a trailing space</span>
<a href="#l19.33"></a><span id="l19.33"> const OFFSET_SCORE_SQL_SNIPPET =</span>
<a href="#l19.34"></a><span id="l19.34">   &quot;(((length(osets) + 1) / &quot; + OFFSET_CHARS_PER_FULLTEXT_MATCH + &quot;) * &quot; +</span>
<a href="#l19.35"></a><span id="l19.35">   SCORE_FOR_FULLTEXT_MATCH + &quot;)&quot;;</span>
<a href="#l19.36"></a><span id="l19.36"> </span>
<a href="#l19.37"></a><span id="l19.37" class="difflineat">@@ -312,12 +327,11 @@ var tests = [</span>
<a href="#l19.38"></a><span id="l19.38">   setup_test_noun_and_attributes,</span>
<a href="#l19.39"></a><span id="l19.39">   test_lots_of_string_constraints,</span>
<a href="#l19.40"></a><span id="l19.40">   setup_search_ranking_idiom,</span>
<a href="#l19.41"></a><span id="l19.41">   test_search_ranking_idiom_offsets,</span>
<a href="#l19.42"></a><span id="l19.42">   test_search_ranking_idiom_score,</span>
<a href="#l19.43"></a><span id="l19.43"> ];</span>
<a href="#l19.44"></a><span id="l19.44"> </span>
<a href="#l19.45"></a><span id="l19.45"> function run_test() {</span>
<a href="#l19.46"></a><span id="l19.46" class="difflineminus">-  // use mbox injection so we get multiple folders...</span>
<a href="#l19.47"></a><span id="l19.47" class="difflineminus">-  injectMessagesUsing(INJECT_MBOX);</span>
<a href="#l19.48"></a><span id="l19.48" class="difflineminus">-  glodaHelperRunTests(tests);</span>
<a href="#l19.49"></a><span id="l19.49" class="difflineplus">+  // Don't initialize the index message state</span>
<a href="#l19.50"></a><span id="l19.50" class="difflineplus">+  glodaHelperRunTests(tests, null, true);</span>
<a href="#l19.51"></a><span id="l19.51"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_query_messages.js</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_query_messages.js</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -17,16 +17,22 @@</span>
<a href="#l20.4"></a><span id="l20.4"> </span>
<a href="#l20.5"></a><span id="l20.5"> load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l20.6"></a><span id="l20.6"> load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l20.7"></a><span id="l20.7"> </span>
<a href="#l20.8"></a><span id="l20.8"> // Create a message generator</span>
<a href="#l20.9"></a><span id="l20.9"> var msgGen = new MessageGenerator();</span>
<a href="#l20.10"></a><span id="l20.10"> // Create a message scenario generator using that message generator</span>
<a href="#l20.11"></a><span id="l20.11"> var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineplus">+// Whether we're using a single folder to test. We need to skip a few tests if</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+// we're doing so</span>
<a href="#l20.14"></a><span id="l20.14" class="difflineplus">+var singleFolder = false;</span>
<a href="#l20.15"></a><span id="l20.15" class="difflineplus">+// Whether we expect fulltext results. IMAP folders that are offline shouldn't</span>
<a href="#l20.16"></a><span id="l20.16" class="difflineplus">+// have their bodies indexed.</span>
<a href="#l20.17"></a><span id="l20.17" class="difflineplus">+var expectFulltextResults = true;</span>
<a href="#l20.18"></a><span id="l20.18"> </span>
<a href="#l20.19"></a><span id="l20.19"> /* ===== Populate ===== */</span>
<a href="#l20.20"></a><span id="l20.20"> var world = {</span>
<a href="#l20.21"></a><span id="l20.21">   phase: 0,</span>
<a href="#l20.22"></a><span id="l20.22"> </span>
<a href="#l20.23"></a><span id="l20.23">   // a list of tuples of [name, email] of length NUM_AUTHORS</span>
<a href="#l20.24"></a><span id="l20.24">   peoples: null,</span>
<a href="#l20.25"></a><span id="l20.25">   NUM_AUTHORS: 5,</span>
<a href="#l20.26"></a><span id="l20.26" class="difflineat">@@ -196,38 +202,56 @@ function generateFolderMessages() {</span>
<a href="#l20.27"></a><span id="l20.27"> function glodaInfoStasher(aSynthMessage, aGlodaMessage) {</span>
<a href="#l20.28"></a><span id="l20.28">   if (aSynthMessage.iConvo !== undefined)</span>
<a href="#l20.29"></a><span id="l20.29">     world.glodaConversationIds[aSynthMessage.iConvo] =</span>
<a href="#l20.30"></a><span id="l20.30">       aGlodaMessage.conversation.id;</span>
<a href="#l20.31"></a><span id="l20.31">   if (world.glodaFolders.length &lt;= world.phase)</span>
<a href="#l20.32"></a><span id="l20.32">     world.glodaFolders.push(aGlodaMessage.folder);</span>
<a href="#l20.33"></a><span id="l20.33"> }</span>
<a href="#l20.34"></a><span id="l20.34"> </span>
<a href="#l20.35"></a><span id="l20.35" class="difflineplus">+// We override these for the IMAP tests</span>
<a href="#l20.36"></a><span id="l20.36" class="difflineplus">+var pre_setup_populate_hook = function default_pre_setup_populate_hook() {</span>
<a href="#l20.37"></a><span id="l20.37" class="difflineplus">+  next_test();</span>
<a href="#l20.38"></a><span id="l20.38" class="difflineplus">+};</span>
<a href="#l20.39"></a><span id="l20.39" class="difflineplus">+var post_setup_populate_hook = function default_post_setup_populate_hook() {</span>
<a href="#l20.40"></a><span id="l20.40" class="difflineplus">+  next_test();</span>
<a href="#l20.41"></a><span id="l20.41" class="difflineplus">+};</span>
<a href="#l20.42"></a><span id="l20.42" class="difflineplus">+</span>
<a href="#l20.43"></a><span id="l20.43" class="difflineplus">+var gSynMessages = [];</span>
<a href="#l20.44"></a><span id="l20.44"> // first, we must populate our message store with delicious messages.</span>
<a href="#l20.45"></a><span id="l20.45"> function setup_populate() {</span>
<a href="#l20.46"></a><span id="l20.46">   world.glodaHolderCollection = Gloda.explicitCollection(Gloda.NOUN_MESSAGE,</span>
<a href="#l20.47"></a><span id="l20.47">     []);</span>
<a href="#l20.48"></a><span id="l20.48"> </span>
<a href="#l20.49"></a><span id="l20.49">   world.peoples = msgGen.makeNamesAndAddresses(world.NUM_AUTHORS);</span>
<a href="#l20.50"></a><span id="l20.50">   world.outlierAuthor = msgGen.makeNameAndAddress();</span>
<a href="#l20.51"></a><span id="l20.51">   world.outlierFriend = msgGen.makeNameAndAddress();</span>
<a href="#l20.52"></a><span id="l20.52">   // set up the per-conversation values with blanks initially</span>
<a href="#l20.53"></a><span id="l20.53">   for (let iConvo = 0; iConvo &lt; world.NUM_CONVERSATIONS; iConvo++) {</span>
<a href="#l20.54"></a><span id="l20.54">     world.lastMessagesInConvos.push(null);</span>
<a href="#l20.55"></a><span id="l20.55">     world.conversationLists.push([]);</span>
<a href="#l20.56"></a><span id="l20.56">     world.glodaConversationIds.push(null);</span>
<a href="#l20.57"></a><span id="l20.57">   }</span>
<a href="#l20.58"></a><span id="l20.58"> </span>
<a href="#l20.59"></a><span id="l20.59" class="difflineminus">-  indexMessages(generateFolderMessages(), glodaInfoStasher,</span>
<a href="#l20.60"></a><span id="l20.60" class="difflineminus">-                setup_populate_phase_two);</span>
<a href="#l20.61"></a><span id="l20.61" class="difflineplus">+  let messages = generateFolderMessages();</span>
<a href="#l20.62"></a><span id="l20.62" class="difflineplus">+  gSynMessages = gSynMessages.concat(messages);</span>
<a href="#l20.63"></a><span id="l20.63" class="difflineplus">+  indexMessages(messages, glodaInfoStasher, setup_populate_phase_two);</span>
<a href="#l20.64"></a><span id="l20.64"> }</span>
<a href="#l20.65"></a><span id="l20.65"> </span>
<a href="#l20.66"></a><span id="l20.66"> function setup_populate_phase_two() {</span>
<a href="#l20.67"></a><span id="l20.67" class="difflineminus">-  world.phase++;</span>
<a href="#l20.68"></a><span id="l20.68" class="difflineminus">-  indexMessages(generateFolderMessages(), glodaInfoStasher, next_test);</span>
<a href="#l20.69"></a><span id="l20.69" class="difflineplus">+  // If we have one folder, we don't attempt to populate the other one</span>
<a href="#l20.70"></a><span id="l20.70" class="difflineplus">+  if (singleFolder) {</span>
<a href="#l20.71"></a><span id="l20.71" class="difflineplus">+    next_test();</span>
<a href="#l20.72"></a><span id="l20.72" class="difflineplus">+  }</span>
<a href="#l20.73"></a><span id="l20.73" class="difflineplus">+  else {</span>
<a href="#l20.74"></a><span id="l20.74" class="difflineplus">+    world.phase++;</span>
<a href="#l20.75"></a><span id="l20.75" class="difflineplus">+    let messages = generateFolderMessages();</span>
<a href="#l20.76"></a><span id="l20.76" class="difflineplus">+    gSynMessages = gSynMessages.concat(messages);</span>
<a href="#l20.77"></a><span id="l20.77" class="difflineplus">+    indexMessages(messages, glodaInfoStasher, next_test);</span>
<a href="#l20.78"></a><span id="l20.78" class="difflineplus">+  }</span>
<a href="#l20.79"></a><span id="l20.79"> }</span>
<a href="#l20.80"></a><span id="l20.80"> </span>
<a href="#l20.81"></a><span id="l20.81"> /* ===== Non-text queries ===== */</span>
<a href="#l20.82"></a><span id="l20.82"> </span>
<a href="#l20.83"></a><span id="l20.83"> /* === messages === */</span>
<a href="#l20.84"></a><span id="l20.84"> </span>
<a href="#l20.85"></a><span id="l20.85"> /**</span>
<a href="#l20.86"></a><span id="l20.86">  * Takes a list of mutually exclusive queries and a list of the resulting</span>
<a href="#l20.87"></a><span id="l20.87" class="difflineat">@@ -289,30 +313,38 @@ function test_query_messages_by_conversa</span>
<a href="#l20.88"></a><span id="l20.88"> var ts_folderNum = 0;</span>
<a href="#l20.89"></a><span id="l20.89"> var ts_folderQueries = [];</span>
<a href="#l20.90"></a><span id="l20.90"> var ts_folderCollections = [];</span>
<a href="#l20.91"></a><span id="l20.91"> /**</span>
<a href="#l20.92"></a><span id="l20.92">  * @tests gloda.noun.message.attr.folder</span>
<a href="#l20.93"></a><span id="l20.93">  * @tests gloda.datastore.sqlgen.kConstraintIn</span>
<a href="#l20.94"></a><span id="l20.94">  */</span>
<a href="#l20.95"></a><span id="l20.95"> function test_query_messages_by_folder() {</span>
<a href="#l20.96"></a><span id="l20.96" class="difflineplus">+  // If we have one folder to test with, we can't do this test more times</span>
<a href="#l20.97"></a><span id="l20.97" class="difflineplus">+  if (singleFolder &amp;&amp; ts_folderNum &gt;= 1) {</span>
<a href="#l20.98"></a><span id="l20.98" class="difflineplus">+    next_test();</span>
<a href="#l20.99"></a><span id="l20.99" class="difflineplus">+    return;</span>
<a href="#l20.100"></a><span id="l20.100" class="difflineplus">+  }</span>
<a href="#l20.101"></a><span id="l20.101" class="difflineplus">+</span>
<a href="#l20.102"></a><span id="l20.102">   let folderNum = ts_folderNum++;</span>
<a href="#l20.103"></a><span id="l20.103">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l20.104"></a><span id="l20.104">   query.folder(world.glodaFolders[folderNum]);</span>
<a href="#l20.105"></a><span id="l20.105"> </span>
<a href="#l20.106"></a><span id="l20.106">   ts_folderQueries.push(query);</span>
<a href="#l20.107"></a><span id="l20.107">   ts_folderCollections.push(queryExpect(query, world.folderClumps[folderNum]));</span>
<a href="#l20.108"></a><span id="l20.108">   // queryExpect calls next_test</span>
<a href="#l20.109"></a><span id="l20.109"> }</span>
<a href="#l20.110"></a><span id="l20.110"> </span>
<a href="#l20.111"></a><span id="l20.111"> /**</span>
<a href="#l20.112"></a><span id="l20.112">  * @tests gloda.query.test.kConstraintIn</span>
<a href="#l20.113"></a><span id="l20.113">  */</span>
<a href="#l20.114"></a><span id="l20.114"> function test_query_messages_by_folder_nonmatches() {</span>
<a href="#l20.115"></a><span id="l20.115" class="difflineminus">-  verify_nonMatches(ts_folderQueries, ts_folderCollections);</span>
<a href="#l20.116"></a><span id="l20.116" class="difflineplus">+  // No can do with one folder</span>
<a href="#l20.117"></a><span id="l20.117" class="difflineplus">+  if (!singleFolder)</span>
<a href="#l20.118"></a><span id="l20.118" class="difflineplus">+    verify_nonMatches(ts_folderQueries, ts_folderCollections);</span>
<a href="#l20.119"></a><span id="l20.119">   next_test();</span>
<a href="#l20.120"></a><span id="l20.120"> }</span>
<a href="#l20.121"></a><span id="l20.121"> </span>
<a href="#l20.122"></a><span id="l20.122"> /**</span>
<a href="#l20.123"></a><span id="l20.123">  * @tests Gloda.ns.getMessageCollectionForHeader()</span>
<a href="#l20.124"></a><span id="l20.124">  */</span>
<a href="#l20.125"></a><span id="l20.125"> function test_get_message_for_header() {</span>
<a href="#l20.126"></a><span id="l20.126">   // pick an arbitrary message</span>
<a href="#l20.127"></a><span id="l20.127" class="difflineat">@@ -453,32 +485,34 @@ dump(&quot;convNum: &quot; + convNum + &quot; blah: &quot; +</span>
<a href="#l20.128"></a><span id="l20.128">  */</span>
<a href="#l20.129"></a><span id="l20.129"> function test_query_messages_by_body_text() {</span>
<a href="#l20.130"></a><span id="l20.130">   // we only need to use one conversation</span>
<a href="#l20.131"></a><span id="l20.131">   let convNum = 0;</span>
<a href="#l20.132"></a><span id="l20.132">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l20.133"></a><span id="l20.133">   let convBodyTerm = uniqueTermGenerator(</span>
<a href="#l20.134"></a><span id="l20.134">     UNIQUE_OFFSET_BODY + UNIQUE_OFFSET_CONV + convNum);</span>
<a href="#l20.135"></a><span id="l20.135">   query.bodyMatches(convBodyTerm);</span>
<a href="#l20.136"></a><span id="l20.136" class="difflineminus">-  queryExpect(query, world.conversationLists[convNum]); // calls next_test</span>
<a href="#l20.137"></a><span id="l20.137" class="difflineplus">+  queryExpect(query, expectFulltextResults ? world.conversationLists[convNum] :</span>
<a href="#l20.138"></a><span id="l20.138" class="difflineplus">+                                             []); // calls next_test</span>
<a href="#l20.139"></a><span id="l20.139"> }</span>
<a href="#l20.140"></a><span id="l20.140"> </span>
<a href="#l20.141"></a><span id="l20.141"> /**</span>
<a href="#l20.142"></a><span id="l20.142">  * Test attachment name searching using the conversation unique attachment term.</span>
<a href="#l20.143"></a><span id="l20.143">  *</span>
<a href="#l20.144"></a><span id="l20.144">  * @tests gloda.noun.message.attr.attachmentNamesMatch</span>
<a href="#l20.145"></a><span id="l20.145">  * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l20.146"></a><span id="l20.146">  */</span>
<a href="#l20.147"></a><span id="l20.147"> function test_query_messages_by_attachment_names() {</span>
<a href="#l20.148"></a><span id="l20.148">   let convNum = 0;</span>
<a href="#l20.149"></a><span id="l20.149">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l20.150"></a><span id="l20.150">   let convUniqueAttachment = uniqueTermGenerator(</span>
<a href="#l20.151"></a><span id="l20.151">     UNIQUE_OFFSET_ATTACHMENT + UNIQUE_OFFSET_CONV + convNum);</span>
<a href="#l20.152"></a><span id="l20.152">   query.attachmentNamesMatch(convUniqueAttachment);</span>
<a href="#l20.153"></a><span id="l20.153" class="difflineminus">-  queryExpect(query, world.conversationLists[convNum]); // calls next_test</span>
<a href="#l20.154"></a><span id="l20.154" class="difflineplus">+  queryExpect(query, expectFulltextResults ? world.conversationLists[convNum] :</span>
<a href="#l20.155"></a><span id="l20.155" class="difflineplus">+                                             []); // calls next_test</span>
<a href="#l20.156"></a><span id="l20.156"> }</span>
<a href="#l20.157"></a><span id="l20.157"> </span>
<a href="#l20.158"></a><span id="l20.158"> /**</span>
<a href="#l20.159"></a><span id="l20.159">  * Test author name fulltext searching using an arbitrary author.</span>
<a href="#l20.160"></a><span id="l20.160">  *</span>
<a href="#l20.161"></a><span id="l20.161">  * @tests gloda.noun.message.attr.authorMatches</span>
<a href="#l20.162"></a><span id="l20.162">  * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l20.163"></a><span id="l20.163">  */</span>
<a href="#l20.164"></a><span id="l20.164" class="difflineat">@@ -590,17 +624,19 @@ function test_query_identities_by_kind_a</span>
<a href="#l20.165"></a><span id="l20.165">                     [peoplesIdentityCollection, outlierIdentityCollection]);</span>
<a href="#l20.166"></a><span id="l20.166">   next_test();</span>
<a href="#l20.167"></a><span id="l20.167"> }</span>
<a href="#l20.168"></a><span id="l20.168"> </span>
<a href="#l20.169"></a><span id="l20.169"> </span>
<a href="#l20.170"></a><span id="l20.170"> /* ===== Driver ===== */</span>
<a href="#l20.171"></a><span id="l20.171"> </span>
<a href="#l20.172"></a><span id="l20.172"> var tests = [</span>
<a href="#l20.173"></a><span id="l20.173" class="difflineplus">+  function pre_setup_populate() { pre_setup_populate_hook(); },</span>
<a href="#l20.174"></a><span id="l20.174">   setup_populate,</span>
<a href="#l20.175"></a><span id="l20.175" class="difflineplus">+  function post_setup_populate() { post_setup_populate_hook(); },</span>
<a href="#l20.176"></a><span id="l20.176">   test_query_messages_by_conversation,</span>
<a href="#l20.177"></a><span id="l20.177">   test_query_messages_by_conversation,</span>
<a href="#l20.178"></a><span id="l20.178">   test_query_messages_by_conversation_nonmatches,</span>
<a href="#l20.179"></a><span id="l20.179">   test_query_messages_by_folder,</span>
<a href="#l20.180"></a><span id="l20.180">   test_query_messages_by_folder,</span>
<a href="#l20.181"></a><span id="l20.181">   test_query_messages_by_folder_nonmatches,</span>
<a href="#l20.182"></a><span id="l20.182">   test_get_message_for_header,</span>
<a href="#l20.183"></a><span id="l20.183">   test_get_messages_for_headers,</span>
<a href="#l20.184"></a><span id="l20.184" class="difflineat">@@ -624,12 +660,13 @@ var tests = [</span>
<a href="#l20.185"></a><span id="l20.185">   test_query_messages_by_recipients_name,</span>
<a href="#l20.186"></a><span id="l20.186">   test_query_messages_by_recipients_email,</span>
<a href="#l20.187"></a><span id="l20.187">   // like</span>
<a href="#l20.188"></a><span id="l20.188">   test_query_contacts_by_name,</span>
<a href="#l20.189"></a><span id="l20.189">   test_query_contacts_by_name_nonmatch</span>
<a href="#l20.190"></a><span id="l20.190"> ];</span>
<a href="#l20.191"></a><span id="l20.191"> </span>
<a href="#l20.192"></a><span id="l20.192"> function run_test() {</span>
<a href="#l20.193"></a><span id="l20.193" class="difflineminus">-  // use mbox injection so we get multiple folders...</span>
<a href="#l20.194"></a><span id="l20.194" class="difflineminus">-  injectMessagesUsing(INJECT_MBOX);</span>
<a href="#l20.195"></a><span id="l20.195">   glodaHelperRunTests(tests);</span>
<a href="#l20.196"></a><span id="l20.196"> }</span>
<a href="#l20.197"></a><span id="l20.197" class="difflineplus">+</span>
<a href="#l20.198"></a><span id="l20.198" class="difflineplus">+// use mbox injection so we get multiple folders...</span>
<a href="#l20.199"></a><span id="l20.199" class="difflineplus">+injectMessagesUsing(INJECT_MBOX);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1">new file mode 100644</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineminus">--- /dev/null</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js</span>
<a href="#l21.4"></a><span id="l21.4" class="difflineat">@@ -0,0 +1,10 @@</span>
<a href="#l21.5"></a><span id="l21.5" class="difflineplus">+/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l21.6"></a><span id="l21.6" class="difflineplus">+/**</span>
<a href="#l21.7"></a><span id="l21.7" class="difflineplus">+ * Test query support for IMAP messages that aren't offline.</span>
<a href="#l21.8"></a><span id="l21.8" class="difflineplus">+ */</span>
<a href="#l21.9"></a><span id="l21.9" class="difflineplus">+load(&quot;test_query_messages.js&quot;);</span>
<a href="#l21.10"></a><span id="l21.10" class="difflineplus">+</span>
<a href="#l21.11"></a><span id="l21.11" class="difflineplus">+var expectFulltextResults = false;</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineplus">+// TODO: Make this use multiple folders, like the local folders test</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+var singleFolder = true;</span>
<a href="#l21.14"></a><span id="l21.14" class="difflineplus">+injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1">new file mode 100644</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineminus">--- /dev/null</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js</span>
<a href="#l22.4"></a><span id="l22.4" class="difflineat">@@ -0,0 +1,16 @@</span>
<a href="#l22.5"></a><span id="l22.5" class="difflineplus">+/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l22.6"></a><span id="l22.6" class="difflineplus">+/**</span>
<a href="#l22.7"></a><span id="l22.7" class="difflineplus">+ * Test query support for IMAP messages that were offline before they were</span>
<a href="#l22.8"></a><span id="l22.8" class="difflineplus">+ * indexed.</span>
<a href="#l22.9"></a><span id="l22.9" class="difflineplus">+ */</span>
<a href="#l22.10"></a><span id="l22.10" class="difflineplus">+load(&quot;test_query_messages.js&quot;);</span>
<a href="#l22.11"></a><span id="l22.11" class="difflineplus">+</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineplus">+// Set the inbox to offline before proceeding</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+var pre_setup_populate_hook = function imap_pre_setup_populate_hook() {</span>
<a href="#l22.14"></a><span id="l22.14" class="difflineplus">+  indexMessageState.imapInbox.setFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l22.15"></a><span id="l22.15" class="difflineplus">+  next_test();</span>
<a href="#l22.16"></a><span id="l22.16" class="difflineplus">+};</span>
<a href="#l22.17"></a><span id="l22.17" class="difflineplus">+</span>
<a href="#l22.18"></a><span id="l22.18" class="difflineplus">+// TODO: Make this use multiple folders, like the local folders test</span>
<a href="#l22.19"></a><span id="l22.19" class="difflineplus">+var singleFolder = true;</span>
<a href="#l22.20"></a><span id="l22.20" class="difflineplus">+injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1">new file mode 100644</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineminus">--- /dev/null</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js</span>
<a href="#l23.4"></a><span id="l23.4" class="difflineat">@@ -0,0 +1,19 @@</span>
<a href="#l23.5"></a><span id="l23.5" class="difflineplus">+/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l23.6"></a><span id="l23.6" class="difflineplus">+/**</span>
<a href="#l23.7"></a><span id="l23.7" class="difflineplus">+ * Test query support for IMAP messages that were indexed, then made available</span>
<a href="#l23.8"></a><span id="l23.8" class="difflineplus">+ * offline.</span>
<a href="#l23.9"></a><span id="l23.9" class="difflineplus">+ */</span>
<a href="#l23.10"></a><span id="l23.10" class="difflineplus">+load(&quot;test_query_messages.js&quot;);</span>
<a href="#l23.11"></a><span id="l23.11" class="difflineplus">+</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineplus">+/**</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+ * Set the imap folder to offline after adding the messages, then force a</span>
<a href="#l23.14"></a><span id="l23.14" class="difflineplus">+ * download of all messages.</span>
<a href="#l23.15"></a><span id="l23.15" class="difflineplus">+ */</span>
<a href="#l23.16"></a><span id="l23.16" class="difflineplus">+var post_setup_populate_hook = function imap_post_setup_populate_hook() {</span>
<a href="#l23.17"></a><span id="l23.17" class="difflineplus">+  imapDownloadAllMessages(indexMessageState.imapInbox, gSynMessages, null,</span>
<a href="#l23.18"></a><span id="l23.18" class="difflineplus">+                          next_test);</span>
<a href="#l23.19"></a><span id="l23.19" class="difflineplus">+};</span>
<a href="#l23.20"></a><span id="l23.20" class="difflineplus">+</span>
<a href="#l23.21"></a><span id="l23.21" class="difflineplus">+// TODO: Make this use multiple folders, like the local folders test</span>
<a href="#l23.22"></a><span id="l23.22" class="difflineplus">+var singleFolder = true;</span>
<a href="#l23.23"></a><span id="l23.23" class="difflineplus">+injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/mailnews/test/fakeserver/maild.js</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/mailnews/test/fakeserver/maild.js</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -34,16 +34,21 @@</span>
<a href="#l24.4"></a><span id="l24.4">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l24.5"></a><span id="l24.5">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l24.6"></a><span id="l24.6">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l24.7"></a><span id="l24.7">  *</span>
<a href="#l24.8"></a><span id="l24.8">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l24.9"></a><span id="l24.9"> </span>
<a href="#l24.10"></a><span id="l24.10"> // Much of the original code is taken from netwerk's httpserver implementation</span>
<a href="#l24.11"></a><span id="l24.11"> </span>
<a href="#l24.12"></a><span id="l24.12" class="difflineplus">+// Make sure we execute this file exactly once</span>
<a href="#l24.13"></a><span id="l24.13" class="difflineplus">+var gMaild_js__;</span>
<a href="#l24.14"></a><span id="l24.14" class="difflineplus">+if (!gMaild_js__) {</span>
<a href="#l24.15"></a><span id="l24.15" class="difflineplus">+gMaild_js__ = true;</span>
<a href="#l24.16"></a><span id="l24.16" class="difflineplus">+</span>
<a href="#l24.17"></a><span id="l24.17"> var Cc = Components.classes;</span>
<a href="#l24.18"></a><span id="l24.18"> var Ci = Components.interfaces;</span>
<a href="#l24.19"></a><span id="l24.19"> var Cr = Components.results;</span>
<a href="#l24.20"></a><span id="l24.20"> var CC = Components.Constructor;</span>
<a href="#l24.21"></a><span id="l24.21"> </span>
<a href="#l24.22"></a><span id="l24.22"> /** The XPCOM thread manager. */</span>
<a href="#l24.23"></a><span id="l24.23"> var gThreadManager = null;</span>
<a href="#l24.24"></a><span id="l24.24"> </span>
<a href="#l24.25"></a><span id="l24.25" class="difflineat">@@ -115,26 +120,33 @@ function nsMailServer(handler) {</span>
<a href="#l24.26"></a><span id="l24.26">    * True if the socket in this is closed (and closure notifications have been</span>
<a href="#l24.27"></a><span id="l24.27">    * sent and processed if the socket was ever opened), false otherwise.</span>
<a href="#l24.28"></a><span id="l24.28">    */</span>
<a href="#l24.29"></a><span id="l24.29">   this._socketClosed = true;</span>
<a href="#l24.30"></a><span id="l24.30"> </span>
<a href="#l24.31"></a><span id="l24.31">   this._handler = handler;</span>
<a href="#l24.32"></a><span id="l24.32">   this._readers = [];</span>
<a href="#l24.33"></a><span id="l24.33">   this._test = false;</span>
<a href="#l24.34"></a><span id="l24.34" class="difflineplus">+</span>
<a href="#l24.35"></a><span id="l24.35" class="difflineplus">+  /**</span>
<a href="#l24.36"></a><span id="l24.36" class="difflineplus">+   * An array to hold refs to all the input streams below, so that they don't</span>
<a href="#l24.37"></a><span id="l24.37" class="difflineplus">+   * get GCed</span>
<a href="#l24.38"></a><span id="l24.38" class="difflineplus">+   */</span>
<a href="#l24.39"></a><span id="l24.39" class="difflineplus">+  this._inputStreams = [];</span>
<a href="#l24.40"></a><span id="l24.40"> }</span>
<a href="#l24.41"></a><span id="l24.41"> nsMailServer.prototype = {</span>
<a href="#l24.42"></a><span id="l24.42">   onSocketAccepted : function (socket, trans) {</span>
<a href="#l24.43"></a><span id="l24.43">     if (this._debug != fsDebugNone)</span>
<a href="#l24.44"></a><span id="l24.44">       print(&quot;Received Connection from &quot; + trans.host + &quot;:&quot; + trans.port);</span>
<a href="#l24.45"></a><span id="l24.45"> </span>
<a href="#l24.46"></a><span id="l24.46">     const SEGMENT_SIZE = 1024;</span>
<a href="#l24.47"></a><span id="l24.47">     const SEGMENT_COUNT = 1024;</span>
<a href="#l24.48"></a><span id="l24.48">     var input = trans.openInputStream(0, SEGMENT_SIZE, SEGMENT_COUNT)</span>
<a href="#l24.49"></a><span id="l24.49">                      .QueryInterface(Ci.nsIAsyncInputStream);</span>
<a href="#l24.50"></a><span id="l24.50" class="difflineplus">+    this._inputStreams.push(input);</span>
<a href="#l24.51"></a><span id="l24.51"> </span>
<a href="#l24.52"></a><span id="l24.52">     var reader = new nsMailReader(this, this._handler, trans, this._debug);</span>
<a href="#l24.53"></a><span id="l24.53">     this._readers.push(reader);</span>
<a href="#l24.54"></a><span id="l24.54"> </span>
<a href="#l24.55"></a><span id="l24.55">     // Note: must use main thread here, or we might get a GC that will cause</span>
<a href="#l24.56"></a><span id="l24.56">     //       threadsafety assertions.  We really need to fix XPConnect so that</span>
<a href="#l24.57"></a><span id="l24.57">     //       you can actually do things in multi-threaded JS.  :-(</span>
<a href="#l24.58"></a><span id="l24.58">     input.asyncWait(reader, 0, 0, gThreadManager.mainThread);</span>
<a href="#l24.59"></a><span id="l24.59" class="difflineat">@@ -521,8 +533,10 @@ nsMailReader.prototype = {</span>
<a href="#l24.60"></a><span id="l24.60">  *   use on the server</span>
<a href="#l24.61"></a><span id="l24.61">  */</span>
<a href="#l24.62"></a><span id="l24.62"> function server(port, handler) {</span>
<a href="#l24.63"></a><span id="l24.63">   var srv = new nsMailServer(handler);</span>
<a href="#l24.64"></a><span id="l24.64">   srv.start(port);</span>
<a href="#l24.65"></a><span id="l24.65">   srv.performTest();</span>
<a href="#l24.66"></a><span id="l24.66">   return srv.playTransaction();</span>
<a href="#l24.67"></a><span id="l24.67"> }</span>
<a href="#l24.68"></a><span id="l24.68" class="difflineplus">+</span>
<a href="#l24.69"></a><span id="l24.69" class="difflineplus">+} // gMaild_js__</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/mailnews/test/resources/mailDirService.js</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/mailnews/test/resources/mailDirService.js</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -4,16 +4,21 @@</span>
<a href="#l25.4"></a><span id="l25.4">  * directory under the process directory and use that as the profile</span>
<a href="#l25.5"></a><span id="l25.5">  * directory for the mailnews tests to locate files during unit tests.</span>
<a href="#l25.6"></a><span id="l25.6">  *</span>
<a href="#l25.7"></a><span id="l25.7">  * For xpcshell tests, the &quot;profile&quot; directory will be:</span>
<a href="#l25.8"></a><span id="l25.8">  * &lt;objdir&gt;/dist/bin/mailtest/  (on Windows and Linux)</span>
<a href="#l25.9"></a><span id="l25.9">  * &lt;objdir&gt;/dist/Thunderbird{Debug}.app/Contents/MacOS/mailtest/  (on Mac OS X)</span>
<a href="#l25.10"></a><span id="l25.10">  */</span>
<a href="#l25.11"></a><span id="l25.11"> </span>
<a href="#l25.12"></a><span id="l25.12" class="difflineplus">+// Make sure we execute this file exactly once</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineplus">+var gMailDirService_js__;</span>
<a href="#l25.14"></a><span id="l25.14" class="difflineplus">+if (!gMailDirService_js__) {</span>
<a href="#l25.15"></a><span id="l25.15" class="difflineplus">+gMailDirService_js__ = true;</span>
<a href="#l25.16"></a><span id="l25.16" class="difflineplus">+</span>
<a href="#l25.17"></a><span id="l25.17"> Components.utils.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l25.18"></a><span id="l25.18"> </span>
<a href="#l25.19"></a><span id="l25.19"> // Declare these globally for unit tests and be done with it.</span>
<a href="#l25.20"></a><span id="l25.20"> var Cc = Components.classes;</span>
<a href="#l25.21"></a><span id="l25.21"> var Ci = Components.interfaces;</span>
<a href="#l25.22"></a><span id="l25.22"> var Cr = Components.results;</span>
<a href="#l25.23"></a><span id="l25.23"> var CC = Components.Constructor;</span>
<a href="#l25.24"></a><span id="l25.24"> </span>
<a href="#l25.25"></a><span id="l25.25" class="difflineat">@@ -128,8 +133,10 @@ catch (e) {</span>
<a href="#l25.26"></a><span id="l25.26">   if (gProfileDir.exists())</span>
<a href="#l25.27"></a><span id="l25.27">     gProfileDir.remove(true);</span>
<a href="#l25.28"></a><span id="l25.28"> </span>
<a href="#l25.29"></a><span id="l25.29">   // This throw is so that we know if this bug happens</span>
<a href="#l25.30"></a><span id="l25.30">   throw Cr.NS_ERROR_FAILURE;</span>
<a href="#l25.31"></a><span id="l25.31"> }</span>
<a href="#l25.32"></a><span id="l25.32"> // Always ensure the profile directory exists before we start the tests</span>
<a href="#l25.33"></a><span id="l25.33"> gProfileDir.create(Ci.nsIFile.DIRECTORY_TYPE, 0700);</span>
<a href="#l25.34"></a><span id="l25.34" class="difflineplus">+</span>
<a href="#l25.35"></a><span id="l25.35" class="difflineplus">+} // gMailDirService_js__</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/mailnews/test/resources/mailTestUtils.js</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/mailnews/test/resources/mailTestUtils.js</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -30,16 +30,21 @@</span>
<a href="#l26.4"></a><span id="l26.4">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l26.5"></a><span id="l26.5">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l26.6"></a><span id="l26.6">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l26.7"></a><span id="l26.7">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l26.8"></a><span id="l26.8">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l26.9"></a><span id="l26.9">  *</span>
<a href="#l26.10"></a><span id="l26.10">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l26.11"></a><span id="l26.11"> </span>
<a href="#l26.12"></a><span id="l26.12" class="difflineplus">+// Make sure we execute this file exactly once</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineplus">+var gMailTestUtils_js__;</span>
<a href="#l26.14"></a><span id="l26.14" class="difflineplus">+if (!gMailTestUtils_js__) {</span>
<a href="#l26.15"></a><span id="l26.15" class="difflineplus">+gMailTestUtils_js__ = true;</span>
<a href="#l26.16"></a><span id="l26.16" class="difflineplus">+</span>
<a href="#l26.17"></a><span id="l26.17"> // we would like for everyone to have fixIterator and toXPComArray</span>
<a href="#l26.18"></a><span id="l26.18"> Components.utils.import(&quot;resource://gre/modules/iteratorUtils.jsm&quot;);</span>
<a href="#l26.19"></a><span id="l26.19"> </span>
<a href="#l26.20"></a><span id="l26.20"> // Local Mail Folders. Requires prior setup of profile directory</span>
<a href="#l26.21"></a><span id="l26.21"> </span>
<a href="#l26.22"></a><span id="l26.22"> var gLocalIncomingServer;</span>
<a href="#l26.23"></a><span id="l26.23"> var gLocalInboxFolder;</span>
<a href="#l26.24"></a><span id="l26.24"> </span>
<a href="#l26.25"></a><span id="l26.25" class="difflineat">@@ -270,8 +275,10 @@ function updateFolderAndNotify(aFolder, </span>
<a href="#l26.26"></a><span id="l26.26">       }</span>
<a href="#l26.27"></a><span id="l26.27">     }</span>
<a href="#l26.28"></a><span id="l26.28">   };</span>
<a href="#l26.29"></a><span id="l26.29"> </span>
<a href="#l26.30"></a><span id="l26.30">   mailSession.AddFolderListener(folderListener, Ci.nsIFolderListener.event);</span>
<a href="#l26.31"></a><span id="l26.31"> </span>
<a href="#l26.32"></a><span id="l26.32">   aFolder.updateFolder(null);</span>
<a href="#l26.33"></a><span id="l26.33"> }</span>
<a href="#l26.34"></a><span id="l26.34" class="difflineplus">+</span>
<a href="#l26.35"></a><span id="l26.35" class="difflineplus">+} // gMailTestUtils_js__</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

