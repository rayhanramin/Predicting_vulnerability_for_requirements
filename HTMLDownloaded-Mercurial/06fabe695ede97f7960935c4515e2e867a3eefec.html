<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 974:06fabe695ede97f7960935c4515e2e867a3eefec</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 06fabe695ede97f7960935c4515e2e867a3eefec" />
<meta property="og:url" content="/comm-central/rev/06fabe695ede97f7960935c4515e2e867a3eefec" />
<meta property="og:description" content="status commit for the massive refactoring as described at the status meeting," />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 06fabe695ede97f7960935c4515e2e867a3eefec 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/06fabe695ede97f7960935c4515e2e867a3eefec">shortlog</a> |
<a href="/comm-central/log/06fabe695ede97f7960935c4515e2e867a3eefec">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/06fabe695ede97f7960935c4515e2e867a3eefec">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/06fabe695ede97f7960935c4515e2e867a3eefec">files</a> |
changeset |
<a href="/comm-central/raw-rev/06fabe695ede97f7960935c4515e2e867a3eefec">raw</a>  | <a href="/comm-central/archive/06fabe695ede97f7960935c4515e2e867a3eefec.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
status commit for the massive refactoring as described at the status meeting,
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Tue, 14 Oct 2008 23:57:28 -0700</td></tr>

<tr>
 <td>changeset 974</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/06fabe695ede97f7960935c4515e2e867a3eefec">06fabe695ede97f7960935c4515e2e867a3eefec</a></td>
</tr>



<tr>
<td>parent 970</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/2c5e2d260836f0789d3f10bb6a297694086305b4">2c5e2d260836f0789d3f10bb6a297694086305b4</a>
</td>
</tr>

<tr>
<td>child 975</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/d8efe76d7bf37411412cb0d654e377d36f67253b">d8efe76d7bf37411412cb0d654e377d36f67253b</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=06fabe695ede97f7960935c4515e2e867a3eefec">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">status commit for the massive refactoring as described at the status meeting,
roughly circa the status meeting.
https://wiki.mozilla.org/Thunderbird/StatusMeetings/2008-10-14#asuth</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/components/glautocomp.js">components/glautocomp.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/06fabe695ede97f7960935c4515e2e867a3eefec/components/glautocomp.js">file</a> |
<a href="/comm-central/annotate/06fabe695ede97f7960935c4515e2e867a3eefec/components/glautocomp.js">annotate</a> |
<a href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/components/glautocomp.js">diff</a> |
<a href="/comm-central/comparison/06fabe695ede97f7960935c4515e2e867a3eefec/components/glautocomp.js">comparison</a> |
<a href="/comm-central/log/06fabe695ede97f7960935c4515e2e867a3eefec/components/glautocomp.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/collection.js">modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/06fabe695ede97f7960935c4515e2e867a3eefec/modules/collection.js">file</a> |
<a href="/comm-central/annotate/06fabe695ede97f7960935c4515e2e867a3eefec/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/06fabe695ede97f7960935c4515e2e867a3eefec/modules/collection.js">comparison</a> |
<a href="/comm-central/log/06fabe695ede97f7960935c4515e2e867a3eefec/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/datamodel.js">modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/06fabe695ede97f7960935c4515e2e867a3eefec/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/06fabe695ede97f7960935c4515e2e867a3eefec/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/06fabe695ede97f7960935c4515e2e867a3eefec/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/06fabe695ede97f7960935c4515e2e867a3eefec/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/06fabe695ede97f7960935c4515e2e867a3eefec/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/06fabe695ede97f7960935c4515e2e867a3eefec/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/06fabe695ede97f7960935c4515e2e867a3eefec/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/06fabe695ede97f7960935c4515e2e867a3eefec/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/explattr.js">modules/explattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/06fabe695ede97f7960935c4515e2e867a3eefec/modules/explattr.js">file</a> |
<a href="/comm-central/annotate/06fabe695ede97f7960935c4515e2e867a3eefec/modules/explattr.js">annotate</a> |
<a href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/explattr.js">diff</a> |
<a href="/comm-central/comparison/06fabe695ede97f7960935c4515e2e867a3eefec/modules/explattr.js">comparison</a> |
<a href="/comm-central/log/06fabe695ede97f7960935c4515e2e867a3eefec/modules/explattr.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/fundattr.js">modules/fundattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/06fabe695ede97f7960935c4515e2e867a3eefec/modules/fundattr.js">file</a> |
<a href="/comm-central/annotate/06fabe695ede97f7960935c4515e2e867a3eefec/modules/fundattr.js">annotate</a> |
<a href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/fundattr.js">diff</a> |
<a href="/comm-central/comparison/06fabe695ede97f7960935c4515e2e867a3eefec/modules/fundattr.js">comparison</a> |
<a href="/comm-central/log/06fabe695ede97f7960935c4515e2e867a3eefec/modules/fundattr.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/06fabe695ede97f7960935c4515e2e867a3eefec/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/06fabe695ede97f7960935c4515e2e867a3eefec/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/06fabe695ede97f7960935c4515e2e867a3eefec/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/06fabe695ede97f7960935c4515e2e867a3eefec/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/index_ab.js">modules/index_ab.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/06fabe695ede97f7960935c4515e2e867a3eefec/modules/index_ab.js">file</a> |
<a href="/comm-central/annotate/06fabe695ede97f7960935c4515e2e867a3eefec/modules/index_ab.js">annotate</a> |
<a href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/index_ab.js">diff</a> |
<a href="/comm-central/comparison/06fabe695ede97f7960935c4515e2e867a3eefec/modules/index_ab.js">comparison</a> |
<a href="/comm-central/log/06fabe695ede97f7960935c4515e2e867a3eefec/modules/index_ab.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/indexer.js">modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/06fabe695ede97f7960935c4515e2e867a3eefec/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/06fabe695ede97f7960935c4515e2e867a3eefec/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/06fabe695ede97f7960935c4515e2e867a3eefec/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/06fabe695ede97f7960935c4515e2e867a3eefec/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/noun_freetag.js">modules/noun_freetag.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/06fabe695ede97f7960935c4515e2e867a3eefec/modules/noun_freetag.js">file</a> |
<a href="/comm-central/annotate/06fabe695ede97f7960935c4515e2e867a3eefec/modules/noun_freetag.js">annotate</a> |
<a href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/noun_freetag.js">diff</a> |
<a href="/comm-central/comparison/06fabe695ede97f7960935c4515e2e867a3eefec/modules/noun_freetag.js">comparison</a> |
<a href="/comm-central/log/06fabe695ede97f7960935c4515e2e867a3eefec/modules/noun_freetag.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/noun_tag.js">modules/noun_tag.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/06fabe695ede97f7960935c4515e2e867a3eefec/modules/noun_tag.js">file</a> |
<a href="/comm-central/annotate/06fabe695ede97f7960935c4515e2e867a3eefec/modules/noun_tag.js">annotate</a> |
<a href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/noun_tag.js">diff</a> |
<a href="/comm-central/comparison/06fabe695ede97f7960935c4515e2e867a3eefec/modules/noun_tag.js">comparison</a> |
<a href="/comm-central/log/06fabe695ede97f7960935c4515e2e867a3eefec/modules/noun_tag.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/query.js">modules/query.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/06fabe695ede97f7960935c4515e2e867a3eefec/modules/query.js">file</a> |
<a href="/comm-central/annotate/06fabe695ede97f7960935c4515e2e867a3eefec/modules/query.js">annotate</a> |
<a href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/query.js">diff</a> |
<a href="/comm-central/comparison/06fabe695ede97f7960935c4515e2e867a3eefec/modules/query.js">comparison</a> |
<a href="/comm-central/log/06fabe695ede97f7960935c4515e2e867a3eefec/modules/query.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/utils.js">modules/utils.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/06fabe695ede97f7960935c4515e2e867a3eefec/modules/utils.js">file</a> |
<a href="/comm-central/annotate/06fabe695ede97f7960935c4515e2e867a3eefec/modules/utils.js">annotate</a> |
<a href="/comm-central/diff/06fabe695ede97f7960935c4515e2e867a3eefec/modules/utils.js">diff</a> |
<a href="/comm-central/comparison/06fabe695ede97f7960935c4515e2e867a3eefec/modules/utils.js">comparison</a> |
<a href="/comm-central/log/06fabe695ede97f7960935c4515e2e867a3eefec/modules/utils.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/components/glautocomp.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/components/glautocomp.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -172,46 +172,42 @@ nsAutoCompleteGlodaResult.prototype = {</span>
<a href="#l1.4"></a><span id="l1.4">     return gravURL;</span>
<a href="#l1.5"></a><span id="l1.5">   },</span>
<a href="#l1.6"></a><span id="l1.6">   removeValueAt: function() {},</span>
<a href="#l1.7"></a><span id="l1.7"> </span>
<a href="#l1.8"></a><span id="l1.8">   _stop: function() {</span>
<a href="#l1.9"></a><span id="l1.9">   },</span>
<a href="#l1.10"></a><span id="l1.10"> };</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+const MAX_POPULAR_CONTACTS = 200;</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+</span>
<a href="#l1.14"></a><span id="l1.14"> /**</span>
<a href="#l1.15"></a><span id="l1.15">  * Complete contacts/identities based on name/email.  Instant phase is based on</span>
<a href="#l1.16"></a><span id="l1.16">  *  a suffix-tree built of popular contacts/identities.  Delayed phase relies</span>
<a href="#l1.17"></a><span id="l1.17">  *  on a LIKE search of all known contacts.</span>
<a href="#l1.18"></a><span id="l1.18">  */</span>
<a href="#l1.19"></a><span id="l1.19"> function ContactIdentityCompleter() {</span>
<a href="#l1.20"></a><span id="l1.20">   // get all the contacts</span>
<a href="#l1.21"></a><span id="l1.21">   let contactQuery = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineminus">-  this.contactCollection = contactQuery.popularityRange(10, null).getAllSync();</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineplus">+  contactQuery.orderBy(&quot;-popularity&quot;).limit(MAX_POPULAR_CONTACTS);</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineplus">+  this.contactCollection = contactQuery.getAllSync();</span>
<a href="#l1.25"></a><span id="l1.25"> </span>
<a href="#l1.26"></a><span id="l1.26">   // cheat and explicitly add our own contact...</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineminus">-  this.contactCollection._onItemsAdded([Gloda.myContact]);</span>
<a href="#l1.28"></a><span id="l1.28" class="difflineminus">-</span>
<a href="#l1.29"></a><span id="l1.29" class="difflineminus">-  // assuming we found some contacts...</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineminus">-  if (this.contactCollection.items.length) {</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineminus">-    // get all the identities...</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineminus">-    let identityQuery = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineminus">-    // ...that belong to one of the above contacts.</span>
<a href="#l1.34"></a><span id="l1.34" class="difflineminus">-    identityQuery.contact.apply(identityQuery, this.contactCollection.items);</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineminus">-    this.identityCollection = identityQuery.getAllSync();</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineminus">-  }</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineminus">-  else {</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineminus">-    // create an empty explicit collection</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineminus">-    this.identityCollection = Gloda.explicitCollection(Gloda.NOUN_IDENTITY, []);</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineminus">-  }</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineplus">+  if (!(Gloda.myContact.id in this.contactCollection._idMap))</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+    this.contactCollection._onItemsAdded([Gloda.myContact]);</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+    </span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+  // the set of identities owned by the contacts is automatically loaded as part</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+  //  of the contact loading...</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineplus">+  this.identityCollection =</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+    this.contactCollection.subCollections[Gloda.NOUN_IDENTITY];</span>
<a href="#l1.48"></a><span id="l1.48"> </span>
<a href="#l1.49"></a><span id="l1.49">   let contactNames = [(c.name.replace(&quot; &quot;, &quot;&quot;).toLowerCase() || &quot;x&quot;) for each</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineminus">-                      ([ic, c] in Iterator(this.contactCollection.items))];</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+                      ([, c] in Iterator(this.contactCollection.items))];</span>
<a href="#l1.52"></a><span id="l1.52">   let identityMails = [i.value.toLowerCase() for each</span>
<a href="#l1.53"></a><span id="l1.53" class="difflineminus">-                       ([ii, i] in Iterator(this.identityCollection.items))];</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineplus">+                       ([, i] in Iterator(this.identityCollection.items))];</span>
<a href="#l1.55"></a><span id="l1.55"> </span>
<a href="#l1.56"></a><span id="l1.56">   this.suffixTree = new MultiSuffixTree(contactNames.concat(identityMails),</span>
<a href="#l1.57"></a><span id="l1.57">     this.contactCollection.items.concat(this.identityCollection.items));</span>
<a href="#l1.58"></a><span id="l1.58"> }</span>
<a href="#l1.59"></a><span id="l1.59"> ContactIdentityCompleter.prototype = {</span>
<a href="#l1.60"></a><span id="l1.60">   _popularitySorter: function(a, b){ return b.popularity - a.popularity; },</span>
<a href="#l1.61"></a><span id="l1.61">   complete: function ContactIdentityCompleter_complete(aResult, aString) {</span>
<a href="#l1.62"></a><span id="l1.62">     if (aString.length &lt; 3)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/modules/collection.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/modules/collection.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -386,32 +386,29 @@ function GlodaCollection(aNounMeta, aIte</span>
<a href="#l2.4"></a><span id="l2.4">   if (aNounMeta === undefined)</span>
<a href="#l2.5"></a><span id="l2.5">     return;</span>
<a href="#l2.6"></a><span id="l2.6"> </span>
<a href="#l2.7"></a><span id="l2.7">   this._nounMeta = aNounMeta;</span>
<a href="#l2.8"></a><span id="l2.8">   // should we also maintain a unique value mapping...</span>
<a href="#l2.9"></a><span id="l2.9">   if (this._nounMeta.usesUniqueValue)</span>
<a href="#l2.10"></a><span id="l2.10">     this._uniqueValueMap = {};</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-  this.items = aItems || [];</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+  this.items = [];</span>
<a href="#l2.14"></a><span id="l2.14">   this._idMap = {};</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineminus">-  if (this._uniqueValueMap) {</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineminus">-    for each (let [iItem, item] in Iterator(this.items)) {</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineminus">-      this._idMap[item.id] = item;</span>
<a href="#l2.18"></a><span id="l2.18" class="difflineminus">-      this._uniqueValueMap[item.uniqueValue] = item;</span>
<a href="#l2.19"></a><span id="l2.19" class="difflineminus">-    }</span>
<a href="#l2.20"></a><span id="l2.20" class="difflineminus">-  }</span>
<a href="#l2.21"></a><span id="l2.21" class="difflineminus">-  else {</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineminus">-    for each (let [iItem, item] in Iterator(this.items)) {</span>
<a href="#l2.23"></a><span id="l2.23" class="difflineminus">-      this._idMap[item.id] = item;</span>
<a href="#l2.24"></a><span id="l2.24" class="difflineminus">-    }</span>
<a href="#l2.25"></a><span id="l2.25" class="difflineminus">-  }</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineplus">+  </span>
<a href="#l2.27"></a><span id="l2.27" class="difflineplus">+  // force the listener to null for our call to _onItemsAdded; no events for</span>
<a href="#l2.28"></a><span id="l2.28" class="difflineplus">+  //  the initial load-out.</span>
<a href="#l2.29"></a><span id="l2.29" class="difflineplus">+  this._listener = null;</span>
<a href="#l2.30"></a><span id="l2.30" class="difflineplus">+  this._onItemsAdded(items);</span>
<a href="#l2.31"></a><span id="l2.31">   </span>
<a href="#l2.32"></a><span id="l2.32">   this.query = aQuery || null;</span>
<a href="#l2.33"></a><span id="l2.33">   this._listener = aListener || null;</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+  </span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+  this.referencesByNounID = {};</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+  this.subCollections = {};</span>
<a href="#l2.37"></a><span id="l2.37"> }</span>
<a href="#l2.38"></a><span id="l2.38"> </span>
<a href="#l2.39"></a><span id="l2.39"> GlodaCollection.prototype = {</span>
<a href="#l2.40"></a><span id="l2.40">   get listener() { return this._listener; },</span>
<a href="#l2.41"></a><span id="l2.41">   set listener(aListener) { this._listener = aListener; },</span>
<a href="#l2.42"></a><span id="l2.42">   </span>
<a href="#l2.43"></a><span id="l2.43">   /**</span>
<a href="#l2.44"></a><span id="l2.44">    * Clear the contents of this collection.  This only makes sense for explicit</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/modules/datamodel.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/modules/datamodel.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -49,27 +49,27 @@ const LOG = Log4Moz.Service.getLogger(&quot;g</span>
<a href="#l3.4"></a><span id="l3.4"> </span>
<a href="#l3.5"></a><span id="l3.5"> Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l3.6"></a><span id="l3.6"> </span>
<a href="#l3.7"></a><span id="l3.7"> /**</span>
<a href="#l3.8"></a><span id="l3.8">  * @class Represents a gloda attribute definition.</span>
<a href="#l3.9"></a><span id="l3.9">  */</span>
<a href="#l3.10"></a><span id="l3.10"> function GlodaAttributeDef(aDatastore, aID, aCompoundName, aProvider, aAttrType,</span>
<a href="#l3.11"></a><span id="l3.11">                            aPluginName, aAttrName, aSubjectTypes,</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-                           aObjectType, aObjectNounMeta) {</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+                           aObjectType, aObjectNounDef) {</span>
<a href="#l3.14"></a><span id="l3.14">   this._datastore = aDatastore;</span>
<a href="#l3.15"></a><span id="l3.15">   this._id = aID;</span>
<a href="#l3.16"></a><span id="l3.16">   this._compoundName = aCompoundName;</span>
<a href="#l3.17"></a><span id="l3.17">   this._provider = aProvider;</span>
<a href="#l3.18"></a><span id="l3.18">   this._attrType = aAttrType;</span>
<a href="#l3.19"></a><span id="l3.19">   this._pluginName = aPluginName;</span>
<a href="#l3.20"></a><span id="l3.20">   this._attrName = aAttrName;</span>
<a href="#l3.21"></a><span id="l3.21">   this._subjectTypes = aSubjectTypes;</span>
<a href="#l3.22"></a><span id="l3.22">   this._objectType = aObjectType;</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineminus">-  this._objectNounMeta = aObjectNounMeta;</span>
<a href="#l3.24"></a><span id="l3.24" class="difflineplus">+  this._objectNounDef = aObjectNounDef;</span>
<a href="#l3.25"></a><span id="l3.25"> </span>
<a href="#l3.26"></a><span id="l3.26">   this.boundName = null;</span>
<a href="#l3.27"></a><span id="l3.27">   this._singular = null;</span>
<a href="#l3.28"></a><span id="l3.28"> </span>
<a href="#l3.29"></a><span id="l3.29">   this._special = 0; // not special</span>
<a href="#l3.30"></a><span id="l3.30">   this._specialColumnName = null;</span>
<a href="#l3.31"></a><span id="l3.31"> </span>
<a href="#l3.32"></a><span id="l3.32">   /** Map parameter values to the underlying database id. */</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineat">@@ -77,17 +77,17 @@ function GlodaAttributeDef(aDatastore, a</span>
<a href="#l3.34"></a><span id="l3.34"> }</span>
<a href="#l3.35"></a><span id="l3.35"> </span>
<a href="#l3.36"></a><span id="l3.36"> GlodaAttributeDef.prototype = {</span>
<a href="#l3.37"></a><span id="l3.37">   get id() { return this._id; },</span>
<a href="#l3.38"></a><span id="l3.38">   get provider() { return this._provider; },</span>
<a href="#l3.39"></a><span id="l3.39">   get attributeName() { return this._attrName; },</span>
<a href="#l3.40"></a><span id="l3.40"> </span>
<a href="#l3.41"></a><span id="l3.41">   get objectNoun() { return this._objectType; },</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineminus">-  get objectNounMeta() { return this._objectNounMeta; },</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineplus">+  get objectNounDef() { return this._objectNounDef; },</span>
<a href="#l3.44"></a><span id="l3.44"> </span>
<a href="#l3.45"></a><span id="l3.45">   get isBound() { return this.boundName !== null; },</span>
<a href="#l3.46"></a><span id="l3.46">   get singular() { return this._singular; },</span>
<a href="#l3.47"></a><span id="l3.47"> </span>
<a href="#l3.48"></a><span id="l3.48">   get special() { return this._special; },</span>
<a href="#l3.49"></a><span id="l3.49">   get specialColumnName() { return this._specialColumnName; },</span>
<a href="#l3.50"></a><span id="l3.50">   </span>
<a href="#l3.51"></a><span id="l3.51">   get parameterBindings() { return this._parameterBindings; },</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineat">@@ -110,49 +110,49 @@ GlodaAttributeDef.prototype = {</span>
<a href="#l3.53"></a><span id="l3.53">     let id = this._datastore._createAttributeDef(this._attrType,</span>
<a href="#l3.54"></a><span id="l3.54">                  this._pluginName, this._attrName, aValue);</span>
<a href="#l3.55"></a><span id="l3.55">     this._parameterBindings[aValue] = id;</span>
<a href="#l3.56"></a><span id="l3.56">     this._datastore.reportBinding(id, this, aValue);</span>
<a href="#l3.57"></a><span id="l3.57">     return id;</span>
<a href="#l3.58"></a><span id="l3.58">   },</span>
<a href="#l3.59"></a><span id="l3.59"> </span>
<a href="#l3.60"></a><span id="l3.60">   /**</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineminus">-   * Given an instance of an object with this attribute, return the value</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineminus">-   *  of the attribute.  This handles bound and un-bound attributes.  For</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineminus">-   *  singular attributes, the value is null or the value; for non-singular</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineminus">-   *  attributes the value is a list.</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineplus">+   * Given a list of values (if non-singular) or a single value (if singular),</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineplus">+   *  return a list (regardless of plurality) of database-ready [attribute id,</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineplus">+   *  value] tuples.  This is intended to be used to directly convert the value</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineplus">+   *  of a property on an object that corresponds to a bound attribute.</span>
<a href="#l3.69"></a><span id="l3.69">    */</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineminus">-  getValueFromInstance: function gloda_attr_getValueFromInstance(aObj) {</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineminus">-    // if it's bound, we can just use the binding and trigger his caching</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineminus">-    // if it's special, the attribute actually exists, but just with explicit</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineminus">-    //  code backing it.</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineminus">-    if (this.boundName !== null || this._special) {</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineminus">-      return aObj[this.boundName];</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineminus">-    }</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineminus">-    let instances = aObj.getAttributeInstances(this);</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineminus">-    let nounMeta = this._objectNounMeta;</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineplus">+  convertValuesToDBAttributes:</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineplus">+      function gloda_attr_convertValuesToDBAttributes(aInstanceValues) {</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineplus">+    let nounDef = this._objectNounDef;</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineplus">+    </span>
<a href="#l3.83"></a><span id="l3.83">     if (this._singular) {</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineminus">-      if (instances.length &gt; 0)</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineminus">-        return nounMeta.fromParamAndValue(instances[0][1], instances[0][2]);</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineminus">-      else</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineminus">-        return null;</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineplus">+      if (nounDef.usesParameter) {</span>
<a href="#l3.89"></a><span id="l3.89" class="difflineplus">+        let [param, dbValue] = nounDef.toParamAndValue(aInstanceValues);</span>
<a href="#l3.90"></a><span id="l3.90" class="difflineplus">+        return [[this.bindParameter(param), dbValue]];</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+      }</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineplus">+      else {</span>
<a href="#l3.93"></a><span id="l3.93" class="difflineplus">+        return [[this._id, nounDef.toParamAndValue(aInstanceValues)[1]]];</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineplus">+      }</span>
<a href="#l3.95"></a><span id="l3.95">     }</span>
<a href="#l3.96"></a><span id="l3.96">     else {</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineminus">-      let values;</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineminus">-      if (instances.length &gt; 0) {</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineminus">-        values = [];</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineminus">-        for (let iInst = 0; iInst &lt; instances.length; iInst++) {</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineminus">-          values.push(nounMeta.fromParamAndValue(instances[iInst][1],</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineminus">-                                                 instances[iInst][2]));</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineplus">+      let dbAttributes = [];</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineplus">+      if (nounDef.usesParameter) {</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineplus">+        for each (let [iValue, instanceValue] in Iterator(aInstanceValues)) {</span>
<a href="#l3.106"></a><span id="l3.106" class="difflineplus">+          let [param, dbValue] = nounDef.toParamAndValue(aInstanceValues);</span>
<a href="#l3.107"></a><span id="l3.107" class="difflineplus">+          dbAttributes.push([this.bindParameter(param), dbValue]);</span>
<a href="#l3.108"></a><span id="l3.108">         }</span>
<a href="#l3.109"></a><span id="l3.109">       }</span>
<a href="#l3.110"></a><span id="l3.110">       else {</span>
<a href="#l3.111"></a><span id="l3.111" class="difflineminus">-        values = instances; // empty is empty</span>
<a href="#l3.112"></a><span id="l3.112" class="difflineplus">+        for each (let [iValue, instanceValue] in Iterator(aInstanceValues)) {</span>
<a href="#l3.113"></a><span id="l3.113" class="difflineplus">+          dbAttributes.push([this._id,</span>
<a href="#l3.114"></a><span id="l3.114" class="difflineplus">+                             nounDef.toParamAndValue(instanceValue)[1]);</span>
<a href="#l3.115"></a><span id="l3.115" class="difflineplus">+        }</span>
<a href="#l3.116"></a><span id="l3.116">       }</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineminus">-      return values;</span>
<a href="#l3.118"></a><span id="l3.118" class="difflineplus">+      return dbAttributes;</span>
<a href="#l3.119"></a><span id="l3.119">     }</span>
<a href="#l3.120"></a><span id="l3.120">   },</span>
<a href="#l3.121"></a><span id="l3.121"> </span>
<a href="#l3.122"></a><span id="l3.122">   toString: function() {</span>
<a href="#l3.123"></a><span id="l3.123">     return this._compoundName;</span>
<a href="#l3.124"></a><span id="l3.124">   }</span>
<a href="#l3.125"></a><span id="l3.125"> };</span>
<a href="#l3.126"></a><span id="l3.126"> </span>
<a href="#l3.127"></a><span id="l3.127" class="difflineat">@@ -272,56 +272,57 @@ function MixIn(aConstructor, aMixIn) {</span>
<a href="#l3.128"></a><span id="l3.128">  */</span>
<a href="#l3.129"></a><span id="l3.129"> function GlodaConversation(aDatastore, aID, aSubject, aOldestMessageDate,</span>
<a href="#l3.130"></a><span id="l3.130">                            aNewestMessageDate) {</span>
<a href="#l3.131"></a><span id="l3.131">   this._datastore = aDatastore;</span>
<a href="#l3.132"></a><span id="l3.132">   this._id = aID;</span>
<a href="#l3.133"></a><span id="l3.133">   this._subject = aSubject;</span>
<a href="#l3.134"></a><span id="l3.134">   this._oldestMessageDate = aOldestMessageDate;</span>
<a href="#l3.135"></a><span id="l3.135">   this._newestMessageDate = aNewestMessageDate;</span>
<a href="#l3.136"></a><span id="l3.136" class="difflineminus">-</span>
<a href="#l3.137"></a><span id="l3.137" class="difflineminus">-  this._messages = null;</span>
<a href="#l3.138"></a><span id="l3.138"> }</span>
<a href="#l3.139"></a><span id="l3.139"> </span>
<a href="#l3.140"></a><span id="l3.140"> GlodaConversation.prototype = {</span>
<a href="#l3.141"></a><span id="l3.141">   NOUN_ID: 101,</span>
<a href="#l3.142"></a><span id="l3.142">   get id() { return this._id; },</span>
<a href="#l3.143"></a><span id="l3.143">   get subject() { return this._subject; },</span>
<a href="#l3.144"></a><span id="l3.144">   get oldestMessageDate() { return this._oldestMessageDate; },</span>
<a href="#l3.145"></a><span id="l3.145">   get newestMessageDate() { return this._newestMessageDate; },</span>
<a href="#l3.146"></a><span id="l3.146"> </span>
<a href="#l3.147"></a><span id="l3.147" class="difflineminus">-  /**</span>
<a href="#l3.148"></a><span id="l3.148" class="difflineminus">-   * @TODO Return the collection of messages belonging to this conversation.</span>
<a href="#l3.149"></a><span id="l3.149" class="difflineminus">-   * (And weakly store a reference to the collection.  Once the user is rid of</span>
<a href="#l3.150"></a><span id="l3.150" class="difflineminus">-   *  it, we really don't care.)</span>
<a href="#l3.151"></a><span id="l3.151" class="difflineminus">-   */</span>
<a href="#l3.152"></a><span id="l3.152" class="difflineminus">-  get messages() {</span>
<a href="#l3.153"></a><span id="l3.153" class="difflineminus">-    if (this._messages == null) {</span>
<a href="#l3.154"></a><span id="l3.154" class="difflineminus">-      this._messages = this._datastore.getMessagesByConversationID(this._id,</span>
<a href="#l3.155"></a><span id="l3.155" class="difflineminus">-                                                                   false);</span>
<a href="#l3.156"></a><span id="l3.156" class="difflineminus">-    }</span>
<a href="#l3.157"></a><span id="l3.157" class="difflineminus">-    return this._messages;</span>
<a href="#l3.158"></a><span id="l3.158" class="difflineminus">-  },</span>
<a href="#l3.159"></a><span id="l3.159" class="difflineminus">-</span>
<a href="#l3.160"></a><span id="l3.160">   toString: function gloda_conversation_toString() {</span>
<a href="#l3.161"></a><span id="l3.161">     return this._subject;</span>
<a href="#l3.162"></a><span id="l3.162">   },</span>
<a href="#l3.163"></a><span id="l3.163"> };</span>
<a href="#l3.164"></a><span id="l3.164"> </span>
<a href="#l3.165"></a><span id="l3.165" class="difflineminus">-function GlodaFolder(aDatastore, aID, aURI, aPrettyName) {</span>
<a href="#l3.166"></a><span id="l3.166" class="difflineplus">+function GlodaFolder(aDatastore, aID, aURI, aDirtyStatus, aPrettyName) {</span>
<a href="#l3.167"></a><span id="l3.167">   this._datastore = aDatastore;</span>
<a href="#l3.168"></a><span id="l3.168">   this._id = aID;</span>
<a href="#l3.169"></a><span id="l3.169">   this._uri = aURI;</span>
<a href="#l3.170"></a><span id="l3.170" class="difflineplus">+  this._dirtyStatus = aDirtyStatus;</span>
<a href="#l3.171"></a><span id="l3.171">   this._prettyName = aPrettyName;</span>
<a href="#l3.172"></a><span id="l3.172"> }</span>
<a href="#l3.173"></a><span id="l3.173"> </span>
<a href="#l3.174"></a><span id="l3.174"> GlodaFolder.prototype = {</span>
<a href="#l3.175"></a><span id="l3.175" class="difflineminus">- NOUN_ID: 100,</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineminus">- get id() { return this._id; },</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineminus">- get uri() { return this._uri; },</span>
<a href="#l3.178"></a><span id="l3.178" class="difflineplus">+  NOUN_ID: 100,</span>
<a href="#l3.179"></a><span id="l3.179" class="difflineplus">+  /** The folder is believed to be up-to-date */</span>
<a href="#l3.180"></a><span id="l3.180" class="difflineplus">+  kFolderClean: 0,</span>
<a href="#l3.181"></a><span id="l3.181" class="difflineplus">+  /** The folder has some un-indexed or dirty messages */</span>
<a href="#l3.182"></a><span id="l3.182" class="difflineplus">+  kFolderDirty: 1,</span>
<a href="#l3.183"></a><span id="l3.183" class="difflineplus">+  /** The folder needs to be entirely re-indexed, regardless of the flags on</span>
<a href="#l3.184"></a><span id="l3.184" class="difflineplus">+   * the messages in the folder. This state will be downgraded to dirty */</span>
<a href="#l3.185"></a><span id="l3.185" class="difflineplus">+  kFolderFilthy: 2,</span>
<a href="#l3.186"></a><span id="l3.186" class="difflineplus">+  get id() { return this._id; },</span>
<a href="#l3.187"></a><span id="l3.187" class="difflineplus">+  get uri() { return this._uri; },</span>
<a href="#l3.188"></a><span id="l3.188" class="difflineplus">+  get dirtyStatus { return this._dirtyStatus; },</span>
<a href="#l3.189"></a><span id="l3.189" class="difflineplus">+  set dirtyStatus (aNewStatus) {</span>
<a href="#l3.190"></a><span id="l3.190" class="difflineplus">+    if (aNewStatus != this._dirtyStatus) {</span>
<a href="#l3.191"></a><span id="l3.191" class="difflineplus">+      this._dirtyStatus = aNewStatus;</span>
<a href="#l3.192"></a><span id="l3.192" class="difflineplus">+      this._datastore.updateFolderDirtyStatus(this);</span>
<a href="#l3.193"></a><span id="l3.193" class="difflineplus">+    }</span>
<a href="#l3.194"></a><span id="l3.194" class="difflineplus">+  },</span>
<a href="#l3.195"></a><span id="l3.195" class="difflineplus">+  get name { return this._prettyName; },</span>
<a href="#l3.196"></a><span id="l3.196">   toString: function gloda_folder_toString() {</span>
<a href="#l3.197"></a><span id="l3.197">     return this._prettyName;</span>
<a href="#l3.198"></a><span id="l3.198">   }</span>
<a href="#l3.199"></a><span id="l3.199"> }</span>
<a href="#l3.200"></a><span id="l3.200"> </span>
<a href="#l3.201"></a><span id="l3.201"> /**</span>
<a href="#l3.202"></a><span id="l3.202">  * @class A message representation.</span>
<a href="#l3.203"></a><span id="l3.203">  */</span>
<a href="#l3.204"></a><span id="l3.204" class="difflineat">@@ -329,58 +330,62 @@ function GlodaMessage(aDatastore, aID, a</span>
<a href="#l3.205"></a><span id="l3.205">                       aConversationID, aConversation, aDate,</span>
<a href="#l3.206"></a><span id="l3.206">                       aHeaderMessageID, aDeleted) {</span>
<a href="#l3.207"></a><span id="l3.207">   this._datastore = aDatastore;</span>
<a href="#l3.208"></a><span id="l3.208">   this._id = aID;</span>
<a href="#l3.209"></a><span id="l3.209">   this._folderID = aFolderID;</span>
<a href="#l3.210"></a><span id="l3.210">   this._messageKey = aMessageKey;</span>
<a href="#l3.211"></a><span id="l3.211">   this._conversationID = aConversationID;</span>
<a href="#l3.212"></a><span id="l3.212">   this._conversation = aConversation;</span>
<a href="#l3.213"></a><span id="l3.213" class="difflineminus">-  this.date = aDate;</span>
<a href="#l3.214"></a><span id="l3.214" class="difflineplus">+  this._date = aDate;</span>
<a href="#l3.215"></a><span id="l3.215">   this._headerMessageID = aHeaderMessageID;</span>
<a href="#l3.216"></a><span id="l3.216"> </span>
<a href="#l3.217"></a><span id="l3.217">   // only set _deleted if we're deleted, otherwise the undefined does our</span>
<a href="#l3.218"></a><span id="l3.218">   //  speaking for us.</span>
<a href="#l3.219"></a><span id="l3.219">   if (aDeleted)</span>
<a href="#l3.220"></a><span id="l3.220">     this._deleted = aDeleted;</span>
<a href="#l3.221"></a><span id="l3.221"> }</span>
<a href="#l3.222"></a><span id="l3.222"> </span>
<a href="#l3.223"></a><span id="l3.223"> GlodaMessage.prototype = {</span>
<a href="#l3.224"></a><span id="l3.224">   NOUN_ID: 102,</span>
<a href="#l3.225"></a><span id="l3.225">   get id() { return this._id; },</span>
<a href="#l3.226"></a><span id="l3.226">   get folderID() { return this._folderID; },</span>
<a href="#l3.227"></a><span id="l3.227">   get messageKey() { return this._messageKey; },</span>
<a href="#l3.228"></a><span id="l3.228">   get conversationID() { return this._conversationID; },</span>
<a href="#l3.229"></a><span id="l3.229">   // conversation is special</span>
<a href="#l3.230"></a><span id="l3.230">   get headerMessageID() { return this._headerMessageID; },</span>
<a href="#l3.231"></a><span id="l3.231" class="difflineplus">+  </span>
<a href="#l3.232"></a><span id="l3.232" class="difflineplus">+  get date() { return this._date; },</span>
<a href="#l3.233"></a><span id="l3.233" class="difflineplus">+  set date(aNewDate) { this._date = aNewDate; },</span>
<a href="#l3.234"></a><span id="l3.234"> </span>
<a href="#l3.235"></a><span id="l3.235">   get folderURI() {</span>
<a href="#l3.236"></a><span id="l3.236">     if (this._folderID != null)</span>
<a href="#l3.237"></a><span id="l3.237" class="difflineminus">-      return this._datastore._mapFolderID(this._folderID);</span>
<a href="#l3.238"></a><span id="l3.238" class="difflineplus">+      return this._datastore._mapFolderID(this._folderID).uri;</span>
<a href="#l3.239"></a><span id="l3.239">     else</span>
<a href="#l3.240"></a><span id="l3.240">       return null;</span>
<a href="#l3.241"></a><span id="l3.241">   },</span>
<a href="#l3.242"></a><span id="l3.242">   get conversation() {</span>
<a href="#l3.243"></a><span id="l3.243">     if (this._conversation == null) {</span>
<a href="#l3.244"></a><span id="l3.244">       this._conversation = this._datastore.getConversationByID(</span>
<a href="#l3.245"></a><span id="l3.245">         this._conversationID);</span>
<a href="#l3.246"></a><span id="l3.246">     }</span>
<a href="#l3.247"></a><span id="l3.247">     return this._conversation;</span>
<a href="#l3.248"></a><span id="l3.248">   },</span>
<a href="#l3.249"></a><span id="l3.249"> </span>
<a href="#l3.250"></a><span id="l3.250" class="difflineminus">-  set messageKey(aMessageKey) { this._messageKey = aMessageKey; },</span>
<a href="#l3.251"></a><span id="l3.251" class="difflineminus">-  set folderURI(aFolderURI) {</span>
<a href="#l3.252"></a><span id="l3.252" class="difflineminus">-    this._folderID = this._datastore._mapFolderURI(aFolderURI);</span>
<a href="#l3.253"></a><span id="l3.253" class="difflineminus">-  },</span>
<a href="#l3.254"></a><span id="l3.254" class="difflineminus">-</span>
<a href="#l3.255"></a><span id="l3.255">   toString: function gloda_message_toString() {</span>
<a href="#l3.256"></a><span id="l3.256">     // uh, this is a tough one...</span>
<a href="#l3.257"></a><span id="l3.257">     return &quot;Message &quot; + this._id;</span>
<a href="#l3.258"></a><span id="l3.258">   },</span>
<a href="#l3.259"></a><span id="l3.259"> </span>
<a href="#l3.260"></a><span id="l3.260" class="difflineplus">+  _clone: function gloda_message_clone() {</span>
<a href="#l3.261"></a><span id="l3.261" class="difflineplus">+    return new GlodaMessage(this._datastore, this._id, this._folderId,</span>
<a href="#l3.262"></a><span id="l3.262" class="difflineplus">+      this._messageKey, this._conversationID, this._conversation, this._date,</span>
<a href="#l3.263"></a><span id="l3.263" class="difflineplus">+      this._headerMessageID, this._deleted);</span>
<a href="#l3.264"></a><span id="l3.264" class="difflineplus">+  },</span>
<a href="#l3.265"></a><span id="l3.265" class="difflineplus">+</span>
<a href="#l3.266"></a><span id="l3.266">   _ghost: function gloda_message_ghost() {</span>
<a href="#l3.267"></a><span id="l3.267">     this._folderID = null;</span>
<a href="#l3.268"></a><span id="l3.268">     this._messageKey = null;</span>
<a href="#l3.269"></a><span id="l3.269">   },</span>
<a href="#l3.270"></a><span id="l3.270"> </span>
<a href="#l3.271"></a><span id="l3.271">   _nuke: function gloda_message_nuke() {</span>
<a href="#l3.272"></a><span id="l3.272">     this._id = null;</span>
<a href="#l3.273"></a><span id="l3.273">     this._folderID = null;</span>
<a href="#l3.274"></a><span id="l3.274" class="difflineat">@@ -399,17 +404,17 @@ GlodaMessage.prototype = {</span>
<a href="#l3.275"></a><span id="l3.275">    * This method no longer caches the result, so it's up to you.</span>
<a href="#l3.276"></a><span id="l3.276">    */</span>
<a href="#l3.277"></a><span id="l3.277">   get folderMessage() {</span>
<a href="#l3.278"></a><span id="l3.278">     if (this._folderID === null || this._messageKey === null)</span>
<a href="#l3.279"></a><span id="l3.279">       return null;</span>
<a href="#l3.280"></a><span id="l3.280">     let rdfService = Cc['@mozilla.org/rdf/rdf-service;1'].</span>
<a href="#l3.281"></a><span id="l3.281">                      getService(Ci.nsIRDFService);</span>
<a href="#l3.282"></a><span id="l3.282">     let folder = rdfService.GetResource(</span>
<a href="#l3.283"></a><span id="l3.283" class="difflineminus">-                   this._datastore._mapFolderID(this._folderID));</span>
<a href="#l3.284"></a><span id="l3.284" class="difflineplus">+                   this._datastore._mapFolderID(this._folderID).uri);</span>
<a href="#l3.285"></a><span id="l3.285">     if (folder instanceof Ci.nsIMsgFolder) {</span>
<a href="#l3.286"></a><span id="l3.286">       let folderMessage = folder.GetMessageHeader(this._messageKey);</span>
<a href="#l3.287"></a><span id="l3.287">       if (folderMessage !== null) {</span>
<a href="#l3.288"></a><span id="l3.288">         // verify the message-id header matches what we expect...</span>
<a href="#l3.289"></a><span id="l3.289">         if (folderMessage.messageId != this._headerMessageID) {</span>
<a href="#l3.290"></a><span id="l3.290">           LOG.info(&quot;Message with message key does not match expected &quot; +</span>
<a href="#l3.291"></a><span id="l3.291">                    &quot;header! (&quot; + this._headerMessageID + &quot; expected, got &quot; +</span>
<a href="#l3.292"></a><span id="l3.292">                    folderMessage.messageId + &quot;)&quot;);</span>
<a href="#l3.293"></a><span id="l3.293" class="difflineat">@@ -454,17 +459,18 @@ function GlodaContact(aDatastore, aID, a</span>
<a href="#l3.294"></a><span id="l3.294"> }</span>
<a href="#l3.295"></a><span id="l3.295"> </span>
<a href="#l3.296"></a><span id="l3.296"> GlodaContact.prototype = {</span>
<a href="#l3.297"></a><span id="l3.297">   NOUN_ID: 103,</span>
<a href="#l3.298"></a><span id="l3.298"> </span>
<a href="#l3.299"></a><span id="l3.299">   get id() { return this._id; },</span>
<a href="#l3.300"></a><span id="l3.300">   get directoryUUID() { return this._directoryUUID; },</span>
<a href="#l3.301"></a><span id="l3.301">   get contactUUID() { return this._contactUUID; },</span>
<a href="#l3.302"></a><span id="l3.302" class="difflineminus">-  get name() { return this._name },</span>
<a href="#l3.303"></a><span id="l3.303" class="difflineplus">+  get name() { return this._name; },</span>
<a href="#l3.304"></a><span id="l3.304" class="difflineplus">+  set name(aName) { this._name = aName; },</span>
<a href="#l3.305"></a><span id="l3.305"> </span>
<a href="#l3.306"></a><span id="l3.306">   get popularity() { return this._popularity; },</span>
<a href="#l3.307"></a><span id="l3.307">   set popularity(aPopularity) {</span>
<a href="#l3.308"></a><span id="l3.308">     this._popularity = aPopularity;</span>
<a href="#l3.309"></a><span id="l3.309">     this.dirty = true;</span>
<a href="#l3.310"></a><span id="l3.310">   },</span>
<a href="#l3.311"></a><span id="l3.311"> </span>
<a href="#l3.312"></a><span id="l3.312">   get frecency() { return this._frecency; },</span>
<a href="#l3.313"></a><span id="l3.313" class="difflineat">@@ -480,17 +486,22 @@ GlodaContact.prototype = {</span>
<a href="#l3.314"></a><span id="l3.314">   },</span>
<a href="#l3.315"></a><span id="l3.315"> </span>
<a href="#l3.316"></a><span id="l3.316">   toString: function gloda_contact_toString() {</span>
<a href="#l3.317"></a><span id="l3.317">     return this._name;</span>
<a href="#l3.318"></a><span id="l3.318">   },</span>
<a href="#l3.319"></a><span id="l3.319">   </span>
<a href="#l3.320"></a><span id="l3.320">   get accessibleLabel() {</span>
<a href="#l3.321"></a><span id="l3.321">     return &quot;Contact: &quot; + this._name;</span>
<a href="#l3.322"></a><span id="l3.322" class="difflineminus">-  }</span>
<a href="#l3.323"></a><span id="l3.323" class="difflineplus">+  },</span>
<a href="#l3.324"></a><span id="l3.324" class="difflineplus">+</span>
<a href="#l3.325"></a><span id="l3.325" class="difflineplus">+  _clone: function gloda_contact_clone() {</span>
<a href="#l3.326"></a><span id="l3.326" class="difflineplus">+    return new GlodaContact(this._datastore, this._id, this._directoryUUID,</span>
<a href="#l3.327"></a><span id="l3.327" class="difflineplus">+      this._contactUUID, this._name, this._popularity, this._frecency);</span>
<a href="#l3.328"></a><span id="l3.328" class="difflineplus">+  },</span>
<a href="#l3.329"></a><span id="l3.329"> };</span>
<a href="#l3.330"></a><span id="l3.330"> MixIn(GlodaContact, GlodaHasAttributesMixIn);</span>
<a href="#l3.331"></a><span id="l3.331"> </span>
<a href="#l3.332"></a><span id="l3.332"> </span>
<a href="#l3.333"></a><span id="l3.333"> /**</span>
<a href="#l3.334"></a><span id="l3.334">  * @class A specific means of communication for a contact.</span>
<a href="#l3.335"></a><span id="l3.335">  */</span>
<a href="#l3.336"></a><span id="l3.336"> function GlodaIdentity(aDatastore, aID, aContactID, aContact, aKind, aValue,</span>
<a href="#l3.337"></a><span id="l3.337" class="difflineat">@@ -524,34 +535,17 @@ GlodaIdentity.prototype = {</span>
<a href="#l3.338"></a><span id="l3.338">     return this._contact;</span>
<a href="#l3.339"></a><span id="l3.339">   },</span>
<a href="#l3.340"></a><span id="l3.340"> </span>
<a href="#l3.341"></a><span id="l3.341">   toString: function gloda_identity_toString() {</span>
<a href="#l3.342"></a><span id="l3.342">     return this._value;</span>
<a href="#l3.343"></a><span id="l3.343">   },</span>
<a href="#l3.344"></a><span id="l3.344"> </span>
<a href="#l3.345"></a><span id="l3.345">   get abCard() {</span>
<a href="#l3.346"></a><span id="l3.346" class="difflineminus">-    // search through all of our local address books looking for a match.</span>
<a href="#l3.347"></a><span id="l3.347" class="difflineminus">-    let enumerator = Components.classes[&quot;@mozilla.org/abmanager;1&quot;]</span>
<a href="#l3.348"></a><span id="l3.348" class="difflineminus">-                               .getService(Ci.nsIAbManager)</span>
<a href="#l3.349"></a><span id="l3.349" class="difflineminus">-                               .directories;</span>
<a href="#l3.350"></a><span id="l3.350" class="difflineminus">-    let cardForEmailAddress;</span>
<a href="#l3.351"></a><span id="l3.351" class="difflineminus">-    let addrbook;</span>
<a href="#l3.352"></a><span id="l3.352" class="difflineminus">-    while (!cardForEmailAddress &amp;&amp; enumerator.hasMoreElements())</span>
<a href="#l3.353"></a><span id="l3.353" class="difflineminus">-    {</span>
<a href="#l3.354"></a><span id="l3.354" class="difflineminus">-      addrbook = enumerator.getNext().QueryInterface(Ci.nsIAbDirectory);</span>
<a href="#l3.355"></a><span id="l3.355" class="difflineminus">-      try</span>
<a href="#l3.356"></a><span id="l3.356" class="difflineminus">-      {</span>
<a href="#l3.357"></a><span id="l3.357" class="difflineminus">-        cardForEmailAddress = addrbook.cardForEmailAddress(this._value);</span>
<a href="#l3.358"></a><span id="l3.358" class="difflineminus">-        if (cardForEmailAddress)</span>
<a href="#l3.359"></a><span id="l3.359" class="difflineminus">-          return cardForEmailAddress;</span>
<a href="#l3.360"></a><span id="l3.360" class="difflineminus">-      } catch (ex) {}</span>
<a href="#l3.361"></a><span id="l3.361" class="difflineminus">-    }</span>
<a href="#l3.362"></a><span id="l3.362" class="difflineminus">-</span>
<a href="#l3.363"></a><span id="l3.363" class="difflineminus">-    return null;</span>
<a href="#l3.364"></a><span id="l3.364" class="difflineplus">+    return GlodaUtils.getCardForEmail(this._value);</span>
<a href="#l3.365"></a><span id="l3.365">   },</span>
<a href="#l3.366"></a><span id="l3.366">   </span>
<a href="#l3.367"></a><span id="l3.367">   pictureURL: function(aSize) {</span>
<a href="#l3.368"></a><span id="l3.368">     let md5hash = GlodaUtils.md5HashString(this._value);</span>
<a href="#l3.369"></a><span id="l3.369">     let gravURL = &quot;http://www.gravatar.com/avatar/&quot; + md5hash +</span>
<a href="#l3.370"></a><span id="l3.370">                                 &quot;?d=identicon&amp;s=&quot; + aSize + &quot;&amp;r=g&quot;;</span>
<a href="#l3.371"></a><span id="l3.371">     return gravURL;</span>
<a href="#l3.372"></a><span id="l3.372">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -48,21 +48,16 @@ const Cr = Components.results;</span>
<a href="#l4.4"></a><span id="l4.4"> const Cu = Components.utils;</span>
<a href="#l4.5"></a><span id="l4.5"> </span>
<a href="#l4.6"></a><span id="l4.6"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l4.7"></a><span id="l4.7"> </span>
<a href="#l4.8"></a><span id="l4.8"> Cu.import(&quot;resource://gloda/modules/datamodel.js&quot;);</span>
<a href="#l4.9"></a><span id="l4.9"> Cu.import(&quot;resource://gloda/modules/databind.js&quot;);</span>
<a href="#l4.10"></a><span id="l4.10"> Cu.import(&quot;resource://gloda/modules/collection.js&quot;);</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-// XXX from Gloda.js.  duplicated here for dependency reasons.  bad!</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineminus">-const kSpecialColumn = 1;</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineminus">-const kSpecialString = 2;</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineminus">-const kSpecialFulltext = 3;</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineminus">-</span>
<a href="#l4.17"></a><span id="l4.17"> /**</span>
<a href="#l4.18"></a><span id="l4.18">  * @class This callback handles processing the asynchronous query results of</span>
<a href="#l4.19"></a><span id="l4.19">  *  GlodaDatastore.getMessagesByMessageID.  Because that method is only</span>
<a href="#l4.20"></a><span id="l4.20">  *  called as part of the indexing process, we are guaranteed that there will</span>
<a href="#l4.21"></a><span id="l4.21">  *  be no real caching ramifications.  Accordingly, we can also defer our cache</span>
<a href="#l4.22"></a><span id="l4.22">  *  processing (via GlodaCollectionManager) until the query completes.</span>
<a href="#l4.23"></a><span id="l4.23">  *</span>
<a href="#l4.24"></a><span id="l4.24">  * @param aMsgIDToIndex Map from message-id to the desired</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineat">@@ -108,35 +103,65 @@ MessagesByMessageIdCallback.prototype = </span>
<a href="#l4.26"></a><span id="l4.26">     this.statement = null;</span>
<a href="#l4.27"></a><span id="l4.27"> </span>
<a href="#l4.28"></a><span id="l4.28">     this.callback.apply(this.callbackThis, args);</span>
<a href="#l4.29"></a><span id="l4.29"> </span>
<a href="#l4.30"></a><span id="l4.30">     GlodaDatastore._asyncCompleted();</span>
<a href="#l4.31"></a><span id="l4.31">   }</span>
<a href="#l4.32"></a><span id="l4.32"> };</span>
<a href="#l4.33"></a><span id="l4.33"> </span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+function PostCommitHandler(aCallbacks) {</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+  this.callbacks = aCallbacks;</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+}</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+PostCommitHandler.prototype = {</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineplus">+  handleResult: function gloda_ds_pch_handleResult(aResultSet) {</span>
<a href="#l4.40"></a><span id="l4.40" class="difflineplus">+  },</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineplus">+  </span>
<a href="#l4.42"></a><span id="l4.42" class="difflineplus">+  handleError: function gloda_ds_pch_handleError(aError) {</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineplus">+  },</span>
<a href="#l4.44"></a><span id="l4.44" class="difflineplus">+  </span>
<a href="#l4.45"></a><span id="l4.45" class="difflineplus">+  handleCompletion: function gloda_ds_pch_handleCompletion(aReason) {</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineplus">+    if (aReason == Ci.mozIStorageStatementCallback.REASON_FINISHED) {</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineplus">+      for each (let [iCallback, callback] in Iterator(this.callbacks)) {</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineplus">+        try {</span>
<a href="#l4.49"></a><span id="l4.49" class="difflineplus">+          callback();</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineplus">+        }</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineplus">+        catch (ex) {</span>
<a href="#l4.52"></a><span id="l4.52" class="difflineplus">+          dump(&quot;PostCommitHandler callback (&quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineplus">+               ex.lineNumber + &quot;) threw: &quot; + ex);</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineplus">+        }</span>
<a href="#l4.55"></a><span id="l4.55" class="difflineplus">+      }</span>
<a href="#l4.56"></a><span id="l4.56" class="difflineplus">+    }</span>
<a href="#l4.57"></a><span id="l4.57" class="difflineplus">+    GlodaDatastore._asyncCompleted();</span>
<a href="#l4.58"></a><span id="l4.58" class="difflineplus">+  }</span>
<a href="#l4.59"></a><span id="l4.59" class="difflineplus">+};</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineplus">+</span>
<a href="#l4.61"></a><span id="l4.61"> /**</span>
<a href="#l4.62"></a><span id="l4.62">  * @class Handles the results from a GlodaDatastore.queryFromQuery call.</span>
<a href="#l4.63"></a><span id="l4.63">  * @constructor</span>
<a href="#l4.64"></a><span id="l4.64">  */</span>
<a href="#l4.65"></a><span id="l4.65"> function QueryFromQueryCallback(aStatement, aNounMeta, aCollection) {</span>
<a href="#l4.66"></a><span id="l4.66">   this.statement = aStatement;</span>
<a href="#l4.67"></a><span id="l4.67">   this.nounMeta = aNounMeta;</span>
<a href="#l4.68"></a><span id="l4.68">   this.collection = aCollection;</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineplus">+  </span>
<a href="#l4.70"></a><span id="l4.70" class="difflineplus">+  this.referencesByNounID = {};</span>
<a href="#l4.71"></a><span id="l4.71"> </span>
<a href="#l4.72"></a><span id="l4.72">   GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l4.73"></a><span id="l4.73"> }</span>
<a href="#l4.74"></a><span id="l4.74"> </span>
<a href="#l4.75"></a><span id="l4.75"> QueryFromQueryCallback.prototype = {</span>
<a href="#l4.76"></a><span id="l4.76">   handleResult: function gloda_ds_qfq_handleResult(aResultSet) {</span>
<a href="#l4.77"></a><span id="l4.77">     let newItems = [];</span>
<a href="#l4.78"></a><span id="l4.78">     let row;</span>
<a href="#l4.79"></a><span id="l4.79">     let nounMeta = this.nounMeta;</span>
<a href="#l4.80"></a><span id="l4.80">     while (row = aResultSet.getNextRow()) {</span>
<a href="#l4.81"></a><span id="l4.81">       let item = nounMeta.objFromRow.call(nounMeta.datastore, row);</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineplus">+      GlodaDatastore.loadNounItem(item, this.referencesByNounID);</span>
<a href="#l4.83"></a><span id="l4.83">       newItems.push(item);</span>
<a href="#l4.84"></a><span id="l4.84">     }</span>
<a href="#l4.85"></a><span id="l4.85">     // have the collection manager attempt to replace the instances we just</span>
<a href="#l4.86"></a><span id="l4.86">     //  created with pre-existing instances.  there is some waste here...</span>
<a href="#l4.87"></a><span id="l4.87">     // XXX consider having collection manager take row objects with the</span>
<a href="#l4.88"></a><span id="l4.88">     //  knowledge of what index is the 'id' index and knowing what objFromRow</span>
<a href="#l4.89"></a><span id="l4.89">     //  method to call if it needs to realize the row.</span>
<a href="#l4.90"></a><span id="l4.90">     // queries have the potential to easily exceed the size of our cache, and</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineat">@@ -257,27 +282,40 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l4.92"></a><span id="l4.92">  *  states of attributes to accomplish this, but that is not desirable.)  This</span>
<a href="#l4.93"></a><span id="l4.93">  *  needs to be addressed, and may be best addressed at layers above</span>
<a href="#l4.94"></a><span id="l4.94">  *  datastore.js.</span>
<a href="#l4.95"></a><span id="l4.95">  * @namespace</span>
<a href="#l4.96"></a><span id="l4.96">  */</span>
<a href="#l4.97"></a><span id="l4.97"> var GlodaDatastore = {</span>
<a href="#l4.98"></a><span id="l4.98">   _log: null,</span>
<a href="#l4.99"></a><span id="l4.99"> </span>
<a href="#l4.100"></a><span id="l4.100" class="difflineplus">+  /* see Gloda's documentation for these constants */</span>
<a href="#l4.101"></a><span id="l4.101" class="difflineplus">+  kSpecialColumn: 1,</span>
<a href="#l4.102"></a><span id="l4.102" class="difflineplus">+  kSpecialString: 2,</span>
<a href="#l4.103"></a><span id="l4.103" class="difflineplus">+  kSpecialFulltext: 3,</span>
<a href="#l4.104"></a><span id="l4.104" class="difflineplus">+  </span>
<a href="#l4.105"></a><span id="l4.105" class="difflineplus">+  kMagicAttrIDs: -1,</span>
<a href="#l4.106"></a><span id="l4.106" class="difflineplus">+  </span>
<a href="#l4.107"></a><span id="l4.107" class="difflineplus">+  kConstraintEquals: 0,</span>
<a href="#l4.108"></a><span id="l4.108" class="difflineplus">+  kConstraintIn: 1,</span>
<a href="#l4.109"></a><span id="l4.109" class="difflineplus">+  kConstraintRanges: 2,</span>
<a href="#l4.110"></a><span id="l4.110" class="difflineplus">+</span>
<a href="#l4.111"></a><span id="l4.111">   /* ******************* SCHEMA ******************* */</span>
<a href="#l4.112"></a><span id="l4.112"> </span>
<a href="#l4.113"></a><span id="l4.113" class="difflineminus">-  _schemaVersion: 9,</span>
<a href="#l4.114"></a><span id="l4.114" class="difflineplus">+  _schemaVersion: 10,</span>
<a href="#l4.115"></a><span id="l4.115">   _schema: {</span>
<a href="#l4.116"></a><span id="l4.116">     tables: {</span>
<a href="#l4.117"></a><span id="l4.117"> </span>
<a href="#l4.118"></a><span id="l4.118">       // ----- Messages</span>
<a href="#l4.119"></a><span id="l4.119">       folderLocations: {</span>
<a href="#l4.120"></a><span id="l4.120">         columns: [</span>
<a href="#l4.121"></a><span id="l4.121">           &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l4.122"></a><span id="l4.122">           &quot;folderURI TEXT NOT NULL&quot;,</span>
<a href="#l4.123"></a><span id="l4.123" class="difflineplus">+          &quot;dirtyStatus INTEGER NOT NULL&quot;,</span>
<a href="#l4.124"></a><span id="l4.124" class="difflineplus">+          &quot;name TEXT NOT NULL&quot;,</span>
<a href="#l4.125"></a><span id="l4.125">         ],</span>
<a href="#l4.126"></a><span id="l4.126"> </span>
<a href="#l4.127"></a><span id="l4.127">         triggers: {</span>
<a href="#l4.128"></a><span id="l4.128">           delete: &quot;DELETE from messages WHERE folderID = OLD.id&quot;,</span>
<a href="#l4.129"></a><span id="l4.129">         },</span>
<a href="#l4.130"></a><span id="l4.130">       },</span>
<a href="#l4.131"></a><span id="l4.131"> </span>
<a href="#l4.132"></a><span id="l4.132">       conversations: {</span>
<a href="#l4.133"></a><span id="l4.133" class="difflineat">@@ -318,16 +356,17 @@ var GlodaDatastore = {</span>
<a href="#l4.134"></a><span id="l4.134">           &quot;messageKey INTEGER&quot;,</span>
<a href="#l4.135"></a><span id="l4.135">           &quot;conversationID INTEGER NOT NULL REFERENCES conversations(id)&quot;,</span>
<a href="#l4.136"></a><span id="l4.136">           &quot;date INTEGER&quot;,</span>
<a href="#l4.137"></a><span id="l4.137">           // we used to have the parentID, but because of the very real</span>
<a href="#l4.138"></a><span id="l4.138">           //  possibility of multiple copies of a message with a given</span>
<a href="#l4.139"></a><span id="l4.139">           //  message-id, the parentID concept is unreliable.</span>
<a href="#l4.140"></a><span id="l4.140">           &quot;headerMessageID TEXT&quot;,</span>
<a href="#l4.141"></a><span id="l4.141">           &quot;deleted INTEGER NOT NULL default 0&quot;,</span>
<a href="#l4.142"></a><span id="l4.142" class="difflineplus">+          &quot;jsonAttributes TEXT&quot;,</span>
<a href="#l4.143"></a><span id="l4.143">         ],</span>
<a href="#l4.144"></a><span id="l4.144"> </span>
<a href="#l4.145"></a><span id="l4.145">         indices: {</span>
<a href="#l4.146"></a><span id="l4.146">           messageLocation: ['folderID', 'messageKey'],</span>
<a href="#l4.147"></a><span id="l4.147">           headerMessageID: ['headerMessageID'],</span>
<a href="#l4.148"></a><span id="l4.148">           conversationID: ['conversationID'],</span>
<a href="#l4.149"></a><span id="l4.149">           date: ['date'],</span>
<a href="#l4.150"></a><span id="l4.150">           deleted: ['deleted'],</span>
<a href="#l4.151"></a><span id="l4.151" class="difflineat">@@ -366,22 +405,16 @@ var GlodaDatastore = {</span>
<a href="#l4.152"></a><span id="l4.152">           &quot;attributeID INTEGER NOT NULL REFERENCES attributeDefinitions(id)&quot;,</span>
<a href="#l4.153"></a><span id="l4.153">           &quot;value NUMERIC&quot;,</span>
<a href="#l4.154"></a><span id="l4.154">         ],</span>
<a href="#l4.155"></a><span id="l4.155"> </span>
<a href="#l4.156"></a><span id="l4.156">         indices: {</span>
<a href="#l4.157"></a><span id="l4.157">           attribQuery: [</span>
<a href="#l4.158"></a><span id="l4.158">             &quot;attributeID&quot;, &quot;value&quot;,</span>
<a href="#l4.159"></a><span id="l4.159">             /* covering: */ &quot;conversationID&quot;, &quot;messageID&quot;],</span>
<a href="#l4.160"></a><span id="l4.160" class="difflineminus">-          messageAttribFetch: [</span>
<a href="#l4.161"></a><span id="l4.161" class="difflineminus">-            &quot;messageID&quot;,</span>
<a href="#l4.162"></a><span id="l4.162" class="difflineminus">-            /* covering required: */ &quot;attributeID&quot;, &quot;value&quot;],</span>
<a href="#l4.163"></a><span id="l4.163" class="difflineminus">-          conversationAttribFetch: [</span>
<a href="#l4.164"></a><span id="l4.164" class="difflineminus">-            &quot;conversationID&quot;,</span>
<a href="#l4.165"></a><span id="l4.165" class="difflineminus">-            /* covering: */ &quot;messageID&quot;, &quot;attributeID&quot;, &quot;value&quot;],</span>
<a href="#l4.166"></a><span id="l4.166">         },</span>
<a href="#l4.167"></a><span id="l4.167">       },</span>
<a href="#l4.168"></a><span id="l4.168"> </span>
<a href="#l4.169"></a><span id="l4.169">       // ----- Contacts / Identities</span>
<a href="#l4.170"></a><span id="l4.170"> </span>
<a href="#l4.171"></a><span id="l4.171">       /**</span>
<a href="#l4.172"></a><span id="l4.172">        * Corresponds to a human being and roughly to an address book entry.</span>
<a href="#l4.173"></a><span id="l4.173">        *  Constrast with an identity, which is a specific e-mail address, IRC</span>
<a href="#l4.174"></a><span id="l4.174" class="difflineat">@@ -390,17 +423,18 @@ var GlodaDatastore = {</span>
<a href="#l4.175"></a><span id="l4.175">        */</span>
<a href="#l4.176"></a><span id="l4.176">       contacts: {</span>
<a href="#l4.177"></a><span id="l4.177">         columns: [</span>
<a href="#l4.178"></a><span id="l4.178">           &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l4.179"></a><span id="l4.179">           &quot;directoryUUID TEXT&quot;,</span>
<a href="#l4.180"></a><span id="l4.180">           &quot;contactUUID TEXT&quot;,</span>
<a href="#l4.181"></a><span id="l4.181">           &quot;popularity INTEGER&quot;,</span>
<a href="#l4.182"></a><span id="l4.182">           &quot;frecency INTEGER&quot;,</span>
<a href="#l4.183"></a><span id="l4.183" class="difflineminus">-          &quot;name TEXT&quot;</span>
<a href="#l4.184"></a><span id="l4.184" class="difflineplus">+          &quot;name TEXT&quot;,</span>
<a href="#l4.185"></a><span id="l4.185" class="difflineplus">+          &quot;jsonAttributes TEXT&quot;,</span>
<a href="#l4.186"></a><span id="l4.186">         ],</span>
<a href="#l4.187"></a><span id="l4.187">         indices: {</span>
<a href="#l4.188"></a><span id="l4.188">           popularity: [&quot;popularity&quot;],</span>
<a href="#l4.189"></a><span id="l4.189">           frecency: [&quot;frecency&quot;],</span>
<a href="#l4.190"></a><span id="l4.190">         },</span>
<a href="#l4.191"></a><span id="l4.191">       },</span>
<a href="#l4.192"></a><span id="l4.192"> </span>
<a href="#l4.193"></a><span id="l4.193">       contactAttributes: {</span>
<a href="#l4.194"></a><span id="l4.194" class="difflineat">@@ -408,19 +442,16 @@ var GlodaDatastore = {</span>
<a href="#l4.195"></a><span id="l4.195">           &quot;contactID INTEGER NOT NULL REFERENCES contacts(id)&quot;,</span>
<a href="#l4.196"></a><span id="l4.196">           &quot;attributeID INTEGER NOT NULL REFERENCES attributeDefinitions(id)&quot;,</span>
<a href="#l4.197"></a><span id="l4.197">           &quot;value NUMERIC&quot;</span>
<a href="#l4.198"></a><span id="l4.198">         ],</span>
<a href="#l4.199"></a><span id="l4.199">         indices: {</span>
<a href="#l4.200"></a><span id="l4.200">           contactAttribQuery: [</span>
<a href="#l4.201"></a><span id="l4.201">             &quot;attributeID&quot;, &quot;value&quot;,</span>
<a href="#l4.202"></a><span id="l4.202">             /* covering: */ &quot;contactID&quot;],</span>
<a href="#l4.203"></a><span id="l4.203" class="difflineminus">-          contactAttribFetch: [</span>
<a href="#l4.204"></a><span id="l4.204" class="difflineminus">-            &quot;contactID&quot;,</span>
<a href="#l4.205"></a><span id="l4.205" class="difflineminus">-            /* covering */ &quot;attributeID&quot;, &quot;value&quot;]</span>
<a href="#l4.206"></a><span id="l4.206">         }</span>
<a href="#l4.207"></a><span id="l4.207">       },</span>
<a href="#l4.208"></a><span id="l4.208"> </span>
<a href="#l4.209"></a><span id="l4.209">       /**</span>
<a href="#l4.210"></a><span id="l4.210">        * Identities correspond to specific e-mail addresses, IRC nicks, etc.</span>
<a href="#l4.211"></a><span id="l4.211">        */</span>
<a href="#l4.212"></a><span id="l4.212">       identities: {</span>
<a href="#l4.213"></a><span id="l4.213">         columns: [</span>
<a href="#l4.214"></a><span id="l4.214" class="difflineat">@@ -460,18 +491,20 @@ var GlodaDatastore = {</span>
<a href="#l4.215"></a><span id="l4.215">    */</span>
<a href="#l4.216"></a><span id="l4.216">   asyncConnection: null,</span>
<a href="#l4.217"></a><span id="l4.217"> </span>
<a href="#l4.218"></a><span id="l4.218">   /**</span>
<a href="#l4.219"></a><span id="l4.219">    * Initialize logging, create the database if it doesn't exist, &quot;upgrade&quot; it</span>
<a href="#l4.220"></a><span id="l4.220">    *  if it does and it's not up-to-date, fill our authoritative folder uri/id</span>
<a href="#l4.221"></a><span id="l4.221">    *  mapping.</span>
<a href="#l4.222"></a><span id="l4.222">    */</span>
<a href="#l4.223"></a><span id="l4.223" class="difflineminus">-  _init: function gloda_ds_init() {</span>
<a href="#l4.224"></a><span id="l4.224" class="difflineplus">+  _init: function gloda_ds_init(aNsJSON) {</span>
<a href="#l4.225"></a><span id="l4.225">     this._log = Log4Moz.Service.getLogger(&quot;gloda.datastore&quot;);</span>
<a href="#l4.226"></a><span id="l4.226" class="difflineplus">+    </span>
<a href="#l4.227"></a><span id="l4.227" class="difflineplus">+    this._json = aNsJSON;</span>
<a href="#l4.228"></a><span id="l4.228"> </span>
<a href="#l4.229"></a><span id="l4.229">     // Get the path to our global database</span>
<a href="#l4.230"></a><span id="l4.230">     var dirService = Cc[&quot;@mozilla.org/file/directory_service;1&quot;].</span>
<a href="#l4.231"></a><span id="l4.231">                      getService(Ci.nsIProperties);</span>
<a href="#l4.232"></a><span id="l4.232">     var dbFile = dirService.get(&quot;ProfD&quot;, Ci.nsIFile);</span>
<a href="#l4.233"></a><span id="l4.233">     dbFile.append(&quot;global-messages-db.sqlite&quot;);</span>
<a href="#l4.234"></a><span id="l4.234"> </span>
<a href="#l4.235"></a><span id="l4.235">     // Get the storage (sqlite) service</span>
<a href="#l4.236"></a><span id="l4.236" class="difflineat">@@ -668,16 +701,32 @@ var GlodaDatastore = {</span>
<a href="#l4.237"></a><span id="l4.237">       aDBFile.remove(false);</span>
<a href="#l4.238"></a><span id="l4.238">       this._log.warn(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l4.239"></a><span id="l4.239">       return this._createDB(aDBService, aDBFile);</span>
<a href="#l4.240"></a><span id="l4.240">     }</span>
<a href="#l4.241"></a><span id="l4.241">     // version 9 just adds the contactAttributes table</span>
<a href="#l4.242"></a><span id="l4.242">     if (aCurVersion &lt; 9) {</span>
<a href="#l4.243"></a><span id="l4.243">       this._createTableSchema(aDBConnection, &quot;contactAttributes&quot;);</span>
<a href="#l4.244"></a><span id="l4.244">     }</span>
<a href="#l4.245"></a><span id="l4.245" class="difflineplus">+    // version 10:</span>
<a href="#l4.246"></a><span id="l4.246" class="difflineplus">+    // we have so many changes here, not to mention semantic changes, that</span>
<a href="#l4.247"></a><span id="l4.247" class="difflineplus">+    //  purging is the right answer.</span>
<a href="#l4.248"></a><span id="l4.248" class="difflineplus">+    // - adds dirtyStatus, name to folderLocations</span>
<a href="#l4.249"></a><span id="l4.249" class="difflineplus">+    // - removes messageAttribFetch index from messageAttributes</span>
<a href="#l4.250"></a><span id="l4.250" class="difflineplus">+    // - removes conversationAttribFetch index from messageAttributes</span>
<a href="#l4.251"></a><span id="l4.251" class="difflineplus">+    // - removes contactAttribFetch index from contactAttributes</span>
<a href="#l4.252"></a><span id="l4.252" class="difflineplus">+    // - adds jsonAttributes column to messages table</span>
<a href="#l4.253"></a><span id="l4.253" class="difflineplus">+    // - adds jsonAttributes column to contacts table</span>
<a href="#l4.254"></a><span id="l4.254" class="difflineplus">+    if (aCurVersion &lt; 10) {</span>
<a href="#l4.255"></a><span id="l4.255" class="difflineplus">+      aDBConnection.close();</span>
<a href="#l4.256"></a><span id="l4.256" class="difflineplus">+      aDBFile.remove(false);</span>
<a href="#l4.257"></a><span id="l4.257" class="difflineplus">+      this._log.warn(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l4.258"></a><span id="l4.258" class="difflineplus">+      return this._createDB(aDBService, aDBFile);</span>
<a href="#l4.259"></a><span id="l4.259" class="difflineplus">+    }</span>
<a href="#l4.260"></a><span id="l4.260" class="difflineplus">+    </span>
<a href="#l4.261"></a><span id="l4.261">     aDBConnection.schemaVersion = aNewVersion;</span>
<a href="#l4.262"></a><span id="l4.262">     </span>
<a href="#l4.263"></a><span id="l4.263">     return aDBConnection;</span>
<a href="#l4.264"></a><span id="l4.264">   },</span>
<a href="#l4.265"></a><span id="l4.265"> </span>
<a href="#l4.266"></a><span id="l4.266">   _outstandingAsyncStatements: [],</span>
<a href="#l4.267"></a><span id="l4.267"> </span>
<a href="#l4.268"></a><span id="l4.268">   _createAsyncStatement: function gloda_ds_createAsyncStatement(aSQLString,</span>
<a href="#l4.269"></a><span id="l4.269" class="difflineat">@@ -812,46 +861,58 @@ var GlodaDatastore = {</span>
<a href="#l4.270"></a><span id="l4.270">   },</span>
<a href="#l4.271"></a><span id="l4.271"> </span>
<a href="#l4.272"></a><span id="l4.272">   get _rollbackTransactionStatement() {</span>
<a href="#l4.273"></a><span id="l4.273">     let statement = this._createAsyncStatement(&quot;ROLLBACK&quot;);</span>
<a href="#l4.274"></a><span id="l4.274">     this.__defineGetter__(&quot;_rollbackTransactionStatement&quot;, function() statement);</span>
<a href="#l4.275"></a><span id="l4.275">     return this._rollbackTransactionStatement;</span>
<a href="#l4.276"></a><span id="l4.276">   },</span>
<a href="#l4.277"></a><span id="l4.277"> </span>
<a href="#l4.278"></a><span id="l4.278" class="difflineplus">+  _pendingPostCommitCallbacks: null,</span>
<a href="#l4.279"></a><span id="l4.279" class="difflineplus">+  /**</span>
<a href="#l4.280"></a><span id="l4.280" class="difflineplus">+   * Register a callback to be invoked when the current transaction's commit</span>
<a href="#l4.281"></a><span id="l4.281" class="difflineplus">+   *  completes.</span>
<a href="#l4.282"></a><span id="l4.282" class="difflineplus">+   */</span>
<a href="#l4.283"></a><span id="l4.283" class="difflineplus">+  runPostCommit: function gloda_ds_runPostCommit(aCallback) {</span>
<a href="#l4.284"></a><span id="l4.284" class="difflineplus">+    this._pendingPostCommitCallbacks.push(aCallback);</span>
<a href="#l4.285"></a><span id="l4.285" class="difflineplus">+  },</span>
<a href="#l4.286"></a><span id="l4.286" class="difflineplus">+</span>
<a href="#l4.287"></a><span id="l4.287">   /**</span>
<a href="#l4.288"></a><span id="l4.288">    * Begin a potentially nested transaction; only the outermost transaction gets</span>
<a href="#l4.289"></a><span id="l4.289">    *  to be an actual transaction, and the failure of any nested transaction</span>
<a href="#l4.290"></a><span id="l4.290">    *  results in a rollback of the entire outer transaction.  If you really</span>
<a href="#l4.291"></a><span id="l4.291">    *  need an atomic transaction</span>
<a href="#l4.292"></a><span id="l4.292">    */</span>
<a href="#l4.293"></a><span id="l4.293">   _beginTransaction: function gloda_ds_beginTransaction() {</span>
<a href="#l4.294"></a><span id="l4.294">     if (this._transactionDepth == 0) {</span>
<a href="#l4.295"></a><span id="l4.295" class="difflineplus">+      this._pendingPostCommitCallbacks = [];</span>
<a href="#l4.296"></a><span id="l4.296">       this._beginTransactionStatement.executeAsync(this.trackAsync());</span>
<a href="#l4.297"></a><span id="l4.297">       this._transactionGood = true;</span>
<a href="#l4.298"></a><span id="l4.298">     }</span>
<a href="#l4.299"></a><span id="l4.299">     this._transactionDepth++;</span>
<a href="#l4.300"></a><span id="l4.300">   },</span>
<a href="#l4.301"></a><span id="l4.301">   /**</span>
<a href="#l4.302"></a><span id="l4.302">    * Commit a potentially nested transaction; if we are the outer-most</span>
<a href="#l4.303"></a><span id="l4.303">    *  transaction and no sub-transaction issues a rollback</span>
<a href="#l4.304"></a><span id="l4.304">    *  (via _rollbackTransaction) then we commit, otherwise we rollback.</span>
<a href="#l4.305"></a><span id="l4.305">    */</span>
<a href="#l4.306"></a><span id="l4.306">   _commitTransaction: function gloda_ds_commitTransaction() {</span>
<a href="#l4.307"></a><span id="l4.307">     this._transactionDepth--;</span>
<a href="#l4.308"></a><span id="l4.308">     if (this._transactionDepth == 0) {</span>
<a href="#l4.309"></a><span id="l4.309">       try {</span>
<a href="#l4.310"></a><span id="l4.310">         if (this._transactionGood)</span>
<a href="#l4.311"></a><span id="l4.311" class="difflineminus">-          this._commitTransactionStatement.executeAsync(this.trackAsync());</span>
<a href="#l4.312"></a><span id="l4.312" class="difflineplus">+          this._commitTransactionStatement.executeAsync(</span>
<a href="#l4.313"></a><span id="l4.313" class="difflineplus">+            new PostCommitHandler(this._pendingPostCommitCallbacks));</span>
<a href="#l4.314"></a><span id="l4.314">         else</span>
<a href="#l4.315"></a><span id="l4.315">           this._rollbackTransaction.executeAsync(this.trackAsync());</span>
<a href="#l4.316"></a><span id="l4.316">       }</span>
<a href="#l4.317"></a><span id="l4.317">       catch (ex) {</span>
<a href="#l4.318"></a><span id="l4.318">         this._log.error(&quot;Commit problem: &quot; + ex);</span>
<a href="#l4.319"></a><span id="l4.319">       }</span>
<a href="#l4.320"></a><span id="l4.320" class="difflineplus">+      this._pendingPostCommitCallbacks = [];</span>
<a href="#l4.321"></a><span id="l4.321">     }</span>
<a href="#l4.322"></a><span id="l4.322">   },</span>
<a href="#l4.323"></a><span id="l4.323">   /**</span>
<a href="#l4.324"></a><span id="l4.324">    * Abort the commit of the potentially nested transaction.  If we are not the</span>
<a href="#l4.325"></a><span id="l4.325">    *  outermost transaction, we set a flag that tells the outermost transaction</span>
<a href="#l4.326"></a><span id="l4.326">    *  that it must roll back.</span>
<a href="#l4.327"></a><span id="l4.327">    */</span>
<a href="#l4.328"></a><span id="l4.328">   _rollbackTransaction: function gloda_ds_rollbackTransaction() {</span>
<a href="#l4.329"></a><span id="l4.329" class="difflineat">@@ -1019,104 +1080,137 @@ var GlodaDatastore = {</span>
<a href="#l4.330"></a><span id="l4.330">   },</span>
<a href="#l4.331"></a><span id="l4.331"> </span>
<a href="#l4.332"></a><span id="l4.332">   /* ********** Folders ********** */</span>
<a href="#l4.333"></a><span id="l4.333">   /** next folder (row) id to issue, populated by _getAllFolderMappings. */</span>
<a href="#l4.334"></a><span id="l4.334">   _nextFolderId: 1,</span>
<a href="#l4.335"></a><span id="l4.335"> </span>
<a href="#l4.336"></a><span id="l4.336">   get _insertFolderLocationStatement() {</span>
<a href="#l4.337"></a><span id="l4.337">     let statement = this._createAsyncStatement(</span>
<a href="#l4.338"></a><span id="l4.338" class="difflineminus">-      &quot;INSERT INTO folderLocations (id, folderURI) VALUES (?1, ?2)&quot;);</span>
<a href="#l4.339"></a><span id="l4.339" class="difflineplus">+      &quot;INSERT INTO folderLocations (id, folderURI, dirtyStatus, name) VALUES \</span>
<a href="#l4.340"></a><span id="l4.340" class="difflineplus">+        (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l4.341"></a><span id="l4.341">     this.__defineGetter__(&quot;_insertFolderLocationStatement&quot;,</span>
<a href="#l4.342"></a><span id="l4.342">       function() statement);</span>
<a href="#l4.343"></a><span id="l4.343">     return this._insertFolderLocationStatement;</span>
<a href="#l4.344"></a><span id="l4.344">   },</span>
<a href="#l4.345"></a><span id="l4.345"> </span>
<a href="#l4.346"></a><span id="l4.346">   /**</span>
<a href="#l4.347"></a><span id="l4.347">    * Authoritative map from folder URI to folder ID.  (Authoritative in the</span>
<a href="#l4.348"></a><span id="l4.348">    *  sense that this map exactly represents the state of the underlying</span>
<a href="#l4.349"></a><span id="l4.349">    *  database.  If it does not, it's a bug in updating the database.)</span>
<a href="#l4.350"></a><span id="l4.350">    */</span>
<a href="#l4.351"></a><span id="l4.351" class="difflineminus">-  _folderURIs: {},</span>
<a href="#l4.352"></a><span id="l4.352" class="difflineplus">+  _folderByURI: {},</span>
<a href="#l4.353"></a><span id="l4.353">   /** Authoritative map from folder ID to folder URI */</span>
<a href="#l4.354"></a><span id="l4.354" class="difflineminus">-  _folderIDs: {},</span>
<a href="#l4.355"></a><span id="l4.355" class="difflineplus">+  _folderByID: {},</span>
<a href="#l4.356"></a><span id="l4.356"> </span>
<a href="#l4.357"></a><span id="l4.357" class="difflineminus">-  /** Intialize our _folderURIs/_folderIDs mappings, called by _init(). */</span>
<a href="#l4.358"></a><span id="l4.358" class="difflineplus">+  /** Intialize our _folderByURI/_folderByID mappings, called by _init(). */</span>
<a href="#l4.359"></a><span id="l4.359">   _getAllFolderMappings: function gloda_ds_getAllFolderMappings() {</span>
<a href="#l4.360"></a><span id="l4.360">     let stmt = this._createSyncStatement(</span>
<a href="#l4.361"></a><span id="l4.361" class="difflineminus">-      &quot;SELECT id, folderURI FROM folderLocations&quot;, true);</span>
<a href="#l4.362"></a><span id="l4.362" class="difflineplus">+      &quot;SELECT id, folderURI, dirtyStatus, name FROM folderLocations&quot;, true);</span>
<a href="#l4.363"></a><span id="l4.363"> </span>
<a href="#l4.364"></a><span id="l4.364">     while (stmt.executeStep()) {  // no chance of this SQLITE_BUSY on this call</span>
<a href="#l4.365"></a><span id="l4.365">       let folderID = stmt.getInt64(0);</span>
<a href="#l4.366"></a><span id="l4.366">       let folderURI = stmt.getString(1);</span>
<a href="#l4.367"></a><span id="l4.367" class="difflineminus">-      this._folderURIs[folderURI] = folderID;</span>
<a href="#l4.368"></a><span id="l4.368" class="difflineminus">-      this._folderIDs[folderID] = folderURI;</span>
<a href="#l4.369"></a><span id="l4.369" class="difflineplus">+      let dirtyStatus = stmt.getInt32(2);</span>
<a href="#l4.370"></a><span id="l4.370" class="difflineplus">+      let folderName = stmt.getString(3);</span>
<a href="#l4.371"></a><span id="l4.371" class="difflineplus">+      </span>
<a href="#l4.372"></a><span id="l4.372" class="difflineplus">+      let folder = new GlodaFolder(this, folderID, folderURI, dirtyStatus,</span>
<a href="#l4.373"></a><span id="l4.373" class="difflineplus">+                                   folderName);</span>
<a href="#l4.374"></a><span id="l4.374" class="difflineplus">+      </span>
<a href="#l4.375"></a><span id="l4.375" class="difflineplus">+      this._folderByURI[folderURI] = folder;</span>
<a href="#l4.376"></a><span id="l4.376" class="difflineplus">+      this._folderByID[folderID] = folder;</span>
<a href="#l4.377"></a><span id="l4.377"> </span>
<a href="#l4.378"></a><span id="l4.378" class="difflineminus">-      if (folderID + 1 &gt; this._nextFolderId)</span>
<a href="#l4.379"></a><span id="l4.379" class="difflineplus">+      if (folderID &gt;= this._nextFolderId)</span>
<a href="#l4.380"></a><span id="l4.380">         this._nextFolderId = folderID + 1;</span>
<a href="#l4.381"></a><span id="l4.381">     }</span>
<a href="#l4.382"></a><span id="l4.382">     stmt.finalize();</span>
<a href="#l4.383"></a><span id="l4.383">   },</span>
<a href="#l4.384"></a><span id="l4.384"> </span>
<a href="#l4.385"></a><span id="l4.385" class="difflineminus">-  _folderURIKnown: function gloda_ds_folderURIKnown(aFolderURI) {</span>
<a href="#l4.386"></a><span id="l4.386" class="difflineminus">-    return aFolderURI in this._folderURIs;</span>
<a href="#l4.387"></a><span id="l4.387" class="difflineplus">+  _folderKnown: function gloda_ds_folderKnown(aFolder) {</span>
<a href="#l4.388"></a><span id="l4.388" class="difflineplus">+    let folderURI = aFolder.URI;</span>
<a href="#l4.389"></a><span id="l4.389" class="difflineplus">+    return folderURI in this._folderByURI;</span>
<a href="#l4.390"></a><span id="l4.390">   },</span>
<a href="#l4.391"></a><span id="l4.391"> </span>
<a href="#l4.392"></a><span id="l4.392">   /**</span>
<a href="#l4.393"></a><span id="l4.393">    * Map a folder URI to a folder ID, creating the mapping if it does not yet</span>
<a href="#l4.394"></a><span id="l4.394">    *  exist.</span>
<a href="#l4.395"></a><span id="l4.395">    */</span>
<a href="#l4.396"></a><span id="l4.396" class="difflineminus">-  _mapFolderURI: function gloda_ds_mapFolderURI(aFolderURI) {</span>
<a href="#l4.397"></a><span id="l4.397" class="difflineminus">-    if (aFolderURI in this._folderURIs) {</span>
<a href="#l4.398"></a><span id="l4.398" class="difflineminus">-      return this._folderURIs[aFolderURI];</span>
<a href="#l4.399"></a><span id="l4.399" class="difflineplus">+  _mapFolder: function gloda_ds_mapFolderURI(aFolder) {</span>
<a href="#l4.400"></a><span id="l4.400" class="difflineplus">+    let folderURI = aFolder.URI;</span>
<a href="#l4.401"></a><span id="l4.401" class="difflineplus">+    if (folderURI in this._folderByURI) {</span>
<a href="#l4.402"></a><span id="l4.402" class="difflineplus">+      return this._folderByURI[folderURI];</span>
<a href="#l4.403"></a><span id="l4.403">     }</span>
<a href="#l4.404"></a><span id="l4.404"> </span>
<a href="#l4.405"></a><span id="l4.405">     let folderID = this._nextFolderId++;</span>
<a href="#l4.406"></a><span id="l4.406" class="difflineminus">-    this._insertFolderLocationStatement.bindInt64Parameter(0, folderID)</span>
<a href="#l4.407"></a><span id="l4.407" class="difflineminus">-    this._insertFolderLocationStatement.bindStringParameter(1, aFolderURI);</span>
<a href="#l4.408"></a><span id="l4.408" class="difflineplus">+    </span>
<a href="#l4.409"></a><span id="l4.409" class="difflineplus">+    let folder = new GlodaFolder(this, folderID, folderURI,</span>
<a href="#l4.410"></a><span id="l4.410" class="difflineplus">+      GlodaFolder.prototype.kFolderFilthy, aFolder.prettyName);</span>
<a href="#l4.411"></a><span id="l4.411" class="difflineplus">+    </span>
<a href="#l4.412"></a><span id="l4.412" class="difflineplus">+    this._insertFolderLocationStatement.bindInt64Parameter(0, folder.id)</span>
<a href="#l4.413"></a><span id="l4.413" class="difflineplus">+    this._insertFolderLocationStatement.bindStringParameter(1, folder.uri);</span>
<a href="#l4.414"></a><span id="l4.414" class="difflineplus">+    this._insertFolderLocationStatement.bindInt64Parameter(2,</span>
<a href="#l4.415"></a><span id="l4.415" class="difflineplus">+                                                           folder.dirtyStatus);</span>
<a href="#l4.416"></a><span id="l4.416" class="difflineplus">+    this._insertFolderLocationStatement.bindStringParameter(3, folder.name);</span>
<a href="#l4.417"></a><span id="l4.417">     this._insertFolderLocationStatement.executeAsync(this.trackAsync());</span>
<a href="#l4.418"></a><span id="l4.418"> </span>
<a href="#l4.419"></a><span id="l4.419" class="difflineminus">-    this._folderURIs[aFolderURI] = folderID;</span>
<a href="#l4.420"></a><span id="l4.420" class="difflineminus">-    this._folderIDs[folderID] = aFolderURI;</span>
<a href="#l4.421"></a><span id="l4.421" class="difflineminus">-    this._log.info(&quot;mapping URI &quot; + aFolderURI + &quot; to &quot; + folderID);</span>
<a href="#l4.422"></a><span id="l4.422" class="difflineminus">-    return folderID;</span>
<a href="#l4.423"></a><span id="l4.423" class="difflineplus">+    this._folderByURI[aFolderURI] = folder;</span>
<a href="#l4.424"></a><span id="l4.424" class="difflineplus">+    this._folderByID[folderID] = folder;</span>
<a href="#l4.425"></a><span id="l4.425" class="difflineplus">+    return folder;</span>
<a href="#l4.426"></a><span id="l4.426">   },</span>
<a href="#l4.427"></a><span id="l4.427"> </span>
<a href="#l4.428"></a><span id="l4.428">   _mapFolderID: function gloda_ds_mapFolderID(aFolderID) {</span>
<a href="#l4.429"></a><span id="l4.429">     if (aFolderID === null)</span>
<a href="#l4.430"></a><span id="l4.430">       return null;</span>
<a href="#l4.431"></a><span id="l4.431" class="difflineminus">-    if (aFolderID in this._folderIDs)</span>
<a href="#l4.432"></a><span id="l4.432" class="difflineminus">-      return this._folderIDs[aFolderID];</span>
<a href="#l4.433"></a><span id="l4.433" class="difflineplus">+    if (aFolderID in this._folderByID)</span>
<a href="#l4.434"></a><span id="l4.434" class="difflineplus">+      return this._folderByID[aFolderID];</span>
<a href="#l4.435"></a><span id="l4.435">     throw &quot;Got impossible folder ID: &quot; + aFolderID;</span>
<a href="#l4.436"></a><span id="l4.436">   },</span>
<a href="#l4.437"></a><span id="l4.437"> </span>
<a href="#l4.438"></a><span id="l4.438" class="difflineplus">+  get _updateFolderDirtyStatusStatement() {</span>
<a href="#l4.439"></a><span id="l4.439" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l4.440"></a><span id="l4.440" class="difflineplus">+      &quot;UPDATE folderLocations SET dirtyStatus = ?1 \</span>
<a href="#l4.441"></a><span id="l4.441" class="difflineplus">+              WHERE id = ?2&quot;);</span>
<a href="#l4.442"></a><span id="l4.442" class="difflineplus">+    this.__defineGetter__(&quot;_updateFolderDirtyStatusStatement&quot;,</span>
<a href="#l4.443"></a><span id="l4.443" class="difflineplus">+      function() statement);</span>
<a href="#l4.444"></a><span id="l4.444" class="difflineplus">+    return this._updateFolderDirtyStatusStatement;</span>
<a href="#l4.445"></a><span id="l4.445" class="difflineplus">+  },</span>
<a href="#l4.446"></a><span id="l4.446" class="difflineplus">+</span>
<a href="#l4.447"></a><span id="l4.447" class="difflineplus">+  updateFolderDirtyStatus: function gloda_ds_updateFolderDirtyStatus(aFolder) {</span>
<a href="#l4.448"></a><span id="l4.448" class="difflineplus">+    let ufds = this._updateFolderDirtyStatusStatement;</span>
<a href="#l4.449"></a><span id="l4.449" class="difflineplus">+    ufds.bindInt64Parameter(1, folder.id);</span>
<a href="#l4.450"></a><span id="l4.450" class="difflineplus">+    ufds.bindInt64Parameter(0, folder.dirtyStatus);</span>
<a href="#l4.451"></a><span id="l4.451" class="difflineplus">+    ufds.executeAsync(this.trackAsync());</span>
<a href="#l4.452"></a><span id="l4.452" class="difflineplus">+  },</span>
<a href="#l4.453"></a><span id="l4.453" class="difflineplus">+</span>
<a href="#l4.454"></a><span id="l4.454">   get _updateFolderLocationStatement() {</span>
<a href="#l4.455"></a><span id="l4.455">     let statement = this._createAsyncStatement(</span>
<a href="#l4.456"></a><span id="l4.456">       &quot;UPDATE folderLocations SET folderURI = ?1 \</span>
<a href="#l4.457"></a><span id="l4.457" class="difflineminus">-              WHERE folderURI = ?2&quot;);</span>
<a href="#l4.458"></a><span id="l4.458" class="difflineplus">+              WHERE id = ?2&quot;);</span>
<a href="#l4.459"></a><span id="l4.459">     this.__defineGetter__(&quot;_updateFolderLocationStatement&quot;,</span>
<a href="#l4.460"></a><span id="l4.460">       function() statement);</span>
<a href="#l4.461"></a><span id="l4.461">     return this._updateFolderLocationStatement;</span>
<a href="#l4.462"></a><span id="l4.462">   },</span>
<a href="#l4.463"></a><span id="l4.463"> </span>
<a href="#l4.464"></a><span id="l4.464">   /**</span>
<a href="#l4.465"></a><span id="l4.465">    * Non-recursive asynchronous folder renaming based on the URI.</span>
<a href="#l4.466"></a><span id="l4.466">    *</span>
<a href="#l4.467"></a><span id="l4.467">    * @TODO provide a mechanism for recursive folder renames or have a higher</span>
<a href="#l4.468"></a><span id="l4.468">    *     layer deal with it and remove this note.</span>
<a href="#l4.469"></a><span id="l4.469">    */</span>
<a href="#l4.470"></a><span id="l4.470" class="difflineminus">-  renameFolder: function gloda_ds_renameFolder(aOldURI, aNewURI) {</span>
<a href="#l4.471"></a><span id="l4.471" class="difflineminus">-    let folderID = this._mapFolderURI(aOldURI); // ensure the URI is mapped...</span>
<a href="#l4.472"></a><span id="l4.472" class="difflineminus">-    this._folderURIs[aNewURI] = folderID;</span>
<a href="#l4.473"></a><span id="l4.473" class="difflineminus">-    this._folderIDs[folderID] = aNewURI;</span>
<a href="#l4.474"></a><span id="l4.474" class="difflineminus">-    this._log.info(&quot;renaming folder URI &quot; + aOldURI + &quot; to &quot; + aNewURI);</span>
<a href="#l4.475"></a><span id="l4.475" class="difflineminus">-    this._updateFolderLocationStatement.bindStringParameter(1, aOldURI);</span>
<a href="#l4.476"></a><span id="l4.476" class="difflineplus">+  renameFolder: function gloda_ds_renameFolder(aOldFolder, aNewURI) {</span>
<a href="#l4.477"></a><span id="l4.477" class="difflineplus">+    let folder = this._mapFolder(aOldFolder); // ensure the folder is mapped</span>
<a href="#l4.478"></a><span id="l4.478" class="difflineplus">+    let oldURI = folder.uri; </span>
<a href="#l4.479"></a><span id="l4.479" class="difflineplus">+    this._folderByURI[aNewURI] = folder;</span>
<a href="#l4.480"></a><span id="l4.480" class="difflineplus">+    folder._uri = aNewURI;</span>
<a href="#l4.481"></a><span id="l4.481" class="difflineplus">+    this._log.info(&quot;renaming folder URI &quot; + oldURI + &quot; to &quot; + aNewURI);</span>
<a href="#l4.482"></a><span id="l4.482" class="difflineplus">+    this._updateFolderLocationStatement.bindStringParameter(1, folder.id);</span>
<a href="#l4.483"></a><span id="l4.483">     this._updateFolderLocationStatement.bindStringParameter(0, aNewURI);</span>
<a href="#l4.484"></a><span id="l4.484">     this._updateFolderLocationStatement.executeAsync(this.trackAsync());</span>
<a href="#l4.485"></a><span id="l4.485" class="difflineminus">-    delete this._folderURIs[aOldURI];</span>
<a href="#l4.486"></a><span id="l4.486" class="difflineplus">+    </span>
<a href="#l4.487"></a><span id="l4.487" class="difflineplus">+    delete this._folderByURI[oldURI];</span>
<a href="#l4.488"></a><span id="l4.488">   },</span>
<a href="#l4.489"></a><span id="l4.489"> </span>
<a href="#l4.490"></a><span id="l4.490">   get _deleteFolderByIDStatement() {</span>
<a href="#l4.491"></a><span id="l4.491">     let statement = this._createAsyncStatement(</span>
<a href="#l4.492"></a><span id="l4.492">       &quot;DELETE FROM folderLocations WHERE id = ?1&quot;);</span>
<a href="#l4.493"></a><span id="l4.493">     this.__defineGetter__(&quot;_deleteFolderByIDStatement&quot;,</span>
<a href="#l4.494"></a><span id="l4.494">       function() statement);</span>
<a href="#l4.495"></a><span id="l4.495">     return this._deleteFolderByIDStatement;</span>
<a href="#l4.496"></a><span id="l4.496" class="difflineat">@@ -1275,18 +1369,18 @@ var GlodaDatastore = {</span>
<a href="#l4.497"></a><span id="l4.497">       this._nextMessageId = stmt.getInt64(0) + 1;</span>
<a href="#l4.498"></a><span id="l4.498">     }</span>
<a href="#l4.499"></a><span id="l4.499">     stmt.finalize();</span>
<a href="#l4.500"></a><span id="l4.500">   },</span>
<a href="#l4.501"></a><span id="l4.501"> </span>
<a href="#l4.502"></a><span id="l4.502">   get _insertMessageStatement() {</span>
<a href="#l4.503"></a><span id="l4.503">     let statement = this._createAsyncStatement(</span>
<a href="#l4.504"></a><span id="l4.504">       &quot;INSERT INTO messages (id, folderID, messageKey, conversationID, date, \</span>
<a href="#l4.505"></a><span id="l4.505" class="difflineminus">-                             headerMessageID) \</span>
<a href="#l4.506"></a><span id="l4.506" class="difflineminus">-              VALUES (?1, ?2, ?3, ?4, ?5, ?6)&quot;);</span>
<a href="#l4.507"></a><span id="l4.507" class="difflineplus">+                             headerMessageID, jsonAttributes) \</span>
<a href="#l4.508"></a><span id="l4.508" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)&quot;);</span>
<a href="#l4.509"></a><span id="l4.509">     this.__defineGetter__(&quot;_insertMessageStatement&quot;, function() statement);</span>
<a href="#l4.510"></a><span id="l4.510">     return this._insertMessageStatement;</span>
<a href="#l4.511"></a><span id="l4.511">   },</span>
<a href="#l4.512"></a><span id="l4.512"> </span>
<a href="#l4.513"></a><span id="l4.513">   get _insertMessageTextStatement() {</span>
<a href="#l4.514"></a><span id="l4.514">     let statement = this._createAsyncStatement(</span>
<a href="#l4.515"></a><span id="l4.515">       &quot;INSERT INTO messagesText (docid, subject, body, attachmentNames) \</span>
<a href="#l4.516"></a><span id="l4.516">               VALUES (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l4.517"></a><span id="l4.517" class="difflineat">@@ -1299,59 +1393,78 @@ var GlodaDatastore = {</span>
<a href="#l4.518"></a><span id="l4.518">    *  of the process of creating a message (the attributes still need to be</span>
<a href="#l4.519"></a><span id="l4.519">    *  completed), it's on the caller's head to call GlodaCollectionManager's</span>
<a href="#l4.520"></a><span id="l4.520">    *  itemAdded method once the message is fully created.</span>
<a href="#l4.521"></a><span id="l4.521">    *</span>
<a href="#l4.522"></a><span id="l4.522">    * This method uses the async connection, any downstream logic that depends on</span>
<a href="#l4.523"></a><span id="l4.523">    *  this message actually existing in the database must be done using an</span>
<a href="#l4.524"></a><span id="l4.524">    *  async query.</span>
<a href="#l4.525"></a><span id="l4.525">    */</span>
<a href="#l4.526"></a><span id="l4.526" class="difflineminus">-  createMessage: function gloda_ds_createMessage(aFolderURI, aMessageKey,</span>
<a href="#l4.527"></a><span id="l4.527" class="difflineplus">+  createMessage: function gloda_ds_createMessage(aFolder, aMessageKey,</span>
<a href="#l4.528"></a><span id="l4.528">                               aConversationID, aDatePRTime, aHeaderMessageID,</span>
<a href="#l4.529"></a><span id="l4.529">                               aSubject, aBody, aAttachmentNames) {</span>
<a href="#l4.530"></a><span id="l4.530">     let folderID;</span>
<a href="#l4.531"></a><span id="l4.531" class="difflineminus">-    if (aFolderURI != null) {</span>
<a href="#l4.532"></a><span id="l4.532" class="difflineminus">-      folderID = this._mapFolderURI(aFolderURI);</span>
<a href="#l4.533"></a><span id="l4.533" class="difflineplus">+    if (aFolder != null) {</span>
<a href="#l4.534"></a><span id="l4.534" class="difflineplus">+      folderID = this._mapFolder(aFolder).id;</span>
<a href="#l4.535"></a><span id="l4.535">     }</span>
<a href="#l4.536"></a><span id="l4.536">     else {</span>
<a href="#l4.537"></a><span id="l4.537">       folderID = null;</span>
<a href="#l4.538"></a><span id="l4.538">     }</span>
<a href="#l4.539"></a><span id="l4.539"> </span>
<a href="#l4.540"></a><span id="l4.540">     let messageID = this._nextMessageId++;</span>
<a href="#l4.541"></a><span id="l4.541"> </span>
<a href="#l4.542"></a><span id="l4.542" class="difflineplus">+    let message = new GlodaMessage(this, messageID, folderID,</span>
<a href="#l4.543"></a><span id="l4.543" class="difflineplus">+                            aMessageKey, aConversationID, null,</span>
<a href="#l4.544"></a><span id="l4.544" class="difflineplus">+                            aDatePRTime ? new Date(aDatePRTime / 1000) : null,</span>
<a href="#l4.545"></a><span id="l4.545" class="difflineplus">+                            aHeaderMessageID);</span>
<a href="#l4.546"></a><span id="l4.546" class="difflineplus">+</span>
<a href="#l4.547"></a><span id="l4.547" class="difflineplus">+    this._log.debug(&quot;CreateMessage: &quot; + folderID + &quot;, &quot; + aMessageKey + &quot;, &quot; +</span>
<a href="#l4.548"></a><span id="l4.548" class="difflineplus">+                    aConversationID + &quot;, &quot; + aDatePRTime + &quot;, &quot; +</span>
<a href="#l4.549"></a><span id="l4.549" class="difflineplus">+                    aHeaderMessageID);</span>
<a href="#l4.550"></a><span id="l4.550" class="difflineplus">+</span>
<a href="#l4.551"></a><span id="l4.551" class="difflineplus">+    // We would love to notify the collection manager about the message at this</span>
<a href="#l4.552"></a><span id="l4.552" class="difflineplus">+    //  point (at least if it's not a ghost), but we can't yet.  We need to wait</span>
<a href="#l4.553"></a><span id="l4.553" class="difflineplus">+    //  until the attributes have been indexed, which means it's out of our</span>
<a href="#l4.554"></a><span id="l4.554" class="difflineplus">+    //  hands.  (Gloda.processMessage does it.)</span>
<a href="#l4.555"></a><span id="l4.555" class="difflineplus">+</span>
<a href="#l4.556"></a><span id="l4.556" class="difflineplus">+    return message;</span>
<a href="#l4.557"></a><span id="l4.557" class="difflineplus">+  },</span>
<a href="#l4.558"></a><span id="l4.558" class="difflineplus">+  </span>
<a href="#l4.559"></a><span id="l4.559" class="difflineplus">+  insertMessage: function gloda_ds_insertMessage(aMessage) {</span>
<a href="#l4.560"></a><span id="l4.560" class="difflineplus">+</span>
<a href="#l4.561"></a><span id="l4.561">     let ims = this._insertMessageStatement;</span>
<a href="#l4.562"></a><span id="l4.562" class="difflineminus">-    ims.bindInt64Parameter(0, messageID);</span>
<a href="#l4.563"></a><span id="l4.563" class="difflineminus">-    if (folderID === null)</span>
<a href="#l4.564"></a><span id="l4.564" class="difflineplus">+    ims.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l4.565"></a><span id="l4.565" class="difflineplus">+    if (aMessage.folderID === null)</span>
<a href="#l4.566"></a><span id="l4.566">       ims.bindNullParameter(1);</span>
<a href="#l4.567"></a><span id="l4.567">     else</span>
<a href="#l4.568"></a><span id="l4.568" class="difflineminus">-      ims.bindInt64Parameter(1, folderID);</span>
<a href="#l4.569"></a><span id="l4.569" class="difflineminus">-    if (aMessageKey === null)</span>
<a href="#l4.570"></a><span id="l4.570" class="difflineplus">+      ims.bindInt64Parameter(1, aMessage.folderID);</span>
<a href="#l4.571"></a><span id="l4.571" class="difflineplus">+    if (aMessage.messageKey === null)</span>
<a href="#l4.572"></a><span id="l4.572">       ims.bindNullParameter(2);</span>
<a href="#l4.573"></a><span id="l4.573">     else</span>
<a href="#l4.574"></a><span id="l4.574" class="difflineminus">-      ims.bindInt64Parameter(2, aMessageKey);</span>
<a href="#l4.575"></a><span id="l4.575" class="difflineminus">-    ims.bindInt64Parameter(3, aConversationID);</span>
<a href="#l4.576"></a><span id="l4.576" class="difflineminus">-    if (aDatePRTime === null)</span>
<a href="#l4.577"></a><span id="l4.577" class="difflineplus">+      ims.bindInt64Parameter(2, aMessage.messageKey);</span>
<a href="#l4.578"></a><span id="l4.578" class="difflineplus">+    ims.bindInt64Parameter(3, aMessage.conversationID);</span>
<a href="#l4.579"></a><span id="l4.579" class="difflineplus">+    if (aMessage.date === null)</span>
<a href="#l4.580"></a><span id="l4.580">       ims.bindNullParameter(4);</span>
<a href="#l4.581"></a><span id="l4.581">     else</span>
<a href="#l4.582"></a><span id="l4.582" class="difflineminus">-      ims.bindInt64Parameter(4, aDatePRTime);</span>
<a href="#l4.583"></a><span id="l4.583" class="difflineminus">-    ims.bindStringParameter(5, aHeaderMessageID);</span>
<a href="#l4.584"></a><span id="l4.584" class="difflineplus">+      ims.bindInt64Parameter(4, aMessage.date * 1000);</span>
<a href="#l4.585"></a><span id="l4.585" class="difflineplus">+    ims.bindStringParameter(5, aMessage.headerMessageID);</span>
<a href="#l4.586"></a><span id="l4.586" class="difflineplus">+    if (aMessage._jsonText)</span>
<a href="#l4.587"></a><span id="l4.587" class="difflineplus">+      ims.bindStringParameter(6, aMessage._jsonText);</span>
<a href="#l4.588"></a><span id="l4.588" class="difflineplus">+    else</span>
<a href="#l4.589"></a><span id="l4.589" class="difflineplus">+      ims.bindNullParameter(6);</span>
<a href="#l4.590"></a><span id="l4.590"> </span>
<a href="#l4.591"></a><span id="l4.591">     try {</span>
<a href="#l4.592"></a><span id="l4.592">        ims.executeAsync(this.trackAsync());</span>
<a href="#l4.593"></a><span id="l4.593">     }</span>
<a href="#l4.594"></a><span id="l4.594">     catch(ex) {</span>
<a href="#l4.595"></a><span id="l4.595">        throw(&quot;error executing statement... &quot; +</span>
<a href="#l4.596"></a><span id="l4.596">              this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l4.597"></a><span id="l4.597">              this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l4.598"></a><span id="l4.598">     }</span>
<a href="#l4.599"></a><span id="l4.599"> </span>
<a href="#l4.600"></a><span id="l4.600" class="difflineminus">-    this._log.debug(&quot;CreateMessage: &quot; + folderID + &quot;, &quot; + aMessageKey + &quot;, &quot; +</span>
<a href="#l4.601"></a><span id="l4.601" class="difflineminus">-                    aConversationID + &quot;, &quot; + aDatePRTime + &quot;, &quot; +</span>
<a href="#l4.602"></a><span id="l4.602" class="difflineminus">-                    aHeaderMessageID);</span>
<a href="#l4.603"></a><span id="l4.603" class="difflineminus">-</span>
<a href="#l4.604"></a><span id="l4.604">     // we only create the full-text row if the body is non-null.</span>
<a href="#l4.605"></a><span id="l4.605">     // so, even though body might be null, we still want to create the</span>
<a href="#l4.606"></a><span id="l4.606">     //  full-text search row</span>
<a href="#l4.607"></a><span id="l4.607">     if (aBody) {</span>
<a href="#l4.608"></a><span id="l4.608">       let imts = this._insertMessageTextStatement;</span>
<a href="#l4.609"></a><span id="l4.609">       imts.bindInt64Parameter(0, messageID);</span>
<a href="#l4.610"></a><span id="l4.610">       imts.bindStringParameter(1, aSubject);</span>
<a href="#l4.611"></a><span id="l4.611">       imts.bindStringParameter(2, aBody);</span>
<a href="#l4.612"></a><span id="l4.612" class="difflineat">@@ -1365,64 +1478,58 @@ var GlodaDatastore = {</span>
<a href="#l4.613"></a><span id="l4.613">       }</span>
<a href="#l4.614"></a><span id="l4.614">       catch(ex) {</span>
<a href="#l4.615"></a><span id="l4.615">          throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l4.616"></a><span id="l4.616">                this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l4.617"></a><span id="l4.617">                this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l4.618"></a><span id="l4.618">       }</span>
<a href="#l4.619"></a><span id="l4.619">     }</span>
<a href="#l4.620"></a><span id="l4.620"> </span>
<a href="#l4.621"></a><span id="l4.621" class="difflineminus">-    let message = new GlodaMessage(this, messageID, folderID,</span>
<a href="#l4.622"></a><span id="l4.622" class="difflineminus">-                            aMessageKey, aConversationID, null,</span>
<a href="#l4.623"></a><span id="l4.623" class="difflineminus">-                            aDatePRTime ? new Date(aDatePRTime / 1000) : null,</span>
<a href="#l4.624"></a><span id="l4.624" class="difflineminus">-                            aHeaderMessageID);</span>
<a href="#l4.625"></a><span id="l4.625" class="difflineminus">-</span>
<a href="#l4.626"></a><span id="l4.626" class="difflineminus">-    // We would love to notify the collection manager about the message at this</span>
<a href="#l4.627"></a><span id="l4.627" class="difflineminus">-    //  point (at least if it's not a ghost), but we can't yet.  We need to wait</span>
<a href="#l4.628"></a><span id="l4.628" class="difflineminus">-    //  until the attributes have been indexed, which means it's out of our</span>
<a href="#l4.629"></a><span id="l4.629" class="difflineminus">-    //  hands.  (Gloda.processMessage does it.)</span>
<a href="#l4.630"></a><span id="l4.630" class="difflineminus">-</span>
<a href="#l4.631"></a><span id="l4.631" class="difflineminus">-    return message;</span>
<a href="#l4.632"></a><span id="l4.632">   },</span>
<a href="#l4.633"></a><span id="l4.633"> </span>
<a href="#l4.634"></a><span id="l4.634">   get _updateMessageStatement() {</span>
<a href="#l4.635"></a><span id="l4.635">     let statement = this._createAsyncStatement(</span>
<a href="#l4.636"></a><span id="l4.636">       &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l4.637"></a><span id="l4.637">                            messageKey = ?2, \</span>
<a href="#l4.638"></a><span id="l4.638">                            conversationID = ?3, \</span>
<a href="#l4.639"></a><span id="l4.639">                            date = ?4, \</span>
<a href="#l4.640"></a><span id="l4.640" class="difflineminus">-                           headerMessageID = ?5 \</span>
<a href="#l4.641"></a><span id="l4.641" class="difflineminus">-              WHERE id = ?6&quot;);</span>
<a href="#l4.642"></a><span id="l4.642" class="difflineplus">+                           headerMessageID = ?5,</span>
<a href="#l4.643"></a><span id="l4.643" class="difflineplus">+                           jsonAttributes = ?6 \</span>
<a href="#l4.644"></a><span id="l4.644" class="difflineplus">+              WHERE id = ?7&quot;);</span>
<a href="#l4.645"></a><span id="l4.645">     this.__defineGetter__(&quot;_updateMessageStatement&quot;, function() statement);</span>
<a href="#l4.646"></a><span id="l4.646">     return this._updateMessageStatement;</span>
<a href="#l4.647"></a><span id="l4.647">   },</span>
<a href="#l4.648"></a><span id="l4.648"> </span>
<a href="#l4.649"></a><span id="l4.649">   /**</span>
<a href="#l4.650"></a><span id="l4.650">    * Update the database row associated with the message.  If aBody is supplied,</span>
<a href="#l4.651"></a><span id="l4.651">    *  the associated full-text row is created; it is assumed that it did not</span>
<a href="#l4.652"></a><span id="l4.652">    *  previously exist.</span>
<a href="#l4.653"></a><span id="l4.653">    */</span>
<a href="#l4.654"></a><span id="l4.654">   updateMessage: function gloda_ds_updateMessage(aMessage, aSubject, aBody,</span>
<a href="#l4.655"></a><span id="l4.655">                                                  aAttachmentNames) {</span>
<a href="#l4.656"></a><span id="l4.656">     let ums = this._updateMessageStatement;</span>
<a href="#l4.657"></a><span id="l4.657" class="difflineminus">-    ums.bindInt64Parameter(5, aMessage.id);</span>
<a href="#l4.658"></a><span id="l4.658" class="difflineplus">+    ums.bindInt64Parameter(6, aMessage.id);</span>
<a href="#l4.659"></a><span id="l4.659">     if (aMessage.folderID === null)</span>
<a href="#l4.660"></a><span id="l4.660">       ums.bindNullParameter(0);</span>
<a href="#l4.661"></a><span id="l4.661">     else</span>
<a href="#l4.662"></a><span id="l4.662">       ums.bindInt64Parameter(0, aMessage.folderID);</span>
<a href="#l4.663"></a><span id="l4.663">     if (aMessage.messageKey === null)</span>
<a href="#l4.664"></a><span id="l4.664">       ums.bindNullParameter(1);</span>
<a href="#l4.665"></a><span id="l4.665">     else</span>
<a href="#l4.666"></a><span id="l4.666">       ums.bindInt64Parameter(1, aMessage.messageKey);</span>
<a href="#l4.667"></a><span id="l4.667">     ums.bindInt64Parameter(2, aMessage.conversationID);</span>
<a href="#l4.668"></a><span id="l4.668">     if (aMessage.date === null)</span>
<a href="#l4.669"></a><span id="l4.669">       ums.bindNullParameter(3);</span>
<a href="#l4.670"></a><span id="l4.670">     else</span>
<a href="#l4.671"></a><span id="l4.671">       ums.bindInt64Parameter(3, aMessage.date * 1000);</span>
<a href="#l4.672"></a><span id="l4.672">     ums.bindStringParameter(4, aMessage.headerMessageID);</span>
<a href="#l4.673"></a><span id="l4.673" class="difflineplus">+    if (aMessage._jsonText)</span>
<a href="#l4.674"></a><span id="l4.674" class="difflineplus">+      ims.bindStringParameter(5, aMessage._jsonText);</span>
<a href="#l4.675"></a><span id="l4.675" class="difflineplus">+    else</span>
<a href="#l4.676"></a><span id="l4.676" class="difflineplus">+      ims.bindNullParameter(5);</span>
<a href="#l4.677"></a><span id="l4.677"> </span>
<a href="#l4.678"></a><span id="l4.678">     ums.executeAsync(this.trackAsync());</span>
<a href="#l4.679"></a><span id="l4.679"> </span>
<a href="#l4.680"></a><span id="l4.680">     if (aBody) {</span>
<a href="#l4.681"></a><span id="l4.681">       let imts = this._insertMessageTextStatement;</span>
<a href="#l4.682"></a><span id="l4.682">       imts.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l4.683"></a><span id="l4.683">       imts.bindStringParameter(1, aSubject);</span>
<a href="#l4.684"></a><span id="l4.684">       imts.bindStringParameter(2, aBody);</span>
<a href="#l4.685"></a><span id="l4.685" class="difflineat">@@ -1449,19 +1556,19 @@ var GlodaDatastore = {</span>
<a href="#l4.686"></a><span id="l4.686">   },</span>
<a href="#l4.687"></a><span id="l4.687"> </span>
<a href="#l4.688"></a><span id="l4.688">   /**</span>
<a href="#l4.689"></a><span id="l4.689">    * Given a list of gloda message ids, and a list of their new message keys in</span>
<a href="#l4.690"></a><span id="l4.690">    *  the given new folder location, asynchronously update the message's</span>
<a href="#l4.691"></a><span id="l4.691">    *  database locations.  Also, update the in-memory representations.</span>
<a href="#l4.692"></a><span id="l4.692">    */</span>
<a href="#l4.693"></a><span id="l4.693">   updateMessageLocations: function gloda_ds_updateMessageLocations(aMessageIds,</span>
<a href="#l4.694"></a><span id="l4.694" class="difflineminus">-      aNewMessageKeys, aDestFolderURI) {</span>
<a href="#l4.695"></a><span id="l4.695" class="difflineplus">+      aNewMessageKeys, aDestFolder) {</span>
<a href="#l4.696"></a><span id="l4.696">     let statement = this._updateMessageLocationStatement;</span>
<a href="#l4.697"></a><span id="l4.697" class="difflineminus">-    let destFolderID = this._mapFolderURI(aDestFolderURI);</span>
<a href="#l4.698"></a><span id="l4.698" class="difflineplus">+    let destFolderID = this._mapFolder(aDestFolder).id;</span>
<a href="#l4.699"></a><span id="l4.699"> </span>
<a href="#l4.700"></a><span id="l4.700">     let modifiedItems = [];</span>
<a href="#l4.701"></a><span id="l4.701"> </span>
<a href="#l4.702"></a><span id="l4.702">     for (let iMsg = 0; iMsg &lt; aMessageIds.length; iMsg++) {</span>
<a href="#l4.703"></a><span id="l4.703">       let id = aMessageIds[iMsg]</span>
<a href="#l4.704"></a><span id="l4.704">       statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l4.705"></a><span id="l4.705">       statement.bindInt64Parameter(1, aNewMessageKeys[iMsg]);</span>
<a href="#l4.706"></a><span id="l4.706">       statement.bindInt64Parameter(2, id);</span>
<a href="#l4.707"></a><span id="l4.707" class="difflineat">@@ -1493,20 +1600,20 @@ var GlodaDatastore = {</span>
<a href="#l4.708"></a><span id="l4.708">   },</span>
<a href="#l4.709"></a><span id="l4.709"> </span>
<a href="#l4.710"></a><span id="l4.710">   /**</span>
<a href="#l4.711"></a><span id="l4.711">    * Asynchronously mutate message folder id/message keys for the given</span>
<a href="#l4.712"></a><span id="l4.712">    *  messages, indicating that we are moving them to the target folder, but</span>
<a href="#l4.713"></a><span id="l4.713">    *  don't yet know their target message keys.</span>
<a href="#l4.714"></a><span id="l4.714">    */</span>
<a href="#l4.715"></a><span id="l4.715">   updateMessageFoldersByKeyPurging:</span>
<a href="#l4.716"></a><span id="l4.716" class="difflineminus">-      function gloda_ds_updateMessageFoldersByKeyPurging(aSrcFolderURI,</span>
<a href="#l4.717"></a><span id="l4.717" class="difflineminus">-        aMessageKeys, aDestFolderURI) {</span>
<a href="#l4.718"></a><span id="l4.718" class="difflineminus">-    let srcFolderID = this._mapFolderURI(aSrcFolderURI);</span>
<a href="#l4.719"></a><span id="l4.719" class="difflineminus">-    let destFolderID = this._mapFolderURI(aDestFolderURI);</span>
<a href="#l4.720"></a><span id="l4.720" class="difflineplus">+      function gloda_ds_updateMessageFoldersByKeyPurging(aSrcFolder,</span>
<a href="#l4.721"></a><span id="l4.721" class="difflineplus">+        aMessageKeys, aDestFolder) {</span>
<a href="#l4.722"></a><span id="l4.722" class="difflineplus">+    let srcFolderID = this._mapFolder(aSrcFolder).id;</span>
<a href="#l4.723"></a><span id="l4.723" class="difflineplus">+    let destFolderID = this._mapFolder(aDestFolder).id;</span>
<a href="#l4.724"></a><span id="l4.724"> </span>
<a href="#l4.725"></a><span id="l4.725">     let sqlStr = &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l4.726"></a><span id="l4.726">                                       messageKey = ?2 \</span>
<a href="#l4.727"></a><span id="l4.727">                    WHERE folderID = ?3 \</span>
<a href="#l4.728"></a><span id="l4.728">                      AND messageKey IN (&quot; + aMessageKeys.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l4.729"></a><span id="l4.729">     let statement = this._createAsyncStatement(sqlStr, true);</span>
<a href="#l4.730"></a><span id="l4.730">     statement.bindInt64Parameter(2, srcFolderID);</span>
<a href="#l4.731"></a><span id="l4.731">     statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l4.732"></a><span id="l4.732" class="difflineat">@@ -1583,20 +1690,20 @@ var GlodaDatastore = {</span>
<a href="#l4.733"></a><span id="l4.733"> </span>
<a href="#l4.734"></a><span id="l4.734">   /**</span>
<a href="#l4.735"></a><span id="l4.735">    * Synchronously retrieve the message that we believe to correspond to the</span>
<a href="#l4.736"></a><span id="l4.736">    *  given message key in the given folder.</span>
<a href="#l4.737"></a><span id="l4.737">    * @return null on failure to locate the message, the message on success.</span>
<a href="#l4.738"></a><span id="l4.738">    *</span>
<a href="#l4.739"></a><span id="l4.739">    * @XXX on failure, attempt to resolve the problem through re-indexing, etc.</span>
<a href="#l4.740"></a><span id="l4.740">    */</span>
<a href="#l4.741"></a><span id="l4.741" class="difflineminus">-  getMessageFromLocation: function gloda_ds_getMessageFromLocation(aFolderURI,</span>
<a href="#l4.742"></a><span id="l4.742" class="difflineplus">+  getMessageFromLocation: function gloda_ds_getMessageFromLocation(aFolder,</span>
<a href="#l4.743"></a><span id="l4.743">                                                                  aMessageKey) {</span>
<a href="#l4.744"></a><span id="l4.744">     this._selectMessageByLocationStatement.bindInt64Parameter(0,</span>
<a href="#l4.745"></a><span id="l4.745" class="difflineminus">-      this._mapFolderURI(aFolderURI));</span>
<a href="#l4.746"></a><span id="l4.746" class="difflineplus">+      this._mapFolder(aFolder).id);</span>
<a href="#l4.747"></a><span id="l4.747">     this._selectMessageByLocationStatement.bindInt64Parameter(1, aMessageKey);</span>
<a href="#l4.748"></a><span id="l4.748"> </span>
<a href="#l4.749"></a><span id="l4.749">     let message = null;</span>
<a href="#l4.750"></a><span id="l4.750">     if (this._syncStep(this._selectMessageByLocationStatement))</span>
<a href="#l4.751"></a><span id="l4.751">       message = this._messageFromRow(this._selectMessageByLocationStatement);</span>
<a href="#l4.752"></a><span id="l4.752">     this._selectMessageByLocationStatement.reset();</span>
<a href="#l4.753"></a><span id="l4.753"> </span>
<a href="#l4.754"></a><span id="l4.754">     if (message === null)</span>
<a href="#l4.755"></a><span id="l4.755" class="difflineat">@@ -1803,61 +1910,85 @@ var GlodaDatastore = {</span>
<a href="#l4.756"></a><span id="l4.756">       &quot;INSERT INTO messageAttributes (conversationID, messageID, attributeID, \</span>
<a href="#l4.757"></a><span id="l4.757">                              value) \</span>
<a href="#l4.758"></a><span id="l4.758">               VALUES (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l4.759"></a><span id="l4.759">     this.__defineGetter__(&quot;_insertMessageAttributeStatement&quot;,</span>
<a href="#l4.760"></a><span id="l4.760">       function() statement);</span>
<a href="#l4.761"></a><span id="l4.761">     return this._insertMessageAttributeStatement;</span>
<a href="#l4.762"></a><span id="l4.762">   },</span>
<a href="#l4.763"></a><span id="l4.763"> </span>
<a href="#l4.764"></a><span id="l4.764" class="difflineplus">+  get _deleteMessageAttributeStatement() {</span>
<a href="#l4.765"></a><span id="l4.765" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l4.766"></a><span id="l4.766" class="difflineplus">+      &quot;DELETE FROM messageAttributes WHERE attributeID = ?1 AND value = ?2 \</span>
<a href="#l4.767"></a><span id="l4.767" class="difflineplus">+         AND conversationID = ?3 AND messageID = ?4&quot;);</span>
<a href="#l4.768"></a><span id="l4.768" class="difflineplus">+    this.__defineGetter__(&quot;_deleteMessageAttributeStatement&quot;,</span>
<a href="#l4.769"></a><span id="l4.769" class="difflineplus">+      function() statement);</span>
<a href="#l4.770"></a><span id="l4.770" class="difflineplus">+    return this._deleteMessageAttributeStatement;</span>
<a href="#l4.771"></a><span id="l4.771" class="difflineplus">+  },</span>
<a href="#l4.772"></a><span id="l4.772" class="difflineplus">+</span>
<a href="#l4.773"></a><span id="l4.773">   /**</span>
<a href="#l4.774"></a><span id="l4.774" class="difflineminus">-   * Insert a bunch of attributes relating to a GlodaMessage.  This is performed</span>
<a href="#l4.775"></a><span id="l4.775" class="difflineplus">+   * Insert and remove attributes relating to a GlodaMessage.  This is performed</span>
<a href="#l4.776"></a><span id="l4.776">    *  inside a pseudo-transaction (we create one if we aren't in one, using</span>
<a href="#l4.777"></a><span id="l4.777">    *  our _beginTransaction wrapper, but if we are in one, no additional</span>
<a href="#l4.778"></a><span id="l4.778">    *  meaningful semantics are added).</span>
<a href="#l4.779"></a><span id="l4.779">    * No attempt is made to verify uniqueness of inserted attributes, either</span>
<a href="#l4.780"></a><span id="l4.780">    *  against the current database or within the provided list of attributes.</span>
<a href="#l4.781"></a><span id="l4.781">    *  The caller is responsible for ensuring that unwanted duplicates are</span>
<a href="#l4.782"></a><span id="l4.782">    *  avoided.</span>
<a href="#l4.783"></a><span id="l4.783" class="difflineminus">-   * Currently, it is expected that this method will be used following a call to</span>
<a href="#l4.784"></a><span id="l4.784" class="difflineminus">-   *  clearMessageAttributes to wipe out the existing attributes in the</span>
<a href="#l4.785"></a><span id="l4.785" class="difflineminus">-   *  database.  We will probably try and move to a delta-mechanism in the</span>
<a href="#l4.786"></a><span id="l4.786" class="difflineminus">-   *  future, avoiding needless database churn for small changes in state.</span>
<a href="#l4.787"></a><span id="l4.787">    *</span>
<a href="#l4.788"></a><span id="l4.788">    * @param aMessage The GlodaMessage the attributes belong to.  This is used</span>
<a href="#l4.789"></a><span id="l4.789">    *     to provide the message id and conversation id.</span>
<a href="#l4.790"></a><span id="l4.790" class="difflineminus">-   * @param aAttributes A list of attribute tuples, where each tuple contains</span>
<a href="#l4.791"></a><span id="l4.791" class="difflineminus">-   *     an attribute ID and a value.  Lest you forget, an attribute ID</span>
<a href="#l4.792"></a><span id="l4.792" class="difflineplus">+   * @param aAddDBAttributes A list of attribute tuples to add, where each tuple</span>
<a href="#l4.793"></a><span id="l4.793" class="difflineplus">+   *     contains an attribute ID and a value.  Lest you forget, an attribute ID</span>
<a href="#l4.794"></a><span id="l4.794">    *     corresponds to a row in the attribute definition table.  The attribute</span>
<a href="#l4.795"></a><span id="l4.795">    *     definition table stores the 'parameter' for the attribute, if any.</span>
<a href="#l4.796"></a><span id="l4.796">    *     (Which is to say, our frequent Attribute-Parameter-Value triple has</span>
<a href="#l4.797"></a><span id="l4.797">    *     the Attribute-Parameter part distilled to a single attribute id.)</span>
<a href="#l4.798"></a><span id="l4.798" class="difflineplus">+   * @param aRemoveDBAttributes A list of attribute tuples to remove.</span>
<a href="#l4.799"></a><span id="l4.799">    */</span>
<a href="#l4.800"></a><span id="l4.800" class="difflineminus">-  insertMessageAttributes: function gloda_ds_insertMessageAttributes(aMessage,</span>
<a href="#l4.801"></a><span id="l4.801" class="difflineminus">-                                        aAttributes) {</span>
<a href="#l4.802"></a><span id="l4.802" class="difflineplus">+  adjustMessageAttributes: function gloda_ds_adjustMessageAttributes(aMessage,</span>
<a href="#l4.803"></a><span id="l4.803" class="difflineplus">+                                        aAddDBAttributes, aRemoveDBAttributes) {</span>
<a href="#l4.804"></a><span id="l4.804">     let imas = this._insertMessageAttributeStatement;</span>
<a href="#l4.805"></a><span id="l4.805" class="difflineplus">+    let dmas = this._deleteMessageAttributeStatement;</span>
<a href="#l4.806"></a><span id="l4.806">     this._beginTransaction();</span>
<a href="#l4.807"></a><span id="l4.807">     try {</span>
<a href="#l4.808"></a><span id="l4.808" class="difflineminus">-      for (let iAttribute = 0; iAttribute &lt; aAttributes.length; iAttribute++) {</span>
<a href="#l4.809"></a><span id="l4.809" class="difflineminus">-        let attribValueTuple = aAttributes[iAttribute];</span>
<a href="#l4.810"></a><span id="l4.810" class="difflineplus">+      for (let iAttrib = 0; iAttrib &lt; aAddDBAttributes.length; iAttrib++) {</span>
<a href="#l4.811"></a><span id="l4.811" class="difflineplus">+        let attribValueTuple = aAddDBAttributes[iAttrib];</span>
<a href="#l4.812"></a><span id="l4.812"> </span>
<a href="#l4.813"></a><span id="l4.813">         imas.bindInt64Parameter(0, aMessage.conversationID);</span>
<a href="#l4.814"></a><span id="l4.814">         imas.bindInt64Parameter(1, aMessage.id);</span>
<a href="#l4.815"></a><span id="l4.815">         imas.bindInt64Parameter(2, attribValueTuple[0]);</span>
<a href="#l4.816"></a><span id="l4.816">         // use 0 instead of null, otherwise the db gets upset.  (and we don't</span>
<a href="#l4.817"></a><span id="l4.817">         //  really care anyways.)</span>
<a href="#l4.818"></a><span id="l4.818">         if (attribValueTuple[1] == null)</span>
<a href="#l4.819"></a><span id="l4.819">           imas.bindInt64Parameter(3, 0);</span>
<a href="#l4.820"></a><span id="l4.820">         else if (Math.floor(attribValueTuple[1]) == attribValueTuple[1])</span>
<a href="#l4.821"></a><span id="l4.821">           imas.bindInt64Parameter(3, attribValueTuple[1]);</span>
<a href="#l4.822"></a><span id="l4.822">         else</span>
<a href="#l4.823"></a><span id="l4.823">           imas.bindDoubleParameter(3, attribValueTuple[1]);</span>
<a href="#l4.824"></a><span id="l4.824">         imas.executeAsync(this.trackAsync());</span>
<a href="#l4.825"></a><span id="l4.825">       }</span>
<a href="#l4.826"></a><span id="l4.826"> </span>
<a href="#l4.827"></a><span id="l4.827" class="difflineplus">+      for (let iAttrib = 0; iAttrib &lt; aRemoveDBAttributes.length; iAttrib++) {</span>
<a href="#l4.828"></a><span id="l4.828" class="difflineplus">+        let attribValueTuple = aRemoveDBAttributes[iAttrib];</span>
<a href="#l4.829"></a><span id="l4.829" class="difflineplus">+</span>
<a href="#l4.830"></a><span id="l4.830" class="difflineplus">+        dmas.bindInt64Parameter(0, attribValueTuple[0]);</span>
<a href="#l4.831"></a><span id="l4.831" class="difflineplus">+        // use 0 instead of null, otherwise the db gets upset.  (and we don't</span>
<a href="#l4.832"></a><span id="l4.832" class="difflineplus">+        //  really care anyways.)</span>
<a href="#l4.833"></a><span id="l4.833" class="difflineplus">+        if (attribValueTuple[1] == null)</span>
<a href="#l4.834"></a><span id="l4.834" class="difflineplus">+          dmas.bindInt64Parameter(1, 0);</span>
<a href="#l4.835"></a><span id="l4.835" class="difflineplus">+        else if (Math.floor(attribValueTuple[1]) == attribValueTuple[1])</span>
<a href="#l4.836"></a><span id="l4.836" class="difflineplus">+          dmas.bindInt64Parameter(1, attribValueTuple[1]);</span>
<a href="#l4.837"></a><span id="l4.837" class="difflineplus">+        else</span>
<a href="#l4.838"></a><span id="l4.838" class="difflineplus">+          dmas.bindDoubleParameter(1, attribValueTuple[1]);</span>
<a href="#l4.839"></a><span id="l4.839" class="difflineplus">+        dmas.bindInt64Parameter(2, aMessage.conversationID);</span>
<a href="#l4.840"></a><span id="l4.840" class="difflineplus">+        dmas.bindInt64Parameter(3, aMessage.id);</span>
<a href="#l4.841"></a><span id="l4.841" class="difflineplus">+        dmas.executeAsync(this.trackAsync());</span>
<a href="#l4.842"></a><span id="l4.842" class="difflineplus">+      }</span>
<a href="#l4.843"></a><span id="l4.843" class="difflineplus">+</span>
<a href="#l4.844"></a><span id="l4.844">       this._commitTransaction();</span>
<a href="#l4.845"></a><span id="l4.845">     }</span>
<a href="#l4.846"></a><span id="l4.846">     catch (ex) {</span>
<a href="#l4.847"></a><span id="l4.847">       this._rollbackTransaction();</span>
<a href="#l4.848"></a><span id="l4.848">       throw ex;</span>
<a href="#l4.849"></a><span id="l4.849">     }</span>
<a href="#l4.850"></a><span id="l4.850">   },</span>
<a href="#l4.851"></a><span id="l4.851"> </span>
<a href="#l4.852"></a><span id="l4.852" class="difflineat">@@ -1927,46 +2058,68 @@ var GlodaDatastore = {</span>
<a href="#l4.853"></a><span id="l4.853">   _stringSQLQuoter: function(aString) {</span>
<a href="#l4.854"></a><span id="l4.854">     return &quot;'&quot; + aString.replace(&quot;'&quot;, &quot;''&quot;, &quot;g&quot;) + &quot;'&quot;;</span>
<a href="#l4.855"></a><span id="l4.855">   },</span>
<a href="#l4.856"></a><span id="l4.856">   _numberQuoter: function(aNum) {</span>
<a href="#l4.857"></a><span id="l4.857">     return aNum;</span>
<a href="#l4.858"></a><span id="l4.858">   },</span>
<a href="#l4.859"></a><span id="l4.859"> </span>
<a href="#l4.860"></a><span id="l4.860">   /* ===== Generic Attribute Support ===== */</span>
<a href="#l4.861"></a><span id="l4.861" class="difflineminus">-  insertAttributes: function gloda_ds_insertAttributes(aItem,</span>
<a href="#l4.862"></a><span id="l4.862" class="difflineminus">-                                        aAttributes) {</span>
<a href="#l4.863"></a><span id="l4.863" class="difflineplus">+  adjustAttributes: function gloda_ds_adjustAttributes(aItem, aAddDBAttributes,</span>
<a href="#l4.864"></a><span id="l4.864" class="difflineplus">+      aRemoveDBAttributes) {</span>
<a href="#l4.865"></a><span id="l4.865">     let nounMeta = aItem.NOUN_META;</span>
<a href="#l4.866"></a><span id="l4.866">     let dbMeta = nounMeta._dbMeta;</span>
<a href="#l4.867"></a><span id="l4.867">     if (dbMeta.insertAttrStatement === undefined) {</span>
<a href="#l4.868"></a><span id="l4.868">       dbMeta.insertAttrStatement = this._createAsyncStatement(</span>
<a href="#l4.869"></a><span id="l4.869">         &quot;INSERT INTO &quot; + nounMeta.attrTableName +</span>
<a href="#l4.870"></a><span id="l4.870">         &quot; (&quot; + nounMeta.attrIDColumnName + &quot;, attributeID, value) &quot; +</span>
<a href="#l4.871"></a><span id="l4.871">         &quot; VALUES (?1, ?2, ?3)&quot;);</span>
<a href="#l4.872"></a><span id="l4.872" class="difflineplus">+      // we always create this at the same time (right here), no need to check</span>
<a href="#l4.873"></a><span id="l4.873" class="difflineplus">+      dbMeta.deleteAttrStatement = this._createAsyncStatement(</span>
<a href="#l4.874"></a><span id="l4.874" class="difflineplus">+        &quot;DELETE FROM &quot; + nounMeta.attrTableName + &quot; WHERE &quot; +</span>
<a href="#l4.875"></a><span id="l4.875" class="difflineplus">+        &quot; attributeID = ?1 AND value = ?2 AND &quot; +</span>
<a href="#l4.876"></a><span id="l4.876" class="difflineplus">+        nounMeta.attrIDColumnName + &quot; = ?3&quot;);</span>
<a href="#l4.877"></a><span id="l4.877">     }</span>
<a href="#l4.878"></a><span id="l4.878"> </span>
<a href="#l4.879"></a><span id="l4.879">     let ias = dbMeta.insertAttrStatement;</span>
<a href="#l4.880"></a><span id="l4.880" class="difflineplus">+    let das = dbMeta.deleteAttrStatement;</span>
<a href="#l4.881"></a><span id="l4.881">     this._beginTransaction();</span>
<a href="#l4.882"></a><span id="l4.882">     try {</span>
<a href="#l4.883"></a><span id="l4.883" class="difflineminus">-      for (let iAttribute = 0; iAttribute &lt; aAttributes.length; iAttribute++) {</span>
<a href="#l4.884"></a><span id="l4.884" class="difflineminus">-        let attribValueTuple = aAttributes[iAttribute];</span>
<a href="#l4.885"></a><span id="l4.885" class="difflineplus">+      for (let iAttr = 0; iAttr &lt; aAddDBAttributes.length; iAttr++) {</span>
<a href="#l4.886"></a><span id="l4.886" class="difflineplus">+        let attribValueTuple = aAddDBAttributes[iAttr];</span>
<a href="#l4.887"></a><span id="l4.887"> </span>
<a href="#l4.888"></a><span id="l4.888">         ias.bindInt64Parameter(0, aItem.id);</span>
<a href="#l4.889"></a><span id="l4.889">         ias.bindInt64Parameter(1, attribValueTuple[0]);</span>
<a href="#l4.890"></a><span id="l4.890">         // use 0 instead of null, otherwise the db gets upset.  (and we don't</span>
<a href="#l4.891"></a><span id="l4.891">         //  really care anyways.)</span>
<a href="#l4.892"></a><span id="l4.892">         if (attribValueTuple[1] == null)</span>
<a href="#l4.893"></a><span id="l4.893">           ias.bindInt64Parameter(2, 0);</span>
<a href="#l4.894"></a><span id="l4.894">         else if (Math.floor(attribValueTuple[1]) == attribValueTuple[1])</span>
<a href="#l4.895"></a><span id="l4.895">           ias.bindInt64Parameter(2, attribValueTuple[1]);</span>
<a href="#l4.896"></a><span id="l4.896">         else</span>
<a href="#l4.897"></a><span id="l4.897">           ias.bindDoubleParameter(2, attribValueTuple[1]);</span>
<a href="#l4.898"></a><span id="l4.898">         ias.executeAsync(this.trackAsync());</span>
<a href="#l4.899"></a><span id="l4.899">       }</span>
<a href="#l4.900"></a><span id="l4.900"> </span>
<a href="#l4.901"></a><span id="l4.901" class="difflineplus">+      for (let iAttr = 0; iAttr &lt; aRemoveDBAttributes.length; iAttr++) {</span>
<a href="#l4.902"></a><span id="l4.902" class="difflineplus">+        let attribValueTuple = aRemoveDBAttributes[iAttr];</span>
<a href="#l4.903"></a><span id="l4.903" class="difflineplus">+</span>
<a href="#l4.904"></a><span id="l4.904" class="difflineplus">+        das.bindInt64Parameter(0, attribValueTuple[0]);</span>
<a href="#l4.905"></a><span id="l4.905" class="difflineplus">+        // use 0 instead of null, otherwise the db gets upset.  (and we don't</span>
<a href="#l4.906"></a><span id="l4.906" class="difflineplus">+        //  really care anyways.)</span>
<a href="#l4.907"></a><span id="l4.907" class="difflineplus">+        if (attribValueTuple[1] == null)</span>
<a href="#l4.908"></a><span id="l4.908" class="difflineplus">+          das.bindInt64Parameter(1, 0);</span>
<a href="#l4.909"></a><span id="l4.909" class="difflineplus">+        else if (Math.floor(attribValueTuple[1]) == attribValueTuple[1])</span>
<a href="#l4.910"></a><span id="l4.910" class="difflineplus">+          das.bindInt64Parameter(1, attribValueTuple[1]);</span>
<a href="#l4.911"></a><span id="l4.911" class="difflineplus">+        else</span>
<a href="#l4.912"></a><span id="l4.912" class="difflineplus">+          das.bindDoubleParameter(1, attribValueTuple[1]);</span>
<a href="#l4.913"></a><span id="l4.913" class="difflineplus">+        das.bindInt64Parameter(2, aItem.id);</span>
<a href="#l4.914"></a><span id="l4.914" class="difflineplus">+        das.executeAsync(this.trackAsync());</span>
<a href="#l4.915"></a><span id="l4.915" class="difflineplus">+      }</span>
<a href="#l4.916"></a><span id="l4.916" class="difflineplus">+</span>
<a href="#l4.917"></a><span id="l4.917">       this._commitTransaction();</span>
<a href="#l4.918"></a><span id="l4.918">     }</span>
<a href="#l4.919"></a><span id="l4.919">     catch (ex) {</span>
<a href="#l4.920"></a><span id="l4.920">       this._rollbackTransaction();</span>
<a href="#l4.921"></a><span id="l4.921">       throw ex;</span>
<a href="#l4.922"></a><span id="l4.922">     }</span>
<a href="#l4.923"></a><span id="l4.923">   },</span>
<a href="#l4.924"></a><span id="l4.924"> </span>
<a href="#l4.925"></a><span id="l4.925" class="difflineat">@@ -2000,17 +2153,18 @@ var GlodaDatastore = {</span>
<a href="#l4.926"></a><span id="l4.926">    * Perform a database query given a GlodaQueryClass instance that specifies</span>
<a href="#l4.927"></a><span id="l4.927">    *  a set of constraints relating to the noun type associated with the query.</span>
<a href="#l4.928"></a><span id="l4.928">    *  A GlodaCollection is returned containing the results of the look-up.</span>
<a href="#l4.929"></a><span id="l4.929">    *  By default the collection is &quot;live&quot;, and will mutate (generating events to</span>
<a href="#l4.930"></a><span id="l4.930">    *  its listener) as the state of the database changes.</span>
<a href="#l4.931"></a><span id="l4.931">    * This functionality is made user/extension visible by the Query's</span>
<a href="#l4.932"></a><span id="l4.932">    *  getCollection (asynchronous) and getAllSync (synchronous).</span>
<a href="#l4.933"></a><span id="l4.933">    */</span>
<a href="#l4.934"></a><span id="l4.934" class="difflineminus">-  queryFromQuery: function gloda_ds_queryFromQuery(aQuery, aListener, bSynchronous) {</span>
<a href="#l4.935"></a><span id="l4.935" class="difflineplus">+  queryFromQuery: function gloda_ds_queryFromQuery(aQuery, aListener,</span>
<a href="#l4.936"></a><span id="l4.936" class="difflineplus">+      bSynchronous, aListenerData) {</span>
<a href="#l4.937"></a><span id="l4.937">     // when changing this method, be sure that GlodaQuery's testMatch function</span>
<a href="#l4.938"></a><span id="l4.938">     //  likewise has its changes made.</span>
<a href="#l4.939"></a><span id="l4.939">     let nounMeta = aQuery._nounMeta;</span>
<a href="#l4.940"></a><span id="l4.940"> </span>
<a href="#l4.941"></a><span id="l4.941">     let whereClauses = [];</span>
<a href="#l4.942"></a><span id="l4.942">     let unionQueries = [aQuery].concat(aQuery._unions);</span>
<a href="#l4.943"></a><span id="l4.943">     let boundArgs = [];</span>
<a href="#l4.944"></a><span id="l4.944"> </span>
<a href="#l4.945"></a><span id="l4.945" class="difflineat">@@ -2145,16 +2299,32 @@ var GlodaDatastore = {</span>
<a href="#l4.946"></a><span id="l4.946"> </span>
<a href="#l4.947"></a><span id="l4.947">       if (selects.length)</span>
<a href="#l4.948"></a><span id="l4.948">         whereClauses.push(&quot;id IN (&quot; + selects.join(&quot; INTERSECT &quot;) + &quot; )&quot;);</span>
<a href="#l4.949"></a><span id="l4.949">     }</span>
<a href="#l4.950"></a><span id="l4.950"> </span>
<a href="#l4.951"></a><span id="l4.951">     let sqlString = &quot;SELECT * FROM &quot; + nounMeta.tableName;</span>
<a href="#l4.952"></a><span id="l4.952">     if (whereClauses.length)</span>
<a href="#l4.953"></a><span id="l4.953">       sqlString += &quot; WHERE &quot; + whereClauses.join(&quot; OR &quot;);</span>
<a href="#l4.954"></a><span id="l4.954" class="difflineplus">+    </span>
<a href="#l4.955"></a><span id="l4.955" class="difflineplus">+    if (aQuery._order.length) {</span>
<a href="#l4.956"></a><span id="l4.956" class="difflineplus">+      let orderClauses = [];</span>
<a href="#l4.957"></a><span id="l4.957" class="difflineplus">+      for (let [, colName] in Iterator(aQuery._order)) {</span>
<a href="#l4.958"></a><span id="l4.958" class="difflineplus">+         if (colName[0] == &quot;-&quot;)</span>
<a href="#l4.959"></a><span id="l4.959" class="difflineplus">+           orderClauses.push(colName.substring(1) + &quot; DESC&quot;);</span>
<a href="#l4.960"></a><span id="l4.960" class="difflineplus">+         else</span>
<a href="#l4.961"></a><span id="l4.961" class="difflineplus">+           orderClauses.push(colName + &quot; ASC&quot;);</span>
<a href="#l4.962"></a><span id="l4.962" class="difflineplus">+      }</span>
<a href="#l4.963"></a><span id="l4.963" class="difflineplus">+      sqlString += &quot; ORDER BY &quot; + orderClauses.join(&quot;, &quot;);</span>
<a href="#l4.964"></a><span id="l4.964" class="difflineplus">+    }</span>
<a href="#l4.965"></a><span id="l4.965" class="difflineplus">+    </span>
<a href="#l4.966"></a><span id="l4.966" class="difflineplus">+    if (aQuery._limit) {</span>
<a href="#l4.967"></a><span id="l4.967" class="difflineplus">+      sqlString += &quot; LIMIT ?&quot;;</span>
<a href="#l4.968"></a><span id="l4.968" class="difflineplus">+      boundArgs.push(aQuery._limit); </span>
<a href="#l4.969"></a><span id="l4.969" class="difflineplus">+    }</span>
<a href="#l4.970"></a><span id="l4.970"> </span>
<a href="#l4.971"></a><span id="l4.971">     this._log.debug(&quot;QUERY FROM QUERY: &quot; + sqlString);</span>
<a href="#l4.972"></a><span id="l4.972"> </span>
<a href="#l4.973"></a><span id="l4.973">     let collection;</span>
<a href="#l4.974"></a><span id="l4.974">     if (bSynchronous) {</span>
<a href="#l4.975"></a><span id="l4.975">       let statement = this._createSyncStatement(sqlString, true);</span>
<a href="#l4.976"></a><span id="l4.976">       for (let [iBinding, bindingValue] in Iterator(boundArgs)) {</span>
<a href="#l4.977"></a><span id="l4.977">         this._bindVariant(statement, iBinding, bindingValue);</span>
<a href="#l4.978"></a><span id="l4.978" class="difflineat">@@ -2168,148 +2338,185 @@ var GlodaDatastore = {</span>
<a href="#l4.979"></a><span id="l4.979"> </span>
<a href="#l4.980"></a><span id="l4.980">       // have the collection manager attempt to replace the instances we just</span>
<a href="#l4.981"></a><span id="l4.981">       //  created with pre-existing instances.  if the instance didn't exist,</span>
<a href="#l4.982"></a><span id="l4.982">       //  cache the newly observed ones.  We are trading off wastes here; we don't</span>
<a href="#l4.983"></a><span id="l4.983">       //  want to have to ask the collection manager about every row, and we don't</span>
<a href="#l4.984"></a><span id="l4.984">       //  want to invent some alternate row storage.</span>
<a href="#l4.985"></a><span id="l4.985">       GlodaCollectionManager.cacheLoadUnify(nounMeta.id, items);</span>
<a href="#l4.986"></a><span id="l4.986">       collection = new GlodaCollection(nounMeta, items, aQuery, aListener);</span>
<a href="#l4.987"></a><span id="l4.987" class="difflineplus">+      if (aListenerData !== undefined)</span>
<a href="#l4.988"></a><span id="l4.988" class="difflineplus">+        collection.data = aListenerData;</span>
<a href="#l4.989"></a><span id="l4.989"> </span>
<a href="#l4.990"></a><span id="l4.990">       GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l4.991"></a><span id="l4.991">     }</span>
<a href="#l4.992"></a><span id="l4.992">     else { // async!</span>
<a href="#l4.993"></a><span id="l4.993">       let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l4.994"></a><span id="l4.994">       for (let [iBinding, bindingValue] in Iterator(boundArgs)) {</span>
<a href="#l4.995"></a><span id="l4.995">         this._bindVariant(statement, iBinding, bindingValue);</span>
<a href="#l4.996"></a><span id="l4.996">       }</span>
<a href="#l4.997"></a><span id="l4.997"> </span>
<a href="#l4.998"></a><span id="l4.998">       collection = new GlodaCollection(nounMeta, [], aQuery, aListener);</span>
<a href="#l4.999"></a><span id="l4.999" class="difflineplus">+      if (aListenerData !== undefined)</span>
<a href="#l4.1000"></a><span id="l4.1000" class="difflineplus">+        collection.data = aListenerData;</span>
<a href="#l4.1001"></a><span id="l4.1001">       GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l4.1002"></a><span id="l4.1002"> </span>
<a href="#l4.1003"></a><span id="l4.1003">       statement.executeAsync(new QueryFromQueryCallback(statement, nounMeta,</span>
<a href="#l4.1004"></a><span id="l4.1004">         collection));</span>
<a href="#l4.1005"></a><span id="l4.1005">       statement.finalize();</span>
<a href="#l4.1006"></a><span id="l4.1006">     }</span>
<a href="#l4.1007"></a><span id="l4.1007">     return collection;</span>
<a href="#l4.1008"></a><span id="l4.1008">   },</span>
<a href="#l4.1009"></a><span id="l4.1009"> </span>
<a href="#l4.1010"></a><span id="l4.1010" class="difflineminus">-  /**</span>
<a href="#l4.1011"></a><span id="l4.1011" class="difflineminus">-   * Deprecated, but still in existence for the benefit of expmess code that</span>
<a href="#l4.1012"></a><span id="l4.1012" class="difflineminus">-   *  needs to go away anyways and can take this with it.</span>
<a href="#l4.1013"></a><span id="l4.1013" class="difflineminus">-   */</span>
<a href="#l4.1014"></a><span id="l4.1014" class="difflineminus">-  queryMessagesAPV: function gloda_ds_queryMessagesAPV(aAPVs) {</span>
<a href="#l4.1015"></a><span id="l4.1015" class="difflineminus">-    let selects = [];</span>
<a href="#l4.1016"></a><span id="l4.1016" class="difflineminus">-</span>
<a href="#l4.1017"></a><span id="l4.1017" class="difflineminus">-    for (let iAPV = 0; iAPV &lt; aAPVs.length; iAPV++) {</span>
<a href="#l4.1018"></a><span id="l4.1018" class="difflineminus">-      let APV = aAPVs[iAPV];</span>
<a href="#l4.1019"></a><span id="l4.1019" class="difflineminus">-</span>
<a href="#l4.1020"></a><span id="l4.1020" class="difflineminus">-      let attributeID;</span>
<a href="#l4.1021"></a><span id="l4.1021" class="difflineminus">-      if (APV[1] != null)</span>
<a href="#l4.1022"></a><span id="l4.1022" class="difflineminus">-        attributeID = APV[0].bindParameter(APV[1]);</span>
<a href="#l4.1023"></a><span id="l4.1023" class="difflineminus">-      else</span>
<a href="#l4.1024"></a><span id="l4.1024" class="difflineminus">-        attributeID = APV[0].id;</span>
<a href="#l4.1025"></a><span id="l4.1025" class="difflineminus">-      let select = &quot;SELECT messageID FROM messageAttributes WHERE attributeID&quot; +</span>
<a href="#l4.1026"></a><span id="l4.1026" class="difflineminus">-                   &quot; = &quot; + attributeID;</span>
<a href="#l4.1027"></a><span id="l4.1027" class="difflineminus">-      // straight value match?</span>
<a href="#l4.1028"></a><span id="l4.1028" class="difflineminus">-      if (APV.length == 3) {</span>
<a href="#l4.1029"></a><span id="l4.1029" class="difflineminus">-        if (APV[2] != null)</span>
<a href="#l4.1030"></a><span id="l4.1030" class="difflineminus">-          select += &quot; AND value = &quot; + APV[2];</span>
<a href="#l4.1031"></a><span id="l4.1031" class="difflineplus">+  loadNounItem: function gloda_ds_loadNounItem(aItem, aReferencesByNounID) {</span>
<a href="#l4.1032"></a><span id="l4.1032" class="difflineplus">+    let jsonDict = this._json.decode(aItem._jsonText);</span>
<a href="#l4.1033"></a><span id="l4.1033" class="difflineplus">+    delete aItem._jsonText;</span>
<a href="#l4.1034"></a><span id="l4.1034" class="difflineplus">+    </span>
<a href="#l4.1035"></a><span id="l4.1035" class="difflineplus">+    let attribIDToDef = this._attributeIDToDef;</span>
<a href="#l4.1036"></a><span id="l4.1036" class="difflineplus">+    </span>
<a href="#l4.1037"></a><span id="l4.1037" class="difflineplus">+    let deps = {};</span>
<a href="#l4.1038"></a><span id="l4.1038" class="difflineplus">+    let hasDeps = false;</span>
<a href="#l4.1039"></a><span id="l4.1039" class="difflineplus">+    </span>
<a href="#l4.1040"></a><span id="l4.1040" class="difflineplus">+    // Iterate over the attributes on the item</span>
<a href="#l4.1041"></a><span id="l4.1041" class="difflineplus">+    for each (let [attribId, jsonValue] in Iterator(jsonDict)) {</span>
<a href="#l4.1042"></a><span id="l4.1042" class="difflineplus">+      // find the attribute definition that corresponds to this key</span>
<a href="#l4.1043"></a><span id="l4.1043" class="difflineplus">+      let attrib = attribIDToDef[attribId][0];</span>
<a href="#l4.1044"></a><span id="l4.1044" class="difflineplus">+      // the attribute should only fail to exist if an extension was removed</span>
<a href="#l4.1045"></a><span id="l4.1045" class="difflineplus">+      if (attrib === undefined)</span>
<a href="#l4.1046"></a><span id="l4.1046" class="difflineplus">+        continue;</span>
<a href="#l4.1047"></a><span id="l4.1047" class="difflineplus">+      </span>
<a href="#l4.1048"></a><span id="l4.1048" class="difflineplus">+      let objectNounDef = attrib.objectNounDef;</span>
<a href="#l4.1049"></a><span id="l4.1049" class="difflineplus">+      </span>
<a href="#l4.1050"></a><span id="l4.1050" class="difflineplus">+      // if it has a tableName member, then it's a persistent object that needs</span>
<a href="#l4.1051"></a><span id="l4.1051" class="difflineplus">+      //  to be loaded, which also means we need to hold it in a collection</span>
<a href="#l4.1052"></a><span id="l4.1052" class="difflineplus">+      //  owned by our collection.</span>
<a href="#l4.1053"></a><span id="l4.1053" class="difflineplus">+      if (objectNounDef.tableName) {</span>
<a href="#l4.1054"></a><span id="l4.1054" class="difflineplus">+        let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l4.1055"></a><span id="l4.1055" class="difflineplus">+        if (references === undefined)</span>
<a href="#l4.1056"></a><span id="l4.1056" class="difflineplus">+          references = aReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l4.1057"></a><span id="l4.1057" class="difflineplus">+          </span>
<a href="#l4.1058"></a><span id="l4.1058" class="difflineplus">+        if (attrib.singular)</span>
<a href="#l4.1059"></a><span id="l4.1059" class="difflineplus">+          references[jsonValue] = null;</span>
<a href="#l4.1060"></a><span id="l4.1060" class="difflineplus">+        else {</span>
<a href="#l4.1061"></a><span id="l4.1061" class="difflineplus">+          for each (let [, anID] in Iterator(jsonValue))</span>
<a href="#l4.1062"></a><span id="l4.1062" class="difflineplus">+            references[anID] = null;</span>
<a href="#l4.1063"></a><span id="l4.1063" class="difflineplus">+        }</span>
<a href="#l4.1064"></a><span id="l4.1064" class="difflineplus">+        </span>
<a href="#l4.1065"></a><span id="l4.1065" class="difflineplus">+        deps[attrib] = jsonValue;</span>
<a href="#l4.1066"></a><span id="l4.1066" class="difflineplus">+        hasDeps = true;</span>
<a href="#l4.1067"></a><span id="l4.1067">       }</span>
<a href="#l4.1068"></a><span id="l4.1068" class="difflineminus">-      else { // APV.length == 4, so range match</span>
<a href="#l4.1069"></a><span id="l4.1069" class="difflineminus">-        // BETWEEN is optimized to &gt;= and &lt;=, or we could just do that ourself.</span>
<a href="#l4.1070"></a><span id="l4.1070" class="difflineminus">-        //  (in other words, this shouldn't hurt our use of indices)</span>
<a href="#l4.1071"></a><span id="l4.1071" class="difflineminus">-        select += &quot; AND value BETWEEN &quot; + APV[2] + &quot; AND &quot; + APV[3];</span>
<a href="#l4.1072"></a><span id="l4.1072" class="difflineplus">+      /* if it has custom contribution logic, use it */</span>
<a href="#l4.1073"></a><span id="l4.1073" class="difflineplus">+      else if (objectNounDef.contributeObjDependencies) {</span>
<a href="#l4.1074"></a><span id="l4.1074" class="difflineplus">+        if (objectNounDef.contributeObjDependencies(jsonValue,</span>
<a href="#l4.1075"></a><span id="l4.1075" class="difflineplus">+                                                    aReferencesByNounID)) {</span>
<a href="#l4.1076"></a><span id="l4.1076" class="difflineplus">+          deps[attrib] = jsonValue;</span>
<a href="#l4.1077"></a><span id="l4.1077" class="difflineplus">+          hasDeps = true;</span>
<a href="#l4.1078"></a><span id="l4.1078" class="difflineplus">+        }</span>
<a href="#l4.1079"></a><span id="l4.1079" class="difflineplus">+        else // just propagate the value, it's some form of simple sentinel</span>
<a href="#l4.1080"></a><span id="l4.1080" class="difflineplus">+          aItem[attrib.boundName] = jsonValue;</span>
<a href="#l4.1081"></a><span id="l4.1081">       }</span>
<a href="#l4.1082"></a><span id="l4.1082" class="difflineminus">-      selects.push(select);</span>
<a href="#l4.1083"></a><span id="l4.1083" class="difflineplus">+      // otherwise, the value just needs to be de-persisted, or not</span>
<a href="#l4.1084"></a><span id="l4.1084" class="difflineplus">+      else if (objectNounDef.fromJSON) {</span>
<a href="#l4.1085"></a><span id="l4.1085" class="difflineplus">+        if (attrib.singular)</span>
<a href="#l4.1086"></a><span id="l4.1086" class="difflineplus">+          aItem[attrib.boundName] = objectNounDef.fromJSON(jsonValue);</span>
<a href="#l4.1087"></a><span id="l4.1087" class="difflineplus">+        else</span>
<a href="#l4.1088"></a><span id="l4.1088" class="difflineplus">+          aItem[attrib.boundName] = [objectNounDef.fromJSON(val) for each</span>
<a href="#l4.1089"></a><span id="l4.1089" class="difflineplus">+            ([, val] in Iterator(jsonValue)];</span>
<a href="#l4.1090"></a><span id="l4.1090" class="difflineplus">+      }</span>
<a href="#l4.1091"></a><span id="l4.1091" class="difflineplus">+      // it's fine as is</span>
<a href="#l4.1092"></a><span id="l4.1092" class="difflineplus">+      else</span>
<a href="#l4.1093"></a><span id="l4.1093" class="difflineplus">+        aItem[attrib.boundName] = jsonValue;</span>
<a href="#l4.1094"></a><span id="l4.1094">     }</span>
<a href="#l4.1095"></a><span id="l4.1095" class="difflineminus">-</span>
<a href="#l4.1096"></a><span id="l4.1096" class="difflineminus">-    let sqlString = &quot;SELECT * FROM messages WHERE id IN (&quot; +</span>
<a href="#l4.1097"></a><span id="l4.1097" class="difflineminus">-                    selects.join(&quot; INTERSECT &quot;) + &quot; )&quot;;</span>
<a href="#l4.1098"></a><span id="l4.1098" class="difflineminus">-    let statement = this._createSyncStatement(sqlString, true);</span>
<a href="#l4.1099"></a><span id="l4.1099" class="difflineminus">-</span>
<a href="#l4.1100"></a><span id="l4.1100" class="difflineminus">-    let messages = [];</span>
<a href="#l4.1101"></a><span id="l4.1101" class="difflineminus">-    while (this._syncStep(statement)) {</span>
<a href="#l4.1102"></a><span id="l4.1102" class="difflineminus">-      messages.push(this._messageFromRow(statement));</span>
<a href="#l4.1103"></a><span id="l4.1103" class="difflineminus">-    }</span>
<a href="#l4.1104"></a><span id="l4.1104" class="difflineminus">-    statement.finalize();</span>
<a href="#l4.1105"></a><span id="l4.1105" class="difflineminus">-</span>
<a href="#l4.1106"></a><span id="l4.1106" class="difflineminus">-    if (messages.length)</span>
<a href="#l4.1107"></a><span id="l4.1107" class="difflineminus">-      GlodaCollectionManager.cacheLoadUnify(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l4.1108"></a><span id="l4.1108" class="difflineminus">-                                            messages);</span>
<a href="#l4.1109"></a><span id="l4.1109" class="difflineminus">-</span>
<a href="#l4.1110"></a><span id="l4.1110" class="difflineminus">-    return messages;</span>
<a href="#l4.1111"></a><span id="l4.1111" class="difflineplus">+    </span>
<a href="#l4.1112"></a><span id="l4.1112" class="difflineplus">+    if (hasDeps)</span>
<a href="#l4.1113"></a><span id="l4.1113" class="difflineplus">+      aItem._deps = deps;</span>
<a href="#l4.1114"></a><span id="l4.1114" class="difflineplus">+    return hasDeps;</span>
<a href="#l4.1115"></a><span id="l4.1115">   },</span>
<a href="#l4.1116"></a><span id="l4.1116"> </span>
<a href="#l4.1117"></a><span id="l4.1117">   /* ********** Contact ********** */</span>
<a href="#l4.1118"></a><span id="l4.1118">   _nextContactId: 1,</span>
<a href="#l4.1119"></a><span id="l4.1119"> </span>
<a href="#l4.1120"></a><span id="l4.1120">   _populateContactManagedId: function () {</span>
<a href="#l4.1121"></a><span id="l4.1121">     let stmt = this._createSyncStatement(&quot;SELECT MAX(id) FROM contacts&quot;, true);</span>
<a href="#l4.1122"></a><span id="l4.1122">     if (stmt.executeStep()) {  // no chance of this SQLITE_BUSY on this call</span>
<a href="#l4.1123"></a><span id="l4.1123">       this._nextContactId = stmt.getInt64(0) + 1;</span>
<a href="#l4.1124"></a><span id="l4.1124">     }</span>
<a href="#l4.1125"></a><span id="l4.1125">     stmt.finalize();</span>
<a href="#l4.1126"></a><span id="l4.1126">   },</span>
<a href="#l4.1127"></a><span id="l4.1127"> </span>
<a href="#l4.1128"></a><span id="l4.1128">   get _insertContactStatement() {</span>
<a href="#l4.1129"></a><span id="l4.1129">     let statement = this._createAsyncStatement(</span>
<a href="#l4.1130"></a><span id="l4.1130">       &quot;INSERT INTO contacts (id, directoryUUID, contactUUID, name, popularity,\</span>
<a href="#l4.1131"></a><span id="l4.1131" class="difflineminus">-                             frecency) \</span>
<a href="#l4.1132"></a><span id="l4.1132" class="difflineminus">-              VALUES (?1, ?2, ?3, ?4, ?5, ?6)&quot;);</span>
<a href="#l4.1133"></a><span id="l4.1133" class="difflineplus">+                             frecency, jsonAttributes) \</span>
<a href="#l4.1134"></a><span id="l4.1134" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)&quot;);</span>
<a href="#l4.1135"></a><span id="l4.1135">     this.__defineGetter__(&quot;_insertContactStatement&quot;, function() statement);</span>
<a href="#l4.1136"></a><span id="l4.1136">     return this._insertContactStatement;</span>
<a href="#l4.1137"></a><span id="l4.1137">   },</span>
<a href="#l4.1138"></a><span id="l4.1138"> </span>
<a href="#l4.1139"></a><span id="l4.1139">   createContact: function gloda_ds_createContact(aDirectoryUUID, aContactUUID,</span>
<a href="#l4.1140"></a><span id="l4.1140">       aName, aPopularity, aFrecency) {</span>
<a href="#l4.1141"></a><span id="l4.1141">     let contactID = this._nextContactId++;</span>
<a href="#l4.1142"></a><span id="l4.1142" class="difflineminus">-    let ics = this._insertContactStatement;</span>
<a href="#l4.1143"></a><span id="l4.1143" class="difflineminus">-    ics.bindInt64Parameter(0, contactID);</span>
<a href="#l4.1144"></a><span id="l4.1144" class="difflineminus">-    if (aDirectoryUUID == null)</span>
<a href="#l4.1145"></a><span id="l4.1145" class="difflineminus">-      ics.bindNullParameter(1);</span>
<a href="#l4.1146"></a><span id="l4.1146" class="difflineminus">-    else</span>
<a href="#l4.1147"></a><span id="l4.1147" class="difflineminus">-      ics.bindStringParameter(1, aDirectoryUUID);</span>
<a href="#l4.1148"></a><span id="l4.1148" class="difflineminus">-    if (aContactUUID == null)</span>
<a href="#l4.1149"></a><span id="l4.1149" class="difflineminus">-      ics.bindNullParameter(2);</span>
<a href="#l4.1150"></a><span id="l4.1150" class="difflineminus">-    else</span>
<a href="#l4.1151"></a><span id="l4.1151" class="difflineminus">-      ics.bindStringParameter(2, aContactUUID);</span>
<a href="#l4.1152"></a><span id="l4.1152" class="difflineminus">-    ics.bindStringParameter(3, aName);</span>
<a href="#l4.1153"></a><span id="l4.1153" class="difflineminus">-    ics.bindInt64Parameter(4, aPopularity);</span>
<a href="#l4.1154"></a><span id="l4.1154" class="difflineminus">-    ics.bindInt64Parameter(5, aFrecency);</span>
<a href="#l4.1155"></a><span id="l4.1155" class="difflineminus">-</span>
<a href="#l4.1156"></a><span id="l4.1156" class="difflineminus">-    ics.executeAsync(this.trackAsync());</span>
<a href="#l4.1157"></a><span id="l4.1157"> </span>
<a href="#l4.1158"></a><span id="l4.1158">     let contact = new GlodaContact(this, contactID,</span>
<a href="#l4.1159"></a><span id="l4.1159">                                    aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l4.1160"></a><span id="l4.1160">                                    aPopularity, aFrecency);</span>
<a href="#l4.1161"></a><span id="l4.1161">     GlodaCollectionManager.itemsAdded(contact.NOUN_ID, [contact]);</span>
<a href="#l4.1162"></a><span id="l4.1162">     return contact;</span>
<a href="#l4.1163"></a><span id="l4.1163">   },</span>
<a href="#l4.1164"></a><span id="l4.1164" class="difflineplus">+  </span>
<a href="#l4.1165"></a><span id="l4.1165" class="difflineplus">+  insertContact: function gloda_ds_insertContact(aContact) {</span>
<a href="#l4.1166"></a><span id="l4.1166" class="difflineplus">+    let ics = this._insertContactStatement;</span>
<a href="#l4.1167"></a><span id="l4.1167" class="difflineplus">+    ics.bindInt64Parameter(0, aContact.id);</span>
<a href="#l4.1168"></a><span id="l4.1168" class="difflineplus">+    if (aContact.directoryUUID == null)</span>
<a href="#l4.1169"></a><span id="l4.1169" class="difflineplus">+      ics.bindNullParameter(1);</span>
<a href="#l4.1170"></a><span id="l4.1170" class="difflineplus">+    else</span>
<a href="#l4.1171"></a><span id="l4.1171" class="difflineplus">+      ics.bindStringParameter(1, aContact.directoryUUID);</span>
<a href="#l4.1172"></a><span id="l4.1172" class="difflineplus">+    if (aContact.contactUUID == null)</span>
<a href="#l4.1173"></a><span id="l4.1173" class="difflineplus">+      ics.bindNullParameter(2);</span>
<a href="#l4.1174"></a><span id="l4.1174" class="difflineplus">+    else</span>
<a href="#l4.1175"></a><span id="l4.1175" class="difflineplus">+      ics.bindStringParameter(2, aContact.contactUUID);</span>
<a href="#l4.1176"></a><span id="l4.1176" class="difflineplus">+    ics.bindStringParameter(3, aContact.name);</span>
<a href="#l4.1177"></a><span id="l4.1177" class="difflineplus">+    ics.bindInt64Parameter(4, aContact.popularity);</span>
<a href="#l4.1178"></a><span id="l4.1178" class="difflineplus">+    ics.bindInt64Parameter(5, aContact.frecency);</span>
<a href="#l4.1179"></a><span id="l4.1179" class="difflineplus">+    if (aContact._jsonText)</span>
<a href="#l4.1180"></a><span id="l4.1180" class="difflineplus">+      ims.bindStringParameter(6, aContact._jsonText);</span>
<a href="#l4.1181"></a><span id="l4.1181" class="difflineplus">+    else</span>
<a href="#l4.1182"></a><span id="l4.1182" class="difflineplus">+      ims.bindNullParameter(6);</span>
<a href="#l4.1183"></a><span id="l4.1183" class="difflineplus">+</span>
<a href="#l4.1184"></a><span id="l4.1184" class="difflineplus">+    ics.executeAsync(this.trackAsync());</span>
<a href="#l4.1185"></a><span id="l4.1185" class="difflineplus">+</span>
<a href="#l4.1186"></a><span id="l4.1186" class="difflineplus">+    GlodaCollectionManager.itemsAdded(contact.NOUN_ID, [contact]);</span>
<a href="#l4.1187"></a><span id="l4.1187" class="difflineplus">+    return contact;</span>
<a href="#l4.1188"></a><span id="l4.1188" class="difflineplus">+  },</span>
<a href="#l4.1189"></a><span id="l4.1189"> </span>
<a href="#l4.1190"></a><span id="l4.1190">   get _updateContactStatement() {</span>
<a href="#l4.1191"></a><span id="l4.1191">     let statement = this._createAsyncStatement(</span>
<a href="#l4.1192"></a><span id="l4.1192">       &quot;UPDATE contacts SET directoryUUID = ?1, \</span>
<a href="#l4.1193"></a><span id="l4.1193">                            contactUUID = ?2, \</span>
<a href="#l4.1194"></a><span id="l4.1194">                            name = ?3, \</span>
<a href="#l4.1195"></a><span id="l4.1195">                            popularity = ?4, \</span>
<a href="#l4.1196"></a><span id="l4.1196" class="difflineminus">-                           frecency = ?5 \</span>
<a href="#l4.1197"></a><span id="l4.1197" class="difflineminus">-                       WHERE id = ?6&quot;);</span>
<a href="#l4.1198"></a><span id="l4.1198" class="difflineplus">+                           frecency = ?5,</span>
<a href="#l4.1199"></a><span id="l4.1199" class="difflineplus">+                           jsonAttributes = ?6 \</span>
<a href="#l4.1200"></a><span id="l4.1200" class="difflineplus">+                       WHERE id = ?7&quot;);</span>
<a href="#l4.1201"></a><span id="l4.1201">     this.__defineGetter__(&quot;_updateContactStatement&quot;, function() statement);</span>
<a href="#l4.1202"></a><span id="l4.1202">     return this._updateContactStatement;</span>
<a href="#l4.1203"></a><span id="l4.1203">   },</span>
<a href="#l4.1204"></a><span id="l4.1204"> </span>
<a href="#l4.1205"></a><span id="l4.1205">   updateContact: function gloda_ds_updateContact(aContact) {</span>
<a href="#l4.1206"></a><span id="l4.1206">     let ucs = this._updateContactStatement;</span>
<a href="#l4.1207"></a><span id="l4.1207" class="difflineminus">-    ucs.bindInt64Parameter(5, aContact.id);</span>
<a href="#l4.1208"></a><span id="l4.1208" class="difflineplus">+    ucs.bindInt64Parameter(6, aContact.id);</span>
<a href="#l4.1209"></a><span id="l4.1209">     ucs.bindStringParameter(0, aContact.directoryUUID);</span>
<a href="#l4.1210"></a><span id="l4.1210">     ucs.bindStringParameter(1, aContact.contactUUID);</span>
<a href="#l4.1211"></a><span id="l4.1211">     ucs.bindStringParameter(2, aContact.name);</span>
<a href="#l4.1212"></a><span id="l4.1212">     ucs.bindInt64Parameter(3, aContact.popularity);</span>
<a href="#l4.1213"></a><span id="l4.1213">     ucs.bindInt64Parameter(4, aContact.frecency);</span>
<a href="#l4.1214"></a><span id="l4.1214" class="difflineplus">+    if (aContact._jsonText)</span>
<a href="#l4.1215"></a><span id="l4.1215" class="difflineplus">+      ims.bindStringParameter(5, aContact._jsonText);</span>
<a href="#l4.1216"></a><span id="l4.1216" class="difflineplus">+    else</span>
<a href="#l4.1217"></a><span id="l4.1217" class="difflineplus">+      ims.bindNullParameter(5);</span>
<a href="#l4.1218"></a><span id="l4.1218"> </span>
<a href="#l4.1219"></a><span id="l4.1219">     ucs.executeAsync(this.trackAsync());</span>
<a href="#l4.1220"></a><span id="l4.1220">   },</span>
<a href="#l4.1221"></a><span id="l4.1221"> </span>
<a href="#l4.1222"></a><span id="l4.1222">   _contactFromRow: function gloda_ds_contactFromRow(aRow) {</span>
<a href="#l4.1223"></a><span id="l4.1223">     let directoryUUID, contactUUID;</span>
<a href="#l4.1224"></a><span id="l4.1224">     if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l4.1225"></a><span id="l4.1225">       directoryUUID = null;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/modules/explattr.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/modules/explattr.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -103,24 +103,16 @@ var GlodaExplicitAttr = {</span>
<a href="#l5.4"></a><span id="l5.4">                         bindName: &quot;tags&quot;,</span>
<a href="#l5.5"></a><span id="l5.5">                         singular: false,</span>
<a href="#l5.6"></a><span id="l5.6">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l5.7"></a><span id="l5.7">                         objectNoun: Gloda.NOUN_TAG,</span>
<a href="#l5.8"></a><span id="l5.8">                         parameterNoun: null,</span>
<a href="#l5.9"></a><span id="l5.9">                         // Property change notifications that we care about:</span>
<a href="#l5.10"></a><span id="l5.10">                         propertyChanges: [&quot;keywords&quot;],</span>
<a href="#l5.11"></a><span id="l5.11">                         }); // not-tested</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-    Gloda.defineNounAction(Gloda.NOUN_TAG, {</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineminus">-      actionType: &quot;filter&quot;, actionTarget: Gloda.NOUN_TAG,</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineminus">-      shortName: &quot;same tag&quot;,</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineminus">-      makeConstraint: function(aAttrDef, aTagged) {</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineminus">-        return [GlodaExplicitAttr._attrTag].concat(</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineminus">-          TagNoun.toParamAndValue(aTagged, true));</span>
<a href="#l5.18"></a><span id="l5.18" class="difflineminus">-      },</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineminus">-      });</span>
<a href="#l5.20"></a><span id="l5.20"> </span>
<a href="#l5.21"></a><span id="l5.21">     // Star</span>
<a href="#l5.22"></a><span id="l5.22">     this._attrStar = Gloda.defineAttribute({</span>
<a href="#l5.23"></a><span id="l5.23">                         provider: this,</span>
<a href="#l5.24"></a><span id="l5.24">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l5.25"></a><span id="l5.25">                         attributeType: Gloda.kAttrExplicit,</span>
<a href="#l5.26"></a><span id="l5.26">                         attributeName: &quot;star&quot;,</span>
<a href="#l5.27"></a><span id="l5.27">                         bind: true,</span>
<a href="#l5.28"></a><span id="l5.28" class="difflineat">@@ -141,35 +133,33 @@ var GlodaExplicitAttr = {</span>
<a href="#l5.29"></a><span id="l5.29">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l5.30"></a><span id="l5.30">                         objectNoun: Gloda.NOUN_BOOLEAN,</span>
<a href="#l5.31"></a><span id="l5.31">                         parameterNoun: null,</span>
<a href="#l5.32"></a><span id="l5.32">                         }); // tested-by: test_attributes_explicit</span>
<a href="#l5.33"></a><span id="l5.33">     </span>
<a href="#l5.34"></a><span id="l5.34">   },</span>
<a href="#l5.35"></a><span id="l5.35">   </span>
<a href="#l5.36"></a><span id="l5.36">   process: function Gloda_explattr_process(aGlodaMessage, aMsgHdr, aMimeMsg) {</span>
<a href="#l5.37"></a><span id="l5.37" class="difflineminus">-    let attribs = [];</span>
<a href="#l5.38"></a><span id="l5.38" class="difflineplus">+    aGlodaMessage.flagged = aMsgHdr.isFlagged;</span>
<a href="#l5.39"></a><span id="l5.39" class="difflineplus">+    aGlodeMessage.read = aMsgHdr.isRead;</span>
<a href="#l5.40"></a><span id="l5.40">     </span>
<a href="#l5.41"></a><span id="l5.41" class="difflineminus">-    attribs.push([this._attrStar.id, aMsgHdr.isFlagged ? 1 : 0]);</span>
<a href="#l5.42"></a><span id="l5.42" class="difflineminus">-    attribs.push([this._attrRead.id, aMsgHdr.isRead ? 1 : 0]);</span>
<a href="#l5.43"></a><span id="l5.43" class="difflineplus">+    let tags = aGlodaMessage.tags = [];</span>
<a href="#l5.44"></a><span id="l5.44">     </span>
<a href="#l5.45"></a><span id="l5.45">     // -- Tag</span>
<a href="#l5.46"></a><span id="l5.46">     // build a map of the keywords</span>
<a href="#l5.47"></a><span id="l5.47">     let keywords = aMsgHdr.getStringProperty(&quot;keywords&quot;);</span>
<a href="#l5.48"></a><span id="l5.48">     let keywordList = keywords.split(' ');</span>
<a href="#l5.49"></a><span id="l5.49">     let keywordMap = {};</span>
<a href="#l5.50"></a><span id="l5.50">     for (let iKeyword = 0; iKeyword &lt; keywordList.length; iKeyword++) {</span>
<a href="#l5.51"></a><span id="l5.51">       let keyword = keywordList[iKeyword];</span>
<a href="#l5.52"></a><span id="l5.52">       keywordMap[keyword] = true;</span>
<a href="#l5.53"></a><span id="l5.53">     }</span>
<a href="#l5.54"></a><span id="l5.54"> </span>
<a href="#l5.55"></a><span id="l5.55" class="difflineminus">-    let nowPRTime = Date.now() * 1000;</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineminus">-</span>
<a href="#l5.57"></a><span id="l5.57">     let tagArray = this._msgTagService.getAllTags({});</span>
<a href="#l5.58"></a><span id="l5.58">     for (let iTag = 0; iTag &lt; tagArray.length; iTag++) {</span>
<a href="#l5.59"></a><span id="l5.59">       let tag = tagArray[iTag];</span>
<a href="#l5.60"></a><span id="l5.60">       if (tag.key in keywordMap)</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineminus">-        attribs.push([this._attrTag, tag.key, nowPRTime]);</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineplus">+        tags.push(tag);</span>
<a href="#l5.63"></a><span id="l5.63">     }</span>
<a href="#l5.64"></a><span id="l5.64">     </span>
<a href="#l5.65"></a><span id="l5.65" class="difflineminus">-    return attribs;</span>
<a href="#l5.66"></a><span id="l5.66" class="difflineplus">+    yield Gloda.kWorkDone;</span>
<a href="#l5.67"></a><span id="l5.67">   },</span>
<a href="#l5.68"></a><span id="l5.68"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/modules/fundattr.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/modules/fundattr.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -164,38 +164,16 @@ var GlodaFundAttr = {</span>
<a href="#l6.4"></a><span id="l6.4">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l6.5"></a><span id="l6.5">                         attributeName: &quot;cc&quot;,</span>
<a href="#l6.6"></a><span id="l6.6">                         bind: true,</span>
<a href="#l6.7"></a><span id="l6.7">                         singular: false,</span>
<a href="#l6.8"></a><span id="l6.8">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l6.9"></a><span id="l6.9">                         objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l6.10"></a><span id="l6.10">                         }); // not-tested</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-    Gloda.defineNounAction(Gloda.NOUN_IDENTITY, {actionType: &quot;filter&quot;,</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineminus">-      actionTarget: Gloda.NOUN_MESSAGE,</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineminus">-      shortName: &quot;from&quot;,</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineminus">-      makeConstraint: function(aAttrDef, aIdentity) {</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineminus">-        return [GlodaFundAttr._attrFrom, null, aIdentity.id];</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineminus">-      },</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineminus">-      });</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineminus">-    Gloda.defineNounAction(Gloda.NOUN_IDENTITY, {actionType: &quot;filter&quot;,</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineminus">-      actionTarget: Gloda.NOUN_MESSAGE,</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineminus">-      shortName: &quot;to&quot;,</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineminus">-      makeConstraint: function(aAttrDef, aIdentity) {</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineminus">-        return [GlodaFundAttr._attrTo, null, aIdentity.id];</span>
<a href="#l6.24"></a><span id="l6.24" class="difflineminus">-      },</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineminus">-      });</span>
<a href="#l6.26"></a><span id="l6.26" class="difflineminus">-    Gloda.defineNounAction(Gloda.NOUN_IDENTITY, {actionType: &quot;filter&quot;,</span>
<a href="#l6.27"></a><span id="l6.27" class="difflineminus">-      actionTarget: Gloda.NOUN_MESSAGE,</span>
<a href="#l6.28"></a><span id="l6.28" class="difflineminus">-      shortName: &quot;cc&quot;,</span>
<a href="#l6.29"></a><span id="l6.29" class="difflineminus">-      makeConstraint: function(aAttrDef, aIdentity) {</span>
<a href="#l6.30"></a><span id="l6.30" class="difflineminus">-        return [GlodaFundAttr._attrCc, null, aIdentity.id];</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineminus">-      },</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineminus">-      });</span>
<a href="#l6.33"></a><span id="l6.33" class="difflineminus">-</span>
<a href="#l6.34"></a><span id="l6.34">     // Date.  now lives on the row.</span>
<a href="#l6.35"></a><span id="l6.35">     this._attrDate = Gloda.defineAttribute({</span>
<a href="#l6.36"></a><span id="l6.36">                         provider: this,</span>
<a href="#l6.37"></a><span id="l6.37">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l6.38"></a><span id="l6.38">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l6.39"></a><span id="l6.39">                         attributeName: &quot;date&quot;,</span>
<a href="#l6.40"></a><span id="l6.40">                         bind: false,</span>
<a href="#l6.41"></a><span id="l6.41">                         singular: true,</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineat">@@ -301,79 +279,111 @@ var GlodaFundAttr = {</span>
<a href="#l6.43"></a><span id="l6.43">    * Specializations:</span>
<a href="#l6.44"></a><span id="l6.44">    * - Mailing Lists.  Replies to a message on a mailing list frequently only</span>
<a href="#l6.45"></a><span id="l6.45">    *   have the list-serve as the 'to', so we try to generate a synthetic 'to'</span>
<a href="#l6.46"></a><span id="l6.46">    *   based on the author of the parent message when possible.  (The 'possible'</span>
<a href="#l6.47"></a><span id="l6.47">    *   part is that we may not have a copy of the parent message at the time of</span>
<a href="#l6.48"></a><span id="l6.48">    *   processing.)</span>
<a href="#l6.49"></a><span id="l6.49">    * - Newsgroups.  Same deal as mailing lists.</span>
<a href="#l6.50"></a><span id="l6.50">    */</span>
<a href="#l6.51"></a><span id="l6.51" class="difflineminus">-  process: function gloda_fundattr_process(aGlodaMessage, aMsgHdr, aMimeMsg,</span>
<a href="#l6.52"></a><span id="l6.52" class="difflineminus">-                                           aIsNew) {</span>
<a href="#l6.53"></a><span id="l6.53" class="difflineminus">-    let attribs = [];</span>
<a href="#l6.54"></a><span id="l6.54" class="difflineplus">+  process: function gloda_fundattr_process(aGlodaMessage, aRawReps,</span>
<a href="#l6.55"></a><span id="l6.55" class="difflineplus">+                                           aIsNew, aCallbackHandle) {</span>
<a href="#l6.56"></a><span id="l6.56" class="difflineplus">+    let aMsgHdr = aRawReps.header;</span>
<a href="#l6.57"></a><span id="l6.57" class="difflineplus">+    let aMimeMsg = aRawReps.mime;</span>
<a href="#l6.58"></a><span id="l6.58" class="difflineplus">+    </span>
<a href="#l6.59"></a><span id="l6.59" class="difflineplus">+    let attribs = aGlodaMessage.attributes;</span>
<a href="#l6.60"></a><span id="l6.60" class="difflineplus">+    let optimizations = aGlobaMessage.optimizationAttributes;</span>
<a href="#l6.61"></a><span id="l6.61" class="difflineplus">+    </span>
<a href="#l6.62"></a><span id="l6.62">     let involvedIdentities = {};</span>
<a href="#l6.63"></a><span id="l6.63">     </span>
<a href="#l6.64"></a><span id="l6.64" class="difflineplus">+    let involved = aGlodaMessage.involved;</span>
<a href="#l6.65"></a><span id="l6.65" class="difflineplus">+    if (involved === undefined)</span>
<a href="#l6.66"></a><span id="l6.66" class="difflineplus">+      involved = aGlodaMessage.involved = [];</span>
<a href="#l6.67"></a><span id="l6.67" class="difflineplus">+    let to = aGlodaMessage.to;</span>
<a href="#l6.68"></a><span id="l6.68" class="difflineplus">+    if (to === undefined)</span>
<a href="#l6.69"></a><span id="l6.69" class="difflineplus">+      to = aGlodaMessage.to = [];</span>
<a href="#l6.70"></a><span id="l6.70" class="difflineplus">+    let cc = aGlodaMessage.cc;</span>
<a href="#l6.71"></a><span id="l6.71" class="difflineplus">+    if (cc === undefined)</span>
<a href="#l6.72"></a><span id="l6.72" class="difflineplus">+      cc = aGlodaMessage.cc = [];</span>
<a href="#l6.73"></a><span id="l6.73" class="difflineplus">+    </span>
<a href="#l6.74"></a><span id="l6.74" class="difflineplus">+    // me specialization optimizations</span>
<a href="#l6.75"></a><span id="l6.75" class="difflineplus">+    let toMe = aGlodaMessage.toMe;</span>
<a href="#l6.76"></a><span id="l6.76" class="difflineplus">+    if (toMe === undefined)</span>
<a href="#l6.77"></a><span id="l6.77" class="difflineplus">+      toMe = aGlodaMessage.toMe = [];</span>
<a href="#l6.78"></a><span id="l6.78" class="difflineplus">+    let fromMeTo = aGlodaMessage.fromMeTo;</span>
<a href="#l6.79"></a><span id="l6.79" class="difflineplus">+    if (fromMeTo === undefined)</span>
<a href="#l6.80"></a><span id="l6.80" class="difflineplus">+      fromMeTo = aGlodaMessage.fromMeTo = [];</span>
<a href="#l6.81"></a><span id="l6.81" class="difflineplus">+    let ccMe = aGlodaMessage.ccMe;</span>
<a href="#l6.82"></a><span id="l6.82" class="difflineplus">+    if (ccMe === undefineD)</span>
<a href="#l6.83"></a><span id="l6.83" class="difflineplus">+      ccMe = aGlodaMEssage.ccMe = [];</span>
<a href="#l6.84"></a><span id="l6.84" class="difflineplus">+    let fromMeCc = aGlodaMessage.fromMeCc;</span>
<a href="#l6.85"></a><span id="l6.85" class="difflineplus">+    if (fromMeCc === undefined)</span>
<a href="#l6.86"></a><span id="l6.86" class="difflineplus">+      fromMeCc = aGlodaMessage.fromMeCc = [];</span>
<a href="#l6.87"></a><span id="l6.87" class="difflineplus">+    </span>
<a href="#l6.88"></a><span id="l6.88">     // -- From</span>
<a href="#l6.89"></a><span id="l6.89">     // Let's use replyTo if available.</span>
<a href="#l6.90"></a><span id="l6.90">     // er, since we are just dealing with mailing lists for now, forget the</span>
<a href="#l6.91"></a><span id="l6.91">     //  reply-to...</span>
<a href="#l6.92"></a><span id="l6.92">     // TODO: deal with default charset issues</span>
<a href="#l6.93"></a><span id="l6.93">     let author = null;</span>
<a href="#l6.94"></a><span id="l6.94">     /*</span>
<a href="#l6.95"></a><span id="l6.95">     try {</span>
<a href="#l6.96"></a><span id="l6.96">       author = aMsgHdr.getStringProperty(&quot;replyTo&quot;);</span>
<a href="#l6.97"></a><span id="l6.97">     }</span>
<a href="#l6.98"></a><span id="l6.98">     catch (ex) {</span>
<a href="#l6.99"></a><span id="l6.99">     }</span>
<a href="#l6.100"></a><span id="l6.100">     */</span>
<a href="#l6.101"></a><span id="l6.101">     if (author == null || author == &quot;&quot;)</span>
<a href="#l6.102"></a><span id="l6.102">       author = aMsgHdr.author;</span>
<a href="#l6.103"></a><span id="l6.103" class="difflineplus">+    </span>
<a href="#l6.104"></a><span id="l6.104" class="difflineplus">+    let [authorIdentities, toIdentities, ccIdentities] =</span>
<a href="#l6.105"></a><span id="l6.105" class="difflineplus">+      yield aCallbackHandle.pushAndGo(</span>
<a href="#l6.106"></a><span id="l6.106" class="difflineplus">+        Gloda.getOrCreateMailIdentities(aCallbackHandle,</span>
<a href="#l6.107"></a><span id="l6.107" class="difflineplus">+                                        author, aMsgHdr.recipients,</span>
<a href="#l6.108"></a><span id="l6.108" class="difflineplus">+                                        aMsgHdr.ccList));</span>
<a href="#l6.109"></a><span id="l6.109"> </span>
<a href="#l6.110"></a><span id="l6.110" class="difflineminus">-    let authorIdentity = Gloda.getIdentityForFullMailAddress(author);</span>
<a href="#l6.111"></a><span id="l6.111" class="difflineminus">-    if (authorIdentity == null) {</span>
<a href="#l6.112"></a><span id="l6.112" class="difflineplus">+    if (authorIdentities.length == 0) {</span>
<a href="#l6.113"></a><span id="l6.113">       this._log.error(&quot;Message with subject '&quot; + aMsgHdr.mime2DecodedSubject +</span>
<a href="#l6.114"></a><span id="l6.114">                       &quot;' somehow lacks a valid author.  Bailing.&quot;);</span>
<a href="#l6.115"></a><span id="l6.115">       return attribs;</span>
<a href="#l6.116"></a><span id="l6.116">     }</span>
<a href="#l6.117"></a><span id="l6.117" class="difflineminus">-    attribs.push([this._attrFrom.id, authorIdentity.id]);</span>
<a href="#l6.118"></a><span id="l6.118" class="difflineminus">-    attribs.push([this._attrInvolves.id, authorIdentity.id]);</span>
<a href="#l6.119"></a><span id="l6.119" class="difflineminus">-    involvedIdentities[authorIdentity.id] = true;</span>
<a href="#l6.120"></a><span id="l6.120" class="difflineplus">+    aGlodaMessage.from = authorIdentities[0];</span>
<a href="#l6.121"></a><span id="l6.121" class="difflineplus">+    involved.push(authorIdentities[0]);</span>
<a href="#l6.122"></a><span id="l6.122" class="difflineplus">+    involvedIdentities[authorIdentities[0].id] = true;</span>
<a href="#l6.123"></a><span id="l6.123">     </span>
<a href="#l6.124"></a><span id="l6.124">     let myIdentities = Gloda.myIdentities; // needless optimization?</span>
<a href="#l6.125"></a><span id="l6.125">     let isFromMe = authorIdentity.id in myIdentities;</span>
<a href="#l6.126"></a><span id="l6.126">     </span>
<a href="#l6.127"></a><span id="l6.127">     // -- To, Cc</span>
<a href="#l6.128"></a><span id="l6.128">     // TODO: handle mailing list semantics (use my visterity logic as a first</span>
<a href="#l6.129"></a><span id="l6.129">     //  pass.)</span>
<a href="#l6.130"></a><span id="l6.130" class="difflineminus">-    let toIdentities = Gloda.getIdentitiesForFullMailAddresses(</span>
<a href="#l6.131"></a><span id="l6.131" class="difflineminus">-                           aMsgHdr.recipients);</span>
<a href="#l6.132"></a><span id="l6.132">     for (let iTo = 0; iTo &lt; toIdentities.length; iTo++) {</span>
<a href="#l6.133"></a><span id="l6.133">       let toIdentity = toIdentities[iTo];</span>
<a href="#l6.134"></a><span id="l6.134" class="difflineminus">-      attribs.push([this._attrTo.id, toIdentity.id]);</span>
<a href="#l6.135"></a><span id="l6.135" class="difflineplus">+      to.push(toIdentity);</span>
<a href="#l6.136"></a><span id="l6.136">       if (!(toIdentity.id in involvedIdentities)) {</span>
<a href="#l6.137"></a><span id="l6.137" class="difflineminus">-        attribs.push([this._attrInvolves.id, toIdentity.id]);</span>
<a href="#l6.138"></a><span id="l6.138" class="difflineplus">+        involved.push(toIdentity);</span>
<a href="#l6.139"></a><span id="l6.139">         involvedIdentities[toIdentity.id] = true;</span>
<a href="#l6.140"></a><span id="l6.140">       }</span>
<a href="#l6.141"></a><span id="l6.141">       // optimization attribute to-me ('I' am the parameter)</span>
<a href="#l6.142"></a><span id="l6.142">       if (toIdentity.id in myIdentities) {</span>
<a href="#l6.143"></a><span id="l6.143">         attribs.push([this._attrCcMe.bindParameter(toIdentity.id),</span>
<a href="#l6.144"></a><span id="l6.144">                       authorIdentity.id]);</span>
<a href="#l6.145"></a><span id="l6.145">         if (aIsNew)</span>
<a href="#l6.146"></a><span id="l6.146">           authorIdentity.contact.popularity += this.POPULARITY_TO_ME;</span>
<a href="#l6.147"></a><span id="l6.147">       }</span>
<a href="#l6.148"></a><span id="l6.148">       // optimization attribute from-me-to ('I' am the parameter)</span>
<a href="#l6.149"></a><span id="l6.149">       if (isFromMe) {</span>
<a href="#l6.150"></a><span id="l6.150" class="difflineplus">+        fromMeTo.push(</span>
<a href="#l6.151"></a><span id="l6.151">         attribs.push([this._attrFromMeCc.bindParameter(authorIdentity.id),</span>
<a href="#l6.152"></a><span id="l6.152">                       toIdentity.id]);</span>
<a href="#l6.153"></a><span id="l6.153">         // also, popularity</span>
<a href="#l6.154"></a><span id="l6.154">         if (aIsNew)</span>
<a href="#l6.155"></a><span id="l6.155">           toIdentity.contact.popularity += this.POPULARITY_FROM_ME_TO;</span>
<a href="#l6.156"></a><span id="l6.156">       }</span>
<a href="#l6.157"></a><span id="l6.157">     }</span>
<a href="#l6.158"></a><span id="l6.158" class="difflineminus">-    let ccIdentities = Gloda.getIdentitiesForFullMailAddresses(aMsgHdr.ccList);</span>
<a href="#l6.159"></a><span id="l6.159">     for (let iCc = 0; iCc &lt; ccIdentities.length; iCc++) {</span>
<a href="#l6.160"></a><span id="l6.160">       let ccIdentity = ccIdentities[iCc];</span>
<a href="#l6.161"></a><span id="l6.161">       attribs.push([this._attrCc.id, ccIdentity.id]);</span>
<a href="#l6.162"></a><span id="l6.162">       if (!(ccIdentity.id in involvedIdentities)) {</span>
<a href="#l6.163"></a><span id="l6.163">         attribs.push([this._attrInvolves.id, ccIdentity.id]);</span>
<a href="#l6.164"></a><span id="l6.164">         involvedIdentities[ccIdentity.id] = true;</span>
<a href="#l6.165"></a><span id="l6.165">       }</span>
<a href="#l6.166"></a><span id="l6.166">       // optimization attribute cc-me ('I' am the parameter)</span>
<a href="#l6.167"></a><span id="l6.167" class="difflineat">@@ -396,11 +406,11 @@ var GlodaFundAttr = {</span>
<a href="#l6.168"></a><span id="l6.168">     // TODO: deal with mailing lists, including implicit-to.  this will require</span>
<a href="#l6.169"></a><span id="l6.169">     //  convincing the indexer to pass us in the previous message if it is</span>
<a href="#l6.170"></a><span id="l6.170">     //  available.  (which we'll simply pass to everyone... it can help body</span>
<a href="#l6.171"></a><span id="l6.171">     //  logic for quoting purposes, etc. too.)</span>
<a href="#l6.172"></a><span id="l6.172">     </span>
<a href="#l6.173"></a><span id="l6.173">     // -- Date</span>
<a href="#l6.174"></a><span id="l6.174">     attribs.push([this._attrDate.id, aMsgHdr.date]);</span>
<a href="#l6.175"></a><span id="l6.175">     </span>
<a href="#l6.176"></a><span id="l6.176" class="difflineminus">-    return attribs;</span>
<a href="#l6.177"></a><span id="l6.177" class="difflineplus">+    yield Gloda.kWorkDone;</span>
<a href="#l6.178"></a><span id="l6.178">   },</span>
<a href="#l6.179"></a><span id="l6.179"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -146,17 +146,18 @@ var Gloda = {</span>
<a href="#l7.4"></a><span id="l7.4">    *  current user (based on accounts).</span>
<a href="#l7.5"></a><span id="l7.5">    *</span>
<a href="#l7.6"></a><span id="l7.6">    * Additional nouns and the core attribute providers are initialized by the</span>
<a href="#l7.7"></a><span id="l7.7">    *  everybody.js module which ensures all of those dependencies are loaded</span>
<a href="#l7.8"></a><span id="l7.8">    *  (and initialized).</span>
<a href="#l7.9"></a><span id="l7.9">    */</span>
<a href="#l7.10"></a><span id="l7.10">   _init: function gloda_ns_init() {</span>
<a href="#l7.11"></a><span id="l7.11">     this._initLogging();</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-    GlodaDatastore._init();</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+    this._json = Cc[&quot;@mozilla.org/dom/json;1&quot;].createInstance(Ci.nsIJSON);</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+    GlodaDatastore._init(this._jsn);</span>
<a href="#l7.15"></a><span id="l7.15">     this._initAttributes();</span>
<a href="#l7.16"></a><span id="l7.16">     this._initMyIdentities();</span>
<a href="#l7.17"></a><span id="l7.17">   },</span>
<a href="#l7.18"></a><span id="l7.18"> </span>
<a href="#l7.19"></a><span id="l7.19">   _log: null,</span>
<a href="#l7.20"></a><span id="l7.20">   /**</span>
<a href="#l7.21"></a><span id="l7.21">    * Initialize logging; the error console window gets Warning/Error, and stdout</span>
<a href="#l7.22"></a><span id="l7.22">    *  (via dump) gets everything.</span>
<a href="#l7.23"></a><span id="l7.23" class="difflineat">@@ -178,89 +179,135 @@ var Gloda = {</span>
<a href="#l7.24"></a><span id="l7.24">     this._log.info(&quot;Logging Initialized&quot;);</span>
<a href="#l7.25"></a><span id="l7.25">   },</span>
<a href="#l7.26"></a><span id="l7.26"> </span>
<a href="#l7.27"></a><span id="l7.27">   kIndexerIdle: 0,</span>
<a href="#l7.28"></a><span id="l7.28">   kIndexerIndexing: 1,</span>
<a href="#l7.29"></a><span id="l7.29">   kIndexerMoving: 2,</span>
<a href="#l7.30"></a><span id="l7.30">   kIndexerRemoving: 3,</span>
<a href="#l7.31"></a><span id="l7.31"> </span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+  /** Synchronous activities performed, you can drive us more. */</span>
<a href="#l7.33"></a><span id="l7.33" class="difflineplus">+  kWorkSync: 0,</span>
<a href="#l7.34"></a><span id="l7.34" class="difflineplus">+  /**</span>
<a href="#l7.35"></a><span id="l7.35" class="difflineplus">+   * Asynchronous activity performed, you need to relinquish flow control and</span>
<a href="#l7.36"></a><span id="l7.36" class="difflineplus">+   *  trust us to call callbackDriver later.</span>
<a href="#l7.37"></a><span id="l7.37" class="difflineplus">+   */</span>
<a href="#l7.38"></a><span id="l7.38" class="difflineplus">+  kWorkAsync: 1,</span>
<a href="#l7.39"></a><span id="l7.39" class="difflineplus">+  /**</span>
<a href="#l7.40"></a><span id="l7.40" class="difflineplus">+   * We are all done with our task, close us and figure out something else to do.</span>
<a href="#l7.41"></a><span id="l7.41" class="difflineplus">+   */</span>
<a href="#l7.42"></a><span id="l7.42" class="difflineplus">+  kWorkDone: 2,</span>
<a href="#l7.43"></a><span id="l7.43" class="difflineplus">+  /**</span>
<a href="#l7.44"></a><span id="l7.44" class="difflineplus">+   * We are not done with our task, but we think it's a good idea to take a</span>
<a href="#l7.45"></a><span id="l7.45" class="difflineplus">+   *  breather.</span>
<a href="#l7.46"></a><span id="l7.46" class="difflineplus">+   */</span>
<a href="#l7.47"></a><span id="l7.47" class="difflineplus">+  kWorkPause: 3,</span>
<a href="#l7.48"></a><span id="l7.48" class="difflineplus">+  /**</span>
<a href="#l7.49"></a><span id="l7.49" class="difflineplus">+   * We are done with our task, and have a result that we are returning.  This</span>
<a href="#l7.50"></a><span id="l7.50" class="difflineplus">+   *  should only be used by your callback handler's doneWithResult method.</span>
<a href="#l7.51"></a><span id="l7.51" class="difflineplus">+   *  Ex: you are passed aCallbackHandle, and you do</span>
<a href="#l7.52"></a><span id="l7.52" class="difflineplus">+   *  &quot;yield aCallbackHandle.doneWithResult(myResult);&quot;.</span>
<a href="#l7.53"></a><span id="l7.53" class="difflineplus">+   */</span>
<a href="#l7.54"></a><span id="l7.54" class="difflineplus">+  kWorkDoneWithResult: 4,</span>
<a href="#l7.55"></a><span id="l7.55" class="difflineplus">+</span>
<a href="#l7.56"></a><span id="l7.56">   /**</span>
<a href="#l7.57"></a><span id="l7.57">    * Lookup a gloda message from an nsIMsgDBHdr.</span>
<a href="#l7.58"></a><span id="l7.58">    *</span>
<a href="#l7.59"></a><span id="l7.59">    * @param aMsgHdr The header of the message you want the gloda message for.</span>
<a href="#l7.60"></a><span id="l7.60">    *</span>
<a href="#l7.61"></a><span id="l7.61">    * @return the gloda messages that corresponds to the provided nsIMsgDBHdr</span>
<a href="#l7.62"></a><span id="l7.62">    *    if one exists, null if one cannot be found.</span>
<a href="#l7.63"></a><span id="l7.63">    */</span>
<a href="#l7.64"></a><span id="l7.64">   getMessageForHeader: function gloda_ns_getMessageForHeader(aMsgHdr) {</span>
<a href="#l7.65"></a><span id="l7.65" class="difflineminus">-    return GlodaDatastore.getMessageFromLocation(aMsgHdr.folder.URI,</span>
<a href="#l7.66"></a><span id="l7.66" class="difflineplus">+    return GlodaDatastore.getMessageFromLocation(aMsgHdr.folder,</span>
<a href="#l7.67"></a><span id="l7.67">                                                  aMsgHdr.messageKey);</span>
<a href="#l7.68"></a><span id="l7.68">   },</span>
<a href="#l7.69"></a><span id="l7.69">   </span>
<a href="#l7.70"></a><span id="l7.70">   getFolderForFolder: function gloda_ns_getFolderForFolder(aMsgFolder) {</span>
<a href="#l7.71"></a><span id="l7.71" class="difflineminus">-    let uri = aMsgFolder.URI;</span>
<a href="#l7.72"></a><span id="l7.72" class="difflineminus">-    return new GlodaFolder(GlodaDatastore, GlodaDatastore._mapFolderURI(uri),</span>
<a href="#l7.73"></a><span id="l7.73" class="difflineminus">-                           uri, aMsgFolder.prettyName);</span>
<a href="#l7.74"></a><span id="l7.74" class="difflineplus">+    return GlodaDatastore._mapFolder(aMsgFolder);</span>
<a href="#l7.75"></a><span id="l7.75">   },</span>
<a href="#l7.76"></a><span id="l7.76" class="difflineminus">-</span>
<a href="#l7.77"></a><span id="l7.77" class="difflineplus">+  </span>
<a href="#l7.78"></a><span id="l7.78">   /**</span>
<a href="#l7.79"></a><span id="l7.79">    * Given one or more full mail addresses (ex: &quot;Bob Smith&quot; &lt;bob@smith.com&gt;),</span>
<a href="#l7.80"></a><span id="l7.80">    *  return a list of the identities that corresponds to each mail address,</span>
<a href="#l7.81"></a><span id="l7.81">    *  creating them as required.</span>
<a href="#l7.82"></a><span id="l7.82">    */</span>
<a href="#l7.83"></a><span id="l7.83" class="difflineminus">-  getIdentitiesForFullMailAddresses:</span>
<a href="#l7.84"></a><span id="l7.84" class="difflineminus">-      function gloda_ns_getIdentitiesForMailAddresses(aMailAddresses) {</span>
<a href="#l7.85"></a><span id="l7.85" class="difflineminus">-    let parsed = GlodaUtils.parseMailAddresses(aMailAddresses);</span>
<a href="#l7.86"></a><span id="l7.86" class="difflineminus">-</span>
<a href="#l7.87"></a><span id="l7.87" class="difflineminus">-    let identities = [];</span>
<a href="#l7.88"></a><span id="l7.88" class="difflineminus">-    for (let iAddress = 0; iAddress &lt; parsed.count; iAddress++) {</span>
<a href="#l7.89"></a><span id="l7.89" class="difflineminus">-      let identity = GlodaDatastore.getIdentity(&quot;email&quot;,</span>
<a href="#l7.90"></a><span id="l7.90" class="difflineminus">-                                                parsed.addresses[iAddress]);</span>
<a href="#l7.91"></a><span id="l7.91" class="difflineminus">-</span>
<a href="#l7.92"></a><span id="l7.92" class="difflineminus">-      if (identity === null) {</span>
<a href="#l7.93"></a><span id="l7.93" class="difflineminus">-        let name = parsed.names[iAddress];</span>
<a href="#l7.94"></a><span id="l7.94" class="difflineminus">-        let mailAddr = parsed.addresses[iAddress];</span>
<a href="#l7.95"></a><span id="l7.95" class="difflineminus">-</span>
<a href="#l7.96"></a><span id="l7.96" class="difflineminus">-        // fall-back to the mail address if the name is empty</span>
<a href="#l7.97"></a><span id="l7.97" class="difflineminus">-        if ((name === null) || (name == &quot;&quot;))</span>
<a href="#l7.98"></a><span id="l7.98" class="difflineminus">-          name = mailAddr;</span>
<a href="#l7.99"></a><span id="l7.99" class="difflineminus">-</span>
<a href="#l7.100"></a><span id="l7.100" class="difflineminus">-        // we must create a contact</span>
<a href="#l7.101"></a><span id="l7.101" class="difflineminus">-        let contact = GlodaDatastore.createContact(null, null, name, 0, 0);</span>
<a href="#l7.102"></a><span id="l7.102" class="difflineminus">-</span>
<a href="#l7.103"></a><span id="l7.103" class="difflineminus">-        // we must create the identity.  use a blank description because there's</span>
<a href="#l7.104"></a><span id="l7.104" class="difflineminus">-        //  nothing to differentiate it from other identities, as this contact</span>
<a href="#l7.105"></a><span id="l7.105" class="difflineminus">-        //  only has one initially (us).</span>
<a href="#l7.106"></a><span id="l7.106" class="difflineminus">-        identity = GlodaDatastore.createIdentity(contact.id, contact, &quot;email&quot;,</span>
<a href="#l7.107"></a><span id="l7.107" class="difflineminus">-                                                 mailAddr,</span>
<a href="#l7.108"></a><span id="l7.108" class="difflineminus">-                                                 &quot;&quot;, false);</span>
<a href="#l7.109"></a><span id="l7.109" class="difflineplus">+  getOrCreateMailIdentities:</span>
<a href="#l7.110"></a><span id="l7.110" class="difflineplus">+      function gloda_ns_getOrCreateMailIdentities(aCallbackHandle) {</span>
<a href="#l7.111"></a><span id="l7.111" class="difflineplus">+    let addresses = {};</span>
<a href="#l7.112"></a><span id="l7.112" class="difflineplus">+    let resultLists = [];</span>
<a href="#l7.113"></a><span id="l7.113" class="difflineplus">+    </span>
<a href="#l7.114"></a><span id="l7.114" class="difflineplus">+    for (let iArg = 1; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l7.115"></a><span id="l7.115" class="difflineplus">+      let aMailAddresses = arguments[iArg];</span>
<a href="#l7.116"></a><span id="l7.116" class="difflineplus">+      let parsed = GlodaUtils.parseMailAddresses(aMailAddresses);</span>
<a href="#l7.117"></a><span id="l7.117" class="difflineplus">+      </span>
<a href="#l7.118"></a><span id="l7.118" class="difflineplus">+      let resultList = [];</span>
<a href="#l7.119"></a><span id="l7.119" class="difflineplus">+      resultLists.push(resultList);</span>
<a href="#l7.120"></a><span id="l7.120" class="difflineplus">+      </span>
<a href="#l7.121"></a><span id="l7.121" class="difflineplus">+      let identities = [];</span>
<a href="#l7.122"></a><span id="l7.122" class="difflineplus">+      for (let iAddress = 0; iAddress &lt; parsed.count; iAddress++) {</span>
<a href="#l7.123"></a><span id="l7.123" class="difflineplus">+        let address = parsed.addresses[iAddress];</span>
<a href="#l7.124"></a><span id="l7.124" class="difflineplus">+        if (address in addresses)</span>
<a href="#l7.125"></a><span id="l7.125" class="difflineplus">+          addresses[address].push(resultList);</span>
<a href="#l7.126"></a><span id="l7.126" class="difflineplus">+        else</span>
<a href="#l7.127"></a><span id="l7.127" class="difflineplus">+          addresses[address] = [parsed.names[iAddress], resultList];</span>
<a href="#l7.128"></a><span id="l7.128">       }</span>
<a href="#l7.129"></a><span id="l7.129" class="difflineminus">-      identities.push(identity);</span>
<a href="#l7.130"></a><span id="l7.130">     }</span>
<a href="#l7.131"></a><span id="l7.131"> </span>
<a href="#l7.132"></a><span id="l7.132" class="difflineminus">-    return identities;</span>
<a href="#l7.133"></a><span id="l7.133" class="difflineminus">-  },</span>
<a href="#l7.134"></a><span id="l7.134" class="difflineplus">+    let query = this.newQuery(this.NOUN_IDENTITY);</span>
<a href="#l7.135"></a><span id="l7.135" class="difflineplus">+    query.kind(&quot;email&quot;);</span>
<a href="#l7.136"></a><span id="l7.136" class="difflineplus">+    query.value.apply(query.value, [address for (address in addresses)]);</span>
<a href="#l7.137"></a><span id="l7.137" class="difflineplus">+    let collection = query.getCollection(aCallbackHandle);</span>
<a href="#l7.138"></a><span id="l7.138" class="difflineplus">+    yield this.kWorkAsync;</span>
<a href="#l7.139"></a><span id="l7.139" class="difflineplus">+</span>
<a href="#l7.140"></a><span id="l7.140" class="difflineplus">+    // put the identities in the appropriate result lists</span>
<a href="#l7.141"></a><span id="l7.141" class="difflineplus">+    for each (let [, identity] in Iterator(collection.items)) {</span>
<a href="#l7.142"></a><span id="l7.142" class="difflineplus">+      let nameAndResultLists = addresses[identity.value];</span>
<a href="#l7.143"></a><span id="l7.143" class="difflineplus">+      // index 0 is the name, skip it</span>
<a href="#l7.144"></a><span id="l7.144" class="difflineplus">+      for (let iResList = 1; iResList &lt; nameAndResultLists.length; iResList++)</span>
<a href="#l7.145"></a><span id="l7.145" class="difflineplus">+        nameAndResultLists[iResList].push(identity);</span>
<a href="#l7.146"></a><span id="l7.146" class="difflineplus">+      }</span>
<a href="#l7.147"></a><span id="l7.147" class="difflineplus">+      delete addresses[identity.value];</span>
<a href="#l7.148"></a><span id="l7.148" class="difflineplus">+    }</span>
<a href="#l7.149"></a><span id="l7.149" class="difflineplus">+    </span>
<a href="#l7.150"></a><span id="l7.150" class="difflineplus">+    // create the identities that did not exist yet</span>
<a href="#l7.151"></a><span id="l7.151" class="difflineplus">+    for each (let [address, nameAndResultLists] in Iterator(addresses)) {</span>
<a href="#l7.152"></a><span id="l7.152" class="difflineplus">+      let name = nameAndResultsLists[0]; </span>
<a href="#l7.153"></a><span id="l7.153"> </span>
<a href="#l7.154"></a><span id="l7.154" class="difflineminus">-  /**</span>
<a href="#l7.155"></a><span id="l7.155" class="difflineminus">-   * Given a full mail address (ex: &quot;Bob Smith&quot; &lt;bob@smith.com&gt;), return the</span>
<a href="#l7.156"></a><span id="l7.156" class="difflineminus">-   *  identity that corresponds to that mail address, creating it if required.</span>
<a href="#l7.157"></a><span id="l7.157" class="difflineminus">-   *  (If you want the contact, it is easily retrieved via the 'contact'</span>
<a href="#l7.158"></a><span id="l7.158" class="difflineminus">-   *  attribute on the identity.)</span>
<a href="#l7.159"></a><span id="l7.159" class="difflineminus">-   */</span>
<a href="#l7.160"></a><span id="l7.160" class="difflineminus">-  getIdentityForFullMailAddress:</span>
<a href="#l7.161"></a><span id="l7.161" class="difflineminus">-      function gloda_ns_getIdentityForFullMailAddress(aMailAddress) {</span>
<a href="#l7.162"></a><span id="l7.162" class="difflineminus">-    let identities = this.getIdentitiesForFullMailAddresses(aMailAddress);</span>
<a href="#l7.163"></a><span id="l7.163" class="difflineminus">-    if (identities.length != 1) {</span>
<a href="#l7.164"></a><span id="l7.164" class="difflineminus">-      this._log.info(&quot;Expected exactly 1 address, got &quot; + identities.length +</span>
<a href="#l7.165"></a><span id="l7.165" class="difflineminus">-                     &quot; for address: &quot; + aMailAddress);</span>
<a href="#l7.166"></a><span id="l7.166" class="difflineminus">-      return null;</span>
<a href="#l7.167"></a><span id="l7.167" class="difflineplus">+      // try and find an existing address book contact.</span>
<a href="#l7.168"></a><span id="l7.168" class="difflineplus">+      let card = GlodaUtils.getCardForEmail();</span>
<a href="#l7.169"></a><span id="l7.169" class="difflineplus">+      // XXX when we have the address book GUID stuff, we need to use that to</span>
<a href="#l7.170"></a><span id="l7.170" class="difflineplus">+      //  find existing contacts... (this will introduce a new query phase</span>
<a href="#l7.171"></a><span id="l7.171" class="difflineplus">+      //  where we batch all the GUIDs for an async query)</span>
<a href="#l7.172"></a><span id="l7.172" class="difflineplus">+      // XXX when the address book supports multiple e-mail addresses, we</span>
<a href="#l7.173"></a><span id="l7.173" class="difflineplus">+      //  should also just create identities for any that don't yet exist</span>
<a href="#l7.174"></a><span id="l7.174" class="difflineplus">+</span>
<a href="#l7.175"></a><span id="l7.175" class="difflineplus">+      let contact = GlodaDatastore.createContact(null, null, name, 0, 0);</span>
<a href="#l7.176"></a><span id="l7.176" class="difflineplus">+      // give the address book indexer a chance if we have a card.</span>
<a href="#l7.177"></a><span id="l7.177" class="difflineplus">+      // (it will fix-up the name based on the card as appropriate)</span>
<a href="#l7.178"></a><span id="l7.178" class="difflineplus">+      if (card)</span>
<a href="#l7.179"></a><span id="l7.179" class="difflineplus">+        yield aCallbackHandle.pushAndGo(</span>
<a href="#l7.180"></a><span id="l7.180" class="difflineplus">+          Gloda.grokNounItem(contact, card, true));</span>
<a href="#l7.181"></a><span id="l7.181" class="difflineplus">+      else // grokNounItem will issue the insert for us...</span>
<a href="#l7.182"></a><span id="l7.182" class="difflineplus">+        GlodaDatastore.insertContact(contact);</span>
<a href="#l7.183"></a><span id="l7.183" class="difflineplus">+</span>
<a href="#l7.184"></a><span id="l7.184" class="difflineplus">+      // we must create the identity.  use a blank description because there's</span>
<a href="#l7.185"></a><span id="l7.185" class="difflineplus">+      //  nothing to differentiate it from other identities, as this contact</span>
<a href="#l7.186"></a><span id="l7.186" class="difflineplus">+      //  only has one initially (us).</span>
<a href="#l7.187"></a><span id="l7.187" class="difflineplus">+      // XXX when we have multiple e-mails and there is a meaning associated</span>
<a href="#l7.188"></a><span id="l7.188" class="difflineplus">+      //  with each e-mail, try and use that to populate the description. </span>
<a href="#l7.189"></a><span id="l7.189" class="difflineplus">+      let identity = GlodaDatastore.createIdentity(contact.id, contact,</span>
<a href="#l7.190"></a><span id="l7.190" class="difflineplus">+        &quot;email&quot;, mailAddr, /* description */ &quot;&quot;, /* relay? */ false);</span>
<a href="#l7.191"></a><span id="l7.191" class="difflineplus">+      </span>
<a href="#l7.192"></a><span id="l7.192" class="difflineplus">+      for (let iResList = 1; iResList &lt; nameAndResultLists.length; iResList++)</span>
<a href="#l7.193"></a><span id="l7.193" class="difflineplus">+        nameAndResultLists[iResList].push(identity);</span>
<a href="#l7.194"></a><span id="l7.194" class="difflineplus">+      }</span>
<a href="#l7.195"></a><span id="l7.195">     }</span>
<a href="#l7.196"></a><span id="l7.196"> </span>
<a href="#l7.197"></a><span id="l7.197" class="difflineminus">-    return identities[0];</span>
<a href="#l7.198"></a><span id="l7.198" class="difflineplus">+    yield aCallbackHandle.doneWithResult(resultLists);</span>
<a href="#l7.199"></a><span id="l7.199">   },</span>
<a href="#l7.200"></a><span id="l7.200"> </span>
<a href="#l7.201"></a><span id="l7.201">   /**</span>
<a href="#l7.202"></a><span id="l7.202">    * Dictionary of the user's known identities; key is the identity id, value</span>
<a href="#l7.203"></a><span id="l7.203">    *  is the actual identity.  This is populated by _initMyIdentities based on</span>
<a href="#l7.204"></a><span id="l7.204">    *  the accounts defined.</span>
<a href="#l7.205"></a><span id="l7.205">    */</span>
<a href="#l7.206"></a><span id="l7.206">   myIdentities: {},</span>
<a href="#l7.207"></a><span id="l7.207" class="difflineat">@@ -338,16 +385,17 @@ var Gloda = {</span>
<a href="#l7.208"></a><span id="l7.208">     if (existingIdentities.length) {</span>
<a href="#l7.209"></a><span id="l7.209">       // just use the first guy's contact</span>
<a href="#l7.210"></a><span id="l7.210">       myContact = existingIdentities[0].contact;</span>
<a href="#l7.211"></a><span id="l7.211">     }</span>
<a href="#l7.212"></a><span id="l7.212">     else {</span>
<a href="#l7.213"></a><span id="l7.213">       // create a new contact</span>
<a href="#l7.214"></a><span id="l7.214">       myContact = GlodaDatastore.createContact(null, null, fullName || &quot;Me&quot;,</span>
<a href="#l7.215"></a><span id="l7.215">                                                0, 0);</span>
<a href="#l7.216"></a><span id="l7.216" class="difflineplus">+      GlodaDatastore.insertContact(myContact);</span>
<a href="#l7.217"></a><span id="l7.217">     }</span>
<a href="#l7.218"></a><span id="l7.218"> </span>
<a href="#l7.219"></a><span id="l7.219">     if (identitiesToCreate.length) {</span>
<a href="#l7.220"></a><span id="l7.220">       for (let iIdentity = 0; iIdentity &lt; identitiesToCreate.length;</span>
<a href="#l7.221"></a><span id="l7.221">           iIdentity++) {</span>
<a href="#l7.222"></a><span id="l7.222">         let emailAddress = identitiesToCreate[iIdentity];</span>
<a href="#l7.223"></a><span id="l7.223">         // XXX this won't always be of type &quot;email&quot; as we add new account types</span>
<a href="#l7.224"></a><span id="l7.224">         // XXX the blank string could be trying to differentiate; we do have</span>
<a href="#l7.225"></a><span id="l7.225" class="difflineat">@@ -406,29 +454,29 @@ var Gloda = {</span>
<a href="#l7.226"></a><span id="l7.226">    *  first class noun.)</span>
<a href="#l7.227"></a><span id="l7.227">    */</span>
<a href="#l7.228"></a><span id="l7.228">   kSpecialNotAtAll: 0,</span>
<a href="#l7.229"></a><span id="l7.229">   /**</span>
<a href="#l7.230"></a><span id="l7.230">    * This attribute is stored as a numeric column on the row for the noun.  The</span>
<a href="#l7.231"></a><span id="l7.231">    *  attribute definition should include this value as 'special' and the</span>
<a href="#l7.232"></a><span id="l7.232">    *  column name that stores the attribute as 'specialColumnName'.</span>
<a href="#l7.233"></a><span id="l7.233">    */</span>
<a href="#l7.234"></a><span id="l7.234" class="difflineminus">-  kSpecialColumn: 1,</span>
<a href="#l7.235"></a><span id="l7.235" class="difflineplus">+  kSpecialColumn: GlodaDatastore.kSpecialColumn,</span>
<a href="#l7.236"></a><span id="l7.236">   /**</span>
<a href="#l7.237"></a><span id="l7.237">    * This attribute is stored as a string column on the row for the noun.  It</span>
<a href="#l7.238"></a><span id="l7.238">    *  differs from kSpecialColumn in that it is a string and thus uses different</span>
<a href="#l7.239"></a><span id="l7.239">    *  query mechanisms.</span>
<a href="#l7.240"></a><span id="l7.240">    */</span>
<a href="#l7.241"></a><span id="l7.241" class="difflineminus">-  kSpecialString: 2,</span>
<a href="#l7.242"></a><span id="l7.242" class="difflineplus">+  kSpecialString: GlodaDatastore.kSpecialString,</span>
<a href="#l7.243"></a><span id="l7.243">   /**</span>
<a href="#l7.244"></a><span id="l7.244">    * This attribute is stored as a fulltext column on the fulltext table for</span>
<a href="#l7.245"></a><span id="l7.245">    *  the noun.  The attribute defintion should include this value as 'special'</span>
<a href="#l7.246"></a><span id="l7.246">    *  and the column name that stores the table as 'specialColumnName'.</span>
<a href="#l7.247"></a><span id="l7.247">    */</span>
<a href="#l7.248"></a><span id="l7.248" class="difflineminus">-  kSpecialFulltext: 3,</span>
<a href="#l7.249"></a><span id="l7.249" class="difflineplus">+  kSpecialFulltext: GlodaDatastore.kSpecialFulltext,</span>
<a href="#l7.250"></a><span id="l7.250"> </span>
<a href="#l7.251"></a><span id="l7.251">   /**</span>
<a href="#l7.252"></a><span id="l7.252">    * The extensionName used for the attributes defined by core gloda plugins</span>
<a href="#l7.253"></a><span id="l7.253">    *  such as fundattr.js and explattr.js.</span>
<a href="#l7.254"></a><span id="l7.254">    */</span>
<a href="#l7.255"></a><span id="l7.255">   BUILT_IN: &quot;built-in&quot;,</span>
<a href="#l7.256"></a><span id="l7.256"> </span>
<a href="#l7.257"></a><span id="l7.257"> </span>
<a href="#l7.258"></a><span id="l7.258" class="difflineat">@@ -542,29 +590,33 @@ var Gloda = {</span>
<a href="#l7.259"></a><span id="l7.259">    */</span>
<a href="#l7.260"></a><span id="l7.260">   _nounNameToNounID: {},</span>
<a href="#l7.261"></a><span id="l7.261">   /**</span>
<a href="#l7.262"></a><span id="l7.262">    * Maps noun IDs to noun meta dictionaries.  (Noun meta dictionaries being</span>
<a href="#l7.263"></a><span id="l7.263">    *  the dictionary provided to us at the time a noun was defined, plus some</span>
<a href="#l7.264"></a><span id="l7.264">    *  additional stuff we put in there.)</span>
<a href="#l7.265"></a><span id="l7.265">    */</span>
<a href="#l7.266"></a><span id="l7.266">   _nounIDToMeta: {},</span>
<a href="#l7.267"></a><span id="l7.267" class="difflineplus">+  </span>
<a href="#l7.268"></a><span id="l7.268" class="difflineplus">+  _managedToJSON: function gloda_ns_managedToJSON(aItem) {</span>
<a href="#l7.269"></a><span id="l7.269" class="difflineplus">+    return aItem.id;</span>
<a href="#l7.270"></a><span id="l7.270" class="difflineplus">+  }</span>
<a href="#l7.271"></a><span id="l7.271"> </span>
<a href="#l7.272"></a><span id="l7.272">   /**</span>
<a href="#l7.273"></a><span id="l7.273">    * Define a noun.  Takes a dictionary with the following keys/values:</span>
<a href="#l7.274"></a><span id="l7.274">    *</span>
<a href="#l7.275"></a><span id="l7.275">    * @param name The name of the noun.  This is not a display name (anything</span>
<a href="#l7.276"></a><span id="l7.276">    *     being displayed needs to be localized, after all), but simply the</span>
<a href="#l7.277"></a><span id="l7.277">    *     canonical name for debugging purposes and for people to pass to</span>
<a href="#l7.278"></a><span id="l7.278">    *     lookupNoun.  The suggested convention is lower-case-dash-delimited,</span>
<a href="#l7.279"></a><span id="l7.279">    *     with names being singular (since it's a single noun we are referring</span>
<a href="#l7.280"></a><span id="l7.280">    *     to.)</span>
<a href="#l7.281"></a><span id="l7.281">    * @param class The 'class' to which an instance of the noun will belong (aka</span>
<a href="#l7.282"></a><span id="l7.282">    *     will pass an instanceof test).</span>
<a href="#l7.283"></a><span id="l7.283" class="difflineminus">-   * @param firstClass Is this a 'first class noun'/can it be a subject, AKA can</span>
<a href="#l7.284"></a><span id="l7.284" class="difflineplus">+   * @param allowsArbitraryAttrs Is this a 'first class noun'/can it be a subject, AKA can</span>
<a href="#l7.285"></a><span id="l7.285">    *     this noun have attributes stored on it that relate it to other things?</span>
<a href="#l7.286"></a><span id="l7.286">    *     For example, a message is first-class; we store attributes of</span>
<a href="#l7.287"></a><span id="l7.287">    *     messages.  A date is not first-class now, nor is it likely to be; we</span>
<a href="#l7.288"></a><span id="l7.288">    *     will not store attributes about a date, although dates will be the</span>
<a href="#l7.289"></a><span id="l7.289">    *     objects of other subjects.  (For example: we might associate a date</span>
<a href="#l7.290"></a><span id="l7.290">    *     with a calendar event, but the date is an attribute of the calendar</span>
<a href="#l7.291"></a><span id="l7.291">    *     event and not vice versa.)</span>
<a href="#l7.292"></a><span id="l7.292">    * @param usesParameter A boolean indicating whether this noun requires use</span>
<a href="#l7.293"></a><span id="l7.293" class="difflineat">@@ -591,30 +643,38 @@ var Gloda = {</span>
<a href="#l7.294"></a><span id="l7.294">     aNounMeta.id = aNounID;</span>
<a href="#l7.295"></a><span id="l7.295">     // if it has a table, you can query on it.  seems straight-forward.</span>
<a href="#l7.296"></a><span id="l7.296">     if (aNounMeta.tableName) {</span>
<a href="#l7.297"></a><span id="l7.297">       [aNounMeta.queryClass, aNounMeta.explicitQueryClass,</span>
<a href="#l7.298"></a><span id="l7.298">        aNounMeta.wildcardQueryClass] =</span>
<a href="#l7.299"></a><span id="l7.299">           GlodaQueryClassFactory(aNounMeta);</span>
<a href="#l7.300"></a><span id="l7.300">       aNounMeta._dbMeta = {};</span>
<a href="#l7.301"></a><span id="l7.301">       aNounMeta.class.prototype.NOUN_META = aNounMeta;</span>
<a href="#l7.302"></a><span id="l7.302" class="difflineplus">+      aNounMeta.toJSON = this._managedToJSON;</span>
<a href="#l7.303"></a><span id="l7.303">     }</span>
<a href="#l7.304"></a><span id="l7.304">     if (aNounMeta.cache) {</span>
<a href="#l7.305"></a><span id="l7.305">       let cacheCost = aNounMeta.cacheCost || 1024;</span>
<a href="#l7.306"></a><span id="l7.306">       let cacheBudget = aNounMeta.cacheBudget || 128 * 1024;</span>
<a href="#l7.307"></a><span id="l7.307">       let cacheSize = Math.floor(cacheBudget / cacheCost);</span>
<a href="#l7.308"></a><span id="l7.308">       if (cacheSize)</span>
<a href="#l7.309"></a><span id="l7.309">         GlodaCollectionManager.defineCache(aNounMeta, cacheSize);</span>
<a href="#l7.310"></a><span id="l7.310">     }</span>
<a href="#l7.311"></a><span id="l7.311" class="difflineplus">+    if (aNounMeta.allowsArbitraryAttrs) {</span>
<a href="#l7.312"></a><span id="l7.312" class="difflineplus">+      aNounMeta.attribsByBoundName = {};</span>
<a href="#l7.313"></a><span id="l7.313" class="difflineplus">+    }</span>
<a href="#l7.314"></a><span id="l7.314">     this._nounNameToNounID[aNounMeta.name] = aNounID;</span>
<a href="#l7.315"></a><span id="l7.315">     this._nounIDToMeta[aNounID] = aNounMeta;</span>
<a href="#l7.316"></a><span id="l7.316">     aNounMeta.actions = [];</span>
<a href="#l7.317"></a><span id="l7.317">     </span>
<a href="#l7.318"></a><span id="l7.318">     this._attrProviderOrderByNoun[aNounMeta.id] = [];</span>
<a href="#l7.319"></a><span id="l7.319">     this._attrProvidersByNoun[aNounMeta.id] = {};</span>
<a href="#l7.320"></a><span id="l7.320" class="difflineplus">+    </span>
<a href="#l7.321"></a><span id="l7.321" class="difflineplus">+    if (aNounMeta.tableName) {</span>
<a href="#l7.322"></a><span id="l7.322" class="difflineplus">+      </span>
<a href="#l7.323"></a><span id="l7.323" class="difflineplus">+    }</span>
<a href="#l7.324"></a><span id="l7.324">   },</span>
<a href="#l7.325"></a><span id="l7.325"> </span>
<a href="#l7.326"></a><span id="l7.326">   /**</span>
<a href="#l7.327"></a><span id="l7.327">    * Lookup a noun (ID) suitable for passing to defineAttribute's various</span>
<a href="#l7.328"></a><span id="l7.328">    *  noun arguments.  Throws an exception if the noun with the given name</span>
<a href="#l7.329"></a><span id="l7.329">    *  cannot be found; the assumption is that you can't live without the noun.</span>
<a href="#l7.330"></a><span id="l7.330">    */</span>
<a href="#l7.331"></a><span id="l7.331">   lookupNoun: function gloda_ns_lookupNoun(aNounName) {</span>
<a href="#l7.332"></a><span id="l7.332" class="difflineat">@@ -701,86 +761,83 @@ var Gloda = {</span>
<a href="#l7.333"></a><span id="l7.333">    *  SQL table def and helper code from datastore.js (and this code) to their</span>
<a href="#l7.334"></a><span id="l7.334">    *  own noun_*.js files.  There are some trade-offs to be made, and I think</span>
<a href="#l7.335"></a><span id="l7.335">    *  we can deal with those once we start to integrate lightning/calendar and</span>
<a href="#l7.336"></a><span id="l7.336">    *  our noun space gets large and more heterogeneous.</span>
<a href="#l7.337"></a><span id="l7.337">    */</span>
<a href="#l7.338"></a><span id="l7.338">   _initAttributes: function gloda_ns_initAttributes() {</span>
<a href="#l7.339"></a><span id="l7.339">     this.defineNoun({</span>
<a href="#l7.340"></a><span id="l7.340">       name: &quot;bool&quot;,</span>
<a href="#l7.341"></a><span id="l7.341" class="difflineminus">-      class: Boolean, firstClass: false,</span>
<a href="#l7.342"></a><span id="l7.342" class="difflineplus">+      class: Boolean, allowsArbitraryAttrs: false,</span>
<a href="#l7.343"></a><span id="l7.343">       fromParamAndValue: function(aParam, aVal) {</span>
<a href="#l7.344"></a><span id="l7.344">         if(aVal != 0) return true; else return false;</span>
<a href="#l7.345"></a><span id="l7.345">       },</span>
<a href="#l7.346"></a><span id="l7.346">       toParamAndValue: function(aBool) {</span>
<a href="#l7.347"></a><span id="l7.347">         return [null, aBool ? 1 : 0];</span>
<a href="#l7.348"></a><span id="l7.348">       }}, this.NOUN_BOOLEAN);</span>
<a href="#l7.349"></a><span id="l7.349">     this.defineNoun({</span>
<a href="#l7.350"></a><span id="l7.350">       name: &quot;number&quot;,</span>
<a href="#l7.351"></a><span id="l7.351" class="difflineminus">-      class: Number, firstClass: false, continuous: true,</span>
<a href="#l7.352"></a><span id="l7.352" class="difflineplus">+      class: Number, allowsArbitraryAttrs: false, continuous: true,</span>
<a href="#l7.353"></a><span id="l7.353">       fromParamAndValue: function(aIgnoredParam, aNum) {</span>
<a href="#l7.354"></a><span id="l7.354">         return aNum;</span>
<a href="#l7.355"></a><span id="l7.355">       },</span>
<a href="#l7.356"></a><span id="l7.356">       toParamAndValue: function(aNum) {</span>
<a href="#l7.357"></a><span id="l7.357">         return [null, aNum];</span>
<a href="#l7.358"></a><span id="l7.358">       }}, this.NOUN_NUMBER);</span>
<a href="#l7.359"></a><span id="l7.359">     this.defineNoun({</span>
<a href="#l7.360"></a><span id="l7.360">       name: &quot;string&quot;,</span>
<a href="#l7.361"></a><span id="l7.361" class="difflineminus">-      class: String, firstClass: false,</span>
<a href="#l7.362"></a><span id="l7.362" class="difflineplus">+      class: String, allowsArbitraryAttrs: false,</span>
<a href="#l7.363"></a><span id="l7.363">       fromParamAndValue: function(aIgnoredParam, aString) {</span>
<a href="#l7.364"></a><span id="l7.364">         return aString;</span>
<a href="#l7.365"></a><span id="l7.365">       },</span>
<a href="#l7.366"></a><span id="l7.366">       toParamAndValue: function(aString) {</span>
<a href="#l7.367"></a><span id="l7.367">         return [null, aString];</span>
<a href="#l7.368"></a><span id="l7.368">       }}, this.NOUN_STRING);</span>
<a href="#l7.369"></a><span id="l7.369">     this.defineNoun({</span>
<a href="#l7.370"></a><span id="l7.370">       name: &quot;date&quot;,</span>
<a href="#l7.371"></a><span id="l7.371" class="difflineminus">-      class: Date, firstClass: false, continuous: true,</span>
<a href="#l7.372"></a><span id="l7.372" class="difflineplus">+      class: Date, allowsArbitraryAttrs: false, continuous: true,</span>
<a href="#l7.373"></a><span id="l7.373">       fromParamAndValue: function(aParam, aPRTime) {</span>
<a href="#l7.374"></a><span id="l7.374">         return new Date(aPRTime / 1000);</span>
<a href="#l7.375"></a><span id="l7.375">       },</span>
<a href="#l7.376"></a><span id="l7.376">       toParamAndValue: function(aDate) {</span>
<a href="#l7.377"></a><span id="l7.377">         return [null, aDate.valueOf() * 1000];</span>
<a href="#l7.378"></a><span id="l7.378">       }}, this.NOUN_DATE);</span>
<a href="#l7.379"></a><span id="l7.379">     this.defineNoun({</span>
<a href="#l7.380"></a><span id="l7.380">       name: &quot;fulltext&quot;,</span>
<a href="#l7.381"></a><span id="l7.381" class="difflineminus">-      class: String, firstClass: false, continuous: false,</span>
<a href="#l7.382"></a><span id="l7.382" class="difflineplus">+      class: String, allowsArbitraryAttrs: false, continuous: false,</span>
<a href="#l7.383"></a><span id="l7.383">       // as noted on NOUN_FULLTEXT, we just pass the string around.  it never</span>
<a href="#l7.384"></a><span id="l7.384">       //  hits the database, so it's okay.</span>
<a href="#l7.385"></a><span id="l7.385">       fromParamAndValue: function(aParam, aString) {</span>
<a href="#l7.386"></a><span id="l7.386">         return aString;</span>
<a href="#l7.387"></a><span id="l7.387">       },</span>
<a href="#l7.388"></a><span id="l7.388">       toParamAndValue: function(aString) {</span>
<a href="#l7.389"></a><span id="l7.389">         return [null, aString];</span>
<a href="#l7.390"></a><span id="l7.390">       }}, this.NOUN_FULLTEXT);</span>
<a href="#l7.391"></a><span id="l7.391"> </span>
<a href="#l7.392"></a><span id="l7.392">     this.defineNoun({</span>
<a href="#l7.393"></a><span id="l7.393">       name: &quot;folder&quot;,</span>
<a href="#l7.394"></a><span id="l7.394">       class: GlodaFolder,</span>
<a href="#l7.395"></a><span id="l7.395" class="difflineminus">-      firstClass: false,</span>
<a href="#l7.396"></a><span id="l7.396" class="difflineplus">+      allowsArbitraryAttrs: false,</span>
<a href="#l7.397"></a><span id="l7.397">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l7.398"></a><span id="l7.398" class="difflineminus">-        // XXX map into folder-space rather than uri-space</span>
<a href="#l7.399"></a><span id="l7.399" class="difflineminus">-        // (this does not pose an immediate problem because folders are</span>
<a href="#l7.400"></a><span id="l7.400" class="difflineminus">-        //  currently special attributes because they are cols on message rows.)</span>
<a href="#l7.401"></a><span id="l7.401">         return GlodaDatastore._mapFolderID(aID);</span>
<a href="#l7.402"></a><span id="l7.402">       },</span>
<a href="#l7.403"></a><span id="l7.403" class="difflineminus">-      toParamAndValue: function(aFolderOrURI) {</span>
<a href="#l7.404"></a><span id="l7.404" class="difflineminus">-        if (aFolderOrURI instanceof GlodaFolder)</span>
<a href="#l7.405"></a><span id="l7.405" class="difflineplus">+      toParamAndValue: function(aFolderOrGlodaFolder) {</span>
<a href="#l7.406"></a><span id="l7.406" class="difflineplus">+        if (aFolderOrGlodaFolder instanceof GlodaFolder)</span>
<a href="#l7.407"></a><span id="l7.407">           return [null, aFolderOrURI.id];</span>
<a href="#l7.408"></a><span id="l7.408">         else</span>
<a href="#l7.409"></a><span id="l7.409" class="difflineminus">-          return [null, GlodaDatastore._mapFolderURI(aFolderOrURI)];</span>
<a href="#l7.410"></a><span id="l7.410" class="difflineplus">+          return [null, GlodaDatastore._mapFolder(aFolderOrGlodaFolder).id];</span>
<a href="#l7.411"></a><span id="l7.411">       }}, this.NOUN_FOLDER);</span>
<a href="#l7.412"></a><span id="l7.412">     // TODO: use some form of (weak) caching layer... it is reasonably likely</span>
<a href="#l7.413"></a><span id="l7.413">     //  that there will be a high degree of correlation in many cases, and</span>
<a href="#l7.414"></a><span id="l7.414">     //  unless the UI is extremely clever and does its cleverness before</span>
<a href="#l7.415"></a><span id="l7.415">     //  examining the data, we will probably hit the correlation.</span>
<a href="#l7.416"></a><span id="l7.416">     this.defineNoun({</span>
<a href="#l7.417"></a><span id="l7.417">       name: &quot;conversation&quot;,</span>
<a href="#l7.418"></a><span id="l7.418">       class: GlodaConversation,</span>
<a href="#l7.419"></a><span id="l7.419" class="difflineminus">-      firstClass: false,</span>
<a href="#l7.420"></a><span id="l7.420" class="difflineplus">+      allowsArbitraryAttrs: false,</span>
<a href="#l7.421"></a><span id="l7.421">       cache: true, cacheCost: 512,</span>
<a href="#l7.422"></a><span id="l7.422">       tableName: &quot;conversations&quot;,</span>
<a href="#l7.423"></a><span id="l7.423">       attrTableName: &quot;messageAttributes&quot;, attrIDColumnName: &quot;conversationID&quot;,</span>
<a href="#l7.424"></a><span id="l7.424">       datastore: GlodaDatastore,</span>
<a href="#l7.425"></a><span id="l7.425">       objFromRow: GlodaDatastore._conversationFromRow,</span>
<a href="#l7.426"></a><span id="l7.426">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l7.427"></a><span id="l7.427">         return GlodaDatastore.getConversationByID(aID);</span>
<a href="#l7.428"></a><span id="l7.428">       },</span>
<a href="#l7.429"></a><span id="l7.429" class="difflineat">@@ -788,52 +845,56 @@ var Gloda = {</span>
<a href="#l7.430"></a><span id="l7.430">         if (aConversation instanceof GlodaConversation)</span>
<a href="#l7.431"></a><span id="l7.431">           return [null, aConversation.id];</span>
<a href="#l7.432"></a><span id="l7.432">         else // assume they're just passing the id directly</span>
<a href="#l7.433"></a><span id="l7.433">           return [null, aConversation];</span>
<a href="#l7.434"></a><span id="l7.434">       }}, this.NOUN_CONVERSATION);</span>
<a href="#l7.435"></a><span id="l7.435">     this.defineNoun({</span>
<a href="#l7.436"></a><span id="l7.436">       name: &quot;message&quot;,</span>
<a href="#l7.437"></a><span id="l7.437">       class: GlodaMessage,</span>
<a href="#l7.438"></a><span id="l7.438" class="difflineminus">-      firstClass: true,</span>
<a href="#l7.439"></a><span id="l7.439" class="difflineplus">+      allowsArbitraryAttrs: true,</span>
<a href="#l7.440"></a><span id="l7.440">       cache: true, cacheCost: 2048,</span>
<a href="#l7.441"></a><span id="l7.441">       tableName: &quot;messages&quot;,</span>
<a href="#l7.442"></a><span id="l7.442">       attrTableName: &quot;messageAttributes&quot;, attrIDColumnName: &quot;messageID&quot;,</span>
<a href="#l7.443"></a><span id="l7.443">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._messageFromRow,</span>
<a href="#l7.444"></a><span id="l7.444" class="difflineplus">+      dbAttribAdjuster: GlodaDatastore.adjustMessageAttributes,</span>
<a href="#l7.445"></a><span id="l7.445" class="difflineplus">+      objInsert: GlodaDatastore.insertMessage,</span>
<a href="#l7.446"></a><span id="l7.446" class="difflineplus">+      objUpdate: GlodaDatastore.updateMessage,</span>
<a href="#l7.447"></a><span id="l7.447">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l7.448"></a><span id="l7.448">         return GlodaDatastore.getMessageByID(aID);</span>
<a href="#l7.449"></a><span id="l7.449">       },</span>
<a href="#l7.450"></a><span id="l7.450">       toParamAndValue: function(aMessage) {</span>
<a href="#l7.451"></a><span id="l7.451">         if (aMessage instanceof GlodaMessage)</span>
<a href="#l7.452"></a><span id="l7.452">           return [null, aMessage.id];</span>
<a href="#l7.453"></a><span id="l7.453">         else // assume they're just passing the id directly</span>
<a href="#l7.454"></a><span id="l7.454">           return [null, aMessage];</span>
<a href="#l7.455"></a><span id="l7.455">       }}, this.NOUN_MESSAGE);</span>
<a href="#l7.456"></a><span id="l7.456">     this.defineNoun({</span>
<a href="#l7.457"></a><span id="l7.457">       name: &quot;contact&quot;,</span>
<a href="#l7.458"></a><span id="l7.458">       class: GlodaContact,</span>
<a href="#l7.459"></a><span id="l7.459" class="difflineminus">-      firstClass: true,</span>
<a href="#l7.460"></a><span id="l7.460" class="difflineplus">+      allowsArbitraryAttrs: true,</span>
<a href="#l7.461"></a><span id="l7.461">       cache: true, cacheCost: 128,</span>
<a href="#l7.462"></a><span id="l7.462">       tableName: &quot;contacts&quot;,</span>
<a href="#l7.463"></a><span id="l7.463">       attrTableName: &quot;contactAttributes&quot;, attrIDColumnName: &quot;contactID&quot;,</span>
<a href="#l7.464"></a><span id="l7.464">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._contactFromRow,</span>
<a href="#l7.465"></a><span id="l7.465" class="difflineplus">+      objInsert: GlodaDatastore.insertContact,</span>
<a href="#l7.466"></a><span id="l7.466">       objUpdate: GlodaDatastore.updateContact,</span>
<a href="#l7.467"></a><span id="l7.467">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l7.468"></a><span id="l7.468">         return GlodaDatastore.getContactByID(aID);</span>
<a href="#l7.469"></a><span id="l7.469">       },</span>
<a href="#l7.470"></a><span id="l7.470">       toParamAndValue: function(aContact) {</span>
<a href="#l7.471"></a><span id="l7.471">         if (aContact instanceof GlodaContact)</span>
<a href="#l7.472"></a><span id="l7.472">           return [null, aContact.id];</span>
<a href="#l7.473"></a><span id="l7.473">         else // assume they're just passing the id directly</span>
<a href="#l7.474"></a><span id="l7.474">           return [null, aContact];</span>
<a href="#l7.475"></a><span id="l7.475">       }}, this.NOUN_CONTACT);</span>
<a href="#l7.476"></a><span id="l7.476">     this.defineNoun({</span>
<a href="#l7.477"></a><span id="l7.477">       name: &quot;identity&quot;,</span>
<a href="#l7.478"></a><span id="l7.478">       class: GlodaIdentity,</span>
<a href="#l7.479"></a><span id="l7.479" class="difflineminus">-      firstClass: false,</span>
<a href="#l7.480"></a><span id="l7.480" class="difflineplus">+      allowsArbitraryAttrs: false,</span>
<a href="#l7.481"></a><span id="l7.481">       cache: true, cacheCost: 128,</span>
<a href="#l7.482"></a><span id="l7.482">       usesUniqueValue: true,</span>
<a href="#l7.483"></a><span id="l7.483">       tableName: &quot;identities&quot;,</span>
<a href="#l7.484"></a><span id="l7.484">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._identityFromRow,</span>
<a href="#l7.485"></a><span id="l7.485">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l7.486"></a><span id="l7.486">         return GlodaDatastore.getIdentityByID(aID);</span>
<a href="#l7.487"></a><span id="l7.487">       },</span>
<a href="#l7.488"></a><span id="l7.488">       toParamAndValue: function(aIdentity) {</span>
<a href="#l7.489"></a><span id="l7.489" class="difflineat">@@ -845,45 +906,63 @@ var Gloda = {</span>
<a href="#l7.490"></a><span id="l7.490"> </span>
<a href="#l7.491"></a><span id="l7.491">     // parameterized identity is just two identities; we store the first one</span>
<a href="#l7.492"></a><span id="l7.492">     //  (whose value set must be very constrainted, like the 'me' identities)</span>
<a href="#l7.493"></a><span id="l7.493">     //  as the parameter, the second (which does not need to be constrained)</span>
<a href="#l7.494"></a><span id="l7.494">     //  as the value.</span>
<a href="#l7.495"></a><span id="l7.495">     this.defineNoun({</span>
<a href="#l7.496"></a><span id="l7.496">       name: &quot;parameterized-identity&quot;,</span>
<a href="#l7.497"></a><span id="l7.497">       class: null,</span>
<a href="#l7.498"></a><span id="l7.498" class="difflineminus">-      firstClass: false,</span>
<a href="#l7.499"></a><span id="l7.499" class="difflineplus">+      allowsArbitraryAttrs: false,</span>
<a href="#l7.500"></a><span id="l7.500" class="difflineplus">+      computeDelta: function(aCurValues, aOldValues) {</span>
<a href="#l7.501"></a><span id="l7.501" class="difflineplus">+        let oldMap = {};</span>
<a href="#l7.502"></a><span id="l7.502" class="difflineplus">+        for each (let [, tupe] in Iterator(aOldValues)) {</span>
<a href="#l7.503"></a><span id="l7.503" class="difflineplus">+          let [originIdentity, </span>
<a href="#l7.504"></a><span id="l7.504" class="difflineplus">+        }</span>
<a href="#l7.505"></a><span id="l7.505" class="difflineplus">+      },</span>
<a href="#l7.506"></a><span id="l7.506" class="difflineplus">+      contributeObjDependencies: function(aJsonValues, aReferencesByNounID) {</span>
<a href="#l7.507"></a><span id="l7.507" class="difflineplus">+        // nothing to do with a zero-length list</span>
<a href="#l7.508"></a><span id="l7.508" class="difflineplus">+        if (aJsonValues.length == 0)</span>
<a href="#l7.509"></a><span id="l7.509" class="difflineplus">+          return false;</span>
<a href="#l7.510"></a><span id="l7.510" class="difflineplus">+      </span>
<a href="#l7.511"></a><span id="l7.511" class="difflineplus">+        let references = aReferencesByNounID[this.NOUN_IDENTITY];</span>
<a href="#l7.512"></a><span id="l7.512" class="difflineplus">+        if (references === undefined)</span>
<a href="#l7.513"></a><span id="l7.513" class="difflineplus">+          references = aReferencesByNounID[this.NOUN_IDENTITY] = {};</span>
<a href="#l7.514"></a><span id="l7.514" class="difflineplus">+        </span>
<a href="#l7.515"></a><span id="l7.515" class="difflineplus">+        for each (let [, tupe] in Iterator(aJsonValues)) {</span>
<a href="#l7.516"></a><span id="l7.516" class="difflineplus">+          let [originIdentityID, targetIdentityID] = tupe;</span>
<a href="#l7.517"></a><span id="l7.517" class="difflineplus">+          references[originIdentityID] = null;</span>
<a href="#l7.518"></a><span id="l7.518" class="difflineplus">+          references[targetIdentityID] = null;</span>
<a href="#l7.519"></a><span id="l7.519" class="difflineplus">+        }</span>
<a href="#l7.520"></a><span id="l7.520" class="difflineplus">+        </span>
<a href="#l7.521"></a><span id="l7.521" class="difflineplus">+        return true;</span>
<a href="#l7.522"></a><span id="l7.522" class="difflineplus">+      },</span>
<a href="#l7.523"></a><span id="l7.523" class="difflineplus">+      resolveObjDependencies: function(aJsonValues, aReferencesByNounID) {</span>
<a href="#l7.524"></a><span id="l7.524" class="difflineplus">+        let references = aReferencesByNounID[this.NOUN_IDENTITY];</span>
<a href="#l7.525"></a><span id="l7.525" class="difflineplus">+        if (references === undefined)</span>
<a href="#l7.526"></a><span id="l7.526" class="difflineplus">+          references = aReferencesByNounID[this.NOUN_IDENTITY] = {};</span>
<a href="#l7.527"></a><span id="l7.527" class="difflineplus">+        </span>
<a href="#l7.528"></a><span id="l7.528" class="difflineplus">+        let results = [];</span>
<a href="#l7.529"></a><span id="l7.529" class="difflineplus">+        for each (let [, tupe] in Iterator(aJsonValues)) {</span>
<a href="#l7.530"></a><span id="l7.530" class="difflineplus">+          let [originIdentityID, targetIdentityID] = tupe;</span>
<a href="#l7.531"></a><span id="l7.531" class="difflineplus">+          results.push([references[originIdentityID],</span>
<a href="#l7.532"></a><span id="l7.532" class="difflineplus">+                        references[targetIdentityID]]);</span>
<a href="#l7.533"></a><span id="l7.533" class="difflineplus">+        }</span>
<a href="#l7.534"></a><span id="l7.534" class="difflineplus">+        </span>
<a href="#l7.535"></a><span id="l7.535" class="difflineplus">+        return results;</span>
<a href="#l7.536"></a><span id="l7.536" class="difflineplus">+      },</span>
<a href="#l7.537"></a><span id="l7.537">       fromParamAndValue: function(aParamIdentityID, aValueIdentityID) {</span>
<a href="#l7.538"></a><span id="l7.538">         return [GlodaDatastore.getIdentityByID(aParamIdentityID),</span>
<a href="#l7.539"></a><span id="l7.539">                 GlodaDatastore.getIdentityByID(aValueIdentityID)];</span>
<a href="#l7.540"></a><span id="l7.540">       },</span>
<a href="#l7.541"></a><span id="l7.541">       toParamAndValue: function(aIdentityTuple) {</span>
<a href="#l7.542"></a><span id="l7.542" class="difflineminus">-        if (typeof aIdentityTuple == &quot;number&quot;)</span>
<a href="#l7.543"></a><span id="l7.543" class="difflineminus">-          return aIdentityTuple;</span>
<a href="#l7.544"></a><span id="l7.544">         return [aIdentityTuple[0].id, aIdentityTuple[1].id];</span>
<a href="#l7.545"></a><span id="l7.545">       }}, this.NOUN_PARAM_IDENTITY);</span>
<a href="#l7.546"></a><span id="l7.546"> </span>
<a href="#l7.547"></a><span id="l7.547">     GlodaDatastore.getAllAttributes();</span>
<a href="#l7.548"></a><span id="l7.548" class="difflineminus">-</span>
<a href="#l7.549"></a><span id="l7.549" class="difflineminus">-    /* boolean actions, these are parameterized by the attribute they operate</span>
<a href="#l7.550"></a><span id="l7.550" class="difflineminus">-       in the context of.  They are also (not coincidentally), ugly. */</span>
<a href="#l7.551"></a><span id="l7.551" class="difflineminus">-    Gloda.defineNounAction(Gloda.NOUN_BOOLEAN, {actionType: &quot;filter&quot;,</span>
<a href="#l7.552"></a><span id="l7.552" class="difflineminus">-      actionTarget: Gloda.NOUN_MESSAGE,</span>
<a href="#l7.553"></a><span id="l7.553" class="difflineminus">-      shortName: &quot;true&quot;,</span>
<a href="#l7.554"></a><span id="l7.554" class="difflineminus">-      makeConstraint: function(aAttrDef, aIdentity) {</span>
<a href="#l7.555"></a><span id="l7.555" class="difflineminus">-        return [aAttrDef, null, 1];</span>
<a href="#l7.556"></a><span id="l7.556" class="difflineminus">-      },</span>
<a href="#l7.557"></a><span id="l7.557" class="difflineminus">-      });</span>
<a href="#l7.558"></a><span id="l7.558" class="difflineminus">-    Gloda.defineNounAction(Gloda.NOUN_BOOLEAN, {actionType: &quot;filter&quot;,</span>
<a href="#l7.559"></a><span id="l7.559" class="difflineminus">-      actionTarget: Gloda.NOUN_MESSAGE,</span>
<a href="#l7.560"></a><span id="l7.560" class="difflineminus">-      shortName: &quot;false&quot;,</span>
<a href="#l7.561"></a><span id="l7.561" class="difflineminus">-      makeConstraint: function(aAttrDef, aIdentity) {</span>
<a href="#l7.562"></a><span id="l7.562" class="difflineminus">-        return [aAttrDef, null, 0];</span>
<a href="#l7.563"></a><span id="l7.563" class="difflineminus">-      },</span>
<a href="#l7.564"></a><span id="l7.564" class="difflineminus">-      });</span>
<a href="#l7.565"></a><span id="l7.565">   },</span>
<a href="#l7.566"></a><span id="l7.566"> </span>
<a href="#l7.567"></a><span id="l7.567">   /**</span>
<a href="#l7.568"></a><span id="l7.568">    * Create accessor functions to 'bind' an attribute to underlying normalized</span>
<a href="#l7.569"></a><span id="l7.569">    *  attribute storage, as well as creating the appropriate query object</span>
<a href="#l7.570"></a><span id="l7.570">    *  constraint helper functions.  This name is somewhat of a misnomer because</span>
<a href="#l7.571"></a><span id="l7.571">    *  special attributes are not 'bound' (because specific/non-generic per-class</span>
<a href="#l7.572"></a><span id="l7.572">    *  code provides the properties) but still depend on this method to</span>
<a href="#l7.573"></a><span id="l7.573" class="difflineat">@@ -891,67 +970,21 @@ var Gloda = {</span>
<a href="#l7.574"></a><span id="l7.574">    *</span>
<a href="#l7.575"></a><span id="l7.575">    * @XXX potentially rename to not suggest binding is required.</span>
<a href="#l7.576"></a><span id="l7.576">    */</span>
<a href="#l7.577"></a><span id="l7.577">   _bindAttribute: function gloda_ns_bindAttr(aAttr, aSubjectType, aObjectType,</span>
<a href="#l7.578"></a><span id="l7.578">                                              aSingular, aDoBind, aBindName) {</span>
<a href="#l7.579"></a><span id="l7.579">     if (!(aSubjectType in this._nounIDToMeta))</span>
<a href="#l7.580"></a><span id="l7.580">       throw Error(&quot;Invalid subject type: &quot; + aSubjectType);</span>
<a href="#l7.581"></a><span id="l7.581"> </span>
<a href="#l7.582"></a><span id="l7.582" class="difflineminus">-    let nounMeta = this._nounIDToMeta[aObjectType];</span>
<a href="#l7.583"></a><span id="l7.583" class="difflineplus">+    let objNounMeta = this._nounIDToMeta[aObjectType];</span>
<a href="#l7.584"></a><span id="l7.584">     let subjectNounMeta = this._nounIDToMeta[aSubjectType];</span>
<a href="#l7.585"></a><span id="l7.585"> </span>
<a href="#l7.586"></a><span id="l7.586">     // -- the on-object bindings</span>
<a href="#l7.587"></a><span id="l7.587">     if (aDoBind) {</span>
<a href="#l7.588"></a><span id="l7.588" class="difflineminus">-      let storageName = &quot;__&quot; + aBindName;</span>
<a href="#l7.589"></a><span id="l7.589" class="difflineminus">-      let getter;</span>
<a href="#l7.590"></a><span id="l7.590" class="difflineminus">-      // should we memoize the value as a getter per-instance?</span>
<a href="#l7.591"></a><span id="l7.591" class="difflineminus">-      if (aSingular) {</span>
<a href="#l7.592"></a><span id="l7.592" class="difflineminus">-        getter = function() {</span>
<a href="#l7.593"></a><span id="l7.593" class="difflineminus">-          let val = this[storageName];</span>
<a href="#l7.594"></a><span id="l7.594" class="difflineminus">-          if (val !== undefined)</span>
<a href="#l7.595"></a><span id="l7.595" class="difflineminus">-            return val;</span>
<a href="#l7.596"></a><span id="l7.596" class="difflineminus">-          let instances = this.getAttributeInstances(aAttr);</span>
<a href="#l7.597"></a><span id="l7.597" class="difflineminus">-          if (instances.length &gt; 0)</span>
<a href="#l7.598"></a><span id="l7.598" class="difflineminus">-            val = nounMeta.fromParamAndValue(instances[0][1], instances[0][2]);</span>
<a href="#l7.599"></a><span id="l7.599" class="difflineminus">-          else</span>
<a href="#l7.600"></a><span id="l7.600" class="difflineminus">-            val = null;</span>
<a href="#l7.601"></a><span id="l7.601" class="difflineminus">-          //this[storageName] = val;</span>
<a href="#l7.602"></a><span id="l7.602" class="difflineminus">-          this.__defineGetter__(aBindName, function() val);</span>
<a href="#l7.603"></a><span id="l7.603" class="difflineminus">-          return val;</span>
<a href="#l7.604"></a><span id="l7.604" class="difflineminus">-        }</span>
<a href="#l7.605"></a><span id="l7.605" class="difflineminus">-      } else {</span>
<a href="#l7.606"></a><span id="l7.606" class="difflineminus">-        getter = function() {</span>
<a href="#l7.607"></a><span id="l7.607" class="difflineminus">-          let values = this[storageName];</span>
<a href="#l7.608"></a><span id="l7.608" class="difflineminus">-          if (values !== undefined)</span>
<a href="#l7.609"></a><span id="l7.609" class="difflineminus">-            return values;</span>
<a href="#l7.610"></a><span id="l7.610" class="difflineminus">-          let instances = this.getAttributeInstances(aAttr);</span>
<a href="#l7.611"></a><span id="l7.611" class="difflineminus">-          if (instances.length &gt; 0) {</span>
<a href="#l7.612"></a><span id="l7.612" class="difflineminus">-            values = [];</span>
<a href="#l7.613"></a><span id="l7.613" class="difflineminus">-            for (let iInst = 0; iInst &lt; instances.length; iInst++) {</span>
<a href="#l7.614"></a><span id="l7.614" class="difflineminus">-              values.push(nounMeta.fromParamAndValue(instances[iInst][1],</span>
<a href="#l7.615"></a><span id="l7.615" class="difflineminus">-                                                     instances[iInst][2]));</span>
<a href="#l7.616"></a><span id="l7.616" class="difflineminus">-            }</span>
<a href="#l7.617"></a><span id="l7.617" class="difflineminus">-          }</span>
<a href="#l7.618"></a><span id="l7.618" class="difflineminus">-          else {</span>
<a href="#l7.619"></a><span id="l7.619" class="difflineminus">-            values = instances; // empty is empty</span>
<a href="#l7.620"></a><span id="l7.620" class="difflineminus">-          }</span>
<a href="#l7.621"></a><span id="l7.621" class="difflineminus">-          //this[storageName] = values;</span>
<a href="#l7.622"></a><span id="l7.622" class="difflineminus">-          this.__defineGetter__(aBindName, function() values);</span>
<a href="#l7.623"></a><span id="l7.623" class="difflineminus">-          return values;</span>
<a href="#l7.624"></a><span id="l7.624" class="difflineminus">-        }</span>
<a href="#l7.625"></a><span id="l7.625" class="difflineminus">-      }</span>
<a href="#l7.626"></a><span id="l7.626" class="difflineminus">-</span>
<a href="#l7.627"></a><span id="l7.627" class="difflineminus">-      let subjectProto = subjectNounMeta.class.prototype;</span>
<a href="#l7.628"></a><span id="l7.628" class="difflineminus">-      subjectProto.__defineGetter__(aBindName, getter);</span>
<a href="#l7.629"></a><span id="l7.629" class="difflineminus">-      // no setters for now; manipulation comes later, and will require the attr</span>
<a href="#l7.630"></a><span id="l7.630" class="difflineminus">-      //  definer to provide the actual logic, since we need to affect reality,</span>
<a href="#l7.631"></a><span id="l7.631" class="difflineminus">-      //  not just the data-store.  we may also just punt that all off onto</span>
<a href="#l7.632"></a><span id="l7.632" class="difflineminus">-      //  STEEL...</span>
<a href="#l7.633"></a><span id="l7.633" class="difflineminus">-</span>
<a href="#l7.634"></a><span id="l7.634">       aAttr.boundName = aBindName;</span>
<a href="#l7.635"></a><span id="l7.635">     }</span>
<a href="#l7.636"></a><span id="l7.636"> </span>
<a href="#l7.637"></a><span id="l7.637">     // -- the query constraint helpers</span>
<a href="#l7.638"></a><span id="l7.638">     if (subjectNounMeta.queryClass !== undefined) {</span>
<a href="#l7.639"></a><span id="l7.639">       let constrainer = function() {</span>
<a href="#l7.640"></a><span id="l7.640">         // all the arguments provided end up being ORed together</span>
<a href="#l7.641"></a><span id="l7.641">         let our_ors = [];</span>
<a href="#l7.642"></a><span id="l7.642" class="difflineat">@@ -1106,34 +1139,33 @@ var Gloda = {</span>
<a href="#l7.643"></a><span id="l7.643"> </span>
<a href="#l7.644"></a><span id="l7.644">         // update the provider maps...</span>
<a href="#l7.645"></a><span id="l7.645">         if (this._attrProviderOrderByNoun[subjectType]</span>
<a href="#l7.646"></a><span id="l7.646">                 .indexOf(aAttrDef.provider) == -1) {</span>
<a href="#l7.647"></a><span id="l7.647">           this._attrProviderOrderByNoun[subjectType].push(aAttrDef.provider);</span>
<a href="#l7.648"></a><span id="l7.648">           this._attrProvidersByNoun[subjectType][aAttrDef.provider] = [];</span>
<a href="#l7.649"></a><span id="l7.649">         }</span>
<a href="#l7.650"></a><span id="l7.650">         this._attrProvidersByNoun[subjectType][aAttrDef.provider].push(aAttrDef);</span>
<a href="#l7.651"></a><span id="l7.651" class="difflineplus">+        </span>
<a href="#l7.652"></a><span id="l7.652" class="difflineplus">+        let subjectNounDef = this._nounIDToMeta[subjectType];</span>
<a href="#l7.653"></a><span id="l7.653" class="difflineplus">+        subjectNounDef.attribsByBoundName[bindName] = attr;</span>
<a href="#l7.654"></a><span id="l7.654" class="difflineplus">+        </span>
<a href="#l7.655"></a><span id="l7.655">       }</span>
<a href="#l7.656"></a><span id="l7.656"> </span>
<a href="#l7.657"></a><span id="l7.657">       this._attrProviders[aAttrDef.provider.providerName].push(attr);</span>
<a href="#l7.658"></a><span id="l7.658">       return attr;</span>
<a href="#l7.659"></a><span id="l7.659">     }</span>
<a href="#l7.660"></a><span id="l7.660"> </span>
<a href="#l7.661"></a><span id="l7.661">     let objectNounMeta = this._nounIDToMeta[aAttrDef.objectNoun];</span>
<a href="#l7.662"></a><span id="l7.662"> </span>
<a href="#l7.663"></a><span id="l7.663" class="difflineminus">-    // Being here means the attribute def does not exist in the database.</span>
<a href="#l7.664"></a><span id="l7.664" class="difflineminus">-    // Of course, we only want to create something in the database if the</span>
<a href="#l7.665"></a><span id="l7.665" class="difflineminus">-    //  parameter is forever un-used (noun does not 'usesParameter')</span>
<a href="#l7.666"></a><span id="l7.666">     let attrID = null;</span>
<a href="#l7.667"></a><span id="l7.667" class="difflineminus">-    if (!objectNounMeta.usesParameter) {</span>
<a href="#l7.668"></a><span id="l7.668" class="difflineminus">-      attrID = GlodaDatastore._createAttributeDef(aAttrDef.attributeType,</span>
<a href="#l7.669"></a><span id="l7.669" class="difflineminus">-                                                  aAttrDef.extensionName,</span>
<a href="#l7.670"></a><span id="l7.670" class="difflineminus">-                                                  aAttrDef.attributeName,</span>
<a href="#l7.671"></a><span id="l7.671" class="difflineminus">-                                                  null);</span>
<a href="#l7.672"></a><span id="l7.672" class="difflineminus">-    }</span>
<a href="#l7.673"></a><span id="l7.673" class="difflineplus">+    attrID = GlodaDatastore._createAttributeDef(aAttrDef.attributeType,</span>
<a href="#l7.674"></a><span id="l7.674" class="difflineplus">+                                                aAttrDef.extensionName,</span>
<a href="#l7.675"></a><span id="l7.675" class="difflineplus">+                                                aAttrDef.attributeName,</span>
<a href="#l7.676"></a><span id="l7.676" class="difflineplus">+                                                null);</span>
<a href="#l7.677"></a><span id="l7.677"> </span>
<a href="#l7.678"></a><span id="l7.678">     attr = new GlodaAttributeDef(GlodaDatastore, attrID, compoundName,</span>
<a href="#l7.679"></a><span id="l7.679">                                  aAttrDef.provider, aAttrDef.attributeType,</span>
<a href="#l7.680"></a><span id="l7.680">                                  aAttrDef.extensionName, aAttrDef.attributeName,</span>
<a href="#l7.681"></a><span id="l7.681">                                  aAttrDef.subjectNouns, aAttrDef.objectNoun);</span>
<a href="#l7.682"></a><span id="l7.682">     // things here match the HATHATHAT clause above.  clearly, this should also</span>
<a href="#l7.683"></a><span id="l7.683">     //  be resolved more satisfactorily.</span>
<a href="#l7.684"></a><span id="l7.684">     attr._special = aAttrDef.special || this.kSpecialNotAtAll;</span>
<a href="#l7.685"></a><span id="l7.685" class="difflineat">@@ -1144,18 +1176,17 @@ var Gloda = {</span>
<a href="#l7.686"></a><span id="l7.686">     for (let iSubject = 0; iSubject &lt; aAttrDef.subjectNouns.length;</span>
<a href="#l7.687"></a><span id="l7.687">          iSubject++) {</span>
<a href="#l7.688"></a><span id="l7.688">       let subjectType = aAttrDef.subjectNouns[iSubject];</span>
<a href="#l7.689"></a><span id="l7.689">       this._bindAttribute(attr, subjectType, aAttrDef.objectNoun,</span>
<a href="#l7.690"></a><span id="l7.690">                           aAttrDef.singular, aAttrDef.bind, bindName);</span>
<a href="#l7.691"></a><span id="l7.691">     }</span>
<a href="#l7.692"></a><span id="l7.692"> </span>
<a href="#l7.693"></a><span id="l7.693">     this._attrProviders[aAttrDef.provider.providerName].push(attr);</span>
<a href="#l7.694"></a><span id="l7.694" class="difflineminus">-    if (!objectNounMeta.usesParameter)</span>
<a href="#l7.695"></a><span id="l7.695" class="difflineminus">-      GlodaDatastore._attributeIDToDef[attrID] = [attr, null];</span>
<a href="#l7.696"></a><span id="l7.696" class="difflineplus">+    GlodaDatastore._attributeIDToDef[attrID] = [attr, null];</span>
<a href="#l7.697"></a><span id="l7.697">     return attr;</span>
<a href="#l7.698"></a><span id="l7.698">   },</span>
<a href="#l7.699"></a><span id="l7.699"> </span>
<a href="#l7.700"></a><span id="l7.700">   /**</span>
<a href="#l7.701"></a><span id="l7.701">    * Retrieve the attribute provided by the given extension with the given</span>
<a href="#l7.702"></a><span id="l7.702">    *  attribute name.  The original idea was that plugins would effectively</span>
<a href="#l7.703"></a><span id="l7.703">    *  name-space attributes, helping avoid collisions.  Since we are leaning</span>
<a href="#l7.704"></a><span id="l7.704">    *  towards using binding heavily, this doesn't really help, as the collisions</span>
<a href="#l7.705"></a><span id="l7.705" class="difflineat">@@ -1337,16 +1368,170 @@ var Gloda = {</span>
<a href="#l7.706"></a><span id="l7.706">     GlodaDatastore.insertMessageAttributes(aMessage, outAttribs);</span>
<a href="#l7.707"></a><span id="l7.707">     aMessage._replaceAttributes(memAttribs);</span>
<a href="#l7.708"></a><span id="l7.708"> </span>
<a href="#l7.709"></a><span id="l7.709">     if (aIsNew)</span>
<a href="#l7.710"></a><span id="l7.710">       GlodaCollectionManager.itemsAdded(aMessage.NOUN_ID, [aMessage]);</span>
<a href="#l7.711"></a><span id="l7.711">     else</span>
<a href="#l7.712"></a><span id="l7.712">       GlodaCollectionManager.itemsModified(aMessage.NOUN_ID, [aMessage]);</span>
<a href="#l7.713"></a><span id="l7.713">   },</span>
<a href="#l7.714"></a><span id="l7.714" class="difflineplus">+  </span>
<a href="#l7.715"></a><span id="l7.715" class="difflineplus">+  /**</span>
<a href="#l7.716"></a><span id="l7.716" class="difflineplus">+   * Populate a gloda representation of an item given the thus-far built</span>
<a href="#l7.717"></a><span id="l7.717" class="difflineplus">+   *  representation, the previous representation, and one or more raw</span>
<a href="#l7.718"></a><span id="l7.718" class="difflineplus">+   *  representations.</span>
<a href="#l7.719"></a><span id="l7.719" class="difflineplus">+   *</span>
<a href="#l7.720"></a><span id="l7.720" class="difflineplus">+   * The result of the processing ends up with attributes in 3 different forms:</span>
<a href="#l7.721"></a><span id="l7.721" class="difflineplus">+   * - Database attribute rows (to be added and removed).</span>
<a href="#l7.722"></a><span id="l7.722" class="difflineplus">+   * - In-memory representation.</span>
<a href="#l7.723"></a><span id="l7.723" class="difflineplus">+   * - JSON-able representation.</span>
<a href="#l7.724"></a><span id="l7.724" class="difflineplus">+   */</span>
<a href="#l7.725"></a><span id="l7.725" class="difflineplus">+  grokNounItem: function gloda_ns_grokNounItem(aItem, aRawReps, aIsNew,</span>
<a href="#l7.726"></a><span id="l7.726" class="difflineplus">+      aCallbackHandle) {</span>
<a href="#l7.727"></a><span id="l7.727" class="difflineplus">+    let itemNounDef = this._nounIDToMeta[aItem.NOUN_ID];</span>
<a href="#l7.728"></a><span id="l7.728" class="difflineplus">+    let attribsByBoundName = itemNounDef.attribsByBoundName;</span>
<a href="#l7.729"></a><span id="l7.729" class="difflineplus">+    </span>
<a href="#l7.730"></a><span id="l7.730" class="difflineplus">+    let addDBAttribs = [];</span>
<a href="#l7.731"></a><span id="l7.731" class="difflineplus">+    let removeDBAttribs = [];</span>
<a href="#l7.732"></a><span id="l7.732" class="difflineplus">+    </span>
<a href="#l7.733"></a><span id="l7.733" class="difflineplus">+    let jsonDict = {};</span>
<a href="#l7.734"></a><span id="l7.734" class="difflineplus">+    </span>
<a href="#l7.735"></a><span id="l7.735" class="difflineplus">+    let aOldItem = aItem;</span>
<a href="#l7.736"></a><span id="l7.736" class="difflineplus">+    // we want to create a clone of the existing item so that we can know the</span>
<a href="#l7.737"></a><span id="l7.737" class="difflineplus">+    //  deltas that happened for indexing purposes</span>
<a href="#l7.738"></a><span id="l7.738" class="difflineplus">+    aItem = aItem._clone();</span>
<a href="#l7.739"></a><span id="l7.739" class="difflineplus">+  </span>
<a href="#l7.740"></a><span id="l7.740" class="difflineplus">+    // Have the attribute providers directly set properties on the aItem</span>
<a href="#l7.741"></a><span id="l7.741" class="difflineplus">+    let attrProviders = this._attrProviderOrderByNoun[aItem.NOUN_ID];</span>
<a href="#l7.742"></a><span id="l7.742" class="difflineplus">+    for (let iProvider = 0; iProvider &lt; attrProviders.length; iProvider++) {</span>
<a href="#l7.743"></a><span id="l7.743" class="difflineplus">+      yield aCallbackHandle.pushAndGo(</span>
<a href="#l7.744"></a><span id="l7.744" class="difflineplus">+        attrProviders[iProvider].process(aItem, aRawItem, aIsNew,</span>
<a href="#l7.745"></a><span id="l7.745" class="difflineplus">+                                         aCallbackHandle));</span>
<a href="#l7.746"></a><span id="l7.746" class="difflineplus">+    }</span>
<a href="#l7.747"></a><span id="l7.747" class="difflineplus">+  </span>
<a href="#l7.748"></a><span id="l7.748" class="difflineplus">+    // Iterate over the attributes on the item</span>
<a href="#l7.749"></a><span id="l7.749" class="difflineplus">+    for each (let [key, value] in Iterator(aItem)) {</span>
<a href="#l7.750"></a><span id="l7.750" class="difflineplus">+      // ignore keys that start with underscores, they are private and not</span>
<a href="#l7.751"></a><span id="l7.751" class="difflineplus">+      //  persisted by our attribute mechanism.  (they are directly handled by</span>
<a href="#l7.752"></a><span id="l7.752" class="difflineplus">+      //  the object implementation.)</span>
<a href="#l7.753"></a><span id="l7.753" class="difflineplus">+      if (key[0] == &quot;_&quot;)</span>
<a href="#l7.754"></a><span id="l7.754" class="difflineplus">+        continue;</span>
<a href="#l7.755"></a><span id="l7.755" class="difflineplus">+      // find the attribute definition that corresponds to this key</span>
<a href="#l7.756"></a><span id="l7.756" class="difflineplus">+      let attrib = attribsByBoundName[key];</span>
<a href="#l7.757"></a><span id="l7.757" class="difflineplus">+      // if there's no attribute, that's not good, but not horrible.</span>
<a href="#l7.758"></a><span id="l7.758" class="difflineplus">+      if (attrib === undefined)</span>
<a href="#l7.759"></a><span id="l7.759" class="difflineplus">+        continue;</span>
<a href="#l7.760"></a><span id="l7.760" class="difflineplus">+      </span>
<a href="#l7.761"></a><span id="l7.761" class="difflineplus">+      let objNounDef = attrib.objectNounDef;</span>
<a href="#l7.762"></a><span id="l7.762" class="difflineplus">+      </span>
<a href="#l7.763"></a><span id="l7.763" class="difflineplus">+      // - translate for our JSON rep</span>
<a href="#l7.764"></a><span id="l7.764" class="difflineplus">+      if (attrib.singular) {</span>
<a href="#l7.765"></a><span id="l7.765" class="difflineplus">+        if (obnNounDef.toJSON)</span>
<a href="#l7.766"></a><span id="l7.766" class="difflineplus">+          jsonDict[attrib.id] = objNounDef.toJSON(value);</span>
<a href="#l7.767"></a><span id="l7.767" class="difflineplus">+        else</span>
<a href="#l7.768"></a><span id="l7.768" class="difflineplus">+          jsonDict[attrib.id] = value; </span>
<a href="#l7.769"></a><span id="l7.769" class="difflineplus">+      }</span>
<a href="#l7.770"></a><span id="l7.770" class="difflineplus">+      else {</span>
<a href="#l7.771"></a><span id="l7.771" class="difflineplus">+        if (objNounDef.toJSON) {</span>
<a href="#l7.772"></a><span id="l7.772" class="difflineplus">+          toJSON = objNounDef.toJSON;</span>
<a href="#l7.773"></a><span id="l7.773" class="difflineplus">+          jsonDict[attrib.id] = [toJSON(subValue) for each</span>
<a href="#l7.774"></a><span id="l7.774" class="difflineplus">+                           ([, subValue] in Iterator(value))] ;</span>
<a href="#l7.775"></a><span id="l7.775" class="difflineplus">+        }</span>
<a href="#l7.776"></a><span id="l7.776" class="difflineplus">+        else</span>
<a href="#l7.777"></a><span id="l7.777" class="difflineplus">+          jsonDict[attrib.id] = value;</span>
<a href="#l7.778"></a><span id="l7.778" class="difflineplus">+      }</span>
<a href="#l7.779"></a><span id="l7.779" class="difflineplus">+      </span>
<a href="#l7.780"></a><span id="l7.780" class="difflineplus">+      // perform a delta analysis against the old value, if we have one</span>
<a href="#l7.781"></a><span id="l7.781" class="difflineplus">+      let oldValue = aOldItem[key];</span>
<a href="#l7.782"></a><span id="l7.782" class="difflineplus">+      if (oldValue !== undefined) {</span>
<a href="#l7.783"></a><span id="l7.783" class="difflineplus">+        // in the singular case if they don't match, it's one add and one remove</span>
<a href="#l7.784"></a><span id="l7.784" class="difflineplus">+        if (attrib.singular) {</span>
<a href="#l7.785"></a><span id="l7.785" class="difflineplus">+          if (value != oldValue) {</span>
<a href="#l7.786"></a><span id="l7.786" class="difflineplus">+            addDBAttribs.push(attrib.convertValuesToDBAttributes(value)[0]);</span>
<a href="#l7.787"></a><span id="l7.787" class="difflineplus">+            removeDBAttribs.push(</span>
<a href="#l7.788"></a><span id="l7.788" class="difflineplus">+              attrib.convertValuesToDBAttributes(oldValue)[0]);</span>
<a href="#l7.789"></a><span id="l7.789" class="difflineplus">+          }</span>
<a href="#l7.790"></a><span id="l7.790" class="difflineplus">+        }</span>
<a href="#l7.791"></a><span id="l7.791" class="difflineplus">+        // in the plural case, we have to figure the deltas accounting for</span>
<a href="#l7.792"></a><span id="l7.792" class="difflineplus">+        //  possible changes in ordering (which is insignificant from an</span>
<a href="#l7.793"></a><span id="l7.793" class="difflineplus">+        //  indexing perspective)</span>
<a href="#l7.794"></a><span id="l7.794" class="difflineplus">+        // some nouns may not meet === equivalence needs, so must provide a</span>
<a href="#l7.795"></a><span id="l7.795" class="difflineplus">+        //  custom computeDelta method to help us out</span>
<a href="#l7.796"></a><span id="l7.796" class="difflineplus">+        else if (objNounDef.computeDelta) {</span>
<a href="#l7.797"></a><span id="l7.797" class="difflineplus">+          let [valuesAdded, valuesRemoved] = </span>
<a href="#l7.798"></a><span id="l7.798" class="difflineplus">+            objNounDef.computeDelta(value, oldValue);</span>
<a href="#l7.799"></a><span id="l7.799" class="difflineplus">+          // convert the values to database-style attribute rows</span>
<a href="#l7.800"></a><span id="l7.800" class="difflineplus">+          addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l7.801"></a><span id="l7.801" class="difflineplus">+            attrib.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l7.802"></a><span id="l7.802" class="difflineplus">+          removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l7.803"></a><span id="l7.803" class="difflineplus">+            attrib.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l7.804"></a><span id="l7.804" class="difflineplus">+        }</span>
<a href="#l7.805"></a><span id="l7.805" class="difflineplus">+        else {</span>
<a href="#l7.806"></a><span id="l7.806" class="difflineplus">+          // build a map of the previous values; we will delete the values as</span>
<a href="#l7.807"></a><span id="l7.807" class="difflineplus">+          //  we see them so that we will know what old values are no longer</span>
<a href="#l7.808"></a><span id="l7.808" class="difflineplus">+          //  present in the current set of values.</span>
<a href="#l7.809"></a><span id="l7.809" class="difflineplus">+          let oldValueMap = {};</span>
<a href="#l7.810"></a><span id="l7.810" class="difflineplus">+          for each (let [iAnOldValue, anOldValue] in Iterator(oldValue)) {</span>
<a href="#l7.811"></a><span id="l7.811" class="difflineplus">+            oldValueMap[anOldValue] = true;</span>
<a href="#l7.812"></a><span id="l7.812" class="difflineplus">+          }</span>
<a href="#l7.813"></a><span id="l7.813" class="difflineplus">+          // traverse the current values...</span>
<a href="#l7.814"></a><span id="l7.814" class="difflineplus">+          let valuesAdded = [];</span>
<a href="#l7.815"></a><span id="l7.815" class="difflineplus">+          for each (let [iCurValue, curValue] in Iterator(value)) {</span>
<a href="#l7.816"></a><span id="l7.816" class="difflineplus">+            if (curValue in oldValueMap)</span>
<a href="#l7.817"></a><span id="l7.817" class="difflineplus">+              delete oldValueMap[curValue];</span>
<a href="#l7.818"></a><span id="l7.818" class="difflineplus">+            else</span>
<a href="#l7.819"></a><span id="l7.819" class="difflineplus">+              valuesAdded.push(curValue);</span>
<a href="#l7.820"></a><span id="l7.820" class="difflineplus">+          }</span>
<a href="#l7.821"></a><span id="l7.821" class="difflineplus">+          // anything still on oldValueMap was removed.</span>
<a href="#l7.822"></a><span id="l7.822" class="difflineplus">+          let valuesRemoved = [val for val in Iterator(oldValueMap, true)];</span>
<a href="#l7.823"></a><span id="l7.823" class="difflineplus">+          // convert the values to database-style attribute rows</span>
<a href="#l7.824"></a><span id="l7.824" class="difflineplus">+          addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l7.825"></a><span id="l7.825" class="difflineplus">+            attrib.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l7.826"></a><span id="l7.826" class="difflineplus">+          removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l7.827"></a><span id="l7.827" class="difflineplus">+            attrib.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l7.828"></a><span id="l7.828" class="difflineplus">+        }</span>
<a href="#l7.829"></a><span id="l7.829" class="difflineplus">+      </span>
<a href="#l7.830"></a><span id="l7.830" class="difflineplus">+        // delete the old values to mark that we have processed them</span>
<a href="#l7.831"></a><span id="l7.831" class="difflineplus">+        delete aOldItem[key];</span>
<a href="#l7.832"></a><span id="l7.832" class="difflineplus">+      }</span>
<a href="#l7.833"></a><span id="l7.833" class="difflineplus">+      // no old value, all attributes are new</span>
<a href="#l7.834"></a><span id="l7.834" class="difflineplus">+      else {</span>
<a href="#l7.835"></a><span id="l7.835" class="difflineplus">+        addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l7.836"></a><span id="l7.836" class="difflineplus">+                                attrib.convertValuesToDBAttributes(value));</span>
<a href="#l7.837"></a><span id="l7.837" class="difflineplus">+      }</span>
<a href="#l7.838"></a><span id="l7.838" class="difflineplus">+    }</span>
<a href="#l7.839"></a><span id="l7.839" class="difflineplus">+    </span>
<a href="#l7.840"></a><span id="l7.840" class="difflineplus">+    // Iterate over any remaining values in old items for purge purposes.</span>
<a href="#l7.841"></a><span id="l7.841" class="difflineplus">+    for each (let [key, value] in Iterator(aOldItem)) {</span>
<a href="#l7.842"></a><span id="l7.842" class="difflineplus">+      // ignore keys that start with underscores, they are private and not</span>
<a href="#l7.843"></a><span id="l7.843" class="difflineplus">+      //  persisted by our attribute mechanism.  (they are directly handled by</span>
<a href="#l7.844"></a><span id="l7.844" class="difflineplus">+      //  the object implementation.)</span>
<a href="#l7.845"></a><span id="l7.845" class="difflineplus">+      if (key[0] == &quot;_&quot;)</span>
<a href="#l7.846"></a><span id="l7.846" class="difflineplus">+        continue;</span>
<a href="#l7.847"></a><span id="l7.847" class="difflineplus">+      // find the attribute definition that corresponds to this key</span>
<a href="#l7.848"></a><span id="l7.848" class="difflineplus">+      let attrib = attribsByBoundName[key];</span>
<a href="#l7.849"></a><span id="l7.849" class="difflineplus">+      // if there's no attribute, that's not good, but not horrible.</span>
<a href="#l7.850"></a><span id="l7.850" class="difflineplus">+      if (attrib === undefined)</span>
<a href="#l7.851"></a><span id="l7.851" class="difflineplus">+        continue;</span>
<a href="#l7.852"></a><span id="l7.852" class="difflineplus">+      </span>
<a href="#l7.853"></a><span id="l7.853" class="difflineplus">+      removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l7.854"></a><span id="l7.854" class="difflineplus">+                                 attrib.convertValuesToDBAttributes(value));</span>
<a href="#l7.855"></a><span id="l7.855" class="difflineplus">+    }</span>
<a href="#l7.856"></a><span id="l7.856" class="difflineplus">+    </span>
<a href="#l7.857"></a><span id="l7.857" class="difflineplus">+    aItem._jsonText = this._json.encode(jsonDict);</span>
<a href="#l7.858"></a><span id="l7.858" class="difflineplus">+    </span>
<a href="#l7.859"></a><span id="l7.859" class="difflineplus">+    if (aIsNew) {</span>
<a href="#l7.860"></a><span id="l7.860" class="difflineplus">+      itemNounDef.objInsert.call(itemNounDef.datastore, aItem);</span>
<a href="#l7.861"></a><span id="l7.861" class="difflineplus">+    }</span>
<a href="#l7.862"></a><span id="l7.862" class="difflineplus">+    else {</span>
<a href="#l7.863"></a><span id="l7.863" class="difflineplus">+      itemNounDef.objUpdate.call(itemNounDef.datastore, aItem);</span>
<a href="#l7.864"></a><span id="l7.864" class="difflineplus">+    }</span>
<a href="#l7.865"></a><span id="l7.865" class="difflineplus">+    </span>
<a href="#l7.866"></a><span id="l7.866" class="difflineplus">+    yield this.kWorkDone;</span>
<a href="#l7.867"></a><span id="l7.867" class="difflineplus">+  },</span>
<a href="#l7.868"></a><span id="l7.868"> </span>
<a href="#l7.869"></a><span id="l7.869">   _processNounItem: function gloda_ns_processNounItem(aItem, aRawItem, aIsNew) {</span>
<a href="#l7.870"></a><span id="l7.870">     // For now, we are ridiculously lazy and simply nuke all existing attributes</span>
<a href="#l7.871"></a><span id="l7.871">     //  before applying the new attributes.</span>
<a href="#l7.872"></a><span id="l7.872">     aItem._datastore.clearAttributes(aItem);</span>
<a href="#l7.873"></a><span id="l7.873"> </span>
<a href="#l7.874"></a><span id="l7.874">     let allAttribs = [];</span>
<a href="#l7.875"></a><span id="l7.875"> </span>
<a href="#l7.876"></a><span id="l7.876" class="difflineat">@@ -1398,24 +1583,16 @@ var Gloda = {</span>
<a href="#l7.877"></a><span id="l7.877">     GlodaDatastore.insertAttributes(aItem, outAttribs);</span>
<a href="#l7.878"></a><span id="l7.878">     aItem._replaceAttributes(memAttribs);</span>
<a href="#l7.879"></a><span id="l7.879"> </span>
<a href="#l7.880"></a><span id="l7.880">     if (aIsNew)</span>
<a href="#l7.881"></a><span id="l7.881">       GlodaCollectionManager.itemsAdded(aItem.NOUN_ID, [aItem]);</span>
<a href="#l7.882"></a><span id="l7.882">     else</span>
<a href="#l7.883"></a><span id="l7.883">       GlodaCollectionManager.itemsModified(aItem.NOUN_ID, [aItem]);</span>
<a href="#l7.884"></a><span id="l7.884">   },</span>
<a href="#l7.885"></a><span id="l7.885" class="difflineminus">-</span>
<a href="#l7.886"></a><span id="l7.886" class="difflineminus">-  /**</span>
<a href="#l7.887"></a><span id="l7.887" class="difflineminus">-   * Deprecated mechanism for querying for messages.  Use newQuery now,</span>
<a href="#l7.888"></a><span id="l7.888" class="difflineminus">-   *  specifying the message noun id.  Still works for now, but not for long.</span>
<a href="#l7.889"></a><span id="l7.889" class="difflineminus">-   */</span>
<a href="#l7.890"></a><span id="l7.890" class="difflineminus">-  queryMessagesAPV: function gloda_ns_queryMessagesAPV(aAPVs) {</span>
<a href="#l7.891"></a><span id="l7.891" class="difflineminus">-    return GlodaDatastore.queryMessagesAPV(aAPVs);</span>
<a href="#l7.892"></a><span id="l7.892" class="difflineminus">-  }</span>
<a href="#l7.893"></a><span id="l7.893"> };</span>
<a href="#l7.894"></a><span id="l7.894"> </span>
<a href="#l7.895"></a><span id="l7.895"> /* and initialize the Gloda object/NS before we return... */</span>
<a href="#l7.896"></a><span id="l7.896"> try {</span>
<a href="#l7.897"></a><span id="l7.897">   Gloda._init();</span>
<a href="#l7.898"></a><span id="l7.898"> }</span>
<a href="#l7.899"></a><span id="l7.899"> catch (ex) {</span>
<a href="#l7.900"></a><span id="l7.900">   Gloda._log.debug(&quot;Exception during Gloda init (&quot; + ex.fileName + &quot;:&quot; +</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/modules/index_ab.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/modules/index_ab.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -217,41 +217,38 @@ var GlodaABAttrs = {</span>
<a href="#l8.4"></a><span id="l8.4">     // we need to find any existing bound freetag attributes, and use them to</span>
<a href="#l8.5"></a><span id="l8.5">     //  populate to FreeTagNoun's understanding</span>
<a href="#l8.6"></a><span id="l8.6">     for (let freeTagName in this._attrFreeTag.parameterBindings) {</span>
<a href="#l8.7"></a><span id="l8.7">       this._log.debug(&quot;Telling FreeTagNoun about: &quot; + freeTagName);</span>
<a href="#l8.8"></a><span id="l8.8">       FreeTagNoun.getFreeTag(freeTagName);</span>
<a href="#l8.9"></a><span id="l8.9">     }</span>
<a href="#l8.10"></a><span id="l8.10">   },</span>
<a href="#l8.11"></a><span id="l8.11">   </span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-  process: function(aContact, aCard) {</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+  process: function(aContact, aCard, aIsNew, aCallbackHandle) {</span>
<a href="#l8.14"></a><span id="l8.14">     if (aContact.NOUN_ID != Gloda.NOUN_CONTACT) {</span>
<a href="#l8.15"></a><span id="l8.15">       this._log.warning(&quot;Somehow got a non-contact: &quot; + aContact);</span>
<a href="#l8.16"></a><span id="l8.16" class="difflineminus">-      return [];</span>
<a href="#l8.17"></a><span id="l8.17" class="difflineplus">+      return Gloda.kWorkDone;</span>
<a href="#l8.18"></a><span id="l8.18">     }</span>
<a href="#l8.19"></a><span id="l8.19" class="difflineplus">+    </span>
<a href="#l8.20"></a><span id="l8.20" class="difflineplus">+    // update the name</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineplus">+    if (aCard.displayName &amp;&amp; aCard.displayName != aContact.name)</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineplus">+      aContact.name = aCard.displayName;</span>
<a href="#l8.23"></a><span id="l8.23">   </span>
<a href="#l8.24"></a><span id="l8.24" class="difflineminus">-    this._log.debug(&quot;Processing a contact and card.&quot;);</span>
<a href="#l8.25"></a><span id="l8.25" class="difflineminus">-    let attribs = [];</span>
<a href="#l8.26"></a><span id="l8.26" class="difflineplus">+    aContact.freeTags = [];</span>
<a href="#l8.27"></a><span id="l8.27">     </span>
<a href="#l8.28"></a><span id="l8.28">     let tags = null;</span>
<a href="#l8.29"></a><span id="l8.29">     try {</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineminus">-      tags = aCard.getProperty(&quot;tags&quot;, null);</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineplus">+      tags = aCard.getProperty(&quot;Categories&quot;, null);</span>
<a href="#l8.32"></a><span id="l8.32">     } catch (ex) {</span>
<a href="#l8.33"></a><span id="l8.33">       this._log.error(&quot;Problem accessing property: &quot; + ex);</span>
<a href="#l8.34"></a><span id="l8.34">     }</span>
<a href="#l8.35"></a><span id="l8.35">     if (tags) {</span>
<a href="#l8.36"></a><span id="l8.36" class="difflineminus">-      this._log.debug(&quot;Found tags: &quot; + tags);</span>
<a href="#l8.37"></a><span id="l8.37">       for each (let [iTagName, tagName] in Iterator(tags.split(&quot;,&quot;))) {</span>
<a href="#l8.38"></a><span id="l8.38">         tagName = tagName.trim();</span>
<a href="#l8.39"></a><span id="l8.39" class="difflineminus">-        // return attrib, param, value; we know the param to use because we know</span>
<a href="#l8.40"></a><span id="l8.40" class="difflineminus">-        //  how FreeTagNoun works, but this is a candidate for refactoring.</span>
<a href="#l8.41"></a><span id="l8.41">         if (tagName) {</span>
<a href="#l8.42"></a><span id="l8.42" class="difflineminus">-          FreeTagNoun.getFreeTag(tagName); // cause the tag to be known</span>
<a href="#l8.43"></a><span id="l8.43" class="difflineminus">-          attribs.push([this._attrFreeTag, tagName, null]);</span>
<a href="#l8.44"></a><span id="l8.44" class="difflineplus">+          aContact.freeTags.push(FreeTagNoun.getFreeTag(tagName));</span>
<a href="#l8.45"></a><span id="l8.45">         }</span>
<a href="#l8.46"></a><span id="l8.46">       }</span>
<a href="#l8.47"></a><span id="l8.47">     }</span>
<a href="#l8.48"></a><span id="l8.48">     </span>
<a href="#l8.49"></a><span id="l8.49" class="difflineminus">-    this._log.debug(&quot;Returning attributes: &quot; + attribs);</span>
<a href="#l8.50"></a><span id="l8.50" class="difflineminus">-    </span>
<a href="#l8.51"></a><span id="l8.51" class="difflineminus">-    return attribs;</span>
<a href="#l8.52"></a><span id="l8.52" class="difflineplus">+    yield Gloda.kWorkDone;</span>
<a href="#l8.53"></a><span id="l8.53">   }</span>
<a href="#l8.54"></a><span id="l8.54"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/modules/indexer.js</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/modules/indexer.js</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -126,16 +126,33 @@ function fixIterator(aEnum, aIface) {</span>
<a href="#l9.4"></a><span id="l9.4">     let iter = function () {</span>
<a href="#l9.5"></a><span id="l9.5">       while (aEnum.hasMoreElements())</span>
<a href="#l9.6"></a><span id="l9.6">         yield aEnum.getNext().QueryInterface(face);</span>
<a href="#l9.7"></a><span id="l9.7">     }</span>
<a href="#l9.8"></a><span id="l9.8">     return { __iterator__: iter };</span>
<a href="#l9.9"></a><span id="l9.9">   } catch(ex) {}</span>
<a href="#l9.10"></a><span id="l9.10"> }</span>
<a href="#l9.11"></a><span id="l9.11"> </span>
<a href="#l9.12"></a><span id="l9.12" class="difflineplus">+function MakeCleanMsgHdrCallback(aMsgHdr) {</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+  return function() {</span>
<a href="#l9.14"></a><span id="l9.14" class="difflineplus">+    // Mark this message as indexed</span>
<a href="#l9.15"></a><span id="l9.15" class="difflineplus">+    aMsgHdr.setUint32Property(this.GLODA_MESSAGE_ID_PROPERTY, curMsg.id);</span>
<a href="#l9.16"></a><span id="l9.16" class="difflineplus">+    // If there is a gloda-dirty flag on there, clear it by writing a 0.  (But</span>
<a href="#l9.17"></a><span id="l9.17" class="difflineplus">+    //  don't do this if we didn't have a dirty flag on there in the first</span>
<a href="#l9.18"></a><span id="l9.18" class="difflineplus">+    //  case.)  It sounds like we would actually prefer to &quot;cut&quot; the &quot;cell&quot;,</span>
<a href="#l9.19"></a><span id="l9.19" class="difflineplus">+    //  but I don't see any in-domain means of doing that.</span>
<a href="#l9.20"></a><span id="l9.20" class="difflineplus">+    try {</span>
<a href="#l9.21"></a><span id="l9.21" class="difflineplus">+      let isDirty = aMsgHdr.getUint32Property(this.GLODA_DIRTY_PROPERTY);</span>
<a href="#l9.22"></a><span id="l9.22" class="difflineplus">+      if (isDirty)</span>
<a href="#l9.23"></a><span id="l9.23" class="difflineplus">+        aMsgHdr.setUint32Property(this.GLODA_DIRTY_PROPERTY, 0);</span>
<a href="#l9.24"></a><span id="l9.24" class="difflineplus">+    }</span>
<a href="#l9.25"></a><span id="l9.25" class="difflineplus">+    catch (ex) {}</span>
<a href="#l9.26"></a><span id="l9.26" class="difflineplus">+  };</span>
<a href="#l9.27"></a><span id="l9.27" class="difflineplus">+}</span>
<a href="#l9.28"></a><span id="l9.28" class="difflineplus">+</span>
<a href="#l9.29"></a><span id="l9.29"> const MSG_FLAG_OFFLINE = 0x80;</span>
<a href="#l9.30"></a><span id="l9.30"> const MSG_FLAG_EXPUNGED = 0x08;</span>
<a href="#l9.31"></a><span id="l9.31"> </span>
<a href="#l9.32"></a><span id="l9.32"> /**</span>
<a href="#l9.33"></a><span id="l9.33">  * @class Capture the indexing batch concept explicitly.</span>
<a href="#l9.34"></a><span id="l9.34">  *</span>
<a href="#l9.35"></a><span id="l9.35">  * @param aJobType The type of thing we are indexing.  Current choices are:</span>
<a href="#l9.36"></a><span id="l9.36">  *   &quot;folder&quot; and &quot;message&quot;.  Previous choices included &quot;account&quot;.  The indexer</span>
<a href="#l9.37"></a><span id="l9.37" class="difflineat">@@ -275,16 +292,18 @@ var GlodaIndexer = {</span>
<a href="#l9.38"></a><span id="l9.38">     </span>
<a href="#l9.39"></a><span id="l9.39">     this._inited = true;</span>
<a href="#l9.40"></a><span id="l9.40">     </span>
<a href="#l9.41"></a><span id="l9.41">     // initialize our listeners' this pointers</span>
<a href="#l9.42"></a><span id="l9.42">     this._databaseAnnouncerListener.indexer = this;</span>
<a href="#l9.43"></a><span id="l9.43">     this._msgFolderListener.indexer = this;</span>
<a href="#l9.44"></a><span id="l9.44">     this._shutdownTask.indexer = this;</span>
<a href="#l9.45"></a><span id="l9.45">     </span>
<a href="#l9.46"></a><span id="l9.46" class="difflineplus">+    this._callbackHandler.init();</span>
<a href="#l9.47"></a><span id="l9.47" class="difflineplus">+    </span>
<a href="#l9.48"></a><span id="l9.48">     // create the timer that drives our intermittent indexing</span>
<a href="#l9.49"></a><span id="l9.49">     this._timer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l9.50"></a><span id="l9.50"> </span>
<a href="#l9.51"></a><span id="l9.51"> </span>
<a href="#l9.52"></a><span id="l9.52">     // figure out if event-driven indexing should be enabled...</span>
<a href="#l9.53"></a><span id="l9.53">     let prefService = Cc[&quot;@mozilla.org/preferences-service;1&quot;].</span>
<a href="#l9.54"></a><span id="l9.54">                         getService(Ci.nsIPrefService);</span>
<a href="#l9.55"></a><span id="l9.55">     let branch = prefService.getBranch(&quot;mailnews.database.global.indexer&quot;);</span>
<a href="#l9.56"></a><span id="l9.56" class="difflineat">@@ -514,33 +533,44 @@ var GlodaIndexer = {</span>
<a href="#l9.57"></a><span id="l9.57">    *  it means the value is known reliably.  If this value is null, it means</span>
<a href="#l9.58"></a><span id="l9.58">    *  that we don't know, likely because we have started up and have not checked</span>
<a href="#l9.59"></a><span id="l9.59">    *  the database.</span>
<a href="#l9.60"></a><span id="l9.60">    */</span>
<a href="#l9.61"></a><span id="l9.61">   pendingDeletions: null,</span>
<a href="#l9.62"></a><span id="l9.62">   </span>
<a href="#l9.63"></a><span id="l9.63">   GLODA_MESSAGE_ID_PROPERTY: &quot;gloda-id&quot;,</span>
<a href="#l9.64"></a><span id="l9.64">   GLODA_DIRTY_PROPERTY: &quot;gloda-dirty&quot;,</span>
<a href="#l9.65"></a><span id="l9.65" class="difflineminus">-</span>
<a href="#l9.66"></a><span id="l9.66" class="difflineminus">-  /** Synchronous activities performed, you can drive us more. */</span>
<a href="#l9.67"></a><span id="l9.67" class="difflineminus">-  kWorkSync: 0,</span>
<a href="#l9.68"></a><span id="l9.68">   /**</span>
<a href="#l9.69"></a><span id="l9.69" class="difflineminus">-   * Asynchronous activity performed, you need to relinquish flow control and</span>
<a href="#l9.70"></a><span id="l9.70" class="difflineminus">-   *  trust us to call callbackDriver later.</span>
<a href="#l9.71"></a><span id="l9.71" class="difflineplus">+   * The message (or folder state) is believed up-to-date.</span>
<a href="#l9.72"></a><span id="l9.72">    */</span>
<a href="#l9.73"></a><span id="l9.73" class="difflineminus">-  kWorkAsync: 1,</span>
<a href="#l9.74"></a><span id="l9.74" class="difflineplus">+  kMessageClean: 0,</span>
<a href="#l9.75"></a><span id="l9.75">   /**</span>
<a href="#l9.76"></a><span id="l9.76" class="difflineminus">-   * We are all done with our task, close us and figure out something else to do.</span>
<a href="#l9.77"></a><span id="l9.77" class="difflineplus">+   * The message (or folder) is known to not be up-to-date. In the case of</span>
<a href="#l9.78"></a><span id="l9.78" class="difflineplus">+   *  folders, this means that some of the messages in the folder may be dirty.</span>
<a href="#l9.79"></a><span id="l9.79" class="difflineplus">+   *  However, because of the way our indexing works, it is possible there may</span>
<a href="#l9.80"></a><span id="l9.80" class="difflineplus">+   *  actually be no dirty messages in a folder.  (We attempt to process</span>
<a href="#l9.81"></a><span id="l9.81" class="difflineplus">+   *  messages in an event-driven fashion for a finite number of messages, but</span>
<a href="#l9.82"></a><span id="l9.82" class="difflineplus">+   *  because we can quit without completing processing of the queue, we need to</span>
<a href="#l9.83"></a><span id="l9.83" class="difflineplus">+   *  mark the folder dirty, just-in-case.)  (We could do some extra leg-work</span>
<a href="#l9.84"></a><span id="l9.84" class="difflineplus">+   *  and do a better job of marking the folder clean again.)   </span>
<a href="#l9.85"></a><span id="l9.85">    */</span>
<a href="#l9.86"></a><span id="l9.86" class="difflineminus">-  kWorkDone: 2,</span>
<a href="#l9.87"></a><span id="l9.87" class="difflineplus">+  kMessageDirty: 1,</span>
<a href="#l9.88"></a><span id="l9.88">   /**</span>
<a href="#l9.89"></a><span id="l9.89" class="difflineminus">-   * We are not done with our task, but we think it's a good idea to take a</span>
<a href="#l9.90"></a><span id="l9.90" class="difflineminus">-   *  breather.</span>
<a href="#l9.91"></a><span id="l9.91" class="difflineplus">+   * We have not indexed the folder at all, but messages in the folder think</span>
<a href="#l9.92"></a><span id="l9.92" class="difflineplus">+   *  they are indexed.  Once we mark all the messages in the folder as being</span>
<a href="#l9.93"></a><span id="l9.93" class="difflineplus">+   *  dirty so that they don't confuse us, we downgrade the folder's dirty</span>
<a href="#l9.94"></a><span id="l9.94" class="difflineplus">+   *  status to just kMessageDirty.</span>
<a href="#l9.95"></a><span id="l9.95">    */</span>
<a href="#l9.96"></a><span id="l9.96" class="difflineminus">-  kWorkPause: 3,</span>
<a href="#l9.97"></a><span id="l9.97" class="difflineplus">+  kMessageFilthy: 2,</span>
<a href="#l9.98"></a><span id="l9.98" class="difflineplus">+</span>
<a href="#l9.99"></a><span id="l9.99" class="difflineplus">+  kWorkSync: Gloda.kWorkSync,</span>
<a href="#l9.100"></a><span id="l9.100" class="difflineplus">+  kWorkAsync: Gloda.kWorkAsync,</span>
<a href="#l9.101"></a><span id="l9.101" class="difflineplus">+  kWorkDone: Gloda.kWorkDone,</span>
<a href="#l9.102"></a><span id="l9.102" class="difflineplus">+  kWorkPause: Gloda.kWorkPause,</span>
<a href="#l9.103"></a><span id="l9.103" class="difflineplus">+  kWorkDoneWithResult: Gloda.kWorkDoneWithResult,</span>
<a href="#l9.104"></a><span id="l9.104">   </span>
<a href="#l9.105"></a><span id="l9.105">   /**</span>
<a href="#l9.106"></a><span id="l9.106">    * Our current job number, out of _indexingJobGoal.  Although our jobs comes</span>
<a href="#l9.107"></a><span id="l9.107">    *  from _indexQueue, this is not an offset into that list because we forget</span>
<a href="#l9.108"></a><span id="l9.108">    *  jobs once we complete them.  As such, this value is strictly for progress</span>
<a href="#l9.109"></a><span id="l9.109">    *  tracking.</span>
<a href="#l9.110"></a><span id="l9.110">    */ </span>
<a href="#l9.111"></a><span id="l9.111">   _indexingJobCount: 0,</span>
<a href="#l9.112"></a><span id="l9.112" class="difflineat">@@ -724,22 +754,21 @@ var GlodaIndexer = {</span>
<a href="#l9.113"></a><span id="l9.113">                                                                aNeedIterator) {</span>
<a href="#l9.114"></a><span id="l9.114">     // if leave folder was't cleared first, remove the listener; everyone else</span>
<a href="#l9.115"></a><span id="l9.115">     //  will be nulled out in the exception handler below if things go south</span>
<a href="#l9.116"></a><span id="l9.116">     //  on this folder.</span>
<a href="#l9.117"></a><span id="l9.117">     if (this._indexingFolder !== null) {</span>
<a href="#l9.118"></a><span id="l9.118">       this._indexingDatabase.RemoveListener(this._databaseAnnouncerListener);</span>
<a href="#l9.119"></a><span id="l9.119">     }</span>
<a href="#l9.120"></a><span id="l9.120">     </span>
<a href="#l9.121"></a><span id="l9.121" class="difflineminus">-    let folderURI = GlodaDatastore._mapFolderID(aFolderID);</span>
<a href="#l9.122"></a><span id="l9.122" class="difflineminus">-    //this._log.debug(&quot;Active Folder URI: &quot; + folderURI);</span>
<a href="#l9.123"></a><span id="l9.123" class="difflineplus">+    let glodaFolder = GlodaDatastore._mapFolderID(aFolderID);</span>
<a href="#l9.124"></a><span id="l9.124">   </span>
<a href="#l9.125"></a><span id="l9.125">     let rdfService = Cc['@mozilla.org/rdf/rdf-service;1'].</span>
<a href="#l9.126"></a><span id="l9.126">                      getService(Ci.nsIRDFService);</span>
<a href="#l9.127"></a><span id="l9.127" class="difflineminus">-    let folder = rdfService.GetResource(folderURI);</span>
<a href="#l9.128"></a><span id="l9.128" class="difflineplus">+    let folder = rdfService.GetResource(glodaFolder.uri);</span>
<a href="#l9.129"></a><span id="l9.129">     folder.QueryInterface(Ci.nsIMsgFolder); // (we want to explode in the try</span>
<a href="#l9.130"></a><span id="l9.130">     // if this guy wasn't what we wanted)</span>
<a href="#l9.131"></a><span id="l9.131">     this._indexingFolder = folder;</span>
<a href="#l9.132"></a><span id="l9.132">     this._indexingFolderID = aFolderID;</span>
<a href="#l9.133"></a><span id="l9.133"> </span>
<a href="#l9.134"></a><span id="l9.134">     try {</span>
<a href="#l9.135"></a><span id="l9.135">       // The msf may need to be created or otherwise updated for local folders.</span>
<a href="#l9.136"></a><span id="l9.136">       // This may require yielding until such time as the msf has been created.</span>
<a href="#l9.137"></a><span id="l9.137" class="difflineat">@@ -762,19 +791,17 @@ var GlodaIndexer = {</span>
<a href="#l9.138"></a><span id="l9.138">         return this.kWorkAsync;</span>
<a href="#l9.139"></a><span id="l9.139">       }</span>
<a href="#l9.140"></a><span id="l9.140">       // we get an nsIMsgDatabase out of this (unsurprisingly) which</span>
<a href="#l9.141"></a><span id="l9.141">       //  explicitly inherits from nsIDBChangeAnnouncer, which has the</span>
<a href="#l9.142"></a><span id="l9.142">       //  AddListener call we want.</span>
<a href="#l9.143"></a><span id="l9.143">       if (this._indexingDatabase == null)</span>
<a href="#l9.144"></a><span id="l9.144">         this._indexingDatabase = folder.getMsgDatabase(null);</span>
<a href="#l9.145"></a><span id="l9.145">       if (aNeedIterator)</span>
<a href="#l9.146"></a><span id="l9.146" class="difflineminus">-        this._indexingIterator = fixIterator(</span>
<a href="#l9.147"></a><span id="l9.147" class="difflineminus">-                                   this._indexingDatabase.EnumerateMessages(),</span>
<a href="#l9.148"></a><span id="l9.148" class="difflineminus">-                                   Ci.nsIMsgDBHdr);</span>
<a href="#l9.149"></a><span id="l9.149" class="difflineplus">+        this._indexerGetIterator();</span>
<a href="#l9.150"></a><span id="l9.150">       this._indexingDatabase.AddListener(this._databaseAnnouncerListener);</span>
<a href="#l9.151"></a><span id="l9.151">     }</span>
<a href="#l9.152"></a><span id="l9.152">     catch (ex) {</span>
<a href="#l9.153"></a><span id="l9.153">       this._log.error(&quot;Problem entering folder: &quot; +</span>
<a href="#l9.154"></a><span id="l9.154">                       folder.prettiestName + &quot;, skipping.&quot;);</span>
<a href="#l9.155"></a><span id="l9.155">       this._log.error(&quot;Error was: &quot; + ex);</span>
<a href="#l9.156"></a><span id="l9.156">       this._indexingFolder = null;</span>
<a href="#l9.157"></a><span id="l9.157">       this._indexingFolderID = null;</span>
<a href="#l9.158"></a><span id="l9.158" class="difflineat">@@ -784,16 +811,22 @@ var GlodaIndexer = {</span>
<a href="#l9.159"></a><span id="l9.159">       // re-throw, we just wanted to make sure this junk is cleaned up and</span>
<a href="#l9.160"></a><span id="l9.160">       //  get localized error logging...</span>
<a href="#l9.161"></a><span id="l9.161">       throw ex;</span>
<a href="#l9.162"></a><span id="l9.162">     }</span>
<a href="#l9.163"></a><span id="l9.163">     </span>
<a href="#l9.164"></a><span id="l9.164">     return this.kWorkSync;</span>
<a href="#l9.165"></a><span id="l9.165">   },</span>
<a href="#l9.166"></a><span id="l9.166">   </span>
<a href="#l9.167"></a><span id="l9.167" class="difflineplus">+  _indexerGetIterator: function gloda_indexer_indexerGetIterator() {</span>
<a href="#l9.168"></a><span id="l9.168" class="difflineplus">+    this._indexingIterator = fixIterator(</span>
<a href="#l9.169"></a><span id="l9.169" class="difflineplus">+                               this._indexingDatabase.EnumerateMessages(),</span>
<a href="#l9.170"></a><span id="l9.170" class="difflineplus">+                               Ci.nsIMsgDBHdr);</span>
<a href="#l9.171"></a><span id="l9.171" class="difflineplus">+  },</span>
<a href="#l9.172"></a><span id="l9.172" class="difflineplus">+  </span>
<a href="#l9.173"></a><span id="l9.173">   _indexerLeaveFolder: function gloda_index_indexerLeaveFolder(aExpected) {</span>
<a href="#l9.174"></a><span id="l9.174">     if (this._indexingFolder !== null) {</span>
<a href="#l9.175"></a><span id="l9.175">       // remove our listener!</span>
<a href="#l9.176"></a><span id="l9.176">       this._indexingDatabase.RemoveListener(this._databaseAnnouncerListener);</span>
<a href="#l9.177"></a><span id="l9.177">       // null everyone out</span>
<a href="#l9.178"></a><span id="l9.178">       this._indexingFolder = null;</span>
<a href="#l9.179"></a><span id="l9.179">       this._indexingFolderID = null;</span>
<a href="#l9.180"></a><span id="l9.180">       this._indexingDatabase = null;</span>
<a href="#l9.181"></a><span id="l9.181" class="difflineat">@@ -831,49 +864,71 @@ var GlodaIndexer = {</span>
<a href="#l9.182"></a><span id="l9.182">   },</span>
<a href="#l9.183"></a><span id="l9.183"> </span>
<a href="#l9.184"></a><span id="l9.184">   /**</span>
<a href="#l9.185"></a><span id="l9.185">    * The current processing 'batch' generator, produced by a call to workBatch()</span>
<a href="#l9.186"></a><span id="l9.186">    *  and used by callbackDriver to drive execution.</span>
<a href="#l9.187"></a><span id="l9.187">    */</span>
<a href="#l9.188"></a><span id="l9.188">   _batch: null,</span>
<a href="#l9.189"></a><span id="l9.189">   _inCallback: false,</span>
<a href="#l9.190"></a><span id="l9.190" class="difflineplus">+  _savedCallbackArgs: null,</span>
<a href="#l9.191"></a><span id="l9.191">   /**</span>
<a href="#l9.192"></a><span id="l9.192">    * The root work-driver.  callbackDriver creates workBatch generator instances</span>
<a href="#l9.193"></a><span id="l9.193">    *  (stored in _batch) which run until they are done (kWorkDone) or they</span>
<a href="#l9.194"></a><span id="l9.194">    *  (really the embedded _actualWorker) encounter something asynchronous.</span>
<a href="#l9.195"></a><span id="l9.195">    *  The convention is that all the callback handlers end up calling us,</span>
<a href="#l9.196"></a><span id="l9.196">    *  ensuring that control-flow properly resumes.  If the batch completes,</span>
<a href="#l9.197"></a><span id="l9.197">    *  we re-schedule ourselves after a time delay (controlled by _indexInterval)</span>
<a href="#l9.198"></a><span id="l9.198">    *  and return.  (We use one-shot timers because repeating-slack does not</span>
<a href="#l9.199"></a><span id="l9.199">    *  know enough to deal with our (current) asynchronous nature.)</span>
<a href="#l9.200"></a><span id="l9.200">    */</span>
<a href="#l9.201"></a><span id="l9.201">   callbackDriver: function gloda_index_callbackDriver() {</span>
<a href="#l9.202"></a><span id="l9.202">     // it is conceivable that someone we call will call something that in some</span>
<a href="#l9.203"></a><span id="l9.203">     //  cases might be asynchronous, and in other cases immediately generate</span>
<a href="#l9.204"></a><span id="l9.204">     //  events without returning.  In the interest of (stack-depth) sanity,</span>
<a href="#l9.205"></a><span id="l9.205">     //  let's handle this by performing a minimal time-delay callback.</span>
<a href="#l9.206"></a><span id="l9.206" class="difflineplus">+    // this is also now a good thing sequencing-wise.  if we get our callback</span>
<a href="#l9.207"></a><span id="l9.207" class="difflineplus">+    //  with data before the underlying function has yielded, we obviously can't</span>
<a href="#l9.208"></a><span id="l9.208" class="difflineplus">+    //  cram the data in yet.  Our options in this case are to either mark the</span>
<a href="#l9.209"></a><span id="l9.209" class="difflineplus">+    //  fact that the callback has already happened and immediately return to</span>
<a href="#l9.210"></a><span id="l9.210" class="difflineplus">+    //  the iterator when it does bubble up the kWorkAsync, or we can do as we</span>
<a href="#l9.211"></a><span id="l9.211" class="difflineplus">+    //  have been doing, but save the </span>
<a href="#l9.212"></a><span id="l9.212">     if (this._inCallback) {</span>
<a href="#l9.213"></a><span id="l9.213" class="difflineplus">+      this._savedCallbackArgs = arguments;</span>
<a href="#l9.214"></a><span id="l9.214">       this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l9.215"></a><span id="l9.215">                                    0,</span>
<a href="#l9.216"></a><span id="l9.216">                                    Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l9.217"></a><span id="l9.217">       return;</span>
<a href="#l9.218"></a><span id="l9.218">     }</span>
<a href="#l9.219"></a><span id="l9.219">     this._inCallback = true;</span>
<a href="#l9.220"></a><span id="l9.220"> </span>
<a href="#l9.221"></a><span id="l9.221">     try {</span>
<a href="#l9.222"></a><span id="l9.222">       if (this._batch === null)</span>
<a href="#l9.223"></a><span id="l9.223">         this._batch = this.workBatch();</span>
<a href="#l9.224"></a><span id="l9.224">       </span>
<a href="#l9.225"></a><span id="l9.225">       // kWorkAsync, kWorkDone, kWorkPause are allowed out; kWorkSync is not</span>
<a href="#l9.226"></a><span id="l9.226">       // On kWorkDone, we want to schedule another timer to fire on us if we are</span>
<a href="#l9.227"></a><span id="l9.227">       //  not done indexing.  (On kWorkAsync, we don't care what happens, because</span>
<a href="#l9.228"></a><span id="l9.228">       //  someone else will be receiving the callback, and they will call us when</span>
<a href="#l9.229"></a><span id="l9.229">       //  they are done doing their thing.</span>
<a href="#l9.230"></a><span id="l9.230" class="difflineminus">-      switch (this._batch.next()) {</span>
<a href="#l9.231"></a><span id="l9.231" class="difflineplus">+      let result;</span>
<a href="#l9.232"></a><span id="l9.232" class="difflineplus">+      let args;</span>
<a href="#l9.233"></a><span id="l9.233" class="difflineplus">+      if (this._savedCallbackArgs != null) {</span>
<a href="#l9.234"></a><span id="l9.234" class="difflineplus">+        args = this._savedCallbackArgs;</span>
<a href="#l9.235"></a><span id="l9.235" class="difflineplus">+        this._savedCallbackArgs = null;</span>
<a href="#l9.236"></a><span id="l9.236" class="difflineplus">+      }</span>
<a href="#l9.237"></a><span id="l9.237" class="difflineplus">+      else</span>
<a href="#l9.238"></a><span id="l9.238" class="difflineplus">+        args = arguments;</span>
<a href="#l9.239"></a><span id="l9.239" class="difflineplus">+      if (args.length == 0)</span>
<a href="#l9.240"></a><span id="l9.240" class="difflineplus">+        result = this._batch.next();</span>
<a href="#l9.241"></a><span id="l9.241" class="difflineplus">+      else if (args.length == 1)</span>
<a href="#l9.242"></a><span id="l9.242" class="difflineplus">+        result = this._batch.send(args[0]);</span>
<a href="#l9.243"></a><span id="l9.243" class="difflineplus">+      else // arguments works with destructuring assignment</span>
<a href="#l9.244"></a><span id="l9.244" class="difflineplus">+        result = this._batch.send(args);</span>
<a href="#l9.245"></a><span id="l9.245" class="difflineplus">+      switch (result) {</span>
<a href="#l9.246"></a><span id="l9.246">         // job's done, close the batch and re-schedule ourselves if there's more</span>
<a href="#l9.247"></a><span id="l9.247">         //  to do.</span>
<a href="#l9.248"></a><span id="l9.248">         case this.kWorkDone:</span>
<a href="#l9.249"></a><span id="l9.249">           this._batch.close();</span>
<a href="#l9.250"></a><span id="l9.250">           this._batch = null;</span>
<a href="#l9.251"></a><span id="l9.251">           // (intentional fall-through to re-scheduling logic) </span>
<a href="#l9.252"></a><span id="l9.252">         // the batch wants to get re-scheduled, do so.</span>
<a href="#l9.253"></a><span id="l9.253">         case this.kWorkPause:</span>
<a href="#l9.254"></a><span id="l9.254" class="difflineat">@@ -890,74 +945,121 @@ var GlodaIndexer = {</span>
<a href="#l9.255"></a><span id="l9.255">           break;</span>
<a href="#l9.256"></a><span id="l9.256">       }</span>
<a href="#l9.257"></a><span id="l9.257">     }</span>
<a href="#l9.258"></a><span id="l9.258">     finally {    </span>
<a href="#l9.259"></a><span id="l9.259">       this._inCallback = false;</span>
<a href="#l9.260"></a><span id="l9.260">     }</span>
<a href="#l9.261"></a><span id="l9.261">   },</span>
<a href="#l9.262"></a><span id="l9.262"> </span>
<a href="#l9.263"></a><span id="l9.263" class="difflineminus">-  /**</span>
<a href="#l9.264"></a><span id="l9.264" class="difflineminus">-   * The generator we are using to perform processing of the current job</span>
<a href="#l9.265"></a><span id="l9.265" class="difflineminus">-   *  (this._curIndexingJob).  It differs from this._batch which is a generator</span>
<a href="#l9.266"></a><span id="l9.266" class="difflineminus">-   *  that takes care of the batching logistics (namely managing database</span>
<a href="#l9.267"></a><span id="l9.267" class="difflineminus">-   *  transactions and keeping track of how much work can be done with the</span>
<a href="#l9.268"></a><span id="l9.268" class="difflineminus">-   *  current allocation of processing &quot;tokens&quot;.</span>
<a href="#l9.269"></a><span id="l9.269" class="difflineminus">-   * The generator is created by _hireJobWorker from one of the _worker_*</span>
<a href="#l9.270"></a><span id="l9.270" class="difflineminus">-   *  generator methods.</span>
<a href="#l9.271"></a><span id="l9.271" class="difflineminus">-   */</span>
<a href="#l9.272"></a><span id="l9.272" class="difflineminus">-  _actualWorker: null,</span>
<a href="#l9.273"></a><span id="l9.273" class="difflineplus">+  _callbackHandle: {</span>
<a href="#l9.274"></a><span id="l9.274" class="difflineplus">+    _init: function gloda_index_callbackhandle_init() {</span>
<a href="#l9.275"></a><span id="l9.275" class="difflineplus">+      this.wrappedCallback = GlodaIndexer._wrapCallbackDriver;</span>
<a href="#l9.276"></a><span id="l9.276" class="difflineplus">+      this.callback = GlodaIndexer.callbackDriver;</span>
<a href="#l9.277"></a><span id="l9.277" class="difflineplus">+      </span>
<a href="#l9.278"></a><span id="l9.278" class="difflineplus">+    },</span>
<a href="#l9.279"></a><span id="l9.279" class="difflineplus">+    activeStack: [],</span>
<a href="#l9.280"></a><span id="l9.280" class="difflineplus">+    activeIterator: null,</span>
<a href="#l9.281"></a><span id="l9.281" class="difflineplus">+    push: function gloda_index_callbackhandle_push(aIterator) {</span>
<a href="#l9.282"></a><span id="l9.282" class="difflineplus">+      this.activeStack.push(aIterator);</span>
<a href="#l9.283"></a><span id="l9.283" class="difflineplus">+      this.activeIterator = aIterator;</span>
<a href="#l9.284"></a><span id="l9.284" class="difflineplus">+    },</span>
<a href="#l9.285"></a><span id="l9.285" class="difflineplus">+    pushAndGo: function gloda_index_callbackhandle_pushAndGo(aIterator) {</span>
<a href="#l9.286"></a><span id="l9.286" class="difflineplus">+      this.push(aIterator);</span>
<a href="#l9.287"></a><span id="l9.287" class="difflineplus">+      return this.activeIterator.next();</span>
<a href="#l9.288"></a><span id="l9.288" class="difflineplus">+    },</span>
<a href="#l9.289"></a><span id="l9.289" class="difflineplus">+    pop: function gloda_index_callbackhandle_pop() {</span>
<a href="#l9.290"></a><span id="l9.290" class="difflineplus">+      this.activeIterator.close();</span>
<a href="#l9.291"></a><span id="l9.291" class="difflineplus">+      this.activeStack.pop();</span>
<a href="#l9.292"></a><span id="l9.292" class="difflineplus">+      if (this.activeStack.length)</span>
<a href="#l9.293"></a><span id="l9.293" class="difflineplus">+        this.activeIterator = this.activeStack[this.activeStack.length - 1];</span>
<a href="#l9.294"></a><span id="l9.294" class="difflineplus">+      else</span>
<a href="#l9.295"></a><span id="l9.295" class="difflineplus">+        this.activeIterator = null;</span>
<a href="#l9.296"></a><span id="l9.296" class="difflineplus">+    },</span>
<a href="#l9.297"></a><span id="l9.297" class="difflineplus">+    /**</span>
<a href="#l9.298"></a><span id="l9.298" class="difflineplus">+     * Someone propagated an exception and we need to clean-up all the active</span>
<a href="#l9.299"></a><span id="l9.299" class="difflineplus">+     *  logic as best we can.  Which is not really all that well.</span>
<a href="#l9.300"></a><span id="l9.300" class="difflineplus">+     */</span>
<a href="#l9.301"></a><span id="l9.301" class="difflineplus">+    cleanup: function gloda_index_callbackhandle_cleanup() {</span>
<a href="#l9.302"></a><span id="l9.302" class="difflineplus">+      while (this.activeIterator !== null) {</span>
<a href="#l9.303"></a><span id="l9.303" class="difflineplus">+        this.pop();</span>
<a href="#l9.304"></a><span id="l9.304" class="difflineplus">+      }</span>
<a href="#l9.305"></a><span id="l9.305" class="difflineplus">+    },</span>
<a href="#l9.306"></a><span id="l9.306" class="difflineplus">+    popWithResult: function gloda_index_callbackhandle_popWithResult() {</span>
<a href="#l9.307"></a><span id="l9.307" class="difflineplus">+      this.pop();</span>
<a href="#l9.308"></a><span id="l9.308" class="difflineplus">+      let reslt = this._result;</span>
<a href="#l9.309"></a><span id="l9.309" class="difflineplus">+      this._result = null;</span>
<a href="#l9.310"></a><span id="l9.310" class="difflineplus">+      return result;</span>
<a href="#l9.311"></a><span id="l9.311" class="difflineplus">+    },</span>
<a href="#l9.312"></a><span id="l9.312" class="difflineplus">+    _result: null,</span>
<a href="#l9.313"></a><span id="l9.313" class="difflineplus">+    doneWithResult: function gloda_index_callbackhandle_doneWithResult(aResult){</span>
<a href="#l9.314"></a><span id="l9.314" class="difflineplus">+      this._result = aResult;</span>
<a href="#l9.315"></a><span id="l9.315" class="difflineplus">+      yield Gloda.kWorkDoneWithResult;</span>
<a href="#l9.316"></a><span id="l9.316" class="difflineplus">+    },</span>
<a href="#l9.317"></a><span id="l9.317" class="difflineplus">+    </span>
<a href="#l9.318"></a><span id="l9.318" class="difflineplus">+    /* be able to serve as a collection listener, resuming the active iterator's</span>
<a href="#l9.319"></a><span id="l9.319" class="difflineplus">+       last yield kWorkAsync */</span>
<a href="#l9.320"></a><span id="l9.320" class="difflineplus">+    _onItemsAdded: function() {},</span>
<a href="#l9.321"></a><span id="l9.321" class="difflineplus">+    _onItemsModified: function() {},</span>
<a href="#l9.322"></a><span id="l9.322" class="difflineplus">+    _onItemsRemoved: function() {},</span>
<a href="#l9.323"></a><span id="l9.323" class="difflineplus">+    _onQueryCompleted: function(aCollection) {</span>
<a href="#l9.324"></a><span id="l9.324" class="difflineplus">+      GlodaIndexer.callbackDriver();</span>
<a href="#l9.325"></a><span id="l9.325" class="difflineplus">+    }</span>
<a href="#l9.326"></a><span id="l9.326" class="difflineplus">+  },</span>
<a href="#l9.327"></a><span id="l9.327">   /**</span>
<a href="#l9.328"></a><span id="l9.328">    * The workBatch generator handles a single 'batch' of processing, managing</span>
<a href="#l9.329"></a><span id="l9.329">    *  the database transaction and keeping track of &quot;tokens&quot;.  It drives the</span>
<a href="#l9.330"></a><span id="l9.330">    *  _actualWorker generator which is doing the work.</span>
<a href="#l9.331"></a><span id="l9.331">    * workBatch will only produce kWorkAsync and kWorkDone notifications.</span>
<a href="#l9.332"></a><span id="l9.332">    *  If _actualWorker returns kWorkSync and there are still tokens available,</span>
<a href="#l9.333"></a><span id="l9.333">    *  workBatch will keep driving _actualWorker until it encounters a</span>
<a href="#l9.334"></a><span id="l9.334">    *  kWorkAsync (which workBatch will yield to callbackDriver), or it runs</span>
<a href="#l9.335"></a><span id="l9.335">    *  out of tokens and yields a kWorkDone. </span>
<a href="#l9.336"></a><span id="l9.336">    */</span>
<a href="#l9.337"></a><span id="l9.337">   workBatch: function gloda_index_workBatch() {</span>
<a href="#l9.338"></a><span id="l9.338">     let commitTokens = this._indexCommitTokens;</span>
<a href="#l9.339"></a><span id="l9.339">     GlodaDatastore._beginTransaction();</span>
<a href="#l9.340"></a><span id="l9.340"> </span>
<a href="#l9.341"></a><span id="l9.341" class="difflineplus">+    let data = undefined;</span>
<a href="#l9.342"></a><span id="l9.342">     while (commitTokens &gt; 0) {</span>
<a href="#l9.343"></a><span id="l9.343">       for (let tokensLeft = this._indexTokens; tokensLeft &gt; 0;</span>
<a href="#l9.344"></a><span id="l9.344">           tokensLeft--, commitTokens--) {</span>
<a href="#l9.345"></a><span id="l9.345" class="difflineminus">-        if ((this._actualWorker === null) &amp;&amp; !this._hireJobWorker()) {</span>
<a href="#l9.346"></a><span id="l9.346" class="difflineplus">+        if ((this._callbackHandle.activeIterator === null) &amp;&amp;</span>
<a href="#l9.347"></a><span id="l9.347" class="difflineplus">+            !this._hireJobWorker()) {</span>
<a href="#l9.348"></a><span id="l9.348">           commitTokens = 0;</span>
<a href="#l9.349"></a><span id="l9.349">           break;</span>
<a href="#l9.350"></a><span id="l9.350">         }</span>
<a href="#l9.351"></a><span id="l9.351">       </span>
<a href="#l9.352"></a><span id="l9.352">         // XXX for performance, we may want to move the try outside the for loop</span>
<a href="#l9.353"></a><span id="l9.353">         //  with a quasi-redundant outer loop that shunts control back inside</span>
<a href="#l9.354"></a><span id="l9.354">         //  if we left the loop due to an exception (without consuming all the</span>
<a href="#l9.355"></a><span id="l9.355">         //  tokens.)</span>
<a href="#l9.356"></a><span id="l9.356">         try {</span>
<a href="#l9.357"></a><span id="l9.357" class="difflineminus">-          switch (this._actualWorker.next()) {</span>
<a href="#l9.358"></a><span id="l9.358" class="difflineplus">+          switch (this._callbackHandler.activeIterator.send(data)) {</span>
<a href="#l9.359"></a><span id="l9.359">             case this.kWorkSync:</span>
<a href="#l9.360"></a><span id="l9.360">               break;</span>
<a href="#l9.361"></a><span id="l9.361">             case this.kWorkAsync:</span>
<a href="#l9.362"></a><span id="l9.362" class="difflineminus">-              yield this.kWorkAsync;</span>
<a href="#l9.363"></a><span id="l9.363" class="difflineplus">+              data = yield this.kWorkAsync;</span>
<a href="#l9.364"></a><span id="l9.364">               break;</span>
<a href="#l9.365"></a><span id="l9.365">             case this.kWorkDone:</span>
<a href="#l9.366"></a><span id="l9.366" class="difflineminus">-              this._actualWorker.close();</span>
<a href="#l9.367"></a><span id="l9.367" class="difflineminus">-              this._actualWorker = null;</span>
<a href="#l9.368"></a><span id="l9.368" class="difflineplus">+              this._callbackHandler.pop();</span>
<a href="#l9.369"></a><span id="l9.369" class="difflineplus">+              tokensLeft++; // don't eat a token for this pass</span>
<a href="#l9.370"></a><span id="l9.370">               break;</span>
<a href="#l9.371"></a><span id="l9.371" class="difflineplus">+            case this.kWorkDoneWithResult:</span>
<a href="#l9.372"></a><span id="l9.372" class="difflineplus">+              data = this._callbackHandler.popWithResult();</span>
<a href="#l9.373"></a><span id="l9.373" class="difflineplus">+              tokensLeft++; // don't eat a token for this pass</span>
<a href="#l9.374"></a><span id="l9.374" class="difflineplus">+              continue;</span>
<a href="#l9.375"></a><span id="l9.375">           }</span>
<a href="#l9.376"></a><span id="l9.376">         }</span>
<a href="#l9.377"></a><span id="l9.377">         catch (ex) {</span>
<a href="#l9.378"></a><span id="l9.378">           this._log.debug(&quot;Bailing on job (at &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l9.379"></a><span id="l9.379">               ex.lineNumber + &quot;) because: &quot; + ex);</span>
<a href="#l9.380"></a><span id="l9.380">           this._indexerLeaveFolder(true);</span>
<a href="#l9.381"></a><span id="l9.381">           this._curIndexingJob = null;</span>
<a href="#l9.382"></a><span id="l9.382" class="difflineminus">-          if (this._actualWorker !== null) {</span>
<a href="#l9.383"></a><span id="l9.383" class="difflineminus">-            this._actualWorker.close();</span>
<a href="#l9.384"></a><span id="l9.384" class="difflineminus">-            this._actualWorker = null;</span>
<a href="#l9.385"></a><span id="l9.385" class="difflineminus">-          }</span>
<a href="#l9.386"></a><span id="l9.386" class="difflineplus">+          this._callbackHandle.cleanup();</span>
<a href="#l9.387"></a><span id="l9.387">         }</span>
<a href="#l9.388"></a><span id="l9.388">       }</span>
<a href="#l9.389"></a><span id="l9.389">       </span>
<a href="#l9.390"></a><span id="l9.390">       // take a breather by having the caller re-schedule us sometime in the</span>
<a href="#l9.391"></a><span id="l9.391">       //  future, but only if we're going to perform another loop iteration.</span>
<a href="#l9.392"></a><span id="l9.392">       if (commitTokens &gt; 0)</span>
<a href="#l9.393"></a><span id="l9.393">         yield this.kWorkPause;</span>
<a href="#l9.394"></a><span id="l9.394">     }</span>
<a href="#l9.395"></a><span id="l9.395" class="difflineat">@@ -997,43 +1099,48 @@ var GlodaIndexer = {</span>
<a href="#l9.396"></a><span id="l9.396">     //                this._indexQueue.length);</span>
<a href="#l9.397"></a><span id="l9.397">     let job = this._curIndexingJob = this._indexQueue.shift();</span>
<a href="#l9.398"></a><span id="l9.398">     this._indexingJobCount++;</span>
<a href="#l9.399"></a><span id="l9.399">     //this._log.debug(&quot;++ Pulled job: &quot; + job.jobType + &quot;, &quot; +</span>
<a href="#l9.400"></a><span id="l9.400">     //                job.deltaType + &quot;, &quot; + job.id);</span>
<a href="#l9.401"></a><span id="l9.401">     let generator = null;</span>
<a href="#l9.402"></a><span id="l9.402">     </span>
<a href="#l9.403"></a><span id="l9.403">     if (job.jobType == &quot;sweep&quot;) {</span>
<a href="#l9.404"></a><span id="l9.404" class="difflineminus">-      this._actualWorker = this._worker_indexingSweep(job);</span>
<a href="#l9.405"></a><span id="l9.405" class="difflineplus">+      generator = this._worker_indexingSweep(job);</span>
<a href="#l9.406"></a><span id="l9.406">     }</span>
<a href="#l9.407"></a><span id="l9.407">     else if (job.jobType == &quot;folder&quot;) {</span>
<a href="#l9.408"></a><span id="l9.408" class="difflineminus">-      this._actualWorker = this._worker_folderIndex(job);</span>
<a href="#l9.409"></a><span id="l9.409" class="difflineplus">+      generator = this._worker_folderIndex(job);</span>
<a href="#l9.410"></a><span id="l9.410">     }</span>
<a href="#l9.411"></a><span id="l9.411">     else if(job.jobType == &quot;message&quot;) {</span>
<a href="#l9.412"></a><span id="l9.412">       if (job === this._pendingAddJob)</span>
<a href="#l9.413"></a><span id="l9.413">         this._pendingAddJob = null;</span>
<a href="#l9.414"></a><span id="l9.414">       // update our goal from the items length</span>
<a href="#l9.415"></a><span id="l9.415">       job.goal = job.items.length;</span>
<a href="#l9.416"></a><span id="l9.416">                   </span>
<a href="#l9.417"></a><span id="l9.417" class="difflineminus">-      this._actualWorker = this._worker_messageIndex(job);</span>
<a href="#l9.418"></a><span id="l9.418" class="difflineplus">+      generator = this._worker_messageIndex(job);</span>
<a href="#l9.419"></a><span id="l9.419">     }</span>
<a href="#l9.420"></a><span id="l9.420">     else if (job.jobType == &quot;delete&quot;) {</span>
<a href="#l9.421"></a><span id="l9.421">       // we'll count the block processing as a cost of 1...</span>
<a href="#l9.422"></a><span id="l9.422">       job.goal = 1;</span>
<a href="#l9.423"></a><span id="l9.423" class="difflineminus">-      this._actualWorker = this._worker_processDeletes(job);</span>
<a href="#l9.424"></a><span id="l9.424" class="difflineplus">+      generator = this._worker_processDeletes(job);</span>
<a href="#l9.425"></a><span id="l9.425">     }</span>
<a href="#l9.426"></a><span id="l9.426">     else if (job.jobType in this._otherIndexerWorkers) {</span>
<a href="#l9.427"></a><span id="l9.427">       let [indexer, workerFunc] = this._otherIndexerWorkers[job.jobType];</span>
<a href="#l9.428"></a><span id="l9.428" class="difflineminus">-      this._actualWorker = workerFunc.call(indexer, job);</span>
<a href="#l9.429"></a><span id="l9.429" class="difflineplus">+      generator = workerFunc.call(indexer, job);</span>
<a href="#l9.430"></a><span id="l9.430">     }</span>
<a href="#l9.431"></a><span id="l9.431">     else {</span>
<a href="#l9.432"></a><span id="l9.432">       this._log.warning(&quot;Unknown job type: &quot; + job.jobType);</span>
<a href="#l9.433"></a><span id="l9.433">     }</span>
<a href="#l9.434"></a><span id="l9.434">     </span>
<a href="#l9.435"></a><span id="l9.435" class="difflineminus">-    return true;</span>
<a href="#l9.436"></a><span id="l9.436" class="difflineplus">+    if (generator) {</span>
<a href="#l9.437"></a><span id="l9.437" class="difflineplus">+      this._callbackHandle.push(generator);</span>
<a href="#l9.438"></a><span id="l9.438" class="difflineplus">+      return true;</span>
<a href="#l9.439"></a><span id="l9.439" class="difflineplus">+    }</span>
<a href="#l9.440"></a><span id="l9.440" class="difflineplus">+    else</span>
<a href="#l9.441"></a><span id="l9.441" class="difflineplus">+      return false;</span>
<a href="#l9.442"></a><span id="l9.442">   },</span>
<a href="#l9.443"></a><span id="l9.443"> </span>
<a href="#l9.444"></a><span id="l9.444">   /**</span>
<a href="#l9.445"></a><span id="l9.445">    * Performs the folder sweep, locating folders that should be indexed, and</span>
<a href="#l9.446"></a><span id="l9.446">    *  creating a folder indexing job for them, and rescheduling itself for</span>
<a href="#l9.447"></a><span id="l9.447">    *  execution after that job is completed.  Once it indexes all the folders,</span>
<a href="#l9.448"></a><span id="l9.448">    *  if we believe we have deletions to process (or just don't know), it kicks</span>
<a href="#l9.449"></a><span id="l9.449">    *  off a deletion processing job.</span>
<a href="#l9.450"></a><span id="l9.450" class="difflineat">@@ -1072,39 +1179,32 @@ var GlodaIndexer = {</span>
<a href="#l9.451"></a><span id="l9.451">       let numFolders = allFolders.Count();</span>
<a href="#l9.452"></a><span id="l9.452">       for (let folderIndex = 0; folderIndex &lt; numFolders; folderIndex++)</span>
<a href="#l9.453"></a><span id="l9.453">       {</span>
<a href="#l9.454"></a><span id="l9.454">         let folder = allFolders.GetElementAt(folderIndex).QueryInterface(</span>
<a href="#l9.455"></a><span id="l9.455">                                                             Ci.nsIMsgFolder);</span>
<a href="#l9.456"></a><span id="l9.456">         // we could also check nsMsgFolderFlags.Mail conceivably...</span>
<a href="#l9.457"></a><span id="l9.457">         let isLocal = folder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l9.458"></a><span id="l9.458">         // we only index local folders or IMAP folders that are marked offline.</span>
<a href="#l9.459"></a><span id="l9.459" class="difflineminus">-        if (!isLocal &amp;&amp; !(folder.flags&amp;Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l9.460"></a><span id="l9.460" class="difflineplus">+        if (!isLocal &amp;&amp; !(folder.flags &amp; Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l9.461"></a><span id="l9.461">           continue;</span>
<a href="#l9.462"></a><span id="l9.462"> </span>
<a href="#l9.463"></a><span id="l9.463">         // if no folder was indexed (or the pref's not set), just use the first folder</span>
<a href="#l9.464"></a><span id="l9.464">         if (!aJob.lastFolderIndexedUri || useNextFolder)</span>
<a href="#l9.465"></a><span id="l9.465">         {</span>
<a href="#l9.466"></a><span id="l9.466">           // make sure the folder is dirty before accepting this job...</span>
<a href="#l9.467"></a><span id="l9.467" class="difflineminus">-          let isDirty = true;</span>
<a href="#l9.468"></a><span id="l9.468" class="difflineminus">-          try {</span>
<a href="#l9.469"></a><span id="l9.469" class="difflineminus">-            isDirty = folder.GetStringProperty(this.GLODA_DIRTY_PROPERTY) !=</span>
<a href="#l9.470"></a><span id="l9.470" class="difflineminus">-                        &quot;0&quot;; </span>
<a href="#l9.471"></a><span id="l9.471" class="difflineminus">-          }</span>
<a href="#l9.472"></a><span id="l9.472" class="difflineminus">-          catch (ex) {}</span>
<a href="#l9.473"></a><span id="l9.473" class="difflineminus">-          </span>
<a href="#l9.474"></a><span id="l9.474" class="difflineminus">-          if (!isDirty) {</span>
<a href="#l9.475"></a><span id="l9.475" class="difflineminus">-            continue; </span>
<a href="#l9.476"></a><span id="l9.476" class="difflineminus">-          }</span>
<a href="#l9.477"></a><span id="l9.477" class="difflineplus">+          let glodaFolder = GlodaDatastore._mapFolder(folder);</span>
<a href="#l9.478"></a><span id="l9.478" class="difflineplus">+          if (!glodaFolder.dirtyStatus)</span>
<a href="#l9.479"></a><span id="l9.479" class="difflineplus">+            continue;</span>
<a href="#l9.480"></a><span id="l9.480">         </span>
<a href="#l9.481"></a><span id="l9.481">           aJob.lastFolderIndexedUri = folder.URI;</span>
<a href="#l9.482"></a><span id="l9.482">           this._indexingJobGoal += 2;</span>
<a href="#l9.483"></a><span id="l9.483">           // add a job for the folder indexing</span>
<a href="#l9.484"></a><span id="l9.484">           this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 0,</span>
<a href="#l9.485"></a><span id="l9.485" class="difflineminus">-              this._datastore._mapFolderURI(aJob.lastFolderIndexedUri)));</span>
<a href="#l9.486"></a><span id="l9.486" class="difflineplus">+              this._datastore._mapFolder(folder).id));</span>
<a href="#l9.487"></a><span id="l9.487">           // re-schedule this job (although this worker will die)</span>
<a href="#l9.488"></a><span id="l9.488">           this._indexQueue.push(aJob);</span>
<a href="#l9.489"></a><span id="l9.489">           yield this.kWorkDone;</span>
<a href="#l9.490"></a><span id="l9.490">         }</span>
<a href="#l9.491"></a><span id="l9.491">         else</span>
<a href="#l9.492"></a><span id="l9.492">         {</span>
<a href="#l9.493"></a><span id="l9.493">           if (aJob.lastFolderIndexedUri == folder.URI)</span>
<a href="#l9.494"></a><span id="l9.494">             useNextFolder = true;</span>
<a href="#l9.495"></a><span id="l9.495" class="difflineat">@@ -1151,45 +1251,80 @@ var GlodaIndexer = {</span>
<a href="#l9.496"></a><span id="l9.496">     </span>
<a href="#l9.497"></a><span id="l9.497">     // there is of course a cost to all this header investigation even if we</span>
<a href="#l9.498"></a><span id="l9.498">     //  don't do something.  so we will yield with kWorkSync for every block. </span>
<a href="#l9.499"></a><span id="l9.499">     const HEADER_CHECK_BLOCK_SIZE = 100;</span>
<a href="#l9.500"></a><span id="l9.500">     </span>
<a href="#l9.501"></a><span id="l9.501">     let isLocal = this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l9.502"></a><span id="l9.502">     // we can safely presume if we are here that this folder has been selected</span>
<a href="#l9.503"></a><span id="l9.503">     //  for offline processing...</span>
<a href="#l9.504"></a><span id="l9.504" class="difflineplus">+</span>
<a href="#l9.505"></a><span id="l9.505" class="difflineplus">+    // Handle the filthy case.  A filthy folder may have misleading properties</span>
<a href="#l9.506"></a><span id="l9.506" class="difflineplus">+    //  on the message that claim the message is indexed.  They are misleading</span>
<a href="#l9.507"></a><span id="l9.507" class="difflineplus">+    //  because the database, for whatever reason, does not have the messages</span>
<a href="#l9.508"></a><span id="l9.508" class="difflineplus">+    //  (accurately) indexed.</span>
<a href="#l9.509"></a><span id="l9.509" class="difflineplus">+    // We need to walk all the messages and mark them filthy if they have a</span>
<a href="#l9.510"></a><span id="l9.510" class="difflineplus">+    //  dirty property.  Once we have done this, we can downgrade the folder's</span>
<a href="#l9.511"></a><span id="l9.511" class="difflineplus">+    //  dirty status to plain dirty.  We do this rather than trying to process</span>
<a href="#l9.512"></a><span id="l9.512" class="difflineplus">+    //  everyone in one go in a filthy context because if we have to terminate</span>
<a href="#l9.513"></a><span id="l9.513" class="difflineplus">+    //  indexing before we quit, we don't want to have to re-index messages next</span>
<a href="#l9.514"></a><span id="l9.514" class="difflineplus">+    //  time.  (This could even lead to never completing indexing in a</span>
<a href="#l9.515"></a><span id="l9.515" class="difflineplus">+    //  pathological situation.)</span>
<a href="#l9.516"></a><span id="l9.516" class="difflineplus">+    let glodaFolder = GlodaDatastore._mapFolder(this._indexingFolder);</span>
<a href="#l9.517"></a><span id="l9.517" class="difflineplus">+    if (glodaFolder.dirtyStatus == glodaFolder.kFolderFilthy) {</span>
<a href="#l9.518"></a><span id="l9.518" class="difflineplus">+      let count = 0;</span>
<a href="#l9.519"></a><span id="l9.519" class="difflineplus">+      for (let msgHdr in this._indexingIterator) {</span>
<a href="#l9.520"></a><span id="l9.520" class="difflineplus">+        // we still need to avoid locking up the UI, pause periodically...</span>
<a href="#l9.521"></a><span id="l9.521" class="difflineplus">+        if (++count % HEADER_CHECK_BLOCK_SIZE == 0)</span>
<a href="#l9.522"></a><span id="l9.522" class="difflineplus">+          yield this.kWorkSync;</span>
<a href="#l9.523"></a><span id="l9.523" class="difflineplus">+        </span>
<a href="#l9.524"></a><span id="l9.524" class="difflineplus">+        let glodaMessageId = msgHdr.getUint32Property(</span>
<a href="#l9.525"></a><span id="l9.525" class="difflineplus">+                             this.GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l9.526"></a><span id="l9.526" class="difflineplus">+        // if it has a gloda message id, we need to mark it filthy</span>
<a href="#l9.527"></a><span id="l9.527" class="difflineplus">+        if (glodaMessageId != 0)</span>
<a href="#l9.528"></a><span id="l9.528" class="difflineplus">+          msgHdr.setUint32Property(this.GLODA_DIRTY_PROPERTY,</span>
<a href="#l9.529"></a><span id="l9.529" class="difflineplus">+                                   this.kMessageFilthy);</span>
<a href="#l9.530"></a><span id="l9.530" class="difflineplus">+        // if it doesn't have a gloda message id, we will definitely index it,</span>
<a href="#l9.531"></a><span id="l9.531" class="difflineplus">+        //  so no action is required.</span>
<a href="#l9.532"></a><span id="l9.532" class="difflineplus">+      }</span>
<a href="#l9.533"></a><span id="l9.533" class="difflineplus">+      // this will automatically persist to the database</span>
<a href="#l9.534"></a><span id="l9.534" class="difflineplus">+      glodaFolder.dirtyStatus = glodaFolder.kFolderDirty;</span>
<a href="#l9.535"></a><span id="l9.535" class="difflineplus">+      </span>
<a href="#l9.536"></a><span id="l9.536" class="difflineplus">+      // We used up the iterator, get a new one.</span>
<a href="#l9.537"></a><span id="l9.537" class="difflineplus">+      this._indexerGetIterator();</span>
<a href="#l9.538"></a><span id="l9.538" class="difflineplus">+    }</span>
<a href="#l9.539"></a><span id="l9.539">     </span>
<a href="#l9.540"></a><span id="l9.540">     for (let msgHdr in this._indexingIterator) {</span>
<a href="#l9.541"></a><span id="l9.541">       // per above, we want to periodically release control while doing all</span>
<a href="#l9.542"></a><span id="l9.542">       //  this header traversal/investigation.</span>
<a href="#l9.543"></a><span id="l9.543">       if (++aJob.offset % HEADER_CHECK_BLOCK_SIZE == 0)</span>
<a href="#l9.544"></a><span id="l9.544">         yield this.kWorkSync;</span>
<a href="#l9.545"></a><span id="l9.545">       </span>
<a href="#l9.546"></a><span id="l9.546" class="difflineminus">-      if ((isLocal || msgHdr.flags&amp;MSG_FLAG_OFFLINE) &amp;&amp;</span>
<a href="#l9.547"></a><span id="l9.547" class="difflineminus">-          !(msgHdr.flags&amp;MSG_FLAG_EXPUNGED)) {</span>
<a href="#l9.548"></a><span id="l9.548" class="difflineplus">+      if ((isLocal || (msgHdr.flags &amp; MSG_FLAG_OFFLINE)) &amp;&amp;</span>
<a href="#l9.549"></a><span id="l9.549" class="difflineplus">+          !(msgHdr.flags &amp; MSG_FLAG_EXPUNGED)) {</span>
<a href="#l9.550"></a><span id="l9.550">         // this returns 0 when missing</span>
<a href="#l9.551"></a><span id="l9.551">         let glodaMessageId = msgHdr.getUint32Property(</span>
<a href="#l9.552"></a><span id="l9.552">                              this.GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l9.553"></a><span id="l9.553">         </span>
<a href="#l9.554"></a><span id="l9.554">         // if it has a gloda message id, it has been indexed, but it still</span>
<a href="#l9.555"></a><span id="l9.555">         //  could be dirty.</span>
<a href="#l9.556"></a><span id="l9.556">         if (glodaMessageId != 0) {</span>
<a href="#l9.557"></a><span id="l9.557">           // (returns 0 when missing)</span>
<a href="#l9.558"></a><span id="l9.558">           let isDirty = msgHdr.getUint32Property(this.GLODA_DIRTY_PROPERTY)!= 0;</span>
<a href="#l9.559"></a><span id="l9.559"> </span>
<a href="#l9.560"></a><span id="l9.560">           // it's up to date if it's not dirty </span>
<a href="#l9.561"></a><span id="l9.561">           if (!isDirty)</span>
<a href="#l9.562"></a><span id="l9.562">             continue;</span>
<a href="#l9.563"></a><span id="l9.563">         }</span>
<a href="#l9.564"></a><span id="l9.564">         </span>
<a href="#l9.565"></a><span id="l9.565" class="difflineminus">-        yield this._indexMessage(msgHdr);</span>
<a href="#l9.566"></a><span id="l9.566" class="difflineplus">+        yield this._callbackHandle.pushAndGo(this._indexMessage(msgHdr));</span>
<a href="#l9.567"></a><span id="l9.567">       }</span>
<a href="#l9.568"></a><span id="l9.568">     }</span>
<a href="#l9.569"></a><span id="l9.569">     </span>
<a href="#l9.570"></a><span id="l9.570" class="difflineminus">-    this._indexingFolder.setStringProperty(this.GLODA_DIRTY_PROPERTY, &quot;0&quot;);</span>
<a href="#l9.571"></a><span id="l9.571" class="difflineplus">+    glodaFolder.dirtyStatus = glodaFolder.kFolderClean;</span>
<a href="#l9.572"></a><span id="l9.572">     </span>
<a href="#l9.573"></a><span id="l9.573">     // by definition, it's not likely we'll visit this folder again anytime soon</span>
<a href="#l9.574"></a><span id="l9.574">     this._indexerLeaveFolder();</span>
<a href="#l9.575"></a><span id="l9.575">     </span>
<a href="#l9.576"></a><span id="l9.576">     yield this.kWorkDone;</span>
<a href="#l9.577"></a><span id="l9.577">   },</span>
<a href="#l9.578"></a><span id="l9.578">   </span>
<a href="#l9.579"></a><span id="l9.579">   /**</span>
<a href="#l9.580"></a><span id="l9.580" class="difflineat">@@ -1276,17 +1411,17 @@ var GlodaIndexer = {</span>
<a href="#l9.581"></a><span id="l9.581">   indexAccount: function glodaIndexAccount(aAccount) {</span>
<a href="#l9.582"></a><span id="l9.582">     let rootFolder = aAccount.incomingServer.rootFolder;</span>
<a href="#l9.583"></a><span id="l9.583">     if (rootFolder instanceof Ci.nsIMsgFolder) {</span>
<a href="#l9.584"></a><span id="l9.584">       this._log.info(&quot;Queueing account folders for indexing: &quot; + aAccount.key);</span>
<a href="#l9.585"></a><span id="l9.585"> </span>
<a href="#l9.586"></a><span id="l9.586">       GlodaDatastore._beginTransaction();</span>
<a href="#l9.587"></a><span id="l9.587">       let folderJobs =</span>
<a href="#l9.588"></a><span id="l9.588">               [new IndexingJob(&quot;folder&quot;, 1,</span>
<a href="#l9.589"></a><span id="l9.589" class="difflineminus">-                              GlodaDatastore._mapFolderURI(folder.URI)) for each</span>
<a href="#l9.590"></a><span id="l9.590" class="difflineplus">+                               GlodaDatastore._mapFolder(folder).id) for each</span>
<a href="#l9.591"></a><span id="l9.591">               (folder in fixIterator(rootFolder.subFolders, Ci.nsIMsgFolder))];</span>
<a href="#l9.592"></a><span id="l9.592">       GlodaDatastore._commitTransaction();</span>
<a href="#l9.593"></a><span id="l9.593">       </span>
<a href="#l9.594"></a><span id="l9.594">       this._indexingJobGoal += folderJobs.length;</span>
<a href="#l9.595"></a><span id="l9.595">       this._indexQueue = this._indexQueue.concat(folderJobs);</span>
<a href="#l9.596"></a><span id="l9.596">       this.indexing = true;</span>
<a href="#l9.597"></a><span id="l9.597">     }</span>
<a href="#l9.598"></a><span id="l9.598">     else {</span>
<a href="#l9.599"></a><span id="l9.599" class="difflineat">@@ -1296,43 +1431,29 @@ var GlodaIndexer = {</span>
<a href="#l9.600"></a><span id="l9.600"> </span>
<a href="#l9.601"></a><span id="l9.601">   /**</span>
<a href="#l9.602"></a><span id="l9.602">    * Queue a single folder for indexing given an nsIMsgFolder.</span>
<a href="#l9.603"></a><span id="l9.603">    */</span>
<a href="#l9.604"></a><span id="l9.604">   indexFolder: function glodaIndexFolder(aFolder) {</span>
<a href="#l9.605"></a><span id="l9.605">     this._log.info(&quot;Queue-ing folder for indexing: &quot; + aFolder.prettiestName);</span>
<a href="#l9.606"></a><span id="l9.606">     </span>
<a href="#l9.607"></a><span id="l9.607">     this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 1,</span>
<a href="#l9.608"></a><span id="l9.608" class="difflineminus">-                          GlodaDatastore._mapFolderURI(aFolder.URI)));</span>
<a href="#l9.609"></a><span id="l9.609" class="difflineplus">+                          GlodaDatastore._mapFolder(aFolder).id));</span>
<a href="#l9.610"></a><span id="l9.610">     this._indexingJobGoal++;</span>
<a href="#l9.611"></a><span id="l9.611">     this.indexing = true;</span>
<a href="#l9.612"></a><span id="l9.612">   },</span>
<a href="#l9.613"></a><span id="l9.613" class="difflineminus">-</span>
<a href="#l9.614"></a><span id="l9.614" class="difflineminus">-  /**</span>
<a href="#l9.615"></a><span id="l9.615" class="difflineminus">-   * Queue a single folder for indexing given its URI.</span>
<a href="#l9.616"></a><span id="l9.616" class="difflineminus">-   */</span>
<a href="#l9.617"></a><span id="l9.617" class="difflineminus">-  indexFolderByURI: function gloda_index_indexFolderByURI(aURI) {</span>
<a href="#l9.618"></a><span id="l9.618" class="difflineminus">-    if (aURI !== null) {</span>
<a href="#l9.619"></a><span id="l9.619" class="difflineminus">-      this._log.info(&quot;Queue-ing folder URI for indexing: &quot; + aURI);</span>
<a href="#l9.620"></a><span id="l9.620" class="difflineminus">-      </span>
<a href="#l9.621"></a><span id="l9.621" class="difflineminus">-      this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 1,</span>
<a href="#l9.622"></a><span id="l9.622" class="difflineminus">-                            GlodaDatastore._mapFolderURI(aURI)));</span>
<a href="#l9.623"></a><span id="l9.623" class="difflineminus">-      this._indexingJobGoal++;</span>
<a href="#l9.624"></a><span id="l9.624" class="difflineminus">-      this.indexing = true;</span>
<a href="#l9.625"></a><span id="l9.625" class="difflineminus">-    }</span>
<a href="#l9.626"></a><span id="l9.626" class="difflineminus">-  },</span>
<a href="#l9.627"></a><span id="l9.627">   </span>
<a href="#l9.628"></a><span id="l9.628">   /**</span>
<a href="#l9.629"></a><span id="l9.629">    * Queue a list of messages for indexing.</span>
<a href="#l9.630"></a><span id="l9.630">    *</span>
<a href="#l9.631"></a><span id="l9.631">    * @param aFoldersAndMessages List of [nsIMsgFolder, message key] tuples.</span>
<a href="#l9.632"></a><span id="l9.632">    */</span>
<a href="#l9.633"></a><span id="l9.633">   indexMessages: function gloda_index_indexMessages(aFoldersAndMessages) {</span>
<a href="#l9.634"></a><span id="l9.634">     let job = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l9.635"></a><span id="l9.635" class="difflineminus">-    job.items = [[GlodaDatastore._mapFolderURI(fm[0].URI), fm[1]] for each</span>
<a href="#l9.636"></a><span id="l9.636" class="difflineplus">+    job.items = [[GlodaDatastore._mapFolder(fm[0]).id, fm[1]] for each</span>
<a href="#l9.637"></a><span id="l9.637">                  ([i, fm] in Iterator(aFoldersAndMessages))];</span>
<a href="#l9.638"></a><span id="l9.638">     this._indexQueue.push(job);</span>
<a href="#l9.639"></a><span id="l9.639">     this._indexingJobGoal++;</span>
<a href="#l9.640"></a><span id="l9.640">     this.indexing = true;</span>
<a href="#l9.641"></a><span id="l9.641">   },</span>
<a href="#l9.642"></a><span id="l9.642">   </span>
<a href="#l9.643"></a><span id="l9.643">   /* *********** Event Processing *********** */</span>
<a href="#l9.644"></a><span id="l9.644">   observe: function gloda_indexer_observe(aSubject, aTopic, aData) {</span>
<a href="#l9.645"></a><span id="l9.645" class="difflineat">@@ -1421,17 +1542,17 @@ var GlodaIndexer = {</span>
<a href="#l9.646"></a><span id="l9.646">         this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l9.647"></a><span id="l9.647">         this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l9.648"></a><span id="l9.648">         this.indexer._indexingJobGoal++;</span>
<a href="#l9.649"></a><span id="l9.649">       }</span>
<a href="#l9.650"></a><span id="l9.650">       // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l9.651"></a><span id="l9.651">       if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l9.652"></a><span id="l9.652">           this.indexer._indexMaxEventQueueMessages) {</span>
<a href="#l9.653"></a><span id="l9.653">         this.indexer._pendingAddJob.items.push(</span>
<a href="#l9.654"></a><span id="l9.654" class="difflineminus">-          [GlodaDatastore._mapFolderURI(aMsgHdr.folder.URI),</span>
<a href="#l9.655"></a><span id="l9.655" class="difflineplus">+          [GlodaDatastore._mapFolder(aMsgHdr.folder).id,</span>
<a href="#l9.656"></a><span id="l9.656">            aMsgHdr.messageKey]);</span>
<a href="#l9.657"></a><span id="l9.657">         this.indexer.indexing = true;</span>
<a href="#l9.658"></a><span id="l9.658">         this.indexer._log.debug(&quot;msgAdded notification, event indexing&quot;);</span>
<a href="#l9.659"></a><span id="l9.659">       }</span>
<a href="#l9.660"></a><span id="l9.660">       else {</span>
<a href="#l9.661"></a><span id="l9.661">         this.indexer.indexingSweepNeeded = true;</span>
<a href="#l9.662"></a><span id="l9.662">         this.indexer._log.debug(&quot;msgAdded notification, sweep indexing&quot;);</span>
<a href="#l9.663"></a><span id="l9.663">       }</span>
<a href="#l9.664"></a><span id="l9.664" class="difflineat">@@ -1532,17 +1653,17 @@ var GlodaIndexer = {</span>
<a href="#l9.665"></a><span id="l9.665">                 //  required.</span>
<a href="#l9.666"></a><span id="l9.666">                 catch (ex) {}</span>
<a href="#l9.667"></a><span id="l9.667">               }</span>
<a href="#l9.668"></a><span id="l9.668">             }</span>
<a href="#l9.669"></a><span id="l9.669">             </span>
<a href="#l9.670"></a><span id="l9.670">             // this method takes care to update the in-memory representations</span>
<a href="#l9.671"></a><span id="l9.671">             //  too; we don't need to do anything</span>
<a href="#l9.672"></a><span id="l9.672">             this.indexer._datastore.updateMessageLocations(glodaIds,</span>
<a href="#l9.673"></a><span id="l9.673" class="difflineminus">-              newMessageKeys, aDestFolder.URI);</span>
<a href="#l9.674"></a><span id="l9.674" class="difflineplus">+              newMessageKeys, aDestFolder);</span>
<a href="#l9.675"></a><span id="l9.675">           }</span>
<a href="#l9.676"></a><span id="l9.676">           // target is IMAP or something we equally don't understand</span>
<a href="#l9.677"></a><span id="l9.677">           else {</span>
<a href="#l9.678"></a><span id="l9.678">             // XXX the srcFolder will always be the same for now, but we</span>
<a href="#l9.679"></a><span id="l9.679">             //  probably don't want to depend on it, or at least want a unit</span>
<a href="#l9.680"></a><span id="l9.680">             //  test that will break if it changes...</span>
<a href="#l9.681"></a><span id="l9.681">             let srcFolder = aSrcMsgHdrs.queryElementAt(0,Ci.nsIMsgDBHdr).folder;</span>
<a href="#l9.682"></a><span id="l9.682">     </span>
<a href="#l9.683"></a><span id="l9.683" class="difflineat">@@ -1551,17 +1672,17 @@ var GlodaIndexer = {</span>
<a href="#l9.684"></a><span id="l9.684">             let messageKeys = [];</span>
<a href="#l9.685"></a><span id="l9.685">             for (let iMsgHdr = 0; iMsgHdr &lt; aSrcMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l9.686"></a><span id="l9.686">               let msgHdr = aSrcMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l9.687"></a><span id="l9.687">               messageKeys.push(msgHdr.messageKey);</span>
<a href="#l9.688"></a><span id="l9.688">             }</span>
<a href="#l9.689"></a><span id="l9.689">             // XXX we could extract the gloda message id's instead.</span>
<a href="#l9.690"></a><span id="l9.690">             // quickly move them to the right folder, zeroing their message keys</span>
<a href="#l9.691"></a><span id="l9.691">             this.indexer._datastore.updateMessageFoldersByKeyPurging(</span>
<a href="#l9.692"></a><span id="l9.692" class="difflineminus">-              srcFolder.URI, messageKeys, aDestFolder.URI);</span>
<a href="#l9.693"></a><span id="l9.693" class="difflineplus">+              srcFolder, messageKeys, aDestFolder);</span>
<a href="#l9.694"></a><span id="l9.694">             // we _do not_ need to mark the folder as dirty, because the</span>
<a href="#l9.695"></a><span id="l9.695">             //  message added events will cause that to happen.</span>
<a href="#l9.696"></a><span id="l9.696">           }</span>
<a href="#l9.697"></a><span id="l9.697">         }</span>
<a href="#l9.698"></a><span id="l9.698">        // copy case</span>
<a href="#l9.699"></a><span id="l9.699">         else {</span>
<a href="#l9.700"></a><span id="l9.700">           // mark the folder as dirty; we'll get to it later.</span>
<a href="#l9.701"></a><span id="l9.701">           aDestFolder.setStringProperty(this.indexer.GLODA_DIRTY_PROPERTY, &quot;1&quot;);</span>
<a href="#l9.702"></a><span id="l9.702" class="difflineat">@@ -1582,21 +1703,20 @@ var GlodaIndexer = {</span>
<a href="#l9.703"></a><span id="l9.703">      *  underlying account implementation, so we explicitly handle each case.</span>
<a href="#l9.704"></a><span id="l9.704">      *  Namely, we treat it as if we're only planning on getting one, but we</span>
<a href="#l9.705"></a><span id="l9.705">      *  handle if the children are already gone for some reason.</span>
<a href="#l9.706"></a><span id="l9.706">      */</span>
<a href="#l9.707"></a><span id="l9.707">     folderDeleted: function gloda_indexer_folderDeleted(aFolder) {</span>
<a href="#l9.708"></a><span id="l9.708">       this.indexer._log.debug(&quot;folderDeleted notification&quot;);</span>
<a href="#l9.709"></a><span id="l9.709">       </span>
<a href="#l9.710"></a><span id="l9.710">       delFunc = function(folder) {</span>
<a href="#l9.711"></a><span id="l9.711" class="difflineminus">-        let folderURI = aFolder.URI;</span>
<a href="#l9.712"></a><span id="l9.712" class="difflineminus">-        if (this._datastore._folderURIKnown(aFolder.URI)) {</span>
<a href="#l9.713"></a><span id="l9.713" class="difflineminus">-          let folderID = GlodaDatastore._mapFolderURI(aFolder.URI);</span>
<a href="#l9.714"></a><span id="l9.714" class="difflineminus">-          this._datastore.markMessagesDeletedByID(folderID);</span>
<a href="#l9.715"></a><span id="l9.715" class="difflineminus">-          this._datastore.deleteFolderByID(folderID);</span>
<a href="#l9.716"></a><span id="l9.716" class="difflineplus">+        if (this._datastore._folderKnown(aFolder)) {</span>
<a href="#l9.717"></a><span id="l9.717" class="difflineplus">+          let folder = GlodaDatastore._mapFolder(aFolder);</span>
<a href="#l9.718"></a><span id="l9.718" class="difflineplus">+          this._datastore.markMessagesDeletedByID(folder.id);</span>
<a href="#l9.719"></a><span id="l9.719" class="difflineplus">+          this._datastore.deleteFolderByID(folder.id);</span>
<a href="#l9.720"></a><span id="l9.720">         }</span>
<a href="#l9.721"></a><span id="l9.721">       };</span>
<a href="#l9.722"></a><span id="l9.722"> </span>
<a href="#l9.723"></a><span id="l9.723">       let descendentFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l9.724"></a><span id="l9.724">                                 createInstance(Ci.nsISupportsArray);</span>
<a href="#l9.725"></a><span id="l9.725">       aFolder.ListDescendents(descendentFolders);</span>
<a href="#l9.726"></a><span id="l9.726">       </span>
<a href="#l9.727"></a><span id="l9.727">       // (the order of operations does not matter; child, non-child, whatever.)</span>
<a href="#l9.728"></a><span id="l9.728" class="difflineat">@@ -1642,17 +1762,17 @@ var GlodaIndexer = {</span>
<a href="#l9.729"></a><span id="l9.729">     _folderRenameHelper: function gloda_indexer_folderRenameHelper(aOrigFolder,</span>
<a href="#l9.730"></a><span id="l9.730">                                                                    aNewURI) {</span>
<a href="#l9.731"></a><span id="l9.731">       let descendentFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l9.732"></a><span id="l9.732">                                 createInstance(Ci.nsISupportsArray);</span>
<a href="#l9.733"></a><span id="l9.733">       aOrigFolder.ListDescendents(descendentFolders);</span>
<a href="#l9.734"></a><span id="l9.734">       </span>
<a href="#l9.735"></a><span id="l9.735">       let origURI = aOrigFolder.URI;</span>
<a href="#l9.736"></a><span id="l9.736">       // this rename is straightforward.</span>
<a href="#l9.737"></a><span id="l9.737" class="difflineminus">-      GlodaDatastore.renameFolder(origURI, aNewURI);</span>
<a href="#l9.738"></a><span id="l9.738" class="difflineplus">+      GlodaDatastore.renameFolder(aOrigFolder, aNewURI);</span>
<a href="#l9.739"></a><span id="l9.739">       </span>
<a href="#l9.740"></a><span id="l9.740">       for (let folder in fixIterator(descendentFolders, Ci.nsIMsgFolder)) {</span>
<a href="#l9.741"></a><span id="l9.741">         let oldSubURI = folder.URI;</span>
<a href="#l9.742"></a><span id="l9.742">         // mangle a new URI from the old URI.  we could also try and do a</span>
<a href="#l9.743"></a><span id="l9.743">         //  parallel traversal of the new folder hierarchy, but that seems like</span>
<a href="#l9.744"></a><span id="l9.744">         //  more work.</span>
<a href="#l9.745"></a><span id="l9.745">         let newSubURI = aNewURI + oldSubURI.substring(origURI.length)</span>
<a href="#l9.746"></a><span id="l9.746">         this.indexer._datastore.renameFolder(oldSubURI, newSubURI);</span>
<a href="#l9.747"></a><span id="l9.747" class="difflineat">@@ -1728,17 +1848,17 @@ var GlodaIndexer = {</span>
<a href="#l9.748"></a><span id="l9.748">         this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l9.749"></a><span id="l9.749">         this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l9.750"></a><span id="l9.750">         this.indexer._indexingJobGoal++;</span>
<a href="#l9.751"></a><span id="l9.751">       }</span>
<a href="#l9.752"></a><span id="l9.752">       // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l9.753"></a><span id="l9.753">       if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l9.754"></a><span id="l9.754">           this.indexer._indexMaxEventQueueMessages)</span>
<a href="#l9.755"></a><span id="l9.755">         this.indexer._pendingAddJob.items.push(</span>
<a href="#l9.756"></a><span id="l9.756" class="difflineminus">-          [GlodaDatastore._mapFolderURI(msgFolder.URI),</span>
<a href="#l9.757"></a><span id="l9.757" class="difflineplus">+          [GlodaDatastore._mapFolder(msgFolder).id,</span>
<a href="#l9.758"></a><span id="l9.758">            aMsgHdr.messageKey]);</span>
<a href="#l9.759"></a><span id="l9.759">       this.indexer.indexing = true;</span>
<a href="#l9.760"></a><span id="l9.760">     },</span>
<a href="#l9.761"></a><span id="l9.761">   </span>
<a href="#l9.762"></a><span id="l9.762">     OnItemAdded: function gloda_indexer_OnItemAdded(aParentItem, aItem) {</span>
<a href="#l9.763"></a><span id="l9.763">     },</span>
<a href="#l9.764"></a><span id="l9.764">     OnItemRemoved: function gloda_indexer_OnItemRemoved(aParentItem, aItem) {</span>
<a href="#l9.765"></a><span id="l9.765">     },</span>
<a href="#l9.766"></a><span id="l9.766" class="difflineat">@@ -1846,48 +1966,37 @@ var GlodaIndexer = {</span>
<a href="#l9.767"></a><span id="l9.767">       return !this.indexer._shutdown(aUrlListener);</span>
<a href="#l9.768"></a><span id="l9.768">     },</span>
<a href="#l9.769"></a><span id="l9.769">     </span>
<a href="#l9.770"></a><span id="l9.770">     getCurrentTaskName: function gloda_indexer_getCurrentTaskName() {</span>
<a href="#l9.771"></a><span id="l9.771">       return &quot;Global Database Indexer&quot;; // L10n-me</span>
<a href="#l9.772"></a><span id="l9.772">     },</span>
<a href="#l9.773"></a><span id="l9.773">   }, </span>
<a href="#l9.774"></a><span id="l9.774">   </span>
<a href="#l9.775"></a><span id="l9.775" class="difflineminus">-  _indexMessage: function gloda_indexMessage(aMsgHdr) {</span>
<a href="#l9.776"></a><span id="l9.776" class="difflineplus">+  _indexMessage: function gloda_indexMessage(aMsgHdr, aCallbackHandle) {</span>
<a href="#l9.777"></a><span id="l9.777">     this._log.debug(&quot;*** Indexing message: &quot; + aMsgHdr.messageKey + &quot; : &quot; +</span>
<a href="#l9.778"></a><span id="l9.778">                     aMsgHdr.subject);</span>
<a href="#l9.779"></a><span id="l9.779" class="difflineminus">-    MsgHdrToMimeMessage(aMsgHdr, this, this._indexMessageWithBody);</span>
<a href="#l9.780"></a><span id="l9.780" class="difflineminus">-    return this.kWorkAsync;</span>
<a href="#l9.781"></a><span id="l9.781" class="difflineminus">-  },</span>
<a href="#l9.782"></a><span id="l9.782" class="difflineminus">-  </span>
<a href="#l9.783"></a><span id="l9.783" class="difflineminus">-  _indexMessageWithBody: function gloda_index_indexMessageWithBody(</span>
<a href="#l9.784"></a><span id="l9.784" class="difflineminus">-       aMsgHdr, aMimeMsg) {</span>
<a href="#l9.785"></a><span id="l9.785" class="difflineplus">+    MsgHdrToMimeMessage(aMsgHdr, aCallbackHandle, aCallbackHandle.callback);</span>
<a href="#l9.786"></a><span id="l9.786" class="difflineplus">+    let aMimeMsg = yield this.kWorkAsync;</span>
<a href="#l9.787"></a><span id="l9.787"> </span>
<a href="#l9.788"></a><span id="l9.788">     // -- Find/create the conversation the message belongs to.</span>
<a href="#l9.789"></a><span id="l9.789">     // Our invariant is that all messages that exist in the database belong to</span>
<a href="#l9.790"></a><span id="l9.790">     //  a conversation.</span>
<a href="#l9.791"></a><span id="l9.791">     </span>
<a href="#l9.792"></a><span id="l9.792">     // - See if any of the ancestors exist and have a conversationID...</span>
<a href="#l9.793"></a><span id="l9.793">     // (references are ordered from old [0] to new [n-1])</span>
<a href="#l9.794"></a><span id="l9.794">     let references = [aMsgHdr.getStringReference(i) for each</span>
<a href="#l9.795"></a><span id="l9.795">                       (i in range(0, aMsgHdr.numReferences))];</span>
<a href="#l9.796"></a><span id="l9.796">     // also see if we already know about the message...</span>
<a href="#l9.797"></a><span id="l9.797">     references.push(aMsgHdr.messageId);</span>
<a href="#l9.798"></a><span id="l9.798">     </span>
<a href="#l9.799"></a><span id="l9.799" class="difflineminus">-    this._datastore.getMessagesByMessageID(references,</span>
<a href="#l9.800"></a><span id="l9.800" class="difflineminus">-      this._indexMessageWithBodyAndAncestors, this,</span>
<a href="#l9.801"></a><span id="l9.801" class="difflineminus">-      [references, aMsgHdr, aMimeMsg]);</span>
<a href="#l9.802"></a><span id="l9.802" class="difflineminus">-    </span>
<a href="#l9.803"></a><span id="l9.803" class="difflineminus">-    return this.kWorkAsync;</span>
<a href="#l9.804"></a><span id="l9.804" class="difflineminus">-  },</span>
<a href="#l9.805"></a><span id="l9.805" class="difflineminus">-  </span>
<a href="#l9.806"></a><span id="l9.806" class="difflineminus">-  _indexMessageWithBodyAndAncestors:</span>
<a href="#l9.807"></a><span id="l9.807" class="difflineminus">-    function gloda_index_indexMessageWithBodyAndAncestors(ancestorLists,</span>
<a href="#l9.808"></a><span id="l9.808" class="difflineminus">-      references, aMsgHdr, aMimeMsg) {</span>
<a href="#l9.809"></a><span id="l9.809" class="difflineplus">+    this._datastore.getMessagesByMessageID(references, aCallbackHandle.callback,</span>
<a href="#l9.810"></a><span id="l9.810" class="difflineplus">+      aCallbackHandle);</span>
<a href="#l9.811"></a><span id="l9.811">     // (ancestorLists has a direct correspondence to the message ids)</span>
<a href="#l9.812"></a><span id="l9.812" class="difflineplus">+    let ancestorLists = yield kWorkAsync; </span>
<a href="#l9.813"></a><span id="l9.813">     </span>
<a href="#l9.814"></a><span id="l9.814">     // pull our current message lookup results off</span>
<a href="#l9.815"></a><span id="l9.815">     references.pop();</span>
<a href="#l9.816"></a><span id="l9.816">     let candidateCurMsgs = ancestorLists.pop();</span>
<a href="#l9.817"></a><span id="l9.817">     </span>
<a href="#l9.818"></a><span id="l9.818">     let conversationID = null;</span>
<a href="#l9.819"></a><span id="l9.819">     // -- figure out the conversation ID</span>
<a href="#l9.820"></a><span id="l9.820">     // if we have a clone/already exist, just use his conversation ID</span>
<a href="#l9.821"></a><span id="l9.821" class="difflineat">@@ -1996,57 +2105,48 @@ var GlodaIndexer = {</span>
<a href="#l9.822"></a><span id="l9.822">       if (allAttachmentNames)</span>
<a href="#l9.823"></a><span id="l9.823">         attachmentNames = allAttachmentNames.join(&quot;\n&quot;);</span>
<a href="#l9.824"></a><span id="l9.824">     } </span>
<a href="#l9.825"></a><span id="l9.825">     </span>
<a href="#l9.826"></a><span id="l9.826">     let isNew;</span>
<a href="#l9.827"></a><span id="l9.827">     if (curMsg === null) {</span>
<a href="#l9.828"></a><span id="l9.828">       this._log.debug(&quot;...creating new message.  body length: &quot; +</span>
<a href="#l9.829"></a><span id="l9.829">                       (aMimeMsg ? aMimeMsg.body.length : null));</span>
<a href="#l9.830"></a><span id="l9.830" class="difflineminus">-      curMsg = this._datastore.createMessage(aMsgHdr.folder.URI,</span>
<a href="#l9.831"></a><span id="l9.831" class="difflineplus">+      curMsg = this._datastore.createMessage(aMsgHdr.folder,</span>
<a href="#l9.832"></a><span id="l9.832">                                              aMsgHdr.messageKey,                </span>
<a href="#l9.833"></a><span id="l9.833">                                              conversationID,</span>
<a href="#l9.834"></a><span id="l9.834">                                              aMsgHdr.date,</span>
<a href="#l9.835"></a><span id="l9.835">                                              aMsgHdr.messageId,</span>
<a href="#l9.836"></a><span id="l9.836">                                              aMsgHdr.subject,</span>
<a href="#l9.837"></a><span id="l9.837">                                              aMimeMsg ? aMimeMsg.body : null,</span>
<a href="#l9.838"></a><span id="l9.838">                                              attachmentNames);</span>
<a href="#l9.839"></a><span id="l9.839">       isNew = true;</span>
<a href="#l9.840"></a><span id="l9.840">     }</span>
<a href="#l9.841"></a><span id="l9.841">     else {</span>
<a href="#l9.842"></a><span id="l9.842">       isNew = (curMsg._folderID === null); // aka was-a-ghost</span>
<a href="#l9.843"></a><span id="l9.843">       // (messageKey can be null if it's not new in the move-case)</span>
<a href="#l9.844"></a><span id="l9.844" class="difflineminus">-      curMsg._folderID = this._datastore._mapFolderURI(aMsgHdr.folder.URI);</span>
<a href="#l9.845"></a><span id="l9.845" class="difflineplus">+      curMsg._folderID = this._datastore._mapFolder(aMsgHdr.folder).id;</span>
<a href="#l9.846"></a><span id="l9.846">       curMsg._messageKey = aMsgHdr.messageKey;</span>
<a href="#l9.847"></a><span id="l9.847">       curMsg.date = new Date(aMsgHdr.date / 1000); </span>
<a href="#l9.848"></a><span id="l9.848">       // note: we are assuming that our matching logic is flawless in that</span>
<a href="#l9.849"></a><span id="l9.849">       //  if this message was not a ghost, we are assuming the 'body'</span>
<a href="#l9.850"></a><span id="l9.850">       //  associated with the id is still exactly the same.  It is conceivable</span>
<a href="#l9.851"></a><span id="l9.851">       //  that there are cases where this is not true.</span>
<a href="#l9.852"></a><span id="l9.852">       this._datastore.updateMessage(curMsg, isNew ? aMsgHdr.subject : null,</span>
<a href="#l9.853"></a><span id="l9.853">         (isNew &amp;&amp; aMimeMsg) ? aMimeMsg.body : null,</span>
<a href="#l9.854"></a><span id="l9.854">         isNew ? attachmentNames : null);</span>
<a href="#l9.855"></a><span id="l9.855">     }</span>
<a href="#l9.856"></a><span id="l9.856">     </span>
<a href="#l9.857"></a><span id="l9.857" class="difflineminus">-    // TODO: provide the parent gloda message if we can conjure it up.</span>
<a href="#l9.858"></a><span id="l9.858" class="difflineminus">-    Gloda.processMessage(curMsg, aMsgHdr, aMimeMsg, isNew,</span>
<a href="#l9.859"></a><span id="l9.859" class="difflineminus">-                         /* parent gloda message */ null);</span>
<a href="#l9.860"></a><span id="l9.860" class="difflineplus">+    yield aCallbackHandle.pushAndGo(&quot;Process Message Attributes&quot;,</span>
<a href="#l9.861"></a><span id="l9.861" class="difflineplus">+      Gloda.grokNounItem(curMsg, {header: aMsgHdr, mime: aMimeMsg}, isNew));</span>
<a href="#l9.862"></a><span id="l9.862">     </span>
<a href="#l9.863"></a><span id="l9.863" class="difflineminus">-    // Mark this message as indexed</span>
<a href="#l9.864"></a><span id="l9.864" class="difflineminus">-    aMsgHdr.setUint32Property(this.GLODA_MESSAGE_ID_PROPERTY, curMsg.id);</span>
<a href="#l9.865"></a><span id="l9.865" class="difflineminus">-    // If there is a gloda-dirty flag on there, clear it by writing a 0.  (But</span>
<a href="#l9.866"></a><span id="l9.866" class="difflineminus">-    //  don't do this if we didn't have a dirty flag on there in the first</span>
<a href="#l9.867"></a><span id="l9.867" class="difflineminus">-    //  case.)  It sounds like we would actually prefer to &quot;cut&quot; the &quot;cell&quot;,</span>
<a href="#l9.868"></a><span id="l9.868" class="difflineminus">-    //  but I don't see any in-domain means of doing that.</span>
<a href="#l9.869"></a><span id="l9.869" class="difflineminus">-    try {</span>
<a href="#l9.870"></a><span id="l9.870" class="difflineminus">-      let isDirty = aMsgHdr.getUint32Property(this.GLODA_DIRTY_PROPERTY);</span>
<a href="#l9.871"></a><span id="l9.871" class="difflineminus">-      if (isDirty)</span>
<a href="#l9.872"></a><span id="l9.872" class="difflineminus">-        aMsgHdr.setUint32Property(this.GLODA_DIRTY_PROPERTY, 0);</span>
<a href="#l9.873"></a><span id="l9.873" class="difflineminus">-    }</span>
<a href="#l9.874"></a><span id="l9.874" class="difflineminus">-    catch (ex) {}</span>
<a href="#l9.875"></a><span id="l9.875" class="difflineplus">+    // we want to update the header for messages only after the transaction</span>
<a href="#l9.876"></a><span id="l9.876" class="difflineplus">+    //  irrevocably hits the disk.  otherwise we could get confused if the</span>
<a href="#l9.877"></a><span id="l9.877" class="difflineplus">+    //  transaction rolls back or what not.</span>
<a href="#l9.878"></a><span id="l9.878" class="difflineplus">+    GlodaDatastore.runPostCommit(MakeCleanMsgHdrCallback(aMsgHdr));</span>
<a href="#l9.879"></a><span id="l9.879">     </span>
<a href="#l9.880"></a><span id="l9.880">     this.callbackDriver();</span>
<a href="#l9.881"></a><span id="l9.881">   },</span>
<a href="#l9.882"></a><span id="l9.882">   </span>
<a href="#l9.883"></a><span id="l9.883">   /**</span>
<a href="#l9.884"></a><span id="l9.884">    * Wipe a message out of existence from our index.  This is slightly more</span>
<a href="#l9.885"></a><span id="l9.885">    *  tricky than one would first expect because there are potentially</span>
<a href="#l9.886"></a><span id="l9.886">    *  attributes not immediately associated with this message that reference</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/modules/noun_freetag.js</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/modules/noun_freetag.js</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -56,17 +56,17 @@ FreeTag.prototype = {</span>
<a href="#l10.4"></a><span id="l10.4"> </span>
<a href="#l10.5"></a><span id="l10.5"> /**</span>
<a href="#l10.6"></a><span id="l10.6">  * @namespace Tag noun provider.  Since the tag unique value is stored as a</span>
<a href="#l10.7"></a><span id="l10.7">  *  parameter, we are an odd case and semantically confused.</span>
<a href="#l10.8"></a><span id="l10.8">  */</span>
<a href="#l10.9"></a><span id="l10.9"> var FreeTagNoun = {</span>
<a href="#l10.10"></a><span id="l10.10">   name: &quot;freetag&quot;,</span>
<a href="#l10.11"></a><span id="l10.11">   class: FreeTag,</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-  firstClass: false,</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+  allowsArbitraryAttrs: false,</span>
<a href="#l10.14"></a><span id="l10.14">   </span>
<a href="#l10.15"></a><span id="l10.15">   _listeners: [],</span>
<a href="#l10.16"></a><span id="l10.16">   addListener: function(aListener) {</span>
<a href="#l10.17"></a><span id="l10.17">     this._listeners.push(aListener);</span>
<a href="#l10.18"></a><span id="l10.18">   },</span>
<a href="#l10.19"></a><span id="l10.19">   removeListener: function(aListener) {</span>
<a href="#l10.20"></a><span id="l10.20">     let index = this._listeners.indexOf(aListener);</span>
<a href="#l10.21"></a><span id="l10.21">     if (index &gt;=0)</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineat">@@ -79,19 +79,25 @@ var FreeTagNoun = {</span>
<a href="#l10.23"></a><span id="l10.23">     if (!tag) {</span>
<a href="#l10.24"></a><span id="l10.24">       tag = this.knownFreeTags[aTagName] = new FreeTag(aTagName);</span>
<a href="#l10.25"></a><span id="l10.25">       for each (let [iListener, listener] in Iterator(this._listeners))</span>
<a href="#l10.26"></a><span id="l10.26">         listener.onFreeTagAdded(tag);</span>
<a href="#l10.27"></a><span id="l10.27">     }</span>
<a href="#l10.28"></a><span id="l10.28">     return tag;</span>
<a href="#l10.29"></a><span id="l10.29">   },</span>
<a href="#l10.30"></a><span id="l10.30"> </span>
<a href="#l10.31"></a><span id="l10.31" class="difflineminus">-  toParamAndValue: function gloda_noun_tag_toParamAndValue(aTag) {</span>
<a href="#l10.32"></a><span id="l10.32" class="difflineplus">+  toParamAndValue: function gloda_noun_freetag_toParamAndValue(aTag) {</span>
<a href="#l10.33"></a><span id="l10.33">     return [aTag.name, null];</span>
<a href="#l10.34"></a><span id="l10.34">   },</span>
<a href="#l10.35"></a><span id="l10.35" class="difflineplus">+  fromParamAndValue: function gloda_noun_freetag_fromParameterValue(aTagName,</span>
<a href="#l10.36"></a><span id="l10.36" class="difflineplus">+                                                                    aIgnored) {</span>
<a href="#l10.37"></a><span id="l10.37" class="difflineplus">+    return this.getFreeTag(aTagName);</span>
<a href="#l10.38"></a><span id="l10.38" class="difflineplus">+  },</span>
<a href="#l10.39"></a><span id="l10.39">   </span>
<a href="#l10.40"></a><span id="l10.40" class="difflineminus">-  fromParamAndValue: function gloda_noun_tag_fromParameterValue(aTagName,</span>
<a href="#l10.41"></a><span id="l10.41" class="difflineminus">-                                                                aIgnored) {</span>
<a href="#l10.42"></a><span id="l10.42" class="difflineplus">+  toJSON: function gloda_noun_freetag_toJSON(aTag) {</span>
<a href="#l10.43"></a><span id="l10.43" class="difflineplus">+    return aTag.name;</span>
<a href="#l10.44"></a><span id="l10.44" class="difflineplus">+  },</span>
<a href="#l10.45"></a><span id="l10.45" class="difflineplus">+  fromJSON: function gloda_noun_freetag_fromJSON(aTagName) {</span>
<a href="#l10.46"></a><span id="l10.46">     return this.getFreeTag(aTagName);</span>
<a href="#l10.47"></a><span id="l10.47">   },</span>
<a href="#l10.48"></a><span id="l10.48"> };</span>
<a href="#l10.49"></a><span id="l10.49"> </span>
<a href="#l10.50"></a><span id="l10.50"> Gloda.defineNoun(FreeTagNoun);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/modules/noun_tag.js</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/modules/noun_tag.js</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -30,74 +30,69 @@</span>
<a href="#l11.4"></a><span id="l11.4">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l11.5"></a><span id="l11.5">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l11.6"></a><span id="l11.6">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l11.7"></a><span id="l11.7">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l11.8"></a><span id="l11.8">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l11.9"></a><span id="l11.9">  * </span>
<a href="#l11.10"></a><span id="l11.10">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l11.11"></a><span id="l11.11"> </span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-EXPORTED_SYMBOLS = ['Tagged', 'TagNoun'];</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+EXPORTED_SYMBOLS = ['TagNoun'];</span>
<a href="#l11.14"></a><span id="l11.14"> </span>
<a href="#l11.15"></a><span id="l11.15"> const Cc = Components.classes;</span>
<a href="#l11.16"></a><span id="l11.16"> const Ci = Components.interfaces;</span>
<a href="#l11.17"></a><span id="l11.17"> const Cr = Components.results;</span>
<a href="#l11.18"></a><span id="l11.18"> const Cu = Components.utils;</span>
<a href="#l11.19"></a><span id="l11.19"> </span>
<a href="#l11.20"></a><span id="l11.20"> Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l11.21"></a><span id="l11.21"> </span>
<a href="#l11.22"></a><span id="l11.22"> /**</span>
<a href="#l11.23"></a><span id="l11.23" class="difflineminus">- * @class Represents a tag applied at a certain time.  Or rather it would if we</span>
<a href="#l11.24"></a><span id="l11.24" class="difflineminus">- *  were clever enough to track and maintain that time accurately.</span>
<a href="#l11.25"></a><span id="l11.25" class="difflineminus">- */</span>
<a href="#l11.26"></a><span id="l11.26" class="difflineminus">-function Tagged(aTag, aDate) {</span>
<a href="#l11.27"></a><span id="l11.27" class="difflineminus">-  this.tag = aTag;</span>
<a href="#l11.28"></a><span id="l11.28" class="difflineminus">-  this.date = aDate;</span>
<a href="#l11.29"></a><span id="l11.29" class="difflineminus">-}</span>
<a href="#l11.30"></a><span id="l11.30" class="difflineminus">-</span>
<a href="#l11.31"></a><span id="l11.31" class="difflineminus">-Tagged.prototype = {</span>
<a href="#l11.32"></a><span id="l11.32" class="difflineminus">-  toString: function () {</span>
<a href="#l11.33"></a><span id="l11.33" class="difflineminus">-    return this.tag.tag;</span>
<a href="#l11.34"></a><span id="l11.34" class="difflineminus">-  }</span>
<a href="#l11.35"></a><span id="l11.35" class="difflineminus">-};</span>
<a href="#l11.36"></a><span id="l11.36" class="difflineminus">-</span>
<a href="#l11.37"></a><span id="l11.37" class="difflineminus">-/**</span>
<a href="#l11.38"></a><span id="l11.38" class="difflineminus">- * @namespace Tag noun provider.  Since the tag unique value is stored as a</span>
<a href="#l11.39"></a><span id="l11.39" class="difflineminus">- *  parameter, we are an odd case and semantically confused.</span>
<a href="#l11.40"></a><span id="l11.40" class="difflineplus">+ * @namespace Tag noun provider.</span>
<a href="#l11.41"></a><span id="l11.41">  */</span>
<a href="#l11.42"></a><span id="l11.42"> var TagNoun = {</span>
<a href="#l11.43"></a><span id="l11.43">   name: &quot;tag&quot;,</span>
<a href="#l11.44"></a><span id="l11.44" class="difflineminus">-  class: Tagged,</span>
<a href="#l11.45"></a><span id="l11.45" class="difflineminus">-  firstClass: false,</span>
<a href="#l11.46"></a><span id="l11.46" class="difflineplus">+  class: Ci.nsIMsgTag,</span>
<a href="#l11.47"></a><span id="l11.47" class="difflineplus">+  allowsArbitraryAttrs: false,</span>
<a href="#l11.48"></a><span id="l11.48">   _msgTagService: null,</span>
<a href="#l11.49"></a><span id="l11.49" class="difflineplus">+  _tagMap: null,</span>
<a href="#l11.50"></a><span id="l11.50">   </span>
<a href="#l11.51"></a><span id="l11.51">   _init: function () {</span>
<a href="#l11.52"></a><span id="l11.52">     this._msgTagService = Cc[&quot;@mozilla.org/messenger/tagservice;1&quot;].</span>
<a href="#l11.53"></a><span id="l11.53">                           getService(Ci.nsIMsgTagService);</span>
<a href="#l11.54"></a><span id="l11.54" class="difflineplus">+    this._updateTagMap();</span>
<a href="#l11.55"></a><span id="l11.55" class="difflineplus">+    </span>
<a href="#l11.56"></a><span id="l11.56" class="difflineplus">+    this.fromJSON = this.fromParamAndValue;</span>
<a href="#l11.57"></a><span id="l11.57" class="difflineplus">+  },</span>
<a href="#l11.58"></a><span id="l11.58" class="difflineplus">+  </span>
<a href="#l11.59"></a><span id="l11.59" class="difflineplus">+  _updateTagMap: function gloda_noun_tag_updateTagMap() {</span>
<a href="#l11.60"></a><span id="l11.60" class="difflineplus">+    this._tagMap = {};</span>
<a href="#l11.61"></a><span id="l11.61" class="difflineplus">+    let tagArray = this._msgTagService.getAllTags({});</span>
<a href="#l11.62"></a><span id="l11.62" class="difflineplus">+    for (let iTag = 0; iTag &lt; tagArray.length; iTag++) {</span>
<a href="#l11.63"></a><span id="l11.63" class="difflineplus">+      let tag = tagArray[iTag];</span>
<a href="#l11.64"></a><span id="l11.64" class="difflineplus">+      this._tagMap[tag.key] = tag;</span>
<a href="#l11.65"></a><span id="l11.65" class="difflineplus">+    }</span>
<a href="#l11.66"></a><span id="l11.66">   },</span>
<a href="#l11.67"></a><span id="l11.67">   </span>
<a href="#l11.68"></a><span id="l11.68">   // we cannot be an attribute value</span>
<a href="#l11.69"></a><span id="l11.69">   </span>
<a href="#l11.70"></a><span id="l11.70" class="difflineminus">-  toParamAndValue: function gloda_noun_tag_toParamAndValue(aTagged, aGeneric) {</span>
<a href="#l11.71"></a><span id="l11.71" class="difflineminus">-    if (aGeneric)</span>
<a href="#l11.72"></a><span id="l11.72" class="difflineminus">-      return [aTagged.tag.key, null];</span>
<a href="#l11.73"></a><span id="l11.73" class="difflineminus">-    else</span>
<a href="#l11.74"></a><span id="l11.74" class="difflineminus">-      return [aTagged.tag.key, aTagged.date.valueOf() * 1000];</span>
<a href="#l11.75"></a><span id="l11.75" class="difflineplus">+  toParamAndValue: function gloda_noun_tag_toParamAndValue(aTag) {</span>
<a href="#l11.76"></a><span id="l11.76" class="difflineplus">+    return [aTag.key, null];</span>
<a href="#l11.77"></a><span id="l11.77">   },</span>
<a href="#l11.78"></a><span id="l11.78" class="difflineminus">-  </span>
<a href="#l11.79"></a><span id="l11.79" class="difflineplus">+  toJSON: function gloda_noun_tag_toJSON(aTag) {</span>
<a href="#l11.80"></a><span id="l11.80" class="difflineplus">+    return aTag.key;</span>
<a href="#l11.81"></a><span id="l11.81" class="difflineplus">+  }</span>
<a href="#l11.82"></a><span id="l11.82">   fromParamAndValue: function gloda_noun_tag_fromParameterValue(aTagKey,</span>
<a href="#l11.83"></a><span id="l11.83" class="difflineminus">-                                                                aPRTime) {</span>
<a href="#l11.84"></a><span id="l11.84" class="difflineminus">-    // we have to walk the array to find our tag.  curse you, tag service!</span>
<a href="#l11.85"></a><span id="l11.85" class="difflineminus">-    let tagService = Cc[&quot;@mozilla.org/messenger/tagservice;1&quot;].</span>
<a href="#l11.86"></a><span id="l11.86" class="difflineminus">-                          getService(Ci.nsIMsgTagService);</span>
<a href="#l11.87"></a><span id="l11.87" class="difflineminus">-    let tagArray = tagService.getAllTags({});</span>
<a href="#l11.88"></a><span id="l11.88" class="difflineminus">-    for (let iTag = 0; iTag &lt; tagArray.length; iTag++) {</span>
<a href="#l11.89"></a><span id="l11.89" class="difflineminus">-      let tag = tagArray[iTag];</span>
<a href="#l11.90"></a><span id="l11.90" class="difflineminus">-      if (tag.key == aTagKey)</span>
<a href="#l11.91"></a><span id="l11.91" class="difflineminus">-        return new Tagged(tag, new Date(aPRTime/1000));</span>
<a href="#l11.92"></a><span id="l11.92" class="difflineplus">+                                                                aIgnored) {</span>
<a href="#l11.93"></a><span id="l11.93" class="difflineplus">+    let tag = this._tagMap[aTagKey];</span>
<a href="#l11.94"></a><span id="l11.94" class="difflineplus">+    // you will note that if a tag is removed, we are unable to aggressively</span>
<a href="#l11.95"></a><span id="l11.95" class="difflineplus">+    //  deal with this.  we are okay with this, but it would be nice to be able</span>
<a href="#l11.96"></a><span id="l11.96" class="difflineplus">+    //  to listen to the message tag service to know when we should rebuild.</span>
<a href="#l11.97"></a><span id="l11.97" class="difflineplus">+    if ((tag === undefined) &amp;&amp; this._msgTagService.isValidKey(aTagKey)) {</span>
<a href="#l11.98"></a><span id="l11.98" class="difflineplus">+      this._updateTagMap();</span>
<a href="#l11.99"></a><span id="l11.99" class="difflineplus">+      tag = this._tagMap[aTagKey];</span>
<a href="#l11.100"></a><span id="l11.100">     }</span>
<a href="#l11.101"></a><span id="l11.101" class="difflineminus">-    // the tag has gone a-way, null is probably the safest thing to do.</span>
<a href="#l11.102"></a><span id="l11.102" class="difflineminus">-    return null;</span>
<a href="#l11.103"></a><span id="l11.103" class="difflineplus">+    // we intentionally are returning undefined if the tag doesn't exist</span>
<a href="#l11.104"></a><span id="l11.104" class="difflineplus">+    return tag;</span>
<a href="#l11.105"></a><span id="l11.105">   },</span>
<a href="#l11.106"></a><span id="l11.106"> };</span>
<a href="#l11.107"></a><span id="l11.107"> </span>
<a href="#l11.108"></a><span id="l11.108"> TagNoun._init();</span>
<a href="#l11.109"></a><span id="l11.109"> Gloda.defineNoun(TagNoun, Gloda.NOUN_TAG);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/modules/query.js</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/modules/query.js</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -60,16 +60,19 @@ Cu.import(&quot;resource://gloda/modules/log4</span>
<a href="#l12.4"></a><span id="l12.4"> function GlodaQueryClass() {</span>
<a href="#l12.5"></a><span id="l12.5">   // if we are an 'or' clause, who is our parent whom other 'or' clauses should</span>
<a href="#l12.6"></a><span id="l12.6">   //  spawn from...</span>
<a href="#l12.7"></a><span id="l12.7">   this._owner = null;</span>
<a href="#l12.8"></a><span id="l12.8">   // our personal chain of and-ing.</span>
<a href="#l12.9"></a><span id="l12.9">   this._constraints = [];</span>
<a href="#l12.10"></a><span id="l12.10">   // the other instances we union with</span>
<a href="#l12.11"></a><span id="l12.11">   this._unions = [];</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineplus">+  </span>
<a href="#l12.13"></a><span id="l12.13" class="difflineplus">+  this._order = [];</span>
<a href="#l12.14"></a><span id="l12.14" class="difflineplus">+  this._limit = 0;</span>
<a href="#l12.15"></a><span id="l12.15"> }</span>
<a href="#l12.16"></a><span id="l12.16"> </span>
<a href="#l12.17"></a><span id="l12.17"> GlodaQueryClass.prototype = {</span>
<a href="#l12.18"></a><span id="l12.18">   WILDCARD: {},</span>
<a href="#l12.19"></a><span id="l12.19">   </span>
<a href="#l12.20"></a><span id="l12.20">   get constraintCount() {</span>
<a href="#l12.21"></a><span id="l12.21">     return this._constraints.length;</span>
<a href="#l12.22"></a><span id="l12.22">   },</span>
<a href="#l12.23"></a><span id="l12.23" class="difflineat">@@ -77,26 +80,38 @@ GlodaQueryClass.prototype = {</span>
<a href="#l12.24"></a><span id="l12.24">   or: function gloda_query_or() {</span>
<a href="#l12.25"></a><span id="l12.25">     let owner = this._owner || this;</span>
<a href="#l12.26"></a><span id="l12.26">     let orQuery = new this._queryClass();</span>
<a href="#l12.27"></a><span id="l12.27">     orQuery._owner = owner;</span>
<a href="#l12.28"></a><span id="l12.28">     owner._unions.push(orQuery);</span>
<a href="#l12.29"></a><span id="l12.29">     return orQuery;</span>
<a href="#l12.30"></a><span id="l12.30">   },</span>
<a href="#l12.31"></a><span id="l12.31">   </span>
<a href="#l12.32"></a><span id="l12.32" class="difflineplus">+  orderBy: function gloda_query_orderBy() {</span>
<a href="#l12.33"></a><span id="l12.33" class="difflineplus">+    for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l12.34"></a><span id="l12.34" class="difflineplus">+      let arg = arguments[iArg];</span>
<a href="#l12.35"></a><span id="l12.35" class="difflineplus">+      this._order.push(arg);</span>
<a href="#l12.36"></a><span id="l12.36" class="difflineplus">+    }</span>
<a href="#l12.37"></a><span id="l12.37" class="difflineplus">+  },</span>
<a href="#l12.38"></a><span id="l12.38" class="difflineplus">+  </span>
<a href="#l12.39"></a><span id="l12.39" class="difflineplus">+  limit: function gloda_query_limit(aLimit) {</span>
<a href="#l12.40"></a><span id="l12.40" class="difflineplus">+    this._limit = aLimit;</span>
<a href="#l12.41"></a><span id="l12.41" class="difflineplus">+  },</span>
<a href="#l12.42"></a><span id="l12.42" class="difflineplus">+  </span>
<a href="#l12.43"></a><span id="l12.43">   /**</span>
<a href="#l12.44"></a><span id="l12.44">    * Return a collection asynchronously populated by this collection.  You must</span>
<a href="#l12.45"></a><span id="l12.45">    *  provide a listener to receive notifications from the collection as it</span>
<a href="#l12.46"></a><span id="l12.46">    *  receives updates.  The listener object should implement onItemsAdded,</span>
<a href="#l12.47"></a><span id="l12.47">    *  onItemsModified, and onItemsRemoved methods, all of which take a single</span>
<a href="#l12.48"></a><span id="l12.48">    *  argument which is the list of items which have been added, modified, or</span>
<a href="#l12.49"></a><span id="l12.49">    *  removed respectively.</span>
<a href="#l12.50"></a><span id="l12.50">    */</span>
<a href="#l12.51"></a><span id="l12.51" class="difflineminus">-  getCollection: function gloda_query_getAll(aListener) {</span>
<a href="#l12.52"></a><span id="l12.52" class="difflineminus">-    return this._nounMeta.datastore.queryFromQuery(this, aListener);</span>
<a href="#l12.53"></a><span id="l12.53" class="difflineplus">+  getCollection: function gloda_query_getCollection(aListener, aData) {</span>
<a href="#l12.54"></a><span id="l12.54" class="difflineplus">+    return this._nounMeta.datastore.queryFromQuery(this, aListener, false,</span>
<a href="#l12.55"></a><span id="l12.55" class="difflineplus">+      aData);</span>
<a href="#l12.56"></a><span id="l12.56">   },</span>
<a href="#l12.57"></a><span id="l12.57">   </span>
<a href="#l12.58"></a><span id="l12.58">   getAllSync: function gloda_query_getAllSync(aListener) {</span>
<a href="#l12.59"></a><span id="l12.59">     return this._nounMeta.datastore.queryFromQuery(this, aListener, true);</span>
<a href="#l12.60"></a><span id="l12.60">   },</span>
<a href="#l12.61"></a><span id="l12.61">   </span>
<a href="#l12.62"></a><span id="l12.62">   /**</span>
<a href="#l12.63"></a><span id="l12.63">    * Test whether the given first-class noun instance satisfies this query.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/modules/utils.js</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/modules/utils.js</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -105,9 +105,30 @@ var GlodaUtils = {</span>
<a href="#l13.4"></a><span id="l13.4">      // return the two-digit hexadecimal code for a byte</span>
<a href="#l13.5"></a><span id="l13.5">     function toHexString(charCode) {</span>
<a href="#l13.6"></a><span id="l13.6">       return (&quot;0&quot; + charCode.toString(16)).slice(-2);</span>
<a href="#l13.7"></a><span id="l13.7">     }</span>
<a href="#l13.8"></a><span id="l13.8"> </span>
<a href="#l13.9"></a><span id="l13.9">     // convert the binary hash data to a hex string.</span>
<a href="#l13.10"></a><span id="l13.10">     return [toHexString(hash.charCodeAt(i)) for (i in hash)].join(&quot;&quot;);</span>
<a href="#l13.11"></a><span id="l13.11">   },</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineplus">+  </span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+  getCardForEmail: function gloda_utils_getCardForEmail(aAddress) {</span>
<a href="#l13.14"></a><span id="l13.14" class="difflineplus">+    // search through all of our local address books looking for a match.</span>
<a href="#l13.15"></a><span id="l13.15" class="difflineplus">+    let enumerator = Components.classes[&quot;@mozilla.org/abmanager;1&quot;]</span>
<a href="#l13.16"></a><span id="l13.16" class="difflineplus">+                               .getService(Ci.nsIAbManager)</span>
<a href="#l13.17"></a><span id="l13.17" class="difflineplus">+                               .directories;</span>
<a href="#l13.18"></a><span id="l13.18" class="difflineplus">+    let cardForEmailAddress;</span>
<a href="#l13.19"></a><span id="l13.19" class="difflineplus">+    let addrbook;</span>
<a href="#l13.20"></a><span id="l13.20" class="difflineplus">+    while (!cardForEmailAddress &amp;&amp; enumerator.hasMoreElements())</span>
<a href="#l13.21"></a><span id="l13.21" class="difflineplus">+    {</span>
<a href="#l13.22"></a><span id="l13.22" class="difflineplus">+      addrbook = enumerator.getNext().QueryInterface(Ci.nsIAbDirectory);</span>
<a href="#l13.23"></a><span id="l13.23" class="difflineplus">+      try</span>
<a href="#l13.24"></a><span id="l13.24" class="difflineplus">+      {</span>
<a href="#l13.25"></a><span id="l13.25" class="difflineplus">+        cardForEmailAddress = addrbook.cardForEmailAddress(aAddress);</span>
<a href="#l13.26"></a><span id="l13.26" class="difflineplus">+        if (cardForEmailAddress)</span>
<a href="#l13.27"></a><span id="l13.27" class="difflineplus">+          return cardForEmailAddress;</span>
<a href="#l13.28"></a><span id="l13.28" class="difflineplus">+      } catch (ex) {}</span>
<a href="#l13.29"></a><span id="l13.29" class="difflineplus">+    }</span>
<a href="#l13.30"></a><span id="l13.30" class="difflineplus">+</span>
<a href="#l13.31"></a><span id="l13.31" class="difflineplus">+    return null;</span>
<a href="#l13.32"></a><span id="l13.32" class="difflineplus">+  },</span>
<a href="#l13.33"></a><span id="l13.33"> };</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

