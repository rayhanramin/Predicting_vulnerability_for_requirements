<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 7514:85be50c0b00f108108926331c1a9db77e901f530</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 85be50c0b00f108108926331c1a9db77e901f530" />
<meta property="og:url" content="/comm-central/rev/85be50c0b00f108108926331c1a9db77e901f530" />
<meta property="og:description" content="get rid of nsAutoLock, bug 647000, r=neil" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 85be50c0b00f108108926331c1a9db77e901f530 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/85be50c0b00f108108926331c1a9db77e901f530">shortlog</a> |
<a href="/comm-central/log/85be50c0b00f108108926331c1a9db77e901f530">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/85be50c0b00f108108926331c1a9db77e901f530">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/85be50c0b00f108108926331c1a9db77e901f530">files</a> |
changeset |
<a href="/comm-central/raw-rev/85be50c0b00f108108926331c1a9db77e901f530">raw</a>  | <a href="/comm-central/archive/85be50c0b00f108108926331c1a9db77e901f530.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
get rid of nsAutoLock, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=647000">bug 647000</a>, r=neil
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#68;&#97;&#118;&#105;&#100;&#32;&#66;&#105;&#101;&#110;&#118;&#101;&#110;&#117;&#32;&#60;&#98;&#105;&#101;&#110;&#118;&#101;&#110;&#117;&#64;&#110;&#118;&#101;&#110;&#116;&#117;&#114;&#101;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Wed, 06 Apr 2011 20:15:34 -0700</td></tr>

<tr>
 <td>changeset 7514</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/85be50c0b00f108108926331c1a9db77e901f530">85be50c0b00f108108926331c1a9db77e901f530</a></td>
</tr>



<tr>
<td>parent 7513</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/000c04a87624ce94e1efbb9ee22c4a1184f2bb14">000c04a87624ce94e1efbb9ee22c4a1184f2bb14</a>
</td>
</tr>

<tr>
<td>child 7515</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/64f6a4022713d7264506eedc9163d23986974d99">64f6a4022713d7264506eedc9163d23986974d99</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=85be50c0b00f108108926331c1a9db77e901f530">5758</a></td></tr>
<tr><td>push user</td><td>bienvenu@nventure.com</td></tr>
<tr><td>push date</td><td class="date age">Thu, 07 Apr 2011 03:15:42 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@85be50c0b00f [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=85be50c0b00f108108926331c1a9db77e901f530">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=85be50c0b00f108108926331c1a9db77e901f530&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=85be50c0b00f108108926331c1a9db77e901f530&newProject=comm-central&newRevision=85be50c0b00f108108926331c1a9db77e901f530&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=85be50c0b00f108108926331c1a9db77e901f530&newProject=comm-central&newRevision=85be50c0b00f108108926331c1a9db77e901f530&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=85be50c0b00f108108926331c1a9db77e901f530&newProject=comm-central&newRevision=85be50c0b00f108108926331c1a9db77e901f530&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28neil%29&revcount=50">neil</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=647000">647000</a></td></tr>




</table></div>

<div class="page_body description">get rid of nsAutoLock, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=647000">bug 647000</a>, r=neil</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapFlagAndUidState.cpp">mailnews/imap/src/nsImapFlagAndUidState.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapFlagAndUidState.cpp">file</a> |
<a href="/comm-central/annotate/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapFlagAndUidState.cpp">annotate</a> |
<a href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapFlagAndUidState.cpp">diff</a> |
<a href="/comm-central/comparison/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapFlagAndUidState.cpp">comparison</a> |
<a href="/comm-central/log/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapFlagAndUidState.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapFlagAndUidState.h">mailnews/imap/src/nsImapFlagAndUidState.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapFlagAndUidState.h">file</a> |
<a href="/comm-central/annotate/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapFlagAndUidState.h">annotate</a> |
<a href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapFlagAndUidState.h">diff</a> |
<a href="/comm-central/comparison/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapFlagAndUidState.h">comparison</a> |
<a href="/comm-central/log/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapFlagAndUidState.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapIncomingServer.cpp">mailnews/imap/src/nsImapIncomingServer.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapIncomingServer.cpp">file</a> |
<a href="/comm-central/annotate/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapIncomingServer.cpp">annotate</a> |
<a href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapIncomingServer.cpp">diff</a> |
<a href="/comm-central/comparison/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapIncomingServer.cpp">comparison</a> |
<a href="/comm-central/log/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapIncomingServer.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapIncomingServer.h">mailnews/imap/src/nsImapIncomingServer.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapIncomingServer.h">file</a> |
<a href="/comm-central/annotate/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapIncomingServer.h">annotate</a> |
<a href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapIncomingServer.h">diff</a> |
<a href="/comm-central/comparison/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapIncomingServer.h">comparison</a> |
<a href="/comm-central/log/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapIncomingServer.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapProtocol.cpp">mailnews/imap/src/nsImapProtocol.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapProtocol.cpp">file</a> |
<a href="/comm-central/annotate/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapProtocol.cpp">annotate</a> |
<a href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapProtocol.cpp">diff</a> |
<a href="/comm-central/comparison/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapProtocol.cpp">comparison</a> |
<a href="/comm-central/log/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapProtocol.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapProtocol.h">mailnews/imap/src/nsImapProtocol.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapProtocol.h">file</a> |
<a href="/comm-central/annotate/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapProtocol.h">annotate</a> |
<a href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapProtocol.h">diff</a> |
<a href="/comm-central/comparison/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapProtocol.h">comparison</a> |
<a href="/comm-central/log/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapProtocol.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapUrl.cpp">mailnews/imap/src/nsImapUrl.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapUrl.cpp">file</a> |
<a href="/comm-central/annotate/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapUrl.cpp">annotate</a> |
<a href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapUrl.cpp">diff</a> |
<a href="/comm-central/comparison/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapUrl.cpp">comparison</a> |
<a href="/comm-central/log/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapUrl.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapUrl.h">mailnews/imap/src/nsImapUrl.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapUrl.h">file</a> |
<a href="/comm-central/annotate/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapUrl.h">annotate</a> |
<a href="/comm-central/diff/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapUrl.h">diff</a> |
<a href="/comm-central/comparison/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapUrl.h">comparison</a> |
<a href="/comm-central/log/85be50c0b00f108108926331c1a9db77e901f530/mailnews/imap/src/nsImapUrl.h">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/imap/src/nsImapFlagAndUidState.cpp</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapFlagAndUidState.cpp</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -37,20 +37,21 @@</span>
<a href="#l1.4"></a><span id="l1.4">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l1.5"></a><span id="l1.5"> </span>
<a href="#l1.6"></a><span id="l1.6"> #include &quot;msgCore.h&quot;  // for pre-compiled headers</span>
<a href="#l1.7"></a><span id="l1.7"> </span>
<a href="#l1.8"></a><span id="l1.8"> #include &quot;nsImapCore.h&quot;</span>
<a href="#l1.9"></a><span id="l1.9"> #include &quot;nsImapFlagAndUidState.h&quot;</span>
<a href="#l1.10"></a><span id="l1.10"> #include &quot;prcmon.h&quot;</span>
<a href="#l1.11"></a><span id="l1.11"> #include &quot;nspr.h&quot;</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-#include &quot;nsAutoLock.h&quot;</span>
<a href="#l1.13"></a><span id="l1.13"> </span>
<a href="#l1.14"></a><span id="l1.14"> NS_IMPL_THREADSAFE_ISUPPORTS1(nsImapFlagAndUidState, nsIImapFlagAndUidState)</span>
<a href="#l1.15"></a><span id="l1.15"> </span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+using namespace mozilla;</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+</span>
<a href="#l1.18"></a><span id="l1.18"> NS_IMETHODIMP nsImapFlagAndUidState::GetNumberOfMessages(PRInt32 *result)</span>
<a href="#l1.19"></a><span id="l1.19"> {</span>
<a href="#l1.20"></a><span id="l1.20">   if (!result)</span>
<a href="#l1.21"></a><span id="l1.21">     return NS_ERROR_NULL_POINTER;</span>
<a href="#l1.22"></a><span id="l1.22">   *result = fUids.Length();</span>
<a href="#l1.23"></a><span id="l1.23">   return NS_OK;</span>
<a href="#l1.24"></a><span id="l1.24"> }</span>
<a href="#l1.25"></a><span id="l1.25"> </span>
<a href="#l1.26"></a><span id="l1.26" class="difflineat">@@ -105,17 +106,18 @@ NS_IMETHODIMP nsImapFlagAndUidState::Get</span>
<a href="#l1.27"></a><span id="l1.27">   *aPartialUIDFetch = fPartialUIDFetch;</span>
<a href="#l1.28"></a><span id="l1.28">   return NS_OK;</span>
<a href="#l1.29"></a><span id="l1.29"> }</span>
<a href="#l1.30"></a><span id="l1.30"> </span>
<a href="#l1.31"></a><span id="l1.31"> /* amount to expand for imap entry flags when we need more */</span>
<a href="#l1.32"></a><span id="l1.32"> </span>
<a href="#l1.33"></a><span id="l1.33"> nsImapFlagAndUidState::nsImapFlagAndUidState(PRInt32 numberOfMessages)</span>
<a href="#l1.34"></a><span id="l1.34">   : fUids(numberOfMessages),</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineminus">-    fFlags(numberOfMessages)</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineplus">+    fFlags(numberOfMessages),</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineplus">+    mLock(&quot;nsImapFlagAndUidState.mLock&quot;)</span>
<a href="#l1.38"></a><span id="l1.38"> {</span>
<a href="#l1.39"></a><span id="l1.39">   fSupportedUserFlags = 0;</span>
<a href="#l1.40"></a><span id="l1.40">   fNumberDeleted = 0;</span>
<a href="#l1.41"></a><span id="l1.41">   fPartialUIDFetch = PR_TRUE;</span>
<a href="#l1.42"></a><span id="l1.42">   m_customFlagsHash.Init(10);</span>
<a href="#l1.43"></a><span id="l1.43"> }</span>
<a href="#l1.44"></a><span id="l1.44"> </span>
<a href="#l1.45"></a><span id="l1.45"> /* static */PLDHashOperator nsImapFlagAndUidState::FreeCustomFlags(const PRUint32 &amp;aKey, char *aData,</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineat">@@ -270,17 +272,17 @@ imapMessageFlagsType nsImapFlagAndUidSta</span>
<a href="#l1.47"></a><span id="l1.47">                                     (PRUint32 *) ndx);</span>
<a href="#l1.48"></a><span id="l1.48">   imapMessageFlagsType retFlags = (*foundIt) ? fFlags[*ndx] : kNoImapMsgFlag;</span>
<a href="#l1.49"></a><span id="l1.49">   PR_CExitMonitor(this);</span>
<a href="#l1.50"></a><span id="l1.50">   return retFlags;</span>
<a href="#l1.51"></a><span id="l1.51"> }</span>
<a href="#l1.52"></a><span id="l1.52"> </span>
<a href="#l1.53"></a><span id="l1.53"> NS_IMETHODIMP nsImapFlagAndUidState::AddUidCustomFlagPair(PRUint32 uid, const char *customFlag)</span>
<a href="#l1.54"></a><span id="l1.54"> {</span>
<a href="#l1.55"></a><span id="l1.55" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l1.56"></a><span id="l1.56" class="difflineplus">+  MutexAutoLock mon(mLock);</span>
<a href="#l1.57"></a><span id="l1.57">   if (!m_customFlagsHash.IsInitialized())</span>
<a href="#l1.58"></a><span id="l1.58">     return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l1.59"></a><span id="l1.59">   char *ourCustomFlags;</span>
<a href="#l1.60"></a><span id="l1.60">   char *oldValue = nsnull;</span>
<a href="#l1.61"></a><span id="l1.61">   m_customFlagsHash.Get(uid, &amp;oldValue);</span>
<a href="#l1.62"></a><span id="l1.62">   if (oldValue)</span>
<a href="#l1.63"></a><span id="l1.63">   {</span>
<a href="#l1.64"></a><span id="l1.64">   // we'll store multiple keys as space-delimited since space is not</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineat">@@ -309,30 +311,30 @@ NS_IMETHODIMP nsImapFlagAndUidState::Add</span>
<a href="#l1.66"></a><span id="l1.66">     if (!ourCustomFlags)</span>
<a href="#l1.67"></a><span id="l1.67">       return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l1.68"></a><span id="l1.68">   }</span>
<a href="#l1.69"></a><span id="l1.69">   return (m_customFlagsHash.Put(uid, ourCustomFlags) == 0) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l1.70"></a><span id="l1.70"> }</span>
<a href="#l1.71"></a><span id="l1.71"> </span>
<a href="#l1.72"></a><span id="l1.72"> NS_IMETHODIMP nsImapFlagAndUidState::GetCustomFlags(PRUint32 uid, char **customFlags)</span>
<a href="#l1.73"></a><span id="l1.73"> {</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineplus">+  MutexAutoLock mon(mLock);</span>
<a href="#l1.76"></a><span id="l1.76">   if (m_customFlagsHash.IsInitialized())</span>
<a href="#l1.77"></a><span id="l1.77">   {</span>
<a href="#l1.78"></a><span id="l1.78">     char *value = nsnull;</span>
<a href="#l1.79"></a><span id="l1.79">     m_customFlagsHash.Get(uid, &amp;value);</span>
<a href="#l1.80"></a><span id="l1.80">     if (value)</span>
<a href="#l1.81"></a><span id="l1.81">     {</span>
<a href="#l1.82"></a><span id="l1.82">       *customFlags = NS_strdup(value);</span>
<a href="#l1.83"></a><span id="l1.83">       return (*customFlags) ? NS_OK : NS_ERROR_FAILURE;</span>
<a href="#l1.84"></a><span id="l1.84">     }</span>
<a href="#l1.85"></a><span id="l1.85">   }</span>
<a href="#l1.86"></a><span id="l1.86">   *customFlags = nsnull;</span>
<a href="#l1.87"></a><span id="l1.87">   return NS_OK;</span>
<a href="#l1.88"></a><span id="l1.88"> }</span>
<a href="#l1.89"></a><span id="l1.89"> </span>
<a href="#l1.90"></a><span id="l1.90"> NS_IMETHODIMP nsImapFlagAndUidState::ClearCustomFlags(PRUint32 uid)</span>
<a href="#l1.91"></a><span id="l1.91"> {</span>
<a href="#l1.92"></a><span id="l1.92" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l1.93"></a><span id="l1.93" class="difflineplus">+  MutexAutoLock mon(mLock);</span>
<a href="#l1.94"></a><span id="l1.94">   m_customFlagsHash.Remove(uid);</span>
<a href="#l1.95"></a><span id="l1.95">   return NS_OK;</span>
<a href="#l1.96"></a><span id="l1.96"> }</span>
<a href="#l1.97"></a><span id="l1.97"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/imap/src/nsImapFlagAndUidState.h</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapFlagAndUidState.h</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -36,16 +36,17 @@</span>
<a href="#l2.4"></a><span id="l2.4">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l2.5"></a><span id="l2.5"> </span>
<a href="#l2.6"></a><span id="l2.6"> #ifndef nsImapFlagAndUidState_h___</span>
<a href="#l2.7"></a><span id="l2.7"> #define nsImapFlagAndUidState_h___</span>
<a href="#l2.8"></a><span id="l2.8"> </span>
<a href="#l2.9"></a><span id="l2.9"> #include &quot;MailNewsTypes.h&quot;</span>
<a href="#l2.10"></a><span id="l2.10"> #include &quot;nsTArray.h&quot;</span>
<a href="#l2.11"></a><span id="l2.11"> #include &quot;nsIImapFlagAndUidState.h&quot;</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+#include &quot;mozilla/Mutex.h&quot;</span>
<a href="#l2.13"></a><span id="l2.13"> </span>
<a href="#l2.14"></a><span id="l2.14"> const PRInt32 kImapFlagAndUidStateSize =	100;</span>
<a href="#l2.15"></a><span id="l2.15"> </span>
<a href="#l2.16"></a><span id="l2.16"> #include &quot;nsBaseHashtable.h&quot;</span>
<a href="#l2.17"></a><span id="l2.17"> #include &quot;nsDataHashtable.h&quot;</span>
<a href="#l2.18"></a><span id="l2.18"> </span>
<a href="#l2.19"></a><span id="l2.19"> class nsImapFlagAndUidState : public nsIImapFlagAndUidState</span>
<a href="#l2.20"></a><span id="l2.20"> {</span>
<a href="#l2.21"></a><span id="l2.21" class="difflineat">@@ -62,22 +63,24 @@ public:</span>
<a href="#l2.22"></a><span id="l2.22"> </span>
<a href="#l2.23"></a><span id="l2.23">     PRBool       IsLastMessageUnseen(void);</span>
<a href="#l2.24"></a><span id="l2.24">     PRBool       GetPartialUIDFetch() {return fPartialUIDFetch;}</span>
<a href="#l2.25"></a><span id="l2.25">     void         SetPartialUIDFetch(PRBool isPartial) {fPartialUIDFetch = isPartial;}</span>
<a href="#l2.26"></a><span id="l2.26">     PRUint32     GetHighestNonDeletedUID();</span>
<a href="#l2.27"></a><span id="l2.27">     PRUint16     GetSupportedUserFlags() { return fSupportedUserFlags; }</span>
<a href="#l2.28"></a><span id="l2.28"> </span>
<a href="#l2.29"></a><span id="l2.29"> private:</span>
<a href="#l2.30"></a><span id="l2.30" class="difflineminus">-    </span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+</span>
<a href="#l2.32"></a><span id="l2.32">   static PLDHashOperator FreeCustomFlags(const PRUint32 &amp;aKey, char *aData, void *closure);</span>
<a href="#l2.33"></a><span id="l2.33">     nsTArray&lt;nsMsgKey&gt;      fUids;</span>
<a href="#l2.34"></a><span id="l2.34">     nsTArray&lt;imapMessageFlagsType&gt; fFlags;</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineminus">-    nsDataHashtable&lt;nsUint32HashKey, char *&gt; m_customFlagsHash;	// Hash table, mapping uids to extra flags</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+    // Hash table, mapping uids to extra flags</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+    nsDataHashtable&lt;nsUint32HashKey, char *&gt; m_customFlagsHash;</span>
<a href="#l2.38"></a><span id="l2.38">     PRUint16                fSupportedUserFlags;</span>
<a href="#l2.39"></a><span id="l2.39">     PRInt32                 fNumberDeleted;</span>
<a href="#l2.40"></a><span id="l2.40">     PRBool                  fPartialUIDFetch;</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineplus">+    mozilla::Mutex mLock;</span>
<a href="#l2.42"></a><span id="l2.42"> };</span>
<a href="#l2.43"></a><span id="l2.43"> </span>
<a href="#l2.44"></a><span id="l2.44"> </span>
<a href="#l2.45"></a><span id="l2.45"> </span>
<a href="#l2.46"></a><span id="l2.46"> </span>
<a href="#l2.47"></a><span id="l2.47"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/imap/src/nsImapIncomingServer.cpp</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapIncomingServer.cpp</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -65,32 +65,33 @@</span>
<a href="#l3.4"></a><span id="l3.4"> #include &quot;nsIMsgWindow.h&quot;</span>
<a href="#l3.5"></a><span id="l3.5"> #include &quot;nsImapMailFolder.h&quot;</span>
<a href="#l3.6"></a><span id="l3.6"> #include &quot;nsImapUtils.h&quot;</span>
<a href="#l3.7"></a><span id="l3.7"> #include &quot;nsIRDFService.h&quot;</span>
<a href="#l3.8"></a><span id="l3.8"> #include &quot;nsRDFCID.h&quot;</span>
<a href="#l3.9"></a><span id="l3.9"> #include &quot;nsIMsgMailNewsUrl.h&quot;</span>
<a href="#l3.10"></a><span id="l3.10"> #include &quot;nsIImapService.h&quot;</span>
<a href="#l3.11"></a><span id="l3.11"> #include &quot;nsMsgI18N.h&quot;</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-#include &quot;nsAutoLock.h&quot;</span>
<a href="#l3.13"></a><span id="l3.13"> #include &quot;nsIImapMockChannel.h&quot;</span>
<a href="#l3.14"></a><span id="l3.14"> // for the memory cache...</span>
<a href="#l3.15"></a><span id="l3.15"> #include &quot;nsICacheEntryDescriptor.h&quot;</span>
<a href="#l3.16"></a><span id="l3.16"> #include &quot;nsImapUrl.h&quot;</span>
<a href="#l3.17"></a><span id="l3.17"> #include &quot;nsIMsgProtocolInfo.h&quot;</span>
<a href="#l3.18"></a><span id="l3.18"> #include &quot;nsIMsgMailSession.h&quot;</span>
<a href="#l3.19"></a><span id="l3.19"> #include &quot;nsIMAPNamespace.h&quot;</span>
<a href="#l3.20"></a><span id="l3.20"> #include &quot;nsISignatureVerifier.h&quot;</span>
<a href="#l3.21"></a><span id="l3.21"> #include &quot;nsArrayUtils.h&quot;</span>
<a href="#l3.22"></a><span id="l3.22"> #include &quot;nsITimer.h&quot;</span>
<a href="#l3.23"></a><span id="l3.23"> #include &quot;nsMsgUtils.h&quot;</span>
<a href="#l3.24"></a><span id="l3.24"> #include &quot;nsServiceManagerUtils.h&quot;</span>
<a href="#l3.25"></a><span id="l3.25"> #include &quot;nsComponentManagerUtils.h&quot;</span>
<a href="#l3.26"></a><span id="l3.26"> #include &quot;nsCRTGlue.h&quot;</span>
<a href="#l3.27"></a><span id="l3.27"> </span>
<a href="#l3.28"></a><span id="l3.28" class="difflineplus">+using namespace mozilla;</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineplus">+</span>
<a href="#l3.30"></a><span id="l3.30"> #define PREF_TRASH_FOLDER_NAME &quot;trash_folder_name&quot;</span>
<a href="#l3.31"></a><span id="l3.31"> #define DEFAULT_TRASH_FOLDER_NAME &quot;Trash&quot;</span>
<a href="#l3.32"></a><span id="l3.32"> </span>
<a href="#l3.33"></a><span id="l3.33"> static NS_DEFINE_CID(kImapProtocolCID, NS_IMAPPROTOCOL_CID);</span>
<a href="#l3.34"></a><span id="l3.34"> static NS_DEFINE_CID(kRDFServiceCID, NS_RDFSERVICE_CID);</span>
<a href="#l3.35"></a><span id="l3.35"> static NS_DEFINE_CID(kSubscribableServerCID, NS_SUBSCRIBABLESERVER_CID);</span>
<a href="#l3.36"></a><span id="l3.36"> static NS_DEFINE_CID(kCImapHostSessionListCID, NS_IIMAPHOSTSESSIONLIST_CID);</span>
<a href="#l3.37"></a><span id="l3.37"> </span>
<a href="#l3.38"></a><span id="l3.38" class="difflineat">@@ -100,16 +101,17 @@ NS_IMPL_RELEASE_INHERITED(nsImapIncoming</span>
<a href="#l3.39"></a><span id="l3.39"> NS_INTERFACE_MAP_BEGIN(nsImapIncomingServer)</span>
<a href="#l3.40"></a><span id="l3.40">   NS_INTERFACE_MAP_ENTRY(nsIImapServerSink)</span>
<a href="#l3.41"></a><span id="l3.41">   NS_INTERFACE_MAP_ENTRY(nsIImapIncomingServer)</span>
<a href="#l3.42"></a><span id="l3.42">   NS_INTERFACE_MAP_ENTRY(nsISubscribableServer)</span>
<a href="#l3.43"></a><span id="l3.43">   NS_INTERFACE_MAP_ENTRY(nsIUrlListener)</span>
<a href="#l3.44"></a><span id="l3.44"> NS_INTERFACE_MAP_END_INHERITING(nsMsgIncomingServer)</span>
<a href="#l3.45"></a><span id="l3.45"> </span>
<a href="#l3.46"></a><span id="l3.46"> nsImapIncomingServer::nsImapIncomingServer()</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+  : mLock(&quot;nsImapIncomingServer.mLock&quot;)</span>
<a href="#l3.48"></a><span id="l3.48"> {</span>
<a href="#l3.49"></a><span id="l3.49">   m_capability = kCapabilityUndefined;</span>
<a href="#l3.50"></a><span id="l3.50">   mDoingSubscribeDialog = PR_FALSE;</span>
<a href="#l3.51"></a><span id="l3.51">   mDoingLsub = PR_FALSE;</span>
<a href="#l3.52"></a><span id="l3.52">   m_canHaveFilters = PR_TRUE;</span>
<a href="#l3.53"></a><span id="l3.53">   m_userAuthenticated = PR_FALSE;</span>
<a href="#l3.54"></a><span id="l3.54">   m_shuttingDown = PR_FALSE;</span>
<a href="#l3.55"></a><span id="l3.55"> }</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineat">@@ -500,17 +502,17 @@ nsImapIncomingServer::RetryUrl(nsIImapUr</span>
<a href="#l3.57"></a><span id="l3.57"> NS_IMETHODIMP</span>
<a href="#l3.58"></a><span id="l3.58"> nsImapIncomingServer::LoadNextQueuedUrl(nsIImapProtocol *aProtocol, PRBool *aResult)</span>
<a href="#l3.59"></a><span id="l3.59"> {</span>
<a href="#l3.60"></a><span id="l3.60">   nsresult rv = NS_OK;</span>
<a href="#l3.61"></a><span id="l3.61">   PRBool urlRun = PR_FALSE;</span>
<a href="#l3.62"></a><span id="l3.62">   PRBool keepGoing = PR_TRUE;</span>
<a href="#l3.63"></a><span id="l3.63">   nsCOMPtr &lt;nsIImapProtocol&gt;  protocolInstance ;</span>
<a href="#l3.64"></a><span id="l3.64"> </span>
<a href="#l3.65"></a><span id="l3.65" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineplus">+  MutexAutoLock mon(mLock);</span>
<a href="#l3.67"></a><span id="l3.67">   PRInt32 cnt = m_urlQueue.Count();</span>
<a href="#l3.68"></a><span id="l3.68"> </span>
<a href="#l3.69"></a><span id="l3.69">   while (cnt &gt; 0 &amp;&amp; !urlRun &amp;&amp; keepGoing)</span>
<a href="#l3.70"></a><span id="l3.70">   {</span>
<a href="#l3.71"></a><span id="l3.71">     nsCOMPtr&lt;nsIImapUrl&gt; aImapUrl(m_urlQueue[0]);</span>
<a href="#l3.72"></a><span id="l3.72">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; aMailNewsUrl(do_QueryInterface(aImapUrl, &amp;rv));</span>
<a href="#l3.73"></a><span id="l3.73"> </span>
<a href="#l3.74"></a><span id="l3.74">     PRBool removeUrlFromQueue = PR_FALSE;</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineat">@@ -563,17 +565,17 @@ nsImapIncomingServer::LoadNextQueuedUrl(</span>
<a href="#l3.76"></a><span id="l3.76">   return rv;</span>
<a href="#l3.77"></a><span id="l3.77"> }</span>
<a href="#l3.78"></a><span id="l3.78"> </span>
<a href="#l3.79"></a><span id="l3.79"> NS_IMETHODIMP</span>
<a href="#l3.80"></a><span id="l3.80"> nsImapIncomingServer::AbortQueuedUrls()</span>
<a href="#l3.81"></a><span id="l3.81"> {</span>
<a href="#l3.82"></a><span id="l3.82">   nsresult rv = NS_OK;</span>
<a href="#l3.83"></a><span id="l3.83"> </span>
<a href="#l3.84"></a><span id="l3.84" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineplus">+  MutexAutoLock mon(mLock);</span>
<a href="#l3.86"></a><span id="l3.86">   PRInt32 cnt = m_urlQueue.Count();</span>
<a href="#l3.87"></a><span id="l3.87"> </span>
<a href="#l3.88"></a><span id="l3.88">   while (cnt &gt; 0)</span>
<a href="#l3.89"></a><span id="l3.89">   {</span>
<a href="#l3.90"></a><span id="l3.90">     nsCOMPtr&lt;nsIImapUrl&gt; aImapUrl(m_urlQueue[cnt - 1]);</span>
<a href="#l3.91"></a><span id="l3.91">     PRBool removeUrlFromQueue = PR_FALSE;</span>
<a href="#l3.92"></a><span id="l3.92"> </span>
<a href="#l3.93"></a><span id="l3.93">     if (aImapUrl)</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineat">@@ -633,17 +635,16 @@ nsresult nsImapIncomingServer::DoomUrlIf</span>
<a href="#l3.95"></a><span id="l3.95">   }</span>
<a href="#l3.96"></a><span id="l3.96">   return rv;</span>
<a href="#l3.97"></a><span id="l3.97"> }</span>
<a href="#l3.98"></a><span id="l3.98"> </span>
<a href="#l3.99"></a><span id="l3.99"> NS_IMETHODIMP</span>
<a href="#l3.100"></a><span id="l3.100"> nsImapIncomingServer::RemoveConnection(nsIImapProtocol* aImapConnection)</span>
<a href="#l3.101"></a><span id="l3.101"> {</span>
<a href="#l3.102"></a><span id="l3.102">   PR_CEnterMonitor(this);</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineminus">-</span>
<a href="#l3.104"></a><span id="l3.104">   if (aImapConnection)</span>
<a href="#l3.105"></a><span id="l3.105">     m_connectionCache.RemoveObject(aImapConnection);</span>
<a href="#l3.106"></a><span id="l3.106"> </span>
<a href="#l3.107"></a><span id="l3.107">   PR_CExitMonitor(this);</span>
<a href="#l3.108"></a><span id="l3.108">   return NS_OK;</span>
<a href="#l3.109"></a><span id="l3.109"> }</span>
<a href="#l3.110"></a><span id="l3.110"> </span>
<a href="#l3.111"></a><span id="l3.111"> PRBool</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/imap/src/nsImapIncomingServer.h</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapIncomingServer.h</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -43,16 +43,17 @@</span>
<a href="#l4.4"></a><span id="l4.4"> #include &quot;nsIImapIncomingServer.h&quot;</span>
<a href="#l4.5"></a><span id="l4.5"> #include &quot;nsMsgIncomingServer.h&quot;</span>
<a href="#l4.6"></a><span id="l4.6"> #include &quot;nsIImapServerSink.h&quot;</span>
<a href="#l4.7"></a><span id="l4.7"> #include &quot;nsIStringBundle.h&quot;</span>
<a href="#l4.8"></a><span id="l4.8"> #include &quot;nsISubscribableServer.h&quot;</span>
<a href="#l4.9"></a><span id="l4.9"> #include &quot;nsIUrlListener.h&quot;</span>
<a href="#l4.10"></a><span id="l4.10"> #include &quot;nsIMsgImapMailFolder.h&quot;</span>
<a href="#l4.11"></a><span id="l4.11"> #include &quot;nsCOMArray.h&quot;</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+#include &quot;mozilla/Mutex.h&quot;</span>
<a href="#l4.13"></a><span id="l4.13"> </span>
<a href="#l4.14"></a><span id="l4.14"> class nsIEventTarget;</span>
<a href="#l4.15"></a><span id="l4.15"> class nsIRDFService;</span>
<a href="#l4.16"></a><span id="l4.16"> </span>
<a href="#l4.17"></a><span id="l4.17"> /* get some implementation from nsMsgIncomingServer */</span>
<a href="#l4.18"></a><span id="l4.18"> class nsImapIncomingServer : public nsMsgIncomingServer,</span>
<a href="#l4.19"></a><span id="l4.19">                              public nsIImapIncomingServer,</span>
<a href="#l4.20"></a><span id="l4.20">                              public nsIImapServerSink,</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineat">@@ -140,16 +141,17 @@ private:</span>
<a href="#l4.22"></a><span id="l4.22">   nsVoidArray       m_urlConsumers;</span>
<a href="#l4.23"></a><span id="l4.23">   PRUint32          m_capability;</span>
<a href="#l4.24"></a><span id="l4.24">   nsCString         m_manageMailAccountUrl;</span>
<a href="#l4.25"></a><span id="l4.25">   PRPackedBool      m_userAuthenticated;</span>
<a href="#l4.26"></a><span id="l4.26">   PRPackedBool      mDoingSubscribeDialog;</span>
<a href="#l4.27"></a><span id="l4.27">   PRPackedBool      mDoingLsub;</span>
<a href="#l4.28"></a><span id="l4.28">   PRPackedBool      m_shuttingDown;</span>
<a href="#l4.29"></a><span id="l4.29"> </span>
<a href="#l4.30"></a><span id="l4.30" class="difflineplus">+  mozilla::Mutex mLock;</span>
<a href="#l4.31"></a><span id="l4.31">   // subscribe dialog stuff</span>
<a href="#l4.32"></a><span id="l4.32">   nsresult AddFolderToSubscribeDialog(const char *parentUri, const char *uri,const char *folderName);</span>
<a href="#l4.33"></a><span id="l4.33">   nsCOMPtr &lt;nsISubscribableServer&gt; mInner;</span>
<a href="#l4.34"></a><span id="l4.34">   nsresult EnsureInner();</span>
<a href="#l4.35"></a><span id="l4.35">   nsresult ClearInner();</span>
<a href="#l4.36"></a><span id="l4.36"> };</span>
<a href="#l4.37"></a><span id="l4.37"> </span>
<a href="#l4.38"></a><span id="l4.38"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -72,17 +72,16 @@</span>
<a href="#l5.4"></a><span id="l5.4"> #include &quot;nsNetUtil.h&quot;</span>
<a href="#l5.5"></a><span id="l5.5"> #include &quot;nsIDBFolderInfo.h&quot;</span>
<a href="#l5.6"></a><span id="l5.6"> #include &quot;nsIPipe.h&quot;</span>
<a href="#l5.7"></a><span id="l5.7"> #include &quot;nsIMsgFolder.h&quot;</span>
<a href="#l5.8"></a><span id="l5.8"> #include &quot;nsMsgMessageFlags.h&quot;</span>
<a href="#l5.9"></a><span id="l5.9"> #include &quot;nsImapStringBundle.h&quot;</span>
<a href="#l5.10"></a><span id="l5.10"> #include &quot;nsICopyMsgStreamListener.h&quot;</span>
<a href="#l5.11"></a><span id="l5.11"> #include &quot;nsTextFormatter.h&quot;</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-#include &quot;nsAutoLock.h&quot;</span>
<a href="#l5.13"></a><span id="l5.13"> #include &quot;nsIMsgHdr.h&quot;</span>
<a href="#l5.14"></a><span id="l5.14"> #include &quot;nsMsgI18N.h&quot;</span>
<a href="#l5.15"></a><span id="l5.15"> // for the memory cache...</span>
<a href="#l5.16"></a><span id="l5.16"> #include &quot;nsICacheEntryDescriptor.h&quot;</span>
<a href="#l5.17"></a><span id="l5.17"> #include &quot;nsICacheSession.h&quot;</span>
<a href="#l5.18"></a><span id="l5.18"> #include &quot;nsIPrompt.h&quot;</span>
<a href="#l5.19"></a><span id="l5.19"> #include &quot;nsIDocShell.h&quot;</span>
<a href="#l5.20"></a><span id="l5.20"> #include &quot;nsIDocShellLoadInfo.h&quot;</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineat">@@ -108,20 +107,20 @@ PRLogModuleInfo *IMAP;</span>
<a href="#l5.22"></a><span id="l5.22"> #include &quot;nsIStreamConverterService.h&quot;</span>
<a href="#l5.23"></a><span id="l5.23"> #include &quot;nsIProxyInfo.h&quot;</span>
<a href="#l5.24"></a><span id="l5.24"> #include &quot;nsISSLSocketControl.h&quot;</span>
<a href="#l5.25"></a><span id="l5.25"> #include &quot;nsProxyRelease.h&quot;</span>
<a href="#l5.26"></a><span id="l5.26"> #include &quot;nsDebug.h&quot;</span>
<a href="#l5.27"></a><span id="l5.27"> #include &quot;nsMsgCompressIStream.h&quot;</span>
<a href="#l5.28"></a><span id="l5.28"> #include &quot;nsMsgCompressOStream.h&quot;</span>
<a href="#l5.29"></a><span id="l5.29"> #include &quot;nsAlgorithm.h&quot;</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineplus">+using namespace mozilla;</span>
<a href="#l5.31"></a><span id="l5.31"> </span>
<a href="#l5.32"></a><span id="l5.32"> #define ONE_SECOND ((PRUint32)1000)    // one second</span>
<a href="#l5.33"></a><span id="l5.33"> </span>
<a href="#l5.34"></a><span id="l5.34" class="difflineminus">-</span>
<a href="#l5.35"></a><span id="l5.35"> #define OUTPUT_BUFFER_SIZE (4096*2) // mscott - i should be able to remove this if I can use nsMsgLineBuffer???</span>
<a href="#l5.36"></a><span id="l5.36"> </span>
<a href="#l5.37"></a><span id="l5.37"> #define IMAP_ENV_HEADERS &quot;From To Cc Bcc Subject Date Message-ID &quot;</span>
<a href="#l5.38"></a><span id="l5.38"> #define IMAP_DB_HEADERS &quot;Priority X-Priority References Newsgroups In-Reply-To Content-Type&quot;</span>
<a href="#l5.39"></a><span id="l5.39"> #define IMAP_ENV_AND_DB_HEADERS IMAP_ENV_HEADERS IMAP_DB_HEADERS</span>
<a href="#l5.40"></a><span id="l5.40"> static const PRIntervalTime kImapSleepTime = PR_MillisecondsToInterval(60000);</span>
<a href="#l5.41"></a><span id="l5.41"> static PRInt32 gPromoteNoopToCheckCount = 0;</span>
<a href="#l5.42"></a><span id="l5.42"> static const PRUint32 kFlagChangesBeforeCheck = 10;</span>
<a href="#l5.43"></a><span id="l5.43" class="difflineat">@@ -363,17 +362,27 @@ nsresult nsImapProtocol::GlobalInitializ</span>
<a href="#l5.44"></a><span id="l5.44">     aPrefBranch-&gt;GetIntPref(&quot;mail.imap.expunge_option&quot;, &amp;gExpungeOption);</span>
<a href="#l5.45"></a><span id="l5.45">     aPrefBranch-&gt;GetIntPref(&quot;mail.imap.expunge_threshold_number&quot;,</span>
<a href="#l5.46"></a><span id="l5.46">                             &amp;gExpungeThreshold);</span>
<a href="#l5.47"></a><span id="l5.47">     aPrefBranch-&gt;GetIntPref(&quot;mailnews.tcptimeout&quot;, &amp;gResponseTimeout);</span>
<a href="#l5.48"></a><span id="l5.48">     return NS_OK;</span>
<a href="#l5.49"></a><span id="l5.49"> }</span>
<a href="#l5.50"></a><span id="l5.50"> </span>
<a href="#l5.51"></a><span id="l5.51"> nsImapProtocol::nsImapProtocol() : nsMsgProtocol(nsnull),</span>
<a href="#l5.52"></a><span id="l5.52" class="difflineminus">-    m_parser(*this)</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineplus">+    mLock(&quot;nsImapProtocol.mLock&quot;),</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineplus">+    m_dataAvailableMonitor(&quot;imapDataAvailable&quot;),</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineplus">+    m_urlReadyToRunMonitor(&quot;imapUrlReadyToRun&quot;),</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+    m_pseudoInterruptMonitor(&quot;imapPseudoInterrupt&quot;),</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+    m_dataMemberMonitor(&quot;imapDataMember&quot;),</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineplus">+    m_threadDeathMonitor(&quot;imapThreadDeath&quot;),</span>
<a href="#l5.59"></a><span id="l5.59" class="difflineplus">+    m_waitForBodyIdsMonitor(&quot;imapWaitForBodyIds&quot;),</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineplus">+    m_fetchMsgListMonitor(&quot;imapFetchMsgList&quot;),</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineplus">+    m_fetchBodyListMonitor(&quot;imapFetchBodyList&quot;),</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineplus">+    m_passwordReadyMonitor(&quot;imapPasswordReady&quot;),</span>
<a href="#l5.63"></a><span id="l5.63" class="difflineplus">+     m_parser(*this)</span>
<a href="#l5.64"></a><span id="l5.64"> {</span>
<a href="#l5.65"></a><span id="l5.65">   m_urlInProgress = PR_FALSE;</span>
<a href="#l5.66"></a><span id="l5.66">   m_idle = PR_FALSE;</span>
<a href="#l5.67"></a><span id="l5.67">   m_retryUrlOnError = PR_FALSE;</span>
<a href="#l5.68"></a><span id="l5.68">   m_useIdle = PR_TRUE; // by default, use it</span>
<a href="#l5.69"></a><span id="l5.69">   m_useCondStore = PR_TRUE;</span>
<a href="#l5.70"></a><span id="l5.70">   m_useCompressDeflate = PR_TRUE;</span>
<a href="#l5.71"></a><span id="l5.71">   m_ignoreExpunges = PR_FALSE;</span>
<a href="#l5.72"></a><span id="l5.72" class="difflineat">@@ -407,25 +416,16 @@ nsImapProtocol::nsImapProtocol() : nsMsg</span>
<a href="#l5.73"></a><span id="l5.73">     prefBranch-&gt;GetCharPref(&quot;mailnews.customDBHeaders&quot;,</span>
<a href="#l5.74"></a><span id="l5.74">                             getter_Copies(customDBHeaders));</span>
<a href="#l5.75"></a><span id="l5.75"> </span>
<a href="#l5.76"></a><span id="l5.76">     ParseString(customDBHeaders, ' ', mCustomDBHeaders);</span>
<a href="#l5.77"></a><span id="l5.77">   }</span>
<a href="#l5.78"></a><span id="l5.78"> </span>
<a href="#l5.79"></a><span id="l5.79">     // ***** Thread support *****</span>
<a href="#l5.80"></a><span id="l5.80">   m_thread = nsnull;</span>
<a href="#l5.81"></a><span id="l5.81" class="difflineminus">-  m_dataAvailableMonitor = nsnull;</span>
<a href="#l5.82"></a><span id="l5.82" class="difflineminus">-  m_urlReadyToRunMonitor = nsnull;</span>
<a href="#l5.83"></a><span id="l5.83" class="difflineminus">-  m_pseudoInterruptMonitor = nsnull;</span>
<a href="#l5.84"></a><span id="l5.84" class="difflineminus">-  m_dataMemberMonitor = nsnull;</span>
<a href="#l5.85"></a><span id="l5.85" class="difflineminus">-  m_threadDeathMonitor = nsnull;</span>
<a href="#l5.86"></a><span id="l5.86" class="difflineminus">-  m_waitForBodyIdsMonitor = nsnull;</span>
<a href="#l5.87"></a><span id="l5.87" class="difflineminus">-  m_fetchMsgListMonitor = nsnull;</span>
<a href="#l5.88"></a><span id="l5.88" class="difflineminus">-  m_fetchBodyListMonitor = nsnull;</span>
<a href="#l5.89"></a><span id="l5.89" class="difflineminus">-  m_passwordReadyMonitor = nsnull;</span>
<a href="#l5.90"></a><span id="l5.90">   m_imapThreadIsRunning = PR_FALSE;</span>
<a href="#l5.91"></a><span id="l5.91">   m_currentServerCommandTagNumber = 0;</span>
<a href="#l5.92"></a><span id="l5.92">   m_active = PR_FALSE;</span>
<a href="#l5.93"></a><span id="l5.93">   m_folderNeedsSubscribing = PR_FALSE;</span>
<a href="#l5.94"></a><span id="l5.94">   m_folderNeedsACLRefreshed = PR_FALSE;</span>
<a href="#l5.95"></a><span id="l5.95">   m_threadShouldDie = PR_FALSE;</span>
<a href="#l5.96"></a><span id="l5.96">   m_inThreadShouldDie = PR_FALSE;</span>
<a href="#l5.97"></a><span id="l5.97">   m_pseudoInterrupted = PR_FALSE;</span>
<a href="#l5.98"></a><span id="l5.98" class="difflineat">@@ -528,29 +528,19 @@ nsresult nsImapProtocol::Initialize(nsII</span>
<a href="#l5.99"></a><span id="l5.99">   m_sinkEventTarget = aSinkEventTarget;</span>
<a href="#l5.100"></a><span id="l5.100">   m_hostSessionList = aHostSessionList; // no ref count...host session list has life time &gt; connection</span>
<a href="#l5.101"></a><span id="l5.101">   m_parser.SetHostSessionList(aHostSessionList);</span>
<a href="#l5.102"></a><span id="l5.102">   m_parser.SetFlagState(m_flagState);</span>
<a href="#l5.103"></a><span id="l5.103"> </span>
<a href="#l5.104"></a><span id="l5.104">   // one of the initializations that should be done in UI thread</span>
<a href="#l5.105"></a><span id="l5.105">   nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l5.106"></a><span id="l5.106"> </span>
<a href="#l5.107"></a><span id="l5.107" class="difflineminus">-  // Now initialize the thread for the connection and create appropriate monitors</span>
<a href="#l5.108"></a><span id="l5.108" class="difflineplus">+  // Now initialize the thread for the connection</span>
<a href="#l5.109"></a><span id="l5.109">   if (m_thread == nsnull)</span>
<a href="#l5.110"></a><span id="l5.110">   {</span>
<a href="#l5.111"></a><span id="l5.111" class="difflineminus">-    m_dataAvailableMonitor = PR_NewMonitor();</span>
<a href="#l5.112"></a><span id="l5.112" class="difflineminus">-    m_urlReadyToRunMonitor = PR_NewMonitor();</span>
<a href="#l5.113"></a><span id="l5.113" class="difflineminus">-    m_pseudoInterruptMonitor = PR_NewMonitor();</span>
<a href="#l5.114"></a><span id="l5.114" class="difflineminus">-    m_dataMemberMonitor = PR_NewMonitor();</span>
<a href="#l5.115"></a><span id="l5.115" class="difflineminus">-    m_threadDeathMonitor = PR_NewMonitor();</span>
<a href="#l5.116"></a><span id="l5.116" class="difflineminus">-    m_waitForBodyIdsMonitor = PR_NewMonitor();</span>
<a href="#l5.117"></a><span id="l5.117" class="difflineminus">-    m_fetchMsgListMonitor = PR_NewMonitor();</span>
<a href="#l5.118"></a><span id="l5.118" class="difflineminus">-    m_fetchBodyListMonitor = PR_NewMonitor();</span>
<a href="#l5.119"></a><span id="l5.119" class="difflineminus">-    m_passwordReadyMonitor = PR_NewMonitor();</span>
<a href="#l5.120"></a><span id="l5.120" class="difflineminus">-</span>
<a href="#l5.121"></a><span id="l5.121">     nsresult rv = NS_NewThread(getter_AddRefs(m_iThread), this);</span>
<a href="#l5.122"></a><span id="l5.122">     if (NS_FAILED(rv))</span>
<a href="#l5.123"></a><span id="l5.123">     {</span>
<a href="#l5.124"></a><span id="l5.124">       NS_ASSERTION(m_iThread, &quot;Unable to create imap thread.\n&quot;);</span>
<a href="#l5.125"></a><span id="l5.125">       return rv;</span>
<a href="#l5.126"></a><span id="l5.126">     }</span>
<a href="#l5.127"></a><span id="l5.127">     m_iThread-&gt;GetPRThread(&amp;m_thread);</span>
<a href="#l5.128"></a><span id="l5.128"> </span>
<a href="#l5.129"></a><span id="l5.129" class="difflineat">@@ -564,35 +554,16 @@ nsImapProtocol::~nsImapProtocol()</span>
<a href="#l5.130"></a><span id="l5.130"> </span>
<a href="#l5.131"></a><span id="l5.131">   NS_IF_RELEASE(m_flagState);</span>
<a href="#l5.132"></a><span id="l5.132"> </span>
<a href="#l5.133"></a><span id="l5.133">   PR_Free(m_dataOutputBuf);</span>
<a href="#l5.134"></a><span id="l5.134">   delete m_inputStreamBuffer;</span>
<a href="#l5.135"></a><span id="l5.135"> </span>
<a href="#l5.136"></a><span id="l5.136">   // **** We must be out of the thread main loop function</span>
<a href="#l5.137"></a><span id="l5.137">   NS_ASSERTION(!m_imapThreadIsRunning, &quot;Oops, thread is still running.\n&quot;);</span>
<a href="#l5.138"></a><span id="l5.138" class="difflineminus">-</span>
<a href="#l5.139"></a><span id="l5.139" class="difflineminus">-  if (m_dataAvailableMonitor)</span>
<a href="#l5.140"></a><span id="l5.140" class="difflineminus">-    PR_DestroyMonitor(m_dataAvailableMonitor);</span>
<a href="#l5.141"></a><span id="l5.141" class="difflineminus">-  if (m_urlReadyToRunMonitor)</span>
<a href="#l5.142"></a><span id="l5.142" class="difflineminus">-    PR_DestroyMonitor(m_urlReadyToRunMonitor);</span>
<a href="#l5.143"></a><span id="l5.143" class="difflineminus">-  if (m_pseudoInterruptMonitor)</span>
<a href="#l5.144"></a><span id="l5.144" class="difflineminus">-    PR_DestroyMonitor(m_pseudoInterruptMonitor);</span>
<a href="#l5.145"></a><span id="l5.145" class="difflineminus">-  if (m_dataMemberMonitor)</span>
<a href="#l5.146"></a><span id="l5.146" class="difflineminus">-    PR_DestroyMonitor(m_dataMemberMonitor);</span>
<a href="#l5.147"></a><span id="l5.147" class="difflineminus">-  if (m_threadDeathMonitor)</span>
<a href="#l5.148"></a><span id="l5.148" class="difflineminus">-    PR_DestroyMonitor(m_threadDeathMonitor);</span>
<a href="#l5.149"></a><span id="l5.149" class="difflineminus">-  if (m_waitForBodyIdsMonitor)</span>
<a href="#l5.150"></a><span id="l5.150" class="difflineminus">-    PR_DestroyMonitor(m_waitForBodyIdsMonitor);</span>
<a href="#l5.151"></a><span id="l5.151" class="difflineminus">-  if (m_fetchMsgListMonitor)</span>
<a href="#l5.152"></a><span id="l5.152" class="difflineminus">-    PR_DestroyMonitor(m_fetchMsgListMonitor);</span>
<a href="#l5.153"></a><span id="l5.153" class="difflineminus">-  if (m_fetchBodyListMonitor)</span>
<a href="#l5.154"></a><span id="l5.154" class="difflineminus">-    PR_DestroyMonitor(m_fetchBodyListMonitor);</span>
<a href="#l5.155"></a><span id="l5.155" class="difflineminus">-  if (m_passwordReadyMonitor)</span>
<a href="#l5.156"></a><span id="l5.156" class="difflineminus">-    PR_DestroyMonitor(m_passwordReadyMonitor);</span>
<a href="#l5.157"></a><span id="l5.157"> }</span>
<a href="#l5.158"></a><span id="l5.158"> </span>
<a href="#l5.159"></a><span id="l5.159"> const nsCString&amp;</span>
<a href="#l5.160"></a><span id="l5.160"> nsImapProtocol::GetImapHostName()</span>
<a href="#l5.161"></a><span id="l5.161"> {</span>
<a href="#l5.162"></a><span id="l5.162">   if (m_runningUrl &amp;&amp; m_hostName.IsEmpty())</span>
<a href="#l5.163"></a><span id="l5.163">   {</span>
<a href="#l5.164"></a><span id="l5.164">     nsCOMPtr&lt;nsIURI&gt; url = do_QueryInterface(m_runningUrl);</span>
<a href="#l5.165"></a><span id="l5.165" class="difflineat">@@ -979,36 +950,36 @@ nsresult nsImapProtocol::SetupWithUrl(ns</span>
<a href="#l5.166"></a><span id="l5.166"> }</span>
<a href="#l5.167"></a><span id="l5.167"> </span>
<a href="#l5.168"></a><span id="l5.168"> </span>
<a href="#l5.169"></a><span id="l5.169"> // when the connection is done processing the current state, free any per url state data...</span>
<a href="#l5.170"></a><span id="l5.170"> void nsImapProtocol::ReleaseUrlState(PRBool rerunning)</span>
<a href="#l5.171"></a><span id="l5.171"> {</span>
<a href="#l5.172"></a><span id="l5.172">   // clear out the socket's reference to the notification callbacks for this transaction</span>
<a href="#l5.173"></a><span id="l5.173">   {</span>
<a href="#l5.174"></a><span id="l5.174" class="difflineminus">-    nsAutoCMonitor mon(this);</span>
<a href="#l5.175"></a><span id="l5.175" class="difflineplus">+    MutexAutoLock mon(mLock);</span>
<a href="#l5.176"></a><span id="l5.176">     if (m_transport)</span>
<a href="#l5.177"></a><span id="l5.177">     {</span>
<a href="#l5.178"></a><span id="l5.178">       m_transport-&gt;SetSecurityCallbacks(nsnull);</span>
<a href="#l5.179"></a><span id="l5.179">       m_transport-&gt;SetEventSink(nsnull, nsnull);</span>
<a href="#l5.180"></a><span id="l5.180">     }</span>
<a href="#l5.181"></a><span id="l5.181">   }</span>
<a href="#l5.182"></a><span id="l5.182"> </span>
<a href="#l5.183"></a><span id="l5.183">   if (m_mockChannel &amp;&amp; !rerunning)</span>
<a href="#l5.184"></a><span id="l5.184">   {</span>
<a href="#l5.185"></a><span id="l5.185">     // Proxy the close of the channel to the ui thread.</span>
<a href="#l5.186"></a><span id="l5.186">     if (m_imapMailFolderSink)</span>
<a href="#l5.187"></a><span id="l5.187">       m_imapMailFolderSink-&gt;CloseMockChannel(m_mockChannel);</span>
<a href="#l5.188"></a><span id="l5.188">     else</span>
<a href="#l5.189"></a><span id="l5.189">       m_mockChannel-&gt;Close();</span>
<a href="#l5.190"></a><span id="l5.190"> </span>
<a href="#l5.191"></a><span id="l5.191">     {</span>
<a href="#l5.192"></a><span id="l5.192" class="difflineminus">-      // grab a monitor so m_mockChannel doesn't get cleared out</span>
<a href="#l5.193"></a><span id="l5.193" class="difflineplus">+      // grab a lock so m_mockChannel doesn't get cleared out</span>
<a href="#l5.194"></a><span id="l5.194">       // from under us.</span>
<a href="#l5.195"></a><span id="l5.195" class="difflineminus">-      nsAutoCMonitor mon(this);</span>
<a href="#l5.196"></a><span id="l5.196" class="difflineplus">+      MutexAutoLock mon(mLock);</span>
<a href="#l5.197"></a><span id="l5.197">       if (m_mockChannel)</span>
<a href="#l5.198"></a><span id="l5.198">       {</span>
<a href="#l5.199"></a><span id="l5.199">         // Proxy the release of the channel to the main thread.  This is something</span>
<a href="#l5.200"></a><span id="l5.200">         // that the xpcom proxy system should do for us!</span>
<a href="#l5.201"></a><span id="l5.201">         nsCOMPtr&lt;nsIThread&gt; thread = do_GetMainThread();</span>
<a href="#l5.202"></a><span id="l5.202">         nsIImapMockChannel *doomed = nsnull;</span>
<a href="#l5.203"></a><span id="l5.203">         m_mockChannel.swap(doomed);</span>
<a href="#l5.204"></a><span id="l5.204">         NS_ProxyRelease(thread, doomed);</span>
<a href="#l5.205"></a><span id="l5.205" class="difflineat">@@ -1017,34 +988,34 @@ void nsImapProtocol::ReleaseUrlState(PRB</span>
<a href="#l5.206"></a><span id="l5.206">   }</span>
<a href="#l5.207"></a><span id="l5.207"> </span>
<a href="#l5.208"></a><span id="l5.208">   m_channelContext = nsnull; // this might be the url - null it out before the final release of the url</span>
<a href="#l5.209"></a><span id="l5.209">   m_imapMessageSink = nsnull;</span>
<a href="#l5.210"></a><span id="l5.210"> </span>
<a href="#l5.211"></a><span id="l5.211">   // Proxy the release of the listener to the main thread.  This is something</span>
<a href="#l5.212"></a><span id="l5.212">   // that the xpcom proxy system should do for us!</span>
<a href="#l5.213"></a><span id="l5.213">   {</span>
<a href="#l5.214"></a><span id="l5.214" class="difflineminus">-    // grab a monitor so the m_channelListener doesn't get cleared.</span>
<a href="#l5.215"></a><span id="l5.215" class="difflineminus">-    nsAutoCMonitor mon(this);</span>
<a href="#l5.216"></a><span id="l5.216" class="difflineplus">+    // grab a lock so the m_channelListener doesn't get cleared.</span>
<a href="#l5.217"></a><span id="l5.217" class="difflineplus">+    MutexAutoLock mon(mLock);</span>
<a href="#l5.218"></a><span id="l5.218">     if (m_channelListener)</span>
<a href="#l5.219"></a><span id="l5.219">     {</span>
<a href="#l5.220"></a><span id="l5.220">       nsCOMPtr&lt;nsIThread&gt; thread = do_GetMainThread();</span>
<a href="#l5.221"></a><span id="l5.221">       nsIStreamListener *doomed = nsnull;</span>
<a href="#l5.222"></a><span id="l5.222">       m_channelListener.swap(doomed);</span>
<a href="#l5.223"></a><span id="l5.223">       NS_ProxyRelease(thread, doomed);</span>
<a href="#l5.224"></a><span id="l5.224">     }</span>
<a href="#l5.225"></a><span id="l5.225">   }</span>
<a href="#l5.226"></a><span id="l5.226">   m_channelInputStream = nsnull;</span>
<a href="#l5.227"></a><span id="l5.227">   m_channelOutputStream = nsnull;</span>
<a href="#l5.228"></a><span id="l5.228">   </span>
<a href="#l5.229"></a><span id="l5.229">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsurl;</span>
<a href="#l5.230"></a><span id="l5.230">   nsCOMPtr&lt;nsIImapMailFolderSink&gt; saveFolderSink;</span>
<a href="#l5.231"></a><span id="l5.231"> </span>
<a href="#l5.232"></a><span id="l5.232">   {</span>
<a href="#l5.233"></a><span id="l5.233" class="difflineminus">-    nsAutoCMonitor mon(this);</span>
<a href="#l5.234"></a><span id="l5.234" class="difflineplus">+    MutexAutoLock mon(mLock);</span>
<a href="#l5.235"></a><span id="l5.235">     if (m_runningUrl)</span>
<a href="#l5.236"></a><span id="l5.236">     {</span>
<a href="#l5.237"></a><span id="l5.237">       mailnewsurl = do_QueryInterface(m_runningUrl);</span>
<a href="#l5.238"></a><span id="l5.238">       saveFolderSink = m_imapMailFolderSink;</span>
<a href="#l5.239"></a><span id="l5.239"> </span>
<a href="#l5.240"></a><span id="l5.240">       m_runningUrl = nsnull; // force us to release our last reference on the url</span>
<a href="#l5.241"></a><span id="l5.241">       m_urlInProgress = PR_FALSE;</span>
<a href="#l5.242"></a><span id="l5.242">     }</span>
<a href="#l5.243"></a><span id="l5.243" class="difflineat">@@ -1123,42 +1094,42 @@ NS_IMETHODIMP nsImapProtocol::Run()</span>
<a href="#l5.244"></a><span id="l5.244"> //</span>
<a href="#l5.245"></a><span id="l5.245"> // Must be called from UI thread only </span>
<a href="#l5.246"></a><span id="l5.246"> //</span>
<a href="#l5.247"></a><span id="l5.247"> NS_IMETHODIMP nsImapProtocol::CloseStreams()</span>
<a href="#l5.248"></a><span id="l5.248"> {</span>
<a href="#l5.249"></a><span id="l5.249">   // make sure that it is called by the UI thread</span>
<a href="#l5.250"></a><span id="l5.250">   NS_ABORT_IF_FALSE(NS_IsMainThread(), &quot;CloseStreams() should not be called from an off UI thread&quot;);</span>
<a href="#l5.251"></a><span id="l5.251"> </span>
<a href="#l5.252"></a><span id="l5.252" class="difflineminus">-  PR_CEnterMonitor(this);</span>
<a href="#l5.253"></a><span id="l5.253" class="difflineminus">-  if (m_transport)</span>
<a href="#l5.254"></a><span id="l5.254" class="difflineminus">-  {</span>
<a href="#l5.255"></a><span id="l5.255" class="difflineminus">-      // make sure the transport closes (even if someone is still indirectly</span>
<a href="#l5.256"></a><span id="l5.256" class="difflineminus">-      // referencing it).</span>
<a href="#l5.257"></a><span id="l5.257" class="difflineminus">-      m_transport-&gt;Close(NS_ERROR_ABORT);</span>
<a href="#l5.258"></a><span id="l5.258" class="difflineminus">-      m_transport = nsnull;</span>
<a href="#l5.259"></a><span id="l5.259" class="difflineminus">-  }</span>
<a href="#l5.260"></a><span id="l5.260" class="difflineminus">-  m_inputStream = nsnull;</span>
<a href="#l5.261"></a><span id="l5.261" class="difflineminus">-  m_outputStream = nsnull;</span>
<a href="#l5.262"></a><span id="l5.262" class="difflineminus">-  m_channelListener = nsnull;</span>
<a href="#l5.263"></a><span id="l5.263" class="difflineminus">-  m_channelContext = nsnull;</span>
<a href="#l5.264"></a><span id="l5.264" class="difflineminus">-  if (m_mockChannel)</span>
<a href="#l5.265"></a><span id="l5.265" class="difflineminus">-  {</span>
<a href="#l5.266"></a><span id="l5.266" class="difflineminus">-      m_mockChannel-&gt;Close();</span>
<a href="#l5.267"></a><span id="l5.267" class="difflineminus">-      m_mockChannel = nsnull;</span>
<a href="#l5.268"></a><span id="l5.268" class="difflineminus">-  }</span>
<a href="#l5.269"></a><span id="l5.269" class="difflineminus">-  m_channelInputStream = nsnull;</span>
<a href="#l5.270"></a><span id="l5.270" class="difflineminus">-  m_channelOutputStream = nsnull;</span>
<a href="#l5.271"></a><span id="l5.271" class="difflineplus">+  {</span>
<a href="#l5.272"></a><span id="l5.272" class="difflineplus">+    MutexAutoLock mon(mLock);</span>
<a href="#l5.273"></a><span id="l5.273" class="difflineplus">+    if (m_transport)</span>
<a href="#l5.274"></a><span id="l5.274" class="difflineplus">+    {</span>
<a href="#l5.275"></a><span id="l5.275" class="difflineplus">+        // make sure the transport closes (even if someone is still indirectly</span>
<a href="#l5.276"></a><span id="l5.276" class="difflineplus">+        // referencing it).</span>
<a href="#l5.277"></a><span id="l5.277" class="difflineplus">+        m_transport-&gt;Close(NS_ERROR_ABORT);</span>
<a href="#l5.278"></a><span id="l5.278" class="difflineplus">+        m_transport = nsnull;</span>
<a href="#l5.279"></a><span id="l5.279" class="difflineplus">+    }</span>
<a href="#l5.280"></a><span id="l5.280" class="difflineplus">+    m_inputStream = nsnull;</span>
<a href="#l5.281"></a><span id="l5.281" class="difflineplus">+    m_outputStream = nsnull;</span>
<a href="#l5.282"></a><span id="l5.282" class="difflineplus">+    m_channelListener = nsnull;</span>
<a href="#l5.283"></a><span id="l5.283" class="difflineplus">+    m_channelContext = nsnull;</span>
<a href="#l5.284"></a><span id="l5.284" class="difflineplus">+    if (m_mockChannel)</span>
<a href="#l5.285"></a><span id="l5.285" class="difflineplus">+    {</span>
<a href="#l5.286"></a><span id="l5.286" class="difflineplus">+        m_mockChannel-&gt;Close();</span>
<a href="#l5.287"></a><span id="l5.287" class="difflineplus">+        m_mockChannel = nsnull;</span>
<a href="#l5.288"></a><span id="l5.288" class="difflineplus">+    }</span>
<a href="#l5.289"></a><span id="l5.289" class="difflineplus">+    m_channelInputStream = nsnull;</span>
<a href="#l5.290"></a><span id="l5.290" class="difflineplus">+    m_channelOutputStream = nsnull;</span>
<a href="#l5.291"></a><span id="l5.291" class="difflineplus">+</span>
<a href="#l5.292"></a><span id="l5.292" class="difflineplus">+    // Close scope because we must let go of the monitor before calling</span>
<a href="#l5.293"></a><span id="l5.293" class="difflineplus">+    // RemoveConnection to unblock anyone who tries to get a monitor to the</span>
<a href="#l5.294"></a><span id="l5.294" class="difflineplus">+    // protocol object while holding onto a monitor to the server.</span>
<a href="#l5.295"></a><span id="l5.295" class="difflineplus">+  }</span>
<a href="#l5.296"></a><span id="l5.296">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; me_server = do_QueryReferent(m_server);</span>
<a href="#l5.297"></a><span id="l5.297" class="difflineminus">-</span>
<a href="#l5.298"></a><span id="l5.298" class="difflineminus">-  // we must let go of the monitor before calling RemoveConnection to unblock</span>
<a href="#l5.299"></a><span id="l5.299" class="difflineminus">-  // anyone who tries to get a monitor to the protocol object while</span>
<a href="#l5.300"></a><span id="l5.300" class="difflineminus">-  // holding onto a monitor to the server.</span>
<a href="#l5.301"></a><span id="l5.301" class="difflineminus">-  PR_CExitMonitor(this);</span>
<a href="#l5.302"></a><span id="l5.302" class="difflineminus">-</span>
<a href="#l5.303"></a><span id="l5.303">   if (me_server)</span>
<a href="#l5.304"></a><span id="l5.304">   {</span>
<a href="#l5.305"></a><span id="l5.305">       nsresult result;</span>
<a href="#l5.306"></a><span id="l5.306">       nsCOMPtr&lt;nsIImapIncomingServer&gt;</span>
<a href="#l5.307"></a><span id="l5.307">           aImapServer(do_QueryInterface(me_server, &amp;result));</span>
<a href="#l5.308"></a><span id="l5.308">       if (NS_SUCCEEDED(result))</span>
<a href="#l5.309"></a><span id="l5.309">           aImapServer-&gt;RemoveConnection(this);</span>
<a href="#l5.310"></a><span id="l5.310">       me_server = nsnull;</span>
<a href="#l5.311"></a><span id="l5.311" class="difflineat">@@ -1185,57 +1156,54 @@ NS_IMETHODIMP nsImapProtocol::OnInputStr</span>
<a href="#l5.312"></a><span id="l5.312">   // should we check if it's a close vs. data available?</span>
<a href="#l5.313"></a><span id="l5.313">   if (m_idle)</span>
<a href="#l5.314"></a><span id="l5.314">   {</span>
<a href="#l5.315"></a><span id="l5.315">     PRUint32 bytesAvailable = 0;</span>
<a href="#l5.316"></a><span id="l5.316">     (void) inStr-&gt;Available(&amp;bytesAvailable);</span>
<a href="#l5.317"></a><span id="l5.317">     // check if data available - might be a close</span>
<a href="#l5.318"></a><span id="l5.318">     if (bytesAvailable != 0)</span>
<a href="#l5.319"></a><span id="l5.319">     {</span>
<a href="#l5.320"></a><span id="l5.320" class="difflineminus">-      PR_EnterMonitor(m_urlReadyToRunMonitor);</span>
<a href="#l5.321"></a><span id="l5.321" class="difflineplus">+      MonitorAutoEnter mon(m_urlReadyToRunMonitor);</span>
<a href="#l5.322"></a><span id="l5.322">       m_lastActiveTime = PR_Now();</span>
<a href="#l5.323"></a><span id="l5.323">       m_nextUrlReadyToRun = PR_TRUE;</span>
<a href="#l5.324"></a><span id="l5.324" class="difflineminus">-      PR_Notify(m_urlReadyToRunMonitor);</span>
<a href="#l5.325"></a><span id="l5.325" class="difflineminus">-      PR_ExitMonitor(m_urlReadyToRunMonitor);</span>
<a href="#l5.326"></a><span id="l5.326" class="difflineplus">+      mon.Notify();</span>
<a href="#l5.327"></a><span id="l5.327">     }</span>
<a href="#l5.328"></a><span id="l5.328">   }</span>
<a href="#l5.329"></a><span id="l5.329">   return NS_OK;</span>
<a href="#l5.330"></a><span id="l5.330"> }</span>
<a href="#l5.331"></a><span id="l5.331"> </span>
<a href="#l5.332"></a><span id="l5.332"> // this is to be called from the UI thread. It sets m_threadShouldDie,</span>
<a href="#l5.333"></a><span id="l5.333"> // and then signals the imap thread, which, when it wakes up, should exit.</span>
<a href="#l5.334"></a><span id="l5.334"> // The imap thread cleanup code will check m_safeToCloseConnection.</span>
<a href="#l5.335"></a><span id="l5.335"> NS_IMETHODIMP</span>
<a href="#l5.336"></a><span id="l5.336"> nsImapProtocol::TellThreadToDie(PRBool aIsSafeToClose)</span>
<a href="#l5.337"></a><span id="l5.337"> {</span>
<a href="#l5.338"></a><span id="l5.338">   NS_WARN_IF_FALSE(NS_IsMainThread(),</span>
<a href="#l5.339"></a><span id="l5.339">                    &quot;TellThreadToDie(aIsSafeToClose) should only be called from UI thread&quot;);</span>
<a href="#l5.340"></a><span id="l5.340" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l5.341"></a><span id="l5.341" class="difflineplus">+  MutexAutoLock mon(mLock);</span>
<a href="#l5.342"></a><span id="l5.342"> </span>
<a href="#l5.343"></a><span id="l5.343">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; me_server = do_QueryReferent(m_server);</span>
<a href="#l5.344"></a><span id="l5.344">   if (me_server)</span>
<a href="#l5.345"></a><span id="l5.345">   {</span>
<a href="#l5.346"></a><span id="l5.346">     nsresult rv;</span>
<a href="#l5.347"></a><span id="l5.347">     nsCOMPtr&lt;nsIImapIncomingServer&gt;</span>
<a href="#l5.348"></a><span id="l5.348">       aImapServer(do_QueryInterface(me_server, &amp;rv));</span>
<a href="#l5.349"></a><span id="l5.349">     if (NS_SUCCEEDED(rv))</span>
<a href="#l5.350"></a><span id="l5.350">       aImapServer-&gt;RemoveConnection(this);</span>
<a href="#l5.351"></a><span id="l5.351">     m_server = nsnull;</span>
<a href="#l5.352"></a><span id="l5.352">     me_server = nsnull;</span>
<a href="#l5.353"></a><span id="l5.353">   }</span>
<a href="#l5.354"></a><span id="l5.354" class="difflineminus">-</span>
<a href="#l5.355"></a><span id="l5.355" class="difflineminus">-  PR_EnterMonitor(m_threadDeathMonitor);</span>
<a href="#l5.356"></a><span id="l5.356" class="difflineminus">-  m_safeToCloseConnection = aIsSafeToClose;</span>
<a href="#l5.357"></a><span id="l5.357" class="difflineminus">-  m_threadShouldDie = PR_TRUE;</span>
<a href="#l5.358"></a><span id="l5.358" class="difflineminus">-  PR_ExitMonitor(m_threadDeathMonitor);</span>
<a href="#l5.359"></a><span id="l5.359" class="difflineminus">-  PR_EnterMonitor(m_urlReadyToRunMonitor);</span>
<a href="#l5.360"></a><span id="l5.360" class="difflineplus">+  {</span>
<a href="#l5.361"></a><span id="l5.361" class="difflineplus">+    MonitorAutoEnter deathMon(m_threadDeathMonitor);</span>
<a href="#l5.362"></a><span id="l5.362" class="difflineplus">+    m_safeToCloseConnection = aIsSafeToClose;</span>
<a href="#l5.363"></a><span id="l5.363" class="difflineplus">+    m_threadShouldDie = PR_TRUE;</span>
<a href="#l5.364"></a><span id="l5.364" class="difflineplus">+  }</span>
<a href="#l5.365"></a><span id="l5.365" class="difflineplus">+  MonitorAutoEnter readyMon(m_urlReadyToRunMonitor);</span>
<a href="#l5.366"></a><span id="l5.366">   m_nextUrlReadyToRun = PR_TRUE;</span>
<a href="#l5.367"></a><span id="l5.367" class="difflineminus">-  PR_Notify(m_urlReadyToRunMonitor);</span>
<a href="#l5.368"></a><span id="l5.368" class="difflineminus">-  PR_ExitMonitor(m_urlReadyToRunMonitor);</span>
<a href="#l5.369"></a><span id="l5.369" class="difflineminus">-</span>
<a href="#l5.370"></a><span id="l5.370" class="difflineplus">+  readyMon.Notify();</span>
<a href="#l5.371"></a><span id="l5.371">   return NS_OK;</span>
<a href="#l5.372"></a><span id="l5.372"> }</span>
<a href="#l5.373"></a><span id="l5.373"> </span>
<a href="#l5.374"></a><span id="l5.374"> void</span>
<a href="#l5.375"></a><span id="l5.375"> nsImapProtocol::TellThreadToDie()</span>
<a href="#l5.376"></a><span id="l5.376"> {</span>
<a href="#l5.377"></a><span id="l5.377">   nsresult rv = NS_OK;</span>
<a href="#l5.378"></a><span id="l5.378">   NS_WARN_IF_FALSE(!NS_IsMainThread(),</span>
<a href="#l5.379"></a><span id="l5.379" class="difflineat">@@ -1245,89 +1213,89 @@ nsImapProtocol::TellThreadToDie()</span>
<a href="#l5.380"></a><span id="l5.380">   if (m_inThreadShouldDie)</span>
<a href="#l5.381"></a><span id="l5.381">     return;</span>
<a href="#l5.382"></a><span id="l5.382">   m_inThreadShouldDie = PR_TRUE;</span>
<a href="#l5.383"></a><span id="l5.383"> </span>
<a href="#l5.384"></a><span id="l5.384">   // This routine is called only from the imap protocol thread.</span>
<a href="#l5.385"></a><span id="l5.385">   // The UI thread causes this to be called by calling TellThreadToDie.</span>
<a href="#l5.386"></a><span id="l5.386">   // In that case, m_safeToCloseConnection will be FALSE if it's dropping a</span>
<a href="#l5.387"></a><span id="l5.387">   // timed out connection, true when closing a cached connection.</span>
<a href="#l5.388"></a><span id="l5.388" class="difflineminus">-  {</span>
<a href="#l5.389"></a><span id="l5.389" class="difflineminus">-    nsAutoCMonitor mon(this);</span>
<a href="#l5.390"></a><span id="l5.390" class="difflineminus">-</span>
<a href="#l5.391"></a><span id="l5.391" class="difflineminus">-    m_urlInProgress = PR_TRUE;  // let's say it's busy so no one tries to use</span>
<a href="#l5.392"></a><span id="l5.392" class="difflineplus">+  // We're using PR_CEnter/ExitMonitor because Monitors don't like having</span>
<a href="#l5.393"></a><span id="l5.393" class="difflineplus">+  // us to hold one monitor and call code that gets a different monitor. And</span>
<a href="#l5.394"></a><span id="l5.394" class="difflineplus">+  // some of the methods we call here use Monitors.</span>
<a href="#l5.395"></a><span id="l5.395" class="difflineplus">+  PR_CEnterMonitor(this);</span>
<a href="#l5.396"></a><span id="l5.396" class="difflineplus">+</span>
<a href="#l5.397"></a><span id="l5.397" class="difflineplus">+  m_urlInProgress = PR_TRUE;  // let's say it's busy so no one tries to use</span>
<a href="#l5.398"></a><span id="l5.398">                                 // this about to die connection.</span>
<a href="#l5.399"></a><span id="l5.399" class="difflineminus">-    PRBool urlWritingData = PR_FALSE;</span>
<a href="#l5.400"></a><span id="l5.400" class="difflineminus">-    PRBool connectionIdle = !m_runningUrl;</span>
<a href="#l5.401"></a><span id="l5.401" class="difflineminus">-</span>
<a href="#l5.402"></a><span id="l5.402" class="difflineminus">-    if (!connectionIdle)</span>
<a href="#l5.403"></a><span id="l5.403" class="difflineminus">-      urlWritingData = m_imapAction == nsIImapUrl::nsImapAppendMsgFromFile</span>
<a href="#l5.404"></a><span id="l5.404" class="difflineminus">-        || m_imapAction == nsIImapUrl::nsImapAppendDraftFromFile;</span>
<a href="#l5.405"></a><span id="l5.405" class="difflineminus">-</span>
<a href="#l5.406"></a><span id="l5.406" class="difflineminus">-    PRBool closeNeeded = GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l5.407"></a><span id="l5.407" class="difflineminus">-                  nsImapServerResponseParser::kFolderSelected &amp;&amp; m_safeToCloseConnection;</span>
<a href="#l5.408"></a><span id="l5.408" class="difflineminus">-    nsCString command;</span>
<a href="#l5.409"></a><span id="l5.409" class="difflineminus">-</span>
<a href="#l5.410"></a><span id="l5.410" class="difflineminus">-    // if a url is writing data, we can't even logout, so we're just</span>
<a href="#l5.411"></a><span id="l5.411" class="difflineminus">-    // going to close the connection as if the user pressed stop.</span>
<a href="#l5.412"></a><span id="l5.412" class="difflineminus">-    if (m_currentServerCommandTagNumber &gt; 0 &amp;&amp; !urlWritingData)</span>
<a href="#l5.413"></a><span id="l5.413" class="difflineminus">-    {</span>
<a href="#l5.414"></a><span id="l5.414" class="difflineminus">-      PRBool isAlive = PR_FALSE;</span>
<a href="#l5.415"></a><span id="l5.415" class="difflineminus">-      if (m_transport)</span>
<a href="#l5.416"></a><span id="l5.416" class="difflineminus">-        rv = m_transport-&gt;IsAlive(&amp;isAlive);</span>
<a href="#l5.417"></a><span id="l5.417" class="difflineminus">-</span>
<a href="#l5.418"></a><span id="l5.418" class="difflineminus">-      if (TestFlag(IMAP_CONNECTION_IS_OPEN) &amp;&amp; m_idle &amp;&amp; isAlive)</span>
<a href="#l5.419"></a><span id="l5.419" class="difflineminus">-        EndIdle(PR_FALSE);</span>
<a href="#l5.420"></a><span id="l5.420" class="difflineminus">-</span>
<a href="#l5.421"></a><span id="l5.421" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; isAlive &amp;&amp; closeNeeded &amp;&amp; GetDeleteIsMoveToTrash() &amp;&amp;</span>
<a href="#l5.422"></a><span id="l5.422" class="difflineminus">-          TestFlag(IMAP_CONNECTION_IS_OPEN) &amp;&amp; m_outputStream)</span>
<a href="#l5.423"></a><span id="l5.423" class="difflineminus">-        Close(PR_TRUE, connectionIdle);</span>
<a href="#l5.424"></a><span id="l5.424" class="difflineminus">-</span>
<a href="#l5.425"></a><span id="l5.425" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; isAlive &amp;&amp; TestFlag(IMAP_CONNECTION_IS_OPEN) &amp;&amp; </span>
<a href="#l5.426"></a><span id="l5.426" class="difflineminus">-          NS_SUCCEEDED(GetConnectionStatus()) &amp;&amp; m_outputStream)</span>
<a href="#l5.427"></a><span id="l5.427" class="difflineminus">-        Logout(PR_TRUE, connectionIdle);</span>
<a href="#l5.428"></a><span id="l5.428" class="difflineminus">-    }</span>
<a href="#l5.429"></a><span id="l5.429" class="difflineminus">-  }</span>
<a href="#l5.430"></a><span id="l5.430" class="difflineplus">+  PRBool urlWritingData = PR_FALSE;</span>
<a href="#l5.431"></a><span id="l5.431" class="difflineplus">+  PRBool connectionIdle = !m_runningUrl;</span>
<a href="#l5.432"></a><span id="l5.432" class="difflineplus">+</span>
<a href="#l5.433"></a><span id="l5.433" class="difflineplus">+  if (!connectionIdle)</span>
<a href="#l5.434"></a><span id="l5.434" class="difflineplus">+    urlWritingData = m_imapAction == nsIImapUrl::nsImapAppendMsgFromFile</span>
<a href="#l5.435"></a><span id="l5.435" class="difflineplus">+      || m_imapAction == nsIImapUrl::nsImapAppendDraftFromFile;</span>
<a href="#l5.436"></a><span id="l5.436" class="difflineplus">+</span>
<a href="#l5.437"></a><span id="l5.437" class="difflineplus">+  PRBool closeNeeded = GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l5.438"></a><span id="l5.438" class="difflineplus">+                nsImapServerResponseParser::kFolderSelected &amp;&amp; m_safeToCloseConnection;</span>
<a href="#l5.439"></a><span id="l5.439" class="difflineplus">+  nsCString command;</span>
<a href="#l5.440"></a><span id="l5.440" class="difflineplus">+  // if a url is writing data, we can't even logout, so we're just</span>
<a href="#l5.441"></a><span id="l5.441" class="difflineplus">+  // going to close the connection as if the user pressed stop.</span>
<a href="#l5.442"></a><span id="l5.442" class="difflineplus">+  if (m_currentServerCommandTagNumber &gt; 0 &amp;&amp; !urlWritingData)</span>
<a href="#l5.443"></a><span id="l5.443" class="difflineplus">+  {</span>
<a href="#l5.444"></a><span id="l5.444" class="difflineplus">+    PRBool isAlive = PR_FALSE;</span>
<a href="#l5.445"></a><span id="l5.445" class="difflineplus">+    if (m_transport)</span>
<a href="#l5.446"></a><span id="l5.446" class="difflineplus">+      rv = m_transport-&gt;IsAlive(&amp;isAlive);</span>
<a href="#l5.447"></a><span id="l5.447" class="difflineplus">+</span>
<a href="#l5.448"></a><span id="l5.448" class="difflineplus">+    if (TestFlag(IMAP_CONNECTION_IS_OPEN) &amp;&amp; m_idle &amp;&amp; isAlive)</span>
<a href="#l5.449"></a><span id="l5.449" class="difflineplus">+      EndIdle(PR_FALSE);</span>
<a href="#l5.450"></a><span id="l5.450" class="difflineplus">+</span>
<a href="#l5.451"></a><span id="l5.451" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; isAlive &amp;&amp; closeNeeded &amp;&amp; GetDeleteIsMoveToTrash() &amp;&amp;</span>
<a href="#l5.452"></a><span id="l5.452" class="difflineplus">+        TestFlag(IMAP_CONNECTION_IS_OPEN) &amp;&amp; m_outputStream)</span>
<a href="#l5.453"></a><span id="l5.453" class="difflineplus">+      Close(PR_TRUE, connectionIdle);</span>
<a href="#l5.454"></a><span id="l5.454" class="difflineplus">+</span>
<a href="#l5.455"></a><span id="l5.455" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; isAlive &amp;&amp; TestFlag(IMAP_CONNECTION_IS_OPEN) &amp;&amp; </span>
<a href="#l5.456"></a><span id="l5.456" class="difflineplus">+        NS_SUCCEEDED(GetConnectionStatus()) &amp;&amp; m_outputStream)</span>
<a href="#l5.457"></a><span id="l5.457" class="difflineplus">+      Logout(PR_TRUE, connectionIdle);</span>
<a href="#l5.458"></a><span id="l5.458" class="difflineplus">+  }</span>
<a href="#l5.459"></a><span id="l5.459" class="difflineplus">+  PR_CExitMonitor(this);</span>
<a href="#l5.460"></a><span id="l5.460">   // close streams via UI thread</span>
<a href="#l5.461"></a><span id="l5.461">   if (m_imapProtocolSink) </span>
<a href="#l5.462"></a><span id="l5.462">   {</span>
<a href="#l5.463"></a><span id="l5.463">     m_imapProtocolSink-&gt;CloseStreams();</span>
<a href="#l5.464"></a><span id="l5.464">     m_imapProtocolSink = nsnull;</span>
<a href="#l5.465"></a><span id="l5.465">   }</span>
<a href="#l5.466"></a><span id="l5.466">   Log(&quot;TellThreadToDie&quot;, nsnull, &quot;close socket connection&quot;);</span>
<a href="#l5.467"></a><span id="l5.467"> </span>
<a href="#l5.468"></a><span id="l5.468" class="difflineminus">-  PR_EnterMonitor(m_threadDeathMonitor);</span>
<a href="#l5.469"></a><span id="l5.469" class="difflineminus">-  m_threadShouldDie = PR_TRUE;</span>
<a href="#l5.470"></a><span id="l5.470" class="difflineminus">-  PR_ExitMonitor(m_threadDeathMonitor);</span>
<a href="#l5.471"></a><span id="l5.471" class="difflineminus">-</span>
<a href="#l5.472"></a><span id="l5.472" class="difflineminus">-  PR_EnterMonitor(m_dataAvailableMonitor);</span>
<a href="#l5.473"></a><span id="l5.473" class="difflineminus">-  PR_Notify(m_dataAvailableMonitor);</span>
<a href="#l5.474"></a><span id="l5.474" class="difflineminus">-  PR_ExitMonitor(m_dataAvailableMonitor);</span>
<a href="#l5.475"></a><span id="l5.475" class="difflineminus">-</span>
<a href="#l5.476"></a><span id="l5.476" class="difflineminus">-  PR_EnterMonitor(m_urlReadyToRunMonitor);</span>
<a href="#l5.477"></a><span id="l5.477" class="difflineminus">-  PR_NotifyAll(m_urlReadyToRunMonitor);</span>
<a href="#l5.478"></a><span id="l5.478" class="difflineminus">-  PR_ExitMonitor(m_urlReadyToRunMonitor);</span>
<a href="#l5.479"></a><span id="l5.479" class="difflineplus">+  {</span>
<a href="#l5.480"></a><span id="l5.480" class="difflineplus">+    MonitorAutoEnter mon(m_threadDeathMonitor);</span>
<a href="#l5.481"></a><span id="l5.481" class="difflineplus">+    m_threadShouldDie = PR_TRUE;</span>
<a href="#l5.482"></a><span id="l5.482" class="difflineplus">+  }</span>
<a href="#l5.483"></a><span id="l5.483" class="difflineplus">+  {</span>
<a href="#l5.484"></a><span id="l5.484" class="difflineplus">+    MonitorAutoEnter dataMon(m_dataAvailableMonitor);</span>
<a href="#l5.485"></a><span id="l5.485" class="difflineplus">+    dataMon.Notify();</span>
<a href="#l5.486"></a><span id="l5.486" class="difflineplus">+  }</span>
<a href="#l5.487"></a><span id="l5.487" class="difflineplus">+  MonitorAutoEnter urlReadyMon(m_urlReadyToRunMonitor);</span>
<a href="#l5.488"></a><span id="l5.488" class="difflineplus">+  urlReadyMon.NotifyAll();</span>
<a href="#l5.489"></a><span id="l5.489"> }</span>
<a href="#l5.490"></a><span id="l5.490"> </span>
<a href="#l5.491"></a><span id="l5.491"> NS_IMETHODIMP</span>
<a href="#l5.492"></a><span id="l5.492"> nsImapProtocol::GetLastActiveTimeStamp(PRTime* aTimeStamp)</span>
<a href="#l5.493"></a><span id="l5.493"> {</span>
<a href="#l5.494"></a><span id="l5.494">   if (aTimeStamp)</span>
<a href="#l5.495"></a><span id="l5.495" class="difflineminus">-      *aTimeStamp = m_lastActiveTime;</span>
<a href="#l5.496"></a><span id="l5.496" class="difflineplus">+    *aTimeStamp = m_lastActiveTime;</span>
<a href="#l5.497"></a><span id="l5.497">   return NS_OK;</span>
<a href="#l5.498"></a><span id="l5.498"> }</span>
<a href="#l5.499"></a><span id="l5.499"> </span>
<a href="#l5.500"></a><span id="l5.500"> NS_IMETHODIMP</span>
<a href="#l5.501"></a><span id="l5.501"> nsImapProtocol::PseudoInterruptMsgLoad(nsIMsgFolder *aImapFolder, nsIMsgWindow *aMsgWindow, PRBool *interrupted)</span>
<a href="#l5.502"></a><span id="l5.502"> {</span>
<a href="#l5.503"></a><span id="l5.503">   NS_ENSURE_ARG (interrupted);</span>
<a href="#l5.504"></a><span id="l5.504"> </span>
<a href="#l5.505"></a><span id="l5.505">   *interrupted = PR_FALSE;</span>
<a href="#l5.506"></a><span id="l5.506"> </span>
<a href="#l5.507"></a><span id="l5.507" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l5.508"></a><span id="l5.508" class="difflineplus">+  PR_CEnterMonitor(this);</span>
<a href="#l5.509"></a><span id="l5.509"> </span>
<a href="#l5.510"></a><span id="l5.510">   if (m_runningUrl &amp;&amp; !TestFlag(IMAP_CLEAN_UP_URL_STATE))</span>
<a href="#l5.511"></a><span id="l5.511">   {</span>
<a href="#l5.512"></a><span id="l5.512">     nsImapAction imapAction;</span>
<a href="#l5.513"></a><span id="l5.513">     m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l5.514"></a><span id="l5.514"> </span>
<a href="#l5.515"></a><span id="l5.515">     if (imapAction == nsIImapUrl::nsImapMsgFetch)</span>
<a href="#l5.516"></a><span id="l5.516">     {</span>
<a href="#l5.517"></a><span id="l5.517" class="difflineat">@@ -1345,16 +1313,17 @@ nsImapProtocol::PseudoInterruptMsgLoad(n</span>
<a href="#l5.518"></a><span id="l5.518">         if (aImapFolder == runningImapFolder &amp;&amp; msgWindow == aMsgWindow)</span>
<a href="#l5.519"></a><span id="l5.519">         {</span>
<a href="#l5.520"></a><span id="l5.520">           PseudoInterrupt(PR_TRUE);</span>
<a href="#l5.521"></a><span id="l5.521">           *interrupted = PR_TRUE;</span>
<a href="#l5.522"></a><span id="l5.522">         }</span>
<a href="#l5.523"></a><span id="l5.523">       }</span>
<a href="#l5.524"></a><span id="l5.524">     }</span>
<a href="#l5.525"></a><span id="l5.525">   }</span>
<a href="#l5.526"></a><span id="l5.526" class="difflineplus">+  PR_CExitMonitor(this);</span>
<a href="#l5.527"></a><span id="l5.527"> #ifdef DEBUG_bienvenu</span>
<a href="#l5.528"></a><span id="l5.528">   printf(&quot;interrupt msg load : %s\n&quot;, (*interrupted) ? &quot;TRUE&quot; : &quot;FALSE&quot;);</span>
<a href="#l5.529"></a><span id="l5.529"> #endif</span>
<a href="#l5.530"></a><span id="l5.530">   return NS_OK;</span>
<a href="#l5.531"></a><span id="l5.531"> }</span>
<a href="#l5.532"></a><span id="l5.532"> </span>
<a href="#l5.533"></a><span id="l5.533"> void</span>
<a href="#l5.534"></a><span id="l5.534"> nsImapProtocol::ImapThreadMainLoop()</span>
<a href="#l5.535"></a><span id="l5.535" class="difflineat">@@ -1364,17 +1333,17 @@ nsImapProtocol::ImapThreadMainLoop()</span>
<a href="#l5.536"></a><span id="l5.536">   PRIntervalTime sleepTime = kImapSleepTime;</span>
<a href="#l5.537"></a><span id="l5.537">   while (!DeathSignalReceived())</span>
<a href="#l5.538"></a><span id="l5.538">   {</span>
<a href="#l5.539"></a><span id="l5.539">     nsresult rv = NS_OK;</span>
<a href="#l5.540"></a><span id="l5.540">     PRBool readyToRun;</span>
<a href="#l5.541"></a><span id="l5.541"> </span>
<a href="#l5.542"></a><span id="l5.542">     // wait for an URL to process...</span>
<a href="#l5.543"></a><span id="l5.543">     {</span>
<a href="#l5.544"></a><span id="l5.544" class="difflineminus">-      nsAutoMonitor mon(m_urlReadyToRunMonitor);</span>
<a href="#l5.545"></a><span id="l5.545" class="difflineplus">+      MonitorAutoEnter mon(m_urlReadyToRunMonitor);</span>
<a href="#l5.546"></a><span id="l5.546"> </span>
<a href="#l5.547"></a><span id="l5.547">       while (NS_SUCCEEDED(rv) &amp;&amp; !DeathSignalReceived() &amp;&amp;</span>
<a href="#l5.548"></a><span id="l5.548">              !m_nextUrlReadyToRun &amp;&amp; !m_threadShouldDie)</span>
<a href="#l5.549"></a><span id="l5.549">         rv = mon.Wait(sleepTime);</span>
<a href="#l5.550"></a><span id="l5.550"> </span>
<a href="#l5.551"></a><span id="l5.551">       readyToRun = m_nextUrlReadyToRun;</span>
<a href="#l5.552"></a><span id="l5.552">       m_nextUrlReadyToRun = PR_FALSE;</span>
<a href="#l5.553"></a><span id="l5.553">     }</span>
<a href="#l5.554"></a><span id="l5.554" class="difflineat">@@ -1886,31 +1855,32 @@ PRBool nsImapProtocol::ProcessCurrentURL</span>
<a href="#l5.555"></a><span id="l5.555">         m_useIdle = PR_FALSE;</span>
<a href="#l5.556"></a><span id="l5.556">     }</span>
<a href="#l5.557"></a><span id="l5.557">   }</span>
<a href="#l5.558"></a><span id="l5.558">   return anotherUrlRun;</span>
<a href="#l5.559"></a><span id="l5.559"> }</span>
<a href="#l5.560"></a><span id="l5.560"> </span>
<a href="#l5.561"></a><span id="l5.561"> PRBool nsImapProtocol::RetryUrl()</span>
<a href="#l5.562"></a><span id="l5.562"> {</span>
<a href="#l5.563"></a><span id="l5.563" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l5.564"></a><span id="l5.564" class="difflineplus">+  PR_CEnterMonitor(this);</span>
<a href="#l5.565"></a><span id="l5.565">   nsCOMPtr &lt;nsIImapUrl&gt; kungFuGripImapUrl = m_runningUrl;</span>
<a href="#l5.566"></a><span id="l5.566">   nsCOMPtr &lt;nsIImapMockChannel&gt; saveMockChannel;</span>
<a href="#l5.567"></a><span id="l5.567" class="difflineminus">-  </span>
<a href="#l5.568"></a><span id="l5.568" class="difflineplus">+</span>
<a href="#l5.569"></a><span id="l5.569">   // the mock channel might be null - that's OK.</span>
<a href="#l5.570"></a><span id="l5.570">   if (m_imapServerSink)</span>
<a href="#l5.571"></a><span id="l5.571">     (void) m_imapServerSink-&gt;PrepareToRetryUrl(kungFuGripImapUrl, getter_AddRefs(saveMockChannel));</span>
<a href="#l5.572"></a><span id="l5.572" class="difflineminus">-  </span>
<a href="#l5.573"></a><span id="l5.573" class="difflineplus">+</span>
<a href="#l5.574"></a><span id="l5.574">   ReleaseUrlState(PR_TRUE);</span>
<a href="#l5.575"></a><span id="l5.575">   nsresult rv;</span>
<a href="#l5.576"></a><span id="l5.576">   nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer  = do_QueryReferent(m_server, &amp;rv);</span>
<a href="#l5.577"></a><span id="l5.577">   if (NS_SUCCEEDED(rv))</span>
<a href="#l5.578"></a><span id="l5.578">     imapServer-&gt;RemoveConnection(this);</span>
<a href="#l5.579"></a><span id="l5.579">   if (m_imapServerSink)</span>
<a href="#l5.580"></a><span id="l5.580">     m_imapServerSink-&gt;RetryUrl(kungFuGripImapUrl, saveMockChannel);</span>
<a href="#l5.581"></a><span id="l5.581" class="difflineplus">+  PR_CExitMonitor(this);</span>
<a href="#l5.582"></a><span id="l5.582">   return (m_imapServerSink != nsnull); // we're running a url (the same url)</span>
<a href="#l5.583"></a><span id="l5.583"> }</span>
<a href="#l5.584"></a><span id="l5.584"> </span>
<a href="#l5.585"></a><span id="l5.585"> // ignoreBadAndNOResponses --&gt; don't throw a error dialog if this command results in a NO or Bad response</span>
<a href="#l5.586"></a><span id="l5.586"> // from the server..in other words the command is &quot;exploratory&quot; and we don't really care if it succeeds or fails.</span>
<a href="#l5.587"></a><span id="l5.587"> void nsImapProtocol::ParseIMAPandCheckForNewMail(const char* commandString, PRBool aIgnoreBadAndNOResponses)</span>
<a href="#l5.588"></a><span id="l5.588"> {</span>
<a href="#l5.589"></a><span id="l5.589">     if (commandString)</span>
<a href="#l5.590"></a><span id="l5.590" class="difflineat">@@ -1971,20 +1941,21 @@ nsresult nsImapProtocol::SendData(const </span>
<a href="#l5.591"></a><span id="l5.591">     if (!aSuppressLogging)</span>
<a href="#l5.592"></a><span id="l5.592">       Log(&quot;SendData&quot;, nsnull, dataBuffer);</span>
<a href="#l5.593"></a><span id="l5.593">     else</span>
<a href="#l5.594"></a><span id="l5.594">       Log(&quot;SendData&quot;, nsnull, &quot;Logging suppressed for this command (it probably contained authentication information)&quot;);</span>
<a href="#l5.595"></a><span id="l5.595"> </span>
<a href="#l5.596"></a><span id="l5.596">     {</span>
<a href="#l5.597"></a><span id="l5.597">       // don't allow someone to close the stream/transport out from under us</span>
<a href="#l5.598"></a><span id="l5.598">       // this can happen when the ui thread calls TellThreadToDie.</span>
<a href="#l5.599"></a><span id="l5.599" class="difflineminus">-      nsAutoCMonitor mon(this);</span>
<a href="#l5.600"></a><span id="l5.600" class="difflineplus">+      PR_CEnterMonitor(this);</span>
<a href="#l5.601"></a><span id="l5.601">       PRUint32 n;</span>
<a href="#l5.602"></a><span id="l5.602">       if (m_outputStream)</span>
<a href="#l5.603"></a><span id="l5.603">         rv = m_outputStream-&gt;Write(dataBuffer, PL_strlen(dataBuffer), &amp;n);</span>
<a href="#l5.604"></a><span id="l5.604" class="difflineplus">+      PR_CExitMonitor(this);</span>
<a href="#l5.605"></a><span id="l5.605">     }</span>
<a href="#l5.606"></a><span id="l5.606">     if (NS_FAILED(rv))</span>
<a href="#l5.607"></a><span id="l5.607">     {</span>
<a href="#l5.608"></a><span id="l5.608">       Log(&quot;SendData&quot;, nsnull, &quot;clearing IMAP_CONNECTION_IS_OPEN&quot;);</span>
<a href="#l5.609"></a><span id="l5.609">       // the connection died unexpectedly! so clear the open connection flag</span>
<a href="#l5.610"></a><span id="l5.610">       ClearFlag(IMAP_CONNECTION_IS_OPEN);</span>
<a href="#l5.611"></a><span id="l5.611">       TellThreadToDie();</span>
<a href="#l5.612"></a><span id="l5.612">       SetConnectionStatus(rv);</span>
<a href="#l5.613"></a><span id="l5.613" class="difflineat">@@ -2109,20 +2080,19 @@ NS_IMETHODIMP nsImapProtocol::LoadImapUr</span>
<a href="#l5.614"></a><span id="l5.614"> </span>
<a href="#l5.615"></a><span id="l5.615">       // if we're running a select or delete all, do a noop first.</span>
<a href="#l5.616"></a><span id="l5.616">       // this should really be in the connection cache code when we know</span>
<a href="#l5.617"></a><span id="l5.617">       // we're pulling out a selected state connection, but maybe we</span>
<a href="#l5.618"></a><span id="l5.618">       // can get away with this.</span>
<a href="#l5.619"></a><span id="l5.619">       m_needNoop = (imapAction == nsIImapUrl::nsImapSelectFolder || imapAction == nsIImapUrl::nsImapDeleteAllMsgs);</span>
<a href="#l5.620"></a><span id="l5.620"> </span>
<a href="#l5.621"></a><span id="l5.621">       // We now have a url to run so signal the monitor for url ready to be processed...</span>
<a href="#l5.622"></a><span id="l5.622" class="difflineminus">-      PR_EnterMonitor(m_urlReadyToRunMonitor);</span>
<a href="#l5.623"></a><span id="l5.623" class="difflineplus">+      MonitorAutoEnter urlReadyMon(m_urlReadyToRunMonitor);</span>
<a href="#l5.624"></a><span id="l5.624">       m_nextUrlReadyToRun = PR_TRUE;</span>
<a href="#l5.625"></a><span id="l5.625" class="difflineminus">-      PR_Notify(m_urlReadyToRunMonitor);</span>
<a href="#l5.626"></a><span id="l5.626" class="difflineminus">-      PR_ExitMonitor(m_urlReadyToRunMonitor);</span>
<a href="#l5.627"></a><span id="l5.627" class="difflineplus">+      urlReadyMon.Notify();</span>
<a href="#l5.628"></a><span id="l5.628"> </span>
<a href="#l5.629"></a><span id="l5.629">     } // if we have an imap url and a transport</span>
<a href="#l5.630"></a><span id="l5.630">     else</span>
<a href="#l5.631"></a><span id="l5.631">       NS_ASSERTION(PR_FALSE, &quot;missing channel or running url&quot;);</span>
<a href="#l5.632"></a><span id="l5.632"> </span>
<a href="#l5.633"></a><span id="l5.633">   } // if we received a url!</span>
<a href="#l5.634"></a><span id="l5.634"> </span>
<a href="#l5.635"></a><span id="l5.635">   return rv;</span>
<a href="#l5.636"></a><span id="l5.636" class="difflineat">@@ -2157,49 +2127,51 @@ NS_IMETHODIMP nsImapProtocol::IsBusy(PRB</span>
<a href="#l5.637"></a><span id="l5.637">   NS_UNLOCK_INSTANCE();</span>
<a href="#l5.638"></a><span id="l5.638">   return rv;</span>
<a href="#l5.639"></a><span id="l5.639"> }</span>
<a href="#l5.640"></a><span id="l5.640"> </span>
<a href="#l5.641"></a><span id="l5.641"> #define IS_SUBSCRIPTION_RELATED_ACTION(action) (action == nsIImapUrl::nsImapSubscribe\</span>
<a href="#l5.642"></a><span id="l5.642"> || action == nsIImapUrl::nsImapUnsubscribe || action == nsIImapUrl::nsImapDiscoverAllBoxesUrl || action == nsIImapUrl::nsImapListFolder)</span>
<a href="#l5.643"></a><span id="l5.643"> </span>
<a href="#l5.644"></a><span id="l5.644"> </span>
<a href="#l5.645"></a><span id="l5.645" class="difflineminus">-// canRunUrl means the connection is not busy, and is in the selcted state</span>
<a href="#l5.646"></a><span id="l5.646" class="difflineplus">+// canRunUrl means the connection is not busy, and is in the selected state</span>
<a href="#l5.647"></a><span id="l5.647"> // for the desired folder (or authenticated).</span>
<a href="#l5.648"></a><span id="l5.648"> // has to wait means it's in the right selected state, but busy.</span>
<a href="#l5.649"></a><span id="l5.649"> NS_IMETHODIMP nsImapProtocol::CanHandleUrl(nsIImapUrl * aImapUrl,</span>
<a href="#l5.650"></a><span id="l5.650">                                            PRBool * aCanRunUrl,</span>
<a href="#l5.651"></a><span id="l5.651">                                            PRBool * hasToWait)</span>
<a href="#l5.652"></a><span id="l5.652"> {</span>
<a href="#l5.653"></a><span id="l5.653">   if (!aCanRunUrl || !hasToWait || !aImapUrl)</span>
<a href="#l5.654"></a><span id="l5.654">     return NS_ERROR_NULL_POINTER;</span>
<a href="#l5.655"></a><span id="l5.655">   nsresult rv = NS_OK;</span>
<a href="#l5.656"></a><span id="l5.656" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l5.657"></a><span id="l5.657" class="difflineplus">+  MutexAutoLock mon(mLock);</span>
<a href="#l5.658"></a><span id="l5.658"> </span>
<a href="#l5.659"></a><span id="l5.659">   *aCanRunUrl = PR_FALSE; // assume guilty until proven otherwise...</span>
<a href="#l5.660"></a><span id="l5.660">   *hasToWait = PR_FALSE;</span>
<a href="#l5.661"></a><span id="l5.661"> </span>
<a href="#l5.662"></a><span id="l5.662">   if (DeathSignalReceived())</span>
<a href="#l5.663"></a><span id="l5.663">     return NS_ERROR_FAILURE;</span>
<a href="#l5.664"></a><span id="l5.664" class="difflineplus">+</span>
<a href="#l5.665"></a><span id="l5.665">   PRBool isBusy = PR_FALSE;</span>
<a href="#l5.666"></a><span id="l5.666">   PRBool isInboxConnection = PR_FALSE;</span>
<a href="#l5.667"></a><span id="l5.667"> </span>
<a href="#l5.668"></a><span id="l5.668">   if (!m_transport)</span>
<a href="#l5.669"></a><span id="l5.669">   {</span>
<a href="#l5.670"></a><span id="l5.670">     // this connection might not be fully set up yet.</span>
<a href="#l5.671"></a><span id="l5.671">     return NS_ERROR_FAILURE;</span>
<a href="#l5.672"></a><span id="l5.672">   }</span>
<a href="#l5.673"></a><span id="l5.673">   else if (m_currentServerCommandTagNumber != 0)</span>
<a href="#l5.674"></a><span id="l5.674">   {</span>
<a href="#l5.675"></a><span id="l5.675">     PRBool isAlive;</span>
<a href="#l5.676"></a><span id="l5.676">     rv = m_transport-&gt;IsAlive(&amp;isAlive);</span>
<a href="#l5.677"></a><span id="l5.677">     // if the transport is not alive, and we've ever sent a command with this connection, kill it.</span>
<a href="#l5.678"></a><span id="l5.678">     // otherwise, we've probably just not finished setting it so don't kill it!</span>
<a href="#l5.679"></a><span id="l5.679">     if (NS_FAILED(rv) || !isAlive)</span>
<a href="#l5.680"></a><span id="l5.680">     {</span>
<a href="#l5.681"></a><span id="l5.681" class="difflineplus">+      MutexAutoUnlock unlock(mLock); // TellThreadToDie gets the lock</span>
<a href="#l5.682"></a><span id="l5.682">       TellThreadToDie(PR_FALSE);</span>
<a href="#l5.683"></a><span id="l5.683">       return NS_ERROR_FAILURE;</span>
<a href="#l5.684"></a><span id="l5.684">     }</span>
<a href="#l5.685"></a><span id="l5.685">   }</span>
<a href="#l5.686"></a><span id="l5.686">   IsBusy(&amp;isBusy, &amp;isInboxConnection);</span>
<a href="#l5.687"></a><span id="l5.687">   PRBool inSelectedState = GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l5.688"></a><span id="l5.688">     nsImapServerResponseParser::kFolderSelected;</span>
<a href="#l5.689"></a><span id="l5.689"> </span>
<a href="#l5.690"></a><span id="l5.690" class="difflineat">@@ -4105,46 +4077,46 @@ void nsImapProtocol::ProcessMailboxUpdat</span>
<a href="#l5.691"></a><span id="l5.691">   if (new_spec &amp;&amp; !DeathSignalReceived())</span>
<a href="#l5.692"></a><span id="l5.692">   {</span>
<a href="#l5.693"></a><span id="l5.693">     if (!DeathSignalReceived())</span>
<a href="#l5.694"></a><span id="l5.694">     {</span>
<a href="#l5.695"></a><span id="l5.695">       nsImapAction imapAction;</span>
<a href="#l5.696"></a><span id="l5.696">       nsresult res = m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l5.697"></a><span id="l5.697">       if (NS_SUCCEEDED(res) &amp;&amp; imapAction == nsIImapUrl::nsImapExpungeFolder)</span>
<a href="#l5.698"></a><span id="l5.698">         new_spec-&gt;mBoxFlags |= kJustExpunged;</span>
<a href="#l5.699"></a><span id="l5.699" class="difflineminus">-      PR_EnterMonitor(m_waitForBodyIdsMonitor);</span>
<a href="#l5.700"></a><span id="l5.700" class="difflineplus">+      m_waitForBodyIdsMonitor.Enter();</span>
<a href="#l5.701"></a><span id="l5.701">       entered_waitForBodyIdsMonitor = PR_TRUE;</span>
<a href="#l5.702"></a><span id="l5.702">       UpdatedMailboxSpec(new_spec);</span>
<a href="#l5.703"></a><span id="l5.703">     }</span>
<a href="#l5.704"></a><span id="l5.704">   }</span>
<a href="#l5.705"></a><span id="l5.705">   else if (!new_spec)</span>
<a href="#l5.706"></a><span id="l5.706">     HandleMemoryFailure();</span>
<a href="#l5.707"></a><span id="l5.707"> </span>
<a href="#l5.708"></a><span id="l5.708">   // Block until libmsg decides whether to download headers or not.</span>
<a href="#l5.709"></a><span id="l5.709">   PRUint32 *msgIdList = nsnull;</span>
<a href="#l5.710"></a><span id="l5.710">   PRUint32 msgCount = 0;</span>
<a href="#l5.711"></a><span id="l5.711"> </span>
<a href="#l5.712"></a><span id="l5.712">   if (!DeathSignalReceived())</span>
<a href="#l5.713"></a><span id="l5.713">   {</span>
<a href="#l5.714"></a><span id="l5.714">     WaitForPotentialListOfMsgsToFetch(&amp;msgIdList, msgCount);</span>
<a href="#l5.715"></a><span id="l5.715"> </span>
<a href="#l5.716"></a><span id="l5.716">     if (entered_waitForBodyIdsMonitor)</span>
<a href="#l5.717"></a><span id="l5.717" class="difflineminus">-      PR_ExitMonitor(m_waitForBodyIdsMonitor);</span>
<a href="#l5.718"></a><span id="l5.718" class="difflineplus">+      m_waitForBodyIdsMonitor.Exit();</span>
<a href="#l5.719"></a><span id="l5.719"> </span>
<a href="#l5.720"></a><span id="l5.720">     if (msgIdList &amp;&amp; !DeathSignalReceived() &amp;&amp; GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l5.721"></a><span id="l5.721">     {</span>
<a href="#l5.722"></a><span id="l5.722">       FolderHeaderDump(msgIdList, msgCount);</span>
<a href="#l5.723"></a><span id="l5.723">       PR_Free( msgIdList);</span>
<a href="#l5.724"></a><span id="l5.724">     }</span>
<a href="#l5.725"></a><span id="l5.725">     HeaderFetchCompleted();</span>
<a href="#l5.726"></a><span id="l5.726">       // this might be bogus, how are we going to do pane notification and stuff when we fetch bodies without</span>
<a href="#l5.727"></a><span id="l5.727">       // headers!</span>
<a href="#l5.728"></a><span id="l5.728">   }</span>
<a href="#l5.729"></a><span id="l5.729">   else if (entered_waitForBodyIdsMonitor) // need to exit this monitor if death signal received</span>
<a href="#l5.730"></a><span id="l5.730" class="difflineminus">-    PR_ExitMonitor(m_waitForBodyIdsMonitor);</span>
<a href="#l5.731"></a><span id="l5.731" class="difflineplus">+    m_waitForBodyIdsMonitor.Exit();</span>
<a href="#l5.732"></a><span id="l5.732"> </span>
<a href="#l5.733"></a><span id="l5.733">   // wait for a list of bodies to fetch.</span>
<a href="#l5.734"></a><span id="l5.734">   if (!DeathSignalReceived() &amp;&amp; GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l5.735"></a><span id="l5.735">   {</span>
<a href="#l5.736"></a><span id="l5.736">     WaitForPotentialListOfBodysToFetch(&amp;msgIdList, msgCount);</span>
<a href="#l5.737"></a><span id="l5.737">     if ( msgCount &amp;&amp; !DeathSignalReceived() &amp;&amp; GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l5.738"></a><span id="l5.738">     {</span>
<a href="#l5.739"></a><span id="l5.739">       // Tell the url that it should store the msg fetch results offline,</span>
<a href="#l5.740"></a><span id="l5.740" class="difflineat">@@ -4194,69 +4166,63 @@ void nsImapProtocol::FolderMsgDump(PRUin</span>
<a href="#l5.741"></a><span id="l5.741"> </span>
<a href="#l5.742"></a><span id="l5.742">   SetProgressString(0);</span>
<a href="#l5.743"></a><span id="l5.743"> }</span>
<a href="#l5.744"></a><span id="l5.744"> </span>
<a href="#l5.745"></a><span id="l5.745"> void nsImapProtocol::WaitForPotentialListOfMsgsToFetch(PRUint32 **msgIdList, PRUint32 &amp;msgCount)</span>
<a href="#l5.746"></a><span id="l5.746"> {</span>
<a href="#l5.747"></a><span id="l5.747">   PRIntervalTime sleepTime = kImapSleepTime;</span>
<a href="#l5.748"></a><span id="l5.748"> </span>
<a href="#l5.749"></a><span id="l5.749" class="difflineminus">-    PR_EnterMonitor(m_fetchMsgListMonitor);</span>
<a href="#l5.750"></a><span id="l5.750" class="difflineminus">-    while(!m_fetchMsgListIsNew &amp;&amp; !DeathSignalReceived())</span>
<a href="#l5.751"></a><span id="l5.751" class="difflineminus">-        PR_Wait(m_fetchMsgListMonitor, sleepTime);</span>
<a href="#l5.752"></a><span id="l5.752" class="difflineminus">-    m_fetchMsgListIsNew = PR_FALSE;</span>
<a href="#l5.753"></a><span id="l5.753" class="difflineminus">-</span>
<a href="#l5.754"></a><span id="l5.754" class="difflineminus">-    *msgIdList = m_fetchMsgIdList;</span>
<a href="#l5.755"></a><span id="l5.755" class="difflineminus">-    msgCount   = m_fetchCount;</span>
<a href="#l5.756"></a><span id="l5.756" class="difflineminus">-</span>
<a href="#l5.757"></a><span id="l5.757" class="difflineminus">-    PR_ExitMonitor(m_fetchMsgListMonitor);</span>
<a href="#l5.758"></a><span id="l5.758" class="difflineplus">+  MonitorAutoEnter fetchListMon(m_fetchMsgListMonitor);</span>
<a href="#l5.759"></a><span id="l5.759" class="difflineplus">+  while(!m_fetchMsgListIsNew &amp;&amp; !DeathSignalReceived())</span>
<a href="#l5.760"></a><span id="l5.760" class="difflineplus">+    fetchListMon.Wait(sleepTime);</span>
<a href="#l5.761"></a><span id="l5.761" class="difflineplus">+  m_fetchMsgListIsNew = PR_FALSE;</span>
<a href="#l5.762"></a><span id="l5.762" class="difflineplus">+</span>
<a href="#l5.763"></a><span id="l5.763" class="difflineplus">+  *msgIdList = m_fetchMsgIdList;</span>
<a href="#l5.764"></a><span id="l5.764" class="difflineplus">+  msgCount   = m_fetchCount;</span>
<a href="#l5.765"></a><span id="l5.765"> }</span>
<a href="#l5.766"></a><span id="l5.766"> </span>
<a href="#l5.767"></a><span id="l5.767"> void nsImapProtocol::WaitForPotentialListOfBodysToFetch(PRUint32 **msgIdList, PRUint32 &amp;msgCount)</span>
<a href="#l5.768"></a><span id="l5.768"> {</span>
<a href="#l5.769"></a><span id="l5.769">   PRIntervalTime sleepTime = kImapSleepTime;</span>
<a href="#l5.770"></a><span id="l5.770"> </span>
<a href="#l5.771"></a><span id="l5.771" class="difflineminus">-    PR_EnterMonitor(m_fetchBodyListMonitor);</span>
<a href="#l5.772"></a><span id="l5.772" class="difflineminus">-    while(!m_fetchBodyListIsNew &amp;&amp; !DeathSignalReceived())</span>
<a href="#l5.773"></a><span id="l5.773" class="difflineminus">-        PR_Wait(m_fetchBodyListMonitor, sleepTime);</span>
<a href="#l5.774"></a><span id="l5.774" class="difflineminus">-    m_fetchBodyListIsNew = PR_FALSE;</span>
<a href="#l5.775"></a><span id="l5.775" class="difflineminus">-</span>
<a href="#l5.776"></a><span id="l5.776" class="difflineminus">-    *msgIdList = m_fetchBodyIdList;</span>
<a href="#l5.777"></a><span id="l5.777" class="difflineminus">-    msgCount   = m_fetchBodyCount;</span>
<a href="#l5.778"></a><span id="l5.778" class="difflineminus">-</span>
<a href="#l5.779"></a><span id="l5.779" class="difflineminus">-    PR_ExitMonitor(m_fetchBodyListMonitor);</span>
<a href="#l5.780"></a><span id="l5.780" class="difflineplus">+  MonitorAutoEnter fetchListMon(m_fetchMsgListMonitor);</span>
<a href="#l5.781"></a><span id="l5.781" class="difflineplus">+  while(!m_fetchBodyListIsNew &amp;&amp; !DeathSignalReceived())</span>
<a href="#l5.782"></a><span id="l5.782" class="difflineplus">+    fetchListMon.Wait(sleepTime);</span>
<a href="#l5.783"></a><span id="l5.783" class="difflineplus">+  m_fetchBodyListIsNew = PR_FALSE;</span>
<a href="#l5.784"></a><span id="l5.784" class="difflineplus">+</span>
<a href="#l5.785"></a><span id="l5.785" class="difflineplus">+  *msgIdList = m_fetchBodyIdList;</span>
<a href="#l5.786"></a><span id="l5.786" class="difflineplus">+  msgCount   = m_fetchBodyCount;</span>
<a href="#l5.787"></a><span id="l5.787"> }</span>
<a href="#l5.788"></a><span id="l5.788"> </span>
<a href="#l5.789"></a><span id="l5.789"> // libmsg uses this to notify a running imap url about the message headers it should</span>
<a href="#l5.790"></a><span id="l5.790"> // download while opening a folder. Generally, the imap thread will be blocked</span>
<a href="#l5.791"></a><span id="l5.791"> // in WaitForPotentialListOfMsgsToFetch waiting for this notification.</span>
<a href="#l5.792"></a><span id="l5.792"> NS_IMETHODIMP nsImapProtocol::NotifyHdrsToDownload(PRUint32 *keys, PRUint32 keyCount)</span>
<a href="#l5.793"></a><span id="l5.793"> {</span>
<a href="#l5.794"></a><span id="l5.794" class="difflineminus">-    PR_EnterMonitor(m_fetchMsgListMonitor);</span>
<a href="#l5.795"></a><span id="l5.795" class="difflineminus">-    m_fetchMsgIdList = keys;</span>
<a href="#l5.796"></a><span id="l5.796" class="difflineminus">-    m_fetchCount    = keyCount;</span>
<a href="#l5.797"></a><span id="l5.797" class="difflineminus">-    m_fetchMsgListIsNew = PR_TRUE;</span>
<a href="#l5.798"></a><span id="l5.798" class="difflineminus">-    PR_Notify(m_fetchMsgListMonitor);</span>
<a href="#l5.799"></a><span id="l5.799" class="difflineminus">-    PR_ExitMonitor(m_fetchMsgListMonitor);</span>
<a href="#l5.800"></a><span id="l5.800" class="difflineplus">+  MonitorAutoEnter fetchListMon(m_fetchMsgListMonitor);</span>
<a href="#l5.801"></a><span id="l5.801" class="difflineplus">+  m_fetchMsgIdList = keys;</span>
<a href="#l5.802"></a><span id="l5.802" class="difflineplus">+  m_fetchCount    = keyCount;</span>
<a href="#l5.803"></a><span id="l5.803" class="difflineplus">+  m_fetchMsgListIsNew = PR_TRUE;</span>
<a href="#l5.804"></a><span id="l5.804" class="difflineplus">+  fetchListMon.Notify();</span>
<a href="#l5.805"></a><span id="l5.805">   return NS_OK;</span>
<a href="#l5.806"></a><span id="l5.806"> }</span>
<a href="#l5.807"></a><span id="l5.807"> </span>
<a href="#l5.808"></a><span id="l5.808"> // libmsg uses this to notify a running imap url about message bodies it should download.</span>
<a href="#l5.809"></a><span id="l5.809"> // why not just have libmsg explicitly download the message bodies?</span>
<a href="#l5.810"></a><span id="l5.810"> NS_IMETHODIMP nsImapProtocol::NotifyBodysToDownload(PRUint32 *keys, PRUint32 keyCount)</span>
<a href="#l5.811"></a><span id="l5.811"> {</span>
<a href="#l5.812"></a><span id="l5.812" class="difflineminus">-    PR_EnterMonitor(m_fetchBodyListMonitor);</span>
<a href="#l5.813"></a><span id="l5.813" class="difflineminus">-    PR_FREEIF(m_fetchBodyIdList);</span>
<a href="#l5.814"></a><span id="l5.814" class="difflineminus">-    m_fetchBodyIdList = (PRUint32 *) PR_MALLOC(keyCount * sizeof(PRUint32));</span>
<a href="#l5.815"></a><span id="l5.815" class="difflineminus">-    if (m_fetchBodyIdList)</span>
<a href="#l5.816"></a><span id="l5.816" class="difflineminus">-      memcpy(m_fetchBodyIdList, keys, keyCount * sizeof(PRUint32));</span>
<a href="#l5.817"></a><span id="l5.817" class="difflineminus">-    m_fetchBodyCount    = keyCount;</span>
<a href="#l5.818"></a><span id="l5.818" class="difflineminus">-    m_fetchBodyListIsNew = PR_TRUE;</span>
<a href="#l5.819"></a><span id="l5.819" class="difflineminus">-    PR_Notify(m_fetchBodyListMonitor);</span>
<a href="#l5.820"></a><span id="l5.820" class="difflineminus">-    PR_ExitMonitor(m_fetchBodyListMonitor);</span>
<a href="#l5.821"></a><span id="l5.821" class="difflineplus">+  MonitorAutoEnter fetchListMon(m_fetchBodyListMonitor);</span>
<a href="#l5.822"></a><span id="l5.822" class="difflineplus">+  PR_FREEIF(m_fetchBodyIdList);</span>
<a href="#l5.823"></a><span id="l5.823" class="difflineplus">+  m_fetchBodyIdList = (PRUint32 *) PR_MALLOC(keyCount * sizeof(PRUint32));</span>
<a href="#l5.824"></a><span id="l5.824" class="difflineplus">+  if (m_fetchBodyIdList)</span>
<a href="#l5.825"></a><span id="l5.825" class="difflineplus">+    memcpy(m_fetchBodyIdList, keys, keyCount * sizeof(PRUint32));</span>
<a href="#l5.826"></a><span id="l5.826" class="difflineplus">+  m_fetchBodyCount    = keyCount;</span>
<a href="#l5.827"></a><span id="l5.827" class="difflineplus">+  m_fetchBodyListIsNew = PR_TRUE;</span>
<a href="#l5.828"></a><span id="l5.828" class="difflineplus">+  fetchListMon.Notify();</span>
<a href="#l5.829"></a><span id="l5.829">   return NS_OK;</span>
<a href="#l5.830"></a><span id="l5.830"> }</span>
<a href="#l5.831"></a><span id="l5.831"> </span>
<a href="#l5.832"></a><span id="l5.832"> NS_IMETHODIMP nsImapProtocol::GetFlagsForUID(PRUint32 uid, PRBool *foundIt, imapMessageFlagsType *resultFlags, char **customFlags)</span>
<a href="#l5.833"></a><span id="l5.833"> {</span>
<a href="#l5.834"></a><span id="l5.834">   PRInt32 i;</span>
<a href="#l5.835"></a><span id="l5.835"> </span>
<a href="#l5.836"></a><span id="l5.836">   imapMessageFlagsType flags = m_flagState-&gt;GetMessageFlagsFromUID(uid, foundIt, &amp;i);</span>
<a href="#l5.837"></a><span id="l5.837" class="difflineat">@@ -4552,39 +4518,33 @@ PRUint32 nsImapProtocol::CountMessagesIn</span>
<a href="#l5.838"></a><span id="l5.838">         saveStartToken = curToken + 1;</span>
<a href="#l5.839"></a><span id="l5.839">     }</span>
<a href="#l5.840"></a><span id="l5.840">     PR_Free(uidString);</span>
<a href="#l5.841"></a><span id="l5.841">   }</span>
<a href="#l5.842"></a><span id="l5.842">   return numberOfMessages;</span>
<a href="#l5.843"></a><span id="l5.843"> }</span>
<a href="#l5.844"></a><span id="l5.844"> </span>
<a href="#l5.845"></a><span id="l5.845"> </span>
<a href="#l5.846"></a><span id="l5.846" class="difflineminus">-PRMonitor *nsImapProtocol::GetDataMemberMonitor()</span>
<a href="#l5.847"></a><span id="l5.847" class="difflineminus">-{</span>
<a href="#l5.848"></a><span id="l5.848" class="difflineminus">-    return m_dataMemberMonitor;</span>
<a href="#l5.849"></a><span id="l5.849" class="difflineminus">-}</span>
<a href="#l5.850"></a><span id="l5.850" class="difflineminus">-</span>
<a href="#l5.851"></a><span id="l5.851"> // It would be really nice not to have to use this method nearly as much as we did</span>
<a href="#l5.852"></a><span id="l5.852"> // in 4.5 - we need to think about this some. Some of it may just go away in the new world order</span>
<a href="#l5.853"></a><span id="l5.853"> PRBool nsImapProtocol::DeathSignalReceived()</span>
<a href="#l5.854"></a><span id="l5.854"> {</span>
<a href="#l5.855"></a><span id="l5.855">   nsresult returnValue = NS_OK;</span>
<a href="#l5.856"></a><span id="l5.856">   // ignore mock channel status if we've been pseudo interrupted</span>
<a href="#l5.857"></a><span id="l5.857">   // ### need to make sure we clear pseudo interrupted status appropriately.</span>
<a href="#l5.858"></a><span id="l5.858">   if (!GetPseudoInterrupted() &amp;&amp; m_mockChannel)</span>
<a href="#l5.859"></a><span id="l5.859">   {</span>
<a href="#l5.860"></a><span id="l5.860">     nsCOMPtr&lt;nsIRequest&gt; request = do_QueryInterface(m_mockChannel);</span>
<a href="#l5.861"></a><span id="l5.861">     if (request)</span>
<a href="#l5.862"></a><span id="l5.862">       request-&gt;GetStatus(&amp;returnValue);</span>
<a href="#l5.863"></a><span id="l5.863">   }</span>
<a href="#l5.864"></a><span id="l5.864">   if (NS_SUCCEEDED(returnValue)) // check the other way of cancelling.</span>
<a href="#l5.865"></a><span id="l5.865">   {</span>
<a href="#l5.866"></a><span id="l5.866" class="difflineminus">-    PR_EnterMonitor(m_threadDeathMonitor);</span>
<a href="#l5.867"></a><span id="l5.867" class="difflineplus">+    MonitorAutoEnter threadDeathMon(m_threadDeathMonitor);</span>
<a href="#l5.868"></a><span id="l5.868">     returnValue = m_threadShouldDie;</span>
<a href="#l5.869"></a><span id="l5.869" class="difflineminus">-    PR_ExitMonitor(m_threadDeathMonitor);</span>
<a href="#l5.870"></a><span id="l5.870">   }</span>
<a href="#l5.871"></a><span id="l5.871">   return returnValue;</span>
<a href="#l5.872"></a><span id="l5.872"> }</span>
<a href="#l5.873"></a><span id="l5.873"> </span>
<a href="#l5.874"></a><span id="l5.874"> NS_IMETHODIMP nsImapProtocol::ResetToAuthenticatedState()</span>
<a href="#l5.875"></a><span id="l5.875"> {</span>
<a href="#l5.876"></a><span id="l5.876">     GetServerStateParser().PreauthSetAuthenticatedState();</span>
<a href="#l5.877"></a><span id="l5.877">     return NS_OK;</span>
<a href="#l5.878"></a><span id="l5.878" class="difflineat">@@ -4597,48 +4557,38 @@ NS_IMETHODIMP nsImapProtocol::GetSelecte</span>
<a href="#l5.879"></a><span id="l5.879">     if (GetServerStateParser().GetSelectedMailboxName())</span>
<a href="#l5.880"></a><span id="l5.880">         *folderName =</span>
<a href="#l5.881"></a><span id="l5.881">             PL_strdup((GetServerStateParser().GetSelectedMailboxName()));</span>
<a href="#l5.882"></a><span id="l5.882">     return NS_OK;</span>
<a href="#l5.883"></a><span id="l5.883"> }</span>
<a href="#l5.884"></a><span id="l5.884"> </span>
<a href="#l5.885"></a><span id="l5.885"> PRBool nsImapProtocol::GetPseudoInterrupted()</span>
<a href="#l5.886"></a><span id="l5.886"> {</span>
<a href="#l5.887"></a><span id="l5.887" class="difflineminus">-  PRBool rv = PR_FALSE;</span>
<a href="#l5.888"></a><span id="l5.888" class="difflineminus">-  PR_EnterMonitor(m_pseudoInterruptMonitor);</span>
<a href="#l5.889"></a><span id="l5.889" class="difflineminus">-  rv = m_pseudoInterrupted;</span>
<a href="#l5.890"></a><span id="l5.890" class="difflineminus">-  PR_ExitMonitor(m_pseudoInterruptMonitor);</span>
<a href="#l5.891"></a><span id="l5.891" class="difflineminus">-  return rv;</span>
<a href="#l5.892"></a><span id="l5.892" class="difflineplus">+  MonitorAutoEnter pseudoInterruptMon(m_pseudoInterruptMonitor);</span>
<a href="#l5.893"></a><span id="l5.893" class="difflineplus">+  return m_pseudoInterrupted;</span>
<a href="#l5.894"></a><span id="l5.894"> }</span>
<a href="#l5.895"></a><span id="l5.895"> </span>
<a href="#l5.896"></a><span id="l5.896"> void nsImapProtocol::PseudoInterrupt(PRBool the_interrupt)</span>
<a href="#l5.897"></a><span id="l5.897"> {</span>
<a href="#l5.898"></a><span id="l5.898" class="difflineminus">-  PR_EnterMonitor(m_pseudoInterruptMonitor);</span>
<a href="#l5.899"></a><span id="l5.899" class="difflineplus">+  MonitorAutoEnter pseudoInterruptMon(m_pseudoInterruptMonitor);</span>
<a href="#l5.900"></a><span id="l5.900">   m_pseudoInterrupted = the_interrupt;</span>
<a href="#l5.901"></a><span id="l5.901">   if (the_interrupt)</span>
<a href="#l5.902"></a><span id="l5.902" class="difflineminus">-  {</span>
<a href="#l5.903"></a><span id="l5.903">     Log(&quot;CONTROL&quot;, NULL, &quot;PSEUDO-Interrupted&quot;);</span>
<a href="#l5.904"></a><span id="l5.904" class="difflineminus">-  }</span>
<a href="#l5.905"></a><span id="l5.905" class="difflineminus">-  PR_ExitMonitor(m_pseudoInterruptMonitor);</span>
<a href="#l5.906"></a><span id="l5.906"> }</span>
<a href="#l5.907"></a><span id="l5.907"> </span>
<a href="#l5.908"></a><span id="l5.908"> void  nsImapProtocol::SetActive(PRBool active)</span>
<a href="#l5.909"></a><span id="l5.909"> {</span>
<a href="#l5.910"></a><span id="l5.910" class="difflineminus">-  PR_EnterMonitor(GetDataMemberMonitor());</span>
<a href="#l5.911"></a><span id="l5.911" class="difflineplus">+  MonitorAutoEnter dataMemberMon(m_dataMemberMonitor);</span>
<a href="#l5.912"></a><span id="l5.912">   m_active = active;</span>
<a href="#l5.913"></a><span id="l5.913" class="difflineminus">-  PR_ExitMonitor(GetDataMemberMonitor());</span>
<a href="#l5.914"></a><span id="l5.914"> }</span>
<a href="#l5.915"></a><span id="l5.915"> </span>
<a href="#l5.916"></a><span id="l5.916"> PRBool  nsImapProtocol::GetActive()</span>
<a href="#l5.917"></a><span id="l5.917"> {</span>
<a href="#l5.918"></a><span id="l5.918" class="difflineminus">-  PRBool ret;</span>
<a href="#l5.919"></a><span id="l5.919" class="difflineminus">-  PR_EnterMonitor(GetDataMemberMonitor());</span>
<a href="#l5.920"></a><span id="l5.920" class="difflineminus">-  ret = m_active;</span>
<a href="#l5.921"></a><span id="l5.921" class="difflineminus">-  PR_ExitMonitor(GetDataMemberMonitor());</span>
<a href="#l5.922"></a><span id="l5.922" class="difflineminus">-  return ret;</span>
<a href="#l5.923"></a><span id="l5.923" class="difflineplus">+  MonitorAutoEnter dataMemberMon(m_dataMemberMonitor);</span>
<a href="#l5.924"></a><span id="l5.924" class="difflineplus">+  return m_active;</span>
<a href="#l5.925"></a><span id="l5.925"> }</span>
<a href="#l5.926"></a><span id="l5.926"> </span>
<a href="#l5.927"></a><span id="l5.927"> PRBool nsImapProtocol::GetShowAttachmentsInline()</span>
<a href="#l5.928"></a><span id="l5.928"> {</span>
<a href="#l5.929"></a><span id="l5.929">   PRBool showAttachmentsInline = PR_TRUE;</span>
<a href="#l5.930"></a><span id="l5.930">   if (m_imapServerSink)</span>
<a href="#l5.931"></a><span id="l5.931">     m_imapServerSink-&gt;GetShowAttachmentsInline(&amp;showAttachmentsInline);</span>
<a href="#l5.932"></a><span id="l5.932">   return showAttachmentsInline;</span>
<a href="#l5.933"></a><span id="l5.933" class="difflineat">@@ -4829,29 +4779,24 @@ nsImapProtocol::NotifySearchHit(const ch</span>
<a href="#l5.934"></a><span id="l5.934">     nsresult rv;</span>
<a href="#l5.935"></a><span id="l5.935">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_runningUrl, &amp;rv);</span>
<a href="#l5.936"></a><span id="l5.936">     if (m_imapMailFolderSink)</span>
<a href="#l5.937"></a><span id="l5.937">         m_imapMailFolderSink-&gt;NotifySearchHit(mailnewsUrl, hitLine);</span>
<a href="#l5.938"></a><span id="l5.938"> }</span>
<a href="#l5.939"></a><span id="l5.939"> </span>
<a href="#l5.940"></a><span id="l5.940"> void nsImapProtocol::SetMailboxDiscoveryStatus(EMailboxDiscoverStatus status)</span>
<a href="#l5.941"></a><span id="l5.941"> {</span>
<a href="#l5.942"></a><span id="l5.942" class="difflineminus">-    PR_EnterMonitor(GetDataMemberMonitor());</span>
<a href="#l5.943"></a><span id="l5.943" class="difflineplus">+  MonitorAutoEnter mon(m_dataMemberMonitor);</span>
<a href="#l5.944"></a><span id="l5.944">   m_discoveryStatus = status;</span>
<a href="#l5.945"></a><span id="l5.945" class="difflineminus">-    PR_ExitMonitor(GetDataMemberMonitor());</span>
<a href="#l5.946"></a><span id="l5.946"> }</span>
<a href="#l5.947"></a><span id="l5.947"> </span>
<a href="#l5.948"></a><span id="l5.948"> EMailboxDiscoverStatus nsImapProtocol::GetMailboxDiscoveryStatus( )</span>
<a href="#l5.949"></a><span id="l5.949"> {</span>
<a href="#l5.950"></a><span id="l5.950" class="difflineminus">-  EMailboxDiscoverStatus returnStatus;</span>
<a href="#l5.951"></a><span id="l5.951" class="difflineminus">-    PR_EnterMonitor(GetDataMemberMonitor());</span>
<a href="#l5.952"></a><span id="l5.952" class="difflineminus">-  returnStatus = m_discoveryStatus;</span>
<a href="#l5.953"></a><span id="l5.953" class="difflineminus">-    PR_ExitMonitor(GetDataMemberMonitor());</span>
<a href="#l5.954"></a><span id="l5.954" class="difflineminus">-</span>
<a href="#l5.955"></a><span id="l5.955" class="difflineminus">-    return returnStatus;</span>
<a href="#l5.956"></a><span id="l5.956" class="difflineplus">+  MonitorAutoEnter mon(m_dataMemberMonitor);</span>
<a href="#l5.957"></a><span id="l5.957" class="difflineplus">+  return m_discoveryStatus;</span>
<a href="#l5.958"></a><span id="l5.958"> }</span>
<a href="#l5.959"></a><span id="l5.959"> </span>
<a href="#l5.960"></a><span id="l5.960"> PRBool</span>
<a href="#l5.961"></a><span id="l5.961"> nsImapProtocol::GetSubscribingNow()</span>
<a href="#l5.962"></a><span id="l5.962"> {</span>
<a href="#l5.963"></a><span id="l5.963">     // ***** code me *****</span>
<a href="#l5.964"></a><span id="l5.964">     return PR_FALSE;// ***** for now</span>
<a href="#l5.965"></a><span id="l5.965"> }</span>
<a href="#l5.966"></a><span id="l5.966" class="difflineat">@@ -8190,23 +8135,22 @@ nsresult nsImapProtocol::GetPassword(nsC</span>
<a href="#l5.967"></a><span id="l5.967">     nsCAutoString pwd; // GetPasswordWithUI truncates the password on Cancel</span>
<a href="#l5.968"></a><span id="l5.968">     rv = m_imapServerSink-&gt;AsyncGetPassword(this,</span>
<a href="#l5.969"></a><span id="l5.969">                                                      newPasswordRequested,</span>
<a href="#l5.970"></a><span id="l5.970">                                                      password);</span>
<a href="#l5.971"></a><span id="l5.971">     if (password.IsEmpty())</span>
<a href="#l5.972"></a><span id="l5.972">     {</span>
<a href="#l5.973"></a><span id="l5.973">       PRIntervalTime sleepTime = kImapSleepTime;</span>
<a href="#l5.974"></a><span id="l5.974">       m_passwordStatus = NS_OK;</span>
<a href="#l5.975"></a><span id="l5.975" class="difflineminus">-      PR_EnterMonitor(m_passwordReadyMonitor);</span>
<a href="#l5.976"></a><span id="l5.976" class="difflineplus">+      MonitorAutoEnter mon(m_passwordReadyMonitor);</span>
<a href="#l5.977"></a><span id="l5.977">       while (m_password.IsEmpty() &amp;&amp; !NS_FAILED(m_passwordStatus) &amp;&amp;</span>
<a href="#l5.978"></a><span id="l5.978">              m_passwordStatus != NS_MSG_PASSWORD_PROMPT_CANCELLED &amp;&amp;</span>
<a href="#l5.979"></a><span id="l5.979">              !DeathSignalReceived())</span>
<a href="#l5.980"></a><span id="l5.980" class="difflineminus">-        PR_Wait(m_passwordReadyMonitor, sleepTime);</span>
<a href="#l5.981"></a><span id="l5.981" class="difflineplus">+        mon.Wait(sleepTime);</span>
<a href="#l5.982"></a><span id="l5.982">       rv = m_passwordStatus;</span>
<a href="#l5.983"></a><span id="l5.983" class="difflineminus">-      PR_ExitMonitor(m_passwordReadyMonitor);</span>
<a href="#l5.984"></a><span id="l5.984">       password = m_password;</span>
<a href="#l5.985"></a><span id="l5.985">     }</span>
<a href="#l5.986"></a><span id="l5.986">   }</span>
<a href="#l5.987"></a><span id="l5.987">   if (!password.IsEmpty())</span>
<a href="#l5.988"></a><span id="l5.988">     m_lastPasswordSent = password;</span>
<a href="#l5.989"></a><span id="l5.989">   return rv;</span>
<a href="#l5.990"></a><span id="l5.990"> }</span>
<a href="#l5.991"></a><span id="l5.991"> </span>
<a href="#l5.992"></a><span id="l5.992" class="difflineat">@@ -8224,44 +8168,41 @@ nsImapProtocol::OnPromptStart(PRInt32 *a</span>
<a href="#l5.993"></a><span id="l5.993">   nsCString password = m_lastPasswordSent;</span>
<a href="#l5.994"></a><span id="l5.994">   rv = imapServer-&gt;PromptPassword(msgWindow, password);</span>
<a href="#l5.995"></a><span id="l5.995">   m_password = password;</span>
<a href="#l5.996"></a><span id="l5.996">   m_passwordStatus = rv;</span>
<a href="#l5.997"></a><span id="l5.997">   if (!m_password.IsEmpty())</span>
<a href="#l5.998"></a><span id="l5.998">     *aResult = PR_TRUE;</span>
<a href="#l5.999"></a><span id="l5.999"> </span>
<a href="#l5.1000"></a><span id="l5.1000">   // Notify the imap thread that we have a password.</span>
<a href="#l5.1001"></a><span id="l5.1001" class="difflineminus">-  PR_EnterMonitor(m_passwordReadyMonitor);</span>
<a href="#l5.1002"></a><span id="l5.1002" class="difflineminus">-  PR_Notify(m_passwordReadyMonitor);</span>
<a href="#l5.1003"></a><span id="l5.1003" class="difflineminus">-  PR_ExitMonitor(m_passwordReadyMonitor);</span>
<a href="#l5.1004"></a><span id="l5.1004" class="difflineplus">+  MonitorAutoEnter passwordMon(m_passwordReadyMonitor);</span>
<a href="#l5.1005"></a><span id="l5.1005" class="difflineplus">+  passwordMon.Notify();</span>
<a href="#l5.1006"></a><span id="l5.1006">   return rv;</span>
<a href="#l5.1007"></a><span id="l5.1007"> }</span>
<a href="#l5.1008"></a><span id="l5.1008"> </span>
<a href="#l5.1009"></a><span id="l5.1009"> NS_IMETHODIMP</span>
<a href="#l5.1010"></a><span id="l5.1010"> nsImapProtocol::OnPromptAuthAvailable()</span>
<a href="#l5.1011"></a><span id="l5.1011"> {</span>
<a href="#l5.1012"></a><span id="l5.1012">   nsresult rv;</span>
<a href="#l5.1013"></a><span id="l5.1013">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; imapServer = do_QueryReferent(m_server, &amp;rv);</span>
<a href="#l5.1014"></a><span id="l5.1014">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.1015"></a><span id="l5.1015">   m_passwordStatus = imapServer-&gt;GetPassword(m_password);</span>
<a href="#l5.1016"></a><span id="l5.1016">   // Notify the imap thread that we have a password.</span>
<a href="#l5.1017"></a><span id="l5.1017" class="difflineminus">-  PR_EnterMonitor(m_passwordReadyMonitor);</span>
<a href="#l5.1018"></a><span id="l5.1018" class="difflineminus">-  PR_Notify(m_passwordReadyMonitor);</span>
<a href="#l5.1019"></a><span id="l5.1019" class="difflineminus">-  PR_ExitMonitor(m_passwordReadyMonitor);</span>
<a href="#l5.1020"></a><span id="l5.1020" class="difflineplus">+  MonitorAutoEnter mon(m_passwordReadyMonitor);</span>
<a href="#l5.1021"></a><span id="l5.1021" class="difflineplus">+  mon.Notify();</span>
<a href="#l5.1022"></a><span id="l5.1022">   return m_passwordStatus;</span>
<a href="#l5.1023"></a><span id="l5.1023"> }</span>
<a href="#l5.1024"></a><span id="l5.1024"> </span>
<a href="#l5.1025"></a><span id="l5.1025"> NS_IMETHODIMP</span>
<a href="#l5.1026"></a><span id="l5.1026"> nsImapProtocol::OnPromptCanceled()</span>
<a href="#l5.1027"></a><span id="l5.1027"> {</span>
<a href="#l5.1028"></a><span id="l5.1028">   // A prompt was cancelled, so notify the imap thread.</span>
<a href="#l5.1029"></a><span id="l5.1029">   m_passwordStatus = NS_MSG_PASSWORD_PROMPT_CANCELLED;</span>
<a href="#l5.1030"></a><span id="l5.1030" class="difflineminus">-  PR_EnterMonitor(m_passwordReadyMonitor);</span>
<a href="#l5.1031"></a><span id="l5.1031" class="difflineminus">-  PR_Notify(m_passwordReadyMonitor);</span>
<a href="#l5.1032"></a><span id="l5.1032" class="difflineminus">-  PR_ExitMonitor(m_passwordReadyMonitor);</span>
<a href="#l5.1033"></a><span id="l5.1033" class="difflineplus">+  MonitorAutoEnter mon(m_passwordReadyMonitor);</span>
<a href="#l5.1034"></a><span id="l5.1034" class="difflineplus">+  mon.Notify();</span>
<a href="#l5.1035"></a><span id="l5.1035">   return NS_OK;</span>
<a href="#l5.1036"></a><span id="l5.1036"> }</span>
<a href="#l5.1037"></a><span id="l5.1037"> </span>
<a href="#l5.1038"></a><span id="l5.1038"> PRBool nsImapProtocol::TryToLogon()</span>
<a href="#l5.1039"></a><span id="l5.1039"> {</span>
<a href="#l5.1040"></a><span id="l5.1040">   PR_LOG(IMAP, PR_LOG_DEBUG, (&quot;try to log in&quot;));</span>
<a href="#l5.1041"></a><span id="l5.1041">   NS_ENSURE_TRUE(m_imapServerSink, false);</span>
<a href="#l5.1042"></a><span id="l5.1042">   PRBool loginSucceeded = PR_FALSE;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/imap/src/nsImapProtocol.h</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapProtocol.h</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -83,16 +83,17 @@</span>
<a href="#l6.4"></a><span id="l6.4"> #include &quot;nsICacheListener.h&quot;</span>
<a href="#l6.5"></a><span id="l6.5"> #include &quot;nsIImapHeaderXferInfo.h&quot;</span>
<a href="#l6.6"></a><span id="l6.6"> #include &quot;nsMsgLineBuffer.h&quot;</span>
<a href="#l6.7"></a><span id="l6.7"> #include &quot;nsIAsyncInputStream.h&quot;</span>
<a href="#l6.8"></a><span id="l6.8"> #include &quot;nsITimer.h&quot;</span>
<a href="#l6.9"></a><span id="l6.9"> #include &quot;nsAutoPtr.h&quot;</span>
<a href="#l6.10"></a><span id="l6.10"> #include &quot;nsIMsgFolder.h&quot;</span>
<a href="#l6.11"></a><span id="l6.11"> #include &quot;nsIMsgAsyncPrompter.h&quot;</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+#include &quot;mozilla/Monitor.h&quot;</span>
<a href="#l6.13"></a><span id="l6.13"> </span>
<a href="#l6.14"></a><span id="l6.14"> class nsIMAPMessagePartIDArray;</span>
<a href="#l6.15"></a><span id="l6.15"> class nsIMsgIncomingServer;</span>
<a href="#l6.16"></a><span id="l6.16"> class nsIPrefBranch;</span>
<a href="#l6.17"></a><span id="l6.17"> </span>
<a href="#l6.18"></a><span id="l6.18"> #define kDownLoadCacheSize 16000 // was 1536 - try making it bigger</span>
<a href="#l6.19"></a><span id="l6.19"> </span>
<a href="#l6.20"></a><span id="l6.20"> </span>
<a href="#l6.21"></a><span id="l6.21" class="difflineat">@@ -371,26 +372,26 @@ private:</span>
<a href="#l6.22"></a><span id="l6.22">   nsCOMPtr&lt;nsIImapMockChannel&gt;    m_mockChannel;   // this is the channel we should forward to people</span>
<a href="#l6.23"></a><span id="l6.23">   //nsCOMPtr&lt;nsIRequest&gt; mAsyncReadRequest; // we're going to cancel this when we're done with the conn.</span>
<a href="#l6.24"></a><span id="l6.24"> </span>
<a href="#l6.25"></a><span id="l6.25"> </span>
<a href="#l6.26"></a><span id="l6.26">   // ******* Thread support *******</span>
<a href="#l6.27"></a><span id="l6.27">   nsCOMPtr&lt;nsIEventTarget&gt; m_sinkEventTarget;</span>
<a href="#l6.28"></a><span id="l6.28">   nsCOMPtr&lt;nsIThread&gt;      m_iThread;</span>
<a href="#l6.29"></a><span id="l6.29">   PRThread     *m_thread;</span>
<a href="#l6.30"></a><span id="l6.30" class="difflineminus">-  PRMonitor    *m_dataAvailableMonitor;   // used to notify the arrival of data from the server</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineminus">-  PRMonitor    *m_urlReadyToRunMonitor;   // used to notify the arrival of a new url to be processed</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineminus">-  PRMonitor    *m_pseudoInterruptMonitor;</span>
<a href="#l6.33"></a><span id="l6.33" class="difflineminus">-  PRMonitor    *m_dataMemberMonitor;</span>
<a href="#l6.34"></a><span id="l6.34" class="difflineminus">-  PRMonitor    *m_threadDeathMonitor;</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineminus">-  PRMonitor    *m_waitForBodyIdsMonitor;</span>
<a href="#l6.36"></a><span id="l6.36" class="difflineminus">-  PRMonitor    *m_fetchMsgListMonitor;</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineminus">-  PRMonitor   *m_fetchBodyListMonitor;</span>
<a href="#l6.38"></a><span id="l6.38" class="difflineminus">-  PRMonitor   *m_passwordReadyMonitor;</span>
<a href="#l6.39"></a><span id="l6.39" class="difflineminus">-</span>
<a href="#l6.40"></a><span id="l6.40" class="difflineplus">+  mozilla::Monitor m_dataAvailableMonitor;   // used to notify the arrival of data from the server</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineplus">+  mozilla::Monitor m_urlReadyToRunMonitor;   // used to notify the arrival of a new url to be processed</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineplus">+  mozilla::Monitor m_pseudoInterruptMonitor;</span>
<a href="#l6.43"></a><span id="l6.43" class="difflineplus">+  mozilla::Monitor m_dataMemberMonitor;</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineplus">+  mozilla::Monitor m_threadDeathMonitor;</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineplus">+  mozilla::Monitor m_waitForBodyIdsMonitor;</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineplus">+  mozilla::Monitor m_fetchMsgListMonitor;</span>
<a href="#l6.47"></a><span id="l6.47" class="difflineplus">+  mozilla::Monitor m_fetchBodyListMonitor;</span>
<a href="#l6.48"></a><span id="l6.48" class="difflineplus">+  mozilla::Monitor m_passwordReadyMonitor;</span>
<a href="#l6.49"></a><span id="l6.49" class="difflineplus">+  mozilla::Mutex mLock;</span>
<a href="#l6.50"></a><span id="l6.50">   // If we get an async password prompt, this is where the UI thread</span>
<a href="#l6.51"></a><span id="l6.51">   // stores the password, before notifying the imap thread of the password</span>
<a href="#l6.52"></a><span id="l6.52">   // via the m_passwordReadyMonitor.</span>
<a href="#l6.53"></a><span id="l6.53">   nsCString m_password;</span>
<a href="#l6.54"></a><span id="l6.54">   // Set to the result of nsImapServer::PromptPassword</span>
<a href="#l6.55"></a><span id="l6.55">   nsresult    m_passwordStatus;</span>
<a href="#l6.56"></a><span id="l6.56"> </span>
<a href="#l6.57"></a><span id="l6.57">   PRBool       m_imapThreadIsRunning;</span>
<a href="#l6.58"></a><span id="l6.58" class="difflineat">@@ -407,17 +408,16 @@ private:</span>
<a href="#l6.59"></a><span id="l6.59">   nsCOMPtr&lt;nsIImapProtocolSink&gt;       m_imapProtocolSink;</span>
<a href="#l6.60"></a><span id="l6.60"> </span>
<a href="#l6.61"></a><span id="l6.61">   // helper function to setup imap sink interface proxies</span>
<a href="#l6.62"></a><span id="l6.62">   void SetupSinkProxy();</span>
<a href="#l6.63"></a><span id="l6.63">   // End thread support stuff</span>
<a href="#l6.64"></a><span id="l6.64"> </span>
<a href="#l6.65"></a><span id="l6.65">   PRBool GetDeleteIsMoveToTrash();</span>
<a href="#l6.66"></a><span id="l6.66">   PRBool GetShowDeletedMessages();</span>
<a href="#l6.67"></a><span id="l6.67" class="difflineminus">-  PRMonitor *GetDataMemberMonitor();</span>
<a href="#l6.68"></a><span id="l6.68">   nsCString m_currentCommand;</span>
<a href="#l6.69"></a><span id="l6.69">   nsImapServerResponseParser m_parser;</span>
<a href="#l6.70"></a><span id="l6.70">   nsImapServerResponseParser&amp; GetServerStateParser() { return m_parser; }</span>
<a href="#l6.71"></a><span id="l6.71"> </span>
<a href="#l6.72"></a><span id="l6.72">   void HandleIdleResponses();</span>
<a href="#l6.73"></a><span id="l6.73">   virtual PRBool ProcessCurrentURL();</span>
<a href="#l6.74"></a><span id="l6.74">   void EstablishServerConnection();</span>
<a href="#l6.75"></a><span id="l6.75">   virtual void ParseIMAPandCheckForNewMail(const char* commandString =</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/imap/src/nsImapUrl.cpp</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapUrl.cpp</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -47,33 +47,34 @@</span>
<a href="#l7.4"></a><span id="l7.4"> #include &quot;prmem.h&quot;</span>
<a href="#l7.5"></a><span id="l7.5"> #include &quot;plstr.h&quot;</span>
<a href="#l7.6"></a><span id="l7.6"> #include &quot;prprf.h&quot;</span>
<a href="#l7.7"></a><span id="l7.7"> #include &quot;nsCRT.h&quot;</span>
<a href="#l7.8"></a><span id="l7.8"> #include &quot;nsCOMPtr.h&quot;</span>
<a href="#l7.9"></a><span id="l7.9"> #include &quot;nsIImapIncomingServer.h&quot;</span>
<a href="#l7.10"></a><span id="l7.10"> #include &quot;nsMsgBaseCID.h&quot;</span>
<a href="#l7.11"></a><span id="l7.11"> #include &quot;nsImapUtils.h&quot;</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-#include &quot;nsAutoLock.h&quot;</span>
<a href="#l7.13"></a><span id="l7.13"> #include &quot;nsIMAPNamespace.h&quot;</span>
<a href="#l7.14"></a><span id="l7.14"> #include &quot;nsICacheEntryDescriptor.h&quot;</span>
<a href="#l7.15"></a><span id="l7.15"> #include &quot;nsISupportsObsolete.h&quot;</span>
<a href="#l7.16"></a><span id="l7.16"> #include &quot;nsIMsgFolder.h&quot;</span>
<a href="#l7.17"></a><span id="l7.17"> #include &quot;nsIDocShell.h&quot;</span>
<a href="#l7.18"></a><span id="l7.18"> #include &quot;nsIInterfaceRequestor.h&quot;</span>
<a href="#l7.19"></a><span id="l7.19"> #include &quot;nsIInterfaceRequestorUtils.h&quot;</span>
<a href="#l7.20"></a><span id="l7.20"> #include &quot;nsMsgUtils.h&quot;</span>
<a href="#l7.21"></a><span id="l7.21"> #include &quot;nsIMsgHdr.h&quot;</span>
<a href="#l7.22"></a><span id="l7.22"> #include &quot;nsIProgressEventSink.h&quot;</span>
<a href="#l7.23"></a><span id="l7.23"> #include &quot;nsAlgorithm.h&quot;</span>
<a href="#l7.24"></a><span id="l7.24"> #include &quot;nsServiceManagerUtils.h&quot;</span>
<a href="#l7.25"></a><span id="l7.25"> </span>
<a href="#l7.26"></a><span id="l7.26" class="difflineplus">+using namespace mozilla;</span>
<a href="#l7.27"></a><span id="l7.27" class="difflineplus">+</span>
<a href="#l7.28"></a><span id="l7.28"> static NS_DEFINE_CID(kCImapHostSessionListCID, NS_IIMAPHOSTSESSIONLIST_CID);</span>
<a href="#l7.29"></a><span id="l7.29"> </span>
<a href="#l7.30"></a><span id="l7.30" class="difflineminus">-nsImapUrl::nsImapUrl()</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineplus">+nsImapUrl::nsImapUrl() : mLock(&quot;nsImapUrl.mLock&quot;)</span>
<a href="#l7.32"></a><span id="l7.32"> {</span>
<a href="#l7.33"></a><span id="l7.33">   m_listOfMessageIds = nsnull;</span>
<a href="#l7.34"></a><span id="l7.34">   m_sourceCanonicalFolderPathSubString = nsnull;</span>
<a href="#l7.35"></a><span id="l7.35">   m_destinationCanonicalFolderPathSubString = nsnull;</span>
<a href="#l7.36"></a><span id="l7.36">   m_listOfMessageIds = nsnull;</span>
<a href="#l7.37"></a><span id="l7.37">   m_tokenPlaceHolder = nsnull;</span>
<a href="#l7.38"></a><span id="l7.38">   m_searchCriteriaString = nsnull;</span>
<a href="#l7.39"></a><span id="l7.39">   m_idsAreUids = PR_FALSE;</span>
<a href="#l7.40"></a><span id="l7.40" class="difflineat">@@ -281,17 +282,17 @@ NS_IMETHODIMP nsImapUrl::CreateSearchCri</span>
<a href="#l7.41"></a><span id="l7.41">     return  NS_ERROR_NULL_POINTER;</span>
<a href="#l7.42"></a><span id="l7.42">   *aResult = strdup(m_searchCriteriaString);</span>
<a href="#l7.43"></a><span id="l7.43">   return NS_OK;</span>
<a href="#l7.44"></a><span id="l7.44"> }</span>
<a href="#l7.45"></a><span id="l7.45"> </span>
<a href="#l7.46"></a><span id="l7.46"> // this method gets called from the UI thread and the imap thread</span>
<a href="#l7.47"></a><span id="l7.47"> NS_IMETHODIMP nsImapUrl::GetListOfMessageIds(nsACString &amp;aResult)</span>
<a href="#l7.48"></a><span id="l7.48"> {</span>
<a href="#l7.49"></a><span id="l7.49" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l7.50"></a><span id="l7.50" class="difflineplus">+  MutexAutoLock mon(mLock);</span>
<a href="#l7.51"></a><span id="l7.51">   if (!m_listOfMessageIds)</span>
<a href="#l7.52"></a><span id="l7.52">     return  NS_ERROR_NULL_POINTER;</span>
<a href="#l7.53"></a><span id="l7.53"> </span>
<a href="#l7.54"></a><span id="l7.54">   PRInt32 bytesToCopy = strlen(m_listOfMessageIds);</span>
<a href="#l7.55"></a><span id="l7.55"> </span>
<a href="#l7.56"></a><span id="l7.56">   // mime may have glommed a &quot;&amp;part=&quot; for a part download</span>
<a href="#l7.57"></a><span id="l7.57">   // we return the entire message and let mime extract</span>
<a href="#l7.58"></a><span id="l7.58">   // the part. Pop and news work this way also.</span>
<a href="#l7.59"></a><span id="l7.59" class="difflineat">@@ -1042,26 +1043,26 @@ NS_IMETHODIMP  nsImapUrl::CreateServerSo</span>
<a href="#l7.60"></a><span id="l7.60">   AllocateServerPath(m_sourceCanonicalFolderPathSubString, kOnlineHierarchySeparatorUnknown, result);</span>
<a href="#l7.61"></a><span id="l7.61">   return NS_OK;</span>
<a href="#l7.62"></a><span id="l7.62"> }</span>
<a href="#l7.63"></a><span id="l7.63"> </span>
<a href="#l7.64"></a><span id="l7.64"> // this method is called from the imap thread AND the UI thread...</span>
<a href="#l7.65"></a><span id="l7.65"> NS_IMETHODIMP nsImapUrl::CreateCanonicalSourceFolderPathString(char **result)</span>
<a href="#l7.66"></a><span id="l7.66"> {</span>
<a href="#l7.67"></a><span id="l7.67">   NS_ENSURE_ARG_POINTER(result);</span>
<a href="#l7.68"></a><span id="l7.68" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l7.69"></a><span id="l7.69" class="difflineplus">+  MutexAutoLock  mon(mLock);</span>
<a href="#l7.70"></a><span id="l7.70">   *result = strdup(m_sourceCanonicalFolderPathSubString ? m_sourceCanonicalFolderPathSubString : &quot;&quot;);</span>
<a href="#l7.71"></a><span id="l7.71">   return (*result) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l7.72"></a><span id="l7.72"> }</span>
<a href="#l7.73"></a><span id="l7.73"> </span>
<a href="#l7.74"></a><span id="l7.74"> // this method is called from the imap thread AND the UI thread...</span>
<a href="#l7.75"></a><span id="l7.75"> NS_IMETHODIMP nsImapUrl::CreateServerDestinationFolderPathString(char **result)</span>
<a href="#l7.76"></a><span id="l7.76"> {</span>
<a href="#l7.77"></a><span id="l7.77">   NS_ENSURE_ARG_POINTER(result);</span>
<a href="#l7.78"></a><span id="l7.78" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l7.79"></a><span id="l7.79" class="difflineplus">+  MutexAutoLock mon(mLock);</span>
<a href="#l7.80"></a><span id="l7.80">   nsresult rv = AllocateServerPath(m_destinationCanonicalFolderPathSubString,</span>
<a href="#l7.81"></a><span id="l7.81">                                    kOnlineHierarchySeparatorUnknown,</span>
<a href="#l7.82"></a><span id="l7.82">                                    result);</span>
<a href="#l7.83"></a><span id="l7.83">   return (*result) ? rv : NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l7.84"></a><span id="l7.84"> }</span>
<a href="#l7.85"></a><span id="l7.85"> </span>
<a href="#l7.86"></a><span id="l7.86"> // for enabling or disabling mime parts on demand. Setting this to PR_TRUE says we</span>
<a href="#l7.87"></a><span id="l7.87"> // can use mime parts on demand, if we chose.</span>
<a href="#l7.88"></a><span id="l7.88" class="difflineat">@@ -1135,48 +1136,48 @@ NS_IMETHODIMP nsImapUrl::GetMimePartSele</span>
<a href="#l7.89"></a><span id="l7.89">   *mimePartSelectorDetected = m_mimePartSelectorDetected;</span>
<a href="#l7.90"></a><span id="l7.90">   return NS_OK;</span>
<a href="#l7.91"></a><span id="l7.91"> }</span>
<a href="#l7.92"></a><span id="l7.92"> </span>
<a href="#l7.93"></a><span id="l7.93"> </span>
<a href="#l7.94"></a><span id="l7.94"> // this method is only called from the UI thread.</span>
<a href="#l7.95"></a><span id="l7.95"> NS_IMETHODIMP nsImapUrl::SetCopyState(nsISupports* copyState)</span>
<a href="#l7.96"></a><span id="l7.96"> {</span>
<a href="#l7.97"></a><span id="l7.97" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l7.98"></a><span id="l7.98" class="difflineplus">+  MutexAutoLock  mon(mLock);</span>
<a href="#l7.99"></a><span id="l7.99">   m_copyState = copyState;</span>
<a href="#l7.100"></a><span id="l7.100">   return NS_OK;</span>
<a href="#l7.101"></a><span id="l7.101"> }</span>
<a href="#l7.102"></a><span id="l7.102"> </span>
<a href="#l7.103"></a><span id="l7.103"> //this method is only called from the imap thread..but we still</span>
<a href="#l7.104"></a><span id="l7.104"> // need a monitor 'cause the setter is called from the UI thread.</span>
<a href="#l7.105"></a><span id="l7.105"> NS_IMETHODIMP nsImapUrl::GetCopyState(nsISupports** copyState)</span>
<a href="#l7.106"></a><span id="l7.106"> {</span>
<a href="#l7.107"></a><span id="l7.107">   NS_ENSURE_ARG_POINTER(copyState);</span>
<a href="#l7.108"></a><span id="l7.108" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l7.109"></a><span id="l7.109" class="difflineplus">+  MutexAutoLock mon(mLock);</span>
<a href="#l7.110"></a><span id="l7.110">   *copyState = m_copyState;</span>
<a href="#l7.111"></a><span id="l7.111">   NS_IF_ADDREF(*copyState);</span>
<a href="#l7.112"></a><span id="l7.112"> </span>
<a href="#l7.113"></a><span id="l7.113">   return NS_OK;</span>
<a href="#l7.114"></a><span id="l7.114"> }</span>
<a href="#l7.115"></a><span id="l7.115"> </span>
<a href="#l7.116"></a><span id="l7.116"> NS_IMETHODIMP</span>
<a href="#l7.117"></a><span id="l7.117"> nsImapUrl::SetMsgFile(nsIFile* aFile)</span>
<a href="#l7.118"></a><span id="l7.118"> {</span>
<a href="#l7.119"></a><span id="l7.119">   nsresult rv = NS_OK;</span>
<a href="#l7.120"></a><span id="l7.120" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l7.121"></a><span id="l7.121" class="difflineplus">+  MutexAutoLock mon(mLock);</span>
<a href="#l7.122"></a><span id="l7.122">   m_file = aFile;</span>
<a href="#l7.123"></a><span id="l7.123">   return rv;</span>
<a href="#l7.124"></a><span id="l7.124"> }</span>
<a href="#l7.125"></a><span id="l7.125"> </span>
<a href="#l7.126"></a><span id="l7.126"> NS_IMETHODIMP</span>
<a href="#l7.127"></a><span id="l7.127"> nsImapUrl::GetMsgFile(nsIFile** aFile)</span>
<a href="#l7.128"></a><span id="l7.128"> {</span>
<a href="#l7.129"></a><span id="l7.129">   NS_ENSURE_ARG_POINTER(aFile);</span>
<a href="#l7.130"></a><span id="l7.130"> </span>
<a href="#l7.131"></a><span id="l7.131" class="difflineminus">-  nsAutoCMonitor mon(this);</span>
<a href="#l7.132"></a><span id="l7.132" class="difflineplus">+  MutexAutoLock mon(mLock);</span>
<a href="#l7.133"></a><span id="l7.133">   NS_IF_ADDREF(*aFile = m_file);</span>
<a href="#l7.134"></a><span id="l7.134">   return NS_OK;</span>
<a href="#l7.135"></a><span id="l7.135"> }</span>
<a href="#l7.136"></a><span id="l7.136"> </span>
<a href="#l7.137"></a><span id="l7.137"> // this method is called from the UI thread..</span>
<a href="#l7.138"></a><span id="l7.138"> NS_IMETHODIMP nsImapUrl::GetMockChannel(nsIImapMockChannel ** aChannel)</span>
<a href="#l7.139"></a><span id="l7.139"> {</span>
<a href="#l7.140"></a><span id="l7.140">   NS_ENSURE_ARG_POINTER(aChannel);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/imap/src/nsImapUrl.h</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapUrl.h</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -44,16 +44,17 @@</span>
<a href="#l8.4"></a><span id="l8.4"> #include &quot;nsMsgMailNewsUrl.h&quot;</span>
<a href="#l8.5"></a><span id="l8.5"> #include &quot;nsIMsgIncomingServer.h&quot;</span>
<a href="#l8.6"></a><span id="l8.6"> #include &quot;nsIImapMailFolderSink.h&quot;</span>
<a href="#l8.7"></a><span id="l8.7"> #include &quot;nsIImapServerSink.h&quot;</span>
<a href="#l8.8"></a><span id="l8.8"> #include &quot;nsIImapMessageSink.h&quot;</span>
<a href="#l8.9"></a><span id="l8.9"> </span>
<a href="#l8.10"></a><span id="l8.10"> #include &quot;nsWeakPtr.h&quot;</span>
<a href="#l8.11"></a><span id="l8.11"> #include &quot;nsIFile.h&quot;</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+#include &quot;mozilla/Mutex.h&quot;</span>
<a href="#l8.13"></a><span id="l8.13"> </span>
<a href="#l8.14"></a><span id="l8.14"> class nsImapUrl : public nsIImapUrl, public nsMsgMailNewsUrl, public nsIMsgMessageUrl, public nsIMsgI18NUrl</span>
<a href="#l8.15"></a><span id="l8.15"> {</span>
<a href="#l8.16"></a><span id="l8.16"> public:</span>
<a href="#l8.17"></a><span id="l8.17"> </span>
<a href="#l8.18"></a><span id="l8.18">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l8.19"></a><span id="l8.19"> </span>
<a href="#l8.20"></a><span id="l8.20">   // nsIURI override</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineat">@@ -150,11 +151,12 @@ protected:</span>
<a href="#l8.22"></a><span id="l8.22"> </span>
<a href="#l8.23"></a><span id="l8.23">   // used by save message to disk</span>
<a href="#l8.24"></a><span id="l8.24">   nsCOMPtr&lt;nsIFile&gt; m_messageFile;</span>
<a href="#l8.25"></a><span id="l8.25">   PRBool                m_addDummyEnvelope;</span>
<a href="#l8.26"></a><span id="l8.26">   PRBool                m_canonicalLineEnding; // CRLF</span>
<a href="#l8.27"></a><span id="l8.27"> </span>
<a href="#l8.28"></a><span id="l8.28">   nsCString mURI; // the RDF URI associated with this url.</span>
<a href="#l8.29"></a><span id="l8.29">   nsCString mCharsetOverride; // used by nsIMsgI18NUrl...</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineplus">+  mozilla::Mutex mLock;</span>
<a href="#l8.31"></a><span id="l8.31"> };</span>
<a href="#l8.32"></a><span id="l8.32"> </span>
<a href="#l8.33"></a><span id="l8.33"> #endif /* nsImapUrl_h___ */</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

